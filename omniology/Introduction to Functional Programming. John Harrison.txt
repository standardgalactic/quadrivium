In
tro
duction
to
F
unctional
Programming
John
Harrison
jrhclcamac
uk
rd
Decem
b
er
		

i

Preface
These
are
the
lecture
notes
accompan
ying
the
course
Intr
o
duction
to
F
unctional
Pr
o
gr
amming
whic
h
I
taugh
t
at
Cam
bridge
Univ
ersit
y
in
the
academic
y
ear
		
This
course
has
mainly
b
een
taugh
t
in
previous
y
ears
b
y
Mik
e
Gordon
I
ha
v
e
retained
the
basic
structure
of
his
course
with
a
blend
of
theory
and
practice
and
ha
v
e
b
orro
w
ed
hea
vily
in
what
follo
ws
from
his
o
wn
lecture
notes
a
v
ailable
in
b
o
ok
form
as
P
art
I
I
of
	Gordon
	
I
ha
v
e
also
b
een
inuenced
b
y
those
who
ha
v
e
taugh
t
related
courses
here
suc
h
as
Andy
Gordon
and
Larry
P
aulson
and
in
the
c
hapter
on
t
yp
es
b
y
Andy
Pittss
course
on
the
sub
ject
The
large
c
hapter
on
examples
is
not
directly
examinable
though
studying
it
should
impro
v
e
the
readers
grasp
of
the
early
parts
and
giv
e
a
b
etter
idea
ab
out
ho
w
ML
is
actually
used
Most
c
hapters
include
some
exercises
either
in
v
en
ted
sp
ecially
for
this
course
or
tak
en
from
v
arious
sources
They
are
normally
in
tended
to
require
a
little
though
t
rather
than
just
b
eing
routine
drill
Those
I
consider
fairly
dicult
are
mark
ed
with
a
	
These
notes
ha
v
e
not
y
et
b
een
tested
extensiv
ely
and
no
doubt
con
tain
v
arious
errors
and
obscurities
I
w
ould
b
e
grateful
for
constructiv
e
criticism
from
an
y
readers
John
Harrison
	jrhclcamacuk
ii

Plan
of
the
lectures
This
c
hapter
indicates
roughly
ho
w
the
material
is
to
b
e
distributed
o
v
er
a
course
of
t
w
elv
e
lectures
eac
h
of
sligh
tly
less
than
one
hour

In
tro
duction
and
Ov
erview
F
unctional
and
imp
erativ
e
programming
con
trast
pros
and
cons
General
structure
of
the
course
ho
w
lam
b
da
cal
culus
turns
out
to
b
e
a
general
programming
language
Lam
b
da
notation
ho
w
it
claries
v
ariable
binding
and
pro
vides
a
general
analysis
of
mathe
matical
notation
Currying
Russells
parado
x

Lam
b
da
calculus
as
a
formal
system
F
ree
and
b
ound
v
ariables
Sub
stitution
Con
v
ersion
rules
Lam
b
da
equalit
y

Extensionalit
y

Reduction
and
reduction
strategies
The
Ch
urc
hRosser
theorem
statemen
t
and
con
sequences
Com
binators

Lam
b
da
calculus
as
a
programming
language
Computabilit
y
bac
k
ground
T
uring
completeness
	no
pro
of

Represen
ting
data
and
basic
op
erations
truth
v
alues
pairs
and
tuples
natural
n
um
b
ers
The
predecessor
op
eration
W
riting
recursiv
e
functions
xed
p
oin
t
com
binators
Let
ex
pressions
Lam
b
da
calculus
as
a
declarativ
e
language

T
yp
es
Wh
y
t
yp
es
Answ
ers
from
programming
and
logic
Simply
t
yp
ed
lam
b
da
calculus
Ch
urc
h
and
Curry
t
yping
Let
p
olymorphism
Most
general
t
yp
es
and
Milners
algorithm
Strong
normalization
	no
pro
of

and
its
negativ
e
consequences
for
T
uring
completeness
Adding
a
recursion
op
erator

ML
ML
as
t
yp
ed
lam
b
da
calculus
with
eager
ev
aluation
Details
of
ev
alu
ation
strategy

The
conditional
The
ML
family

Practicalities
of
in
teract
ing
with
ML
W
riting
functions
Bindings
and
declarations
Recursiv
e
and
p
olymorphic
functions
Comparison
of
functions

Details
of
ML
More
ab
out
in
teraction
with
ML
Loading
from
les
Com
men
ts
Basic
data
t
yp
es
unit
b
o
oleans
n
um
b
ers
and
strings
Builtin
op
erations
Concrete
syn
tax
and
inxes
More
examples
Recursiv
e
t
yp
es
and
pattern
matc
hing
Examples
lists
and
recursiv
e
functions
on
lists
iii

iv

Pro
ving
programs
correct
The
correctness
problem
T
esting
and
v
eri
cation
The
limits
of
v
erication
F
unctional
programs
as
mathematical
ob
jects
Examples
of
program
pro
ofs
exp
onen
tial
GCD
app
end
and
re
v
erse

Eectiv
e
ML
Using
standard
com
binators
List
iteration
and
other
useful
com
binators
examples
T
ail
recursion
and
accum
ulators
wh
y
tail
recursion
is
more
ecien
t
F
orcing
ev
aluation
Minimizing
consing
More
ecien
t
rev
ersal
Use
of
as
Imp
erativ
e
features
exceptions
references
arra
ys
and
sequencing
Imp
erativ
e
features
and
t
yp
es
the
v
alue
restriction
	
ML
examples
I
sym
b
olic
dieren
tiation
Sym
b
olic
computation
Data
represen
tation
Op
erator
precedence
Asso
ciation
lists
Prett
yprin
ting
expressions
Installing
the
prin
ter
Dieren
tiation
Simplication
The
problem
of
the
righ
t
simplication

ML
examples
I
I
recursiv
e
descen
t
parsing
Grammars
and
the
parsing
problem
Fixing
am
biguit
y

Recursiv
e
descen
t
P
arsers
in
ML
P
arser
com
binators
examples
Lexical
analysis
using
the
same
tec
hniques
A
parser
for
terms
Automating
precedence
parsing
Av
oiding
bac
ktrac
king
Comparison
with
other
tec
hniques

ML
examples
I
I
I
exact
real
arithmetic
Real
n
um
b
ers
and
nite
repre
sen
tations
Real
n
um
b
ers
as
programs
or
functions
Our
represen
tation
of
reals
Arbitrary
precision
in
tegers
Injecting
in
tegers
in
to
the
reals
Nega
tion
and
absolute
v
alue
Addition
the
imp
ortance
of
rounding
division
Multiplication
and
division
b
y
in
tegers
General
m
ultiplication
In
v
erse
and
division
Ordering
and
equalit
y

T
esting
Av
oiding
reev
aluation
through
memo
functions

ML
examples
IV
Prolog
and
theorem
pro
ving
Prolog
terms
Case
sensitiv
e
lexing
P
arsing
and
prin
ting
including
list
syn
tax
Unication
Bac
ktrac
king
searc
h
Prolog
examples
Prologst
yle
theorem
pro
ving
Ma
nipulating
form
ulas
negation
normal
form
Basic
pro
v
er
the
use
of
con
tin
uations
Examples
P
elletier
problems
and
who
dunit

Con
ten
ts

In
tro
duction


The
merits
of
functional
programming

















Outline



































Lam
b
da
calculus


The
b
enets
of
lam
b
da
notation





















Russells
parado
x





























Lam
b
da
calculus
as
a
formal
system



















Lam
b
da
terms



























F
ree
and
b
ound
v
ariables





















Substitution




























Con
v
ersions




























Lam
b
da
equalit
y

























Extensionalit
y



























Lam
b
da
reduction
























Reduction
strategies





















	
	
The
Ch
urc
hRosser
theorem

















	

Com
binators
































Lam
b
da
calculus
as
a
programming
language


Represen
ting
data
in
lam
b
da
calculus


















T
ruth
v
alues
and
the
conditional
















P
airs
and
tuples


























The
natural
n
um
b
ers





















	

Recursiv
e
functions




























Let
expressions






























Steps
to
w
ards
a
real
programming
language














F
urther
reading






























T
yp
es


T
yp
ed
lam
b
da
calculus
























	

The
sto
c
k
of
t
yp
es
























Ch
urc
h
and
Curry
t
yping



















v

vi
CONTENTS

F
ormal
t
ypabilit
y
rules






















T
yp
e
preserv
ation

























P
olymorphism































Let
p
olymorphism
























Most
general
t
yp
es
























Strong
normalization



























A
taste
of
ML


Eager
ev
aluation





























Consequences
of
eager
ev
aluation




















The
ML
family






























Starting
up
ML






























In
teracting
with
ML



























Bindings
and
declarations
























P
olymorphic
functions


























Equalit
y
of
functions



























F
urther
ML


Basic
datat
yp
es
and
op
erations





















Syn
tax
of
ML
phrases


























F
urther
examples





























T
yp
e
denitions






























P
attern
matc
hing

























Recursiv
e
t
yp
es


























T
ree
structures


























The
subtlet
y
of
recursiv
e
t
yp
es

















Pro
ving
programs
correct


F
unctional
programs
as
mathematical
ob
jects













Exp
onen
tiation






























Greatest
common
divisor

























App
ending

































Rev
ersing

































Eectiv
e
ML
	

Useful
com
binators


























	

W
riting
ecien
t
co
de

























	

T
ail
recursion
and
accum
ulators















	

Minimizing
consing






















	

F
orcing
ev
aluation
























Imp
erativ
e
features




























Exceptions





























References
and
arra
ys























CONTENTS
vii

Sequencing




























In
teraction
with
the
t
yp
e
system















	
Examples
	
	
Sym
b
olic
dieren
tiation























	
	
First
order
terms
























	
Prin
ting





























	
Deriv
ativ
es



























	
Simplication


























	
P
arsing


































	
Recursiv
e
descen
t
parsing



















	
P
arser
com
binators























	
Lexical
analysis

























	
P
arsing
terms


























	
Automatic
precedence
parsing

















	
Defects
of
our
approac
h




















	
Exact
real
arithmetic


























	
Represen
tation
of
real
n
um
b
ers















	
	
Arbitraryprecision
in
tegers

















	
	
Basic
op
erations
























	
General
m
ultiplication





















	
Multiplicativ
e
in
v
erse






















	
Ordering
relations
























	
Cac
hing





























	
Prolog
and
theorem
pro
ving






















	
Prolog
terms


























	
Lexical
analysis

























	
P
arsing





























	
Unication




























	
Bac
ktrac
king


























	
Examples




























	
Theorem
pro
ving























	

Chapter

In
tro
duction
Programs
in
traditional
languages
suc
h
as
F
OR
TRAN
Algol
C
and
Mo
dula
rely
hea
vily
on
mo
difying
the
v
alues
of
a
collection
of
v
ariables
called
the
state
If
w
e
neglect
the
inputoutput
op
erations
and
the
p
ossibilit
y
that
a
program
migh
t
run
con
tin
uously
	eg
the
con
troller
for
a
man
ufacturing
pro
cess
w
e
can
arriv
e
at
the
follo
wing
abstraction
Before
execution
the
state
has
some
initial
v
alue
 
represen
ting
the
inputs
to
the
program
and
when
the
program
has
nished
the
state
has
a
new
v
alue
  including
the
result	s
Moreo
v
er
during
execution
eac
h
command
c
hanges
the
state
whic
h
has
therefore
pro
ceeded
through
some
nite
sequence
of
v
alues
 
    
  
 


  n

  F
or
example
in
a
sorting
program
the
state
initially
includes
an
arra
y
of
v
alues
and
when
the
program
has
nished
the
state
has
b
een
mo
died
in
suc
h
a
w
a
y
that
these
v
alues
are
sorted
while
the
in
termediate
states
represen
t
progress
to
w
ards
this
goal
The
state
is
t
ypically
mo
died
b
y
assignment
commands
often
written
in
the
form
v

E
or
v

E
where
v
is
a
v
ariable
and
E
some
expression
These
commands
can
b
e
executed
in
a
sequen
tial
manner
b
y
writing
them
one
after
the
other
in
the
program
often
separated
b
y
a
semicolon
By
using
statemen
ts
lik
e
if
and
while
one
can
execute
these
commands
conditionally

and
rep
eatedly

dep
ending
on
other
prop
erties
of
the
curren
t
state
The
program
amoun
ts
to
a
set
of
instructions
on
ho
w
to
p
erform
these
state
c
hanges
and
therefore
this
st
yle
of
programming
is
often
called
imp
er
ative
or
pr
o
c
e
dur
al
Corresp
ondingly

the
tra
ditional
languages
in
tended
to
supp
ort
it
are
kno
wn
as
imp
erativ
e
or
pro
cedural
languages
F
unctional
programming
represen
ts
a
radical
departure
from
this
mo
del
Es
sen
tially

a
functional
program
is
simply
an
expression
and
execution
means
ev
aluation
of
the
expression

W
e
can
see
ho
w
this
migh
t
b
e
p
ossible
in
gen

F
unctional
programming
is
often
called
applicativ
e
programming
since
the
basic
mec
ha



CHAPTER

INTR
ODUCTION
eral
terms
as
follo
ws
Assuming
that
an
imp
erativ
e
program
	as
a
whole
is
deterministic
ie
the
output
is
completely
determined
b
y
the
input
w
e
can
sa
y
that
the
nal
state
or
whic
hev
er
fragmen
ts
of
it
are
of
in
terest
is
some
func
tion
of
the
initial
state
sa
y
  
f
	 

In
functional
programming
this
view
is
emphasized
the
program
is
actually
an
expression
that
corresp
onds
to
the
mathematical
function
f

F
unctional
languages
supp
ort
the
construction
of
suc
h
expressions
b
y
allo
wing
rather
p
o
w
erful
functional
constructs
F
unctional
programming
can
b
e
con
trasted
with
imp
erativ
e
programming
ei
ther
in
a
negativ
e
or
a
p
ositiv
e
sense
Negativ
ely

functional
programs
do
not
use
v
ariables

there
is
no
state
Consequen
tly

they
cannot
use
assignmen
ts
since
there
is
nothing
to
assign
to
F
urthermore
the
idea
of
executing
commands
in
sequence
is
meaningless
since
the
rst
command
can
mak
e
no
dierence
to
the
second
there
b
eing
no
state
to
mediate
b
et
w
een
them
P
ositiv
ely
ho
w
ev
er
functional
programs
can
use
functions
in
m
uc
h
more
sophisticated
w
a
ys
F
unc
tions
can
b
e
treated
in
exactly
the
same
w
a
y
as
simpler
ob
jects
lik
e
in
tegers
they
can
b
e
passed
to
other
functions
as
argumen
ts
and
returned
as
results
and
in
general
calculated
with
Instead
of
sequencing
and
lo
oping
functional
languages
use
recursiv
e
functions
ie
functions
that
are
dened
in
terms
of
themselv
es
By
con
trast
most
traditional
languages
pro
vide
p
o
or
facilities
in
these
areas
C
al
lo
ws
some
limited
manipulation
of
functions
via
p
oin
ters
but
do
es
not
allo
w
one
to
create
new
functions
dynamically

F
OR
TRAN
do
es
not
ev
en
supp
ort
recursion
at
all
T
o
illustrate
the
distinction
b
et
w
een
imp
erativ
e
and
functional
programming
the
factorial
function
migh
t
b
e
co
ded
imp
erativ
ely
in
C
	without
using
Cs
un
usual
assignmen
t
op
erations
as
int
factint
n

int
x


while
n



x

x

n
n

n



return
x

whereas
it
w
ould
b
e
expressed
in
ML
the
functional
language
w
e
discuss
later
as
a
recursiv
e
function
let
rec
fact
n

if
n


then

else
n

factn



nism
is
the
applic
ation
of
functions
to
argumen
ts

Compare
Naurs
remarks
Raphael
	
that
he
can
write
an
y
program
in
a
single
state
men
t
O
utput

P
r
og
r
amI
nput



THE
MERITS
OF
FUNCTIONAL
PR
OGRAMMING

In
fact
this
sort
of
denition
can
b
e
used
in
C
to
o
Ho
w
ev
er
for
more
sophis
ticated
uses
of
functions
functional
languages
stand
in
a
class
b
y
themselv
es

The
merits
of
functional
programming
A
t
rst
sigh
t
a
language
without
v
ariables
or
sequencing
migh
t
seem
completely
impractical
This
impression
cannot
b
e
disp
elled
simply
b
y
a
few
w
ords
here
But
w
e
hop
e
that
b
y
studying
the
material
that
follo
ws
readers
will
gain
an
appreciation
of
ho
w
it
is
p
ossible
to
do
a
lot
of
in
teresting
programming
in
the
functional
manner
There
is
nothing
sacred
ab
out
the
imp
erativ
e
st
yle
familiar
though
it
is
Man
y
features
of
imp
erativ
e
languages
ha
v
e
arisen
b
y
a
pro
cess
of
abstraction
from
t
ypical
computer
hardw
are
from
mac
hine
co
de
to
assem
blers
to
macro
as
sem
blers
and
then
to
F
OR
TRAN
and
b
ey
ond
There
is
no
reason
to
supp
ose
that
suc
h
languages
represen
t
the
most
palatable
w
a
y
for
h
umans
to
comm
uni
cate
programs
to
a
mac
hine
After
all
existing
hardw
are
designs
are
not
sacred
either
and
computers
are
supp
osed
to
do
our
bidding
rather
than
con
v
ersely

P
erhaps
the
righ
t
approac
h
is
not
to
start
from
the
hardw
are
and
w
ork
up
w
ards
but
to
start
with
programming
languages
as
an
abstract
notation
for
sp
ecifying
algorithms
and
then
w
ork
down
to
the
hardw
are
	Dijkstra
	
Actually

this
tendency
can
b
e
detected
in
traditional
languages
to
o
Ev
en
F
OR
TRAN
allo
ws
arithmetical
expressions
to
b
e
written
in
the
usual
w
a
y

The
programmer
is
not
burdened
with
the
task
of
linearizing
the
ev
aluation
of
sub
expressions
and
nding
temp
orary
storage
for
in
termediate
results
This
suggests
that
the
idea
of
dev
eloping
programming
languages
quite
dif
feren
t
from
the
traditional
imp
erativ
e
ones
is
certainly
defensible
Ho
w
ev
er
to
emphasize
that
w
e
are
not
merely
prop
osing
c
hange
for
c
hanges
sak
e
w
e
should
sa
y
a
few
w
ords
ab
out
wh
y
w
e
migh
t
prefer
functional
programs
to
imp
erativ
e
ones
P
erhaps
the
main
reason
is
that
functional
programs
corresp
ond
more
directly
to
mathematical
ob
jects
and
it
is
therefore
easier
to
reason
ab
out
them
In
order
to
get
a
rm
grip
on
exactly
what
programs
mean
w
e
migh
t
wish
to
assign
an
abstract
mathematical
meaning
to
a
program
or
command

this
is
the
aim
of
denotational
semantics
	seman
tics

meaning
In
imp
erativ
e
languages
this
has
to
b
e
done
in
a
rather
indirect
w
a
y

b
ecause
of
the
implicit
dep
endency
on
the
v
alue
of
the
state
In
simple
imp
erativ
e
languages
one
can
asso
ciate
a
command
with
a
function

 
where

is
the
set
of
p
ossible
v
alues
for
the
state
That
is
a
command
tak
es
some
state
and
pro
duces
another
state
It
ma
y
fail
to
terminate
	eg
while
true
do
x

x
so
this
function
ma
y
in
general
b
e
partial
Alternativ
e
seman
tics
are
sometimes
preferred
eg
in
terms
of
pr
e
dic
ate
tr
ansformers
	Dijkstra
	
But
if
w
e
add
features
that
can
p
erv
ert
the
execution
sequence
in
more
complex
w
a
ys
eg
goto
or
Cs
break


CHAPTER

INTR
ODUCTION
and
continue
ev
en
these
in
terpretations
no
longer
w
ork
since
one
command
can
cause
the
later
commands
to
b
e
skipp
ed
Instead
one
t
ypically
uses
a
more
complicated
seman
tics
based
on
c
ontinuations
By
con
trast
functional
programs
in
the
w
ords
of
Henson
		
w
ear
their
seman
tics
on
their
sleev
es

W
e
can
illustrate
this
using
ML
The
basic
datat
yp
es
ha
v
e
a
direct
in
terpretation
as
mathematical
ob
jects
Using
the
standard
notation
of

X
 
 
for
the
seman
tics
of
X

w
e
can
sa
y
for
example
that

in
t 
 

Z

No
w
the
ML
function
fact
dened
b
y
let
rec
fact
n

if
n


then

else
n

factn



has
one
argumen
t
of
t
yp
e
int
and
returns
a
v
alue
of
t
yp
e
int
so
it
can
simply
b
e
asso
ciated
with
an
abstract
partial
function
Z
 Z


fact 
 	n

 n!
if
n



otherwise
	Here

denotes
undenedness
since
for
negativ
e
argumen
ts
the
program
fails
to
terminate
This
kind
of
simple
in
terpretation
ho
w
ev
er
fails
in
non
functional
programs
since
socalled
functions
migh
t
not
b
e
functions
at
all
in
the
mathematical
sense
F
or
example
the
standard
C
library
features
a
function
rand
whic
h
returns
dieren
t
pseudorandom
v
alues
on
successiv
e
calls
This
sort
of
thing
can
b
e
implemen
ted
b
y
using
a
lo
cal
static
v
ariable
to
remem
b
er
the
previous
result
eg
int
randvoid

static
int
n


return
n



n



Th
us
one
can
see
the
abandonmen
t
of
v
ariables
and
assignmen
ts
as
the
logical
next
step
after
the
abandonmen
t
of
goto
since
eac
h
step
mak
es
the
seman
tics
simpler
A
simpler
seman
tics
mak
es
reasoning
ab
out
programs
more
straigh
tfor
w
ard
This
op
ens
up
more
p
ossibilities
for
correctness
pro
ofs
and
for
pro
v
ably
correct
transformations
in
to
more
ecien
t
programs
Another
p
oten
tial
adv
an
tage
of
functional
languages
is
the
follo
wing
Since
the
ev
aluation
of
expressions
has
no
sideeect
on
an
y
state
separate
sub
expressions
can
b
e
ev
aluated
in
an
y
order
without
aecting
eac
h
other
This
means
that
functional
programs
ma
y
lend
themselv
es
w
ell
to
parallel
implemen
tation
ie
the
computer
can
automatically
farm
out
dieren
t
sub
expressions
to
dieren
t

More
denotational
seman
tics
can
b
e
seen
as
an
attempt
to
turn
imp
erativ
e
languages
in
to
functional
ones
b
y
making
the
state
explicit


OUTLINE

pro
cessors
By
con
trast
imp
erativ
e
programs
often
imp
ose
a
fairly
rigid
order
of
execution
and
ev
en
the
limited
in
terlea
ving
of
instructions
in
mo
dern
pip
elined
pro
cessors
turns
out
to
b
e
complicated
and
full
of
tec
hnical
problems
Actually

ML
is
not
a
purely
functional
programming
language
it
do
es
ha
v
e
v
ariables
and
assignmen
ts
if
required
Most
of
the
time
w
e
will
w
ork
inside
the
purely
functional
subset
But
ev
en
if
w
e
do
use
assignmen
ts
and
lose
some
of
the
preceding
b
enets
there
are
adv
an
tages
to
o
in
the
more
exible
use
of
functions
that
languages
lik
e
ML
allo
w
Programs
can
often
b
e
expressed
in
a
v
ery
concise
and
elegan
t
st
yle
using
higherorder
functions
	functions
that
op
erate
on
other
functions

Co
de
can
b
e
made
more
general
since
it
can
b
e
parametrized
ev
en
o
v
er
other
functions
F
or
example
a
program
to
add
up
a
list
of
n
um
b
ers
and
a
program
to
m
ultiply
a
list
of
n
um
b
ers
can
b
e
seen
as
instances
of
the
same
pro
gram
parametrized
b
y
the
pairwise
arithmetic
op
eration
and
the
corresp
onding
iden
tit
y

In
one
case
it
is
giv
en
"
and

and
in
the
other
case

and


Finally

functions
can
also
b
e
used
to
represen
t
innite
data
in
a
con
v
enien
t
w
a
y

for
example
w
e
will
sho
w
later
ho
w
to
use
functions
to
p
erform
exact
calculation
with
real
n
um
b
ers
as
distinct
from
oating
p
oin
t
appro
ximations
A
t
the
same
time
functional
programs
are
not
without
their
problems
Since
they
corresp
ond
less
directly
the
the
ev
en
tual
execution
in
hardw
are
it
can
b
e
dicult
to
reason
ab
out
their
exact
usage
of
resources
suc
h
as
time
and
space
Inputoutput
is
also
dicult
to
incorp
orate
neatly
in
to
a
functional
mo
del
though
there
are
ingenious
tec
hniques
based
on
innite
sequences
It
is
up
to
readers
to
decide
after
reading
this
b
o
ok
on
the
merits
of
the
functional
st
yle
W
e
do
not
wish
to
enforce
an
y
ideologies
merely
to
p
oin
t
out
that
there
ar
e
dieren
t
w
a
ys
of
lo
oking
at
programming
and
that
in
the
righ
t
situations
functional
programming
ma
y
ha
v
e
considerable
merits
Most
of
our
examples
are
c
hosen
from
areas
that
migh
t
lo
osely
b
e
describ
ed
as
sym
b
olic
computation
for
w
e
b
eliev
e
that
functional
programs
w
ork
w
ell
in
suc
h
appli
cations
Ho
w
ev
er
as
alw
a
ys
one
should
select
the
most
appropriate
to
ol
for
the
job
It
ma
y
b
e
that
imp
erativ
e
programming
ob
jectorien
ted
programming
or
logic
programming
are
more
suited
to
certain
tasks
Horses
for
courses

Outline
F
or
those
used
to
imp
erativ
e
programming
the
transition
to
functional
program
ming
is
inevitably
dicult
whatev
er
approac
h
is
tak
en
While
some
will
b
e
im

Elegance
is
sub
jectiv
e
and
conciseness
is
not
an
end
in
itself
F
unctional
languages
and
other
languages
lik
e
APL
often
create
a
temptation
to
pro
duce
v
ery
short
tric
ky
co
de
whic
h
is
elegan
t
to
cognoscen
ti
but
obscure
to
outsiders

This
parallels
the
notion
of
abstraction
in
pure
mathematics
eg
that
the
additiv
e
and
m
ultiplicativ
e
structures
o
v
er
n
um
b
ers
are
instances
of
the
abstract
notion
of
a
monoid
This
similarly
a
v
oids
duplication
and
increases
elegance


CHAPTER

INTR
ODUCTION
patien
t
to
get
quic
kly
to
real
programming
w
e
ha
v
e
c
hosen
to
start
with
lam
b
da
calculus
and
sho
w
ho
w
it
can
b
e
seen
as
the
theoretical
underpinning
for
func
tional
languages
This
has
the
merit
of
corresp
onding
quite
w
ell
to
the
actual
historical
line
of
dev
elopmen
t
So
rst
w
e
in
tro
duce
lam
b
da
calculus
and
sho
w
ho
w
what
w
as
originally
in
tended
as
a
formal
logical
system
for
mathematics
turned
out
to
b
e
a
completely
general
programming
language
W
e
then
discuss
wh
y
w
e
migh
t
w
an
t
to
add
t
yp
es
to
lam
b
da
calculus
and
sho
w
ho
w
it
can
b
e
done
This
leads
us
in
to
ML
whic
h
is
essen
tially
an
extended
and
optimized
implemen
tation
of
t
yp
ed
lam
b
da
calculus
with
a
certain
ev
aluation
strategy

W
e
co
v
er
the
practicalities
of
basic
functional
programming
in
ML
and
discuss
p
olymorphism
and
most
general
t
yp
es
W
e
then
mo
v
e
on
to
more
adv
anced
topics
including
exceptions
and
MLs
imp
erativ
e
features
W
e
conclude
with
some
substan
tial
examples
whic
h
w
e
hop
e
pro
vide
evidence
for
the
p
o
w
er
of
ML
F
urther
reading
Numerous
textb
o
oks
on
functional
programming
include
a
general
in
tro
duction
to
the
eld
and
a
con
trast
with
imp
erativ
e
programming

bro
wse
through
a
few
and
nd
one
that
y
ou
lik
e
F
or
example
Henson
		
con
tains
a
go
o
d
in
tro
ductory
discussion
and
features
a
similar
mixture
of
theory
and
practice
to
this
text
A
detailed
and
p
olemical
adv
o
cacy
of
the
functional
st
yle
is
giv
en
b
y
Bac
kus
		
the
main
in
v
en
tor
of
F
OR
TRAN
Gordon
			
discusses
the
problems
of
incorp
orating
inputoutput
in
to
functional
languages
and
some
solu
tions
Readers
in
terested
in
denotational
seman
tics
for
imp
erativ
e
and
functional
languages
ma
y
lo
ok
at
Winsk
el
			

Chapter

Lam
b
da
calculus
Lam
b
da
calculus
is
based
on
the
socalled
lam
b
da
notation
for
denoting
func
tions
In
informal
mathematics
when
one
w
an
ts
to
refer
to
a
function
one
usually
rst
giv
es
the
function
an
arbitrary
name
and
thereafter
uses
that
name
eg
Supp
ose
f

R
 R
is
dened
b
y
f
	x

 
if
x


x

sin	x


if
x


Then
f
 	x
is
not
Leb
esgue
in
tegrable
o
v
er
the
unit
in
terv
al

 
Most
programming
languages
C
for
example
are
similar
in
this
resp
ect
w
e
can
dene
functions
only
b
y
giving
them
names
F
or
example
in
order
to
use
the
successor
function
	whic
h
adds

to
its
argumen
t
in
non
trivial
w
a
ys
	eg
consider
a
p
oin
ter
to
it
then
ev
en
though
it
is
v
ery
simple
w
e
need
to
name
it
via
some
function
denition
suc
h
as
int
sucint
n

return
n



In
either
mathematics
or
programming
this
seems
quite
natural
and
gener
ally
w
orks
w
ell
enough
Ho
w
ev
er
it
can
get
clumsy
when
higher
order
functions
	functions
that
manipulate
other
functions
are
in
v
olv
ed
In
an
y
case
if
w
e
w
an
t
to
treat
functions
on
a
par
with
other
mathematical
ob
jects
the
insistence
on
naming
is
rather
inconsisten
t
When
discussing
an
arithmetical
expression
built
up
from
simpler
ones
w
e
just
write
the
sub
expressions
do
wn
without
needing
to
giv
e
them
names
Imagine
if
w
e
alw
a
ys
had
to
deal
with
arithmetic
expressions
in
this
w
a
y
Dene
x
and
y
b
y
x


and
y


resp
ectiv
ely

Then
xx

y




CHAPTER

LAMBD
A
CALCULUS
Lam
b
da
notation
allo
ws
one
to
denote
functions
in
m
uc
h
the
same
w
a
y
as
an
y
other
sort
of
mathematical
ob
ject
There
is
a
mainstream
notation
sometimes
used
in
mathematics
for
this
purp
ose
though
its
normally
still
used
as
part
of
the
denition
of
a
temp
orary
name
W
e
can
write
x
 tx 
to
denote
the
function
mapping
an
y
argumen
t
x
to
some
arbitrary
expression
tx 
whic
h
usually

but
not
necessarily

con
tains
x
	it
is
o
ccasionally
useful
to
#thro
w
a
w
a
y$
an
argumen
t
Ho
w
ev
er
w
e
shall
use
a
dieren
t
notation
dev
elop
ed
b
y
Ch
urc
h
		
x
tx 
whic
h
should
b
e
read
in
the
same
w
a
y

F
or
example
x
x
is
the
iden
tit
y
function
whic
h
simply
returns
its
argumen
t
while
x
x

is
the
squaring
function
The
sym
b
ol

is
completely
arbitrary

and
no
signicance
should
b
e
read
in
to
it
	Indeed
one
often
sees
particularly
in
F
renc
h
texts
the
alternativ
e
notation
x 
tx 
Apparen
tly
it
arose
b
y
a
complicated
pro
cess
of
ev
olution
Originally

the
famous
Principia
Mathematic
a
	Whitehead
and
Russell
	
used
the
hat
notation
t
%
x 
for
the
function
of
x
yielding
tx 
Ch
urc
h
mo
died
this
to
%
x
tx 
but
since
the
t
yp
esetter
could
not
place
the
hat
on
top
of
the
x
this
app
eared
as
x
tx 
whic
h
then
m
utated
in
to
x
tx 
in
the
hands
of
another
t
yp
esetter

The
b
enets
of
lam
b
da
notation
Using
lam
b
da
notation
w
e
can
clear
up
some
of
the
confusion
engendered
b
y
informal
mathematical
notation
F
or
example
its
common
to
talk
sloppily
ab
out
f
	x
lea
ving
con
text
to
determine
whether
w
e
mean
f
itself
or
the
result
of
applying
it
to
particular
x
A
further
b
enet
is
that
lam
b
da
notation
giv
es
an
attractiv
e
analysis
of
practically
the
whole
of
mathematical
notation
If
w
e
start
with
v
ariables
and
constan
ts
and
build
up
expressions
using
just
lam
b
da
abstraction
and
application
of
functions
to
argumen
ts
w
e
can
represen
t
v
ery
complicated
mathematical
expressions
W
e
will
use
the
con
v
en
tional
notation
f
	x
for
the
application
of
a
function
f
to
an
argumen
t
x
except
that
as
is
traditional
in
lam
b
da
notation
the
brac
k
ets
ma
y
b
e
omitted
allo
wing
us
to
write
just
f
x
F
or
reasons
that
will
b
ecome
clear
in
the
next
paragraph
w
e
assume
that
function
application
asso
ciates
to
the
left
ie
f
x
y
means
	f
	x	y

As
a
shorthand
for
x
y

tx
y
 
w
e
will
use
x
y

tx
y
 
and
so
on
W
e
also
assume
that
the
scop
e
of
a
lam
b
da
abstraction
extends
as
far
to
the
righ
t
as
p
ossible
F
or
example
x
x
y
means
x
	x
y

rather
than
	x
x
y



THE
BENEFITS
OF
LAMBD
A
NOT
A
TION
	
A
t
rst
sigh
t
w
e
need
some
sp
ecial
notation
for
functions
of
sev
eral
argumen
ts
Ho
w
ev
er
there
is
a
w
a
y
of
breaking
do
wn
suc
h
applications
in
to
ordinary
lam
b
da
notation
called
currying
after
the
logician
Curry
		
	Actually
the
device
had
previously
b
een
used
b
y
b
oth
F
rege
		
and
Sc
h&
onnk
el
		
but
its
easy
to
understand
wh
y
the
corresp
onding
app
ellations
ha
v
ent
caugh
t
the
public
imagination
The
idea
is
to
use
expressions
lik
e
x
y

x
"
y

This
ma
y
b
e
regarded
as
a
function
R
 	R
 R

so
it
is
said
to
b
e
a
higher
order
function
or
functional
since
when
applied
to
one
argumen
t
it
yields
another
function
whic
h
then
accepts
the
second
argumen
t
In
a
sense
it
tak
es
its
argumen
ts
one
at
a
time
rather
than
b
oth
together
So
w
e
ha
v
e
for
example
	x
y

x
"
y




	y


"
y




"

Observ
e
that
function
application
is
assumed
to
asso
ciate
to
the
left
in
lam
b
da
notation
precisely
b
ecause
currying
is
used
so
m
uc
h
Lam
b
da
notation
is
particularly
helpful
in
pro
viding
a
unied
treatmen
t
of
b
ound
v
ariables
V
ariables
in
mathematics
normally
express
the
dep
endency
of
some
expression
on
the
v
alue
of
that
v
ariable
for
example
the
v
alue
of
x

"

dep
ends
on
the
v
alue
of
x
In
suc
h
con
texts
w
e
will
sa
y
that
a
v
ariable
is
fr
e
e
Ho
w
ev
er
there
are
other
situations
where
a
v
ariable
is
merely
used
as
a
place
mark
er
and
do
es
not
indicate
suc
h
a
dep
endency

Tw
o
common
examples
are
the
v
ariable
m
in
n
X
m
m

n	n
"


and
the
v
ariable
y
in
Z
x
 y
"
a
dy

x

"
ax
In
logic
the
quan
tiers
x
P
x 
	for
all
x
P
x 
and
	x
P
x 
	there
exists
an
x
suc
h
that
P
x 
pro
vide
further
examples
and
in
set
theory
w
e
ha
v
e
set
abstractions
lik
e
fx
j
P
x g
as
w
ell
as
indexed
unions
and
in
tersections
In
suc
h
cases
a
v
ariable
is
said
to
b
e
b
ound
In
a
certain
sub
expression
it
is
free
but
in
the
whole
expression
it
is
b
ound
b
y
a
variablebinding
op
er
ation
lik
e
summation
The
part
inside
this
v
ariablebinding
op
eration
is
called
the
sc
op
e
of
the
b
ound
v
ariable
A
similar
situation
o
ccurs
in
most
programming
languages
at
least
from
Algol

on
w
ards
V
ariables
ha
v
e
a
denite
scop
e
and
the
formal
argumen
ts
of
pro
ce
dures
and
functions
are
eectiv
ely
b
ound
v
ariables
eg
n
in
the
C
denition
of
the
successor
function
giv
en
ab
o
v
e
One
can
actually
regard
v
ariable
declarations
as
binding
op
erations
for
the
enclosed
instances
of
the
corresp
onding
v
ariable	s
Note
b
y
the
w
a
y

that
the
sc
op
e
of
a
v
ariable
should
b
e
distinguished
sharply
from
its
lifetime
In
the
C
function
rand
that
w
e
ga
v
e
in
the
in
tro
duction
n
had


CHAPTER

LAMBD
A
CALCULUS
a
textually
limited
scop
e
but
it
retained
its
v
alue
ev
en
outside
the
execution
of
that
part
of
the
co
de
W
e
can
freely
c
hange
the
name
of
a
b
ound
v
ariable
without
c
hanging
the
meaning
of
the
expression
eg
Z
x
 z
"
a
dz

x

"
ax
Similarly

in
lam
b
da
notation
x
E
x 
and
y

E
y
 
are
equiv
alen
t
this
is
called
alphaequiv
alence
and
the
pro
cess
of
transforming
b
et
w
een
suc
h
pairs
is
called
alphacon
v
ersion
W
e
should
add
the
pro
viso
that
y
is
not
a
free
v
ariable
in
E
x 
or
the
meaning
clearly
ma
y
c
hange
just
as
Z
x
 a
"
a
da

x

"
ax
It
is
p
ossible
to
ha
v
e
iden
ticallynamed
free
and
b
ound
v
ariables
in
the
same
expression
though
this
can
b
e
confusing
it
is
tec
hnically
unam
biguous
eg
Z
x
 x
"
a
dx

x

"
ax
In
fact
the
usual
Leibniz
notation
for
deriv
ativ
es
has
just
this
prop
ert
y

eg
in
d
dx
x


x
x
is
used
b
oth
as
a
b
ound
v
ariable
to
indicate
that
dieren
tiation
is
to
tak
e
place
with
resp
ect
to
x
and
as
a
free
v
ariable
to
sho
w
where
to
ev
aluate
the
resulting
deriv
ativ
e
This
can
b
e
confusing
eg
f
 	g
	x
is
usually
tak
en
to
mean
something
dieren
t
from
d
dx
f
	g
	x
Careful
writers
esp
ecially
in
m
ultiv
ariate
w
ork
often
mak
e
the
separation
explicit
b
y
writing
j
d
dx
x

j
x

x
or
j
d
dz
z

j
x

x
P
art
of
the
app
eal
of
lam
b
da
notation
is
that
all
v
ariablebinding
op
era
tions
lik
e
summation
dieren
tiation
and
in
tegration
can
b
e
regarded
as
func
tions
applied
to
lam
b
daexpressions
Subsuming
all
v
ariablebinding
op
erations
b
y
lam
b
da
abstraction
allo
ws
us
to
concen
trate
on
the
tec
hnical
problems
of
b
ound
v
ariables
in
one
particular
situation
F
or
example
w
e
can
view
d
dx
x

as
a
syn
tactic
sugaring
of
D
	x
x


x
where
D

	R
 R

 R
 R
is
a
dif
feren
tiation
op
erator
yielding
the
deriv
ativ
e
of
its
rst
	function
argumen
t
at
the
p
oin
t
indicated
b
y
its
second
argumen
t
Breaking
do
wn
the
ev
eryda
y
syn
tax
completely
in
to
lam
b
da
notation
w
e
ha
v
e
D
	x
EXP
x

x
for
some
constan
t
EXP
represen
ting
the
exp
onen
tial
function


R
USSELLS
P
ARADO
X

In
this
w
a
y

lam
b
da
notation
is
an
attractiv
ely
general
abstract
syn
tax
for
mathematics
all
w
e
need
is
the
appropriate
sto
c
k
of
constan
ts
to
start
with
Lam
b
da
abstraction
seems
in
retrosp
ect
to
b
e
the
appropriate
primitiv
e
in
terms
of
whic
h
to
analyze
v
ariable
binding
This
idea
go
es
bac
k
to
Ch
urc
hs
enco
ding
of
higher
order
logic
in
lam
b
da
notation
and
as
w
e
shall
see
in
the
next
c
hapter
Landin
has
p
oin
ted
out
ho
w
man
y
constructs
from
programming
languages
ha
v
e
a
similar
in
terpretation
In
recen
t
times
the
idea
of
using
lam
b
da
notation
as
a
univ
ersal
abstract
syn
tax
has
b
een
put
esp
ecially
clearly
b
y
MartinL&
of
and
is
often
referred
to
in
some
circles
as
MartinL&
of
s
theory
of
expressions
and
arities


Russells
parado
x
As
w
e
ha
v
e
said
one
of
the
app
eals
of
lam
b
da
notation
is
that
it
p
ermits
an
analysis
of
more
or
less
all
of
mathematical
syn
tax
Originally

Ch
urc
h
hop
ed
to
go
further
and
include
set
theory

whic
h
as
is
w
ell
kno
wn
is
p
o
w
erful
enough
to
form
a
foundation
for
m
uc
h
of
mo
dern
mathematics
Giv
en
an
y
set
S

w
e
can
form
its
socalled
char
acteristic
pr
e
dic
ate

S

suc
h
that

S
	x

 tr
ue
if
x

S
f
al
se
if
x

S
Con
v
ersely

giv
en
an
y
unary
predicate
	ie
function
of
one
argumen
t
P

w
e
can
consider
the
set
of
all
x
satisfying
P
	x

w
e
will
just
write
P
	x
for
P
	x

tr
ue
Th
us
w
e
see
that
sets
and
predicates
are
just
dieren
t
w
a
ys
of
talking
ab
out
the
same
thing
Instead
of
regarding
S
as
a
set
and
writing
x

S

w
e
can
regard
it
as
a
predicate
and
write
S
	x
This
p
ermits
a
natural
analysis
in
to
lam
b
da
notation
w
e
can
allo
w
arbitrary
lam
b
da
expressions
as
functions
and
hence
indirectly
as
sets
Unfortunately

this
turns
out
to
b
e
inconsisten
t
The
simplest
w
a
y
to
see
this
is
to
consider
the
Russell
parado
x
of
the
set
of
all
sets
that
do
not
con
tain
themselv
es
R

fx
j
x

xg
W
e
ha
v
e
R

R

R

R

a
stark
con
tradiction
In
terms
of
lam
b
da
dened
functions
w
e
set
R

x
	x
x
and
nd
that
R
R

	R
R

ob
viously
coun
ter
to
the
in
tuitiv
e
meaning
of
the
negation
op
erator

T
o
a
v
oid
suc
h
parado
xes
Ch
urc
h
		
follo
w
ed
Russell
in
augmen
ting
lam
b
da
notation
with
a
notion
of
typ
e
w
e
shall
consider
this
in
a
later
c
hapter
Ho
w
ev
er
the
parado
x
itself
is
suggestiv
e
of
some
in
teresting
p
ossibilities
in
the
standard
un
t
yp
ed
system
as
w
e
shall
see
later

This
w
as
presen
ted
at
the
Brou
w
er
Symp
osium
in
	
but
w
as
not
describ
ed
in
the
prin
ted
pro
ceedings


CHAPTER

LAMBD
A
CALCULUS

Lam
b
da
calculus
as
a
formal
system
W
e
ha
v
e
tak
en
for
gran
ted
certain
ob
vious
facts
eg
that
	y


"
y




"

since
these
reect
the
in
tended
meaning
of
abstraction
and
application
whic
h
are
in
a
sense
con
v
erse
op
erations
Lam
b
da
c
alculus
arises
if
w
e
enshrine
certain
suc
h
principles
and
only
those
as
a
set
of
formal
rules
The
app
eal
of
this
is
that
the
rules
can
then
b
e
used
mec
hanically

just
as
one
migh
t
transform
x





x
in
to
x


"

without
pausing
eac
h
time
to
think
ab
out
why
these
rules
ab
out
mo
ving
things
from
one
side
of
the
equation
to
the
other
are
v
alid
As
Whitehead
			
sa
ys
sym
b
olism
and
formal
rules
of
manipulation



 
ha
v
e
in
v
ariably
b
een
in
tro
duced
to
mak
e
things
easy




 
b
y
the
aid
of
sym
b
olism
w
e
can
mak
e
transitions
in
reasoning
almost
mec
hanically
b
y
the
ey
e
whic
h
otherwise
w
ould
call
in
to
pla
y
the
higher
faculties
of
the
brain



 
Civilisation
adv
ances
b
y
extending
the
n
um
b
er
of
imp
ortan
t
op
erations
whic
h
can
b
e
p
erformed
without
thinking
ab
out
them

Lam
b
da
terms
Lam
b
da
calculus
is
based
on
a
formal
notion
of
lam
b
da
term
and
these
terms
are
built
up
from
v
ariables
and
some
xed
set
of
constan
ts
using
the
op
erations
of
function
application
and
lam
b
da
abstraction
This
means
that
ev
ery
lam
b
da
term
falls
in
to
one
of
the
follo
wing
four
categories

V
ariables
these
are
indexed
b
y
arbitrary
alphan
umeric
strings
t
ypically
w
e
will
use
single
letters
from
to
w
ards
the
end
of
the
alphab
et
eg
x
y
and
z


Constan
ts
ho
w
man
y
constan
ts
there
are
in
a
giv
en
syn
tax
of
lam
b
da
terms
dep
ends
on
con
text
Sometimes
there
are
none
at
all
W
e
will
also
denote
them
b
y
alphan
umeric
strings
lea
ving
con
text
to
determine
when
they
are
mean
t
to
b
e
constan
ts

Com
binations
ie
the
application
of
a
function
s
to
an
argumen
t
t
b
oth
these
comp
onen
ts
s
and
t
ma
y
themselv
es
b
e
arbitrary
terms
W
e
will
write
com
binations
simply
as
s
t
W
e
often
refer
to
s
as
the
rator
and
t
as
the
rand
	short
for
op
erator
and
op
erand
resp
ectiv
ely

Abstractions
of
an
arbitrary
lam
b
daterm
s
o
v
er
a
v
ariable
x
	whic
h
ma
y
or
ma
y
not
o
ccur
free
in
s
denoted
b
y
x
s
F
ormally

this
denes
the
set
of
lam
b
da
terms
inductiv
ely

ie
lam
b
da
terms
arise
only
in
these
four
w
a
ys
This
justies
our


LAMBD
A
CALCULUS
AS
A
F
ORMAL
SYSTEM


Dening
functions
o
v
er
lam
b
da
terms
b
y
primitiv
e
recursion

Pro
ving
prop
erties
of
lam
b
da
terms
b
y
structural
induction
A
formal
discussion
of
inductiv
e
generation
and
the
notions
of
primitiv
e
re
cursion
and
structural
induction
ma
y
b
e
found
elsewhere
W
e
hop
e
most
readers
who
are
unfamiliar
with
these
terms
will
nd
that
the
examples
b
elo
w
giv
e
them
a
sucien
t
grasp
of
the
basic
ideas
W
e
can
describ
e
the
syn
tax
of
lam
b
da
terms
b
y
a
BNF
	Bac
kusNaur
form
grammar
just
as
w
e
do
for
programming
languages
E
xp

V
ar
j
C
onst
j
E
xp
E
xp
j

V
ar

E
xp
and
follo
wing
the
usual
computer
science
view
w
e
will
iden
tify
lam
b
da
terms
with
abstract
syn
tax
trees
rather
than
with
sequences
of
c
haracters
This
means
that
con
v
en
tions
suc
h
as
the
leftasso
ciation
of
function
application
the
reading
of
x
y

s
as
x
y

s
and
the
am
biguit
y
o
v
er
constan
t
and
v
ariable
names
are
purely
a
matter
of
parsing
and
prin
ting
for
h
uman
con
v
enience
and
not
part
of
the
formal
system
One
feature
w
orth
men
tioning
is
that
w
e
use
single
c
haracters
to
stand
for
v
ariables
and
constan
ts
in
the
formal
system
of
lam
b
da
terms
and
as
socalled
meta
v
ariables
standing
for
arbitrary
terms
F
or
example
x
s
migh
t
represen
t
the
constan
t
function
with
v
alue
s
or
an
arbitrary
lam
b
da
abstraction
using
the
v
ariable
x
T
o
mak
e
this
less
confusing
w
e
will
normally
use
letters
suc
h
as
s
t
and
u
for
meta
v
ariables
o
v
er
terms
It
w
ould
b
e
more
precise
if
w
e
denoted
the
v
ariable
x
b
y
V
x
	the
xth
v
ariable
and
lik
ewise
the
constan
t
k
b
y
C
k

then
all
the
v
ariables
in
terms
w
ould
ha
v
e
the
same
status
Ho
w
ev
er
this
mak
es
the
resulting
terms
a
bit
cluttered

F
ree
and
b
ound
v
ariables
W
e
no
w
formalize
the
in
tuitiv
e
idea
of
free
and
b
ound
v
ariables
in
a
term
whic
h
inciden
tally

giv
es
a
go
o
d
illustration
of
dening
a
function
b
y
primitiv
e
recursion
In
tuitiv
ely

a
v
ariable
in
a
term
is
free
if
it
do
es
not
o
ccur
inside
the
scop
e
of
a
corresp
onding
abstraction
W
e
will
denote
the
set
of
free
v
ariables
in
a
term
s
b
y
F
V
	s
and
dene
it
b
y
recursion
as
follo
ws
F
V
	x

fxg
F
V
	c


F
V
	s
t

F
V
	s

F
V
	t
F
V
	x
s

F
V
	s

fxg
Similarly
w
e
can
dene
the
set
of
b
ound
v
ariables
in
a
term
B
V
	s


CHAPTER

LAMBD
A
CALCULUS
B
V
	x


B
V
	c


B
V
	s
t

B
V
	s

B
V
	t
B
V
	x
s

B
V
	s

fxg
F
or
example
if
s

	x
y

x
	x
z
x
w
e
ha
v
e
F
V
	s

fz
g
and
B
V
	s

fx
y
g
Note
that
in
general
a
v
ariable
can
b
e
b
oth
free
and
b
ound
in
the
same
term
as
illustrated
b
y
some
of
the
mathematical
examples
earlier
As
an
example
of
using
structural
induction
to
establish
prop
erties
of
lam
b
da
terms
w
e
will
pro
v
e
the
follo
wing
theorem
	a
similar
pro
of
w
orks
for
B
V
to
o
Theorem

F
or
any
lamb
da
term
s
the
set
F
V
	s
is
nite
Pro
of
By
structur
al
induction
Certainly
if
s
is
a
variable
or
a
c
onstant
then
by
denition
F
V
	s
is
nite
sinc
e
it
is
either
a
singleton
or
empty
If
s
is
a
c
ombination
t
u
then
by
the
inductive
hyp
othesis
F
V
	t
and
F
V
	u
ar
e
b
oth
nite
and
then
F
V
	s

F
V
	t

F
V
	u
which
is
ther
efor
e
also
nite
the
union
of
two
nite
sets
is
nite
Final
ly
if
s
is
of
the
form
x
t
then
F
V
	t
is
nite
by
the
inductive
hyp
othesis
and
by
denition
F
V
	s

F
V
	t

fxg
which
must
b
e
nite
to
o
sinc
e
it
is
no
lar
ger
QED

Substitution
The
rules
w
e
w
an
t
to
formalize
include
the
stipulation
that
lam
b
da
abstraction
and
function
application
are
in
v
erse
op
erations
That
is
if
w
e
tak
e
a
term
x
s
and
apply
it
as
a
function
to
an
argumen
t
term
t
the
answ
er
is
the
term
s
with
all
free
instances
of
x
replaced
b
y
t
W
e
often
mak
e
this
more
transparen
t
in
discussions
b
y
using
the
notation
x
sx 
and
st 
for
the
resp
ectiv
e
terms
Ho
w
ev
er
this
simplelo
oking
notion
of
substituting
one
term
for
a
v
ariable
in
another
term
is
surprisingly
dicult
Some
notable
logicians
ha
v
e
made
fault
y
statemen
ts
regarding
substitution
In
fact
this
dicult
y
is
rather
unfortunate
since
as
w
e
ha
v
e
said
the
app
eal
of
formal
rules
is
that
they
can
b
e
applied
mec
hanically

W
e
will
denote
the
op
eration
of
substituting
a
term
s
for
a
v
ariable
x
in
an
other
term
t
b
y
tsx 
One
sometimes
sees
v
arious
other
notations
eg
tx
s 
sx t
or
ev
en
txs 
The
notation
w
e
use
is
p
erhaps
most
easily
remem
b
ered
b
y
noting
the
v
ague
analogy
with
m
ultiplication
of
fractions
xtx 

t
A
t
rst
sigh
t
one
can
dene
substitution
formally
b
y
recursion
as
follo
ws
xtx 

t
y
tx 

y
if
x

y


LAMBD
A
CALCULUS
AS
A
F
ORMAL
SYSTEM

ctx 

c
	s

s

tx 

s

tx 
s

tx 
	x
stx 

x
s
	y

stx 

y

	stx 
if
x

y
Ho
w
ev
er
this
isnt
quite
righ
t
F
or
example
	y

x
"
y
y
x 

y

y
"
y

whic
h
do
esnt
corresp
ond
to
the
in
tuitiv
e
answ
er

The
original
lam
b
da
term
w
as
the
function
that
adds
x
to
its
argumen
t
so
after
substitution
w
e
migh
t
exp
ect
to
get
the
function
that
adds
y
to
its
argumen
t
What
w
e
actually
get
is
the
function
that
doubles
its
argumen
t
The
problem
is
that
the
v
ariable
y
that
w
e
ha
v
e
substituted
is
c
aptur
e
d
b
y
the
v
ariablebinding
op
eration
y





W
e
should
rst
rename
the
b
ound
v
ariable
	y

x
"
y


	w

x
"
w

and
only
no
w
p
erform
a
naiv
e
substitution
op
eration
	w

x
"
w
y
x 

w

y
"
w
W
e
can
tak
e
t
w
o
approac
hes
to
this
problem
Either
w
e
can
add
a
condition
on
all
instances
of
substitution
to
disallo
w
it
wherev
er
v
ariable
capture
w
ould
o
ccur
or
w
e
can
mo
dify
the
formal
denition
of
substitution
so
that
it
p
erforms
the
appropriate
renamings
automatically

W
e
will
opt
for
this
latter
approac
h
Here
is
the
denition
of
substitution
that
w
e
use
xtx 

t
y
tx 

y
if
x

y
ctx 

c
	s

s

tx 

s

tx 
s

tx 
	x
stx 

x
s
	y

stx 

y

	stx 
if
x

y
and
either
x

F
V
	s
or
y

F
V
	t
	y

stx 

z

	sz
y
 tx 
otherwise
where
z

F
V
	s

F
V
	t
The
only
dierence
is
in
the
last
t
w
o
lines
W
e
substitute
as
b
efore
in
the
t
w
o
safe
situations
where
either
x
isnt
free
in
s
so
the
substitution
is
trivial
or
where
y
isnt
free
in
t
so
v
ariable
capture
w
ont
o
ccur
	at
this
lev
el
Ho
w
ev
er
where
these
conditions
fail
w
e
rst
rename
y
to
a
new
v
ariable
z

c
hosen
not
to
b
e
free
in
either
s
or
t
then
pro
ceed
as
b
efore
F
or
deniteness
the
v
ariable
z
can
b
e
c
hosen
in
some
canonical
w
a
y

eg
the
lexicographically
rst
name
not
o
ccurring
as
a
free
v
ariable
in
either
s
or
t


W
e
will
con
tin
ue
to
use
inx
syn
tax
for
standard
op
erators
strictly
w
e
should
write

x
y
rather
than
x

y


Cognoscen
ti
ma
y
also
b
e
w
orried
that
this
denition
is
not
in
fact
primitive
recursiv
e


CHAPTER

LAMBD
A
CALCULUS

Con
v
ersions
Lam
b
da
calculus
is
based
on
three
con
v
ersions
whic
h
transform
one
term
in
to
another
one
in
tuitiv
ely
equiv
alen
t
to
it
These
are
traditionally
denoted
b
y
the
Greek
letters

	alpha

	b
eta
and
	
	eta

Here
are
the
formal
denitions
of
the
op
erations
using
annotated
arro
ws
for
the
con
v
ersion
relations

Alpha
con
v
ersion
x
s

 
y

sy
x 
pro
vided
y

F
V
	s
F
or
example
u
u
v

 
w

w
v

but
u
u
v

 
v

v
v

The
restriction
a
v
oids
another
instance
of
v
ariable
capture

Beta
con
v
ersion
	x
s
t

 
stx 

Eta
con
v
ersion
x
t
x

 
t
pro
vided
x

F
V
	t
F
or
example
u
v
u

 
v
but
u
u
u

 
u
Of
the
three

con
v
ersion
is
the
most
imp
ortan
t
one
to
us
since
it
represen
ts
the
ev
aluation
of
a
function
on
an
argumen
t

con
v
ersion
is
a
tec
hnical
device
to
c
hange
the
names
of
b
ound
v
ariables
while
	
con
v
ersion
is
a
form
of
extensionality
and
is
therefore
mainly
of
in
terest
to
those
taking
a
logical
not
a
programming
view
of
lam
b
da
calculus

Lam
b
da
equalit
y
Using
these
con
v
ersion
rules
w
e
can
dene
formally
when
t
w
o
lam
b
da
terms
are
to
b
e
considered
equal
Roughly

t
w
o
terms
are
equal
if
it
is
p
ossible
to
get
from
one
to
the
other
b
y
a
nite
sequence
of
con
v
ersions
	


or
	

either
forw
ard
or
bac
kw
ard
at
an
y
depth
inside
the
term
W
e
can
sa
y
that
lam
b
da
equalit
y
is
the
c
ongruenc
e
closur
e
of
the
three
reduction
op
erations
together
ie
the
smallest
relation
con
taining
the
three
con
v
ersion
op
erations
and
closed
under
reexivit
y

symmetry

transitivit
y
and
substitutivit
y

F
ormally
w
e
can
dene
it
inductiv
ely
as
follo
ws
where
the
horizon
tal
lines
should
b
e
read
as
if
what
is
ab
o
v
e
the
line
holds
then
so
do
es
what
is
b
elo
w
s

 
t
or
s

 
t
or
s

 
t
s

t
t

t
b
ecause
of
the
last
clause
Ho
w
ev
er
it
can
easily
b
e
mo
died
in
to
a
primitiv
e
recursiv
e
denition
of
m
ultiple
parallel
substitution
This
pro
cedure
is
analogous
to
strengthening
an
induction
h
yp
othesis
during
a
pro
of
b
y
induction
Note
that
b
y
construction
the
pair
of
substitutions
in
the
last
line
can
b
e
done
in
parallel
rather
than
sequen
tially
without
aecting
the
result

These
names
are
due
to
Curry

Ch
urc
h
originally
referred
to
con
v
ersion
and

con
v
ersion
as
rule
of
pro
cedure
I
and
rule
of
pro
cedure
I
I
resp
ectiv
ely



LAMBD
A
CALCULUS
AS
A
F
ORMAL
SYSTEM

s

t
t

s
s

t
and
t

u
s

u
s

t
s
u

t
u
s

t
u
s

u
t
s

t
x
s

x
t
Note
that
the
use
of
the
ordinary
equalit
y
sym
b
ol
	
here
is
misleading
W
e
are
actually
dening
the
relation
of
lam
b
da
equalit
y

and
it
isnt
clear
that
it
corresp
onds
to
equalit
y
of
the
corresp
onding
mathematical
ob
jects
in
the
usual
sense

Certainly
it
m
ust
b
e
distinguished
sharply
from
equalit
y
at
the
syntactic
lev
el
W
e
will
refer
to
this
latter
kind
of
equalit
y
as
iden
tit
y
and
use
the
sp
ecial
sym
b
ol

F
or
example
x
x

y

y
but
x
x

y

y

F
or
man
y
purp
oses

con
v
ersions
are
immaterial
and
often


is
used
in
stead
of
strict
iden
tit
y

This
is
dened
lik
e
lam
b
da
equalit
y

except
that
only

con
v
ersions
are
allo
w
ed
F
or
example
	x
xy


	y

y
y

Man
y
writers
use
this
as
iden
tit
y
on
lam
b
da
terms
ie
consider
equiv
alence
classes
of
terms
under



There
are
alternativ
e
formalizations
of
syn
tax
where
b
ound
v
ariables
are
unnamed
	de
Bruijn
	
and
here
syn
tactic
iden
tit
y
corresp
onds
to
our




Extensionalit
y
W
e
ha
v
e
said
that
	
con
v
ersion
em
b
o
dies
a
principle
of
extensionality
In
general
philosophical
terms
t
w
o
prop
erties
are
said
to
b
e
extensional
ly
equiv
alen
t
	or
c
o
extensive
when
they
are
satised
b
y
exactly
the
same
ob
jects
In
mathematics
w
e
usually
tak
e
an
extensional
view
of
sets
ie
sa
y
that
t
w
o
sets
are
equal
precisely
if
they
ha
v
e
the
same
elemen
ts
Similarly

w
e
normally
sa
y
that
t
w
o
functions
are
equal
precisely
if
they
ha
v
e
the
same
domain
and
giv
e
the
same
result
on
all
argumen
ts
in
that
domain
As
a
consequence
of
	
con
v
ersion
our
notion
of
lam
b
da
equalit
y
is
extensional
Indeed
if
f
x
and
g
x
are
equal
for
an
y
x
then
in
particular
f
y

g
y
where
y
is
c
hosen
not
to
b
e
free
in
either
f
or
g

Therefore
b
y
the
last
rule
ab
o
v
e
y

f
y

y

g
y

No
w
b
y
	
con
v
erting
a
couple
of
times
at
depth
w
e
see
that

Indeed
w
e
ha
v
ent
b
een
v
ery
precise
ab
out
what
the
corresp
onding
mathematical
ob
jects
ar
e
But
there
are
mo
dels
of
the
lam
b
da
calculus
where
our
lam
b
da
equalit
y
is
in
terpreted
as
actual
equalit
y



CHAPTER

LAMBD
A
CALCULUS
f

g

Con
v
ersely

extensionalit
y
implies
that
all
instances
of
	
con
v
ersion
do
indeed
giv
e
a
v
alid
equation
since
b
y

reduction
	x
t
x
y

t
y
for
an
y
y
when
x
is
not
free
in
t
This
is
the
imp
ort
of
	
con
v
ersion
and
ha
ving
discussed
that
w
e
will
largely
ignore
it
in
fa
v
our
of
the
more
computationally
signican
t

con
v
ersion

Lam
b
da
reduction
Lam
b
da
equalit
y

unsurprisingly

is
a
symmetric
relation
Though
it
captures
the
notion
of
equiv
alence
of
lam
b
da
terms
w
ell
it
is
more
in
teresting
from
a
computational
p
oin
t
of
view
to
consider
an
asymmetric
v
ersion
W
e
will
dene
a
reduction
relation

 as
follo
ws
s

 
t
or
s

 
t
or
s

 
t
s

 t
t

 t
s

 t
and
t

 u
s

 u
s

 t
s
u

 t
u
s

 t
u
s

 u
t
s

 t
x
s

 x
t
Actually
the
name
reduction
	and
one
also
hears

con
v
ersion
called


reduction
is
a
sligh
t
misnomer
since
it
can
cause
the
size
of
a
term
to
gro
w
eg
	x
x
x
x
	x
x
x
x

 	x
x
x
x
	x
x
x
x
	x
x
x
x

 	x
x
x
x
	x
x
x
x
	x
x
x
x
	x
x
x
x

 


Ho
w
ev
er
reduction
do
es
corresp
ond
to
a
systematic
attempt
to
ev
aluate
a
term
b
y
rep
eatedly
ev
aluating
com
binations
f
	x
where
f
is
a
lam
b
da
abstraction
When
no
more
reductions
except
for

con
v
ersions
are
p
ossible
w
e
sa
y
that
the
term
is
in
normal
form


LAMBD
A
CALCULUS
AS
A
F
ORMAL
SYSTEM
	

Reduction
strategies
Let
us
recall
in
the
middle
of
these
theoretical
considerations
the
relev
ance
of
all
this
to
functional
programming
A
functional
program
is
an
expr
ession
and
executing
it
means
ev
aluating
the
expression
In
terms
of
the
concepts
discussed
here
w
e
are
prop
osing
to
start
with
the
relev
an
t
term
and
k
eep
on
applying
re
ductions
un
til
there
is
nothing
more
to
b
e
ev
aluated
But
ho
w
are
w
e
to
c
ho
ose
whic
h
reduction
to
apply
at
eac
h
stage
The
reduction
relation
is
not
determin
istic
ie
for
some
terms
t
there
are
sev
eral
t
i
suc
h
that
t

 t
i

Sometimes
this
can
mak
e
the
dierence
b
et
w
een
a
nite
and
innite
reduction
sequence
ie
b
e
t
w
een
a
program
terminating
and
failing
to
terminate
F
or
example
b
y
reducing
the
innermost
r
e
dex
	reducible
expression
in
the
follo
wing
w
e
ha
v
e
an
innite
reduction
sequence
	x
y

		x
x
x
x
	x
x
x
x

 	x
y

		x
x
x
x
	x
x
x
x
	x
x
x
x

 	x
y

		x
x
x
x
	x
x
x
x
	x
x
x
x
	x
x
x
x

 


and
so
ad
innitum
Ho
w
ev
er
the
alternativ
e
of
reducing
the
outermost
redex
rst
giv
es
	x
y

		x
x
x
x
	x
x
x
x

 y
immediately

and
there
are
no
more
reductions
to
apply

The
situation
is
claried
b
y
the
follo
wing
theorems
whose
pro
ofs
are
to
o
long
to
b
e
giv
en
here
The
rst
one
sa
ys
that
the
situation
w
e
ha
v
e
noted
ab
o
v
e
is
true
in
a
more
general
sense
ie
that
reducing
the
leftmost
outermost
redex
is
the
b
est
strategy
for
ensuring
termination
Theorem

If
s

 t
with
t
in
normal
form
then
the
r
e
duction
se
quenc
e
that
arises
fr
om
s
by
always
r
e
ducing
the
leftmost
outermost
r
e
dex
is
guar
ante
e
d
to
terminate
in
normal
form
F
ormally

w
e
dene
the
leftmost
outermost
redex
recursiv
ely
for
a
term
	x
s
t
it
is
the
term
itself
for
an
y
other
term
s
t
it
is
the
leftmost
outermost
redex
of
s
and
for
an
abstraction
x
s
it
is
the
leftmost
outermost
redex
of
s
In
terms
of
concrete
syn
tax
w
e
alw
a
ys
reduce
the
redex
whose

is
the
furthest
to
the
left
	
The
Ch
urc
hRosser
theorem
The
next
assertion
the
famous
Ch
urc
hRosser
theorem
states
that
if
w
e
start
from
a
term
t
and
p
erform
an
y
t
w
o
nite
reduction
sequences
there
are
alw
a
ys


CHAPTER

LAMBD
A
CALCULUS
t
w
o
more
reduction
sequences
that
bring
the
t
w
o
bac
k
to
the
same
term
	though
of
course
this
migh
t
not
b
e
in
normal
form
Theorem

If
t

 s

and
t

 s


then
ther
e
is
a
term
u
such
that
s


 u
and
s


 u
This
has
at
least
the
follo
wing
imp
ortan
t
consequences
Corollary

If
t


t

then
ther
e
is
a
term
u
with
t


 u
and
t


 u
Pro
of
It
is
e
asy
to
se
e
by
structur
al
induction
that
the
e
quality
r
elation

is
in
fact
the
symmetric
tr
ansitive
closur
e
of
the
r
e
duction
r
elation
Now
we
c
an
pr
o
c
e
e
d
by
induction
over
the
c
onstruction
of
the
symmetric
tr
ansitive
closur
e
However
less
formal
ly
minde
d
r
e
aders
wil
l
pr
ob
ably
nd
the
fol
lowing
diagr
am
mor
e
c
onvincing
t

t

  R



  R



  R



  R



  R



  R



  R



  R



  R



  R



u
We
assume
t


t


so
ther
e
is
some
se
quenc
e
of
r
e
ductions
in
b
oth
dir
e
ctions
ie
the
zigzag
at
the
top
that
c
onne
cts
them
Now
the
Chur
chR
osser
the
or
em
al
lows
us
to
l
l
in
the
r
emainder
of
the
sides
in
the
ab
ove
diagr
am
and
henc
e
r
e
ach
the
r
esult
by
c
omp
osing
these
r
e
ductions
QED
Corollary

If
t

t

and
t

t

with
t

and
t

in
normal
form
then
t



t


ie
t

and
t

ar
e
e
qual
ap
art
fr
om

c
onversions
Pro
of
By
the
rst
c
or
ol
lary
we
have
some
u
with
t


 u
and
t


 u
But
sinc
e
t

and
t

ar
e
alr
e
ady
in
normal
form
these
r
e
duction
se
quenc
es
to
u
c
an
only
c
onsist
of
alpha
c
onversions
QED
Hence
normal
forms
when
they
do
exist
are
unique
up
to
alpha
con
v
ersion
This
giv
es
us
the
rst
pro
of
w
e
ha
v
e
a
v
ailable
that
the
relation
of
lam
b
da
equalit
y
isnt
completely
trivial
ie
that
there
are
an
y
unequal
terms
F
or
example
since
x
y

x
and
x
y

y
are
not
in
tercon
v
ertible
b
y
alpha
con
v
ersions
alone
they
cannot
b
e
equal
Let
us
sum
up
the
computational
signicance
of
all
these
assertions
In
some
sense
reducing
the
leftmost
outermost
redex
is
the
b
est
strategy

since
it
will
w
ork
if
an
y
strategy
will
This
is
kno
wn
as
normal
or
der
r
e
duction
On
the
other
hand
any
terminating
reduction
sequence
will
alw
a
ys
giv
e
the
same
result
and
moreo
v
er
it
is
nev
er
to
o
late
to
abandon
a
giv
en
strategy
and
start
using
normal
order
reduction
W
e
will
see
later
ho
w
this
translates
in
to
practical
terms


COMBINA
TORS


Com
binators
Com
binators
w
ere
actually
dev
elop
ed
as
an
indep
enden
t
theory
b
y
Sc
h&
onnk
el
		
b
efore
lam
b
da
notation
came
along
Moreo
v
er
Curry
redisco
v
ered
the
theory
so
on
afterw
ards
indep
enden
tly
of
Sc
h&
onnk
el
and
of
Ch
urc
h
	When
he
found
out
ab
out
Sc
h&
onnk
els
w
ork
Curry
attempted
to
con
tact
him
but
b
y
that
time
Sc
h&
onnk
el
had
b
een
committed
to
a
lunatic
asylum
W
e
will
distort
the
historical
dev
elopmen
t
b
y
presen
ting
the
theory
of
com
binators
as
an
asp
ect
of
lam
b
da
calculus
W
e
will
dene
a
c
ombinator
simply
to
b
e
a
lam
b
da
term
with
no
free
v
ari
ables
Suc
h
a
term
is
also
said
to
b
e
close
d
it
has
a
xed
meaning
indep
enden
t
of
the
v
alues
of
an
y
v
ariables
No
w
w
e
will
later
in
the
course
of
functional
programming
come
across
man
y
useful
com
binators
But
the
cornerstone
of
the
theory
of
com
binators
is
that
one
can
get
a
w
a
y
with
just
a
few
com
binators
and
express
in
terms
of
those
and
v
ariables
any
term
at
all
the
op
eration
of
lam
b
da
abstraction
is
unnecessary

In
particular
a
closed
term
can
b
e
expressed
purely
in
terms
of
these
few
com
binators
W
e
start
b
y
dening
I

x
x
K

x
y

x
S

f
g
x
	f
x	g
x
W
e
can
motiv
ate
the
names
as
follo
ws

I
is
the
iden
tit
y
function
K
pro
duces
constan
t
functions

when
applied
to
an
argumen
t
a
it
giv
es
the
function
y

a
Finally
S
is
a
sharing
com
binator
whic
h
tak
es
t
w
o
functions
and
an
argumen
t
and
shares
out
the
argumen
t
among
the
functions
No
w
w
e
pro
v
e
the
follo
wing
Lemma

F
or
any
lamb
da
term
t
not
involving
lamb
da
abstr
action
ther
e
is
a
term
u
also
not
c
ontaining
lamb
da
abstr
actions
built
up
fr
om
S

K

I
and
variables
with
F
V
	u

F
V
	t

fxg
and
u

x
t
ie
u
is
lamb
dae
qual
to
x
t
Pro
of
By
structur
al
induction
on
the
term
t
By
hyp
othesis
it
c
annot
b
e
an
abstr
action
so
ther
e
ar
e
just
thr
e
e
c
ases
to
c
onsider

If
t
is
a
variable
then
ther
e
ar
e
two
p
ossibilities
If
it
is
e
qual
to
x
then
x
x

I

so
we
ar
e
nishe
d
If
not
say
t

y

then
x
y

K
y


If
t
is
a
c
onstant
c
then
x
c

K
c

If
t
is
a
c
ombination
say
s
u
then
by
the
inductive
hyp
othesis
ther
e
ar
e
lamb
dafr
e
e
terms
s
 and
u
 with
s
 
x
s
and
u
 
x
u
Now
we
claim
S
s
 u
 su	c
es
Inde
e
d

W
e
are
not
claiming
these
are
the
historical
reasons
for
them

Konstan
t

Sc
h
onnk
el
w
as
German
though
in
fact
he
originally
used
C



CHAPTER

LAMBD
A
CALCULUS
S
s
 u
 x

S
	x
s
	x
u
x

		x
s
x		x
u
x

s
u

t
Ther
efor
e
by
	
c
onversion
we
have
S
s
 u
 
x
S
s
 u
 x

x
t
sinc
e
by
the
inductive
hyp
othesis
x
is
not
fr
e
e
in
s
 or
u
 
QED
Theorem

F
or
any
lamb
da
term
t
ther
e
is
a
lamb
dafr
e
e
term
t
 built
up
fr
om
S

K

I
and
variables
with
F
V
	t
 

F
V
	t
and
t
 
t
Pro
of
By
structur
al
induction
on
t
using
the
lemma
F
or
example
if
t
is
x
s
we
rst
nd
by
the
inductive
hyp
othesis
a
lamb
dafr
e
e
e
quivalent
s
 of
s
Now
the
lemma
c
an
b
e
applie
d
to
x
s
 
The
other
c
ases
ar
e
str
aightforwar
d
QED
This
remark
able
fact
can
b
e
strengthened
since
I
is
denable
in
terms
of
S
and
K

Note
that
for
an
y
A
S
K
A
x

	K
x	A
x

	y

x	A
x

x
So
again
b
y
	
con
v
erting
w
e
see
that
I

S
K
A
for
an
y
A
It
is
customary

for
reasons
that
will
b
ecome
clear
when
w
e
lo
ok
at
t
yp
es
to
use
A

K

So
I

S
K
K

and
w
e
can
a
v
oid
the
use
of
I
in
our
com
binatory
expression
Note
that
the
pro
ofs
ab
o
v
e
are
constructiv
e
in
the
sense
that
they
guide
one
in
a
denite
pro
cedure
that
giv
en
a
lam
b
da
term
pro
duces
a
com
binator
equiv
alen
t
One
pro
ceeds
b
ottomup
and
at
eac
h
lam
b
da
abstraction
whic
h
b
y
construction
has
a
lam
b
dafree
b
o
dy

applies
the
topdo
wn
transformations
giv
en
in
the
lemma
Although
w
e
ha
v
e
presen
ted
com
binators
as
certain
lam
b
da
terms
they
can
also
b
e
dev
elop
ed
as
a
theory
in
their
o
wn
righ
t
That
is
one
starts
with
a
formal
syn
tax
excluding
lam
b
da
abstractions
but
including
com
binators
Instead
of



and
	
con
v
ersions
one
p
osits
c
onversion
rules
for
expressions
in
v
olving
com
binators
eg
K
x
y

 x
As
an
indep
enden
t
theory

this
has
man
y
analogies
with
lam
b
da
calculus
eg
the
Ch
urc
hRosser
theorem
holds
for
this
notion
of
reduction
to
o
Moreo
v
er
the
ugly
diculties
connected
with
b
ound
v
ariables
are
a
v
oided
completely

Ho
w
ev
er
the
resulting
system
is
w
e
feel
less
in
tuitiv
e
since
com
binatory
expressions
can
get
rather
obscure


COMBINA
TORS

Apart
from
their
purely
logical
in
terest
com
binators
ha
v
e
a
certain
practical
p
oten
tial
As
w
e
ha
v
e
already
hin
ted
and
as
will
b
ecome
m
uc
h
clearer
in
the
later
c
hapters
lam
b
da
calculus
can
b
e
seen
as
a
simple
functional
language
forming
the
core
of
real
practical
languages
lik
e
ML
W
e
migh
t
sa
y
that
the
theorem
of
com
binatory
completeness
sho
ws
that
lam
b
da
calculus
can
b
e
compiled
do
wn
to
a
mac
hine
co
de
of
com
binators
This
computing
terminology
is
not
as
fanciful
as
it
app
ears
Com
binators
ha
v
e
b
een
used
as
an
implemen
tation
tec
hnique
for
functional
languages
and
real
hardw
are
has
b
een
built
to
ev
aluate
com
binatory
expressions
F
urther
reading
An
encyclop
edic
but
clear
b
o
ok
on
lam
b
da
calculus
is
Barendregt
		
Another
p
opular
textb
o
ok
is
Hindley
and
Seldin
		
Both
these
con
tain
pro
ofs
of
the
results
that
w
e
ha
v
e
merely
asserted
A
more
elemen
tary
treatmen
t
fo
cused
to
w
ards
computer
science
is
P
art
I
I
of
Gordon
		
Muc
h
of
our
presen
tation
here
and
later
is
based
on
this
last
b
o
ok
Exercises

Find
a
normal
form
for
	x
x
x
x
a
b
c

Dene
tw
ice

f
x
f
	f
x
What
is
the
in
tuitiv
e
meaning
of
tw
ice
Find
a
normal
form
for
tw
ice
tw
ice
tw
ice
f
x
	Remem
b
er
that
function
application
asso
ciates
to
the
left

Find
a
term
t
suc
h
that
t

 
t
Is
it
true
to
sa
y
that
a
term
is
in
normal
form
if
and
only
if
whenev
er
t

 t
 then
t


t
 

What
are
the
circumstances
under
whic
h
stx uy
 


suy
 tx 

Find
an
equiv
alen
t
in
terms
of
the
S

K
and
I
com
binators
alone
for
f
x
f
	x
x

Find
a
single
com
binator
X
suc
h
that
all
terms
are
equal
to
a
term
built
from
X
and
v
ariables
Y
ou
ma
y
nd
it
helpful
to
consider
A

p
p
K
S
K
and
then
think
ab
out
A
A
A
and
A
	A
A

Pro
v
e
that
an
y
X
is
a
xed
p
oin
t
com
binator
if
and
only
if
it
is
itself
a
xed
p
oin
t
of
G
where
G

y
m
m	y
m

Chapter

Lam
b
da
calculus
as
a
programming
language
One
of
the
cen
tral
questions
studied
b
y
logicians
in
the
	s
w
as
the
Entschei
dungspr
oblem
or
decision
problem
This
ask
ed
whether
there
w
as
some
system
atic
mec
hanical
pro
cedure
for
deciding
v
alidit
y
in
rst
order
logic
If
it
turned
out
that
there
w
as
it
w
ould
ha
v
e
fundamen
tal
philosophical
and
p
erhaps
practi
cal
signicance
It
w
ould
mean
that
a
h
uge
v
ariet
y
of
complicated
mathematical
problems
could
in
principle
b
e
solv
ed
purely
b
y
follo
wing
some
single
xed
metho
d

w
e
w
ould
no
w
sa
y
algorithm

no
additional
creativit
y
w
ould
b
e
required
As
it
stands
the
question
is
hard
to
answ
er
b
ecause
w
e
need
to
dene
in
math
ematical
terms
what
it
means
for
there
to
b
e
a
systematic
mec
hanical
pro
cedure
for
something
P
erhaps
T
uring
		
ga
v
e
the
b
est
analysis
b
y
arguing
that
the
mec
hanical
pro
cedures
are
those
that
could
in
principle
b
e
p
erformed
b
y
a
rea
sonably
in
telligen
t
clerk
with
no
kno
wledge
of
the
underlying
sub
ject
matter
He
abstracted
from
the
b
eha
viour
of
suc
h
a
clerk
and
arriv
ed
at
the
famous
notion
of
a
T
uring
mac
hine
Despite
the
fact
that
it
arose
b
y
considering
a
human
computer
and
w
as
purely
a
mathematical
abstraction
w
e
no
w
see
a
T
uring
mac
hine
as
a
v
ery
simple
computer
Despite
b
eing
simple
a
T
uring
mac
hine
is
capable
of
p
erforming
an
y
calculation
that
can
b
e
done
b
y
a
ph
ysical
computer

A
mo
del
of
computation
of
equal
p
o
w
er
to
a
T
uring
mac
hine
is
said
to
b
e
T
uring
c
omplete
A
t
ab
out
the
same
time
there
w
ere
sev
eral
other
prop
osed
denitions
of
mec
hanical
pro
cedure
Most
of
these
turned
out
to
b
e
equiv
alen
t
in
p
o
w
er
to
T
uring
mac
hines
In
particular
although
it
originally
arose
as
a
foundation
for
mathematics
lam
b
da
calculus
can
also
b
e
seen
as
a
programming
language
to
b
e
executed
b
y
p
erforming

con
v
ersions
In
fact
Ch
urc
h
prop
osed
b
efore
T
uring
that
the
set
of
op
erations
that
can
b
e
expressed
in
lam
b
da
calculus
formalizes
the

Actually
more
since
it
neglects
the
necessary
nite
limit
to
the
computers
store
Arguably
an
y
existing
computer
is
actually
a
nite
state
mac
hine
but
the
assumption
of
un
b
ounded
memory
seems
a
more
fruitful
abstraction



in
tuitiv
e
idea
of
a
mec
hanical
pro
cedure
a
p
ostulate
kno
wn
as
Chur
ch
s
thesis
Ch
urc
h
		
sho
w
ed
that
if
this
w
as
accepted
the
Entscheidungspr
oblem
is
unsolv
able
T
uring
later
sho
w
ed
that
the
functions
denable
in
lam
b
da
calculus
are
precisely
those
computable
b
y
a
T
uring
mac
hine
whic
h
len
t
more
credibilit
y
to
Ch
urc
hs
claims
T
o
a
mo
dern
programmer
T
uring
mac
hine
programs
are
just
ab
out
recog
nizable
as
a
v
ery
primitiv
e
kind
of
mac
hine
co
de
Indeed
it
seems
that
T
uring
mac
hines
and
in
particular
T
urings
construction
of
a
univ
ersal
mac
hine

w
ere
a
k
ey
inuence
in
the
dev
elopmen
t
of
mo
dern
stored
program
computers
though
the
exten
t
and
nature
of
this
inuence
is
still
a
matter
for
con
tro
v
ersy
	Robinson
		
It
is
remark
able
that
sev
eral
of
the
other
prop
osals
for
a
denition
of
mec
hanical
pro
cedure
often
made
b
efore
the
adv
en
t
of
electronic
computers
corresp
ond
closely
to
real
programming
metho
ds
F
or
example
Mark
o
v
algo
rithms
the
standard
approac
h
to
computabilit
y
in
the
	former
So
viet
Union
can
b
e
seen
as
underlying
the
programming
language
SNOBOL
In
what
follo
ws
w
e
are
concerned
with
the
inuence
of
lam
b
da
calculus
on
functional
program
ming
languages
LISP

the
second
oldest
high
lev
el
language
	F
OR
TRAN
b
eing
the
oldest
to
ok
a
few
ideas
from
lam
b
da
calculus
in
particular
the
notation
	LAMBD
A




for
anon
ymous
functions
Ho
w
ev
er
it
w
as
not
really
based
on
lam
b
da
calculus
at
all
In
fact
the
early
v
ersions
and
some
curren
t
dialects
use
a
system
of
dynamic
binding
that
do
es
not
corresp
ond
to
lam
b
da
calculus
	W
e
will
discuss
this
later
Moreo
v
er
there
w
as
no
real
supp
ort
for
higher
order
functions
while
there
w
as
considerable
use
of
imp
erativ
e
features
Nev
ertheless
LISP
deserv
es
to
b
e
considered
as
the
rst
functional
programming
language
and
pioneered
man
y
of
the
asso
ciated
tec
hniques
suc
h
as
automatic
storage
allo
cation
and
garbage
collection
The
inuence
of
lam
b
da
calculus
really
to
ok
o
with
the
w
ork
of
Landin
and
Strac
hey
in
the
s
In
particular
Landin
sho
w
ed
ho
w
man
y
features
of
curren
t
	imp
erativ
e
languages
could
usefully
b
e
analyzed
in
terms
of
lam
b
da
calculus
eg
the
notion
of
v
ariable
scoping
in
Algol

Landin
		
w
en
t
on
to
prop
ose
the
use
of
lam
b
da
calculus
as
a
core
for
programming
languages
and
in
v
en
ted
a
functional
language
ISWIM
	If
y
ou
See
What
I
Mean
This
w
as
widely
inuen
tial
and
spa
wned
man
y
real
languages
ML
started
life
as
the
metalanguage
	hence
the
name
ML
of
a
theorem
pro
v
ing
system
called
Edin
burgh
LCF
	Gordon
Milner
and
W
adsw
orth
		
That
is
it
w
as
in
tended
as
a
language
in
whic
h
to
write
algorithms
for
pro
ving
theo
rems
in
a
formal
deductiv
e
calculus
It
w
as
strongly
inuenced
b
y
ISWIM
but
added
an
inno
v
ativ
e
p
olymorphic
t
yp
e
system
including
abstract
t
yp
es
as
w
ell
as
a
system
of
exc
eptions
to
deal
with
error
conditions
These
facilities
w
ere
dictated

A
single
T
uring
mac
hine
program
capable
of
sim
ulating
an
y
other

w
e
w
ould
no
w
regard
it
as
an
interpr
eter
Y
ou
will
learn
ab
out
this
in
the
course
on
Computation
Theory


CHAPTER

LAMBD
A
CALCULUS
AS
A
PR
OGRAMMING
LANGUA
GE
b
y
the
application
at
hand
and
this
p
olicy
resulted
in
a
coheren
t
and
fo
cused
design
This
narro
wness
of
fo
cus
is
t
ypical
of
successful
languages
	C
is
another
go
o
d
example
and
con
trasts
sharply
with
the
failure
of
committeedesigned
lan
guages
lik
e
Algol

whic
h
ha
v
e
serv
ed
more
as
a
source
of
imp
ortan
t
ideas
than
as
p
opular
practical
to
ols
W
e
will
ha
v
e
more
to
sa
y
ab
out
ML
later
Let
us
no
w
see
ho
w
pur
e
lamb
da
c
alculus
can
b
e
used
as
a
programming
language

Represen
ting
data
in
lam
b
da
calculus
Programs
need
data
to
w
ork
on
so
w
e
start
b
y
xing
lam
b
da
expressions
to
enco
de
data
F
urthermore
w
e
dene
a
few
basic
op
erations
on
this
data
In
man
y
cases
w
e
sho
w
ho
w
a
string
of
h
umanreadable
syn
tax
s
can
b
e
translated
directly
in
to
a
lam
b
da
expression
s
 
This
pro
cedure
is
kno
wn
as
syn
tactic
sugaring

it
mak
es
the
bitter
pill
of
pure
lam
b
da
notation
easier
to
digest
W
e
write
suc
h
denitions
as
s


s
 This
notation
means
s

s
 b
y
denition
one
also
commonly
sees
this
written
as
s

def
s
 
If
preferred
w
e
could
alw
a
ys
regard
these
as
dening
a
single
constan
t
denoting
that
op
eration
whic
h
is
then
applied
to
argumen
ts
in
the
usual
lam
b
da
calculus
st
yle
the
surface
notation
b
eing
irrelev
an
t
F
or
example
w
e
can
imagine
if
E
then
E

else
E


as
COND
E
E

E


for
some
constan
t
COND
In
suc
h
cases
an
y
v
ariables
on
the
left
of
the
denition
need
to
b
e
abstracted
o
v
er
eg
instead
of
fst
p


p
true
	see
b
elo
w
w
e
could
write
fst


p
p
true

T
ruth
v
alues
and
the
conditional
W
e
can
use
an
y
unequal
lam
b
da
expressions
to
stand
for
true
and
false
but
the
follo
wing
w
ork
particularly
smo
othly
true


x
y

x
false


x
y

y
Giv
en
those
denitions
w
e
can
easily
dene
a
conditional
expression
just
lik
e
Cs

construct
Note
that
this
is
a
conditional
expr
ession
not
a
conditional


REPRESENTING
D
A
T
A
IN
LAMBD
A
CALCULUS

c
ommand
	this
notion
mak
es
no
sense
in
our
con
text
and
therefore
the
else
arm
is
compulsory
if
E
then
E

else
E



E
E

E

indeed
w
e
ha
v
e
if
true
then
E

else
E


true
E

E


	x
y

x
E

E


E

and
if
false
then
E

else
E


false
E

E


	x
y

y

E

E


E

Once
w
e
ha
v
e
the
conditional
it
is
easy
to
dene
all
the
usual
logical
op
erations
not
p


if
p
then
false
else
true
p
and
q


if
p
then
q
else
false
p
or
q


if
p
then
true
else
q

P
airs
and
tuples
W
e
can
represen
t
ordered
pairs
as
follo
ws
	E


E




f

f
E

E

The
paren
theses
are
not
obligatory

but
w
e
often
use
them
for
the
sak
e
of
familiarit
y
or
to
enforce
asso
ciations
In
fact
w
e
simply
regard
the
comma
as
an
inx
op
erator
lik
e
"
Giv
en
the
ab
o
v
e
denition
the
corresp
onding
destructors
for
pairs
can
b
e
dened
as
fst
p


p
true
snd
p


p
false
It
is
easy
to
see
that
these
w
ork
as
required

CHAPTER

LAMBD
A
CALCULUS
AS
A
PR
OGRAMMING
LANGUA
GE
fst
	p
q


	p
q

true

	f

f
p
q

true

true
p
q

	x
y

x
p
q

p
and
snd
	p
q


	p
q

false

	f

f
p
q

false

false
p
q

	x
y

y

p
q

q
W
e
can
build
up
triples
quadruples
quin
tuples
indeed
arbitrary
ntuples
b
y
iterating
the
pairing
construct
	E


E






E
n


	E


	E





E
n

W
e
need
simply
sa
y
that
the
inx
comma
op
erator
is
righ
tasso
ciativ
e
and
can
understand
this
without
an
y
other
con
v
en
tions
F
or
example
	p
q

r

s

	p
	q

	r

s

f

f
p
	q

	r

s

f

f
p
	f

f
q
	r

s

f

f
p
	f

f
q
	f

f
r
s

f

f
p
	g

g
q
	h
h
r
s
where
in
the
last
line
w
e
ha
v
e
p
erformed
an
alphacon
v
ersion
for
the
sak
e
of
clarit
y

Although
tuples
are
built
up
in
a
at
manner
it
is
easy
to
create
arbitrary
nitelybranc
hing
tree
structures
b
y
using
tupling
rep
eatedly

Finally

if
one
prefers
con
v
en
tional
functions
o
v
er
Cartesian
pro
ducts
to
our
curried
functions
one
can
con
v
ert
b
et
w
een
the
t
w
o
using
the
follo
wing
CURR
Y
f


x
y

f
	x
y

UNCURR
Y
g


p
g
	fst
p
	snd
p


REPRESENTING
D
A
T
A
IN
LAMBD
A
CALCULUS
	
These
sp
ecial
op
erations
for
pairs
can
easily
b
e
generalized
to
arbitrary
n
tuples
F
or
example
w
e
can
dene
a
selector
function
to
get
the
i
th
comp
onen
t
of
a
at
tuple
p
W
e
will
write
this
op
eration
as
	p
i
and
dene
	p


fst
p
and
the
others
b
y
	p
i

fst
	snd
i
p
Lik
ewise
w
e
can
generalize
CURR
Y
and
UNCURR
Y
CURR
Y
n
f


x




x
n

f
	x






x
n

UNCURR
Y
n
g


p
g
	p




	p
n
W
e
can
no
w
write
	x






x
n

t
as
an
abbreviation
for
UNCURR
Y
n
	x




x
n

t
giving
a
natural
notation
for
functions
o
v
er
Cartesian
pro
ducts

The
natural
n
um
b
ers
W
e
will
represen
t
eac
h
natural
n
um
b
er
n
as
follo
ws

n


f
x
f
n
x
that
is


f
x
x


f
x
f
x


f
x
f
	f
x
etc
These
represen
ta
tions
are
kno
wn
as
Chur
ch
numer
als
though
the
basic
idea
w
as
used
earlier
b
y
Wittgenstein
		

They
are
not
a
v
ery
ecien
t
represen
tation
amoun
ting
essen
tially
to
coun
ting
in
unary











There
are
from
an
eciency
p
oin
t
of
view
m
uc
h
b
etter
w
a
ys
of
represen
ting
n
um
b
ers
eg
tuples
of
trues
and
falses
as
binary
expansions
But
at
the
momen
t
w
e
are
only
in
terested
in
computabilit
y
in
principle
and
Ch
urc
h
n
umerals
ha
v
e
v
arious
nice
formal
prop
erties
F
or
example
it
is
easy
to
giv
e
lam
b
da
expressions
for
the
common
arithmetic
op
erators
suc
h
as
the
successor
op
erator
whic
h
adds
one
to
its
argumen
t
SUC


n
f
x
n
f
	f
x
Indeed
SUC
n

	n
f
x
n
f
	f
x	f
x
f
n
x

f
x
	f
x
f
n
xf
	f
x

f
x
	x
f
n
x	f
x

The
n
in
f
n
x
is
just
a
metanotation
and
do
es
not
mean
that
there
is
an
ything
circular
ab
out
our
denition


A
n
um
b
er
is
the
exp
onen
t
of
an
op
eration

CHAPTER

LAMBD
A
CALCULUS
AS
A
PR
OGRAMMING
LANGUA
GE

f
x
f
n
	f
x

f
x
f
n

x

n
"

Similarly
it
is
easy
to
test
a
n
umeral
to
see
if
it
is
zero
ISZER
O
n


n
	x
false
true
since
ISZER
O


	f
x
x	x
false

true

true
and
ISZER
O
	n
"


	f
x
f
n

x	x
falsetrue

	x
false
n

true

	x
false		x
false

n
true

false
The
follo
wing
p
erform
addition
and
m
ultiplication
on
Ch
urc
h
n
umerals
m
"
n


f
x
m
f
	n
f
x
m

n


f
x
m
	n
f

x
Indeed
m
"
n

f
x
m
f
	n
f
x

f
x
	f
x
f
m
x
f
	n
f
x

f
x
	x
f
m
x
	n
f
x

f
x
f
m
	n
f
x

f
x
f
m
		f
x
f
n
x
f
x

f
x
f
m
		x
f
n
x
x

f
x
f
m
	f
n
x

f
x
f
m
n
x
and
m

n

f
x
m
	n
f

x

f
x
	f
x
f
m
x
	n
f

x


RECURSIVE
FUNCTIONS


f
x
	x
	n
f

m
x
x

f
x
	n
f

m
x

f
x
		f
x
f
n
x
f

m
x

f
x
		x
f
n
x
m
x

f
x
	f
n

m
x

f
x
f
mn
x
Although
those
op
erations
on
natural
n
um
b
ers
w
ere
fairly
easy

a
predecessor
function
is
m
uc
h
harder
What
is
required
is
a
a
lam
b
da
expression
P
R
E
so
that
P
R
E



and
P
R
E
	n
"


n
Finding
suc
h
an
expression
w
as
the
rst
piece
of
mathematical
researc
h
b
y
the
logician
Kleene
		
His
tric
k
w
as
giv
en
f
x
f
n
x
to
thro
w
a
w
a
y
one
of
the
applications
of
f

The
rst
step
is
to
dene
a
function
PREFN
that
op
erates
on
pairs
suc
h
that
PREFN
f
	true
x

	false
x
and
PREFN
f
	false
x

	false
f
x
Giv
en
this
function
then
	PREFN
f

n

	true
x

	false

f
n
x
whic
h
is
enough
to
let
us
dene
a
predecessor
function
without
m
uc
h
dicult
y

Here
is
a
suitable
denition
of
PREFN
PREFN


f
p
	false

if
fst
p
then
snd
p
else
f
	snd
p
No
w
w
e
dene
PRE
n


f
x
snd
	n
	PREFN
f

	true
x
It
is
left
as
an
exercise
to
the
reader
to
see
that
this
w
orks
correctly


Recursiv
e
functions
Being
able
to
dene
functions
b
y
recursion
is
a
cen
tral
feature
of
functional
pro
gramming
it
is
the
only
general
w
a
y
of
p
erforming
something
comparable
to
iteration
A
t
rst
sigh
t
it
app
ears
that
w
e
ha
v
e
no
w
a
y
of
doing
this
in
lam
b
da
calculus
Indeed
it
w
ould
seem
that
the
naming
of
the
function
is
a
vital
part
of
making
a
recursiv
e
denition
since
otherwise
ho
w
can
w
e
refer
to
it
on
the
righ
t
hand
side
of
the
denition
without
descending
in
to
innite
regress
Rather
sur
prisingly

it
can
b
e
done
although
as
with
the
existence
of
a
predecessor
function
this
fact
w
as
only
disco
v
ered
after
considerable
eort
The
k
ey
is
the
existence
of
socalled
xe
d
p
oint
c
ombinators
A
closed
lam
b
da
term
Y
is
said
to
b
e
a
xed
p
oin
t
	or
xp
oin
t
com
binator
when
for
all
lam
b
da

CHAPTER

LAMBD
A
CALCULUS
AS
A
PR
OGRAMMING
LANGUA
GE
terms
f

w
e
ha
v
e
f
	Y
f


Y
f

That
is
a
xed
p
oin
t
com
binator
giv
en
an
y
term
f
as
an
argumen
t
returns
a
xed
p
oin
t
for
f

ie
a
term
x
suc
h
that
f
	x

x
The
rst
suc
h
com
binator
to
b
e
found
	b
y
Curry
is
usually
called
Y

It
can
b
e
motiv
ated
b
y
recalling
the
Russell
parado
x
and
for
this
reason
is
often
called
the
parado
xical
com
binator
W
e
dened
R

x
	x
x
and
found
that
R
R

	R
R

That
is
R
R
is
a
xed
p
oin
t
of
the
negation
op
erator
So
in
order
to
get
a
general
xed
p
oin
t
com
binator
all
w
e
need
to
do
is
generalize

in
to
whatev
er
function
is
giv
en
it
as
argumen
t
Therefore
w
e
set
Y


f

	x
f
	x
x	x
f
	x
x
It
is
a
simple
matter
to
sho
w
that
it
w
orks
Y
f

	f

	x
f
	x
x	x
f
	x
x
f

	x
f
	x
x	x
f
	x
x

f
		x
f
	x
x	x
f
	x
x

f
	Y
f

Though
v
alid
from
a
mathematical
p
oin
t
of
view
this
is
not
so
attractiv
e
from
a
programming
p
oin
t
of
view
since
the
ab
o
v
e
w
as
only
v
alid
for
lam
b
da
equalit
y

not
reduction
	in
the
last
line
w
e
p
erformed
a
b
ackwar
ds
b
eta
con
v
ersion
F
or
this
reason
the
follo
wing
alternativ
e
due
to
T
uring
ma
y
b
e
preferred
T


	x
y

y
	x
x
y

	x
y

y
	x
x
y

	The
pro
of
that
T
f

 f
	T
f

is
left
as
an
exercise
Ho
w
ev
er
it
do
es
no
harm
if
w
e
simply
allo
w
Y
f
to
b
e
b
etareduced
throughout
the
reduction
sequence
for
a
recursiv
ely
dened
function
No
w
let
us
see
ho
w
to
use
a
xed
p
oin
t
com
binator
	sa
y
Y

to
implemen
t
recursiv
e
functions
W
e
will
tak
e
the
factorial
function
as
an
example
W
e
w
an
t
to
dene
a
function
fact
with
fact
	n

if
ISZER
O
n
then

else
n

fact	PRE
n
The
rst
step
is
to
transform
this
in
to
the
follo
wing
equiv
alen
t
fact

n
if
ISZER
O
n
then

else
n

fact	PRE
n
whic
h
in
its
turn
is
equiv
alen
t
to


LET
EXPRESSIONS

fact

	f
n
if
ISZER
O
n
then

else
n

f
	PRE
n
fact
This
exhibits
fact
as
the
xed
p
oin
t
of
a
function
F

namely
F

f
n
if
ISZER
O
n
then

else
n

f
	PRE
n
Consequen
tly
w
e
merely
need
to
set
fact

Y
F

Similar
tec
hniques
w
ork
for
m
utually
recursiv
e
functions
ie
a
set
of
functions
whose
denitions
are
m
utually
dep
enden
t
A
denition
suc
h
as
f


F

f




f
n
f


F

f




f
n







f
n

F
n
f




f
n
can
b
e
transformed
using
tuples
in
to
a
single
equation
	f


f






f
n


	F

f




f
n

F

f




f
n





F
n
f




f
n

If
w
e
no
w
write
t

	f


f






f
n

then
eac
h
of
the
functions
on
the
righ
t
can
b
e
reco
v
ered
b
y
applying
the
appropriate
selector
to
t
w
e
ha
v
e
f
i

	t
i

After
abstracting
out
t
this
giv
es
an
equation
in
the
canonical
form
t

F
t
whic
h
can
b
e
solv
ed
b
y
t

Y
F

No
w
the
individual
functions
can
b
e
reco
v
ered
from
t
b
y
the
same
metho
d
of
selecting
comp
onen
ts
of
the
tuple

Let
expressions
W
ev
e
touted
the
abilit
y
to
write
anon
ymous
functions
as
one
of
the
merits
of
lam
b
da
calculus
and
sho
wn
that
names
are
not
necessary
to
dene
recursiv
e
functions
Nev
ertheless
it
is
often
useful
to
b
e
able
to
giv
e
names
to
expressions
to
a
v
oid
tedious
rep
etition
of
large
terms
A
simple
form
of
naming
can
b
e
supp
orted
as
another
syn
tactic
sugar
on
top
of
pure
lam
b
da
calculus
let
x

s
in
t


	x
t
s
F
or
example
as
w
e
w
ould
exp
ect
	let
z


"

in
z
"
z


	z

z
"
z

	
"


	
"

"
	
"

W
e
can
ac
hiev
e
the
binding
of
m
ultiple
names
to
expressions
either
in
a
serial
or
parallel
fashion
F
or
the
rst
w
e
will
simply
iterate
the
ab
o
v
e
construct
F
or
the
latter
w
e
will
write
m
ultiple
bindings
separated
b
y
and

CHAPTER

LAMBD
A
CALCULUS
AS
A
PR
OGRAMMING
LANGUA
GE
let
x


s

and



and
x
n

s
n
in
t
and
regard
it
as
syn
tactic
sugar
for
		x






x
n

t
	s






s
n

T
o
illustrate
the
distinction
b
et
w
een
serial
and
parallel
binding
consider
let
x


in
let
x


in
let
y

x
in
x
"
y
whic
h
should
yield

while
let
x


in
let
x


and
y

x
in
x
"
y
should
yield

W
e
will
also
allo
w
argumen
ts
to
names
b
ound
b
y
let
again
this
can
b
e
regarded
as
syn
tactic
sugar
with
f
x




x
n

t
meaning
f

x




x
n

t
Instead
of
a
prex
let
x

s
in
t
w
e
will
allo
w
a
p
ostx
v
ersion
whic
h
is
sometimes
more
readable
t
where
x

s
F
or
example
w
e
migh
t
write
y

y

where
y


"
x
Normally

the
let
and
where
constructs
will
b
e
in
terpreted
as
ab
o
v
e
in
a
nonrecursiv
e
fashion
F
or
example
let
x

x


in



binds
x
to
one
less
than
whatev
er
v
alue
it
is
b
ound
to
outside
rather
than
trying
to
bind
x
to
the
xed
p
oin
t
of
x

x



Ho
w
ev
er
where
a
recursiv
e
in
terpretation
is
required
w
e
add
the
w
ord
rec
writing
let
rec
or
where
rec
eg
let
rec
fact	n

if
ISZER
O
n
then

else
n

fact	PRE
n
This
can
b
e
regarded
as
a
shorthand
for
let
fact

Y
F

where
F

f
n
if
ISZER
O
n
then

else
n

f
	PRE
n
as
explained
ab
o
v
e

There
is
suc
h
a
xed
p
oin
t
but
the
lam
b
da
term
in
v
olv
ed
has
no
normal
form
so
is
in
a
sense
undened
The
seman
tics
of
non
terminating
terms
is
subtle
and
w
e
will
not
consider
it
at
length
here
Actually

the
salien
t
question
is
not
whether
a
term
has
a
normal
form
but
whether
it
has
a
socalled
he
ad
normal
form

see
Barendregt
	
and
also
Abramsky
		



STEPS
TO
W
ARDS
A
REAL
PR
OGRAMMING
LANGUA
GE


Steps
to
w
ards
a
real
programming
language
W
e
ha
v
e
established
a
fairly
extensiv
e
system
of
syn
tactic
sugar
to
supp
ort
a
h
umanreadable
syn
tax
on
top
of
pure
lam
b
da
calculus
It
is
remark
able
that
this
device
is
enough
to
bring
us
to
the
p
oin
t
where
w
e
can
write
the
denition
of
the
factorial
function
almost
in
the
w
a
y
w
e
can
in
ML
In
what
sense
though
is
the
lam
b
da
calculus
augmen
ted
with
these
notational
con
v
en
tions
really
a
programming
language
Ultimately

a
program
is
just
a
single
expression
Ho
w
ev
er
giv
en
the
use
of
let
to
bind
v
arious
imp
ortan
t
sub
expressions
to
names
it
is
natural
instead
to
view
the
program
as
a
set
of
denitions
of
auxiliary
functions
follo
w
ed
nally
b
y
the
expression
itself
eg
let
rec
fact	n

if
ISZER
O
n
then

else
n

fact	PRE
n
in



f
act	
W
e
can
read
these
denitions
of
auxiliary
functions
as
equations
in
the
mathe
matical
sense
Understo
o
d
in
this
w
a
y

they
do
not
giv
e
an
y
explicit
instructions
on
ho
w
to
ev
aluate
expressions
or
ev
en
in
whic
h
direction
the
equations
are
to
b
e
used
F
or
this
reason
functional
programming
is
often
referred
to
as
a
de
clar
ative
programming
metho
d
as
also
is
logic
programming
	eg
PR
OLOG

The
program
do
es
not
incorp
orate
explicit
instructions
merely
declares
certain
prop
erties
of
the
relev
an
t
notions
and
lea
v
es
the
rest
to
the
mac
hine
A
t
the
same
time
the
program
is
useless
or
at
least
am
biguous
unless
the
mac
hine
someho
w
reacts
sensibly
to
it
Therefore
it
m
ust
b
e
understo
o
d
that
the
program
alb
eit
from
a
sup
ercial
p
oin
t
of
view
purely
declarativ
e
is
to
b
e
executed
in
a
certain
w
a
y

In
fact
the
expression
is
ev
aluated
b
y
expanding
all
instances
of
dened
notions
	ie
reading
the
equations
from
left
to
righ
t
and
then
rep
eatedly
p
erforming

con
v
ersions
That
is
although
there
seems
to
b
e
no
pro
cedural
information
in
the
program
a
p
articular
exe
cution
str
ate
gy
is
understo
o
d
In
a
sense
then
the
term
declarativ
e
is
largely
a
matter
of
h
uman
psyc
hology

Moreo
v
er
there
m
ust
b
e
a
denite
con
v
en
tion
for
the
reduction
strategy
to
use
for
w
e
kno
w
that
dieren
t
c
hoices
of

redex
can
lead
to
dieren
t
b
eha
viour
with
resp
ect
to
termination
Consequen
tly

it
is
only
when
w
e
sp
ecify
this
that
w
e
really
get
a
denite
programming
language
W
e
will
see
in
later
c
hapters
ho
w
dieren
t
functional
languages
mak
e
dieren
t
c
hoices
here
But
rst
w
e
pause
to
consider
the
incorp
oration
of
t
yp
es

Apparen
tly
Landin
preferred
denotativ
e
to
declarativ
e

CHAPTER

LAMBD
A
CALCULUS
AS
A
PR
OGRAMMING
LANGUA
GE

F
urther
reading
Man
y
of
the
standard
texts
already
cited
include
details
ab
out
the
matters
dis
cussed
here
In
particular
Gordon
		
giv
es
a
clear
pro
of
that
lam
b
da
calculus
is
T
uringcomplete
and
that
the
lam
b
da
calculus
analog
of
the
halting
problem
	whether
a
term
has
a
normal
form
is
unsolv
able
The
inuence
of
lam
b
da
cal
culus
on
real
programming
languages
and
the
ev
olution
of
functional
languages
are
discussed
b
y
Hudak
			
Exercises

Justify
generalized

con
v
ersion
ie
pro
v
e
that
		x






x
n

tx






x
n
 	t






t
n


tt






t
n
 

Dene
f

g


x
f
	g
x
and
recall
that
I

x
x
Pro
v
e
that
CURR
Y

UNCURR
Y

I

Is
it
also
true
that
UNCURR
Y

CURR
Y

I


What
arithmetical
op
eration
do
es
n
f
x
f
	n
f
x
p
erform
on
Ch
urc
h
n
umerals
What
ab
out
m
n
n
m

Pro
v
e
that
the
follo
wing
	due
to
Klop
is
a
xed
p
oin
t
com
binator
                          where
 

abcdef
g
hij
k
l
mnopq
stuv
w
xy
z
r

r
	thisisaf
ixedpointcombinator


Mak
e
a
recursiv
e
denition
of
natural
n
um
b
er
subtraction

Consider
the
follo
wing
represen
tation
of
lists
due
to
Mairson
			
nil

c
n
n
cons

x
l
c
n
c
x
	l
c
n
head

l

l
	x
y

x
nil
tail

l

snd
	l
	x
p
	cons
x
	fst
p
fst
p
	nil

nil

app
end

l

l


l

cons
l

app
end
lists

L
L
app
end
nil


FUR
THER
READING

map

f
l

l
	x
cons
	f
x
nil
length

l

l
	x
SUC

tac
k

x
l

l
cons
	cons
x
nil

rev
erse

l

l
tac
k
nil
lter

l
test
l
	x
	test
x	cons
x	y

y

nil
Wh
y
do
es
Mairson
call
them
Ch
urc
h
lists

What
do
all
these
functions
do

Chapter

T
yp
es
T
yp
es
are
a
means
of
distinguishing
dieren
t
sorts
of
data
lik
e
b
o
oleans
natural
n
um
b
ers
and
functions
and
making
sure
that
these
distinctions
are
resp
ected
b
y

for
example
ensuring
that
functions
cannot
b
e
applied
to
argumen
ts
of
the
wrong
t
yp
e
Wh
y
should
w
e
w
an
t
to
add
t
yp
es
to
lam
b
da
calculus
and
to
programming
languages
deriv
ed
from
it
W
e
can
distinguish
reasons
from
logic
and
reasons
from
programming
F
rom
the
logical
p
oin
t
of
view
w
e
ha
v
e
seen
that
the
Russell
parado
x
mak
es
it
dicult
to
extend
lam
b
da
calculus
with
set
theory
without
con
tradiction
The
Russell
parado
x
ma
y
w
ell
arise
b
ecause
of
the
p
eculiar
selfreferen
tial
nature
of
the
tric
k
in
v
olv
ed
w
e
apply
a
function
to
itself
Ev
en
if
it
w
erent
necessary
to
a
v
oid
parado
x
w
e
migh
t
feel
that
in
tuitiv
ely
w
e
really
ha
v
e
a
p
o
or
grip
of
whats
going
on
in
a
system
where
w
e
can
do
suc
h
things
Certainly
applying
some
functions
to
themselv
es
eg
the
iden
tit
y
function
x
x
or
a
constan
t
function
x
y

seems
quite
inno
cuous
But
surely
w
e
w
ould
ha
v
e
a
clearer
picture
of
what
sort
of
functions
lam
b
da
terms
denote
if
w
e
knew
exactly
what
their
domains
and
co
domains
w
ere
and
only
applied
them
to
argumen
ts
in
their
domains
These
w
ere
the
sorts
of
reasons
wh
y
Russell
originally
in
tro
duced
t
yp
es
in
Principia
Mathematic
a
T
yp
es
also
arose
p
erhaps
at
rst
largely
indep
enden
tly
of
the
ab
o
v
e
con
siderations
in
programming
languages
and
since
w
e
view
lam
b
da
calculus
as
a
programming
language
this
motiv
ates
us
to
o
Ev
en
F
OR
TRAN
distinguished
in
tegers
and
oating
p
oin
t
v
alues
One
reason
w
as
clearly
eciency
the
mac
hine
can
generate
more
ecien
t
co
de
and
use
storage
more
eectiv
ely

b
y
kno
wing
more
ab
out
a
v
ariable
F
or
example
the
implemen
tation
of
Cs
p
oin
ter
arith
metic
v
aries
according
to
the
size
of
the
referenced
ob
jects
If
p
is
a
p
oin
ter
to
ob
jects
o
ccup
ying

b
ytes
then
what
C
programmers
write
as
p
"

b
ecomes
p
"

inside
a
b
yteaddressed
mac
hine
Cs
ancestor
BCPL
is
un
t
yp
ed
and
is
therefore
unable
to
distinguish
p
oin
ters
from
in
tegers
to
supp
ort
the
same
st
yle
of
p
oin
ter
arithmetic
it
is
necessary
to
apply
a
scaling
at
ev
ery
indirection
a
signican
t
p
enalt
y




TYPED
LAMBD
A
CALCULUS
	
Apart
from
eciency

as
time
w
en
t
b
y

t
yp
es
also
b
egan
to
b
e
appreciated
more
and
more
for
their
v
alue
in
pro
viding
limited
static
c
hec
ks
on
programs
Man
y
programming
errors
either
trivial
t
yp
os
or
more
substan
tial
conceptual
errors
are
suggested
b
y
t
yp
e
clashes
and
these
can
b
e
detected
b
efore
running
the
program
during
the
compilation
pro
cess
Moreo
v
er
t
yp
es
often
serv
e
as
useful
do
cumen
tation
for
p
eople
reading
co
de
Finally

t
yp
es
can
b
e
used
to
ac
hiev
e
b
etter
mo
dularization
and
data
hiding
b
y
articially
distinguishing
some
data
structure
from
its
in
ternal
represen
tation
A
t
the
same
time
some
programmers
dislik
e
t
yp
es
b
ecause
they
nd
the
restrictions
placed
on
their
programming
st
yle
irksome
There
are
un
t
yp
ed
pro
gramming
languages
imp
erativ
e
ones
lik
e
BCPL
and
functional
ones
lik
e
ISWIM
SASL
and
Erlang
Others
lik
e
PLI
ha
v
e
only
we
ak
typing
with
the
compiler
allo
wing
some
mixtures
of
dieren
t
t
yp
es
and
casting
them
appropriately

There
are
also
languages
lik
e
LISP
that
p
erform
t
yp
ec
hec
king
dynamic
al
ly
during
exe
cution
rather
than
statically
during
compilation
This
can
	at
least
in
principle
degrade
run
time
p
erformance
since
it
means
that
the
computer
is
sp
ending
some
time
on
making
sure
t
yp
es
are
resp
ected
during
execution

compare
c
hec
king
of
arra
y
b
ounds
during
execution
another
common
run
time
o
v
erhead
By
con
trast
w
e
ha
v
e
suggested
that
static
t
yping
if
an
ything
can
impro
v
e
p
erformance
Just
ho
w
restrictiv
e
a
t
yp
e
system
is
found
dep
ends
a
lot
on
the
nature
of
the
programmers
applications
and
programming
st
yle
Finding
a
t
yp
e
system
that
allo
ws
useful
static
t
yp
ec
hec
king
while
at
the
same
time
allo
wing
programmers
plen
t
y
of
exibilit
y

is
still
an
activ
e
researc
h
area
The
ML
t
yp
e
system
is
an
imp
ortan
t
step
along
this
road
since
it
features
p
olymorphism
allo
wing
the
same
function
to
b
e
used
with
v
arious
dieren
t
t
yp
es
This
retains
strong
static
t
yp
e
c
hec
king
while
giving
some
of
the
b
enets
of
w
eak
or
dynamic
t
yping

Moreo
v
er
programmers
nev
er
need
to
sp
ecify
any
t
yp
es
in
ML

the
computer
can
infer
a
most
general
t
yp
e
for
ev
ery
expression
and
reject
expressions
that
are
not
t
y
pable
W
e
will
consider
p
olymorphism
in
the
setting
of
lam
b
da
calculus
b
elo
w
Certainly

the
ML
t
yp
e
system
pro
vides
a
congenial
en
vironmen
t
for
man
y
kinds
of
programming
Nev
ertheless
w
e
do
not
w
an
t
to
giv
e
the
impression
that
it
is
necessarily
the
answ
er
to
all
programming
problems

T
yp
ed
lam
b
da
calculus
It
is
a
fairly
straigh
tforw
ard
matter
to
mo
dify
lam
b
da
calculus
with
a
notion
of
t
yp
e
but
the
resulting
c
hanges
as
w
e
shall
see
are
farreac
hing
The
basic
idea
is
that
ev
ery
lam
b
da
term
has
a
typ
e
and
a
term
s
can
only
b
e
applied
to
a
term
t
in
a
com
bination
s
t
when
the
t
yp
es
matc
h
up
appropriately

ie
s
has
the
t
yp
e
of
a
function
  
and
t
has
t
yp
e
 
The
result
s
t
then
has
t
yp
e


This
is
in
programming
language
parlance
str
ong
typing
The
term
t
m
ust
ha
v
e
exactly

As
w
ell
p
erhaps
as
some
of
the
o
v
erheads


CHAPTER

TYPES
the
t
yp
e
 
there
is
no
notion
of
subt
yping
or
co
ercion
This
con
trasts
with
some
programming
languages
lik
e
C
where
a
function
exp
ecting
an
argumen
t
of
t
yp
e
float
or
double
will
accept
one
of
t
yp
e
int
and
appropriately
cast
it
Similar
notions
of
subt
yping
and
co
ercion
can
also
b
e
added
to
lam
b
da
calculus
but
to
consider
these
here
w
ould
lead
us
to
o
far
astra
y

W
e
will
use
t

 
to
mean
t
has
t
yp
e
 
This
is
already
the
standard
notation
in
mathematics
where
function
spaces
are
concerned
b
ecause
f

  
means
that
f
is
a
function
from
the
set
 to
the
set


W
e
will
think
of
t
yp
es
as
sets
in
whic
h
the
corresp
onding
ob
jects
liv
e
and
imagine
t

 to
mean
t

 
Though
the
reader
ma
y
lik
e
to
do
lik
ewise
as
a
heuristic
device
w
e
will
view
t
yp
ed
lam
b
da
calculus
purely
as
a
formal
system
and
mak
e
the
rules
indep
enden
t
of
an
y
suc
h
in
terpretation

The
sto
c
k
of
t
yp
es
The
rst
stage
in
our
formalization
is
to
sp
ecify
exactly
what
the
t
yp
es
are
W
e
supp
ose
rst
of
all
that
w
e
ha
v
e
some
set
of
primitive
typ
es
whic
h
migh
t
for
example
con
tain
bool
and
int
W
e
can
construct
comp
osite
t
yp
es
from
these
using
the
function
space
typ
e
c
onstructor
F
ormally

w
e
mak
e
the
follo
wing
inductiv
e
denition
of
the
set
T
y
C
of
t
yp
es
based
on
a
set
of
primitiv
e
t
yp
es
C

 
C
 
T
y
C
 
T
y
C


T
y
C
  

T
y
C
F
or
example
p
ossible
t
yp
es
migh
t
b
e
int
bool
 bool
and
	int
 bool

 int
 bool

W
e
assume
that
the
function
arro
w
asso
ciates
to
the
righ
t
ie
  
 
means
  	
 

This
ts
naturally
with
the
other
syn
tactic
con
v
en
tions
connected
with
currying
Before
long
w
e
shall
extend
the
t
yp
e
system
in
t
w
o
w
a
ys
First
w
e
will
allo
w
socalled
typ
e
variables
as
w
ell
as
primitiv
e
t
yp
e
constan
ts

these
are
the
v
ehicle
for
p
olymorphism
Secondly

w
e
will
allo
w
the
in
tro
duction
of
other
t
yp
e
constructors
b
esides
the
function
arro
w
F
or
example
w
e
will
later
in
tro
duce
a
constructor

for
the
pro
duct
t
yp
e
In
that
case
a
new
clause
 
T
y
C


T
y
C
 


T
y
C
needs
to
b
e
added
to
the
inductiv
e
denition
Once
w
e
mo
v
e
to
the
more
concrete
case
of
ML
there
is
the
p
ossibilit
y
of
new
userdened
t
yp
es
and
t
yp
e
construc
tors
so
w
e
will
get
used
to
arbitrary
sets
of
constructors
of
an
y
arit
y

W
e
will
write
	







n
con
for
the
application
of
an
nary
t
yp
e
constructor
con
to
the
argumen
ts

i

	Only
in
a
few
sp
ecial
cases
lik
e
 and

do
w
e
use
inx
syn
tax


TYPED
LAMBD
A
CALCULUS

for
the
sak
e
of
familiarit
y

F
or
example
	 l
ist
is
the
t
yp
e
of
lists
whose
elemen
ts
all
ha
v
e
t
yp
e
 
An
imp
ortan
t
prop
ert
y
of
the
t
yp
es
pro
v
able
b
ecause
of
fr
e
e
inductiv
e
gen
eration
is
that
  

 
	In
fact
more
generally

a
t
yp
e
cannot
b
e
the
same
as
an
y
prop
er
syn
tactic
sub
expression
of
itself
This
rules
out
the
p
ossibilit
y
of
applying
a
term
to
itself
unless
the
t
w
o
instances
in
question
ha
v
e
distinct
t
yp
es

Ch
urc
h
and
Curry
t
yping
There
are
t
w
o
ma
jor
approac
hes
to
dening
t
yp
ed
lam
b
da
calculus
One
ap
proac
h
due
to
Ch
urc
h
is
explicit
A
	single
t
yp
e
is
attac
hed
to
eac
h
term
That
is
in
the
construction
of
terms
the
un
t
yp
ed
terms
that
w
e
ha
v
e
presen
ted
are
mo
died
with
an
additional
eld
for
the
t
yp
e
In
the
case
of
constan
ts
this
t
yp
e
is
preassigned
but
v
ariables
ma
y
b
e
of
an
y
t
yp
e
The
rules
for
v
alid
term
formation
are
then
v

 Constan
t
c
has
t
yp
e
 c

 s

  
t

 s
t


v

 t


v

t

  
F
or
our
purp
oses
ho
w
ev
er
w
e
prefer
Currys
approac
h
to
t
yping
whic
h
is
purely
implicit
The
terms
are
exactly
as
in
the
un
t
yp
ed
case
and
a
term
ma
y
or
ma
y
not
ha
v
e
a
t
yp
e
and
if
it
do
es
ma
y
ha
v
e
man
y
dieren
t
t
yp
es

F
or
example
the
iden
tit
y
function
x
x
ma
y
b
e
giv
en
an
y
t
yp
e
of
the
form
   
reasonably
enough
There
are
t
w
o
related
reasons
wh
y
w
e
prefer
this
approac
h
First
it
pro
vides
a
smo
other
treatmen
t
of
MLs
p
olymorphism
and
secondly

it
corresp
onds
w
ell
to
the
actual
use
of
ML
where
it
is
nev
er
necessary
to
sp
ecify
t
yp
es
explicitly

A
t
the
same
time
some
of
the
formal
details
of
Curryst
yle
t
yp
e
assignmen
t
are
a
bit
more
complex
W
e
do
not
merely
dene
a
relation
of
t
ypabilit
y
in
isolation
but
with
resp
ect
to
a
c
ontext
ie
a
nite
set
of
t
yping
assumptions
ab
out
v
ariables
W
e
write
'

t

 
Some
purists
w
ould
argue
that
this
isnt
prop
erly
sp
eaking
t
yp
ed
lam
b
da
calculus
but
rather
un
t
yp
ed
lam
b
da
calculus
with
a
separate
notion
of
t
yp
e
assignmen
t


CHAPTER

TYPES
to
mean
in
con
text
'
the
term
t
can
b
e
giv
en
t
yp
e
 
	W
e
will
ho
w
ev
er
write

t

 or
just
t

 when
the
t
yping
judgemen
t
holds
in
the
empt
y
con
text
The
elemen
ts
of
'
are
of
the
form
v

 
ie
they
are
themselv
es
t
yping
assumptions
ab
out
v
ariables
t
ypically
those
that
are
comp
onen
ts
of
the
term
W
e
assume
that
'
nev
er
giv
es
con
tradictory
assignmen
ts
to
the
same
v
ariable
if
preferred
w
e
can
think
of
it
as
a
partial
function
from
the
indexing
set
of
the
v
ariables
in
to
the
set
of
t
yp
es
The
use
of
the
sym
b
ol

corresp
onds
to
its
general
use
for
judgemen
ts
in
logic
of
the
form
'


read
as

follo
ws
from
assumptions
'

F
ormal
t
ypabilit
y
rules
The
rules
for
t
yping
expressions
are
fairly
natural
Remem
b
er
the
in
terpretation
of
t

 as
t
c
ould
b
e
giv
en
t
yp
e
 
v

 
'
'

v

 Constan
t
c
has
t
yp
e
 c

 '

s

  
'

t

 '

s
t


'

fv

 g

t


'

v

t

  
Once
again
this
is
to
b
e
regarded
as
an
inductiv
e
denition
of
the
t
ypabilit
y
relation
so
a
term
only
has
a
t
yp
e
if
it
can
b
e
deriv
ed
b
y
the
ab
o
v
e
rules
F
or
example
let
us
see
ho
w
to
t
yp
e
the
iden
tit
y
function
By
the
rule
for
v
ariables
w
e
ha
v
e
fx

 g

x

 and
therefore
b
y
the
last
rule
w
e
get


x
x

   By
our
established
con
v
en
tion
for
empt
y
con
texts
w
e
write
simply
x
x

   
This
example
also
illustrates
the
need
for
the
con
text
in
Curry
t
yping
and
wh
y
it
can
b
e
a
v
oided
in
the
Ch
urc
h
v
ersion
Without
the
con
text
w
e
could
deduce
x


for
an
y


and
then
b
y
the
last
rule
get
x
x

  

clearly
at
v
ariance
with
the
in
tuitiv
e
in
terpretation
of
the
iden
tit
y
function
This
problem
do
esnt
arise
in
Ch
urc
h
t
yping
since
in
that
case
either
b
oth
v
ariables
ha
v
e
t
yp
e
 
in
whic
h
case
the
rules
imply
that
x
x

   
or
else
the
t
w
o
xs
are
actually
dier
ent
variables
since
their
t
yp
es
dier
and
the
t
yp
es
are
a
comp
onen
t
of
the
term
No
w
indeed
x

 
	x




  

but
this
is
reasonable
b
ecause
the


TYPED
LAMBD
A
CALCULUS

term
is
alphaequiv
alen
t
to
x

 
	y




  

In
the
Curry
v
ersion
of
t
yping
the
t
yp
es
are
not
attac
hed
to
the
terms
and
so
w
e
need
some
w
a
y
of
connecting
instances
of
the
same
v
ariable

T
yp
e
preserv
ation
Since
the
underlying
terms
of
our
t
yp
ed
lam
b
da
calculus
are
the
same
as
in
the
un
t
yp
ed
case
w
e
can
tak
e
o
v
er
the
calculus
of
con
v
ersions
unc
hanged
Ho
w
ev
er
for
this
to
mak
e
sense
w
e
need
to
c
hec
k
that
all
the
con
v
ersions
preserv
e
t
ypa
bilit
y

a
prop
ert
y
called
typ
e
pr
eservation
This
is
not
dicult
w
e
will
sk
etc
h
a
formal
pro
of
for
	
con
v
ersion
and
lea
v
e
the
other
similar
cases
to
the
reader
First
w
e
pro
v
e
a
couple
of
lemmas
that
are
fairly
ob
vious
but
whic
h
need
to
b
e
established
formally

First
adding
new
en
tries
to
the
con
text
cannot
inhibit
t
ypabilit
y
Lemma

If
'

t

 and
'

(
then
(

t

 
Pro
of
By
induction
on
the
structur
e
of
t
F
ormal
ly
we
ar
e
xing
t
and
pr
oving
the
ab
ove
for
al
l
'
and
(
sinc
e
in
the
inductive
step
for
abstr
actions
the
sets
c
onc
erne
d
change
If
t
is
a
variable
we
must
have
that
t

 
'
Ther
efor
e
t

 
(
and
the
r
esult
fol
lows
If
t
is
a
c
onstant
the
r
esult
is
imme
diate
sinc
e
the
sto
ck
of
c
onstants
and
their
p
ossible
typ
es
is
indep
endent
of
the
c
ontext
If
t
is
a
c
ombination
s
u
then
we
have
for
some
typ
e


that
'

s


  and
'

u



By
the
inductive
hyp
othesis
(

s


  and
(

u


and
the
r
esult
fol
lows
Final
ly
if
t
is
an
abstr
action
x
s
then
we
must
have
by
the
last
rule
that
 is
of
the
form

 
 and
that
'

fx


g

s


 
Sinc
e
'

(
we
also
have
'

fx


g

(

fx


g
and
so
by
the
inductive
hyp
othesis
(

fx


g

s


 
By
applying
the
rule
for
abstr
actions
the
r
esult
fol
lows
QED
Secondly

en
tries
in
the
con
text
for
v
ariables
not
free
in
the
relev
an
t
term
ma
y
b
e
discarded
Lemma

If
'

t

 
then
'
t

t

 wher
e
'
t
c
ontains
only
entries
for
variables
fr
e
e
in
t
or
mor
e
formal
ly
'
t

fx


j
x



'
and
x

F
V
	tg
Pro
of
A
gain
we
pr
ove
the
ab
ove
for
al
l
'
and
the
c
orr
esp
onding
'
t
by
structur
al
induction
over
t
If
t
is
a
variable
then
sinc
e
'

t

 we
must
have
an
entry
x

 in
the
c
ontext
But
by
the
rst
rule
we
know
fx

 g

x

 as
r
e
quir
e
d
In
the
c
ase
of
a
c
onstant
then
the
typing
is
indep
endent
of
the
c
ontext
so
the
r
esult
holds
trivial
ly
If
t
is
a
c
ombination
s
u
then
we
have
for
some

that
'

s


  and
'

u



By
the
inductive
hyp
othesis
we
have
'
s

s


  and
'
u

u



By
the
monotonicity
lemma
we
ther
efor
e
have
'
su

s


  and
'
su

u



sinc
e
F
V
	s
u

F
V
	s

F
V
	u
Henc
e
by
the
rule
for
c
ombinations
we
get
'
su

t

 
Final
ly
if
t
has
the
form
x
s
we
must
have


CHAPTER

TYPES
'

fx


g

s


 with
 of
the
form

 
 
By
the
inductive
hyp
othesis
we
have
	'

fx


g
s

s


 
and
so
	'

fx


g
s

fx


g

	x
s

 
Now
we
ne
e
d
simply
observe
that
	'

fx


g
s

fx


g

'
t
and
app
e
al
onc
e
mor
e
to
monotonicity
QED
No
w
w
e
come
to
the
main
result
Theorem

If
'

t

 and
t

 
t
 
then
also
'

t
 
 Pro
of
Sinc
e
by
hyp
othesis
t
is
an
	
r
e
dex
it
must
b
e
of
the
form
	x
t
x
with
x

F
V
	t
Now
its
typ
e
c
an
only
have
arisen
by
the
last
typing
rule
and
ther
efor
e
 must
b
e
of
the
form

 
 
and
we
must
have
fx


g

	t
x


 
Now
this
typing
c
an
only
have
arisen
by
the
rule
for
c
ombinations
Sinc
e
the
c
ontext
c
an
only
give
one
typing
to
e
ach
variable
we
must
ther
efor
e
have
fx


g

t


 
 
But
sinc
e
by
hyp
othesis
x

F
V
	t
the
lemma
yields

t


 
 as
r
e
quir
e
d
QED
Putting
together
all
these
results
for
other
con
v
ersions
w
e
see
that
if
'

t

 and
t

 t
 
then
w
e
ha
v
e
'

t
 
 
This
is
reassuring
since
if
the
ev
aluation
rules
that
are
applied
during
execution
could
c
hange
the
t
yp
es
of
expressions
it
w
ould
cast
doubt
on
the
whole
en
terprise
of
static
t
yping

P
olymorphism
The
Curry
t
yping
system
already
giv
es
us
a
form
of
p
olymorphism
in
that
a
giv
en
term
ma
y
ha
v
e
dieren
t
t
yp
es
Let
us
start
b
y
distinguish
b
et
w
een
the
similar
concepts
of
p
olymorphism
and
overlo
ading
Both
of
them
mean
that
an
expression
ma
y
ha
v
e
m
ultiple
t
yp
es
Ho
w
ev
er
in
the
case
of
p
olymorphism
all
the
t
yp
es
b
ear
a
systematic
relationship
to
eac
h
other
and
all
t
yp
es
follo
wing
the
pattern
are
allo
w
ed
F
or
example
the
iden
tit
y
function
ma
y
ha
v
e
t
yp
e
   
or

 

or
	  

 	  

but
all
the
instances
ha
v
e
the
same
structure
By
con
trast
in
o
v
erloading
a
giv
en
function
ma
y
ha
v
e
dieren
t
t
yp
es
that
b
ear
no
structural
relation
to
eac
h
other
or
only
certain
instances
ma
y
b
e
selected
F
or
example
a
function
"
ma
y
b
e
allo
w
ed
to
ha
v
e
t
yp
e
int
 int
 int
or
t
yp
e
f
l
oat
 f
l
oat
 f
l
oat
but
not
bool
 bool
 bool


Y
et
a
third
related
notion
is
subt
yping
whic
h
is
a
more
principled
v
ersion
of
o
v
erloading
regarding
certain
t
yp
es
as
em
b
edded
in
others
This
ho
w
ev
er
turns
out
to
b
e
a
lot
more
complex
than
it
seems


Strac
hey

who
coined
the
term
p
olymorphism
referred
to
what
w
e
call
p
olymorphism
and
o
v
erloading
as
p
ar
ametric
and
ad
ho
c
p
olymorphism
resp
ectiv
ely


F
or
example
if

is
a
subt
yp
e
of

 
should

 
b
e
a
subt
yp
e
or
a
sup
ert
yp
e
of

  

One
can
defend
either
in
terpretation
co
v
arian
t
or
con
tra
v
arian
t
in
certain
situations


POL
YMORPHISM


Let
p
olymorphism
Unfortunately
the
t
yp
e
system
w
e
ha
v
e
so
far
places
some
unpleasan
t
restrictions
on
p
olymorphism
F
or
example
the
follo
wing
expression
is
p
erfectly
acceptable
if
	x
x
true
then
	x
x

else

Here
is
a
pro
of
according
to
the
ab
o
v
e
rules
W
e
assume
that
the
constan
ts
can
b
e
t
yp
ed
in
the
empt
y
en
vironmen
t
and
w
e
fold
together
t
w
o
successiv
e
applications
of
the
rule
for
com
binations
as
a
rule
for
if
remem
b
ering
that
if
b
then
t

else
t


is
shorthand
for
COND
b
t

t


fx

bool
g

x

bool

	x
x

bool
 bool

true

bool

	x
x
true

bool
fx

intg

x

int

	x
x

int
 int



int

	x
x


int



int

if
	x
x
true
then
	x
x

else


int
The
t
w
o
instances
of
the
iden
tit
y
function
get
t
yp
es
bool
 bool
and
int
 int
But
consider
the
follo
wing
let
I

x
x
in
if
I
true
then
I

else

According
to
our
denitions
this
is
just
syn
tactic
sugar
for
	I

if
I
true
then
I

else

	x
x
As
the
reader
ma
y
readily
conrm
this
cannot
b
e
t
yp
ed
according
to
our
rules
There
is
just
one
instance
of
the
iden
tit
y
function
and
it
m
ust
b
e
giv
en
a
single
t
yp
e
This
feature
is
un
b
earable
since
in
practical
functional
programming
w
e
rely
hea
vily
on
using
let
Unless
w
e
c
hange
the
t
yping
rules
man
y
of
the
b
enets
of
p
olymorphism
are
lost
Our
solution
is
to
mak
e
let
primitiv
e
rather
than
in
terpret
it
as
syn
tactic
sugar
and
add
the
new
t
yping
rule
'

s

 '

tsx 


'

let
x

s
in
t


This
rule
whic
h
sets
up
let
p
olymorphism
expresses
the
fact
that
with
resp
ect
to
t
yping
at
least
w
e
treat
let
bindings
just
as
if
separate
instances
of
the
named
expression
w
ere
written
out
The
additional
h
yp
othesis
'

s

 merely
ensures
that
s
is
t
ypable
the
exact
t
yp
e
b
eing
irrelev
an
t
This
is
to
a
v
oid
admitting
as
w
ellt
yp
ed
terms
suc
h
as
let
x

f

f
f
in

No
w
for
example
w
e
can
t
yp
e
the
troublesome
example


CHAPTER

TYPES
fx

 g

x

 
x
x

   As
giv
en
ab
o
v
e

if
	x
x
true
then
	x
x

else


int

let
I

x
x
in
if
I
true
then
I

else


int

Most
general
t
yp
es
As
w
e
ha
v
e
said
some
expressions
ha
v
e
no
t
yp
e
eg
f

f
f
or
f

	f
true
f

T
ypable
expressions
normally
ha
v
e
man
y
t
yp
es
though
some
eg
tr
ue
ha
v
e
exactly
one
W
e
ha
v
e
already
commen
ted
that
the
form
of
p
olymorphism
in
ML
is
p
ar
ametric
ie
all
the
dieren
t
t
yp
es
an
expression
can
ha
v
e
b
ear
a
structural
similarit
y
to
eac
h
other
In
fact
more
is
true
there
exists
for
eac
h
t
ypable
expression
a
most
gener
al
typ
e
or
princip
al
typ
e
and
all
p
ossible
t
yp
es
for
the
expression
are
instances
of
this
most
general
t
yp
e
Before
stating
this
precisely
w
e
need
to
establish
some
terminology

First
w
e
extend
our
notion
of
t
yp
es
with
typ
e
variables
That
is
t
yp
es
can
b
e
built
up
b
y
applying
t
yp
e
constructors
either
to
t
yp
e
constan
ts
or
v
ariables
Normally
w
e
use
the
letters

and

to
represen
t
t
yp
e
v
ariables
and
 and

arbitrary
t
yp
es
Giv
en
this
extension
w
e
can
dene
what
it
means
to
substitute
one
t
yp
e
for
a
t
yp
e
v
ariable
in
another
t
yp
e
This
is
precisely
analogous
to
substitution
at
the
term
lev
el
and
w
e
ev
en
use
the
same
notation
F
or
example
	  bool
	  
  

	  

 bool

The
formal
denition
is
m
uc
h
simpler
than
at
the
term
lev
el
b
ecause
w
e
do
not
ha
v
e
to
w
orry
ab
out
bindings
A
t
the
same
time
it
is
con
v
enien
t
to
extend
it
to
m
ultiple
parallel
substitutions

i










n

k
 


i
if

i


for


i

k











n

k
 


if

i


for


i

k
	 





 n
con
 

	 

 




 n

 con
F
or
simplicit
y
w
e
treat
t
yp
e
constan
ts
as
n
ullary
constructors
eg
consider
	int
rather
than
int
but
if
preferred
it
is
easy
to
include
them
as
a
sp
ecial
case
Giv
en
this
denition
of
substitution
w
e
can
dene
the
notion
of
a
t
yp
e
 b
eing
mor
e
gener
al
than
a
t
yp
e
  
written
 
  

This
is
dened
to
b
e
true
precisely
if
there
is
a
set
of
substitutions

suc
h
that
  
 

F
or
example
w
e
ha
v
e


 
 


 

 bool

	
 

 bool

This
relation
is
reexiv
e
so
w
e
should
really
sa
y
at
least
as
general
as
rather
than
more
general
than


STR
ONG
NORMALIZA
TION


 


 

 

	
 

 
No
w
w
e
come
to
the
main
theorem
Theorem

Every
typ
able
term
has
a
princip
al
typ
e
ie
if
t



then
ther
e
is
some
 such
that
t

 and
for
any
  
if
t

  then
 
  
It
is
easy
to
see
that
the
relation

is
a
preorder
relation
ie
is
reexiv
e
and
transitiv
e
The
principal
t
yp
e
is
not
unique
but
it
is
unique
up
to
renaming
of
t
yp
e
v
ariables
More
precisely

if
 and

are
b
oth
principal
t
yp
es
for
an
expression
then
 


meaning
that
 

and


 
W
e
will
not
ev
en
sk
etc
h
a
pro
of
of
the
principal
t
yp
e
theorem
it
is
not
partic
ularly
dicult
but
is
rather
long
What
is
imp
ortan
t
to
understand
is
that
the
pro
of
giv
es
a
concrete
pro
cedure
for
nding
a
principal
t
yp
e
This
pro
cedure
is
kno
wn
as
Milner
s
algorithm
or
often
the
HindleyMilner
algorithm

All
imple
men
tations
of
ML
and
sev
eral
other
functional
languages
incorp
orate
a
v
ersion
of
this
algorithm
so
expressions
can
automatically
b
e
allo
cated
a
principal
t
yp
e
or
rejected
as
illt
yp
ed

Strong
normalization
Recall
our
examples
of
terms
with
no
normal
form
suc
h
as
		x
x
x
x
	x
x
x
x

 		x
x
x
x
	x
x
x
x
	x
x
x
x

 	



In
t
yp
ed
lam
b
da
calculus
this
cannot
happ
en
b
y
virtue
of
the
follo
wing
str
ong
normalization
theorem
whose
pro
of
is
to
o
long
for
us
to
giv
e
here
Theorem

Every
typ
able
term
has
a
normal
form
and
every
p
ossible
r
e
duc
tion
se
quenc
e
starting
fr
om
a
typ
able
term
terminates

A
t
rst
sigh
t
this
lo
oks
go
o
d

a
functional
program
resp
ecting
our
t
yp
e
discipline
can
b
e
ev
aluated
in
an
y
order
and
it
will
alw
a
ys
terminate
in
the
unique
normal
form
	The
uniqueness
comes
from
the
Ch
urc
hRosser
theorem
whic
h
is

The
ab
o
v
e
principal
t
yp
e
theorem
in
the
form
w
e
ha
v
e
presen
ted
it
is
due
to
Milner
	

but
the
theorem
and
an
asso
ciated
algorithm
had
earlier
b
een
disco
v
ered
b
y
Hindley
in
a
similar
system
of
com
binatory
logic

W
eak
normalization
means
the
rst
part
only

ie
ev
ery
term
can
b
e
reduced
to
normal
form
but
there
ma
y
still
b
e
reduction
sequences
that
fail
to
terminate


CHAPTER

TYPES
still
true
in
the
t
yp
ed
system
Ho
w
ev
er
the
abilit
y
to
write
non
terminating
functions
is
essen
tial
to
T
uring
completeness

so
w
e
are
no
longer
able
to
dene
all
computable
functions
not
ev
en
all
total
ones
This
migh
t
not
matter
if
w
e
could
dene
all
practically
in
teresting
functions
Ho
w
ev
er
this
is
not
so
the
class
of
functions
denable
as
t
yp
ed
lam
b
da
terms
is
fairly
limited
Sc
h
wic
h
ten
b
erg
		
has
pro
v
ed
that
if
Ch
urc
h
n
umerals
are
used
then
the
denable
functions
are
those
that
are
p
olynomials
or
result
from
p
olynomials
using
denition
b
y
cases
Note
that
this
is
strictly
in
tensional
if
another
n
umeral
represen
tation
is
used
a
dieren
t
class
of
functions
is
obtained
In
an
y
case
it
is
not
enough
for
a
general
programming
language
Since
all
denable
functions
are
total
w
e
are
clearly
unable
to
mak
e
arbitrary
recursiv
e
denitions
Indeed
the
usual
xp
oin
t
com
binators
m
ust
b
e
un
t
ypable
Y

f

	x
f
	x
x	x
f
	x
x
clearly
isnt
w
ellt
yp
ed
b
ecause
it
applies
x
to
itself
and
x
is
b
ound
b
y
a
lam
b
da
In
order
to
regain
T
uringcompleteness
w
e
simply
add
a
w
a
y
of
dening
arbitrary
recursiv
e
functions
that
is
w
ellt
yp
ed
W
e
in
tro
duce
a
p
olymorphic
recursion
op
erator
with
all
t
yp
es
of
the
form
R
ec

		  

 	  

   
and
the
extra
reduction
rule
that
for
an
y
F

	  

 	  

w
e
ha
v
e
R
ec
F

 F
	R
ec
F

F
rom
no
w
on
w
e
will
supp
ose
that
recursiv
e
denitions
signalled
b
y
let
rec
map
do
wn
to
the
use
of
these
recursion
op
erators
F
urther
reading
Barendregt
		
and
Hindley
and
Seldin
		
also
consider
t
yp
ed
lam
b
da
calculus
The
original
pap
er
b
y
Milner
		
is
still
a
go
o
d
source
of
information
ab
out
p
olymorphic
t
yping
and
the
algorithm
for
nding
principal
t
yp
es
A
nice
elemen
tary
treatmen
t
of
t
yp
ed
lam
b
da
calculus
whic
h
giv
es
a
pro
of
of
Strong
Normalization
and
discusses
some
in
teresting
connections
with
logic
is
Girard
Lafon
t
and
T
a
ylor
			
This
also
discusses
a
more
adv
anced
v
ersion
of
t
yp
ed
lam
b
da
calculus
called
System
F
where
ev
en
though
strong
normalization
holds
the
ma
jorit
y
of
in
teresting
functions
are
denable
Exercises

Is
it
true
that
if
'

t

 then
for
an
y
substitution

w
e
ha
v
e
'

t

	 


Giv
en
an
y
recursiv
e
en
umeration
of
total
computable
functions
w
e
can
alw
a
ys
create
one
not
in
the
list
b
y
diagonalization
This
will
b
e
illustrated
in
the
Computabilit
y
Theory
course


STR
ONG
NORMALIZA
TION
	

Pro
v
e
formally
the
t
yp
e
preserv
ation
theorems
for

and

con
v
ersion

Sho
w
that
the
con
v
erse
to
t
yp
e
preserv
ation
do
es
not
hold
ie
it
is
p
ossible
that
t

 t
 and
'

t
 
 but
not
'

t

 

	
Pro
v
e
that
ev
ery
term
of
t
yp
ed
lam
b
da
calculus
with
princip
al
t
yp
e
	
 

 	
 

reduces
to
a
Ch
urc
h
n
umeral

	
T
o
what
exten
t
can
the
t
yp
ec
hec
king
pro
cess
b
e
rev
ersed
ie
the
term
inferred
from
the
t
yp
e
F
or
instance
is
it
true
that
in
pure
t
yp
ed
lam
b
da
calculus
with
t
yp
e
v
ariables
but
no
constan
ts
and
no
recursion
op
erator
that
an
y
t


 
 
is
in
fact
equal
to
K

x
y

x
in
the
usual
sense
of
lam
b
da
equalit
y
If
so
ho
w
far
can
this
b
e
generalized
	

	
W
e
will
sa
y
that
an
arbitrary
reduction
relation

 is
we
akly
Chur
ch
R
osser
if
whenev
er
t

 t

and
t

 t


then
there
is
a
u
with
t


 
u
and
t


 
u
where

 
is
the
reexiv
e
transitiv
e
closure
of

 
Pro
v
e
Newman

s
L
emma
whic
h
states
that
if
a
relation
is
w
eakly
Ch
urc
hRosser
and
ob
eys
strong
normalization
then

 
is
Ch
urc
hRosser
	Hin
t
use
a
form
of
w
ellfounded
induction
 	
See
Mairson
		
for
more
on
this
question

If
y
ou
get
stuc
k
there
is
a
nice
pro
of
in
Huet
	


Chapter

A
taste
of
ML
In
the
last
few
c
hapters
w
e
ha
v
e
started
with
pure
lam
b
da
calculus
and
system
atically
extended
it
with
new
primitiv
e
features
F
or
example
w
e
added
the
let
construct
as
primitiv
e
for
the
sak
e
of
making
the
p
olymorphic
t
yping
more
useful
and
a
recursion
op
eration
in
order
to
restore
the
computational
p
o
w
er
that
w
as
lost
when
adding
t
yp
es
By
tra
v
elling
further
along
this
path
w
e
will
ev
en
tually
arriv
e
at
ML
although
its
still
v
aluable
to
retain
the
simple
w
orldview
of
t
yp
ed
lam
b
da
calculus
The
next
stage
is
to
abandon
the
enco
dings
of
datat
yp
es
lik
e
b
o
oleans
and
natural
n
um
b
ers
via
lam
b
da
terms
and
instead
mak
e
them
primitiv
e
That
is
w
e
ha
v
e
new
primitiv
e
t
yp
es
lik
e
bool
and
int
	actually
p
ositiv
e
and
negativ
e
in
te
gers
and
new
t
yp
e
constructors
lik
e

a
step
w
e
ha
v
e
in
man
y
w
a
ys
an
ticipated
in
the
last
c
hapter
Asso
ciated
with
these
are
new
constan
ts
and
new
con
v
ersion
rules
F
or
example
the
expression

"

is
ev
aluated
using
mac
hine
arithmetic
rather
than
b
y
translation
in
to
Ch
urc
h
n
umerals
and
p
erforming

con
v
ersions
These
additional
con
v
ersions
regarded
as
augmen
ting
the
usual
lam
b
da
op
era
tions
are
often
referred
to
as

con
v
ersions
W
e
will
see
in
due
course
ho
w
the
ML
language
is
extended
in
other
w
a
ys
in
comparison
with
pure
lam
b
da
calculus
First
w
e
m
ust
address
the
fundamen
tal
question
of
MLs
ev
aluation
strategy


Eager
ev
aluation
W
e
ha
v
e
said
that
from
a
theoretical
p
oin
t
of
view
normal
order
	top
do
wn
lefttorigh
t
reduction
of
expressions
is
to
b
e
preferred
since
if
an
y
strategy
terminates
this
one
will

Ho
w
ev
er
it
has
some
practical
defects
F
or
example
consider
the
follo
wing
	x
x
"
x
"
x
	
"


This
strategy
is
familiar
from
a
few
traditional
languages
lik
e
Algol

where
it
is
referred
to
as
c
al
l
by
name



EA
GER
EV
ALUA
TION

A
normal
order
reduction
results
in
	
"

"
	
"

"
	
"

and
the
follo
wing
reduction
steps
need
to
ev
aluate
three
separate
instances
of
the
same
expression
This
is
unacceptable
in
practice
There
are
t
w
o
main
solutions
to
this
problem
and
these
solutions
divide
the
w
orld
of
functional
programming
languages
in
to
t
w
o
camps
The
rst
alternativ
e
is
to
stic
k
with
normal
order
reduction
but
attempt
to
optimize
the
implemen
tation
so
m
ultiple
sub
expressions
arising
in
this
w
a
y
are
shared
and
nev
er
ev
aluated
more
than
once
In
ternally

expressions
are
represen
ted
as
directed
acyclic
graphs
rather
than
as
trees
This
is
kno
wn
as
lazy
or
c
al
lbyne
e
d
ev
aluation
since
expressions
are
only
ev
aluated
when
absolutely
necessary

The
second
approac
h
is
to
turn
the
theoretical
considerations
ab
out
reduction
strategy
on
their
head
and
ev
aluate
argumen
ts
to
functions
b
efore
passing
the
v
alues
to
the
function
This
is
kno
wn
as
applic
ative
or
der
or
e
ager
ev
aluation
The
latter
name
arises
b
ecause
function
argumen
ts
are
ev
aluated
ev
en
when
they
ma
y
b
e
unnecessary

eg
t
in
	x
y

t
Of
course
eager
ev
aluation
means
that
some
expressions
ma
y
lo
op
that
w
ould
terminate
in
a
lazy
regime
But
this
is
considered
acceptable
since
these
instances
are
generally
easy
to
a
v
oid
in
practice
In
an
y
case
an
eager
ev
aluation
strategy
is
the
standard
in
man
y
programming
languages
lik
e
C
where
it
is
referred
to
as
c
al
l
by
value
ML
adopts
eager
ev
aluation
for
t
w
o
main
reasons
Choreographing
the
re
ductions
and
sharings
that
o
ccur
in
lazy
ev
aluation
is
quite
tric
ky

and
implemen
tations
tend
to
b
e
relativ
ely
inecien
t
and
complicated
Unless
the
programmer
is
v
ery
careful
memory
can
ll
up
with
p
ending
unev
aluated
expressions
and
in
general
it
is
hard
to
understand
the
space
b
eha
viour
of
programs
In
fact
man
y
implemen
tations
of
lazy
ev
aluation
try
to
optimize
it
to
eager
ev
aluation
in
cases
where
there
is
no
seman
tic
dierence

By
con
trast
in
ML
w
e
alw
a
ys
rst
ev
aluate
the
argumen
ts
to
functions
and
only
then
p
erform
the

reduction

this
is
simple
and
ecien
t
and
is
easy
to
implemen
t
using
standard
compiler
tec
hnology

The
second
reason
for
preferring
applicativ
e
order
ev
aluation
is
that
ML
is
not
a
pur
e
functional
language
but
includes
imp
erativ
e
features
	v
ariables
as
signmen
ts
etc
Therefore
the
order
of
ev
aluation
of
sub
expressions
can
mak
e
a
semantic
dierence
rather
than
merely
aecting
eciency

If
lazy
ev
aluation
is
used
it
seems
to
b
ecome
practically
imp
ossible
for
the
programmer
to
visualize
in
a
non
trivial
program
exactly
when
eac
h
sub
expression
gets
ev
aluated
In
the
eager
ML
system
one
just
needs
to
remem
b
er
the
simple
ev
aluation
rule
It
is
imp
ortan
t
to
realize
ho
w
ev
er
that
the
ML
ev
aluation
strategy
is
not
simply
b
ottomup
the
exact
opp
osite
of
normal
order
reduction
In
fact
ML
never
evaluates
underne
ath
a
lamb
da
	In
particular
it
nev
er
reduces
	
redexes

They
try
to
p
erform
strictness
analysis
a
form
of
static
analysis
that
can
often
disco
v
er
that
argumen
ts
are
necessarily
going
to
b
e
ev
aluated
Mycroft
	



CHAPTER

A
T
ASTE
OF
ML
only

redexes
In
ev
aluating
	x
sx 
t
t
is
ev
aluated
rst
Ho
w
ev
er
sx 
is
not
touc
hed
since
it
is
underneath
a
lam
b
da
and
an
y
sub
expressions
of
t
that
happ
en
to
b
e
in
the
scop
e
of
a
lam
b
da
are
also
left
alone
The
precise
ev
aluation
rules
are
as
follo
ws

Constan
ts
ev
aluate
to
themselv
es

Ev
aluation
stops
immediately
at
abstractions
and
do
es
not
lo
ok
inside
them
In
particular
there
is
no
	
con
v
ersion

When
ev
aluating
a
com
bination
s
t
then
rst
b
oth
s
and
t
are
ev
aluated
Then
assuming
that
the
ev
aluated
form
of
s
is
a
lam
b
da
abstraction
a
toplev
el

con
v
ersion
is
p
erformed
and
the
pro
cess
is
rep
eated
The
order
of
ev
aluation
of
s
and
t
v
aries
b
et
w
een
v
ersions
of
ML
In
the
v
ersion
w
e
will
use
t
is
alw
a
ys
ev
aluated
rst
Strictly

w
e
should
also
sp
ecify
a
rule
for
let
expressions
since
as
w
e
ha
v
e
said
they
are
b
y
no
w
accepted
as
a
primitiv
e
Ho
w
ev
er
from
the
p
oin
t
of
view
of
ev
aluation
they
can
b
e
understo
o
d
in
the
original
w
a
y

as
a
lam
b
da
applied
to
an
argumen
t
with
the
understanding
that
the
rand
will
b
e
ev
aluated
rst
T
o
mak
e
this
explicit
the
rule
for
let
x

s
in
t
is
that
rst
of
all
s
is
ev
aluated
the
resulting
v
alue
is
substituted
for
x
in
t
and
nally
the
new
v
ersion
of
t
is
ev
aluated
Let
us
see
some
examples
of
ev
aluating
expressions
	x
	y

y
"
y

x	
"


 	x
	y

y
"
y

x

 	y

y
"
y


 
"


 
Note
that
the
subterm
	y

y
"
y

x
is
not
r
e
duc
e
d
since
it
is
within
the
scop
e
of
a
lam
b
da
Ho
w
ev
er
terms
that
are
reducible
and
not
enclosed
b
y
a
lam
b
da
in
b
oth
function
and
argumen
t
get
reduced
b
efore
the
function
application
itself
is
ev
aluated
eg
the
second
step
in
the
follo
wing
		f
x
f
x
	y

y
"
y

	
"


 		f
x
f
x
	y

y
"
y



 	x
	y

y
"
y

x


 	y

y
"
y



 
"



CONSEQUENCES
OF
EA
GER
EV
ALUA
TION

The
fact
that
ML
do
es
not
ev
aluate
under
lam
b
das
is
of
crucial
imp
ortance
to
adv
anced
ML
programmers
It
giv
es
precise
con
trol
o
v
er
the
ev
aluation
of
expressions
and
can
b
e
used
to
mimic
man
y
of
the
helpful
cases
of
lazy
ev
aluation
W
e
shall
see
a
v
ery
simple
instance
in
the
next
section

Consequences
of
eager
ev
aluation
The
use
of
eager
ev
aluation
forces
us
to
mak
e
additional
features
primitiv
e
with
their
o
wn
sp
ecial
reduction
pro
cedures
rather
than
implemen
ting
them
directly
in
terms
of
lam
b
da
calculus
In
particular
w
e
can
no
longer
regard
the
conditional
construct
if
b
then
e

else
e

as
the
application
of
an
ordinary
ternary
op
erator
COND
b
e

e

The
reason
is
that
in
an
y
particular
instance
b
ecause
of
eager
ev
aluation
w
e
ev
aluate
all
the
expressions
b
e

and
e

rst
b
efore
ev
aluating
the
b
o
dy
of
the
COND
Usually

this
is
disastrous
F
or
example
recall
our
denition
of
the
factorial
function
let
rec
fact	n

if
ISZER
O
n
then

else
n

fact	PRE
n
If
the
conditional
ev
aluates
all
its
argumen
ts
then
in
order
to
ev
aluate
fact	
the
else
arm
m
ust
b
e
ev
aluated
in
its
turn
causing
fact	PRE

to
b
e
ev
alu
ated
This
in
its
turn
causes
the
ev
aluation
of
fact	PRE
	PRE

and
so
on
Consequen
tly
the
computation
will
lo
op
indenitely

Accordingly

w
e
mak
e
the
conditional
a
new
primitiv
e
construct
and
mo
dify
the
usual
reduction
strategy
so
that
rst
the
b
o
olean
expression
is
ev
aluated
and
only
then
is
exactly
one
of
the
t
w
o
arms
ev
aluated
as
appropriate
What
ab
out
the
pro
cess
of
recursion
itself

W
e
ha
v
e
suggested
understanding
recursiv
e
denitions
in
terms
of
a
recursion
op
erator
R
ec
with
its
o
wn
reduction
rule
R
ec
f

 f
	R
ec
f

This
w
ould
also
lo
op
using
an
eager
ev
aluation
strategy
R
ec
f

 f
	R
ec
f


 f
	f
	R
ec
f


 f
	f
	f
	R
ec
f


 


Ho
w
ev
er
w
e
only
need
a
v
ery
simple
mo
dication
to
the
reduction
rule
to
mak
e
things
w
ork
correctly


CHAPTER

A
T
ASTE
OF
ML
R
ec
f

 f
	x
R
ec
f
x
No
w
the
lam
b
da
on
the
righ
t
means
that
x
R
ec
f
x
ev
aluates
to
itself
and
so
only
after
the
expression
has
b
een
further
reduced
follo
wing
substitution
in
the
b
o
dy
of
f
will
ev
aluation
con
tin
ue

The
ML
family
W
e
ha
v
e
b
een
talking
ab
out
ML
as
if
it
w
ere
a
single
language
In
fact
there
are
man
y
v
arian
ts
of
ML
ev
en
including
Lazy
ML
an
implemen
tation
from
Chalmers
Univ
ersit
y
in
Sw
eden
that
is
based
on
lazy
ev
aluation
The
most
p
opu
lar
v
ersion
of
ML
in
education
is
Standard
ML
but
w
e
will
use
another
v
ersion
called
CAML
	camel
Ligh
t

W
e
c
hose
CAML
Ligh
t
for
sev
eral
reasons

The
implemen
tation
is
small
and
highly
p
ortable
so
can
b
e
run
eectiv
ely
on
Unix
mac
hines
PCs
Macs
etc

The
system
is
simple
syn
tactically
and
seman
tically

making
it
relativ
ely
easy
to
approac
h

The
system
is
w
ell
suited
to
practical
programming
eg
it
can
easily
b
e
in
terfaced
to
C
and
supp
orts
standard
makecompatible
separate
compila
tion
Ho
w
ev
er
w
e
will
b
e
teac
hing
quite
general
tec
hniques
and
an
y
co
de
w
e
write
can
b
e
run
with
a
few
minor
syn
tactic
c
hanges
in
an
y
v
ersion
of
ML
and
indeed
often
in
other
functional
languages

Starting
up
ML
ML
has
already
b
een
installed
on
Thor
In
order
to
use
it
y
ou
need
to
put
the
CAML
binary
directory
on
y
our
PATH
This
can
b
e
done
	assuming
y
ou
use
the
bash
shell
or
one
of
its
family
as
follo
ws
PATHPATHhomejrhc
aml
bin
export
PATH
T
o
a
v
oid
doing
this
ev
ery
time
y
ou
log
on
y
ou
can
insert
these
lines
near
the
end
of
y
our
bash
profile
or
the
equiv
alen
t
for
y
our
fa
v
ourite
shell
No
w
to
use
CAML
in
its
normal
in
teractiv
e
and
in
terpretiv
e
mo
de
y
ou
simply
need
to
t
yp
e
camllight
and
the
system
should
re
up
and
presen
t
its
prompt
	

The
name
stands
for
Categorical
Abstract
Mac
hine
the
underlying
implemen
tation
metho
d


INTERA
CTING
WITH
ML


camllight
	
Caml
Light
version



In
order
to
exit
the
system
simply
t
yp
e
ctrld
or
quit

at
the
prompt
If
y
ou
are
in
terested
in
installing
CAML
Ligh
t
on
y
our
o
wn
mac
hine
y
ou
should
consult
the
follo
wing
W
eb
page
for
detailed
information
httppauillacinriafr
caml


In
teracting
with
ML
When
ML
presen
ts
y
ou
with
its
prompt
y
ou
can
t
yp
e
in
expressions
terminated
b
y
t
w
o
successiv
e
semicolons
and
it
will
ev
aluate
them
and
prin
t
the
result
In
computing
jargon
the
ML
system
sits
in
a
readev
alprin
t
lo
op
it
rep
eatedly
reads
an
expression
ev
aluates
it
and
prin
ts
the
result
F
or
example
ML
can
b
e
used
as
a
simple
calculator





int


The
system
not
only
returns
the
answ
er
but
also
the
typ
e
of
the
expression
whic
h
it
has
inferred
automatically

It
can
do
this
b
ecause
it
kno
ws
the
t
yp
e
of
the
builtin
addition
op
erator

On
the
other
hand
if
an
expression
is
not
t
ypable
the
system
will
reject
it
and
try
to
giv
e
some
idea
ab
out
ho
w
the
t
yp
es
fail
to
matc
h
up
In
complicated
cases
the
error
messages
can
b
e
quite
tric
ky
to
understand


true
Toplevel
input
	let
it



true
	

This
expression
has
type
bool
but
is
used
with
type
int
Since
ML
is
a
functional
language
expressions
are
allo
w
ed
to
ha
v
e
function
t
yp
e
The
ML
syn
tax
for
a
lam
b
da
abstraction
x
tx 
is
fun
x

tx
F
or
example
w
e
can
dene
the
successor
function
fun
x
	
x




int
	
int

fun	


CHAPTER

A
T
ASTE
OF
ML
Again
the
t
yp
e
of
the
expression
this
time
int

int
is
inferred
and
dis
pla
y
ed
Ho
w
ev
er
the
function
itself
is
not
prin
ted
the
system
merely
writes
fun
This
is
b
ecause
in
general
the
in
ternal
represen
tations
of
functions
are
not
v
ery
readable

F
unctions
are
applied
to
argumen
ts
just
as
in
lam
b
da
calcu
lus
b
y
juxtap
osition
F
or
example
fun
x
	
x





int


Again
as
in
lam
b
da
calculus
function
application
asso
ciates
to
the
left
and
y
ou
can
write
curried
functions
using
the
same
con
v
en
tion
of
eliding
m
ultiple
s
	ie
funs
F
or
example
the
follo
wing
are
all
equiv
alen
t
fun
x
	
fun
y
	
x

y




int


fun
x
	
fun
y
	
x

y




int


fun
x
y
	
x

y




int



Bindings
and
declarations
It
is
not
con
v
enien
t
of
course
to
ev
aluate
the
whole
expression
in
one
go
rather
w
e
w
an
t
to
use
let
to
bind
useful
sub
expressions
to
names
This
can
b
e
done
as
follo
ws
let
successor

fun
x
	
x


in
successorsuccessorsucc
esso
r




int


F
unction
bindings
ma
y
use
the
more
elegan
t
sugaring
let
successor
x

x


in
successorsuccessorsucce
ssor




int


and
can
b
e
made
recursiv
e
just
b
y
adding
the
rec
k
eyw
ord
let
rec
fact
n

if
n


then

else
n

factn


in
fact



int


By
using
and
w
e
can
mak
e
sev
eral
binding
sim
ultaneously

and
dene
m
utu
ally
recursiv
e
functions
F
or
example
here
are
t
w
o
simple
though
highly
ine
cien
t
functions
to
decide
whether
or
not
a
natural
n
um
b
er
is
o
dd
or
ev
en

CAML
do
es
not
store
them
simply
as
syn
tax
trees
but
compiles
them
in
to
b
yteco
de


BINDINGS
AND
DECLARA
TIONS

let
rec
even
n

if
n


then
true
else
odd
n


and
odd
n

if
n


then
false
else
even
n


even

int
	
bool

fun	
odd

int
	
bool

fun	
even



bool

true
odd



bool

false
In
fact
an
y
bindings
can
b
e
p
erformed
separately
from
the
nal
application
ML
remem
b
ers
a
set
of
v
ariable
bindings
and
the
user
can
add
to
that
set
in
ter
activ
ely

Simply
omit
the
in
and
terminate
the
phrase
with
a
double
semicolon
let
successor

fun
x
	
x


successor

int
	
int

fun	
After
this
declaration
an
y
later
phrase
ma
y
use
the
function
successor
eg
successor



int


Note
that
w
e
are
not
making
assignments
to
variables
Eac
h
binding
is
only
done
once
when
the
system
analyses
the
input
it
cannot
b
e
rep
eated
or
mo
di
ed
It
can
b
e
o
v
erwritten
b
y
a
new
denition
using
the
same
name
but
this
is
not
assignmen
t
in
the
usual
sense
since
the
sequence
of
ev
en
ts
is
only
connected
with
the
c
ompilation
pro
cess
not
with
the
dynamics
of
program
exe
cution
In
deed
apart
from
the
more
in
teractiv
e
feedbac
k
from
the
system
w
e
could
equally
replace
all
the
double
semicolons
after
the
declarations
b
y
in
and
ev
aluate
ev
erything
at
once
On
this
view
w
e
can
see
that
the
o
v
erwriting
of
a
declaration
really
corresp
onds
to
the
denition
of
a
new
lo
cal
v
ariable
that
hides
the
outer
one
according
to
the
usual
lam
b
da
calculus
rules
F
or
example
let
x


x

int


let
y


y

int


let
x


x

int


x

y


int


is
the
same
as
let
x


in
let
y


in
let
x


in
x

y


int




CHAPTER

A
T
ASTE
OF
ML
Note
carefully
that
also
follo
wing
lam
b
da
calculus
v
ariable
binding
is
static
ie
the
rst
binding
of
x
is
still
used
un
til
an
inner
binding
o
ccurs
and
an
y
uses
of
it
un
til
that
p
oin
t
are
not
aected
b
y
the
inner
binding
F
or
example
let
x


x

int


let
f
w

w

x
f

int
	
int

fun	
let
x


x

int


f




int


The
rst
v
ersion
of
LISP

ho
w
ev
er
used
dynamic
binding
where
a
rebinding
of
a
v
ariable
propagated
to
earlier
uses
of
the
v
ariable
so
that
the
analogous
se
quence
to
the
ab
o
v
e
w
ould
return

This
w
as
in
fact
originally
regarded
as
a
bug
but
so
on
programmers
started
to
appreciate
its
con
v
enience
It
mean
t
that
when
some
lo
wlev
el
function
w
as
mo
died
the
c
hange
propagated
automatically
to
all
applications
of
it
in
higher
lev
el
functions
without
the
need
for
recompilation
The
feature
surviv
ed
for
a
long
time
in
man
y
LISP
dialects
but
ev
en
tually
the
view
that
static
binding
is
b
etter
prev
ailed
In
Common
LISP

static
binding
is
the
default
but
dynamic
binding
is
a
v
ailable
if
desired
via
the
k
eyw
ord
special

P
olymorphic
functions
W
e
can
dene
p
olymorphic
functions
lik
e
the
iden
tit
y
op
erator
let
I

fun
x
	
x
I

a
	
a

fun	
ML
prin
ts
t
yp
e
v
ariables
as
a
b
etc
These
are
supp
osed
to
b
e
ASCI
I
represen
tations
of



and
so
on
W
e
can
no
w
use
the
p
olymorphic
function
sev
eral
times
with
dieren
t
t
yp
es
I
true


bool

true
I



int


I
I
I
I



int


Eac
h
instance
of
I
in
the
last
expression
has
a
dieren
t
t
yp
e
and
in
tuitiv
ely
corresp
onds
to
a
dieren
t
function
In
fact
lets
dene
all
the
com
binators


POL
YMORPHIC
FUNCTIONS
	
let
I
x

x
I

a
	
a

fun	
let
K
x
y

x
K

a
	
b
	
a

fun	
let
S
f
g
x

f
x
g
x
S

a
	
b
	
c
	
a
	
b
	
a
	
c

fun	
Note
that
the
system
k
eeps
trac
k
of
the
t
yp
es
for
us
ev
en
though
in
the
last
case
they
w
ere
quite
complicated
No
w
recall
that
I

S
K
K

let
us
try
this
out
in
ML

let
I

S
K
K
I

a
	
a

fun	
It
has
the
righ
t
t
yp
e

and
it
ma
y
easily
b
e
c
hec
k
ed
in
all
concrete
cases
eg
I





bool

true
In
the
ab
o
v
e
examples
of
p
olymorphic
functions
the
system
v
ery
quic
kly
infers
a
most
general
t
yp
e
for
eac
h
expression
and
the
t
yp
e
it
infers
is
simple
This
usually
happ
ens
in
practice
but
there
are
pathological
cases
eg
the
follo
wing
example
due
to
Mairson
			
The
t
yp
e
of
this
expression
tak
es
ab
out

seconds
to
calculate
and
o
ccupies
o
v
er

lines
on
an
column
terminal
let
pair
x
y

fun
z
	
z
x
y
in
let
x

fun
y
	
pair
y
y
in
let
x

fun
y
	
xx
y
in
let
x

fun
y
	
xx
y
in
let
x

fun
y
	
xx
y
in
let
x

fun
y
	
xx
y
in
xfun
z
	
z
W
e
ha
v
e
said
that
the
ML
programmer
need
nev
er
en
ter
a
t
yp
e
This
is
true
in
the
sense
that
ML
will
already
allo
cate
as
general
a
t
yp
e
as
p
ossible
to
an
expression
Ho
w
ev
er
it
ma
y
sometimes
b
e
con
v
enien
t
to
r
estrict
the
generalit
y
of
a
t
yp
e
This
cannot
mak
e
co
de
w
ork
that
didnt
w
ork
b
efore
but
it
ma
y
serv
e
as
do
cumen
tation
regarding
the
in
tended
purp
ose
of
the
co
de
it
is
also
p
ossible
to
use
shorter
synon
yms
for
complicated
t
yp
es
T
yp
e
restriction
can
b
e
ac
hiev
ed
in
ML
b
y
adding
typ
e
annotations
after
some
expression	s
These
t
yp
e
annotations
consist
of
a
colon
follo
w
ed
b
y
a
t
yp
e
It
usually
do
esnt
matter
exactly
where
these
annotations
are
added
pro
vided
they
enforce
the
appropriate
constrain
ts
F
or
example
here
are
some
alternativ
e
w
a
ys
of
constraining
the
iden
tit
y
function
to
t
yp
e
int

int

W
e
remark
ed
that
from
the
un
t
yp
ed
p
oin
t
of
view
S
K
A

I
for
an
y
A
Ho
w
ev
er
the
reader
ma
y
try

for
example
S
K
S
and
see
that
the
principal
t
yp
e
is
less
general
than
exp
ected

Ignore
the
underscores
for
no
w
This
is
connected
with
the
t
yping
of
imp
erativ
e
features
and
w
e
will
discuss
it
later


CHAPTER

A
T
ASTE
OF
ML
let
I
xint

x
I

int
	
int

fun	
let
I
x

xint
I

int
	
int

fun	
let
Iint	int

fun
x
	
x
I

int
	
int

fun	
let
I

fun
xint
	
x
I

int
	
int

fun	
let
I

fun
x
	
xint	int
I

int
	
int

fun	

Equalit
y
of
functions
Instead
of
comparing
the
actions
of
I
and
I
 on
particular
argumen
ts
lik
e

it
w
ould
seem
that
w
e
can
settle
the
matter
denitiv
ely
b
y
comparing
the
functions
themselv
es
Ho
w
ev
er
this
do
esnt
w
ork
I

I
Uncaught
exception
Invalidargument
equal
functional
value
It
is
in
general
forbidden
to
compare
functions
for
equalit
y

though
a
few
sp
ecial
instances
where
the
functions
are
ob
viously
the
same
yield
true
let
f
x

x


f

int
	
int

fun	
let
g
x

x


g

int
	
int

fun	
f

f


bool

true
f

g
Uncaught
exception
Invalidargument
equal
functional
value
let
h

g
h

int
	
int

fun	
h

f
Uncaught
exception
Invalidargument
equal
functional
value
h

g


bool

true
Wh
y
these
restrictions
Arent
functions
supp
osed
to
b
e
rstclass
ob
jects
in
ML
Y
es
but
unfortunately

	extensional
function
equalit
y
is
not
computable
This
follo
ws
from
a
n
um
b
er
of
classic
theorems
in
recursion
theory

suc
h
as
the
unsolvability
of
the
halting
pr
oblem
and
R
ic
e
s
the
or
em

Let
us
giv
e
a
concrete
illustration
of
wh
y
this
migh
t
b
e
so
It
is
still
an
op
en
problem
whether
the

Y
ou
will
see
these
results
pro
v
ed
in
the
Computation
Theory
course
Rices
theorem
is
an
extremely
strong
undecidabilit
y
result
whic
h
asserts
that
any
non
trivial
prop
ert
y
of
the
function
corresp
onding
to
a
program
is
uncomputable
from
its
text
An
excellen
t
computation
theory
textb
o
ok
is
Da
vis
Sigal
and
W
eyuk
er
		



EQUALITY
OF
FUNCTIONS

follo
wing
function
terminates
for
all
argumen
ts
the
assertion
that
it
do
es
b
eing
kno
wn
as
the
Col
latz
c
onje
ctur
e

let
rec
collatz
n

if
n


then

else
if
evenn
then
collatzn


else
collatz

n


collatz

int
	
int

fun	
What
is
clear
though
is
that
if
it
do
es
halt
it
returns

No
w
consider
the
follo
wing
trivial
function
let
f
xint



f

int
	
int

fun	
By
deciding
the
equation
collatz

f
the
computer
w
ould
settle
the
Collatz
conjecture
It
is
easy
to
conco
ct
other
examples
for
op
en
mathematical
problems
It
is
p
ossible
to
trap
out
applications
of
the
equalit
y
op
erator
to
functions
and
datat
yp
es
built
up
from
them
as
part
of
t
yp
ec
hec
king
rather
than
at
run
time
T
yp
es
that
do
not
in
v
olv
e
functions
in
these
w
a
ys
are
kno
wn
as
e
quality
typ
es
since
it
is
alw
a
ys
v
alid
to
test
ob
jects
of
suc
h
t
yp
es
for
equalit
y

On
the
negativ
e
side
this
mak
es
the
t
yp
e
system
m
uc
h
more
complicated
Ho
w
ev
er
one
migh
t
argue
that
static
t
yp
ec
hec
king
should
b
e
extended
as
far
as
feasibilit
y
allo
ws
F
urther
reading
Man
y
b
o
oks
on
functional
programming
b
ear
on
the
general
issues
w
e
ha
v
e
dis
cussed
here
suc
h
as
ev
aluation
strategy

A
go
o
d
elemen
tary
in
tro
duction
to
CAML
Ligh
t
and
functional
programming
is
Maun
y
			
P
aulson
			
is
another
go
o
d
textb
o
ok
though
based
on
Standard
ML
Exercises

Supp
ose
that
a
conditional
function
dened
b
y
itebxy

if
b
then
x
else
y
is
the
only
function
a
v
ailable
that
op
erates
on
argumen
ts
of
t
yp
e
bool
Is
there
an
y
w
a
y
to
write
a
factorial
function

Use
the
t
yping
rules
in
the
last
c
hapter
to
write
out
a
formal
pro
of
that
the
S
com
binator
has
the
t
yp
e
indicated
b
y
the
ML
system

A
go
o
d
surv
ey
of
this
problem
and
attempts
to
solv
e
it
is
giv
en
b
y
Lagarias
	

Strictly

w
e
should
use
unlimited
precision
in
tegers
rather
than
mac
hine
arithmetic
W
e
will
see
later
ho
w
to
do
this


CHAPTER

A
T
ASTE
OF
ML

W
rite
a
simple
recursiv
ely
dened
function
to
p
erform
exp
onen
tiation
of
in
tegers
ie
calculate
x
n
for
n


W
rite
do
wn
t
w
o
ML
functions
the
equalit
y
of
whic
h
corresp
onds
to
the
truth
of
F
ermats
last
theorem
there
are
no
in
tegers
x
y

z
and
natural
n
um
b
er
n


with
x
n
"
y
n

z
n
except
for
the
trivial
case
where
x


or
y



Chapter

F
urther
ML
In
this
c
hapter
w
e
consolidate
the
previous
examples
b
y
sp
ecifying
the
basic
facilities
of
ML
and
the
syn
tax
of
phrases
more
precisely

and
then
go
on
to
treat
some
additional
features
suc
h
as
recursiv
e
t
yp
es
W
e
migh
t
start
b
y
sa
ying
more
ab
out
in
teraction
with
the
system
So
far
w
e
ha
v
e
just
b
een
t
yping
phrases
in
to
MLs
toplev
el
readev
alprin
t
lo
op
and
observing
the
result
Ho
w
ev
er
this
is
not
a
go
o
d
metho
d
for
writing
non
trivial
programs
T
ypically

y
ou
should
write
the
expressions
and
declarations
in
a
le
T
o
try
things
out
as
y
ou
go
they
can
b
e
inserted
in
the
ML
windo
w
using
cut
and
paste
This
op
eration
can
b
e
p
erformed
using
Xwindo
ws
and
similar
systems
or
in
an
editor
lik
e
Emacs
with
m
ultiple
buers
Ho
w
ev
er
this
b
ecomes
lab
orious
and
timeconsuming
for
large
programs
Instead
y
ou
can
use
MLs
include
function
to
read
in
the
le
directly

F
or
example
if
the
le
myprogml
con
tains
let
pythag
x
y
z

x

x

y

y

z

z
pythag



pythag



pythag



then
the
toplev
el
phrase
include
myprogml

results
in
include
myprogml
pythag

int
	
int
	
int
	
bool

fun	


bool

true


bool

true


bool

false


unit





CHAPTER

FUR
THER
ML
That
is
the
ML
system
resp
onds
just
as
if
the
phrases
had
b
een
en
tered
at
the
top
lev
el
The
nal
line
is
the
result
of
ev
aluating
the
include
expression
itself
In
large
programs
it
is
often
helpful
to
include
commen
ts
In
ML
these
are
written
b
et
w
een
the
sym
b
ols

and

eg












This
function
tests
if
xyz
is
a
Pythagorean
triple












let
pythag
x
y
z

x

x

y

y

z

z
comments
pythag
can

go

almost

anywhere

and

can

be

nested

quite

arbitrarily



Basic
datat
yp
es
and
op
erations
ML
features
sev
eral
builtin
primitiv
e
t
yp
es
F
rom
these
comp
osite
t
yp
es
ma
y
b
e
built
using
v
arious
t
yp
e
constructors
F
or
the
momen
t
w
e
will
only
use
the
function
space
constructor

and
the
Cartesian
pro
duct
constructor

but
w
e
will
see
in
due
course
whic
h
others
are
pro
vided
and
ho
w
to
dene
new
t
yp
es
and
t
yp
e
constructors
The
primitiv
e
t
yp
es
that
concern
us
no
w
are

The
t
yp
e
unit
This
is
a
elemen
t
t
yp
e
whose
only
elemen
t
is
written

Ob
viously

something
of
t
yp
e
unit
con
v
eys
no
information
so
it
is
commonly
used
as
the
return
t
yp
e
of
imp
erativ
ely
written
functions
that
p
erform
a
sideeect
suc
h
as
include
ab
o
v
e
It
is
also
a
con
v
enien
t
argu
men
t
where
the
only
use
of
a
function
t
yp
e
is
to
dela
y
ev
aluation

The
t
yp
e
bool
This
is
a
elemen
t
t
yp
e
of
b
o
oleans
	truthv
alues
whose
elemen
ts
are
written
true
and
false

The
t
yp
e
int
This
con
tains
some
nite
subset
of
the
p
ositiv
e
and
negativ
e
in
tegers
T
ypically
the
p
ermitted
range
is
from

 	
up
to

 

	

The
n
umerals
are
written
in
the
usual
w
a
y

optionally
with
a
negation
sign
eg




The
t
yp
e
string
con
tains
strings
	ie
nite
sequences
of
c
haracters
They
are
written
and
prin
ted
b
et
w
een
double
quotes
eg
hello
In
order
to
enco
de
include
sp
ecial
c
haracters
in
strings
Clik
e
escap
e
sequences
are
used
F
or
example
 
is
the
double
quote
itself
and
 n
is
the
newline
c
haracter

This
is
ev
en
more
limited
than
exp
ected
for
mac
hine
arithmetic
b
ecause
a
bit
is
stolen
for
the
garbage
collector
W
e
will
see
later
ho
w
to
use
an
alternativ
e
t
yp
e
of
in
tegers
with
unlimited
precision


BASIC
D
A
T
A
TYPES
AND
OPERA
TIONS

The
ab
o
v
e
v
alues
lik
e

false

and
caml
are
all
to
b
e
regarded
as
constan
ts
in
the
lam
b
da
calculus
sense
There
are
other
constan
ts
corresp
onding
to
op
er
ations
on
the
basic
t
yp
es
Some
of
these
ma
y
b
e
written
as
inx
op
erators
for
the
sak
e
of
familiarit
y

These
ha
v
e
a
notion
of
precedence
so
that
expressions
are
group
ed
together
as
one
w
ould
exp
ect
F
or
example
w
e
write
x

y
rather
than

x
y
and
x



y

z
rather
than

x



y
z
The
logical
op
erator
not
also
has
a
sp
ecial
parsing
status
in
that
the
usual
leftasso
ciativit
y
rule
is
rev
ersed
for
it
not
not
p
means
not
not
p
Userdened
functions
ma
y
b
e
gran
ted
inx
status
via
the
infix
directiv
e
F
or
example
here
is
a
denition
of
a
function
p
erforming
comp
osition
of
functions
let
successor
x

x


successor

int
	
int

fun	
let
o
f
g

fun
x
	
fg
x
o

a
	
b
	
c
	
a
	
c
	
b

fun	
let
add

o
successor
o
successor
successor
add

int
	
int

fun	
add




int


infix
o
let
add

successor
o
successor
o
successor
add

int
	
int

fun	
add




int


It
is
not
p
ossible
to
sp
ecify
the
precedence
of
userdened
inxes
nor
to
mak
e
userdened
noninx
functions
righ
tasso
ciativ
e
Note
that
the
implicit
op
era
tion
of
function
application
has
a
higher
precedence
than
an
y
binary
op
erator
so
successor



parses
as
successor



If
it
is
desired
to
use
a
func
tion
with
sp
ecial
status
as
an
ordinary
constan
t
simply
precede
it
b
y
prefix
F
or
example
o
successor
successor
Toplevel
input
	o
successor
successor
	
Syntax
error
prefix
o
successor
successor


int
	
int

fun	
prefix
o
successor
successor


int
	
int

fun	
With
these
questions
of
concrete
syn
tax
out
of
the
w
a
y

let
us
presen
t
a
systematic
list
of
the
op
erators
on
the
basic
t
yp
es
ab
o
v
e
The
unary
op
erators
are
Op
erator
T
yp
e
Meaning

int

int
Numeric
negation
not
bool

bool
Logical
negation


CHAPTER

FUR
THER
ML
and
the
binary
op
erators
in
appro
ximately
decreasing
order
of
precedence
are
Op
erator
T
yp
e
Meaning
mod
int

int

int
Mo
dulus
	remainder

int

int

int
Multiplication

int

int

int
T
runcating
division

int

int

int
Addition

int

int

int
Subtraction
!
string

string

string
String
concatenation

a

a

bool
Equalit
y

a

a

bool
Inequalit
y

a

a

bool
Less
than

a

a

bool
Less
than
or
equal

a

a

bool
Greater
than

a

a

bool
Greater
than
or
equal
"
bool

bool

bool
Bo
olean
and
or
bool

bool

bool
Bo
olean
or
F
or
example
x


"
x


is
parsed
as
"

x


x

Note
that
all
the
comparisons
not
just
the
equalit
y
relation
are
p
olymorphic
They
not
only
order
in
tegers
in
the
exp
ected
w
a
y

and
strings
alphab
etically

but
all
other
primitiv
e
t
yp
es
and
comp
osite
t
yp
es
in
a
fairly
natural
w
a
y

Once
again
ho
w
ev
er
they
are
not
in
general
allo
w
ed
to
b
e
used
on
functions
The
t
w
o
b
o
olean
op
erations
"
and
or
ha
v
e
their
o
wn
sp
ecial
ev
aluation
strat
egy

lik
e
the
conditional
expression
In
fact
they
can
b
e
regarded
as
synon
yms
for
conditional
expressions
p
)
q


if
p
then
q
else
false
p
or
q


if
p
then
true
else
q
Th
us
the
and
op
eration
ev
aluates
its
rst
argumen
t
and
only
if
it
is
true
ev
aluates
its
second
Con
v
ersely

the
or
op
eration
ev
aluates
its
rst
argumen
t
and
only
if
it
is
false
ev
aluates
its
second

Syn
tax
of
ML
phrases
Expressions
in
ML
can
b
e
built
up
from
constan
ts
and
v
ariables
an
y
iden
tier
that
is
not
curren
tly
b
ound
is
treated
as
a
v
ariable
Declarations
bind
names
to
v
alues
of
expressions
and
declarations
can
o
ccur
lo
cally
inside
expressions
Th
us
the
syn
tax
classes
of
expressions
and
declarations
are
m
utually
recursiv
e
W
e
can
represen
t
this
b
y
the
follo
wing
BNF
grammar


W
e
neglect
man
y
constructs
that
w
e
w
ont
b
e
concerned
with
A
few
will
b
e
in
tro
duced
later
See
the
CAML
man
ual
for
full
details


SYNT
AX
OF
ML
PHRASES

expr
ession

v
ar
iabl
e
j
constant
j
expr
ession
expr
ession
j
expr
ession
inf
ix
expr
ession
j
not
expr
ession
j
if
expr
ession
then
expr
ession
else
expr
ession
j
fun
patter
n

expr
ession
j
	expr
ession
j
decl
ar
ation
in
expr
ession
decl
ar
ation

let
l
et
binding
s
j
let
rec
l
et
binding
s
l
et
binding
s

l
et
binding
j
l
et
binding
and
l
et
binding
s
l
et
binding

patter
n

expr
ession
patter
n

v
ar
iabl
es
v
ar
iabl
es

v
ar
iabl
e
j
v
ar
iabl
e
v
ar
iabl
es
The
syn
tax
class
patter
n
will
b
e
expanded
and
explained
more
thoroughly
later
on
F
or
the
momen
t
all
the
cases
w
e
are
concerned
with
are
either
just
v
ar
iabl
e
or
v
ar
iabl
e
v
ar
iabl
e



v
ar
iabl
e
In
the
rst
case
w
e
simply
bind
an
ex
pression
to
a
name
while
the
second
uses
the
sp
ecial
syn
tactic
sugar
for
function
declarations
where
the
argumen
ts
are
written
after
the
function
name
to
the
left
of
the
equals
sign
F
or
example
the
follo
wing
is
a
v
alid
declaration
of
a
function
add
whic
h
can
b
e
used
to
add

to
its
argumen
t
let
add
x

let
y

successor
x
in
let
z

let
w

successor
y
in
successor
w
in
successor
z
add

int
	
int

fun	
add



int


It
is
instructiv
e
to
unra
v
el
this
declaration
according
to
the
ab
o
v
e
grammar
A
toplev
el
phrase
terminated
b
y
t
w
o
successiv
e
semicolons
ma
y
b
e
either
an
expression
or
a
declaration


CHAPTER

FUR
THER
ML

F
urther
examples
It
is
easy
to
dene
b
y
recursion
a
function
that
tak
es
a
p
ositiv
e
in
teger
n
and
a
function
f
and
returns
f
n

ie
f





f
	n
times
let
rec
funpow
n
f
x

if
n


then
x
else
funpow
n


f
f
x
funpow

int
	
a
	
a
	
a
	
a

fun	
In
fact
a
little
though
t
will
sho
w
that
the
function
funpow
tak
es
a
mac
hine
in
teger
n
and
returns
the
Ch
urc
h
n
umeral
corresp
onding
to
n
Since
functions
arent
prin
ted
w
e
cant
actually
lo
ok
at
the
lam
b
da
expression
represen
ting
a
Ch
urc
h
n
umeral
funpow



a
	
a
	
a
	
a

fun	
Ho
w
ev
er
it
is
straigh
tforw
ard
to
dene
an
in
v
erse
function
to
funpow
that
tak
es
a
Ch
urc
h
n
umeral
bac
k
to
a
mac
hine
in
teger
let
defrock
n

n
fun
x
	
x




defrock

int
	
int
	
int
	
a
	
a

fun	
defrockfunpow



int


W
e
can
try
out
some
of
the
arithmetic
op
erations
on
Ch
urc
h
n
umerals
let
add
m
n
f
x

m
f
n
f
x
add

a
	
b
	
c
	
a
	
d
	
b
	
a
	
d
	
c

fun	
let
mul
m
n
f
x

m
n
f
x
mul

a
	
b
	
c
	
d
	
a
	
d
	
b
	
c

fun	
let
exp
m
n
f
x

n
m
f
x
exp

a
	
a
	
b
	
c
	
d
	
b
	
c
	
d

fun	
let
test
bop
x
y

defrock
bop
funpow
x
funpow
y
test

a
	
a
	
a
	
a
	
b
	
b
	
b
	
b
	
int
	
int
	
int
	
c
	
int
	
int
	
c

fun	
test
add





int


test
mul





int


test
exp





int



The
ab
o
v
e
is
not
a
v
ery
ecien
t
w
a
y
of
p
erforming
arithmetic
op
erations
ML
do
es
not
ha
v
e
a
function
for
exp
onen
tiation
but
it
is
easy
to
dene
one
b
y
recursion


FUR
THER
EXAMPLES
	
let
rec
exp
x
n

if
n


then

else
x

exp
x
n


exp

int
	
int
	
int

fun	
Ho
w
ev
er
this
p
erforms
n
m
ultiplications
to
calculate
x
n

A
more
ecien
t
w
a
y
is
to
exploit
the
facts
that
x
n

	x
n


and
x
n


x	x
n


as
follo
ws
let
square
x

x

x
square

int
	
int

fun	
let
rec
exp
x
n

if
n


then

else
if
n
mod



then
squareexp
x
n


else
x

squareexp
x
n


exp

int
	
int
	
int

fun	
infix
exp

exp




int




exp




int



Another
classic
op
eration
on
natural
n
um
b
ers
is
to
nd
their
greatest
common
divisor
	highest
common
factor
using
Euclids
algorithm
let
rec
gcd
x
y

if
y


then
x
else
gcd
y
x
mod
y
gcd

int
	
int
	
int

fun	
gcd





int


gcd

	


int


gcd





int


W
e
ha
v
e
used
a
notional
recursion
op
erator
Rec
to
explain
recursiv
e
deni
tions
W
e
can
actually
dene
suc
h
a
thing
and
use
it
let
rec
Rec
f

ffun
x
	
Rec
f
x
Rec

a
	
b
	
a
	
b
	
a
	
b

fun	
let
fact

Rec
fun
f
n
	
if
n


then

else
n

fn


fact

int
	
int

fun	
fact

it

int


Note
ho
w
ev
er
that
the
lam
b
da
w
as
essen
tial
otherwise
the
expression
Rec
f
go
es
in
to
an
innite
recursion
b
efore
it
is
ev
en
applied
to
its
argumen
t
let
rec
Rec
f

fRec
f
Rec

a
	
a
	
a

fun	
let
fact

Rec
fun
f
n
	
if
n


then

else
n

fn


Uncaught
exception
Outofmemory


CHAPTER

FUR
THER
ML

T
yp
e
denitions
W
e
ha
v
e
promised
that
ML
has
facilities
for
declaring
new
t
yp
e
constructors
so
that
comp
osite
t
yp
es
can
b
e
built
up
out
of
existing
ones
In
fact
ML
go
es
further
and
allo
ws
a
comp
osite
t
yp
e
to
b
e
built
up
not
only
out
of
preexisting
t
yp
es
but
also
from
the
comp
osite
t
yp
e
itself
Suc
h
t
yp
es
naturally
enough
are
said
to
b
e
r
e
cursive
They
are
declared
using
the
type
k
eyw
ord
follo
w
ed
b
y
an
equation
indicating
ho
w
the
new
t
yp
e
is
built
up
from
existing
ones
and
itself
W
e
will
illustrate
this
b
y
a
few
examples
The
rst
one
is
the
denition
of
a
sum
t
yp
e
in
tended
to
corresp
ond
to
the
disjoin
t
union
of
t
w
o
existing
t
yp
es
type
absum

inl
of
a

inr
of
b
Type
sum
defined
Roughly

an
ob
ject
of
t
yp
e
absum
is
either
something
of
t
yp
e
a
or
something
of
t
yp
e
b
More
formally

ho
w
ev
er
all
these
things
ha
v
e
dieren
t
t
yp
es
The
t
yp
e
declaration
also
declares
the
socalled
c
onstructors
inl
and
inr
These
are
functions
that
tak
e
ob
jects
of
the
comp
onen
t
t
yp
es
and
inject
them
in
to
the
new
t
yp
e
Indeed
w
e
can
see
their
t
yp
es
in
the
ML
system
and
apply
them
to
ob
jects
inl


a
	
a
b
sum

fun	
inr


a
	
b
a
sum

fun	
inl



int
a
sum

inl

inr
false


a
bool
sum

inr
false
W
e
can
visualize
the
situation
via
the
follo
wing
diagram
Giv
en
t
w
o
existing
t
yp
es

and


the
t
yp
e
	


sum
is
comp
osed
precisely
of
separate
copies
of

and


and
the
t
w
o
constructors
map
on
to
the
resp
ectiv
e
copies


	


sum
             
inl
inr
X
X
X
X
X
X
X
X
X
X
X
X
X
z


TYPE
DEFINITIONS

This
is
similar
to
a
union
in
C
but
in
ML
the
copies
of
the
comp
onen
t
t
yp
es
are
k
ept
apart
and
one
alw
a
ys
kno
ws
whic
h
of
these
an
elemen
t
of
the
union
b
elongs
to
By
con
trast
in
C
the
comp
onen
t
t
yp
es
are
o
v
erlapp
ed
and
the
programmer
is
resp
onsible
for
this
b
o
okk
eeping

P
attern
matc
hing
The
constructors
in
suc
h
a
denition
ha
v
e
three
v
ery
imp
ortan
t
prop
erties

They
are
exhaustiv
e
ie
ev
ery
elemen
t
of
the
new
t
yp
e
is
obtainable
either
b
y
inl
x
for
some
x
or
inr
y
for
some
y
That
is
the
new
t
yp
e
con
tains
nothing
b
esides
copies
of
the
comp
onen
t
t
yp
es

They
are
injectiv
e
ie
an
equalit
y
test
inl
x

inl
y
is
true
if
and
only
if
x

y
and
similarly
for
inr
That
is
the
new
t
yp
e
con
tains
a
faithful
cop
y
of
eac
h
comp
onen
t
t
yp
e
without
iden
tifying
an
y
elemen
ts

They
are
distinct
ie
their
ranges
are
disjoin
t
More
concretely
this
means
in
the
ab
o
v
e
example
that
inl
x

inr
y
is
false
whatev
er
x
and
y
migh
t
b
e
That
is
the
cop
y
of
eac
h
comp
onen
t
t
yp
e
is
k
ept
apart
in
the
new
t
yp
e
The
second
and
third
prop
erties
of
constructors
justify
our
using
p
attern
matching
This
is
done
b
y
using
more
general
varstructs
as
the
argumen
ts
in
a
lam
b
da
eg
fun
inl
n
	
n
	


inr
b
	
b


int
bool
sum
	
bool

fun	
This
function
has
the
prop
ert
y

naturally
enough
that
when
applied
to
inl
n
it
returns
n


and
when
applied
to
inr
b
it
returns
b
It
is
precisely
b
ecause
of
the
second
and
third
prop
erties
of
the
constructors
that
w
e
kno
w
this
do
es
giv
e
a
w
elldened
function
Because
the
constructors
are
injectiv
e
w
e
can
uniquely
reco
v
er
n
from
inl
n
and
b
from
inr
b
Because
the
constructors
are
distinct
w
e
kno
w
that
the
t
w
o
clauses
cannot
b
e
m
utually
inconsisten
t
since
no
v
alue
can
corresp
ond
to
b
oth
patterns
In
addition
b
ecause
the
constructors
are
exhaustiv
e
w
e
kno
w
that
eac
h
v
alue
will
fall
under
one
pattern
or
the
other
so
the
function
is
dened
ev
erywhere
Actually

it
is
p
ermissible
to
relax
this
last
prop
ert
y
b
y
omitting
certain
patterns
though
the
ML
system
then
issues
a
w
arning
fun
inr
b
	
b
Toplevel
input
	fun
inr
b
	
b
	
Warning
this
matching
is
not
exhaustive


a
b
sum
	
b

fun	


CHAPTER

FUR
THER
ML
If
this
function
is
applied
to
something
of
the
form
inl
x
then
it
will
not
w
ork
let
f

fun
inr
b
	
b
Toplevel
input
	let
f

fun
inr
b
	
b
	

Warning
this
matching
is
not
exhaustive
f

a
b
sum
	
b

fun	
f
inl

Uncaught
exception
Matchfailure



Though
b
o
oleans
are
built
in
to
ML
they
are
eectiv
ely
dened
b
y
a
rather
trivial
instance
of
a
recursiv
e
t
yp
e
often
called
an
enumer
ate
d
typ
e
where
the
constructors
tak
e
no
argumen
ts
type
bool

false

true
Indeed
it
is
p
erfectly
p
ermissible
to
dene
things
b
y
matc
hing
o
v
er
the
truth
v
alues
The
follo
wing
t
w
o
phrases
are
completely
equiv
alen
t
if



then

else




int


fun
true
	


false
	







int


P
attern
matc
hing
is
ho
w
ev
er
not
limited
to
casewise
denitions
o
v
er
elemen
ts
of
recursiv
e
t
yp
es
though
it
is
particularly
con
v
enien
t
there
F
or
example
w
e
can
dene
a
function
that
tells
us
whether
an
in
teger
is
zero
as
follo
ws
fun

	
true

n
	
false


int
	
bool

fun	
fun

	
true

n
	
false




bool

true
fun

	
true

n
	
false



bool

false
In
this
case
w
e
no
longer
ha
v
e
m
utual
exclusivit
y
of
patterns
since

matc
hes
either
pattern
The
patterns
are
examined
in
order
one
b
y
one
and
the
rst
matc
hing
one
is
used
Note
carefully
that
unless
the
matc
hes
are
m
utually
ex
clusiv
e
there
is
no
guaran
tee
that
eac
h
clause
holds
as
a
mathematical
equation
F
or
example
in
the
ab
o
v
e
the
function
do
es
not
return
false
for
an
y
n
so
the
second
clause
is
not
univ
ersally
v
alid
Note
that
only
c
onstructors
ma
y
b
e
used
in
the
ab
o
v
e
sp
ecial
w
a
y
as
com
p
onen
ts
of
patterns
Ordinary
constan
ts
will
b
e
treated
as
new
v
ariables
b
ound
inside
the
pattern
F
or
example
consider
the
follo
wing


TYPE
DEFINITIONS

let
true

true
true

bool

true
let
false

false
false

bool

false
fun
true
	


false
	





Toplevel
input
	fun
true
	


false
	





	

Warning
this
matching
case
is
unused


int


In
general
the
unit
elemen
t

the
truth
v
alues
the
in
teger
n
umerals
the
string
constan
ts
and
the
pairing
op
eration
	inx
comma
ha
v
e
constructor
status
as
w
ell
as
other
constructors
from
predened
recursiv
e
t
yp
es
When
they
o
ccur
in
a
pattern
the
target
v
alue
m
ust
corresp
ond
All
other
iden
tiers
matc
h
an
y
expression
and
in
the
pro
cess
b
ecome
b
ound
As
w
ell
as
the
v
arstructs
in
lam
b
da
expressions
there
are
other
w
a
ys
of
p
er
forming
pattern
matc
hing
Instead
of
creating
a
function
via
pattern
matc
hing
and
applying
it
to
an
expression
one
can
p
erform
patternmatc
hing
o
v
er
the
expression
directly
using
the
follo
wing
construction
matc
h
expr
ession
with
patter
n

E

j



j
patter
n
n

E
n
The
simplest
alternativ
e
of
all
is
to
use
let
patter
n

expr
ession
but
in
this
case
only
a
single
pattern
is
allo
w
ed

Recursiv
e
t
yp
es
The
previous
examples
ha
v
e
all
b
een
recursiv
e
only
v
acuously

in
that
w
e
ha
v
e
not
dened
a
t
yp
e
in
terms
of
itself
F
or
a
more
in
teresting
example
w
e
will
declare
a
t
yp
e
of
lists
	nite
ordered
sequences
of
elemen
ts
of
t
yp
e
a
type
alist

Nil

Cons
of
a

alist
Type
list
defined
Let
us
examine
the
t
yp
es
of
the
constructors
Nil


a
list

Nil
Cons


a

a
list
	
a
list

fun	


CHAPTER

FUR
THER
ML
The
constructor
Nil
whic
h
tak
es
no
argumen
ts
simply
creates
some
ob
ject
of
t
yp
e
alist
whic
h
is
to
b
e
though
t
of
as
the
empt
y
list
The
other
constructor
Cons
tak
es
an
elemen
t
of
t
yp
e
a
and
an
elemen
t
of
the
new
t
yp
e
alist
and
giv
es
another
whic
h
w
e
think
of
as
arising
from
the
old
list
b
y
adding
one
elemen
t
to
the
fron
t
of
it
F
or
example
w
e
can
consider
the
follo
wing
Nil


a
list

Nil
ConsNil


int
list

Cons

Nil
ConsConsNil


int
list

Cons

Cons

Nil
ConsConsConsNil




int
list

Cons

Cons

Cons

Nil
Because
the
constructors
are
distinct
and
injectiv
e
it
is
easy
to
see
that
all
these
v
alues
whic
h
w
e
think
of
as
lists
 
 

 
and


 
are
distinct
Indeed
purely
from
these
prop
erties
of
the
constructors
it
follo
ws
that
arbitrarily
long
lists
of
elemen
ts
ma
y
b
e
enco
ded
in
the
new
t
yp
e
Actually

ML
already
has
a
t
yp
e
list
just
lik
e
this
one
dened
The
only
dierence
is
syn
tactic
the
empt
y
list
is
written

and
the
recursiv
e
constructor

has
inx
status
Th
us
the
ab
o
v
e
lists
are
actually
written
 !


a
list

 !
 !


int
list

 !
 !


int
list

 
!
 !


int
list

 

!
The
lists
are
prin
ted
in
an
ev
en
more
natural
notation
and
this
is
also
allo
w
ed
for
input
Nev
ertheless
when
the
exact
expression
in
terms
of
constructors
is
needed
it
m
ust
b
e
remem
b
ered
that
this
is
only
a
surface
syn
tax
F
or
example
w
e
can
dene
functions
to
tak
e
the
head
and
tail
of
a
list
using
pattern
matc
hing
let
hd
ht

h
Toplevel
input
	let
hd
ht

h
	

Warning
this
matching
is
not
exhaustive
hd

a
list
	
a

fun	
let
tl
ht

t
Toplevel
input
	let
tl
ht

t
	

Warning
this
matching
is
not
exhaustive
tl

a
list
	
a
list

fun	


TYPE
DEFINITIONS

The
compiler
w
arns
us
that
these
b
oth
fail
when
applied
to
the
empt
y
list
since
there
is
no
pattern
to
co
v
er
it
	remem
b
er
that
the
constructors
are
distinct
Let
us
see
them
in
action
hd
 !


int


tl
 !


int
list

 
!
hd
 !
Uncaught
exception
Matchfailure
Note
that
the
follo
wing
is
not
a
correct
denition
of
hd
In
fact
it
constrains
the
input
list
to
ha
v
e
exactly
t
w
o
elemen
ts
for
matc
hing
to
succeed
as
can
b
e
seen
b
y
thinking
of
the
v
ersion
in
terms
of
the
constructors
let
hd
 xy!

x
Toplevel
input
	let
hd
 xy!

x
	

Warning
this
matching
is
not
exhaustive
hd

a
list
	
a

fun	
hd
 !


int


hd
 !
Uncaught
exception
Matchfailure
P
attern
matc
hing
can
b
e
com
bined
with
recursion
F
or
example
here
is
a
function
to
return
the
length
of
a
list
let
rec
length

fun
 !
	


ht
	


length
t
length

a
list
	
int

fun	
length
 !


int


length
 !


int


Alternativ
ely

this
can
b
e
written
in
terms
of
our
earlier
destructor
functions
hd
and
tl
let
rec
length
l

if
l

 !
then

else


lengthtl
l
This
latter
st
yle
of
function
denition
is
more
usual
in
man
y
languages
no
tably
LISP

but
the
direct
use
of
pattern
matc
hing
is
often
more
elegan
t


CHAPTER

FUR
THER
ML

T
ree
structures
It
is
often
helpful
to
visualize
the
elemen
ts
of
recursiv
e
t
yp
es
as
tree
structures
with
the
recursiv
e
constructors
at
the
branc
h
no
des
and
the
other
datat
yp
es
at
the
lea
v
es
The
recursiv
eness
merely
sa
ys
that
plugging
subtrees
together
giv
es
another
tree
In
the
case
of
lists
the
trees
are
all
rather
spindly
and
onesided
with
the
list




b
eing
represen
ted
as



      


   


   







It
is
not
dicult
to
dene
recursiv
e
t
yp
es
whic
h
allo
w
more
balanced
trees
eg
type
abtree

Leaf
of
a

Branch
of
abtree

abtree
In
general
there
can
b
e
sev
eral
dieren
t
recursiv
e
constructors
eac
h
with
a
dieren
t
n
um
b
er
of
descendan
ts
This
giv
es
a
v
ery
natural
w
a
y
of
represen
ting
the
syntax
tr
e
es
of
programming
	and
other
formal
languages
F
or
example
here
is
a
t
yp
e
to
represen
t
arithmetical
expressions
built
up
from
in
tegers
b
y
addition
and
m
ultiplication
type
expression

Integer
of
int

Sum
of
expression

expression

Product
of
expression

expression
and
here
is
a
recursiv
e
function
to
ev
aluate
suc
h
expressions
let
rec
eval

fun
Integer
i
	
i

Sumee
	
eval
e

eval
e

Productee
	
eval
e

eval
e
eval

expression
	
int

fun	
eval
ProductSumInteger
Integer
Integer



int




TYPE
DEFINITIONS

Suc
h
abstract
syn
tax
trees
are
a
useful
represen
tation
whic
h
allo
ws
all
sorts
of
manipulations
Often
the
rst
step
programming
language
compilers
and
related
to
ols
tak
e
is
to
translate
the
input
text
in
to
an
abstract
syn
tax
tree
according
to
the
parsing
rules
Note
that
con
v
en
tions
suc
h
as
precedences
and
brac
k
etings
are
not
needed
once
w
e
ha
v
e
reac
hed
the
lev
el
of
abstract
syn
tax
the
tree
struc
ture
mak
es
these
explicit
W
e
will
use
suc
h
tec
hniques
to
write
ML
v
ersions
of
the
formal
rules
of
lam
b
da
calculus
that
w
e
w
ere
considering
earlier
First
the
follo
wing
t
yp
e
is
used
to
represen
t
lam
b
da
terms
type
term

Var
of
string

Const
of
string

Comb
of
term

term

Abs
of
string

term
Type
term
defined
Note
that
w
e
mak
e
Abs
tak
e
a
v
ariable
name
and
a
term
rather
than
t
w
o
terms
in
order
to
prohibit
the
formation
of
terms
that
arent
v
alid
F
or
example
w
e
represen
t
the
term
x
y

y
	x
x
y

b
y
AbsxAbsyCombVar
yCombCombVar
xVar
xVar
y
Here
is
the
recursiv
e
denition
of
a
function
free
in
to
decide
whether
a
v
ariable
is
free
in
a
term
let
rec
freein
x

fun
Var
v
	
x

v

Const
c
	
false

Combst
	
freein
x
s
or
freein
x
t

Absvt
	
not
x

v
"
freein
x
t
freein

string
	
term
	
bool

fun	
freein
x
CombVar
fVar
x


bool

true
freein
x
AbsxCombVar
xVar
y


bool

false
Similarly

w
e
can
dene
substitution
b
y
recursion
First
though
w
e
need
a
function
to
rename
v
ariables
to
a
v
oid
name
clashes
W
e
w
an
t
the
abilit
y
to
con
v
ert
an
existing
v
ariable
name
to
a
new
one
that
is
not
free
in
some
giv
en
expression
The
renaming
is
done
b
y
adding
prime
c
haracters
let
rec
variant
x
t

if
freein
x
t
then
variant
x
t
else
x
variant

string
	
term
	
string

fun	
variant
x
CombVar
fVar
x


string

x
variant
x
AbsxCombVar
xVar
y


string

x
variant
x
CombVar
fCombVar
xVar
x


string

x


CHAPTER

FUR
THER
ML
No
w
w
e
can
dene
substitution
just
as
w
e
did
in
abstract
terms
let
rec
subst
u
tx

match
u
with
Var
y
	
if
x

y
then
t
else
Var
y

Const
c
	
Const
c

Combss
	
Combsubst
s
txsubst
s
tx

Absys
	
if
x

y
then
Absys
else
if
freein
x
s
"
freein
y
t
then
let
z

variant
y
Combst
in
Abszsubst
subst
s
Var
yz
tx
else
Absysubst
s
tx
subst

term
	
term

string
	
term

fun	
Note
the
v
ery
close
parallels
b
et
w
een
the
standard
mathematical
presen
tation
of
lam
b
da
calculus
as
w
e
presen
ted
earlier
and
the
ML
v
ersion
here
All
w
e
really
need
to
mak
e
the
analogy
complete
is
a
means
of
reading
and
writing
the
terms
in
some
more
readable
form
rather
than
b
y
explicitly
in
v
oking
the
constructors
W
e
will
return
to
this
issue
later
and
see
ho
w
to
add
these
features

The
subtlet
y
of
recursiv
e
t
yp
es
A
recursiv
e
t
yp
e
ma
y
con
tain
nested
instances
of
other
t
yp
e
constructors
includ
ing
the
function
space
constructor
F
or
example
consider
the
follo
wing
type
aembedding

K
of
aembedding	a
Type
embedding
defined
If
w
e
stop
to
think
ab
out
the
underlying
seman
tics
this
lo
oks
disquieting
Consider
for
example
the
sp
ecial
case
when
a
is
bool
W
e
then
ha
v
e
an
injec
tiv
e
function
Kboolembeddingbool

bool
em
bedd
ing
This
directly
con
tradicts
Can
tors
theorem
that
the
set
of
all
subsets
of
X
cannot
b
e
injected
in
to
X


Hence
w
e
need
to
b
e
more
careful
with
the
seman
tics
of
t
yp
es
In
fact

 
cannot
b
e
in
terpreted
as
the
full
function
space
or
recursiv
e
t
yp
e
constructions
lik
e
the
ab
o
v
e
are
inconsisten
t
Ho
w
ev
er
since
all
functions
w
e
can
actually
create
are
computable
it
is
reasonable
to
restrict
ourselv
es
to
com
putable
functions
only

With
that
restriction
a
consisten
t
seman
tics
is
p
ossible
although
the
details
are
complicated
The
ab
o
v
e
denition
also
has
in
teresting
consequences
for
the
t
yp
e
system
F
or
example
w
e
can
no
w
dene
the
Y
com
binator
b
y
using
K
as
a
kind
of
t
yp
e
cast
Note
that
if
the
K
s
are
deleted
this
is
essen
tially
the
usual
denition
of

Pro
of
consider
C

fis
j
s

X

and
is

sg
If
i

X

 X
is
injectiv
e
w
e
ha
v
e
iC


C

iC


C

a
con
tradiction
This
is
similar
to
the
Russell
parado
x
and
in
fact
probably
inspired
it
The
analogy
is
ev
en
closer
if
w
e
consider
the
equiv
alen
t
form
that
there
is
no
surjection
j

X
 X


and
pro
v
e
it
b
y
considering
fs
j
s

j
s
g


TYPE
DEFINITIONS
	
the
Y
com
binator
in
un
t
yp
ed
lam
b
da
calculus
The
use
of
let
is
only
used
for
the
sak
e
of
eciency

but
w
e
do
need
the
	
redex
in
v
olving
z
in
order
to
prev
en
t
lo
oping
under
MLs
ev
aluation
strategy

let
Y
h

let
g
K
x
z

h
x
K
x
z
in
g
K
g
Y

a
	
b
	
a
	
b
	
a
	
b

fun	
let
fact

Y
fun
f
n
	
if
n


then

else
n

fn


fact

int
	
int

fun	
fact



int


Th
us
recursiv
e
t
yp
es
are
a
p
o
w
erful
addition
to
the
language
and
allo
w
us
to
bac
k
o
the
c
hange
of
making
the
recursion
op
erator
a
primitiv
e
Exercises

What
go
es
wrong
in
our
denition
of
subst
if
w
e
replace
Var
y

if
x

y
then
t
else
Var
y
b
y
these
separate
patterns
Var
x

t
#
Var
y

Var
y

It
w
ould
b
e
p
ossible
though
inecien
t
to
dene
natural
n
um
b
ers
using
the
follo
wing
recursiv
e
t
yp
e
type
num

Zero

Suc
of
num
Dene
functions
to
p
erform
arithmetic
on
natural
n
um
b
ers
in
this
form

Use
the
t
yp
e
denition
for
the
syn
tax
of
lam
b
da
terms
that
w
e
ga
v
e
ab
o
v
e
W
rite
a
function
to
con
v
ert
an
arbitrary
lam
b
da
term
in
to
an
equiv
alen
t
in
terms
of
the
S

K
and
I
com
binators
based
on
the
tec
hnique
w
e
ga
v
e
earlier
Represen
t
the
com
binators
b
y
Const
S
etc

Extend
the
syn
tax
of
lam
b
da
terms
to
a
incorp
orate
Ch
urc
hst
yle
t
yping
W
rite
functions
that
c
hec
k
the
t
yping
conditions
b
efore
allo
wing
terms
to
b
e
formed
but
otherwise
map
do
wn
to
the
primitiv
e
constructors

Consider
a
t
yp
e
of
binary
trees
with
strings
at
the
no
des
dened
b
y
type
stree

Leaf

Branch
of
stree

string

stree


CHAPTER

FUR
THER
ML
W
rite
a
function
strings
to
return
a
list
of
the
strings
o
ccurring
in
the
tree
in
lefttorigh
t
order
ie
at
eac
h
no
de
it
app
ends
the
list
resulting
from
the
left
branc
h
the
singleton
list
at
the
curren
t
no
de
and
the
list
o
ccurring
at
the
righ
t
branc
h
in
that
order
W
rite
a
function
that
tak
es
a
tree
where
the
corresp
onding
list
is
alphab
etically
sorted
and
a
new
string
and
returns
a
tree
with
the
new
string
inserted
in
the
appropriate
place

	
Rene
the
ab
o
v
e
functions
so
that
the
tree
remains
almost
balanced
at
eac
h
stage
ie
the
maxim
um
depths
o
ccurring
at
the
left
and
righ
t
branc
hes
dier
b
y
at
most
one


	
Can
y
ou
c
haracterize
the
t
yp
es
of
expressions
that
can
b
e
written
do
wn
in
simply
t
yp
ed
lam
b
da
calculus
without
a
recursion
op
erator

What
is
the
t
yp
e
of
the
follo
wing
recursiv
e
function
let
rec
f
i

i
o
f
i
o
i
Sho
w
ho
w
it
can
b
e
used
to
write
do
wn
ML
expressions
with
completely
p
olymorphic
t
yp
e


Can
y
ou
write
a
terminating
expression
with
this
prop
ert
y
What
ab
out
an
arbitrary
function
t
yp
e

 


See
AdelsonV
elskii
and
Landis
	
and
v
arious
algorithm
b
o
oks
for
more
details
of
these
A
VL
trees
and
similar
metho
ds
for
balanced
trees

The
answ
er
lies
in
the
CurryHo
w
ard
isomorphism

see
Girard
Lafon
t
and
T
a
ylor
		
for
example

Chapter

Pro
ving
programs
correct
As
programmers
kno
w
through
bitter
p
ersonal
exp
erience
it
can
b
e
v
ery
dicult
to
write
a
program
that
is
c
orr
e
ct
ie
p
erforms
its
in
tended
function
Most
large
programs
ha
v
e
bugs
The
consequences
of
these
bugs
can
v
ary
widely

Some
bugs
are
harmless
some
merely
irritating
Some
are
deadly

F
or
example
the
programs
inside
heart
pacemak
ers
aircraft
autopilots
car
engine
managemen
t
systems
and
an
tilo
c
k
braking
systems
radiation
therap
y
mac
hines
and
n
uclear
reactor
con
trollers
are
safety
critic
al
An
error
in
one
of
them
can
lead
directly
to
loss
of
life
p
ossibly
on
a
large
scale
As
computers
b
ecome
ev
er
more
p
erv
asiv
e
in
so
ciet
y

the
n
um
b
er
of
w
a
ys
in
whic
h
program
bugs
can
kill
p
eople
increases

Ho
w
can
w
e
mak
e
sure
a
program
is
correct
One
v
ery
useful
metho
d
is
simply
to
test
it
in
a
v
ariet
y
of
situations
One
tries
the
program
out
on
inputs
designed
to
exercise
man
y
dieren
t
parts
of
it
and
rev
eal
p
ossible
bugs
But
usually
there
are
to
o
man
y
p
ossible
situations
to
try
them
all
exhaustiv
ely

so
there
ma
y
still
b
e
bugs
lying
undetected
As
rep
eatedly
emphasized
b
y
v
arious
writers
notably
Dijkstra
program
testing
can
b
e
v
ery
useful
for
demonstrating
the
presence
of
bugs
but
it
is
only
in
a
few
un
usual
cases
where
it
can
demonstrate
their
absence
Instead
of
testing
a
program
one
can
try
to
verify
it
mathematically

A
program
in
a
sucien
tly
precisely
dened
programming
language
has
a
denite
mathematical
meaning
Similarly

the
requiremen
ts
on
a
program
can
b
e
ex
pressed
using
mathematics
and
logic
as
a
precise
sp
e
cic
ation
One
can
then
try
to
p
erform
a
mathematical
pr
o
of
that
the
program
meets
its
sp
ecication
One
can
con
trast
testing
and
v
erication
of
programs
b
y
considering
the
fol
lo
wing
simple
mathematical
assertion

N
n n

N
	N
"


It
is
claimed
that
this
holds
for
an
y
N

W
e
can
certainly
test
it
for
an
y
n
um
b
er
of
particular
v
alues
of
N

This
ma
y
lead
to
our
in
tuitiv
e
condence
in
the
form
ula
suc
h
that
w
e
can
hardly
b
eliev
e
it
could
ev
er
fail
Ho
w
ev
er
in

Similar
remarks
apply
to
hardw
are
but
w
e
will
fo
cus
on
soft
w
are



CHAPTER

PR
O
VING
PR
OGRAMS
CORRECT
general
a
prep
onderance
of
n
umerical
evidence
can
b
e
deceptiv
e
there
are
w
ell
kno
wn
cases
in
n
um
b
er
theory
where
things
turned
out
to
b
e
false
against
the
w
eigh
t
of
man
y
particular
cases

A
more
reliable
pro
cedure
is
to
pr
ove
the
ab
o
v
e
form
ula
mathematically

This
can
easily
b
e
done
using
induction
on
N

In
the
same
w
a
y

w
e
hop
e
to
replace
testing
a
program
on
a
range
of
inputs
b
y
some
completely
general
pro
of
that
it
alw
a
ys
w
orks
correctly

It
is
imp
ortan
t
ho
w
ev
er
to
appreciate
t
w
o
limitations
of
program
pro
ofs

One
has
no
guaran
tee
that
the
execution
of
the
program
on
the
computer
corresp
onds
exactly
to
the
abstract
mathematical
mo
del
One
m
ust
b
e
on
the
lo
ok
out
for
discrepancies
caused
p
erhaps
b
y
bugs
in
compilers
and
op
erating
systems
or
ph
ysical
defects
in
the
underlying
tec
hnology

This
is
of
course
a
general
problem
in
applications
of
mathematics
to
science
F
or
example
assuming
that
arithmetic
op
erations
corresp
ond
exactly
to
their
mathematical
coun
terparts
is
a
natural
simplifying
assumption
just
as
one
migh
t
neglect
air
resistance
in
the
analysis
of
a
simple
dynamical
system
But
b
oth
can
b
e
in
v
alid
in
certain
cases

The
program
is
to
b
e
v
eried
b
y
pro
of
against
a
mathematical
sp
ecication
It
is
p
ossible
that
this
sp
ecication
do
es
not
capture
accurately
what
is
actually
w
an
ted
in
the
real
w
orld
In
fact
it
can
b
e
remark
ably
dicult
to
arriv
e
at
a
precise
mathematical
v
ersion
of
informal
requiremen
ts
There
is
evidence
that
man
y
of
the
serious
problems
in
computer
systems
are
caused
not
b
y
co
ding
errors
in
the
usual
sense
but
b
y
a
mistak
en
impression
of
what
is
actually
w
an
ted
Just
formalizing
the
requiremen
ts
is
often
v
aluable
in
itself
W
e
can
represen
t
this
situation
b
y
the
follo
wing
diagram
Actual
system
Mathematical
mo
del
Mathematical
sp
ecication
Actual
requiremen
ts



W
e
are
trying
to
establish
a
link
b
et
w
een
the
b
ottom
and
top
b
o
xes
ie
the
actual
system
and
the
actual
requiremen
ts
in
real
life
T
o
do
this
w
e
pro
ceed
b
y

F
or
example
Littlew
o
o
d
pro
v
ed
in
	
that

n

l
in
c
hanges
sign
innitely
often
where

n
is
the
n
um
b
er
of
primes

n
and
l
in

R
n

dul
nu

This
came
as
a
surprise
since
not
a
single
sign
c
hange
had
b
een
found
despite
extensiv
e
testing
up
to





FUNCTIONAL
PR
OGRAMS
AS
MA
THEMA
TICAL
OBJECTS

pro
ducing
a
mathematical
v
ersion
of
eac
h
It
is
only
the
cen
tral
link
b
et
w
een
the
mathematical
mo
del
of
the
system
and
the
mathematical
v
ersion
of
the
sp
ec
ication
that
is
mathematically
precise
The
other
links
remain
informal
All
w
e
can
do
is
try
to
k
eep
them
small
b
y
using
a
realistic
mo
del
of
the
system
and
a
highlev
el
mathematical
sp
ecication
that
is
reasonably
readable
These
reserv
ations
not
withstanding
program
pro
ving
has
considerable
merit
Compared
with
testing
it
establishes
correctness
once
and
for
all
p
ossibly
for
a
whole
class
of
programs
at
once
	eg
con
trolled
b
y
the
setting
of
some
parameter
Moreo
v
er
b
ecause
it
is
a
more
principled
analytical
approac
h
the
pro
cess
of
pro
ving
a
program
	or
failing
to
do
so
can
lead
to
a
deep
er
appreciation
of
the
program
and
of
the
task
in
hand

F
unctional
programs
as
mathematical
ob
jects
In
the
in
tro
duction
w
e
remark
ed
that
	pure
functional
programs
really
corre
sp
ond
directly
to
functions
in
the
mathematical
sense
F
or
this
reason
it
is
often
suggested
that
they
are
more
amenable
to
formal
pro
of
than
imp
erativ
e
programs
Ev
en
if
this
is
true
and
man
y
w
ould
dispute
it
it
is
w
orth
realizing
that
the
gap
b
et
w
een
this
mathematical
abstraction
and
the
nal
execution
in
hardw
are
is
greater
than
for
t
ypical
imp
erativ
e
languages
In
particular
there
can
b
e
substan
tial
storage
requiremen
ts
hidden
in
the
ev
en
tual
realization
on
the
computer
So
one
ma
y
just
b
e
getting
easier
pro
ofs
b
ecause
they
pro
v
e
less
ab
out
what
really
matters
W
e
w
ont
settle
this
argumen
t
here
but
w
e
w
an
t
to
sho
w
that
reasoning
ab
out
simple
functional
programs
is
often
fairly
straigh
tforw
ard
The
example
at
the
end
of
the
previous
c
hapter
sho
w
ed
that
a
naiv
e
asso
ci
ation
of
function
spaces
of
ML
and
function
spaces
of
mathematics
is
not
quite
accurate
Ho
w
ev
er
if
w
e
sta
y
a
w
a
y
from
the
higher
reac
hes
of
recursiv
e
t
yp
es
and
are
not
concerned
with
the
space
of
al
l
functions
only
with
some
particular
ones
w
e
can
safely
iden
tify
the
ob
jects
of
ML
with
those
of
abstract
mathematical
realms

W
e
in
tend
to
mo
del
functional
programs
as
mathematical
functions
Giv
en
the
equations

t
ypically
recursiv
e

that
dene
an
ML
function
w
e
w
an
t
to
in
terpret
them
as
axioms
ab
out
the
corresp
onding
mathematical
ob
jects
F
or
example
w
e
w
ould
assume
from
the
denition
of
the
factorial
function
let
rec
fact

fun

	


n
	
n

factn


that
fact
	


and
that
for
all
n


w
e
ha
v
e
fact	n

n

fact	n


This
is
righ
t
but
w
e
need
to
tread
carefully
b
ecause
of
the
question
of
termination
F
or

W
e
will
neglect
arithmetic
o
v
ero
w
whenev
er
w
e
use
arithmetic
There
is
a
facilit
y
in
CAML
for
arbitrary
precision
arithmetic
at
the
cost
of
in
principle
unlimited
storage
requiremen
ts


CHAPTER

PR
O
VING
PR
OGRAMS
CORRECT
negativ
e
n
the
program
fails
to
terminate
so
the
second
equation
is
true
only
in
the
v
acuous
sense
that
b
oth
sides
are
undened
It
is
m
uc
h
easier
to
reason
ab
out
functions
when
w
e
kno
w
they
are
total
so
sometimes
one
uses
a
separate
argumen
t
to
establish
termination
In
the
examples
that
follo
w
this
is
done
in
parallel
with
the
correctness
pro
of
ie
w
e
pro
v
e
together
that
for
eac
h
argumen
t
the
function
terminates
and
the
result
satises
our
sp
ecication
As
for
the
actual
pro
of
that
the
function
ob
eys
the
sp
ecication
this
can
b
e
a
mathematical
pro
of
in
the
most
general
sense
Ho
w
ev
er
it
often
happ
ens
that
when
functions
are
dened
b
y
recursion
prop
erties
of
them
dually

can
b
e
pro
v
ed
b
y
induction
this
includes
termination
Moreo
v
er
the
exact
form
of
induction
	arithmetical
structural
w
ellfounded
usually
corresp
onds
to
the
mo
de
of
recursion
used
in
the
denition
This
should
b
ecome
clearer
when
w
e
ha
v
e
seen
a
few
examples

Exp
onen
tiation
Recall
our
simple
denition
of
exp
onen
tiation
let
rec
exp
x
n

if
n


then

else
x

exp
x
n


W
e
will
pro
v
e
the
follo
wing
prop
ert
y
of
exp
Theorem

F
or
al
l
n


and
x
exp
x
n
is
dene
d
and
exp
x
n

x
n

Pro
of
The
ML
function
exp
was
dene
d
by
primitive
stepbystep
r
e
cursion
It
is
ther
efor
e
no
surprise
that
our
pr
o
of
pr
o
c
e
e
ds
by
or
dinary
stepbystep
induc
tion
We
pr
ove
that
it
holds
for
n


and
then
that
if
it
holds
for
any
n


it
also
holds
for
n
"


If
n


then
by
denition
exp
x
n


By
denition
for
any
inte
ger
x
we
have
x
 

so
the
desir
e
d
fact
is
establishe
d
Note
that
we
assume

 

an
example
of
how
one
must
state
the
sp
e
cic
ation
pr
e
cisely

what
do
es
x
n
me
an
in
gener
al

and
how
it
might
surprise
some
p
e
ople

Supp
ose
that
for
n


we
have
exp
x
n

x
n

Sinc
e
n


we
have
n
"



and
so
by
denition
exp
x
	n
"


x

exp
x
		n
"



Ther
efor
e
exp
x
	n
"


x

exp
x
		n
"




x

exp
x
n

x

x
n

x
n



GREA
TEST
COMMON
DIVISOR

QED

Greatest
common
divisor
Recall
our
function
to
calculate
the
greatest
common
divisor
g
cd	m
n
of
t
w
o
natural
n
um
b
ers
m
and
n
let
rec
gcd
x
y

if
y


then
x
else
gcd
y
x
mod
y
In
fact
w
e
claim
this
w
orks
for
an
y
in
tegers
not
just
p
ositiv
e
ones
Ho
w
ev
er
one
needs
to
understand
the
precise
denition
of
g
cd
in
that
case
Let
us
dene
the
relation
ujv

or
u
divides
v

for
an
y
t
w
o
in
tegers
u
and
v
to
mean
v
is
an
in
tegral
m
ultiple
of
u
ie
there
is
some
in
teger
d
with
v

du
F
or
example
j
j
j
but


j


j
W
e
will
sa
y
that
d
is
a
gr
e
atest
c
ommon
divisor
of
x
and
y
precisely
if

djx
and
djy

F
or
an
y
other
in
teger
d
 
if
d
 jx
and
d
 jy
then
d
 jd
Note
that
w
e
sa
y
d
 jd
not
d
 
d
This
b
elies
the
use
of
greatest
but
it
is
in
fact
the
standard
denition
in
algebra
b
o
oks
Observ
e
that
an
y
pair
of
n
um
b
ers
	except

and

has
t
w
o
gcds
since
if
d
is
a
gcd
of
x
and
y

so
is
d
Our
sp
ecication
is
no
w
for
any
inte
gers
x
and
y

d

gc
d
x
y
is
a
gc
d
of
x
and
y

This
is
another
go
o
d
example
of
ho
w
pro
viding
a
precise
sp
ecication
ev
en
for
suc
h
a
simple
function
is
harder
than
it
lo
oks
This
sp
ecication
also
exemplies
the
common
prop
ert
y
that
it
do
es
not
completely
sp
ecify
the
answ
er
merely
places
certain
constrain
ts
on
it
If
w
e
dened
let
rec
ngcd
x
y

gcd
x
y
then
the
function
ngcd
w
ould
satisfy
the
sp
ecication
just
as
w
ell
as
gcd
Of
course
w
e
are
free
to
tigh
ten
the
sp
ecication
if
w
e
wish
eg
insist
that
if
x
and
y
are
p
ositiv
e
so
is
the
gcd
returned
The
gcd
function
is
not
dened
simply
b
y
primitiv
e
recursion
In
fact
gcd
x
y
is
dened
in
terms
of
gcd
y
x
mod
y
in
the
step
case
Corresp
ondingly

w
e
do
not
use
stepb
ystep
induction
but
w
ellfounded
induction
W
e
w
an
t
a
w
ellfounded
relation
that
decreases
o
v
er
recursiv
e
calls
this
will
guaran
tee
ter
mination
and
act
as
a
handle
for
pro
ofs
b
y
w
ellfounded
induction
In
general
complicated
relations
on
the
argumen
ts
are
required
But
often
it
is
easy
to
conco
ct
a
me
asur
e
that
maps
the
argumen
ts
to
natural
n
um
b
ers
suc
h
that
the
measure
decreases
o
v
er
recursiv
e
calls
Suc
h
is
the
case
here
the
measure
is
jy
j


CHAPTER

PR
O
VING
PR
OGRAMS
CORRECT
Theorem

F
or
any
inte
gers
x
and
y

gc
d
x
y
terminates
in
a
gc
d
of
x
and
y

Pro
of
T
ake
some
arbitr
ary
n
and
supp
ose
that
for
al
l
x
and
y
with
jy
j

n
we
have
that
gc
d
x
y
terminates
with
a
gc
d
of
x
and
y

and
try
to
pr
ove
that
the
same
holds
for
al
l
x
and
y
with
jy
j

n
This
su	c
es
for
the
main
r
esult
sinc
e
any
y
wil
l
have
some
n
with
jy
j

n
So
let
us
c
onsider
an
x
and
y
with
jy
j

n
Ther
e
ar
e
two
c
ases
to
c
onsider
ac
c
or
ding
to
the
c
ase
split
use
d
in
the
denition

Supp
ose
y


Then
gc
d
x
y

x
by
denition
Now
trivial
ly
xjx
and
xj
so
it
is
a
c
ommon
divisor
Supp
ose
d
is
another
c
ommon
divisor
ie
djx
and
dj
Then
inde
e
d
we
have
djx
imme
diately
so
x
must
b
e
a
gr
e
atest
c
ommon
divisor

Supp
ose
y


We
want
to
apply
the
inductive
hyp
othesis
to
gc
d
y
	x
mo
d
y

We
wil
l
write
r

x
mo
d
y
for
short
The
b
asic
pr
op
erty
of
the
mod
function
is
that
sinc
e
y


for
some
inte
ger
q
we
have
x

q
y
"
r
and
jr
j

jy
j
Sinc
e
jr
j

jy
j
the
inductive
hyp
othesis
tel
ls
us
that
d

gc
d
y
	x
mo
d
y

is
a
gc
d
of
y
and
r

We
just
ne
e
d
to
show
that
it
is
a
gc
d
of
x
and
y

It
is
c
ertainly
a
c
ommon
divisor
sinc
e
if
djy
and
djr
we
have
djx
as
x

q
y
"
r

Now
supp
ose
d
 jx
and
d
 jy

By
the
same
e
quation
we
nd
that
d
 jr

Thus
d
 is
a
c
ommon
divisor
of
y
and
r

but
then
by
the
inductive
hyp
othesis
d
 jd
as
r
e
quir
e
d
QED
Note
that
the
basic
prop
ert
y
of
the
mo
dulus
op
eration
that
w
e
used
needs
careful
c
hec
king
against
the
sp
ecication
of
mod
in
the
CAML
man
ual
There
are
w
ell
kno
wn
dierences
b
et
w
een
languages
and
b
et
w
een
implemen
tations
of
the
same
language
when
mo
duli
in
v
olving
negativ
e
n
um
b
ers
are
concerned
If
ev
er
one
is
in
doubt
o
v
er
the
v
alidit
y
of
a
necessary
assumption
it
can
b
e
made
explicit
in
the
theorem
if



then





App
ending
W
e
will
no
w
ha
v
e
an
example
of
a
function
dened
o
v
er
lists
The
function
append
is
in
tended
not
surprisingly

to
app
end
or
join
together
t
w
o
lists
F
or
example
if
w
e
app
end


 
and


 
w
e
get





 
let
rec
append
l
l

match
l
with
 !
	
l

ht
	
happend
t
l
This
is
dened
b
y
primitiv
e
recursion
o
v
er
the
t
yp
e
of
lists
It
is
dened
on
the
empt
y
list
and
then
for
h

t
in
terms
of
the
v
alue
for
t
Consequen
tly



REVERSING

when
pro
ving
theorems
ab
out
it
it
is
natural
to
use
the
corresp
onding
principle
of
structural
induction
for
lists
if
a
prop
ert
y
holds
for
the
empt
y
list
and
whenev
er
it
holds
for
t
it
holds
for
an
y
h

t
then
it
holds
for
an
y
list
Ho
w
ev
er
this
is
not
obligatory

and
if
preferred
w
e
could
pro
ceed
b
y
mathematical
induction
on
the
length
of
the
list
W
e
will
aim
at
pro
ving
that
the
app
end
op
eration
is
asso
ciativ
e
Theorem

F
or
any
thr
e
e
lists
l


l

and
l

we
have
app
end
l

	app
end
l

l



app
end
	app
end
l

l


l

Pro
of
By
structur
al
induction
on
l


we
pr
ove
this
holds
for
any
l

and
l



If
l


 
then
app
end
l

	app
end
l

l



app
end
 
	app
end
l

l



app
end
l

l


app
end
	app
end
 
l


l


app
end
	app
end
l

l


l


Now
supp
ose
l


h

t
We
may
assume
that
for
any
l

and
l

we
have
app
end
t
	app
end
l

l



app
end
	app
end
t
l


l

Ther
efor
e
app
end
l

	app
end
l

l



app
end
	h

t
	app
end
l

l



h

	app
end
t
	app
end
l

l



h

	app
end
	app
end
t
l


l



app
end
	h

	app
end
t
l


l



app
end
	app
end
	h

t
l


l



app
end
	app
end
l

l


l


QED

Rev
ersing
It
is
not
dicult
to
dene
a
function
to
rev
erse
a
list


CHAPTER

PR
O
VING
PR
OGRAMS
CORRECT
let
rec
rev

fun
 !
	
 !

ht
	
append
rev
t
 h!
rev

a
list
	
a
list

fun	
rev
 !


int
list

 

!
W
e
will
pro
v
e
that
rev
is
an
in
v
olution
ie
that
rev	rev
l


l
Ho
w
ev
er
if
w
e
try
to
tac
kle
this
directly
b
y
list
induction
w
e
nd
that
w
e
need
a
couple
of
additional
lemmas
W
e
will
pro
v
e
these
rst
Lemma

F
or
any
list
l
we
have
app
end
l
 

l

Pro
of
Structur
al
induction
on
l


If
l

 
we
have
app
end
l
 

app
end
 
 

 

l

Now
supp
ose
l

h

t
and
we
know
that
app
end
t
 

t
We
nd
app
end
l
 

app
end
	h

t
 

h

	app
end
t
 

h

t

l
QED
Lemma

F
or
any
lists
l

and
l

we
have
r
ev	app
end
l

l



app
end
	r
ev
l


	r
ev
l


Pro
of
Structur
al
induction
on
l



If
l


 
we
have
r
ev	app
end
l

l



r
ev
	app
end
 
l



r
ev
l


app
end
	r
ev
l

 

app
end
	r
ev
l


	r
ev
 


REVERSING
	

Now
supp
ose
l


h

t
and
we
know
that
r
ev	app
end
t
l



app
end
	r
ev
l


	r
ev
t
then
we
nd
r
ev	app
end
l

l



r
ev	app
end
	h

t
l



r
ev	h

	app
end
t
l



app
end
	r
ev	app
end
t
l


h 

app
end
	app
end
	r
ev
l


	r
ev
t
h 

app
end
	r
ev
l


	app
end
	r
ev
t
h 

app
end
	r
ev
l


	r
ev
	h

t

app
end
	r
ev
l


	r
ev
l


QED
Theorem

F
or
any
list
l
we
have
r
ev	r
ev
l


l

Pro
of
Structur
al
induction
on
l


If
l

 
we
have
r
ev	r
ev
l


r
ev	r
ev
 

r
ev
 

 

l

Now
supp
ose
l

h

t
and
we
know
that
r
ev
	r
ev
t

t
then
we
nd
r
ev	r
ev
l


r
ev	r
ev
	h

t

r
ev	app
end
	r
ev
t
h 

app
end
	r
ev
h 
	r
ev	r
ev
t

app
end
	r
ev
h 
t

app
end
	r
ev
	h

 
t

	
CHAPTER

PR
O
VING
PR
OGRAMS
CORRECT

app
end
	app
end
	r
ev
 
h 
t

app
end
	app
end
 
h 
t

app
end
h 
t

app
end
	h

 
t

h

	app
end
 
t

h

t

l
QED
There
are
lots
of
theorems
relating
the
list
op
erations
that
can
b
e
pro
v
ed
in
a
similar
st
yle
Generally

one
pro
ceeds
b
y
list
induction
In
subtler
cases
one
has
to
split
o
lemmas
whic
h
are
themselv
es
pro
v
ed
inductiv
ely

and
sometimes
to
generalize
the
theorem
b
efore
pro
ceeding
b
y
induction
There
are
plen
t
y
of
examples
in
the
exercises
for
readers
to
try
their
hand
at
F
urther
reading
Neumann
			
catalogues
the
dangers
arising
from
the
use
of
computers
in
so
ciet
y

including
those
arising
from
soft
w
are
bugs
A
v
ery
readable
discussion
of
the
issues
with
extensiv
e
discussion
of
some
in
teresting
examples
is
giv
en
b
y
P
eterson
			
The
general
issue
of
soft
w
are
v
erication
w
as
at
one
time
con
tro
v
ersial
with
DeMillo
Lipton
and
P
erlis
			
among
others
arguing
against
it
A
cogen
t
discussion
is
giv
en
b
y
Barwise
			
There
is
no
w
a
large
liter
ature
in
soft
w
are
v
erication
though
m
uc
h
of
it
is
concerned
with
imp
erativ
e
programs
Man
y
in
tro
ductory
functional
programming
b
o
oks
suc
h
as
P
aulson
			
and
Reade
			
giv
e
some
basic
examples
lik
e
the
ones
here
It
is
also
w
orth
lo
oking
at
the
w
ork
of
Bo
y
er
and
Mo
ore
			
on
v
erifying
prop
erties
of
pure
LISP
functions
expressed
inside
their
theorem
pro
v
er
One
of
the
largest
real
pro
ofs
of
the
t
yp
e
w
e
consider
here
is
the
v
erication
b
y
Aagaard
and
Leeser
			
of
a
b
o
olean
simplier
used
in
VLSI
logic
syn
thesis
Exercises

Pro
v
e
the
correctness
of
the
more
ecien
t
program
w
e
ga
v
e
for
p
erforming
exp
onen
tiation


REVERSING
	
let
square
x

x

x
let
rec
exp
x
n

if
n


then

else
if
n
mod



then
squareexp
x
n


else
x

squareexp
x
n



Recall
the
denition
of
length
let
rec
length

fun
 !
	


ht
	


length
t
Pro
v
e
that
length
	rev
l


length
l
and
that
length
	app
end
l

l



length
l

"
length
l



Dene
the
map
function
whic
h
applies
a
function
to
eac
h
elemen
t
of
a
list
as
follo
ws
let
rec
map
f

fun
 !
	
 !

ht
	
f
hmap
f
t
Pro
v
e
that
if
l

 
then
hd
	map
f
l


f
	hd
l

and
that
map
f
	rev
l


rev
	map
f
l

Recall
the
denition
of
function
comp
osition
let
o
f
g

fun
x
	
fg
x
infix
o
Pro
v
e
that
map
f
	map
g
l


map
	f

g

l


McCarth
ys
	
function
can
b
e
dened
b
y
let
rec
f
x

if
x
	


then
x


else
ffx


Pro
v
e
that
for
n


w
e
ha
v
e
f
	n

	
P
a
y
careful
atten
tion
to
establishing
termination
	Hin
t
a
p
ossible
measure
is


x

	
CHAPTER

PR
O
VING
PR
OGRAMS
CORRECT

The
problem
of
the
Dutc
h
National
Flag
is
to
sort
a
list
of
colours
	red
white
and
blue
so
that
the
reds
come
rst
then
the
whites
and
then
the
blues
Ho
w
ev
er
the
only
metho
d
p
ermitted
is
to
sw
ap
adjacen
t
elemen
ts
Here
is
an
ML
solution
The
function
dnf
returns
true
i
it
has
made
a
c
hange
and
this
function
is
then
rep
eated
un
til
no
c
hange
o
ccurs
type
colour

Red

White

Blue
let
rec
dnf

fun
 !
	
 !false

WhiteRedrest
	
RedWhiteresttrue

BlueRedrest
	
RedBlueresttrue

BlueWhiterest
	
WhiteBlueresttrue

xrest
	
let
flch

dnf
rest
in
xflch
let
rec
flag
l

let
lchanged

dnf
l
in
if
changed
then
flag
l
else
l
F
or
example
flag
 White
Red
Blue
Blue
Red
White
White
Blue
Red!


colour
list

 Red
Red
Red
White
White
White
Blue
Blue
Blue!
Pro
v
e
that
the
function
flag
alw
a
ys
terminates
with
a
correctly
sorted
list

	
Dene
the
follo
wing
functions


REVERSING
	
let
rec
sorted

fun
 !
	
true

 h!
	
true

hht
	
h

h
"
sortedht
let
rec
filter
p

fun
 !
	
 !

ht
	
let
t

filter
p
t
in
if
p
h
then
ht
else
t
let
sameprop
p
l
l

lengthfilter
p
l

lengthfilter
p
l
let
rec
permutes
l
l

fun
 !
	
true

ht
	
sameprop
fun
x
	
x

h
l
l
"
permutes
l
l
t
let
permuted
l
l

permutes
l
l
l
What
do
they
all
do
Implemen
t
a
sorting
function
sort
and
pro
v
e
that
for
all
lists
l
one
has
sorted	sort
l


true
and
p
erm
uted
l
	sort
l


true


Chapter

E
ectiv
e
ML
In
this
c
hapter
w
e
discuss
some
of
the
tec
hniques
and
tric
ks
that
ML
program
mers
can
use
to
mak
e
programs
more
elegan
t
and
more
ecien
t
W
e
then
go
on
to
discuss
some
additional
imp
er
ative
features
that
can
b
e
used
when
the
purely
functional
st
yle
seems
inappropriate

Useful
com
binators
The
exibilit
y
of
higher
order
functions
often
means
that
one
can
write
some
v
ery
useful
little
functions
that
can
b
e
reused
for
a
v
ariet
y
of
related
tasks
These
are
often
called
c
ombinators
and
not
simply
b
ecause
they
can
b
e
regarded
as
lam
b
da
terms
with
no
free
v
ariables
It
often
turns
out
that
these
functions
are
so
exible
that
practically
an
ything
can
b
e
implemen
ted
b
y
plugging
them
together
rather
than
sa
y

explicitly
making
a
recursiv
e
denition
In
this
w
a
y
they
corresp
ond
to
the
original
view
of
com
binators
as
ubiquitous
building
blo
c
ks
for
mathematical
expressions
F
or
example
a
v
ery
useful
com
binator
for
list
op
erations
often
called
itlist
or
fold
p
erforms
the
follo
wing
op
eration
itlist
f
x


x






x
n
 
b

f
x

	f
x

	f
x

	


	f
x
n
b
A
straigh
tforw
ard
denition
in
ML
is
let
rec
itlist
f

fun
 !
b
	
b

ht
b
	
f
h
itlist
f
t
b
itlist

a
	
b
	
b
	
a
list
	
b
	
b

fun	
Quite
commonly

when
dening
a
recursiv
e
function
o
v
er
lists
all
one
is
doing
is
rep
eatedly
applying
some
op
erator
in
this
manner
By
using
itlist
with
the
appropriate
argumen
t
one
can
implemen
t
suc
h
functions
v
ery
easily
without
explicit
use
of
recursion
A
t
ypical
use
is
a
function
to
add
all
the
elemen
ts
of
a
list
of
n
um
b
ers
	


USEFUL
COMBINA
TORS
	
let
sum
l

itlist
fun
x
sum
	
x

sum
l


sum

int
list
	
int

fun	
sum
 !


int


sum
 !


int


sum
 !


int


Those
esp
ecially
k
een
on
brevit
y
migh
t
prefer
to
co
de
sum
as
let
sum
l

itlist
prefix

l


It
is
easy
to
mo
dify
this
function
to
form
a
pro
duct
rather
than
a
sum
let
prod
l

itlist
prefix

l

Man
y
useful
list
op
erations
can
b
e
implemen
ted
in
this
w
a
y

F
or
example
here
is
a
function
to
lter
out
only
those
elemen
ts
of
a
list
satisfying
a
predicate
let
filter
p
l

itlist
fun
x
s
	
if
p
x
then
xs
else
s
l
 !
filter

a
	
bool
	
a
list
	
a
list

fun	
filter
fun
x
	
x
mod




 	!


int
list

 

!
Here
are
functions
to
nd
whether
either
all
or
some
of
the
elemen
ts
of
a
list
satisfy
a
predicate
let
forall
p
l

itlist
fun
h
a
	
ph
"
a
l
true
forall

a
	
bool
	
a
list
	
bool

fun	
let
exists
p
l

itlist
fun
h
a
	
ph
or
a
l
false
exists

a
	
bool
	
a
list
	
bool

fun	
forall
fun
x
	
x


 !


bool

true
forall
fun
x
	
x


 !


bool

false
and
here
are
alternativ
e
v
ersions
of
old
fa
v
ourites
length
append
and
map
let
length
l

itlist
fun
x
s
	
s


l


length

a
list
	
int

fun	
let
append
l
m

itlist
fun
h
t
	
ht
l
m
append

a
list
	
a
list
	
a
list

fun	
let
map
f
l

itlist
fun
x
s
	
f
xs
l
 !
map

a
	
b
	
a
list
	
b
list

fun	
Some
of
these
functions
can
themselv
es
b
ecome
useful
com
binators
and
so
on
up
w
ards
F
or
example
if
w
e
are
in
terested
in
treating
lists
as
sets
ie
a
v
oiding
duplicate
elemen
ts
then
man
y
of
the
standard
set
op
erations
can
b
e
expressed
v
ery
simply
in
terms
of
the
com
binators
ab
o
v
e

	
CHAPTER

EFFECTIVE
ML
let
mem
x
l

exists
fun
y
	
y

x
l
mem

a
	
a
list
	
bool

fun	
let
insert
x
l

if
mem
x
l
then
l
else
xl
insert

a
	
a
list
	
a
list

fun	
let
union
l
l

itlist
insert
l
l
union

a
list
	
a
list
	
a
list

fun	
let
setify
l

union
l
 !
setify

a
list
	
a
list

fun	
let
Union
l

itlist
union
l
 !
Union

a
list
list
	
a
list

fun	
let
intersect
l
l

filter
fun
x
	
mem
x
l
l
intersect

a
list
	
a
list
	
a
list

fun	
let
subtract
l
l

filter
fun
x
	
not
mem
x
l
l
subtract

a
list
	
a
list
	
a
list

fun	
let
subset
l
l

forall
fun
t
	
mem
t
l
l
subset

a
list
	
a
list
	
bool

fun	
The
setify
function
is
supp
osed
to
turn
a
list
in
to
a
set
b
y
eliminating
an
y
duplicate
elemen
ts

W
riting
ecien
t
co
de
Here
w
e
accum
ulate
some
common
tric
ks
of
the
trade
whic
h
can
often
mak
e
ML
programs
substan
tially
more
ecien
t
In
order
to
justify
some
of
them
w
e
need
to
sk
etc
h
in
general
terms
ho
w
certain
constructs
are
executed
in
hardw
are

T
ail
recursion
and
accum
ulators
The
principal
con
trol
mec
hanism
in
functional
programs
is
recursion
If
w
e
are
in
terested
in
ecien
t
programs
it
b
eho
v
es
us
to
think
a
little
ab
out
ho
w
recursion
is
implemen
ted
on
con
v
en
tional
hardw
are
In
fact
there
is
not
in
this
resp
ect
at
least
m
uc
h
dierence
b
et
w
een
the
implemen
tation
of
ML
and
man
y
other
languages
with
dynamic
v
ariables
suc
h
as
C
If
functions
cannot
b
e
called
recursiv
ely

then
w
e
are
safe
in
storing
their
lo
cal
v
ariables
	whic
h
includes
the
v
alues
of
argumen
ts
at
a
xed
place
in
memory

this
is
what
F
OR
TRAN
do
es
Ho
w
ev
er
this
is
not
p
ossible
in
general
if
the
function
can
b
e
called
recursiv
ely

A
call
to
a
function
f
with
one
set
of
argumen
ts
ma
y
include
within
it
a
call
to
f
with
a
dieren
t
set
of
argumen
ts
The
old
ones
w
ould
b
e
o
v
erwritten
ev
en
if
the
outer
v
ersion
of
f
needs
to
refer
to
them
again
after
the
inner
call
has
nished
F
or
example
consider
the
factorial
function
y
et
again
let
rec
fact
n

if
n


then

else
n

factn




WRITING
EFFICIENT
CODE
	
A
call
to
fact

causes
another
call
to
fact

	and
b
ey
ond
but
when
this
call
is
nished
and
the
v
alue
of
fact

is
obtained
w
e
still
need
the
original
v
alue
of
n
namely

in
order
to
do
the
m
ultiplication
yielding
the
nal
result
What
normally
happ
ens
in
implemen
tations
is
that
eac
h
function
call
is
allo
cated
a
new
frame
on
a
stack
Ev
ery
new
function
call
mo
v
es
the
stac
k
p
oin
ter
further
do
wn

the
stac
k
creating
space
for
new
v
ariables
When
the
function
call
is
nished
the
stac
k
p
oin
ter
mo
v
es
up
and
so
the
un
w
an
ted
inner
v
ariables
are
discarded
automatically

A
diagram
ma
y
mak
e
this
clearer
SP

n


n


n


n


n


n


n


This
is
an
imagined
snapshot
of
the
stac
k
during
execution
of
the
innermost
recursiv
e
call
ie
fact

All
the
lo
cal
v
ariables
for
the
upp
er
stages
are
stac
k
ed
up
ab
o
v
e
with
eac
h
instance
of
the
function
ha
ving
its
o
wn
stac
k
frame
and
when
the
calls
are
nished
the
stac
k
p
oin
ter
SP
mo
v
es
bac
k
up
Therefore
our
implemen
tation
of
fact
requires
n
stac
k
frames
when
applied
to
argumen
t
n
By
con
trast
consider
the
follo
wing
implemen
tation
of
the
factorial
function
let
rec
tfact
x
n

if
n


then
x
else
tfact
x

n
n


tfact

int
	
int
	
int

fun	
let
fact
n

tfact

n
fact

int
	
int

fun	
fact



int


Although
tfact
is
also
recursiv
e
the
recursiv
e
call
is
the
whole
expression
it
do
es
not
o
ccur
as
a
prop
er
sub
expression
of
some
other
expression
in
v
olving
v
alues
of
v
ariables
Suc
h
a
call
is
said
to
b
e
a
tail
c
al
l
	b
ecause
it
is
the
v
ery
last
thing
the
calling
function
do
es
and
a
function
where
all
recursiv
e
calls
are
tail
calls
is
said
to
b
e
tail
r
e
cursive

Despite
the
name
stac
ks
con
v
en
tionally
gro
w
do
wn
w
ards

	
CHAPTER

EFFECTIVE
ML
What
is
signican
t
ab
out
tail
calls
When
making
a
recursiv
e
call
to
tfact
there
is
no
need
to
preserv
e
the
old
v
alues
of
the
lo
cal
v
ariables
Exactly
the
same
xed
area
of
storage
can
b
e
used
This
of
course
dep
ends
on
the
compilers
b
eing
in
telligen
t
enough
to
recognize
the
fact
but
most
compilers
including
CAML
Ligh
t
are
Consequen
tly

reco
ding
a
function
so
that
the
recursiv
e
core
of
it
is
tail
recursiv
e
can
dramatically
cut
do
wn
the
use
of
storage
F
or
functions
lik
e
the
factorial
it
is
hardly
lik
ely
that
they
will
b
e
called
with
large
enough
v
alues
of
n
to
mak
e
the
stac
k
o
v
ero
w
Ho
w
ev
er
the
naiv
e
implemen
tations
of
man
y
list
functions
can
cause
suc
h
an
eect
when
the
argumen
t
lists
are
long
The
additional
argumen
t
x
of
the
tfact
function
is
called
an
ac
cumulator
b
ecause
it
accum
ulates
the
result
as
the
recursiv
e
calls
rac
k
up
and
is
then
returned
at
the
end
W
orking
in
this
w
a
y

rather
than
mo
difying
the
return
v
alue
on
the
w
a
y
bac
k
up
is
a
common
w
a
y
of
making
functions
tail
recursiv
e
W
e
ha
v
e
remark
ed
that
a
xed
area
of
storage
can
b
e
used
for
the
argumen
ts
to
a
tail
recursiv
e
function
On
this
view
one
can
lo
ok
at
a
tail
recursiv
e
function
as
a
thinlyv
eiled
imp
erativ
e
implemen
tation
There
is
an
ob
vious
parallel
with
our
C
implemen
tation
of
the
factorial
as
an
iterativ
e
function
int
factint
n

int
x


while
n



x

x

n
n

n



return
x

The
initialization
x


corresp
onds
to
our
setting
of
x
to

b
y
an
outer
wrapp
er
function
fact
The
cen
tral
while
lo
op
corresp
onds
to
the
recursiv
e
calls
the
only
dierence
b
eing
that
the
argumen
ts
to
the
tail
recursiv
e
function
mak
e
explicit
that
part
of
the
state
w
e
are
in
terested
in
assigning
to
Rather
than
assigning
and
lo
oping
w
e
mak
e
a
recursiv
e
call
with
the
v
ariables
up
dated
Using
similar
tric
ks
and
making
the
state
explicit
one
can
easily
write
essen
tially
imp
erativ
e
co
de
in
an
ostensibly
functional
st
yle
with
the
kno
wledge
that
under
standard
compiler
optimizations
the
eect
inside
the
mac
hine
will
in
fact
b
e
m
uc
h
the
same

Minimizing
consing
W
e
ha
v
e
already
considered
the
use
of
stac
k
space
But
v
arious
constructs
in
functional
programs
use
another
kind
of
store
usually
allo
cated
from
an
area
called
the
he
ap
Whereas
the
stac
k
gro
ws
and
shrinks
in
a
sequen
tial
manner
based
on
the
o
w
of
con
trol
b
et
w
een
functions
other
storage
used
b
y
the
ML


WRITING
EFFICIENT
CODE
		
system
cannot
b
e
reclaimed
in
suc
h
a
simple
w
a
y

Instead
the
run
time
system
o
ccasionally
needs
to
c
hec
k
whic
h
bits
of
allo
cated
memory
arent
b
eing
used
an
y
more
and
reclaim
them
for
future
applications
a
pro
cess
kno
wn
as
garb
age
c
ol
le
ction
A
particularly
imp
ortan
t
example
is
the
space
used
b
y
constructors
for
recursiv
e
t
yp
es
eg

F
or
example
when
the
follo
wing
fragmen
t
is
executed
let
l

 !
in
tl
l
a
new
blo
c
k
of
memory

called
a
cons
cell
is
allo
cated
to
store
the
instance
of
the

constructor
T
ypically
this
migh
t
b
e
three
w
ords
of
storage
one
b
eing
an
iden
tier
for
the
constructor
and
the
other
t
w
o
b
eing
p
oin
ters
to
the
head
and
tail
of
the
list
No
w
in
general
it
is
dicult
to
decide
when
this
memory
can
b
e
reclaimed
In
the
ab
o
v
e
example
w
e
immediately
select
the
tail
of
the
list
so
it
is
clear
that
the
cons
cell
can
b
e
recycled
immediately

But
in
general
this
cant
b
e
decided
b
y
lo
oking
at
the
program
since
l
migh
t
b
e
passed
to
v
arious
functions
that
ma
y
or
ma
y
not
just
lo
ok
at
the
comp
onen
ts
of
the
list
Instead
one
needs
to
analyze
the
memory
usage
dynamically
and
p
erform
garbage
collection
of
what
is
no
longer
needed
Otherwise
one
w
ould
ev
en
tually
run
out
of
storage
ev
en
when
only
a
small
amoun
t
is
ev
er
needed
sim
ultaneously

Implemen
tors
of
functional
languages
w
ork
hard
on
making
garbage
collection
ecien
t
Some
claim
that
automatic
memory
allo
cation
and
garbage
collection
often
w
orks
out
faster
than
t
ypical
uses
of
explicit
memory
allo
cation
in
languages
lik
e
C
	malloc
etc
While
w
e
w
ouldnt
go
that
far
it
is
certainly
v
ery
con
v
enien
t
that
memory
allo
cation
is
alw
a
ys
done
automatically

It
a
v
oids
a
lot
of
tedious
and
notoriously
errorprone
parts
of
programming
Man
y
constructs
b
elo
v
ed
of
functional
programmers
use
storage
that
needs
to
b
e
reclaimed
b
y
garbage
collection
While
w
orrying
to
o
m
uc
h
ab
out
this
w
ould
cripple
the
st
yle
of
functional
programs
there
are
some
simple
measures
that
can
b
e
tak
en
to
a
v
oid
gratuitous
consing
	creation
of
cons
cells
One
v
ery
simple
rule
of
th
um
b
is
to
a
v
oid
using
append
if
p
ossible
As
can
b
e
seen
b
y
considering
the
w
a
y
the
recursiv
e
calls
unroll
according
to
the
denition
let
rec
append
l
l

match
l
with
 !
	
l

ht
	
happend
t
l
this
t
ypically
generates
n
cons
cells
where
n
is
the
length
of
the
rst
argumen
t
list
There
are
often
w
a
ys
of
a
v
oiding
app
ending
suc
h
as
adding
extra
accum
ulator
argumen
ts
to
functions
that
can
b
e
augmen
ted
b
y
direct
use
of
consing
A
striking
example
is
the
list
rev
ersal
function
whic
h
w
e
co
ded
earlier
as
let
rec
rev

fun
 !
	
 !

ht
	
append
rev
t
 h!


CHAPTER

EFFECTIVE
ML
This
t
ypically
generates
ab
out
n


cons
cells
where
n
is
the
length
of
the
list
The
follo
wing
alternativ
e
using
an
accum
ulator
only
generates
n
of
them
let
rev

let
rec
reverse
acc

fun
 !
	
acc

ht
	
reverse
hacc
t
in
reverse
 !
Moreo
v
er
the
recursiv
e
core
reverse
is
tail
recursiv
e
so
w
e
also
sa
v
e
stac
k
space
and
win
t
wice
o
v
er
F
or
another
t
ypical
situation
where
w
e
can
a
v
oid
app
ending
b
y
judicious
use
of
accum
ulators
consider
the
problem
of
returning
the
fringe
of
a
binary
tree
ie
a
list
of
the
lea
v
es
in
lefttorigh
t
order
If
w
e
dene
the
t
yp
e
of
binary
trees
as
type
btree

Leaf
of
string

Branch
of
btree

btree
then
a
simple
co
ding
is
the
follo
wing
let
rec
fringe

fun
Leaf
s
	
 s!

Branchlr
	
append
fringe
l
fringe
r
Ho
w
ev
er
the
follo
wing
more
rened
v
ersion
p
erforms
few
er
conses
let
fringe

let
rec
fr
t
acc

match
t
with
Leaf
s
	
sacc

Branchlr
	
fr
l
fr
r
acc
in
fun
t
	
fr
t
 !
Note
that
w
e
ha
v
e
written
the
accum
ulator
as
the
second
argumen
t
so
that
the
recursiv
e
call
has
a
more
natural
lefttorigh
t
reading
Here
is
a
simple
ex
ample
of
ho
w
either
v
ersion
of
fringe
ma
y
b
e
used
fringe
BranchBranchLeaf
aLeaf
b
BranchLeaf
cLeaf
d


string
list

 a
b
c
d!
The
rst
v
ersion
creates

cons
cells
the
second
only

On
larger
trees
the
eect
can
b
e
more
dramatic
Another
situation
where
gratuitous
consing
can
crop
up
is
in
pattern
matc
hing
F
or
example
consider
the
co
de
fragmen
t
fun
 !
	
 !

ht
	
if
h


then
t
else
ht


WRITING
EFFICIENT
CODE

The
else
arm
creates
a
cons
cell
ev
en
though
what
it
constructs
w
as
in
fact
the
argumen
t
to
the
function
That
is
it
is
taking
the
argumen
t
apart
and
then
rebuilding
it
One
simple
w
a
y
of
a
v
oiding
this
is
to
reco
de
the
function
as
fun
l
	
match
l
with
 !
	
 !

ht
	
if
h


then
t
else
l
Ho
w
ev
er
ML
oers
a
more
exible
alternativ
e
using
the
as
k
eyw
ord
a
name
ma
y
b
e
iden
tied
with
certain
comp
onen
ts
of
the
pattern
so
that
it
nev
er
needs
to
b
e
rebuilt
F
or
example
fun
 !
	
 !

ht
as
l
	
if
h


then
t
else
l

F
orcing
ev
aluation
W
e
ha
v
e
emphasized
that
since
ML
do
es
not
ev
aluate
underneath
lam
b
das
one
can
use
lam
b
das
to
dela
y
ev
aluation
W
e
will
see
some
in
teresting
examples
later
Con
v
ersely

ho
w
ev
er
it
can
happ
en
that
one
w
an
ts
to
force
ev
aluation
of
expressions
that
are
hidden
underneath
lam
b
das
F
or
example
recall
the
tail
recursiv
e
factorial
ab
o
v
e
let
rec
tfact
x
n

if
n


then
x
else
tfact
x

n
n


let
fact
n

tfact

n
Since
w
e
nev
er
really
w
an
t
to
use
tfact
directly

it
seems
a
pit
y
to
bind
it
to
a
name
Instead
w
e
can
mak
e
it
lo
cal
to
the
factorial
function
let
fact
n

let
rec
tfact
x
n

if
n


then
x
else
tfact
x

n
n


in
tfact

n
This
ho
w
ev
er
has
the
defect
that
the
lo
cal
recursiv
e
denition
is
only
ev
al
uated
after
fact
receiv
es
its
argumen
t
since
b
efore
that
it
is
hidden
under
a
lam
b
da
Moreo
v
er
it
is
then
reev
aluated
eac
h
time
fact
is
called
W
e
can
c
hange
this
as
follo
ws
let
fact

let
rec
tfact
x
n

if
n


then
x
else
tfact
x

n
n


in
tfact



CHAPTER

EFFECTIVE
ML
No
w
the
lo
cal
binding
is
only
ev
aluated
once
at
the
p
oin
t
of
declaration
of
fact
According
to
our
tests
the
second
v
ersion
of
fact
is
ab
out
*
faster
when
called
on
the
argumen
t

The
additional
ev
aluation
do
esnt
amoun
t
to
m
uc
h
in
this
case
more
or
less
just
unra
v
elling
a
recursiv
e
denition
y
et
the
sp
eedup
is
signican
t
In
instances
where
there
is
a
lot
of
computation
in
v
olv
ed
in
ev
aluating
the
lo
cal
binding
the
dierence
can
b
e
sp
ectacular
In
fact
there
is
a
sophisticated
researc
h
eld
of
partial
ev
aluation
dev
oted
to
p
erforming
op
timizations
lik
e
this
and
m
uc
h
more
sophisticated
ones
b
esides
automatically

In
a
sense
it
is
a
generalization
of
standard
compiler
optimizations
for
ordinary
languages
suc
h
as
constan
t
folding
In
pro
duction
ML
systems
ho
w
ev
er
it
is
normally
the
resp
onsibilit
y
of
the
user
to
force
it
as
here
W
e
migh
t
note
in
passing
that
if
functions
are
implemen
ted
b
y
plugging
together
com
binators
with
few
er
explicit
lam
b
das
there
is
more
c
hance
that
as
m
uc
h
of
the
expression
as
p
ossible
will
b
e
ev
aluated
at
declaration
time
T
o
tak
e
a
trivial
example
f

g
will
p
erform
an
y
ev
aluation
of
f
and
g
that
ma
y
b
e
p
ossible
whereas
x
f
	g
x
will
p
erform
none
at
all
un
til
it
receiv
es
its
argumen
t
On
the
other
side
of
the
coin
when
w
e
actually
want
to
dela
y
ev
aluation
w
e
really
need
lam
b
das
so
a
purely
com
binatory
v
ersion
is
imp
ossible

Imp
erativ
e
features
ML
has
a
fairly
full
complemen
t
of
imp
erativ
e
features
W
e
will
not
sp
end
m
uc
h
time
on
the
imp
erativ
e
st
yle
of
programming
since
that
is
not
the
fo
cus
of
this
course
and
w
e
assume
readers
already
ha
v
e
sucien
t
exp
erience
Therefore
w
e
treat
these
topics
fairly
quic
kly
with
few
illustrativ
e
examples
Ho
w
ev
er
some
imp
erativ
e
features
are
used
in
later
examples
and
some
kno
wledge
of
what
is
a
v
ailable
will
stand
the
reader
in
go
o
d
stead
for
writing
practical
ML
co
de

Exceptions
W
e
ha
v
e
seen
on
o
ccasion
that
certain
ev
aluations
fail
eg
through
a
failure
in
pattern
matc
hing
There
are
other
reasons
for
failure
eg
attempts
to
divide
b
y
zero




Uncaught
exception
Divisionbyzero
In
all
these
cases
the
compiler
complains
ab
out
an
uncaugh
t
exception
An
exception
is
a
kind
of
error
indication
but
they
need
not
alw
a
ys
b
e
propagated
to
the
top
lev
el
There
is
a
t
yp
e
exn
of
exc
eptions
whic
h
is
eectiv
ely
a
recursiv
e
t
yp
e
though
it
is
usually
recursiv
e
only
v
acuously

Unlik
e
with
ordinary
t
yp
es
one
can
add
new
constructors
for
the
t
yp
e
exn
at
an
y
p
oin
t
in
the
program
via
an
exception
declaration
eg


IMPERA
TIVE
FEA
TURES

exception
Died
Exception
Died
defined
exception
Failed
of
string
Exception
Failed
defined
While
certain
builtin
op
erations
generate
	one
usually
sa
ys
r
aise
exceptions
this
can
also
b
e
done
explicitly
using
the
raise
construct
eg
raise
Failed
I
dont
know
why
Uncaught
exception
Failed
I
dont
know
why
F
or
example
w
e
migh
t
in
v
en
t
our
o
wn
exception
to
co
v
er
the
case
of
taking
the
head
of
an
empt
y
list
exception
Headofempty
Exception
Headofempty
defined
let
hd

fun
 !
	
raise
Headofempty

ht
	
h
hd

a
list
	
a

fun	
hd
 !
Uncaught
exception
Headofempty
Normally
exceptions
propagate
out
to
the
top
but
they
can
b
e
caugh
t
inside
an
outer
expression
b
y
using
try
with
follo
w
ed
b
y
a
series
of
patterns
to
matc
h
exceptions
eg
let
headstring
sl

try
hd
sl
with
Headofempty
	


Failed
s
	
Failure
because
s
headstring

string
list
	
string

fun	
headstring
 hi
there!


string

hi
headstring
 !


string


It
is
a
matter
of
opinion
whether
exceptions
are
really
an
imp
erativ
e
feature
On
one
view
functions
just
return
elemen
ts
of
a
disjoin
t
sum
consisting
of
their
visible
return
t
yp
e
and
the
t
yp
e
of
exceptions
and
all
op
erations
implicitly
pass
bac
k
exceptions
Another
view
is
that
exceptions
are
a
highly
nonlo
cal
con
trol
o
w
p
erv
ersion
analogous
to
goto

Whatev
er
the
seman
tic
view
one
tak
es
exceptions
can
often
b
e
quite
useful

P
erhaps
more
precisely

to
Cs
setjmp
and
longjmp


CHAPTER

EFFECTIVE
ML

References
and
arra
ys
ML
do
es
ha
v
e
real
assignable
v
ariables
and
expressions
can
as
a
sideeect
mo
dify
the
v
alues
of
these
v
ariables
They
are
explicitly
accessed
via
r
efer
enc
es
	p
oin
ters
in
C
parlance
and
the
references
themselv
es
b
eha
v
e
more
lik
e
ordinary
ML
v
alues
Actually
this
approac
h
is
quite
common
in
C
to
o
F
or
example
if
one
w
an
ts
socalled
v
ariable
parameters
in
C
where
c
hanges
to
the
lo
cal
v
ariables
propagate
outside
the
only
w
a
y
to
do
it
is
to
pass
a
p
oin
ter
so
that
the
function
can
dereference
it
Similar
tec
hniques
are
often
used
where
the
function
is
to
pass
bac
k
comp
osite
data
In
ML
one
sets
up
a
new
assignable
memory
cell
with
the
initial
con
ten
ts
x
b
y
writing
ref
x
	Initialization
is
compulsory

This
expression
yields
a
reference
	p
oin
ter
to
the
cell
Subsequen
t
access
to
the
con
ten
ts
of
the
cell
requires
an
explicit
dereference
using
the
$
op
erator
similar
to
unary

in
C
The
cell
is
assigned
to
using
a
con
v
en
tionallo
oking
assignmen
t
statemen
t
F
or
example
let
x

ref

x

int
ref

ref

#x


int


x




unit


#x


int


x

#x

#x


unit


x


int
ref

ref

#x


int


Note
that
in
most
resp
ects
ref
b
eha
v
es
lik
e
a
t
yp
e
constructor
so
one
can
patternmatc
h
against
it
Th
us
one
could
actually
dene
an
indirection
op
erator
lik
e
$
let
contentsof
ref
x

x
contentsof

a
ref
	
a

fun	
contentsof
x


int


As
w
ell
as
b
eing
m
utable
references
are
sometimes
useful
for
creating
ex
plicitly
shared
data
structures
One
can
easily
create
graph
structures
where
n
umerous
no
des
con
tain
a
p
oin
ter
to
some
single
subgraph
Apart
from
single
cells
one
can
also
use
arra
ys
in
ML
In
CAML
these
are
called
vectors
An
arra
y
of
elemen
ts
of
t
yp
e

has
t
yp
e

v
ect
A
fresh
v
ector
of
size
n
with
eac
h
elemen
t
initialized
to
x

once
again
the
initialization
is
compulsory

is
created
using
the
follo
wing
call


IMPERA
TIVE
FEA
TURES

makevect
n
x
One
can
then
read
elemen
t
m
of
a
v
ector
v
using
vectitem
v
m
and
write
v
alue
y
to
elemen
t
m
of
v
using
vectassign
v
m
y
These
op
erations
corresp
ond
to
the
expressions
vm
and
vm

y
in
C
The
elemen
ts
of
an
arra
y
are
n
um
b
ered
from
zero
F
or
example
let
v

makevect



v

int
vect

 








!
vectitem
v



int


vectassign
v





unit


v


int
vect

 








!
vectitem
v



int


All
reading
and
writing
is
constrained
b
y
b
ounds
c
hec
king
eg
vectitem
v

Uncaught
exception
Invalidargument
vectitem

Sequencing
There
is
no
need
for
an
explicit
sequencing
op
eration
in
ML
since
the
normal
rules
of
ev
aluation
allo
w
one
to
imp
ose
an
order
F
or
example
one
can
do
let


x

#x


in
let


x

#x


in
let


x

#x


in
let


x

#x


in

and
the
expressions
are
ev
aluated
in
the
exp
ected
order
Here
w
e
use
a
sp
ecial
pattern
whic
h
thro
ws
a
w
a
y
the
v
alue
but
w
e
could
use
a
dumm
y
v
ariable
name
instead
Nev
ertheless
it
is
more
attractiv
e
to
use
the
con
v
en
tional
notation
for
sequencing
and
this
is
p
ossible
in
ML
b
y
using
a
single
semicolon
x

#x


x

#x


x

#x


x

#x




CHAPTER

EFFECTIVE
ML

In
teraction
with
the
t
yp
e
system
While
p
olymorphism
w
orks
v
ery
w
ell
for
the
pure
functional
core
of
ML
it
has
unfortunate
in
teractions
with
some
imp
erativ
e
features
F
or
example
consider
the
follo
wing
let
l

ref
 !
Then
l
w
ould
seem
to
ha
v
e
p
olymorphic
t
yp
e

l
ist
r
ef

In
accordance
with
the
usual
rules
of
letp
olymorphism
w
e
should
b
e
able
to
use
it
with
t
w
o
dieren
t
t
yp
es
eg
rst
l

 !
and
then
hd#l

true
But
this
isnt
reasonable
b
ecause
w
e
w
ould
actually
b
e
writing
something
as
an
ob
ject
of
t
yp
e
int
then
reading
it
as
an
ob
ject
of
t
yp
e
bool
Consequen
tly

some
restriction
on
the
usual
rule
of
let
p
olymorphism
is
called
for
where
ref
erences
are
concerned
There
ha
v
e
b
een
man
y
attempts
to
arriv
e
at
a
sound
but
con
v
enien
t
restriction
of
the
ML
t
yp
e
system
some
of
them
v
ery
compli
cated
Recen
tly

dieren
t
v
ersions
of
ML
seem
to
b
e
con
v
erging
on
a
relativ
ely
simple
metho
d
called
the
value
r
estriction
due
to
W
righ
t
			
and
CAML
implemen
ts
this
restriction
with
a
t
wist
regarding
toplev
el
bindings
Indeed
the
ab
o
v
e
sequence
fails
But
the
in
termediate
b
eha
viour
is
in
teresting
If
w
e
lo
ok
at
the
rst
line
w
e
see
let
l

ref
 !
l

a
list
ref

ref
 !
The
underscore
on
the
t
yp
e
v
ariable
indicates
that
l
is
not
p
olymorphic
in
the
usual
sense
rather
it
has
a
single
xed
t
yp
e
although
that
t
yp
e
is
as
y
et
undetermined
The
second
line
w
orks
ne
l

 !


unit


but
if
w
e
no
w
lo
ok
at
the
t
yp
e
of
l
w
e
see
that
l


int
list
ref

ref
 !
The
pseudop
olymorphic
t
yp
e
has
no
w
b
een
xed
Gran
ted
this
it
is
clear
that
the
last
line
m
ust
fail


IMPERA
TIVE
FEA
TURES

hd#l

true
Toplevel
input
	hd#l

true
	

This
expression
has
type
bool
but
is
used
with
type
int
So
far
this
seems
quite
reasonable
but
w
e
ha
v
ent
y
et
explained
wh
y
the
same
underscored
t
yp
e
v
ariables
o
o
cur
in
apparen
tly
quite
inno
cen
t
purely
functional
expressions
and
wh
y

moreo
v
er
they
often
disapp
ear
on
etaexpansion
eg
let
I
x

x
I

a
	
a

fun	
I
o
I
it

a
	
a

fun	
let
I

I
o
I
in
fun
x
	
I
x


a
	
a

fun	
fun
x
	
I
o
I
x
it

a
	
a

fun	
Other
tec
hniques
for
p
olymorphic
references
often
rely
on
enco
ding
in
the
t
yp
es
the
fact
that
an
expression
ma
y
in
v
olv
e
references
This
seems
natural
but
it
can
lead
to
the
t
yp
es
of
functions
b
ecoming
cluttered
with
this
sp
ecial
information
It
is
unattractiv
e
that
the
particular
implemen
tation
of
the
function
eg
imp
erativ
e
or
functional
should
b
e
reected
in
its
t
yp
e
W
righ
ts
solution
on
the
other
hand
uses
just
the
basic
syn
tax
of
the
ex
pression
b
eing
letb
ound
insisting
that
it
is
a
socalled
value
b
efore
generalizing
the
t
yp
e
What
is
really
w
an
ted
is
kno
wledge
of
whether
the
expression
ma
y
cause
sideeects
when
ev
aluated
Ho
w
ev
er
since
this
is
undecidable
in
general
the
simple
syn
tactic
criterion
of
its
b
eing
or
not
b
eing
a
v
alue
is
used
Roughly
sp
eaking
an
expression
is
a
v
alue
if
it
admits
no
further
ev
aluation
according
to
the
ML
rules

this
is
wh
y
an
expression
can
often
b
e
made
in
to
a
v
alue
b
y
p
erforming
a
rev
erse
eta
con
v
ersion
Unfortunately
this
w
orks
against
the
tec
hniques
for
forcing
ev
aluation
Exercises

Dene
the
C
com
binator
as
let
C
f
x
y

f
y
x
What
do
es
the
follo
wing
function
do


CHAPTER

EFFECTIVE
ML
fun
f
l
l
	
itlist
union
o
C
map
l
o
f
l
 !

What
do
es
this
function
do
W
rite
a
more
ecien
t
v
ersion
let
rec
upto
n

if
n


then
 !
else
append
upto
n
 n!

Dene
a
function
to
calculate
Fib
onacci
n
um
b
ers
as
follo
ws
let
rec
fib

fun

	



	


n
	
fibn



fibn


Wh
y
is
this
v
ery
inecien
t
W
rite
a
similar
but
b
etter
v
ersion

	
Can
y
ou
think
of
an
y
uses
for
this
exception
or
similar
recursiv
e
ones
exception
Recurse
of
exn

Implemen
t
a
simple
v
ersion
of
quic
ksort
using
arra
ys
The
arra
y
is
rst
partitioned
ab
out
some
piv
ot
then
t
w
o
recursiv
e
calls
sort
the
left
and
righ
t
p
ortions
Whic
h
recursiv
e
calls
are
tail
calls
What
is
the
w
orstcase
space
usage
Ho
w
can
this
b
e
impro
v
ed
dramatically
b
y
a
simple
c
hange

Pro
v
e
that
the
t
w
o
v
ersions
of
rev
that
w
e
ha
v
e
quoted
inecien
t
and
ecien
t
alw
a
ys
giv
e
the
same
answ
er

Chapter
	
Examples
As
w
e
ha
v
e
said
ML
w
as
originally
designed
as
a
metalanguage
for
a
computer
theorem
pro
v
er
Ho
w
ev
er
it
is
suitable
for
plen
t
y
of
other
applications
mostly
from
the
same
general
eld
of
sym
b
olic
computation
In
this
c
hapter
w
e
will
giv
e
some
examples
of
c
haracteristic
uses
of
ML
It
is
not
necessary
that
the
reader
should
understand
ev
ery
detail
of
the
particular
examples
eg
the
analyses
of
real
n
um
b
er
appro
ximations
giv
en
b
elo
w
Ho
w
ev
er
it
is
w
orth
trying
out
these
programs
and
similar
examples
for
y
ourself
and
doing
some
of
the
exercises
There
is
no
b
etter
w
a
y
of
getting
a
feel
for
ho
w
ML
is
actually
used
	
Sym
b
olic
dieren
tiation
The
phrase
sym
b
olic
computation
is
a
bit
v
ague
but
roughly
sp
eaking
it
co
v
ers
applications
where
manipulation
of
mathematical
expr
essions
in
general
con
taining
v
ariables
is
emphasized
at
the
exp
ense
of
actual
n
umerical
calculation
There
are
sev
eral
successful
computer
algebra
systems
suc
h
as
Axiom
Maple
and
Mathematica
whic
h
can
do
certain
sym
b
olic
op
erations
that
are
useful
in
mathematics
eg
factorizing
p
olynomials
and
dieren
tiating
and
in
tegrating
ex
pressions
	They
are
also
capable
of
purely
n
umerical
w
ork
W
e
will
illustrate
ho
w
this
sort
of
application
can
b
e
tac
kled
using
ML
W
e
use
sym
b
olic
dieren
tiation
as
our
example
b
ecause
there
is
an
algorithm
to
do
it
whic
h
is
fairly
simple
and
w
ell
kno
wn
The
reader
is
probably
familiar
with
certain
deriv
ativ
es
of
basic
op
erations
eg
d
dx
sin	x

cos	x
as
w
ell
as
results
suc
h
as
the
Chain
Rule
and
Pro
duct
Rule
for
calculating
the
deriv
ativ
es
of
comp
osite
expressions
in
terms
of
the
deriv
ativ
es
of
the
comp
onen
ts
Just
as
one
can
use
these
systematically
in
order
to
nd
deriv
ativ
es
it
is
p
ossible
to
program
a
fairly
straigh
tforw
ard
algorithm
to
do
it
in
ML
	


CHAPTER
	
EXAMPLES
	
First
order
terms
W
e
will
allo
w
mathematical
expressions
in
a
fairly
general
form
They
ma
y
b
e
built
up
from
v
ariables
and
constan
ts
b
y
the
application
of
op
erators
These
op
erators
ma
y
b
e
unary

binary

ternary

or
in
general
nary

W
e
represen
t
this
using
the
follo
wing
recursiv
e
datat
yp
e
type
term

Var
of
string

Const
of
string

Fn
of
string

term
list
Type
term
defined
F
or
example
the
expression
sin	x
"
y
cos	x

exp	y


l
n	
"
x
is
represen
ted
b
y
Fn Fn Fnsin
 Fn

 Va
r
x
Var
y!!
Fncos Fn Var
x
Fnexp Var
y!!!!
Fnln Fn Const

Var
x!!!
	
Prin
ting
Reading
and
writing
expressions
in
their
ra
w
form
is
rather
unpleasan
t
This
is
a
general
problem
in
all
sym
b
olic
computation
systems
and
t
ypically
the
systems
in
terface
con
tains
a
p
arser
and
pr
ettyprinter
to
allo
w
resp
ectiv
ely
input
and
out
put
in
a
readable
form
A
detailed
discussion
of
parsing
is
p
ostp
oned
since
it
is
w
orth
a
section
of
its
o
wn
but
w
e
will
no
w
write
a
v
ery
simple
prin
ter
for
expressions
so
that
at
least
w
e
can
see
whats
going
on
W
e
w
an
t
the
prin
ter
to
supp
ort
ordinary
h
uman
con
v
en
tions
ie

V
ariables
and
constan
ts
are
just
written
as
their
names

Ordinary
nary
functions
applied
to
argumen
ts
are
written
b
y
juxtap
osing
the
function
and
a
brac
k
eted
list
of
argumen
ts
eg
f
	x






x
n


Inx
binary
functions
lik
e
"
are
written
in
b
et
w
een
their
argumen
ts

Brac
k
ets
are
used
where
necessary
for
disam
biguation

Inx
op
erators
ha
v
e
a
notion
of
precedence
to
reduce
the
need
for
brac
k
ets
First
w
e
declare
a
list
of
inxes
whic
h
is
a
list
of
pairs
eac
h
op
erator
name
together
with
its
precedence
let
infixes

 






!

	
SYMBOLIC
DIFFERENTIA
TION

It
is
common
to
use
lists
in
this
w
a
y
to
represen
t
nite
partial
functions
since
it
allo
ws
more
exibilit
y

They
are
commonly
called
asso
ciation
lists
and
are
v
ery
common
in
functional
programming

In
order
to
con
v
ert
the
list
in
to
a
partial
function
w
e
use
assoc
let
rec
assoc
a
xyrest

if
a

x
then
y
else
assoc
a
rest
Toplevel
input
	let
rec
assoc
a
xyrest

if
a

x
then
y
else
assoc
a
rest
	










Warning
this
matching
is
not
exhaustive
assoc

a
	
a

b
list
	
b

fun	
The
compiler
w
arns
us
that
if
the
appropriate
data
is
not
found
in
the
list
the
function
will
fail
No
w
w
e
can
dene
a
function
to
get
the
inx
precedence
of
a
function
let
getprecedence
s

assoc
s
infixes
getprecedence

string
	
int

fun	
getprecedence



int


getprecedence



int


getprecedence
$
Uncaught
exception
Matchfailure




Note
that
if
w
e
ev
er
c
hange
this
list
of
inxes
then
an
y
functions
suc
h
as
get
precedence
that
use
it
need
to
b
e
redeclared
This
is
the
main
reason
wh
y
man
y
LISP
programmers
prefer
dynamic
binding
Ho
w
ev
er
w
e
can
mak
e
the
set
of
inxes
arbitrarily
extensible
b
y
making
it
in
to
a
reference
and
dereferencing
it
on
eac
h
application
let
infixes

ref
 






!
infixes

string

int
list
ref

ref
 










!
let
getprecedence
s

assoc
s
#infixes
getprecedence

string
	
int

fun	
getprecedence

Uncaught
exception
Matchfailure




infixes


#infixes


unit


getprecedence



int



F
or
more
hea
vyw
eigh
t
applications
some
alternativ
e
suc
h
as
hash
tables
is
m
uc
h
b
etter
but
for
simple
applications
where
the
lists
dont
get
to
o
long
this
kind
of
linear
list
is
simple
and
adequate


CHAPTER
	
EXAMPLES
Note
that
b
y
the
ML
ev
aluation
rules
the
dereferencing
is
only
applied
after
the
function
get
precedence
receiv
es
its
argumen
t
and
hence
results
in
the
set
of
inxes
at
that
time
W
e
can
also
dene
a
function
to
decide
whether
a
function
has
an
y
data
asso
ciated
with
it
One
w
a
y
is
simply
to
try
the
function
get
precedence
and
see
if
it
w
orks
let
isinfix
s

try
getprecedence
s
true
with

	
false
An
alternativ
e
is
to
use
a
general
function
can
that
nds
out
whether
another
function
succeeds
let
can
f
x

try
f
x
true
with

	
false
can

a
	
b
	
a
	
bool

fun	
let
isinfix

can
getprecedence
isinfix

string
	
bool

fun	
W
e
will
use
the
follo
wing
functions
that
w
e
ha
v
e
already
considered
let
hdht

h
let
tlht

t
let
rec
length
l

if
l

 !
then

else


lengthtl
l
Without
further
ado
here
is
a
function
to
con
v
ert
a
term
in
to
a
string
let
rec
stringofterm
prec

fun
Var
s
	
s

Const
c
	
c

Fnfargs
	
if
length
args


"
isinfix
f
then
let
prec

getprecedence
f
in
let
s

stringofterm
prec
hd
args
and
s

stringofterm
prec
hdtl
args
in
let
ss

s
f
s
in
if
prec

prec
then
ss
else
ss
else
fstringofterms
args
and
stringofterms
t

match
t
with
 !
	


 t!
	
stringofterm

t

ht
	
stringofterm

hstringofterms
t
The
rst
argumen
t
prec
indicates
the
precedence
lev
el
of
the
op
erator
of
whic
h
the
curren
tly
considered
expression
is
an
immediate
subterm
No
w
if
the
curren
t
expression
has
an
inx
binary
op
erator
at
the
top
lev
el
paren
theses
are
needed

	
SYMBOLIC
DIFFERENTIA
TION

if
the
precedence
of
this
op
erator
is
lo
w
er
eg
if
w
e
are
considering
the
righ
t
hand
sub
expression
of
x

	y
"
z

Actually
w
e
use
paren
theses
ev
en
when
they
are
equal
in
order
to
mak
e
groupings
clear
In
the
case
of
asso
ciativ
e
op
erators
lik
e
"
this
do
esnt
matter
but
w
e
m
ust
distinguish
x

	y

z

and
	x

y


z

	A
more
sophisticated
sc
heme
w
ould
giv
e
eac
h
op
erator
an
asso
ciativit
y

The
second
m
utually
recursiv
e
function
string
of
terms
is
used
to
prin
t
a
comma
separated
list
of
terms
as
they
o
ccur
for
noninx
function
applications
of
the
form
f
	t






t
n

Let
us
see
this
in
action
let
t

Fn Fn Fnsin
 F
n
 
Var
x
Var
y!!
Fncos Fn Var
x
Fnexp Var
y!!!!
Fnln Fn Const

Var
x!!!
t

term

Fn

 Fn

 Fn
sin
 Fn

 Var
x
Var
y!!
Fn
cos
 Fn

 Var
x
Fn
exp
 Var
y!!!!
Fn
ln
 Fn

 Const

Var
x!!!
stringofterm

t


string

sinx

y

cosx

expy

ln

x
In
fact
w
e
dont
need
to
con
v
ert
a
term
to
a
string
ourselv
es
CAML
Ligh
t
allo
ws
us
to
set
up
our
o
wn
prin
ter
so
that
it
is
used
to
prin
t
an
ything
of
t
yp
e
term
in
the
standard
readev
alprin
t
lo
op
This
needs
a
few
sp
ecial
commands
to
ensure
that
w
e
in
teract
prop
erly
with
the
toplev
el
lo
op
open
format
let
printterm
s

openhvbox


printstring%stringo
fte
rm

s%
closebox
printterm

term
	
unit

fun	
installprinter
printterm


unit


No
w
compare
the
eect
let
t

Fn Fn Fnsin
 Fn

 Va
r
x
Var
y!!
Fncos Fn Var
x
Fnexp Var
y!!!!
Fnln Fn Const

Var
x!!!
t

term

%sinx

y

cosx

expy

ln

x%
let
x

t
x

term

%sinx

y

cosx

expy

ln

x%


CHAPTER
	
EXAMPLES
Once
the
new
prin
ter
is
installed
it
is
used
whenev
er
CAML
w
an
ts
to
prin
t
something
of
t
yp
e
term
ev
en
if
it
is
a
comp
osite
datastructure
suc
h
as
a
pair
xt


term

term

%sinx

y

cosx

expy

ln

x%
%sinx

y

cosx

expy

ln

x%
or
a
list
 x
t
x!


term
list

 %sinx

y

cosx

expy

ln

x%
%sinx

y

cosx

expy

ln

x%
%sinx

y

cosx

expy

ln

x%!
This
prin
ter
is
rather
crude
in
that
it
will
not
break
up
large
expressions
in
telligen
tly
across
lines
The
CAML
library
format
from
whic
h
w
e
used
a
few
functions
ab
o
v
e
pro
vides
for
a
b
etter
approac
h
Instead
of
con
v
erting
the
term
in
to
a
string
then
prin
ting
it
in
one
piece
w
e
can
mak
e
separate
prin
ting
calls
for
dieren
t
parts
of
it
and
in
tersp
erse
these
with
some
sp
ecial
function
calls
that
help
the
prin
ting
mec
hanism
to
understand
where
to
break
the
lines
Man
y
of
the
principles
used
in
this
and
similar
prett
yprin
ting
engines
are
due
to
Opp
en
		
W
e
will
not
consider
this
in
detail
here

see
the
CAML
man
ual
for
details

	
Deriv
ativ
es
No
w
it
is
a
fairly
simple
matter
to
dene
the
deriv
ativ
e
function
First
let
us
recall
the
systematic
metho
d
w
e
are
taugh
t
in
sc
ho
ol

If
the
expression
is
one
of
the
standard
functions
applied
to
an
argumen
t
that
is
the
v
ariable
of
dieren
tiation
eg
sin	x
return
the
kno
wn
deriv
a
tiv
e

If
the
expression
is
of
the
form
f
	x
"
g
	x
then
apply
the
rule
for
sums
returning
f
 	x
"
g
 	x
Lik
ewise
for
subtraction
etc

If
the
expression
is
of
the
form
f
	x

g
	x
then
apply
the
pro
duct
rule
ie
return
f
 	x

g
	x
"
f
	x

g
 	x

If
the
expression
is
one
of
the
standard
functions
applied
to
a
comp
osite
argumen
t
sa
y
f
	g
	x
then
apply
the
Chain
Rule
and
so
giv
e
g
 	x

f
 	g
	x

There
is
also
a
tutorial
written
b
y
Pierre
W
eis
a
v
ailable
online
as
part
of
the
CAML
page
httppauillac
inr
ia
fr
c
am
lF
AQ
fo
rm
at
en
g
htm
l

	
SYMBOLIC
DIFFERENTIA
TION

This
is
nothing
but
a
recursiv
e
algorithm
though
that
terminology
is
seldom
used
in
sc
ho
ols
W
e
can
program
it
in
ML
v
ery
directly
let
rec
differentiate
x
tm

match
tm
with
Var
y
	
if
y

x
then
Const

else
Const



Const
c
	
Const



Fn t!
	
Fn differentiate
x
t!

Fn tt!
	
Fn differentiate
x
t
differentiate
x
t!

Fn tt!
	
Fn differentiate
x
t
differentiate
x
t!

Fn tt!
	
Fn Fn differe
ntia
te
x
t
t!
Fn t
differentiate
x
t!!

Fninv t!
	
chain
x
t
Fn Fninv Fn
 
tC
onst
!!!

Fn tn!
	
chain
x
t
Fn n
Fn t
Fn n
Const
!!!

Fnexp t!
	
chain
x
t
tm

Fnln t!
	
chain
x
t
Fninv t!

Fnsin t!
	
chain
x
t
Fncos t!

Fncos t!
	
chain
x
t
Fn Fnsin t!!


Fn tt!
	
differentiate
x
Fn t
Fninv t!!

Fntan t!
	
differentiate
x
Fn Fnsin t!
Fncos t!!
and
chain
x
t
u

Fn differentiate
x
t
u!
The
chain
function
just
a
v
oids
rep
eating
the
c
hain
rule
construction
for
man
y
op
erations
Apart
from
that
w
e
just
systematically
apply
rules
for
sums
pro
d
ucts
etc
and
the
kno
wn
deriv
ativ
es
of
standard
functions
Of
course
w
e
could
add
other
functions
suc
h
as
the
h
yp
erb
olic
functions
and
in
v
erse
trigonometric
functions
if
desired
A
couple
of
cases
namely
division
and
tan
a
v
oid
a
compli
cated
denition
b
y
applying
the
dieren
tiator
to
an
alternativ
e
form
ulation
	
Simplication
If
w
e
try
the
dieren
tiator
out
on
our
running
example
then
it
w
orks
quite
w
ell


CHAPTER
	
EXAMPLES
t


term

%sinx

y

cosx

expy

ln

x%
differentiate
x
t


term

%




cosx

y

invcosx

expy

sinx

y





expy

sinx

expy

invcosx

expy







inv

x%
differentiate
y
t


term

%



cosx

y

invcosx

expy

sinx

y





expy

sinx

expy

invcosx

expy








inv

x%
differentiate
z
t


term

%




cosx

y

invcosx

expy

sinx

y





expy

sinx

expy

invcosx

expy








inv

x%
Ho
w
ev
er
it
fails
to
mak
e
v
arious
ob
vious
simplications
suc
h
as


x


and
x
"


x
Some
of
these
redundan
t
expressions
are
created
b
y
the
rather
unsubtle
dieren
tiation
strategy
whic
h
for
instance
applies
the
c
hain
rule
to
f
	t
ev
en
where
t
is
just
the
v
ariable
of
dieren
tiation
Ho
w
ev
er
some
w
ould
b
e
hard
to
a
v
oid
without
making
the
dieren
tiator
m
uc
h
more
complicated
Accordingly

let
us
dene
a
separate
simplication
function
that
gets
rid
of
some
of
these
unnecessary
expressions
let
simp

fun
Fn Const


t!
	
t

Fn t
Const

!
	
t

Fn t
Const

!
	
t

Fn Const


t!
	
Fn t!

Fn t
Fn t!!
	
Fn t
t!

Fn Const


t!
	
Const



Fn t
Const

!
	
Const



Fn Const

t!
	
t

Fn t
Const
!
	
t

Fn Fn t!
Fn t!!
	
Fn t
t!

Fn Fn t!
t!
	
Fn Fn t
t!!

Fn t
Fn t!!
	
Fn Fn t
t!!

Fn Fn t!!
	
t

t
	
t
This
just
applies
the
simplication
at
the
top
lev
el
of
the
term
W
e
need
to
execute
it
in
a
b
ottomup
sw
eep
This
will
also
bring
negations
up
w
ards
through
pro
ducts
In
some
cases
it
w
ould
b
e
more
ecien
t
to
simplify
in
a
topdo
wn
sw
eep
eg


t
for
a
complicated
expression
t
but
this
w
ould
need
rep
eating
for
terms
lik
e
	
"



The
c
hoice
is
rather
lik
e
that
b
et
w
een
normal
and
applicativ
e
order
reduction
in
lam
b
da
calculus

	
SYMBOLIC
DIFFERENTIA
TION

let
rec
dsimp

fun
Fnfnargs
	
simpFnfnmap
dsimp
args

t
	
simp
t
No
w
w
e
get
b
etter
results
dsimpdifferentiate
x
t


term

%cosx

y

invcosx

expy

sinx

y

sinx

expy

invcosx

expy



inv

x%
dsimpdifferentiate
y
t


term

%cosx

y

invcosx

expy

sinx

y

expy

sinx

expy

invcosx

expy

%
dsimpdifferentiate
z
t


term

%
%
In
general
one
can
alw
a
ys
add
more
and
more
sophisticated
simplication
F
or
example
consider
let
t

Fntan Var
x!
t

term

%tanx%
differentiate
x
t


term

%

cosx

invcosx

sinx



sinx

invcosx

%
dsimpdifferentiate
x
t


term

%cosx

invcosx

sinx

sinx

invcosx

%
W
e
w
ould
lik
e
to
simplify
cosx

invcosx
simply
to

ignoring
as
most
commercial
computer
algebra
systems
do
the
p
ossibilit
y
that
cosx
migh
t
b
e
zero
W
e
can
certainly
add
new
clauses
to
the
simplier
for
that
Similarly

w
e
migh
t
lik
e
to
collect
up
terms
in
the
second
summand
Ho
w
ev
er
here
w
e
start
to
see
that
h
uman
psyc
hology
pla
ys
a
role
Whic
h
of
the
follo
wing
is
preferable
It
is
hard
for
the
mac
hine
to
decide
unaided
sinx

sinx

invcosx


sinx



invcosx


sinx



cosx


sinx

cosx


tanx




CHAPTER
	
EXAMPLES
And
ha
ving
c
hosen
the
last
one
should
it
then
con
v
ert


tanx


in
to
secx


Certainly

it
is
shorter
and
more
con
v
en
tional
Ho
w
ev
er
it
relies
on
the
fact
that
w
e
kno
w
the
denitions
of
these
fairly
obscure
trig
functions
lik
e
sec
What
ev
er
the
mac
hine
decides
to
do
it
is
lik
ely
that
some
user
will
nd
it
upsetting
	
P
arsing
A
defect
of
our
previous
example
w
as
that
the
input
had
to
b
e
written
explicitly
in
terms
of
t
yp
e
constructors
Here
w
e
will
sho
w
ho
w
to
write
a
parser
for
this
situation
and
mak
e
our
co
de
sucien
tly
general
that
it
can
easily
b
e
applied
to
similar
formal
languages
Generally
sp
eaking
the
problem
of
parsing
is
as
follo
ws
A
formal
language
is
dened
b
y
a
gr
ammar
whic
h
is
a
set
of
pr
o
duction
rules
for
eac
h
syn
tactic
category

F
or
a
language
of
terms
with
t
w
o
inx
op
erators

and

and
only
alphan
umeric
v
ariables
and
n
umeral
	

etc
constan
ts
it
migh
t
lo
ok
lik
e
this
ter
m

 name
ter
ml
ist
j
name
j
ter
m
j
numer
al
j
ter
m
j
ter
m

ter
m
j
ter
m

ter
m
ter
ml
ist

 ter
m
ter
ml
ist
j
ter
m
W
e
will
assume
for
the
momen
t
that
w
e
kno
w
what
names
and
n
umerals
are
but
w
e
could
ha
v
e
similar
rules
dening
them
in
terms
of
single
c
haracters
No
w
this
set
of
pro
duction
rules
giv
es
us
a
w
a
y
of
generating
the
concrete
linear
represen
tation
for
all
terms
Note
that
name
numer
al

ter
m
and
ter
ml
ist
are
mean
t
to
b
e
v
ariables
in
the
ab
o
v
e
whereas
elemen
ts
lik
e

and

written
in
b
old
t
yp
e
are
actual
c
haracters
F
or
example
w
e
ha
v
e

	
P
ARSING
	
ter
m

 ter
m

ter
m

 ter
m

ter
m

 ter
m

ter
m

ter
m

 ter
m

ter
m

ter
m

ter
m

 numer
al

name

name

name
so
follo
wing
similar
rules
for
name
and
numer
al

w
e
can
generate
for
example


x

y

z
The
task
of
p
arsing
is
to
rev
erse
this
pro
cess
of
applying
pro
duction
rules
ie
to
tak
e
a
string
and
disco
v
er
ho
w
it
could
ha
v
e
b
een
generated
b
y
the
pro
duction
rules
for
a
syn
tactic
category

T
ypically

the
output
is
a
p
arse
tr
e
e
ie
a
tree
structure
that
sho
ws
clearly
the
sequence
of
applications
of
the
rules
One
problem
with
parsing
is
that
the
grammar
ma
y
b
e
ambiguous
ie
a
giv
en
string
can
often
b
e
generated
in
sev
eral
dieren
t
w
a
ys
This
is
the
case
in
our
example
ab
o
v
e
for
the
string
could
also
ha
v
e
b
een
generated
b
y
ter
m

 ter
m

ter
m

 ter
m

ter
m

 ter
m

ter
m

ter
m

 ter
m

ter
m

ter
m

ter
m

 numer
al

name

name

name
The
ob
vious
w
a
y
to
x
this
is
to
sp
ecify
rules
of
precedence
and
asso
ciativit
y
for
inx
op
erators
Ho
w
ev
er
w
e
can
mak
e
the
grammar
unam
biguous
without
in
tro
ducing
additional
mec
hanisms
at
the
cost
of
adding
new
syn
tactic
categories
atom

 name
ter
ml
ist
j
name
j
numer
al
j
ter
m
j
atom
mul
exp

 atom

mul
exp
j
atom
ter
m

 mul
exp

ter
m
j
mul
exp
ter
ml
ist

 ter
m
ter
ml
ist
j
ter
m


CHAPTER
	
EXAMPLES
Note
that
this
mak
es
b
oth
inx
op
erators
righ
t
asso
ciativ
e
F
or
a
more
com
plicated
example
of
this
tec
hnique
in
action
lo
ok
at
the
formal
denition
of
expressions
in
the
ANSI
C
Standard
	
Recursiv
e
descen
t
parsing
The
pro
duction
rules
suggest
a
v
ery
simple
w
a
y
of
going
ab
out
parsing
using
a
series
of
m
utually
recursiv
e
functions
The
idea
is
to
ha
v
e
a
function
for
eac
h
syn
tactic
category

and
a
recursiv
e
structure
that
reects
exactly
the
m
utual
re
cursion
found
in
the
grammar
itself
F
or
example
the
pro
cedure
for
parsing
terms
sa
y
term
will
on
encoun
tering
a

sym
b
ol
mak
e
a
recursiv
e
call
to
itself
to
parse
the
subterm
and
on
encoun
tering
a
name
follo
w
ed
b
y
an
op
ening
paren
thesis
will
mak
e
a
recursiv
e
call
to
termlist
This
in
itself
will
mak
e
at
least
one
recursiv
e
call
to
term
and
so
on
Suc
h
a
st
yle
of
programming
is
particularly
natural
in
a
language
lik
e
ML
where
recursion
is
the
principal
con
trol
mec
hanism
In
our
ML
implemen
tation
w
e
supp
ose
that
w
e
ha
v
e
some
input
list
of
ob
jects
of
arbitrary
t
yp
e

for
the
parser
to
consume
These
migh
t
simply
b
e
c
haracters
but
in
fact
there
is
usually
a
separate
lev
el
of
lexic
al
analysis
whic
h
collects
c
haracters
together
in
to
tokens
suc
h
as
x

and
	
so
b
y
the
time
w
e
reac
h
this
lev
el
the
input
is
a
list
of
tok
ens
W
e
a
v
oid
committing
ourselv
es
to
an
y
particular
t
yp
e
Similarly

w
e
will
allo
w
the
parser
to
construct
ob
jects
of
arbitrary
t
yp
e

from
its
input
These
migh
t
for
example
b
e
parse
trees
as
mem
b
ers
of
a
recursiv
e
datat
yp
e
or
migh
t
simply
b
e
n
um
b
ers
if
the
parser
is
to
tak
e
an
expression
and
ev
aluate
it
No
w
in
general
a
parser
migh
t
not
consume
all
its
input
so
w
e
also
mak
e
it
output
the
remaining
tok
ens
Therefore
a
parser
will
ha
v
e
t
yp
e
	
l
ist
 

	
l
ist
F
or
example
when
giv
en
the
input
c
haracters
x

y

z
the
function
atom
should
pro
cess
the
c
haracters
x

y
and
lea
v
e
the
remaining
c
haracters

z
It
migh
t
return
a
parse
tree
for
the
pro
cessed
expression
using
our
earlier
recursiv
e
t
yp
e
and
hence
w
e
w
ould
ha
v
e
atom
x

y

z

Fn Var
x
Var
y!
z
Since
an
y
call
of
the
function
atom
m
ust
b
e
from
within
the
function
mulexp
this
second
function
will
use
the
result
of
atom
and
deal
with
the
input
that
remains
making
a
second
call
to
atom
to
pro
cess
the
expression
z
	
P
arser
com
binators
Another
reason
wh
y
this
tec
hnique
w
orks
particularly
w
ell
in
ML
is
that
w
e
can
dene
some
useful
com
binators
for
plugging
parsers
together
In
fact
b
y
giving

	
P
ARSING

them
inx
status
w
e
can
mak
e
the
ML
parser
program
lo
ok
quite
similar
in
structure
to
the
original
grammar
dening
the
language
First
w
e
declare
an
exception
to
b
e
used
where
parsing
fails
Then
w
e
dene
an
inx

that
applies
t
w
o
parsers
in
sequence
pairing
up
their
results
and
and
inx
##
whic
h
tries
rst
one
parser
then
the
other
W
e
then
dene
a
man
yfold
v
ersion
of

that
rep
eats
a
parser
as
far
as
p
ossible
putting
the
results
in
to
a
list
Finally

the
inx

is
used
to
mo
dify
the
results
of
a
parser
according
to
a
function
The
CAML
rules
for
sym
b
olic
iden
tiers
suc
h
as

mak
e
them
inx
automat
ically

so
w
e
suppress
this
during
the
denition
using
the
prefix
k
eyw
ord
Their
precedences
are
also
automatic
follo
wing
from
the
usual
precedence
of
their
rst
c
haracters
as
arithmetic
op
erations
etc
That
is

is
the
strongest

falls
in
the
middle
and
##
is
the
w
eak
est
this
is
exactly
what
w
e
w
an
t
exception
Noparse
let
prefix

parser
parser
input

try
parser
input
with
Noparse
	
parser
input
let
prefix

parser
parser
input

let
resultrest

parser
input
in
let
resultrest

parser
rest
in
resultresultrest

let
rec
many
parser
input

try
let
resultnext

parser
input
in
let
resultsrest

many
parser
next
in
resultresultsrest
with
Noparse
	
 !input
let
prefix
		
parser
treatment
input

let
resultrest

parser
input
in
treatmentresultrest

W
e
will
in
what
follo
ws
use
the
follo
wing
other
functions
Most
of
these
ha
v
e
b
een
dened
ab
o
v
e
the
main
exception
b
eing
explode
whic
h
con
v
erts
a
string
in
to
a
list
of
elemen
ts
strings
It
uses
the
in
built
functions
sub&string
and
string&length
w
e
do
not
describ
e
them
in
detail
but
their
function
should
b
e
easy
to
grasp
from
the
example


CHAPTER
	
EXAMPLES
let
rec
itlist
f

fun
 !
b
	
b

ht
b
	
f
h
itlist
f
t
b
let
uncurry
fxy

f
x
y
let
K
x
y

x
let
C
f
x
y

f
y
x
let
o
f
g
x

fg
x
infix
o
let
explode
s

let
rec
exap
n
l

if
n


then
l
else
exap
n


substring
s
n
l
in
exap
stringlength
s


 !
In
order
to
get
started
w
e
dene
a
few
atomic
parsers
The
function
some
accepts
an
y
item
satisfying
a
predicate
and
returns
it
The
function
a
is
similar
but
demands
a
particular
item
and
nally
finished
just
mak
es
sure
there
are
no
items
left
to
b
e
parsed
let
some
p

fun
 !
	
raise
Noparse

ht
	
if
p
h
then
ht
else
raise
Noparse
let
a
tok

some
fun
item
	
item

tok
let
finished
input

if
input

 !
then

input
else
raise
Noparse
	
Lexical
analysis
Our
parsing
com
binators
can
easily
b
e
used
in
conjunction
with
a
few
simple
c
haracter
discrimination
functions
to
construct
a
lexical
analyzer
for
our
lan
guage
of
terms
W
e
dene
a
t
yp
e
of
tokens
	or
lexemes
and
the
lexer
translates
the
input
string
in
to
a
list
of
tok
ens
The
other
cases
co
v
er
sym
b
olic
iden
tiers
they
are
all
straigh
tforw
ard
as
they
consist
of
just
a
single
c
haracter
rather
than
comp
osite
ones
lik
e


	
P
ARSING

type
token

Name
of
string

Num
of
string

Other
of
string
let
lex

let
several
p

many
some
p
in
let
lowercaseletter
s

a

s
"
s

z
in
let
uppercaseletter
s

A

s
"
s

Z
in
let
letter
s

lowercaseletter
s
or
uppercaseletter
s
in
let
alpha
s

letter
s
or
s


or
s


in
let
digit
s




s
"
s

	
in
let
alphanum
s

alpha
s
or
digit
s
in
let
space
s

s



or
s

&n
or
s

&t
in
let
collectht

hitlist
prefix

t

in
let
rawname

some
alpha

several
alphanum
		
Name
o
collect
in
let
rawnumeral

some
digit

several
digit
		
Num
o
collect
in
let
rawother

some
K
true
		
Other
in
let
token

rawname

rawnumeral

rawother

several
space
		
fst
in
let
tokens

several
space

many
token
		
snd
in
let
alltokens

tokens

finished
		
fst
in
fst
o
alltokens
o
explode
F
or
example
lex
sinx

y

cos

x

y


token
list

 Name
sin
Other

Name
x
Other

Name
y
Other

Other

Name
cos
Other

Num

Other

Name
x
Other

Name
y
Other
!
	
P
arsing
terms
Since
w
e
are
no
w
w
orking
at
the
lev
el
of
tok
ens
w
e
dene
trivial
parsers
to
accept
tok
ens
of
	only
a
certain
kind
let
name

fun
Name
srest
	
srest


	
raise
Noparse
let
numeral

fun
Num
srest
	
srest


	
raise
Noparse
let
other

fun
Other
srest
	
srest


	
raise
Noparse
No
w
w
e
can
dene
a
parser
for
terms
in
a
form
v
ery
similar
to
the
original
grammar
The
main
dierence
is
that
eac
h
pro
duction
rule
has
asso
ciated
with
it
some
sort
of
sp
ecial
action
to
tak
e
as
a
result
of
parsing


CHAPTER
	
EXAMPLES
let
rec
atom
input

name

a
Other


termlist

a
Other

		
fun
nameargs
	
Fnnameargs

name
		
fun
s
	
Var
s

numeral
		
fun
s
	
Const
s

a
Other


term

a
Other

		
snd
o
fst

a
Other


atom
		
snd
input
and
mulexp
input

atom

aOther


mulexp
		
fun
am
	
Fn am!

atom
input
and
term
input

mulexp

aOther


term
		
fun
am
	
Fn am!

mulexp
input
and
termlist
input

term

a
Other


termlist
		
fun
ht
	
ht

term
		
fun
h
	
 h!
input
Let
us
pac
k
age
ev
erything
up
as
a
single
parsing
function
let
parser

fst
o
term

finished
		
fst
o
lex
T
o
see
it
in
action
w
e
try
with
and
without
the
prin
ter
	see
ab
o
v
e
installed
parser
sinx

y

cos

x

y


term

Fn

 Fn
sin
 Fn

 Var
x
Var
y!!
Fn
cos
 Fn

 Fn

 Const

Var
x!
Var
y!!!
installprinter
printterm


unit


parser
sinx

y

cos

x

y


term

%sinx

y

cos

x

y%
	
Automatic
precedence
parsing
In
the
ab
o
v
e
parser
w
e
hardwired
a
parser
for
the
t
w
o
inx
op
erators
Ho
w
ev
er
it
w
ould
b
e
nicer
and
consisten
t
with
our
approac
h
to
prin
ting
if
c
hanges
to
the
set
of
inxes
could
propagate
to
the
parser
Moreo
v
er
ev
en
with
just
t
w
o
dier
en
t
binary
op
erators
our
pro
duction
rules
and
consequen
t
parser
w
ere
already

	
P
ARSING

starting
to
lo
ok
articial
imagine
if
w
e
had
a
dozen
or
so
What
w
e
w
ould
lik
e
is
to
automate
the
pro
duction
of
a
la
y
er
of
parsers
one
for
eac
h
op
erator
in
order
of
precedence
This
can
easily
b
e
done
First
w
e
dene
a
general
function
that
tak
es
a
parser
for
what
at
this
lev
el
are
regarded
as
atomic
expressions
and
pro
duces
a
new
parser
for
suc
h
expressions
separated
b
y
a
giv
en
op
erator
Note
that
this
could
also
b
e
dened
using
parsing
com
binators
but
the
function
b
elo
w
is
simple
and
more
ecien
t
let
rec
binop
op
parser
input

let
atomrest
as
result

parser
input
in
if
not
rest

 !
"
hd
rest

Other
op
then
let
atomrest

binop
op
parser
tl
rest
in
Fnop atom
atom!rest
else
result
No
w
w
e
dene
functions
that
pic
k
out
the
inx
op
erator
in
our
asso
ciation
list
with
	equal
lo
w
est
precedence
and
delete
it
from
the
list
If
w
e
main
tained
the
list
already
sorted
in
precedence
order
w
e
could
simply
tak
e
the
head
and
tail
of
the
list
let
findmin
l

itlist
fun
pr
as
p
pr
as
p
	
if
pr

pr
then
p
else
p
tl
l
hd
l
let
rec
delete
x
ht

if
h

x
then
t
else
hdelete
x
t
No
w
w
e
can
dene
the
generic
precedence
parser
let
rec
precedence
ilist
parser
input

if
ilist

 !
then
parser
input
else
let
opp

findmin
ilist
in
let
ilist

delete
opp
ilist
in
binop
fst
opp
precedence
ilist
parser
input
and
hence
can
mo
dify
the
main
parser
to
b
e
b
oth
simpler
and
more
general


CHAPTER
	
EXAMPLES
let
rec
atom
input

name

a
Other


termlist

a
Other

		
fun
nameargs
	
Fnnameargs

name
		
fun
s
	
Var
s

numeral
		
fun
s
	
Const
s

a
Other


term

a
Other

		
snd
o
fst

a
Other


atom
		
snd
input
and
term
input

precedence
#infixes
atom
input
and
termlist
input

term

a
Other


termlist
		
fun
ht
	
ht

term
		
fun
h
	
 h!
input
let
parser

fst
o
term

finished
		
fst
o
lex
for
example
parser


sinx



siny




term

Fn

 Fn

 Const

Fn

 Fn
sin
 Var
x!
Const
!!
Fn

 Fn

 Const

Fn

 Fn
sin
 Var
y!
Const
!!
Const
!!
installprinter
printterm


unit


parser


sinx



siny




term

%

sinx





siny



%
	
Defects
of
our
approac
h
Our
approac
h
to
lexing
and
parsing
is
not
particularly
ecien
t
In
fact
CAML
and
some
other
ML
implemen
tations
include
a
generator
for
LR
parsers
similar
to
Y
A
CC
	Y
et
Another
Compiler
Compiler
whic
h
is
often
used
to
generate
parsers
in
C
under
Unix
Not
only
are
these
more
general
in
the
grammars
that
they
can
handle
but
the
resulting
parsers
are
more
ecien
t
Ho
w
ev
er
w
e
b
eliev
e
the
presen
t
approac
h
is
rather
clear
adequate
for
most
purp
oses
and
a
go
o
d
in
tro
duction
to
programming
with
higher
order
functions
The
ineciency
of
our
approac
h
can
b
e
reduced
b
y
a
v
oiding
a
few
particularly
w
asteful
features
Note
that
if
t
w
o
dieren
t
pro
ductions
for
the
same
syn
tactic

	
P
ARSING

category
ha
v
e
a
common
prex
then
w
e
should
a
v
oid
parsing
it
more
than
once
unless
it
is
guaran
teed
to
b
e
trivial
Our
pro
duction
rules
for
ter
m
ha
v
e
this
prop
ert
y
ter
m

 name
ter
ml
ist
j
name
j



W
e
carefully
put
the
longer
pro
duction
rst
in
our
actual
implemen
tation
otherwise
success
in
reading
a
name
w
ould
cause
the
abandonmen
t
of
attempts
to
read
a
paren
thesized
list
of
argumen
ts
Nev
ertheless
b
ecause
of
the
redundancy
w
e
ha
v
e
men
tioned
this
w
a
y
of
constructing
the
parser
is
w
asteful
In
this
case
it
do
esnt
matter
m
uc
h
b
ecause
the
duplicated
call
only
analyzes
one
tok
en
Ho
w
ev
er
the
case
for
ter
ml
ist
is
more
signican
t
let

and
termlist
input

term

a
Other


termlist
		
fun
ht
	
ht

term
		
fun
h
	
 h!
input
Here
w
e
could
reparse
a
whole
term
whic
h
migh
t
b
e
arbitrarily
large
W
e
can
a
v
oid
this
in
sev
eral
w
a
ys
One
is
to
mo
v
e
the
##
alternation
to
after
the
initial
term
has
b
een
read
A
con
v
enien
t
w
a
y
to
co
de
it
is
to
esc
hew
explicit
recursion
in
fa
v
our
of
many
let

and
termlist
input

term

many
a
Other


term
		
snd
		
fun
ht
	
ht
input
Therefore
the
nal
v
ersion
of
the
parser
is
let
rec
atom
input

name

a
Other


termlist

a
Other

		
fun
nameargs
	
Fnnameargs

name
		
fun
s
	
Var
s

numeral
		
fun
s
	
Const
s

a
Other


term

a
Other

		
snd
o
fst

a
Other


atom
		
snd
input
and
term
input

precedence
#infixes
atom
input
and
termlist
input

term

many
a
Other


term
		
snd
		
fun
ht
	
ht
input


CHAPTER
	
EXAMPLES
A
general
defect
of
our
approac
h
and
recursiv
e
descen
t
parsing
generally

is
that
socalled
left
r
e
cursion
in
pro
ductions
causes
problems
This
is
where
a
giv
en
category
expands
to
a
sequence
including
the
category
itself
as
the
rst
item
F
or
example
if
w
e
had
w
an
ted
to
mak
e
the
addition
op
erator
leftasso
ciativ
e
in
our
earlier
grammar
w
e
could
ha
v
e
used
ter
m

 ter
m

mul
exp
j
mul
exp
The
naiv
e
transcription
in
to
ML
w
ould
lo
op
indenitely

calling
term
on
the
same
subterm
o
v
er
and
o
v
er
There
are
v
arious
sligh
tly
ad
ho
c
w
a
ys
of
dealing
with
this
problem
F
or
example
one
can
con
v
ert
this
use
of
recursion
whic
h
in
some
w
a
ys
is
rather
gratuitous
in
to
the
explicit
use
of
rep
etition
W
e
can
do
this
using
standard
com
binators
lik
e
many
to
return
a
list
of
mul
exps
and
then
run
o
v
er
the
list
building
the
tree
leftasso
ciated
A
nal
problem
is
that
w
e
do
not
handle
errors
v
ery
gracefully

W
e
alw
a
ys
raise
the
exception
Noparse
and
this
when
caugh
t
initiates
bac
ktrac
king
Ho
w
ev
er
this
is
not
alw
a
ys
appropriate
for
t
ypical
grammars
A
t
b
est
it
can
cause
exp
ensiv
e
reparsing
and
can
lead
to
ba+ing
error
indications
at
the
top
lev
el
F
or
example
on
encoun
tering


w
e
exp
ect
a
term
follo
wing
the

and
if
w
e
dont
nd
one
w
e
should
generate
a
comprehensible
exception
for
the
user
rather
than
raise
Noparse
and
p
erhaps
initiate
sev
eral
other
p
oin
tless
attempts
to
parse
the
expression
in
a
dieren
t
w
a
y

	
Exact
real
arithmetic
Real
arithmetic
on
computers
is
normally
done
via
oating
p
oin
t
appro
ximations
In
general
w
e
can
only
manipulate
a
real
n
um
b
er
either
ourselv
es
or
inside
a
computer
via
some
sort
of
nite
represen
tation
Some
question
ho
w
n
um
b
ers
can
b
e
said
to
exist
if
they
ha
v
e
no
nite
represen
tation
F
or
example
Kronec
k
er
accepted
in
tegers
and
rationals
b
ecause
they
can
b
e
written
do
wn
explicitly

and
ev
en
algebr
aic
n
um
b
ers

b
ecause
they
can
b
e
represen
ted
using
the
p
olynomials
of
whic
h
they
are
solutions
Ho
w
ev
er
he
rejected
transcenden
tal
n
um
b
ers
b
ecause
apparen
tly
they
could
not
b
e
represen
ted
nitely

Allegedly
he
he
greeted
the
famous
pro
of
b
y
Lindemann
	
that

is
transcenden
tal
with
the
remark
that
this
w
as
in
teresting
except
that

do
es
not
exist
Ho
w
ev
er
giv
en
our
mo
dern
p
ersp
ectiv
e
w
e
can
sa
y
that
after
all
man
y
more
n
um
b
ers
than
Kronec
k
er
w
ould
ha
v
e
accepted
do
ha
v
e
a
nite
represen
tation
namely
the
program
or
in
some
more
abstract
sense
the
rule
used
to
calculate

Algebraic
n
um
b
ers
are
those
that
are
ro
ots
of
p
olynomials
with
in
teger
co
ecien
ts
eg
p

and
transcenden
tal
n
um
b
ers
are
ones
that
arent

	
EXA
CT
REAL
ARITHMETIC
	
them
to
greater
and
greater
precision
F
or
example
w
e
can
write
a
program
that
will
pro
duce
for
an
y
argumen
t
n
the
rst
n
digits
of


Alternativ
ely
it
can
pro
duce
a
rational
n
um
b
er
r
suc
h
that
j

r
j


n

Whatev
er
approac
h
is
tak
en
to
the
successiv
e
appro
ximation
of
a
real
n
um
b
er
the
k
ey
p
oin
t
is
that
its
represen
tation
the
program
itself
is
nite
This
w
orks
particularly
nicely
in
a
language
lik
e
ML
where
higher
order
func
tions
are
a
v
ailable
What
w
e
ha
v
e
called
a
program
ab
o
v
e
will
just
b
e
an
ML
function
W
e
can
actually
represen
t
the
arithmetic
op
erations
on
n
um
b
ers
as
higher
order
functions
that
giv
en
functions
for
appro
ximating
x
and
y

will
pro
duce
new
ones
for
appro
ximating
x
"
y

xy

sin	x
and
so
on
for
a
wide
range
of
functions
In
an
ordinary
programming
language
w
e
w
ould
need
to
dene
a
concrete
represen
tation
for
programs
eg
G&
odel
n
um
b
ering
and
write
an
in
terpreter
for
this
represen
tation

	
Represen
tation
of
real
n
um
b
ers
Our
approac
h
is
to
represen
t
a
real
x
b
y
a
function
f
x

N
 Z
that
for
eac
h
n

N
returns
an
appro
ximation
of
x
to
within

n

appropriately
scaled
In
fact
w
e
ha
v
e
jf
x
	n


n
xj


This
is
of
course
equiv
alen
t
to
j
f
x
n

n

xj



n

W
e
could
return
a
rational
appro
ximation
directly

but
it
w
ould
still
b
e
con
v
enien
t
for
the
rationals
to
ha
v
e
denominators
that
are
all
p
o
w
ers
of
some
n
um
b
er
so
that
common
denominators
arising
during
addition
dont
get
to
o
big
P
erforming
the
scaling
directly
seems
simpler
requiring
only
in
teger
arithmetic
Our
c
hoice
of
the
base

is
largely
arbitrary

A
lo
w
er
base
is
normally
adv
an
tageous
b
ecause
it
minimizes
the
gr
an
ularity
of
the
ac
hiev
able
accuracies
F
or
example
if
w
e
used
base

then
ev
en
if
w
e
only
need
to
increase
the
accuracy
of
an
appro
ximation
sligh
tly

w
e
ha
v
e
to
step
up
the
requested
accuracy
b
y
a
factor
of

	
Arbitraryprecision
in
tegers
CAMLs
standard
in
tegers
	t
yp
e
int
ha
v
e
a
sev
erely
limited
range
so
rst
of
all
w
e
need
to
set
up
a
t
yp
e
of
unlimitedprecision
in
tegers
This
is
not
so
dicult
to
program
but
is
sligh
tly
tedious
F
ortunately

the
CAML
release
includes
a
library
that
giv
es
a
fast
implemen
tation
of
arbitrary
precision
in
teger
	and
in
fact
rational
arithmetic
A
v
ersion
of
CAML
Ligh
t
with
this
library
preloaded
is
installed
on
Thor
Assuming
y
ou
ha
v
e
used
the
follo
wing
path
setting

Eectiv
ely

w
e
are
manipulating
functions
in
extension
rather
than
in
in
tension
ie
not
concerning
ourselv
es
with
their
represen
tation


CHAPTER
	
EXAMPLES
PATHPATHhomejrhc
aml
bin
export
PATH
then
the
augmen
ted
v
ersion
of
CAML
Ligh
t
can
b
e
red
up
using

camllight
mylittlecaml
When
the
system
returns
its
prompt
use
the
open
directiv
e
to
mak
e
the
library
functions
a
v
ailable
open
num
This
library
sets
up
a
new
t
yp
e
num
of
arbitrary
precision
rational
n
um
b
ers
w
e
will
just
use
the
in
teger
subset
CAML
do
es
not
pro
vide
o
v
erloading
so
it
is
necessary
to
use
dieren
t
sym
b
ols
for
the
usual
arithmetic
op
erations
o
v
er
num
Note
that
small
constan
ts
of
t
yp
e
num
m
ust
b
e
written
as
Int
k
rather
than
simply
k
In
fact
Int
is
a
t
yp
e
constructor
for
num
used
in
the
case
when
the
n
um
b
er
is
a
mac
hinerepresen
table
in
teger
Larger
ones
use
Big
int
The
unary
negation
on
t
yp
e
num
is
written
minus
num
Another
handy
unary
op
erator
is
abs
num
whic
h
nds
absolute
v
alues
ie
giv
en
x
returns
jxj
The
usual
binary
op
erations
are
also
a
v
ailable
The
	truncating
division
and
mo
dulus
function
called
quo
num
and
mod
num
do
not
ha
v
e
inx
status
Ho
w
ev
er
most
of
the
other
binary
op
erators
are
inxes
and
the
names
are
deriv
ed
from
the
usual
ones
b
y
adding
a
slash

It
is
imp
ortan
t
to
realize
that
in
general
one
m
ust
use

to
compare
n
um
b
ers
for
equalit
y

This
is
b
ecause
the
constructors
of
the
t
yp
e
num
are
as
alw
a
ys
distinct
b
y
denition
y
et
in
terms
of
the
underlying
meaning
they
ma
y
o
v
erlap
F
or
example
w
e
get
dieren
t
result
from
using
truncating
division
and
true
division
on

 and

ev
en
though
they
are
n
umerically
the
same
One
uses
t
yp
e
constructor
Int
and
the
other
Ratio
Int


Int



Int


quonum
Int


Int


Int

it

bool

false
Int


Int



Int


quonum
Int


Int


Int

it

bool

true
Here
is
a
full
list
of
the
main
inx
binary
op
erators
Op
erator
T
yp
e
Meaning

num

num

num
Exp
onen
tiation

num

num

num
Multiplication

num

num

num
Addition

num

num

num
Subtraction

num

num

bool
Equalit
y

num

num

bool
Inequalit
y

num

num

bool
Less
than

num

num

bool
Less
than
or
equal

num

num

bool
Greater
than

num

num

bool
Greater
than
or
equal

	
EXA
CT
REAL
ARITHMETIC

Let
us
see
some
further
examples
Int


Int

it

num

Int

Int


Int


it

num

Bigint
abstr	
Int


Int



Int

it

num

Ratio
abstr	
quonum
Int


Int


Int

it

num

Int

	
Note
that
large
n
um
b
ers
are
not
prin
ted
Ho
w
ev
er
w
e
can
alw
a
ys
con
v
ert
one
to
a
string
using
string
of
num
stringofnumInt


Int




string

	
		

	
	
		




This
also
has
an
in
v
erse
called
naturally
enough
num
of
string
	
Basic
op
erations
Recall
that
our
real
n
um
b
ers
are
supp
osed
to
b
e
	represen
ted
b
y
functions
Z
 Z

In
ML
w
e
will
actually
use
int

num
since
the
in
built
t
yp
e
of
in
tegers
is
more
than
adequate
for
indexing
the
lev
el
of
accuracy

No
w
w
e
can
dene
some
op
erations
on
reals
The
most
basic
op
eration
whic
h
gets
us
started
is
to
pro
duce
the
real
n
um
b
er
corresp
onding
to
an
in
teger
This
is
easy
let
realofint
k
n

Int


Int
n

Int
k
realofint

int
	
int
	
num

fun	
realofint



int
	
num

fun	
It
is
ob
vious
that
for
an
y
k
this
ob
eys
the
desired
appro
ximation
criterion
jf
k
	n


n
k
j

j
n
k


n
k
j




No
w
w
e
can
dene
the
rst
non
trivial
op
eration
that
of
unary
negation
let
realneg
f
n

minusnumf
n
The
compiler
generalizes
the
t
yp
e
more
than
in
tended
but
this
will
not
trouble
us
It
is
almost
as
easy
to
see
that
the
appro
ximation
criterion
is
preserv
ed
If
w
e
kno
w
that
for
eac
h
n
jf
x
	n


n
xj


then
w
e
ha
v
e
for
an
y
n


CHAPTER
	
EXAMPLES
jf
x
	n


n
	xj

j

f
x
	n


n
	xj

j

	f
x
	n


n
xj

jf
x
	n


n
xj


Similarly

w
e
can
dene
an
absolute
v
alue
function
on
real
n
um
b
ers
using
the
corresp
onding
function
abs
num
on
n
um
b
ers
let
realabs
f
n

absnum
f
n
The
correctness
of
this
is
again
straigh
tforw
ard
using
the
fact
that
jjxj

jy
jj

jx

y
j
No
w
consider
the
problem
of
adding
t
w
o
real
n
um
b
ers
Supp
ose
x
and
y
are
represen
ted
b
y
f
x
and
f
y
resp
ectiv
ely

W
e
could
dene
f
x
y
	n

f
x
	n
"
f
y
	n
Ho
w
ev
er
this
giv
es
no
guaran
tee
that
the
appro
ximation
criterion
is
main
tained
w
e
w
ould
ha
v
e
jf
x
y
	n


n
	x
"
y
j

jf
x
	n
"
f
y
	n


n
	x
"
y
j

jf
x
	n


n
xj
"
jf
y
	n


n
y
j
W
e
can
guaran
tee
that
the
sum
on
the
righ
t
is
less
than

but
not
that
it
is
less
than

as
required
Therefore
w
e
need
in
this
case
to
ev
aluate
x
and
y
to
gr
e
ater
accuracy
than
required
in
the
answ
er
Supp
ose
w
e
dene
f
x
y
	n

	f
x
	n
"

"
f
y
	n
"

No
w
w
e
ha
v
e
jf
x
y
	n


n
	x
"
y
j

j	f
x
	n
"

"
f
y
	n
"



n
	x
"
y
j

jf
x
	n
"



n
xj
"
jf
y
	n
"



n
y
j



jf
x
	n
"



n

xj
"


jf
y
	n
"



n

y
j




"





Apparen
tly
this
just
giv
es
the
accuracy
required
Ho
w
ev
er
w
e
ha
v
e
implicitly
used
real
mathematical
division
ab
o
v
e
Since
the
function
is
supp
osed
to
yield
an
in
teger
w
e
are
obliged
to
round
the
quotien
t
to
an
in
teger
If
w
e
just
use
quo
num
the
error
from
rounding
this
migh
t
b
e
almost

after
whic
h
w
e
could
nev
er

	
EXA
CT
REAL
ARITHMETIC

guaran
tee
the
b
ound
w
e
w
an
t
ho
w
ev
er
accurately
w
e
ev
aluate
the
argumen
ts
Ho
w
ev
er
with
a
bit
more
care
w
e
can
dene
a
division
function
that
alw
a
ys
returns
the
in
teger
closest
to
the
true
result
	or
one
of
them
in
the
case
of
t
w
o
equally
close
ones
so
that
the
rounding
error
nev
er
exceeds



This
could
b
e
done
directly
in
in
teger
arithmetic
but
the
most
straigh
tforw
ard
co
ding
is
to
use
rational
division
follo
w
ed
b
y
rounding
to
the
nearest
in
teger
as
there
are
builtin
functions
for
b
oth
these
op
erations
let
ndiv
x
y

roundnumx

y
ndiv

num
	
num
	
num

fun	
infix
ndiv
Int

ndiv
Int



num

Int

Int

ndiv
Int



num

Int

Int
ndiv
Int



num

Int

Int	
ndiv
Int



num

Int

No
w
if
w
e
dene
f
x
y
	n

	f
x
	n
"

"
f
y
	n
"

ndiv

ev
erything
w
orks
jf
x
y
	n


n
	x
"
y
j

j		f
x
	n
"

"
f
y
	n
"

ndiv



n
	x
"
y
j



"
j	f
x
	n
"

"
f
y
	n
"



n
	x
"
y
j



"


j	f
x
	n
"

"
f
y
	n
"



n

	x
"
y
j



"


jf
x
	n
"



n

xj
"


jf
y
	n
"



n

y
j



"



"





Accordingly
w
e
mak
e
our
denition
let
realadd
f
g
n

fn



gn


ndiv
Int

W
e
can
dene
subtraction
similarly

but
the
simplest
approac
h
is
to
build
it
out
of
the
functions
that
w
e
already
ha
v
e
let
realsub
f
g

realadd
f
realneg
g
realsub

num
	
num
	
num
	
num
	
num
	
num

fun	


CHAPTER
	
EXAMPLES
It
is
a
bit
tric
kier
to
dene
m
ultiplication
in
v
erses
and
division
Ho
w
ev
er
the
cases
where
w
e
m
ultiply
or
divide
b
y
an
in
teger
are
m
uc
h
easier
and
quite
common
It
is
w
orth
while
implemen
ting
these
separately
as
they
can
b
e
made
more
ecien
t
W
e
dene
f
mx
	n

	mf
x
	n
"
p
"

ndiv

p

where
p
is
c
hosen
so
that

p

jmj
F
or
correctness
w
e
ha
v
e
jf
mx
	n


n
	mxj



"
j
mf
x
	n
"
p
"


p



n
	mxj



"
jmj

p

jf
x
	n
"
p
"



n
p

xj



"
jmj

p




"


jmj

p



"




In
order
to
implemen
t
this
w
e
need
a
function
to
nd
the
appropriate
p
The
follo
wing
is
crude
but
adequate
let
log

let
rec
log
x
y

if
x

Int

then
y
else
log
quonum
x
Int

y


in
fun
x
	
log
x

Int



The
implemen
tation
is
simply
let
realintmul
m
x
n

let
p

log
absnum
m
in
let
p

p


in
m

xn

p
ndiv
Int


Int
p
F
or
division
b
y
an
in
teger
w
e
dene
f
xm
	n

f
x
	n
ndiv
m
F
or
correctness
w
e
can
ignore
the
trivial
cases
when
m


whic
h
should
nev
er
b
e
used
and
when
m


since
then
the
result
is
exact
Otherwise
w
e
assume
jf
x
	n


n
xj


so
jf
x
	nm


n
xmj


jmj




whic
h
together
with
the
fact
that
jf
x
	n
ndiv
m

f
x
	nmj




yields
the
result
So
w
e
ha
v
e
let
realintdiv
m
x
n

xn
ndiv
Int
m

	
EXA
CT
REAL
ARITHMETIC

	
General
m
ultiplication
General
m
ultiplication
is
harder
b
ecause
the
error
in
appro
ximation
for
one
n
um
b
er
is
m
ultiplied
b
y
the
magnitude
of
the
second
n
um
b
er
Therefore
b
efore
the
nal
accuracies
are
calculated
a
preliminary
ev
aluation
of
the
argumen
ts
is
required
to
determine
their
appro
ximate
magnitude
W
e
pro
ceed
as
follo
ws
Sup
p
ose
that
w
e
w
an
t
to
ev
aluate
x
"
y
to
precision
n
First
w
e
c
ho
ose
r
and
s
so
that
jr

sj


and
r
"
s

n
"

That
is
b
oth
r
and
s
are
sligh
tly
more
than
half
the
required
precision
W
e
no
w
ev
aluate
f
x
	r

and
f
y
	s
and
select
natural
n
um
b
ers
p
and
q
that
are
the
corresp
onding
binary
logarithms
ie
jf
x
	r
j


p
and
jf
y
	sj


q

If
b
oth
p
and
q
are
zero
then
it
is
easy
to
see
that
w
e
ma
y
return
just

Otherwise
remem
b
er
that
either
p


or
q


as
w
e
will
need
this
later
No
w
set
k

n
"
q

s
"


q
"
r
"

l

n
"
p

r
"


p
"
s
"

m

	k
"
l


n

p
"
q
"

W
e
claim
that
f
xy
	n

	f
x
	k
f
y
	l

ndiv

m
has
the
righ
t
error
b
eha
viour
ie
jf
xy
	n


n
	xy
j


If
w
e
write

k
x

f
x
	k

"


l
y

f
y
	l

"

with
j
j


and
jj


w
e
ha
v
e
jf
xy
	n


n
	xy
j



"
j
f
x
	k
f
y
	l


m


n
	xy
j



"

m
jf
x
	k
f
y
	l



k

l
xy
j



"

m
jf
x
	k
f
y
	l


	f
x
	k

"

	f
y
	l

"
j



"

m
j
f
y
	l

"
f
x
	k

"

j



"

m
	j
f
y
	l
j
"
jf
x
	k
j
"
j
j



"

m
	jf
y
	l
j
"
jf
x
	k
j
"
j
j



"

m
	jf
y
	l
j
"
jf
x
	k
j
"

No
w
w
e
ha
v
e
jf
x
	r
j


p

so
j
r
xj


p
"

Th
us
j
k
xj


q


	
p
"

so
jf
x
	k
j


q


	
p
"

"

ie
jf
x
	k
j


q


	
p
"

Similarly
jf
y
	l
j


p

	
q
"

Consequen
tly


CHAPTER
	
EXAMPLES
jf
y
	l
j
"
jf
x
	k
j
"



p

	
q
"

"

q


	
p
"

"



p
q


"

p

"

p
q


"

q


"



p
q


"

p

"

q


"

No
w
for
our
error
b
ound
w
e
require
jf
y
	l
j
"
jf
x
	k
j
"



m

or
dividing
b
y

and
using
the
discreteness
of
the
in
tegers

p
q


"

p
"

q


p
q


W
e
can
write
this
as
	
p
q
"

p

"
	
p
q
"

q



p
q


"

p
q



whic
h
is
true
b
ecause
w
e
ha
v
e
either
p


or
q


So
at
last
w
e
are
justied
in
dening
let
realmul
x
y
n

let
n

n


in
let
r

n


in
let
s

n

r
in
let
xr

xr
and
ys

ys
in
let
p

log
xr
and
q

log
ys
in
if
p


"
q


then
Int

else
let
k

q

r


and
l

p

s


and
m

p

q


in
xk

yl
ndiv
Int


Int
m
	
Multiplicativ
e
in
v
erse
Next
w
e
will
dene
the
m
ultiplicativ
e
in
v
erse
function
In
order
to
get
an
y
sort
of
upp
er
b
ound
on
this
let
alone
a
go
o
d
appro
ximation
w
e
need
to
get
a
lower
b
ound
for
the
argumen
t
In
general
there
is
no
b
etter
w
a
y
than
to
k
eep
ev
aluating
the
argumen
t
with
greater
and
greater
accuracy
un
til
w
e
can
b
ound
it
a
w
a
y
from
zero
W
e
will
use
the
follo
wing
lemma
to
justify
the
correctness
of
our
pro
cedure
Lemma
	
If
e

n
"
k
"

jf
x
	k
j


e
and
jf
x
	k



k
xj


wher
e
f
x
	k

is
an
inte
ger
and
e
n
and
k
ar
e
natur
al
numb
ers
then
if
we
dene
f
y
	n


n
k
ndiv
f
x
	k

we
have
jf
y
	n


n
x

j


ie
the
r
e
quir
e
d
b
ound
Pro
of
The
pr
o
of
is
r
ather
te
dious
and
wil
l
not
b
e
given
in
ful
l
We
just
sketch
the
ne
c
essary
c
ase
splits
If
jf
x
	k
j


e
then
a
str
aightforwar
d
analysis
gives
the
r
esult
the
r
ounding
in
ndiv
gives
an
err
or
of
at
most



and
the
r
emaining
err
or
is




If
jf
x
	k
j


e
but
n
"
k

e
then
although
the
se
c
ond
c
omp
onent
of
the

	
EXA
CT
REAL
ARITHMETIC

err
or
may
now
b
e
twic
e
as
much
ie


ther
e
is
no
r
ounding
err
or
b
e
c
ause
f
x
	k



e
divides
into

n
k
exactly
We
use
her
e
the
fact
that

e




e

b
e
c
ause
sinc
e
e

n
"
k
"

e
c
annot
b
e
zer
o
Final
ly
if
jf
x
	k
j


e
and
n
"
k

e
we
have
jf
y
	n


n

x
j


b
e
c
ause
b
oth
jf
y
	nj


and


j
n

x
j


and
b
oth
these
numb
ers
have
the
same
sign
QED
No
w
supp
ose
w
e
wish
to
nd
the
in
v
erse
of
x
to
accuracy
n
First
w
e
ev
aluate
f
x
	
There
are
t
w
o
cases
to
distinguish

If
jf
x
	j


r
for
some
natural
n
um
b
er
r

then
c
ho
ose
the
least
natural
n
um
b
er
k
	whic
h
ma
y
w
ell
b
e
zero
suc
h
that
r
"
k

n
"

and
set
e

r
"
k

W
e
no
w
return

n
k
ndiv
f
x
	k

It
is
easy
to
see
that
the
conditions
of
the
lemma
are
satised
Since
jf
x
	j


r
"

w
e
ha
v
e
jxj


r

and
so
j
k
xj


r

k

This
means
jf
x
	k
j


r

k


and
as
f
x
	k

is
an
in
teger
jf
x
	k
j


r

k


e
as
required
The
condition
that
e

n

k
"

is
easy
to
c
hec
k
Note
that
if
r

n
w
e
can
immediately
deduce
that
f
y
	n


is
a
v
alid
appro
ximation

If
jf
x
	j


then
w
e
call
the
function
msd
that
returns
the
least
p
suc
h
that
jf
x
	pj


Note
that
this
ma
y
in
general
fail
to
terminate
if
x


No
w
w
e
set
e

n
"
p
"

and
k

e
"
p
and
return

n
k
ndiv
f
x
	k

Once
again
the
conditions
for
the
lemma
are
satised
Since
jf
x
	pj


w
e
ha
v
e
j
p
xj


ie
jxj



p

Hence
j
k
xj


k
p


e

and
so
jf
x
	k
j


e


ie
jf
x
	k
j


e

T
o
implemen
t
this
w
e
rst
dene
the
msd
function
let
msd

let
rec
msd
n
x

if
absnumxn
	
Int

then
n
else
msd
n


x
in
msd


and
then
translate
the
ab
o
v
e
mathematics
in
to
a
simple
program
let
realinv
x
n

let
x

x

in
let
k

if
x
	
Int

then
let
r

log
x


in
let
k

n





r
in
if
k


then

else
k
else
let
p

msd
x
in
n



p


in
Int


Int
n

k
ndiv
xk
No
w
of
course
it
is
straigh
tforw
ard
to
dene
division
let
realdiv
x
y

realmul
x
realinv
y


CHAPTER
	
EXAMPLES
	
Ordering
relations
The
in
teresting
things
ab
out
all
these
functions
is
that
they
are
in
fact
uncom
putable
in
general
The
essen
tial
p
oin
t
is
that
it
is
imp
ossible
to
decide
whether
a
giv
en
n
um
b
er
is
zero
W
e
can
k
eep
appro
ximating
it
to
greater
and
greater
accuracy

but
if
the
appro
ximations
alw
a
ys
return

w
e
cannot
tell
whether
it
is
going
to
do
so
indenitely
or
whether
the
next
step
will
giv
e
a
nonzero
answ
er

If
x
is
not
zero
then
the
searc
h
will
ev
en
tually
terminate
but
if
x
is
zero
it
will
run
forev
er
Accepting
this
it
is
not
dicult
to
dene
the
relational
op
erators
T
o
decide
the
ordering
relation
of
x
and
y
it
suces
to
nd
an
n
suc
h
that
jx
n

y
n
j


F
or
example
if
x
n

y
n
"

w
e
ha
v
e

n
x

x
n



y
n
"



n
y
and
so
x

y

W
e
rst
write
a
general
pro
cedure
to
p
erform
this
searc
h
and
then
dene
all
the
orderings
in
terms
of
it
Note
that
the
only
w
a
y
to
arriv
e
at
the
reexiv
e
orderings
is
to
justify
the
irreexiv
e
v
ersion!
let
separate

let
rec
separate
n
x
y

let
d

xn

yn
in
if
absnumd
	
Int

then
d
else
separate
n


x
y
in
separate


let
realgt
x
y

separate
x
y
	
Int


let
realge
x
y

realgt
x
y
let
reallt
x
y

separate
x
y

Int


let
realle
x
y

reallt
x
y
	
Cac
hing
In
order
to
try
out
all
the
ab
o
v
e
functions
w
e
w
ould
lik
e
to
b
e
able
to
prin
t
out
a
decimal
represen
tation
of
some
appro
ximation
to
a
real
This
is
not
hard
using
some
more
standard
facilities
in
the
CAML
library

If
d
decimal
places
are
desired
then
w
e
mak
e
n
suc
h
that

n


d
and
hence
the
accuracy
corresp
onds
at
least
to
the
n
um
b
er
of
digits
prin
ted
let
view
x
d

let
n



d
in
let
out

xn

Int


Int
n
in
approxnumfix
d
out

F
or
a
pro
of
that
it
is
uncomputable
simply
wrap
up
the
halting
problem
b
y
dening
f
n


if
a
certain
T
uring
mac
hine
has
halted
after
no
more
than
n
iterations
and
f
n


otherwise

	
EXA
CT
REAL
ARITHMETIC
	
No
w
w
e
can
test
out
some
simple
examples
whic
h
seem
to
w
ork
let
x

realofint

x

int
	
num

fun	
let
xi

realinv
x
xi

int
	
num

fun	
let
wun

realmul
x
xi
wun

int
	
num

fun	
view
x


it

string






















view
xi


it

string


view
wun


it

string






















Ho
w
ev
er
there
is
a
subtle
and
serious
bug
in
our
implemen
tation
whic
h
sho
ws
itself
if
w
e
try
larger
expressions
The
problem
is
that
sub
expressions
can
b
e
ev
aluated
man
y
times
Most
ob
viously

this
happ
ens
if
they
o
ccur
sev
eral
times
in
the
input
expression
But
ev
en
if
they
dont
the
m
ultiplication
and
ev
en
more
so
the
in
v
erse
require
trial
ev
aluations
at
diering
accuracies
As
the
ev
aluation
propagates
do
wn
to
the
b
ottom
lev
el
there
is
often
an
exp
onen
tial
buildup
of
reev
aluations
F
or
example
the
follo
wing
is
slo
w

it
tak
es
sev
eral
seconds
let
x

realofint

in
let
x

realmul
x
x
in
let
x

realmul
x
x
in
let
x

realmul
x
x
in
let
x

realmul
x
x
in
let
x

realmul
x
x
in
let
x

realmul
x
x
in
view
x




string












W
e
can
x
this
problem
using
the
idea
of
c
aching
or
memo
functions
	Mic
hie
	
W
e
giv
e
eac
h
function
a
reference
cell
to
remem
b
er
the
most
accurate
v
ersion
already
calculated
If
there
is
a
second
request
for
the
same
accuracy

it
can
b
e
returned
immediately
without
further
ev
aluation
Whats
more
w
e
can
alw
a
ys
construct
a
lo
w
erlev
el
appro
ximation
sa
y
n
from
a
higher
one
sa
y
n
"
k
with
k


If
w
e
kno
w
that
jf
x
	n
"
k



n
k
xj


then
w
e
ha
v
e
jf
x
	n
"
k

ndiv

k


n
xj



"
j
f
x
	n
"
k


k


n
xj



"


k
jf
x
	n
"
k



n
k
xj



"


k




CHAPTER
	
EXAMPLES
Hence
w
e
are
alw
a
ys
safe
in
returning
f
x
	n
"
k

ndiv

k

W
e
can
implemen
t
this
memo
tec
hnique
via
a
generic
function
memo
to
b
e
inserted
in
eac
h
of
the
previous
functions
let
realofint
k

memo
fun
n
	
Int


Int
n

Int
k
let
realneg
f

memo
fun
n
	
minusnumf
n
let
realabs
f

memo
fun
n
	
absnum
f
n
let
realadd
f
g

memo
fun
n
	
fn



gn


ndiv
Int

let
realsub
f
g

realadd
f
realneg
g
let
realintmul
m
x

memo
fun
n
	
let
p

log
absnum
m
in
let
p

p


in
m

xn

p
ndiv
Int


Int
p
let
realintdiv
m
x

memo
fun
n
	
xn
ndiv
Int
m
let
realmul
x
y

memo
fun
n
	
let
n

n


in
let
r

n


in
let
s

n

r
in
let
xr

xr
and
ys

ys
in
let
p

log
xr
and
q

log
ys
in
if
p


"
q


then
Int

else
let
k

q

r


and
l

p

s


and
m

p

q


in
xk

yl
ndiv
Int


Int
m
let
realinv
x

memo
fun
n
	
let
x

x

in
let
k

if
x
	
Int

then
let
r

log
x


in
let
k

n





r
in
if
k


then

else
k
else
let
p

msd
x
in
n



p


in
Int


Int
n

k
ndiv
xk
let
realdiv
x
y

realmul
x
realinv
y
where

	
PR
OLOG
AND
THEOREM
PR
O
VING

let
memo
f

let
mem

ref
Int


in
fun
n
	
let
mres

#mem
in
if
n

m
then
if
m

n
then
res
else
res
ndiv
Int


Intm

n
else
let
res

f
n
in
mem

nres
res
No
w
the
ab
o
v
e
sequence
of
m
ultiplications
is
instan
taneous
Here
are
a
few
more
examples
let
pi

realdiv
realofint

realofint

pi

int
	
num

fun	
view
pi


it

string

	
let
pi

realdiv
realofint

realofint

pi

int
	
num

fun	
view
pi


it

string

		

let
pidiff

realsub
pi
pi
pidiff

int
	
num

fun	
view
pidiff


it

string







let
ipidiff

realinv
pidiff
ipidiff

int
	
num

fun	
view
ipidiff


it

string

	




















Of
course
ev
erything
w
e
ha
v
e
done
to
date
could
b
e
done
with
rational
arith
metic
Actually

it
ma
y
happ
en
that
our
approac
h
is
more
ecien
t
in
certain
situations
since
w
e
a
v
oid
calculating
n
um
b
ers
that
migh
t
ha
v
e
immense
n
umer
ators
and
denominators
when
w
e
just
need
an
appro
ximation
Nev
ertheless
the
presen
t
approac
h
really
comes
in
to
its
o
wn
when
w
e
w
an
t
to
dene
transcenden
tal
functions
lik
e
exp
sin
etc
W
e
will
not
co
v
er
this
in
detail
for
lac
k
of
space
but
it
mak
es
an
in
teresting
exercise
One
approac
h
is
to
use
truncated
T
a
ylor
series
Note
that
nite
summations
can
b
e
ev
aluated
directly
rather
than
b
y
iterating
the
addition
function
this
leads
to
m
uc
h
b
etter
error
b
eha
viour
	
Prolog
and
theorem
pro
ving
The
language
Prolog
is
p
opular
in
Articial
In
telligence
researc
h
and
is
used
in
v
arious
practical
applications
suc
h
as
exp
ert
systems
and
in
telligen
t
databases
Here
w
e
will
sho
w
ho
w
the
main
mec
hanism
of
Prolog
namely
depthrst
searc
h
through
a
database
of
rules
using
unication
and
bac
ktrac
king
can
b
e
imple
men
ted
in
ML
W
e
do
not
pretend
that
this
is
a
fullblo
wn
implemen
tation
of


CHAPTER
	
EXAMPLES
Prolog
but
it
giv
es
an
accurate
picture
of
the
general
a
v
our
of
the
language
and
w
e
will
b
e
able
to
run
some
simple
examples
in
our
system
	
Prolog
terms
Prolog
co
de
and
data
is
represen
ted
using
a
uniform
system
of
rst
order
terms
W
e
ha
v
e
already
dened
a
t
yp
e
of
terms
for
our
mathematical
expressions
and
asso
ciated
parsers
and
prin
ters
Here
w
e
will
use
something
similar
but
not
quite
the
same
First
of
all
it
simplies
some
of
the
co
de
if
w
e
treat
constan
ts
as
n
ullary
functions
ie
functions
that
tak
e
an
empt
y
list
of
argumen
ts
Accordingly
w
e
dene
type
term

Var
of
string

Fn
of
string

term
list
Where
w
e
w
ould
formerly
ha
v
e
used
Const
s
w
e
will
no
w
use
Fns
Note
that
w
e
will
treat
functions
of
dieren
t
arities
	dieren
t
n
um
b
ers
of
argumen
ts
as
distinct
ev
en
if
they
ha
v
e
the
same
name
Th
us
there
is
no
danger
of
our
confusing
constan
ts
with
true
functions
	
Lexical
analysis
In
order
to
follo
w
Prolog
con
v
en
tions
whic
h
include
case
sensitivit
y

w
e
also
mo
dify
lexical
analysis
W
e
will
not
attempt
to
conform
exactly
to
the
full
details
of
Prolog
but
one
feature
is
v
ery
imp
ortan
t
alphan
umeric
iden
tiers
that
b
egin
with
an
upp
er
c
ase
letter
or
an
underscore
are
treated
as
v
ariables
while
other
alphan
umeric
iden
tiers
along
with
n
umerals
are
treated
as
constan
ts
F
or
example
X
and
Answer
are
v
ariables
while
x
and
john
are
constan
ts
W
e
will
lump
all
sym
b
olic
iden
tiers
together
as
constan
ts
to
o
but
w
e
will
distinguish
the
punctuation
sym
b
ols
left
and
righ
t
brac
k
ets
commas
and
semicolons
Non
punctuation
sym
b
ols
are
collected
together
in
to
the
longest
strings
p
ossible
so
sym
b
olic
iden
tiers
need
not
consist
only
of
one
c
haracter
type
token

Variable
of
string

Constant
of
string

Punct
of
string
The
lexer
therefore
lo
oks
lik
e
this

	
PR
OLOG
AND
THEOREM
PR
O
VING

let
lex

let
several
p

many
some
p
in
let
collectht

hitlist
prefix

t

in
let
upperalpha
s

A

s
"
s

Z
or
s


and
loweralpha
s

a

s
"
s

z
or



s
"
s

	
and
punct
s

s


or
s


or
s

 
or
s

!
or
s


or
s


and
space
s

s



or
s

&n
or
s

&t
in
let
alphanumeric
s

upperalpha
s
or
loweralpha
s
in
let
symbolic
s

not
space
s
"
not
alphanumeric
s
"
not
punct
s
in
let
rawvariable

some
upperalpha

several
alphanumeric
		
Variable
o
collect
and
rawconstant

some
loweralpha

several
alphanumeric

some
symbolic

several
symbolic
		
Constant
o
collect
and
rawpunct

some
punct
		
Punct
in
let
token

rawvariable

rawconstant

rawpunct

several
space
		
fst
in
let
tokens

several
space

many
token
		
snd
in
let
alltokens

tokens

finished
		
fst
in
fst
o
alltokens
o
explode
F
or
example
lex
addXYZ

X
is
YZ


token
list

 Constant
add
Punct

Variable
X
Punct

Variable
Y
Punct

Variable
Z
Punct

Constant

Variable
X
Constant
is
Variable
Y
Constant

Variable
Z
Punct
!
	
P
arsing
The
basic
parser
is
prett
y
m
uc
h
the
same
as
b
efore
the
prin
ter
is
exactly
the
same
The
main
mo
dication
to
the
prin
ter
is
that
w
e
allo
w
Prolog
lists
to
b
e
written
in
a
more
con
v
enien
t
notation
Prolog
has

and
nil
corresp
onding
to
MLs

and

and
w
e
set
up
the
parser
so
that
lists
can
b
e
written
m
uc
h
as
in
ML
eg

W
e
also
allo
w
the
Prolog
notation
H#T
instead
of
consHT
t
ypically
used
for
patternmatc
hing
After
the
basic
functions
let
variable

fun
Variable
srest
	
srest


	
raise
Noparse
let
constant

fun
Constant
srest
	
srest


	
raise
Noparse


CHAPTER
	
EXAMPLES
w
e
ha
v
e
a
parser
for
terms
and
also
for
Prolog
rules
of
these
forms
ter
m
ter
m

ter
m




ter
m
The
parsers
are
as
follo
ws
let
rec
atom
input

constant

a
Punct


termlist

a
Punct

		
fun
nameargs
	
Fnnameargs

constant
		
fun
s
	
Fns !

variable
		
fun
s
	
Var
s

a
Punct


term

a
Punct

		
snd
o
fst

a
Punct
 

list
		
snd
input
and
term
input

precedence
#infixes
atom
input
and
termlist
input

term

a
Punct


termlist
		
fun
ht
	
ht

term
		
fun
h
	
 h!
input
and
list
input

term

a
Constant


term

a
Punct
!
		
snd
o
fst

a
Punct


list
		
snd

a
Punct
!
		
K
Fn ! !
		
fun
ht
	
Fn h
t!

a
Punct
!
		
K
Fn ! !
input
and
rule
input

term

a
Punct

		
K
 !

a
Constant


term

many
a
Punct


term
		
snd

a
Punct

		
fun
ht
	
ht
input
let
parseterm

fst
o
term

finished
		
fst
o
lex
let
parserules

fst
o
many
rule

finished
		
fst
o
lex
	
Unication
Prolog
uses
a
set
of
rules
to
solv
e
a
curren
t
go
al
b
y
trying
to
matc
h
one
of
the
rules
against
the
goal
A
rule
consisting
of
a
single
term
can
solv
e
a
goal
immediately


	
PR
OLOG
AND
THEOREM
PR
O
VING

In
the
case
of
a
rule
ter
m

ter
m






ter
m
n

if
the
goal
matc
hes
ter
m
then
Prolog
needs
to
solv
e
eac
h
ter
m
i
as
a
subgoal
in
order
to
nish
the
original
goal
Ho
w
ev
er
goals
and
rules
do
not
ha
v
e
to
b
e
exactly
the
same
Instead
Prolog
assigns
v
ariables
in
b
oth
the
goal
and
the
rule
to
mak
e
them
matc
h
up
a
pro
cess
kno
wn
as
unic
ation
This
means
that
w
e
can
end
up
pro
ving
a
sp
ecial
case
of
the
original
goal
eg
P
	f
	X

instead
of
P
	Y

F
or
example

T
o
unify
f
	g
	X

Y

and
f
	g
	a
X

w
e
can
set
X

a
and
Y

a
Then
b
oth
terms
are
f
	g
	a
a

T
o
unify
f
	a
X

Y

and
f
	X

a
Z

w
e
can
set
X

a
and
Y

Z

and
then
b
oth
terms
are
f
	a
a
Z


It
is
imp
ossible
to
unify
f
	X

and
X

In
general
uniers
are
not
unique
F
or
example
in
the
second
example
w
e
could
c
ho
ose
to
set
Y

f
	b
and
Z

f
	b
Ho
w
ev
er
one
can
alw
a
ys
c
ho
ose
one
that
is
most
gener
al
ie
an
y
other
unication
can
b
e
reac
hed
from
it
b
y
further
instan
tiation
	compare
most
general
t
yp
es
in
ML
In
order
to
nd
it
roughly
sp
eaking
one
need
only
descend
the
t
w
o
terms
recursiv
ely
in
parallel
and
on
nding
a
v
ariable
on
either
side
assigns
it
to
whatev
er
the
term
on
the
other
side
is
One
also
needs
to
c
hec
k
that
the
v
ariable
hasnt
already
b
een
assigned
to
something
else
and
that
it
do
esnt
o
ccur
in
the
term
b
eing
assigned
to
it
	as
in
the
last
example
ab
o
v
e
A
simple
implemen
tation
of
this
idea
follo
ws
W
e
main
tain
an
asso
ciation
list
giving
instan
tiations
already
made
and
w
e
lo
ok
eac
h
v
ariable
up
to
see
if
it
is
already
assigned
b
efore
pro
ceeding
W
e
use
the
existing
instan
tiations
as
an
accum
ulator
let
rec
unify
tm
tm
insts

match
tm
with
Varx
	
try
let
tm

assoc
x
insts
in
unify
tm
tm
insts
with
Notfound
	
augment
xtm
insts

Fnfargs
	
match
tm
with
Vary
	
try
let
tm

assoc
y
insts
in
unify
tm
tm
insts
with
Notfound
	
augment
ytm
insts

Fnfargs
	
if
f

f
then
itlist
unify
args
args
insts
else
raise
error
functions
do
not
match


CHAPTER
	
EXAMPLES
where
the
instan
tiation
lists
need
to
b
e
augmen
ted
with
some
care
to
a
v
oid
the
socalled
o
ccurs
c
hec
k
problem
W
e
m
ust
disallo
w
instan
tiation
of
X
to
a
non
trivial
term
in
v
olving
X

as
in
the
third
example
ab
o
v
e
Most
real
Prologs
ignore
this
either
for
	claimed
eciency
reasons
or
in
order
to
allo
w
w
eird
cyclic
datas
tructures
instead
of
simple
rst
order
terms
let
rec
occursin
x

fun
Var
y
	
x

y

Fnargs
	
exists
occursin
x
args
let
rec
subst
insts

fun
Var
y
	
try
assoc
y
insts
with
Notfound
	
tm

Fnfargs
	
Fnfmap
subst
insts
args
let
rawaugment

let
augment
theta
xs

let
s

subst
theta
s
in
if
occursin
x
s
"
nots

Varx
then
raise
error
Occurs
check
else
xs
in
fun
p
insts
	
pmap
augment
 p!
insts
let
augment
vt
insts

let
t

subst
insts
t
in
match
t
with
Varw
	
if
w

v
then
if
w

v
then
insts
else
rawaugment
vt
insts
else
rawaugment
wVarv
insts


	
if
occursin
v
t
then
raise
error
Occurs
check
else
rawaugment
vt
insts
	
Bac
ktrac
king
Prolog
pro
ceeds
b
y
depthrst
searc
h
but
it
ma
y
bac
ktrac
k
ev
en
if
a
rule
uni
es
successfully

if
all
the
remaining
goals
cannot
b
e
solv
ed
under
the
resulting
instan
tiations
then
another
initial
rule
is
tried
Th
us
w
e
consider
the
whole
list
of
goals
rather
than
one
at
a
time
to
giv
e
the
righ
t
con
trol
strategy


	
PR
OLOG
AND
THEOREM
PR
O
VING

let
rec
first
f

fun
 !
	
raise
error
No
rules
applicable

ht
	
try
f
h
with
error

	
first
f
t
let
rec
expand
n
rules
insts
goals

first
fun
rule
	
if
goals

 !
then
insts
else
let
concasms

renamerule
stringofint
n
rule
in
let
insts

unify
conc
hd
goals
insts
in
let
localglobal

partition
fun
v
	
occursin
v
conc
or
exists
occursin
v
asms
insts
in
let
goals

map
subst
local
asms
'
tl
goals
in
expand
n


rules
global
goals
rules
Here
w
e
use
a
function
rename
to
generate
fresh
v
ariables
for
the
rules
eac
h
time
let
rec
rename
s

fun
Var
v
	
Var(vs

Fnfargs
	
Fnfmap
rename
s
args
let
renamerule
s
concasms

rename
s
concmap
rename
s
asms
Finally

w
e
can
pac
k
age
ev
erything
together
in
a
function
prolog
that
tries
to
solv
e
a
giv
en
goal
using
the
giv
en
rules
type
outcome

No

Yes
of
string

term
list
let
prolog
rules
goal

try
let
insts

expand

rules
 !
 goal!
in
Yesfilter
fun
v
	
occursin
v
goal
insts
with
error

	
No
This
sa
ys
either
that
the
goal
cannot
b
e
solv
ed
or
that
it
can
b
e
solv
ed
with
the
giv
en
instan
tiations
Note
that
w
e
only
return
one
answ
er
in
this
latter
case
but
this
is
easy
to
c
hange
if
desired
	
Examples
W
e
can
use
the
Prolog
in
terpreter
just
written
to
try
some
simple
examples
from
Prolog
textb
o
oks
F
or
example


CHAPTER
	
EXAMPLES
let
rules

parserules
malealbert
maleedward
femalealice
femalevictoria
parentsedwardvictoriaal
bert

parentsalicevictoriaalb
ert

sisterofXY

femaleX
parentsXMF
parentsYMF
rules

term

term
list
list

 %malealbert%
 !
%maleedward%
 !
%femalealice%
 !
%femalevictoria%
 !
%parentsedwardvictori
aal
bert
%
 !
%parentsalicevictoria
alb
ert
%
 !
%sisterofXY%
 %femaleX%
%parentsXMF%
%parentsYMF%!!
prolog
rules
sisterofaliceedward



outcome

Yes
 !
prolog
rules
parseterm
sisterofaliceX


outcome

Yes
 X
%edward%!
prolog
rules
parseterm
sisterofXY


outcome

Yes
 Y
%edward%
X
%alice%!
The
follo
wing
are
similar
to
some
elemen
tary
ML
list
op
erations
Since
Prolog
is
relational
rather
than
functional
it
is
p
ossible
to
use
Prolog
queries
in
a
more
exible
w
a
y

eg
ask
what
argumen
ts
w
ould
giv
e
a
certain
result
rather
than
vice
v
ersa
let
r

parserules
append !LL
append HT!L HA!

appendTLA
r

term

term
list
list

 %append !LL%
 !
%appendH

TLH

A%
 %appendTLA%!!
prolog
r
parseterm
append ! ! !




outcome

Yes
 !
prolog
r
parseterm
append ! !X



outcome

Yes
 X
%







 !%!
prolog
r
parseterm
append !XX


outcome

No
prolog
r
parseterm
append !XY


outcome

Yes
 Y
%



X%!
In
suc
h
cases
Prolog
seems
to
b
e
sho
wing
an
impressiv
e
degree
of
in
telligence
Ho
w
ev
er
under
the
surface
it
is
just
using
a
simple
searc
h
strategy

and
this
can
easily
b
e
th
w
arted
F
or
example
the
follo
wing
lo
ops
indenitely
prolog
r
parseterm
appendX !X

	
PR
OLOG
AND
THEOREM
PR
O
VING
	
	
Theorem
pro
ving
Prolog
is
acting
as
a
simple
theorem
pro
v
er
using
a
database
of
logical
facts
	the
rules
in
order
to
pro
v
e
a
goal
Ho
w
ev
er
it
is
rather
limited
in
the
facts
it
can
pro
v
e
partly
b
ecause
its
depthrst
searc
h
strategy
is
incomplete
and
partly
b
ecause
it
can
only
mak
e
logical
deductions
in
certain
patterns
It
is
p
ossible
to
mak
e
Prologlik
e
systems
that
are
more
p
o
w
erful
eg
see
Stic
k
el
		
In
what
follo
ws
w
e
will
just
sho
w
ho
w
to
build
a
more
capable
theorem
pro
v
er
using
essen
tially
similar
tec
hnology

including
the
unication
co
de
and
an
iden
tical
bac
ktrac
king
strategy

In
particular
unication
is
an
eectiv
e
w
a
y
of
deciding
ho
w
to
sp
ecialize
univ
ersally
quan
tied
v
ariables
F
or
example
giv
en
the
facts
that
X

p	X


q
	X

and
p	f
	a
w
e
can
unify
the
t
w
o
expressions
in
v
olving
p
and
th
us
disco
v
er
that
w
e
need
to
set
X
to
f
	a
By
con
trast
the
v
ery
earliest
theorem
pro
v
ers
tried
all
p
ossible
terms
built
up
from
the
a
v
ailable
constan
ts
and
functions
	the
Herbrand
base
Usually

depthrst
searc
h
w
ould
go
in
to
an
innite
lo
op
so
w
e
need
to
mo
dify
the
Prolog
strategy
sligh
tly

W
e
will
use
depth
rst
iter
ative
de
ep
ening
This
means
that
the
searc
h
depth
has
a
hard
limit
and
attempts
to
exceed
it
cause
bac
ktrac
king
Ho
w
ev
er
if
no
pro
of
is
found
at
a
giv
en
depth
the
b
ound
is
increased
and
another
attempt
is
made
Th
us
rst
one
searc
hes
for
pro
ofs
of
depth

and
if
that
fails
searc
hes
for
one
of
depth

then
depth

and
so
on
F
or
depth
one
can
use
v
arious
parameters
eg
the
heigh
t
or
o
v
erall
size
of
the
searc
h
tree
w
e
will
use
the
n
um
b
er
of
uniable
v
ariables
in
tro
duced
Manipulating
form
ulas
W
e
will
simply
use
our
standard
rst
order
terms
to
denote
form
ulas
in
tro
ducing
new
constan
ts
for
the
logical
op
erators
Man
y
of
these
are
written
inx
Op
erator
Meaning
'	p
not
p
p
"
q
p
and
q
p
#
q
p
or
q
p

q
p
implies
q
p

q
p
if
and
only
if
q
forall	Xp
for
all
X
p
exists	Xp
there
exists
an
X
suc
h
that
p
An
alternativ
e
w
ould
b
e
to
in
tro
duce
a
separate
t
yp
e
of
form
ulas
but
this
w
ould
require
separate
parsing
and
prin
ting
supp
ort
W
e
will
a
v
oid
this
for
the
sak
e
of
simplicit
y



CHAPTER
	
EXAMPLES
Prepro
cessing
form
ulas
Its
con
v
enien
t
if
the
main
part
of
the
pro
v
er
need
not
cop
e
with
implications
and
if
and
only
if
s
Therefore
w
e
rst
dene
a
function
that
eliminates
these
in
fa
v
our
of
the
other
connectiv
es
let
rec
proc
tm

match
tm
with
Fn( t!
	
Fn( proc
t!

Fn" t
t!
	
Fn" proc
t
proc
t!

Fn t
t!
	
Fn proc
t
proc
t!

Fn	 t
t!
	
proc
Fn Fn( t!
t!

Fn	 t
t!
	
proc
Fn" Fn	 t
t!
Fn	 t
t!!

Fnforall x
t!
	
Fnforall x
proc
t!

Fnexists x
t!
	
Fnexists x
proc
t!

t
	
t
The
next
step
is
to
push
the
negations
do
wn
the
form
ula
putting
it
in
to
so
called
negation
normal
form
	NNF
W
e
dene
t
w
o
m
utually
recursiv
e
functions
that
create
NNF
for
a
form
ula
and
its
negation
let
rec
nnfp
tm

match
tm
with
Fn( t!
	
nnfn
t

Fn" t
t!
	
Fn" nnfp
t
nnfp
t!

Fn t
t!
	
Fn nnfp
t
nnfp
t!

Fnforall x
t!
	
Fnforall x
nnfp
t!

Fnexists x
t!
	
Fnexists x
nnfp
t!

t
	
t
and
nnfn
tm

match
tm
with
Fn( t!
	
nnfp
t

Fn" t
t!
	
Fn nnfn
t
nnfn
t!

Fn t
t!
	
Fn" nnfn
t
nnfn
t!

Fnforall x
t!
	
Fnexists x
nnfn
t!

Fnexists x
t!
	
Fnforall x
nnfn
t!

t
	
Fn( t!
W
e
will
con
v
ert
the
negation
of
the
input
form
ula
in
to
negation
normal
form
and
the
main
pro
v
er
will
then
try
to
deriv
e
a
con
tradiction
from
it
This
will
suce
to
pro
v
e
the
original
form
ula
The
main
pro
v
er
A
t
eac
h
stage
the
pro
v
er
has
a
curren
t
form
ula
a
list
of
form
ulas
y
et
to
b
e
considered
and
a
list
of
literals
It
is
trying
to
reac
h
a
con
tradiction
The
follo
wing
strategy
is
emplo
y
ed

	
PR
OLOG
AND
THEOREM
PR
O
VING


If
the
curren
t
form
ula
is
p
"
q
then
consider
p
and
q
separately

ie
mak
e
p
the
curren
t
form
ula
and
add
q
to
the
form
ulas
to
b
e
considered

If
the
curren
t
form
ula
is
p
#
q
then
try
to
get
a
con
tradiction
from
p
and
then
one
from
q

If
the
curren
t
form
ula
is
forall	Xp
in
v
en
t
a
new
v
ariable
to
replace
X
the
righ
t
v
alue
can
b
e
disco
v
ered
later
b
y
unication

If
the
curren
t
form
ula
is
exists	Xp
in
v
en
t
a
new
constan
t
to
replace
X

Otherwise
the
form
ula
m
ust
b
e
a
literal
so
try
to
unify
it
with
a
con
tra
dictory
literal

If
this
fails
add
it
to
the
list
of
literals
and
pro
ceed
with
the
next
form
ula
W
e
desire
a
similar
bac
ktrac
king
strategy
to
Prolog
only
if
the
curren
t
in
stan
tiation
allo
w
all
remaining
goals
to
b
e
solv
ed
do
w
e
accept
it
W
e
could
use
lists
again
but
instead
w
e
use
c
ontinuations
A
con
tin
uation
is
a
function
that
is
passed
to
another
function
and
can
b
e
called
from
within
it
to
p
erform
the
rest
of
the
computation
In
our
case
it
tak
es
a
list
of
instan
tiations
and
tries
to
solv
e
the
remaining
goals
under
these
instan
tiations
Th
us
rather
than
explicitly
trying
to
solv
e
all
remaining
goals
w
e
simply
try
calling
the
con
tin
uation
let
rec
prove
fm
unexp
pl
nl
n
cont
i

if
n


then
raise
error
No
proof
else
match
fm
with
Fn" pq!
	
prove
p
qunexp
pl
nl
n
cont
i

Fn pq!
	
prove
p
unexp
pl
nl
n
prove
q
unexp
pl
nl
n
cont
i

Fnforall Var
x
p!
	
let
v

mkvar
in
prove
subst
 xVar
v!
p
unexp' fm!
pl
nl
n


cont
i

Fnexists Var
x
p!
	
let
v

mkvar
in
prove
subst
 xFnv !!
p
unexp
pl
nl
n


cont
i

Fn( t!
	
try
first
fun
t
	
let
i

unify
t
t
i
in
cont
i
pl
with
error

	
prove
hd
unexp
tl
unexp
pl
tnl
n
cont
i

t
	
try
first
fun
t
	
let
i

unify
t
t
i
in
cont
i
nl
with
error

	
prove
hd
unexp
tl
unexp
tpl
nl
n
cont
i


CHAPTER
	
EXAMPLES
W
e
set
up
the
nal
pro
v
er
as
follo
ws
let
prover

let
rec
proveiter
n
t

try
let
insts

prove
t
 !
 !
 !
n
I
 !
in
let
globinsts

filter
fun
v
	
occursin
v
t
insts
in
nglobinsts
with
error

	
proveiter
n


t
in
fun
t
	
proveiter

nnfnprocparseterm
t
This
implemen
ts
the
iterativ
e
deep
ening
strategy

It
tries
to
nd
the
pro
of
with
the
few
est
univ
ersal
instan
tiations
if
it
succeeds
it
returns
the
n
um
b
er
re
quired
and
an
y
toplev
el
instan
tiations
thro
wing
a
w
a
y
instan
tiations
for
in
ternally
created
v
ariables
Examples
Here
are
some
simple
examples
from
P
elletier
		
let
P

prover
p
	
q
	
(q
	
(p
P

int

string

term
list



 !
let
P

prover
p

q
"
r
	
p

q
"
p

r
P

int

string

term
list



 !
let
P

prover
p
	
q

q
	
p
P

int

string

term
list



 !
let
P

prover
existsYforallXpY	
pX


P

int

string

term
list


 !
let
P	

prover
existsXforallYforall
Z
pY	qZ	pX	q
X


P	

int

string

term
list


 !
A
bigger
example
is
the
follo
wing
let
P

prover
livesagatha
"
livesbutler
"
livescharles
"
killedagathaagatha

killedbutleragatha

killedcharlesagatha
"
forallXforallY
killedXY
	
hatesXY
"
(richerXY
"
forallXhatesagathaX
	
(hatescharlesX
"
hatesagathaagatha
"
hatesagathacharles
"
forallXlivesX
"
(richerXagatha
	
hatesbutlerX
"
forallXhatesagathaX
	
hatesbutlerX
"
forallX(hatesXagatha


(hatesXbutler

(hatesXcharles
	
killedagathaagatha
P

int

string

term
list


 !

	
PR
OLOG
AND
THEOREM
PR
O
VING

In
fact
the
pro
v
er
can
w
ork
out
who
dunit
let
P

prover
livesagatha
"
livesbutler
"
livescharles
"
killedagathaagatha

killedbutleragatha

killedcharlesagatha
"
forallXforallY
killedXY
	
hatesXY
"
(richerXY
"
forallXhatesagathaX
	
(hatescharlesX
"
hatesagathaagatha
"
hatesagathacharles
"
forallXlivesX
"
(richerXagatha
	
hatesbutlerX
"
forallXhatesagathaX
	
hatesbutlerX
"
forallX(hatesXagatha


(hatesXbutler

(hatesXcharles
	
killedXagatha
P

int

string

term
list


 X
%agatha%!
F
urther
reading
Sym
b
olic
dieren
tiation
is
a
classic
application
of
functional
languages
Other
sym
b
olic
op
erations
are
ma
jor
researc
h
issues
in
their
o
wn
righ
t

Da
v
enp
ort
Siret
and
T
ournier
		
giv
e
a
readable
o
v
erview
of
what
computer
algebra
systems
can
do
and
ho
w
they
w
ork
P
aulson
		
discusses
the
kind
of
simpli
cation
strategy
w
e
use
here
in
a
m
uc
h
more
general
setting
P
arsing
with
higher
order
functions
is
another
p
opular
example
It
seems
to
ha
v
e
existed
in
the
functional
programming
folklore
for
a
long
time
an
early
treatmen
t
is
giv
en
b
y
Burge
		
Our
presen
tation
has
b
een
inuenced
b
y
the
treatmen
ts
in
P
aulson
			
and
Reade
			
The
rst
denition
of
computable
real
n
um
b
er
in
our
sense
w
as
in
the
orig
inal
pap
er
of
T
uring
		
His
approac
h
w
as
based
on
decimal
expansions
but
he
needed
to
mo
dify
it
	T
uring
	
for
reasons
explored
in
the
exercises
b
elo
w
The
approac
h
to
real
arithmetic
giv
en
here
follo
ws
the
w
ork
of
Bo
ehm
Cart
wrigh
t
ODonnel
and
Riggle
		
More
recen
tly
a
highp
erformance
implemen
tation
in
CAML
Ligh
t
has
b
een
written
b
y
M
,
enissierMorain
			
whose
thesis
	in
F
renc
h
con
tains
detailed
pro
ofs
of
correctness
for
all
the
al
gorithms
for
elemen
tary
transcenden
tal
functions
F
or
an
alternativ
e
approac
h
using
linear
fractional
transformations
see
P
otts
			
Our
approac
h
to
Prolog
searc
h
and
bac
ktrac
king
either
using
lists
or
con
tin
uations
is
fairly
standard
F
or
more
on
implemen
ting
Prolog
see
for
example
Boizumault
			
while
for
more
on
the
actual
use
of
the
language
the
classic
text
b
y
Clo
c
ksin
and
Mellish
		
is
recommended
A
detailed
discussion
of
con
tin
uations
in
their
man
y
guises
is
giv
en
b
y
Reynolds
			
The
unication
algorithm
giv
en
here
is
simple
and
purely
functional
but
rather
inecien
t
F
or


CHAPTER
	
EXAMPLES
faster
imp
erativ
e
algorithms
see
Martelli
and
Mon
tanari
		
Our
theorem
pro
v
er
is
based
on
leanT
A
P
	Bec
k
ert
and
P
osegga
		
F
or
another
imp
ortan
t
theorem
pro
ving
metho
d
con
v
enien
tly
based
on
Prologst
yle
searc
h
lo
ok
at
the
Prolog
T
ec
hnology
Theorem
Pro
v
er
	Stic
k
el
	
Exercises

Mo
dify
the
prin
ter
so
that
eac
h
op
erator
has
an
asso
ciativit
y

used
when
prin
ting
iterated
cases
of
the
op
erator
to
a
v
oid
excessiv
e
paren
theses

The
dieren
tiation
rules
for
in
v
erses
g
	x
and
quotien
ts
f
	xg
	x
are
not
v
alid
when
g
	x


Sev
eral
others
for
functions
lik
e
l
n
are
also
true
only
under
certain
conditions
Actually
most
commercial
computer
algebra
systems
ignore
this
fact
Ho
w
ev
er
try
to
do
b
etter
b
y
writing
a
new
v
ersion
of
the
dieren
tiator
that
not
only
pro
duces
the
deriv
ativ
e
but
also
a
list
of
conditions
that
m
ust
b
e
assumed
for
the
deriv
ativ
e
to
b
e
v
alid

T
ry
programming
a
simple
pro
cedure
for
indenite
in
tegration
In
general
it
will
not
b
e
able
to
do
ev
ery
in
tegral
but
try
to
mak
e
it
understand
a
few
basic
principles


Read
the
do
cumen
tation
for
the
format
library

and
try
to
implemen
t
a
prin
ter
that
b
eha
v
es
b
etter
when
the
output
is
longer
than
one
line

What
happ
ens
if
the
parser
functions
lik
e
term
atom
etc
are
all
etareduced
b
y
deleting
the
w
ord
input
What
happ
ens
if
precedence
is
consisten
tly
etareduced
b
y
deleting
input

Ho
w
w
ell
do
precedence
parsers
generated
b
y
precedence
treat
distinct
op
erators
with
the
same
precedence
Ho
w
can
the
b
eha
viour
b
e
impro
v
ed
Can
y
ou
extend
it
to
allo
w
a
mix
of
left
and
righ
t
asso
ciativ
e
op
erators
F
or
example
one
really
w
an
ts
subtraction
to
asso
ciate
to
the
left

Rewrite
the
parser
so
that
it
giv
es
helpful
error
messages
when
parsing
fails

T
ry
represen
ting
a
real
n
um
b
er
b
y
the
function
that
generates
the
rst
n
digits
in
a
decimal
expansion
Can
y
ou
implemen
t
the
addition
function
	
	
Ho
w
can
y
ou
retain
a
p
ositional
represen
tation
while
making
the
basic
op
erations
computable

In
fact
there
are
algorithms
that
can
in
tegrate
all
algebraic
expressions
not
in
v
olving
sin
l
n
etc

see
Da
v
enp
ort
	


	
PR
OLOG
AND
THEOREM
PR
O
VING


Implemen
t
m
ultiprecision
in
teger
arithmetic
op
erations
y
ourself
Mak
e
y
our
m
ultiplication
algorithm
O
	n
l
og



where
n
is
the
n
um
b
er
of
digits
in
the
argumen
ts

Using
memo
as
w
e
ha
v
e
dened
it
is
it
the
case
that
whatev
er
series
of
argumen
ts
a
function
is
applied
to
it
will
alw
a
ys
giv
e
the
same
answ
er
for
the
same
argumen
t
That
is
are
the
functions
true
mathematical
functions
despite
the
in
ternal
use
of
references

W
rite
a
parserev
aluator
to
read
realv
alued
expressions
and
create
the
func
tional
represen
tation
for
the
answ
er

	
Extend
the
real
arithmetic
routines
to
some
functions
lik
e
exp
and
sin

Our
prepro
cessing
and
negation
normal
form
pro
cess
can
tak
e
exp
onen
tial
time
in
the
length
of
the
input
in
the
case
of
man
y
if
and
only
if
s
Mo
dify
it
so
that
it
is
linear
in
this
n
um
b
er

Extend
the
initial
transformation
in
to
negation
normal
form
so
that
it
giv
es
Sk
olem
normal
form


	
Implemen
t
a
more
ecien
t
unication
algorithm
eg
follo
wing
Martelli
and
Mon
tanari
		

	
Implemen
t
a
v
ersion
of
the
Prolog
T
ec
hnology
Theorem
Pro
v
er
	Stic
k
el
	

Sk
olem
normal
form
is
co
v
ered
in
most
elemen
tary
logic
b
o
oks
eg
Enderton
	


Bibliograph
y
Aagaard
M
and
Leeser
M
			
V
erifying
a
logic
syn
thesis
to
ol
in
Nuprl
A
case
study
in
soft
w
are
v
erication
In
v
Bo
c
hmann
G
and
Probst
D
K
	eds
Computer
A
ide
d
V
eric
ation
Pr
o
c
e
e
dings
of
the
F
ourth
International
Workshop
CA
V
	
V
olume

of
L
e
ctur
e
Notes
in
Computer
Scienc
e
Mon
treal
Canada
pp
	-
Springer
V
erlag
Abramsky

S
			
The
lazy
lam
b
dacalculus
In
T
urner
D
A
	ed
R
ese
ar
ch
T
opics
in
F
unctional
Pr
o
gr
amming
Y
ear
of
Programming
series
pp
-
AddisonW
esley

AdelsonV
elskii
G
M
and
Landis
E
M
		
An
algorithm
for
the
organi
zation
of
information
Soviet
Mathematics
Doklady


	-
Bac
kus
J
		
Can
programming
b
e
lib
erated
from
the
v
on
Neumann
st
yle
A
functional
st
yle
and
its
algebra
of
programs
Communic
ations
of
the
A
CM


-
Barendregt
H
P

		
The
L
amb
da
Calculus
Its
Syntax
and
Semantics
V
ol
ume

of
Studies
in
L
o
gic
and
the
F
oundations
of
Mathematics
North
Holland
Barwise
J
			
Mathematical
pro
ofs
of
computer
correctness
Notic
es
of
the
A
meric
an
Mathematic
al
So
ciety


-
Bec
k
ert
B
and
P
osegga
J
			
leanT
A
P

Lean
tableaubased
deduction
Jour
nal
of
A
utomate
d
R
e
asoning


	-
Also
a
v
ailable
on
the
W
eb
from
httpiwwwiraukade'p
ose
gga
Lean
TaP
ps
Z
Bo
ehm
H
J
Cart
wrigh
t
R
ODonnel
M
J
and
Riggle
M
		
Exact
real
arithmetic
a
case
study
in
higher
order
programming
In
Confer
enc
e
R
e
c
or
d
of
the
	
A
CM
Symp
osium
on
LISP
and
F
unctional
Pr
o
gr
amming
pp
-
Asso
ciation
for
Computing
Mac
hinery

Boizumault
P

			
The
implementation
of
Pr
olo
g
Princeton
series
in
computer
science
Princeton
Univ
ersit
y
Press
T
ranslated
from
Prolog
limplan
tation
b
y
A
M
Djam
b
oulian
and
J
F
attouh


BIBLIOGRAPHY

Bo
y
er
R
S
and
Mo
ore
J
S
			
A
Computational
L
o
gic
A
CM
Monograph
Series
Academic
Press
Burge
W
H
		
R
e
cursive
Pr
o
gr
amming
T
e
chniques
AddisonW
esley

Ch
urc
h
A
		
An
unsolv
able
problem
of
elemen
tary
n
um
b
ertheory

A
meri
c
an
Journal
of
Mathematics


-
Ch
urc
h
A
		
A
form
ulation
of
the
Simple
Theory
of
Typ
es
Journal
of
Symb
olic
L
o
gic


-
Ch
urc
h
A
		
The
c
alculi
of
lamb
dac
onversion
V
olume

of
A
nnals
of
Math
ematics
Studies
Princeton
Univ
ersit
y
Press
Clo
c
ksin
W
F
and
Mellish
C
S
		
Pr
o
gr
amming
in
Pr
olo
g
	rd
ed
SpringerV
erlag
Curry

H
B
		
Grundlagen
der
Kom
binatorisc
hen
Logik
A
meric
an
Journal
of
Mathematics


	-
	-
Da
v
enp
ort
J
H
		
On
the
inte
gr
ation
of
algebr
aic
functions
V
olume

of
L
e
ctur
e
Notes
in
Computer
Scienc
e
SpringerV
erlag
Da
v
enp
ort
J
H
Siret
Y
and
T
ournier
E
		
Computer
algebr
a
systems
and
algorithms
for
algebr
aic
c
omputation
Academic
Press
Da
vis
M
D
Sigal
R
and
W
eyuk
er
E
J
			
Computability
c
omplexity
and
languages
fundamentals
of
the
or
etic
al
c
omputer
scienc
e
	nd
ed
Academic
Press
de
Bruijn
N
G
		
Lam
b
da
calculus
notation
with
nameless
dummies
a
to
ol
for
automatic
form
ula
manipulation
with
application
to
the
Ch
urc
hRosser
theorem
Indagationes
Mathematic
ae


-	
DeMillo
R
Lipton
R
and
P
erlis
A
			
So
cial
pro
cesses
and
pro
ofs
of
theorems
and
programs
Communic
ations
of
the
A
CM


-
Dijkstra
E
W
		
A
Discipline
of
Pr
o
gr
amming
Pren
ticeHall
Enderton
H
B
		
A
Mathematic
al
Intr
o
duction
to
L
o
gic
Academic
Press
F
rege
G
		
Grundgesetze
der
A
rithmetik
b
e
grisschrift
ab
geleitet
Jena
P
ar
tial
English
translation
b
y
Mon
tgomery
F
urth
in
The
basic
la
ws
of
arithmetic
Exp
osition
of
the
system
Univ
ersit
y
of
California
Press
	
Girard
JY
Lafon
t
Y
and
T
a
ylor
P

			
Pr
o
ofs
and
T
yp
es
V
olume

of
Cambridge
T
r
acts
in
The
or
etic
al
Computer
Scienc
e
Cam
bridge
Univ
ersit
y
Press


BIBLIOGRAPHY
Gordon
A
D
			
F
unctional
Pr
o
gr
amming
and
InputOutput
Distinguished
Dissertations
in
Computer
Science
Cam
bridge
Univ
ersit
y
Press
Gordon
M
J
C
		
Pr
o
gr
amming
L
anguage
The
ory
and
its
Implementa
tion
applic
ative
and
imp
er
ative
p
ar
adigms
Pren
ticeHall
In
ternational
Series
in
Computer
Science
Pren
ticeHall
Gordon
M
J
C
Milner
R
and
W
adsw
orth
C
P

			
Edinbur
gh
LCF
A
Me
chanise
d
L
o
gic
of
Computation
V
olume

of
L
e
ctur
e
Notes
in
Computer
Scienc
e
SpringerV
erlag
Henson
M
C
		
Elements
of
functional
languages
Blac
kw
ell
Scien
tic
Hindley

J
R
and
Seldin
J
P

		
Intr
o
duction
to
Combinators
and

Calculus
V
olume

of
L
ondon
Mathematic
al
So
ciety
Student
T
exts
Cam
bridge
Univ
ersit
y
Press
Hudak
P

			
Conception
ev
olution
and
application
of
functional
program
ming
languages
A
CM
Computing
Surveys


	-
Huet
G
		
Conuen
t
reductions
abstract
prop
erties
and
applications
to
term
rewriting
systems
Journal
of
the
A
CM


	-
Kleene
S
C
		
A
theory
of
p
ositiv
e
in
tegers
in
formal
logic
A
meric
an
Journal
of
Mathematics


-
	-
Lagarias
J
		
The
x
"

problem
and
its
generalizations
The
A
meric
an
Mathematic
al
Monthly

	
-
Av
ailable
on
the
W
eb
as
httpwwwcecmsfucaorga
nic
spa
pers
lag
ari
asi
ndex
htm
l
Landin
P

J
		
The
next

programming
languages
Communic
ations
of
the
A
CM

	
-
Lindemann
F
	
&
Ub
er
die
Zahl


Mathematische
A
nnalen


-
Mairson
H
G
			
Deciding
ML
t
ypabilit
y
is
complete
for
deterministic
exp
o
nen
tial
time
In
Confer
enc
e
R
e
c
or
d
of
the
Sevente
enth
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
POPL
San
F
rancisco
pp
-
Asso
ciation
for
Computing
Mac
hinery

Mairson
H
G
			
Outline
of
a
pro
of
theory
of
parametricit
y

In
Hughes
J
	ed
		
A
CM
Symp
osium
on
F
unctional
Pr
o
gr
amming
and
Computer
A
r
chi
te
ctur
e
V
olume

of
L
e
ctur
e
Notes
in
Computer
Scienc
e
Harv
ard
Univ
ersit
y

pp
-
Martelli
A
and
Mon
tanari
U
		
An
ecien
t
unication
algorithm
A
CM
T
r
ansactions
on
Pr
o
gr
amming
L
anguages
and
Systems


-

BIBLIOGRAPHY
	
Maun
y

M
			
F
unctional
programming
using
CAML
Ligh
t
Av
ailable
on
the
W
eb
from
httppauillacinriafr
caml
tu
tori
ali
ndex
ht
ml
M
,
enissierMorain
V
			
A
rithm

etique
exacte
c
onc
eption
algorithmique
et
p
erformanc
es
d
une
impl

ementation
informatique
en
pr

ecision
arbitr
air
e
Th
.
ese
Univ
ersit
,
e
P
aris

Mic
hie
D
		
#Memo$
functions
and
mac
hine
learning
Natur
e


	-
Milner
R
		
A
theory
of
t
yp
e
p
olymorphism
in
programming
Journal
of
Computer
and
Systems
Scienc
es


-
Mycroft
A
		
Abstract
in
terpretation
and
optimising
transformations
of
applicativ
e
programs
T
ec
hnical
rep
ort
CST
Computer
Science
Depart
men
t
Edin
burgh
Univ
ersit
y

Kings
Buildings
Ma
yeld
Road
Edin
burgh
EH	
JZ
UK
Neumann
P

G
			
Computerr
elate
d
risks
AddisonW
esley

Opp
en
D
		
Prett
yprin
ting
A
CM
T
r
ansactions
on
Pr
o
gr
amming
L
anguages
and
Systems


-
P
aulson
L
C
		
A
higherorder
implemen
tation
of
rewriting
Scienc
e
of
Computer
Pr
o
gr
amming


	-	
P
aulson
L
C
			
ML
for
the
Working
Pr
o
gr
ammer
Cam
bridge
Univ
ersit
y
Press
P
elletier
F
J
		
Sev
en
t
yv
e
problems
for
testing
automatic
theorem
pro
v
ers
Journal
of
A
utomate
d
R
e
asoning


	-
Errata
JAR

		
-
P
eterson
I
			
F
atal
Defe
ct

Chasing
Kil
ler
Computer
Bugs
Arro
w
P
otts
P

			
Computable
real
arithmetic
using
linear
fractional
trans
formations
Unpublished
draft
for
PhD
thesis
a
v
ailable
on
the
W
eb
as
httptheorydocicacuk
'pj
ppu
bph
ddr
aft
ps
gz
Raphael
B
		
The
structure
of
programming
languages
Communic
ations
of
the
A
CM

	
-
Reade
C
			
Elements
of
F
unctional
Pr
o
gr
amming
AddisonW
esley

Reynolds
J
C
			
The
disco
v
eries
of
con
tin
uations
Lisp
and
Symb
olic
Com
putation


-


BIBLIOGRAPHY
Robinson
J
A
			
Logic
computers
Turing
and
v
on
Neumann
In
F
uruk
a
w
a
K
Mic
hie
D
and
Muggleton
S
	eds
Machine
Intel
ligenc
e

pp
-
Clarendon
Press
Sc
h&
onnk
el
M
		
&
Ub
er
die
Bausteine
der
mathematisc
hen
Logik
Mathe
matische
A
nnalen

	
-
English
translation
On
the
building
blo
c
ks
of
mathematical
logic
in
v
an
Heijeno
ort
		
pp
-
Sc
h
wic
h
ten
b
erg
H
		
Denierbare
F
unktionen
im
Kalk
&
ul
mit
Typ
en
A
rkhiv
f

ur
mathematische
L
o
gik
und
Grund
lagenforschung


-
Stic
k
el
M
E
		
A
Prolog
Tec
hnology
Theorem
Pro
v
er
Implemen
tation
b
y
an
extended
Prolog
compiler
Journal
of
A
utomate
d
R
e
asoning


-
T
uring
A
M
		
On
computable
n
um
b
ers
with
an
application
to
the
En
tsc
heidungsproblem
Pr
o
c
e
e
dings
of
the
L
ondon
Mathematic
al
So
ciety



-
T
uring
A
M
		
Correction
to
T
uring
		
Pr
o
c
e
e
dings
of
the
L
ondon
Mathematic
al
So
ciety



-
v
an
Heijeno
ort
J
	ed
		
F
r
om
Fr
e
ge
to
G
odel
A
Sour
c
e
Bo
ok
in
Mathe
matic
al
L
o
gic
		
Harv
ard
Univ
ersit
y
Press
Whitehead
A
N
			
A
n
Intr
o
duction
to
Mathematics
Williams
and
Norgate
Whitehead
A
N
and
Russell
B
		
Principia
Mathematic
a

vols
Cam
bridge
Univ
ersit
y
Press
Winsk
el
G
			
The
formal
semantics
of
pr
o
gr
amming
languages
an
intr
o
duction
F
oundations
of
computing
MIT
Press
Wittgenstein
L
		
T
r
actatus
L
o
gic
oPhilosophicus
Routledge
)
Kegan
P
aul
W
righ
t
A
			
P
olymorphism
for
imp
erativ
e
languages
without
imp
erativ
e
t
yp
es
T
ec
hnical
Rep
ort
TR	
Rice
Univ
ersit
y


