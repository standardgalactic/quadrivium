Институт Актуального Образования
“ЮрИнфоР-МГУ”
КАТЕГОРИАЛЬНАЯ
АБСТРАКТНАЯ МАШИНА
Конспект лекций: введение в вычисления
Издание 2-е
Проект: Аппликативные Вычислительные Системы
Руководитель проекта, кандидат технических наук
Л.Ю.Исмаилова
Москва
Учебно-консультационный центр “ЮрИнфоР”
2001

I
Кафедра перспективных компьютерных исследований и
информационных технологий
Проект: Аппликативные Вычислительные Системы
Руководитель проекта, кандидат технических наук
Исмаилова Л.Ю.
Категориальная абстрактная машина. Конспект лекций: вве-
дение в вычисления.- М.: Учебно-консультационный центр“ЮрИн-
фоР”, 2001.- с.
ISBN
Работа содержит изложение базовых моделей вычислений, применяе-
мые в компьютерных науках. Изложены основы λ-исчисления и ком-
бинаторные исчисления. Основное внимание уделено подробному рас-
смотрению техники вычисления значения конструкций языков про-
граммирования, включая компилирование кода, его оптимизацию и
исполнение на примере категориальной абстрактной машины. Изло-
жение построено на примерах возрастающей сложности.
Книга может быть рекомендована студентам и аспирантам, изучаю-
щим основы компьютерных наук, теорию и языки программирования,
информационные технологии, информатику и дискретную математи-
ку.
c⃝Учебно-консультационный центр “ЮрИнфоР”, 1997-2001
Учебно-консультационный центр “ЮрИнфоР”
Институт Актуального Образования ЮрИнфоР-МГУ
Воротниковский пер., 7
Москва, 103006 Россия
Fax: +7 (095) 299-8415
E-mail: vew@jmsuice.msk.ru

II

Оглавление
Предисловие . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.
Абстрактная машина . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.1
Значение выражений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2
Сравнение различных способов вычисления . . . . . . . . . . .
12
1.3
Построение абстрактной машины . . . . . . . . . . . . . . . . . . . .
13
1.4
Вычисления в категориальной абстрактной машине . . .
13
1.5
Статические комбинаторы. . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.6
Работа КАМ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.7
Замена символов д.з.к. инструкциями КАМ . . . . . . . . . . .
18
1.8
Цикл работы КАМ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
Примеры и упражнения. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.
Оптимизации вычислений . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2.1
Вычисление на КАМ β-свертывания . . . . . . . . . . . . . . . . .
29
2.2
Обоснование вычисления β-свертывания . . . . . . . . . . . . . .
30
2.3
Экономия в кодировании двухместных операторов . . . . .
31
3.
Расширение и реализация КАМ . . . . . . . . . . . . . . . . . . . . . .
33
3.1
Неподвижная точка и конструкция ветвления . . . . . . . . .
33
3.2
Вычисления с рекурсивной модификацией среды . . . . . .
37
3.3
Организация цикла mkloop . . . . . . . . . . . . . . . . . . . . . . . . . .
43
3.4
Рекурсия и ленивые вычисления . . . . . . . . . . . . . . . . . . . . .
46
Литература . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
Предметный указатель . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54

Предисловие
Вычисление как самостоятельный объект исследования давно подвер-
гается массированным математическим“натискам”. По-видимому, ка-
ждое очередное поколение математиков от computer science пытает-
ся по-своему переосмыслить и переоткрыть основные законы вычи-
слений. Самое существенное, что содержание понятия вычисления не
остается чем-то неизменным, но периодическим меняется. Тем самым
вновь и вновь возникает необходимость выработки надлежащих теоре-
тических оснований, которые хотя бы на время удовлетворяли новым
требованиям.
Рекомендации по обучению
Если книга используется в академических целях для изложения или
изучения данного предмета, то наиболее эффективно ее можно исполь-
зовать в курсах компьютерных наук, информационных технологий и
программирования. В таком курсе акцентируется аспект означивания
используемой конструкции, который наиболее близко соответствует
реальной практике достижения целей проекта языка программирова-
ния. В курсах компьютерных наук и программирования книга может
изучаться в последовательности от начала до конца.
Во многих учебных заведениях проводятся занятия со слушателя-
ми, специализирующимися в области информационных технологий. В
этом случае книга вполне подходит для организации занятий и может
быть изучена от начала до конца.

2
Предисловие
Благодарности
Круг вопросов, отраженных в работе, подвергался обсуждениям с
участниками научных семинаров по аппликативным вычислительным
системам в МИФИ, вместе с которыми была рассмотрена большая
часть примеров.
Выражается искреннюю признательность всем, кто принимал уча-
стие в подготовке этой книги. В первую очередь это относится к чи-
тателям первого препринтного издания сокращенного варианта, кото-
рые поделились своими замечаниями, а также сообщили об ошибках
и удачных местах. Множество таких предложений отражено в книге.
Хотелось бы выразить благодарность студентам, слушателям и со-
трудникам Института Актуального Образования “ЮрИнфоР-МГУ”,
которые внесли целый ряд предложений по улучшению изложения от-
дельных вопросов, связанных с абстрактными машинами.
Отдельно выражается благодарность С.В. Косикову, любезно пре-
доставившему первую макетную реализации абстрактной машины.
Особая благодарность выражается к.т.н. доценту А.В. Гаврило-
ву, реализовавшему представительный набор инструкций абстракт-
ной машины и предоставившему для этих целей вычислительную сре-
ду.
г. Москва
апрель 2001 года

Введение
Категориальная абстрактная машина (КАМ) представляет собой ма-
тематическую идеализацию процесса вычисления программы, харак-
терную для аппликативного, функционального или композиционно-
го программирования. Одним из способов реализации языков фук-
ционального программирования является машина, основанная на су-
перкомбинаторах, или SK-машина Тернера. Альтернативный способ
основан на концепции КАМ. Универсум КАМ составляют синтакси-
ческая, семантическая и вычислительная компоненты.
Разработка семантики предполагает указание способа, которым
языку программирования придается математический смысл. Прог-
раммы интерпретируются в категориях, наделенных структурой, под
которой изначально понимаются множества и функции, а затем де-
лается переход к технике вычислений, характерной для исчислений
объектов. Основными задачами такого направления в компьютерных
науках являются:
⋄
установление понятийной основы и подходящего набора опреде-
лений, пользуясь которыми достигают достаточного уровня аб-
стракции, чтобы не иметь дело с различными деталями реализа-
ции и которые обеспечивают независимую от конкретной реали-
зации базу для рассуждений;
⋄
разработка математических средств для доказательств, касаю-
щихся свойств программ. Наряду с логикой, семантические мо-
дели ведут к возможности построения непротиворечивых правил
вывода, которые можно использовать для автоматической про-
верки доказательств.

4
Введение

1. Абстрактная машина
Предметом обсуждения является связывание значений с индентифи-
каторами в зависимости от среды. Под средой с интуитивной точки
зрения понимается тот контекст, в котором осуществляется сопоста-
вление идентификатору его значения. Более строго, вычисление значе-
ния представляет собой отображение, обозначаемое через ∥·∥·, которое
действует на пару аргументов, первым из которых является иденти-
фикатор I, а вторым – среда ρ, – и в качестве результата возвращает
значение идентификатора:
∥· ∥·: идентификатор × среда →значение.
1.1 Значение выражений
В рамках аппликативной вычислительной системы (АВС) идентифи-
катором служит объект, определяемый индукцией по построению:
(i) константы c и переменные x считаются объектами;
(ii) если M и N – объекты, то (MN) считается объектом:
(· ·): объект × объект →объект,
где (· ·) – оператор аппликации;
(iii) если x – переменная, а M – объект, то λx.M считается объектом:
(λ · .·): переменная × объект →объект,
где (λ · .·) – оператор абстракции.
Пользуясь определением объекта, определяем семантические равен-
ства, характеризующие вычисление значения:

6
Абстрактная машина
∥x∥ρ
=
ρ(x);
∥c∥ρ
=
ρ(c) ≡c;
∥MN∥ρ
=
(∥M∥ρ)(∥N∥ρ);
∥λx.M∥ρd
=
∥M∥([d/x]ρ)
|
{z
}
ρ′
,
где ρ(x) – значение, связываемое с x в среде ρ; c – константа, обознача-
ющая значение; ([d/x]ρ) среда ρ′, в которой переменная x замещается
на объект d.
Заметим, что среда ρ имеет вид [[. . . [[(), vn], vn−1] . . .], v0], где vi
связана с i, а i имеет связь с числами Дебрейна1. Числа Дебрейна
возникают как средство ликвидации коллизии имен переменных при
выполнении β-редукций. В частности, в λ-исчислении недопустимо
вычисление
(λxy.x)y Λβ λy.y,
поскольку оно дает неправильный результат. Правильным признаем
вычисление вида
(λxy.x)y Λα (λx.(λz.[z/y]x))y = (λxz.x)y Λβ λz.y.
Разница в вычислениях ясна: если λy.y указывает на тождественное
преобразование, то λy.z – на константную функцию. Для преодоления
такого смешения заметим следующее: в замкнутом терме (который
не содержит свободных переменных) вся информация о переменной
заключена в глубине ее связывания, то есть она определяется чи-
слом символов λ, записанных между данной переменной и связыва-
ющим ее символом λ. Сам связывающий символ λ в этом подсчете не
участвует. Тогда оказывается возможным заместить символы пере-
менных числами, указывающими глубину их связывания. В частно-
сти, кодирование глубины связывания переменных в замкнутом терме
P = λy.(λxy.x)y дает выражение λ.(λλ.1)0. Следовательно, в рассмо-
тренном ранее примере β-редукции, вызвавшем коллизию перемен-
ных, от терма вида λxy.x просто переходим к коду Дебрейна λλ.1
вместо подбора новой переменной x и использования постулата (α)
для построения правильного терма λxz.x.
1 Отказ от “линейной” формы записи среды обусловлен требованиями эф-
фективности при построении абстрактной машины, реализующей вычи-
сление значений выражений.

1.1 Значение выражений
7
Использование кодирования замкнутых термов по Дебрейну при-
водит к формулированию новых семантических равенств:
∥0∥[ρ, d]
=
d;
∥n + 1∥[ρ, d] = ∥n∥ρ;
∥c∥ρ
=
c;
∥MN∥ρ
=
(∥M∥ρ)(∥N∥ρ);
∥λ.M∥ρd
=
∥M∥[ρ, d].
Далее вместо анализа собственно значений остановимся на вычисли-
тельной стороне различных комбинаций выражений. Основной прин-
цип, которому следуем:
значение аппликации MN является аппликацией (комбинаци-
ей) значения M к значению N.
Кроме того, сохраним в качестве рамок анализа вычисления значений
комбинаторную логику, что требует введения следующих комбинато-
ров:
D
≡
λxy.[x, y] ≡λxyr.rxy,
S
≡
CIS
арности 2,
Λ
≡
λx.(λyz.x[y, z])
арности 1,
′
≡
K ≡λx.(λy.x)
арности 1.
Кроме того, добавим бесконечное множество комбинаторов n! с харак-
теристиками:
∥n∥
≡
n!;
∥c∥
=
′c;
∥MN∥
=
S[∥M∥, ∥N∥];
∥λ.M∥
=
Λ∥M∥.
Последние комбинаторы оправдывают введение в употребление ком-
бинаторов D, S, Λ, ′, поскольку семантические равенства можно свести
к синтаксическим:
0![x, y]
=
y,
n + 1![x, y] = n!x;
(′x)y
=
x;
S[x, y]z
=
xz(yz);
Λ(x)yz
=
x[y, z].
Мотивировкой последнего свода синтаксических равенств вытекает из
свойств реализации абстрактной машины. Последнее равенство опре-
деляет каррирование, а предпоследнее – декаррирование выражений2.
2 Каррированием называют преобразование “алгебраического”выражения
в объект АВС, а обратную процедуру называют декаррированием.

8
Абстрактная машина
Эти последние равенства играют основную роль при построении ка-
тегориальной комбинаторной логики, которую можно рассматривать
как обычную комбинаторную логику, в которой используются явные
(декартовы) произведения. Для оперирования произведениями допол-
нительно вводится комбинатор пары:
< ·, · >≡λt.[·t, ·t]
с характеристикой
< f, g >≡λtλz.z(ft)(gt) ≡λt.[ft, gt]
и семантическим равенством
∥[M, N]∥=< ∥M∥, ∥N∥> .
Следуя традиционной алгебраической практике, произведение осна-
щается проекциями:
Fst
≡
CIK
≡
(n + 1)!;
Snd
≡
CI(KI)
≡
0!,
а также характеристическими равенствами:
Fst[x, y]
=
x;
Snd[x, y]
=
y;
< x, y > z
=
[xz, yz].
Последние из равенств служат формализацией в категориальной ком-
бинаторной логике (ККЛ) следующей алгебраической идеи: в теоре-
тико-множественном смысле парой функций
x
:
A →B,
y
:
A →C
считается функция
w : A →B × C,
которая в качестве результата дает совокупность результатов фун-
кций-компонентов3. Представленные комбинаторы введены с избыт-
ком: это касается Fst и (n + 1)!, Snd и 0!, S и < ·, · >. Избыточность с
3 Совокупностью функций x и y является не функция, а элемент в (A →
B) × (A →B).

1.1 Значение выражений
9
легкостью устраняется переходом к базисному теоретико-категорному
оператору, которым является композиция, обозначаемая через ‘◦’, и
полностью аналогичная комбинатору B из обычной комбинаторной
логики. Кроме того, введем явно символ операции аппликации, обо-
значаемый через ‘ε’:
ε[f, x] = f(x).
Обоснуем некоторые полезные для дальнейшего равенства:
(1) Sxyt = xt(yt) = ε[xt, yt] = (ε◦< x, y >)t, откуда следует, что
S ≡λxy.(ε◦< x, y >);
(2) Положим
Fstn+1
≡
Fst ◦Fstn
для n > 1;
Fst1
≡
Fst,
откуда следует, что n! ≡Snd ◦Fstn для n > 0, а 0! ≡Snd.
Теперь устраним дублирование комбинаторов и представим оконча-
тельный перечень равенств:
(ass)
(x ◦y)z
=
x(yz),
(fst)
Fst[x, y]
=
x,
(snd)
Snd[x, y]
=
y,
(dpair)
< x, y > z
=
[xz, yz],
(ac)
ε[Λ(x)y, z]
=
x[y, z],
(quote)
(′x)y
=
x,
где (ass) устанавливает связь аппликации и композиции, а (dpair) –
связь спаривания и формирования совокупности.
Пример 1.1.1. Рассмотрим выражение языка функционального про-
граммирования ML:
(1)
let x = plus in x (4, (x where x = 3));;
Как известно, между выражением (1) и некоторым выражением M
λ-исчисления имеется взаимно однозначное соответствие:
(2)
M = (λx.x[4, (λx.x)3])+
Заметим, что в результате каррирования выражение (2) принимает
вид

10
Абстрактная машина
(2′)
M = (λx.x 4((λx.x)3))+
Теперь оказывается, что выражения вида (2) и (2′) могут быть вычи-
слены различными способами.
Способ 1. Основан на непосредственном использовании постулатов λ-
исчисления:
(λx.x 4((λx.x)3))+
=β
+4((λx.x)3)
=β
+4 3
→
7.
Последний шаг вычисления обусловлен наличием заранее указан-
ной интерпретации символа ‘+’.
Способ 2. Основан на предварительном переводе выражения (2′) в вы-
ражение комбинаторной логики. Для определенности выберем ба-
зис I, K, S и алгоритм перевода:
(i)
λx.x
=
I;
(ii)
λx.c
=
Kc, c ̸≡x, c – атом;
(iii)
λx.PQ
=
S(λx.P)(λx.Q).
Следовательно,
(λx.x 4((λx.x)3))
=(iii)
S(λx.x 4)(λx.(λx.x)3)
=(iii),α
S(S(λx.x)(λx.4))
(S(λx.(λy.y))(λx.3))
=(i),(ii)
S(SI(K4))(S(λx.I)(K3))
=(ii)
S(SI(K4))(S(KI)(K3))
Тогда вычисление в комбинаторной логике принимает вид:
(λx.x 4((λx.x)3))+
=
S(SI(K4))(S(KI)(K3))+
=S
SI(K4) + (S(KI)(K3)+)
=S,S
I + (K4+)((KI+)(K3+))
=K,K,K
I + 4(I3)
=I
I + 4 3
=I
+ 4 3
→
7.
Способ 3. Основан на предварительном переводе выражения (2) в код
Дебрейна:

1.1 Значение выражений
11
M
=
(λx.x[4, (λx.x)3])+
=
(λx.x[4, (λ.0)3])+
=
(λ.0[4, (λ.0)3])+
(между переменной, стоящей после символа точки, и связываю-
щим эту переменную символом λ нет других символов λ). Далее
вычисляется значение, то есть функция значения ∥· ∥·, от выра-
жения M:
∥M∥
=
∥(λ.0[4, (λ.0)3]) + ∥
=
S[∥λ.0[4, (λ.0)3]∥, ∥+ ∥]
=
S[Λ∥0[4, (λ.0)3]∥, ∥+ ∥]
=
S[Λ(S[0!, ∥[4, (λ.0)3]∥]), ∥+ ∥]
=
S[Λ(S[0!, < ∥4∥, ∥(λ.0)3∥>]),′ +]
=
S[Λ(S[0!, <′ 4, S[Λ(0!),′ 3] >]), Λ(+ ◦Snd)].
Последний шаг вычисления опирается на равенство
′+ = Λ(+ ◦Snd),
которое нетрудно обосновать. Действительно, для произвольных
t и u:
′ + tu
=
+u
Λ(+ ◦Snd)tu
=
(+ ◦Snd)[t, u]
=
+(Snd[t, u])
=
+u.
Сопоставляя оба вычисления, получаем требуемое равенство.
Наконец, завершим вычисление значения, учтя среду. В данном слу-
чае среда ρ пуста, то есть ρ ≡(). Для сокращения выкладок примем
обозначения:
A
≡
S[0!, <′ 4, B >]
B
≡
S[Λ(0!),′ 3].
Тогда ∥M∥≡S[Λ(A), Λ(+ ◦Snd)], и вычисление дает:

12
Абстрактная машина
∥M∥()
=
S[Λ(A), Λ(+ ◦Snd)]()
=
(Λ(A)())(Λ(+ ◦Snd)())
=
ε[Λ(A)(), Λ(+ ◦Snd)()]
=(ac)
A [(), Λ(+ ◦Snd)()]
|
{z
}
ρ
≡Aρ
≡
S[0!, <′ 4, B >]ρ
=
ε[0!ρ, <′ 4, B > ρ]
=0!,ρ
ε[Λ(+ ◦Snd)(), <′ 4, B > ρ]
=(ac)
(+ ◦Snd)[(), <′ 4, B > ρ]
=(dpair)
(+ ◦Snd)[(), [′4ρ, Bρ]]
=(quote)
(+ ◦Snd)[(), [4, Bρ]]
=B
(+ ◦Snd)[(), [4, ε[Λ(0!)ρ,′ 3ρ]]]
=(quote)
(+ ◦Snd)[(), [4, ε[Λ(0!)ρ, 3]]]
=(ac)
(+ ◦Snd)[(), [4, 0![ρ, 3]]]
=0!
(+ ◦Snd)[(), [4, 3]]
=(ass)
+(Snd[(), [4, 3]])
=(snd)
+[4, 3]
→
7.
1.2 Сравнение различных способов вычисления
При первом способе вычисления выглядят короче всего. Однако они
используют выражения, содержащие связанные переменные. Во вто-
ром способе вычисления оказываются в высокой степени унифициро-
ванными, поскольку вовсе не содержат переменных и составляются
с помощью аппликации констант I, K, S, а также константных ча-
стей исходного выражения языка. В вычислениях по третьему способу
используется унифицированный набор синтактико-семантических ра-
венств. Поскольку S = λxy.(ε◦< x, y >) и S = CIS, то
S[x, y]t
=
CIS[x, y]t
=
I[x, y]St
=
Sxyt
=
(ε◦< x, y >)t,
и, следовательно,
S[x, y] = ε◦< x, y > .
Это последнее равенство неоднократно использовалось в ходе вычи-
слений.

1.3 Построение абстрактной машины
13
1.3 Построение абстрактной машины
По существу построим варианта комбинаторной логики, нацелен-
ный на вычисление значений выражений. Используемая формализа-
ция опирается на некоторый набор синтактико-семантических ра-
венств. Далее применяемый набор средств комбинаторной логики име-
ет в значительной мере выраженный категориальный характер. Сюда
вкладывается следующий смысл:
1) категории предполагают проведение вычислений с использовани-
ем композиции и тождественного преобразования;
2) декартовы категории дополнительно вовлекают в вычисления про-
изведения, то есть используют функцию спаривания < ·, · >, осна-
щенную первой проекцией Fst и второй проекцией Snd;
3) декартово замкнутые категории (д.з.к.) в дополнение к возможно-
стям декартовых категорий добавляют экспоненцирование (функ-
циональные пространства).
Экспоненцирование в комбинаторной логике сводят к каррированию
(Λ) и апплицированию (ε).
1.4 Вычисления в категориальной абстрактной
машине
В категориальной абстрактной машине (КАМ) – так будем в даль-
нейшем называть вариант комбинаторной логики, вовлекающий д.з.к.,
а также техническое устройство, вычисляющее значений выражений
д.з.к., – основными “циклами” работы являются:
выбор категориального терма, построенного из комбинаторов;
означивание этого терма путем его апплицирования к среде.
Предполагается, что среда состоит из пар различных компонентов.
Ни аппликация, ни пары в выражении терма как комбинаторы не
присутствуют. Аппликация проявляет себя, начиная с приложения к
среде (к пустой среде), а пары возникают в силу использования пра-
вила
(dpair)
< x, y > z = [xz, yz].

14
Абстрактная машина
Другими словами, аппликация и пары появляются в ходе самих вы-
числений динамически. Это дает основание соответствующие им ком-
бинаторы называть динамическими в отличие от комбинаторов, ис-
пользуемых при компиляции. Эти последние комбинаторы называют-
ся статическими.
1.5 Статические комбинаторы
Сперва рассмотрим “систему команд”, в которую компилируется ис-
ходный терм языка. По существу, каждой команде соответствует не-
который статический комбинатор. Термы имеют вид:
M ′(),
где M ′ – терм, закодированный по Дебрейну, а ( ) – пустая среда. В
свою очередь “внутри” терм M ′ устроен из компонентов, каждая из
которых имеет вид Mv, где M – код Дебрейна, а v – значение, то есть
Mv понимается как код, действующий на v.
Что же считается командой в КАМ? Поскольку исходные термы
берутся из (функционального) языка, то
каждый его символ вызывает некоторое действие, то есть
является командой.
Как обычно, команда – это преобразование, изменяющее исходное со-
стояние на новое состояние. Состоянием КАМ считается тройка
{T, C, S},
где T – терм, C – код, а S – стек.
Из рассмотрения вида исходного терма теперь замечаем, что он
строится из символов
< , > Fst Snd Λ ′ ε
и ограничителей
( ) [ ]
Заметим, что ограничителями символа ‘,’ служат квадратные скобки,
то есть, по существу, рассматривается составной символ ‘[·, ·]’. В ходе
вычислений возникает дополнительный символ аппликации ‘ε’.

1.6 Работа КАМ
15
Однако исходными символами, а, следовательно, и статическими
комбинаторами, следует признать
< , > Fst Snd Λ ′
Эти статические комбинаторы и считаются системой команд КАМ.
1.6 Работа КАМ
Как и всякая машина, КАМ управляется сменой своих состояний, что
и показано на рис. 1.1. Получая на входе ‘старое’ состояние {T, C, S},
Новое
состояние
Старое
состояние
КАМ
{T, C, S}
{T ′, C′, S′}
Рис. 1.1. Работа КАМ.
КАМ преобразует его в ‘новое’ – {T ′, C′, S′}. Одна из основных ком-
понентов исходного функционального языка имеет вид
< M, N > v = [Mv, Nv].
В данном случае имеется два объяснения такого вычисления.
При допустимости параллельного выполнения вычислений действие
M, N на v происходит независимо и составляется совокупность из
v1 (значение M) и v2 (значение N).
При последовательном выполнении вычислений сперва вычисляется
значение M, которое дает v1, а только затем – значение N, которое
дает v2. После этого комбинируются v1 и v2.
На основании таких рассуждений определение кода для < M, N >
привлекает идею замены символов <, > соответствующими команда-
ми КАМ, то есть статическими комбинаторами:
код для < M, N > – это набор команд КАМ, заменяющий ‘<’,
затем следует код для M, затем – набор команд, заменяющий
‘,’, затем – код для N, затем – набор команд, заменяющий ‘>’.

16
Абстрактная машина
Такой же способ замены распространяется и на другие символы ис-
ходного выражения функционального языка.
Полный цикл работы КАМ с учетом указанного принципа замены
символов приведен на рис. 1.2. Появление очередного кода вынужда-
ет КАМ учитывать ‘содержимое’ терма и стека и выполнять опре-
деленные действия. По завершении этих действий КАМ переходит в
новое состояние, в котором анализируется следующий код. Продви-
жение КАМ “вдоль” кода осуществляется символ за символом слева
направо.
Появление различных кодов-символов приводит к следующим дей-
ствиям:
< :
проталкивает содержимое терма на вершину стека;
, :
меняет местами содержимое терма и вершины стека;
> :
составляет совокупность из содержимого вершины стека и
терма; замещает содержимое терма на построенную совокуп-
ность; проталкивает стек;
Fst :
содержимое терма вида [s, t] замещается на s;
Snd :
содержимое терма вида [s, t] замещается на t;
Λ(C) :
замещает терм s на C : s, где C : s ≡Λ(M)s, а C – код M;
ε :
содержимое терма вида [C : s, t] замещается на [s, t], вместо
символа ε (в коде) записывается C;
′c :
замещает содержимое терма на (инкапсулированную) конс-
танту c.
Кодирование инкапсулированных констант заканчивается следующим
действием: ′c = Λ(C), где C = Snd|c, то есть ′c = Λ(c ◦Snd).
Соглашение об обозначениях. Для сокращенной записи спис-
ков инструкций и элементов стека введем некоторые обозначения:
[ ] : пустой список;
[e1; . . . ; en] : список из n элементов;
a.L : добавление элемента a в начало списка L, то есть a.L ≡
[a; L];
[L1@L2] : конкатенация списков L1 и L2ю
Более строго, пусть
C1 =



[ ]
, если C1 – пустой список;
ins
, если C1 – атом;
[e1; . . . ; en]
, если C1 – список.

1.6 Работа КАМ
17
<
***
***
Ⓢ
t
t
Ⓢ
***
,
***
>
***
***
t
***
Λ(C)
***
′c
***
***
s
Ⓢ
***
Fst
***
Snd
***
***
[s, t]
Ⓢ
***
ε
***
Код
Код′
Терм
Стек
Терм′
Стек′
C
t
t
s
[s, t]
[C : s, t]
Ⓢ
. . .
Ⓢ
. . .
Ⓢ
Ⓢ
Ⓢ
Ⓢ
t
. . .
[Ⓢ, t]
. . .
C : s
Ⓢ
c
Ⓢ
s
Ⓢ
t
Ⓢ
[s, t]
Ⓢ
Рис. 1.2. Изменение состояния КАМ.

18
Абстрактная машина
Тогда преобразование “точечной” записи в “списковую” соответствует
последовательному переходу:
a.b.c 7→a.[b; c] 7→[a; b; c],
а конкатенация @ списков C1 и L ≡[e1; . . . ; em] определяется индук-
цией по построению C1:
(1) [ ]@[e1; . . . ; em] = [e1; . . . ; em] ≡L;
(2) ins@[e1; . . . ; em] = [ins; e1; . . . ; em] ≡ins.L;
(3) [e1; . . . ; en]@[e1; . . . ; em] = [e1; . . . ; en; e1; . . . ; em].
1.7 Замена символов д.з.к. инструкциями КАМ
Основная идея функционального языка состоит в том, что каждый его
символ трактуется как функция. В языке д.з.к. использовано восемь
символов, которые поставим в соответствие инструкциям КАМ, как
это показано в таблице 1.1. Для обозначения части инструкций КАМ
Таблица 1.1. Соответствие символов языка д.з.к. и инструкций КАМ
№п/п
Символ д.з.к.
Инструкция КАМ
1
Fst
car
2
Snd
cdr
3
<
push
4
,
swap
5
>
cons
6
ε
app
7
Λ
cur
8
′
quote
заимствуется мнемоника языков работы со списками.

1.8 Цикл работы КАМ
19
1.8 Цикл работы КАМ
КАМ представляет собой устройство, которое изменяет свое состо-
яние в зависимости от поданной на его вход последовательности ин-
струкций. Последовательность инструкций имеет вид списка, а состо-
янием считается тройка
{T, C, S},
где T – терм, C – код, а S – стек.
В качестве кода используется один из символов языка д.з.к., рас-
сматриваемый в качестве первого элемента списка. Переход из ‘ста-
рого’ состояния в ‘новое’:
{T, C, S} 7→{T ′, C′, S′}
задается разбором случаев вида кода.
1) Код имеет вид < . ∗∗∗. Тогда переход определяется посредством:
Код
< . ∗∗∗
∗∗∗
Терм
t
→
t
Стек
Ⓢ
t.Ⓢ
то есть код продвигается на одну инструкцию, терм не меняется,
а в “голову” стека добавляется ‘старый’ терм.
2) Код имеет вид , . ∗∗∗. Тогда переход определяется посредством:
Код
, . ∗∗∗
∗∗∗
Терм
t
→
Ⓢ
Стек
Ⓢ. . . .
t. . . .
Код продвигается на одну инструкцию, а терм и “голова” стека
меняются местами.
3) Код имеет вид > . ∗∗∗.
Код
> . ∗∗∗
∗∗∗
Терм
t
→
Ⓢ.t
Стек
Ⓢ. . . .
. . .
4) Код имеет вид Λ(C). ∗∗∗.

20
Примеры и упражнения
Код
Λ(C). ∗∗∗
∗∗∗
Терм
s
→
C : s
Стек
Ⓢ
Ⓢ
5) Код имеет вид ′c. ∗∗∗.
Код
′c. ∗∗∗
∗∗∗
Терм
s
→
c
Стек
Ⓢ
Ⓢ
6) Код имеет вид Fst. ∗∗∗.
Код
Fst. ∗∗∗
∗∗∗
Терм
[s, t]
→
s
Стек
Ⓢ
Ⓢ
7) Код имеет вид Snd. ∗∗∗.
Код
Snd. ∗∗∗
∗∗∗
Терм
[s, t]
→
t
Стек
Ⓢ
Ⓢ
8) Код имеет вид ε. ∗∗∗.
Код
ε. ∗∗∗
∗∗∗
Терм
[C : s, t]
→
[s, t]
Стек
Ⓢ
Ⓢ
Переход к символическим обозначениям для инструкций КАМ при-
водит к таблице 1.2. Представленная таблица полностью описывает
работу КАМ.
Примеры и упражнения
Рассмотрим примеры простейших вычислений.
Пример 1.8.1 (каррированная форма, вариант 1).

Примеры и упражнения
21
Таблица 1.2. Цикл работы КАМ
Старое состояние
Новое состояние
терм
код
стек
терм′
код′
стек′
t
push.C
S
t
C
t.S
t
swap.C
s.S
s
C
t.S
t
cons.C
s.S
[s, t]
C
S
s
(cur C).C1
s.S
C : s
C1
S
[s, t]
car.C
S
s
C
S
[s, t]
cdr.C
S
t
C
S
[C : s, t]
app.C1
S
[s, t]
C@C1
S
∥+ 4 3∥
=
S[∥+ 4∥, ∥3∥] = S[S[∥+ ∥, ∥4∥], ∥3∥]
=
ε◦< [S[∥+ ∥, ∥4∥], ∥3∥>
=
ε◦< ε◦< ∥+ ∥, ∥4∥>, ∥3∥>
=
ε◦< ε◦<′ +,′ 4 >,′ 3 >
≡
<<′ +,′ 4 > |ε,′ 3 > |ε
≡
<<′ +,′ 4 > ε,′ 3 > ε
Терм
Код
Стек
1
()
<<′ +,′ 4 > ε,′ 3 > ε
[]
2
()
<′ +,′ 4 > ε,′ 3 > ε
[()]
3
()
′+,′ 4 > ε,′ 3 > ε
[(); ()]
4
+
,′ 4 > ε,′ 3 > ε
[(); ()]
5
()
′4 > ε,′ 3 > ε
[+; ()]
6
4
> ε,′ 3 > ε
[+; ()]
7
(+, 4)
ε,′ 3 > ε
[()]
?
8
(+, 4)
,′ 3 > ε
[()]
9
()
′3 > ε
[(+, 4)]
10
3
> ε
[(+, 4)]
11
((+4), 3)
ε
[]
?
12
((+4), 3)
[]
[]
Пример 1.8.2 (каррированная форма, вариант 2).

22
Примеры и упражнения
∥+ 4 3∥
=
S[∥+ 4∥, ∥3∥]
=
<< ∥+ ∥,′ 4 > |ε,′ 3 > |ε
=
<< Λ(+ ◦Snd),′ 4 > ε,′ 3 > ε
≡
<< Λ(Snd|+),′ 4 > ε,′ 3 > ε
≡
<< Λ(Snd +),′ 4 > ε,′ 3 > ε
Терм
Код
Стек
1
()
<< Λ(Snd +),′ 4 > ε,′ 3 > ε
[]
2
()
< Λ(Snd +),′ 4 > ε,′ 3 > ε
[()]
3
()
Λ(Snd +),′ 4 > ε,′ 3 > ε
[(); ()]
4
(Snd +) : ()
,′ 4 > ε,′ 3 > ε
[(); ()]
5
()
′4 > ε,′ 3 > ε
[(Snd +) : (); ()]
6
4
> ε,′ 3 > ε
[(Snd +) : (); ()]
7
((Snd +) : (), 4)
ε,′ 3 > ε
[()]
8
((), 4)
Snd +,′ 3 > ε
[()]
9
4
+,′ 3 > ε
[()]
10
(+4)
,′ 3 > ε
[()]
11
()
′3 > ε
[(+4)]
12
3
> ε
[(+4)]
13
((+4), 3)
ε
[]
14
((+4), 3)
[]
[]
Выполнение последних шести строк зависит от того, как КАМ интер-
претирует встроенную функцию ‘+’.
Пример 1.8.3 (операторная форма, вариант 1).
∥+ [4 3]∥
=
S[∥+ ∥, ∥[4, 3]∥]
=
S[∥+ ∥, < ∥4∥, ∥3∥>]
=
ε◦< ∥+ ∥, < ∥4∥, ∥3∥>>
=
<′ +, <′ 4,′ 3 >> |ε
≡
<′ +, <′ 4,′ 3 >> ε

Примеры и упражнения
23
Терм
Код
Стек
1
()
<′ +, <′ 4,′ 3 >> ε
[]
2
()
′+, <′ 4,′ 3 >> ε
[()]
3
+
, <′ 4,′ 3 >> ε
[()]
4
()
<′ 4,′ 3 >> ε
[+]
5
()
′4,′ 3 >> ε
[(); +]
6
4
,′ 3 >> ε
[(); +]
7
()
′3 >> ε
[4; +]
8
3
>> ε
[4; +]
9
(4, 3)
> ε
[+]
10
(+, (4, 3))
ε
[]
11
(+, (4, 3))
[]
[]
Пример 1.8.4 (операторная форма, вариант 2).
∥+ [4 3]∥
=
S[∥+ ∥, ∥[4, 3]∥]
=
S[∥+ ∥, < ∥4∥, ∥3∥>]
=
ε◦< ∥+ ∥, < ∥4∥, ∥3∥>>
=
< Λ(Snd|+), <′ 4,′ 3 >> |ε
≡
< Λ(Snd+), <′ 4,′ 3 >> ε
Терм
Код
Стек
1
()
< Λ(Snd+), <′ 4,′ 3 >> ε
[]
2
()
Λ(Snd+), <′ 4,′ 3 >> ε
[()]
3
(Snd+) : ()
, <′ 4,′ 3 >> ε
[()]
4
()
<′ 4,′ 3 >> ε
[(Snd+) : ()]
5
()
′4,′ 3 >> ε
[(); (Snd+) : ()]
6
4
,′ 3 >> ε
[(); (Snd+) : ()]
7
()
′3 >> ε
[4; (Snd+) : ()]
8
3
>> ε
[4; (Snd+) : ()]
9
(4, 3)
> ε
[(Snd+) : ()]
10
((Snd+) : (), (4, 3))
ε
[]
11
((), (4, 3))
Snd+
[]
12
(4, 3)
+
[]
13
7
[]
[]
Пример 1.8.5 (смешанная форма).

24
Примеры и упражнения
∥(λx.x[4, 3]) + ∥
=
∥(λ.0[4, 3]) + ∥
=
S[∥λ.0[4, 3]∥, ∥+ ∥]
=
S[Λ∥0[4, 3]∥, ∥+ ∥]
=
S[Λ(S[0!, ∥[4, 3]∥]), ∥+ ∥]
=
ε◦< Λ(ε◦< 0!, < ∥4∥, ∥3∥>>), ∥+ ∥>
=
< Λ(< Snd, <′ 4,′ 3 >> ε), Λ(Snd+) > ε
Введем сокращение
A ≡< Snd, <′ 4,′ 3 >> |ε
Терм
Код
Стек
1
()
< Λ(A), Λ(Snd+) > ε
[]
2
()
Λ(A), Λ(Snd+) > ε
[()]
3
A : ()
, Λ(Snd+) > ε
[()]
4
()
Λ(Snd+) > ε
[A : ()]
5
(Snd+) : ()
> ε
[A : ()]
Положим (Snd+) : () ≡Ⓢ
5′
Ⓢ
> ε
[A : ()]
6
(A : (), Ⓢ)
ε
[]
7
((), Ⓢ)
A
[]
7′
((), Ⓢ)
< Snd, <′ 4,′ 3 >> ε
[]
8
((), Ⓢ)
Snd, <′ 4,′ 3 >> ε
[((), Ⓢ)]
9
((), Ⓢ)
<′ 4,′ 3 >> ε
[Ⓢ]
10
((), Ⓢ)
′4,′ 3 >> ε
[((), Ⓢ); Ⓢ]
11
4
,′ 3 >> ε
[((), Ⓢ); Ⓢ]
12
((), Ⓢ)
′3 >> ε
[4; Ⓢ]
13
3
>> ε
[4; Ⓢ]
14
(4, 3)
> ε
[Ⓢ]
15
(Ⓢ, (4, 3))
ε
[]
15′
((Snd+) : (), (4, 3))
ε
[]
16
((), (4, 3))
Snd+
[]
17
(4, 3)
+
[]
18
7
[]
[]
Пример 1.8.6 (2-х местный предикат, вариант 1).

Примеры и упражнения
25
∥(λxy.P[x, y])ab∥
=
∥(λλ.P[1, 0])ab∥
=
S[∥(λλ.P[1, 0])a∥, ∥b∥]
=
S[S[∥λλ.P[1, 0]∥, ∥a∥], ∥b∥]
=
ε◦< ε◦< ∥λλ.P[1, 0]∥,′ a >,′ b >
=
<< ∥λλ.P[1, 0]∥,′ a > ε,′ b > ε
=
<< Λ∥λ.P[1, 0]∥,′ a > ε,′ b > ε
=
<< Λ(Λ(∥P[1, 0]∥)),′ a > ε,′ b > ε
=
<< Λ(Λ(S[′P, < ∥1∥, ∥0∥>])),′ a > ε,′ b > ε
=
<< Λ(Λ(S
[′P, < Snd ◦Fst
|
{z
}
F |S
, Snd
|{z}
S
>])),′ a > ε,′ b > ε
=
<< Λ(Λ(ε◦<′ P, < F|S, S >>)),′ a > ε,′ b > ε
=
<< Λ(Λ(<′ P, < F|S, S >> ε)),′ a > ε,′ b > ε
Примем сокращение
P ≡<′ P, < F|S, S >> ε.
Терм
Код
Стек
1
()
<< Λ(Λ(P)),′ a > ε,′ b > ε
[]
2
()
< Λ(Λ(P)),′ a > ε,′ b > ε
[()]
3
()
< Λ(Λ(P)),′ a > ε,′ b > ε
[(); ()]
4
(Λ(P)) : ()
,′ a > ε,′ b > ε
[(); ()]
5
()
′a > ε,′ b > ε
[(Λ(P)) : (); ()]
6
a
> ε,′ b > ε
[(Λ(P)) : (); ()]
7
((Λ(P)) : (), a)
ε,′ b > ε
[()]
8
((), a)
Λ(P),′ b > ε
[()]
9
(P : ((), a))
,′ b > ε
[()]
10
()
′b > ε
[(P : ((), a))]
11
b
> ε
[(P : ((), a))]
На следующем шаге образ оператора будет помещен в терм, после чего
подготовлен к означиванию.

26
Примеры и упражнения
Терм
Код
Стек
12
((P : ((), a)), b)
ε
[]
13
(((), a), b)
P
[]
13′
(((), a), b)
<′ P, < F|S, S >> ε
[]
14
(((), a), b)
′P, < F|S, S >> ε
[(((), a), b)]
15
P
, < F|S, S >> ε
[(((), a), b)]
16
(((), a), b)
< F|S, S >> ε
[P]
17
(((), a), b)
F|S, S >> ε
[(((), a), b); P]
18
((), a)
S, S >> ε
[(((), a), b); P]
19
a
, S >> ε
[(((), a), b); P]
20
(((), a), b)
S >> ε
[a; P]
21
b
>> ε
[a; P]
22
(a, b)
> ε
[P]
23
(P, (a, b))
ε
[]
Пример 1.8.7 (2-х местный предикат, вариант 2).
∥(λxy.P[x, y])ab∥
=
∥(λλ.P[1, 0])ab∥
= << Λ(Λ(<′ P, < F|S, S >> ε)),′ a > ε,′ b > ε
= << Λ(Λ(< Λ(S|P), < F|S, S >> ε)),′ a > ε,′ b > ε
Примем сокращение
P ≡< Λ(S|P), < F|S, S >> ε.
Терм
Код
Стек
1
()
<< Λ(Λ(P)),′ a > ε,′ b > ε
[]
. . .
. . .
. . .
. . .
13
(((), a), b)
P
[]
13′
(((), a), b)
< Λ(S|P), < F|S, S >> ε
[]
14
(((), a), b)
Λ(S|P), < F|S, S >> ε
[(((), a), b)]
15
(S|P) : (((), a), b)
, < F|S, S >> ε
[(((), a), b)]
Далее подготовленный терм будет перемещен в стек.

Примеры и упражнения
27
Терм
Код
Стек
Положим (S|P) : (((), a), b) ≡Ⓢ
15′
Ⓢ
, < F|S, S >> ε
[(((), a), b)]
16
(((), a), b)
< F|S, S >> ε
[Ⓢ]
17
(((), a), b)
F|S, S >> ε
[(((), a), b); Ⓢ]
18
((), a)
S, S >> ε
[(((), a), b); Ⓢ]
19
a
, S >> ε
[(((), a), b); Ⓢ]
20
(((), a), b)
S >> ε
[a; Ⓢ]
21
b
>> ε
[a; Ⓢ]
22
(a, b)
> ε
[Ⓢ]
23
(Ⓢ, (a, b))
ε
[]
24
((((), a), b), (a, b))
S|P
[]
25
(a, b)
P
[]
true,
если (a, b) ∈P
false,
если (a, b) ̸∈P

28
Примеры и упражнения

2. Оптимизации вычислений
Вычисления значения выражений допускают оптимизации, выполняе-
мые как на уровне скомпилированного кода, так и на уровне его интер-
претации, то есть непосредственно для КАМ-инструкций. Эти опти-
мизации, как оказывается, связаны с тождественным комбинатором,
без которого рассматриваемый вариант комбинаторной логики вряд
ли может быть назван ‘категориальной’.
2.1 Вычисление на КАМ β-свертывания
Рассмотрим вычисление на КАМ свертывания по постулату β.
∥(λ.M)N∥
=
S[∥λ.M∥, ∥N∥]
=
S[Λ(∥M∥), ∥N∥]
=
ε◦< Λ(∥M∥
|{z}
m
), ∥N∥
|{z}
n
>
≡
< Λ(m), n > ε
Полное вычисление:
Терм
Код
Стек
1
()
< Λ(m), n > ε
[]
2
()
Λ(m), n > ε
[()]
3
(m : ())
, n > ε
[()]
4
()
n > ε
[m : ()]
5
v
> ε
[m : ()]
6
(m : (), v)
ε
[]
7
((), v)
m
[]
Построим сокращенное вычисление. Приводимая далее табличное вы-
числение получено, начиная с последней строки. Строка-предшест-

30
Оптимизации вычислений
венник формируется на основании просмотра разрешенных переходов
состояний, перечисленных в таблице 1.2.
Терм
Код
Стек
1 (4)
()
< n > m
[]
2 (3)
()
n > m
[()]
3 (2)
v
> m
[()]
4 (1)
((), v)
m
[]
(Здесь: ∥M∥≡m, ∥N∥≡n; предполагается, что вычисление значения
для n приводит к результату v.)
2.2 Обоснование вычисления β-свертывания
Свертывание по постулату β опирается на идею замещения аппли-
кации λ-выражения к объекту подстановкой этого объекта в тело λ-
выражения. Поскольку
ε◦< Λ(X), Z >
=η
λt.(ε◦< Λ(X), Z >)t
=
λt.ε(< Λ(X), Z > t)
=
λt.ε[Λ(X)t, Zt]
=
λt.X[t, Zt]
=
λt.X[It, Zt]
=
λt.(X◦< I, Z >)t
=η
X◦< I, Z >,
то справедливо следующее равенство:
(Beta)
ε◦< Λ(X), Z >= X◦< I, Z >
Тогда вычисление его правой части на КАМ дает:
Терм
Код
Стек
1
()
< I, Z > |X
[]
2
()
I, Z > |X
[()]
3
()
, Z > |X
[()]
4
()
Z > |X
[()]
5
v
> |X
[()]
6
((), v)
X
[]

2.3 Экономия в кодировании двухместных операторов
31
Третья строка получена в предположении, что комбинатор I обеспе-
чивает тождественное преобразование. Далее, можно заметить, что
табличное вычисление выражения < Z > X дает тот же самый ре-
зультат:
Терм
Код
Стек
1
()
< Z > |X
[]
2
()
Z > |X
[()]
3
v
> |X
[()]
4
((), v)
X
[]
Следовательно, равенство (Beta) можно переписать в виде:
(Beta)
ε◦< Λ(X), Z >= X◦< I, Z >= X◦< Z >
Заметим, что при переходе к инструкциям КАМ из равенства (Beta)
вытекают три приема оптимизации набора инструкций:
(1) push.(cur X).swap.Z@[cons;app] = push.skip.swap.@Z@cons.X
(2)
push.skip.swap.@Z@cons.X = push.Z.cons.X
(3)
push.skip.swap = push
В последних равенствах инструкция skip не вызывает изменения со-
стояния и представляет КАМ-код тождественного преобразования I.
2.3 Экономия в кодировании двухместных
операторов
Равенство (Beta) можно использовать в качестве принципа оптими-
зации набора КАМ-инструкций. Действительно,
∥®[M, N]∥
=
S[∥®∥, ∥[M, N]∥]
=
ε ◦< ∥®∥, ∥[M, N]∥>
=
ε ◦< ∥®∥, < ∥M∥, ∥N∥>>
=
ε ◦< Λ(® ◦Snd), < ∥M∥, ∥N∥>>
=
® ◦Snd◦< I, < ∥M∥, ∥N∥>>
по (Beta)
=
® ◦< ∥M∥, ∥N∥>
≡
< ∥M∥, ∥N∥> |®
Проведем КАМ-вычисления:

32
Оптимизации вычислений
Терм
Код
Стек
1
()
< m, n > ®
[]
2
()
m, n > ®
[()]
3
v
, n > ®
[()]
4
()
n > ®
[v]
5
w
> ®
[v]
6
(v, w)
®
[]
(Здесь: m ≡M, n ≡N, а v, w – вычисленные на КАМ значения для
m и n соответственно.) В этих вычислениях можно достигнуть еще
большей экономии, если считать, что ® действует на терм и вер-
шину стека как на свой первый и второй операнды соответственно.
При таком допущении на уровне КАМ-инструкций можно пользовать-
ся правилом вывода:
> ® 7→®,
то есть инструкция [cons; ®] замещается инструкцией [®]. Предста-
вим эти результаты в виде равенства:
∥®[M, N]∥= ® ◦< ∥M∥, ∥N∥> = < ∥M∥, ∥N∥> | ®.

3. Расширение и реализация КАМ
3.1 Неподвижная точка и конструкция ветвления
Рассмотрим обработку в КАМ рекурсии и ленивых вычислений. В
качестве примера рассмотрим рекурсивное определение функции, вы-
числяющей факториал.
Пример 3.1.1.
letrec fact n = if n=0 then 1
else n * fact(n - 1)
in fact 1 ;;
Преобразуем определение с использованием комбинатора Y , который
считаем константой, – с целью преобразования рекурсивного опреде-
ления в нерекурсивное по форме определение.
Шаг 1: в качестве исходного принимаем имеющееся определение для
fact:
fact n
=
if n = 0
then 1
else n ∗fact(n −1)
Шаг 2: по постулату (ξ) выполняем абстрагирование обеих частей ра-
венства по n:
λn.fact n
=
λn.if n = 0
then 1
else n ∗fact(n −1)
Шаг 3: преобразуем левую часть равенства, воспользовавшись посту-
латом (η):
fact
=
λn.if n = 0
then 1
else n ∗fact(n −1)

34
Расширение и реализация КАМ
Шаг 3: преобразуем правую часть равенства, воспользовавшись по-
стулатом (β):
fact
=
(λf.λn.if n = 0
then 1
else n ∗f(n −1))fact
Шаг 4: преобразуем правую часть равенства, воспользовавшись тео-
ремой о неподвижной точке:
fact
=
Y (λf.λn.if n = 0
then 1
else n ∗f(n −1))
С учетом полученного представления исходное определение функции
преобразуем к виду:
(fact 1) = (λg.g 1)(Y (λf.λn.if n = 0 then 1 else n ∗f(n −1)))
Теперь необходимо доопределить в КАМ обработку условных кон-
струкций и комбинатора Y , которые представлены в таблице 3.1.
Итак, действие дополнительных конструкций, как следует из табли-
Таблица 3.1. Условные конструкции и рекурсия
Старое состояние
Новое состояние
терм
код
стек
терм′
код′
стек′
true
(branch(C1, C2)).C
s.S
s
C1@C
S
false
(branch(C1, C2)).C
s.S
s
C2@C
S
s
mkloop.C
(s1, s2).S
s′
C
S
цы, сводится к следующему:
branch :
в соответствии с тем, имеет ли терм значение ‘true’ или
‘false’, выполняется C1 или C2;
mkloop :
замещает правую часть совокупности, адресом которой
является верхний элемент (‘вершина’) стека, на терм и
удаляет верхний элемент из стека.
Во-первых, конструкция

3.1 Неподвижная точка и конструкция ветвления
35
if P then M else N
переводится в набор КАМ-инструкций:
< p branch (m, n),
где branch выполняет m или n в зависимости от истинности или лож-
ности p соответственно (здесь: m ≡∥M∥, n ≡∥N∥, p ≡∥P∥. )
Во-вторых, комбинаторная характеристика Y
Y M = M(Y M)
принимает вид
∥Y M∥= ∥M(Y M)∥
=
S[∥M∥, ∥Y M∥]
=
ε◦< ∥M∥, ∥Y M∥>
Поищем частные решения этого уравнения. При решении рассмотрен-
ного примера с факториалом можно положить
∥M∥= ∥λλ.P∥,
откуда
∥Y M∥
=
ε◦< ∥M∥, ∥Y M∥>
=
ε◦< Λ(Λ(∥P∥)), ∥Y M∥>
=
Λ(∥P∥)◦< I, ∥Y M∥>
по (Beta)
=
Λ(∥P∥)◦< ∥Y M∥>
Последнее равенство обосновывается КАМ-вычислением следующим
образом. Представим КАМ-вычисления для правой части предыдуще-
го равенства:
Терм
Код
Стек
1
(t)
< I, ∥Y M∥> Λ(∥P∥)
[s]
2
(t)
I, ∥Y M∥> Λ(∥P∥)
[t; s]
3
(t)
, ∥Y M∥> Λ(∥P∥)
[t; s]
4
(t)
∥Y M∥> Λ(∥P∥)
[t; s]
5
v
> Λ(∥P∥)
[t; s]
6
(t, v)
Λ(∥P∥)
[s]
7
p : (t, v)
[]
[s]
Теперь проделаем КАМ-вычисления для левой части равенства:

36
Расширение и реализация КАМ
Терм
Код
Стек
1
(t)
∥Y M∥
[s]
2
v
[]
[s]
Поскольку есть резон считать, что оба вычисления в одинаковых усло-
виях, то есть при одном и том же терме и стеке, дают один и тот же
результат, то отсюда вытекает, что
v = (p : (t, v))
(здесь: v – значение, записанное в терм, которое получено при вы-
числении левой части исходного равенства, а (p : (t, v)) – значение,
записанное в терм, которое получено при вычислении правой части
исходного характеристического равенства для Y ). Далее,
v
=
(p : (t, v))
=
(p : (t, (p : (t, v))))
=
(p : (t, (p : (t, (p : (t, v))))))
=
. . . .
Как видим, это бесконечная запись, которую удобно представить са-
моссылающимся графом. Графическое представление этого вычисле-
ния дает гиперграф, показанный на рис. 3.1. Качественное решение
:
p
(· , ·)
t
Рис. 3.1. Гиперграф рекурсивной модификации среды: v = (p : (t, v)).
приводит к следующему рассуждению: в качестве кода для Y (λλ.P)
берется (rec cur p), где p – значение кода P, p ≡∥P∥. Действие это-
го кода на некоторый терм t определяется как замещение этого тер-
ма t в соответствии с определением, представленным гиперграфом на
рис. 3.1. Это замещение и представляет собой рекурсивную модифика-
цию среды. Неформально говоря, если в ходе вычислений встретится

3.2 Вычисления с рекурсивной модификацией среды
37
указание на рекурсию, – а на это указывает комбинатор Y , – то выпол-
няется модификация среды такая, что ее графическое представление
является самоссылающимся графом. Перейдем к детальному разбору
вычисления факториала.
3.2 Вычисления с рекурсивной модификацией
среды
Выполним запись вычислений n! для n = 1. Запись исходного выра-
жения на некотором входном языке имеет следующий вид:
letrec fact n = if n=0 then 1
else n * fact(n - 1)
in fact 1 ;;
Как было показано в подразделе 3.1, запись исходной конструкции
трансформируется в
(fact 1) = (λg.g 1)(Y (λf.λn.if n = 0 then 1 else n ∗f(n −1)))
Построим теперь выражения скомпилированного кода для отдельных
компонентов исходной конструкции.
λf.λn.if n = 0 then 1 else n ∗f(n −1) =
=
λf.λn. <= [n, 0] (branch(1, ∗[n, f(−[n, 1])]))
=
λλ. <= [0, 0](b(1, ∗[0, 1(−[0, 1])]))
Примем следующие сокращения:
C
≡
∗[0, 1(−[0, 1])]
B
≡
<= [0, 0](b(1, ∗[0, 1(−[0, 1])]))
≡
<= [0, 0](b(1, C))
Вычислим значение этих компонентов.
∥C∥
=
∗◦< ∥0∥, ε◦< ∥1∥, −◦< ∥0∥,′ 1 >>>
=
∗◦< S, ε◦< F|S, −◦< S,′ 1 >>>
=
< S, < F|S, < S,′ 1 > −> ε > ∗
Здесь и далее используются сокращения S ≡Snd, F ≡Fst.

38
Расширение и реализация КАМ
∥B∥
=
< ∥= [0, 0]∥b(∥1∥, ∥C∥)
=
<= ◦< S,′ 0 > b(′1, ∥C∥)
=
<< S,′ 0 >= b(′1, ∥C∥)
В качестве замечания отметим способ кодирования условного выра-
жения:
if P then M else N 7→< (код P) branch((код M), (код N))
Далее, как было показано,
∥Y M∥
=
ε◦< ∥M∥, ∥Y M∥>
В предположении, что ∥M∥= ∥λλ.P∥, получаем равенство
∥Y M∥
=
Λ(∥P∥)◦< I, ∥Y M∥>
=
Λ(∥P∥)◦< ∥Y M∥>,
причем последнее выражение получается из предыдущего посред-
ством оптимизации.
Составим вычисляемое выражение:
∥(λ.01)(Y (λλ.B))∥
=
ε◦< Λ(ε◦< S,′ 1 >), ∥Y (λλ.B)∥>
=
ε◦< S,′ 1 > ◦< I, ∥Y (λλ.B)∥>
(Beta)
=
ε◦< S,′ 1 > ◦< ∥Y (λλ.B)∥>
=
ε◦< S,′ 1 > ◦< Λ(∥B∥)◦< ∥Y (λλ.B)∥>>
=
<< ∥Y (λλ.B)∥> Λ(∥B∥) >< S,′ 1 > ε
Положим для краткости ∥B∥≡b, ∥C∥≡c, ∥Y (λλ.B)∥≡y и произве-
дем вычисление n! для n = 1.

3.2 Вычисления с рекурсивной модификацией среды
39
Терм
Код
Стек
1
()
<< y > Λ(b) >< S,′ 1 > ε
[]
2
v
> Λ(b) >< S,′ 1 > ε
[(); ()]
3
((), v)
Λ(b) >< S,′ 1 > ε
[()]
4
b : ((), v)
>< S,′ 1 > ε
[()]
5
((), b : ((), v))
< S,′ 1 > ε
[]
6
((), b : ((), v))
S,′ 1 > ε
[((), b : ((), v))]
7
(b : ((), v))
,′ 1 > ε
[((), b : ((), v))]
8
((), b : ((), v))
′1 > ε
[(b : ((), v))]
9
1
> ε
[(b : ((), v))]
10
(b : ((), v), 1)
ε
[]
11
(((), v), 1)
b
[]
. . . положим (((), v), 1) ≡v1 . . .
12
v1
<< S,′ 0 >= b(′1, c)
[]
13
v1
< S,′ 0 >= b(′1, c)
[v1]
14
v1
S,′ 0 >= b(′1, c)
[v1; v1)]
15
1
,′ 0 >= b(′1, c)
[v1; v1]
16
v1
′0 >= b(′1, c)
[1; v1]
17
0
>= b(′1, c)
[1; v1]
18
(1, 0)
= b(′1, c)
[v1]
19
false
b(′1, c)
[v1]
В этом месте выполняется инструкция ветвления по условию false.

40
Расширение и реализация КАМ
Терм
Код
Стек
20
v1
c
[]
21
v1
< S, < F|S, < S,′ 1 > −> ε > ∗
[]
22
(((), v), 1)
S, < F|S, < S,′ 1 > −> ε > ∗
[v1]
23
1
, < F|S, < S,′ 1 > −> ε > ∗
[v1]
24
v1
< F|S, < S,′ 1 > −> ε > ∗
[1]
25
(((), v), 1)
F|S, < S,′ 1 > −> ε > ∗
[v1; 1]
26
v
, < S,′ 1 > −> ε > ∗
[v1; 1]
27
v1
< S,′ 1 > −> ε > ∗
[v; 1]
28
(((), v), 1)
S,′ 1 > −> ε > ∗
[v1; v; 1]
29
1
,′ 1 > −> ε > ∗
[v1; v; 1]
30
v1
′1 > −> ε > ∗
[1; v; 1]
31
1
> −> ε > ∗
[1; v; 1]
32
(1, 1)
−> ε > ∗
[v; 1]
33
0
> ε > ∗
[v; 1]
34
(v, 0)
ε > ∗
[1]
. . . v = (b : ((), v)) . . .
35
(b : ((), v), 0)
ε > ∗
[1]
36
(((), v), 0)
b > ∗
[1]
37
(((), v), 0)
<< S,′ 0 >= b(′1, c) > ∗
[1]
. . . положим (((), v), 0) ≡v0 . . .
38
v0
< S,′ 0 >= b(′1, c) > ∗
[v0; 1]
39
(((), v), 0)
S,′ 0 >= b(′1, c) > ∗
[v0; v0; 1]
40
0
,′ 0 >= b(′1, c) > ∗
[v0; v0; 1]
41
v0
′0 >= b(′1, c) > ∗
[0; v0; 1]
42
0
>= b(′1, c) > ∗
[0; v0; 1]
43
(0, 0)
= b(′1, c) > ∗
[v0; 1]
44
true
b(′1, c) > ∗
[v0; 1]
45
v0
′1 > ∗
[1]
46
1
> ∗
[1]
47
(1, 1)
∗
[]
48
1
[]
[]
На этом вычисление n! = 1! = 1 завершается. Как можно заметить,
все вычисления производились с непосредственным использованием
свойств комбинатора неподвижной точки Y . Отметим, что имеет-
ся способ сократить число непосредственно записываемых инструк-
ций. Это способ организации циклов для выполнения последователь-
ностей КАМ-инструкций. Для определения требуемой конструкции
цикла сначала попытаемся как следует уяснить, в чем именно состо-

3.2 Вычисления с рекурсивной модификацией среды
41
ит цикличность в КАМ-вычислениях. Проведем вычисление n! = 2!
= 2 × 1 = 2, пользуясь нумерацией строк предыдущего вычисления.
Заметим, что (λg.g 2)(Y (. . .)) = 2!.
Терм
Код
Стек
1
()
<< y > Λ(b) >< S,′ 2 > ε
[]
11
(((), v), 2)
b
[]
. . . положим (((), v), 2) ≡v2 . . .
12
v2
<< S,′ 0 >= b(′1, c)
[]
18
(2, 0)
= b(′1, c)
[v2]
19
false
b(′1, c)
[v2]
В этом месте выполняется инструкция ветвления по условию false.
Терм
Код
Стек
20
v2
c
[]
21
v2
< S, < F|S, < S,′ 1 > −> ε > ∗
[]
22
(((), v), 2)
S, < F|S, < S,′ 1 > −> ε > ∗
[v2]
23
2
, < F|S, < S,′ 1 > −> ε > ∗
[v2]
24
v2
< F|S, < S,′ 1 > −> ε > ∗
[2]
25
(((), v), 2)
F|S, < S,′ 1 > −> ε > ∗
[v2; 2]
26
v
, < S,′ 1 > −> ε > ∗
[v2; 2]
27
v2
< S,′ 1 > −> ε > ∗
[v; 2]
28
(((), v), 2)
S,′ 1 > −> ε > ∗
[v2; v; 2]
29
2
,′ 1 > −> ε > ∗
[v2; v; 2]
30
v2
′1 > −> ε > ∗
[2; v; 2]
31
1
> −> ε > ∗
[2; v; 2]
32
(2, 1)
−> ε > ∗
[v; 2]
33
1
> ε > ∗
[v; 2]
34
(v, 1)
ε > ∗
[2]
Для продолжения вычислений требуется выполнить рекурсивную мо-
дификацию среды.

42
Расширение и реализация КАМ
Терм
Код
Стек
. . . v = (b : ((), v)) . . .
35
(b : ((), v), 1)
ε > ∗
[2]
36
(((), v), 1)
b > ∗
[2]
37
(((), v), 1)
<< S,′ 0 >= b(′1, c) > ∗
[2]
. . . положим (((), v), 1) ≡v1 . . .
38
v1
< S,′ 0 >= b(′1, c) > ∗
[v1; 2]
39
(((), v), 1)
S,′ 0 >= b(′1, c) > ∗
[v1; v1; 2]
40
1
,′ 0 >= b(′1, c) > ∗
[v1; v1; 2]
41
v1
′0 >= b(′1, c) > ∗
[1; v1; 2]
42
0
>= b(′1, c) > ∗
[1; v1; 2]
43
(1, 0)
= b(′1, c) > ∗
[v1; 2]
Заметим, что дальнейшие вычисления аналогичны (с некоторой мо-
дификацией) вычислениям, начиная со строки 19, поэтому будем при-
менять двойную нумерацию.
Терм
Код
Стек
44(19)
false
b(′1, c) > ∗
[v1; 2]
45(20)
v1
c > ∗
[2]
46(21)
v1
< S, < F|S, < S,′ 1 > −> ε > ∗> ∗
[2]
47(22)
(((), v), 1)
S, < F|S, < S,′ 1 > −> ε > ∗> ∗
[v1; 2]
48(23)
1
, < F|S, < S,′ 1 > −> ε > ∗> ∗
[v1; 2]
49(24)
v1
< F|S, < S,′ 1 > −> ε > ∗> ∗
[1; 2]
50(25)
(((), v), 1)
F|S, < S,′ 1 > −> ε > ∗> ∗
[v1; 1; 2]
51(26)
v
, < S,′ 1 > −> ε > ∗> ∗
[v1; 1; 2]
52(27)
v1
< S,′ 1 > −> ε > ∗> ∗
[v; 1; 2]
53(28)
(((), v), 1)
S,′ 1 > −> ε > ∗> ∗
[v1; v; 1; 2]
54(29)
1
,′ 1 > −> ε > ∗> ∗
[v1; v; 1; 2]
55(30)
v1
′1 > −> ε > ∗> ∗
[1; v; 1; 2]
56(31)
1
> −> ε > ∗> ∗
[1; v; 1; 2]
57(32)
(1, 1)
−> ε > ∗> ∗
[v; 1; 2]
58(33)
0
> ε > ∗> ∗
[v; 1; 2]
59(34)
(v, 0)
ε > ∗> ∗
[1; 2]
Теперь для продолжения вычислений требуется выполнить рекурсив-
ную модификацию среды.

3.3 Организация цикла mkloop
43
Терм
Код
Стек
. . . v = (b : ((), v)) . . .
60(35)
(b : ((), v), 0)
ε > ∗> ∗
[1; 2]
61(36)
(((), v), 0)
b > ∗> ∗
[1; 2]
62(37)
(((), v), 0)
<< S,′ 0 >= b(′1, c) > ∗> ∗
[1; 2]
. . . положим (((), v), 0) ≡v0 . . .
63(38)
v0
< S,′ 0 >= b(′1, c) > ∗> ∗
[v0; 1; 2]
64(39)
(((), v), 0)
S,′ 0 >= b(′1, c) > ∗> ∗
[v0; v0; 1; 2]
65(40)
0
,′ 0 >= b(′1, c) > ∗> ∗
[v0; v0; 1; 2]
66(41)
v0
′0 >= b(′1, c) > ∗> ∗
[0; v0; 1; 2]
67(42)
0
>= b(′1, c) > ∗> ∗
[0; v0; 1; 2]
68(43)
(0, 0)
= b(′1, c) > ∗> ∗
[v0; 1; 2]
69(44)
true
b(′1, c) > ∗> ∗
[v0; 1; 2]
В этом месте выполняется инструкция ветвления по условию true.
Терм
Код
Стек
69(44)
(((), v), 0)
′1 > ∗> ∗
[1; 2]
70(45)
1
> ∗> ∗
[1; 2]
71(46)
(1, 1)
∗> ∗
[2]
72(47)
1
> ∗
[2]
73(48)
(2, 1)
∗
[]
74
2
[]
[]
На этом вычисление 2! завершено. Отметим, что дополнительные
строки в таблице потребовались для вычисления содержимого из сте-
ка рекурсии.
3.3 Организация цикла mkloop
Вычисления, которые были приведены в предыдущем подразделе, до-
вольно длинны, хотя и вполне рутинны. Можно отметить, что они со-
держат перекрывающиеся части, которые незначительно отличаются
друг от друга – с точность до параметров. Это оставляет возмож-
ность организации цикла вычислений на КАМ. Для этого применя-
ется вспомогательная команда – инструкция mkloop, – для краткости
обозначаемая через m.
При тех же самых предположениях, касающихся вида выражений,
что и для вычисления факториала, построим кодирование:

44
Расширение и реализация КАМ
∥Y (λλ.P)∥=<′ () >< Λ(∥P∥)m,
где ∥P∥≡p. “Микропрограмма” организации цикла использует ра-
венство
s = p : ((), s).
Представим вычисление значения для приведенного кода:
Терм
Код
Стек
1
(s)
<′ () >< Λ(∥P∥)m
[S]
2
(s)
′() >< Λ(∥P∥)m
[s; S]
3
()
>< Λ(∥P∥)m
[s; S]
4
(s, ())
< Λ(∥P∥)m
[S]
5
(s, ())
Λ(∥P∥)m
[(s, ()); S]
6
p : (s, ())
m
[(s, ()); S]
t = (s, ())
[]
[S]
Для t = a = p : ((), a):
Терм
Код
Стек
a = p : ((), a)
ε
[S]
e = ((), p : ((), e))
p
[S]
Приведем теперь сокращенные вычисления для факториала с исполь-
зованием конструкции цикла. Начальное состояние вычисления:
Терм
Код
Стек
1
()
<<′ () >< Λ(b)m >< S,′ 1 > ε
[]
Продолжая вычисление, получаем:
Терм
Код
Стек
2
((), ())
Λ(b)m >< S,′ 1 > ε
[((), ()); ()]
3
b : ((), ())
m >< S,′ 1 > ε
[((), ()); ()]
4
a = b : ((), a)
>< S,′ 1 > ε
[()]
5
((), a = b : ((), a))
< S,′ 1 > ε
[]
6
((), a = b : ((), a))
S,′ 1 > ε
[((), a = b : ((), a))]
7
(a = b : ((), a))
,′ 1 > ε
[((), a = b : ((), a))]
8
((), a = b : ((), a))
′1 > ε
[(a = b : ((), a))]
9
1
> ε
[(a = b : ((), a))]
10
((a = b : ((), a)), 1)
ε
[]

3.3 Организация цикла mkloop
45
Применение отображения ε дает следующий результат:
a = b : ((), a) 7→((), a) = ((), b : ((), a)),
следовательно, для ((), a) ≡t, пользуясь сокращениями (t = ((), b :
t), 1) ≡b1, (t = ((), b : t), 0) ≡b0, получаем:
Терм
Код
Стек
11
(t = ((), b : t), 1)
b
[]
12
(t = ((), b : t), 1)
<< S,′ 0 >= b(′1, c)
[]
13
(t = ((), b : t), 1)
S,′ 0 >= b(′1, c)
[b1; b1]
14
1
,′ 0 >= b(′1, c)
[b1; b1]
15
0
>= b(′1, c)
[1; b1]
16
(1, 0)
= b(′1, c)
[b1]
17
false
b(′1, c)
[b1]
18
b1
< S, < F|S, < S,′ 1 > −> ε > ∗
[]
19
1
, < F|S, < S,′ 1 > −> ε > ∗
[b1]
20
(t = ((), b : t), 1)
< F|S, < S,′ 1 > −> ε > ∗
[1]
21
(t = ((), b : t), 1)
F|S, < S,′ 1 > −> ε > ∗
[b1; 1]
22
b : (t = ((), b : t))
, < S,′ 1 > −> ε > ∗
[b1; 1]
Далее следуют рутинные вычисления, в которых используется сокра-
щение b : (t = ((), b : t)) ≡b.
Терм
Код
Стек
23
b1
< S,′ 1 > −> ε > ∗
[b; 1]
24
(t = ((), b : t), 1)
S,′ 1 > −> ε > ∗
[b1; b; 1]
25
1
,′ 1 > −> ε > ∗
[b1; b; 1]
26
b1
′1 > −> ε > ∗
[1; b; 1]
27
1
> −> ε > ∗
[1; b; 1]
28
(1, 1)
−> ε > ∗
[b; 1]
29
0
> ε > ∗
[b; 1]
30
(b, 0)
ε > ∗
[1]
Теперь ε замещается на код и вычисляется.

46
Расширение и реализация КАМ
Терм
Код
Стек
31
((t = ((), b : t)), 0)
<< S,′ 0 >= b(′1, c) > ∗
[1]
32
((t = ((), b : t)), 0)
S,′ 0 >= b(′1, c) > ∗
[b0; b0; 1]
33
0
,′ 0 >= b(′1, c) > ∗
[b0; b0; 1]
34
b0
′0 >= b(′1, c) > ∗
[0; b0; 1]
35
0
>= b(′1, c) > ∗
[0; b0; 1]
36
(0, 0)
= b(′1, c) > ∗
[b0; 1]
37
true
b(′1, c) > ∗
[b0; 1]
38
b0
′1 > ∗
[1]
39
1
> ∗
[1]
40
(1, 1)
∗
[]
41
1
[]
[]
3.4 Рекурсия и ленивые вычисления
До сих пор рассматривались механизмы означивания вызова по зна-
чению (call by value, CBV). В этом случае аргументы как функций,
так и совокупностей означиваются полностью. Как известно, вызов по
имени (call by name, CBN), или ленивое означивание, позволяет избе-
жать бесполезных вычислений, тем самым обеспечивая возможности
работы с бесконечными структурами. Естественным путем реализа-
ции вызова по имени является введение явного задерживания вычи-
слений – откладывания вычислений. Для этого в рамках механизма
вызова по имени вводится инструкция freeze и парная ей инструкция
unfreeze, действие которых приведено в таблице 3.2. Третья строка
Таблица 3.2. Ленивые вычисления и лейзы
Старое состояние
Новое состояние
терм
код
стек
терм′
код′
стек′
s
(freeze C).C1
S
C.s
C1
S
C.s
unfreeze.C
S
s
C
S
s
unfreeze.C
S
s
C
S
в таблице описывает случай вычисления, когда вторая строка непри-
менима.

3.4 Рекурсия и ленивые вычисления
47
Элемент (C.s), который ссылается на Ms, в случае, когда C
является кодом для M, называется лейзом (laze).
Итак, действие дополнительных конструкций сводится к следующе-
му:
freeze :
замещает терм s на структуру (C.s), где C – код, инка-
псулированный в инструкцию замораживания;
unfreeze :
не выполняет никакого действия до тех пор, пока терм
не принимает вид лейза C.s, в котором C записан в пре-
фикс кода (включая ‘unfreeze’), и терм становится s.
Введение в употребление лейзов изменяет способ трактовки компо-
нентов терма абстрактной машины. При допущении использования
лейзов терм понимается не как конструкция, состоящая из значений,
а как конструкция, состоящая из неозначенных выражений. Теперь
терм может оказаться лейзом, а во время компиляции инструкция
должна быть снабжена префиксом в виде кода, который вынуждает
означивание лейза. Такую роль играет unfreeze.
Механизм ленивых вычислений опирается на следующие предпо-
ложения:
либо неявное инкапсулирование кодов M, N в инструкции unfreeze,
когда, например, компилируется аппликация ε◦< M, N >,
либо явное введение примитивов unfreeze при специфицировании
языка высокого уровня.
Будем считать, что при любом из подходов компилятор по мере необ-
ходимости в состоянии производить инструкции unfreeze.
Пример 3.4.1. Рассмотрим конструкцию
let z = 3 in (λx.z)(freeze((λy.y)4)),
причем введем следующие сокращения: f ≡freeze, V ≡∥((λy.y)4)∥.
Поскольку
P = (λz.(λx.z)(f((λy.y)4)))3,
то

48
Расширение и реализация КАМ
∥P∥
=
∥(λ.(λ.1)(f((λ.0)4)))3∥
=
ε◦< ∥λ.(λ.1)(f((λ.0)4))∥, ∥3∥>
=
ε◦< Λ(∥(λ.1)(f((λ.0)4))∥),′ 3 >
=
∥(λ.1)(f((λ.0)4))∥◦<′ 3 >
(Beta)
=
ε◦< ∥λ.1∥, ∥(f((λ.0)4))∥> ◦<′ 3 >
=
ε◦< Λ∥1∥, f∥(λ.0)4∥> ◦<′ 3 >
=
ε◦< Λ(F|S), f(V) > ◦<′ 3 >
≡
<′ 3 >< Λ(F|S), f(V) > ε
Тогда вычисления на КАМ приводят к следующему результату:
Терм
Код
Стек
1
()
<′ 3 >< Λ(F|S), f(V) > ε
[]
2
()
′3 >< Λ(F|S), f(V) > ε
[()]
3
3
>< Λ(F|S), f(V) > ε
[()]
4
((), 3)
< Λ(F|S), f(V) > ε
[]
5
((), 3)
Λ(F|S), f(V) > ε
[((), 3)]
6
(F|S) : ((), 3)
, f(V) > ε
[((), 3)]
7
((), 3)
f(V) > ε
[(F|S) : ((), 3)]
8
V.((), 3)
> ε
[(F|S) : ((), 3)]
В терме сформирован лейз V.((), 3). Продолжая вычисления, получаем
следующий результат:
Терм
Код
Стек
9
((F|S) : ((), 3), V.((), 3))
ε
[]
10
(((), 3), V.((), 3))
F|S
[]
11
((), 3)
S
[]
12
3
[]
[]
В этом примере применением конструкции freeze с последующим по-
строением лейза V.((), 3) удалось избежать лишних вычислений, свя-
занных с означиванием V ≡∥((λy.y)4)∥.
Приведем еще один пример использования лейзов для обработки
рекурсивно определенных списков.
Пример 3.4.2. Рассмотрим конструкцию
letrec x = [1, freeze x] in fst(snd(x)); ;
Для компилирования кода проделаем следующие преобразования:

3.4 Рекурсия и ленивые вычисления
49
x = [1, f x]
=
(λx.[1, f x])x
=
Y (λx.[1, f x])
по т.н.т.
=
Y (λ.[1, f 0])
В данном случае использована теорема о неподвижной точке. Посколь-
ку, как известно, комбинаторная характеристика Y
Y M = M(Y M)
принимает вид
∥Y M∥= ∥M(Y M)∥
=
ε◦< ∥M∥, ∥Y M∥>,
то частные решения этого уравнения будем искать для
∥M∥≡∥λ.P∥,
откуда
∥Y M∥
=
ε◦< ∥M∥, ∥Y M∥>
=
ε◦< Λ∥P∥, ∥Y M∥>
=
∥P∥◦< I, ∥Y M∥>
по (Beta)
В данном случае
∥P∥
≡
∥[1, f 0]∥
=
<′ 1, f(Snd) >
≡
<′ 1, f(S) >
Теперь исходную конструкцию можно переписать как
let x = Y (λ.[1, freeze 0]) in fst(snd(x)); ;
Далее,
W
≡
(λg.fst(snd(g)))(Y (λ.[1, freeze 0]))
=
(λ.fst(snd(0)))(Y (λ.[1, freeze 0]))
Компилирование кода с применением оптимизации (Beta) дает следу-
ющий результат:

50
Расширение и реализация КАМ
∥W∥= ε◦< Λ(∥fst(snd(0))∥), ∥Y (λ.[1, freeze 0])∥>
= ∥fst(snd(0))∥◦< I, ∥Y (λ.[1, freeze 0])∥>
≡∥(fst ◦snd)(0)∥◦< I, ∥Y (λ.[1, freeze 0])∥>
≡∥(fst ◦snd)(0)∥◦< I, ∥Y (λ.[1, freeze 0])∥>
= ε◦< Λ((fst ◦snd) ◦Snd), Snd > ◦< I, ∥Y (λ.[1, freeze 0])∥>
= ((fst ◦snd) ◦Snd)◦< I, Snd > ◦< I, ∥Y (λ.[1, freeze 0])∥>
= ((fst ◦snd) ◦Snd)◦< I, Snd > ◦< I, ∥Y (λ.[1, freeze 0])∥>
= (fst ◦snd) ◦∥Y (λ.[1, freeze 0])∥>
≡F ◦u ◦S ◦∥Y (λ.[1, freeze 0])∥
≡∥Y (λ.[1, freeze 0])∥S u F
=<′ () ><<′ 1, f(S) > m S u F
(mkloop)
в соответствии с результатами, полученными в подразделе 2.3. (Здесь:
u – это указатель unfreeze для цикла рекурсии.) Построим следую-
щую таблицу вычислений, вводя сокращение e2 ≡((), ()):
Терм
Код
Стек
1
()
<′ () ><<′ 1, f(S) > m S u F
[]
2
()
′() ><<′ 1, f(S) > m S u F
[()]
3
()
><<′ 1, f(S) > m S u F
[()]
4
((), ())
<<′ 1, f(S) > m S u F
[]
5
((), ())
<′ 1, f(S) > m S u F
[((), ())]
6
((), ())
′1, f(S) > m S u F
[e2; e2]
7
1
, f(S) > m S u F
[e2; e2]
8
((), ())
f(S) > m S u F
[1; ((), ())]
9
S.((), ())
> m S u F
[1; ((), ())]
10
(1, S.((), ()))
m S u F
[((), ())]
11
s = (1, S.((), s))
S u F
[]
Поскольку имеется лейз S.((), s) ≡t, где
s
=
(1, S.((), s))
≡
(1, t)
=
(1, S.((), (1, S.((), s))))
≡
(1, S.((), (1, t))),
то для ‘второй’ проекции имеем
t = S.((), (1, t))
и в строке 12 выполняется модификация среды.

3.4 Рекурсия и ленивые вычисления
51
Терм
Код
Стек
12
t = S.((), (1, t))
u F
[]
13
((), s = ((), (1, S.((), s))))
S u F
[]
14
s = (1, S.((), s))
u F
[]
15
s = (1, S.((), s))
F
[]
16
1
[]
[]
В строке 13 пользуемся равенством
(1, t) = (1, S.((), s)).

52
Расширение и реализация КАМ

Литература
[1] Илюхин А.А., Исмаилова Л.Ю., Шаргатова З.И. Экспертные системы
на реляционной основе. М.: МИФИ, 1990. – 64 с.
[2] Косиков С.В., Мясников А.В. Математические методы и средства в
новой информационной технологии. М.: МИФИ, 1990. – 48 с.
[3] Amadio R.M., Curien P.-L. Domains and lambda-calculi. Cambridge Tracts
in Theretical Computer Science, 46, Cambridge, Cambridge University
Press, 1998. – 484 p.
[4] Benˆatre
J.-P.,
Jones
S.B.,
LeM´etayer
D.
Prospects
for
functional
programming in software engineering. ESPRIT Project (European Strategic
Programme for Research and Development in Information Technology
Project). Vol. 1, Springer, 1991. – 210 p.
[5] Cousineau G., Curien P.-L., Mauny M. The categorical abstract machine.
Lecture Notes in Computer Science, №201, 1985, pp. 50–64.
[6] Cousineau
G.,
Curien
P.-L.,
Mauny
M.,
Su´arez
A.
Combinateurs
cat´egoriques et impl´ementation des langages fonctionnels. Lecture Notes in
Computer Science, №242, 1986, pp. 85–103.
[7] De Bruijn N.G. Lambda-calculus notations with nameless dummies: a tool
for automatic formula manipulation. Indag. Math., 34, 1972, pp. 381–392.
[8] Wikstr¨om A. Functional programming using standard ML. Prentice Hall Int.,
Series in Computer Science, 1987. – 446 p.
[9] Winston P., Horn B. LISP. Addison Wesley, 1981.

Предметный указатель
Вычисление, 1
индентификатор, 5
коллизия
– имен, 6
лейз, 47
объект, 5
числа
– Дебрейна, 6
54

Категориальная абстрактная машина. Конспект лекций:
введение в вычисления
Макет:
Автор
АОЗТ “Учебно-консультационный центр “ЮрИнфоР”
103006, Москва, Воротниковский пер., 7, тел. 299-6500
Лицензия на издательскую деятельность
ЛР №071236 от 21 ноября 1995 г.
Подписано в печать
Формат 84×108/32. Бумага офсет №1. Гарнитура Таймс.
Печать офсетная. Усл.-печ.л.
Учетн.-изд.л.
Тираж
экз. Заказ №
Отпечатано
Все права принадлежат
АОЗТ “Учебно-консультационный центр “ЮрИнфоР”
103006, Москва, Воротниковский пер., 7, тел. 299-6500

