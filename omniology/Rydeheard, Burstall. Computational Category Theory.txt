Computational Category Theory
D.E. Rydeheard
University of Manchester
R.M. Burstall
University of Edinburgh

This is a version of Computational Category Theory that is available
for personal use only. Distributing copies, multiple downloads, availabil-
ity at other websites, or use of any of the text for commercial purposes
is strictly forbidden. Full copyright remains with the authors.


Contents
1
Introduction
1
1.1
The contents
4
1.2
Accompanying texts
6
1.2.1
Textbooks on category theory
6
1.2.2
ML references and availability
7
1.2.3
A selection of textbooks on functional programming
7
1.3
Acknowledgements
8
2
Functional Programming in ML
9
2.1
Expressions, values and environments
11
2.2
Functions
13
2.2.1
Recursive deﬁnitions
14
2.2.2
Higher order functions
14
2.3
Types
15
2.3.1
Primitive types
16
2.3.2
Compound types
16
2.3.3
Type abbreviation
17
2.4
Type polymorphism
17
2.5
Patterns
20
2.6
Deﬁning types
21
2.7
Abstract types
24
2.8
Exceptions
26
2.9
Other facilities
27
2.10 Exercises
27
3
Categories and Functors
35
3.1
Categories
35
vii

3.1.1
Diagram chasing
38
3.1.2
Subcategories, isomorphisms, monics and epis
39
3.2
Examples
40
3.2.1
Sets and ﬁnite sets
40
3.2.2
Graphs
40
3.2.3
Finite categories
41
3.2.4
Relations and partial orders
41
3.2.5
Partial orders as categories
42
3.2.6
Deductive systems
42
3.2.7
Universal algebra: terms, algebras and equations
43
3.2.8
Sets with structure and structure-preserving arrows
46
3.3
Categories computationally
47
3.4
Categories as values
49
3.4.1
The category of ﬁnite sets
49
3.4.2
Terms and term substitutions: the category TΩF in
50
3.4.3
A ﬁnite category
52
3.5
Functors
53
3.5.1
Functors computationally
54
3.5.2
Examples
54
3.6
Duality
55
3.7
An assessment∗
57
3.8
Conclusion
60
3.9
Exercises
60
4
Limits and Colimits
65
4.1
Deﬁnition by universality
67
4.2
Finite colimits
68
4.2.1
Initial objects
69
4.2.2
Binary coproducts
70
4.2.3
Coequalizers and pushouts
72
4.3
Computing colimits
74
4.4
Graphs, diagrams and colimits
79
4.5
A general construction of colimits
82
4.6
Colimits in the category of ﬁnite sets
88
4.7
A calculation of pushouts
90
4.8
Duality and limits
93
4.9
Limits in the category of ﬁnite sets
95
4.10 An application: operations on relations
97
4.11 Exercises
100

5
Constructing Categories
103
5.1
Comma categories
104
5.1.1
Representing comma categories
105
5.2
Colimits in comma categories
107
5.3
Calculating colimits of graphs
109
5.4
Functor categories
113
5.4.1
Natural transformations
113
5.4.2
Functor categories
114
5.5
Colimits in functor categories
116
5.6
Duality and limits
118
5.7
Abstract colimits and limits∗
120
5.7.1
Abstract diagrams and colimits
121
5.7.2
Category constructions
122
5.7.3
Indexed colimit structures
123
5.7.4
Discussion
123
5.8
Exercises
124
6
Adjunctions
127
6.1
Deﬁnitions of adjunctions
128
6.2
Representing adjunctions
130
6.3
Examples
131
6.3.1
Floor and ceiling functions: converting real num-
bers to integers
132
6.3.2
Components of a graph
132
6.3.3
Free algebras
134
6.3.4
Graph theory
136
6.3.5
Limits and colimits
138
6.3.6
Adjunctions and comma categories
138
6.3.7
Examples from algebra and topology
139
6.4
Computing with adjunctions
140
6.5
Free algebras
142
6.5.1
Constructing free algebras
143
6.5.2
A program
144
6.5.3
An example: transitive closure
146
6.5.4
Other constructions of free algebras
149
6.6
Exercises
152
7
Toposes
155
7.1
Cartesian closed categories
156
7.1.1
An example: the category of ﬁnite sets
157
7.2
Toposes
159

7.2.1
An example: the topos of ﬁnite sets
161
7.2.2
Computing in a topos
162
7.2.3
Logic in a topos
164
7.2.4
An example: a three-valued logic
166
7.3
Conclusion
170
7.4
Exercises
171
8
A Categorical Uniﬁcation Algorithm
173
8.1
The uniﬁcation of terms
174
8.2
Uniﬁcation as a coequalizer
175
8.3
On constructing coequalizers
176
8.4
A categorical program
180
9
Constructing Theories
187
9.1
Preliminaries
188
9.2
Constructing theories
190
9.3
Theories and institutions
194
9.4
Colimits of theories
197
9.5
Environments
199
9.6
Semantic operations
200
9.7
Implementing a categorical semantics
201
10 Formal Systems for Category Theory
203
10.1 Formal aspects of category theory
204
10.2 Category theory in OBJ
207
10.3 Category theory in a type theory
216
10.4 Categorical data types
218
A ML Keywords
223
B Index of ML Functions
225
C Other ML Functions
229
D Answers to Programming Exercises
231

Foreword
John W. Gray
Why should there be a book with such a strange title as this one? Isn’t
category theory supposed to be a subject in which mathematical struc-
tures are analyzed on such a high level of generality that computations
are neither desirable nor possible? Historically, category theory arose in
algebraic topology as a way to explain in what sense the passages from
geometry to algebra in that ﬁeld are ‘natural’ in the sense of reﬂecting
underlying geometric reality rather than particular representations in
that reality. The success of this endeavor led to many similar studies of
geometric and algebraic interrelationships in other parts of mathematics
until, at present, there is a large body of work in category theory ranging
from purely categorical studies to applications of categorical principles in
almost every ﬁeld of mathematics. This work has usually been presented
in a form that emphasizes its conceptual aspects, so that category theory
has come to be viewed as a theory whose purpose is to provide a certain
kind of conceptual clarity.
What can all of this have to do with computation? The fact of the
matter is that category theory is an intensely computational subject, as
all its practitioners well know. Categories themselves are the models of
an essentially algebraic theory and nearly all the derived concepts are
ﬁnitary and algorithmic in nature. One of the main virtues of this book
is the unrelenting way in which it proceeds from algorithm to algorithm
until all of elementary category theory is laid out in precise computational
form. This of course cannot be the whole story because there are some
deep and important results in category theory that are non-constructive
and that cannot therefore be captured by any algorithm. However, for
many purposes, the constructive aspects are central to the whole subject.
This is important for several reasons. First of all, one of the most

important features of category theory is that it is a guide to computation.
The conceptual clarity gained from a categorical understanding of some
particular circumstance in mathematics enables one to see how a com-
putation of relevant entities can be carried out for special cases. When
the special case is itself very complex, as frequently is the case, then it
is a tremendous advantage to know exactly what one is trying to do and
in principle how to carry out the computation. The idea of mechanizing
such computations is very intriguing. The present book, of course, does
not enable one to do this, but it can be viewed as an essential precur-
sor of developments that will lead to such mechanization.
Categories
themselves must be present in the computer as well as many particular
examples of them before mechanical computation of categorical entities
can be carried out.
Secondly, the fact that category theory is essentially algebraic means
that it can be learned by learning these basic constructions. It comes
as something of a shock to realize that one aspect of category theory is
that it is ‘just’ a collection of ML-algorithms. However, it is particu-
larly important for computer scientists and students of computer science
that there is such a programming language representation of the subject.
Because mathematicians have accumulated geometric and algebraic intu-
itions, many things can be elided in presenting category theory to them.
But computer scientists generally lack these intuitions, so these elisions
can present a great diﬃculty for them. Computer code does not permit
such elisions and thus presents the basic material in a form that reas-
sures computer scientists and allows them to use their intuitions for and
understanding of programs to gain an advantage similar to the mathe-
maticians’ advantage from their knowledge of geometry and algebra.
Of course, all of this is beside the point unless there is a reason
for computer scientists to need to learn category theory. However, the
reasons are easily found by looking into almost any issue of a journal
in theoretical computer science. Either the category theory is explicitly
there or should be there and is missing only at the expense of devious
circumlocutions. It really cannot be avoided in discussing the semantics
of programming languages. The most dramatic instance of this arises in
the semantics of the polymorphic lambda calculus which underlies ML. It
really is an engaging thought that one needs category theory to explain
ML, while in turn ML is a vehicle for explaining category theory.
That brings up the last point. There is another audience for this
book; namely, category theorists who want to understand theoretical
computer science so that they can participate in the exciting interactions

that are taking place between these two ﬁelds. One very important entry
point into the problems of theoretical computer science is just to examine
computer programs and to wonder what they mean. There probably is
no ﬁnal answer to this question, but along the way, this book can serve
as an invaluable stimulus to further research.


Preface
This is an account of a project we have undertaken in which basic con-
structions of category theory are expressed as computer programs. The
programs are written in a functional programming language, called ML,
and have been executed on examples.
We have used these programs
to develop algorithms for the uniﬁcation of terms and to implement a
categorical semantics.
This book should be helpful to computer scientists wishing to under-
stand the computational signiﬁcance of theorems in category theory and
the constructions carried out in their proofs. Specialists in programming
languages should be interested in the use of a functional programming
language in this novel domain of application, particularly in the way in
which the structure of programs is inherited from that of the mathemat-
ics. It should also be of interest to mathematicians familiar with category
theory – they may not be aware of the computational signiﬁcance of the
constructions arising in categorical proofs.
In general, we are engaged in a bridge-building exercise between cat-
egory theory and computer programming. Our eﬀorts are a ﬁrst attempt
at connecting the abstract mathematics with concrete programs, whereas
others have applied categorical ideas to the theory of computation.
The original motivation for embarking on the exercise of program-
ming categorical constructions was a desire to get a better grip on cate-
gorical ideas, making use of a programmer’s intuition. The abstractness
of category theory makes it diﬃcult for many computer scientists to mas-
ter it; writing code seemed a good way to bring it down to earth. Some-
one with a computing background who wishes to learn category theory
should have recourse to standard texts, some of which are listed later,
xv

but could well ﬁnd this book a helpful companion text.
Mathemati-
cians who have learned a little programming, perhaps in conventional
languages like Pascal, may proﬁt from seeing how the functional pro-
gramming style can embody abstract mathematics and do it in a way
not too far from mathematical notation.
In preparing this book, we would especially like to thank John Gray
for contributing a foreword. His enthusiasm for this project will be evi-
dent. Tony Hoare and the referees gave detailed comments for improving
the book. Mike Spivey carefully read the manuscript and gave some use-
ful comments. Anne Rydeheard and John Stell undertook some proof-
reading for which we are grateful.
Ma Qing Ming and Don Sannella
pointed out some errors in an early draft. Finally, we are indebted to
LATEX2 and Microsoft Word 3, two document preparation systems used
for the book.

Chapter 1
Introduction
The usual occupation in computer science is to build a tool of some
kind, for example, a compiler or a window manipulation package.
In
pure mathematics, on the other hand, we deﬁne new entities, for exam-
ple, complex numbers, and demonstrate their properties. The motivation
in this book is neither of these; rather it is to illustrate a connection be-
tween two hitherto widely separated branches of knowledge: computer
programming and category theory.
We started oﬀin a spirit of cre-
ative play, programming some basic constructions in category theory.
We hoped that it would provide a tool for advanced programming, har-
nessing the abstraction of category theory for use in program design.
These hopes have not really been realized by our work so far. However,
we do present two example applications where categorical constructions
are used in the development of programs. More immediately our work
has educational value for both computer scientists and mathematicians.
Category theory should have a particular interest for computer scien-
tists because it seems to operate on the same level of generality as logic
and computer programming. None of these are committed to any par-
ticular branch of mathematics, such as algebra or number theory. The
essential virtue of category theory is as a discipline for making deﬁnitions,
and making deﬁnitions is the programmer’s main task in life. What else
is the programmer doing when she writes code? Somehow categorical
deﬁnitions come in larger chunks than deﬁnitions of individual functions
in a program. Notably, when we deﬁne the adjoint to a functor, we get
a new functor (a parameterized data type), a natural transformation (a
function) and a bijection between hom-sets (another function). Thus an
adjoint deﬁnition corresponds to a module in a programming language
rather than a single function deﬁnition, but it is a module which has
1

some internal cohesion and raison d’ˆetre, instead of a bundle of func-
tions which the modularly-minded programmer has forced into uneasy
proximity.
Another reason why computer scientists might be interested in cat-
egory theory is that it is largely constructive. Theorems asserting the
existence of objects are proven by explicit construction.
This means
that we can view category theory as a collection of algorithms. These
algorithms have a generality beyond that normally encountered in pro-
gramming in that they are parameterized over an arbitrary category and
so can be specialized to diﬀerent data structures.
We have expressed categorical algorithms in ML, a functional pro-
gramming language.
Functional languages are closer to mathematical
notation than are imperative languages like Basic or Pascal. One writes
expressions to denote mathematical entities rather than deﬁning the tran-
sitions of an abstract machine. ML also provides types which make a pro-
gram much more intelligible and prevent some programming mistakes.
ML has polymorphic types which allow us to express in programs some-
thing of the generality of category theory.
However, the type system
of ML is not suﬃciently sophisticated to prevent the illegal composition
of two arrows whose respective source and target do not match. This
requires a computation of equality on objects. It is an open question
whether a programming language with dependent types or a subtype
mechanism can do better.
The relationship of the mathematics to the ML code is as follows:
(1) categorical concepts are represented as types in ML, and (2) con-
structive proofs of theorems in category theory become ML programs.
For instance, the theorem that if a category has an initial object and
pushouts then it has all ﬁnite colimits yields an iterative algorithm for
constructing the colimiting cocone of a ﬁnite diagram, starting with the
initial object and using the pushout at each iteration.
We should make it clear that we have not invented a new program-
ming language or a new speciﬁcation language. We simply used an exist-
ing functional language, ML, to write a novel kind of program of unusual
generality. Tatsuya Hagino has indeed invented such a new language for
programming and speciﬁcation, based on adjoints. It turns out to be very
like ML, almost identical in its expressive power, but using fewer primi-
tive notions and hence having a more rational structure, a sort of natural
mathematical unfolding of the main language concepts as opposed to a
computer science evolution of them by trial and error of language design-
ers. We say a little about Hagino’s work in Chapter 10.

It has been clear for a long time that the many of the proofs in cat-
egory theory are constructive and hence could be translated into algo-
rithms; so in a mathematical sense we have just spelled out the obvious.
However, from a programming point of view, there is considerable in-
terest in seeing carefully worked out programs to represent the essence
of the categorical proofs and to notice that these programs have a cer-
tain elegance and pleasing structure. We went to considerable trouble
through various formulations to embody as much of the elegance of the
categorical approach as possible in our programs. For example, having
written a certain function which we needed, we noticed that it formed
the object part of a functor and that the arrow would be helpful later on.
Seeing these two functions as part of the same functor is a good example
of categorical thinking imposing mathematical structure on a program.
The Nuprl system [Constable et al. 85] is a proof development system
based on constructive logic which automatically extracts a program from
a proof. It would be interesting to see how such automatically generated
programs compare with our hand-coded ones. Probably in Nuprl one
could obtain elegant programs by creating a proper organization of the
proof, but the question is as yet unexplored. Unlike the Nuprl formu-
lation, our algorithms only represent part of the information in a proof;
they embody the construction; the remaining information in the proof
corresponds to the veriﬁcation showing that the construction produces
the required result.
In programming category theory, we are confronted at the outset by
the problem: how do we represent a category? Do we use a list of ob-
jects and a list of arrows?
This would mean we represent only ﬁnite
categories. Instead we use a functional representation in which the class
of objects and that of arrows are types in ML. This allows us to repre-
sent inﬁnite categories. Another representation problem arises with the
ubiquitous universal properties of category theory. Again we make use
of functions, in this case higher order functions. The programs derived
from categorical constructions are parameterized on categories. In order
to apply the programs to a range of categories, we need systematic ways
of constructing categories rather than explicitly encoding them. Goguen
suggested we use comma categories for computations on structures such
as graphs. We have also made use of functor categories. Another aspect
of category theory that is used in the programming is duality. Duality
is a fundamental principle in category theory arising from the invariance
of the theory under the reversal of arrows. We use it, for instance, to
convert programs computing colimits to those computing limits.

In a ﬁnal chapter we discuss other approaches to computational rep-
resentation of category theory, notably those of Dyckhoﬀand Goguen,
which are similar in spirit to ours, and that of Hagino, which diﬀers
rather radically and interestingly.
We have discovered that applications of our categorical approach to
speciﬁc computing problems are not easily developed. You have to really
understand a task to abstract it in a categorical framework. However, we
have two quite interesting applications, a general uniﬁcation algorithm
using coequalizers, which specializes to known uniﬁcation algorithms,
and a categorical implementation of the speciﬁcation constructing oper-
ations in the language Clear.
Since the early 1970s there has been an increasing amount of interest
in using category theory to explicate aspects of the theory of compu-
tation, in particular, the semantics of programming languages. This is
somewhat outside the scope of this book although we try to indicate
where categorical concepts are relevant to programming. The range of
applications of category theory in computation may be judged from the
proceedings of two conferences published as Lecture Notes in Computer
Science, nos. 240 (1986) and 283 (1987), Springer-Verlag.
1.1
The contents
In the succeeding chapters, we describe the techniques used in the pro-
gramming of category theory.
In Chapter 2, we describe the functional programming language Stan-
dard ML. We cover all the features of ML that we use later in the book,
using illustrative examples. This is meant as a tutorial and a series of
exercises is included. Answers to these exercises may be found in an
appendix to the book. Those with knowledge of ML can safely omit this
chapter. Those with some experience of functional languages may wish
to browse through the chapter to acquaint themselves with the syntax
of ML. Others ought to read the chapter so as to be able to understand
the subsequent programming. In Appendix A there is an index of ML
keywords. This may be used as a reference for reading ML programs.
Programming in ML is often a rewarding experience and we encourage
the reader to get hold of an ML system to practice on.
Chapters 3 to 7 lay out basic category theory.
We describe the
mathematical concepts and constructions and the corresponding ML pro-
grams. We choose illustrative examples which are relevant to program-
ming rather than those drawn from areas of abstract mathematics. In

this, we hope to avoid relying on mathematical intuition but instead,
through the programs, use programmer’s insight to get over the abstract
concepts of category theory.
In Chapter 3, we present categories and functors. We deﬁne them and
show how to represent them in ML. Illustrative examples are included.
We also consider the principle of duality, coding it as operations on cat-
egories and functors. In Chapter 4, we describe how universally deﬁned
concepts may be represented. We deal with limits and colimits. We also
present the ﬁrst substantial programs which arise from categorical con-
structions of colimits. Duality allows us to convert these into programs
computing limits.
Chapter 5 introduces constructions of categories. We concentrate on
comma categories and functor categories.
In each case, under certain
conditions, colimits in constructed categories may be computed from
those in the component categories. We program up this inheritance. By
introducing canonical isomorphisms, duality allows us to convert this
inheritance of colimits to an inheritance of limits.
In Chapter 6, we look at adjunctions. Adjunctions occur widely in
mathematics and programming. We deﬁne them and represent them as
an ML type. We introduce constructions of adjunctions based on the
‘term algebra’ construction of free algebras. In Chapter 7, we brieﬂy in-
troduce toposes taking the theory as far as internal logics within toposes.
We display programs to compute internal logics.
Chapters 8 and 9 are applications of the categorical programming.
In Chapter 8, we consider the uniﬁcation of terms. This is a task aris-
ing in the automation of inference and corresponds to solving equations.
We show how uniﬁcation algorithms may be derived from constructions
of colimits. In Chapter 9, we look at colimits in a diﬀerent role: the
construction of algebraic theories. We implement the semantics of the
algebraic speciﬁcation language, Clear. Operations for combining theo-
ries are described in terms of colimits in certain categories.
Finally, in Chapter 10, we discuss formal (linguistic) aspects of cat-
egory theory. We list some requirements on a formalism for expressing
category theory. We also look at fragments of category theory in for-
malisms other than ML. We present an algebraic treatment in OBJ due
to Goguen and a description of category theory in a constructive type
theory due to Dyckhoﬀ. We also brieﬂy describe an interesting system
of Hagino, which consists of a programming language based upon the
universal concepts of category theory.
We include most of the programs we have written so that this book

may serve as a manual to those wishing to use the categorical program-
ming. At the back of the book in Appendices B and C there is an index
of the functions that we have deﬁned. This provides a cross-reference for
reading the categorical programs.
Some sections in the book are starred. These may safely be omitted
as they contain material somewhat aside from main development.
Exercises will be found scattered throughout the book, mainly at
the end of chapters. Some of these are meant to reinforce the reader’s
understanding or introduce further examples of what has already been
covered. Some, however, are starred exercises. These are more substan-
tial and explore new topics in the form of mini-projects or open-ended
questions.
1.2
Accompanying texts
In this section we give details of some books which the reader may ﬁnd
useful to complement the material of this book.
1.2.1
Textbooks on category theory
This book does not have the breadth or depth of coverage of a mathe-
matical text on category theory. Here topics are chosen for their com-
putational signiﬁcance. Categorical texts are aimed at a mathematical
audience and some require a fairly substantial mathematical background.
We list some textbooks on category theory which expand upon the
material in this book:
Arbib, M. and Manes, E. (1975) Arrows, Structures and Functors: The
Categorical Imperative. Academic Press, London.
Barr, M. and Wells, C. (1985) Toposes, Triples and Theories. Grund-
lehren der mathematischen Wissenschaften, 273, Springer-Verlag,
New York.
Goldblatt, R. (1979) Topoi – The Categorial Analysis of Logic. Studies
in Logic and the Foundations of Mathematics, 98, North-Holland,
Amsterdam.
Herrlich, H. and Strecker, G.E. (1973) Category Theory.
Allyn and
Bacon.

Lambek, J. and Scott, P.J. (1986) Introduction to Higher-order Cate-
gorical Logic. CUP.
Mac Lane, S. (1971) Categories for the Working Mathematician.
Springer-Verlag, New York.
Schubert, H. (1972) Categories. Springer-Verlag, Berlin.
1.2.2
ML references and availability
The two references below are full and readable reports on the version of
the ML language used in this book, called Standard ML:
Harper, R. and Mitchell, K. (1986) Introduction to Standard ML. Un-
published report, University of Edinburgh.
Wikstr¨om, A. (1987) Functional Programming using Standard ML. Pren-
tice Hall International, Hemel Hempstead.
The Standard ML system runs on most machines that support UNIX
( c⃝Bell Laboratories). It is available from:
Laboratory for Foundations of Computer Science,
Department of Computer Science,
University of Edinburgh,
The King’s Buildings,
Edinburgh EH9 3JZ
1.2.3
A selection of textbooks on functional programming
Abelson, H. and Sussman, G.J with Sussman, J. (1985) Structure and
Interpretation of Computer Programs.
MIT Press, Cambridge,
Mass.
Darlington, J., Henderson, P. and Turner, D.A. (1982) Functional Pro-
gramming and its Applications: An Advanced Course. CUP.
Glaser, H., Hankin, C. and Till, D. (1984) Principles of Functional
Programming. Prentice Hall International, Hemel Hempstead.
Henderson, P. (1980) Functional Programming: Applications and Im-
plementation. Prentice Hall International, Hemel Hempstead.

1.3
Acknowledgements
We have spent a few years now on this project and over this time many
people have given us help and support.
We are indebted to Don Sannella at Edinburgh who was a collabo-
rator on this project. Don undertook some of the early programming
in a hectic few weeks one summer. Later he jointly undertook the work
described in Chapter 9. Throughout, Don has helped with his expertise
on functional programming. Here at Manchester, John Stell spent a few
months translating the code into Standard ML.
Amongst others who have helped, Joseph Goguen deserves special
mention. He collaborated with one of the authors (RMB) in developing a
categorical model theory of program speciﬁcation. It was this work that
prompted RMB to consider computational aspects of category theory,
see [Burstall 80]. Throughout, he has kept an encouraging interest in
the project and given useful guidance, including turning our attention to
some categorical algorithms involving colimits and operations on graphs
as well as encoding a fragment of category theory in a version of OBJ.
We are especially grateful for the Foreword provided by John W.
Gray. His enthusiasm for this project will be evident.
David MacQueen used this categorical programming to test ideas
about modularity in programming. Roy Dyckhoﬀkindly allowed us to
describe his implementation of category theory and gave detailed com-
ments on the account in this book. Both Horst Reichel and Ursula Martin
helped in the development of the uniﬁcation algorithm. Esther Dennis-
Jones helped with modular programs in ML and Victoria Stavridou with
OBJ. We are indebted to all those who, under the leadership of Robin
Milner, developed the programming language Standard ML.
Others who have contributed through discussions, advice and en-
couragement are Gordon Plotkin, David Benson, Andrzej Tarlecki, Peter
Aczel and Michael Barr.
The work described in this book was undertaken with ﬁnancial sup-
port from the Science and Engineering Research Council.

Chapter 2
Functional Programming in
ML
This chapter is an introduction to some aspects of functional
programming. It is also a guide to the programming language
ML. In the next few chapters we shall use ML to program
constructions from category theory. Those familiar with the
ML language can safely omit the chapter. An index of ML
keywords appears at the end of the book for reference when
reading ML programs.
Functional programming arose from two sources: the execution of pro-
grams on computing machinery, and logicians’ interest in languages and
functions. Early computer programs consisted of sequences of machine
instructions. It was found diﬃcult to reason about these programs so
as to establish their behaviour. Part of the problem was the linguistic
distance between the primitive instructions and the intended behaviour.
Moreover, the simple substitution properties normally associated with
variables were not applicable to these programs. The action associated
with an instruction depended not only on the context of the instruc-
tion in the program but also upon the state of the machine, which is
determined by the computational history of the program. Landin [1966]
pointed out that many of the features of programming languages could
be maintained whilst at the same time having the usual substitution
rules. McCarthy [1960] had previously developed such a programming
language called Lisp. Many other ‘functional’ programming languages
have been developed since then. These are based on deﬁning functions
and satisfy, in the main, the standard substitution rules.
9

The other historical strand is the development by logicians of lan-
guages for describing functions. This was an attempt to treat functions
as primitive, deﬁned by ‘rules’, rather than as graphs deﬁned in terms
of sets. Two directions were pursued. Combinatory logic [Curry, Feys
68] provides a variable-free description of functions. Backus [1978] has
proposed that variable-free languages, combinator languages, be devel-
oped for programming. At approximately the same time as combinatory
logic was being developed, Church [1941] proposed the λ-notation for
functions and associated calculi. λ-calculus has been inﬂuential in the
theory and design of modern programming languages.
Our interest is in languages for describing mathematical construc-
tions. Constructions transform input to output, taking structures of one
kind to structures of another. This dependence of output on input is
functional and makes a functional programming language a suitable ve-
hicle for programming constructions like those in category theory. We
describe here the functional programming language ML, which we have
used to program category theory. ML was developed by Milner [1978] as
a language for constructing mathematical proofs on a computer – hence
the name: it is a metalanguage (ML) for proof development. ML owes a
good deal to predecessors such as Lisp [McCarthy 60] and ISWIM [Landin
66] as well as to λ-calculus. It resembles other programming languages
like Miranda [Turner 86] and OBJ [Goguen, Tardo 79]. The novelty is its
type system, with polymorphic types and a type deﬁnition mechanism.
The language is based upon higher-order recursion equations for function
deﬁnition. It incorporates a type abstraction mechanism and support for
modular programming [MacQueen 85]. Various non-functional features,
like exceptions and references, have been found convenient and been in-
corporated into the language.
ML can be used interactively.
Types
and functions may be deﬁned and expressions evaluated in a fairly sim-
ple manner. Readers are encouraged to try programming in ML; they
should ﬁnd it a pleasant experience.
The version of ML that we describe, known as Standard ML, was
developed by a team at Edinburgh under the leadership of Robin Milner
[1984]. It incorporates features of previous versions of ML as well as from
the language Hope [Burstall, MacQueen, Sannella 80]. Full and readable
reports of the language are [Wikstr¨om 87] and [Harper, Mitchell 86].
The latter has proved useful in compiling this chapter. In the following
description we concentrate on those features of ML that we use in the
programming of category theory.

2.1
Expressions, values and environments
The evaluation of expressions, by which syntactic descriptions are trans-
formed into the values, is fundamental to programming.
An example expression for an integer in ML is (3+4)*5, where *
denotes multiplication. All phrases to be evaluated in ML are terminated
with a semicolon. Typing this expression followed by a semicolon will
give the response,
> 35 : int
which consists of the value 35 and its associated type int, that of integers.
An example expression in truth-values (booleans), rather than inte-
gers, is:
not(true andalso false)
It will give as result:
> true : bool
In programming, we want not only to describe values, but also to
name them for future reference. A collection of named values is called
an environment. The syntax which evaluates to an environment is called
a (value) binding.
A simple binding consists of an identiﬁer (or ‘variable’, we shall use
the terms interchangeably) m and its associated value described by an
expression. For example:
val m = (3+4)*5
The response to this, the environment denoted by this binding, is
obtained simply by evaluating the expression:
> val m = 35 : int
Here is another example binding, this time for truth-values:
val x = not(true andalso false)
It should be noted that bindings are not ‘assignment’ statements, like
x := 35 in Pascal. A binding gives a value to a variable just once at the
point where the variable is declared. The value of an expression in the
presence of bindings depends only on its textual context and not on some
notion of computational history. This is called referential transparency

and distinguishes functional languages from imperative languages which
have assignment and updating operations. Standard substitution rules
are valid in functional programming, making for easier reasoning about
and manipulation of programs.
Larger environments can be built by combining bindings. There is
a parallel combination of bindings in which each binding is evaluated
independently. To avoid clashes of deﬁnition the variables bound should
be distinct. An example of a parallel combination is:
val m = (3+4)*5 and n = 6*7
This results in the following environment:
> val n = 42 : int
val m = 35 : int
Bindings may also be combined sequentially in which case the expres-
sion in the second can use the variable bound in the ﬁrst, as illustrated
below.
val m = (3+4)*5; val n = 6*m
This evaluates to the following environment:
> val m = 35 : int
> val n = 210 : int
An expression containing variables can be evaluated by supplying
values to the variables, that is, it can be evaluated in the presence of a
suitable environment. This is described using a let-clause:
let val m = (3+4)*5 in m*m + (m+1)*(m+1) end
The result of this is simply the value of the expression with the variables
instantiated to their values given in the binding:
> 2521 : int
Notice that the binding of m to its value is not available after the expres-
sion is evaluated. This is described by saying that the variable and its
binding is local to the clause.
Conditional expressions are available in ML and are written in the
familiar form:
if x=1 then 0 else 2+x

2.2
Functions
Functional programming is about deﬁning, naming and invoking func-
tions. A function f is applied to a value v (its argument) by juxtapo-
sition f v. Parentheses may be inserted if wished to give the standard
notation f(v).
This is for preﬁx functions – those in which application is by preﬁxing
the function name to the argument. Other syntax for application is in
use. For instance, binary operations are often inﬁx, like the addition of
numbers 3+4. To introduce inﬁx operations we declare their inﬁx nature
together with a precedence – a number used to disambiguate expressions;
the higher the number the tighter it binds its arguments:
infix 4 +
Functions may be deﬁned using the standard mathematical format:
fun f(x) = 2*x
The result of typing this into ML is:
> val f = fn : int -> int
This tells us that we have deﬁned an environment in which the variable
f denotes a function which cannot be printed.
The type information
consists of two type expressions separated by an arrow; the ﬁrst type is
that of the argument to the function, the second is the type of the result
of evaluating the function.
For numerical values, we can separate the deﬁnition of a value from
its name.
To do this for functions we introduce expressions denoting
functions. Here is an example.
fn x => 2*x
This denotes the function which doubles an integer, so we may write,
(fn x => 2*x)(3)
to apply the function to the value 3 to yield the result 6. Notice how
the result is obtained. The variable x is bound to the argument 3 and
the expression 2*x is then evaluated. This notation is a variant of the
λ-expression λx.(2 × x). Notice that
fun f(x) = 2*x

is equivalent to
val f = fn x => 2*x
ML is statically scoped. Free variables in expressions are resolved in
the context of the deﬁnition of the expression rather than the context of
its evaluation.
2.2.1
Recursive deﬁnitions
Function deﬁnitions may be recursive, in which case the function being
deﬁned occurs in the expression on the right-hand side of the deﬁnition.
The factorial function, n! = 1×2×. . . ×n, can be deﬁned recursively as:
fun factorial(x) = if x = 0 then 1 else x*factorial(x-1)
An application of the factorial function factorial(n) is evaluated by a
successive ‘unfolding’ of the deﬁnition until the base case factorial(0)
is reached.
Here is a recursive deﬁnition of a function which tests whether an
integer is even or not:
fun even(x) = if x=0 then true else
if x > 0 then not(even(x-1))
else not(even(x+1))
Recursion is the key to deﬁning a wide range of functions in a func-
tional programming language like ML. As a repetitive construct it re-
places iteration in imperative languages (like the WHILE loop in Pascal).
The relationship between recursion and iteration, the uses and eﬃciency
of each, is a fairly involved topic for which the reader should consult a
reference (e.g. [Kruse 87]). Recursion introduces the possibility of non-
termination in programs. Termination proofs are needed to ensure the
well-formedness of deﬁnitions.
2.2.2
Higher order functions
Higher order functions are functions that take functions as arguments
or return them as results. These are available in ML. This is an impor-
tant aspect of programming as many mathematical structures, such as
automata, algebras, categories and adjunctions, are functional in nature
and therefore constructions on them are inherently higher order.
Let us consider some examples.

A simple and rather useless example of a function taking a function
as argument is the function eval at one which takes a function f acting
on integers and returns the value f(1):
fun eval_at_one(f) = f(1)
Thus eval at one(factorial) has value 1 (= 1!) and
eval_at_one(fn x => if x > 0 then true else false)
has value true.
Here is a more interesting example,
fun poly_eval(f) = f(f(3)) + f(3) + 3
which on argument factorial will result in the value 729 (= 6!+3!+3).
Functions may also be returned as results:
fun add_on(m) = fn n => m + n
Thus add on(3) is the function which adds 3 to a number. Deﬁnitions
like these go under the name of partial evaluation as some of the argu-
ments are supplied and some are left uninstantiated to form a function.
We may write this function deﬁnition equivalently using multiple argu-
ments:
fun add_on(m)(n) = m + n
As a ﬁnal example we give a function which has functional arguments
and functional results:
fun poly(f)(x) = f(f(x)) + f(x) + x
Thus poly eval(f) = poly(f)(3).
2.3
Types
Types are introduced into programming languages to organize the space
of values by dividing it into sections, each section being identiﬁed with
a type. The point of this is to gather together values of the same form
so that the validity of applying functions may be controlled.
Where
there is a range of diﬀerent values, deﬁnitions of functions presuppose
a certain form for the argument.
For example, integer addition is a
diﬀerent algorithm from real addition and, moreover, the algorithm only

applies to values which have the form of an integer so cannot be applied
to either real numbers or truth-values.
We write v:T to denote that value v is of type T. In ML all values have
an associated type (such languages are called strongly-typed). Moreover,
the fact that a value has a particular type is recognizable from the form
of the expression for the value. Resolving the type of expressions is called
type checking and languages like ML are designed so that type checking
is decidable. Whilst this restricts the expressiveness of the type system,
it allows for checking the type well-formedness of programs before they
are run, thus eliminating one source of errors in programming.
2.3.1
Primitive types
The primitive types in ML are integers, real numbers, truth-values (also
called booleans), strings (of characters) and the unit type.
The numerical types, integers and reals, have the usual arithmetic
operations deﬁned upon them as well as equality and the various in-
equalities. These operations are overloaded in the sense that the same
symbol is used for operations on integers and on reals. This means that
occasionally we have to disambiguate expressions by explicitly including
type information. For example:
fun add(x:int,y:int) = x+y
The type of truth-values is called bool and has values true and
false. The operations ‘not’ not, ‘and’ andalso, and ‘or’ orelse are
available.
Strings are ﬁnite sequences of characters and are written inside double
quotes e.g. "the quick brown fox". Strings may be concatenated end-
to-end (using inﬁx b). The operation size returns the length of a string.
Finally, the unit type unit consists of a single value, written (). It is
a formal device used, for example, to make constants into functions with
no arguments.
2.3.2
Compound types
We have already seen a type building operation – from types A and B we
may form the type A -> B of all functions from A to B.
The type of tuples consists of sequences of values of a ﬁxed length
enclosed in parentheses. If a:A, b:B, . . . d:D then the tuple (a,b,...,d)
is of type A*B*...*D, sometimes called the product type. For instance:

(2,true,"brown") : int * bool * string
To name the components in a tuple, record types are available. The
following is a record type for personal ﬁles:
{name: string, salary: int, gender: bool}
Values of this type are given as:
{name="fred", salary=10000, gender=true}
A further type formation operation, that of lists, is available and
discussed in Section 2.6.
2.3.3
Type abbreviation
Names may be given to type expressions:
type Fcn_and_Int = (int -> int) * int
This is not the creation of a new type. Equality of types is structural
equality and type names get expanded to their deﬁnitions.
2.4
Type polymorphism
In languages where values have associated types, it seems natural to asso-
ciate just one type with each value. Such languages are called monomor-
phic. This, however, is unnecessarily restrictive as there are constructions
which are uniform over a range of types. A single program can act on
values of various types. To gain this generality, a type system must allow
values to have more than one type. Languages with such type systems
are called polymorphic.
Type polymorphism arose in combinatory logic [Hindley 69] and λ-
calculus [Girard 72] and was introduced into programming by Strachey
[1967], Reynolds [1974] and by Milner [1978] in the language ML. Stra-
chey makes the distinction between polymorphism based upon a unifor-
mity of action, which he calls ‘parametric’ polymorphism and polymor-
phism based upon a common name for an operation, which he calls ad hoc
polymorphism. This ‘overloading’ of the name of an operation is common
and useful, for instance in arithmetic + stands for the addition of inte-
gers and of real numbers. The programs for these two operations may
be quite diﬀerent. Again, a print function takes values and transform

them into strings of characters for display. A diﬀerent transformation is
required for diﬀerent types of the argument.
Parametric polymorphism with its uniformity of action is a more
fundamental notion which we illustrate here with some examples.
Consider the simple function which projects a pair onto the ﬁrst ar-
gument, deﬁned as follows:
fun first(x,y) = x
It has many diﬀerent types. If x and y are integers, then it has type
int*int -> int, so that first(2,4) is well-typed. If x is an integer
and y is a truth-value, then the function has type int*bool -> int and
first(2,true) is well-typed.
By introducing type variables, we can give an expression which en-
compasses all the types of the function first. The most general type of
the function first is:
first : ’a * ’b -> ’a
Type variables are distinguished in ML (for parsing purposes) by an
initial quotation mark. Any type for the function is obtained by instan-
tiating the type variables.
The type system of ML is such that all well-formed expressions have a
unique most general type and this can be determined from the expression
using a uniﬁcation algorithm.
As another example of type polymorphism, consider the higher order
function:
fun twice(f) = fn x => f(f(x))
Thus twice(square)(3) is square(square(3)), and so is 81. The most
general type of this function is given by the expression:
twice : (’a -> ’a) -> (’a -> ’a)
Notice that, in the deﬁnition of twice, the argument type of f must be
the same as its result type, since f is applied to itself on the right-hand
side.
Structures which store values often admit operations which change
the structure independently of the type of the values stored. Simple ex-
amples of this polymorphism are provided by list processing functions.
Lists are linear sequences of items.
They are homogeneous, meaning
that all items within a list have have the same type. Thus [1,2,3] and

[true,false,true,true] are lists, of numbers and truth-values respec-
tively. [1,true,6] is not a list in this sense. Any list may be built from
the empty list by successively putting items on the front of the list. Let
nil denote the empty list and :: the operation which takes an item and
a list and creates a new list consisting of the old list with the item on
the front. Expressions built from nil and :: are in 1-1 correspondence
with lists, e.g. 1::(2::(3::nil)) is the list [1,2,3].
Consider the function append, which concatenates two lists end to
end:
append([1,3,2],[3,4]) = [1,3,2,3,4]
This clearly acts independently of the type of the items in the lists and
so is polymorphic. It can be applied to any two lists, whatever the type
of the items, as long as the two lists have the same type of items. What
then is the most general type of this function? First, we need the type of
homogeneous lists which we write as ’a list where ’a is a type variable.
Thus the type of lists of integers is int list and that of reals is real
list.
Later, we shall see to deﬁne this type, at the moment we are
concerned with types of list processing functions.
Using type variables to denote the polymorphic nature of functions
we may write the (most general) type of the append function as:
append: (’a list)*(’a list) -> (’a list)
By instantiating the type variable we see that append has many diﬀerent
types corresponding to the diﬀerent types of lists to which it may be
applied, for example,
append: (int list)*(int list) -> (int list)
as well as:
append: (bool list)*(bool list) -> (bool list)
Here are some further polymorphic functions on lists:
reverse : ’a list -> ’a list
nil : ’a list
Not all list processing functions are polymorphic. For instance, the
function that adds up a list of integers is of type:
sum : int list -> int

2.5
Patterns
Components of structures are obtained by pattern matching, matching
a pattern against a value.
For instance, suppose that v is the triple
(3,false,4):
val v = (3,false,4)
We may match this against a pattern (x,y,z) to create an environment
in which x, y and z are bound to the corresponding components of v:
val (x,y,z) = v
> val z = 4 : int
val y = false : bool
val x = 3 : int
If only some of the components are required, the underscore can be
used to prevent binding:
val (x,y,_) = v
The result of this will be the environment:
> val y = false : bool
val x = 3 : int
Variables must not be repeated in a pattern. The following is incor-
rect as it would not be clear what type x is, let alone its value:
val (x,x,z) = v
A pattern, then, is an expression built from variables, value construc-
tors (e.g. parentheses for constructing tuples) and the underscore, such
that each variable in the expression occurs only once.
The simplest case of a pattern is a variable:
val x = 3
Values other than tuples form patterns. Here are records:
val r = {name = ("joe","smith"), age = 40}
The surname may be obtained by the match:
val {name = (_,surname), age = _} = r
> val surname = "smith" : string

It is useful to be able to match simultaneously a pattern and a sub-
term of a pattern against a value. To do this we introduce layered pat-
terns. Consider the value:
val v = ((1,2),3)
We match this against a layered pattern (using the keyword as):
val (x as (_,y),_) = v
This yields the following environment:
> val y = 2 : int
val x = (1,2) : int * int
Pattern matching can be avoided when, as well as ‘constructor’ oper-
ations for forming values, there are ‘destructor’ operations for extracting
components of structures. If there is a ﬁxed set of type constructors then
we can introduce a set of destructor operations to accompany them. It is
in the presence of an extensible type system, when new types and their
values can be deﬁned, that pattern matching comes into its own.
2.6
Deﬁning types
ML allows the deﬁnition of new types and their associated values. The
values are described in terms of operations for forming values, called data
constructors. Values consists of expressions built out of data construc-
tors. Here is a simple example in which there are three data constructors,
each of which is a nullary (constant) operation:
datatype Colour = red | blue | green
This corresponds to an enumerated type having three values. The verti-
cal bar | separates the diﬀerent forms of the values. It may be read as
‘or’. The type consists of the disjoint (labelled) union of the forms of the
values indicated.
Functions are deﬁned over this type by pattern matching against the
diﬀerent cases:
fun warm(red)
= true
| warm(blue)
= false
| warm(green) = false

Here the patterns are simply the constant data constructors enumerated
in the type deﬁnition. In such case analysis, it is wise to ensure that
the cases deﬁned by patterns are both distinct and exhaustive so as to
admit only single-valued functions which are total. In fact, the cases are
accessed sequentially. We may make use of this to abbreviate deﬁnitions.
The deﬁnition above is equivalent to a case statement written in the
following form:
fun warm(x) = case x of
red => true | blue => false | green => false
Consider now a type deﬁnition with non-constant data constructors:
datatype Plant = flower of string*int*Colour |
foliage of string*int
Values of this type are of two forms. For ﬂowering plants we give their
name, height and colour of ﬂowers, e.g. flower("rose",3,red). For
foliage plants, we give their name and height, e.g. foliage("fern",2).
Again, functions are deﬁned by pattern matching:
fun height(flower(_,n,_) = n
| height(foliage(_,n) = n
Type deﬁnitions may be recursive to describe values which are ex-
pressions of an arbitrary size.
Peano’s recursive deﬁnition of natural
numbers becomes:
datatype Num = zero | succ of Num
This deﬁnes natural numbers using succ as the successor function adding
1 to a number. Thus zero stands for 0 and succ(succ(zero)) for 2.
Functions are again deﬁned by case analysis but, in general, deﬁni-
tions will be recursive corresponding to the recursive structure of the
values:
fun even(zero) = true
| even(succ(n)) = not(even(n))
Addition of natural numbers may be deﬁned as follows:
fun add(zero,n) = n
| add(succ(m),n) = succ(add(m,n))

Types such as lists and trees, which act as storage structures for
values of arbitrary type, are deﬁned by type parameterization. Consider
the simple example of a pair of values of the same type:
datatype ’a Pair = pair of (’a * ’a)
Here ’a is a type variable and Pair is a type constructor. By instantiating
the type variable various types can be obtained:
pair(3,4) : int Pair
pair(true,false) : bool Pair
Functions over parameterized types may be polymorphic:
fun first(pair(x,y)) = x
This function has type,
first : ’a Pair -> ’a
for any type ’a.
A recursive, parametric type is list,
datatype ’a list = nil | ’a :: (’a list)
deﬁning linear lists of items of any type (all items in the list must have
the same type, i.e. the lists are homogeneous). Thus lists are either empty
nil or consist of an item v on the front of a list s, v::s. Thus the list
[2,3,4] corresponds to 2::(3::(4::nil). Lists are built into ML with
the square-bracket notation. We saw some list processing functions in
Section 2.4. Here are some more examples:
fun length nil = 0
| length (h :: t) = 1 + length t
fun member(e,nil) = false
| member(e,(h::t)) = if e=h then true else member(e,t)
Equality of values is handled as a special function in ML. The prim-
itive types all have a pre-deﬁned equality function on them. Compound
types and user-deﬁned types have an equality where this may be deter-
mined structurally. Roughly, this means that equality is pre-determined
on all non-functional types. Types involving functions do not in general
admit an extensional equality. Any intended equality on functional types

and any equality diﬀerent from structural equality can be supplied by the
user.
The ML type system is one among many that have been proposed
for programming languages and for proof systems. Polymorphism makes
it more expressive than, say, Pascal and yet type checking is decidable.
The ML type system does not include dependent types (as in the pro-
gramming language Pebble [Burstall, Lampson 84]), type quantiﬁcation
(see [Cardelli, Wegner 85]), subtypes (as in OBJ [Goguen, Tardo 79]) or
type universes (as in [Martin-L¨of 82]).
2.7
Abstract types
Programming languages provide a range of types and type formation
operations. Part of the process of programming is the choice of types in
the language to represent given structures. There will not, in general, be
a unique way to represent a given structure. Moreover, rarely will it be
possible to choose an exact representation. Usually the representation
contains more structure than is necessary.
What is required of a representation is that certain operations may
be deﬁned and have a given behaviour. It is desirable to separate the
representation from the use of the type.
The operations mediate be-
tween the representation and its use. They provide an ‘interface’ to the
representation. With this separation, we may change the representation
and redeﬁne the operations, without needing to change programs using
the type. To make this eﬀective, the representation should be inacces-
sible outside its deﬁnition.
The operations on a type determine how
much of the representation is available and so, where there is superﬂuous
structure in a representation, this may be hidden. This separation of
representation from use is called ‘data abstraction’ and is a fundamental
idea in the organization of programs.
Let us have a look at an example of an abstract data type:
abstype Mixture = mix of int*int*int
with val cement = mix(6,0,0)
and sand
= mix(0,6,0)
and gravel = mix(0,0,6)
and mortar = mix(1,5,0)
and infill = mix(1,2,3)
fun compound(parts:int, mix(c,s,g),
parts’:int,mix(c’,s’,g’)) =

let val p = parts + parts’
val cp = (parts*c+parts’*c’) div p
and sp = (parts*s+parts’*s’) div p
and gp = (parts*g+parts’*g’) div p
in mix(cp,sp,gp) end
end
Here we deﬁne a type, representing it in terms of a triple of integers, and
operations on the type. The representation is not available outside the
deﬁnition, in particular the data constructor mix will not be deﬁned out-
side the type deﬁnition. The only way to manipulate mixtures is through
the operations provided, which act as an interface to the representation.
Finite sets provide another example of data abstraction. Some pro-
gramming languages incorporate ﬁnite sets as an in-built type. In ML,
we represent this type in terms of other types. We show how sets are
represented by lists of their elements, using data abstraction to hide the
order in which the elements are stored and the multiplicity of elements
in a list.
abstype ’a Set = set of ’a list
with val emptyset = set([])
fun is_empty(set(s)) = length(s)=0
fun singleton(x) = set([x])
fun union(set(s),set(t)) = set(append(s,t))
fun member(x,set(l)) = list_member(x,l)
fun remove(x,set(l)) = set(list_remove(x,l))
fun singleton_split(set(nil)) = raise empty_set
| singleton_split(set(x::s)) =
(x,remove(x,set(s)))
fun split(s) =
let val (x,s’) = singleton_split(s) in
(singleton(x),s’) end
end
For abstract types, pattern matching is no longer appropriate, so we
introduce functions to take values apart, called ‘destructor functions’.
An example in the type above is the function singleton split. New
functions on sets may be deﬁned using these destructor functions:
fun cardinality(s) = if is_empty(s) then 0 else
let val (x,s’) = singleton_split(s) in
1 + cardinality(s’) end

We can avoid destructor functions and this explicit recursion if we can
ﬁnd a collection of operations on sets from which all required operations
may be constructed through composition and application. Category the-
ory provides some guidance on this matter (see chapter 7). We will often
display ﬁnite sets using the standard set-parentheses {. . .}.
In the deﬁnition of the abstract type of ﬁnite sets, the clause for
the extraction of an element from the empty set raises an exception.
Exceptions are the topic of the next section.
2.8
Exceptions
Often when programming we meet expressions which are not intended to
have any value, for instance when a function is applied to an argument
outside its domain of deﬁnition. To ensure that programs are ‘robust’ in
being able to cope with erroneous input, we need a so-called exception
mechanism. There is a type-safe exception mechanism in ML which we
illustrate with an example:
exception empty_list: unit
fun head(nil)
= raise empty_list
| head(a::s) = a
The name of the exception empty list and its type unit is declared.
The type of an exception is that of the value returned (in this case no
value is returned).
The function evaluates as follows.
When the list
is not empty, this function returns the ﬁrst item of the list. When it
is empty, evaluation ceases and an exception with name empty list is
raised. When an exception is raised, evaluation may be passed to an-
other expression called the handler as in the following, rather contrived,
function for concatenating lists end to end.
fun append(s,t) =
head(s)::append(tail(s),t) handle empty_list => t
Here, the ﬁrst part of the deﬁnition clause is evaluated. If no exception
is raised, its value is returned.
If an exception called empty list is
raised, the value of the clause in the handler is returned. To handle all
exceptions raised in a clause we use a ‘wildcard’ instead of an exception
name: ...
handle ?
=> ....
Values may be passed through exceptions as in the following example:

exception div_by_zero:int
fun divide(n,d) = if d=0
then raise div_by_zero with n else div(n,d)
An expression calling this function can make use of the value of the
numerator when the function fails:
f(a,b) handle div_by_zero with x => x*x
There are certain scope rules associated with exceptions which are
explained in [Harper, Mitchell 86].
2.9
Other facilities
ML provides a facility for modular programming, based on a proposal of
MacQueen [1985]. It incorporates parameterized modules and submodule
sharing. We do not describe modules here as they do not appear in the
forthcoming programming (for reasons discussed in Chapter 10).
Other features of ML are a type-safe reference and assignment facility
and a collection of input/output primitives based on streams.
2.10
Exercises
The exercises in this chapter are designed to be done interactively on an
ML system. They may, however, be done as pen-and-paper exercises.
They follow roughly the order of presentation in the chapter, with some
more substantial exercises at the end. Answers to the exercises are given
in Appendix D.
Exercise 1. Values and environments What
values
or
environ-
ments are given by the following ML expressions?
1. val x = 3; val y = 4 and z = x+1
2. let val x =1 and y =2 in x+y end
3. val p = 3 and q = p+1
4. let val (x,y) = (2,3) in 2*x + y end
5. let val x = 1 in let val y = x+2 in let val x = 5
in x+y end end end
6. val (x,y as ( ,p)) = ((2,3),(4,(5,6)))

Exercise 2. Deﬁning functions Deﬁne the following functions on
integers:
1. The function sign which tests whether an integer is positive.
2. The function absvalue which returns the absolute value of an
integer.
3. The function ﬁnding the maximum of two integers.
4. The Fibonacci sequence is 1, 1, 2, 3, 5, 8, 13, . . . in which each
number is the sum of its two immediate predecessors. Write
a recursive deﬁnition of the n-th entry in the sequence.
Exercise 3. Natural numbers Deﬁne the type of natural numbers as
follows:
datatype Num = zero | succ of Num
Deﬁne a function numprint :
Num -> int which displays natural
numbers as integers.
In the text of the chapter we show how to deﬁne addition of
natural numbers. Use this addition operation and the same cases
as in its deﬁnition to deﬁne the multiplication of natural numbers.
Exercise 4. Higher order and polymorphic functions What are
the most general types of the following functions?
1. The function apply which takes a function and a value and
returns the results of applying the function to the value:
fun apply(f)(x) = f(x)
2. The function which composes two functions:
fun compose(g,f) = fn x => g(f(x))
Exercise 5. List processing Deﬁne the following functions on lists.
1. The function which ﬁnds the maximum integer in a list of
integers.
2. The function which sums a list of integers.
3. The function which takes a list of coeﬃcients a0, a1, . . . , an and
a value x and evaluates the polynomial a0+a1×x+. . . an×xn.

4. Use the append function, concatenating lists end to end, to
deﬁne the function which reverses a list.
5. The function maplist which applies a function to all items in
a list returning the list of results. What is its most general
type?
6. The function calculating the sum of a list of integers can be
generalized. Suppose there is a binary function f:
A*B ->
B and an initial value v:B, then we may run through an A
list accumulating a result by successively applying the bi-
nary function to the current element of the list and the value
accumulated so far, starting with the initial value. Deﬁne this
function – the deﬁnition is shorter than its explanation!
Exercise 6. Binary trees For this exercise, a binary tree is a structure
like:
1
2
3
•
•



A
A
AA



A
A
A
A
A
A
A
A
It consists of binary branching nodes and values stored at the tips.
The top node is called the root.
As a type within ML, we deﬁne binary trees as follows:
datatype ’a BinTree =
tip of ’a | node of (’a BinTree)*(’a BinTree)
The tree above is then represented as the expression:
node(node(tip(1),tip(2)),tip(3))
Deﬁne the following functions on binary trees:
1. The breadth of a tree, deﬁned as the number of tips.
2. The depth of the tree, deﬁned as the maximum length of a
path from the root to a tip.

3. The function which collects, in order, the list of values at the
tips.
Exercise 7. Data abstraction Rational numbers may be represented
as integer fractions or as an integer part together with a fractional
part which consists of a ﬁnite sequence of digits followed by another
ﬁnite sequence which is inﬁnitely repeated. Deﬁne the arithmetic
of rational numbers as an abstract type using either representation.
Exercise∗8. More list processing We have already seen many fun-
ctions on lists. However, this is but a small sample of a rich vein
of functions which illustrate the utility of recursion as a concise
and executable deﬁnition mechanism. Here are a few more sugges-
tions for list processing functions. Clearly there are many similar
functions which you may wish to encode.
1. The function which deletes all occurrences of a value from a
list is deﬁned as follows:
fun delete(x,nil) = nil
| delete(x,a::s) =
if x=a then delete(x,s)
else a::delete(x,s)
Deﬁne the function which deletes the n-th occurrence of a
value.
2. Deﬁne the function sublist which tests whether a list is a
sublist of another, in the sense that the second list is the
ﬁrst ﬁlled out at any positions with other entries. There are
variants of this notion of sublist which you may like to encode.
3. Deﬁne the function which counts how may times a list is a sub-
list of another, including overlapping. Here are some sample
results.
number_of_sublists([1,2],[1,2,2])
> 2 : int
number_of_sublists([1,2],[1,1,2,2])
> 4 : int
number_of_sublists([1,1],[1,1,1])
> 3 : int
number_of_sublists([1,1],[1])
> 0 : int

This is rather tricky so we give the ﬁrst clauses in the deﬁni-
tion:
fun number_of_sublists(nil,t) = 1
| number_of_sublists(a::s,nil) = 0
| number_of_sublists(a::s,b::t) = ...
Exercise∗9. Operations on ﬁnite sets In this exercise we use the
abstract type of ﬁnite sets deﬁned in Section 2.7 and deﬁne several
operations on sets.
These operations will arise in the following
chapters, when we consider internal structure within the category
of ﬁnite sets.
Let us begin with a deﬁnition of a function which takes the
image of a ﬁnite set through a function:
fun image(f)(s) = if is_empty(s) then emptyset else
let val (x,s’) = singleton_split(s) in
union(singleton(f(x)),image(f)(s’)) end
Now deﬁne the following operations:
1. The disjoint union of ﬁnite sets.
2. The cartesian product of two ﬁnite sets.
3. The powerset of a ﬁnite set – the set of all subsets of the set.
4. The set of all total functions between two ﬁnite sets. For this,
represent a function between two ﬁnite sets as its graph (list
of argument-result pairs).
Notice how the deﬁnitions of the last three functions depend upon
one another. This dependence can be expressed abstractly within
category theory.
To print sample results, you will need a function converting sets
to strings of characters for display. Moreover, to deﬁne powersets
you need equality on ﬁnite sets.
Exercise∗10. Sorting This is an exercise in programming an algo-
rithm for sorting a list of items, which support a total order, into
a non-descending sequence. The algorithm is called ‘tree sort’ and
works by inserting items successively into an ‘ordered’ tree and then
ﬂattening the resultant tree. Those unfamiliar with the algorithm
should consult a reference such as [Knuth 73].

The algorithm uses binary trees of the following form (where we
consider, for simplicity, only sorting lists of integers):
datatype BTree = empty | tip of int |
node of BTree*int*BTree
We build ordered trees. A tree node(s,n,t) is ordered if the nodes
in s are all less than n and those in t are greater than or equal to
n and s and t are ordered.
Write a function insert for inserting a value in an ordered tree
by creating a new node and still maintaining the ordered property.
Also write a function flatten to collect the list of values at the
nodes following an in-order traversal.
Using the function accumulate deﬁned in Exercise 5.6 above,
the sorting algorithm can be expressed as:
fun sort(s) = flatten(accumulate(insert)(empty)(s))
Exercise∗11. Universal algebra and recursion Burstall and Lan-
din [1969] show how ideas from universal algebra can contribute to
the design of computer programs. This is a short exercise based
on these ideas and should only be attempted if you know some
universal algebra.
Notice that the deﬁnition of list processing functions like length,
member (Section 2.6), sum and maplist (Exercise 5) all have the
same general form. This may be explained by the fact that lists
form a free monoid. The monoid structure is that of concatenat-
ing lists with the empty list as the identity. There is a function
h : A →list(A) which returns the singleton list on an element.
The freeness is expressed by the unique existence of a homomor-
phism as follows:
For any monoid (B, ∗, e) and function f : A →B, there is a
unique homomorphism f # from the monoid of lists to (B, ∗, e) such
that the following commutes:
A
list(A)
B
h
f
f #
-
?
@
@
@
@
R

Given the monoid (B, ∗, e), the map f 7→f # can be constructed
and the construction can be expressed as a program in ML. Rep-
resenting the target monoid as a pair of a binary function and a
constant, write this program. It is an example of an encapsula-
tion of recursion, in that functions (like those mentioned above)
normally deﬁned through explicit recursion, can be obtained by
passing suitable parameters to this program.
Consult the reference above for more details of this and for the
extension from lists to arbitrary free algebras.


Chapter 3
Categories and Functors
Beginning in this chapter and running through to Chapter 7,
we develop some of the basic ideas in category theory. Ex-
amples are chosen for relevance to computing.
Theorems
are established through constructive proofs.
The presenta-
tion of the mathematics is accompanied by corresponding ML
programs.
The starting point in the development of category theory is the deﬁ-
nition of a category together with illustrative examples. We present this
material much as it is to be found in standard texts, concentrating how-
ever on examples of relevance to programming. Alongside this, we begin
the programming of category theory by representing categories so as to
compute with them.
3.1
Categories
Category theory is founded upon the abstraction of the arrow,
f : a →b
Here a and b are called objects and f is an arrow whose source is object
a and target is object b. Such directional structures occur widely in set
theory, algebra, topology and logic. For example, a and b may be sets
and f a total function from a to b or, indeed, f may be a partial function
from set a to set b; or a and b may be algebras of the same type and f
a homomorphism between them; or a and b may be topological spaces
and f a continuous map; or, again, a and b may be propositions and f a
proof of a ⊢b.
35

It is by describing structure in terms of the existence and proper-
ties of arrows that category theory achieves its wide applicability. The
usual mode of description in mathematics is by reference to the internal
structure of objects. The applicability of the description is then limited
to objects supporting such structure. Categorical descriptions make no
assumption about the internal structure of objects; they are purely in
terms of the ‘transport’ of whatever structure is preserved by the ar-
rows. In this sense, they are data independent descriptions – the same
description may apply to sets, graphs, algebras and whatever else can be
considered to be objects in a category.
Particularly amenable to description in terms of arrows are construc-
tions which are in some sense ‘canonical’. These are common throughout
mathematics. We mention a few here to illustrate the sorts of construc-
tions we have in mind. Canonical constructions in graph theory are the
transitive closure of a graph and the strong components of a graph. In
algebra, free and generated algebras are common. A canonical construc-
tion is the abelianization of a group. In topology, there are constructions
like the compactiﬁcation of spaces.
An arrow-theoretic description of
such constructions captures all the ingredients, including the sense in
which the construction is considered to be canonical.
The generality of descriptions in term of arrows is oﬀset by a re-
moteness from application so that considerable work is involved in un-
ravelling categorical descriptions in a particular setting and, conversely,
in attempting to give a categorical description of a particular concept.
On the other hand, these descriptions are usually elementary (i.e. ﬁrst-
order) though they tend to be fairly complex in terms of the alternation
of quantiﬁers.
To support deﬁnitions in terms of arrows, Eilenberg and Mac Lane
[1945] introduced structures called categories. A category is a class whose
elements are ‘objects’ together with a class of ‘arrows’ (sometimes called
‘morphisms’) between objects. Arrows are to be composable: if f : a →b
and g : b →c, there is a composite arrow gf : a →c (sometimes denoted
g.f). Notice the order in which we write the composition. Some authors
write fg rather than gf to denote the composite of f : a →b followed
by g : b →c. The order fg corresponds to the diagram,
a
f
−→b
g
−→c
but then, to be consistent, application of a function f to an argument
x becomes post application xf (like ﬁeld selectors in some programming
languages). The order gf corresponds to the usual preﬁx notation for

the application of functions (gf)(x) = g(f(x)).
The latter is gaining
ascendancy in categorical texts and so is adopted here.
Composition is to have two properties:
1. Associativity. For all f : a →b, g : b →c and h : c →d,
(hg)f = h(gf)
2. Identity.
For all objects a in the category there is an ‘identity’
arrow ia such that for all f : a →b,
fia = f = ibf
Categories are thus graphs (directed multigraphs) with a composition
and identity structure. Based upon this, we may give a formal deﬁnition
of a category.
Deﬁnition 1 A graph is a pair N, E of classes (of nodes and edges)
together with a pair of mappings s, t : E →N called source and target
respectively.
We write f : a →b when f is in E and s(f) = a and
t(f) = b.
Deﬁnition 2 A category is a graph (O, A, s, t) whose nodes O we call
objects and whose edges A we call arrows. Associated with each object
a in O, there is an arrow ia : a →a, the identity arrow on a, and to
each pair of arrows f : a →b and g : b →c, there is an associated arrow
gf : a →b, the composition of f with g. The following equations must
hold for all objects a, b and c and arrows f : a →b, g : b →c and
h : c →d:
(hg)f = h(gf)
fia = f = ibf
Such then are categories. The structure is fairly weak, consisting of
only typed composition with identities.
It is customary to say something about the ‘size’ of the collections
O and A which we have called classes. Many categories have collections
O and A which are too ‘big’ to be sets, for instance, the category whose
objects are all sets (in some universe) or whose objects are all groups
(again in some universe). Considering these collections to be sets yields
inconsistency (Russell’s paradox). We thus need some justiﬁcation for

dealing with these large categories in terms of a foundational framework
for category theory.
Originally, various extensions of set theory were
proposed to deal with this matter.
Universes of sets were considered
by Mac Lane [1971], Grothendieck [1963] and Feferman [1969] and the
G¨odel-Bernays theory of classes has also been employed as a foundation.
Set-theoretic foundations are discussed in Blass [1984]. When working
in category theory, such set-based foundations seem both superﬂuous
(except to avoid contradictions) and inappropriate.
There have been
proposals that category theory itself should provide a foundation not only
for category theory but also for the whole of mathematics. Lawvere [1966]
considers the category of categories as a foundation, whilst B´enabou
[1985] analyses category theory in use and proposes ﬁbered categories as
a foundation (to handle ‘set’-indexed diagrams).
Programming category theory, as we are about to do, involves em-
bedding it in a suitable formal language. In doing so we confront this
foundational question. From a programming point of view, we are inter-
ested only in objects and arrows that we may construct. This leads, as
we shall see (Section 3.3), to a framework based on formal type systems.
Various systems have been proposed and some have been incorporated
in programming languages. We discuss this topic in Chapter 10.
3.1.1
Diagram chasing
Categorical properties are often expressed in terms of ‘commuting’ di-
agrams and proofs take the form of ‘diagram chasing’.
Informally, a
diagram is a picture of some objects and arrows in a category. Formally,
a diagram is a graph whose nodes are labelled with objects of the cate-
gory and whose edges are labelled with arrows in the category in such a
way that source and target nodes of an edge are labelled with source and
target objects of the labelling arrow. An example of a ﬁnite diagram ∆
is:
a
b
c
f
p
g
-
?
@
@
@
@
R
a
h
q

    	
A path in a diagram is a non-empty sequence of edges and their
labelling arrows such that the target node of each edge is the source
node of the next edge in the sequence. For example, the left triangle in

the diagram ∆contains the path, a
f
−→b
g
−→c. Each path determines an
arrow by composing the arrows along it. A diagram is said to commute if,
for every pair of nodes m, n, every path from m to n determines through
composition the same arrow.
Thus to say the diagram ∆commutes
amounts to the following two equations:
p = gf
and
q = gh
Proofs using commutation of diagrams are equational proofs. The equa-
tions are typed by their source and target nodes. This simple form for
categorical proofs means that these proofs are especially amenable to be
conducted on computers. Not only is the technology for equation deduc-
tion fairly well understood but also the typed nature of categorical proofs
constrains the search arising in deduction. Huet [1986] has considered
this matter and Watjen and Struckmann [1982] have automated part of
categorical reasoning.
3.1.2
Subcategories, isomorphisms, monics and epis
A category C whose objects and arrows are subclasses of those of a
category A, and whose source, target, identities and compositions are
those of A is said to be a subcategory of A. A subcategory C of A is
said to be full when, for all pairs of objects a and b in C, if f : a →b
is an arrow in A then it is in C. A full subcategory of a category A is
determined by the objects alone.
We now consider some important properties of arrows.
An arrow
f : a →b in a category is said to be an isomorphism if there is an arrow
g : b →a which is a left and right inverse to f i.e. gf = ia and fg = ib.
In this case we say that a and b are isomorphic objects, written a ∼= b.
In the category whose objects are sets and whose arrows are functions,
isomorphisms are bijections (1-1 and onto functions). Isomorphisms are
important in category theory since arrow-theoretic descriptions usually
determine an object only to within an isomorphism. Thus isomorphisms
are the degree of ‘sameness’ that we wish to consider in categories.
An arrow m : b →c is a monic iﬀfor every pair of arrows f, g : a →b,
if mf = mg then f = g. By turning the arrows around, we deﬁne the
concept of an epi: an arrow e : a →b is a epi iﬀfor every pair of
arrows f, g : b →c, if fe = ge then f = g. In the category of sets with
functions as arrows, monics are 1-1 functions and epis are onto functions.
In fact, monics are but one of several diﬀerent categorical notions which
characterize 1-1 functions, likewise epis and onto functions.

3.2
Examples
Examples of categories abound throughout mathematics. We consider
some that are of importance in programming.
3.2.1
Sets and ﬁnite sets
The primary example of a category is that of sets, Set, whose objects are
sets (in a universe) and whose arrows are total functions. More precisely,
since arrows determine their source and target objects, arrows in Set are
typed total functions, which we may consider to be triples (a, f, b), a and
b being sets and f a function deﬁned on all elements of a and whose
results lie in b. Identities are simply identity functions: ia = (a, λx.x, a)
and composition is the composition of functions, for f : a →b and
g : b →c,
gf = (a, λx.g(f(x)), c)
A subcategory of Set is that of ﬁnite sets, FinSet, whose arrows are
again typed total functions.
There are other categories whose objects are sets. For instance, we
may consider arrows to be not total functions but partial functions to get
a category SetP f. We may go further and consider objects again to be
sets but arrows to be relations between sets (labelled with their source
and target sets). A relation r : a →b is a subset of the cartesian product
a × b. The composition sr of r : a →b with s : b →c is deﬁned by
sr = {(x, z) : ∃y ∈b . (x, y) ∈r ∧(y, z) ∈s}
Let us call this category SetRel.
3.2.2
Graphs
We consider directed multi-graphs, that is, pairs of sets N (of nodes) and
E (of edges) together with pairs of functions s, t : E →N (source and
target respectively). Notice that the collections of nodes and of edges are
both sets rather than proper classes (so-called small graphs).
Graphs are objects in a category Graph. Arrows in this category are
structure-preserving maps between graphs. This means that an arrow
from graph (N, E, s, t) to graph (N ′, E′, s′, t′) is a pair of functions (f :
N →N ′, g : E →E′) such that, for all e ∈E, f(s(e)) = s′(g(e))
and f(t(e)) = t′(g(e)). We may picture these two requirements as the
commutation of the following squares:

E
N
E′
N ′
s
f
g
s′
?
-
?
-
E
N
E′
N ′
t
f
g
t′
?
-
?
-
3.2.3
Finite categories
Categories in which the classes of objects and of arrows are both ﬁnite
sets may be represented pictorially. For example,
b
c
a
f
g
h
k
     @
@
@
@
R
@
@
@
@
R
-
Here a, b and c denote objects, f, g and h are arrows with sources and
targets as depicted. We deﬁne composition explicitly for each composable
pair of arrows: gf = k and hf = k and the existence of an identity arrow
for each object is assumed.
3.2.4
Relations and partial orders
We have already deﬁned the category SetRel whose objects are sets and
whose arrows are relations. However, we can also deﬁne a category whose
objects are relations. To do so we must say what we mean by an arrow
between relations.
First some notation: if R ⊆a × b is a relation we will write xRy for
(x, y) ∈R. Now consider relations from a set to itself. These are pairs
(a, R ⊆a × a). An arrow from (a, R) to (b, S) is a function f : a →b
such that xRy ⇒f(x)Sf(y). Composition and identities in this category,
Rel, are those of functions.
A subcategory of Rel is the category of partial orders. A relation
(a, ≤) is a partial order if it satisﬁes the following:

1. (Reﬂexivity) x ≤x.
2. (Anti-symmetry) If x ≤y and y ≤x, then x = y.
3. (Transitivity) If x ≤y and y ≤z, then x ≤z.
Arrows between partial orders are arrows of relations, i.e. order preserv-
ing functions. This forms a category Pos.
3.2.5
Partial orders as categories
As well as the category Pos of partial orders, each partial order (a, ≤)
may itself be considered to be a category as follows. The objects of the
category are the elements of a. There is precisely one arrow from x ∈a
to y ∈a iﬀx ≤y.
Transitivity ensures that composition is deﬁned
and reﬂexivity ensures that identities exist. In fact, we do not need the
anti-symmetry axiom, so this construction works for pre-orders (reﬂexive,
transitive relations).
3.2.6
Deductive systems
The idea here is that propositions are objects in a category and that an
arrow f : a →b corresponds to (an equivalence class of) a proof of a ⊢b.
Let us illustrate with a simple example: The calculus of conjunction
(logical ‘and’ denoted ∧). The objects are propositional expressions built
from variables (drawn from a set X say) and a binary inﬁx operator
denoted ∧.
The arrows are equivalence classes of proofs generated by inference
rules.
We write the inference rules using (proofs of) sequents rather
than propositions, so that inference rules provide means of constructing
arrows.
Corresponding to the deduction a ∧b ⊢a, we have the rule
πa,b : a ∧b →a
and likewise the rule
π′
a,b : a ∧b →b
These are elimination rules for conjunction. The introduction rule, con-
structing arrows from arrows, is
f : c →a, g : c →b
⟨f, g⟩: c →a ∧b

To make this structure into a category, we assume the existence of
identity entailments a ⊢a:
ia : a →a
and an associative composition of proofs,
f : a →b, g : b →c
gf : a →c
for which the identity arrows are indeed identities. Finally, we impose
the following equations on proofs:
πa,b⟨f, g⟩= f
π′
a,b⟨f, g⟩= g
⟨πa,bh, π′
a,bh⟩= h
As an example proof, we demonstrate the commutativity of ∧, i.e.
a ∧b ⊢b ∧a. The following arrow is a proof of this entailment:
⟨π′
a,b, πa,b⟩: a ∧b →b ∧a
This is but an indication of how deductive systems give rise to cate-
gories. Further structure in the logic is reﬂected in corresponding cate-
gorical structure. There is now a well developed ﬁeld of categorical logic,
including topos theory (Chapter 7) and structures combining the idea
of proofs as arrows with that, introduced in the next section, of term
substitutions as arrows.
For more details, the reader should consult
references such as [Goldblatt 79], [Lambek, Scott 86], [Lawvere 70],
[Seely 83].
3.2.7
Universal algebra: terms, algebras and equations
We describe some basic universal algebra and several categories which
occur. For more details of universal algebra the reader should consult
standard texts, for example [Cohn 65,81]. Some computational aspects
of universal algebra are dealt with in [Huet 80] and [Huet, Oppen 80].
Indeed the concepts developed here are fundamental to the semantics of
computation [Goguen, Meseguer 88].
The starting point is the notion of a ‘term’ which is a symbolic ex-
pression built from operators (function symbols) and variables. Thus if
X = {x, y, z} is a set of variables (simply symbols) and f is a unary

operator and g a binary operator, then the expressions f(f(z)) and
g(f(x), g(x, y)) are terms in X.
An operator domain is a set of operator symbols indexed by their
arities (natural numbers). If Ωis an operator domain, denote by Ωn the
set of operators in Ωwhose arity is the natural number n.
The terms in a set X over an operator domain Ω, the set of which we
denote by TΩ(X), are syntactic objects deﬁned recursively by:
x ∈X ⇒⟨x⟩∈TΩ(X)
ρ ∈Ωn, t1, t2, . . . , tn ∈TΩ(X) ⇒ρ(t1, t2, . . . , tn) ∈TΩ(X)
Strictly speaking, a constant c, i.e an operator with arity 0, when
considered as a term should be written c() but we will often elide this
distinction. Also variables should be enclosed as ⟨x⟩but the parentheses
are dropped where no ambiguity arises.
A (term) substitution from set X to set Y , f : X →Y is a function,
f : X →TΩ(Y ), mapping variables to terms. Thus if X = {x, y, z} and
Y = {u, v, w} and f is a unary operator and g a binary operator, then
an example term substitution from X to Y is:
{x 7→g(u, v), y 7→g(f(u), g(u, v)), z 7→f(f(w))}
We now deﬁne a category whose objects are sets and whose arrows are
term substitutions. To do so we deﬁne composition of term substitutions
and identity substitutions.
Notice that substitutions can be applied to terms. If f : X →Y is a
substitution, deﬁne the application of f to a term in X by:
f(⟨x⟩) = f(x) for all x ∈X
f(ρ(t1, t2, . . . , tn)) = ρ(f(t1), f(t2), . . . , f(tn))
for ρ ∈Ωn, t1, t2, . . . , tn ∈TΩ(X)
We deﬁne composition using application (gf)(x) = g(f(x)). Also, for
each set X the identity substitution is deﬁned by iX(x) = ⟨x⟩(unless X
is empty in which case the identity is the empty function).
Deﬁne TΩto be the category whose objects are sets and whose arrows
are substitutions. This is indeed a category under the composition and
identities above. The full subcategory of ﬁnite sets is denoted TΩF in.

This category provides a basis for a categorical treatment of equa-
tional deduction. In Chapter 8, we show how a particular case of equation-
solving, the so-called uniﬁcation problem, can be interpreted in this cat-
egory and we derive uniﬁcation algorithms from general categorical con-
structions. For further details of this categorical treatment of equational
deduction, see [Rydeheard, Stell 87].
We now consider algebras. An algebra is a set together with a fam-
ily of functions on the set.
By introducing arrows (homomorphisms)
between algebras of the same kind, we may deﬁne categories of algebras.
An Ω-algebra (A, α) consists of a set A called the carrier, together
with, for each n ∈N and operator ρ ∈Ωn, a function αρ : An →A. A
homomorphism h from (A, α) to (A′, α′) is a function h : A →A′ such
that for each n ∈N and ρ ∈Ωn, and x1, x2, . . . , xn ∈A,
h(αρ(x1, x2, . . . , xn)) = α′
ρ(h(x1), h(x2), . . . , h(xn))
Composition and identities are the composition and identities of func-
tions. Thus, for each operator domain Ω, we form the category of Ω-
algebras, AlgΩ.
As an example, we may take Ωto contain just a nullary operator
(one taking no arguments, i.e. a constant), c, and a unary (1-argument)
operator, f. An Ω-algebra consists of a set A, a distinguished element
of A as the constant and a unary function on A. The natural numbers
N = {0, 1, . . .} form an Ω-algebra with c as 0 and f as the successor
function, λx . x + 1. Another Ω-algebra is the set of truth-values T =
{⊤, ⊥} with c as ⊤and f deﬁned to be negation λx . ¬x. There is a
homomorphism h : N →T given by h(0) = ⊤and h(x + 1) = ¬(h(x)).
This is the function which tests whether a number is even. Notice that
these equations not only deﬁne the function but also ensure that it is a
homomorphism.
Groups and rings are examples of algebras whose operators satisfy
a set of equations. This set of equations is often called the ‘theory’ of
groups or rings respectively. The class of all groups, and that of all rings,
is the class of algebras which satisfy the equations. This class is called
a ‘variety’. By introducing homomorphisms as arrows, varieties become
categories – full subcategories of AlgΩfor suitable Ω.
Let us state this formally. First notice that the set TΩ(X) may be
considered to be an Ω-algebra (TΩ(X), τ) by deﬁning the operators to
construct terms, i.e. for each n ∈N and ρ ∈Ωn:
τρ(t1, . . . , tn) = ρ(t1, . . . , tn)

Moreover, there is a function h : X →TΩ(X) deﬁned by h(x) = ⟨x⟩.
Given an algebra (A, α), a function f : X →A determines a homo-
morphism f # : (TΩ(X), τ) →(A, α) deﬁned by
f #(⟨x⟩) = f(x)
f #(ρ(t1, t2, . . . , tn)) = αρ(f #(t1), f #(t2), . . . , f #(tn))
In fact this homomorphism is the unique homomorphism such that f #h =
f. This is described by saying that (TΩ(X), τ) is a free Ω-algebra on the
set X. Freeness and this construction of free algebras is discussed again
in Chapter 6.
An Ω-equation is a pair of terms ⟨t1, t2⟩. An Ω-algebra (A, α) satis-
ﬁes an equation ⟨t1, t2⟩in variables X if, for all functions f : X →A,
f #(t1) = f #(t2).
Let E be a set of Ω-equations.
The pair T = (Ω, E) is called a
presentation of an equational theory (or just a theory). An Ω-algebra is
a T-algebra if it satisﬁes all the equations in E. We may thus deﬁne the
category of all T-algebras with homomorphisms as arrows, AlgT.
The category of groups, Group, is an example of an equational vari-
ety. Let Ωcontain a nullary operator e, a unary operator i and a binary
(inﬁx) operator ◦. The equations E are the associativity of ◦, the left
and right identity laws for e and the left and right inverse laws for i. If
T = (Ω, E), then Group = AlgT.
It is possible to consider constraints other than equations, e.g. Horn
clauses or formulae in ﬁrst order logic, to deﬁne full subcategories of the
categories AlgΩ.
So far, algebras contain just one set and operations on it.
More
generally, we may consider ‘many sorted’ algebras which contain more
than one set. These arise as data types in programming and are discussed
in Chapter 9.
For those with knowledge of universal algebra, we mention that TΩ
is equivalent to the category of free Ω-algebras with homomorphisms as
arrows. In fact, the construction of TΩis a special case of a general
construction due to Kleisli [1965]. For details of this, consult [Manes 76],
[Mac Lane 71] or [Barr, Wells 85] or the related ‘algebraic theories’ of
Lawvere [1963].
3.2.8
Sets with structure and structure-preserving arrows
This is but a small selection of categories which arise. Many categories
have objects which are sets with structure upon them and arrows which

are functions preserving structure, with identities as identity functions
and composition as function composition. We have already met the cate-
gories Graph, Rel and AlgΩwhich are of this form. The preservation of
structure may be the mapping of structure in the source to a correspond-
ing structure in the target. Other forms of preservation are present in
topology where there are categories Top, of topological spaces and con-
tinuous maps, TopOpen, of topological spaces and open maps, Haus,
the category of Hausdorﬀspaces and continuous maps, amongst many
others.
3.3
Categories computationally
We now look at categories from a programming viewpoint. Our aim is to
capture the computational content of the deﬁnition of a category so that
constructions within categories may be expressed as computer programs.
What then is the computational content of a category? The objects
in a category are delimited by their common structure. This common
structure is captured by functions which build objects from other struc-
tures and, possibly, from other objects in the category. A class of values
described in terms of functions for constructing values is the notion of
a ‘type’ in programming.
Thus the class of all objects and, likewise,
that of all arrows, is captured by a type within a suitable programming
language. Types in programming languages are not always suﬃciently
expressive to deﬁne these classes. This is particularly so for languages
without explicit types like Lisp. Nevertheless, the common structure of
objects and arrows is captured by the form of the representation which
can be expressed as functions for constructing representations.
The category structure on the objects and arrows is represented again
using functions. Four functions are required to specify how the objects
and arrows are considered to form a category. These functions are the
source and target functions, returning an object for each arrow, the iden-
tity function, returning an arrow for each object, and the composition
function which, for two composable arrows, returns their composite ar-
row. These functions together with the type of the objects and of the
arrows deﬁne a category and contain all its basic computational content.
Rarely do we consider categories without some additional internal
structure. For example, categories may be equipped with products or co-
products of pairs of objects. We shall deﬁne these constructs in the next
chapter and show that they can be represented as functions. Thus a cat-
egory with additional structure consists of the four functions mentioned

above together with extra functions recording the additional structure.
Notice how we turn properties of a category (e.g. that all pairs of ob-
jects have a product) into functions whose existence is the property in
question.
It is important to capture in the programming the generality of cat-
egorical constructions. The constructions apply to a range of categories.
To compute a result, the construction is specialized to a particular cat-
egory.
This is achieved by binding identiﬁers in the program to the
functions deﬁning the category.
The construction can then call upon
these functions in its computation. This describes the passing of cate-
gories as parameters to programs. We see that a higher-order capability,
passing functions as parameters, is required to program categorical con-
structions. This may be either implicit, as in some algebraic systems, or
explicit as in ML.
Many diﬀerent types may be the objects and arrows of categories. We
have deﬁned a category Set whose objects are sets, a category Graph
whose objects are graphs and a category AlgΩwhose objects are alge-
bras. A categorical construction applies to a range of categories quite
possibly with diﬀerent types of objects and arrows. The construction is
uniform in that the same program is used for the computation in diﬀer-
ent categories, the diﬀerence arises only in the types and the evaluation
of the identity, composition and other functions deﬁning the category.
This phenomenon of a program applying to values of various types, and
hence the function computed having a range of types, is the concept of
(parametric) polymorphism discussed in the previous chapter.
The programming language ML, which we use here, allows both
higher-order functions (functions taking functions as arguments or re-
turning them as results) and a form of type polymorphism. Our imme-
diate aim is to express categories as a type in ML and then write code
for particular categories to yield values of this type.
Recall that a category is described in terms of two types capturing the
common structure of the objects and the arrows, along with four func-
tions deﬁning the category structure on the objects and arrows. These
functions are the source, target, identity and composition functions. If
’o is the type of the objects, and ’a the type of the arrows, then the
source and target functions both have type ’a -> ’o, the identity func-
tion has type ’o -> ’a and composition function has type ’a*’a -> ’a.
We thus declare the type of categories to be that of 4-tuples of functions
with these types:

datatype (’o,’a)Cat =
cat of (’a->’o)*(’a->’o)*(’o->’a)*(’a*’a->’a)
This type declaration deﬁnes a type constructor Cat which, when sup-
plied with types for the objects and arrows gives the type of all categories
with objects and arrows of the speciﬁed type. The right-hand side of the
declaration states that values of the type are 4-tuples of functions with
the given types. This 4-tuple is labelled with the data constructor cat
– an uninterpreted function turning 4-tuples of functions into categories.
Whether categories are labelled or unlabelled tuples is, from a computa-
tional viewpoint, merely a matter of taste, for categories are all of one
form. This should be contrasted with other types, e.g. lists where the
labels nil and :: are essential for distinguishing the two forms of lists.
We choose to label the values so as to record which tuples are to denote
categories and to document the fact that these tuples of functions satisfy
some axioms deﬁning a category.
3.4
Categories as values
To deﬁne a category we need the following: types to represent the objects
and arrows, and deﬁnitions of functions for the source and target of
arrows, the identity arrows and the composition of arrows. We look at
some examples of categories as values in ML.
3.4.1
The category of ﬁnite sets
Let us consider the category FinSet of ﬁnite sets and typed total func-
tions. To begin, we need a type of ﬁnite sets. In some languages, like
Pascal, ﬁnite sets are implemented as a basic type. In languages where
this is not the case we represent ﬁnite sets using other types such as
arrays or lists. In the previous chapter we deﬁned sets as an abstract
type represented by linear lists. Using this representation, we denote by
’a Set the type of ﬁnite sets whose elements have type ’a.
Arrows in FinSet are typed functions – triples consisting of two sets
and a function between them. As a data type this is:
datatype ’a Set_Arrow =
set_arrow of (’a Set)*(’a->’a)*(’a Set)
We now deﬁne four functions describing how ﬁnite sets and set arrows
form a category.

fun set_s(set_arrow(a,_,_)) = a
fun set_t(set_arrow(_,_,b)) = b
fun set_ident(a) = set_arrow(a,fn x => x,a)
fun set_comp(set_arrow(c,g,d),set_arrow(a,f,b)) =
if seteq(b,c) then set_arrow(a,fn x => g(f(x)),d)
else raise non_composable_pair
The notation fn x => e is that of the λ-expression λx.e.
It is at this point that we consider the partial nature of composition.
Composition is deﬁned not on all pairs of arrows but only on composable
pairs, those for which the target object of the ﬁrst is the source object of
the second. To test whether this is indeed the case requires computing
equality on objects in the category. Here we test whether two ﬁnite sets
are equal using the function seteq which, for two ﬁnite sets a and b,
tests whether the following holds:
(∀x ∈a . ∃y ∈b . x = y) ∧(∀y ∈b . ∃x ∈a . y = x)
Thus equality on ﬁnite sets requires an equality function on the elements.
In ML, some types, including primitive types, support an equality by
virtue of the structure of their values. Types which include functions as
part of their values do not have an implicit equality. If an equality is
required in this case then it must be given explicitly.
Notice that an attempt to compose two non-composable arrows is
signalled by raising an exception. In this case all that happens is that
the token message non composable pair is returned. More informative
error handling could be included if required.
These functions on sets and set arrows are bundled together to form
the category of ﬁnite sets, which is a value of type,
(’a Set,’a Set_Arrow)Cat
and is deﬁned by:
val FinSet = cat(set_s,set_t,set_ident,set_comp)
3.4.2
Terms and term substitutions: the category TΩ
F in
We look at a computational representation of one of the categories arising
in universal algebra discussed in Section 3.2.7. We consider the category
TΩF in whose objects are ﬁnite sets and whose arrows are term substitu-
tions.

We deﬁne operator domains, terms and term substitutions in ML. An
operator is an operator symbol together with an arity. We take arities to
be sets of names of argument places rather than just natural numbers, so
that we identify the argument places in a term ρ(t1, . . . , tn) with the set of
numbers {1, . . . , n}. More generally the argument places can be names,
for example, the division operator on numbers may be denoted by the
pair (/,{numerator, denominator}). When arities are natural numbers,
terms are built from lists of subterms and so list-processing operations
are involved.
By considering arities to be sets, we use set operations
instead. These operations can be described as categorical constructs in
FinSet, constructs such as limits and colimits, and thus we develop a
wholly categorical treatment.
We deﬁne a type of operators as below:
datatype opr = opr of symbol * (element Set)
Thus an operator is of the form opr(s,a) with s a symbol (its name)
and a a set (its arity). Here element is the type of names of argument
places. We may ﬁx this to be, say, character strings or integers.
We deﬁne terms recursively as either a variable ⟨x⟩, denoted var(x),
or as an operator together with an assignment of terms to the argu-
ment places ρ(tα1 . . . tαn), denoted apply(rho,fn x => t(x)). The ‘|’
is ML’s labelled union of these two cases.
datatype Term = var of element |
apply of opr * (element -> Term)
A term substitution f : a →b is a function taking elements of set
a to terms whose variables are in set b. We also need to keep track of
the source set a and the target set b, so we deﬁne a substitution to be a
triple:
datatype Substitution =
subst of (element Set)*(element -> Term)*(element Set)
Following the treatment in Section 3.2.7, composition of substitutions
is deﬁned in terms of the application of a substitution to a term.
fun subst_apply(t)(S as subst(a,f,b)) =
case t of var(x) => f(x)
| apply(psi,s) =>
apply(psi,fn x => subst_apply(s x)(S))

fun subst_compose(S as subst(c,g,d),subst(a,f,b)) =
if seteq(b,c)
then subst(a,fn x => subst_apply(f x)(S),d)
else raise non_composable
We also need the identity substitution on a set, together with source
and target functions, which are deﬁned as follows:
fun subst_ident(a) = subst(a,fn x => var(x),a)
fun subst_s(subst(a,_,_)) = a
fun subst_t(subst(_,_,b)) = b
Deﬁne the category TΩF in as the 4-tuple of these functions:
val FinKleisli =
cat(subst_s,subst_t,subst_ident,subst_compose)
3.4.3
A ﬁnite category
As another example of a category in ML, consider a ﬁnite category, that
of Section 3.2.3, depicted below.
b
c
a
f
g
h
k
     @
@
@
@
R
@
@
@
@
R
-
Composition is deﬁned by gf = k and hf = k and the existence of
an identity arrow for each object is assumed.
In this case the objects and arrows are constants. We represent them
using enumerated types. Identities are constructed as labelled objects
(we may make them additional constants but this lengthens the case
analyses):
datatype Obj = a | b | c
datatype Arrow = f | g | h | k | id of Obj
Source, target and composition are deﬁned explicitly for each argu-
ment using case analysis.

val example_category =
let val s = fn f => b | g => a | h => a |
k => b | id(x) => x
and t = fn f => a | g => c | h => c |
k => c | id(x) => x
and ident = fn x => id(x)
and comp =
fn (id(x),u) => if t(u)=x then u
else raise non_composable
| (u,id(x)) => if s(u)=x then u
else raise non_composable
| (g,f) => k | (h,f) => k
| _ => raise non_composable
in cat(s,t,ident,comp) end
3.5
Functors
Functors are maps between categories that preserve the category struc-
ture. Let A and B be categories, a functor F : A →B consists of two
functions, one from the objects of category A to those of B and one from
the arrows of A to those of B. It is usual to denote both these functions
by the functor name, F. The sense in which the category structure is
preserved is given in the following deﬁnition.
Deﬁnition 3 A functor F : A →B from category A to category B is a
pair of functions
• F : Obj(A) →Obj(B),
F : a 7→F(a)
• F : Arrow(A) →Arrow(B),
F : (f : a →b) 7→F(f) : F(a) →
F(b)
satisfying F(ia) = iF (a) and F(gf) = F(g)F(f) whenever gf is deﬁned.
A functor from a category C to itself is called an endofunctor on C.
Functors F : A →B and G : B →C may be composed to form
a functor GF : A →C by the separate composition of the constituent
functions. Identity functors consists of two identity functions. In fact,
we may consider categories to be objects within a category and functors
to be arrows.

3.5.1
Functors computationally
Functors, consisting as they do of two functions, one on objects, the
other on arrows, can be represented quite simply. We need only recall
that functors, being arrows, determine their source and target categories,
which therefore need to be included as components in the representation.
Just as the type of a category depends on that of its objects and arrows,
so the type of a functor depends upon the types of objects and arrows in
both the source and target categories. We put all this together in a type
deﬁnition for functors.
datatype (’oA,’aA,’oB,’aB)Functor
=
ffunctor of (’oA,’aA)Cat *
(’oA->’oB) * (’aA->’aB) *
(’oB,’aB)Cat
The word ‘functor’ is rather overused, occurring not only in category
theory but also as programming constructs in languages like Prolog and
ML (the latter is related to the categorical notion of functors). Note
that we write ffunctor rather than functor to distinguish categorical
functors from ML functors.
3.5.2
Examples
To describe particular functors we need the source and target categories
and the functions on objects and on arrows.
Let us consider an example, the identity functor on a category, IA :
A →A, acting identically on objects and arrows:
fun I(A) = ffunctor(A,fn x => x,fn x => x,A)
For a more substantial example consider the functor X : FinSet →
FinSet which maps a ﬁnite set a to a×a, the cartesian product of a with
itself. On arrows (typed functions) it maps f to f × f deﬁned by (f ×
f)(x, y) = (f(x), f(y)). The functorial nature of X can be established as
follows:
X(gf)(x, y) = (gf(x), gf(y)) = (g(f(x)), g(f(y)))
= X(g)(f(x), f(y)) = X(g)X(f)(x, y)
and
X(ia)(x, y) = (x, y) = iX (a)(x, y)
We now program this functor. The cartesian product of ﬁnite sets
may be deﬁned recursively as follows:

fun cartesian_prod(A,B) =
if is_empty(A) then nil_set else
let val (a,A’) = singleton_split A in
mapset(fn b => (a,b),B)
U
A’ X B end
Here mapset(f,C) is the image of set C through the function f and U is
set union.
The product of two set arrows is deﬁned below:
fun prod_arrow(set_arrow(A,f,B),set_arrow(C,g,D))
=
set_arrow( cartesian_prod(A,C),
(fn (x,y) => (f(x),g(y))),
cartesian_prod(B,D) )
The functor X is the 4-tuple consisting of the source category, the two
functions, one on objects, the other on arrows, and the target category:
val X =
ffunctor(FinSet,fn A => cartesian_prod(A,A),
fn f => prod_arrow(f,f),FinSet)
Category theory leads us to ask not only what structures are in-
volved in a computation but also what are the appropriate maps be-
tween structures.
Functors are a computation on structures together
with a computation on the maps between structures. These two func-
tions are connected by the functorial axioms. This should be contrasted
with collections of loosely connected or totally unconnected functions
which are grouped together to form ad hoc modules. Not only is there
a mathematical rationale to this collection of functions but it provides
a more complete description of the situation. The completeness of the
description is important in ensuring a wider re-usability of the code.
3.6
Duality
Like several other branches of mathematics, category theory supports a
principle of duality. In the case of category theory, this arises from the
invariance of the theory under the interchange of the source and target
of arrows, i.e. reversing arrows. Each categorical property has a dual
obtained by reversing all arrows in the statement of the property. The
invariance means that one proof gives two results, the theorem proven
and its dual. In programming, one piece of code will perform two calcu-
lations!

Duality can be formalized at a meta-level as a transformation of for-
mulae in the ﬁrst-order theory of categories. Each formulae has a dual
obtained by a purely syntactic transformation interchanging sources and
targets and reversing composites, see [Mac Lane 71] for details. This is
interesting as a theorem-proving technique in which a theory is mapped
back into itself under a validity-preserving map. In programming this
syntactic manipulation of code goes under the name of ‘program trans-
formation’ and usually arises in the context of eﬃciency of execution
rather than multiple computations.
As pointed out by Mac Lane [1971], there is an alternative description
of duality involving operations on categories and functors. For a category
A, we can deﬁne a ‘dual’ category, dual(A), whose objects are those of
A and whose arrows are the reverse of arrows in A. Composition has
then to be reversed:
Deﬁnition 4 Let A be a category. The dual category, dual(A), has as
objects those of A. Arrows f : a →b in dual(A) are arrows f : b →a
in A. Identities are those of A, whilst composition of f : a →b and
g : b →c in dual(A) is deﬁned as fg : c →a in A.
The dual of a functor F : A →B, dual(F) : dual(A) →dual(B), is
the same pair of functions as F but between the dual categories.
Any categorical property or construction is transformed into its dual
by interpreting it in the dual category. This is the role of duality in the
forthcoming programming. The dual of a construction is obtained from
a program for the construction by composition with duality operations.
In Chapter 4 we use duality to transform colimit constructions to limit
constructions and in Chapter 5 we deal with constructions of categories
where duality introduces canonical isomorphisms.
Here all we do is code up the duality operation on categories and
functors.
This is a straightforward translation into ML of the above
deﬁnitions:
fun dual_Cat(cat(s,t,i,c)) =
cat(t,s,i,fn (g,f) => c(f,g))
fun dual_Fun(ffunctor(A,fo,fa,B)) =
ffunctor(dual_Cat(A),fo,fa,dual_Cat(B))

3.7
An assessment∗
We now assess what we have done in representing categories and functor
for computation, mentioning a few important points. A fuller treatment
will be found in Chapter 10, where we discuss formal (linguistic) aspects
of category theory and the requirements on a language for encoding cat-
egory theory.
The representation of categories given above is intended to capture
exactly those ingredients of a category required in categorical construc-
tions so that we may code up these constructions to run on computers. It
will become clear in the next few chapters that this representation indeed
allows us to program many basic constructions in category theory. The
generality of these constructions is captured through passing categories
as parameters, using the higher order types of ML, and through type
polymorphism.
Categories are expressed as types within ML. However, the constraint
provided by the type system is too weak. For the type correctness of a
program, any four functions taking arguments of the requisite type and
returning results of the requisite type can be considered to be a category.
Type systems for programming are a compromise between expres-
siveness and utility. ML polymorphism is more expressive than many of
the the type systems of current programming languages like Pascal, yet
is much weaker than systems designed for expressing constructive math-
ematics. Unlike many of the more expressive systems, the type-checking
of ML is static, i.e. it is decidable whether a value is of a particular type.
This property has advantages from a programming point of view, since
type security of a program can be automatically assured before running
the program.
The information which is lost in moving from the mathematics to
ML types is, ﬁrst of all, the axioms relating the functions. For cate-
gories, these are the axioms of associativity of composition, identities
and those deﬁning the source and target of composites and identities.
Moreover, where partial functions occur, as in the composition of arrows
in a category, there is no means of describing in ML types the domain
of deﬁnition of partial functions. Programming languages, designed as
they are for executability, separate the constructive elements in a proof
from the veriﬁcation that the construction satisﬁes its speciﬁcation. It
is, therefore, incumbent upon the programmer to ensure that only struc-
tures satisfying the requisite axioms are supplied to programs.
An alternative is to force this veriﬁcation to take place. There has

been a good deal of interest over the last few years in formal systems
for mathematics which include proofs. Some of this interest has been
generated by the requirements of computation.
Not only do we wish
to know the possibility of expressing mathematics in a formal system,
but we also want it to be a practical proposition to run various parts of
mathematics on a computer.
The computations we undertake involve ﬁnite structures. For exam-
ple, we consider categories of ﬁnite sets and of ﬁnite graphs. This could
be extended to enumerable structures such as lazy lists. However, there
are categories where the objects are themselves described as types, such
as categories of algebras and categories of categories. To express these
in a type system we need type universes, at least a type of ‘small’ types.
Some further points about the categorical programming we describe
in this book: We are not inventing a categorical programming language,
like that of Hagino [1987], described later, or a language for programming
category theory, except in as much as the type deﬁnitions and functions
in ML constitute a language. Notice that the arrows in a category are not
represented by the arrow type constructor for function types. The type
constructors are associated with an underlying category whose objects
are types and whose arrows are functions. Arrow types correspond to
exponentials in the category. It is not this category that we are encoding.
As a consequence, the well-formedness of composites is not a matter
of type-checking. In fact, such well-formedness requires a computation
of equality on objects in the category.
In formalizing the notion of a
category, this equality on objects is not usually made explicit but it has
to be considered in any foundation for category theory, see [B´enabou 85])
for a discussion of this matter.
One method of handling equality on objects is to include an equality
function as a component of the representation of a category. To insist
that all categories have a computable equality on objects will rule out
many categories in which the equality is not computable but which are
otherwise perfectly well-behaved – categories which we can represent,
compute with and usefully apply, for example, categories of functors.
This suggests introducing two forms of categories – those with and with-
out equality on objects. An analogous situation arises with equality on
values in programming languages.
Notice also that, unlike the mathematics, we make an allowance for
non-denoting expressions such as the composition of non-composable ar-
rows. In cases like this, we include exception handling, where possible,
to make the program ‘robust’, i.e. able to cope with erroneous input.

Some deﬁnitions of categories explicitly introduce the collection of
arrows between each two objects a and b as a set called the hom-set
and denoted, in category C, by HomC(a, b) or just C(a, b). We do not
consider this part of the general structure of categories. Where we wish to
consider hom-sets as ﬁnite sets, we represent them as an extra component
of type ’o x ’o -> (’a Set) and hence deﬁne ‘locally ﬁnite’ categories.
So far, we have looked at the type of categories. Now let us look at a
particular category, FinSet, to see how the computational representation
matches the intended mathematics. In fact, the representation falls short
of the category of all ﬁnite sets.
The type of categories allows only
‘homogeneous’ categories – those in which all objects have the same type,
and likewise all arrows. Thus the sets in FinSet all have elements of the
same type. This is indicated by the fact that FinSet is a polymorphic
constant of type (’a Set,’a Set Arrow)Cat. Letting the type variable
’a be the type int, we see that FinSet may be the category of ﬁnite
sets of integers.
This uniformity of type in ML is intended to allow
us to deﬁne types where computation is allowed.
Thus in ﬁnite sets
of integers, disjoint unions may be represented by particular arithmetic
computations which would not be available in the general category of
sets. By enriching the type structure, beyond that of ML, it is possible
to encode more general categories of sets. For instance, dependent types
allow us to express categories of homogeneous sets whose type of elements
vary from set to set.
There is a further mismatch between the category FinSet and its rep-
resentation. The arrows in FinSet are total functions yet the represen-
tation allows partial functions, since the arrow type constructor gives the
space of all partial functions, allowing, as it does, for the non-termination
of programs. Unless we are working within a framework where all func-
tions are total, ensuring that functions are total on a domain is unlikely
to be decidable. Again it is incumbent upon the programmer to ensure
that total functions are supplied where required.
Some of the veriﬁcation that structures are indeed categories can be
avoided through systematic ways of constructing categories from other
categories. Constructions of categories are introduced in Chapter 5 where
we show that from a few primitive categories, like FinSet, a whole range
of useful categories can be built and their categorical nature can be as-
sured through the correctness of the construction.

3.8
Conclusion
In this chapter we have considered at some length the fundamental con-
cepts of categories and functors, displaying types to represent these and
writing programs for particular categories and functors. So far we have
not presented any signiﬁcant categorical constructions so the code we
have written is fairly simple, all the eﬀort going into the design of repre-
senting types. In the next few chapters we consider constructive proofs
of theorems in category theory. From these proofs we derive programs
for calculations within categories, using the representations of categories
and functors presented here.
3.9
Exercises
Exercise 1. Let us consider how to represent the category of ﬁnite
graphs FinGraph in ML. This is a full subcategory of the cat-
egory of graphs described in Section 3.2.2.
Objects in the category are ﬁnite graphs which may be repre-
sented as 4-tuples, consisting of two ﬁnite sets N and E (of nodes
and edges) and two functions s, t : E →N.
We represent the
collection of such graphs as a type in ML as follows:
datatype Graph =
graph of (Node Set)*(Edge Set)*
(Edge->Node)*(Edge->Node)
The types Node and Edge are names for the nodes and edges and
so may be ﬁxed to be character strings or integers or whatever.
Arrows are pairs of functions,
(f : N →N ′, g : E →E′) : (N, E, s, t) →(N ′, E′, s′, t′)
such that, for all e ∈E, f(s(e)) = s′(g(e)) and f(t(e)) = t′(g(e)).
This pair of functions, together with the source and target graphs
form the type of arrows:
datatype Graph_Arrow =
graph_arrow of Graph*(Node->Node)*(Edge->Edge)*Graph

The source and target of arrows are projections onto the ﬁrst and
last components. Deﬁne ML functions for the identity arrows and
the composition of arrows and hence deﬁne the category of ﬁnite
graphs in ML.
Exercise 2. This is an exercise in deﬁning the category FinSetRel (Sec-
tion 3.2.1) in ML. The objects are ﬁnite sets and the arrows are
relations. A relation may be represented as a ﬁnite set of pairs.
Deﬁne arrows in FinSetRel as a type in ML (including the source
and target sets).
Write code for the composition of relations and hence deﬁne the
category in ML. For this you will need some operations on ﬁnite
sets.
Use the following (you may like to deﬁne them using the
functions on sets described in the previous chapter): the mapset or
image operation ‘mapset(f,S)’ applying a function f to all elements
of a set S to yield the set {f(x) | x ∈S}, the cartesian product
S × T of two sets, the subset deﬁned by a predicate P, ‘ﬁlter S by
P = {x ∈S | P(x)}’, and equality on sets assuming an equality on
their elements.
An alternative representation of relations uses power sets. The
power set P(a) of a set a is the set of all subsets of a. A relation
r : a →b can be described as a partial function r : a →P(b).
Deﬁne the composition of relations in this representation and the
category whose arrows are relations in this form.
We shall see later that the operations on relations used here,
seemingly awkward to code, can be expressed elegantly using cat-
egorical constructions.
Exercise 3. Recall that a partial order can be considered to be a cat-
egory (Section 3.2.5).
Let us see how to represent the natural
numbers N as a category under the usual partial order: m ≤n iﬀ
∃p ∈N . m + p = n.
Objects are natural numbers which, following Peano arithmetic,
we may deﬁne to be a type whose values are in 1-1 correspondence
with expressions built from a constant using one unary operation:
datatype Num = zero | succ of Num
Thus succ(succ(zero)) represents the number 2. Operations like
addition may be deﬁned on natural numbers using recursion:

fun add(zero,n) = n
| add(succ(m),n) = succ(add(m,n))
For each pair of natural numbers (m, n) such that m ≤n there
is to be exactly one arrow m →n. For m ≤n, we represent the
unique arrow m →n by the pair of numbers (m, n −m). Moreover
any pair of numbers (p, q) represents an arrow p →p + q. Notice
that the source and target numbers are reconstructable from the
pair representing the order relation.
What are identity arrows? Deﬁne composition of arrows in ML
and hence the category derived from the partial order on natural
numbers.
Exercise 4. A monoid is a semigroup (a set with an associative binary
operation) with an identity element.
A category with just one
object is a monoid, i.e. the arrows deﬁning the category form a
monoid whose binary operation is composition and, conversely, any
monoid forms a category with one object.
The set of lists A∗of elements drawn from a set A form a
monoid, with the binary operation as the end-to-end concatenation
of lists and identity as the empty list. Deﬁne in ML the correspond-
ing category.
Exercise 5. Deﬁne the relation ⪯on lists by s ⪯t iﬀs is an initial
part of t, i.e. there is a list u such that t = s ⋄u where ⋄is the
end-to-end concatenation of lists. An arrow between lists f : s →t
is a function f from the elements of s such that f(s) ⪯t where the
application on the left is elementwise.
Deﬁne and the composition and identities and prove that the
result is a category.
Choose a suitable representation in ML for the arrows (the anal-
ogy with Exercise 3 may be useful) and code up the category.
Exercise 6. Matrices Consider the category MatrixK whose objects
are natural numbers and whose arrows n →m are m × n matri-
ces over a commutative ring K. Composition is matrix product.
Represent this in programming terms (you may wish to restrict
attention to the case when K is the ring of integers).
Exercise 7. Consider the power set operation, mapping a set to its set
of subsets P : a 7→P(a).
We show that it is functorial, that

is, there is an accompanying operation on functions so as to form
a functor.
The operation on functions mapping f : a →b to
P(f) : P(a) →P(b) is deﬁned by P(f)(s) = {f(x) | x ∈s},
the image of subset s under f. Verify that this deﬁnes a functor
P : Set →Set and program it for ﬁnite sets. The power set of a
ﬁnite set may be computed recursively very much like the cartesian
product of sets in Section 3.5.
Exercise 8. 2-categories
A richer compositional structure than a category is a 2-category,
which has not only arrows but also arrows between arrows:
Deﬁnition 5 A 2-category is a category A together with arrows
between arrows with the same source and target. Objects in A are
called 0-cells, arrows are called 1-cells and arrows between arrows
are 2-cells. Let f, g : a →b, denote a 2-cell by α : f ⇒g or, more
fully, α : f ⇒g : a →b or, pictorially, as:
a
b
f
g
α
⇓
-
-
There are two compositions of 2-cells: If f, g, h : a →b and α : f ⇒
g, β : g ⇒h, there is a composition β.α : f ⇒h forming a category
for each pair of objects a and b. This is vertical composition. For
2-cells α : f ⇒f ′ : a →b and β : g ⇒g′ : b →c there is
an associative composition β ◦α : gf ⇒g′f ′. This is horizontal
composition, often written as βα. These two compositions satisfy
the so-called interchange law:
(α.α′) ◦(β.β′) = (α ◦β).(α′ ◦β′)
Finally, identities of vertical composition are those of horizontal
composition, in the sense that if ia : a →a is the identity on a and
iia : ia ⇒ia is the identity of ‘.’, then it is also the identity of ‘◦’.
Following the representation of categories, represent 2-categories as
an ML type.
Exercise∗9. Categories form objects in a category Cat with functors as
arrows. Show this and consider how to encode Cat in a formalism
in which type universes are available.


Chapter 4
Limits and Colimits
Category theory is the theory of typed composition of arrows and as such
is a very ‘weak’ theory. The theory ﬁnds its strength in powerful and
intricate descriptive mechanisms. Amongst these are the topic of this
chapter – limits and colimits.
Limits and colimits give a uniﬁed treatment of constructs such as
products and sums of pairs of objects and limits of chains of objects.
These constructs appear in various guises in set theory, algebra and topol-
ogy. For example, we may form the product of two sets, the product of
two groups and the product of two topological spaces. The details of
the construction vary, but the general form of products is common to
all cases. Mac Lane [1948,50] showed that products can be described
abstractly in terms of the projection arrows from products to their com-
ponents. This description uses universality – a method of deﬁnition by
which a class of structures is deﬁned and a particular structure isolated
by its relationship with others in the class. We look at this in detail be-
low. Kan [1958] extended Mac Lane’s observation, introducing a general
concept of limit and colimit which encompasses many of the universally
deﬁned combinations of structures.
As general mechanisms for combining structures, limits and colim-
its are of relevance to programming. This observation goes back to the
work of Goguen [1971] and Goguen and Ginali [1978] in general systems
theory. Colimits, in particular, allow us to build structured objects from
components. Notice that, unlike sets, objects with internal structure,
like graphs, cannot in general be decomposed as disjoint unions. De-
compositions have to take account of shared sub-components. Colimits
handle this by introducing arrows between components of a structure.
In programming, as in any activity involving writing deﬁnitions, we
65

give names to values, so creating environments. Environments are nam-
ing structures and may be sets of names, maps, labelled graphs, program
modules, or algebraic theories, depending upon context. Building envi-
ronments from components involves some, often fairly intricate, manip-
ulation of names (variables or identiﬁers). We create names uniquely,
identify them, separate them, or rename them as required. Limits and
colimits provide general mechanisms for handling names. Coproducts (a
form of colimit) correspond to separating names and often replace the
requirement to create new variables distinct from those present (as with
the non-functional ‘gensym’ of Lisp). On the other hand, pushouts (an-
other form of colimit) correspond to identifying selected names. We look
at examples of this later, particularly in Chapter 9 where we consider
constructing algebraic theories.
In this chapter we present the ﬁrst substantial programming exer-
cises.
The programs are drawn from constructive proofs in category
theory. The correspondence between constructive proofs and programs
allows proof techniques to be used in program construction. This has
been inﬂuential in the development of type theory, as in [Martin L¨of
75,82,84].
The Nuprl system [Constable et al. 85] is an implementa-
tion of a type theory in which programs can be automatically extracted
from constructive proofs. The programming we undertake relies on the
fact that category theory is largely (though not wholly) constructive:
proofs of existence are explicit constructions which may be expressed as
programs.
The programs derived from category theory are tightly organized,
following the organization of the theory itself. They are also highly ab-
stract being parameterized over categories.
This gives an abstraction
beyond that normally encountered in programming. Programs are ‘data
independent’ in the sense that, by supplying diﬀerent categories, pro-
grams can be executed on diﬀerent data structures. A construction can
be executed on sets, graphs, algebras or whatever depending upon the
parameter category.
The inherent duality of category theory, its invariance under ‘revers-
ing arrows’, is here put to computational use. Limits are dual to colimits,
and because it is duality, colimits are dual to limits. Not only does du-
ality allow us to interchange between the two concepts, and hence their
representations as types, but also programs constructing colimits can be
re-used to construct limits, simply by interpreting the colimit computa-
tion in the dual category.
A remarkable aspect of category theory is its richness in ways of con-

structing colimits from other colimits and, by duality, limits from other
limits. These constructions have an easy pictorial nature, often being ex-
pressed as the ‘pasting together’ of diagrams. We use these constructions
to capture the compositional nature of various algorithms, including, as
we shall see later, algorithms for the uniﬁcation of terms. As well as con-
structions obtained from simple diagrams, there are general constructions
for computing arbitrary colimits in a category. The constructions are not
in any sense ‘deep’ but their variety is fascinating.
We shall look in detail at some of these constructions. The proofs
are based upon ‘diagram-chasing’. When converted into ML programs,
their diagrammatic form is necessarily lost. To overcome this, a graphical
input/output facility could be provided for the programs or, possibly, a
more pictorial language used. An interesting aspect of constructions of
limits and colimits is that the universal property is usually inherited, in
the sense that the universality of the constructed object arises directly
from the universality of its constituents. This imposes a tight structure
on proofs making them almost automatic if the relevant diagrams ﬁt
together, a point of interest in proof mechanization.
In this chapter, we ﬁrst discuss deﬁnition by universality. We then
turn to colimits, introducing some special cases, then the general concept.
We represent these as types in ML using a functional representation of
universality.
We then present some programs for computing colimits,
including a calculation of arbitrary ﬁnite colimits in a category. This
is reproduced for limits except that constructions of limits are obtained
from those of colimits using duality. We consider colimits before limits,
and in greater detail, as they appear more often as general constructional
mechanisms. Colimits are applied to programming tasks in Chapters 8
and 9.
We concentrate in this chapter on computing colimits and limits in
the category FinSet.
In the next chapter, we show how the general
constructions are used in other categories.
4.1
Deﬁnition by universality
Deﬁnition by universality is a familiar deﬁnition technique which, in cat-
egory theory, provides the principle way of characterizing structure. We
illustrate universal deﬁnitions with an example from set theory:
The union of two sets, A and B, is the smallest set containing
both A and B.

It consists of two parts:
• A deﬁnition of a class of objects which, in this case, is the class of
all sets containing both A and B.
• A criterion for distinguishing a particular element in this class (or,
more generally, a sub-class of elements) by its relationship to other
elements. In the case above, the criterion is simply the ‘smallest’,
i.e. contained within any other element in the class.
It turns out that category theory is a suitable formalism for expressing
these universal deﬁnitions. Both the class of elements and the criterion
for distinguishing a particular element are described in the same, arrow-
theoretic, language. There is a standard format for such deﬁnitions in
which the criterion for distinguishing a particular element is the unique
existence of an arrow satisfying some given conditions. This deﬁnes ob-
jects only to within an isomorphism: if two objects both satisfy the
requirements of the deﬁnition then they are isomorphic. Thus objects
are viewed abstractly, that is independent of a particular representation.
This characteristic of category theory is one sense in which the theory is
‘abstract’. For objects deﬁned to within an isomorphism, we shall adopt
the usual convention of talking of ‘the’ object, when meaning any object
in the isomorphism class.
Determining an object to within an isomorphism poses a problem
from a computational viewpoint; which object in the isomorphism class
is computed or is the whole class computed? Our treatment is algebraic
in that all constructs appear as operations determining a unique object
in the isomorphism class. Where isomorphisms are important, these are
calculated as components of a structure and hence are themselves results
of operations. If there is more than one way of performing a calculation,
the results may diﬀer by an isomorphism which itself is the result of a
calculation.
Limits and colimits can both be deﬁned through universality. More
examples will be found in succeeding chapters. A curious result is the
interdeﬁnability of universal concepts in category theory. Universal con-
cepts can be obtained from one another by interpreting them in suitable
categories.
4.2
Finite colimits
In this section we consider some special cases of colimits: initial objects,
binary coproducts, coequalizers and pushouts. We deﬁne these concepts,

show how they may be expressed as types in ML, including a represen-
tation of the universality, and then encode examples in FinSet.
4.2.1
Initial objects
The deﬁnition of an initial object in a category goes as follows:
Deﬁnition 6 An initial object in a category is an object, a, such that
for any object, b, there is a unique arrow f : a →b.
In the categories Set and FinSet, the initial object is the empty set
φ, because for any set b there is just one function from φ to b, that with
the empty graph.
We show how initial objects may be represented as a type in ML. An
initial object is an object, a, which satisﬁes a certain universal property.
This property deﬁnes a function taking each object, b, into the unique
arrow f : a →b. It is this pair of an object and a function (assigning an
arrow to each object) which serves as a representation of an initial object.
If objects have type ’o and arrows have type ’a then initial objects have
type:
’o * (’o -> ’a)
We thus introduce the following type declaration to name types of the
above form:
type (’o,’a)InitialObj = ’o * (’o -> ’a)
This functional representation of the universal property is crucial
to the programming of category theory. It is ‘Skolemization’, turning
∀∃-statements (unique existence in this case) into functions. It applies
not only to the initial object but to all universally deﬁned concepts in
category theory. We shall see many examples in the succeeding pages
of types of this form and show how to write programs to compute with
them. Notice that we could have used a datatype declaration here and
so introduced a constructor for initial objects.
These deﬁnitions are
equivalent; we give the one above for simplicity.
The representation of initial objects as an ML type is fairly slack.
Conditions on the source and target of arrows, as well as the unique-
ness of the universal arrow, are not included. However, it captures all
the structure necessary for computation. Further properties on the type
are treated as veriﬁcation conditions as discussed in the previous chap-
ter. You may wonder whether it is necessary to include the universal

property as a component of the type. It is often inherited through con-
structions and so universality of constructed objects can be guaranteed.
However, the ability to handle universality as a structure in its own right
makes various categorical constructions programmable – for example,
free algebras and colimits in comma categories, both of which we meet
later.
The initial object in FinSet is a value of the above type. We program
it as follows:
val set_initial =
(emptyset, fn a => set_arrow(emptyset,nil_fn,a))
Here emptyset is the empty set, which, if sets are represented as lists, is
the empty list. The function nil fn is the empty function that raises an
exception on any argument.
In Set and FinSet there is but one initial object, the empty set. In
other categories, initial objects may not be unique but are always isomor-
phic. We prove this using a simple but neat arrow-theoretic argument.
The proof for other universal concepts is similar. Let a and a′ be initial
objects in a category. Since a is initial, there is an arrow f : a →a′ and,
since a′ is initial there is an arrow g : a′ →a. Now gf : a →a; but
ia : a →a is another arrow from a to itself, so by the uniqueness of the
arrow from an initial object gf = ia. Likewise, fg = ia′. So a and a′ are
isomorphic.
We express this argument as the construction of an isomorphism,
a pair of mutually inverse arrows, in the following little ML program.
It takes two initial objects, including their universality, and returns an
isomorphism:
fun iso_initial((a,univ_a),(a’,univ_a’)) =
(univ_a(a’),univ_a’(a))
4.2.2
Binary coproducts
Binary coproducts are another example of colimits. They are deﬁned as
follows.
Deﬁnition 7 A (binary) coproduct of objects a and b in a category is
an object a + b together with arrows f : a →a + b and g : b →a + b such
that, for any object c′ and arrows f ′ : a →c′ and g′ : b →c′, there is
a unique arrow u : a + b →c′ (denoted [f ′, g′]) such that the following
diagram commutes.

a
a + b
c′
f
f ′
u
-
?
@
@
@
@
R
b
g
g′

    	
Binary coproducts determine a sum of arrows: Let f : a →a′ and
g : b →b′, deﬁne f + g : a + b →a′ + b′ to be [ja′f, jb′g] where ja′ : a′ →
a′ + b′, (a′ + b′, jb′ : b′ →a′ + b′) is the coproduct of a′ and b′.
The binary coproduct of sets a and b in Set (as well as in FinSet)
is their disjoint union a ⊎b. The disjoint union can be represented in
various (isomorphic) ways, labelling the elements of the two sets to keep
them disjoint. There are functions f : a →a ⊎b and g : a →a ⊎b,
called the coproduct injection functions. The universal property takes a
set c′ and functions f ′ : a →c′ and g′ : b →c′ and returns a function
u : a ⊎b →c′ deﬁned by, for x ∈a ⊎b of the form f(z) for z ∈a then
u(x) = f ′(z), otherwise x is of the form g(z) for z ∈b and u(x) = g′(z).
By deﬁnition, this function makes the following diagram commute.
a
a + b
c′
f
f ′
u
-
?
@
@
@
@
R
b
g
g′

    	
Moreover, any function u making this diagram commute must be
deﬁned as indicated on the image of f and on the image of g and hence
u uniquely satisﬁes this commuting diagram.
We now turn to a representation of binary coproducts as a type in
ML. A binary coproduct is a function which takes two objects a and b
and returns a triple consisting of an object and two arrows, (a + b, f, g).
This triple satisﬁes a universal condition which deﬁnes a function from
such triples to arrows, assigning to (c′, f ′, g′) the unique arrow [f ′, g′] :
a + b →c′. As an ML type this becomes:
type (’o,’a)Coproduct =
’o * ’o -> (’o,’a)Coproduct_CoCone
where Coproduct CoCone is deﬁned as:
type (’o,’a’)Coproduct_CoCone =
(’o * ’a * ’a) * (’o * ’a * ’a -> ’a)

Coproducts in FinSet are disjoint unions as explained above. We
show how they form a value of this type. To ensure the disjointness of
the union of two sets a and b, we label the elements of each set with a
label diﬀerent from that of the other set. The two labels are arbitrary –
we choose pink and blue (for girls and boys). Recall that categories of
sets are homogeneous: all elements have the same type. Thus labelled
elements must have the same type as unlabelled elements. A new type
is introduced so that elements are closed under the labelling operation:
datatype ’a Tag =
just of ’a | pink of (’a Tag) | blue of (’a Tag)
An example of a term of type int Tag is pink(pink(blue(just(2)))).
The coproduct object in FinSet of sets a and b is their (labelled) dis-
joint union. As an example, the disjoint union of set {just(1),just(2)}
with set {just(2),just(3)} is
{pink(just(1)),pink(just(2)),blue(just(2)),blue(just(3))}
The arrows into this coproduct are the labelling functions. The universal
property deﬁnes a function which takes any pair of functions f : a →c
and g : b →c and yields a function [f, g] : a + b →c.
All this is expressed in the following ML program:
fun set_coproduct(a,b) =
let val sumab = mapset(pink)(a) U mapset(blue)(b)
{ the disjoint union }
val univ =
fn (c,set_arrow(_,f,_),set_arrow(_,g,_)) =>
let val fg = fn pink x => f(x)
| blue x => g(x)
in set_arrow(sumab,fg,c) end
{ the universal part }
in (( sumab,
set_arrow(a,pink,sumab),
set_arrow(b,blue,sumab)),
univ) end
4.2.3
Coequalizers and pushouts
We end this section with two further special cases of ﬁnite colimits: co-
equalizers and pushouts.

Deﬁnition 8 A coequalizer of a parallel pair of arrows f, g : a →b in a
category is an object c and an arrow q : b →c with qf = qg such that for
any object c′ and arrow q′ : b →c′ such that q′f = q′g, there is a unique
u : c →c′ to make the diagram below commute.
b
c
c′
q
q′
u
-
?
@
@
@
@
R
Coequalizers in Set and FinSet are calculated using equivalence
classes. Let f, g : a →b be two functions. Deﬁne a relation on b by
x ; y iﬀthere is a z ∈a with f(z) = x and g(z) = y. Let ≃be the
equivalence closure of ;, and c be the set of ≃-equivalence classes. The
quotient function q : b →c maps an element x to its equivalence class
[x] so that qf = qg. Now let c′ be a set and q′ : b →c′ be a function
such that q′f = q′g, deﬁne u : c →c′ by u([x]) = q′(x). This is well-
deﬁned and, moreover, uq = q′ by deﬁnition and u is clearly the only
such function.
Deﬁnition 9 A pushout of a pair of arrows f : a →b and g : a →c
in a category is a pair of arrows p : b →d and q : c →d such that the
square
a
c
b
d
g
q
f
p
?
-
?
-
commutes and the following universal condition is satisﬁed: Suppose
p′ : b →d′ and q′ : c →d′ with p′f = q′g, then there is a unique u : d →d′
such that the following diagram commutes.

b
d
d′
p
p′
u
-
?
@
@
@
@
R
c
q
q′

    	
In Set and in FinSet, pushouts are constructed as a combination of
a disjoint union and a quotient. Let f : a →b and g : a →c be a pair of
functions and b ⊎c the disjoint union of b and c with injection functions
jb : b →b ⊎c and jc : c →b ⊎c. Deﬁne the relation ; by x ; y iﬀ
there is a z ∈a with jbf(z) = x and jcg(z) = y. Let d be the set of
equivalence classes of b ⊎c under the equivalence closure of ;. Then d
is the pushout object. We leave it as an exercise for the reader to prove
this.
Functional representations in ML of these coequalizers and pushouts
follow the pattern of initial objects and coproducts above:
type (’o,’a)Coequalizer =
’a * ’a -> (’o * ’a) * (’o * ’a -> ’a)
type (’o,’a)Pushout =
’a * ’a -> (’a * ’a) * (’a * ’a -> ’a)
Programs for coequalizers and pushouts in FinSet involve fairly in-
tricate recursions. We leave this until later when we can make use of
general constructions to calculate these colimits.
Exercise 1. Complete the construction of pushouts in Set and show
that this indeed constructs a pushout.
Despite the caveat above, you might try to write programs
which calculate, from ﬁrst principles, coequalizers and pushouts
in FinSet.
4.3
Computing colimits
We now turn to constructions of colimits showing how programs are de-
rived from categorical proofs. From the wide variety available we choose
several fairly simple constructions to illustrate the techniques involved.
We then present a program for constructing arbitrary ﬁnite colimits.
We start with a construction of ternary coproducts from binary co-
products. A ternary coproduct is a coproduct of three objects and is
deﬁned like the binary coproduct, only replacing two objects by three.

Proposition 1 A category with binary coproducts has ternary coprod-
ucts.
The proof is a typical diagram-chase establishing the inheritance of
universality:
Given objects a, b and c in a category which has binary coproducts
we can form the coproduct of these three objects as in the following
diagram:
a
b
c
a + b
(a + b) + c
f
g
k
h



A
A
AAK



A
A
A
A
A
A
A
AK
Before looking at universality, let us encode the construction in this
picture.
Suppose we are given a composition function comp in a category and
binary coproducts in it, that is a function b coprod taking two objects
and giving as result the coproduct object, the two arrows into it and the
universal part. The object (a + b) + c, and the three arrows to it, are
given by the expression:
let val (sumab,f,g),univab = b_coprod(a,b)
val (sumabc,k,h),univabc = b_coprod(sumab,c) in
(sumabc, comp(k,f), comp(k,g), h) end
We now show that this construction is universal. The universality
of the ternary coproduct is inherited from that of the binary coproducts
involved as follows: For any object d and arrows fa : a →d, fb : b →d
and fc : c →d, from the universality of the coproduct of a and b, there
is a unique arrow u : a + b →d such that uf = fa and ug = fb. Now we
have arrows u : a + b →d and fc : c →d. Thus, using the universality of
the coproduct of a + b and c, there is a unique arrow v : (a + b) + c →d
such that vk = u and vh = fc. This is pictured in the following diagram:

a
b
c
a + b
(a + b) + c
d
f
g
k
h
fa
fb
fc
u
v



A
A
AAK



A
A
A
A
A
A
A
AK
    

*

1
-
HHHHHH
j
Thus v satisﬁes v(kf) = fa, v(kg) = fb and vh = fc.
Moreover,
the uniqueness is inherited: If v′ satisﬁes these equations then, by the
uniqueness of u, we have v′k = u and so, by the uniqueness of v, v = v′.
As a program, this universality is a function taking an object d and
three arrows fa, fb and fc and yielding the arrow v.
It is deﬁned as
follows, using the universal parts univab of the coproduct a + b and
univabc of the coproduct (a + b) + c:
fn (d,fa,fb,fc) =>
let val u = univab(d,fa,fb) in
univabc(d,u,fc) end
We combine these two pieces of code into a function extending binary
coproducts to ternary coproducts. A ternary coproduct in a category
with objects of type ’o and arrows of type ’a has type:
’o * ’o * ’o ->
(’o * ’a * ’a * ’a) * (’o * ’a * ’a * ’a -> ’a)
The function is deﬁned as follows:
fun ternary_coprod(C,b_coprod) =
{ arguments are a category and a coproduct }
fn (a,b,c) =>
let val ((sumab,f,g),univab)
= b_coprod(a,b)
val ((sumabc,k,h),univabc) = b_coprod(sumab,c)
val univ =
fn (d,fa,fb,fc) =>
let val u = univab(d,fa,fb)
univabc(d,u,fc)
end
in
( (sumabc,compose(C)(k,f),compose(C)(k,g),h),
univ)
end

Notice the functionality of this colimit computation. It takes as argu-
ment a category together with a binary coproduct in the category. It is
in this sense that categorical code is ‘data independent’. We may supply
the category of ﬁnite sets to produce an operation on sets or, say, the
category of ﬁnite graphs to produce an operation on graphs.
Exercise 2. The ternary coproduct can also be computed as a+(b+c).
Write the associated program. Moreover, there is an isomorphism
between a+(b+c) and (a+b)+c. Write a program which uses the
universality to compute this isomorphism as a (mutually inverse)
pair of arrows.
Exercise 3. We can do better than this – any category with an initial
object and binary coproducts has all ﬁnite coproducts. Prove this
and write the corresponding iterative program.
We consider a more interesting construction of colimits – the ‘pasting-
together’ of pushout squares.
Proposition 2 In the diagram below, if the two squares are pushouts,
then so is the outer rectangle:
g
p
f
q
p′
h
q′
a
c
b
c′
d
b′
?
-
?
-
-
?
-
A pushout square in a category with arrows of type ’a consists of
four arrows (the square) and a universal property (a function) and has
type:
(’a * ’a * ’a * ’a) * (’a * ’a -> ’a)
From two pushout squares of this type ((f,g,p,q),univfg) and
((h,q,p’,q’),univhq) in a category C, we construct the new square as
the outer rectangle, which is:
(compose(C)(h,f),g,compose(C)(p’,p),q’)

The universality of the outer rectangle is established as follows. Let
r : b′ →d′ and s : c →d′ such that rhf = sg. Then, since p, q is the
pushout of f, g, there is a unique arrow u : c′ →d′ such that uq = rh
and up = s.
Now, since uq = rh, by the universality of the second
square, there is a unique v : d →d′ with vp′ = u and vq′ = r. Hence
vp′p = up = s and vq′ = r. This is pictured below.
g
p
f
q
p′
h
q′
a
c
b
c′
d
b′
d′
s
u
v
r
?
-
?
-
-
?
-
PPPPPPPPPPPPPPPPPPPPPPPP
q
HHHHHHHHHHHHHHH
j
@
@
@
@
@
@
@
@
R
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
AU
For the uniqueness of v satisfying these conditions, suppose that v′
satisﬁes v′p′p = s and v′q′ = r. Then, by the uniqueness of u, u = v′p′,
and so, by the uniqueness of v, v = v′.
Expressing this universality as a function we get the following:
fn (r,s) =>
let val u = univfg(compose(C)(r,h),s) in
univhq(r,u)
end
Combining this with the pushout square above, we get a function to
compose pushout squares:
fun compose_squares(C)( ((f,g,p,q),univfg),
((h,q,p’,q’),univhq) ) =
( (compose(C)(h,f),g,compose(C)(p’,p),q’),
fn (r,s) =>
let val u = univfg(compose(C)(r,h),s) in
univhq(r,u) end )
Exercise 4. Another operation on pushout squares is the coproduct.
Prove that if (f, g, p, q) and (f ′, g′, p′, q′) are pushout squares, then

so is (f + f ′, g + g′, p + p′, q + q′). Write a program for the con-
struction.
Exercise 5. Textbooks abound in constructions of colimits based upon
combining diagrams. Here is another:
Proposition 3 A category with binary coproducts and coequalizers
has pushouts.
The pushout of f : a →b and g : a →c is constructed as the
coequalizer of jbf and jcg where jb and jc is the coproduct of b and
c. Prove this and program up the construction. It can be used to
compute pushouts in FinSet.
4.4
Graphs, diagrams and colimits
Colimits are a generalization of the universally deﬁned concepts that we
have met so far. The generalization is based upon diagrams in a category.
We deﬁne diagrams and then the general concept of a colimit. We show
how these are represented as types in ML and then give a construction
of arbitrary ﬁnite colimits in a category.
Recall, from the previous chapter, the deﬁnitions of graphs and dia-
grams:
Deﬁnition 10 A graph is a pair N, E of sets (of nodes and edges)
together with a pair of mappings s, t : E →N called source and target
respectively.
We write f : a →b when f is in E and s(f) = a and
t(f) = b. A ﬁnite graph is one in which N and E are ﬁnite sets.
Deﬁnition 11 A diagram in a category A is a graph (N, E, s, t) (its
shape) and two functions f : N →Obj(A), g : E →Arrow(A) which
respect sources and targets in the following sense: For each edge e ∈E,
f(s(e)) = sA(g(e)) and f(t(e)) = tA(g(e)), where sA and tA are source
and target of arrows in A.
For diagram ∆, we denote by ∆n, the object at node n, and by ∆e,
the arrow at edge e.
Finite graphs and diagrams may be directly represented as types:
datatype Graph = graph of (Node Set)*(Edge Set)*
(Edge->Node)*(Edge->Node)
datatype (’o,’a)Diagram =
diagram of Graph*(Node->’o)*(Edge->’a)

Here Set is the type constructor for ﬁnite sets and Node and Edge
are names which may be strings of characters or integers, or whatever.
To link objects with diagrams, we introduce cocones (also called
‘cones from a diagram’):
Deﬁnition 12 A cocone in a category on a diagram ∆(the base) is
an object a (the apex) together with, for each node n in ∆, an arrow
ξn : ∆n →a such that for all edges e : m →n in ∆the following
commutes.
a
∆m
∆n
ξm
∆e
ξn
-




A
A
A
AAK
A cocone consists of three components, an apex, a base and a family
of arrows indexed by the nodes in the diagram. All this is expressed as
an ML type:
datatype (’o,’a)CoCone =
cocone of ’o * (’o,’a)Diagram * (Node->’a)
In keeping with the categorical dictum of deﬁning arrows as well as
structures, we deﬁne arrows between cocones on the same base. A more
general arrow which allows maps between bases is possible but is not
needed here.
Deﬁnition 13 A cocone arrow on diagram ∆from cocone ξn : ∆n →a
on ∆to cocone ξ′
n : ∆n →a′ is an arrow f : a →a′ such that for all
nodes n in ∆the triangle below commutes.
a
a′
∆n
f
ξn
ξ′
n
-
A
A
A
AK




As a type in ML, this becomes:
datatype (’o,’a)CoCone_Arrow =
cocone_arrow of (’o,’a)CoCone * ’a * (’o,’a)CoCone

Colimits are deﬁned to be universal cocones in that there is a unique
cocone arrow to any cocone on the same base:
Deﬁnition 14 A colimit of a diagram ∆is a cocone, L, on ∆such that
for any cocone on ∆, K, there is a unique cocone arrow u : L →K.
We represent this as an ML type:
type (’o,’a)Colimiting_CoCone =
(’o,’a)CoCone * ((’o,’a)CoCone -> (’o,’a)CoCone_Arrow)
type (’o,’a)Colimit =
(’o,’a)Diagram -> (’o,’a)Colimiting_CoCone
The universality of colimits can be described by saying that colimits
are initial cocones in the category of cocones.
This is an example of
the interdeﬁnability of universal concepts in category theory and means
that we could use the type of initial objects to provide an (equivalent)
representation of colimits.
Deﬁnition 15 A category having colimits of all (ﬁnite) diagrams is said
to be (ﬁnitely) cocomplete.
As a type, a cocomplete category is a category together with a colimit
computing function:
datatype (’o,’a)CoComplete_Cat =
cocomplete_cat of (’o,’a)Cat * (’o,’a)Colimit
Functors which preserve colimits are called cocontinuous – they pre-
serve not just the apex of the colimiting cocone but the whole colimiting
cocone.
Deﬁnition 16 A functor F : A →B is (ﬁnitely) cocontinuous if, when
ξn : ∆n →a is a colimiting cocone of a (ﬁnite) diagram ∆in A, then
F(ξn) : F(∆n) →F(a) is a colimiting cocone of F(∆) in B.
As a type, a cocontinuous functor is a functor together with a map
between colimiting cocones:
datatype (’oA,’aA,’oB,’aB)CoContinuous_Functor =
cocontinuous_functor of
(’oA,’aA,’oB,’aB)Functor *
((’oA,’aA)Colimiting_CoCone ->
(’oB,’aB)Colimiting_CoCone)

There is an alternative treatment of diagram as functors rather than
as new structures. A diagram ∆in category C on graph A is equivalent
to a functor F : A →C where A is the transitive, reﬂexive closure of
graph A (called the path category of A). The correspondence is given by
F(a) = ∆a on nodes of A, and F(f1.f2 . . . fn) = ∆fn . . . ∆f2∆f1 on paths
in A. Replacing diagrams by functors, means that fewer concepts need be
considered as primitive in category theory and allows certain construc-
tions to be concisely expressed, therefore giving compact code. However,
the inclusion of the path category in the representation makes it rather
ineﬃcient in terms of storage. Ideally, program abstraction should make
the choice immaterial for subsequent code.
This requires an abstract
description of diagrams and colimits. We consider the mathematics of
this in the next chapter.
Exercise 6. The initial object is a special case of a colimit, being the
colimit on the empty diagram. Prove this and write a program
converting initial objects into colimits. Likewise, binary coproducts
are colimits of two object diagrams, coequalizers are colimits of
parallel pairs and pushouts are colimits of pushout diagrams (pairs
of arrows with common source).
Exercise 7. Both identity functors and isomorphisms are cocontinuous.
Isomorphisms are pairs of mutually inverse functors. Write expres-
sions of the type of cocontinuous functors for these two cases.
Exercise 8. A functor F : A →B may be applied to a diagram ∆in
A to yield a diagram F(∆) in B by applying F to the objects and
arrows of ∆. Likewise, functors may be applied to cocones. Write
these two application functions.
4.5
A general construction of colimits
We have already seen how constructive proofs in category theory give
rise to programs. We have also looked at some colimit constructions. In
this section we present a theorem which guarantees ﬁnite cocompleteness
of some categories. Its proof provides a function for calculating arbitrary
ﬁnite colimits in a category.
The following theorem, which Manes [1976] describes as ‘quite re-
markable’, is our starting point.
Theorem 1 A category having an initial object, binary coproducts and
coequalizers of parallel pairs of arrows has all ﬁnite colimits.

This theorem asserts that if certain simple colimits exist in a category
then so do colimits of arbitrarily complex ﬁnite diagrams. We look at
the proof in detail and present the corresponding program.
Proof
The proof is in two parts.
The ﬁrst part constructs arbitrary ﬁnite
coproducts (that is, colimits of discrete diagrams, those containing no
edges). In the second part, we take account of edges in the diagram,
using coequalizers.
Lemma 1 A category C having an initial object and binary coproducts
has all ﬁnite coproducts.
This is proven by induction on the number of nodes in the diagram.
If ∆is a discrete diagram in C then either:
1. ∆is empty, in which case the coproduct is the initial object; or
2. ∆is non-empty. Let n be a node in ∆and let ∆′ be the diagram
∆without node n. Assume inductively that ∆′ has a coproduct
ξj : ∆j →a for j ∈nodes(∆′). Let the binary coproduct of objects
a and ∆n be f : a →b and g : ∆n →b.
Construct a cocone
on ∆, νj : ∆j →b for j ∈nodes(∆), by νn = g and νj = fξj
otherwise. This is a coproduct of ∆, for suppose ν′
j : ∆j →b′ for
j ∈nodes(∆) is a cocone on ∆then it is a cocone on ∆′ and thus,
by universality of ξj, there is a unique arrow u : a →b′ such that
for all j ∈nodes(∆′) the diagram below commutes:
a
b′
∆j
u
ξj
ν′
j
-
A
A
A
AK




Now by universality of the binary coproduct, the two arrows u :
a →b′ and ν′
n : ∆n →b′ determine a unique arrow v : b →b′ such
that the diagram below commutes.

a
b
b′
f
u
v
-
?
@
@
@
@
R
∆n
g
ν′
n

    	
The two previous diagrams show that v : b →b′ makes the diagram
below commute for each j ∈nodes(∆). The uniqueness conditions
of u and v ensure that v is the only such arrow:
b
b′
∆j
v
νj
ν′
j
-
A
A
A
AK




This proves Lemma 1.
2
Before progressing to the second part of the proof let us encode this
construction of ﬁnite coproducts. To do this we need a category C and
an initial object init and binary coproducts b coprod in the category.
The function derived from this proof then takes a discrete diagram (or,
equivalently, a multiset of objects) and returns its colimit and hence has
type:
finite_coproduct:
(’o,’a)Cat * (’o,’a)Initial_Obj * (’o,’a)Coproduct ->
((’o,’a)Diagram -> (’o,’a)Colimiting_CoCone)
In the case when the diagram in the category C is empty, we use
the initial object init to construct a colimit of the empty diagram
nil diagram as in the following expression:
let val (i,i_univ) = init
val i_cocone = cocone(i,nil_diagram,nil_fn)
{ initial object as apex and an empty base }
in (i_cocone,
fn c1 =>
cocone_arrow(i_cocone,i_univ(co_apex c1),c1)) end
For the case of the non-empty diagram D we follow the proof above
using the binary coproduct function b coprod and a recursive call to the
function finite coproduct:

let val (n,N1) = singleton_split(nodes(D))
{ first extract node n from the set of nodes }
val (c,univc) =
finite_coproduct(C,init,b_coprod)
(reduce_diagram(D,n))
{ compute the colimit of remaining diagram }
val ((b,f,g),univcp) =
b_coprod(co_apex(c),obj_at_node(D)(n))
{ this is the binary coproduct }
val result_cocone =
cocone(b,d,fn m => if m=n then g
else compose(C)(f,sides(c)(m)))
{ the universal part }
val universal =
fn c1 =>
let val u = co_apex_arrow(univc(c1))
val v =
univcp(co_apex(c1),u,sides(c1)(n))
in cocone_arrow(result_cocone,v,c1)
end
in (result_cocone,universal)
end
Now for the second part of the proof – constructing ﬁnite colimits
from ﬁnite coproducts and coequalizers using coequalizers to account for
the edges in the diagram.
Lemma 2 A category C having ﬁnite coproducts and coequalizers of par-
allel pairs of arrows has all ﬁnite colimits.
Again proven by induction. If ∆is a ﬁnite diagram in C then either:
1. ∆is discrete (no edges) in which case the colimit is the coproduct;
or
2. ∆has edges. Let e : p →q be an edge of ∆with associated arrow
f : ∆p →∆q and let ∆′ be ∆without edge e. Assume inductively
that ∆′ has a colimit ξn : ∆n →a. Consider now the parallel pair
of arrows ξp, ξqf : ∆p →a. Let the coequalizer be h : a →b.

a
∆p
∆q
ξp
f
ξq
b
h
-




A
A
A
AK
6
Construct a cocone on diagram ∆, νn : ∆n →b for n ∈nodes(∆),
by νn = hξn. We show it is colimiting. Let ν′
n : ∆n →b′ be a
cocone on ∆. It is a cocone on ∆′ and so, by the universality of ξn,
there is a unique arrow u : a →b′ such that for all n ∈nodes(∆),
uξn = ν′
n Now, uξp = uξqf = ν′
p, hence, by the universality of the
coequalizer, there is a unique arrow v : b →b′ such that vh = u as
pictured:
a
∆p
∆q
ξp
f
ξq
b
h
-




A
A
A
AK
6
b′
ν′
p
ν′
q
u
v

3






1
HHHHH
j
Thus v satisﬁes, for each n ∈nodes(∆), the commuting triangle be-
low, where νn = hξn. It is the unique such arrow by the uniqueness
in the deﬁnition of u and v.
b
b′
∆n
v
νn
ν′
n
-
A
A
A
AK




This completes the proof.
2
To program the second part of the proof, we start with the coequaliz-
ing operation associated with each edge in a diagram. This transforms a
colimiting cocone (of the diagram minus the edge) to a colimiting cocone
(of the augmented diagram). The program follows the steps of the proof

and uses the same notation where possible.
add_edge : (’o,’a)Cat * (’o,’a)Coequalizer ->
((’o,’a)Colimiting_CoCone * Edge ->
(’o,’a)Colimiting_CoCone)
fun add_edge(C,coeq) ((c,univ),e) =
let val diagram(g,fo,fa) = base(c)
val graph(N,E,s,t) = g
{ extracting base and its shape }
val ((b,h),ce_univ) =
coeq(sides(c)(s(e)),
compose(C)(sides(c)(t(e)),fa(e)))
{ the coequalizing }
{ now assemble the new colimiting cocone }
val result_graph = graph(N,[e] U E,s,t)
val result_diagram =
diagram(result_graph,fo,fa)
val result_cocone =
cocone(b,
result_diagram,
fn n => compose(C)(h,sides(c)(n)))
{ the universal part }
val universal =
fn c1 =>
let val u = co_apex_arrow(univ(c1))
val v = ce_univ(co_apex(c1),u)
in cocone_arrow(result_cocone,v,c1) end
in (result_cocone,universal) end
Combining these two parts, we arrive at a function which computes
colimits of arbitrary ﬁnite diagrams:
finite_colimit : (’o,’a)IO_CP_CE_Cat -> (’o,’a)Colimit
It takes as argument a category together with the requisite colimits:
datatype (’o,’a)IO_CP_CE_Cat
=
io_cp_ce_cat of (’o,’a)Cat *
(’o,’a)InitialObj *
(’o,’a)Coproduct
*
(’o,’a)Coequalizer
Now for the deﬁnition of the function:

fun finite_colimit(cC as io_cp_ce(C,init,b_coprod,coeq))
(d as diagram(graph(N,E,s,t),fo,fa)) =
if is_empty(E)
then finite_coproduct(C,init,b_coprod)(d)
else let val (e,E1) = singleton_split(E)
val d1 = diagram(graph(N,E1,s,t),fo,fa)
in add_edge(C,coeq)((finite_colimit cC d1),e) end
Exercise 9. A category with coequalizers of parallel pairs of arrows has
coequalizers of any ﬁnite set of parallel arrows.
Prove this and
write the iterative function.
Exercise 10. Mac Lane [1971 page 109] gives an alternative proof of
the (dual of) ﬁnite cocompleteness of a category with initial ob-
ject, binary coproducts and coequalizers. It uses the coequalizing
operation only once. Look up this proof and encode it. Is it any
more eﬃcient?
4.6
Colimits in the category of ﬁnite sets
The category of ﬁnite sets FinSet is ﬁnitely cocomplete. This can be
proven by observing that FinSet has initial object, binary coproducts
and coequalizers and so, by Theorem 1, FinSet has all ﬁnite colimits.
To compute these colimits we need only supply these special colimits in
FinSet to the program derived from the proof of Theorem 1.
We have already programmed the initial object and binary coproducts
in FinSet. Coequalizers are not quite as straightforward. We present a
construction which is valid in any category and then use this as a basis
of a recursive algorithm for coequalizers in FinSet.
Proposition 4 In any category, if q : b →c is a coequalizer of the
parallel pair:
a
f
−→
−→
g
b
and r : c →d is a coequalizer of:

a′
b
b
c
f ′
g′
q
q
   
@
@
@
R
   
@
@
@
R
then the composite rq : b →d is a coequalizer of the following parallel
pair:
a + a′
[f,f′]
−→
−→
[g,g′]
b
This construction provides a recursive algorithm as follows: Decom-
pose the source of the parallel pair non-trivially as a coproduct, recur-
sively compute the coequalizers of the two parts then combine the results
as indicated in the proposition. In FinSet, decomposition as non-trivial
coproducts terminates.
To program coequalizers in FinSet we may either accumulate equiv-
alence classes or choose representative elements from equivalence classes.
We do the latter. The program itself is a case analysis: If the source set
of a parallel pair is empty, the coequalizer is the identity on the target;
if the source set is a singleton set, an explicit calculation is required,
testing if the image elements are the same or not. The remaining case is
the recursion.
fun set_coequalizer(set_arrow(s,f,b),set_arrow(_,g,_)) =
{ takes a parallel pair of set arrows }
let val cat(_,_,id,comp) = FinSet in
if is_empty(s) then
{ empty source - coeq is the identity }
((b, id(b)), fn (_,j) =>j)
else if cardinality(s) = 1 then
{ singleton source - see if image elements
are the same or different }
let val (y,_) = singleton_split(s) in
if f(y)=g(y)
then ((b,id(b)),fn (_,j) => j)
else
let val b’ = b diff (sing (g y))
fun ff(z) = if z=g(y) then f(y) else z

in ( (b’,set_arrow(b,ff,b’)),
fn (d’,set_arrow(_,j,_)) =>
set_arrow(b’,j,d’) ) end end
{ the recursive case - use the proposition }
else let val (a,a’) = split(s)
val ((_,q),univ) =
set_coequalizer(set_arrow(a,f,b),
set_arrow(a,g,b))
val ((d,r),univ’) =
set_coequalizer(comp(q,set_arrow(a’,f,b)),
comp(q,set_arrow(a’,g,b)))
in ((d,comp(r,q)),
fn (d’,j)=> univ’(d’,univ(d’,j))) end end end
To compute ﬁnite colimits in FinSet, call the general colimit function
of the previous section supplying the category of ﬁnite sets, an initial
object in this category, binary coproducts (all coded previously) and
coequalizers (above).
val io_cp_ce_FinSet =
io_cp_ce_cat(FinSet,set_initial,
set_coproduct,set_coequalizer)
val cocomplete_FinSet =
cocomplete_cat(FinSet,finite_colimit(io_cp_ce_FinSet))
Exercise 11. Prove Proposition 4 and encode the construction of co-
equalizers in terms of others in an arbitrary category. Remember
to include the universality of the construction.
4.7
A calculation of pushouts
We have produced some elaborate code but not yet shown it in action
calculating colimits.
As an example, let us calculate the pushout in
FinSet of the following diagram.
{B, E, F, G}
{C, D, E, F, G}
{A, B, C, D}
f = {A 7→C, B 7→C,
C 7→D, D 7→E}
g = {A 7→B, B 7→E,
C 7→B, D 7→F}



A
A
AAU
We ﬁrst encode this diagram in ML and then call the general colimit
routine specialized to the category FinSet.

A diagram is assembled from its underlying graph. For pushout dia-
grams this looks like:
"b"
"c"
"a"
"f"
"g"



A
A
AAU
val G = let val N = {word "a",word "b",word "c"}
val E = {word "f",word "g"}
fun src (word "f") = word "a"
| src (word "g") = word "a"
fun tgt (word "f") = word "b"
| tgt (word "g") = word "c"
in graph(N,E,src,tgt) end
A diagram is deﬁned by assigning sets to nodes and functions (set
arrows) to edges. The three sets are as follows.
val a_set = {just "A",just "B",just "C",just "D"}
val b_set = {just "C",just "D",just "E",just "F",just "G"}
val c_set = {just "B",just "E",just "F",just "G"}
The functions associated with edges f and g are deﬁned below:
fun f_fn (just "A") = just "C"
| f_fn (just "B") = just "C"
| f_fn (just "C") = just "D"
| f_fn (just "D") = just "E"
fun g_fn (just "A") = just "B"
| g_fn (just "B") = just "E"
| g_fn (just "C") = just "B"
| g_fn (just "D") = just "F"
Then the pushout diagram is given by the following expression:
fun nodes_to_sets (word "a") = a_set
| nodes_to_sets (word "b") = b_set
| nodes_to_sets (word "c") = c_set
fun edges_to_arrows (word "f") =
set_arrow(a_set,f_fn,b_set)
| edges_to_arrows (word "g") =
set_arrow(a_set,g_fn,c_set)
val po_diagram =
diagram(G,nodes_to_sets,edges_to_arrows)

The pushout is obtained as the value of the following expression:
let val cocomplete_cat(_,set_colimit) =
cocomplete_FinSet
in set_colimit(po_diagram) end
It is a cocone with a universal part. The apex of this cocone is calculated
to be the following set:
{ pink just "D", pink just "A", blue pink just "G",
blue pink just "F", blue blue pink just "G" }
Let us consider how this result was arrived at. The general construction
of colimits of arbitrary ﬁnite diagrams has been invoked.
This calls
upon initial object, coproduct and coequalizer of ﬁnite sets. Firstly, the
coproduct of the sets at the nodes in the diagram is accumulated starting
with the initial object (the empty set) and using the labels ‘blue’ and
‘pink’ to construct disjoint unions. Secondly, elements of the coproduct
are removed by two coequalizer operations, one for each of the edges in
the diagram.
The rest of the cocone has po diagram as base and the sides are
functions performing labelling and identiﬁcation. The side from node a
is a set arrow containing the following function:
fn just "A" => pink just "A" | just "B" => pink just "A"
| just "C" => pink just "A" | just "D" => pink just "D"
The function associated with node b is:
fn just "C" => pink just "A"
| just "D" => pink just "A"
| just "E" => pink just "D"
| just "F" => blue pink just "F"
| just "G" => blue pink just "G"
Finally, that associated with node c is:
fn just "B" => pink just "A" | just "E" => pink just "A"
| just "F" => pink just "D"
| just "G" => blue blue pink just "G"
As well as all this being calculated, there is the universal part taking
a cocone on po diagram to a cocone arrow. It is left to the reader to
work out what this function should be.

4.8
Duality and limits
Limits are dual to colimits – they are deﬁned by reversing arrows in the
deﬁnition of colimits.
Dual to initial objects are terminal objects, to
coproducts are products, to coequalizers are equalizers, and to pushouts
are pullbacks. Dual to cocones are cones and to colimits are limits.
We showed in the previous chapter how duality can be programmed
as an arrow-reversing operation on categories. We use this to calculate
limits in categories by calculating colimits in the dual category. Thus
the programs we have written are re-used to calculate limits.
In this section we introduce types for various limits, a duality opera-
tion converting colimits to limits, and a function for calculating limits of
ﬁnite diagrams. In the next section we put this to use to calculate ﬁnite
limits in FinSet.
Products, which are dual to coproducts, are deﬁned by:
Deﬁnition 17 A (binary) product of objects a and b in a category is an
object a × b together with arrows (called projection arrows) f : a × b →a
and g : a × b →b such that, for any object c′ and arrows f ′ : c′ →a and
g′ : c′ →b, there is a unique arrow u : c′ →a × b (denoted ⟨f ′, g′⟩) such
that the diagram below commutes.
a
a × b
c′
f
f ′
u

6
@
@
@
@
I
b
g
g′
-
    
Just as the coproduct operation extends to arrows, we may, by du-
ality, deﬁne the product f × g of arrows f : a →b and g : a′ →b′ as
⟨fπa, gπa′⟩: a × a′ →b × b′ where πa, πa′ are the product projections
from a × a′.
The representation of colimits in the previous section was phrased in
terms of the objects and arrows involved but not including the direction
of arrows, hence limits have the same type as the corresponding colimits.
Thus the type of products is given by:
type (’o,’a)Product =
’o*’o -> (’o*’a*’a) * (’o*’a*’a->’a)
The deﬁnitions of and type expressions for other limits are treated in the
same way.

The general concept of a limit is treated similarly. For the sake of
deﬁniteness, we introduce new types with constructors to indicate that,
for instance, cones diﬀer from cocones even though the functional types
in terms of objects and arrows are the same.
datatype (’o,’a)Cone =
cone of ’o * (’o,’a)Diagram * (Node->’a)
datatype (’o,’a)Cone_Arrow =
cone_arrow of (’o,’a)Cone * ’a * (’o,’a)Cone
type (’o,’a)Limiting_Cone =
(’o,’a)Cone * ((’o,’a)Cone->(’o,’a)Cone_Arrow)
type (’o,’a)Limit =
(’o,’a)Diagram -> (’o,’a)Limiting_Cone
datatype (’o,’a)Complete_Cat =
complete_cat of (’o,’a)Cat * (’o,’a)Limit
The following simple argument shows how colimit constructions con-
vert to limit constructions. The dual of a diagram is given by reversing
the edges of the underlying graph, giving a diagram in the dual category:
fun dual_graph(graph(N,E,s,t)) = graph(N,E,t,s)
fun dual_diagram(diagram(g,nm,em)) =
diagram(dual_graph(g),nm,em)
A colimiting cocone in a category dual(C) on diagram dual(∆) is a lim-
iting cone in C on ∆. Thus there is a function taking colimiting cocones
to limiting cones, deﬁned as follows:
fun dual_cone(cocone(a,D,f),univ) =
let val result_cone = cone(a,dual_diagram(D),f)
val universal =
fn (c1 as cone(a1,D1,f1)) =>
let val c2 = cocone(a1,dual_Diag D1,f1)
in cone_arrow( c1,
co_apex_arrow(univ c2),
result_cone) end
in (result_cone,universal) end
Suppose that F is a colimit, i.e. a function taking diagrams to col-
imiting cocones, then, by conjugation with the two functions above, we
have the corresponding limit as follows:

fun dual_colimit(F) =
fn D => dual_cone(F(dual_diagram D))
This then is the function which converts colimit calculations into limit
calculations.
We now return to Theorem 1 which asserted the cocompleteness of
certain categories. The dual says:
Theorem 2 A category having a terminal object, binary products and
equalizers of parallel pairs of arrows has all ﬁnite limits.
The proof is an appeal to duality. To use it to compute limits in category
C, proceed as follows. Calculate the terminal object, binary products and
equalizers of parallel pairs of arrows in C. These correspond, in the dual
category, to the initial object, binary coproducts and coequalizers. Apply
the general colimit extension function finite colimit to calculate ﬁnite
colimits in the dual category. Now use the above function dual colimit
to convert to limits in the original category. All this is captured in the
following expression which calculates ﬁnite limits in a category:
dual_colimit(finite_colimit(io_cp_ce_cat(dual(C),te,pr,eq)))
Exercise 12. Show that in FinSet the terminal object is a one element
set, products are cartesian products and equalizers are a subset
construction.
4.9
Limits in the category of ﬁnite sets
As explained above we use duality to compute limits. We apply this to
limits in FinSet. Firstly, we encode a terminal object (a one element
set), binary products (the cartesian product) and equalizers (a subset
construction). These are straightforward to encode as long as we ensure
that the type of elements is closed under the requisite operations: pair-
ing for products and a constant element (which we call ttrue) for the
terminal object. We extend the type of tagged values to include these
two operations:
datatype ’a Tag = ... | pair of (’a Tag)*(’a Tag) | ttrue
Below are programs for these three limits in the category of ﬁnite sets.

val set_terminal =
let val t = singleton_set(ttrue)
{ the terminal object is a one element set }
in (t, fn a => set_arrow(a,fn x => ttrue,t)) end
{ the universal part is a constant function }
fun set_product(a,b) =
let val a_cross_b = mapset(pair)(a X b)
{ the labelled cartesian product }
val proj_a =
set_arrow(a_cross_b,fn pair(y,z) => y ,a)
val proj_b =
set_arrow(a_cross_b,fn pair(y,z) => z ,b)
{ projections to first and second components }
val univ =
fn (p,f1,f2) =>
set_arrow( p,
fn y => pair(f1 OF y,f2 OF y),
a_cross_b )
{ universal part - pairing two functions }
in ((a_cross_b,proj_a,proj_b),univ) end
fun set_equalizer(f,g) =
let val a = source(FinSet)(f)
val e = a filtered_by (fn y => (f OF y)=(g OF y))
{ the equalizer object-a subset of the source }
in ((e,set_arrow(e,fn x => x,a)),
{ the equalizer object and an inclusion }
(fn (e1,h1)=>set_arrow(e1,fn y => h1 OF y,e))) end
{ the universal part }
We extend these special limits to limits of arbitrary ﬁnite diagrams in
FinSet using duality:
val complete_FinSet =
complete_cat( FinSet,
dual_colimit(finite_colimit(
io_cp_ce_cat( dual(FinSet),
set_terminal,
set_product,
set_equalizer))))

4.10
An application: operations on relations
In this section we show how to implement operations on relations using
limits and colimits.
A relation between elements in a set A and those in a set B is a subset
of A × B. There is a categorical notion of relations which is deﬁned in
any category and allows us to express operations for combining relations
as limits and colimits.
A span in a category C is an ordered pair of arrows with common
source:
a
b
r
f
g



A
A
AAU
A relation determines a span in Set: the projection functions from a
set of pairs is a span. In general, spans in Set correspond to multirela-
tions. Multirelations are bipartite multigraphs – relations in which there
may be more than one witness in r to a pair in a×b. If the sets a and b in
the span are the same, then the span is a graph – a directed multigraph.
Let C be a category with pullbacks. Consider two relations in C with
common intermediate object (f : r →a, g : r →b) and (f ′ : r′ →b, g′ :
r′ →c). We may form the pullback p, p′ of g with f ′ as depicted below:
a
b
c
r
r′
s
f
g f ′
g′
p
p′



A
A
AAU







A
A
AAU
A
A
A
AU
The join of the relations (f, g) with (f ′, g′), as introduced by Codd
[1970], is the ternary relation (fp, gp, g′p′). The composition (f ′, g′) ◦
(f, g) is the binary relation (fp, g′p′).
As an exercise, show that this
corresponds, in the category Set, to the standard composition of relations
deﬁned as follows: The composition of relation r ⊆a × b with s ⊆b × c
is the relation s ◦r deﬁned by
(x, z) ∈s ◦r
iﬀ
∃y : (x, y) ∈r and (y, z) ∈s.

Before seeing how the pullback deﬁnition of composition yields a pro-
gram, let us have a look at a straightforward program in which we repre-
sent relations as sets of pairs and use the above deﬁnition of composition.
We use the language SETL [Dewar 78] to express this as it has a construct
for iterating over sets:
PROGRAM composition
sr := NIL
LOOP (FORALL (x,z) IN axc) DO
LOOP (FORALL y IN b) DO
IF ((x,y) IN r) AND ((y,z) IN s) THEN
sr := sr WITH (x,z)
END IF
END LOOP
END LOOP
END PROGRAM composition
This program directly implements the deﬁnition of composition. It
is a nested pair of loops. Eﬃciency can be improved by exiting from the
inner loop once a suitable y is found.
The description of the composition in terms of a pullback gives the
following program in any ﬁnitely complete category.
fun relation_compose(cC)((f’,g’),(f,g)) =
let val complete_cat(C,_) = cC
val (p,p’),_ = pullback(cC)(g,f’) in
(compose(C)(f,p),compose(C)(g’,p’)) end
Notice that the program is linear – no repetitive constructs – we use
the recursion inherent in the pullback in the category cC. This is an
example of categorical primitives encapsulating iteration and recursion.
Notice also that, because it is parameterized over categories, there is an
implied generality to the code so that we may apply it to relations other
than those in FinSet. For instance, we may wish to impose structure
on the sets, and have relations preserving this structure.
To illustrate what is involved in a limit computation, let us run an
example in the category FinSet. We have already encoded ﬁnite limits
in FinSet. To make the description of relations as spans more succinct,
we introduce the conversion function from sets of pairs:

fun relation_span(a,r,b) =
{ r is a subset of a x b }
(set_arrow(r,fn pair(x,y) => x,a),
set_arrow(r,fn pair(x,y) => y,b))
Deﬁne two relations, r from a to b and s from b to c:
val a = {just(1),just(2)}
val b = {just(3),just(4),just(5)}
val c = {just(6),just(7)}
val r = relation_span( a,
{pair(just(1),just(3)),
pair(just(2),just(3)),
pair(just(2),just(4))},
b )
val s = relation_span( b,
{pair(just(3),just(6)),
pair(just(4),just(6)),
pair(just(4),just(7)),
pair(just(5),just(6))},
c )
As a set of pairs, the composition of r with s is {(1, 6), (2, 6), (2, 7)}.
As a span, the composition of the two relations is given by the expression
relation_compose(complete_FinSet)(r,s)
which has the following value:
let val r_o_s =
{pair(pair(just(1),just(3)),
pair(just(3),pair(pair(just(3),just(6)),ttrue))),
pair(pair(just(2),just(3)),
pair(just(3),pair(pair(just(3),just(6)),ttrue))),
pair(pair(just(2),just(4)),
pair(just(4),pair(pair(just(4),just(6)),ttrue))),
pair(pair(just(2),just(4)),
pair(just(4),pair(pair(just(4),just(7)),ttrue)))} in
( set_arrow( r_o_s,<function>,{just(1),just(2)} ),
set_arrow( r_o_s,<function>,{just(6),just(7)} ) ) end

To understand how it got this result, recall that pullbacks are con-
structed from terminal objects, binary products and equalizers. We have
encoded each of these for the category FinSet. The computation of the
pullback uses duality and the colimit extension program (from Theorem
1). It is computed as a product iterated over the nodes, beginning with
the terminal object {ttrue}. This explains the depth of nesting of pairs
and the presence of ttrue in the result. Following the iterated prod-
uct, an equalizer is computed for each of the two edges in the pullback
diagram. This extracts the relevant subset of the product. Notice that
there are four elements in the computed result where one would expect
only three. The reason for this is that spans correspond to multirelations
and there are two witnesses, the elements 3 and 4, to the pair (2, 6). A
factorization can be used to extract the relevant subset. The functions
in the above result can be applied to arguments to check that they are
indeed the correct projections.
Exercise 13. Intersection and union of relations Given two spans
from a to b, (f, g) and (f ′, g′), in a category C, consider the limit
(u : s →r, v : s →r′) of the diagram:
r
a
b
r′
f
g
g′
f ′
   
@
@
@
R
@
@
@
I
   	
This determines a span (fu, gu) – the intersection of the two spans.
Consider now the pushout of (u, v). Its universal property gives a
span from a to b – the union of the two spans.
Work through the details, showing how these operations in
FinSet correspond to the union and intersection of relations. Write
the relevant programs.
4.11
Exercises
Exercise 14. In the previous chapter we deﬁned a category TΩF in whose
arrows are term substitutions. Show that coproducts in TΩF in are
disjoint unions and express this as a program.

Exercise∗15. The interchange of colimits theorem can be found in
[Mac Lane 71], page 111. Write a program for this general col-
imit construction.


Chapter 5
Constructing Categories
So far we have managed to describe a few categories and to compute
ﬁnite limits and colimits in the category of ﬁnite sets. What about other
categories? Do we explicitly deﬁne each category that we are interested
in and then, if needed, laboriously encode limits and colimits?
Fortunately not: there are systematic ways of constructing categories
from other categories. When encoded as programs, these provide a means
of introducing categories without explicitly deﬁning them in terms of
objects, arrows and associated operations. Moreover, under certain cir-
cumstances, limits and colimits in the constructed category are inherited
from the constituent categories. In such cases, the inheritance itself is
a construction which may be used to calculate limits and colimits in
various categories.
Calculating limits and colimits is awkward for two reasons: the dia-
grams involved may be large and unwieldy and the objects and arrows
may themselves be complex structures. In the previous chapter we gave
an eﬀective way of building large diagrams from small pieces whilst ac-
cumulating the colimit at the same time. In this chapter, we show how
to separate the computation of colimits of complex objects into those of
simpler objects.
We begin with comma categories, showing how this construction of
categories is expressed as an ML program. We state and prove a theorem
establishing cocompleteness of certain comma categories. This provides
a program for computing colimits in these comma categories. We apply
this to computing colimits of graphs. We then turn to categories whose
objects are functors, showing how to compute colimits of diagrams of
functors. Duality allows us to re-use these colimit programs for com-
puting limits. This involves canonical isomorphisms linking duality and
103

constructions of categories. At the end of the chapter we present an ab-
stract formulation of colimits – an abstract type for arbitrary colimits.
This is prompted by the need for a uniﬁed treatment of representations
of colimits and our quest for generality of code.
5.1
Comma categories
Comma categories were introduced by Lawvere [1963] in the context of
the interdeﬁnability of the universal concepts of category theory. The
basic idea is the elevation of arrows of one category C to objects in
another.
The full generality can be obtained by taking a subclass of
arrows – those whose source is in the image of one functor L : A →C
and whose target is in the image of another functor R : B →C.
Deﬁnition 18 Let L : A →C and R : B →C be functors. The comma
category (L, R) has, as objects, triples of the form (a, f : L(a) →R(b), b)
where a is an object of A and b an object of B. An arrow in (L, R), from
(a, f, b) to (a′, f ′, b′) is a pair of arrows s : a →a′ and t : b →b′ such
that the following square commutes:
L(a)
L(a′)
R(b)
R(b′)
L(s)
f ′
f
R(t)
?
-
?
-
Composition is deﬁned componentwise, (s, t).(s′, t′) = (s.s′, t.t′) and
identities are pairs of identities.
Associated with comma categories are two projection functors:
left : (L, R) →A,
right : (L, R) →B
deﬁned by left(a, f, b) = a and left(s, t) = s and similarly for the functor
right.
Examples
An example of a comma category is the category of graphs.
Graphs
are ﬁnite, directed multigraphs, possibly with loops. Arrows of graphs

are pairs of functions, mapping edges to edges and nodes to nodes, and
preserving the source and target structure. This category is (isomorphic
to) the comma category (IFinSet, X) where X : FinSet →FinSet is the
functor X(a) = a × a and, on arrows, X(f) = f × f where (f × f)(x) =
(f(x), f(x)). An object of this comma category is a triple of the form
(E, f : E →N ×N, N). Letting E be the set of edges, N the set of nodes
and f the function allocating to each edge a pair of source and target
nodes, we see that these are graphs. Moreover, arrows in (IFinSet, X)
are graph arrows.
Another example of a comma category is that of signatures (many-
sorted operator domains). Categories of cones and of cocones are also
comma categories.
Comma categories arise through the operations of
labelling (e.g. labelled trees), indexing and adding distinguished points.
5.1.1
Representing comma categories
We show how the comma category construction can be expressed as an
ML program. Consider the comma category (L : A →C, R : B →C).
To deﬁne this as an ML value, we need the type of objects and arrows in
the category and the functions source, target, identity and composition.
Let ’oA be the type of the objects in A, ’aA the type of its arrows, and
similarly for the other categories. Objects in the comma category are
triples of the source and target objects and the arrow in category C,
and so have type: ’oA * ’aC * ’oB. Arrows in the comma category are
pairs of arrows of type (’aA*’aB) together with the source and target
objects:
datatype (’oA,’aA,’oC,’aC,’oB,’aB)Comma_Arrow
=
comma_arrow of (’oA*’aC*’oB)*(’aA*’aB)*(’oA*’aC*’oB)
We deﬁne the comma category as a construction taking two functors
and yielding a category:
fun comma_cat(L,R) =
let val A = domain(L)
val B = domain(R) in
cat( fn comma_arrow(Y,_,_) => Y,
fn comma_arrow(_,_,Y) => Y,
fn Z as (a,_,c) =>
comma_arrow(Z,(identity(A)(a),identity(B)(c)),Z),

fn ( comma_arrow(_,(f,g),Z),
comma_arrow(Y,(h,j),_) ) =>
comma_arrow( Y,
(compose(A)(f,h),compose(B)(g,j)),
Z ) ) end
To represent a particular comma category we need only deﬁne the
two functors involved. As an example, consider the category of graphs
deﬁned above. We need the functor X : a 7→a × a encoded as follows:
val X =
let fun prod(a,b) =
mapset(pair)(cartesian_prod(a,b)) in
ffunctor(FinSet,
fn a => prod(a,a),
fn set_arrow(a,f,b) =>
set_arrow( prod(a,a),
fn pair(x,y)=>pair(f(x),f(y)),
prod(b,b) ),
FinSet) end
The category of ﬁnite graphs is then the value of the following ex-
pression:
val cat_of_graphs = comma_cat(I(FinSet),cross_product)
Various special cases of comma categories can be deﬁned. For in-
stance, for a category C and object a of C, we can form the comma
category (IA, Ka) where Ka : 1 →C is the constant functor from the
one object, one arrow, category 1, returning object a of A. Objects in
this category are arrows into a. Arrows are commuting triangles. This
is called a slice category and is denoted C/a.
Exercise 1. An A-indexed set is a family of sets Si, i ∈A. Equivalently,
it is a function f : X →A. Show that these are equivalent (watch
disjointness) and use the second representation to express the cat-
egory of A-indexed sets as a comma category (a slice category).
Exercise 2. Cones and their arrows (on a ﬁxed diagram) form a comma
category. Show this and use this representation to deﬁne limits as
functors from a category of diagrams to the category of cones.
Exercise 3. The category of graphs deﬁned above has products (more
generally, has all ﬁnite limits and colimits). Write a program to
calculate products in this category.

5.2
Colimits in comma categories
The reader who attempted the last exercise, explicitly programming
products of graphs, will have noticed that extensive use is made of prod-
ucts of sets. The set of nodes of the product graph is the product of
the node-sets of the constituent graphs, likewise edges. Moreover, the
product graph is assembled using the universal property of the product
of sets.
This is part of a more general observation which gives a system-
atic method of calculating limits and colimits: Under certain circum-
stances, limits and colimits in comma categories are inherited from those
in the constituent categories. This is the import of the following theo-
rem, whose computational signiﬁcance was pointed out to us by Goguen,
see [Goguen, Burstall 84].
Theorem 3 Let L : A →C and R : B →C be functors with L (ﬁnitely)
cocontinuous.
If A and B are (ﬁnitely) cocomplete so is the comma
category (L, R).
Proof Let ∆be a (ﬁnite) diagram in (L, R). Denote the object at node
n ∈node(∆) by
∆n = (an, fn : L(an) →R(bn), bn).
The projection functors left and right applied to ∆give diagrams ∆A
and ∆B in categories A and B.
Let ξn : an →a,
n ∈node(∆) be
the colimit of ∆A in A and νn : bn →b, n ∈node(∆) be the colimit
of ∆B in B. Then R(νn)fn : L(an) →R(b), n ∈node(∆) is a cocone
on L(∆A).
The colimit of this diagram, by the cocontinuity of L, is
the cocone L(ξn) : L(an) →L(a), n ∈node(∆). Thus there is a unique
arrow f : L(a) →R(b) such that for all nodes n ∈nodes(∆) the following
commutes:
L(a)
L(an)
R(b)
R(bn)
L(ξn)
fn
f
R(νn)
6
-
6
-

It may be veriﬁed that
(ξn, νn) : ∆n →(a, f, b),
n ∈node(∆)
is a colimiting cocone on ∆with the universal property determined by
those of colimits ξn and νn.
2
Notice how the colimiting cocone is constructed from the universality
of colimits. To program this construction, we therefore need the univer-
sality as a component of the colimit structure. We have already made
this available, representing universality as a function.
The program derived from this construction takes as arguments two
functors L and R, colimits colimA in category A and colimB in B and
also the preservation property preserve of the the cocontinuous functor
L. The preservation property is a function taking colimiting cocones to
colimiting cocones. The result of the computation is a colimiting cocone
colim cocone of a diagram D in the comma category (L,R), calculated
as follows:
let val (c_A,univ_A)= colimA(apply_Fun_Diag(left(L,R),D)
val (c_B,univ_B)= colimB(apply_Fun_Diag(right(L,R),D)
{ colimits in A and B of projections of D }
val (Lc,Luniv) = preserve(c_A,univ_A)
{ colimiting cocone in C using cocontinuity }
val Rc = apply_Fun_CoCone(R,c_B)
val c1 =
cocone(co_apex(Rc),
base(Lc),
fn n =>
let val (_,f_n,_) =
obj_at_node(D)(n) in
compose(range(L))(sides(Rc)(n),f_n) end)
{ constructing new cocone in C from cocone Rc }
val f = co_apex_arrow(Luniv c1)
{ using universality to construct arrow }
val colim_obj = (co_apex(c_A),f,co_apex(c_B)) in
cocone(colim_obj,
D,
fn n =>
comma_arrow( obj_at_node(D)(n),
(sides(c_A)(n),sides(c_B)(n)),
colim_obj) ) end

The universal part of this cocone is a function taking a cocone in the
comma category and yielding a cocone arrow in the same category. It is
computed using the universality of the colimits in the categories A and
B.
fn c =>
let val uA =
co_apex_arrow(univ_A(apply_Fun_CoCone(left(L,R),c)))
val uB =
co_apex_arrow(univ_B(apply_Fun_CoCone(right(L,R),c)))
in cocone_arrow( colim_cocone,
comma_arrow( colim_obj,
(uA,uB),
co_apex(c) ),
c ) end
These two expressions combine to give a function lift colimit which
calculates colimits in comma categories:
fun cocomplete_comma_cat(cA,cB)
(cL as cocontinuous_functor(L,_),R) =
cocomplete_cat(comma_cat(L,R),lift_colimit(cA,cB)(cL,R))
5.3
Calculating colimits of graphs
Graphs, unlike sets, may not, in general, be decomposed as coproducts.
What is required for graphs is a decomposition which takes account of
shared subgraphs. Pushouts, rather than coproducts, provide a way of
constructing and decomposing graphs. The shared part is the common
source in a pushout diagram. More generally, decomposing objects with
internal structure involves shared sub-structure. The sharing can often
be described using arrows between sub-components. The decomposition
is then that of a colimit on the diagram of sub-components. Pushouts
have a special role, providing a semantics for parameter passing. This
was ﬁrst pointed out in the language Clear [Burstall, Goguen 80] and is
discussed in Chapter 9.
We use the above program to compute a pushout of graphs.
We
have shown how the category of graphs FinGraph is (isomorphic to)
the comma category (IFinSet, X) where X : a 7→a×a. The conditions of
the theorem are satisﬁed since FinSet is ﬁnitely cocomplete and identity

functors are cocontinuous. The ﬁnite cocompleteness of the category of
graphs is therefore given by the following expression:
val cocomplete_cat_of_graphs =
let val C = cocomplete_FinSet in
cocomplete_comma_cat(C,C)( cocontinuous_I(FinSet),
cross_product) end
Let us run an example of a pushout in FinGraph. We compute the
pushout of two graph arrows from the following graph, a graph,
A
C
B
E
F



A
A
AAU
to the graphs below.
B
A
C
E
G
F
D
H
b graph
-
-




A
A
A
AU
A
B
D
F
H
G
c graph
-




A
A
A
AU
Let the arrow from a graph to b graph be the inclusion and that
from a graph to c graph be deﬁned as follows. The map on nodes is
{A 7→B, B 7→A, C 7→B} and that on edges is {E 7→F, F 7→F}.
We ﬁrst deﬁne this diagram in FinGraph and then show the result
of the computation.
The shape of a pushout diagram is a span:
"b"
"c"
"a"
"f"
"g"



A
A
AAU
To deﬁne the diagram we assign graphs to nodes and graph arrows
to edges. The graph at node "a" is:
val a_graph =
let val Na = {just "A",just "B",just "C"}
val Ea = {just "E",just "F"} in

( Ea,
set_arrow(Ea,fn just "E" => pair(just "B",just "A")
| just "F" => pair(just "B",just "C"),
cross_product ofo Na),
Na ) end
The other graphs are deﬁned similarly. The graph arrow associated
with "f" is the inclusion, whilst that associated with "g" is expressed as
the following arrow in a comma category:
val g_arrow =
let fun gN_fn (just "A") = just "B"
| gN_fn (just "B") = just "A"
| gN_fn (just "C") = just "B"
fun gE_fn (just "E") = just "F"
| gE_fn (just "F") = just "F"
in comma_arrow( a_graph,
( set_arrow(edges(a_graph),
gE_fn,
edges(c_graph)),
set_arrow(nodes(a_graph),
gN_fn,
nodes(c_graph)) ),
c_graph ) end
The diagram is assembled as follows:
val D =
let fun nodes_to_objs (word "a") = a_graph
| nodes_to_objs (word "b") = b_graph
| nodes_to_objs (word "c") = c_graph
fun edges_to_arrows (word "f") = f_arrow
| edges_to_arrows (word "g") = g_arrow
in diagram(span,nodes_to_objs,edges_to_arrows) end
The computed value of the expression,
let val cocomplete_cat(_,graph_colimit) =
cocomplete_cat_of_graphs in graph_colimit(D) end
is a cocone and its universal property. The apex of the cocone is a graph
whose nodes are the following set:

{pink just "B", pink just "A",
blue pink just "D", blue blue pink just "D"}
The edges are as follows:
{pink just "E", blue pink just "H", blue pink just "G",
blue blue pink just "H", blue blue pink just "G"}
The sources and targets of these edges are deﬁned by the following
function.
fn pink just "E" =>
pair(pink just "B",pink just "A")
| blue pink just "H" =>
pair(pink just "B",blue pink just "D")
| blue pink just "G" =>
pair(pink just "A",pink just "A")
| blue blue pink just "H" =>
pair(pink just "A",blue blue pink just "D")
| blue blue pink just "G" =>
pair(pink just "B",blue blue pink just "D")
We draw this graph below (abbreviating the labels):
pB
pA
bbpD
pE
bbpH
bbpG
bpD
bpH
bpG
-
-




A
A
A
AU



-
How does it get the answer in this form? The program for the in-
heritance of colimits by comma categories is invoked.
This calls the
calculation of colimits in FinSet. These colimits are calculated using
the colimit extension function of the previous chapter and the code for
initial object, binary coproducts and coequalizers in FinSet. The set
of nodes and the set of edges of the pushout graph are both calculated
as pushouts in FinSet. Thus the labelling with ‘pink’ and ‘blue’ of the
disjoint union takes place as well as the selection of elements associated
with the coequalizing. The graph is assembled by deﬁning the source
and target of edges using the universality of the pushout of the edges.

As well as the pushout graph, the arrows into it from the diagram,
and the universality of the construction, are calculated. We leave it to
the reader to work out what these are.
5.4
Functor categories
The class of functors between two categories can be considered to be a
category by introducing arrows between functors called natural transfor-
mations. Natural transformations are functions which exhibit a form of
parametric polymorphism in which the uniformity of the deﬁnition over
diﬀerent objects is expressed by commuting diagrams.
We deﬁne natural transformations and functor categories and give
computational representations. We then consider calculating colimits in
functor categories much as we did for comma categories.
5.4.1
Natural transformations
We begin with a deﬁnition.
Deﬁnition 19 Let F, G : A →B be functors, a natural transformation
α : F →G is a function assigning to each object a of A an arrow of
B, α(a) : F(a) →G(a), such that, for every arrow f : a →a′ in A the
following square commutes.
F(a)
F(a′)
G(a)
G(a′)
F(f)
α(a′)
α(a)
G(f)
?
-
?
-
Examples
Consider the two functors X, I : Set →Set where X(a) = a × a and
similarly on arrows. There is a natural transformation δ : I →X deﬁned
for a set a as the function δ(a) = λx.(x, x). That this is natural means
that the following square commutes for any arrow f : a →a′:

a
a′
a × a
a′ × a′
f
δ(a′)
δ(a)
f × f
?
-
?
-
Polymorphic list processing functions provide examples of natural
transformations. There is a functor (−)∗: Set →Set taking a set to the
set of ﬁnite linear lists on the set, and operating as ‘maplist’ on arrows.
Consider the reverse function on lists rev(a) : a∗→a∗. It is a natural
transformation as the following square commutes for any f : a →b:
a∗
b∗
a∗
b∗
f ∗
rev(b)
rev(a)
f ∗
?
-
?
-
Let ba be the set of functions from set a to set b. The evaluation
function, eval : ba →a deﬁned simply as eval(h, a) = h(a) is natu-
ral, i.e.
deﬁnes a natural transformation, as it satisﬁes the equation
f(eval(h, x)) = eval(fh, x).
Adjunctions, introduced in the next chapter, provide a general setting
for these examples.
5.4.2
Functor categories
We deﬁne a composition of natural transformations so that they form
arrows in a category whose objects are functors. In fact, there are two
compositions of natural transformations:
1. Let F, G, H : A →B be functors and α : F →G and β : G →H
be natural transformations. Deﬁne the vertical composition, β.α,
by, for each object a of A:
(β.α)(a) = β(a)α(a)

2. Let F, F ′ : A →B and G, G′ : B →C be functors and α : F →
F ′ and β : G →G′ be natural transformations.
The horizon-
tal composition, β ◦α (or simply βα), is deﬁned to be, for each
object a of A, the diagonal of the following commuting square.
GF(a)
GF ′(a)
G′F(a)
G′F ′(a)
G(α(a))
β(F ′(a))
β(F(a))
G′(α(a))
?
-
?
-
The notation used for these two compositions should be noted.
There are identity natural transformations on each functor F, ιF ,
deﬁned by for each object a of A, ιF (a) = iF (a). Using identities, we de-
ﬁne compositions of functors with natural transformations. For example
Gα = ιGα.
Deﬁnition 20 The functor category from category A to category B,
BA, has functors from A to B as objects and natural transformations as
arrows. Composition is the vertical composition of natural transforma-
tions and identities are deﬁned above.
Examples
Categories of relations treated as spans form functor categories. Each
span in a category C is a functor from the ﬁnite category whose shape is
that of a span to the category C.
Considering graphs to be parallel pairs
of arrows, the category of graphs FinGraph is a functor category. Thus
graphs can be viewed not only as objects in a comma category but also
as functors. This gives an alternative treatment to that of the previous
section. Other examples of functor categories are categories of diagrams,
categories of algebras [Lawvere 63], the category of ‘sets through time’
and other time structures of temporal logic, as well as representations
of algebras (e.g. groups as permutations). Categories of functors ﬁnd
application in formalizing aspects of programming, e.g. the semantics of
block structure [Oles 85].

Representation
We now represent natural transformations as a type and the functor
category construction as a function. Natural transformations are triples
consisting of the source and target functors and a map from objects to
arrows:
datatype (’oA,’aA,’oB,’aB)Nat_transform =
nat_transform of (’oA,’aA,’oB,’aB)Functor *
(’oA->’aB) *
(’oA,’aA,’oB,’aB)Functor
The category of functors is a function taking a pair of categories and
returning a category:
fun id(A,cat(_,_,i,_)) F =
nat_transform(F,fn a => i(F ofo a) ,F)
fun dotcomp(A,cat(_,_,_,comp)) =
fn (nat_transform(_,beta,H),
nat_transform(F,alpha,_)) =>
nat_transform(F,fn a => comp(beta(a),alpha(a)),H)
fun ringcomp(cat(_,_,_,comp)) =
fn (nat_transform(G,beta,G’),
nat_transform(F,alpha,F’)) =>
nat_transform(G Fun_comp F,
fn a =>
comp(beta(F’ ofo a),G ofa alpha(a)),
G’ Fun_comp F’)
fun cat_of_functors(A,B) =
cat( fn nat_transform(s,_,_) => s,
fn nat_transform(_,_,t) => t,
id(A,B),
dotcomp(A,B) )
5.5
Colimits in functor categories
Colimits in functor categories are derived from those in the target cate-
gory. This is the import of the following theorem.
Theorem 4 If the category B is (ﬁnitely) cocomplete, then, for any cat-
egory A, the functor category BA is (ﬁnitely) cocomplete.

Proof The construction of colimits is pointwise. Let B be cocomplete
and ∆be a diagram in BA with object ∆n at n ∈node(∆).
Apply
diagram ∆to an object a of A to yield a diagram ∆(a) in B. Let the
colimit of ∆(a) be
ξn(a) : ∆n(a) →F(a),
n ∈node(∆).
We show that F is a functor and that for each n ∈node(∆) the map
ξn: ∆n →F is a natural transformation. Let f : a →a′ in A. Using
the universality of the colimit deﬁne F(f) : F(a) →F(a′) as the unique
arrow such that for all n ∈node(∆) the following square commutes:
F(a)
∆n(a)
F(a′)
∆n(a′)
ξn(a)
∆n(f)
F(f)
ξn(a′)
6
-
6
-
The cocone ξn : ∆n →F for n ∈node(∆) is colimiting, for let
νn : ∆n →G, n ∈node(∆) be a cocone on ∆then for any object a of
A, νn(a) : ∆n(a) →G(a), n ∈node(∆) is a cocone on ∆(a) and thus
there is a unique ν(a) : F(a) →G(a) such that, for all n ∈node(∆), the
following triangle commutes:
F(a)
G(a)
∆n(a)
ν(a)
ξn(a)
νn(a)
-
A
A
A
AK




It can be veriﬁed that ν : F →G is the unique natural transformation
required.
2
The derivation of a program from this proof is straightforward. We
exhibit a fragment of the program – the construction of the colimit object
of a diagram of functors. This object itself is a functor. The rest of the
construction of the colimit we leave as an exercise.
fun colimiting_functor( A as cat(s,t,_,_),
cB as cocomplete_cat(B,_))(D) =
{ take an object of A, apply the

diagram of functors and take colimit in B }
let val object_function =
fn a => colimit_object(cB)(applydo(A,B)(D,a))
{ the arrow part }
val arrow_function =
fn f =>
let val univ =
universal_part(cB)(applydo(A,B)(D,s(f)))
val tc =
colimit_cocone(cB)(applydo(A,B)(D,t(f)))
val c1 =
new_cocone(B)(applyda(A,B)(D,f),tc)
in co_apex_arrow(univ c1) end
in ffunctor(A,object_function,arrow_function,B) end
Here we use functions applydo and applyda, applying a diagram
of functors to an object and to an arrow respectively, and the function
new cocone taking a cocone and a diagram arrow into its base, and
producing a new cocone by composition.
5.6
Duality and limits
Limits in C are colimits in dual(C). Thus to compute limits in comma
categories, we compute colimits in the dual of comma categories. How
do we do this? The answer lies in the existence of isomorphisms which
express the interaction of duality with category constructions, as in the
following proposition:
Proposition 5 There is an isomorphism
ψ : dual(L, R) →(dual(R), dual(L))
satisfying the equations dual(left) = right.ψ and dual(right) = left.ψ.
We deﬁne this isomorphism as two, mutually-inverse, functors:
fun I1(L,R) =
let val object_fn = fn (c,f,a) => (a,f,c) in
ffunctor(comma_cat(dual_Fun(R),dual_Fun(L)),
object_fn,
fn comma_arrow(S,(mc,ma),T) =>
comma_arrow(object_fn(T),(ma,mc),object_fn(S)),
dual_Cat(comma_cat(L,R)) ) end

fun I2(L,R) =
let val object_fn = fn (a,f,c) => (c,f,a) in
ffunctor(dual_Cat(comma_cat(L,R)),
object_fn,
fn (comma_arrow(S,(ma,mc),T)) =>
comma_arrow(object_fn(T),(mc,ma),object_fn(S)),
comma_cat(dual_Fun(R),dual_Fun(L)) ) end
To compute colimits in the dual of a comma category, we compute
colimits in a comma category and transport them along an isomor-
phism.
Thus limits in comma categories can be computed from col-
imits in comma categories. To program this we use a simple function
iso colimit which takes an isomorphism of categories and yields a map
of colimiting cocones. The following expression computes limits in the
comma category (L,R) where R is ﬁnitely continuous.
{ first compute colimit in (dual(R),dual(L)) }
let val colim =
lift_colimit(dual_complete_Cat(cB),dual_complete_Cat(cA))
(dual_continuous_Fun(cR),dual_Fun(L)) in
{ apply iso to get colimit in dual(L,R) }
val iso_colim = iso_colimit(I1(L,R),I2(L,R))(colim)
{ then convert to a limit in (L,R) }
in dual_colimit(iso_colim) end
As an example, we give a program which computes limits of graphs.
Firstly, we need the ﬁnite continuity of the product functor X taking a
ﬁnite set a to a × a.
Exercise 4. Write a program expressing the product functor X : a 7→
a × a as a ﬁnitely continuous functor cts cross product i.e. show
how X preserves ﬁnite limits. This may be coded from ﬁrst princi-
ples or, alternatively, using a general result which says that functors
deﬁned in terms of limits are continuous.
To calculate limits of graphs use the following: (1) the ﬁnitely contin-
uous functor cts cross product, (2) the ﬁnite completeness of FinSet,
which we encoded in the previous chapter; and (3) the above limit inheri-
tance which is a function complete comma cat taking a pair of complete
categories and two functors, one of which is ﬁnitely continuous, and
yielding a complete comma category. Combining these, we get the ﬁnite
completeness of FinGraph:

val complete_cat_of_graphs =
let val cC = complete_FinSet in
complete_comma_cat(cC,cC)(I(FinSet),cts_cross_product) end
For limits in functor categories, use the following proposition and the
same method as for comma categories.
Proposition 6 There is an isomorphism
θ : dual(BA) →dual(B)dual(A)
Exercise 5. The isomorphisms linking duality and constructions of cat-
egories are canonical. There is a unique functor (which is an iso-
morphism) satisfying the conditions of the propositions and an
additional condition arising from the universal characterization of
comma categories and functor categories. Fill out the details and
prove this.
Exercise 6. Write a program to compute limits in functor categories.
5.7
Abstract colimits and limits∗
The reader may have noticed that, in the previous chapter, initial objects,
binary coproducts, coequalizers and ﬁnite colimits are all represented by
types of the same general form. The relevant observation from category
theory is that these concepts are all cases of a more general concept –
that of colimits – and by choosing the appropriate diagrams the special
colimits above can be realized.
Colimits are deﬁned in terms of representations – representations of
diagrams and of cocones. Since much of the manipulation associated with
colimits is independent of the representation of diagrams and cocones,
there is good reason for dispensing with the representation and providing
an abstract description: an abstract type for colimits. The faint-hearted
may complain that colimits are already abstract enough for their tastes!
However, this is more than a mathematical exercise: it will produce code
of added generality – provided it can be accommodated within the type
structure. For instance, the construction of colimits in comma categories
works equally well for initial objects and binary coproducts. Thus we
need to pass as argument to the code the relevant colimit structure – an
instance of the abstract type describing the colimits with which we are
concerned.

The abstraction which we deﬁne contains the functorial nature of the
construction of categories of diagrams and categories of cocones together
with the function which, given a cocone, yields its base. Colimits are de-
scribed as free objects. We call the structures abstract colimit structures.
In the following we consider the category Cat of categories as a 2-
category (deﬁned in Chapter 3, Exercise 7). This means that functors
Σ : Cat →Cat are 2-functors acting not only upon the objects (cate-
gories) and arrows (functors) but also upon the natural transformations
in such a way as to preserve identity and both compositions of natural
transformations. Moreover, a natural transformation between functors
on Cat, α : Σ →Σ′, respects natural transformations in Cat, γ : F →G,
where F, G : A →B, in that the following holds:
Σ′(γ)α(A) = α(A)Σ(γ)
The abstraction is phrased in terms of adjunctions. Those not fa-
miliar with adjunctions should turn to the next chapter, before reading
on.
5.7.1
Abstract diagrams and colimits
An abstract cocone structure consists of a pair of functors Γ, ∆: Cat →
Cat with a natural transformation β : Γ →∆. For each category C, call
∆(C) the category of diagrams (of ﬁxed shape) on C, Γ(C) the category
of cocones on C and β(C) the base functor.
If β : Γ →∆is a cocone structure, a colimit in category C of an
object d of category ∆(C) is a free object (γ, f : d →β(C)(γ)) on d with
respect to the functor β(C). A category C with such free objects for all
objects of ∆(C), i.e. such that there is a left adjoint H : ∆(C) →Γ(C)
to the functor β(C) : Γ(C) →∆(C) is called β-cocomplete.
A functor F : A →B is said to preserve the colimit of an object d
of ∆(A), (γ, f), if ((Γ(F))(γ), (∆(F))(f)) is a colimit of (∆(F))(d). A
functor preserving all existing colimits is called β-cocontinuous. For β-
cocomplete categories A and B, F : A →B being β-cocontinuous means
that the following is an arrow of adjunctions (see Chapter 6, Exercise 11,
for deﬁnition):
⟨Γ(F), ∆(F)⟩: (H, β(A), η) →(H′, β(B), η′)
An abstract colimit structure (β, H) on a category C is an abstract
cocone structure β : Γ →∆with H a left adjoint to β(C). Changing left
adjoint to right adjoint, the above treatment deﬁnes an abstract limit
structure.

5.7.2
Category constructions
Considering diagrams of a ﬁxed shape ∆: Cat →Cat and cocones on a
ﬁxed shaped base Γ : Cat →Cat we notice that for functors L : C →A
and R : C →B there are isomorphisms,
∆(L, R) ∼= (∆(L), ∆(R))
Γ(L, R) ∼= (Γ(L), Γ(R))
Moreover, a universal characterization of comma categories ensures
that these isomorphisms uniquely satisfy certain commutation condi-
tions. For the other constructions of categories that we have considered,
there are similar isomorphisms:
∆(A × B) ∼= ∆(A) × ∆(B)
∆(BA) ∼= ∆(B)A
(and likewise for Γ) which, again using universal characterization of
these constructions, uniquely satisfy certain commutation conditions.
For these isomorphisms to exist, it is essential that we ﬁx the shape
of the diagrams under consideration.
We now insist that cocone structures satisfy these additional ‘preser-
vation’ conditions so that we can formulate the construction of colimits
in comma, functor and product categories.
It may be of interest to see these isomorphisms in a general setting.
Consider a pair of functors Σ, Σ′ : Cat →Cat, then
• Deﬁne a construction on a category A to be a functor H : Σ(A) →
Σ′(A).
• Say an endofunctor F : A →A respects such a construction on A
iﬀthe following commutes to within an isomorphism.
Σ(A)
Σ′(A)
Σ(A)
Σ′(A)
H
Σ′(F)
Σ(F)
H
?
-
?
-

As an example, for the product of categories, take Σ to be the func-
tor such that Σ(C) = CT , T being the category of two objects and only
identity arrows. The functor Σ′ is the construction of the spanning cate-
gory. i.e. for each category C, Σ′(C) = CZ where Z is the ﬁnite category
below.
a
b
c
f
g



A
A
AAU
Let A = Cat (thus interpreting the above in a higher universe).
The functor H takes a pair of categories A and B to the product span
(first : A × B →A, second : A × B →B).
The existence of the
isomorphisms above can be restated as: both the diagram functor ∆and
the cocone functor Γ respect the product category construction.
Comma and functor categories ﬁt this framework in a similar manner.
5.7.3
Indexed colimit structures
The considerations above restrict us to diagrams of a ﬁxed shape and
cocones on bases of a ﬁxed shape.
This treatment may, however, be
extended to cover collections of colimits on variously shaped diagrams,
such as ﬁnite coproducts, ﬁnite colimits or ﬁltered colimits. Consider
a class G (of graphs) and a G-indexed collection of cocone structures
βg : Γg →∆g, g ∈G such that for each g ∈G the abstract cocone
structure respects the category constructions above.
A category C is
said to be G-cocomplete (with the cocone structures implicit) if, for each
g ∈G, the functor βg(C) : Γg(C) →∆g(C) has a left adjoint.
5.7.4
Discussion
The intention of the exercise was to capture enough of the behaviour of
diagrams, cocones and colimits to enable us to formulate the construc-
tion of colimits (and limits) in product categories, comma categories and
functor categories as well as proofs such as the cocontinuity of left ad-
joints and interchange of colimits. It may be veriﬁed that these proofs
can be expressed within the simple colimit structures deﬁned above.
Looking back over the code for colimits in comma and functor cate-
gories, we see that the abstract colimit structures contain just the aux-
iliary functions that occurred and therefore can be used to organize the
programs as well as to produce code of greater generality.

There are several aspects of colimits which have not been included
as they play no role in these proofs although they may well be needed
elsewhere and may then be added to the abstract structure. For instance,
the base of a colimit on a diagram d is itself d (i.e. β(C)H is an identity).
Moreover, arrows between diagrams of diﬀerent shapes, for which there
are several possible deﬁnitions, are not needed for the present purposes.
5.8
Exercises
Exercise 7. Product categories The product of categories A and B,
A×B, has as objects pairs of objects and as arrows, pairs of arrows.
Program up this construction and show how to compute limits and
colimits componentwise.
Exercise 8. Twisted arrow categories For any category C, we de-
ﬁne a category whose objects are arrows of C. Arrows in the cat-
egory from f : a →b to f ′ : a′ →b′ are pairs of arrows h : a →a′
and k : b′ →b such that the following square commutes:
a
b
a′
b′
f
k
h
f ′
?
-
?

Composition of arrows is (h, k).(h′, k′) = (hh′, k′k). Express this
construction as an ML program.
Exercise 9. Consider colimits in the comma category (Ka, IA) where
Ka is the constant functor returning object a of A. Objects in this
category are arrows out of a. This is a case not considered so far
(why?). Show that coproducts in this category can be constructed
as pushouts in A. Write the associated program.
Exercise∗10. Automata Non-deterministic ﬁnite automata are edge-
labelled graphs. These are objects in the comma category,
(Edges : FinGraph →FinSet, Ka : 1 →FinSet)

where Ka is the constant functor from the one object category
returning the set a of labels. Show this and compare colimits in this
category with constructions of non-deterministic ﬁnite automata
for recognizing regular expressions.
Deterministic ﬁnite automata are based on a transition function
of the form Q×A →Q where Q is the set of states and A the input
alphabet. These are examples of algebras, which we consider in the
next chapter. Colimits of deterministic automata require a more
complex construction than that of non-deterministic automata. A
suitable reference for this material is [Hopcroft, Ullman 79].
Exercise∗11. Graph grammars Graph grammars use pushouts in
assembling and matching graphs. If you are unfamiliar with this
material consult references (e.g. [Ehrig et al. 73]). Write programs
for the operations on graphs used in graph grammars.
Exercise∗12. Indexed categories An indexed category is a functor
F : C →Cat.
From this we may create a category G(F), the
opﬁbration induced by F, by what is known as the Grothendieck
construction:
• Objects of G(F) are pairs ⟨c, a⟩where c is an object of C and
a is an object of F(c).
• Arrows of G(F) are pairs ⟨f, g⟩: ⟨c, a⟩→⟨c′, a′⟩where f : c →
c′ in C and g : (F(f))(a) →a′ in F(c′).
• The composition of ⟨f, g⟩: ⟨c, a⟩→⟨c′, a′⟩with ⟨f ′, g′⟩:
⟨c′, a′⟩→⟨c′′, a′′⟩is given by
⟨f ′f : c →c′′, g.′(F(f ′))(g) : (F(f ′f))(a) →a′′⟩.
Many categories are of the form G(F). For instance, let C be (the
dual of) a category of theories and F allocate to each theory its
variety of algebras. Other examples: signatures indexed by their
sorts, theories (signatures and sets of equations) indexed by their
signatures, diagrams by their shape (underlying graph), cones by
their base (a diagram), etc. Notice how ‘dependent’ products arise
as objects and arrows of G(F).
What about colimits in G(F)? Establish the following:
Proposition 7 If C has (ﬁnite) colimits and, for each object c of
C, F(c) has (ﬁnite) colimits, and also, for each f : c →c′ in C,
F(f) preserves (ﬁnite) colimits, then G(F) has (ﬁnite) colimits.

Limits are not quite as straightforward. Establish:
Proposition 8 Suppose each functor F(f) has a right adjoint. If
C has (ﬁnite) limits and so do F(c) for each object c of C, then
G(F) has (ﬁnite) limits.
This exercise was suggested by a draft paper of A. Tarlecki
describing limit and colimit constructions in categories of the form
G(F).

Chapter 6
Adjunctions
Adjunctions, introduced by Kan in 1958, provide a descriptive frame-
work of great generality, capturing the essence of many canonical con-
structions.
They turn up throughout mathematics often as ‘closures’
and ‘completions’, and as ‘free’ and ‘generated’ structures. For example,
the transitive closure of a graph, the completion of a metric space, factor
commutator groups, and free algebras are all examples of adjunctions. In
categorical logic, quantiﬁers are interpreted as adjunctions with respect
to substitution of variables. The canonical nature of these constructions
is captured by universality. Indeed, adjunctions subsume the universal
concepts of previous chapters, both limits and colimits.
Adjunctions arise in the semantics of programming languages.
It
was the ‘ADJ’ group (J.A. Goguen, J.W. Thatcher, E.G. Wagner and
J.B. Wright) who showed that the the notion of a ‘data type’ involves
initial and free algebras. Relevant papers are [Goguen, Thatcher, Wag-
ner, Wright 77] and [Goguen, Thatcher, Wagner 78]. The construction
of free algebras as term algebras links syntax with semantics; values of
the data type are constructed as terms. Universality allows functions to
be deﬁned over the type. The dual notion, of cofreeness and terminal
algebras, arises in the semantics of systems with internal states and an
externally observed behaviour. For example, the minimal realization of
the behaviour of ﬁnite automata determines an adjunction, see [Goguen
73], [Arbib, Manes 74].
In this chapter we deﬁne adjunctions and represent them as an ML
type. Adjunctions are fairly complex structures and can be deﬁned in
several equivalent ways. We encode this equivalence as conversion func-
tions between representations. We look at some examples of adjunctions,
coding them as ML values. Moreover, we show how to compute with ad-
127

junctions, constructing continuous and cocontinuous functors.
At the end of the chapter, we present a categorical version of the
‘term’ or ‘word’ algebra construction of free algebras. This is an iterative
construction which we use to construct the transitive closure of a graph.
Another construction of adjunctions is provided by the adjoint functor
theorems of Freyd [1964]. These are used to establish the existence of
adjunctions. As programs for constructing adjunctions, they are of little
use because the ‘solution sets’ from which adjunctions are constructed
are necessarily ﬁnite.
6.1
Deﬁnitions of adjunctions
Adjunctions capture canonical constructions whereby objects of one kind
are constructed from those of another kind in a universal manner. There
are two categories involved in an adjunction, together with a pair of
functors, G : A →B and F : B →A. These functors are not inverse
to one another but satisfy a universal property linking their composite
with the identity.
We ﬁrst introduce the concept of a universal arrow and then deﬁne
adjunctions.
Deﬁnition 21 Let G : A →B be a functor and b be an object of B, a
universal arrow from b to G is a pair (a, u) with a an object of A and
u : b →G(a), such that, for any pair (a′, f : b →G(a′)), there is a unique
arrow f # : a →a′ such that the following triangle commutes:
b
G(a)
G(a′)
u
f
G(f #)
-
?
@
@
@
@
R
Deﬁnition 22 Let A and B be categories. An adjunction is deﬁned by
either of the following equivalent deﬁnitions.
1. A functor G : A →B and, for each object b of B, a universal
arrow from b to G.
2. Two functors F : B →A and G : A →B together with two
natural transformations η : IB →GF and ϵ : FG →IA such that
Gϵ.ηG = iG and ϵF.Fη = iF .

The functor F is called the left adjoint to G, and G the right adjoint to
F. The natural transformation η : IB →GF is the unit of the adjunction
and ϵ : FG →IA the co-unit.
We show how the second deﬁnition arises from the ﬁrst. Let b be an
object of B and (a, u) the corresponding universal arrow from b to G.
Deﬁne the action of functor F on objects by F : b 7→a. Let f : b →b′
in B and (a′, u′) be the universal arrow from b′ to G. Deﬁne F(f) =
(u′f)# : a →a′ using the universality of (a, u).
The unit and co-unit are deﬁned as follows. For b in B with universal
arrow (a, u) deﬁne the unit η(b) = u : b →G(F(b)). For the co-unit, let
(FG(a), u′) be the universal arrow from G(a) to G. Consider the pair
(G(a), iG(a) : G(a) →G(a)), and deﬁne ϵ(a) = iG(a)# : F(G(a)) →a.
The ﬁrst equation arises from the commutativity of the triangle:
G(a)
GFG(a)
G(a)
η(G(a))
=
G(ϵ(a))
-
?
@
@
@
@
R
The second equation arises from the uniqueness property of the uni-
versal arrow. It is a straightforward exercise to verify that F is a functor
and η and ϵ are natural transformations.
In the reverse direction, from the second deﬁnition to the ﬁrst, deﬁne
the universal arrow from b to G to be (F(b), η(b)).
This is universal
because, for any arrow f : b →G(a′), deﬁne f # = ϵ(a′)F(f) : F(b) →
a′. We denote an adjunction by ⟨F, G, η, ϵ⟩: B →A. Notice that an
adjunction deﬁnes a bijection between arrows:
b →G(a)
F(b) →a
The universality of adjunctions ensures that the right adjoint determines
the left adjoint to within an isomorphism and vice versa.
The conversion between a universal deﬁnition and an equational def-
inition is used to show the partial equational nature of many of the
concepts of category theory. It also gives an evaluation mechanism for
categorical expressions, treating the equations as rewrite rules.
This
arises in the categorical abstract machine [Curien 86] and in the cat-
egorical programming language of Hagino [1987], described in Chapter
10.

6.2
Representing adjunctions
Adjunctions are built from categories, functors, natural transformations
and universality. We have shown how to represent all of these as types in
ML. All that remains is to group them together to represent adjunctions.
The deﬁnition in terms of universal arrows gives the following type:
type (’oA,’aA,’oB,’aB)Universal_Arrow =
’oB -> ((’oA*’aB)*((’oA*’aB) -> ’aA))
datatype (’oA,’aA,’oB,’aB)Universal_Adj =
universal_adj of (’oA,’aA,’oB,’aB)Functor *
(’oA,’aA,’oB,’aB)Universal_Arrow
The deﬁnition in terms of two natural transformations gives the fol-
lowing type:
datatype (’oA,’aA,’oB,’aB)Adjunction
=
adjunction of (’oB,’aB,’oA,’aA)Functor *
(’oA,’aA,’oB,’aB)Functor *
(’oB,’aB,’oB,’aB)Nat_transform *
(’oA,’aA,’oA,’aA)Nat_transform
We write a program to convert from the ﬁrst deﬁnition, in terms
of universal arrows, to the second, in terms of natural transformations.
The equivalence is explained in the previous section; the translation into
a program is straightforward. We ﬁrst construct the left adjoint, and
then the two natural transformations:
fun left_adjoint(universal_adj(G,universal)) =
let val A = domain(G)
val B = range(G)
val obj_part =
fn b => let val ((a,_),_) = universal(b) in a end
val arrow_part =
fn f =>
let val (_,source_univ) = universal(source(B)(f))
val ((a,u),_)
= universal(target(B)(f))
in source_univ(a,compose(B)(u,f)) end
in ffunctor(B,obj_part,arrow_part,A) end

fun UA_to_ADJ(u_adj as universal_adj(G,universal)) =
let val A = domain(G)
val B = range(G)
val F = left_adjoint(u_adj)
val unit =
nat_transform
( I(B),
fn b =>
let val ((_,f),_) = universal(b) in f end,
G Fun_comp F )
val counit =
nat_transform
( F Fun_comp G,
fn a =>
let val (_,univ) = universal(G ofo a)
in univ(a,identity(B)(G ofo a)) end,
I(A) )
in adjunction(F,G,unit,counit) end
Exercise 1. The following is another deﬁnition of adjunctions, in terms
of a bijection between arrows. An adjunction is a pair of functors
F : B →A and G : A →B together with an isomorphism of
comma categories
J : (F, IA) →(IB, G)
such that ⟨left, right⟩J = ⟨left, right⟩. Prove that this is equivalent
to the previous deﬁnitions. By deﬁning an appropriate ML type,
program this equivalence.
6.3
Examples
Adjunctions arise in many areas of mathematics.
We begin with two
simple examples as tutorials explaining in detail how the components of
an adjunction arise. We then present the construction of free algebras as
‘term’ or ‘word’ algebras. Finally, to illustrate the wealth of constructions
which are adjunctions, we list some other examples.

6.3.1
Floor and ceiling functions: converting real numbers
to integers
Consider the two operations mapping real numbers to integers: r↓(called
‘ﬂoor’), the largest integer less than r (e.g. 3.14↓= 3), and r↑(called
‘ceiling’), the smallest integer greater than r (e.g.
3.14↑= 4). These
simple operations determine adjunctions.
Consider the case of the ceiling function r ↑.
The two categories
involved are int and real, that of integers and that of real numbers, both
as partial orders under the usual ≤partial order. Recall that a partial
order can be considered to be a category whose objects are elements of
the partially ordered set, and for which there is an arrow from x to y
just when x ≤y.
There is an inclusion functor, U : int →real. The ceiling function
is functorial↑: real →int, because r ≤r′ ⇒r↑≤r′↑. This functor is
left adjoint to U. First notice that r ≤U(r↑); this provides the unit
of the adjunction. The universality arises as follows. For any integer n,
with r ≤n, i.e. r ≤U(n) in real, we have that r↑≤n. This captures
the deﬁning characteristic of the ceiling function as the smallest integer
greater than r. The triangle required to commute does so automatically
in partial orders as there is at most one arrow between any two objects.
This example was brought to our attention by V. Pratt. Adjunctions
between partial orders are exactly Galois connections, see [Mac Lane 71].
Exercise 2. Show that the ﬂoor function r↓is right adjoint to U.
Exercise 3. Express the two adjunctions deﬁned by ‘ﬂoor’ and ‘ceiling’
as ML values. The representation of int and real can be drawn
from Exercise 3 in Chapter 3 where it is suggested that an arrow
m →n, for m ≤n, is represented by (m, n −m), or you may use
the pair (m, n).
6.3.2
Components of a graph
Many adjunctions arise in graph theory. We select a simple example as
an illustration, that of the components of a graph.
A semipath in a graph is a sequence of nodes, ni, 1 ≤i ≤N, such
that for each pair of consecutive nodes ni, ni+1, there is an edge from
ni to ni+1 or from ni+1 to ni.
Two nodes in a directed multigraph
are connected if there is a semipath linking them. A graph is said to be
connected if all pairs of nodes are connected. A connected component of a

graph is a maximal connected subgraph. Every graph can be expressed as
a (disjoint) union of its connected components. The connection relation
is the equivalence closure of the adjacency relation (two nodes being
adjacent when they are linked by an edge).
We show how the connected components determine an adjunction.
Denote a graph by (N, E, s, t), where N is the set of nodes, E the set
of edges and s and t are the source and target maps. Let S be a set.
We may form a graph from S, the discrete graph on S, as the graph
(S, S, λx.x, λx.x). This is functorial D : Set →Graph. Any function
f : S →S′, gives a graph arrow (f, f) : D(S) →D(S′).
We may label the nodes of a graph so that two nodes are in the
same connected component iﬀthey have the same label.
Let S be a
minimum set of labels, so that labels correspond exactly to components.
This determines a functor C : Graph →Set. The action on arrows is
deﬁned as follows. If (f, g) : G →G′, f acting on nodes, g on edges and
s is the component label of node n, then the image of s under C(f, g)
is the component label of f(n). This is well deﬁned as connected nodes
map, under a graph arrow, to connected nodes.
We show that C is left adjoint to D. The unit of the adjunction is a
graph arrow η(G) : G →DC(G) for each graph G. This is the function
labelling each node with its component label. Edges are mapped to the
unique edge on the node in the discrete graph.
The universal property of this construction arises as follows. Let S
be a set and (fN, fE) : G →D(S) be a graph arrow. There is a function
f : C(G) →S given by f(s) = fN(n) where n is in component s. Well-
deﬁnedness follows from the fact that (fN, fE) is a graph arrow and that
all elements of C(G) are component labels.
Finally, f is unique making the following commute:
G
D(C(G))
D(S)
η(G)
(fN, fE)
D(f)
-
?
@
@
@
@
R
That f makes it commute is the deﬁnition of f, that it is unique fol-
lows from the fact that η(G) does not map nodes in diﬀerent components
to the same label.
Informally, we may say that the existence part of the universality
corresponds to C(G) having ‘no junk’ (every element arises from a com-
ponent of G), and the uniqueness part corresponds to C(G) having ‘no

confusion’ (every element arises from a unique component of G). This
‘no junk, no confusion’ is characteristic of many adjunctions.
To program this adjunction for ﬁnite sets and graphs, we need to com-
pute the component functor C : FinGraph →FinSet. This requires
a little thought. A neat way of computing this is to use our categorical
programs. Recall that a graph can be interpreted as a parallel pair of
arrows in Set. Their coequalizer corresponds to the set of components.
We ﬁrst code the discrete graph functor:
val Discrete =
let fun discrete_graph(S) =
(S,S,identity_fn,identity_fn) in
functor(FinSet,
discrete_graph,
fn set_arrow(S,f,S’) =
(discrete_graph(S),(f,f),(discrete_graph(S’)),
FinGraph) end
Here is the adjunction determined by the components. The set of
components is the coequalizer of the source and target arrows. The unit
is the coequalizing arrow and the universality is that of the coequalizer.
val Components_Adj =
let val univ_arrow =
fn G as (N,E,s,t) =>
let val ((S,q),univ) =
coequalize(cocomplete_FinSet)
(set_arrow(E,s,N),set_arrow(E,t,N) in
((S,
(G,(q,compose(q,set_arrow(E,s,N))),Discrete ofo S)),
fn (S’,(_,(fe,fn),_)) =>
univ(set_arrow(N,fn,S’))) end) in
universal_adj(Discrete,univ_arrow)
None of this need be tied to the category of sets. In any category with
coequalizers, we can deﬁne graphs as parallel pairs and discrete graphs
as pairs of identity arrows and so construct the adjunction.
6.3.3
Free algebras
In Chapter 3, we considered some categories arising in universal alge-
bra. We now show how the construction of term algebras (often called

‘word’ algebras) determines an adjunction. As well as its role in uni-
versal algebra, this is a fundamental idea in the semantics of data types
and programming languages. We consider programs for this construction
later in the chapter.
Recall that an operator domain is a set of operator symbols indexed
by their arities (natural numbers). If Ωis an operator domain, denote
by Ωn the set of operators in Ωwhose arity is the natural number n.
The terms in a set X over an operator domain Ω, the set of which
we denote by TΩ(X), are syntactic objects deﬁned recursively by:
x ∈X ⇒⟨x⟩∈TΩ(X)
ρ ∈Ωn, t1, t2, . . . , tn ∈TΩ(X) ⇒ρ(t1, t2, . . . , tn) ∈TΩ(X)
We can consider TΩ(X) to be an Ω-algebra, by deﬁning the operations
syntactically. That is, for ρ ∈Ωn, the corresponding operation takes the
terms t1, t2, . . . , tn ∈TΩ(X) to the term ρ(t1, t2, . . . , tn). This algebra is
called the term algebra on X.
There is a functor U : AlgΩ→Set taking each algebra to its carrier
(its underlying set) and acting as identity on arrows. The construction
of the term algebra deﬁnes a left adjoint to U, namely F : Set →AlgΩ,
where F(X) is TΩ(X) considered as an algebra.
We describe this by
saying that the term algebra on X is a free algebra on X.
The universality arises as follows.
There is a function u : X →
U(TΩ(X)), given by u(x) = ⟨x⟩.
Now, for any Ω-algebra (A, α) and
function f : X →A, we deﬁne the homomorphism f # : TΩ(X) →(A, α)
recursively:
f #(⟨x⟩) = f(x) for x ∈X
f #(ρ(t1, t2, . . . , tn)) = ρ(f #(t1), f #(t2), . . . , f #(tn))
It is a homomorphism by the second clause of the deﬁnition. The ﬁrst
clause ensures that the following triangle commutes:
X
U(TΩ(X))
A
u
f
U(f #)
-
?
@
@
@
@
R
These two clauses therefore uniquely deﬁne such a homomorphism.
In the case of algebras of equational theories, we construct free alge-
bras as quotients of term algebras as follows.

Let E be a set of Ω-equations. Deﬁne an equivalence relation ∼on
TΩ(X) by s ∼t iﬀE ⊢s = t, that is, we can prove, using equational
deduction from equations E, that s = t holds. Let TΩ(X)/E be the set of
equivalence classes of TΩ(X) under ∼. This is the carrier of an Ω-algebra
where we deﬁne the operations as follows:
ρ([t1], [t2], . . . , [tn]) = [ρ(t1, t2, . . . , tn)]
Here [t] denotes the equivalence class containing t. The operation is well
deﬁned by deﬁnition of the relation ∼.
A similar argument to that above shows that TΩ(X)/E is a free alge-
bra, i.e. determines a left adjoint to U : AlgT →Set where T = (Ω, E).
We consider two examples of the above constructions, natural num-
bers and ﬁnite powersets.
The natural numbers N = {0, 1, . . .} form an Ω-algebra where Ω
contains just a constant c and a unary operator f. We interpret c as
0 and f as the successor function λx . x + 1. The natural numbers are
identiﬁed with terms in TΩ(φ) where φ is the empty set and so forms a
free algebra. Free algebras on the empty set are initial objects in the
category AlgΩ.
As another example, let S be a set and F(S) denote the set of ﬁnite
subsets of S. We show that this forms a free semilattice. A semilattice is
an algebra with one binary operation that is associative, commutative,
absorptive and has an identity. F(S) forms a semilattice under the op-
eration ∪of union of sets. Its identity is the empty set. The equivalence
classes of terms in variables S are in 1-1 correspondence with ﬁnite sub-
sets of S. An equivalence class of a term t contains all bracketed versions
of t, all versions with the identity appearing, all permutations of the vari-
ables, and all multiplicities of variables. Therefore, all that is required to
identify an equivalence class is the ﬁnite set of variables occurring in the
term. An alternative proof that F(S) is a free semilattice can be given
by demonstrating the universality of F(S).
6.3.4
Graph theory
Here are some examples of adjunctions in graph theory:
• The transitive closure of a graph is the graph with the same nodes
but whose edges are paths in the original graph.
A path in a
graph is a (possibly empty) sequence of edges e1, e2, . . . , en, n >
0 such that t(ei) = s(ei+1), 0 < i < n, where s and t are the

source and target, respectively, of the edges. A path into a node
may be composed with one out of the node. Empty paths at each
node are identities of this composition so that the transitive closure
forms a category, the path category of the graph. The construction
is functorial, T : Graph →SmallCat where SmallCat is the
category whose objects are small categories (categories with a set
of objects and a set of arrows) and whose arrows are functors. The
functor T is left adjoint to the functor U : SmallCat →Graph
which returns the underlying graph of a category.
• Two nodes, m and n, in a graph are said to be strongly-connected
if there is a path from m to n and a path from n to m. A sub-
graph is strongly connected if each pair of nodes in it is strongly
connected. A strong component of a graph is a maximal strongly
connected subgraph.
The strong components of a graph them-
selves form an acyclic graph which is a quotient of the original
graph. This may be expressed as a left adjoint to the inclusion
functor AcyclicGraph →Graph where AcyclicGraph is the
full subcategory of Graph of acyclic graphs.
• Consider graphs whose edges have non-negative real numbers R+
assigned to them. The distance between two nodes is the shortest
path (in terms of the sum of the distances on edges in the path)
between the nodes. By allocating to each pair of nodes the dis-
tance between them (making it inﬁnite if there is no path between
them), we form a metric space from the graph. Two categories are
involved: (1) MetricSpace whose objects are metric spaces and
whose arrows f : ⟨S, d⟩→⟨S′, d′⟩satisfy d(m, n) ≥d′(f(m), f(n));
(2) LabelledGraph whose objects are graphs whose edges are
labelled with non-negative real numbers and whose arrows are
graph arrows ⟨fN, fE⟩: (N, E, s, t, λ) →(N ′, E′, s′, t′, λ′) where
λ : E →R+ and λ′ : E′ →R+ satisfying λ(e) ≥λ′(fE(e)).
There is a functor G : MetricSpace →LabelledGraph deﬁned
as follows. For any metric space ⟨S, d⟩, the graph G(⟨S, d⟩) has
elements of S as nodes, and has an edge from m to n just when
d(m, n) < ∞, the label being d(m, n). The construction of a metric
space from a graph by taking the minimum path distance between
nodes provides a left adjoint to G.

6.3.5
Limits and colimits
Both limits and colimits can be interpreted as adjunctions.
For example, the initial object in a category C is a left adjoint to the
constant functor T : C →1, where 1 is the category of one object and
an identity arrow. The unit of the adjunction is the identity in 1 and
the co-unit is the unique arrow from the initial object.
We can code this as a function converting initial objects to adjunc-
tions:
datatype UnitObj
= unitobj
datatype UnitArrow = unitarrow
val unitcat = cat (fn unitarrow => unitobj,
fn unitarrow => unitobj,
fn unitobj => unitarrow,
fn (unitarrow,unitarrow)=> unitarrow)
val T(C) = ffunctor( C,
fn c => unitobj,
fn f => unitarrow,
unitcat)
fun initial_adj(C,(init,init_univ)) =
universal_adj(T(C),
fn unitobj =>
((init,identity(unitcat)(unitobj)),
fn (c,_) => init_univ(c)))
As another example, the reader may like to show that binary co-
products are left adjoint to the diagonal functor ∆: C →C × C,
∆(a) = (a, a). The example of graph components (Example 5.3.2) shows
how coequalizers form an adjunction. Limits arise as right adjoints. For
example, products are right adjoint to ∆.
Exercise 4. General colimits in a category determine an adjunction be-
tween categories of diagrams and categories of cocones. Demon-
strate this and write a function which constructs an adjunction
from a (ﬁnitely) cocomplete category.
6.3.6
Adjunctions and comma categories
An important construction of an adjunction arises from slice categories,
a special case of comma categories.

Recall that, for category C and object a in C, C/a denotes the comma
category (IC, Ka), where Ka : 1 →C is the constant functor returning
the object a. Objects in C/a are arrows into a and arrows in C/a are
commuting triangles:
c
c′
a
g
f
f ′
-




A
A
A
AU
A function h : a →b deﬁnes a functor Σh : C/a →C/b by composi-
tion, taking f : c →a into hf : c →b.
When C has pullbacks, this functor has a right adjoint h# : C/b →
C/a deﬁned as follows. For object f : c →b, form the pullback:
c′
a
c
b
f ′
h
h′
f
?
-
?
-
Then h# : f 7→f ′. The universal property of pullbacks provides the
action on arrows.
Exercise 5. Complete the description of this adjunction and express it
as an ML program.
When C = Set, the category C/a is that of a-indexed sets.
Describe the functors Σh and h# in this case.
Exercise 6. When C has binary products, the functor Σa : C/a →C,
deﬁned by Σa : (f : c →a) 7→c, has a right adjoint ×a : C →C/a
mapping c to the projection π2 : c × a →a. Prove this and code
up the construction.
6.3.7
Examples from algebra and topology
Textbooks on category theory give many examples of adjunctions drawn
from algebra and topology. We list a few examples here.

In algebra, the factor commutator group is the free abelianization of
a group, i.e. is left adjoint to the inclusion functor of abelian groups in
Group. The ﬁeld of quotients of an integral domain is left adjoint to
the inclusion of ﬁelds in the category of integral domains (with monic
maps). Many other examples arise as freely generated structures.
In topology, the functor taking a topological space to its underlying
set has a left adjoint (the discrete topology on a set, all subsets are
open sets) and a right adjoint (the indiscrete topology, only the set itself
and the empty set are open sets). The Stone-ˇCech compactiﬁcation of a
topological space is left adjoint to the inclusion of compact spaces in the
category of all topological spaces.
6.4
Computing with adjunctions
We now look at a construction involving adjunctions and show how to
code it in ML. We start with a duality operation on adjunctions and
then look at a construction of continuous and cocontinuous functors from
adjunctions.
The dual of adjunction ⟨F, G, η, ϵ⟩: B →A is the adjunction
⟨dual(G), dual(F), ϵ, η⟩: dual(A) →dual(B).
fun dual_Adj(adjunction(F,G,unit,counit)) =
adjunction(dual_Fun(G),dual_Fun(F),counit,unit)
A useful property of adjunctions is contained in the next proposition.
Proposition 9 If ⟨F, G, η, ϵ⟩: A →B is an adjunction then F is co-
continuous and G is continuous.
Proof
We show that F is cocontinuous. Duality provides the other
half of the theorem. Let ∆be a diagram in A with objects ∆n at nodes
n ∈nodes(∆). Let the colimit of ∆be ξn : ∆n →a. We show that
F(ξn) : F(∆n) →F(a) is a colimit of F(∆) in B. Let νn : F(∆n) →b be
a cocone on F(∆) then G(νn)η(∆n) : ∆n →G(b) is a cocone on ∆and
so there is a unique v : a →G(b) such that the square below commutes
for all n ∈nodes(∆).

a
∆n
G(b)
G(F(∆n))
ξn
η(∆n)
v
G(νn)
6
-
6
-
Finally, by the deﬁnition of adjunctions, there is a unique v# =
ϵ(b)F(v) such that the following commutes.
F(a)
b
F(∆n)
v#
F(ξn)
νn
-
A
A
A
AK




This establishes the cocontinuity of the left adjoint.
2
The proof constructs cocontinuous functors from adjunctions.
We
express this construction in the program below, where the cocontinuity
is represented as a preservation function from colimits to colimits:
fun adj_cocontinuous(A as adjunction(F,G,eta,epsilon))=
{ the preservation of colimiting cocones }
let val preserve =
fn (c,u) =>
{ the cocone is the application of F }
let val result_cocone = apply_Fun_CoCone(F,c)
{ the universal part }
val universal =
fn c1 =>
let val c2 =
new_cocone(domain F)
( apply_Nat_Diag(eta,base(c)),
apply_Fun_CoCone(G,c1))
val v = co_apex_arrow(u c2)
val (_,v_sharp,_) =
sharp(A) ofo (co_apex(c),v,co_apex(c1))
in cocone_arrow(result_cocone,v_sharp,c1) end
in (result_cocone,universal) end
in cocontinuous_functor(F,preserve) end

The function new cocone takes a cocone ξn : ∆′
n →a on diagram ∆′ and
a diagram arrow δ : ∆→∆′ and returns the cocone ξnδn : ∆n →a.
Duality, which allows us to state that the right adjoint is continuous,
can be coded using the above program and conversion functions:
fun adj_continuous(adj) =
dual_CoCon_Fun(adj_cocontinuous(dual_Adj(adj)))
The dual of an adjunction is deﬁned above. The fact that the dual of a
cocontinuous functor is a continuous functor can be similarly encoded.
6.5
Free algebras
In Section 6.3.3 we described a construction of free algebras as term al-
gebras. The construction is iterative, building terms of increasing depth.
There is a categorical generalization of this construction which we now
present. The generalization allows us to move away from algebras whose
carriers are in Set to other categories.
To do so we replace operator
domains by functors and represent algebras as arrows corresponding to
the evaluation of terms.
An algebra of a functor F : C →C is an object a of C and an arrow
f : F(a) →a. An arrow between algebras h : (a, f) →(a′, f ′) is an arrow
h : a →a′ such that the following square commutes.
F(a)
a
F(a′)
a′
f
h
F(h)
f ′
?
-
?
-
The category of F-algebras with these arrows we denote by (F : C).
The carrier a of algebra (a, f) determines a functor U : (F : C) →C. In
the next section we show how to construct a left adjoint to U, i.e. free
F-algebras.
Example
An operator domain Ωdetermines a functor F : Set →Set deﬁned by
F(X) = {ρ(x1, x2, . . . , xn)|n ∈N, ρ ∈Ωn, xi ∈X, 1 ≤i ≤n}.

Thus F(X) is the set of terms of depth 1 in X. An Ω-algebra (A, α)
determines a function f : F(A) →A by
f(ρ(a1, a2, . . . , an)) = αρ(a1, a2, . . . , an).
There is another functor associated with an operator domain F ′ : Set →
Set, F ′(X) = X ∪F(X), terms of depth at most 1 in X.
There is
an inclusion X →F ′(X) and again an Ω-algebra (A, α) determines a
function F ′(A) →A. The term algebra TΩ(X) (see Section 6.3.3) is a
free F-algebra on set X (and also a free F ′-algebra).
6.5.1
Constructing free algebras
We now look at some iterative constructions of free F-algebras. There
has been extensive study of such constructions, including transﬁnite it-
erations, and their application, for instance to constructing colimits of
algebras. The following publications illustrate this material: [Barr 70],
[Schubert 72], [Dubuc 74], [Manes 76], [Ad´amek, Trnkova 78], [Ad´amek
77,78], [Ad´amek, Koubek 80] and [Barr, Wells 85].
There are various constructions of free F-algebras involving countable
coproducts or ω-colimits, that is, colimits of diagrams (called ω-chains)
of the form:
a0
a1
a2
an
an+1
f0
f1
f2
fn
-
-
-
-
. . .
. . .
Their applicability depends upon preservation properties of the func-
tor F. In this section we consider a construction using countable coprod-
ucts and use it to compute the transitive closure of a graph. Later, as
exercises, we present two ω-colimit constructions of free algebras.
Theorem 5 If C has countable coproducts and F : C →C preserves
them, then free F-algebras exist. The free algebra on a is constructed as
the coproduct:
a + F(a) + F 2(a) + F 3(a) + · · ·
Proof
Let ξn : F n(a) →T(a) (n ≥0) be the coproduct
a + F(a) + F 2(a) + F 3(a) + · · ·
Then T is a functor. The action of T on arrows is deﬁned by univer-
sality of the coproduct. Since F preserves countable coproducts F(ξn) :
F n+1(a) →F(T(a)) is the coproduct
F(a) + F 2(a) + F 3(a) + · · ·

But ξn : F n(a) →T(a), (n ≥1) is a cocone on these objects, so there is
a unique arrow f : F(T(a)) →T(a) such that, for n ≥1, fF(ξn) = ξn.
This is the free algebra.
There is an arrow ξ0 : a →T(a) and the
universality arises from that of the coproduct.
6.5.2
A program
We now program this construction of free algebras and use it to compute
the transitive closure of graphs.
The iterative construction can be encoded as it stands. To apply the
construction, we need categories with countable coproducts. Now, the
category FinSet does not have all countable coproducts and, although
Set does, coproducts of ﬁnite sets may well be inﬁnite. The case we
deal with here is when the iteration terminates. This seemingly trivial
case is a categorical version of program iteration, which we code as a
recursive program in ML. Termination means that the sequence of ob-
jects eventually becomes constantly the initial object. Notice that, for
chains generated by functors preserving the initial object, the ﬁrst occur-
rence of an initial object guarantees that the sequence remains constant
thereafter. This makes termination checkable.
Iterative constructions of free algebras, like that above, require the
functor F to preserve certain colimits. In programming this, it is not
suﬃcient that we know the preservation property holds, we need to ex-
press it in the program for it provides the algebraic structure of the free
algebra. The preservation properties of F depend upon how F is con-
structed in terms of limits and colimits. These preservation properties
are intricate to establish and hold for a restricted range of categories.
Rarely are general theorems available. For constructing free algebras of
equational theories over Set, the relevant preservation property is the
commutation of ﬁnite limits with ﬁltered colimits in Set. Such special-
ized constructions may be realized as, albeit lengthy, programs.
Alternatives are available.
We may operate under the assumption
that the relevant colimits are preserved and compute two colimits, that
of the original diagram and that of the result of applying F to the di-
agram.
The latter is used in place of the image of the colimit under
F. This necessarily involves extra computation and is the penalty for
avoiding programming the proof of preservation. In the case of colim-
its of ω-chains of arrows, termination means that the arrows eventually
all become isomorphisms. Because functors preserve isomorphisms, the
preservation of colimits of terminating ω-chains is simply expressed.

We now program the construction. We say that the countable co-
product of objects ai, i ∈ω, terminates if there is an n ∈ω such that
∀i ≥n. ai is an initial object. In this case the colimit is a ﬁnite coproduct.
When the functor F preserves initial objects, it suﬃces for termination
of F i(a), i ∈ω, that F n(a) is the initial object for some n ∈ω.
The following program accumulates the countable coproduct and
tests for termination, under the assumption that F preserves initial ob-
jects, by testing each iterate for isomorphism with the initial object. We
thus need categories in which isomorphisms are recognizable and inverses
are constructible. We give examples of these in the next section.
datatype (’o,’a)IsoCat =
iso_cat of (’o,’a)Cat * (’a -> bool) * (’a -> ’a)
type (’o,’a)Countable_Coproduct =
(num ->’o) * ’o * (num->’a) * (’o * (num->’a) -> ’a)
fun iterated_coproduct(cC,iso_cat(C,is_iso,_))(F)(a) =
let fun accumulate(Fna,sum) =
if is_iso(initial_arrow(cC)(Fna)) then sum
else accumulate(F ofo Fna, add(cC)(n,Fna,sum)) in
accumulate(a,initial_coproduct(cC)) end
The function initial coproduct is the coproduct of the chain of
initial objects and add adds another iterate to a repeated coproduct
using the binary coproduct in the ﬁnitely cocomplete category cC.
The free algebra is constructed from the universality of the coproduct
and the preservation of coproducts. The latter may be replaced by a
further computation of colimits as discussed above.
fun free_algebra(cC,isoC)(F)(a) =
let val ((_,Ta,xi),univ) =
iterated_coproduct(cC,isoC)(F)(a)
val (_,Funiv) =
iterated_coproduct(cC,isoC)(F)(F ofo a)
val result_alg = (Ta,Funiv(Ta,fn n => xi(succ n)))
val universal =
fn ((b,epsilon’),f) =>
let fun nu(zero) = f
| nu(succ n) =
compose(cat_of cC)(epsilon’,F ofa nu(n))
in (result_alg,univ(b,nu),(b,epsilon’)) end in
(result_alg,universal) end

6.5.3
An example: transitive closure
We apply this construction of free F-algebras to compute the transitive
closure of a graph. The functor F is constructed using limits and colimits,
which means that we can assemble a program for transitive closure from
pieces already available.
A path in a graph is a non-empty sequence of edges e1, e2, . . . , en,
n > 0 such that t(ei) = s(ei+1), 0 < i < n, where s and t are the
source and target, respectively, of the edges. The transitive closure of
the graph has the same nodes, but has paths as edges. A path ending
at a node may be composed, by concatenation, with a path starting at
the node and this composition is associative. Also there are source and
target operations on paths yielding the start and end nodes. Under these
operations, the transitive closure of a graph forms an algebra. This is an
algebra on graphs rather than sets. In fact, transitive closure is the free
algebra on a graph. All this is well known: if we include identities at each
node (empty paths), the transitive closure becomes the path category,
the free small category on a graph.
Recall that graphs in a category C are parallel pairs of arrows. The
transitive closure is a graph on the same nodes as the original graph. We
introduce a category of graphs on a ﬁxed set of nodes as follows. Deﬁne
the category Grapha(C) to have as objects parallel pairs in C whose
target is a and, as arrows, triangles which serially commute. This is a
‘double’ version of a slice category.
datatype (’o,’a)Parallel_Pair = pp of ’a * ’a
datatype (’o,’a)Parallel_Pair_Arrow = pp_arrow of
(’o,’a)Parallel_Pair * ’a * (’o,’a)Parallel_Pair
fun Graph(C)(a) =
cat(fn pp_arrow(s,_,_) => s,
fn pp_arrow(_,_,t) => t,
fn pp(f,g) =>
pp_arrow( pp(f,g),
identity(C)(source(C)(f)),
pp(f,g) ),
fn (pp_arrow(_,f’,q’),pp_arrow(p,f,q)) =>
pp_arrow(p,compose(C)(f’,f),q’))
If C is (ﬁnitely) cocomplete then so is Grapha(C) and the construc-
tion yields a program.
Consider for the moment graphs in FinSet. Deﬁne a binary operation
∗taking graphs G and G′ on the same set of nodes to a graph on these

nodes and having, as edges, composable pairs of edges, the ﬁrst from G,
the second from G′:
edges(G ∗G′) =
{⟨e1, e2⟩: e1 ∈edges(G), e2 ∈edges(G′), tG(e1) = sG′(e2)}.
This is the composition of graphs considered as relations and so may
be deﬁned in any category with pullbacks: Consider graphs G = ⟨s, t⟩:
c →a and G′ = ⟨s′, t′⟩: c′ →a. Let the following be a pullback square:
ˆc
c
c′
a
k1
t
k2
s′
?
-
?
-
Then G ∗G′ = ⟨sk1, t′k2⟩: ˆc →a.
This operation extends to a
functor. The action of ∗on arrows is deﬁned in terms of the universality
of the pullback as described in the program below:
fun edge_composition(lC as complete_cat(C,_))
(G as pp(s,t))(G’ as pp(s’,t’)) =
let val ((k1,k2),pb_univ) = pullback(lC)(t,s’) in
pp(compose(C)(s,k1),compose(C)(t’,k2)) end
fun action_on_arrows(lC as complete_cat(C,_))
(pp_arrow(G as pp(s,t),f,G’ as pp(s’,t’)))
(pp_arrow(H as pp(u,v),g,H’ as pp(u’,v’))) =
let val ((k1,k2),pb_univ)
= pullback(lC)(t,s’)
val ((k1’,k2’),pb_univ’) = pullback(lC)(v,u’)
val u =
pb_univ’(compose(C)(f,k1),compose(C)(g,k2)) in
pp_arrow( edge_composition(lC)(G)(H),
u,
edge_composition(lC)(G’)(H’)) end

fun star(lC as complete_cat(C,_))(a) =
bifunctor( Graph(C)(a),Graph(C)(a),
edge_composition(lC),
action_on_arrows(lC),
Graph(C)(a) )
A bifunctor is a binary functor, i.e. a functor from a product of two
categories.
Theorem 5 may be used to accumulate the transitive closure as a
countable coproduct by noting that, for graphs in FinSet, the functor
ΣG : H 7→G ∗H preserves initial objects and (ﬁnite and) countable
coproducts. The free ΣG algebra on G is a graph T(G) and a graph
arrow G ∗T(G) →T(G).
The graph T(G) is the transitive closure
of G, the arrow corresponds to the operation of extending a path by
concatenating an edge onto its front. The freeness of this construction
ensures that edges in T(G) are indeed paths of edges.
To program this construction of transitive closure, we must ﬁrst con-
sider categories with recognizable isomorphisms and explicit inverses to
isomorphisms. Isomorphisms in FinSet are functions whose source, tar-
get and image all have the same cardinality:
val isoFinSet =
let fun is_iso(fa as set_arrow(a,f,b)) =
(cardinal(a)=cardinal(b)) andalso
(cardinal(b)=cardinal(image fa))
fun invert(set_arrow(a,f,b)) =
set_arrow( b,
fn x =>
let val S =
filter(fn z => (f(z)=x))(a)
val (y,_) =
singleton_split(S) in y end,
a ) in
iso_cat(FinSet,is_iso,invert) end
There is an inheritance of isomorphism structure from a category C to
the category Grapha(C).

fun iso_Graph(iso_cat(C,is_iso,invert))(a) =
iso_cat( Graph(C)(a),
fn pp_arrow(_,f,_) => is_iso(f),
fn pp_arrow(s,f,t) =>
pp_arrow(t,invert(f),s) )
Now we have the ingredients of a transitive closure program:
fun transitive_close(G) =
let val N = pp_source(FinSet)(G) in
free_algebra( cocomplete_Graph(cocomplete_FinSet)(N),
iso_Graph(isoFinSet)(N) )
(as_functor(star(complete_FinSet),G))(N)
end
Notice what has gone into this program: colimits (coproducts) in FinSet
and the inheritance by graphs, recognition of isomorphisms and limits
(pullbacks) in FinSet. This may seem excessive for the transitive closure
of graphs but notice that we calculate not only the transitively closed
graph but also its algebraic structure and its universality.
Moreover,
there is an implied generality of this code as we may release it from
graphs over FinSet to more general graphs, for instance, with structure
on the node or edge sets.
This algorithm is the repeated accumulation of pairs of paths and
so has complexity O(N 3 log N) where N is the number of nodes. Faster
algorithms exist, see [Warshall 62] for an O(N 3) algorithm. A diﬀerent
abstract approach to transitive closure uses semirings (see e.g. [Lehmann
77]).
6.5.4
Other constructions of free algebras
In a series of exercises we present two constructions of free algebras in
terms of colimits of ω-chains. An ω-chain is a diagram of the form:
a0
a1
a2
an
an+1
f0
f1
f2
fn
-
-
-
-
. . .
. . .
We let the arrows fn, n ∈ω represent ω-chains:
type (’o,’a)w_Chain = (num -> ’a)
An ω-cocone is a cocone on an ω-chain and an ω-colimit is a colimiting
ω-cocone. These are represented as types following the treatment of ﬁnite
colimits.

datatype (’o,’a)w_CoCone =
w_cocone of ’o * (’o,’a)w_Chain * (num -> ’a)
datatype (’o,’a)w_CoCone_Arrow
=
w_cocone_arrow of (’o,’a)w_CoCone*’a*(’o,’a)w_CoCone
type (’o,’a)w_Colimiting_CoCone =
((’o,’a)w_CoCone *
((’o,’a)w_CoCone -> (’o,’a)w_CoCone_Arrow))
type (’o,’a)w_Colimit =
(’o,’a)w_Chain -> (’o,’a)w_Colimiting_CoCone
datatype (’o,’a)w_CoComplete_Cat
=
w_cocomplete_cat of (’o,’a)Cat * (’o,’a)w_Colimit
Exercise 7. ω-colimits of terminating chains.
A chain fn : an →an+1, n ∈ω is said to terminate iﬀthere is an
N ∈ω such that for all n ≥N the arrows fn are isomorphisms (i.e.
are invertible). Such chains trivially have colimits. Any an, n ≥N
is a colimiting object.
Write a program to construct colimits of terminating ω-chains
in any category with recognizable isomorphisms and explicit in-
verses to isomorphisms.
Assume that the ﬁrst occurrence of an
isomorphism in the chain guarantees that all succeeding arrows are
isomorphisms. This will be the case for the free algebra construc-
tions which we present below.
As a help, we give the function which ﬁnds the ﬁrst occurrence
of an isomorphism:
fun fixed_point(isoC as iso_cat(C,iso,inverse))
(w_chain)(n) =
if iso(w_chain n)
then n else fixed_point(isoC)(w_chain)(n+1)
Exercise 8. The following theorem constructs free F-algebras as ω-
colimits.
Theorem 6 Let C have colimits of countable chains (ω-colimits)
and an initial object 0. Let F : C →C preserve ω-colimits. Then,
the initial F-algebra exists and is constructed as the colimit of the
chain:

0
F(0)
F 2(0)
F n(0)
F n+1(0)
f
F(f)
F 2(f)
F n(f)
-
-
-
-
. . .
. . .
where f : 0 →0F is the unique such arrow.
In the case that C has binary coproducts, the free algebra on a is
obtained by replacing F by a + F in the above construction, where
a stands for the constant functor returning the object a.
Prove this and encode the construction.
Exercise 9. Here is a construction of free algebras using an iterated
pushout:
Theorem 7 Let C have ﬁnite colimits and ω-colimits.
Let F :
C →C preserve ω-colimits. Then free F-algebras exist. The free
algebra on a, F(a∞) →a∞, is constructed as the colimit of the
following chain of pushout squares,
0
a0
a1
a2
f
f1
f2
f3
-
-
-
...
F(a0)
F(a1)
F(a2)
F(f1)
F(f2)
F(f3)
-
-
-
-
...
?
?
?
?
g
g1
g2
g3
where a0 = a and f and g are the unique arrows from the initial
object.
Prove this theorem.
The function ﬁnding when such a chain of pushouts terminates
is given below. Use this to write a program constructing free alge-
bras as in the theorem.
fun fixpoint(cC,isoC as iso_cat(C,is_iso,_))(F)(a) =
let fun accumulate(f_n,g_n) =
let val ((f_succn,g_succn),_) =
pushout(cC)(g_n,f_n) in
if is_iso(f_succn) then source(C)(f_n) else
accumulate(F ofa f_succn,g_succn) end in
accumulate( initial_arrow(cC)(a),
initial_arrow(cC)(F ofo a)) end

This construction may be used to compute colimits of algebras and
free algebras of equational theories. In the latter case, the equations
may be imposed at each step of the iteration using appropriate
coequalizers. More about the iterated pushout construction may be
found in [Ad´amek, Trnkova 78], [Ad´amek 77,78], [Ad´amek, Koubek
80] and [Barr, Wells 85].
6.6
Exercises
Exercise 10. Arrows of adjunctions can be deﬁned to form a cate-
gory of adjunctions: Let A and B be categories. A pair of nat-
ural transformations (σ : F →F ′, τ : G′ →G) from adjunction
⟨F, G, η, ϵ⟩: B →A to adjunction ⟨F ′, G′, η′, ϵ′⟩: B →A is said to
be conjugate if the diagram below commutes:
I
G′F ′
GF
GF ′
η′
τF ′
η
Gσ
?
-
?
-
In fact, each natural transformation determines the other.
Under the composition (σ, τ).(σ′, τ ′) = (σ.σ′, τ ′.τ), adjunctions,
with conjugate pairs of natural transformations as arrows, form a
category Adj(B, A). Give a computational representation of the
category of adjunctions.
Exercise 11. Adjunctions may be composed. Given ⟨F, G, η, ϵ⟩: A →
B and ⟨F ′, G′, η′, ϵ′⟩: B →C, their composition is deﬁned to be
the adjunction ⟨FF ′, G′G, η.Fη′G, G′ϵF ′.ϵ′⟩: A →C.
Exercise 12. Show that if C is complete so is the category of algebras
(F : C). Program this construction of ﬁnite limits.
Constructions of colimits of algebras are not so straightforward.
Iterative constructions are available as mentioned in Exercise 9.
Exercise∗13. Minimal realization by automata Goguen [1973], as
well as Arbib and Manes [1974,75a], show that the minimal realiza-

tion of a behaviour by a ﬁnite automaton is right adjoint to a be-
haviour functor. Write a program to compute minimal realizations
as an adjunction. A reference for the construction is [Hopcroft,
Ullman 79].
Exercise∗14. Monads Free algebras ﬁnd a setting in the theory of
monads. Monads are an alternative formulation of adjunctions and
provide a description of equational theories in terms of functors
and natural transformations.
Suitable references are [Mac Lane
71], [Manes 76] and [Barr, Wells 86]. Many of the constructions
involving monads may be expressed as programs. Try this.
Alagi´c [1975] has shown how top-down and bottom-up tree pro-
cessing may be given a categorical setting using monads. Can you
use these ideas to write general tree-processing routines?
Exercise∗15. Consider the category of recursively enumerable (r.e.)
sets with recursive functions as arrows. Which limits and colimits
exist in this category?
Lazy lists in ML, otherwise called streams, may be used to
represent r.e. sets and hence limits and colimits that exist may be
encoded.
Exercise∗16. Constructing adjunctions via colimits The
fact
that left adjoints are cocontinuous may be used to construct ad-
junctions as follows.
Let F : A →B be a cocontinuous functor. To compute the ac-
tion of F on an object a of A, express a as a colimit of a diagram ∆
and assume, recursively, that we can compute F(∆). Then, by co-
continuity, F(a) is the colimiting object of F(∆) in B. Notice that
in computing F(∆) we need to (recursively) compute the action of
F on arrows as well as objects. This requires careful analysis since
the expression of objects and arrows as colimiting cocones and ar-
rows of colimiting cocones respectively is not, in general, functorial.
Conditions can be imposed to make this scheme work. In particu-
lar, if F is a left adjoint then, assuming the recursion terminates,
we construct adjunctions using colimits. This is the substance of
the following theorem:

Theorem 8 Consider a diagram of functors:
C
A
B
J
F
G
-
6
@
@
@
@
R
Let J : C →A satisfy the following: For each object a of A,
there is a diagram ∆in C such that a is a colimit of J(∆).
Suppose B is cocomplete and there is a natural transformation
η : J →GF such that, for each object c of C, (F(c), η(c)) is free
on J(c) with respect to G, then F extends (necessarily uniquely) to
a left adjoint F ∗: A →B of G such that F ∗J = F.
Note: Such an F and η is equivalent to, for each c in C, a
(canonical) universal arrow from J(c) to G.
Prove this theorem and show how it leads to recursive programs
for computing adjunctions assuming that the decomposition into
diagrams terminates.
Show how Warshall’s algorithm for the transitive closure of a
graph can be considered to be an example of this construction of
adjunctions.
Warshall’s algorithms is described in [Warshall 62]
and [Aho, Hopcroft, Ullman 74].

Chapter 7
Toposes
This is the ﬁnal chapter in which we consider basic category theory and
its computational representation. We shall take a brief look at categorical
logic, considering cartesian closed categories and toposes.
Cartesian closed categories are categories in which analogues of func-
tion spaces, called exponentials, are deﬁned. There is an exact corre-
spondence between cartesian closed categories and certain λ-calculi, see
[Lambek 69,80] and [Lambek, Scott 86]. This correspondence provides
an algebraic treatment of models of λ-calculi. Moreover, it translates
functional languages with variables into a variable-free combinator lan-
guage. Curien [1986] uses the combinators of cartesian closed categories
to deﬁne an abstract machine for implementing functional languages.
Elementary toposes were introduced by Lawvere and Tierney. Toposes
are cartesian closed categories which have an extra structure allowing the
deﬁnition of an internal logic which is, in general, intuitionistic rather
than classical. Just as certain λ-calculi correspond to cartesian closed
categories so theories in higher order intuitionistic logic correspond to
toposes. The logical operations are expressed in terms of limits, colimits
and exponentials and can be realized as programs. Originally, toposes
were introduced in an attempt to characterize the category Set in an
entirely arrow-theoretic fashion. So interpreted, toposes provide cate-
gorical primitives for manipulating sets so that programs involving sets
may be assembled from the operations in a topos.
In this chapter, the treatment is fairly brief.
We deﬁne cartesian
closed categories and toposes, giving computational representations and
some example computations involving these concepts. This is all prelim-
inary to presenting programs to compute the internal logic in toposes.
These programs are run on an example of a topos to provide truth-tables
155

for a three-valued logic.
For those wishing to know more about categorical logic and toposes,
useful references are [Freyd 72], [Goldblatt 79], [Johnstone 77], [Seely 83]
[Barr, Wells 85], [Lambek, Scott 86] and the introductory paper [Mac
Lane 75].
7.1
Cartesian closed categories
It is somewhat remarkable that function spaces can be universally char-
acterized:
Deﬁnition 23 Let C be a category with binary products. If a and b are
objects of C, an exponential from a to b is an object ba and an arrow
e : a × ba →b such that for any object c and arrow f : a × c →b, there
is a unique arrow f # : c →ba such that the triangle below commutes.
a × c
b
a × ba
f
ia × f #
e
-
?    
Deﬁnition 24 A category which is ﬁnitely complete and has exponen-
tials for any pair of objects is called cartesian closed.
Some authors require only ﬁnite products rather than all ﬁnite limits.
Notice that the deﬁnition of exponentials is that of an adjunction: the
functor ( )a is right adjoint to the functor a × .
Just as in previous chapters we represented universally deﬁned con-
cepts as functional types in ML, so here we represent exponentials and
hence declare a type for cartesian closed categories:
type (’o,’a)Exponential =
(’o*’o) -> ( (’o*’a) * ((’o*’a) -> ’a) )
datatype (’o,’a)Cartesian_Closed_Cat
=
cartesian_closed_cat of
(’o,’a)Cat * (’o,’a)Limit * (’o,’a)Exponential

7.1.1
An example: the category of ﬁnite sets
The categories FinSet and Set are both cartesian closed. The exponen-
tial ba is the set of all functions from a to b, the function e : a × ba →b
is application apply(x,f) = f(x) and the universal property is the
so-called ‘curry’ operation converting a binary operation into repeated
application:
curry(f) = fn x => fn y => f(y,x)
To program the exponential in FinSet, we represent functions by
their graphs (sets of pairs) and then compute the set of all functions
between two ﬁnite sets. The latter calculation is based on the following
isomorphisms which hold in any cartesian closed category with initial
object 0 and binary coproducts:
b0 ∼= 1
b1 ∼= b
ba+a′ ∼= ba × ba′
These may be veriﬁed using elementary arguments and the deﬁnition of
exponentials. Alternatively, the ﬁrst and third isomorphisms arise from
the fact that the functor b( ) : dual(C) →C is right adjoint to itself and
so carries colimits to limits.
These isomorphisms supply a recursive algorithm for calculating the
exponential in FinSet as follows: The ﬁnite set a in ba is either empty,
in which case we have b0 ∼= 1, or is a singleton set, in which case b1 ∼= b or
it can be expressed non-trivially as a coproduct, in which case we have
ba+a′ ∼= ba × ba′.
Again, we need to ensure that the elements of the sets are closed under
the operations on them, in this case that of forming lists. We extend the
type of these elements, which already are closed under operations like
pairing:
datatype ’a Tag = ... | tuple of (’a*’a)list
The function space ba is computed by case analysis on set a:
fun function_space(a,b) =
if cardinal(a) = 0 then singleton(tuple [])
else if cardinal(a) = 1 then
let val x = element_of(a) in

mapset((fn y => tuple([x,y)])),b) end
else let val (a1,a2) = split(a)
val prod =
cartesian_prod( function_space(a1,b),
function_space(a2,b)) in
mapset(fn (tuple(x),tuple(y))=>tuple(append(x,y))),
prod)
end
The exponential is the function space together with an evaluation arrow
e : a × ba →b.
fun exponential(a,b) =
let val fs = function_space(a,b)
val ((fs_X_a,proj_fs,proj_a),_) =
product(complete_FinSet)(fs,a)
val eval =
set_arrow(fs_X_a,
fn pr => let val s = proj_fs OF pr
and x = proj_a OF pr
in list_to_fn(s)(x) end,
b )
in (fs,eval) end
The description is completed by deﬁning the universal property as a
function taking a pair (c, f : a × c →b) and returning an arrow f # : c →
ba:
fun set_exp(a,b) =
( exponential(a,b),
fn (c,f) =>
let val (_,univ) = product(complete_FinSet)(a,c)
val tt_obj as (tt,tt_arrow) =
terminal_obj(complete_FinSet)
fun constant_arrow(x,d) =
set_arrow(terminal_obj,constant(x),d)
val comp = compose(FinSet)
in set_arrow( c,
fn y =>
let fun fsharp(z) =
comp(e,
univ(tt_obj,
constant_arrow(z,a),

constant_arrow(y,c))
OF ttrue
in fn_to_list(fsharp,a) end,
function_space(a,b) ) end )
The cartesian closed category of ﬁnite sets is the category FinSet to-
gether with limits and exponentials:
val cc_FinSet =
let val complete_cat(_,lim) = complete_FinSet in
cartesian_closed_cat(FinSet,lim,set_exp) end
7.2
Toposes
A topos is a cartesian closed category which has an object, called a sub-
object classiﬁer, to represent the truth-values. In the topos Set this is
a two element set (for the truth-values ‘true’ and ‘false’). Other toposes
allow more exotic truth-values, including logics of undeﬁnedness and tem-
poral logics. Internal logics in toposes are intuitionistic. Indeed, there
is a exact correspondence between toposes and theories in higher order
intuitionistic logic, see [Lambek, Scott 86].
The following deﬁnition captures the required behaviour of truth-
values in arrow-theoretic terms:
Deﬁnition 25 Let C be a category with a terminal object, 1. A subob-
ject classiﬁer in C is an object of C, Ω, together with an arrow t : 1 →Ω,
which satisfy the following:
For each monic m : a →c there is a unique χm : c →Ω,
called the character of m, such that the following is a pullback
square.
a
1
c
Ω
!
t
m
χm
?
-
?
-

We use the notation ! : a →1 for the unique arrow into the terminal
object.
Recall that an arrow m : b →c is a monic iﬀfor all arrows
f, g : a →b, mf = mg
⇒
f = g.
In Set, Ωis a two-element set, say, {tt, ﬀ} and the arrow t : 1 →Ω
selects the element tt. A monic (a 1-1 function) m : a →c divides c into
the elements that are in the image under m and those that are not. The
character of m maps image elements to tt and other elements to ﬀ. It is
readily veriﬁed that this does indeed make the above square a pullback.
Deﬁnition 26 A category is a topos if
• It is ﬁnitely bicomplete (i.e. complete and cocomplete),
• It has exponentials,
• It has a subobject classiﬁer.
It can be shown that cocompleteness follows from the other axioms,
so we may deﬁne a topos as a cartesian closed category with a subobject
classiﬁer.
In a topos, the object Ωis called the object of truth values, the arrow
t : 1 →Ωis truth and for any object a the composite a
!
−→1
t
−→Ωis
called true on a. The name of an arrow f : a →b in any cartesian closed
category is the unique arrow ˆf : 1 →ba determined by the universality
of the exponential ba.
Turning to the computational representation of toposes, we see that
the deﬁnition of a topos involves monic arrows. Monics are not simply
arrows with extra computational structure. Any treatment of monics re-
quires an equality on arrows – either a decidable equality or a proof sys-
tem for establishing equality. However, constructions involving toposes
do not make reference to the monic nature of arrows which rather is part
of the correctness argument for the constructions.
We proceed to represent toposes and give examples of constructions
within them including that of the internal logic:
type (’o,’a)PullBack_Square =
(’a*’a*’a*’a) * ((’a*’a) -> ’a)
type (’o,’a)Subobject_Classifier =
(’o*’a) * (’a -> (’o,’a)PullBack_Square)

datatype (’o,’a)Topos =
topos of
(’o,’a)Cat *
(’o,’a)Limit *
(’o,’a)Colimit *
(’o,’a)Exponential *
(’o,’a)Subobject_Classifier
Here are some useful functions associated with toposes:
fun true_ (T as topos(C,lim,_,_,((_,truth),_)))(a) =
let val cC = complete_cat (C,lim) in
compose(C)(truth,terminal_arrow(cC)(a)) end
fun character(topos(_,_,_,_,(_,sc_univ)))(m)
=
let val ((_,chi,_,_),_) = sc_univ(m) in chi end
fun name (topos(C,lim,_,exp,_))(f) =
let val cC = complete_cat(C,lim)
val t_obj = terminal_obj cC
val a = source(C)(f) and b = target(C)(f)
val pr_a_f = let val ((_,pr_a,_),_) =
product cC (t_obj,a)
in compose(C)(f,pr_a) end
val (_,exp_adj) = exp(a,b)
in exp_adj (t_obj,pr_a_f) end
7.2.1
An example: the topos of ﬁnite sets
The categories Set and FinSet are both toposes. We describe the topos
FinSet as a value in ML. Since we already have programmed the carte-
sian closed category of ﬁnite sets and also ﬁnite colimits in FinSet, all
that remains is the subobject classiﬁer. This was described in the previ-
ous section and is expressed in the following program:
val subobject_classifier =
let val lC as complete_cat(C,_) = complete_FinSet
val truvals = {ttrue,ffalse}
val truth =
set_arrow({ttrue},fn x=>ttrue,truvals)
val chi =
fn m =>

set_arrow(target(C)(m),
fn z =>
if member(z,(image_set m))
then ttrue else ffalse,
truvals )
in ( (truvals,truth),
fn m =>
let val t =
terminal_arrow(lC)(source(C)(m)) in
((truth,chi(m),t,m),
fn (f,g) =>
compose(C)(right_inverse(m),g)) end) end
val topos_of_sets =
let val cartesian_closed_cat(C,lim,exp) = cc_FinSet
val cocomplete_cat(_,colim) = cocomplete_FinSet
in topos(C,lim,colim,exp,subobject_classifier) end
7.2.2
Computing in a topos
Constructions within a topos can be programmed using ﬁnite limits and
colimits, exponentials and the subobject classiﬁer.
As an example we consider the concept of power objects.
This is
a universal characterization of the powerset construction in the toposes
Set and FinSet.
Deﬁnition 27 Let C be a category with binary products and a an object
of C, the power object of a is an object of C, P(a), together with an
object d and a monic p : d →a × P(a), such that, for any object b and
monic m : r →a × b, there is a unique arrow f : b →P(a) and a
(necessarily unique) arrow g : r →d to make the square below a pullback
square:
r
d
a × b
a × P(a)
g
p
m
ia × f
?
-
?
-

Proposition 10 In a topos, every object has a power object.
Proof
The idea behind the construction is that in Set we can represent
the powerset P(a) by the set of functions from a to the two-element set
of truth-values Ω. To lift this to an arbitrary topos, we need only deﬁne
the requisite arrows and check their universality as follows.
For an object a of topos T with subobject classiﬁer t : 1 →Ωand
exponential e : a × Ωa →Ω, deﬁne P(a) = Ωa and p : c →a × P(a) by
the pullback square:
c
a × Ωa
1
Ω
p
e
!
t
?
-
?
-
The universal property of (P(a), p) can be established from that of
the subobject classiﬁer, the exponential and the above pullback.
2
This construction is given explicitly in the ML function below.
type (’o,’a)Power =
’o -> (’o*’a*(’a -> (’a*(’o,’a)PullBack_Square)))
fun power(topos(C,lim,colim,exp,sc)) =
let val ((truvals,truth),character_square) = sc
val lC = complete_cat(C,lim) in
fn a =>
let val ((P_of_a,eval),exp_adjoint) =
exp(a,truvals)
val ((h,membership),pb_univ) =
pullback(lC)(truth,eval)
val universal =
fn f =>
let val ((_,chi,t,_),sc_univ) =
character_square(m)
val f = exp_adjoint(source(C)(chi),chi)
val fxa = a_prod_o_within(lC)(f,a)
val u = pb_univ(t,compose(C)(fxa,f))
val square = (membership,fxa,u,f)

val univ =
fn (p,q) => sc_univ(compose(C)(h,p),q)
in (f,(square,univ)) end
in (P_of_a,membership,universal) end end
7.2.3
Logic in a topos
In this section we deﬁne the internal logic in a topos and program it in
ML. We then run this on an example topos to produce the truth-tables
of a three-valued logic.
Firstly, we need the following result.
Proposition 11 In a topos, every arrow can be factored as an epi fol-
lowed by a monic.
Proof
Given an arrow f : a →b in topos T, let (p, q) be the pushout
of (f, f) and m : d →b the equalizer of the parallel pair (p, q). The
universality of the equalizer gives a unique arrow e : a →d such that
f = m.e. It can be veriﬁed that this is an epi-monic factorization of f.
2
The factorization can be encoded as a function factorize taking a
topos and an arrow and returning the two arrows which are its epi-monic
factorization.
Let T be a topos with subobject classiﬁer t : 1 →Ωand initial
object 0. The internal logic in T arises from the following deﬁnitions of
the logical connectives:
• true : 1 →Ωis the arrow t.
• false : 1 →Ωis the character of the unique arrow 0 →1.
• not : Ω→Ωis the character of false.
• and : Ω× Ω→Ωis the character of < true, true >: 1 →Ω× Ω.
• or : Ω× Ω→Ωis the character of the image (the monic part of
the epi-monic factorization) of the arrow
[< T, iΩ>, < iΩ, T >] : Ω+ Ω→Ω× Ω
where T : Ω→Ωis constantly true.
• imply : Ω× Ω→Ωis the character of the equalizer of the arrows
and, π1 : Ω× Ω→Ω.

These operations can be directly encoded using limits, colimits and
the subobject classiﬁer. Exponentials are used only in deﬁning quantiﬁers
(see Exercise 1):
fun FALSE (T as topos(C,lim,colim,_,_)) =
let val (init,_) = initial(cocomplete_cat(C,colim))
val f = terminal_arrow(complete_cat(C,lim))(init)
in character(T)(f) end
fun NOT(T) = character(T)(FALSE T)
fun AND(T as topos(C,lim,colim,_,sc) ) =
let val lC = complete_cat(C,lim)
val ((truvals,truth),_) = sc
val (_,p_univ) = product(lC)(truvals,truvals)
val m = p_univ(terminal_obj(lC),truth,truth)
in character(T)(m) end
fun OR(T as topos(C,lim,colim,_,((truvals,truth),_))) =
let val lC = complete_cat(C,lim)
val cC = cocomplete_cat(C,colim)
val ((coprod,p,q),cp_univ) =
coproduct(cC)(truvals,truvals)
val ((prod,r,s),pr_univ) =
product (lC) (truvals,truvals)
val t =
compose(C)(truth,terminal_arrow(lC)(truvals))
val p1 = pr_univ(truvals,identity(C)(truvals),t)
val p2 = pr_univ(truvals,t,identity(C)(truvals))
val m
= cp_univ(prod,p1,p2)
val (_,im_of_m) = factorize(T)(m)
in character(T)(im_of_m) end
fun IMPLY(T as topos(C,lim,colim,_,((truvals,truth),_)))=
let val lC = complete_cat(C,lim)
val ((prod,r,s),pr_univ) =
product(lC)(truvals,truvals)
val m = pr_univ(terminal_obj(lC),truth,truth)
val conj = character(T)(m)
val ((_,m1),_) = equalizer(lC)(conj,r)
in character(T)(m1) end

7.2.4
An example: a three-valued logic
We could apply these functions to the topos of ﬁnite sets to get an ex-
tremely contorted method of computing the familiar truth-tables of clas-
sical propositional logic. However, the genericity of the code allows more
exotic truth-values and internal logics. Let us use this code to generate
a three-valued logic.
We deﬁne the topos structure of FinSet→, the category whose ob-
jects are FinSet-arrows and whose arrows are commuting squares. This
is the comma category (IFinSet, IFinSet).
Alternatively, this category is the functor category from the category
with two objects and one non-identity arrow between them. There are
general constructions of toposes as functor and comma categories. In the
exercises, we suggest that the reader programs some of these construc-
tions. In fact, the functor category description of FinSet→provides its
topos structure through a general construction. However, here we ex-
plicitly code this topos, avoiding the overheads arising from representing
the general construction. Moreover, we use the comma category repre-
sentation as it is somewhat more succinct.
Limits and colimits in FinSet→arise from the description as a comma
category:
val arrow_cat = comma_cat(I(FinSet),I(FinSet))
val cocomplete_arrow_cat =
cocomplete_comma_cat
(cocomplete_FinSet,cocomplete_FinSet)
(cocontinuous_I(FinSet),I(FinSet))
val complete_arrow_cat =
complete_comma_cat
(complete_FinSet,complete_FinSet)
(I(FinSet),continuous_I(FinSet))
The subobject classiﬁer is rather interesting. The object of truth-
values is an object in the comma category and so is a pair of sets and a
set arrow between them. The source set is a three-element set:
val src = {just("F"),just("*"),just("T")}
and the target is a two-element set:
val tgt = {just("T"),just("F")}
The function between them is deﬁned in the following:

val Omega =
( src,
set_arrow(src,
fn just("T") => just("T")
| just("*") => just("T")
| just("F") => just("F"),
tgt),
tgt )
It is clear that we get something more than a version of two-valued
classical logic. The arrow t : 1 →Ωrepresenting ‘true’ selects the element
just("T") in both the source and target sets:
val truth =
let val T_obj as (T,_,T’) =
terminal_obj(complete_arrow_cat) in
comma_arrow( T_obj,
(set_arrow(T,fn _ => just("T"),src),
set_arrow(T’,fn _ => just("T"),tgt)),
Omega ) end
The required property of Ωis that any monic has a characteristic
arrow into Ωto make a square into a pullback. Monics in the comma
category from (a, f, a′) to (c, g, c′) are pairs of monics (m : a →c, m′ :
a′ →c′) such that the following square commutes:
a
a′
c
c′
f
m′
m
g
?
-
?
-
The three-valued source set src is used to deﬁne the character of a
monic as follows. For an element z ∈c, if z is in the image of a then it
maps to just("T"); otherwise, if it is in the inverse image of a′ through
g but not in the image of a then it maps to just("*") else it maps to
just("F"):

fun chi(comma_arrow(s_obj as (a,f,a’),
(m,m’),
t_obj as (c,g,c’))) =
comma_arrow(t_obj,
(set_arrow(c,fn z =>
if member(z,image_set m) then just("T")
else if member(z,
(inv_image(g,image_set(m’))
diff image_set(m)))
then just("*") else just("F"),src),
set_arrow(c’,fn z =>
if member(z,image_set m’) then just("T")
else just("F"),tgt) ),
Omega )
These components are gathered together, with the universality of the
pullback square, in the following deﬁnition of the subobject classiﬁer in
FinSet→:
val subobject_classifier =
let val lC as complete_cat(C,_) =
complete_arrow_cat in
( (Omega,truth),
fn M as comma_arrow(s_obj as (a,f,a’),
(m,m’),
t_obj as (c,g,c’)) =>
let val t =
terminal_arrow(lC)(source(C)(M)) in
((truth,chi(M),t,M),
fn (p,q) =>
compose(C)
(comma_arrow(target(C)(q),
(inv(m),inv(m’)),
s_obj),q) )
end
) end
This is all that is required to deﬁne the truth-tables of the logical
connectives (exponentials appear only when deﬁning quantiﬁers). Let us
call the topos arrow topos.
We can now run the programs above to compute the logical connec-
tives. Arrows 1 →Ωare in 1-1 correspondence with elements of the set

src and, moreover, functions on Ωare characterized by the action on
these elements. We thus consider this to be a three-valued logic whose
truth-values are the elements of src and we display the resulting con-
nectives as truth-tables.
First, the value of FALSE(arrow topos) is the arrow from the termi-
nal object selecting the element just("F") in each set of Ω.
The value of NOT(arrow topos) is an arrow in the comma category
from Ωto Ω. Its action on the set src is given in the following table:
NOT
T
F
*
F
F
T
The connectives AND(arrow topos) and OR(arrow topos) are both
arrows in the comma category from Ω×Ωto Ω. The results of calculating
these values are given in the following tables:
AND
T
*
F
T
T
*
F
*
*
*
F
F
F
F
F
OR
T
*
F
T
T
T
T
*
T
*
*
F
T
*
F
Finally, here is the truth-table of implication, calculated as the value
of IMPLY(arrow topos):
IMPLY
T
*
F
T
T
*
F
*
T
T
F
F
T
T
T
This is a simple temporal logic discussed in [Lawvere 76].
Let us examine the ingredients in these calculations. Explicitly, we
use products and coproducts in the comma category, and implicitly, in
the factorization, we use equalizers and pushouts. These are computed
from those in FinSet using the inheritance of colimits to comma cate-
gories and, through the encoding of duality, the inheritance of limits. As

well as this, the image and inverse image operations on set arrows are
called from the subobject classiﬁer. These also are computed using lim-
its and colimits in FinSet. All this to calculate the simple truth-tables
above!
7.3
Conclusion
So far we have displayed a good deal of category theory in the program-
ming language ML and shown explicitly how categorical constructions
yield programs. We have travelled fairly methodically through standard
constructions and run the resulting programs on examples which we hope
have been of some interest to the reader. Where do we go from here?
Because of the generality of category theory and its applicability in
set theory, algebra, topology and logic, it may be expected that the cat-
egorical programs we have developed would similarly be of widespread
application.
However, it turns out that ﬁnding applications is not as
easy as we at ﬁrst envisaged. Programming tasks are often described at
a fairly low level of abstraction and in order to use the programs we have
developed we must interpret the tasks at a much more abstract level – as
instances of categorical concepts. Moreover, we then must ﬁnd relevant
constructions in category theory to provide algorithms. The following
two chapters are case studies in the application of categorical program-
ming, ﬁrst to developing uniﬁcation algorithms and then to implementing
a semantics.
There are certain categorical constructs which we have not encoded as
they cannot be represented within the type system of ML at a suﬃcient
level of generality. An example of such a construct is indexed categories
which occur, for instance, as hyperdoctrines in categorical logic.
An-
other example is the general term algebra construction which, we have
presented only for ﬁnite algebras. Both of these require explicit type uni-
verses. We are now engaged in the development of a suitable type system
for categorical programming. We discuss linguistic aspects of category
theory at length in Chapter 10.

7.4
Exercises
Exercise 1. Quantiﬁers Universal and existential quantiﬁers can be
deﬁned in a topos.
Using deﬁnitions from standard texts, e.g.
[Goldblatt 79], verify that the following ML functions deﬁne the
quantiﬁers:
fun FOR_ALL(T)(a) =
character(T)(name(T)(true_(T)(a)))
fun EXISTS (T as topos(C,lim,_,_,_))(a) =
let val (P_of_a,a_membership,_) = power(T)(a)
val ((_,pr,_),_) =
product(complete_cat(C,lim))(P_of_a,a)
val f = compose(C)(pr,a_membership)
val (_,im_of_f) = factorize(T)(f)
in character(T)(im_of_f) end
Exercise∗2. Constructing toposes: 1. Slice categories The follo-
wing is called the fundamental theorem of toposes: If C is a topos,
then so is the slice category C/a for any object a of C.
Recall that the slice category C/a has as objects, arrows into a
and as arrows, commuting triangles. Details of the topos structure
of slice categories are found in [Freyd 72] and [Goldblatt 79]. You
may like to program this as a way of generating some interesting
toposes.
Exercise∗3. Constructing toposes: 2. Functor categories For
any small category B (i.e. category whose collections of objects and
arrows are both sets), the functor categories SetB and FinSetB
are toposes. The objects in these categories are called presheaves.
The details of this construction may be found in [Freyd 72],
[Goldblatt 79] and [Barr, Wells 85]. The subobject classiﬁer is con-
structed as sets of ‘sieves’. Again the construction can be expressed
as a program for generating toposes.
Exercise∗4. A topos of graphs Let B be the category with two ob-
jects s and t and two arrows both from s to t as well as the identity
arrows.
Then the functor topos FinSetB is the topos of ﬁnite
graphs.
Investigate the topos structure of graphs in this topos. Hint:
the subobject classiﬁer has two nodes a and b and ﬁve edges. Two

edges from a to itself and one from b to itself; the other two are
between a and b in opposite directions.

Chapter 8
A Categorical Uniﬁcation
Algorithm
We turn from programming basic category theory to applications. In
this chapter, we derive an algorithm for the uniﬁcation of terms from
constructions of colimits. This is a case study in using the abstraction
and constructivity of category theory in the design of algorithms1.
Uniﬁcation is a symbol-manipulative task occurring in many areas of
computation, in particular in the automation of inference. For those not
familiar with uniﬁcation we describe it below. Uniﬁcation is an equation-
solving task that is decidable. The earliest algorithm for computing most
general uniﬁers was given by Herbrand [1930]. Robinson [1965] applied
this to automated inference. Since then many variations on the basic
uniﬁcation algorithm have been proposed, often to improve eﬃciency.
The algorithm we present is a non-deterministic version of the basic
algorithm of Robinson.
The derivation of a uniﬁcation algorithm hinges upon two observa-
tions. Firstly, uniﬁcation can be considered as an instance of something
more abstract – as a colimit in a suitable category. Secondly, general
constructions of colimits provide recursive procedures for computing the
uniﬁcation of terms.
As it stands, this derivation of a uniﬁcation algorithm is an isolated
result. However, it ﬁnds a setting in a categorical treatment of equational
deduction. This is described in [Rydeheard, Stell 87] where we draw upon
categorical logic to give a 2-category structure for equational deduction.
In this setting, we consider solving equations in equational theories and
173

combining uniﬁcation algorithms for diﬀerent theories.
8.1
The uniﬁcation of terms
As an example of uniﬁcation, consider the following equation between
terms:
f(w, g(h(y)), h(z)) = f(g(x), z, h(w))
Here f, g and h are operator symbols with the evident arities and w, x,
y, z are variables. The task of uniﬁcation is to replace the variables with
terms so that both sides of the equation become the same term. Such a
substitution is called a uniﬁer. For instance, the substitution,
w 7→g(h(v)), x 7→h(v), y 7→v, z 7→g(h(v))
where v is a variable, makes both sides of the equation equal to
f(g(h(v)), g(h(v)), h(g(h(v))))
Not only is this a uniﬁer, it is the ‘most general uniﬁer’ in that any other
uniﬁer factors through it.
Uniﬁers need not always exist for an equation. We can distinguish
two cases when they fail to exist. As examples:
• Clash
g(x) = h(y)
• Cyclic
x = g(x)
In the ‘clash’ case no substitution can possibly make the two sides equal.
However, in the ‘cyclic’ case uniﬁers do exist if we allow inﬁnite terms.
In programming, uniﬁcation occurs, for instance, in computational
logic [Robinson 65], polymorphic type-checking [Milner 78] and in imple-
menting programming languages which are based upon pattern-matching
such as Prolog [Colmerauer et al. 73]. A good general survey of term
rewriting and uniﬁcation is [Huet, Oppen 80]. Eﬃcient uniﬁcation al-
gorithms have been proposed, for instance those of [Paterson, Wegman
78] and of [Martelli, Montanari 82]. Uniﬁcation admits several general-
izations including higher-order uniﬁcation [Huet 75] and uniﬁcation in
equational theories [Huet, Oppen 80], [Siekman 84].
1This account appears in the Proc. Summer Conf. on Category Theory and Com-
puter Programming (1985), LNCS 240, Eds. D. Pitt et al., Springer-Verlag 1986. A
full account of the material of this chapter may be found in internal reports of the
Departments of Computer Science in the Universities of Manchester and Edinburgh.

Manna and Waldinger [1980], Eriksson [1984] and Paulson [1985] have
considered derivations of uniﬁcation algorithms and the reader is invited
to compare this categorical version with theirs. The algorithm we are to
derive is a general recursive counterpart of the non-deterministic algo-
rithm in [Martelli, Montanari 82] which there serves as a starting point
for the development of an eﬃcient algorithm. It is an open question as
to whether such eﬃcient evaluation strategies can be understood in this
categorical framework. It is the compositional structure of uniﬁcation
algorithms rather than their eﬃciency which seems open to this abstract
analysis.
8.2
Uniﬁcation as a coequalizer
We recall the material of Chapter 3 on terms and term substitutions. Let
Ωbe an operator domain. Denote by TΩ(X) the set of terms over Ωin
variables from the set X. A (term) substitution f : X →Y is a function
f : X →TΩ(Y )
Substitutions may be applied to terms, replacing variables by terms.
They form arrows in a category TΩwhose objects are sets.
The full
subcategory of ﬁnite sets we denote by TΩF in.
We show that the task of uniﬁcation is exactly that of computing
coequalizers in the category TΩ(an observation made by Goguen).
An equation in set X over Ωis a pair of terms (s,t), which we write
as s = t. A substitution q : X →Y is said to unify a set of equations
in X, {si = ti : i ∈I}, if ∀i ∈I. q(si) = q(ti). Such uniﬁers do not
always exist. However, when they do exist so does a most general uniﬁer
deﬁned to be a uniﬁer q : X →Y such that for any uniﬁer q′ : X →Y ′
there is a unique2 substitution u : Y →Y ′ satisfying uq = q′.
Now, a set of equations in X over Ω, {si = ti : i ∈I}, is equivalent
to a parallel pair of arrows in TΩ,
I
f
−→
−→
g
X
deﬁned by f(i) = si and g(i) = ti. Uniﬁers of this set of equations are
arrows q such that qf = qg. Moreover, the above deﬁnition of a most
general uniﬁer is exactly that of a coequalizer of f and g in TΩ.
2Uniqueness is often not demanded here but, since epis are involved, uniqueness is
assured.

Notice how, in the above, the universal form of the deﬁnition of the
most general uniﬁer translates directly into the universal deﬁnition of
the coequalizer.
An alternative, somewhat more standard way of treating the compo-
sitional structure of uniﬁcation goes as follows. Fix an inﬁnite (global)
set of variables X. Instead of considering substitutions to be maps be-
tween sets, let them be maps between terms in X.
We then form a
category whose objects are terms and whose arrows are substitutions.
This category is sometimes reduced to a pre-order (s <
∼t iﬀt is a substi-
tution instance of s) and, from this, a lattice, the lattice of subsumptions
[Plotkin 69], may be constructed. The most general uniﬁer of two terms
is their least upper bound in this pre-order.
The localization of variables in our treatment seems crucial. It allows
us to use general constructions at the level of category theory as a source
of uniﬁcation algorithms. Moreover, it avoids much of the explicit han-
dling of variables which occurs in standard treatments of term-rewriting
– indeed, even when using a global set of variables, there are occasions,
such as in deﬁning ‘narrowing’, when local sets of variables are required.
Localization aﬀords a uniform treatment of variables, as they are handled
automatically within the limit and colimit operations in TΩ.
8.3
On constructing coequalizers
As we have remarked previously, category theory is particularly rich in
ways of constructing colimits from other colimits. For uniﬁcation algo-
rithms we need constructions of coequalizers. The following two theorems
provide constructions, in an arbitrary category, of coequalizers in terms
of other coequalizers. Amongst the many possible such theorems, these
two are chosen so as to lead to a recursive algorithm which terminates
in the category TΩF in and hence provides uniﬁcation algorithms.
Of
course, neither is particularly ‘deep’ nor are they new but together they
reﬂect the compositional structure of uniﬁcation.
Each theorem can readily be veriﬁed by simple arrow-chasing.
In
fact, the second theorem follows directly from the deﬁnition of an epi.
The ﬁrst theorem considers parallel pairs of arrows whose source can
be expressed as a coproduct, whilst the second theorem deals with par-
allel pairs of arrows that can be factored through a common arrow. In
the case of uniﬁcation (i.e. in the category TΩ) the ﬁrst theorem corre-
sponds to the division of the set of equations into two parts (we have
met it already in Chapter 4), whilst the second theorem corresponds to

the division of terms into subterms.
Theorem 9 If q : b →c is a coequalizer of the parallel pair,
a
f
−→
−→
g
b
and r : c →d is the coequalizer of
a′
b
b
c
f ′
g′
q
q
   
@
@
@
R
   
@
@
@
R
then rq : b →d is the coequalizer of the following parallel pair:
a + a′
[f,f′]
−→
−→
[g,g′]
b
Theorem 10 For all epis h : a′ →a, the arrow q : b →c is a coequalizer
of the parallel pair of arrows f, g : a →b iﬀit is a coequalizer of the
parallel pair:
a′
fh
−→
−→
gh
b
It is to be emphasized that these theorems are valid for any category.
However, for our present purposes, we illustrate them in the category
TΩ. Consider the following two equations (with f, g, h, a operators and
w, x, y, z variables):
f(w, g(h(y)), h(z)) = f(g(x), z, h(w))
h(a) = x
The most general uniﬁer q of the ﬁrst equation is given previously as
w 7→g(h(v)), x 7→h(v), y 7→v, z 7→g(h(v))
The second equation with q applied to it is
h(a) = h(v)

Its most general uniﬁer r is simply
v 7→a
According to Theorem 9, the most general uniﬁer of the two equations
is then rq, which is the following substitution:
w 7→g(h(a)), x 7→h(a), y 7→a, z 7→g(h(a))
Theorem 10 says that, for instance, the most general uniﬁer of the two
equations above is the same as the most general uniﬁer of the following
set of equations obtained by matching subterms:
w = g(x)
g(h(y)) = z
h(z) = h(w)
h(a) = x
There is a calculus of parallel pairs based on the following two oper-
ations. Letting + be a distinguished coproduct, deﬁne the coalesced sum
of parallel pairs as
(a
f
−→
−→
g
b) ⊕(a′
f′
−→
−→
g′
b) = a + a′
[f,f′]
−→
−→
[g,g′]
b
Deﬁne the right composition of an arrow with a parallel pair as
(a
f
−→
−→
g
b) ◦(a′
h
−→a) = a′
fh
−→
−→
gh
b
The left composition (also denoted ◦) is deﬁned similarly.
In terms of these operations, the coequalizer function φ taking parallel
pairs to arrows satisﬁes the following equations (in the sense that if the
right side is deﬁned so is the left and they are equal):
φ(P ⊕Q) = φ(φ(P) ◦Q)φ(P)
φ(P ◦h) = φ(P)
(h an epi)
These equations are simply a rewriting of Theorems 9 and 10. Notice
that they do not express φ as a homomorphism.

Let us say that a parallel pair is irreducible if it cannot be expressed
non-trivially as a coalesced sum or as a right composite. An expression
for a parallel pair P as Q ⊕R is trivial if either Q or R is isomorphic to
P. Likewise, an expression for P as Q ◦h is trivial if Q is isomorphic to
P.
The following theorem says that in the category TΩF in these equa-
tions deﬁne a function – the coequalizer.
Theorem 11 Let C be the class of coequalizable parallel pairs in TΩF in.
There is a unique (to within an isomorphism) function,
φ : C →Arrow(TΩF in)
deﬁned to be the coequalizer on irreducible parallel pairs and satisfying
the following equations (in the sense that if the right side is deﬁned so is
the left and they are equal):
φ(P ⊕Q) = φ(φ(P) ◦Q)φ(P)
φ(P ◦h) = φ(P)
(h an epi)
Moreover, φ(P) is the coequalizer of P ∈C.
Sketch of proof
The universality of the arrow φ(P), if it exists, is a direct consequence of
Theorems 9 and 10 above and hence is at the level of general categorical
skull-duggery. To establish the existence of φ(P) when P is coequalizable
is more intricate – unduly intricate compared with the elegance of Theo-
rems 9 and 10. Other authors, e.g. [Manna, Waldinger 80], have noticed
this disparity between derivation and proof of uniﬁcation algorithms.
The existence of φ(P) is a termination proof and depends on deﬁn-
ing a suitable well-founded pre-order.
We give a rough argument for
termination, ignoring the partial nature of uniﬁcation.
Deﬁne a well-founded pre-order on sets of equations as
the lexical product3 of the pre-orders (i) the number of vari-
ables in the set of equations, (ii) the number of occurrences
of operators and (iii) the number of equations.
3The lexical product <
∼of pre-orders <
∼1 and <
∼2 is deﬁned by x < y iﬀx <1 y
or (x ∼1 y and x <2 y), together with x ∼y iﬀx ∼1 y ∼2 x. The lexical product
of well-founded pre-orders is well-founded. The pre-order determined by numerical
functions is that corresponding to the usual numerical order.

Now let E be a set of equations. Consider the construction
of Theorem 9. Divide E non-trivially into the union of E1 and
E2. The set E1 is smaller than E in the pre-order since E1 has
no more variables or operator occurrences than E and E1 has
strictly fewer equations (by non-triviality). Let q be the most
general unifying substitution of E1 and let q ◦E2 be the set
of equations resulting from applying q throughout E2. There
are two cases. If q is an isomorphism, then q◦E2 ≡E2 and so,
as before, q ◦E2 is smaller than E. If q is not an isomorphism
then it reduces the number of variables (an observation of
Robinson [1965]) and so again q ◦E2 is smaller than E.
Consider now the construction of Theorem 10.
In this
case E is expressed non-trivially as E′ ◦h with h an epi. E′
is smaller than E in the pre-order since both have the same
number of variables but the number of operator occurrences
in E′ is strictly smaller than that in E or is the same but
then E′ contains fewer equations than E.
This rough argument can be cast into a categorical proof by axioma-
tizing suitable properties of the category TΩF in, principally the support
of an appropriate well-founded pre-order.
It has been pointed out to
us that there is a possibility of an entirely categorical termination proof
using a theory of ordinals in categorical logic.
8.4
A categorical program
In this section we express the above two constructions of coequalizers as
programs. These programs are then used to deﬁne a recursive uniﬁcation
algorithm.
In Chapter 4 we deal with computational representations of various
colimits including coequalizers. We simplify that treatment here by omit-
ting the universal part of the coequalizer (it can easily be added and will
then provide the universal part of the most general uniﬁer). Thus we
make the coequalizer a function of type:
coequalize: ’a * ’a
-> ’a
Here ’a is the type variable representing the type of arrows in the cate-
gory of interest.
Theorem 9 as a construction, takes two parallel pairs f, g : a →b and
f ′, g′ : a′ →b (using the notation of the theorem) and yields an arrow –

a coequalizing arrow of the parallel pair
a + a′
[f,f′]
−→
−→
[g,g′]
b
The type of this function is:
sum_coequalize: (’o,’a)Cat -> ((’a * ’a -> ’a) ->
((’a * ’a) * (’a * ’a) -> ’a))
Referring back to the statement of Theorem 9, we interpret this as: in a
category with coequalizers, parallel pairs (f, g) and (f ′, g′) determine an
arrow (rq in the notation of the theorem). The deﬁnition of the function
is simply a rewording of the theorem:
fun sum_coequalize(C)(cq)((f,g),(f’,g’)) =
let val q = cq(f,g)
val r = cq(compose(C)(q,f’),compose(C)(q,g’)) in
compose(C)(r,q) end
Theorem 10 is dealt with similarly, giving the following trivial pro-
gram which says simply that the coequalizer of a parallel pair P ◦h (with
h an epi) is that of the parallel pair P.
fun composite_coequalize(C)(cq)(P,h) = cq(P)
It is Theorem 11 and its proof that is to provide uniﬁcation algo-
rithms. Looking back at the theorem, we see that, apart from the equa-
tions deﬁning coequalizers of reducible parallel pairs and the direct deﬁ-
nition of coequalizers of irreducible parallel pairs, there remains only the
constructive interpretation of reducibility, i.e. encoding the following:
∃Q, R : P ≡Q ⊕R,
Q ̸≡P ̸≡R
∃Q, h (epi) : P ≡Q ◦h,
h not an isomorphism
This becomes a pair of decomposition functions which, if supplied with
reducible parallel pairs, give the components as results. On other ar-
guments these functions may not be deﬁned – in programming terms
they may ‘fail’ or ‘raise an exception’. We should consider here some
form of non-determinism as, for the correctness of the algorithm, it is
immaterial in what order the decomposition takes place. Moreover, the
same applies to the order in which the equations (and hence the decom-
positions) are chosen. Clearly, some strategies are more eﬃcient than

others and there remains the question of how to constrain the algorithm
to eﬃcient strategies.
Recall from Chapter 3 the computational representation of the cate-
gory TΩF in. There we introduced terms and deﬁned term substitutions
as:
datatype Substitution =
subst of (element Set)*(element -> Term)*(element Set)
By introducing functions for the composition and identity of such sub-
stitutions we deﬁned a category FinKleisli.
We are now ready to describe the decomposition of parallel pairs of
substitutions. To express a parallel pair non-trivially as a coalesced sum
we express the source set as the disjoint union of non-empty sets, i.e.
non-trivially as a coproduct in TΩF in. If this is not possible we raise an
exception. The appropriate function is deﬁned below using a function
split which expresses a ﬁnite set (cardinality greater than one) as a
non-trivial coproduct in TΩF in (this can be done in various ways).
fun sum_decompose(P) =
if cardinal(pp_source P) > 1 then
let val (b,c) = split(pp_source P) in
(restrict(b,P),restrict(c,P)) end
else raise sum_decompose
The function restrict takes a subset a′ of the source of a parallel pair
P of substitutions f, g and yields the parallel pair of f and g restricted
to a′.
Expression as a non-trivial right composition is more complex, in-
volving the factorization of terms. One way of factoring a term ρ(t1, t2)
in X is to express it as a term ρ(z1, z2) in Z = {z1, z2}, the arity of
ρ, together with a substitution p : Z →X deﬁned by p(z1) = t1 and
p(z2) = t2. Note that the substitution s = λx.ρ(z1, z2) : 1 →Z is an epi.
This extends to a factorization of substitutions as follows. A (non-
variable) term in X is a pair ⟨ρ, p : Z →X⟩with Z the arity of ρ and
p a substitution. A substitution contains a term ⟨ρ, p : Z →X⟩iﬀit
is (to within an isomorphism) of the form [f ′, ps] : Y ′ + 1 →X where
s : 1 →X is s = λx.ρ(iX). This substitution may then be factored in
TΩas:
Y ′ + 1
iY ′+s
−→Y ′ + Z
[f′,p]
−→X

Note that iY ′ + s is an epi. Moreover, as long as we factor only pairs of
terms with a common leading operator, this factorization extends to the
right factorization of parallel pairs of substitutions.
Coproducts in the category TΩF in are disjoint unions and can be
programmed as in FinSet using a labelling with, say, ‘pink’ and ‘blue’
to ensure disjointness.
We shall encode this decomposition as a program – ﬁrstly deﬁning
a function which checks whether a pair of terms has the same leading
operator by case analysis on the form of the terms:
fun top_same(apply(phi,_),apply(psi,_)) = phi=psi
| top_same(s’,var(x)) = false
| top_same(var(y),t’) = false
The next function identiﬁes such a pair of terms in a parallel pair of
substitutions:
fun witness(P as (f,g)) =
if is_empty(pp_source P) then raise witness else
let val (x,a’) = singleton_split(pp_source(P)) in
if top_same(subst_apply(f)(x),subst_apply(g)(x))
then x else witness(restrict(a’,P)) end
Here singleton split extracts an element from a set and returns the
element and the remaining set. We can now deﬁne the decomposition
function which expresses a parallel pair of substitutions, if possible, as
a right composite Q ◦h returning the epi h and the parallel pair Q as
results.
fun composite_decompose(P as (f,g)) =
let val x = witness(P)
val apply(phi,s) = subst_apply(f)(x)
and apply(psi,t) = subst_apply(g)(x)
val c = sum(minus(pp_source(P),x),arity(phi)) in
((subst(c,
fn pink(z) => subst_apply(f)(z)
| blue(z)=> s(z),
pp_target(P)),
subst(c,
fn pink(z) => subst_apply(g)(z)
| blue(z)=> t(z),
pp_target(P)) ),

subst(pp_source(P),
fn z => if x=z
then apply(phi,fun y => var(blue(y)))
else var(pink(z)),
c)) end
Here pp source and pp target are the source and target functions
for parallel pairs of substitutions, minus subtracts an element from a
set and subst apply applies a substitution to an element of its source
yielding a term.
The ﬁnal task before giving a recursive uniﬁcation algorithm is the
computation of coequalizers of irreducible parallel pairs of substitutions.
Irreducible parallel pairs which have coequalizers are either empty, in
which case the coequalizer is an identity, or are equivalent to a pair of
terms (⟨x⟩, t) in X with x ∈X and x /∈Var(t) (unless t is a variable).
The coequalizer then is simply the substitution which takes x to t and
acts as identity on all other elements of X.
The ﬁrst function below
creates this substitution. The second function uniﬁes irreducible parallel
pairs when possible.
fun unit_unify(x,t,b,c) =
subst(b,fn z => if z=x then t else var(z),c)
fun irreducible_unify(P as (f,g)) =
let val b = pp_target P in
if is_empty(pp_source P)
then subst_identity(b)
else
let val (x,_) = singleton_split(pp_source P)
val s = subst_apply(f)(x)
and t = subst_apply(g)(x) in
case (s,t) of
(var(z),var(z’)) =>
let val c =
if z=z’ then b else minus(b,z) in
unit_unify(z,t,b,c) end |

(var(z),t’) =>
if occurs(z,t’) then raise cyclic else
unit_unify(z,t’,b,minus(b,z)) |
(s’,var(z)) =>
if occurs(z,s’) then raise cyclic else
unit_unify(z,s’,b,minus(b,z)) |
(_,_)
=> raise clash end end
The function occurs checks whether a variable occurs in a term.
Finally, a program for the most general uniﬁer of a parallel pair. This
is a case analysis – express the pair, if possible, non-trivially as a coa-
lesced sum or as a right composite and calculate the uniﬁer by Theorem
9 or Theorem 10 calling uniﬁcation recursively. If decomposition is not
possible then the function above calculates uniﬁers of irreducible parallel
pairs. Exception handling is used to check the form of a parallel pair by
attempting the decomposition. If the decomposition fails then a handler
is invoked which either attempts another decomposition or deals with
the irreducible cases.
fun unify(P) =
let val (P,P’) = sum_decompose(P) in
sum_coequalize(FinKleisli)(unify)(P,P’) end
handle ? =>
let val (P’,h) = composite_decompose(P) in
composite_coequalize(FinKleisli)(unify)(P’,h) end
handle ? =>
irreducible_unify(P)
This then is a program for uniﬁcation based on constructions of col-
imits. It could be expressed using conditionals rather than exceptions
but the tests for decomposability proceed by attempting the decompo-
sition, so code would be repeated in the test and the decomposition.
The universal property of the most general uniﬁer could be included by
encoding it for the two functions derived from Theorems 9 and 10, and
amending the code for irreducible parallel pairs.
Exercise∗1. Consider a parallel pair of arrows f, f ′ : a →b. Suppose
f = hg.
Then we may take the pushout p, p′ of g, f ′ and the
coequalizer q of p, p′h. Show that the coequalizer of f, f ′ is qp′.
In a category with coproducts, this provides a recursive con-
struction of coequalizers based on the factorization of one arrow in

a parallel pair rather than the simultaneous factorization of both.
Does this provide a uniﬁcation algorithm i.e. does the recursion
terminate in TΩF in?
Exercise∗2. Inductive generalization There is a dual to uniﬁcation
called generalization by Plotkin [1969]. A common instance of two
terms s and t is a term u such that there are substitutions f and
g with f(u) = s and g(u) = t.
A generalization of two terms
is a greatest common instance. This is dual to uniﬁcation in the
lattice of subsumptions.
Does generalization have a categorical
formulation in TΩand what about algorithms for generalization?

Chapter 9
Constructing Theories
Computer scientists have been concerned over the last ten years or so with
the question of how to specify a task before embarking on the design of
a program to perform that task. Informal speciﬁcations in English are
vague, so a lot of research has gone into the design of formal speciﬁcation
languages. For example, if we want to write a matrix inversion program
we might formally specify the reals and operations on them, matrices,
the identity matrix and matrix multiplication; we would then be able
to say what it means to compute the inverse of a matrix. If we want
to write a compiler which translates Pascal into assembly code we need
precise deﬁnitions of both these languages. Speciﬁcation languages may
be based on equations, on predicate calculus or on a higher order logic. A
speciﬁcation consists of a sequence of declarations of types (or sorts) and
operations over them, together with a set of equations or logic sentences.
The closure of this set under the appropriate inference operations forms a
theory. Thus the speciﬁcation is what is called in algebra a ‘presentation’
of the theory.
A long, unstructured list of axioms (equations or logic sentences) is
prone to error and hard to understand. So a number of proposals have
been made for modular speciﬁcation languages in which a structured
speciﬁcation may be given using operations to combine smaller pieces of
speciﬁcation. This is analogous to the structuring operations in program-
ming languages such as Modula2 or Ada. We want to deﬁne speciﬁcations
with parameters which can later be ﬁlled in. For example, the notion of
matrix and the operations over matrices can be generalized to work over
any ring, just as the notion of sorting a sequence can be deﬁned for any
ordering. These combination operations are really independent of the
particular language used to state the axioms, and they can be deﬁned
187

for any language which permits some substitution operations on sen-
tences which are ‘semantically well behaved’ in some elementary sense.
To deﬁne the operations independent of the base language, Goguen and
Burstall [1983] formulated the concept of ‘institution’ to explicate the
above criterion.
It turned out to be very close to logicians’ work on
abstract model theory, initiated by Barwise [1974].
Burstall and Goguen [1980,81] describe a speciﬁcation language, cal-
led Clear. Its semantics is given in terms of institutions. The opera-
tions for building speciﬁcations are interpreted as colimits in a suitable
category.
It this chapter, we show how to implement these semantic
operations using the preceding categorical programming. We begin by
describing the speciﬁcation-building operations at a syntactic level. We
then deﬁne institutions and the semantics of the operations. We then
code up the appropriate colimits and implement the semantics.
9.1
Preliminaries
As a preliminary to looking at the construction of algebraic speciﬁca-
tions, we review some fairly standard universal algebra, extending that
of Section 3.2.7 to the many-sorted (or ‘heterogeneous’) case.
For S a set, an S-sorted set X is a family of sets Xs, s ∈S.
A
signature is a many-sorted operator domain. If S is a set of sorts, then a
signature is a pair Σ = (S, (O, a)) where S is a set (of sorts), O is a set (of
operators) and a assigns to each operator a non-empty sequence of sorts
in S. For ρ ∈O with a(ρ) = s1, . . . , sn, s, we write ρ : s1, . . . , sn →s.
As an example of a many-sorted signature, consider that of graphs:
Graph_Sig =
sorts node, edge
opns
source : edge -> node
target : edge -> node
and also that of edge-labelled graphs:
Labelled_Graph_Sig =
sorts node, edge, element
opns
source : edge -> node
target : edge -> node
label
: edge -> element
An arrow from signature Σ = (S, (O, a)) to signature Σ′ = (S′, (O′, a′))
is a pair of functions f : S →S′, g : O →O′ such that, for each oper-

ator ρ ∈O, if a(ρ) = s1, . . . , sn, s then a′(g(ρ)) = f(s1), . . . , f(sn), f(s).
Signature arrows are composed componentwise to form a category Sign.
An example of a signature arrow,
s : Labelled_Graph_Sig -> Graph_Sig,
maps the sort element to the sort node, the operator label to source
and is identity elsewhere.
For X an S-sorted set, we deﬁne the S-sorted set of terms TΣ(X) as:
x ∈Xs ⇒⟨x⟩∈TΣ(X)s
ρ : s1, . . . , sn →s and ti ∈TΩ(X)si, 1 ≤i ≤n ⇒
ρ(t1, t2, . . . , tn) ∈TΣ(X)s
An equation in variables X is a pair of terms in TΣ(X) with the same
sort.
A signature arrow may be applied to a term, and hence to an
equation, by translating the operators in the term through the signature
arrow.
An equational presentation of a theory is a pair (Σ, E) of a signature
Σ and a set E of Σ-equations.
An example of an equational presentation is that of graphs with dis-
tinguished loops at each node:
Loop_Graph =
sorts node, edge
opns
source : edge -> node
target : edge -> node
loop
: node -> edge
eqns
source(loop(n)) = n
target(loop(n)) = n
An algebra of a signature Σ = (S, (O, a)) is an S-sorted set A and for
each operator in O, ρ : s1, . . . , sn →s, a function fρ : As1 × . . . × Asn →
As. Homomorphisms are a many-sorted version of the single-sorted case,
as is the concept of an algebra satisfying an equation. We therefore deﬁne
categories AlgΣ of algebras of a signature Σ, and Alg(Σ,E) of Σ-algebras
satisfying set of equations E. Both the categories AlgΣ and Alg(Σ,E) have
initial and free algebras constructed as sorted versions of term algebras.
As examples, algebras of Graph Sig and of Labelled Graph Sig are
graphs and edge-labelled graphs respectively.
A set of Σ-equations E can be closed with respect to validity, forming
a set of equations E∗with e ∈E∗iﬀe is satisﬁed by every algebra

in Alg(Σ,E). This coincides with closure under many-sorted equational
deduction [Goguen, Meseguer 85], so that e ∈E ∗iﬀe is deducible from
the equations E. A set of equations E is closed if E = E ∗. A theory is
a presentation in which the set of equations is closed. A presentation
(Σ, E) presents the theory (Σ, E ∗). A theory arrow from (Σ, E) to (Σ′, E′)
is a signature arrow F : Σ →Σ′ such that, if e ∈E, then F(e) ∈E ′. We
thus form the category of theories Th.
This summarizes the universal algebra that we need to describe the
semantics of combining theories. More details of many-sorted algebra
may be found in, for instance, [Goguen, Burstall 84].
9.2
Constructing theories
We describe some operations for constructing theories, which we illus-
trate with equational theories though, as we shall see later, they may be
extended to other kinds of theories. These operations were introduced
by Burstall and Goguen [1977,80,81] in the speciﬁcation language Clear.
Combine
The combine of two theories T1, T2, written T1 + T2, is their disjoint
union. More properly, it is the theory presented by the disjoint union
of the signatures together with the two sets of equations translated into
the disjoint union signature. This turns out to be a coproduct in the
category of theories.
As an example, consider the two theories presented as follows:
const SemiGroup =
theory sorts element
opns
_ * _ : element,element -> element
eqns
(a*b)*c = a*(b*c)
endth
const Graph =
theory sorts node, edge
opns
source : edge -> node
target : edge -> node
endth
Then the theory SemiGroup + Graph contains the three sorts and
the three operations above satisfying the one equation. More generally,

renaming would take place to separate sorts and operations which share
the same name.
We are concerned not only with theories but also with speciﬁcations
– descriptions of the construction of theories from component theories.
Consider two speciﬁcations of theories T1, T2 which contain some com-
mon component theory T. Does T1 + T2 contain one or two copies of
T? In practice, it seems more useful to allow only one copy of T (the
alternative is called ‘proliferation’). This is handled by introducing the
concept of ‘theories built from theories’, which are described as cocones
in the category of theories. The combine operation is then interpreted
as a coproduct of cocones.
Enrich
Enriching a theory is simply the addition of new sorts, operations and
equations and is interpreted as a theory arrow from the original theory
to the enriched theory.
As an example, suppose there is a theory of truth-values called Bool
(deﬁned later) containing a sort of truth-values, bool, and the constant
operations true and false as well as conjunction and implication. Then
a theory of ordered sets (in this case, the order is a pre-order) can be
described as an enrichment of Bool.
const Order =
Bool enriched by
sorts element
opns
_ =< _ : element,element -> bool
eqns x =< x = true
x =< y and y =< z implies x =< z = true
enden
Notice that the added equations may refer to operations in the theory
being enriched (Bool in this case).
Parameters
Consider graphs whose edges are labelled. For many applications, e.g.
for ‘ﬂow’ problems, it does not matter what the labels are. They might
be integers, reals, pairs of integers or even words, as long as the labels
support some kind of order.
We thus want to abstract the notion of
labelled graphs from particular kinds of labels. To do this we treat the
labels as a parameter and ensure that they support a requisite order.

Consider graphs with maximum ﬂow values on the edges and an actual
ﬂow along the edges. The theory of such graphs may be written:
procedure Flow(P: Order)
Graph enriched by
opns max: edge -> element
flow: edge -> element
eqns flow(e) =< max(e) = true
enden
where P is the formal parameter and Order is the above theory of pre-
ordered sets (called the requirement of the parameter). The body of the
procedure, which deﬁnes what is meant by a ﬂow in a graph, can use the
sorts and operations of the parameter P by using the names (e.g. =<) in
the requirement theory Order.
To supply the theory of graphs where ﬂows are measured by natural
numbers, we call the procedure with a theory of natural numbers as
argument. Suppose that NatLe is a theory of natural numbers with sort
nat for numbers and an operation leq for the usual ‘less than or equal
to’ of natural numbers. A theory of graphs with natural numbers ﬂows
is given by:
Flow(NatLe[element is nat, =< is leq])
The list in square brackets, the ‘ﬁtting arrow’, tells how the theory NatLe
is to match the theory Order, that is, it deﬁnes what order we are con-
sidering on natural numbers.
The semantics of the procedure call is deﬁned in terms of the seman-
tics of the procedure itself and of the matching of the requirements to
the actual parameters. Both of these are theory arrows. The beauty of
this description is that the application of a procedure is the pushout of
the two theory arrows.
Free interpretation
Theories describe a category of algebras. Often, however, we are inter-
ested not in the whole class of algebras but in a particular algebra or,
more generally, some subclass. Typical cases are truth-values or natural
numbers. Both of these examples are initial in a category of algebras.
Thus there are occasions when we wish to interpret theories as initial or
free algebras.
Consider the following theory of truth-values:

const Bool =
theory data sorts bool
opns
true, false: bool
endth
The presence of the word data indicates that algebras of this theory
are to be initial in the category of all algebras of the given signature.
In particular, the carrier has exactly two elements denoted by true and
false. Extra operations on truth-values may be added by an enrichment:
const Bool1 =
Bool enriched by
opns not: bool -> bool
and: bool,bool -> bool
eqns not(false) = true
not(true) = false
b and true = b
b and false = false
enden
A similar example is that of natural numbers constructed from zero
and a successor function by initiality:
const Nat =
theory data sorts nat
opns
0: nat
succ: nat -> nat
endth
Initial algebras come equipped with an equality predicate which we
write as == to distinguish it from the = of equations. Thus x == y iﬀ
x = y is deducible from the equations.
When procedures are involved, it is free algebras rather than initial
algebras that are described. Consider ﬁrst the trivial theory of one sort:
const Triv =
theory sorts element endth
Sequences may be described by the following procedure which is a
speciﬁcation of free monoids:

procedure Sequence(X: Triv)
X enriched by
data sorts sequence
opns
empty: sequence
unit: element -> sequence
_ . _ : sequence,sequence -> sequence
eqns
empty.s = s
s.empty = s
(s.t).u = s.(t.u)
enden
The data operation is considered, like equations, to add constraints
limiting the class of algebras under consideration. It is somewhat re-
markable that these so-called data constraints behave, in an abstract
setting, just like equations.
Derive
Often we build some complex theory and then want to extract some piece
of it. As an example, instead of directly deﬁning truth-values as above,
we may want to implement them in terms of the numbers 0 and 1. Of
course, some operations on numbers make no sense on truth-values so
these must be omitted.
const Bool =
derive sorts bool
opns
true,false: bool
from Nat
by bool
is nat
false is 0
true
is succ(0)
endde
The interpretation of this is a factorization of a theory arrow.
It
is the factorization which eliminates operations on numbers which are
inappropriate for truth-values.
9.3
Theories and institutions
We now describe the model-theoretic notion of institution developed by
Goguen and Burstall [1983]. The aim is to deﬁne notions of speciﬁcation

and theory which abstract from particular languages such as equational
or ﬁrst order logic.
The abstract theories should be amenable to the
various operations described in the previous section. This makes it pos-
sible to deﬁne the semantics of a structured speciﬁcation language such
as Clear without reference to any one particular base logic. Indeed, it is
possible to envisage languages which use more than one base logic; for
example, we might use equational logic for the deﬁnition of data types
and their primitive operations and use predicate calculus to deﬁne other
operations over these data types. The use of institutions for deﬁning
speciﬁcation languages has become fairly popular in computer science
research.
Traditionally, a logic may be described by a set S of sentences, a
set M of models and a satisfaction relation |= between models and sen-
tences. However the sets S of sentences and M of models are relative to
some signature, where the notion of signature varies from logic to logic.
For equational logic, signatures would be as above. For predicate cal-
culus they would also include some predicates. To deﬁne the combine
and enrich operations on speciﬁcations we need a notion of inclusion be-
tween signatures and to deﬁne parameterized speciﬁcations we will need
a notion of renaming between signatures. We introduce a category of
signatures and must then ensure that when we change signatures we can
translate sentences and models, and also that the satisfaction relation is
preserved under these translations. Notice that models translate in the
opposite sense from sentences.
Deﬁnition 28 An institution consists of a category Sig (of objects called
signatures) equipped with two functors and a relation |= (called the
satisfaction relation):
• Mod : Sig →Setop – set of models on a signature,
• Sen : Sig →Set – set of sentences on a signature,
• |=⊆Mod(Σ) × Sen(Σ) for each Σ of Sig,
such that for each σ : Σ →Σ′ in Sig, e ∈Sen(Σ) and m′ ∈Mod(Σ′),
m′ |= Sen(σ)(e)
iﬀ
Mod(σ)(m′) |= e
Moreover, we insist that the category Sig is ﬁnitely cocomplete.
An example is the equational institution described in Section 9.1.
The category Sig is that of ordinary signatures (sorts and operations

with their functionality), Mod gives the set of algebras on a signature
and Sen the set of all equations (pairs of terms) on the signature. We
might extend the notion of an institution to include a category, rather
than a set, of models for each signature.
Suppose I is an institution, a presentation (of a theory) in I consists
of a pair (Σ, E) where Σ is a signature (an object of Sig) and E is a
subset of Sen(Σ).
A theory is a presentation (Σ, E) in which the set E is ‘closed’. In
this model theory, closure is the semantic closure, deﬁned in terms of
satisfaction as follows. Extend satisfaction to sets of models M and sets
of equations E by:
M |= e
⇐⇒
∀m ∈M m |= e
m |= E
⇐⇒
∀e ∈E m |= e
Given a set of sentences E, deﬁne M = {m : m |= E} and then deﬁne
the closure of E as E∗= {e : M |= e}. A set of sentences E is closed iﬀ
E = E∗.
Deﬁnition 29 A theory in an institution (Sig, Mod, Sen, |=) is a pair
(Σ, E) where Σ is an object of Sig and E is a closed subset of Sen(Σ).
In the equational case, the closure of a ﬁnite set of equations is, in
general, an inﬁnite non-recursive set. To deal satisfactorily with closed
sets of sentences we introduce ﬁnite expressions denoting these sets. The
expressions are built from the operations that we wish to perform on
closed sets. The following operations are needed:
• closure(E) = E∗,
• closeU(E, E′) = (E ∪E′)∗, notice that (E ∪E′)∗̸= E∗∪E′∗,
• closetrans(f, E) = (Sen(f)(E))∗,
• invtrans(f, E) = {e : Sen(f)(e) ∈E} – it is closed,
• star(Σ, E) = {e : M |= e} where M = {m+ : m |= E}. It is deﬁned
when Σ has a sort ‘boolean’ with constants ‘true’ and ‘false’. Then
m+ is m extended with an equality operation == on each sort
satisfying a == b = true
iﬀ
a = b.
The language of expressions built from these operations can be de-
scribed by an ML type:

datatype (’o,’a,’sen)Closure =
closure of (’sen)Set |
closeU of (’o,’a,’sen)Closure*(’o,’a,’sen)Closure |
closetrans of ’a * (’o,’a,’sen)Closure |
invtrans of ’a * (’o,’a,’sen)Closure |
star of ’o * (’o,’a,’sen)Closure
These closure operations are the key to writing a modular theorem
prover based on modular speciﬁcations. For, whilst the operations them-
selves are not implementable, we can use a theorem prover to check
whether a sentence in an institution is in a particular closure. This idea
has been used by Don Sannella [1982] to produce a pilot version of a
structured theorem prover using the Edinburgh LCF system for proof
construction.
Using expressions for closed sets of sentences, theories may be repre-
sented as follows:
datatype (’o,’a,’sen)Theory =
theory of ’o * (’o,’a,’sen)Closure
A theory arrow f : (Σ, E) →(Σ′, E′) is a signature arrow f : Σ →Σ′
such that Sen(f)(E) ⊆E. Thus, including the source and target theories,
datatype (’o,’a,’sen)Theory_Arrow =
theory_arrow of
(’o,’a,’sen)Theory * ’a * (’o,’a,’sen)Theory
Noting that the identity and composition of theory arrows are those
in Sig, the deﬁnition of the category of theories Th over an institution
is straightforward. This deﬁnes a function of type:
cat_of_theories: (’o,’a)Cat ->
((’o,’a,’sen)Theory,(’o,’a,’sen)Theory_Arrow)Cat
9.4
Colimits of theories
We now show how to compute colimits of theories. We proceed by deﬁn-
ing the initial theory, binary coproducts and coequalizers of theories and
then using the general colimit construction of Chapter 4.
The initial object, binary coproducts and coequalizers of theories are
deﬁned as follows:

• The initial theory is (Φ, φ) where Φ is the initial signature and φ
the empty set of equations.
• The coproduct of two theories (Σ, E) and (Σ′, E′) is the theory
(Σ + Σ′, (Sen(f)(E) ∪Sen(f ′)(E′))∗) where f : Σ →Σ + Σ′ and
f ′ : Σ′ →Σ + Σ′ is the coproduct of signatures.
• The coequalizer of f, g : (Σ, E) →(Σ′, E′) is the theory arrow h :
(Σ′, E′) →(Σ′′, (Sen(h)(E′))∗) where h : Σ′ →Σ′′ is the coequalizer
of f, g in the category of signatures.
As an example of a program to compute the colimit of theories, we
present the coproduct function:
fun theory_coproduct(cSig as cocomplete_cat(Sig,_)) =
fn (t as theory(S,E),t’ as theory(S’,E’)) =>
let val ((sum_sig,f,f’),univ_sig) =
coproduct(cSig)(S,S’)
val sum_sentence =
closeU (closetrans(f,E),closetrans(f’,E’))
val sum_theory = theory(sum_sig,sum_sentence)
val universal =
fn (tt,g,g’) =>
theory_arrow(sum_theory,
univ_sig(signature(Sig) ofo tt,
signature(Sig) ofa g,
signature(Sig) ofa g’),
tt) in
( (sum_theory,
theory_arrow(t,f,sum_theory),
theory_arrow(t’,f’,sum_theory)),
universal )
end
Exercise 1. The category of theories Th over an institution is an in-
dexed category, indexed by signatures. Indexed categories are de-
ﬁned in Chapter 5 (Exercise 12). This provides an alternative con-
struction of colimits of theories as follows.
For any institution,
deﬁne the functor F : Sig →Cat so that F(Σ) is the category of
closed sets of Σ-sentences under inclusion. On signature arrows,
f : Σ →Σ′, deﬁne (F(f))(E) = (Sen(f)(E))∗. For each signature
Σ, the category F(Σ) has ﬁnite colimits (only coproducts are non-
trivial: E + E′ = (E ∪E′)∗). Moreover, the functors F(f) preserve

ﬁnite colimits. Show that the Grothendieck construction G(F) is
(isomorphic to) the category Th. Thus, by Proposition 7, Th has
ﬁnite colimits.
9.5
Environments
A speciﬁcation consists of a description of a theory in terms of other
theories. Theory arrows connect the speciﬁed theory to its components.
Moreover, the components themselves are deﬁned in terms of one an-
other. Thus the environment in which a theory is deﬁned is a diagram
in the category of theories. A speciﬁcation denotes a theory and its con-
nection to an environment, that is, it denotes a cocone in the category
of theories. We call cocones based objects and their arrows based arrows.
Based arrows are cocone arrows for which the arrow between bases is an
inclusion. This restriction on the arrows expresses the way environments
combine. These ideas were introduced in [Burstall, Goguen 80], a paper
which should be consulted for more details.
Deﬁnition 30 Let ∆be a diagram in a category C. Deﬁne the category
C∆to have, as objects, cocones whose bases are subdiagrams of ∆and,
as arrows, cocone arrows which are inclusions on bases.
Operations for combining speciﬁcations are interpreted as colimits of
based objects in the category of theories. Colimits of based objects in a
category C are constructed in terms of colimits in C. The construction
is given explicitly in [Burstall, Goguen 80]:
Proposition 12 If C is (ﬁnitely) cocomplete and ∆a (ﬁnite) diagram,
then C∆is (ﬁnitely) cocomplete.
Proof
Let δ be a (ﬁnite) diagram in C∆, with objects δn having apices
ˆδn and bases βi ⊆∆. The colimit of δ is constructed as follows. Its
base β is S
n βn. Its apex is the colimit object of the diagram δ′ which
results from ‘ﬂattening’ δ restricted to β; more precisely, the objects of
the diagram δ′ are the objects of β plus the ˆδn (i.e. the coproduct); the
arrows of δ′ are those of β plus the cocone arrows in each δn. Finally,
the sides of the colimiting cocone are those resulting from the colimit of
δ′. The universal property can be veriﬁed.
2
This construction can be programmed to give a function of type:
based_object_colimit: (’o,’a)CoComplete_Cat ->
((’o,’a)Based_Obj,(’o,’a)Based_Arrow)Colimit

The category of based objects and their colimits is then:
fun cocomplete_cat_of_based_objs(cC) =
let val cocomplete_cat(C,_) = cC in
cocomplete_cat(cat_of_based_objs(C),
based_object_colimit(cC)) end
9.6
Semantic operations
The denotation of a speciﬁcation is a based object in the category of the-
ories – naturally called a based theory. Some of the semantic operations
are described in terms of colimits in the category of based theories. We
describe these below.
Combine
The combine operation is the coproduct of two theories taking into ac-
count the theories shared in the environment. This is, by construction,
the coproduct in the category of based theories:
fun combine(cSig)(b,b’) =
let val cC = cocomplete_cat_of_based_objs
(cocomplete_cat_of_theories(cSig))
val ((sumbb’,_,_),_) = coproduct(cC)(b,b’) in
sumbb’ end
Enrich
The enrichment operation is a simple manipulation of signatures and sets
of sentences as follows.
The theory T to be enriched is a based theory. The enrichment is
a theory arrow from the signature of the apex ˆT of T to the body of
the enrichment. The resultant based theory is obtained by extending the
theory arrow to ˆT and then composing this with the sides of the cocone
T.
fun enrich(Sig)(t,theory_arrow(_,g,theory(sig’,sen’))) =
let val th as theory(_,sen) = apex(t)
val th’ =
theory(sig’,closeU(sen’,closetrans(g,sen)))
val th_arrow = theory_arrow(th,g,th’) in
cocone_compose(cat_of_theories(Sig))(t,th_arrow) end

The function cocone compose takes a cocone and an arrow out of the
apex and constructs a new cocone in an obvious manner.
Procedures
The application of a procedure to its arguments is described as a pushout
of based theories.
The denotation of a procedure is a based theory arrow from the co-
product of the requirement theories to the body of the procedure. The
application of a procedure takes this based theory arrow and a list of
ﬁtting arrows and yields the pushout based theory.
fun apply(cSig)(proc,fittings)
let val cC as cocomplete_cat(bth,_) =
cocomplete_cat_of_based_objs
(cocomplete_cat_of_theories(cSig))
val fa = list_coproduct(cC)(fittings)
val ((p,q),_) = pushout(cC)(proc,fa) in
target(bth)(p) end
The other speciﬁcation-building operations may also be described
in this categorical framework: The restriction to free interpretation is
achieved by so-called data constraints which behave exactly as sentences
in an institution. The ‘derive’ operation is a factorization of based theory
arrows.
9.7
Implementing a categorical semantics
It is not the intention of this section to describe in full detail either the
semantics of the speciﬁcation language Clear or the implementation of
this semantics undertaken by Don Sannella and the authors.
We have explained how the speciﬁcation building operations are in-
terpreted as constructions in a category. We sketch brieﬂy how these
provide a semantics for a speciﬁcation language.
The abstract syntax of the language is deﬁned as an ML type:
datatype Exp = just of Name
| theory of Enr
| plus of Exp * Exp
| enrich of Exp * Enr
| derive of Enr * (Exp)Set * Exp * Sic

| apply of Name * (Exp*Sic)list
| let_th of Name * Exp * Exp
The type Sic is that of signature changes, which are expressions
denoting signature arrows. The type of enrichments, Enr, is either an
ordinary enrichment (just some sorts, operations and equations) or a
data enrichment.
Omitting some details concerning syntactic classes and dictionaries
(for keeping track of names), we are in a position to deﬁne the semantics.
Environments are diagrams, whilst procedure environments associate
a procedure name with an arrow of based theories and a list of based
theories – the requirements.
The semantic function gives the denotation of expressions as based
theories.
E: Exp -> ((’o,’a)CoComplete_Cat ->
((’o,’a)Env -> ((’o,’a)ProcEnv -> (’o,’a)Based_Theory)))
For example, the expression for combining two theories is deﬁned by:
fun E(plus(e1,e2))(cSig)(rho)(pi) =
combine(cSig)(E(e1)(cSig)(rho)(pi),E(e2)(cSig)(rho)(pi))
The other expressions are handled in a similar style, invoking the ap-
propriate categorical constructions. Full details of the semantics may be
found in [Burstall, Goguen 80]. For descriptions of this implementation
consult [Sannella 82] or [Rydeheard 81].
As a practical implementation of a speciﬁcation language, this is not
satisfactory. It is a large program which runs slowly. For the sake of com-
parison and to get a practical program, Don Sannella [1984] has written a
direct implementation of a variant of this semantics. The semantic oper-
ations, instead of being interpreted in a general category, are specialized
to operations on equational theories and are given directly in set theory.
This speeds up the the program considerably, suggesting that a source
of ineﬃciency is the use of general high-level code. It also suggests that
this improvement may be achievable through program transformation
but this is not clear. However, it seems that much of the improvement is
due to the reduced size of the programs and data structures in the ML
system.

Chapter 10
Formal Systems for
Category Theory
The advent of computing has given renewed interest in formal systems for
describing areas of mathematics. The interest is not simply metamathe-
matical – establishing properties of formal systems – but practical. We
actually want to formalize mathematics for machine processing.
We have seen in previous chapters how constructions from category
theory can be expressed in the programming language ML. In this chapter
we consider formal (linguistic) aspects of category theory. We list some
of the requirements on a formalism for category theory. Some of these
we have come across as features of ML, others arose where ML proved
inadequate for programming category theory.
We also display fragments of category theory written in some machine-
implemented languages other than ML. This is not meant to be an ex-
haustive account but merely to indicate possibilities. We consider two
languages: OBJ, a language of theories and algebras, and GTTS, an
implementation of a constructive type theory. We also look at Hagino’s
[1987] system in which universal constructs in category theory are used
as a general type deﬁnition mechanism. We are indebted to J. A. Goguen
for allowing us to present his OBJ program and to R. Dyckhoﬀfor al-
lowing us to report his formulation of category theory in a variant of
Martin-L¨of’s type theory. The latter has appeared as [Dyckhoﬀ85].
An interesting use of cartesian closed categories in programming oc-
curs in the Categorical Abstract Machine. We do not describe this here;
a full account may be found in [Curien 86].
203

10.1
Formal aspects of category theory
Category theory provides a language for elementary (ﬁrst order) descrip-
tions of some general phenomena in mathematics. Mathematicians have
been interested in this linguistic aspect of category theory, partly from a
foundational point of view so as to avoid paradoxes, and partly to turn
the notation used in practice into a formal framework, see [B´enabou
85]. Our interest is in appropriate languages in which to embed category
theory for machine processing.
Here we list some formal aspects of category theory:
• Categories are algebraic – they can be presented in terms of opera-
tions and equations. This applies also to categorical concepts such
as products, coproducts, and equalizers.
The operations may be only partially deﬁned, for example com-
position is deﬁned not on all pairs of arrows but only on compos-
able pairs. This is called ‘equational partialness’, or ‘essentially
algebraic’ [Freyd 72], in that operations can be arranged in or-
der so that the domain of deﬁnition of each partial operation is
an equation in preceding operations. Equational partialness has
been investigated by Cartmell [1978], Benecke and Reichel [1982]
and Burmeister [1986]. The somewhat more general notion of ‘left
exact theories’ is discussed in [Barr, Wells 85] and [McLarty 86].
Lambek and Scott [1986] point out that categories are graph alge-
bras – algebras whose carriers are graphs rather than sets. There
are also formal systems for handling more general kinds of partial
functions. These include order-sorted algebras [Goguen 78], con-
ditional rewriting systems [Bergstra, Klop 82], multi-valued logics
[Barringer et al.
84], deﬁnedness operators [Scott 79] and [Bee-
son 86], the logic of computable functions, LCF, [Gordon et al.
79], domain-theoretic methods [Plotkin 1985] and categorical ap-
proaches to partial functions [Robinson, Rosolini 86].
• Commutative diagrams abound in category theory.
Categorical
reasoning in the form of ‘diagram chasing’ is typed equational de-
duction as pointed out by Huet [1986] and is open to some form
of automation [Watjen, Struckmann 82].
The diagrammatic na-
ture of category theory suggests the use of programming languages
more pictorial than current languages.
• We often consider categories whose class of objects encompasses

all algebraic structures of a certain kind, for example, varieties
of algebras or categories of functors. These categories are second
order structures. Formalisms based on theories and their algebras,
such as program modules, are inherently ﬁrst order and cannot
cope with such categories.
Though modules have a type (their
‘interface’ – a signature or theory), this cannot appear as a type
within a module.
• Category theory supports a principle of duality.
The theory is
invariant under ‘reversing arrows’. This may be formalized at a
meta-level as a truth-preserving transformation of formulae in cat-
egory theory. Thus for each proof, we obtain two theorems, that
proven and its dual. Duality may be expressed as an operation on
categories, taking a category to that with its arrows reversed. This
may be programmed and allows us to obtain two calculations from
a single program through composition with duality operations.
• Inﬁnite structures naturally arise in category theory, even if we
restrict ourselves to computational aspects of the theory. An ex-
ample is the construction of term algebras on ﬁnite sets. We may
introduce recursive or r.e. sets to accommodate such constructions
but it often seems more natural to describe these inﬁnite sets as
types rather than values. For instance, we want the type of lists, as
well as that of integers, to be objects in the category of monoids.
This ‘objects as types’ is especially necessary when dealing with
term algebras as they introduce new deﬁnitional mechanisms for
functions. By moving to categories in a higher universe we may let
objects range over types as required.
• There is a correspondence between typed functional programming
and category theory. Types correspond to objects, functions are
arrows and type constructors are functors.
However, functions,
in the presence of possible non-termination, are partial functions,
whereas arrows are usually taken to be total (e.g. in Set).
• Reﬂection principles and predicativity. Category theory is unusual
amongst mathematical theories in that categories are objects in a
category whose arrows are functors. Most type theories are pred-
icative in character and cannot comfortably handle such reﬂection.
For instance in [Martin-L¨of 84] there is a hierarchy of type uni-
verses. We can introduce categories whose objects have types rang-
ing over a universe. However, categorical constructions are coded

for each universe and cannot be applied to higher universes even
though the construction is identical for each universe. Attempts to
work within one universe can lead to inconsistency, as discussed by
Coquand [1986].
• Categories like Set and FinSet are non-homogeneous structures
in that the type of elements in the sets varies with the set. ML
polymorphism is not suﬃcient to deal with these structures.
If
only homogeneous categories of sets are considered then operations
on objects impose requirements on the type of the elements. For
example, the disjoint union of sets constructed as a labelled union
requires the labelled elements to be of the same type as the original
elements.
• We have emphasized that universal constructs in category theory
can be expressed as higher order functions. Higher order structure
abounds in category theory, for example, the the action of the free
monoid functor on arrows is the ‘maplist’ function (‘mapcar’ in
Lisp) deﬁned in ML by
fun maplist(f)(nil) = nil
| maplist(f)(x::s) = f(x)::maplist(f)(s)
Goguen, in the OBJ example below, shows how some of these higher
order functions can be treated in a ﬁrst order framework.
• Equality on objects. When working in category theory we do not
usually make statements like ‘for objects a and b, a = b’.
We
consider isomorphism rather than equality on objects. However,
the deﬁnition of a category requires that composition is deﬁned for
pairs g, f such that the source of f is equal to the target of g –
an equality on objects. We came across this matter in Chapter 3
when writing programs for the composition function. It is discussed
in [B´enabou 85], where a distinction is drawn between what is
expressible in category theory and what is expressible in a meta-
language in which we deﬁne categories.
We now turn to category theory expressed in several quite diﬀerent
formalisms.

10.2
Category theory in OBJ
OBJ is a language based upon on theories and algebras. Theories serve as
speciﬁcations of intended behaviour whilst algebras are implementations
of the theories. Algebras are called ‘objects’ in OBJ. Beware of confusion
with objects in categories. OBJ was devised by J. A. Goguen and ﬁrst
implemented by J. Tardo [Goguen, Tardo 79]. We use a version of OBJ3
[Goguen 88], which developed from OBJ2 [Futatsugi et al. 85].
Theories and algebras are presented as collections of operations to-
gether with axioms which are either equations or conditional equations.
OBJ is a programming language in which evaluation is equational rewrit-
ing using the axioms in algebras. Theories and algebras are linked by
‘views’ which assert that an algebra is considered as belonging to a given
theory. A view is a renaming map, mapping names of sorts and opera-
tions in the theory to those corresponding in the algebra.
Let us have a look at a simple example of theories and algebras so as
to ﬁx notation. In the example below we deﬁne the theory (introduced
by th) of monoids (semigroups with identity). We introduce a particular
monoid as an OBJ object (introduced by obj) and assert through a view
that the object is an algebra of the theory of monoids.
th MONOID is
sort El .
op _;_ : El El -> El [assoc] .
op E : -> El .
var A : El .
eq : A ; E = A .
eq : E ; A = A .
endth
obj INTS is
protecting INT .
op _++_ : Int Int -> Int [assoc] .
op two : -> Int .
vars A B : Int .
eq : A ++ B = A * B - A - B + 2 .
eq : two = 2 .
endo
view INTS-AS-MONOID from MONOID to INTS is
sort El to Int .

op : _;_ to : _++_ .
op : E to : two .
endv
Equational rewriting in OBJ makes special provision for some ax-
ioms like associativity, commutativity, idempotence and identity. These
are treated as attributes of operations and special routines are built-in
for matching and uniﬁcation in the presence of these axioms. This is
illustrated above where the binary operation in a monoid is associative.
It also has an identity which we could treat in the same way but in-
stead make into an operation satisfying appropriate equations, so as to
illustrate equations in a theory. Denotationally these are the same, but
operationally the equations serve as left to right rewrite rules, whereas
the specialist matching algorithm for identity will match in both direc-
tions. Equations may be conditional, in which case the condition, an
equation, is evaluated to determine whether or not the rewrite rule is
applicable.
OBJ allows operations to be partial (indicated by ‘op as’) with the
domain of deﬁnition given by equations in preceding operations. This
form of partialness goes under various names including ‘equational par-
tialness’ [Burmeister 86], ‘essentially algebraic’ [Freyd 72] and the some-
what more general ‘left exact’ [Barr, Wells 85].
In OBJ, the sorts may be partially ordered so that one sort S is a
subsort of another S’, written S < S’. When this occurs, operations on
S’ may be applied to values of sort S, whereas operations returning values
of sort S may be considered to return values of sort S’.
Theories and algebras may be built using already deﬁned theories
and algebras. In the example above we build the monoid INTS from that
of integers INT but we wish to protect integers from modiﬁcation (e.g. by
adding an equation like 1 = 2). Structures may be parameterized using a
parameterization technique similar to that of Clear discussed in Chapter
9. As an example, we consider an algebra of lists:
obj LIST[X :: TRIV] is
sorts List .
subsorts Elt < List .
op _._ : List List -> List [assoc, id : nil] .
endo
This is parametrized on the type of elements in the list. Their are no
requirements on the elements to form lists so the formal parameter X is

matched to the trivial theory TRIV having just one sort Elt. We use
the subsort mechanism to assert that elements are singleton lists. Lists
of, say, integers are obtained by instantiating with a view showing how
integers may be considered as algebras of TRIV:
view INT-AS-TRIV from TRIV to INT is
sort Elt to Int .
endv
Then LIST[INT-AS-TRIV] denotes the OBJ object of lists of integers.
Non-trivial requirements on parameters occur, for example, in sorting
where we require the elements of lists to support an ordering, so must
match the theory of partial (or total) orders.
Because categories are algebras and categorical concepts tend to be
algebraic in nature, a language like OBJ would appear to be a use-
ful formalism for category theory.
Indeed, the equational partialness
and the special treatment of associative operations are just what is re-
quired for the composition of arrows. Moreover, the order which may be
imposed upon sorts allows us to express the conversion between types
when one type is extended by extra components or extra properties. An
example in category theory is the fact that colimiting cocones are co-
cones together with their universality so we may write Colimit-CoCone
< CoCone. Structuring facilities, like those in OBJ, are essential in build-
ing large and complex systems, both to control the complexity and to
allow suﬃcient generality.
The framework of theories and algebras adopted by OBJ is ﬁrst or-
der. As already remarked, categories such as varieties of algebras and
categories of functors are second order structures in that their objects
range over all structures of a certain kind. Thus whilst we can deﬁne
the theory of categories and the theory of monoids in OBJ, we cannot
match the sort of objects in categories to the theory of monoids to form
the category of monoids. This may be circumvented but is a mismatch
between the OBJ treatment and mathematical practice.
We now turn to a fragment of category theory in OBJ3 kindly sup-
plied by J. A. Goguen. We begin with the theory of categories. The asso-
ciativity of composition and its partial nature are both directly
expressible:
th CAT-TH is
sorts Obj Arrow.
op d0_ : Arrow -> Obj .

op d1_ : Arrow -> Obj .
op-as _;_ : Arrow Arrow -> Arrow
for M1 ; M2 if d1 M1 == d0 M2 [assoc] .
op id_ : Obj -> Arrow .
var O : Obj .
vars A A0 A1 : Arrow .
eq : d0 id O = O .
eq : d1 id O = O .
eq : d0 (A0 ; A1) = d0 A0 .
eq : d1 (A0 ; A1) = d1 A1 .
eq : (id d0 A) ; A = A .
eq : A ; id d1 A = A .
endth
Categories of sets form algebras (OBJ objects) of this theory. The
categories of sets which we deﬁne are homogeneous, in that elements
of every set in a category have the same type.
We ﬁrst deﬁne these
categories and then deﬁne sets.
obj CAT-SET[X :: TRIV] is
protecting SET[X] .
sorts Fn .
op d0_ : Fn -> Set .
op d1_ : Fn -> Set .
op-as _;_ : Fn Fn -> Fn
for F1 ; F2 if d1 F1 == d0 F2 [assoc] .
op id_ : Set -> Fn .
op-as _of_ : Fn Elt -> Elt
for F of X if (X in d0 F) and (F of X in d1 F) .
var O : Set .
vars F F0 F1 : Fn .
var E : Elt .
eq : d0 id O = O .
eq : d1 id O = O .
eq : d0 (F0 ; F1) = d0 F0 .
eq : d1 (F0 ; F1) = d1 F1 .
eq : (id d0 F) ; F = F .
eq : F ; id d1 F = F .
eq : (F0 ; F1) of E = F0 of (F1 of E) .
eq : (id O) of E = E .
endo

The deﬁnition is parameterized over the type of elements in the sets.
The elements require no structure, so need only match the theory TRIV.
Objects in the category are sets imported from SET[X] which we deﬁne
below. Arrows are deﬁned as functions with a source set and a target set.
The functional behaviour of arrows is given by the application operation
‘of’. The last two equations deﬁne composition and identity in terms
of application. Moreover, arrows are total functions as asserted in the
condition for deﬁnedness of application.
A view is used to assert that this OBJ object matches the theory of
categories:
view CAT-SET-AS-CAT from CAT-TH to CAT-SET is
sort Obj to Set .
sort Arrow to Fn .
endv
Sets are usually deﬁned in terms of union and intersection. Instead,
to simplify the axiomatic treatment, we make intersection and symmetric
diﬀerence the primary operations, deﬁning union in terms of them. That
is, we introduce the Boolean ring of sets rather than the Boolean algebra.
A Boolean ring is a ring in which every element satisﬁes A.A = A. A
well-known result of algebra asserts that these two algebraic structures
are equivalent. For sets, multiplication is intersection and addition is
symmetric diﬀerence. We introduce a top element (a universal set Ω) as
well as a bottom element (the empty set) so that sets constructed from
the operations are either ﬁnite or formally coﬁnite, i.e. of the form Ω−S
for ﬁnite S.
obj BSET[X :: TRIV] is
protecting BOOL .
sort Set .
op {} : -> Set .
op omega : -> Set .
*** universal set
op {_} : Elt -> Set .
op _+_ : Set Set -> Set [assoc comm id: {}] .
*** symmetric difference
op _&_ : Set Set -> Set [assoc comm idem id: omega] .
*** intersection
vars S S’ S’’ : Set .
vars E E’ : Elt .
eq : S + S = {} .

ceq : { E } & { E’ } = {} if E =/= E’ .
eq : S & {} = {} .
eq : S &(S’ + S’’) = (S & S’)+(S & S’’) .
endo
Other standard operations on sets are deﬁned as follows:
obj SET[X :: TRIV] is
protecting BSET[X] .
protecting INT .
op _U_ : Set Set -> Set [assoc comm id: {}] .
op _-_ : Set Set -> Set .
op #_ : Set -> Int [prec 0] .
op _in_ : Elt Set -> Bool .
op _in_ : Set Set -> Bool .
op empty?_ : Set -> Bool .
var X : Elt .
vars S S’ S’’ : Set .
eq : S U S’ = (S & S’)+ S + S’ .
eq : S - S’ = S + (S & S’) .
eq : empty? S = S == {} .
eq : X in S = { X } & S =/= {} .
eq : S in S’ = S U S’ == S’ .
eq : # {} = 0 .
ceq : #({ X } + S) = # S if X in S .
ceq : #({ X } + S) = 1 + # S if not X in S .
endo
Let us look at binary coproducts in this formalism. We start with
binary cocones in a category. The OBJ code below describes cocones as
a pair of arrows with common target. It is parameterized on categories
and uses an OBJ object of pairs for bases of cocones.
obj CO2CONE[C :: CAT-TH] is
protecting 2TUPLE[Obj,Obj] * (sort 2Tuple to Base) .
sorts Co2cone .
op-as cocone : Arrow Arrow -> Co2cone
for cocone(A1,A2) if d1 A1 == d1 A2 .
op j1 : Co2cone -> Arrow .
op j2 : Co2cone -> Arrow .
op apex : Co2cone -> Obj .
op base : Co2cone -> Base .

vars A1 A2 : Arrow .
eq : j1(cocone(A1,A2)) = A1 .
eq : j2(cocone(A1,A2)) = A2 .
eq : apex(cocone(A1,A2)) = d1 A1 .
eq : base(cocone(A1,A2)) = << d0 A1 ; d0 A2 >> .
endo
Categories with coproducts form a theory in OBJ. An algebra of the
theory is a category together with a construction of coproducts of pairs of
objects. Coproducts, as universal cocones, are a subsort of cocones and
cocone operations are inherited implicitly. The universality is expressed
as an operation which, for a universal cocone and a cocone on the same
base, returns the mediating arrow. Unlike universality as expressed in
ML, this gives a ﬁrst order treatment by separating components and
using sorts and equations to link them. Notice that OBJ is really second
order in functionality as names are given to operations in theories. These
names may be bound to actual operations using a view.
th CO2PROD-TH[C :: CAT-TH] is
protecting CO2CONE[C] .
protecting BOOL .
sort Uco2cone .
subsorts Uco2cone < Co2cone .
op ucocone : Obj Obj ->Uco2cone . ***coproduct cocone
op _++_ : Obj Obj -> Obj .
*** coproduct object
op-as uarrow : Uco2cone Co2cone -> Arrow
for uarrow(U,C) if base(U) == base(C) .
vars A B : Obj .
vars F G H : Arrow .
eq: apex(ucocone(A,B)) = A ++ B .
eq: base(ucocone(A,B)) = << A ; B >> .
eq: (j1(ucocone(A,B)));uarrow(ucocone(A,B),cocone(F,G))
= F .
eq: (j2(ucocone(A,B)));uarrow(ucocone(A,B),cocone(F,G))
= G .
ceq: H = uarrow(ucocone(A,B),cocone(F,G))
if (j1(ucocone(A,B)); H == F)
and (j2(ucocone(A,B)); H == G) .
endth
We can now give a calculation of coproducts in the categories of sets
deﬁned above. Coproducts of sets are disjoint unions. Disjoint unions

may be expressed in various ways according to the type of elements in
the sets.
We abstract on this calculation by introducing a theory of
injection arrows into coproducts. The description of coproducts of sets
is parameterized on this theory. This is then specialized to sets of integers
using an arithmetic formula for the disjoint union.
th 2INJ-TH is
protecting BOOL .
sort Elt .
op i0 : Elt -> Elt .
op i0inv : Elt -> Elt .
op i0pred : Elt -> Bool .
op i1 : Elt -> Elt .
op i1inv : Elt -> Elt .
op i1pred : Elt -> Bool .
var E : Elt .
eq : i0inv(i0(E)) = E .
eq : i1inv(i1(E)) = E .
eq : i0pred(i0(E)) = true .
eq : i0pred(i1(E)) = false .
eq : i1pred(i1(E)) = true .
eq : i1pred(i0(E)) = false .
endth
obj CO2PROD-CAT-SET[X :: 2INJ-TH] is
extending CO2CONE[CAT-SET[X]] .
sort Uco2cone .
subsorts Uco2cone < Co2cone .
op ucocone : Set Set -> Uco2cone .
op-as uarrow : Uco2cone Co2cone -> Fn
for uarrow(U,C) if base(U) == base(C) .
op I0 : Set -> Set .
op I1 : Set -> Set .
op _++_ : Set Set -> Set .
vars A B S : Set .
vars F G : Fn .
var E : Elt .
eq : I0({}) = {} .
eq : I0({ E } + S) = { i0(E) } + I0(S) .
eq : I1({}) = {} .
eq : I1({ E } + S) = { i1(E) } + I1(S) .

eq : A ++ B = I0(A) U I1(B) .
eq : apex(ucocone(A,B)) = A ++ B .
eq : base(ucocone(A,B)) = << A ; B >> .
ceq : j1(ucocone(A,B)) of E = i0(E) if E in A .
ceq : j2(ucocone(A,B)) of E = i1(E) if E in B .
ceq : uarrow(ucocone(A,B),cocone(F,G)) of E =
F of i0inv(E) if i0pred(E) .
ceq : uarrow(ucocone(A,B),cocone(F,G)) of E =
G of i1inv(E) if i1pred(E) .
endo
view CO2PROD-CAT-SET-AS-CO2PROD-TH[J :: 2INJ-TH]
from CO2PROD-TH[CAT-SET[J]] to CO2PROD-CAT-SET[J] endv
The category of sets of integers with an explicit calculation of co-
products is deﬁned below. A view is used to instantiate the theory of
coproducts to the coproduct injections calculated numerically.
obj CAT-SET-INT is
protecting CAT-SET[INT] * (op omega to ints) .
endo
obj CO2PROD-CAT-SET-INT is
protecting CO2PROD-CAT-SET[view from 2INJ-TH to INT is
sort Elt to Int .
var I : Elt .
op : i0(I) to : (2 * I) .
op : i0inv(I) to : (I quo 2) .
op : i0pred(I) to : (I rem 2 == 0) .
op : i1(I) to : 1 + (2 * I) .
op : i1inv(I) to : ((I - 1) quo 2) .
op : i1pred(I) to : (I rem 2 == 1) .
endv] .
endo
view CO2PROD-CAT-SET-INT-VIEW
from CO2PROD-TH[CAT-SET-INT]
to CO2PROD-CAT-SET-INT endv

10.3
Category theory in a type theory
We now look at a fragment of category theory in a type theory for con-
structive mathematics. Type theories are organized around types and
values and the notion that a value has a particular type. Usually, type
constructors include dependent types and some form of type universes
as well as product and function types. Rules are given by which we may
establish whether a given expression is a type and whether an expression
for a value belongs to a particular type. Unlike type systems in program-
ming languages, these theories allow types to be deﬁned with axiomatic
constraints. Type checking is often not decidable. Programs appear in
this framework as constructive proofs. This is to be contrasted with OBJ
where both types (sets and operations on them) and algorithms (rewrite
rules) are identiﬁed in the concept of an OBJ object.
A variety of constructive type theories have been proposed including
those of Martin-L¨of [1975,82,84] and Feferman [1975,79], the Theory of
Constructions [Coquand, Huet 85], the ‘logical’ theories of [Aczel 80]
and [Dybjer 85] and the Logical Framework (LF) [Harper et al.
87].
Automated systems have been developed such as Nuprl [Constable et al.
85] and the G¨oteborg Type Theory System [Petersson 84], both based
on Martin-L¨of’s work, and the Automath system [de Bruijn 80]. The
Theory of Constructions and the Logical Framework are also available
as machine implementations.
We summarize the work of Roy Dyckhoﬀ[1985] in developing an
experimental implementation of category theory in the G¨oteborg Type
Theory System (GTTS) which implements a type theory of Martin-L¨of.
Inference rules are presented in the natural deduction style, so are orga-
nized into those that introduce operators and those that eliminate them.
Moreover there are rules for establishing equality of types and of values.
To implement category theory in such a system we may represent the
types (like that of categories) and values (like FinSet) in terms of those
provided by the system and hence use the inference rules of the system
itself.
Categories are introduced axiomatically and it is necessary to
prove that such an axiomatic presentation denotes a type of the system.
This approach is logically sound but leads to clumsy notation and fails
to capture the linguistic content of category theory in providing a typed
arrow-theoretic language.
There is an alternative. Expand the type system with new rules for
type formation (for the type of categories, functors and other categorical
concepts such as natural transformations) and value formation (such as

the composition of arrows). Adding new rules may violate consistency,
so a meta-level proof of consistency is required.
To express the fact that categories form a type we use the simple rule
of type formation in which the requirements for forming the type (above
the horizontal line of the rule) are empty:
CAT type
Strictly speaking, to avoid inconsistency, we should declare CAT to
be a type within a universe U1 (CAT : U1) and the subsequent rules
should be amended accordingly, replacing type with U1.
Declaring functors to be a type requires two categories. We form the
type of all functors between two categories as follows:
C : CAT
D : CAT
FUNC(C, D) type
We read this as ‘from the assertion that C and D are categories, infer
that FUNC(C, D) is a type’.
To introduce a value of type CAT we need some ingredients: a type
of objects, a family of types of arrows; two functions, identity and com-
position; and some axioms. This is the introduction rule for categories:
O type
A(X, Y ) type
[X : O, Y : O]
i : A(X, X)
[X : O]
c(f, g) : A(X, Z)
[X : O, Y : O, Z : O, f : A(X, Y ), g : A(Y, Z)]
c(f, i) = f : A(X, Y )
[X : O, Y : O, f : A(X, Y )]
c(i, f) = f : A(X, Y )
[X : O, Y : O, f : A(X, Y )]
c(f, c(g, h)) = c(c(f, g), h) : A(W, Z)
[W : O, X : O, Y : O, Z : O, f : A(W, X), g : A(X, Y ), h : A(Y, Z)]
Cat(O, A, i, c) : CAT
The lists in square brackets are the assumptions for the assertion to
the left, i.e. e [e′] is the assertion that e holds under the assumptions e′.
Notice how dependent types handle the source and target of arrows and
the partial nature of composition. Notice also the presence of axioms,
showing that we need rules for establishing equality of arrows. There is
a rule asserting that any category may be constructed as above. Elim-
ination rules allow us to extract components of categories (‘selectors’);
Ob and Arrow for the types of objects and arrows, and comp and id for
the composition and identity functions.
The rule for introduction of functors looks like:

C : CAT
F1(X) : Ob(D)
[X : Ob(C)]
F2(f) : Arrow(D, F1(X), F1(Y ))
[X, Y : Ob(C), f : Arrow(C, X, Y )]
F2(id) = id : Arrow(D, F1(X), F1(X))
[X : Ob(C)]
F2(comp(f, g)) = comp(F2(f), F2(g)) : Arrow(D, F1(X), F1(Z))
[X, Y, Z : Ob(C), f : Arrow(C, X, Y ), g : Arrow(C, Y, Z)]
Func(F1, F2) : FUNC(C, D)
Dyckhoﬀpresents rules for natural transformations and has imple-
mented a facility for reducing expressions for arrows using associativity
and identity laws. This fragment of category theory is presented with
some 40 inference rules.
He also presents some proofs in this system
including the reﬂexivity of isomorphism and the fact that the composite
of monics is a monic.
Particular categories are deﬁned using the introduction rule for val-
ues of type CAT. We may form a category of small types, i.e. types in
the universe U1, whose arrows from X to Y are values of type X →Y .
This category is cartesian closed. Other categories such as categories of
functors and categories of categories can be deﬁned within this frame-
work. For these we need to consider type universes and we get into the
hierarchical situation described earlier. The reﬂective nature of category
theory is not accommodated in this type theory.
10.4
Categorical data types
A very interesting implementation of some categorical concepts has been
undertaken by Tatsuya Hagino [1987,87a] at Edinburgh University. He
deﬁnes a programming language whose sole declaration mechanism is es-
sentially deﬁnition of a left or right adjoint functor. With this minimal
apparatus he is able to deﬁne the various features available in conven-
tional functional languages such as ML, for example, products, sums,
exponentials, data types and lazy (i.e. inﬁnitary) data types. Thus his
use of category theory is essentially to deﬁne a programming language
rather than to deﬁne particular programs. In fact, his work can be viewed
as a ‘rational reconstruction’ of a prototypical functional programming
language on categorical principles.
It is unclear whether his methods could be extended to cover the area
treated in this book. He works relative to a single underlying category,
U, which is uninterpreted but may be thought of as Set.
Types are
represented by objects, parameterized types by functors, functions by

arrows and data values by arrows from the terminal object. This diﬀers
from our approach in which values in ML correspond to objects and
perhaps seems more natural.
Each declaration is introduced with the key words right object or
left object and deﬁnes a type and some associated functions, i.e. a
functor and associated unit or co-unit natural transformations plus a
bijection between hom-sets. Some of the ﬂavour of the system may be
obtained from the following examples.
Products are declared to be a right adjoint in the following rather
succinct manner:
right object prod(t1,t2) with pair is
pi1: prod -> t1
pi2: prod -> t2
end object
In this deﬁnition a new functor prod is deﬁned together with the co-
unit, the pair of arrows pi1 and pi2 and the bijection pair : t1 × t2 →
prod(t1, t2).
The new functor is right adjoint to a functor which is
determined implicitly by the expressions after pi1 and pi2; this is the
diagonal functor from U to U×U. The pair of arrows correspond to the
co-unit of the adjunction.
In fact, the deﬁnition mechanism must be a little more general than
adjoints, and it is based on parameterized F,G-dialgebras. First, a T-
algebra over C, where T : C →C is a functor, is an object c and an
arrow f : T(c) →c. Extending this notion, given functors F, G : C →D,
Hagino deﬁnes an F,G-dialgebra as an object c together with an arrow
h : F(c) →G(c). Left and right objects are deﬁned in terms of initial
and ﬁnal F,G-algebras.
Deﬁnition 31 Let F, G : C →D be functors, the category DAlg(F, G)
has objects pairs ⟨c, f⟩where c is a C-object and f : F(c) →G(c) in
D, arrows from ⟨c1, f1⟩to ⟨c2, f2⟩are arrows h : c1 →c2 such that
G(h)f1 = f2F(h).
More precisely, Hagino uses parameterized F,G-dialgebras to deal
with parameterized data types. Consider functors H, K : A × B →D,
and write Ha(b) for H(a, b) and Ka(b) for K(a, b). Then for each a in A,
let ⟨Left(a), ηa⟩be the initial algebra of DAlg(Ha, Ka), if it exists. We
can extend Left to a functor from A to B, and ηa : Ha →Ka is a natural
transformation. Dually, we get a functor Right : A →B and a natural
transformation ϵ by taking the ﬁnal algebra, if it exists.

Given a functor F : A →D, we can put Ha(b) = b and Ka(b) = F(a);
Hagino shows that in this case Left is the left adjoint of F. Thus the con-
struction really does generalize the notion of adjunction. Interestingly,
it also yields comma categories as a specialization.
In a left object deﬁnition we supply H and K and hence deﬁne the
functor Left⟨H,K⟩and the natural transformation η as well as the map
from an arbitrary algebra to the unique dialgebra homomorphism to it.
This map φ corresponds to the bijection of hom-sets in an adjunction.
We illustrate this with the example of coproduct.
left object coprod(t1,t2) with case is
in1: t1 -> coprod
in2: t2 -> coprod
end object
Here the given information is:
• A is U × U – because there are two parameters, t1 and t2
• B is U – this is always the case
• D is U →U – because there are two arrows in1 and in2
• H(t1,t2)(coprod) is (t1, t2) – source of (in1, in2)
• K(t1,t2)(coprod) is (coprod, coprod) – target of (in1, in2)
and the results of the declaration are:
• Left is coprod : U × U →U – the new functor, a type constructor
• η(t1,t2) is (in1, in2) – the injection arrows
• φ is case – if f1 : t1 →t and f2 : t2 →t then case(f1, f2) :
coprod(t1, t2) →t
Exponentials are right adjoints deﬁned in terms of products. As well
as the new type, a curry function and an eval function are deﬁned.
right object exp(s,t) with curry is
eval: prod(exp,s) -> t
end object
Lists are deﬁned in terms of products as follows. The deﬁnition is
very like an ML data type deﬁnition, but it also delivers a functional to
do primitive recursion on lists.

left object list(t) with primitive_list_rec is
nil: 1 -> list
cons: prod(t,list) -> list
end object
A dual deﬁnition deﬁnes ‘lazy’ lists, that is inﬁnite lists.
Functions over the data types constructed in this way can be de-
ﬁned from the primitives provided by the left and right object deﬁni-
tions. Hagino uses composition rather than lambda abstraction to do
this, rather in the style of Backus’ FP language. He ﬁrst presents his
style of deﬁnition as a speciﬁcation language, an alternative to algebraic
speciﬁcation languages. This requires a precise description of well-formed
functorial expressions. He then shows that if the underlying category has
certain properties, notably cartesian closure, his deﬁnitions yield a Cat-
egorical Programming Language. The equations satisﬁed by the unit (or
co-unit), and by the bijection part of an adjunction generalized as shown
above, can be used as rewrite rules. This gives a evaluation algorithm,
which he has implemented to build an interpreter for his language in
Franz Lisp. Using Tait’s method, he proves that the computations al-
ways terminate, a substantial theoretical result given the power of his
language.
The remarkable aspect of Hagino’s Categorical Programming Lan-
guage is the economy of means with which he is able to deﬁne the vari-
ous facilities provided by the usual style of functional programming lan-
guage. Making use of one categorical deﬁnition mechanism, he no longer
has to take the terminal object, products, coproducts or exponentials as
primitive notions. He deﬁnes data types and lazy data types in a dual
manner. It should be noted that he is deﬁning a categorical program-
ming language, whereas in this book we have been using a traditional
functional programming language to code categorical constructions.


Appendix A
ML Keywords
The table below contains ML keywords together with a reference to the
page on which the ML construct is described.
Keyword
Page number
abstype
25
and
12
as
21
case
22
datatype
21
exception
26
fn
13
fun
13
handle
26
if then else
12
infix
13
let
12
of
22
raise
26
type
17
val
11
:
16
*, (,)
16
->
13
;
12
|
21
’
23
223


Appendix B
Index of ML Functions
add edge 87
adj cocontinuous 142
adj continuous 142
Adjunction 130
adjunction 130
AND 166
apply 51, 158, 201
arrow cat 166
arrow topos 168
blue 72
cardinality 25
Cartesian Closed Cat 156
cartesian closed cat 156
Cat 48
cat 48
cat of functors 116
cat of theories 197
cc FinSet 159
character 161
Closure 207
CoComplete Cat 81
cocomplete cat 81
cocomplete cat of based objs 200
cocomplete cat of graphs 110
cocomplete comma cat 109
cocomplete finset 90
CoCone 80
cocone 80
CoCone Arrow 81
cocone arrow 81
CoContinuous Functor 82
cocontinuous functor 82
Coequalizer 74
Colimit 81
Colimiting CoCone 81
colimiting functor 118
combine 200
Comma Arrow 105
comma arrow 105
comma cat 106
complete cat of graphs 120
complete FinSet 96
Components Adj 134
composite coequalize 181
Coproduct 71
Coproduct CoCone 71
Countable Coproduct 145
cross product 106
Diagram 80
diagram 80
Discrete 134
dotcomp 116
dual Adj 140
dual Cat 56
dual colimit 95
225

dual cone 94
dual diagram 94
dual Functor 56
dual graph 94
Edge 80
emptyset 25
enrich 201
EXISTS 171
Exponential 156
factorize 164
FALSE 165
ffunctor 54
finite colimit 88
finite coproduct 84
FinKleisli 52
FinSet 50
fixed point 150
fixpoint 152
FOR ALL 171
free algebra 146
function space 158
Functor 54
Graph 80, 147
graph 80
I 54
IMPLY 166
initial adj 138
InitialObj 69
is empty 25
IsoCat 145
isocat 145
isoFinSet 148
iso Graph 149
iterated coproduct 145
just 72
lift colimit 109
maplist 235
member 25
name 161
Nat transform 116
nat transform 116
Node 80
NOT 165
opr 51
OR 166
pair 95
Parallel Pair 147
Parallel Pair Arrow 147
pink 72
Power 164
power 164
pp 147
pp arrow 147
PullBack Square 161
Pushout 74
relation compose 98
remove 25
ringcomp 116
Set 25
Set Arrow 49
set arrow 49
set coequalizer 90
set coproduct 72
set equalizer 96
set initial 70
set product 96
set terminal 96

singleton 25
singleton split 25
split 25
star 148
Subobject Classifier 161
Substitution 51
subst 51
subst apply 51
sum coequalize 181
Tag 72, 95, 157
Term 51
ternary coproduct 77
Theory 197
theory 197
Theory Arrow 197
theory arrow 197
theory coproduct 198
Topos 161
topos 161
topos of sets 162
transitive close 149
true 161
ttrue 95
UA to ADJ 131
unify 185
union 25
unitcat 138
Universal Adj 130
universal adj 130
Universal Arrow 130
var 51
w Chain 149
w Colimit 150
w Colimiting CoCone 150
w CoComplete Cat 150
w cocomplete cat 150
w cocone 150
w CoCone 150
w CoCone Arrow 150
w cocone arrow 150
X 54


Appendix C
Other ML Functions
This is a list of ML functions which are used in the text, excluding those
in Appendix B. In the main, these are simple functions and, to avoid
interrupting the text, their action is described here.
applyda
Applies a diagram of functors to an arrow, returns
a diagram arrow
applydo
Applies a diagram of functors to an object, returns
a diagram
apply Fun Diag
Applies a functor to a diagram
apply Fun CoCone
Applies a functor to a cocone
apply Nat Diag
Applies a natural transformation to a dia-
gram, returns a diagram arrow
a prod o within
In a complete category, the product of an
arrow with the identity arrow on an object
as functor
The functor obtained by ﬁxing an argument of
a bifunctor
base
Extracts the base diagram of a cocone
co apex
Extracts the apex of a cocone
co apex arrow
Extracts the arrow between the apices of a
cocone arrow
compose
Takes a category, returns its composition of arrows
coproduct
Takes a cocomplete category, returns a binary
coproduct function
domain
The source category of a functor
fn to list
Converts ﬁnite functions to association lists
(their graphs)
Fun comp
The composition of functors
229

identity
Takes a category, returns the function assigning
identity arrows to objects
list to fn
Converts association lists (graphs of functions)
into functions
mapset
The image of a set through a function
new cocone
In a category, takes cocone ξn : ∆′
n →a on
diagram ∆′ and a diagram arrow δ : ∆→∆′, returns the
cocone ξnδn : ∆n →a
obj at node
Takes a diagram, returns the object at a given
node
OF
Applies an arrow in FinSet to an element of the source
set
ofa
Applies a functor to an arrow
ofa
Applies a functor to an object
product
Takes a complete category, returns a product func-
tion
pushout
Takes a cocomplete category, returns a pushout
function
pullback
Takes a complete category, returns a pullback
function
range
The target category of a functor
restrict
The restriction of an arrow in FinSet to a subset
of the source
sides
Takes a cocone, returns the function from nodes in
the base to arrows to the apex
signature
Given a category of signatures (in an institu-
tion), the functor returning the signature of a theory
sharp
Takes an adjunction (F, G, η, ϵ), returns the function
(f : a →G(b)) 7→(f # : F(a) →b)
source
Takes a category, returns its source function
target
Takes a category, returns its target function
terminal obj
The terminal object in a complete category
terminal arrow
In a complete category, the unique arrow
from an object to the terminal object

Appendix D
Answers to Programming
Exercises
These are answers to the programming exercises in Chapter 2. They are
mainly transcripts of ML sessions.
1.
val x = 3; val y = 4 and z = x+1
> val x = 3 : int
> val z = 4 : int
val y = 4 : int
let val x = 1 and y = 2 in x+y end
> 3 : int
val p = 3 and q = p+1
Type checking error in: p
Unbound value identifier: p
let val (x,y) = (2,3) in 2*x + y end
> 7 : int
let val x = 1 in
let val y = x+2 in
let val x = 5 in x+y end end end
> 8 : int
231

val (x, y as (_,p)) = ((2,3),(4,(5,6)))
> val p = (5,6) : int * int
val y = (4,(5,6)) : int * (int * int)
val x = (2,3) : int * int
2.
fun sign(n: int) = if n < 0 then false else true
fun absvalue(n:int) = if n < 0 then 0-n else n
fun max(m,n:int) = if m < n then n else m
fun fib(n) = if n=0 then 1 else
if n=1 then 1 else fib(n-1) + fib(n-2)
3.
fun numprint(zero) = 0
| numprint(succ(n)) = 1+ numprint(n)
fun mult(zero,n) = zero
| mult(succ(m),n) = add(n,mult(m,n))
4.
fun apply(f)(x) = f(x)
> (’a -> ’b) * ’a -> ’b
fun compose(g,f) = fn x => g(f(x))
> (’b -> ’c) * (’a -> ’b) -> (’a -> ’c)
5.
fun listmax(nil) = 0 | listmax(x::s) = max(x,listmax(s))
fun sum(nil) = 0 | sum(x::s) = x + sum(s)
fun poly(nil)(x:int) = 0
| poly(a::s)(x) = a + x * poly(s)(x)
fun reverse(nil) = nil
| reverse(x::s) = append(reverse(s),[x])
fun maplist(f)(nil) = nil
| maplist(f)(x::s) = f(x)::maplist(f)(s)

The accumulate function can be written in two ways depending on which
end of the list we start at:
fun accumulate(f)(initial)(nil) = initial
| accumulate(f)(initial)(x::s) =
f(x,accumulate(f)(initial)(s))
fun accumulate(f)(initial)(nil) = i
| accumulate(f)(initial)(x::s) =
accumulate(f)(f(x,initial))(s)
6.
fun breadth(tip n) = 1
| breadth(node(s,t)) = breadth(s) + breadth(t)
fun depth(tip n) = 1
| depth(node(s,t)) = 1 + max(depth(s),depth(t))
fun flatten(tip n) = [n]
| flatten(node(s,t)) = append(flatten(s),flatten(t))
7.
abstype Rat = fraction of (int * int)
with fun intrat(n) = fraction(n,1)
val zero = intrat(0)
val one
= intrat(1)
fun numerator(fraction(n,d)) = n
fun denominator(fraction(n,d)) = d
fun add(fraction(n,d),fraction(n’,d’)) =
fraction(n*d’+n’*d,d*d’)
fun minus(fraction(n,d),fraction(n’,d’)) =
fraction(n*d’-n’*d,d*d’)
fun times(fraction(n,d),fraction(n’,d’)) =
fraction(n*n’,d*d’)
fun mkrat(n,d) = fraction(n,d)
end
Other functions may be deﬁned in the abstract type. The type could
be modiﬁed so that fractions are kept in their reduced form or displayed
without any common factors between numerator and denominator.

8.
fun delete(n)(x,nil) = nil
| delete(n)(x,a::s) = if n=1
then if x=a then s else a::delete(n)(x,s)
else if x=a then a::delete(n-1)(x,s)
else a::delete(n)(x,s)
fun sublist(nil,t) = true
| sublist(a::s,nil) = false
| sublist(a::s,b::t) =
if a=b then sublist(s,t) else sublist(a::s,t)
fun number_of_sublists(nil,t) = 1
| number_of_sublists(a::s,nil) = 0
| number_of_sublists(a::s,b::t) =
if a=b then number_of_sublists(s,t) +
number_of_sublists(a::s,t)
else number_of_sublists(a::s,t)
9.
fun disjoint_union(s,t) =
union(image(fn x => (x,0))(s),image(fn x => (x,1))(t)
fun product(s,t) = if is_empty(s) then emptyset else
let val (x,s’) = singleton_split(s) in
union(image(fn y => (x,y))(t),product(s’,t)) end
fun powerset(s) =
if is_empty(s) then singleton(emptyset) else
let val (x,s’) = singleton_split(s)
val ps’ = powerset(s’) in
union(image(fn t => union(singleton(x),t))(ps’),ps’)
end
10.
datatype BTree =
empty | tip of int | node of BTree*int*BTree
fun insert(n,empty) = tip(n)
| insert(n,tip(m)) =
if n < m then node(tip(n),m,empty)

else node(empty,m,tip(n))
| insert(n,node(s,m,t)) =
if n < m then node(insert(n,s),m,t)
else node(s,m,insert(n,t))
fun flatten(empty) = nil | flatten(tip(n)) = [n]
| flatten(node(s,m,t)) =
append(flatten(s),m::flatten(t))
fun maplist(f)(nil) = nil
| maplist(f)(a::s) = f(a)::maplist(f)(s)
fun sort(s) = flatten(accumulate(insert)(empty)(s))
11.
We give the deﬁnition of the map f 7→f # and then some example uses.
fun list_extend(e,star)(f) =
fn nil => e
| a::s => star(f(a),list_extend(e,star)(f)(s))
> val list_extend = fn :
(’a * ((’b * ’a) -> ’a)) ->
((’c -> ’b) -> ((’c list) -> ’a))
val length =
list_extend(0,fn (x,y:int) => x+y)(fn x => 1)
val set_of_elements =
list_extend(emptyset,fn (x,y) => union(x,y))
(fn x => singleton(x))
val sum = list_extend(0,fn (x,y:int) => x+y)(fn x=>x)

• LNCS = Lecture Notes in Comp. Sci., Springer-Verlag, Berlin.
• LNM = Lecture Notes in Math., Springer-Verlag, Berlin.
Abelson, H. and Sussman, G.J, with Sussman, J. (1985) Structure and
Interpretation of Computer Programs.
MIT Press, Cambridge,
Mass.
Aczel, P. (1977) The Strength of Martin-L¨of’s Type Theory with One
Universe.
Proc.
Symp.
Math.
Logic, Oulu, Dept.
Philosophy,
University of Helsinki, pp. 1–32.
Aczel, P. (1980) Frege Structures and Notions of Proposition. In (eds.)
Barwise, Keisler and Kunen, The Kleene Symposium. North-Holland,
Amsterdam, pp 31–59.
Ad´amek, J. (1977) Colimits of Algebras Revisited. Bull. Austral. Math.
Soc., 17. pp. 433–450.
Ad´amek, J. (1978) Construction of Free Ordered Algebras.
Internal
report, Faculty of Elect. Engin. Fel Cvut, Suchbatrarova 2. 166
27 Praha 6, Czechoslovakia.
Ad´amek, J. and Koubek, V. (1980) Are Colimits of Algebras Simple to
Construct? J. Algebra, 66, pp. 226–250.
Ad´amek, J. and Trnkova, V. (1978) Varietors and Machines. Comp.
and Inform. Science Tech. Report 78–6, University of Massachusetts
at Amherst.
Aho, A.V., Hopcroft, J.E. and Ullman, J.D. (1974) The Design and
Analysis of Computer Algorithms. Addison-Wesley.
Alagi´c, S. (1975) Natural State Transformations. J. Comp. Sys. Sci.,
10, pp. 266–307.
Arbib, M. and Manes, E. (1974) Machines in a Category: An Expository
Introduction. SIAM Rev., 16, 2, pp. 163–192.
Arbib, M. and Manes, E. (1975) Arrows, Structures and Functors: The
Categorical Imperative. Academic Press, London.
Arbib, M. and Manes, E. (1975a) Adjoint Machines, State-Behavior
Machines and Duality. J. Pure and Applied Algebra, 6, pp. 313–
344.

Backus, J. (1978) Can programming be liberated from the Von Neu-
mann style? Comm. ACM, 21, 8, pp. 613–641.
Barr, M. (1970) Coequalisers and Free Triples. Maths Z., 2, 116, pp.
307–332.
Barr, M. and Wells, C. (1985) Toposes, Triples and Theories. Grund-
lehren der mathematischen Wissenschaften, 273, Springer-Verlag,
New York.
Barringer, H., Cheng, J.H. and Jones, C.B. (1984) A Logic Covering
Undeﬁnedness in Program Proofs. Acta Informatica, 21, pp. 251–
269.
Barwise, J. (1974) Axioms for Abstract Model Theory. Annal Math.
Logic, 7, pp. 221–265.
Beeson, M.J. (1985) Foundations of Constructive Mathematics: Meta-
mathematical Studies. Springer-Verlag, Berlin.
Beeson, M.J. (1986) Proving Programs and Programming Proofs. Proc.
Logic, Methodology and Philosophy of Science VII, Elsevier Science.
pp. 51–82.
B´enabou, J. (1985) Fibered Categories and the Foundations of Naive
Category Theory. J. Symbolic Logic, 50, 1, pp. 10–37.
Benecke, K. and Reichel, H. (1982) Equational Partiality. Algebra Uni-
versalis, 15, pp. 306–358.
Bergstra, J.A. and Klop, J.W. (1982) Conditional Rewrite Rules: Con-
ﬂuency and Termination. Internal report, Mathematisch Centrum,
Amsterdam.
Birkhoﬀ, G. (1938) Structure of Abstract Algebras. Proc. Camb. Phil.
Soc., 31, pp. 433–454.
Blass, A. (1984) The Interaction between Category Theory and Set The-
ory. Proc. of the Special Session on the Mathematical Applications
of Category Theory, 89th Annual Meeting of the American Mathe-
matical Society, (ed.) J.W. Gray, Contemporary Mathematics, 30,
American Mathematical Society.

Boehm, H., Demers, A. and Donahue, J. (1980) An Informal Description
of Russell.
Technical report, Dept.
Computer Science, Cornell
University.
de Bruijn, N.G. (1980) A Survey of the Project Automath. In (eds.)
J.R. Hindley and J.P. Seldin, To H.B. Curry: Essays on Combi-
natory Logic, Lambda Calculus and Formalisms, Academic Press,
London.
Burmeister, P. (1982) Partial Algebras – A Survey of a Unifying Ap-
proach towards a Two-valued Model Theory for Partial Algebras.
Algebra Universalis, 15, pp. 306–358.
Burmeister, P. (1986) A Model Theoretic Oriented Approach to Partial
Algebras. Akademie-Verlag, Berlin.
Burstall, R.M. (1980) Electronic Category Theory. Invited paper, Proc.
9th Annual Symposium on the Mathematical Foundations of Com-
puter Science, Rydzyua, Poland.
Burstall, R.M. and Darlington, J. (1977) A Transformation System for
Developing Recursive Programs. J. ACM, 24, pp. 44–67.
Burstall, R.M. and Goguen, J.A. (1977) Putting Theories Together to
Make Speciﬁcations. Proc. 5th International Joint Conference on
Artiﬁcial Intelligence, Boston, Mass., pp. 1045–1058.
Burstall, R.M. and Goguen, J.A. (1980) The Semantics of Clear, A
Speciﬁcation Language. Proc. Advanced Course on Abstract Soft-
ware Speciﬁcations, LNCS 86.
Burstall, R.M. and Goguen, J.A. (1981) An Informal Introduction to
Speciﬁcations using Clear. In (eds.) R.S. Boyer and J.S. Moore,
The Correctness Problem in Computer Science, Academic Press,
London, pp. 185–215.
Burstall, R.M. and Lampson, B. (1984) A Kernel Language for Abstract
Data Types and Modules. Proc. of Semantics of Data Types Conf.,
Sophia-Antipolis, France, LNCS 173.
Burstall, R.M. and Landin, P.J. (1969) Programs and Their Proofs: An
Algebraic Approach. In (eds.) B. Meltzer and D. Michie, Machine
Intelligence 4, Edinburgh University Press, pp. 17–44.

Burstall, R.M., MacQueen, D.B. and Sannella, D.T. (1980) Hope: An
Experimental Applicative Language. Proc. ACM Lisp Conf., Stan-
ford University, California.
Burstall, R.M. and Thatcher, J.W. (1974) The Algebraic Theory of
Recursive Program Schemes. In Category Theory Applied to Com-
putation and Control. LNCS 25.
Cardelli, L. and Wegner, P. (1985) On Understanding Types, Data Ab-
straction, and Polymorphism. ACM Computing Surveys, 17, 4.
Cartmell, J. (1978) Generalised Algebraic Theories and Contextual Cat-
egories. DPhil thesis, Oxford University.
Cartmell, J. (1985) Reduction Rules for Cartesian Closed Categories.
Preprint, Dept. Comp. Sci., Edinburgh University.
Church, C. (1941) The Calculi of Lambda-Conversion.
Ann.
Math.
Studies, Princeton University Press.
Codd, E.F. (1970) A Relational Model of Data for Large Shared Data
Banks. Comm. ACM, 13, 6, pp. 377–387.
Cohn, P.M. (i965) Universal Algebra. Harper & Row, New York. Re-
published 1981 by D. Reidel, Dordrecht, Holland.
Colmerauer, A. et al. (1973) Etude et Realisation d’un Syst`eme PRO-
LOG. Convention de Research IRIA-Sesori 77030.
Constable, R.L. and Bates, J.L. (1984) The Nearly Ultimate PRL. Tech-
nical report, 83–551, Cornell University.
Constable, R.L. et al. (1985) Implementing Mathematics with the Nuprl
Proof Development System. Prentice Hall, Englewood Cliﬀs, NJ.
Coquand, T. (1986) An Analysis of Girard’s Paradox. Proc. 1st Logic
in Computer Science Symposium. Boston, Mass., IEEE, Ithaca,
NY.
Coquand, T. and Huet, G. (1985) Constructions: A Higher Order Proof
System for Mechanising Mathematics. EUROCAL85, Linz, LNCS
203.
Curien, P.-L. (1986) Categorical Combinators, Sequential Algorithms
and Functional Programming. Research Notes in Theoretical Com-
puter Science. Pitman, London.

Curry, H.B. and Feys, R. (1968) Combinatory Logic. 1, North-Holland,
Amsterdam.
Darlington, J., Henderson, P. and Turner, D.A. (1982) Functional Pro-
gramming and its Applications: An Advanced Course. CUP.
Dewar, R.B.K. (1978) The SETL Programming Language. Technical
report, Courant Inst. of Mathematical Sciences, New York Univ.
Dubuc, E.J. (1974) Free Monoids. J. Algebra 29, pp. 208–228.
Dybjer, P (1985) Program Veriﬁcation in a Logical Theory of Con-
structions. In Functional Programming Languages and Computer
Architectures LNCS 201.
Dybjer, P (1986) Category Theory and Programming Language Seman-
tics: An Overview. Proc. Summer Workshop on Category Theory
and Computer Programming 1985, LNCS 240. pp. 165–181.
Dyckhoﬀ, R. (1985) Category theory as an extension of Martin-L¨of type
theory. Internal report CS 85/3, Dept. of Computational Science,
University of St. Andrews, Scotland.
Ehrig, H., Pfender, M. and Schneider, H. (1973) Graph Grammars: An
Algebraic Approach.
Proc.
14th.
Annual IEEE Symposium on
Switching and Automata Theory, pp. 167-180.
Eilenburg, S. and Mac Lane, S. (1945) A General Theory of Natural
Equivalences. Trans. Am. Math. Soc., 58, pp. 231–294.
Eilenberg, S. and Moore, J.C. (1965) Adjoint Functors and Triples.
Illinois J. Math., 9, pp. 381–398.
Elgot, C.C. (1971) Algebraic Theories and Program Schemes. In (ed.)
Engeler, Symp. on the Semantics of Algorithmic Languages, LNM
188, pp. 71–88.
Eriksson, L.H. (1984) Synthesis of a Uniﬁcation Algorithm in a Logic
Programming Calculus. J. Logic Programming, 1, 1.
Ershov, Y.L. (1973) Theorie der Numerierungen I. Z. Mathematische
Logik 19.
Ershov, Y.L. (1975) Theorie der Numerierungen II. Z. Mathematische
Logik 21.

Feferman, S. (1969) Set-Theoretical Foundations of Category Theory.
In (ed.) S. Mac Lane, Reports of the Mid-West Category Seminar
III, LNM 106, pp 201-247.
Feferman, S. (1975) A Language and Axioms for Explicit Mathematics.
In Algebra and Logic, LNM 450. pp. 87–139.
Feferman, S. (1979) Constructive Theories of Functions and Classes. In
(eds.) M. Boﬀa, D. van Dalen and K. McAloon, Logic Colloquium
’80, pp. 95–128. North-Holland, Amsterdam.
Freyd, P. (1964) Abelian Categories: An Introduction to the Theory of
Functors. Harper & Row, New York.
Freyd, P. (1972) Aspects of Topoi. Bull. Aust. Math. Soc., 7, pp. 1–76.
Futatsugi, K., Goguen, J.A., Jouannaud, J.-P. and Meseguer, J. (1985)
Principles of OBJ2.
In Proc. Symposium on Principles of Pro-
gramming Languages, ACM, pp. 52–66.
Girard. J.Y. (1972) Interpr´etation fonctionelle et ´elimination des coupures
dans l’arithm´etique d’ordre sup´erieur. PhD thesis, Paris.
Glaser, H., Hankin, C. and Till, D. (1984) Principles of Functional
Programming. Prentice Hall International, Hemel Hempstead.
Goguen, J.A. (1971) Mathematical Representation of Hierarchically Or-
ganized Systems. In (ed.) E. Atlinger, Global Systems Dynamics,
pp. 112–128. S. Karger.
Goguen, J.A. (1973) Realization is Universal. Math. Sys. Th., 6, pp.
359–374.
Goguen, J.A. (1978) Order Sorted Algebra. UCLA Computer Science
Dept., Semantics and Theory of Computation report 14; to appear
in J. Comp. Sys. Sci.
Goguen, J.A. (1988) Higher Order Functions Considered Unnecessary
for Higher Order Programming. Internal report SRI-CSL-88-1, SRI
International.
Goguen, J.A. and Burstall, R.M. (1983) Introducing Institutions. Proc.
Logics of Programming Workshop, Carnegie-Mellon University.

Goguen, J.A. and Burstall, R.M. (1984) Some Fundamental Tools for
the Semantics of Computation, Part 1: Comma Categories, Colim-
its, Signatures and Theories. Th. Comp. Sci., 31, pp. 175–209.
Goguen, J.A. and Ginali, S. (1978) A Categorical Approach to Gen-
eral Systems Theory. In (ed.) G. Klir, Applied General Systems
Research pp. 257–270, Plenum, New York.
Goguen, J.A. and Meseguer, J. (1985) Completeness of Many-sorted
Equational Logic. Houston J. Math., 11, 3, pp. 307-334.
Goguen, J.A. and Meseguer, J. (1988) Semantics of Computation. Pre-
print, book in preparation.
Goguen, J.A. and Tardo, J. (1979) An Introduction to OBJ: A Lan-
guage for Writing and Testing Software. In Speciﬁcation of Reliable
Software, pp. 170–189, IEEE, Ithaca, NY.
Goguen, J.A., Thatcher, J.W., Wagner, E.G. and Wright, J.B. (1977)
Initial Algebra Semantics and Continuous Algebras. J. ACM 24,
1, pp. 68–95.
Goguen, J.A., Thatcher, J.W. and Wagner, E.G. (1978) An Initial Al-
gebra Approach to the Speciﬁcation, Correctness and Implemen-
tation of Abstract Data Types. In (ed.) R. Yeh, Current Trends
in Programming Methodology Prentice Hall, Englewood Cliﬀs, NJ.
pp. 80–149.
Goldblatt, R. (1979) Topoi – The Categorial Analysis of Logic. Studies
in Logic and the Foundations of Mathematics, 98, North-Holland,
Amsterdam.
Gordon, M.J.C. (1979) The Denotational Description of Programming
Languages. Springer-Verlag, Berlin.
Gordon, M.J.C., Milner, R. and Wadsworth, C.P. (1979) Edinburgh
LCF. LNCS 78.
Grothendieck, A. (1963) Cat´egories ﬁbr´ees et descente. Revˆetements
´etales et group fondamental.
S´eminaire de G´em´etrie Alg´ebrique
du Bois-Marie 1960/61 (SGA 1), expos´e VI, 3rd ed., Institut des
Hautes ´Etudes Scientiﬁques, Paris; reprinted in LNM 224 (1971).
Hagino, T. (1987) Categorical Data Types. PhD thesis, Internal report,
LFCS, Dept. Comp. Sci., University of Edinburgh.

Hagino, T. (1987a) A Typed Lambda Calculus with Type Constructors.
Proc. Summer Conference on Category Theory and Computer Sci-
ence, Edinburgh, LNCS 283.
Hamza, T.T.A. (1985) Normalisation Techniques in Proof Theory and
Category Theory – An Implementation and Applications.
PhD
thesis, University of St. Andrews, Scotland.
Harper, R., Honsell, F. and Plotkin, P. (1987) A Framework for Deﬁning
Logics. Proc. Symposium on Logic in Computer Science, June 22-
25, IEEE, Ithaca, NY.
Harper, R. and Mitchell, K. (1986) Introduction to Standard ML. Un-
published Report, University of Edinburgh.
Henderson, P. (1980) Functional Programming: Applications and Im-
plementation. Prentice Hall International, Hemel Hempstead.
Herbrand, J. (1930) Recherches sur la Th´eorie de la D´emonstration.
thesis, University of Paris, In (1968) Ecrits logique de Jacques Her-
brand, PUF, Paris.
Herrlich, H. and Strecker, G.E. (1973) Category Theory.
Allyn and
Bacon.
Hindley, R. (1969) The Principal Type-scheme of an Object in Combi-
natory Logic. Trans. Am. Math. Soc., 146, pp. 29–40.
Hintze, S. (1981) Kategorientheoretische Beschreibung rekursiver Funk-
tionale. Unpublished paper.
Hook, J.G. (1984) Understanding Russell – A First Attempt.
Proc.
Semantics of Data Types Conf., Sophia-Antipolis, France, LNCS
173.
Hopcroft, J.E. and Ullman, J.D. (1979) Introduction to Automata The-
ory, Languages, and Computation. Addison-Wesley.
Huet, G. (1975) A Uniﬁcation Algorithm for Typed Lambda Calculus.
Th. Comp. Sci., 1, 1, pp. 27–57.
Huet, G. (1976) R´esolution d’Equations dans les Languages d’Ordre
1, 2, . . . , ω. thesis, Specialit´e Maths., University of Paris, VII.

Huet, G. (1980) Conﬂuent Reductions: Abstract Properties and Appli-
cations to Term Rewriting Systems. J. ACM, 27, 4, pp. 797–821.
Huet, G. (1986) Formal Structures for Computation and Deduction.
Working Paper for International Summer School on Logic of Pro-
gramming and Calculi of Discrete Design, Marktoberdorf, Ger-
many.
Huet, G. and Oppen, D.C (1980) Equations and Rewrite Rules: A
Survey. In (ed.) R. Book, Formal Languages: Perspectives and
Open Problems, Academic Press.
Hyland, J.M.E. (1982) The eﬀective topos. In (eds.) A.S. Troelstra and
D. van Dalen, The L.E.J. Brouwer Centenary Symposium North-
Holland, Amsterdam, pp. 165–216.
Isbell, J. (1957) Some remarks concerning categories and subspaces.
Can. J. Math., 9, pp. 563–577.
Johnstone, P.T. (1977) Topos Theory. Academic Press, London.
Jones, C.B. (1986) Systematic Software Development using VDM. Pren-
tice-Hall, Hemel Hempstead.
Joyal, A. (1981) Une Theorie Combinatoire des S´eries Formelles. Adv.
Math., 42, pp. 1–82.
Kan, D.M. (1958) Adjoint Functors. Trans. Am. Math. Soc., 87, pp.
294–329.
Kapur, D., Musser, D.R. and Stepanov, A.A. (1981) Operators and
Algebraic Structures. Proc. ACM Conf. Functional Prog. Lan-
guages.
Kleisli, H. (1965) Every Standard Construction is Induced by a Pair of
Adjoint Functors. Proc. Am. Math. Soc., 16, pp. 544–546.
Knuth, D.E. (1973) Searching and Sorting. Addison-Wesley.
Knuth, D.E. and Bendix, P.B. (1970) Simple Word Problems in Univer-
sal Algebras. In (ed.) J. Leech Computational Problems in Abstract
Algebra, Pergamon Press, Oxford, pp. 263–297.
Kruse, R.L. (1987) Data Structures and Program Design. Prentice Hall,
Englewood Cliﬀs, NJ.

Lambek, J. (1969) Deductive systems and categories II. LNM 86, pp
76–122.
Lambek, J. (1980) From λ-calculus to Cartesian Closed Categories. In
(eds.) J.R. Hindley and J.P. Seldin, To H.B. Curry: Essays on
Combinatory Logic, Lambda-Calculus and Formalism.
Academic
Press, pp. 375–402.
Lambek, J. and Scott, P.J. (1986) Introduction to Higher Order Cate-
gorical Logic. CUP.
Landin, P.J. (1966) The Next 700 Programming Languages. Comm.
ACM, 9, 3, pp. 157–166.
Lawvere, F.W. (1963) Functorial Semantics of Algebraic Theories. PhD
thesis, Columbia University.
Lawvere, F.W. (1963a) Functorial Semantics of Algebraic Theories.
Proc. Nat. Acad. Sci., 50, pp. 869–872.
Lawvere, F.W. (1966) The Category of Categories as a Foundation for
Mathematics. In (eds) S. Eilenberg et al., Proc. Conf. on Cate-
gorical Algebra, La Jolla, 1965. Springer-Verlag.
Lawvere, F.W. (1970) Equality in Hyperdoctrines and the Comprehen-
sion Schema as an Adjoint Functor. Proc. Symp. in Pure Math.,
XVII: Applications of Categorical Algebra, Am. Math. Soc., pp.
1–14.
Lawvere, F.W. (1974) Variable Quantities and Variable Structures in
Topoi. In Algebra, Topology, and Category Theory, Academic Press,
pp. 101–132.
Lehmann, D.J. (1977) Algebraic Structures for Transitive Closure. Th.
Comp. Sci., 4, 1, pp. 59–76.
Levi, G. and Sirovich, F. (1975) Proving Program Properties, Symbolic
Evaluation and Logical Procedural Semantics. Proc. Math. Found.
Comp. Sci., LNCS 32.
McCarthy, J. (1960) Recursive Functions of Symbolic Expressions and
Their Computation by Machine. Comm. ACM, 3, 4, pp. 184–195.
Mac Lane, S. (1948) Groups, Categories and Duality. Proc. Nat. Acad.
Sci., 34, pp. 263–267.

Mac Lane, S. (1950) Duality for Groups. Bull. Am. Math. Soc., 56,
pp. 485–516.
Mac Lane, S. (1965) Categorical Algebra. Bull. Am. Math. Soc., 71,
pp. 40–106.
Mac Lane, S. (1971) Categories for the Working Mathematician. Spri-
nger-Verlag, New York.
Mac Lane, S. (1975) Sets, Topoi and Internal Logic in Categories. Proc.
Logic Coll., Bristol, 1973, North-Holland, Amsterdam.
McLarty, C. (1986) Left Exact Logic. J. Pure and Appl. Algebra, 41,
pp. 63–66.
MacQueen, D. (1985) Modules for Standard ML. Polymorphism, 2, 2.
Earlier version in Proc. ACM Symp. on Lisp and Functional Pro-
gramming, 1984, Austin, Texas.
Manes, E.G. (1976) Algebraic Theories. Springer-Verlag, New York.
Manna, Z. and Waldinger, R. (1980) Deductive Synthesis of the Uniﬁ-
cation Algorithm. SRI research report.
Martelli, A. and Montanari, U. (1982) An Eﬃcient Uniﬁcation Algo-
rithm. ACM Trans. Prog. Lang. Sys., 4, 2, pp. 258–282.
Martin-L¨of, P. (1975) An Intuitionistic Theory of Types: Predicative
Part. In (eds.) H.E. Rose and J.C. Shepherdson, Logic Colloquium,
Bristol, 1973, North-Holland, Amsterdam, pp. 73–118.
Martin-L¨of, P. (1982) Constructive Mathematics and Computer Sci-
ence. 6th Int. Congress for Logic, Methodology and Philosophy of
Science, Hannover, 1979. North-Holland, Amsterdam.
Martin-L¨of, P. (1984) Intuitionistic Type Theory, Bibliopolis, Naples.
Milner, R. (1978) A Theory of Type Polymorphism in Programming.
J. Comp. Sys. Sci., 17, 3, pp. 348–375.
Milner, R. (1984) A Proposal for Standard ML. Proc. ACM Symp. on
Lisp and Functional Programming, Austin, Texas.
Moggi, E. (1985) Partial Morphisms in Categories of Eﬀective Objects.
Unpublished paper, Dept. Comp. Sci., University of Edinburgh.

Mulry, P. (1981) Generalized Banach-Mazur Functionals in the Topos
of Recursive Sets, J. Pure and Appl. Algebra, 26.
Oles, F.J. (1985) Type Algebras, Functor Categories and Block Struc-
ture. In (eds.) M. Nivat and J.C. Reynolds, Algebraic Methods in
Semantics, CUP, Chapter 15.
Paterson, M.S. and Wegman, M.N. (1978) Linear Uniﬁcation. J. Comp.
Sys. Sci., 16, 2, pp. 158–167.
Paulson, L.C. (1985) Verifying the Uniﬁcation Algorithm in LCF. Sci.
Comp. Programming, 5, 2, pp. 143–170.
Petersson, K. (1982,84) A Programming System for Type Theory. LPM
memo 21, Dept. Comp. Sci., Chalmers Institute of Technology,
G¨oteborg.
Pitt, A.M. (1987) Polymorphism is Set Theoretic, Constructively. Proc.
Summer Conference on Category Theory and Computer Science,
Edinburgh 1987, LNCS 283.
Plotkin, G. (1969) A Note on Inductive Generalisation. In (eds.) B.
Meltzer and D. Michie, Machine Intelligence 5, Edinburgh Univer-
sity Press, pp. 153–163.
Plotkin, G. (1985) Denotational Semantics with Partial Functions. Lec-
tures at the CSLI Summer School, Stanford, July 1985.
Poign´e, A. (1984) On Speciﬁcations, Theories and Models with Higher
Types. Preprint, Imperial College, London.
Reichel, H. (1980) Initially-Restricting Algebraic Theories.
Unpub-
lished report, TH. ‘Otto von Guericke’, Sektion Math/Physik, Mag-
deburg, DDR.
Reichel, H. (1987) Initial Computability, Algebraic Speciﬁcations and
Partial Algebras. Clarendon Press, Oxford.
Reynolds, J.C. (1974) Towards a Theory of Type Structure. Colloque
sur la programmation, Paris, LNCS 19, pp 408–425.
Reynolds, J.C. (1981) The Craft of Programming. Prentice Hall, Hemel
Hempstead.

Reynolds, J.C. (1983) Types, Abstraction and Parametric Polymor-
phism. Proc. IFIP Congress, Paris.
Robinson, E.P. and Rosolini, G. (1986) Categories of Partial Maps.
Quaderno del Dipartimento di Matematica, 18, Universit`a di Parma.
Robinson, J.A. (1965) A Machine-oriented Logic Based on the Resolu-
tion Principle. J. ACM, 12, 1, pp. 23–41.
Robinson, J.A. and Wos, L.T. (1969) Paramodulation and Theorem
Proving in First-Order Theories with Equality. In (eds) B. Meltzer
and D. Michie, Machine Intelligence 4, Edinburgh University Press,
pp. 135–150.
Rydeheard, D.E. (1981) Applications of Category Theory to Program-
ming and Program Speciﬁcation, PhD thesis. Dept. Comp. Sci.,
University of Edinburgh.
Rydeheard, D.E. and Burstall, R.M. (1985) The Uniﬁcation of Terms:
A Category-theoretic Algorithm.
Internal report UMCS-85-8-1,
Dept. Comp. Sci., University of Manchester.
Rydeheard, D.E. and Burstall, R.M. (1985) Monads and Theories – A
Survey for Computation. In (eds) M. Nivat and J.C. Reynolds,
Algebraic Methods in Semantics, CUP, Chapter 16.
Rydeheard, D.E. and Burstall, R.M. (1986) A Categorical Uniﬁcation
Algorithm.
Proc.
Summer Workshop on Category Theory and
Computer Programming, 1985, LNCS 240, pp. 493–505.
Rydeheard, D.E. and Stell, J.G. (1987) Foundations of Equational De-
duction: A Categorical Treatment of Equational Proofs and Uniﬁ-
cation Algorithms. Proc. Summer Conference on Category Theory
and Computer Science, Edinburgh, 1987, LNCS 283.
Sannella, D.T. (1982) Semantics, Implementation and Pragmatics of
Clear, a Program Speciﬁcation Language. PhD thesis, Dept. Comp.
Sci., University of Edinburgh.
Sannella, D.T. (1984) A Set-theoretic Semantics for Clear. Acta Infor-
matica, 21, 5, pp. 443–472.

Sannella, D. and Tarlecki, A. (1986) Extended ML: An Institution-Inde-
pendent Framework for Formal Program Development. Proc. Sum-
mer Workshop on Category Theory and Computer Science, Surrey,
1985, LNCS 240.
Sannella, D.T. and Wirsing, M. (1983) A Kernel Language for Al-
gebraic Speciﬁcation and Implementation.
Report CSR-131-83,
Dept.
Comp. Sci., University of Edinburgh. Extended abstract
in:
Proc Int.
Conf.
on Foundations of Computation Theory,
Borgholm, Sweden, LNCS 158, pp. 413-427.
Schubert, H. (1972) Categories. Springer-Verlag, Berlin.
Scott, D.S. (1979) Identity and Existence in Intuitionistic Logic.
In
Applications of Sheaves, LNM 753, pp. 660–696.
Scott, D.S. (1980) Relating Theories of the λ-calculus. In (eds.) J.R.
Hindley and J.P. Seldin, To H.B. Curry: Essays on Combinatory
Logic, Lambda-Calculus and Formalism. Academic Press, London,
pp. 403–450.
Seely, R.A.G. (1983) Hyperdoctrines, Natural Deduction and the Beck
Condition. Z. Math. Logik, 29, pp. 505–542.
Seely, R.A.G. (1984) Locally Cartesian Closed Categories and Type
Theory. Math. Proc. Camb. Phil. Soc., 95, pp. 33–48.
Seely, R.A.G. (1987) Modelling Computations: A 2-Categorical Frame-
work. Proc. Symp. Logic in Computer Science, June 22–25, 1987,
IEEE, Ithaca, NY.
Siekman, J.H. (1984) Universal Uniﬁcation. 7th Int. Conf. Automated
Deduction, LNCS 170.
Smyth, M.B. and Plotkin, G.D. (1982) The Category-theoretic Solution
of Recursive Domain Equations. SIAM J. Computing, 11, pp. 761–
783.
Strachey, C. (1967) Fundamental Concepts in Programming Languages.
Lecture notes, International Summer School in Computer Program-
ming, Copenhagen.
Szabo, M. (1978) Algebra of Proofs. North-Holland, Amsterdam.

Tarjan, R. (1972) Depth-First Search and Linear Graph Algorithms.
SIAM J. Computing, 1, pp. 146-160.
Turner, D.A. (1979) A New Implementation Technique for Applicative
Languages. Software Practice and Experience, 9, 10.
Turner, D.A. (1986) Miranda: A Non-Strict Functional Language with
Polymorphic Types. Proc. STACS 86, LNCS 210.
Wand, M. (1979) Final Algebra Semantics and Data Type Extensions.
J. Comp. Sys. Sci., 19, pp. 27–44.
Warren, D.H.D., Pereira, L.M. and Pereira, F. (1977) PROLOG –
The Language and its Implementation Compared with Lisp. Proc.
Symp. on Artiﬁcial Intelligence and Prog. Languages, University
of Rochester, NY. Appeared in joint issue: SIGPLAN Notices 12,
8, and SIGART Newsletter, 64.
Warshall, S. (1962) A Theorem on Boolean Matrices. J. ACM, 9, 1, pp.
11–12.
Watjen, D. and Struckmann, W. (1982) An Algorithm for Verifying
Equations of Morphisms in a Category. Inform. Process. Letters,
14, 3, pp. 104–108.
Wikstr¨om, A. (1987) Functional Programming using Standard ML. Pren-
tice Hall International, Hemel Hempstead.
Winskel, G. (1986) Category Theory and Models of Parallel Computa-
tion. Proc. Summer Workshop on Category Theory and Computer
Programming, Surrey, 1985, LNCS 240, pp. 266–281.
Winskel, G. (1987) Relating Two Models of Hardware. Proc. Summer
Conference on Category Theory and Computer Science, Edinburgh,
1987, LNCS 283, pp. 98–113.
Wright, J.B., Goguen, J.A., Thatcher, J.W. and Wagner, E.G. (1976)
Rational Algebraic Theories and Fixed Point Solutions. Proc. 17th
IEEE Symp. Foundations of Computer Science, Houston, Texas.
Yelick, K. (1985) Combining Uniﬁcation Algorithms for Conﬁned Reg-
ular Equational Theories. Proc. 1st International Conf. Rewriting
Techniques and Applications, Dijon, France, LNCS 202, pp. 365-
380.

