

Mathematica Cookbook
Sal Mangano
                 Beijing  •  Cambridge  •  Farnham  •  Köln  • Sebastopol  •  Taipei  •  Tokyo

Mathematica Cookbook
by Sal Mangano
Copyright © 2010 Salvatore Mangano. All rights reserved. 
Printed in the United States of America.
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.
O’Reilly books may be purchased for educational, business, or sales promotional use. Online edi-
tions are also available for most titles (http://my.safaribooksonline.com). For more information, 
contact our corporate/institutional sales department: (800) 998-9938 or corporate@oreilly.com.
Editor:
Mike Loukides
Production Editor:
Adam Witwer
Production Services:
Precision Graphics
Cover Designer:
Karen Montgomery
Interior Designer:
David Futato
Nutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo are registered trade-
marks of O’Reilly Media, Inc. Mathematica Cookbook, the image of a solarium seashell, and 
related trade dress are trademarks of O’Reilly Media, Inc.
Many of the designations used by manufacturers and sellers to distinguish their products are 
claimed as trademarks. Where those designations appear in this book, and O’Reilly Media, Inc., 
was aware of a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of this book, the publisher and author 
assume no responsibility for errors or omissions, or for damages resulting from the use of the 
information contained herein.
ISBN: 978-0-596-52099-1
Wolfram Mathematica®  
Spikey logo is a registered trademark of Wolfram Research, Inc. The Mathematica software design, 
"" look and feel",  display, and other graphic elements are copyright of Wolfram Research, Inc.
“ 
”
is a registered trademark of Wolfram Research, Inc. The Mathematica

To Wanda, Leonardo and Salvatore: 
My life would not compute without you.

Included with this book is a free 30 day trial of the Wolfram Mathematica ® software. 
To access your free download, simply go to http://www.wolfram.com/books/resources 
and enter license number L3294-005. You will be guided to download and install the 
latest version of Mathematica.

v
Table of Contents
	
1
	
4
	
9
	
12
	
13
	
16
	
18
	
20
	
23
	
	
	
43

48
	
51
	
	
62

vi | Table of Contents
	
66
	
73
	
77
	
79
	
85
	
97
	
100
	
102
	
103
	
105
	
110
	
112

114

119
	
121

125
	
145
	
155
	
157
	
	
168
	
169

Table of Contents | vii
	
170
	
171
	
177
	
178
5
181
	
187
	
192
	
196
	
198
	
201
	
202
	
209
	
213
	
227
	
237
	
238
	
247
	
249
	
252
	
255
	
258
	
260
	
263
	
269
	
270
	
275
	
283
	
285
	
290

viii | Table of Contents
	
292
	
295
	
296
	
298
	
302
	
306
	
309
	
313
	
317
	
320
	
329
	
332
	
	
361
	
373
	
374
	
375
	
376
	
377
	
378
	
379
	
380
	
384
	
386
	
389
	
390

Table of Contents | ix
	
392
	
393
	
394
	
397
	
403
	
405
	
408
	
413	
.
414	
.
415	
.
416	
.
419	
.
422
	
425	
.
426	
.
427	
.
429	
.
431	
.
435	
.
438	
.
441	
.
443	
.
447	
.
450	
.
452
	
455

456	
.
461	
.
464

x | Table of Contents

466	
.
468	
.
471	
.
472	
.
475	
.
477

479	
.
483	
.
486	
.
492	
.
496	
.
499
	
505	
.
507	
.
510	
.
513	
.
516	
.
519	
.
522	
.
524	
.
533	
.
537	
.
549	
.
557	
.
559	
.
561	
.
563

Table of Contents | xi	
.
565

574

578

583

585	
.
593	
.
594	
.
598	
.
600

607	
.
609


613	
.
615

619	
.
622

624	
.
625	
.
627	
.
630

633

xii | Table of Contents
	
641	
.
643	
.
646

	
656	
.
658

661	
.
662

663

665

669	
.
678

686
	
689	
.
692	
.
694	
.
700

707	
.
711	
.
714	
.
715

Table of Contents | xiii
	
719	
.
720	
.
721	
.
723

725	
.
727

728	
.
733	
.
736	
.
737	
.
739
	
741	
.
743	
.
746	
.
747	
.
753

756	
.
758


769
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .777


xv
Preface
Introduction
If you were stranded on a desert island with only your laptop (and presumably a large 
solar panel), what software would you want to have with you? For me the answer 
definitely includes the latest version of Wolfram Mathematica. Whether you are a 
scientist, engineer, or mathematician, a Wall Street quant, a statistician or program-
mer, or even an artist or musician, you will be a better one if you have this tool at your 
disposal. Of course, having a tool and knowing how to use it well are quite different 
things. That is why I wrote the Mathematica Cookbook. 
I am a big fan of O’Reilly cookbooks, as these books are designed to help you solve 
real-world problems. Mathematica is an ideal candidate for a cookbook because it 
is so vast, deep, and full of traps for the novice. I was ecstatic to learn that O’Reilly 
was looking to publish a Mathematica cookbook and even more excited when I was 
chosen to be its author. I have been a user of Mathematica since version 3.0. Although 
that was over 13 years ago, I still remember the frustration of trying to solve prob-
lems in this system. I don’t mean this in a derogatory way. The frustration a newbie 
experiences when trying to learn Mathematica comes from the knowledge that you 
are sitting in front of a highly advanced computational platform that eventually will 
magnify your productivity tenfold—if you can only wrap your mind around its unfa-
miliar idioms. If you are a new (or even not-so-new) user of Mathematica today, you 
are simultaneously in a better and a much worse position than I was with version 3.0. 
You are in a better position because Mathematica 7.0 is vastly more powerful than 3.0 
was back then. Not only has the number of available functions doubled, but Math-
ematica has fundamental new capabilities including dynamic interactivity, curated 
data sources, parallel processing, image processing, and much more. You are in a 
worse position because there is much more to learn! 
As Mathematica grows, it remains largely unchanged in its core principles. This book 
is designed to help you master those core principles by presenting Mathematica in 

xvi  |  Preface
the context of real-world problems. However, my goal is not just to show you how to 
solve problems in Mathematica, but to show you how to do so in a way that plays to 
Mathematica’s strengths. This means there is an emphasis on symbolic, functional, 
and pattern-based styles of programming. Mathematica is a multi-paradigm pro-
gramming language; you can easily write code in it that a Fortran or C programmer 
would have little trouble following. However, the procedural style that this entails is 
not likely to give you good performance. More importantly, it will often cause you to 
write more code than necessary and spend more time adapting that code to future 
problems. Stephen Wolfram has said that a correct Mathematica program is often a 
short Mathematica program. There is much truth to this. The truth comes from the 
idea that good Mathematica programs leverage the capabilities of the vast built-in 
library of both general-purpose and highly specialized functions. Programming in 
Mathematica is a search for the right combination of primitives. My hope is that this 
cookbook will play a role as your guide.
MathematicaCookbook.com
One risk of authoring a cookbook is that it is almost inevitable that something some-
one finds important will be left out. With Mathematica, this risk is a certainty be-
cause even as I wrote the book, Mathematica’s capabilities grew. However, even if you 
drew a line at, say, version 6.0, you would find that there are still many topics that I 
do not cover in the book, for various reasons. To remedy this and to create a living 
resource that I hope the Mathematica community will help nourish, I am launching 
http://mathematicacookbook.com. Here you will find recipes that did not make it into 
this book, and more importantly, you will be able rate recipes, contribute your own, 
or provide alternative implementations to those found in the book or on the site.
Structure of This Book
The Mathematica Cookbook is not necessarily meant to be read from start to finish 
like a conventional book (although you are certainly welcome to do so!). Having said 
that, the chapters are organized in a purposeful way. Chapters 1 through 8 present 
general techniques that all users of Mathematica should know. These chapters are 
largely self-contained, but sometimes it is necessary to use features in one chapter 
that are covered more deeply in another. Cross-references within each recipe should 
prevent you from getting stuck. However, keep in mind that a cookbook is not the 
same as a tutorial, and you should also make frequent use of the Mathematica refer-
ence, tutorials, and guides that are integrated into Mathematica’s help system. Chap-
ters 9 through 14 cover specific domains of Mathematica application. If you are the 

Preface  |  xvii
type of person who learns best by examples from your area of expertise, you will ben-
efit from seeing the techniques of the first chapters leveraged in problems related to 
physics, engineering, calculus, statistics, music, finance, and more. Finally, Chapters 
15 through 19 cover important techniques, extensions, and tools that make Math-
ematica unrivaled as a technical software development tool. 
Chapter 1 covers numerics. For the most part, Mathematica simply does the right 
thing when computing numeric results, as you would expect. In pure mathematics, 
numbers are formal objects that are well behaved, but when you represent numbers 
in a finite discrete device like a computer, often you will need to understand issues of 
precision and accuracy in order to get reasonable results on certain classes of prob-
lems. Further, numbers have different representations in Mathematica (Integers, Ra-
tionals, Complex, and some exotic types like Intervals). Then there is an issue of input 
and presentation: Mathematica supports different base representations and different 
display formats. This chapter has recipes that cover all these issues, and it is wise to 
have some familiarity with them before using any of the numeric algorithms.
Functional programming is a style of Mathematica development that most seasoned 
users prefer. Chapter 2 dives deeply into functional programming, Mathematica style. 
Because Mathematica was designed to support multiple development paradigms, its 
functional programming abilities are not as pure as languages like Haskell. This is ac-
tually a big plus, because if you are using Mathematica chances are you are solving a 
problem, and it’s the solution rather than the aesthetics that is foremost in your mind. 
Mathematica programmers prefer the functional style because it leads to efficient 
programs. It also leads to elegant programs. In the context of programming, elegant 
means the combination of brevity, power, and clarity. There is an amazing sense of 
intellectual satisfaction that comes from finding a concise functional solution, and 
this feeling creates the positive feedback that will draw you into Mathematica. How-
ever, this style is often mysterious to people who come to Mathematica from other 
languages like Fortran, C, Mathlab, or Microsoft Excel. I think this chapter will help 
you discover the rewards of the functional style.
Chapter 3 presents Mathematica data structures, which are largely built on the foun-
dation of lists. From lists, Mathematica derives matrices and higher order tensors, 
sparse matrices, and more. Knowing how to manipulate these structures is essential 
for almost any application of Mathematica. This is obvious if you are doing linear 
algebra, but list processing is integral to almost every facet of use. This chapter also 
shows how to implement other types of data structures, such as a dictionary that 
leverages the fast associative look-up that is part of Mathematica’s evaluation engine. 
Pattern-based programming revolves around pattern matching and transformation. 
Chapter 4 introduces Mathematica’s rich pattern-based techniques. Patterns are not 

xviii  |  Preface
a feature of most mainstream languages, but they are tremendously powerful and 
essential if you hope to accomplish anything nontrivial in Mathematica. Of all the 
techniques at your disposal, pattern matching and replacement is the one most likely 
to yield the “wow” reaction you get when you see a seemingly simple looking piece of 
code do something not so simple. To whet your appetite, here is one of my favorites. 
In[190]:=
runEncode@l_ListD := Map@8Ò, 1< & , lD êê.
8head___, 8x_, n_<, 8x_, m_<, tail___< ß 8head, 8x, n + m<, tail<
In this little ditty by Frank Zizza (which won a programming contest at the 1990 
Wolfram conference), the goal is to take a list and return the list in run length encoded 
form. Don’t worry if this code seems cryptic; it won’t after you have recipes from 
Chapters 2 and 4 under your belt. For example, input {1, 1, 2, 2, 2, 1, 3, 3, 3, 3} 
should produce {{1, 2}, {2, 3}, {1, 1}, {3, 4}}.
In[191]:=
runEncode@81, 1, 2, 2, 2, 1, 3, 3, 3, 3<D
Out[191]=
881, 2<, 82, 3<, 81, 1<, 83, 4<<
Although you can create small solutions to this problem in languages like Python or 
Ruby, I find this solution compelling because it contains no explicit looping construct 
and, once you learn to read it, contains a very explicit statement of the problem. 
Chapter 5 covers string manipulation, which is more important than you might think 
for a language that is primarily associated with numeric and symbolic mathematics. 
Mathematica has a rich set of string manipulation primitives that include all the typi-
cal functions you expect (StringLength, StringReplace, StringInsert, and so forth), 
plus an extension of its pattern language specifically designed for strings and includ-
ing regular expression-based transformations. 
The next two chapters explore one of Mathematica’s best capabilities, integrated graph-
ics. Chapter 6 dives into two-dimensional plots and graphics. There are many packages 
that let you create plots, but few are so seamlessly integrated into the same development 
environment where you write code. This integration is an amazing productivity tool. 
I frequently find myself using Plot and other graphing functions simply as a means 
to help me understand an equation or algorithm I am developing and not necessarily 
because I am creating a presentation to be viewed by others. The fact that functions 
like Plot, ListPlot, and ParametricPlot give good results with little effort means they 
can become part of your day-to-day interaction with Mathematica. But if you need pro-
fessionally designed graphics for an important paper or presentation, you will not be 
disappointed, because there are options to customize every aspect of the presentation. 
Chapter 7 builds on the preceding chapter by moving into the more sexy domain of 
3D graphics and plots. Plotting in 3D provides you with additional visualization and 
interaction capabilities. All 3D graphics can be rotated, panned, and zoomed inter-

Preface  |  xix
actively. There are also many sophisticated options that let you adjust every aspect 
of the plot, including shading, mesh, coloring, camera angles, how light reflects off 
the surface, and so on. Not every user will want to tweak all of these settings, but if 
you are a graphic artist or aficionado you will have a lot of fun once you master all 
the options. This chapter will give you a leg up on this important dimension of Math-
ematica’s power.
Chapter 8, the first of the special-purpose chapters, covers image processing. Native 
image processing functions were added in Mathematica 7.0, and you can have quite a 
bit of fun transforming images programmatically as you do by hand with software such 
as Photoshop. This chapter also shows some advanced image-processing techniques 
for which I wrote a large part of the algorithms in Mathematica rather than relying on 
the built-in functions. This provides readers who are interested in image processing 
with a guide to approaching image algorithm development in Mathematica, and also 
provides some deeper insight for those who know little about these algorithms
Chapter 9 will give you respite from all the eye-candy by providing some ear-candy. 
You may not know it, but Mathematica is quite the musician, and I was happy to have 
John Kiehl, a professional musician and recording studio owner, write this chapter for 
you. Mathematica can turn functions into sound to play notes, chords, and electronic 
versions of a variety of musical instruments. Further, it can import MIDI files and oth-
er audio formats. You can even perform various operations on sound such as Fourier 
transforms. There really are few limits, and John is an experienced guide who provides 
lots of recipes for the musically inclined to expand upon and the not-so-musically in-
clined to educate themselves with (or just play with for fun). This chapter is available for 
your immediate listening pleasure at http://www.oreilly.com/catalog/9780596521004.
Chapter 10 returns to more mathematical fare by exploring Mathematica’s formidable 
abilities in symbolic math. This chapter focuses on algebraic manipulation and solu-
tions to equations. Many of the recipes show techniques for massaging results pro-
duced by Mathematica into equivalent but sometimes more desirable forms.
Symbolic and numerical calculus is what most people think about when they think 
about Mathematica, and Chapter 11 dives into Mathematica’s formidable (many say 
unrivaled) capabilities in this domain. Here you will see recipes related to computing 
limits, derivatives, integrals, vector calculus, and the solutions to differential equa-
tions. The chapter also covers the increasingly important domain of discrete calculus, 
including sums, products, and difference equations. 
There is high probability that the average technical person will need to do some sta-
tistics! Puns aside, Chapter 12 has recipes that will help you get a handle on Math-
ematica’s formidable statistical capabilities, which rival those of specialized stats 

xx  |  Preface
packages. This chapter has recipes for common statistical measures, probability dis-
tributions, data fitting, interpolation, and more sophisticated tools like ANOVA. It 
also introduces stochastic simulation.
Chapter 13 enters the realm of applied math by showcasing physics and engineering. 
These domains are extremely broad, so rather than attempting to cover a large swath, 
I cherry pick recipes that show applications of the mathematical tools discussed in 
preceding chapters. I also include recipes that demonstrate general techniques for 
organizing programs that have many variables. In addition, this chapter shows how 
educators and others can draw on Mathematica’s access to curated data related to 
physics, chemistry, and biology.
Chapter 14 jumps bravely into the risky business of numerical finance. The goal of 
this chapter is to show quants and others interested in mathematical finance how 
to leverage Mathematica’s strengths in applying common financial algorithms. This 
chapter presents problems of mild to moderate sophistication so that the illustration 
of Mathematica techniques is not lost in the complexity of modern computational 
finance. A large part of this chapter is the result of the efforts of Andreas Lauschke, 
who is expert in both computational finance and Mathematica. 
Version 6.0 brought new excitement to the Mathematica world with the addition of dy-
namic interactivity. For the first time a Mathematica user had the capability to create 
notebook output that changed in response to changes in underlying variables. In many 
ways this ability parallels the new types of dynamic web pages that emerged around the 
same time (so-called Web 2.0)—but I digress. Chapter 15 introduces the primitives un-
derlying this new dynamic interactivity. Amazingly, there are just three main ingredients 
to this capability: Manipulate, Dynamic and DynamicModule. As with many of Mathematica’s 
advanced features, you will master the easy use cases immediately, because the primi-
tives just do the right thing. More advanced application will require some steep learning, 
but this chapter has many recipes that will help you get there. For your immediate grati-
fication, this chapter is available at http://www.oreilly.com/catalog/9780596521004.
Computers with multiple cores (processing elements) are commonplace; there is a 
good chance you own a computer with at least two cores, and if you bought one re-
cently, perhaps even four or more. My Mac Pro has eight. Mathematica stays ahead 
of this trend by bundling Parallel Processing with version 7.0. Chapter 16 contains 
recipes that show you how to use these features. Mathematica makes it easy to add 
parallelism to your programs, but this does not mean your algorithms will run four 
times faster if you have four processors. To get any speed increase at all, you need to 
understand how the parallel primitives work and how they can be tuned. The recipes 
in this chapter show you how to configure parallelism, parallelize existing serial pro-
grams, and also implement more sophisticated parallel techniques like Map-Reduce 
and parallel pipelines.

Preface  |  xxi
As powerful as Mathematica is, there are times when you need something else. Chap-
ter 17 will show you how to interface Mathematica with other languages and pro-
grams. Here, programmers will learn how to integrate code written in C, Java, and 
.NET languages. This chapter also has recipes for integrating Mathematica with da-
tabase systems and third-party tools like spreadsheets.
Chapter 18, “Tricks of the Trade,” includes material that every Mathematica user 
should know but that did not quite fit anywhere else in the book. Here I introduce 
recipes on performance, packaging, stylesheets, and other important techniques.
Last but by no means least, you will want to know how to debug your way out of 
those nasty situations where you just can’t figure out why you are getting strange er-
ror messages or bizarre results. Chapter 19 presents debugging techniques and, pos-
sibly more important, unit testing techniques. An important part of this chapter is 
Wolfram Workbench, the alternative development environment based on Eclipse (an 
open source IDE designed to be customizable to different languages).
Acknowledgments
The Mathematica Cookbook was one of my most challenging projects and it is not 
something I could have accomplished without the support of many people. Although 
I would have never survived without this help, any problems, errors, or omissions in 
the final product are mine alone.
First I must thank Maryka Baraka of Wolfram Research for turning me on to this project, 
arranging my first visit to Wolfram Research, and most importantly, for introducing me 
to many valuable people on the Wolfram staff. Over the course of this project, Maryka 
fielded dozens of queries and directed them to where they needed to go in the Wolfram 
organization. Her advice and support were invaluable. Maryka, you’re the best! 
Theo Gray of Wolfram answered many questions and provided much support, including 
a personal tutorial of some of the advanced features of Mathematica’s Manipulate and 
Dynamic functionality. He was also instrumental in my visiting Wolfram so that I could 
preview Mathematica 7 before its release. This improved the book tremendously.
Many other Wolfram folks answered questions and provided valuable suggestions 
and support. So many, in fact, that I fear I may leave someone out. At the risk of 
that, I must personally acknowledge Larry Adelston, Chris Carlson, Joy Costa, Lou 
D’Andria, John Fultz, Roger Germundsson, Bradley Harden, Jason Harris, Tom 
Wickham Jones, Andre Kuzniarek, Misty Moseley, Peter Overmann, Schoeller Porter, 
Michael Trot, and Eric W. Weisstein. Also, thanks to Stephen Wolfram for creating 
and nurturing Mathematica for all these years.

xxii  |  Preface
Working with O’Reilly for the second time has proved to be just as rewarding as the 
first. First and foremost, a big thank you to my editor, Michael Loukides, whose sup-
port and patience were without bound (even when I whined about this and that as we 
nitpicking authors so often do!). Michael provided great perspective as he read and 
commented on each chapter, and he helped me to understand many points that were 
awkward or would trip up a beginner. In addition, Abby Fox, Keith Fahlgren, and 
Adam Witwer provided valuable help in the early stages of production. Also thanks to 
Simon St. Laurent, the editor of my first cookbook, for his glowing recommendation.
Instrumental to improving the quality of many recipes were the technical critique 
and corrections from Larry Stead, Gregory Frascadore, and Andreas Lauschke. Not 
only did these reviewers correct mistakes, they also offered better implementations 
for several recipes. Again, remaining defects or inadequacies are the fault of the au-
thor alone.
Portions of this book would simply not exist without generous contributions from 
Thomas Weber (Weber and Partner), Chris Carlson (Wolfram), and Ulises Cervantes-
Pimentel (Wolfram). Special thanks to John Kiehl (Soundtrack Studios), whose 
unique combination of musical and Mathematica abilities resulted in the entertaining 
and educational music and audio processing chapter. Special thanks also to Andreas 
Lauschke (Andreas Lauschke Consulting) for much of the material in the financial 
engineering chapter.
I must also thank Kirsten Dennison and her staff at Precision Graphics for arriving to 
solve the final production issues and seeing this book into print. Also, thanks again 
to Larry Adelston of Wolfram for assisting Kirsten’s team with stylesheet production 
and other automation.
Thanks also to my colleagues who offered both moral and technical support during 
this project. In particular I would like to thank Doug Finke, whose conversations are 
always uplifting, and Kalani Thielen, who always seems to know what I need every 
time I ask. 
Although the folks above were crucial, the most important ingredients that went into 
this cookbook were the love, patience, and support of my family. In particular, thanks 
to my wonderful wife Wanda, for enduring a second book project that never seemed 
to be coming to an end, and for all the things small and large that she did for me and 
our family when I was busy working on it. She deserves more than I can ever put into 
words. Also to my two boys, Leonardo and Salvatore, who had to give up quite a bit 
of our personal play time so I could get this beast out the door. This book is dedicated 
to you guys. Thanks also to my parents, family, and friends who provided so much 
support throughout my life and who cheered me on and lifted my spirits. 

Preface  |  xxiii
Conventions Used in This Book
The following typographical conventions are used in this book :
Italic
	
Indicates new terms, URLs, email addresses, filenames, and file extensions.
Constant width
	
Used for program listings, as well as within paragraphs to refer to program ele-
ments such as variable or function names, databases, data types, environment 
variables, statements, and keywords.
Constant width bold
	
Shows commands or other text that should be typed literally by the user.
Constant width italic
	
Shows text that should be replaced with user-supplied values or by values deter-
mined by context.
	
	 This icon signifies a tip, suggestion, or general note.
	
This icon indicates a warning or caution.
Using Code Examples
This book is here to help you get your job done. In general, you may use the code in 
this book in your programs and documentation. You do not need to contact us for 
permission unless you’re reproducing a significant portion of the code. For example, 
writing a program that uses several chunks of code from this book does not require 
permission. Selling or distributing a CD-ROM of examples from O’Reilly books does 
not require permission. Answering a question by citing this book and quoting example 
code does not require permission. Incorporating a significant amount of example 
code from this book into your product’s documentation does require permission.
We appreciate, but do not require, attribution. An attribution usually includes the 
title, author, publisher, and ISBN. For example: “Mathematica Cookbook by Salvatore 
Mangano. Copyright 2010 O’Reilly Media, Inc., 978-0-596-52099-1.”

xxiv  |  Preface
If you feel your use of code examples falls outside fair use or the permission given 
above, feel free to contact us at permissions@oreilly.com.
Safari® Enabled
Safari Books Online is an on-demand digital library that lets you 
easily search over 7,500 technology and creative reference books 
and videos to find the answers you need quickly.
With a subscription, you can read any page and watch any video from our library 
online. Read books on your cell phone and mobile devices. Access new titles be-
fore they are available for print, and get exclusive access to manuscripts in devel-
opment and post feedback for the authors. Copy and paste code samples, organize 
your favorites, download chapters, bookmark key sections, create notes, print out 
pages, and benefit from tons of other time-saving features.
O’Reilly Media has uploaded this book to the Safari Books Online service. To 
have full digital access to this book and others on similar topics from O’Reilly and 
other publishers, sign up for free at http://my.safaribooksonline.com.
How to Contact Us
Please address comments and questions concerning this book to the publisher: 
O’Reilly Media, Inc.
1005 Gravenstein Highway North 
North Sebastopol, CA 95472 
800-998-9938 (in the United States or Canada) 
707-829-0515 (international or local) 
707 829-0104 (fax)
We have a web page for this book, where we list errata, examples, and any additional 
information. You can access this page at: 
http://www.oreilly.com/catalog/9780596521004 
To comment or ask technical questions about this book, send email to: 
bookquestions@oreilly.com
For more information about our books, conferences, Resource Centers, and the 
O’Reilly Network, see our web site at:
http://www.oreilly.com

CHAPTER 1
Numerics
Jenny I’ve got your number
I need to make you mine 
Jenny don’t change your number 
Eight six seven five three oh nine 
Eight six seven five three oh nine 
Eight six seven five three oh nine 
Eight six seven five three oh nine
Tommy Tutone, “867-5309/Jenny”
1.0 Introduction
Numerical Types
Mathematics is a huge, almost all-encompassing subject, and the average layperson 
often fails to appreciate the types of exotic objects that are in the mathematician’s 
domain. Yet every person on the street perceives math is about numbers. So even 
though numbers only scratch the surface of math and Mathematica, it makes sense 
to begin with their representation.
Mathematica supports four numerical types: Integer, Rational, Real, and Complex. In 
the following examples we use Mathematica’s comment notation (*comment*).
1        (*The integer one*) 
1 / 2    (*The rational one half*)
1.2 ^ 8  (*The real 1.2 x 10^8*) 
3 + 2 I  (*The complex number 3+2i*)
There is no need to take my word that these expressions have the specified types. 
You can ask Mathematica to tell you using the function Head[], which returns the 
head of an expression (i.e., head of a list). 
In[2]:=
Head@1D
Out[2]=
Integer
1

In[3]:=
Head@1ê2D
Out[3]=
Rational
In[4]:=
Head@1.2 ^ 8D
Out[4]=
Real
In[5]:=
Head@3 + 2 ID
Out[5]=
Complex
Although Mathematica does not internally store numbers as lists, it provides the illu-
sion that a number has a head indicating its type. This is consistent with the fact
that everything in Mathematica is an expression and every expression must have a
head. It is also common for Mathematica to use the head to indicate type when con-
structing more complex objects. See Recipe 1.5, for example. If you are confused by
this, for now, just think of Head as returning a type name when presented with an
atomic expression (expressions that can’t be divided into subexpressions).  
Exact and Approximate Results
Mathematica is unique in comparison to most mathematical tools and programming
languages in that it will usually produce exact results unless you tell it otherwise.
The following examples show the difference between exact and approximate results.
Recipes 1.1 and 1.2 show you how to make Mathematica use the appropriate form.
Exact results are displayed in their entirety when possible or symbolically when full
display would be impossible due to the infinity of the exact representation.
In[6]:=
3 ^ 1000
Out[6]=
1322070819480806636890455259752 144 365 965 422 032 752 148 167 664 920 368 226Ö
828597346704899540778313850608 061 963 909 777 696 872 582 355 950 954 582 100Ö
618911865342725257953674027620 225 198 320 803 878 014 774 228 964 841 274 390Ö
400117588618041128947815623094 438 061 566 173 054 086 674 490 506 178 125 480Ö
344405547054397038895817465368 254 916 136 220 830 268 563 778 582 290 228 416Ö
398307887896918556404084898937 609 373 242 171 846 359 938 695 516 765 018 940Ö
588109060426089671438864102814 350 385 648 747 165 832 010 614 366 132 173 102Ö
768902855220001
In[7]:=
Sqrt@2D
Out[7]=
2
Approximate numeric results are represented in machine precision floating point by
default.  On  most  modern  computers,  this  means  double-precision  floating-point
numbers, which contain a total of 64 binary bits, typically yielding 16 decimal digits
of mantissa. You can also specify numbers with greater than machine precision (see
2 | Chapter 1: Numerics

Recipe 1.1) but there is a performance cost: Mathematica must switch from the na-
tive hardware-based floating-point algorithms to software-based ones.
In[8]:=
3. ^ 1000
Out[8]=
1.322070819480807µ10477
In[9]:=
Sqrt@2.D
Out[9]=
1.41421
By adding a decimal point to a number, you force Mathematica to treat it as approxi-
mate. These approximate numbers will be machine precision by default, but there
are several ways to force higher precision. Recipes 1.1 and 1.2 in this chapter will
elaborate on these differences.
Numerical Expressions
The previous examples show simple numerical expressions. In practice, Mathemat-
ica follows general mathematical notation, but in many cases this means that there
are  multiple  ways  to  express  the  same  thing.  Let’s  consider  each  of  the  com-
mon operations that arise in algebra. There are several ways to express multiplica-
tion, division, and other arithmetic operations. A single space between expressions
(e.g.,  variables,  numbers)  implies  multiplication,  as  is  the  typical  convention
among  mathematicians. You can evaluate typeset mathematics using special sym-
bols, such as ×. You can also use Full Form (e.g., Plus, Times, Divide), but for arith-
metic this is unnecessarily verbose.
In[10]:=
9 + 8
Out[10]=
17
In[11]:=
Plus@9, 8D
Out[11]=
17
In[12]:=
9 µ 8
Out[12]=
72
In[13]:=
a = 9; b = 8;
a b
Out[14]=
72
In[15]:=
Times@9, 8D
Out[15]=
72
In[16]:=
8ê9
Out[16]=
8
9
1.0 Introduction | 3

In[17]:=
8
9
Out[17]=
8
9
In[18]:=
Divide@8, 9D
Out[18]=
8
9
The various representations are known as “forms” in Mathematica (e.g., InputForm,
OutputForm, TraditionalForm, etc.). Recipe 1.7 shows you how to control what form
is used for output of results. Controlling what form is used for input is a function of
using  the  various  features  of  the  Mathematica  frontend  (palettes,  shortcut  keys,
etc.). This book will not discuss the use of the frontend, since its main focus is pro-
gramming,  and  there  are  numerous  other  resources  (the  best  being  the  integrated
help system) for mastering the frontend. 
Numerical Approximations
Mathematica is famous for its symbolic abilities; however, when it comes to numeri-
cal methods it is also no slouch! The core functions for numerical solutions are NSum,
NProduct, NSolve, NIntegrate, and NDSolve. These are covered in Chapters 10 and 12.
1.1 Controlling Precision and Accuracy
Problem
You want numerical results that are to a specified numerical precision and accuracy.
Solution
Use N[] to convert from exact to approximate form while controlling precision and
accuracy to the desired amount. 
In[19]:=
N@1ê5D
Out[19]=
0.2
4 | Chapter 1: Numerics

You can explicitly specify the precision as a second argument to N[].
In[20]:=
N@1ê17, 10D
Out[20]=
0.05882352941
You can also explicitly specify both the precision and accuracy, but this is less com-
mon. You might do this to guarantee a fixed number of decimal places independent
of the size of the actual number. 
In[21]:=
NA817, 1ê17<, 9Infinity, 10=E
Out[21]=
817.000000000, 0.0588235294<
To drive this point home, I ask you to consider the following. The first column uses
fixed precision, whereas the second uses infinite precision and fixed accuracy.
In[22]:=
TableAWith A8x = 10^n + 1ê17<, 9N@x, 10D, NAx, 9Infinity, 10=E=E,
8n, 0, 5<E êê TableForm
Out[22]//TableForm=
1.058823529
1.058823529
10.05882353
10.058823529
100.0588235
100.058823529
1000.058824
1000.058823529
10000.05882 10000.0588235294
100000.0588 100000.0588235294
Discussion
For most purposes, treat precision as the total number of digits in the decimal repre-
sentation of a number and accuracy as the total number of digits after the decimal.
As such, precision is a measure of relative uncertainty (given a precision p a larger
number will have more uncertainty than a smaller number). Accuracy is an absolute
measure of uncertainty because the number of places after the decimal is indepen-
dent of the magnitude of the number. Typically you only need to control precision
in most applications. 
There are two common syntaxes for using N[]. You already saw the functional
syntax in the solution section. The second uses Mathematica’s postfix notation. See
the  sidebar  “Mathematica  Expressions”  on  page  6  for  a  discussion  of  postfix  and
other notations.
In[29]:=
Sqrt@2D êê N
Out[29]=
1.41421
1.1 Controlling Precision and Accuracy | 5

Mathematica Expressions
Mathematica contains quite a bit of syntactic sugar that gives users the flexibility to enter
expressions in a variety of ways. Developers of traditional languages (C+, Java, Ruby, etc.)
are  not  typically  used  to  this  much  flexibility.  The  flexibility  stems  partly  from
mathematics itself, which often provides many notations to express the same concepts. It
also derives from Mathematica’s aim to be a platform for publishing mathematical
ideas as much as a computer-aided mathematics tool and programming language.
At this point in the book, I do not go over all possible ways Mathematica can display
input  and  output.  Rather,  I  introduce  the  reader  to  four  basic  syntaxes  for
Mathematica expressions. This was a point of confusion for me when I first learned
Mathematica, so I believe it is best to attend to it now.
Functional notation
This is the most common notation. When we use N[value,precision], we are
using the functional notation for N.
Infix notation
Infix notation is most common for operators such as +, -, *, etc. However, infix
notation can be used for any function f by using the syntax ~f~.
Postfix notation
Some operators, like ! for Factorial[], use postfix notation, but as we already
saw with N, postfix notation can be generally applied for function f using //f. 
Prefix notation
Some  operators,  like  -  (unary  Minus),  use  prefix  notation,  but  there  is  also  a
general way to use prefix notation for any function f using the syntax f@.
Here  are  some  examples  using  N.  Notice  that  when  you  use  prefix  or  postfix  and
need to supply an argument, you must use Mathematica’s syntax for pure functions
where # is used as a placeholder for the input and & is added as a postfix operator
alias for Function[]. 
N@1ê2, 10D H*Function*L
0.5000000000
1ê2 ~N~ 10 H*Infix*L
0.5000000000
1ê2 êê N H*Postfix*L
0.5
1ê2 êê N@Ò, 10D & H*Postfix with argument*L
0.5000000000
Nü1ê2 H*Prefix*L
0.5
N@Ò, 10D &ü1ë 2 H*Prefix with argument*L
0.5000000000
6 | Chapter 1: Numerics

It is common to use this notation to force Mathematica to convert an exact or sym-
bolic result to an approximate result as the last step in a computation. When you
use postfix notation, you can explicitly specify the precision, but it is a bit awkward.
In[30]:=
Sqrt@2D êê N@Ò, 10D &
Out[30]=
1.414213562
When you don’t specify precision, Mathematica uses MachinePrecision, which is a
built-in symbol that denotes the precision native to your computer’s floating-point
capabilities.  The  numerical  value  of  MachinePrecision  is  stored  in  a  variable
$MachinePrecision.
In[31]:=
$MachinePrecision
Out[31]=
15.9546
There is another notation that is less common but you may come across it in Mathe-
matica output. If a literal number is displayed with a trailing ` (backtick) followed
optionally by a number, this indicates the number is either in machine precision or
is in the precision specified by the number following the backtick.
In[32]:=
20` H*20 in machine precision*L
Out[32]=
20.
In[33]:=
20`20 H*20 with high precision of 20 digits*L
Out[33]=
20.000000000000000000
In a complex expression with a lot of high-precision numbers, you can avoid specify-
ing each precision individually by using SetPrecision[].
In[34]:=
SetPrecision@20. + 1ê3 * 12.3 ê 37.8 + Pi, 20D
H*All numbers will be set to a precision of 20.*L
Out[34]=
23.250058262055400604
You  may  find  it  surprising  that  $MachinePrecision  is  not  an  integer.
The  reason  stems  from  the  formal  definition  of  precision,  which  is
derived from considering a number x and its uncertainty dx and using
the expression - Log[10, dx/x]. Accuracy is defined as - Log[10, dx]. 
1.1 Controlling Precision and Accuracy | 7

If you have an expression and need to know the precision or accuracy, you can use
the following functions.
In[35]:=
Precision@2.D
Out[35]=
MachinePrecision
In[36]:=
Precision@2`20D
Out[36]=
20.
Exact results have infinite precision.
In[37]:=
Precision@Sqrt@2DD
Out[37]=
¶
In[38]:=
Precision@Sqrt@2.DD
Out[38]=
MachinePrecision
In[39]:=
Accuracy@2.D
Out[39]=
15.6536
You are not guaranteed the accuracy you specify if the precision is too small.
In[40]:=
Accuracy@N@30, 820, 20<DD
Out[40]=
18.5229
With enough precision, however, you will get accuracy.
In[41]:=
Accuracy@N@30, 830, 20<DD
Out[41]=
20.
And precision can even be specified as infinite!
In[42]:=
AccuracyANA30, 9Infinity, 20=EE
Out[42]=
20.
Mathematica also defines two internal variables: $MinPrecision, whose default value
is minus infinity, and $MaxPrecision, whose default value is plus infinity.  
In[43]:=
9$MinPrecision, $MaxPrecision=
Out[43]=
80, ¶<
You can control precision within a complex calculation (without using N[] on every
intermediate  result)  by  changing  these  values;  however,  you  should  only  do  so
within a Block (a local context). For example, compare the difference between a cal-
culation  with  automatic  precision  for  intermediate  results  to  the  same  calculation
with  fixed  precision  (obtained  by  making  $MinPrecision  ==  $MaxPrecision).
Note  that  we  must  still  start  out  the  calculation  with  base  values  of  at  least
8 | Chapter 1: Numerics

$MinPrecision, otherwise the value will revert to the lowest precision, as explained
in Recipe 1.2. 
In[44]:=
SetPrecision@H1 + Exp@Sqrt@2D + Sqrt@3DDL ê 2^25, 32D
Out[44]=
7.226780742612584668840452114476µ10-7
In[45]:=
BlockA9$MinPrecision = 32, $MaxPrecision = 32=,
SetPrecision@H1 + Exp@Sqrt@2D + Sqrt@3DDLê2^25, 32DE
Out[45]=
7.2267807426125846688404521144759µ10-7
However, unless you have a very specific reason to control precision yourself, it is
generally best to let Mathematica automatically handle this for you. 
See Also
The Wolfram documentation for N[] is here: http://bit.ly/XVe2E.
Discussions of precision and accuracy can be found at  http://bit.ly/15qq2N and
http://bit.ly/icrh1. 
The most thorough discussions of precision and accuracy in Mathematica can be found in
Chapter 8 of An Introduction to Programming with Mathematica (Cambridge University
Press) and The Mathematica GuideBook for Numerics (Springer). 
A  nice  essay  by  David  Goldberg  called  “What  Every  Computer  Scientist  Should
Know About Floating-Point Arithmetic” can be found at http://bit.ly/1EJ23y. 
1.2 Mixing Different Numerical Types
Problem
You need to predict what Mathematica will do with expressions containing mixed
types and representations. 
Solution
The general rule of thumb is that the least precise type will determine the type of the result. 
Mixing exact values and symbols
When  expressions  containing  exact  numeric  values  (integers  and  rationals)  are
mixed with symbols, Mathematica will keep all results in the most general form, pos-
sibly reducing rationals to integers but leaving symbolic values in symbolic form.
1.2 Mixing Different Numerical Types | 9

In[46]:=
H2 PiLê3 + Piê3
Out[46]=
p
In[47]:=
Sqrt@Sin@2 Pi ED ê 1ê2 E^2D
Out[47]=
‰
1
2
Sin@2 ‰ pD
Mixing exact values and approximate values
When an approximate value is used in an otherwise symbolic expression, it forces
Mathematica to convert to approximate values.
In[48]:=
H2.0 PiLê3 + Piê3
Out[48]=
3.14159
In[49]:=
1. + H2 PiLê3 + Piê3
Out[49]=
4.14159
Mixing values of different precision and accuracy
When you mix values of different precision and accuracy, the lower precision and ac-
curacy will determine the result. For multiplication, the precision of the result will
be exactly the minimum of the precision of each term, whereas the accuracy will be
somewhat less. 
In[50]:=
x = N@Sqrt@2D, 30D * N@Sqrt@3D, 10D
Out[50]=
2.449489743
In[51]:=
Precision@xD
Out[51]=
10.
In[52]:=
Accuracy@xD
Out[52]=
9.61092
For addition, the accuracy of the result will be exactly the minimum of the accuracy
of each term; the precision will be somewhat more. 
In[53]:=
x = NASqrt@5D, 9Infinity, 30=E + NASqrt@7D, 9Infinity, 10=E
Out[53]=
4.8818192886
In[54]:=
Precision@xD
Out[54]=
10.6886
In[55]:=
Accuracy@xD
Out[55]=
10.
10 | Chapter 1: Numerics

Discussion
When mixing exact values with inexact values, it is possible to gain precision. 
In[56]:=
Precision@N@Sqrt@2D, 20DD
Out[56]=
20.
In[57]:=
Precision@2 + N@Sqrt@2D, 20DD
Out[57]=
20.3828
The gain in precision will be greater when the magnitude of the exact number domi-
nates that of the inexact number, as we see in this generated table.
In[2]:=
TableFormATable@
82^n + N@Sqrt@2D, 20D, Precision@2^n + N@Sqrt@2D, 20DD<, 8n, 0, 10<D,
TableHeadings Ø 8None, 8"Result", "Precision"<< E
Out[2]//TableForm=
Result
Precision
2.4142135623730950488
20.2323
3.4142135623730950488
20.3828
5.4142135623730950488
20.583
9.4142135623730950488
20.8233
17.4142135623730950488
21.0904
33.4142135623730950488
21.3734
65.4142135623730950488
21.6652
129.4142135623730950488
21.9615
257.4142135623730950488
22.2601
513.4142135623730950488
22.56
1025.4142135623730950488 22.8604
See Also
The most thorough discussions of Mathematica’s numerical rules can be found in
Chapter 8 of An Introduction to Programming with Mathematica and The Mathemat-
ica GuideBook for Numerics.  
1.2 Mixing Different Numerical Types | 11

1.3 Representing Numbers in Other Bases
Problem
Your application calls for a different numerical base than 10. 
Solution
Mathematica uses notation of the form base^^digits to represent numbers in differ-
ent bases. There must not be any internal whitespace in this representation.
In[59]:=
2^^101
H*Binary*L
Out[59]=
5
In[60]:=
16^^FFFF H*Hexidecimal*L
Out[60]=
65535
Discussion
In addition to expressing numbers in other bases, you can convert numbers to other
bases with BaseForm[digits, base]. The base must be an integer between 2 and 36
when using either ^^ or BaseForm[]. Mathematica uses the letters a through z to repre-
sent digits higher than 10. 
In[61]:=
BaseForm@2^^1010101, 16D
Out[61]//BaseForm=
5516
If you do math in another base, the output will still default to decimal, but you can
use BaseForm to convert the output of a function to hex.
In[62]:=
16^^A0 + 16^^0F êê BaseForm@Ò, 16D &
Out[62]//BaseForm=
af16
In[63]:=
HashA"Hello, my name is Sal", "MD5"E êê BaseForm@Ò, 16D &
Out[63]//BaseForm=
a275144453239f0279228469f229688116
You can also convert real and complex numbers to other bases.
In[64]:=
123.777 êê BaseForm@Ò, 16D &
Out[64]//BaseForm=
7b.c6f16
12 | Chapter 1: Numerics

In[65]:=
12.1 + 67.2 I êê BaseForm@Ò, 16D &
Out[65]//BaseForm=
c.199a16 + 43.33316 Â
See Also
Recipe 1.5 shows how to extract digits of a number in alternate bases. 
1.4 Extracting the Digits of a Number
Problem
You want to extract the individual digits of a number to manipulate them individually.
Solution
The functions IntegerDigits[] and RealDigits[] make this task easy.
IntegerDigits[]  returns  a  list  of  digits  in  base  10.  See  the  “Discussion”  section,
next, for additional options.
In[66]:=
IntegerDigits@12345D
Out[66]=
81, 2, 3, 4, 5<
RealDigits[] returns a two-item list with the first item being the digits in base 10
and the second being the position of the decimal point. See the “Discussion” section
for additional options. First consider the digits display with N[] alone.
In[67]:=
N@1ê31D
Out[67]=
0.0322581
Notice how RealDigits[] automatically extracts more precision to return the num-
ber of digits necessary to get to the point at which they begin to repeat in the deci-
mal expansion. 
In[68]:=
RealDigits@N@1ê31D, 10D
Out[68]=
883, 2, 2, 5, 8, 0, 6, 4, 5, 1, 6, 1, 2, 9, 0, 3<, -1<
Discussion
Both RealDigits[] and IntegerDigits[] take the desired base and the number of de-
sired digits (length) as optional second and third arguments, respectively.
In[69]:=
12!
Out[69]=
479001600
1.4 Extracting the Digits of a Number | 13

In[70]:=
IntegerDigits@12!, 10, 5D
Out[70]=
80, 1, 6, 0, 0<
In[71]:=
12! êê BaseForm@Ò, 16D & H*Consider 12! in base 16.*L
Out[71]//BaseForm=
1c8cfc0016
In[72]:=
IntegerDigits@12!, 16D
H*Notice how IntegerDigits
with base 16 gives the digit values in base 10.*L
Out[72]=
81, 12, 8, 12, 15, 12, 0, 0<
In[73]:=
IntegerDigits@12!, 16D êê BaseForm@Ò, 16D &
H*But you can easily force them to base 16.*L
Out[73]//BaseForm=
8116, c16, 816, c16, f16, c16, 016, 016<
RealDigits can take an additional fourth argument that specifies where in the deci-
mal expansion to start. If b is the base, then the fourth argument n means to start the
counting at the coefficient signified by b^n. The following examples should clarify.
In[74]:=
N@Pi, 10D
H*Pi to 10 digits of precision.*L
Out[74]=
3.141592654
In[75]:=
RealDigits@Pi, 10, 3D
H*Extract first three digits. Decimal place is indicated as 1.*L
Out[75]=
883, 1, 4<, 1<
Start at 10^-2 = 0.01, or the second digit after the decimal.
In[76]:=
RealDigits@Pi, 10, 3, -2D
H*Extract third to fifth digit. Decimal place is indicated as -2.*L
Out[76]=
884, 1, 5<, -1<
Start at 10^-5 = 0.00001, or the fifth digit after the decimal.
In[77]:=
RealDigits@Pi, 10, 3, -5D
Out[77]=
889, 2, 6<, -4<
In[78]:=
N@Pi, 10D êê BaseForm@Ò, 2D &
Out[78]//BaseForm=
11.00100100001111110110101010001002
Here we get the digits of pi in base 2.
In[79]:=
RealDigits@Pi, 2, 5, -2D
Out[79]=
880, 1, 0, 0, 1<, -1<
Here is an interesting application in which IntegerDigits is combined with the
Tuples function and a bit of pattern matching to get all n digits without calling
14 | Chapter 1: Numerics

IntegerDigits[] more than once. We used Short to elide the full list. (Short places
<<n>> in the output to indicate n missing items.)
In[80]:=
TuplesAIntegerDigits@43210D, 4E êê Short@Ò, 4D &
Out[80]//Short=
884, 4, 4, 4<, 84, 4, 4, 3<, 84, 4, 4, 2<, 84, 4, 4, 1<, 84, 4, 4, 0<, 84, 4, 3, 4<,
84, 4, 3, 3<, 84, 4, 3, 2<, 84, 4, 3, 1<, 84, 4, 3, 0<, 84, 4, 2, 4<,
84, 4, 2, 3<, 84, 4, 2, 2<, 84, 4, 2, 1<, 84, 4, 2, 0<, 84, 4, 1, 4<,
84, 4, 1, 3<, 84, 4, 1, 2<, 84, 4, 1, 1<, 84, 4, 1, 0<, 84, 4, 0, 4<,
84, 4, 0, 3<, 84, 4, 0, 2<, á579à, 80, 0, 4, 2<, 80, 0, 4, 1<, 80, 0, 4, 0<,
80, 0, 3, 4<, 80, 0, 3, 3<, 80, 0, 3, 2<, 80, 0, 3, 1<, 80, 0, 3, 0<,
80, 0, 2, 4<, 80, 0, 2, 3<, 80, 0, 2, 2<, 80, 0, 2, 1<, 80, 0, 2, 0<,
80, 0, 1, 4<, 80, 0, 1, 3<, 80, 0, 1, 2<, 80, 0, 1, 1<, 80, 0, 1, 0<,
80, 0, 0, 4<, 80, 0, 0, 3<, 80, 0, 0, 2<, 80, 0, 0, 1<, 80, 0, 0, 0<<
If you do not want the cases with leading zeros, you can use DeleteCases as follows.
In[81]:=
DeleteCasesATuplesAIntegerDigits@43 210D, 4E,
8z__ ê; z == 0, n__<E êê Short@Ò, 4D &
Out[81]//Short=
884, 4, 4, 4<, 84, 4, 4, 3<, 84, 4, 4, 2<, 84, 4, 4, 1<, 84, 4, 4, 0<, 84, 4, 3, 4<,
84, 4, 3, 3<, 84, 4, 3, 2<, 84, 4, 3, 1<, 84, 4, 3, 0<, 84, 4, 2, 4<,
84, 4, 2, 3<, 84, 4, 2, 2<, 84, 4, 2, 1<, 84, 4, 2, 0<, 84, 4, 1, 4<,
84, 4, 1, 3<, 84, 4, 1, 2<, 84, 4, 1, 1<, 84, 4, 1, 0<, 84, 4, 0, 4<,
84, 4, 0, 3<, 84, 4, 0, 2<, á454à, 81, 0, 4, 2<, 81, 0, 4, 1<, 81, 0, 4, 0<,
81, 0, 3, 4<, 81, 0, 3, 3<, 81, 0, 3, 2<, 81, 0, 3, 1<, 81, 0, 3, 0<,
81, 0, 2, 4<, 81, 0, 2, 3<, 81, 0, 2, 2<, 81, 0, 2, 1<, 81, 0, 2, 0<,
81, 0, 1, 4<, 81, 0, 1, 3<, 81, 0, 1, 2<, 81, 0, 1, 1<, 81, 0, 1, 0<,
81, 0, 0, 4<, 81, 0, 0, 3<, 81, 0, 0, 2<, 81, 0, 0, 1<, 81, 0, 0, 0<<
The inverse of IntegerDigits[] is FromDigits[].  
In[82]:=
FromDigitsAIntegerDigits@987654321DE
Out[82]=
987654321
In[83]:=
FromDigitsAIntegerDigits@987654321, 2D, 2E H*Base 2*L
Out[83]=
987654321
FromDigits[] has the added capability of converting strings and roman numerals.
In[84]:=
FromDigits@"4750"D + 1
Out[84]=
4751
In[85]:=
FromDigits@"MMXIX", "Roman"D - 10
Out[85]=
2009
1.4 Extracting the Digits of a Number | 15

IntegerString[] is used to convert back to string form. I use InputForm only so the
quotes are displayed.
In[86]:=
IntegerString@4750D êê InputForm
Out[86]//InputForm=
"4750"
In[87]:=
IntegerString@2009, "Roman"D êê InputForm
Out[87]//InputForm=
"MMIX"
1.5 Working with Intervals
Problem
You  need  to  compute  with  data  subject  to  measurement  errors  and  you  need  the
greatest possible estimate on the final error.
Solution
As an alternative to doing math directly on numbers, Mathematica allows you to do
math on intervals that define the uncertainty in a value. 
In[88]:=
ClearAerror1, error2, mass, velocity, kineticEnergyE;
error1 = 0.01; error2 = 0.005;
mass = Interval@81.10 - error1, 1.10 + error1<D;
velocity = Interval@87.50 - error2, 7.50 + error2<D;
kineticEnergy = 1ê2 mass velocity ^ 2
Out[92]=
Interval@830.6154, 31.2604<D
By representing them as intervals, we express the idea that there are some known er-
rors in the measurement of the value of mass and velocity. We would like to under-
stand what that means in terms of the value we compute for kinetic energy. 
You can see that the resulting error range is magnified by the combination of each er-
ror and the squaring.
In[93]:=
Subtract üü kineticEnergy@@1DD êê
Abs H*This computes the size of the interval.*L
Out[93]=
0.645
16 | Chapter 1: Numerics

If there were only a single interval of uncertainty, the range would be smaller.
In[94]:=
ClearAerror1, mass, velocity, kineticEnergyE;
error1 = 0.01;
mass = Interval@81.10 - error1, 1.10 + error1<D;
velocity = 7.5;
kineticEnergy = 1ê2 mass velocity^2
Out[98]=
Interval@830.6562, 31.2188<D
In[99]:=
Subtract üü kineticEnergy@@1DD êê Abs
Out[99]=
0.5625
Discussion
Intervals  are  objects  with  head  Interval  and  a  sequence  of  one  or  more  lists  that
represent segments of the interval. Typically there is one list, but non-overlapping
intervals can be expressed using two or more lists.
In[100]:=
Interval@81, 2<D
Out[100]=
Interval@81, 2<D
In[101]:=
Interval@81, 2<, 83, 4<D
Out[101]=
Interval@81, 2<, 83, 4<D
Intervals will automatically reorder themselves so that the least value is first.
In[102]:=
Interval@82, 1<D
Out[102]=
Interval@81, 2<D
In[103]:=
Interval@84, 3<, 82, 1<D
Out[103]=
Interval@81, 2<, 83, 4<D
Naturally, the standard mathematical operations for scalars work on intervals as well.
In[104]:=
Interval@81, 2<D + Interval@83, 4<D
Out[104]=
Interval@84, 6<D
In[105]:=
Interval@81, 2<D Interval@83, 4<D H*Implied multiplication*L
Out[105]=
Interval@83, 8<D
In[106]:=
Interval@81, 2<D ê Interval@83, 4<D
Out[106]=
IntervalC;
1
4
,
2
3
?G
In[107]:=
Sqrt@Interval@81.0, 2.0<DD
Out[107]=
Interval@81., 1.41421<D
1.5 Working with Intervals | 17

There  are  also  functions  specifically  for  working  with  intervals.  IntervalUnion[]
gives the interval representing set of all points of the input intervals. IntervalInter-
section[]  gives  the  interval  in  common  among  the  inputs  and  IntervalMemberQ[]
tests if a value belongs to an interval.
There are some cases in which Mathematica functions can return intervals. Consider
the problem of finding the limit of an oscillating function at a critical value.  
In[108]:=
Clear@xD;
LimitASin@xD + 1ê2 Cos@xD, x Ø InfinityE
Out[109]=
IntervalC;-
3
2
,
3
2
?G
In[110]:=
Limit@2 Sin@1êxD + 1ê2 Cos@xD, x Ø 0D
Out[110]=
IntervalC;-
3
2
,
5
2
?G
See Also
Papers and FAQs (as well as a movie) related to the theory of interval math can be
found at http://bit.ly/lbXoE.
1.6 Converting Between Numerical Types
Problem
You have a number of one type and need it represented in another type. 
Solution
Conversion from rational to integer happens automatically, when possible.
In[111]:=
Head@4ê2D
Out[111]=
Integer
Conversion  of  rational  to  integer  can  be  forced  by  using  Floor[],  Ceiling[],  and
Round[]. (Numbers of the form x.5 are rounded toward the nearest even integer.)
In[112]:=
Floor@5ê2D
Out[112]=
2
In[113]:=
Ceiling@5ê2D
Out[113]=
3
18 | Chapter 1: Numerics

In[114]:=
Round@5ê2D
Out[114]=
2
In[115]:=
Round@7ê2D
Out[115]=
4
We already saw in Recipe 1.1 how N[] can be used to convert exact values and sym-
bolic  constants  to  approximate  real  numbers.  Rationalize[]  is  how  you  convert
from approximate values to exact.
In[116]:=
Rationalize@3.14159D
Out[116]=
314159
100000
The single argument version of Rationalize will only succeed if a sufficiently close
(see “Discussion” section, next) rational number exists.
In[117]:=
Rationalize@3.1415927D
Out[117]=
3.14159
You  can  provide  a  second  argument  specifying  your  tolerance  for  error,  in  which
case the operation will always succeed.
In[118]:=
Rationalize@3.1415927, 10^-8D
Out[118]=
121033
38526
And you can force an exact rational by indicating a maximum error of zero.
In[119]:=
Rationalize@3.1415927, 0D
Out[119]=
31415927
10000000
Discussion
On the surface, the solutions here are rather simple. In day-to-day usage, numeric
conversion will not present many challenges. However, there are subtle issues and
interesting theory underlying the apparent simplicity. Let’s consider rounding. Sup-
pose you need to round a set of numbers, but the numbers still must satisfy some
constraint  after  the  rounding.  Consider  percentages  or  probabilities.  One  would
want percentages to still add to 100 and probabilities to still sum to 1. Another con-
text is in statistics, where we want to round while preserving certain statistical
properties, such as the variance. Various forms of stochastic rounding can be used
in these cases. One form of stochastic rounding that gives good results is the unbi-
ased rounding rule. According to this rule, a number of the form x.v is rounded up
1.6 Converting Between Numerical Types | 19

with the probability v/10 and rounded down with probability (10-v)/10. So, for
example, 10.5 would have equal probability of going to 10 as to 11, whereas 10.85 would
have probability of 0.85 of rounding up and 0.15 of rounding down.
In[120]:=
UnbiasedRound@x_D := Block@8whole = Floor@xD, v<,
v = 10 * Hx - wholeL; whole + Floor@ vê10 + RandomReal@DDD
In[121]:=
Table@UnbiasedRound@10.5D, 820<D
Out[121]=
811, 11, 10, 11, 10, 10, 10, 11, 11, 11, 10, 11, 11, 10, 10, 11, 11, 11, 11, 11<
In[122]:=
Table@UnbiasedRound@10.1D, 820<D
Out[122]=
810, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 11, 10, 10, 10<
In[123]:=
Table@UnbiasedRound@10.8D, 820<D
Out[123]=
811, 11, 11, 10, 11, 11, 11, 11, 11, 10, 11, 10, 11, 11, 10, 11, 11, 11, 11, 11<
The main disadvantage of stochastic rounding is that the results are not repeatable.
See Also
An Examination of the Effects of Rounding on the Quality and Confidentiality of Tabu-
lar Data by Lawrence H. Cox and Jay J. Kim (http://bit.ly/I7JdA).
1.7 Displaying Numbers in Alternate Forms
Problem
You don’t like the format that Mathematica chooses to display a particular numeri-
cal result.
Solution
Use  one  of  the  alternative  forms:  AccountingForm,  EngineeringForm,  NumberForm,
PaddedForm, and ScientificForm. The default form is usually the most compact way
to represent the number, but if you are outputting values that have specific user ex-
pectations or if you are trying to convey a specific accuracy, you may want to force a
different form.
In[124]:=
number = 3.50 * 1000000
Out[124]=
3.5µ106
Accounting  form  does  not  use  scientific  notation  and  shows  negative  numbers  in
parentheses. Here it is traditional to use the form as a postfix (//) operation.
20 | Chapter 1: Numerics

In[125]:=
number êê AccountingForm
Out[125]//AccountingForm=
3500000.
In[126]:=
-number êê AccountingForm
Out[126]//AccountingForm=
H3500000.L
Alternatively, NumberForm allows you to control the digits of precision and the num-
ber of digits after the decimal.
In[127]:=
NumberForm@number, 86, 4<D
Out[127]//NumberForm=
3.5000µ106
Discussion
Forms have an extensive set of options to provide fine-grained control over the out-
put. Here I use AccountingForm to display a column of numbers. DigitBlock specifies
the grouping factor and NumberPadding allows control of the characters used to pad
out the display on the left (shown here as spaces) and right (shown as zeros).
In[128]:=
AccountingFormAColumn@8100000.00, 1 000 000.00, 10 000 000.00<D,
89, 1<, DigitBlock Ø 3, NumberPadding Ø 8" ", "0"<E
Out[128]//AccountingForm=
100,000.00
1,000,000.00
10,000,000.00
Contrast this to AccountingForm without the options.
In[129]:=
AccountingForm@Column@8100000.00, 1 000 000.00, 10 000 000.00<DD
Out[129]//AccountingForm=
100000.
1000000.
10000000.
PaddedForm is convenient when all you want to do is pad out a number with specific
characters on the left and right. This is often a useful operation prior to conversion
to a string to generate fixed-length identifiers. 
In[130]:=
PaddedFormA10, 8, NumberPadding Ø 8"0", ""<E
Out[130]//PaddedForm=
000000010
1.7 Displaying Numbers in Alternate Forms | 21

In[131]:=
id = ToStringAPaddedFormA10, 8, NumberPadding Ø 8"0", ""<EE
Out[131]=
000000010
EngineeringForm forces exponents in multiples of three, provided an exponent of at
least three is required. 
In[132]:=
810.0, 100.0, 1000.0, 10000.0, 100 000.0, 1 000 000.0< êê EngineeringForm
Out[132]//EngineeringForm=
910., 100., 1.µ103, 10.µ103, 100.µ103, 1.µ106=
ScientificForm always shows numbers with one digit before the decimal and adjusts
the exponent accordingly.
In[133]:=
810.0, 100.0, 1000.0, 10000.0, 100 000.0, 1 000 000.0< êê ScientificForm
Out[133]//ScientificForm=
91.µ101, 1.µ102, 1.µ103, 1.µ104, 1.µ105, 1.µ106=
You can use the option NumberFormat to get precise control of the display. NumberFor-
mat specifies a function (see Chapter 2 for details) that accepts up to three arguments
for the mantissa, base, and exponent. Here is an example that displays numbers like
a calculator might. Here, the function uses Row to format the mantissa and exponent
(it ignores the base).
In[134]:=
ScientificForm@1.77 µ 10^5, NumberFormat Ø HRow@8Ò1, "E", Ò3<D &LD
Out[134]//ScientificForm=
1.77E5
See Also
You can find information and examples on all these forms and their options in the
Wolfram documentation under tutorial/OutputFormatsForNumbers.
22 | Chapter 1: Numerics

CHAPTER 2
Functional Programming
A man builds a city 
With banks and cathedrals
A man melts the sand so he can 
See the world outside
(You’re gonna meet her there) 
A man makes a car 
(She’s your destination)
And builds a road to run them on 
(Gotta get to her)
 A man dreams of leaving 
(She’s imagination)
But he always stays behind
And these are the days 
When our work has come asunder
And these are the days 
When we look for something other
2.0 Introduction
Many books on Mathematica tout its capabilities as a multiparadigm language. 
Although it’s true that Mathematica supports procedural, recursive, rule-based, func-
tional, and even object-oriented styles (to some degree), I believe it is the functional 
and rule-based styles that are most important to master. Some gurus may go a step 
further and say that if you do not master the functional style then you are not really
programming in Mathematica and your programs will have a far greater chance of
being inefficient and clumsy. I won’t be so dogmatic, but until you are an expert it’s
23

best to stick with an approach that many Mathematica experts prefer. A practi-
cal reason to learn the functional style is that most of the recipes in this book
use either functional or rule-based styles and sometimes mixtures of both. This chap-
ter is intended as a kind of decoder key for readers who want to master the func-
tional style and get a deeper understanding of the solutions throughout this book.
There are also a few recipes at the end of the chapter that are not about functional
programming proper, but rather techniques specific to Mathematica that allow you
to create flexible functions. These techniques are also used throughout later recipes
in the book.
The hallmark of the functional style is, of course, functions. Every high-level programming
language has functions, but what makes a language functional is that functions are first-
class entities (however, see the sidebar “What Is a Functional Programming Language . . .”
on page 31 for more subtle points). This means you can write higher-order functions
that take other functions as arguments  and  return  functions  as  values.  Another
important feature of functional languages is that they provide a syntactic method of
whipping up anonymous functions on the fly. These nameless functions are often re-
ferred to as “lambda functions,” although Mathematica calls them pure functions.
Unless you are already a convert to functional programming, why a functional ap-
proach  is  considered  superior  may  not  be  obvious  to  you.  A  general  consensus
among software developers is that given two correct solutions to a problem, the sim-
pler solution is the superior one. Simplicity is sometimes difficult to define, but one
metric has to do with the length of the solution in lines of code. You will find, al-
most without exception, that a high-quality functional solution will be more concise
than a high-quality procedural solution. This stems partly from the fact that looping
constructs disappear (become implicit) in a functional solution. In a procedural pro-
gram, code must express the loop, which also introduces auxiliary index variables. 
Functional programs are often faster, but there are probably exceptions. Ignoring the
fact that Mathematica has a built-in function, Total, for a moment, let’s contrast a
procedural and functional program to sum an array of 100,000 random values.
In[1]:=
array = RandomReal@8-1, 1<, 100000D;
In[2]:=
H*Procedural solution using For loop*L
Isum = 0 ;
DoAsum += array@@iDD, 9i, 1, LengthAarrayE=E;
sumM êê Timing
Out[2]=
80.21406, 90.6229<
In[3]:=
H*Functional solution using Fold*L
FoldAPlus, 0, arrayE êê Timing
Out[3]=
80.008291, 90.6229<
24 | Chapter 2: Functional Programming

As  you  can  see,  the  functional  solution  was  about  an  order  of  magnitude  faster.
Clearly the functional solution is shorter, so that is an added bonus. Of course, one
of the tricks to creating the shortest and the fastest programs is exploiting special
functions when they exist. In this case, Total is the way to go!
In[4]:=
TotalAarrayE êê Timing
Out[4]=
80.000193, 90.6229<
If you come from a procedural background, you may find that style more comfort-
able. However, when you begin to write more complex code, the procedural style be-
gins to be a liability from a complexity and performance point of view. This is not
just a case of shorter being sweeter. In a very large program, it is common to intro-
duce  a  large  number  of  index  and  scratch  variables  when  programming  procedu-
rally.  Every  variable  you  introduce  becomes  a  variable  whose  meaning  must  be
tracked. I wish I had a dollar for every bug caused by a change to code that used in-
dex variable i when j was intended! It should come as no surprise that eliminating
these scratch variables will result in code that is much faster. In fact, in a typical pro-
cedural language like C, it is only through the efforts of a complex optimizing com-
piler that these variables disappear into machine registers so that maximum speed is
obtained. In an interpreted language like Mathematica, these variables are not opti-
mized away and, hence, incur a significant overhead each time they appear. By adopt-
ing a functional approach, you get almost the equivalent of optimized machine code
with the pleasure of interactive development.
There are a lot more theoretical reasons for adopting a functional approach. Some in-
volve the ability to prove programs correct or the ability to introduce concurrency. I
will not make those arguments here because they usually have only marginal value
for practical, everyday development and they hinge on a language being purer than
Mathematica. Readers who have interest in learning more should refer to some of
the excellent resources listed in the “See Also” section on page 30.
The Elements of Functional Programming
Many functional programming languages share core primitive functions that act as
the building blocks of more sophisticated functions and algorithms. The names of
these primitives vary from language to language, and each language provides its own
twists. However, when you learn the set of primitives of one functional language,
you will have an easier time reading and porting code to other functional languages. 
2.0 Introduction | 25

Table 2-1. Primary functional programming primitives
Function
Operator
Description
Map@f, exprD
êü
Return the list that results 
from executing the function f 
on each element of an expr
Apply@f, exprD
üü
Return the result of 
replacing the head of a list 
with function f
Apply@f, expr, 81<D
üüü
Applies f a level 1 inside 
list. In other words,replace 
the head of all elements.
Fold@f, x, 8a1, a2, a3, ...<D
NëA
If list has length 0,return 
x,otherwise return 
fAfAf@x, a1D, a2E, a3E…
FoldList@f, x,
8a1, a2, a3, ...<D
NëA
Return the list 
9x, f@x, a1D, fAf@x, a1D, a2E, …=
Nest@f, expr, nD
NëA
Return the result of 
fAfAfA... f@exprD...EEE (i.e. f 
applied n times)
NestList@f, expr, nD
NëA
Return the list 
9x, f@exprD, fAf@exprDE, ...= 
where f repeats up to n times
In the Mathematica documentation, you will see the verb apply (in its
various tenses) used in at least two senses. One is in the technical sense
of the function Apply[f,expr] (i.e., change the head of expr to f) and
the  other  in  the  sense  of  invoking  a  function  on  one  or  more
arguments  (as  in  “applied”  in  the  definition  of  Nest[],  “gives  an
expression with f applied n times to expr”). Clearly, changing the head
of the expression n times would be no different from changing it once,
so it should be unambiguous in most cases. See Recipe 2.1 for syntax
variations of the latter sense of function application.
There  are  other  important  Mathematica  functions  related  to  functional  program-
ming, but you should commit to memory the functions in Table 2-1, because they
arise repeatedly.  You  should  especially  get  used  to  the  operator  notations  for
26 | Chapter 2: Functional Programming

Map (/@) and Apply (@@) because they arise frequently (not only in this book but in
others  and  in  sample  code  you  will  find  online).  If  you  are  unfamiliar  with
these functions, it is worthwhile to experiment a bit. One important exercise is to
use each function with a symbol that is not defined and a list of varying structure so
you can see the effects from a structural point of view. For example, pay close atten-
tion to the difference between /@ and @@@. Each iterates the function across the list,
but the results are quite different. 
In  this  code,  zz  is  purposefully  undefined  so  you  can  visualize  the
effect of the operators. The ability of Mathematica to handle undefined
symbols  without  throwing  errors  is  both  a  source  of  power  and  a
source of frustration to the uninitiated.
In[5]:=
zz êü 81, 81<, 81, 2<<
Out[5]=
8zz@1D, zz@81<D, zz@81, 2<D<
In[6]:=
zz üü 81, 81<, 81, 2<<
Out[6]=
zz@1, 81<, 81, 2<D
In[7]:=
zz üüü 81, 81<, 81, 2<<
Out[7]=
81, zz@1D, zz@1, 2D<
In[8]:=
Fold@zz, 0, 81, 81<, 81, 2<<D
Out[8]=
zz@zz@zz@0, 1D, 81<D, 81, 2<D
In[9]:=
FoldList@zz, 0, 81, 81<, 81, 2<<D
Out[9]=
80, zz@0, 1D, zz@zz@0, 1D, 81<D,
zz@zz@zz@0, 1D, 81<D, 81, 2<D<
In[10]:=
Nest@zz, 81, 81<, 81, 2<<, 3D
Out[10]=
zz@zz@zz@81, 81<, 81, 2<<DDD
In[11]:=
NestList@zz, 81, 81<, 81, 2<<, 3D
Out[11]=
881, 81<, 81, 2<<, zz@81, 81<, 81, 2<<D,
zz@zz@81, 81<, 81, 2<<DD,
zz@zz@zz@81, 81<, 81, 2<<DDD<
DownValues and UpValues 
Mathematica  has  a  flexible  facility  for  associating  symbols  and  their  definitions.
Most of the time you need not be concerned with these low-level details, but some
advanced  Mathematica  techniques  discussed  in  this  chapter  and  elsewhere  in  the
book require you to have some basic understanding. When you define functions of
the form f[args] := definition or f[args] = definition you create downvalues for the
symbol f. You can inspect these values using the function DownValues[f].
2.0 Introduction | 27

In[12]:=
ClearAll@fD
f@0D := 1
f@1D := 1
fAn_IntegerE := n * f@n - 1D
In[16]:=
DownValues@fD
Out[16]=
9HoldPattern@f@0DD ß 1, HoldPattern@f@1DD ß 1,
HoldPatternAfAn_IntegerEE ß n f@n - 1D=
The results are shown as a list of patterns in held form (see Recipe 4.8). The order of
the definitions returned by DownValues is the order in which Mathematica will search for a
matching pattern when it needs to evaluate an expression containing f. Mathematica has a
general  rule  of  ordering  more  specific  definitions  before  more  general  ones;  when
there are ties, it uses the order in which the user typed them. In rare cases, you may
need to redefine the ordering by assigning a new order to DownValues[f]. 
In[17]:=
H*This reassignment won't affect usage of f,
but illustrates the technique.*L
DownValues@fD = DownValues@fD@@82, 1, 3<DD
Out[17]=
9HoldPattern@f@1DD ß 1, HoldPattern@f@0DD ß 1,
HoldPatternAfAn_IntegerEE ß n f@n - 1D=
There are some situations in which you would like to give new meaning to functions
native to Mathematica. These situations arise when you introduce new types of ob-
jects. For example, imagine Mathematica did not already have a package that sup-
ported quaternions (a kind of noncommutative generalization of complex numbers)
and you wanted to develop your own. Clearly you would want to use standard math-
ematical notation, but this would amount to defining new downvalues for the built-
in Mathematica functions Plus, Times, etc. 
Unprotect[Plus,Times]
Plus[quaternion[a1_,b1_,c1_,d1_], quaternion[a2_,b2_,c2_,d2_]] := ...
Times[quaternion[a1_,b1_,c1_,d1_], quaternion[a2_,b2_,c2_,d2_]] := ...
Protect[Plus,Times]
If quaternion math were very common, this might be a valid approach. However,
Mathematica provides a convenient way to associate the definitions of these opera-
tions  with  the  quaternion  rather  than  with  the  operations.  These  associations  are
called UpValues, and there are two syntax variations for defining them. The first uses
operations called UpSet (^=) and UpSetDelayed (^:=), which are analogous to Set (=)
and SetDelayed (:=) but create upvalues rather than downvalues. 
Plus[quaternion[a1_,b1_,c1_,d1_], quaternion[a2_,b2_,c2_,d2_]] ^:= ...
Times[quaternion[a1_,b1_,c1_,d1_], quaternion[a2_,b2_,c2_,d2_]] ^:= ...
28 | Chapter 2: Functional Programming

The alternate syntax is a bit more verbose but is useful in situations in which the
symbol the upvalue should be associated with is ambiguous. For example, imagine
you want to define addition of a complex number and a quaternion. You can use
TagSet or TagSetDelayed to indicate that the operation is an upvalue for quaternion
rather than Complex.
quaternion /: Plus[Complex[r_, im_], quaternion[a1_,b1_,c1_,d1_]] := ...
quaternion /: Times[Complex[r_, im_], quaternion[a1_,b1_,c1_,d1_]] := ...
Upvalues  solve  two  problems.  First,  they  eliminate  the  need  to  unprotect  native
Mathematica symbols. Second, they avoid bogging down Mathematica by forcing it
to consider custom definitions every time it encounters common functions like Plus
and  Times.  (Mathematica  aways  uses  custom  definitions  before  built-in  ones.)  By
associating the operations with the new types (in this case quaternion), Mathematica
need only consider these operations in expression where quaternion appears. If both
upvalues and downvalues are present, upvalues have precedence, but this is some-
thing you should avoid.
Function Attributes
Mathematica will modulate the behavior of functions based on a set of predefined
attributes, which users should already be familiar with as those often required
to achieve proper results in users’ own functions. The functions Attributes[f],
SetAttributes[f,attr],  and  ClearAttributes[f,attr]  are  used  to  query,  set,  and
clear attributes from functions. In the following subsections, I’ll review the most im-
portant attributes. Refer to the Mathematica documentation for attributes to review
the complete list.
Attributes  must  be  assigned  to  symbols  before  functions  are  defined
for the symbols.
Orderless
This tells Mathematica that the function is commutative. When Mathematica encounters
this function, it will reorder arguments into canonical order (sorted in ascending or-
der). Orderless also influences pattern matching (see Recipe 4.1) since Mathematica
will consider reordering when attempting to match.
2.0 Introduction | 29

Flat
Use  Flat  to  tell  Mathematica  that  nested  applications  of  the  function
(f[f[x,y],z])  can  be  flattened  out  (f[x,y,z]).  In  mathematics,  flat  functions  are
called associative. 
Listable
It  is  often  convenient  to  define  functions  that  automatically  map  across  lists.  See
Recipe 2.3 for more information.
HoldFirst
Mathematica defines a function Hold which prevents its argument from being evalu-
ated. The attribute HoldFirst allows you to give this feature to the first argument of
a function. All remaining arguments will behave normally.
HoldRest
This is the opposite of HoldFirst; the first argument is evaluated normally, but all
remaining arguments are kept in unevaluated form.
HoldAll
All arguments of the function are kept unevaluated. This is equivalent to using both
HoldFirst and HoldRest.
See Also
An excellent animated introduction to the core Mathematica functions can be found
at http://bit.ly/3cuB4B.
See guide/FunctionalProgramming in the documentation for an overview of Mathe-
matica’s functional programming primitives.
A classic paper on the benefits of functional programming is Why Functional Pro-
gramming Matters by John Hughes (http://bit.ly/4mRBYO).
Another classic is A Tutorial on the Universality and Expressiveness of Fold by Gra-
ham Hutton (PDF available at http://bit.ly/ZYDiH).
Further  discussion  of  upvalues  and  downvalues  can  be  found  at  tutorial/TheStandard-
EvaluationProcedure  and  tutorial/AssociatingDefinitionsWithDifferentSymbols  in  the
documentation.
30 | Chapter 2: Functional Programming

What Is a Functional Programming Language and 
How Functional Is Mathematica?
Anyone who has spent time in mail groups frequented by programmers knows they
like to argue. One of the favorite arguments centers around the “best programming
language.”  Derivatives  include  “what  language  is  the  most  [insert  characteristic
here]” arguments. For example, what language is the most “object-oriented,” “self-
documenting,” or in our case, “functional.” The problem is that such characteristics
rarely have an objective, a priori definition; rather, their definitions emerged out of
research  in  actual  language  use.  Since  each  researcher  is  interested  in  different
features, the definitions become fuzzy. It is thus difficult to give a precise definition
of  “functional”  with  which  every  computer  scientist  and  programmer  will  agree.
However, to help you discover more on your own, I provide some generally agreed-
on features that are important to the theory of functional programming and discuss
Mathematica’s support for these features. The usefulness of features rather than the
cachet  of  labels  (like  “functional”)  is  likely  the  primary  concern  of  readers  of
cookbooks!
All functional languages emphasize the evaluation of expressions to produce values
rather  than  commands  or  statements  that  are  executed  for  their  side  effects.
Consider the language C, which has functions but also other statements (for, if-then-
else,  while,  goto,  etc.)  that  execute  without  producing  a  return  value  (although
values may be computed and stored in variables as side effects of these statements).
In  a  functional  language,  all  constructs,  even  conditional  logic  constructs  and
looping constructs, are executed to compute some value, and they should generally
be executed only for the value and not for other side effects. Most of Mathematica’s
functions produce a value, but there are exceptions, and these exceptions can lead to
problems. The obvious example of this is the “function” Do[]. If Do[] appears in a
context where a value is expected, it will evaluate to null. Since no one needs to set
up a loop to produce null, it is clear that Do[] exists for producing some side effect.
Thus Do[] is certainly not functional. Even expressions that produce values can have
side effects in Mathematica, which leads to the next consideration.
Functional languages that are, by design, free of side effects are called pure functional
languages.  One  hallmark  of  a  pure  functional  language  is  single-assignment,  where  a
variable within a given scope can only get a value once. Examples include Haskell and
Erlang, but not Mathematica, because in most cases, a variable can be reassigned (one
exception is variables introduced by With[]). If you make a concerted effort to avoid
multiple  assignment,  you  will  be  rewarded  with  programs  that  are  often  easier  to
debug; in this book, I’ll often ignore this advice if it results in a simpler example of
the particular recipe in question.
2.0 Introduction | 31

Another feature is the so-called lambda function or anonymous function. There is a
rich mathematical theory called lambda calculus that underlies this idea, but from a
practical point of view, whipping up a function on the fly is a very nice thing in a
language  centered  around  functions.  Whenever  you  write  something  like  {#1+#2}&
(i.e.,  an  anonymous  function  that  takes  two  arguments  and  produces  a  list
containing their sum), you are using Mathematica’s syntax for a lambda function or,
in Mathematica speak, a Function[].
Functional languages are also distinguished as being strict versus nonstrict. In a strict
language,  arguments  to  functions  are  evaluated  immediately,  whereas  nonstrict
languages  use  lazy  evaluation  to  evaluate  expressions  passed  as  arguments  only
when those values are needed. Mathematica is generally a strict language and does
not  provide  for  automatic  lazy  evaluation.  However,  some  nonstrictness  exists  by
the availability of Hold and the attributes HoldAll, HoldFirst, and HoldRest. These are
not the same as lazy evaluation: they allow expressions to be passed in unevaluated
form, but the programmer largely controls whether a held expression gets evaluated
(e.g., by using ReleaseHold[] in the case of an explicit Hold[]).
Another rather technical feature of modern functional languages is their support for
currying. This is a feature that applies a function to multiple arguments individually.
For example, a function of two arguments, A and B, is applied to A, returning a new
function that is then applied to B to return a value. This definition can clearly be
extended  to  functions  that  take  any  number  of  arguments.  Some  languages  that
explicitly  support  currying  are  Haskell  and  ML.  You  will  not  find  references  to
currying in Mathematica documentation, but the feature is essentially present, and I
discuss it in Recipe 2.15. 
Finally, modern functional languages often support closures (a function executed in
an environment that can access previously bound local values) and continuations (a
value representing the rest of a computation that can be completed later). Closures
are discussed in Recipe 2.14.
2.1 Mapping Functions with More Than 
One Argument
Problem
You need to map a function over a list containing sublists whose values are argu-
ments to the function. 
32 | Chapter 2: Functional Programming

Solution
Use a Map-Apply idiom. A very simple example of this problem is when you want to
sum the sublists.
In[18]:=
MapAIApply@Plus, ÒDM &, 881, 2, 3<, 84, 5, 6, 7, 8<, 89, 10, 11, 12<<E
Out[18]=
86, 30, 42<
This can be abbreviated to:
In[19]:=
Plus üü Ò & êü 881, 2, 3<, 84, 5, 6, 7, 8<, 89, 10, 11, 12<<
Out[19]=
86, 30, 42<
Discussion
Although  the  solution  seems  very  simple,  this  problem  arises  quite  frequently  in
more complicated guises, and you should learn to recognize it by studying some of
the following more interesting examples.
Consider a structure representing an order for some product with the form order[sku,
qty,price]. Now imagine you have a list of such orders along with a function for
computing the total cost of an order. Given a list of orders, you want to produce a
list of their costs. The situation is a bit tricky because our function does not care
about the sku, and rather than a list of lists we have a list of order[]. Even with these
differences you still have the same basic problem. Recall that Apply does not necessar-
ily require an expression whose head is List; it will work just as well with any head,
such as order. Also, using compOrderTotCost we can easily preprocess each order to
extract just the elements needed.
In[20]:=
compOrderTotCostAqty_, price_E := qty * price
MapAIApply@compOrderTotCost, Rest@ÒDDM &, 8order@"sku1", 10 , 4.98D,
order@"sku2", 1 , 17.99D, order@"sku3", 12, 0.25D<E
Out[21]=
849.8, 17.99, 3.<
This solution is still a bit contrived because both qty and price within order were
adjacent at the end of order, so Rest made it easy to grab the needed values. The
real world is rarely that accommodating. Let’s complicate the situation a bit by intro-
ducing another element to order that represents a discount percent: order[sku,
disc%,qty,price]. Here you use Apply with a function that takes slot specifications
(#n) to pick out the proper arguments. The convention is that #n stands for the nth
argument and # by itself is short for #1.
2.1 Mapping Functions with More Than One Argument | 33

In[22]:=
compDiscOrderTotCostAqty_, price_, disc_E :=
qty * price * H1.0 - discê100.0L
MapAIApply@compDiscOrderTotCost@Ò3, Ò4, Ò2D &, ÒDM &,
8order@"sku1", 5, 10 , 4.98D,
order@"sku2", 0, 1 , 17.99D, order@"sku3", 15, 12, 0.25D<E
Out[23]=
847.31, 17.99, 2.55<
There is another version of Apply that takes a level specification as a third argument.
If we use this version, we can often get the same effect without explicitly using Map. 
In[24]:=
Apply@Plus@ÒÒD &, 881, 2, 3<, 84, 5, 6, 7, 8<, 89, 10, 11, 12<<, 81<D
Out[24]=
86, 30, 42<
Here we apply Plus using level specification {1} that restricts Apply to level one only.
This uses ## (slot sequence) to pick up all elements at this level. There is also a short-
cut operator, @@@, for this case of applying a function to only level one. In this case,
you can also dispense with ## to create a very concise expression.
In[25]:=
Plus üüü 881, 2, 3<, 84, 5, 6, 7, 8<, 89, 10, 11, 12<<
Out[25]=
86, 30, 42<
You will need slot sequence if you want to pass other arguments in. For example,
consider the following variations.
In[26]:=
Plus@1, ÒÒD & üüü 881, 2, 3<, 84, 5, 6, 7, 8<, 89, 10, 11, 12<<
Out[26]=
87, 31, 43<
This says to produce the sum of each list and add in the element (hence, you use the
second element twice in the sum).
In[27]:=
Plus@Ò2, ÒÒD & üüü 881, 2, 3<, 84, 5, 6, 7, 8<, 89, 10, 11, 12<<
Out[27]=
88, 35, 52<
This leads to a simplified version of the discounted order example. 
In[28]:=
compDiscOrderTotCost@ Ò3, Ò4, Ò2D & üüü 8order@"sku1", 5, 10 , 4.98D,
order@"sku2", 0, 1 , 17.99D, order@"sku3", 15, 12, 0.25D<
Out[28]=
847.31, 17.99, 2.55<
If the lists are more deeply nested, you can use larger level specifications to get the re-
sult you want. Imagine the order being nested in an extra structure called envelope.
In[29]:=
Apply@compDiscOrderTotCost@ Ò3, Ò4, Ò2D &,
8envelope@1, order@"sku1", 5, 10 , 4.98DD,
envelope@2, order@"sku2", 0, 1 , 17.99DD,
envelope@3, order@"sku3", 15, 12, 0.25DD<, 82<D
Out[29]=
8envelope@1, 47.31D, envelope@2, 17.99D, envelope@3, 2.55D<
34 | Chapter 2: Functional Programming

The same result is obtained using Map-Apply because Map takes level specifications as
well.
In[30]:=
MapAIApply@compDiscOrderTotCost@ Ò3, Ò4, Ò2D &, ÒDM &,
8envelope@1, order@"sku1", 5, 10 , 4.98DD,
envelope@2, order@"sku2", 0, 1 , 17.99DD,
envelope@3, order@"sku3", 15, 12, 0.25DD<, 82<E
Out[30]=
8envelope@1, 47.31D, envelope@2, 17.99D, envelope@3, 2.55D<
Of course, you probably want to discard the envelope. This can be done with a part
specification [[All,2]], which means all parts at the first level but only the second ele-
ment of each of these parts.
In[31]:=
MapAIApply@compDiscOrderTotCost@ Ò3, Ò4, Ò2D &, ÒDM &,
8envelope@1, order@"sku1", 5, 10 , 4.98DD,
envelope@2, order@"sku2", 0, 1 , 17.99DD,
envelope@3, order@"sku3", 15, 12, 0.25DD<, 82<E@@All, 2DD
Out[31]=
847.31, 17.99, 2.55<
The following does the same thing using only Map, Apply, and a prefix form of Map
that brings the level specification closer. There are a lot of # symbols flying around
here, and one of the challenges of reading code like this is keeping track of the fact
that # is different in each function. I don’t necessarily recommend writing code this
way if you want others to understand it, but you will see code like this and should
be able to read it. 
In[32]:=
Part@Ò, 2D & êü
Map@compDiscOrderTotCost@ Ò3, Ò4, Ò2D & üü Ò &, Ò, 82<D &ü
8envelope@1, order@"sku1", 5, 10 , 4.98DD,
envelope@2, order@"sku2", 0, 1 , 17.99DD,
envelope@3, order@"sku3", 15, 12, 0.25DD<
Out[32]=
847.31, 17.99, 2.55<
With some practice, this expression translates rather easily to English as “take the
second element of each element produced by applying compDiscOrderTotCost at level
two over the list of enveloped orders.”
See Also
Slots  (#)  and  slot  sequences  (##)  are  discussed  in  tutorial/PureFunctions  in
the documentation.
2.1 Mapping Functions with More Than One Argument | 35

2.2 Holding Arbitrary Arguments
Problem
You want to create a function that holds arguments in different combinations than
provided by HoldFirst and HoldRest.
Solution
Use Hold in the argument list. Here I create a function called arrayAssign whose ob-
jective is to accept a symbol that is associated with a list, an index (or Span), and a
second symbol associated with another list. The result is the assignment of the ele-
ments of array2 to array1 that are specified by index. For this to work, arguments a
and b must remain held but aIndex should not.
In[33]:=
array1 = Table@0, 810<D; array2 = Table@1, 810<D;
arrayAssignAHoldAa_SymbolE, aIndex_, HoldAb_SymbolE, bIndex_E :=
Module@8<,
a@@aIndexDD = b@@bIndexDD;
a@@aIndexDDD
H*Assign elements 2 through 3 in array 2 to array 1.*L
arrayAssignAHoldAarray1E, 2 ;; 3, HoldAarray2E, 1E;
array1
Out[36]=
80, 1, 1, 0, 0, 0, 0, 0, 0, 0<
Discussion
The attributes HoldFirst, HoldRest, and HoldAll fill the most common needs for creat-
ing functions that don’t evaluate their arguments. However, if your function is more
naturally  implemented  by  keeping  other  combinations  of  variables  unevaluated,
then you can use Hold directly. Of course, you need to use Hold at the point of call,
but by also putting Hold in the arguments of the implementation, you ensure the func-
tion will only match if the Holds are in place on the call and you also unwrap the
hold contents immediately without causing evaluation.
See Also
The attributes HoldFirst, HoldRest, and HoldAll are explained in the “Introduction”
on page 30.
36 | Chapter 2: Functional Programming

2.3 Creating Functions That Automatically Map 
Over Lists
Problem
You want to write functions that act as if they are being called Map[f, list].
Solution
A Mathematica attribute called Listable indicates a function that should automati-
cally be threaded over lists that appear as its arguments. 
In[37]:=
SetAttributesAmyListableFunc, ListableE
myListableFunc@x_D := x + 1
myListableFunc@81, 2, 3, 4<D
Out[39]=
82, 3, 4, 5<
Discussion
Log and D are examples of built-in Mathematica functions that are listable. Listability
also works for operators used in prefix, infix, and postfix notation.
In[40]:=
810, 20, 30<^83, 2, 1<
Out[40]=
81000, 400, 30<
In[41]:=
81ê2, 1ê3, 1ê5, Sqrt@2D< êê N
Out[41]=
80.5, 0.333333, 0.2, 1.41421<
Listable  has  a  performance  advantage  over  the  explicit  use  of  Map,  so  is  recom-
mended if the function will often be applied to vectors and matrices.
In[42]:=
TimingALog@RandomReal@81, 1000<, 1 000 000DDE@@1DD
Out[42]=
0.057073
In[43]:=
TimingAMapALog, RandomReal@81, 1000<, 1 000 000DEE@@1DD
Out[43]=
0.14031
2.3 Creating Functions that Automatically Map Over Lists | 37

2.4 Mapping Multiple Functions in a Single Pass
Problem
You want to map several functions over elements of a list in a single pass.
Solution
There is no need to make multiple passes over a list when using Map[]. In this example we
compute a table that relates each number to its square and cube in a single pass.
In[44]:=
8Ò, Ò^2, Ò^3< & êü 81, 7, 3, 8, 5, 9, 6, 4, 2< êê TableForm
Out[44]//TableForm=
1 1
1
7 49 343
3 9
27
8 64 512
5 25 125
9 81 729
6 36 216
4 16 64
2 4
8
Here we map several functions over a generated list and add the individual results;
structurally, this is the same solution. 
In[45]:=
Sin@ÒD^2 + Ò Cos@2 ÒD & êü Table@N@1êi PiD, 8i, 16, 1, -1<D
Out[45]=
80.219464, 0.23456, 0.251693, 0.271252, 0.293712, 0.319635, 0.349652, 0.384378,
0.424127, 0.468077, 0.511799, 0.539653, 0.5, 0.226401, -0.570796, 3.14159<
Here, since Table is already being used, it would be easier to write Table[With[{p =
N[1/i Pi]}, Sin[p]^2 + p Cos[2 p]], {i, 16, 1, -1}], but that misses the point.
I am using Table because I need a list, but imagine the list was a given. Map applies to cases
for which you are given a list and need to create a new list, whereas Table is better
used when you are generating the list on the fly.
Discussion
Once you become comfortable with functional programming, you will find all sorts
of really nice applications of this general pattern. Here is a slick little demonstration bor-
rowed from the Mathematica documentation for visually identifying the first 100 primes.
38 | Chapter 2: Functional Programming

In[46]:=
GridAPartitionAIf@PrimeQ@ÒD, Framed@ÒD, ÒD & êü Range@100D, 20EE
Out[46]=
1
2
3
4
5
6
7
8
9
10
11
12
13
14 15 16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34 35 36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54 55 56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74 75 76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94 95 96
97
98
99
100
In the following, I apply the technique twice to create a presentation that shows the
first 12 regular polygons, with the number of sides and the interior angles in degrees
displayed in the center. 
In[47]:=
angles = Table@i 2 Piên, 8n, 3, 14<, 8i, 0, n - 1< D;
GraphicsA9EdgeForm@8Thin, Black<D,
FaceForm@WhiteD, Polygon@ÒD, InsetA9Length@ÒD,
IPi - VectorAngle@Ò@@1DD, Ò@@2DDDMë Degree=E=E & êü
MapAN@8Sin@ÒD, Cos@ÒD<D &, angles, 82<E êê
Partition@Ò, 4D & êê GraphicsGridAÒ, Frame Ø All, ImageSize Ø 500E &
Out[47]=
83, 60.<
84, 90.<
85, 108.<
86, 120.<
87, 128.571<
88, 135.<
89, 140.<
810, 144.<
811, 147.273<
812, 150.<
813, 152.308<
814, 154.286<
The first step is to generate a list of lists using Table. The innermost list (rows below)
contains n equally spaced angles about a circle where n varies between 3 and 14. We
can see this by inspecting angles in tabular form. Here, using Map is superior to Table
2.4 Mapping Multiple Functions in a Single Pass | 39

if you want to use the computed table of angles in further steps in the computation.
In my case, I just want to display them.
In[48]:=
TableFormAangles, TableSpacing Ø 81, 2<E
Out[48]//TableForm=
0
2 p
3
4 p
3
0
p
2
p
3 p
2
0
2 p
5
4 p
5
6 p
5
8 p
5
0
p
3
2 p
3
p
4 p
3
5 p
3
0
2 p
7
4 p
7
6 p
7
8 p
7
10 p
7
12 p
7
0
p
4
p
2
3 p
4
p
5 p
4
3 p
2
7 p
4
0
2 p
9
4 p
9
2 p
3
8 p
9
10 p
9
4 p
3
14 p
9
16 p
9
0
p
5
2 p
5
3 p
5
4 p
5
p
6 p
5
7 p
5
8 p
5
9 p
5
0
2 p
11
4 p
11
6 p
11
8 p
11
10 p
11
12 p
11
14 p
11
16 p
11
18 p
11
20 p
11
0
p
6
p
3
p
2
2 p
3
5 p
6
p
7 p
6
4 p
3
3 p
2
5 p
3
11 p
6
0
2 p
13
4 p
13
6 p
13
8 p
13
10 p
13
12 p
13
14 p
13
16 p
13
18 p
13
20 p
13
22 p
13
24 p
13
0
p
7
2 p
7
3 p
7
4 p
7
5 p
7
6 p
7
p
8 p
7
9 p
7
10 p
7
11 p
7
12 p
7
13 p
7
Since Polygon requires points, I compute them by mapping the Sin and Cos functions
in parallel over each sublist by giving a level specification of {2} to Map. I show only
the first three results below for sake of space.
In[49]:=
Map@N@8Sin@ÒD, Cos@ÒD<D &,
Table@i 2 Piên, 8n, 3, 14<, 8i, 0, n - 1< D, 82<D@@1 ;; 3DD êê Column
Out[49]=
880., 1.<, 80.866025, -0.5<, 8-0.866025, -0.5<<
880., 1.<, 81., 0.<, 80., -1.<, 8-1., 0.<<
880., 1.<, 80.951057, 0.309017<, 80.587785, -0.809017<,
8-0.587785, -0.809017<, 8-0.951057, 0.309017<<
The next pass uses the technique to create both the polygon and the inset with the
number of sides and the interior angles. The use of Partition and GraphicsGrid is
solely for formatting purposes.
40 | Chapter 2: Functional Programming

See Also
See Recipe 2.5 for a variation of Map called MapIndexed that gives you the position of
an element as a second argument.
2.5 Keeping Track of the Index of Each Item 
As You Map
Problem
You want to apply a function over a list as with Map (/@), but the function requires
the position of the item in the list in addition to its value.
Solution
Use MapIndexed instead of Map. Keep in mind that MapIndexed wraps the index in a
list, so a common idiom is to use First[#2] to access the index directly. To show
this, I first use an undefined function ff before showing a more useful application. 
In[50]:=
Clear@ffD;
MapIndexed@ff@Ò1, First@Ò2DD &, 8a, b, c, d, e<D
Out[51]=
8ff@a, 1D, ff@b, 2D, ff@c, 3D, ff@d, 4D, ff@e, 5D<
Imagine you want to raise the elements of a list to a power based on its position.
You could not easily do this with Map, but MapIndex makes it trivial.
In[52]:=
MapIndexed@Ò1^First@Ò2D &, 82, 0, 7, 3<D
Out[52]=
82, 0, 343, 81<
This  is  not  so  contrived  if  you  consider  the  problem  of  converting  a  list  to  a
polynomial.
In[53]:=
Plus üü MapIndexed@Ò1 x^First@Ò2D &, 82, 0, 7, 3<D
Out[53]=
2 x + 7 x3 + 3 x4
Discussion
Although MapIndexed is used less frequently than Map, it is a godsend when you need
it, since it avoids the need to return to a procedural style when you want the posi-
tion. I think you might agree the following procedural implementation is a bit uglier.
2.5 Keeping Track of the Index of Each Item As You Map | 41

In[54]:=
BlockA9poly = 0,
list = 82, 0, 7, 3<=,
DoA
poly = poly + list@@iDD x^i,
9i, 1, Length@listD=
E;
polyE
Out[54]=
2 x + 7 x3 + 3 x4
You may find it curious that MapIndexed wraps the position in a list, forcing you to
use First to extract the index. There is a good reason for this convention: MapIn-
dexed easily generalizes to nested lists such as matrices where the position has multi-
ple parts. Here we use a variant of MapIndexed that takes a level specification as a
third argument indicating the function ff should map over the items at level two.
Here two integers are required to specify the position; thus, the list convention
immediately makes sense.
In[55]:=
MapIndexedAff@Ò1, Ò2D &, 98a, b, c<, 8d, e, f<, 9g, h, i==, 82<E
Out[55]=
98ff@a, 81, 1<D, ff@b, 81, 2<D, ff@c, 81, 3<D<,
8ff@d, 82, 1<D, ff@e, 82, 2<D, ff@f, 82, 3<D<,
9ffAg, 83, 1<E, ff@h, 83, 2<D, ff@i, 83, 3<D==
As an application, consider a function for reading the positions of pieces on a chess-
board. The board is a matrix with empty spaces designated by 0 and pieces desig-
nated by letters with subscripts B for black and W for white. We implement a func-
tion piecePos that can convert a piece and its position into a description that uses
algebraic chess notation.
42 | Chapter 2: Functional Programming

In[56]:=
Clear@piecePosD
chessboard = 8
80, 0, 0, 0, 0, 0, 0, 0<,
80, 0, 0, 0, 0, 0, 0, 0<,
80, 0, 0, 0, 0, 0, 0, 0<,
80, 0, 0, 0, 0, 0, 0, 0<,
8NB, PW, NW, 0, 0, 0, 0, 0<,
80, 0, 0, 0, 0, 0, 0, 0<,
80, 0, QW, 0, 0, 0, 0, 0<,
8KB, 0, 0, 0, 0, 0, 0, 0<
<;
toColor@BD = "Black";
toColor@WD = "White";
toPosA9x_, y_=E :=
ModuleA9file = 9"a", "b", "c", "d", "e", "f", "g", "h"==,
fileAAyEE <> ToString@xDE
piecePosAPc_, pos_E := 8toColor@cD, " Pawn ", toPos@posD<
piecePosANc_, pos_E := 9toColor@cD, " Knight ", toPos@posD=
piecePosABc_, pos_E := 8toColor@cD, " Bishop ", toPos@posD<
piecePosARc_, pos_E := 8toColor@cD, " Rook ", toPos@posD<
piecePosAQc_, pos_E := 8toColor@cD, " Queen ", toPos@posD<
piecePosAKc_, pos_E := 9toColor@cD, " King ", toPos@posD=
piecePos@0, _D := Sequence@D
MapIndexed will allow us to use piecePos to describe the whole board. Here, piecePos
converts an empty space to any empty sequence, which Mathematica will automati-
cally remove for us. Flatten is used to collapse unneeded nesting inherited from the
chessboard’s representation as a list of lists.
In[68]:=
Flatten@MapIndexed@piecePos, chessboard, 82<D, 1D
Out[68]=
99Black, Knight , a5=, 8White, Pawn , b5<,
9White, Knight , c5=, 8White, Queen , c7<, 9Black, King , a8==
2.6 Mapping a Function over a Moving Sublist
Problem
You have a list and wish to apply some operation over a moving window of fixed
size over that list.
2.6 Mapping a Function over a Moving Sublist | 43

Solution
Ignoring available special functions of Mathematica for a moment, you can attack
this  problem  head-on  by  using  Table  in  conjunction  with  a  Part  and  Span  (i.e.,
[[start;;end]]) to create the moving window (sublist) and Apply the desired func-
tion to each sublist. For example, use Mean if you want a moving average.
In[69]:=
array = RandomReal@80, 10<, 20D ;
In[70]:=
TableAMean üü 9array@@i ;; i + 4DD=, 8i, 1, 16<E
Out[70]=
83.13108, 3.27291, 4.31676, 5.41289, 5.98751, 5.6219, 5.8349, 5.52834,
5.87892, 4.7862, 5.5245, 5.36589, 4.35811, 4.09389, 4.66446, 3.87226<
Here is a variation using Take.
In[71]:=
TableAMean üü 9TakeAarray, 8i, i + 4<E=, 8i, 1, 16<E
Out[71]=
83.13108, 3.27291, 4.31676, 5.41289, 5.98751, 5.6219, 5.8349, 5.52834,
5.87892, 4.7862, 5.5245, 5.36589, 4.35811, 4.09389, 4.66446, 3.87226<
A nonmathematical example uses the same technique to create successive pairs.
In[72]:=
TableAList üü array@@i ;; i + 1DD, 8i, 1, 16<E
Out[72]=
885.14848, 4.21272<, 84.21272, 0.968604<,
80.968604, 2.94497<, 82.94497, 2.38062<, 82.38062, 5.85762<,
85.85762, 9.43197<, 89.43197, 6.44928<, 86.44928, 5.81804<,
85.81804, 0.552592<, 80.552592, 6.92264<,
86.92264, 7.89915<, 87.89915, 8.20219<, 88.20219, 0.354432<,
80.354432, 4.24409<, 84.24409, 6.12958<, 86.12958, 2.86026<<
Discussion
The solution illustrates the basic idea, but it is not very general because the function
and window size are hard coded. You can generalize the solution like this:
In[73]:=
moving@f_, expr_, n_D := ModuleA9len = Length@exprD, windowEnd =,
windowEnd = Min@n, lenD - 1;
TableAApply@f, 8expr@@i ;; i + windowEndDD<D, 8i, 1, len - windowEnd<EE
Note that there is a built-in function, MovingAverage, that computes both simple and
weighted moving averages. There is also a MovingMedian. You should use these in-
stead of the solution given here if they are appropriate for what you need to compute.
Two special functions in Mathematica, ListConvolve and ListCorrelate, present the most
general way to perform computations on sublists. These functions contain a myriad
of variations, but it is well worth the added effort to familiarize yourself with them. I
will present only ListConvolve because anything you can compute with one you can
compute with the other, and the choice is just a matter of fit for the specific problem.
Let’s ease in slowly by using ListConvolve to implement a moving average.
44 | Chapter 2: Functional Programming

In[74]:=
movingAvg@list_, n_D := ListConvolve@Table@1ên, 8n<D, listD
In[75]:=
movingAvgAarray, 5E
Out[75]=
83.13108, 3.27291, 4.31676, 5.41289, 5.98751, 5.6219, 5.8349, 5.52834,
5.87892, 4.7862, 5.5245, 5.36589, 4.35811, 4.09389, 4.66446, 3.87226<
The first argument to ListConvolve is called the kernel. It is a list that defines a set of
values that determines the length of the sublists and factors by which to multiply
each element in the sublist. After the multiplication, each sublist is summed. This is
shown more easily using symbols.
In[76]:=
ListConvolve@81, 1<, 8a, b, c, d, e<D
Out[76]=
8a + b, b + c, c + d, d + e<
Here I use a simple kernel {1,1}, which implies sublists will be size 2 and each ele-
ment will simply be itself (because 1 is the identity). This yields a list of successive
sums. In the moving average, the kernel was simply 1/n repeated n times since this
results in the mean.
In[77]:=
ListConvolve@81, 1<ê2, 8a, b, c, d, e<D
Out[77]=
:
a
2
+
b
2
,
b
2
+
c
2
,
c
2
+
d
2
,
d
2
+
e
2
>
It’s easy to see how using an appropriate kernel gives a weighted moving average,
but I won’t continue in this vein, because my goal is to demonstrate the generality of
ListConvolve and, as I already said, MovingAverage does the trick. 
The first bit of generality comes from Mathematica adding a third argument to List-
Convolve that can be an integer k or a list {kL,kR}. Since using just k is equivalent to
using {k,k}, I’ll only discuss the later case. It is best to start with some examples.
In[78]:=
ListConvolve@81, 1<, 8a, b, c, d, e<, 81, 1<D
Out[78]=
8a + e, a + b, b + c, c + d, d + e<
In[79]:=
ListConvolve@81, 1<, 8a, b, c, d, e<, 81, -1<D
Out[79]=
8a + e, a + b, b + c, c + d, d + e, a + e<
Hopefully you can guess the meaning of {kL,kR}; kL tells ListConvolve how much to
overhang the kernel on the left of the list, and kR tells it how much to overhang the
kernel on the right. Hence, it tells ListConvolve to treat the list as circular. The de-
fault value is {-1,1}, which means no overhang on either side. 
Sometimes you do not want to treat the lists as circular, but rather as padded; hence,
ListConvolve takes a fourth argument that specifies the padding. 
In[80]:=
ListConvolve@81, 1<, 8a, b, c, d, e<, 81, -1<, 1D
Out[80]=
81 + a, a + b, b + c, c + d, d + e, 1 + e<
2.6 Mapping a Function over a Moving Sublist | 45

I’ve  rushed  through  these  features  a  bit  because  the  Mathematica  documentation
can fill you in on the details and because my real goal is to arrive at the version of
ListConvolve that takes a fifth and sixth argument. This takes us back to the theme
of this recipe, which is the idea of mapping arbitrary functions over moving sublists.
Thus  far,  ListConvolve  has  been  about  mapping  a  very  specific  function,  Plus,
across a sublist defined by a kernel, which defines both the length of the sub-
list (matches length of kernel) and a set of weights to Times the individual ele-
ments  (the  elements  of  the  kernel).  The  fifth  argument  allows  you  to  replace
Times with an arbitrary function, and the sixth argument allows you to replace
Plus with an arbitrary function.
Here is the pair extraction function from the solution implemented using ListCon-
volve, shown here but using strings to emphasize that we don’t necessarily need to
do math. I replace Times with the function #2&, which simply ignores the element
from the kernel, and I replace Plus with List because that will form the pairs.
In[81]:=
list = 9"foo", "bar", "baz", "bing"=;
ListConvolve@81, 1<, list, 8-1, 1<, 8<, Ò2 &, ListD
Out[82]=
98foo, bar<, 8bar, baz<, 9baz, bing==
But sometimes you can make nice use of the kernel even in nonmathematical con-
texts.  Here we hyphenate pairs using  StringJoin  with  input  kernel  strings  {"-",""}
(consider that "" is the identity for string concatenation).
In[83]:=
ListConvolveA8"-", ""<, list, 8-1, 1<, 8<, StringJoin, StringJoinE
Out[83]=
9foo-bar, bar-baz, baz-bing=
Let’s consider another application. You have a list of points and want to compute
the distances between successive pairs. This introduces a new wrinkle because the in-
put list is two levels deep. ListConvolve assumes you want to do a two-dimensional
convolution and will complain that the kernel does not have the same rank as the
list. Luckily, you can tell ListConvolve to remain on the first level by specifying a fi-
nal (seventh) argument.
In[84]:=
points = RandomReal@8-1, 1<, 820, 2<D;
ListConvolve@81, 1<, points, 8-1, 1<, 8<, Ò2 &, EuclideanDistance, 1D
Out[85]=
81.49112, 0.764671, 0.789573, 0.941825, 0.933473, 1.05501,
1.21181, 0.827185, 1.25728, 0.365742, 0.62815, 1.88344, 0.741821,
1.13765, 0.719799, 0.643237, 1.60263, 0.93153, 1.33332<
Taking three points at a time, you can compute the area of successive triangles and
draw them as well!
46 | Chapter 2: Functional Programming

In[86]:=
triareaA9xA_, yA_=, 9xB_, yB_=, 9xC_, yC_=E :=
AbsAIxB*yA - xA*yBM + IxC*yB - xB*yCM + IxA*yC - xC*yAMEë 2
ListConvolve@81, 1, 1<, points, 8-1, 1<, 8<, Ò2 &, triarea, 1D
Out[87]=
80.549352, 0.064558, 0.31907, 0.228057, 0.308535, 0.561063,
0.0457104, 0.126488, 0.164337, 0.104572, 0.107751, 0.581687,
0.333659, 0.408676, 0.220177, 0.457996, 0.679265, 0.550845<
In[88]:=
ListConvolveA81, 1, 1<, points,
8-1, 1<, 8<, Ò2 &, Polygon@8ÒÒ<D &, 1E êê GraphicsA
9EdgeForm@BlackD, FaceForm@WhiteD, Opacity@0.5D, Ò=, ImageSize Ø SmallE &
Out[88]=
There is something a bit awkward about ListConvolve use cases where we essentially
ignore the kernel. Readers familiar with the function Partition will immediately see
a much shorter variation.
In[89]:=
triarea üüü Partition@ points, 3, 1D
Out[89]=
80.549352, 0.064558, 0.31907, 0.228057, 0.308535, 0.561063,
0.0457104, 0.126488, 0.164337, 0.104572, 0.107751, 0.581687,
0.333659, 0.408676, 0.220177, 0.457996, 0.679265, 0.550845<
Partition and ListConvolve have many similar features, and with a bit of program-
ming,  you  can  implement  ListConvolve  in  terms  of  Partition  and  vice  versa.  The
one observation I can make in favor of ListConvolve is that it does the partitioning
and function application in one fell swoop. This inspires the following compromise.
In[90]:=
partitionApply@func_, list_, n_D :=
ListConvolveAArray@1 &, nD, list, 8-1, 1<, 8<, Ò2 &, func, 1E
2.6 Mapping a Function over a Moving Sublist | 47

Above, Array is used to generate a kernel of the required size where 1& is the func-
tion that always returns 1.  
In[91]:=
partitionApply@triarea, points, 3D
Out[91]=
80.549352, 0.064558, 0.31907, 0.228057, 0.308535, 0.561063,
0.0457104, 0.126488, 0.164337, 0.104572, 0.107751, 0.581687,
0.333659, 0.408676, 0.220177, 0.457996, 0.679265, 0.550845<
But, lo and behold, the function we are looking for is actually buried inside the De-
veloper` package! It’s called Developer`PartitionMap.
In[92]:=
Developer`PartitionMap@triarea üü Ò &, points, 3, 1D
Out[92]=
80.549352, 0.064558, 0.31907, 0.228057, 0.308535, 0.561063,
0.0457104, 0.126488, 0.164337, 0.104572, 0.107751, 0.581687,
0.333659, 0.408676, 0.220177, 0.457996, 0.679265, 0.550845<
See Also
I highly recommend reviewing the documentation for Partition, ListConvolve, and
ListCorrelate  in  succession  to  get  insight  into  their  relationships.  I  spent  a  lot  of
time in my early Mathematica experience understanding how to use Partition but
viewing ListConvolve and ListCorrelate as mysterious. If you find a need to use Par-
tition in one of its advanced forms, you might be working on a problem where List-
Convolve or ListCorrelate applies.
ListConvolve  and  ListCorrelate  are  frequently  used  in  image-processing  applica-
tions. See Recipe 8.5. Also see Recipe 2.12, in which I use it for a traveling salesper-
son problem.
2.7 Using Prefix and Postfix Notation 
to Produce More Readable Code
Problem
A complicated piece of functional code can become deeply nested and, as a result,
hard to read. You want to collapse some of these levels of nesting without introduc-
ing intermediate variables. Of course, readability is in the eye of the beholder, so a
closely related problem is making sure you can understand this style when you see it
in the wild.
48 | Chapter 2: Functional Programming

Solution
Many  Mathematica  veterans  prefer  a  functional  style  of  programming  that  makes
liberal use of prefix notation, which uses the @ symbol to compose functions, and
postfix  notation,  which  uses  //.  Let’s  consider  a  simple  program  that  looks  for
primes of the form 2n ± 1 up to some limiting value of nmax.
In[93]:=
somePrimes@nmax_D :=
Select@Union@Flatten@Table@82^n - 1, 2^n + 1<, 8n, 0, nmax<DDD, PrimeQD;
somePrimes@
5D
Out[94]=
82, 3, 5, 7, 17, 31<
As a first step, you can eliminate some levels of nesting by using @.
In[95]:=
somePrimes@nmax_D :=
Select@UnionüFlattenüTable@82^n - 1, 2^n + 1<, 8n, 0, nmax<D, PrimeQD
somePrimes@5D
Out[96]=
82, 3, 5, 7, 17, 31<
You can further emphasize that this program is about finding primes by using func-
tional composition with Select. This brings the PrimeQ test to the front.
In[97]:=
somePrimes@nmax_D := Select@Ò, PrimeQD & ü
UnionüFlattenüTable@82^n - 1, 2^n + 1<, 8n, 0, nmax<D
somePrimes@
5D
Out[98]=
82, 3, 5, 7, 17, 31<
The use of postfix is perfectly valid on the left-hand side, although you are less likely
to see this style widely used.
In[99]:=
somePrimesünmax_ :=
Select@Ò, PrimeQD & ü UnionüFlattenüTable@82^n - 1, 2^n + 1<, 8n, 0, nmax<D
A functional purist might go further and make somePrimes a pure function, but most
would agree this goes way too far in this instance! Still, you should know how to
read  code  like  this,  because  you  will  come  across  it,  and  there  are  cases  where  it
makes sense.
In[100]:=
Clear@somePrimesD;
somePrimes = HSelect@Ò, PrimeQD & ü
UnionüFlattenüTable@82^n - 1, 2^n + 1<, 8n, 0, Ò<DL &;
somePrimes@
5D
Out[102]=
82, 3, 5, 7, 17, 31<
2.7 Using Prefix and Postfix Notation to Produce More Readable Code | 49

Discussion
The uninitiated could make an argument that the first form of somePrimes was more
understandable to them than any of the later ones. First, let me say that there is
no reward in heaven for coding in a specific style, so don’t feel the need to conform
to a particular fashion. Your programs won’t run faster just because you use a terser
syntax. Having said that, I now defend the merits of this particular style. Let me re-
peat the version that I think strikes the right balance.
In[103]:=
Clear@somePrimesD;
somePrimes@nmax_D :=
Select@Ò, PrimeQD & ü UnionüFlattenüTable@82^n - 1, 2^n + 1<, 8n, 0, nmax<D
First,  use  of  symbols  like  @  should  not  be  a  real  barrier.  After  all,  such  symbolic
forms of expression are pervasive. Every first grader knows what 1 + 1 or $15 means. Sym-
bolic operators are not inherently mysterious after you are exposed to them. 
However, the primary goal and claim is readability. This expression can be read as “select
the primes of the union of the flattening of the table of pairs {2^n-1, 2^n+1} with n ranging
from 0 to nmax”. As I stated in the solution, the most relevant aspect of this program is that
it selects primes. Having a language that gives you the freedom to express programs in a
way that emphasizes their function is really quite liberating in my opinion. 
The flip side of emphasis by pushing functions forward is deemphasis by pushing an-
cillary detail toward the end. This is one of the roles of postfix //. Common uses include
formatting and timing. Here the main idea is taking the last value of somePrime[500].
The fact that you are interested in the timing is likely an afterthought, and you may
delete that at some point. Placing it at the end makes it easy to remove.
In[105]:=
LastüsomePrimes@500D êê Timing
Out[105]=
80.113328, 170141183460469231731 687 303 715 884 105 727<
Likewise, formatting is a convention that does not change meaning, so most users
tag formatting directives at the end.
In[106]:=
10.00 + 12.77 - 36.00 - 42.01 êê AccountingForm
Out[106]//AccountingForm=
H55.24L
Note that @ has high precedence and associates to the right, whereas // has low prece-
dence and associates to the left. The precedence is suggested by the way the front-
end typesets expressions with @ containing no space to suggest tight binding, while
// expressions are spaced out to suggest loose binding and lower precedence. 
In[107]:=
aübüc êê füd êê e
Out[107]=
e@f@dD@a@b@cDDDD
50 | Chapter 2: Functional Programming

It’s worth mentioning that Postfix and Prefix will convert standard functional form
to the shortened versions.
In[108]:=
Prefix@f@1DD
Out[108]=
Prefix@1D
In[109]:=
Postfix@f@1DD
Out[109]=
Postfix@1D
See Also
Additional  perspectives  on  this  notation  can  be  found  in  the  essay  The  Con-
cepts and Confusions of Prefix, Infix, Postfix and Fully Nested Notations by Xah Lee
at http://bit.ly/t6GoC.
Readers interested in functional programming styles should google the term Point-
free to learn how the ideas discussed here manifest themselves in other languages,
such as Haskell.
2.8 Defining Indexed Functions
Problem
You want to define a family of functions differentiated by an index or indices.
Solution
Use indexed heads or subscripts.
In[110]:=
ClearAll@fD ;
f@1DAx_, y_E := 0.5 * Ix + yM
f@2DAx_, y_E := 0.5 * Ix - yM
f@3DAx_, y_E := 0.5 * Iy - xM
In[114]:=
TableAfARandomInteger@81, 3<DE@3, 2D, 8i, 6<E
Out[114]=
82.5, -0.5, -0.5, -0.5, 2.5, 0.5<
The mathematician in you might prefer using subscripts instead.
In[115]:=
ClearAll@fD ;
f1Ax_, y_E := 0.5 * Ix + yM
f2Ax_, y_E := 0.5 * Ix - yM
f3Ax_, y_E := 0.5 * Iy - xM
In[119]:=
fRandomInteger@81,3<D@3, 2D
Out[119]=
0.5
2.8 Defining Indexed Functions | 51

Discussion
In Stan Wagon’s Mathematica in Action (W.H. Freeman), there is a study of iterated
function systems that are nicely expressed in terms of indexed functions. This is a
variation  of  his  code  that  takes  advantage  of  the  new  RandomChoice  function  in
Mathematica 6. The fernlike structure emerges out of a nonuniform distribution of
function selections.
In[120]:=
ClearAll@fD
f@1DA9x_, y_=E := DotA880.85, 0.04<, 8-0.04, 0.85<<, 9x, y=E + 80, 1.6<
f@2DA9x_, y_=E := DotA88-0.15, 0.28<, 80.26, 0.24<<, 9x, y=E + 80, 0.44<
f@3DA9x_, y_=E := DotA880.2, -0.26<, 80.23, 0.22<<, 9x, y=E + 80, 1.6<
f@4DA9x_, y_=E := DotA880.0, 0.0<, 80.0, 0.16<<, 9x, y=E
ff@p_D := f@RandomChoice@885, 7, 7, 1< Ø 81, 2, 3, 4<DD@pD
fern@n_D :=
GraphicsA8AbsolutePointSize@0.5D, Point êü NestList@ff, 80, 0<, nD<,
PlotRange Ø 88-3, 3<, 8-1, 11<<, AspectRatio Ø 0.83, ImageSize Ø SmallE
In[127]:=
fern@10000D
Out[127]=
You are not restricted to indexing functions by integers. Here are some variations
that are possible.
In[128]:=
g@1, 1DAx_, y_E := x + 2 y
g@weirdDAx_, y_E := ExpASin@xD TanAyEE
g@1 + 2 ID := x + 2 y I
52 | Chapter 2: Functional Programming

2.9 Understanding the Use of Fold As an 
Alternative to Recursion
Problem
You want to understand and create programs that use Fold[] as an alternative to ex-
plicit recursion.
Solution
Consider the following simple recursive definition for a summation function.
In[131]:=
mySum@8<D := 0
mySum@l_D := First@lD + mySum@Rest@lDD
In[133]:=
mySum@81, 2, 3, 4, 5<D
Out[133]=
15
This  function  can  easily  be  translated  to  a  nonrecursive  implementation  that  uses
Fold[].
In[134]:=
mySum2@l_D := Fold@Ò1 + Ò2 &, 0, lD
In[135]:=
mySum@81, 2, 3, 4, 5<D
Out[135]=
15
Discussion
The function Fold[f, x, {a1,a2,...,aN}] computes f[f[f[x,a1],a2],...,aN]. It is
a simple enough definition to understand, but it is not always clear to the uniniti-
ated when such a function might be useful. It turns out that there is a relation-
ship between Fold and certain common kinds of recursive functions. Consider the
following abstract recursive structure.
g[{}] = x
g[l_] = f[First[l], g[Rest[l]] 
When a function g has this recursive structure in terms of another function f, then it can
easily be translated into a nonrecursive function using Fold, provided f is associative. If f is
not associative, then you may need to reverse the list l before passing to Fold.
g[l_] = Fold[f[#1,#2]&,x,l]
Here is an example that shows that the functionality of Map can be implemented in
terms of Fold. First start with your own recursive definition of Map.
In[136]:=
myMap@_, 8<D := 8<
myMap@f_, l_D := PrependAmyMap@f, Rest@lDD, f@First@lDDE
2.9 Understanding the Use of Fold As an Alternative to Recursion | 53

The translation requires reversing the list because prepending the application of f to
a list is clearly not associative.
In[138]:=
myMap2@f_, l_D := Fold@Prepend@Ò1, f@Ò2DD &, 8<, Reverse@lDD
Here  is  a  test  of  the  recursive  implementation,  first  on  an  empty  list,  then  on  a
nonempty one.
In[139]:=
myMap@Sqrt, 8<D
Out[139]=
8<
In[140]:=
myMap@Sqrt, 81, 2, 3, 4<D
Out[140]=
:1,
2 ,
3 , 2>
Now the Fold version.
In[141]:=
myMap2@Sqrt, 8<D
Out[141]=
8<
In[142]:=
myMap2@Sqrt, 81, 2, 3, 4<D
Out[142]=
:1,
2 ,
3 , 2>
Before considering more useful applications of Fold, I need to clear up some poten-
tial confusion with folding implementations from other languages. In Haskell, there
are functions called foldl and foldr, which stand for fold left and fold right, respec-
tively. Mathematica’s Fold is like foldl.
In[143]:=
H*This is like Haskell's foldr.*L
foldr@f_, v_, 8<D := v
foldr@f_, v_, l_D := f@First@lD, foldr@f, v, Rest@lDDD
In[145]:=
H*This is like Haskell's foldl and Mathematica's Fold.*L
foldl@f_, v_, 8<D := v
foldl@f_, v_, l_D := foldl@f, f@v, First@lDD, Rest@lDD
These various folds will give the same answer if the function passed is associative
and commutative.
In[147]:=
foldr@Plus, 0, 81, 2, 3<D
Out[147]=
6
In[148]:=
foldl@Plus, 0, 81, 2, 3<D
Out[148]=
6
In[149]:=
Fold@Plus, 0 , 81, 2, 3<D
Out[149]=
6
54 | Chapter 2: Functional Programming

To visualize the difference between foldr and foldl, consider the trees produced by
using the List function. Trees labeled b and c are the same, confirming the equiva-
lence of Haskell’s foldl and Mathematica’s Fold.
In[150]:=
GridAPartitionAMapIndexedATreeFormAÒ, ImageMargins Ø 1,
ImagePadding Ø 0, PlotLabel Ø Extract@8"a", "b", "c"<, Ò2DE & ,
8foldr@List, 8<, 81, 2, 3<D, foldl@List, 8<, 81, 2, 3<D,
Fold@List, 8<, 81, 2, 3<D<E, 2, 2, 81, 1<, SpanFromLeftEE
Out[150]=
List
1
List
2
List
3
8<
a
List
List
List
8<
1
2
3
b
List
List
List
8<
1
2
3
c
2.9 Understanding the Use of Fold As an Alternative to Recursion | 55

You can use the relationship between Fold and recursion to analyze more compli-
cated use cases. For example, the Mathematica documentation provides an example
of using Fold to find all the unique sums of a list of numbers.
In[151]:=
Fold@Union@Ò1, Ò1 + Ò2D &, 80<, 81, 2, 7<D
Out[151]=
80, 1, 2, 3, 7, 8, 9, 10<
When  I  first  saw  this,  it  was  not  immediately  obvious  to  me  why  the  solution
worked. However, by converting to the recursively equivalent solution, it is easier to
analyze what is happening. 
In[152]:=
uniqueSums@8<D := 80<
uniqueSums@l_D :=
Union@8First@lD<, uniqueSums@Rest@lDD, First@lD + uniqueSums@Rest@lDDD
In[154]:=
uniqueSums@81, 2, 7<D
Out[154]=
80, 1, 2, 3, 7, 8, 9, 10<
The first rule is obvious. The sum of the empty list is zero. The second rule says that
the unique sums of a list are found by taking the union of the first element of the
list, the unique sums of the rest of the list, and the sum of the first element and the
unique sums of the rest of the list. The last part of the union (First[l] + uniqueSums
[Rest[l]]) provided me with the key insight into why this example worked. It is a
sum of a scalar and a vector and provides the sum of the first element with all other
combinations  of  sums  of  the  remaining  elements.  It  is  obvious  that  the  recursive
translation, as written, is suboptimal because the recursive call is made twice (this
could easily be fixed with a local variable), but the point here was to use the recur-
sive function as a tool to analyze the meaning of the Fold implementation.
See Also
FoldList is a variant of Fold that returns all intermediate steps of the Fold in a list.
Refer to the Mathematica documentation for details.
Nest and NestList also repeatedly apply a function to an expression, but the repeti-
tions are controlled by an integer n. See Recipe 2.11.
NestWhile  and  NestWhileList  apply  a  function  as  long  as  a  test  condition  remains
true. See Recipe 2.11.
56 | Chapter 2: Functional Programming

2.10 Incremental Construction of Lists
Problem
You  need  to  build  up  a  list  piece  by  piece  during  an  iterative  or  recursive
computation.
Solution
An obvious solution to this problem is to use the function AppendTo[s, elem]; how-
ever,  AppendTo  should  be  avoided  for  performance  reasons.  Instead,  use  Reap  and
Sow. Here is a simple factorial function that collects intermediate results using Reap
and Sow.
In[155]:=
factorialListAn_Integer ê; n ¥ 0E := Reap@factorialListSow@nDD
factorialListSow@0D := Sow@1D
factorialListSow@n_D := Module@8fact<, Sow@ n * factorialListSow@n - 1DDD
In[158]:=
factorialList@8D
Out[158]=
840320, 881, 1, 2, 6, 24, 120, 720, 5040, 40 320<<<
Discussion
Reap  and  Sow  cause  confusion  for  some,  possibly  because  there  are  few  languages
that have such a feature built in. Simply think of Reap as establishing a private queue
and each Sow as pushing an expression to the end of that queue. When control exits
Reap, the items are extracted from the queue and returned along with the value com-
puted by the code inside the Reap. I don’t claim that Reap and Sow are implemented
in this way (they might or might not be), but thinking in these terms will make you
more comfortable with their use.
Reap and Sow are often used as evaluation-monitoring functions for numerical algo-
rithms. FindRoot, NDSolve, NIntegrate, NMinimize and NSum allow an optional Evaluation-
Monitor or StepMonitor where Reap and Sow can come in handy.
2.10 Incremental Construction of Lists | 57

In[159]:=
ModuleA9x, y, f = FunctionA9x, y=, Ix^3 - y^2M^2E=, ReapA
NMinimizeAfAx, yE,
98x, -5, 5<, 9y, -5, 5==, EvaluationMonitor ß SowA9x, y=EEEE
Out[159]=
992.93874µ10-39, 9x$2657 Ø 0.0781025, y$2657 Ø 0.0218272==,
8881.52468, 1.3307<, 81.82813, 0.663518<, 84.35202, 4.76188<,
8-0.999213, -2.76766<, 80.338596, -0.885272<, 80.0351429, -0.218087<,
8-0.861351, -0.65889<, 8-1.15094, -2.43406<, 80.855774, 0.389512<,
80.552321, 1.0567<, 80.392027, -0.39978<, 8-0.428604, -1.00738<,
80.534679, 0.0402892<, 8-0.107509, -0.658156<, 80.374132, -0.134322<,
80.0172481, 0.0473707<, 8-0.170141, 0.270946<, 80.356237, 0.131136<,
8-0.000646785, 0.312828<, 80.280437, -0.0225345<,
8-0.0585518, -0.106299<, 8-0.321741, -0.0363943<,
80.129893, -0.0259995<, 80.205693, 0.127671<, 80.139632, 0.0691781<,
80.252276, -0.00419199<, 80.0760051, 0.03448<, 80.0662664, -0.0606976<,
80.12129, 0.0367092<, 80.0674026, 0.0971887<, 80.11427, 0.00479757<,
80.0830251, 0.0663916<, 80.106459, 0.0201961<, 80.0908364, 0.0509931<,
80.102553, 0.0278953<, 80.147838, 0.0301245<, 80.0939635, 0.0333911<,
80.0752265, 0.0245773<, 80.0521947, 0.0185113<, 80.0666367, 0.0300731<,
80.0935742, 0.0284398<, 80.0748372, 0.0196259<, 80.0931849, 0.0234884<,
80.0797161, 0.0243051<, 80.0886953, 0.0237606<, 80.0819609, 0.024169<,
80.100698, 0.0329828<, 80.0813024, 0.0229651<, 80.0929156, 0.027236<,
80.0846996, 0.0249357<, 80.0901769, 0.0264692<, 80.0860689, 0.0253191<,
80.0737971, 0.0198445<, 80.0785637, 0.0221984<, 80.0908355, 0.027673<,
80.0780567, 0.0218016<, 80.085562, 0.0249223<, 80.0838124, 0.0242413<,
80.0780567, 0.0218016<, 80.0780567, 0.0218016<, 80.0781026, 0.0218272<,
80.0781025, 0.0218272<, 80.0781025, 0.0218272<, 80.0781025, 0.0218272<,
80.0780567, 0.0218016<, 80.0780567, 0.0218016<, 80.0780545, 0.021807<,
80.0780545, 0.021807<, 80.0780545, 0.021807<<<=
Reap and Sow also can be used to build up several lists by specifying tags with Sow and
patterns that match those tags in Reap. Here you create a three-way partitioning func-
tion using an ordering function by sowing values with tags |1, 0, or 1, depending on
the relation.
In[160]:=
partition@l_, v_, comp_ D := Flatten êü Reap@
Scan@
Which@comp@Ò, vD, Sow@Ò, -1D,
comp@v, ÒD, Sow@Ò, 1D, True, Sow@Ò, 0DD &, lD,
8-1, 0, 1<D@@2DD
In[161]:=
partition@83, 5, 7, 9, 2, 4, 6, 8, 3, 4<, 4, LessD
Out[161]=
883, 2, 3<, 84, 4<, 85, 7, 9, 6, 8<<
Our queue analogy easily extends to this case by assuming Reap establishes a sepa-
rate queue for each pattern and Sow chooses the matching queue.
58 | Chapter 2: Functional Programming

See Also
Reap and Sow are used in the tree traversal algorithms in Recipe 3.11. 
2.11 Computing Through Repeated 
Function Application 
Problem
You want to understand the types of computations you can perform using the Nest
family of functions (Nest, NestList, NestWhile, NestWhileList).
Solution
Many problems require repeated application of a function for a specified number of
times. One example that is familiar to most people is compounded interest.
In[162]:=
compoundedInterestAprincipal_, rate_, years_, n_E :=
NestAÒ H1.0 + rateênL &, principal, years nE
As expected, the principal grows in value quicker the more times the interest is com-
pounded per year.
In[163]:=
Table@compoundedInterest@1000, 0.05, 10, nD, 8n, 81, 2, 4, 12, 365<<D
Out[163]=
81628.89, 1638.62, 1643.62, 1647.01, 1648.66<
Another classic application is fractals. Here I use Nest to generate one side of
the Koch snowflake. The rule for creating the snowflake is to take the line seg-
ment, divide it into three equal segments, rotate copies of the middle segment
Pi/3  and  -Pi/3  radians  from  their  ends  to  form  an  equilateral  triangle,  and
then  remove  the  middle  section  of  the  original  line  segment.  This  is  imple-
mented literally (but not efficiently) by iterating a replacement rule using Nest. We
cover these rules in Chapter 4.
2.11 Computing Through Repeated Function Application | 59

In[164]:=
Clear@koch, snowflakeD
koch@Line@x_DD := WithA9s = ScalingMatrix@81ê3, 1ê3<D,
r1 = RotationMatrix@Piê3D, r2 = RotationMatrix@-Piê3D=,
8 Line@x.sD, Line@x.r1.s + 881ê3, 0<, 81ê3, 0<<D,
Line@x.r2.s + 881ê2, -0.289<, 81ê2, -0.289<<D,
Line@s.x + 882ê3, 0<, 82ê3, 0<<D<E
snowflake@n_D := WithA9g = Graphics@8Line@880, 0<, 81, 0<<D<D=,
NestAÒ ê. Line@x_D ß koch@Line@xDD &, g, nEE
GraphicsGrid@
88snowflake@1D, snowflake@3D<, 8snowflake@2D, snowflake@4D<<D
Out[167]=
Discussion
If you are interested in the intermediate values of the iteration, NestList is the an-
swer. Suppose you want to see all rotations of a shape through d radians. Here I use
NestList to rotate clockwise and translate a square with a dot in its corner through
angle d until at least 2Pi radians (360 degrees) are covered.
In[168]:=
allRotations@shape_, d_D := WithA9n = Ceiling@2 PiêdD=,
Graphics@NestList@Translate@Rotate@Ò, -dD, 81.5, 0<D &, shape, nDDE
allRotationsA9Red, Rectangle@D, Black, Point@80.90, 0.1<D=, Piê6E
Out[169]=
NestWhile and NestWhileList generalize Nest and NestList, respectively, by adding a
test  predicate  to  determine  if  the  iterative  application  of  the  function  should  con-
tinue. In addition to the test, an upper limit can be specified to guarantee the itera-
tion terminates in a given number of steps if the test does not terminate it first. Here
is an application that searches for a tour in a traveling salesperson problem (TSP)
that is less than some specified distance. The cities are numbered 1 through n, and
the distances are represented as a sparse matrix. 
60 | Chapter 2: Functional Programming

In[170]:=
H*Make random set of cities.*L
makeCities@n_D :=
SparseArrayAFlattenA
TableA9i, j= Ø IfAi ã j, 0, RandomReal@81, 50<DE, 8i, 1, n<, 9j, 1, i=EEE
H*Given set of cities, and two particular cities,
return distance between.*L
distance@cities_, c1_, c2_D :=
With@8i1 = Max@c1, c2D, i2 = Min@c1, c2D<, cities@@i1, i2DDD
H*Given a tour, compute the total distance traveled
if you visit each city and return to the first.*L
totalDistance@cities_, tour_D :=
Total@ListConvolve@81, 1<, tour,
8-1, -1<, tour, Ò2 &, distance@cities, Ò1, Ò2D &DD
H*Make an initial tour where cities are visted in
ascending order of city number.*L
makeOrderedTour@cities_D := RangeALength@citiesDE
H*Randomly sample tours until a tour is less
than specified distance or maxTries is exceeded.*L
findTourLessThan@cities_, distance_, maxTries_D :=
ModuleA9n = Length@citiesD=,
NestWhile@RandomSample@Ò, nD &, makeOrderedTour@citiesD,
totalDistance@cities, ÒD >= distance &, maxTriesDE
The  algorithm  is  not  very  intelligent,  but  it  nicely  demonstrates  NestWhile.  First  I
make a random set of 10 cities and see the distance of the ordered tour.
In[175]:=
cities = makeCities@10D;
dist = totalDistance@cities, makeOrderedTour@citiesDD
Out[176]=
273.898
Now I see if I can find a better tour that is better than 80% of the ordered tour in
100,000 tries.
In[177]:=
findTourLessThan@cities, 0.80 dist , 100 000D
Out[177]=
89, 5, 10, 2, 6, 8, 3, 7, 1, 4<
You can see that it was successful!
In[178]:=
totalDistance@cities, %D
Out[178]=
300.754
2.11 Computing Through Repeated Function Application | 61

See Also
The replacement rules used in the Koch snowflake are covered in Chapter 4.
In Recipe 12.16, NestList is used to drive a simulation.
The TSP example used ListConvolve to compute the distance of a tour. See Recipe 2.6.
2.12 Building a Function Through Iteration 
Problem
You want to construct a higher-order function from explicit iteration of a lower-or-
der function.
Solution
This is a good application for Nest. For example, you can pre-expand terms in New-
ton’s method for 
n .
In[179]:=
ClearAf, x, y, z, n, termsE;
makeSqrtNewtonExpansionAn_, terms_Integer: 4E :=
FunctionAx,
EvaluateATogether@Nest@Function@z, Hz + nêzLê2D, x, termsDDEE
In[181]:=
sqrt2 = makeSqrtNewtonExpansion@2, 4D
Out[181]=
FunctionAx$, I256 + 15360 x$2 + 116 480 x$4 +
256256 x$6 + 205920 x$8 + 64064 x$10 + 7280 x$12 + 240 x$14 + x$16Më
I16 x$ I2 + x$2M I4 + 12 x$2 + x$4M I16 + 224 x$2 + 280 x$4 + 56 x$6 + x$8MME
We are left with a function that will converge quickly to sqrt[2] when given an initial
guess. Here we see it takes just four iterations to converge.
In[182]:=
FixedPointList@sqrt2, 1`40D
Out[182]=
81.000000000000000000000000000000000000000,
1.41421356237468991062629557889013491012,
1.4142135623730950488016887242096980786,
1.414213562373095048801688724209698079<
Discussion
Code generation is a powerful technique; the solution shows how Function and Nest
can be used with Evaluate to create such a generator. The key here is the use of
Evaluate,  which  forces  the  Nest  to  execute  immediately  to  create  the  body  of  the
function.  Later,  when  you  use  the  function,  you  execute  just  the  generated  code
(i.e., the cost of the Nest is paid only during generation, not application).
62 | Chapter 2: Functional Programming

Fold can also be used as a generator. Here is an example of constructing a continued
fraction  using  Fold  adapted  from  Eric  W.  Weisstein’s  “Continued  Fraction”  from
MathWorld (http://bit.ly/35rxJF).
In[183]:=
continuedFraction@8a0_, l_List?MatrixQ<D :=
a0 + Fold@Ò2@@1DDêHÒ1 + Ò2@@2DDL &, 0, Reverse@lDD
continuedFraction@8a0_, 8<<D := a0
In[185]:=
continuedFraction@8a@0D, Table@8b@iD, a@iD<, 8i, 4<D<D ê.
x_Ay_E ß SubscriptAx, yE
Out[185]=
a0 +
b1
a1 +
b2
a2+
b3
a3+
b4
a4
2.13 Exploiting Function Composition and 
Inverse Functions
Problem
You want to compose one or more functions to produce a new function, with the
added ability to easily invert the new function.
Solution
Use Composition to build a new function f1[f2[f3...[x]]] from f1, f2, f3... and
InverseFunction to convert the composition to ...f3-1[f2-1[f1-1[x]]].
In[186]:=
f = Composition@Exp, CosD
Out[186]=
Composition@Exp, CosD
In[187]:=
result = f@0.5D
Out[187]=
2.40508
In[188]:=
Exp@Cos@0.5DD
Out[188]=
2.40508
If  the  composed  functions  are  invertible,  you  can  compute  the  inverse  of  the
composition.
In[189]:=
InverseFunction@fD@resultD
Out[189]=
0.5
2.13 Exploiting Function Composition and Inverse Functions | 63

Discussion
The Mathematica 6 documentation for Composition is not very compelling. It lists
the following examples of usage:
In[190]:=
H*Create a sum of numbers to be displayed in held form.*L
Composition@HoldForm, PlusD üü Range@20D
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20
Out[190]=
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20
Out[191]=
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20
In[192]:=
H*Tabulate square roots of values without using auxiliary variables.*L
TableFormACompositionAThrough, 9Identity, Sqrt=E êü 80, 1.0, 2.0, 3.0, 4.0<E
Out[192]//TableForm=
0
0
1. 1.
2. 1.41421
3. 1.73205
4. 2.
Although these are certainly examples of usage, they are not compelling because the
same results can be achieved without Composition and, to my tastes, more simply. 
In[193]:=
HoldForm@Plus@ÒÒDD & üü Range@20D
Out[193]=
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20
This is an example of Recipe 2.4.
In[194]:=
9Identity@ÒD, Sqrt@ÒD= & êü 80, 1.0, 2.0, 3.0, 4.0< êê TableForm
Out[194]//TableForm=
0
0
1. 1.
2. 1.41421
3. 1.73205
4. 2.
For some time I thought that Composition was just a curiosity that might appeal to
some mathematically minded folks on aesthetic grounds but otherwise did not add
much  value.  This  was  before  I  understood  how  Composition  can  work  together
with  InverseFunction.  When  you  have  an  arbitrary  composition  of  functions,  In-
verseFunction will produce an inverse of the composition by inverting each compo-
nent and reversing the order of application. In the case of the example in the preceding
“Solution” section, you get the following:
In[195]:=
InverseFunction@Composition@Exp, CosDD
Out[195]=
CompositionAArcCos, LogE
64 | Chapter 2: Functional Programming

Unfortunately, mathematical functions often are not invertible, so this particular ex-
ample will not always work given an arbitrary list of functions. But the really cool
thing is that the functions need not be mathematical or perfectly invertible as long as
you tell Mathematica you know what you’re doing by defining the inverses of your
custom functions!
You can see that Mathematica has no idea what the inverse of RotateRight is, even
though it is obvious that for a list it is RotateLeft.
In[196]:=
InverseFunctionARotateRightE@81, 2, 3<D
Out[196]=
RotateRightH-1L@81, 2, 3<D
But  you  can  define  your  own  version  and  its  inverse  by  using  upvalues  (see
“DownValues and UpValues” on page 27).
In[197]:=
ClearAllAreverse, rotateRightE;
rotateRight@list_ListD := RotateRight@listD
H*Define an UpValue for inverse of rotateRight.*L
InverseFunctionArotateRightE ^:= RotateLeft@Ò1D &
reverse@list_ListD := Reverse@listD
H*Clearly, reverse is its own inverse.*L
InverseFunction@reverseD ^:= reverse@ÒD &
Now, given an arbitrary composition of these functions, we are guaranteed the abil-
ity to produce its inverse with no effort at all! I find that compelling, don’t you?
In[202]:=
tr1 = CompositionAreverse, rotateRight, rotateRightE;
In[203]:=
v = tr1@81, 2, 3, 4, 5, 6<D
Out[203]=
84, 3, 2, 1, 6, 5<
In[204]:=
InverseFunction@tr1D@vD
Out[204]=
81, 2, 3, 4, 5, 6<
The obvious implication of this simple example is that if you define a set of func-
tions and inverses, then given an arbitrary composition of those functions, you will
always have the undo operation handy. Further, you get partial undo via Drop.
In[205]:=
H*Drop one level of undo.*L
Drop@InverseFunction@tr1D, 1D@vD
Out[205]=
86, 1, 2, 3, 4, 5<
In Recipe 2.7 we discussed composing functions using prefix operator @. The follow-
ing illustrates the relationship:
In[206]:=
Composition@f1, f2, f3D@xD === f1üf2üf3üx
Out[206]=
True
2.13 Exploiting Function Composition and Inverse Functions | 65

See Also
ComposeList  returns  the  list  of  results  computed  by  successive  compositions  of  a
given list of functions. See the Mathematica documentation.
2.14 Implementing Closures 
Problem
You want to create expressions with persistent private state, behavior, and identity, but
Mathematica does not directly support Lisp-like closures or object-oriented programming.
The  techniques  described  in  this  section  fall  a  bit  outside  garden-
variety Mathematica; some purists may frown on using techniques that
make  Mathematica  feel  like  a  different  language.  They  might  argue
that  Mathematica  has  enough  features  to  solve  problems  and  that
users  are  better  off  mastering  these  rather  than  trying  to  morph  the
language  into  something  else.  I  think  this  advice  is  generally  sound.
However, Mathematica is a system for multiparadigm programming as
well as a system for research and exploration. So if you are interested,
as  I  am,  in  exploring  software  development  concepts  for  their  own
sake, I think you will find this recipe useful in stimulating new ideas
about what Mathematica can do.
Solution
Create a symbol called closure with attributes HoldAll and with the form closure
[var_List, val_List, func_List]. Create an evaluation function for closures that ex-
ecutes in a private environment provided by Block and returns the result and a new
closure that captures any state changes that occurred during the evaluation.
In[207]:=
SetAttributes@closure, HoldAllD;
SetAttributes@evaluate, HoldFirstD;
evaluate@f_, closure@vars_, vals_, funcs_DD := Block@vars, vars = vals;
Block@funcs, 8f , closure@vars, Evaluate@varsD, funcsD<DD
You can now use this machinery to create a counter.
In[210]:=
ClearAll@makeCounter, counterD;
makeCounter@init_D := With@8v = init<, closure@8x<, 8v<,
8incr = Function@x = x + 1D, decr = Function@x = x - 1D,
reset = Function@v, x = vD, read = Function@xD<DD
counter = makeCounter@0D
Out[212]=
closure@8x<, 80<, 8incr = Hx = x + 1L &,
decr = Hx = x - 1L &, reset = Function@v, x = vD, read = x &<D
66 | Chapter 2: Functional Programming

From a syntactic point of view, the implementation is only half done, but it is usable
(see the folllowing “Discussion” for the icing on the cake).
In[213]:=
8val, counter< = evaluate@incr@D, counterD; val
Out[213]=
1
When you evaluate again, you see that the state change persisted.
In[214]:=
8val, counter< = evaluate@incr@D, counterD; val
Out[214]=
2
Notice that even though the closure contains a free variable x, changes to x in the
global environment do not impact the closure.
In[215]:=
x = 0;
8val, counter< = evaluate@incr@D, counterD; val
Out[216]=
3
However,  you  can  reset  the  counter  through  the  provided  interface.  You  can  also
decrement it and read its current value.
In[217]:=
8val, counter< = evaluate@decr@D, counterD; val
Out[217]=
2
In[218]:=
8val, counter< = evaluate@reset@7D, counterD; val
Out[218]=
7
In[219]:=
8val, counter< = evaluate@read@7D, counterD; val
Out[219]=
7
Discussion
In computer science, a closure is a function that closes over the lexical environment
in which it was defined. In some languages (e.g., Lisp, JavaScript), a closure may oc-
cur when a function is defined within another function, and the inner function refers
to local variables of the outer function. Mathematica cannot do this in a safe way (as
discussed here), hence the solution.
The solution presented is a bit awkward to use and read and, thus, would be easy to
dismiss as a mere curiosity. However, we can use an advanced feature of Mathemat-
ica to make the solution far more compelling, especially to those readers who come
from an object-oriented mind-set. One problem with the solution is that you need to
deal with both the returned value and the returned closure. This is easy to fix by
defining a function call that hides this housekeeping. 
In[220]:=
SetAttributes@call, HoldAllD;
call@f_, c_D := Module@8val<, 8val, c< = evaluate@f, cD; valD
2.14 Implementing Closures | 67

This simplifies things considerably.
In[222]:=
val = call@decr@D, counterD
Out[222]=
6
But we can go further by adding some syntactic sugar using the Notation facility.
In[223]:=
<< Notation`
Notation@c_ ﬂfunc_ ó call@func_, c_DD;
Now you can write code like this:
In[225]:=
counter ﬂincr@D
Out[225]=
7
In[226]:=
counter ﬂreset@0D
Out[226]=
0
In[227]:=
counter ﬂincr@D
Out[227]=
1
You  can  use  an  existing  closure  to  create  new  independent  closures  by  creating  a
clone method. This is known as the prototype pattern.
In[228]:=
clone@closure@vars_, vals_, funcs_DD :=
clone@closure@vars, vals, funcsD, valsD
clone@closure@vars_, vals_, funcs_D, newVals_D :=
With@8v = newVals<, closure@vars, v, funcsDD
In[230]:=
counter2 = clone@counterD H*Clone existing state.*L
Out[230]=
closure@8x<, 81<, 8incr = Hx = x + 1L &,
decr = Hx = x - 1L &, reset = Function@v, x = vD, read = x &<D
In[231]:=
counter3 = clone@counter, 80<D
H*Clone structure but initialize to new state.*L
Out[231]=
closure@8x<, 80<, 8incr = Hx = x + 1L &,
decr = Hx = x - 1L &, reset = Function@v, x = vD, read = x &<D
You can see these counters are independent from the original counters (but they do
share the same functions, so they don’t incur much additional memory overhead).
In[232]:=
counter2 ﬂincr@D
Out[232]=
2
In[233]:=
counter3 ﬂincr@D
Out[233]=
1
In[234]:=
counter ﬂread@D
Out[234]=
1
68 | Chapter 2: Functional Programming

It is instructive to compare this solution with other languages that support closures.
In JavaScript, a closure over an accumulator can be created like this:
javascript
function counter (n) {
return function (i) { return n += i }
} 
Let’s see what happens if we attempt the same approach in Mathematica.
In[235]:=
Clear@makeCounterD;
makeCounterAn_IntegerE := Function@i, n += iD
counter = makeCounter@0D;
In[238]:=
counter@1D
AddTo::rvalue :
0 is not a variable with a value, so its value cannot
be changed. à
Out[238]=
0 += 1
This was doomed from the start because n is not a free variable that can be closed
over by Function. But let’s try something else.
In[239]:=
Clear@makeCounter, stateD;
makeCounterAn_IntegerE := Block@8state = n<, Function@i, state += iDD
counter = makeCounter@0D;
In[242]:=
counter@1D
AddTo::rvalue :
state is not a variable with a value, so its value
cannot be changed. à
Out[242]=
state += 1
This fails because state is only defined while the block is active, because Block is a
dynamic scoping construct and closures require lexical scoping. You might recall that
Module is a lexical scoping construct; perhaps we would have better luck with that.
In[243]:=
Clear@makeCounter, stateD;
makeCounterAn_IntegerE := Module@8state = n<, Function@i, state += iDD
counter = makeCounter@0D;
In[246]:=
counter@1D
Out[246]=
1
In[247]:=
counter@1D
Out[247]=
2
2.14 Implementing Closures | 69

This seems to work, but it has a flaw that you can see if you inspect the value of
counter.
In[248]:=
counter
Out[248]=
Function@i$, state$2811 += i$D
The variable we called state has now morphed into something called state$<some
number>.  The  point  here  is  that  Module  implements  lexical  scope  by  synthesizing  a
global variable that is guaranteed not to be defined already, but that variable is not
protected in any way and could be changed by the user. This is not esthetically pleasing
and is not at all what is happening in the JavaScript or Lisp equivalents.
The solution in this recipe uses a different tactic. It uses the HoldAll attribute to cre-
ate a container for the lexical environment of the closure. Because the variables and
functions are held in unevaluated form, it makes no difference if there are global
symbols with the same names. When it comes time to evaluate the closure, the evaluate
function builds up a Block on the fly to create local instances of the variables and an-
other Block to create local instances of the functions. It then binds the stored values
of  the  variables  and  functions  to  these  locals  and  calls  the  appropriate  locally  de-
fined function. 
What practical value are closures within the context of Mathematica? Clearly, creat-
ing a counter is too trivial. However, even the simple counter example shows some
promising features of this technique. First, had we implemented the counter as a sim-
ple global variable, it could be used accidentally for some purpose inconsistent with
the behavior of a counter. By encapsulating the counter in the closure, we restrict ac-
cess to its state and the interface exposed by the closure becomes the only way to ma-
nipulate it. Further, the interface can be easily inspected because it is carried around
inside the closure. 
Mathematica 6’s Dynamic feature provides the context for a compelling application
of closures. Let’s say you want to create a graphic that can be dynamically updated
under programmatic control (rather than user control, for which you would use Ma-
nipulate instead). One way to do this is to define variables for all the aspects of the
graphic that you need to change and wrap the graphic in a Dynamic function.
70 | Chapter 2: Functional Programming

In[249]:=
rectX = 1; rectY = 2; rectAngle = 10 Degree; circR = 1;
DynamicModuleA9g=,
g = GraphicsA9Thick, Green, RotateARectangle@80, 0<, 8rectX, rectY<D,
rectAngleE, Red, Disk@80, 0<, circRD=, ImageSize Ø SmallE;
DynamicA
gEE
Out[250]=
You then write Mathematica code that manipulates the variables as necessary to dy-
namically update the drawing. This is all well and good for a simple example with
two shapes and four degrees of freedom, but imagine if you were doing this as part
of a simulation that had hundreds of shapes with hundreds of degrees of freedom.
Clearly, you would want a way to encapsulate all those variables behind an interface
that made sense for the simulation. This closure facility can do just that.
In[251]:=
ClearAll@shapeCtrlD
shapeCtrl = closureA9rectX, rectY, rectAngle, circR=, 91, 2, 10 Degree, 1=,
9rotate = FunctionAa, rectAngle += aE,
grow = Function@r, rectX *= r; rectY *= rD,
rectCorner = Function@8rectX, rectY<D,
angle = FunctionArectAngleE,
radius = Function@circRD=E
Out[252]=
closureA9rectX, rectY, rectAngle, circR=,
81, 2, 10 °, 1<, 9rotate = FunctionAa, rectAngle += aE,
grow = Function@r, rectX *= r; rectY *= rD,
rectCorner = 8rectX, rectY< &, angle = rectAngle &, radius = circR &=E
2.14 Implementing Closures | 71

In[253]:=
closureA9rectX, rectY, rectAngle, circR=,
81, 2, 10 °, 1<, 9rotate = FunctionAa, rectAngle += aE,
grow = Function@r, rectX *= r; rectY *= rD,
rectCorner = 8rectX, rectY< &, angle = rectAngle &, radius = circR &=E
Out[253]=
closureA9rectX, rectY, rectAngle, circR=,
81, 2, 10 °, 1<, 9rotate = FunctionAa, rectAngle += aE,
grow = Function@r, rectX *= r; rectY *= rD,
rectCorner = 8rectX, rectY< &, angle = rectAngle &, radius = circR &=E
Here you define a closure, called shapeCtrl, over the same graphic but expose only
two  functions,  rotate  and  grow,  that  are  capable  of  changing  the  state.  The  other
functions are strictly for returning the values for use in the graphic. You now specify
the dynamic graphic in terms of the shape controller closure.
In[254]:=
DynamicAGraphicsA9Thick, Green, RotateA
Rectangle@80, 0<, shapeCtrl ﬂrectCorner@DD, shapeCtrl ﬂangle@DE, Red,
Disk@80, 0<, shapeCtrl ﬂradius@DD=, Frame Ø True, PlotRange Ø AllEE;
By its nature, dynamic content does not lend itself to static print demonstration, but
we compensate by showing the result of each transform in the figure.
Original
shapeCtrl ﬂrotate@20D
shapeCtrl ﬂgrow@1.5D
Figure 2-1. Transformations snapshots of the graphics
It could be argued that this recipe has crossed the boundary of the traditional defini-
tion of a closure and moved toward the capabilities of object-oriented programming.
This is no accident, since there is a relationship between closures and objects, in that
closures can be used to implement object-oriented programming, and languages like
C++  can  implement  closures  in  terms  of  objects  with  operator().  However,  a
full-blown,  object-oriented  implementation  would  have  to  provide  additional  fea-
tures not implemented by this recipe. Inheritance is the most obvious, but there are
others (e.g., different access levels for functions and data). I prefer to think of this im-
72 | Chapter 2: Functional Programming

plementation as souped-up closures rather than dumbed-down objects, but you can
think  of  them  in  whichever  way  makes  the  most  sense  to  you.  My  feeling  is  that
more traditional closures that act like single functions don’t provide enough bang
for the buck. In any case, the simpler, traditional form can be implemented in terms
of the richer form demonstrated in this recipe. Here is one way to do it.
In[255]:=
H*First define a closure with a
single function and assign to a variable.*L
incr = closure@8x<, 80<, 8incr = Function@x = x + 1D<D
Out[255]=
closure@8x<, 80<, 8incr = Hx = x + 1L &<D
In[256]:=
H*Then define a function pattern in terms of the same closure
but with a Blank where the state variables would reside.*L
closure@8x<, 8_<, 8incr = Function@x = x + 1D<D @D := call@incr@D, incrD
In[257]:=
H*Now, whenever the variable is used like a function,
it will invoke the call on the closure.*L
incr@D
Out[257]=
1
In[258]:=
incr@D
Out[258]=
2
In[259]:=
incr@D
Out[259]=
3
See Also
The Wikipedia entry for closures (http://bit.ly/T9vhN) is a good place to start learn-
ing more about this concept because it contains links to some useful papers and im-
plementations in other languages.
2.15 Currying in Mathematica
Problem
You want to emulate the ability of other functional languages to automatically con-
vert  functions  of  multiple  arguments  into  higher-order  functions  with  a  single
argument.
This recipe is more of theoretical interest to functional programming
aficionados  than  of  practical  use  for  everyday  Mathematica
development.  The  techniques  employed  are  of  more  general  interest,
but  you  may  need  to  consult  Chapter  4  if  you  are  unfamiliar  with
patterns and replacement rules.
2.15 Currying in Mathematica | 73

Solution
Mathematica does not support implicit currying like Haskell does, but you can use
this  solution  to  create  functions  that  curry  implicitly.  Refer  to  the  next  section,
“Discussion,” if you are unfamiliar with currying.
In[260]:=
Clear@f, f1, f2D; Curry@f_, x__D :=
ModuleA8expr<, expr = HoldAIfAValueQ@f@xDD, f@xD, Curry@z, ÒÒD &EE êê.
g_@a_D@b__D -> g@a, bD ê. z Ø f@xD; ReleaseHold@exprDE
fAx_, y_, z_E := x + y +
z
In[262]:=
H*Create f1 by currying f.*L
f1 = Curry@f, 10D
Out[262]=
Curry@f@10D, ÒÒ1D &
In[263]:=
H*f2 now can be created by implicit currying f1.*L
f2 = f1@20D
Out[263]=
Curry@f@10D@20D, ÒÒ1D &
In[264]:=
H*f2 evaluates because all three arguments become available.*L
f2@30D
Out[264]=
60
In[265]:=
H*f1 evaluates if the remaining two arguments are supplied.*L
f1@20, 30D
Out[265]=
60
In[266]:=
H*And the curried syntax works as well.*L
f1@20D@30D
Out[266]=
60
Discussion
Currying  is  the  process  of  transforming  a  function  that  takes  multiple  arguments
into a function that takes just a single argument and returns another function if any
arguments are still needed. In languages that implicitly curry, you can write code as
follows:
In[267]:=
f1 = f@10D
Out[267]=
f@10D
In[268]:=
f2 = f1@20D
Out[268]=
f@10D@20D
In[269]:=
f2@30D
Out[269]=
f@10D@20D@30D
74 | Chapter 2: Functional Programming

This is legal in Mathematica, but notice that when all three arguments are supplied,
the function remains in unevaluated curried form. This is not the effect that you typi-
cally want. It is possible to manually uncurry by using ReplaceAllRepeated (//.) to
transform the curried form to normal form.
In[270]:=
f2@30D êê. g_@a_D@b__D Ø g@a, bD
Out[270]=
60
The function Curry in the solution works as follows. It builds up an expression that
says,  “See  if  the  specified  function  (first  argument)  with  the  specified  parameters
(second argument) will evaluate (ValueQ); if so, evaluate it. Otherwise, return the
curried version of the function within a lambda expression using the Curry function
itself.” To add to the trickery, this expression needs to be built up in the context of a
Hold to keep everything unevaluated until it can be transformed into a format where
the ValueQ test and evaluation are in uncurried form. However, the lambda function
part must remain in curried form, so we use z as a placeholder for a second round
ReplaceAll (/.) that injects the curried form, instead of z. 
I’ll  be  the  first  to  admit  this  is  tricky,  but  if  you  are  tenacious  (and  perhaps  look
ahead to some of the recipes in Chapter 4), you will be rewarded with a deeper under-
standing of how powerful Mathematica can be at bootstrapping new behaviors. One
way to get a handle on what is happening is to execute a version of Curry that does not re-
lease the Hold. This allows you to inspect the result at each stage before it is evaluated.
In[271]:=
CurryHold@f_, x__D :=
ModuleA8expr<, expr = HoldAIfAValueQ@f@xDD, f@xD, Curry@z, ÒÒD &EE êê.
g_@a_D@b__D -> g@a, bD ê. z Ø f@xDE
When the Hold is released, ValueQ[f[10]] will return false, so we will return a Func-
tion (&) that curries f[10] with yet to be supplied arguments ##1.
In[272]:=
CurryHold@f, 10D
Out[272]=
HoldAIfAValueQ@f@10DD, f@10D, Curry@f@10D, ÒÒ1D &EE
When this Hold is released, ValueQ will also fail because there is no two-argument ver-
sion of f, and we get a further currying function on f[10][20] that is ready for more
arguments ##1.
In[273]:=
CurryHold@f1, 20D
Out[273]=
HoldAIfAValueQ@f@10, 20DD, f@10, 20D, Curry@f@10D@20D, ÒÒ1D &EE
Finally,  by  supplying  a  third  argument,  we  get  an  uncurried  function  f[10,20,30]
that will evaluate; so ValueQ succeeds, and the uncurried version is evaluated.
In[274]:=
CurryHold@f2, 30D
Out[274]=
HoldAIfAValueQ@f@10, 20, 30DD, f@10, 20, 30D, Curry@f@10D@20D@30D, ÒÒ1D &EE
2.15 Currying in Mathematica | 75

A useful addition is a function that creates a self-currying function without supply-
ing the first argument.
In[275]:=
makeCurry@f_D := Curry@f, ÒÒD &
In[276]:=
f0 = makeCurry@fD
Out[276]=
Curry@f, ÒÒ1D &
In[277]:=
f0@10D @20D@30D
Out[277]=
60
So now that you’ve suffered through this magic act, I expect you’d like to be told
that there is some neat application of currying. However, as I mentioned in the warn-
ing on page 73, currying is largely of theoretical interest. This is true even in lan-
guages where it occurs transparently. For example, many new Haskell programmers
don’t  think  in  terms  of  transformations  from  functions  to  higher-order  functions,
but rather, in terms of producing new functions that are specializations of existing
functions (i.e., the new function is produced by binding the first argument of the gen-
eral function). The reason Haskell was designed with currying functions is that its
designers were concerned with formal proofs of correctness. Such proofs are easier
when all functions can be thought of as having a single argument and producing a
single result. If you’re a mathematician, you may find these ideas interesting; please
see the references in the “See Also” section on page 77.
I should emphasize that the goal of this recipe was to achieve implicit currying. Ex-
plicit currying is easy. In fact, explicit currying should really not be called currying at
all,  but  rather,  should  be  called  partial  function  application.  For  example,  if  you
want to manually create a function that hard codes the first parameter of f to 10, sim-
ply write f[10, ##]& . You can automate creation of such functions with the follow-
ing code:
In[278]:=
explicitCurry@f_, v_D := Function@f@v, ÒÒDD
In[279]:=
f1 = explicitCurry@f, 10D;
f2 = explicitCurry@f1, 20D;
In[281]:=
f1@20, 30D
Out[281]=
60
In[282]:=
f2@30D
Out[282]=
60
The obvious difference between implicit and explicit currying is the need to explic-
itly use the currying function each time, hence the name “explicit.”
76 | Chapter 2: Functional Programming

See Also
Information on currying in Haskell can be found at http://bit.ly/2eABAm.
You  will  be  impressed  by  the  expressiveness  of  Mathematica  by  comparing  the
amount  of  code  in  this  recipe  with  the  code  to  implement  implicit  currying  in
scheme (http://bit.ly/otB90).
Theoretical ideas about the relationship between proofs and programs can be found
at http://bit.ly/2YrkxI.
2.16 Creating Functions with Default Values
Problem
You want to create functions with optional arguments that specify default values. 
Solution
The simplest way to define a function with default values is to use the syntax x_: default
or x_h:default.
In[283]:=
someFuncAarg1_Integer, arg2_Integer : 0E := arg1 ^ 2 + arg2
In[284]:=
someFunc@10D
Out[284]=
100
In[285]:=
someFunc@10, 1D
Out[285]=
101
Another technique is to register a global default value with Mathematica using De-
fault. This facility is used by many built-in Mathematica functions, such as Plus.
You can use Default to query or set defaults for your own functions. Defaults can apply
to multiple arguments or specific arguments.
In[286]:=
Default@PlusDH*Missing arguments to Plus default to zero.*L
Out[286]=
0
In[287]:=
Plus@D
Out[287]=
0
In[288]:=
Plus@1D
Out[288]=
1
If you ask for a default that is undefined, the function will not evaluate.
In[289]:=
ClearAllAmyFuncWithDefaultE; DefaultAmyFuncWithDefault, 2E
Out[289]=
DefaultAmyFuncWithDefault, 2E
2.16 Creating Functions with Default Values | 77

You must define the default before defining the function that uses it.
In[290]:=
DefaultAmyFuncWithDefault, 2E = 0
Out[290]=
0
In[291]:=
DefaultAmyFuncWithDefault, 2E
Out[291]=
0
An argument whose default has been registered with Default is specified as x_. (the
trailing period signals the default).
In[292]:=
myFuncWithDefaultAx_, y_.E := x^y - x + y
When you inspect the definition of a function, it shows the registered defaults.
In[293]:=
DefinitionAmyFuncWithDefaultE
Out[293]=
myFuncWithDefaultAx_, y_.E := xy - x + y
myFuncWithDefault ê: DefaultAmyFuncWithDefault, 2E = 0
In[294]:=
myFuncWithDefault@4D
Out[294]=
-3
In[295]:=
myFuncWithDefault@10, 1D
Out[295]=
1
Discussion
Unlike in some other languages, in Mathematica, the arguments with default values
need not be at the end.
In[296]:=
someFunc2Aarg1_Integer : 1, arg2_IntegerE := arg1 ^ 2 + arg2
In[297]:=
someFunc2@10D
Out[297]=
11
In[298]:=
someFunc2@10, 1D
Out[298]=
101
Ambiguities are resolved by assigning values to the leftmost argument that matches.
In[299]:=
someFunc3Aarg1_Integer : 1, arg2_Integer : 0E := 2 arg1 + arg2
In[300]:=
someFunc3@10D
Out[300]=
20
In[301]:=
someFunc4Aarg1_String : "test", arg2_Integer : 1E := StringTakeAarg1, arg2E
In[302]:=
someFunc4@3D H*3 does not match String
so it is assigned to the second default.*L
Out[302]=
tes
78 | Chapter 2: Functional Programming

Having this much flexibility is sometimes useful, but if you are writing a library of
functions to be used by others, it is probably best to place all parameters with de-
faults at the end.
You may be wondering why Mathematica provides two distinct methods to specify
default values. The flippant answer is that Mathematica provides at least two ways
to do everything! But there are useful differences. For functions you write for your
own use, the arg_ : default does the job in most cases. The advantage of the De-
fault method is that it separates the default definition from the function definition.
This allows users to alter the defaults if they do so before loading the module contain-
ing your functions, and if you code your module to only define defaults if existing de-
faults are not already defined. 
BeginPackage["SomePackage`"]
yourFunction::usage = "This function works miracles."
Begin["`Private`"]
(*If there are not already defaults defined, define them.*)
If[DefaultValues[yourFunction] == {},
Default[yourFunction] = 0,
Null];
yourFunction[a_,b_,c_.,d_.] := ...
End[]
EndPackage[]
2.17 Creating Functions That Accept Options
Problem
You need to write a function that can be customized by the user in a variety of ways. 
Solution
Set  up  default  values  for  the  function  by  registering  them  with  Options[yourFun].
Then  write  the  function  to  accept  an  optional  OptionsPattern[]  as  the  last  argu-
ment.  Use  the  companion  function  OptionValue[option]  to  retrieve  the  effective
value of option. I’ll illustrate this technique by implementing a quick sort algorithm.
There  are  two  obvious  ways  to  customize  a  quick  sort.  First,  you  can  allow
2.17 Creating Functions That Accept Options | 79

the user to specify the comparison function. Second, you can allow the caller to cus-
tomize the function used to select the pivot element.
This quick sort is in no way as performant as Mathematica’s Sort[], so
I don’t recommend using it. I introduce it solely to illustrate a custom
function with options.
By default, use the first element to pivot and the Less function for comparisons.
In[303]:=
Options@qsortD = 8pivot Ø First, compare Ø Less< ;
The options, by convention, are accepted as the last parameter.
In[304]:=
qsort@l_List, opts : OptionsPattern@DD :=
Module@8pivotFunc, compareFunc<,
8pivotFunc, compareFunc< = 8OptionValue@pivotD, OptionValue@compareD< ;
Reap@qsort2@l, pivotFunc, compareFuncDD@@2, 1DDD
Function qsort2 does most of the work after options are resolved. The partition is
from Recipe 2.10.
In[305]:=
qsort2@8<, _, _D := 8<
qsort2@8a_<, _, _D := Sow@aD
qsort2@l_List, pivot_, comp_D :=
Block@8l1, l2, l3<, 8l1, l2, l3< = partition@l, pivot@lD, compD;
qsort2@l1, pivot, compD;
Scan@Sow, l2D;
qsort2@l3, pivot, compDD
Prior  to  version  6,  OptionValue[]  did  not  exist.  The  idiomatic  solution  used  Re-
placeAll (/.) to first apply user-specified options and then the default options. You
may still encounter this idiom in older code. 
{pivotFunc, compareFunc} = {pivot, compare} /. opts /. Options[qsort];
Let’s test the function with and without options.
In[308]:=
unsorted = RandomInteger@8-100, 100<, 50D
Out[308]=
842, 77, 50, 98, -89, 49, 21, 70, 2, -39, 41, -100, 32, -19, -36, 99, 43,
37, 34, 35, -98, 58, -10, -38, -80, 25, -40, -26, 3, 62, -13, 5, 15, -40,
83, -74, -43, 31, 78, -89, 15, 60, 67, -55, -7, -45, -16, -91, 21, 16<
In[309]:=
qsort@unsortedD
Out[309]=
8-100, -98, -91, -89, -89, -80, -74, -55, -45, -43, -40, -40, -39, -38,
-36, -26, -19, -16, -13, -10, -7, 2, 3, 5, 15, 15, 16, 21, 21, 25, 31,
32, 34, 35, 37, 41, 42, 43, 49, 50, 58, 60, 62, 67, 70, 77, 78, 83, 98, 99<
80 | Chapter 2: Functional Programming

In[310]:=
qsort@unsorted, compare Ø GreaterD
Out[310]=
899, 98, 83, 78, 77, 70, 67, 62, 60, 58, 50, 49, 43, 42, 41, 37, 35, 34, 32,
31, 25, 21, 21, 16, 15, 15, 5, 3, 2, -7, -10, -13, -16, -19, -26, -36,
-38, -39, -40, -40, -43, -45, -55, -74, -80, -89, -89, -91, -98, -100<
In[311]:=
H*Always pivoting on the first element leads to bad performance
if lists are already sorted, so a random selection of pivot
points might be safer Ialthough there are no guaranteesM.*L
qsort@unsorted, pivot Ø RandomChoiceD
Out[311]=
8-100, -98, -91, -89, -89, -80, -74, -55, -45, -43, -40, -40, -39, -38,
-36, -26, -19, -16, -13, -10, -7, 2, 3, 5, 15, 15, 16, 21, 21, 25, 31,
32, 34, 35, 37, 41, 42, 43, 49, 50, 58, 60, 62, 67, 70, 77, 78, 83, 98, 99<
In[312]:=
H*Here we specify both pivot and comparison using custom functions.*L
qsortAunsorted, pivot Ø IPartAÒ, FloorALength@ÒDë 2EE &M,
compare Ø HLess@Abs@Ò1D, Abs@Ò2DD &LE
Out[312]=
82, 3, 5, -7, -10, -13, 15, 15, -16, 16, -19, 21, 21, 25, -26, 31, 32, 34,
35, -36, 37, -38, -39, -40, -40, 41, 42, 43, -43, -45, 49, 50, -55, 58,
60, 62, 67, 70, -74, 77, 78, -80, 83, -89, -89, -91, 98, -98, 99, -100<
Discussion
Options are a better choice than default values (Recipe 2.16) when there are many
different options (the Graphics function of Mathematica is a good example) or when
the default option values are fine for most users and you don’t want to clutter the
function interface with low-level details.
Sometimes  you  are  not  interested  in  using  options  directly  in  your  function,  but
merely want to pass them on to other built-in Mathematica functions. You need to
be careful to pass only options that are applicable. The function FilterRules pro-
vides a convenient way to solve this problem. The Mathematica documentation pro-
vides a nice example of a function that solves a differential equation and then plots
the solution.
2.17 Creating Functions That Accept Options | 81

In[313]:=
ClearAx, y, x0, x1E;
odeplotAde_, y_, 8x_, x0_, x1_<, opts : OptionsPattern@DE :=
ModuleA8sol<,
sol =
NDSolveAde, y, 8x, x0, x1<, FilterRules@8opts<, Options@NDSolveDDE;
IfAHead@solD === NDSolve,
$Failed,
PlotAEvaluateAy ê. solE, 8x, x0, x1<,
Evaluate@FilterRules@8opts<, Options@PlotDDDE
E
E
In[315]:=
odeplotA9y''@xD + y@xD == 0, y@0D ã 1, y'@0D ã 0=, y@xD,
8x, 0, 10<, Method -> "ExplicitRungeKutta", PlotStyle Ø DashedE
Out[315]=
2
4
6
8
10
-1.0
-0.5
0.5
1.0
Without FilterOptions you would get an error.
In[316]:=
ClearAx, y, x0, x1E;
odeplotBadAde_, y_, 8x_, x0_, x1_<, opts : OptionsPattern@DE :=
ModuleA8sol<,
sol = NDSolveAde, y, 8x, x0, x1<, optsE;
IfAHead@solD === NDSolve,
$Failed,
PlotAEvaluateAy ê. solE, 8x, x0, x1<, optsE
E
E
82 | Chapter 2: Functional Programming

In[318]:=
odeplotBadA9y''@xD + y@xD == 0, y@0D ã 1, y'@0D ã 0=, y@xD,
8x, 0, 10<, Method -> "ExplicitRungeKutta", PlotStyle Ø DashedE
NDSolve::optx : Unknown option PlotStyle in
NDSolve@8y@xD + y££@xD ã 0, y@0D ã 1, y£@0D ã 0<, y@xD,
8x, 0, 10<, Method Ø
ExplicitRungeKutta, PlotStyle Ø Dashing@8Small, Small<DD.
à
Out[318]=
$Failed
When writing or working with functions that use options, keep in mind that Mathe-
matica’s convention is to give precedence to options that appear earlier in the list. So
if two options conflict, the first wins.
In[319]:=
PlotASin@xD, 8x, -Pi, Pi<, PlotStyle Ø Dashed, PlotStyle Ø ThickE
H*Dashed wins.*L
Out[319]=
-3
-2
-1
1
2
3
-1.0
-0.5
0.5
1.0
2.17 Creating Functions That Accept Options | 83


CHAPTER 3
Data Structures 
Well I live with snakes and lizards 
And other things that go bump in the night 
3.0 Introduction
Higher mathematics is rich in structures and formalisms that take mathematics be-
yond  the  realm  of  numbers.  This  chapter  includes  a  potpourri  of  recipes  for  data
structures  and  algorithms  that  arise  in  linear  algebra,  tensor  calculus,  set  theory,
graph theory, and computer science. For the most part, lists form the foundation for
these  structures.  Mathematica  gains  a  lot  of  mileage  by  representing  sets,  vectors,
matrices, and tensors using lists because all the generic list operations are available
for their manipulation. Of course, a list, a set, and a tensor are very distinct entities
from  a  mathematical  point  of  view,  but  this  distinction  is  handled  by  special-
purpose functions rather than special-purpose data structures. 
List Functions
The foundation of most data structures in Mathematica is the list. It is difficult to do 
much advanced work with Mathematica unless you are fluent in its functions for list 
processing. To this end, the initial recipes revolve around basic list processing. A list 
in Mathematica is constructed using the function List[elem1,elem2,...,elemN] or,
more commonly, with curly brackets {elem1,elem2,...,elemN}. There is no restric-
tion on the nature of these elements. They could be mixtures of numbers, strings,
functions,  other  lists,  or  anything  else  Mathematica  can  represent  (like  graphic  or
sound data). 

The first thing you need to know about lists is how to generate them. Table is the
workhorse function for doing this. It has several variations that are most easily ex-
plained by example.
In[1]:=
H*Ten copies of an expr; in this case, the constant 1*L
Table@1, 810<D
Out[1]=
81, 1, 1, 1, 1, 1, 1, 1, 1, 1<
In[2]:=
H*The result of evaluation expr for i 1 to 10*L
Table@i^2, 8i, 10<D
Out[2]=
81, 4, 9, 16, 25, 36, 49, 64, 81, 100<
In[3]:=
H*The result of evaluation expr for i 2 to 10*L
Table@i^2, 8i, 2, 10<D
Out[3]=
84, 9, 16, 25, 36, 49, 64, 81, 100<
In[4]:=
H*The result of evaluation expr for i 2 to 10 by steps of 2*L
Table@i, 8i, 2, 10, 2<D
Out[4]=
82, 4, 6, 8, 10<
In[5]:=
H*2 x 3 matrix of constant 1*L
Table@1, 82<, 83<D
Out[5]=
881, 1, 1<, 81, 1, 1<<
In[6]:=
H*Tensor of rank three*L
TableAi + j^2 + k^3, 8i, 0, 2<, 9j, 0, 2=, 8k, 0, 2<E êê MatrixForm
Out[6]//MatrixForm=
0
1
8
1
2
9
4
5
12
1
2
9
2
3
10
5
6
13
2
3
10
3
4
11
6
7
14
In  addition  to  Table,  Mathematica  has  several  special-purpose  list  constructors:
Range,  Array,  ConstantArray,  DiagonalMatrix,  and  IdentityMatrix.  These  functions
are less general than Table but are clearer and simpler to use when applicable. For ex-
ample, consider IdentityMatrix and its Table equivalent. 
86 | Chapter 3: Data Structures 

In[7]:=
IdentityMatrix@3D êê MatrixForm
Out[7]//MatrixForm=
1 0 0
0 1 0
0 0 1
In[8]:=
H*Equivalent to IdentityMatrix*L
TableAIfAi ã j, 1, 0E, 8i, 1, 3<, 9j, 1, 3=E êê MatrixForm
Out[8]//MatrixForm=
1 0 0
0 1 0
0 0 1
Sometimes using a special-purpose list constructor is more verbose. Consider these
equivalent ways of generating an array of ten 1s. Here, 1& is the function that always
returns 1.
In[9]:=
Array@1 &, 10D ã ConstantArray@1, 10D
Out[9]=
True
Once you have one or more lists, you can compose new lists using functions like
Append, Prepend, Insert, Join, and Riffle.
In[10]:=
list1 = Range@10D
Out[10]=
81, 2, 3, 4, 5, 6, 7, 8, 9, 10<
In[11]:=
list2 = list1 ^ 2
Out[11]=
81, 4, 9, 16, 25, 36, 49, 64, 81, 100<
In[12]:=
H*Add elements to the end.*L
Append@list1, 11D
Out[12]=
81, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11<
In[13]:=
H*Add elements to the front.*L
Prepend@list1, 0D
Out[13]=
80, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10<
In[14]:=
H*Insert elements at specific positions.*L
Insert@list1, 3.5, 4D
Out[14]=
81, 2, 3, 3.5, 4, 5, 6, 7, 8, 9, 10<
In[15]:=
H*Negative offsets to insert from the end*L
Insert@list1, 3.5, -4D
Out[15]=
81, 2, 3, 4, 5, 6, 7, 3.5, 8, 9, 10<
In[16]:=
H*You can insert at multiple positions 88i1<,8i2<,...,8iN<<.*L
InsertAlist1, 0, List êü RangeA2, Length@list1DEE
Out[16]=
81, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10<
3.0 Introduction | 87

In[17]:=
H*Join one or more lists.*L
Join@list1, list2D
Out[17]=
81, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100<
In[18]:=
H*Riffle is a function specifically designed to interleave elements.*L
Riffle@list1, 0D
Out[18]=
81, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10<
The flip side of building lists is taking them apart. Here you will use operations like
Part, First, Last, Rest, Most, Take, Drop, Select, and Cases.
In[19]:=
H*Part is frequently accessed via its operator @@exprDD equivalent.*L
list1@@3DD ã Part@list1, 3D
Out[19]=
True
In[20]:=
H*Accessing the first element. Lisp
programmers call this operation car.*L
First@list1D
Out[20]=
1
In[21]:=
H*Accessing the last element*L
Last@list1D
Out[21]=
10
In[22]:=
H*All but the first element. Lisp programmers call this operation cdr.*L
Rest@list1D
Out[22]=
82, 3, 4, 5, 6, 7, 8, 9, 10<
In[23]:=
H*All but the last element*L
Most@list1D
Out[23]=
81, 2, 3, 4, 5, 6, 7, 8, 9<
In[24]:=
H*The first three elements*L
Take@list1, 3D
Out[24]=
81, 2, 3<
In[25]:=
H*All but the first three*L
Drop@list1, 3D
Out[25]=
84, 5, 6, 7, 8, 9, 10<
In[26]:=
H*The elements in which some criterion is satisfied,
in this case odd elements*L
Select@list1, OddQD
Out[26]=
81, 3, 5, 7, 9<
88 | Chapter 3: Data Structures 

In[27]:=
H*The elements matching a pattern*L
CasesAlist1 ê3 , a_Integer Ø 3 aE
Out[27]=
83, 6, 9<
See Chapter 5 for more information on patterns.
You  rearrange  and  restructure  lists  using  functions  such  as  Reverse,  RotateLeft,
RotateRight, Flatten, Partition, Transpose, and Sort. 
In[28]:=
Reverse@list1D
Out[28]=
810, 9, 8, 7, 6, 5, 4, 3, 2, 1<
In[29]:=
RotateLeft@list1D
Out[29]=
82, 3, 4, 5, 6, 7, 8, 9, 10, 1<
In[30]:=
RotateRight@list1D
Out[30]=
810, 1, 2, 3, 4, 5, 6, 7, 8, 9<
Partition and Flatten are very versatile functions for creating and removing struc-
ture. Flatten can be thought of as the inverse of Partition. Here, repeated partition-
ing using Nest converts a list to a binary tree.
In[31]:=
bifurcate@list_D :=
NestAPartition@Ò, 2D &, list, FloorALogA2, Length@listDEEE
Hstructured = bifurcate@list1DL êê TreeForm
Out[32]//TreeForm=
List
List
List
List
1
2
List
3
4
List
List
5
6
List
7
8
In[33]:=
Flatten@structuredD
Out[33]=
81, 2, 3, 4, 5, 6, 7, 8<
3.0 Introduction | 89

Flatten can also take a level that tells it to flatten only up to that level.
In[34]:=
Flatten@structured, 1D êê TreeForm
Out[34]//TreeForm=
List
List
List
1
2
List
3
4
List
List
5
6
List
7
8
In[35]:=
Flatten@structured, 2D êê TreeForm
Out[35]//TreeForm=
List
List
1
2
List
3
4
List
5
6
List
7
8
In[36]:=
Flatten@structured, 3D
Out[36]=
81, 2, 3, 4, 5, 6, 7, 8<
Many  of  these  functions  have  advanced  features,  so  you  should  refer  to  the
Mathematica documentation for each to understand their full capabilities. I will use
these functions frequently throughout this book without further explanation, so if
you are not already familiar with them, you should take some time to experi-
ment on your own.
90 | Chapter 3: Data Structures 

Set Functions
A  set  in  Mathematica  is  nothing  more  than  a  list  that  is  normalized  to  eliminate
duplicates upon application of a set operation: Union, Intersection, or Complement.
To determine duplicates, Mathematica uses an option called SameTest, which by de-
fault is the function SameQ or ===. The function Subsets constructs a list of all sub-
sets. MemberQ is used to test membership, but this function is far more general, and I
will revisit it in Chapter 4. 
In[37]:=
Union@list1, list2D
Out[37]=
81, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 25, 36, 49, 64, 81, 100<
In[38]:=
Intersection@list1, list2D
Out[38]=
81, 4, 9<
In[39]:=
H*Complement can be used with
Intersection to implement Set Difference.*L
Complement@list1, Intersection@list1, list2DD
Out[39]=
82, 3, 5, 6, 7, 8, 10<
In[40]:=
Complement@list2, Intersection@list1, list2DD
Out[40]=
816, 25, 36, 49, 64, 81, 100<
In[41]:=
H*Generating all subsets*L
Subsets@8a, b, c<D
Out[41]=
88<, 8a<, 8b<, 8c<, 8a, b<, 8a, c<, 8b, c<, 8a, b, c<<
In[42]:=
MemberQ@list2, 4D
Out[42]=
True
Vector Functions
A vector is also represented by a list, but Mathematica has a special representation
called a SparseArray that can conserve space when a vector contains many zero en-
tries (see Recipe 3.8). Matrices and tensors are naturally represented as nested lists;
these likewise can use SparseArrays.
Vector math is supported by the fact that most mathematical operations have the at-
tribute Listable, meaning that the operations automatically thread over lists.
3.0 Introduction | 91

In[43]:=
H*Multiplication and subtraction of a vector by a scalar*L
3 * list1 - 3
Out[43]=
80, 3, 6, 9, 12, 15, 18, 21, 24, 27<
In[44]:=
H*Listable is the relevant property.*L
Intersection@Flatten@Attributes@8Times, Plus, Minus, Divide, Power<DDD
Out[44]=
9Flat, Listable, NumericFunction,
OneIdentity, Orderless, Protected, ReadProtected=
Same-sized vectors and matrices can also be added, multiplied, and so on, in
an element-by-element fashion.
In[45]:=
Range@10D ^ Range@10, 1, -1D
Out[45]=
81, 512, 6561, 16384, 15625, 7776, 2401, 512, 81, 10<
Vector-specific  operations  are  also  supported.  Some  of  the  more  advanced  opera-
tions  are  in  a  package  called  VectorAnalysis`,  including  CrossProduct,  Norm,  Div,
Grad, Curl, and about three dozen others. Use ?VectorAnalysis`* after loading the
package to see the full list.
In[47]:=
u = 8-1, 0.5, 1<; v = 81, -0.5, 1<;
In[48]:=
u.v
Out[48]=
-0.25
In[49]:=
Norm@uD
Out[49]=
1.5
In[50]:=
Orthogonalize@8u, v<D
Out[50]=
88-0.666667, 0.333333, 0.666667<, 80.596285, -0.298142, 0.745356<<
In[51]:=
Projection@u, vD
Out[51]=
8-0.111111, 0.0555556, -0.111111<
CrossProduct is not built in, so you must load a special package.
In[52]:=
NeedsA"VectorAnalysis`"E
In[53]:=
CrossProduct@u, vD
Out[53]=
81., 2., 0.<
92 | Chapter 3: Data Structures 

Matrix and Tensor Functions
Vectors and matrices are familiar to most scientists, engineers, and software develop-
ers. A tensor is a generalization of vectors and matrices to higher dimensions. Specifi-
cally, a scalar is a zero-order tensor, a vector is a first-order tensor, and a matrix is a
second-order tensor. Tensors of order three and higher are represented in Mathemat-
ica as more deeply nested lists. Here is an example of a tensor of order four. Note
that the use of subscripting in this example is for illustration and is not integral to
the notion of a tensor from Mathematica’s point of view. (Mathematicians familiar
with tensor analysis know that subscripts and superscripts have very definite mean-
ing,  but  Mathematica  does  not  directly  support  those  notations  [although  some
third-party packages do].)
In[54]:=
Itensor4 = TableASubscriptAa, i, j, k, lE,
8i, 1, 2<, 9j, 1, 2=, 8k, 1, 2<, 8l, 1, 2<EM êê MatrixForm
Out[54]//MatrixForm=
a1,1,1,1
a1,1,1,2
a1,1,2,1
a1,1,2,2
a1,2,1,1
a1,2,1,2
a1,2,2,1
a1,2,2,2
a2,1,1,1
a2,1,1,2
a2,1,2,1
a2,1,2,2
a2,2,1,1
a2,2,1,2
a2,2,2,1
a2,2,2,2
In[55]:=
H*Using Part with a single index yields a third-order tensor.*L
tensor4@@1DD êê MatrixForm
Out[55]//MatrixForm=
a1,1,1,1
a1,1,1,2
a1,1,2,1
a1,1,2,2
a1,2,1,1
a1,2,1,2
a1,2,2,1
a1,2,2,2
In[56]:=
H*Using Part with two indices on a fourth-
order tensor yields a second-order tensor Hi.e., a matrixL.*L
tensor4@@1, 1DD êê MatrixForm
Out[56]//MatrixForm=
a1,1,1,1
a1,1,1,2
a1,1,2,1
a1,1,2,2
In[57]:=
H*Using Part with three indices yields a vector.*L
tensor4@@1, 1, 2DD
Out[57]=
9a1,1,2,1, a1,1,2,2=
In[58]:=
H*And all 4 indices gives a scalar.*L
tensor4@@2, 1, 2, 2DD
Out[58]=
a2,1,2,2
3.0 Introduction | 93

The recipes in this chapter deal mostly with vectors and matrices, but many opera-
tions in Mathematica are generalized to higher-order tensors. A very important func-
tion central to linear algebra is the Dot product. In linear algebra texts, this is often
referred to simply as vector multiplication. The Dot product only works if vectors and
matrices have compatible shapes.
In[59]:=
DotA8x1, x2, x3<, 9y1, y2, y3=E
Out[59]=
x1 y1 + x2 y2 + x3 y3
In[60]:=
ClearAx, yE;
DotATableASubscriptAx, i, jE, 8i, 1, 3<, 9j, 1, 2=E,
TableASubscriptAy, i, jE, 8i, 1, 2<, 9j, 1, 3=EE êê MatrixForm
Out[61]//MatrixForm=
x1,1 y1,1 + x1,2 y2,1
x1,1 y1,2 + x1,2 y2,2
x1,1 y1,3 + x1,2 y2,3
x2,1 y1,1 + x2,2 y2,1
x2,1 y1,2 + x2,2 y2,2
x2,1 y1,3 + x2,2 y2,3
x3,1 y1,1 + x3,2 y2,1
x3,1 y1,2 + x3,2 y2,2
x3,1 y1,3 + x3,2 y2,3
Inner[f,m1,m2,g] is a function that generalizes Dot by allowing a function f to take
the  place  of  multiplication  and  g  to  take  the  place  of  addition.  Here  are  some
examples.
In[62]:=
InnerAList, TableAi^j, 8i, 1, 4<, 9j, 1, 3=E,
TableAj! i!, 8i, 1, 3<, 9j, 1, 4=E, MaxE êê MatrixForm
Out[62]//MatrixForm=
6
12 36 144
8
12 36 144
27 27 36 144
64 64 64 144
In[63]:=
InnerAList, TableAi + j, 8i, 1, 3<, 9j, 1, 2=E,
TableAi*j, 8i, 1, 2<, 9j, 1, 3=E, ListE êê MatrixForm
Out[63]//MatrixForm=
2 1
3 2
2 2
3 4
2 3
3 6
3 1
4 2
3 2
4 4
3 3
4 6
4 1
5 2
4 2
5 4
4 3
5 6
94 | Chapter 3: Data Structures 

In[64]:=
InnerAList, TableAi*j, 8i, 1, 2<, 9j, 1, 2=E,
TableAi + j, 8i, 1, 2<, 9j, 1, 2=E, JoinE êê MatrixForm
Out[64]//MatrixForm=
1
2
2
3
1
3
2
4
2
2
4
3
2
3
4
4
In[65]:=
InnerAAnd, TableAi < j, 8i, 1, 3<, 9j, 1, 3=E,
TableAj < i, 8i, 1, 3<, 9j, 1, 3=E, OrE êê MatrixForm
Out[65]//MatrixForm=
True
True
False
True
True
False
False False False
3.1 Ensuring the Most Efficient Representation 
of Numerical Lists 
Problem
You are performing very mathematically intense computations on large vectors, ma-
trices, or higher-order tensors and want the most efficient representation in terms of
speed and space.
Solution
Make sure your lists are packed arrays by not mixing numerical types. This means ar-
rays of integers should work exclusively in integers or exclusively in machine preci-
sion floating point. Use of uniform types is necessary but not sufficient for getting
packed arrays. Mathematica tries to automatically use packed arrays when generat-
ing large lists of numbers, but sometimes subtle coding differences prevent it from
packing the result.
Here are two very similar pieces of code, but the first generates an unpacked
representation and the second generates a packed one.
In[66]:=
array1 = N@Table@i * Pi, 8i, 0, 500 000<DD;
Developer`PackedArrayQAarray1E
Out[67]=
False
3.1 Ensuring the Most Efficient Representation of Numerical Lists | 95

In[68]:=
array2 = Table@i * Pi, 8i, 0.0, 500 000.0<D;
Developer`PackedArrayQAarray2E
Out[69]=
True
The difference is that the first Table generates a table in symbolic form and then con-
verts it to real numbers with N. So, although the final array meets the uniform criteria,
N will not pack it. In the second version, I force Table to create a list of real numbers
right off the bat by using real bounds for the index i. This makes N unnecessary and
causes Table to return a packed result.
Discussion
To get some insight into the superiority of packed arrays, we can ask Mathematica
to tell us the size of each array from the solution.
In[70]:=
GridA98"", "size", "per elem"<,
9"array1", ByteCountAarray1E, NAByteCountAarray1Eë LengthAarray1EE=,
9"array2", ByteCountAarray2E, NAByteCountAarray2Eë LengthAarray2EE==,
Alignment Ø Right, Frame Ø AllE
Out[70]=
size per elem
array1
12000056
24.0001
array2
4000132
8.00025
As you can see, the space saved is considerable. Essentially, packed is giving you the
equivalent of a C or Fortran array. Space savings is not the only reason to work with
packed arrays. Many operations are considerably faster as well. Here you see that
multiplication of packed arrays is an order of magnitude faster than unpacked! 
In[71]:=
MeanüTableATimingAarray1*array2E@@1DD, 8100<E
Out[71]=
0.0909364
In[72]:=
MeanüTableATimingAarray2*array2E@@1DD, 8100<E
Out[72]=
0.00625822
When you can get an order of magnitude improvement, it is a good idea to take it,
because life is short!
The  Developer` package has a function to pack an unpacked array, although it is
preferable to alter your coding style as we’ve discussed here to get packed arrays.
In[73]:=
array1 = Developer`ToPackedArrayAarray1E;
Developer`PackedArrayQAarray1E
Out[74]=
True
96 | Chapter 3: Data Structures 

If you have a very large packed array and assign a value to one of the
elements  that  differ  from  the  packed  type,  this  assignment  will  be
expensive relative to a normal assignment. Mathematica will be forced
to copy the entire array into unpacked form before the assignment can
be made. 
See Also
The  Developer`  package  also  has  a  function  Developer`FromPackedArray  for
converting  a  packed  form  back  to  the  normal  representation.  Evaluating
?"Developer`*" allows you to peruse all the functions in this package, but many are
undocumented. 
3.2 Sorting Lists
Problem
You need to sort a list based on standard ordering (Less) or a custom-ordering rela-
tion. One common reason for sorting is to enable binary search.
Solution
Use Sort or SortBy, depending on how the ordering relation is specified. By default,
Sort uses less than (<) to order elements. 
In[76]:=
list = RandomInteger@8-100, 100<, 10D;
In[77]:=
Sort@listD
Out[77]=
8-73, -50, -45, -43, -20, 2, 42, 50, 66, 84<
In[78]:=
Sort@list, GreaterD
Out[78]=
884, 66, 50, 42, 2, -20, -43, -45, -50, -73<
SortBy does not use an ordering relation, but rather uses a function whose output is
passed to Less.
In[79]:=
SortBy@list, AbsD
Out[79]=
82, -20, 42, -43, -45, -50, 50, 66, -73, 84<
Discussion
If you need to sort lists containing objects more complicated than scalars, you
will need to be comfortable with expressing the order relation function. Here
are some examples.
3.2 Sorting Lists | 97

In[80]:=
data = 9
8"21 Mar 2007 14:34:30", 10.1, 12.7, 13.3<,
8"21 Jun 2005 10:19:30", 10.3, 11.7, 11.7<,
9"21 Aug 2006 15:34:01", 11.7, 16.8, 8.6=,
9"21 Aug 2006 09:34:00", 11.9, 16.5, 8.6=
=;
H*Sort the data by the time entry,
which must be converted to an absolute time to be properly ordered.*L
SortAdata,
LessAAbsoluteTimeA9Ò1@@1DD, 9"Day", "MonthNameShort", "Year", "Time"==E,
AbsoluteTimeA9Ò2@@1DD,
9"Day", "MonthNameShort", "Year", "Time"==EE &E êê TableForm
Out[81]//TableForm=
21 Jun 2005 10:19:30 10.3 11.7 11.7
21 Aug 2006 09:34:00 11.9 16.5 8.6
21 Aug 2006 15:34:01 11.7 16.8 8.6
21 Mar 2007 14:34:30 10.1 12.7 13.3
For practical sorting, you will never need to look beyond Sort, because it is both fast
and flexible. However, if you are interested in sorting from an algorithmic perspec-
tive,  Mathematica  also  has  a  package  called  Combinatorica`,  which  contains  some
sorting routines that use specific algorithms (SelectionSort, HeapSort). 
In[82]:=
Needs@"Combinatorica`"D
In[83]:=
SelectionSort@list, LessD
Out[83]=
8-73, -50, -45, -43, -20, 2, 42, 50, 66, 84<
Of course, there is probably no practical reason to use SelectionSort since its asymp-
totic behavior is O(n^2), whereas Sort uses a O(n log n) algorithm. You can count
the number of comparisons each sort makes using a custom comparison function.
The framed number is the comparison count.
In[84]:=
H*The sorted list and count of comparisons with Sort*L
Block@8count = 0<, 8Sort@list, Hcount++; Less@Ò1, Ò2DL &D, Framed@countD<D
Out[84]=
:8-73, -50, -45, -43, -20, 2, 42, 50, 66, 84<,
26 >
In[85]:=
H*Comparisons consistent with n log n*L
LogA2.0, Length@listDE * Length@listD
Out[85]=
33.2193
98 | Chapter 3: Data Structures 

In[86]:=
H*The sorted list and count of comparisons
with SelectionSort. Roughly twice the comparisons*L
Block@8count = 0<,
8SelectionSort@list, Hcount++; Less@Ò1, Ò2DL &D, Framed@countD<D
Out[86]=
:8-73, -50, -45, -43, -20, 2, 42, 50, 66, 84<,
55 >
In[87]:=
H*Although better than worst case*L
Length@listD^2
Out[87]=
100
Heap  sort  is  O(n  log  n),  but  the  Combinatorica`  implementation  is  somewhat  
crippled because the ordering operation cannot be customized. 
In[88]:=
HeapSort@listD
Out[88]=
8-73, -50, -45, -43, -20, 2, 42, 50, 66, 84<
If you are keen to do this experiment with HeapSort, you can easily make a customi-
zable version, since the source code is available. 
In[89]:=
genericHeapSort@8<, _D := 8<
genericHeapSortAp_List, ordering_E :=
ModuleA9heap = genericHeapifyAp, orderingE, min=,
AppendATableAmin = First@heapD; heap@@1DD = heap@@nDD;
heap = genericHeapifyADrop@heap, -1D, 1, orderingE; min,
9n, Length@pD, 2, -1=E, Max@heapDEE ê; Length@pD > 0
H*HeapSort is implemented in terms of a function Heapify,
which we must customize to inject our ordering.*L
genericHeapifyAp_List, ordering_E :=
ModuleA9j, heap = p=, DoAheap = genericHeapifyAheap, j, orderingE,
9j, QuotientALength@pD, 2E, 1, -1=E; heapE
genericHeapifyAp_List, k_Integer, ordering_E :=
ModuleA9hp = p, i = k, l, n = Length@pD=,
WhileAHl = 2 iL § n, IfAl < n && ordering@hp@@l + 1DD, hp@@lDDD, l++E;
IfAordering@hp@@lDD, hp@@iDDD,
8hp@@iDD, hp@@lDD< = 8hp@@lDD, hp@@iDD<; i = l, i = n + 1E;E; hpE
In[93]:=
BlockA8count = 0<,
9genericHeapSort@list, Hcount++; Less@Ò1, Ò2DL &D, Framed@countD=E
Out[93]=
:8-73, -50, -45, -43, -20, 2, 42, 50, 66, 84<,
39 >
It  is  unfortunate  that  we  have  to  hack  HeapSort  to  give  it  customizable  ordering
function.  When  you  develop  your  own  general-purpose  functions,  it  pays  to
consider facilities that allow you and other users to customize the details while
3.2 Sorting Lists | 99

leaving  the  essential  algorithm  intact.  This  is  the  essence  of  what  is  called
generic programming. Chapter 2 has several recipes that demonstrate how to create
more generic functions. 
One application of sorting is performing efficient search. The Combinatorica` pack-
age provides the function BinarySearch, which requires a sorted list. BinarySearch re-
turns  the  index  of  the  first  occurrence  of  a  search  key,  if  found.  If  the  key  is  not
found, it returns index + 1/2, indicating that the key belongs between index and in-
dex + 1 if it were to be inserted.
In[94]:=
list2 = Range@1, 20, 2D
Out[94]=
81, 3, 5, 7, 9, 11, 13, 15, 17, 19<
In[95]:=
BinarySearch@list2, 7D
Out[95]=
4
In[96]:=
BinarySearch@list2, 6D
Out[96]=
7
2
In[97]:=
H*An example of how BinarySearch might be used to
conditionally insert new elements into a sorted list*L
value = 6 ;
pos = BinarySearch@list2, valueD;
IfAIntegerQ@posD, pos, pos = Ceiling@posD;
list2 = Insert@list2, value, posD; posE;
list2
Out[100]=
81, 3, 5, 6, 7, 9, 11, 13, 15, 17, 19<
See Also
Recipe  3.3  discusses  how  to  determine  sorted  order  without  rearranging  the  ele-
ments of the list. 
A good overview of various sorting algorithms can be found at http://bit.ly/2bRckv.
3.3 Determining Order Without Sorting
Problem
You need to know how the elements of a list are ordered without actually sorting
them. This may be because it is too expensive to keep multiple copies of the data in
various orderings.
100 | Chapter 3: Data Structures 

Solution
Use Ordering to get a list of offsets to the elements in the order they would appear if
sorted.
In[101]:=
unsorted = RandomInteger@890, 99<, 10D
Out[101]=
898, 90, 91, 98, 98, 91, 99, 99, 97, 96<
In[102]:=
Ordering@unsortedD
Out[102]=
82, 3, 6, 10, 9, 1, 4, 5, 7, 8<
Discussion
Ordering has two variations. The first takes an integer that limits how many posi-
tions are returned. If you specify n, then the first n are returned; if you specify -n, the
last  n  are  returned.  This  option  makes  Ordering  more  useful  than  Sort  when  you
don’t need the entire list sorted.
In[103]:=
Ordering@unsorted, 3D
Out[103]=
82, 3, 6<
In[104]:=
Ordering@unsorted, -3D
Out[104]=
85, 7, 8<
The second variation takes both an integer and an ordering relation.
In[105]:=
OrderingAunsorted, Length@unsortedD, GreaterE
Out[105]=
88, 7, 5, 4, 1, 9, 10, 6, 3, 2<
Given an ordering, it is easy to create a sorted version of the list.
In[106]:=
unsortedAAOrdering@unsortedDEE
Out[106]=
890, 91, 91, 96, 97, 98, 98, 98, 99, 99<
Unfortunately, Ordering does as many comparisons as a full sort even if you only
want the first few orderings. 
In[107]:=
BlockA8count = 0<,
9Ordering@unsorted, 3, Hcount++; Less@Ò1, Ò2DL &D, Framed@countD=E
Out[107]=
:82, 6, 3<,
23 >
In[108]:=
BlockA8count = 0<,
9Ordering@unsorted, 6, Hcount++; Less@Ò1, Ò2DL &D, Framed@countD=E
Out[108]=
:82, 6, 3, 10, 9, 5<,
23 >
3.3 Determining Order Without Sorting | 101

A heap would be superior in such an application, but rolling your version of Order-
ing is unlikely to yield superior results due to optimizations that go beyond minimiz-
ing comparisons. After all, it takes Ordering less than a second to do its work on a
million integers on my relatively low-powered laptop.
In[109]:=
TimingAOrderingARandomInteger@81, 999 999<, 1 000 000D, 2EE
Out[109]=
80.255152, 8314075, 337366<<
See Also
Recipe 3.2 discusses sorting.
OrderedQ tests if a list is ordered, and Order compares two expressions, returning
|1 (Less), 0 (Equal), or 1 (Greater). 
3.4 Extracting the Diagonals of a Matrix 
Problem
You want to extract the diagonal, subdiagonal, superdiagonal, or antidiagonal of a
matrix.
Solution
In versions prior to Mathematica 6, use Tr with List as the combining function (the
default combining function of Tr is Plus).
In[110]:=
Hmatrix = 881, 2, 3<, 84, 5, 6<, 87, 8, 9<<L êê MatrixForm
Out[110]//MatrixForm=
1 2 3
4 5 6
7 8 9
In[111]:=
Tr@matrix, ListD
Out[111]=
81, 5, 9<
Mathematica 6 introduced the function Diagonal, which makes this recipe trivial.
In[112]:=
Diagonal@matrixD
Out[112]=
81, 5, 9<
102 | Chapter 3: Data Structures 

You can extract the antidiagonal using either of the following expressions:
In[113]:=
Diagonal@Map@Reverse, matrixDD
Out[113]=
83, 5, 7<
In[114]:=
Tr@Map@Reverse, matrixD, ListD
Out[114]=
83, 5, 7<
Discussion
The Diagonal function is more versatile than Tr in that it allows you to select off the
main diagonal by proving an index.
In[115]:=
Diagonal@matrix, 1D
Out[115]=
82, 6<
In[116]:=
Diagonal@matrix, -1D
Out[116]=
84, 8<
Although the solutions implementation of antidiagonal is simple, it is not the most
efficient: it reverses every row of the input matrix. An iterative solution using Table
is simple and fast.
In[117]:=
AntiDiagonal@matrix_D := ModuleA9len = Length@matrixD=,
Table@matrix@@i, len - i + 1DD, 8i, 1, len<DE
In[118]:=
bigMatrix = TableAi*j, 8i, 0, 5500<, 9j, 0, 5500=E;
In[119]:=
TimingAAntiDiagonalAbigMatrixEE@@1DD
Out[119]=
0.001839
In[120]:=
TimingADiagonalAMapAReverse, bigMatrixEEE@@1DD
Out[120]=
0.230145
It is always good to test a new version of an algorithm against one you already know
works.
In[121]:=
AntiDiagonalAbigMatrixE ã DiagonalAMapAReverse, bigMatrixEE
Out[121]=
True
3.5 Constructing Matrices of Specific Structure
Problem
You  want  to  construct  matrices  of  a  specific  structure  (e.g.,  diagonal,  identity,
tridiagonal).
3.5 Constructing Matrices of Specific Structure | 103

Solution
Mathematica has built-in matrix constructions for the most common kinds of matrices.
In[122]:=
IdentityMatrix@5D êê MatrixForm
Out[122]//MatrixForm=
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0
0 0 0 0 1
In[123]:=
DiagonalMatrixARange@4DE êê MatrixForm
Out[123]//MatrixForm=
1 0 0 0
0 2 0 0
0 0 3 0
0 0 0 4
Discussion
Although identity and diagonal matrices are quite common, there are other kinds of
matrices that arise frequently in practical problems. For example, problems involv-
ing coupled systems often give rise to tridiagonal matrices. SparseArray and Band are
perfect for this job. These are discussed in Recipe 3.8. Here, the use of Normal to con-
vert sparse form to list form is not essential because sparse arrays will play nicely
with regular ones.
In[124]:=
triDiagonal@sub_List, main_List, super_ListD ê;
9Length@subD, Length@superD= + 1 ã 9Length@mainD , Length@mainD= :=
ModuleA8<,
NormalASparseArrayA8Band@82, 1<D Ø sub,
Band@81, 2<D Ø super, Band@81, 1<D Ø main<, Length@mainDEEE
In[125]:=
triDiagonalAsub_?NumericQ, main_?NumericQ, super_?NumericQ, n_IntegerE :=
NormalASparseArray@
8Band@82, 1<D Ø sub, Band@81, 2<D Ø super, Band@81, 1<D Ø main<, nDE
In[126]:=
triDiagonal@8-1, -1, -1<, 82, 2, 2, 2<, 81, 1, 1<D êê MatrixForm
Out[126]//MatrixForm=
2
1
0
0
-1
2
1
0
0
-1
2
1
0
0
-1 2
104 | Chapter 3: Data Structures 

Tridiagonal matrices are always invertible.
In[127]:=
InverseAtriDiagonal@8-1, -1, -1<, 82, 2, 2, 2<, 81, 1, 1<DE
Out[127]=
::
12
29
, -
5
29
,
2
29
, -
1
29
>, :
5
29
,
10
29
, -
4
29
,
2
29
>,
:
2
29
,
4
29
,
10
29
, -
5
29
>, :
1
29
,
2
29
,
5
29
,
12
29
>>
There are also functions to transform a given matrix to another. Mathematica 7 in-
troduced  LowerTriangularize  and  UpperTriangularize  to  create  triangular  matrices
from a given matrix.
In[128]:=
WithA9m = Array@1 &, 84, 4<D=, RowA9LowerTriangularize@mD êê MatrixForm,
UpperTriangularize@mD êê MatrixForm=EE
Out[128]=
1 0 0 0
1 1 0 0
1 1 1 0
1 1 1 1
1 1 1 1
0 1 1 1
0 0 1 1
0 0 0 1
These functions take an optional second parameter k, where positive k refers to sub-
diagonals above the main diagonal and negative k refers to subdiagonals below the
main diagonal. This points to another way to arrive at a tridiagonal matrix from a
given or synthesized matrix. 
In[129]:=
UpperTriangularizeA
LowerTriangularizeAArray@Ò &, 84, 4<D, 1E, -1E êê MatrixForm
Out[129]//MatrixForm=
1 1 0 0
2 2 2 0
0 3 3 3
0 0 4 4
See Also
Certain important transformation matrices are accommodated by ScalingMatrix,
RotationMatrix, and ReflectionMatrix. See Recipe 2.11 for a usage example.
3.6 Constructing Permutation and Shift Matrices
Problem
You want to construct a matrix that will permute or shift the rows or columns of an
input matrix.
3.6 Constructing Permutation and Shift Matrices | 105

Solution
A permutation matrix is a permutation of the identity matrix. It is used to permute
either the rows or columns of another matrix.
In[130]:=
permutationMatrix@list_D := IdentityMatrixALength@listDE@@listDD
In[131]:=
Im1 = TableA2 i + j, 8i, 1, 3<, 9j, 1, 3=EM êê MatrixForm
Out[131]//MatrixForm=
3 4 5
5 6 7
7 8 9
In[132]:=
H*Create a permutation matrix that
permutes the second and first row or column.*L
Hp1 = permutationMatrix@82, 1, 3<DL êê MatrixForm
Out[132]//MatrixForm=
0 1 0
1 0 0
0 0 1
In[133]:=
Hm1p1 = Dot@m1, p1DL êê MatrixForm H*Permute columns.*L
Out[133]//MatrixForm=
4 3 5
6 5 7
8 7 9
In[134]:=
Hp1m1 = Dot@p1, m1DL êê MatrixForm H*Permute rows.*L
Out[134]//MatrixForm=
5 6 7
3 4 5
7 8 9
Whereas a permutation matrix permutes rows or columns, a shift matrix shifts rows
or columns, replacing the empty elements with zeros. A shift matrix is simply a ma-
trix with 1s on the superdiagonal or subdiagonal and 0s everywhere else. This can
easily be constructed using the DiagonalMatrix function. 
In[135]:=
shiftMatrix@n_, dir_D := DiagonalMatrix@Table@1, 8n - Abs@dirD<D, dirD
In[136]:=
DotAshiftMatrix@4, 2D, TableA1, 8i, 1, 4<, 9j, 1, 4=EE êê MatrixForm
Out[136]//MatrixForm=
1 1 1 1
1 1 1 1
0 0 0 0
0 0 0 0
106 | Chapter 3: Data Structures 

In[137]:=
H*Shift columns right.*L
Dot@m1, shiftMatrix@3, 1DD êê MatrixForm
Out[137]//MatrixForm=
0 3 4
0 5 6
0 7 8
In[138]:=
H*Shift columns left.*L
Dot@m1, shiftMatrix@3, -1DD êê MatrixForm
Out[138]//MatrixForm=
4 5 0
6 7 0
8 9 0
In[139]:=
H*Shift rows up.*L
Dot@ shiftMatrix@3, 1D, m1D êê MatrixForm
Out[139]//MatrixForm=
5 6 7
7 8 9
0 0 0
In[140]:=
H*Shift rows down.*L
Dot@ shiftMatrix@3, -1D, m1D êê MatrixForm
Out[140]//MatrixForm=
0 0 0
3 4 5
5 6 7
Discussion
A generalized permutation matrix has the same zero entries as the corresponding 
permutation matrix, but the nonzero entries can have values other than 1. 
In[141]:=
generalizedPermutationMatrix@values_List, perm_ListD :=
DotADiagonalMatrix@valuesD, permutationMatrix@permDE
In[142]:=
generalizedPermutationMatrix@83, -1, 4<, 82, 3, 1<D êê MatrixForm
Out[142]//MatrixForm=
0 3
0
0 0 -1
4 0
0
You can easily enumerate all n! permutation matrices of size n. 
In[143]:=
allPermutationMatrices@n_D :=
permutationMatrix@ÒD & êü PermutationsARange@nDE
3.6 Constructing Permutation and Shift Matrices | 107

In[144]:=
Grid@Partition@MatrixForm êü allPermutationMatrices@4D, 6DD
Out[144]=
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0
1 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1
1 0 0 0
0 0 1 0
0 0 0 1
0 1 0 0
1 0 0 0
0 0 0 1
0 1 0 0
0 0 1 0
1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
0 1 0 0
1 0 0 0
0 0 1 0
0 0 0 1
0 1 0 0
1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
0 0 1 0
1 0 0 0
0 0 0 1
0 1 0 0
0 0 1 0
0 0 0 1
1 0 0 0
0 1 0 0
0 0 0 1
1 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1
0 0 1 0
1 0 0 0
0 0 1 0
1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0
1 0 0 0
0 0 0 1
0 1 0 0
0 0 1 0
0 1 0 0
1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
0 0 0 1
1 0 0 0
0 0 1 0
0 0 0 1
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
0 1 0 0
1 0 0 0
0 0 0 1
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
1 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1
0 1 0 0
1 0 0 0
0 0 1 0
0 0 0 1
0 1 0 0
0 0 1 0
1 0 0 0
0 0 0 1
0 0 1 0
1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0
0 1 0 0
1 0 0 0
It is also easy to detect if a matrix is a row permutation of another matrix: simply re-
move  each  row  from  m1  that  matches  m2  and  see  if  you  are  left  with  no  rows.  Of
course, you must also check that the matrices are the same size. A check for column
permutation is just a check for row permutations on the transpose of each matrix.
In[145]:=
isRowPermutation@m1_, m2_D :=
Length@m1D ã Length@m2D && Fold@DeleteCases@Ò1, Ò2D &, m1, m2D ã 8<
isMatrixPermutation@m1_, m2_D := isRowPermutation@m1, m2D »»
isRowPermutation@Transpose@m1D, Transpose@m2DD
You can verify this on some test cases.
In[147]:=
H*Obviously a matrix is a permutation of itself.*L
isMatrixPermutation@m1, m1D
Out[147]=
True
In[148]:=
H*Test a row permutation.*L
isMatrixPermutation@m1, p1m1D
Out[148]=
True
In[149]:=
H*Test a column permutation.*L
isMatrixPermutation@m1, m1p1D
Out[149]=
True
In[150]:=
H*A matrix and its tranpose are not permutations unless symmetric.*L
isMatrixPermutation@m1, Transpose@m1DD
Out[150]=
False
You may be thinking that matrix permutations via linear algebra will only apply to
matrices of numbers, but recall that Mathematica is a symbolic language and,
108 | Chapter 3: Data Structures 

thus, not limited to numerical manipulation. Here we do a Dot product on a matrix
of graphics! 
In[151]:=
greenRook = ImportA
FileNameJoinA9NotebookDirectory@D, "..", "images", "greenRook.gif"=EE;
redSq = ImportAFileNameJoinA9NotebookDirectory@D,
"..", "images", "redSq.gif"=EE;
greenSq = ImportAFileNameJoinA9NotebookDirectory@D,
"..", "images", "greenSq.gif"=EE;
pieceAi_, j_E := WhichAi ã j, greenRook, OddQAi + jE,
redSq, True, greenSqE;
Iboard = TableApieceAi, jE, 8i, 1, 4<, 9j, 1, 4=EM êê MatrixForm
Out[155]//MatrixForm=
In[156]:=
Dot@board, permutationMatrix@82, 3, 1, 4<DD êê MatrixForm
Out[156]//MatrixForm=
This chess demo lacks some aesthetics (the squares move along with the rooks), but
it does illustrate the generality of the permutation matrix. 
3.6 Constructing Permutation and Shift Matrices | 109

3.7 Manipulating Rows and Columns of Matrices
Problem
You want to add, remove, or modify entire rows or columns of a matrix in place.
Solution
Many operations on lists (including higher-order lists such as matrices) do not
modify the input list but rather produce a new list with the change. For example,
Append[myList,10]  returns  a  list  with  10  appended  but  leaves  myList  untouched.
Sometimes you want to modify the actual value of the list associated with a symbol.
In[157]:=
H*Create a 5 x 5 zero matrix.*L
Hx = Table@0, 85<, 85<DL êê MatrixForm
Out[157]//MatrixForm=
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
In[158]:=
H*Set the second column to 81,2,3,4,5<.*L
x@@All, 2DD = Range@5D;
In[159]:=
x êê MatrixForm
Out[159]//MatrixForm=
0 1 0 0 0
0 2 0 0 0
0 3 0 0 0
0 4 0 0 0
0 5 0 0 0
In[160]:=
H*Set the third row to 3.*L
x@@3, AllDD = 3;
In[161]:=
x êê MatrixForm
Out[161]//MatrixForm=
0 1 0 0 0
0 2 0 0 0
3 3 3 3 3
0 4 0 0 0
0 5 0 0 0
In[162]:=
H*Set 3 x 3 interior to 9.*L
x@@2 ;; 4, 2 ;; 4DD = 9;
110 | Chapter 3: Data Structures 

In[163]:=
x êê MatrixForm
Out[163]//MatrixForm=
0 1 0 0 0
0 9 9 9 0
3 9 9 9 3
0 9 9 9 0
0 5 0 0 0
You may also want to add elements, rows, and columns.
In[164]:=
H*Add a row.*L
AppendToAx, Range@10, 14DE;
In[165]:=
x êê MatrixForm
Out[165]//MatrixForm=
0
1
0
0
0
0
9
9
9
0
3
9
9
9
3
0
9
9
9
0
0
5
0
0
0
10 11 12 13 14
In[166]:=
H*Add a column of 9s.*L
Do@AppendTo@x@@iDD, 9D, 8i, 1, 6<D
In[167]:=
x êê MatrixForm
Out[167]//MatrixForm=
0
1
0
0
0
9
0
9
9
9
0
9
3
9
9
9
3
9
0
9
9
9
0
9
0
5
0
0
0
9
10 11 12 13 14 9
Discussion
Destructive operations should generally be avoided because they can lead to annoy-
ing bugs. For one thing, they make code sensitive to evaluation order. This type of
code is harder to change. Further, you need to keep in mind that these operations
are being performed on symbols rather than lists. What does this mean? Let’s in-
spect the attributes of AppendTo to gain a bit of insight. 
In[168]:=
Attributes@AppendToD
Out[168]=
8HoldFirst, Protected<
3.7 Manipulating Rows and Columns of Matrices | 111

The relevant attribute here is HoldFirst. This means that the expression passed as
the first argument is passed in unevaluated form. This has implications when you
want to write your own functions that destructively change the value of a symbol.
Consider trying to implement your own AppendTo.
In[169]:=
ClearAllAmyAppendToE ;
myAppendTo@x_, val_D := x = Append@x, valD
In[171]:=
AttributesAmyAppendToE
Out[171]=
8<
In[172]:=
x = 8< ; myAppendTo@x, 10D
Set::shape : Lists 8< and 810< are not the same shape. à
Out[172]=
810<
In[173]:=
x
Out[173]=
8<
First  notice  that  this  generated  an  error  message  and  that  x  did  not  change.
This occurred because x was evaluated before the call, and you ended up evaluating
AppendTo[List[], 10], which is illegal. You can remedy this by using HoldFirst.
In[174]:=
SetAttributesAmyAppendTo, 8HoldFirst<E
In[175]:=
myAppendTo@x, 10D
Out[175]=
810<
In[176]:=
x
Out[176]=
810<
Now it works. As a general rule, you need to use attributes HoldFirst, HoldRest, or
HoldAll, as appropriate, to pass expressions in unevaluated form to your own func-
tions. This is covered in Chapter 2, “Introduction,” on page 30, and in Recipe 2.2.
3.8 Using Sparse Arrays to Conserve Memory 
Problem
You need to work with very large arrays or matrices but most of the entries are dupli-
cates (typically 0). 
112 | Chapter 3: Data Structures 

Solution
Mathematica has direct support for sparse arrays and higher-order tensors using the
SparseArray function. The sparse array is built from a rule-based specification that
maps positions to values.
In[177]:=
H*1000 µ 1000 sparse matrix*L
m1 = SparseArray@881, 1< Ø 1, 81000, 1000< Ø -1, 8500, 750< Ø 5<D
Out[177]=
SparseArray@<3>, 81000, 1000<D
You can also specify the positions and values in separate lists. Here is a sparse vector
using this technique.
In[178]:=
v1 = SparseArray@81, 3, 9, 81, 6561< Ø 85, 10, 15, 20, 25<D
Out[178]=
SparseArray@<5>, 86561<D
You can also convert a standard matrix to a sparse one.
In[179]:=
dense = DiagonalMatrixARange@1000DE;
In[180]:=
sparse = SparseArray@denseD
Out[180]=
SparseArray@<1000>, 81000, 1000<D
As you can see, the memory savings is considerable.
In[181]:=
ByteCount@denseD - ByteCount@sparseD
Out[181]=
3987416
In[182]:=
ClearAll@denseD
Discussion
Very large but sparsely populated matrices arise often in applications of linear alge-
bra. Mathematica provides excellent support for sparse arrays because most opera-
tions that are available for list-based matrices (or tensors in general) are available for
sparse array objects.
Mathematica  does  not  have  sparse  equivalents  of  the  convenience  functions
IdentityMatrix  and  DiagonalMatrix,  but  they  are  easy  to  synthesize  using  Band,
which specifies either the starting position of a diagonal entry or a range of positions
for a diagonal.
In[183]:=
H*100 x 100 identity matrix*L
identity = SparseArray@Band@81, 1<D Ø 1, 8100, 100<D
Out[183]=
SparseArray@<100>, 8100, 100<D
3.8 Using Sparse Arrays to Conserve Memory | 113

In[184]:=
H*100 x 100 diagonal matrix with
the values 81,2,3,...,100< on the diagonal*L
diagonal = SparseArrayABand@81, 1<D Ø Range@100D, 8100, 100<E
Out[184]=
SparseArray@<100>, 8100, 100<D
A general sparse diagonal function looks like this.
In[185]:=
sparseDiagonal@list_, k_D :=
SparseArrayABand@If@k > 0, 81, 1 + k<, 81 - k, 1<DD Ø list,
ILength@listD + Abs@kDM 81, 1<E
You can also produce sparse versions of the permutation matrices from Recipe 3.6. 
In[186]:=
sparsePermutationMatrix@list_D :=
SparseArrayABand@81, 1<D Ø 1, Length@listD 81, 1<E @@listDD
antiDiag = sparsePermutationMatrixARange@100, 1, -1DE
Out[187]=
SparseArray@<100>, 8100, 100<D
See Also
Recipe 3.5 showed how to use SparseArray and Band to create tridiagonal matrices.
3.9 Manipulating Deeply Nested Lists Using 
Functions with Level Specifications
Problem
You need to extract, delete, modify, or transform content deep inside a nested list.
Solution
A level specification (or levelspec) is the key for surgically manipulating lists that con-
tain many levels. Most of Mathematica’s functions that deal with lists have varia-
tions that take levelspecs. Position is one such function. Consider a list of integers
that has values nested up to eight levels.
In[188]:=
deep = 81, 82, 3, 4, 5, 81, 6, 1, 7<,
81, 88881, 8<, 1<, 81<<, 1<<, 1, 1, 1, 9, 10, 11<, 12<;
Depth@
deepD
Out[189]=
8
114 | Chapter 3: Data Structures 

In[190]:=
deep êê TreeForm
Out[190]//TreeForm=
List
1 List
2
3
4
5 List
1
6
1
7
List
1 List
List
List
List
1
8
1
List
1
1
1
1
1
9 10 11
12
If you use Position to search for 1, you get a list of all positions that have the value
1. You can verify this using Extract.
In[191]:=
Position@deep, 1D
Out[191]=
881<, 82, 5, 1<, 82, 5, 3<, 82, 6, 1<, 82, 6, 2, 1, 1, 1, 1<,
82, 6, 2, 1, 1, 2<, 82, 6, 2, 1, 2, 1<, 82, 6, 2, 2<, 82, 7<, 82, 8<, 82, 9<<
In[192]:=
Extract@deep, Position@deep, 1DD
Out[192]=
81, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1<
Suppose you do not want the 1s at every level. This is where levelspecs come in handy.
Use a single positive integer n to search at all levels up to and including n.
In[193]:=
H*Only search up to level two.*L
Position@deep, 1, 2D
Out[193]=
881<, 82, 7<, 82, 8<, 82, 9<<
Enclosing the level {n} in a list restricts search to that level.
In[194]:=
H*Only search at level two.*L
Position@deep, 1, 82<D
Out[194]=
882, 7<, 82, 8<, 82, 9<<
The list notation {n,m} restricts search to levels n through m, inclusively.
In[195]:=
H*Search at levels three through five.*L
Position@deep, 1, 83, 5<D
Out[195]=
882, 5, 1<, 82, 5, 3<, 82, 6, 1<, 82, 6, 2, 2<<
3.9 Manipulating Deeply Nested Lists Using Functions with Level Specifications | 115

Negative  level  specification  of  the  form  -n  looks  for  objects  that  themselves  have
depth n. 
In[196]:=
Position@deep, 1, -1D
Out[196]=
881<, 82, 5, 1<, 82, 5, 3<, 82, 6, 1<, 82, 6, 2, 1, 1, 1, 1<,
82, 6, 2, 1, 1, 2<, 82, 6, 2, 1, 2, 1<, 82, 6, 2, 2<, 82, 7<, 82, 8<, 82, 9<<
In[197]:=
H*See the discussion for why this is empty and must be empty.*L
Position@deep, 1, -2D
Out[197]=
8<
Discussion
We  used  Position  to  get  a  feel  for  level  specifications  because  it  is  easy  to  judge,
based on the length of each position sublist, the depth of each item found. However,
you may be surprised that the last example was empty. It is easy to mistakenly think
that negative level specification means searching from the bottom of the tree up be-
cause this seems analogous to the way negative indices work in functions like Part.
This is not the case. A negative level specification means only looking for items with
specified depth after dropping the minus sign. Any scalar (like 1) has depth 1, includ-
ing complex numbers. 
In[198]:=
8Depth@1D, Depth@3.7D, Depth@"foo"D, Depth@1 + 7 ID<
Out[198]=
81, 1, 1, 1<
From this, it follows that a scalar will never be found by using a negative depth value
less than |1.
Another important function for illustrating the use of level specifications is Level. Its
function is to retrieve all objects at the specified level(s). 
In[199]:=
Level@deep, 82<D
Out[199]=
82, 3, 4, 5, 81, 6, 1, 7<, 81, 88881, 8<, 1<, 81<<, 1<<, 1, 1, 1, 9, 10, 11<
Objects at level {2} may have a variety of depths.
In[200]:=
Depth êü Level@deep, 82<D
Out[200]=
81, 1, 1, 1, 2, 6, 1, 1, 1, 1, 1, 1<
Objects at level {-2} will only have a single depth by definition.
In[201]:=
Level@deep, 8-2<D
Out[201]=
881, 6, 1, 7<, 81, 8<, 81<<
In[202]:=
Depth êü Level@deep, 8-2<D
Out[202]=
82, 2, 2<
116 | Chapter 3: Data Structures 

A picture helps reinforce this. Note that each tree has two levels.
In[203]:=
GraphicsRowATreeForm êü Level@deep, 8-2<D, ImageSize Ø LargeE
Out[203]=
List
1
6
1
7
List
1
8
List
1
Note the difference between {-2}, meaning exactly depth 2, and -2, meaning depth
2 or more.
In[204]:=
Depth êü Level@deep, -2D
Out[204]=
82, 2, 3, 2, 4, 5, 6, 7<
Once  you  have  mastered  level  specifications,  the  functions  Apply,  Cases,  Delete,
DeleteCases, Extract, FreeQ, Level, Map, MapIndexed, MemberQ, Position, Replace,
and Scan take on more power and precision because they each have versions that use
levelspecs. 
Here are some examples in which we extract, delete, and modify the contents of a
deeply nested expression. This time we use an algebraic expression.
In[205]:=
ClearAx, yE;
deepAlg = 1 + Ix + yM - 2 x^2 + Ix + yM^3 + E^Ix + yM;
deepAlg = FactorAdeepAlg ^ deepAlg - deepAlgE
Out[207]=
I1 + ‰x+y + x - 2 x2 + x3 + y + 3 x2 y + 3 x y2 + y3M
I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
-2 x2
K-I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
2 x2
+
I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
‰x+y+x+y+Hx+yL3
O
In[208]:=
DepthAdeepAlgE
Out[208]=
8
In[209]:=
H*The three x's at levels two through three*L
ExtractAdeepAlg, PositionAdeepAlg, x, 82, 3<EE
Out[209]=
8x, x, x, x<
3.9 Manipulating Deeply Nested Lists Using Functions with Level Specifications | 117

In[210]:=
H*Delete the x's at two and three.*L
DeleteAdeepAlg, PositionAdeepAlg, x, 82, 3<EE
Out[210]=
I4 + ‰x+y - 2 x2 + y + 3 x2 y + 3 y2 + y3M
I1 + ‰x+y - 2 x2 + y + Ix + yM3M
-2 x2
K-I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
2 x2
+
I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
‰x+y+x+y+Hx+yL3
O
In[211]:=
H*Change those x's to z's.*L
ReplaceAdeepAlg, x Ø z, 82, 3<E
Out[211]=
K-I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
2 x2
+
I1 + ‰x+y + x - 2 x2 + y + Ix + yM3M
‰x+y+x+y+Hx+yL3
O
I1 + ‰x+y - 2 x2 + y + Ix + yM3 + zM
-2 x2
I1 + ‰x+y - 2 x2 + y + 3 x2 y + y3 + z + 3 y2 z + z3M
In[212]:=
H*Sure enough, there are now four z's.*L
Count@%, z, 82, 3<D
Out[212]=
4
In[213]:=
H*Replace any subexpression with depth three with z.*L
ReplaceAdeepAlg, _ Ø z, 8-3<E
Out[213]=
I1 + x + y + 3 zMz I1 + x + x3 + y + y3 + 4 zM
I-I1 + x + y + 3 zMz + I1 + x + y + 3 zMx+y+2 zM
In[214]:=
H*Square all subexpressions of depth three.*L
MapAÒ^2 &, deepAlg, 8-3<E
Out[214]=
I1 + ‰2 x+2 y + x + x3 + 4 x4 + y + 9 x4 y2 + y3 + 9 x2 y4M
I1 + ‰2 x+2 y + x + 4 x4 + y + Ix + yM6M
4 x4
-I1 + ‰2 x+2 y + x + 4 x4 + y + Ix + yM6M
4 x4
+
I1 + ‰2 x+2 y + x + 4 x4 + y + Ix + yM6M
‰2 x+2 y+x+y+Hx+yL6
See Also
Chapter 2, “Functional Programming,”  has  recipes  that  deal  with  the  specifics  of
Apply, Map, MapIndexed, and Scan.
Chapter 4, “Patterns,”  has  recipes  that  deal  with  the  specifics  of  Cases,  
DeleteCases, FreeQ, MemberQ, and Replace.
118 | Chapter 3: Data Structures 

3.10 Implementing Bit Vectors and Using 
Format to Customize Their Presentation
Problem
You want to manipulate a vector of bits in a space-efficient fashion. You also want
to give these vectors a concise default display format.
Solution
You can use Mathematica’s ability to represent arbitrarily large integers as a means
of implementing bit vectors. Using Mathematica’s UpValue convention (see Chapter 2,
“DownValues and UpValues,” page 27) you can make bit vectors adopt the familiar
interface used by lists. When you create custom data structures like this, you can
give them an output format that hides the details of their internal representation.
In[215]:=
H*Make a bit vector from a list of bit value.*L
makeBitVector@bits_ListD :=
bitvecAFromDigits@Reverse@bitsD, 2D, Length@bitsDE
H*Make a bit vector of a specified
length. Values are initialized to 0.*L
makeBitVector@l_: 32D := bitvec@0, lD
H*Set bit at index to 0 or 1.*L
setBitAbitvec@n_, l_D, index_Integer, 1E :=
ModuleA8n2 = BitSet@n, index - 1D<, bitvecAn2, MaxAl, BitLength@n2DEEE
setBitAbitvec@n_, l_D, index_Integer, 0E :=
bitvec@BitClear@n, index - 1D, lD
SetAttributes@setBitOf, HoldFirstD
setBitOfAname_Symbol, index_Integer, bit_ ê; bit === 0 »» bit === 1E :=
name = setBit@name, index, bitD
H*Get the first bit value.*L
bitvec ê: First@bitvec@n_, _DD := BitGet@n , 0D
H*Get the rest of the bits after the first as a new bit vector.*L
bitvec ê: Rest@bitvec@n_, l_DD := bitvec@Floor@nê2D, l - 1D
H*Get bit at index.*L
bitvec ê: PartAbitvec@n_, _D, index_IntegerE := BitGet@n , index - 1D
H*Get the length of the bit vector.*L
bitvec ê: Length@bitvec@n_, l_DD := l
bitvec ê: BitLength@bitvec@n_, l_DD := l
H*Perform bitwise AND of two vectors.*L
3.10 Implementing Bit Vectors and Using Format to Customize Their Presentation | 119

bitvec ê: BitAnd@bitvec@n1_, l1_D, bitvec@n2_, l2_DD :=
bitvec@BitAnd@n1, n2D, Max@l1, l2DD
H*Perform bitwise OR of two vectors.*L
bitvec ê: BitOr@bitvec@n1_, l1_D, bitvec@n2_, l2_DD :=
bitvec@BitAnd@n1, n2D, Max@l1, l2DD
H*Return the complement HNOTL of a bit vector.*L
bitvec ê: BitNot@bitvec@n_, l_DD :=
bitvec@BitAnd@BitNot@nD, 2^l - 1D, lD
H*Create a format to print bit vectors in an abbreviated fashion.*L
Format@bitvec@n_, l_DD :=
"bitvec"A"<" <> ToString@BitGet@n, 0DD <> "..." <>
ToString@BitGet@n, l - 1DD <> ">", lE
Here are some examples of usage.
In[229]:=
bv = makeBitVector@81, 0, 0, 0, 1<D
Out[229]=
bitvec@<1...1>, 5D
In[230]:=
bv@@2DD
Out[230]=
0
In[231]:=
bv = setBit@bv, 2, 1D
Out[231]=
bitvec@<1...1>, 5D
In[232]:=
bv@@2DD
Out[232]=
1
In[233]:=
bv = setBit@bv, 500, 1D
Out[233]=
bitvec@<1...1>, 500D
In[234]:=
bv2 = Rest@bvD
Out[234]=
bitvec@<1...1>, 499D
In[235]:=
bv3 = BitNot@makeBitVector@81, 0, 0, 0, 1<DD
Out[235]=
bitvec@<0...0>, 5D
In[236]:=
bv3@@1DD
Out[236]=
0
Discussion
Even if you have no immediate application for bit vectors, this recipe provides a les-
son in how you can create new types of objects and integrate them into Mathemat-
ica using familiar native functions. 
120 | Chapter 3: Data Structures 

See Also
See tutorial/DefiningOutputFormats in the Mathematica  documentation  for  more
details on Format.
3.11 Implementing Trees and Traversals 
Using Lists
Problem
You want to model tree data structures in Mathematica and operate on them with
standard tree-based algorithms. 
Solution
The simplest tree is the binary tree, and the simplest model of a binary tree in Mathe-
matica is a list consisting of the left branch, node value, and right branch. 
In[238]:=
H*MakeTree constructs either an empty
tree or a tree with only a root element.*L
makeTree@D := 8<
makeTree@value_D := 88<, value, 8<<
H*Functions for extracting the parts of a node*L
getTreeValue@tree_D := tree@@2DD
getTreeLeft@tree_D := tree@@1DD
getTreeRight@tree_D := tree@@3DD
H*We insert elements into a tree using < ordering relation.*L
insertTree@8<, value_D := 88<, value, 8<<
insertTree@tree_, value_D := IfAvalue < getTreeValue@treeD,
9insertTreeAgetTreeLeft@treeD, valueE,
getTreeValue@treeD, getTreeRight@treeD=,
9getTreeLeft@treeD, getTreeValue@treeD,
insertTreeAgetTreeRight@treeD, valueE=E
H*Given the above primitives, it is easy to define
some common algorithms.*L
listToTree@list_ListD := Fold@insertTree@Ò1, Ò2D &, makeTree@D, listD
H*A preorder traversal is also known as depth-first.*L
preorder@tree_D := Reap@preorder2@treeDD @@2, 1DD
preorder2@8<D := 8<
preorder2@tree_D := ModuleA8<, SowAgetTreeValue@treeDE;
preorder2AgetTreeLeft@treeDE;
preorder2AgetTreeRight@treeDEE
3.11 Implementing Trees and Traversals Using Lists | 121

postorder@tree_D := Reap@postorder2@treeDD@@2, 1DD
postorder2@8<D := 8<
postorder2@tree_D := ModuleA8<,
postorder2AgetTreeLeft@treeDE;
postorder2AgetTreeRight@treeDE;
SowAgetTreeValue@treeDEE
H*An inorder traversal returns the values in sorted order.*L
inorder@tree_D := Reap@inorder2@treeDD@@2, 1DD
inorder2@8<D := 8<
inorder2@tree_D := ModuleA8<,
inorder2AgetTreeLeft@treeDE;
SowAgetTreeValue@treeDE;
inorder2AgetTreeRight@treeDEE
H*A level order traversal is also known as breadth first.*L
levelorder@tree_D := Reap@levelorder2@8tree<DD@@2, 1DD
H*Breadth first is commonly implemented in terms of
a queue that keeps track of unprocessed levels. I model
the queue as a list.*L
levelorder2@8<D := 8< H*Stop on empty queue.*L
levelorder2@88<<D := 8< H*Stop on queue with empty tree.*L
levelorder2@queue_D := ModuleA9front = First@queueD,
queue2 = Rest@queueD, H*Pop front of queue.*L,
left, right=,
SowAgetTreeValue@frontDE; H*Visit node.*L
left = getTreeLeft@frontD;
right = getTreeRight@frontD;
queue2 = IfALength@leftD ã 0, queue2, Append@queue2, leftDE;
H*Append left if not empty.*L
queue2 = IfALengthArightE ã 0, queue2, AppendAqueue2, rightEE;
H*Append right if not empty.*L
levelorder2@queue2DE
In[259]:=
nodes = RandomInteger@81, 100<, 18D
Out[259]=
862, 97, 36, 82, 76, 84, 58, 32, 79, 16, 89, 15, 45, 72, 90, 32, 12, 9<
122 | Chapter 3: Data Structures 

In[260]:=
Htree = listToTree@nodesDL êê
TreeFormAÒ, PlotRangePadding Ø 0, ImageSize Ø 450E &
Out[260]//TreeForm=
List
List
List
List
List
List
List
8<
9
8<
12
8<
15
8<
16
8<
32
List
8<
32
8<
36
List
List
8<
45
8<
58
8<
62
List
List
List
List
8<
72
8<
76
List
8<
79
8<
82
List
8<
84
List
8<
89
List
8<
90
8<
97
8<
In[261]:=
preorder@treeD
Out[261]=
862, 36, 32, 16, 15, 12, 9, 32, 58, 45, 97, 82, 76, 72, 79, 84, 89, 90<
In[262]:=
postorder@treeD
Out[262]=
89, 12, 15, 16, 32, 32, 45, 58, 36, 72, 79, 76, 90, 89, 84, 82, 97, 62<
In[263]:=
inorder@treeD
Out[263]=
89, 12, 15, 16, 32, 32, 36, 45, 58, 62, 72, 76, 79, 82, 84, 89, 90, 97<
In[264]:=
levelorder@treeD
Out[264]=
862, 36, 97, 32, 58, 82, 16, 32, 45, 76, 84, 15, 72, 79, 89, 12, 90, 9<
Discussion
The tree implementation in the solution is a bit simplistic, but it is intended to illus-
trate basic concepts. One way to generalize the implementation is to allow a differ-
ent ordering function. It makes sense to keep the ordering with each instance of the
tree. For this, it is best to use Mathematica options, which are a standard conven-
tion for optional values. You need to redefine the functions for creating trees and ac-
cessing  their  parts,  but  once  you  do  that,  the  existing  algorithm  implementations
will still work.
3.11 Implementing Trees and Traversals Using Lists | 123

In[265]:=
ClearAllAmakeTree, getTreeValue,
getTreeLeft, getTreeRight, insertTree, listToTreeE;
H*Use the explicit head Tree to hold the
representation and the options.*L
makeTreeAopt : OptionsPatternAOrdering Ø LessEE := Tree@8<, optD
makeTreeAvalue_, opt : OptionsPatternAordering Ø LessEE :=
Tree@88<, value, 8<<, optD
H*Functions for extracting the parts of a node are now overloaded for top-
level Tree form.*L
getTreeValue@Tree@tree_, ___DD := getTreeValue@treeD
getTreeValue@tree_D := tree@@2DD
getTreeLeft@Tree@tree_, ___DD := getTreeLeft@treeD
getTreeLeft@tree_D := tree@@1DD
getTreeRight@Tree@tree_, ___DD := getTreeRight@treeD
getTreeRight@tree_D := tree@@3DD
H*Insert extracts the ordering option
using the replacement rule and passes it to
the function that implements the insert.*L
insertTree@Tree@tree_, opts_D, value_D :=
TreeAinsertTreeAtree, value, ordering ê. optsE, optsE
insertTree@8<, value_, _D := 88<, value, 8<<
insertTreeAtree_, value_, ordering_E :=
IfAorderingAvalue, getTreeValue@treeDE ,
9insertTreeAgetTreeLeft@treeD, value, orderingE,
getTreeValue@treeD, getTreeRight@treeD=,
9getTreeLeft@treeD, getTreeValue@treeD,
insertTreeAgetTreeRight@treeD, value, orderingE=E
listToTreeAlist_List, opt : OptionsPatternAOrdering Ø LessEE :=
Fold@insertTree@Ò1, Ò2D &, makeTree@optD, listD
In[278]:=
t1 = listToTreeARandomInteger@81, 100<, 20D, ordering Ø GreaterE;
inorder@t1D
Out[279]=
892, 92, 91, 84, 78, 71, 68, 56, 56, 54, 41, 39, 38, 35, 34, 32, 21, 16, 11, 2<
124 | Chapter 3: Data Structures 

Another  enhancement  is  to  generalize  the  so-called  visit  function  of  the  traversal  
algorithms. 
In[280]:=
ClearAll@inorder, inorder2D;
inorder@tree_, visit_ : Sow D := Flatten@ Reap@inorder2@tree, visitDDD
inorder2@8<, _D := 8<
inorder2@tree_, visit_D := ModuleA8<,
inorder2AgetTreeLeft@treeD, visitE;
visitAgetTreeValue@treeDE;
inorder2AgetTreeRight@treeD, visitEE
This allows the caller the option of not receiving all the nodes. For example, rather
than Sow, you can pass in a function that writes the values to a file or a filter as we do
here.
In[284]:=
inorder@t1, If@OddQ@ÒD, Sow@ÒD, ÒD &D
Out[284]=
891, 71, 41, 39, 35, 21, 11<
See Also
More information on trees and tree traversal can be found in any computer science
data structures book or at http://bit.ly/7xP6jQ.
3.12 Implementing Ordered Associative Lookup 
Using a Red-Black Tree
Problem
You need better-than-linear associative lookup and storage to increase performance
of a program. You also need the elements to remain ordered.
Solution
A red-black tree is a popular balanced tree algorithm used as the foundation for asso-
ciative data structures. To implement a red-black tree in Mathematica, you create a
representation of the tree and functions for creating, reading, updating, and deleting
(CRUD). This implementation will use a head rbTree containing a tree and an order-
ing relation. The tree is modeled as either an empty list or a quadruple consisting of
a color (red or black), a left subtree, an element, and a right subtree. By default, we
use the function Less as the ordering relation. Storing the ordering relation as part of
the tree allows for trees of varying element content.
3.12 Implementing Ordered Associative Lookup Using a Red-Black Tree | 125

In[285]:=
H*Make an empty tree with default ordering.*L
makeRBTree@D := rbTree@8<, LessD
H*Make an empty tree with a custom ordering.*L
makeRBTreeAordering_E := rbTreeA8<, orderingE
H*Make a tree with given root and ordering.*L
makeRBTreeA9color_, left_, elem_, right_=, ordering_E :=
rbTreeA9color, left, elem, right=, orderingE
Before we can do much with these trees, we need a method for inserting new el-
ements while keeping the tree well ordered and balanced. For this, we create a top-
level insert function implemented in terms of several low-level functions that main-
tain all the constraints necessary for a red-black tree.
In[288]:=
insertRBTreeArbTreeAstruct_, ordering_E, elem_E :=
makeRBTreeAmakeBlackAinsertRBTree2Astruct, elem, orderingEE, orderingE
In[289]:=
H*This implementation method does ordered
insertion and balancing of the tree representation.
Note: empty subtrees 8< are considered implicitly black.*L
insertRBTree2@8<, elem_, _D := 8red, 8<, elem, 8<<
insertRBTree2A9color_, left_, elem2_, right_=, elem1_, ordering_E :=
WhichAordering@elem1, elem2D,
balanceAcolor, insertRBTree2Aleft, elem1, orderingE, elem2, rightE,
ordering@elem2, elem1D,
balanceAcolor, left, elem2, insertRBTree2Aright, elem1, orderingEE,
True, 9color, left, elem2, right=E
In[291]:=
H*This is a helper that turns a node to black.*L
makeBlackA9color_, left_, elem_, right_=E := 9black, left, elem, right=
In[292]:=
H*Balancing is handled by a transformation function that
matches all red-black constraint violations
and transforms them into balanced versions.*L
balanceAblack, 9red, 9red, left1_, elem1_, right1_=, elem2_, right2_=,
elem3_, right3_E :=
9red, 9black, left1, elem1, right1=, elem2, 9black, right2, elem3, right3==
balanceAblack, 9red, left1_, elem1_, 9red, left2_, elem2_, right1_==,
elem3_, right2_E :=
9red, 8black, left1, elem1, left2<, elem2, 9black, left2, elem3, right2==
126 | Chapter 3: Data Structures 

balanceAblack, left1_, elem1_,
9red, 9red, left2_, elem2_, right1_=, elem3_, right2_=E :=
9red, 8black, left1, elem1, left2<, elem2,
9black, right1, elem3, right2==
balanceAblack, left1_, elem1_,
9red, left2_, elem2_, 9red, left3_, elem3_, right1_==E :=
9red, 8black, left1, elem1, left2<, elem2, 9black, left3, elem3, right1==
balanceAcolor_, left1_, elem1_, right1_E :=
9color, left1, elem1, right1=
List-to-tree  and  tree-to-list  conversions  are  very  convenient  operations  for  inter-
facing with the rest of Mathematica.
In[296]:=
H*Given a list create an rbTree of the elements.*L
listToRBTree@list_ListD :=
Fold@insertRBTree@Ò1, Ò2D &, makeRBTree@D, listD
listToRBTreeAlist_List, ordering_E :=
FoldAinsertRBTree@Ò1, Ò2D &, makeRBTreeAorderingE, listE
H*Given a tree convert to a list while retaining ordering.*L
rbTreeToList@rbTree@tree_, _DD :=
FlattenAtree ê. Hred
blackL Ø Sequence@D, InfinityE
rbTreeFind@rbTree@8<, _D, _D := 8<
rbTreeFindArbTreeAtree_, ordering_E, elem_E :=
rbTreeFind2Atree, elem, orderingE
rbTreeFind2A9color_, left_, elem2_, right_=, elem1_, ordering_E :=
WhichAordering@elem1, elem2D, rbTreeFind2Aleft, elem1, orderingE,
ordering@elem2, elem1D, rbTreeFind2Aright, elem1, orderingE,
True, 8elem2<E
rbTreeMax2@8_, _, elem_, 8<<D := elem
rbTreeMax2A9_, _, _, right_=E := rbTreeMax2ArightE
removeRBTreeArbTreeA8<, ordering_E, elem_E := rbTreeA8<, orderingE
removeRBTreeArbTreeAtree_, ordering_E, elem_E :=
makeRBTreeAmakeBlackAremoveRBTree2Atree, elem, orderingEE, orderingE
removeRBTree2@8<, _, _D := 8<
3.12 Implementing Ordered Associative Lookup Using a Red-Black Tree | 127

removeRBTree2A9color_, left_, elem2_, right_=, elem1_, ordering_E :=
WhichAordering@elem1, elem2D,
balanceAred, removeRBTree2Aleft, elem1, orderingE, elem2, rightE,
ordering@elem2, elem1D,
balanceAred, left, elem2, removeRBTree2Aright, elem1, orderingEE,
True, WhichAright == 8<, left,
left == 8<, right,
True, WithA8max = rbTreeMax2@leftD<,
balanceAred, removeRBTree2Aleft, max, orderingE, max, rightEEE
E
Discussion
There are several ways to approach a problem like this. One reasonable answer is to
implement  associative  lookup  outside  of  Mathematica  using  a  language  like  C++
and then use MathLink to access this functionality. Here we will take the approach
of implementing a red-black tree directly in Mathematica. 
A red-black tree implemented in C may typically be hundreds of lines of code, yet
we achieve an implementation in Mathematica with less than a hundred, including
comments.  How  is  this  possible?  The  main  idea  is  to  exploit  pattern  matching  as
much as possible. Note particularly the function balance. This function directly im-
plements the most tricky part of a red-black-tree implementation in a traditionally
procedural language by stating the balancing rules in a form that is very close to the
way the algorithm requirements might specify them. Let’s take one of the versions as
an example.
balance[black, {red, {red, left1_, elem1_, right1_}, elem2_, right2_}, elem3
_, right3_] := 
{red, {black, left1, elem1, right1}, elem2, {black, right2, elem3, right3}}
The above says: “If you find a black node (elem3) with a red left child (elem2) that
also has a red left child (elem1), then convert to a red node with two black children
(elem1 and elem3, in that order). This is a case where the code speaks more clearly
and precisely than any English translation. With a slight bit of editing, the code itself
translates into a graphical view of before and after. I can’t think of another general
programming language where you can code and visualize an algorithm with so little
added effort!
128 | Chapter 3: Data Structures 

In[309]:=
TreeFormA9black, 9red, 9red, left1, elem1, right1=, elem2, right2=,
elem3, right3= , ImageSize Ø MediumE
TreeFormA9red, 9black, left1, elem1, right1=, elem2,
9black, right2, elem3, right3==, ImageSize Ø 450E
Out[309]//TreeForm=
List
black
List
red
List
red
left1
elem1
right1
elem2
right2
elem3
right3
Out[310]//TreeForm=
List
red
List
black
left1
elem1
right1
elem2
List
black
right2
elem3
right3
See Also
A  solution  to  associative  lookup  that  is  more  in  the  spirit  of  Mathematica  can  be
found in Recipe 3.13.
This  recipe  was  inspired  by  the  book  Purely  Functional  Data  Structures  by  Chris
Okasaki  (Cambridge  University  Press),  in  which  Haskell  is  used  to  demonstrate
that data structures can be written under the constraints of a pure functional pro-
gramming language. 
Wikipedia provides a good basic explanation of and references to more sources for
red-black trees (http://bit.ly/3WEqrT). 
3.12 Implementing Ordered Associative Lookup Using a Red-Black Tree | 129

3.13 Exploiting Mathematica’s Built-In 
Associative Lookup 
Problem
You want to create a dictionary to associate keys with values, but you want Mathe-
matica to do most of the work.
Solution
Harness the same mechanism Mathematica uses to locate the downvalues of a sym-
bol to create the dictionary.
Here I outline the basic idea for the solution and defer the actual implementation to
the discussion. The idea is simply to exploit something that Mathematica must
already do well: look up a symbol’s downvalues. It must do this well because it is
central to Mathematica programming. Imagine you want to create a table of values
associating some U.S. zip codes with towns. A reasonable way to proceed is as follows:
In[311]:=
zipcode@11771D = 9"Oyster Bay", "Upper Brookville",
"East Norwhich", "Cove Neck", "Centere Island"=;
zipcode@11772D = 9"Patchogue", "North Patchogue", "East Patchogue"=;
H*And so on...*L
zipcode@11779D = 8"Ronkonkoma", "Lake Ronkonkoma"<;
Now, when your program needs to do a lookup, it can simply call the “function”
zipcode.
In[314]:=
WithA8zip = 11771<,
PrintA"The number of towns in ",
zip, " is ", Length@zipcode@zipDD, ";"E;E
The number of towns in 11 771 is 5.
This  is  so  obvious  that  few  regular  Mathematica  programmers  would  even  think
twice about doing this. However, this use case is static. Most associative data struc-
tures are dynamic. This is not a problem because you can also remove downvalues.
In[315]:=
zipcode@11779D =.
Now there is no longer an association to 11779. Mathematica indicates this by return-
ing the expression in unevaluated form.
In[316]:=
zipcode@11779D
Out[316]=
zipcode@11779D
130 | Chapter 3: Data Structures 

But this is still not enough. An associated data structure should also tell you all the
keys and all the values it knows. Again, Mathematica comes through.
In[317]:=
DownValues@zipcodeD
Out[317]=
9HoldPattern@zipcode@11771DD ß
9Oyster Bay, Upper Brookville, East Norwhich, Cove Neck, Centere Island=,
HoldPattern@zipcode@11772DD ß
9Patchogue, North Patchogue, East Patchogue==
So all the building blocks are present in the core of Mathematica to create a dynamic
dictionary-like  data  structure.  All  that  is  needed  is  the  creation  of  some  code  to
neatly tie these pieces together into a general utility. 
Discussion
The first function we need is a way to construct a dictionary. In the solution, we use
a symbol that makes sense for the problem at hand, but in a generic implementation
what symbol is used is not significant so long as it is unique. Luckily, Mathematica
has the function Unique to deliver the goods. We initialize the dictionary by creating
a downvalue that maps any value to the empty list. The symbol is wrapped up in the
head Dictionary and returned to the caller.
In[318]:=
makeDictionary@D :=
ModuleA8name<,
name = Unique@"dict"D ;
Evaluate@nameD@k_D := 8<;
Dictionary@nameD
E
You will also want a way to get rid of dictionaries and all their content. Remove does
the trick.
In[319]:=
destroyDictionaryADictionary@name_, ___DE :=
If@ValueQ@name@_DD, Remove@nameD; True, FalseD
Although we said that there is no need to know the symbol used internally, there is
no harm in providing a function to retrieve it. Further, our implementation will use
this function so that it is easier to change the internal representation in the future. 
In[320]:=
dictNameADictionary@name_, ___DE := name
The  most  important  function,  dictStore,  allows  the  association  of  a  value  with  a
key. We assume, as in the solution, that more than one value may be needed for a
given key, so we store values in a list and prepend new values as they are added. 
In[321]:=
dictStoreAdict_Dictionary, key_, value_E :=
ModuleA8d = dictName@dictD<, dAkeyE = PrependAdAkeyE, valueEE
3.13 Exploiting Mathematica’s Built-In Associative Lookup | 131

The  function  dictReplace  is  like  dictStore,  except  it  guarantees  value  is  unique.
That is, there are no duplicates of value, although there might be other values for
the key.
In[322]:=
dictReplaceAdict_Dictionary, key_, value_E :=
ModuleA8d = dictName@dictD<, dAkeyE = dAkeyE ‹ 8value<E
In  contrast,  the  function  dictRemove  ensures  that  there  are  no  instances  of  value  
associated with the key (although, again, there might be other values for the key).
In[323]:=
dictRemoveAdict_Dictionary, key_, value_E :=
ModuleA8d = dictName@dictD<, dAkeyE = ComplementAdAkeyE, 8value<EE
If you want all values removed, then use dictClear.
In[324]:=
dictClearADictionary@name_, ___DE :=
If@ValueQ@name@_DD, Clear@nameD; Evaluate@nameD@k_D := 8<; True, FalseD
Maintaining the dictionary is all well and good, but you also need to be able to re-
trieve  values.  The  function  dictLookup  is  the  easiest  to  implement  because  it  gets
Mathematica to do all the work by simply asking for the downvalue in the usual way.
In[325]:=
dictLookupADictionary@name_, ___D, key_E := nameAkeyE
Sometimes you might not care what the value is but rather if the key exists at all.
Here I use ValueQ, which returns true if the evaluation of an expression returns
something  different  than  the  expression  itself  (hence,  indicating  there  is  a
value). In this implementation, I don’t care that the value may be the empty list {}
because dictHasKeyQ is only intended to tell the caller that the key is present.
In[326]:=
dictHasKeyQADictionary@name_, ___D, key_E := ValueQAnameAkeyEE
This function tells you that the key is present but has no values.
In[327]:=
dictKeyEmptyQADictionary@name_, ___D, key_E := nameAkeyE === 8<
In some applications, you may want to know the set of all keys; dictKeys provides
that. It works by using DownValues, as shown in the solution, but transforms the re-
sults  to  extract  only  the  keys.  Most  is  used  to  exclude  the  special  downvalue
name[k_], which was created within makeDictionary. The use of HoldPattern follows
from the format that DownValues uses, as seen in the solution section. Here, Evaluate
is used because DownValues has the attribute HoldAll.
In[328]:=
dictKeysAdict_DictionaryE := Most@DownValues@Evaluate@dictName@dictDDDD ê.
HoldPattern@a_ ß _ListD ß aP1, 1T
Another  useful  capability  is  to  get  a  list  of  all  key  value  pairs;  dictKeyValuePairs
does that.
132 | Chapter 3: Data Structures 

In[329]:=
dictKeyValuePairsAdict_DictionaryE :=
Most@DownValues@Evaluate@dictName@dictDDDD ê.
HoldPattern@a_ ß values_ListD ß 8aP1, 1T, values<
Before I exercise this functionality, a few general points need to be made. 
You may be curious about the pattern Dictionary[name_, ___] since the representa-
tion of the dictionary, per makeDictionary, is clearly just Dictionary[name]. As you
probably already know (see Chapter 4 if necessary), ___ matches a sequence of zero
or  more  expressions.  Using  this  pattern  will  future  proof  the  functions  against
changes in the implementation. For example, I may want to enhance Dictionary to
take options that control aspects of its behavior (for example, whether duplicate val-
ues are allowed for a key or whether a key can have multiple values all together).
Keep this in mind when creating your own data structures. 
A  collection  of  functions  like  this  really  begs  to  be  organized  more  formally  as  a
Mathematica package. In fact, you can download such a package, with the source
code, at this book’s website, http://oreilly.com/catalog/9780596520991/. I cover pack-
ages in Recipe 18.4. 
Here is how I might code the zip codes example from the solution if I needed the full
set of create, read, update, and delete capabilities that Dictionary provides.
In[330]:=
zipcodes = makeDictionary@D;
dictStore@zipcodes, 11771, ÒD & êü
9"Oyster Bay",
"Upper Brookville", "East Norwhich", "Cove Neck", "Centere Island"=;
dictStore@zipcodes, 11772, ÒD & êü
9"Patchogue", "North Patchogue", "East Patchogue"=;
dictStore@zipcodes, 11779, ÒD & êü
8"Ronkonkoma", "Lake Ronkonkoma"<;
In[334]:=
dictLookup@zipcodes, 11771D
Out[334]=
9Centere Island, Cove Neck, East Norwhich, Upper Brookville, Oyster Bay=
In[335]:=
dictLookup@zipcodes, 99999D
Out[335]=
8<
Ask if a key is present.
In[336]:=
dictHasKeyQ@zipcodes, 11779D
Out[336]=
True
Get all the zip codes stored.
In[337]:=
dictKeys@zipcodesD
Out[337]=
811771, 11772, 11779<
In Recipe 3.12, “Red-Black Trees,” quite a bit more coding is required to get a
similar level of functionality. This recipe is relatively easy because it leverages one
3.13 Exploiting Mathematica’s Built-In Associative Lookup | 133

of Mathematica’s strengths. This is an important lesson when working with Mathe-
matica  (or  any  language).  Always  look  for  solutions  that  play  to  the  language’s
strengths rather than using hack solutions designed for other programming environ-
ments.  To  be  fair,  the  red-black-tree  implementation  has  features  that  would  be
more difficult to support in this recipe. Specifically, we could control the ordering of keys
with red-black tree, but here keys are ordered according to Mathematica’s conventions
(which are conveniently in line with the expectations one would have for a dictionary).
3.14 Constructing Graphs Using the 
Combinatorica` Package
Problem
You are solving a problem modeled as a graph and need to create that graph for use
with Combinatorica` package’s algorithms.
Solution
If your graph is almost complete, construct a complete graph and remove unwanted
edges.
In[338]:=
Needs@"Combinatorica`"D
In[339]:=
g1 = CompleteGraph@6D;
g1 = DeleteEdgesAg1, 881, 5<, 81, 3<<E;
ShowGraphAg1, VertexNumber Ø True, ImageSize Ø SmallE
Out[341]=
1
2
3
4
5
6
134 | Chapter 3: Data Structures 

If your graph is sparse, construct directly.
In[342]:=
ShowGraphAFromUnorderedPairs@881, 2<, 81, 4<, 82, 3<, 83, 6<, 84, 6<<D ,
VertexNumber Ø True, ImageSize Ø SmallE
Out[342]=
1
2
3
4
5
6
Use MakeGraph if your graph can be defined by a predicate.
In[343]:=
ShowGraphAMakeGraphARange@14D, ! CoprimeQ@Ò1, Ò2D && Ò1 ≠Ò2 &,
Type -> UndirectedE, VertexNumber Ø True,
VertexStyle Ø Directive@PointSize@0.01DD, ImageSize Ø SmallE
Out[343]=
1
2
3
4
5
6
7
8
9
10
11
12
13
14
3.14 Constructing Graphs Using the Combinatorica` Package | 135

Discussion
Graphs can also be constructed from combinations of existing graphs by using
GraphUnion, GraphIntersection, GraphDifference, GraphProduct, and GraphJoin. In the
examples given here, I always use two graphs, but the operations are generalized to
multiple graphs.
GraphUnion  always  creates  a  disjoint  graph  resulting  from  the  combination  of  the
graphs in the union.
In[344]:=
ShowGraph@GraphUnion@CompleteGraph@3D, CompleteGraph@3, 2DD,
VertexLabel Ø TrueD
Out[344]=
1
2
3
4
5
6
7
8
GraphJoin performs a union and then links up all the vertices from the correspond-
ing graphs.
In[345]:=
ShowGraph@GraphJoin@CompleteGraph@3D, CompleteGraph@3, 2DD,
VertexLabel Ø TrueD
Out[345]=
1
2
3
4
5
6
7
8
136 | Chapter 3: Data Structures 

GraphIntersection  works  only  on  graphs  with  the  same  number  of  vertices  and  
produces a graph where the input graphs have edges in common.
In[346]:=
g1 = DeleteEdge@CompleteGraph@5D, 81, 2<D;
g2 = DeleteEdge@CompleteGraph@5D, 82, 3<D;
ShowGraphArrayA9g1, g2, GraphIntersectionAg1, g2E=, VertexLabel Ø TrueE
Out[348]=
1
2
3
4
5
1
2
3
4
5
1
2
3
4
5
GraphDifference creates a graph with all the edges that are in the first graph but not
in the second.
In[349]:=
g1 = CompleteGraph@5D;
g2 = DeleteEdges@CompleteGraph@5D, 881, 2<, 82, 3<, 82, 5<, 84, 5<<D;
ShowGraphArrayA9g1, g2, GraphDifferenceAg1, g2E=, VertexLabel Ø TrueE
Out[351]=
1
2
3
4
5
1
2
3
4
5
1
2
3
4
GraphProduct creates a graph by injecting copies of the first graph into the second at
each vertex of the second and then connecting the vertices of the injected graphs.
Unlike a numerical product, this operation is not commutative, as demonstrated in
Out[354] on page 138.
3.14 Constructing Graphs Using the Combinatorica` Package | 137

In[352]:=
g1 = CompleteGraph@3D;
g2 = CompleteGraph@3, 2D;
ShowGraphArrayA99g1, g2=, 9GraphProductAg1, g2E, GraphProductAg2, g1E==,
VertexLabel Ø True, ImageSize Ø MediumE
Out[354]=
1
2
3
1
2
3
4
5
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Another  way  to  construct  graphs  is  from  alternate  representations,  such  as  adja-
cency  matrices  and  adjacency  lists.  Out[355]  on  page  139  shows  a  graph  constructed
from an adjacency matrix obtained from GraphData. Normal is used to convert Sparse-
Matrix, since Combinatorica does not recognize sparse-matrix representations.
138 | Chapter 3: Data Structures 

In[355]:=
ShowGraphAFromAdjacencyMatrixANormalA
GraphDataA"CubicalGraph", "AdjacencyMatrix"EEE, ImageSize Ø SmallE
Out[355]=
Combinatorica also supports directed graphs and graphs with weighted edges. Using
SetEdgeWeights alone  gives  random  real  weights  in  the  range  [0,1].  SetEdgeWeights
also accepts WeightingFunction and WeightRange options.  You  can  also  explicitly
specify the weights in a list, which will be assigned to the edges in the same order as
returned by the function Edges.
In[356]:=
SeedRandom@1D;
g1 = RandomGraphA5, 0.3, Type Ø DirectedE;
g1 = SetEdgeWeightsAg1,
WeightingFunction Ø RandomInteger, WeightRange Ø 81, 10<E;
g2 = MakeUndirectedAg1E;
H*The number of weights must match
the number of edges or you'll get garbage!*L
g2 = SetEdgeWeightsAg2, 81, 2, 3, 4, 5, 6, 7<E;
SetGraphOptionsAg2, Type Ø DirectedE;
GraphicsRowA9ShowGraphA
SetEdgeLabelsAg1, GetEdgeWeightsAg1EE, ImagePadding Ø 8840, 0<, 80, 0<<E,
ShowGraphASetEdgeLabelsAg2, GetEdgeWeightsAg2EE,
ImagePadding Ø 8840, 0<, 80, 0<<E=,
BaseStyle Ø 8FontSize Ø 10<, ImageSize Ø MediumE
3.14 Constructing Graphs Using the Combinatorica` Package | 139

Out[362]=
6
5
4
1
2
4
6
4
1
2
3
4
5
6
7
See Also
The  definitive  reference  to  Combinatorica  is  Computational  Discrete  Mathematics:
Combinatorics  and  Graph  Theory  with  Mathematica  by  Sriram  Pemmaraju  and
Steven Skiena (Cambridge University Press). This reference is essential if you intend
to use Combinatorica in a serious way, because the documentation that comes bun-
dled with Mathematica is very sparse.
Mathematica has an alternate graph package called GraphUtilities` that represents
graphs using lists of rules (e.g., {aØb, aØc, bØc}). There is a conversion func-
tion  to  Combinatorica`  graphs.  Search  for  GraphUtilities  in  the  Mathematica
documentation.
3.15 Using Graph Algorithms to Extract 
Information from Graphs
Problem
You want to test a graph for specific properties or find paths through a graph with
specific properties or which satisfy specific constraints.
Solution
There are many graph theoretic functions in the Combinatorica` package related to
shortest  paths,  network  flows,  connectivity,  planarity  testing,  topological  sorting,
and so on. The solutions and following discussion show a sampling of some of the
more popular graph algorithms. 
140 | Chapter 3: Data Structures 

Out[363]a  shows  a  graph  generated  from  a  complete  graph  with  select  edges  re-
moved. The graph in Out[363]b is the minimum spanning tree of Out[363]a,
and Out[363]c is the shortest path spanning tree. 
In[363]:=
ModuleA9g, edges=,
H*Start with a complete graph.*L
g = CompleteGraph@20D;
H*Generate some edges to remove.*L
9dummy, 9edges== = ReapA
DoAIfAModAj, iE < 7 , SowA9i, j=E, NullE, 8i, 1, 20<, 9j, i + 1, 15=EE;
Ig = DeleteEdgeAg, ÒEM & êü edges;
H*Weight the edges randomly.*L
SeedRandom@1D; H*Make random edge weights repeatable.*L
SetEdgeWeightsAgE;
H*Demonstrate MinimumSpanningTree and ShortestPathSpanningTree.*L
GraphicsRowA9ShowGraphAg, PlotLabel Ø "a"E,
ShowGraphAMinimumSpanningTreeAgE, VertexNumber Ø True, PlotLabel Ø "b"E,
ShowGraphAShortestPathSpanningTreeAg, 1E,
VertexNumber Ø True, PlotLabel Ø "c"E=, ImageSize Ø 450E
E
Out[363]=
a
1
2
3
4
5
6
7
8
9
0
11
12
13
14
15
16
17
18
19
20
b
1
2
3
4
5
6
7
8
9
0
11
12
13
14
15
16
17
18
19
20
c
Discussion
Properties  of  graphs  can  be  tested  using  a  variety  of  functions,  such  as  HamiltonianQ
(which  has  a  cycle  that  visits  each  vertex  once),  EulerianQ  (which  has  a  tour  that
traverses each edge once), AntisymmetricQ, ReflexiveQ, UndirectedQ, SelfLoopsQ, and
so on. There are over 40 such predicates in Combinatorica.
3.15 Using Graph Algorithms to Extract Information from Graphs | 141

In[364]:=
g1 = Hypercube@3D; g2 = CompleteGraph@4, 2D;
GraphicsRowA9ShowGraphAg1,
PlotLabel Ø "HamiltonianQ == " <> ToStringAHamiltonianQAg1EEE,
ShowGraphAg2, PlotLabel Ø "HamiltonianQ == " <>
ToStringAHamiltonianQAg2EEE=E
Out[365]=
HamiltonianQ == True
HamiltonianQ == False
In[366]:=
GraphicsRowA
9ShowGraphAg1, PlotLabel Ø "EulerianQ == " <> ToStringAEulerianQAg1EEE,
ShowGraphAg2, PlotLabel Ø "EulerianQ == " <> ToStringAEulerianQAg2EEE=E
Out[366]=
EulerianQ == False
EulerianQ == True
A directed graph with no cycles is called a directed acyclic graph (DAG). The transi-
tive closer of a DAG is the supergraph that adds directed edges from ancestors to
descendants.
In[367]:=
g = CompleteBinaryTree@7D;
e = ReverseAEdgesAgE, 82<E;
g = DeleteEdgesAMakeDirectedAgE, eE;
9AcyclicQAgE, TopologicalSortATransitiveClosureAgEE=
Out[370]=
8True, 81, 2, 3, 4, 5, 6, 7<<
142 | Chapter 3: Data Structures 

Out[371]  shows  the  tree  and  its  transitive  closure.  When  you  display  highly  con-
nected  graphs  (like  the  transitive  closure)  with  vertex  labels,  it  often  helps  to  use
opacity or font control to make sure vertex labels are not obscured by the edges.
In[371]:=
ModuleA8opts<,
opts =
SequenceAVertexLabel Ø True, BaseStyle Ø 9FontWeight Ø Bold, FontSize Ø 12=,
LabelStyle -> 9FontWeight Ø Medium=,
VertexStyle Ø Disk@0.005D, EdgeStyle -> Opacity@0.4DE;
GraphicsRowA
9ShowGraphAg, opts, PlotLabel Ø "Tree"E, ShowGraphATransitiveClosureAgE,
opts, PlotLabel Ø "TransitiveClosure"E=, ImageSize Ø 450EE
Out[371]=
See Also
See  Chapters  7  and  8  in  Computational  Discrete  Mathematics:  Combinatorics  and
Graph Theory with Mathematica by Sriram Pemmaraju and Steven Skiena.
3.15 Using Graph Algorithms to Extract Information from Graphs | 143


CHAPTER 4
Patterns and Rule-Based Programming
You are an obsession
I cannot sleep
I am your possession
Unopened at your feet
There’s no balance
No equality
Be still I will not accept defeat
I will have you
Yes, I will have you
I will find a way and I will have you
Like a butterfly
A wild butterly
I will collect you and capture you
Animotion, “Obsession”
4.0 Introduction
In Chapter 2, I argue that the functional style of programming is the preferred way
to solve problems in Mathematica. Although functions form much of the brawn,
pattern  matching  provides  the  brains.  In  fact,  functions  and  patterns  should  be
thought of as partners rather than competitors. By mastering both functional pro-
gramming and pattern-based programming, you will be able to use Mathematica to
its fullest potential. In fact, once you get the hang of pattern-based solutions they
may become a bit of an obsession.
If  you  have  done  any  programming  that  involves  text  manipulation,  you  have  no
doubt  been  exposed  to  regular  expressions,  a  concise  syntax  for  describing
patterns in text and manipulating text. Mathematica’s pattern syntax general-
izes  regular  expressions  to  the  domain  of  symbolic  processing,  which  allows
you  to  manipulate  arbitrary  symbolic  structures.  Patterns  and  rules  are  at  the
foundation of Mathematica’s symbolic processing capabilities. Symbolic integration,
145

differentiation,  equation  solving,  and  simplification  are  all  driven  by  the  pat-
tern primitives explained in this chapter. 
In  the  context  of  Mathematica,  a  pattern  is  an  expression  that  acts  as  a  template
against which other expressions can be matched. Some of the most useful patterns
contain variables that are bound to values as a result of the matching process. How-
ever, many times just knowing that a pattern matched is sufficient. Patterns are cen-
tral to specifying constraints in function arguments (e.g., Integer). They also play
roles in parsing, replacing, and counting, as we show in the recipes here. I defer the
role of patterns in string manipulation to Chapter 5. 
Rules build on patterns by specifying a mapping from a pattern to another expres-
sion that uses all or parts of the matched results. Rules pervade Mathematica, as you
will see in this chapter’s recipes and throughout this book. It’s safe to say that Mathe-
matica would be almost as crippled by the removal of rules as it would be by the re-
moval of the definition for Plus.
The rest of this introduction gives a brief overview of the most important primitives
associated with pattern matching. This will make the recipes a bit easier to follow if
you are new to these concepts. The recipes will explore the primitives more deeply,
and as usual, you should refer to the Mathematica documentation for subtle details
or clarification.
Blanks
The  most  basic  pattern  constructs  are  Blank[]  (_),  BlankSequence[]  (__),  and
BlankNullSequence[]  (___).  Blank[]  matches  any  expression  (_),  whereas  Blank[h]
(_h)  matches  any  expression  with  head  h.  BlankSequence  (__)  means  one  or  more;
BlankNullSequence means zero or more. Thus, ___h means zero or more expressions
with head h. Here MatchQ tests if a pattern matches an expression.
In[1]:=
MatchQ@a, _D
Out[1]=
True
In[2]:=
MatchQ@a@1D, _aD
Out[2]=
True
In[3]:=
H*By itself a has head Symbol.*L
MatchQ@a, _aD
Out[3]=
False
In[4]:=
MatchQ@81, 2<, _ListD
Out[4]=
True
146 | Chapter 4: Patterns and Rule-Based Programming

Blanks are more powerful when you can determine what they are matched against
so you can use the matched value for further processing. This is most often done us-
ing  a  prefix  symbol  (e.g.,  x_,  x__,  x___).  This  syntax  should  be  familiar  since  it  is
most  commonly  used  for  function  arguments.  However,  as  shown  in  this  recipe,
there are other contexts where binding symbols to matches comes into play.
In[5]:=
H*f1 will match when called with a single integer argument.*L
f1An_IntegerE := 8n<
H*f2 will match when called with one or more integers.*L
f2An__IntegerE := 8n<
H*f3 will match when called with zero or more integers.*L
f3An___IntegerE := 8n<
In[8]:=
f1@10D H*Match*L
Out[8]=
810<
In[9]:=
f1@10, 20D H*No match*L
Out[9]=
f1@10, 20D
In[10]:=
f2@10, 20D H*Match*L
Out[10]=
810, 20<
In[11]:=
f2@D H*No match*L
Out[11]=
f2@D
In[12]:=
f3@D H*Match*L
Out[12]=
8<
In[13]:=
f3@1, 2, "3"D H*No match*L
Out[13]=
f3@1, 2, 3D
Alternatives
Sometimes you need to construct patterns that match two or more forms. This can
be  done  using  Alternatives[p1,p2,...,pn]  or,  more  commonly,  using  vertical  bar
p1|p2|...|pn.
In[14]:=
Cases@8a, r, t, i, c, h, o, k, e<, a
e
i
o
uD
Out[14]=
8a, i, o, e<
This form can also appear in functions.
In[15]:=
Clear@fD
fAx_Complex
x_Real
x_IntegerE := x
4.0 Introduction | 147

In[17]:=
f êü 81, 3.14, 10 + 3 I, 1ê2, "foo"<
Out[17]=
:1, 3.14, 10 + 3 Â, fB
1
2
F, f@fooD>
Repeats
You use Repeated[p] or p.. to match one or more instances of some pattern p; you
use RepeatedNull[p] or p... to match zero or more instances of p. 
In[18]:=
Cases@880, 0, 0<, 80, 0, 1<, 80, 1, 0<, 80, 1, 1<,
81, 0, 0<, 81, 0, 1<, 81, 1, 0<, 81, 1, 1<<, 81 .., 0 ..<D
Out[18]=
881, 0, 0<, 81, 1, 0<<
In[19]:=
Cases@880, 0, 0<, 80, 0, 1<, 80, 1, 0<, 80, 1, 1<,
81, 0, 0<, 81, 0, 1<, 81, 1, 0<, 81, 1, 1<<, 81 ..., 0 ...<D
Out[19]=
880, 0, 0<, 81, 0, 0<, 81, 1, 0<, 81, 1, 1<<
PatternSequence
Repeated (p..) matches a very specific sequence, whereas BlankSequence (x__) is
very general. Sometimes you need to match a sequence of intermediate specificity.
PatternSequence was introduced in Mathematica 6 to help achieve this. The follow-
ing means f is a function that takes exactly two expressions.
In[20]:=
Clear@fD;
f@x : PatternSequence@_, _DD := Power@xD
In[22]:=
f@1D H*No match, too few*L
Out[22]=
f@1D
In[23]:=
f@2, 3D H*Match*L
Out[23]=
8
In[24]:=
f@2, 3, 4D H*No match, too many*L
Out[24]=
f@2, 3, 4D
Above, PatternSequence is not strictly necessary because f[x_,y_] := Power[x,y] is the
more conventional notation, but consider these more interesting use cases.
f[0 | PatternSequence[]] := 0 (*Matches either f[0] or f[]*)
f[p : PatternSequence[_,_],___] := {p} (*Names the first two elements of a
sequence and discards the rest*)
f[p : Longests@PatternSequence[a,b]..,rest___] (*The longest repeated
sequence of a,b*)
148 | Chapter 4: Patterns and Rule-Based Programming

Except
Often, it is easier to describe what you don’t want to match than what you do. In
these cases, you can use Except[p] to indicate matching for everything except what
matches p.
In[25]:=
Cases@8a, r, t, i, c, h, o, k, e<, Except@a
e
i
o
uDD
Out[25]=
8r, t, c, h, k<
Conditions and Pattern Tests
Conditions allow you to qualify a pattern with an additional test that the matching
element must pass for the match to succeed. This is a powerful construct because it
extends the degree of control over the matching process to any criteria Mathematica
can compute. 
In[26]:=
Cases@880, 0, 0<, 80, 0, 1<, 80, 1, 0<, 80, 1, 1<,
81, 0, 0<, 81, 0, 1<, 81, 1, 0<, 81, 1, 1<<, b__ ê; Total@bD > 1D
Out[26]=
880, 1, 1<, 81, 0, 1<, 81, 1, 0<, 81, 1, 1<<
Pattern tests also qualify the match, but they apply to the entire pattern and, there-
fore, don’t require pattern variables. The following lists all primes less than 250 + 2
of the form 2n± 1.
In[27]:=
Cases@Union@Flatten@Table@82^n - 1, 2^n + 1<, 8n, 0, 50<DDD, _?PrimeQD
Out[27]=
82, 3, 5, 7, 17, 31, 127, 257, 8191, 65 537, 131 071, 524 287, 2 147 483 647<
In[28]:=
Cases@Union@Flatten@Table@82^n - 1, 2^n + 1<, 8n, 0, 50<DDD,
_?HÒ1 < 127 &LD
Out[28]=
80, 1, 2, 3, 5, 7, 9, 15, 17, 31, 33, 63, 65<
A common mistake is to write the last example in one of two ways that
will not work:
In[29]:=
Cases[Union[Flatten[Table[{2^n - 1, 2^n + 1}, 
{n, 0, 50}]]], _?(#1 < 127)&] (*wrong!*)
Out[29]=
8<
In[30]:=
Cases[Union[Flatten[Table[{2^n - 1, 2^n + 1}, 
{n, 0, 50}]]], _?#1 < 127&]  (*wrong!*)
Out[30]=
8<
I  still  make  this  mistake  from  time  to  time,  and  it’s  frustrating;  pay
attention to those parentheses!
4.0 Introduction | 149

Rules
Rules take pattern matching to a new level of expressiveness, allowing you to per-
form transformations on matched expressions. Rules are an integral part of Mathe-
matica  internal  operations  and  are  used  in  expressing  solutions  to  equations  (see
Recipe 11.6), Options (see Recipe 2.17), and SparseArrays (see Recipe 3.8). Rules are
also the foundation of Mathematica’s symbolic abilities. With all these applications,
no serious user of Mathematica can afford to ignore them.
In[32]:=
H*Here we use a rule to replace all Hê.L
occurrences of x with the numerical value of Pi.*L
x - x^2 + x^3 - x ^4 + x^5 ê. x Ø N@PiD
Out[32]=
232.889
In[33]:=
H*Convert matching binary digit list to integers. You need
to use RuleDelayed since b is not defined until the match.*L
CasesA880, 0, 0<, 80, 0, 1<, 80, 1, 0<, 80, 1, 1<, 81, 0, 0<,
81, 0, 1<, 81, 1, 0<, 81, 1, 1<<, b : 81 .., 0 ..< ß FromDigits@b, 2DE
Out[33]=
84, 6<
A good way to gain insight into the difference between Ø and ß is to consider replace-
ments of a randomly generated number.
In[34]:=
H*With Rule, RandomInteger@D is evaluated
immediately so is constant while the rule is applied.*L
8x, x, x, x< ê. x Ø RandomInteger@80, 100<D
Out[34]=
82, 2, 2, 2<
In[35]:=
H*With RuleDelayed, it is newly evaluated on each match.*L
8x, x, x, x< ê. x ß RandomInteger@80, 100<D
Out[35]=
836, 37, 62, 23<
See Also
The tutorial of pattern primitives is a useful resource: tutorial/PatternsAndTransfor-
mationRules. Committing most of these to memory will strengthen your Mathemat-
ica skills considerably.
150 | Chapter 4: Patterns and Rule-Based Programming

4.1 Collecting Items That Match 
(or Don’t Match) a Pattern
Problem
You have a list or other expression and want to find values that match a pattern.
You may also want to transform the matching values as they are found.
Solution
Use Cases with a pattern to produce a list of expressions that match the pattern.
In[36]:=
list = 81, 1.2, "test", 3, 82<, x + 1<;
CasesAlist, _IntegerE
Out[37]=
81, 3<
Use  a  rule  to  transform  matches  to  other  forms.  Here  the  matched  integers  are
squared to produce the result. This added capability of Cases is extremely powerful.
In[38]:=
CasesAlist, x_Integer :> x^2E
Out[38]=
81, 9<
Wrapping the pattern in Except gives the nonmatching values.
In[39]:=
CasesA81, 1.2, "test", 3, 82<, x + 1<, ExceptA_IntegerEE
Out[39]=
81.2, test, 82<, 1 + x<
Note the use of colon syntax when capturing the value matched using Except with a
rule-based transformation. Here I use a rule that demonstrates that the type of ob-
ject produced does not need to be the same as the type that matched (i.e., all results
here are symbols).
In[40]:=
CasesA81, 1.2, "test", 3, 82<, x + 1<, x : ExceptA_IntegerE ß Head@xD E
Out[40]=
9Real, String, List, Plus=
Discussion
Cases will work with any expression, not just lists. However, you need to keep in
mind that Mathematica will rearrange the expression before the pattern is applied.
In[41]:=
CasesAx + y - z^2 + z^3 + x^5, _^_E
Out[41]=
9x5, z3=
4.1 Collecting Items That Match (or Don’t Match) a Pattern | 151

You may have expected z^2 or -z^2 to be selected; examining the FullForm of the ex-
pression will reveal why it was not. FullForm is your friend when it comes to debug-
ging pattern matching because that is the form that Mathematica sees.
In[42]:=
x + y - z^2 + z^3 + x^5 êê FullForm
Out[42]//FullForm=
PlusAx, Power@x, 5D, y, Times@-1, Power@z, 2DD, Power@z, 3DE
Providing a level specification will allow you to reach down deeper. Level specifica-
tions are discussed in Recipe 3.9.
In[43]:=
CasesAx + y - z^2 + z^3 + x^5, _^_, 2E
Out[43]=
9x5, z2, z3=
You can also limit the number of matches using an optional fourth argument.
In[44]:=
CasesAx + y - z^2 + z^3 + x^5, _^_, 2, 1E
Out[44]=
9x5=
Take into account the attributes Flat and Orderless when pattern matching. Flat
means nested expressions like Plus[a,Plus[b,c]] will be flattened; Orderless means
the operation is communicative, and Mathematica will account for this when pat-
tern matching.
In[45]:=
Attributes@PlusD
Out[45]=
9Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected=
Here we select every expression that contains b +, no matter its level or order in the
input expression.
In[46]:=
Cases@8a + b, a + c, b + a, a^2 + b, Plus@a, Plus@b, cDD<, b + _D
Out[46]=
9a + b, a + b, a2 + b, a + b + c=
Hold will suppress transformations due to Flat and Orderless, but the pattern itself
is still reordered from b + a to a + b. In Recipe 4.8 we show how to prevent this us-
ing HoldPattern.
In[47]:=
Cases@Hold@a + b, a + c, b + a, a^2 + b, Plus@a, Plus@b, cDDD, b + aD
Out[47]=
8a + b<
An alternative to Cases is the combination of Position and Extract. Here Position lo-
cates  the  items,  and  Extract  returns  them.  This  variation  would  be  more  helpful
than Cases, for example, if you needed to know the positions as well as the items,
since Cases does not provide positional information. By default, Position will search
every level, but you can restrict it with a levelspec as I do here.
152 | Chapter 4: Patterns and Rule-Based Programming

In[48]:=
list = 81, 1.2, "test", 3, 82<, x + 1<;
positions = PositionAlist, _Integer, 81<E;
Extract@list, positionsD
Out[50]=
81, 3<
One useful application of this idiom is matching on one list and extracting from a
parallel list.
In[51]:=
names = 8"Jane", "Jim", "Jeff", "Jessie", "Jezebel"<;
ages = 830, 20, 42, 16, 69< ;
ExtractAnames, PositionAages, x_ ê; x > 30EE
Out[53]=
8Jeff, Jezebel<
See Also
Recipe 3.9 also discusses Position and Extract in greater detail.
4.2 Excluding Items That Match 
(or Don’t Match) a Pattern
Problem
You have a list or other expression and want to exclude elements that do not match
a pattern.
Solution
DeleteCases has features similar to Cases but excludes elements that match.
In[54]:=
DeleteCasesA81, 1.2, "test", 3, 82<, x + 1<, _IntegerE
Out[54]=
81.2, test, 82<, 1 + x<
Wrapping the pattern in Except makes DeleteCases work like Cases for the non-
inverted pattern.
In[55]:=
DeleteCasesA81, 1.2, "test", 3, 82<, x + 1<, ExceptA_IntegerEE
Out[55]=
81, 3<
Cases and DeleteCases can be made to return the same result by using Except, but Cases
should be used when you want to transform the items that remain (see Recipe 4.1).
In[56]:=
DeleteCasesA81, 1.2, "test", 3, 82<, x + 1<, ExceptA_IntegerEE ã
CasesA81, 1.2, "test", 3, 82<, x + 1<, _IntegerE
Out[56]=
True
4.2 Excluding Items That Match (or Don’t Match) a Pattern | 153

Discussion
Most of the variations supported by Cases discussed in Recipe 4.1 apply to Delete-
Cases as well. In fact, given the existence of Except, one could argue that DeleteCases
is  redundant.  However,  given  the  context  of  the  problem,  usually  either  Cases  or
DeleteCases will be easier to understand compared to using pattern inversions. Also,
Except has some limitations since pattern variables like x_ can’t appear inside of an
Except.
Use  levelspecs  to  constrain  deletions  to  particular  portions  of  an  expression  tree.
Here is an expression that is nine levels deep.
In[57]:=
expr = ‡ Sqrt@x + Sqrt@xDD „x
Out[57]=
1
12
x + x K-3 + 2
x + 8 xO +
1
8
LogB1 + 2
x + 2
x + x F
In[58]:=
Depth@exprD
Out[58]=
9
You can delete roots at level four.
In[59]:=
DeleteCases@expr, Sqrt@_D, 84<D
Out[59]=
1
12
x H-1 + 8 xL +
1
8
LogB1 + 2
x + 2
x + x F
You can also delete roots at levels up to four.
In[60]:=
DeleteCases@expr, Sqrt@_D, 4D
Out[60]=
1
12
H-1 + 8 xL +
1
8
LogB1 + 2
x + 2
x + x F
Or, you delete roots at every level.
In[61]:=
DeleteCasesAexpr, Sqrt@_D, InfinityE
Out[61]=
1
12
H-1 + 8 xL +
Log@5D
8
Just  as  Extract  plus  Position  is  the  equivalent  of  Cases  (discussed  in  Recipe  4.1),
Delete plus Position is the equivalent for DeleteCases. Again, remember that Position
looks at all levels unless you restrict it.
154 | Chapter 4: Patterns and Rule-Based Programming

In[62]:=
list = 81, 1.2, "test", 3, 82<, x + 1<;
ColumnA9
DeleteAlist, PositionAlist, _IntegerEE,
DeleteAlist, PositionAlist, _Integer, 81<EE
=E
Out[63]=
81.2, test, 8<, x<
81.2, test, 82<, 1 + x<
This leads to a way to get the results of Cases and DeleteCases without executing the
pattern match twice.
In[64]:=
list = 81, 1.2, "test", 3, 82<, x + 1<;
positions = PositionAlist, _Integer, 81<E;
Column@8
Extract@list, positionsD,
Delete@list, positionsD
<D
Out[66]=
81, 3<
81.2, test, 82<, 1 + x<
4.3 Counting Items That Match a Pattern
Problem
You need to know the number of expressions that match a pattern by matching the
expressions themselves or their position.
Solution
Use Count to count matching elements in an expression or at particular levels in an
expression. Counting literal matches is perhaps the simplest application of Count.
In[67]:=
Count@8a, 1, a, 2, a, 3<, aD
Out[67]=
3
By default, Count works only on level one (levelspec {1}), but you can provide alter-
nate levelspecs as a third argument.
In[68]:=
expr = 1 + 3 I + 4 + I x + x^2 + yxx;
9 Count@expr, xD,
CountAexpr, x, InfinityE=
Out[69]=
80, 4<
4.3 Counting Items That Match a Pattern | 155

Count  can  be  derived  from  Position  or  Cases,  so  these  are  handy  if  you  need  the
matching items (or positions) in addition to the count.
In[70]:=
Length@Cases@8a, 1, a, 2, a, 3<, aDD
Out[70]=
3
In[71]:=
Length@Position@8a, 1, a, 2, a, 3<, a, 81<DD
Out[71]=
3
Discussion
Other counting functions include LeafCount and Tally. It is difficult to emulate Leaf-
Count using Count because LeafCount treats complex numbers in their FullForm (e.g.,
Complex[1,1] has LeafCount == 3) but using FullForm on an expression does not pro-
vide the right answer.
In[72]:=
9LeafCount@exprD, CountAFullForm@exprD, _?AtomQ, Infinity, Heads Ø TrueE=
Out[72]=
817, 14<
You need to eliminate the complex numbers using ReplaceAll before performing the
count, so LeafCount is rather unique. 
In[73]:=
9LeafCount@exprD, CountA
expr ê. Complex@r_, i_D ß complex@r, iD, _?AtomQ, Infinity, Heads Ø TrueE=
Out[73]=
817, 17<
Tally  counts  equivalent  elements  in  a  list  using  SameQ  or  a  user-supplied  equality
test. It works only on lists, so you’ll need to convert expressions with other heads to
List before using Tally. The output is a list of pairs showing the element and its
count.
In[74]:=
TallyA9a, x, a, x, a, a, b, y=E
Out[74]=
98a, 4<, 8x, 2<, 8b, 1<, 9y, 1==
In[75]:=
TallyAFlattenüApplyAList, expr, 90, Infinity=EE
Out[75]=
985 + 3 Â, 1<, 8Â, 1<, 8x, 4<, 82, 1<, 9y, 1==
Here is an example using a different equivalence relation (congruence module 7).
In[76]:=
TallyAPrimeARange@100DE, Mod@Ò1, 7D ã Mod@Ò2, 7D &E
Out[76]=
882, 18<, 83, 18<, 85, 18<, 87, 1<, 811, 14<, 813, 16<, 829, 15<<
See Also
Level specifications are covered in detail in Recipe 3.9.
156 | Chapter 4: Patterns and Rule-Based Programming

4.4 Replacing Parts of an Expression
Problem
You want to transform the parts of an expression designated by an index.
Solution
Use  ReplacePart,  which  can  use  indices  or  index  patterns  to  limit  the  scope  of  a
replacement.
In[77]:=
H*Replace elements at position three and position seven.*L
ReplacePartA9a, b, c, d, e, f, g, h, i= , 83 Ø 3, 7 Ø 11<E
Out[77]=
8a, b, 3, d, e, f, 11, h, i<
In[78]:=
Range@0, 20, 2D
Out[78]=
80, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20<
Place an x at prime-numbered positions. Note that the position is being tested for
primality, not for value.
In[79]:=
ReplacePartA9a, b, c, d, e, f, g, h, i=, 8i_?PrimeQ :> x<E
Out[79]=
8a, x, x, d, x, f, x, h, i<
If you want access to the value as well, you can use the position to index into the list.
In[80]:=
WithA9list = 9a, b, c, d, e, f, g, h, i==,
ReplacePart@list, 8i_?PrimeQ :> Framed@list@@iDDD<DE
Out[80]=
:a,
b ,
c , d,
e , f,
g , h, i>
Discussion
On first encounter, you might think ReplacePart and part assignment are redundant.
In[81]:=
list1 = 81, 2, 3, 4, 5, 6<;
list1@@81, 3<DD = 99;
list1
Out[83]=
899, 2, 99, 4, 5, 6<
This seems similar to what is achieved using ReplacePart.
In[84]:=
list1 = 81, 2, 3, 4, 5, 6<;
list2 = ReplacePart@list1, 81 Ø 99, 3 Ø 99<D
Out[85]=
899, 2, 99, 4, 5, 6<
4.4 Replacing Parts of an Expression | 157

However,  there  are  a  multitude  of  differences.  First,  ReplacePart  does  not  modify
the list but creates a new list with modified values. 
In[86]:=
8list1, list2<
Out[86]=
881, 2, 3, 4, 5, 6<, 899, 2, 99, 4, 5, 6<<
A related difference is that assignment is meaningful only to symbols, not expres-
sions. In contrast, ReplacePart can use either as input. 
In[87]:=
81, 2, 3<@@2DD = 99
Set::setps : 81, 2, 3< in the part assignment is not a symbol. à
Out[87]=
99
Another important difference is that it is harmless to specify an index that does not
match. ReplacePart simply returns a new list with the same content. Contrast this to
part assignment, where you get an error.
In[88]:=
ReplacePart@81, 2, 3<, 10 Ø 99D
Out[88]=
81, 2, 3<
In[89]:=
list1@@10DD = 99
Set::partw : Part 10 of 81, 2, 3, 4, 5, 6< does not exist. à
Out[89]=
99
Part assignment gains flexibility by supporting ranges and lists of position, whereas
ReplacePart uses index patterns.
In[90]:=
list1 = Range@10D ;
In[91]:=
ReplacePartARange@10D, i_?HÒ > 3 && Ò < 7 &L Ø 99E
Out[91]=
81, 2, 3, 99, 99, 99, 7, 8, 9, 10<
In[92]:=
list1@@4 ;; 6DD = 99;
list1
Out[93]=
81, 2, 3, 99, 99, 99, 7, 8, 9, 10<
158 | Chapter 4: Patterns and Rule-Based Programming

ReplacePart works on arbitrarily nested expressions, including matrices. Also note
that the index patterns can be referenced on the right side of rules.
In[94]:=
ReplacePartAIdentityMatrix@5D, 8i_, i_< -> iE êê MatrixForm
Out[94]//MatrixForm=
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
The following use case performs a transpose.
In[95]:=
matrix = Table@x, 810<, 8x, 1, 10<D;
ReplacePartAmatrix, 9i_, j_= :> matrixAAj, iEE E êê MatrixForm
Out[96]//MatrixForm=
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
2
2
2
2
3
3
3
3
3
3
3
3
3
3
4
4
4
4
4
4
4
4
4
4
5
5
5
5
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9
9
10 10 10 10 10 10 10 10 10 10
In[97]:=
ReplacePart@Expand@Hx + 3L^3D, 83, 2< :> zD
Out[97]=
27 + 27 x + x3 + 9 z
See Also
Chapter 3 covers list manipulation in detail, including the use of Part.
4.5 Finding the Longest (or Shortest) 
Match for a Pattern
Problem
A  replacement  rule  is  not  working  the  way  you  think  it  should.  In  particular,  it
seems to work on only part of the expression. Often this is an indication that you
need greedy matching provided by Longest.
4.5 Finding the Longest (or Shortest) Match for a Pattern | 159

Solution
By default, sequence patterns like a__ and a___ act as if they are surrounded by
Shortest. This means they match as little as possible to still be consistent with the
entire pattern. The following repeated replacement seems like it should shuffle items
in the list until all equal values are adjacent. It almost works, but a 3 and a 1 stub-
bornly remain in place. This happens because on the final pass a___ matches noth-
ing (which is shortest), b_ matches 1, c__ matches 1, b_ matches the third 1, and
d___ matches the remainder. This results in a null transformation, so Replace-
Repeated stops.
In[98]:=
81, 3, 1, 4, 1, 3, 4, 2, 7, 1, 8< êê.
88a___, b_, c__, b_, d___< -> 8b , b, a, c, d<<
Out[98]=
81, 1, 1, 3, 4, 3, 4, 2, 7, 1, 8<
Contrast this to the same transformation using Longest. Here we force a___ to
greedily gobble up as many elements as it can and still keep the rest of the pattern
matching. 
In[99]:=
81, 3, 1, 4, 1, 3, 4, 2, 7, 1, 8< êê.
99Longest@a___D, b_, c__, b_, d___= -> 8b , b, a, c, d<=
Out[99]=
81, 1, 1, 1, 3, 3, 4, 4, 2, 7, 8<
Forcing a___ to match as much as it can and yet still satisfy the rest of the pattern re-
sults in all sequences of identical elements separated by one or more other elements
(b_, c__, b_) to be found.
Discussion
Readers familiar with regular expression will recognize the solution example as illus-
trating the difference between greedy and nongreedy matching. This difference is the
source of infinite frustration to pattern writers because, depending on your test case,
nongreedy patterns can appear to work most of the time. Always consider what will
happen if patterns like a__ match only one item and a___ matches nothing. Often
this is what you want, but almost as often it is not!
A reasonable question to ask is why there is a Shortest if it is the default. For string
patterns (see Chapter 5), the default is reversed. You may also use Shortest to docu-
ment that it is your intent, but you should probably limit this to portions of the pat-
tern that are up front.
Also keep in mind that if multiple Shortest or Longest directives are used, the ones
that appear earlier are given higher priority to match the shortest or longest number
of elements, respectively. 
160 | Chapter 4: Patterns and Rule-Based Programming

In[100]:=
81, 2, 3, 4, 5< ê. 8Shortest@a__D, Shortest@b__D< Ø 88a<, 8b<<
Out[100]=
881<, 82, 3, 4, 5<<
In[101]:=
81, 2, 3, 4, 5< ê. 9Longest@a__D, Longest@b__D= Ø 88a<, 8b<<
Out[101]=
881, 2, 3, 4<, 85<<
See Also
Mastering Regular Expressions by Jeffrey E. F. Friedl (O’Reilly) has an extensive dis-
cussion of greedy versus lazy matching that is relevant to understanding Longest and
Shortest. This book is a good investment if you also make use of Mathematica’s
regular expression syntax for string manipulation.
4.6 Implementing Algorithms in Terms of Rules
Problem
You need to implement an algorithm that can be viewed as a transformation from a
start state to a goal state. 
Solution
Many  problems  are  elegantly  stated  in  a  few  simple  transformation  rules.  Here  I
show some simple examples; the discussion will try a few more ambitious tasks. 
Imagine you have a graph of vertex-to-vertex connection rules. This is the notation
used by GraphPlot and the functions in the GraphUtilities` package.
In[102]:=
In[103]:=
ClearAa, b, c, d, e, f, g, h, x, y, zE;
graph = 9a Ø b, b Ø e, b Ø f, f Ø g, a Ø c, a Ø d, e Ø g=;
graph2 = 9a Ø b, b Ø c, c Ø d, d Ø e, b Ø h, h Ø c, c Ø g, g Ø d, d Ø f,
f Ø e, h Ø i, i Ø g, i Ø f, a Ø x, x Ø y, x Ø z, y Ø z, z Ø a=;
In[106]:=
GraphPlotAgraph, VertexLabeling Ø True, DirectedEdges Ø TrueE
Out[106]=
a
b
e
f
g
c
d
4.6 Implementing Algorithms in Terms of Rules | 161

The idea in this solution is to find a path from the from node to some intermediate
node x, and from x to some node y, and then add the path fromØy if it does not al-
ready  exist.  Continue  this  until  the  graph  no  longer  changes  (hence  FixedPoint).
Then check if fromØto is present using MemberQ.
In[107]:=
hasPathAgraph_, from_, from_E := True
hasPathAgraph_, from_, to_E :=
ModuleA9graph2 = graph, pat1=,
pat1 = 9a___, from Ø x_, b___, x_ Ø y_, c___= ê;
! MemberQAgraph2, from Ø yE ß 9from Ø y, x Ø y, from Ø x, a, b, c=;
MemberQAFixedPointAIgraph2 = ReplaceAll@Ò , pat1DM &, graph2E, from Ø toEE
You can test hasPath on the graph in Out[106] on page 161.
In[109]:=
hasPathAgraph, a, gE
Out[109]=
True
In[110]:=
hasPathAgraph, b, dE
Out[110]=
False
Here is an exhaustive test of the vertex c in the graph in Out[113].
In[111]:=
9hasPathAgraph2, c, ÒE, Ò= & êü Igraph2 ê. Rule@v_, _D ß vM
Out[111]=
98False, a<, 8False, b<, 8True, c<, 8True, d<, 8False, b<, 8False, h<,
8True, c<, 9True, g=, 8True, d<, 8True, f<, 8False, h<, 8False, i<,
8False, i<, 8False, a<, 8False, x<, 8False, x<, 9False, y=, 8False, z<=
Here is a related function to compute the transitive closure of a graph.
In[112]:=
transitiveClosureAgraph_E :=
ModuleA9graph2 = graph, pat1=,
pat1 = 9a___, w_ Ø x_, b___, x_ Ø y_, c___= ê;
! MemberQAgraph2, w Ø yE && w =!= y ß 9a, w Ø x, b, x Ø y, c, w Ø y=;
FixedPointAIgraph2 = ReplaceAll@Ò , pat1DM &, graph2EE
In[113]:=
GraphPlotAgraph2, VertexLabeling Ø True, DirectedEdges Ø TrueE
Out[113]=
a
b
c
d
e
h
g
f
i
x
y
z
162 | Chapter 4: Patterns and Rule-Based Programming

Here you compute the transitive closure of Out[113].
In[114]:=
transitiveClosureAgraph2E
Out[114]=
9a Ø b, b Ø c, c Ø d, d Ø e, b Ø h, h Ø c, c Ø g, g Ø d, d Ø f, f Ø e,
h Ø i, i Ø g, i Ø f, a Ø x, x Ø y, x Ø z, y Ø z, z Ø a, a Ø c, a Ø h,
b Ø d, a Ø d, b Ø g, a Ø g, c Ø e, b Ø e, a Ø e, c Ø f, b Ø f, a Ø f,
b Ø i, a Ø i, h Ø g, h Ø e, h Ø f, g Ø f, a Ø y, a Ø z, x Ø a, y Ø a, z Ø c,
x Ø c, y Ø c, z Ø h, x Ø h, y Ø h, z Ø d, x Ø d, y Ø d, z Ø g, x Ø g, y Ø g,
z Ø e, x Ø e, y Ø e, z Ø f, x Ø f, y Ø f, z Ø i, x Ø i, y Ø i, z Ø y=
Out[115] is the plot of the transitive closure of the simpler graph from Out[106] on
page 161.
In[115]:=
GraphPlotAtransitiveClosureAgraphE,
VertexLabeling Ø True, DirectedEdges Ø TrueE
Out[115]=
a
b
e
f
g
c
d
Discussion
The hasPath and transitiveClosure functions share a common property. They are im
plemented by repeated transformation of the input until some goal state is achieved.
The search terminates when there are no more available transformations, as deter-
mined by FixedPoint. TransitiveClosure uses the final state as the result, whereas
hasPath makes one more match using MemberQ to see if the goal was reached.
Although rule-driven algorithms tend to be small, they are not always the most effi-
cient.  HasPath  finds  all  paths  from  the  start  node  before  making  a  determination.
4.6 Implementing Algorithms in Terms of Rules | 163

The hasPath2 implementation here uses Catch-Throw to exit as soon as the solution
is found.
In[116]:=
hasPath2Agraph_, from_, to_E :=
ModuleA9graph2 = graph, pat1, pat2=,
pat1 = 8___, from Ø to, __< ß Throw@from Ø toD;
pat2 = 9a___, from Ø x_, b___, x_ Ø y_, c___= ê;
! MemberQAgraph2, from Ø yE ß 9from Ø y, from Ø x, x Ø y, a, b, c=;
CatchAFixedPointAIgraph2 = ReplaceAll@Ò , 8pat1, pat2<DM &, graph2EE;
MemberQAgraph2, from Ø toEE
In[117]:=
monsterGraph = Table@i Ø i + 1, 8i, 500<D;
In[118]:=
Timing@hasPath@monsterGraph, 1, 250DD
Out[118]=
86.15429, True<
In[119]:=
Timing@hasPath2@monsterGraph, 1, 250DD
Out[119]=
80.519091, True<
The main components of this solution are: 
1. Localization: Module[ {rules, start, next, final}, .. ] 
2. Rules: Enumeration of the rules with tests against next (graph2 plays the role of
next in the examples). An optional Throw rule detects success for early termination.
3. Repetition: next = ReplaceAll[next, rules] 
4. Stopping criteria: final = FixedPoint[ .., start]. Assignment to final allows
the result to undergo some post processing. In the examples, final was implicit.
If a Throw rule is used, FixedPoint should be wrapped in a Catch.
5. Postprocessing:  Extract  results  from  final.  Here  MemberQ  is  used  to  test  if  the
path was found. 
If you have trouble following one of these solutions, Mathematica will show its work
if you use FixedPointList. For example, here is the expansion of the steps in hasPath.
In[120]:=
explainHasPathAgraph_, from_, from_E := 8from Ø from<
explainHasPathAgraph_, from_, to_E :=
ModuleA9graph2 = graph, pat1=,
pat1 = 9a___, from Ø x_, b___, x_ Ø y_, c___= ê;
! MemberQAgraph2, from Ø yE ß 9from Ø y, x Ø y, from Ø x, a, b, c=;
FixedPointListAIgraph2 = ReplaceAll@Ò , pat1DM &, graph2EE
164 | Chapter 4: Patterns and Rule-Based Programming

In[122]:=
explainHasPathAgraph, a, gE êê TableForm
Out[122]//TableForm=
a Ø b
b Ø e
b Ø f
f Ø g
a Ø c
a Ø d
e Ø g
a Ø e
b Ø e
a Ø b
b Ø f
f Ø g
a Ø c
a Ø d
e Ø g
a Ø g
e Ø g
a Ø e
b Ø e
a Ø b
b Ø f
f Ø g
a Ø c
a Ø d
a Ø f
b Ø f
a Ø b
a Ø g
e Ø g
a Ø e
b Ø e
f Ø g
a Ø c
a Ø d
a Ø f
b Ø f
a Ø b
a Ø g
e Ø g
a Ø e
b Ø e
f Ø g
a Ø c
a Ø d
This shows each step in the transition from the original graph to the one with all in-
termediate steps filled in. Try to work out how the rule took each line to the next
line.  Only  by  working  through  examples  like  this  will  you  begin  to  master  the
concepts.
See Also
FixedPoint usually finds application in numerical methods that use iteration, such as
Newton’s method (see Recipe 2.12), but any algorithm that computes until an equi-
librium state is reached can use FixedPoint.
4.7 Debugging Infinite Loops When Using 
ReplaceRepeated
Problem
Mathematica went into an infinite loop when you used //. (ReplaceRepeated), and
the reason is not immediately obvious.
Solution
ReplaceRepeated is often very handy but also dangerous because it only terminates
when the result stops changing. The simplest thing to do is to test ReplaceRepeated
with the option MaxIterations set to a reasonably small value (the default is 65,536).
In[123]:=
ReplaceRepeated@81, 2<, 8a_, b_< Ø 88a<, 8b<<, MaxIterations Ø 10D
ReplaceRepeated::rrlim :
Exiting after 81, 2< scanned 10 times. à
Out[123]=
888888888881<<<<<<<<<<, 88888888882<<<<<<<<<<<
4.7 Debugging Infinite Loops When Using ReplaceRepeated | 165

It should be clear that this will never terminate. Any transformation that adds struc-
ture  is  doomed.  However,  sometimes  the  end  result  obtained  when  clamping
iterations does not immediately reveal the problem. In such cases, it helps to  see
the  whole  sequence  of  transformations.  You  can  do  that  using  NestList  and
ReplaceAll to emulate a ReplaceRepeated with a small number of iterations that re-
turn the result after each iteration.
In[124]:=
NestList@ReplaceAll@Ò, 8a_, b_< Ø 8b, a<D &, 81, 2<, 10D
Out[124]=
881, 2<, 82, 1<, 81, 2<, 82, 1<, 81, 2<,
82, 1<, 81, 2<, 82, 1<, 81, 2<, 82, 1<, 81, 2<<
Here the problem is an oscillating transformation that will never settle down. You
could probably see that by inspection, but seeing each step makes it obvious.
Discussion
Sometimes  applying  the  debugging  techniques  in  the  solution  can  still  leave  you
stumped. Here is an example that one would expect to terminate based on the fact
that NumberQ[Infinity] is false.
In[125]:=
ReplaceRepeatedA81, a, 2, b, 3, c< ,
9_?NumberQ Ø FAInfinityE=, MaxIterations -> 10E
ReplaceRepeated::rrlim :
Exiting after 81, a, 2, b, 3, c< scanned 10 times. à
Out[125]=
9FADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinity@F@¶DDEEEEEEEEEEEEEEEEE,
a, FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinity@F@¶DDEEEEEEEEEEEEEEEEE,
b, FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinity@F@¶DDEEEEEEEEEEEEEEEEE, c=
166 | Chapter 4: Patterns and Rule-Based Programming

In situations like this, you should try applying FullForm to the output to see what
Mathematica sees rather than what it shows you.
In[126]:=
FullForm@%D
Out[126]//FullForm=
ListAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityAFA
DirectedInfinityAFADirectedInfinityA
FADirectedInfinity@1DEEEEEEEEEEEEEEEEEEE,
a, FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinity@1DEEEEEEEEEEEEEEEEEEE,
b, FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinityAFADirectedInfinityAFADirectedInfinityA
FADirectedInfinity@1DEEEEEEEEEEEEEEEEEEE, cE
Do you see the problem? It is near the end of the output. If you can’t see it, consider
this.
In[127]:=
FullFormAInfinityE
Out[127]//FullForm=
DirectedInfinity@1D
The full form of Infinity contains the integer 1, which is being matched and replaced
with F[DirectedInfinity[1]] and so on, ad infinitum. In this simple case, Replace-
Repeated  was  not  needed  because  ReplaceAll  would  do  the  trick.  If  Replace-
Repeated is necessary, break the process into two steps, first using a proxy for
the construct that has the hidden representation that is messing you up. Here I use
Inf instead of Infinity.
In[128]:=
81, a, 2, b, 3, c< êê. 8_?NumberQ Ø F@InfD< ê. Inf Ø Infinity
Out[128]=
8F@¶D, a, F@¶D, b, F@¶D, c<
See Also
You  can  find  a  realistic  example  of  the  Infinity  problem  at  the  Wolfram  Math-
Group Archives: http://bit.ly/2oRAuZ.
4.7 Debugging Infinite Loops When Using ReplaceRepeated | 167

4.8 Preventing Evaluation 
Until Replace Is Complete
Problem
You are trying to transform an expression, but the structure you want to transform
is disappearing due to evaluation before you can transform it.
Solution 
Use Hold and ReleaseHold with the replacement.
This does not work the way you probably intended.
In[129]:=
1 + 1 + 1 + 1 + 1 ê. 81 Ø 2, Plus -> Times<
Out[129]=
5
This preserves the structure until the transformation is complete, then allows it to
evaluate.
In[130]:=
ReleaseHold@Hold@1 + 1 + 1 + 1 + 1 D ê. 81 Ø 2, Plus -> Times<D
Out[130]=
32
A related problem is wanting the left side of a replacement rule to remain unevalu-
ated. In this case, you need to use HoldPattern.
This is equivalent to ReleaseHold[Hold[1 + 1 + 1 + 1 + 1 ] /. 4 :> 2 + 2 + 2 + 2 ].
In[131]:=
ReleaseHold@Hold@1 + 1 + 1 + 1 + 1 D ê. 1 + 1 + 1 + 1 :> 2 + 2 + 2 + 2D
Out[131]=
5
In[132]:=
H*This works as intended by preserving the structure of the pattern.*L
ReleaseHold@
Hold@1 + 1 + 1 + 1 + 1 D ê. HoldPattern@1 + 1 + 1 + 1D :> 2 + 2 + 2 + 2D
Out[132]=
9
Discussion
Keep in mind that HoldPattern[expr] differs from Hold[expr]. From a pattern-matching
point  of  view,  HoldPattern[expr]  is  equivalent  to  expr  alone  except  it  prevents
evaluation. Hold[expr] includes the Hold as part of the pattern.
168 | Chapter 4: Patterns and Rule-Based Programming

In[133]:=
GO = "gone";
In[134]:=
Hold@1 + 2 + 3D ê. HoldPattern@1 + 2 + 3D :> GO
Out[134]=
Hold@GOD
In[135]:=
Hold@1 + 2 + 3D ê. Hold@1 + 2 + 3D :> GO
Out[135]=
gone
See Also
Chapter 2 discusses Hold in more detail.
4.9 Manipulating Patterns with Patterns
Problem
You need to transform a pattern expression using patterns. 
Solution
Use  Verbatim  to  allow  a  pattern  to  match  another  pattern.  Here  Verbatim  tells
Mathematica to treat the expression literally. 
In[136]:=
x_ Ø 1 ê. Verbatim@x_D ß y_
Out[136]=
y_ Ø 1
Here we want to split up a pattern variable into the name and the head it matches.
In[137]:=
x_Integer ê. Verbatim@PatternD@name_, head_D ß 8name, head<
Out[137]=
9x, _Integer=
Discussion
The key to understanding the solution is to consider the FullForm of pattern variables.
In[138]:=
9FullForm@x_D, FullForm@x__D, FullForm@x___D, FullFormAx_IntegerE=
Out[138]=
9Pattern@x, Blank@DD, Pattern@x, BlankSequence@DD,
Pattern@x, BlankNullSequence@DD, PatternAx, BlankAIntegerEE=
Without Verbatim, the first example in the first part of the solution would go wrong.
In[139]:=
x_ Ø 1 ê. x_ ß y_
Out[139]=
y_
4.9 Manipulating Patterns with Patterns | 169

The second part of the solution would fail because a pattern can’t have another pat-
tern as its name.
In[140]:=
x_Integer ê. Pattern@name_, head_D ß 8name, head<
Pattern::patvar :
First element in pattern Pattern@name_, head_D is
not a valid pattern name. à
Out[140]=
x_Integer
Verbatim[expr] says “match expr exactly as it appears.” You will not use Verbatim of-
ten  unless  you  find  yourself  writing  Mathematica  code  to  transform  Mathematica
code, as you might if you were writing a special interpreter or code to rewrite Mathe-
matica code containing patterns in some other form.
See Also
The Mathematica Programmer II by Roman Maeder (Academic Press) uses Verbatim
during the development of an interpreter for a Prolog-like language.
4.10 Optimizing Rules
Problem
You have a large list of frequently used rules and want to speed up processing.
Solution
Use Dispatch to create a dispatch table and use that in place of the rules.
In[141]:=
rules = 9 Inf Ø Infinity, sin Ø Sin, cos Ø Cos, tan Ø Tan, pi Ø Pi=
Out[141]=
8Inf Ø ¶, sin Ø Sin, cos Ø Cos, tan Ø Tan, pi Ø p<
In[142]:=
dispatch = Dispatch@rulesD
Out[142]=
Dispatch@8Inf Ø ¶, sin Ø Sin, cos Ø Cos, tan Ø Tan, pi Ø p<, -DispatchTables -D
In[143]:=
cos@2 pi qD + sin@q^2D - sin@cos@3 zDD ê. dispatch
Out[143]=
Cos@2 p qD + SinAq2E - Sin@Cos@3 zDD
170 | Chapter 4: Patterns and Rule-Based Programming

Discussion
If you do a lot of multiple-rule transformations, it is convenient to store all the rules
in a single variable. This common practice makes maintenance of your code simpler
since there is only a single definition to maintain for all rules. However, the penalty
for doing this is that the performance of a replace decreases as the number of rules
increases. This is because each rule must be scanned in turn, even if it ends up being
inapplicable to a given transformation. Rule dispatch tables optimize rule dispatch
so it is mostly independent of the number of rules.
To test this claim, I generate a list of 5,000 rules, called monsterRuleSet, and then
optimize  it  to  create  monsterDispatch.  The  timing  on  the  monsterRuleSet  is  very
poor, whereas the dispatched version is lickety-split.
In[144]:=
monsterRuleSet = Table@i Ø i + 1, 8i, 5000<D;
monsterDispatch = Dispatch@monsterRuleSetD;
In[146]:=
Timing@81< êê. monsterRuleSetD
Out[146]=
83.29176, 85001<<
In[147]:=
Timing@81< êê. monsterDispatchD
Out[147]=
80.005828, 85001<<
Peering into the implementation, you can see that the secret to Dispatch’s success is
a hash table.
In[148]:=
monsterDispatch@@2DD êê Short
Out[148]//Short=
8HashTable@1, 5000, 1, 8810, 2856<, 8<, 83110, 3440<, 8<, 81245<, á4989à,
83060<, 81008<, 8912<, 8879, 3696, 4165, 4971<, 8545, 676, 4204<<D<
4.11 Using Patterns As a Query Language
Problem
You want to perform SQL-like queries on data stored in Mathematica.
Solution
Consider data of the sort one might encounter in a relational database but encoded
in  Mathematica  form.  This  example  is  taken  from  the  classic  introduction  to
databases by C. J. Date.
4.11 Using Patterns As a Query Language | 171

In[149]:=
S = 8
supplier@ "S1" , "Smith", 20, "London"D,
supplier@"S2", "Jones" , 10 , "Paris"D,
supplier@"S3", "Blake" , 30 , "Paris"D,
supplier@ "S4", "Clark", 20 , "London"D,
supplier@ "S5", "Adams" , 30 , "Athens"D
<;
P = 9
part@"P1", "Nut" , "Red", 12, "London"D,
part@ "P2" , "Bolt" , "Green", 17, "Paris"D,
part@"P3" , "Screw", "Blue", 17, "Rome"D,
part@"P4" , "Screw", "Red", 14, "London"D,
part@ "P5" , "Cam", "Blue", 12, "Paris"D,
partA "P6" , "Cog", "Red" , 19, "London"E
=;
INV = 9
inventory@ "S1" , "P1" , 300D,
inventory@ "S1" , "P2" , 200D,
inventory@ "S1" , "P3" , 400D,
inventory@ "S1" , "P4" , 200D,
inventory@ "S1" , "P5" , 100D,
inventory@ "S1" , "P6" , 100D,
inventory@ "S2" , "P1" , 300D,
inventory@ "S2" , "P2" , 400D,
inventory@ "S3" , "P2" , 200D,
inventory@ "S4" , "P2" , 200D,
inventory@ "S4" , "P4" , 300D,
inventory@ "S4" , "P5" , 400D
=;
Simple queries can be done using Cases alone.
In[152]:=
H*Find suppliers in Paris.*L
Cases@S, supplier@_, _, _, "Paris"D D
Out[152]=
8supplier@S2, Jones, 10, ParisD, supplier@S3, Blake, 30, ParisD<
In[153]:=
H*Find suppliers in Paris with status greater than 10.*L
Cases@S, supplier@_, _, status_ ê; status > 10, "Paris"D D
Out[153]=
8supplier@S3, Blake, 30, ParisD<
172 | Chapter 4: Patterns and Rule-Based Programming

Queries involving joins can be implemented with the help of Outer.
In[154]:=
H*Find suppliers and parts located in the same city.*L
FlattenAOuterA
CasesA88Ò1, Ò2<<, 9supplierAsid_, __, city_E, partApid_, __, city_E= ß
colocatedAsid, pid, cityEE &, S, PEE
Out[154]=
8colocated@S1, P1, LondonD, colocated@S1, P4, LondonD,
colocated@S1, P6, LondonD, colocated@S2, P2, ParisD,
colocated@S2, P5, ParisD, colocated@S3, P2, ParisD,
colocated@S3, P5, ParisD, colocated@S4, P1, LondonD,
colocated@S4, P4, LondonD, colocated@S4, P6, LondonD<
In[155]:=
H*Find suppliers who have the same status.*L
Flatten@Outer@Cases@88Ò1, Ò2<<,
8supplier@sid1_, _, s_, _D, supplier@sid2_, _, s_, _D< ê;
Order@sid1 , sid2D == 1 ß same@sid1, sid2, sDD &, S, SDD
Out[155]=
8same@S1, S4, 20D, same@S3, S5, 30D<
Discussion
If the data you need to query resides in a database, it makes more sense to let that
database do the query work before the data is imported into Mathematica. If this is
not  the  case,  Mathematica  can  easily  do  the  job,  even  for  rather  sophisticated
queries. Here are some simple examples with SQL equivalents.
Find all pairs of cities where a supplier in the first city has inventory on a part in the
second city.
SELECT DISTINCT S.CITY, P.CITY
FROM S, INV, P
WHERE S.SID = INV.SID
AND INV.PID = P.PID;
In[156]:=
query = 9supplierAsid_, _, _, city1_E, inventory@sid_, pid_, _D,
partApid_, _, _, _, city2_E= ß citiesAcity1, city2E;
UnionAFlattenAOuterACasesA88Ò1, Ò2, Ò3<<, queryE &, S, INV, PEEE êê
TableForm
Out[157]//TableForm=
cities@London, LondonD
cities@London, ParisD
cities@London, RomeD
cities@Paris, LondonD
cities@Paris, ParisD
4.11 Using Patterns As a Query Language | 173

In this case, ReplaceRepeated can be used to implement GROUP BY. The idea is to con-
tinually search for pairs of items that match on the grouping criteria and combine
them according to some aggregation method, in this case the sum of qty. Since each
replacement  removes  an  inventory  item,  we  are  guaranteed  to  terminate  when  all
items are unique. A final ReplaceAll is used to extract the relevant information. The
use of Null in the replacement rule is just for aesthetics, conveying that when you
aggregate two inventory records you no longer have a valid record for a particu-
lar supplier.
SELECT PID, SUM(QTY)
FROM INV
GROUP BY PID;
In[158]:=
INV êê.
9Longest@i1___D, inventory@ _ , p_ , q1_D, i2__, inventory@_, p_, q2_D,
i3___= ß 9i1, inventory@Null, p , q1 + q2D, i2, i3= ê.
inventory@s_ , p_ , q_D ß totals@p, qD êê TableForm
Out[158]//TableForm=
totals@P1, 600D
totals@P2, 1000D
totals@P3, 400D
totals@P4, 500D
totals@P5, 500D
totals@P6, 100D
Suppose you want the names of suppliers who have inventory in the part P1. This in-
volves  integrating  information  from  S  and  INV.  This  can  be  done  as  a  join,  but  in
SQL it can also be done via a subquery. You can emulate that using rules. Here MemberQ
implements the semantics of the SQL IN.
SELECT NAME
FROM S
WHERE SID IN
( 
SELECT SID
FROM INV
WHERE PID = 'P2') 
In[159]:=
CasesAS, supplier@sid_, sname_, ___D ê; MemberQA
CasesAINV, inventory@sid1_, "P2", _D ß sid1E,
sidE ß snameE
Out[159]=
8Smith, Jones, Blake, Clark<
In the examples given, I have demonstrated queries for which the data is in rela-
tional form. One feature of relational form is that it is normalized so that each col-
umn can hold only atomic data. However, Mathematica is not a relational database,
174 | Chapter 4: Patterns and Rule-Based Programming

so data can appear in just about any form with any level of nesting. This is no prob-
lem because patterns are much more flexible than SQL. Still, I find it easier to put
data  in  a  tabular  form  before  trying  to  extract  information  and  relationships  with
other collections of data. Let’s consider an example that is more in the Mathematica
domain.
GraphData and PolyhedronData are two extensive data sources that are bundled with
Mathematica  6  and  later  versions.  The  relationship  between  these  data  sources  is
that each polyhedron has an associated graph. In PolyhedronData, the property that
ties the two sources together is called SkeletonGraph. In database jargon, Skeleton-
Graph is a foreign key to GraphData, and thus, allows us to investigate relationships be-
tween polyhedra and their associated graphs. For this example, I want to consider
all graphs that are both Eulerian and Hamiltonian with their associated polyhedron
being  Archimedean.  (An  Archimedean  solid  is  a  highly  symmetric,  semiregular,
convex polyhedron composed of two or more types of regular polygons meeting in
identical vertices.)
In[160]:=
Archimedean = CasesA9ToString@ÒD,
PolyhedronData@ÒD, PolyhedronData@Ò, "SkeletonGraphName"D,
PolyhedronData@Ò, "Archimedean"D= & êü PolyhedronData@D ,
9name_, image_, graph_, True= ß archimedeanAname, image, graphEE;
Graphs = CasesA9ToString@ÒD, GraphData@ÒD, GraphData@Ò, "Eulerian"D,
GraphData@Ò, "Hamiltonian"D= & êü GraphData@D ,
9name_, image_, True, True= ß graphEorHAname, imageEE;
It’s often a good idea to see how many results you received.
In[162]:=
9Length@ArchimedeanD, Length@GraphsD=
Out[162]=
813, 676<
In[163]:=
results =
FlattenAOuterACasesA88Ò1, Ò2<<, 9archimedeanApname_, pimage_, gname_E,
graphEorHAgname_, gimage_E=
ß
rAgname, pname, gimage, pimageEE &, Archimedean, GraphsEE ;
There are exactly 4 cases out of 13 Archimedean polyhedra that meet the criteria of
having both Eulerian and Hamiltonian graphs. 
In[164]:=
TableFormAresults ê. 9 rAgname_, pname_, gimage_, pimage_E ß
99gname, gimage= ê. Graphics@a__D ß GraphicsAa, ImageSize Ø 100E,
9pname, pimage= ê. Graphics3D@b__D ß Graphics3DAb, ImageSize Ø 100E==E
4.11 Using Patterns As a Query Language | 175

Out[164]//TableForm=
CuboctahedralGraph
Cuboctahedron
IcosidodecahedralGraph
Icosidodecahedron
SmallRhombicosidodecahedralGraph SmallRhombicosidodecahedron
SmallRhombicuboctahedralGraph
SmallRhombicuboctahedron
176 | Chapter 4: Patterns and Rule-Based Programming

You might find more intuitive ways to solve this problem, but the solution given em-
phasizes  pattern  matching.  You  could  also  use  Intersection  with  an  appropriate
SameTest, as shown here. The r @@@ serves only to put the result in the same form as
we used previously and is not strictly needed.
In[165]:=
results = r üüü
Intersection@Archimedean, Graphs, SameTest -> HÒ1@@3DD == Ò2@@1DD &LD;
See Also
The supplier-parts database is a classic example borrowed from An Introduction to
Database Systems: Volume 1, Fourth Edition, by C. J. Date (Addison-Wesley). 
4.12 Semantic Pattern Matching
Problem
You  want  to  work  with  patterns  that  reach  beyond  syntactic  (structural)  relation-
ships to consider semantic relationships.
Solution
This solution is a simplified adaptation of concepts from “Semantica: Semantic Pat-
tern Matching in Mathematica” by Jason Harris, published in the Mathematica Jour-
nal, Volume 7, Issue 3, 1999. 
Pattern matching in Mathematica is strictly structural. Consider the following func-
tion f.
In[166]:=
Clear@fD
SetAttributes@f, HoldFirstD;
fAx_Integer^2E := 1
Clearly,  3^2  matches  the  first  version  of  the  function.  However,  neither  f[9]  nor
f[10]  are  in  the  correct  form,  so  they  fail  to  match,  even  though  in  the  second
case 9 == 3^2.
In[169]:=
8f@3^2D, f@9D, f@10D<
Out[169]=
81, f@9D, f@10D<
4.12 Semantic Pattern Matching | 177

All hope is not lost. By exploiting patterns, you can create a semantic match that
uses Condition, which is commonly abbreviated as /;.
In[170]:=
Clear@fD;
SetAttributes@f, HoldFirstD;
fAx_ ê; IntegerQ@xD && IReduceAz^2 ã x, 8z<, IntegersE =!= FalseME := 1
Now both the first and second cases match but not the last.
In[173]:=
8f@3^2D, f@9D, f@10D<
Out[173]=
81, 1, f@10D<
Discussion
Mathematica deals with structural patterns simply because, in general, it is impossi-
ble to determine if two expressions are semantically equivalent. In the 1930s, Gödel,
Turing, Church, and others performed the theoretical work that underlies this unfor-
tunate truth. Still, there are many restricted cases for which semantic matching can
succeed, as demonstrated in the solution. 
4.13 Unification Pattern Matching
Problem
You want to emulate unification-based matching, à la Prolog.
Solution
Unification is more powerful than Mathematica pattern matching in that it allows
pattern variables on both sides of the match. We can’t use normal pattern variables
for this purpose, so we use the syntax $[var] to denote unification variable. 
In[174]:=
ClearAllAunifyE
SetAttributesA$, HoldAllE
OptionsAunifyE = 9bindings Ø 8<=;
unifyAx_, y_, opt___E :=
BlockA9$bindings = bindings ê. 8opt< ê. OptionsAunifyE=,
ModuleA9unify0, boundQ, lookup=,
SetAttributesAunify0, OrderlessE;
boundQ@x1_D := ModuleA8<, Ix1 ê. $bindings M =!= x1E;
lookup@x1_D := ModuleA8<, x1 ê. $bindingsE;
178 | Chapter 4: Patterns and Rule-Based Programming

H*If both variables are bound, then match if values match.*L
unify0A$@x1_D, $Ay1_EE ê; boundQ@x1D && boundQAy1E :=
ModuleA8<, lookup@x1D === lookupAy1EE;
H*If one variable matches,
then bind the other to the same value and unify again.*L
unify0A$@x1_D, $Ay1_EE ê; boundQ@x1D :=
ModuleA8xval<, xval = lookup@x1D;
AppendToA$bindings, y1 Ø xvalE; unify0Axval, $Ay1EEE;
H*If neither variable is bound,
then eliminate variable by binding first to second.*L
unify0A$@x1_D, $Ay1_EE :=
ModuleA8<, AppendToA$bindings, x1 Ø y1E; TrueE;
H*Unify a bound variable to an
expression by unifying its value to the expression.*L
unify0A$@x1_D, y1_E ê; boundQ@x1D :=
ModuleA8<, unify0Alookup@x1D, y1EE;
H*Unify an unbound variable
to an expression by binding to the expression.*L
unify0A$@x1_D, y1_E := ModuleA8<,
AppendToA$bindings, x1 Ø y1E; TrueE;
H*Atoms unify if they are the same.*L
unify0Ax1_?AtomQ, y1_?AtomQE := ModuleA8<, x1 === y1E;
H*Compound expressions unify if they have the same head and
the same length and their corresponding elements unify.*L
unify0Ax1_, y1_E ê; Head@x1D === HeadAy1E &&
Length@x1D ã LengthAy1E :=
ModuleA8u<, And üü ThreadAuAx1, y1E, Head@x1DE ê. u Ø unify0E;
H*Otherwise fail*L
unify0Ax1_, y1_E := False;
IfAunify0Ax, yE, 9True, $bindings ê. $@a_D ß a=, 8False, 8<<EEE
Test unify on various expressions:
In[178]:=
unify@1, 1D
Out[178]=
8True, 8<<
In[179]:=
unifyA$@xD, 1E
Out[179]=
8True, 8x Ø 1<<
4.13 Unification Pattern Matching | 179

In[180]:=
unifyA1, $@xDE
Out[180]=
8True, 8x Ø 1<<
In[181]:=
unifyAfA$@xD, aE, fAb, $AyEEE
Out[181]=
9True, 9x Ø b, y Ø a==
In[182]:=
unifyAfA$@xD, aE, fAb, $@xDEE
Out[182]=
8False, 8<<
In[183]:=
unifyAfA$@xD, gA$AyEEE, fAg@3D, $@xDEE
Out[183]=
9True, 9x Ø g@3D, y Ø 3==
In[184]:=
unifyAfAgA$AyEEE, fA$@xDEE
Out[184]=
9True, 9x Ø gAyE==
Here you pass in a preexisting binding so the unification fails.
In[185]:=
unifyA1, $@xD, bindings Ø 8x Ø 2<E
Out[185]=
8False, 8<<
Discussion
In[186]:=
ClearAunifyNE
unifyNAx_, y_E := unifyAx, yE
unifyNAx_, y_, z__E := ModuleA8t, b2<,
8t, b2< = unifyN@x, zD; IfAt, unifyAx, y, bindings ß b2E, 8t, b2<EE
In[189]:=
unifyNAfA$@wD, 2, 3, 4E, fA1, $@xD, 3, 4E, fA1, 2, $AyE, 4E, fA1, 2, 3, $@zDEE
Out[189]=
9True, 9w Ø 1, z Ø 4, y Ø 3, x Ø 2==
See Also
Maeder’s Mathematica Programmer II goes much further than this recipe by imple-
menting a large subset of Prolog. It also allows you to use normal pattern syntax by
rewriting the variables using techniques discussed in Recipe 3.10.
180 | Chapter 4: Patterns and Rule-Based Programming

CHAPTER 5
String and Text Processing
Someone will call
Something will fall
And smash on the floor
Without reading the text
Know what comes next
Seen it before
And it’s painful
Things must change
We must rearrange them
Or we’ll have to estrange them
All that I’m saying
The game’s not worth playing
Over and over again
Depeche Mode, “The Sun and the Rainfall”
5.0 Introduction
Users who come to Mathematica for its superior mathematical capabilities are pleas-
antly surprised to find strong abilities in programming areas outside of mathematics
proper. This is certainly true in the area of textual and string processing. Mathemati-
ca’s rich library of functions for string and structured text manipulation rivals Java,
Perl, or any other modern language you can tie a string around. 
The sections in this introduction provide information on some of the basic tools of
strings and string manipulation. 
Characters and Character Encodings
Mathematica uses Unicode internally, but externally (e.g., when saving a notebook)
it uses ASCII codes, encoding non-ASCII characters in a special form.
For example, lowercase Greek letters and other non-ASCII characters are encoded
using backslash-bracketed character names (\[name]).
181

In[1]:=
alpha = "a"
Out[1]=
a
The function ToString will translate strings using different encoding schemes.
In[2]:=
ToStringAalpha, CharacterEncoding Ø "ASCII"E
Out[2]=
\[Alpha]
The default character encoding used by Mathematica is stored in $CharacterEncoding,
and the native character encoding of the underlying operating system Mathematica
is running is stored in $SystemCharacterEncoding. All available encodings are stored
in $CharacterEncodings.
In[3]:=
$CharacterEncoding
Out[3]=
UTF-8
In[4]:=
$SystemCharacterEncoding
Out[4]=
UTF-8
In[5]:=
PartitionA$CharacterEncodings, 4E êê TableForm
Out[5]//TableForm=
AdobeStandard
ASCII
CP936
CP949
CP950
Custom
EUC-JP
EUC
IBM-850
ISO10646-1
ISO8859-10
ISO8859-11
ISO8859-13
ISO8859-14
ISO8859-15
ISO8859-16
ISO8859-1
ISO8859-2
ISO8859-3
ISO8859-4
ISO8859-5
ISO8859-6
ISO8859-7
ISO8859-8
ISO8859-9
ISOLatin1
ISOLatin2
ISOLatin3
ISOLatin4
ISOLatinCyrillic
Klingon
koi8-r
MacintoshArabic
MacintoshChineseSimplified
MacintoshChineseTraditional MacintoshCroatian
MacintoshCyrillic MacintoshGreek
MacintoshHebrew
MacintoshIcelandic
MacintoshKorean
MacintoshNonCyrillicSlavic
MacintoshRomanian
MacintoshRoman
MacintoshThai
MacintoshTurkish
MacintoshUkrainian
Math1
Math2
Math3
Math4
Math5
Mathematica1
Mathematica2
Mathematica3
Mathematica4
Mathematica5
Mathematica6
Mathematica7
PrintableASCII
ShiftJIS
Symbol
Unicode
UTF8
WindowsANSI
WindowsBaltic
WindowsCyrillic
WindowsEastEurope
WindowsGreek
WindowsThai
WindowsTurkish
ZapfDingbats
Notice how UTF-8 needs two bytes to display alpha.
In[6]:=
ToStringAalpha, CharacterEncoding Ø "UTF8"E
Out[6]=
Î±
ToCharacterCode gives the numerical representation.
In[7]:=
ToCharacterCodeAToStringAalpha, CharacterEncoding Ø "UTF8"EE
Out[7]=
8206, 177<
182 | Chapter 5: String and Text Processing

You can map from character codes back to characters using FromCharacterCode[].
In[8]:=
FromCharacterCode@887, 88, 89, 90<D
Out[8]=
WXYZ
The mapping may not be one-to-one for certain encodings.
In[9]:=
FromCharacterCode@8206, 177<, "UTF8"D
Out[9]=
a
String and Regular Expressions
A great deal of Mathematica’s prowess in text processing comes from its rich support
for pattern matching. There are two basic classes of string patterns: string expres-
sions and regular expressions. Introduced in version 5.1, each has a similar expres-
sive  power.  The  advantage  of  StringExpression  is  that  it  is  less  cryptic  because  it
uses more words than symbols to express patterns. The advantage of RegularExpression is
that it is more standardized with other languages such as Perl, Ruby, Java, and so on.
Non-Mathematica  programmers,  especially  those  with  a  background  in  Unix,  are
more likely to understand regular expressions, although these expressions are cryp-
tic to the uninitiated. You should become familiar with both if you plan to do much
string manipulation. If you program frequently in languages outside of Mathematica,
master the regular expression syntax. If you work strictly in Mathematica, choose the one
that most appeals to you. If you learn the string expression syntax, you will have a
leg up on learning Mathematica’s more general pattern-matching syntax, which is
used in many contexts outside text processing. You can also mix string expressions
and regular expressions into compound patterns.
String expressions     
StringExpressions are mostly written using the infix operator ~~, which is a syntactic
shortcut for the StringExpression[] function. StringExpression uses Mathematica’s
blanks notation (e.g., _, __, and ___) to represent wild cards. See Chapter 4 for more
on blanks.
Match "xy" followed by any character.
In[10]:=
"xy" ~~ _;
In[11]:=
StringMatchQA"xyz" , "xy" ~~ _E
Out[11]=
True
In[12]:=
StringMatchQA"xyzz" , "xy" ~~ _E
Out[12]=
False
5.0 Introduction | 183

Match "xy" followed by one or more characters.
In[13]:=
"xy" ~~ __;
In[14]:=
StringMatchQA"xyzz" , "xy" ~~ __E
Out[14]=
True
In[15]:=
StringMatchQA"xy" , "xy" ~~ __E
Out[15]=
False
Match "xy" followed by zero or more characters.
In[16]:=
"xy" ~~ ___;
In[17]:=
StringMatchQA"xyz" , "xy" ~~ ___E
Out[17]=
True
In[18]:=
StringMatchQA"xy" , "xy" ~~ ___E
Out[18]=
True
Patterns  can  be  associated  with  variables  so  that  the  matching  portion  can  be  re-
ferred to in a subsequent expression. For example, the following pattern will match
if the string begins and ends with the same sequence of characters.
In[19]:=
StringMatchQA"xyx" , x__ ~~ ___ ~~ x__E
Out[19]=
True
In[20]:=
StringMatchQA"Hello. I said, hello" , x__ ~~ ___ ~~ x__, IgnoreCase Ø TrueE
Out[20]=
True
In[21]:=
StringMatchQA"123ABC323", x : NumberString ~~ ___ ~~ x_E
Out[21]=
False
In[22]:=
StringMatchQA"123ABC123", x : NumberString ~~ ___ ~~ x_E
Out[22]=
True
Table 5-1 shows some of the common raw ingredients for string expressions. If you
have already read Chapter 4 on pattern matching, you can see that all the same con-
structs are available for strings. The full set of string expression primitives can be
found in tutorial/WorkingWithStringPatterns.
184 | Chapter 5: String and Text Processing

Table 5-1. Common string patterns
Pattern
Description
"\"string\""
"_"
"a literal string of characters"
"any single character"
"__"
"any substring of
one or more characters"
"___"
"any substring of
zero or more characters"
"x_,x__,x___"
"substrings given the name x"
"x:pattern"
"pattern given the name x"
"pattern.."
"pattern repeated one or more times"
"pattern..."
"pattern repeated zero or more times"
"patt1»patt2»..."
"a pattern matching
at least one of the patt-i"
"pattê;cond"
"a pattern for which
cond evaluates to True"
"pattern?test"
"a pattern for which test
yields True for each character"
"Except@patternD"
"matches anything except pattern"
"Whitespace"
"a sequence of whitespace characters"
"NumberString"
"the characters of a number"
"DatePattern@specD"
"the characters of a date"
"charobj"
"an object representing a
character class Hsee belowL"
Table 5-2 shows some of the common raw ingredients for regular expressions. The full set
of regular expression primitives can be found in tutorial/WorkingWithStringPatterns.
Here c or cn, where n is a number, is a placeholder for an arbitrary character, and pn
is a placeholder for an arbitrary regular expression.
5.0 Introduction | 185

Table 5-2. Common regular expressions
Regular expression
Description
"@c1c2c3D"
"@c1-c2D"
"Matches any of the characters c1, c2, or c3.
For example,@AEIOUaeiouD matches vowels."
"Matches characters c1 through c2. For example,
@a-zD matches all lowercase letters."
"@^c1c2c3D"
"Matches any characters EXCEPT c1, c2, c3. For
example,@^AEIOUaeiouD matches nonvowels."
"c*"
"Zero or more occurrences
of character c. Greedy version."
"c+"
"One or more occurrences
of character c. Greedy version."
"c?"
"The character c or nothing Hi.e., zero
or one occurrencesL. Greedy version."
"c*?"
"Lazy version of c*."
"c+?"
"Lazy version of c+."
"c??"
"Lazy version of c?."
"p1»p2»...»pN"
"Matches p1 or p2 or ... pN."
"p1p2...pN"
"Matches p1, followed by p2, followed by ... pN."
"^p1"
"Matches p1 only at the start of the string."
"p1$"
"Matches p1 only at the end of the string."
"^p1$"
"Matches only if p1 matches the entire string."
"\\d"
"Any digit 0-9"
"\\s"
"Whitespace"
See Also
The definitive reference on regular expressions is Mastering Regular Expressions, Sec-
ond Edition, by Jeffrey E. F. Friedl (O’Reilly). If you plan to do anything nontrivial
using regular expression matching, you will save yourself hours of frustration by con-
sulting this book.
An  excellent  tutorial  on  working  with  string  patterns  in  Mathematica  can  be
found in the documentation under tutorial/WorkingWithStringPatterns or online at
http://bit.ly/yGbND. Besides being a good all-around tutorial, it has a section specifi-
cally targeting Perl programmers, which is helpful for those who already have experi-
ence with string manipulation in Perl.
186 | Chapter 5: String and Text Processing

5.1 Comparing Strings
Problem
You want to compare strings but Less, LessEqual, Greater, and GreaterEqual do not
work.
Solution
Use Order[e1,e2], which returns 1 if e1 is before e2, |1 if e1 is after e2, and 0 if they
are equal.
In[23]:=
Order@"rat", "rate"D
Out[23]=
1
In[24]:=
Order@"rat", "cat"D
Out[24]=
-1
Discussion
Most users of Mathematica will not find themselves doing direct string comparison
since functions like Sort and Ordering do the right thing. However, if you find your-
self needing to use the more natural comparison operators with strings, you can do
the following:
In[25]:=
Unprotect@Less, LessEqual, Greater, GreaterEqualD;
LessAs1_String, s2_StringE := Order@s1, s2D > 0;
LessEqualAs1_String, s2_StringE := Order@s1, s2D > -1;
GreaterAs1_String, s2_StringE := Order@s1, s2D < 0;
GreaterEqualAs1_String, s2_StringE := Order@s1, s2D < 1;
Protect@Less, LessEqual, Greater, GreaterEqualD;
In[31]:=
"rat" < "cat"
Out[31]=
False
In[32]:=
"cat" < "rat"
Out[32]=
True
In[33]:=
"cat" <= "cat"
Out[33]=
True
5.1 Comparing Strings | 187

5.2 Removing and Replacing Characters 
from Strings
Problem
You want to strip certain characters (e.g., whitespace) or characters at certain positions
from a string. You may also want to replace these characters with other characters.
Solution
Using patterns
StringReplace[] is an extremely versatile function that solves most character-oriented
stripping and replacing operations. It supports a very general set of string-substitution
rules, including regular expressions and Mathematica-specific string patterns.
Strip all spaces.
In[34]:=
myString = " The quick brown
fox
jumped over the lazy programmer
";
In[35]:=
StringReplaceAmyString, " " Ø ""E
Out[35]=
Thequickbrownfoxjumpedoverthelazyprogrammer
Strip leading and trailing whitespace.
In[36]:=
StringReplaceAmyString, RegularExpressionA"^\\s+»\\s+$"E Ø ""E êê InputForm
Out[36]//InputForm=
"The quick brown  fox   jumped over the lazy programmer"
Normalize whitespace: strip leading, trailing, and multiple internal whitespace.
In[37]:=
StringReplaceAmyString, 9RegularExpressionA"^\\s+»\\s+$"E Ø "",
RegularExpression@"\\s\\s+"D Ø " "=E êê InputForm
Out[37]//InputForm=
"The quick brown fox jumped over the lazy programmer"
Literal string substitution.
In[38]:=
StringReplaceAmyString, "the" Ø "a"E êê InputForm
Out[38]//InputForm=
" The quick brown  fox   jumped over a lazy programmer   "
Ignore case while matching.
In[39]:=
StringReplaceAmyString, "the" Ø "a", IgnoreCase Ø TrueE êê InputForm
Out[39]//InputForm=
" a quick brown  fox   jumped over a lazy programmer    "
Use Mathematica-specific patterns instead of regular expressions.
In[40]:=
StringReplaceAmyString, "ox" ~~ Whitespace Ø "ox "E
Out[40]=
The quick brown
fox jumped over the lazy programmer
188 | Chapter 5: String and Text Processing

Using positions
Sometimes you know exactly where the characters are that you want to remove. In
that case, StringDrop[] is a lot more efficient. StringDrop[] takes the string and a sec-
ond argument, which can be an offset from the front, an offset from the end, specific
positions, or a range of positions.
Consider:
In[41]:=
myString = "abcdefghijklmnop" ;
Here you drop the first three characters. 
In[42]:=
StringDropAmyString, 3E
Out[42]=
defghijklmnop
Alternatively, you drop the last three characters, like so.
In[43]:=
StringDropAmyString, -3E
Out[43]=
abcdefghijklm
Drop only the third character, like this.
In[44]:=
StringDropAmyString, 83<E
Out[44]=
abdefghijklmnop
And drop the third through fifth ("cde"), using a range list.
In[45]:=
StringDropAmyString, 83, 5<E
Out[45]=
abfghijklmnop
The step size in the range can even be greater than one by specifying it as the third
element. Here you specify a step size of two to remove every other character. The -1
upper limit is a convenient way to specify the end of the string without having to
know its length.
In[46]:=
StringDropAmyString, 81, -1, 2<E
Out[46]=
bdfhjlnp
You can also act on several strings at once.
In[47]:=
otherString = "1234567890";
In[48]:=
StringDropA9myString, otherString=, 83, 5<E
Out[48]=
9abfghijklmnop, 1267890=
The  positional  form  for  replacement  is  called  StringReplacePart[],  and  it  works
using similar conventions for specifying positions. The difference is that you must
always provide a contiguous range or a list of such ranges.
5.2 Removing and Replacing Characters from Strings | 189

In[49]:=
StringReplacePartAmyString, "ZZZ", 83, 5<E
Out[49]=
abZZZfghijklmnop
In[50]:=
StringReplacePartAmyString, "ZZZ", 883, 5<, 810, 15<<E
Out[50]=
abZZZfghiZZZp
Each range can also have its own replacement string.
In[51]:=
StringReplacePartAmyString, 8"ZZZ", "WWW"<, 883, 5<, 810, 15<<E
Out[51]=
abZZZfghiWWWp
Discussion
As you can see from the given examples, StringReplace is quite versatile. However,
the  versatility  is  derived  from  Mathematica’s  rich  support  for  patterns  (see
“Introduction”  on page 181). Here are some typical text-processing problems that
yield to the application of StringReplace[] and pattern matching.
Stripping comments
String expression version:
In[52]:=
StringReplaceA
"1 + 2 * 3.14 H*precise enough for our purpose*L ê 42 H*secret
of the universe*L", "H*" ~~ ShortestMatch@___D ~~ "*L" Ø ""E
Out[52]=
1 + 2 * 3.14
ê 42
Regular expression version:
In[53]:=
StringReplaceA
"1 + 2 * 3.14 H*precise enough for our purpose*L ê 42 H*secret of
the universe*L", RegularExpression@"\\H\\*.*?\\*\\L"D Ø ""E
Out[53]=
1 + 2 * 3.14
ê 42
Changing delimiters
Delimited text (e.g., comma-delimited text) sounds simple at first, but many delim-
ited formats allow a way to handle the delimiters as regular text by some quoting
mechanism, as well as a way to escape quotes themselves. Furthermore, you must
handle empty fields. If you want to replace a comma-delimited format with, say, a
semicolon-delimited  format,  you  must  craft  expressions  that  deal  with  all  cases.
Here,  ""  is  used  to  escape  a  double  quote.  This  example  does  not  handle  empty
fields, but see Friedl’s Mastering Regular Expressions for guidance. 
190 | Chapter 5: String and Text Processing

In[54]:=
delimitedText = "Ten Thousand,10000,
2710 ,\"10,000\",\"It's \"\"10 Grand\"\",baby\",10k";
StringJoinARiffleAStringCasesAdelimitedText,
RegularExpression@"H@^\",D+»\"H?:@^\"D»\"\"L*\"L"D ß
StringReplaceA"$1", "\"\"" ß "\""EE, ";"EE
Out[55]=
Ten Thousand;10000; 2710 ;"10,000";"It's "10 Grand",baby";10k
Removing XML markup
Simple XML manipulations, such as discarding markup, can be accomplished with
StringReplace[].
In[56]:=
NotebookDirectory@D
Out[56]=
êUsersêsmanganoêDocumentsêworkspaceêMathematica Cookbookêmathematicaê
In[57]:=
xml = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "data", "ch02", "data1.xml"=E, "Text"E
Out[57]=
<?xml version="1.0" encoding="UTF-8"?>
<!-- Some data to use as a test for Mathematica's XML import -->
<?test Just for didactic purposes?>
<data>
<item>
<name>Leonardo<êname>
<sex>male<êsex>
<age>8<êage>
<height>4.7<êheight>
<êitem>
<item>
<name>Salvatore<êname>
<sex>male<êsex>
<age>5<êage>
<height>4.1<êheight>
<êitem>
<item>
<name>Alexis<êname>
<sex>female<êsex>
<age>6<êage>
<height>4.4<êheight>
<êitem>
<êdata>
<!-- Comment at end -->
5.2 Removing and Replacing Characters from Strings | 191

In[58]:=
StringReplace@xml,
8Shortest@"<" ~~ Except@">"D .. ~~ ">"D .. Ø "", Whitespace Ø " "<D
Out[58]=
Leonardo male 8 4.7
Salvatore male 5 4.1
Alexis female 6 4.4
Replacing with expression evaluation
By capturing matched substrings in variables, you can perform expression evaluation
using ToExpression[] as you replace.
In[59]:=
expr = "Is 1 + 1 in every possible universe? What about Pi ê 2?" ;
In[60]:=
StringReplaceAexpr,
x : I9NumberString , "Pi"= ~~ Whitespace ... ~~ 8"*", "+", "-", "ê"< ~~
Whitespace ... ~~ 9NumberString , "Pi"=M ß
x <> " = " <> ToString@N@ToExpression@xDDDE
Out[60]=
Is 1 + 1 = 2. in every possible universe? What about Pi ê 2 = 1.5708?
Here is another example using dates.
In[61]:=
invoice =
"05ê17ê2008\nMathematica Programming: $1000.00\nInvoice is Net 30";
BlockA9datefmt = 9"Month", "ê", "Day", "ê", "Year"=, date=,
date = StringCases@invoice, DatePattern@datefmtDD;
StringReplaceAinvoice, "Net " ~~ n : NumberString ß "due " <> DateString@
DatePlus@DateList@date@@1DDD, ToExpression@nDD, datefmtDEE
Out[62]=
05ê17ê2008
Mathematica Programming: $1000.00
Invoice is due 06ê16ê2008
See Also
See  Recipe  2.4  for  use  of  StringPosition[],  which  returns  sequence  specification
that can be fed into StringReplacePart[] and StringDrop[].
See Recipes 2.8 and 2.9 for more sophisticated forms of XML processing. 
5.3 Extracting Characters and Substrings
Problem
You want to extract a substring by position or content from a string.
192 | Chapter 5: String and Text Processing

Solution
Using patterns
StringCases[] provides the pattern-driven means of extracting substrings. There are
two  major  variations.  In  the  first,  you  simply  extract  what  the  patterns  literally
match.  The  second  variation  uses  rules  to  transform  the  matched  substrings  into
other strings and return those instead.
You  can  extract  specific  words  using  regular  expressions  (here  \\b  matches  word
boundaries).
In[63]:=
StringCasesA"The pig thought he was a dog and then chased the cat.",
RegularExpression@"\\bHa»theL\\b"D, IgnoreCase Ø TrueE
Out[63]=
8The, a, the<
The same can be done using string expressions.
In[64]:=
StringCasesA"The pig thought he was a dog and then chased the cat.",
WordBoundary ~~ 8"a", "the"< ~~ WordBoundary, IgnoreCase -> TrueE
Out[64]=
8The, a, the<
The most common reason for using rules instead of patterns is to match a substring
within a specific context but return the substring alone. Here we want to return sub-
strings bracketed by one or more occurrences of the letter a. This example also illus-
trates that regular expressions and string expressions can be mixed. 
In[65]:=
StringCasesA"abacbcdbdaeaaazzza",
RegularExpression@"H?<=aL"D ~~
x : Repeated@Except@"a"DD ~~
RegularExpression@"H?=aL"D Ø xE
H*Return the characters surrounded by "a".*L
Out[65]=
8b, cbcdbd, e, zzz<
Using positions
Sometimes you know exactly where the characters are that you want to remove. In
that case, StringTake[] is a lot more efficient. StringTake[] takes the string and a sec-
ond argument, which can be an offset from the front, an offset from the end, specific
positions, or a range of positions.
Consider:
In[66]:=
myString = "abcdefghijklmnop" ;
5.3 Extracting Characters and Substrings | 193

Here you take the first three characters. 
In[67]:=
StringTakeAmyString, 3E
Out[67]=
abc
Alternatively, you take the last three characters, like so.
In[68]:=
StringTakeAmyString, -3E
Out[68]=
nop
Take only the third character, like this.
In[69]:=
StringTakeAmyString, 83<E
Out[69]=
c
And take the third through fifth ("cde") using a range list.
In[70]:=
StringTakeAmyString, 83, 5<E
Out[70]=
cde
The step size in the range can even be greater than one by specifying it as the third
element. Here you specify a step size of two to take every other character. The -1 upper
limit is a convenient way to specify the end of the string without having to know its length.
In[71]:=
StringTakeAmyString, 81, -1, 2<E
Out[71]=
acegikmo
Conveniently, you can also act on several strings at once.
In[72]:=
otherString = "1234567890";
In[73]:=
StringTakeA9myString, otherString=, 83, 5<E
Out[73]=
8cde, 345<
If you have read Recipe 5.2, you see that StringTake has very similar parameter varia-
tions as StringDrop[]. However, StringTake has an additional feature: it can take a
list of position specifications and produce a list of the resulting extracts. 
In[74]:=
StringTakeAmyString, 881<, 83<, 88, 10<<E
Out[74]=
9a, c, hij=
This is useful for picking multiple segments from a string in one step. However, if
you want a string rather than a list, simply wrap the expression in a StringJoin[].
In[75]:=
StringJoinAStringTakeAmyString, 881<, 83<, 88, 10<<EE
Out[75]=
achij
194 | Chapter 5: String and Text Processing

Discussion
In the “Solution” section on page 193 we used RegularExpression["(?<=a)"] (look-
behind) and RegularExpression["(?=a)"] (look-ahead) because there is no string-
expression equivalent.  However,  there  is  an  option  for  StringCases[]  called  Over-
laps, which when set to True, causes the matcher to continue at the character that
follows the first character of the last matched substring. In the following example,
this allows a single a to act as both a start of pattern and end of pattern. 
In[76]:=
StringCases@"abacbcdbdaeaaazzza",
"a" ~~ x : Repeated@Except@"a"DD ~~ "a" Ø x, Overlaps Ø TrueD
Out[76]=
8b, cbcdbd, e, zzz<
Without OverlapsØTrue, you would not get the "cbcbd" substring.
In[77]:=
StringCases@"abacbcdbdaeaaazzza",
"a" ~~ x : Repeated@Except@"a"DD ~~ "a" Ø xD
Out[77]=
8b, e, zzz<
There is a third setting, OverlapsØAll, which causes the matcher to repeat searches
from the same position until no new matches are found. To see the effect of All, we
need to consider a different example, one in which the bracketing character is not ex-
cluded from the match. A parenthesized expression is a good example. 
In[78]:=
StringCasesA"HHa-bL Hc + dL He ê Hf + gLLL",
Shortest@"H" ~~ __ ~~ "L"D , Overlaps Ø FalseE êê TableForm
Out[78]//TableForm=
HHa-bL
Hc + dL
He ê Hf + gL
In[79]:=
StringCasesA"HHa-bL Hc + dL He ê Hf + gLLL",
Shortest@"H" ~~ __ ~~ "L"D , Overlaps Ø TrueE êê TableForm
Out[79]//TableForm=
HHa-bL
Ha-bL
Hc + dL
He ê Hf + gL
Hf + gL
In[80]:=
StringCasesA"HHa-bL Hc + dL He ê Hf + gLLL",
Shortest@"H" ~~ __ ~~ "L"D , Overlaps Ø AllE êê TableForm
5.3 Extracting Characters and Substrings | 195

Out[80]//TableForm=
HHa-bL
HHa-bL Hc + dL
HHa-bL Hc + dL He ê Hf + gL
HHa-bL Hc + dL He ê Hf + gLL
HHa-bL Hc + dL He ê Hf + gLLL
Ha-bL
Ha-bL Hc + dL
Ha-bL Hc + dL He ê Hf + gL
Ha-bL Hc + dL He ê Hf + gLL
Ha-bL Hc + dL He ê Hf + gLLL
Hc + dL
Hc + dL He ê Hf + gL
Hc + dL He ê Hf + gLL
Hc + dL He ê Hf + gLLL
He ê Hf + gL
He ê Hf + gLL
He ê Hf + gLLL
Hf + gL
Hf + gLL
Hf + gLLL
See Also
If you have a list of strings and want to extract those that match a pattern, you want
Select, using StringMatchQ with a string pattern as the test, rather than StringCases. See
Recipe 4.1.
5.4 Duplicating a String 
Problem
You need to synthesize a string from a fixed number of copies of a seed string.
Solution
Use StringJoin[] on the output of Table[].
In[81]:=
stringDup@seed_, n_: 2D := StringJoinüArray@seed &, nD
In[82]:=
stringDup@"-", 10D êê InputForm
Out[82]//InputForm=
"----------"
In[83]:=
stringDup@"wiki "D
Out[83]=
wiki wiki
196 | Chapter 5: String and Text Processing

Discussion
This is a simple recipe, and I include it because it’s something you expect to be bun-
dled as a native function, but it’s not. For most practical applications, the solution is
fine, but for very large n, a doubling approach will have better performance. Rather
than doing the math to get the exact string size, we simply truncate the closest sized
string obtained from pure doubling of the seed.
In[84]:=
stringDup2@seed_, n_D :=
StringTakeANestAÒ <> Ò &, seed, CeilingALog@2, nDE E, nE
In[85]:=
MeanATableATimingAstringDup@"-", 100 000DE@@1DD, 810<EE
Out[85]=
0.0486878
In[86]:=
MeanATableATimingAstringDup2@"-", 100 000DE@@1DD, 810<EE
Out[86]=
0.0031014
This solution may not be obvious, so let’s break it down. It should be clear that map-
ping the function #<>#& to a list containing a string will double that string (recall that
<> is string concatenation).
In[87]:=
Ò <> Ò & êü 8"-"<
Out[87]=
8--<
It follows that doing this twice will quadruple it.
In[88]:=
Ò <> Ò & êü HÒ <> Ò & êü 8"-"<L
Out[88]=
8----<
Repeating this process m times will create a string of length 2^m. However, the input
is the desired length n, not the number of doublings, so we know we need at least
Ceiling[Log[2, n]] doublings; by using Nest with this number, we get exactly that.
However, this overshoots the desired length in most cases, because we rarely expect
n to be an exact power of 2. So we use Take to extract the correct length. The reason
this is fast for large n is that it reduces a O(n) operation in terms of Table to a O(log n)
operation using StringJoin.
You  can  bundle  these  versions  together  into  one  function  that  gives  good  perfor-
mance across all sizes.
In[89]:=
ClearAstringDupE;
stringDupAseed_String, n_Integer ê; n >= 2^12E :=
StringTakeANestAÒ <> Ò &, seed, CeilingALog@2, nDE E, nE
stringDupAseed_String, n_Integer: 2E := StringJoinüArray@seed &, nD
5.4 Duplicating a String | 197

See Also
Nest is discussed in Recipe 2.11.
5.5 Matching and Searching Text
Problem
You want to determine if a string contains a pattern and at what positions.
Solution
Use StringMatchQ[string,pattern] to determine if a string matches a pattern. 
In[92]:=
StringMatchQA"1234", NumberStringE
Out[92]=
True
Here I show a match on multiple strings with a pattern that is predicated.
In[93]:=
StringMatchQA8"1234", "1237"<, p : NumberString ê; OddQAFromDigits@pDEE
Out[93]=
8False, True<
Use StringFreeQ[string,pattern] to determine if a string does not match a pattern.  
In[94]:=
StringFreeQA8"1234", "abcde"<, p : NumberStringE
Out[94]=
8False, True<
Use StringPosition[string,pattern] to find the integer offsets of matches. The de-
fault behavior is to search for all occurrences of the pattern (i.e., Overlaps Ø True).
In[95]:=
StringPositionA"1234abcd54321", NumberStringE
Out[95]=
881, 4<, 82, 4<, 83, 4<, 84, 4<,
89, 13<, 810, 13<, 811, 13<, 812, 13<, 813, 13<<
With Overlaps Ø False, you only get matches on substrings that don’t share charac-
ters with prior matches.
In[96]:=
StringPositionA"1234abcd54321", NumberString, Overlaps Ø FalseE
Out[96]=
881, 4<, 89, 13<<
198 | Chapter 5: String and Text Processing

Discussion
StringMatchQ[] and StringFreeQ[] very often find application in restricting inputs to
functions.
In[97]:=
classifyAword_String ê; StringMatchQAword, 9"I", "me", "we",
"you", "they", "him", "her", "it"=EE := pronoun@wordD
classifyAword_String ê; StringMatchQAword, 9"and", "or", "nor",
"after," "although," "as," "because," "before," "how," "if,"
"once," "since," "than," "that," "though," "till," "until,"
"when," "where," "whether,", "while"=EE := conjunction@wordD
classifyAword_String ê; StringMatchQAword, DatePatternA9"DayName"=EEE :=
dayofweek@wordD
classifyAword_String ê; StringMatchQ@word, DatePattern@8"MonthName"<DDE :=
month@wordD
H*...*L
classifyAword_StringE := other@wordD ;
You can also use them as input to other functions, like Pick[] in the following grep
implementation  adapted  from  an  example  in  Mathematica  documentation.  Recall
that in the standard Unix grep, option -v instructs grep to return lines that don’t
match the pattern. Here Transpose and Range are used to number each line so the re-
sult contains a list of pairs {line, match text}. This grep function was implemented
in terms of StringFreeQ rather than StringMatchQ since the latter only succeeds if the
entire string matches.
In[102]:=
grep@file_, patt_, "-v"D := grepImpl@file, patt, True D
grep@file_, patt_D := grepImpl@file, patt, FalseD
grepImpl@file_, patt_, value_D := WithA8data = Import@file, "Lines"D<,
PickATransposeA9RangeALength@dataDE, data=E,
StringFreeQAdata, RegularExpression@pattDE, valueEE
In[105]:=
grepAFileNameJoinA9NotebookDirectory@D, "greptest.txt"=E, "bar"E êê
TableForm
Out[105]//TableForm=
1 bar
4 foo bar
5 foobar
6 barfo
In[106]:=
grepAFileNameJoinA9NotebookDirectory@D, "greptest.txt"=E, "bar$"E
Out[106]=
881, bar<, 84, foo bar<, 85, foobar<<
In[107]:=
grepAFileNameJoinA9NotebookDirectory@D, "greptest.txt"=E, "bar", "-v"E
Out[107]=
882, foo<, 83, baz<, 87, fo o<<
5.5 Matching and Searching Text | 199

Both  StringMatchQ[]  and  StringFreeQ[]  support  the  IgnoreCase  Ø  True  option.
StringMatchQ  also  supports  option  SpellingCorrection  Ø  True,  which  allows  the
match to succeed even if a small number of characters are wrong. However, in many
cases a small number can mean only 1, as the following example demonstrates, so I
would not rely too heavily on this “feature.”
In[108]:=
StringMatchQA"mississippi", "missisippi", SpellingCorrection Ø TrueE
Out[108]=
True
In[109]:=
StringMatchQA"mississippi", "misisipi", SpellingCorrection Ø TrueE
Out[109]=
False
The output of StringPosition[] can be used as the input to StringTake. 
In[110]:=
WithA8str = "1234abcd54321"<,
StringTakeAstr, StringPositionAstr, NumberStringEEE
Out[110]=
81234, 234, 34, 4, 54321, 4321, 321, 21, 1<
If you want to use it with StringDrop[], you need to map StringDrop[] over the list
returned by StringPosition[]. This will give you a list with each matching segment
dropped. More than likely, you will want to set Overlaps Ø False in this case. Try
Overlaps Ø True with the expression given below to see why it is undesirable.
In[111]:=
WithA8str = "1234abcd54321"<, StringDrop@str, ÒD & êü
StringPositionAstr, NumberString, Overlaps Ø FalseEE
Out[111]=
8abcd54321, 1234abcd<
See Also
See Recipes 5.3 and 5.2 for usage of StringTake[] and StringDrop[]. 
200 | Chapter 5: String and Text Processing

5.6 Tokenizing Text
Problem
You want to break a string into tokens based on a character or pattern.
Solution
StringSplit[] provides a variety of options for tokenizing text. The default is simply
to tokenize on whitespace.
In[112]:=
StringSplitA"The quick brown fox\njumped over the lazy programmer"E
Out[112]=
9The, quick, brown, fox, jumped, over, the, lazy, programmer=
Other delimiters can be specified as literals or more general patterns. Here you spec-
ify comma delimiters with zero or more whitespace characters.
In[113]:=
StringSplit@"2008ê01ê20, test1, 100.3, 77.8,33.77",
"," ~~ WhitespaceCharacter ...D
Out[113]=
82008ê01ê20, test1, 100.3, 77.8, 33.77<
If there are several delimiters, give each pattern in a list. Here you decide to parse the
date along with the comma-delimited text.
In[114]:=
StringSplit@"2008ê01ê20, test1, 100.3, 77.8,33.77",
8"," ~~ WhitespaceCharacter ..., "ê"<D
Out[114]=
82008, 01, 20, test1, 100.3, 77.8, 33.77<
Discussion
StringSplit supports rules as well as patterns, which leads to some interesting ap-
plications, such as a means of highlighting output. Here is an example that stylizes XML
by rendering directives, comments, and tags in specific font styles and colors. (The
colors will not be visible in a monochrome print, but you can try the code on your
own to see the effect.)
5.6 Tokenizing Text | 201

In[115]:=
StringSplitAImportA
FileNameJoinA9NotebookDirectory@D, "..", "data", "ch02", "data1.xml"=E,
"text"E, 9x : H"<!--" ~~ Except@">"D .. ~~ ">"L ß
Style@x, FontSlant Ø Italic, FontColor Ø BrownD,
x : H"<?" ~~ Except@">"D .. ~~ ">"L ß Style@x, FontColor Ø RedD,
x : H"<" ~~ Except@">"D .. ~~ ">"L ß
StyleAx, FontWeight Ø Bold, FontColor Ø BlueE=E êê Row
Out[115]=
<?xml version="1.0" encoding="UTF-8"?>
<!-- Some data to use as a test for Mathematica's XML import -->
<?test Just for didactic purposes?>
<data>
<item>
<name>Leonardo<êname>
<sex>male<êsex>
<age>8<êage>
<height>4.7<êheight>
<êitem>
<item>
<name>Salvatore<êname>
<sex>male<êsex>
<age>5<êage>
<height>4.1<êheight>
<êitem>
<item>
<name>Alexis<êname>
<sex>female<êsex>
<age>6<êage>
<height>4.4<êheight>
<êitem>
<êdata>
<!-- Comment at end -->
5.7 Working with Natural Language Dictionaries
Problem
You want to do some simple linguistic processing driven by a reliable lexicon. 
Solution
As of version 6, Mathematica comes bundled with many useful data sources. One of
these sources is an integrated English language dictionary (dictionaries for other lan-
guages can be installed). 
202 | Chapter 5: String and Text Processing

Look up words that begin with th and end with y.
In[116]:=
DictionaryLookupA"th" ~~ ___ ~~ "y"E
Out[116]=
9thankfully, thanklessly, theatricality, theatrically,
thematically, theocracy, theologically, theology, theoretically,
theory, theosophy, therapeutically, therapy, thereby, thermally,
thermodynamically, thermostatically, they, thickly, thievery,
thingummy, thingy, thinly, thirdly, thirstily, thirsty, thirty, thorny,
thoroughly, thoughtfully, thoughtlessly, thready, threateningly,
threepenny, threnody, thriftily, thrifty, thrillingly, throatily,
throaty, throwaway, thruway, thuggery, thunderously, thundery, thy=
Look up words that end in ee.
In[117]:=
DictionaryLookup@___ ~~ "ee"D
Out[117]=
9absentee, addressee, agree, Aimee, Albee, amputee, apogee, appointee,
Ashlee, attendee, Attlee, axletree, banshee, bee, bootee, bumblebee,
bungee, carefree, Chattahoochee, Cherokee, chickadee, chimpanzee,
coffee, committee, conferee, consignee, coulee, Cree, debauchee, decree,
Dee, degree, deportee, Desiree, detainee, devotee, disagree, divorcee,
draftee, Dundee, dungaree, Elysee, emcee, employee, enlistee, entree,
epee, escapee, evacuee, fat-free, fee, fiancee, filigree, flee, foresee,
franchisee, free, fricassee, Frisbee, fusee, Galilee, garnishee, gee, ghee,
glee, goatee, grandee, grantee, guarantee, gumtree, honeybee, honoree,
Humvee, inductee, internee, interviewee, invitee, jamboree, Jaycee,
jubilee, kedgeree, Klee, knee, lee, Lee, legatee, Legree, lessee, levee,
licensee, manatee, marquee, matinee, McGee, McKee, melee, Menominee,
Milwaukee, mortgagee, Murrumbidgee, Muskogee, nee, negligee, nominee,
Okeechobee, Okefenokee, oversee, parolee, Pawnee, payee, pedigree, pee,
peewee, Pelee, perigee, pewee, pharisee, Pharisee, pongee, prithee,
protegee, puree, puttee, quadtree, ranee, referee, refugee, Renee,
repartee, retiree, returnee, Rhee, rupee, Sadducee, scree, see, settee,
Shawnee, Sheree, shoetree, singletree, sirree, Slurpee, soiree, spree,
squeegee, standee, subcommittee, subtree, suttee, Suwanee, Swanee,
Tallahassee, tee, Tennessee, tepee, thee, three, toffee, toll-free, topee,
toupee, towhee, townee, Toynbee, trainee, transferee, tree, trochee,
Truckee, trustee, Tuskegee, twee, Tweedledee, Tyree, wannabee, wee, whee,
whiffletree, whippletree, whoopee, Yahtzee, Yankee, yippee, Zebedee=
5.7 Working with Natural Language Dictionaries | 203

Discussion
There are a lot of neat applications for an integrated dictionary. 
Crossword puzzles
Here is how you might cheat at a crossword puzzle. Say you have three letters of a
six-letter word and the clue is “51 down: unkeyed.”
In[118]:=
DictionaryLookup@"a" ~~ _ ~~ "o" ~~ _ ~~ _ ~~ "l"D
Out[118]=
8amoral, atonal, avowal<
Ah, atonal sounds right (pun intended)!
Anagrams
You can also help your second grader impress the teacher on that November work-
sheet for finding all the words you can make out of the letters in “Thanksgiving”
(i.e., anagrams). Here we use a pattern containing all combinations of the letters in
“thanksgiving” and an extra constraint function to ensure letters are contained by
their availability (count). Strictly speaking, an anagram must use all the letters of the
input, but I ignore that here.
In[119]:=
thanksgivingQ@word_D := StringCount@word, "t"D < 2 &&
StringCount@word, "h"D < 2 && StringCount@word, "a"D < 2 &&
StringCount@word, "n"D < 3 && StringCount@word, "k"D < 2 &&
StringCount@word, "s"D < 2 && StringCountAword, "g"E < 3 &&
StringCount@word, "i"D < 3 && StringCount@word, "v"D < 2 ;
In[120]:=
DictionaryLookupA
word : I"t"
"h"
"a"
"n"
"k"
"s"
"g"
"i"
"v" M .. ê;
thanksgivingQ@wordD, IgnoreCase Ø True E
204 | Chapter 5: String and Text Processing

Out[120]=
9a, aging, agings, Agni, ah, Aisha, akin, Akita, an, Ana, angst, Anita, ankh,
ankhs, Ann, Anna, ans, Anshan, ant, anti, anting, antis, ants, as, ash,
Ashanti, ashing, Asia, Asian, ask, asking, at, Atkins, Ava, Avis, gag,
gags, gain, gaining, gains, gait, gaits, gang, gangs, gas, gash, gashing,
gating, Gavin, ghat, ghats, Ghats, GI, giant, giants, gig, gigs, gin,
Gina, gins, Gish, gist, git, gits, giving, givings, gnash, gnashing,
gnat, gnats, gs, ha, hag, haggis, hags, Hahn, Haiti, Han, hang, hanging,
hangings, hangs, hank, Hank, hanks, Hans, has, hast, hasting, hat, hating,
hats, having, hi, Higgins, hiking, hinging, hint, hinting, hints, his,
histing, hit, hits, HIV, hiving, I, Ian, in, Ina, ink, inking, inks, inn,
innit, inns, ins, insight, inti, is, Isa, Isiah, it, IT, its, Iva, Ivan,
Kan, Kans, Kant, khan, Khan, khans, kin, king, King, kings, Kings, kins,
kit, Kit, kith, kithing, kiths, kiting, kits, knavish, knight, Knight,
knighting, knights, knish, knit, knits, ks, nag, nags, nah, nan, Nan,
nans, NASA, Nash, Nat, nigh, night, nights, Nikita, Nina, ninth, ninths,
Nisan, nit, Nita, nits, nth, sag, saint, saith, Saki, Saks, San, sang,
Sang, saning, sank, Sask, sat, SAT, satin, sating, satining, saving, sh,
shag, shaking, shank, shat, shaving, shin, shining, shiv, Shiva, sigh,
sighing, sight, sighting, sign, signing, Sikh, Sikhs, sin, Sinai, sing,
singing, sink, Sinkiang, sinking, sit, siting, Siva, Sivan, ska, skating,
ski, skiing, skin, skint, skit, skiting, skiving, snag, snaking, snit,
stag, staging, stain, staining, staking, Stan, stank, staving, sting,
stinging, stink, stinking, ta, tag, tags, Tahiti, taking, takings, tan,
tang, tangs, tank, tanking, tanks, tans, task, tasking, Thai, Thais,
than, thank, thanking, thanks, thanksgiving, Thanksgiving, Thant, thin,
thing, things, think, thinking, thinks, thins, this, ti, Tia, tin, Tina,
ting, Ting, tinging, tings, tining, tins, Tisha, Titan, Titans, Titian,
TNT, ts, TV, TVs, vain, van, Van, Vang, vanish, vanishing, vans, vast,
vat, VAT, vats, VHS, via, viking, Viking, vikings, Vikings, vining,
visa, Visa, visaing, vising, visit, vista, vistaing, vita, Vivian, vs=
Using Tally[] to count letter occurrences and doing a bit of set manipulation, we
can generalize this for any word. The condition checking for the empty complement
at the end is not strictly needed here because we will never match a word in the dic-
tionary that has a letter that is not in the input word. However, it is needed to make
the logic if isWordSubsetQ[] is correct as a general predicate.
5.7 Working with Natural Language Dictionaries | 205

In[121]:=
isWordSubsetQ@word1_, word2_D :=
BlockA9tally1 = Tally@Characters@word1DD,
tally2 = Tally@Characters@word2DD=,
And üü MapThreadAHÒ1@@2DD ¥ Ò2@@2DDL &, 9IntersectionAtally1,
tally2, SameTest Ø HÒ1@@1DD === Ò2@@1DD &LE, IntersectionA
tally2, tally1, SameTest Ø HÒ1@@1DD === Ò2@@1DD &LE=E &&
Complement@Characters@word2D, Characters@word1DD === 8<E
In[122]:=
isWordSubsetQA"thanksgiving", "visa"E
Out[122]=
True
In[123]:=
isWordSubsetQA"thanksgiving", "pork"E
Out[123]=
False
In[124]:=
anagrams@word_D := DictionaryLookupA
w : Characters@wordD .. ê; isWordSubsetQ@word, wD, IgnoreCase Ø TrueE
You can test the generality against other words.
In[125]:=
anagrams@"winter"D
Out[125]=
8en, er, in, inert, inter, ire, it, net, new, newt, nit, niter, re, rein, rent,
rite, ten, tern, ti, tie, tier, tin, tine, tire, twin, twine, twiner, we,
weir, wen, went, wet, win, wine, winter, wire, wit, wren, writ, write<
In[126]:=
anagramsA"dog"E
Out[126]=
9do, dog, go, god=
Palindromes
Here is a neat little palindrome finder (courtesy of the Mathematica documentation).
In[127]:=
DictionaryLookupAx__ ê; x === StringReverse@xDE
Out[127]=
9a, aha, aka, bib, bob, boob, bub, CFC, civic, dad, deed, deified,
did, dud, DVD, eke, ere, eve, ewe, eye, gag, gig, huh, I, kayak,
kook, level, ma'am, madam, mam, MGM, minim, mom, mum, nan, non, noon,
nun, oho, pap, peep, pep, pip, poop, pop, pup, radar, redder, refer,
repaper, reviver, rotor, sagas, sees, seres, sexes, shahs, sis,
solos, SOS, stats, stets, tat, tenet, TNT, toot, tot, tut, wow, WWW=
Spell-checker
By using all the words in the dictionary with Nearest[], you can create a rudimen-
tary  spell-checker.  For  our  first  attempt,  we’ll  use  Nearest’s  default  distance  func-
tion. We’ll return a list for which the first element is True or False depending on the
word’s inclusion in the dictionary and the second element is a list of potential cor-
rect spellings. 
206 | Chapter 5: String and Text Processing

In[128]:=
nf1 = NearestADictionaryLookup@DE;
SpellCheck1@word_D := Module@8corrections = nf1@word, 15D<,
If@ MemberQ@ corrections, wordD, 8True, word<, 8False, corrections<DD
In[130]:=
SpellCheck1@"pickel"D
Out[130]=
9False, 9nickel, picked, picker, picket, bicker, dicker, dickey,
hickey, kicked, kicker, licked, Michel, mickey, Mickey, nicked==
We see that the default distance function used for strings (EditDistance) does not
make the greatest spell-checker: the obvious suggestion of pickle is not among the
first 15 nearest words. You can experiment with other distance functions. Here is
one that penalizes more heavily for mistakes in consonants than for mistakes in vowels. 
In[131]:=
SpellDistance@a_, b_D := ModuleA
8vowelpat = H"a"
"e"
"i"
"o"
"u"L Ø ""<, EditDistance@a, bD +
EditDistanceAStringReplace@a, vowelpatD, StringReplace@b, vowelpatDEE
nf2 = NearestADictionaryLookup@D, DistanceFunction Ø SpellDistanceE;
SpellCheck2@word_D := Module@8corrections = nf2@word, 10D<,
If@ MemberQ@ corrections, wordD, 8True, word<, 8False, corrections<DD
In[134]:=
SpellCheck2@"pickel"D
Out[134]=
8False, 8nickel, picked, picker,
picket, pickle, packed, packer, packet, pecked, pick<<
Here we test on some commonly misspelled words (according to the Oxford Dictio-
naries website: http://bit.ly/KuIQ2) .
In[135]:=
SpellCheck2@"accomodate"D
Out[135]=
8False, 8accommodate, accommodated, accommodates, accumulate, accelerate,
accentuate, acclimate, accolade, accommodation, accordant<<
In[136]:=
SpellCheck2@"alcahol"D
Out[136]=
9False, 9alcohol, alcohols, alcoholic,
achoo, ahchoo, algal, anchor, carol, lethal, local==
In[137]:=
SpellCheck2@"mispell"D
Out[137]=
9False, 9misspell, Aspell, Ispell, miscall,
respell, spell, dispel, dispels, misdeal, misplay==
This returns useful results, but performance (speed) is poor. 
In[138]:=
SpellCheck2@"pickel"D êê Timing
Out[138]=
82.22533, 8False, 8nickel, picked, picker,
picket, pickle, packed, packer, packet, pecked, pick<<<
5.7 Working with Natural Language Dictionaries | 207

We can improve the speed using a divide-and-conquer approach: pick a large but
manageable number (e.g., 100) of nearest words according to simple EditDistance,
and then do a second pass on the smaller set with the EditDistance sans vowels. We
define a distance function called ConsonantDistance[] for the second pass.
In[139]:=
ConsonantDistance@a_, b_D :=
ModuleA8vowelpat = H"a"
"e"
"i"
"o"
"u"L Ø ""<,
EditDistanceAStringReplace@a, vowelpatD, StringReplace@b, vowelpatDEE
In[140]:=
SpellCheck3@word_D :=
Module@8corrections, corrections2, nf<, corrections = nf1@word, 100D;
nf = Nearest@corrections, DistanceFunction Ø ConsonantDistanceD;
corrections2 = nf@word, 10D;
If@ MemberQ@ corrections2, wordD, 8True, word<, 8False, corrections2<DD
In[141]:=
SpellCheck3@"pickel"D êê Timing
Out[141]=
80.055973, 8False, 8pickle, nickel, picked,
picker, picket, packed, packer, packet, pecked, pick<<<
Good results and about 43 times faster! 
Mathematica also provides WordData[], which returns information about properties
of words, such as parts of speech and definitions. 
In[142]:=
WordData@"run"D
Out[142]=
98run, Noun, Score<, 8run, Noun, Travel<, 9run, Noun, RegularTrip=,
8run, Noun, ShortTrip<, 9run, Noun, FootballPlay=, 8run, Noun, Endeavor<,
8run, Noun, Successiveness<, 8run, Noun, Flow<, 9run, Noun, Damage=,
8run, Noun, Footrace<, 9run, Noun, Campaign=, 8run, Noun, Streak<,
8run, Noun, Stream<, 9run, Noun, IndefiniteQuantity=,
9run, Noun, Liberty=, 8run, Noun, TimePeriod<, 9run, Verb, Disintegrate=,
8run, Verb, SplitUp<, 8run, Verb, Dissolve<, 8run, Verb, Treat<,
9run, Verb, Change=, 8run, Verb, Get<, 8run, Verb, Vie<, 8run, Verb, Race<,
8run, Verb, Catch<, 8run, Verb, Draw<, 8run, Verb, Operate<,
8run, Verb, Function<, 9run, Verb, CarryThrough=, 9run, Verb, Play=,
8run, Verb, Circularize<, 8run, Verb, Trip<, 9run, Verb, GoThrough=,
9run, Verb, Hurry=, 9run, Verb, TravelRapidly=, 8run, Verb, Sport<,
9run, Verb, Accompany=, 8run, Verb, Sail<, 8run, Verb, SpreadOut<,
8run, Verb, Flow<, 9run, Verb, GoAway=, 8run, Verb, Displace<,
9run, Verb, MoveFreely=, 8run, Verb, Trade<, 8run, Verb, Loose<,
8run, Verb, Direct<, 8run, Verb, Succeed<, 8run, Verb, Implement<,
8run, Verb, Occur<, 8run, Verb, Continue<, 8run, Verb, Endure<,
8run, Verb, Extend<, 8run, Verb, MakePass<, 8run, Verb, Lean<,
8run, Verb, Incur<, 8run, Verb, Go<, 9run, Verb, Range==
208 | Chapter 5: String and Text Processing

See Also
Readers  interested  in  spell-checkers  should  check  out  this  approach  (written  in
Python) by Peter Norvig of Google: http://bit.ly/19gyjN. 
5.8 Importing XML 
Problem
You want to import and manipulate XML data in Mathematica.
Solution
Use  Import[]  with  format  "XMLObject"  to  import  XML  and  convert  it  to  a  special
Mathematica  expression  form.  Consider  the  following  XML  in  file  data1.xml
(available for download at the book’s website).
<?xml version="1.0" encoding="UTF-8"?>
<!-- Some data to use as a test for Mathematica's XML import -->
<?test Just for didactic purposes?>
<data>
<item>
<name>Leonardo</name>
<sex>male</sex>
<age>8</age>
<height>4.7</height>
</item>
<item>
<name>Salvatore</name>
<sex>male</sex>
<age>5</age>
<height>4.1</height>
</item>
<item>
<name>Alexis</name>
<sex>female</sex>
<age>6</age>
<height>4.4</height>
</item>
</data>
5.8 Importing XML | 209

In[143]:=
data = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "data", "ch02", "data1.xml"=E, "XMLObject"E
Out[143]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<, 9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex, 8<, 8male<D,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElement@sex, 8<, 8male<D, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElement@sex, 8<, 8female<D,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=E,
9XMLObject@CommentD@ Comment at end D=E
Discussion
Mathematica imports XML into expression form. You can manipulate the ex-
pression just like you would any other Mathematica expression, but first you
need to understand the structure, which is a bit unconventional. Mathematica
uses  two  types  of  heads  to  encode  XML.  XMLObject["type"]  is  used  to  repre-
sent everything that is not an element, including the entire document (type =
"Document"),  comments  (type  =  "Comment"),  CDATA  sections  (type  =
"CDATASection"), processing instructions (type = "ProcessingInstruction"), decla-
rations  (type  =  "Declaration"),  and  document types  (type  =  "Doctype").  In  the
XML above, you see examples for document, declaration, comment, and process-
ing instruction. XMLElement[tag,{attr1Øval1,...},{data1,...}] is used to represent
element data for both simple (text values) and complex element types (those with
child elements). Don’t get tripped up by the XMLObject notation. The entire syntax
XMLObject["type"] is the head of the expression, while the remainder is a sequence
of one or more arguments that depends on the type.
In[144]:=
Head@dataD êê InputForm
Out[144]//InputForm=
XMLObject["Document"]
The document version consists of three arguments: a list containing the declaration
and possibly other objects, the document content, and a list of any objects (such as
comments) that might appear past the last XML element. A very crude way to access
structure is through Part[] or, equivalently, [[n]].
210 | Chapter 5: String and Text Processing

In[145]:=
data@@1DD
Out[145]=
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=
In[146]:=
data@@2DD
Out[146]=
XMLElementAdata, 8<, 9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex, 8<, 8male<D,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElement@sex, 8<, 8male<D, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElement@sex, 8<, 8female<D,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=E
In[147]:=
data@@3DD
Out[147]=
9XMLObject@CommentD@ Comment at end D=
In[148]:=
data@@2DD@@1DD H*The tag of the root element*L
Out[148]=
data
In[149]:=
data@@2DD@@3DD@@1DD H*The first child*L
Out[149]=
XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex, 8<, 8male<D,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E
Pattern matching is much more elegant and more resilient to changes in document
structure. Here we extract male elements using Cases with a pattern and an infinite
level specification. This is roughly equivalent to using XPath in native XML processing.
In[150]:=
CasesAdata, XMLElement@_, _, 8_, XMLElement@"sex", _, 8"male"<D, ___<D,
InfinityE êê TableForm
Out[150]//TableForm=
XMLElement@item, 8<, 8XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex,
8<, 8male<D, XMLElement@age, 8<, 88<D, XMLElement@height, 8<, 84.7<D<D
XMLElement@item, 8<, 8XMLElement@name, 8<, 8Salvatore<D, XMLElement@sex,
8<, 8male<D, XMLElement@age, 8<, 85<D, XMLElement@height, 8<, 84.1<D<D
5.8 Importing XML | 211

Sometimes, the XMLObject and XMLElement notation can be a bit too heavy, and it is
easier to work with simple nested lists. This can be done with Apply plus List, speci-
fying all levels.
In[151]:=
list = ApplyAList, data, 90, Infinity=E
Out[151]=
9998Version, 1.0<, 9Encoding, UTF-8==,
8 Some data to use as a test for Mathematica's XML import <,
8test, Just for didactic purposes<=, 9data, 8<,
99item, 8<, 98name, 8<, 8Leonardo<<, 8sex, 8<, 8male<<, 9age, 8<, 88<=,
9height, 8<, 84.7<===, 9item, 8<, 98name, 8<, 8Salvatore<<,
8sex, 8<, 8male<<, 9age, 8<, 85<=, 9height, 8<, 84.1<===,
9item, 8<, 98name, 8<, 8Alexis<<, 8sex, 8<, 8female<<,
9age, 8<, 86<=, 9height, 8<, 84.4<=====, 88 Comment at end <<=
This can shorten the patterns needed to extract content.
In[152]:=
CasesAlist, 8___, 8"sex", _, 8"male"<<, ___<, InfinityE
Out[152]=
998name, 8<, 8Leonardo<<, 8sex, 8<, 8male<<,
9age, 8<, 88<=, 9height, 8<, 84.7<==, 98name, 8<, 8Salvatore<<,
8sex, 8<, 8male<<, 9age, 8<, 85<=, 9height, 8<, 84.1<===
Another useful transformation is to change all heads to the symbolic form of
the element tag. Here we use //. (ReplaceAll) with rules that strip XMLObject and
convert XMLElement expressions. I show the output in tree form to make it clear what
this transformation does. 
In[153]:=
data êê. 9XMLObject@"Document"D@_, content_, _D ß content,
XMLElement@"data", attrs_, content_D ß XMLElement@"items",
attrs, contentD, XMLElementAtag_String, _, 8content___<E ß
SymbolAtagE üü 8content<= êê TreeFormAÒ, ImageSize Ø 600E &
Out[153]//TreeForm=
items
item
name
Leonardo
sex
male
age
8
height
4.7
item
name
Salvatore
sex
male
age
5
height
4.1
item
name
Alexis
sex
female
age
6
height
4.4
212 | Chapter 5: String and Text Processing

When converting strings to symbols, you need to be cognizant of whether a
symbol already exists and has a value. This bit me when I was preparing this
recipe, because I failed to recognize that the top-level element tag name was
“data,”  which,  of  course,  turned  out  to  be  the  name  of  the  variable
that I was transforming. Infinite recursion! The solution was to include
the  transformation  from  XMLElement["data",  attrs_,  content_]  to
XMLElement["items", attrs, content] as the first transformation.
See Also
Recipes 5.9 and 5.10 show you how to transform imported XML into other structures.
5.9 Transforming XML Using Patterns and Rules
Problem
You want to transform imported XML into something more suitable to mathemati-
cal manipulation.
Solution
The  format  of  imported  XML  is  a  bit  heavy.  You  use  pattern  matching  and
ReplaceAll  to  transform  it  into  something  more  digestible.  Here  we  take  our
row-oriented XML data into a simple matrix.
In[154]:=
data = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "data", "ch02", "data1.xml"=E, "XMLObject"E;
In[155]:=
CasesAdata , XMLElement@"item", _, _D, InfinityE ê.
XMLElement@_, _ , 8val_<D ß val ê.
XMLElement@"item", _, list_D ß list ê. 9n_, s_, age_, ht_= Ø
9n, s, ToExpressionAageE, ToExpression@htD= êê MatrixForm
Out[155]//MatrixForm=
Leonardo
male
8 4.7
Salvatore
male
5 4.1
Alexis
female 6 4.4
This technique has two basic steps. First, you use Cases to extract the relevant elements. Sec
ond, you use a series of one or more transformations to massage the data into the form you
want. In the first transformation, elements are taken to primitive values. Here you
rely on the column position to determine when strings need conversion into numbers via
ToExpression[]. The second transformation strips out the remaining XMLElement con-
tent. Until you have some experience with these types of transformations it is unlikely that
you’ll whip them up off the top of your head. The final form of this transformation
reflects the fact that I developed it in stages. Here are the successive refinements.
5.9 Transforming XML Using Patterns and Rules | 213

Choose the relevant elements.
In[156]:=
CasesAdata , XMLElement@"item", _, _D, InfinityE
Out[156]=
9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex, 8<, 8male<D,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElement@sex, 8<, 8male<D, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElement@sex, 8<, 8female<D,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=
Strip out the data-level XML structure.
In[157]:=
CasesAdata , XMLElement@"item", _, _D, InfinityE ê.
XMLElement@_, _ , 8val_<D ß val
Out[157]=
8XMLElement@item, 8<, 8Leonardo, male, 8, 4.7<D,
XMLElement@item, 8<, 8Salvatore, male, 5, 4.1<D,
XMLElement@item, 8<, 8Alexis, female, 6, 4.4<D<
Strip out the row-level XML structure, leaving the data in matrix form but all the
primitive values as strings.
In[158]:=
CasesAdata , XMLElement@"item", _, _D, InfinityE ê.
XMLElement@_, _ , 8val_<D ß val ê. XMLElement@"item", _, list_D ß list
Out[158]=
88Leonardo, male, 8, 4.7<, 8Salvatore, male, 5, 4.1<, 8Alexis, female, 6, 4.4<<
Finally, do the type conversion.
In[159]:=
CasesAdata , XMLElement@"item", _, _D, InfinityE ê.
XMLElement@_, _ , 8val_<D ß val ê.
XMLElement@"item", _, list_D ß list ê.
9n_, s_, age_, ht_= Ø 9n, s, ToExpressionAageE, ToExpression@htD=
Out[159]=
88Leonardo, male, 8, 4.7<, 8Salvatore, male, 5, 4.1<, 8Alexis, female, 6, 4.4<<
Discussion
There are always many ways to solve the same transformation problem. The trade-
offs involve brevity, clarity, generality, and performance. The solution has clarity, be-
cause it accomplishes the transformation in a step-by-step fashion. However, it is nei-
ther brief nor very general. The following transformation does the same thing but is
more  general.  It  will  work  on  any  two-level  XML  document  because  it  does  not
match  on  specific  element  names  (like  "item").  It  also  does  not  hardcode  which
columns contain numeric data. However, it is a bit more cryptic because it does not
mention XMLElement at all. Rather, it immediately converts the data to a list (using
Apply with head List), and it uses [[n]] to pick out the relevant items.
214 | Chapter 5: String and Text Processing

In[160]:=
toMatrix@xml_D :=
ApplyAList, xml@@2DD, 90, Infinity=E@@3DD ê. 8_, 8<, row_< ß row ê.
8_, 8<, 8val_<< ß
IfAStringMatchQAval, NumberStringE, ToExpression@valD, valE
toMatrix@dataD êê MatrixForm
Out[161]//MatrixForm=
Leonardo
male
8 4.7
Salvatore
male
5 4.1
Alexis
female 6 4.4
I demonstrate the generality by processing an XML file with a different number of
rows, columns, and data types. 
In[162]:=
toMatrixAImportA
FileNameJoinA9NotebookDirectory@D, "..", "data", "ch02", "data2.xml"=E,
"XMLObject"EE êê MatrixForm
Out[162]//MatrixForm=
1.
88.33 8 1000
4.7
2.
99.66 5 1001
4.1
3.
89.7
6 1002
4.4
1.5
99.7
6 1008 4.45
XML-to-XML transformations
You may find that you need to transform XML for reasons other than using the data
in Mathematica. Unless you already know a language specifically designed for this
purpose (like XSLT), Mathematica is a good choice. Mathematica’s pattern-matching
capabilities  are  well  suited  to  many  types  of  XML  transformations.  Consider  the
problem of converting elements to attributes. 
In[163]:=
dataUsingAttr =
data ê. XMLElement@"item", 8<, childElements_D :> XMLElementA"item",
childElements ê. XMLElementAtag_, _, 8val_<E :> RuleAtag, valE, 8<E
Out[163]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<,
9XMLElementAitem, 9name Ø Leonardo, sex Ø male, age Ø 8, height Ø 4.7=, 8<E,
XMLElementAitem, 9name Ø Salvatore, sex Ø male, age Ø 5, height Ø 4.1=,
8<E, XMLElementAitem,
9name Ø Alexis, sex Ø female, age Ø 6, height Ø 4.4=, 8<E=E,
9XMLObject@CommentD@ Comment at end D=E
5.9 Transforming XML Using Patterns and Rules | 215

It is a bit easier to see how this worked by converting back to XML text. The strip-
ping of carriage returns (\r) is only for formatting purposes.
In[164]:=
StringReplaceAExportStringAdataUsingAttr, "XML"E, "\r" Ø ""E
Out[164]=
<?xml version='1.0' encoding='UTF-8'?>
<!-- Some data to uses as a test for Mathematica's XML import -->
<?test Just for didactic purposes?>
<data>
<item name='Leonardo'
sex='male'
age='8'
height='4.7' ê>
<item name='Salvatore'
sex='male'
age='5'
height='4.1' ê>
<item name='Alexis'
sex='female'
age='6'
height='4.4' ê>
<êdata>
<!-- Comment at end -->
A transformation from attributes to elements follows similar lines. The use of Join[]
here is not strictly necessary, but it shows you how to handle cases in which you
don’t want to lose preexisting child elements at the point where you are injecting at-
tribute content.
In[165]:=
dataUsingElems =
dataUsingAttr ê. XMLElement@"item", attrs_, childElements_D ß
XMLElementA"item", 8<, JoinAchildElements,
attrs ê. RuleAtag_, val_E ß XMLElementAtag, 8<, 8val<EEE
216 | Chapter 5: String and Text Processing

Out[165]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<, 9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex, 8<, 8male<D,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElement@sex, 8<, 8male<D, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElement@sex, 8<, 8female<D,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=E,
9XMLObject@CommentD@ Comment at end D=E
In[166]:=
StringReplaceAExportStringAdataUsingElems, "XML"E, "\r" Ø ""E
Out[166]=
<?xml version='1.0' encoding='UTF-8'?>
<!-- Some data to use as a test for Mathematica's XML import -->
<?test Just for didactic purposes?>
<data>
<item>
<name>Leonardo<êname>
<sex>male<êsex>
<age>8<êage>
<height>4.7<êheight>
<êitem>
<item>
<name>Salvatore<êname>
<sex>male<êsex>
<age>5<êage>
<height>4.1<êheight>
<êitem>
<item>
<name>Alexis<êname>
<sex>female<êsex>
<age>6<êage>
<height>4.4<êheight>
<êitem>
<êdata>
<!-- Comment at end -->
5.9 Transforming XML Using Patterns and Rules | 217

See Also
See the tutorial XML/tutorial/TransformingXML in the Mathematica documentation
(also at http://bit.ly/4tS1Ce).
Recipe 5.10 shows alternate techniques for XML transformation.
5.10 Transforming XML Using Recursive 
Functions (à la XSLT)
Problem
The pure pattern-based approach of Recipe 5.9 is too awkward, cryptic, or complex
for your particular transformation problem.
Solution
Consider using an approach inspired by Extensible Stylesheet Language Transforms
(XSLT). XSLT is a language that is specifically designed to transform XML. There
are some rough similarities between XSLT and a style of Mathematica programming
that exploits functions, patterns, and recursion. Here is how you use Mathematica
to process XML in ways similar to XSLT. Consider the Recipe 5.9 transformation of
elements to attributes. Rather than rely on replacement, we use a set of mutually re-
cursive functions with patterns to navigate the XML tree while surgically inserting
transformations at the correct places. 
In[167]:=
data = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "data", "ch02", "data1.xml"=E, "XMLObject"E
Out[167]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<, 9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElement@sex, 8<, 8male<D,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElement@sex, 8<, 8male<D, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElement@sex, 8<, 8female<D,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=E,
9XMLObject@CommentD@ Comment at end D=E
218 | Chapter 5: String and Text Processing

In[168]:=
ClearAll@transformD
transformAXMLObject@"Document"D@decl_, content_, rest_DE :=
ModuleA8<, XMLObjectAtypeE@decl, transform@contentD, restD E
transformAXMLObjectAtype_EAargs___EE :=
ModuleA8<, XMLObjectAtypeEAargs EE
transform@XMLElement@"item", _, elements__D D :=
Module@8<, XMLElement@"item", asAttribute@ÒD & êü elements, 8<D D
transformAXMLElementAtag_String, attrs_List, child_ListEE :=
ModuleA8<, XMLElementAtag, attrs, transform@childDEE
transform@list_ListD := Module@8<, transform@ÒD & êü list D
asAttributeAXMLElementAtag_, 8<, 8val_<EE :=
ModuleA8<, RuleAtag, valE E
In[175]:=
transform@dataD
Out[175]=
XMLObjectAtypeEA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E, XMLObject@
CommentD@ Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<,
9XMLElementAitem, 9name Ø Leonardo, sex Ø male, age Ø 8, height Ø 4.7=, 8<E,
XMLElementAitem, 9name Ø Salvatore, sex Ø male, age Ø 5, height Ø 4.1=,
8<E, XMLElementAitem,
9name Ø Alexis, sex Ø female, age Ø 6, height Ø 4.4=, 8<E=E,
9XMLObject@CommentD@ Comment at end D=E
Discussion
A natural objection to using this style of transformation rather than using replace-
ment rules is that it is more verbose. This verbosity comes with some advantages.
The first advantage is that when things go wrong, it is generally easier to debug a set
of  discrete  functions  than  a  replacement  pattern.  Most  of  the  action  of  a  replace-
ment pattern is happening under the covers. The second advantage comes in cases
where  you  need  to  make  many  changes  at  different  levels  in  the  XML  hierarchy.
Here the overhead of the recursive approach is less bothersome. We implement a
transformation that changes elements to attributes, renames the "item" element to
"row", changes "sex" to "gender", and converts the height from feet to meters~all
with very little extra overhead.
5.10 Transforming XML Using Recursive Functions (à la XSLT) | 219

In[176]:=
ClearAll@transformD
transformAXMLObject@"Document"D@decl_, content_, rest_DE :=
ModuleA8<, XMLObject@"Document"D@decl, transform@contentD, restD E
transformAXMLObjectAtype_EAargs___EE :=
ModuleA8<, XMLObjectAtypeEAargs EE
transform@XMLElement@"item", _, elements__D D :=
Module@8<, XMLElement@"row", asAttribute@ÒD & êü elements, 8<D D
transform@list_ListD := Module@8<, transform@ÒD & êü list D
transformAXMLElementAtag_String, attrs_List, child_ListEE :=
ModuleA8<, XMLElementAtag, attrs, transform@childDEE
asAttribute@XMLElement@"sex", 8<, 8val_<DD :=
ModuleA8<, RuleA"gender", valE E
asAttributeAXMLElementA"height", 8<, 8val_<EE :=
ModuleA8<, RuleA"height", ToString@0.3048* ToExpression@valDDE E
asAttributeAXMLElementAtag_, 8<, 8val_<EE := ModuleA8<, RuleAtag, valE E
In[185]:=
data2 = transform@dataD
Out[185]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<, 9XMLElementArow,
9name Ø Leonardo, gender Ø male, age Ø 8, height Ø 1.43256=, 8<E,
XMLElementArow, 9name Ø Salvatore, gender Ø male,
age Ø 5, height Ø 1.24968=, 8<E, XMLElementArow,
9name Ø Alexis, gender Ø female, age Ø 6, height Ø 1.34112=, 8<E=E,
9XMLObject@CommentD@ Comment at end D=E
220 | Chapter 5: String and Text Processing

In[186]:=
ExportString@data2, "XML"D êê StringReplace@Ò, "\r" Ø ""D &
Out[186]=
<?xml version='1.0' encoding='UTF-8'?>
<!-- Some data to use as a test for Mathematica's XML import -->
<?test Just for didactic purposes?>
<data>
<row name='Leonardo'
gender='male'
age='8'
height='1.43256' ê>
<row name='Salvatore'
gender='male'
age='5'
height='1.24968' ê>
<row name='Alexis'
gender='female'
age='6'
height='1.34112' ê>
<êdata>
<!-- Comment at end -->
One of the first things you learn about XSLT is that if you create an empty stylesheet
(XSLT’s equivalent of a program), you get some default transformation rules that act
to  output  just  the  text  nodes  of  the  XML  data.  We  can  emulate  that  behavior  in
Mathematica with the following functions.
In[187]:=
ClearAll@transformD
transformAXMLObjectAtype_E@content__DE :=
StringJoin@transform@ÒD & êü List@contentDD
transformAXMLElementAtag_, attrs_List, data_ListEE :=
StringJoin@transform@ÒD & êü data D
transformAtext_StringE := text
transform@_D := ""
In[192]:=
transform@dataD
Out[192]=
Leonardomale84.7Salvatoremale54.1Alexisfemale64.4
5.10 Transforming XML Using Recursive Functions (à la XSLT) | 221

So  far,  so  good,  but  can  we  do  something  more  interesting?  Suppose  we  want  to
clone our XML document but replace all occurrences of the element "sex" with the
element "gender".
In[193]:=
ClearAll@transformD
In[194]:=
transformAXMLObjectAtype_E@content__DE :=
ModuleA8<, XMLObjectAtypeE@transform@List@contentDDD E
transform@XMLElement@"sex", attrs_List, data_ListDD :=
ModuleA8<, XMLElementA"gender", attrs, transform@dataDEE
transformAXMLElementAtag_String, attrs_List, data_ListEE :=
ModuleA8<, XMLElementAtag, attrs, transform@dataDE E
transform@list_ListD := Module@8<, transform@ÒD & êü list D
transformAtext_StringE := Module@8<, textD
In[199]:=
transform@dataD
Out[199]=
XMLObject@DocumentDA99XMLObject@DeclarationDA9transform@Version Ø 1.0D,
transformAEncoding Ø UTF-8E=E, XMLObject@CommentD@
8 Some data to use as a test for Mathematica's XML import <D,
XMLObjectAProcessingInstructionE@8test, Just for didactic purposes<D=,
XMLElementAdata, 8<, 9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElementAgender, 8<, 8male<E,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElementAgender, 8<, 8male<E, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElementAgender, 8<, 8female<E,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=E,
9XMLObject@CommentD@8 Comment at end <D==E
222 | Chapter 5: String and Text Processing

This  recursive  transformational  approach  is  overkill  in  this  scenario  since  we  can
more easily express this transformation using ReplaceAll.
In[200]:=
data ê. "sex" Ø "gender"
Out[200]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E,
XMLObject@CommentD@
Some data to use as a test for Mathematica's XML import D,
XMLObjectAProcessingInstructionE@test, Just for didactic purposesD=,
XMLElementAdata, 8<, 9XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Leonardo<D, XMLElementAgender, 8<, 8male<E,
XMLElementAage, 8<, 88<E, XMLElementAheight, 8<, 84.7<E=E,
XMLElementAitem, 8<, 9XMLElement@name, 8<, 8Salvatore<D,
XMLElementAgender, 8<, 8male<E, XMLElementAage, 8<, 85<E,
XMLElementAheight, 8<, 84.1<E=E, XMLElementAitem, 8<,
9XMLElement@name, 8<, 8Alexis<D, XMLElementAgender, 8<, 8female<E,
XMLElementAage, 8<, 86<E, XMLElementAheight, 8<, 84.4<E=E=E,
9XMLObject@CommentD@ Comment at end D=E
5.10 Transforming XML Using Recursive Functions (à la XSLT) | 223

There  are  certain  types  of  structure-adding  transformations  that  were  difficult  to  do  in
XSLT until a grouping construct was added (xsl:for-each-group) in XSLT 2.0. Here is a
solution to a grouping problem using Mathematica’s Sort[] and Split[] functions.
In[201]:=
employees =
ImportAFileNameJoinA9NotebookDirectory@D,
"..", "data", "ch02", "employee.xml"=E, "XMLObject"E
Out[201]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E=,
XMLElementAEmployees, 8<,
9XMLElementAemployee, 8name Ø Jil Michel, sex Ø female, dept Ø 1001<, 8<E,
XMLElementAemployee, 9name Ø Nancy Pratt, sex Ø female, dept Ø 1001=, 8<E,
XMLElementAemployee,
8name Ø Phill McKraken, sex Ø male, dept Ø 1003<, 8<E,
XMLElementAemployee, 8name Ø Ima Little, sex Ø female, dept Ø 1001<, 8<E,
XMLElementAemployee, 9name Ø Betsy Ross, sex Ø female, dept Ø 1007=, 8<E,
XMLElementAemployee, 8name Ø Jane Doe, sex Ø female, dept Ø 1003<, 8<E,
XMLElementAemployee, 8name Ø Walter H. Potter, sex Ø male, dept Ø 2001<,
8<E, XMLElementAemployee,
9name Ø Wendy B.K. McDonald, sex Ø female, dept Ø 2003=, 8<E,
XMLElementAemployee, 9name Ø Craig F. Frye, sex Ø male, dept Ø 1001=, 8<E,
XMLElementAemployee, 9name Ø Hardy Hamburg, sex Ø male, dept Ø 2001=, 8<E,
XMLElementAemployee, 8name Ø Rich Shaker, sex Ø male, dept Ø 2001<, 8<E,
XMLElementAemployee, 8name Ø Mike Rosenbaum, sex Ø male, dept Ø 2003<,
8<E, XMLElementAemployee,
9name Ø Cindy Post-Kellog, sex Ø female, dept Ø 3001=, 8<E,
XMLElementAemployee, 8name Ø Allen Bran, sex Ø male, dept Ø 3001<, 8<E,
XMLElementAemployee, 9name Ø Frank N. Berry, sex Ø male, dept Ø 1001=,
8<E, XMLElementAemployee,
8name Ø Jack Apple, sex Ø male, dept Ø 2001<, 8<E, XMLElementA
employee, 8name Ø Oscar A. Winner, sex Ø male, dept Ø 3003<, 8<E,
XMLElementAemployee, 8name Ø Jack Nickolas, sex Ø male, dept Ø 1001<, 8<E,
XMLElementAemployee, 9name Ø R.P. McMurphy, sex Ø male, dept Ø 1001=, 8<E,
XMLElementAemployee, 8name Ø Tom Hanks, sex Ø male, dept Ø 2001<, 8<E,
XMLElementAemployee, 8name Ø Forest Gump, sex Ø male, dept Ø 2003<, 8<E,
XMLElementAemployee, 8name Ø Andrew Beckett, sex Ø male, dept Ø 3001<,
8<E, XMLElementAemployee,
8name Ø Susan Sarandon, sex Ø female, dept Ø 1001<, 8<E, XMLElementA
employee, 9name Ø Helen Prejean, sex Ø female, dept Ø 2001=, 8<E=E, 8<E
224 | Chapter 5: String and Text Processing

The goal of this transformation is to group all employees in the same department un-
der a new element <Dept dept="num">. Notice how this is accomplished with little ad-
ditional code. Helper functions define an ordering and an equivalence relation
for Sort and OrderQ, respectively, and a transform[] applies the additional level
of grouping when it matches the "employees" element.
In[202]:=
ClearAll@transformD
getDept@XMLElement@_, 8__, "dept" Ø dept_<, 8<DD := dept
sameDeptQ@a_, b_D := ModuleA8<, OrderAgetDept@aD, getDept@bDE ã 0E
orderDept@a_, b_D := ModuleA8<, OrderAgetDept@aD, getDept@bDE ã 1E
transformAXMLObject@"Document"D@decl_, content_, rest_DE :=
ModuleA8<, XMLObject@"Document"D@decl, transform@contentD, restD E
transformAXMLObjectAtype_EAargs___EE :=
ModuleA8<, XMLObjectAtypeEAargs EE
transformAXMLElementA"Employees", _, elements__E E :=
ModuleA8<, XMLElementA"Employees", 8<,
XMLElementA"Dept", 9"dept" Ø getDept@Ò@@1DDD=, ÒE & êü
Split@Sort@elements, orderDeptD, sameDeptQD EE
transform@list_ListD := Module@8<, transform@ÒD & êü list D
transformAXMLElementAtag_String, attrs_List, child_ListEE :=
ModuleA8<, XMLElementAtag, attrs, transform@childDEE
5.10 Transforming XML Using Recursive Functions (à la XSLT) | 225

In[211]:=
transformAemployeesE
Out[211]=
XMLObject@DocumentDA
9XMLObject@DeclarationDAVersion Ø 1.0, Encoding Ø UTF-8E=,
XMLElementAEmployees, 8<, 9XMLElementADept, 8dept Ø 1001<,
9XMLElementAemployee, 8name Ø Susan Sarandon, sex Ø female, dept Ø 1001<,
8<E, XMLElementAemployee, 9name Ø R.P. McMurphy,
sex Ø male, dept Ø 1001=, 8<E, XMLElementAemployee,
8name Ø Jack Nickolas, sex Ø male, dept Ø 1001<, 8<E, XMLElementA
employee, 9name Ø Frank N. Berry, sex Ø male, dept Ø 1001=, 8<E,
XMLElementAemployee, 9name Ø Craig F. Frye, sex Ø male, dept Ø 1001=,
8<E, XMLElementAemployee, 8name Ø Ima Little,
sex Ø female, dept Ø 1001<, 8<E, XMLElementAemployee,
9name Ø Nancy Pratt, sex Ø female, dept Ø 1001=, 8<E, XMLElementA
employee, 8name Ø Jil Michel, sex Ø female, dept Ø 1001<, 8<E=E,
XMLElementADept, 8dept Ø 1003<, 9XMLElementAemployee,
8name Ø Jane Doe, sex Ø female, dept Ø 1003<, 8<E, XMLElementA
employee, 8name Ø Phill McKraken, sex Ø male, dept Ø 1003<, 8<E=E,
XMLElementADept, 8dept Ø 1007<, 9XMLElementAemployee,
9name Ø Betsy Ross, sex Ø female, dept Ø 1007=, 8<E=E,
XMLElementADept, 8dept Ø 2001<, 9XMLElementAemployee,
9name Ø Helen Prejean, sex Ø female, dept Ø 2001=, 8<E,
XMLElementAemployee, 8name Ø Tom Hanks, sex Ø male, dept Ø 2001<, 8<E,
XMLElementAemployee, 8name Ø Jack Apple, sex Ø male, dept Ø 2001<, 8<E,
XMLElementAemployee, 8name Ø Rich Shaker, sex Ø male, dept Ø 2001<, 8<E,
XMLElementAemployee, 9name Ø Hardy Hamburg, sex Ø male, dept Ø 2001=,
8<E, XMLElementAemployee, 8name Ø Walter H. Potter, sex Ø male,
dept Ø 2001<, 8<E=E, XMLElementADept, 8dept Ø 2003<,
9XMLElementAemployee, 8name Ø Forest Gump, sex Ø male, dept Ø 2003<, 8<E,
XMLElementAemployee, 8name Ø Mike Rosenbaum, sex Ø male, dept Ø 2003<,
8<E, XMLElementAemployee,
9name Ø Wendy B.K. McDonald, sex Ø female, dept Ø 2003=, 8<E=E,
XMLElementADept, 8dept Ø 3001<, 9XMLElementAemployee,
8name Ø Andrew Beckett, sex Ø male, dept Ø 3001<, 8<E,
XMLElementAemployee, 8name Ø Allen Bran, sex Ø male, dept Ø 3001<, 8<E,
XMLElementAemployee,
9name Ø Cindy Post-Kellog, sex Ø female, dept Ø 3001=, 8<E=E,
XMLElementADept, 8dept Ø 3003<, 9XMLElementAemployee,
8name Ø Oscar A. Winner, sex Ø male, dept Ø 3003<, 8<E=E=E, 8<E
Of course, there are significant differences between these transformations and XSLT.
For example, in XSLT, you operate on a tree and, hence, can navigate upward from
226 | Chapter 5: String and Text Processing

child elements to parent elements. This is not the case for Mathematica’s representa-
tion of XML. The tutorial mentioned in the following “See Also” section provides
some guidance for working around these issues.
See Also
The  tutorial  XML/tutorial/TransformingXML  in  the  Mathematica  documentation
(also at http://bit.ly/4tS1Ce) has a section comparing Mathematica to XSLT and can
provide further help in exploiting these techniques.
You can learn more about XSLT at the XSL Working Group’s website: http://bit.ly/1fJsB.
5.11 Writing Parsers and Grammars 
in Mathematica
Problem
You want to write a parser in Mathematica.
Solution
The easiest type of parser to write in Mathematica is a recursive descent parser. Be-
fore writing the parser, we need to know the grammar of the language we will parse.
The most common notation for grammars is  Backus-Naur  Form  (BNF),  but  for
reasons that will become apparent in the discussion, I use Mathematica itself to rep-
resent the grammar. For this example, I use a simplified English grammar. The pre-
sentation here is a variation of one developed and  given  by  Daniel  Lichtblau  of
Wolfram  Research  at  the  Wolfram  Developer’s  Conference  in  1999.  Refer  to  the
“See Also” section on page 235 for more information.
First, we need some helper functions to make creating the grammar easier. We use
two functions, sequence and choose, with attribute HoldAll to prevent them from eval
uating their arguments and causing an infinite recursion. As its name would suggest,
sequence[]  represents  a  sequence  of  terms  of  the  grammar.  Choose  represents  a
choice of one out of two or more possible terms. I allow choose to take an extra argu-
ment, which is a list of probabilities for the choices. More on that later. 
In[212]:=
SetAttributes@8sequence, choose<, HoldAllD
NILL = "";
5.11 Writing Parsers and Grammars in Mathematica | 227

This grammar is for a small subset of English.
In[214]:=
sentence := chooseAdeclarative, interrogative, imperativeE
declarative := sequenceAsubject, predicatepastE
interrogative := sequenceAqverb, subject, predicatepresentE
imperative := sequenceAactverb, subjectE
subject := choose@nounclause, sequence@nounclause, prepositionclauseDD
nounclause := sequenceAadjectiveclause, nounE
noun = 9"skyscraper", "ball", "dog", "cow", "shark", "attorney", "hatter",
"programmer", "city", "village", "buffalo", "moon", "librarian", "sheep"=;
adjectiveclause := sequenceAarticle, adjectivelistE
adjectivelist := chooseANILL, sequenceAadjective, adjectivelistE, 80.7<E
article = 8"a", "the", "this", "that"<;
adjective =
9"big", "wet", "mad", "hideous", "red", "repugnant", "slimy", "delectable",
"mild-mannered", "lazy", "silly", "crazy", "ferocious", "cute"=;
prepositionclause := sequence@preposition, nounclause D
preposition = 8"in", "above", "under", "from", "near", "at", "with"< ;
predicatepresent := sequenceAverbpresent, subjectE
predicatepast := sequenceAverbclause, subjectE
verbclause := sequence@adverblist, verbpastD
adverblist := choose@NILL, sequence@adverb, adverblist D, 80.6<D
adverb =
9"swiftly", "unflinchingly", "smugly", "selflessly", "oddly", "mightily"=;
verbpast = 9"ate", "threw", "gnashed", "boiled",
"grated", "milked", "spanked", "jumped"=;
verbpresent = 9"eat", "throw", "gnash", "boil", "grate",
"milk", "spank", "salivate", "jump"=;
qverb = 8"did", "will", "could", "should"<;
actverb = 8"break", "fix", "launch", "squeeze", "fetch"<;
In[236]:=
ToUpperCaseAStringTakeAToString@Hold@sentenceDD, 86, -2<EE
Out[236]=
SENTENCE
This  grammar  becomes  the  specification  for  our  parser.  Recursive  descent  parsers
are probably the easiest parsers to craft by hand because their structure mimics the
grammar. The goal of this parser is to create a labeled parse tree from a sentence.
The parser is very simple: it contains no provision for error handling and relies on
the grammar being completely conflict free. For example, the major sentence types
are completely determined by the first word. Real languages or even artificial lan-
guages (like programming languages) are rarely that clean. 
228 | Chapter 5: String and Text Processing

In[237]:=
H*Test for membership of a terminal
symbol in a list of terminal symbols.*L
isQAtype_, word_E := MemberQAtype, wordE
H*Get next word for parser.*L
getNextWord@8<D := ""
getNextWord@words_ListD := First@wordsD
H*Parse a single word, classifyingit as head, and return length of 1.*L
atomParse@head_, words_ListD := 9headAgetNextWord@wordsDE, 1=
H*Top level parse function for
sentences. Dispatches based on first word.*L
sentenceParseAsentence_sentenceTypeE :=
ModuleA9sentencelist = Apply@List, sentenceD, firstWord =,
firstWord = First@sentencelistD;
IfAisQ@qverb, firstWordD, interrogativeParse@sentencelistD,
If@isQ@actverb, firstWordD, imperativeParse@sentencelistD,
declarativeParse@sentencelistDDEE
H*declarative := sequenceAsubject, predicatepastE*L
declarativeParse@words_ListD :=
ModuleA9subject = subjectParse@wordsD, predicate=,
predicate = predicatepastParseADropAwords, subject@@2DDEE;
"DECLARATIVE SENTENCE"Asubject@@1DD, predicate@@1DDEE
H*interrogative := sequenceAqverb, subject, predicatepresentE*L
interrogativeParse@words_ListD :=
ModuleA9qverb = atomParse@"QUESTION VERB", wordsD, subject, predicate=,
subject = subjectParse@Drop@words, qverb@@2DDDD;
predicate = predicatepresentParseA
DropAwords, qverb@@2DD + subject@@2DDEE;
"INTERROGATIVE SENTENCE"Aqverb@@1DD, subject@@1DD, predicate@@1DDEE
H**L
H*imperative := sequenceAactverb, subjectE*L
imperativeParse@words_ListD :=
ModuleA9actverb = atomParse@"ACTION VERB", wordsD, subject=,
subject = subjectParse@Drop@words, actverb@@2DDDD;
"IMPERATIVE SENTENCE"Aactverb@@1DD, subject@@1DDEE
5.11 Writing Parsers and Grammars in Mathematica | 229

H*subject :=
choose@nounclause,
sequence@nounclause, prepositionclauseDD*L
subjectParse@words_ListD :=
ModuleA8nounclause = nounclauseParse@wordsD, prepositionclause<,
prepositionclause = Drop@words, nounclause@@2DDD;
IfA! isQApreposition, getNextWord@prepositionclauseDE,
8"SUBJECT"@nounclause@@1DDD, nounclause@@2DD<,
prepositionclause = prepositionclauseParse@prepositionclauseD;
8"SUBJECT"@nounclause@@1DD, prepositionclause@@1DDD,
nounclause@@2DD + prepositionclause@@2DD<EE
H*predicatepast:=sequenceAverbclause,subjectE*L
predicatepastParse@words_ListD :=
ModuleA9verbclause = verbclauseParse@wordsD, subject=,
subject = subjectParse@Drop@words, verbclause@@2DDDD;
9"PREDICATE"Averbclause@@1DD, subject@@1DDE,
verbclause@@2DD + subject@@2DD=E
H*predicatepresent:=sequenceAverbpresent,subjectE*L
predicatepresentParse@words_ListD :=
ModuleA9verb = atomParse@"VERB HPRESENT TENSEL", wordsD, subject=,
subject = subjectParse@Drop@words, verb@@2DDDD;
9"PREDICATE"Averb@@1DD, subject@@1DDE, verb@@2DD + subject@@2DD=E
H*verbclause:=sequence@adverblist,verbpastD*L
verbclauseParse@words_ListD :=
Module@8adverbs = adverblistParse@wordsD, verb<,
verb = atomParse@"VERB HPAST TENSEL", Drop@words, adverbs@@2DDDD;
If@adverbs@@2DD ã 0, verb,
8"VERB CLAUSE"@adverbs@@1DD, verb@@1DDD, adverbs@@2DD + verb@@2DD<DD
H*nounclause:= sequenceAadjectiveclause, nounE*L
nounclauseParse@words_ListD :=
ModuleA9adjectiveclause = adjectiveclauseParse@wordsD, noun=,
noun = atomParseA"NOUN", DropAwords, adjectiveclause@@2DDEE;
9"NOUN CLAUSE"Aadjectiveclause@@1DD, noun@@1DDE,
adjectiveclause@@2DD + noun@@2DD=E
H*adjectiveclause := sequenceAarticle, adjectivelistE*L
adjectiveclauseParse@words_ListD :=
ModuleA9art = atomParse@"ARTICLE", wordsD, adjlist=,
adjlist = adjectivelistParse@Drop@words, art@@2DDDD;
230 | Chapter 5: String and Text Processing

IfAadjlist@@2DD ã 0, art, 9"ADJECTIVE CLAUSE"Aart@@1DD, adjlist@@1DDE,
art@@2DD + adjlist@@2DD=EE
H*Parse Ipossibly emptyM list of adjectives.*L
H*adjectivelist :=
chooseANILL, sequenceAadjective, adjectivelistE, 80.7<E*L
adjectivelistParse@words_ListD :=
ModuleA9words2 = words, adj, result, len = 0=, result = "ADJECTIVE LIST"@D;
WhileAisQAadjective, getNextWord@words2DE,
adj = atomParse@"ADJECTIVE", words2D;
len += adj@@2DD;
result = "ADJECTIVE LIST"Aresult, adj@@1DDE;
words2 = DropAwords2, adj@@2DDEE;
9FlattenAresult, Infinity, "ADJECTIVE LIST"E, len=E
H*prepositionclause := sequence@preposition, nounclauseD*L
prepositionclauseParse@words_ListD :=
Module@8preposition = atomParse@"PREPOSITION", wordsD, nounclause<,
nounclause = nounclauseParse@Drop@words, preposition@@2DDDD;
8"PREPOSITION CLAUSE"@preposition@@1DD, nounclause@@1DDD,
preposition@@2DD + nounclause@@2DD<D
H*Parse Ipossibly emptyM list of adverbs.*L
H*adverblist := choose@NILL, sequence@adverb,adverblistD, 80.6<D*L
adverblistParse@words_ListD :=
ModuleA8words2 = words, adv, result, len = 0<, result = "ADVERB LIST"@D;
WhileAisQAadverb, getNextWord@words2DE,
adv = atomParse@"ADVERB", words2D;
len += adv@@2DD;
result = "ADVERB LIST"@result, adv@@1DDD;
words2 = Drop@words2, adv@@2DDDE;
9FlattenAresult, Infinity, "ADVERB LIST"E, len=E
5.11 Writing Parsers and Grammars in Mathematica | 231

We can test the parser on a sentence that conforms to the grammar.
In[254]:=
sentenceParseA
sentenceTypeA"will", "the", "wet", "programmer", "spank", "the", "moon"EE
Out[254]=
INTERROGATIVE SENTENCEAQUESTION VERB@willD,
SUBJECTANOUN CLAUSEAADJECTIVE CLAUSE@ARTICLE@theD,
ADJECTIVE LIST@ADJECTIVE@wetDDD, NOUNAprogrammerEEE,
PREDICATE@VERB HPRESENT TENSEL@spankD,
SUBJECT@NOUN CLAUSE@ARTICLE@theD, NOUN@moonDDDDE
Discussion
You may wonder why I took the trouble to specify the grammar using Mathematica
if I was going to write the parser by hand. First, I did not write this parser; I
just  prettied up a parser written by Daniel Lichtblau! The more serious answer is
that the grammar can be used to easily create a language generator to go along with
the parser. The generator is very useful for testing the parser. Here I based a genera-
tor  on  Lichtblau’s  implementation  but  made  some  significant  improvements.  The
first improvement is that my implementation is more declarative than procedural be-
cause it leverages Mathematica’s pattern matching. The second improvement is that
the generator absorbs all the complexity so the grammar can remain very clean. In
Lichtblau’s original grammar, the representation was soiled by the presence of pro-
grammatic constructs, like Hold[] and his implementation of random choice. Other
than the presence of probabilities, the grammar in the preceding “Solution” section
is completely clean. In fact, it reads as easy as BNF. Refer to the URL in the “See
Also” section on page 235 to compare this implementation with the original.
232 | Chapter 5: String and Text Processing

In[255]:=
<< Combinatorica`
H*needed for BinarySearch@D*L
H*randomChoose@parts_List,probs_ListD selects an item from
parts_List based on a list of probabilities the length of
which must be one less than the number of parts and the sum
of which is less than one. The interpretation is that each
probability corresponds to the probability of the item in the same
position except for the last item, which gets the residual.*L
randomChoose@parts_List, probs_ListD := ModuleA9weights, test, pos=,
weights = N@Append@FoldList@Plus, First@probsD, Rest@probsDD, 1DD;
test = RandomReal@D; pos = CeilingABinarySearchAweights, testEE;
parts@@posDDE
H*randomPart@D is responsible for interpreting the grammar in
a random manner. There is a variation for each possible term,
and recursion is used to expand nonterminals.*L
randomPart@sequence@parts__DD := randomPart@ÒD & êü List@partsD
randomPart@choose@parts__, probs_ListDD :=
Union@Flatten@List@randomPart@randomChoose@List@partsD, probsDDDDD
randomPart@choose@parts__DD := ModuleA8partList, numParts<,
partList = List@partsD; numParts = Length@partListD;
randomPart@randomChoose@partList, Table@1ênumParts, 8numParts - 1<DDDE
randomPart@terminals_ListD :=
terminalsAA RandomIntegerA 91, Length@terminalsD=E EE
randomPart@NILLD := 8<
H*randomSentence@D is the entry point for
generating a random sentence of the grammar.*L
randomSentence@D := sentenceType üü Flatten@randomPart@sentenceDD
H*We provide a nice textual formatting for
sentences that also takes care of punctuation.*L
FormatAsentence_sentenceTypeE :=
ModuleA8word = First@sentenceD, words, punc<,
words = MapAStringJoin@Ò, " "D &, sentenceE;
punc = If@isQ@qverb, wordD, "?", If@isQ@actverb, wordD, "!", "."DD;
wordsAALength@wordsDEE = StringReplacePart@Last@wordsD, punc, -1D;
words@@1DD = StringReplacePartAFirst@wordsD,
ToUpperCaseAStringTake@First@wordsD, 1DE, 1E;
ApplyAStringJoin, wordsEE
Here  you  can  see  the  result  of  generating  10  random  sentences.  They  are,  for  the
most part, utter gibberish, but some are kind of funny. They all conform to the gram-
mar, as we can see by running them through the parser.
5.11 Writing Parsers and Grammars in Mathematica | 233

In[264]:=
randomSentence@D êê InputForm
Out[264]//InputForm=
sentenceType["a", "city", "in", "that", "mad", "village", "threw", "the", 
"shark", "at", "a", "ball"]
In[265]:=
Table@randomSentence@D, 810<D êê TableForm
Out[265]//TableForm=
Launch this moon from the city!
A skyscraper from a village ate a skyscraper in the attorney.
"The delectable librarian above that red hatter spanked this buffalo above
the big sheep."
Will that programmer salivate that programmer?
Could that mad silly ball spank this moon at that buffalo?
This skyscraper under the cow boiled a village in that village.
Squeeze a ball!
"The crazy mad city in the skyscraper unflinchingly jumped this village
above the skyscraper."
Could a programmer spank the attorney?
Fetch a programmer in this shark!
In[266]:=
SeedRandom@2D;
sentenceParse@randomSentence@DD êê TreeFormAÒ, ImageSize Ø 500E &
Out[267]//TreeForm=
IMPERATIVE SENTENCE
ACTION VERB
break
SUBJECT
NOUN CLAUSE
ARTICLE
that
NOUN
dog
PREPOSITION CLAUSE
PREPOSITION
above
NOUN CLAUSE
ADJECTIVE CLAUSE
ARTICLE
this
ADJECTIVE LIST
ADJECTIVE
ferocious
NOUN
cow
234 | Chapter 5: String and Text Processing

The parser we wrote by hand is an instance of a predictive recursive descent parser
because it looks ahead wherever there is a choice so that it does not take a wrong
path  through  the  grammar.  In  contrast,  a  backtracking  parser  simply  starts  over
from where it left off if a particular parse path fails. If you are ambitious, you can
continue this recipe and write a backtracking parser generator in Mathematica. The
references in the following “See Also” section provide some background.
See Also
See Daniel Lichtblau’s original implementation at http://bit.ly/zXhUm.
Packrat parsing is amenable to Mathematica implementation. See http://bit.ly/RsNCe.
A functional approach to parsing is discussed in “Monadic Parser Combinators” by
Graham Hutton and Erik Meijer, published in Journal of Functional Programming,
Volume 8, Issue 4, 1996. See http://bit.ly/PIVAh (PostScript file). 
5.11 Writing Parsers and Grammars in Mathematica | 235


CHAPTER 6
Two-Dimensional Graphics and Plots
I’ve been looking so long at these pictures of you
that I almost believe that they’re real
I’ve been living so long with my pictures of you
that I almost believe that the pictures are all I can feel
The Cure, “Pictures of You”
6.0 Introduction
One  of  the  features  that  places  Mathematica  in  a  class  by  itself  among  similar
computer-aided mathematics tools is its advanced graphics capabilities. This chap-
ter focuses on two-dimensional graphics. Mathematica provides a variety of plotting
functions with a versatile set of options for customizing their display. The most
common  types  of  2D  graphic  are  the  plot  of  a  function  and  list  plots  of  values.
Recipe 6.1 covers Plot and Recipe 6.4 covers ListPlot. Frequently you will want
to  use  other  coordinate  systems  or  scales.  In  two  dimensions,  PolarPlot  and
ParametricPlot are often used as demonstrated in Recipes 6.1 and 6.2.
True  to  its  symbolic  nature,  Mathematica  represents  all  graphics  as  collections  of
graphics primitives and directives. Primitives include objects such as Point and Line;
directives  provide  styling  information  such  as  Thickness  and  Hue.  Mathematica  al-
lows you to work with the low-level primitives (see Recipe 6.8), but most readers
will be interested in the higher-level functions like Plot and ListPlot, which gener-
ate graphics from functions and data and display them. However, it is easy to demon-
strate that these functions generate primitives by specifying InputForm.
In[1]:=
ListPlot@80, 1, 2, 3<D êê InputForm
237

Out[1]//InputForm=
GraphicsA8Hue@0.67, 0.6, 0.6D,
Point@881., 0.<, 82., 1.<, 83., 2.<, 84., 3.<<D<,
9AspectRatio -> GoldenRatio^H-1L, Axes -> True,
AxesOrigin -> 80, Automatic<,
PlotRange -> Automatic, PlotRangeClipping -> True=E
This  uniform  representation  allows  graphics  to  be  manipulated  programmatically,
just like any Mathematica object, and sometimes can be useful for generating cus-
tom effects. However, this representation is not entirely at the lowest level, because
graphics constructs like axes are implicitly specified via options. To get to the lowest
level you can use the function FullGraphics. Here I use Short to suppress some of
the details.
In[2]:=
Short@InputForm@FullGraphics@ListPlot@80, 1, 2, 3<DDD, 10D
Out[2]//Short=
Graphics@88Hue@0.67, 0.6, 0.6D, Point@881., 0.<, 82., 1.<, 83.,
2.<, 84., 3.<<D<, 88GrayLevel@0.D, AbsoluteThickness@0.25D,
Line@880.2, 0.<, 80.2, 0.010112712429686845<<D<, Text@0.2,
80.2, -0.02022542485937369<, 80., 1.<D, 8GrayLevel@0.D,
AbsoluteThickness@0.25D, Line@880.4, 0.<, 80.4,
0.010112712429686845<<D<, Text@0.4, 80.4, -0.02022542485937369<,
80., 1.<D, 8GrayLevel@0.D, AbsoluteThickness@0.25D,
Line@880.6000000000000001, 0.<, 80.6000000000000001,
0.010112712429686845<<D<, Text@0.6000000000000001,
80.6000000000000001, -0.02022542485937369<, 80., 1.<D,
8GrayLevel@0.D, AbsoluteThickness@0.25D, Line@880.8, 0.<, 80.8,
0.010112712429686845<<D<, <<41>>, 8GrayLevel@0.D, <<2>><,
8GrayLevel@0.D, AbsoluteThickness@0.125D, Line@880., 0.9<, 80.00375,
0.9<<D<, 8GrayLevel@0.D, AbsoluteThickness@0.125D, Line@880.,
0.9500000000000001<, 80.00375, 0.9500000000000001<<D<, 8GrayLevel@0.D,
AbsoluteThickness@0.25D, Line@880., 0.<, 80., 1.<<D<<<D
In the recipes that follow, I make frequent use of GraphicsRow, GraphicsColumn, and
GraphicsGrid. These are handy for formatting multiple graphics outputs across the
page  to  make  maximum  use  of  both  horizontal and vertical space. Both GraphicsRow
and  GraphicsColumn  take  a  list  of  graphics  to  format,  whereas  GraphicsGrid
takes  a  matrix.  To  help  generate  these  lists  and  matrices,  I  sometimes  use
Table and Partition. These functions are simple enough that I hope they do not de-
tract from the intended lesson of the recipe. Recipe 6.6 explains the use of these grid-
like formatting functions in detail.
238 | Chapter 6: Two-Dimensional Graphics and Plots

6.1 Plotting Functions in Cartesian Coordinates
Problem
You want to graph one or more built-in or user-defined functions.
Solution
The simplest solution is to use the Plot command with the range of values to plot.
Plot  takes  one  or  more  functions  of  a  single  variable  and  an  iterator  of  the  form
{var, min, max}.
In[3]:=
GraphicsRow@8
Plot@Erf@xD, 8x, -2, 2<D,
Plot@80.5 Sin@2 xD, Cos@3 xD<, 8x, -Pi, Pi<D
<D
Out[3]=
-2
-1
1
2
-1.0
-0.5
0.5
1.0
-3
-2
-1
1
2
3
-1.0
-0.5
0.5
1.0
Discussion
Plot has a wide variety of options for controlling the appearance of the plot. Here
are the defaults.
In[4]:=
Partition@ Options@PlotD , 4D êê TableForm
Out[4]//TableForm=
AlignmentPoint Ø Center
AspectRatio Ø 1êGoldenRatio
Axes Ø True
AxesLabel Ø None
AxesOrigin Ø Automatic
AxesStyle Ø 8<
Background Ø None
BaselinePosition Ø Automatic
BaseStyle Ø 8<
ClippingStyle Ø None
ColorFunction Ø Automatic
ColorFunctionScaling Ø True
ColorOutput Ø Automatic
ContentSelectable Ø Automatic
CoordinatesToolOptions Ø Automatic DisplayFunction ß $DisplayFunction
Epilog Ø 8<
Evaluated Ø Automatic
EvaluationMonitor Ø None
Exclusions Ø Automatic
ExclusionsStyle Ø None
Filling Ø None
FillingStyle Ø Automatic
FormatType ß TraditionalForm
Frame Ø False
FrameLabel Ø None
FrameStyle Ø 8<
FrameTicks Ø Automatic
FrameTicksStyle Ø 8<
GridLines Ø None
GridLinesStyle Ø 8<
ImageMargins Ø 0.
ImagePadding Ø All
ImageSize Ø Automatic
ImageSizeRaw Ø Automatic
LabelStyle Ø 8<
MaxRecursion Ø Automatic
Mesh Ø None
MeshFunctions Ø 9Ò1 &=
MeshShading Ø None
MeshStyle Ø Automatic
Method Ø Automatic
PerformanceGoal ß $PerformanceGoal PlotLabel Ø None
PlotPoints Ø Automatic
PlotRange Ø 9Full, Automatic=
PlotRangeClipping Ø True
PlotRangePadding Ø Automatic
PlotRegion Ø Automatic
PlotStyle Ø Automatic
PreserveImageOptions Ø Automatic
Prolog Ø 8<
RegionFunction Ø ITrue &M RotateLabel Ø True
Ticks Ø Automatic
TicksStyle Ø 8<
6.1 Plotting Functions in Cartesian Coordinates | 239

When plotting two or more functions, you may want to explicitly set the style of
each plot’s lines. You can also suppress one or both of the axes using Axes, as I do in
the second and fourth plots. You can label one or both of the axes using AxesLabel and
control the format using LabelStyle.
In[5]:=
GraphicsGridA9
9PlotA80.5 Sin@2 xD, Cos@3 xD, Sin@xD - Cos@2 xD<, 8x, -Pi, Pi<,
PlotStyle Ø 8Directive@Black, ThinD, Directive@Black, ThickD,
Directive@Black, DashedD<, ImageSize Ø SmallE,
Plot@Erf@xD, 8x, -2, 2<, Axes Ø 8False, True<D=,
9PlotA0.5 Sin@2 qD, 8q, 0, 2 p<, AxesLabel Ø 9"Angle", "Amplitude"=,
LabelStyle Ø Directive@BoldD, ImageSize Ø SmallE,
PlotA0.5 Sin@2 qD, 8q, 0, 2 p<, Axes Ø False, ImageSize Ø SmallE
==E
Out[5]=
-3
-2
-1
1
2
3
-1.0
-0.5
0.5
1.0
1.5
2.0
-1.0
-0.5
0.0
0.5
1.0
1
2
3
4
5
6
Angle
-0.4
-0.2
0.2
0.4
Amplitude
240 | Chapter 6: Two-Dimensional Graphics and Plots

PlotLabel is a handy option for naming plots, especially when you display several
plots at a time.
In[6]:=
GraphicsRow@8
Plot@Sin@xD, 8x, -2 Pi, 2 Pi<, PlotLabel Ø "Sin"D,
Plot@Cos@xD, 8x, -2 Pi, 2 Pi<, PlotLabel Ø "Cos"D
<D
Out[6]=
-6
-4
-2
2
4
6
-1.0
-0.5
0.5
1.0
Sin
-6
-4
-2
2
4
6
-1.0
-0.5
0.5
1.0
Cos
You can add grid lines with an explicitly determined frequency or a frequency deter-
mined automatically by Mathematica.
In[7]:=
GraphicsRowA9
PlotATan@xD, 8x, -Piê2, Piê2<, GridLines Ø Automatic, ImageSize Ø Small,
PlotLabel Ø "Automatic Grid"E, PlotATan@xD, 8x, -Piê2, Piê2<,
GridLines Ø 88-Piê2, -Piê4, 0, Piê4, Piê2<, 8-6, -4, -2, 0, 2, 4, 6<<,
ImageSize Ø Small, PlotLabel Ø "Custom Grid"E
=E
Out[7]=
-1.5
-1.0
-0.5
0.5
1.0
1.5
-6
-4
-2
2
4
6
Automatic Grid
-1.5
-1.0
-0.5
0.5
1.0
1.5
-6
-4
-2
2
4
6
Custom Grid
6.1 Plotting Functions in Cartesian Coordinates | 241

Frame, FrameStyle, and FrameLabel let you annotate the graph with a border and la-
bel.  Note  that  FrameStyle  and  FrameLabel  only  have  effect  if  FrameØTrue  is  also
specified.
In[8]:=
GraphicsRowB:
PlotBExp@Sin@xDD, 8x, 0, 2 Pi<, Frame Ø True, FrameLabel Ø "esin x",
ImageSize Ø SmallF,
PlotAExp@Cos@xDD, 8x, 0, 2 Pi<, Frame Ø True, FrameLabel Ø "ecos x",
FrameStyle Ø DirectiveAGray, ThickE,
ImageSize Ø SmallE
>F
Out[8]=
0
1
2
3
4
5
6
0.0
0.5
1.0
1.5
2.0
2.5
esin x
0
1
2
3
4
5
6
0.0
0.5
1.0
1.5
2.0
2.5
ecos x
Mesh is an option that allows you to highlight specific points in the plot. Mesh Ø All
will highlight all points sampled while plotting the graph, Mesh Ø Full will use
regularly spaced points. Mesh Ø n will use n equally spaced points. The behavior of
Mesh Ø Automatic will vary based on the plotting primitive.
242 | Chapter 6: Two-Dimensional Graphics and Plots

In[9]:=
GraphicsGridAPartitionATableA
PlotA0.5 Sin@2 qD, 8q, 0, 2 p<, Mesh Ø m,
ImageSize Ø Small, Frame Ø True,
PlotLabel Ø "Mesh Ø " <> ToString@mDE,
8m, 8None, Automatic, All, Full, 16, 50<<E, 2E, Spacings Ø 0E
Out[9]=
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø None
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø Automatic
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø All
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø Full
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø 16
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø 50
PlotRange is an important option that controls what coordinates to include in the
plot. Automatic lets Mathematica decide on the best choice, All specifies all points
actually plotted, and Full specifies the entire range. In addition, you can supply
explicit coordinates in the form {{xmin,xmax},{ymin,ymax}}.
6.1 Plotting Functions in Cartesian Coordinates | 243

In[10]:=
GraphicsGridAPartitionA
TableA
PlotASqrt@100.0 - x^2D, 8x, 0, 100<,
PlotRange Ø r, ImageSize Ø 8225, Automatic<, Frame Ø True,
FrameLabel Ø "PlotRange Ø " <> ToString@rDE,
8r, 8Automatic, All, Full, 880, 20<, 80, 20<<<<E, 2E, Spacings Ø 0E
Out[10]=
0
2
4
6
8
10
0
2
4
6
8
10
PlotRange Ø Automatic
0
2
4
6
8
10
0
2
4
6
8
10
PlotRange Ø All
0
20
40
60
80
100
0
2
4
6
8
10
PlotRange Ø Full
0
5
10
15
20
0
5
10
15
20
PlotRange Ø 880, 20<, 80, 20<<
AspectRatio  controls  the  ratio  of  height  to  width  of  the  plot.  The  default  value  is
1/GoldenRatio (also known as f). A value of Automatic uses the coordinate values to
determine the aspect ratio. 
244 | Chapter 6: Two-Dimensional Graphics and Plots

In[11]:=
GraphicsGridüPartitionA
TableA
PlotASqrt@100.0 - x^2D, 8x, 0, 10<, AspectRatio Ø a, Frame Ø True,
FrameLabel Ø "AspectRatio Ø " <> ToString@TraditionalForm@aDDE,
9a, 9GoldenRatio-1, Automatic, 1.25, 0.75==E, 2E
Out[11]=
0
2
4
6
8
10
0
2
4
6
8
10
AspectRatio Ø
1
f
0
2
4
6
8
10
0
2
4
6
8
10
AspectRatio Ø Automatic
0
2
4
6
8
10
0
2
4
6
8
10
AspectRatio Ø 1.25
0
2
4
6
8
10
0
2
4
6
8
10
AspectRatio Ø 0.75
Sometimes you want to emphasize an area on one side of the curve or between two
different curves. Filling can be set to Top to fill from the curve upward, Bottom to fill
from the curve downward, Axis to fill from the axis to the curve, or to a numeric
value to fill from the curve to that value in either y direction. 
6.1 Plotting Functions in Cartesian Coordinates | 245

In[12]:=
GraphicsGridüPartitionATableA
PlotASin@xD, 8x, 0, 2 Pi<, Filling Ø f, Frame Ø True,
FrameLabel -> "Filling Ø " <> ToString@fD,
ImageSize Ø 8200, Automatic<E,
8f, 8Top, Bottom, Axis, 0.5<<E, 2E
Out[12]=
FillingStyle allows you to control the color and opacity of the filling. Specifying an
opacity is useful where regions of multiple functions overlap.
In[13]:=
PlotA8Cosh@xD, Cosh@3 xD<, 8x, -1, 1<, Filling Ø Top,
FillingStyle Ø DirectiveAGray, Opacity@0.5DE, ImageSize Ø 300E
Out[13]=
246 | Chapter 6: Two-Dimensional Graphics and Plots

You can also use a special notation to fill the area between two curves. In this nota-
tion, you refer to a curve by {i} where i is an integer referring to the ith plot. You
can then say something like Filling Ø {i Ø {j}} to specify that filling should be be-
tween plot i and plot j. You can also override the FillingStyle by including a graph-
ics directive, as in the example here.
In[14]:=
PlotA8Sin@xD, 2 Sin@x + 1D + 3, 3 Sin@x + 2D + 6<, 8x, 0, 2 Pi<,
Filling Ø 81 Ø 882<, Red<, 2 Ø 883<, Yellow<<,
ImageSize Ø 300E
Out[14]=
1
2
3
4
5
6
2
4
6
8
See Also
Recipes 6.2 and 6.3 demonstrate PolarPlot and ListPlot, which share most of the
options of Plot.
6.2 Plotting in Polar Coordinates
Problem
You want to create a plot in polar coordinates of radius as a function of angle.
Solution
Use PolarPlot, which plots the radius as the angle in polar coordinates varies counter-
clockwise with 0 at the x-axis, p/2 at the y-axis, and so on. 
6.2 Plotting in Polar Coordinates | 247

In[15]:=
GraphicsGrid@8
8PolarPlot@1, 8q, 0, 2 p<, PlotLabel Ø "Constant"D,
PolarPlot@q, 8q, 0, 2 p<, PlotLabel Ø "Spiral"D<,
8PolarPlot@Sin@5 qD, 8q, 0, 2 p<, PlotLabel Ø "Loops"D,
PolarPlot@1êH1.5 + Sin@5 qDL, 8q, 0, 2 p<, PlotLabel Ø "Star Fish"D<
<D
Out[15]=
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
Constant
-2
2
4
6
-4
-3
-2
-1
1
Spiral
-0.5
0.5
-0.5
0.5
1.0
Loops
-1.5
-1.0
-0.5
0.5
1.0
1.5
-2.0
-1.5
-1.0
-0.5
0.5
1.0
1.5
Star Fish
Discussion
As with Plot, you can plot several functions simultaneously.
248 | Chapter 6: Two-Dimensional Graphics and Plots

In[16]:=
PolarPlotA81, 0.5 Cos@2 qD, Sin@Exp@qê2DD<, 8q, 0, 2 p<,
ImageSize Ø 300,
PlotStyle Ø 8Directive@Black, DashedD,
Directive@Black, DotDashedD,
Directive@Black, DottedD<E
Out[16]=
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
The options for PolarPlot are essentially the same as Plot. One notable exception is
the absence of options related to Filling. Also note that AspectRatio is automatic by
default, which makes sense because symmetry is an essential aesthetic of polar plots.
In[17]:=
Complement@Options@PolarPlotD, Options@PlotDD
Out[17]=
9AspectRatio Ø Automatic, Axes Ø Automatic, AxesOrigin Ø 80, 0<,
MeshFunctions Ø 8Ò3 &<, PlotRange Ø Automatic, PolarAxes Ø False,
PolarAxesOrigin Ø Automatic, PolarGridLines Ø None, PolarTicks Ø Automatic=
6.3 Creating Plots Parametrically
Problem
You want to create Lissajous curves and other parametric plots where points {fx[u],
fy[u]} are plotted against a parameter u. 
6.3 Creating Plots Parametrically | 249

Solution
Here are some common Lissajous curves. Note how ParametricPlot takes a pair of
functions in the form of a list. 
In[18]:=
GraphicsGrid@88ParametricPlot@
8Sin@Pi uD, Sin@2 Pi uD<, 8u, 0, 2<, PlotLabel Ø "H1:2L"D,
ParametricPlot@8Sin@2 Pi uD, Sin@ Pi uD<,
8u, 0, 2<, PlotLabel Ø "H2:1L"D<,
8ParametricPlot@8Sin@5 Pi uD, Sin@4 Pi uD<, 8u, 0, 2<,
PlotLabel Ø "H5:4L"D,
ParametricPlot@
8Sin@9 Pi uD, Sin@8 Pi uD<, 8u, 0, 2<, PlotLabel Ø "H9:8L"D<<D
Out[18]=
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
H1:2L
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
H2:1L
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
H5:4L
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
H9:8L
250 | Chapter 6: Two-Dimensional Graphics and Plots

Discussion
Here is an animation showing the effect of phase shifting on signals of frequency 
ratio 1:1 and 2:1.
In[19]:=
Animate@
GraphicsRow@8ParametricPlot@8Sin@Pi u + dD, Sin@ Pi uD<, 8u, 0, 2<D,
ParametricPlot@8Sin@2 Pi u + dD, Sin@ Pi uD<, 8u, 0, 2<D
<D, 8d, 0, 2 Pi<D
Out[19]=
d
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
You also use ParametricPlot to create parametric surfaces. This introduces a second
parameter.
In[20]:=
ParametricPlot@
8 r^2 Cos@Sqrt@ tDD, Sqrt@ rD Sin@r tD<, 8t, 0, 2 Pi<, 8r, 1, 2<D
Out[20]=
See Also
The 3D counterpart to ParametricPlot, ParametricPlot3D, is covered in Recipe 7.5.
6.3 Creating Plots Parametrically | 251

6.4 Plotting Data 
Problem
You  want  to  graph  data  values  that  were  captured  outside  Mathematica  or  previ-
ously computed within Mathematica.
Solution
Use ListPlot with either lists of x values or lists of (x,y) pairs. In this first plot, I gen-
erate the y values but let the x values derive from the iteration range. You can also ex-
plicitly provide the x and y values as a pair for each point plotted, as shown in the
second ListPlot, which compares PrimePi to Prime.
In[21]:=
GraphicsRowA9
ListPlotATableAPrime@iDë I1 + Log@Fibonacci@iDDM, 8i, 1, 100<E,
ImageSize Ø 250E,
ListPlotATable@8PrimePi@iD, Prime@iD<, 8i, 1, 200<D, ImageSize Ø 250E
=E
Out[21]=
20
40
60
80
100
4
6
8
10
10
20
30
40
200
400
600
800
1000
1200
252 | Chapter 6: Two-Dimensional Graphics and Plots

Discussion
ListPlot shares most options with Plot; instead of repeating them here, I show only
the differences.
In[22]:=
Complement@Options@ListPlotD, Options@PlotDD
Out[22]=
9DataRange Ø Automatic, InterpolationOrder Ø None, Joined Ø False,
MaxPlotPoints Ø ¶, PlotMarkers Ø None, PlotRange Ø Automatic=
DataRange allows you to specify minimum and maximum values for the x-axis. In the
first plot, the x-axis is assumed to be integer values. 
In[24]:=
data = Table@Sin@xD, 8x, -10, 10, 0.1<D; GraphicsRowA
9ListPlot@dataD, ListPlotAdata, DataRange Ø 8-10, 10<E=, ImageSize Ø 500E
Out[24]=
50
100
150
200
-1.0
-0.5
0.5
1.0
-10
-5
5
10
-1.0
-0.5
0.5
1.0
InterpolationOrder  is  used  with  Joined  to  control  the  way  lines  drawn  between
points are interpolated. A value of 1 results in straight lines; higher values result in
smoothing, although for most practical purposes, a value of 2 is sufficient.
6.4 Plotting Data | 253

In[25]:=
data = RandomReal@80, 2<, 8D;
GraphicsColumnA
TableAListPlotAdata, Joined Ø True, InterpolationOrder Ø i,
PlotLabel Ø I"InterpolationOrder" <> ToString@iDM,
ImageSize Ø SmallE, 8i, 81, 2, 3<<EE
Out[26]=
2
4
6
8
0.5
1.0
1.5
InterpolationOrder 1
2
3
4
5
6
7
8
0.5
1.0
1.5
2.0
InterpolationOrder 2
2
3
4
5
6
7
8
0.5
1.0
1.5
2.0
InterpolationOrder 3
See Also
Mathematica  has  related  list  plotting  functions  ListLinePlot,  ListLogLogPlot,  and
ListLogLinearPlot that have similar usage to ListPlot but are specialized for certain
types of data. Refer to the Mathematica documentation to learn more.
254 | Chapter 6: Two-Dimensional Graphics and Plots

6.5 Mixing Two or More Graphs 
into a Single Graph
Problem
You want to mix several kinds of plots into a single graph.
Solution
Use Show to combine graphs produced by different functions.
In[27]:=
Show@Plot@x, 8x, 1, 100<D, ListPlot@Table@Prime@xD, 8x, 1, 100<DDD
Out[27]=
20
40
60
80
100
20
40
60
80
100
Discussion
When using Show to combine plots, you can override options used in the indi-
vidual graphs. For example, you can override the position of axes, aspect ratio,
and plot range.
In[28]:=
g1 = PlotAx^2 - x, 8x, 1, 10<, AspectRatio Ø 0.6, AxesOrigin Ø AutomaticE;
g2 = PlotAx^2 + x, 8x, 1, 10<, AspectRatio Ø 0.6, AxesOrigin Ø AutomaticE;
In[30]:=
GraphicsColumnA
9g1, g2, ShowAg1, g2, AspectRatio Ø 1, AxesOrigin Ø 80, 0<, PlotRange Ø AllE=,
ImageSize Ø 200E
6.5 Mixing Two or More Graphs into a Single Graph | 255

Out[30]=
4
6
8
10
20
40
60
80
4
6
8
10
20
40
60
80
100
2
4
6
8
10
20
40
60
80
100
Show can be used to combine arbitrary graphics. For example, you can give a graphic
a background image.
256 | Chapter 6: Two-Dimensional Graphics and Plots

In[31]:=
g1 = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "Graphics"E;
g1 = GraphicsA9Opacity@0.3D, g1@@1DD=E;
H*Insert opacity directive into graphics.*L
ShowAPlotAx, 8x, 0, 100<, PlotStyle Ø ThickE,
g1, PlotRange Ø All, ImageSize Ø SmallE
Out[32]=
One of my favorite mathematical illustrations is convergence through the iteration
of a function (something I am sure many of you have done by repeatedly pressing
Cos on a pocket calculator). Here, NestList performs 12 iterations. We duplicate ev-
ery two and flatten and partition into pairs with overhand of 1 to yield the points for
illustrating the convergence of the starting point 1 to the solution of x == Cos[x]. 
In[33]:=
Show@Plot@8x, Cos@xD<, 8x, 0.1, 1.1<D, Graphics@
Line@Partition@Flatten@8Ò, Ò< & êü NestList@Cos, 1.0, 12DD, 2, 1DDDD
Out[33]=
0.4
0.6
0.8
1.0
0.2
0.4
0.6
0.8
1.0
6.5 Mixing Two or More Graphs into a Single Graph | 257

Show uses the following rules to combine plots:
Ë Use the union of plot intervals.
Ë Use  the  value  of  Options  from  the  first  plot  unless  overridden  by  Show’s  own
options.
6.6 Displaying Multiple Graphs in a Grid
Problem
You want to display several related graphs for easy comparison.
Solution
Use GraphicsGrid in Mathematica 6 or GraphicsArray in earlier versions. You can use
tables to group several plots together, but this gives you very little control of the lay-
out  of  the  images.  GraphicsGrid  gives  control  of  the  dimensions  of  the  grid,  the
frame, spacing, dividers, and other options. The dimensions of the grid are inferred
from the dimensions of the list of graphics passed as the first argument. You will
find  Partition  handy  for  converting  a  linear  list  into  the  desired  two-dimensional
form.
In[34]:=
WithA8cols = 2<,
GraphicsGridA
PartitionATableAPlotA0.5 Sin@2 qD, 8q, 0, 2 p<,
Mesh Ø m, ImageSize Ø Small, Frame Ø True,
FrameLabel Ø "Mesh Ø " <> ToString@mDE,
8m, 8None, Automatic, All, Full, 16, 50<<E,
colsE, Frame Ø AllE
E
258 | Chapter 6: Two-Dimensional Graphics and Plots

Out[34]=
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø None
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø Automatic
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø All
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø Full
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø 16
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Mesh Ø 50
Discussion
In  addition  to  GraphicsGrid,  Mathematica  provides  GraphicsRow  and  GraphicsColumn,
which are simpler to use for laying out graphics horizontally or vertically. These
layout functions can be combined and nested to create more complex layouts. Here
I demonstrate using GraphicsRow to show a GraphicsColumn next to another Graphics-
Row. Frames can be drawn around the row or column (FrameØTrue) or additionally
dividing all the elements (FrameØAll).
6.6 Displaying Multiple Graphs in a Grid | 259

In[35]:=
WithA9polygons = TableA
GraphicsA9EdgeForm@BlackD, FaceFormALightGrayE,
Polygon@Table@8Cos@2 Pi k êpD, Sin@2 Pi k êpD<, 8k, p<DD=,
ImageSize Ø TinyE,
8p, 4, 8, 2<E=,
GraphicsRowA9
GraphicsColumnApolygons, Frame Ø TrueE,
GraphicsRowApolygons, Frame Ø TrueE
=, Frame Ø All, ImageSize Ø 450EE
Out[35]=
6.7 Creating Plots with Legends
Problem
You want to identify the information in a plot of multiple data sets using a legend.
Solution
Use the PlotLegends` package with the PlotLegend, LegendPosition, and LegendSize
options.
260 | Chapter 6: Two-Dimensional Graphics and Plots

In[36]:=
NeedsA"PlotLegends`"E;
PlotA8Sin@xD, Sin@2 xD<, 8x, 0, 2 Pi<,
PlotStyle Ø 8Directive@Black, DottedD, Directive@Black, DashedD<,
PlotLegend Ø 8"Sin x", "Sin 2x"<,
LegendPosition Ø 81, 0.1<, LegendSize Ø 0.75E
Out[37]=
1
2
3
4
5
6
-1.0
-0.5
0.5
1.0
Sin 2x
Sin x
Legends use their own coordinate system, for which the center of the graphic is at
{0,0}  and  the  inside  is  the  scaled  bounding  region {{-1,-1},{1,1}}. LegendPosition
refers to the lower left corner of the legend.
Discussion
There are a variety of options for further tweaking the legend’s appearance. You can
turn off or control the offset of the drop shadow (LegendShadow); control spacing of
various  elements  using  LegendSpacing,  LegendTextSpace,  LegendLabelSpace,  and
LegendBorderSpace;  control  the  labels  with  LegendTextDirection,  LegendTextOffset,
LegendSpacing,  and  LegendTextSpace;  and  give  the  legend  a  label  with  LegendLabel
and LegendLabelSpace. 
Notice the effect of LegendTextSpace, which is a bit counterintuitive because it ex-
presses the ratio of the text space to the size of a key box so larger numbers actually
shrink the legend. LegendSpacing controls the space around each key box on a scale
where the box size is 1. 
6.7 Creating Plots with Legends | 261

In[38]:=
plotCommonOptions = SequenceA
PlotStyle Ø 8Directive@Black, DottedD, Directive@Black, DashedD<,
PlotLegend Ø 8"Sin x", "Sin 2x"<, LegendPosition Ø 81, 0.1<,
LegendSize Ø 0.75, ImageSize Ø 250E;
GraphicsGridA9
9PlotA8Sin@xD, Sin@2 xD<, 8x, 0, 2 Pi<,
Evaluate@plotCommonOptionsD,
LegendShadow Ø None,
LegendSpacing Ø 1ê2, LegendTextSpace Ø 10E,
PlotA8Sin@xD, Sin@2 xD<, 8x, 0, 2 Pi<,
Evaluate@plotCommonOptionsD,
LegendShadow Ø None, LegendLabel Ø "Plots",
LegendSpacing Ø 0.2, LegendTextSpace Ø 5E
=,
9PlotA8Sin@xD, Sin@2 xD<, 8x, 0, 2 Pi<,
Evaluate@plotCommonOptionsD,
LegendShadow Ø 8-0.1, -0.1<, LegendLabel Ø "Plots",
LegendSpacing Ø 0.2, LegendTextSpace Ø 5E,
PlotA8Sin@xD, Sin@2 xD<, 8x, 0, 2 Pi<,
Evaluate@plotCommonOptionsD,
LegendShadow Ø 80.1, 0.1<,
LegendSpacing Ø 1ê2, LegendTextSpace Ø 10E
=
=,
Dividers Ø AllE
262 | Chapter 6: Two-Dimensional Graphics and Plots

Out[39]=
1
2
3
4
5
6
-1.0
-0.5
0.5
1.0
Sin 2x
Sin x
1
2
3
4
5
6
-1.0
-0.5
0.5
1.0
Sin 2x
Sin x
Plots
1
2
3
4
5
6
-1.0
-0.5
0.5
1.0
Sin 2x
Sin x
Plots
1
2
3
4
5
6
-1.0
-0.5
0.5
1.0
Sin 2x
Sin x
See Also
Sometimes  you  want  to  create  a  more  customized  legend.  In  that  case,  consider  
Legend and ShowLegend.
See the tutorial on the PlotLegends` package at http://bit.ly/TYvfV.
6.8 Displaying 2D Geometric Shapes
Problem
You want to create graphics that contain lines, squares, circles, and other geometric
objects.
Solution
Mathematica  has  a  versatile  collection  of  graphics  primitives:  Text,  Polygon,
Rectangle, Circle, Disk, Line, Point, Arrow, Raster, and Point can be combined to
create  a  variety  of  2D  drawings.  Here  I  demonstrate  a  somewhat  frivolous  yet
instructive  function  that  creates  a  snowman  drawing  using  a  broad  sampling  of
the  available  primitives.  Included  is  a  useful  function,  ngon,  for  creating  regular
polygons.
6.8 Displaying 2D Geometric Shapes | 263

In[41]:=
ClearAllAgenerateSnowE
In[42]:=
H*Create a regular polygon.*L
ngonAsides_Integer, center_List, size_?NumberQ, rotation_: 0 E :=
Polygon@Table@8size Cos@2 Pi kêsides + rotationD + center@@1DD,
size Sin@2 Pi kêsides + rotationD + center@@2DD<, 8k, sides<DD
H*Generate snow as randomly scattered pairs of
semitransparent points of random size.*L
generateSnowAminPoint_List, maxPoint_List, density_?NumberQE := ModuleA
9size, z = 100, j=, 9Opacity@0.3D, ReapADoAWhichARandomReal@D < 0.3,
size = RandomReal@80.001, 0.008<D;
j = RandomReal@8-1.0, 1.0<D;
SowA9PointSize@sizeê1.3D,
IfARandomReal@D < 0.5, 9PointA9x, y + z size + j =E,
PointA9x, y - z size + j=E, PointA9x + z size, y + j =E,
PointA9x - z size, y + j=E=, 9PointA9x + z size, y + z size + j =E,
PointA9x - z size, y + z size + j=E, PointA9x + z size,
y - z size + j =E, PointA9x - z size, y - z size + j=E=E,
PointSize@sizeD, PointA9x, y + j=E=EE,
9x, minPoint@@1DD, maxPoint@@1DD, density=,
9y, minPoint@@2DD, maxPoint@@2DD, density=EE@@2, 1DD=E
H*Draw a snowman whose base is of the given radius.*L
snowmanAbodyRadius_E := ModuleA9bodyCenter = 80, 0<,
H*Proportioning the torso and head
based on golden ratio gives a pleasing effect.*L
torsoRadius = bodyRadius ë GoldenRatio,
headRadius = bodyRadius ë HGoldenRatio^2L,
torsoCenter, headCenter, leftShoulder, rightShoulder,
buttonSize = bodyRadiusë 10, buttonSep = bodyRadiusë 3.3,
leftHand, rightHand, mouthCenter, leftEyeCenter, rightEyeCenter=,
torsoCenter = 9bodyCenter@@1DD, torsoRadius + bodyRadius=;
headCenter =
9bodyCenter@@1DD, bodyRadius + 2 torsoRadius + headRadius=;
H*Position the arms at -60 and 60 degrees.*L
leftShoulder =
torsoCenter + 8torsoRadius *Sin@-Piê3D, torsoRadius * Cos@-Piê3D<;
leftHand = torsoCenter + 83 torsoRadius *Sin@-Piê3D,
3 torsoRadius * Cos@-Piê3D<;
rightShoulder = torsoCenter + 8torsoRadius *Sin@Piê3D,
torsoRadius * Cos@Piê3D<;
rightHand = torsoCenter + 83 torsoRadius *Sin@Piê3D,
3 torsoRadius * Cos@Piê3D<;
264 | Chapter 6: Two-Dimensional Graphics and Plots

H*Position eyes at -45 and 45 degrees and half
the radius of the head.*L
leftEyeCenter = headCenter + 80.5 headRadius * Sin@-Piê4D,
0.5 headRadius * Cos@-Piê4D<;
rightEyeCenter = headCenter + 80.5 headRadius * Sin@Piê4D,
0.5 headRadius * Cos@Piê4D<;
H*Position mouth at 180 degrees -
bottom of circle. Also half radius of head.*L
mouthCenter = headCenter +
80.5 headRadius * Sin@PiD, 0.5 headRadius * Cos@PiD<;
GraphicsA9
CircleAbodyCenter, bodyRadiusE, H*base ciricle*L
Circle@torsoCenter, torsoRadiusD, H*middle circle*L
Circle@headCenter, headRadiusD, H*head*L
Circle@mouthCenter, headRadiusê4, 8-Pi, 0<D,
H*half circle for mouth*L
H*Use disks for eyes.*L
DiskAleftEyeCenter, headRadiusê8E,
DiskArightEyeCenter, headRadiusê8E,
H*Make a carrot-shaped nose out of lines. The
proportions here were worked out by trial and error.*L
Line@8headCenter - 80, headRadiusê10<, headCenter -
8headRadiusê2, headRadiusê5<, headCenter + 80, headRadiusê10<<D,
H*I use arrows for arms to illustrate how they
work. See discussion for more detail.*L
8Arrowheads@8-0.1, 0<D, Arrow@8leftHand, leftShoulder<D<,
9Arrowheads@80, 0.1<D, ArrowA9rightShoulder, rightHand=E=,
9Gray, Thickness@torsoRadiusê800D,
LineA9rightHand + 8-2, 2<, 9rightHand@@1DD - 2, -bodyRadiusë 2==E,
RectangleAbodyCenter + 9bodyRadiusë 1.4, -2=,
bodyCenter + 92.4 bodyRadius, -bodyRadius=E=,
generateSnowA9-2 bodyRadius, -bodyRadius=,
93 bodyRadius, 3.1 bodyRadius=, 5E,
H*Use pentagons to simulate coal buttons.*L
ngonA5, 90, torsoRadius + bodyRadius - buttonSep=, buttonSizeE,
ngonA5, 90, torsoRadius + bodyRadius=, buttonSizeE,
ngonA5, 90, torsoRadius + bodyRadius + buttonSep=, buttonSizeE=,
ImageSize -> bodyRadius*10EE
snowman@40D
6.8 Displaying 2D Geometric Shapes | 265

Out[45]=
Discussion
One of the keys to getting the most out of the graphics primitives is to learn how to
combine  them  with  graphics  directives.  Some  directives  are  very  specific,  whereas
others are quite general. For example, Arrowheads applies only to Arrow, whereas Red
and Opacity apply to all primitives. A directive will apply to all objects that follow it,
subject to scoping created by nesting objects within a list. For example, in the follow-
ing graphic, Red applies to Disk and Rectangle but not Line because the line is given
a specific color and thickness within its own scope.
In[46]:=
GraphicsA9Red, Disk@8-2, -2<, 0.5D, Rectangle@D, 8Thickness@0.02D,
Black, Line@88-1.65, -1.65<, 80, 0<<D<=, ImageSize Ø SmallE
Out[46]=
Color directives can use named colors: Red, Green, Blue, Black, White, Gray, Cyan,
Magenta,  Yellow,  Brown,  Orange,  Pink,  Purple,  LightRed,  LightGreen,  LightBlue,
LightGray, LightCyan, LightMagenta, LightYellow, LightBrown, LightOrange, LightPink, and
LightPurple.  You  can  also  synthesize  colors  using  RGBColor  or  Hue,  CMYKColor,
GrayLevel,  and  Blend.  In  Mathematica  6  or  later  versions,  these  directives  can
take opacity values in addition to values that define the color or gray settings. Blend
is also new to Mathematica 6.
266 | Chapter 6: Two-Dimensional Graphics and Plots

In[47]:=
GraphicsATableA9Hue@xD, Rectangle@8x, 1<, 8x + 0.1, 2<D=, 8x, 0, 0.99, .1<E,
ImageSize -> SmallE
Out[47]=
In[48]:=
GraphicsATableA9Hue@xD, Rectangle@8x, 1<, 8x + 0.05, 2<D,
Blend@8Hue@xD, Hue@x + 0.05D<, 0.25D, Rectangle@8x + .05, 1<,
8x + 0.1, 2<D=, 8x, 0, 0.99, .1<E, ImageSize -> SmallE
Out[48]=
Of course, you’ll need to try the code on your own to view the colors.
6.8 Displaying 2D Geometric Shapes | 267

Thickness[r]  is  specified  relative  to  the  total  width  of  the  graphic  and,  therefore,
scales with size changes. AbsoluteThickness[d] is specified in units of printer points
(1/72 inch) and does not scale. Thick and Thin are predefined versions (0.25 and 2,
respectively) of AbsoluteThickness. Thickness directives apply to primitives that con-
tain lines such as Line, Polygon, Arrow, and the like.
In[49]:=
Graphics@8Line@880, -1<, 80, 1<<D,
8Thin, Line@880.5, -1<, 80.5, 1<<D<, 8Thick, Line@881, -1<, 81, 1<<D<,
8AbsoluteThickness@3D, Line@881.5, -1<, 81.5, 1<<D<<D
Out[49]=
See Also
Recipe 14.12 applies Mathematica’s graphics primitives to the serious task of visualiz-
ing Hull-White trees, which are used in modeling interest-rate-sensitive securities.
Recipe 13.11 shows an application in constructing finite element diagrams used in
engineering.
268 | Chapter 6: Two-Dimensional Graphics and Plots

6.9 Annotating Graphics with Text
Problem
You want to add stylized text to graphics.
Solution
Use Text with Style to specify FontFamily, FontSubstitutions, FontSize, FontWeight,
FontSlant, FontTracking, FontColor, and Background.
In[50]:=
GraphicsA9TextAStyle@"12 Point Default Font", FontSize Ø 12D, 80, 0<E, TextA
Style@"16 Point Italic", FontSize Ø 16, FontSlant Ø ItalicD, 80, -.2<E,
TextAStyleA"14 Point Bold", FontSize Ø 14, FontWeight Ø BoldE, 80, -.4<E,
TextA
StyleA"14 Point Arial", FontSize Ø 14, FontFamily Ø "Arial"E, 80, -.6<E,
TextAStyleA"14 Point Arial Narrow", FontSize Ø 14,
FontFamily Ø "Arial", FontTracking Ø "Narrow"E, 80, -.8<E,
TextAStyleA"14 Point Bold White on Black", FontSize Ø 14,
FontWeight Ø Bold, FontColor Ø White, Background Ø BlackE,
80, -1<E=, ImageSize Ø SmallE
Out[50]=
12 Point Default Font
16 Point Italic
14 Point Bold
14 Point Arial
14 Point ArialNarrow
14 Point Bold White on Black
Discussion
In  this  chapter,  I  demonstrate  various  plotting  functions  that  contain  options  for
adding labels to the entire graph, frames, and axes. These options can also be stylized.
6.9 Annotating Graphics with Text | 269

In[51]:=
PlotA0.5 Sin@2 qD, 8q, 0, 2 p<,
PlotLabel Ø StyleA0.5 Sin@2 qD, FontSize Ø 20, FontFamily Ø "Arial"E,
AxesLabel Ø 8"Radians", "Amplitude"<, LabelStyle Ø
DirectiveABold, FontFamily Ø "Arial", FontSize Ø 12E, Frame Ø True,
FrameLabel Ø Style@"Sine Wave", FontSlant Ø ItalicD, ImageSize Ø MediumE
Out[51]=
0
1
2
3
4
5
6
-0.4
-0.2
0.0
0.2
0.4
Sine Wave
Radians
0.5 sinH2 qL
The Style directive was added into Mathematica 6 and is quite versatile. Style can
add style options to both Mathematica expressions and graphics.
6.10 Creating Custom Arrows
Problem
You want to create arrows with custom arrowheads, tails, and connecting lines for
use in annotating graphics.
Solution
Use Arrowheads with a custom graphic to create arbitrary arrowheads and tails.
In[52]:=
WithA8h = Graphics@8Disk@80, 0<, 0.75D<D,
t = Graphics@8Line@88-0.5, 0<, 80.5, 0<<D,
Line@880, -0.6<, 80, 0.6<<D, Line@880.2, -0.6<, 80.2, 0.6<<D<D<,
GraphicsA8Arrowheads@880.05, 1, h<, 80.1, 0, t<<D,
Arrow@880, 0<, 80.25, 0.25<<D<, ImageSize Ø SmallEE
270 | Chapter 6: Two-Dimensional Graphics and Plots

Out[52]=
Discussion
Arrowheads is quite versatile. You can easily create double-ended arrows and arrows
with multiple arrowheads along the span.
In[53]:=
GraphicsA8Arrowheads@8-0.1, 0.1<D, Arrow@880, 0<, 81, 0<<D,
Arrowheads@80, 0.1, .1, .1, .1<D, Arrow@880, -0.5<, 81, -0.5<<D<,
ImageSize Ø SmallE
Out[53]=
You may consider using Arrowheads to label arrows, but Mathematica does not treat
such “arrowheads” specially, so you may get undesirable effects.
6.10 Creating Custom Arrows | 271

In[54]:=
GraphicsA9ArrowheadsA90, 9Automatic, 0.5, GraphicsA
9TextAStyleA"Label", FontSize Ø 14, FontWeight Ø BoldEE=E=, 0.1=E,
Arrow@880, 0<, 8-0.25, 0.25<<D=, ImageSize Ø SmallE
Out[54]=
Label
A  better  option  is  to  position  the  text  by  using  Rotate  with  Text  or  Inset  or  by
using GraphPlot or related functions (see Recipe 4.6). The advantage of Inset over
manually positioned Text is that you get auto-centering if you don’t mind the label
not being parallel to the arrow.
In[55]:=
GraphicsA9Arrowheads@80.1<D, Arrow@880, 0<, 8-0.25, 0.25<<D,
RotateATextAStyleA"Label", FontSize Ø 14, FontWeight Ø BoldE,
8-0.14, 0.11<E, -Piê4E=, ImageSize Ø SmallE
Out[55]=
Label
272 | Chapter 6: Two-Dimensional Graphics and Plots

In[56]:=
GraphicsA9Arrowheads@80.1<D, Arrow@880, 0<, 8-0.25, 0.25<<D,
InsetATextAStyleA"Label", FontSize Ø 14, FontWeight Ø BoldEEE=,
ImageSize Ø SmallE
Out[56]=
Label
6.10 Creating Custom Arrows | 273


CHAPTER 7
Three-Dimensional Plots and Graphics
Maybe I’ll win
Saved by zero
Holding onto
Winds that teach me
I will conquer
Space around me
The Fixx, “Saved by Zero”
7.0 Introduction
Modern mathematics demands advanced visualization tools. Although Mathemati-
ca’s  2D  graphics  are  impressive,  3D  graphics  is  where  Mathematica  really  distin-
guishes  itself.  As  with  2D,  3D  graphics  are  represented  symbolically  but  with  the
head Graphics3D instead of Graphics. There are 3D counterparts to most 2D plotting
functions. For example, Plot3D and ListPlot3D are the counterparts to the 2D func-
tions Plot and ListPlot. There are also many functions unique to 3D space, such as
SphericalPlot3D and RevolutionPlot3D. 
Mathematica’s 3D graphics are interactive, although it is difficult to illustrate this in
book form! Any 3D plot or drawing can be rotated, flipped, and stretched, allowing
you to see different perspectives. Furthermore, Mathematica 6 added a host of op-
tions for controlling lighting, camera placement, and even how light reflects off of
surfaces (see Recipes 7.12 and 7.13). 
275

The Symbolic Nature of Graphics
I think most users are quite impressed with the breadth and depth of what Mathe-
matica 7 can achieve with plotting functions (see Recipes 7.1 through 7.9). However,
as a programmer, I am even more taken with what can be achieved in Mathematica
that would be next to impossible in most plotting packages outside of Mathematica.
When  you  ask  the  Mathematica  kernel  to  perform  a  plot,  it  does  not  produce  a
raster image that the frontend simply renders using the graphics hardware. Instead,
it produces a symbolic representation of the plot that the frontend translates into a
raster  image.  Why  is  this  relevant?  Imagine  you  were  working  in  another  domain
(e.g., Microsoft Excel) and there were two plotting functions that each did half of
what you wanted to render on the screen. How could you morph those two plots to
achieve the desired result? You couldn’t. (I’m ignoring whatever skills you might pos-
sess as a Photoshop hacker!) In Mathematica, all hope is not lost. In Recipe 7.6, a
3D plot and a 2D contour plot are combined to achieve a 3D plot with a 2D contour
“shadow” underneath. Another example is Recipe 7.10: RevolutionPlot3D is used to
generate  a  cone  to  compensate  for  the  lack  of  a  Cone  primitive  in  Mathematica  6
(Cone  is  built  into  Mathematica  7).  Achieving  these  results  involves  sticking  your
head under the hood and, sometimes, doing quite a bit of trial and error, but the re-
sults are within reach once you have the general principles.
See Also
In  Recipe  18.5,  I  discuss  how  the  attributes  of  3D  graphics  can  be  controlled
through stylesheets. If you intend to create publication-quality documents in Mathe-
matica, you should familiarize yourself with stylesheets. 
7.1 Plotting Functions of Two Variables 
in Cartesian Coordinates
Problem
You want to graph one or more built-in or user-defined functions of two variables.
Solution
Use Plot3D with the function or functions to plot and two lists specifying the ranges
for the independent variables. 
276 | Chapter 7: Three-Dimensional Plots and Graphics

In[1]:=
Plot3DASinAx Pi ExpA-y + xEE, 8x, -1, 1<, 9y, -1, 1=E
Out[1]=
As with most plots, you can provide multiple functions. However, 3D plots will be-
come crowded quickly (Figure 7-1a), so consider placing multiple plots side by side
rather than trying to shoehorn everything into a single plot. With some functions
and options, this is not an issue (Figure 7-1b).
In[2]:=
GraphicsGridA
99Plot3DA9SinAx Pi ExpA-y + xEE, CosAx Pi ExpA1 - x yEE=, 8x, -1, 1<,
9y, -1, 1=, PlotLabel Ø "a"E, Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<,
9y, -2, 2=, BoxRatios Ø Automatic, PlotLabel Ø "b"E==, ImageSize Ø LargeE
Out[2]=
Figure 7-1. 3D plots of multiple functions
7.1 Plotting Functions of Two Variables in Cartesian Coordinates | 277

Discussion
As you might suspect, Plot3D has a variety of options for customizing presentation.
Here I use Complement to list only those options that differ from the 2D Plot function
in Recipe 6.1.
In[3]:=
Complement@First êü Options@Plot3DD, First êü Options@PlotDD
Out[3]=
9AxesEdge, BoundaryStyle, Boxed, BoxRatios, BoxStyle, ControllerLinking,
ControllerMethod, ControllerPath, FaceGrids, FaceGridsStyle,
Lighting, NormalsFunction, RotationAction, SphericalRegion, ViewAngle,
ViewCenter, ViewMatrix, ViewPoint, ViewRange, ViewVector, ViewVertical=
In[4]:=
9AxesEdge, BoundaryStyle, Boxed, BoxRatios, BoxStyle, ControllerLinking,
ControllerMethod, ControllerPath, FaceGrids, FaceGridsStyle,
Lighting, NormalsFunction, RotationAction, SphericalRegion, ViewAngle,
ViewCenter, ViewMatrix, ViewPoint, ViewRange, ViewVector, ViewVertical=
Out[4]=
9AxesEdge, BoundaryStyle, Boxed, BoxRatios, BoxStyle, ControllerLinking,
ControllerMethod, ControllerPath, FaceGrids, FaceGridsStyle,
Lighting, NormalsFunction, RotationAction, SphericalRegion, ViewAngle,
ViewCenter, ViewMatrix, ViewPoint, ViewRange, ViewVector, ViewVertical=
AxesEdge determines where the axes are drawn, and the default value of Automatic
(Figure 7-2a) usually gives good results. You can override the default by proving a
specification  of  the  form  {{dir  y,  dir  z},{dir  x,  dir  z},{dir  x,  dir  y}}
where each dir  i must be either +1 or |1, indicating whether axes are drawn
on the edge of the box with a larger or smaller value of coordinate i, respec-
tively (Figure 7-2b, c, and d). 
278 | Chapter 7: Three-Dimensional Plots and Graphics

In[5]:=
GraphicsGridA99Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=,
BoxRatios Ø Automatic, PlotLabel Ø "a", AxesEdge Ø AutomaticE, Plot3DA
9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø Automatic,
PlotLabel Ø "b", AxesEdge Ø 88-1, -1<, 8-1, 1<, 8-1, -1<<E=,
9Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø
Automatic, PlotLabel Ø "c", AxesEdge Ø 881, 1<, 81, -1<, 81, 1<<E,
Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø
Automatic, PlotLabel Ø "d", AxesEdge Ø 881, 1<, 81, 1<, 81, 1<<E==,
ImageSize Ø 400, Spacings Ø 80.1, 0.1<E
Out[5]=
Figure 7-2. Examples of AxesEdge option
7.1 Plotting Functions of Two Variables in Cartesian Coordinates | 279

BoundaryStyle allows you to stylize the edge of a plot surface.
In[6]:=
Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=,
BoundaryStyle Ø Directive@Black, Thickness@0.0125DDE
Out[6]=
Boxed, BoxRatios, and BoxStyle control the presence, proportions, and style of the
edges surrounding 3D plots. Each of the plots in Figure 7-3 is of the same function.
The differences are that Figure 7-3a is not boxed, Figure 7-3b is boxed with Auto-
matic ratios, and Figure 7-3c and Figure 7-3d have specified ratios.
280 | Chapter 7: Three-Dimensional Plots and Graphics

In[7]:=
GraphicsGridA
99Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=, PlotLabel Ø "a",
Boxed Ø FalseE, Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<,
9y, -2, 2=, BoxRatios Ø Automatic, PlotLabel Ø "b"E=,
9Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø
81, 2, 1<, PlotLabel Ø "c", AxesEdge Ø 881, 1<, 81, -1<, 81, 1<<E,
Plot3DA9x^2 + y^2, -x^2 - y^2=, 8x, -2, 2<, 9y, -2, 2=,
BoxRatios Ø 82, 1, 2<, PlotLabel Ø "d"E==, ImageSize Ø MediumE
Out[7]=
Figure 7-3. Examples of BoxRatios option
FaceGrids specifies grid lines to draw on the faces of the bounding box. You can
specify All or specific faces using {x,y,z}, where two values are 0 and the third is
either +1 (largest value) or |1 (smallest value). FaceGridsStyle allows you to stylize
the grid to your liking.
7.1 Plotting Functions of Two Variables in Cartesian Coordinates | 281

In[8]:=
GraphicsGridA99Plot3DAx^2 + y^2, 8x, -2, 2<, 9y, -2, 2=,
BoxRatios Ø Automatic, PlotLabel Ø "a", FaceGrids Ø AllE,
Plot3DAx^2 + y^2, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø Automatic,
PlotLabel Ø "b", FaceGrids Ø 880, 0, 1<<E=,
9Plot3DAx^2 + y^2, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø Automatic,
PlotLabel Ø "c", FaceGrids Ø 881, 0, 0<, 80, 1, 0<<E,
Plot3DAx^2 + y^2, 8x, -2, 2<, 9y, -2, 2=, BoxRatios Ø Automatic,
PlotLabel Ø "d", FaceGrids Ø 88-1, 0, 0<, 80, 1, 0<<,
FaceGridsStyle Ø Directive@Red, ThickDE==, ImageSize Ø 400E
Out[8]=
See Also
ViewAngle, ViewCenter, ViewMatrix, ViewPoint, ViewRange, ViewVector, and View-
Vertical  are  options  that  give  you  detailed  control  of  the  orientation  of  the  plot.
These are covered in Recipe 7.12.
Recipe 6.1 demonstrates Plot, which is the 2D counterpart to Plot3D.
282 | Chapter 7: Three-Dimensional Plots and Graphics

7.2 Plotting Functions in Spherical Coordinates
Problem
You want to plot a surface with spherical radius r as a function of rotational angles q
(latitude) and f (longitude).
Solution
Use SphericalPlot3D when plotting one or more surfaces in spherical coordinates.
Such plots most often arise in situations where there is some degree of rotational
symmetry. For example, a sphere is fully symmetrical under all rotations and is triv-
ially plotted using SphericalPlot3D as a constant radius.
In[9]:=
SphericalPlot3DA1, 8q, 0, Pi<, 8f, 0, 2 Pi<, ImageSize Ø SmallE
Out[9]=
Discussion
You  can  plot  multiple  surfaces  by  providing  a  list  of  functions  and  leave  holes  in
some of the surfaces by returning the symbol None for these regions. 
7.2 Plotting Functions in Spherical Coordinates | 283

In[10]:=
SphericalPlot3DA81, If@f < 3 Piê2, 2, NoneD, If@f < 3 Piê2, 3, NoneD<,
8q, 0, Pi<, 8f, 0, 2 Pi<, ImageSize Ø SmallE
Out[10]=
Of course, you will probably use SphericalPlot3D to plot more interesting functions
too.
In[11]:=
SphericalPlot3DAExp@1êH1 + qL + Cos@3 fDD,
8q, 0, Pi<, 8f, 0, 2 Pi<, ImageSize Ø SmallE
Out[11]=
284 | Chapter 7: Three-Dimensional Plots and Graphics

Use PlotStyle to achieve some dramatic effects. Applying the Opacity option is espe-
cially useful when specifying rotational angles greater than 2Pi radians; otherwise,
the resulting interior surfaces would be hidden. Compare Figure 7-4a with Figure 7-4b.
In[12]:=
GraphicsRowA
9SphericalPlot3DAIf@q < Piê4, None, 1êHf + 5 LD, 8q, 0, Pi<, 8f, 0, 4 Pi<,
PlotStyle Ø DirectiveAOrange, Opacity@0.6D, Specularity@White, 10DE,
Mesh Ø None, PlotPoints Ø 30, PlotLabel Ø "a"E,
SphericalPlot3DAIf@q < Piê4, None, 1êHf + 5 LD, 8q, 0, Pi<,
8f, 0, 4 Pi<, PlotStyle Ø DirectiveAOrange, Specularity@White, 10DE,
Mesh Ø None, PlotPoints Ø 30, PlotLabel Ø "b"E=, ImageSize Ø 400E
Out[12]=
Figure 7-4. Effect of Opacity
See Also
See Recipe 7.4 for the relationship between SphericalPlot3D and ParametricPlot3D.
7.3 Plotting Surfaces in Cylindrical Coordinates
Problem
You want to visualize a surface generated via a revolution of a function or paramet-
ric curve around the z-axis.
7.3 Plotting Surfaces in Cylindrical Coordinates | 285

Solution
Many common surfaces can be generated by revolving a 2D curve. The following ex-
amples illustrate the basic idea.
Revolve a parabola to create a bowl.
In[13]:=
RevolutionPlot3DAt^2 , 8t, 0, 1<, ImageSize Ø SmallE
Out[13]=
Revolve a vertical line at a constant distance from the center to create a cylinder.
In[14]:=
RevolutionPlot3DA81, t< , 8t, 0, 1<, ImageSize Ø SmallE
Out[14]=
Functions that incorporate the angle of revolution can create more exotic surfaces,
such as the spiral shown here. Notice how the angle of revolution can be greater (or
less) than 2Pi (one revolution).
286 | Chapter 7: Three-Dimensional Plots and Graphics

In[15]:=
RevolutionPlot3DA84 t, q< , 8t, 0, 1<, 8q, 0, 4 Pi<, ImageSize Ø SmallE
Out[15]=
Discussion
To get a feel for RevolutionPlot3D, plot the 2D parametric version of the equation
next to the 3D revolution. It is fairly easy to see how the 180-degree rotation
of the 2D curve around the y-axis in Figure 7-5a will yield the 3D surface shown
in Figure 7-5b.
7.3 Plotting Surfaces in Cylindrical Coordinates | 287

In[16]:=
ModuleA8f1, f2<,
fx@x_D := Sin@xD + Sin@9 xDê5;
fy@x_D := Cos@xD + Cos@9 xDê5;
GraphicsRowA9
ParametricPlotA9fx@tD, fy@tD=, 8t, 0, Pi<, PlotLabel Ø "a"E,
RevolutionPlot3DA9fx@tD, fy@tD=, 8t, 0, Pi<, 8q, 0, Pi<, PlotLabel Ø "b"E
=, ImageSize Ø 400EE
Out[16]=
Figure 7-5. Relationship between ParametricPlot and RevolutionPlot3D
RevolutionPlot3D was introduced in Mathematica 6. Prior to version 6, similar sur-
faces could be generated with ParametricPlot3D; however, the equations one needs
to plot a specific surface using RevolutionPlot3D are often simpler and more intuitive
than  those  used  when  plotting  parametrically.  Both  of  the  following  plots  yield  a
torus, but the RevolutionPlot3D version is simpler.
In[17]:=
GraphicsRowA
8ParametricPlot3D@8H2 + Cos@vDL Sin@uD, H2 + Cos@vDL Cos@uD, 2 + Sin@vD<,
8u, 0, 2 Pi<, 8v, 0, 2 Pi<D,
RevolutionPlot3D@82 + Cos@tD, 2 + Sin@tD<, 8t, 0, 2 Pi<D<, ImageSize Ø 400E
Out[17]=
288 | Chapter 7: Three-Dimensional Plots and Graphics

As of version 6, Mathematica did not have a RevolutionAxis option, which was in a
legacy package called Graphics`SurfaceOfRevolution`. The effect could be emulated
by swapping axes and using ViewVertical. Here I also use ViewPoint to compensate
for the different default orientations of the two plotting functions, but that is not
strictly necessary. The important aspect of the code that produces Figure 7-6 is the
transposition of t and t^2 in RevolutionPlot3D.
In[18]:=
Needs@"Graphics`SurfaceOfRevolution`"D
GraphicsRowA8RevolutionPlot3D@8t^2, t<, 8t, 0, 2<,
Ticks Ø None, ViewVertical Ø 8-1, 0, 0<, ViewPoint Ø 8-2, -2, 1.1<D,
SurfaceOfRevolution@8t, t^2<, 8t, 0, 2<, Ticks Ø None,
RevolutionAxis Ø 81, 0, 0<D<, ImageSize Ø 400E
General::obspkg :
Graphics`SurfaceOfRevolution` is now obsolete. The
legacy version being loaded may conflict with
current Mathematica functionality. See the
Compatibility Guide for updating information. à
Out[19]=
Figure 7-6.  Emulating SurfaceOfRevolution
(Note: RevolutionAxis was added in version 7.)
See Also
See discussion of ParametricPlot3D in Recipe 7.4. 
See Recipe 7.12 for use of the geometry options ViewVertical and ViewPoint.
7.3 Plotting Surfaces in Cylindrical Coordinates | 289

7.4 Plotting 3D Surfaces Parametrically
Problem
You want to plot a 3D curve or surface parameterized over a region defined by a
range. 
Solution
Here you plot a curve in 3D space by specifying a single variable u over the range 
[|Pi,Pi]. This creates the curve in 3D space, shown in Figure 7-7.
In[20]:=
ParametricPlot3DA8Cos@uD, Sin@uD, Cos@u^2D* Sin@u^2D<,
8u, -Pi, Pi<, ImageSize Ø SmallE
Out[20]=
-1.0
-0.5
0.0
0.5
1.0
-1.0
-0.5
0.0
0.5
1.0
-0.5
0.0
0.5
Figure 7-7. Curve in 3D space
Here you plot a surface in 3D space by specifying an area defined by variables u and
v, yielding Figure 7-8.
290 | Chapter 7: Three-Dimensional Plots and Graphics

In[21]:=
ParametricPlot3DA8Cos@uD, Sin@vD, Cos@u^2D* Sin@v^2D<,
8u, -Pi, Pi<, 8v, -Pi, Pi<, ImageSize Ø SmallE
Out[21]=
Figure 7-8. Surface in 3D space
Discussion
To get a better understanding of ParametricPlot3D, consider it as a generalization of
the more specialized Plot3D. In Plot3D, the x and y coordinates always vary linearly
over the range as it plots a specified function in the z-axis. This implies that you can
mimic Plot3D using ParametricPlot (Figure 7-9). The only caveat is that you need to
change the BoxRatios, which have different defaults in ParametricPlot3D.
In[22]:=
GraphicsRowA
9Plot3DASinAx yE + Cos@xD, 8x, -Pi, Pi<, 9y, -Pi, Pi=, PlotLabel Ø Plot3DE,
ParametricPlot3DA9x, y, SinAx yE + Cos@xD=, 8x, -Pi, Pi<, 9y, -Pi, Pi=,
BoxRatios Ø 81, 1, 0.4<, PlotLabel -> ParametricPlot3DE=, ImageSize Ø 400E
Out[22]=
Figure 7-9. Using ParametricPlot3D to emulate Plot3D
7.4 Plotting 3D Surfaces Parametrically | 291

The relationship between ParametricPlot3D and SphericalPlot3D can be understood
in terms of the following:
fx = f[q,f] sin q cos f
fy = f[q,f] sin q sin f
fz = f[q,f] cos q
For example, if we pick f[q,f] to be the constant 1, both SphericalPlot3D and
ParametricPlot3D give a sphere using this relationship.
In[23]:=
GraphicsRowA
8SphericalPlot3D@1, 8q, 0, Pi<, 8f, 0, 2 Pi<, PlotLabel -> SphericalPlot3DD,
ParametricPlot3D@81 Sin@qD Cos@fD, 1 Sin@qD Sin@fD, 1 Cos@qD<,
8q, 0, Pi<, 8f, 0, 2 Pi<, PlotLabel -> ParametricPlot3DD<, ImageSize Ø 400E
Out[23]=
7.5 Creating 3D Contour Plots
Problem
You want to create a plot showing the surfaces where a function of three variables
takes on a specific value (Figure 7-10).
Solution
Use  ContourPlot3D  with  a  function  to  produce  evenly  spaced  contour  surfaces  for
that function. 
292 | Chapter 7: Three-Dimensional Plots and Graphics

In[24]:=
ContourPlot3DASinAx y zE, 8x, -Pi, Pi<,
9y, -1, 1=, 8z, -1, 1<, ImageSize Ø 300E
Out[24]=
Figure 7-10. 3D contour plot example
Use  ContourPlot3D  with  an  equivalence  relation  to  plot  the  surface  where  the
equivalence is satisfied. In Figure 7-11, ContourPlot3D shows the surface where the
polynomial is equal to zero.
In[25]:=
ContourPlot3DAx^3 + y^2 - z^2 == 0,
8x, -2, 2<, 9y, -2, 2=, 8z, -2, 2<, ImageSize Ø SmallE
Out[25]=
Figure 7-11. Surface where polynomial is zero
7.5 Creating 3D Contour Plots | 293

Discussion
3D contour plots show surfaces of equal value. ContourPlot3D plots several equally
spaced  surfaces  over  the  specified  intervals.  You  use  the  option  Contours  Ø  n,
where n is an integer, to control the number of surfaces.
In[26]:=
GraphicsGridA
PartitionATableAContourPlot3DAx^3 + y^2 - z^2, 8x, -2, 2<, 9y, -2, 2=,
8z, -2, 2<, Contours Ø n, PlotLabel Ø "Contours->" <> ToString@nDE,
8n, 1, 4<E, 2E, ImageSize Ø 400E
Out[26]=
See Also
The 2D version ContourPlot is discussed in Recipe 7.6. 
294 | Chapter 7: Three-Dimensional Plots and Graphics

7.6 Combining 2D Contours with 3D Plots
Problem
You want to use a 2D contour plot to annotate the lower plane of a 3D plot.
Solution
Transform the 2D contour plot into a 3D graphic by adding a third z coordinate of
constant value. Use Show to combine the new 3D graphic with a 3D plot.
In[27]:=
ModuleA8f<, fAx_, y_, z_E := 2 x3 + 3 y2 - 5 z; ShowA
ContourPlot3DAfAx, y, zE, 8x, -1, 1<, 9y, -1, 1=, 8z, -1, 1<, Contours Ø 1E,
Graphics3DAContourPlotAfAx, y, -1E, 8x, -1, 1<, 9y, -1, 1=EP1T ê.
9x_Real, y_Real= Ø 9x, y, -1=E, ImageSize Ø 300EE
Out[27]=
Discussion
You can apply the same technique to Plot3D. Here I use a larger PlotRange on the
z-axis to provide room to see the contour. Using Opacity to add some translucence
to the 3D plot also allows the contour plot to be better viewed.
7.6 Combining 2D Contours with 3D Plots | 295

In[28]:=
ModuleA8f<, fAx_, y_E := Sin@2 Pi x^3D + CosA 3 Pi y^2E;
ShowAPlot3DAfAx, yE, 8x, -1, 1<, 9y, -1, 1=,
PlotStyle Ø Opacity@0.7D, PlotRange Ø 8Automatic, Automatic, 8-8, 2<<E,
Graphics3DA
ContourPlotAfAx, yE, 8x, -1, 1<, 9y, -1, 1=, Axes Ø FalseE@@1D
D ê. 9x : _Real, y : _Real= Ø 9x, y, -8=E,
ViewPoint Ø 8-2, -2, 1<, ImageSize Ø 300
E
E
Out[28]=
7.7 Constraining Plots to Specified Regions
Problem
You want to plot a 3D surface that includes only the points defined by a predicate. 
Solution
Use the RegionFunction option with  Plot3D,  SphericalPlot3D,  RevolutionPlot3D,
ParametricPlot3D, and other 3D plots. 
296 | Chapter 7: Three-Dimensional Plots and Graphics

In[29]:=
SphericalPlot3DA1, 8q, 0, Pi<, 8f, -Pi, Pi<,
RegionFunction Ø Function@8q, f<, Sin@f q D < 0.3D,
ViewPoint Ø 82, 2, 0<, ImageSize Ø SmallE
Out[29]=
Discussion
The  parameters  passed  to  a  region  function  vary  by  plot  type;  these  are  listed  in
Table 7-1.
Table 7-1. Region functions by plot type
Plot type
RegionFunction arguments
Plot3D, ListPlot3D, ListSurfacePlot3D
x, y, z
ContourPlot3D, ListContourPlot3D
x, y, z, f
ParametricPlot3D
x, y, z, u, v
SphericalPlot3D
x, y, z, q, f , r
RevolutionPlot3D
x, y, z, t, q, r
7.7 Constraining Plots to Specified Regions | 297

The region function can be used to create quite exotic effects, as demonstrated in 
Figure 7-12.
In[30]:=
GraphicsRowA9SphericalPlot3DA1 + Sin@5 fDê10, 8q, 0, Pi<, 8f, 0, 2 Pi<,
RegionFunction -> HSin@5 HÒ3 + Ò5LD > 0 &L,
Mesh Ø None, BoundaryStyle Ø BlackE,
SphericalPlot3DA1 + Sin@5 fDê10, 8q, 0, Pi<, 8f, 0, 2 Pi<,
RegionFunction -> HSin@5 HÒ3 + Ò6LD > 0 &L,
Mesh Ø None, BoundaryStyle Ø BlackE=, ImageSize Ø 400E
Out[30]=
Figure 7-12. Effects of the RegionFunction option
7.8 Plotting Data in 3D
Problem
You have a matrix of data points that you want to plot as heights, with possible 
interpolation of intermediate values.
Solution
Use  ListPlot3D  with  InterpolationOrderØ0  to  plot  distinct  levels,  Interpolation-
OrderØ1 to join points with straight lines, and InterpolationOrderØ2 or higher to
create smoother surfaces.
In[31]:=
SeedRandom@1000D;
data = RandomReal@8-10, 10<, 820, 20<D;
298 | Chapter 7: Three-Dimensional Plots and Graphics

In[33]:=
GraphicsColumnA
Table@ListPlot3D@data, InterpolationOrder Ø i, Mesh Ø NoneD, 8i, 0, 2<D,
ImageSize Ø 150, Frame Ø AllE
Out[33]=
7.8 Plotting Data in 3D | 299

Discussion
3D list plots are often enhanced by use of a mesh. Here, in an example adapted from
the Wolfram documentation, I show a plot of elevation of the state of Utah by lati-
tude and longitude. The option MeshFunctions Ø {#3 &} uses the elevation data to
specify the mesh giving contours (first image) that help visualize the elvation better
than the default mesh (second image).
In[34]:=
ColumnA9ListPlot3DA
9CityDataAÒ, "Longitude"E, CityData@Ò, "Latitude"D, CityData@Ò,
"Elevation"D= & êü CityData@8All, "Utah", "UnitedStates"<D,
MeshFunctions Ø 8Ò3 &<, ImageSize Ø 300E,
ListPlot3DA9CityDataAÒ, "Longitude"E,
CityData@Ò, "Latitude"D, CityData@Ò, "Elevation"D= & êü
CityData@8All, "Utah", "UnitedStates"<D, ImageSize Ø 300E=E
Out[34]=
See Also
ListPointPlot3D is used to create 3D scatter plots. 
300 | Chapter 7: Three-Dimensional Plots and Graphics

7.9 Plotting 3D Regions Where a Predicate 
Is Satisfied
Problem
You want to visualize regions where a predicate is satisfied.
Solution
RegionPlot takes a predicate of up to three variables. The predicate can use all of the
relational operators (<, <=, >, >=, ==, !=) and logical connectives (&&, ||, Not). 
In[35]:=
RegionPlot3DA x^2 + z^3 - 4 y^2 > 1 »» x^2 + y^2 + z^2 < 0.5,
8x, -2, 2<, 9y, -2, 2=, 8z, -2, 2<, ViewPoint Ø Front, ImageSize Ø 250E
Out[35]=
Discussion
RegionPlot3D uses an adaptive algorithm that is based on the options PlotPoints and
MaxRecursion. The default setting for each is Automatic, meaning Mathematica will
pick what it thinks are appropriate values based on the predicate and ranges. The al-
gorithm first samples using equally spaced points, and then subdivides those points
based on MaxRecursions and the behavior of the predicate. It is possible for the algo-
rithm to miss regions where the predicate is true. One way to gain confidence in the
result is to plot with successively larger values  for  PlotPoints  and  MaxRecursion.
However, of the two, PlotPoints usually has a more significant effect. 
7.9 Plotting 3D Regions Where a Predicate Is Satisfied | 301

In[314]:=
GridAPartitionATableA
RegionPlot3DAx^2 + y^2 + z^2 § 0.75 + Sin@3 xD SinA5 yE Sin@7 zDê2,
8x, -1.25, 1.25<, 9y, -1.25, 1.25=, 8z, -1.25, 1.25<, Mesh Ø None,
MaxRecursion Ø 0, PlotPoints Ø ppE, 8pp, 85, 10, 15, 25<<E, 2EE
Out[314]=
7.10 Displaying 3D Geometrical Shapes
Problem
You  want  to  create  graphics  that  contain  spheres,  cylinders,  polyhedra,  and  other
3D shapes.
302 | Chapter 7: Three-Dimensional Plots and Graphics

Solution
Mathematica has 3D primitives: Cuboid, Sphere, Cylinder Line, Point, and Polygon. 
In[37]:=
ClearAll@coneD
In[38]:=
coneAheight_, base_, 9x_, y_, z_=, 9ax_, ay_, az_=E :=
ModuleA8c1, c2, c3, c4, c5<,
c1 = RevolutionPlot3DA9t, -height t 2=, 8t, 0, base<, Mesh Ø NoneE;
c2 = Rotate@c1@@1DD, ax, 81, 0, 0<D; c3 = RotateAc2, ay, 80, 1, 0<E;
c4 = Rotate@c3, az, 80, 0, 1<D;
c5 = TranslateAc4, 9x, y, z + height * base=E; c5E
torus@D := 8<
snowman3DAbodyRadius_E := ModuleA9bodyCenter = 80, 0, 0<,
H*Proportioning the torso and
head based on golden ratio gives pleasing effect.*L
torsoRadius = bodyRadius ë GoldenRatio,
headRadius = bodyRadius ë HGoldenRatio^2L,
torsoCenter, headCenter, leftShoulder, rightShoulder,
buttonSize = bodyRadiusë 10, buttonSep = bodyRadiusë 3.3,
leftHand, rightHand, mouthCenter, leftEyeCenter, rightEyeCenter=,
torsoCenter =
9bodyCenter@@1DD, bodyCenter@@2DD, torsoRadius + bodyRadius=;
headCenter = 9bodyCenter@@1DD, bodyCenter@@2DD,
bodyRadius + 2 torsoRadius + headRadius=;
H*Position the arms at -60 and 60 degrees.*L
leftShoulder = torsoCenter +
8torsoRadius *Sin@-Piê3D, 0, torsoRadius * Cos@-Piê3D<;
leftHand = torsoCenter + 82.5 torsoRadius *Sin@-Piê3D,
0, 3 torsoRadius * Cos@-Piê3D<;
rightShoulder = torsoCenter + 8torsoRadius *Sin@Piê3D,
0, torsoRadius * Cos@Piê3D<;
rightHand = torsoCenter + 82.5 torsoRadius *Sin@Piê3D,
0, 3 torsoRadius * Cos@Piê3D<;
H*Position eyes at -45 and 45 degrees and half
the radius of the head.*L
leftEyeCenter = headCenter + 80.5 headRadius * Sin@-Piê4D,
-0.8 headRadius, 0.5 headRadius * Cos@-Piê4D<;
rightEyeCenter = headCenter + 80.5 headRadius * Sin@Piê4D,
-0.8 headRadius, 0.5 headRadius * Cos@Piê4D<;
H*Position mouth at 180 degrees - bottom of circle,
also half radius of head.*L
mouthCenter = headCenter + 80.75 headRadius * Sin@PiD,
-25, 0.75 headRadius * Cos@PiD<;
7.10 Displaying 3D Geometrical Shapes | 303

Graphics3DA9
SphereAbodyCenter, bodyRadiusE, H*Base circle*L
Sphere@torsoCenter, torsoRadiusD, H*Middle circle*L
Sphere@headCenter, headRadiusD,
Cylinder@8leftShoulder, leftHand<, 1.5D,
CylinderA9rightShoulder, rightHand=, 1.5E,
SphereAleftEyeCenter, headRadiusê4E,
SphereArightEyeCenter, headRadiusê4E,
coneAheadRadiusê4, headRadiusê4,
headCenter - 8headRadiusê8, 2 headRadius, 0.75 headRadius<,
990 Degree, 180 Degree, -5 Degree=E=, Axes Ø True,
AxesLabel Ø 9"x", "y", "z"=, ImageSize Ø SmallEE;
snowman3D@30D
Out[41]=
Discussion
A  more  mathematically  inspired  demonstration  of  graphics  primitives  is  the  Dan-
delin  construction.  Here  one  drops  two  spheres,  one  small  and  one  large,  into  a
cone such that the spheres do not touch. Consider a plane that slices through the
cone tangent to the surface of both spheres. As you may know, a plane intersecting
a cone traces an ellipse. What is remarkable is that the tangent points with the spheres
are the foci of this ellipse. I adapt the construction from Stan Wagon’s Mathematica
in Action (W.H. Freeman), upgrading it to take advantage of the advanced 3D fea-
tures of Mathematica 6, such as Opacity and PointSize. I refer the reader to Wag-
on’s book for the derivation of the mathematics.
304 | Chapter 7: Three-Dimensional Plots and Graphics

In[42]:=
BlockA
8r1, r2, m, h1, h2, C1, C2, M, MC1, MC2, T1, T2, ht,
cone, slope, plane<,
8r1, r2< = 81.4, 3.4<;
m = TanA70.*DegreeE;
h1 := r1*Sqrt@1 + m^2D;
h2 := r2*Sqrt@1 + m^2D;
C1 := 80, 0, h1<;
C2 := 80, 0, h2<;
M = 80, MC1 + h1<;
MC2 = MC1*Hr2êr1L;
MC1 = Hr1*Hh2 - h1LLêHr1 + r2L;
T1 = C1 + r1*8-Sqrt@1 - r1^2êMC1^2D, 0, r1êMC1<;
T2 = C2 + r2*8Sqrt@1 - r2^2êMC2^2D, 0, -Hr2êMC2L<;
ht = 1.2*Hh2 + r2L; cone@m_, h_D :=
RevolutionPlot3D@8t, m*t<, 8t, 0, hêm<, Mesh -> FalseD@@1DD;
slope = HT2@@3DD - T1@@3DDLêHT2@@1DD - T1@@1DDL;
plane = ParametricPlot3D@8t, u, slope*t + M@@2DD<, 8t, -2*m, 12êm<,
8u, -3, 3<, Boxed -> False, Axes -> FalseD@@1DD;
Graphics3DA99Opacity@0.45D, cone@m, 1.2*Hh2 + r2LD=,
9Opacity@0.5D, Sphere@C1, r1D, Sphere@C2, r2D=,
9Opacity@0.5D, plane=, PointSize@0.0175D, Point@T1D, Point@T2D=,
Boxed -> False, ViewPoint -> 8-1.8, -2.5, 1.5<, ImageSize -> 300EE
Out[42]=
7.10 Displaying 3D Geometrical Shapes | 305

Mathematica can also deal with 3D graphics that are not necessarily of mathemati-
cal origin. You can demonstrate this using ExampleData.
In[43]:=
GraphicsGridA
PartitionAExampleData êü TakeA ExampleDataA"Geometry3D"E, 16E, 4EE
Out[43]=
7.11 Constructing Wireframe Models from Mesh
Problem
You want to build a wireframe model or other structural models from an existing 3D
plot.
Solution
The following solution was developed by Ulises Cervantes-Pimentel and Chris Carl-
son of Wolfram Research. As with Recipe 7.6, the trick is to leverage Mathematica’s
symbolic representation of 3D graphics and to perform transformations on that repre-
sentation to yield the desired result. 
You begin with the shape of interest. Here Chris Carlson was interested in an archi-
tectural model of a bubblelike structure. Note the use of the Mesh option, which is
central to extracting the wireframe.
306 | Chapter 7: Three-Dimensional Plots and Graphics

In[44]:=
bubbleModel = ModuleC
9d = 1.5`, h = 5, l = 0.15`, nx = 10, ny = 10, r = 0.4`, t = 0.15`, zMin = -0.2`=,
ContourPlot3DC
x -
d
2
2
+ y2 + h z2 - 1
x +
d
2
2
+ y2 + h Hz + tL2 - r ,
8x, -2, 2<, 9y, -2, 2=, 8z, zMin, 1<, BoxRatios Ø Automatic,
PlotPoints Ø 20 81, 1, 1<, Axes Ø None, PerformanceGoal Ø "Quality",
Contours Ø 8l<, ImageSize Ø 400, Mesh Ø 9nx, ny, 0=GG
Out[44]=
You can go directly to a wireframe by simply extracting the lines.
In[45]:=
Graphics3DACases@Normal@bubbleModelD, _Line, ¶D,
Boxed Ø False, ImageSize Ø 400E
Out[45]=
7.11 Constructing Wireframe Models from Mesh | 307

Discussion
The solution was quite simple because the transformation was a simple extraction of
graphics data that was already present. However, you can take this approach much
further. Here Normal is used to force the Graphics3D object into a representation of
low-level primitives, and Cases is used to extract the lines. However, this time the
lines are transformed to polygons to create a box model.
In[46]:=
Graphics3DACasesANormal@bubbleModelD, Line@pts_, ___D ß Polygon@ptsD, ¶E,
Boxed Ø False, ImageSize Ø 400E
Out[46]=
If your end goal was an architectural structure, the box model is no good. You need
to open up the space. Here is an even more sophisticated transformation that turns
the walls of the model into curved support beams.
In[47]:=
InsetPoints@pts_D := PolygonAJoinApts, ReverseA
ModuleA9centroid = HPlus üü ptsLë Length@ptsD=,
HÒ + .1 Hcentroid - ÒLL & êü ptsE
EEE
Graphics3DACases@Normal@bubbleModelD,
Line@pts_, ___D ß InsetPoints@ptsD, ¶D, Boxed Ø False, ImageSize Ø 500E
Out[48]=
308 | Chapter 7: Three-Dimensional Plots and Graphics

As a final step, you may want to show how the structure would look if it were cov-
ered  with  a  translucent  covering.  Here  Mathematica’s  sophisticated  Lighting  and
Specularity options are used. 
In[49]:=
Graphics3DA9
Gray,
Cases@Normal@bubbleModelD, Line@pts_, ___D ß InsetPoints@ptsD, ¶D,
EdgeForm@NoneD, Opacity@.5D,
Specularity@White, 1000D, Hue@.66, .75, .5D, Lighting Ø "Neutral",
CasesANormal@bubbleModelD, _Polygon, ¶E
=, Boxed Ø False, ImageSize Ø 500, Lighting Ø "Neutral"E
Out[49]=
See Also
Recipe 7.13 covers Lighting and Specularity.
Chris  Carlson  gave  a  superb  presentation  at  the  2009  International  Mathematica
User Conference (IMUC). This post on the Wolfram Blog covers a good portion of
the talk: http://bit.ly/291CDE.
7.12 Controlling Viewing Geometry 
Problem
You want to control the placement of a simulated camera that determines viewing
perspective of a 3D graphic.
7.12 Controlling Viewing Geometry | 309

Solution
Use the ViewPoint option to control the point in space from which a 3D object is to
be viewed. Here I enumerate some of the possibilities.
In[50]:=
GraphicsGridA
PartitionATableAAppendAExampleDataA9"Geometry3D", "Beethoven"=E,
9ViewPoint Ø vp, PlotLabel Ø ToString@vpD=E, 9vp, 9Front, Back,
Above, Below, Top, Left, Right, 80, -2, 2<, 82, -2, 0<==E, 3EE
Out[50]=
310 | Chapter 7: Three-Dimensional Plots and Graphics

Use the ViewCenter option to control the point that should appear as the center of
the displayed image. The coordinates are scaled to the range [0,1].
In[51]:=
GridAPartitionA
TableAGraphics3DACylinder@D, ViewCenter Ø vc, SphericalRegion Ø True,
PlotLabel Ø ToString@N@vc, 2DD, ImageSize Ø TinyE, 8vc,
880, 0, 0<, 81ê2, 1ê2, 1ê2<, 81, 0, 1<, 81, 1, 0<, 80, 1, 1<, 81, 1, 1<,
81ê3, 1ê2, 1ê3<, 80, 1ê3, 1ê3<, 81ê3, 1ê3, 0<<<E, 3E, Frame Ø AllE
Out[51]=
7.12 Controlling Viewing Geometry | 311

Use the ViewVertical option to control which coordinates should be vertical.
In[52]:=
GraphicsRowATableAGraphics3DACylinder@D, ViewVertical Ø vvE,
8vv, 881, 0, 0<, 80, 1, 0<, 80, 0, 1<, 8-0.5, -1, 1<<<EE
Out[52]=
Discussion
For many users, combinations of ViewPoint, ViewCenter, and ViewVertical will cre-
ate  the  initial  spatial  orientation  of  the  3D  graphic  that  most  suits  your  tastes  or
visual emphasis. However, there are additional options that are useful in some cir-
cumstances. ViewVector allows you to control the position and orientation of a simu-
lated  camera.  ViewVector  takes  either  a  single  vector  that  specifies  the  position
of  the  camera  that  is  pointed  at  ViewCenter  or  a  pair  of  vectors  that  specify  both
the  position  of  the  camera  and  the  center.  ViewVector  overrides  ViewPoint  and
ViewCenter.  To  understand  the  concept  of  the  camera,  picture  yourself  looking
through the camera as it moves around the stationary graphic.
In[53]:=
GraphicsRowA
TableAGraphics3DACylinder@D, SphericalRegion Ø True, ViewVector Ø vvE,
8vv, 885, 5, -5<, 80, 5, 5<, 85, -5, 0<, 82.5, 2, 2.5<<<EE
Out[53]=
Continuing with the camera metaphor, the option ViewAngle is analogous to zoom-
ing. The default view angle is 35 degrees. You can specify a specific angle or the sym-
bol All, which will pick an angle that is sufficient to see everything.
312 | Chapter 7: Three-Dimensional Plots and Graphics

7.13 Controlling Lighting and Surface Properties
Problem
You want to modulate lighting and surface characteristics to highlight important fea-
tures or create artistic effects.
Solution
Mathematica provides quite sophisticated control of light via the options Lighting,
Specularity, and Glow. The simplest settings for Lighting are Automatic, "Neutral",
and None (Figure 7-13).
In[54]:=
GraphicsRowATableAGraphics3DASphere@D, Lighting Ø lE,
8l, 8Automatic, "Neutral", None<<EE
Out[54]=
Figure 7-13. Examples of Lighting
For  more  sophisticated  control,  you  can  specify  combinations  of  ambient,  direc-
tional, spot, and point light sources (Figure 7-14). Try the code on your own for the
full effect.
In[55]:=
GraphicsRowATableAGraphics3DASphere@D, Lighting Ø lE,
8l, 888"Point", Red, 80, 0, 2<<<, 88"Ambient", Green<<,
88"Directional", Blue, 880, 0, 1<, 8-1, 1, 1<<<<<<EE
Out[55]=
Figure 7-14. Examples of Glow
7.13 Controlling Lighting and Surface Properties | 313

Glow is the opposite of Lighting. It specifies the color of the surface itself. Glow is also
different from an object’s color, as you can see in Figure 7-15. (However, Glow is not
easily demonstrated in monochrome print. Please try the code on your own to see
the effect.) Both the cylinder and the sphere have a green color, but the sphere also
has a green glow. There is no lighting, so only the cylinder appears bright because of
Glow. Another way Glow differs from Lighting is that it does not affect surround-
ing  objects,  only  the  objects  with  Glow.  In  other  words,  a  glowing  object  is  not  a
light source in the Graphics3D domain.
In[56]:=
Graphics3DA99Glow@GreenD, Green, Cylinder@D=,
8Green, Sphere@82, 1.5, 0<D<=, Lighting Ø None, ImageSize Ø 300E
Out[56]=
Figure 7-15. Difference between Glow and color
314 | Chapter 7: Three-Dimensional Plots and Graphics

Discussion
As you probably would expect from your experience with colored lights, Mathemat-
ica lighting follows the additive color model (refer to the online version of the follow-
ing image to appreciate its full glory: http://bit.ly/xIgx7).
In[58]:=
ModuleA9lights, plane=, lights = 88"Spot", Red, 883, 3, 5<, 83, 3, 0<<, Piê8<,
8"Spot", Green, 887, 3, 5<, 87, 3, 0<<, Piê8<,
8"Spot", Blue, 885, 6, 5<, 85, 6, 0<<, Piê8<<;
plane = ParametricPlot3D@8u, v, -2<, 8u, 0, 10<, 8v, 0, 9<,
PlotPoints Ø 100, MaxRecursion Ø 0, Mesh Ø None, Axes Ø FalseD;
ShowAplane, Lighting Ø lightsEE
Out[58]=
Lighting can be used as an option that applies to an entire graphic, but it also works
as  a  graphics  directive  that  applies  to  the  objects  that  follow  it  within  the  same
scope. 
7.13 Controlling Lighting and Surface Properties | 315

In[59]:=
Graphics3DA9
9Lighting Ø 88"Directional", Blue, 880, 0, 1<, 8-1, 1, 1<<<,
8"Point", Red, 81, 1, 1<<<,
9Specularity@0.5D, Sphere@80, 0, 1<, 0.25D=,
Sphere@81, 0, 0<, 0.25D=,
Sphere@81, 1, 1<, 0.25D
=, Lighting Ø 88"Ambient", Green<<, ImageSize Ø SmallE
Out[59]=
Specularity and Glow are strictly used as directives, although Specularity can be
combined with Lighting.
See Also
The  use  cases  covered  in  this  recipe  should  satisfy  most  common  uses  of  colored
lighting, but if you are trying to achieve very specific lighting effects, you should con-
sult  the  Mathematica  documentation  to  explore  the  full  range  of  forms  Lighting,
Specularity, and Glow can take and how they interact with color. 
316 | Chapter 7: Three-Dimensional Plots and Graphics

7.14 Transforming 3D Graphics
Problem
You want to scale, translate, or rotate graphics in 3D space.
Solution
Use Scale to stretch or shrink graphics.
In[60]:=
GraphicsGridA
PartitionATableAGraphics3DA8Scale@Sphere@D, 8s, s, s<, 80, 0, 0<D<,
PlotRange Ø 88-2, 2<, 8-2, 2<, 8-2, 2<<,
PlotLabel Ø "Scale = " <> ToString@N@sDDE,
8s, 81ê3, 1ê2, 1, 2<<E, 2E, ImageSize Ø 300E
Out[60]=
7.14 Transforming 3D Graphics | 317

Use Translate to move graphics in 3D space. Figure 7-16 presents four translations
of a sphere that is originally constructed at the origin.
In[61]:=
GraphicsGridAPartitionA
TableAGraphics3DA8Translate@Sphere@80, 0, 0<, 0.75D, vD<, PlotRange Ø
88-2, 2<, 8-2, 2<, 8-2, 2<<, PlotLabel Ø "Vec = " <> ToString@N@vDDE,
8v, 88-1, -1, -1<, 80, 0, 0<, 81, 1, 1<, 81ê2, 0, -1ê2<<<E,
2E, ImageSize Ø 300E
Out[61]=
Figure 7-16. Examples of Translate
Use Rotate to change the orientation of graphics. Figure 7-17 rotates a cube through
Pi/4 radians (45 degrees) but uses different vectors to define the rotation axis.
318 | Chapter 7: Three-Dimensional Plots and Graphics

In[62]:=
GraphicsGridA
PartitionATableAGraphics3DA8Rotate@Cuboid@D, Piê4, vD<, PlotRange Ø
88-2, 2<, 8-2, 2<, 8-2, 2<<, PlotLabel Ø "Vec =" <> ToString@N@vDDE,
8v, 88-1, 0, 1<, 80, 1, -1<, 81, 1, 0<, 81, 1, 1<<<E, 2E, ImageSize Ø 300E
Out[62]=
Vec =8-1., 0., 1.<
Vec =80., 1., -1.<
Vec =81., 1., 0.<
Vec =81., 1., 1.<
Figure 7-17. Examples of Rotate
Discussion
In  addition  to  the  primitive  transformations  shown  in  the  solution,  Mathematica
provides  support  for  transformation  matrices  and  symbolic  transformation  functions.
Matrices  include  RotationMatrix,  ScalingMatrix,  ShearingMatrix,  and  Reflection-
Matrix. The transformation functions are RotationTransform, TranslationTransform,
ScalingTransform,  ShearingTransform,  ReflectionTransform,  RescalingTransform,
AffineTransform, and LinearFractionalTransform. A smattering of examples is given here.
7.14 Transforming 3D Graphics | 319

Transformations  work  in  conjunction  with  the  function  GeometricTransformation,
which takes a graphic and either a transformation or a matrix.
ShearingTransform[q,v,n] is an area or volume preserving transformation that adds
a slant, also known as a shear, to a graphic. Shear is specified in terms of an angle q
along a vector v and normal to a second vector n. Figure 7-18 shows a polyhedron in
its  original  state  followed  by  a  shear  transform.  A  translucent  cube  is  also  trans-
formed to give a sense of the angles.
In[63]:=
ModuleA9poly=, poly = PolyhedronDataA"DisdyakisDodecahedron"E@@1DD;
GraphicsRowA9
Graphics3DA9Green, poly=, Boxed Ø False, ViewPoint Ø FrontE,
Graphics3DA9Green,
GeometricTransformationApoly,
ShearingTransform@Piê6, 81, 0, 0<, 80, 0, 1<DE, Opacity@0.1D,
GeometricTransformationACuboid@8-1.5, -1.5, -1.5<, 81.5, 1.5, 1.5<D,
ShearingTransform@Piê6, 81, 0, 0<, 80, 0, 1<DE=,
Boxed Ø False, ViewPoint Ø FrontE=
EE
Out[63]=
Figure 7-18. Example of ShearingTransform
7.15 Exploring Polyhedra
Problem
You want to investigate the characteristics of various polyhedra.
320 | Chapter 7: Three-Dimensional Plots and Graphics

Solution
Mathematica 6 includes PolyhedronData, which is effectively an embedded database
of  polyhedra  attributes.  Apropos  to  this  chapter,  PolyhedronData  contains  the  3D
graphics  data  for  a  variety  of  common  and  exotic  polyhedra.  If  you  call
PolyhedronData[] with no arguments, it returns a list of all polyhedra it has informa-
tion about. 
In[64]:=
PartitionA
PolyhedronData@"Properties"D,
4, 4, 81, 1<, 8<E êê TableForm
Out[64]//TableForm=
AdjacentFaceIndices
AlternateNames
AlternateStandardNames
Amphichiral
Antiprism
Archimedean
ArchimedeanDual
Centroid
Chiral
Circumcenter
Circumradius
Circumsphere
Classes
Compound
Concave
Convex
Cuboid
DefaultOrientation
Deltahedron
DihedralAngleRules
DihedralAngles
Dipyramid
DualCompound
DualName
DualScale
EdgeCount
EdgeIndices
EdgeLengths
Edges
Equilateral
FaceCount
FaceCountRules
FaceIndices
Faces
GeneralizedDiameter
Hypercube
Image
Incenter
InertiaTensor
Information
Inradius
Insphere
Johnson
KeplerPoinsot
Midcenter
Midradius
Midsphere
Name
NetCoordinates
NetCount
NetEdgeIndices
NetEdges
NetFaceIndices
NetFaces
NetImage
NotationRules
Orientations
Orthotope
Platonic
PolyhedronIndices
Prism
Pyramid
Quasiregular
RectangularParallelepiped
RegionFunction
Rhombohedron
Rigid
SchlaefliSymbol
SelfDual
Shaky
Simplex
SkeletonCoordinates
SkeletonGraphName
SkeletonImage
SkeletonRules
SpaceFilling
StandardName
StandardNames
Stellation
StellationCount
SurfaceArea
SymmetryGroupString
Uniform
UniformDual
VertexCoordinates
VertexCount
VertexIndices
Volume
WythoffSymbol
Zonohedron
If you call PolyhedronData[poly], where poly is the name of the polyhedron, it will re-
turn the graphic. The code given here creates a labeled grid of a random selection of
24 polyhedra known to Mathematica 7. Here StringSplit uses a regular expression
to parse the names on CamelCase boundaries and inserts a new line so the names fit
inside the grid cells.
7.15 Exploring Polyhedra | 321

In[65]:=
BlockRandomA
SeedRandom@4D; BlockA9p = AppendAPolyhedronData@ÒD,
9PlotLabel Ø TextAStyleAStringJoinAStringSplitAToString@ÒD,
RegularExpression@"H@a-zDLH@A-ZDL"D Ø "$1\n$2"EE,
FontSize Ø 10, TextAlignment Ø CenterEE, Boxed Ø False,
ImageSize Ø Large=E & êü RandomChoiceA PolyhedronData@D, 20E=,
GridAPartitionAShowAÒ, ImageSize Ø 95E & êü p, 5E, Spacings Ø 80, 0<E
E
E
Out[65]=
Gyroelongated
Pentagonal
Bicupola
Truncated
Cube
Gyroelongated
Square
Pyramid
Gyroelongated
Triangular
Cupola
Dodecahedron
Small
Triambic
Icosahedron
Compound
Gyroelongated
Pentagonal
Cupola
Gyroelongated
Triangular
Bicupola
Augmented
Truncated
Dodecahedron
Gyroelongated
Triangular
Cupola
Elongated
Pentagonal
Gyrobirotunda
Parabidiminished
Rhombicosidodecahedron
Tetrahedron
Rhombic
Icosahedron
Elongated
Triangular
Cupola
Triaugmented
Hexagonal
Prism
Augmented
Truncated
Dodecahedron
Elongated
Triangular
Gyrobicupola
Biaugmented
Triangular
Prism
Triakis
Icosahedron
Tetrahedron
Three
Compound
322 | Chapter 7: Three-Dimensional Plots and Graphics

Discussion
PolyhedraData contains a treasure trove of polyhedra information. In the solution we
demonstrate how to extract graphics by name. Here we show the input form of a
cube.
In[66]:=
PolyhedronData@"Cube"D êê InputForm
Out[66]//InputForm=
Graphics3D[GraphicsComplex[{{-1/2, -1/2, -1/2}, {-1/2, -1/2, 1/2}, {-1/2, 
1/2, -1/2}, {-1/2, 1/2, 1/2}, {1/2, -1/2, -1/2}, 
  {1/2, -1/2, 1/2}, {1/2, 1/2, -1/2}, {1/2, 1/2, 1/2}}, Polygon[{{8, 4, 2, 
6}, {8, 6, 5, 7}, {8, 7, 3, 4}, {4, 3, 1, 2}, 
   {1, 3, 7, 5}, {2, 1, 5, 6}}]]]
The solution also exploits the ability to list all the polyhedra by providing no argu-
ments. The solution used the first 20, but there are many more, as you can see.
In[67]:=
LengthAPolyhedronData@DE
Out[67]=
187
You can explore all of them with this little dynamic widget.
In[68]:=
DynamicModuleA9poly = "DodecahedronSixCompound"=,
RowA9PopupMenuADynamicApolyE, PolyhedronData@DE,
DynamicAPolyhedronDataApolyEE=, " "EE
Out[68]=
DodecahedronSixCompound
7.15 Exploring Polyhedra | 323

The polyhedra are grouped into classes. You can get a list of these classes or a list of
the members of a particular class.
In[69]:=
PolyhedronData@"Classes"D
Out[69]=
9Amphichiral, Antiprism, Archimedean, ArchimedeanDual, Chiral, Compound,
Concave, Convex, Cuboid, Deltahedron, Dipyramid, Equilateral, Hypercube,
Johnson, KeplerPoinsot, Orthotope, Platonic, Prism, Pyramid, Quasiregular,
RectangularParallelepiped, Rhombohedron, Rigid, SelfDual, Shaky,
Simplex, SpaceFilling, Stellation, Uniform, UniformDual, Zonohedron=
In[70]:=
PolyhedronData@"Chiral"D
Out[70]=
9GyroelongatedPentagonalBicupola, GyroelongatedPentagonalBirotunda,
GyroelongatedPentagonalCupolarotunda, GyroelongatedSquareBicupola,
GyroelongatedTriangularBicupola, PentagonalHexecontahedron,
PentagonalIcositetrahedron, SnubCube, SnubDodecahedron=
Polyhedra also have various properties, which you can list or use with a polyhedron
to retrieve the value.
In[71]:=
PolyhedronData@"Properties"D
Out[71]=
9AdjacentFaceIndices, AlternateNames, AlternateStandardNames, Amphichiral,
Antiprism, Archimedean, ArchimedeanDual, Centroid, Chiral, Circumcenter,
Circumradius, Circumsphere, Classes, Compound, Concave, Convex, Cuboid,
DefaultOrientation, Deltahedron, DihedralAngleRules, DihedralAngles,
Dipyramid, DualCompound, DualName, DualScale, EdgeCount, EdgeIndices,
EdgeLengths, Edges, Equilateral, FaceCount, FaceCountRules, FaceIndices,
Faces, GeneralizedDiameter, Hypercube, Image, Incenter, InertiaTensor,
Information, Inradius, Insphere, Johnson, KeplerPoinsot, Midcenter,
Midradius, Midsphere, Name, NetCoordinates, NetCount, NetEdgeIndices,
NetEdges, NetFaceIndices, NetFaces, NetImage, NotationRules,
Orientations, Orthotope, Platonic, PolyhedronIndices, Prism, Pyramid,
Quasiregular, RectangularParallelepiped, RegionFunction, Rhombohedron,
Rigid, SchlaefliSymbol, SelfDual, Shaky, Simplex, SkeletonCoordinates,
SkeletonGraphName, SkeletonImage, SkeletonRules, SpaceFilling,
StandardName, StandardNames, Stellation, StellationCount, SurfaceArea,
SymmetryGroupString, Uniform, UniformDual, VertexCoordinates,
VertexCount, VertexIndices, Volume, WythoffSymbol, Zonohedron=
In[72]:=
PolyhedronDataA"GyroelongatedPentagonalBicupola", "VertexCount"E
Out[72]=
30
324 | Chapter 7: Three-Dimensional Plots and Graphics

In[73]:=
PolyhedronData@"Cube", "Faces"D
Out[73]=
GraphicsComplexC;;-
1
2
, -
1
2
, -
1
2
?, ;-
1
2
, -
1
2
,
1
2
?, ;-
1
2
,
1
2
, -
1
2
?,
;-
1
2
,
1
2
,
1
2
?, ;
1
2
, -
1
2
, -
1
2
?, ;
1
2
, -
1
2
,
1
2
?, ;
1
2
,
1
2
, -
1
2
?, ;
1
2
,
1
2
,
1
2
??,
Polygon@888, 4, 2, 6<, 88, 6, 5, 7<, 88, 7, 3, 4<,
84, 3, 1, 2<, 81, 3, 7, 5<, 82, 1, 5, 6<<DG
Skeletal images show the polygons in terms of connected graphs.
In[74]:=
GraphicsRowA9PolyhedronDataA"Cube", "SkeletonImage"E, PolyhedronDataA
"GyroelongatedPentagonalBicupola", "SkeletonImage"E=, ImageSize Ø MediumE
Out[74]=
NetImage is my favorite aspect of PolyhedronData because it shows how to make a
cutout that can be folded into an actual 3D model of the named polyhedron. My
kids like this one, too, although I have to do all the tedious parts!
In[75]:=
GraphicsRowA9PolyhedronDataA"GyroelongatedPentagonalBicupola", "NetImage"E,
ImportAFileNameJoinA9NotebookDirectory@D, "..", "images",
"GyroelongatedPentagonalBicupolaConstr.PNG"=EE=E
Out[75]=
7.15 Exploring Polyhedra | 325

See Also
GraphData,  KnotData,  and  LatticeData  are  equally  cool  graphical  data  sources  that
you can explore on your own. Refer to the Mathematica documentation.
7.16 Importing 3D Graphics from CAD 
and Other 3D Software
Problem
You have 3D data from another application that you would like to view or manipu-
late within Mathematica.
Solution
Mathematica 6 can import several popular 3D graphics formats, including Drawing
Exchange Format (DXF) produced by AutoCAD and other CAD packages.
In[76]:=
dxf = ImportA"ExampleDataêhelicopter.dxf.gz", ImageSize Ø SmallE
Out[76]=
Discussion
Mathematica’s  symbolic  representation  makes  it  possible  to  manipulate  imported
graphics via pattern matching.
You can change colors and directives. 
326 | Chapter 7: Three-Dimensional Plots and Graphics

In[77]:=
GraphicsRowA9dxf ê. RGBColor@1., 0., 0.D Ø RGBColor@0, 1., 1.D,
dxf ê. 9 RGBColor@__D, Polygon@x_D= :> 9EdgeForm@DashedD, Polygon@x D==,
ImageSize Ø 400E
Out[77]=
You  can  extract  elements  based  on  properties.  Here  we  delete  all  nonyellow  
polygons (i.e., all but the rotor). 
In[78]:=
DeleteCasesAdxf, ExceptA9RGBColor@1., 1., 0.D, Polygon@__D=E, 85<E
Out[78]=
You  can  emphasize  the  component  polygons  by  shrinking  each  toward  its  center
and changing all colors to dark gray.
In[79]:=
shrinkAt_, Polygon@x_List, opts___DE := ModuleA
9c = Plus üü xë Length@xD=, Polygon@Map@Hc + H1 - tL HÒ - cLL &, xD, optsDE
In[80]:=
dxf ê. 9x_Polygon ß shrink@0.4, xD,
RGBColor@_, _, _D ß GrayLevel@0.3D, Small ß 600=
Out[80]=
7.16 Importing 3D Graphics from CAD and Other 3D Software | 327


CHAPTER 8
Image Processing
I have a picture
Pinned to my wall
An image of you and of me and we’re laughing
We’re loving it all
...
You say I’m a dreamer
We’re two of a kind
Both of us searching for some perfect world
We know we’ll never find
Thompson Twins, “Hold Me Now”
8.0 Introduction
Image processing is a field with many challenges. The first challenge is the magni-
tude of the data. Consider that a simple 256 × 256 pixel grayscale image will contain
65,536  bytes  of  data  for  the  pixel  values  alone.  Larger  color  images  can  contain
many times this amount. The second challenge is the raster form of the image data,
which is optimized for display, not for detecting distinct visual elements. A third chal-
lenge is the noise and other artifacts of the image-capture process. A final challenge
is the lack of contextual information; most images do not encode where they were
taken, the lighting conditions, the device used, and so on (although this is beginning
to change). In my opinion, these challenges make working on image processing very
rewarding, especially when one considers that significant portions of our brains are
dedicated to visual perception. Finding algorithms that achieve the kinds of visual-
processing tasks that the brain performs is one way to begin to peel away the veil ob-
scuring the workings of our most mysterious organ.
The field of image processing is very broad; this chapter only samples a small frac-
tion of the relevant problems. The choice of topics is largely a function of the au-
thor’s interests and experience. The full scope of image-processing research includes
efficient encoding of images and video, image enhancement and restoration, image
329

segmentation, recovering spatial shape from shading and pattern distortions, learn-
ing about 3D from multiple 2D images, as well as image recognition. Researchers in
this field rely on a wide variety of mathematical techniques; hence, Mathematica is
an ideal platform to get one’s feet wet. 
Image Representation
Mathematica  uses  the  function  Import  to  load  images  into  a  format  suitable  for
processing  and  display  within  the  frontend.  When  you  use  Import  on  an  image
file in versions of Mathematica prior to 7, you get a Graphics object that typically
contains a single Mathematica graphics primitive called Raster. A Raster represents
a 2D array of grayscale or color cells. A gray cell value will be a single number; a
color  cell  value  will  be  three  or  four  numbers.  An  option  called  ColorFunction
tells Mathematica how to map the cell values to display colors. Typical encodings
are  RGBColor,  GrayLevel,  and  Hue.  Most  of  the  recipes  in  this  chapter  deal  with
grayscale images; however, the first recipe shows you how to transform red-green-
blue  (RGB)  images  to  other  encodings  that  are  appropriate  for  the  kinds  of  algo-
rithms in these recipes. 
As  of  version  7,  Mathematica  images  have  their  own  representation,  called  Image,
which  is  distinct  from  Graphics  (although  you  can  request  the  older  format
for  backward  compatibility  using  “Graphic”  with  Import).  To  make  these  recipes
compatible  to  both  versions  6  and  7,  I  use  the  following  functions  throughout
this chapter. However, in some recipes these are not sufficient because the code as-
sumed  Graphics  form  when  recreating  the  image  for  display,  and  hence,  expected
Graphics options to be present in the imported version. 
In[18]:=
ClearAgetImgData, getImgRange, getImgDim, rasterReplaceE
getImgDataAimg_GraphicsE := img@@1, 1DD
getImgDataAimg_ImageE := ReverseAImageDataAimg, "Byte"EE
getImgRangeAimg_GraphicsE := img@@1, 3DD
getImgRangeAimg_ImageE := ModuleA8<,
SwitchAImageTypeAimgE, "Bit", 80, 1<, "Byte",
80, 255<, "Bit16", 80, 65535<, "Real", 80.0, 1.0<EE
getImgDimAimg_GraphicsE := img@@1, 2, 2DD - img@@1, 2, 1DD
getImgDimAimg_ImageE := ImageDimensionsAimgE
330 | Chapter 8: Image Processing

getImgCoordAimg_GraphicsE := img@@1, 2DD
getImgCoordAimg_ImageE := 980, 0<, getImgDimAimgE=
rasterReplaceAimg_Graphics, raster_List, opts___E :=
GraphicsARasterAraster, img@@1, 2DD, opts, Sequence üü OptionsAimg@@1DDEE,
Sequence üü OptionsAimgEE
rasterReplaceAimg_Image, raster_List, opts___E :=
ImageAraster, img@@2DD, opts, Sequence üü OptionsAimgEE
Image Processing in Mathematica 7
Most of this chapter was originally written prior to the release of Mathematica 7,
which introduced many native functions for image processing. After the release of
version 7, I added content and augmented some of the recipes. However, I still left
most of the custom algorithms intact, rather than just rewrite everything in terms of
the built-in constructs. As I stated previously, I believe image-processing algorithms
are interesting in their own right. The Mathematica 7 functions are very easy to use;
if you want to sharpen an image, for example, use Sharpen and you are done. How-
ever,  if  you  want  to  understand  the  mathematics,  see  Recipe  8.5  or  8.6.  In  some
recipes,  I  simply  refer  you  to  the  appropriate  Mathematica  function  in  the  “See
Also” section. There are some common image transformations that are not covered
in this chapter, but most are easily implemented and are native to Mathematica 7. If
you  need  to  crop,  pad,  rotate,  and  so  on,  you  will  want  to  upgrade  to  version  7,
which has ImageCrop, ImagePad, ImageResize, ImageTake, and ImageRotate.
See Also
The  recipes  in  this  chapter  draw  heavily  on  Rafael  C.  Gonzalez  and  Richard  E.
Woods’s Digital Image Processing, Second Edition (Addison-Wesley). This is one of
the  classic  texts  in  the  field,  and  any  individual  who  has  a  serious  interest  in
image  processing  should  own  this  text.  Although  I  relied  on  the  second  edition,
I would recommend buying the latest (third) edition, published by Prentice Hall in 2008. 
If you have never worked with images in Mathematica, consult the documentation
and experiment with the functions Import, Graphics, and Raster before diving into
these recipes. 
8.0 Introduction | 331

8.1 Extracting Image Information
Problem
You want to extract information from one or more image files for manipulation by
Mathematica or for combining into a new image.
Solution
Use the two-argument version of the Import function to selectively import data from
an image file. Using Import with a PNG, GIF, TIFF, BMP, or other supported image
format will import the image and display it in the Mathematica frontend. However,
sometimes you might want to extract a subset of the image data for manipulation
rather than display. What information can you extract? This is answered using a sec-
ond argument of "Elements".
In[200]:=
ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "Elements"E
Out[200]=
9Aperture, BitDepth, CameraTopOrientation, ColorMap, ColorSpace, Data,
DataType, Date, Exposure, FocalLength, Graphics, GrayLevels, Image,
ImageSize, ISOSpeed, Manufacturer, Model, RawData, RGBColorArray=
Note  that  not  every  image  will  provide  the  same  level  of  information.  The  image
format and the device that produced the image determine which elements are available.
In[201]:=
ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "mechanism1.png"=E, "Elements"E
Out[201]=
9BitDepth, ColorSpace, Data, DataType,
Graphics, GrayLevels, Image, ImageSize, RGBColorArray=
Once you know which elements are available, you can extract them by name.
In[202]:=
ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "BitDepth"E
Out[202]=
8
Note that an image element might be supported but not available, in which case 
Import will return None.
In[203]:=
ImportA
FileNameJoinA9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "Model"E
Out[203]=
None
332 | Chapter 8: Image Processing

However, if you ask for the value of an element that is not supported, Import will
fail. 
In[204]:=
ImportAFileNameJoinA9NotebookDirectory@D, "..", "images", "truck.jpg"=E,
"Copyright"E
Import::noelem :
The Import element "Copyright" is not present when
importing as JPEG. à
Out[204]=
$Failed
Discussion
From an image processing point of view, the elements you will most likely extract
are  "Graphics",  "GrayLevels",  "Data",  and  "RGBColorArray".  The  "Graphics"
element is the default element for an image file. It extracts the image in a format suit-
able for immediate display in the frontend.
In[205]:=
ImportAFileNameJoinA9NotebookDirectory@D, "..", "images", "truck.jpg"=E,
"Graphics"E
Out[205]=
Note, if you want to extract the "Graphics" format without displaying it, terminate
the expression with a semicolon.
In[206]:=
image = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "Graphics"E;
8.1 Extracting Image Information | 333

The "GrayLevels" element will convert color image data to gray level data. That is, it
will return a 2D array of pixel gray values in the range 0 (black) to 1 (white). Here I
use Short to only show a few of the gray level values.
In[207]:=
ShortAImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "GrayLevels"E, 6E
Out[207]//Short=
880.283235, 0.330294, 0.270298, 0.242804, 0.227118, 0.190608,
0.190608, 0.161494, 0.181102, 0.156357, 0.21518, 0.322149, 0.388816,
0.446467, 0.524855, 0.576922, 0.620016, 0.646208, á125à,
0.980071, 0.988663, 0.980373, 0.981588, 0.98551, 0.984592, 0.984592,
0.984122, 0.972357, 0.985016, 0.985016, 0.984973, 0.984078,
0.984078, 0.984592, 0.984592, 0.983698<, á118à, 8á1à<<
The "Data" element will extract the image pixel data as it is stored in the image file.
The format of the data will vary depending on the image type, but typically it will be
a matrix of RGB triplets for a color image and gray values for a grayscale image both
in the range [0,255].
In[208]:=
ShortAImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "Data"E, 6E
Out[208]//Short=
88886, 67, 63<, 898, 79, 75<, 882, 64, 60<, 873, 58, 53<, 869, 54, 49<,
857, 46, 40<, 857, 46, 40<, 847, 40, 32<, 852, 45, 37<, 843, 40, 31<,
858, 55, 46<, 882, 84, 73<, 899, 101, 90<, 8113, 116, 105<, 8131, 137, 125<,
8141, 152, 138<, 8150, 164, 149<, 8152, 173, 156<, 8150, 175, 156<,
8141, 168, 149<, 8136, 160, 144<, 8142, 165, 149<, 8149, 169, 157<,
8155, 173, 161<, 8146, 163, 153<, 8145, 165, 154<, 8146, 167, 158<,
á107à, 8246, 245, 241<, 8250, 249, 245<, 8255, 255, 251<,
8255, 255, 251<, 8249, 251, 248<, 8248, 250, 247<, 8247, 251, 252<,
8249, 253, 254<, 8248, 252, 255<, 8247, 251, 252<, 8248, 255, 248<,
8246, 253, 245<, 8249, 252, 245<, 8250, 253, 246<, 8252, 251, 249<,
8252, 251, 249<, 8254, 249, 253<, 8251, 246, 250<, 8254, 249, 255<,
8254, 249, 255<, 8252, 250, 255<, 8252, 250, 253<, 8252, 250, 253<,
8252, 251, 249<, 8252, 251, 249<, 8252, 251, 247<<, á118à, 8á1à<<
334 | Chapter 8: Image Processing

In[209]:=
ShortAImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "RGBColorArray"E, 6E
Out[209]//Short=
88RGBColor@0.337255, 0.262745, 0.247059D,
RGBColor@0.384314, 0.309804, 0.294118D,
RGBColor@0.321569, 0.25098, 0.235294D,
RGBColor@0.286275, 0.227451, 0.207843D,
RGBColor@0.270588, 0.211765, 0.192157D,
á150à, RGBColor@0.988235, 0.980392, 0.992157D,
RGBColor@0.988235, 0.980392, 0.992157D,
RGBColor@0.988235, 0.984314, 0.976471D,
RGBColor@0.988235, 0.984314, 0.976471D,
RGBColor@0.988235, 0.984314, 0.968627D<, á119à<
See Also
More  details  can  be  found  in  the  Mathematica  documentation  for  Import  and  the
formats JPEG, TIFF, BMP, PNG, and GIF.
8.2 Converting Images from RGB Color Space 
to HSV Color Space
Problem
You have an image that is represented in RGB but most image-processing algorithms
demand the hue-saturation-value (HSV) color space model. 
Solution
The solution starts with defining some primitives to compute Hue, Saturation, and
Value from Red, Green, and Blue intensities.
The  HSV  color  model  is  often  depicted  geometrically  as  a  cone  (see  http://en.
wikipedia.org/wiki/Image:HSV_cone.png). The hue can be thought of as the angle of
a vector rotating around the center, with angles close to 0 degrees corresponding to
red and increasing angles moving through the rainbow out to violet and returning
again to red. To simplify the math, we first scale the standard RGB values that range
from 0 to 255 to values that range between 0 and 1. Mathematically speaking, you
compute hue by finding which two of the three scaled RGB color intensities domi-
nate and then using their difference to compute an angular offset from a starting an-
gle determined by the third (least dominant) color. Here you divide the circle into
six regions (red, orange, yellow, green, blue, violet) with i specifying the start region
and f acting as a factor determining the offset from i. This value is scaled by the
8.2 Converting Images from RGB Color Space to HSV Color Space | 335

difference between the most dominant (rgbMax) and least dominant (rgbMin) color to
yield a value between 0 and 6. Finally you divide by 6 to get a value for hue in the
range [0,1]. 
In[210]:=
HueValueAr_Integer, g_Integer, b_IntegerE :=
HueValue2Arê255.0, gë 255.0, bê255.0E
HueValue2Ar_ ê; r § 1, g_ ê; g § 1, b_ ê; b § 1E :=
ModuleA9minRGB = MinAr, g, bE, maxRGB = MaxAr, g, bE, f, i=,
WhichAmaxRGB ã minRGB, Return@0D,
minRGB ã r , f = g - b; i = 3,
minRGB ã g, f = b - r; i = 5,
minRGB ã b, f = r - g; i = 1E;
Hi - fêHmaxRGB - minRGBLLê6E
Saturation is a measure of the purity of the hue. Highly saturated colors are domi-
nated by a single color, whereas low saturation yields colors that are more muted.
Geometrically, saturation is depicted as the distance from the center to the edge of
the HSV cone. Mathematically, saturation is the difference between the most domi-
nant and least dominant color scaled by the most dominant. Again, you scale RGB
integer values to the range [0,1]. 
In[212]:=
SatValueAr_Integer, g_Integer, b_IntegerE :=
SatValue2Arê255.0, gë 255.0, bê255.0E
SatValue2Ar_ ê; r § 1, g_ ê; g § 1, b_ ê; b § 1E :=
ModuleA9minRGB = MinAr, g, bE, maxRGB = MaxAr, g, bE=,
If@maxRGB > 0, HmaxRGB - minRGBLêmaxRGB, 0DE
The third component of the HSV triplet is the value, which is also known as bright-
ness (HSV is sometimes referred to as HSB). The brightness is the simplest to com-
pute since it is simply the value of the most dominant RGB value scaled to the range
[0,1]. Geometrically, the value is the distance from the apex (dark) of the HSV cone
to the base (bright). 
In[214]:=
BrightValueAr_Integer, g_Integer, b_IntegerE := MaxAr, g, bE ë 255.0
Given these primitives, it becomes a relatively simple matter to translate an image
from RGB space to HSV space. But before you can do this, you need to understand
how  Mathematica  represents  imported  images.  The  applicable  function  is  called
Raster,  and  it  depicts  a  rectangular  region  of  color  or  gray  level  cells.  See  the
“Discussion”  section  on  page  338  for  more  information  on  Raster.  The  goal  is  to
transform the RGB color cells to HSV color cells. An easy way to do that is to lin-
earize the 2D grid into a linear array and then use the techniques from Recipe 2.1 to
transform this RGB array into an HSV array. To get everything back to a 2D grid, we
use  the  Partition  function  with  information  from  the  original  image  to  get  the
proper width and height. To get HSV images to display properly, we tell Mathematica
336 | Chapter 8: Image Processing

to use Hue as the ColorFunction. Finally, we copy options from the original graphic
to the new graphic, which requires a sequence rather than a list.
In[215]:=
H*RGB2HSVAimage_GraphicsE :=
ModuleA9rgb =FlattenAgetImgDataAimageE,1E,hsv,width,height=,
9width,height= = getImgDimAimageE;
hsv =
9Apply@HueValue,ÒD, Apply@SatValue,ÒD,ApplyABrightValue,ÒE=& êü rgb;
GraphicsARasterAPartition@hsv,widthD, 980,0<,getImgDimAimageE=,
ColorFunctionØHueE,Sequence üü OptionsAimageEEE*L
RGB2HSVAimage_GraphicsE :=
ModuleA9rgb = FlattenAgetImgDataAimageE, 1E, hsv, width, height=,
9width, height= = getImgDimAimageE;
hsv = 9Apply@HueValue, ÒD,
Apply@SatValue, ÒD, ApplyABrightValue, ÒE= & êü rgb;
rasterReplaceAimage, Partition@hsv, widthD, ColorFunction Ø HueEE
In[216]:=
image = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "truck.jpg"=E, "Graphics"E
Out[216]=
In[217]:=
imageHSV = RGB2HSVAimageE
Out[217]=
8.2 Converting Images from RGB Color Space to HSV Color Space | 337

These two images of the red truck look identical, but we can see they have a very dif-
ferent internal representation by inspecting a portion of each Raster.
In[218]:=
ShortAgetImgDataAimageE@@1DD, 3E
Out[218]//Short=
88104, 122, 142<, 899, 117, 137<, 894, 112, 132<,
894, 112, 132<, 898, 119, 138<, 8104, 125, 144<, 8106, 127, 146<,
8106, 127, 146<, 8101, 124, 142<, 8101, 124, 142<, 8100, 123, 141<,
899, 122, 140<, 895, 121, 138<, á134à, 894, 116, 130<,
892, 114, 128<, 892, 114, 128<, 893, 115, 129<, 895, 117, 131<,
899, 121, 135<, 898, 120, 134<, 898, 120, 134<, 898, 120, 134<,
899, 121, 135<, 8101, 123, 137<, 8103, 125, 139<, 8104, 126, 140<<
In[219]:=
ShortAgetImgDataAimageHSVE@@1DD, 3E
Out[219]//Short=
880.587719, 0.267606, 0.556863<, 80.587719, 0.277372, 0.537255<,
80.587719, 0.287879, 0.517647<, á155à,
80.564815, 0.258993, 0.545098<, 80.564815, 0.257143, 0.54902<<
Discussion
The  major  color  spaces  in  popular  use  are  RGB,  HSV,  and  cyan-magenta-yellow-
black (CMYK). RGB is the most common format because it maps directly onto dis-
play technology. The problem with RGB is that it is not very good for image analysis
because colors that are close in perceptual space are not grouped together in RGB
space. CMYK is most often used in printing. HSV is popular in image processing ap-
plications  because  the  mathematical  distance  between  the  colors  is  more  closely
aligned with human judgments, yielding a closer approximation to human percep-
tion of color. Another advantage of HSV is that one can immediately convert from
color to grayscale by discarding the hue and saturation components and retaining
the value component.
In[220]:=
imageHSV ê. 98_Real, _Real, v_Real< Ø v, Hue Ø GrayLevel=
Out[220]=
338 | Chapter 8: Image Processing

Doing image processing in Mathematica requires familiarity with the Raster graph-
ics primitive. When an image is imported from a JPEG, BMP, or GIF file, it will be
represented  as  an  RGB  or  grayscale  Raster  with  cell  values  ranging  from  0
through 255. The ColorFunction will be RGBColor for color image and GrayLevel for
grayscale images. There are several forms of the Raster function, but the form you
will  typically  encounter  in  image  processing  is  Raster[array,  dimensions,  scale,
ColorFunction Ø function], where array is a 2D array of integers or RGB triplets,
dimensions defines a rectangle of the form {{xmin,ymin}, {xmax,ymax}}, scale speci-
fies the minimum and maximum values in the array (typically {0,255}), and function
is either GrayLevel or RGBColor. A good way to test algorithms is to mathematically
create rasters so you have controlled test cases. 
For example, the following is a green gradient in RGB space that varies from black in
the lower left corner to bright green in the upper right. (Of course, you’ll need to try
the code yourself to view the color effects.)
In[221]:=
greenGradientRGB = GraphicsA
RasterATableA90, MinAg*16 + x, 255E, 0=, 9g, 0, 15=, 8x, 0, 15<E ,
880, 0<, 816, 16<<, 80, 255<E, ImageSize Ø 8160, 160<E
Out[221]=
In[222]:=
greenGradientHSV = RGB2HSVAgreenGradientRGBE
Out[222]=
In[223]:=
greenGradientHSV@@1, 2DD
Out[223]=
880, 0<, 816, 16<<
8.2 Converting Images from RGB Color Space to HSV Color Space | 339

In HSV space, we expect the hue coordinate to be a constant (1/3) with the excep-
tion  of  the  black  corner  element.  The  saturation  should  also  be  constant  and  the
brightness values should form a straight line when plotted. This is easy to check.
In[224]:=
UnionAFlattenAgetImgDataAgreenGradientHSVE ê. 8h_, _, _< ß hEE
Out[224]=
80, 0.333333<
In[225]:=
CountAFlattenAgetImgDataAgreenGradientHSVE ê. 8h_, _, _< ß hE, 0E
Out[225]=
1
In[226]:=
CountAFlattenAgetImgDataAgreenGradientHSVE ê. 8h_, _, _< ß hE,
0.3333333333333333`E
Out[226]=
255
In[227]:=
ListPlotAFlattenAgetImgDataAgreenGradientHSVE ê. 8_, _, v_< ß vE,
ImageSize Ø SmallE
Out[227]=
50
100
150
200
250
0.2
0.4
0.6
0.8
1.0
See Also
In  Mathematica  7,  use  ColorConvert  (see  the  documentation  center:  http://bit.ly/
irShF).
Wikipedia has several very approachable articles on color models. See http://bit.ly/
lWvVW, http://bit.ly/2DZAhY, http://bit.ly/3jawwr, and http://bit.ly/2qHxrI. 
Color renderings of the images in this chapter can be found at http://bit.ly/xIgx7 or
http://www.mathematicacookbook.com.
340 | Chapter 8: Image Processing

8.3 Enhancing Images Using 
Histogram Equalization
Problem
You  have  an  image  that  is  too  dark  or  too  light  and  you  would  like  to  increase
contrast.
Solution
You  obtain  the  histogram  of  a  grayscale  image  using  BinCounts  on  the  flattened
raster  matrix.  If  an  image  has  poor  contrast,  you  will  see  that  the  histogram  is
skewed when you plot the histogram using BarChart.
In[228]:=
overexposed = ImportAFileNameJoinA9NotebookDirectory@D,
"..", "images", "truckOverExposed.jpg"=E, "Graphics"E
Out[228]=
In[229]:=
Quiet@Needs@"BarCharts`"DD
In[230]:=
histogramPlotAimage_GraphicsE :=
ModuleA9pixels = FlattenAgetImgDataAimageEE, min, max, dx, width, height=,
8min, max< = IfAMatchQAgetImgRangeAimageE, 8_, _<E,
getImgRangeAimageE, 80, 1<E;
dx = Hmax - minLê255.0;
BarChartABinCounts@pixels, 8min, max + dx, dx<D, BarLabels Ø None,
BarStyle Ø Black, BarSpacing Ø 0.25, BarEdges Ø FalseEE
8.3 Enhancing Images Using Histogram Equalization | 341

In[231]:=
histogramPlot@overexposedD
Out[231]=
0
100
200
300
400
Histogram equalization works by using the image distribution to derive a transfor-
mation function that will always yield a more uniform distribution of gray levels de-
spite the shape of the input image’s distribution. The solution below will work on
any grayscale image but is not very efficient. I’ll implement a more efficient solution
in the “Discussion” section on page 343 and also cover theory that explains why this
transformation works. 
In[232]:=
histCDFAx_, histogram_, n_E :=
NASumAhistogram@@iDD, 8i, 1, x + 1, 1<E*255 ênE
In[233]:=
histogramCorrectAimage_GraphicsE :=
ModuleA9pixels = FlattenAgetImgDataAimageEE,
min, max, histogram, width, height, nPixels, outpix=,
H*Extract the image's dimensions.*L
9width, height= = getImgDimAimageE ;
H*Extract the image's range, which if unspecified implies @0,1D.*L
8min, max< =
IfAMatchQAgetImgRangeAimageE, 8_, _<E, getImgRangeAimageE, 80, 1<E;
H*Normalize the data to the range @0,255D if necessary.*L
pixels = If@8min, max< == 80, 255<,
pixels, Round@Rescale@pixels, 8min, max<, 80, 255<DDD;
H*Compute histogram. Use 256 as the upper limit because
the BinCount range is of the form @min,maxD.*L
histogram = BinCounts@pixels, 80, 256, 1<D;
H*Transform by treating the
histogram as a cumulative distribution function.*L
nPixels = width * height;
outpix = histCDFAÒ, histogram, nPixelsE & êü pixels;
GraphicsARasterAPartition@outpix, widthD, image@@1, 2DD, 80, 255<,
ColorFunction Ø GrayLevelE, Sequence üü OptionsAimageEEE
342 | Chapter 8: Image Processing

In[234]:=
corrected = histogramCorrect@overexposedD
Out[234]=
Note how the histogram of the corrected image is more spread out than the input.
In[235]:=
histogramPlot@correctedD
Out[235]=
0
100
200
300
400
Discussion
The theory behind automatic histogram equalization is based on probability theory.
View the gray levels of an image as a random variable in the interval [0,1]. It is clear
that grayscale ranges in the [0,255] range can be scaled to [0,1] simply by dividing
by 255. Let pr[r] denote the probability density function (PDF) of the input image.
Let ps[s] denote the desired PDF of the output image. In this case, we want ps[s] to
be uniform. Let T[r] denote the transformation function applied to the input r to
produce output s with PDF ps[s]. We want T[r] to be a single-valued monotoni-
cally increasing function. Single valued is necessary so that the inverse exists; mono-
tonic prevents the transformation from inverting gray levels. We also want T[r] to
have range [0,1]. Given these conditions, we know from probability that the trans-
formed PDF is related to the original PDF by:
ps@sD = pr@rD
dr
ds
8.3 Enhancing Images Using Histogram Equalization | 343

In the solution, we used the discrete form of the cumulative density function (CDF)
as T[r]. The continuous form of the CDF is
s = T@rD= ‡
0
r
pr@wD„w
By substitution, we obtain
d s
d r
=
d T@rD
d r
=
d
d r
‡
0
r
pr@wD„w
We can ask Mathematica to evaluate this derivative for us by entering it in Mathe-
matica syntax.
In[236]:=
DC‡
0
r
pr@wD „w, rG
Out[236]=
pr@rD
By substitution into the original equation, we get
s@sD = pr@rD
1
pr@rD
Since  the  probabilities  are  always  positive,  we  can  remove  the  absolute  value  to
prove that 
s[s] = 1
This  means  that  the  PDF  of  s  is  1;  hence,  we  have  a  uniform  distribution.  This
demonstrates that in the continuous case, using the CDF as a transformation always
yields  a  uniform  distribution  regardless  of  the  characteristics  of  the  input  PDF.
Of course, these results for the continuous domain do not translate exactly to the
discrete domain, but it suggests that the discrete CDF will tend to shift gray levels to
a more uniform range. To gain some deeper insight, you can plot the transformation
function obtained from the histogram of the overexposed image.
In[237]:=
ClearAllAT, i, k, histogram, nPixelsE;
histogram = BinCountsAFlattenAgetImgData@overexposedDE, 80, 256, 1<E;
nSum = TotalAhistogramE;
nPixels = Times üü IgetImgDim@overexposedDM;
T@k_D := NASumAhistogram@@iDD, 8i, 1, k + 1, 1<Eë nPixelsE*255
PlotAT@xD, 8x, 0, 255<, PlotRange Ø AutomaticE
344 | Chapter 8: Image Processing

Out[242]=
50
100
150
200
250
50
100
150
200
250
This shows that all but the brightest levels will be mapped to darker levels; thus an
overly bright image will tend to be darkened. The opposite will occur for an overly
dark (underexposed) input image. 
The nature of the transformation function leads to an obvious optimization: a pre-
computed lookup table computed in a single pass using FoldList. This lookup table
can be used as the transformation function. This produces an O(nPixels) algorithm
from our original O(nLevels * nPixels).
In[243]:=
histogramCorrect2Aimage_GraphicsE :=
ModuleA9pixels = FlattenAgetImgDataAimageEE, min, max,
histogram, transform, width, height, nPixels, outpix=,
H*Extract the image's dimensions.*L
9width, height= = getImgDimAimageE;
H*Extract the image's range, which if unspecified implies @0,1D.*L
8min, max< =
IfAMatchQAgetImgRangeAimageE, 8_, _<E, getImgRangeAimageE, 80, 1<E;
H*Normalize the data to the range @0,255D if necessary.*L
pixels = If@8min, max< == 80, 255<,
pixels, Round@Rescale@pixels, 8min, max<, 80, 255<DDD;
H*Compute histogram. Use 256 as the upper limit because
the BinCount range is of the form @min,maxM.*L
histogram = BinCounts@pixels, 80, 256, 1<D;
H*Transform by treating the
histogram as a cumulative distribution function.*L
nPixels = width * height;
transform = NARestAFoldListAPlus, 0, histogramEE * 255ênPixelsE;
outpix = transform@@Ò + 1DD & êü pixels;
GraphicsARasterAPartition@outpix, widthD, image@@1, 2DD, 80, 255<,
ColorFunction Ø GrayLevelE, Sequence üü OptionsAimageEEE
8.3 Enhancing Images Using Histogram Equalization | 345

As you can see, there is a two-orders-of-magnitude performance improvement for
histogramCorrect2.
In[244]:=
timingOrig = TimingAhistogramCorrect@overexposedDE@@1DD;
timingNew = TimingAhistogramCorrect2@overexposedDE@@1DD;
GridA99"original", "new"=, 9timingOrig, timingNew==E
Out[246]=
original
new
2.356
0.015
Here are the histograms from each for comparison.
In[247]:=
GraphicsRowA9histogramPlotAhistogramCorrect2@overexposedDE,
histogramPlotAhistogramCorrect@overexposedDE=E
Out[247]=
0
100
200
300
400
0
100
200
300
400
Mathematica  7  has  the  native  function  ImageHistogram  for  plotting  an  image’s
histogram.
In[248]:=
GraphicsRowA9ImageHistogramAhistogramCorrect2@overexposedDE,
ImageHistogramAhistogramCorrect@overexposedDE=E
Out[248]=
See Also
Recipe 8.3 shows how histograms can be used to match one image’s contrast to that
of a reference image.
346 | Chapter 8: Image Processing

8.4 Correcting Images Using Histogram 
Specification
Problem
You  need  to  transform  the  gray  levels  of  an  image  to  match  another  image’s
histogram.
Solution
To match a histogram of one image to another, you produce the equalization trans-
form of the input image as in Recipe 8.1. You then produce the equalization trans-
form  of  the  target  image,  and  from  that  and  the  input  transform,  derive  the  final
specification transform. Next, map the input through the specification transform to
yield an image that approaches the target image’s histogram. Since you need to build
the equalization transform for each image, it makes sense to factor that logic into a
separate function. Here I call it buildEqualizationMap. You will recognize the basic
logic from Recipe 8.2.
In[249]:=
buildEqualizationMapAimage_GraphicsE :=
ModuleA9pixels , min, max, histogram, width, height, nPixels=,
pixels = FlattenAgetImgDataAimageEE;
8min, max< = IfAMatchQAgetImgRangeAimageE, 8_, _<E,
getImgRangeAimageE, 80, 1<E;
pixels = If@8min, max< == 80, 255<, pixels,
Rescale@pixels, 8min, max<, 80, 255<DD;
nPixels = Length@pixelsD ;
histogram = BinCounts@pixels, 80, 256, 1<D;
NARestAFoldListAPlus, 0, histogramEE * 255ênPixelsEE
The main function must build the map for each image and use those maps to derive
the final transformation (here it is called specMap). The logic underlying the deriva-
tion  of  specMap  is  explained  in  the  “Discussion”  section  on  page  349  and  was
adapted from work by Nikos Drakos and Ross Moore (refer to the “See Also” sec-
tion on page 351). Here we take advantage of Reap and Sow to build up specMap incre-
mentally without the overhead of Append.
8.4 Correcting Images Using Histogram Specification | 347

In[250]:=
specificationMapAinputMap_List, targetMap_ListE :=
ModuleA9i, j = 0=, ReapADoA
IfAIinputMap@@i + 1DD <= targetMapAAj + 1EEM ,
SowAjE,
WhileAinputMap@@i + 1DD > targetMapAAj + 1EE , j++E;
SowAIfAItargetMapAAj + 1EE - inputMap@@i + 1DDM >
IinputMap@@i + 1DD - targetMapAAjEEM, j--, jEE
E, 8i, 0, 255<EE@@2, 1DDE
In[251]:=
histogramSpecificationAinput_Graphics, target_GraphicsE :=
ModuleA9pixels , min, max, histogram, width,
height, nPixels, inputMap, targetMap, specMap, outpix=,
H*Compute histogram mapping of target.*L
targetMap = buildEqualizationMapAtargetE;
H*Compute histogram mapping of input.*L
inputMap = buildEqualizationMap@inputD;
H*Compute inverse of targetMap.*L
specMap = specificationMapAinputMap, targetMapE;
H*Use inverse to transform input.*L
outpix = FlattenAgetImgData@inputDE;
H*outpix = inputMap@@Round@ÒD+1DD&êü outpix;*L
outpix = specMap@@Round@ÒD + 1DD & êü outpix ;
9width, height= = getImgDim@inputD ;
GraphicsARasterAPartition@outpix, widthD, input@@1, 2DD, 80, 255<,
ColorFunction Ø GrayLevelE, Sequence üü Options@inputDEE
To demonstrate histogramSpecification, I’ll synthesize two raster images with differ-
ent grayscale levels, using one as the input and the other as the target. In Recipe 8.4
there is a much less contrived example of this algorithm’s application.
In[252]:=
test = GraphicsARasterATableAi*jë 2, 8i, 1, 16<, 9j, 1, 16=E,
880, 0<, 816, 16<<, 80, 255<E, ImageSize Ø 864, 64<E
Out[252]=
348 | Chapter 8: Image Processing

In[253]:=
target = GraphicsARasterATableAi*j - 1, 8i, 1, 16<, 9j, 1, 16=E,
880, 0<, 816, 16<<, 80, 255<E, ImageSize Ø 864, 64<E
Out[253]=
Here  you  can  see  the  darker  test  image  has  been  shifted  toward  the  lighter  target
image.
In[254]:=
histogramSpecificationAtest, targetE
Out[254]=
Discussion
In Recipe 8.2 we saw how histograms can be used to automatically equalize an im-
age’s contrast. However, sometimes it is preferable to equalize based on a reference
histogram  rather  than  a  uniform  distribution.  This  often  arises  when  transforma-
tions are applied to an image and have side effects that reduce contrast~side effects
we wish to undo by shifting the image back to the grayscale distribution of the origi-
nal image (see Recipe 8.4).
To appreciate the theory behind the solution, imagine an image that has a uniform
grayscale distribution. Suppose you want to transform this hypothetical image to the
distribution  of  the  target  image.  How  could  you  produce  such  a  transformation?
You  already  know  how  to  transform  the  target  image  to  a  uniform  distribution
(Recipe 8.2); it follows that the inverse of this transformation will take the uniform
distribution back to the target distribution. If we had this inverse distribution, we
could proceed as follows:
1. Transform the input image to a uniform distribution using Recipe 8.2.
2. Use  the  inverse  of  the  target  equalization  transformation  to  transform  the
output of (1) to the distribution of the target.
The key to the solution is finding the inverse. Since you are working in a discrete
domain,  you  cannot  hope  to  find  the  exact  inverse,  but  you  can  approximate  the
8.4 Correcting Images Using Histogram Specification | 349

inverse by flipping the targetMap, taking the minimal unique values, and filling in
missing values with the next closest higher entry. The function inverseEqualization-
Map shown here will build such an inverse from an image. However, if you inspect
the code in histogramSpecification, you’ll see that for efficiency the inverse is never
built, but rather it computes the specification map directly using specificationMap
from the input and target equalization transformations (inputMap and targetMap). 
In[255]:=
expand@p1_List, p2_ListD := Reap@Sow@p1D;
Do@Sow@8i, p2@@2DD<D, 8i, p1@@1DD + 1, p2@@1DD - 1<DD@@2, 1DD
buildPartialInverseEqualizationMapAimage_GraphicsE :=
ModuleA9map = buildEqualizationMapAimageE=,
Union@880, 0<<, Table@8Round@map@@i + 1DDD, i<, 8i, 0, 255<D,
88256, 255<<, SameTest Ø HÒ1@@1DD ã Ò2@@1DD &LDE
inverseEqualizationMapAimage_GraphicsE := FlattenA
expand üüü PartitionAbuildPartialInverseEqualizationMapAimageE, 2, 1E,
1E@@All, 2DD
We  can  gain  some  insight  into  this  process  by  creating  a  function  histogram-
SpecificationPlot,  which  plots  the  input  transform,  target  transform,  target
inverse, and the resulting histogram specification transform. These plots show how
input  gray  levels  are  mapped  to  output  gray  levels.  If  you  are  not  convinced  that
specificationMap gives the desired transformation, replace the plot of specMap with
inverseMap[#]& /@ inputMap to see that it yields the same plot. 
In[258]:=
NeedsA"PlotLegends`"E
histogramSpecificationPlotAinput_Graphics, target_GraphicsE :=
ModuleA9inputMap, targetMap, inverseMap, specMap=,
H*Compute histogram mapping of target.*L
targetMap = buildEqualizationMapAtargetE;
H*Compute histogram mapping of input.*L
inputMap = buildEqualizationMap@inputD;
inverseMap = inverseEqualizationMapAtargetE;
H*Compute inverse of targetMap.*L
specMap = specificationMapAinputMap, targetMapE;
ListPlotA9inputMap, targetMap, inverseMap, specMap=,
PlotMarkers Ø Automatic, Joined Ø True, MaxPlotPoints Ø 50,
PlotLegend Ø 9"inputEq", "targetEq", "inverseTarget", "spec"=,
LegendPosition Ø 80.7, -0.5<, LegendSize Ø 0.4,
LegendShadow Ø None, ImageSize Ø LargeEE
350 | Chapter 8: Image Processing

In[260]:=
histogramSpecificationPlotAtest, targetE
Out[260]=
ÊÊ
ÊÊ
ÊÊÊ
ÊÊÊ
Ê
Ê
Ê
ÊÊ
ÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ
‡‡‡‡‡‡‡
‡‡‡
‡
‡
‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡
ÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏÏ
Ï
Ï
ÚÚÚÚÚÚÚÚÚÚÚÚ
ÚÚÚ
ÚÚÚÚÚÚÚÚ
Ú
Ú
ÚÚ
Ú
ÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚÚ
50
100
150
200
250
50
100
150
200
250
Ú
spec
Ï
inverseTarget
‡
targetEq
Ê
inputEq
See Also
The theory behind histogram specification can be found in Gonzalez and Woods,
but for the implementation, I am indebted to Professor Ruye Wang’s lecture notes,
available at http://bit.ly/4oSglp. Wang’s lecture contains information originally pub-
lished by Nikos Drakos (University of Leeds) and Ross Moore (Macquarie Univer-
sity, Sydney). 
8.5 Sharpening Images Using Laplacian 
Transforms
Problem
You want to emphasize edges in the image and make them easier for the eye to pick
out. You want to work in the spatial domain.
8.5 Sharpening Images Using Laplacian Transforms | 351

Solution
This transformation is performed as a convolution of the image with one of the Lap-
lacian kernels in Figure 8-1.
Transforms
Subtract transform from image Add transform to image
Sharpens in vertical
and
horizontal
0
1
0
1 -4
1
0
1
01
0
-1
0
-1
4
-1
0
-1
0
Also sharpens in
diagonal
1
1
1
1 -8 1
1
1
1
-1
-1
-1
-1
8
-1
-1
-1
-1
Figure 8-1. Laplacian kernels
The built-in function ListConvolve makes it easy to implement image convolution in
Mathematica. The only caveat is that by default, ListConvolve returns a matrix that
is smaller than the input. However, you can specify a cyclic convolution by pass-
ing a third parameter of 1 to ListConvolve to make the output size match the input
size. Refer to the ListConvolve Mathematica documentation for clarification. 
In[261]:=
sharpenWithLaplacianAimage_Graphics,
kernel_List : 88-1, -1, -1<, 8-1, 8, -1<, 8-1, -1, -1<<E :=
ModuleA8transformed, sharpened<,
transformed = ListConvolveAkernel, getImgDataAimageE, 1E;
sharpened = NAgetImgDataAimageE + Sign@kernel@@2, 2DDD* transformedE;
GraphicsA
RasterARescale@sharpened, 8Min@ÒÒD, Max@ÒÒD< & üü Flatten@sharpenedD,
80, 255<D, image@@1, 2DD, 80, 255<,
ColorFunction Ø GrayLevelE, Sequence üü OptionsAimageEEE
Here we want to see more fine detail of the craters in an image of the moon. The
transform  achieves  this  but  we  lose  contrast.  We  can  readjust  contrast  using  the
histogramSpecification algorithm from Recipe 8.3.
352 | Chapter 8: Image Processing

In[262]:=
image = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "moon.jpg"=E, "Graphics"E
Out[262]=
In[263]:=
sharpenWithLaplacianAimageE
Out[263]=
8.5 Sharpening Images Using Laplacian Transforms | 353

In[264]:=
histogramSpecificationAsharpenWithLaplacianAimageE, imageE
Out[264]=
Discussion
The Laplacian of a continuous 2D function is given as
“2f =
∂2f
∂2x2 +
∂2f
∂2y2
This equation is not useful for image processing and must be converted to discrete
form. A common way to do this is to express each component in finite difference
form and sum the result.
∂2f
∂2x2 =fIx+1,yM + f Ix-1,yM - 2fIx,yM
∂2f
∂2y2 = fIx,y+1M + fIx,y-1M - 2fIx,yM
“2f = fIx+1,yM + f Ix-1,yM + fIx,y+1M + fIx,y-1M - 4 fIx,yM
This leads to the convolution kernel shown in Figure 8-2a. To improve results in the
diagonal directions, one can add terms for each of the four diagonal components~
for example, f(x+1,y+1)~each which contributes a negative f(x,y) term leading to
the kernel in Figure 8-2b. Equivalently, one can multiply each of these kernels by |1,
with the sign of the center value determining whether you add or subtract the trans-
354 | Chapter 8: Image Processing

formation from the input image to get the sharpened version. Since the operation is
based on second derivatives, it creates a sharp response in areas of discontinuities
and a shallow response around more slowly varying gray levels. This can be seen
by  viewing the output of the transformation  directly  (i.e.,  before  it  is  added  to
the input image).
a
b
0
1
0
1
-4
1
0
1
0
1
1
1
1
-8
1
1
1
1
Figure 8-2. Convolution kernels
In[265]:=
laplacianImageAimage_Graphics,
kernel_List : 88-1, -1, -1<, 8-1, 8, -1<, 8-1, -1, -1<<E :=
ModuleA8transformed<, transformed =
ListConvolveAkernel, getImgDataAimageE, 1E;
GraphicsARasterARescale@transformed, 8Min@ÒÒD, Max@ÒÒD< & üü
Flatten@transformedD, 80, 255<D, image@@1, 2DD, 80, 255<,
ColorFunction Ø GrayLevelE, Sequence üü OptionsAimageEEE
In[266]:=
laplacianImageAimageE
Out[266]=
8.5 Sharpening Images Using Laplacian Transforms | 355

See Also
In Mathematica 7, you can use Sharpen (http://bit.ly/2rutpn).
8.6 Sharpening and Smoothing 
with Fourier Transforms
Problem
You want to emphasize either the low or high frequency characteristics of an image. 
Solution
Fourier-based  image  processing  in  Mathematica  is  particularly  easy  to  implement
since it has the native function Fourier, which implements a high-quality version of
the Fast Fourier Transform (FFT). The basic steps of Fourier image processing are
1. Obtain the Fourier transform of the image.
2. Center the Fourier transform using one of the techniques explained in the dis-
cussion here.
3. Apply a filtering function to the transformed result.
4. Undo the centering. 
5. Apply  the  inverse  Fourier  transform,  discarding  any  residual  imaginary
components.
In[95]:=
Clear@fourierFilterD;
fourierFilterAimage_, filter_E :=
ModuleA9four , trans, cols = LengthAgetImgDataAimageE@@1DDE,
rows = LengthAgetImgDataAimageEE=,
trans = TableAH-1Lx+y, 8x, 1, rows<, 9y, 1, cols=E;
H*Centering transforms*L
four = FourierAgetImgDataAimageE *trans, FourierParameters -> 81, -1<E;
four =
TableAfilterAx, y, rows, colsE, 8x, 1, rows<, 9y, 1, cols=E * four;
four = Abs@InverseFourier@four, FourierParameters -> 81, -1<D* transD;
GraphicsARasterAfour, getImgCoordAimageE, 8Min@ÒÒD, Max@ÒÒD< & üü
Flatten@fourD, ColorFunction Ø IGrayLevel@Ò1, 1D &MEEE
356 | Chapter 8: Image Processing

The fourierFilter function is designed to work with a custom filter function. Here
are some common functions found in the literature. See the “Discussion” section on
page 358 for more details.
In[11]:=
dist@u_, v_, rows_, cols_D := Sqrt@Hu - rowsê2.L^2 + Hv - colsê2.L^2D
In[12]:=
idealLowPass@u_, v_, rows_, cols_, d0_D :=
If@dist@u, v, rows, colsD § d0, 1, 0D
In[13]:=
idealHighPass@u_, v_, rows_, cols_, d0_D :=
If@dist@u, v, rows, colsD § d0, 0, 1D
In[14]:=
butterWorthLowPass@u_, v_, rows_, cols_, d0_, n_D :=
1.0êH1.0 + Hdist@u, v, rows, colsDêd0L^2 nL
One can use a low-pass filter for blurring an image. This might be done as a single
stage of a multistage process applied to text that will be processed by OCR software.
For  example,  blurring  can  diminish  gaps  in  letters.  This  might  be  followed  by  a
threshold transformation and other adjustments. 
In[100]:=
image = ColorConvertA
ImportAFileNameJoinA9NotebookDirectory@D, "..", "images", "text2.png"=E,
"Graphics", ImageSize Ø MediumE, "GrayScale"E
Out[100]=
8.6 Sharpening and Smoothing with Fourier Transforms | 357

In[103]:=
image2 = fourierFilterAimage, butterWorthLowPass@Ò1, Ò2, Ò3, Ò4, 90, 1D &E
Out[103]=
Discussion
An important step in this algorithm is centering the zero frequency component of
the transform. This allows filter functions to use the distance from the center as a
function of increasing frequency. There are two ways to achieve centering. One way
is to preprocess the image before it is transformed by multiplying it by the function
H-1Lx+y. This function produces a matrix of alternating values 1 and |1. This is the
technique used in the solution.
In[274]:=
TableAH-1Lx+y, 8x, 1, 10<, 9y, 1, 10=E êê MatrixForm
Out[274]//MatrixForm=
1
-1
1
-1
1
-1
1
-1
1
-1
-1
1
-1
1
-1
1
-1
1
-1
1
1
-1
1
-1
1
-1
1
-1
1
-1
-1
1
-1
1
-1
1
-1
1
-1
1
1
-1
1
-1
1
-1
1
-1
1
-1
-1
1
-1
1
-1
1
-1
1
-1
1
1
-1
1
-1
1
-1
1
-1
1
-1
-1
1
-1
1
-1
1
-1
1
-1
1
1
-1
1
-1
1
-1
1
-1
1
-1
-1
1
-1
1
-1
1
-1
1
-1
1
358 | Chapter 8: Image Processing

Alternatively, one can postprocess the Fourier output by swapping quadrants using
the quadSwap function.
In[275]:=
quadSwap@matrix_ListD := ModuleA9width, height, q1, q2, q3, q4=,
9width, height= = 9Length@matrix@@1DDD, Length@matrixD=;
q1 = matrixAA1 ;; FloorAheightë 2E, 1 ;; Floor@widthê2DEE;
q2 = matrixAA1 ;; FloorAheightë 2E, Floor@widthê2D + 1 ;; widthEE;
q3 =
matrixAAFloorAheightë 2E + 1 ;; height, Floor@widthê2D + 1 ;; widthEE;
q4 = matrixAAFloorAheightë 2E + 1 ;; height, 1 ;; Floor@widthê2DEE;
Join@Join@q3, q4, 2D, Join@q2, q1, 2DDE
In[276]:=
ItestQuadSwap = TableA
IfAx <= 5 && y <= 5, 1, IfAx > 5 && y <= 5, 4, IfAx § 5 && y > 5, 2, 3EEE,
8x, 1, 10<, 9y, 1, 10=EM êê MatrixForm
Out[276]//MatrixForm=
1 1 1 1 1 2 2 2 2 2
1 1 1 1 1 2 2 2 2 2
1 1 1 1 1 2 2 2 2 2
1 1 1 1 1 2 2 2 2 2
1 1 1 1 1 2 2 2 2 2
4 4 4 4 4 3 3 3 3 3
4 4 4 4 4 3 3 3 3 3
4 4 4 4 4 3 3 3 3 3
4 4 4 4 4 3 3 3 3 3
4 4 4 4 4 3 3 3 3 3
In[277]:=
quadSwap@testQuadSwapD êê MatrixForm
Out[277]//MatrixForm=
3 3 3 3 3 4 4 4 4 4
3 3 3 3 3 4 4 4 4 4
3 3 3 3 3 4 4 4 4 4
3 3 3 3 3 4 4 4 4 4
3 3 3 3 3 4 4 4 4 4
2 2 2 2 2 1 1 1 1 1
2 2 2 2 2 1 1 1 1 1
2 2 2 2 2 1 1 1 1 1
2 2 2 2 2 1 1 1 1 1
2 2 2 2 2 1 1 1 1 1
I include both methods because you may encounter either of them in the literature.
Gonzalez  and  Woods  use  the  preprocessing  technique,  although  I  find  the  post-
processing technique easier to understand conceptually.
8.6 Sharpening and Smoothing with Fourier Transforms | 359

It  is  difficult  to  appreciate  the  meaning  of  complex  images  after  they  are  mapped
into  the  frequency  domain.  However,  almost  every  image-processing  text  that
discusses the Fourier transform will provide images of the transformation after center-
ing. The fourierImage function below does this using quadSwap, whereas fourier-
Image2  uses  H-1Lx+y.  You  can  see  that  they  produce  equivalent  results.  You’ll
notice  that  each  function  maps  Log[#+1]  over  the  pixel  values  because  Fourier
transforms produce images with a much too large dynamic range. 
In[278]:=
fourierImageAimage_GraphicsE :=
ModuleA9four = MapALog@Ò + 1D &, quadSwapAAbsA
FourierAgetImgDataAimageE, FourierParameters Ø 81, -1<EEE, 2E=,
GraphicsARasterAfour, image@@1, 2DD, 8Min@ÒÒD, Max@ÒÒD< & üü
Flatten@fourD, ColorFunction Ø GrayLevelE, OptionsAimageEEE
In[279]:=
fourierImage2Aimage_GraphicsE := ModuleA9width, height, trans, four=,
8cols, rows< = getImgDimAimageE;
trans = TableAH-1Lx+y, 8x, 1, rows<, 9y, 1, cols=E;
four = MapALog@Ò + 1D &, AbsA
FourierAgetImgDataAimageE * trans, FourierParameters Ø 81, -1<EE, 2E;
GraphicsARasterAfour, image@@1, 2DD, 8Min@ÒÒD, Max@ÒÒD< & üü
Flatten@fourD, ColorFunction Ø GrayLevelE, OptionsAimageEEE
In[280]:=
fourierImageAimageE
Out[280]=
360 | Chapter 8: Image Processing

In[281]:=
fourierImage2AimageE
Out[281]=
8.7 Detecting Edges in Images
Problem
You want to detect boundaries between distinct objects in an image possibly as a
preprocessing step to object recognition.
Solution
Two popular methods of edge detection are the Sobel and Laplacian of the Gaussian
(LoG) algorithms. The Sobel is based on first-order derivatives that approximate the
gradient. The LoG algorithm combines the second-order Laplacian that we used in
8.7 Detecting Edges in Images | 361

Recipe 3.3 with a Gaussian smoothing to reduce the sensitivity of the Laplacian to
noise. See the “Discussion” section on page 364 for further details. This implementa-
tion uses transformation rules that map intermediate gray levels to either white or
black to emphasize the edges.
The  edgeDetectSobel  function  provides  the  orientation  optional  parameter  for
extracting just the x edges {1,0}, just the y edges {0,1}, or both {1,1} (the default).
In[282]:=
edgeDetectSobelAimage_Graphics, orientation_List : 81, 1<E :=
ModuleA9yKernel = orientation@@2DD*881, 0, -1<, 82, 0, -2<, 81, 0, -1<<,
xKernel = orientation@@1DD*881, 2, 1<, 80, 0, 0<, 8-2, -1, -1<<,
transformed=,
transformed = AbsAListConvolveAxKernel, getImgDataAimageE, 1EE +
AbsAListConvolveAyKernel, getImgDataAimageE, 1EE;
GraphicsARasterAtransformed ê. 8x_ ê; x < 127 Ø 0, x_ ê; x ¥ 127 Ø 255<,
image@@1, 2DD, 80, 255<, ColorFunction Ø GrayLevelE,
Sequence üü OptionsAimageEEE
The  edgeDetectLOG  function  provides  a  way  to  customize  the  kernel.  See  the
“Discussion” section on page 364 for criteria of appropriate kernels. 
In[283]:=
edgeDetectLOGAimage_Graphics,
kernel_List : 880, 0, -1, 0, 0<, 80, -1, -2, -1, 0<,
8-1, -2, 16, -2, -1<, 80, -1, -2, -1, 0<, 80, 0, -1, 0, 0<<E :=
ModuleA8transformed<, transformed =
ListConvolveAkernel, getImgDataAimageE, 1E;
GraphicsARasterAtransformed ê. 8x_ ê; x < 127 Ø 0, x_ ê; x ¥ 127 Ø 255<,
image@@1, 2DD, 80, 255<, ColorFunction Ø GrayLevelE,
Sequence üü OptionsAimageEEE
In[284]:=
mech = ImportAFileNameJoinA
9NotebookDirectory@D, "..", "images", "mechanism.png"=E, "Graphics"E;
362 | Chapter 8: Image Processing

In[285]:=
GraphicsGridA99mech, edgeDetectSobel@mechD=,
9edgeDetectSobel@mech, 80, 1<D, edgeDetectSobel@mech, 81, 0<D=,
9edgeDetectLOG@mechD , edgeDetectLOG@mech,
2*880, 0, -1, 0, 0<, 80, -1, -2, -1, 0<, 8-1, -2, 16, -2, -1<,
80, -1, -2, -1, 0<, 80, 0, -1, 0, 0<<D ==,
ImageSize Ø Medium, Dividers Ø AllE
Out[285]=
8.7 Detecting Edges in Images | 363

Discussion
An edge is a set of connected pixels that lie on the boundary of two regions. Edges
are local areas of discontinuity rather than more global regions. An ideal edge would
have a sharp transition between two very different grayscale values; however, few
realistic images will have edges that are so sharply defined. Typically an edge transi-
tion will be in the form of a ramp from one level to the next, possibly with some
noise superimposed on the transition. See Gonzalez and Woods for some nice visual-
izations of these concepts.
Since  edges  are  transitions,  it  is  not  surprising  that  methods  of  edge  detection
are based on mathematical derivatives. First derivatives of a noisy ramp will produce
an approximate square wave transition along the length of the ramp. Second deriva-
tives will form a spike at the start of the edge transition and one of opposite sign at
the end. 
The  Sobel  masks  and  Laplacian  masks  approximate  first  and  second  derivatives
in  the  discrete  domain.  There  are  two  masks  in  the  first-derivative  Sobel  method.
The first finds horizontal edges; the second finds vertical edges. The function edge-
DetectSobel is written so that you can use the second parameter to emphasize both
edges {1,1}, horizontal edges {1,0}, or vertical edges {0,1}. 
The edgeDetectLOG functions uses a larger 5 × 5 mask  to  better  approximate  the
Mexican  hat  response  function  sought  by  that  transformation  (large  central  peak,
with rapid tapering off, followed by a gentle increase). This transformation creates
finer lines but is more sensitive to image noise. 
Mathematica 7 has ImageConvolve. Here is an example using a Sobel mask.
In[286]:=
ImageResizeAImageConvolveAImportA
FileNameJoinA9NotebookDirectory@D, "..", "images", "mechanism.png"=EE,
88-1, 0, 1<, 8-2, 0, 2<, 8-1, 0, 1<<E, 250E
Out[286]=
364 | Chapter 8: Image Processing

8.8 Image Recognition Using Eigenvectors 
(Eigenimages)
Problem
Given an initial training set of images, you want to find the best match of an input
image to an image in the training set.
Solution
Here  we  show  a  solution  that  uses  concepts  from  principal  component  analysis
(PCA) and information theory to map a high-dimensional training set of images into
a lower dimension such that the most significant features of the data are preserved.
This allows new images to be classified in terms of the training set. 
In[287]:=
H*Helper for vectorizing and scaling image data*L
imageVectorAimage : I_Graphics
_ImageME :=
NARescaleAFlattenAgetImgDataAimageEEEE
H*Computes eigenimage vectors, avg image vector,
and eigenvectors of reduced M x M system
where M is the number of training images*L
eigenImageElementsAimages_List, frac_ : 0.5E :=
ModuleA9imgMatrix = imageVector êü images,
imgMatrixAdj, imgAverage, eigenVecs=,
imgAverage = NATotalAimgMatrixEë LengthAimgMatrixEE;
imgMatrixAdj = IÒ - imgAverageM & êü imgMatrix;
eigenVecs = EigenvectorsADotAimgMatrixAdj, TransposeAimgMatrixAdjEEE ;
imgMatrixAdj =
DotATakeAeigenVecs, CeilingAfrac * LengthAeigenVecsEEE, imgMatrixE;
9imgMatrixAdj, imgAverage, eigenVecs=E
H*Computes the eigenimages and
average image from a set of training images*L
eigenImagesAimages_List, frac_ : 0.5E :=
ModuleA9eigenImages, imgAvg, dummy, img1 = images@@1DD, width=,
9eigenImages, imgAvg, dummy= = eigenImageElementsAimages, fracE;
width = getImgDimAimg1E@@1DD;
GraphicsARasterAPartition@Rescale@ÒD, widthD, img1@@1, 2DD, 80.0, 1.0<E,
OptionsAimg1EE & êü AppendAeigenImages , imgAvgE
E
8.8 Image Recognition Using Eigenvectors (Eigenimages) | 365

H*Computes a set of weight vectors for each input image,
and acceptance threshold for matching new
images based on the results from eigenImageElements*L
eigenImageRecognitionElementsAimages_List, frac_ : 0.5E :=
ModuleA
9eigenImages, imgAvg, dummy, weightVecs, thresholdVec, threshold=,
9eigenImages, imgAvg, dummy= = eigenImageElementsAimages, fracE;
weightVecs =
TableADotAimageVectorAimages@@iDDE - imgAvg, eigenImagesAAjEEE,
9i, 1, LengthAimagesE=, 9j, 1, LengthAeigenImagesE=E;
thresholdVec = TableADotAimgAvg, eigenImages@@iDDE,
9i, 1, LengthAeigenImagesE=E;
threshold = MinAEuclideanDistance@thresholdVec, ÒD & êü weightVecsEë 2;
EigenImageElementsA9weightVecs, threshold, eigenImages, imgAvg=EE
H*Given a training set, determines if a test image matches any image in
the set and also returns the possible matches ranked best to worst*L
eigenImageRecognitionAimages_List,
testImage : I_Graphics
_ImageM, frac_ : 0.5E :=
ModuleA9eigenImages, imgAvg, dummy, weightVecs, testVec,
matchDistances, matchOrdering, match, thresholdVec, threshold=,
9weightVecs, threshold, eigenImages, imgAvg= =
eigenImageRecognitionElementsAimages, fracE@@1DD;
testVec = TableADotAimageVectorAtestImageE - imgAvg, eigenImages@@iDDE,
9i, 1, LengthAeigenImagesE=E;
matchDistances = EuclideanDistance@testVec, ÒD & êü weightVecs;
matchOrdering = Ordering@matchDistancesD;
matchDistances = matchDistancesAAmatchOrderingEE;
9matchDistances@@1DD § threshold,
InnerAList, matchOrdering, matchDistances, ListE=
E
366 | Chapter 8: Image Processing

H*This function is more efficient when many test images need to
be matched since it allows you to compute the eigenImageElements
once for the training set and reuse it for each test image.*L
eigenImageRecognitionAeigenImageElements_EigenImageElements,
testImage : I_Graphics
_ImageM, frac_ : 0.5E :=
ModuleA9eigenImages, imgAvg, dummy, weightVecs, testVec,
matchDistances, matchOrdering, match, thresholdVec, threshold=,
9weightVecs, threshold, eigenImages, imgAvg= = eigenImageElements@@1DD ;
testVec = TableADotAimageVectorAtestImageE - imgAvg, eigenImages@@iDDE,
9i, 1, LengthAeigenImagesE=E;
matchDistances = EuclideanDistance@testVec, ÒD & êü weightVecs;
matchOrdering = Ordering@matchDistancesD;
matchDistances = matchDistancesAAmatchOrderingEE;
9matchDistances@@1DD § threshold,
InnerAList, matchOrdering, matchDistances, ListE=
E
I use a training set of faces obtained from the Yale Faces Database. These images
were labeled “normal” in the database and were normalized manually in Photoshop
to center the faces and equalize image dimensions. 
In[293]:=
faces = Import@Ò, "Graphics"D & êü FileNamesAFileNameJoinA
9NotebookDirectory@D, "..", "images", "faces", "subject*.png"=EE;
Discussion
The solution is based on work performed by Matthew Turk and Alex Pentland at
the MIT Media Laboratory. They were inspired by earlier work by L. Sirovich and
M. Kirby for representing faces using PCA to efficiently encode face images. PCA is a
technique for identifying patterns in data by highlighting similarities and differences.
PCA is used to reduce high-dimensional data sets. It uses the most significant eigen-
vectors  (those  with  the  greatest  eigenvalues)  of  a  covariance  matrix  to  project
the  high-dimensional  data  on  a  smaller  dimensional  subspace  in  terms  of  the
eigenvectors. 
In the case of image recognition, you start with a training set of images normalized
to  the  same  dimensions.  For  this  example  I  used  images  from  the  Yale  Face
Database that I normalized to 180 × 240 pixels with the face centered. 
8.8 Image Recognition Using Eigenvectors (Eigenimages) | 367

In[294]:=
GraphicsGridAPartition@faces, 5D, ImageSize Ø MediumE
Out[294]=
The first step is to represent the images as vectors by flattening and normalizing the
raster data. The helper function imageVector is used for that purpose. The vectors
are then grouped into a matrix of 15 rows and 43,200 (180 × 240) columns and nor-
malized  by  subtracting  the  average  of  all  images  from  each  image.  If  the  solution
used  PCA  directly,  it  would  then  need  to  generate  a  43,200  ×  43,200  covariance
matrix  and  solve  for  the  43,200  eigensystem.  Clearly  this  brute  force  attack  is  in-
tractable.  Rather,  the  solution  takes  advantage  of  the  fact  that  in  a  system  where
the number of images (15) is much less than the number of data points (43,200),
most eigenvalues will be zero. Hence, it takes an indirect approach of computing the
eigenvectors of a smaller 15 × 15 matrix obtained from multiplying the image matrix
by its transpose as explained in Turk and Pentland. A fraction (half by default) of
these eigenvectors are then used to compute the eigenimages from the original image
data. This work is encapsulated in the function eigenImageElements, which returns
the eigenimages, the average image, and the computed eigenvectors of the smaller
matrix. This prevents the need to recompute these values in other functions. 
The function eigenImages is used to visualize the results. It returns a list of graphics
containing each of the eigenimages plus the average image. Here we show all 16 (15
eigen + 1 average) images by setting frac to 1. The ghostlike quality is a standard
feature of eigenimages of faces. Recalling that the lightest areas of a grayscale image
368 | Chapter 8: Image Processing

represent the largest magnitudes, you can see the elements of each image that are
emphasized. For example, the area around the cheek bones of the first image are the
most significant. 
In[295]:=
GraphicsGridAPartitionAeigenImages@faces, 0.95D, 5, 5, 81, 1<, Graphics@DE,
ImageSize Ø MediumE
Out[295]=
The eigenimages can be used as a basis for image recognition by using the product
of the eigenimages and the original images to form a vector of weights for each test
image. The weights represent the contribution of eigenimage to the original image.
Given these weight vectors, you can compute similar weights for an unknown image
8.8 Image Recognition Using Eigenvectors (Eigenimages) | 369

and use the Euclidean distance as a classification metric. If the distance is below a
certain threshold, then a match is declared. 
The test images are derived from some non-face images, some distortions of facial
images, and other poses of the faces in the training set. The function eigenImage-
Recognition returns a Boolean and a ranking list. The Boolean determines if the test
image fell in the threshold of the training set. The threshold is computed using the av
erage image distance. The ranking set ties the index to the image in the training set
and the distance in order of increasing distance. This means the first entry is the best
match to the training image.
In[296]:=
testFaces = Import@Ò, "Graphics"D & êü FileNamesAFileNameJoinA
9NotebookDirectory@D, "..", "images", "faces", "test", "*.png"=EE;
In[297]:=
GraphicsGridA
Partition@testFaces, 6, 6, 81, 1<, Graphics@DD, ImageSize Ø MediumE
Out[297]=
In[298]:=
eir = eigenImageRecognitionElements@facesD;
results = eigenImageRecognition@eir, ÒD & êü testFaces ;
The code that follows displays the best match in the training set that corresponds to
the test image. If the threshold was not met, an X is superimposed on the image. 
370 | Chapter 8: Image Processing

In[300]:=
GraphicsGridAPartition@If@Ò@@1DD, faces@@Ò@@2, 1, 1DDDD,
Graphics@8faces@@Ò@@2, 1, 1DDDD@@1DD, Red, Thick,
Line@88180, 1<, 81, 240<<D, Line@881, 1<, 8180, 240<<D<DD & êü
results, 6, 6, 81, 1<, Graphics@DD, ImageSize Ø MediumE
Out[300]=
These results show a false positive for the second image in the first row, the first im-
ages in the second and third rows, and the fourth image in the third row. There is a
false negative for the second image in the second row, meaning there was a correct
match  but  it  fell  below  the  threshold.  All  other  results  are  correct.  This  is  pretty
good considering the small size of the training set.
See Also
The images used here can be found at http://bit.ly/xlgx7 or http://www.mathematica
cookbook.com. The original Yale Face Database can be found at http://bit.ly/52lgvb.
The original research of paper Eigenfaces for Recognition by Matthew Turk and Alex
Pentland from the Journal of Cognitive Neuroscience (Volume 3, Number 1) can be
found at http://bit.ly/7OSSBw.
An excellent tutorial by Lindsay I. Smith on PCA can be found at http://bit.ly/6CJTWn.
8.8 Image Recognition Using Eigenvectors (Eigenimages) | 371


CHAPTER 9
Audio and Music Processing
Deep in the back of my mind is an unrealized sound
Every feeling I get from the street says it soon
could be found
When I hear the cold lies of the pusher,
I know it exists
It’s confirmed in the eyes of the kids, emphasized
with their fists
...
The music must change
For we’re chewing a bone
We soared like the sparrow hawk flied
Then we dropped like a stone
Like the tide and the waves
Growing slowly in range
Crushing mountains as old as the Earth
So the music must change
The Who, “Music Must Change”
9.0 Introduction
Audio  and  music  can  be  approached  in  three  different  ways  with  Mathematica:
(1) as traditional musical notes with associated pitch names and other specifications,
such  as  duration,  timbre,  loudness,  etc.;  (2)  as  abstract  mathematical  waveforms
that represent vibrating systems; and (3) as digitally represented sound~just think
of .wav and .aiff files. If nothing else, this chapter should hint at the ease with which
Mathematica can be put in the service of the arts. Let’s make some music!
Mathematica  allows  you  to  approach  music  and  sound  in  at  least  three  different
ways.  You  can  talk  to  Mathematica  about  musical  notes  such  as  "C"  or  "Fsharp".
You  can  directly  specify  other  traditional  concepts,  such  as  timbre  and  loudness,
with Mathematica’s Sound, SoundNote, and PlayList functions. You can ask Mathe-
matica to play analog waveforms. And you can ask Mathematica to interpret digital
sound samples.
373

9.1 Creating Musical Notes
Problem
You want to create musical notes corresponding to traditional musical notation. 
Solution
The Mathematica function SoundNote represents a musical sound. SoundNote uses
either a numerical convention, for which middle C is represented as zero, or it ac-
cepts strings like "C", "C3", or "Aflat4", where "A0" represents the lowest note on a
piano keyboard.
In[691]:=
Sound@SoundNote@0DD
Out[691]=
1 s
In[692]:=
Sound@SoundNote@"C"DD
Out[692]=
1 s
Discussion
SoundNote  assumes  you  want  to  play  a  piano  sound,  for  exactly  one  second,  at  a
medium  volume.  You  can  override  these  presets.  Here’s  a  loud  (SoundVolumeØ1),
short (0.125 second), guitar blast ("GuitarOverdriven").
374 | Chapter 9: Audio and Music Processing

In[693]:=
Sound@SoundNote@0, 0.125, "GuitarOverdriven", SoundVolume Ø 1DD
Out[693]=
0.13 s
9.2 Creating a Scale or a Melody
Problem
You want to create a sequence of notes, like a scale or single-note melody.
Solution
Sound can accept a list of notes, which it will play sequentially. Here is a whole-tone
scale specified to take exactly 1.5 seconds to play in its entirety.
In[694]:=
Sound@8SoundNote@0D, SoundNote@2D, SoundNote@4D,
SoundNote@6D, SoundNote@8D, SoundNote@10D, SoundNote@12D<, 1.5D
Out[694]=
1.5 s
9.2 Creating a Scale or a Melody | 375

Here’s an alternative syntax using Map (/@), which requires less typing and collects
the note specifications into a list.
In[695]:=
Sound@SoundNote@ÒD & êü 80, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 24<, 1.0D
Out[695]=
1 s
Here’s  a  randomly  generated  melody  composed  of  notes  from  an  AŸ  major  scale.
The duration of each note is specified as 0.125 second. The duration specification,
now  a  parameter  of  SoundNote  rather  than  an  overall  specification  of  the  entire
melody as in the previous examples, sets the stage for the next example.
In[696]:=
Sound@SoundNote@Ò, 0.125D & êü RandomChoice@
8"Aflat2", "Bflat2", "C3", "Dflat3", "Eflat3", "F3", "G3", "Aflat3"<, 10DD
Out[696]=
1.25 s
9.3 Adding Rhythm to a Melody
Problem
You need to specify a melody for which the notes have different rhythm values. 
Solution
Replace  the  0.125  specification  in  the  previous  example  with  other  values.  Since
you’re generating a random melody, why not generate random durations?
376 | Chapter 9: Audio and Music Processing

In[697]:=
Sound@
SoundNote@Ò, RandomChoice@80.125, 0.5, 0.75, 1.0<DD & êü RandomChoice@
8"Aflat2", "Bflat2", "C3", "Dflat3", "Eflat3", "F3", "G3", "Aflat3"<, 10DD
Out[697]=
3.25 s
Here, the weighting feature of RandomChoice is used to guarantee a preponderance of
short notes.
In[698]:=
Sound@
SoundNote@Ò, RandomChoice@810, 1, 1, 1< Ø 80.125, 0.5, 0.75, 1.0<DD & êü
RandomChoice@8"Aflat2", "Bflat2", "C3",
"Dflat3", "Eflat3", "F3", "G3", "Aflat3"<, 10DD
Out[698]=
2 s
9.4 Controlling the Volume
Problem
You would like to add some phrasing to your melody by controlling the volume.
Solution
Unlike duration, which is specified as a parameter to SoundNote, you control the vol-
ume  with  an  option  setting.  Pulling  everything  together  from  the  examples  above
9.4 Controlling the Volume | 377

and adding a randomized volume yields this funky guitar pattern. Anyone for a cup
of Maxwell House coffee? 
In[699]:=
Sound@SoundNote@Ò, 0.125, "GuitarMuted", SoundVolume Ø RandomReal@DD & êü
RandomChoice@820, 1, 1, 1, 1, 1< Ø 80, 2, 4, 7, 9, 12<, 56DD
Out[699]=
7 s
9.5 Creating Chords
Problem
You want to move beyond simple sequences of single notes to chord patterns.
Solution
To make a chord, give SoundNote a list of notes. For example, you can specify the C
major  triad  using  the  pitches  C,  E,  and  G  specified  as  a  list  of  numbers  {0,4,7}.
Don’t  confuse  making  chords  by  giving  SoundNote  a  list  of  notes  with  making
melodies by giving Sound a list of SoundNotes.
In[700]:=
Sound@SoundNote@80, 4, 7<DD
Out[700]=
1 s
378 | Chapter 9: Audio and Music Processing

9.6 Playing a Chord Progression
Problem
You want to make a chord progression.
Solution
This is the same as making melodies. Spell out the chords in your chord progression
as lists inside a list. Feed them into SoundNote using Map.
In[701]:=
Sound@SoundNote@Ò, 0.5D & êü
88"C3", "E3", "G3"<, 8"F3", "A3", "C4"<, 8"G3", "B3", "D4"<<D
Out[701]=
1.5 s
Here’s a popular pop song progression.
In[702]:=
Sound@SoundNote@Ò, 1D & êü 88"C3", "E3", "G3"<,
8"B2", "E3", "G3"<, 8"Bb2", "E3", "G3"<, 8"A2", "E3", "G3"<,
8"Aflat2", "Eflat3", "G3"<, 8"G2", "C3", "D3", "G3"<, 8"C3", "E3", "G3"<<D
Out[702]=
7 s
9.6 Playing a Chord Progression | 379

9.7 Writing Music with Traditional 
Chord Notation
Problem
You  want  to  specify  a  chord  progression  using  traditional  notation.  For  example,
you would like to write something like: 
In[703]:=
myProg = "C A7 d-7 FêG C";
or, using roman numerals as is common in jazz notation, 
In[704]:=
myJazzProgression = "<Eb>
I vi-9 II7êÒ9b13 ii-9 V7sus I";
Solution
Mathematica can deftly handle this task with its String manipulation routines and
its pattern recognition functions. First, decide which chord symbols will be allowed.
Here’s a list of jazz chords: Maj7/9, Majadd9, add9, Maj7#11, Maj7/13, Maj7/#5,
Maj7, Maj, -7b5, -7, -9, -11, min, 7/b913, 7/#9b13, 7/b9b13, 7/b9#11, 7/b5, 7/b9,
7/#9, 7/#11, 7/13, 7, 7/9, 7sus, and sus.
The rules below turn the chord names into the appropriate scale degree numbers in
the key of C. Later, as a second step, you’ll transpose these voicings to other keys.
In[705]:=
chordSpellingRules = 9"Maj7ê9" ß 80, 4, 7, 11, 14<, "Majadd9" ß 80, 2, 4, 7<,
"add9" ß 80, 2, 4, 7<, "Maj7êÒ11" ß 80, 4, 7, 11, 14, 18<,
"Maj7ê13" ß 82, 6, 9<, "Maj7êÒ5" ß 84, 8, 11<, "Maj7" ß 80, 4, 7, 11<,
"Maj" ß 80, 4, 7<,
H*lstead - added rule so "F" works*L
"" ß 80, 4, 7<,
"-7b5" ß 80, 3, 6, 10<, "-7" ß 80, 3, 7, 10<,
"-9" ß 80, 3, 7, 10, 14<, "-11" ß 80, 3, 7, 10, 14, 17<,
"min" ß 80, 3, 7<,
H*lstead - added rule so "D-" works*L
"-" ß 80, 3, 7<,
"7êb913" ß 81, 4, 9, 10<, "7êÒ9b13" ß 80, 3, 8<, "7êb9b13" ß 81, 4, 8, 10<,
"7êb9Ò11" ß 81, 4, 6, 10<, "7êb5" ß 80, 4, 6, 10<,
"7êb9" ß 81, 4, 7, 10<, "7êÒ9" ß 84, 10, 15<,
"7êÒ11" ß 80, 4, 7, 10, 14, 18<, "7ê13" ß 84, 9, 10, 14<, "7" ß 80, 4, 7, 10<,
"7ê9" ß 80, 4, 7, 10, 14<, "7sus" ß 80, 5, 7, 10<, "sus" ß 80, 5, 7, 12<=;
380 | Chapter 9: Audio and Music Processing

romanRoots = 8"bIII" ß 3, "III" ß 4, "bII" ß 1, "II" ß 2, "ÒII" ß 3,
"IV" ß 5, "ÒIV" ß 6, "bVII" ß 10, "VII" ß 11, "bVI" ß 8, "VI" ß 9,
"ÒVI" ß 10, "bV" ß 6, "V" ß 7, "ÒV" ß 8, "I" ß 0, "ÒI" ß 1<;
letterRoots = 8"C" ß 0, "CÒ" ß 1, "Db" ß 1, "D" ß 2, "DÒ" ß 3,
"Eb" ß 3, "E" ß 4, "F" ß 5, "FÒ" ß 6, "Gb" ß 6, "G" ß 7,
"GÒ" ß 8, "Ab" ß 8, "A" ß 9, "Bb" ß 10, "B" ß 11<;
roots = Join@romanRoots, letterRootsD
Out[708]=
8bIII ß 3, III ß 4, bII ß 1, II ß 2, ÒII ß 3, IV ß 5, ÒIV ß 6,
bVII ß 10, VII ß 11, bVI ß 8, VI ß 9, ÒVI ß 10, bV ß 6, V ß 7, ÒV ß 8,
I ß 0, ÒI ß 1, C ß 0, CÒ ß 1, Db ß 1, D ß 2, DÒ ß 3, Eb ß 3, E ß 4,
F ß 5, FÒ ß 6, Gb ß 6, G ß 7, GÒ ß 8, Ab ß 8, A ß 9, Bb ß 10, B ß 11<
Make a table by concatenating together each possible root and type. Then /. can 
be used to decode chord.
In[709]:=
compoundRules = TableAToUpperCase@lP1, 1T ~~ lP2, 1TD ->
8lP1, 2T, lP2, 2T<, 9l, TuplesA9roots, chordSpellingRules=E=E;
drules = Dispatch@compoundRulesD;
Now  create  a  function  for  converting  the  chord  string  into  a  progression
representation.
In[711]:=
progressionFromString@s_D :=
BlockA8su, ss<,
ss = StringSplit@s, WhitespaceD;
progression@First@ssD, ToUpperCase@Rest@ssDDDE
progressionAkey_, chords_E :=
BlockA9keyCenter, lh, rh=,
keyCenter = StringCasesAkey,
RegularExpression@"H?iL@a-zD+"DEP1T ê. letterRoots;
progressionAkey, chords, keyCenter,
TableA
8lh, rh< = Hchord ê. drulesL;
lh = lh + keyCenter - 24;
rh = rh + lh + 24;
Flatten@8lh, rh<D,
8chord, chords<EEE
And a function to play the progression.
In[713]:=
playProgressionAprogressionAk_, csyms_, kn_, chords_EE :=
Sound@SoundNote@Ò, 1D & êü chords, 5D
9.7 Writing Music with Traditional Chord Notation | 381

Let’s test it on a jazz progression.
In[714]:=
jazzS = "<Eb>
I vi-9 II7êÒ9b13 ii-9 V7sus I";
In[715]:=
jazzP = progressionFromStringAjazzSE
Out[715]=
progression@<Eb>, 8I, VI-9, II7êÒ9B13, II-9, V7SUS, I<,
3, 88-21, 3, 7, 10<, 8-12, 12, 15, 19, 22, 26<, 8-19, 5, 8, 13<,
8-19, 5, 8, 12, 15, 19<, 8-14, 10, 15, 17, 20<, 8-21, 3, 7, 10<<D
In[716]:=
playProgressionAjazzPE
Out[716]=
5 s
Let’s add some rhythm and volume.
In[717]:=
buffer = progressionFromStringAjazzSE@@4DD
Sound@MapIndexed@SoundNote@Ò, 81, 0.5, 0.5, 0.75, 0.25, 1<PSequence üü Ò2T,
SoundVolume Ø RandomReal@0.5, 1DD &, bufferDD
Out[717]=
88-21, 3, 7, 10<, 8-12, 12, 15, 19, 22, 26<, 8-19, 5, 8, 13<,
8-19, 5, 8, 12, 15, 19<, 8-14, 10, 15, 17, 20<, 8-21, 3, 7, 10<<
Out[718]=
4 s
382 | Chapter 9: Audio and Music Processing

Discussion
There’s a very unsatisfying feature to the result: the chords jump around in an unmu-
sical way. A piano player would typically invert the chords to keep the voicings cen-
tered  around  middle  C.  So  for  example,  when  playing  a  CMaj7  chord,  which  is
defined as {0,4,7,11} or {"C3","E3","G3","B3"}, a piano player might drop the top
two notes down an octave and play {-5,-1,0,4} or {"G2","B2","C3","E3"}. You can
use Mathematica’s Mod function to achieve the same result. Here the notes greater
than 6 {"F#3"} are transposed down an octave simply by subtracting 12 from them.
In[719]:=
buffer
Out[719]=
88-21, 3, 7, 10<, 8-12, 12, 15, 19, 22, 26<, 8-19, 5, 8, 13<,
8-19, 5, 8, 12, 15, 19<, 8-14, 10, 15, 17, 20<, 8-21, 3, 7, 10<<
Currently in the buffer, the nonbass notes are all positive, so this rule, which uses /;
n>0 as a condition, leaves the (negative) bass notes untouched while processing the
rest of the voicing.
In[720]:=
buffer ê. 9n_Integer ê; n > 0 :> Mod@n, 12, -5D=
Out[720]=
88-21, 3, -5, -2<, 8-12, 0, 3, -5, -2, 2<, 8-19, 5, -4, 1<,
8-19, 5, -4, 0, 3, -5<, 8-14, -2, 3, 5, -4<, 8-21, 3, -5, -2<<
In[721]:=
SoundASoundNote@Ò, 1D & êü I buffer ê. 9n_Integer ê; n > 0 :> Mod@n, 12, -5D=ME
Out[721]=
6 s
9.7 Writing Music with Traditional Chord Notation | 383

Here’s another progression showing all the steps in one place.
In[722]:=
buffer = progressionFromString@"<F> F Eb7 F C7 d- Bb7 C7 F"D@@4DD;
SoundA
SoundNote@Ò, 1D & êü I buffer ê. 9n_Integer ê; n > 0 :> Mod@n, 12, -5D=ME
Out[723]=
8 s
9.8 Creating Percussion Grooves
Problem
You want to make percussion sounds.
Solution
Mathematica has implemented 60 percussion instruments as specified in the Gen-
eral MIDI (musical instrument digital interface) specification.
Here the percussion instruments are listed in alphabetical order. Some of the names
are  not  obvious.  For  example,  there  is  no  triangle  or  conga,  instead  there’s
"MuteTriangle", "OpenTriangle", "HighCongaMute", "HighCongaOpen", and "LowConga".
In[724]:=
allPerc = 9"BassDrum", "BassDrum2", "BellTree", "Cabasa", "Castanets",
"ChineseCymbal", "Clap", "Claves", "Cowbell", "CrashCymbal",
"CrashCymbal2", "ElectricSnare", "GuiroLong", "GuiroShort", "HighAgogo",
"HighBongo", "HighCongaMute", "HighCongaOpen", "HighFloorTom",
"HighTimbale", "HighTom", "HighWoodblock", "HiHatClosed", "HiHatOpen",
"HiHatPedal", "JingleBell", "LowAgogo", "LowBongo", "LowConga",
"LowFloorTom", "LowTimbale", "LowTom", "LowWoodblock", "Maracas",
"MetronomeBell", "MetronomeClick", "MidTom", "MidTom2", "MuteCuica",
"MuteSurdo", "MuteTriangle", "OpenCuica", "OpenSurdo", "OpenTriangle",
"RideBell", "RideCymbal", "RideCymbal2", "ScratchPull", "ScratchPush",
"Shaker", "SideStick", "Slap", "Snare", "SplashCymbal", "SquareClick",
"Sticks", "Tambourine", "Vibraslap", "WhistleLong", "WhistleShort"=;
384 | Chapter 9: Audio and Music Processing

Here’s what each instrument sounds like. The instrument name is fed into SoundNote
where,  more  typically,  the  note  specification  should  be.  In  fact,  in  the  Standard
MIDI specification, each percussion instrument is represented as a single pitch in a
“drum” patch. So for example, "BassDrum" is C0, "BassDrum2" is C#0, "Snare" is D0,
and so on. Therefore, it makes sense for Mathematica to treat these instruments as
notes,  not  as  “instruments”  as  was  done  above  for  "Piano",  "GuitarMuted",  and
"GuitarOverDriven".
In[725]:=
Sound@SoundNote@Ò, 0.125D & êü allPercD
Out[725]=
7.5 s
Here’s a measure’s worth of closed hi-hat:
In[726]:=
Sound@SoundNote@Ò, 0.125D & êü Table@"HiHatClosed", 88<DD
Out[726]=
1 s
9.8 Creating Percussion Grooves | 385

And here’s something with a little more pizzazz. Both the choice of instrument and
volume are randomized.
In[727]:=
Sound@SoundNote@Ò, 0.125, SoundVolume Ø RandomReal@80.25, 1<DD & êü
Table@RandomChoice@8"HiHatOpen", "HiHatClosed", "HiHatPedal"<D, 816<DD
Out[727]=
2 s
9.9 Creating More Complex Percussion Grooves
Problem
You want to create a drum kit groove for a pop song using kick, snare, and hi-hat.
Solution
This task is the percussion equivalent of making chords, because on certain beats all
three instruments could be playing, on other beats only one instrument or possibly
none. Here’s the previous hi-hat pattern, played at a slower tempo.
In[728]:=
Sound@SoundNote@Ò, 0.25D & êü Table@"HiHatClosed", 88<DD
Out[728]=
2 s
386 | Chapter 9: Audio and Music Processing

Here’s a kick drum pattern. Use None as a rest indication.
In[729]:=
Sound@SoundNote@Ò, 0.25D & êü
8"BassDrum", None, None, "BassDrum", "BassDrum", None, None, None<D
Out[729]=
1.25 s
Here’s the snare drum backbeat. The display omits the leading rests, so the picture
is a little misleading. As soon as we integrate this with the hi-hat and kick drum,
everything will look correct.
In[730]:=
Sound@SoundNote@Ò, 0.25D & êü
8None, None, "Snare", None, None, None, "Snare", None<D
Out[730]=
1.75 s
Each  list  has  exactly  eight  elements,  so  we  can  use  Transpose  to  interlace  the
elements.
In[731]:=
groove = Transpose@8Table@"HiHatClosed", 88<D,
8"BassDrum", None, None, "BassDrum", "BassDrum", None, None, None<,
8None, None, "Snare", None, None, None, "Snare", None<<D
Out[731]=
88HiHatClosed, BassDrum, None<, 8HiHatClosed, None, None<,
8HiHatClosed, None, Snare<, 8HiHatClosed, BassDrum, None<,
8HiHatClosed, BassDrum, None<, 8HiHatClosed, None, None<,
8HiHatClosed, None, Snare<, 8HiHatClosed, None, None<<
9.9 Creating More Complex Percussion Grooves | 387

In[732]:=
SoundASoundNote@Ò, 0.25D & êü grooveE
Out[732]=
2 s
An  entire  tune  can  now  be  made  by  repeating  this  one-measure  groove  as  many
times as desired. 
In[733]:=
SoundASoundNote@Ò, 0.25D & êü FlattenATableA groove, 84<E, 1EE
Out[733]=
8 s
Discussion
Getting the curly braces just right in Mathematica’s syntax can be a little frustrating.
Without Flatten in the example above, the SoundNote function is confused by the
List-within-List results of the Table function. Consequently, you get no output.
In[734]:=
SoundASoundNote@Ò, 0.25D & êü TableA groove, 84<EE
Out[734]=
Sound@
8SoundNote@88"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", "BassDrum", None<,
8"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", None, None<<, 0.25`D,
SoundNote@88"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", "BassDrum", None<,
8"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", None, None<<, 0.25`D,
388 | Chapter 9: Audio and Music Processing

SoundNote@88"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", "BassDrum", None<,
8"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", None, None<<, 0.25`D,
SoundNote@88"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", "BassDrum", None<,
8"HiHatClosed", "BassDrum", None<, 8"HiHatClosed", None, None<,
8"HiHatClosed", None, "Snare"<, 8"HiHatClosed", None, None<<, 0.25`D<D
Furthermore, with a simple Flatten wrapped around the Table function, each hit is
treated individually; we lose the chordal quality of the drums hitting simultaneously.
Go back and notice that the correct idea is to remove just one layer of braces by us-
ing Flatten[ ... , 1 ].
In[735]:=
SoundASoundNote@Ò, 0.25D & êü FlattenATableA groove, 84<EEE
Out[735]=
23.5 s
9.10 Exporting MIDI files
Problem
You want to save your Mathematica expression as a standard MIDI file.
Solution
Mathematica can export any expression composed of Sound and SoundNote expres-
sions as a standard MIDI file. The rub, however, is that Mathematica does not im-
port MIDI files. So let’s create some utilities that at the very least let you look at the
guts of standard MIDI files.
9.10 Exporting MIDI files | 389

Here’s a simple phrase that gets exported as the file myPhrase.mid.
In[736]:=
myPhrase = Sound@
8SoundNote@0D, SoundNote@4D, SoundNote@7D, SoundNote@80, 4, 7, 12<D<D
Out[736]=
4 s
In[737]:=
ExportA"myPhrase.mid", myPhraseE
Out[737]=
myPhrase.mid
9.11 Playing Functions As Sound
Problem
You want to listen to the waveform generated by a mathematical function.
Solution
If you know how to plot a function in Mathematica:
In[738]:=
PlotASin@1000*2 p*tD, 8t, 0, 0.001<, ImageSize Ø 300E
Out[738]=
0.0002
0.0004
0.0006
0.0008
0.0010
-1.0
-0.5
0.5
1.0
390 | Chapter 9: Audio and Music Processing

You  can  play  a  function.  Play  uses  the  same  syntax  as  Plot.  However,  you  don’t
want to listen to 1/1000th of a second, which is what was plotted above, so specify
something like {t, 0, 1}.
In[739]:=
Play@Sin@1000*2 p*tD, 8t, 0, 1<D
Out[739]=
Discussion
Here are other crazy-sounding functions.
In[740]:=
Play@Sin@300 2 p t Exp@tDD, 8t, 0, 8<D
Out[740]=
In[741]:=
Play@H2 + Cos@40 t^2DL Sin@700 t^2D, 8t, 0, 10<D
Out[741]=
9.11 Playing Functions As Sound | 391

9.12 Adding Tremolo
Problem
You want to add tremolo.
Solution
“Tremolo” is the musical term for amplitude modulation. Here a 20 Hz signal modi-
fies the amplitude of a 1,000 Hz signal.
In[742]:=
PlotAH2 + Sin@20*2 p*tDL*Sin@1000*2 p *tD, 8t, 0, 0.1<, ImageSize -> 300E
Out[742]=
0.02
0.04
0.06
0.08
0.10
-3
-2
-1
1
2
3
And here, a 5 Hz signal modifies a 1,000 Hz signal.
In[743]:=
Play@H2 + Sin@5*2 p*tDL*Sin@1000*2 p *tD, 8t, 0, 1<D
Out[743]=
392 | Chapter 9: Audio and Music Processing

9.13 Adding Vibrato
Problem
You want to add vibrato.
Solution
Vibrato is frequency modulation. Notice that the sine wave alternates between re-
gions of compression and expansion.
In[744]:=
PlotAHSin@H1 + Sin@250*2 p*tDL*1000*2 p *tDL,
8t, 0, 0.010<, ImageSize Ø 400, AspectRatio Ø 0.5E
Out[744]=
0.002
0.004
0.006
0.008
0.010
-1.0
-0.5
0.5
1.0
Here the parameters are adjusted for listening.
In[745]:=
Play@HSin@H1 + 0.002 Sin@5*2 p*tDL*1000*2 p *tDL, 8t, 0, 1<D
Out[745]=
9.13 Adding Vibrato | 393

Why not put the two modulations together: tremolo and vibrato?
In[746]:=
Play@H2 + Sin@5*2 p*tDL*
Sin@H1 + 0.002 Sin@5*2 p*tDL*1000*2 p *tD, 8t, 0, 1<D
Out[746]=
9.14 Applying an Envelope to a Signal
Problem
You want to apply an envelope to your signal.
Solution
The  Mathematica  function  Piecewise  is  the  perfect  tool  for  creating  an  envelope.
Here is the popular attack-decay-sustain-release (ADSR) envelope.
In[747]:=
PlotAPiecewise@8
86 t, t < 1<,
86 - 5 Ht - 1L, t < 2<,
81, t < 4<,
81 - 0.5 Ht - 4L, t < 6<
<D,
8t, 0, 6<,
PlotStyle Ø AbsoluteThickness@2D,
ImageSize Ø 8300, 150<, AspectRatio Ø 0.5
E
394 | Chapter 9: Audio and Music Processing

Out[747]=
1
2
3
4
5
6
1
2
3
4
5
6
Sine waves are typically represented as amplitude * sine (wt). You can simply substi-
tute the entire Piecewise[] envelope for amplitude.
In[748]:=
PlotA
Piecewise@8
86 t, t < 1<,
8-5 Ht - 1L + 6, t < 2<,
81, t < 4<,
8-0.5 Ht - 4L + 1, t < 6<<
D*Sin@6*2 p*tD,
8t, 0, 6<,
PlotRange Ø All
E
Out[748]=
1
2
3
4
5
6
-6
-4
-2
2
4
6
9.14 Applying an Envelope to a Signal | 395

Listen!
In[749]:=
Play@
Piecewise@8
8H6 tL, t < 1<,
8H-5 Ht - 1L + 6L, t < 2<,
8H1L, t < 4<,
8H-0.5 Ht - 4L + 1L, t < 6<
<D*Sin@1000*2 p*tD,
8t, 0, 6<
D
Out[749]=
Discussion
Calculating the envelope functions for the four regions is not as hard as you might
expect. Perhaps you remember the equation for a straight line: y = m x + b, where m
is the slope of the line and b is the y-intercept. Here is a line with a slope of |2 that
intercepts the y-axis at y = 4, so its equation is y = |2x + 4.
In[750]:=
PlotA-2 x + 4, 8x, 0, 2<, PlotRange Ø 880, 4<, 8-1, 4<<,
PlotStyle Ø 9AbsoluteDashing@84, 4<D, 8Thick, Black<=E
Out[750]=
1
2
3
4
-1
0
1
2
3
4
396 | Chapter 9: Audio and Music Processing

If this were the function for the second portion of the envelope, the decay portion,
you would need to shift this line to the right. You can shift the line to the right sim-
ply by replacing x with (x | displacement). In general, the template for creating the
equations  for  the  Piecewise  functions  will  be:  y  =  m  (x  |  displacement)  +  initial
value  of  segment.  Notice  that  what  was  at  first  the  y-intercept  is  now  the  “initial
value of the segment.” The line here is shifted two units to the right, and the new
equation is y = |2 (x | 2) + 4. If we simplify the right side, the equation becomes y =
|2x + 8. This line has the same |2 slope but would intercept the y-axis at y = 8 if we
were to extend the line to the left.
In[751]:=
PlotA-2 Hx - 2L + 4, 8x, 0, 4<, PlotRange Ø 880, 4<, 8-1, 4<<,
PlotStyle Ø 9AbsoluteDashing@84, 4<D, 8Thick, Black<=E
Out[751]=
1
2
3
4
-1
0
1
2
3
4
9.15 Exploring Alternate Tunings
Problem
You  want  to  explore  different  partitions  of  the  musical  scale  and  alternate  instru-
ment tunings.
Solution
Modern Western music uses tempered tuning, which is a slight compromise to the vi-
brations of the natural world, or at least the perfection of the natural world as the
Greeks described it 3,000 years ago. The ancient Greeks (and even earlier, the Babylo-
nians) noticed that when objects vibrate in simple, integer ratios to each other, the
resulting sound is pleasant. The simple ratio of 2:1 is so pleasant that we perceive it
as an equivalence. When two notes vibrate in a ratio of 2:1, we say they have the
same pitch but are in different octaves. The history of music has been the history of
partitioning the octave. 
9.15 Exploring Alternate Tunings | 397

The first obvious division of the octave is created by the next simplest ratio, a 3:1 ra-
tio. Consider the following schematic of a vibrating string. The only requirement on
the string is that its endpoints remain fixed. The string can vibrate in many different
modes, as shown in the first column. Each mode has a characteristic number of still
points,  called  “nodes,”  that  appear  symmetrically  along  the  length  of  the  string.
Each mode also has a characteristic rate of vibration, which is a simple integer multi-
ple to the lowest fundamental frequency. Notice that three out of the first four har-
monics  are  octave  equivalences.  The  third  harmonic,  situated  between  the  second
and  fourth  harmonics,  has  a  ratio  of  3:2  to  the  second  harmonic  and  3:4  to  the
fourth. These were the kinds of simple ratios that appealed to the Greeks.
In[752]:=
SetOptionsAPlot, ImageSize Ø 8150, 30<, AspectRatio Ø 0.2,
Ticks Ø None, PlotStyle Ø AbsoluteThickness@2DE;
StyleBGridB:
8"mode", "harmonic", "musical interpretation", "ratio to fundamental"<,
:Plot@Sin@400 µ 2 p*tD, 8t, 0, 0.005<D, "4th", "octave", "
4
1
">,
:Plot@Sin@300 µ 2 p*tD, 8t, 0, 0.005<D, "3rd", "fifth", "
3
1
">,
:Plot@Sin@200 µ 2 p*tD, 8t, 0, 0.005<D, "2nd", "octave", "
2
1
">,
9PlotASin@100 µ 2 p*tD, 8t, 0, 0.005<, PlotRange Ø 8-1, 1<E,
"1st", "tonic", "1"=
>,
Frame Ø All,
Background Ø 8White, 8White, White, White, White, White<<
F, 14, "Label"
F
Out[753]=
mode
harmonic musical interpretation ratio to fundamental
4th
octave
4
1
3rd
fifth
3
1
2nd
octave
2
1
1st
tonic
1
398 | Chapter 9: Audio and Music Processing

Out[90]=
mode
harmonic musical interpretation ratio to fundamental
4th
octave
4
1
3rd
fifth
3
1
2nd
octave
2
1
1st
tonic
1
mode
harmonic musical interpretation ratio to fundamental
4th
octave
4
1
3rd
fifth
3
1
2nd
octave
2
1
1st
tonic
1
The following keyboard shows how a successive application of the 3:2 ratio can be
used to build the entire chromatic scale. After 12 applications of this 3:2 ratio, every
note of the modern chromatic scale has been visited once and we are returned to
starting pitch~sort of!
In[754]:=
WithA9y1 = -1.6, y2 = 6.5=,
whiteKeys = TableARectangle@8x, 0<, 8x + 1, 5<D, 8x, 0, 49<E;
blackKeys = TableARectangle@8octave + x + 0.65, 2<, 8octave + x + 1.3, 5<D,
8x, 80, 1, 3, 4, 5<<, 8octave, 0, 42, 7<E;
sequential = SortAFlattenüJoinAwhiteKeys, blackKeysEE;
highlights = sequentialPTable@n, 8n, 1, 85, 7<DT;
keyboard = 9White, EdgeForm@8Black, AbsoluteThickness@1D<D, whiteKeys,
Gray, highlights, Black, blackKeys, Gray, highlightsP7 ;; 11T=;
GraphicsA9keyboard,
StyleA9TextA"1", 90.5, y1=E, TextA3ê2, 94.5, y1=E, TextAH3ê2L2,
98.5, y1=E, TextAH3ê2L3, 912.5, y1=E, TextAH3ê2L4, 916.5, y1=E,
TextAH3ê2L5, 920.5, y1=E, TextAH3ê2L6, 925, y2=E,
TextAH3ê2L7, 929, y2=E, TextAH3ê2L8, 933, y2=E,
TextAH3ê2L9, 937, y2=E, TextAH3ê2L10, 941, y2=E,
TextAH3ê2L11, 945.5, y1=E, TextAH3ê2L12, 949.5, y1=E=, 9E
=, ImageSize Ø 8550, 200<EE
9.15 Exploring Alternate Tunings | 399

Out[754]=
1
3 ê
2
9 ê
4
27 ê
8
81 ê
16
243 ê
32
729 ê
64
2187 ê
128
6561 ê
256
19683 ê
512
59049 ê
1024
177147 ê
2048
531441 ê
4096
There’s a problem: H3 ê 2L12 represents the C seven octaves above the starting C and
should equal a C with a frequency ratio of 27 = 128, but H3 ê 2L12 equals 129.75. The
equal temperament solution to this problem is to distribute this discrepancy equally
over all the intervals. In other words, in equal temperament, every interval is made
slightly, and equally, “out of tune.” Johann Sebastian Bach composed a series of key-
board pieces in 1722 called “The Well-Tempered Clavier” to demonstrate that this
compromise was basically imperceptible and had no negative impact on the beauty
of the music. 
Mathematically, equal temperament means that the frequency of each pitch should
have the same ratio to its immediate lower neighbor’s frequency. Call this ratio a.
Then it must be the case that if a chromatic scale, which contains 12 pitches, takes
you from some frequency to twice that frequency, then a12= 2. So the ratio of a semi-
tone in equal temperament is 1.0596.
In[755]:=
a =
2.0
12
Out[755]=
1.05946
Out[92]=
1.05946
1.05946
However,  now  that  we  have  the  octave  in  perfect  shape,  every  other  interval  is
slightly “wrong”~or at least wrong according to the manner in which the Greeks
were trying to make their intervals. So for example, a Pythagorean fifth, which is 3/2
= 1.5, is slightly flat in equal temperament (the musical interval of a fifth is com-
posed of seven half-steps).
In[756]:=
a7
Out[756]=
1.49831 7
In[757]:=
1.498307
Out[757]=
1.49831
Now that we’ve gone through the basics of tuning, how do you use Mathematica to
explore alternate tunings?
400 | Chapter 9: Audio and Music Processing

Discussion
As explained above, tuning instruments in the modern Western world is based on di-
viding  the octave  into  12  equal  segments.  If  the  ratio  of  the  semitone  C  to  C#  is
called a, then the ratio of the octave from C3 to C4 is a12  and should equal 2.0.
Therefore you can calculate a to be the 12th root of 20. 
In[758]:=
a =
2.0
12
Out[758]=
1.05946
Out[95]=
1.05946
1.05946
Here’s the equal-tempered chromatic scale, sometimes referred to as 12-TET (twelve-
tone equal temperament):
In[759]:=
TET = TableASinA440.0*an *2 p*tE, 8n, 0, 12<E
Out[759]=
8Sin@2764.6 tD, Sin@2928.99 tD, Sin@3103.16 tD,
Sin@3287.68 tD, Sin@3483.18 tD, Sin@3690.3 tD,
Sin@3909.74 tD, Sin@4142.22 tD, Sin@4388.53 tD,
Sin@4649.49 tD, Sin@4925.96 tD, Sin@5218.87 tD, Sin@5529.2 tD<
Out[96]=
8Sin@2764.6 tD, Sin@2928.99 tD, Sin@3103.16 tD,
Sin@3287.68 tD, Sin@3483.18 tD, Sin@3690.3 tD,
Sin@3909.74 tD, Sin@4142.22 tD, Sin@4388.53 tD,
Sin@4649.49 tD, Sin@4925.96 tD, Sin@5218.87 tD, Sin@5529.2 tD<
8Sin@2764.6 tD, Sin@2928.99 tD, Sin@3103.16 tD,
Sin@3287.68 tD, Sin@3483.18 tD, Sin@3690.3 tD,
Sin@3909.74 tD, Sin@4142.22 tD, Sin@4388.53 tD,
Sin@4649.49 tD, Sin@4925.96 tD, Sin@5218.87 tD, Sin@5529.2 tD<
9.15 Exploring Alternate Tunings | 401

In[760]:=
ShowAPlay@Ò, 8t, 0, 0.25<D & êü TETE
Out[760]=
The equal-tempered major scale is
In[761]:=
ShowAPlay@Ò, 8t, 0, 0.25<D & êü TETP1 + 80, 2, 4, 5, 7, 9, 11, 12<TE
Out[761]=
402 | Chapter 9: Audio and Music Processing

9.16 Importing Digital Sound Files
Problem
You want to import a digital sound file, for example, a WAV or AIFF file.
Solution
Mathematica imports many standard file formats. Both AIFF and WAV are in the
list.
In[762]:=
$ImportFormats
Out[762]=
93DS, ACO, AIFF, ApacheLog, AU, AVI, Base64, Binary, Bit, BMP, Byte, BYU,
BZIP2, CDED, CDF, Character16, Character8, Complex128, Complex256,
Complex64, CSV, CUR, DBF, DICOM, DIF, Directory, DXF, EDF, ExpressionML,
FASTA, FITS, FLAC, GenBank, GeoTIFF, GIF, Graph6, GTOPO30, GZIP,
HarwellBoeing, HDF, HDF5, HTML, ICO, Integer128, Integer16, Integer24,
Integer32, Integer64, Integer8, JPEG, JPEG2000, JVX, LaTeX, List, LWO,
MAT, MathML, MBOX, MDB, MGF, MMCIF, MOL, MOL2, MPS, MTP, MTX, MX, NB,
NetCDF, NOFF, OBJ, ODS, OFF, Package, PBM, PCX, PDB, PDF, PGM, PLY, PNG,
PNM, PPM, PXR, QuickTime, RawBitmap, Real128, Real32, Real64, RIB,
RSS, RTF, SCT, SDF, SDTS, SDTSDEM, SHP, SMILES, SND, SP3, Sparse6, STL,
String, SXC, Table, TAR, TerminatedString, Text, TGA, TIFF, TIGER,
TSV, UnsignedInteger128, UnsignedInteger16, UnsignedInteger24,
UnsignedInteger32, UnsignedInteger64, UnsignedInteger8, USGSDEM, UUE,
VCF, WAV, Wave64, WDX, XBM, XHTML, XHTMLMathML, XLS, XML, XPORT, XYZ, ZIP=
Using the "Data" specification will save you the aggravation of decoding the syntax
of the imported data. Don’t forget the semicolon, which prevents Mathematica from
listing all the sample points. The easiest way to access a file is to type Import[  ],
place your cursor between the empty brackets, choose File... from the Insert Menu,
navigate in the dialog box to the file you want to open.
In[763]:=
file = FileNameJoinA9NotebookDirectory@D , "..", "data", "JCK_01.aif"=E;
data = FlattenüImport@file, "Data"D;
You’ll need to know the sample rate and whether this file is a mono or stereo, so do
a second Import on the same file but specify "Options". 
In[765]:=
Import@file, "Options"D
Out[765]=
9AudioChannels Ø 1, AudioEncoding Ø Integer16, SampleRate Ø 48 000=
If you simply wanted to play the file, specify "Sound" as the second parameter.
In[766]:=
snd = Import@file, "Sound"D;
9.16 Importing Digital Sound Files | 403

This returns a Sound object.
In[767]:=
snd êê Head
Out[767]=
Sound
And can be played like so:
In[768]:=
snd
Out[768]=
Discussion
Sound files can be huge, and as such, become difficult to work with. 
In[769]:=
Length@dataD
Out[769]=
1396853
Here’s a quick way to get an overview of a sound file. Mathematica is being asked to
display  every  thousandth  sample  point.  You  can  easily  see  there  are  a  handful  of
bursts of energy.
In[770]:=
SetOptionsAListLinePlot,
ImageSize Ø 8500, 150<, AspectRatio Ø 0.25, PlotRange Ø AllE;
In[771]:=
SetOptionsAListPlot, ImageSize Ø 8500, 150<,
AspectRatio Ø 0.25, PlotRange Ø AllE;
In[772]:=
ListLinePlot@dataP1 ;; 1396000 ;; 1000TD
Out[772]=
200
400
600
800
1000
1200
1400
-0.3
-0.2
-0.1
0.1
0.2
0.3
404 | Chapter 9: Audio and Music Processing

Focus on the three wavelets between 900 and 1,300.
In[773]:=
ListLinePlot@dataP900000 ;; 1300000TD
Out[773]=
“Yes we can; yes we can; yes we can!”
In[774]:=
Sound@SampledSoundList@dataP900000 ;; 1 300 000T, 48 000DD
Out[774]=
9.17 Analyzing Digital Sound Files
Problem
You want to do a Fourier analysis on a sound file. Fourier analysis is a means of in-
vestigating  the  energy  in  a  signal.  Specifically,  Fourier  analysis  will  report  on  the
energy spectrum of a signal versus frequency. The mathematics behind Fourier analy-
sis is quite sophisticated, but armed with just a few principles, you can put Mathe-
matica’s Fourier tools to work for you. 
Solution
Typically you’ll start with a digitized signal. The sampling rate will determine the
highest  frequency  that  can  be  investigated.  This  highest  frequency  is  called  the
Nyquist frequency and is always exactly one half the sampling rate. For this “Yes we
can!” sample, which was digitized at 48 KHz, the highest frequency is 24 KHz. (It’s
9.17 Analyzing Digital Sound Files | 405

not coincidental that this frequency is slightly greater than the limits of human hear-
ing.) Notice the plot is symmetric about the Nyquist frequency.
The number of sample points used in any analysis is also critical. Here exactly one
second of audio, that is, 48,000 sample points, is being analyzed. The 48,000 points
from the time domain yield 48,000 points in the frequency domain, but as you can
see, the right side of the plot, between points 24,000 and 48,000, is just a mirror du-
plication of the points between 0 and 24,000. This is an artifact of the underlying
mathematics, and there is no additional information in this half of the plot.
In[775]:=
ListLinePlot@Abs@Fourier@dataP900 000 ;; 900 000 + 48 000TDDD
Out[775]=
10000
20000
30000
40000
0.1
0.2
0.3
0.4
0.5
0.6
0.7
Since this is speech, you can focus on the first 2,000 points, which correspond to
frequencies 0 to 2,000 Hz. Later you’ll see that 2,000 points of a Fourier analysis
doesn’t always mean frequencies 0 through 2,000 Hz. It does in this case because
you started with 48,000 sample points in the time domain that equals the sampling
rate and created a one-to-one relationship between data points and frequencies in
the frequency domain. You can see that this speaker has four significant frequency
resonances  to  his  voice  at  approximately  150  Hz,  300  Hz,  490  Hz,  and  700  Hz.
These resonances are known as formants. Notice, the Ticks option customized the la-
beling of the x-axis.
In[776]:=
ListLinePlot@Abs@Fourier@dataP900 000 ;; 900 000 + 48 000TDDP1 ;; 2000T,
Ticks Ø 88150, 300, 490, 700, 1000, 1500, 2000<, Automatic<D
Out[776]=
150
300
490
700
1000
1500
2000
0.1
0.2
0.3
0.4
0.5
0.6
0.7
Typically, when analyzing voice, one second is too long of a sample. Just think how
many syllables you utter in one second of normal speech. A much more appropriate
length  would  be  1/10  or  1/20  or  even  1/30  of  a  second.  You  can  easily  identify
406 | Chapter 9: Audio and Music Processing

various  phonemes  of  “yes  we  can”  in  the  plot  below:  the  “yeh”  and  “sss”  of  the
“yes,” the singular vowel sound of “we,” and the hard “c” and “an” of “can.” 
In[777]:=
ListLinePlotAdata@@925000 ;; 925 000 + 96 000DD,
PlotRange -> All, AxesOrigin Ø 80, -0.4<E
Out[777]=
20000
40000
60000
80000
-0.2
0.0
0.2
0.4
Here’s the “we,” which is very homogeneous.
In[778]:=
ListLinePlotAdata@@955000 ;; 955 000 + 9600DD, PlotRange -> AllE
Out[778]=
2000
4000
6000
8000
-0.2
-0.1
0.1
0.2
0.3
You’re now looking at 9,600 sample points (9,600/48,000 = 1/5 sec) in the time do-
main,  so  each  point  in  the  frequency  domain  represents  48,000/9,600  =  5  Hz.
There’s a direct trade-off between using as few sample points as possible to narrow
the analysis to a single phoneme, versus sampling enough points to ascertain a desired
precision in the frequency domain. 
In[779]:=
pts = Abs@Fourier@data@@955000 ;; 955 000 + 9600DDDD@@1 ;; 100DD;
ListPlotApts, Joined Ø True,
Epilog Ø 8MapIndexed@Point@8Sequence üü Ò2, Ò<D &, ptsD<,
Ticks Ø 8Table@8n, 5*n<, 8n, 0, 100, 10<D, Automatic<,
PlotRange Ø All, Filling Ø AxisE
Out[780]=
9.17 Analyzing Digital Sound Files | 407

Here, half as many points (4,800) sampled from the same region focuses our analysis
in the time domain, but each sample point now represents 10 Hz. Perhaps we’re los-
ing some detail in the 150|200 Hz range, as well as the 300|350 Hz range?
In[781]:=
pts = Abs@Fourier@data@@955000 ;; 955 000 + 4800DDDD@@1 ;; 100DD;
ListPlotApts, Joined Ø True,
Epilog Ø 8MapIndexed@Point@8Sequence üü Ò2, Ò<D &, ptsD<,
Ticks Ø 8Table@8n, 10*n<, 8n, 0, 100, 10<D, Automatic<,
PlotRange Ø All, Filling Ø AxisE
Out[782]=
9.18 Slicing a Sample
Problem
You want a Fourier analysis over time.
Solution
You can partition the data into 1/30 of a second slices and do an analysis on each
slice. Each sample point in the frequency domain will be 30 Hz, which is “wider”
than  the  previous  examples,  but  the  precision  in  the  time  domain  will  more  than
make up for it.
In[783]:=
ffts = Table@Fourier@dataPt ;; t + 1600 - 1TD,
8t, 900000, 900000 + 1600*250, 1600<D;
Take just the lowest 100 frequency bands, frequencies 0|3,000 Hz.
In[784]:=
lines = Abs@fftsPAll, 1 ;; 100TD;
With Mathematica’s Graphics3D primitives, you can make this waterfall-style chart,
where time is left to right across the front, and frequency is front to back.
In[785]:=
Graphics3DA
Line@ÒD & êü MapIndexed@List@Sequence üü Ò2, ÒD &, lines , 8-1<D,
PlotRange Ø 880, 250<, 80, 60<, 80, 4<<, BoxRatios Ø 84, 2, 1<,
ImageSize Ø 500, SphericalRegion Ø True,
ViewPoint Ø 81, -1, 0.75<, Boxed Ø TrueE
408 | Chapter 9: Audio and Music Processing

Out[785]=
ListLinePlot accomplishes the same thing but interpolates the individual lines into
surfaces.
In[786]:=
ListPlot3DAlines,
Mesh Ø None, PlotRange Ø All, ImageSize Ø 500,
SphericalRegion Ø True, ViewPoint Ø 8-1, 1, 0.75<,
Boxed Ø False, ColorFunction Ø IGrayLevel@1 - Ò3D &M,
Ticks Ø 8Function@8min, max<, Table@8i, i*30<, 8i, 0, Floor@maxD, 10<DD,
Function@8min, max<,
Table@8i, i*0.033 êê Round<, 8i, 0, Floor@maxD, 30<DD, Automatic<
E
Out[786]=
9.18 Slicing a Sample | 409

Discussion
Now  that  you’ve  seen  the  previous  3D  displays,  perhaps  these  contour  plots  will
make immediate sense to you. These are bird’s-eye views of the 3D plots. You can
really finesse these plots to bring out the details. Look at the color versions provided
in the online version of this book.
In[787]:=
ListContourPlotA
TransposeüTable@Abs@Fourier@dataPn ;; n + 1600 - 1TDDP1 ;; 120T,
8n, 900000, 900000 + 1600*250, 1600<D,
Contours Ø 20, ContourShading Ø None, ImageSize Ø 8500, 300<,
AspectRatio Ø 0.5, Ticks Ø 8None, None<,
FrameTicks Ø 8Automatic,
Function@8min, max<, Table@8i, i*15<, 8i, 0, max, 20<DD<E
Out[787]=
Tweaking  the  Contours  and  ContourShading  options  prevent  the  white-outs  in  the
peak regions.
In[788]:=
ListContourPlotA
TransposeüTable@Abs@Fourier@dataPn ;; n + 1600 - 1TDDP1 ;; 120T,
8n, 900000, 900000 + 1600*250, 1600<D,
Contours Ø FunctionA8min, max<, Range@0, max, 0.25DE,
ContourShading Ø TableAGrayLevel@1 - nê16.D, 8n, 16<E, PlotRange Ø All,
ImageSize Ø 8800, 400<, AspectRatio Ø 0.5E
Out[788]=
410 | Chapter 9: Audio and Music Processing

A Spectrograph
ArrayPlot is another perfect tool to display the results. ArrayPlot will automatically
scale the results such that the greater the energy content in the frequency domain,
the darker the plot. Frequency runs across the page, as shown previously in Recipe
9.17, whereas the individual slices run down the page.
In[789]:=
SetOptionsAArrayPlot, ImageSize Ø 8600, 200<, AspectRatio Ø 0.25E;
In[790]:=
ArrayPlot@Table@Abs@Fourier@dataPn ;; n + 1600 - 1TDDP1 ;; 100T,
8n, 900000, 900000 + 1600*250, 1600<D,
FrameTicks Ø 8Automatic, Table@8n, 30*n<, 8n, 0, 100, 5<D<D
Out[790]=
0
150 300 450 600 750 900 10501200135015001650180019502100225024002550270028503000
50
100
150
200
250
You can improve on ArrayPlot’s formatting. Convention wants time to run left to
right across the page and frequency to run bottom to top. Transpose will reverse the
axes, but you’ll also need DataReversedØTrue to make time run left to right.
In[791]:=
ArrayPlot@TransposeüTable@Abs@Fourier@dataPn ;; n + 1600 - 1TDDP1 ;; 120T,
8n, 900000, 900000 + 1600*250, 1600<D,
FrameTicks Ø 8Table@8n, 30*n<, 8n, 0, 100, 10<D,
Table@8n, 0.03333*n êê Round<, 8n, 0, 250, 30<D<, DataReversed Ø TrueD
Out[791]=
0
1
2
3
4
5
6
7
8
0
300
600
900
1200
1500
1800
2100
2400
2700
3000
You could set a threshold and display in black and white.
In[792]:=
ArrayPlot@TransposeüTable@Abs@Fourier@dataPn ;; n + 1600 - 1TDDP1 ;; 120T,
8n, 900000, 900000 + 1600*250, 1600<D ê.
8_Real?HÒ >= 0.3 &L ß 1, _Real?HÒ < 0.3 &L ß 0<,
9.18 Slicing a Sample | 411

In[792]:=
FrameTicks Ø 8Table@8n, 30*n<, 8n, 0, 100, 10<D,
Table@8n, 0.03333*n êê Round<, 8n, 0, 250, 30<D<, DataReversed Ø TrueD
Out[792]=
0
1
2
3
4
5
6
7
8
0
300
600
900
1200
1500
1800
2100
2400
2700
3000
Or, you could zoom in and look more closely at the lower frequencies.
In[793]:=
ArrayPlot@TransposeüTable@Abs@Fourier@dataPn ;; n + 1600 - 1TDDP1 ;; 30T,
8n, 900000, 900000 + 1600*250, 1600<D,
FrameTicks Ø 8Table@8n, 30*n<, 8n, 0, 30, 5<D,
Table@8n, 0.03333*n êê Round<, 8n, 0, 250, 30<D<, DataReversed Ø TrueD
Out[793]=
0
1
2
3
4
5
6
7
8
0
150
300
450
600
750
900
412 | Chapter 9: Audio and Music Processing

CHAPTER 10
Algebra
When a problem comes along
You must whip it
Before the cream sits out too long
You must whip it
When something’s going wrong
You must whip it
Now whip it
Into shape
Shape it up
Get straight
Go forward
Move ahead
Try to detect it
It’s not too late
To whip it
Whip it good
Devo, “Whip It”
10.0 Introduction
Algebra can be divided into elementary algebra and abstract algebra. Elementary algebra
is the kind we all learned in high school. Mathematica is well equipped to solve prob-
lems in elementary algebra, and many of the recipes in this chapter show you how to
leverage these features. Mathematica does not presently have deep support for ab-
stract algebra, which is concerned with constructs such as groups, rings, and fields.
However, there are third-party packages available for exploring abstract algebra, and
I provide references for those.
Mathematica’s  ability  to  do  algebraic  manipulation  is  important  for  two  reasons.
First, many problems, although conceptually easy to solve by hand, are tedious, and
it makes sense to have Mathematica relieve you of this drudgery. Recipe 10.1 shows
you  how  to  solve  algebraic  equations;  Recipe  10.2  shows  how  to  work  backward
413

from a root to a polynomial. However, helping you solve algebraic equations is not
the most important part of this chapter. Rather, you will often find that Mathemat-
ica will not automatically give you an answer in the form you desire. Knowing how
to coax expressions into the desired form is an important skill in your day-to-day use
of Mathematica. Recipe 10.3 is geared to helping you gain proficiency in this area. It is easy
enough to create a polynomial by typing input into Mathematica, but if you want to
generate a polynomial of a specific form, Recipe 10.4 will show you how. On the other
hand,  if  you  need  to  break  up  a  polynomial into  parts  to  perform  some  low-level
manipulations, you will want to look at Recipe 10.5. Diving a bit deeper into abstrac-
tion, Recipe 10.6 investigates division and related operations on polynomials.
See Also
Allen C. Hibbard and Kenneth M. Levasseur have developed “Exploring Abstract Al-
gebra with Mathematica” (http://bit.ly/CHT9O), which can be freely downloaded
after registering. 
10.1 Solving Algebraic Equations
Problem
You want to solve an algebraic equation for its unknowns. 
Solution
Use Solve with expressions of the form left-hand-side == right-hand-side and the
unknown  variable  (or  variables)  provided  as  the  second  argument.  Results  are  re-
turned as rules.
In[2]:=
Solve@x^2 - 2 x - 3 ã 0, xD
Out[2]:=
88x Ø -1<, 8x Ø 3<<
Solve takes either a single expression, as above, or a list of expressions or several ex-
pressions linked with &&. As you would expect, solutions can be found in symbolic
form.
In[3]:=
SolveA9a x + 2 y ã 7, 3 b x - y ã 1=, 9x, y=E
Out[3]=
;;x Ø
9
a + 6 b
, y Ø -
a - 21 b
a + 6 b
??
In[4]:=
SolveAa x - 2 y ã 7 && 2 b x + y ã 0, 9x, y=E
Out[4]=
;;x Ø
7
a + 4 b
, y Ø -
14 b
a + 4 b
??
414 | Chapter 10: Algebra

Discussion
Solve  works  best  with  linear  and  polynomial  equations.  For  expressions  involving
constraints,  inequalities,  or  non-algebraic  expressions,  you  should  use  Reduce.  (In
Mathematica 8.0, Solve will be enhanced to cover a much larger class of problems,
thus reducing the need to Reduce!) 
In[5]:=
Reduce@x > 0 && x^2 - 2 x - 3 ã 0, xD
Out[5]=
x ã 3
Reduce does not use rules because it may need to express solutions in terms of intervals.
In[6]:=
Reduce@x > 0 && x^2 < 2, xD
Out[6]=
0 < x <
2
FindRoot is appropriate when you are looking for numerical solutions and have pro-
vided a starting point where you want Mathematica to search. FindRoot is a numeri-
cal method, so it can solve a larger class of expressions then Solve, although it is not
guaranteed to converge. 
In[7]:=
FindRoot@x^2 - 2 x - 3 ã 0, 8x, -3<D
Out[7]=
8x Ø -1.<
In[8]:=
FindRoot@x^2 - Exp@2 xD - 3 ã x, 8x, 0<D
Out[8]=
8x Ø -1.32237<
10.2 Finding a Polynomial from a Given Root
Problem
You have an algebraic number and you want a polynomial that has the number among
its roots. This is the opposite of Solve, which finds the roots given a polynomial.
Solution
Use MinimalPolynomial to find the minimal polynomial (least degree) with the given
value as a root.
In[9]:=
poly = MinimalPolynomial@Sqrt@2D + Sqrt@5D, xD
Out[9]=
9 - 14 x2 + x4
In[10]:=
LastASolveApoly ã 0, xEE êê FullSimplify
Out[10]=
;x Ø
2 +
5 ?
10.2 Finding a Polynomial from a Given Root | 415

Discussion
As you would expect, complex numbers are allowed.
In[11]:=
MinimalPolynomial@2 + I, xD
Out[11]=
5 - 4 x + x2
Numbers must be explicitly algebraic or you will get an error. Trying to use Minimal-
Polynomial with Pi is doomed, since Pi is a transcendental number, but a rational
approximation of Pi fails as well because it is not explicitly algebraic.
In[12]:=
MinimalPolynomial@Pi, xD
MinimalPolynomial::nalg :
p is not an explicit algebraic number. à
Out[12]=
MinimalPolynomial@p, xD
In[13]:=
MinimalPolynomial@3.14, xD
MinimalPolynomial::nalg :
3.14` is not an explicit algebraic number. à
Out[13]=
MinimalPolynomial@3.14, xD
Use Rationalize to work around this limitation.
Out[14]=
MinimalPolynomial@Rationalize@3.14D, xD
Out[14]=
-157 + 50 x
10.3 Transforming Expressions to Other Forms
Problem
You have a symbolic expression that you would like to transform to a different form.
This problem often arises when you get a result from a Mathematica computation
that is in a form you don’t want. One common requirement is to simplify the expression.
416 | Chapter 10: Algebra

Solution
The two most important symbolic transformations are Simplify and FullSimplify.
These functions attempt to apply algebraic and other transformations to an expres-
sion that will convert it to an equivalent form that  contains  fewer  symbols.  The
main  difference between Simplify and FullSimplify is that FullSimplify will con-
sider a much larger set of transformations, including special functions. As a result,
FullSimplify is often more effective but also slower.
Here Simplify and FullSimplify ultimately arrive at the same answer, but Full-
Simplify  takes  well  over  a  minute,  whereas  Simplify  completes  in  just  over  a
second.
In[15]:=
TimingASimplifyASinAIx + y + zM^2E CosA Iz + y + xM^2EEE
Out[15]=
;0.764,
1
2
SinA2 Ix + y + zM2E?
In[16]:=
TimingAFullSimplifyASinAIx + y + zM^2E CosA Iz + y + xM^2EEE
In[16]:=
;38.626,
1
2
SinA2 Ix + y + zM2E?
Discussion
Simplify  and  FullSimplify  perform  fully  automated  simplification.  However,  you
sometimes want to apply more targeted transformations. For example, a common
transformation is to bring together a sum over a common denominator.
In[17]:=
Together@
aêHa^2 + b^2 + c^2L + bêHa^2 + b^2 + c^2L + cêHa^2 + b^2 + c^2LD
In[17]:=
a + b + c
a2 + b2 + c2
Apart is another useful transformation that represents an expression as sums of par-
tial fractions.
In[18]:=
Apart@4êHH1 + xL H5 + xLLD
In[18]:=
1
1 + x
-
1
5 + x
Polynomial transformations are a very important class, exemplified by functions like
Factor, FactorTerms, FactorSquareFree, Expand, and ExpandAll.
In[19]:=
FactorA21 - 4 x - x2E
In[19]:=
-H-3 + xL H7 + xL
10.3 Transforming Expressions to Other Forms | 417

Expand  is  the  opposite  of  Factor  and  expands  out  sums  of  products  and  positive
powers.
In[20]:=
Expand@%D
Out[20]=
21 - 4 x - x2
In[21]:=
Expand@H1 + xL^5D
Out[21]=
1 + 5 x + 10 x2 + 10 x3 + 5 x4 + x5
In[22]:=
Factor@%D
Out[22]=
H1 + xL5
ExpandAll is similar to Expand but reaches in deeper into the expression, for example,
into arguments of functions like Sin or Exp. Notice how Expand has no effect on a
nested polynomial but ExpandAll does.
In[23]:=
ExpandASinAH1 + xL5EE
Out[23]=
SinAH1 + xL5E
In[24]:=
ExpandAllASinAH1 + xL5EE
Out[24]=
SinA1 + 5 x + 10 x2 + 10 x3 + 5 x4 + x5E
You can also narrow the scope of Expand to the numerator or denominator of a ratio-
nal expression using ExpandNumerator and ExpandDenominator, respectively.
In[25]:=
With@8expr = H1 + xL^3 ê H3 + xL^4<,
Row@8ExpandNumerator@exprD, ExpandDenominator@exprD< , Invisible@exprDDD
Out[25]=
1 + 3 x + 3 x2 + x3
H3 + xL4
H1 + xL3
81 + 108 x + 54 x2 + 12 x3 + x4
Collect does the job of Expand but also collects terms of matching powers of some
variable. Compare the results of Expand and Collect given here.
In[26]:=
Expand@Ha + xL^2 Hb + xL^3D
Out[26]=
a2 b3 + 3 a2 b2 x + 2 a b3 x + 3 a2 b x2 + 6 a b2 x2 +
b3 x2 + a2 x3 + 6 a b x3 + 3 b2 x3 + 2 a x4 + 3 b x4 + x5
In[27]:=
Collect@Ha + xL^2 Hb + xL^3, xD
In[27]:=
a2 b3 + I3 a2 b2 + 2 a b3M x + I3 a2 b + 6 a b2 + b3M x2 +
Ia2 + 6 a b + 3 b2M x3 + H2 a + 3 bL x4 + x5
FactorTerms factors out numerical terms or terms that do not depend on particular
variables.
In[28]:=
FactorTerms@Expand@H3 + 3 xL^5DD
Out[28]=
243 I1 + 5 x + 10 x2 + 10 x3 + 5 x4 + x5M
418 | Chapter 10: Algebra

In[29]:=
ExpandAIy + y xM^5E
Out[29]=
y5 + 5 x y5 + 10 x2 y5 + 10 x3 y5 + 5 x4 y5 + x5 y5
In[30]:=
FactorTermsA%, yE
Out[30]=
I1 + 5 x + 10 x2 + 10 x3 + 5 x4 + x5M y5
Another  important  class  of  transformations  are  trigonometric  transformations.
These include TrigFactor, TrigExpand, TrigExpandAll, and TrigReduce.
In[31]:=
TrigFactor@Sin@3 xDD
Out[31]=
H1 + 2 Cos@2 xDL Sin@xD
TrigExpand removes sums and products inside arguments by expanding the expres-
sion using trigonometric identities.
In[32]:=
TrigExpand@Sin@3 x + 1DD
Out[32]=
Cos@xD3 Sin@1D + 3 Cos@1D Cos@xD2 Sin@xD -
3 Cos@xD Sin@1D Sin@xD2 - Cos@1D Sin@xD3
Cos@xD3 Sin@1D + 3 Cos@1D Cos@xD2 Sin@xD -
3 Cos@xD Sin@1D Sin@xD2 - Cos@1D Sin@xD3
Cos@xD3 Sin@1D + 3 Cos@1D Cos@xD2 Sin@xD -
3 Cos@xD Sin@1D Sin@xD2 - Cos@1D Sin@xD3
TrigReduce transforms an expression so that it is linear in the trigonometric terms
(no powers or multiplications of two different trig functions).
In[33]:=
TrigReduce@Sin@3 xD^2 Cos@2 xDD
Out[33]=
1
4
H2 Cos@2 xD - Cos@4 xD - Cos@8 xDL
See Also
Mathematica  has  quite  a  few  specialized  functions  for  manipulating  polynomials
and extracting portions of their structure. See tutorial/AlgebraicOperationsOnPolynomials
in the documentation. 
A complete overview of algebraic manipulations can be found at tutorial/Algebraic 
ManipulationOverview.
10.4 Generating Polynomials
Problem
You want to generate a polynomial of a specific degree.
10.4 Generating Polynomials | 419

Solution
A simple solution uses Sum and Subscript. Here I generate a fourth-degree polynomial.
In[34]:=
Sum@Subscript@a, iD x^i, 8i, 0, 4<D
Out[34]=
a0 + x a1 + x2 a2 + x3 a3 + x4 a4
Discussion
If, other than the degree, you don’t care about the particular form of the polynomial,
then the solution is fine. However, if you want to specify the coefficients, you can
generate a polynomial with Dot.
In[35]:=
ClearAllAmakePolyE
SetAttributesAmakePoly, HoldRestE; makePoly@coef_List, var_: xD :=
DotATableAvar^i, 9i, 0, Length@coefD - 1=E, coefE
In[37]:=
makePoly@8a, b, c, d, e<D
Out[37]=
a + b x + c x2 + d x3 + e x4
Here I specify a variable other than x.
In[38]:=
makePoly@8a, b, c, d, e<, zD
Out[38]=
a + b z + c z2 + d z3 + e z4
Many mathematics textbooks show polynomials from highest to lowest degree, and
you may want to generate and display your polynomials in this order as well. Re-
place Dot with Inner and use HoldForm so the sum is not reordered by Mathematica.
Note how I changed Table to generate terms from highest degree to lowest.
In[39]:=
ClearAllAmakePoly2E
SetAttributesAmakePoly2, HoldRestE;
makePoly2@coef_List, var_: xD := InnerATimes,
TableAvar^i, 9i, Length@coefD - 1, 0, -1=E, coef, HoldForm@Plus@ÒÒDD &E
In[41]:=
makePoly2@8a, b, c, d, e<, zD
Out[41]=
a z4 + b z3 + c z2 + d z + e
10.5 Decomposing Polynomials into Their 
Constituent Parts
Problem
You  want  to  extract  a  list  of  coefficients,  monomials,  or  variables  from  a  given
polynomial.
420 | Chapter 10: Algebra

Solution
Two  useful  primitives  for  decomposing  polynomials  are  CoefficientList  and
MonomialList. First I generate a polynomial, per Recipe 10.4. 
In[42]:=
poly = Sum@Subscript@a, iD x^i, 8i, 0, 6<D
Out[42]=
a0 + x a1 + x2 a2 + x3 a3 + x4 a4 + x5 a5 + x6 a6
Use CoefficientList to extract a list of coefficients of poly.
In[43]:=
CoefficientListApoly, xE
In[43]:=
8a0, a1, a2, a3, a4, a5, a6<
Use MonomialList to extract a list of the individual monomial terms of poly.
In[44]:=
MonomialListApolyE
Out[44]=
9a0, x6 a6, x5 a5, x4 a4, x3 a3, x2 a2, x a1=
If you only want the variables of the polynomial, use Variables.
In[45]:=
VariablesAHx + 1L^2 Iy + 3M^3E
Out[45]=
9x, y=
Discussion
In addition to CoefficientList, you can pick coefficients that match a specific form
using Coefficient.
In[46]:=
CoefficientA8 + 12 x + 6 x2 + x3, x^2E
Out[46]=
6
Coefficient also takes a third argument, which specifies the power of the second ar-
gument. So the same extraction can be done as shown here.
In[47]:=
CoefficientA8 + 12 x + 6 x2 + x3, x, 2E
In[47]:=
6
Conveniently, this also allows you to extract the constant term. 
In[48]:=
CoefficientA8 + 12 x + 6 x2 + x3, x, 0E
Out[48]=
8
Returning to MonomialList, there is a third argument that allows you to change the or
der  of  the  monomials  returned.  The  available  orderings  are  "Lexicographic",
"DegreeLexicographic",  "DegreeReverseLexicographic",  "NegativeLexicographic",
"NegativeDegreeLexicographic",  and  "NegativeDegreeReverseLexicographic".  Refer
to the documentation of MonomialList for definitions.
10.5 Decomposing Polynomials into Their Constituent Parts | 421

In[49]:=
poly = ExpandAHx + 2L^2 Iy + 3M^3E
Out[49]=
108 + 108 x + 27 x2 + 108 y + 108 x y +
27 x2 y + 36 y2 + 36 x y2 + 9 x2 y2 + 4 y3 + 4 x y3 + x2 y3
In[50]:=
MonomialListApoly, 9x, y=, "DegreeLexicographic"E
Out[50]=
9x2 y3, 9 x2 y2, 4 x y3, 27 x2 y, 36 x y2, 4 y3, 27 x2, 108 x y, 36 y2, 108 x, 108 y, 108=
In[51]:=
MonomialListApoly, 9x, y=, "Lexicographic"E
Out[51]=
9x2 y3, 9 x2 y2, 27 x2 y, 27 x2, 4 x y3, 36 x y2, 108 x y, 108 x, 4 y3, 36 y2, 108 y, 108=
In[52]:=
MonomialListApoly, 9x, y=, "NegativeDegreeLexicographic"E
Out[52]=
9108, 108 x, 108 y, 27 x2, 108 x y, 36 y2, 27 x2 y, 36 x y2, 4 y3, 9 x2 y2, 4 x y3, x2 y3=
After using MonomialList to get the monomials in the desired order, you can display
the polynomial in that order using HoldForm.
In[53]:=
HoldForm@Plus@ÒÒDD & üü MonomialListApoly, 9x, y=, "Lexicographic"E
Out[53]=
x2 y3 + 9 x2 y2 + 27 x2 y + 27 x2 + 4 x y3 +
36 x y2 + 108 x y + 108 x + 4 y3 + 36 y2 + 108 y + 108
See Also
You  may  also  want  to  consider  CoefficientArrays  and  CoefficientRules.  See  the
Mathematica documentation for these functions.
10.6 Dividing Polynomials by Other Polynomials
Problem
You want to divide polynomials, find remainders, greatest common divisor (GCD),
or least common multiple (LCM). 
Solution
Use  PolynomialQuotient  or  PolynomialRemainder.  If  you  need  both,  use  Polynomial-
QuotientRemainder.
In[54]:=
PolynomialQuotient@x^3 + x^2 - x + 1, x + 1, xD
Out[54]:=
-1 + x2
In[55]:=
PolynomialRemainder@x^3 + x^2 - x + 1, x + 1, xD
Out[55]=
2
In[56]:=
PolynomialQuotientRemainder@x^3 + x^2 - x + 1, x + 1, xD
Out[56]=
9-1 + x2, 2=
422 | Chapter 10: Algebra

Discussion
Mathematica  also  provides  PolynomialMod,  which  uses  an  algorithm  based  on  re-
peated subtraction and, hence, never performs a division. In contrast, Polynomial-
Remainder is implemented in terms of PolynomialQuotient.
In[57]:=
WithA9poly = x^3 + x^2 - x + 1, divisor = x^2=,
SimplifyApoly - Idivisor* PolynomialQuotientApoly, divisor, xE ME ===
PolynomialRemainderApoly, divisor, xEE
Out[57]=
True
In many cases, PolynomialMod and PolynomialRemainder will return the same result.
In particular, for univariate rational polynomials, PolynomialRemainder is the same as
PolynomialMod.
In[58]:=
PolynomialMod@x^3 + x^2 - x + 1, x^2D ===
PolynomialRemainder@x^3 + x^2 - x + 1, x^2, xD
Out[58]=
True
In[59]:=
PolynomialMod@x^3 + x^2 - x + 1, xD ===
PolynomialRemainder@x^3 + x^2 - x + 1, x, xD
Out[59]=
True
If the divisor is a constant or multivariate, the functions work differently. In the case
of  PolynomialMod,  a  constant  m  reduces  the  coefficients  module  m  whereas
PolynomialRemainder will always give 0.
In[60]:=
PolynomialMod@13 x^3 + 15 x^2 - 5 x + 7, 7D
Out[60]=
2 x + x2 + 6 x3
In[61]:=
PolynomialRemainder@x^3 + x^2 - x + 1, 7, xD
Out[61]=
0
In the multivariate case, PolynomialMod determines variable order based on OrderedQ.
In[62]:=
PolynomialMod@a x^3 + 2 a x^2 - 5 ax + 1, x + aD
Out[62]:=
1 - 5 ax - 2 x3 - x4
In[63]:=
PolynomialRemainder@a x^3 + 2 a x^2 - 5 ax + 1, x + a, xD
Out[63]=
1 + 2 a3 - a4 - 5 ax
10.6 Dividing Polynomials by Other Polynomials | 423

Both PolynomialMod and PolynomialRemainder allow you to compute the result mod-
ule to a specific integer n by specifying the option ModulusØn. This means the compu-
tation is over the finite ring of integers Zn. The default is ModulusØ0, meaning the
infinite set of integers.
In[64]:=
PolynomialRemainder@x^2 + 2 x + 2, x, xD
Out[64]=
2
Given these polynomial generalizations of division, it makes sense to discuss GCD
and LCM.
In[65]:=
PolynomialGCD@10 x^3 + 2, 30 x^3 + 6D
Out[65]=
2 + 10 x3
Here we show that polynomials with coefficients with LCM less than the product
will result in polynomials with LCM different than their product.
In[66]:=
WithA8p1 = 12 x + 18, p2 = 18 x + 24<,
GridA9Expand êü 9 PolynomialLCM@p1, p2D, p1 *p2==, Dividers Ø All EE
Out[66]=
72 + 102 x + 36 x2
432 + 612 x + 216 x2
Observe that 
In[67]:=
8LCM@18, 24D, LCM@12, 18D<
Out[67]:=
872, 36<
In[68]:=
612ê102 ã 432ê72 ã 216ê36 ã GCD@18, 24, 12D
Out[68]=
True
424 | Chapter 10: Algebra

CHAPTER 11
 Calculus: Continuous and Discrete
Time may change me
But I can’t trace time
I said that time may change me
But I can’t trace time
David Bowie, “Changes”
11.0 Introduction
This chapter primarily focuses on the types of problems students and teachers will
cover  in  college-level  mathematics  courses  and  how  Mathematica  can  be  used  as
a calculator (tool for getting an answer) and a teacher (tool for gaining insight into
a  mathematical  problem).  However,  this  focus  was  largely  pragmatic  and  does
not imply that Mathematica is limited to introductory calculus. Quite the contrary.
Mathematica has been leading the charge among computer algebra systems since its
inception, and with each new release the depth and breadth of its abilities in sym-
bolic  calculus  improve.  My  goal  in  most  of  these  recipes  is  to  provide  a  starting
point  for  the  inexperienced  user.  Experts  will  probably  find  little  that  is  new  or
highly original. This was a conscious choice based on space limitations. I am quite
certain one could write a small cookbook by turning each recipe here into an entire
chapter! Such is the depth of Mathematica’s abilities. 
Most of the recipes in this chapter address what is commonly known as infinitesimal
or  continuous  calculus.  These  problems  deal  with  limits  (Recipe  11.1),  series
(Recipe  11.3),  derivatives  (Recipe  11.4),  integrals  (Recipe  11.5),  and  differential
equations  (Recipe  11.6).  A  common  application  of  calculus  is  finding  minimums
and  maximums.  Mathematica  packages  these  techniques  into  Minimize,  Maximize,
and related functions (Recipe 11.7). When you use your calculus skills to solve real
engineering  and  physics  problems,  you  are  bound  to  run  smack  into  applications
that  involve  vector  calculus.  Mathematica  has  a  package  of  functions  specifically
dedicated  to  vector  calculus,  and  we  touch  on  some  of  this  functionality  in
Recipe 11.8. 
425

Although the calculus of continuous functions still plays a dominant role, discrete calcu-
lus is extremely important and has been garnering increasing attention lately due to re-
search in such varied domains as string theory, probability theory, theory of algorithms,
and combinatorics, to name a few. Mathematica 7 has enhanced its discrete calculus
abilities. Recipes 11.9 through 11.11 help you start using these capabilities. 
See Also
A guide to all functions related to infinitesimal calculus can be found in the Mathe-
matica documentation at guide/Calculus.
A guide to all functions related to discrete calculus can be found in the Mathematica
documentation at guide/DiscreteCalculus.
11.1 Computing Limits
Problem
You want to determine the value of a function as a variable approaches a specific
value, even if evaluating the function at that limit may give an indeterminate result.
Solution
The functions Sin[x]/x, Sin[x^2]/x, and Sin[x]/x^2 each evaluate to the indetermi-
nate value 0/0 at x = 0; however, their limits as x approaches zero are quite definite
and different.
In[1]:=
Limit@Sin@xDêx, x Ø 0D
Out[1]=
1
In[2]:=
Limit@Sin@x^2Dêx, x Ø 0D
Out[2]=
0
In[3]:=
Limit@Sin@xDêx^2, x Ø 0D
Out[3]=
¶
Discussion
Plotting functions around the limiting value is often a good way to provide visual in-
sight into the limiting value.
426 | Chapter 11:  Calculus: Continuous and Discrete

In[4]:=
GraphicsRow@8Plot@Sin@xDêx, 8x, -1, 1<D,
Plot@Sin@x^2Dêx, 8x, -1, 1<D, Plot@Sin@xDêx^2, 8x, -1, 1<D<D
Out[4]=
-1.0
-0.5
0.0
0.5
1.0
0.90
0.95
1.00
-1.0
-0.5
0.5
1.0
-0.5
0.5
-1.0
-0.5
0.5
1.0
-10
-5
5
10
Here you can see that the last function has different limits depending on whether
one approaches the limit from the left or the right. You can specify which limit you
want using the option Direction.
In[5]:=
H*From the left*LLimit@Sin@xDêx^2, x -> 0, Direction Ø 1D
Out[5]=
-¶
In[6]:=
H*From the right*LLimit@Sin@xDêx^2, x -> 0, Direction Ø -1D
Out[6]=
¶
11.2 Working with Piecewise Functions
Problem
You  want  to  express  a  function  in  terms  of  two  or  more  functions  over  different
intervals.
Solution
Mathematica supports a function Piecewise for composing a complex function out
of  simpler  functions  using  predicates  to  determine  which  of  the  simpler  functions
apply. 
In[7]:=
f@x_D =
Piecewise@88Sqrt@1êx^2D, x < -0.3<, 81êx, x > 0.3 <, 83.33, True<<D
Out[7]=
1
x2
x < -0.3
1
x
x > 0.3
3.33
True
11.2 Working with Piecewise Functions | 427

In[8]:=
Plot@f@xD, 8x, -3, 3<D
Out[8]=
-3
-2
-1
1
2
3
1.0
1.5
2.0
2.5
3.0
Discussion
Clip, Sign, and UnitStep are special cases of built-in piecewise functions. Clip con-
strains its input to a minimum and maximum value (default |1 and +1). Sign gives
|1 or 1 depending on whether the input is negative or positive, and UnitStep is 0 for
negative values and 1 for values greater than or equal to zero.
In[9]:=
GraphicsRowA9Plot@Clip@2 Sin@xDD, 8x, -Pi, Pi<, PlotLabel -> "Clip"D,
PlotASign@2 Sin@xDD, 8x, -Pi, Pi<, PlotLabel -> "Sign"E,
Plot@UnitStep@2 Sin@xDD, 8x, -Pi, Pi<, PlotLabel -> "UnitStep"D=,
ImageSize Ø 8500, 150<E
Out[9]=
-3
-2
-1
1
2
3
-1.0
-0.5
0.5
1.0
Clip
-3
-2
-1
1
2
3
-1.0
-0.5
0.5
1.0
Sign
-3 -2 -1
1
2
3
0.2
0.4
0.6
0.8
1.0
UnitStep
You can differentiate and integrate piecewise functions, and you’ll get a piecewise
function.
In[10]:=
D@Clip@2 Sin@xDD, xD
Out[10]=
0
Sin@xD < -
1
2 »» Sin@xD >
1
2
2 Cos@xD
True
In[11]:=
Integrate@Clip@2 Sin@xDD, xD
Out[11]=
-x
Sin@xD < -
1
2
x
Sin@xD >
1
2
-2 Cos@xD
True
428 | Chapter 11:  Calculus: Continuous and Discrete

PiecewiseExpand can take a nested piecewise function and return a single function.
You can use this to show that Min, Max, and Abs are also special cases of piecewise
functions.
In[12]:=
PiecewiseExpandAMaxAw, x, y, zEE
Out[12]=
w
w - x ¥ 0 && w - y ¥ 0 && w - z ¥ 0
x
w - x < 0 && x - y ¥ 0 && x - z ¥ 0
y
w - y < 0 && x - y < 0 && y - z ¥ 0
z
True
In[13]:=
PiecewiseExpandAClipAMinAx, yEEE
Out[13]=
-1
Ix < -1 && x - y § 0M »» Ix - y > 0 && y < -1M
1
Ix > 1 && x - y § 0M »» Ix - y > 0 && y > 1M
x
-1 § x § 1 && x - y § 0
y
True
11.3 Using Power Series Representations 
Problem
You want to find the series expansion of a function.
Solution
The Mathematica function Series  will generate the series expansion of a function
about a point to a specified order. It produces a SeriesObject, which Mathematica
will display as a traditional series expansion.
In[14]:=
Series@Sin@xD, 8x, 0, 10<D
Out[14]=
x -
x3
6
+
x5
120
-
x7
5040
+
x9
362880
+ O@xD11
In[15]:=
% êê InputForm
Out[15]//InputForm=
SeriesData[x, 0, {1, 0, -1/6, 0, 1/120, 0, -1/5040, 0, 1/362880}, 1, 11, 1]
You  use  Normal  to  create  a  regular  Mathematica  expression.  Here  I  also  use
Evaluate because I am defining a function and want Normal to evaluate immediately
even though the function is defined using SetDelayed (:=). Equivalently, you can use
Set (=) to define the function without Evaluate.
In[16]:=
f@x_D := Evaluate@Normal@Series@Sin@xD, 8x, 0, 10<DDD
11.3 Using Power Series Representations | 429

You visualize the accuracy of the series approximation by plotting over successively
larger  intervals.  As  expected,  this  series  approximation  begins  to  diverge  as  you
move away from the origin.
In[17]:=
GraphicsColumn@Table@Plot@8Sin@xD, f@xD<, 8x, -n Pi, n Pi<D, 8n, 1, 3<DD
Out[17]=
-3
-2
-1
1
2
3
-1.0
-0.5
0.5
1.0
-6
-4
-2
2
4
6
-3
-2
-1
1
2
3
-5
5
-3
-2
-1
1
2
3
Discussion
You can compute the inverse of a series using InverseSeries.
In[18]:=
fInv@x_D = Normal@InverseSeries@Series@Sin@xD, 8x, 0, 10<DDD
Out[18]=
x +
x3
6
+
3 x5
40
+
5 x7
112
+
35 x9
1152
430 | Chapter 11:  Calculus: Continuous and Discrete

In[19]:=
PlotA8ArcSin@xD , fInv@xD<, 8x, -1, 1<, ImageSize Ø SmallE
Out[19]=
-1.0
-0.5
0.5
1.0
-1.5
-1.0
-0.5
0.5
1.0
1.5
11.4 Differentiating Functions 
Problem
You  want  to  compute  derivatives  or  partial  derivatives  of  functions  in  symbolic
form. You may do this as a means of creating new functions or as a means of teach-
ing the concepts that underlie differentiation.
Solution
Mathematica allows you to enter derivatives in input form as D[f[x], x] or in stan-
dard form as ∂xf[x].
In[20]:=
D@Sin@xD, xD
Out[20]=
Cos@xD
In[21]:=
∂x Sin@xD
Out[21]=
Cos@xD
Higher-order derivatives are specified as D[f[x],{x,n}] where n is 2 for the second
derivative, 3 for the third, and so on. In standard form, the second derivative can be
entered as ∂8x,2< f@xD.
In[22]:=
D@Sin@xD, 8x, 2<D
Out[22]=
-Sin@xD
Partial  derivatives  are  easily  accommodated  as  well  using  several  equivalent
notations.
In[23]:=
DASin@xD SinAyE, 8x, 1<E
Out[23]=
Cos@xD SinAyE
11.4 Differentiating Functions | 431

In[24]:=
DASin@xD SinAyE, x, x, yE
Out[24]=
-CosAyE Sin@xD
In[25]:=
DASin@xD SinAyE, 8x, 2<, 9y, 1=E
Out[25]=
-CosAyE Sin@xD
Discussion
Mathematica also recognizes prime notation, but this notation is more commonly
used  in  Mathematica  when  entering  a  differential  equation.  See  the  sidebar
“Mathematica’s Representation of Differentiation” on page 433 for some important
subtleties.
In[26]:=
8Sin'@xD, Sin''@xD<
Out[26]=
8Cos@xD, -Sin@xD<
You can use D along with Solve to differentiate implicit functions. Simply use D as
usual and use Solve to find the solution in terms of y'[x].
In[35]:=
implicitFunction = x^4 + 2 y@xD^2 ã 8;
SolveAD@implicitFunction, xD, y'@xDE
Out[36]=
;;y£@xD Ø -
x3
y@xD
??
There are cases where you may want to use the D to synthesize a function on the fly.
In this case, use Set (=) to perform the differentiation operation immediately or use
Evaluate with SetDelayed (:=). 
In[37]:=
f1@x_D = D@Sin@Pi x Cos@x ^ 2DD, xD;
In[38]:=
f2@x_D := Evaluate@D@Sin@Pi x Cos@x ^ 2DD, xDD
In[39]:=
8f1@2.D, f2@2.D<
Out[39]=
8-9.65614, -9.65614<
If you forget to do so, you will get an error when you call the function with a literal
value.
In[40]:=
f3@x_D := D@Sin@Pi x Cos@x ^ 2DD, xD
In[41]:=
f3@2.D
General::ivar : 2.` is not a valid variable. à
Out[41]=
∂2. 0.82226
432 | Chapter 11:  Calculus: Continuous and Discrete

Mathematica’s Representation of Differentiation
More importantly, the prime notation is not synonymous with D[] but rather with a
differential  operator  of  the  form  Derivative[n].  The  operator  form  clarifies
ambiguities that would result from using it with functions of more than one variable.
Think of Derivative[n1, n2, ...] as an operator that acts on a function to produce
the specific derivative. The number of n’s should not exceed the number of variables
of the function since each n is associated with the nth derivative of the corresponding
variable. Some examples should help clarify.
First derivative with respect to x:
Derivative@1D@fDAx, yE
1 -
x2
2
+
x4
24
-
x6
720
+
x8
40320
f£Ax, yE
1 -
x2
2
+
x4
24
-
x6
720
+
x8
40320
First derivative with respect to x, then y:
Derivative@1, 1D@fDAx, yE
fH1,1LAx, yE
fH1,1LAx, yE
fH1,1LAx, yE
First derivative with respect to x, then second derivative with respect to y:
Derivative@1, 2D@fDAx, yE
fH1,2LAx, yE
fH1,2LAx, yE
fH1,2LAx, yE
For the most part, you should work with D[] directly, but keep the operator notation
in  the  back  of  your  mind  because  it  is  how  Mathematica  represents  derivatives
internally.
DAfAx, yE, x, yE êê FullForm
Derivative@1, 1D@fDAx, yE
Derivative@1, 1D@fDAx, yE
fH1,1LAx, yE
Many students will use Mathematica to check the answers to their calculus homework,
but Mathematica is also useful for generating demonstrations of the fundamental con-
cepts underlying differentiation. For example, the derivative of a function at a point
11.4 Differentiating Functions | 433

is the slope of the tangent to the function at that point. Further, given two points,
the slope of the secant drawn between these points approaches the derivative as the
points  approach  each  other  along  the  curve.  The  following  function  uses
Mathematica’s dynamic features to generate presentations of this fact using any func-
tion and starting points as input.
In[42]:=
makeDerivativeDemo@f_, x1_, x2_, opts : OptionsPattern@DD :=
DynamicModuleA9fp, f2, p1, p2, g, slope, slopeText, buildPlot, minX, maxX=,
p1 = 8x1, f@x1D<;
p2 = 8x2, f@x2D<;
g = buildPlot@f, fp, f2, p1, p2D;
With A9plotRange = Inner@8Min@ÒÒ - 3D, Max@ÒÒ + 3D< &, p1, p2, ListD=,
minX = plotRange@@1, 1DD;
maxX = plotRange@@1, 2DD;
DynamicA
GraphicsA9g@@1DD, Line@8p1, p2<D,
LocatorADynamicAp1, 9Hp1 = 8Ò@@1DD, f@Ò@@1DDD<L &,
Ig = buildPlot@f, fp, f2, p1, p2DM &=E, Appearance Ø SmallE,
LocatorADynamicAp2, 9Hp2 = 8Ò@@1DD, f@Ò@@1DDD<L &,
Ig = buildPlot@f, fp, f2, p1, p2DM &=E, Appearance Ø SmallE=,
FilterRulesA8opts<, OptionsAgEE, PlotRange -> plotRange,
OptionsAgEEE
E,
Initialization ß I
H*The actual derivative*L
fp@x_D := Evaluate@D@f@xD, xDD;
H*Function for tangent line at x0*L
f2@x0_, x_D := Module@8<, f@x0D + fp@x0D Hx - x0LD;
H*Text for slope of line from p1 to p2*L
slopeText@p1_, p2_D :=
ModuleA8s<, s = Divide üü H1.0êHp2 - p1LL; ToString@sDE;
H*Plot function, tangent line, and text label*L
buildPlot@ff_, fp_, f2_, p1_, p2_D := ModuleA8<,
NormalA
PlotA8ff@xD, f2@p1@@1DD, xD<, 8x, p1@@1DD - 3, p2@@1DD + 3<,
Epilog Ø 9InsetAPanelA"Secant slope = " <>
slopeText@p1, p2D <>
"\nDerivative = " <>
ToString@N@fp@p1@@1DDDDDE, 8Left, Top<, 8Left, Top<E=
EE
E
ME
434 | Chapter 11:  Calculus: Continuous and Discrete

In[43]:=
makeDerivativeDemo@Sin@Pi Cos@ÒDD &, 1.25, 1.75D
Out[43]=
11.5 Integration
Problem
You want to solve problems that involve indefinite or definite integrals using sym-
bolic integration. 
Solution
Use Integrate or Ÿ to compute single, double, or higher-order integrations. Indefi-
nite integrals specify an expression and the variables of integration.
In[44]:=
Integrate@1êx, xD
Out[44]=
Log@xD
Definite  integrals  provide  the  minimum  and  maximum  limits,  which  can  be  con-
stants or expressions.
In[45]:=
Integrate@1êx, 8x, 1, 10.0<D
Out[45]=
2.30259
In[46]:=
Clear@a, bD;
Integrate@x^2, 8x, a, b<D
Out[47]=
-
a3
3
+
b3
3
The minimum and maximum limits can be -Infinity or Infinity.
In[48]:=
IntegrateA1êHx^3 + x^2L, 9x, 1, Infinity=E
Out[48]=
1 - Log@2D
11.5 Integration | 435

Discussion
Integrate will easily handle most integration problems you are likely to encounter in
school, engineering, and science. 
In[49]:=
·
z2
Iz2 - 1M
z2 + 1
„z
Out[49]=
1
4
4 ArcSinh@zD +
2
Log@-1 + zD - Log@1 + zD +
LogC-1 + z -
2
1 + z2 G - LogC1 + z +
2
1 + z2 G
Double and higher-order integrals are computed with a single Integrate function by
adding multiple integration variables. However, if you use the traditional integration
notation, you will use multiple integral symbols.
In[50]:=
IntegrateASinA2 Pi z yë xE x y z, x, y, zE
Out[50]=
1
64 p2
x
I-2 p x2 y z + 4 p3 y3 z3M CosC
2 p y z
x
G +
x I-3 x2 + 2 p2 y2 z2M SinC
2 p y z
x
G
+
4 Ix4 + 2 p4 y4 z4M SinIntegralC
2 p y z
x
G
In[51]:=
‡ ‡ ‡ x y z „x „y „z
Out[51]=
1
8
x2 y2 z2
Some  integrations  may  return  with  conditionals  and  assumptions  due  to  conver-
gence issues. You can eliminate these by providing your own assumptions.
In[52]:=
IntegrateAExpA-c x2E, 8x, -¶, ¶<E
Out[52]=
IfCRe@cD > 0,
p
c
, IntegrateB‰-c x2, 8x, -¶, ¶<, Assumptions Ø Re@cD § 0FG
In[53]:=
IntegrateAExpA-c x2E, 8x, -¶, ¶<, Assumptions Ø c > 0E
Out[53]=
p
c
436 | Chapter 11:  Calculus: Continuous and Discrete

You also do this using GenerateConditions Ø False.
In[54]:=
IntegrateAExpA-c x2E, 8x, -¶, ¶<, GenerateConditions Ø FalseE
Out[54]=
p
c
You can also get piecewise functions as a result of Integrate.
In[55]:=
Integrate@Abs@x + Abs@xD^2D, x, Assumptions Ø x œ RealsD
Out[55]=
x2
2 +
x3
3
x § -1
1
3 -
x2
2 -
x3
3
-1 < x § 0
1
3 +
x2
2 +
x3
3
True
When Integrate is unable to solve the integration, it will return the unevaluated inte-
gral in symbolic form. 
In[56]:=
IntegrateAExpA1ë ILog@xD + 1ME, 8x, 2, 3<E
Out[56]=
‡
2
3
‰
1
1+Log@xD „x
Applications  of  integration  are  numerous,  and  it  would  be  impossible  to  provide
even a small representative set of examples here. Rather, I will provide examples that
emphasize  how  Integrate  can  be  combined  with  other  Mathematica  functions  in
non-obvious ways.
A simple application is a function to compute the area between two arbitrary curves
given two points. When you create functions that embed Integrate, you often want
to allow options to pass through to increase generality.
In[57]:=
areaBetweenTwoCurves@expr1_, expr2_, var_, a_,
b_, opts : OptionsPattern@DD := IntegrateAexpr1 - expr2,
8var, a, b<, Sequence üü FilterRulesA8opts<, OptionsAIntegrateEEE
In[58]:=
areaBetweenTwoCurves@x, x^2, x, 0, 1D
Out[58]=
1
6
This would generate a huge messy conditional if not for the ability to pass assump-
tions about the arbitrary bounds a and b.
In[59]:=
areaBetweenTwoCurvesALog@xD, Sin@xD, x, a, b, Assumptions Ø a > 0 && b > 0E
Out[59]=
a - b - Cos@aD + Cos@bD - a Log@aD + b Log@bD
Create  a  table  of  volumes  of  hyperspheres.  Here  Boole  maps  True  to  1  and  False
to 0. Note that the list of integration limits must be converted to a sequence using
11.5 Integration | 437

Apply (@@). By the way, this is a very expensive way to calculate volume of a hyper-
sphere, but it does illustrates how to parameterize the order of integration. Search
for hyperspheres on Wikipedia or Wolfram’s MathWorld to find a more practical
formula.
In[60]:=
TableAIntegrateABoole@Sum@x@iD^2, 8i, 1, n<D § 1D,
Sequence üü TableA9xAjE, -Infinity, Infinity=, 9j, 1, n=E,
GenerateConditions Ø TrueE, 8n, 1, 5<E
Out[60]=
;2, p,
4 p
3
,
p2
2
,
8 p2
15
?
You can combine Integrate with differentiation to create a general function to com-
pute the length of a curve between two points.
In[61]:=
ClearAlengthOfCurveE
In[62]:=
lengthOfCurve@expr_, var_, a_, b_, opts : OptionsPattern@DD :=
IntegrateASqrt@1 + D@expr, varD^2D, 8var, a, b<,
Sequence üü FilterRulesA8opts<, OptionsAIntegrateEEE
Or, you can compute the length of the hypotenuse of a right triangle.
In[63]:=
lengthOfCurve@x, x, 0, 1D
Out[63]=
2
Verify the formula for the circumference of a circle given its radius by taking twice
the arc length of a semicircle. 
In[64]:=
2 lengthOfCurve@Sqrt@r^2 - x^2D, x, -r, r, Assumptions Ø r > 0D
Out[64]=
2 p r
Here is a purely symbolic solution with assumptions to simplify results.
In[65]:=
lengthOfCurve@Exp@xD, x, a, b, Assumptions Ø Ha > 0 && b > 0LD
Out[65]=
-
1 + ‰2 a +
1 + ‰2 b +
1
2
LogC
1 +
1 + ‰2 a
-1 +
1 + ‰2 b
-1 +
1 + ‰2 a
1 +
1 + ‰2 b
G
11.6 Solving Differential Equations
Problem
You have a model of a system described by a differential equation and you want to
solve that equation symbolically. Two related problems are getting the equation in a
form Mathematica expects and getting the solution in the form you expect.
438 | Chapter 11:  Calculus: Continuous and Discrete

Solution
An undergraduate student of engineering or physics will commonly need to solve dif-
ferential equations that model simple systems. A common problem is an undamped
oscillator composed of a mass hanging from a spring. The problem may appear in a
textbook as
In[66]:=
m y'' + k y = 0
This says that the force (mass × acceleration) is balanced by the force of the spring,
as given by Hooke’s law, where k is the spring constant. The key to solving this equa-
tion in Mathematica using DSolve is to make the equation more explicit. Specifically,
the equation omits the time variable. You must also replace the = symbol with ==
and tell Mathematica what equation we are solving for and what are the variables.
In[67]:=
DSolveAm y''@tD + k y@tD ã 0, y@tD, tE
Out[67]=
;;y@tD Ø C@1D CosC
k t
m
G + C@2D SinC
k t
m
G??
The solution is given as a replacement rule, and since the equation is a second order,
two constants, C[1] and C[2], are introduced. You can provide initial conditions to
eliminate the constants. In this case, you can also render the solution in its customary
form by replacing Sqrt[k]/Sqrt[m] by the angular frequency w. 
In[68]:=
DSolveA9m y''@tD + k y@tD ã 0, y@0D ã 1, y'@0D ã 1=, y@tD, tE ê.
8Sqrt@kDêSqrt@mD Ø w<
Out[68]=
;;y@tD Ø
k Cos@t wD +
m Sin@t wD
k
??
Discussion
The  solutions  provided  by  DSolve  are  not  automatically  simplified,  and  you  often
will want to use Simplify or FullSimplify to postprocess them into a more mathe-
matically  friendly  form.  This  is  especially  relevant  when  comparing  the  answer
DSolve  finds  with  answers  provided  in  a  typical  textbook.  Consider  this  problem
adapted  from  Advanced  Engineering  Mathematics  by  Erwin  Kreyszig  (John  Wiley).
Here you want to find the solution to a differential equation describing the speed of
a fluid flowing out of an opening in a container. 
11.6 Solving Differential Equations | 439

In[69]:=
k = 0.00266 ;
eq = 8h'@tD ã -k Sqrt@h@tDD, h@0D == 150<;
sol = DSolve@eq, h@tD, tD
Out[71]=
99h@tD Ø 150. - 0.0325782 t + 1.7689µ10-6 t2=,
9h@tD Ø 150. + 0.0325782 t + 1.7689µ10-6 t2==
Given the physics of the problem, it should be clear we want the first solution (the
second solution has the height increasing with time). 
In[72]:=
FullSimplify@sol@@1DDD
Out[72]=
9h@tD Ø 1.7689µ10-6 H-9208.61 + tL H-9208.61 + tL=
Although this has simplified the result somewhat, it is a much more complicated solu-
tion than the one provided by Kreyszig, which is
In[73]:=
150 -0.00133` t
2
Out[73]=
5
6 - 0.00133 t
2
Did DSolve give the wrong result? A common mistake when using Mathematica is to
prematurely substitute specific constants as I did above. It is often advisable to solve
equations entirely in symbolic form and substitute constants later. 
In[74]:=
eq = 8h'@tD ã -k1 Sqrt@h@tDD, h@0D == h0<;
sol = FullSimplify@DSolve@eq, h@tD, tD@@1DDD
Out[75]=
;h@tD Ø
1
4
-2
h0 + k1 t
2
?
Although this did not get us all the way to the form of the book’s solution, you are
more likely to see the final transformation that will demonstrate that DSolve was cor-
rect. It hinges on noticing that 1/4 is the same as (|1/2)*(|1/2).
1
4
-2
h0 +k1 t
2
ã
1
4
-2
h0 +k1 t
-2
h0 +k1 t ã
-
1
2
-2
h0 +k1 t -
1
2
-2
h0 +k1 t
ã
h0 -
k1
2
t
h0 -
k1
2
t ã
h0 -
k1
2
t
2
440 | Chapter 11:  Calculus: Continuous and Discrete

Substituting h0 and k1 with the constants shows that Mathematica did get the cor-
rect solution. Alternatively, you can ask Mathematica to prove its solution is equal
to the book’s solution by using Resolve and ForAll. The only problem here is that
Mathematica does not show its work!
In[76]:=
ResolveBForAllB8h0, k1, t<,
1
4
-2
h0 + k1 t
2
ã
h0 -
k1
2
t
2
F F
Out[76]=
True
11.7 Solving Minima and Maxima Problems
Problem
You want to find the minimum or maximum values of a function. You may need to
find these extremes subject to constraints or for numbers in a specific domain (e.g.,
integers).
Solution
Although there are standard techniques used in calculus for finding extrema, Mathe-
matica provides the specific functions Minimize and Maximize, which provide a great
deal of power.
In[77]:=
MaximizeA1 - H-2 + xL2 - H-1 + xL4, xE êê N
Out[77]=
80.710727, 8x Ø 1.58975<<
In[78]:=
Minimize@2 x^4 - 3 x^2 + x, xD êê N
Out[78]=
8-2.0293, 8x Ø -0.939693<<
Discussion
For many applications of minimization or maximization, you are interested in the ex-
treme value within a specific interval. 
In[79]:=
Maximize@8HHx - 3L^3 - 2 x^2 - xL, -1 < x < 4<, xD êê N
Out[79]=
8-9.3726, 8x Ø 1.48085<<
I restrict this discussion to Maximize for simplicity, but everything here applies
to  Minimize as well. If you are interested in displaying the result of Maximize, you
will want to force the result to numerical form, as we did in the solution. Maximize
will keep the result in exact form if it is given input in exact form. For polynomials,
this typically means the result will be expressed in terms of radicals or Root objects.
A Root[f,k] object represents the kth solution to a polynomial equation f[x] == 0. 
11.7 Solving Minima and Maxima Problems | 441

In[80]:=
Maximize@8HHx - 3L^3 - 2 x^2 - xL, -1 < x < 4<, xD
Out[80]=
;-27 +
26
3
11 -
43
-
11
9
11 -
43
2
+
1
27
11 -
43
3
,
;x Ø
1
3
11 -
43
??
In[81]:=
MaximizeA1 - H-2 + xL2 - H-1 + xL4, xE
Out[81]=
:-4 + 8 RootA-4 + 7 Ò1 - 6 Ò12 + 2 Ò13 &, 1E -
7 RootA-4 + 7 Ò1 - 6 Ò12 + 2 Ò13 &, 1E2 + 4 RootA-4 + 7 Ò1 - 6 Ò12 + 2 Ò13 &, 1E3 -
RootA-4 + 7 Ò1 - 6 Ò12 + 2 Ò13 &, 1E4, 9x Ø RootA-4 + 7 Ò1 - 6 Ò12 + 2 Ò13 &, 1E=>
Sometimes you want to find solutions for integer values only. You can constrain
Maximize to the integers in one of two ways. You might recognize this problem as an
instance of a knapsack problem where you are optimizing the value of the knapsack
(item1 has value 8, item2 11, and so on) subject to size constraint of 14 where item1
has size 5 and so on.
In[82]:=
MaximizeA98 x1 + 11 x2 + 6 x3 + 4 x4,
5 x1 + 7 x2 + 4 x3 + 3 x4 § 14 && x1 < 2 && x2 < 2 && x3 < 2 &&
x4 < 2 && ElementAx1
x2
x3
x4, IntegersE=, 8x1, x2, x3, x4<E
Out[82]=
821, 8x1 Ø 0, x2 Ø 1, x3 Ø 1, x4 Ø 1<<
A more convenient notation when all variables are integer is to specify the domain as
the third argument to Maximize. 
In[83]:=
MaximizeA88 x1 + 11 x2 + 6 x3 + 4 x4, 5 x1 + 7 x2 + 4 x3 + 3 x4 § 14 &&
x1 < 2 && x2 < 2 && x3 < 2 && x4 < 2<, 8x1, x2, x3, x4<, IntegersE
Out[83]=
821, 8x1 Ø 0, x2 Ø 1, x3 Ø 1, x4 Ø 1<<
Maximize  seeks  a  global  maximum,  whereas  an  alternative  function,  FindMaximum,
seeks a local maximum (there is also FindMinimum for local minimums). FindMaximum
allows you to specify a starting point for the search, but otherwise has a very similar
form to Maximize. The following program demonstrates the difference between Maxi-
mize and FindMaximum. The advantage  of  FindMaximum  is  that  it  does  not  require
the objective function to be differentiable.
442 | Chapter 11:  Calculus: Continuous and Discrete

In[84]:=
Clear@"Global`*"D;
f@x_D := x Cos@0.1 Exp@xDD Sin@0.1 Pi Exp@xDD ;
globalMax = Maximize@8f@xD, 0 < x < 5<, xD;
localMax = FindMaximum@f@xD, 8x, 0<D;
PlotAf@xD, 8x, 0, 5<, Epilog Ø 9PointSize@0.02D,
Red, Point@8x, f@xD<D ê. LastAglobalMaxE ,
Blue, Point@8x, f@xD<D ê. Last@localMaxD=E
Out[88]=
1
2
3
4
5
-2
2
4
11.8 Solving Vector Calculus Problems
Problem
You want to find solutions to problems within vector fields. Such problems arise in
mechanics, electromagnetic theory, and fluid dynamics.
Solution
Simple vector calculus problems can be solved in terms of the calculus primitives dis-
cussed in this chapter’s recipes along with vector functions like Dot and Cross. For ex-
ample, line integrals are commonly used to calculate work performed when moving
a particle along a path in a vector field. Here F is the vector equation of the field, f is
the equation of the path through the field, var is the parameter of f, and a and b are
the start and end points of the path.
In[89]:=
lineIntegral@F_, f_, var_, a_, b_D :=
Integrate@Dot@F@f@varDD, D@f@varD, varDD, 8var, a, b<D
FA9x_, y_, z_=E := 9x + y, y^2, x - z=
f@t_D := 8-t + 1, t + 2, -6 t + 1<
lineIntegral@F, f, t, 0, 1D
Out[92]=
-
35
3
11.8 Solving Vector Calculus Problems | 443

Another common operation in vector calculus is the surface integral over scalar func-
tions and vector fields. Surface integrals are the 2D analog of line integrals. One way
to think of the scalar surface integral is to imagine a surface f made of a material
whose density varies as described by a second function g. The surface integral of f
over g is then the mass per unit thickness. 
In[93]:=
surfaceIntegralScalarAg_, f_, 8v1_, v1a_, v1b_<, 8v2_, v2a_, v2b_<E :=
IntegrateAg@f@v1, v2DD Norm@Cross@D@f@v1, v2D, v1D, D@f@v1, v2D, v2DDD,
8v1, v1a, v1b<, 8v2, v2a, v2b<E
For example, consider the surface f1, which is a half sphere over the interval {f, 0,
Pi/2} and {q, 0, 2 Pi}, and compute the surface integral given a density function
given by (x^2 + y^2) z.
In[94]:=
f1@f_, q_D := 8Sin@fD Cos@qD, Sin@fD Sin@qD, Cos@fD<
g1A9x_, y_, z_=E := Ix^2 + y^2M z
surfaceIntegralScalarAg1, f1, 8f, 0, Piê2<, 8q, 0, 2 Pi<E
Out[96]=
p
2
If we use a constant function (uniform density), we get the surface area of the half sphere
as expected (surface area of an entire sphere is 4 pr2).
In[97]:=
g2A9x_, y_, z_=E := 1
surfaceIntegralScalarAg2, f1, 8f, 0, Piê2<, 8q, 0, 2 Pi<E
Out[98]=
2 p
For a vector field, there is a similar equation using Dot in place of scalar multiplication
by the norm. The traditional way to visualize the vector surface interval is to consider
a fluid flowing through a surface where there is a vector function F describing the ve-
locity of the fluid at various points on the surface. The surface integral is then the
flux, or the quantity of fluid flowing through the surface in unit time.
In[99]:=
surfaceIntegralVector@F_, f_, 8v1_, v1a_, v1b_<, 8v2_, v2a_, v2b_<D :=
Integrate@Dot@F@f@v1, v2DD, Cross@D@f@v1, v2D, v1D, D@f@v1, v2D, v2DDD,
8v1, v1a, v1b<, 8v2, v2a, v2b<D
Here is the solution to the flux described by {3 y, -z, x^2} through a surface de-
scribed parametrically as {s t, s + t, (s^2 - t^2)/2}.
In[100]:=
f@s_, t_D := 8s t, s + t, Hs^2 - t^2Lê2<
FA9x_, y_, z_=E := 93 y, -z, x^2=
surfaceIntegralVector@F, f, 8s, 0, 1<, 8t, 0, 3<D
Out[102]=
-15
444 | Chapter 11:  Calculus: Continuous and Discrete

A standard result from electrostatics is that the net flux out of a unit sphere, for a
field that is everywhere normal, is zero. We can verify this as follows:
In[103]:=
F2A9x_, y_, z_=E := 81, 1, 1<ë Ix^2 + y^2 + z^2M
In[104]:=
f2@q_, f_D := 8Sin@fD Cos@qD, Sin@fD Sin@qD, Cos@fD<
In[105]:=
surfaceIntegralVector@F2, f2, 8q, 0, 2 Pi<, 8f, 0, Pi<D
Out[105]=
0
Discussion
The solution  shows how the calculus primitives and other Mathematica functions
can be used to build up higher-order vector calculus solutions. However, if you are
interested in solving problems in vector calculus, the package VectorAnalysis` is defi-
nitely worth a look. Be forewarned that you might be in for a bit of a learning curve
with this particular package, but it offers a lot of functionality. An important feature
of  the  package  is  that  it  simplifies  working  in  different  coordinate  systems.
Before you can make effective use of VectorAnalysis`, you need to understand how
coordinate  systems  are  used  and  which  coordinate  system  is  appropriate  to  your
problem.
In[106]:=
NeedsA"VectorAnalysis`"E
In[107]:=
CoordinateSystem
Out[107]=
Cartesian
In[108]:=
SetCoordinates@SphericalD
Out[108]=
Spherical@Rr, Ttheta, PphiD
In[109]:=
CoordinateSystem
Out[109]=
Spherical
When you use VectorAnalysis`, you will typically want to use functions in that pack-
age in place of some standard Mathematica functions such as Dot and Cross. This is
because  the  alternatives  DotProduct  and  CrossProduct  respect  the  current  coordi-
nate system. For example, if the current coordinate system is Spherical, you expect
the following DotProduct to be zero because the vectors are orthogonal in spherical
coordinates.
In[110]:=
DotProduct@81, Piê2, 0<, 81, Piê2, Piê2<D
Out[110]=
0
11.8 Solving Vector Calculus Problems | 445

In contrast, Dot and Cross always assume Cartesian coordinates.
In[111]:=
Dot@81, Piê2, 0<, 81, Piê2, Piê2<D
Out[111]=
1 +
p2
4
Some  of  the  most  important  vector  calculus  operations  are  Div  (divergence),  Grad
(gradient), Curl, and the Laplacian. Although it would make a nice exercise to imple-
ment these from the calculus primitives, as I did for line and surface integrals, there
is no need if you use the VectorAnalysis` package. These operations use the default
coordinate  system,  or  you  can  specify  a  specific  coordinate  system  as  a  separate
argument.
The divergence represents the instantaneous outflow of a vector field at each point.
In[112]:=
TogetherADivA81, 1, 1<ë Ix^2 + y^2 + z^2M, CartesianAx, y, zEEE
Out[112]=
-
2 Ix + y + zM
Ix2 + y2 + z2M2
The curl of a vector field represents the amount of rotation.
In[113]:=
TogetherACurlA81, 1, 1<ë Ix^2 + y^2 + z^2M, CartesianAx, y, zEEE
Out[113]=
;-
2 Iy - zM
Ix2 + y2 + z2M2 ,
2 Hx - zL
Ix2 + y2 + z2M2 , -
2 Ix - yM
Ix2 + y2 + z2M2 ?
By  definition,  the  divergence  of  the  curl  must  be  zero  since  the  curl  has  no  net
outflow.
In[114]:=
SetCoordinatesACartesianAx, y, zEE;
DivACurlA81, 1, 1<ë Ix^2 + y^2 + z^2MEE
Out[115]=
0
The gradient of a function f is a vector-valued function that indicates the direction
in which f is increasing most rapidly. If you were climbing a hill, you would move in
the direction of the gradient at each point to reach the top (strictly speaking the gradi-
ent would only be guaranteed to be directing you to a local peak). You can visualize
the meaning of the gradient by using VectorPlot. I restrict the result to 2D for easier
visualization. 
446 | Chapter 11:  Calculus: Continuous and Discrete

In[116]:=
GraphicsRowA9Plot3DAx2 y3, 8x, -1, 1<, 9y, -1, 1=, PlotRange Ø FullE,
VectorPlotAEvaluateADropAGradA x2 y3 1, CartesianAx, y, zEE, -1EE,
8x, -1, 1<, 9y, -1, 1=E=, ImageSize Ø 500E
Out[116]=
See Also
The Mathematica tutorial to the VectorAnalysis package is essential reading for us-
ing those functions.
Div, Grad, Curl, and All That by H. M. Schey (W.W. Norton) and Vector Calculus
by Paul C. Matthews (Springer) are two of my favorite informal introductions to vec-
tor calculus.
11.9 Solving Problems Involving Sums 
and Products
Problem
You want to solve problems in discrete calculus that are expressed in terms of sums
or products.
Solution
Mathematica can handle infinite sums and products with ease, provided, of course,
they converge.
In[117]:=
‚
n=1
¶
1
n2
Out[117]=
p2
6
11.9 Solving Problems Involving Sums and Products | 447

In[118]:=
‰
i=2
¶
1 -
1
i3
Out[118]=
CoshC
3 p
2
G
3 p
Discussion
If sums or products don’t converge, Mathematica will let you know by emitting an
error.  You  can  test  for  convergence  without  evaluating  the  sum  using  Sum-
Convergence.
In[119]:=
‚
n=1
¶ 1
n
Sum::div : Sum does not converge. à
Out[119]=
‚
n=1
¶ 1
n
In[120]:=
TableB:
1
nk
, SumConvergenceB
1
nk
, nF>, 8k, 1, 4<F êê TableForm
Out[120]//TableForm=
1
n
False
1
n2
True
1
n3
True
1
n4
True
As with Integrate, Sum can specify multiple summation variables. In traditional
form these sums are rendered as a multiple summation, but keep in mind that these
are  entered  as  Sum[expr,{n,nmin,nmax},{m,mmin,mmaz}]  rather  than  Sum[Sum[expr,
{n,nmin,nmax}],{m,mmin,mmaz}].
This double summation has a surprisingly simply solution.
In[121]:=
‚
m=1
¶
‚
n=1
¶
m2 n
2m Hm 2n + 2m nL
Out[121]=
2
This is a very famous sum attributed to Srinivasa Ramanujan, one of India’s greatest
mathematical geniuses. You might think that Mathematica is just doing some simple
pattern matching to recognize this result; however, substitute for any of the magic
448 | Chapter 11:  Calculus: Continuous and Discrete

constants in this formula, and Mathematica will handle it just as well (but don’t ex-
pect the answer to be as pretty).
In[122]:=
2
2
9801
‚
k=0
¶ H4 kL! H1103 + 26390 kL
Hk!L4 3964 k
Out[122]=
1
p
In[123]:=
‚
k=0
¶ H3 kL! H5 + 10 kL
Hk!L4 3004 k
Out[123]=
1
135000000
675000000 HypergeometricPFQC;
1
3
,
2
3
?, 81, 1<,
1
300 000 000
G +
HypergeometricPFQC;
4
3
,
5
3
?, 82, 2<,
1
300 000 000
G
Here  is  a  very  pretty  formula  for  p  that  combines  an  infinite  sum  and  an  infinite
product.
In[124]:=
¤n=1
¶
J1 +
1
4 n2-1 N
⁄n=1
¶
1
4 n2-1
Out[124]=
p
As of version 7, Mathematica can handle indefinite sums and products. Mathemat-
ica will seek to eliminate the sum if possible. For example, the sum over k of a polyno-
mial is another polynomial that can be expressed in terms of k, and products over
polynomials will invariably reduce to some expression involving Gamma.
In[125]:=
‚
k
I3 k3 - k2 + 3 k + 5M
Out[125]=
1
12
k I40 + 33 k - 22 k2 + 9 k3M
In[126]:=
‰k Ik2 - 3 k + 5M
Out[126]=
3 CoshC
11 p
2
G GammaC-
3
2 -
Â
11
2
+ kG GammaC-
3
2 +
Â
11
2
+ kG
p
The Z-transform is an important infinite sum used in signal processing. It is defined
as Sum[f[n] z^-n,{n,0,Infinity}], but is directly supported using ZTransform.
In[127]:=
ZTransform@n^2, n, zD
Out[127]=
z H1 + zL
H-1 + zL3
11.9 Solving Problems Involving Sums and Products | 449

Here is an unconventional application for Sum, but one that is sometimes used in dis-
crete math to introduce the idea of a generating function. You can use Sum to con-
struct a generating function for solutions to problems like x1+x2+x3 == 12 subject to
x1 >= 4, x2 >= 2, and 5 >= x3 >= 2. Each Sum is constructed from the smallest num-
ber the associated variable can take to the largest, by considering the smallest the
other variables can take. For example, x1 must be at least 4 but can’t be greater than
12|2|2 = 8, since x2 and x3 must each be at least 2. Here we use Expand to generate
the  polynomial  and  Cases  to  find  the  exponents  that  sum  to  12,  thus  giving  all
solutions.
In[128]:=
CasesB ExpandB‚
n=4
8
x1n ‚
n=2
6
x2n ‚
n=2
5
x3n F,
x1n1_ x2n2_ x3n3_ ê; n1 + n2 + n3 ã 12 ß 8n1, n2, n3<F
Out[128]=
888, 2, 2<, 87, 3, 2<, 86, 4, 2<, 85, 5, 2<, 84, 6, 2<, 87, 2, 3<, 86, 3, 3<,
85, 4, 3<, 84, 5, 3<, 86, 2, 4<, 85, 3, 4<, 84, 4, 4<, 85, 2, 5<, 84, 3, 5<<
If you only care about the number of solutions, it would fall out of the coefficient of
x12 in the expansion of this polynomial.
In[129]:=
CasesB ExpandB‚
n=4
8
xn ‚
n=2
6
xn ‚
n=2
5
xn F, a_ x12 ß aF
Out[129]=
814<
See Also
See Recipe 11.11 for more information on generating functions in Mathematica.
Readers  who  are  interested  in  gaining  insight  into  the  algorithms  that  underlie
Mathematica’s  amazing  feats  with  infinite  sums  should  read  A=B  by  Marko
Petkovsek, Herbert S. Wilf, and Doron  Zeilberger  (A  K  Peters),  which  is  avail-
able online at http://bit.ly/1LJiwe.
11.10 Solving Difference Equations
Problem
You want to solve problems that arise in discrete systems such as finance, actuarial
science,  dynamical  systems,  and  numerical  analysis.  Many  such  problems  can  be
modeled as recurrence relations, also known as difference equations.
450 | Chapter 11:  Calculus: Continuous and Discrete

Solution
RSolve is used to solve difference equations. A simple problem where RSolve applies
is in mortgage calculations. Suppose you want to derive a function for the outstand-
ing principal over the life of a loan. Let’s say the yearly interest rate is 5.75%, the
monthly payment is $1,000.00, and the term is 30 years. This loan can be described
as the following difference equation. Here the constraint y[360] == 0 arises from the
condition that the last payment is zero (I am using y[0] as the origin).
In[130]:=
i = 0.0575;
payment = 1000.00;
sol = RSolveA9y@n + 1D ã H1 + iê12L y@nD - payment, y@360D ã 0=, y, nE
Out[132]=
99y Ø FunctionA8n<, 0.995231µ2.71828-0.00478022 n
I209696.µ1.00479n - 37516.4µ1.00479n 2.718280.00478022 nME==
From this we can figure out the initial principal or the payoff at any given month:
In[133]:=
y@0D ê. sol@@1DD
Out[133]=
171358.
After 60 months, or 5 years, very little has been paid off, which is quite depressing
but a fact of life.
In[134]:=
y@0D - y@60D ê. sol@@1DD
Out[134]=
12402.6
Discussion
Setting up a difference equation is often a matter of solving the problem by hand for
small values of n and then detecting the relationship between successive values.
Consider the Towers of Hanoi puzzle. A one-disk problem is solved in one move
(T[1] = 1), a two-disk problem is solved in three moves (T[2] = 3), and three-disk
problem is solved in seven moves (T[3] = 7). It follows then that T[n] = 2 T[n-1] + 1.
In[135]:=
RSolve@8T@nD ã 2 T@n - 1D + 1, T@1D ã 1<, T, nD
Out[135]=
99T Ø FunctionA8n<, -1 + 2nE==
A seemingly innocent difference equation can result in a solution involving complex
numbers. This is a second-order equation, so two initial values are required to get an
exact solution with no arbitrary constants.
In[136]:=
sol = RSolve@8a@nD == 2 Ha@n - 1D - a@n - 2DL, a@0D == 1, a@1D ã 2<, a, nD
Out[136]=
;;a Ø FunctionC8n<,
1
2
+
Â
2
IH1 - ÂLn - Â H1 + ÂLnMG??
11.10 Solving Difference Equations | 451

Note that like DSolve, RSolve does not try to simplify the result. It is advisable to try
to simplify it; in this case, you see that complex numbers disappear, and the result is
in terms of trigonometric functions, which you may not have expected.
In[137]:=
FullSimplify@a@nD ê. sol@@1DDD
Out[137]=
H1 - ÂL-1+n + H1 + ÂL-1+n
As with DSolve, if you do not provide initial conditions, you will get solutions in-
volving arbitrary constants of the form C[N]. 
In[138]:=
RSolve@8a@nD - 3 a@n - 1D ã 5 H3^nL<, a, nD
Out[138]=
99a Ø FunctionA8n<, 5 µ 3n n + 3-1+n C@1DE==
These solutions were found in terms of pure functions because we asked for the solu-
tion in terms of a, but you can change the form of the second argument to a[n] to
get the solution in that form.
In[139]:=
sol = RSolve@8a@nD - 3 a@n - 1D ã 5 H3^nL<, a@nD, nD
Out[139]=
99a@nD Ø 5 µ 3n n + 3-1+n C@1D==
You can evaluate this solution for specific n and C[1] using ReplaceAll (//.).
In[140]:=
a@nD êê. Flatten@8sol, n Ø 3, C@1D Ø 2<D
Out[140]=
423
See Also
One of the best introductions to the subject of difference equations is An Introduc-
tion to Difference Equations by Saber Elaydi (Springer).
11.11 Generating Functions 
and Sequence Recognition
Problem
You want Mathematica to generate a function associated with a particular sequence
or to infer a function that will produce the sequence for successive integers.
452 | Chapter 11:  Calculus: Continuous and Discrete

Solution
Use  FindGeneratingFunction  to  derive  the  generating  function  for  a  sequence.
Recall  that  the  power  series  of  a  generating  function  encodes  the  sequence  in  its
coefficients. 
In[141]:=
g = FindGeneratingFunction@81, 4, 9, 16, 25, 36, 49, 64, 81, 100<, xD
Out[141]=
-1 - x
H-1 + xL3
In[142]:=
SeriesAg, 8x, 0, 12<E
Out[142]=
1 + 4 x + 9 x2 + 16 x3 + 25 x4 + 36 x5 + 49 x6 +
64 x7 + 81 x8 + 100 x9 + 121 x10 + 144 x11 + 169 x12 + O@xD13
Use FindSequenceFunction to find an expression that maps the integers to the spec-
ified sequence.
In[143]:=
s = FindSequenceFunction@81, 4, 9, 16, 25, 36, 49, 64, 81, 100<, nD
Out[143]=
n2
In[144]:=
Table@s, 8n, 1, 12<D
Out[144]=
81, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144<
Discussion
FindSequenceFunction  can  deal  with  sequences  that  are  not  strictly  increasing  and
with noninteger sequences. 
In[145]:=
FindSequenceFunction@8-1, 3, -11, 13, -29, 31, -55,
57, -89, 91, -131, 133, -181, 183, -239<, nD êê FullSimplify
Out[145]=
H-1Ln I-H-1Ln H-1 + nL + n2M
In[146]:=
FindSequenceFunctionB:0,
2
9
,
3
8
,
12
25
,
5
9
,
30
49
,
21
32
,
56
81
,
18
25
,
90
121
>, xF
Out[146]=
-x + x2
H1 + xL2
You  can  synthesize  a  generating  function  from  an  expression  using  Generating-
Function.
In[147]:=
g = GeneratingFunctionB
1
Hn + 1L!
, n, xF
Out[147]=
-1 + ‰x
x
11.11 Generating Functions and Sequence Recognition | 453

And recover the sequence to the Nth term using the following expression:
In[148]:=
WithA8N = 12<,
1ë TableASeriesCoefficientASimplifyASeriesAg, 8x, 0, N<EE, nE, 8n, 1, N<EE
Out[148]=
82, 6, 24, 120, 720, 5040, 40320, 362 880,
3628800, 39916800, 479001600, 6227 020 800<
See Also
For the nonexpert, a very approachable book on generating functions is Generating-
functionology by Herbert S. Wilf (A K Peters). An online version can be found at
http://bit.ly/3bkssK.
454 | Chapter 11:  Calculus: Continuous and Discrete

CHAPTER 12
Statistics and Data Analysis
Watching in a trance
The crew is certain
Nothing left to chance
...
Starting to collect
Requested data
“What will it affect
When all is done?”
Thinks Major Tom
Peter Schilling, “Major Tom (Coming Home)”
12.0 Introduction
Ask statisticians what software they use, and chances are (no pun intended), they
will mention SAS, SPSS, or maybe even R. Those systems are quite good, but most
are highly specialized for statistical work. With the release of version 7, Wolfram has
substantially beefed up the statistical capabilities of Mathematica. Given everything
else Mathematica can do, it is now a compelling alternative for statistics and data
analysis.  An  entire  Mathematica  statistical  cookbook  could  be  written;  therefore,
this chapter is necessarily incomplete. I have selected these recipes for this chapter
to provide jumping-off points for further exploration. You should consult the Mathe-
matica  documentation  for  more  depth,  and  nonexperts  should  consider  Sarah
Boslaugh  and  Paul  Andrew  Watters’  Statistics  in  a  Nutshell  (O’Reilly)  for  a  broad
overview of the relevant concepts. 
Even readers without much interest in statistics are encouraged to skim these recipes
because  there  are  demonstrations  here  that  have  application  outside  statistics
proper.  Most  users  of  Mathematica  are  comfortable  with  basic  statistical  metrics,
such as mean and variance, but perhaps you are rusty on quantiles. All are covered
in Recipe 12.1. Every programmer needs to generate random numbers from time to
time, and it is useful to know how to use different distributions beside the standard
455

uniform distribution (Recipe 12.2). Students and teachers of probability will appreci-
ate Mathematica’s ability to manipulate and plot a variety of common (and not so
common) distributions (Recipe 12.3) as well as the ability to illustrate statistical theo-
rems and puzzles (Recipes 12.4 and 12.16). Advanced statisticians and researchers
will get a lot of use out of Mathematica’s data analysis features, covered in Recipes
12.5 through 12.13. Finally, Recipe 12.14 demonstrates plots that are specific to sta-
tistical analysis.
This chapter often synthesizes data using random generation. In these cases, I seed
the  random  number  generator  with  a  specific  seed  so  the  results  are  repeatable.
There is no magic behind the seeds specified other than they provided a reasonable
result. When I use specific data in these recipes, it is plausible but entirely fabricated
and should not be construed as coming from an actual experiment.
12.1 Computing Common Statistical Metrics 
of Numerical and Symbolic Data
Problem
You want to perform common statistical analysis of data sets. These metrics repre-
sent the entry-level statistical functions that all users of Mathematica should have un-
der their belts.
Solution
It should come as little surprise that Mathematica is equipped with the standard sta-
tistical functions. Here I use the byte count of Mathematica files on my folder as a
source of data.
In[1]:=
data = NA FileByteCount êü
FileNamesAFileNameJoinA9NotebookDirectory@D, "*.nb"=EEE;
H*Compute the mean.*L
Mean@dataD
Out[2]=
2.45023µ106
The statistical functions you will use most in Mathematica (Mean, Median, Max, Min,
Variance,  and  StandardDeviation)  have  obvious  names  and  obvious  uses.  Here  I
456 | Chapter 12: Statistics and Data Analysis

get a bit fancy by computing a table in one step by using Through with the list of
functions.
In[3]:=
ModuleA8statFuncs<,
statFuncs = 8Mean, Median, Max, Min, Variance, StandardDeviation<;
TableFormA9Through@statFuncs@ dataDD=,
TableHeadings Ø 9None, ToString êü statFuncs=EE
Out[3]//TableForm=
Mean
Median
Max
Min
Variance
StandardDeviation
2.45023µ106
114698. 3.62386µ107
1019. 3.94825µ1013 6.28351µ106
Not quite as pedestrian, quantiles are a common concept in statistics that general-
izes the concept of median to other subdivisions.
In[4]:=
H*Find the lower quantile.*L
Quantile@data, 1ê4D
Out[4]=
14412.
In[5]:=
H*Find the 1ê2, 1ê3, 1ê4, ... 1ê10.*L
Quantile@data, ÒD & êü Table@1ên, 8n, 2, 10<D
Out[5]=
8114698., 26623., 14412., 7712., 6102., 5456., 4775., 3865., 3514.<
In[6]:=
Quantile@data, 1ê2D
Out[6]=
114698.
When used with default parameters Quantile always returns some element in the ac-
tual list. Thus, Quantile[data, 1/2] may not be the same as Median.
In[7]:=
Quantile@data, 1ê2D ã Median@dataD
Out[7]=
True
With the following parameters, Quantile and Median are identical. See Quantile docu-
mentation for the meaning of these parameters.
In[8]:=
Quantile@data, 1ê2, 881ê2, 0<, 80, 1<<D ã Median@dataD
Out[8]=
True
Discussion
The basic functions covered in the solution are no doubt familiar and hardly warrant
further elaboration except to note their generality. 
All of the statistics functions in Mathematica work with SparseArray, which is very
convenient when you have a very large but sparse data set.
In[9]:=
NAMeanASparseArray@81 Ø 10, 2 Ø 11, 3 Ø 12, 4 Ø 11<, 810 000<, 7DEE
Out[9]=
7.0016
12.1 Computing Common Statistical Metrics of Numerical and Symbolic Data | 457

Further, given Mathematica’s symbolic nature, you should not be too surprised that
it can do more than other common data analysis applications, such as MS Excel. 
In[10]:=
Clear@a, b, c, dD;
Variance@8a, a, a, c, c, b, d, d<D
Out[11]=
1
56
I3 H5 a - b - 2 c - 2 dL Conjugate@aD + H-3 a + 7 b - 2 c - 2 dL Conjugate@bD +
2 H-3 a - b + 6 c - 2 dL Conjugate@cD + 2 H-3 a - b - 2 c + 6 dL Conjugate@dDM
What does this result mean? It is the formula for computing the variance of a set of
data with 3 a’s, 1 b, 2 c’s and 2 d’s. You can use this formula using ReplaceAll.
In[12]:=
Variance@8a, a, a, c, c, b, d, d<D ê. 8a Ø 1, b Ø 2, c Ø 3, d Ø 4<
Out[12]=
95
56
This is exactly the result you would get if you took the direct route.
In[13]:=
Variance@81, 1, 1, 3, 3, 2, 4, 4<D
Out[13]=
95
56
This  may  seem  completely  academic;  for  many  of  you,  it  will  be  so.  Yet  consider
that symbolic form allows you to perform further symbolic manipulations that ac-
count for properties you may know about the symbolic data. For example, imagine
the items were all angles in radians in a given relationship and you wanted to know
the formula for the variance of their sine. Such examples are contrived only until you
need to do a similar transformation.
In[14]:=
TrigFactorAFullSimplify@
Variance@8a, a, a, c, c, b, d, d<D ê. 8a Ø Sin@xD, b Ø Sin@2 xD,
c Ø Sin@3 xD, d Ø Sin@4 xD<, Assumptions Ø x œ Reals DE
Out[14]=
1
14
CosC
x
2
G
2
H93 - 100 Cos@xD + 94 Cos@2 xD -
64 Cos@3 xD + 64 Cos@4 xD - 16 Cos@5 xD + 24 Cos@6 xDL SinC
x
2
G
2
These symbolic capabilities also imply you can use these functions with common dis-
tributions rather than on individual values.
In[15]:=
9MeanALogNormalDistribution@0, 1DE, Variance@HalfNormalDistribution@1DD,
StandardDeviation@InverseGaussianDistribution@1, 2DD=
Out[15]=
;
‰ ,
1
2
H-2 + pL,
1
2
?
458 | Chapter 12: Statistics and Data Analysis

Another common statistical metric is the mode. This function is called Commonest in
Mathematica and can be used to find the commonest or the n commonest. Related
to this is a new function in version 7, Tally, that gives the individual counts.
In[16]:=
list = FirstA RealDigits@Pi, 10, 50DE;
In[17]:=
8Commonest@listD, Commonest@list, 3D<
Out[17]=
883<, 83, 1, 9<<
In[18]:=
Tally@listD
Out[18]=
883, 9<, 81, 5<, 84, 4<, 85, 5<, 89, 8<, 82, 5<, 86, 4<, 88, 5<, 87, 4<, 80, 1<<
See Also
There  is  a  multivariate  statistics  package  (see  MultivariateStatistics/guide/Multivariate
StatisticsPackage) that generalizes notions of mean, median, and so on, to multiple
dimensions. Here you will find functions such as SpatialMedian, SimplexMedian, and
PolytopeQuantile, which clearly are targeted at specialists.
12.2 Generating Pseudorandom Numbers 
with a Given Distribution
Problem
You want to generate random numbers that have nonuniform distributions. Many
recipes in this book use RandomReal and RandomInteger, but these functions give uni-
form distributions unless you specify otherwise. 
Solution
Both RandomReal and RandomInteger can take a distribution as their first argument.
RandomReal uses continuous distributions, including NormalDistribution, HalfNormal-
Distribution,  LogNormalDistribution,  InverseGaussianDistribution,  GammaDistribution,
ChiSquareDistribution, and others. RandomInteger uses discrete distributions, such
as  BernoulliDistribution,  GeometricDistribution,  HypergeometricDistribution,
PoissonDistribution, and others.
In[19]:=
RandomReal@NormalDistribution@D, 10D
Out[19]=
8-0.96524, 1.19926, 0.989088, 0.156427, -0.336326,
-1.66671, 0.149802, -0.464219, -0.998164, 0.948215<
In[20]:=
RandomInteger@PoissonDistribution@5D, 10D
Out[20]=
85, 2, 6, 5, 6, 4, 3, 4, 4, 5<
12.2 Generating Pseudorandom Numbers with a Given Distribution | 459

Discussion
You can visualize distributions using BinCounts and BarChar.
In[21]:=
GraphicsRowA
9BarChartABinCountsARandomInteger@GeometricDistribution@0.3D, 5000DEE,
BarChartABinCountsARandomInteger@PoissonDistribution@5D, 5000DEE=E
Out[21]=
Another way to visualize the various continuous distributions is to generate a ran-
dom raster using each distribution. How would you rewrite this to remove the re-
dundancy? (Hint: functional programming!)
In[22]:=
GraphicsGridA99Graphics@Point@RandomReal@80, 1<, 8500, 2<DDD,
Graphics@Point@RandomReal@NormalDistribution@D, 8500, 2<DDD,
Graphics@Point@RandomReal@HalfNormalDistribution@1D, 8500, 2<DDD,
GraphicsAPointARandomRealALogNormalDistribution@0, 1D, 8500, 2<EEE,
Graphics@
Point@RandomReal@InverseGaussianDistribution@1, 1D, 8500, 2<DDD=,
9"Uniform", "Normal", "HalfNormal", "LogNormal", "InverseGaussian"==E
Out[22]=
Uniform
Normal
HalfNormal
LogNormal
InverseGaussian
460 | Chapter 12: Statistics and Data Analysis

See Also
Other  useful  functions  to  explore  in  the  Mathematica  documentation  are  Seed-
Random, BlockRandom, and RandomComplex. 
See Recipe 12.12 for a common method for testing random generators based on the
chi-square distribution.
12.3 Working with Probability Distributions
Problem
You want to compute the probability density function (PDF) and cumulative density
function (CDF) of various distributions. You may also want to determine the charac-
teristic function of the associated distribution. 
Solution
Use PDF to compute the probability density function and CDF to compute the cumu-
lative density function. I illustrate the use of these functions using the standardized
normal distribution (mean 0 and variance 1).
In[23]:=
Plot@PDF@NormalDistribution@0, 1D, xD, 8x, -3, 3<D
Out[23]=
-3
-2
-1
1
2
3
0.1
0.2
0.3
0.4
12.3 Working with Probability Distributions | 461

In[24]:=
Plot@CDF@NormalDistribution@0, 1D, xD, 8x, -3, 3<D
Out[24]=
-3
-2
-1
1
2
3
0.2
0.4
0.6
0.8
1.0
Discussion
The CDF is obtained from the PDF by integrating the PDF from |¶ to x, which you
can illustrate in Mathematica very easily. The implementation given here is designed
to execute the integration only once and then store it as a new function for subse-
quent evaluation, so it is almost as fast as the built-in CDF. There is no compelling
reason to use this over the built-in CDF implementation. It is here strictly as an illustra-
tion of the relationship. If you use Mathematica to teach statistics, it is a good idea
to peek under the covers of black box functions like CDF whenever possible.
In[25]:=
cdf@dist_D := cdf@distD =
FunctionA8x<, EvaluateAIntegrateAPDF@dist, x1D, 9x1, -Infinity, x=EEE
Plot@cdf@NormalDistribution@0, 1DD@xD, 8x, -3, 3<D
Out[26]=
-3
-2
-1
1
2
3
0.2
0.4
0.6
0.8
1.0
462 | Chapter 12: Statistics and Data Analysis

Clearly, you can also obtain the closed-form formula for the CDF of any particular
distribution.
In[27]:=
Integrate@PDF@NormalDistribution@0, 1D, xD, xD
Out[27]=
1
2
ErfC
x
2
G
Find the value at |¶.
In[28]:=
% êê. x Ø -Infinity
Out[28]=
-
1
2
So the closed-form value for the CDF of the normal distribution is 
In[29]:=
cumNormDist@x_D := Erf@xêSqrt@2DDê2 + 0.5
The  classic  application  of  a  PDF  is  in  computing  the  probability  that  a  particular
value  falls  within  some  range.  For  example,  consider  the  probability  of  a  value
falling between 0 and 0.25 for various distributions.
In[30]:=
Integrate@PDF@Ò, xD, 8x, 0, 0.25<D & êü
8UniformDistribution@80, 1<D, NormalDistribution@0, 1D,
HalfNormalDistribution@1D, ChiSquareDistribution@2D<
Out[30]=
80.25, 0.0987063, 0.158106, 0.117503<
Based on the definition of the CDF, it is easy to see that it computes the probability
that a value will be less than or equal to a specific value. Subtracting the CDF from 1
will give the probability of a value being greater than a specified limit.
In[31]:=
H*Probability that a normally distributed random variable will
be less than or equal to 0.5*LCDF@NormalDistribution@0, 1D, 0.5D
Out[31]=
0.691462
In[32]:=
H*Probability that a normally distributed random variable will
be greater than 0.8*L1 - CDF@NormalDistribution@0, 1D, 0.8D
Out[32]=
0.211855
In[33]:=
H*Probability that a normally distributed random
variable will be less than -1 or greater than 1*L
CDF@NormalDistribution@0, 1D, -1.D +
H1 - CDF@NormalDistribution@0, 1D, 1.DL
Out[33]=
0.317311
12.3 Working with Probability Distributions | 463

When you plot a PDF, you can use ColorFunction to highlight regions of interest,
but  make  sure  you  also  set  Filling  Ø  Axis  and  ColorFunctionScaling  Ø  False.
Here I plot the regions of interest whose total area (and hence probability) is approxi-
mately 0.317311.
In[34]:=
PlotAPDF@NormalDistribution@0, 1D, xD, 8x, -3, 3<,
ColorFunction -> FunctionA9x, y=, IfAx < -1 »» x > 1, LightGray, WhiteEE,
Filling -> Axis, FillingStyle Ø Automatic, ColorFunctionScaling Ø False,
ImageSize -> Small, Axes Ø 8True, False<, Mesh Ø FullE
Out[34]=
Use CharacteristicFunction[dist,var] to extract the  characteristic  function  of  a
distribution  in  terms  of  a  variable  var.  Here  are  the  functions  for  five  common
distributions.
In[35]:=
Row@CharacteristicFunction@Ò, tD & êü 8UniformDistribution@80, 1<D,
NormalDistribution@0, 1D, HalfNormalDistribution@1D,
ChiSquareDistribution@2D, PoissonDistribution@3D<, ", "D
Out[35]=
-
Â I-1 + ‰Â tM
t
, ‰
-
t2
2 , ‰
-
p t2
4
1 + Â ErfiC
p t
2
G
,
1
1 - 2 Â t
, ‰
3 J-1+‰Â tN
See Also
Recipe 12.12 demonstrates an application of the chi-square distribution.
Recipe 12.6 demonstrates metrics for capturing the shapes of various distributions. 
12.4 Demonstrating the Central Limit Theorem
Problem
You want to illustrate the central limit theorem (CLT) to yourself or your students.
464 | Chapter 12: Statistics and Data Analysis

Solution
The  CLT  states  that  the  mean  of  sufficiently  large  samples  from  any  distribution
will  approximate  a  normal  distribution.  You  can  illustrate  this  by  averaging  suit-
ably  large  random  samples  from  a  nonnormal  distribution,  such  as  the  uniform
distribution.
In[36]:=
BarChart@BinCounts@Mean êü Table@RandomReal@8-100, 100<, 30D, 8200<DDD
Out[36]=
Discussion
The CLT is often stated in a very technical way. In Statistics in a Nutshell, Boslaugh
and Watters explain that the CLT “states that the sampling distribution of the sam-
ple mean approximates the normal distribution, regardless of the distribution of the
population from which samples are drawn, if the sample size is sufficiently large”
(137).  Other  references  define  it  in  an  equally  technical  way.  The  solution  shows
that the concept is not difficult, although the result is certainly not obvious. The so-
lution demonstrates 200 samples of uniformly generated lists of random numbers,
each of length 30, being averaged and then the counts of each integer-valued range
being organized into bins and plotted. The shape looks roughly normal, which is the
prediction of the CLT. BinCounts, Mean, and RandomReal are relatively easy to under-
stand (see prior recipes), so this makes the idea behind the CLT rather concrete.
To further emphasize that this is not a property of the uniform distribution, you can
substitute other distributions. These use finer grained bins due to the tighter range
of numbers generated, but the result is similar. As an exercise, wrap a Manipulate
around the code in the “Solution” section above and adjust both the sample size and
the number of samples. This will illustrate that the validity of the CLT is predicated
on a sufficiently large number of samples of sufficiently large size.
12.4 Demonstrating the Central Limit Theorem | 465

In[37]:=
BarChart@BinCounts@Mean êü
Table@RandomReal@HalfNormalDistribution@0.5D, 40D, 81000<D, 0.05DD
Out[37]=
In[38]:=
BarChart@BinCounts@Mean êü
Table@RandomReal@ExponentialDistribution@1D, 25D, 81000<D, 0.05DD
Out[38]=
See Also
A proof of the CLT can be found at Wolfram MathWorld: http://bit.ly/S00Y1.
12.5 Computing Covariance and Correlation 
of Vectors and Matrices
Problem
You want to measure the relationship between data sets to see if they vary about the
mean in a similar way (covariance) or if there is a linear relationship (correlation).
466 | Chapter 12: Statistics and Data Analysis

Solution
In[39]:=
ModuleA8data1, data2, data3<,
data1 = 81, 3, 5, 7, 9, 11, 13<;
data2 = 82, 4, 6, 8, 10, 12, 14<;
data3 = 8100, 99, 98, 97, 96, 95, 94<;
TableFormA8
8Covariance@data1, data2D,
Covariance@data1, data3D, Covariance@data2, data3D<,
8Correlation@data1, data2D, Correlation@data1, data3D,
Correlation@data2, data3D<
< êê N, TableHeadings Ø 88"Covariance", "Correlation"<,
8"1 vs 2", "1 vs 3", "2 vs 3"<<EE
Out[39]//TableForm=
1 vs 2
1 vs 3
2 vs 3
Covariance
18.6667 -9.33333 -9.33333
Correlation 1.
-1.
-1.
Discussion
Covariance and Correlation both operate on matrices. If you pass a single matrix, it
will return a covariance (or correlation) matrix resulting from computing the covar-
iance between each column. To demonstrate this clearly, I’ll engineer a matrix with
an obvious relationship between the first and second column and a weak correlation
of these in a third column. The output matrix will always be symmetrical. The corre-
lation matrix will always have ones on the diagonal, since these entries represent cor-
relations of columns with themselves. You can also pass two matrices, in which case
you get the covariance (or correlation) with respective columns.
In[40]:=
SeedRandom@2D;
Hdata = Transpose@880, 1, 2, 3, 4, 5, 6, 7, 8, 9<,
80, 10, 20, 30, 40, 50, 60, 70, 80, 90<,
RandomReal@8-1, 1<, 10D<DL êê TableForm
Out[41]//TableForm=
0 0
0.44448
1 10 -0.781103
2 20 -0.0585946
3 30 0.0711637
4 40 0.166355
5 50 -0.412115
6 60 -0.669691
7 70 0.202516
8 80 0.508435
9 90 0.542246
12.5 Computing Covariance and Correlation of Vectors and Matrices | 467

In[42]:=
Covariance@dataD êê TableForm
Out[42]//TableForm=
9.16667
91.6667 0.467288
91.6667
916.667 4.67288
0.467288 4.67288 0.228412
In[43]:=
Correlation@dataD êê TableForm
Out[43]//TableForm=
1.
1.
0.322938
1.
1.
0.322938
0.322938 0.322938 1.
In[44]:=
Correlation@data, data^2D êê TableForm
Out[44]//TableForm=
0.962691 0.962691 0.00604923
0.962691 0.962691 0.00604923
0.442467 0.442467 -0.522003
12.6 Measuring the Shape of Data 
Problem
You  want  to  summarize  the  shape  of  your  data  using  some  common  statistical
measures.
Solution
Use Skewness to measure the asymmetry of a distribution. A symmetrical distribu-
tion like the NormalDistribution will have skewness of zero. A positive skewness indi-
cates the right tail is longer, while a negative skewness indicates the left tail is longer.
In[45]:=
dist1 = NormalDistribution@0, 1D;
dist2 = ChiSquareDistribution@1D; dist3 = BetaDistribution@8, 2D;
GridA99TextAStyle@"Skewness", Bold, 14DE, TextAStyle@"Plot", Bold, 14DE=,
8Skewness@dist1D, Plot@PDF@dist1, xD, 8x, -5, 5<D<,
8Skewness@dist2D, Plot@PDF@dist2, xD, 8x, 0, 5<D<,
8Skewness@dist3D, Plot@PDF@dist3, xD, 8x, 0, 1<D<=, Frame Ø AllE
468 | Chapter 12: Statistics and Data Analysis

Out[46]=
Skewness
Plot
0
-4
-2
2
4
0.1
0.2
0.3
0.4
2
2
1
2
3
4
5
0.1
0.2
0.3
0.4
0.5
0.6
-
11
4
0.2
0.4
0.6
0.8
1.0
0.5
1.0
1.5
2.0
2.5
3.0
3.5
Use QuartileSkewness to measure if the median is closer to the upper or lower quar-
tile. QuartileSkewness is a more robust measure of skewness in the presence of ex-
treme values. 
In[47]:=
data = 80.1, 0.3, 0.7, 1, 0.6, 99, 0.8, 2, 2.1, 0.95, 1.7, 0.69<;
8QuartileSkewness@dataD, Skewness@dataD<
Out[48]=
80.618257, 3.01242<
Use Kurtosis to measure the sharpness of the peak of a distribution. A high kurtosis
distribution has a sharper peak and longer, fatter tails, whereas a low kurtosis distri-
bution has a more rounded peak and shorter, thinner tails.
12.6 Measuring the Shape of Data | 469

In[49]:=
dist1 = LogNormalDistribution@0, 1D;
dist2 = NormalDistribution@0, 1D; dist3 = BetaDistribution@1, 1D;
GridA
99TextAStyle@"Kurtosis", Bold, 14DE, TextAStyle@"Plot", Bold, 14DE=,
8Kurtosis@dist1D êê N, Plot@PDF@dist1, xD, 8x, 0, 6<D<,
8Kurtosis@dist2D êê N, Plot@PDF@dist2, xD, 8x, 0, 6<D<,
8Kurtosis@dist3D êê N, Plot@PDF@dist3, xD, 8x, 0, 6<D<=, Frame Ø AllE
Out[49]=
Kurtosis
Plot
113.936
1
2
3
4
5
6
0.1
0.2
0.3
0.4
0.5
0.6
3.
1
2
3
4
5
6
0.1
0.2
0.3
0.4
1.8
1
2
3
4
5
6
0.2
0.4
0.6
0.8
1.0
470 | Chapter 12: Statistics and Data Analysis

Discussion
CentralMoment is a fundamental measure that underlies statistical measures of shape.
It is computed as
1
n
‚
i
Ixi-xMr
The second central moment of a data set is called the population variance (which is
not as commonly used as sample variance as computed by the Variance function).
In[50]:=
data = 80.1, 0.3, 0.7, 1, 0.6, 99, 0.8, 2, 2.1, 0.95, 1.7, 0.69<;
In[51]:=
Table@CentralMoment@data, iD, 8i, 1, 3<D
Out[51]=
91.77636µ10-15, 734.086, 59915.=
Skewness  is  equivalent  to  CentralMoment[list,3]/CentralMoment[list,2]^(3/2);  Kurto-
sis is CentralMoment[list,4]/CentralMoment[list,2]^2. 
12.7 Finding and Adjusting for Outliers
Problem
You have a large data set and you want to identify outliers and possibly adjust the
statistics to compensate.
Solution
A simple way to identify outliers is to use Sort and inspect the beginning and end of
the list. You can also look at a certain number of elements near the minimum and
maximum using Nearest.
In[52]:=
data = Join@80.0001, 0.0005<, RandomReal@810, 30<, 500D, 81000, 1007<D;
8min, max< = 8Min@dataD, Max@dataD<;
8Nearest@data, min, 5D, Nearest@data, max, 5D<
Out[54]=
880.0001, 0.0005, 10.0021, 10.1101, 10.1403<,
81007, 1000, 29.9915, 29.9773, 29.975<<
You can also compute the trimmed mean, which is the mean after dropping a frac-
tion of the smallest and largest elements.
In[55]:=
8Mean@dataD, TrimmedMean@data, 0.2D<
Out[55]=
824.0623, 20.173<
12.7 Finding and Adjusting for Outliers | 471

Discussion
Here  I  take  advantage  of  a  feature  of  Tally  that  allows  you  to  provide  custom
equivalence function. The idea here is to treat values within a specified distance of
each other as equal. In this case, I use distance 5. This shows that there are 3 clusters
of values in the data and some outliers with low frequency of occurrence. 
In[56]:=
Tally@data, HAbs@Ò1 - Ò2D < 5L &D êê TableForm
Out[56]//TableForm=
0.0001
2
25.5715 235
10.4722 135
17.0082 130
1000
1
1007
1
12.8 Fitting Data Using a Linear Model
Problem
You have a data set and would like to find a linear model of the data. A linear model
is commonly called a “linear regression.” A linear model has various statistics that
define its accuracy, and you typically want to obtain these as well.
Solution
In[57]:=
data = Table@8x, x + RandomReal@8-2, 3<D<, 8x, 1, 20<D;
Use Fit in versions prior to Mathematica 7.
In[58]:=
linFit@x_D := Evaluate@Fit@data, 81, x<, xDD
In[59]:=
ShowAListPlot@dataD, Plot@linFit@xD, 8x, 1, 20<D, ImageSize Ø SmallE
Out[59]=
5
10
15
20
5
10
15
20
472 | Chapter 12: Statistics and Data Analysis

Use LinearModelFit in version 7 and above to build a linear model that you can then
use to plot or extract statistics.
In[60]:=
lm = LinearModelFit@data, x, xD;
ShowAListPlot@dataD, Plot@lm@xD, 8x, 1, 20<D, ImageSize Ø SmallE
Out[60]=
5
10
15
20
5
10
15
20
Discussion
LinearModelFit is a vast improvement over Fit since it is not just a way to synthesize
a function. Once you have constructed a linear model, you can query its various
properties, of which there are quite a few. To find out what is available, simply ask
the model. Ask for a specific property by name.
In[62]:=
lm@"Properties"D
Out[62]=
9AdjustedRSquared, AIC, ANOVATable, ANOVATableDegreesOfFreedom,
ANOVATableEntries, ANOVATableFStatistics, ANOVATableMeanSquares,
ANOVATablePValues, ANOVATableSumsOfSquares, BetaDifferences, BestFit,
BestFitParameters, BIC, CatcherMatrix, CoefficientOfVariation,
CookDistances, CorrelationMatrix, CovarianceMatrix, CovarianceRatios,
Data, DesignMatrix, DurbinWatsonD, EigenstructureTable,
EigenstructureTableEigenvalues, EigenstructureTableEntries,
EigenstructureTableIndexes, EigenstructureTablePartitions,
EstimatedVariance, FitDifferences, FitResiduals, Function,
FVarianceRatios, HatDiagonal, MeanPredictionBands,
12.8 Fitting Data Using a Linear Model | 473

MeanPredictionConfidenceIntervals, MeanPredictionConfidenceIntervalTable,
MeanPredictionConfidenceIntervalTableEntries, MeanPredictionErrors,
ParameterConfidenceIntervals, ParameterConfidenceIntervalTable,
ParameterConfidenceIntervalTableEntries, ParameterConfidenceRegion,
ParameterErrors, ParameterPValues, ParameterTable, ParameterTableEntries,
ParameterTStatistics, PartialSumOfSquares, PredictedResponse, Properties,
Response, RSquared, SequentialSumOfSquares, SingleDeletionVariances,
SinglePredictionBands, SinglePredictionConfidenceIntervals,
SinglePredictionConfidenceIntervalTable,
SinglePredictionConfidenceIntervalTableEntries, SinglePredictionErrors,
StandardizedResiduals, StudentizedResiduals, VarianceInflationFactors=
In[63]:=
lm@"RSquared"D
Out[63]=
0.944788
In[64]:=
lm@"MeanPredictionErrors"D
Out[64]=
80.627101, 0.579603, 0.533846, 0.490318, 0.449667, 0.412744,
0.380636, 0.354652, 0.336216, 0.326608, 0.326608, 0.336216, 0.354652,
0.380636, 0.412744, 0.449667, 0.490318, 0.533846, 0.579603, 0.627101<
In[65]:=
lm@"BestFit"D
Out[65]=
0.981879 + 0.990357 x
You can also get the best Fit function by using Normal.
In[66]:=
Normal@lmD
Out[66]=
0.981879 + 0.990357 x
See Also
FindFit and LeastSquares are other related functions you can explore in the Math-
ematica documentation.
GeneralizedLinearModelFit and DesignMatrix are Mathematica 7 functions that are
also worth exploring in the documentation and tutorials.
474 | Chapter 12: Statistics and Data Analysis

12.9 Fitting Data Using a Nonlinear Model
Problem
You want to fit data to a function for which you have knowledge of the mathemati-
cal model. Specifically, you know the model is nonlinear and, hence, neither Fit nor
LinearModelFit is appropriate.
Solution
Use FindFit in versions prior to Mathematica 7. 
In[67]:=
SeedRandom@3D;
H*Randomly generate data that is not linear.*L
data = Sort@RandomSample@Table@8x, 3 Exp@x - 8 D<, 8x, 0, 10, 0.1<D, 22DD
Out[68]=
880.9, 0.00247531<, 81.3, 0.00369274<, 81.7, 0.00550891<,
82.7, 0.0149748<, 82.9, 0.0182902<, 83.2, 0.0246892<,
83.5, 0.033327<, 83.6, 0.036832<, 83.9, 0.049718<, 84.6, 0.10012<,
85.4, 0.222821<, 85.8, 0.332409<, 85.9, 0.367369<, 86.1, 0.448706<,
86.2, 0.495897<, 86.8, 0.903583<, 87.5, 1.81959<, 88., 3.<,
88.7, 6.04126<, 88.8, 6.67662<, 88.9, 7.37881<, 89.6, 14.8591<<
In[69]:=
FindFit@data , a Exp@b + c xD + d, 8a, b, c, d<, xD
Out[69]=
9a Ø 0.0608805, b Ø -4.10255, c Ø 1., d Ø 3.33224µ10-17=
Use NonLinearModel fit in Mathematica 7 as a more complete solution.
In[70]:=
nlm = NonlinearModelFit@data, a Exp@b + c xD + d , 8a, b, c, d<, xD;
In[71]:=
Normal@nlmD
Out[71]=
3.33224µ10-17 + 0.0608805 ‰-4.10255+1. x
In[72]:=
Show@ListPlot@dataD, Plot@nlm@xD, 8x, 0, 10<D, Frame Ø TrueD
Out[72]=
0
2
4
6
8
0
1
2
3
4
12.9 Fitting Data Using a Nonlinear Model | 475

Discussion
As with LinearModelFit, NonlinearModelFit encapsulates a wealth of information.
In[73]:=
nlm@"Properties"D
Out[73]=
9AdjustedRSquared, AIC, ANOVATable, ANOVATableDegreesOfFreedom,
ANOVATableEntries, ANOVATableMeanSquares, ANOVATableSumsOfSquares,
BestFit, BestFitParameters, BIC, CorrelationMatrix, CovarianceMatrix,
CurvatureConfidenceRegion, Data, EstimatedVariance, FitCurvatureTable,
FitCurvatureTableEntries, FitResiduals, Function, HatDiagonal,
MaxIntrinsicCurvature, MaxParameterEffectsCurvature, MeanPredictionBands,
MeanPredictionConfidenceIntervals, MeanPredictionConfidenceIntervalTable,
MeanPredictionConfidenceIntervalTableEntries,
MeanPredictionErrors, ParameterBias, ParameterConfidenceIntervals,
ParameterConfidenceIntervalTable, ParameterConfidenceIntervalTableEntries,
ParameterConfidenceRegion, ParameterErrors, ParameterPValues,
ParameterTable, ParameterTableEntries, ParameterTStatistics,
PredictedResponse, Properties, Response, RSquared, SingleDeletionVariances,
SinglePredictionBands, SinglePredictionConfidenceIntervals,
SinglePredictionConfidenceIntervalTable,
SinglePredictionConfidenceIntervalTableEntries,
SinglePredictionErrors, StandardizedResiduals, StudentizedResiduals=
For example, you can extract and plot confidence  bands  for  various  confidence
levels. 
In[74]:=
SeedRandom@30D;
data = Sort@
RandomSample@Table@8x, Exp@x + 1.3 Sin@xDD<, 8x, 0, 10, 0.1<D, 15DD;
nlm = NonlinearModelFit@data, a x Exp@b + c xD + d , 8a, b, c, d<, xD;
8bands90@x_D, bands95@x_D, bands99@x_D, bands999@x_D< =
Table@nlm@"MeanPredictionBands", ConfidenceLevel Ø clD,
8cl, 8.9, .95, .99, .999<<D;
ShowAListPlot@dataD, PlotA8nlm@xD, bands90@xD, bands95@xD, bands99@xD,
bands999@xD<, 8x, 1, 10<, Filling Ø 82 Ø 81<, 3 Ø 82<, 4 Ø 83<, 5 Ø 84<<EE
Out[78]=
476 | Chapter 12: Statistics and Data Analysis

Or you can extract a variety of statistics.
In[79]:=
nlm@"MeanPredictionErrors"D
Out[79]=
8854.599, 758.348, 729.776, 709.976, 580.188, 526.565, 526.883,
567.372, 617.731, 669.962, 711.146, 717.15, 732.972, 968.248, 1442.15<
In[80]:=
nlm@"ANOVATable"D
Out[80]=
DF SS
MS
Model
4
4.04209µ108
1.01052µ108
Error
11 3.28552µ107
2.98683µ106
Uncorrected Total
15 4.37064µ108
Corrected Total
14 2.96124µ108
In[81]:=
nlm@"CorrelationMatrix"D êê TableForm
Out[81]//TableForm=
1.
1.
-0.993792 -0.777438
1.
1.
-0.993792 -0.777438
-0.993792 -0.993792 1.
0.730294
-0.777438 -0.777438 0.730294
1.
See Also
The statistical model analysis guide (guide/StatisticalModelAnalysis) is a good start-
ing point for exploring all the new modeling capabilities in Mathematica 7.
12.10 Creating Interpolation Functions 
from Data 
Problem
You have a set of data points and want to construct a function you can use to pre-
dict values at other points.
Solution
Normally, you would interpolate data that was obtained in the wild without any a
priori notion of the underlying function. However, as a simple illustration, I’ll sam-
ple data from a known function.
In[82]:=
xvalues = Sort@RandomReal@8-4 Pi, 4 Pi<, 18DD;
data = Table@8x, Sin@xD<, 8x, xvalues<D;
fData = Interpolation@dataD
Out[84]=
InterpolatingFunction@88-11.3374, 12.5436<<, <>D
12.10 Creating Interpolation Functions from Data | 477

In[85]:=
PlotA8fData@xD, Sin@xD<, 8x, -2 Pi, 2 Pi<, PlotStyle Ø 8Thin, Dashed<E
Out[85]=
-6
-4
-2
2
4
6
-1.0
-0.5
0.5
1.0
Discussion
Interpolation returns an InterpolationFunctionObject, which can be used just like
a normal function. The default order for Interpolation is 3 but this can be varied us-
ing the option InterpolationOrder.
In[86]:=
fData1 = Interpolation@data, InterpolationOrder Ø 1D;
fData2 = Interpolation@data, InterpolationOrder Ø 2D;
fData3 = Interpolation@data, InterpolationOrder Ø 3D;
In[89]:=
PlotA8fData1@xD, fData2@xD, fData3@xD<,
8x, -2 Pi, 2 Pi<, PlotStyle Ø 8Dashed, Thin, Thick<E
Out[89]=
-6
-4
-2
2
4
6
-1.0
-0.5
0.5
1.0
478 | Chapter 12: Statistics and Data Analysis

12.11 Testing for Statistically Significant 
Difference Between Groups Using ANOVA
Problem
You have experimental data suggesting a linear relationship between an independent
and dependent variables; however, you are unsure if the relationship is causal. You
run an experiment using an experimental group and a control group. You want to
know if the results of the experiment are statistically significant.
Solution
Analysis of variance (ANOVA) is a popular statistical technique that is very impor-
tant in the analysis of experimental results. Mathematica provides this functionality
in a package aptly named ANOVA`. To illustrate the use of this package, I borrow a toy
example from Boslaugh and Watters’ Statistics in a Nutshell. Imagine you collected
the data in table coffeeIQ suggesting a relationship between coffee consumption in
cups and IQ as measured by some standardized IQ test.
In[90]:=
coffeeIQ = 882, 123<, 81, 112<, 81, 102<, 81, 98<,
80, 79<, 80, 87<, 81, 102<, 82, 120<, 82, 120<, 83, 145<<;
In[91]:=
lm = LinearModelFit@coffeeIQ, x, xD;
ShowAListPlot@coffeeIQD, Plot@lm@xD, 8x, 0, 4<D, ImageSize Ø SmallE
Out[92]=
1
2
3
4
100
120
140
160
In[93]:=
Normal@lmD
Out[93]=
83.0247 + 19.8272 x
12.11 Testing for Statistically Significant Difference Between Groups Using ANOVA | 479

The question that remains is whether there is a causal relationship between caffeine
and IQ, since one could equally suppose smart people just like to drink coffee. To in-
vestigate  further,  you  design  an  experiment  with  two  randomly  selected  groups:
everyone  in  the  first  group  receives  a  caffeine  pill,  and  those  in  the  second  group
receive a placebo. The pills are administered in a double-blind method, at the same
time, under the exact same conditions, and each group is administered an IQ test at
a specific time after the pills were taken. From these experiments you obtain the fol-
lowing data, where the first entry is 1 for those who received the caffeine and 0 for
those who received the placebo. The second entry is the measured IQ.
In[94]:=
experiments = 881, 110<, 81, 100<, 81, 120<, 81, 125<, 81, 120<, 81, 120<,
81, 115<, 81, 98<, 81, 95<, 81, 91<, 80, 100<, 80, 95<, 80, 100<,
80, 122<, 80, 115<, 80, 88<, 80, 97<, 80, 87<, 80, 92<, 80, 76<<;
Using ANOVA you see 
In[95]:=
Needs@"ANOVA`"D
In[96]:=
ANOVA@experiments D
Out[96]=
;ANOVA Ø
DF
SumOfSq
MeanSq
FRatio
PValue
Model
1
744.2
744.2
4.47415
0.0486171
Error
18
2994.
166.333
Total
19
3738.2
, CellMeans Ø
All
103.3
Model@0D 97.2
Model@1D 109.4
?
Here the important results are the FRatio (higher is better) and PValue (smaller is bet-
ter). The PValue is the probability of obtaining the result at least as extreme as the
one that was actually observed, given that the null hypothesis is true. Typically one
will reject the null hypothesis when the PValue is less than 0.05.
Discussion
You may wonder why the output of ANOVA is formatted as it is. Here Mathematica
is emulating a popular statistics package called Minitab. You can drill down to the
raw values easily enough.
In[97]:=
HANOVA ê. ANOVA@experiments DL@@1DD
Out[97]=
881, 744.2, 744.2, 4.47415, 0.0486171<, 818, 2994., 166.333<, 819, 3738.2<<
The solution shows a one-way ANOVA. It is frequently the case that there are multi-
ple independent variables. In this case, you must describe the model and variables
more precisely. For example, suppose you were measuring height and age of men as
480 | Chapter 12: Statistics and Data Analysis

a predictor of income. For the purpose of this experiment, we will designate men un-
der 5'10" as “short,” assigning them height classification 1 and “tall” men classifica-
tion 2. Similarly, we will define “young” men as under 40 with age classification 1
and “mature” men with age classification 2.
In[98]:=
twowaydata = 881, 1, 30000<, 81, 1, 65 000<, 81, 1, 57 000<, 81, 1, 45 000<,
81, 2, 49000<, 81, 2, 87000<, 81, 2, 56 000<, 81, 2, 90 000<,
82, 1, 55000<, 82, 1, 88000<, 82, 1, 104 000<, 82, 1, 88 000<,
82, 2, 75000<, 82, 2, 101000<, 82, 2, 150 000<, 82, 2, 125 000<<;
In[99]:=
ANOVAAtwowaydata, 9height, age, All=, 9height, age=E êê
StyleAÒ, FontTracking Ø "Condensed"E &
Out[99]=
:ANOVA Ø
DF
SumOfSq
MeanSq
FRatio
PValue
height
1
5.89056µ109
5.89056µ109
11.053
0.00605829
age
1
2.52506µ109
2.52506µ109
4.73801
0.0501898
age height
1
6.00625µ107
6.00625µ107
0.112701
0.742887
Error
12
6.39525µ109
5.32938µ108
Total
15
1.48709µ1010
,
CellMeans Ø
All
79062.5
height@1D
59875.
height@2D
98250.
age@1D
66500.
age@2D
91625.
age@1Dheight@1D 49250.
age@1Dheight@2D 83750.
age@2Dheight@1D 70500.
age@2Dheight@2D 112750.
>
Here I use All in the model input to indicate I want to analyze all products of the
main  effects.  You  can  also  specify  the  products  individually.  For  example,  if  you
want to analyze the significance of height and height and age together, you can spec-
ify the model parameter as {height, age height}.
12.11 Testing for Statistically Significant Difference Between Groups Using ANOVA | 481

In[100]:=
ANOVAAtwowaydata, 9height, age height =, 9height, age=E êê
StyleAÒ, FontTracking Ø "Condensed"E &
Out[100]=
:ANOVA Ø
DF
SumOfSq
MeanSq
FRatio
PValue
height
1
5.89056µ109
5.89056µ109
11.053
0.00605829
age height
2
2.58513µ109
1.29256µ109
2.42535
0.13043
Error
12
6.39525µ109
5.32938µ108
Total
15
1.48709µ1010
,
CellMeans Ø
All
79062.5
height@1D
59875.
height@2D
98250.
age@1Dheight@1D 49250.
age@1Dheight@2D 83750.
age@2Dheight@1D 70500.
age@2Dheight@2D 112750.
>
There  are  a  few  standard  post  hoc  tests  you  can  run  to  determine  which  group’s
means  were  significantly  different  given  SignificanceLevel  (default  is  0.05).  I  will
not  delve  into  the  statistics  behind  these  tests.  You  should  refer  to  one  of  the  re-
sources in the “See Also” section on page 483. The output is fairly self-explanatory.
Here we see that using the Bonferroni and Tukey tests, variation in income due to
height was statistically significant between groups 1 and 2, but age did not show up
as significant for either test. 
In[101]:=
ANOVAAtwowaydata, 9height, age , All =, 9height, age=,
SignificanceLevel Ø 0.05, PostTests Ø 9Tukey, Bonferroni=,
CellMeans Ø FalseE êê StyleAÒ, FontTracking Ø "Condensed"E &
Out[101]=
:ANOVA Ø
DF
SumOfSq
MeanSq
FRatio
PValue
height
1
5.89056µ109
5.89056µ109
11.053
0.00605829
age
1
2.52506µ109
2.52506µ109
4.73801
0.0501898
age height
1
6.00625µ107
6.00625µ107
0.112701
0.742887
Error
12
6.39525µ109
5.32938µ108
Total
15
1.48709µ1010
,
PostTests Ø :height Ø
Bonferroni 81, 2<
Tukey
81, 2<
, age Ø
Bonferroni 8<
Tukey
8<
>>
482 | Chapter 12: Statistics and Data Analysis

Returning to the data from the “Solution” section on page 479, we can see how the
tests can pass at one significance level but fail at a tighter tolerance. Note also how I
use the output as a replacement rule to extract only the test results.
In[102]:=
PostTests ê. ANOVAAexperiments , SignificanceLevel Ø 0.05,
PostTests Ø 9Tukey, Bonferroni=, CellMeans Ø FalseE
Out[102]=
;Model Ø
Bonferroni 80, 1<
Tukey
80, 1<
?
In[103]:=
PostTests ê. ANOVAAexperiments , SignificanceLevel Ø 0.01,
PostTests Ø 9Tukey, Bonferroni=, CellMeans Ø FalseE
Out[103]=
;Model Ø
Bonferroni 8<
Tukey
8<
?
In the examples given here, I have also used the option CellMeans Ø False, which
suppresses the display of the means.
See Also
Basic information on ANOVA can be found on Wikipedia at http:/bit.ly/bf8PrO, and
in Boslaugh and Watters, Statistics in a Nutshell.
12.12 Hypothesis Testing with Categorical Data
Problem
You want to determine if there are statistically significant relationships within cate-
gorical data. 
Solution
The  chi-square  test  is  a  standard  computation  on  categorical  data.  Categorical
data  is  that  for  which  the  response  is  a  choice  among  a  set  of  discrete  categories
rather  than  a  measurement  on  a  continuous  scale.  Common  examples  are  sex
{male,  female},  party  {Democrat,  Republican},  or  sometimes  data  that  could  be
placed  on  a  scale  but  for  simplicity  is  lumped  into  discrete  groups,  for  example,
blood pressure {low, normal, prehypertensive, hypertensive}. Experiments using
categorical data often result in tables; hence, the data is called row-column (RC) data.
12.12 Hypothesis Testing with Categorical Data | 483

Here is a simplest possible example (borrowed from Statistics in a Nutshell) showing
a two-by-two table relating smoking to lung cancer.
Lung Cancer Diagnosis
No Lung Cancer Diagnosis
Currently smoke
60
300
Do not currently smoke
10
390
The chi-square test is a test for independence. If the RC data is independent, there is
no demonstrated relationship between smoking and cancer (the null hypothesis);
otherwise,  there  is  evidence  for  the  alternate  hypothesis.  The  chi-square  statistic
starts with the computation of expected, values for each cell. The formula is
E i j=
i th row total * j
th
row total
grand total
This is easily computed for the entire table using Outer.
In[104]:=
data := 8860, 300<, 810, 390<<;
Out[105]=
expectedValues@rc_ListD := ModuleA9rowTotals, colTotals, grandTotal=,
colTotals := Total@rcD ;
rowTotals := Total@Transpose@rcDD;
grandTotal := Total@rowTotalsD ;
Outer@Times, rowTotals, colTotalsD ë grandTotalE
The chi-square value is computed by taking the differences between expected and
observed, squaring the result, dividing it by expected, and summing all the ratios.
In[106]:=
chiSquare@data_ListD := Module@8ev<, ev = expectedValues@dataD;
Total@HHdata - ev L ^ 2 Lê ev, 2DD
In[107]:=
expectedValues@dataD êê N êê TableForm
Out[107]//TableForm=
33.1579 326.842
36.8421 363.158
In[108]:=
chiSquare@dataD êê N
Out[108]=
45.4741
To interpret this result, you need to compute PValue. The smaller the p-value, the
more confident you can be in rejecting the null hypothesis. 
In[109]:=
NeedsA"HypothesisTesting`"E
ChiSquarePValue@45.4741, 1D
Out[110]=
OneSidedPValue Ø 1.54671µ10-11
484 | Chapter 12: Statistics and Data Analysis

Discussion
The  second  argument  to  ChiSquarePValue  specifies  the  degrees  of  freedom  of  the
distribution.  In  the  solution  example,  we  use  1  without  explanation.  The  rule  for
computing the degrees of freedom for RC data is (numRows |1)(numCols |1).
In[111]:=
degreesOfFreedom@rc_ListD := Times üü HDimensions@rcD - 1L
In[112]:=
degreesOfFreedom@dataD
Out[112]=
1
In the literature you will often find tables of critical values for various distributions
relative  to  a  significance  level  called  alpha  (a).  For  example,  a  common  value  for
alpha is 0.05, which represents 95% confidence or (1 | a) * 100%. The critical value
for a specified degree of freedom is the lower (or upper) bound for chiSquare in the
solution that would give you the required confidence. Computing the critical value
is the problem of finding a limit that gives the specified alpha as the area under the
PDF  for  the  distribution.  We  can  compute  these  values  efficiently  using  FindRoot
and NIntegrate. 
In[113]:=
chiSqUpperP@criticalValue_, df_D := WithA9infinity = 1000=, NIntegrateA
PDF@ChiSquareDistribution@dfD, xD, 9x, criticalValue, infinity=EE
chiSqLowerP@criticalValue_, df_D := NIntegrate@
PDF@ChiSquareDistribution@dfD, xD, 8x, 0, criticalValue<D
criticalValueUpper@alpha_, df_D :=
FindRoot@chiSqUpperP@c, dfD ã alpha, 8c, 0.1<D
criticalValueLower@alpha_, df_D :=
FindRoot@chiSqLowerP@c, dfD ã alpha, 8c, 0.1<D
The critical value for the experiment in the solution is
In[117]:=
criticalValueUpper@0.05, 1D êê Quiet
Out[117]=
8c Ø 3.84146<
Our result was 45.47, so the result was well over the critical value. A result below
the  lower  critical  value  is  also  acceptable,  but  clearly  that  does  not  apply  to  this
experiment.
In[118]:=
criticalValueLower@0.05, 1D êê Quiet
Out[118]=
8c Ø 0.00393214<
Given these functions, you can create your own tables of critical values like those in
the NIST/SEMATECH e-Handbook of Statistical Methods website (http://bit.ly/AbGvb).
In[119]:=
chiSqCritValues@dfFrom_, dfTo_D := WithA8alphas = 80.10, 0.05, 0.01, 0.001<<,
TableFormATable@c ê. criticalValueUpper@alpha, dfD, 8df, dfFrom, dfTo<,
8alpha, alphas<D, TableHeadings Ø 9Range@dfFrom, dfToD, alphas=EE
12.12 Hypothesis Testing with Categorical Data | 485

In[120]:=
chiSqCritValues@1, 10D êê Quiet
Out[120]//TableForm=
0.1
0.05
0.01
0.001
1
2.70554 3.84146 6.6349
10.8276
2
4.60517 5.99146 9.21034 13.8155
3
6.25139 7.81473 11.3449 16.2662
4
7.77944 9.48773 13.2767 18.4668
5
9.23636 11.0705 15.0863 20.515
6
10.6446 12.5916 16.8119 22.4577
7
12.017
14.0671 18.4753 24.3219
8
13.3616 15.5073 20.0902 26.1245
9
14.6837 16.919
21.666
27.8772
10 15.9872 18.307
23.2093 29.5883
See Also
More information on using ChiSquare can be found in the NIST/SEMATECH e-Hand-
book of Statistical Methods website (http://bit.ly/AbGvb).
A  tutorial  on  the  complete  HypothesisTesting`  package  in  Mathematica  can  be
found in the documentation (HypothesisTesting/tutorial/HypothesisTesting).
12.13 Grouping Data into Clusters
Problem
You want to group data in separate lists based on a metric like Euclidean distance or
Hamming distance. This problem arises in a wide variety of contexts, including mar-
ket research, demographics, informatics, risk analysis, and so forth. 
Solution
Use  FindClusters  with  the  default  Euclidean  distance  function  for  numbers  and
vectors.
In[121]:=
FindClusters@81, 100, 2, 101, 3, 102, 1000, 1010, 4, 1020, 7<D
Out[121]=
881, 2, 3, 4, 7<, 8100, 101, 102<, 81000, 1010, 1020<<
When you use FindClusters with strings, this distance function is “edit distance” or
the number of character changes to get from one string to another.
In[122]:=
FindClustersADictionaryLookup@_ ~~ "ead" ~~ _DE
Out[122]=
98beads, heads, leads, reads<, 9beady, heady, Meade, Reade, ready==
486 | Chapter 12: Statistics and Data Analysis

You can insist on a specific number of clusters.
In[123]:=
FindClusters@81, 100, 2, 101, 3, 102, 1000, 1010, 4, 1020, 7<, 4D
Out[123]=
881, 2, 3, 4<, 8100, 101, 102<, 81000, 1010, 1020<, 87<<
Discussion
If you need to cluster data by a key or criterion that is not part of the data, transform
the  data  into  the  form  {key1Ødata1,  key2Ødata2,  ...}.  When  FindClusters  sees
this  format,  it  will  cluster  that  data  using  the  keys.  For  example,  say  you  retrieve
some  data  from  a  database  with  names  and  ages  and  you  want  to  cluster  names
by age.
In[124]:=
data = 88"Wanda", 41<, 8"Sal", 44<, 8"Leo", 9<,
8"Salvatore", 6<, 8"Steven", 37<, 8"Adrian", 3<<;
H*Use ReplaceAll Hê.L to transform data into the right format.*L
FindClustersAdata ê. 9name_, age_= :> age Ø nameE
Out[125]=
88Wanda, Sal, Steven<, 8Leo, Salvatore, Adrian<<
If you don’t want to lose the ages, you can use the following variation:
In[126]:=
FindClustersAdata ê. 9name_, age_= :> age Ø 9name, age=E
Out[126]=
888Wanda, 41<, 8Sal, 44<, 8Steven, 37<<,
88Leo, 9<, 8Salvatore, 6<, 8Adrian, 3<<<
There is also a variation that is more convenient when the keys and values are in sep-
arate lists.
In[127]:=
keys = 841, 44, 9, 6, 37, 3< ;
values = 8"Wanda", "Sal", "Leo", "Salvatore", "Steven", "Adrian"<;
FindClustersAkeys Ø valuesE
Out[129]=
88Wanda, Sal, Steven<, 8Leo, Salvatore, Adrian<<
You can also handle the situation via a custom distance function, which is a more
general solution since the function can use other metrics besides Euclidean distance. 
In[130]:=
FindClustersAdata,
DistanceFunction Ø FunctionA9x, y=, AbsAx@@2DD - y@@2DDEEE
Out[130]=
888Wanda, 41<, 8Sal, 44<, 8Steven, 37<<,
88Leo, 9<, 8Salvatore, 6<, 8Adrian, 3<<<
12.13 Grouping Data into Clusters | 487

Mathematica provides a variety of built-in distance functions that cater to different
conceptions  of  closeness  as  well  as  different  data  types.  For  numbers,  vectors,
and higher-order tensors, you can  use  EuclideanDistance,  SquaredEuclideanDistance,
ManhattanDistance, ChessboardDistance, CanberraDistance, CosineDistance, Correlation-
Distance, or BrayCurtisDistance. For example, CosineDistance (also known as angu-
lar distance) is often used with highly dimensional data. Here we generate a data set
of 800 vectors of length 50. By design, the vectors are clumped into four groups by
magnitude, so it should be of little surprise that FindClusters using default Euclidean-
Distance discovers four clusters.
In[131]:=
data =
Join@RandomReal@8-10, -5<, 8200, 50<D, RandomReal@8-5, 0<, 8200, 50<D,
RandomReal@80, 1<, 8200, 50<D, RandomReal@85, 10<, 8200, 50<DD;
In[132]:=
Length@FindClusters@dataDD
Out[132]=
4
However,  using  CosineDistance,  which  is  insensitive  to  vector  length,  only  two
clusters are found. 
In[133]:=
Length@FindClusters@data, DistanceFunction -> CosineDistanceDD
In[133]:=
2
For Boolean vectors, you can use  MatchingDissimilarity,  JaccardDissimilarity,
RussellRaoDissimilarity,  SokalSneathDissimilarity,  RogersTanimotoDissimilarity,
DiceDissimilarity, and YuleDissimilarity. Consider a problem that turns the game
of 20 Questions on its head. I devised 20 questions in a somewhat haphazard fashion
and then selected a bunch of nouns as they came into my head (Table 12-1). The
idea here is to associate a Boolean vector with each noun based on how one might
answer the questions in relation to the noun. Some of the questions are very subjec-
tive, and some don’t really apply to all nouns, but to stay in the domain of Boolean,
I forced myself to choose either true or false.
488 | Chapter 12: Statistics and Data Analysis

Table 12-1. Twenty Questions
Number
Question
1
Is it living?
2
Is it bigger than a bread box?
3
Is it soft?
4
Is it visible?
5
Is it man - made?
6
Is it flammable?
7
Is it famous?
8
Does it run on electricity?
9
Does it have hair or fur?
10
Does it process information?
11
Does it usually cost more than $1000?
12
Is it mostly one color?
13
Can you sell it legally?
14
Does it conduct electricity?
15
Can you bend it without
breaking and it retains its new shape?
16
Can an average human lift it?
17
Can it been seen with the unaided eye?
18
Can you transfer it over the Internet?
19
Is it scary?
20
Does its English name come before Lizard in the dictionary?
The nouns I applied these questions to are
In[135]:=
words = 9"cat", "PC", "Java", "bird", "airplane", "Obama", "Mathematica",
"Hillary Clinton", "weather", "time", "wind", "tunnel",
"carpenter", "house", "red", "beer", "LSD", "Nintendo Wii",
"John Lennon", "Paul McCartney", "Howard Stern", "mother", "Linux",
"candle", "paper", "rock", "scissors", "steak", "broccoli"=;
12.13 Grouping Data into Clusters | 489

I’ll only show part of the data set (you can find it in the file 20Q.nb in the down-
loads from the book’s website) . 
In[136]:=
88True, True, True, True, False, True, False, False, True, True, False,
False, True, True, False, True, True, False, False, True< Ø "cat",
8False, True, False, True, True, False, False, True, False, True, True,
False, True, False, False, True, True, False, False, False< Ø "PC",
8False, False, False, True, True, True, False, False, False, True,
False, False, True, False, False, False, True, True, False, True< Ø
"Java", 8True, False, True, True, False, True, False,
False, False, True, False, True, True, True, False,
True, True, False, False, True< Ø "bird"< êê TableForm
Out[136]//TableForm=
9True, True, True, True, False, True, False, False, True, True, False, False, True, True, False, True, True, False, False, True= Ø cat
9False, True, False, True, True, False, False, True, False, True, True, False, True, False, False, True, True, False, False, False= Ø PC
9False, False, False, True, True, True, False, False, False, True, False, False, True, False, False, False, True, True, False, True= Ø Java
9True, False, True, True, False, True, False, False, False, True, False, True, True, True, False, True, True, False, False, True= Ø bird
Assuming  the  full  data  set  is  stored  in  the  variable  data,  we  can  see  how  Find-
Clusters partitions the data using the various Boolean distance functions. 
In[137]:=
ColumnAFindClusters A Flatten@data, 2D,
DistanceFunction -> MatchingDissimilarityEE
Out[137]=
9Cat, bird, airplane, Obama, Hillary Clinton, carpenter,
John Lennon, Paul McCartney, Howard Stern, mother, broccoli=
8PC, Java, Mathematica, weather, time, wind, tunnel, house, red,
beer, LSD, Nintendo Wii, Linux, candle, paper, rock, scissors, steak<
In[138]:=
ColumnAFindClusters A Flatten@data, 2D,
DistanceFunction -> JaccardDissimilarityEE
Out[138]=
9Cat, Obama, Hillary Clinton, carpenter,
John Lennon, Paul McCartney, Howard Stern, mother=
8PC, Java, Mathematica, weather, time,
wind, tunnel, house, Nintendo Wii, Linux, rock<
8bird, airplane, red, beer, LSD, candle, paper, scissors, steak, broccoli<
490 | Chapter 12: Statistics and Data Analysis

By transforming Boolean value to 0 and 1, you can see how EuclideanDistance and
ManhattanDistance tend to create a larger number of clusters. 
In[139]:=
Column@FindClusters @ Flatten@data, 2D ê. 8False Ø 0., True Ø 1.<,
DistanceFunction Ø EuclideanDistanceDD
Out[139]=
8Cat, bird, airplane, beer, steak, broccoli<
8PC, Java, Mathematica, house, LSD,
Nintendo Wii, Linux, candle, paper, rock, scissors<
9Obama, Hillary Clinton, carpenter,
John Lennon, Paul McCartney, Howard Stern, mother=
8weather, time, wind, tunnel, red<
In[140]:=
Column@FindClusters @ Flatten@data, 2D ê. 8False Ø 0., True Ø 1.<,
DistanceFunction Ø ManhattanDistanceDD
Out[140]=
8Cat, bird, beer, steak, broccoli<
8PC, Mathematica, tunnel, red, LSD,
Nintendo Wii, candle, paper, rock, scissors<
8Java, Linux<
8airplane, house<
9Obama, Hillary Clinton, carpenter,
John Lennon, Paul McCartney, Howard Stern, mother=
8weather, time, wind<
For strings, you can choose from EditDistance, DamerauLevenshteinDistance,  and
HammingDistance.
In[141]:=
FindClustersAPrependADictionaryLookup@"b" ~~ __ ~~ "i"D, "brocolli"E,
DistanceFunction Ø EditDistanceE
Out[141]=
98brocolli, bacilli, beriberi, bouzouki, broccoli, bronchi<,
9bani, banzai, bhaji, bikini, blini, bonsai, borzoi==
HammingDistance  requires  equal  length  strings,  otherwise  it  will  report  an  error.
I  added  a  preprocessing  function  that  pads  each  string  at  the  end  with  blanks  to
make each as long as the longest string in the list.
In[142]:=
lengthNormalize@words_ListD := ModuleA8maxLen< ,
maxLen = MaxAStringLength êü wordsE;
StringInsertAÒ,
StringJoinATableA" ", 9maxLen - StringLength@ÒD=EE, -1E & êü wordsE
12.13 Grouping Data into Clusters | 491

In[143]:=
FindClustersA
lengthNormalizeAPrependADictionaryLookup@"b" ~~ __ ~~ "i"D, "brocolli"EE,
DistanceFunction Ø HammingDistanceE
Out[143]=
98brocolli, beriberi, bouzouki, broccoli, bronchi <, 9bacilli ,
bani
, banzai
, bhaji
, bikini
, blini
, bonsai
, borzoi
==
For advanced applications of FindCluster, you can tweak fine-grained aspects of the
clustering algorithm via the Method option. Consult the FindClusters tutorial for de-
tailed specifications of Method that provide for custom significance tests and linkage
tests.
See Also
The tutorial for partitioning data into clusters (tutorial/PartitioningDataIntoClusters)
is the essential resource for advanced features of FindClusters.
The Mathematica 7 function Gather is a special case of FindClusters: it groups identi-
cal elements, which is akin to clustering only when the distance is zero. 
12.14 Creating Common Statistical Plots
Problem
You want to visualize experimental data in a manner that effectively summarizes all
the standard statistical measures.
Solution
The BoxWhiskerPlot is an excellent way to visually convey the essential statistics of
one or more data sets. 
492 | Chapter 12: Statistics and Data Analysis

In[144]:=
Needs@"StatisticalPlots`"D
dataSet1 = 8100, 95, 100, 122, 115, 88, 97, 87, 92, 76<
dataSet2 = 8110, 100, 120, 125, 120, 120, 115, 98, 95, 91<
BoxWhiskerPlot@dataSet1, dataSet2, BoxLabels Ø 8"Control", "Treatment"<D
Out[145]=
8100, 95, 100, 122, 115, 88, 97, 87, 92, 76<
In[146]:=
8110, 100, 120, 125, 120, 120, 115, 98, 95, 91<
Out[147]=
Control
Treatment
80
90
100
110
120
Discussion
A box plot shows the minimum, maximum, median (black line), and middle quan-
tile  (box).  There  are  options  to  change  orientation  (BoxOrientation),  spacing
(BoxExtraSpacing), styles (BoxLineStyle, BoxMedianStyle, BoxFillingStyle), and dis-
play of outliers (BoxOutliers, BoxOutlierMarkers). You can also show other quantiles
using BoxQuantile.
12.14 Creating Common Statistical Plots | 493

In[148]:=
BoxWhiskerPlotAdataSet1, dataSet2, BoxLabels Ø 8"Control", "Treatment"<,
BoxOrientation Ø Horizontal, BoxMedianStyle Ø Dashed, BoxQuantile Ø 1ê3E
Out[148]=
80
90
100
110
120
Control
Treatment
Other  common  statistical  chart  types  include  StemLeafPlot,  ParetoPlot,  
QuantilePlot, and PairwiseScatterPlot.
In[149]:=
StemLeafPlot@dataSet1D
Out[149]=
Stem
Leaves
7
6
8
78
9
257
10
00
11
5
12
2
Stem units: 10
494 | Chapter 12: Statistics and Data Analysis

A Pareto plot combines a bar chart of percentages of categories with a plot of cumu-
lative percentages. It is often used in quality control applications for which the data
might be defects for various products.
In[150]:=
RandomSeed@666D;
ParetoPlotAFlattenATableAi, 8i, 1, 7<, 9RandomInteger@81, 12<D=EEE
Out[151]=
Quantile plots are used to visualize whether two data sets come from the same popu-
lation. If so, the data lies along a straight line reference line.
In[152]:=
GraphicsRow@
8QuantilePlot@RandomReal@8-1, 1<, 100D, RandomReal@8-1, 1<, 100DD,
QuantilePlot@RandomReal@8-1, 1<, 100D,
RandomReal@NormalDistribution@0, 1D, 100DD<D
Out[152]=
ÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ
-0.5
0.5
1.0
-1.0
-0.5
0.5
1.0
ÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ
Ê
-1.0-0.5
0.51.0
-2
-1
1
2
PairwiseScatterPlot  plots  each  column  of  a  matrix  against  each  of  the  other
columns.  The  diagonals  will  always  be  straight  lines.  The  following  plot  of  2006,
2007,  and  2008  Dow  Jones  Industrial  Average  (DJIA)  data  shows  how  2006  and
2008  had  nearly  inverse  trends,  whereas  2007  deviated  in  the  middle  of  the  year
from the 2008 data.
12.14 Creating Common Statistical Plots | 495

In[153]:=
PairwiseScatterPlot@Transpose@8Rescale@
FinancialData@"^DJI", 882006, 1, 1<, 82006, 12, 31<<D@@All, 2DDD,
Rescale@FinancialData@"^DJI", 882007, 1, 1<, 82007, 12, 31<<D@@All, 2DDD,
Drop@Rescale@FinancialData@"^DJI", 882008, 1, 1<, 82008, 12, 31<<D@@
All, 2DDD, 2D<D, DataLabels Ø 8"2006", "2007", "2008"<D
Out[153]=
2006
2007
2008
2008
2007
2006
See Also
The  tutorial  StatisticalPlots/tutorial/StatisticalPlots  in  the  documentation  provides
many examples for customizing these plots to your needs.
12.15 Quasi-Random Number Generation
Problem
You need to generate random numbers, but you want to avoid the inevitable cluster-
ing that occurs using pseudorandom generators. This type of generator is sometimes
called quasirandom.
496 | Chapter 12: Statistics and Data Analysis

Solution
Notice the clumping in this randomly generated list plot of 500 points. 
In[154]:=
WithA8N = 500<,
ListPlotA RandomReal@80, 1<, 8N, 2<D,
PlotStyle Ø Black, Frame Ø True, AspectRatio Ø 1, ImageSize Ø SmallEE
Out[154]=
0.0
0.2
0.4
0.6
0.8
1.0
0.0
0.2
0.4
0.6
0.8
1.0
The van der Corput sequence takes the digits of an integer in a given base b, and
then reflects them about the decimal point. This maps the numbers from 1 to n into
a set of numbers [0,1] in an even distribution, provided n is one less than a power of
the base.
In[155]:=
corput@n_, b_D :=
IntegerDigits@n, bD.Ib ^ RangeA-FloorALog@b, nD + 1E, -1EM;
SetAttributes@corput, ListableD
12.15 Quasi-Random Number Generation | 497

The Halton sequence shows that a good way to distribute the values in n dimensions
is to use the first n primes as the bases used with van der Corput. 
In[157]:=
halton@n_, s_D := corputAn, PrimeARange@sDEE
WithA8N = 500<, ListPlotATable@halton@n, 2D, 8n, N<D,
PlotStyle Ø Black, Frame Ø True, AspectRatio Ø 1, ImageSize Ø SmallEE
Out[158]=
0.0
0.2
0.4
0.6
0.8
1.0
0.0
0.2
0.4
0.6
0.8
1.0
As  you  can  see,  this  gives  far  less  clumpy  distribution  of  points  than  RandomReal
gives.
Discussion
These quasirandom numbers are often used in simulations and Monte Carlo meth-
ods. One problem with these sequences is that they always give you the same set of
numbers. One possibility is to perturb each number by a small random epsilon (e).
This more or less preserves the even distribution provided the random perturbation
is small.
498 | Chapter 12: Statistics and Data Analysis

In[159]:=
halton@n_, s_, e_D :=
ClipAcorputAn, PrimeARange@sDEE + RandomReal@8-e, e<D, 80, 1<E
In[160]:=
WithA8N = 500<,
GraphicsRowA9
ListPlotATable@halton@n, 2, 0.01D, 8n, N<D,
PlotStyle Ø Black, Frame Ø True, AspectRatio Ø 1, ImageSize Ø SmallE,
ListPlotATable@Halton@n, 2, 0.05D, 8n, N<D,
PlotStyle Ø Black, Frame Ø True, AspectRatio Ø 1, ImageSize Ø SmallE=EE
Out[160]=
0.0
0.2
0.4
0.6
0.8
1.0
0.0
0.2
0.4
0.6
0.8
1.0
-1.0
-0.5
0.0
0.5
1.0
-1.0
-0.5
0.0
0.5
1.0
See Also
An  excellent  reference  is  this  Quasi-Monte  Carlo  Simulation  website  found  at
http://bit.ly/2vdGQs.
Interesting  papers  and  Mathematica  notebooks  that  explore  quasirandomness
can  be  found  at  James  Propp’s  University  of  Massachusetts  Lowell  website
(http://bit.ly/7kC32).
12.16 Creating Stochastic Simulations 
Problem
You want to create a simulation as a means of developing a better understanding of
the long-term behavior of a system governed by randomness.
12.16 Creating Stochastic Simulations | 499

Solution
One of the most well-known types of stochastic processes is the random walk. A ran-
dom walk can occur in one-, two-, three-, or even higher dimensional space, but it
is easiest to visualize in one or two dimensions. Here I show a random walk on a 2D
lattice. A particle (or drunkard, if you prefer) starts at the origin {0,0} and can take a
step east {0,1}, west {0,-1}, north {1,0} or south {-1,0}.
In[161]:=
latticeWalk2D@n_D := Module@8start = 80, 0<,
east = 81, 0<, west = 8-1, 0<, north = 80, 1<, south = 80, -1<<,
NestList@Ò + RandomChoice@8east, west, north, south<D &, start, nDD
The walk is generated by specifying a number of steps and can be visualized using
ListLinePlot or using arrows for each step, as I show in Out[163] below. Here I use
SeedRandom only to make sure I always get the same walk no matter how many times
this notebook is evaluated before going to press! 
In[162]:=
SeedRandom@1004D; walk = latticeWalk2D@50D
Out[162]=
880, 0<, 8-1, 0<, 80, 0<, 80, 1<, 80, 0<, 80, 1<, 8-1, 1<, 8-1, 2<,
80, 2<, 8-1, 2<, 8-1, 1<, 8-2, 1<, 8-1, 1<, 8-1, 2<, 80, 2<, 80, 1<,
80, 2<, 8-1, 2<, 8-1, 1<, 8-1, 0<, 8-1, 1<, 8-2, 1<, 8-3, 1<, 8-4, 1<,
8-4, 2<, 8-5, 2<, 8-5, 3<, 8-6, 3<, 8-6, 2<, 8-5, 2<, 8-6, 2<, 8-6, 1<,
8-5, 1<, 8-5, 0<, 8-5, -1<, 8-5, -2<, 8-6, -2<, 8-7, -2<, 8-8, -2<,
8-9, -2<, 8-10, -2<, 8-10, -3<, 8-10, -4<, 8-11, -4<, 8-10, -4<,
8-11, -4<, 8-10, -4<, 8-11, -4<, 8-12, -4<, 8-11, -4<, 8-10, -4<<
In[163]:=
GraphicsA8Arrowheads@SmallD, Arrow êü Partition@walk, 2, 1D,
PointSize@0.03D, Green, Point@First@walkDD, Red,
Point@Last@walkDD<, ImageSize Ø All, Axes Ø TrueE
Out[163]=
-12
-10
-8
-6
-4
-2
-4
-3
-2
-1
1
2
3
500 | Chapter 12: Statistics and Data Analysis

Discussion
Some simulations contain constraints on what can happen at each step. For exam-
ple, if you wanted a walk for which a back-step is disallowed, you could remember
the previous step and remove its inverse from the population on the generation. 
In[164]:=
latticeWalk2DNoBackStep@n_D :=
ModuleA8start = 80, 0<, east = 81, 0<, west = 8-1, 0<,
north = 80, 1<, south = 80, -1<, steps, last<,
steps = 8east, west, north, south<;
H*Initialize last to a step not in the
population so not to remove anything the first time.*L
last = 81, 1<;
H*At each step the inverse H-lastL
is removed from possible steps using Complement.*L
NestList@Ò + Hlast = RandomChoice@Complement@steps, 8-last<DDL &,
start, nDE
In[165]:=
SeedRandom@778D; walk = latticeWalk2DNoBackStep@25D
Out[165]=
880, 0<, 81, 0<, 82, 0<, 82, -1<, 83, -1<, 84, -1<, 85, -1<, 85, -2<,
86, -2<, 86, -1<, 86, 0<, 85, 0<, 84, 0<, 84, 1<, 85, 1<, 85, 2<, 86, 2<,
87, 2<, 87, 1<, 87, 0<, 88, 0<, 89, 0<, 89, 1<, 88, 1<, 88, 2<, 88, 3<<
In[166]:=
GraphicsA8Arrowheads@SmallD, Arrow êü Partition@walk, 2, 1D,
PointSize@0.02D, Green, Point@First@walkDD, Red,
Point@Last@walkDD<, ImageSize Ø Medium, Axes Ø TrueE
Out[166]=
2
4
6
8
-2
-1
1
2
3
Given  a  simulation,  you  will  usually  want  to  understand  its  behavior  over  many
runs. One obvious metric is the distance from the origin. You might postulate, for
example,  that  the  average  distance  from  the  origin  for  latticeWalk2D  will  be  less
12.16 Creating Stochastic Simulations | 501

than  latticeWalk2DNoBackStep.  By  running  the  simulation  500  times  for  each  case
and computing the mean, median, and other statistics, you can be more confident
this intuition is correct. You can also see that the advantage seems to be only about
two steps.
In[167]:=
ModuleA8distL2D, distL2DNoBack, walkDistance,
statFuncs = 8Mean, Median, Max, Min, Variance, StandardDeviation<<,
walkDistance@walk_D := ManhattanDistance@First@walkD, Last@walkDD;
distL2D = Table@walkDistance@latticeWalk2D@25DD, 8500<D;
distL2DNoBack =
Table@walkDistance@latticeWalk2DNoBackStep@25DD, 8500<D;
TableFormA9Through@statFuncs@ distL2DDD,
Through@statFuncs@ distL2DNoBackDD= êê N, TableHeadings Ø
98"Unconstrained", "No Back Step"<, ToString êü statFuncs=EE
Out[167]//TableForm=
Mean
Median Max Min Variance StandardDeviation
Unconstrained 5.616 5.
15. 1.
8.69393
2.94855
No Back Step
7.78
7.
21. 1.
13.8754
3.72496
Simulation is also powerful as a tool for persuading someone of a truth that seems to
defy  intuition.  A  famous  example  is  the  Monty  Hall  problem.  This  problem  is
named after a U.S. game show called “Let’s Make a Deal,” which was popular in the
1960s and ’70s and hosted by Monty Hall. A well-known statement of the problem
was published in Parade magazine (“Ask Marilyn,” Sept. 1990, 16):
Suppose you’re on a game show, and you’re given the choice of three doors:
Behind one door is a car; behind the others, goats. You pick a door, say No.
1, and the host, who knows what’s behind the doors, opens another door,
say No. 3, which has a goat. He then says to you, “Do you want to pick
door No. 2?” Is it to your advantage to switch your choice?
For many people, the intuitive answer is that there is no advantage in switching be-
cause there is a 50/50 chance you have the car either way you go. There even seems
to be a bias for not switching, based on the platitude “go with your first instincts.”
However, if you analyze the problem correctly (see the following analysis) there is a
2/3 probability of getting the car if you switch. But the analysis is subtle and appar-
ently fails to convince even some very intelligent people, so perhaps a simulation is
helpful. An advantage of creating the simulation is that it makes it clear just what
you mean by this problem. Specifically, we are talking about the best decision over
many trials for a problem where the initial choice of door is random, the placement
of the car is random, and Monty always shows the door that contains a goat. In this
simulation, we call sticking with your first choice strategy1 and switching to the re-
maining door strategy2. The simulation is purposefully without any cute functional
502 | Chapter 12: Statistics and Data Analysis

programming tricks so it is clear that at each step we are accurately following the
rules of the game.
In[168]:=
H*randomPick is similar to RandomChoice except we want
the position of the choice rather than the choice itself.*L
randomPick@choices_ListD :=
ModuleA8<, RandomIntegerA91, Length@choicesD=EE
H*simulateStrat1VSStrat2 computes the winnings over a number
of trials for strategy1 HstickL and strategy2 HswitchL.*L
simulateStrat1VSStrat2Atrials_IntegerE :=
ModuleA9GOAT = 0, CAR = 1, doors, firstPick, secondPick,
winnings1 = 0, winnings2 = 0, doorsTemp, makePrizes=,
H*There are 3 possible initial game configurations. These
can be generated using Permutations.*L
SeedRandom@D;
DoA
H*Randomly pick one of the
three possible initial game configurations.*L
doors = RandomSample@8GOAT, GOAT, CAR<D;
H*Contestant picks a door at random. Recall this
is the position of the prize, not the prize itself.*L
firstPick = randomPick@doorsD;
H*Winnings of contestant who keeps first pick always*L
winnings1 += doors@@firstPickDD;
H*Delete first pick from choices.*L
doorsTemp = Drop@doors, 8firstPick<D;
H*Delete goat from remaining; this is where Monty shows the goat.
Here I use position to find a goat and, since there could be two,
I arbitrarily remove the first.*L
doorsTemp = Drop@doorsTemp, Position@doorsTemp, GOATD@@1DDD;
H*Contestant following second
strategy always switches to remaining prize.*L
secondPick = doorsTemp@@1DD;
H*Winnings of contestant who switches*L
winnings2 += secondPick,
8trials<E;
9winnings1, winnings2=E
You  can  now  simulate  any  number  of  games  and  compare  the  accumulated  win-
nings over that many games. Here I show the results where the number of games
12.16 Creating Stochastic Simulations | 503

varies from 10 to 100,000 in increments of powers of 10. Clearly strategy2, always
switching, is the way to play the Monty Hall game.
In[170]:=
Table@simulateStrat1VSStrat2@10^iD, 8i, 1, 5<D êê TableForm
Out[170]//TableForm=
4
6
34
66
304
696
3345
6655
33321 66679
The Monty Hall game analysis that leads to the correct conclusion is as follows: Con-
sider the probability of not picking the car at the start of the game. Since there are 2
goats and 1 car, the probability of not picking a car is 2/3. Now consider what hap-
pens when Monty shows you a goat. In effect he tells you that IF you did not pick a
car initially, THEN there is definitely a car behind the remaining door. We agreed
that the probability of not having picked the car initially was 2/3, so now the proba-
bility of the car being behind the remaining door must be 2/3. The simulation we’re
given  shows this to be the case.
See Also
Computer Simulations with Mathematica: Explorations in Complex Physical and Bio-
logical by Richard J. Gaylord and Paul R. Wellin (Springer-Verlag TELOS) demon-
strates a variety of simple simulations, but some of the examples need to be updated
to Mathematica 6 and 7. 
Chapter 14, “Financial Engineering,” contains an example of Monte Carlo simula-
tion that is a very popular technique in finance and the physical sciences.
The  Wolfram  Demonstration  Project  (http://bit.ly/40hsJD)  contains  many  small
simulation problems that exploit Mathematica’s dynamic capabilities.
504 | Chapter 12: Statistics and Data Analysis

CHAPTER 13
Science and Engineering
Mmm~but it’s poetry in motion
And when she turned her eyes to me
As deep as any ocean
As sweet as any harmony
Mmm~but she blinded me with science
And failed me in geometry
When she’s dancing next to me
“Blinding me with science~science!”
“Science!”
I can hear machinery
“Blinding me with science~science!”
“Science!”
Thomas Dolby, “She Blinded Me With Science”
13.0 Introduction
Scientists and engineers make up a large part of the Mathematica user base, and it is
hard  to  think  of  any  scientific  or  engineering  practitioner,  no  matter  how  special-
ized, who could not benefit from Mathematica. I am neither a scientist nor an engi-
neer by profession, but just fiddling around with Mathematica has given me insights
into scientific and engineering ideas that otherwise would have taken many years
of study.
The goals of this chapter are threefold. First, I want to illustrate techniques for orga-
nizing solutions to problems. Many science and engineering problems require numer-
ous variables, and organization becomes paramount. There is not one correct way to
organize complex solutions, but I provide two different approaches in Recipes 13.6
and 13.11. The second goal is to take some of the theoretical recipes covered in ear-
lier chapters and apply them to real-world problems. I often see posts on Mathemati-
ca’s primary mailing list questioning the usefulness  of  function  or  pattern-based
programming on real-world problems. Other posters express a wish to use these
505

techniques but can’t get themselves on the right track. This chapter contains recipes
to which most scientists and engineers can relate, and all use a mixture of functional
and  pattern-based  ideas.  An  auxiliary  goal  is  to  take  some  of  the  functions  intro-
duced in Chapter 11 and make each the focus of a recipe. The third goal of the chap-
ter is to introduce some special features of Mathematica that we did not have
occasion to discuss in earlier recipes. 
One important feature introduced in Mathematica 6 that gained momentum in ver-
sion 7 is curated data sources. These high-quality data sources alone are worth the
cost  of  admission  to  Mathematica’s  user  base.  Recipes  13.1  through  13.4  discuss
some sources pertinent to the sciences. Chapter 14 includes recipes related to finan-
cial  data  sources.  All  these  sources  have  a  uniform,  self-describing  structure.  You
can query any data source for the kinds of data it provides using syntax DataSource
["Properties"]. This will give you a list of properties. Each property describes an im-
portant subset of the data held by the source. You use the properties along with keys
to  retrieve  particular  values.  For  example,  ElementData[1,  "AtomicWeight"]  gives
1.00794, the atomic weight of hydrogen. Once you master the data source concept,
you will quickly be able to leverage new data sources as they become available.
Recipe 13.5 applies the discrete calculus function RSolve from Recipe 11.10 to solve
a standard predator-prey problem. Here I also demonstrate how Mathematica’s inter-
active features can be used to explore the solution space and gain insight into the dy-
namics of the problem. 
In Recipe 13.6, I solve a relatively straightforward problem in rigid body dynamics.
The primary purpose of this recipe is to illustrate one way you might organize a prob-
lem with many objects and many parameters per object. This recipe highlights Math-
ematica’s  flexible  ways  of  creating  names  of  things,  an  ability  you  should  exploit
when  modeling  complex  problems.  Recipe  13.11  uses  the  topic  of  finite  element
method (FEM) to illustrate an alternate way to organize a problem that uses a lot of
data and a variety of related functions. The interface developed here follows a trend
that is becoming more popular in new Mathematica features (e.g., LinearModelFit).
Recipes  13.7  through  13.10  focus  on  applied  differential  equations.  Here  I  solve
some problems symbolically using DSolve and some problems numerically using
NDSolve. These recipes show how to set up initial and boundary conditions, how to
leverage Fourier series in obtaining solutions, and how to visualize solutions.
506 | Chapter 13: Science and Engineering

13.1 Working with Element Data
Problem
You want to perform computations that take as input information about the chemi-
cal elements. You may also want to create visual displays of this information for
reference or classroom use.
Solution
You can list the names of all the elements using ElementData[] or the name of the
nth element using ElementData[n].
In[1]:=
ElementData@D
Out[1]=
9Hydrogen, Helium, Lithium, Beryllium, Boron, Carbon, Nitrogen, Oxygen,
Fluorine, Neon, Sodium, Magnesium, Aluminum, Silicon, Phosphorus, Sulfur,
Chlorine, Argon, Potassium, Calcium, Scandium, Titanium, Vanadium,
Chromium, Manganese, Iron, Cobalt, Nickel, Copper, Zinc, Gallium,
Germanium, Arsenic, Selenium, Bromine, Krypton, Rubidium, Strontium,
Yttrium, Zirconium, Niobium, Molybdenum, Technetium, Ruthenium, Rhodium,
Palladium, Silver, Cadmium, Indium, Tin, Antimony, Tellurium, Iodine,
Xenon, Cesium, Barium, Lanthanum, Cerium, Praseodymium, Neodymium,
Promethium, Samarium, Europium, Gadolinium, Terbium, Dysprosium,
Holmium, Erbium, Thulium, Ytterbium, Lutetium, Hafnium, Tantalum,
Tungsten, Rhenium, Osmium, Iridium, Platinum, Gold, Mercury, Thallium,
Lead, Bismuth, Polonium, Astatine, Radon, Francium, Radium, Actinium,
Thorium, Protactinium, Uranium, Neptunium, Plutonium, Americium,
Curium, Berkelium, Californium, Einsteinium, Fermium, Mendelevium,
Nobelium, Lawrencium, Rutherfordium, Dubnium, Seaborgium, Bohrium,
Hassium, Meitnerium, Darmstadtium, Roentgenium, Ununbium, Ununtrium,
Ununquadium, Ununpentium, Ununhexium, Ununseptium, Ununoctium=
In[2]:=
ElementData@1D
Out[2]=
Hydrogen
Mathematica will return properties of an element if given its number and the name
of the property.
In[3]:=
RowA9ElementData@1D, ElementData@1, "AtomicNumber"D,
ElementDataA1, "AtomicWeight"E, ElementData@1, "Phase"D=, "\t"E
Out[3]=
Hydrogen
1
1.00794
Gas
13.1 Working with Element Data | 507

Discussion
You can see from the list of all properties that Mathematica has a comprehensive
database of elemental data. Be aware that CommonCompoundNames will pull in a lot of
data if you use it with a common element like hydrogen.
In[4]:=
Partition@ElementData@"Properties"D, 3, 3, 1, ""D êê TableForm
Out[4]//TableForm=
Abbreviation
AbsoluteBoilingPoint
AbsoluteMeltingPoint
AdiabaticIndex
AllotropeNames
AllotropicMultiplicities
AlternateNames
AlternateStandardNames
AtomicNumber
AtomicRadius
AtomicWeight
Block
BoilingPoint
BrinellHardness
BulkModulus
CASNumber
Color
CommonCompoundNames
CovalentRadius
CriticalPressure
CriticalTemperature
CrustAbundance
CrystalStructure
CuriePoint
DecayMode
Density
DiscoveryCountries
DiscoveryYear
ElectricalConductivity
ElectricalType
ElectronAffinity
ElectronConfiguration
ElectronConfigurationString
Electronegativity
ElectronShellConfiguration FusionHeat
GasAtomicMultiplicities
Group
HalfLife
HumanAbundance
IconColor
IonizationEnergies
IsotopeAbundances
KnownIsotopes
LatticeAngles
LatticeConstants
Lifetime
LiquidDensity
MagneticType
MassMagneticSusceptibility MeltingPoint
Memberships
MeteoriteAbundance
MohsHardness
MolarMagneticSusceptibility
MolarVolume
Name
NeelPoint
NeutronCrossSection
NeutronMassAbsorption
OceanAbundance
Period
Phase
PoissonRatio
QuantumNumbers
Radioactive
RefractiveIndex
Resistivity
ShearModulus
SolarAbundance
SoundSpeed
SpaceGroupName
SpaceGroupNumber
SpecificHeat
StableIsotopes
StandardName
SuperconductingPoint
ThermalConductivity
ThermalExpansion
UniverseAbundance
Valence
VanDerWaalsRadius
VaporizationHeat
VickersHardness
VolumeMagneticSusceptibility
YoungModulus
The most obvious application of ElementData is to create a periodic table. The
ElementData documentation shows code for a simple table. Here I show a more
ambitious one, complete with Tooltip.
508 | Chapter 13: Science and Engineering

In[5]:=
makeElemDetail@a_D :=
ModuleA9abr, name, atomicWeight, density, melting, boiling, color, phase=,
9abr, name, atomicWeight, density, melting, boiling, color, phase= = TableA
ElementData@a, pD, 9p, 9"Abbreviation", "StandardName", "AtomicWeight",
"Density", "MeltingPoint", "BoilingPoint", "Color", "Phase"==E;
GridA98name, SpanFromLeft, a<, 9abr, atomicWeight, "amu"=,
9"Density", density, "Kgêm3"=, 9"Melting Pt", melting, "C"=,
9"Boiling Pt.", boiling, "C"=, 8"Phase", color, phase<=, Frame Ø All,
Alignment Ø 99Left, Right, Right=, 8Center, Center, Center<=E
E
makeElem@a_, size_D :=
ModuleA9abr, name, atomicWeight=, abr = ElementData@a, "Abbreviation"D;
atomicWeight = ElementDataAa, "AtomicWeight"E;
GraphicsA9TextAStyleAToString@aD, 9, Bold,
FontFamily -> "Helvetica", TextAlignment Ø CenterE, 80, 20<E,
TextAStyleAabr, 20, FontWeight Ø "Bold", FontFamily -> "Helvetica"E,
80, 0<E, TextAStyleAToStringAatomicWeightE, 8,
FontFamily -> "Helvetica", TextAlignment Ø CenterE, 80, -20<E=,
ImageSize Ø 8size, size<EE
makePeriodicTable@w_, h_D :=
ModuleA9elemData, frame, background, re1 = 57, re2 = 71, re3 = 89,
re4 = 103, gsz = 42=, elemData = Table@ElementData@e, pD,
8e, 1, 118<, 8p, 8"AtomicNumber", "Period", "Group"<<D;
frame = 9None, None, CasesAelemData,
9a_Integer, p_, g_Integer= ß I9p, g= Ø TrueME=;
background = 9None, None, CasesAelemData, 9a_Integer, p_, g_Integer= ß
I9p, g= Ø ElementData@a, "IconColor"DME=;
ColumnA9
GraphicsGridANormalASparseArrayA
CasesAelemData, 9a_Integer, p_, g_Integer= ß I9p, g= Ø aMEEE ê.
9a_Integer ê; a > 0 ß TooltipAmakeElemAa, gszE, makeElemDetail@aDE,
0 Ø Graphics@8<D=, Frame Ø frame, Background -> background,
ImageSize Ø 8w, h<E,
GraphicsGridA9TableATooltipAmakeElemAa, gszE, makeElemDetail@aDE,
8a, re1, re2<E, TableAmakeElemAa, gszE, 8a, re3, re4<E=,
ImageSize Ø 8w - 100, 100<, Background Ø 8None, None,
Flatten@Table@881, a - re1 + 1< -> ElementData@a, "IconColor"D,
82, a - re1 + 1< -> ElementData@a + re3 - re1, "IconColor"D<,
8a, re1, re2<DD<E=, Alignment Ø 8Center, Automatic<EE
13.1 Working with Element Data | 509

In[8]:=
makePeriodicTable@650, 300D
Out[8]=
1H
1.00794
2He
4.002602
3Li
6.941
4Be
9.012182
5B
10.811
6C
12.0107
7N
14.0067
8O
15.9994
9F
8.9984032
10
Ne
20.1797
11
Na
22.989770
12
Mg
24.3050
13Al
26.981538
14Si
28.0855
15P
30.973761
16S
32.065
17Cl
35.453
18
Ar
39.948
19K
39.0983
20
Ca
40.078
21
Sc
44.955910
22Ti
47.867
23V
50.9415
24
Cr
51.9961
25
Mn
54.938049
26
Fe
55.845
27
Co
58.9332
28Ni
58.6934
29
Cu
63.546
30
Zn
65.409
31
Ga
69.723
32
Ge
72.64
33
As
74.92160
34
Se
78.96
35
Br
79.904
36
Kr
83.798
37
Rb
85.4678
38Sr
87.62
39Y
88.90585
40Zr
91.224
41
Nb
92.90638
42
Mo
95.94
43
Tc
98
44
Ru
101.07
45
Rh
102.90550
46
Pd
106.42
47
Ag
107.8682
48
Cd
112.411
49In
114.818
50
Sn
118.710
51
Sb
121.760
52
Te
127.60
53I
126.90447
54
Xe
131.293
55
Cs
132.90545
56
Ba
137.327
71
Lu
174.967
72Hf
178.49
73
Ta
180.9479
74W
183.84
75
Re
186.207
76
Os
190.23
77Ir
192.217
78Pt
195.078
79
Au
196.96655
80
Hg
200.59
81Tl
204.3833
82
Pb
207.2
83Bi
208.98038
84
Po
209
85At
210
86
Rn
222
87Fr
223
88
Ra
226
103
Lr
262
104
Rf
261
105
Db
262
106
Sg
266
107
Bh
264
108
Hs
277
109
Mt
268
110
Ds
281
111
Rg
272
112
Uub
285
113
Uut
284
114
Uuq
289
115
Uup
288
116
Uuh
292
117
Uus
ing@Unkno
118
Uuo
294
57
La
138.9055
58
Ce
140.116
59Pr
140.90765
60
Nd
144.24
61
Pm
145
62
Sm
150.36
63
Eu
151.964
64
Gd
157.25
65
Tb
158.92534
66
Dy
162.5
67
Ho
164.93032
68Er
167.259
69
Tm
168.93421
70
Yb
173.04
71
Lu
174.967
89
Ac
227
90
Th
232.0381
91
Pa
231.03588
92U
238.02891
93
Np
237
94
Pu
244
95
Am
243
96
Cm
247
97
Bk
247
98Cf
251
99
Es
252
100
Fm
257
101
Md
258
102
No
259
103
Lr
262
13.2 Working with Chemical Data
Problem
You want to perform computations that take as input information about the chemi-
cal compounds. You may also want to create visual displays of this information for
reference or classroom use.
Solution
ChemicalData is a curated data source. You can request chemical information by com-
mon names, registry numbers, IUPAC-like names, or structure strings.
In[9]:=
ChemicalData@"Water"D
Out[9]=
O
H
O
H
In[10]:=
ChemicalData@"CO2", "IUPACName"D
Out[10]=
carbon dioxide
In[11]:=
ChemicalData@"CID5234", "Name"D
Out[11]=
8sodium chloride, sodium chloride-35 Cl<
In[12]:=
ChemicalDataA"Glucose", "CompoundFormulaDisplay"E
Out[12]=
9C6H12O6, C6H12O6, C6H12O6, C6H12O6=
510 | Chapter 13: Science and Engineering

In[13]:=
GraphicsRowAChemicalData@"Glucose", "MoleculePlot"D, ImageSize Ø LargeE
Out[13]=
Discussion
The list of properties of chemical compounds is quite impressive. The table below
lists a random subset of the full list of 101 properties.
In[14]:=
Partition@Sort@RandomSample@ChemicalData@"Properties"D, 30DD, 3D êê
TableForm
Out[14]//TableForm=
AcidityConstant
BoilingPoint
CHStructureDiagram
CIDNumber
CompoundFormulaDisplay
CriticalPressure
CriticalTemperature
FlashPointFahrenheit
FormattedName
HildebrandSolubility IUPACName
MDLNumber
MeltingPoint
NFPAHazards
NFPAHealthRating
NFPALabel
NonStandardIsotopeCount
NonStandardIsotopeNumbers
PartitionCoefficient Phase
Resistivity
RotatableBondCount
SideChainAcidityConstant SpaceFillingMoleculePlot
StructureDiagram
TautomerCount
TopologicalPolarSurfaceArea
VaporPressureTorr
VertexTypes
Viscosity
At  the  time  of  this  writing,  Mathematica  has  curated  data  on  over  34,300  com-
pounds, subdivided into 67 classes. 
In[15]:=
Length@ChemicalData@DD
Out[15]=
34336
In[16]:=
ChemicalData@"Classes"D
Out[16]=
9AcidAnhydrides, AcidHalides, Acids, Alcohols, Aldehydes, Alkanes,
Alkenes, Alkynes, Alloys, Amides, Amines, AminoAcidDerivatives,
AminoAcids, Arenes, Aromatic, Bases, Brominated, Carbohydrates,
CarboxylicAcids, Catalysts, Cations, Ceramics, Chiral, Chlorinated,
Dendrimers, Esters, Ethers, Fluorinated, Furans, Gases, Halogenated,
HeavyMolecules, Heterocyclic, Hydrides, Hydrocarbons, Imidazoles,
Indoles, Inorganic, Iodinated, IonicLiquids, Ketones, Ligands,
Lipids, Liquids, MetalCarbonyls, Monomers, Nanomaterials, Nitriles,
Organic, Organometallic, Oxides, Phenols, Piperazines, Piperidines,
Polymers, Pyrazoles, Pyridines, Pyrimidines, Quinolines, Salts, Solids,
Solvents, Sulfides, SyntheticElements, Thiazoles, Thiols, Thiophenes=
13.2 Working with Chemical Data | 511

There are six kinds of structural diagrams that can be used to visualize these com-
pounds.  Here,  for  example,  are  representations  for  what  may  be  one  of  your  fa-
vorites, for better or worse~caffeine.
In[17]:=
GraphicsGridAPartitionA
TableAChemicalData@"Caffeine", pD, 9p, 9"CHColorStructureDiagram",
"CHStructureDiagram", "ColorStructureDiagram", "StructureDiagram",
"MoleculePlot", "SpaceFillingMoleculePlot"==E, 3E, ImageSize Ø LargeE
Out[17]=
You can use the data to analyze relationships between properties. Here I show a plot
of inverse vapor pressure to boiling point for all liquids with a Tooltip around each
point so outliers are easy to identify. Cases is used to filter out any MissingData entries.
In[18]:=
ListLogLogPlotACasesATableA9ChemicalData@c, "VaporPressure"D,
ChemicalDataAc, "BoilingPoint"E, c=, 8c, ChemicalData@"Liquids"D<E,
9vp_Real, bp_Real, c_String= ß Tooltip@81êvp, bp<, cDEE
Out[18]=
512 | Chapter 13: Science and Engineering

13.3 Working with Particle Data
Problem
You want to perform computations that take as input information about the elemen-
tary particles. You may also want to create visual displays of this information for ref-
erence or classroom use.
Solution
In[19]:=
ParticleData@"Classes"D
Out[19]=
9Baryon, BBBarMeson, Boson, BottomBaryon, BottomMeson,
CCBarMeson, CharmedBaryon, CharmedMeson, Fermion, GaugeBoson,
Hadron, Lepton, LongLived, Meson, Neutrino, Pentaquark, Quark,
Stable, StrangeBaryon, StrangeCharmedBaryon, StrangeCharmedMeson,
StrangeMeson, UnflavoredBaryon, UnflavoredMeson=
It is easy to create functions that generate tables of particle information. The func-
tion  particleTable  accepts  a  list  of  one  or  more  class  memberships  (e.g.,  Baryon,
LongLived, and others from ParticleData["Classes"]) and a list of properties to use
as columns. The helper function particleData reformats "QuarkContent" into a more
concise representation. You will often want to filter out entries that are missing since
there is only partial data available for exotic particles. 
In[20]:=
particleData@p_, "QuarkContent"D :=
FlattenA ParticleData@p, "QuarkContent"D ê.
q_String ß
ParticleDataAq, "Symbol"EE
particleData@p_, prop_D := ParticleData@p, propD
particleTable@memberships_List, properties_ListD := ModuleA8<,
GridAPrepend@
Table@particleData@particle, ÒD & êü properties,
8particle, Select@ParticleData@D,
HIntersection@ParticleData@Ò, "Memberships"D, membershipsD ã
memberships L &D<D, propertiesD ê.
9Missing@"Unknown"D Ø "?", Missing@"NotAvailable"D Ø "NêA"=,
Frame Ø All,
ItemStyle Ø
9Automatic, Automatic, 9981, 1<, 91, Length@propertiesD== Ø Bold==E
E
Create a table of long-lived baryons. A baryon is a particle made of three quarks, and
long-lived refers to particles whose lifetime is greater than 10|20 seconds.
13.3 Working with Particle Data | 513

In[23]:=
particleTableA9"Baryon", "LongLived"=, 9"StandardName",
"Symbol", "Mass", "Charge", "Lifetime", "Isospin", "QuarkContent"=E
Out[23]=
StandardName
Symbol
Mass
Charge
Lifetime
Isospin
QuarkContent
Lambda
L
1115.683
0
2.632µ10-10
0
8s, d, u<
LambdaBar
L
1115.683
0
2.632µ10-10
0
:s, d, u>
Neutron
n
939.56536
0
885.6
1
2
8d, d, u<
NeutronBar
n
939.56536
0
885.6
1
2
:d, d, u>
Omega
W
1672.45
-1
8.21µ10-11
0
8s, s, s<
OmegaBar
W
1672.45
1
8.21µ10-11
0
9s, s, s=
Proton
p
938.27203
1
¶
1
2
8d, u, u<
ProtonBar
p
938.27203
-1
¶
1
2
:d, u, u>
SigmaBarMinus
S-
1189.37
-1
8.018µ10-11
1
9s, u, u=
SigmaBarPlus
S+
1197.449
1
1.48µ10-10
1
:s, d, d>
SigmaBarZero
S0
1192.642
0
7.4µ10-20
1
:s, d, u>
SigmaMinus
S-
1197.449
-1
1.48µ10-10
1
8s, d, d<
SigmaPlus
S+
1189.37
1
8.018µ10-11
1
8s, u, u<
SigmaZero
S0
1192.642
0
7.4µ10-20
1
8s, d, u<
XiBarPlus
X+
1321.31
1
1.64µ10-10
1
2
:s, s, d>
XiBarZero
X0
1314.83
0
2.90µ10-10
1
2
9s, s, u=
XiMinus
X-
1321.31
-1
1.64µ10-10
1
2
8s, s, d<
XiZero
X0
1314.83
0
2.90µ10-10
1
2
8s, s, u<
8LambdaB, 0<
Lb
5624.
0
1.23µ10-12
0
8b, d, u<
8LambdaBBar, 0<
Lb
5624.
0
1.23µ10-12
0
:b, d, u>
8LambdaC, 1<
Lc
2286.46
1
2.0µ10-13
0
8c, d, u<
8LambdaCBar, -1<
Lc
2286.46
-1
2.0µ10-13
0
:c, d, u>
8OmegaC, 0<
Wc
2697.5
0
6.9µ10-14
0
8c, s, s<
8OmegaCBar, 0<
Wc
2697.5
0
6.9µ10-14
0
9c, s, s=
8XiC, 0<
Xc
0
2471.
0
1.1µ10-13
1
2
8c, s, d<
8XiC, 1<
Xc
+
2467.9
1
4.42µ10-13
1
2
8c, s, u<
8XiCBar, -1<
Xc
-
2467.9
-1
4.42µ10-13
1
2
9c, s, u=
8XiCBar, 0<
Xc
0
2471.
0
1.1µ10-13
1
2
:c, s, d>
8XiCC, 1<
Xcc
3518.9
1
3.3000µ10-14
?
8c, c, d<
8XiCCBar, -1<
Xcc
3518.9
-1
3.3000µ10-14
?
:c, c, d>
514 | Chapter 13: Science and Engineering

Discussion
The list of properties available in particle data are as follows:
In[24]:=
Transpose@Partition@ParticleData@"Properties"D, 9, 9, 1, ""DD êê TableForm
Out[24]//TableForm=
Antiparticle Excitations
Isospin
PDGNumber
BaryonNumber FullDecayModes
IsospinMultiplet
QuarkContent
Bottomness
FullSymbol
IsospinProjection
Spin
Charge
GenericFullSymbol LeptonNumber
Strangeness
ChargeStates GenericSymbol
Lifetime
Symbol
Charm
GFactor
Mass
Topness
CParity
GParity
MeanSquareChargeRadius UnobservedDecayModes
DecayModes
HalfLife
Memberships
Width
DecayType
Hypercharge
Parity
In[25]:=
ParticleData@"Classes"D
Out[25]=
9Baryon, BBBarMeson, Boson, BottomBaryon, BottomMeson,
CCBarMeson, CharmedBaryon, CharmedMeson, Fermion, GaugeBoson,
Hadron, Lepton, LongLived, Meson, Neutrino, Pentaquark, Quark,
Stable, StrangeBaryon, StrangeCharmedBaryon, StrangeCharmedMeson,
StrangeMeson, UnflavoredBaryon, UnflavoredMeson=
A scatter plot of mass versus spin versus charge shows large voids where there are no
known particles (or where the values are unknown).
In[26]:=
ListPointPlot3DA
CasesASortA9ParticleData@Ò, "Mass"D, ParticleData@Ò, "Spin"D,
ParticleDataAÒ, "Charge"E= & êü ParticleData@"Hadron"DE,
8_?NumberQ, _?NumberQ, _?NumberQ<E, AxesLabel Ø
9"mass", "spin", "charge"=E
Out[26]=
0
5000
10000
mass
0
2
4
6
spin
-2
-1
0
1
2
charge
13.3 Working with Particle Data | 515

DecayModes and FullDecayModes list the ways the particle can decay; FullDecayModes
also lists those predicted by theory but not observed in detectors. The number (or in-
terval) display with the decay mode is the branch ratio.
In[27]:=
FlattenATableAp Ø Ò & êü ParticleDataAp, "DecayModes"E,
8p, 8"DeltaMinus", "DeltaZero", "DeltaPlus", "Lambda"<<E, 1E êê TableForm
Out[27]//TableForm=
DeltaMinus Ø 88Neutron, PiMinus<, 1.00<
DeltaZero Ø 88Neutron, Photon<, Interval@80.0051, 0.008<D<
DeltaPlus Ø 88Proton, Photon<, Interval@80.0051, 0.008<D<
Lambda Ø 88Proton, PiMinus<, 0.639<
Lambda Ø 88Neutron, PiZero<, 0.358<
Lambda Ø 88Neutron, Photon<, 0.00175<
Lambda Ø 88Proton, PiMinus, Photon<, 0.00084<
Lambda Ø 88Proton, Electron, ElectronNeutrinoBar<, 0.000832<
Lambda Ø 88Proton, Muon, MuonNeutrinoBar<, 0.000157<
13.4 Working with Genetic Data and 
Protein Data
Problem
You want to use Mathematica’s pattern matching and computational capabilities to
develop bioinformatics applications. GenomeData and ProteinData provide the raw
materials for this application.
Solution
Get the first 100 nucleobases (or, simply, bases) on the male X chromosome.
In[28]:=
GenomeData@8"ChromosomeX", 81, 100<<D
Out[28]=
CTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTCTGAAAGTGGACCTATCAGCAGGATGTGGGTGGGAGÖ
CAGATTAGAGAATAAAAGCAGACTGC
516 | Chapter 13: Science and Engineering

Get the first 10 proteins known to Mathematica and show number of amino acids in
its sequence.
In[29]:=
9Ò, ProteinDataAÒ, "SequenceLength"E= & êü
Take@ProteinData@D, 10D êê TableForm
Out[29]//TableForm=
A1BG
495
A2M
1474
NAT1
290
NAT2
290
SERPINA3 423
AADAC
399
AAMP
434
AANAT
207
AARS
968
ABAT
500
Find five other chromosomes that have sequences that match the first 50 bases of
chromosome-1 in the human genome. Strands of the chromosome are indicated as 1
or |1. 
In[30]:=
GenomeLookup@GenomeData@8"Chromosome1", 81, 50<<D, 5D
Out[30]=
888Chromosome1, 1<, 81, 50<<, 88Chromosome1, 1<, 87, 56<<,
88Chromosome1, 1<, 813, 62<<, 88Chromosome3, -1<, 8116 621, 116 670<<,
88Chromosome3, -1<, 8116615, 116 664<<<
Discussion
At the time of writing, Mathematica has data on 27,479 proteins and 39,920 genes. 
In[31]:=
9Length@ProteinData@DD, Length@GenomeData@DD=
Out[31]=
827479, 39920<
The following is a list of properties of the proteins. This data is somewhat incom-
plete:  some  of  the  values  are  not  known  or  have  not  been  updated  in  Wolfram’s
database. The good news is that it improves over time, so there is likely more data
when you’re reading this than when I wrote it. Notice how this sample is ordered in
columns, whereas prior recipes showed similar lists in rows. All you need is Trans-
pose and a bit of math to get the desired number of columns. 
In[32]:=
ModuleA8props = ProteinData@"Properties"D<,
WithA9nCols = CeilingALength@propsDë 3E=,
Transpose@Partition@props, nCols, nCols, 1, ""DDEE êê TableForm
13.4 Working with Genetic Data and Protein Data | 517

Out[32]//TableForm=
AdditionalAtomPositions DNACodingSequence
MolecularWeight
AdditionalAtomTypes
DNACodingSequenceLength MoleculePlot
AtomPositions
DomainIDs
Name
AtomRoles
DomainPositions
NCBIAccessions
AtomTypes
Domains
PDBIDList
BiologicalProcesses
Gene
PrimaryPDBID
CellularComponents
GeneID
SecondaryStructureRules
ChainLabels
GyrationRadius
Sequence
ChainSequences
Memberships
SequenceLength
DihedralAngles
MolecularFunctions
StandardName
One property that is sparsely populated is MoleculePlot. At the time of writing, the
only protein beginning with “ATP” that has a MolecularPlot is ATP7BIsoformA.
In[33]:=
ProteinData@"ATP7BIsoformA", "MoleculePlot"D
Out[33]=
GenomeData  likewise  contains  a  wealth  of  information.  Here  I  show  the  properties
available. 
In[34]:=
ModuleA8props = GenomeData@"Properties"D<,
WithA9nCols = CeilingALength@propsDë 3E=,
Transpose@Partition@props, nCols, nCols, 1, ""DDEE êê TableForm
518 | Chapter 13: Science and Engineering

Out[34]//TableForm=
AlternateNames
GBandStainingLevels Orientation
AlternateStandardNames
GenBankIndices
ProteinGenBankIndices
BiologicalProcesses
GeneID
ProteinNames
CellularComponents
GeneOntologyIDs
ProteinNCBIAccessions
Chromosome
GeneType
ProteinStandardNames
CodingSequenceLists
InteractingGenes
PubMedIDs
CodingSequencePositions IntronSequences
SequenceLength
CodingSequences
LocusList
StandardName
ExonSequences
LocusString
TranscriptGenBankIndices
FullSequence
Memberships
TranscriptNCBIAccessions
FullSequencePosition
MIMNumbers
UniProtAccessions
GBandLocusStrings
MolecularFunctions
UnsequencedPositions
GBandScaledPositions
Name
UTRSequences
GBandStainingCodes
NCBIAccessions
In[35]:=
GenomeData@"ACOT9", "ProteinNames"D
Out[35]=
9acyl-Coenzyme A thioesterase 2, mitochondrial isoform a,
acyl-Coenzyme A thioesterase 2, mitochondrial isoform b=
In[36]:=
GenomeData@"ACOT9", "Memberships"D
Out[36]=
9ChromosomeXGenes, Genes, Hydrolase,
Mitochondrion, ProteinBinding, ProteinCoding=
In[37]:=
GenomeData@"ACOT9", "CellularComponents"D
Out[37]=
8Mitochondrion<
In[38]:=
GenomeData@"ACOT9", "MolecularFunctions"D
Out[38]=
9AcetylCoAHydrolaseActivity,
CarboxylesteraseActivity, HydrolaseActivity, ProteinBinding=
13.5 Modeling Predator-Prey Dynamics
Problem
You  want  to  model  a  dynamic  system  consisting  of  populations  of  predators  and
prey to see how population levels evolve over time.
Solution
Consider a population of rabbits (prey) and foxes (predators) with a specific growth
rate for rabbits G and carrying capacity of their environment K. The population dy-
namics can be modeled by a pair of difference equations. See the “Discussion” sec-
tion on page 520 for more insight into the form of these equations and the meaning
of the constants. 
13.5 Modeling Predator-Prey Dynamics | 519

Rt+1 Rt + G Rt 1 -
Rt
K
- 0.0001 Ft Rt
Ft+1 Ft + 0.0001 Ft Rt - 0.02 Ft
NestList presents one possible solution for deriving the dynamics of the population
over time from an initial starting point. 
In[39]:=
RabFox@8r_, f_<, G_: 0.02, K_: 500D :=
8r + HG H1 - HrêKLL rL - 0.0001 r f, f + H0.0001 r fL - H0.02 fL<
initPop = 850, 10<;
ListLinePlotA NestList@RabFox, initPop, 1500D,
PlotRange Ø 880, 500<, 80, 200<<, AxesLabel Ø 8"Rabbits", "Foxes"<E
Out[41]=
0
100
200
300
400
500
Rabbits
0
50
100
150
200
Foxes
This shows the rabbit population doing what rabbits do for many generations as the
fox  population  slowly  increases  due  to  the  increasing  food  supply.  An  inflection
point is reached, and the fox population begins to take off with a resulting collapse
in the rabbit population. Eventually the system reaches equilibrium.
Discussion
The equation for rabbits assumes that rabbits follow the logistic model of exponen-
tial growth limited by the carrying capacity of the environment and then subtracts a
term proportional to the number of rabbits and foxes where the constant 0.0001 re-
flects the efficiency of the predators. The equation for foxes assumes that the fox pop-
ulation is proportional to the ability to catch rabbits (same term from first equation)
minus some natural death rate (here 2 percent of the population). 
NestList provides a very simple solution to this model, but it is not the best choice
if, due to efficiency, you want to create an interactive model using Manipulate. Luckily,
Mathematica 7 has new capabilities for discrete math that provide an alternate solu-
tion path. RecurrenceTable is a new function that will generate the list of solutions of
specified length given a recurrence relation.  
520 | Chapter 13: Science and Engineering

In[42]:=
DynamicModuleA8pop<,
ManipulateA
pop = RecurrenceTable@8
R@t + 1D ã R@tD + G * H1 - HR@tDêkLL*R@tD - 0.0001 R@tD F@tD,
F@t + 1D ã F@tD + 0.0001 R@tD F@tD - 0.02 F@tD,
R@0D ã P@@1DD,
F@0D ã P@@2DD<, 8R, F<, 8t, 0, T<, Method Ø 8Compiled Ø False<D;
ListLinePlotApop, PlotRange Ø 880, 500<, 80, 200<<,
AxesLabel Ø 8"Rabbits", "Foxes"<, PlotLabel ß Floor@Last@popDDE,
88G, 0.02<, 0.00, 0.03<, 88k, 500<, 300, 800<, 88P, 850, 10<<, Locator<,
88T, 1000<, 1, 5000, 1<, SaveDefinitions Ø TrueEE
Out[42]=
G
k
T
0
100
200
300
400
500
Rabbits
0
50
100
150
200
Foxes
8199, 113<
This interactive model allows you to position the locator at the initial population lev-
els for rabbits and foxes and allows you to adjust the growth rate, carrying capacity,
and number of iterations. The plot title displays the end value of rabbits and foxes.
See Also
More elaborate predator-prey models can be found at the Wolfram Demonstration
Project: http://bit.ly/mUVGS and http://bit.ly/21GfLm. 
13.5 Modeling Predator-Prey Dynamics | 521

13.6 Solving Basic Rigid Bodies Problems 
Problem
You want to compute mass, center of mass, and moment of inertia as a prerequisite
to solving dynamical problems involving rigid bodies.
Solution
The basic equation for computing the center of mass given a collection of discrete
point masses is
⁄i =1
n
cmi mi
⁄i =1
n
mi
where  cmi is the center  of  mass  of  each  point  and  mi is its mass. The  numerator  of
this equation is called the first moment. Another name for the center of mass is the
centroid.
In[43]:=
centerMass@particles_D := ModuleA8totalMass, firstMoment<,
8firstMoment, totalMass < =
SumA8massüparticles@@iDD centroidüparticles@@iDD,
massüparticles@@iDD<, 9i, Length@particlesD=E;
firstMomentê totalMassE
In[44]:=
massücar = 1000.;
centroidücar = 8100, 100<;
massüdriver = 86.;
centroidüdriver = 8103, 101< ;
massüfuel = 14.2;
centroidüfuel = 893, 100<;
centerMass@8car, driver, fuel<D
Out[50]=
8100.144, 100.078<
Discussion
The solution is fairly elementary from a physical point of view, but it may look a bit
mysterious from a Mathematica coding point of view. The solution is coded using
Mathematica’s prefix notion. Recall that f@x is prefix notation for f[x]. This nota-
tion is appealing for modeling problems because it is concise and readable (simply re-
place the @ with “of” as you read the code). Notice how I use the same notation with
the problem objects car, driver, and fuel. 
522 | Chapter 13: Science and Engineering

Now suppose this notation does not appeal to you; perhaps you like to model the
physical objects as lists or some other notation like object[{mass,centroid}]. Does this
mean you need to reimplement the centerMass function? Not at all. Simply define the
function’s mass and centroid for your preferred representation, and you are all set.
In[51]:=
massAobject@8m_, ___<DE := m
In[52]:=
centroidAobject@8_, c_, ___<DE := c
In[53]:=
centerMassA9object@81000, 8100, 100<<D,
object@886, 8103, 101<<D, object@814.2, 893, 100<<D=E
Out[53]=
8100.144, 100.078<
Another important property of rigid bodies is the mass moment of inertia about an
axis.  These  values  are  important  when  solving  problems  involving  rotation  of  the
body. The general equation for the mass moment of inertia involves integration over
infinitesimal point masses that make up the body, but in practice problems, equa-
tions for known geometries are typically used. One way to approach this in Mathe-
matica is to use a property called shape and rely on pattern matching to select the
appropriate formula. Each of these functions returns a list in the form {Ixx, Iyy,
Izz}, giving the moment of inertia about the x-, y-, and z-axis, respectively.
In[1]:=
massMomentOfInertia@o_D ê; shapeüo ã "circularCylinder" :=
ModuleA8i1, i2<,
i1 = HHmassüo radiusüo^2Lê4L + IImassüo lengthüo ^2Më 12M;
i2 = HHmassüo radiusüo^2Lê2L ;
8i1, i1, i2< E
massMomentOfInertia@o_D ê; shapeüo ã "circularCylindricalShell" :=
ModuleA8i1, i2<,
i1 = HHmassüo radiusüo^2Lê2L + IImassüo lengthüo ^2Më 12M;
i2 = HHmassüo radiusüo^2LL ;
8i1, i1, i2< E
massMomentOfInertia@o_D ê; shapeüo ã "rectangularCylinder" :=
ModuleA9ixx, iyy, izz=,
ixx = IImassüo Iheightüo + lengthüoM ^2Më 12M ;
iyy = IImassüo Iwidthüo + lengthüoM ^2Më 12M ;
izz = IImassüo Iwidthüo + heightüoM ^2Më 12M ;
9ixx, iyy, izz= E
massMomentOfInertia@o_D ê; shapeüo ã "sphere" := Module@8i<,
i = Hmassüo H2 radiusüo ^2Lê5L ;
8i, i, i< D
massMomentOfInertia@o_D ê; shapeüo ã "sphericalShell" := Module@8i<,
i = Hmassüo H2 radiusüo ^2Lê3L ;
8i, i, i< D
13.6 Solving Basic Rigid Bodies Problems | 523

In[59]:=
shapeücar = "rectangularCylinder";
lengthücar = 4.73;
widthücar = 1.83;
heightücar = 1.25;
In[63]:=
massMomentOfInertia@carD
Out[63]=
82980.03, 3586.13, 790.533<
In[64]:=
shapeücar = "circularCylindricalShell";
radiusücar = 1.83;
In[66]:=
massMomentOfInertia@carD
Out[66]=
83538.86, 3538.86, 3348.9<
13.7 Solving Problems in Kinematics
Problem
You want to demonstrate standard problems in kinematics, like those you typically
find in first-year physics studies. 
Solution
The basic equations of kinematics are as follows.
In[67]:=
acceleration1@deltaT_, v1_, v2_D := Hv2 - v1L ê deltaT
acceleration2@deltaT_, v1_, deltaS_D :=
2 HdeltaS - v1 deltaTL ê HdeltaT^2L
acceleration3@v1_, v2_, deltaS_D := Hv2^2 - v1^2Lê H2 deltaSL
distance@a_, v1_, deltaT_D := Ha deltaT^2 ê2L + v1 deltaT
distance1@a_, v1_, v2_D := Hv2^2 - v1^2L ê H2 aL
distance2@deltaT_, v1_, v2_D := HdeltaTê2L Hv1 + v2L
time1@a_, v1_, v2_D := Hv2 - v1Lê a
time2@a_, v1_, deltaS_D := HSqrt@v1^2 + 2 + 2 a deltaSD - v1L ê a
time3@v1_, v2_, deltaS_D := H 2 deltaSL ê Hv1 + v2L
velocity1@a_, v2_, deltaT_D := v2 - a deltaT
velocity2@a_, deltaS_, deltaT_D := HdeltaSêdeltaTL - H a deltaTê2L
velocity3@a_, v2_, deltaS_D := Sqrt@v2^2 - 2 a deltaSD
Given these equations, you can solve a variety of problems. For example, how far
will a bullet drop if shot horizontally from a rifle at a target 500 m away if the initial
velocity is 800 m/s? Ignore drag, wind, and other factors.
First, compute how long the bullet remains in flight before hitting the target by tak-
ing the initial and final velocity to be the same.
524 | Chapter 13: Science and Engineering

In[79]:=
timeTraveled = time3@800, 800, 500D êê N
Out[79]=
0.625
Given the acceleration due to gravity is 9.8 m/s2, compute the distance dropped by
setting the initial vertical velocity component to zero.
In[80]:=
distanceDropped = distance@9.8, 0, timeTraveledD
Out[80]=
1.91406
The bullet drops almost 2 meters. 
Discussion
The  solution  works  out  a  simple  problem  by  working  first  in  the  x  direction  and
then plugging the results into an equation in the y direction. In more complex prob-
lems, it is often necessary to use vectors to capture the velocity components in the x,
y, and z directions. Consider a game or simulation involving a movable cannon and
a movable target of varying size. 
Imagine the cannon is fixed to the side of a fortress such that the vertical height (z di-
rection in this example) is variable but the x and y position is fixed. The length, angle
of elevation (alpha), left-right angle (gamma), and muzzle velocities are also variable.
You require a function that gives the locus of points traversed by the shell given the
cannon settings and the time of flight. Here we use Select to filter the points above
ground level (positive in the z direction). The function returns a list of values of the
form {{x1,y1,z1,t1}, ..., {xn,yn,zn,tn}}, where each entry is the position of the
shell at the specified time. Chop is used only to replace numbers close to zero by zero.
Note that in each dimension, the basic kinematic equations are in play, but since the
inputs are in terms of angles, some basic trigonometry is needed to get the separate
x, y, and z components. Velocity is constant in the x-y plane (we are still ignoring
drag), and the z-axis uses the initial velocity component and the fall of the shell due
to gravity.
In[81]:=
displacementAorigin_List, velocity_, alpha_, gamma_, tEnd_E :=
WithA9g = 9.8=,
SelectAIf AtEnd § 0, 8<,
ChopATableA9
origin@@1DD + velocity *t * Cos@alpha * Piê2D,
origin@@2DD + velocity * t * CosAgamma * PiE,
origin@@3DD + velocity * t * Sin@alpha * Piê2D - 0.5 g t^2,
t=,
8t, 0, tEnd, 0.25<EEE, Ò@@3DD ¥ 0 &E
E
13.7 Solving Problems in Kinematics | 525

You can also create a function that computes the instantaneous velocity components
at a specified time.
In[82]:=
velocityAvelocity_, alpha_, gamma_, t_E :=
WithA9g = 9.8=,
ChopA
IfAt > 0,
9velocity * Cos@alpha * Piê2D,
velocity * CosAgamma * PiE,
velocity Sin@alpha * Piê2D - g t=, 80., 0., 0.<E
E
E
Since the plan is to create a simulation, you need a function that figures out when
the shell intersects with the target. For simplicity, assume the shape of the target is a box.
In[83]:=
intersect@point_List, corner1_List, corner2_ListD :=
point@@1DD ¥ corner1@@1DD && point@@1DD § corner2@@1DD &&
point@@2DD ¥ corner1@@2DD && point@@2DD § corner2@@2DD &&
point@@3DD ¥ corner1@@3DD && point@@3DD § corner2@@3DD
H*The shell hit the target if any point in the locus
of points intersects. Apply Or to list of Booleans.*L
intersection@points_List, corner1_List, corner2_ListD :=
Or üü Hintersect@Ò, corner1, corner2D & êü pointsL
You can set the simulation up inside of a Manipulate so that you can play around
with all the variables. 
526 | Chapter 13: Science and Engineering

In[85]:=
WithA9width = 200, height = 200, length = 200, limit = 10=,
ManipulateA
DynamicModuleA9b, Lx, Ly, Lz, cannonAlpha,
cannonGamma, targetX, targetY, path, text, color, Vx, Vy, Vz=,
8cannonGamma, cannonAlpha< = cannonOrient;
9targetX, targetY= = targetPos;
b = cannonL * Cos@H1 - cannonAlphaL * Piê2D;
Lx = cannonL Cos@cannonAlpha * Piê2D;
Ly = lengthë 2 + cannonL * Cos@cannonGamma * PiD;
Lz = cannonL Sin@cannonAlpha * Piê2D;
path = displacementA9Lx, Ly, cannonZb + Lz=,
cannonVM, cannonAlpha, cannonGamma, timeE;
tLast = IfALength@pathD > 1, Last@pathD@@4DD, 0E;
9Vx, Vy, Vz= = velocity@cannonVM, cannonAlpha, cannonGamma, tLastD;
color =
IfAintersectionApath, 9targetX, targetY, targetZ=, 9targetX + targetL,
targetY + targetW, targetZ + targetH=E, Red, GreenE;
ColumnA9
GridA99"Vx", "Vy", "Vz"=, 9Vx, Vy, Vz==E,
Graphics3DA99Thickness@0.02D,
LineA990, lengthë 2, cannonZb=, 9Lx, Ly, Lz + cannonZb==E=, 9color,
CuboidA9targetX, targetY, targetZ=, 9targetX + targetL, targetY +
targetW, targetZ + targetH=E=, Point@Most@ÒDD & êü path=,
PlotRange Ø 980, width<, 90, length=, 90, height==,
ImageSize Ø 300E=E
E,
88cannonVM, 50<, 10, 100<, 88cannonOrient, 80.5, 0.5<<, 80, 0<, 81, 1<<,
9cannonL, 20, lengthë 2=, 9cannonZb, 0, heightë 2=,
99targetPos, 8100, 100<=, 85 * limit, 0<,
9width - limit, length - limit==,
9targetZ, 0, height - limit=, 9targetL, limit, lengthë 2=,
9targetW, limit, widthê2=, 9targetH, limit, heightë 2=,
8time, 0, 25<,
9time, 0, 25, ControlType Ø Trigger=, SaveDefinitions Ø TrueEE
13.7 Solving Problems in Kinematics | 527

Out[85]=
canonVM
canonOrient
canonL
canonZb
targetPos
targetZ
targetL
targetW
targetH
time
time
Vx Vy Vz
0
0
0
The initial output of the Manipulate is shown in Out[85] above. The path of the bul-
let is displayed up until the point in time specified by the time control, so the box
turns red after it is hit by a shell. The instantaneous velocity  of  the  shell  is  dis-
played for the current value of time. The Vz will be negative when the shell is falling.
Figure 13-1 shows two frames from the Manipulate, at a time before impact and a
time after.
See Also
David M. Bourg’s Physics for Game Developers (O’Reilly) has an example of the can-
non problem where wind drag is introduced. Keep in mind that the author uses the
y-axis as the vertical whereas the code in this recipe uses the z-axis.
Mathematical Methods Using Mathematica by Sadri Hassani (Springer) has solutions
to  similar  problems  using  differential  equations  which  consider  drag,  curvature  of
the earth, and nonconstant acceleration at large distances from the earth’s surface
(see Chapter 6). 
528 | Chapter 13: Science and Engineering

Figure 13-1. Two frames from the cannon simulation
13.7 Solving Problems in Kinematics | 529

13.8 Computing Normal Modes for Coupled 
Mass Problems
Problem
You want to compute the normal modes for a system of identical masses connected
by identical springs. Normal modes are natural or resonant frequencies of the entire
system.  The  system  this  recipe  considers  consists  of  n>1  masses  connected  by  n-1
springs on a frictionless surface. Figure 13-2 shows an example for n=3. 
Figure 13-2. Coupled masses
Solution
Here I state, without proof (refer to “See Also” section on page 532), that these sys-
tems take the form of n simultaneous linear equations whose matrix representation
is tridiagonal. That is a matrix with nonzero entries along the main diagonal and adja-
cent minor diagonals and zero entries in all other elements. The corner entries of the
main diagonal are special since they represent masses that are free on one side and
take the form k - m*w^2, where k is the spring constant, m is the mass, and w is the an-
gular frequency. The off corner entries represent the masses with springs on both
sides and take the form 2*k - m*w^2. The minor diagonals are all -k. Here I solve the
three mass problems, and in the discussion, I show how to create a general solver for
the n mass case.
In[86]:=
matrix =
k - 2 w^2
-k
0
-k
2 k - 2 w^2
-k
0
-k
k - 2 w^2
Out[86]=
99k - 2 w2, -k, 0=, 9-k, 2 k - 2 w2, -k=, 90, -k, k - 2 w2==
Nontrivial solutions to this system leave the matrix as noninvertible; hence, the deter-
minant is zero. Use Solve to find the frequencies in terms of k.
530 | Chapter 13: Science and Engineering

In[87]:=
sol = Solve@Det@matrixD ã 0, wD
Out[87]=
;8w Ø 0<, 8w Ø 0<, ;w Ø -
3
2
k ?,
;w Ø
3
2
k ?, ;w Ø -
k
2
?, ;w Ø
k
2
??
You don’t care about the solutions with negative or zero frequencies, so you can fil-
ter these out to obtain two physically interesting resonant frequencies.
In[88]:=
sol = Cases@sol, Except@8_ Ø 0<
8_ Ø -_<DD
Out[88]=
;;w Ø
3
2
k ?, ;w Ø
k
2
??
Given the frequencies, you can solve the system to get the amplitudes. The first solu-
tion gives a1 == a3 and a2 == -2a1, with the alternative of k == 0 being physically
uninteresting. This solution has the outer masses moving in unison in the same direc-
tion  while  the  inner  mass  compensates  by  moving  in  the  opposite  direction  with
twice the amplitude.
In[89]:=
Reduce@Dot@Hmatrix ê. sol@@1DDL , 8a1, a2, a3<D ã 0, 8a1, a2, a3<D
Out[89]=
Ha2 ã -2 a1 && a3 ã a1L »» k ã 0
The second solution gives a2 == 0 and a3 == -a1 with the alternative of k == 0 being
physically uninteresting. This is a solution with the center mass at rest and the outer
masses moving toward and then away from the center. 
In[90]:=
Reduce@Dot@Hmatrix ê. sol@@2DDL , 8a1, a2, a3<D ã 0, 8a1, a2, a3<D
Out[90]=
Ha2 ã 0 && a3 ã -a1L »» k ã 0
Discussion
To solve the general n-mass system, we need a way to synthesize a tridiagonal ma-
trix of the proper form. For this, SparseArray and Band are just what the doctor or-
dered. When using sparse matrix, rules that come earlier override rules that come
later. This works to your favor because it allows the case where n == 2 to be
handled without any conditional logic stemming from the fact that there are no
2*k - m*w^2 terms when n == 2.
13.8 Computing Normal Modes for Coupled Mass Problems | 531

In[91]:=
Clear@massMatrixD;
massMatrix@n_ ê; n > 1D := SparseArray@8
81, 1< -> k - m w^2,
8n, n< -> k - m w^2,
Band@82, 1<D Ø -k,
Band@81, 2<D Ø -k,
Band@81, 1<D Ø 2 k - m w^2<, nD
In[93]:=
massMatrix@2D êê MatrixForm
Out[93]//MatrixForm=
k - m w2
-k
-k
k - m w2
In[94]:=
massMatrix@5D êê MatrixForm
Out[94]//MatrixForm=
k - m w2
-k
0
0
0
-k
2 k - m w2
-k
0
0
0
-k
2 k - m w2
-k
0
0
0
-k
2 k - m w2
-k
0
0
0
-k
k - m w2
For the general solution, you want to use NSolve with specific values of m and k be-
cause roots of polynomials with degree greater than five are likely to give Solve trou-
ble. Here I solve a 10-mass system with k == 1 and m == 1. Chop is used to remove
residual imaginary values and Cases filters out zero and negative solutions because
they are physically uninteresting.
In[95]:=
Cases@Chop@NSolve@Det@massMatrix@10DD ã 0 ê. 8k Ø 1, m Ø 1<, wDD,
8_ Ø a_ ê; a > 0<D
Out[95]=
88w Ø 0.312869<, 8w Ø 0.618034<, 8w Ø 0.907981<, 8w Ø 1.17557<,
8w Ø 1.41421<, 8w Ø 1.61803<, 8w Ø 1.78201<, 8w Ø 1.90211<, 8w Ø 1.97538<<
See Also
You  can  find  derivations  of  the  systems  solved  in  this  recipe  in  many  advanced
physics and linear algebra books. In particular, Mathematical Methods Using Mathe-
matica by Sadri Hassani provides a nice mix of practical physics and Mathematica
techniques, although the most recent edition is written for versions of Mathematica
prior to 6 and therefore does not always indicate the best technique to use for cur-
rent versions. 
532 | Chapter 13: Science and Engineering

13.9 Modeling a Vibrating String
Problem
You want to model the dynamics of a vibrating string after it is released from a partic-
ular deformation.
Solution
This  solution  is  a  particular  solution  to  the  one-dimensional  wave  equation  D[u[x,t],
{x,2}] == c^2 D[u[x,t],{t,2}] where u[x,t] gives the position of the string at point
x  and  time  t.  The  general  solution  to  the  wave  equation  can  be  obtained  using
DSolve.
In[96]:=
DSolve@D@u@x, tD, 8x, 2<D == c^2 D@u@x, tD, 8t, 2<D, u@t, xD, 8t, x<D
Out[96]=
;;u@x, tD Ø C@1DCt -
c2 xG + C@2DCt +
c2 xG??
The general solution is not very helpful because it is specified in terms of two
unknown  functions,  C[1]  and  C[2].  In  theory,  you  could  specify  boundary  condi-
tions and initial conditions, but DSolve is very limited in its ability to find solutions
to  partial  differential  equations.  This  problem  is  better  handled  numerically  with
NDSolve.
First we need a specification for the shape of the string at t = 0. For simplicity, I’ll
use the Sin function that will give a width of L units. Here I use Plot to show the ini-
tial defection of the string. 
In[97]:=
string@x_, L_D := 0.35 SinB
p x
L
F;
In[98]:=
WithA8L = 5<, PlotAstring@ x, LD, 8x, 0, L<, AspectRatio Ø 1êLEE
Out[98]=
1
2
3
4
5
0.05
0.10
0.15
0.20
0.25
0.30
0.35
To use NDSolve to model the vibrating string, you must provide initial and boundary
conditions. The initial condition states that u[0,x] = string[x]. In other words, at
the start, the string has the position depicted previously. You must also specify the
initial velocity of the string, which is the first derivative with respect to time. The ob-
vious choice for initial velocity is zero. Using input form, this would be entered as
Derivative[1,  0][u][0,  x]  ==  0. This operator notation was explained in Recipe
11.4. The two boundary conditions specify that the ends of the string are anchored
at position 0 and L, u[t, 0] == 0, and u[t, L] == 0.
13.9 Modeling a Vibrating String | 533

In[99]:=
WithA8L = 5, T = 10, waveEq = D@u@t, xD, t, tD == D@u@t, xD, x, xD<,
sol = NDSolveA
9waveEq, u@0, xD == string@x, LD, Derivative@1, 0D@uD@0, xD == 0,
u@t, 0D == 0, u@t, LD == 0=, u, 8t, 0, 10<, 8x, 0, L<E;
AnimateAPlotAEvaluate@u@t, xD ê. sol@@1DDD, 8x, 0, L<,
AspectRatio -> 1êL, PlotRange Ø 880, L<, 8-0.4, 0.4<<E,
8t, 0, T, 0.5<, SaveDefinitions Ø TrueEE
Out[99]=
t
1
2
3
4
5
-0.4
-0.2
0.0
0.2
0.4
Discussion
Although DSolve can deal with some partial differential equations (PDEs), it is lim-
ited in its ability to derive specific solutions given initial and boundary conditions.
Therefore, it is better to use NDSolve on PDEs, as I’ve done in the solution. However,
it is not difficult to pose problems that NDSolve will have a hard time with and ulti-
mately fail to solve. Consider trying to solve the wave equation with an initial posi-
tion that contains a discontinuity.
In[100]:=
string2@x_, L_D := 0.7 Abs@ x êL - Round@xêLDD
In[101]:=
WithA8L = 5<, PlotAstring2@ x, LD, 8x, 0, L<, AspectRatio Ø 1êLEE
Out[101]=
1
2
3
4
5
0.05
0.10
0.15
0.20
0.25
0.30
0.35
If you try to use string2 in the solution shown in In[99] above, it will likely run for a
very long time, consuming memory and finally failing. However, this situation is not
entirely hopeless. One technique is to produce an approximation to string2 using Fourier
series. Using Fourier series, I obtained the following Sin expansion, called sinString2:
534 | Chapter 13: Science and Engineering

In[102]:=
sinString2@x_D = 0.285325252629769` Sin@HPi*xLê5D -
0.033193742967516204` Sin@H3*Pi*xLê5D +
0.013117204588138661` Sin@p xD - 0.007723288156504195`
Sin@H7*Pi*xLê5D + 0.005695145921372713` Sin@H9*Pi*xLê5D -
0.004945365736699312` Sin@H11*Pi*xLê5D;
Below  I  plot  both  functions  to  demonstrate  how  closely  sinString2  approximates
string2 while smoothing out the discontinuity at the apex.
In[103]:=
WithA8L = 5<, PlotA9string2@ x, LD, sinString2@xD=,
8x, 0, L<, AspectRatio Ø 1êL, PlotStyle Ø 8Dashed, Thin<EE
Out[103]=
1
2
3
4
5
0.05
0.10
0.15
0.20
0.25
0.30
0.35
In[104]:=
In[105]:=
WithA8L = 5, T = 10, waveEq = D@u@t, xD, t, tD == D@u@t, xD, x, xD<,
sol2 = NDSolveA
9waveEq, u@0, xD == sinString2@xD, Derivative@1, 0D@uD@0, xD == 0,
u@t, 0D == 0, u@t, LD == 0=, u, 8t, 0, 10<, 8x, 0, L<E;
AnimateAPlotAEvaluate@u@t, xD ê. sol2@@1DDD, 8x, 0, L<,
AspectRatio -> 1êL, PlotRange Ø 880, L<, 8-0.40, 0.40<<E,
8t, 0, T, 0.5<, SaveDefinitions Ø TrueEE
Out[105]=
t
1
2
3
4
5
-0.4
-0.2
0.0
0.2
0.4
There is an exact solution to the triangular wave, although it isn’t derived here (refer
to the “See Also” section on page 536). It is given by this infinite sum, which Mathe-
matica can solve using a special function LerchPhi. This solution is too complex to
use in an animation, but you can use it to verify that the approximate solution is
quite good.
13.9 Modeling a Vibrating String | 535

In[106]:=
triangular@t_, x_D = WithA8L = 5<, FullSimplifyA
HH0.35*8LêPi^2L*SumAH-1L^Hi + 1L*Sin@H2*i - 1L*Pi*HxêLLD*
HCos@H2*i - 1L*Pi*HtêLLDêH2*i - 1L^2L, 9i, 1, Infinity=EEE
Out[106]=
‰
-
1
5 Â p H5 t+xL
H0. - 0.0177312 ÂL ‰
2
5 Â p H2 t+xL LerchPhiC-‰
-
2
5 Â p Ht-xL, 2,
1
2
G +
H0. + 0.0177312 ÂL ‰
6 Â p t
5
LerchPhiC-‰
2
5 Â p Ht-xL, 2,
1
2
G +
H0. + 0.0177312 ÂL ‰
4 Â p t
5
LerchPhiC-‰
-
2
5 Â p Ht+xL, 2,
1
2
G -
H0. + 0.0177312 ÂL ‰
2
5 Â p H3 t+xL LerchPhiC-‰
2
5 Â p Ht+xL, 2,
1
2
G
Plotting a few snapshots of the exact solution over time tells us that the approximate
solution is more than adequate and, in some sense, superior because it is far less
computationally intense.
In[107]:=
GridAWithA8L = 5, T = 5<,
PartitionATableAPlotAtriangular@t, xD , 8x, 0, L<,
AspectRatio -> 1êL, Ticks Ø None,
PlotRange Ø 880, L<, 8-0.40, 0.40<<E, 8t, 0, T<E, 3EEE
Out[107]=
See Also
There are many ways to approach the solution to the wave equation. When this prob-
lem is solved by hand, separation of variables is often employed. See Advanced Engi-
neering Mathematics by Erwin Kreyszig (John Wiley) for a step-by-step exam-
ple.  Warning:  this  book  is  not  a  Mathematica  reference,  but  the  problems  are
worked out in enough detail that you can easily see your way to creating your own
Mathematica-based solutions.
536 | Chapter 13: Science and Engineering

13.10 Modeling Electrical Circuits
Problem
You  want  to  understand  how  electrical  circuits  consisting  of  resistors,  capacitors,
and inductors behave. 
Solution
The differential equation governing an RLC circuit is L I'' + R I' + I/C = E(t),
where I is current, L is inductance, R is resistance, C is capacitance, and E(t) is the
electromotive force (commonly known as voltage). Modeling the system means un-
derstanding how the current varies as you drive the system with a particular timing
varying voltage. Let’s consider a common sinusoidal voltage and solve the system
assuming that the charge and current are zero at t=0. Setting the problem up with
the context of a With allows you to solve the problem for different values of induc-
tance, capacitance, resistance, frequency, and voltage.
In[108]:=
sol = WithB8L = 0.01, R = 100, C = 0.001, f = 60, V = 1<,
DSolveB:L Iout''@tD + R Iout'@tD +
1
C
Iout@tD ã V 2 Pi f Cos@2 Pi f tD,
Iout@0D ã 0, Iout'@0D ã 0>, Iout@tD, tFF
Out[108]=
99Iout@tD Ø
‰-10 000. t I0.000377588 ‰10.01 t - 0.000265869 ‰9989.99 t - H0.000111719 + 0. ÂL
‰10 000. t Cos@376.991 tD + H0.00999875 + 0. ÂL ‰10000. t Sin@376.991 tDM==
In[109]:=
fIout@t_D = ChopAFullSimplify@Iout@tD ê. sol@@1DDDE
Out[109]=
0.000377588 ‰-9989.99 t - 0.000265869 ‰-10.01 t -
0.000111719 Cos@376.991 tD + 0.00999875 Sin@376.991 tD
By plotting the input voltage and output current, you can see they have the same ba-
sic shape and frequency except for a phase shift.
In[110]:=
With@8f = 60, V = 1<,
GraphicsRow@8Plot@8V 2 Pi f Cos@2 Pi f tD<, 8t, 0, 0.1<, PlotLabel Ø VinD,
Plot@8fIout@tD<, 8t, 0, 0.1<, PlotLabel Ø IoutD<D
D
Out[110]=
0.02 0.04 0.06 0.08 0.10
-300
-200
-100
100
200
300
Vin
0.02 0.04 0.06 0.08 0.10
-0.010
-0.005
0.005
0.010
Iout
13.10 Modeling Electrical Circuits | 537

Discussion
A more interesting example uses a nonsinusoidal wave, such as a triangular wave.
Conveniently, Mathematica 7 has a function TriangleWave[t] that suits our purpose. 
In[111]:=
Et@V_, t_D = V TriangleWave@tD;
In[112]:=
PlotAEt@1, tD, 8t, 1, 3<, ImageSize Ø SmallE
Out[112]=
1.5
2.0
2.5
3.0
-1.0
-0.5
0.5
1.0
However,  the  discontinuities  in  this  waveform  throw  DSolve  for  a  loop.  To  work
around this, represent the triangular wave by its Fourier series. This will give a very
close approximation without the discontinuities at the extremes. This will allow you
to use DSolve. 
In[113]:=
Et2@V_, t_D =
FourierSinSeries@Et@V, tD, t, 10, FourierParameters Ø 81, 2 Pi<D
Out[113]=
8 V Sin@2 p tD
p2
-
8 V Sin@6 p tD
9 p2
+
8 V Sin@10 p tD
25 p2
-
8 V Sin@14 p tD
49 p2
+
8 V Sin@18 p tD
81 p2
In[114]:=
PlotAEt2@1, tD, 8t, 1, 3<, ImageSize Ø SmallE
Out[114]=
1.5
2.0
2.5
3.0
-1.0
-0.5
0.5
1.0
In[115]:=
sol2 = With@8L = 0.01, R = 100, C = 0.001, V = 1<,
DSolve@8L*Derivative@2D@IiD@tD +
R*Derivative@1D@IiD@tD + H1êCL*Ii@tD ==
Et2@V, tD, Ii@0D == 0, Derivative@1D@IiD@0D == 0<, Ii@tD, tDD;
In[116]:=
fIout2@t_D = Ii@tD ê. sol2@@1DD;
538 | Chapter 13: Science and Engineering

Notice how the RLC circuit responds to the triangular wave input by smoothing the
current flow to an approximately sinusoidal form. As an exercise, you can try this
same example using SquareWave, SawtoothWave, or other functions of your own design. 
In[117]:=
With@8f = 60, V = 1<,
GraphicsRow@8Plot@8Et2@1, tD<, 8t, 0, 3<, PlotLabel Ø VinD,
Plot@8fIout2@tD<, 8t, 0, 3<, PlotLabel Ø IoutD<D
D
Out[117]=
0.5 1.0 1.5 2.0 2.5 3.0
-1.0
-0.5
0.5
1.0
Vin
0.5 1.0 1.5 2.0 2.5 3.0
-0.0006
-0.0004
-0.0002
0.0002
0.0004
0.0006
Iout
13.11 Modeling Truss Structures Using 
the Finite Element Method 
Problem
You want to build a model based on the finite element method (FEM). You want to
organize  the  model  in  a  manner  that  allows  you  to  obtain  the  solution  as  well  as
other intermediate results and structural diagrams.
Solution
The FEM has a wide range of engineering applications. In this recipe, I will limit the
discussion to structures composed of linear elements known as trusses. See the fig-
ure shown in the “Discussion” section on page 545. Here my focus will be on the or-
ganization of the solution within Mathematica rather than on the underlying theory.
Therefore, all results will be present without derivation of the underlying mathemat-
ics. Please refer to the references in the “See Also” section on page 547. 
To begin, you will need a means to represent the elements. I use a structure called
linearElement that specifies two endpoints called nodes ({{x1, y1}, {x2, y2}}), an
area, and a measure of stiffness called Young’s Modulus (YM). 
linearElementA99x1, y1=, 9x2, y2==, area, YME
In addition, you need a means for specifying the x and y components of the force at
each node. 
forceA9x, y=, fx, fyE
13.11 Modeling Truss Structures Using the Finite Element Method | 539

Furthermore, at each node there is a computed displacement in the x and y direc-
tion. The FEM literature uses the variable u for x displacements and v for y displace-
ments Typically, each node is sequentially numbered, so you would have u1, v1,
u2, v2, and so on. I will not use a sequential numbering here, because each node
is uniquely identified by its coordinates, and given Mathematica’s liberal repre-
sentation of variables, it is much more convenient to specify nodal displacements us-
ing coordinates. 
uAx1, y1E
H*The displacement in the x direction at node 9x1,y1=*L
vAx1, y1E H*The displacement in the y direction at node 9x1,y1=*L
With  these  conventions  established,  I  proceed  by  defining  a  series  of  helper  func-
tions that will be needed later. I provide a brief description of each function but, for
brevity, defer more detail to the “Discussion” section on page 543.
Each element in the model is governed by a system of linear equations. The system
is naturally represented by a symmetric matrix. The symmetry takes the form
{{A,-A},{-A,A}} where A is a block matrix. 
In[118]:=
linearElementMatrixA
linearElementA99x1_, y1_=, 9x2_, y2_==, area_, YM_EE :=
ModuleA8L, BlockMatrix, LocalMatrix, A, l, m<,
L = EuclideanDistanceA9x1, y1=, 9x2, y2=E;
BlockMatrix = 88A, -A<, 8-A, A<<;
LocalMatrix =
ArrayFlatten@ BlockMatrix ê. 8A Ø 88l l, l m<, 8l m, m m<<<D;
I LocalMatrix ê. 9l Ø Hx2 - x1LêL , m Ø Iy2 - y1M ë L=M
HH YM areaLêLL
E
A location vector provides a means for locating the position of the local element ma-
trices  computed  by  linearElementMatrix  within  a  larger  global  matrix  that  repre-
sents the system over all elements.
In[119]:=
assemblyLocationVector@linearElement@8n1_, n2_<, __D, allnodes_D :=
Flatten@Position@allnodes, ÒD & êü 8u üü n1, v üü n1, u üü n2, v üü n2<D
This helper maps a node of the form {{x1,y1},{x2,y2}} to the corresponding force
components {{fx1,fy1},{{fx2,fy2}}}. It does this by searching for the first match of
the node within the list of forces and transforming it to the desired form.
In[120]:=
getExternalForces@8forces__force<, node_D :=
Cases@8forces<, force@node, fu_, fv_D :> 8fu, fv<, 1, 1D
540 | Chapter 13: Science and Engineering

This helper extracts the unique set of nodes from the elements and places them in a
canonical order, as defined by Union. This ordering is essential to the construction of
a consistent system of equations. See the “Discussion” section on page 543 for details.
In[121]:=
getNodes@8elements__linearElement<D :=
Union@8elements< ê. linearElement@8n1_, n2_<, __D :> Sequence@n1, n2DD
This helper is used to construct a replacement rule for forces.
In[122]:=
makeForceRuleAforceAp_, fx_, fy_EE := force@p, _, _D Ø forceAp, fx, fyE
Construct a global vector of all forces using a set of nodes in canonical order. 
In[123]:=
getForceVector@8forces__force<, nodes_D :=
FlattenAgetExternalForces@8forces<, ÒD & êü nodesE
Assemble the global matrix that defines the system of equations over all elements us-
ing the local matrices for individual elements and the location vectors that define the
position of the local matrices with the global matrix. Note that the global matrix is
obtained  by  summing  the  local  matrices  into  the  appropriate  positions  within  the
global matrix. In other words, think of each member of locationVectors as specify-
ing a submatrix within the global matrix for which the corresponding member of
localMatrices is added. 
In[124]:=
assembleGlobalMatrix@localMatricies_,
locationVectors_, numElements_, dimension_D :=
ModuleA9g=,
g = Table@0, 8dimension<, 8dimension<D;
DoAg@@ locationVectors@@iDD, locationVectors@@iDD DD +=
localMatricies@@iDD, 8i, 1, numElements<E;
g
E
A model consists of a collection of connected elements, the external forces applied
to the structure at one or more nodes, and the boundary conditions that typically
manifest as points where a node is anchored, rendered  immobile  in  the  x,  y,  or
both directions. Here I organize a solution in the spirit of LinearModelFit covered in
Chapter 12. That is, I construct an object called a TrussModel, the function of which
is to organize the underlying data and then use that  object  as  the  target  for  re-
quests for certain properties relevant to the FEM. As of Mathematica 6 and particularly
in Mathematica 7, this object-based  methodology  has  emerged  as  a  design  pat-
tern for organizing solutions that involve large quantities of data or collections of re-
lated functionality.
13.11 Modeling Truss Structures Using the Finite Element Method | 541

To proceed in this manner, you need a function for creating the TrussModel and a
Format for displaying it. The Format is syntactic sugar that hides the details of the
TrussModel, which could be quite large.
In[125]:=
createTrussModelA8elements__linearElement<,
8forces___force<, boundaryNodes_E :=
ModuleA9localMatrices, nodes, nodalVar, forceVec, locationVectors,
degreesOfFreedom, globalMatrix, allForces, forceRules=,
nodes = getNodes@8elements<D;
nodalVar = Flatten@8u üü Ò, v üü Ò< & êü nodesD;
localMatrices = linearElementMatrix êü 8elements<;
locationVectors = assemblyLocationVector@Ò, nodalVarD & êü 8elements<;
globalMatrix = assembleGlobalMatrixAlocalMatrices,
locationVectors, Length@8elements<D, Length@nodalVarDE;
degreesOfFreedom = ComplementARangeALength@nodalVarDE,
FlattenAPosition@nodalVar, ÒD & êü boundaryNodesEE;
allForces = force@Ò, 0, 0D & êü nodes;
forceRules = makeForceRule êü 8forces< ;
allForces = allForces ê. forceRules;
forceVec = getForceVector@allForces, nodesD;
TrussModelA8elements<, boundaryNodes, localMatrices,
globalMatrix, nodalVar, forceVec, degreesOfFreedom, forcesEE
FormatATrussModelAelements_, boundaryNodes_, __EE :=
ToStringATrussModelA9Length@elementsD=, 9LengthAboundaryNodesE=EE
The goal of a FEM analysis is to determine the behavior of the structure from the be-
havior of the elements. For a system of trusses, solve for the displacements at the
joints,  the  axial  forces,  and  axial  stresses.  Following  the  proposed  methodology,
these will be accessed as properties of the TrussModel. 
The  displacements  property  is  implemented  as  a  functional  pattern  associated
with the TrussModel. This notation may look somewhat unusual but is quite natural
from the standpoint of Mathematica’s design. It simply states that when you see a
pattern consisting of a TrussModel and a literal argument, "displacements", replace it
with the results of computing the displacements using data from the TrussModel.
In[127]:=
TrussModelA_, _, _, globalMatrix_, nodalVars_,
forceVec_, degreesOfFreedom_, ___E@"displacements"D :=
FlattenASolveADotAglobalMatrixAAdegreesOfFreedom, degreesOfFreedomEE,
nodalVarsAAdegreesOfFreedomEEE ã
forceVecAAdegreesOfFreedomEE, nodalVarsAAdegreesOfFreedomEEEE
542 | Chapter 13: Science and Engineering

As  a  matter  of  convenience,  you  can  make  a  property  the  default  property  of  the
model  by  associating  it  with  the  invocation  of  the  model  with  no  arguments.  Of
course, thus far I have defined only one property, displacements, but it was my in-
tent to make this the default. In the discussion I derive other properties of this model.
In[128]:=
TrussModel@model__D@D := TrussModel@modelD@"displacements"D
All this tedious preparation leads us to a solution that is very easy to use. Here is the
TrussModel, depicted in Out[136] on page 545. The example data is borrowed from
a problem presented in Bhatti’s book (refer to the “See Also” section on page 547).
In[129]:=
tm = createTrussModel@
8linearElement@880, 0<, 81500, 3500<<, 4000., 200*10^3D,
linearElement@881500, 3500<, 85000, 5000<<, 4000., 200*10^3D,
linearElement@880, 0<, 80, 5000<<, 3000., 200*10^3D,
linearElement@880, 5000<, 85000, 5000<<, 3000., 200*10^3D,
linearElement@880, 5000<, 81500, 3500<<, 2000., 70*10^3D<,
8force@81500, 3500<, 0, -150000D<,
8u@0, 0D, v@0, 0D, u@5000, 5000D, v@5000, 5000D<D
Out[129]=
TrussModel@85<, 84<D
Now you can compute the nodal displacements at the nodes that are unsupported.
In[130]:=
tm@"displacements"D
Out[130]=
8u@0, 5000D Ø 0.264704, v@0, 5000D Ø -0.264704,
u@1500, 3500D Ø 0.538954, v@1500, 3500D Ø -0.953061<
Discussion
To complete the TrussModel, we need to define more properties. It is nice to have a
visual aid to help diagnose problems in the setup of the model. A "diagram" property
generates graphics. As before, I need to develop some helper functions to take care
of certain tails. Each helper function has a placeholder for options (opts___), but to
keep the implementation from getting any more complicated, I do not implement
any options. You could add options to control the level of detail, for example, to in-
clude  or  suppress  displacement  arrows  and  labels.  Other  options  might  be  pass-
through options to Graphics.
The diagram uses a convention where supported nodes are filled-in points, whereas
unsupported nodes are hollow circles with associated displacement arrows. It is pos-
sible that a node can be stationary in one direction but not the other. For example, a
roller would be free to move in the x direction but not the y. Professional FEM soft-
ware handles a much wider variety of boundary conditions, and standard icons are
used in the industry to depict these. The goal here is simplicity over sophistication.
13.11 Modeling Truss Structures Using the Finite Element Method | 543

The  function  trussGraphicsNodes  does  most  of  the  work  of  mapping  the  various
types of nodes onto the specific graphics element. The complexity of the code is man-
aged  by  judicious  use  of  patterns  and  replacement  rules.  Some  of  the  scaling  and
text placement was largely determined by trial and error, so you may need to tweak
these settings for your own application or add additional code to help generalize
the solution. 
In[131]:=
trussGraphicsElementA
linearElementA99x1_, y1_=, 9x2_, y2_==, ___E, opts___E :=
9Opacity@0.6D, LineA99x1, y1=, 9x2, y2==E=
trussGraphicsNodesAnodalVars_, boundaryNodes_, arrowLen_, opts___E :=
ModuleA8freeNodes, arrows, circles, disks<,
freeNodes = ComplementAnodalVars, boundaryNodesE ;
arrows = 9 Arrowheads@.02D,
freeNodes ê. 9uAx_, y_E ß 9ArrowA99x, y=, 9x + arrowLen, y==E,
TextAuAx, yE, OffsetA812, 12<, 9x + arrowLen, y=EE=,
vAx_, y_E ß 9ArrowA99x, y=, 9x, y + arrowLen==E,
TextAvAx, yE, OffsetA812, 12<, 9x, y + arrowLen=EE==
=;
circles =
UnionAfreeNodes ê. Hu
vLAx_, y_E ß CircleA9x, y=, arrowLenê6EE;
disks = UnionAboundaryNodes ê.
Hu
vLAx_, y_E ß DiskA9x, y=, arrowLenê6EE;
Flatten@8circles, disks, arrows<D
E
trussForceGraphicsAforceA9x_, y_=, fx_, fy_E, scale_, opts___E :=
ModuleA8a1, a2<,
a1 = 9ArrowA99x, y=, 9x + fx*scale, y==E,
TextAfx, OffsetA9Sign@fxD 12, 0=, 9x + fx*scale, y=EE=;
a2 = 9ArrowA99x, y=, 9x, y + fy*scale==E,
TextAfy, OffsetA90, SignAfyE 12=, 9x, y + fy*scale=EE=;
8a1, a2<
E
trussBoundaryAforceA9x_, y_=, fx_, fy_E, scale_, opts___E :=
ModuleA8a1, a2<,
a1 = ArrowA99x, y=, 9x + fx*scale, y==E;
a2 = ArrowA99x, y=, 9x, y + fy*scale==E;
8a1, a2<
544 | Chapter 13: Science and Engineering

E
TrussModelA8elements__linearElement<, boundaryNodes_, _, _, nodalVars_,
forceVec_, degreesOfFreedom_, forces_EA"diagram", opts___E :=
ModuleA8dispLen, forceScale, min, max<,
8max, min< = 8Max@ÒÒD, Min@ÒÒD< & üü Flatten@List üüü nodalVarsD;
dispLen = Hmax - minL ê15;
forceScale = Hmax - minLêH3 Max@Abs@forceVecDDL;
GraphicsA9
trussGraphicsElement@Ò, optsD & êü 8elements< ,
trussGraphicsNodesAnodalVars, boundaryNodes, dispLen, optsE,
Flatten@trussForceGraphics@Ò, forceScale, optsD & êü 8forces<D
=, Axes Ø True, ImagePadding Ø All, AxesOrigin Ø 8-maxê10, -maxê10<EE
As before, once the infrastructure is in place, the diagram is easy to create by simply
asking the model for the "diagram" property.
In[136]:=
tmA"diagram"E
Out[136]=
Other  important  properties  are  axialStrain,  axialStress,  and  axialForce.  These
will be implemented to return all or specific values for a specified element.
13.11 Modeling Truss Structures Using the Finite Element Method | 545

In[137]:=
Clear@axialStrainD
axialStrainA
linearElementA99x1_, y1_=, 9x2_, y2_==, __E, displacements_E :=
ModuleA8l, m, L, dv<,
dv = 9uAx1, y1E, vAx1, y1E, uAx2, y2E, vAx2, y2E= ê. displacements ê.
Hu
vL@__D Ø 0;
L = EuclideanDistanceA9x1, y1=, 9x2, y2=E;
l = Hx2 - x1LêL;
m = Iy2 - y1Më L;
Plus@-Ò1, Ò2D & üü Dot@88l, m, 0, 0<, 80, 0, l, m<<, dvDêLE
axialStress@linearElement@_, _, YM_D, strain_D := strain * YM;
axialForce@linearElement@_, A_, _D, stress_D := stress * A ;
In[141]:=
TrussModel@8elements__linearElement<, __D@"elements"D := 8elements<
In[142]:=
TrussModel@model__D@"axial strain", element_ : AllD :=
Module@8thisModel, disp, elements<,
thisModel = TrussModel@modelD;
disp = thisModel@"displacements"D;
elements = Cases@thisModel@"elements"D, element ê. 8All Ø _<D;
axialStrain@Ò, dispD & êü elementsD
TrussModel@model__D@"axial stress", element_ : AllD :=
Module@8thisModel, strain, elements<,
thisModel = TrussModel@modelD;
elements = Cases@thisModel@"elements"D, element ê. 8All Ø _<D;
strain = thisModel@"axial strain", elementD;
MapThread@axialStress , 8elements, strain<DD
In[144]:=
TrussModel@model__D@"axial force", element_ : AllD :=
Module@8thisModel, stress, elements<,
thisModel = TrussModel@modelD;
elements = Cases@thisModel@"elements"D, element ê. 8All Ø _<D;
stress = thisModel@"axial stress", elementD;
MapThread@axialForce , 8elements, stress<DD
In[145]:=
tm@"axial strain"D
Out[145]=
8-0.000174295, -0.0000314997, -0.0000529407, -0.0000529407, 0.000320869<
In[146]:=
tm@"axial strain", linearElement@880, 0<, 81500, 3500<<, __DD
Out[146]=
8-0.000174295<
In[147]:=
tm@"axial stress"D
Out[147]=
8-34.8591, -6.29994, -10.5881, -10.5881, 22.4608<
546 | Chapter 13: Science and Engineering

In[148]:=
tm@"axial force"D
Out[148]=
8-139436., -25199.8, -31764.4, -31 764.4, 44 921.7<
See Also
There are many books and online resources that cover FEM. For example, the the-
ory relevant to truss structures can be found at Jason Midkiff’s Virginia Tech science
and engineering website: http://bit.ly/32BUq1. 
If you are looking for books with a Mathematica focus, look no further than Funda-
mental Finite Element Analysis and Applications: With Mathematica and Matlab Com-
putations (John Wiley) and~if you are really into FEM~Advanced Topics in Finite
Element Analysis of Structures: With Mathematica and MATLAB Computations (John
Wiley), both by M. Asghar Bhatti. The code in these books is pre|version 6, but
I found few incompatibilities. 
13.11 Modeling Truss Structures Using the Finite Element Method | 547


CHAPTER 14
Financial Engineering
I’ve got the brains, you’ve got the looks
Let’s make lots of money
You’ve got the brawn, I’ve got the brains
Let’s make lots of money
Pet Shop Boys, “Opportunities (Let’s Make
Lots of Money)”
14.0 Introduction
Financial engineering (also known as computational finance) is the use of computers
to create mathematical models and simulations that attempt to price financial instru-
ments, model their sensitivity to changes in the market, hedge against these changes,
and measure and manage risk. This is a high-stakes game, where there can be great
reward for getting things right but even greater loss if you get things wrong. This be-
came  acutely  evident  during  the  financial  crisis  that  started  around  July  2007.  It
might  be  tempting  to  conclude  that  attempts  to  bring  mathematical  rigor  to  the
chaos of the market is foolhardy, but this would be like concluding that traditional
engineering is foolhardy because a plane crashed or a bridge fell. Such failings are hu-
man failings, not mathematical ones. They only point to the need to use computa-
tional tools more diligently and more responsibly.
One goal for this chapter was to create a variety of recipes with a range of difficul-
ties. This means that there are some recipes that may seem trivial and others that a
novice might find difficult. Almost every recipe tries to demonstrate techniques that
are unique to Mathematica; I hope readers of every skill level will take away tech-
niques that they can apply to financial problems that interest them. 
549

Mathematica has unique characteristics lacking in many other tools commonly used
in the financial industry. As of version 6, Mathematica has integrated financial data
that is essential to testing your models. This is a big plus; having worked in the indus-
try, I have seen how hard it can be for quants (quantitative analysts) to get data
easily that is immediately usable. This may seem counterintuitive; it seems that
investment banks and hedge funds would be swimming in data. They are, but you of-
ten must exert great effort to access it because of technical, logistical, and political
barriers. Recipe 14.1 explains how to use FinancialData to get access to historical
and delayed market data. Unfortunately, FinancialData is still incomplete. As of ver-
sion 7, it concentrates mainly on equities, commodities, and currency data. There is
nothing related to government, municipal, or corporate bonds; options; or interest
rates. Luckily, Mathematica will import data from other sources; Recipe 14.2 shows
an example of that.
Another important feature of Mathematica is its ability to find exact solutions using
its unparalleled symbolic capabilities. Exact solutions, when you can get them, over-
come  the  errors  and  inaccuracies  introduced  by  numerical  methods,  especially
around the boundaries of a solution. For example, when computing Greeks it is ad-
vantageous if you can compute a symbolic derivative (D) rather than a numerical one
(ND). Recipe 14.6 shows how the symbolic capabilities of Mathematica can be used
to compute and visualize the Greeks for European style options. See the introduc-
tory sidebar on page 551 if this is all Greek to you!
Performance is important in financial engineering, and getting Mathematica to per-
form well can be tricky for the novice. Recipes 14.8, 14.9, and 14.10 show how to
use some of the optimized special functions that execute at machine speed and how
to use Compile to eliminate the overhead of handwritten interpreted code. When writ-
ing numerically intense financial functions, you should try to compile as much as
possible, but there are cases where functions cannot be compiled fully and where do-
ing so may influence results.
Finally, Mathematica has some of the best visualization tools for checking your mod-
els and developing an intuition for their behaviors across different regions of the solu-
tion. Almost every recipe includes 2D or 3D plots, but Recipe 14.12 shows how you
can use lower-level graphics primitives to create useful diagrams.
550 | Chapter 14: Financial Engineering

A Brief Introduction to Computational Finance for the Nonquant
It is impossible to do justice to this topic in a few paragraphs, but since this is a general
purpose  book  and  computational  finance  is  littered  with  specific  terminology,  I
attempt to define some basic ideas that are assumed in the recipes in the book. The
references below can help you dig deeper.
Bonds  are  debt  instruments  that  allow  the  lending  of  money  under  set  terms.
Typically,  the  issuer  (borrower)  of  a  bond  is  obligated  to  pay  the  holder  (lender)
interest in the form of fixed payments at specified dates (the coupon). A wide variety
of terms are associated with various bonds that influence the computation of price,
yield, risk characteristics, and so forth. Some bonds may be convertible to a different
security  (e.g.,  common  stock)  and  some  may  be  callable  (the  issuer  can  cancel  their
obligation by paying back the holder before the bonds expire). A fixed-rate bond is initially
issued at a set price for a standardized amount (e.g., 1000 × $100.00) at a set interest rate
(e.g., 6%). After the bond is issued, its price fluctuates (based on factors such as interest
rates, credit ratings, and so forth). The change in price alters the bond’s yield or effective
interest rate, since the interest remains fixed. So, for example, if the bond was issued at
$100 but falls to $95, its yield would increase because a buyer would be getting the same
interest payments for less up-front cost. Thus, price and yield have an inverse relation.
An  option  on  a  security  is  a  contract  that  gives  the  holder  the  right  (but  not  the
obligation) to buy or sell that stock at a specific price (the strike price) on a specific
date. The owner of a call has the right to buy; the owner of a put has the right to sell
to the buyer. In contrast, the seller of a call is obligated to sell the security at the
strike if it is exercised by the owner, and the seller of the put is obligated to buy. It
would  only  make  sense  for  an  owner  of  an  option  to  exercise  it  if  it  were  in  the
money,  if  the  option’s  strike  were  favorable  relative  to  the  market  price  of  the
underlying security. For example, a call for IBM at strike $100 would be favorable to
the call owner if IBM were trading at $120 when the call was exercised: there would
be an immediate profit of $20 less transaction fees.
Options  come  in  different  flavors.  European  options  can  only  be  exercised  at  the
expiration date. These are the simplest to model. American options can be exercised
at any time up to expiration. If the underlying security pays dividends, it creates further
complications that must be accounted for in the model. There are also more exotic flavors
of options, such as Asian and Bermudian, that you can read about in the references. 
The Greeks are important measures for an options trader. The Greeks are computed
as  derivatives  of  the  option’s  pricing  function  with  respect  to  various  parameters.
For  example,  delta  is  the  derivative  with  respect  to  the  price  of  the  underlying
security.  Thus,  delta  measures  the  sensitivity  of  the  option’s  price  with  respect  to
changes in the underlying. Gamma is a second derivative with respect to price and
measures  the  sensitivity  of  delta.  Other  important  Greeks  are  theta  (time),  rho
(interest rates), and vega (volatility). These are discussed in Recipe 14.6.
14.0 Introduction | 551

See Also
The classic text in this area is Options, Futures, and Other Derivatives by John C.
Hull (Prentice Hall).
The  Wilmott  Journal  and  magazine  discuss  modern  ideas  in  quantitative  finance:
http://bit.ly/rm9hO.
If  you  have  more  of  a  passing  interest,  Wikipedia  has  good  definitions  and  basic
explanations of most of the ideas discussed here.
An excellent book that teaches Mathematica programming in parallel with financial
engineering  is  Computational  Financial  Mathematics  Using  Mathematica  by  Srdjan
Stojanovic´ (Springer). 
14.1 Leveraging Mathematica’s Bundled 
Financial Data
Problem
You need financial data to test your mathematical models.
Solution
Use Mathematica’s curated financial data, FinancialData. This is a data source that
you can query to extract quite a variety of up-to-date data (15-minute delayed and
historical) on a variety of security types, what Mathematica calls "Groups". To see
the available groups, execute the following. If this is the first time you are doing this,
you will see the status message "Initializing Financial Indices", and the groups
will display.
In[1]:=
FinancialData@"Groups"D
Out[1]=
9Currencies, Exchanges, ExchangeTradedFunds,
Futures, Indices, MutualFunds, Sectors, Stocks=
The next thing you will want to find is the available properties of the data.
552 | Chapter 14: Financial Engineering

In[2]:=
FinancialData@"Properties"D
Out[2]=
9Ask, AskSize, Average200Day, Average50Day, AverageVolume3Month,
Bid, BidSize, BookValuePerShare, Change, Change200Day, Change50Day,
ChangeHigh52Week, ChangeLow52Week, CIK, Close, Company,
CumulativeFractionalChange, CumulativeReturn, CUSIP, Dividend,
DividendPerShare, DividendYield, EarningsPerShare, EBITDA, Exchange,
FloatShares, ForwardEarnings, ForwardPERatio, FractionalChange,
FractionalChange200Day, FractionalChange50Day, FractionalChangeHigh52Week,
FractionalChangeLow52Week, High, High52Week, ISIN, LastTradeSize,
LatestTrade, Lookup, Low, Low52Week, MarketCap, Name, Open, PEGRatio,
PERatio, Price, PriceTarget, PriceToBookRatio, PriceToSalesRatio,
QuarterForwardEarnings, Range, Range52Week, RawClose, RawHigh,
RawLow, RawOpen, RawRange, Return, Sector, SEDOL, ShortRatio,
SICCode, StandardName, Symbol, Volatility20Day, Volatility50Day,
Volume, Website, YearEarningsEstimate, YearPERatioEstimate=
Now you can retrieve data for a specific symbol. By default, you will get the current
price, but you can also ask for data from a specific date or within a date range.
In[3]:=
FinancialData@"IBM", "Price"D
Out[3]=
127.17
In[4]:=
DateListPlot@8FinancialData@"IBM", "Price", "Jan 1,2005"D,
FinancialData@"AAPL", "Price", "Jan 1,2005"D<D
Out[4]=
2005
2006
2007
2008
2009
2010
50
100
150
200
14.1 Leveraging Mathematica’s Bundled Financial Data | 553

Discussion
FinancialData has a rich interface that allows you to perform many types of queries.
First, let’s see how you can use the interface to find what is available. Suppose you
are curious to see what coverage there is for a specific symbol.
In[5]:=
FinancialData@"IBM", "Properties"D
Out[5]=
9Ask, AskSize, Average200Day, Average50Day, AverageVolume3Month,
Bid, BidSize, BookValuePerShare, Change, Change200Day, Change50Day,
ChangeHigh52Week, ChangeLow52Week, CIK, Close, Company,
CumulativeFractionalChange, CumulativeReturn, CUSIP, Dividend,
DividendPerShare, DividendYield, EarningsPerShare, EBITDA, Exchange,
FloatShares, ForwardEarnings, ForwardPERatio, FractionalChange,
FractionalChange200Day, FractionalChange50Day, FractionalChangeHigh52Week,
FractionalChangeLow52Week, High, High52Week, ISIN, LastTradeSize,
LatestTrade, Lookup, Low, Low52Week, MarketCap, Name, Open, PEGRatio,
PERatio, Price, PriceTarget, PriceToBookRatio, PriceToSalesRatio,
QuarterForwardEarnings, Range, Range52Week, RawClose, RawHigh,
RawLow, RawOpen, RawRange, Return, Sector, SEDOL, ShortRatio,
SICCode, StandardName, Symbol, Volatility20Day, Volatility50Day,
Volume, Website, YearEarningsEstimate, YearPERatioEstimate=
One difficulty is that every security is not guaranteed to have every property popu-
lated. There seem to be two possibilities when a property is not present. You may
get Missing["NotAvailable"] or you may get an unevaluated expression like Financial-
Data["IBM",  "CumulativeFractionalChange"].  One  way  to  see  what  properties  are
populated and also get a sample of the associated data is to execute the following (I
elide the results with Short).
In[6]:=
WithA8sec = "IBM"<,
SelectA
Table@8prop, FinancialData@sec, propD<,
8prop, FinancialData@sec, "Properties"D<D,
FreeQAÒ, 9_, Missing@"NotAvailable"D
HoldPattern@FinancialData@__DD=E &EE êê Short
Out[6]//Short=
99Average200Day, 122.097=, 9Average50Day, 129.82=, á54à,
9YearEarningsEstimate, 11.08=, 8YearPERatioEstimate, 11.64<=
Let’s look at other types of financial data and see some of the additional capabilities
that are provided. Industry sectors are especially useful for studying and comparing
different industries’ performance.
554 | Chapter 14: Financial Engineering

In[7]:=
Length@FinancialData@"Sectors"DD
Out[7]=
169
There are 169 sectors. Here I use a pattern to find those with the string "Service" in
the name.
In[8]:=
SelectAFinancialData@"Sectors"D, StringMatchQ@Ò, __ ~~ "Service" ~~ __D &E
Out[8]=
9CommunicationsServicesNotElsewhere,
LegalServices, MiscellaneousBusinessServices,
MiscellaneousHealthAndAlliedServicesNot, OilNaturalGasFieldServices,
RefrigerationServiceMachinery, ResearchDevelopmentAndTestingServices,
TruckingAndCourierServicesExceptAir=
Given a sector, you can ask for its members. You can also use "Members" with an
index,  such  as  the  S&P  500,  or  an  exchange  like  the  New  York  Stock  Exchange
(NYSE). Here I pick 10 OilNaturalGasFieldServices members at random.
In[9]:=
RandomChoice@FinancialData@"OilNaturalGasFieldServices", "Members"D, 10D
Out[9]=
8DE:HRL, PK:ONXC, PK:ASRPF, F:SJR,
PK:VTHC, F:DG1, NYSE:WG, TO:POU, TO:POU, DE:DO1<
In[10]:=
Mean@Select@Quiet@FinancialData@Ò, "Price"D & êü
FinancialData@"OilNaturalGasFieldServices", "Members"DD, NumberQDD
Out[10]=
13.025
FinancialData  provides  information  on  153  currencies.  You  can  get  the  exchange
rate by using a string or list notation.
In[11]:=
Length@FinancialData@"Currencies"DD
Out[11]=
153
In[12]:=
FinancialData@"USDêEUR"D
Out[12]=
0.7065
In[13]:=
FinancialData@8"USD", "EUR"<D
Out[13]=
0.7065
FinancialData does not provide a notation to get more than a single property at a
time, which is unfortunate. You can use Outer to get this behavior, but it seems it
could be done more efficiently if this were native to FinancialData. First I extract
U.S. oil and gas service companies using FinancialData’s ability to list the members
of a sector. 
In[14]:=
americanOilGasCos =
SelectAFinancialData@"OilNaturalGasFieldServices", "Members"D,
StringMatchQ@Ò, H"AMEX:"
"NYSE:"
"NASDAQ:"L ~~ __D &E;
14.1 Leveraging Mathematica’s Bundled Financial Data | 555

Then, using Outer, I extract the market cap and a price. Recalling that market cap
equals share price * shares outstanding, it is easy to compute a share-weighted
average price for the sector by summing the market cap and dividing by the sum of
the shares outstanding. I put this in a function sharedWeightedAvg so we can reuse
it later.
In[15]:=
sharedWeightedAvgAsymbols_List, price_E := ModuleA8data<,
data = SelectA
QuietAOuterAFinancialData@Ò1, Ò2D &, symbols, 8"MarketCap", price<EE,
And üü HNumberQ êü ÒL &E;
Total@dataD@@1DDêTotal@Divide üü Ò & êü dataDE
sharedWeightedAvg@americanOilGasCos, "Close"D
Out[16]=
33.619
You can add as many properties as you need to the second argument of Outer. As
usual, it is a good idea to filter out invalid data, as I do here by using Select and test-
ing for numeric values in both entries using And @@ (NumberQ /@ #) & as the filter
function.
You can use "Members" with indices and exchanges. Here I get the share-weighted av-
erage for the Dow Jones Industrial Average (DJIA) stocks.
In[17]:=
sharedWeightedAvg@FinancialData@"^DJI", "Members"D, "Close"D
Out[17]=
35.3389
In[18]:=
FinancialDataA"Exchanges"E
Out[18]=
9AMEX, Amsterdam, AustraliaASX, Barcelona, Berlin, Bilbao, Bombay, Brussels,
BuenosAires, Cairo, CBOE, CBOT, CME, Colombo, COMEX, Copenhagen,
Dusseldorf, Eurex, Euronext, Frankfurt, Hamburg, Hanover, HongKong,
IndiaNSE, Ireland, Jakarta, KCBT, KoreaKOSDAQ, KoreaKSE, Lisbon,
LondonIOB, LSE, Madrid, MadridCATS, MexicoBMV, Milan, Munich, NASDAQ,
NewZealandNZX, NYBOT, NYMEX, NYSE, Oslo, OTCBB, Paris, PhilippinesPSE,
Pinksheets, Prague, RussiaRTS, Santiago, SaoPaulo, Shanghai,
Shenzhen, Singapore, Stockholm, Stuttgart, SwitzerlandSWX, TaiwanOTC,
TaiwanTSEC, TelAviv, Toronto, TSXVenture, Valencia, Vienna, Xetra=
A special property called "Lookup" allows you to search using patterns. Here I search
for New York Mercantile Exchange (NYMEX) symbols that begin with "A" and re-
trieve the full name.
In[19]:=
FinancialData@Ò, "Name"D & êü FinancialData@"NYM:A*", "Lookup"D
Out[19]=
8Ardour Global XL Mar 2009, Ardour Global XL Jun 2009,
Ardour Global XL Sep 2009, Ardour Global XL Dec 2008<
556 | Chapter 14: Financial Engineering

You can use dynamic features to create a mini interface for exploring the data. Here
I use PopMenu to create an interface over all the symbols in the Dow Jones Industrials
and all available properties.
In[20]:=
DynamicModuleA9symbol = "MSFT", prop=,
RowA9PopupMenuADynamicAsymbolE, FinancialData@"^DJI", "Members"DE,
PopupMenuADynamic@propD, FinancialData@"Properties"DE,
DynamicAFinancialDataAsymbol, propEE=, " "EE
Out[20]=
MSFT
Ask
29.17
In the solution, we saw that data can be retrieved over intervals of time. The inter-
vals can specify a start date, a start and an end date, and also a period, such as "Day",
"Week", "Month", or "Year". 
In[21]:=
FinancialData@"^DJI", 8"Jan 1,2008", "Jan 1,2009", "Month"<D
Out[21]=
8882008, 1, 2<, 12650.4<, 882008, 2, 1<, 12 266.4<, 882008, 3, 3<, 12 262.9<,
882008, 4, 1<, 12820.1<, 882008, 5, 1<, 12 638.3<, 882008, 6, 2<, 11 350.<,
882008, 7, 1<, 11378.<, 882008, 8, 1<, 11 543.6<, 882008, 9, 2<, 10 850.7<,
882008, 10, 1<, 9325.01<, 882008, 11, 3<, 8829.04<, 882008, 12, 1<, 8776.39<<
14.2 Importing Financial Data from Websites
Problem
The data you want is not yet available from FinancialData but it is available from an-
other website.
Solution
The  Import  function  can  retrieve  data  directly  from  websites  like  Yahoo!  Finance
that support an interface that uses HTTP GET|style queries. Here I extract options
data for IBM.
In[22]:=
WithA9optSymbol = "IBMGM.X"=,
ImportA"http:êêdownload.finance.yahoo.comêdêquotes.csv?s=" <>
optSymbol <> "&f=sl1d1t1c1ohgv&e=.csv"EE
Out[22]=
88IBMGM.X, 0., NêA, NêA, 0., 0., 0., 0., 0<<
Discussion
The Yahoo! URL structure is self-explanatory except for the f=sl1d1t1c1ohgv  por-
tion. The f stands for “format,” and the characters define the types of data you want
14.2 Importing Financial Data from Websites | 557

to  download.  For  example,  s  stands  for  symbol,  l1  last  trade  price,  and  d1  is  the
trade  date.  The  entire  set  is  available  on  a  website  (see  the  “See  Also”  section  on
page 559).
To get more data on options chains it is useful to be able to encode an option sym-
bol. Each option symbol is made up of a base symbol, an expiration month letter in
the range A|L for calls and M|X for puts, and a strike price letter. Standard strike
prices are in increments of 5 and use the letters A|T, but there are also fractional
strike prices using letters U|Z (see the “See Also” section on page 559).
In[23]:=
strikePriceCodeAstrike_IntegerE ê; Mod@strike, 5D ã 0 :=
FromCharacterCode@ToCharacterCode@"A"D + Mod@strikeê5 - 1, 20DD
strikePriceCode@strike_RealD :=
FromCharacterCode
@ToCharacterCode
@"U"D+Floor@Mod@Hstrike - 2.5L ê5 - 1, 6DDD
expirationCall@month_D :=
FromCharacterCode@ToCharacterCode@"A"D + month - 1D
expirationPut@month_D :=
FromCharacterCode@ToCharacterCode@"M"D + month - 1D
Now it is easy to download a range of options data, such as these July (month 7)
calls for IBM at various strike prices.
In[27]:=
WithA9symbols = Flatten@Table@"IBM" <> expirationCall@7D <>
strikePriceCode@strikeD <> ".X", 8strike, 60, 135, 5<DD=,
TableAImportA"http:êêdownload.finance.yahoo.comêdêquotes.csv?s=" <>
optSymbol <> "&f=sl1d1t1c1ohgv&e=.csv"E, 9optSymbol, symbols=EE
Out[27]=
888IBMGL.X, 0., NêA, 2:56pm, NêA, NêA, NêA, NêA, NêA<<,
88IBMGM.X, 0., NêA, NêA, 0., 0., 0., 0., 0<<,
88IBMGN.X, 0., NêA, NêA, 0., 0., 0., 0., 0<<,
88IBMGO.X, 0., NêA, NêA, 0., 0., 0., 0., 0<<,
88IBMGP.X, 51.4, 1ê22ê2010, 10:54am, 0., 51.4, 51.4, 51.4, 10<<,
88IBMGQ.X, 46.45, 1ê22ê2010, 10:55am, 0., 46.45, 46.45, 46.45, 10<<,
88IBMGR.X, 39.15, 1ê22ê2010, 10:54am, 0., 39., 39.15, 39.15, 34<<,
88IBMGS.X, 35., 1ê22ê2010, 10:54am, 0., 34.85, 35., 35., 52<<,
88IBMGT.X, 29.45, 1ê22ê2010, 10:54am, 0., 29.45, 29.45, 29.45, 2<<,
88IBMGA.X, 24.78, 1ê22ê2010, 10:54am, 0., 25.73, 24.78, 24.78, 106<<,
88IBMGB.X, 18.7, 1ê22ê2010, 10:55am, -2., 21.52, 19.8, 18.7, 16<<,
88IBMGC.X, 15.65, 1ê22ê2010, 10:54am, -0.45, 16.6, 15.65, 15.65, 55<<,
88IBMGD.X, 11.45, 1ê22ê2010, 10:55am, -0.9, 11.15, 11.95, 11.15, 49<<,
88IBMGE.X, 8.05, 1ê22ê2010, 10:54am, -0.95, 8.55, 8.75, 8.05, 111<<,
88IBMGF.X, 5.59, 1ê22ê2010, 10:55am, -0.76, 6.4, 6.2, 5.5, 62<<,
88IBMGG.X, 3.6, 1ê22ê2010, 10:54am, -0.6, 4.5, 4.05, 3.6, 63<<<
You  can  also  import  data  from  files  in  a  variety  of  formats  and  from  databases
(provided  you  have  access  to  such  databases).  See  Recipe  17.9  for  Mathematica's
database connectivity capabilities.
558 | Chapter 14: Financial Engineering

See Also
An explanation of the Yahoo! interface can be found at: http://bit.ly/dyiIPO.
The encoding of options ticker symbols is explained here http://bit.ly/24yb0p.
14.3 Present Value of Future Cash Flows
Problem
You want to compute the present value of a set of cash payments or receipts over
time.
Solution
Use the standard formula for compound interest calculations to discount future cash
flows to the present.
In[28]:=
pv@cashFlows_List, times_List, rate_RealD :=
ModuleB9T = Length@cashFlowsD=, ‚
t=1
T
cashFlows@@tDD
H1 + rateLtimes@@tDD
F
For example, if you pay $1000 today to receive income of $100, $300, $600, and
$600 in the next four years with a rate of 5%, the present value is
In[29]:=
pv@8-1000.0, 100.0, 300.0, 600.0, 600.0<, 80, 1, 2, 3, 4<, 0.05D
Out[29]=
379.271
Discussion
Cash in hand today is worth more then the same amount in the future. Present value
is determined by discounting future cash flows by a discount factor. The solution fol-
lows from the formula for a discount factor in terms of an interest rate r and a time
t, which is Hr + 1L-t. There are some standard types of cash flow arrangements, and
you can use Simplify to derive them from the standard present value formula in the
solution. For example, a perpetuity is a set of fixed cash flows X that repeat forever. 
In[30]:=
SimplifyASumAXêH1 + rL^t, 9t, 1, Infinity=EE
Out[30]=
X
r
In[31]:=
1êHH1 + rL^tL êê TraditionalForm
Out[31]//TraditionalForm=
Hr + 1L-t
14.3 Present Value of Future Cash Flows | 559

Hence...
In[32]:=
pvPerpetuity@cash_Real, rate_RealD :=
cash
rate
An annuity is a set of fixed cash flows X that repeat for a specified number of periods T.
In[33]:=
Simplify@Sum@XêH1 + rL^t, 8t, 1, T<DD
Out[33]=
X - H1 + rL-T X
r
In[34]:=
pvPerpetuity@100.00, 0.03D
Out[34]=
3333.33
Hence...
In[35]:=
pvAnuityAcash_Real, rate_Real, periods_IntegerE :=
cash - H1 + rateL-periods cash
rate
In[36]:=
pvAnuity@100.00, 0.03, 10D
Out[36]=
853.02
Closely  related  to  present  value  is  the  internal  rate  of  return,  the  rate  that  would
make the present value equal to zero. You can use FindRoot to calculate the internal
rate of return for a set of cash flows. Here we tell FindRoot to begin searching for a so-
lution at irr of 0.0.
In[37]:=
internalRateOfReturn@cashFlows_List, times_ListD :=
FindRoot@pv@cashFlows, times, irrD, 8irr, 0.0<D
In[38]:=
internalRateOfReturn@8-1000.0, 100.0, 300.0, 600.0, 600.0<, 80, 1, 2, 3, 4<D
Out[38]=
8irr Ø 0.169775<
In finance, it is more common to deal with continuously compounding interest than
the discrete compounding formulas discussed. The present value in terms of continu-
ously compounding interest is
In[39]:=
pvCC@cashFlows_List, times_List, rate_RealD :=
ModuleA9N = Length@cashFlowsD=,
Sum@cashFlows@@iDDêE^Hrate*times@@iDDL,
8i, 1, N<DE
In[40]:=
pvCC@8-1000.0, 100.0, 300.0, 600.0, 600.0<, 80, 1, 2, 3, 4<, 0.05D
Out[40]=
374.237
560 | Chapter 14: Financial Engineering

See Also
You may want to play with (and download the source code for) some of the Wolfram
demonstrations  that  cover  present  value  and  related  basic  financial  concepts.  See,
for example, http://bit.ly/1D7JVU. 
14.4 Interest Rate Sensitivity of Bonds 
Problem
You want to determine the fair value of a bond and analyze its performance under
varying market conditions.
Solution
Before  you  can  analyze  a  bond,  you  need  to  know  how  to  compute  its  price  and
yield to maturity. The price of a fixed-rate bond is equivalent to the present value of the
bond’s coupon payments. For example, if a three-year bond has a face value of $100
and makes yearly payments of 10% and the present interest rate is 8%, then the fair
bond price should be
In[41]:=
pv@810, 10, 110<, 81, 2, 3<, 0.08D
Out[41]=
105.154
The price only captures one aspect of a bond. You may also want to know the effec-
tive interest rate of the bond if it is held to maturity (yield to maturity). This is the
same as the internal rate of return calculation of Recipe 12.1. The first cash flow
is the bond’s price, then the two coupon payments, and the final is coupon plus
face value.
In[42]:=
H*Yield to maturity for a bond is the same
calculation as IRR with bond price as first cash flow.*L
internalRateOfReturn@8-105.154, 10, 10, 110<, 80, 1, 2, 3<D
Out[42]=
8irr Ø 0.0800007<
It is no accident that the yield to maturity is equal (modulo rounding errors) to the
current interest rate. This is a sign that the bond is priced correctly. 
Investors in bonds want to understand a bond’s sensitivity to changes in current inter-
est rates. The price of an asset with long-term cash flows has more interest-rate sensi-
tivity than an asset with cash flows in the near future. The duration is a weighted
average maturity of a bond. 
14.4 Interest Rate Sensitivity of Bonds | 561

In[43]:=
duration@cashFlows_List, times_List, rate_RealD :=
ModuleA9T = Length@cashFlowsD, D, B=,
8D, B< = Sum@8Htimes@@tDD*cashFlows@@tDDLêH1 + rateL^times@@tDD,
cashFlows@@tDDêH1 + rateL^times@@tDD<, 8t, 1, T<D; DêBE
In[44]:=
duration@810, 10, 110<, 81, 2, 3<, 0.08D
Out[44]=
2.74236
In[45]:=
convexity@cashFlows_List, times_List, rate_RealD :=
ModuleA9T = Length@cashFlowsD, B=,
B = pv@cashFlows, times, rateD; H1êBL*H1êH1 + rateL^2L *
Sum@Htimes@@tDD + times@@tDD^2L *
HcashFlows@@tDDêH1 + rateL^times@@tDDL, 8t, 1, T<DE
In[46]:=
convexity@810, 10, 110<, 81, 2, 3<, 0.08D
Out[46]=
9.11374
Discussion
In[47]:=
Plot@pv@810, 10, 10, 10, 10, 110<, 81, 2, 3, 4, 5, 6<, rD, 8r, 0.0, 0.20<D
Out[47]=
0.05
0.10
0.15
0.20
100
120
140
160
In[48]:=
PlotApvAAppend@Table@10, 8119<D, 110D, Range@1, 120D, rE, 8r, 0.0, 0.20<E
Out[48]=
0.05
0.10
0.15
0.20
200
300
400
500
600
562 | Chapter 14: Financial Engineering

14.5 Constructing and Manipulating 
Yield Curves
Problem
You want to build a yield curve from underlying spot rates and then model changes
in the curve so you can model the return of a portfolio of rate-sensitive securities.
Solution
If you are only interested in changes in the yield curve at a particular maturity, you
can use published yields for various maturities and use interpolation. For example,
here is some interest rate data taken from Bloomberg in late June 2009. The pairs
are {days, rate}.
In[49]:=
rates = 887, 0.01<, 814, 0.04<, 830, 0.05<, 860, 0.17<, 8180, 0.29<,
8360, 0.4<, 8730, 1.11<, 81095, 1.63<, 81825, 2.56<, 82555, 3.20<,
83650, 3.54<, 85475, 4.12<, 87300, 4.49<, 810 950, 4.86<<;
In[50]:=
iRates = Interpolation@rates, Method Ø "Spline"D;
In[51]:=
ShowAListPlotArates, PlotStyle Ø 8PointSize@0.01D<,
PlotRange Ø 880, 11000<, 80, 6<<E,
Plot@iRates@tD, 8t, 7, 11000<D
E
Out[51]=
0
2000
4000
6000
8000
10000
0
1
2
3
4
5
6
Interpolation is all well and good, but if you want to understand the dynamics of the
curve, you need a model. The Nelson-Siegel function is a popular parametric model
of the yield curve. 
14.5 Constructing and Manipulating Yield Curves | 563

In[52]:=
nsYieldCurve@m_, b0_, b1_, b2_, t_D :=
b0 +
b1 H1 - Exp@-mêtDL
HmêtL
+
b2
H1 - Exp@-mêtDL
HmêtL
- Exp@-mêtD
In[53]:=
fit = FindFit@ rates, nsYieldCurve@m, b0, b1, b2, tD,
8b0, b1, b2, t<, m, Method Ø NMinimizeD
Out[53]=
8b0 Ø 5.28846, b1 Ø -5.26294, b2 Ø -3.75868, t Ø 651.468<
Here I use the fitted curve to initialize a Manipulate. You can then play with the pa-
rameters to get a feel for their effect.
In[54]:=
ManipulateAShowAListPlotArates,
PlotStyle Ø 8PointSize@0.01D<, PlotRange Ø 880, 11 000<, 80, 6<<E,
PlotAnsYieldCurve@m, beta0, beta1, beta2, tauD,
8m, 1, 11000<, PlotRange Ø 880, 11 000<, 80, 6<<EE,
88beta0, b0<, 3, 6, 0.1<,
88beta1, b1<, 2, -6, 0.1<,
88beta2, b2<, -5, -1, 0.1<,
88tau, t<, 100, 1000, 10<, SaveDefinitions Ø TrueE ê. fit
Out[54]=
beta0
beta1
beta2
tau
0
2000
4000
6000
8000
10000
0
1
2
3
4
5
6
564 | Chapter 14: Financial Engineering

Discussion
An extension of the Nelson-Siegel model is the Svensson model, which addresses problems
with convexity, inaccuracies introduced for large changes in yield due to the nonlinear
relationship between prices and yields. The capital gain induced by a decline in the
yield is larger than the capital loss induced by an equal-sized increase in the yield.
Given the Svensson model for the forward curve, you can use Mathematica’s sym-
bolic integration capabilities to find the zero coupon (or spot) model.
In[55]:=
Clear@svForwardCurve, svSpotCurveD;
svForwardCurve@m_, b0_, b1_, b2_, b3_, t1_, t2_D :=
b0 + b1 Exp@-mêt1D + b2 Hmêt1L Exp@-mêt1D + b3 Hmêt2L Exp@-mêt2D
In[57]:=
svSpotCurve@m_, b0_, b1_, b2_, b3_, t1_, t2_D =
FullSimplifyAH1êmL*
Integrate@svForwardCurve@m, b0, b1, b2, b3, t1, t2D, 8m, 0, m<DE
Out[57]=
m b0 + b1
t1 - ‰
-
m
t1 t1
+ b2
t1 - ‰
-
m
t1 Hm + t1L
+ b3
t2 - ‰
-
m
t2 Hm + t2L
m
The solution demonstrates a so-called parametric method (i.e., a method based on
parameters  that  have  real-world  meaning).  There  are  also  nonparametric  methods
that are in use where curves are fit using polynomials and tension splines. See the
following references.
See Also
This recipe is based on Parsimonious Modeling of Yield Curves by Charles R. Nelson
and  Andrew  F.  Siegel  (Journal  of  Business,  Vol.  60,  No.  4  [Oct.  1987]:  473|489),
which can be found online at http://bit.ly/1mQ3mq.
A library of Mathematica code for working with the term structure of interest rates
can be found on Mark Fisher’s website at http://bit.ly/3hW4KC, with documentation
at http://bit.ly/1ormSc.
A more thorough investigation of yield curve models can be found in this notebook
at the Wolfram Library Archives, http://bit.ly/17OU4U, which was developed by Jan
Hurt of the Charles University of Prague.
14.6 Black-Scholes for European Option Pricing
Problem
You want to price European puts and calls using the Black-Scholes formula.
14.6 Black-Scholes for European Option Pricing | 565

Solution
We  give  the  solution  to  the  Black-Scholes  formula  here  without  derivation.  There
are many excellent resources listed in the “See Also” section on page 572 for readers
interested  in  the  theory  underlying  this  solution.  The  helper  functions  d1  and  d2
have become fairly standard within the literature, so I use them here despite my per-
sonal aversion to short, cryptic names. The expression involving the d1 term in the
pricing functions is related to the value of acquiring the stock; the expression involv-
ing the d2 term relates to the value of exercising the option on expiration. 
In[58]:=
Clear@d1, d2, priceEuroCall, priceEuroPutD
These helper functions are used by both priceEuroCall and priceEuroPut.
In[59]:=
d1Aprice_Real, strike_Real, volatility_Real, maturityT_Real, rate_RealE :=
ILog@priceêstrikeD + Irate + volatility^2.ë 2.M*maturityTMë
Ivolatility*SqrtAmaturityTEM;
d2Aprice_Real, strike_Real, volatility_Real, maturityT_Real, rate_RealE :=
d1Aprice, strike, volatility, maturityT, rateE -
volatility*SqrtAmaturityTE;
cumNormDist@x_?NumberQD := CDF@NormalDistribution@D, xD;
Given the price of a stock, the strike price of the option, the volatility, time to option
maturity in fractions of a year, and the risk-free interest rate, compute the value of a
call or put option.
In[62]:=
priceEuroCallAprice_Real, strike_Real,
volatility_Real, maturityT_Real, rate_RealE :=
price*cumNormDistAd1Aprice, strike, volatility, maturityT, rateEE -
strike*ExpA-rate*maturityTE*
cumNormDistAd2Aprice, strike, volatility, maturityT, rateEE
The fact that a put can be priced in terms of a call is called put-call parity.
In[63]:=
priceEuroPutAprice_Real, strike_Real, volatility_Real, maturityT_Real,
rate_RealE := priceEuroCallAprice, strike, volatility, maturityT, rateE +
strike*ExpA-rate*maturityTE - price
Here we compute the value of a call option with strike $60 and 1/2 year to maturity,
with the underlying stock trading at $70, with a volatility of 0.29, and a risk-free rate
of 4%. The volatility is usually measured as the standard deviation of the stock price.
In[64]:=
priceEuroCall@70., 60., 0.29, 0.5, 0.04D
Out[64]=
12.6323
566 | Chapter 14: Financial Engineering

Here  we  show  the  opposing  relationship  between  a  call  and  a  put  with  equal
attributes by plotting their values against the price of the underlying stock. A call
increases in value with the stock price, whereas a put decreases in value. 
In[65]:=
PlotA8priceEuroCall@s, 60., 0.29, 0.5, 0.04D,
priceEuroPut@s, 60., 0.29, 0.5, 0.04D<, 8s, 40, 80<,
PlotRange -> All, AxesLabel -> 8"stock price", "option price"<,
PlotRange Ø 880, 15<, 82, 15<<, ImageSize Ø SmallE
Out[65]=
50
60
70
80
stock price
5
10
15
20
option price
Discussion
Although the ability to price an option is vital to successful trading, it is equally vital
to measure the sensitivity of an option (or any other derivative security) to changes
in  the  economic  environment.  These  measures  are  based  on  mathematical  deriva-
tives of the pricing function. These measures are collectively known as the Greeks be-
cause each is associated with a Greek letter.
In[66]:=
ClearAdeltaEuroCall, deltaEuroPut,
gammaEuroCall, gammaEuroPut, thetaEuroCall, thetaEuroPut,
rhoEuroCall, rhoEuroPut, vegaEuroCall, vegaEuroPutE
Delta is a measure of the sensitivity of an option to changes in the stock price. It is
computed as the first derivative of the pricing function with respect to the underly-
ing stock price.
In[67]:=
deltaEuroCallAprice_Real, strike_,
volatility_Real, maturityT_Real, rate_RealE :=
ModuleA8s<, DApriceEuroCallAs, strike, volatility, maturityT, rateE, sE ê.
s ß priceE
deltaEuroPutAprice_Real, strike_, volatility_Real,
maturityT_Real, rate_RealE :=
DApriceEuroPutAs, strike, volatility, maturityT, rateE, sE ê. s ß price
Gamma is a measure of the sensitivity of the delta to changes in the stock price. It is
computed as the second derivative of the pricing function with respect to the underly-
ing stock price.
14.6 Black-Scholes for European Option Pricing | 567

In[69]:=
gammaEuroCallAprice_Real, strike_, volatility_, maturityT_, rate_E :=
ModuleA8s<,
DApriceEuroCallAs, strike, volatility, maturityT, rateE, 8s, 2<E ê.
s ß priceE
gammaEuroPutAprice_Real, strike_, volatility_, maturityT_, rate_E :=
ModuleA8s<,
DApriceEuroPutAs, strike, volatility, maturityT, rateE, 8s, 2<E ê.
s ß priceE
Theta is a measure of the sensitivity of the option price to time. It is computed as the
first derivative of the pricing function with respect to the time to expiration (maturity).
In[71]:=
thetaEuroCallAprice_Real, strike_,
volatility_Real, maturityT_Real, rate_RealE :=
ModuleA8t<, -DApriceEuroCallAprice, strike, volatility, t, rateE, tE ê.
t ß maturityTE
thetaEuroPutAprice_Real, strike_, volatility_Real,
maturityT_Real, rate_RealE :=
ModuleA8t<, -DApriceEuroPutAprice, strike, volatility, t, rateE, tE ê.
t ß maturityTE
Rho is a measure of the sensitivity of the option price to changes in the risk-free rate.
It is computed as the first derivative of the pricing function with respect to the inter-
est rate.
In[73]:=
rhoEuroCallAprice_Real, strike_Real,
volatility_Real, maturityT_Real, rate_RealE :=
ModuleA8r<, DApriceEuroCallAprice, strike, volatility, maturityT, rE,
rE ê. r ß rateE
rhoEuroPutAprice_Real, strike_Real, volatility_Real,
maturityT_Real, rate_RealE :=
ModuleA8r<, DApriceEuroPutAprice, strike, volatility, maturityT, rE, rE ê.
r ß rateE
Vega  (also  known  as  kappa)  is  a  measure  of  the  sensitivity  of  the  option  price  to
changes in the volatility.  It is computed as the first derivative of the pricing function
with respect to the volatility.
568 | Chapter 14: Financial Engineering

In[75]:=
vegaEuroCallAprice_Real, strike_Real,
volatility_Real, maturityT_Real, rate_RealE :=
ModuleA8v<, DApriceEuroCallAprice, strike, v, maturityT, rateE, vE ê.
v ß volatilityE
vegaEuroPutAprice_Real, strike_Real, volatility_Real,
maturityT_Real, rate_RealE :=
ModuleA8v<, DApriceEuroPutAprice, strike, v, maturityT, rateE, vE ê.
v ß volatilityE
Here we compute delta of a call with strike $60 with 6 months left to maturity when
the stock is trading at $40. This shows that the option will change value by roughly
3.7 cents for a dollar move. We can confirm this using the pricing function.
In[77]:=
deltaEuroCall@40.00, 60., 0.29, 0.5, 0.04D
Out[77]=
0.0377654
This is in basic agreement with the difference between the value of the option at a
stock price of $40.50 and $39.50 (we choose a dollar spread that places the delta
stock price at the center).
In[78]:=
priceEuroCall@40.50, 60., 0.29, 0.5, 0.04D -
priceEuroCall@39.50, 60., 0.29, 0.5, 0.04D
Out[78]=
0.0378454
You can get an intuitive feel for the behavior of options by creating a 3D plot of each
Greek with respect to stock price and time.
Note how delta increases sharply as the stock price approaches the strike and how
this sensitivity is stronger near expiration (t = 0).
In[79]:=
Plot3DAdeltaEuroCall@s, 60., 0.29, t1, 0.04D,
8s, 40., 80.<, 8t1, 0.001, 1<, ImageSize -> SmallE
Out[79]=
14.6 Black-Scholes for European Option Pricing | 569

The  sensitivity  of  the  delta  to  shrinking  time  to  maturity  and  strike  price  is  rein-
forced by the plot of the gamma, which is the second derivative of the price, or the
first derivative of the delta. 
In[80]:=
Plot3DAgammaEuroCall@s1, 60., 0.29, t1, 0.04D,
8s1, 40., 80.<, 8t1, 0.001, 1.<, ImageSize -> SmallE
Out[80]=
The plot of theta shows that the value of an option will decay more rapidly with ad-
verse moves of the underlying stock when there is a short time to expiration com-
pared to when there are longer times.
In[81]:=
Plot3DAthetaEuroCall@s1, 60, 0.29, t1, 0.04D,
8s1, 40, 80<, 8t1, 0.001, 1.<, ImageSize Ø SmallE
Out[81]=
570 | Chapter 14: Financial Engineering

In[82]:=
Plot3DArhoEuroCall@s1, 60., 0.29, t1, 0.04D,
8s1, 40, 80<, 8t1, 0.001, 1<, ImageSize Ø SmallE
Out[82]=
Note how sensitivity to volatility increases near the strike price and with increasing
time. This follows from the fact that high volatility has more impact over longer time
periods  and  for  options  that  are  in  the  money  (because  of  the  larger  delta  and
gamma of in-the-money options).
In[83]:=
Plot3DAvegaEuroCall@s1, 60, 0.29, t1, 0.04D,
8s1, 20, 100<, 8t1, 0.01, 0.5<, ImageSize Ø SmallE
Out[83]=
The interactive capabilities of Mathematica 6 provide an excellent platform for get-
ting the feel of the behavior of the Greeks. However, for sake of responsiveness, it is
a good idea to evaluate the derivative outside the Manipulate. You can use With to
evaluate the derivative before the call to Manipulate and FullSimplify to make sure it
is in simplest form. 
14.6 Black-Scholes for European Option Pricing | 571

In[84]:=
manipulateDeltaEuroCall@D := BlockA8k, v, t1, r<,
WithA9deltaCall = FullSimplify@D@priceEuroCall@s, k, v, t1, rD, sDD=,
ManipulateAPlot3D@Evaluate@deltaCallD, 8s, 40., 80.<, 8t1, 0.001, 1.<,
PerformanceGoal Ø "Speed"D, 88k, 60., "Strike"<, 10., 100.<,
88r, 0.04, "Rate"<, 0.01, 0.12<, 99v, 0.29, "Volatility"=, 0.01, 0.40=,
ContinuousAction Ø False, AppearanceElements Ø AllEEE
In[85]:=
manipulateDeltaEuroCall@D
Out[85]=
Strike
Rate
Volatility
-1.0
-0.5
0.0
0.5
1.0
-1.0
-0.5
0.0
0.5
1.0
0.0
0.5
1.0
See Also
Modeling  Financial  Derivatives  with  Mathematica  (Cambridge  University  Press)  by
William Shaw is an excellent resource for the quant interested in modeling vanilla
and more exotic flavors (such as Asian options) in Mathematica. It concentrates on
analytical solutions rather than solutions based on numerical methods.
Black-Scholes and Beyond: Option Pricing Models by Neil A. Chris (McGraw-Hill)
covers the basics of modern option pricing. Wikipedia also provides basic informa-
tion on the Black-Scholes model: http://bit.ly/c8IrYX.
572 | Chapter 14: Financial Engineering

14.7 Computing the Implied Volatility 
of Financial Derivatives
Problem
You want to compute the volatility of an option that is implied by its current market
price.
Solution
Use FindRoot to solve for the volatility.
In[86]:=
impliedVolEuroCallAprice_, strike_, maturityT_, rate_, optionsPrice_E :=
volatility ê.
FindRootApriceEuroCallAprice, strike, volatility, maturityT, rateE ã
optionsPrice, 9volatility, 0.2=E
In[87]:=
impliedVolEuroPutAprice_, strike_, maturityT_, rate_, optionsPrice_E :=
volatility ê.
FindRootApriceEuroPutAprice, strike, volatility, maturityT, rateE ã
optionsPrice, 9volatility, 0.2=E
In[88]:=
impliedVolEuroCall@58.00, 60., 0.5, 0.04, 3.8D
Out[88]=
0.254867
Discussion
Implied volatility is the volatility that is implied by the market price of the option
given the pricing model. The idea is that the market will find the fair price for the op-
tion, and from that, you can back out the volatility of the underlying security that
the market is pricing in. This is in contrast to historical volatility, which is a direct
measure of the movement of the underlying’s price over recent history. 
In the solution, FindRoot searches for a numerical root of the pricing function that
will yield the observed price, given the other option parameters. 
14.8 Speeding Up NDSolve When Solving Black-Scholes and Other PDEs | 573

14.8 Speeding Up NDSolve When Solving 
Black-Scholes and Other PDEs
Problem
You  want to compute numerical solutions to partial differential equations (PDEs),
such as the Black-Scholes PDE. NDSolve can sometimes take too much time or lose ac-
curacy near critical values. You would like to speed up NDSolve without loss of accu-
racy where it matters. 
-∂tu@x,tD==
1
2
s2x2∂x,xu@x,tD+r x ∂xu@x,tD-r u@x,tD;
Solution
This recipe was motivated by work done by Andreas Lauschke and used with
permission. Refer to the “See Also” section on page 578 for more information.
To illustrate the problem, I use the PDE for a European put on a dividend-paying
security. For the interest and dividend, I use fixed rate plus time-varying rate that is
strictly increasing. For volatility, I use a volatility smile, which reflects the observa-
tion  that  volatility  is  higher  for  in-  and  out-of-the-money  options  and  lower  for
at-the-money options. In the PDE, x represents the price of the underlying and t is time. 
In[89]:=
ClearAiRate, dividend, sigma, makePutEuropeanE;
iRate@t_D := 0.035 + t 0.01ê3
dividend@t_D := 0.01 + t 0.01ê3;
sigma@price_, strike_, time_D := 1.ê10 000 Hprice - strikeL^2 + 0.25
Options@makePutEuropeanD = 8Method Ø Automatic<;
makePutEuropean@strike_, lower_,
upper_, timeToExp_, opts : OptionsPattern@DD :=
ModuleA8<,
NDSolveA9D@u@x, tD, tD + 1ê2 D@u@x, tD, x, xD x^2 sigma@x, strike, tD^2 +
HiRate@tD - dividend@tDL x D@u@x, tD, xD - iRate@tD u@x, tD ã 0,
u@x, timeToExpD ã Max@0, strike - xD,
u@lower, tD ã strike,
u@upper, tD ã 0=, u, 8x, lower, upper<, 8t, 0, timeToExp<, optsEE
You can adjust different aspects of this model to suit your needs. The main point
here is to consider the performance of NDSolve using different options.
In[95]:=
Off@NDSolve::"mxsst"D
8timePut1, put1< = makePutEuropean@50, 0, 250, 1D êê Timing
Out[96]=
93.01551, 99u Ø InterpolatingFunction@880., 250.<, 80., 1.<<, <>D===
574 | Chapter 14: Financial Engineering

It took just over eight seconds to solve this PDE numerically. However, you can do
better  using  an  adaptive  grid  method  where  you  instruct  NDSolve  to  sample  more
points around the strike price while being looser away from the strike. Here I define
a function for the adaptive grid but defer explanation until the discussion.
In[97]:=
Clear@makeAdaptiveGrid, makePutEuropeanAdaptiveD
makeAdaptiveGridAstrike_, size_: 200, deg_: 1E :=
ModuleA9a = 2 deg + 1, incr = 2 strikeêsize=,
Table@HHx - strikeL^aêstrike^Ha - 1LL + strike, 8x, 0, strike*2, incr<DE
In[99]:=
makePutEuropeanAdaptive@strike_, lower_, upper_, timeToExp_D :=
ModuleA8<,
NDSolveA9D@u@x, tD, tD + 1ê2 D@u@x, tD, x, xD x^2 sigma@x, strike, tD^2 +
HiRate@tD - dividend@tDL x D@u@x, tD, xD == iRate@tD u@x, tD,
u@x, timeToExpD ã Max@0, strike - xD,
u@lower, tD ã strike,
u@upper, tD ã 0=, u, 8x, lower, upper<,
8t, 0, timeToExp<, Method ß 9"MethodOfLines",
"SpatialDiscretization" Ø 9"TensorProductGrid", "Coordinates" Ø Nü
UnionAmakeAdaptiveGrid@strikeD, Range@2 strike, 5 strike, 2DE==EE
In[100]:=
Off@NDSolve : : "eerri", NDSolve::"eerr"D
8timePut2, put2< = makePutEuropeanAdaptive@50, 0, 250, 1D êê Timing
Out[101]=
90.129383, 99u Ø InterpolatingFunction@880., 250.<, 80., 1.<<, <>D===
You can see the speedup is quite substantial. 
In[102]:=
timePut1êtimePut2
Out[102]=
23.3068
Discussion
You can see that the result of pricing the option appears the same for both versions.
In[103]:=
GraphicsColumnA9Plot3DAEvaluate@u@x, 1 - tD ê. Firstüput1D, 8x, 40, 60<,
8t, 0, 1<, PlotRange Ø All, ImageSize Ø 8300, 300<, AxesLabel Ø
9"Underlying Price", "Time to\nExpiration", "Option\nPrice"=E,
Plot3DAEvaluate@u@x, 1 - tD ê. Firstüput2D, 8x, 40, 60<, 8t, 0, 1<,
PlotRange Ø All, ImageSize Ø 8300, 300<, AxesLabel Ø 9"Underlying Price",
"Time to\nExpiration", "Option\nPrice"=E=, Spacings Ø 0E
14.8 Speeding Up NDSolve When Solving Black-Scholes and Other PDEs | 575

Out[103]=
And, indeed, you can see that the max difference in both approaches is negligible.
In[104]:=
Maxü
FlattenüAbs@Table@Hu@x, tD ê. Firstüput1L, 8x, 40, 60<, 8t, 0, 1, 0.01<D -
Table@Hu@x, tD ê. Firstüput2L, 8x, 40, 60<, 8t, 0, 1, 0.01<DD
Out[104]=
0.0000251351
576 | Chapter 14: Financial Engineering

A few words about the function makeAdaptiveGrid are in order. The motivation for
this function can be seen considering the plot of  x^3.
In[105]:=
PlotAx^3, 8x, -3, 3<, ImageSize Ø SmallE
Out[105]=
-3
-2
-1
1
2
3
-20
-10
10
20
The slope about the origin is small compared to the slope at the extremes. This is per-
fect for our application because it means that simply shifting the origin to the strike
will give a function that generates a dense grid around the strike and a looser one at
the  wings  of  the  option  (away  from  the  strike).  The  two  optional  parameters  of
makeAdaptiveGrid  control  the  number  of  grid  points  (size)  generated  and  the
extent of the density around the slope (deg).
In[106]:=
NeedsA"PlotLegends`"E
WithA8strike = 50<,
ListLinePlotA8makeAdaptiveGrid@strike, 200, 1D,
makeAdaptiveGrid@strike, 200, 2D<, DataRange Ø 80, 2 strike<,
PlotStyle Ø 8Thin, Dashed<, PlotLegend Ø 9"deg = 1", "deg = 2"=,
LegendPosition Ø 8-0.75, 0.25<, LegendSize Ø 0.5EE
Out[107]=
20
40
60
80
100
20
40
60
80
100
deg = 2
deg = 1
14.8 Speeding Up NDSolve When Solving Black-Scholes and Other PDEs | 577

In the NDSolve options, I use MethodOfLines, which is a very efficient way to numerically
solve a PDE provided it is an initial value problem. In particular, the solution uses
the  suboption  "SpatialDiscretization",  which  itself  allows  the  coordinates  to  be
passed  in.  Here  the  expression  N@Union[makeAdaptiveGrid[strike],  Range[2  strike,
5 strike, 2]] simply tacks on some coarsely spaced points far from the strike so we
can ensure the solution is valid for a reasonably liberal range of prices on the high
end.  Refer  to  the  references  in  the  following  “See  Also”  section  for  more  details
about MethodOfLines, which is quite feature rich and worth learning if you plan to
use NDSolve.
See Also
This  recipe  was  motivated  by  the  notebook  penalty.nb  developed  by  Andreas
Lauschke. The original notebook is available in the downloads section of this book’s
website: http://bit.ly/xIgx7. Also see Lauschke’s site at http://bit.ly/1Zhdfv for useful
Mathematica and web Mathematica samples, products, and services.
NDSolve was introduced in Recipe 13.9.
The  MethodOfLines  can  be  found  in  tutorial/NDSolvePDE  in  the  Mathematica
documentation.
14.9 Developing an Explicit Finite Difference 
Method for the Black-Scholes Formula 
Problem
You  want  to  use  the  finite  difference  method  (FDM)  to  compute  solutions  to  the
Black-Scholes formula in an efficient manner.
Solution
This solution was developed by Thomas Weber and rearranged to conform to the for-
mat of this book. Refer to the “See Also” section on page 582 for references to the
original notebook.
In this solution we will price a European call option with the following attributes:
In[108]:=
strike = 100.; H*strike price at maturity of the option*L
sigma = 0.2;
H*volatility of the prices of the underlying*L
tau = 1.0;
H*time to maturity of the option*L
rate
= 0.05 ; H*riskless interest rate*L
578 | Chapter 14: Financial Engineering

The presented calculation scheme is a version of the explicit finite difference method
(FDM).  While  applying  this  calculation  scheme,  the  new  values  for  the  derivative
Vj,i-1 are stepwise calculated from Vj+1,i, Vj,i, and Vj-1,i. The concepts are elabo-
rated in the “Discussion” section on page 580. 
In this solution, the number of grid points for the discrete prices of the stock n can
freely  be  chosen  within  a  specific  range.  Increasing  the  number  of  time  steps  im-
proves the accuracy but also increases the overall calculation time. For a first demon-
stration, the number of discrete stock prices is set to 20.
In[112]:=
n = 20;
The grid points for the stock price should be placed in a range not too tight around
the current stock price. In this example, the range is chosen from zero up to twice
the strike price. From the chosen region results the step size DS for the discretization
of  the  stock  prices  range.  One  way  to  generate  the  list  of  grid  points  is  to  use
NestList. #+DS& within NestList is a generic function defined for local use.
On the list of discrete stock prices, the exercise function of the option can be ap-
plied.  The  resulting  list  provides  the  starting  or  initial  values  for  the  numerical
method.
In[113]:=
dS = H2*strikeLên;
S = NestList@Ò1 + dS & , 0, nD;
V = HMax@Ò1 - strike, 0D & L êü S;
The necessary number of time steps for the explicit FDM to converge depends on
the  step  size  for  the  discretization  of  the  stock  price,  the  volatility,  and  the  strike
price. The number of time steps can be calculated as follows (for more information,
see the Wilmott reference in the “See Also” section on page 582):
In[116]:=
nt = Floor@têHdSêH2*X*sLL^2D + 1;
Then the size of the time steps are
In[117]:=
dt =
t
nt
;
In pricingFunc, two terms G and D (see the “Discussion” section on page 580) are
the speed-critical computations since they are inside the Do loop. The Mathematica
function ListConvolve is used because it is a very fast way to compute finite differ-
ences. After the Do loop is finished, V contains a list of option values. Each option
value corresponds to a discrete stock price on the grid. Interpolation on these num-
bers produces an interpolating function for the option price given current price of the
underlying S0.
14.9 Developing an Explicit Finite Difference Method for the Black-Scholes Formula | 579

In[118]:=
pricingFunc@X_, r_, t_, s_, n_D :=
Module@8D, G, s, v, V, S, dS<, dS = H2*XLên;
S = NestList@Ò1 + dS & , 0, nD;
V = HMax@Ò1 - X, 0D & L êü S;
Do@D = ListConvolve@81, 0, -1<, VDêH2*dSL;
G = ListConvolve@81, -2, 1<, VDêdS^2;
s = Take@S, 82, -2<D;
v = Take@V, 82, -2<D;
V = Join@80<, v + dt*HH1ê2L*s ^2*s^2*G + r*s*D - r*vL,
8Last@SD - XêE^Hr*i*dtL<D, 8i, nt<
D;
Interpolation@Transpose@8S, V<DDD
In[119]:=
pf = pricingFunc@V, S, X, r, dS, dt, s, ntD;
S0 = 100.; H*price of the stock at valuation time*L
pf@S0D
Out[121]=
pricingFuncC80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0., 10., 20., 30., 40., 50., 60.,
70., 80., 90., 100.<, 80, 10., 20., 30., 40., 50., 60., 70., 80., 90.,
100., 110., 120., 130., 140., 150., 160., 170., 180., 190., 200.<, X,
r, 10.,
t
1 + FloorA0.04 X2 s2 tE
, s, 1 + FloorA0.04 X2 s2 tEG@100.D
Discussion
The PDE from the Black-Scholes formula for a derivative V on the security S is given as:
In[122]:=
Clear@S, dS, t, dt, s, r, VD;
pde = -D@V@S, tD, tD ==
H1ê2L*s^2*S^2*D@V@S, tD, S, SD + r*S*D@V@S, tD, SD - r*V@S, tD;
Numerical  approximation  for  the  partial  derivative  follows,  for  example  from  the
Taylor series. The partial derivatives in the equation are replaced through the appro-
priate Taylor series.
In[124]:=
rls = 8D@V@S, tD, tD -> HV@S, t - dtD - V@S, tDLêdt,
D@V@S, tD, SD -> HV@S + dS, tD - V@S - dS, tDLêH2*dSL,
D@V@S, tD, S, SD ->
HV@S + dS, tD - 2*V@S, tD + V@S - dS, tDLêdS^2<;
prox = pde ê. rls
Out[125]=
-
-V@S, tD + V@S, t - dtD
dt
ã -r V@S, tD +
r S H-V@S - dS, tD + V@S + dS, tDL
2 dS
+
S2 s2 H-2 V@S, tD + V@S - dS, tD + V@S + dS, tDL
2 dS2
580 | Chapter 14: Financial Engineering

In  the  next  step,  the  notation  is  changed  to  make  it  more  consistent  with  a  grid
scheme.
In[126]:=
prox = prox ê. 9V@S, tD Ø Vj,i,
V@S, t - dtD Ø Vj,i-1, V@S + dS, tD Ø Vj+1,i, V@S - dS, tD Ø Vj-1,i=
Out[126]=
-
Vj,-1+i - Vj,i
dt
ã -r Vj,i +
r S I-V-1+j,i + V1+j,iM
2 dS
+
S2 s2 IV-1+j,i - 2 Vj,i + V1+j,iM
2 dS2
To better illustrate the structure of the equation, more notational adjustments are
made. The new structure will later help to simplify the calculations.
In[127]:=
prox = prox ê. ;
Vj+1,i - 2 Vj,i + Vj-1,i
dS2
Ø Gi,j,
Vj+1,i - Vj-1,i
2 dS
Ø Di,j?
Out[127]=
-
Vj,-1+i - Vj,i
dt
ã -r Vj,i +
1
2
S2 s2 Gi,j + r S Di,j
Solving the last expression for Vj,i and simplifying leads to
In[128]:=
diff = SolveAprox, Vj,i-1E êê Simplify êê First;
diff êê TraditionalForm
Out[129]//TraditionalForm=
:Vj,i-1 Ø Hr dt + 1L Vj,i -
1
2
S dt I2 r Di,j + S s2 Gi,jM>
The presented calculation scheme is a version of the explicit FDM. While applying
this  calculation  scheme,  the  new  values  for  the  derivative  Vj,i-1  are  stepwise
calculated from Vj+1,i, Vj,i, and Vj-1,i. Figure 14-1 illustrates this approach.
Vj
i-1
Vj+1
i
Vj
i
Vj-1
i
DS
Dt
Sj
ti
Figure 14-1. Explicit FDM
14.9 Developing an Explicit Finite Difference Method for the Black-Scholes Formula | 581

An efficient Mathematica function for the calculation of the differences needed in D
and  G  is  available  through  ListConvolve.  To  demonstrate  this,  ListConvolve  is
applied to a list of symbols.
In[130]:=
Clear@V, dSD;
v = TableAVj, 9j, 6=E
Out[131]=
8V1, V2, V3, V4, V5, V6<
ListConvolve used for D results in the following expression.
In[132]:=
D = ListConvolve@81, 0, -1<, vDêH2 dSL êê TraditionalForm
Out[132]//TraditionalForm=
:
V3 - V1
2 dS
,
V4 - V2
2 dS
,
V5 - V3
2 dS
,
V6 - V4
2 dS
>
The first list in ListConvolve, the kernel {1,0,1}, is applied piecewise to the second
list, multiplies the elements of the second list, and adds them up according to the val-
ues given in the kernel. This operation runs internally in Mathematica and is much
faster than any loop written in Mathematica code.
The approach used for D can also be applied for the calculation of G. ListConvolve
can replace loops that are common to the explicit approximation of PDEs.
In[133]:=
G = ListConvolve@81, -2, 1<, vD ê HdS ^ 2L êê TraditionalForm
Out[133]//TraditionalForm=
:
V1 - 2 V2 + V3
dS2
,
V2 - 2 V3 + V4
dS2
,
V3 - 2 V4 + V5
dS2
,
V4 - 2 V5 + V6
dS2
>
See Also
Derivatives: The Theory and Practice of Financial Engineering (Wiley) by P. Wilmott
contains the technical background underlying this recipe.
This recipes was derived from work done by Thomas Weber of Weber & Partner.
The original notebook and other interesting financial applications in Mathematica
can be found at http://bit.ly/bR0bF.
The method used in this recipe is based on the explicit FDM. There are also implicit
methods. See Wikipedia for a general explanation of the difference and the trade-
offs (http://bit.ly/tr3IN).
582 | Chapter 14: Financial Engineering

14.10 Compiling an Implementation of Explicit 
Trinomial for Fast Pricing of American Options
Problem
You need a very fast pricer for American options. You want to make sure the imple-
mentation can be compiled for fastest possible execution without any calls to non-
compiled code.
Solution
This  solution  was  contributed  by  Andreas  Lauschke.  See  Recipe  14.8  for  more
information.
Mathematica has a built-in compiler that creates optimized code for a Mathematica-
specific virtual machine. Compile is discussed fully in Recipe 18.5. Here we simply
show  an  application  that  creates  a  pricer  for  American  options  using  trinomial
scheme (see discussion). 
In[134]:=
americanPutCompiled = CompileA9kk, r, sigma, tt=,
WithA9a = 5, nn = 100, mm = 20, tt0 = sigma^2 ttê2, k = 2 rë sigma^2=,
ModuleA8alpha, h = 2 aênn, s = tt0êmm, x, ss, tmax, f, pp0, u, z<,
alpha = sêh^2;
x = Range@-a, a, hD;
ss = kk Expüx;
tmax = MapThread@Max, 8Table@0, 8nn + 1<D, 1 - Expüx<D;
f =
Exp@1ê2 Hk - 1L x + 1ê4 Hk + 1L^2 HÒ - 1L sD tmax & êü Range@mm + 1D;
pp0 = Max@0, kk - ÒD & êü ss;
u = Exp@1ê2 Hk - 1L xD pp0êkk;
DoAz = alpha HTake@u, 83, nn + 1<D + Take@u, 81, nn - 1<DL -
H2 alpha - 1L Take@u, 82, nn<D;
z = AppendAPrependAz, alpha u@@2DD - H2 alpha - 1L u@@1DD +
alphaêkk ExpA1ê2 Hk - 1L a + 1ê4 Hk + 1L^2 Ij - 1M sEE, 0E;
u = MapThreadAMax, 9z, fAAjEE=E;, 9j, mm=E;
8ss, kk Exp@-1ê4 Hk + 1L^2 tt0D Exp@-1ê2 Hk - 1L xD u<EEE;
You  can  see  that  10  runs  of  the  pricer  over  various  strike  prices  execute  in  32
milliseconds.
14.10 Compiling an Implementation of Explicit Trinomial for Fast Pricing of American Options | 583

In[135]:=
9time, pricing= = Timing@
Table@Take@TransposeüamericanPutCompiled@strike, 0.05, 0.4, 1D, 60D,
8strike, 50, 100, 5<DD;
ListLinePlotApricing, PlotLabel Ø ToString@time*10^3D <> " millisecs"E
Out[136]=
50
100
150
20
40
60
80
100
18.485 millisecs
Discussion
The function americanPutCompiled returns a packed array of two lists: the first is a
list of nodes in the spatial (stock price) direction, and the second is a list of Ameri-
can option prices at these nodes. The two lists can now be interpolated with Mathe-
matica’s Interpolation function to obtain intermediate values.
The  function  americanPutCompiled  is  fully  compiled,  as  can  be  seen  by  inspecting
americanPutCompiled[[4]] and noting that all list elements are numeric. 
In[137]:=
DeleteCases@Flatten@americanPutCompiled@@4DDD, _?NumericQD
Out[137]=
8<
The algorithm implements a method to price American options based on the linear
complementarity formulation of the free boundary value problem. The numbers a,
nn, T0, and mm (and, correspondingly, s and h) are parameters that define the grid to
be used. a and nn determine the grid along the space (stock price) axis, and T0 and mm
determine the grid along the time axis. For explicit methods, it is crucial to keep the
spatial and temporal spacing in certain limits, otherwise local blow-up will occur.
For a 100% explicit method, it is necessary that alpha=s/h^2<=1/2. That means that
if the spatial step size h is reduced by a factor of 10, the time step size s has to be re-
duced by a factor of 100. This is not due to reasons of precision, but due to reasons
of stability. If, for example, mm is lowered to 15, alpha is no longer <=1/2, and the in-
stability becomes quite visible. For numbers like 5 or 10 for mm, the method wreaks
584 | Chapter 14: Financial Engineering

havoc. Traditional American option pricing methods use binomial trees and exhibit
this problem with what is called oscillations. (All tree methods are necessarily 100%
explicit.) It’s the same stability problem that is inherent to all explicit methods.
What makes this rectangular grid method so powerful is the fact that although it is
faster than most tree-based implementations, it computes the option prices for the
whole interval, not just for one particular price of the underlying, which is a limita-
tion all tree-based methods possess.
See Also
Recipe 18.5 explains the mechanics of compiled functions and the performance impli-
cations of functions that don’t fully compile.
See Ansgar Jüngel, “Modellierung und Numerik von Finanzderivaten,” Vorlesungs-
manuskript 2002, Johannes-Gutenberg Universität Mainz.
14.11 Modeling the Value-at-Risk of a Portfolio 
Using Monte Carlo and Other Methods
Problem
You want to understand the worst expected loss of a portfolio of securities. This is re-
ferred to as Value-at-Risk or VaR. Specifically, you want to use Monte Carlo meth-
ods because these allow you to trade accuracy for speed by varying the number of
samples. 
Since the financial disaster that began in 2007, the notion of Value-at-
Risk  has  become  quite  controversial.  Some,  like  Nassim  Taleb,  have
called it an intellectual fraud, while others have called it an invaluable
tool,  if  used properly. I include this recipe as an illustration of the math
behind one particular implementation of VaR and without judgment as to its
effectiveness. Please refer to the link in the “See Also” section on page
587 for a thorough discussion of the efficacy of VaR in practice.
Solution
In its simplest form, VaR is a measure of the worst expected loss under normal mar-
ket  conditions  over  some  time  interval,  usually  days  or  weeks.  The  simplest  (and
highly artificial) illustration of VaR concerns a portfolio consisting of a single secu-
rity. Let’s assume it is worth $10 million, the average return is 0.085, and the stan-
dard deviation is 0.26. The distribution of the portfolio’s value is
14.11 Modeling the Value-at-Risk of Portfolio Using Monte Carlo and Other Methods | 585

In[138]:=
With@8portfolio = 10^7, return = 0.085, stddev = 0.26<,
Plot@PDF@NormalDistribution@portfolio * H1.0 + returnL,
portfolio *stddev D, xD, 8x, 0, 2 portfolio<DD
Out[138]=
5.0µ106
1.0µ107
1.5µ107
2.0µ107
2.µ10-8
4.µ10-8
6.µ10-8
8.µ10-8
1.µ10-7
1.2µ10-7
1.4µ10-7
From this we can compute the probability of a loss of 25% using the CDF.
In[139]:=
With@8portfolio = 10000000, return = 0.085, stddev = 0.26, loss = 0.25<,
CDF@NormalDistribution@portfolio * H1.0 + returnL, portfolio *stddev D,
portfolio H1 - lossLDD
Out[139]=
0.0987927
VaR is computed in terms of worst expected loss in dollars at a certain probability
level, say 1%.  
In[140]:=
valueAtRiskAstartingValue_, meanReturn_, var_, level_E :=
ModuleA9expected = startingValue* H1 + meanReturnL=,
startingValue -
QuantileANormalDistributionAexpected, startingValue*varE, levelEE
In[141]:=
With@8portfolio = 10000000,
meadReturn = 0.085, stddev = 0.26, loss = 0.25<,
valueAtRisk@portfolio, meadReturn, stddev, 0.01DD
Out[141]=
5.1985µ106
Thus the VaR at 1% is about 5.2 million.
586 | Chapter 14: Financial Engineering

Discussion
The  solution  merely  shows  the  statistical  ideas  behind  VaR.  In  real-life  scenarios,
portfolios are more complexly structured, and you need to measure and account for
correlations  in  the  movements  of  these  assets’  values.  The  rest  of  this  discussion
deals with these issues.
The first issue to address is that prices don’t typically follow a NormalDistribution
but rather a LogNormal one. Second, portfolio managers and traders are typically inter-
ested in VaR over much shorter time periods than one year. So a more useful func-
tion is
In[142]:=
Clear@valueAtRiskD
valueAtRiskAstartingValue_, mean_,
var_, level_, days_, tradingDays_: 365E :=
ModuleA9T = daysë tradingDays=,
startingValue - ExpAQuantileANormalDistributionA
LogüstartingValue + Hmean - var^2ê2L*T, var*TE, levelEE
E
Here we compute the VaR assuming 250 trading days.
In[144]:=
WithA9portfolio = 10000000,
return = 0.085, stddev = 0.26, loss = 0.25, days = 1=,
valueAtRiskAportfolio, return, stddev, 0.01, days, 250EE
Out[144]=
22121.5
See Also
An  extensive  discussion  of  VaR  in  light  of  the  financial  crisis  of  2007|2009  (and
counting)  can  be  found  in  this  excellent  New  York  Times  article  by  Joe  Nocera:
http://bit.ly/2SgV68.
14.12 Visualizing Trees for Interest-Rate 
Sensitive Instruments
Problem
You are using a tree-based approach to pricing (such as the Hull-White trees) and
you want to visualize these trees using Mathematica’s graphics abilities. Such visual-
izations are often useful for pedagogical or diagnostic purposes.
14.11 Modeling the Value-at-Risk of Portfolio Using Monte Carlo and Other Methods | 587

Solution
In  this  recipe,  I  am  only  concerned  with  using  Mathematica  for  visualizing  Hull-
White trees. See the “See Also” section on page 591 for the theory and Mathematica
implementation of the same for pricing purposes.
The  usual  way  to  implement  tree  valuation  methods  is  to  state  results  in  two  or
more new states, thereby modeling the diffusion of the stochastic process. The idea
of Hull-White to model mean reverting processes is to add boundary conditions to
this tree structure. The boundary conditions are valid for a given maximum state. 
The graphical building blocks of the tree can then be defined as follows. The vari-
able nmax is global. There are three primitive elements: a nonboundary element, an
upper-boundary element, and a lower-boundary element. The function path returns
a triple that defines the terminal points of the path.  
In[145]:=
pathAj_E := j + 81, 0, -1<
pathAj_ ê; j == nmaxE := j - 80, 1, 2<
pathAj_ ê; j ã -nmaxE := j + 80, 1, 2<
The function grpath then constructs the graphical representation in terms of Line ele-
ments emanating from a starting point.
In[148]:=
grpathApt : 9i_, j_=E := Line@8pt, 8i + 1, Ò<<D & êü pathAjE
Here then are the three primitive components used to build the tree.
In[149]:=
BlockA8nmax = 2<,
GraphicsGridA99GraphicsAgrpath@80, 1<D, PlotLabel Ø "Unbounded"E,
GraphicsAgrpath@80, nmax<D, PlotLabel Ø "Upper Boundary"E,
GraphicsAgrpath@80, -nmax<D, PlotLabel Ø "Lower Boundary"E==,
AspectRatio Ø 0.3E ê. Line Ø ArrowE
Out[149]=
Unbounded
Upper Boundary
Lower Boundary
Given these primitives, it’s a straightforward process to generate a tree with a particu-
lar boundary and depth.
588 | Chapter 14: Financial Engineering

In[150]:=
BlockA8nmax = 4, depth = 10<,
ModuleA8n<,
n@m_D := Min@nmax, mD;
GraphicsATableAgrpathA9m, j=E,
8m, 0, depth - 1<, 9j, -n@mD, n@mD=E, Axes -> TrueEEE
Out[150]=
2
4
6
8
10
-4
-2
2
4
Discussion
The solution is really just a skeleton to illustrate the general technique. For purposes
of visualization, we need trees with labels that suggest the underlying semantics of
Hull-White.  A  particularly  nice  way  to  proceed  is  to  augment  the  tree  with  node
labels that are purely coordinates. This is just a matter of adding text elements to the
solution version. The resulting gr becomes a template, and you can leverage Mathe-
matica’s pattern-directed replacement to assign meaningful labels to the nodes.
In[151]:=
gr = BlockA8nmax = 2, depth = 3<,
ModuleA8n <,
n@m_D := Min@nmax, mD;
FlattenATableA9IfAm < depth, grpathA9m, j=E, 8<E,
TextA9m, j=, 9m, j=, Background Ø WhiteE=,
8m, 0, depth<, 9j, -n@mD, n@mD=EE
EE;
14.12 Visualizing Trees for Interest-Rate Sensitive Instruments | 589

In[152]:=
GraphicsAgr, AspectRatio Ø 1êGoldenRatioE
Out[152]=
80, 0<
81, -1<
81, 0<
81, 1<
82, -2<
82, -1<
82, 0<
82, 1<
82, 2<
83, -2<
83, -1<
83, 0<
83, 1<
83, 2<
The process you want to visualize is a single-factor interest rate model described by
the following formula:
dr = HqHtL - a rt L dt + s dz.
Here r is the short-term rate, and a and s are constants. 
In[153]:=
a = 0.1;
s = 0.01;
Dt = 1;
Dr = s*Sqrt@3*DtD;
Using the template gr, replace the nodes with the rate deltas using the node coordi-
nates in the computation of the labels. Here you use depth Infinity with Replace so
you need not worry about the actual depth of the graphics elements.
In[157]:=
GraphicsAReplaceAgr, 99x_Integer, y_Integer= :> 9x, y Dr=,
TextA9m_, j_=, y___E :> TextAj 100 , yE=, InfinityE,
AspectRatio Ø 1êGoldenRatioE
Out[157]=
0
-1.73205
0
1.73205
-3.4641
-1.73205
0
1.73205
3.4641
-3.4641
-1.73205
0
1.73205
3.4641
590 | Chapter 14: Financial Engineering

See Also
This  recipe  contains  content  originally  developed  by  Thomas  Weber  of  Weber  &
Partner  (http://bit.ly/3Dz1wg)  and  is  used  with  permission.  A  complete  notebook
showing both the theory and visualization is available at this cookbook’s website:
http://bit.ly/xIgx7. 
14.12 Visualizing Trees for Interest-Rate Sensitive Instruments | 591


CHAPTER 15
Interactivity
I’m alive
Oh oh, so alive
I’m alive
Oh oh, so alive
...
My head is full of magic, baby
And I can share this with you
The feel I’m on top again, baby
That’s got everything to do with you 
Love and Rockets, “So Alive”
15.0 Introduction
The pièce de résistance of Mathematica 6 is its dynamic interactivity features. These
features forced Wolfram to completely rethink and redesign its frontend. This had
the unfortunate consequence of breaking many notebooks from version 5 and ear-
lier, especially those that used graphics. However, it is my opinion that the gain was
well worth the pain!
The interactive features of Mathematica 6 are even more impressive when one consid-
ers that they sit on relatively few new functions. The centerpiece of interactivity is
the function Manipulate. Think of Manipulate as a very intelligent user-interface genera-
tor. Manipulate’s power comes by virtue of its ability to take any Mathematica ex-
pression plus a declarative description of the expression’s variables and generate a
mini  embedded  GUI  within  the  notebook  for  interacting  with  that  expression.  Of
course, there are always caveats, and an important feature of this chapter is to help
you get the best possible results with nontrivial Manipulate use cases.
The first five recipes of this chapter are intended to gradually introduce the reader to
Manipulate by demonstrating increasingly sophisticated examples. These recipes are
not necessarily intended for direct use but rather to illustrate the basic features and
generality of Manipulate. Each recipe highlights a feature of Manipulate or a subtlety
593

of its use in a particular context. Animate is a relative of Manipulate that puts its interac-
tive features in autonomous mode. Recipe 15.15 focuses on Animate and shows how
animations can be exported to Flash and other Web-friendly formats.
Many users will never need anything beyond Manipulate, but more advanced applica-
tions require you to dig deeper and understand lower-level dynamic primitive func-
tions called Dynamic, DynamicModule, and DynamicWrapper. Recipe 15.4 shows how Dy-
namic  is  used  in  conjunction  with  Manipulate  to  achieve  better  performance  or
smoother operation. DynamicModule is a preferred alternative to Module when working
with dynamic content, and I use it liberally before introducing it formally. The initial
usage does not require you to know more than its function as a scoping construct.
Recipe 15.11 illustrates the intimate relationship between Manipulate and Dynamic-
Module and shows why you often want to use DynamicModule directly. Many useful dy-
namic techniques require the use of DynamicWrapper but, unfortunately (as of version
7),  this  important  function  is  undocumented  in  the  help  system.  Recipes  15.8,
15.11, and 15.16 show some interesting use cases for this hidden gem.
You  will  get  the  most  out  of  this  chapter  by  downloading  its
associated  notebook  from  the  book’s  website  and  playing  along;  see
http://oreilly.com/catalog/9780596520991. 
15.1 Manipulating a Variable
Problem
You want to control the value of one or more variables via an interactive interface
and see their values update as you interact with the interface.
Solution
Use Manipulate with the desired variables and (optionally) their ranges.
In[1]:=
Manipulate@a, 8a, 1, 10<D
Out[1]=
a
1
594 | Chapter 15: Interactivity

In[2]:=
ManipulateA8a, b, c, d, pt<,
8a, 1, 10<,
H*a varies from 1 - 10.*L
8b, 1, 10, 1<, H*b varies from 1 - 10 in steps of 1.*L
88c, 5<, 1, 10<, H*c varies 1 - 10. Initial value 5*L
8d<, H*d can have any value.*L
8pt, 81, 1<, 810, 10<<, H*Creates a 2D slider*L
99d, 7, "d again"=, 81, 3, 5, 7, 9<= H*Creates buttons*L
E
Out[2]=
a
b
c
d
7
pt
d again
1
3
5
7
9
81, 1, 5, 7, 81, 1<<
Discussion
This solution is strictly intended as a simple introduction to Manipulate. As it stands,
it is not very practical because the variables are displayed rather than used to com-
pute. Still, there are some important concepts. 
The first concept is that Manipulate will automatically choose a control type based
on the structure of the constraints you place on a variable’s value. The most com-
mon control is a slider. It is chosen when a variable is specified with a minimum and
15.1 Manipulating a Variable | 595

maximum value. Out[3] below shows three variations of this idea. The second exam-
ple uses a specified increment, and the third adds an initial value.
In[3]:=
Column@8Manipulate@a, 8a, -10, 10<D, Manipulate@b, 8b, -10, 10, 0.1<D,
Manipulate@c, 88c, 0<, -10, 10, 0.1<D<, Spacer@2DD
Out[3]=
a
-10
b
-10
c
0
When a multiple-choice list is specified, you will get either a series of buttons or a
drop-down list, depending on the number of choices.
In[4]:=
Row@8Manipulate@a, 8a, 80, 1, 2, 3<<D,
Manipulate@b, 8b, Table@i, 8i, 10<D<D<, Spacer@5DD
Out[4]=
a
0
1
2
3
0
b
1
1
When a variable is unconstrained or just specified with an initial value, Manipulate
infers an edit control. In the first case, the variable begins with a null value, so it is
probably a good idea to provide an initial value.
596 | Chapter 15: Interactivity

In[5]:=
Row@8Manipulate@a, 8a<D, Manipulate@b, 8b, 3.3<D<, Spacer@2DD
Out[5]=
a
Null
b
3.3
3.3
A second concept, illustrated in Out[6], is that a single variable can be bound to mul-
tiple controls. This has the effect of tying the controls together so a change in one
control  changes  the  variable  and  is  automatically  reflected  in  the  other  controls
bound to that variable. It’s possible in this circumstance to violate the constraints of
one of the controls. In this case, Manipulate will display a red area in the control that
has the violated constraint.
In[6]:=
Manipulate@a, 8a, -10, 10<, 8a, -20, 20<D
Out[6]=
a
a
-20
A third concept is the ability to provide an arbitrary label by specifying the label af-
ter the initial value. The label can be any Mathematica expression.
In[7]:=
ColumnA9Manipulate@Sin@N@aDD, 88a, -10, Sin@aD<, -10, 10<D, ManipulateAa,
99a, -10, RasterizeATextAStyle@"a", Blue, Italic, Bold, 20DEE=,
-10, 10=E=, Spacer@2DE
Out[7]=
Sin@aD
0.544021
-10
15.1 Manipulating a Variable | 597

15.2 Manipulating a Symbolic Expression
Problem
You want to vary the structure of a symbolic expression interactively.
Solution
This  recipe  is  intended  to  illustrate  that  any  Mathematica  expression  that  can  be
parametrized can be used with Manipulate. 
In[8]:=
Clear@xD;
GridAPartitionATableAManipulateAExpand@Hx + 1L^rD, 88r, init<, 0, 30, 1<,
FrameMargins Ø 0, ImageMargins Ø 0, ContentSize Ø 8250, 75<E,
8init, 81, 2, 10, 15<<E, 2E, Spacings Ø 0.5, Alignment Ø LeftE
Out[8]=
r
1 + x
r
1 + 2 x + x2
r
1 + 10 x + 45 x2 + 120 x3 + 210 x4 +
252 x5 + 210 x6 + 120 x7 + 45 x8 + 10 x9 + x10
r
1 + 15 x + 105 x2 + 455 x3 + 1365 x4 + 3003 x5 + 5005 x6 + 6435 x7 +
6435 x8 + 5005 x9 + 3003 x10 + 1365 x11 + 455 x12 + 105 x13 + 15 x14 + x15
Discussion
Here are a few examples to reinforce the idea that any aspect of an expression can be
manipulated. In Out[9] on page 599, both of the function’s integration limits are vari-
able. In Out[10] on page 599, every aspect of the expression, including its display
form, is subject to user manipulation. Finally, in  Out[11]  on  page  600,  you  see
that tables of values can be dynamically generated and that Manipulate will adjust
the display area to accommodate the additional rows. The ability of Manipulate to
mostly do the right thing is immensely liberating: it allows you to focus on the con-
cept you are illustrating rather than the GUI programming. 
598 | Chapter 15: Interactivity

In[9]:=
ModuleC8x<, ManipulateC‡
a
b
Ig@fD@xDM „x, 88a, 0<, 0., 10<, 88b, 10<, 0., 10<,
9f, 9Identity, Sin, Cos, Exp, Sqrt==, 9g, 9Identity, InverseFunction==GG
Out[9]=
a
b
f
Identity
Sin
Cos
Exp
Sqrt
g
Identity
InverseFunction
50
In[10]:=
ManipulateCfC
a b
c d
G êê form, 88f, Inverse<, 8Det, Transpose, Inverse<<,
88a, x^2<, 80, 1, x, x^2<<, 88b, x<, 80, 1, x, x^2<<,
88c, I<, 80, 1, -1, I, x, Sqrt@xD<<, 88d, x<, 8-1, 0, 1, x<<,
8form, 8MatrixForm, StandardForm, TraditionalForm, InputForm<<,
BaseStyle Ø 9Large=G
Out[10]=
f
Det
Transpose
Inverse
a
0
1
x
x2
b
0
1
x
x2
c
Â
d
-1
0
1
x
form
MatrixForm
StandardForm
TraditionalForm
InputForm
x
-Â x+x3
-
x
-Â x+x3
-
Â
-Â x+x3
x2
-Â x+x3
15.2 Manipulating a Symbolic Expression | 599

In[11]:=
GridA99
ManipulateA
FramedATableFormA8Ò, N@f@ÒDD< & êü Table@i, 8i, 0, 2 Pi, incr<D,
TableSpacing Ø 81, 2<, TableHeadings Ø 8None, 8"x", f<<EE,
8incr, 1, 0.1, -0.1<, 88f, Sin<, 8Sin, Cos, Tan, Sec, Csc, Cot<<,
8incr<E, ManipulateA
FramedATableFormA8Ò, N@f@ÒDD< & êü Table@i, 8i, 0, 2 Pi, incr<D,
TableSpacing Ø 81, 2<, TableHeadings Ø 8None, 8"x", f<<EE,
88incr, 0.5<, 1, 0.1, -0.1<, 88f, Cos<, 8Sin, Cos, Tan, Sec, Csc, Cot<<,
8incr<E==, Alignment Ø Top, Spacings Ø 3E
Out[11]=
incr
f
Sin
incr
1
x
Sin
0
0.
1
0.841471
2
0.909297
3
0.14112
4
-0.756802
5
-0.958924
6
-0.279415
incr
f
Cos
incr
0.5
x
Cos
0.
1.
0.5
0.877583
1.
0.540302
1.5
0.0707372
2.
-0.416147
2.5
-0.801144
3.
-0.989992
3.5
-0.936457
4.
-0.653644
4.5
-0.210796
5.
0.283662
5.5
0.70867
6.
0.96017
15.3 Manipulating a Plot
Problem
You want to create an interactive graph.
Solution
Possibly one of the most popular use cases for Manipulate is to create an interactive
plot.  However,  a  common  stumbling  block  is  forgetting  to  specify  the  PlotRange,
causing a plot for which the axes vary instead of the plot itself varying. 
600 | Chapter 15: Interactivity

In[12]:=
ManipulateAPlotAm x + b, 8x, -10, 10<, PlotRange Ø 8Automatic, 8-30, 30<<E,
88m, 1<, -3, 3<, 88b, 0<, -10, 10<E
Out[12]=
m
b
-10
-5
5
10
-30
-20
-10
10
20
30
Discussion
Use Mathematica to compare the solution to the following variation and you will
immediately see why PlotRange is essential.
In[13]:=
Manipulate@Plot@m x + b, 8x, -10, 10<D, 88m, 1<, -3, 3<, 88b, 0<, -10, 10<D
Out[13]=
m
b
-10
-5
5
10
-10
-5
5
10
15.3 Manipulating a Plot | 601

Another common problem when manipulating graphics is sluggishness when con-
trols are varied. A crude way of dealing with this problem is to tell Manipulate to not
update the display until the control is released. You do this with the option Con-
tinuousActionØFalse .
In[14]:=
Manipulate@
SphericalPlot3D@81, If@f < 3 Piê2, 2, NoneD, If@f < 3 Piê2, 3, NoneD<,
8q, 0, l1<, 8f, 0, l2<D, 88l1, Pi<, Piê4, 2 Pi<,
88l2, 2 Pi<, Piê4, 2 Pi<, ContinuousAction Ø FalseD
Out[14]=
l1
l2
A  more  refined  alternative  is  to  perform  a  low-resolution  plot  while  controls  are
changing and then switch automatically to a full-resolution plot when the control
is released. The ControlActive function along with PlotPoints is exactly what the
doctor ordered. Many graphics functions are self-adaptive when used inside a Ma-
nipulate, but ControlActive allows you to fine-tune this behavior to match the com-
plexity of the graph and the speed of your computer. 
602 | Chapter 15: Interactivity

In[15]:=
Manipulate@
SphericalPlot3D@81, If@f < 3 Piê2, 2, NoneD, If@f < 3 Piê2, 3, NoneD<,
8q, 0, l1<, 8f, 0, l2<, PlotPoints Ø ControlActive@12, 25DD,
88l1, Pi<, Piê4, 2 Pi<, 88l2, 2 Pi<, Piê4, 2 Pi<D
Out[15]=
l1
l2
Another way to fine-tune interactive plots is to separate those options that can be
rendered quickly from those that require a lot of computation. A classic example is a
plot with variable parameters that change the shape of the plot (expensive) and
parameters that change the orientation of the plot (inexpensive). Ideally, parameters
that  are  inexpensive  to  compute  should  not  trigger  computation  of  the  expensive
parts. You achieve this by wrapping the inexpensive parts in Dynamic[]. I discuss this
use of Dynamic in detail in Recipe 15.11.
15.3 Manipulating a Plot | 603

In[16]:=
ManipulateAPlot3DAa Sin@2 Pi a xD + b SinA2 Pi b yE, 8x, 0, 2 Pi<, 9y, 0, 2 Pi=,
ViewPoint Ø Dynamic@82, v, 2<DE, 8a, 0.1, 1<, 8b, 0.1, 1<, 8v, -3, 3<E
Out[16]=
a
b
v
15.4 Creating Expressions for Which Value 
Dynamically Updates
Problem
You want to create output cells that have values that change in real time as variables
used in computing the cell values change.
Solution
Normally  an  expression  is  evaluated  and  produces  an  output  that  remains  static.
You can wrap an expression in Dynamic[] to indicate you want Mathematica to up-
date the value whenever a variable in the expression acquires a new value. Here I ini-
tialize three variables and create a list in which the first element is their sum and the
second is the sum wrapped in Dynamic. Initially the result is {6,6} as you would ex-
pect. However, you are looking at the output after the variable x1 was given a new
value of 100. Notice how the second element reflects the new sum of 105.
604 | Chapter 15: Interactivity

In[17]:=
x1 = 1; x2 = 2; x3 = 3; 9x1 + x2 + x3, Dynamic@x1 + x2 + x3D=
Out[17]=
86, 105<
In[18]:=
x1 = 100
Out[18]=
100
Discussion
Dynamic is one of the low-level primitives that make the functionality of Manipulate
possible. A typical use case of Dynamic is creating free controls that update a variable.
In[19]:=
a1 = 3;
RowA9SliderADynamic@a1D, 81, 5<E, Dynamic@a1D=, "\t"E
Out[20]=
1.
Dynamic expressions can appear in a variety of contexts and work across multiple
cells. Each output cell here will update as the slider changes the value of a1.
In[21]:=
ModuleA8x<, DynamicAIntegrate@Exp@xD, 8x, a1, 10<DEE
Out[21]=
22023.7
In[22]:=
DynamicAPlotASin@ a1 xD, 8x, 0, 2 Pi<, PlotRange Ø 8Automatic, 8-1, 1<<EE
Out[22]=
1
2
3
4
5
6
-1.0
-0.5
0.5
1.0
In[23]:=
DynamicAGraphicsACircle@80, 0<, 1, 80, a1 2 Piê5<D, ImageSize Ø 850, 50<EE
Out[23]=
There are two key principles that underlie Dynamic, and you must keep these in mind
to avoid common pitfalls. The first principle is that Dynamic has the attribute Hold-
First. This means that it does not immediately update its expression until it needs
to and does so only to produce output.
15.4 Creating Expressions for Which Value Dynamically Updates | 605

In[24]:=
AttributesADynamicE
Out[24]=
8HoldFirst, Protected, ReadProtected<
This  leads  to  the  second  key  concept.  Dynamic  is  strictly  a  frontend  function  and
can’t be used to produce values that will be passed to other functions. The following
example underscores this important point. 
In[25]:=
DynamicModuleA8x<, RowA9SliderADynamic@xD, 81, 5<E,
PlotASinADynamic@xD iE, 8i, 0, 2 Pi<E=, Spacer@2DEE
Out[25]=
1
2
3
4
5
6
0.2
0.4
0.6
0.8
1.0
Moving the slider does nothing because passing the output of Dynamic to a kernel
function like Sin can never work. 
As a general rule, if Dynamic is not in a context where its output will be
displayed directly or embedded in an expression that will be displayed
(like a control or a graphics primitive), then you are almost certainly
using Dynamic incorrectly.
See Also
See the tutorial “Introduction to Dynamic” under tutorial/IntroductionToDynamic in
the Wolfram help system.
606 | Chapter 15: Interactivity

15.5 Intercepting the Values of a Control 
Attached to a Dynamic Expression 
Problem
You want to apply a function to the output of a control before it affects the value of
a Dynamic expression.
Solution
Normally when you adjust a control, the value produced is assigned to the expres-
sion in the first argument of Dynamic. However, if the expression is not a variable
that can be assigned, this will lead to errors. The solution is provided by the second
argument  of  Dynamic,  which  allows  you  to  provide  a  function  that  can  override
the default behavior. A classic example is the creation of a control that inverts the
value of the slider. Here are a normal slider and an inverted slider that uses an inver-
sion function as its second argument.
In[26]:=
DynamicModuleA8x1<,
9SliderADynamic@x1, AutomaticDE, SliderADynamic@1 - x1, Hx1 = 1 - ÒL &DE=E
Out[26]=
9
,
=
Discussion
The solution shows a case where the second argument of Dynamic is a function. Dynamic
also supports a more advanced variation where a list of functions is passed in the sec-
ond argument. A list with two functions tells Dynamic to evaluate the first function as the
control is varied and the second function when interaction with the control is complete.
A list with three functions defines a start function, a during function, and an end function.
In[27]:=
DynamicModuleA8x1<, SliderADynamic@x1, 8Hx1 = ÒL &, Print@"End ", ÒD &<DEE
Out[27]=
End 0.
In[28]:=
DynamicModuleA8x1<, SliderA
Dynamic@x1, 8Print@"Start ", ÒD &, Hx1 = ÒL &, Print@"End ", ÒD &<DEE
Out[28]=
Start 0.
End 0.
15.5 Intercepting the Values of a Control Attached to a Dynamic Expression | 607

Here is an example illustrating Ohm’s law (voltage = current * resistance) as a set of
three coupled sliders. The goal is for voltage to be computed when the current or re-
sistance sliders change. However, if voltage is changed, then current must be recom-
puted.  The  problem  with  such  an  example  is  that  if  you  allow  voltage  to  change
when resistance is high, it can easily lead to very large currents that would violate
the limits of the current slider. The solution is to make the sliders’ limits dynamic as
well, but that requires the whole slider to be dynamic! Of course, you don’t want the
interface to be constantly generated as a slider is moved. This is where the finish
function comes in handy. When a slider interaction ends, the limits of the other slid-
ers are recomputed, triggering the creation of a new slider. 
In[29]:=
DynamicModuleA9current = 0., resistance = 1., voltage,
maxCurrent = 1, maxResistance = 100, maxVoltage = 100=,
DynamicWrapperA
GridA99"current",
DynamicASliderADynamicAcurrent, 9
H*The interactive function updates current and computes voltage.*L
I9current, voltage= = 8Ò, resistance * Ò<M &,
H*The finish function updates voltage and resistance limits.*L
I9maxVoltage, maxResistance= = 9MaxAmaxVoltage, Ò * resistanceE,
MaxAmaxResistance, voltage ë Max@Ò, 1DE=M &=E,
80., maxCurrent<EE, Dynamic@currentD=,
9"resistance",
DynamicASliderADynamicAresistance, 9
H*The interactive function
updates resistance and computes voltage.*L
I9resistance, voltage= = 8Ò, Ò * current<M &,
H*The finish function updates current and voltage limits.*L
I9maxCurrent, maxVoltage= = 9MaxAmaxCurrent, voltageë ÒE,
MaxAmaxVoltage, current*ÒE=M &=E,
81., maxResistance<EE, Dynamic@resistanceD=,
608 | Chapter 15: Interactivity

9"voltage",
DynamicASliderADynamicAvoltage, 9
H*The interactive function updates voltage and computes current.*L
I9voltage, current= = 8Ò, Òêresistance <M &,
H*The finish function updates current and resistance limits.*L
H8maxCurrent, maxResistance< = 8Max@maxCurrent, ÒêresistanceD,
Max@maxResistance, ÒêMax@current, 1DD<L &=E,
90., MaxA100., maxVoltageE=EE,
DynamicAvoltageE=,
H*Reset to starting conditions.*L
9ButtonA"Reset", current = 0.;
resistance = 1.; voltage = current * resistance;
maxCurrent = 1; maxResistance = 100; maxVoltage = 100;E=
=
E, voltage = current * resistanceEE
Out[29]=
current
0.
resistance
1.
voltage
0.
Reset
See Also
See Recipe 15.7 for an explanation of why DynamicModule is used in the Ohm’s law
example. 
15.6 Controlling Updates of Dynamic Values
Problem
You want to control the timing or variable dependencies that trigger and update to a
dynamic value.
Solution
Use Refresh to explicitly control dynamic updates. The following dynamic expres-
sion will generate a random number once every second.
15.6 Controlling Updates of Dynamic Values | 609

In[30]:=
DynamicARefreshARandomInteger@81, 100<D, UpdateInterval Ø 1EE
Out[30]=
93
In[31]:=
9
Out[31]=
9
Also use Refresh to control dependencies between dynamic variables. Here you cre-
ate two sliders that update the variables x and y and two dynamic sums of x and y,
but you use Refresh to make the first sum respond to changes in x alone, whereas
the second responds only to changes in y.
In[32]:=
DynamicModuleA9x, y=,
GridA
99SliderADynamic@xDE, DynamicAx + y, TrackedSymbols Ø 8x<E=,
9SliderADynamicAyEE, DynamicAx + y, TrackedSymbols Ø 9y=E==EE
Out[32]=
0.
0.
Discussion
Refresh should be used with caution because it subverts the expected behavior of
Dynamic. One legitimate use of Refresh is with functions that will not be triggered by
Dynamic. Theodore Gray of Wolfram Research refers to these functions as nonticklish.
The function Set normally written as = is ticklish, as you can see by evaluating the fol-
lowing expression. 
In[33]:=
DynamicModuleA8x = 1<, Dynamic@x = x + 1DE
Out[33]=
32872
This will create an output cell that increments about 20 times per second, which is
the standard refresh rate for Dynamic. Contrast this with the evaluation of a nontick-
lish function, RandomReal. 
In[34]:=
Dynamic@RandomReal@DD
Out[34]=
0.570894
This  creates  a  single  random  number  that  will  not  update.  However,  wrapping  it
with a Refresh, like we did in the “Solution” section above, will force it to update.  
See Also
See the tutorial “Advanced Dynamic Functionality” at tutorial/AdvancedDynamicFunctionality
in the Wolfram help.
610 | Chapter 15: Interactivity

15.7 Using DynamicModule As a Scoping 
Construct in Interactive Notebooks
Problem
You want to create dynamic content with local, statically scoped variables (similar
to Module) that maintain values across sessions.
Solution
DynamicModule is similar to Module in that it restricts the scope of variables, but
DynamicModule has the additional behavior of preserving the values of the local vari-
ables in the output so that they are retained between Mathematica sessions. Further,
if you copy and paste the output of a DynamicModule, the values of the pasted copy
are also localized in the copy, leaving the original unchanged as the copy varies.
In[35]:=
DynamicModuleA8pts = 880, 0<, 81, 1<, 82, 0<, 83, 2<<<,
LocatorPaneADynamic@ptsD,
DynamicAPlotAInterpolatingPolynomial@pts, xD, 8x, 0, 3<, PlotRange Ø 3EEEE
Out[35]=
0.5
1.0
1.5
2.0
2.5
3.0
-3
-2
-1
1
2
3
The dynamic plot on page 612 was copied from Out[35] above, pasted here, and
then the locators manipulated. Each variable has its own independent state that will
be retained after Mathematica is shut down and restarted with this notebook. This
works because the values are bundled with the expression that underlies the output
cells of a dynamic module. 
15.7 Using Dynamic Module as a Scoping Construct in Interactive Notebooks | 611

0.5
1.0
1.5
2.0
2.5
3.0
-3
-2
-1
1
2
3
Discussion
Normal variables (including global variables and scoped variables inside a Block or
Module) are stored inside the Mathematica kernel’s memory. When the kernel exits,
the values are lost. DynamicModule variables are stored in the notebook output cells.
Below are a trivial DynamicModule and a trivial Module. Each simply sets a local vari-
able to 1 and outputs the value. In Figures 15-1 and 15-2 you can see the difference
in the underlying notebook representation (via ShowExpression).
In[36]:=
DynamicModule@8x = 1<, xD
Out[36]=
1
Cell[BoxData[
  DynamicModuleBox[{$CellContext`x$$ = 1}, "1",
   DynamicModuleValues:>{}]], "Output",
  CellChangeTimes->{3.4346288561668787`*^9}]
Figure 15-1. Cells resulting from DynamicModule
In[37]:=
Module@8x = 1<, xD
Out[37]=
1
Cell[BoxData["1"], "Output",
  CellChangeTimes->{3.4346290869012537`*^9}]
Figure 15-2. Cells resulting from Module
612 | Chapter 15: Interactivity

15.8 Using Scratch Variables with 
DynamicModule to Balance Speed Versus Space
Problem
You want to avoid doing duplicate computations in a dynamic module by caching
data, but you don’t want to create a bloated notebook when saved.
Solution
Use the UnsavedVariables option of DynamicModule to prevent saving in the notebook
while keeping the variable localized in the frontend. Also use DynamicWrapper to guar-
antee cached data is calculated before any of the dynamic expressions. In this exam-
ple,  you  wish  to  compute  plotPoints  once  since  we  plot  the  points  and  their
squares. You neither need nor want plotPoints to be saved in the notebook; saving
the locator point is sufficient. 
In[38]:=
DynamicModuleA8pt = 81, 1<, plotPoints<,
DynamicWrapperA
RowA9LocatorPaneADynamic@ptD, GraphicsA9Gray, Opacity@0.5D, Disk@D=,
Axes Ø True, ImageSize Ø 150EE,
DynamicAListPlotAplotPoints, AspectRatio Ø 1, ImageSize Ø 150EE,
DynamicAListPlotAplotPoints^2, AspectRatio Ø 1, ImageSize Ø 150EE=,
" "E,
plotPoints = 8Re@ÒD, Im@ÒD< & êü Table@HComplex@Ò1, Ò2D & üü ptL^n,
8n, 0, 16, 0.1<DE, UnsavedVariables Ø 8plotPoints<E
Out[38]=
-60
-40
-20
20
40
60
80
-100
-50
2000
4000
6000
8000
1000
2000
3000
4000
5000
6000
7000
15.8 Using Scratch Variables with Dynamic Module to Balance Speed Versus Space | 613

Discussion
My  first  attempt  at  the  solution  did  not  use  DynamicWrapper  and  seemed  to  work
fine. However, as explained by Theodore Gray of Wolfram, there is a subtle bug that
will likely cause this to break in future versions of Mathematica. The assumption is
that  the  first  Dynamic  will  be  computed  before  the  second,  and  Mathematica  pro-
vides no such evaluation order guarantee. In contrast, the solution using Dynamic-
Wrapper will always guarantee that the second argument of DynamicWrapper will be
computed before any dynamic expressions contained in the first argument.
In[39]:=
DynamicModuleA8pt = 81, 1<, plotPoints<,
RowA9LocatorPaneADynamic@ptD,
GraphicsA9Gray, Opacity@0.5D, Disk@D=, Axes Ø True, ImageSize Ø 150EE,
DynamicAListPlotAplotPoints = 8Re@ÒD, Im@ÒD< & êü
Table@HComplex@Ò1, Ò2D & üü ptL^n, 8n, 0, 16, 0.1<D,
AspectRatio Ø 1, ImageSize Ø 150EE,
DynamicAListPlotAplotPoints^2, AspectRatio Ø 1, ImageSize Ø 150EE=, " "E,
UnsavedVariables Ø 8plotPoints<E
Out[39]=
-60
-40
-20
20
40
60
80
-100
-50
2000
4000
6000
8000
1000
2000
3000
4000
5000
6000
7000
See Also
DynamicWrapper is further discussed in the “DynamicWrapper” sidebar on page 615 and
the “Discussion” section of Recipe 15.11. 
614 | Chapter 15: Interactivity

DynamicWrapper: A Useful Undocumented Function
If  you  search  the  Mathematica  documentation  as  of  version  7,  you  will  not  find
reference to DynamicWrapper, and as I write this, Google will fail to turn up anything
as  well.  I  was  alerted  to  the  existence  of  DynamicWrapper  by  Theodore  Gray  of
Wolfram,  who  stated  that  it  is  definitely  an  approved  function  that  just  slipped
through the documentation cracks. In fact, you can find an instance of its use in a
Wolfram demonstration at http://bit.ly/jds9Z. This sidebar will provide you with the
information you need until Wolfram fills this hole.
DynamicWrapper[appearance, expr] - appearance is typeset and displayed normally
as a static (nondynamic) box structure. Associated with that box structure (wrapped
around it) is an invisible Dynamic[expr] that is tracked and evaluated just like any
other  Dynamic,  but  the  result  of  evaluating  expr  is  not  displayed  anywhere.  An
important feature is that it is guaranteed, now and in the future, that expr will be
evaluated  before  any  Dynamics  there  may  be  inside  appearance.  This  allows  you  to
use  DynamicWrapper  to  set  up,  initialize,  and  update  variables  used  by  Dynamics
inside it.
15.9 Making a Manipulate Self-Contained 
Problem
You want to make sure a Manipulate encapsulates all definitions necessary for its
operation so it always starts up in a working state.
Solution
Manipulate can reference functions and variables from the current kernel’s environ-
ment. There is no guarantee that these will be defined or defined equivalently when
a notebook is saved and reopened. Compare the following two cases. Although each
Manipulate below will behave the same after initial evaluation, you are seeing the re-
sults after restarting Mathematica and reloading this notebook without reevaluating
the definitions of f1 and f2. Note how the first does not know what f1 is, whereas
the second remembers the definition of f2 as before.
15.9 Making a Manipulate Self-Contained | 615

f1@x_D := Sin@x^2D + Cos@xD
f2@x_D := Sin@x^2D + Cos@xD
Manipulate@f1@xD, 88x, N@PiD<, 0, 2 Pi<,
FrameLabel Ø "Definitions UnSaved"D
Manipulate@f2@xD, 88x, N@PiD<, 0, 2 Pi<,
SaveDefinitions Ø True, FrameLabel Ø "Definitions Saved"D
In[40]:=
x
f1@3.14159D
Definitions UnSaved
Out[40]=
x
f1@3.14159D
Definitions UnSaved
In[41]:=
x
-1.4303
Definitions Saved
Out[41]=
x
-1.4303
Definitions Saved
616 | Chapter 15: Interactivity

Discussion
For simple cases of self-contained formulas, the solution using SaveDefinitions is ap-
propriate,  but  it  has  limitations.  Although  the  definition  of  the  function  is  saved
within  the  context  of  the  manipulate  output,  it  is  still  in  the  Global`  scope.  This
means a Clear[f2] will break the manipulation. To localize functions and variable
definitions, you can wrap the Manipulate in a DynamicModule. Now the variables de-
fined in the DynamicModule will be localized and values will be preserved across Math-
ematica sessions.
In[42]:=
DynamicModule@8f<,
f@x_D := Sin@x^2D + Cos@xD;
Manipulate@f@xD, 88x, N@PiD<, 0, 2 Pi<,
FrameLabel -> "Definitions Localized"DD
Clear@
fD
Out[42]=
x
-1.4303
Definitions Localized
Another potential problem with SaveDefinitions is that a great deal of code can get
pulled into the Manipulate output. Imagine your Manipulate uses a function that de-
pends on code from an external package pulled in by Needs. All the code in the pack-
age  could  potentially  be  pulled  into  the  Manipulate  cell  by  SaveDefinitions.  This  will
bloat the notebook and affect the time it takes the control to initialize each time. In
situations like this, it is better to use the option Initialization. Further, if the Ini-
tialization  code  must  complete  before  the  results  are  displayed,  you  should  also
specify option SynchronousInitialization Ø True.
In[44]:=
ManipulateAHistogramARandomReal@dist, 81000<D, PlotRange Ø AllE,
8dist, 880, 1<, NormalDistribution@0, 1D, HalfNormalDistribution@1D,
StudentTDistribution@2D, StudentTDistribution@3D<<,
Initialization :> IIfATrueQA$VersionNumber < 7E, NeedsA"Histograms`"EEM,
SynchronousInitialization Ø TrueE
15.9 Making a Manipulate Self-Contained | 617

Out[44]=
dist
80, 1<
NormalDistribution@0, 1D
HalfNormalDistribution@1D
StudentTDistribution@2D
StudentTDistribution@3D
Mathematica  7  was  released  midway  through  the  production  of  this
book, hence I conditionalized the Initialization since Histogram is a
built-in function in version 7. 
15.10 Remembering the Values Found Using 
Manipulate
Problem
You found some interesting results using Manipulate and want to preserve them for
future use.
Solution
Use the + icon in the Manipulate to select either “Paste Snapshot ” or “Add To Bookmarks.”
In[45]:=
Manipulate@-0.07 x^5 - 0.42 x^4 + 0.94 x^3 - 4.25 x^2 + 86.5 x - 0.13,
8x, 4.873, 4.874<D
Out[45]=
x
0.0617716
618 | Chapter 15: Interactivity

In[46]:=
DynamicModuleA8x = 4.8732500000000005`<,
-0.07` x5 - 0.42` x4 + 0.94` x3 - 4.25` x2 + 86.5` x - 0.13`E
Out[46]=
-0.00816536
In[47]:=
DynamicModuleA8x = 4.873219000000001`<,
-0.07` x5 - 0.42` x4 + 0.94` x3 - 4.25` x2 + 86.5` x - 0.13`E
Out[47]=
0.000507714
Discussion
You can bookmark specific settings by adjusting the dynamic module output to the
desired values and then choosing “Add To Bookmarks.” You will be prompted for a
bookmark name. From that point on you can return to those settings by selecting
the bookmark. In the figure below I have added two bookmarks: “Initial Settings”
and “Interesting.”
15.11 Improving Performance of Manipulate by 
Segregating Fast and Slow Operations
Problem
You have a sluggish Manipulate with several controls and you would like to improve
some aspects of its performance.  
15.11 Improving Performance of Manipulate by Segregating Fast and Slow Operations | 619

Solution
Isolate fast dynamic computations from computationally intensive ones by perform-
ing the fast computations local to an internal Dynamic. In the example below, the gen-
eration of the 50,000 data points using NestList is significantly more expensive than
raising the values in the list to a power. You need not pay the price of the generation
when manipulating the variable z, but to isolate that computation you need to wrap
it in a Dynamic, as shown.
In[48]:=
ManipulateA
DynamicModuleA8data<, data = NestList@r Ò H1.0 - ÒL &, x, 50 000D;
DynamicAListPlotA data^z, PlotRange -> 880, 10 000<, 80, 1<<EEE,
88r, 3.58<, 2, 4<, 88x, 0.4<, 0, 1<, 88z, 1<, 0.1, 5<E
Out[48]=
r
x
z
0
2000
4000
6000
8000
10000
0.0
0.2
0.4
0.6
0.8
1.0
Discussion
This technique works because internally Manipulate wraps its expression with a Dy-
namic and the net result is a Dynamic nested inside another Dynamic. In the solution,
the inner Dynamic is monitoring changes in data and z but not r or x, and since data
does not recompute when z changes, data need not be recomputed. The general rule
is that changes that trigger only updates to an inner Dynamic will not trigger updates
to any outer Dynamic.
You can also exploit this property when combining plots where one is slow and the
other is fast. To make this work, you need to solicit the services of DynamicWrapper
620 | Chapter 15: Interactivity

because Show cannot combine Dynamic output. The trick here is to use DynamicWrapper
to capture the output of each plot, nesting the DynamicWrapper that computes the
ReliefPlot (less expensive) inside the DynamicWrapper that computes the ListContour-
Plot (more expensive). The result is that you can change the color function cf or the
plot points p of the ReliefPlot and get fast updates while paying for the updates to n
or the number of contours c only when these are changed.
In[49]:=
ManipulateADynamicModuleA8p1 = 0, p2 = 0, data<,
data = TableAi + SinAi^n + j^nE, 8i, -4, 4, .03<, 9j, -4, 4, .03=E;
DynamicWrapperADynamicWrapperADynamic@Show@8p2, p1<DD,
p1 = ListContourPlotAdata, ContourShading -> None, Contours -> c,
ContourStyle -> 9Opacity@.5D, Opacity@.8D=, ImageSize -> 300EE,
p2 = ReliefPlotAdata, MaxPlotPoints -> p, ColorFunction -> cf,
ImageSize -> 300EEE, 88n, 2<, 1, 10, 1<,
88c, 3<, 3, 10, 1<, 88p, 50<, 20, 200, 1<,
8cf, 8Automatic, "SunsetColors", "BlueGreenYellow"<<E
Out[49]=
n
c
p
cf
Automatic
SunsetColors
BlueGreenYellow
15.11 Improving Performance of Manipulate by Segregating Fast and Slow Operations | 621

In[50]:=
DynamicModuleA8cf = "SunsetColors", c = 5, n = 6, p = 110<,
DynamicModuleA8p1, p2, data<,
data = TableAi + SinAin + jnE, 8i, -4, 4, 0.03`<, 9j, -4, 4, 0.03`=E;
DynamicWrapperADynamicWrapperADynamic@Show@8p2, p1<DD,
p1 = ListContourPlotAdata, ContourShading Ø None, Contours Ø c,
ContourStyle Ø 9Opacity@0.5`D, Opacity@0.8`D=, ImageSize Ø 500EE,
p2 = ReliefPlotAdata, MaxPlotPoints Ø p, ColorFunction Ø cf,
ImageSize Ø 300EEEE
Out[50]=
15.12 Localizing a Function in a Manipulate
Problem
You want to manipulate a function while keeping the function’s definition localized.
Solution
Wrap the Manipulate in a DynamicModule and use the Initialization option to estab-
lish the function’s definition. Below we define a global function f[x] and two Manipu-
lates using localized definitions of f[x] that remain independent.
In[51]:=
f@x_D := 1
622 | Chapter 15: Interactivity

In[52]:=
DynamicModule@8f<, Manipulate@f@xD, 8x, -2 Pi, 2 Pi<D,
Initialization :> Hf@x_D := Sin@xDLD
Out[52]=
x
0
In[53]:=
DynamicModule@8f<, Manipulate@f@xD, 8x, -2 Pi, 2 Pi<D,
Initialization :> Hf@x_D := Cos@xDLD
Out[53]=
x
1
Discussion
Manipulate only localizes variables associated with control variables. This can cause
problems when you have multiple Manipulates that use the same function name in
different ways. In Out[54] below, it is clear that the second definition of g[x] modi-
fied the first since Sin[x] takes on values between |1 and 1.
In[54]:=
ManipulateAg@xD, 8x, -2. Pi, 2. Pi<, Initialization :> Ig@x_D := Sin@xDME
Out[54]=
x
-18.8496
In[55]:=
ManipulateAg@xD, 8x, 1., 2.<, Initialization :> Ig@x_D := 3 xME
Out[55]=
x
3.
15.12 Localizing a Function in a Manipulate | 623

Note that SaveDefinitionsØTrue as discussed in Recipe 15.9 does not localize the sym-
bol, so it is not a solution to this problem.
In[56]:=
f@x_D := Exp@xD
Manipulate@f@xD, 8x, -2 Pi, 2 Pi<, SaveDefinitions Ø TrueD
Out[57]=
x
‰-2 p
In[58]:=
f@x_D := 1
15.13 Sharing DynamicModule Variables across 
Cell or Window Boundaries
Problem
You want to create an interface that is divided across multiple cells or notebooks but
interacts with shared variables. However, you don’t want these variables to be global.
Solution
Create a DynamicModule Wormhole using InheritScopeØTrue from within a Manip-
ulate or DynamicModule you want to inherit from.
Discussion
Variables defined in the first argument of a DynamicModule or as control variables in a
Manipulate have their scope restricted to the resulting output cell. This concept is ex-
plained in Recipe 15.7. Generally, this is exactly the behavior you want when using
Manipulate. An obvious exception is when you want to create a more complex appli-
cation composed of multiple notebooks (a palette is implemented as a notebook).
The whimsical term wormhole is used to suggest the sharing of scope between differ-
ent physical locations (e.g., output cells). 
Here is an example that uses the same technique as the solution but with Dynamic-
Module  instead  of  Manipulate  and  multiple  output  cells  instead  of  a  palette.  Each
time the button is pressed, a new cell is printed that inherits the scope from the origi-
nal DynamicModule.
624 | Chapter 15: Interactivity

In[59]:=
DynamicModuleA8x = 0, d<,
9Dynamic@xD, SliderADynamic@xD, 8-10, 10<E, ButtonA"MakeCell",
PrintADynamicModuleA8<, Dynamic@xD, InheritScope Ø TrueEEE=E
Out[59]=
;0,
, MakeCell ?
See Also
The “Advanced Dynamic Functionality” tutorial (http://bit.ly/3u8fXo) explains some
of the technical details underlying DynamicModule wormholes. It hints at the ability to
link up arbitrary existing DynamicModules but, unfortunately, provides no additional
information. 
15.14 Creating Your Own Custom Controls
Problem
You want to create a control of your own design that can be used inside a Manipu-
late or notebook cell.
Solution
Manipulate allows you to associate a control variable with a function and thus pro-
vides a means to specify controls with nonstandard behavior and appearance. The
function incUntilButton creates a button that increments the dynamic variable until
it hits a specified value, at which point it sets it back to the minimum specified in the
Manipulate definition. Notice how the slider can change the x through its full range
while the button immediately resets x to |10 if it exceeds 5.
In[60]:=
incUntilButtonAname_String, limit_Integer, Dynamic@val_D,
8min_, max_<E := Button@name, If@val < limit, ++val, val = minDD
Manipulate@x, 8x, -10, 10<, 88x, 0<, -10, 10,
incUntilButton@"Inc Until 5", 5, ÒÒD &<D
Out[61]=
x
x incUntilButton@Inc Until 5, 5, -10, 8-10, 10<D
-10
15.14 Creating Your Own Custom Controls | 625

Discussion
The function you use to create a custom control can take two forms. In the simple
form, it is passed only the control variable wrapped in Dynamic (e.g., Dynamic[x]).
In[62]:=
simpleADynamic@var_DE := Button@"inc", ++varD
Manipulate@x, 88x, 0<, -10, 10<, 88x, 0<, simple@ÒD &<D
Out[63]=
x
x simple@0D
0
The solution shows the advanced form that gives the function access to the mini-
mum and maximum values specified in the definition. In this case, the function
Manipulate sees must have the form f[Dynamic[var_], {min_,max_}]. As the solution
shows, this does not mean you can’t use a function that takes additional arguments.
However, those arguments must be bound when the anonymous function is created
inside the Manipulate, as I did by providing "Inc Until 5" and 5 in the solution.
You may argue that a button hardly qualifies as a “custom control” even though the
solution gives it custom behavior. Have no fear, because you have all the user inter-
face primitives Mathematica has to offer at your disposal for creating interesting con-
trols.  Here  is  an  example  that  shows  how  the  angular  slider  (adapted  from  the
“Applications” section DynamicModule in the Mathematica documentation) can be in-
corporated as a control in a Manipulate.
This  example  uses  the  function  Control  and  the  option  ContentSize,
which are only available in Mathematica 7.
626 | Chapter 15: Interactivity

In[64]:=
angularSliderADynamicAangle_EE :=
ControlA9angle, IDynamicModuleA9p = 81, 0<, angleCalc=,
LocatorPaneADynamicAp, IangleCalc üü Normalize êü 8Ò, p<M &E,
GraphicsA9Circle@D, Arrowheads@0.15D, ArrowA
Dynamic@880, 0<, p<DE=, ImageSize Ø TinyE, Appearance Ø NoneE,
Initialization ß Iangle = 0; angleCalc@newp_, oldp_D := Iangle =
angle + ArcCos@newp.oldpD Sign@Cross@newpD.Hnewp - oldpLD;
p = 9CosAangleE, SinAangleE=MMEM &=E
ManipulateA9angle, SinAangleE, CosAangleE=, 9angle, angularSlider@ÒD &=,
ContentSize Ø 275E
Out[65]=
angle angularSlider@0D
80, 0, 1<
15.15 Animating an Expression
Problem
You want to see how an expression evolves without having to manually adjust controls.
Solution
Use Animate to create instructive self-running demonstrations. Here Animate drives
an  illustration  of  the  cycloid,  which  is  the  locus  of  points  traced  by  a  point  on  a
wheel as it rolls across a flat surface.
In[66]=
AnimateA
ShowAParametricPlotA8t - Sin@tD, 1 - Cos@tD<, 9t, 0, x + $MachineEpsilon=,
PlotRange Ø 880, 4 Pi<, 80, 2<<, Axes Ø NoneE, Graphics@Translate@
Rotate@8Circle@80, 1<D, Point@80, 0<D<, -xD, 8x , 0<DDE, 8x, 0, 4 Pi<E
Out[66]=
x
15.15 Animating an Expression | 627

Discussion
Animate can drive a variety of demonstrations. Here we can get some insight into the
implementation of the Sort function by providing a parameter limit within a cus-
tom comparison function that short-circuits the sort after that many steps. You use
Animate with BarChart to visualize the partialSort at each step. Here the option
DisplayAllSteps keeps Animate from skipping over steps. DisplayAllSteps will slow
things down, so only use it if the animation suffers without it.
In[67]=
DynamicModuleA8list, len<,
list = RandomReal@81, 100<, 50D;
len = Length@listD;
max = FloorAlen * Log@2, lenDE;
AnimateABarChartApartialSort@list, tD, Axes Ø None,
ColorFunction Ø FunctionA9height=, ColorData@"Rainbow"DA1 - heightEEE,
8t, 0, max, 1<, DisplayAllSteps Ø TrueE,
Initialization ß H
partialSort@list_, limit_D :=
Module@8step = 0<, Sort@list, Hstep++ < limit && Ò1 < Ò2L &DD
LE
Out[67]=
t
Other  useful  options  are  AnimationRunningØTrue,  which  starts  the  animation  run-
ning immediately; AnimationRate, which sets the initial speed of the animation; and
AnimationRepetitions, which controls how many times the animation repeats before
stopping. 
628 | Chapter 15: Interactivity

As you might expect, there is a close relationship between Animate and Manipulate.
Animate is implemented in terms of Manipulate with the help of a low-level control
called an Animator. You can use an Animator directly to get more control over the de-
tails of the animation layout. Stare at the next animation for 10 seconds, and when
you awaken, you will have the strong urge to tell all your friends to buy the Mathe-
matica Cookbook!
In[68]:=
DynamicModuleA8x<,
GridA99AnimatorADynamic@xDE, DynamicAGraphicsA9Opacity@0.5D,
Disk@80, 0<, 0.5D, Disk@80, 0<, xD=EE=, 9"You are getting...",
DynamicATextAStyleA"Sleepy", Bold, 12 + 5 xEEE==EE
Out[68]=
You are getting...
Sleepy
You can share your animations over the Web by exporting them to several common
video formats, such as Microsoft AVI or Adobe Flash. You may need to experiment
with the options AnimationRate, RefreshRate, and DefaultDuration to get a smooth
animation.
In[69]:=
ExportA"cycloid.avi",
AnimateAShowAParametricPlotA8t - Sin@tD, 1 - Cos@tD<,
9t, 0, x + $MachineEpsilon=, PlotRange Ø 880, 4 Pi<, 80, 2<<,
Axes Ø NoneE, Graphics@Translate@
Rotate@8Circle@80, 1<D, Point@80, 0<D<, -xD, 8x , 0<DDE,
8x, 0, 4 Pi<, AnimationRate Ø 0.1, RefreshRate Ø 1,
AnimationRunning Ø True, DefaultDuration Ø 20.`,
AnimationDirection Ø ForwardBackwardEE;
15.15 Animating an Expression | 629

See Also
The function ListAnimate provides an alternative to Animate in which the animation
is derived by cycling through the elements of a list. This is useful in a case where
each step in the animation takes a lot of computation; you can precompute all the
frames of the animation and play them back using ListAnimate. See the Mathemat-
ica documentation for examples.
15.16 Creating Custom Interfaces
Problem
You  want  to  create  a  custom  interface  that  requires  handling  of  low-level  events
such as mouse clicks.
Solution
Mathematica’s  higher  level  interactive  functionality  is  adequate  for  most  casual
users,  but  sometimes  you  want  to  achieve  something  cool.  Luckily,  Mathematica
lets  you  intercept  low-level  GUI  events  generated  by  your  operating  system  using
EventHandler. When you execute the following code, you can increase the size of the
text by dragging (moving the mouse with the left button depressed) over the word
Start. When you release the mouse, the text changes to Done.
In[70]:=
DynamicModuleA8text = "Start", points = 12<,
EventHandlerADynamicATextAStyle@text, pointsDEE,
"MouseDown" ß Htext = "Start"; points = 12L,
"MouseUp" ß Htext = "Done"L, "MouseDragged" ß Hpoints += 0.5LEE
Out[70]= Start
Discussion
You can use event handlers to add interactive features to existing plotting and graph-
ics functions. In these applications, you will often use MousePosition["Graphics"] to
query the position of the mouse relative to the enclosing graphic. Here interactive-
Plot creates a plot of a function and annotates it with a point based on the position
of the mouse when you click. The coordinates of the point are displayed in the up-
per left.
630 | Chapter 15: Interactivity

In[71]:=
SetAttributes@interactivePlot, HoldAllD;
interactivePlotAf_, range_E := DynamicModuleA8m, p = 80, 0<, plot, dot<,
ColumnA9Dynamic@Row@p, Spacer@4DDD, EventHandlerA
plot = PlotAf, rangeE;
DynamicWrapperADynamic@Show@plot, dotDD,
dot = Graphics@Point@8p@@1DD, p@@2DD<D, AspectRatio Ø 0.1DE,
"MouseDown" ß Hm = MousePosition@"Graphics"D;
p = 8m@@1DD, Head@fD@m@@1DDD<LE=EE
In[73]:=
interactivePlot@Cos@xD, 8x, 0, 4 Pi<D
Out[73]=
0
0
2
4
6
8
10
12
-1.0
-0.5
0.5
1.0
Event handlers can nest with the options PassEventsDown and PassEventsUp, control-
ling event propagation. By default, inner event handlers get to act on events first, but
outer event handlers see the event first and thus can control propagation of the event
downward. The program below creates a simple game using the keyboard. The idea
is to try to catch the dot with the arrow. Notice that there is an outer event handler
that is used to control the difficulty of the game using the d and e keys. The outer
event  handler  uses  PassEventsDown  Ø  False,  which  means  that  if  it  handles  the
event,  then  the  inner  handler  will  not  see  it.  This  prevents  the  dot  from  moving
when the d or e key is handled. 
EventHandler  using  arrow  keys  does  not  work  well  in  Mac  OS  X
because selection is lost when the arrow is pressed. I do not know a
workaround except to use other keys or mouse events.
15.16 Creating Custom Interfaces | 631

In[74]:=
DynamicModuleA9line = 880, 0<<, dot, inc = 0.1, difficulty = 0.5=,
dot = Disk@Round@RandomReal@80, 1<, 2D, 0.1D, 0.025D;
H*This event handler controls difficulty.*L
EventHandlerADynamicA
H*This event handler controls the game play.*L
EventHandlerA
DynamicA
ColumnA9RowA9"Difficulty", difficulty=, Spacer@2DE, GraphicsA9White,
EdgeForm@ThickD, Rectangle@D, Black, Arrow@lineD, dot=E=EE,
H*Arrow keys extend the line.*L
"RightArrowKeyDown" ß AppendTo@line, Last@lineD + 8inc, 0<D,
"LeftArrowKeyDown" ß AppendTo@line, Last@lineD + 8-inc, 0<D,
"UpArrowKeyDown" ß AppendTo@line, Last@lineD + 80, inc<D,
"DownArrowKeyDown" ß AppendTo@line, Last@lineD + 80, -inc<D,
H*Any key, including arrows, may move the dot or declare a winner.*L
"KeyDown" ß Idot = IfAinc > 0 && dot@@1DD ã Last@lineD,
inc = 0; TextAStyle@"Winner", Bold, 16D, dot@@1DDE,
IfAinc ã 0 »» RandomReal@D > difficulty, dot,
Disk@Round@RandomReal@80, 1<, 2D, 0.1D, 0.025DEEMEE,
9"KeyDown", "d"= ß Idifficulty = MinA0.8, difficulty + 0.05EM,
9"KeyDown", "e"= ß Idifficulty = MaxA0.1, difficulty - 0.05EM,
H*Escape key resets the game.*L
"EscapeKeyDown" ß Hline = 880, 0<<; inc = 0.1;
dot = Disk@Round@RandomReal@80, 1<, 2D, 0.1D, 0.025DL,
H*Don't pass events handled on this layer down.*L
PassEventsDown Ø FalseEE
Out[74]=
Difficulty 0.5
632 | Chapter 15: Interactivity

See Also
FrontEndEventActions,  NotebookEventActions,  and  CellEventActions  are  other  event
handlers with differing levels of granularity. See the Mathematica documentation for
details.
15.17 Managing a Large Number of Controls in 
Limited Screen Real Estate
Problem
You want to go beyond what Manipulate has to offer and create your own custom in-
terfaces. You may need to manage a large number of controls in a sensible manner
or need a custom layout that Manipulate does not support.
Solution
The  building  blocks  of  sophisticated  user  interfaces  are  PaneSelector  and  Opener-
View,  for  managing  many  controls;  Control,  for  selection  of  appropriate  controls;
and Item, Row, Column, and Grid, for layout. The following Manipulate initially pre-
sents a simple interface for modifying the parameters to a 3D plot. You use Opener-
View  to  provide  an  advanced  set  of  controls  that  remain  hidden  until  selected.
Within this OpenerView, you use PaneSelector to alternate between sets of controls, de-
pending on a checkbox that allows modification of PlotStyle or ColorFunction.
Control  is  a  Mathematica  7  feature,  so  the  following  code  will  not
work in version 6.
15.17 Managing a Large Number of Controls in Limited Screen Real Estate | 633

In[75]:=
DynamicModuleA9color, specularity, colorFunc, colorScale, vxy, vz=,
ManipulateAPlot3DASinAa Pi x + y^2E b CosAc Pi yE, 8x, -1, 1<,
9y, -1, 1=, PlotRange Ø 88-1, 1<, 8-1, 1<, 8-5, 5<<,
PlotStyle Ø 9SpecularityAWhite, specularityE, color=,
ColorFunction Ø
IfAcolorFunc, FunctionA9x, y, z=, Hue@colorScale H1 - zLDE, NoneE,
H*Here I use Dynamic as per Recipes 15.6 and 15.5 so that updates
are fast and viewpoint drags of plot sync with controls.*L
ViewPoint Ø DynamicAFlattenA9vxy, vz=E,
I9vxy@@1DD, vxy@@2DD, vz= = ÒM &EE,
8a, -5, 5<, 8b, -5, 5<, 8c, -5, 5<,
H*Advanced set of controls*L
OpenerViewA9"Advanced", ColumnA9
ItemA"Plot Style", Alignment Ø CenterE,
Control@88colorFunc, False<, 8True, False<<D,
H*PlotStyle and ColorFunction are mutually exclusive.*L
PaneSelectorA9True ->
Control@88colorScale, 0.65<, 0, 1<D,
False Ø ColumnA9ControlA9color, Orange=E,
ControlA99specularity, 3=, 5, 1=E=E=, Dynamic@colorFuncDE,
ItemA"View", Alignment Ø CenterE,
RowA9ControlA99vxy, 82, 2<, "x-y"=, 8-2 Pi, -2 Pi<, 82 Pi, 2 Pi<=E,
ControlA98vz, 2, "z"<, -2 Pi, 2 Pi,
ControlType Ø VerticalSlider, ImageSize Ø Tiny=E=E
=E=EEE
634 | Chapter 15: Interactivity

Out[75]=
a
b
c
Advanced
Discussion
In addition to OpenerView and PaneSelector, there is a whole family of controls for
managing  limited  screen  real  estate.  These  include  FlipView,  MenuView,  SlideView,
and TabView. I provide a sample of each without going into much detail because they
are fairly self-explanatory and follow the same basic syntax. 
A FlipView cycles through a list of expressions as you click on the output. Here I use
FlipView over a list of graphics. Click on the graphic to see the next in the series. 
In[76]:=
FlipViewA
GraphicsAÒ, ImageSize Ø TinyE & êü 9Disk@D, Circle@D, Rectangle@D=E
Out[76]=
15.17 Managing a Large Number of Controls in Limited Screen Real Estate | 635

SlideView is similar to FlipView but uses VCR-style controls to give more control of
the progression.
In[77]:=
SlideViewA
GraphicsAÒ, ImageSize Ø TinyE & êü 9Disk@D, Circle@D, Rectangle@D=E
Out[77]=
« ▸
A MenuView allows you random access to the items via a menu that you specify as a
list of rules: MenuView[{lbl1Øexpr1, label2Øexpr2, ...}]. This is similar syntax to
that used by PaneSelector in the solution. Don’t be afraid to build up these expres-
sions using a bit of functional programming as I do here, especially if it cuts down
on repetition. In Out[78] below, I use the Head of each graphic primitive as the label
for convenience, but you can also provide the label explicitly, as in Out[79] on page
637, which builds the list of rules using Inner. 
In[78]:=
MenuViewAIHead@ÒD ß GraphicsAÒ, ImageSize Ø TinyEM & êü
9Disk@D, Circle@D, Rectangle@D=E
Out[78]=
Disk
636 | Chapter 15: Interactivity

In[79]=
MenuViewAInnerAIÒ1 Ø GraphicsAÒ2, ImageSize Ø TinyEM &,
9"aDisk", "aCircle", "aRectangle"=,
9Disk@D, Circle@D, Rectangle@D=, ListEE
Out[79]=
aDisk
TabView is similar to MenuView but uses the familiar tabbed folder theme that has be-
come popular in a variety of modern interfaces, including most web browsers.
In[80]:=
TabViewAInnerAIÒ1 Ø GraphicsAÒ2, ImageSize Ø TinyEM &,
9"aDisk", "aCircle", "aRectangle"=,
9Disk@D, Circle@D, Rectangle@D=, ListEE
Out[80]=
aDisk
aCircle
aRectangle
Clearly these controls can be mixed, combined with Manipulate, or used alone to cre-
ate an unlimited variety of sophisticated interfaces. For example, here is a tabbed set
of Manipulates.
15.17 Managing a Large Number of Controls in Limited Screen Real Estate | 637

In[81]:=
TabView@Inner@
HÒ1 Ø Manipulate@ Plot@a Ò2@b xD, 8x, 0, Pi<D, 8a, 1, 5<, 8b, 1, 5<DL &,
8"Sin", "Cos", "Tan"<, 8Sin, Cos, Tan<, ListDD
Out[81]=
a
b
0.5
1.0
1.5
2.0
2.5
3.0
0.2
0.4
0.6
0.8
1.0
Sin
Cos
Tan
Contrast this to a single Manipulate that can switch between a TabView or a MenuView,
or even one that lets you switch back and forth. This is actually a useful technique
when building an interface for someone’s approval. You can switch among various
design choices without touching the code.
638 | Chapter 15: Interactivity

In[82]:=
Manipulate@control@Inner@HÒ1 Ø Plot@a Ò2@b xD, 8x, 0, Pi<DL &,
8"Sin", "Cos", "Tan"<, 8Sin, Cos, Tan<, ListDD,
8a, 1, 5<, 8b, 1, 5<, 88control, TabView<, 8TabView, MenuView<<D
Out[82]=
a
b
control
TabView
MenuView
0.5
1.0
1.5
2.0
2.5
3.0
-1.0
-0.5
0.5
1.0
Sin
Cos
Tan
See Also
Inspiration for this recipe came from a presentation by Lou D’Andria of Wolfram
during  the  2008  International  Mathematica  User  Conference.  Presentations  from
this conference can be found at http://bit.ly/41BMSZ.
15.17 Managing a Large Number of Controls in Limited Screen Real Estate | 639


CHAPTER 16
Parallel Mathematica
splintered dreams of unity (our lives are parallel)
so far from reality (our lives are parallel)
independent trajectories (our lives are parallel)
separate terms of equality (our lives are parallel)
our lives are parallel
is there no redemption? no common good?
is there nothing we can do for ourselves?
or only what we should?
comes the hard admission of what we don’t provide
goes the insistence on the ways
and means that so divide
Bad Religion, “Parallel”
16.0 Introduction
Mathematica has impressive performance on many types of problems. The majority
of Mathematica users are not drawn to Mathematica for its brute speed, but rather
for its unparalleled depth of features in the realm of symbolic processing. Yet, there
are certainly problems that you will solve in Mathematica that you will want to scale
to  larger  data  sets  or  more  complex  models.  In  the  past,  the  only  viable  solution
might be to port your Mathematica solution to C or Fortran. Today relatively cheap
multiprocessor  and  multicore  computers  have  become  commonplace.  My  primary
development machine has eight cores available. Wolfram provides two solutions for
exploiting multiple CPUs. The first solution, called Grid Mathematica, has been avail-
able as a separate (and somewhat costly) product distinct from your vanilla Mathe-
matica product. The second solution is available to everyone who has updated to
Mathematica 7. One of the big feature enhancements in version 7 is integrated paral-
lelism that can exploit up to four CPU cores. At the present time, going beyond four
cores requires the Grid Mathematica solution, even with version 7. 
641

Whether you use Mathematica 7, Grid Mathematica 7, or Grid Mathematica pre-
release 7, the road to parallelizing your Mathematica code is essentially the same, al-
though it has become significantly more user friendly in version 7. Mathematica’s
concurrency model revolves around running multiple communicating kernels. These
kernels can be on the same machine (which only makes sense if that machine has
multiple cores) or on several networked machines. In the networked case, the ma-
chines can be of any architecture and operating system for which a Mathematica
version exists.
Mathematica’s  concurrency  model  uses  one  master  kernel  and  multiple  slave  ker-
nels. The designations master and slave do not denote different versions of the kernel:
any kernel can play the role of the master. The master coordinates the activity of the
slaves, ships work to the slave kernels, and integrates results to present back to the
end users. There are several possible configurations of master and slaves that will
vary based on your particular arrangement of computer resources and possibly third-
party  tools.  The  simplest  configuration  uses  all  local  kernels  and  is  appropriate
when working on a multicore machine. The next level of complexity is based on Wolf-
ram’s  Lightweight  Grid  Service  technology  and  represents  the  simplest  option  for
users who need to distribute computations over a network of computers. The third
option is ideal for enterprise users who already deploy some third-party vendor’s clus-
tering solution (e.g., Microsoft Cluster Server, Apple Workgroup Cluster, Altair PBS
GridWorks,  etc.).  A  final  option  is  based  on  the  ability  of  the  master  kernel  to
launch remote kernels using the remote shell (rsh), but this is largely a legacy option
and is typically harder to set up and maintain. Recipes 16.1 and 16.2 explain how to
set up the two most common configurations. 
The recipes in this chapter assume you have Mathematica 7, which no
longer  relies  on  the  Parallel  Computing  Toolkit  that  was  the
foundation  of  parallel  operations  for  Mathematica  6  and  earlier
versions. However, many of the recipes will port easily to the Parallel
Computing Toolkit since many of commands have the same names.
There are some common pitfalls you need to avoid so your experience with paral-
lelization does not end in utter frustration.
Never attempt to test your code for the first time in parallel evaluation. If you are
writing a function that you plan to evaluate in parallel, first test it in the normal way
on a single kernel. Make sure it is as bug free as possible so you can separate any
problems you encounter under parallel operation from problems that have nothing
to do with parallel evaluation. 
642 | Chapter 16: Parallel Mathematica

Don’t forget that slave kernels do not have access to variables and definitions cre-
ated in the master unless you specifically grant them access. A very common pitfall
is to forget to use DistributeDefinitions.
Try structuring your code so that it is side-effect free. Code with side effects, includ-
ing code that may create new definitions within the kernel, perform writes to files,
or create visual content in the frontend, may still be parallelizable, but you need to
know what you are doing. A function that saves some state in one slave kernel will
not see that change when it runs again in a different slave kernel. 
Race conditions may be another problem. Consider a function that checks if a file ex-
ists, opens it, and writes some data to the end. If the file was not found, it creates it.
Parallelizing the function is going to be fraught with difficulties unless special precau-
tions are taken. If the function is running on two kernels, both may see that the file
does not exist, and both may then attempt to create it. This will most likely result in
the initial output of one kernel getting lost. Race conditions are extremely frustrat-
ing because a program may work 99 times in a row but then suddenly fail on the
hundredth try. Recipe 16.11 provides techniques for avoiding these kinds of problems.
16.1 Configuring Local Kernels
Problem
You want to exploit your multicore computer by running two or more local kernels
in parallel.
Solution
Use Edit, Preferences and navigate to the Parallel tab (see Figure 16-1). Within this
top-level tab there is a subtab group where the first subtab is called Local Kernels. If
you are configuring parallel preferences for the first time, this tab is probably already
selected.  Notice  the  button  called  Enable  Local  Kernels.  Pressing  that  button  will
cause the display to change to that in Figure 16-2.
16.1 Configuring Local Kernels | 643

Figure 16-1. Parallel preferences for local kernel configuration
There  are  a  few  radio  buttons  for  specifying  how  many  slave  kernels  to  run.  The
default setting is Automatic, meaning it will run as many kernels as there are cores,
up to the standard license limit of four. For most users, this is exactly the setting you
want, and you can now close the Preferences dialog and begin using the parallel pro-
gramming primitives described in the remaining recipes of this chapter.
644 | Chapter 16: Parallel Mathematica

Figure 16-2. Preferences after enabling local kernels
Discussion
The simplest way to get started with parallel computing in Mathematica is to run on
a computer with more than one core. A four-core machine is ideal because that is
the number of slave kernels Mathematica allows in a standard configuration. If you
are using the computer to do other work, you may want to leave “Run kernels at
lower process priority” checked, but on my Mac Pro eight-core processor, I uncheck
this since there is plenty of CPU available to the system even with the four slaves,
one master, and the frontend. 
Once you have enabled local kernels, you can use Parallel Kernel Status to check the
status of the slaves and launch or close them. 
16.1 Configuring Local Kernels | 645

See Also
See  Recipe  16.2  for  configuring  access  to  kernels  running  on  other  computers  on
your network.
16.2 Configuring Remote Services Kernels
Problem
You want to exploit the computing resources of your network by running two or
more kernels across multiple networked computers.
Solution
If you have not already done so, you must obtain the Lightweight Grid Service from
Wolfram  and  install  it  on  all  computers  that  you  wish  to  share  kernels.  The
Lightweight Grid Service is available free to users who have Premier Service. Contact
Wolfram for licensing details. By default, the Lightweight Grid Service is associated
with port 3737, and assuming this default, you can administer the service remotely
via  a  URL  of  the  form  http://<server  name>:3737/WolframLightweightGrid/,  where
<server  name>  is  replaced  by  the  server  or  IP  address.  For  example,  I  use  http://
maxwell.local:3737/WolframLightweightGrid/ for my Mac Pro. I could also access this
machine via its IP address on my network http://10.0.1.4:3737/WolframLightweightGrid/. 
Use  the  Lightweight  Grid  tab  under  Parallel  Preferences  tab  to  configure  the
Lightweight Grid. This tab should automatically detect machines on your local sub-
net.  You  can  also  find  machines  on  other  subnets  (provided  they  are  running
Lightweight Grid) by using the “Discover More Kernels” option, and entering the
name of the machine manually.
646 | Chapter 16: Parallel Mathematica

Figure 16-3. Parallel preferences for Lightweight Grid
16.2 Configuring Remote Services Kernels | 647

Discussion
Once you have the Lightweight Grid configured, remote kernels are as easy to use as
local ones. Mathematica will launch the specified number of remote kernels on the
computers you selected provided the kernels are available. The kernels may not be
available if they are being used by another user on the network since each computer
will typically have a maximum number of kernels that can be launched, and launch-
ing more kernels than there are cores on a specific computer does not usually make
sense.
You can use the LaunchKernels command to launch kernels associated with a spe-
cific computer running the Lightweight Grid Service. 
In[1]:=
LaunchKernelsA"http:êê10.0.1.4:3737êWolframLightweightGridê"E;
See Also
Documentation and download links for the Lightweight Grid can be found at http://
www.wolfram.com/products/lightweightgrid/.
16.3 Sending a Command to Multiple Kernels 
for Parallel Evaluation
Problem
You want to run a command on several kernels simultaneously.
Solution
Use ParallelEvaluate to send commands to multiple kernels and wait for results to
complete. Use With to bind locally defined variables before distribution. 
Imagine you need to generate many random numbers and you want to distribute the
calculation across all available kernels. Here I use $KernelCount to make the computa-
tion independent of the number of kernels and Take to compensate for the extra num-
bers returned if $KernelCount does not divide 100 evenly. 
648 | Chapter 16: Parallel Mathematica

In[2]:=
TakeAFlattenAParallelEvaluateA
RandomIntegerA8-100, 100<, CeilingA100ë $KernelCount EEEE, 100E
Out[2]=
883, -11, 5, -15, -11, -24, 6, -75, 74, 27, -42, 95, 100, -83, -91, -81, 25,
-91, -96, -98, 9, 47, 44, 44, -81, 17, 10, -66, -40, -31, -30, 96, -55,
92, -76, 5, -44, -79, -83, 51, -36, -93, -1, 12, 34, -68, -8, 29, 9, 1,
44, 39, -1, 10, -80, -25, 62, 58, 88, -49, 77, 44, -48, 13, -69, -80, -39,
-44, -37, 95, 34, -81, -8, 33, -79, 86, -97, 29, -29, -19, 22, 50, 4, 95,
-55, -99, -98, 9, -61, -7, 0, -66, -14, -26, 95, 47, -35, -24, -29, -23<
In[3]:=
Length@%D
Out[3]=
100
If you want to make the number of random numbers into a variable, you need to use
With since variable values are not known across multiple kernels by default.
In[4]:=
vars = WithA8num = 1000<, TakeAFlattenAParallelEvaluateA
RandomIntegerA8-100, 100<, CeilingAnumë $KernelCount EEEE, numEE;
Length@
varsD
Out[5]=
1000
Discussion
Since  ParallelEvaluate  simply  ships  the  command  as  stated  to  multiple  kernels,
there needs to be something that inherently makes the command different for each
kernel; otherwise you just get the same result back multiple times.
In[6]:=
ParallelEvaluate@Sin@Piê3DD
Out[6]=
;
3
2
,
3
2
,
3
2
,
3
2
?
You can control which kernels ParallelEvaluate uses by passing as a second argu-
ment  the  list  of  kernel  objects  you  want  to  use.  The  available  kernel  objects  are
returned by the function Kernels[].
In[7]:=
Kernels@D
Out[7]=
9KernelObject@1, localD, KernelObject@2, localD,
KernelObject@3, localD, KernelObject@4, localD=
Here  you  evaluate  the  kernel  ID  and  process  ID  of  the  first  kernel  returned  by
Kernels[] and then for all but the last kernel.
In[8]:=
link = Kernels@D@@1DD;
ParallelEvaluateA9$KernelID, $ProcessID=, linkE
Out[9]=
81, 2478<
16.3 Sending a Command to Multiple Kernels for Parallel Evaluation | 649

In[10]:=
ParallelEvaluateA9$KernelID, $ProcessID=, Drop@Kernels@D, 1DE
Out[10]=
882, 2479<, 83, 2480<, 84, 2481<<
If  you  use  Do  or  Table  with  ParallelEvaluate,  you  may  not  get  the  result  you
expect since the iterator variable will not be known on remote kernels. You must use
With to bind the iteration variable before invoking ParallelEvaluate. 
In[11]:=
TableAWithA8i = i<, ParallelEvaluateASin@PiêiD,
Kernels@DAAModAi, $KernelCountE + 1EEEE, 8i, 1, 10<E
Out[11]=
;0, 1,
3
2
,
1
2
,
5
8
-
5
8
,
1
2
, SinC
p
7
G, SinC
p
8
G, SinC
p
9
G,
1
4
-1 +
5
?
In any case, you don’t want to use ParallelEvaluate with Table because this will ef-
fectively serialize the computation across multiple kernels rather than execute them
in parallel. You can see this by using AbsoluteTiming.
In[12]:=
AbsoluteTimingATableAParallelEvaluateAPause@1D;
0, Kernels@DAAModAj, $KernelCountE + 1EEE, 9j, 1, 4=EE
Out[12]=
84.010592, 80, 0, 0, 0<<
ParallelEvaluate is useful for interrogating the remote kernels to check their state.
For example, a common problem with parallel processing occurs when the remote
kernels are not in sync with the master with respect to definitions of functions. 
In[13]:=
ClearAmyFuncE;
OptionsAmyFuncE = 8option1 Ø 2<;
myFunc@x_, opts : OptionsPattern@DD := OptionValue@option1D * x;
DistributeDefinitionsAmyFuncE;
OptionsAmyFuncE = 8option1 Ø 3<;
ParallelEvaluateAOptionsAmyFuncEE
Out[14]=
88option1 Ø 2<, 8option1 Ø 2<, 8option1 Ø 2<, 8option1 Ø 2<<
In[15]:=
OptionsAmyFuncE
Out[15]=
8option1 Ø 3<
See Also
See the Mathematica documentation for ParallelTable and ParallelArray for better
ways to parallelize Table-like operations.
650 | Chapter 16: Parallel Mathematica

16.4 Automatically Parallelizing Existing 
Serial Expressions
Problem
You have code that you wrote previously in a serial fashion and you want to experi-
ment with parallelization without rewriting.
Solution
Use  Parallelize  to  have  Mathematica  decide  how  to  distribute  work  across
multiple  kernels.  To  demonstrate,  I  first  generate  1,000  large  random  semiprimes
(composite numbers with only two factors).
In[16]:=
semiprimes =
Times üüü MapAPrime, RandomInteger@810 000, 1 000 000<, 81000, 2<D, 82<E;
In[17]:=
Prime@10000D
Out[17]=
104729
Using Parallelize, these semiprimes are factored in ~0.20 seconds.
In[18]:=
9timing1, result= =
AbsoluteTimingAParallelizeAMapAFactorInteger, semiprimesEEE; timing1
Out[18]=
0.206849
Running on a single kernel takes ~0.73 seconds, giving a 3.6 times speedup on my
eight-core machine.
In[19]:=
9timing2, result= = AbsoluteTimingAMapAFactorInteger, semiprimesEE; timing2
Out[19]=
0.737002
In[20]:=
timing2ë timing1
Out[20]=
3.563
If you replace AbsoluteTiming with Timing, you measure an 8 times speedup on this
problem, so the cost of communicating results back to the frontend is significant. 
Discussion
In the solution, I did not use any user-defined functions, so Parallelize was all that
was necessary. In a more realistic situation, you will first need to DistributeDefinitions
of user-defined functions and constants to all kernels before using Parallelize.
16.4 Automatically Parallelizing Existing Serial Expressions | 651

In[21]:=
fmaxFactorAx_IntegerE := MaxAPower üüü FactorInteger@xDE
fmaxFactor@1000D
Out[22]=
125
In[23]:=
DistributeDefinitions@fmaxFactorD;
Parallelize@Map@fmaxFactor, semiprimesDD êê Short
Out[24]=
811124193, 11988217, 12572531, 3331 357, 15 447 821, 11 540 261,
715643, 5844217, 9529441, 8574353, 3 133 597, 9 773 531, á976à,
10027051, 7012807, 13236779, 13258 519, 11 375 971, 7 156 727,
13759661, 15155867, 13243157, 8888 531, 11 137 717, 1 340 891<
Parallelize will consider listable functions, higher-order functions (e.g., Apply, Map,
MapThread), reductions (e.g., Count, MemberQ), and iterations (Table). 
There  is  a  natural  trade-off  in  parallelization  between  controlling  the  overhead  of
splitting a problem or keeping all cores busy. A coarse-grained approach splits the
work into large chunks based on the number of kernels. If a kernel finishes its chunk
first, it will remain idle as the other kernels complete their work. In contrast, a fine-
grained approach uses smaller chunks and therefore has a better chance of keeping
cores occupied, but the trade-off is increased communications overhead.
In[26]:=
9timing1, result= = AbsoluteTimingAParallelizeA
MapAFactorInteger, semiprimesE, Method Ø "CoarsestGrained"EE; timing1
Out[26]=
0.240895
In[27]:=
9timing2, result= = AbsoluteTimingAParallelizeA
MapAFactorInteger, semiprimesE, Method Ø "FinestGrained"EE; timing2
Out[27]=
0.862007
In[28]:=
timing2ë timing1
Out[28]=
3.57835
You  can  use  Parallelize  to  implement  a  parallel  version  of  MapIndexed  since
Mathematica 7 does not have this as a native operation (it does have ParallelMap,
which I will discuss in Recipe 16.6).
In[29]:=
parallelMapIndexed@func_, expr_, opts : OptionsPattern@DD := Parallelize@
MapIndexed@func, exprD, FilterRules@opts, Options@ParallelizeDDD
parallelMapIndexed@func_, expr_, levelspec_, opts : OptionsPattern@DD :=
Parallelize@MapIndexed@func, expr, levelspecD,
FilterRules@opts, Options@ParallelizeDDD
652 | Chapter 16: Parallel Mathematica

In[31]:=
parallelMapIndexedAÒ1^First@Ò2D &, Range@10DE
Out[31]=
ParallelizeBMapIndexedBÒ1First@Ò2D &, 81, 2, 3, 4, 5, 6, 7, 8, 9, 10<F,
FilterRules@8Method Ø Automatic<DF
16.5 Distributing Data Segments in Parallel 
and Combining the Results
Problem
You want to parallelize a function that can be fed chunks of a list in parallel and the
intermediate results combined to yield the final answer. 
Solution
Use  ParallelCombine  to  automatically  divvy  up  the  processing  among  available
kernels. Here we generate a list of integers and ask Mathematica to feed segments
of the list to Total with each segment running on a different kernel. The individual
totals are then combined with the function Plus to arrive at the grand total.
In[32]:=
integersList = RandomInteger@80, 10^8<, 10 000 000D;
ParallelCombineATotal, integersList, PlusE
Out[33]=
500152672039330
In[34]:=
Flatten@8Outer@Min, 89, 9, 9, 10<, 83, 4<D, Outer@Max, 89, 9, 9, 10<, 83, 4<D<D
Out[34]=
83, 4, 3, 4, 3, 4, 3, 4, 9, 9, 9, 9, 9, 9, 10, 10<
Discussion
ParallelCombine can be applied to optimization problems where the goal is to find
the best of a list of inputs. Here I use Max as the objective function, but in practice
this  would  only  be  useful  if  the  objective  function  was  computationally  intense
enough to justify the parallel processing overhead. If the objective function is equally
expensive for all inputs, you will want to specify MethodØ"CoarsestGrained".
In[35]:=
data = Union@RandomReal@80, 10.0<, 100 000DD;
ParallelCombine@Max, data, Max, Method Ø "CoarsestGrained"D
Out[36]=
9.99998
To get actual speedup with ParallelCombine, you  must  pick  problems  for  which
the data returned from each kernel is much smaller than the data sent. Here is an
example that has no hope for speedup even though  on  the  surface  it  may  seem
16.5 Distributing Data Segments in Parallel and Combining the Results | 653

compelling. Here, the idea is to speed up a Sort by using ParallelCombine to Sort
smaller segments, and then perform a final merge on the sorted sections.
In[37]:=
data = RandomInteger@81, 100<, 100 000D;
AbsoluteTiming@ParallelCombine@Sort, data,
Sort@Flatten@ÒDD &, Method Ø "CoarsestGrained"DD êê Short
Out[38]=
80.047581, 81, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, á24 942à, 100, 100, 100,
100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100<<
Here you can see that a plain Sort in a single kernel is an order of magnitude faster.
If you think this has to do with using  Sort[Flatten[#]]  as  the  merge  function,
think again. 
In[39]:=
AbsoluteTiming@Sort@dataDD êê Short
Out[39]=
80.018599, 81, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, á99 942à, 100, 100, 100,
100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100<<
Even if you use Identity to make the merge a no-op, the distributed "Sort" will be
significantly slower. Adding more data or more process will not help because it only
exacerbates the communications overhead.
In[40]:=
AbsoluteTimingAParallelCombineASort, data,
Identity@Flatten@ÒDD &, Method Ø "CoarsestGrained"EE êê Short
Out[40]=
80.091931, 81, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, á24 942à, 100, 100, 100,
100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100<<
16.6 Implementing Data-Parallel Algorithms 
by Using ParallelMap
Problem
You want to map a function across a list of data by executing the function in parallel
for different items in a list.
654 | Chapter 16: Parallel Mathematica

Solution
Functional styles of programming often lead naturally to parallel implementation, es-
pecially when functions are side-effect free. ParallelMap is the parallel counterpart to
Map (/@). It will spread the execution of the Map operation across available kernels.
In[41]:=
ParallelMapAPrimeOmega, RandomInteger@810^40, 10^50<, 32DE
Out[41]=
85, 5, 5, 5, 4, 2, 1, 6, 1, 7, 10, 7, 5, 7,
6, 7, 7, 5, 4, 9, 10, 5, 7, 6, 4, 6, 8, 3, 12, 7, 7, 4<
Discussion
Here I compare the performance of ParallelMap with regular Map on a machine run-
ning four slave kernels. You can see that the speedup is less than the theoretical limit
due to overhead caused by communication with the kernels and other inefficiencies
inherent in ParallelMap’s implementation. 
In[42]:=
ModuleA9data = RandomInteger@810^40, 10^50<, 32D=,
SeedRandom@8D;
ColumnA9
AbsoluteTimingAParallelMapAPrimeOmega, dataEE,
AbsoluteTimingAMapAPrimeOmega, dataEE=EE
Out[43]=
811.794302, 85, 6, 8, 7, 5, 5, 2, 7, 6, 5, 9, 6,
6, 8, 7, 4, 6, 5, 14, 8, 2, 5, 3, 5, 6, 5, 7, 4, 5, 3, 3, 5<<
818.872163, 85, 6, 8, 7, 5, 5, 2, 7, 6, 5, 9, 6,
6, 8, 7, 4, 6, 5, 14, 8, 2, 5, 3, 5, 6, 5, 7, 4, 5, 3, 3, 5<<
ParallelMap is a natural way to introduce parallelism using a functional style. When
you have a computationally intensive function you need to execute over a large data
set, it often makes sense to execute the operations in parallel by allowing Mathemat-
ica to split the mapping among multiple kernels. 
Like Map, ParallelMap can accept a levelspec as a third argument to control the parts
of the expression that are mapped. For example, here I count the satisfiability count
for all Boolean functions of one to four variables, where each function of a particular
variable count is grouped together at level two in the list. The entire output is large,
so I abbreviate using Short.
16.6 Implementing Data-Parallel Algorithms by Using ParallelMap | 655

In[44]:=
ParallelMapASatisfiabilityCount@BooleanFunction üü ÒD &,
Table@8n, v<, 8v, 1, 4<, 8n, 1, 2^2^v<D, 82<E êê Short
Out[44]=
881, 1, 2, 0<, á2à, 81, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2,
3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, á65 460à, 14, 13,
14, 14, 15, 11, 12, 12, 13, 12, 13, 13, 14, 12, 13, 13, 14, 13, 14, 14,
15, 12, 13, 13, 14, 13, 14, 14, 15, 13, 14, 14, 15, 14, 15, 15, 16, 0<<
16.7 Decomposing a Problem into Parallel 
Data Sets
Problem
You have a problem that involves computation across a large data set, and you parti-
tion the data set into chunks that can be processed in parallel.
Solution
A simple example of this problem is where the computation occurs across a data set
that  can  be  generated  by  Table.  Here  you  can  simply  substitute  ParallelTable.
For example, visualizing the Mandelbrot set requires performing an iterative compu-
tation  on  each  point  across  a  region  of  the  complex  plane  and  assigning  a  color
based  on  how  quickly  the  iteration  explodes  toward  infinity.  Here  I  use  a  simple
grayscale mapping for simplicity. 
656 | Chapter 16: Parallel Mathematica

In[45]:=
Clear@mbrotColorD
mbrotColor@c_ComplexD := ModuleA8max = 100, r<,
r = NestWhile@8Ò@@1DD + 1, Ò@@2DD^2 + c< &,
80, c<, Norm@Ò@@2DDD < 2 &, 1, maxD@@1DD;
H*Map r onto a grayscale value. Squaring is for finer detail.*L
1.0 - HHmax - rLêmaxL^2E
DistributeDefinitions@mbrotColorD
WithA9granularity = 0.004=,
ArrayPlotATransposeAParallelTableAmbrotColorAi + j IE,
9i, -2, 0.75, granularity=,
9j, -1, 1, granularity=EE, ImageSize Ø 450EE
Out[46]=
Discussion
ParallelTable has many useful applications. Plotting a large number of graphics is a
perfect  way  to  utilize  a  multicore  computer.  Parallel  processing  makes  you  a  lot
more productive when creating animations, for example. 
16.7 Decomposing a Problem into Parallel Data Sets | 657

In[47]:=
images = ParallelTableA
SphericalPlot3DAIf@q < Piê4, None, 1êHf + 5 LD, 8q, 0, Pi<, 8f, 0, i Pi<,
PlotStyle Ø DirectiveAOrange, Specularity@White, 10DE, Mesh Ø None,
PlotPoints Ø 30, Axes Ø None, Boxed Ø FalseE, 8i, 1, 8, 0.25<E;
ListAnimateAimages, ImageSize Ø SmallE
Out[48]=
You  can  also  generate  multiple  data  sets  in  parallel,  which  you  can  then  plot  or
process further.
In[49]:=
ListLinePlot@ParallelTable@ Sin@n Pi xDên, 8n, 1, 4<, 8x, 0, 2 Pi, 0.01<DD
Out[49]=
100
200
300
400
500
600
-1.0
-0.5
0.5
1.0
658 | Chapter 16: Parallel Mathematica

16.8  Choosing an Appropriate 
Distribution Method
Problem
You  want  to  parallelize  an  operation  whose  runtime  varies  greatly  over  different
inputs.
Solution
The parallel primitives Parallelize, ParallelMap, ParallelTable, ParallelDo, ParallelSum,
and ParallelCombine support an option called Method, which allows you to specify
the granularity of subdivisions used to distribute the computation across kernels. 
Use Method Ø "FinestGrained" when the completion time of each atomic unit of com-
putation  is  expected  to  vary  widely.  "FinestGrained"  prevents  Mathematica  from
committing work units to a kernel until a scheduled work unit is complete. To illus-
trate  this,  create  a  function  for  which  the  completion  time  can  be  controlled  via
Pause.  Then  generate  a  list  of  small  random  delays  and  prepend  to  that  a  much
larger delay to simulate a long-running computation. 
In[50]:=
SeedRandom@11D;
delays = RandomReal@80.1, 0.15<, 200D;
H*Add a long
20-second delay to simulate a bottleneck in the computation.*L
PrependToAdelays, 20.0E;
funcWithDelayAdelay_E := ModuleA8<, PauseAdelayE; delayE
DistributeDefinitionsAfuncWithDelayE;
Since the pauses are distributed over several cores, we expect the actual delay to be
less  than  the  total  delay,  and  that  is  what  we  get.  However,  by  specifying
"CoarsestGrained",  we  tell  Mathematica  to  distribute  large  chunks  of  work  to  the
kernels. This effectively results in jobs backing up behind the ~20-second delay.
In[52]:=
AbsoluteTimingA
TotalAParallelMapAfuncWithDelay, delays, Method Ø "CoarsestGrained"EEE
Out[52]=
826.403951, 44.8136<
When we run the same computation with Method Ø "FinestGrained", our actual com-
pletion time drops by 6 seconds since the remaining cores are free to receive more
work units as soon as they complete a given work unit. 
16.8  Choosing an Appropriate Distribution Method | 659

In[53]:=
AbsoluteTimingA
TotalAParallelMapAfuncWithDelay, delays, Method Ø "FinestGrained"EEE
Out[53]=
820.040469, 44.8136<
Contrast this to the case where the expected computation time is very uniform. Here
Method Ø "CoarsestGrained" has a distinct advantage since there is less overhead in
distributing work in one shot than incrementally.
In[54]:=
delays = Table@0.1, 8800<D;
In[55]:=
AbsoluteTimingA
TotalAParallelMapAfuncWithDelay, delays, Method Ø "CoarsestGrained"EEE
Out[55]=
820.112191, 80.<
Here we see that Method Ø "FinestGrained" only has a slight disadvantage, but that
disadvantage would increase with larger payloads and remotely running kernels.
In[56]:=
AbsoluteTimingA
TotalAParallelMapAfuncWithDelay, delays, Method Ø "FinestGrained"EEE
Out[56]=
820.973056, 80.<
Discussion
If you have ever been to the bank, chances are you stood in a single line that served
several tellers. When a teller became free, the person at the head of the line went to
that  window.  It  turns  out  that  this  queuing  organization  produces  higher  overall
throughput because different customers’ bank transactions take varying amounts of
time, while presumably each teller is equally skilled at handling a variety of transac-
tions. This setup is analogous to the effect you get when using "FinestGrained".
If  there  were  no  overhead  involved  in  communication,  "FinestGrained"  would  be
ideal. But, returning to the analogy with the bank, it is often the case that the person
who is next in line fails to notice a teller has become free and a delay is introduced.
This  is  analogous  to  the  master-slave  overhead:  the  master  must  receive  a  result
from the slave and move the next work unit into the freed-up slave. Each such ac-
tion has overhead, and this overhead can swamp any gains obtained from making
immediate use of an available slave.
In  many  problems,  it  is  best  to  let  Mathematica  balance  these  trade-offs  by  using
MethodØAutomatic, which is what you get by default when no Method is explicitly
specified. Under this scenario, Mathematica performs a moderate amount of chunk-
ing of work units to minimize communication overhead while not committing too
many units to a single slave and thus risking wasted computation when one slave
finishes before the others. 
660 | Chapter 16: Parallel Mathematica

See Also
There  are  a  few  less  important  Method  options  ("EvaluationsPerKernel"  and
"ItemsPerEvaluation") that are covered under the Parallelize function in Mathemati-
ca’s documentation. These give you more precise control over the distribution of work.
16.9 Running Different Algorithms in Parallel 
and Accepting the First to Complete
Problem
You have several different ways to solve a problem and are uncertain which will com-
plete fastest. Typically, one algorithm may be faster on some inputs, while another
will be faster on other inputs. There is no simple computation that makes this deter-
mination at lower cost than running the algorithms themselves.
Solution
Use  ParallelTry  to  run  as  many  versions  of  your  algorithm  as  you  have  available
slave  kernels.  There  are  several  ways  to  use  ParallelTry,  but  the  differences  are
largely  syntactical.  If  your  algorithms  are  implemented  in  separate  functions  (e.g.,
algo1[data_], algo2[data_], and algo3[data_]), you can use ParallelTry, as in the
following example. Here I merely simulate the uncertainty of first completion using
a random pause.
In[57]:=
RandomSeed@13D;
algo1@data_D := ModuleA8<, PauseARandomInteger@81, 10<DE; data^2E
algo2@data_D := ModuleA8<, PauseARandomInteger@81, 10<DE; data^3E
algo3@data_D := ModuleA8<, PauseARandomInteger@81, 10<DE; data^4E
DistributeDefinitionsAalgo1, algo2, algo3E
algo@data_D := ParallelTryAComposition@ÒD@dataD &, 9algo1, algo2, algo3=E
In[59]:=
algo@2D
Out[59]=
4
Discussion
Sometimes you can choose variations to try by passing different function arguments.
Here I minimize a BooleanFunction of 30 variables using ParallelTry with four of the
forms supported by BooleanMinimize. 
16.9 Running Different Algorithms in Parallel and Accepting the First to Complete | 661

In[60]:=
ParallelTry@8Ò, BooleanMinimize@BooleanFunction@10 000, 30D, ÒD< &,
8"DNF", "CNF", "NAND", "NOR"<D
Out[60]=
8CNF, ! Ò1 && ! Ò2 && ! Ò3 && ! Ò4 && ! Ò5 && ! Ò6 && ! Ò7 && ! Ò8 &&
! Ò9 && ! Ò10 && ! Ò11 && ! Ò12 && ! Ò13 && ! Ò14 && ! Ò15 && ! Ò16 &&
! Ò17 && ! Ò18 && ! Ò19 && ! Ò20 && ! Ò21 && ! Ò22 && ! Ò23 && ! Ò24 &&
! Ò25 && ! Ò26 && H! Ò27 »» ! Ò28 »» Ò30L && HÒ27 »» Ò28L &&
HÒ27 »» ! Ò30L && H! Ò28 »» ! Ò29L && H! Ò29 »» ! Ò30L &<
Another  possibility  is  that  you  have  a  single  function  that  takes  different  options,
indicating  different  computational  methods.  Many  advanced  numerical  algorithms
in Mathematica are packaged in this manner.
In[61]:=
WeierstrassFunction@a_, x_D := Sum@Sin@Pi k^a xDêHPi k^aL, 8k, 100<D
DistributeDefinitions@WeierstrassFunctionD
In[63]:=
ParallelTryA
9Ò, FindMinimumASinAWeierstrassFunctionASin@xD, SinA2 yEEE,
98x, 0.6<, 9y, 0.6==, WorkingPrecision Ø 48, Method Ø ÒE= &,
9"Gradient", "ConjugateGradient", "InteriorPoint", "QuasiNewton", "Newton"=E
Out[63]=
9QuasiNewton, 9-1.00000000000000000000000000000000000000000000000,
9x Ø 0.104539716554326205174773982146950548720470352834,
y Ø 0.510629205999258520978426706655563835929211167845===
16.10 Sharing Data Between Parallel Kernels
Problem
Your  parallel  implementations  need  to  communicate  via  one  or  more  variables
shared across kernels.
Solution
Mathematica provides SetSharedVariable as a means of declaring one or more vari-
ables as synchronized across all parallel kernels. Similarly, SetSharedFunction is used
to synchronize the down values of a symbol. In the following example, the variable
list is shared and each slave kernel is thus able to prepend its $KernelID. 
In[64]:=
SetSharedVariable@listD; list = 8<;
ParallelEvaluateAPrependToAlist, $KernelIDEE;
list
Out[65]=
84, 3, 2, 1<
662 | Chapter 16: Parallel Mathematica

Discussion
Consider a combinatorial optimization problem like the traveling salesperson prob-
lem (TSP). You might want all kernels to be aware of the best solution found by any
given kernel thus far so that each kernel can use this information to avoid pursuing
suboptimal solutions. Here I use a solution to the TSP based on simulated annealing.
In[66]:=
dist = TableAIfAi <= j, 0, RandomReal@81, 10<DE, 8i, 1, 10<, 9j, 1, i=E;
16.11 Preventing Race Conditions When 
Multiple Kernels Access a Shared Resource
Problem
Prior to Mathematica 7, users never had to think about problems like race condi-
tions because all processing occurred in a single thread of execution. Parallel process-
ing creates the possibility of subtle bugs caused by two or more kernels accessing a
shared resource such as the file system or variables that are shared. These resources
are not subject to atomic update or synchronization unless special care is taken. 
Solution
Consider a situation where each parallel task needs to update a shared data structure
like  a  list.  Here  I  create  a  simplified  example  with  a  shared  list.  Each  kernel  is
instructed to prepend its $KernelID to the list 10 times. If all goes well, we should see
10 IDs for each kernel. I use Tally to see if that is the case. The random pause is
there to inject a bit of unpredictability into each computation to simulate a more real-
istic computation.
In[67]:=
SetSharedVariable@aListD; aList = 8<;
ParallelEvaluateADoAaList = PrependAaList, $KernelIDE;
Pause@RandomReal@80.01, 0.1<DD, 810<EE;
Tally@
aListD
Out[68]=
882, 7<, 81, 8<, 83, 4<, 84, 7<<
16.11 Preventing Race Conditions When Multiple Kernels Access a Shared Resource | 663

Clearly this is not the result expected, since not one of the $KernelID’s showed up 10
times. The problem is that each kernel may interfere with the others as it attempts to
modify the shared list. This problem is solved by the use of CriticalSection.
In[69]:=
SetSharedVariable@aListD; aList = 8<;
ParallelEvaluateA
DoACriticalSectionA8aListLock<, aList = PrependAaList, $KernelIDEE;
Pause@RandomReal@80.01, 0.1<DD, 810<EE;
Tally@
aListD
Out[70]=
884, 10<, 83, 10<, 81, 10<, 82, 10<<
Much better. Now each kernel ID appears exactly 10 times. 
Discussion
A  critical  section  is  a  mutual  exclusion  primitive  implemented  in  terms  of  one  or
more locks. The variables passed, as in the list (first argument to CriticalSection),
play the role of the locks. A kernel must get control of all locks before it is allowed
to enter the critical section. You may wonder why you would ever need more than
one lock variable. Consider the case where there are two shared resources and three
functions that may be executing in parallel. Function f1 accesses resource r1, which
is protected by lock l1. Function f2 accesses resource r2, which is protected by lock
l2. However, function f3 accesses both r1 and r2, so it must establish both locks.
The following example illustrates.
In[71]:=
SetSharedVariable@r1, r2, r3D;
r1 = 8<; r2 = 8<; r3 = 8<;
f1@x_D :=
Module@8<, CriticalSection@8l1<, PrependTo@r1, xDDD
f2@x_D :=
Module@8<, CriticalSection@8l2<, PrependTo@r2, xDDD
f3@D :=
Module@8<, CriticalSection@8l1, l2<, r3 = Join@r1, r2DDD
If f1, f2, and f3 happen to be running in three different kernels, f1 and f2 will be
able to enter their critical sections simultaneously because they depend on different
locks, but f3 will be excluded. Likewise, if f3 has managed to enter its critical sec-
tion, both f1 and f2 will be locked out until f3 exits its critical section.
Keep  in  mind  that  shared  resources  are  not  only  variables  used  with  SetShared-
Variable. They might be any resource that a kernel could gain simultaneous access
to, including the computer’s file system, a database, and so on. 
664 | Chapter 16: Parallel Mathematica

It should not come as a surprise that critical sections can reduce parallel processing
performance since they effectively define sections of code that can only execute in
one kernel at a time. Further, there is a loss of liveliness since a kernel that is waiting
on a lock cannot detect instantaneously that the lock has been freed. In fact, if you
dig into the implementation (the entire source code for Mathematica 7’s parallel pro-
cessing  primitives  is  available  in  Parallel.m  and  Concurrency.m)  you  will  see  that
a kernel enters into a 0.1-second pause while waiting on a lock. This implies that
CriticalSection should be used sparingly, and if possible, you should find ways to
structure  a  program  to  avoid  it  altogether.  One  obvious  way  to  do  this  is  to  rely
largely  on  the  data  parallelism  primitives  like  ParallelMap  and  ParallelTable  and
only integrate results of these operations in the master kernel. However, advanced
users may want to experiment with more subtle parallel program designs, and it is
handy that synchronization is available right out of the box. 
See Also
In Recipe 16.13, I implement the map-reduce algorithm where CriticalSection is nec-
essary to synchronize access to the file system. 
16.12 Organizing Parallel Processing Operations 
Using a Pipeline Approach
Problem
You have a computation that involves processing many data sets where the computa-
tion  can  be  viewed  as  data  flowing  through  several  processing  steps.  This  type  of
computation is analogous to an assembly line. 
Solution
An easy way to organize a pipeline is to create a kind of to-do list and associate it
with each data set. The master kernel loads the data, tacks on the to-do list and a
job identifier, and then submits the computations to an available slave kernel using
ParallelSubmit.  The  slave  takes  the  first  operation  off  the  to-do  list,  performs
the operation, and returns the result to the master along with the to-do list and job
identifier it was given. The master then records the operation as complete by remov-
ing the first item in the to-do list and submits the data again for the next step. Pro-
cessing is complete when the to-do list is empty. Here I use Reap and Sow to collect
the final results.
16.12 Organizing Parallel Processing Operations Using a Pipeline Approach | 665

In[73]:=
slaveHandlerAinput_, todo_, jobId_E := ModuleA8result<,
result = First@todoD@inputD;
9todo, result, jobId=
E
DistributeDefinitions@slaveHandlerD;
pipelineProcessor@inputs_, todo_D :=
ModuleA8pids, result, id<,
ReapA
pids = With@8todo1 = todo<,
MapIndexed@ParallelSubmit@slaveHandler@Ò, todo1,
First@Ò2DDD &, inputsDD;
WhileApids =!= 8<,
8result, id, pids< = WaitNext@pidsD;
IfALength@result@@1DDD > 1,
AppendToApids,
WithA9todo1 = Rest@result@@1DDD, in = result@@2DD, jobId =
result@@3DD=, ParallelSubmitAslaveHandlerAin, todo1, jobIdEEEE,
Sow@8Last@FileNameSplit@inputs@@result@@3DDDDDD, result@@2DD<
D;
E
E;
True
E
E
To illustrate this technique, I use an image-processing problem. In this problem, a
number of images need to be loaded, resized, sharpened, and then rotated. For sim-
plicity,  I  assume  all  images  will  use  the  same  parameters.  You  can  see  that  the
to-do list is manifested as a list of functions.
In[75]:=
files = FileNameJoinA9NotebookDirectory@D, "..", "images", Ò=E & êü
9"image1.jpg", "image2.jpg", "image3.jpg"=;
todoList = 9Import@ÒD &, ImageResize@Ò, 100D &,
Sharpen@ÒD &, ImageRotateAÒ, RightE &=;
Grid üü pipelineProcessor@files, todoListD@@2DD
666 | Chapter 16: Parallel Mathematica

Out[76]=
image2.jpg
image1.jpg
image3.jpg
Discussion
The solution illustrates a few points about using ParallelSubmit that are worth not-
ing even if you have no immediate need to use a pipeline approach to parallelism.
First,  note  the  use  of  MapIndexed  as  the  initial  launching  pad  for  the  jobs.
MapIndexed is ideal for this purpose because the generated index is perfect as a job
identifier. The jobId plays no role in slaveHandler but is simply returned back to the
master. This jobId allows the master to know what initial inputs were sent to the re-
sponding slave. Similarly, you may wonder why the whole to-do list is sent to the
slave if it is only going to process the first entry. The motivation is simple. This ap-
proach frees pipelineProcessor from state management. Every time it receives a re-
sponse from a slave, it knows immediately what functions are left for that particular
job. This approach is sometimes called stateless because neither the master nor the
slaves need to maintain state past the point where one transfers control to the other.
16.12 Organizing Parallel Processing Operations Using a Pipeline Approach | 667

Also note the use of With as a means of evaluating expressions before they appear in-
side  the  arguments  of  ParallelSubmit.  This  is  important  because  ParallelSubmit
keeps  expressions  in  held  form  and  evaluating  those  expressions  on  slave  cores  is
likely to fail because the data symbols (like todo and result) don’t exist there. 
A reasonable question to ask is, why use this approach at all? For instance, if you
know you want to perform five operations on an image in sequence, why not just
wrap them up in a function and use ParallelMap to distribute images for processing?
For some cases, this approach is indeed appropriate. There are a few reasons why a
pipeline technique might still make sense.
Intermediate results
For some problems, you want to keep the intermediate results of each step. By
returning  the  intermediate  results  back  to  the  master,  you  can  keep  the  code
that  knows  what  needs  to  be  done  with  the  result  out  of  the  logic  that  is
distributed to the slaves. This is a nice way to reduce overall complexity, and it
works when the slaves don’t have the appropriate access to a database or other
storage area where the intermediate results are to be archived.
Checkpointing
Even if you don’t care about intermediate steps, you may want to checkpoint
each immediate calculation, especially if that calculation was quite expensive to
compute. Then, if some later step fails, you do not lose everything computed up
to that point.
Managing complexity
The solution showed a very simplistic use case where there is a fixed to-do list
for each input. This is not the only possibility. It might be the case that each
input needs a specialized to-do list or, more ambitiously, the to-do list for any
input will change based on the results that return from intermediate steps. This
can, of course, be done with complex conditional logic distributed to the slaves,
but  overall  complexity  might  be  reduced  by  keeping  these  decisions  in  the
master pipeline logic. 
Branching pipelines
Slave kernels can’t initiate further parallel computations, so if an intermediate
result suggests a further parallel computation, control needs to be returned to
the master in any case. Of course, branching introduces a degree of complexity,
since  the  master  kernel  must  now  do  state  management  to  keep  track  of
progress along each branch.
668 | Chapter 16: Parallel Mathematica

16.13 Processing a Massive Number of Files 
Using the Map-Reduce Technique
Problem
You have a large number of data files that you need to process. Typically you need
to  integrate  information  from  these  files  into  some  global  statistics  or  create  an
index, sort, or cross-reference. The data from these files is too large to load into a sin-
gle Mathematica kernel.
Solution
Here I show a toy use case traditionally used to introduce mapReduce. The problem is
to process a large number of text files and calculate word frequencies. The principle
that makes mapReduce so attractive is that the user need only specify two, often sim-
ple, functions called the map function and the reduce function. The framework does
the rest. The map function takes a key and a value and outputs a different key and a
different value. The reduce function takes the key that was output by map and the list
of  all  values  that  map  assigned  to  the  specific  key.  The  framework’s  job  is  to  dis-
tribute the work of the map and reduce functions across a large number of processors
on a network and to group by key the data output by map before passing it to reduce. 
To make this concrete, I show how to implement the word-counting problem and
the top-level mapReduce infrastructure. In the discussion, I dive deeper into the nuts
and bolts.
First we need a map function. Recall that it takes a key and a value. Let’s say the key
is the name of a file and the value is a word that has been extracted from that file.
The output of the map function is another key and value. What should these outputs
be to implement word counting? The simplest possible answer is that the output key
should be the word and the output value is simply 1, indicating the word has been
counted. Note that the input key (the filename) is discarded, which is perfectly legiti-
mate if you have no need for it. In this case, I do not wish to track the word’s source. 
In[77]:=
countWordsAkey_, value_E := 8value, 1<
Okay, that was easy. Now we need a reduce function. Recall that the reduce func-
tion will receive a key and a list of all values associated to the key by the map func-
tion. For the case at hand, it means reduce will receive a word and a list of 1’s repre-
senting each time that word was seen. Since the goal is to count words, the reduce
function simply performs a total on the list. What could be easier?
In[78]:=
totalWordsAkey_, value_ListE := Total@valueD
16.13 Processing a Massive Number of Files Using the Map-Reduce Technique | 669

Here again I discard the key because the framework will automatically associate the
key to the output of reduce. In other applications, the key might be required for the
computation.
Surprisingly enough, these two functions largely complete the solution to the prob-
lem! Of course, something is missing, namely the map-reduce implementation that
glues everything together. Here is the top-level function that does the work. 
In[79]:=
Clear@mapReduceD;
Options@mapReduceD = 9
fileDisposition Ø DeleteFile,
intermediateFile Ø True,
saveDirectory ß $UserDocumentsDirectory,
keyToFilenamePrefix Ø Identity=;
mapReduce@inputs_List, map_,
reduce_, parser_ , opts : OptionsPattern@DD :=
ModuleA8<,
ParallelMapA
reducer@Ò, reduce, FilterRules@8opts<, Options@reducerDDD &,
mergeAllAParallelMap@mapper@Ò, parser, map,
FilterRules@8opts<, Options@mapperDDD &, inputsD,
FilterRulesA8opts<, OptionsAmergeAllEEEE
E
You  can  see  from  this  function  that  it  requires  a  list  of  inputs.  That  will  be
the list of files to process. It needs a function map, which in this example will be count-
Words,  and  a  function  reduce,  which  will  be  totalWords.  It  also  needs  something
called a parser. The parser is a function that breaks up the input file into the units
that map will process. Here I use a simple parser that breaks up a file into words. This
function  leverages  Mathematica’s  I/O  primitive  ReadList,  which  does  most  of  the
work. The only bit of postprocessing is to strip some common punctuation that Read-
List does not strip and to convert words to lowercase so counting is case insensitive.
In[81]:=
parseFileToWords@file_D := ModuleA8stream, words<,
stream = OpenRead@fileD;
words = ToLowerCaseASelectAReadList@stream, WordD, StringMatchQAÒ,
RegularExpressionA"^@A-Za-z0-9D@A-Za-z0-9-D*$"EE &EE;
Close@streamD;
words
E
Here is how you use the framework in practice. For test data, I downloaded a bunch
of files from http://www.textfiles.com/conspiracy/. I placed the names of these files in
670 | Chapter 16: Parallel Mathematica

another file called wordcountfiles and use Get to input this list. This is to avoid clut-
tering the solution with all these files.
In[82]:=
files = GetAFileNameJoinA9$UserDocumentsDirectory, "oreilly",
"Mathematica Cookbook", "data", "textfiles", "filelist.m"=EE;
In[83]:=
mapReduce@files, countWords, totalWords, parseFileToWordsD
Out[83]=
mergeAllAreducerA9mapperAêUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêa-z-cons.txt, parseFileToWords,
countWords, 8<E, mapperAêUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêafrica.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêaids-2.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêaids-war.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêaids.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêaids02.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêaidsconsp.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêair-rail.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêalt3.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêanti-jew.txt,
parseFileToWords, countWords, 8<E, áà mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêpvt-prop.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêpvtprop2.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêrat11.txt,
16.13 Processing a Massive Number of Files Using the Map-Reduce Technique | 671

parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêrealene.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêrfk1.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêright-lf.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêrightday.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêscrtgovt.txt,
parseFileToWords, countWords, 8<E, mapperA
êUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêtextfilesêêsecret.txt,
parseFileToWords, countWords, 8<E=, totalWords,
8<E, reducer@8<, totalWords,
8<DE
In[84]:=
% >> "mapReduce.out"
In[85]:=
?countWords
Global`countWords
countWords@key_, value_D := 8value, 1<
672 | Chapter 16: Parallel Mathematica

Discussion
If you want to try map-reduce, use the package files Dictionary.m and
MapReduce.m.  The  code  here  is  laid  out  primarily  for  explanation
purposes. You will need to add the following code to your notebook,
and don’t forget to use DistributeDefinitions with the functions you
create for map, reduce, and parse.
Needs["Cookbook`Dictionary`"]
Needs["Cookbook`MapReduce`"]
ParallelNeeds["Cookbook`Dictionary`"]
ParallelNeeds["Cookbook`MapReduce`"]
You can find examples of usage in mapReduce.nb.
If you are new to map-reduce you should refer to references listed in the “See Also”
section on page 678 before trying to wrap your mind around the low-level implemen-
tation. The original paper by the Google researchers provides the fastest high-level
overview and lists additional applications beyond the word-counting problem. The
most important point about map-reduce is that it is not an efficient way to use paral-
lel processing unless you have a very large number of files to process and a very large
number of networked CPUs to work on the processing.  The  ideal  use  case  is  a
problem for which the data is far too large to fit in the memory of a single computer,
mandating that the processing be spread across many machines. To illustrate, con-
sider how you might implement word counting across a small number of files.
In[86]:=
baseDir = FileNameJoinA
9$UserDocumentsDirectory, "oreilly", "Mathematica Cookbook", "data"=E;
files = FileNameJoin@8baseDir, Ò<D & êü 9"adventur.txt", "solitary.txt"=;
AbsoluteTimingATally@Flatten@parseFileToWords@ÒD & êü filesDDE êê Short
AbsoluteTiming@mapReduce@files, countWords, totalWords,
parseFileToWords, intermediateFile Ø FalseDD êê Short
Out[86]=
90.089739, 98adventure, 3<, 9solving, 1=, 8it, 77<, 8in, 123<,
9easy, 3=, 8steps, 1<, á1562à, 8viewed, 1<, 9gravely, 1=,
8reputation, 1<, 8sufficient, 1<, 9satisfy, 1=, 8demands, 1<==
Out[87]=
90.014468,
mergeAllAreducerA9mapperAêUsersêsmanganoêDocumentsêoreillyêMathematica
Cookbookêdataêadventur.txt, parseFileToWords, countWords, 8<E,
mapper@á1àD=, totalWords, 8<E, reducer@8<, á10à, 8<DE=
16.13 Processing a Massive Number of Files Using the Map-Reduce Technique | 673

The guts of our map-reduce implementation are a bit more complex than the other
parallel recipes. The low-level implementation details have less to do with parallel
processing than with managing the data as it flows though the distributed algorithm.
A key data structure used is a dictionary which stores the intermediate results of a sin-
gle file in memory. This makes use of a packaged version of code I introduced in
Recipe 3.13 and won’t repeat here.
The function mapAndStore is responsible for applying the map function to a key value
pair  and  storing  the  result  in  a  dictionary.  The  dictionary  solves  the  problem  of
grouping all identical keys for a given input file.
In[88]:=
mapAndStoreA9key1_, value1_=, map_, dict_DictionaryE :=
ModuleA9key2, value2=,
9key2, value2= = mapAkey1, value1E;
IfAkey2 =!= Null,
dictStoreAdict, key2, value2EE
E
The default behavior of mapReduce is to store intermediate results in a file. The func-
tions uniqueFileName, nextUniqueFile, and saver have the responsibility of synthesiz-
ing the names of these files and storing the results. The filename is derived from the
key, and options saveDirectory and keyToFilenamePrefix help to customize the
behavior.  These  options  are  provided  in  the  top-level  mapReduce  call.  Here  save-
Directory provides a directory where the intermediate files will be stored. This
directory must be writable by all slave kernels. Use keyToFilenamePrefix to specify a
function that maps the key to a filename prefix. This function is necessary for cases
where the key might not represent a valid filename. 
674 | Chapter 16: Parallel Mathematica

In[89]:=
nextUniqueFileAexistingFile_E := StringReplaceAexistingFile,
num : RegularExpression@"\d+"D ß WithA8n = ToExpression@numD<,
ToStringA
IfAn < 999, PaddedFormAn + 1, 3, NumberPadding Ø 8"0", ""<E,
n + 1EEE
E
uniqueFilename@base_, dir_D := ModuleA9baseFile, existingFiles=,
baseFile = FileNameJoinA9dir, ToString@baseD=E;
H*Ensure only one kernel goes for the next file.*L
CriticalSectionA8uniqueFilenameLock<,
existingFiles = Sort@FileNames@baseFile <> ".*." <> "mr"DD;
IfAexistingFiles === 8<, baseFile <> ".0001.mr",
nextUniqueFileALastAexistingFilesEEE
E
E
Clear@saverD;
Options@saverD = 9
saveDirectory ß $UserDocumentsDirectory,
keyToFilenamePrefix Ø Identity
=;
saverA9key_, values_List=, OptionsPattern@DE :=
ModuleA8filename, stream, prefix<,
prefix = OptionValueAkeyToFilenamePrefixEAkeyE;
filename =
uniqueFilenameAReleaseHold@prefixD, OptionValueAsaveDirectoryEE;
stream = OpenWrite@filenameD;
Write@stream, valuesD;
Close@streamD;
9key, filename=E
ClearAsaveKeyValuesE;
OptionsAsaveKeyValuesE = 9
saveDirectory ß $UserDocumentsDirectory,
keyToFilenamePrefix Ø Identity
=;
saveKeyValuesAdict_Dictionary, opts : OptionsPattern@DE :=
ModuleA9keyValues=,
keyValues = dictKeyValuePairs@dictD ;
saver@Ò, FilterRules@8opts<, Options@saverDDD & êü keyValuesE
16.13 Processing a Massive Number of Files Using the Map-Reduce Technique | 675

The function mapper provides the glue between the parser, the map function, and
the  intermediate  storage  of  the  output  of  map.  As  mentioned  above,  the  default
behavior is to store the output in a file whose name is derived from the key. How-
ever, for small toy problems you might wish to dispense with the intermediate stor-
age and return the actual output to the next stage of processing in the master kernel.
This feature is available by specifying intermediateFile Ø False (the default is True).
In[91]:=
H*mapper*L
Clear@mapperD;
Options@mapperD =
9intermediateFile Ø True, keyToFilenamePrefix Ø Identity=;
mapper@input_, parser_, map_, opts : OptionsPattern@DD :=
ModuleA8parseList, dict, result, useFile<,
parseList = parser@inputD;
dict = makeDictionary@D;
Scan@mapAndStore@8input, Ò<, map, dictD &, parseListD;
useFile = OptionValue@intermediateFileD;
result = IfAuseFile,
saveKeyValuesAdict, FilterRulesA8opts<, OptionsAsaveKeyValuesEEE,
dictKeyValuePairs@dictDE;
destroyDictionary@dictD;
result
E
Before  the  results  of  mapper  can  be  passed  to  the  reduce  stage  of  processing,  it  is
necessary to group all intermediate results together. For example, in the solution, we
presented the problem of counting words in files. Consider a common word like the.
Clearly, this word will have been found in almost all of the files. Thus, counts of this
word are distributed across a bunch of intermediate files (or lists if intermediate-
FileØFalse was specified). Before the final reduction, the intermediate files (or lists)
must be grouped by key and merged. This is the job of the functions mergeAll and
merge. The grouping task is solved by the Mathematica 7 function GatherBy, and the
actual  merging  is  implemented  as  a  parallel  operation  since  each  key  can  be  pro-
cessed independently. 
676 | Chapter 16: Parallel Mathematica

In[92]:=
ClearAmerge, putE;
H*Put is a helper function around the Mathematica
Put that saves the merged results and deletes
the now redundant files.*L
Options@putD = 8fileDisposition Ø DeleteFile<;
put@list_, files_, opts : OptionsPattern@DD :=
HPut@list, First@filesDD;
OptionValue@fileDispositionD@Rest@filesDD; First@filesDL
H*Merge either merges files into a
single file or lists into a single list.*L
OptionsAmergeE = 8intermediateFile Ø True<;
merge@list_, opts : OptionsPattern@DD :=
ModuleA9useFile, getFunc, putFunc=,
useFile = OptionValue@intermediateFileD ;
9getFunc, putFunc= = If AuseFile, 8Get, put@Ò, listD &<,
9Identity, Identity=, 9Identity, Identity=E;
putFuncAJoin üü getFunc êü listEE
ClearAmergeAllE
OptionsAmergeAllE = 8intermediateFile Ø True<;
mergeAll@result_, opts : OptionsPattern@DD := ModuleA9groupResult=,
H*Gather by key,
which is the First element of each list in the flattened result.*L
groupResult = GatherBy@Flatten@result, 1D, FirstD;
H*Transform grouped results into single key and merged values.
Here Transpose is used to take results of the form:
99key, value1=,9key,value2=,..., 9key,valueN== to
99key,...=,8value1,value2,...<= so the duplicate keys are easily
discarded and the values passed to merge.*L
ParallelMapA
I9First@Ò1D, merge@Ò2, optsD= & üü Transpose@ÒDM & , groupResultE
E
The final stage is the reducer, which accepts the merged results (in file or list form)
for each key and passes the key and resulting list to the reduce function. An option,
fileDisposition, is used to determine what should happen to the intermediate file.
The default disposition is DeleteFile, but you could imagine adding some more com-
plex  processing  at  this  stage,  such  as  logging  or  checkpointing  a  transaction  that
began during the parsing stage. 
16.13 Processing a Massive Number of Files Using the Map-Reduce Technique | 677

In[94]:=
H*reducer*L
Clear@reducerD;
Options@reducerD =
8fileDisposition Ø DeleteFile, intermediateFile Ø True<;
reducerA9key_, value_=, reduce_, opts : OptionsPattern@DE :=
ModuleA8stream, list, temp, useFile<,
useFile = OptionValue@intermediateFileD;
list = If@useFile,
temp = Get@valueD;
OptionValue@fileDispositionD@valueD;
temp,
valueD;
9key, reduceAkey, listE=
E
In[95]:=
DistributeDefinitionsAcountWords, destroyDictionary, dictName,
dictKeyValuePairs, dictLookup, makeDictionary, mapAndStore, mapper,
mapReduce, merge, mergeAll, nextUniqueFile, parseFileToWords, put,
reducer, saveKeyValues, saver, dictStore, totalWords, uniqueFilenameE
See Also
The original paper on map-reduce can be found at http://bit.ly/cqBSTH.
More details that were left out of the original paper can be found in the analysis at
http://bit.ly/bXsWsD.
16.14 Diagnosing Parallel Processing 
Performance
Problem
You  are  trying  to  understand  why  your  parallel  program  is  not  achieving  the
expected speedup.
678 | Chapter 16: Parallel Mathematica

Solution
You  can  enable  parallel  tracing  by  setting  options  associated  with  the  symbol
$Parallel. Use Tracers to specify the types of trace information you want to output
and TraceHandler to specify how the trace information should be processed. 
In[96]:=
SetOptionsA$Parallel, Tracers Ø 8SendReceive<, TraceHandler Ø PrintE
Out[96]=
8Tracers Ø 8SendReceive<, TraceHandler Ø Print<
In[97]:=
ParallelTable@Prime@iD, 8i, 99990, 100 010<D
SendReceive:
Sending to kernel 4: iid8600@Table@Prime@iD, 8i, 99990, 99992, 1<DD Hq=0L
SendReceive:
Sending to kernel 3: iid8601@Table@Prime@iD, 8i, 99993, 99995, 1<DD Hq=0L
SendReceive:
Sending to kernel 2: iid8602@Table@Prime@iD, 8i, 99996, 99998, 1<DD Hq=0L
SendReceive:
Sending to kernel 1: iid8603@Table@Prime@iD, 8i, 99999, 100001, 1<DD Hq=0L
SendReceive:
Receiving from kernel 2: iid8602@81299647, 1299653, 1299673<D Hq=0L
SendReceive:
Sending to kernel 2: iid8604@Table@Prime@iD, 8i, 100002, 100004, 1<DD Hq=0L
SendReceive:
Receiving from kernel 3: iid8601@81299601, 1299631, 1299637<D Hq=0L
SendReceive:
Sending to kernel 3: iid8605@Table@Prime@iD, 8i, 100005, 100006, 1<DD Hq=0L
SendReceive:
Receiving from kernel 2: iid8604@81299743, 1299763, 1299791<D Hq=0L
SendReceive:
Sending to kernel 2: iid8606@Table@Prime@iD, 8i, 100007, 100008, 1<DD Hq=0L
16.14 Diagnosing Parallel Processing Performance | 679

SendReceive: Receiving from kernel 3: iid8605@81299811, 1299817<D Hq=0L
SendReceive:
Sending to kernel 3: iid8607@Table@Prime@iD, 8i, 100009, 100010, 1<DD Hq=0L
SendReceive: Receiving from kernel 2: iid8606@81299821, 1299827<D Hq=0L
SendReceive: Receiving from kernel 3: iid8607@81299833, 1299841<D Hq=0L
SendReceive:
Receiving from kernel 4: iid8600@81299541, 1299553, 1299583<D Hq=0L
SendReceive:
Receiving from kernel 1: iid8603@81299689, 1299709, 1299721<D Hq=0L
Out[97]=
81299541, 1299553, 1299583, 1299 601, 1 299 631, 1 299 637, 1 299 647,
1299653, 1299673, 1299689, 1299709, 1 299 721, 1 299 743, 1 299 763,
1299791, 1299811, 1299817, 1299821, 1 299 827, 1 299 833, 1 299 841<
Be sure to disable tracing when you are done.
In[98]:=
SetOptionsA$Parallel, Tracers Ø 8<E
Out[98]=
8Tracers Ø 8<<
Discussion
There are four kinds of Tracers, and you can enable any combination of these. Each
focuses on a different aspect of Mathematica’s parallel architecture. 
In[99]:=
OptionValues@TracersD
Out[99]=
9MathLink, Queueing, SendReceive, SharedMemory=
In  addition,  there  are  three  ways  to  present  the  data  via  the  TraceHandler  option.
Print and Display are similar, but Save is interesting because it defers output until
the TraceList[] command is invoked.
In[100]:=
OptionValues@TraceHandlerE
Out[100]=
9Print, Save, Display=
In[101]:=
SetOptionsA$Parallel, Tracers Ø 9SendReceive, Queueing=E;
SetOptionsA$Parallel, TraceHandler Ø "Save"E;
newTraceList@D;
ParallelTable@Prime@iD, 8i, 99990, 100 010<D;
680 | Chapter 16: Parallel Mathematica

Now  when  you  execute  TraceList,  it  will  return  the  trace  information  in  a  list
instead of printing it. This is useful if you want to further process this data in some
way.
In[103]:=
TraceList@D
Out[103]=
99SendReceive,
Sending to kernel 4: iid8608@Table@Prime@iD, 8i, 99990, 99992, 1<DD
Hq=0L=, 9SendReceive, Sending to kernel 3:
iid8609@Table@Prime@iD, 8i, 99993, 99995, 1<DD Hq=0L=, 9SendReceive,
Sending to kernel 2: iid8610@Table@Prime@iD, 8i, 99996, 99998, 1<DD
Hq=0L=, 9SendReceive,
Sending to kernel 1: iid8611@Table@Prime@iD, 8i, 99999, 100001, 1<DD
Hq=0L=, 9SendReceive,
Receiving from kernel 4: iid8608@81299541, 1299553, 1299583<D Hq=0L=,
9Queueing, eid8608@Table@Prime@iD, 8i, 99990, 99992, 1<DD done=,
9SendReceive,
Sending to kernel 4: iid8612@Table@Prime@iD, 8i, 100002, 100004, 1<DD
Hq=0L=, 9SendReceive,
Receiving from kernel 3: iid8609@81299601, 1299631, 1299637<D Hq=0L=,
9Queueing, eid8609@Table@Prime@iD, 8i, 99993, 99995, 1<DD done=,
9SendReceive,
Sending to kernel 3: iid8613@Table@Prime@iD, 8i, 100005, 100006, 1<DD
Hq=0L=, 9SendReceive,
Receiving from kernel 2: iid8610@81299647, 1299653, 1299673<D Hq=0L=,
9Queueing, eid8610@Table@Prime@iD, 8i, 99996, 99998, 1<DD done=,
9SendReceive,
Sending to kernel 2: iid8614@Table@Prime@iD, 8i, 100007, 100008, 1<DD
Hq=0L=, 9SendReceive,
Receiving from kernel 1: iid8611@81299689, 1299709, 1299721<D Hq=0L=,
9Queueing, eid8611@Table@Prime@iD, 8i, 99999, 100001, 1<DD done=,
9SendReceive,
Sending to kernel 1: iid8615@Table@Prime@iD, 8i, 100009, 100010, 1<DD
Hq=0L=, 9SendReceive,
Receiving from kernel 4: iid8612@81299743, 1299763, 1299791<D Hq=0L=,
9Queueing, eid8612@Table@Prime@iD, 8i, 100002, 100004, 1<DD done=,
9SendReceive, Receiving from kernel 3: iid8613@81299811, 1299817<D Hq=0L=,
9Queueing, eid8613@Table@Prime@iD, 8i, 100005, 100006, 1<DD done=,
9SendReceive, Receiving from kernel 2: iid8614@81299821, 1299827<D Hq=0L=,
9Queueing, eid8614@Table@Prime@iD, 8i, 100007, 100008, 1<DD done=,
9SendReceive, Receiving from kernel 1: iid8615@81299833, 1299841<D Hq=0L=,
9Queueing, eid8615@Table@Prime@iD, 8i, 100009, 100010, 1<DD done==
16.14 Diagnosing Parallel Processing Performance | 681

You can get a better understanding of the use of shared memory and critical sections
by using the SharedMemory tracer.
In[104]:=
SetSharedVariable@listD; list = 8<
SetOptionsA$Parallel, Tracers Ø 9SendReceive, SharedMemory=E;
SetOptionsA$Parallel, TraceHandler Ø "Save"E;
newTraceList@D;
ParallelEvaluateA
CriticalSectionA8listLock<, list = PrependAlist, $KernelIDEEE
In[104]:=
8<
Out[105]=
881<, 82, 1<, 83, 2, 1<, 84, 3, 2, 1<<
Now executing TraceList shows how a shared variable was accessed and modified
over the parallel evaluation as well as how locks were set and released.
In[106]:=
TraceList@D
Out[106]=
99SendReceive, Sending to kernel 1:
CriticalSection@8listLock<, list = Prepend@list, $KernelIDDD Hq=0L=,
9SendReceive, Sending to kernel 2:
CriticalSection@8listLock<, list = Prepend@list, $KernelIDDD Hq=0L=,
9SendReceive, Sending to kernel 3:
CriticalSection@8listLock<, list = Prepend@list, $KernelIDDD Hq=0L=,
9SendReceive, Sending to kernel 4:
CriticalSection@8listLock<, list = Prepend@list, $KernelIDDD
Hq=0L=, 9SharedMemory,
kernel 1: Parallel`Concurrency`Private`acquire@8listLock<, 1D ö True=,
9SharedMemory,
kernel 2: Parallel`Concurrency`Private`acquire@8listLock<, 2D ö False=,
9SharedMemory,
kernel 3: Parallel`Concurrency`Private`acquire@8listLock<, 3D ö False=,
9SharedMemory,
kernel 4: Parallel`Concurrency`Private`acquire@8listLock<, 4D ö False=,
9SharedMemory, kernel 1: list ö 8<=,
9SharedMemory,
kernel 1: list = 81< ö 81<=, 9SharedMemory,
kernel 1: Parallel`Concurrency`Private`release@8listLock<D ö True=,
9SendReceive, Receiving from kernel 1: 81< Hq=0L=,
9SharedMemory,
kernel 2: Parallel`Concurrency`Private`acquire@8listLock<, 2D ö True=,
9SharedMemory,
kernel 3: Parallel`Concurrency`Private`acquire@8listLock<, 3D ö False=,
9SharedMemory,
682 | Chapter 16: Parallel Mathematica

kernel 4: Parallel`Concurrency`Private`acquire@8listLock<, 4D ö False=,
9SharedMemory, kernel 2: list ö 81<=,
9SharedMemory, kernel 2: list = 82, 1< ö 82, 1<=,
9SharedMemory,
kernel 2: Parallel`Concurrency`Private`release@8listLock<D ö True=,
9SendReceive, Receiving from kernel 2: 82, 1< Hq=0L=,
9SharedMemory,
kernel 3: Parallel`Concurrency`Private`acquire@8listLock<, 3D ö True=,
9SharedMemory,
kernel 4: Parallel`Concurrency`Private`acquire@8listLock<, 4D ö False=,
9SharedMemory, kernel 3: list ö 82, 1<=,
9SharedMemory, kernel 3: list = 83, 2, 1< ö 83, 2, 1<=,
9SharedMemory,
kernel 3: Parallel`Concurrency`Private`release@8listLock<D ö True=,
9SendReceive, Receiving from kernel 3: 83, 2, 1< Hq=0L=,
9SharedMemory,
kernel 4: Parallel`Concurrency`Private`acquire@8listLock<, 4D ö True=,
9SharedMemory, kernel 4: list ö 83, 2, 1<=,
9SharedMemory, kernel 4: list = 84, 3, 2, 1< ö 84, 3, 2, 1<=,
9SharedMemory,
kernel 4: Parallel`Concurrency`Private`release@8listLock<D ö True=,
9SendReceive, Receiving from kernel 4: 84, 3, 2, 1< Hq=0L==
TraceList@D
99SendReceive,
StringFormASending to `1`: `2` Hq=`3`L, StringForm@kernel `1`, 1D,
HoldForm@CriticalSection@8listLock<, list = Prepend@list, $KernelIDDDD, 0E=,
9SendReceive,
StringFormASending to `1`: `2` Hq=`3`L, StringForm@kernel `1`, 2D,
HoldForm@CriticalSection@8listLock<, list = Prepend@list, $KernelIDDDD, 0E=,
9SendReceive,
StringFormASending to `1`: `2` Hq=`3`L, StringForm@kernel `1`, 3D,
HoldForm@CriticalSection@8listLock<, list = Prepend@list, $KernelIDDDD, 0E=,
9SendReceive,
StringFormASending to `1`: `2` Hq=`3`L, StringForm@kernel `1`, 4D,
HoldForm@CriticalSection@8listLock<, list = Prepend@list, $KernelIDDDD, 0E=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 1D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 1DE,
HoldForm@TrueDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 2D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 2DE,
16.14 Diagnosing Parallel Processing Performance | 683

HoldForm@FalseDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 3D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 3DE,
HoldForm@FalseDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 4D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 4DE,
HoldForm@FalseDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 1D,
HoldForm@listD, HoldForm@8<DE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 1D,
HoldForm@list = 81<D, HoldForm@81<DE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 1D,
HoldFormAParallel`Concurrency`Private`release@8listLock<DE,
HoldForm@TrueDE=, 9SendReceive,
StringFormAReceiving from `1`: `2` Hq=`3`L, StringForm@kernel `1`, 1D,
HoldForm@81<D, 0E=, 9SharedMemory,
StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 2D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 2DE,
HoldForm@TrueDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 3D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 3DE,
HoldForm@FalseDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 4D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 4DE,
HoldForm@FalseDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 2D,
HoldForm@listD, HoldForm@81<DE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 2D,
HoldForm@list = 82, 1<D, HoldForm@82, 1<DE=, 9SharedMemory,
StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 2D, HoldFormA
Parallel`Concurrency`Private`release@8listLock<DE, HoldForm@TrueDE=,
9SendReceive, StringFormAReceiving from `1`: `2` Hq=`3`L,
StringForm@kernel `1`, 2D, HoldForm@82, 1<D, 0E=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 3D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 3DE,
HoldForm@TrueDE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 4D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 4DE,
HoldForm@FalseDE=, 9SharedMemory, StringFormA`1`: `2` ö `3`,
StringForm@kernel `1`, 3D, HoldForm@listD, HoldForm@82, 1<DE=,
684 | Chapter 16: Parallel Mathematica

9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 3D,
HoldForm@list = 83, 2, 1<D, HoldForm@83, 2, 1<DE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 3D,
HoldFormAParallel`Concurrency`Private`release@8listLock<DE,
HoldForm@TrueDE=,
9SendReceive, StringFormAReceiving from `1`: `2` Hq=`3`L,
StringForm@kernel `1`, 3D, HoldForm@83, 2, 1<D, 0E=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 4D,
HoldFormAParallel`Concurrency`Private`acquire@8listLock<, 4DE,
HoldForm@TrueDE=, 9SharedMemory, StringFormA`1`: `2` ö `3`,
StringForm@kernel `1`, 4D, HoldForm@listD, HoldForm@83, 2, 1<DE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 4D,
HoldForm@list = 84, 3, 2, 1<D, HoldForm@84, 3, 2, 1<DE=,
9SharedMemory, StringFormA`1`: `2` ö `3`, StringForm@kernel `1`, 4D,
HoldFormAParallel`Concurrency`Private`release@8listLock<DE,
HoldForm@TrueDE=,
9SendReceive, StringFormAReceiving from `1`: `2` Hq=`3`L,
StringForm@kernel `1`, 4D, HoldForm@84, 3, 2, 1<D, 0E==
It is enlightening to do the same trace without the use of CriticalSection. Here you
can see the problems caused by unsynchronized modification of shared memory.
In[107]:=
SetSharedVariable@listD; list = 8<
SetOptionsA$Parallel, Tracers Ø 9SendReceive, SharedMemory=E;
SetOptionsA$Parallel, TraceHandler Ø "Save"E;
newTraceList@D;
ParallelEvaluateAlist = PrependAlist, $KernelIDEE
In[107]:=
8<
Out[108]=
881<, 82<, 83<, 84<<
16.14 Diagnosing Parallel Processing Performance | 685

In[109]:=
TraceList@D
Out[109]=
99SendReceive, Sending to kernel 1: list = Prepend@list, $KernelIDD Hq=0L=,
9SendReceive, Sending to kernel 2: list = Prepend@list, $KernelIDD Hq=0L=,
9SendReceive, Sending to kernel 3: list = Prepend@list, $KernelIDD Hq=0L=,
9SendReceive, Sending to kernel 4: list = Prepend@list, $KernelIDD Hq=0L=,
9SharedMemory, kernel 1: list ö 8<=,
9SharedMemory, kernel 2: list ö 8<=,
9SharedMemory, kernel 3: list ö 8<=,
9SharedMemory, kernel 4: list ö 8<=,
9SharedMemory, kernel 1: list = 81< ö 81<=,
9SharedMemory, kernel 2: list = 82< ö 82<=,
9SharedMemory, kernel 3: list = 83< ö 83<=,
9SharedMemory, kernel 4: list = 84< ö 84<=,
9SendReceive, Receiving from kernel 1: 81< Hq=0L=,
9SendReceive, Receiving from kernel 2: 82< Hq=0L=,
9SendReceive, Receiving from kernel 3: 83< Hq=0L=,
9SendReceive, Receiving from kernel 4: 84< Hq=0L==
16.15 Measuring the Overhead of 
Parallelization in Your Environment
Problem
You want to get a handle on the inherent data communications overhead of parallel
Mathematica in your environment.
Solution
Given that Mathematica is available on many operating systems and classes of com-
puter, and also given that computational cores may be local or networked, and given
network topologies and throughput, it is important to benchmark your environment
to get a sense of its parallel performance characteristics. 
One solution is to plot the time it takes to send various amounts of data to kernels
with and without computation taking place on the data. The code below generates
random data of various sizes and measures the time it takes to execute a function on
that data on all kernels using ParallelEvaluate. Here I plot the Identity versus Sqrt
versus  Total  to  show  the  effect  of  no  computation  versus  computation  on
every  element  of  data  versus  computation  on  every  element  with  a  single  return
value. The key here is that the amount of data sent to slaves and returned to master
is the same in the first two cases, whereas for the third case (dotted), less data is
686 | Chapter 16: Parallel Mathematica

returned than sent. Also, the first case (solid) does no computation, and the second
(dashed) and third (dotted) do.
In[110]:=
sendReceiveTimeAcomplexity_, op_E :=
ModuleA9data = RandomRealA80, 100<, 2^complexityE=,
WithA8d = data, now = AbsoluteTime@D<,
ParallelEvaluate@op@dDD; 92^complexity, AbsoluteTime@D - now=EE
ListLinePlotATransposeATableA9sendReceiveTimeAc, IdentityE,
sendReceiveTime@c, SqrtD, sendReceiveTime@c, TotalD=, 8c, 0, 24<EE,
PlotStyle Ø 8Black, Directive@Black, DashedD, Directive@Black, DottedD<E
Out[2]=
500000
1.0 µ 106
1.5 µ 106
2.0 µ 106
2.5 µ 106
0.1
0.2
0.3
0.4
0.5
The plot shows that communication overhead of sending data to kernels dominates
since the effect of computing Sqrt is negligible. Also, Total (dotted) performs better
because  less  data  is  returned  to  the  master.  Notice  how  the  overhead  is  roughly
linear within my configuration, which consists of four local cores on a Mac Pro with
4 GB of memory.
Discussion
Many  users  who  experiment  casually  with  parallelization  in  Mathematica  7  come
away disappointed. This is unfortunate because there are quite a few useful prob-
lems where parallel primitives can yield real gains. The trick is to understand the in-
herent overhead of your computational setup. Running simple experiments like the
one in the solution can give you a sense of the limitations. There are many calcula-
tions Mathematica can do that take well under 0.05 seconds, but that is how long it
might take to get your data shipped to another kernel. This can make parallelization
impractical for your problem.
16.15 Measuring the Overhead of Parallelization in Your Environment | 687

Consider the Mandelbrot plot from Recipe 16.7. Why did I achieve speedup there?
The key characteristics of that problem are that very little data is shipped to the ker-
nels, much computation is done with the data sent, and no coordination is needed
with kernels solving other parts of the problem. Such problems are called embarrass-
ingly  parallel  because  it  is  virtually  guaranteed  that  you  will  get  almost  linear
speedup with the number of cores at your disposal. 
Unfortunately, many problems you come across are not embarrassingly parallel, and
you will have to work hard to exploit any parallelism that exists. In many cases, if
you can achieve any speedup at all, you will need to expend much effort in reorganiz-
ing the problem to fit the computational resources you have at your disposal. The
keys to success are:
1. Try to ship data to kernel only once.
2. Try to ship data in large chunks, provided computation does not become skewed.
3. Try to compute as much as possible and return as little data as possible.
4. Try to avoid the need to communicate between kernels via shared data.
5. Try to return data in a form that can be efficiently combined by the master into
a final result.
6. Try to avoid repeating identical computations on separate kernels. 
688 | Chapter 16: Parallel Mathematica

CHAPTER 17
Interfacing Mathematica
I want somebody to share
Share the rest of my life
Share my innermost thoughts
Know my intimate details
Someone who’ll stand by my side
And give me support
And in return
She’ll get my support
She will listen to me
When I want to speak
Depeche Mode, “Somebody”
17.0 Introduction
As  wonderful  as  Mathematica  is,  there  are  many  practical  reasons  for  needing  to
interact  with  other  languages  and  data  sources.  Luckily,  Mathematica  is  designed
to  interoperate  well  with  third-party  tools.  The  foundation  of  much  of  this  inter-
operability is MathLink. The MathLink protocol is central to Mathematica because
it is how the frontend communicates with the kernel. A link (LinkObject) is a com-
munications  channel  that  allows  Mathematica  expressions  and  data  values  to  be
transmitted  between  the  kernel  and  programs  written  in  C,  Java,  .NET,  and  even
scripting languages like Python. Recipes 17.5, 17.6, 17.7, and 17.8 solve some of the
most common language interoperability problems.
Equally important to programming language interoperability is database interoper-
ability. A powerful language like Mathematica would be far less useful if it did not al-
low full access to enterprise data. In the past, the ability to read in data from flat files
would  suffice,  but  today  most  enterprises  keep  data  in  some  form  of  relational
689

database.  Mathematica  supports  a  variety  of  database  linkages,  such  as  generic
Open Database Connectivity (ODBC), Java Database Connectivity (JDBC), as well
as  specific  database  products  like  MySQL  (http://www.mysql.com/)  and  HSQL
(http://hsqldb.org/). Recipes 17.8 and 17.9 show typical database connectivity use
cases. Recipe 17.10 shows how to extract metadata from a database.
More mundane, but nonetheless useful, interfacing problems involve launching ex-
ternal programs and using remote kernels. See Recipes 17.1, 17.2, and 17.3.
17.1 Calling External Command Line Programs 
from Mathematica
Problem
You have an executable program that you would like to launch from Mathematica.
Solution
Use Run to execute command line programs. Run returns the exit code of the pro-
gram. Results can be read in from a file written by the program. Here is an example
that will work on the Windows operating system. This is only to illustrate the tech-
nique. Mathematica is perfectly capable of telling you the date itself.
Run@"\"date êT > date.txt\""D; FilePrint@"date.txt"D
Sat 11/15/2008 
Discussion
You can also read the output of external programs by using the escape character !
and the function ReadList. This example uses the GNU program wget to retrieve a
web page and extract the unique URLs. Note that this example assumes you have
wget installed on your system and that it is in the path the Operating System (OS)
uses to find programs. 
690 | Chapter 17: Interfacing Mathematica

webpage = ReadListA"!wget -O - http:êêwww.wolfram.com", StringE;
UnionAFlattenAStringCasesAwebpage, RegularExpression@
"https?:êêH@-\w\.D+L+H:\d+L?HêH@\wê_\.D*H\?\S+L?L?L?"DEEE
9http:êêblog.wolfram.comê,
http:êêdemonstrations.wolfram.comê, http:êêfunctions.wolfram.comê,
http:êêintegrals.wolfram.comêindex.jsp, http:êêlibrary.wolfram.comê,
http:êêmathworld.wolfram.comê, http:êêpartnerships.wolfram.comê,
http:êêreference.wolfram.comêalphaindexê,
http:êêreference.wolfram.comêmathematicaêguideêMathematica.html,
http:êêregister.wolfram.comê, http:êêsearch.wolfram.comê,
http:êêstore.wolfram.comê, http:êêstore.wolfram.comêcatalogê,
http:êêstore.wolfram.comêviewêappêmathematicaêupgrade.upg,
http:êêsupport.wolfram.comê, http:êêtones.wolfram.comê,
http:êêwww.mathematica-journal.comêissueêv10i3ê,
http:êêwww.stephenwolfram.comê, http:êêwww.w3.orgê1999êxhtml,
http:êêwww.w3.orgêTRêxhtml1êDTDêxhtml1,
http:êêwww.wolfram.comêservicesêeducationêseminarsê,
http:êêwww.wolframscience.comê=
See Also
Additional details about running external programs can be found in the Mathemat-
ica tutorial /ExternalPrograms.
17.2 Launching Windows Programs from 
Mathematica
Problem
You  want  to  launch  a  Windows-based  program  from  the  frontend  and  Run["Pro-
gram"] does not work.
Solution
Use the Windows Start command in the Run so the program is launched indirectly.
Run@"Start WinWord"D ;H*starts MS Word*L
17.2 Launching Windows Programs from Mathematica | 691

Discussion
I ran across this problem while preparing a presentation in Mathematica for which I
wanted to have a button that launched XMLSpy to show some XML. Without the
use of Start, you need to specify the full path to the executable; Mathematica com-
plains because it expects the command to be short-lived. Note that Start is a Win-
dows command and not a Mathematica one.
ButtonA"Show some XML",
RunA"\"c:êProgram FilesêAltovaêXMLSpy2006êXmlSpy.exe\""EE
Show some XML
The above problem could be solved using Method Ø "Queued" as an option to Button,
but using Start is much simpler.
ButtonA"Show some XML", RunA"Start XMLSpy"EE
Show some XML
17.3 Connecting the Frontend 
to a Remote Kernel
Problem
You want to use the Mathematica kernel from a different computer than the one you
are using to run the frontend.
Solution
Use the menu Evaluation, Kernel Configuration to create a configuration for a re-
mote kernel. Select Add from the dialog. You will then be presented with the Kernel
Properties dialog shown in Figure 17-1. It makes sense to give the kernel a meaning-
ful name that will remind you what server it is connected to, but you can name it af-
ter your spouse or your dog if you like. Select the radio button Remote Machine and
then enter the machine’s name, a login name, and the kernel program (which is of-
ten “math,” but see the “Discussion” section on page 693). I like to check the option
“Append name to In/Out prompts” to remind me I am working with a remote ker-
nel, but this is a matter of taste. If you will mostly be working with this specific re-
mote kernel, you can also check the automatic launch option.
692 | Chapter 17: Interfacing Mathematica

Figure 17-1. Kernel Properties dialog
When you have the kernel configured, you can use Evaluation, Start Kernel to start
it and Evaluation, Notebook Kernel to associate it with the current notebook.
Discussion
If you have network access to a more powerful computer than the one you use daily
and  that  computer  has  Mathematica  installed,  then  you  can  reap  a  lot  of  benefit
from  using  a  remote  kernel.  For  example,  I  like  to  work  on  my  laptop  because  it
gives me the flexibility to work anywhere in my house. However, my basement has
my powerful Mac Pro, so I usually run my kernel there. This not only gives me ac-
cess to a faster machine, but frees resources on the laptop that would otherwise be
used by the local kernel.
There is a caveat to the solution. If the machine you are connected to is a Mac, there
is  no  program  called  “math.”  You  must  instead  give  the  full  path  to  the  program
called  MathKernel  in  the  edit  box  for  Kernel  Program.  The  location  will  depend
on  where  Mathematica  was  installed.  For  example,  I  installed  Mathematica
17.3 Connecting the Frontend to a Remote Kernel | 693

under  /Applications/Wolfram,  so  I  entered  /Applications/Wolfram/Mathematica.app/
Contents/MacOS/MathKernel. 
If you have trouble connecting to the remote kernel you should take the following
steps.
1. Make sure you can ping the computer you entered on the command line. You
can run ping from the Windows cmd.exe shell or Unix or Mac OS X shell. If
you can’t ping the machine, it is either off or there is some network issue you
need to resolve.
2. If  you  can  ping  the  computer  but  the  kernel  fails  to  start,  make  sure
Mathematica is properly installed on the remote computer. Do this by running
Mathematica  directly  from  the  remote  computer  or  ask  your  systems
administrator to verify. A common problem is for Mathematica to be installed
but to rely on a license manager (MathLM) that is not running.
3. If you get an error like “SSH could not launch kernel ‘<kernel name>’ because
the  remote  machine  refused  the  connection.  Error  code  =  113”,  then  there  is
most likely a permissions problem with the login name and the password you
provided when prompted by the frontend. Make sure you can remotely log in to
the  machine  using  Secure  Shell  (SSH)  or  PuTTY  from  the  command  line
(PuTTY  is  a  free  SSH  program  for  Windows  that  you  can  download  from
http://www.putty.org/).
17.4 Using Mathematica with C and C++
Problem
You want to call C functions from Mathematica.
Solution
Here I demonstrate the process of creating a C program with functions that can be
invoked from Mathematica. This example uses Microsoft Visual C++ 2005. Refer to
the “See Also” section on page 699 for information on using other programming
environments. The simplest way to interface Mathematica to C is to utilize the pre-
processor mprep, which takes a template file describing one or more C functions,
and  generate  the  glue  code  needed  to  interface  those  functions  to  Mathematica.
Here is an example of an mprep file describing three different functions.
694 | Chapter 17: Interfacing Mathematica

:Begin:
:Function:
fExample1
:Pattern:
fExample1[x_Integer, y_Integer]
:Arguments:
{x, y}
:ArgumentTypes: {Integer, Integer}
:ReturnType:
Integer
:Function:
fExample2
:Pattern:
fExample2[x_List, y_List]
:Arguments:
{x, y}
:ArgumentTypes: {IntegerList, RealList}
:ReturnType:
Integer
:Function:
fExample3
:Pattern:
fExample3[aStr_String]
:Arguments:
{aStr}
:ArgumentTypes: {String}
:ReturnType:
String
:End:
The  C  source  code  corresponding  to  these  definitions  follows.  Note  that  lists  are
passed as pointers to arrays and that an extra integer parameter is needed for each
such list to receive the length of the array. In this listing, you will also find the defini-
tion of WinMain that is required for Windows executables built with Microsoft Visual
Studio. The body of WinMain is standard boilerplate that you can copy into your own
project. The implementation of the functions themselves is really not important in
this code as its main purpose is to demonstrate the C interface mechanics.
//functions.h
extern "C"
{
int fExample1(int x, int y);
double fExample2(int * x, long xLen, double* y, long yLen);
char * fExample3(char * aStr);
}
//functions.cpp
#include "functions.h"
#include <mathlink.h>
17.4 Using Mathematica with C and C++ | 695

#include <stdio.h>
#include <ctype.h>
int fExample1(int x, int y)
{
return (x >> y) + 1;
}
double fExample2(int * x, int xLen, double* y, int yLen)
{
double result = 0.0;
int i = 0;
for (; i<xLen && i<yLen; ++i)
{
result += x[i] * y[i] ;
}
for (;i < yLen; ++i)
{
result += y[i];
}
return result ;
}
char * fExample3(char * aStr)
{
for(char *p=aStr;*p;++p)
{
*p = toupper(*p) ;
}
return aStr ;
}
int PASCAL WinMain( HINSTANCE hinstCurrent, HINSTANCE hinstPrevious,        
LPSTR lpszCmdLine, int nCmdShow)
{
char  buff[512];
char FAR * buff_start = buff;
char FAR * argv[32];
char FAR * FAR * argv_end = argv + 32;
696 | Chapter 17: Interfacing Mathematica

hinstPrevious = hinstPrevious; /*suppress warning*/
if( !MLInitializeIcon( hinstCurrent, nCmdShow)) return 1;
MLScanString( argv, &argv_end, &lpszCmdLine, &buff_start);
return MLMain( (int)(argv_end - argv), argv);
}
Once you have a MathLink program compiled to an executable, you can install it us-
ing Install. By default, Install will look in the current directory for the executable;
either change the current directory or give Install the full path. Install returns a
LinkObject, which can be used to get information about available functions and also
to terminate the connection using Uninstall.
saveCurDir = Directory@D;
SetDirectoryA
"oreilly\\Mathematica Cookbook\\code\mathLinkExample\\Debug"E;
link = Install@"mathLinkExample"D;
SetDirectory@saveCurDirD;
You can interrogate a link for the available functions.
LinkPatterns@linkD
9fExample1Ax_Integer, y_IntegerE,
fExample2Ax_List, y_ListE, fExample3AaStr_StringE=
You call installed MathLink functions just like normal Mathematica functions.
fExample1@2000, 4D
126
fExample2@81, 2, 3<, 82.0, 4.0, 6.0, 8.0<D
36.
fExample3A"Testing"E
TESTING
Uninstall@linkD
mathLinkExample
17.4 Using Mathematica with C and C++ | 697

Discussion
Although the solution is fairly straightforward, there are numerous details that are
specific  to  the  OS  and  compilation  environment  (compiler  and  IDE  or  make  sys-
tem). The Mathematica documentation for MathLink contains detailed instructions
for many common environments, and you should follow those directions carefully.
It is highly recommended that you use either the example in the solution given or
some of the simple examples that are installed with Mathematica to become familiar
with the process before trying to interface your own C functions. 
Often you will need to return objects more complex than integers and doubles from
your C functions. If this is the case, you should specify a return type of Manual in the
template file. Manual means that you will manually code the function to call the ap-
propriate low-level MathLink C API functions needed to return the correct data to
Mathematica.
//randomList.tm
#include <stdlib.h>
#include <mathlink.h>
:Begin:
:Function:       randomIntList
:Pattern:        randomIntList[n_Integer]
:Arguments:      {n}
:ArgumentTypes:  {Integer}
:ReturnType:     Manual
:End:
extern "C" void randomIntList(int n)
{
int* randData = new int [n] ;
if (randData)
{
for(int i=0; i<n; ++i)
{
randData[i] = rand() ;
}
MLPutInteger32List(stdlink, randData , n);
delete [] randData; 
}
698 | Chapter 17: Interfacing Mathematica

else
{
MLPutInteger32List(stdlink,0,0) ;
}
}
saveCurDir = Directory@D;
SetDirectoryA
"oreilly\\Mathematica Cookbook\\code\mathLinkExample2\\Debug"E;
link2 = Install@"mathLinkExample2"D;
SetDirectory@saveCurDirD;
LinkPatterns@link2D
9randomIntListAn_IntegerE=
randomIntList@12D
82287, 5306, 19753, 3868, 19313,
1043, 29879, 26846, 14625, 1380, 24 555, 28 439<
Uninstall@link2D;
The  example  given  illustrates  the  use  of  MLPutInteger32List  to  return  an  array  of
data as a list. The MathLink API contains many related functions for returning a vari-
ety of types, including integers, strings, lists, multidimensional arrays, and the like.
This  example  also  demonstrates  that  template  files  processed  by  mprep  can  mix
source code with template directives.
Another common requirement is the need to execute initialization code once when
you install the MathLink program. C-based initialization code can easily be added to
the applications main() or WinMain(), but what about Mathematica code? A typical
example is code that installs documentation for the installed functions. For this you
use mprep’s :Evaluate: specifications. For an example of this see http://bit.ly/duSEnb.
See Also
Information  on  how  to  set  up  your  C-built  environment  can  be  found  at  tutorial/
MathLinkDeveloperGuide (Mac OSX), tutorial/MathLinkDeveloperGuide (Windows),
and tutorial/MathLinkDeveloperGuide (Unix and Linux).
See ref/program/mprep in the Mathematica documentation.
17.4 Using Mathematica with C and C++ | 699

17.5 Using Mathematica with Java
Problem
You want to use Mathematica as a Java scripting language to prototype a Java appli-
cation or leverage the functionality of Java classes.
Solution
Use the JLink` package and call InstallJava to make the Java runtime environment
available  to  Mathematica.  You  can  then  create  objects  and  call  methods  or  load
classes to access static methods just as if they were Mathematica functions.
Needs@"JLink`"D
InstallJava@D;
H*Create an instance of decimal format and
call a method using prefix notation objümethod.*L
fmt = JavaNewA"java.text.DecimalFormat", "Ò.0000"E;
fmtüformat@ÒD & êü 81.0, 7.333, N@PiD, 1ê3.<
81.0000, 7.3330, 3.1416, .3333<
H*Load a class and call a static method using
the full class name as if it were a package.*L
LoadJavaClassA"java.lang.System"E;
java`lang`System`currentTimeMillis@D
1226852744984
Discussion
Options@InstallJavaD
9ClassPath Ø Automatic, CommandLine Ø Automatic, JVMArguments Ø None,
ForceLaunch Ø False, Default Ø Automatic, CreateExtraLinks Ø Automatic=
InstallJava takes options that control how the Java is loaded. CommandLine Ø java-
path allows you to specify the particular version of Java you want to load if you have
several  versions  available.  For  example,  CommandLine  Ø  "c:\\Program  Files\\Java
\\jre1.6.0_07\\bin\\java".  ClassPath  Ø  classpath  is  used  to  provide  a  classpath
that is different from the default obtained from the CLASSPATH environment variable.
If  you  require  special  Java  Virtual  Machine  (JVM)  options,  use  JVMArguments  Ø
arguments. 
When InstallJava is invoked several times during a Mathematica session, the subse-
quent invocations are ignored. However, sometimes you want to clear out the old
JVM and start fresh. In that case, use ReinstallJava to exit and reload Java. This
700 | Chapter 17: Interfacing Mathematica

is especially useful if you are making changes to a Java Archive (JAR) that you are de-
veloping alongside the Mathematica notebook that uses it. ReinstallJava takes the
same options as InstallJava.
ReinstallJavaA
CommandLine Ø "c:\\Program Files\\Java\\jre1.6.0_07\\bin\\java"E;
The following example uses a genetic algorithm (GA) Java library called JGAP (see
http://jgap.sourceforge.net/). GAs are in the class of evolutionary inspired algorithms
typically used to tackle complex optimization problems. This example demonstrates
an ideal blend of Mathematica and Java because it shows how easy it is to script a
Java application and exploit the visualization features of Mathematica to investigate
its behavior. 
The example also illustrates the use of JavaBlock as a means of automatically clean-
ing up Java objects when they are no longer needed. It also shows how Java arrays of
objects are replaced by Mathematica lists and how the translation is automated by
JLink.
Needs@"JLink`"D
ReinstallJavaAClassPath Ø
"C:\\code\\jgap;C:\\code\\jgap\jgap-examples.jar;C:\\code\\jgap\jgap.jar
;C:\\code\\jgap\jgapMathematica.jar"E;
H*The volumes of items we wish to be packed*L
itemVolumes = 81.2, 2.8, 3.5, 4.0, 25.0, 6.75, 14.36, 36.7, 78.9, 325.1<;
H*The names of the items*L
itemNames = 9"item1", "item2", "item3", "item4", "widget",
"thingie", "thingie2", "fooBar", "WingWam", "ThingAMaBob"=;
targetVolume = 1000.0;
popSize = 1500;
generations = 150;
I implement the problem using a function called knapsack, which takes an optional
fitness function. The reason for this will become apparent later. Most of the code
within knapsack is straightforward use of JLink facilities interspersed with standard
Mathematica code. The comments in the code point out what’s going on, and much
of the detail is specific to the JGAP library and the knapsack problem. One thing that
might trip you up in your own Java-interfacing projects is dealing with Java arrays of
objects. There is no JLink function specifically designed to construct arrays. Instead,
wherever you need to call a Java function that expects an array, simply pass it a Mathe-
matica list of objects created with JavaNew and Jlink will translate. Mathematica’s
Table is convenient for that purpose and it is how the following code creates an ar-
ray of Gene objects. Likewise, when calling a Java function that returns an array, ex-
pect Mathematica to convert it to a list.
17.5 Using Mathematica with Java | 701

knapsack@fitnessFunc_ : NoneD :=
H*Use a JavaBlock to release all Java objects when block completes.*L
JavaBlockA
ModuleA9conf, fitnessFunc2, sampleGenes, sampleChromosome, population,
individuals, bestSolutionSoFar, packing, volumeFound, dummy=,
H*JGAP uses a configuration object to organize the
genetic algorithm's parameters and objects.*L
LoadJavaClassA"org.jgap.Configuration"E;
Configuration`reset@D;
conf = JavaNewA"org.jgap.impl.DefaultConfiguration"E;
H*We want to preserve the fittest individual.*L
confüsetPreservFittestIndividual@TrueD;
H*The fitness function is
implemented as a class in the example code.*L
fitnessFunc2 = IfAfitnessFunc === None,
JavaNewA"examples.knapsack.KnapsackFitnessFunction", targetVolumeE,
JavaNewA"jgapMathematica.FitnessFunction", fitnessFuncEE;
confüsetFitnessFunction@fitnessFunc2D;
H*In the original Java code sampleGenes is a Java array of class
Gene. However, in Mathematica you create lists of objects, and the
JLink code will take care of translating to arrays when necessary.*L
sampleGenes = TableAJavaNewA"org.jgap.impl.IntegerGene",
conf, 0, CeilingA0.75 targetVolumeë itemVolumes@@iDDEE,
9i, 1, Length@itemVolumesD=E;
sampleChromosome = JavaNewA"org.jgap.Chromosome", conf, sampleGenesE;
confüsetSampleChromosome@sampleChromosomeD;
confüsetPopulationSize@popSizeD;
LoadJavaClassA"org.jgap.Genotype"E;
population = org`jgap`Genotype`randomInitialGenotype@confD;
H*Let's run the evolution for 200 generations and
capture the fittest at each generation.*L
9dummy, 8saveFitnessValues <= = ReapADoApopulationüevolve@D;
SowApopulationügetFittestChromosome@DügetFitnessValue@DE,
9generations=EE;
bestSolutionSoFar = populationügetFittestChromosome@D;
PrintA"Fitness of Best:", bestSolutionSoFarügetFitnessValue@DE;
H*Here we decode the best solution to get the qty of each item.*L
702 | Chapter 17: Interfacing Mathematica

packing =
TableA9bestSolutionSoFarügetGene@iDügetAllele@D,
itemNames@@i + 1DD=, 8i, 0, bestSolutionSoFarüsize@D - 1<E;
PrintA"Packing found: ", packingE;
volumeFound = TotalApacking@@All, 1DD * itemVolumesE;
Print@"Volume used ", volumeFoundD;
PrintA"Difference from desired volume: ", targetVolume - volumeFoundE;
E
E
Using a fairly healthy population size and a large number of generations, we unfortu-
nately get a fairly poor solution! This indicates a problem with the design of our GA.
Let’s see how we can draw on Mathematica to help resolve this. 
popSize = 1500;
generations = 200;
knapsack@D
Fitness of Best: 4.58099µ108
Packing found:
8878, item1<, 827, item2<, 838, item3<, 80, item4<, 826, widget<,
886, thingie<, 811, thingie2<, 80, fooBar<, 80, WingWam<, 80, ThingAMaBob<<
Volume used 1690.66
Difference from desired volume: -690.66
By plotting the logarithm of the fitness at each generation, we can see that the fitness
landscape of this problem is extremely steep since we make a rapid transition from
very low fitness to very high fitness. This suggests the fitness function provided with
this JGAP sample might not be ideal. The poor quality of the solution is further indi-
cation of a poorly designed fitness function. The real lesson is that Mathematica is
an ideal experimental playground for Java libraries because the full wealth of ana-
lytic and visual tools is at your disposal. In fact, I use Mathematica to help find a bet-
ter fitness function, so read on.
17.5 Using Mathematica with Java | 703

BarChartALog@saveFitnessValuesDE
If you want to experiment with Java libraries, it is ideal to be able to implement inter-
faces  defined  by  those  libraries  directly  in  Mathematica.  In  fact,  this  can  be  done
rather easily using ImplementJavaInterface. The following example uses Implement-
JavaInterface to try an alternate fitness function for the knapsack problem. There is
a caveat, however. ImplementJavaInterface will only work with true interfaces, not
abstract classes. In JGAP, FitnessFunction is an abstract class, hence we can’t imple-
ment it using ImplementJavaInterface. The solution in cases like this is to create an
adapter like the one in the following listing.
package jgapMathematica;
import org.jgap.IChromosome;
public class FitnessFunction extends org.jgap.FitnessFunction {
private IMathematicFitness m_fitness;
public FitnessFunction(IMathematicFitness fitness) {
m_fitness = fitness ;
}
@Override
protected double evaluate(final IChromosome chromosome) {
return m_fitness.evaluate(chromosome);
}
}
The above fitness function allows us to use the following interface within Mathemat-
ica code. 
704 | Chapter 17: Interfacing Mathematica

package jgapMathematica;
import org.jgap.IChromosome;
public interface IMathematicFitness {
public double evaluate(final IChromosome chromosome) ;
}
Once this is done, we can write any fitness function we like in pure Mathematica
code. This solution is general in that any abstract class you find in any Java library
can be adapted in a similar manner. Below, we exploit the adapter to write a new
fitness  function  for  the  knapsack  problem.  The  function  penalizes  solutions  that
use more volume than specified, while giving increasing reward to solutions that use
close to the available volume.
knapsackEvaluateAsubject_E := ModuleA9subjPacking, subjVol=,
H*Figure out the volume used by the solution being evaluated.*L
subjPacking =
TableAsubjectügetGene@iDügetAllele@D, 9i, 0, subjectüsize@D - 1=E;
subjVol = TotalAsubjPacking *itemVolumesE;
H*This function gives small fitness to
volumes that are far from the target volume; however,
it rewards underfitting twice as much as overfitting.*L
IfAsubjVol > targetVolume, targetVolumeë subjVol,
IsubjVolë targetVolumeM *2.0E
E
H*Implementing an interface is nothing more than mapping the interface
methods to the Mathematica function. Here our interface has only a single
function called evaluate and it gets mapped to knapsackEvaluate.*L
ff = ImplementJavaInterfaceA"jgapMathematica.IMathematicFitness",
8"evaluate" Ø "knapsackEvaluate"<E;
popSize = 50;
generations = 20;
knapsack@ffD
Fitness of Best: 1.99776
Packing found:
8820, item1<, 895, item2<, 867, item3<, 820, item4<, 82, widget<,
834, thingie<, 88, thingie2<, 80, fooBar<, 80, WingWam<, 80, ThingAMaBob<<
17.5 Using Mathematica with Java | 705

Volume used 998.88
Difference from desired volume: 1.12
BarChart@saveFitnessValuesD
Keep  in  mind  that  implementing  interface  in  Mathematica  code  is  convenient  but
comes at a very high cost. In our case, it makes the GA run much slower and forces
the use of a much smaller population size. This is especially true because the fitness
function is called many times, and it must call back into Java, making it extremely
costly. This is not a real issue because the goal here is experimentation. When a rea-
sonable  fitness  function  is  found,  it  can  be  ported  back  to  Java.  You  can  use  the
same methodology when working with other Java libraries. Of course, if the inter-
face you implement in Mathematica is called infrequently, the hassle of porting back
to Java may seem unnecessary.
See Also
The  J/Link  tutorial  is  an  excellent  way  to  round  out  your  knowledge  of  the
Mathematica-to-Java interface. See JLink/tutorial/Overview.
Mathematica  is  bundled  with  notebooks  illustrating  different  aspects  of
Mathematica-Java interaction (such as using the GUI features of Java Swing).
These  can  be  found  in  the  Mathematica  installation  directory  (evaluate
$InstallationDirectory) under subdirectory SystemFiles/Links/JLink/Examples.
706 | Chapter 17: Interfacing Mathematica

17.6 Using Mathematica to Interact with 
Microsoft’s .NET Framework
Problem
You  want  to  use  Mathematica  as  a  .NET  scripting  language  to  prototype  a  .NET
application  or  leverage  Windows-specific  functionality  not  directly  available  in
Mathematica. 
Solution
Use the NETLink` package and InstallNET to initialize Mathematica’s .NET interface.
You  then  can  use  functions  like  LoadNETAssembly  to  load  custom  .NET  assemblies
and NETNew to create instances of objects. Methods and properties of objects are ac-
cessed  using  Mathematica  prefix  notation  object@property  and  object@method
[args]. 
As  an  example,  you  can  use  Mathematica  6’s  dynamic  functionality  with  a  .NET
timer to display a ticking clock.
Needs@"NETLink`"D
InstallNET@D;
timeOut = "Not Set";
timer = NETNewA"System.Timers.Timer", 1000E;
H*1 sec timer = 1000 msec*L
onTimedEventAsource_, eventArgs_E :=
ModuleA8<, timeOut = eventArgsüSignalTimeüToString@"G"DE;
H*Use AddEventHandler to bind a Mathematica function to an event.*L
AddEventHandler@timerüElapsed, onTimedEventD;
timerüEnabled = True;
Dynamic@timeOutD
timeOut
timerüEnabled = False; H*Stop the timer*L
Discussion
When you use NETNew, Mathematica implicitly loads the .NET type of the class you
are  creating.  For  some  cases,  you  need  to  load  the  type  explicitly.  For  example,
many .NET components use Enums in their interface. To reference these in Mathe-
matica code, you need to load them. In Mathematica, you use LoadNETType for this
17.6 Using Mathematica to Interact with Microsoft’s .NET Framework | 707

purpose.  In  the  following  example,  you  use  LoadNETType  to  get  the  enumerations
associated with dialog box results. This allows you to use the OpenFileDialog compo-
nent to select a file. If you run this code, you may need to press Alt-Tab to switch to
the dialog.
Needs@"NETLink`"D
InstallNET@D;
LoadNETTypeA"System.Windows.Forms.DialogResult"E;
openFileDialog1 = NETNewA"System.Windows.Forms.OpenFileDialog"E;
openFileDialog1üInitialDirectory =
"c:\\Documents And Setting\\Salvtore Mangano"; openFileDialog1üFilter =
"image files H*.jpg;*.gif;*.bmpL»*.jpg;*.gif;*.bmp»All
files H*.*L»*.*"; openFileDialog1üFilterIndex = 1;
openFileDialog1üRestoreDirectory = True;
IfAopenFileDialog1üShowDialog@D === DialogResult`OK,
ImportAopenFileDialog1üFileNameE, "No Image Selected"E
You also use LoadNETType to load a class that has a static method you want to call.
Static methods are then accessible as normal Mathematica functions.
Needs@"NETLink`"D
InstallNET@D;
LoadNETTypeA"System.Diagnostics.Stopwatch"E;
System`Diagnostics`Stopwatch`GetTimestamp@D
5674487004
The default value for the LoadNETType option StaticsVisible is False, but you can
set it to True to avoid having to specify the full namespace path to invoke the func-
tion. You should use this feature with caution since it can lead to name conflicts.
See Also
An extensive tutorial on NETLink can be found in the Mathematica documentation at
NETLink/tutorial/Overview.
708 | Chapter 17: Interfacing Mathematica

17.7 Using the Mathematica Kernel
from a .NET Application
Problem
You  want  to  leverage  the  advanced  Mathematica  algorithms  from  within  a  .NET
application.
Solution
Use the classes in the Wolfram.NETLink.dll from your .NET application. This recipe
will  use  C#,  but  the  Mathematica  kernel  is  accessible  from  any  .NET  language.
The  simplest  way  to  interact  with  Mathematica  is  through  passing  strings  of
Mathematica  code  using  an  instance  of  IKernelLink.  You  acquire  an  instance  via
MathLinkFactory.CreateKernelLink. IKernelLink has several methods for evaluating
Mathematica  code,  but  the  function  EvaluateToOutputForm  is  one  of  the  most
convenient.
using System;
using Wolfram.NETLink;
namespace TestNetLink1
{
    public class TestNetLink
    {
    public static void Main (String[] args)
    {
    
    //Launch the Mathematica Kernel
    
    IKernelLink ml = MathLinkFactory.CreateKernelLink ();
    
    //Discard the initial response kernel will send when launched.
    
    ml.WaitAndDiscardAnswer ();
    
    //Solve a differential equation and evaluate at the value 2
            string expr = "s = NDSolve[{y''[x]+Sin[y[x]] y[x] == 0,
    
y[0] == 1," +
                "y'[0] == 0},y,{x, 0,30}]; y[2] /. s";
    
    string result = ml.EvaluateToOutputForm(expr, 0);
   
    Console.WriteLine ("Result = " + result);
   
    }
 
}
}
17.7 Using the Mathematica Kernelfrom a .NET Application | 709

Discussion
Receiving numerical data back in string form is fine when you just want to display
the result of a computation, but if you want to feed the results Mathematica returns
into further computations, it is less than ideal. There are other ways to read the data
returned by evaluation expressions, but these involve being cognizant of the types
you expect back. 
using System;
using Wolfram.NETLink;
namespace TestNetLink2
{
    public class TestNetLink2
    {
        public static void Main(String[] args)
        {
            //Launch the Mathematica Kernel
            IKernelLink ml = MathLinkFactory.CreateKernelLink();
            //Discard the initial response kernel will send when launched.
            ml.WaitAndDiscardAnswer();
            //Solve a differential equation and evaluate at the value 2.
            string expr = "s = NDSolve[{y''[x]+Sin[y[x]] y[x] == 0, y[0] ==
1," +
                "y'[0] == 0},y,{x, 0,30}]; y[2] /. s";
            //Evaluate expression. Notice this does not return anything.
            ml.Evaluate(expr);
            //Wait for results to be ready.
            ml.WaitForAnswer();
            //Read the result being sure to use the method that retrieves a
n
 
appropriate
            //type. In this case, we expect a list of doubles but MathLink
converts
            //these into arrays. Here you get the first element of the arra
y
 
and can then
            //perform additional computations such as adding 10.
            double result = ml.GetDoubleArray()[0] + 10.0;
            Console.WriteLine("Result = " + result);
        }
    }
}
710 | Chapter 17: Interfacing Mathematica

The  IKernelLink  interface  has  a  variety  of  methods  for  retrieving  typed  results.
These include GetBoolean, GetDouble, GetInteger, GetString, GetDecimal, GetDouble-
Array, and quite a few others. Refer to the NETLink documentation for the full set of
methods.
In addition to IKernelLink, there is a very high-level interface to Mathematica imple-
mented as a class called MathKernel that is ideal for creating a custom frontend to
Mathematica.  MathKernel  derives  from  System.ComponentModel.Component  and  fol-
lows the conventions of .NET components. A nice example of using MathKernel can
be found in the Mathematica installation directory ($InstallationDirectory) under
SystemFiles/Links/NETLink/Examples/Part2/MathKernelApp.
See Also
You can find more information on interacting with the kernel from .NET languages
at  NETLink/tutorial/CallingMathematicaFromNET.  There  are  examples  there  using
both C# and Visual Basic.
17.8 Querying a Database 
Problem
You want to compute with data retrieved from an external database.
The  examples  in  Recipes  17.8  and  17.10  assume  the  existence  of
certain databases. If you don’t have access to a database system where
you can set up these databases, the examples will obviously not work.
If you have a database system or know how to install one, you can get
files  to  initialize  the  database  for  these  examples  from  the  book’s
website. Naturally, these examples are only for illustrating techniques
that  you  can  employ  on  real  databases  you  wish  to  interface  to
Mathematica.
Mathematica  supports  several  flavors  of  database  connectivity,
including  ODBC,  JDBC,  MySQL,  and  HSQLDB  (Hyper  Structured
Query Language Database).
Solution
Here I open a connection to a SupplierParts database previously set up on my sys-
tem and then query all rows of the part table. SQLSelect is the best way to retrieve
all data from a single table. See the discussion for variations and alternatives.
17.8 Querying a Database | 711

Needs@"DatabaseLink`"D;
conn = OpenSQLConnection@"SupplierParts"D;
SQLSelect@conn, "part"D
98p1, Nut, Red, 12., London<, 8p2, Bolt, Green, 17., Paris<,
8p3, Screw, Blue, 17., Rome<, 8p4, Screw, Red, 14., London<,
8p5, Cam, Blue, 12., Paris<, 9p6, Cog, Red, 19., London==
Discussion
SQLSelect  provides  a  stylized  means  to  perform  simple  database  queries  with-
out  knowing  SQL.  Below  are  three  increasingly  complex  queries  you  can  do  with
SQLSelect. 
H*Restrict to specific columns.*L
SQLSelectAconn, "supplier", 9"name", "city"=E
88Smith, London<, 8Jones, Paris<,
8Blake, Paris<, 8Clark, London<, 8Adams, Athens<<
H*Specify selection criteria.*L
SQLSelectAconn, "supplier", 9"name", "city"=, SQLColumn@"id"D ã "s1"E
88Smith, London<<
H*Join data from multiple tables. Here I show
collocated suppliers and parts, and specify a sort.*L
SQLSelectAconn, 8"supplier", "part"<,
98"supplier", "id"<, 8"part", "id"<, 9"supplier", "city"==,
SQLColumnA9"supplier", "city"=E ã SQLColumnA9"part", "city"=E,
"SortingColumns" Ø 8SQLColumn@8"supplier", "id"<D,
SQLColumn@8"part", "id"<D<E êê TableForm
s1 p1 London
s1 p4 London
s1 p6 London
s2 p2 Paris
s2 p5 Paris
s3 p2 Paris
s3 p5 Paris
s4 p1 London
s4 p4 London
s4 p6 London
712 | Chapter 17: Interfacing Mathematica

Of course, the conventions used by SQLSelect create a very thin veneer over SQL, so
if you plan to do quite a bit of database work, you will benefit from learning and us-
ing SQL directly via SQLExecute.
SQLExecuteAconn,
"SELECT supplier.id sid, part.id pid, supplier.city city
FROM supplier, part
WHERE supplier.city = part.city
ORDER BY sid,pid", "ShowColumnHeadings" Ø TrueE êê TableForm
sid pid city
s1
p1
London
s1
p4
London
s1
p6
London
s2
p2
Paris
s2
p5
Paris
s3
p2
Paris
s3
p5
Paris
s4
p1
London
s4
p4
London
s4
p6
London
Nevertheless, using straight SQL can sometimes be a pain when you need to build
the query from data stored in variables. SQLArgument, along with argument placehold-
ers (e.g., `1`, `2`), is the recommended solution. You can use SQLArgument directly
with values, but if you are parameterizing a query on column or table names, you
must also use SQLColumn and SQLTable, respectively.
table = "supplier"; id = "s2"; col = "city";
SQLExecuteAconn,
"SELECT `1` FROM `2` WHERE id = `3`", 9SQLArgument@SQLColumn@colDD,
SQLArgument@SQLTable@tableDD, SQLArgument@idD=E
88Paris<<
CloseSQLConnection@connD;
See Also
Detailed  discussion  of  query  commands  can  be  found  in  DatabaseLink/tutorial/
SelectingData in the Mathematica documentation.
17.8 Querying a Database | 713

17.9 Updating a Database
Problem
You want to store results of computations to a database.
Solution
Use SQLInsert to add new records and SQLUpdate to modify existing records.
Needs@"DatabaseLink`"D;
conn = OpenSQLConnectionA"MySQLTest"E;
SQLInsert@conn, "data1", 8"x1", "x2", "x3"<,
Table@8i, Prime@iD, RandomReal@D<, 8i, 1, 100<DD;
SQLUpdateAconn, "data1", 8"x1", "x2", "x3"<,
80.0, 1.0, 2.0<, SQLColumnA"data1.key"E == 4E
1
Use SQLDelete to remove records.
SQLDeleteAconn, "data1", SQLColumnA"data1.key"E ã 10E
0
Discussion
If you need to update multiple tables in an all-or-nothing manner and your database
management  system  supports  transactions,  you  should  use  SQLBeginTransaction
and  SQLCommitTransaction  to  bracket  the  updates.  If  an  error  occurs  you  can  use
SQLRollbackTransaction, which rolls back to the beginning of the transaction or to a
named save point (which is set using SQLSetSavepoint).
Inserting,  updating,  and  deleting  are  the  most  common  operations  for  changing  a
database, but Mathematica also gives you the ability to create and drop tables. 
SQLExecuteAconn, "UPDATE data1 SET x1=0,x2=1,x3=2 WHERE data1.key=104"E
1
See Also
Detailed discussion of transactions can be found in DatabaseLink/tutorial/Transactions
in the Mathematica documentation.
714 | Chapter 17: Interfacing Mathematica

17.10 Introspection of Databases
Problem
You want to query a database to find out what entities (tables, columns, etc.) are
available.
Solution
Mathematica contains a variety of methods that return information about the data
sources available, their tables, and the schema of those tables.
Needs@"DatabaseLink`"D
The command DataSourceNames[] lists all data sources known to the Mathematica
instance.
DataSourceNames@D
9demo, graphs, publisher, MySQLMeta, MySQLTest, SupplierParts=
Given a connection to one of these sources, list all the tables.
conn = OpenSQLConnection@"SupplierParts"D;
SQLTables@connD
9SQLTableAinventory, TableType Ø TABLEE,
SQLTableApart, TableType Ø TABLEE, SQLTableAsupplier, TableType Ø TABLEE=
Given a connection, list all columns with their associated tables.
SQLColumnNames@connD êê TableForm
inventory sid
inventory pid
inventory qty
part
id
part
name
part
color
part
weight
part
city
supplier
id
supplier
name
supplier
status
supplier
city
17.10 Introspection of Databases | 715

You can also find out all the data types supported by your particular database.
SQLDataTypeNames@connD
8BIT, BOOL, TINYINT, TINYINT UNSIGNED, BIGINT, BIGINT UNSIGNED,
LONG VARBINARY, MEDIUMBLOB, LONGBLOB, BLOB, TINYBLOB, VARBINARY, BINARY,
LONG VARCHAR, MEDIUMTEXT, LONGTEXT, TEXT, TINYTEXT, CHAR, NUMERIC,
DECIMAL, INTEGER, INTEGER UNSIGNED, INT, INT UNSIGNED, MEDIUMINT,
MEDIUMINT UNSIGNED, SMALLINT, SMALLINT UNSIGNED, FLOAT, DOUBLE,
DOUBLE PRECISION, REAL, VARCHAR, ENUM, SET, DATE, TIME, DATETIME, TIMESTAMP<
CloseSQLConnection@connD;
Discussion
The introspection commands demonstrated in the solution can take different argu-
ments and options that restrict results or return additional information.
Needs@"DatabaseLink`"D
conn = OpenSQLConnectionA"MySQLTest"E;
For example, the SQLTables command can retrieve specific tables by name or using
wildcards % (zero or more characters) and _ (any single character). By default, only
tables are returned, but you can use the option TableType to list other tablelike enti-
ties, such as views. 
SQLTables@connD
9SQLTableAdata1, TableType Ø TABLEE, SQLTableAdata2, TableType Ø TABLEE=
SQLTablesAconn, "data1%", "TableType" Ø 8"TABLE", "VIEW"<E
9SQLTableAdata1, TableType Ø TABLEE,
SQLTableAdata1view100, TableType Ø VIEWE=
SQLTablesAconn, "data_", "TableType" Ø 8"TABLE", "VIEW"<E
9SQLTableAdata1, TableType Ø TABLEE, SQLTableAdata2, TableType Ø TABLEE=
If  you  are  unsure  what  kinds  of  table  types  your  database  supports,  you  can  list
them with SQLTableTypeNames.
SQLTableTypeNames@connD
8TABLE, VIEW, LOCAL TEMPORARY<
716 | Chapter 17: Interfacing Mathematica

SQLColumnNames  provides  similar  functionality.  Here  you  can  restrict  columns  to  a
particular table or columns in a table that match a pattern.
SQLColumnNames@connD
99data1, key=, 8data1, x1<, 8data1, x2<, 8data1, x3<,
9data2, akey=, 8data2, avalue<, 9data1view100, key=,
8data1view100, x1<, 8data1view100, x2<, 8data1view100, x3<=
SQLColumnNames@conn, "data_"D
99data1, key=, 8data1, x1<, 8data1, x2<,
8data1, x3<, 9data2, akey=, 8data2, avalue<=
SQLColumnNames@conn, 8"data_", "x_"<D
88data1, x1<, 8data1, x2<, 8data1, x3<<
See Also
Detailed discussion of descriptive commands can be found in DatabaseLink/tutorial/
TableStructure  and  DatabaseLink/tutorial/ColumnStructure  in  the  Mathematica
documentation.
17.10 Introspection of Databases | 717


CHAPTER 18
Tricks of the Trade
Meine tricks
Don’t know what I would do without
Tricks yeah yeah
Gimme tricks
Ihr wisst ich bin alleine ohne meine meine
Tricks yeah
That’s the only reason my heart still ticks
Vishnu, Batu, Fu Manchu too
Hu-Hu, Jonny Manushutu
Dr. Wu, Peggy Sue
Randy Andy too
One thing in common when they get up to their tricks
They do it for kicks
So if you ever see me acting
Like a kid from outer space
And you think of lending a hand
But if you look real close
You’ll see a smile on my face
Then I’m sure you’ll understand
Falco, “Tricks”
18.0 Introduction
This chapter’s recipes consist of Mathematica techniques and capabilities that every
serious user should have in their tool box. Unlike other chapters, the recipes here
are not tied together by any one theme. I include them because each recipe will give
you some deeper insight into details that are unique to the Mathematica architec-
ture. Each recipe has been a lifesaver to me at various times, and I hope that one or
more of them will be helpful to you. 
719

18.1 Cleaning Up During Incremental 
Development
Problem
You are solving a problem by incremental refinement of a set of functions. As you
proceed to refactor and introduce alternative definitions for symbols, you find that
code that was working before mysteriously breaks.
Solution
Make judicious use of Clear before every group of functions that are still undergoing
development. First, I illustrate what can go wrong if you are sloppy. Suppose you de-
fine this function f.
fAx_IntegerE := x^2;
Later, you decide that you should be more general about the valid types for argu-
ment x and also realize you really meant to compute x^2 +1, so you change the line
to this (deleting the previous line from the notebook):
f@x_?NumericQD := x^2 + 1
Later (possibly after you have forgotten the old version even existed), you try out
your code and are surprised by the result.
f@2D
4
To avoid problems like this, you should clear old definitions before defining a func-
tion. Then you can redefine f to your heart’s content without worrying that old defi-
nitions will interfere.
Clear@fD
f@x_?NumericQD := x^2 + 1
Discussion
Developers coming from other programming environments easily fall into the trap
caused by the fact that the kernel holds all definitions created during a session
unless they are specifically cleared or exactly redefined. This is not the expected be-
havior of languages that are compiled or interpreted, since in those environments old
definitions do not persist. The solution shows one way problems can arise, but there
are others. It is just as likely that conflicts can come from other notebooks that are
sharing the same kernel instance. Many Mathematica veterans begin their notebooks
720 | Chapter 18: Tricks of the Trade

with an expression to clear every symbol in the global context (a context is similar to
what other languages call namespaces). 
Clear@"Global`*"D
The Global` context is the default context in which new symbols are defined. 
You can also clear the command history. This is useful for freeing memory. Con-
sider the following example.
In[192]:=
MemoryInUse@D
Out[192]=
132430904
Let’s use a lot of memory.
In[193]:=
x = Array@f, 81000, 1000<D;
MemoryInUse@D
Out[194]=
188470896
Simply clearing x does not get the memory back because it is cached in the history.
In[196]:=
Clear@xD;
MemoryInUse@D
Out[197]=
188473032
However, you can clear the In and Out history by unprotecting, clearing, and repro-
tecting In and Out. 
In[198]:=
Unprotect@In, OutD;
Clear@In, OutD;
Protect@In, OutD;
MemoryInUse@D
Out[201]=
132287208
See Also
Problems with name conflicts can also be mitigated by use of packages. See Recipe 18.4.
18.2 Modifying Built-in Functions and Constants
Problem
You want to extend or alter the meaning of intrinsic functions that are built in to
Mathematica. Perhaps you want to introduce a mathematical object that has its own
natural definitions for the standard operations Plus, Times, etc. 
18.2 Modifying Built-in Functions and Constants | 721

Solution
The  most  straightforward  way  to  modify  Mathematica  operations  is  to  unprotect
them, augment their meaning, and protect them again. However, the easiest way is
frequently not the best or safest way, so be sure not to skip the “Discussion” section.
It is common in certain applications to consider 0^0 to be defined as 1; however,
Mathematica considers this expression to be indeterminate and will issue a warning
when it evaluates it (hence, the use of Quiet here).
0^0 êê Quiet
Indeterminate
You can change this behavior quite easily.
Unprotect@PowerD;
Power@0, 0D = 1;
Protect@PowerD;
0^0
1
This new behavior will persist only within the Mathematica kernel session and will
be known to all notebooks associated with the notebook’s kernel. See Recipe 18.9
for a way to make such changes automatically active each time you use Mathematica.
Discussion
The solution shows a reasonable change to the meaning of an intrinsic function. It is
reasonable because it is unlikely to change the behavior of Mathematica in a detri-
mental way since you are simply supplying meaning to an expression that had no
meaning. Technically speaking, it is possible that third-party code you are also using
depended on Power[0,0] evaluating to indeterminate; however, this possibility is far-
fetched. This is not the case for other seemingly reasonable changes. For example,
you might be irked by the following result:
H-1L^H1ê3L êê N
0.5 + 0.866025 Â
Clearly, an equally valid answer is -1. In fact, there are three valid answers. This is a
question of which branch Mathematica takes by default. 
Solve@x ^ 3 ã -1, xD êê N
88x Ø -1.<, 8x Ø 0.5 + 0.866025 Â<, 8x Ø 0.5 - 0.866025 Â<<
To remedy this choice, you might decide to take matters into your own hands and
force Mathematica to take a different branch whenever it needs to evaluate a rational
power of a negative number.
722 | Chapter 18: Tricks of the Trade

Unprotect@PowerD;
PowerAa_?Negative, n_RationalE = ExpAn Log@aD + n 2 Pi IE;
Protect@PowerD;
H-1L^H1ê3L êê N
-1.
This has an unfortunate consequence if you want Solve to work as before!
Solve@x ^ 3 ã -1, xD êê N
88x Ø -1.<, 8x Ø -1.<, 8x Ø -1.<<
Quitting the kernel will revert to the old behavior.
Quit@D
Solve@x ^ 3 ã -1, xD êê N
88x Ø -1.<, 8x Ø 0.5 + 0.866025 Â<, 8x Ø 0.5 - 0.866025 Â<<
Sometimes you want to temporarily change the meaning of a symbol. In that case,
use  of  Unprotect  is  overkill,  and  it  is  better  to  introduce  the  new  value  within  a
Block. For example, E is the built-in symbol for the base of the natural logarithm,
but in this block we use E as hex digit 14.
Block@8A = 10, B = 11, C = 12, D = 13, E = 14, F = 15<, A*16 + ED
174
This  technique  is  often  used  to  temporarily  change  special  global  variables  like
$RecursionLimit. The following is a recursive implementation of the Ackermann func-
tion that would easily overflow the default stack limit of 256. This is for illustration
purposes and not a good way to implement Ackermann.
H*Ackermann function*L
BlockA9$RecursionLimit = 100000, A=,
A@0, n_D := n + 1; A@m_, 0D := A@m, 0D = A@m - 1, 1D;
A@m_, n_D := A@m, nD = A@m - 1, A@m, n - 1DD; A@4, 1DE
65533
18.3 Locating Undocumented Functions
Problem
You are wondering what undocumented functions might be hiding in your current
version of Mathematica.
Solution
Inspect  the  Developer`  and  Experimental`  contexts  for  hidden  treasures.  Here,
//Short is used only to reduce clutter, so remove that before evaluating.
18.3 Locating Undocumented Functions | 723

In[891]:=
Names@"Developer`*"D êê Short
Out[891]//Short=
;Developer`BesselSimplify , á69à, Developer`$SymbolSystemShadowing ?
In[892]:=
Names@"Experimental`*"D êê Short
Out[892]//Short=
;Experimental`AngleRange , á47à, Experimental`Wait ?
Discussion
Strictly speaking, the Developer` context is not entirely undocumented, but rather
consists of low-level access to underlying algorithms that are typically used in the im-
plementation of higher-level, built-in functions. Here is an example of such a func-
tion and its documentation. However, you can see that the documentation is much
more sparse than that of a function available in standard System` context.
In[550]:=
?? Developer`PartitionMap
PartitionMap@f, list, nD applies f to list after
partitioning into non-overlapping sublists of length n.
PartitionMap@f, list, n, dD applies f to sublists
obtained by partitioning with offset d.
PartitionMap@f, list, 8n1, n2, …<D applies f after partitioning
a nested list into blocks of size n1 än2 ä… .
PartitionMap@f, list, 8n1, n2, …<, 8d1, d2, …<D applies f
after partitioning using offset di at level i.
PartitionMap@f, list, n, d, 8kL, kR<D specifies where
sublists should begin and end.
PartitionMap@f, list, n, d, 8kL, kR<, paddingD specifies
what padding should be used. °à
Attributes@Developer`PartitionMapD = 8Protected<
In  contrast,  expect  to  find  little  information  about  functions  in  the  Experimental`
context. 
In[558]:=
?? Experimental`ShortestSupersequence
Experimental`ShortestSupersequence
Attributes@Experimental`ShortestSupersequenceD = 8Protected<
Options@Experimental`ShortestSupersequenceD = 8IgnoreCase Ø False<
724 | Chapter 18: Tricks of the Trade

Even if you manage to figure out how these functions work, there is no guarantee
the functions won’t change or be removed in a future version, so use them with cau-
tion. Sometimes an experimental function will tell you it has been deprecated and
direct you to an alternative.
In[559]:=
Experimental`FileBrowse@D
Experimental`FileBrowse::obs :
Experimental`FileBrowse has been superseded by
SystemDialogInput, and is now obsolete. It
will not be included in Mathematica version 8.
See Also
PartitionMap was used in Recipe 2.6. 
18.4 Packaging Your Mathematica Solutions
into Libraries for Others to Use
Problem
You have a nice collection of functions that are of general use within your organiza-
tion or perhaps as a library that you want to distribute to others.
Solution
Mathematica provides a facility for defining custom packages that place functions in
a unique namespace and also allow you to selectively expose some functions while
leaving other low-level details hidden. 
BeginPackage["CoolStuff`"]
Unique`::usage = "Unique[list] removes duplicates from a list (similar to 
Union) but does not reorder elements of the list."
Begin["`Private`"]
Unique[list_List] := Module[{once}, 
once[x_] := once[x] = Sequence[];x
once /@ list]
End[]
EndPackage[]
18.4 Packaging Your Mathematica Solutions into Libraries for Others to Use | 725

Discussion
The solution follows a standard convention where actual definitions are placed in a
Private  context  (Begin["`Private`"]  ...  End[])  while  the  function  is  exposed  by
defining its usage string (Unique`::usage) in the public part of the package. Having
the definition of Unique inside Private does not mean you can’t access it. What it
does mean is that any symbols introduced inside the definition of Unique will not be
exported when the package is read in. The context Private` does not have any spe-
cial semantics, but it is a convention used by most Mathematica package authors,
and it would be wise to follow suit.
If a package depends on other packages, you can list the dependents as a second argu-
ment to BeginPackage. Here, CoolStuff` needs SuperCool` and Essential`.
BeginPackage["CoolStuff`", {"SuperCool`", "Essential`"}]
You can defer loading other packages until you know they are needed by using
DeclarePackage.  The  syntax  is  DeclarePackage["context`",  {"name1",  "name2",  ...}].
Here you are telling Mathematica to execute Needs["context`"] contingent on the use of
one of the symbols name1, name2, and so on (typically functions or constants).
BeginPackage["CoolStuff`"]
Cool`::usage = "Cool[list] does something cool."
Cooler`::usage = "Cooler[list] does something even cooler."
ReallyRadCool`::usage = "ReallyRadCool[list] does something too cool for words."
(*If functions Cooler or ReallyRadCool are used, then execute 
Needs["SuperCool`"].*)
DeclarePackage["SuperCool`", {"Cooler", "ReallyRadCool"}]
Begin["`Private`"]
Cool[list_List] := Module[{},
(*...*) 
]
Cooler[list_List] := Module[{x,y},
(*... uses something in SuperCool` context.*) 
]
ReallyRadCool[list_List] := Module[{elvis, jamesdean},
(*... uses something in SuperCool` context ...
  If I show you, I'd have to kill you.*) 
]
End[]
EndPackage[]
726 | Chapter 18: Tricks of the Trade

See Also
See the tutorial for setting up Mathematica packages: http://bit.ly/8Q9WIq.
Some good advice regarding the creation of packages can be found here in the Wolfram
Research MathGroup Archive: http://bit.ly/7rZ60P.
It is also worth reading Michael A. Morrison’s “Mathematica Tips, Tricks, and Tech-
niques” (http://bit.ly/5Z5dI9), although this is less about creating packages and more
about using them.
18.5 Compiling Functions to Improve 
Performance
Problem
You have a function that is called frequently and you want to optimize its performance. 
Solution
In many cases, you can remove a significant amount of overhead from your func-
tions by compiling them. You can compile functions that take Integer, Real, Complex,
Boolean arguments (True | False), or uniform vectors and tensors of these types.
magnitude1@vector : 8__Real<D := Sqrt@Plus üü vectorD;
magnitude2 = Compile@88vector, _Real, 1<<, Sqrt@Plus üü vectorDD;
vec = RandomReal@80, 10<, 1000000D;
TimingAmagnitude1@vecDE
80.485, 2236.01<
TimingAmagnitude2@vecDE
80.187, 2236.01<
Discussion
The syntax of Compile can be a bit confusing at first because it does not follow the tra-
ditional pattern-based syntax of an uncompiled function. This is partly due to the
fact that Compile is far less flexible, and each argument must be entirely unam-
biguous  in  regard  to  its  type.  First  note  that  Compile takes  a  list  of  argument
specifications  and  that  each  argument  specification  is  itself  a  list.  The  argument
specifications  must  at  minimum  specify  the  argument  name,  but  can  also  specify
the type and the rank~if the argument is a vector (rank = 1), matrix (rank = 2), or
tensor (rank > 2).
18.4 Packaging Your Mathematica Solutions into Libraries for Others to Use | 727

Table 18-1. Example argument specifications for compile
Argument specification
Description
8x<
x is some numeric type
8x, _Integer<
x is an Integer
8x, _Real<
x is a Real
8x, _Integer, 1<
x is a vector of Integers
8x, _Complex, 2<
x is a matrix of Complex
8x, _Real, 5<
x is a rank 5 tensor of Reals
8x, True
False, 1<
x is a vector of logical values
Note that functions that take strings or general symbolic arguments cannot be com-
piled. Also, if you specify a rank of two or higher, you must pass uniform arrays of
the appropriate rank rather than jagged arrays (like {{1,2},{3}}), and you can’t mix
types in vectors or higher-ranked tensors. If you violate these constraints, the func-
tion may still work, but Mathematica will use an uncompiled form, which defeats
the advantage of compilation.
18.6 Automating and Standardizing the 
Appearance of Notebooks Using Stylesheets
Problem
You find yourself frequently needing to tweak formatting in your notebook or you
find formatting tedious. You may be frustrated that your notebooks do not have the
professional  appearance  of  your  peers’  or  of  notebooks  you  see  at  conferences  or
download from the Web.
Solution
Creating  a  basic  stylesheet  or  modifying  an  existing  stylesheet  is  easier  than  you
might think, although there are some aspects that are tricky (or nearly impossible to
figure out without help). The easiest way to proceed is to start with a built-in style.
Starting with a new notebook, select Format, Stylesheet and select a style from one
of the submenus. Figure 18-1 shows a notebook configured with the NaturalColor
stylesheet, which is under the Creative submenu in Stylesheets. 
728 | Chapter 18: Tricks of the Trade

Figure 18-1. A notebook using the built-in Mathematica 7 stylesheet
Once you have a stylesheet selected that is close to how you want your notebook to
look, you can customize it by selecting the Format, Edit Stylesheet menu. This will
launch a special stylesheet notebook, shown in Figure 18-2. To modify an existing
style, use the “Choose a style” drop-down menu. This will add a cell to the note-
book  that  is  styled  in  the  selected  style.  By  altering  the  style  elements  of  this  cell
(using the Format menu), you update the stylesheet so this style now is associated
with the style of the cell. Think of this as styling by example, which is a bit different
than how stylesheets work in most word processors and certainly different than Cas-
cading Style Sheets (CSS) used in web pages, but simple enough. You can also add a
new style. In Figure 18-2, I add a style called Warning and give it a red font with gray
background. New styles are added by typing their names in the “Enter a style” edit
box and hitting Enter. 
Figure 18-2. Editing a stylesheet to modify existing styles or add new styles
18.6 Automating and Standardizing the Appearance of Notebooks Using Stylesheets | 729

Discussion
Often when creating a new style you want to base it on an existing style. This inheri-
tance of style attributes is a powerful capability because it reduces the effort for speci-
fying a style and allows changes to the base style  to  automatically  propagate  to
the derived. Creating derived styles involves getting your hands a bit dirty since you
need to drill down into the underlying syntax of the stylesheet cells. As an example,
imagine you want to create a base style called Note and a derived style called Warning.
The intent is to use Note to provide some extra parenthetical information. Warning
should derive from Note, but have a red font to emphasize that the extra information
is cautionary.
When you select a cell (or cells) in a stylesheet and use Ctrl-Shift-E (or Command-
Shift-E on Mac) you convert the cell to expression form, as shown in Figure 18-3.
Here I show two cells that have been changed to expression form. The first cell de-
fines  the  general  properties  I  want  to  have  for  a  note,  including  a  special  margin,
bold font, and gray background. I’ll discuss MenuPosition later.
Figure 18-3. Editing style option in expression form
For now, consider the second style cell. Note in particular the expression for Style-
Data. Here, in addition to the style’s name, there is a rule StyleDefinitions, which in-
dicates the base style is "Note". This is what you must type by hand to link a new
style to its base since there is presently no other way to establish this relationship.
Once the relationship is established, the Warning style will inherit all the attributes of
Note but will be able to override or augment them. Here you can see that I augment
Warning to use a red font. Once the inheritance is defined, you can revert the style
cells back to their normal form (Ctrl-Shift-E again) since most other changes can be
affected using the Format. 
730 | Chapter 18: Tricks of the Trade

When you create new styles, they are integrated into the frontend menus (Format,
Style) as well as the window’s toolbar (assuming you show the toolbar; see Window,
Show Toolbar). The position of the style within the choices is governed by the Menu-
Position option in the stylesheet cell (Figure 18-3). You can set this value to what-
ever number you want, but a sensible scheme is to use either 1 or 10000 (the default). If
you choose 1, the style will sort alphabetically within all styles that have the value 1.
If you choose 10000, the style will appear after all styles with position 1, but again,
sorted alphabetically. This sets up two groups, one for native styles (MenuPositionØ1)
and  the  other  for  custom  styles  (MenuPositionØ10000).  If  you  would  like  multiple
groupings,  use  an  intermediate  value  (like  5000),  but  don’t  attempt  to  assign  a
unique value to every style because this is not the intention of the option and will create
maintenance headaches for your stylesheet.
There are a few style settings that are tricky to set up. One in particular is a num-
bered style for a heading. Here you typically desire a series of headings and subhead-
ings  with  a  hierarchical  numbering  system.  The  NaturalColor  stylesheet  has  styles
called ItemNumbered and SubitemNumbered, so let’s look at these styles in expression
form (Figure 18-4).
Figure 18-4. Expression form for numbered styles does not reveal the numbering options
Do you see anything that would indicate that these styles have some auto-
numbering capability? No? Me either. These settings are magical. You need to select
the  cell  and  invoke  the  options  inspector.  Let’s  revert  to  normal  cell  form
(important!) and use Ctrl-Shift-O to inspect options for ItemNumbered. Figure 18-5
shows how the item counters are maintained and Figure 18-6 shows how the dis-
played output is generated. These options are not visible in the stylesheet because
they are inherited from the Default stylesheet. You can learn a great deal about Mathe-
matica’s  stylesheet  capabilities  by  studying  the  Default  stylesheet,  which  is  located  in
$InstallationDirectory <> "/SystemFiles/FrontEnd/StyleSheets/Default.nb".  Default
itself inherits from Core, so you should inspect that as well. You should avoid changing
18.6 Automating and Standardizing the Appearance of Notebooks Using Stylesheets | 731

either Core or Default; rather, customize your own stylesheet based on these,
as explained in the “Solution” section on page 728.
Figure 18-5. Options inspector for ItemNumbered reveals numbering settings
Figure 18-6. The CellDingbat option controls how the number is generated into the output
Armed with this information, you can create your own numbered styles. 
1-       This is h1 style.
1-1.   This is h2 style.
1-1-1 This is h3 style.
732 | Chapter 18: Tricks of the Trade

18.7 Transforming Notebooks into Other Forms
Problem
You want to extract content from notebooks to create other kinds of documents that
Mathematica does not support as a straight export. You may also want to extract
information from notebooks for other purposes.
Solution
Like everything in Mathematica, notebooks are expressions and can be manipulated
using the powerful expression manipulation facilities of Mathematica. Here is an
example that takes a chapter of Mathematica Cookbook and creates a recipe cross-
reference to native Mathematica symbols (those in the System` package).
In[518]:=
crossRef@8_, code__<, 8recipe_<D :=
9StringJoinAToString êü 8chapter, ".", recipe - 1<E,
IntersectionAnative, CasesA8code<, _String, InfinityEE=
crossRefCookbookChapterAch_Integer, path_StringE :=
Module@8nb<,
nb = NotebookOpen@path, Visible Ø FalseD;
crossRefCookbookChapter@ch, NotebookGet@nbDDD
crossRefCookbookChapterAch_Integer, nb_NotebookE :=
BlockA8native, chapter, cells, recipes, recipe = 0<,
chapter = ch;
native = ToString êü NamesA"System`*"E;
cells = CasesAnb, CellA_, "Heading1"
"Input", ___E, InfinityE;
recipes = GatherByAcells, FunctionAcell,
IfAMatchQAcell, CellA_, "Heading1", ___EE, ++recipe, recipeEEE;
MapIndexed@crossRef, recipesD
E
Here I run the transformation against Chapter 5’s notebook.
In[521]:=
crossRefCookbookChapterA5, NotebookDirectory@D <> "Strings.nb"E
18.7 Transforming Notebooks into Other Forms | 733

Out[521]=
995.0, 9CharacterEncoding, FromCharacterCode,
IgnoreCase, Input, NumberString, Partition, StringMatchQ,
TableForm, ToCharacterCode, ToString, True, $CharacterEncoding,
$CharacterEncodings, $SystemCharacterEncoding==, 85.1,
8Greater, GreaterEqual, Input, Less, LessEqual, Order, Protect, Unprotect<<,
95.2, 9Block, DateList, DatePattern, DatePlus, DateString,
Except, FileNameJoin, IgnoreCase, Import, Input, InputForm, N,
NotebookDirectory, NumberString, RegularExpression, Riffle, Shortest,
ShortestMatch, StringCases, StringDrop, StringJoin, StringReplace,
StringReplacePart, ToExpression, ToString, True, Whitespace==,
95.3, 9All, Except, False, IgnoreCase, Input, Overlaps,
RegularExpression, Repeated, Return, Shortest, StringCases,
StringJoin, StringTake, TableForm, True, WordBoundary==,
95.4, 9Array, Ceiling, Clear, Input, InputForm, Log, Mean,
Nest, StringJoin, StringTake, Table, Timing==,
95.5, 9DatePattern, False, FileNameJoin, FromDigits, Import,
Input, Length, NotebookDirectory, NumberString, OddQ,
Overlaps, Pick, Range, RegularExpression, SpellingCorrection,
StringDrop, StringFreeQ, StringMatchQ, StringPosition,
StringTake, TableForm, Transpose, True, With==,
95.6, 9Blue, Bold, Brown, Except, FileNameJoin, FontColor,
FontSlant, FontWeight, Import, Input, Italic, NotebookDirectory,
Red, Row, StringSplit, Style, WhitespaceCharacter==,
95.7, 9And, Block, Characters, Complement, DictionaryLookup,
DistanceFunction, EditDistance, False, If, IgnoreCase, Input,
Intersection, MapThread, MemberQ, Module, Nearest, SameTest, StringCount,
StringReplace, StringReverse, Tally, Timing, True, WordData==,
95.8, 9Apply, Cases, FileNameJoin, Head, ImageSize, Import,
Infinity, Input, InputForm, List, NotebookDirectory,
Symbol, TableForm, TreeForm, XMLElement, XMLObject==,
95.9, 9Apply, Cases, ExportString, FileNameJoin, If, Import, Infinity,
Input, Join, List, MatrixForm, NotebookDirectory, NumberString,
Rule, StringMatchQ, StringReplace, ToExpression, XMLElement==,
95.10, 9ClearAll, ExportString, FileNameJoin, Import, Input, List,
Module, NotebookDirectory, Order, Rule, Sort, Split, StringJoin,
StringReplace, ToExpression, ToString, XMLElement, XMLObject==,
95.11, 9Append, Apply, Ceiling, Drop, First, Flatten, FoldList, Format,
Hold, HoldAll, If, ImageSize, Infinity, Input, InputForm, Last, Length,
List, Map, MemberQ, Module, N, Plus, RandomInteger, RandomReal, Rest,
SeedRandom, SetAttributes, StringJoin, StringReplacePart, StringTake,
Table, TableForm, Top, ToString, ToUpperCase, TreeForm, Union, While===
734 | Chapter 18: Tricks of the Trade

Discussion
The easiest way to get a notebook into another form is to leverage the conversions
built into Save As. As of Mathematica 7, you can save a notebook as PDF, XHTML
+ MathML, plain text, Rich Text Format (RTF), and PostScript. However, if these
formats are not what you’re after, you should not be afraid to take matters into your
own hands as I did in the solution.
The command NotebookOpen is used to load the notebook from disk and produce a
NotebookObject. You use the option Visible Ø False to prevent the notebook from
being opened in a new window. NotebookGet is applied to the NotebookObject to re-
turn the raw symbolic form of the notebook for manipulation. Here the bulk of the
work  is  done  by  the  second  version  of  crossRefCookbookChapter.  Cases  is  used  to
parse out Cell expressions with the style Heading1 or Input. The Heading1 cells repre-
sent the recipe titles, and the Input cells are the ones you want to cross reference.
GatherBy groups input cells with their associated recipes, and then MapIndexed pro-
cesses  each  recipe  using  the  index  and  the  chapter  number  to  generate  the  recipe
number. The mapped function, crossRef, extracts strings and uses Intersection to lo-
cate just those strings that are in the set of native System` symbols.
One of the handiest uses of notebook manipulation is to create small bulk conver-
sion utilities. For example, imagine you had a large number of notebooks and you
needed to change one style into another. This would be tedious to do by hand, but
is a breeze with Mathematica. The converter would look something like this.
In[541]:=
ClearAconvertStyleE;
convertStyleApath_String, saveAs_String, fromStyle_String,
toStyle_StringE := ModuleA8<, NotebookSaveAconvertStyleA
NotebookOpen@path, Visible Ø FalseD, fromStyle, toStyleE, saveAsEE
convertStyleAnb_NotebookObject,
fromStyle_String, toStyle_StringE := ModuleA8<,
NotebookPutANotebookGet@nbD ê.
CellAc_, fromStyle, o___E ß CellAc, toStyle, oE, nbEE
Here I introduce NotebookPut and NotebookSave, which are used to modify the origi-
nal  notebook  object  and  save  it  back  to  disk,  respectively.  Here  is  an  example  of
usage:
In[543]:=
convertStyleANotebookDirectory@D <> "TestStyleConvert.nb",
NotebookDirectory@D <> "TestStyleConvertOut.nb", "Section", "Subsection"E
18.7 Transforming Notebooks into Other Forms | 735

See Also
Advanced notebook manipulations often require that you convert between strings,
boxes,  and  expressions.  See  the  tutorial/ConvertingBetweenStringsBoxesAndExpressions
in the Mathematica documentation for details.
18.8 Calling into the Mathematica Frontend
Problem
You want to programmatically invoke functionality that is provided by the frontend
rather than the kernel.
Solution
There are certain operations that are executed by the Mathematica frontend rather
than the kernel. If you are running a program from the frontend, you generally don’t
need to worry about the distinction, because Mathematica is designed to make the
distinction  appear  seamless.  However,  you  can  bypass  the  kernel  when  using  the
frontend with FrontEndExecute. 
In[2]:=
FrontEndExecute@
FrontEnd`CellPrint@Cell@"No Help From Kernel", "Emphasis"DDD
No Help From Kernel
You can also invoke actions typically performed via interaction with the frontend’s
menu. For example, the following will open the Font dialog.
In[5]:=
FrontEndExecute@FrontEndToken@"FontPanel"DD
Whereas FrontEndExecute is intended to be used in the frontend, UsingFrontEnd is
intended to be executed from a kernel session to allow the kernel to invoke an op-
eration in the frontend. The output here was created by executing the kernel di-
rectly on the command line.
In[1]:= nb = UsingFrontEnd[NotebookCreate[]]
Out[1]= -NotebookObject-
Note that a frontend must be installed on the system for this to work.
736 | Chapter 18: Tricks of the Trade

Discussion
You  can  see  all  the  commands  that  can  be  executed  directly  in  the  frontend  by
executing
Names@"FrontEnd`*"D
Sometimes you want to invoke features in the frontend that are not available via func-
tions. For example, while doing some notebook manipulations a la Recipe 18.7, you
wish to get the functionality available by selecting a cell and using CopyAs, Plain
Text. You can do this like so:
In[885]:=
someCell = Cell@
BoxData@RowBox@8"N", "@", FractionBox@"1", "9999"D, "D"<DD, "Input"D;
First@MathLink`CallFrontEnd@
FrontEnd`ExportPacket@someCell, "PlainText"DDD
Out[886]=
N@1ê9999D
See Also
See the tutorial ExecutingNotebookCommandsDirectlyInTheFrontEnd for more details
on frontend execution.
See  guide/FrontEndTokens  for  tokens  that  can  be  used  with  FrontEndToken  or
FrontEndTokenExecute.
Also  consult  tutorial/ManipulatingTheFrontEndFromTheKernel  for  further  commands
useful for controlling the frontend from the kernel.
18.9 Initializing and Cleaning Up Automatically
Problem
You want to automatically execute code whenever the kernel or frontend starts. You
may also want to execute code when the kernel is terminated.
Solution
There are several init.m files in which you can place function definitions or code you
want executed automatically.
To execute code on kernel start for every user, modify the file given by
In[865]:=
ToFileNameA9$BaseDirectory, "Kernel"=, "init.m"E
Out[865]=
êLibraryêMathematicaêKernelêinit.m
18.9 Initializing and Cleaning Up Automatically | 737

To execute code on kernel start for the currently logged-in user, modify the file given by
In[866]:=
ToFileNameA9$UserBaseDirectory, "Kernel"=, "init.m"E
Out[866]=
êUsersêsmanganoêLibraryêMathematicaêKernelêinit.m
To execute code on frontend start for every user, modify the file given by
In[867]:=
ToFileNameA9$BaseDirectory, "FrontEnd"=, "init.m"E
Out[867]=
êLibraryêMathematicaêFrontEndêinit.m
To execute code on frontend start for the currently logged-in user, modify the file
given by
In[868]:=
ToFileNameA9$UserBaseDirectory, "FrontEnd"=, "init.m"E
Out[868]=
êUsersêsmanganoêLibraryêMathematicaêFrontEndêinit.m
Clearly the results will vary depending on your particular OS.
Within these files, you can also modify the variable $Epilog to define code that exe-
cutes right before the kernel exits.
Discussion
If you make frequent use of some utility functions or constants, you can make sure
they are always available in every session. For example, if you always use a package
called  Essential`,  you  can  add  Needs["Essential`"]  to  the  user-level  version  of
init.m for the kernel. 
Note that user-level initializations come after system-wide ones, so if you want to
override some system-level definition, you can do so.
See Also
Recipe 18.10 shows a use case for init.m and $Epilog.
See ref/file/init.m in the Mathematica documentation for more information.
738 | Chapter 18: Tricks of the Trade

18.10 Customizing Frontend User Interaction
Problem
You want to hook into the processing performed by the frontend as you type and
evaluate expressions.
Solution
You can intercept Mathematica’s message loop at various stages by defining func-
tions for $PreRead, $Pre, $Post, $PrePrint, and $SyntaxHandler. For example, as an edu-
cator,  you  might  want  to  study  students’  experiences  with  learning  Mathematica
and log their interactions to a file. Here you can define $PreRead, which intercepts input
before being fed to Mathematica; $SyntaxHandler, which is applied to lines with syn-
tax errors; and $PrePrint, which gets the results before printing.
In[830]:=
InitializeStudentMonitoring@D :=
ModuleA9logFile, stream=,
logFile = $UserName <> DateStringA9"Year", "", "Month", "", "Day",
"-", "Hour24", "", "Minute", "", "SecondExact"=E <> ".log";
stream = OpenWriteAlogFileE ;
$PreRead = HWrite@stream, "Input> ", ÒD; ÒL &;
$PrePrint = HWrite@stream, "Output> ", ÒD; ÒL &;
$SyntaxHandler = IWriteAstream, "Syntax:", Ò2, "> " , Ò1E; $FailedM &;
stream
E
In[845]:=
StopStudentMonitoring@stream_D := ModuleA8<,
$PreRead =.;
$PrePrint =.;
$SyntaxHandler =.;
Close@streamDE
You can then place a call to InitializeStudentMonitoring[] in the init.m file and set
delayed $Epilog to StopStudentMonitoring[Evaluate[stream]]. 
In[850]:=
stream = InitializeStudentMonitoring@D;
$Epilog := StopStudentMonitoring@Evaluate@streamDD
18.10 Customizing Frontend User Interaction | 739

Discussion
The solution shows a use case for capturing but not altering session input and out-
put. However, you can also imagine advanced use cases where you want to use these
hooks  to  do  preprocessing  or  postprocessing.  Here  I  use  $PrePrint  to  force  any
string output into InputForm so I can see the quotes.
In[859]:=
$PrePrint = IfAStringQ@ÒD, InputForm@ÒD, ÒE &;
In[860]:=
"SomeString"
Out[860]=
"SomeString"
Now revert to default behavior.
In[863]:=
$PrePrint =.
In[864]:=
"SomeString"
Out[864]=
SomeString
See Also
See the tutorial tutorial/TheMainLoop for more information.
740 | Chapter 18: Tricks of the Trade

CHAPTER 19
Debugging and Testing
Trying hard to speak and
Fighting with my weak hand
Driven to distraction
So part of the plan
When something is broken
And you try to fix it
Trying to repair it
Any way you can
I’m diving off the deep end
You become my best friend
I wanna love you
But I don’t know if I can
I know something is broken
And I’m trying to fix it
Trying to repair it
Any way I can
Coldplay, “X&Y”
19.0 Introduction
Debugging and testing are not as romantic as solving a difficult partial differential
equation, creating a breathtaking plot, or achieving a compelling interactive demon-
stration of a complicated mathematical concept. But, to loosely paraphrase Edison,
Mathematica creation is often 10% coding and 90% debugging and testing. Mathe-
matica’s interactive development paradigm encourages incremental development, so
often you proceed to solve a complex problem by writing little pieces, trying them,
tweaking  them,  and  repeating.  In  time,  you  will  find  yourself  with  quite  a  bit  of
code.  Then,  quite  satisfied  with  yourself,  you  begin  to  feed  your  code  real-world
data  and~bam!~something  goes  awry.  Now  what?  Recipes  19.1  through  19.6
demonstrate various debugging techniques that you can use from within the tradi-
tional Mathematica frontend. Recipe 19.7 shows you how to use the powerful sym-
bolic debugger provide by Wolfram Workbench.
741

Debugging skills are essential, but here frustration can begin to creep in. Mathemat-
ica code can often be difficult to debug, and if you’ve written a lot of it in a haphazard
fashion, you might have your work cut out for you. There are two complementary
techniques for maintaining your sanity when working with Mathematica on large
projects. The first is knowing how to isolate the problem through debugging tech-
niques, and the second is not getting into the problem in the first place. Clearly, the
second is preferable, but how is it achieved? As convenient as interactive develop-
ment inside a notebook can be, it is often a trap. How thoroughly can you test a com-
plex  function  by  feeding  it  a  few  values?  Not  very  thoroughly.  The  solution  is  to
write repeatable unit tests. Why is that better? First, test-drive development (part
of what software developers call an agile development methodology) encourages
breaking problems into small, easily testable pieces. In its purest form, developers
are encouraged to actually write the test before the code! Having a test suite acts as
documentation for the use cases of your function and is a godsend if you decide to
enhance your implementation, because you can quickly see if you have broken exist-
ing functionality. Recipes 19.8 through 19.10 show how to develop unit tests within
Wolfram Workbench. Recipe 19.11 shows how to adapt the underlying MUnit frame-
work that is integrated with Wolfram Workbench for use in the frontend.
This chapter’s workhorse function for illustrating debugging techniques is the Acker-
mann  function.  This  infamous  function  has  a  simple  recursive  definition,  but  its
pathological behavior makes it convenient for illustrating various real-world debug-
ging problems (like stack overflows). 
A[0,n_] := n+1
A[m_,0] := A[m - 1, 1]
A[m_, n_] := A[m - 1, A[m, n - 1]]
Figure 19-1. Ackermann function
The  Mathematica  frontend  has  a  debugger  built  into  the  Evaluation
menu. I do not discuss this debugger in this chapter. I left it out for
several reasons. The main reason is that I never use it, and when I have
attempted to use it, I have found the experience quite unsatisfying. My
impression is that, at best, the frontend integrated debugger is a work
in progress. See ref/menuitem/DebuggerControls for description of the
debugger. 
742 | Chapter 19: Debugging and Testing

19.1 Printing as the First Recourse to Debugging
Problem
You can’t understand why you are getting a particular result but suspect it is due to
a false assumption or bug in an intermediate calculation whose value is not visible.
Solution
Injecting  a  strategically  placed  Print  statement  can  often  be  the  quickest  path  to
debugging a small piece of code. Suppose you forgot or did not know Mathematica’s
convention for choosing branches in the Power[x,y] function (it prefers the principal
value of ey log HxL).
In[1]:=
x = -1;
y = Power@x, 1ê3D;
IfA y ã -1, "expected", "not expected"E
Out[3]=
not expected
Here is the same code with a Print inserted so the value of y can be inspected. You
will often want to force numerical conversion using N[] when inserting Print; other-
wise  you  would  get  the  symbolic  value  (in  this  case  -1^(1/3)),  which  is  quite
unhelpful.
In[4]:=
x = -1;
y = Power@x, 1ê3D; PrintANAyEE;
IfA y ã -1, "expected", "not expected"E
0.5 + 0.866025 Â
Out[6]=
not expected
Discussion
Anyone who has spent even a day programming has come across this obvious debug-
ging  technique,  so  it  may  seem  hardly  worth  a  whole  recipe,  but  please  read  on.
Sometimes, injecting Print into code is very inconvenient, especially if you code in
tight function style with few intermediate values appearing in variables. The prob-
lem is that you can’t inject Print into functional code because Print does not return
a value. Consider if the code for the value y did not exist because it was in-lined.
In[7]:=
x = -1;
If@ Power@x, 1ê3D ã -1, "expected", "not expected"D
Out[8]=
not expected
19.1 Printing as the First Recourse to Debugging | 743

You can’t wrap the call to Power in a Print because it would change the behavior of
the expression, which is not what you want to do when you are already contending
with bugs. For these situations, it is handy to whip up a functional version of Print,
which I call fPrint. This saves you the trouble of introducing temporary variables
for purposes of debugging, thus leaving less mess to clean up after you have diag-
nosed the problem.
In[9]:=
fPrint@x__D := HPrint@xD; xL
x = -1;
If@ fPrint@N@Power@x, 1ê3DDD ã -1, "expected", "not expected"D
0.5 + 0.866025 Â
Out[11]=
not expected
A possible problem that can lead to lost or gray hairs when debugging with Print is
when it seems to print nothing. This can take you down the road to hell by mislead-
ing you into thinking your code must be taking a different branch. For example, it is
easy to miss the empty print cell created by executing this code.
In[12]:=
x = Sequence@D;
Print@xD
This is not as contrived as it may seem: there are bugs that arise from failure to con-
sider the fact that a sequence might be null, for example, when you use Apply (@@) on
an empty list.
In[14]:=
myFunctionThatIsBrokenForEmptySeq@x___D := Total@xD
IfAmyFunctionThatIsBrokenForEmptySeq üü 8< ã 0,
"zero", "not zero", "something completely different"E
Total::argt :
Total called with 0 arguments; 1 or 2 arguments are expected.
à
Out[15]=
"something completely different"
Here an error was generated, and the output was “something completely different”
because the expression in the If was neither True nor False. Pretend it was not imme-
diately obvious to you what was going on (after all, you clearly see that you called
Total with one argument x). You decide to use Print to get to the bottom of it.
Notice that introducing Print into this code requires the whole thing to be wrapped
in parentheses (another common debugging pitfall).
744 | Chapter 19: Debugging and Testing

In[16]:=
myFunctionThatIsBrokenForEmptySeq@x___D := HPrint@xD; Total@xDL
IfAmyFunctionThatIsBrokenForEmptySeq üü 8< ã 0,
"zero", "not zero", "something completely different"E
Total::argt :
Total called with 0 arguments; 1 or 2 arguments are expected.
à
Out[17]=
"something completely different"
If you were confused before, you are now totally befuddled! Here is where your own
little functional fPrint can help, but you need to tweak it slightly to expose two com-
mon ghosts you might encounter in the wild. 
In[18]:=
Clear@fPrintD;
fPrint@D := HPrint@"NullSequence!!"D; Unevaluated@Sequence@DDL
fPrint@""D := IPrintA"NullString!!"E; ""M
fPrint@x__D := HPrint@xD; xL
Now the problem is revealed, and you also side-stepped the parenthesis mistake.
In[22]:=
myFunctionThatIsBrokenForEmptySeq@x___D := Total@fPrint@xDD
IfAmyFunctionThatIsBrokenForEmptySeq üü 8< ã 0,
"zero", "not zero", "something completely different"E
NullSequence!!
Total::argt :
Total called with 0 arguments; 1 or 2 arguments are expected.
à
Out[23]=
"something completely different"
See Also
There  are  other  output  functions  (PrintTemporary,  CellPrint,  and  MessageDialog)
that may be useful in certain debugging situations. See the documentation for these
functions. I use PrintTemporary as part of the solution in Recipe 19.5.
19.1 Printing as the First Recourse to Debugging | 745

19.2 Debugging Functions Called Many Times 
Problem
You have a function that is invoked thousands of times, but only a few of the calls
produce an unexpected result, and it is difficult to determine which invocations are
causing the problem. Print is a poor choice because of the unreasonable amount of
data that may get printed before you identify the issue.
Solution
Use the Reap-Sow combination discussed in Recipe 2.10 to capture the data so you
can analyze it using pattern matching or plotting. For example, imagine you have a
function called func that is returning unexpected negative values and you are trying
to understand the arguments that lead up to negative results. Here I use a contrived
function for sake of the example. You can write a little wrapper around the function
like so.
In[24]:=
func@a_, b_, c_, d_D := If@a + 16 < b + c , 1 - d, b + cD
funcWrapperAargs__E :=
ModuleA8r<, r = funcAargsE ; IfAr < 0, SowA9args=EE; rE
8result, 8problem<< =
Reap@Table@funcWrapper@a, b, c, dD, 8a, 10<, 8b, 10<, 8c, 10<, 8d, 10<DD;
You can now see that there are 90 sets of arguments that caused the negative condi-
tion. Furthermore, you have the exact problematic values captured in a variable and
can use the values to debug the function using techniques presented in other recipes
in this chapter.
In[27]:=
Length@problemD
Out[27]=
90
Invoking the function on these problematic arguments is a cinch using @@@.
In[28]:=
func üüü problem
Out[28]=
8-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9<
746 | Chapter 19: Debugging and Testing

Discussion
Reap-Sow are a powerful debugging tool because they can direct debug data into an
arbitrary number of channels. By channel, I refer to the capability of Sow to specify a
tag as a second argument such that all instances of Sow with that tag collect data into
a distinct list. For example, imagine you want to detect when func returns zero but
want to segregate those arguments from the arguments that cause negative results. 
In[29]:=
funcWrapperAargs__E := ModuleA8r<, r = funcAargsE ;
WhichAr < 0, SowA9args=, negativeE, r ã 0, SowA9args=, zeroE, True, 0E; rE
In[30]:=
8result, 88n<, 8z<<< = ReapATable@funcWrapper@a, b, c, dD,
8a, 10<, 8b, 10<, 8c, 10<, 8d, 10<D, 9negative, zero=E;
Now  you  can  use  these  values  as  separate  test  sets  to  understand  these  distinct
behaviors.
In[31]:=
func üüü n
Out[31]=
8-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9,
-1, -2, -3, -4, -5, -6, -7, -8, -9, -1, -2, -3, -4, -5, -6, -7, -8, -9<
In[32]:=
func üüü z
Out[32]=
80, 0, 0, 0, 0, 0, 0, 0, 0, 0<
See Also
Recipe  19.6  shows  another  common  application  of  Reap-Sow  in  the  debugging  of
built-in numerical algorithms or plotting functions.
Recipe 19.3 shows how to use  Reap-Sow to take Stack snapshots.
19.3 Stack Tracing to Debug Recursive Functions
Problem
You have a recursive function that is unexpectedly violating $RecursionLimit and gen-
erating  an  error.  Alternatively,  you  have  a  complex  function  with  many  function
calls and you want to understand the sequence of calls that leads up to an error con-
dition or erroneous value.
19.3 Stack Tracing to Debug Recursive Functions | 747

Solution
Use Stack[] to output a stack trace. Here I use Ackermann’s function to illustrate
the use of Stack because it will easily violate any sane recursion limit. Further, I cre-
ate a function that will detect stack overflow before it happens and Throw the stack
to caller. Specifically, I throw those expressions on the stack that match the function
of interest by using Stack[A].
In[33]:=
debugStack@D :=
IfALength@Stack@DD + 1 ¥ $RecursionLimit, Throw@Stack@ADDE;
A@0, n_D := n + 1
A@m_, 0D := IdebugStack@D; A@m - 1, 1DM
A@m_, n_D := IdebugStack@D; A@m - 1, A@m, n - 1DDM
In[37]:=
CatchABlockA9$RecursionLimit = 30=, A@4, 1DEE
Out[37]=
8A@4 - 1, A@4, 1 - 1DD, A@2 - 1, A@2, 5 - 1DD,
A@2 - 1, A@2, 4 - 1DD, A@1 - 1, A@1, 7 - 1DD,
A@1 - 1, A@1, 6 - 1DD, A@1 - 1, A@1, 5 - 1DD, A@1 - 1, A@1, 4 - 1DD,
A@1 - 1, A@1, 3 - 1DD, A@1 - 1, A@1, 2 - 1DD, A@1 - 1, A@1, 1 - 1DD<
Discussion
If you want to take multiple snapshots of the stack during the progression of the func-
tion, regardless whether it overflows or not, you can use Reap-Sow.
In[38]:=
Clear@fD
In[39]:=
f@0D := Module@8<, Sow@Stack@TimesDD; 1D
f@x_D := Module@8<, Sow@Stack@TimesDD; x * f@x - 1DD
In[41]:=
Reap@f@3DD
Out[41]=
86, 888<, 83 f@3 - 1D<,
83 f@3 - 1D, 2 f@2 - 1D<, 83 f@3 - 1D, 2 f@2 - 1D, 1 f@1 - 1D<<<<
Out[44]=
86, 888<, 83 f@3 - 1D<,
83 f@3 - 1D, 2 f@2 - 1D<, 83 f@3 - 1D, 2 f@2 - 1D, 1 f@1 - 1D<<<<
Out[189]=
86, 888<, 83 f@3 - 1D<,
83 f@3 - 1D, 2 f@2 - 1D<, 83 f@3 - 1D, 2 f@2 - 1D, 1 f@1 - 1D<<<<
86, 888<, 83 f@3 - 1D<,
83 f@3 - 1D, 2 f@2 - 1D<, 83 f@3 - 1D, 2 f@2 - 1D, 1 f@1 - 1D<<<<
748 | Chapter 19: Debugging and Testing

See Also
StackInhibit can be used to keep certain expressions from showing up in the evalua-
tion  stack.  It  can  be  helpful  to  insert  this  function  into  your  code  to  control  the
amount of information in the stack. I use this function as part of Recipe 19.5.
19.4 Taming Trace to Extract Useful Debugging 
Information
Problem
Trace provides an extremely detailed account of the evaluation of an expression; how-
ever, for all but the most trivial expressions, this voluminous detail can be difficult
to wade through. 
Solution
Again, I use the Ackermann function to illustrate the issue, although this problem is
not particular to recursive functions. Ackermann is convenient because it creates a
large  number  of  nested  function  calls  and  intermediate  expressions.  In  addition,  I
purposefully  throw  a  monkey  wrench  into  this  function  to  simulate  a  bug:  "bug".
Real-world bugs don’t come so nicely labeled (if only!) but the point here is that in a
real-world debugging situation you are looking for a particular subexpression that
looks fishy based on your knowledge of the intended computation. 
In[42]:=
A@0, n_D := n + 1
A@m_, 0D := A@m - 1, 1D
A@m_, 2D := I "bug"; A@m - 1, A@m, 1DDM
A@m_, n_D := A@m - 1, A@m, n - 1DD
If you attempt to trace this buggy Ackermann on even relatively tame inputs, you
will quickly generate a lot of output that anyone but the most seasoned Mathemat-
ica developer would have trouble deciphering. In essence, what you are seeing is an
expansion of the call tree, and thus, the problem is not only the amount of output
but the deeply nested structure of the output. You could easily miss the “bug” in
this data, and even if you spot it, you might still have trouble understanding what
led up to its occurrence. 
19.4 Taming Trace to Extract Useful Debugging Information | 749

In[46]:=
trace = Trace@A@2, 3DD
Out[46]=
9A@2, 3D, A@2 - 1, A@2, 3 - 1DD, 82 - 1, 1<,
983 - 1, 2<, A@2, 2D, bug; A@2 - 1, A@2, 1DD,
982 - 1, 1<, 9A@2, 1D, A@2 - 1, A@2, 1 - 1DD, 82 - 1, 1<, 881 - 1, 0<, A@2, 0D,
A@2 - 1, 1D, 82 - 1, 1<, A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 81 - 1, 0<,
881 - 1, 0<, A@1, 0D, A@1 - 1, 1D, 81 - 1, 0<, A@0, 1D, 1 + 1, 2<,
A@0, 2D, 2 + 1, 3<, A@1, 3D, A@1 - 1, A@1, 3 - 1DD,
81 - 1, 0<, 983 - 1, 2<, A@1, 2D, bug; A@1 - 1, A@1, 1DD,
881 - 1, 0<, 8A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 81 - 1, 0<,
881 - 1, 0<, A@1, 0D, A@1 - 1, 1D, 81 - 1, 0<, A@0, 1D, 1 + 1, 2<,
A@0, 2D, 2 + 1, 3<, A@0, 3D, 3 + 1, 4<, 4=, A@0, 4D, 4 + 1, 5=, A@1, 5D,
A@1 - 1, A@1, 5 - 1DD, 81 - 1, 0<, 985 - 1, 4<, A@1, 4D, A@1 - 1, A@1, 4 - 1DD,
81 - 1, 0<, 984 - 1, 3<, A@1, 3D, A@1 - 1, A@1, 3 - 1DD,
81 - 1, 0<, 983 - 1, 2<, A@1, 2D, bug; A@1 - 1, A@1, 1DD,
881 - 1, 0<, 8A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 81 - 1, 0<,
881 - 1, 0<, A@1, 0D, A@1 - 1, 1D, 81 - 1, 0<, A@0, 1D, 1 + 1, 2<,
A@0, 2D, 2 + 1, 3<, A@0, 3D, 3 + 1, 4<, 4=, A@0, 4D, 4 + 1, 5=,
A@0, 5D, 5 + 1, 6=, A@0, 6D, 6 + 1, 7=, 7=, A@1, 7D,
A@1 - 1, A@1, 7 - 1DD, 81 - 1, 0<, 987 - 1, 6<,
A@1, 6D,
A@1 - 1, A@1, 6 - 1DD,
81 - 1, 0<,
986 - 1, 5<, A@1, 5D, A@1 - 1, A@1, 5 - 1DD, 81 - 1, 0<,
985 - 1, 4<, A@1, 4D, A@1 - 1, A@1, 4 - 1DD, 81 - 1, 0<,
984 - 1, 3<, A@1, 3D, A@1 - 1, A@1, 3 - 1DD, 81 - 1, 0<,
983 - 1, 2<, A@1, 2D, bug; A@1 - 1, A@1, 1DD, 881 - 1, 0<,
8A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 81 - 1, 0<, 881 - 1, 0<, A@1, 0D,
A@1 - 1, 1D, 81 - 1, 0<, A@0, 1D, 1 + 1, 2<, A@0, 2D, 2 + 1, 3<,
A@0, 3D, 3 + 1, 4<, 4=, A@0, 4D, 4 + 1, 5=, A@0, 5D, 5 + 1, 6=,
A@0, 6D, 6 + 1, 7=, A@0, 7D, 7 + 1, 8=, A@0, 8D, 8 + 1, 9=
Using Depth, you can see that there are 13 levels in the expression output by Trace
(although this is inflated by the existence of HoldForm, as I explain later). In a real-
world use of Trace, you could easily encounter output with depth an order of magni-
tude larger and an overall output several orders of magnitude larger still.
In[47]:=
Depth@traceD
Out[47]=
13
To understand this solution, be aware that all the intermediate expressions output
by Trace are wrapped in HoldForm to prevent their evaluation (which would of course
defeat the purpose of Trace). You can see this by using InputForm. I use Short to sup-
press repeating the mess of output from above.
750 | Chapter 19: Debugging and Testing

In[48]:=
trace êê InputForm êê Short
Out[48]//Short=
8HoldForm@A@2, 3DD, HoldForm@A@2
- 1, A@2, <<1>>DDD, <<8>>, HoldForm@9D<
One way to get a handle on the output of Trace is to linearize it so you get a flat
structure that presents the sequence of operations as they occur in time. This can be
done by using what amounts to a preorder tree traversal.
In[49]:=
Clear@traverseTrace, traverseTrace1D;
traverseTrace@x_D := Flatten@Reap@traverseTrace1@xDDD
traverseTrace1@8<D := Sequence@D
traverseTrace1@x_ListD :=
HtraverseTrace1@First@xDD; traverseTrace1@Rest@xDDL
traverseTrace1@HoldForm@x_DD := Sow@HoldForm@xDD
This still produces as much raw data, but its linear nature makes it easier to visualize
and manipulate. 
In[54]:=
timeSequence = traverseTrace@traceD
Out[54]=
9A@2, 3D, A@2 - 1, A@2, 3 - 1DD, 2 - 1, 1, 3 - 1, 2, A@2, 2D, bug;
A@2 - 1, A@2, 1DD, 2 - 1, 1, A@2, 1D, A@2 - 1, A@2, 1 - 1DD, 2 - 1, 1, 1 - 1,
0, A@2, 0D, A@2 - 1, 1D, 2 - 1, 1, A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 1 - 1,
0, 1 - 1, 0, A@1, 0D, A@1 - 1, 1D, 1 - 1, 0, A@0, 1D, 1 + 1, 2, A@0, 2D,
2 + 1, 3, A@1, 3D, A@1 - 1, A@1, 3 - 1DD, 1 - 1, 0, 3 - 1, 2, A@1, 2D, bug;
A@1 - 1, A@1, 1DD, 1 - 1, 0, A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 1 - 1, 0,
1 - 1, 0, A@1, 0D, A@1 - 1, 1D, 1 - 1, 0, A@0, 1D, 1 + 1, 2, A@0, 2D, 2 + 1,
3, A@0, 3D, 3 + 1, 4, 4, A@0, 4D, 4 + 1, 5, A@1, 5D, A@1 - 1, A@1, 5 - 1DD,
1 - 1, 0, 5 - 1, 4, A@1, 4D, A@1 - 1, A@1, 4 - 1DD, 1 - 1, 0, 4 - 1, 3, A@1, 3D,
A@1 - 1, A@1, 3 - 1DD, 1 - 1, 0, 3 - 1, 2, A@1, 2D, bug; A@1 - 1, A@1, 1DD,
1 - 1, 0, A@1, 1D, A@1 - 1, A@1, 1 - 1DD, 1 - 1, 0, 1 - 1, 0, A@1, 0D,
A@1 - 1, 1D, 1 - 1, 0, A@0, 1D, 1 + 1, 2, A@0, 2D, 2 + 1, 3, A@0, 3D, 3 + 1,
4, 4, A@0, 4D, 4 + 1, 5, A@0, 5D, 5 + 1, 6, A@0, 6D, 6 + 1, 7, 7, A@1, 7D,
A@1 - 1, A@1, 7 - 1DD, 1 - 1, 0, 7 - 1, 6, A@1, 6D, A@1 - 1, A@1, 6 - 1DD,
1 - 1, 0, 6 - 1, 5, A@1, 5D, A@1 - 1, A@1, 5 - 1DD, 1 - 1, 0, 5 - 1, 4, A@1, 4D,
A@1 - 1, A@1, 4 - 1DD, 1 - 1, 0, 4 - 1, 3, A@1, 3D, A@1 - 1, A@1, 3 - 1DD,
1 - 1, 0, 3 - 1, 2, A@1, 2D, bug; A@1 - 1, A@1, 1DD, 1 - 1, 0, A@1, 1D,
A@1 - 1, A@1, 1 - 1DD, 1 - 1, 0, 1 - 1, 0, A@1, 0D, A@1 - 1, 1D, 1 - 1, 0,
A@0, 1D, 1 + 1, 2, A@0, 2D, 2 + 1, 3, A@0, 3D, 3 + 1, 4, 4, A@0, 4D, 4 + 1, 5,
A@0, 5D, 5 + 1, 6, A@0, 6D, 6 + 1, 7, A@0, 7D, 7 + 1, 8, A@0, 8D, 8 + 1, 9=
Discussion
Once you have linearized the output of Trace, you can easily extract segments of the
execution history or use patterns to extract specific segments of interest.
19.4 Taming Trace to Extract Useful Debugging Information | 751

In[55]:=
timeSequence@@5 ;; 18DD êê InputForm
Out[55]//InputForm=
9HoldForm@3 - 1D, HoldForm@2D, HoldForm@A@2, 2DD,
HoldFormAbug; A@2 - 1, A@2, 1DDE, HoldForm@2 - 1D, HoldForm@1D,
HoldForm@A@2, 1DD, HoldForm@A@2 - 1, A@2, 1 - 1DDD, HoldForm@2 - 1D,
HoldForm@1D, HoldForm@1 - 1D, HoldForm@0D, HoldForm@A@2, 0DD,
HoldForm@A@2 - 1, 1DD=
Here I use ReplaceList to find every occurrence of a call to A where the first argu-
ment was 0, and then output the expression computed immediately before and im-
mediately after.
In[56]:=
ReplaceList@timeSequence ,
8___, a_, HoldForm@A@0, z_DD, b_, ___< ß 8a, HoldForm@A@0, zDD, b<D
Out[56]=
880, A@0, 1D, 1 + 1<, 82, A@0, 2D, 2 + 1<,
80, A@0, 1D, 1 + 1<, 82, A@0, 2D, 2 + 1<, 83, A@0, 3D, 3 + 1<,
84, A@0, 4D, 4 + 1<, 80, A@0, 1D, 1 + 1<, 82, A@0, 2D, 2 + 1<,
83, A@0, 3D, 3 + 1<, 84, A@0, 4D, 4 + 1<, 85, A@0, 5D, 5 + 1<,
86, A@0, 6D, 6 + 1<, 80, A@0, 1D, 1 + 1<, 82, A@0, 2D, 2 + 1<,
83, A@0, 3D, 3 + 1<, 84, A@0, 4D, 4 + 1<, 85, A@0, 5D, 5 + 1<,
86, A@0, 6D, 6 + 1<, 87, A@0, 7D, 7 + 1<, 88, A@0, 8D, 8 + 1<<
More  to  the  point,  here  I  do  the  same  with  the  pattern  that  is  the  proxy  for  the
buggy behavior. This shows the expressions that preceded and followed the bug.
In[57]:=
ReplaceListAtimeSequence ,
9___, a_, HoldFormA"bug"; z__E, b_, ___= ß 9a, HoldFormA"bug"; zE, b=E
Out[57]=
99A@2, 2D, bug; A@2 - 1, A@2, 1DD, 2 - 1=,
9A@1, 2D, bug; A@1 - 1, A@1, 1DD, 1 - 1=,
9A@1, 2D, bug; A@1 - 1, A@1, 1DD, 1 - 1=,
9A@1, 2D, bug; A@1 - 1, A@1, 1DD, 1 - 1==
Clearly, linearizing loses some information that was in the original output of Trace.
What you lose is the information that says a certain bunch of subexpressions were
triggered  by  some  parent  expression.  But,  the  act  of  debugging  (or  indeed  under-
standing any complex data set) is the act of suppressing extraneous information un-
til  you  can  identify  the  area  where  there  was  a  problem.  Then  some  strategically
placed debug code or Print functions can often get you the rest of the way to the fix.
A very similar result to this solution can be obtained using a variation of Trace called
TraceScan along with Reap-Sow. The difference is that this expression will include a
bit more extraneous detail because it shows the evaluation of every symbol and con-
stant. Here is an excerpt using Short.
752 | Chapter 19: Debugging and Testing

In[58]:=
Reap@TraceScan@Sow, A@2, 3DDD@@2, 1DD êê Short
Out[58]//Short=
8A@2, 3D, A, 2, 3, A@2 - 1, A@2, 3 - 1DD, A, 2 - 1,
Plus, 2, á450à, 7, 1, 8, A@0, 8D, 8 + 1, Plus, 8, 1, 9<
See Also
Trace has advanced features I did not cover here. Refer to tutorial/TracingEvaluation
in the Mathematica documentation for details as well as a description of the related
functions TraceDialog and TracePrint.
19.5 Creating a Poor Man’s Mathematica 
Debugger 
Problem
You  tried  debugging  using  Print,  but  your  program  creates  too  much  output  too
quickly and it is difficult to identify the issue. You want to have more control of the
debugging process. 
Solution
Mathematica has an alternative print command called PrintTemporary that inspired
me to create a sort of interactive debugger. PrintTemporary works just like Print ex-
cept after the evaluation is complete the output is automatically removed. Further,
PrintTemporary returns a value that can be passed to the function NotebookDelete to
delete the output at any time. You can get an idea of what PrintTemporary does by
evaluating the following line:
In[59]:=
PrintTemporary@"test"D; Pause@2D
If you could inject debug code into your ill-behaved programs that used PrintTemporary
and then paused until you took some action (like pressing a button), you could effec-
tively step though the code with the embedded prints acting like breakpoints in a
real debugger. This can be done using a relatively small amount of code. 
19.5 Creating a Poor Man’s Mathematica Debugger | 753

In[60]:=
pmDebuggerInit@D :=
ModuleA8<, $pmStep = False; $pmStop = False; CellPrintADynamicARowA
9ButtonA"Step", $pmStep = TrueE, ButtonA"Stop", $pmStop = TrueE=EEEE
pmWait@x___, t_D := IWhileA$pmStep == False && $pmStop ã False,
PauseA $TimeUnitEE; IfA$pmStop, Abort@DE; NotebookDelete@tD; xM
pmPrint@D := ModuleA8t<, $pmStep = False;
t = PrintTemporary@"NullSequence!!"D;
pmWait@Unevaluated@Sequence@DD, tDE
pmPrint@""D := ModuleA8t<, $pmStep = False;
t = PrintTemporaryA"NullString!!"E; pmWait@"", tDE
pmPrint@x__D := ModuleA8t<, $pmStep = False;
t = PrintTemporary@xD; pmWait@x, tDE
I explain this code further in the following “Discussion” section. For now, let’s just try
it out. Here I use an instrumented version of the Ackermann function as a test example. 
In[65]:=
A@0, n_D := pmPrint@n + 1D;
A@m_, 0D := A@m - 1, 1D;
A@m_, n_D := A@m - 1, A@m, n - 1DD;
test@D := ModuleA8<, pmDebuggerInit@D; A@4, 1DE
Executing test[] creates the debugging controls.
In[85]:=
test@D
Step Stop
3
Discussion
The code in the solution contains two user functions, pmPrint and pmDebuggerInit.
Function pmPrint has the same features as fPrint from Recipe 19.1, but it uses Print-
Temporary  rather  than  Print.  Further,  it  calls  a  function  pmWait,  which  loops  and
pauses until a Boolean variable becomes true. These variables are initialized in
pmDebuggerInit and associated with buttons that are used to control progress of the
debugging session.
Often when creating little utilities like this, it’s fun to see how far you can extend
them without going too far over the top. There are a few deficiencies in the solu-
tion’s debugging techniques. First, if you insert multiple print statements, there is no
way to know which one created output. Second, it would be nice if you did not al-
ways have to step one print at a time. Third, it might be nice if you can also dump
754 | Chapter 19: Debugging and Testing

the stack while the program is paused. It turns out that using a bit of cleverness can
get you all this new functionality using roughly the same amount of code. 
In[69]:=
ClearApmDebuggerInit, pmWait, pmPrintE;
pmDebuggerInit@D :=
ModuleA8<, $pmStep = 1; $pmStop = Function@FalseD; $pmPrintCells = 8<;
CellPrintADynamicA
RowA9ButtonA"Step", INotebookDelete êü $pmPrintCells; $pmStep = 1ME,
ButtonA"Step 10", INotebookDelete êü $pmPrintCells; $pmStep = 10ME,
ButtonA"Stack", $pmStop = FunctionA
StackInhibitAPrependToA$pmPrintCells, PrintTemporary@Stack@DDE;
$pmStop = Function@FalseD; FalseEEE,
ButtonA"Stack Detail", $pmStop = FunctionAStackInhibitA
PrependToA$pmPrintCells, PrintTemporary@Most@Stack@_DDDE;
$pmStop = Function@FalseD; FalseEEE
ButtonA"Stop", $pmStop = Function@Abort@DDE=EEEE
pmWait@x___D :=
IWhileA$pmStep ã 0 && $pmStop@D ã False, PauseA $TimeUnitEE; xM
pmPrintAx__, tag_: ""E :=
ModuleA8<, StackInhibitA$pmStep--; PrependToA$pmPrintCells,
PrintTemporaryARowA9tag, x=, " "EEE; pmWait@xDEE
pmPrintAtag_: ""E := ModuleA8<, $pmStep--; PrependToA$pmPrintCells,
PrintTemporaryARowA9tag, "NullSequence!!"=, " "EEE; pmWait@""DE
In[74]:=
A@0, n_D := pmPrint@n + 1, "n+1="D;
A@m_, 0D := A@pmPrint@m - 1, "m-1="D, 1D;
A@m_, n_D := A@m - 1, A@m, n - 1DD;
test@D := ModuleA8<, pmDebuggerInit@D; A@4, 1DE
In[95]:=
test@D
Step Step 10 Stack Stack Detail
Stop
n+1=2
The trick here is to convert $pmStep to a counter instead of a Boolean and $pmStop to
a function that can be changed by the buttons to either Abort or Print the Stack. I
also  introduce  a  new  variable  to  collect  multiple  temporary  print  cells  and  move
their cleanup to the button press for Step or Step 10. Finally, the pmPrint is refac-
tored  to  take  an  optional  tag  to  display  so  you  can  distinguish  one  debug  output
from another.
19.5 Creating a Poor Man’s Mathematica Debugger | 755

See Also
Recipes 19.1, 19.3, and 19.4 cover some of the functions used in this recipe in more
detail.
19.6 Debugging Built-In Functions with 
Evaluation and Step Monitors
Problem
You are using various black-box numerical algorithms like FindRoot, NDSolve, NIntegrate,
and the like, and you are getting puzzling results. You would like to get under the
covers to gain insight into what is going on.
Solution
A classic problem with FindRoot (which uses Newton’s method by default) is the pos-
sibility of getting into a cycle. If you did not know about this possibility, you might
be  confused  by  the  error  message  generated.  Here  I  suppress  the  message  using
Quiet  because  I  have  purposefully  cherry-picked  a  misbehaved  function.  FindRoot
has an option EvaluationMonitor that lets you hook every call to the supplied func-
tion. Here you use Reap-Sow  to capture these values for analysis. Note that you must
use RuleDelayed (:>) rather than Rule (->) with EvaluationMonitor.
In[78]:=
8result, 8xValues<< = Reap@
Quiet@FindRoot@x^3 - 2 x + 2, 8x, 0<, EvaluationMonitor ß Sow@xDDDD;
ListPlot@xValuesD
Out[79]=
50
100
150
0.7
0.8
0.9
1.0
1.1
756 | Chapter 19: Debugging and Testing

Discussion
Sometimes a StepMonitor can also be useful for debugging. Whereas EvaluationMonitor
shows each time a function is called, a StepMonitor is called only when the algo-
rithm takes a successful step toward the solution. Stephen Wolfram explains the dif-
ference best:
To take a successful step towards an answer, iterative numerical algorithms
sometimes have to do several evaluations of the functions they have been
given. Sometimes this is because each step requires, say, estimating a deriva-
tive from differences between function values, and sometimes it is because
several attempts are needed to achieve a successful step.
In the solution example, StepMonitor is less informative than EvaluationMonitor.
In[80]:=
8result, 8xValues<< =
Reap@Quiet@FindRoot@x^3 - 2 x + 2, 8x, 0<, StepMonitor ß Sow@xDDDD;
xValues êê InputForm
Out[81]//InputForm=
81., 0.8, 0.8178125000000002, 0.816037292480469, 0.8169240294396879,
0.816480444471563, 0.8165081617635014, 0.8164943029060661,
0.8164960352500287, 0.8164960352543595<
One reason you might use StepMonitor during debugging is to get a sense of how
much computational effort an algorithm is expending to find a solution. One mea-
sure of effort would be the average number of function calls per step. Here you can
see that the effort can vary widely for different algorithms and expressions.
In[82]:=
ClearAx, yE;
BlockA8stepCount = 0, callCount = 0<,
NDSolveA9y'@xD ã y@xD CosAx + y@xDE, y@0D ã 1=,
y, 8x, 0, 30<, StepMonitor ß stepCount++,
EvaluationMonitor ß callCount++E; N@callCountêstepCountDE
Out[83]=
2.14243
In[84]:=
ClearAx, yE;
BlockA8stepCount = 0, callCount = 0<,
NDSolveA9y'@xD ã y@xD CosAx + y@xDE, y@0D ã 1=, y, 8x, 0, 30<,
Method -> "ExplicitRungeKutta", StepMonitor ß stepCount++,
EvaluationMonitor ß callCount++E; N@callCountêstepCountDE
Out[85]=
16.039
19.6 Debugging Built-In Functions with Evaluation and Step Monitors | 757

In[86]:=
ClearAx, yE;
BlockA8stepCount = 0, callCount = 0<,
NDSolveA9y'@xD ã y@xD CosAx + y@xDE, y@0D ã 1=, y,
8x, 0, 30<, Method -> "Extrapolation", StepMonitor ß stepCount++,
EvaluationMonitor ß callCount++E; N@callCountêstepCountDE
Out[87]=
49.25
See Also
Evaluation and StepMonitor are also useful outside a debugging context. For example,
they can be used to visualize the behavior of an algorithm for educational purposes.
See the Wolfram documentation for examples.
19.7 Visual Debugging with Wolfram 
Workbench
Problem
You are a Mathematica user longing for the kinds of visual debugging environments
common in mainstream programming environments like Eclipse, Visual Studio,
InteliJ, DDD, and others.
Solution
Use Wolfram Workbench, a Mathematica-specific extension to the Eclipse platform.
When you launch Wolfram Workbench, you must first create a project. Use menu
File, New, New Project. Give the project a name. I used the name Debugging for this
example.  Workbench  automatically  creates  two  files  named  after  your  project.  In
this  example,  I  got  a  Debugging.m  and  a  Debugging.nb.  The  .m  file  is  where  you
would enter code that you want to debug. The Debugging.nb is a normal frontend
notebook file. Here you would typically set up your test calls.
A[0,n_] := n+1
A[m_,0] := A[m - 1, 1]
A[m_, n_] := A[m - 1, A[m, n - 1]]
Figure 19-2. Debugging.m~functions being debugged
758 | Chapter 19: Debugging and Testing

A[3,2]
Figure 19-3. Debugging.nb~place to exercise the functions to be debugged
Once you have these files set up, you can place a breakpoint by double-clicking on
the left margin of the line of code you want the debugger to stop. In Figure 19-4 you
see  a  dot  appear  in  the  margin  to  indicate  the  successful  placement  of  the  break-
point. You can place as many breakpoints as necessary.
Figure 19-4. Wolfram Workbench showing breakpoints on A[m_,0]
Now right-click on the Debugging.nb file in the Package Explorer and select Debug
As... Mathematica. You will be prompted to switch to the Debug perspective, which
is  recommended.  Figure  19-5  shows  what  this  perspective  looks  like.  It  will  also
launch the frontend with Debugging.nb active. Here you can use normal Shift-Enter
19.7 Visual Debugging with Wolfram Workbench | 759

evaluation to execute an expression. When a breakpoint is hit, you can switch back
to the Workbench to continue debugging. Here you can inspect the call stack, see
the value of variables, and set further breakpoints. You can step over or into further
functions using F5 (set), F6 (step over) and F7 (step return). In short, you can per-
form all the operations you’d expect from a modern symbolic debugger.
Figure 19-5. Wolfram Workbench in Debug perspective
Discussion
Many old-time Mathematica users feel that it is sacrilegious (or perhaps just frustrat-
ing) to leave the comfortable Mathematica frontend just to debug. If you don’t have
such a prejudice, your willingness will be rewarded. There is nothing like debugging
within a real debugging environment! If you are a Java or C programmer who is used
760 | Chapter 19: Debugging and Testing

to such luxuries, the Eclipse-based Workbench environment is a must-have. Eclipse
is an open source framework for building integrated software development environ-
ments  (IDEs)  that  first  gained  popularity  with  Java  developers.  Wolfram  used
Eclipse to build an alternative development environment for Mathematica as an alter-
native to the traditional frontend. However, you don’t need to abandon the tradi-
tional Mathematica interface to use Workbench to debug. In this section, I refer to
Eclipse when speaking about generic features that are true about all Eclipse IDEs and
Workbench when speaking about features of Workbench in particular.
If you have never used more traditional languages, such as Java, C, C++ and C#,
then you are likely to find working in Workbench somewhat foreign. To avoid being
frustrated, you should keep a few ideas in mind. First, because Workbench is built
on top of Eclipse and Eclipse was built outside of Wolfram, you should not expect
Workbench to have the same look and feel as the traditional frontend. You should
approach it as you would approach any new piece of software~with an open mind
and no preconceptions. For example, you should not expect to debug code that is
written using all the fancy mathematical typesetting features available in a notebook.
If you developed code solely using the .nb format, you should save your code as a
.m, which is a pure text format. This is not to say you can’t launch notebooks from
Eclipse (the solution shows this is possible) but rather you should make all code that
you wish to debug available in text format. 
Another important concept of Eclipse is that it wants to manage all the source code
under a project. Projects in Eclipse typically correspond to directories under a spe-
cific  root  directory  you  choose  when  Eclipse  is  installed.  It  is  possible  to  specify
other directories outside this hierarchy, but you will not automatically pick up files
that happen to be in an existing location. You can use File, Import for that purpose.
In addition to source code|level breakpoints, Workbench supports message break-
points that break when a function emits any error message and symbol breakpoints
that  provide  a  convenient  way  to  place  a  breakpoint  on  an  overloaded  function
name. For example, a symbol breakpoint can be used to put a break on all three vari-
ants  of  the  Ackermann  function  A.  The  three  types  of  breakpoints  are  accessible
from the Breakpoints tab shown in Figure 19-6. The message break is set using 
,
and  
 is used for symbol breakpoints. There are also buttons for clearing selected
breakpoints, 
, or all breakpoints, 
, and you can uncheck a breakpoint in
the list to temporarily disable it.
19.7 Visual Debugging with Wolfram Workbench | 761

Figure 19-6. Breakpoints tab has toolbar buttons for setting various types of breakpoints
See Also
If you are new to Eclipse, you should definitely check out the series of screencasts on
Wolfram Workbench at http://bit.ly/2srUoj.
19.8 Writing Unit Tests to Help Ensure 
Correctness of Your Code
Problem
You want to write unit tests to help uncover bugs in a library of functions. Perhaps
you are familiar with the unit-testing frameworks that exist in other languages, and
you would like the equivalent for Mathematica.
Solution
Wolfram  Workbench  is  nicely  integrated  with  MUnit,  a  unit-testing  framework
for  Mathematica.  You  create  a  unit  test  in  a  special  file  with  extension  .mt.  The
easiest  way  to  create  such  a  file  is  to  right-click  on  your  project  and  select  New,
Mathematica Test File (you should make sure you are in Mathematica Development
Perspective, or you will have to navigate into the Other submenu to get to this feature). 
The most convenient way to create your first test case is to type Test and then hit
Ctrl-Space to trigger code assist, which automatically creates the test boilerplate. 
762 | Chapter 19: Debugging and Testing

(*Mathematica test file for Ackermann*)
Test[
A[0,0]
,
1
,
TestID->"Test2-20090508-O1L1K5"
]
Test[
A[1,0]
,
2
,
TestID->"Test2-20090508-N4W7U7"
]
Test[
A[0,1]
,
2
,
TestID->"Test2-20090508-F5F9A7"
]
(*This test will fail!*)
Test[
A[1,2]
,
3
,
TestID->"Test2-20090508-L7N0S2"
]
Discussion
You can execute your unit tests at any time by saving the test file, right-clicking on it
in the package explorer, and selecting Run As, Mathematica Test. This will generate
a Test Report, as shown in Figure 19-7. The report shows which tests passed and
which failed. Unique TestIDs are essential to this function, and Workbench has a fea-
ture  that  will  help  fix  and  duplicate  IDs.  Simply  right-click  on  the  file,  select  the
Source menu, and then select Fix Test IDs. 
19.8 Writing Unit Tests to Help Ensure Correctness of Your Code | 763

Figure 19-7. Test report generated after running the tests defined in the solution
Functions like Ackermann that return scalar values are easy to inspect in the failed
tests section to investigate the difference between the expected and actual output. In
Figure 19-7, you can see that the expected output is 6, but the actual output is 4. In
this case, it is the test function that is wrong, because the correct output is 4. The
more typical circumstance is that the function is wrong, but in either case you can
quickly see that something is awry. With more complex outputs, it can be difficult
to  find  the  difference.  A  useful  feature  of  Workbench  is  Failure  Compare.  Simply
right-click on the failure test ID and select Failure Compare. This will open a dialog
with a side-by-side tree view of the expected and actual expression (see Figure 19-8).
You can expand the tree to inspect the branches that indicate differences (the X). 
764 | Chapter 19: Debugging and Testing

Figure 19-8. Use the test failure comparator to drill down into test results to detect problems
See Also
See the Wolfram Workbench unit-testing screencast at http://bit.ly/dOJBL for a step-
by-step overview of unit testing.
19.9 Creating MUnit Tests Where Success Is Not 
Based on Equality Testing
Problem
Although the MUnit Test function is easy to use, it is not the most appropriate func-
tion for certain types of testing. For example, you may want to define your test in
terms of pattern matching.
Solution
MUnit provides other test functions, including TestMatch, TestFree, TestStringMatch,
and TestStringFree. TestMatch uses MatchQ to compare actual and expected results,
and  TestFree  uses  FreeQ.  Likewise,  TestStringMatch  uses  StringMatchQ,  and  Test-
StringFree uses StringFreeQ.
19.9 Creating MUnit Tests Where Success Is Not Based on Equality Testing | 765

TestMatch[
{1,2,3,4,5}
,
{__Integer}
,
TestID->"TestOther-20090509-L8U9H1"
]
TestFree[
{10,12,1/2,2/3,3/4,4/5,5/6}
,
{__Complex}
,
TestID->"TestOther-20090509-L8U9H2"
]
TestStringMatch[
"Hello"
,
"H" ~~ __ ~~ "o"
,
TestID->"TestOther-20090509-L8U9H3"
]
TestStringFree[
"Hello"
,
"x"
,
TestID->"TestOther-20090509-L8U9H4"
]
Discussion
You can create even more flexible tests by using the EquivalenceFunction option of
Test to specify an alternative definition of success. The following test succeeds if the
actual value is greater than 0.
Test[Cos[1]^2 + Sin[1]^2 - Sqrt[1 - Exp[-10]],
 0,
 EquivalenceFunction -> Greater,
 TestID -> "ID17"]
766 | Chapter 19: Debugging and Testing

This option comes in handy when you are creating tests where exact equality is not
useful. For example, you might want to use Round or Chop before comparing.
Test[
InverseFourier[Fourier[{2, 1, 1, 0, 0, 0}]],
 {2, 1, 1, 0, 0, 0},
 EquivalenceFunction -> (Chop[#1] == Chop[#2] &),
 TestID -> "ID42"
 ]
Of course, you can just as readily write the test with Chop applied to the actual com-
putation, but I feel that EquivalenceFunction better documents the test designer’s
intention. Another example is when you are only worried about equality up to a speci-
fied tolerance. 
Test[
(12/7) (2 Sqrt[2] - 1),
 Pi,
 EquivalenceFunction -> Abs[#1-#2] < 0.01,
 TestID -> "ID66"
19.10 Organizing and Controlling MUnit Tests 
and Test Suites
Problem
You have a complex test suite with many tests. The tests may naturally group into
sections. Further, you want the ability to turn on and off test sections as well as state
dependencies  between  sections,  possibly  to  account  for  side  effects.  For  example,
you want to say, “only continue with this section if tests succeed, because further
tests rely on results computed by earlier tests.”
Solution
There  are  a  few  advanced  MUnit  features  that  are  useful  for  organizing  tests  and
managing test dependencies. You can organize tests into sections using BeginTest-
Section[name,switch] and EndTestSection[].
19.10 Organizing and Controlling MUnit Tests and Test Suites | 767

(*Switches to activate and deactivate sections*)
Sect1Active = True;
Sect2Active = True;
(*Section 1*)
BeginTestSection["sect1", Sect1Active]
(*All tests in this section depend on first test success.*)
TestFree[str=OpenRead["SomeTestFile.txt"], $Failed, 
EquivalenceFunction ->UnsameQ,
TestID-> "TestAdvanced-20090509-O6O6O3", TestFailureAction -> "SkipSection"]
Test[Read[str, Number], 5, TestID -> "IDS1_1"]
Test[Read[str, Word], "cars", TestID -> "IDS1_2"]
EndTestSection[]
(*Section 2*)
BeginTestSection["sect2", Sect2Active]
Test[2 + 2, 4, TestID -> "IDS2_1"]
EndTestSection[]
Discussion
If it does not make sense to continue tests after a failure, you can also specify Test-
FailureAction Ø "Abort". This feature is available even if you do not use sections.
If you have a complex Mathematica library, you will want to organize it into sepa-
rate test files. However, running each test separately would be tedious, so MUnit pro-
vides a TestSuite construct. First, you should place all your test files (.mt files) into a
folder under the main project folder. Then create a test file that ties all the tests to-
gether into a suite, as shown in Figure 19-9.
768 | Chapter 19: Debugging and Testing

(*Mathematica TestSuite*)
TestSuite[
{
"Test.mt",
"Test2.mt",
"TestAdvanced.mt",
"TestOther.mt"
}
]
Figure 19-9. TestSuite is a test file that allows you to run other test files all at once
19.11 Integrating Wolfram Workbench’s MUnit 
Package into the Frontend 
Problem
You would like to create unit tests but you prefer to work in the traditional frontend
rather than Workbench. 
Solution
You  need  a  test  driver  to  run  the  tests.  This  mimics  the  basic  functionality  of
Workbench.
In[88]:=
Needs@"MUnit`"D;
TestDriver@tests__D :=
ModuleA8testList = 8tests<, numTests, failedTests<,
numTests = Length@testListD;
failedTests = Select@8tests<, H FailureMode@ÒD =!= "Success"L &D;
PrintA"Passed Tests: ", numTests - Length@failedTestsDE;
PrintA"Failed Tests: ", Length@failedTestsDE;
Print@"Failed Test Id: ", TestID@ÒD, "\nExpected: ",
ExpectedOutput@ÒD, " Actual: ", ActualOutput@ÒDD & êü failedTests;
E
19.11 Integrating Wolfram Workbench’s MUnit Package into the Frontend | 769

The MUnit package is not part of Mathematica 7, but you can still use it
if you have installed Wolfram Workbench 1.1 or higher. You need to
tell the kernel where to find the package. This will vary from system to
system, but generally it will be under the Wolfram Research directory
where  Mathematica  is  installed.  You  want  to  find  a  directory  called
MUnit and add the path to that directory to $Path. On my Windows XP
installation, I added the location to $Path by executing:
In[90]:=
AppendToA$Path, FileNameJoinA9"C:", "Program Files",
"Wolfram Research", "WolframWorkbench", "1.1", "plug-ins",
"com.wolfram.eclipse.testing_1.1.0", "MathematicaSource"=EE
Out[90]=
9C:\Program Files\Wolfram
Research\Mathematica\7.0\SystemFiles\Links,
C:\Users\Sal Mangano\AppData\Roaming\Mathematica\Kernel,
C:\Users\Sal Mangano\AppData\Roaming\Mathematica\Autoload,
C:\Users\Sal Mangano\AppData\Roaming\Mathematica\Applications,
C:\ProgramData\Mathematica\Kernel,
C:\ProgramData\Mathematica\Autoload,
C:\ProgramData\Mathematica\Applications, .,
C:\Users\Sal Mangano, C:\Program Files\Wolfram
Research\Mathematica\7.0\AddOns\Packages,
C:\Program Files\Wolfram
Research\Mathematica\7.0\AddOns\LegacyPackages,
C:\Program Files\Wolfram
Research\Mathematica\7.0\SystemFiles\Autoload, C:\Program
Files\Wolfram Research\Mathematica\7.0\AddOns\Autoload,
C:\Program Files\Wolfram
Research\Mathematica\7.0\AddOns\Applications, C:\Program
Files\Wolfram Research\Mathematica\7.0\AddOns\ExtraPackages,
C:\Program Files\Wolfram
Research\Mathematica\7.0\SystemFiles\Kernel\Packages,
C:\Program Files\Wolfram
Research\Mathematica\7.0\Documentation\English\System,
C:\Program Files\Wolfram
Research\WolframWorkbench\1.1\plug-ins\com.wolfram.eclipse.
testing_1.1.0\MathematicaSource=
You  can  add  this  to  init.m  if  you  intend  to  use  MUnit  frequently.
Alternatively,  you  can  also  copy  the  MUnit  package  into  one  of  the
locations in $Path. 
770 | Chapter 19: Debugging and Testing

Here is a simple example of using the driver. I purposefully made tests with ID2 and
ID4 fail.
In[91]:=
TestDriver@
Test@1 + 1, 2, TestID Ø "ID1"D,
Test@1 + 1, 3, TestID Ø "ID2"D,
Test@2 + 2, 4, TestID Ø "ID3"D,
Test@2 + 2, 3, TestID Ø "ID4"DD
Passed Tests: 2
Failed Tests: 2
Failed Test Id: ID2
Expected: 3 Actual: 2
Failed Test Id: ID4
Expected: 3 Actual: 4
Discussion
The test driver used in the preceding “Solution” section is very basic and does not
support all the features available when you build unit tests in Workbench. If you are
ambitious, you can build a more sophisticated driver~even one that has more fea-
tures than Workbench. It really depends on your needs. The main requirement is to
become familiar with the MUnit API. Although documentation on MUnit is sparse at
the  time  I  am  writing  this,  well-written  Mathematica  packages  are  self-describing.
For  example,  you  can  find  all  the  public  functions  in  the  package  by  using
?"MUnit`*".  For the sake of space, I’ll only list the functions that begin with the let-
ter T. By clicking on the output, you can see what the function or option does. The
most important functions are selectors, like TestID, because these allow you to ex-
tract information from a TestResultObject, which is the output produced by func-
tions like Test, TestMatch, and so on. 
19.11 Integrating Wolfram Workbench’s MUnit Package into the Frontend | 771

In[92]:=
?"MUnit`T*"
MUnit`
Test
TestIndex
TestRunResultObject
TestCaveat
TestInput
TestRunTitle
TestCellEvaluationFunction
TestLog
TestStringFree
TestExecute
TestMatch
TestStringMatch
TestFailureAction
TestMemoryUsed
TestTags
TestFailureMessage
TestRequirement
TestTerminate
TestFree
TestResultObject
TestTimeUsed
TestID
TestResultQ
TestIgnore
TestRun
By inspecting MUnit’s functions, I was inspired to create a test driver that supports
the idea of test sections (see Recipe 19.10). However, instead of a BeginTestSection-
EndTestSection pair, I use a single TestSection function. The TestDriver will work
with  multiple  TestSections  or  multiple  Tests  but  not  mixtures  of  both.  For  this
driver to handle skipping and aborting, it must be careful to evaluate a test lazily,
hence, it uses Hold and the HoldAll attribute judiciously. It also uses Catch and Throw
combinations. This is a feature of Mathematica I have largely avoided in the book,
but it sometimes comes in handy as a way to terminate an iteration without cumber-
some conditional logic. In this case, the function RunTest causes a test to evaluate
and tests for failure. If the test does not succeed, it defers further decisions to On-
FailedTest based on the test’s FailureMode. OnFailedTest will either Throw or return,
depending on the mode. Further, it uses the mode as a tag in the Throw, so the appro-
priate Catch handler can intercept the failure.
772 | Chapter 19: Debugging and Testing

In[93]:=
ClearAll@TestDriver, TestSection, RunTest, OnFailedTestD;
SetAttributes@8TestDriver, TestDriver2, TestSection, RunTest<, HoldAllD;
H*OnFailedTest simply returns the test if mode is Continue,
otherwise it throws using mode as a tag.*L
OnFailedTest@test_, "Continue"D := test
OnFailedTest@test_, mode_D := Throw@test, modeD
H*RunTest tests the failure mode and updates
counters. It defers failure action to OnFailedTest.*L
RunTestAtest_TestResultObjectE :=
If@FailureMode@testD =!= "Success", failedTests++;
OnFailedTest@test, TestFailureAction@testDD, passedTests++; testD
H*A TestSection has one or more tests, a name,
and Boolean for enabling or disabling the section.*L
TestSectionAtests__, section_String, FalseE := 8<
TestSectionAtests__, section_String, _ : TrueE :=
Module@8<,
Catch@ReleaseHold@RunTest@ÒD & êü Hold@testsDD, "SkipSection"DD
H*TestDriver2 valuates the results of tests.*L
TestDriver2@tests__D := Module@8testList = 8tests<, numTests, failed<,
failed = Select@8tests<, H FailureMode@ÒD =!= "Success"L &D;
Print@"Passed Tests: ", passedTestsD;
Print@"Failed Tests: ", failedTestsD;
Print@"Failed Test Id: ", TestID@ÒD, "\nExpected: ",
ExpectedOutput@ÒD, " Actual: ", ActualOutput@ÒDD & êü failed;
D
H*This instance of TestDriver executes sections.*L
TestDriver@secs__TestSectionD :=
Block@8passedTests = 0, failedTests = 0<,
TestDriver2 üü Flatten@ 8Catch@ 8secs<, "Abort"D<DD
H*This instance of TestDriver executes tests.*L
TestDriver@tests__D := Block@8passedTests = 0, failedTests = 0<,
TestDriver2 üü Flatten@ 8Catch@RunTest êü 8tests<, "Abort"D<DD
19.11 Integrating Wolfram Workbench’s MUnit Package into the Frontend | 773

Here I put the driver through its paces demonstrating different failure scenarios.
In this scenario, the second test in sect1 fails with an Abort; hence, tests with test
IDs "Sect1ID3" and "Sect2ID1" are not run.
In[103]:=
TestDriver@
TestSection@
Test@1 + 1, 3, TestID Ø "Sect1ID1"D,
Test@1 + 1, 3, TestID Ø "Sect1ID2", TestFailureAction Ø "Abort"D,
Test@1 + 3, 4, TestID Ø "Sect1ID3"D, "sect1"D,
TestSection@
Test@1 + 1, 2, TestID Ø "Sect2ID1"D, "sect2"D
D
Passed Tests: 0
Failed Tests: 2
Failed Test Id: Sect1ID2
Expected: 3 Actual: 2
In this scenario, the second test in sect1 fails with a "SkipSection"; hence, the test
with test ID "Sect1ID3" is skipped, but a "Sect2ID1" runs.
In[104]:=
TestDriver@
TestSection@
Test@1 + 1, 3, TestID Ø "Sect1ID1"D,
Test@1 + 1, 3, TestID Ø "Sect1ID2", TestFailureAction Ø "SkipSection"D,
Test@1 + 3, 4, TestID Ø "Sect1ID3"D, "sect1"D,
TestSection@
Test@1 + 1, 2, TestID Ø "Sect2ID1"D, "sect2"D
D
Passed Tests: 1
Failed Tests: 2
Failed Test Id: Sect1ID2
Expected: 3 Actual: 2
774 | Chapter 19: Debugging and Testing

Here sections are not used, but a TestFailureAction of "Abort" is still handled appro-
priately. 
In[105]:=
TestDriver@Test@1 + 3, 2, TestID Ø "Sect1ID1", TestFailureAction Ø "Abort"D,
Test@1 + 1, 2, TestID Ø "Sect1ID1"DD
Passed Tests: 0
Failed Tests: 1
Failed Test Id: Sect1ID1
Expected: 2 Actual: 4
See Also
The concept of test sections is native to MUnit when used with Workbench, but has a
different syntax. This is covered in Recipe 19.10.
19.11 Integrating Wolfram Workbench’s MUnit Package into the Frontend | 775


  777
Symbols
` (backtick), 7
! (escape character), 690–691
@ (prefix notation), 6, 49–50, 65
=== (SameQ), 91
## (slot sequence), 34
# (slots), 35
| (vertical bar), 147–148
// (postfix notation), 6, 20–21, 49
/@ operator, 27
@@ operator, 27
@@@ operator, 27, 34
$CharacterEncoding, 182
$CharacterEncodings, 182
$MachinePrecision, 7
$MaxPrecision, 8–9
$MinPrecision, 8–9
$SystemCharacterEncoding, 182
A
AbsoluteThickness, 268
AccountingForm, 20–21
Accuracy, 8
accuracy of numeric results, 4–9, 10
Ackermann function
as debugging illustration, 742
debugging recursive functions, 748
extracting debugging information, 749–753
and recursion limits, 723
adaptive grid method, 575–577
Advanced Engineering Mathematics 
(Kreyszig), 439–440, 536
algebra problems, 413–414
decomposing polynomials, 420–422
dividing polynomials by other 
polynomials, 422–424
finding polynomials from given roots, 
415–416
generating polynomials, 419–420
solving equations, 414–415
transforming expressions, 416–419
algorithms (see also tree algorithms)
rule-driven, 161–165
running in parallel, 661–662
All, 481
alpha, 485–486
alternate tunings, 397–402
Alternatives, 147–148
American option pricing, 583–585
americanPutCompiled, 583–584
amplitude modulation, 392
anagram demonstration, 204–206
analysis of variance (ANOVA), 479–483
Animate
creating self-running demonstrations, 
627–629
as key function for interactivity, 594
relationship with Manipulate, 629
AnimationRate, 628
AnimationRepetitions, 628
AnimationRunning, 628
animations, 627–630
Animator, 629
annotation
of 2D graphics, 269–270
of 3D plots with 2D contours, 295–296
Index
We’d like to hear your suggestions for improving our indexes. Send email to index@oreilly.com.

778  |  Index
arrows, 270–273
graph labels, 241–242
interactive, 630–631
legends, 260–263
annuity, 560
anonymous functions, 32
ANOVA (analysis of variance), 479–483
ANOVA` package, 479–480
Antidiagonal, 103
Apart, 417
Append, 87
AppendTo, 111–112
Apply
level specifications, 117
mapping multi-argument functions, 33–35
operator notation, 26–27
XML data, 212
apply (term usage), 26
approximate numeric results, 2–3, 5–7
approximate numeric values
converting to exact, 19
with mixed numerical types, 9–10
arguments, holding, 36
Array
constructing lists, 86–87
generating kernels, 48
ArrayPlot, 411–412
arrays
packed and unpacked, 95–97
sparse, 112–114
Arrow, 263–266
Arrowheads, 270–272
arrows
in 2D graphics, 263–266
customizing, 270–273
ASCII codes, use of, 181–182
AspectRatio
overriding, 255
with Plot, 244–245
with PolarPlot, 249
associative functions, 30
associative lookup
built-in, 130–134
red-black tree implementation, 125–129
attributes, 29–30
Attributes, 29
audio and music processing, 373
alternate tunings, 397–402
applying an envelope to a signal, 394–397
chord notation, 380
chords and progressions, 378, 379, 383–384
exporting MIDI files, 389–390
Fourier analysis, 405–412
importing digital sound files, 403–412
musical notes, 374–375
percussion, 384–389
playing functions as sound, 390–391
rhythm, 376–377, 382
scales and melodies, 375–376
tremolo, 392, 394
vibrato, 393–394
volume, 377–378, 382
Axes
overriding, 255–256
suppressing plot axes, 240
AxesEdge, 278–279
AxesLabel, 240
axialForce, 545–547
axialStrain, 545–547
axialStress, 545–547
B
backtracking parsers, 235
Backus-Naur Form (BNF), 227, 232
balance, 128
Band
synthesizing sparse functions, 113–114
synthesizing tridiagonal matrices, 104, 
531–532
BarChar, 460
BaseForm, 12–13
bases other than 10, 12–13
BeginTestSection, 767–768
binary trees
converting lists to, 89
modeling, 121–123
selective flattening, 90
BinarySearch, 100
BinCounts
distributions of pseudorandom  
numbers, 460
grayscale histograms, 341
bit vectors, 119–121
Black-Scholes formula
finite difference method for, 578–582
pricing European puts and calls, 565–572
speeding up NDSolve, 574–578

Index  |  779
Blank pattern constructs, 146–147, 148
Block, 66, 69–70
BNF (Backus-Naur Form), 227, 232
bonds, 551, 561–562
bookmarks, 618–619
Boslaugh, Sarah (see Statistics in a Nutshell)
BoundaryStyle, 280
box plots, 493–494
Boxed, 280–281
BoxQuantile, 493–494
BoxRatios, 280–281
BoxStyle, 280–281
BoxWhiskersPlot, 492–493
breakpoints, 761
buttons, 596
C
C and C++ functions, calling, 694–699
CAD, importing from, 326
calculus problems
difference equations, 450–452, 519–521
differential equations, 438–441, 537
differentiating functions, 431–435
generating functions for sequence 
recognition, 452–454
integration, 435–438
limits, 426–427
minima and maxima problems, 441–443
piecewise functions, 427–429
power series representations, 429–431
sum and product problems, 447–450
vector calculus problems, 443–447
call options, 551, 566–567
Carlson, Chris, 306
Cartesian coordinates
2D plots in, 239–247
3D plots in, 276–282
Cases
compared to DeleteCases, 153–154
with Count, 156
in coupled mass problems, 532
extracting lines from 3D objects, 308
extracting XML elements, 211
filtering out MissingData entries, 512
generating polynomials, 450
level specifications, 117
pattern matching, 151–152, 211
querying databases, 172–173
taking lists apart, 88–89
transforming notebooks, 735
transforming XML, 213–214
cash flow value, 559–561
Catch, 772–773
categorical data, 483–486
CDF (cumulative density function), 461–464
Ceiling, 18–19
CellMeans, 483
center of mass, computing, 522–524
centerMass, 522–523
central limit theorem (CLT), 464–466
CentralMoment, 471
Cervantes-Pimentel, Ulises, 306
character encodings, 181–183
character manipulation, 188–192, 192–196
CharacteristicFunction, 464
ChemicalData source, 510–512
chi-square tests, 483–486
ChiSquarePValue, 485
choose, 227–228
Chop, 525
chords
controlling voicings, 383–384
creating, 378
notation, 380
playing progressions, 379
Circle, 263–266
cleaning up
automatically, 737–738
during incremental development, 720–721
Clear, 720–721
ClearAttributes, 29
Clip, 428
clone method, 68
closures
in functional languages, 32
implementing, 66–73
transitive, 162–163
CLT (central limit theorem), 464–466
clustering solutions, third-party, 642
clusters
grouping data into, 486–492
and random number generation, 496–499
CMYK color space, 338
"CoarsestGrained", 659–660
Coefficient, 421
CoefficientList, 421
Collect, 418

780  |  Index
colon syntax, 151
color directives, 266–267
color models, 335–340
ColorFunction
highlighting distribution plots, 464
imported image format, 330, 339
Column, 633–635
Combinatorica` package
constructing graphs to use with, 134–140
extracting information from graphs, 
140–143
sorting lists, 98–100
command history, clearing, 721
command line programs, external, 690–691
comments, stripping, 190
CommonCompoundNames, 508
Commonest, 459
commutative functions, 29
Compile
improving function performance, 727–728
pricing American securities options, 583
compiling (computational finance), 550
Complement, 91, 278
complex numbers
converting to other bases, 12–13
as expression heads, 1–2
Composition, 63–66
computational finance, overview of, 549–551
Condition, 178
conditions, pattern, 149
ConsonantDistance, 208
ConstantArray, 86–87
constants, modifying, 721–723
continuations, 32
“Continued Fraction” (Weisstein), 63
continuously compounding interest, 560
ContourPlot3D, 292–294
contrast, image, 341–346
Control, 633–635
ControlActive, 602–603
controls
creating custom, 625–627
and dynamic updates, 605
and graphics manipulation speed, 602–603
intercepting output of, 607–609
managing large numbers of, 633–639
Manipulate’s choice of, 595–596
multiple, for single variables, 597
types of, 595–596
convergence
graphing iterations, 257
of sums or products, 448
Core stylesheet, 731–732
Correlation, 467–468
correlation, computing, 466–468
CosineDistance, 488
Count, 155–156
coupled mass problems, 530–532
Covariance, 467–468
covariance, computing, 466
critical sections, 664, 665, 682
critical values, 485–486
CriticalSection
diagnosing parallel processing 
performance, 685–686
sharing resources in parallel evaluation, 
664–665
Cross, 443
CrossProduct
solving vector calculus problems, 445–446
and VectorAnalysis` package, 92
crossRef, 735
crossword puzzles, cheating on, 204
cumulative density function (CDF), 461–464
curl, of vector fields, 92, 446
Curry, 74–77
currying, 32, 73–77
cylindrical coordinates, 285–289
D
D, 432, 433
DAGs (directed acyclic graphs), 142–143
DamerauLevenshteinDistance, 491
Dandelin demonstration, 304–305
data
adjusting for outliers, 471–472
categorical, 483–486
generating multiple data sets in  
parallel, 658
grouping into clusters, 486–492
linear models, 472–474
measuring shape of, 468–471
nonlinear models, 475–477
partitioning into parallel data sets, 
656–658
plotting in 2D, 252–254
plotting in 3D, 298–300
sharing between parallel kernels, 662–663

Index  |  781
data sources, curated
ChemicalData, 510–512
dictionaries, 202
ElementData, 507–510
FinancialData, 550, 552–557
GenomeData, 516, 518–519
ParticleData, 513–516
PolyhedronData, 320–326
ProteinData, 516–518
value of, 506
Data specification, 403
databases (see also data sources, curated)
querying with patterns, 171–177, 555
storing results in, 714
third-party, 690, 711–713, 715–717
"Data" element, extracting, 334–335
DataRange, 253
DataSourceNames, 715
Date, C.J., 171–172
debugger, built-in, 742
debuggers, creating interactive, 753–756
debugging, 741–742
extracting useful information, 749–753
function libraries, 762–765
functions invoked many times, 746–747
incremental development problems, 
720–721
infinite loops, 165–167
with Print, 743–745
recursive functions, 747–749
visual, 758–762
XML transformations, 219
DecayModes, 516
DeclarePackage, 726
Default, 77–79
Default stylesheet, 731–732
default values
compared to options, 81
creating functions with, 77–79
definitions, custom, 28–29, 79–83
Delete
level specifications, 117–118
pattern matching, 154–155
DeleteCases
excluding matching elements, 153–155
extracting digits of a number, 15
level specifications, 117
delimiters, changing, 190–191
delta (computational finance)
computing, 567, 569
defined, 551, 567
plotting, 569–570
Depth, 750
Derivative, 433
derivatives, computing, 431–435
derivatives, notation for, 431–432, 433
Developer` context, 723–724
Developer` package, 48, 96–97
Diagonal, 102–103
DiagonalMatrix
compared to Table, 86
constructing shift matrices, 106–107
specifying matrix structure, 104
synthesizing sparse equivalent of, 113–114
diagram, 543, 545
dictClear, 132
dictHasKeyQ, 132
dictionaries
associative lookup, 131–133
key-value, 130–134
natural language, 202–209
Dictionary, 131, 133
dictKeys, 132
dictKeyValuePairs, 132–133
dictLookup, 132
dictRemove, 132
dictReplace, 132
dictStore, 131–132
difference equations
modeling predator-prey dynamics, 519–521
solving, 450–452
differential equations
modeling electrical circuits, 537
solving, 438–441
Digital Image Processing (Gonzalez and 
Woods), 331, 351, 359
DigitBlock, 21
digits, extracting, 13–16
directed acyclic graphs (DAGs), 142–143
directives (see graphics directives)
discount factors, 559–561
Disk, 263–266
Dispatch, 170–171
displacements, 542–543
Display, 680
display forms
bit vectors, 119–121
numerical expressions, 4, 20–22

782  |  Index
DisplayAllSteps, 628
distance functions, 488, 490–492
DistributeDefinitions
with map-reduce, 673
with Parallelize, 651
distribution of processing (see parallel 
processing)
distributions, statistical
central limit theorem, 464–466
cumulative and probability density 
functions, 461–464
measuring shape of data, 468–471
nonuniform, 459–461
divergence (vector calculus), 446
Do
non-functionality of, 31
with ParallelEvaluate, 650
Dot
compared to DotProduct, 445–446
generating polynomials, 420
with graphics matrices, 109
solving vector calculus problems, 443, 444
vector multiplication, 94–95
DotProduct, 445–446
downvalues
inspecting with DownValues, 27–28
synchronizing, 662
DownValues
associative lookup, 132
inspecting downvalues with, 27–28
Drakos, Nikos, 347, 351
Drop
for composed invertible functions, 65
taking lists apart, 88
drop-down lists, 596
DSolve
compared to RSolve, 452
limitations, 534
modeling vibrating strings, 533, 534
solving differential equations, 439–441
with triangular waves, 538
duration of bonds, 561–562
Dynamic
behavior of, 605–606
creating closures, 70–71
in dynamic updates, 604–606
effect of Refresh on, 610
intercepting control output, 607–609
refresh rate, 610
segregating fast and slow operations, 620
speeding up interactive plots, 603–604
dynamic interactivity, overview of, 593–594
dynamic module variables, 624–625
dynamic updates
with changing cell values, 604–606
intercepting control values, 607–609
dynamic values, 609–610
DynamicModule
balancing speed and space, 613–615
creating wormholes, 624–625
with Manipulate, 617, 622
notebook representation of, 612
scope of variables, 624
as a scoping construct, 611–612
DynamicWrapper
balancing speed and space, 613–615
segregating fast and slow operations, 
620–621
E
Eclipse, 761
edgeDetectLOG, 362–364
edgeDetectSobel, 362–363
edges, detecting, 361–364
EditDistance
creating spell-checkers, 207–208
grouping data into clusters, 491
Eigenfaces for Recognition (Turk and 
Pentland), 367, 371
eigenImageElements, 368
eigenImageRecognition, 370
eigenImages, 368
eigenvectors (eigenimages), 365–371
electrical circuits, modeling, 537–539
ElementData, 507–510
engineering applications, overview of, 
505–506
EngineeringForm, 22
envelopes, applying to signals, 394–397
EquivalenceFunction, 766–767
errors, estimating, 16–18
EuclidianDistance, 488, 491
EulerianQ, 141–142
European option pricing, 551, 565–576, 
578–582
Evaluate, 62
evaluation after transformation, 168–169

Index  |  783
evaluation monitors, debugging with, 
756–758
EvaluationMonitor, 757–758
event propagation, controlling, 631–632
EventHandler, 630, 631–632
exact numeric values
in expressions with mixed numerical 
types, 9–10, 11
results as, 2–3, 5–7
ExampleData, 306
Except
finding nonmatching values, 149, 151
limitations of, 154
executable programs, calling, 690–691
Expand
generating polynomials, 450
transforming polynomials, 417–418
ExpandAll, 417–418
Experimental` context, 723–725
explicit methods, stability problems in, 585
expression evaluation, replacement and, 192
Extract
level specifications, 117–118
pattern matching, 152–153
F
FaceGrids, 281–282
FaceGridsStyle, 281–282
Factor, 417
FactorTerms, 417, 418–419
FDM (finite difference method), 578–582
FEM (finite element method), 539–547
fileDisposition, 677–678
Filling
with ColorFunction, 464
with Plot, 245–247
with PolarPlot, 249
FillingStyle, 246–247
FilterOptions, 82
FilterRules, 81–82
financial data, importing from websites, 
557–559
financial derivatives, 573
financial engineering, overview of, 549–551
FinancialData source, 550, 552–557
FindClusters, 486–492
FindFit, 475
FindGeneratingFunction, 453
FindMaximum, 442–443
FindRoot
computing critical values, 485
computing securities option volatility, 573
debugging built-in functions, 756
evaluation monitoring, 57–58
solving algebraic equations, 415
FindSequenceFunction, 453
"FinestGrained", 659–660
finite difference method (FDM), 578–582
finite element method (FEM), 539–547
First, 88
first-class entities, 24
Fit, 473
fitness functions, in Java libraries, 703–706
FixedPointList, 164–165
Flat, 30, 152
Flatten
collapsing unneeded nesting, 43
restructuring lists, 89–90
with SoundNote, 388–389
FlipView, 635
Floor, 18–19
flux, 444
Fold, 26
as code generator, 63
as recursion alternative, 53–56
foldl (Haskell), 54–55
FoldList, 26, 56
foldr (Haskell), 54–55
ForAll, 441
Format, 542
forms, for numerical expressions, 4, 20–22
Fourier analysis, on sound files, 405–412
Fourier series
modeling electrical circuits, 538
modeling vibrating strings, 534
Fourier transforms, in image processing, 
356–361
fourierFilter, 357
fourierImage, 360–361
fractals, generating, 59–60
Frame, 242
FrameLabel, 242
FrameStyle, 242
FRatio, 480
frequency modulation (vibrato), 393–394
FromCharacterCode, 183
FromDigits, 15

784  |  Index
frontend
calling into, 736–737
connecting to remote kernel, 692–694
customizing user interaction, 739–740
integrating MUnit` into, 769–775
startup operations, 737–738
FrontEndExecute, 736
FullDecayModes, 516
FullForm
debugging infinite loops, 167
pattern matching, 152, 169–170
FullGraphics, 238
FullSimplify
measuring securities option sensitivity, 
571–572
solving differential equations, 439
transforming symbolic expressions, 417
function attributes, 29–30
functional notation
for derivatives, 431–432, 433
for numerical expressions, 6
functional programming languages, 31–32
functional programming style, 24–25
compared to pattern-based  
programming, 145
debugging with Print, 743–744
and parallel evaluations, 654–655
functions (see also graphics primitives; 
primitive functions)
associative, 30
commutative, 29
compiling, 727–728
custom definitions, 28–29, 79–83
debugging, 746–749, 756–758
differentiating, 431–435
distance, 488, 490–492
finding series expansions, 429–431
for image processing, 331
indexed, 51–52
for interactivity, 593–594
interpolation, 477–478
localizing within a Manipulate, 622–624
locating undocumented, 723–725
modifying built-in, 721–723
packaging into libraries, 725–727
piecewise, 427–429, 431–435
playing as sound, 390–391
recursive, 218–227, 747–749
redefining with upvalues, 28–29
region, 297–298
repeated application of, 59–62
for sequence recognition, 452–454
vector, 91–92
functions, building
accepting options, 79–83
default values, 77–79
downvalues and upvalues, 27–29
for explicit currying, 73–77
holding arguments, 36
invertible, 63–66
sequence recognition, 452–454
through iteration, 62–63
functions, mapping over lists
automatically, 37
moving sublists, 43–48
multiple arguments, 32–35
multiple functions, 38–41
tracking item indexes, 41–43
functions, plotting
in Cartesian coordinates, 239–247, 
276–282
in polar coordinates, 247–249
in spherical coordinates, 283–285
G
gamma (computational finance), 551, 
567–568
GAs (genetic algorithms), 701, 706
Gather, 492
GatherBy
with map-reduce technique, 676–677
transforming notebooks, 735
GCD (greatest common divisor), 424
GenerateConditions, 437
GeneratingFunction, 453–454
generic programming, 99–100
genetic algorithms (GAs), 701, 706
GenomeData source, 516–519
geometric shapes, displaying, 263–268, 
302–306
Global` context, 721
global matrices, 541
global variables, changing temporarily, 723
Glow, 313–314, 316
Gonzalez, Rafael, 331, 351, 359
gradient (vector calculus), 446
grammars, creating, 227–235

Index  |  785
graph algorithms, 140–143
GraphData
constructing graphs, 138–139
querying databases, 175–177
GraphDifference, 136–137
Graphics, 330–331
graphics directives, 237
color, 266–267
combining with graphics primitives, 266
lighting, 315–316
"Graphics" element, extracting, 333–334
graphics primitives
combining with graphics directives, 266
imported image representation, 330, 339
three-dimensional, 303–305, 408–409
two-dimensional, 237, 263
visualizing tree-based pricing  
approaches, 588
graphics, symbolic nature of, 276
graphics, three-dimensional (see also plots, 
three-dimensional)
compared to 2D graphics, 275
formats supported, 326
geometric shapes, 302–306
importing, 326–327
lighting properties, 313–316
polyhedra, 320–326
surface properties, 313–316
transforming, 317–320
viewing perspective, 309–312
wireframe models, 306–309
graphics, two-dimensional (see also plots, 
two-dimensional)
annotating, 241–242, 269–270
arrows, 270–273
combining multiple graphics, 256–257
format of imported images, 330–331
geometric shapes, 263–268
tree-based pricing approaches, 587–591
Graphics3D, 408–409
GraphicsArray, 258–259
GraphicsColumn, 238, 259–260
GraphicsGrid
displaying related graphs, 258–259
formatting 2D graphics outputs, 238
GraphicsRow, 238, 259–260
GraphIntersection, 136–137
GraphJoin, 136
GraphPlot, 161
GraphProduct, 136–138
graphs
constructing for Combinatorica` 
algorithms, 134–140
extracting information, 140–143
interactive, 600–604
transitive closure of, 162–163
GraphUnion, 136
GraphUtilities` package, 140, 161
Gray, Theodore, 610, 614, 615
"GrayLevels" element, 333–334
greatest common divisor (GCD), 424
greedy matching, 159–161
Greeks, 551, 567–572
grep demonstration, 199–200
Grid, 633–635
grid lines, on graphs, 241–245
Grid Mathematica, 641
grpath, 588
H
Halton sequence, 498
HamiltonianQ, 141–142
HammingDistance, 491–492
Haskell
currying functions, 76, 77
folding implementations, 54–55
as functional language, 31–32
hasPath, 162–165
Head, 1–2
heads
graphics, 275
indexed, 51
numerals, 1–2
red-black trees, 125–126
XML, 210, 212–213
HeapSort, 99–100
histogram equalization, 341–346
histogram specification, 347–351
histogramSpecification, 348–350, 352–354
history, clearing, 721
Hold, 30
completing replacement before 
evaluation, 168–169
currying, 75
holding unique argument combinations, 36
nonstrictness of, 32
pattern matching, 152

786  |  Index
HoldAll, 30
creating grammars, 227–228
implementing closures, 66, 70
nonstrictness of, 32
HoldFirst, 30
destructive changes to symbol values, 
111–112
effect on Dynamic, 605–606
nonstrictness of, 32
HoldForm
displaying polynomials in specific order, 
420, 422
with Trace, 750–751
HoldPattern
associative lookup, 132
completing replacement before 
evaluation, 168–169
HoldRest, 30, 32
HSV color model, 335–340
hue, 335–337
Hull-White method, 587–590
hyperspheres, volume of, 437–438
hypothesis testing, 483–486
I
identity matrices, 104
IdentityMatrix
constructing lists, 86–87
specifying matrix structure, 104
synthesizing sparse equivalent of, 113–114
IgnoreCase, 200
IKernelLink, 709–711
Image, 330–331
image processing
challenges of, 329
converting RGB to HSV, 335–340
correcting images, 347–351
detecting edges, 361–364
enhancing images, 341–346
extracting elements, 332–335
functions, 331
image recognition, 365–371
sharpening images, 351–361
smoothing images, 356–361
image representation, 330–331, 336
ImageConvolve, 364
ImageHistogram, 346
images, imported, 330–331
imageVector, 368
ImplementJavaInterface, 704
Import
extracting image information, 332–335
image processing format, 330–331
importing digital sound files, 403
importing financial data, 557–558
importing XML, 209–210
incUntilButton, 625
indexed functions, 51–52
infinite loops, debugging, 165–167
infix notation, 6
Initialization, 617–618, 622–623
initializing automatically, 737–738
Inner, 94–95, 420
InputForm, 237
Insert, 87
Inset, 272–273
Install (MathLink), 697
InstallJava, 700–701
InstallNET, 707
IntegerDigits, 13–15
integers, as expression heads, 1–2
IntegerString, 16
Integrate, 435–437
integration, 435–438
interactivePlot, 630–631
interactivity, 593–594
animating expressions, 627–630
balancing speed and space, 613–615
controlling dynamic value updates, 
609–610
creating custom controls, 625–627
creating custom interfaces, 630–633
dynamic updates, 604–606
improving Manipulate performance, 
619–622
intercepting control values, 607–609
localizing functions in Manipulate, 
622–624
making a self-contained Manipulate, 
615–618
manipulating plots, 600–604
manipulating symbolic expressions, 
598–600
remembering found values, 618
scoping constructs in notebooks, 611–612
sharing dynamic module variables, 
624–625
variable manipulation, 594–597

Index  |  787
interest, continuously compounding, 560
interest rate sensitivity
of bonds, 561–562
of options, 567–572
visualizing tree-based approaches, 587–591
interfaces, custom
creating, 630–633
managing large number of controls in, 
633–639
interfacing with third-party tools, 689–694
internal rate of return, 560
Interpolation
computing finite differences, 579–580
creating interpolation functions from 
data, 477–478
InterpolationOrder
in 2D plots, 253–254
in 3D plots, 298–299
Intersection
eliminating duplicate list elements, 91
querying databases, 177
IntervalIntersection, 18
IntervalMemberQ, 18
intervals, estimating errors with, 16–18
IntervalUnion, 18
inverseEqualizationMap, 350
InverseFunction, 63–66
InverseSeries, 430–431
Item, 633–635
ItemNumbered, 731–732
iteration
building functions through, 62–63
computing with Nest functions, 59–62
graphing convergence, 257
J
Java, 700–706
JavaBlock, 701
JavaScript closure solutions, 69–70
JLink` package, 700–701
Join
composing new lists, 87–88
transforming XML, 216
K
kernels
as argument of ListConvolve, 45
bypassing, 736
clearing old definitions from, 720–721
Laplacian, 352
local, 643–646
master, 642, 660, 665, 667, 668
master-slave overhead, 660
and .NET applications, 709–711
in parallel computing, 642–650,  
659–663, 686–688
remote, 646–648, 692–694
shared resource issues, 663–665
sharing data across, 662–663
slave, 642–646, 660, 665, 667, 668
startup and termination operations, 
737–738
variable storage in, 612
Kernels, 649–650
keyToFilenamePrefix, 674–675
kinematics problems, 524–529
knapsack, 701–706
Koch snowflake demonstration, 59–60
Kreyszig, Erwin, 439–440, 536
Kurtosis, 469–470, 471
L
labels
arrows, 272–273
on graphs, 241–242
LabelStyle, 240
lambda functions, 32
language generators, creating, 232
Laplacian, 446
Laplacian of the Gaussian (LoG) algorithm, 
361–362
Laplacian transforms, 351–356
Last, 88
LaunchKernels, 648
Lauschke, Andreas, 574, 578, 583
lazy evaluation, 32
LCM (least common multiple), 424
LeafCount, 156
least common multiple (LCM), 424
Legend, 263
LegendPosition, 261
legends, creating, 260–263
LegendSpacing, 261–263
LegendTextSpace, 261–263
Less
creating functions that accept options, 80
ordered associative lookup, 125–126

788  |  Index
Level, 116–117
level specifications (levelspecs), 114
counting matching elements, 155
manipulating nested lists, 114–118
in mapping multi-argument functions, 
34–35
with ParallelMap, 655
pattern matching, 152, 154
libraries
creating, 725–727
debugging, 762–769
Lichtblau, Daniel, 227, 232
Lighting
controlling lighting of 3D graphics, 
313–316
visualizing translucent surface  
coverings, 309
lighting properties, 313–316
Lightweight Grid Service, 642, 646–648
limits, computing, 426–427
Line, 263–266
line integrals, computing, 443
linear regressions, 472–474
linearElement, 539–540
linearElementMatrix, 540
LinearModelFit, 473–474
linguistic processing, 202–209
LinkObject, 689, 697
links, defined, 689
Lissajous curves, plotting, 249–250
List
constructing lists, 85
extracting matrix diagonals, 102
list functions, overview of, 85–90
Listable, 30
mapping over lists automatically, 37
vector math operations, 91–92
ListAnimate, 630
ListContourPlot, 410
ListConvolve
computing finite differences, 579–580, 582
image convolution, 352
performing computations on sublists, 
44–48
ListCorrelate, 44–48
ListLinePlot
in Fourier analysis, 409
visualizing random walks, 500
ListPlot, 252–254
ListPlot3D, 298–300
lists
building incrementally, 57–59
converting to and from trees, 89, 127–128
determining order without sorting, 
100–102
eliminating duplicate elements, 91
generating, 85–88
manipulating nested, 114–118
modeling tree data structures, 121–125
numerical representation, 95–97
processing functions, 85–90
rearranging, 89–90
restructuring, 89–90
sorting, 97–100
taking apart, 88–89
LoadNETType, 707–708
local kernels, 643–646
localMatrices, 541
locationVectors, 541
lock variables, 664–665
LoG (Laplacian of the Gaussian) algorithm, 
361–362
Longest, 159–161
"Lookup", 556–557
LowerTriangularize, 105
M
machine precision, 2–3, 7
MachinePrecision, 7
Macintosh computers, and remote kernels, 
693–694
makeAdaptiveGrid, 575–577
MakeGraph, 135
ManhattanDistance, 488, 491
Manipulate, 593–594
controlling variable values interactively, 
594–597
creating custom controls, 625–627
creating custom interfaces, 633–635
creating interactive graphs, 600–604
creating tabbed and menu interfaces, 
637–639
encapsulating startup definitions, 
615–618
and graphics manipulation speed, 602
improving performance of, 619–622
localizing functions in, 622–624

Index  |  789
measuring securities option sensitivity, 
571–572
relationship with Animate, 629
remembering found values, 618–619
scope of control variables, 624
simulating kinematics problems, 526–529
varying symbolic expression structures, 
598–600
with yield curves, 564–565
Manual, 698–699
Map
compared to ParallelMap, 654–656
creating scales and melodies, 376
effect of, 27
level specifications, 117–118
mapping multi-argument functions, 33–35
mapping multiple functions in a single 
pass, 38–41
notations for, 26
playing chord progressions, 379
mapAndStore, 674
MapIndexed
level specifications, 117
parallel processing with, 652–653, 667
tracking item indexes, 41–43
transforming notebooks, 735
mapper, 676
mapping (see functions, mapping over lists; 
Map)
mapReduce, 669–678
market cap, defined, 556
mass, computing, 522–524
master kernels
overhead, 660
in parallel computing, 642
in pipeline approach, 665, 667–668
matching (see pattern matching)
Mathematica in Action (Wagon)
3D graphics primitives demonstration, 
304–305
iterative functions systems study, 52
MathKernel
connecting frontend to remote kernel, 
693–694
creating a custom frontend, 711
MathLink, 689
installing programs, 697
types returned, 699
matrices, 93
diagonal, 104
global, 541
identity, 104
permutation, 105–106
shift, 106–107
sparse arrays, 112–114
tridiagonal, 104–105, 530
matrices, building, 103–109
matrices, manipulating
extracting diagonals, 102–103
modifying rows and columns, 110–112
non-numeric permutations, 109
permuting rows and columns, 105–107
transforming, 105, 319
with vector functions, 91–92
matrix computations
covariance and correlation, 466–468
normal modes, 530, 531–532
matrix functions, overview of, 93–95
maxima problems, solving, 441–443
Maximize, 441–443
MaxIterations, 165–166
MaxRecursion, 301–302
Median, 457
melody, 375–377
MemberQ
eliminating duplicate list elements, 91
emulating SQL subqueries, 174
level specifications, 117
testing repeated transformations, 163–164
"Members", 556
memory, freeing, 112–114, 721
memory, shared, 682
MenuPosition, 731
MenuView, 635–637
merge, 676–677
mergeAll, 676–677
Mesh
constructing wireframe models, 306–307
highlighting plot points, 242–243
MeshFunctions, 300
Method, 659–661
MethodOfLines, 578
Microsoft .NET, 707–711
MIDI files, exporting, 389–390
minima problems, solving, 441–443
MinimalPolynomial, 415–416
Minimize, 441–443
Mod, 383–384

790  |  Index
mode, computing, 459
Module
compared to DynamicModule, 611–612
implementing closures, 70
moment of inertia, computing, 522–524
MonomialList, 421–422
Monte Carlo method, 585–587
Monty Hall problem, 502–503
Moore, Ross, 347, 351
Most
associative lookup, 132
taking lists apart, 88
MousePosition, 630
MovingAverage, 44
MovingMean, 44
mprep preprocessor, 694–695, 699
MUnit` framework
creating unit tests, 762–765, 765–767
directing kernel to, 770
functions, 772
integrating with frontend, 769–775
organizing and controlling tests, 767–769
music (see audio and music processing)
musical notes, creating, 374–375
N
N, 4–7
natural language dictionaries, 202–209
NDSolve
evaluation monitoring, 57–58
limitations, 534
modeling vibrating strings, 533–534
speeding up, 574–578
Nearest, 206–207
Nelson-Siegel function, 563–565
Nest, 26
building functions through iteration, 62–63
iterative computations, 59–60
as recursion alternative, 56
restructuring lists, 89
nested applications
flattening, 30
readability of, 48–51
nested lists, manipulating, 114–118
NestList, 26
convergence through iteration, 257
debugging infinite loops, 166
generating lists of grid points, 579
iterative computations, 60
modeling population dynamics, 520
as recursion alternative, 56
NestWhile
iterative computations, 60–62
as recursion alternative, 56
NestWhileList
iterative computations, 60
as recursion alternative, 56
.NET, 707–711
NetImage, 325
NETLink` package, 707
NETNew, 707–708
networks
configuring remote services kernels, 
646–648
map-reduce technique for, 673
parallel computing on, 642
nextUniqueFile, 674–675
ngon, 263–266
NIntegrate
computing critical values, 485
evaluation monitoring, 57–58
NMinimize, 57–58
nongreedy matching, 160–161
nonlinear models, 475–477
NonLinearModelFit, 475–477
nonparametric methods, 565
nonsinusoidal waves, 538–539
nonstrict languages, 32
nonticklish functions, 610
Normal
converting sparse matrix to list form, 
104, 138–139
forcing low-level primitive  
representation, 308
generating series expansions of  
functions, 429
normal modes, computing, 530–532
notation, 3–4 (see also postfix notation; 
prefix notation)
for bases other than 10, 12–13
for derivatives, 431–432, 433
functional, 6, 431–432, 433
in GraphUtilities` package, 161
for language grammars, 227
musical, 380–384
for numerical expressions, 3–4, 6
for XMLObject, 210–211

Index  |  791
Notation, 68
NotebookGet, 735
NotebookOpen, 735
NotebookPut, 735
notebooks
extracting information from, 733–737
formatting, 728–732
SaveAs formats, 735
saving and reopening, 615–616
saving space in, 613–615
transforming into other forms, 733–736
notebooks, interactive, 611–612
NotebookSave, 735
NSolve, 532
NSum, 57–58
Null, 174
NumberForm, 21
NumberFormat, 22
NumberPadding, 21
numbers, representation of (see also types, 
numerical)
display forms, 20–22
in lists, 95–97
using other bases, 12–13
numeric results, precision of, 2–3, 4–9
numerical expressions, notation for, 3–6
numerical types (see types, numerical)
O
object-based programming, 541–542
octave divisions, 397–401
Ohm’s law demonstration, 608–609
Opacity, 285, 295–296
OpenerView, 633–635
Options, 79–83
options, accepting, 79–83
options on securities, 551
American pricing, 583–585
computing implied volatility, 573
European pricing, 551, 565–576, 578–582
measuring sensitivity, 567–572
OptionValue, 79–80
Order, 187
ordered associative lookup, 125–129, 
133–134
Ordering, 101–102
Orderless, 29, 152
oscillations in tree methods, 585
Outer
extracting financial properties, 555–556
querying databases, 173
outliers, adjusting for, 471–472
overhead
master-slave, 660
of parallelization, 686–688
tradeoffs, 652
Overlaps
with StringCases, 195–196
with StringPosition, 198, 200
P
packages, defining custom, 725–727
packed arrays, 95–97
PaddedForm, 21–22
PairwiseScatterPlot, 494–496
palindrome demonstration, 206
PaneSelector, 633–635
Parade magazine, 502
Parallel Computing Toolkit, 642
parallel primitives, 659
parallel processing, 641–643
combining results of parallel data 
segments, 653–654
debugging code for, 642
distribution methods, 659–661
mapping functions across lists, 654–656
organizing operations, 665–668
overhead of, 652, 686–688
partitioning large data sets, 656–658
performance problems, 678–686
processing massive numbers of files, 
669–678
race conditions, 663–665
running commands on multiple kernels, 
648–650
running different algorithms in parallel, 
661–662
scope of, 641–642
of serial expressions, 651–653
sharing data between kernels, 662–663
ParallelCombine, 653–654, 659
ParallelDo, 659
ParallelEvaluate
checking state of remote kernels, 650
measuring overhead of parallelization, 
686–687

792  |  Index
running commands on multiple kernels, 
648–650
Parallelize, 651–653, 659
ParallelMap
as alternative to CriticalSection, 665
distributing computation across  
kernels, 659
implementing data-parallel algorithms, 
654–656
ParallelSubmit, 665–668
ParallelSum, 659
ParallelTable, 659
as alternative to CriticalSection, 665
partitioning large data sets, 656–658
ParallelTry, 661–662
parametric methods, 565
parametric plots, 249–251
ParametricPlot, 250–251
ParametricPlot3D, 290–292
compared to RevolutionPlot3D, 288
compared to SphericalPlot3D, 292
constraining 3D plots to specified 
regions, 296–297
ParetoPlot, 494–495
parsers, 227–235, 670
Part
accessing XML structure, 210–211
compared to ReplacePart, 157–159
taking lists apart, 88
partial derivatives, computing, 431–435
partial differential equations (PDEs), 534, 
574–578
particleData function, 513
ParticleData source, 513–516
particleTable, 513–514
Partition
converting linear list into 2D form, 
258–259
converting RGB images to HSV, 336–337
relationship to ListConvolve, 47–48
restructuring lists, 89–90
PassEventsDown, 631–632
PassEventsUp, 631
pattern-based programming, 145–146
pattern constructs, 146–150
pattern matching, 198–200
counting matching elements, 155–156
emulating unification-based matching, 
178–180
excluding matching elements, 153–155
extracting substrings, 193
extracting XML elements, 211–212
finding longest or shortest matches, 
159–161
finding matching values, 151–153
with genetic and protein data, 516–519
greedy and nongreedy, 159–161
manipulating 3D graphics, 326–327
manipulating patterns with, 169–170
order of processing, 28
primitives, 145–149
querying databases, 171–177
removing and replacing string  
characters, 188
replacing parts of an expression, 157–159
in strings and text, 183–186, 198–200
transforming matching values, 151–153
transforming XML, 213–214
using semantic relationships, 177–178
pattern tests, 149
patterns, defined, 146
PatternSequence, 148
PCA (principal component analysis), 
365–367
PDEs (partial differential equations), 534, 
574–578
PDF (probability density function), 461–464
Pentland, Alex, 367, 371
percussion grooves, 384–389
performance, improving
compiling functions, 727–728
dynamic modules, 613–615
freeing memory, 91, 112–114, 721
interactive graphics manipulation, 
602–604
interactivity, 613–615, 619–622
parallel processing, 665, 678–688
partial differential equations, 574–578
periodic table of elements, 508–510
permutation matrices
constructing, 105–109
sparse versions of, 114
perpetuity, 559–560
perspective, 309–312
perturbation, random, 498–499
Piecewise
composing complex functions, 427–428
creating envelopes, 394–397

Index  |  793
piecewise functions
composing, 427–429
as result of Integrate, 437
PiecewiseExpand, 429
pipeline approach, 665–668
Play, 391
Plot, 239
compared to ListPlot, 253
compared to Plot3D, 278
compared to PolarPlot, 248–249
Plot3D
combining 2D contours with 3D plots, 
295–296
compared to ParametricPlot3D, 291
compared to Plot, 278
constraining plots to specified regions, 
296–297
plotting functions in Cartesian 
coordinates, 276–282
PlotLabel, 241
PlotLegends` package, 260–261
PlotPoints
plotting 3D regions with satisfied 
predicates, 301–302
speeding up interactive graphics 
manipulation, 602–603
PlotRange
in interactive plots, 600–601
overriding, 255
specifying coordinates, 243–244
viewing 2D contours with 3D plots, 
295–296
plots, general (see also graphs)
combining slow and fast, 620–622
interactive annotation, 630–631
resolution and speed of interactivity, 602
plots, three-dimensional (see also graphics, 
three-dimensional; graphs)
3D contour plots, 292–294
building structural models from, 306–309
in Cartesian coordinates, 276–282
combining 2D contours with 3D plots, 
295–296
constraining to specified regions, 296–298
in cylindrical coordinates, 285–289
interactivity, 600–604
parametric, 290–292
plotting data, 298–300
regions with satisfied predicates, 301–302
in spherical coordinates, 283–285
plots, two-dimensional, 237–238 (see also 
graphics, two-dimensional; graphs)
in Cartesian coordinates, 239–247
central limit theorem, 464–466
combining 2D contours with 3D plots, 
295–296
combining multiple plots, 255–258
combining slow and fast plots, 620–622
of data, 252–254
displaying related plots, 258–260
distribution shapes, 468–471
formatting, 239–247, 259–260
function gradients, 446–447
interactivity, 600–604
legends, 260–263
limiting values, 426–427
linear regressions, 472–474
nonlinear models, 475–477
parametric plots, 249–251
in polar coordinates, 247–249
probability distributions, 464
pseudorandom number distributions, 460
series approximations, 430
statistical, 492–496
stylizing, 269–270
yield curves, 563–565
PlotStyle, 285
Plus, 34
polar coordinates, plotting in, 247–249
PolarPlot, 247–249
polyhedra characteristics, 320–326
PolyhedronData source, 175–177, 320–325
PolynomialMod, 423–424
PolynomialQuotient, 422
PolynomialQuotientRemainder, 422
PolynomialRemainder, 423–424
polynomials
decomposing, 420–422
dividing by other polynomials, 422–424
extreme values, 441–442
finding from given roots, 415–416
generating, 419–420
indefinite sums and products, 449
transforming, 417–419
population dynamics, modeling, 519–521
Position
with Count, 156
level specifications, 117

794  |  Index
manipulating nested lists, 114–116
pattern matching, 152–153, 154–155, 156
positions
extracting substrings, 193–194
removing and replacing string characters, 
189–190
Postfix, 51
postfix notation, 6
with AccountingForm, 20–21
and code readability, 48–51
specifying precision, 7
power series representations, 429–431
Precision, 8
precision of numeric results, 6
controlling, 2–3, 4–9
with mixed numerical types, 11
with mixed-precision values, 10
predator-prey dynamics, modeling, 519–521
Prefix, 51
prefix notation, 6
and code readability, 48–51
in rigid bodies problems, 522–523
Prepend, 87
prime notation, 432, 433
primes demonstration, 38–40
primitive functions, 25–27 (see also graphics 
primitives)
color primitives, 335–336
for decomposing polynomials, 421
parallel primitives, 659
pattern primitives, 145–149
principal component analysis (PCA), 365–367
Print
compared to PrintTemporary, 753
debugging with, 743–745
with TraceHandler, 680
printing, as debugging technique, 743–745
PrintTemporary, 753–754
Private` context, 726
probability density function (PDF), 461–464
probability distributions, 461–464
procedural programming style, 24–25
products (discrete calculus), 447–450
ProteinData source, 516–519
prototype patterns, defined, 68
pseudorandom numbers, generating, 459–461
pure functional languages, 31–32
pure functions, 24, 32
put-call parity, 566
put options, 551, 566–567
PValue
in ANOVA results, 480
in chi-square tests, 484
Q
quadSwap, 359
Quantile, 457
QuantilePlot, 494–495
quantiles, 457
QuartileSkewness, 469
quasirandom generators, 496–499
querying databases
for available entities, 715–717
with patterns, 171–177, 555
with SQLSelect, 711–713
Quiet, 756
R
race conditions
in parallel evaluation, 643
preventing, 663–665
Ramanujan, Srinivasa, 448
random numbers, 459–461, 496–504
random perturbation, 498–499
random walks, 500–502
RandomChoice
adding rhythm to melody, 377
defining indexed functions, 52
RandomInteger, 459
RandomReal
generating random numbers, 459
as nonticklish function, 610
Range
composing lists, 86–87
in grep implementation, 199
Raster, 330, 336–339
rational numbers
converting to integers, 18–19
as expression heads, 1–2
Rationalize
converting approximate values to exact, 19
finding polynomials from given roots, 416
readability, 48–51
ReadList, 690–691
real numbers
converting to other bases, 12–13
as expression heads, 1–2

Index  |  795
RealDigits, 13–14
Reap
building image transformations 
incrementally, 347–348
building lists incrementally, 57–59
debugging with, 746–749, 752, 756
Rectangle, 263–266
RecurrenceTable, 520–521
recursive descent parsers, 227–228, 235
recursive functions
debugging, 747–749
nonrecursive alternatives, 53–56
transforming XML with, 218–227
red-black tree algorithms
compared to built-in associative lookup, 
133–134
ordered associative lookup, 125–129
Reduce, 415
reduce, 669–678
Refresh, 609–610
RegionFunction, 298
RegionPlot, 301–302
regions
constraining plots to, 296–298
plotting, 301–302
regular expressions
common, 185–186
extracting words from strings, 193
standardization of, 183
stripping comments from, 190
RegularExpression, 183
ReinstallJava, 700–701
ReleaseHold, 168–169
remote kernels
benefits of, 693
configuring, 646–648
connecting frontend to, 692–694
Remove, 131
Repeated, 148
RepeatedNull, 148
Replace, 117–118
ReplaceAll
changing heads of XML data, 212–213
computing variance, 458
creating functions that accept options, 80
debugging infinite loops, 166–167
eliminating complex numbers, 156
evaluating difference equation solutions, 
452
querying databases, 174
transforming XML, 213, 223
ReplaceAllRepeated, 75
ReplaceList, 752
ReplacePart, 157–159
ReplaceRepeated
querying databases, 173–174
testing, 165–167
Resolve, 441
Rest, 88
Reverse, 89
RevolutionAxis, 289
RevolutionPlot3D
constraining 3D plots to specified 
regions, 296–297
plotting surfaces in cylindrical 
coordinates, 286–288
RGB color model, 335–340
rho (computational finance)
computing, 568
defined, 551, 568
plotting, 571
rhythm, 376–377, 382
Riffle, 87–88
rigid bodies problems, 522–524
roman numerals, converting, 15
Root objects, 441–442
Rotate
labeling arrows, 272–273
rotating 3D graphics, 318–319
RotateLeft, 65, 89
RotateRight, 65, 89
Round, 18–19
rounding rational numbers, 18–20
Row, 633–635
RSolve, 451–452
rules, 146, 150
completing replacement before 
evaluating, 168–169
implementing algorithms, 161–165
optimizing, 170–171
transforming matched values, 151
transforming XML, 213–218
using patterns as a query language, 171–177
Run, 690–691
S
SameQ, 91, 156
SameTest

796  |  Index
finding duplicate list elements, 91
querying databases, 177
saturation, 336
Save, 680
SaveAs, 735
SaveDefinitions, 617, 622–624
saveDirectory, 674–675
saver, 674–675
scalar operations, 17
scalars, defined, 93
Scale, 317
scales, musical, 375–376
Scan, 117–118
scientific applications, overview of, 505–506
ScientificForm, 22
scoping constructs, 611–612
scratch variables, 613–615
SeedRandom, 500
Select
extracting matching strings, 196
filtering points in kinematics problems, 525
taking lists apart, 88
SelectionSort, 98–99
semantic pattern matching, 177–178
sequence, 227–228
sequence recognition, 452–454
serial expressions, parallelizing, 651–653
Series, 429
SeriesObject, 429
Set
creating downvalues, 28
differentiating functions, 432
finding series expansions, 429
set functions, overview of, 91
SetAttributes, 29
SetDelayed
creating downvalues, 28
differentiating functions, 432
finding series expansions, 429
SetEdgeWeights, 139–140
SetPrecision, 7
sets, defined, 91
SetSharedFunction, 662
SetSharedVariable, 662–663
shape, 523–524
shared memory performance, 682
SharedMemory tracer, 682
Sharpen, 356
ShearingTransform, 320
shift matrices, constructing, 105–109
Short, 15
Shortest, 160–161
Show
combining 2D contours with 3D plots, 295
combining plots in a single graph, 
255–258
ShowLegend, 263
Sign, 428
Simplify
deriving cash flow arrangements, 559–560
solving differential equations, 439
transforming symbolic expressions, 417
simulations
kinematics problems, 526–529
power of, 502
stochastic, 499–504
Sin functions, 426–427
single-assignment, 31
SkeletonGraph, 175
Skewness, 468–469, 471
slave kernels
checking status of, 645
configuring, 643, 644–646
overhead, 660
in parallel computing, 642
in pipeline approach, 667, 668
sliders, 595–596, 625–627
SlideView, 635–636
Sobel edge-detection method, 361–364
Solve
compared to NSolve, 532
computing normal modes, 530–531
differentiating functions, 432
solving algebraic equations, 414–415
Sort
animated demonstration of, 628
compared to Ordering, 101
compared to SelectionSort, 98
identifying outliers, 471
with ParallelCombine, 653–654
restructuring lists, 89
sorting lists, 97–100
in structure-adding transformations, 
224–226
SortBy, 97
sorting (see also Sort; SortBy)
customizing quick sorts, 79–80
lists, 97–100

Index  |  797
Sound
creating scales and melodies, 375–376
playing digital sound files, 403–404
sound files, digital, 403–412
SoundNote
creating chords, 378
creating musical notes, 374–375
playing chord progressions, 379
specifying percussion instruments, 
385–388
syntax, 388–389
sounds (see audio and music processing)
Sow
building image transformations 
incrementally, 347–348
building lists incrementally, 57–59
debugging with, 746–749, 752, 756
sparse arrays, 112–114
SparseArray
conserving space, 91, 113–114
in statistical analysis, 457
synthesizing tridiagonal matrices, 104, 
531–532
specificationMap, 347–348, 350–351
spectrograph demonstration, 411–412
Specularity
controlling lighting of 3D graphics,  
313, 316
visualizing translucent surface  
coverings, 309
spell-check demonstration, 206–209
spherical coordinates, 3D plots in, 283–285
SphericalPlot3D
compared to ParametricPlot3D, 292
constraining 3D plots to specified 
regions, 296–297
plotting surfaces in spherical coordinates, 
283–284
Split, 224
SQL
database connectivity, 713–717
query equivalents, 171–177
Stack, 748
stack tracing, 747–749
StackInhibit, 749
Start (Windows), 691–692
stateless approach, 667
statistical analysis, 455–456
central limit theorem, 464–466
common functions, 456–459
common plots, 492–496
covariance and correlation, 466–468
grouping data into clusters, 486–492
hypothesis testing, 483–486
interpolation functions, 477–478
linear models, 472–474
measuring data shapes, 468
nonlinear models, 475–477
outliers, 471–472
probability distributions, 461–464
pseudorandom number generation, 
459–461
quasirandom number generation, 
496–499
statistical significance, 479–483
stochastic simulations, 499–504
Statistics in a Nutshell (Boslaugh and 
Watters), 455
central limit theorem, 465
chi-square demonstration, 484
testing for statistical significance, 479–480
StemLeafPlot, 494
step monitors, debugging with, 756–758
StepMonitor, 757–758
stochastic rounding, 19–20
stochastic simulations, 499–504
strict languages, 32
String, 380–381
string expressions, 183–185, 193
string patterns, classes of, 183–186
StringCases, 193, 195–196
StringDrop
compared to StringTake, 194
matching and searching text, 200
removing and replacing characters, 189
StringExpression, 183–184
StringFreeQ, 198, 199–200
StringJoin
duplicating strings, 196–197
extracting characters, 194
StringMatchQ
extracting matching strings, 196
matching patterns, 198, 199–200
StringPosition, 198, 200
StringReplace, 188–192
StringReplacePart, 189–190
strings, 181–186
comparing, 187

798  |  Index
converting, 15–16
duplicating, 196–198
extracting substrings from, 192–196
removing and replacing characters, 
188–192
stripping comments from, 190
StringSplit
listing polyhedron attributes, 321–322
tokenizing text, 201–202
StringTake, 193–194, 200
Style, 269
StyleData, 730
StyleDefinitions, 730
stylesheets, 728–732
SubitemNumbered, 731
Subscript, 420
subscripts, 51
Subsets, 91
substrings, extracting, 192–196
Sum
generating polynomials, 420
solving discrete calculus problems, 
448–450
SumConvergence, 448
sums (discrete calculus), 447–450
surface integrals, 444–445
surface properties, 313–316
surfaces, plotting, 285–292
Svensson model, 565
symbolic expressions, manipulating, 598–600
symbols
assigning attributes to, 29
in expressions with mixed numerical 
types, 9–10
modifying meaning of, 723
symbols, undefined, 27
syntax, 6
colon use, 151
Dictionary, 133
T
Table
creating a moving window for mapping, 44
generating lists, 86–87
mapping multiple functions in a single 
pass, 39–40
with ParallelEvaluate, 650
representing numerical lists, 95–96
TableType, 716
TabView, 635, 637–638
TagSet, 29
TagSetDelayed, 29
Take
mapping a function over a moving 
sublist, 44
running commands on multiple kernels, 
648–649
taking lists apart, 88
Tally
adjusting for outliers, 472
counting matching elements, 156
in linguistic processing, 205–206
in statistical analysis, 459
tempered tuning, 397, 400, 401–402
tensor functions, 93–95
tensors, defined, 93
Test, 766–767
TestFree, 765–766
TestID, 763, 771
testing, 742
creating tests with alternate criteria, 
765–767
creating unit tests, 762–765
organizing and controlling MUnit tests, 
767–769
TestMatch, 765–766
TestSections, 772–775
TestStringFree, 765–766
TestStringMatch, 765–766
TestSuite construct, 768–769
Text
annotating 2D graphics, 263, 269–270
labeling arrows, 272–273
text annotations (see annotation)
text strings, 181–186
changing delimiters in, 190–191
matching patterns in, 198–200
tokenizing, 201–202
theta (computational finance)
computing, 568
defined, 551, 568
plotting, 570
Thickness, 268
three-dimensional graphics (see graphics, 
three-dimensional; graphs; plots, 
three-dimensional)
Through, 457
Throw, 772–773
ToCharacterCode, 182

Index  |  799
ToExpression
expression evaluation, 192
transforming XML, 213–214
tokenizing text, 201–202
ToolTip, 512
ToString, 182
Towers of Hanoi puzzle, 451–452
Tr, 102–103
Trace, 749–753
TraceHandler, 679–680
TraceList, 680–686
Tracers, 679–680
TraceScan, 752–753
transform, 225–226
transformation functions, symbolic, 319–320
transformation matrices, 319–320
transformations
after evaluation, 168–169
images, 347–348
polynomials, 417–419
structure-adding, 224–226
trigonometric, 419
transitive closure, computing, 162–163
transitiveClosure, 162–163
Translate, 318
Transpose
formatting property lists, 517–518
in Fourier analysis, 411–412
in grep implementation, 199
interlacing percussion elements, 387–388
restructuring lists, 89
traversal algorithms, 121–125
tree algorithms
interest-rate sensitivity, 587–591
option pricing, 585, 587–590
red-black, 125–129, 133–134
traversals, 121–125
tree data structures
converting to and from lists, 89, 127–128
modeling with lists, 121–125
selective flattening, 90
tremolo, 392, 394
TriangleWave, 538
tridiagonal matrices, 104–105, 530
TrigExpand, 419
TrigFactor, 419
trigonometric transformations, 419
TrigReduce, 419
trimmed mean, computing, 471
trinomial scheme, 583–585
truss structures, modeling, 539–547
trussGraphicNodes, 544–545
TrussModel, 541–547
tunings, alternate, 397–402
Tuples, 14–15
Turk, Matthew, 367, 371
two-dimensional graphics (see graphics, 
two-dimensional; graphs; plots, 
two-dimensional)
types, numerical
compiling functions, 727, 728
converting between, 18–20
identifying database support for, 716
indicated by Head, 1–2
mixing, 9–11
with .NET applications, 707–708, 710
returned by MathLink, 699
U
unbiased rounding rule, 19–20
uncertainty, 16–18
undo operation, 65
Unicode, 181
unification-based matching, 178–180
uniform distributions, 465–466
unify, 179–180
Union
eliminating duplicate list elements, 91
ordering extracted nodes, 541
Unique
associative lookup, 131
with Private, 726
uniqueFileName, 674–675
unit tests
in frontend, 769–775
organizing and controlling, 767–769
writing, 762–767
UnitStep, 428
unpacked arrays, 95–97
unprotecting operations, 722–723
UnsavedVariables, 613
UpperTriangularize, 105
UpSet, 28–29
UpSetDelayed, 28–29
upvalues, 28–29, 65
UpValues
displaying bit vectors efficiently, 119
redefining functions, 28–29

800  |  Index
user-customized functions, 28–29, 79–83
UsingFrontEnd, 736
V
value (brightness), 336–337
Value-at-Risk (VaR), modeling, 585–587
van der Corput sequence, 497, 498
variables
controlling values interactively, 594–597
dynamic module, 624–625
global, 723
labeling, 597
scoped, 611–612
scratch, 613–615
storage of, 612
Variables, 421
variance, computing, 458
vector calculus problems, solving, 443–447
vector functions, overview of, 91–92
VectorAnalysis` package, 92, 445
VectorPlot, 446–447
vectors, 93
bit, 119–121
Boolean, 488–491
computing covariance and correlation, 
466–468
eigenvectors, 365–371
vega (computational finance)
computing, 568–569
defined, 551, 568
plotting, 571
Verbatim, 169–170
vibrating strings, modeling, 533–536
vibrato, 393–394
ViewAngle, 312
ViewCenter, 311–312
ViewPoint, 310, 312
ViewVector, 312
ViewVertical
controlling viewing perspective, 312
plotting surfaces in cylindrical 
coordinates, 289
volatility, implied, 573
volume, 377–378, 382
W
Wagon, Stan, 52, 304–305
Wang, Ruye, 351
Watters, Paul (see Statistics in a Nutshell)
Webber, Thomas, 578, 582
Weisstein, Eric, 63
wget (GNU), 690–691
Windows programs, launching, 691–692
WinMain, 695–697
wireframe models, 306–309
With
binding locally defined variables, 
648–650
measuring securities option sensitivity, 
571–572
with ParallelSubmit, 668
varying electrical circuit input values, 537
Wolfram Workbench
integrating into frontend, 769–775
visual debugging, 758–762
writing test units, 762, 764–765
Woods, Richard, 331, 351, 359
WordData, 208
wormholes, 624
X
XML
heads, 210, 212–213
importing, 209–213
removing markup, 191–192
stylizing, 201–202
transforming with patterns and rules, 
213–218
transforming with recursive functions, 
218–227
XMLElement, 210, 212–214
XMLObject, 209–210, 212–213
XSLT
compared to Mathematica, 218, 226–227
grouping constructs, 224
transformation rules, 221
Y
Yahoo! URL structure, 557–559
Yale Face Database, 367–371
yield curves, 563–565
yield to maturity, 561
Z
Z-transforms, 449

About the Author
Sal Mangano has been developing software for over 12 years and has worked on many
mission-critical applications, especially in the area of financial-trading applications.
Unlike many XML/XSLT developers, he did not approach the technology from the
standpoint of the Internet and Web development but rather from the broader need for
a general-purpose, data-transformation framework. This experience has given him a
unique perspective that has influenced many of the recipes in his book, the XSLT
Cookbook. Sal has a Master’s degree in Computer Science from Polytechnic University.
Colophon
The animal on the cover of Mathematica Cookbook is a solarium (genus Solarium)
known more commonly today as a sundial or perspective shell. It serves as protection
for marine snails of the genus Architectonica (a Latin name which modern scientists
also use to refer to the shells). While usually found in the tropical Indo-Pacific
region, the solariums also live in warmer waters near North and South America. As
the snails prefer shallow habitat, their shells often wash ashore and are an easy find
for beachgoers.
There are approximately 40 species, and while texture, coloration, and markings vary
accordingly, all solariums have a spiral pattern. On their flattened circular shells, this
radiating effect is evocative of the sun, and likely how the animal got its name. Most
solarium decorations are vivid, including such motifs as bold lines, grooves, alternat-
ing colors, or blotches. Viewed from below, the shell’s deep interior is lined with corru-
gations that resemble a winding staircase.
The direction in which a snail’s shell coils, interestingly, is comparable to left- or right-
handedness in a human. In their larval stage, Architectonica snails begin to develop
soft left-coiling shells. However, when the snail enters its adult stage, the solarium
reverses direction and spirals to the right as it grows. The majority of gastropods have
dextral (right-facing) shells.
The cover image is from Dover Pictorial Archive. The cover font is Adobe ITC Gara-
mond. The text font is Linotype Birka; the heading font is Adobe Myriad Condensed;
and the code font is LucasFont’s TheSansMonoCondensed.

