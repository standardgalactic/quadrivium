
Texts in Theoretical Computer Science
An EATCS Series
Editors: W. Brauer J. Hromkoviˇc G. Rozenberg A. Salomaa
On behalf of the European Association
for Theoretical Computer Science (EATCS)
Advisory Board:
G. Ausiello M. Broy C.S. Calude A. Condon
D. Harel J. Hartmanis T. Henzinger T. Leighton
M. Nivat C. Papadimitriou D. Scott

Erich Grädel • Phokion G. Kolaitis • Leonid Libkin
Maarten Marx • Joel Spencer • Moshe Y. Vardi
Yde Venema • Scott Weinstein
Finite Model Theory
and Its Applications
With 35 Figures and 2 Tables

Authors
Erich Grädel
Mathematical Foundations
of Computer Science
RWTH Aachen
graedel@informatik.rwth-aachen.de
Phokion G. Kolaitis
IBM Almaden Research Center
kolaitis@almaden.ibm.com
and
Univ. of California at Santa Cruz
kolaitis@cs.ucsc.edu
Leonid Libkin
Univ. of Edinburgh
libkin@inf.ed.ac.uk
Maarten Marx
ISLA, Universiteit van Amsterdam
marx@science.uva.nl
Joel Spencer
Courant Institute
spencer@cims.nyu.edu
Moshe Y. Vardi
Rice University
vardi@cs.rice.edu
Yde Venema
Universiteit van Amsterdam
yde@science.uva.nl
Scott Weinstein
Univ. of Pennsylvania
weinstein@cis.upenn.edu
Series Editors
Prof. Dr. Wilfried Brauer
Institut für Informatik der TUM
Boltzmannstr. 3
85748 Garching, Germany
brauer@informatik.tu-muenchen.de
Prof. Dr. Juraj Hromkoviˇc
ETH Zentrum
Department of Computer Science
Swiss Federal Institute of Technology
8092 Zürich, Switzerland
juraj.hromkovic@inf.ethz.ch
Prof. Dr. Grzegorz Rozenberg
Leiden Institute of Advanced
Computer Science
University of Leiden
Niels Bohrweg 1
2333 CA Leiden, The Netherlands
rozenber@liacs.nl
Prof. Dr. Arto Salomaa
Turku Centre of
Computer Science
Lemminkäisenkatu 14 A
20520 Turku, Finland
asalomaa@utu.ﬁ
Library of Congress Control Number: 2007923182
ACM Computing Classiﬁcation (1998): F.4.1, F.1.3, H.2.3, I.2.4, I.2.8
ISSN 1862-4499
ISBN 978-3-540-00428-8 Springer Berlin Heidelberg New York
This work is subject to copyright. All rights are reserved, whether the whole or part of the material is concerned,
speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on
microﬁlm or in any other way, and storage in data banks. Duplication of this publication or parts thereof is permitted
only under the provisions of the German Copyright Law of September 9, 1965, in its current version, and permission
for use must always be obtained from Springer. Violations are liable for prosecution under the German Copyright
Law.
Springer is a part of Springer Science+Business Media
springer.com
c⃝Springer-Verlag Berlin Heidelberg 2007
The use of general descriptive names, registered names, trademarks, etc. in this publication does not imply, even in
the absence of a speciﬁc statement, that such names are exempt from the relevant protective laws and regulations
and therefore free for general use.
Cover Design: KünkelLopka, Heidelberg
Typesetting: by the authors
Production: Integra Software Services Pvt. Ltd., Pondicherry, India
Printed on acid-free paper
45/3100/Integra
5 4 3 2 1 0


Preface
Finite model theory, as understood here, is an area of mathematical logic that
has developed in close connection with applications to computer science, in
particular the theory of computational complexity and database theory. One
of the fundamental insights of mathematical logic is that our understanding
of mathematical phenomena is enriched by elevating the languages we use to
describe mathematical structures to objects of explicit study. If mathematics
is the science of patterns, then the media through which we discern patterns,
as well as the structures in which we discern them, command our attention. It
is this aspect of logic which is most prominent in model theory, “the branch of
mathematical logic which deals with the relation between a formal language
and its interpretations”. No wonder, then, that mathematical logic, and ﬁnite
model theory in particular, should ﬁnd manifold applications in computer
science: from specifying programs to querying databases, computer science
is rife with phenomena whose understanding requires close attention to the
interaction between language and structure.
This volume gives a broad overview of some central themes of ﬁnite model
theory: expressive power, descriptive complexity, and zero–one laws, together
with selected applications to database theory and artiﬁcial intelligence, espe-
cially constraint databases and constraint satisfaction problems. The ﬁnal
chapter provides a concise modern introduction to modal logic, which empha-
sizes the continuity in spirit and technique with ﬁnite model theory. Chapters
2–7 are extensively revised and updated versions of tutorials presented at the
University of Pennsylvania on April 12–15, 1999, under the sponsorship of
Penn’s Institute for Research in Cognitive Science (IRCS) and the Center
for Discrete Mathematics and Theoretical Computer Science (DIMACS) at
Rutgers University. We would like to express our gratitude to DIMACS and
IRCS for their support, which made these tutorials possible. The tutorials
were presented to a diverse audience of computer scientists, linguists, logi-
cians, mathematicians, and philosophers, and the chapters of the book retain
the broad accessibility and wide appeal of the tutorials. The introductory
chapter highlights common themes among the tutorials that follow.

VI
Preface
This volume is not meant to be a textbook on ﬁnite model theory. There
are three such texts currently available. Finite Model Theory, by Ebbinghaus
and Flum, and Elements of Finite Model Theory, by Libkin, provide general
coverage of the ﬁeld, while Descriptive Complexity, by Immerman, focuses
on the connection between ﬁnite model theory and computational-complexity
theory. Rather, this volume aims at highlighting applications of ﬁnite model
theory, emphasizing “the unusual eﬀectiveness of logic in computer science”.
December 18, 2006
Moshe Y. Vardi
Scott Weinstein

Contents
1
Unifying Themes in Finite Model Theory . . . . . . . . . . . . . . . . . .
1
1.1
Deﬁnability Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.1
Classiﬁcation of Concepts in Terms
of Deﬁnitional Complexity . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.2
What More Do We Know When We Know
a Concept Is L-Deﬁnable? . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.1.3
Logics with Finitely Many Variables . . . . . . . . . . . . . . . . .
7
1.1.4
Distinguishing Structures: L-Equivalence
and Comparison Games . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.1.5
Random Graphs and 0–1 Laws . . . . . . . . . . . . . . . . . . . . . . 10
1.1.6
Constraint Satisfaction Problems . . . . . . . . . . . . . . . . . . . . 11
1.2
Descriptive Complexity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.2.1
Satisfaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.2.2
What Is a Logic for PTIME? . . . . . . . . . . . . . . . . . . . . . . . 16
1.3
Finite Model Theory and Inﬁnite Structures . . . . . . . . . . . . . . . . 18
1.4
Tame Fragments and Tame Classes . . . . . . . . . . . . . . . . . . . . . . . . 20
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2
On the Expressive Power of Logics on Finite Models. . . . . . . 27
2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.2
Basic Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.3
Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic . . . . . . . . . . . . 34
2.4
Computational Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.4.1
Complexity Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.4.2
The Complexity of Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.5
Ehrenfeucht–Fra¨ıss´e Games for Existential
Second-Order Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.6
Logics with Fixed-Point Operators . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.6.1
Operators and Fixed Points. . . . . . . . . . . . . . . . . . . . . . . . . 60
2.6.2
Least Fixed-Point Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
2.6.3
Datalog and Datalog(̸=). . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

VIII
Contents
2.6.4
The Complementation Problem for LFP1
and a Normal Form for LFP . . . . . . . . . . . . . . . . . . . . . . . . 79
2.6.5
Partial Fixed-Point Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
2.7
Inﬁnitary Logics with Finitely Many Variables . . . . . . . . . . . . . . 86
2.7.1
The Inﬁnitary Logic Lω
∞ω . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
2.7.2
Pebble Games and Lω
∞ω-Deﬁnability . . . . . . . . . . . . . . . . . 89
2.7.3
0–1 Laws for Lω
∞ω . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
2.7.4
Deﬁnability and Complexity of Lk
∞ω-Equivalence . . . . . . 99
2.7.5
Least Fixed-Point Logic vs. Partial Fixed-Point
Logic on Finite Structures . . . . . . . . . . . . . . . . . . . . . . . . . . 104
2.8
Existential Inﬁnitary Logics with Finitely Many Variables . . . . 106
2.8.1
The Inﬁnitary Logics ∃Lk
∞ω and ∃Lk
∞ω(̸=) . . . . . . . . . . . . 107
2.8.2
Existential Pebble Games . . . . . . . . . . . . . . . . . . . . . . . . . . 109
2.8.3
Descriptive Complexity of Fixed Subgraph
Homeomorphism Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
3
Finite Model Theory and Descriptive Complexity . . . . . . . . . 125
3.1
Deﬁnability and Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
3.1.1
Complexity Issues in Logic . . . . . . . . . . . . . . . . . . . . . . . . . 126
3.1.2
Model Checking for First-Order Logic . . . . . . . . . . . . . . . . 128
3.1.3
The Strategy Problem for Finite Games . . . . . . . . . . . . . . 129
3.1.4
Complexity of First-Order Model Checking . . . . . . . . . . . 132
3.1.5
Encoding Finite Structures by Words . . . . . . . . . . . . . . . . 135
3.2
Capturing Complexity Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
3.2.1
Capturing NP: Fagin’s Theorem . . . . . . . . . . . . . . . . . . . . . 138
3.2.2
Logics That Capture Complexity Classes . . . . . . . . . . . . . 144
3.2.3
Capturing Polynomial Time on Ordered Structures . . . . 145
3.2.4
Capturing Logarithmic Space Complexity . . . . . . . . . . . . 149
3.2.5
Transitive Closure Logics . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
3.3
Fixed-Point Logics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
3.3.1
Some Fixed-Point Theory . . . . . . . . . . . . . . . . . . . . . . . . . . 153
3.3.2
Least Fixed-Point Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
3.3.3
The Modal μ-Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
3.3.4
Parity Games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
3.3.5
Model-Checking Games for Least Fixed-Point Logic . . . 165
3.3.6
Deﬁnability of Winning Regions in Parity Games . . . . . . 169
3.3.7
Simultaneous Fixed-Point Inductions . . . . . . . . . . . . . . . . 170
3.3.8
Inﬂationary Fixed-Point Logic . . . . . . . . . . . . . . . . . . . . . . 174
3.3.9
Partial Fixed-Point Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
3.3.10 Datalog and Stratiﬁed Datalog . . . . . . . . . . . . . . . . . . . . . . 180
3.4
Logics with Counting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
3.4.1
Logics with Counting Terms . . . . . . . . . . . . . . . . . . . . . . . . 187
3.4.2
Fixed-Point Logic with Counting . . . . . . . . . . . . . . . . . . . . 188
3.4.3
Datalog with Counting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190

Contents
IX
3.5
Capturing PTIME via Canonization . . . . . . . . . . . . . . . . . . . . . . . 193
3.5.1
Deﬁnable Linear Orders . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
3.5.2
Canonizations and Interpretations . . . . . . . . . . . . . . . . . . . 194
3.5.3
Capturing PTIME up to Bisimulation. . . . . . . . . . . . . . . . 198
3.5.4
Is There a Logic for PTIME? . . . . . . . . . . . . . . . . . . . . . . . 203
3.6
Algorithmic Model Theory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
3.6.1
Beyond Finite Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
3.6.2
Finitely Presentable Structures . . . . . . . . . . . . . . . . . . . . . . 206
3.6.3
Metaﬁnite Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
3.6.4
Metaﬁnite Spectra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
3.6.5
Descriptive Complexity over the Real Numbers. . . . . . . . 216
3.7
Appendix: Alternating Complexity Classes. . . . . . . . . . . . . . . . . . 222
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
4
Logic and Random Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
4.1
An Instructive Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
4.2
Random Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
4.3
Extension Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
4.4
Closure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
4.5
The Almost Sure Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
4.6
The Case p Constant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
4.7
Countable Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
4.8
A Dynamic View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
4.9
Inﬁnite Spectra via Almost Sure Encoding . . . . . . . . . . . . . . . . . . 244
4.10 The Jump Condition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
4.11 The Complexity Condition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
4.12 Nonconvergence via Almost Sure Encoding . . . . . . . . . . . . . . . . . 249
4.13 No Almost Sure Representation of Evenness . . . . . . . . . . . . . . . . 251
4.14 The Ehrenfeucht Game. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
4.15 About the References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
5
Embedded Finite Models and Constraint Databases . . . . . . . 257
5.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
5.1.1
Organization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
5.2
Relational Databases and Embedded Finite Models . . . . . . . . . . 258
5.3
Constraint Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
5.4
Collapse and Genericity: An Overview . . . . . . . . . . . . . . . . . . . . . 266
5.4.1
Approaches to Proving Expressivity Bounds . . . . . . . . . . 267
5.5
Active-Generic Collapse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
5.5.1
The Ramsey Property . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
5.5.2
Collapse Results. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
5.6
Natural-Active Collapse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
5.6.1
Collapse: Failure and Success . . . . . . . . . . . . . . . . . . . . . . . 274
5.6.2
Good Structures vs. Bad Structures: O-minimality. . . . . 276

X
Contents
5.6.3
Collapse Theorem and Corollaries . . . . . . . . . . . . . . . . . . . 277
5.6.4
Collapse Algorithm: the Linear Case . . . . . . . . . . . . . . . . . 278
5.6.5
Collapse Algorithm: the General Case . . . . . . . . . . . . . . . . 280
5.6.6
Collapse Without O-minimality . . . . . . . . . . . . . . . . . . . . . 285
5.6.7
Natural-Generic Collapse . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
5.7
Model Theory and Collapse Results . . . . . . . . . . . . . . . . . . . . . . . . 288
5.7.1
Pseudo-ﬁnite Homogeneity . . . . . . . . . . . . . . . . . . . . . . . . . 289
5.7.2
Finite Cover Property and Collapse . . . . . . . . . . . . . . . . . . 290
5.7.3
Isolation and Collapse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
5.8
The VC Dimension and Collapse Results . . . . . . . . . . . . . . . . . . . 295
5.8.1
Random Graph and Collapse to MSO . . . . . . . . . . . . . . . . 298
5.8.2
Complexity Bounds for Generic Queries . . . . . . . . . . . . . . 299
5.9
Expressiveness of Constraint Query Languages . . . . . . . . . . . . . . 301
5.9.1
Reductions to the Finite Case . . . . . . . . . . . . . . . . . . . . . . . 301
5.9.2
Topological Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
5.9.3
Linear vs. Polynomial Constraints . . . . . . . . . . . . . . . . . . . 305
5.10 Query Safety. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
5.10.1 Finite and Inﬁnite Query Safety . . . . . . . . . . . . . . . . . . . . . 308
5.10.2 Safe Translations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
5.10.3 Finite Query Safety: Characterization . . . . . . . . . . . . . . . . 311
5.10.4 Inﬁnite Query Safety: Reduction . . . . . . . . . . . . . . . . . . . . 316
5.10.5 Deciding Safety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
5.10.6 Dichotomy Theorem for Embedded Finite Models . . . . . 321
5.11 Database Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
5.11.1 Aggregate Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
5.11.2 Higher-Order Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
5.12 Bibliographic Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
6
A Logical Approach to Constraint Satisfaction . . . . . . . . . . . . . 339
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
6.2
Preliminaries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
6.3
The Computational Complexity of Constraint Satisfaction . . . . 344
6.4
Nonuniform Constraint Satisfaction . . . . . . . . . . . . . . . . . . . . . . . . 347
6.5
Monotone Monadic SNP and Nonuniform Constraint
Satisfaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
6.6
Datalog and Nonuniform Constraint Satisfaction . . . . . . . . . . . . 352
6.7
Datalog, Games, and Constraint Satisfaction . . . . . . . . . . . . . . . . 355
6.8
Games and Consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
6.9
Uniform Constraint Satisfaction and Bounded Treewidth . . . . . 362
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367

Contents
XI
7
Local Variations on a Loose Theme:
Modal Logic and Decidability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
7.2
Modal Systems and Bisimulations . . . . . . . . . . . . . . . . . . . . . . . . . 373
7.3
Basic Modal Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
7.3.1
Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388
7.4
Some Variations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
7.4.1
Neither Locality nor Looseness: Grid Logics . . . . . . . . . . 390
7.4.2
Universal Access: K∗. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
7.4.3
Generalizing Looseness: the Until Operator . . . . . . . . . . . 397
7.5
Modal Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
7.5.1
NP and the Polysize Model Property . . . . . . . . . . . . . . . . 405
7.5.2
PSPACE and Polynomially Deep Paths . . . . . . . . . . . . . . 406
7.5.3
EXPTIME and Exponentially Deep Paths . . . . . . . . . . . . 408
7.5.4
NEXPTIME . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
7.5.5
Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
7.6
Modal Logic and First-Order Logic . . . . . . . . . . . . . . . . . . . . . . . . 413
7.6.1
Guarded Fragments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
7.6.2
Decidability and Complexity . . . . . . . . . . . . . . . . . . . . . . . 418
7.6.3
Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431

Authors
Erich Gr¨adel
Mathematical Foundations
of Computer Science
RWTH Aachen
52056 Aachen, Germany
graedel@informatik.
rwth-aachen.de
Phokion G. Kolaitis
IBM Almaden Research Center
Computer Science Principles
and Methodologies
650 Harry Road
San Jose, CA 95120-6099, USA
kolaitis@almaden.ibm.com
and
Computer Science Dept.
Univ. of California at Santa Cruz
CA 95064, USA
kolaitis@cs.ucsc.edu
Leonid Libkin
School of Informatics
Univ. of Edinburgh
Edinburgh, EH8 9LE
UK
libkin@inf.ed.ac.uk
Maarten Marx
ISLA, Universiteit van Amsterdam
The Netherlands
marx@science.uva.nl
Joel Spencer
Courant Institute
251 Mercer Street
New York, NY 10012, USA
spencer@cims.nyu.edu
Moshe Y. Vardi
Dept. of Computer Science
Rice University
Mail Stop 132
6100 S. Main Street
Houston, TX 77005-1892, USA
vardi@cs.rice.edu
Yde Venema
Inst. for Logic, Language and
Computation
Universiteit van Amsterdam
Plantage Muidergracht 24
1018 TV Amsterdam
The Netherlands
yde@science.uva.nl
Scott Weinstein
Dept. of Philosophy
Univ. of Pennsylvania
Philadelphia, PA 19104, USA
weinstein@cis.upenn.edu

1
Unifying Themes in Finite Model Theory
Scott Weinstein
One of the fundamental insights of mathematical logic is that our understand-
ing of mathematical phenomena is enriched by elevating the languages we use
to describe mathematical structures to objects of explicit study. If mathe-
matics is the science of pattern, then the media through which we discern
patterns, as well as the structures in which we discern them, command our
attention. It is this aspect of logic which is most prominent in model theory,
“the branch of mathematical logic which deals with the relation between a
formal language and its interpretations” [21]. No wonder, then, that mathe-
matical logic, in general, and ﬁnite model theory, the specialization of model
theory to ﬁnite structures, in particular, should ﬁnd manifold applications in
computer science: from specifying programs to querying databases, computer
science is rife with phenomena whose understanding requires close attention
to the interaction between language and structure.
As with most branches of mathematics, the growth of mathematical logic
may be seen as fueled by its applications. The very birth of set theory was
occasioned by Cantor’s investigations in real analysis, on subjects themselves
motivated by developments in nineteenth-century physics; and the study of
subsets of the real line has remained the source of some of the deepest results
of contemporary set theory. At the same time, model theory has matured
through the development of ever deeper applications to algebra. The interplay
between language and structure, characteristic of logic, may be discerned in all
these developments. From the focus on deﬁnability hierarchies in descriptive
set theory, to the classiﬁcation of structures up to elementary equivalence
in classical model theory, logic seeks order in the universe of mathematics
through the medium of formal languages.
As noted, ﬁnite model theory too has grown with its applications, in this
instance not to analysis or algebra, but to combinatorics and computer sci-
ence. Beginning with connections to automata theory, ﬁnite model theory has
developed through a broader and broader range of applications to problems
in graph theory, complexity theory, database theory, computer-aided veriﬁca-
tion, and artiﬁcial intelligence. And though its applications have demanded

2
1 Unifying Themes in Finite Model Theory
the development of new techniques, which have given the subject a distinc-
tive character as compared to classical model theory, the fundamental focus
on organizing and understanding phenomena through attention to the rela-
tion between language and structure remains prominent. Indeed, the detailed
investigation of deﬁnability hierarchies and classiﬁcations of ﬁnite structures
up to equivalence relations coarser than elementary equivalence, which are
deﬁned in terms of a wide variety of fragments of ﬁrst-order, second-order,
ﬁxed-point, and inﬁnitary logics, is a hallmark of ﬁnite model theory. The
remaining sections of this chapter will highlight common themes among the
chapters to follow.
1.1 Deﬁnability Theory
The volume begins with a chapter by Phokion Kolaitis, “On the expressive
power of logics on ﬁnite models”, which surveys major topics in the theory
of deﬁnability in the context of ﬁnite structures. “The theory of deﬁnability
is the branch of logic which studies the complexity of concepts by looking
at the grammatical complexity of their deﬁnitions.” [3]. This characterization
indicates that the theory of deﬁnability has two main aspects:
•
to establish a classiﬁcation of concepts in terms of deﬁnitional complexity
•
to establish that such classiﬁcation is in some way informative about the
intrinsic or intuitive “complexity” of the concepts thus classiﬁed.
Chapter 2 provides an extended treatment of both these aspects of deﬁnability
theory, which reappear throughout the volume as important themes in ﬁnite
model theory and its applications.
1.1.1 Classiﬁcation of Concepts in Terms of Deﬁnitional
Complexity
In the context of ﬁnite model theory, the “concepts” with which we are con-
cerned are queries on classes of ﬁnite relational structures. Chapter 2 pro-
vides precise deﬁnitions of these notions; for the purposes of introduction, let
us focus on Boolean queries on a particular set of ﬁnite undirected graphs
as follows. Let Gn be the collection of undirected graphs with vertex set
[n] (= {1, . . . , n}), and let G = 
n Gn. Thus, each G ∈G has a vertex
set V G = [n], for some n, and an irreﬂexive and symmetric edge relation
EG ⊆[n] × [n]. A Boolean query Q on G is just an isomorphism-closed subset
of G, that is, Q ⊆G is a Boolean query if and only if, for all G, H ∈G,
G ∼= H =⇒(G ∈Q ⇔H ∈Q).
Logical languages provide a natural means for classifying Boolean queries.
A logical language L consists of a set of L-sentences, SL, and an L-satisfaction

1.1 Deﬁnability Theory
3
relation |=L. In the current setting, we may understand |=L as a relation
between graphs G ∈G and sentences ϕ ∈SL: G |=L ϕ, if and only if G
satisﬁes the condition expressed by ϕ. A fundamental notion is the Boolean
query, ϕ[G], deﬁned by an L-sentence, ϕ:
ϕ[G] = {G ∈G | G |=L ϕ}.
A Boolean query Q on G is L-deﬁnable if and only if there is an L-sentence ϕ
with Q = ϕ[G].
Let us look at some examples. Consider the following Boolean queries:
Sizen the set of graphs of size n;
Diamn the set of graphs of diameter ≤n;
Colork the set of k-colorable graphs;
Conn the set of connected graphs;
CardX the set of graphs of size n for some n ∈X ⊆N.
The ﬁrst two queries are deﬁned by ﬁrst-order sentences σn and δn, respec-
tively, for each n; for example, the query Size2 is deﬁned by the ﬁrst-order
sentence σ2,
∃x∃y(x ̸= y) ∧¬∃x∃y∃z(x ̸= y ∧x ̸= z ∧y ̸= z),
and the query Diam2 is deﬁned by the ﬁrst-order sentence δ2,
∀x∀y(x = y ∨Exy ∨∃z(Exz ∧Ezy)).
For each k, the third query is deﬁned by a sentence χk of existential monadic
second-order logic, that is, the fragment of second-order logic consisting of
sentences all of whose second-order quantiﬁers are existential, bind monadic
predicate symbols, and do not occur within the scope of any ﬁrst-order quan-
tiﬁer or truth-functional connective; for example, Color2 is deﬁned by the
sentence χ2,
∃Z∀x∀y(Exy →(Zx ↔¬Zy)).
The next query is deﬁned by a sentence γ of Lω1ω , the inﬁnitary logic obtained
by adding the operations of countable conjunction and countable disjunction
to ﬁrst-order logic, as follows:

n∈N
δn.
Note that in general, γ expresses the condition that a graph has bounded
diameter – over G, this condition coincides with connectedness. Finally, for
each X ⊂N, the query CardX is deﬁned by a sentence κX of Lω1ω as follows:

n∈X
σn.
Now, broadly speaking, deﬁnability theory provides techniques for deter-
mining whether or not given queries, or collections of queries, are deﬁnable in

4
1 Unifying Themes in Finite Model Theory
a speciﬁed logic L, and attempts to extract useful information about queries
from the fact that they are L-deﬁnable. For example, Chap. 2 develops tools to
show that neither Colork nor Conn is ﬁrst-order deﬁnable, and thus stronger
logics are needed to express such basic combinatorial properties.
1.1.2 What More Do We Know When We Know a Concept Is
L-Deﬁnable?
This, of course, depends on L. One striking feature of ﬁnite model theory has
been that it has drawn attention to the fact that a great deal of interesting
information about Boolean queries can be extracted from the fact that they
are deﬁnable in familiar logical languages, and, perhaps even more striking,
it has highlighted the importance of some natural, though hitherto neglected,
fragments of well-studied languages, such as the ﬁnite variable fragments of
ﬁrst-order logic and inﬁnitary logic discussed below.
Before we proceed to explore this aspect of deﬁnability theory in the con-
text of ﬁnite model theory, let us reﬂect for a moment on a paradigmatic
example of extracting information from the fact that a set is deﬁnable in
a certain way: the celebrated result of Cantor concerning the cardinality of
closed sets of real numbers. Recall that a closed set can be deﬁned as the com-
plement of a countable union of open intervals with rational endpoints (which
implies, in modern parlance, that a closed set is Π0
1). Note that we may
infer from this deﬁnability characterization that there are only 2ℵ0 closed sets
of reals, while there are 2(2ℵ0) sets of reals altogether. Cantor showed that
closed sets satisfy a very strong dichotomy with respect to their cardinali-
ties: every inﬁnite closed set is either countable or of cardinality 2ℵ0, that is,
there is no closed set witnessing a cardinality strictly between ℵ0 and 2ℵ0. On
the basis of his success with closed sets, Cantor was motivated to formulate
the Continuum Hypothesis (CH): the conjecture that all inﬁnite sets of reals
satisfy this strong cardinality dichotomy. In 1963, Cohen established that if
Zermelo–Fraenkel set theory with the Axiom of Choice (ZFC) is consistent,
then it is consistent with the statement that there is an inﬁnite set of reals
whose cardinality is neither ℵ0 nor 2ℵ0, that is, ZFC+¬CH is consistent rela-
tive to ZFC. Thus, Cantor’s result shows how it is possible to gain signiﬁcant
structural information about a concept from the knowledge that it admits a
“simple” enough deﬁnition. In what Moshovakis describes as “one of the ﬁrst
important results of descriptive set theory” [52], Suslin generalized Cantor’s
solution of the continuum problem from closed sets to analytic sets, that is,
projections of closed sets (Σ1
1 sets). Indeed, he showed that every uncountable
analytic set contains a nonempty perfect set, as Cantor had established for
closed sets. Further generalization of this property to sets whose deﬁnitional
complexity is greater, even to co-analytic sets, is not possible on the basis
of ZFC.
Finite model theory provides a rich collection of phenomena which illus-
trate this paradigm of wresting structural information about concepts from

1.1 Deﬁnability Theory
5
deﬁnability conditions. Let us begin with an example from asymptotic com-
binatorics which touches on topics dealt with in detail in Chaps. 2 and 4. Let
Q be a Boolean query on G. Recall that card(Gn) = 2(
n
2). The density μn of
Q at Gn is deﬁned as follows:
μn(Q) = card(Q ∩Gn) · 2−(
n
2).
The limit density μ(Q) = limn−→∞μn(Q) may or may not exist, depending
on the query Q. For example, if X ⊆N is ﬁnite or coﬁnite, then μ(CardX)
is 0 or 1, respectively, whereas μ(CardX) is undeﬁned if X is inﬁnite and
coinﬁnite. Thus, deﬁnability in Lω1ω does not guarantee that a query has a
limit density. Indeed, for every graph G ∈G, the query
IsomG
the set of graphs isomorphic to G
is deﬁnable by a single ﬁrst-order sentence ιG; for example, the graph G with
V G = {1, 2} and EG = {⟨1, 2⟩, ⟨2, 1⟩} is deﬁned, up to isomorphism, by the
ﬁrst-order sentence
κ2 ∧∀x∀y(Exy ↔x ̸= y).
It follows that for each query Q, the Lω1ω sentence

G∈Q
ιG
deﬁnes Q. Thus, no information ﬂows from the fact that a query is Lω1ω-
deﬁnable, in particular, no information about the limit density of Conn is
forthcoming from its deﬁnability in Lω1ω. (Note that the expressive power of
Lω1ω is limited on the collection of all ﬁnite and inﬁnite structures; indeed,
from cardinality considerations, there is an ordinal α such that the isomor-
phism type of ⟨α, <⟩cannot be characterized by a sentence of Lω1ω.) Perhaps
we can ﬁnd another source for such information.
Let us consider the query Diam2. How can we compute its density at
Gn? It will be useful to think of this in probabilistic terms. The density of a
query Q at Gn is just the probability of the event Q ∩Gn with respect to the
uniform measure on Gn, that is, the measure u with u({G}) = 2−(
n
2), for each
G ∈Gn. The measure u may be thought of as follows: for each pair of vertices
1 ≤i < j ≤n, we ﬂip a fair coin to determine whether or not there is an edge
between i and j. This point of view facilitates the computation of a useful
approximation to the density of Diam2. For a ﬁxed pair of distinct vertices i
and j, the probability that a distinct vertex k is a neighbor of both i and j is
1/4.Therefore, the probability that none of the n −2 vertices distinct from i
and j is a neighbor of them both is (3/4)(n−2). It is now easy to see that the
probability that some pair of vertices lacks a common neighbor is bounded by
n
2

· (3/4)(n−2). It follows at once that
μn(Diam2) ≥1 −
n
2

·
3
4
(n−2)
.

6
1 Unifying Themes in Finite Model Theory
But,
lim
n→∞
n
2

·
3
4
(n−2)
= 0.
Therefore, μ(Diam2) = 1. Note that Diam2 ⊆Conn (cast logically, δ2 implies
γ), and thus, μ(Conn) = 1. We shall see that this is no isolated phenomenon,
but rather one instance of a beautiful dichotomy revealed by deﬁnability the-
ory.
As observed above, there are continuum-many queries whose limit den-
sity is undeﬁned; moreover, it is not hard to see that for every real number
r ∈[0, 1], there is a query with limit density r. A noteworthy dichotomy
is enshrined in the following deﬁnition. A logic L satisﬁes the 0–1 law with
respect to the uniform measure on G if and only if, for all L-deﬁnable queries
Q,
μ(Q) = 0 or μ(Q) = 1.
A 0–1 law codiﬁes important structural information about L-deﬁnable queries
and provides a useful tool for establishing that speciﬁc queries are not L-
deﬁnable; for example, none of the queries CardX, for X inﬁnite and coinﬁnite,
is L-deﬁnable if L satisﬁes the 0–1 law. It is remarkable that some natural
logics satisfy the 0–1 law. The ﬁrst such result is due to Glebskii et al. [28] and,
independently, to Fagin [26], who established that ﬁrst-order logic satisﬁes the
0–1 law with respect to the uniform measure. A brief look at an argument for
this result will be instructive.
The query Diam2 is an extension property – it requires that every pair
of vertices share a common neighbor. A generalization of this is the (m, n)-
extension property: this requires that for every pair of disjoint sets of vertices
{x1, . . . , xm} and {y1, . . . , yn}, there is a vertex z which is a neighbor of all
the xi and none of the yj. It is easy to see that this condition is expressible
by a ﬁrst-order sentence ηm,n (with m+n+1 variables), and that, just as the
limit density of Diam2 is 1, so too μ(ηm,n[G]) = 1, for all m, n with m+n > 0.
Let ηk be the conjunction ηm,n with k = m + n + 1. Each ηk is a ﬁrst-order
sentence with k variables expressing a query with limit density 1; moreover,
for all l ≤k, ηk implies ηl. Therefore, by the Compactness Theorem for ﬁrst-
order logic, the set of sentences Γ = {ηk | k > 1} is consistent. To complete
the argument, it suﬃces to show that for every ﬁrst-order sentence ϕ, there
is a k such that ηk implies ϕ, or ηk implies ¬ϕ; indeed, if ηk implies ϕ, then
μ(ϕ[G]) = 1, and if ηk implies ¬ϕ, then μ(ϕ[G]) = 0. Now, Γ has no ﬁnite
models, and is ℵ0-categorical, that is, any two countable models of Γ are
isomorphic (the back-and-forth argument, used by Cantor to prove that the
rational numbers are, up to isomorphism, the unique countable dense linear
order without endpoints, may be deployed here; compare Chap. 4). It follows
at once, via the L¨owenheim–Skolem Theorem, that Γ axiomatizes a complete
ﬁrst-order theory. From this, another application of the Compactness Theorem
for ﬁrst-order logic yields the conclusion that for every ﬁrst-order sentence ϕ,
there is a k such that ηk implies ϕ, or ηk implies ¬ϕ. Can we say, for a

1.1 Deﬁnability Theory
7
given ﬁrst-order sentence ϕ, how large a k is required? Kolaitis and Vardi [48]
showed that the answer to this question leads to a signiﬁcant extension of the
0–1 law to a rich fragment of inﬁnitary logic.
1.1.3 Logics with Finitely Many Variables
For each k ≥1, FOk is the fragment of ﬁrst-order logic consisting of exactly
those formulas all of whose variables, both free and bound, are among
x1, . . . , xk. To understand the eﬀect of this restriction, it is useful to observe
that variables may be reused within such sentences, so that, for example, the
queries Diamk are all FO3-deﬁnable. Here is a sentence of FO3 that deﬁnes
Diam3:
∀x1∀x2( x1 = x2 ∨Ex1x2∨
∃x3(Ex1x3 ∧Ex3x2)∨
∃x3(Ex1x3 ∧∃x1(Ex3x1 ∧Ex1x2))).
We have already noted that the logic Lω1ω is too powerful to be of interest
in the context of ﬁnite model theory, since every query is deﬁnable in this logic.
The logic Lk
ω1ω is the fragment of Lω1ω consisting of exactly those formulas
all of whose variables, both free and bound, are among x1, . . . , xk; Lω
ω1ω =

k Lk
ω1ω. In light of the FO3-deﬁnability of Diamk, observe that Conn is
L3
ω1ω−deﬁnable. Indeed, as discussed in Chap. 2, all queries deﬁnable in the
ﬁxed-point logics LFP, IFP, and PFP, which provide means for deﬁnition of
relations by recursion, for example the transitive closure of the edge relation,
are Lω
ω1ω-deﬁnable (note that, in general, these inclusions fail on collections
of ﬁnite and inﬁnite structures; for example, the notion of well-foundedness is
LFP-deﬁnable on the class of all directed graphs, but is not even deﬁnable in
the powerful inﬁnitary logic L∞ω discussed below).
Kolaitis and Vardi established that the 0–1 law holds for Lω
ω1ω with respect
to the uniform measures on Gn. In particular, they showed that for every
k > 1, ηk axiomatizes a complete Lk
ω1ω theory. Thus, even though Lω
ω1ω
has expressive power suﬃcient to encompass various forms of recursion, it
retains some of the structural simplicity of ﬁrst-order logic; indeed, every
Lω
ω1ω-deﬁnable query or its complement is implied by a ﬁrst-order deﬁnable
query of limit density 1 (the analogy with Suslin’s generalization of the the-
orem of Cantor mentioned above is irresistible). This result gave a coherent
explanation for earlier work on 0–1 laws for ﬁxed-point logics (see [14, 47]),
and thereby highlighted the important role that ﬁnite-variable logics can play
in deﬁnability theory over ﬁnite structures. Hella, Kolaitis, and Luosto [41]
further illuminated the situation by showing that FO and Lω
ω1ω are almost
everywhere equivalent with respect to the uniform measure, that is, there is a
set C ⊆G of limit density one such that FO and Lω
ω1ω deﬁne exactly the same
collection of queries over C (even including non-Boolean queries). Dawar [22],
Grohe [33], and Otto [54] are valuable sources of information about the ﬁnite
model theory of ﬁnite-variable logics. The following chapters oﬀer many other

8
1 Unifying Themes in Finite Model Theory
compelling illustrations of the use of deﬁnability theory to yield insight into a
wide range of mathematical and computational phenomena. Before exploring
some of these examples, let us look at some other important notions from
deﬁnability theory which receive extended treatment in Chap. 2.
1.1.4 Distinguishing Structures: L-Equivalence and Comparison
Games
One approach to the question whether a query Q is deﬁnable in a logic L is to
ask whether Q distinguishes between graphs which are indistinguishable from
the point of view of L. Two graphs G and H are L-equivalent (G ≡L H),
that is, indistinguishable from the point of view of L, if and only if, for every
L-deﬁnable query Q,
G ∈Q ⇐⇒H ∈Q.
Clearly, a query Q must be closed under L-equivalence if it is L-deﬁnable.
When L is ﬁrst-order logic, L-equivalence is the notion of elementary equiv-
alence familiar from classical model theory. The classiﬁcation of inﬁnite struc-
tures up to elementary equivalence plays a central role in classical model
theory and in its applications to algebra and analysis. On the other hand,
as observed above, elementary equivalence coincides with isomorphism on G
(and on the class of ﬁnite structures in general), so the foregoing necessary
condition is deprived of direct application to deﬁnability over G with respect
to any logic extending FO. This suggests that analysis of L-equivalence for
logics L weaker than, or orthogonal to, ﬁrst-order logic may be of paramount
importance in the context of ﬁnite model theory. Indeed, this is the case. Let
us approach the matter from the point of view of combinatorial comparison
games between graphs.
Suppose we want to compare (ﬁnite or countably inﬁnite) graphs G and
H with the object of determining whether or not they are isomorphic. One
way of doing so (inspired by the celebrated Cantor “back-and-forth” argu-
ment mentioned above) would be to play the following game. The game has
two players, Spoiler and Duplicator; the equipment for the game consists of
“boards” corresponding to the graphs G and H and pebbles a1, a2, . . . and
b1, b2, . . . . The game is organized into rounds r1, r2, . . . . At each round ri
the Spoiler plays ﬁrst and picks one of the pair of pebbles ai or bi to play
onto a vertex of G or H, respectively; the Duplicator then plays the remain-
ing pebble of the pair onto a vertex of the structure into which the Spoiler
did not play. This completes the round. Let vi (and wi) be the vertex of G
(and of H, respectively) pebbled at round i, let Gi and Hi be the subgraphs
of G and H induced by {v1, . . . , vi} and {w1, . . . , wi}, respectively, and let
Ri = {⟨vj, wj⟩| 1 ≤j ≤i}. The Duplicator loses the game at round ri if
the relation Ri fails to be the graph of an isomorphism from Gi onto Hi. The
Duplicator wins the game if she does not lose at any round. The Duplicator
has a winning strategy for the game if she has a method of play which results

1.1 Deﬁnability Theory
9
in a win for her no matter how the Spoiler plays. In this case, we say that G
is partially isomorphic to H (G ∼=p H).
It is easy to see that the Duplicator has a winning strategy for this game
played on ﬁnite or countably inﬁnite graphs G and H if and only if G is
isomorphic to H. Indeed, if I is an isomorphism from G onto H, and the
Spoiler pebbles the vertex v in G at some round, then the Duplicator will
guarantee a win by pebbling I(v) in H (and similarly, if the Spoiler plays
onto w in H, then the Duplicator answers by playing onto I−1(w) in G).
On the other hand, suppose the Duplicator has a winning strategy for the
game played on G and H. Then, she can win against the following strategy
of Spoiler. The Spoiler can enumerate the vertices of G as s0, s1, . . . and the
vertices of H as t0, t1, . . . . Now the Spoiler plays according to the following
strategy. For i ≥0, at round r2i+1 he places the pebble a2i+1 on si and at
round r2i+2 he places the pebble b2i+2 on ti. The Duplicator now answers
the Spoiler’s moves according to her winning strategy. It follows at once that
the relation R = 
i∈N Ri is the graph of an isomorphism from G onto H.
So, if G and H are countable, and G ∼=p H, then G ∼= H. Carol Karp [46]
established an interesting connection between partial isomorphism and logical
deﬁnability: arbitrary graphs G and H are partially isomorphic if and only
if they are L∞ω-equivalent (L∞ω strengthens Lω1ω by allowing conjunctions
over arbitrary, not necessarily countable, sets of formulas).
Various modiﬁcations of this game, which deprive the players of some
of their access to resources, or alter the winning condition, or add rules that
restrict legitimate play, lead to useful characterizations of equivalence for much
weaker languages. Let us consider some examples of these.
First, we might restrict the number of pebble pairs that are available for
the game, and allow players to replay pebbles that they have played earlier
in the game. If the Duplicator has a winning strategy for the foregoing game
played on G and H when the equipment consists of only k pairs of pebbles, we
say that G is k-partially isomorphic to H (G ∼=k
p H). This variant is discussed
at length in Chap. 2 where a proof sketch of Barwise’s result [9] that for all
G and H, G ∼=k
p H if and only if G is Lk
∞ω-equivalent to H is presented. We
have already seen one application of this result to deﬁnability over G: it is
easy to see that for all G, H ∈G, if G |= ηk and H |= ηk, then G is k-partially
isomorphic to H; it follows at once from Barwise’s result that for every Lk
∞ω
sentence ϕ, ηk implies ϕ, or ηk implies ¬ϕ, which is the key step in Kolaitis
and Vardi’s proof of the 0–1 law for Lk
∞ω.
Second, we might restrict the length of play, so the Duplicator need only
successfully respond to the Spoiler’s moves through some ﬁxed ﬁnite number
n of rounds in order to win. This is called the n-round Ehrenfeucht–Fra¨ıss´e
(E–F) game. As discussed in Chap. 2, these games give a characterization of
deﬁnability in a hierarchy of fragments of ﬁrst-order logic; in particular, the
Duplicator has a winning strategy for the n-round E–F game played on G
and H if and only if G and H are FOn-equivalent, where FOn is the frag-
ment of ﬁrst-order logic consisting of all sentences of quantiﬁer rank bounded

10
1 Unifying Themes in Finite Model Theory
by n. This is the key to using logical indistinguishability to establish that
queries are not ﬁrst-order deﬁnable over G despite the fact that ﬁrst-order
indistinguishability coincides with isomorphism over G. In order to show that
a query Q is not ﬁrst-order deﬁnable, it suﬃces to show that for every n there
are FOn-equivalent G and H with G ∈Q and H ̸∈Q. Chapter 2 includes
several examples of this technique, among them the queries Conn and Colork
mentioned earlier.
Third, we might require that beyond the ﬁrst round, the Spoiler play onto
a vertex that is adjacent to some vertex which has been pebbled at an ear-
lier round. The single-pebble variant of the game thus restricted characterizes
the relation of bisimilarity between vertex-colored directed graphs. Johan van
Benthem ﬁrst introduced this relation and recognized its signiﬁcance in con-
nection with the study of Kripke models for modal logic [11, 12]; the notion
was rediscovered in the context of analyzing the “behavioral equivalence” of
transition systems [42, 57]. Chapter 7 elucidates the fundamental importance
of bisimilarity invariance in explaining various nice features of modal logic.
Fourth, we might require that the Spoiler always play onto a vertex of G.
In this case, by virtue of the asymmetry of play, a win for Duplicator in the
resulting game no longer characterizes an equivalence relation between graphs,
but rather a preorder. In particular, the Duplicator has a winning strategy for
this variant of the game if and only if every existential sentence of L∞ω which
is true in G is also true in H. If, in addition, we relax the winning condition
to require only that at the end of each round ri the relation Ri is the graph of
a homomorphism from G to H, then the Duplicator has a winning strategy if
and only if every positive existential sentence of L∞ω that is true in G is also
true in H. This last variant, in combination with the resource restriction on
the number of pebbles discussed above, characterizes the positive existential
fragment of Lω
∞ω. This fragment is of particular interest from the perspective
of database theory, since it suﬃces to express every Datalog-deﬁnable query;
several applications of this deﬁnability result are discussed in Chaps. 2 and 6.
1.1.5 Random Graphs and 0–1 Laws
Joel Spencer’s chapter, “Logic and random structures” (Chap. 4), gives an
exposition of a 0–1 law for ﬁrst-order logic he and Saharon Shelah discov-
ered [62], and related phenomena in the theory of random graphs. From the
perspective of this theory, the uniform distribution on ﬁnite graphs consid-
ered above is an instance of a far more general scenario developed by Erd¨os
and Renyi in [24]. From this perspective, one considers a sequence of ﬁnite
probability spaces (Gn, μp
n), where the measure μp
n is determined by an “edge
probability” pn which is a function of n; the uniform distribution is just the
special case where pn = .5 for all n. Let us write μp(Q) for the limit probability
of the query Q with respect to the sequence of measures μp
n, that is,
μp(Q) =
lim
n−→∞μp
n(Q ∩Gn).

1.1 Deﬁnability Theory
11
In this context, combinatorists have discovered that threshold phenomena
arise, that is, there are queries Q and functions p with the property that for
all q, if q ≪p, then μq(Q) = 0, and if p ≪q, then μq(Q) = 1. (Here, p ≪q
if and only if limn−→∞pn/qn = 0.) One class of cases which arose naturally
in the study of threshold phenomena is the edge probabilities p(α)n = n−α,
for some real α ∈(0, 1). Spencer observed that among the many queries
analyzed by graph theorists, none possessed a threshold of the form n−α for
α ∈(0, 1) and irrational. Shelah and Spencer discovered a deﬁnability result
that provided an explanation for these threshold phenomena. They showed
that for all α ∈(0, 1), if α is irrational, then ﬁrst-order logic satisﬁes the 0–1
law with respect to (Gn, μp(α)
n
), that is, for every ﬁrst-order deﬁnable query
Q,
μp(α)(Q) = 0 or μp(α)(Q) = 1.
This is an outstanding example of how deﬁnability considerations can provide
insight through systematization of apparently disparate combinatorial facts.
Further investigations of the complete theories T α = {ϕ ∈FO | μp(α)(ϕ[G]) =
1} have revealed interesting connections with classical model theory (see [8,
51]). This aspect of deﬁnability theory has also been prominent in computer
science, as well as in combinatorics.
1.1.6 Constraint Satisfaction Problems
In Chap. 6 of the volume, “A logical approach to constraint satisfaction”,
Kolaitis and Vardi survey some applications of deﬁnability theory to the study
of constraint satisfaction problems, a subject that is important in several
areas of computer science, including artiﬁcial intelligence, database theory,
and operations research. For example, the k-colorability problem for graphs
may be formulated as a constraint satisfaction problem. Given a graph (V, E),
we may think of its vertices as variables. We ask whether there is an assignment
of k colors c1, . . . , ck, one to each variable, so as to satisfy the constraint that
adjacent variables are assigned distinct colors. Feder and Vardi [27] made
the following important observation that advanced the understanding of the
computational complexity of constraint satisfaction problems: they noted that
all such problems may be formulated as homomorphism problems on suitable
relational structures (in general, these relational structures will not be graphs).
For a simple example using graphs, recall that a homomorphism h from G =
(V, E) to H = (V ′, E′) is a map satisfying the condition
Eab ⇒E′h(a)h(b), for all a, b ∈V.
A graph G is k-colorable if and only if there is a homomorphism from G into
Kk, the complete graph on k vertices (thought of as the colors c1, . . . , ck) –
the constraint that adjacent “variables” are assigned distinct colors by any
homomorphism is enforced by the irreﬂexivity of the edge relation in Kk.

12
1 Unifying Themes in Finite Model Theory
In general, a constraint satisfaction problem can be formulated as a homo-
morphism problem: given two classes of relational structures A and B, the
constraint satisfaction problem CSP(A, B) asks, for each pair of structures
A ∈A and B ∈B, whether or not there is a homomorphism from A to B.
Insofar as the homomorphism problem in general is NP-complete, the search
for “islands of tractability”, that is, collections of structures A and B such
that CSP(A, B) can be computed in polynomial time, is of interest.
Two cases which have been studied intensively are nonuniform and uniform
constraint satisfaction problems. The case in which B is a singleton, {B},
and A is U, the collection of all ﬁnite structures, is called the non-uniform
constraint satisfaction problem with template B – CSP(B) for short; on the
other hand, the constraint problem CSP(A, U) is called the uniform constraint
satisfaction problem with input A. To illustrate this terminology by the above
example, for each k, the k-colorability problem is the nonuniform constraint
satisfaction problem CSP(Kk). This is a suggestive example. Recall that the
2-colorability problem is solvable in polynomial time, while the k-colorability
problem is NP-complete, for each k ≥3. Recall too (see [50]) that if P ̸= NP,
then there are problems in NP which are neither NP-complete nor in P. Could
it be that nonuniform constraint satisfaction problems are so special that they
would exhibit the following remarkable dichotomy?
F–V
For every template B, CSP(B) is either in P or is NP-complete.
This is the well-known Feder–Vardi Dichotomy Conjecture, which was articu-
lated in [27] as a generalization of a theorem of Schaefer [61] that established
the dichotomy for the case of templates B with a two-element domain (called
Boolean templates). Indeed, Schaefer showed that it can be decided in poly-
nomial time whether or not CSP(B) is NP-complete for any Boolean template
B. Subsequent investigations have established that the Dichotomy Conjecture
holds for other classes of templates. Generalizing the example of k-colorability,
Hell and Neˇsetˇril [40] showed that for all templates B which are undirected
graphs, if B is bipartite, then CSP(B) is in P, while if B is not bipartite,
then CSP(B) is NP-complete. Building on a group-theoretic approach initi-
ated in [27], Bulatov extended Schaefer’s dichotomy to CSP(B) for all three
element templates B [17]. In their chapter, Kolaitis and Vardi explore deﬁn-
ability frameworks for understanding some of the known results concerning
the conjectured dichotomy. They also show how deﬁnability theory illuminates
the study of uniform constraint satisfaction problems.
1.2 Descriptive Complexity
In the preceding section, we have traced the theme of deﬁnability as a source
of structural information as it arises in several settings throughout the vol-
ume. Let us turn our attention to another major theme, the relation between
deﬁnability and computational complexity. This is the focus of Erich Gr¨adel’s
chapter on “Finite model theory and descriptive complexity” (Chap. 3).

1.2 Descriptive Complexity
13
1.2.1 Satisfaction
Let us look again at the deﬁnition of a query Q being deﬁnable by a sentence
ϕ of a logic L :
ϕ deﬁnes Q if and only if ∀G ∈G(G |=L ϕ ⇔G ∈Q).
If we think of queries as combinatorial problems, it is natural to ask whether
we can obtain information about the computational complexity of a problem
from the fact that it is deﬁnable in one language or another. This question
focuses attention on the complexity of the satisfaction relation itself, (also
known as the model-checking problem). Vardi [68] formulated three notions
of complexity associated with the satisfaction relation for L (relative to a
collection of ﬁnite structures C). The ﬁrst, called the combined complexity of
L is just the complexity of the satisfaction relation itself, viewed as a binary
relation on strings encoding structures in C on the one hand, and sentences of
L on the other. The second, called the data complexity of L, is the complexity
of the decision problems associated with L-deﬁnable queries Q over C. The
third, called the expression complexity of L, is the complexity of the decision
problems associated with the L-theories ThL(G) of ﬁnite structures G in C,
where
ThL(G) = {ϕ ∈L | G |=L ϕ}.
The study of these notions is rooted in the great developments in logic in
the 1930s. In the ﬁrst work which rigorously deﬁned the notion of satisfac-
tion, “On the concept of truth in formalized languages,” [65], Tarski famously
resolved a basic question concerning expression complexity in the context of
inﬁnite structures, and in descriptive terms at that: he showed that the ﬁrst-
order theory of the structure N = ⟨N, 0, +, ×⟩is not arithmetically deﬁnable,
that is, there is no ﬁrst-order formula θ(x) in the language of arithmetic such
that for all i ∈N,
N |= ϕ(i) ⇔N |= χi,
where χi is the sentence in the ﬁrst-order language of arithmetic with
code i. Subsequent work by Kleene and Post revealed the intimate connec-
tion between arithmetic deﬁnability and complexity as measured by Turing
degrees, thereby transforming Tarski’s undeﬁnability result into a lower bound
on recursion-theoretic complexity. Moreover, Tarski’s deﬁnition of satisfaction
itself exhibited that the ﬁrst-order theory of N could be deﬁned by both an
existential and a universal sentence in the second-order language of arith-
metic. Again, later work by Kleene yielded a “computational” interpretation
of this descriptive result – the ﬁrst-order theory of N is hyperarithmetical.
Chapter 3 presents a comprehensive overview of results concerning com-
bined, data, and expression complexity in the context of ﬁnite model theory.
One theme that runs through the chapter is the role of combinatorial games
in analyzing the combined complexity of many logics, among them ﬁrst-order

14
1 Unifying Themes in Finite Model Theory
logic and various ﬁxed-point logics, including the modal μ-calculus, a natural
ﬁxed-point extension of propositional modal logic with applications ranging
from hardware veriﬁcation to analysis of hybrid systems. The chapter begins
with an incisive analysis of the complexity of ﬁrst-order logic using the tech-
nique of model-checking games G(A, ϕ) in which a Veriﬁer and a Falsiﬁer
compete, and Veriﬁer has a winning strategy just in case A |= ϕ. In the case
of ﬁrst-order logic, the model-checking games are positional and have a ﬁnite
game graph. The strategy problem for such games in general, “does Player
I have a winning strategy for the game from position p?”, can be solved in
linear time. Analysis of an alternating algorithm for the ﬁrst-order model-
checking game yields the following information: the combined complexity of
FO is PSPACE-complete, while the combined complexity of FOk is PTIME-
complete – yet another source of interest in the ﬁnite-variable fragments.
Moreover, PSPACE-completeness follows from the fact that the satisﬁability
problem for quantiﬁed Boolean formulas is easily reduced to the ﬁrst-order
theory of the unary structure A = ⟨{0, 1}, {0}⟩, from which it follows at once
that the expression complexity of FO is also PSPACE-complete. On the other
hand, the data complexity of FO is in deterministic LOGSPACE. This gap
between expression complexity and data complexity obtains for many well-
known logics.
When we turn from ﬁrst-order to second-order logic, the situation is
quite diﬀerent. For example, the data complexity of the monadic existen-
tial fragment of second-order logic (mon-ESO) is NP-complete, that is, every
mon-ESO-deﬁnable query is in NP, and some such queries, for example, 3-
colorability, are NP-hard. On the other hand, as discussed in Chap. 2, there
are PTIME queries on G, for example, connectivity, which are not mon-ESO-
deﬁnable. This suggests that deﬁnability theory could be used to illuminate
diﬀerences in complexity which are not easily characterized in terms of com-
putational resources – a good example of this is the result of Ajtai and Fagin
that undirected reachability is mon-ESO-deﬁnable, while directed reachability
is not [4] (recently, Reingold has established that undirected reachability is in
DLOGSPACE, whereas directed reachability is a paradigmatic NLOGSPACE-
complete problem [58] – separating these two complexity classes remains an
outstanding open question). On the other hand, it is also interesting when
deﬁnability of queries in well-understood logics coincides with resource com-
plexity classes, from at least two points of view: ﬁrst, the logical language
could then be used as a transparent speciﬁcation language for queries in the
class, and second, methods of logic could be deployed in complexity-theoretic
investigations.
A logic L captures a complexity class K on a collection of structures C if
and only if, for every query Q over C,
Q is L-deﬁnable ⇔Q ∈K.
In 1970, Fagin [25] showed that the existential fragment of second-order logic
captures the complexity class NP over the class of all ﬁnite structures (see

1.2 Descriptive Complexity
15
Chap. 3 for discussion and a proof). Fagin’s result launched an active search
for characterizations of other complexity classes in logical terms. Since the
natural speciﬁcation of many combinatorial problems is given by an existen-
tial second-order sentence, Fagin’s Theorem provides a convenient tool for
recognizing that problems are in NP. From the point of view of speciﬁcation
languages for database queries, it would be most useful to ﬁnd logics that
capture complexity classes below NP. Though Fagin’s Theorem extends easily
to show that full second-order logic captures the polynomial-time hierarchy,
PH, over arbitrary ﬁnite structures, thus far no logic has been identiﬁed that
captures a complexity class presumed to be strictly contained in NP over the
collection of all ﬁnite structures. On the other hand, much has been learned
about logics that capture such complexity classes over particular collections
of ﬁnite structures. Indeed, the ﬁrst capturing result was of just this kind.
In 1960, B¨uchi [16] showed that mon-ESO captures the collection of regular
languages over the class of string structures, that is, structures of the form
⟨[n], S, P⟩, where S is the usual successor relation on [n] and P is a ﬁnite
sequence of unary predicates; it is worth noting that over string structures,
all of monadic second-order logic is no more expressive than its existential
fragment (see [63] and [32] for extended treatments of connections between
logic and automata theory). Chapter 3 shows how other fragments of second-
order logic yield characterizations of complexity classes over ordered ﬁnite
structures, that is, structures which interpret a distinguished binary relation
as a linear order on the universe. These include Gr¨adel’s results that second-
order Horn logic (and its existential fragment) captures polynomial time on
ordered ﬁnite structures and that second-order Krom logic (and its existen-
tial fragment) captures nondeterministic logarithmic space on ordered ﬁnite
structures.
An especially active area of investigation in descriptive complexity theory
is the analysis of logics with ﬁxed-point operators that allow for deﬁning
queries by induction. The clariﬁcation of the nature of inductive deﬁnitions
was a task undertaken by the pioneers of modern logic. Indeed, among Frege’s
great contributions in Die Grundlagen der Arithmetik was the analysis of one
of the simplest ﬁxed-point operators, which allows deﬁnition of the ancestral of
a relation (now called transitive closure), in the universal fragment of second-
order logic: a is an E-ancestor of b (tcxy(Exy)ab) if and only if
∀R((∀x∀y(Exy →Rxy) ∧∀z((Rxy ∧Ezx) →Rzy)) →Rab).
From the point of view of descriptive complexity, transitive closures appear to
be quite weak compared with universal second-order quantiﬁcation. Immer-
man [43] showed that the extension of ﬁrst-order logic with the transitive-
closure operator (TC) captures NLOGSPACE over the class of ordered ﬁnite
structures, while, by Fagin’s Theorem, the universal fragment of second-
order logic captures co-NP, which has been conjectured to properly include
NLOGSPACE. If transitive closure is applied only to single-valued relations,
one obtains, as an extension of ﬁrst-order logic, deterministic transitive-closure

16
1 Unifying Themes in Finite Model Theory
logic (DTC), which captures DLOGSPACE over the class of ordered ﬁnite
structures [43]. In this instance, the descriptive separation, DTC ̸= TC,
over the class of all ﬁnite structures was established by Gr¨adel and McColm
[31], whereas the separation on ordered ﬁnite structures is equivalent to
the unresolved complexity-theoretic question: is DLOGSPACE distinct from
NLOGSPACE?
Richer ﬁxed-point logics yield characterizations of PTIME and PSPACE
over ordered ﬁnite structures. Chapters 2 and 3 contain detailed developments
of logical and complexity-theoretic results concerning the least ﬁxed-point
(LFP), inﬂationary ﬁxed-point (IFP), and partial ﬁxed-point (PFP) exten-
sions of ﬁrst-order logic, including proofs that LFP captures PTIME over
ordered ﬁnite structures [43, 68], that PFP captures PSPACE over ordered
ﬁnite structures [1, 68], and that LFP = IFP over arbitrary ﬁnite struc-
tures [39] (indeed, Kreutzer established that LFP = IFP over arbitrary, not
just ﬁnite, structures [49]). In contrast to the aforementioned descriptive sepa-
ration of TC and DTC, and in spite of the fact that LFP and PFP do not cap-
ture PTIME and PSPACE over ﬁnite graphs without an ordering, Abiteboul
and Vianu [2] established that there are PFP-deﬁnable queries on ﬁnite graphs
which are not LFP-deﬁnable, if and only if PSPACE is distinct from PTIME,
a striking result which solved an open problem posed by Chandra [20].
As noted earlier, the ﬁxed-point logics LFP, IFP, and PFP are all fragments
of Lω
∞ω with respect to deﬁnability over the class of ﬁnite structures, and
consequently they lack the means to express any nontrivial cardinality queries
on ﬁnite graphs. The extension of IFP with counting quantiﬁers (IFP+C)
yields a logic that captures PTIME over wider classes of ﬁnite structures;
for example, Grohe established that IFP+C captures PTIME on the class of
planar graphs (in fact, on any class of structures whose Gaifman graphs are
of bounded genus) [34, 35] and on any class of structures of bounded tree-
width [36]. On the other hand, Cai, F¨urer, and Immerman established that
IFP+C does not capture PTIME over the class of all ﬁnite graphs [18]. It is
natural to ask: is there a logic that captures PTIME on the class of all ﬁnite
graphs?
1.2.2 What Is a Logic for PTIME?
In order to sensibly address the preceding question, we need to reﬁne the
notion of a logic capturing a complexity class – otherwise, for all we have said
about logics in the abstract, we might be tempted to answer that the collec-
tion of PTIME queries itself is a logic that captures PTIME. Chandra and
Harel [19] introduced the notion of an eﬀectively enumerable query complexity
class and posed the question of whether the PTIME-computable queries are
eﬀectively enumerable; Gurevich [38] introduced the closely related notion of
a logic for PTIME (see also [23] and [53] for further discussion of logics for
complexity classes). In order to explain this notion, we need to focus closely
on the satisfaction relation. Recall that a logic L is a pair consisting of a set

1.2 Descriptive Complexity
17
of sentences SL and a satisfaction relation |=L . We say that L is uniformly
contained in PTIME on a collection of ﬁnite structures C if and only if SL and
|=L are decidable, and there are eﬀectively computable functions m and t such
that for every ϕ ∈SL, m(ϕ) is a deterministic Turing machine which decides
Q(ϕ) ∩C in time nt(ϕ). Note that SO-Horn, LFP, and IFP are uniformly con-
tained in PTIME on the collection of all ﬁnite structures. A logic L eﬀectively
captures PTIME on C if and only if L is uniformly contained in PTIME on C
and every PTIME query on C is L-deﬁnable. In this sense, a logic for PTIME
embodies a query language which can be compiled into machine code with
explicit bounds on running time, and which expresses every PTIME query.
(The notion of “eﬀectively capturing” can easily be extended to other resource
complexity classes; for example, in the obvious sense, Fagin’s Theorem estab-
lishes that ESO eﬀectively captures NP.)
Insofar as we have placed only quite abstract requirements on a logic L
eﬀectively capturing PTIME, the question naturally arises whether the col-
lection Tp of nk-clocked Turing machines, for all k ∈N, itself might not be
such a logic, where the associated satisfaction relation is just acceptance. The
problem with this suggestion is that the “queries” deﬁnable in this logic are
not necessarily queries, that is, they are not in general isomorphism-invariant.
One way of overcoming this obstacle would be to preprocess input graphs so
that a ﬁxed representative of each isomorphism type of structure would be
presented to a clocked machine. Given an equivalence relation ∼on G, we say
f : G −→G is a ∼-canon if and only if, for all G, H ∈G, G ∼f(G) and
if G ∼H, then f(G) = f(H). Given a Turing machine M which computes
an isomorphism canon, we could “compose” M with each of the machines
M ′ ∈Tp and thereby arrive at a logic which captures PTIME on G; if, more-
over, M ran in polynomial time in the length of its input, this would yield a
logic that eﬀectively captures PTIME on G. The existence of a polynomial-
time-computable isomorphism canon for graphs is a major open problem in
complexity theory. It is well known that if P = NP, then there is a polynomial-
time-computable isomorphism canon for ﬁnite graphs, though it is unknown
whether the existence of such a canon would imply that P = NP [5]. It follows
at once that if there is no logic that eﬀectively captures PTIME on G, then
there is no polynomial-time-computable isomorphism canon for graphs, and
hence P ̸= NP. (Indeed, if P = NP, then existential second-order logic is a
logic for P. This follows from Fagin’s Theorem and the “polynomially uni-
form” completeness of typical NP-complete problems.) On the other hand, if
there is a polynomial-time-computable ∼-canon for a class of graphs C, then
there is a logic L that eﬀectively captures ∼-invariant PTIME on C, that is, a
logic which is uniformly contained in PTIME and expresses all and only the
PTIME-computable queries on C which are closed under ∼. In some cases,
such as Grohe’s capturing results for IFP+C cited above, there is a “familiar”
logic that does the capturing. Another example of this phenomenon is Otto’s
result [55] that bisimulation-invariant PTIME is uniformly captured by the
multidimensional μ-calculus (see Chap. 3 and references there).

18
1 Unifying Themes in Finite Model Theory
1.3 Finite Model Theory and Inﬁnite Structures
The concluding section of Chap. 3 surveys several areas where the perspective
of descriptive complexity theory has been extended to the study of certain
classes of inﬁnite structures. Such extension requires, at minimum, that the
structures in question be ﬁnitely presentable and that the satisfaction relation
be computable when restricted to the given setting (structures and language).
One active research direction here is the study of automatic structures, that is,
structures whose universe and relations are regular sets of strings. Automatic
structures have nice closure properties from the point of view of deﬁnability
theory; for example, all ﬁrst-order-deﬁnable relations on such structures are
regular, and so the expansion of an automatic structure by ﬁrst-order-deﬁnable
relations is itself automatic, a property not shared, for example, by recursively
presented structures.
Another research direction where the point of view of descriptive com-
plexity is extended to inﬁnite structures is the study of metaﬁnite structures,
which were introduced by Gr¨adel and Gurevich in [30]. A paradigmatic exam-
ple of such structures is edge-weighted graphs. Here one has a ﬁnite graph
and a numerical structure, such as the ring Z or the ordered ﬁeld R, and
a function which assigns weights in the numerical structure to edges in the
graph. Such two-sorted structures arise naturally in several areas of com-
puter science, including database theory, optimization theory, and complexity
theory. A hallmark of metaﬁnite model theory is the simplicity of the lan-
guages deployed to describe these hybrid structures. In particular, there is
no quantiﬁcation allowed over the numerical structure, indeed, no variables
which admit assignment from the numerical domain. The only access to the
numerical structure is via weight terms that assign numerical values to tuples
from the nonnumerical sort, and terms which combine these by use of opera-
tions on the numerical universe. Following [30], Chap. 3 shows how the notion
of a generalized spectrum admits two extensions to the context of metaﬁ-
nite structures (one allowing projection of weight functions, in addition to
projection of relations on the ﬁnite structure). In the context of arithmeti-
cal structures (those whose numerical part consists of the standard model of
arithmetic with additional polynomial-time-computable multiset operations)
with “small weights”, the more restricted notion of a generalized spectrum
captures NP, whereas on arithmetical structures in general, the wider notion
captures the class of all recursively enumerable relations. Chapter 3 con-
cludes with a proof of the result, due to Gr¨adel and Meer, that in the case of
metaﬁnite structures whose numerical part is the real ordered ﬁeld extended
with constants for all real numbers, the wide notion of a metaﬁnite spectrum
captures NPR, the collection of nondeterministic polynomial-time-acceptable
relations on the reals in the Blum–Schub–Smale model of computation over the
reals [15].

1.3 Finite Model Theory and Inﬁnite Structures
19
A third area which involves a blend of ﬁnite and classical model the-
ory is the study of “Embedded ﬁnite models and constraint databases”, the
subject of Leonid Libkin’s chapter (Chap. 5). In the context of geographical
information systems, the management of spatio-temporal data, bioinformatics,
and numerous other database application areas, it is useful to look at rela-
tional data over inﬁnite sets which may themselves be endowed with additional
structure. The approach via constraint databases, pioneered by Kanellakis et
al. [45], where, for example, geographical regions are stored as logical formu-
las that deﬁne them, via coordinatization, over the real ordered ﬁeld R or the
real ordered group, has proven to be fruitful. In this context, new deﬁnability
questions arise; for example, can one deﬁne topological connectivity of (deﬁn-
able) spatial regions? As discussed in Chap. 5, the work of Grumbach and
Su [37] revealed that many deﬁnability questions of this kind could be reduced
to deﬁnability questions about embedded ﬁnite structures, that is, ﬁnite struc-
tures whose domain is drawn from some ambient inﬁnite structure such as the
real ordered ﬁeld. For example, if G is a ﬁnite graph whose vertices are real
numbers, then the expansion A = ⟨R, EG⟩of R is an embedded ﬁnite model
with “active domain” the set of nonisolated vertices of G. Now, it can be shown
that there is a ﬁrst-order formula ϕ(x, y) such that the region in R2 deﬁned by
ϕ in A is topologically connected, if and only if G is a connected graph. Thus,
if topological connectivity of deﬁnable planar regions were ﬁrst-order-deﬁnable
in R, then connectivity of embedded ﬁnite graphs would also be deﬁnable over
{⟨R, E⟩| E ⊂ﬁn R2}. This is exactly the point at which embedded ﬁnite model
theory comes into play in oﬀering a variety of techniques to answer deﬁnabil-
ity questions of the latter sort. One of the main thrusts of embedded ﬁnite
model theory is to establish “collapse results”, which reduce questions about
deﬁnability over embedded ﬁnite structures to questions about deﬁnability
over ﬁnite structures. It turns out that general model-theoretic conditions
on the ambient inﬁnite structure are of paramount importance in determin-
ing the extent to which such collapse results obtain. Chapter 5 provides a
detailed account of such phenomena. These phenomena provide considerable
evidence that inﬁnite structures which are well-behaved from the point of
view of deﬁnability theory in the inﬁnite are similarly tame with respect to
embedded ﬁnite structures. For example, Benedikt et al. [10] have shown that
if M is an o-minimal structure and Q is an order-generic query on ﬁnite struc-
tures A embedded in M, which is ﬁrst-order deﬁnable over ⟨M, A⟩, then Q
is ﬁrst-order deﬁnable (with order) over ﬁnite structures A; the real ordered
ﬁeld is a paradigmatic o-minimal structure, and recent work in model theory
has established the o-minimality of various of its extensions [66, 70]. Baldwin
and Benedikt [7] have shown, more generally, that the same collapse obtains
for any M which lacks the independence property, a condition familiar from
stability theory. Chapter 5 reveals deep connections between the independence
property and deﬁnability over embedded ﬁnite models.

20
1 Unifying Themes in Finite Model Theory
1.4 Tame Fragments and Tame Classes
The book concludes with a concise, modern introduction to modal logic,
“Local variations on a loose theme: modal logic and decidability”, by Maarten
Marx and Yde Venema (a comprehensive treatment in this spirit can be found
in [13]). Modal logics have numerous applications to computer science, rang-
ing from speciﬁcation of hybrid systems to knowledge representation, and
these applications rest on the delicate balance between the expressive power of
modal languages and their good algorithmic properties. The chapter provides
an incisive analysis of this balance (other useful discussions include [29, 69]).
Propositional modal languages can be viewed, via the Kripke modeling,
as vehicles for expressing unary queries over labeled transition systems, that
is, structures whose universe consists of a collection of states equipped with
binary “accessibility” relations and unary labels. When viewed in this way, a
propositional modal sentence ϕ, such as
P →2(¬P ∧3P),
can be translated into a ﬁrst-order formula ϕ◦with one free variable,
P(x) →∀y(Rxy →(¬P(y) ∧∃x(Ryx ∧P(x)))),
so that, for any Kripke model M = ⟨U M, RM, P M⟩and any s ∈U M,
M, s ⊩ϕ ⇔M |= ϕ◦[s].
For example, if M is the structure with
U M = {1, 2, 3}, RM = {⟨1, 1⟩, ⟨1, 2⟩, ⟨2, 3⟩, ⟨3, 2⟩}, P M = {1, 3},
then ϕ◦deﬁnes the set {2, 3} in M. It is easy to check that for any basic modal
sentence ϕ, ϕ◦is in the the two-variable fragment of ﬁrst-order logic, and all
quantiﬁers in ϕ◦are relativized to the collection of states directly accessible
from a given state. The collection of translations of modal sentences is called
the modal fragment of ﬁrst-order logic.
Chapter 7 emphasizes that bisimulation invariance is the fundamental
property of the modal fragment of ﬁrst-order logic. As mentioned above, bisim-
ilarity can be characterized in terms of a simple one-pebble comparison game.
Kripke structures M and M ′ with states s ∈M and s′ ∈M ′ are bisimilar if
and only if the Duplicator has a winning strategy in the following game. Ini-
tially, pebbles are placed on the distinguished states s and s′. At each round of
play, the Spoiler chooses one of the pebbles and moves it to a state accessible
from the state on which it lies. The Duplicator must move the other pebble
in like fashion, and to a state which is labeled identically to the state onto
which Spoiler has moved. The game ends with a win for the Spoiler if the
Duplicator cannot thus move at some round. Otherwise, the Duplicator wins
the (perhaps inﬁnite) play of the game.

1.4 Tame Fragments and Tame Classes
21
It is easy to check that every formula in the modal fragment is bisimulation
invariant; that is, if M, s is bisimilar to M ′, s′ then
M |= ϕ◦[s] ⇔M ′ |= ϕ◦[s′],
for every modal sentence ϕ. The authors show that by “unraveling” a Kripke
structure M at a state s one can create a tree model M ′ (that is, ⟨U ′, RM′⟩is a
directed tree) that is bisimilar to M at s (the unraveling consists of collecting
all ﬁnite walks in M starting at s and ordering them by immediate extension).
Thus, any bisimulation-invariant language has the “tree model” property. The
authors refer to this as the looseness property of modal logic, and identify it
as one of the sources of the good algorithmic behavior of modal logics. They
observe that this is not the entire story, and note that modal logics also
exhibit some interesting locality properties that also partly account for the
relatively low complexity of their satisﬁability and model-checking problems.
Indeed, since there are continuum-many bisimulation-invariant queries even
on ﬁnite labeled transition systems, the tree model property could not be the
complete account for the computational tameness of the modal fragment. The
authors identify two locality properties that are important in explaining the
behavior of modal logic. The ﬁrst is related to the Hanf and Gaifman locality
of ﬁrst-order logic as discussed in Chap. 2 (note that modal depth equates to
quantiﬁer depth in the modal fragment); the second is related to the fact that
the modal fragment is contained in FO2.
The connection between bisimilarity invariance and modal deﬁnability is
intimate – Johan van Benthem established [11, 12] a preservation theorem for
the modal fragment: every bisimulation-invariant ﬁrst-order formula is equiv-
alent to a formula in the modal fragment. Eric Rosen [59] showed that this
preservation theorem persists to the class of ﬁnite structures; that is, if a for-
mula of ﬁrst-order logic is preserved under bisimulation over the collection of
ﬁnite Kripke structures, then it is equivalent, over ﬁnite Kripke structures,
to a formula in the modal fragment. This result provides evidence that the
modal fragment is tame not only from an algorithmic point of view, but also
from the point of view of ﬁnite model theory. How so? Several well-known
preservation theorems from classical model theory fail when relativized to
ﬁnite structures. For example, Tait [64] showed that the Lo´s–Tarski existen-
tial preservation theorem does not persist to the class of ﬁnite structures –
there is a ﬁrst-order sentence that is preserved under extensions relative to the
collection of ﬁnite structures, but is not equivalent over ﬁnite structures to an
existential sentence. An even more telling example in the current context is the
failure of a preservation theorem for the two-variable fragment of ﬁrst-order
logic to persist to the class of ﬁnite structures. A query is 2-invariant if and
only if it is closed under L2
∞ω equivalence. Immerman and Kozen [44] showed
that if a query is 2-invariant and ﬁrst-order deﬁnable, then it is expressible
by a sentence of FO2. This result does not persist to the ﬁnite case; for exam-
ple, the collection of ﬁnite linear orderings is 2-invariant and FO3-deﬁnable
with respect to the collection of ﬁnite structures, but is not FO2-deﬁnable

22
1 Unifying Themes in Finite Model Theory
over ﬁnite structures. So the modal fragment is in some sense tamer than
the two-variable fragment with respect to model theory over the class of ﬁnite
structures. Otto [56] has proved a generalization of Rosen’s preservation result
which gives yet more evidence that the tameness of modal ﬁnite model theory
is connected to the relativization of quantiﬁcation in the modal fragment. He
established that any formula of FO2 that is invariant under guarded bisimu-
lations with respect to the class of ﬁnite structures is equivalent, over ﬁnite
structures, to a formula in the guarded fragment of FO2. Chapter 7 explains
how the guarded fragment of ﬁrst-order logic is a natural extension of the
modal fragment and discusses aspects of its good algorithmic behavior. Ross-
man [60] recently established that the homomorphism preservation theorem
persists to ﬁnite structures, that is, if a ﬁrst-order deﬁnable query is closed
under homomorphisms with respect to the class of ﬁnite structures, then it
is equivalent over ﬁnite structures to a positive existential sentence. So, in
the sense to hand, the positive existential fragment of ﬁrst-order logic is also
“tame” for ﬁnite model theory. It is worth noting that some fragments that
are ill-behaved with respect to the collection of all ﬁnite structures may be
tame with respect to interesting subclasses. Though the existential preserva-
tion theorem fails over the collection of all ﬁnite structures, Atserias, Dawar,
and Grohe [6] have shown that it holds with respect to classes of ﬁnite struc-
tures of bounded degree and bounded tree-width. To echo a motto proposed
by Hrushovski (“model theory = geography of tame mathematics” [67]), a
geography of tame fragments and tame classes may yield some insight into
ﬁnite model theory.
Acknowledgments
I am grateful to Phokion G. Kolaitis for many corrections and suggestions
which substantially improved this chapter. This work was supported in part
by NSF grant CCR-9820899. Part of this work was done while I was visit-
ing the Isaac Newton Institute for Mathematical Sciences, during a Special
Programme on Logic and Algorithms.
References
1. S. Abiteboul and V. Vianu. Datalog extensions for database queries and updates.
Journal of Computer and System Sciences, 43:62–124, 1991.
2. S. Abiteboul and V. Vianu. Generic computation and its complexity. In STOC,
pages 209–219. ACM, 1991.
3. J. W. Addison. Tarski’s theory of deﬁnability: common themes in descriptive set
theory, recursive function theory, classical pure logic, and ﬁnite-universe logic.
Annals of Pure and Applied Logic, 126:77–92, 2004.
4. M. Ajtai and R. Fagin. Reachability is harder for directed than for undirected
ﬁnite graphs. Journal of Symbolic Logic, 55:113–150, 1990.

References
23
5. V. Arvind and J. Tor´an. Isomorphism testing: Perspective and open problems.
Bulletin of the EATCS, 86:66–84, 2005.
6. A. Atserias, A. Dawar, and M. Grohe.
Preservation under extensions on
well-behaved ﬁnite structures.
In L. Caires, G. F. Italiano, L. Monteiro,
C. Palamidessi, and M. Yung, editors, ICALP, Lecture Notes in Computer Sci-
ence, volume 3580, pages 1437–1449. Springer, 2005.
7. J. Baldwin and M. Benedikt. Stability theory, permutations of indiscernibles,
and embedded ﬁnite models. Transactions of the American Mathematical Soci-
ety, 352:4937–4969, 2000.
8. J. Baldwin and S. Shelah. Randomness and semi-genericity. Transactions of the
American Mathematical Society, 349:1359–1376, 1997.
9. J. Barwise. On Moschovakis closure ordinals. Journal of Symbolic Logic, 42:
292–296, 1977.
10. M. Benedikt, G. Dong, L. Libkin, and L. Wong. Relational expressive power of
constraint query languages. Journal of the ACM, 45(1):1–34, 1998.
11. J. van Benthem.
Modal Correspondence Theory.
PhD thesis, Mathematisch
Instituut & Instituut voor Grondslagenonderzoek, University of Amsterdam,
1976.
12. J. van Benthem. Modal Logic and Classical Logic. Bibliopolis, 1983.
13. P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Cambridge University
Press, 2002.
14. A. Blass, Y. Gurevich, and D. Kozen. A zero–one law for logic with a ﬁxed-point
operator. Information and Control, 67(1-3):70–90, 1985.
15. L. Blum, M. Shub, and S. Smale. On a theory of computation over the real
numbers; np completeness, recursive functions and universal machines (extended
abstract). In FOCS, pages 387–397. IEEE Computer Society, 1988.
16. J. R. B¨uchi. Weak second-order arithmetic and ﬁnite automata. Zeitschrift f¨ur
Mathematische Logik und Grundlagen der Mathematik, 6:66–92, 1960.
17. A. A. Bulatov. A dichotomy theorem for constraints on a three-element set. In
FOCS, pages 649–658. IEEE Computer Society, 2002.
18. J-y. Cai, M. F¨urer, and N. Immerman. An optimal lower bound on the number
of variables for graph identiﬁcation. In FOCS, pages 612–617. IEEE Computer
Society, 1989.
19. A. Chandra and D. Harel. Structure and complexity of relational queries. Jour-
nal of Computer and System Sciences, 25:99–128, 1982.
20. A. K. Chandra. Theory of database queries. In PODS, pages 1–9. ACM, 1988.
21. C. C. Chang and H. J. Keisler. Model Theory. North-Holland, 1990.
22. A. Dawar.
Finite models and ﬁnitely many variables.
In D. Niwinski and
R. Maron, editors, Logic, Algebra and Computer Science, Banach Center Pub-
lications, volume 46, pages 93–117. Polish Academy of Sciences, 1999.
23. A. Dawar. Generalized quantiﬁers and logical reducibilities. Journal of Logic
and Computation, 5(2):213–226, 1995.
24. P. Erd¨os and A. R´enyi. On the evolution of random graphs. Public Mathematical
Institute of Hungary Academy of Sciences, 5:17–61, 1960.
25. R. Fagin. Generalized ﬁrst-order spectra and polynomial-time recognizable sets.
In R. M. Karp, editor, Complexity of Computation, SIAM-AMS Proceedings,
volume 7, pages 43–73, 1974.
26. R. Fagin. Probabilities on ﬁnite models. Journal of Symbolic Logic, 41(1):50–58,
March 1976.

24
1 Unifying Themes in Finite Model Theory
27. T. Feder and M. Y. Vardi. The computational structure of monotone monadic
SNP and constraint satisfaction: a study through datalog and group theory.
SIAM Journal on Computing, 28:57–104, 1998.
28. Y. Glebskii, D. Kogan, M. Liogon’kii, and V. Talanov.
Range and degree
of realizability of formulas in the restricted predicate calculus.
Cybernetics,
5:142–154, 1969.
29. E. Gr¨adel. Why are modal logics so robustly decidable? Bulletin of the EATCS,
68:90–103, 1999.
30. E. Gr¨adel and Y. Gurevich. Metaﬁnite model theory. Information and Compu-
tation, 140:26–81, 1998.
31. E. Gr¨adel and G. L. McColm. Hierarchies in transitive closure logic, stratiﬁed
datalog and inﬁnitary logic.
Annals of Pure and Applied Logic, 77:166–199,
1996.
32. E. Gr¨adel, W. Thomas, and T. Wilke, editors.
Automata, Logics, and Inﬁ-
nite Games: A Guide to Current Research, Lecture Notes in Computer Science,
volume 2500, Springer, 2002.
33. M. Grohe. Finite variable logics in descriptive complexity theory. Bulletin of
Symbolic Logic, 4:345–398, 1998.
34. M. Grohe. Fixed-point logics on planar graphs. In LICS, pages 6–15. IEEE
Computer Society, 1998.
35. M. Grohe. Isomorphism testing for embeddable graphs through deﬁnability. In
STOC, pages 63–72. ACM, 2000.
36. M. Grohe and J. Mari˜no. Deﬁnability and descriptive complexity on databases
of bounded tree-width. In C. Beeri and P. Buneman, editors, ICDT, Lecture
Notes in Computer Science, volume 1540, pages 70–82. Springer, 1999.
37. S. Grumbach and J. Su.
Queries with arithmetical constraints.
Theoretical
Computer Science, 173(1):151–181, 1997.
38. Y. Gurevich. Logic and the challenge of computer science. In E. B¨orger, editor,
Current Trends in Theoretical Computer Science, pages 1–57. Computer Science
Press, 1988.
39. Y. Gurevich and S. Shelah. Fixed-point extensions of ﬁrst-order logic. Annals
of Pure and Applied Logic, 32:265–180, 1986.
40. P. Hell and J. Neˇsetˇril. On the complexity of H-coloring. Journal of Combina-
torial Theory-Series B, 48:92–110, 1990.
41. L. Hella, Ph. G. Kolaitis, and K. Luosto. Almost everywhere equivalence of
logics in ﬁnite model theory.
The Bulletin of Symbolic Logic, 2(4):422–443,
1996.
42. M. Hennessy and R. Milner. Algebraic laws for nondeterminism and concur-
rency. Journal of the ACM, 32(1):137–161, 1985.
43. N. Immerman. Relational queries computable in polynomial time. Information
and Control, 68:86–104, 1986.
44. N. Immerman and D. Kozen.
Deﬁnability with bounded number of bound
variables. Information and Computation, 83:121–139, 1989.
45. P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz. Constraint query languages.
In PODS, pages 299–313. ACM, 1990.
46. C. Karp.
Finite quantiﬁer equivalence.
In J. W. Addison, L. Henkin, and
A. Tarski, editors, The Theory of Models, pages 407–412. North-Holland, 1965.
47. Ph. G. Kolaitis and M. Y. Vardi. The decision problem for the probabilities of
higher-order properties. In STOC, pages 425–435. ACM, 1987.

References
25
48. Ph. G. Kolaitis and M. Y. Vardi. Inﬁnitary logics and 0–1 laws. Information
and Computation, 98(2):258–294, 1992.
49. S. Kreutzer. Expressive equivalence of least and inﬂationary ﬁxed-point logic.
Annals of Pure and Applied Logic, 130(1–3):61–78, 2004.
50. R. E. Ladner. On the structure of polynomial time reducibility. Journal of the
ACM, 22(1):155–171, 1975.
51. M. C. Laskowski. A simpler axiomatization of the Shelah–Spencer almost sure
theories. Israel Journal of Mathematics, to appear.
52. Y. N. Moschovakis. Descriptive Set Theory. North-Holland, 1980.
53. A. Nash, J. B. Remmel, and V. Vianu. Ptime queries revisited. In T. Eiter and
L. Libkin, editors, ICDT, Lecture Notes in Computer Science, volume 3363,
pages 274–288. Springer, 2005.
54. M. Otto. Bounded Variable Logics and Counting. Springer, 1997.
55. M. Otto. Bisimulation-invariant ptime and higher-dimensional μ-calculus. The-
oretical Computer Science, 224(1-2):237–265, 1999.
56. M. Otto. Modal and guarded characterisation theorems over ﬁnite transition
systems. Annals of Pure and Applied Logic, 130:173–205, 2004.
57. D. Park. Concurrency and automata on inﬁnite sequences. In P. Deussen, editor,
Theoretical Computer Science, Lecture Notes in Computer Science, volume 104,
pages 167–183. Springer, 1981.
58. O. Reingold.
Undirected st-connectivity in log-space.
In H. N. Gabow and
R. Fagin, editors, STOC, pages 376–385. ACM, 2005.
59. E. Rosen. Modal logic over ﬁnite structures. Journal of Logic, Language and
Information, 6(4):427–439, 1997.
60. B. Rossman. Existential positive types and preservation under homomorphisms.
In LICS, pages 467–476. IEEE Computer Society, 2005.
61. T. J. Schaefer.
The complexity of satisﬁability problems.
In STOC, pages
216–226. ACM, 1978.
62. S. Shelah and J. Spencer. Zero–one laws for sparse random graphs. Journal of
the American Mathematical Society, 1:97–115, 1988.
63. H. Straubing.
Finite Automata, Formal Logic, and Circuit Complexity.
Birkh¨auser, 1994.
64. W. Tait. A counterexample to a conjecture of Scott and Suppes. Journal of
Symbolic Logic, 24(1):15–16, 1959.
65. A. Tarski. The concept of truth in formalized languages. In Logic, Semantics,
Metamathematics, pages 152–278. Clarendon Press, Oxford, 1956.
66. L. van den Dries. Tame Topology and o-Minimal Structures. Cambridge Uni-
versity Press, 1998.
67. L. van den Dries. Classical model theory of ﬁelds. In D. Haskell, A. Pillay,
and C. Steinhorn, editors, Model Theory, Algebra, and Geometry, pages 37–52.
Cambridge University Press, 2000.
68. M. Y. Vardi. The complexity of relational query languages. In STOC, pages
137–146. ACM, 1982.
69. M. Y. Vardi. Why is modal logic so robustly decidable? In N. Immerman and
Ph. G. Kolaitis, editors, Descriptive Complexity and Finite Models, volume 31
of DIMACS Series in Discrete Mathematics and Theoretical Computer Science,
pages 149–184. American Mathematical Society, 1996.
70. A. J. Wilkie. Model completeness results for expansions of the ordered ﬁeld
of real numbers by restricted pfaﬃan functions and the exponential function.
Journal of the American Mathematical Society, 9:1051–1094, 1996.


2
On the Expressive Power of Logics
on Finite Models
Phokion G. Kolaitis
2.1 Introduction
Finite model theory can be succinctly described as the study of logics on
classes of ﬁnite structures. In addition to ﬁrst-order logic, various other logics
have been explored in the context of ﬁnite model theory, including fragments
of second-order logic, logics with ﬁxed-point operators, inﬁnitary logics, and
logics with generalized quantiﬁers. Some typical classes of ﬁnite structures on
which these logics have been investigated are the class of all ﬁnite graphs, the
class of all ﬁnite ordered graphs, the class of all ﬁnite planar graphs, the class
of all ﬁnite strings, and the class of all ﬁnite trees.
Finite model theory provides a conceptual and methodological framework
for exploring the connections between logic and several key areas of computer
science, such as database theory, computational complexity, and computer-
aided veriﬁcation. This is perhaps the primary motivation for developing ﬁnite
model theory. As its development progressed, however, it became clear that
ﬁnite model theory was an area of research that deserved to be studied in
its own right. While the traditional focus of mathematical logic has been
on ﬁxed inﬁnite structures or on classes of ﬁnite and inﬁnite structures, it
has turned out that new phenomena emerge when one focuses on classes of
ﬁnite structures. These phenomena give ﬁnite model theory its own distinctive
character and set it apart from other areas of mathematical logic.
There are three main areas of research in ﬁnite model theory: the study of
the expressive power of logics on ﬁnite structures; the study of the connections
between logic and computational complexity, an area which is also known as
descriptive complexity; and the study of the connections between logic and
asymptotic probabilities. The ﬁrst of these three areas is the focus of the
present chapter.

28
2 On the Expressive Power of Logics on Finite Models
2.2 Basic Concepts
A vocabulary is a ﬁnite set σ = {R1, . . . , Rm, c1, . . . , cs} of relation sym-
bols of speciﬁed arities, and constant symbols. A σ-structure is a tuple
A = (A, RA
1 , . . . , RA
m, cA
1 , . . . , cA
s ) such that A is a nonempty set, called the
universe of A, each RA
i
is a relation on A such that arity(RA
i ) = arity(Ri),
1 ≤i ≤m, and each cA
j is a distinguished element of A, 1 ≤j ≤s. A ﬁnite
σ-structure is a σ-structure A whose universe A is a ﬁnite set. In what fol-
lows, we shall assume that the universe of every ﬁnite structure is an initial
segment {1, . . . , n} of the integers. If the vocabulary is understood from the
context, we shall simply use the terms “structure” and “ﬁnite structure”. Also,
whenever no confusion arises and in order to simplify the notation, we shall
use the same symbol for both a relation (constant) symbol and the relation
(distinguished element) interpreting it on a structure.
Let us assume that A
=
(A, RA
1 , . . . , RA
m, cA
1 , . . . , cA
s ) and B
=
(B, RB
1 , . . . , RB
m, cB
1 , . . . , cB
s ) are two σ-structures. An isomorphism between
A and B is a mapping h : A →B that satisﬁes the following conditions:
•
h is a one-to-one and onto function.
•
For every constant symbol cj, 1 ≤j ≤s, we have that h(cA
j ) = cB
j .
•
For every relation symbol Ri, 1 ≤i ≤m, of arity t and for every
t-tuple (a1, . . . , at) from A, we have that RA
i (a1, . . . , at) if and only if
RB
i (h(a1), . . . , h(at)).
A structure B = (B, RB
1 , . . . , RB
m, cB
1 , . . . , cB
s ) is a substructure of A if B ⊆
A, each RB
i is the restriction of RA
i to B (which means that RB
i = RA
i ∩Bt,
where t is the arity of Ri), 1 ≤i ≤m, and cB
j = cA
j , 1 ≤j ≤s. If A is a
σ-structure and D is a subset of A, then the substructure of A generated by
D is the structure A ↾D having the set D ∪{cA
1 , . . . , cA
s } as its universe and
having the restrictions of the relations RA
i on D∪{cA
1 , . . . , cA
s } as its relations.
A partial isomorphism from A to B is an isomorphism from a substructure
of A to a substructure of B. From the preceding deﬁnitions, it follows that
every partial isomorphism from A to B must map each constant cA
j of A to
the constant cB
j , 1 ≤j ≤s.
The following examples illustrate some of these concepts. A directed graph
is a structure G = (V, E), where E is a binary relation on V . An undi-
rected graph or, simply, a graph is a structure G = (V, E) such that E is
a binary symmetric relation on V without self-loops. The subgraph of G
induced by a set D of nodes is precisely the substructure of G generated
by D. A directed graph with two distinguished nodes s and t is a structure
G = (V, E, s, t). An ordered directed graph is a structure G = (V, E, ≤),
where E is a binary relation on V and ≤is a linear order on V . A k-colored
directed graph is a structure G = (V, E, P1, . . . , Pk), where E is a binary rela-
tion on V and each Pi is a unary relation on V consisting of all nodes of
color i, 1 ≤i ≤k. Finally, a binary string of length n can be thought of as
a structure S = ({1, 2, . . ., n}, P), where P is a unary relation on {1, . . ., n}

2.2 Basic Concepts
29
such that i ∈P if and only if the ith bit of the string is equal to 1, where
1 ≤i ≤n. For instance, the string 10001 can be identiﬁed with the ﬁnite
structure ({1, 2, 3, 4, 5}, {1, 5}).
The concept of a query, which originated in database theory, is one of
the most fundamental concepts in ﬁnite model theory. We now give a precise
deﬁnition and present several examples.
Deﬁnition 2.2.1. Let σ be a vocabulary and k a positive integer.
•
A class of σ-structures is a collection C of σ-structures that is closed under
isomorphisms, which means that if A ∈C and B is a structure that is
isomorphic to A, then B ∈C.
•
A k-ary query on a class C is a mapping Q with domain C and such that
–
Q(A) is a k-ary relation on A, for A ∈C;
–
Q is preserved under isomorphisms, which means that if h : A →B is
an isomorphism, then Q(B) = h(Q(A)).
•
A Boolean query on a class C is a mapping Q : C →{0, 1} that is preserved
under isomorphisms, i.e., if A is isomorphic to B, then Q(A) = Q(B).
Consequently, Q can be identiﬁed with the subclass C′ = {A ∈C : Q(A) =
1} of C.
Example 2.2.2. Consider the following queries on graphs G = (V, E).
•
The Transitive Closure query T C is the binary query such that
T C(G) = {(a, b) ∈V 2: there is a path from a to b}.
•
The 2-Disjoint Paths query is the 4-ary query 2DP such that
2DP(G) = {(a, b, c, d) ∈V 4: there are two node-disjoint paths from a to b
and from c to d}.
•
The Articulation Point query is the unary query AP such that
AP(G) = {a ∈V : a is an articulation point of G}.
•
The Even Cardinality query EV EN is the Boolean query such that
EV EN(G) =

1 if G has an even number of nodes
0 otherwise.
•
The Connectivity query CN is the Boolean query such that
CN(G) =

1 if G is connected
0 otherwise.
•
The Boolean queries Eulerian, Acyclicity, k-Colorability, and
Hamiltonian Path are deﬁned in an analogous way.

30
2 On the Expressive Power of Logics on Finite Models
Queries are mathematical objects that formalize the concept of a “prop-
erty” of structures and of elements of structures. This formalization makes
it possible to deﬁne and study what it means for such a “property” to be
expressible in some logic. In other words, we shall use logic as a speciﬁcation
language of “properties” of structures and of elements of structures.
Deﬁnition 2.2.3. Let L be a logic and C a class of σ-structures.
•
A k-ary query Q on C is L-deﬁnable if there is an L-formula ϕ(x1, . . . , xk)
with x1, . . . , xk as free variables and such that for every A ∈C,
Q(A) = {(a1, . . . , ak) ∈Ak : A |= ϕ(a1, . . . , ak)}.
•
A Boolean query Q on C is L-deﬁnable if there is an L-sentence ψ such
that for every A ∈C,
Q(A) = 1 ⇐⇒A |= ψ.
•
L(C) denotes the collection of all L-deﬁnable queries on C.
Two remarks are in order now. First, it should be emphasized that the
concept of an L-deﬁnable query Q on a class C of σ-structures is a concept of
uniform deﬁnability. This means that the same L-formula serves as a speci-
ﬁcation of the query on every structure in C, which is entirely analogous to
the requirement that an algorithm for a problem must produce the correct
answer on every instance of the problem. Along these lines, note that if a
query Q is L-deﬁnable on C and C′ is a subclass of C, then the restriction of
Q on C′ is also L-deﬁnable using the formula that deﬁnes it on C. Second,
the concept of an L-deﬁnable query on a class C makes sense for an arbitrary
class of σ-structures, which may very well consist of both ﬁnite and inﬁnite
structures, or only inﬁnite structures, or only ﬁnite structures. In particular,
this concept contains the following important cases as special cases:
1. C is the class S of all (ﬁnite and inﬁnite) σ-structures. This is the primary
case of uniform deﬁnability studied in classical model theory.
2. C consists of a single inﬁnite structure A (and all its isomorphic copies).
This is the case of local deﬁnability on a ﬁxed structure. The two primary
examples are the structure N = (N, +, ×) of arithmetic and the structure
R = (R, +, ×) of analysis, where N is the set of all natural numbers and
R is the set of all real numbers.
3. C is the class F of ﬁnite σ-structures. As stated earlier, this means that
F consists of all σ-structures with universe {1, . . ., n} for some positive
integer n. This is the primary case of uniform deﬁnability studied in ﬁnite
model theory.
We now present several examples of queries that are deﬁnable in ﬁrst-
order logic or in fragments of second-order logic. We assume familiarity with
the syntax and semantics of ﬁrst-order logic and second-order logic (see [20]

2.2 Basic Concepts
31
for the precise deﬁnitions). Informally, ﬁrst-order logic FO over a vocabulary
σ has (ﬁrst-order) variables that are interpreted by elements of the structure
at hand; has atomic formulas of the form s1 = s2 and Ri(s1, . . . , st), where
Ri is a relation symbol and each sj is a variable or a constant symbol; has the
standard propositional connectives ¬, ∨, ∧, →; and, ﬁnally, has ﬁrst-order
quantiﬁers ∀x and ∃x, for each variable x, that range over elements of the
universe of the structure at hand.
Example 2.2.4. The following queries are ﬁrst-order deﬁnable on the class of
all (ﬁnite or inﬁnite) graphs.
•
The Boolean query “the graph G has an isolated node” is deﬁnable by the
ﬁrst-order formula
(∃x)(∀y)(¬E(x, y)).
•
The unary query “the node x has at least two distinct neighbors” is deﬁn-
able by the ﬁrst-order formula
(∃y)(∃z)(¬(y = z) ∧E(x, y) ∧E(x, z)).
Similarly, for each ﬁxed k, the Boolean query “G is a k-regular graph”
(i.e., each node has exactly k neighbors) is ﬁrst-order deﬁnable.
•
The binary query “there is a path of length 2 from x to y” is deﬁnable by
the ﬁrst-order formula
(∃z)(¬(x = z) ∧¬(y = z) ∧E(x, z) ∧E(z, y)).
The syntax of second-order logic SO is obtained by augmenting the syntax
of ﬁrst-order logic with second-order variables X, Y, . . . and second-order quan-
tiﬁers ∃X, ∃Y, . . . , ∀X, ∀Y, . . . that are interpreted by relations of ﬁxed arities
over the universe of the structure at hand. Existential second-order logic ESO
and universal second-order logic USO are the syntactically simplest fragments
of second-order logic. Speciﬁcally, ESO consists of all second-order formulas
of the form
(∃S1) · · · (∃Sm)ϕ(x, S1, . . . , Sm),
where each Si is a second-order variable, 1 ≤i ≤m, and ϕ(x, S1, . . . , Sm)
is a ﬁrst-order formula. In a dual manner, USO consists of all second-order
formulas of the form
(∀S1) · · · (∀Sm)ϕ(x, S1, . . . , Sm),
where each Si is a second-order variable, 1 ≤i ≤m, and ϕ(x, S1, . . . , Sm)
is a ﬁrst-order formula. Monadic second-order logic MSO is the fragment
of second-order logic consisting of all second-order formulas in which every
second-order quantiﬁer is applied to a unary second-order variable, which
means that all second-order quantiﬁers in the formula range over subsets of
the universes of structures. Existential monadic second-order logic consists of

32
2 On the Expressive Power of Logics on Finite Models
all formulas that are both ESO formulas and monadic second-order formulas.
Similarly, universal monadic second-order logic consists of all formulas that
are both USO formulas and monadic second-order formulas.
Example 2.2.5. The following queries are deﬁnable in existential monadic
second-order logic on the class of all (ﬁnite or inﬁnite) graphs:
1. The Boolean query Disconnectivity is deﬁnable by the formula
(∃S)((∃x)S(x) ∧(∃y)¬S(y) ∧(∀z)(∀w)(S(z) ∧¬S(w) →¬E(z, w))).
Intuitively, this sentence asserts that there are two disjoint, nonempty sets
of nodes with no edge between them.
2. The Boolean query 2-Colorability is deﬁnable by the formula
(∃R)(∀x)(∀y)(E(x, y) →(R(x) ↔¬R(y))).
Intuitively, the two colors are encoded by R and the complement of R.
3. For every k ≥3, the Boolean query k-Colorability is deﬁnable by
a formula of existential monadic second-order logic with k −1 existen-
tial monadic quantiﬁers. The formula is similar to the one above used to
deﬁne 2-Colorability: each of the k −1 monadic second-order variables
encodes a diﬀerent color, while the kth color is encoded by the comple-
ment of the union of these k −1 colors. Indeed, the reader may verify that
⌈log k⌉existential monadic quantiﬁers suﬃce.
Example 2.2.6. The Well-Foundedness Boolean query is deﬁnable on the
class of all linear orders (V, ≤) by the following formula of universal monadic
second-order logic:
(∀S)((∃x)S(x) →(∃y)(S(y) ∧(∀z)(S(z) →y ≤z))).
Example 2.2.7. The Boolean query Hamiltonian Path is deﬁnable on the
class of all ﬁnite graphs G = (V, E) by an existential second-order formula
that asserts that
(∃T )( (“T is a linear order on V ”)∧
(∀x)(∀y)(“y is the successor of x in T ” →E(x, y))),
where T is a second-order variable of arity 2. In the above formula, the prop-
erties “T is a linear order on V ” and “y is the successor of x in T ” are clearly
expressible in ﬁrst-order logic.
Example 2.2.8. The Boolean query Rigidity (i.e., given a graph G = (V, E),
is the identity function its only automorphism?) is deﬁnable on the class of
all ﬁnite graphs by a universal second-order formula that asserts that
(∀S)(“S encodes an automorphism of G” →(∀x)S(x, x)),
where S is a binary relation symbol.

2.2 Basic Concepts
33
The expressive power of a logic L on a class C of ﬁnite structures is mea-
sured by the collection L(C) of L-deﬁnable queries on C. As a general rule,
the expressive power of a logic L is context-dependent, that is to say, L(C)
depends on the class C on which the logic L is studied. For instance, ﬁrst-
order logic has very high expressive power on the structure N = (N, +, ×) of
arithmetic, since every recursively enumerable relation is ﬁrst-order deﬁnable
on N. In contrast, ﬁrst-order logic has limited expressive power on the class of
all (ﬁnite or inﬁnite) graphs, since properties as basic as Connectivity and
Acyclicity are not ﬁrst-order deﬁnable. First-order logic has limited expres-
sive power on the class of all ﬁnite graphs as well. In particular, none of the
following queries is ﬁrst-order deﬁnable on ﬁnite graphs: Even Cardinality;
Connectivity; Acyclicity; Planarity; Eulerian; k-Colorability, for
every ﬁxed k ≥2; and Hamiltonian Path. Actually, it is fair to say that no
property of ﬁnite graphs that requires recursion is ﬁrst-order deﬁnable.
The central question about the expressive power of a logic L on a class C
of structures is to determine which queries on C are L-deﬁnable and which are
not. Clearly, to show that a query Q on C is L-deﬁnable, it suﬃces to ﬁnd some
L-formula that deﬁnes it on every structure in C. In contrast, showing that Q is
not L-deﬁnable is in principle a more challenging task, since it entails showing
that no formula of L deﬁnes the property. In many respects, this is analogous
to the diﬀerence between establishing upper and lower bounds on the compu-
tational complexity of an algorithmic problem. For this reason, much of the
investigation of the expressive power of a logic centers on the development of
techniques for showing that queries are not deﬁnable in that logic.
There are three main tools for investigating the expressive power of ﬁrst-
order logic:
•
the Compactness Theorem;
•
the method of ultraproducts;
•
the method of Ehrenfeucht–Fra¨ıss´e games.
The Compactness Theorem and the method of ultraproducts are direct and
eﬀective tools for analyzing the expressive power of ﬁrst-order logic on the class
of all (ﬁnite or inﬁnite) structures over a given vocabulary. To illustrate this
point, let us recall the standard proof that Connectivity is not ﬁrst-order
deﬁnable on the class of all graphs. Towards obtaining a contradiction, assume
that there is a ﬁrst-order sentence ψ such that for every graph G = (V, E)
we have that G |= ψ if and only if G is connected. Let c′, d′ be two constant
symbols and, for every n ≥1, let ϕn be a ﬁrst-order sentence asserting that
there is no path of length n from c to d. Then every ﬁnite subset of the set
T = {ϕn : n ≥1} ∪{ψ}
has a model (for instance, a suﬃciently long path with c and d as its end-
points). Consequently, the Compactness Theorem implies that T has a model
G = (V, E, c, d). This, however, gives rise to a contradiction. Indeed, on the

34
2 On the Expressive Power of Logics on Finite Models
one hand, G is connected, since G |= ψ; in particular, there is a path from
(the distinguished element interpreting) c to (the distinguished element inter-
preting) d in G. On the other hand, however, there is no path from c to d in
G, since G |= ϕn, for every n ≥1.
Although the above proof establishes that Connectivity is not ﬁrst-order
deﬁnable on the class of all graphs, it does not establish that this property
is not ﬁrst-order deﬁnable on the class of all ﬁnite graphs. The reason is that
the model of T guaranteed to exist by the Compactness Theorem need not be
ﬁnite. In general, it may very well be the case that every ﬁnite subset of a set
T of ﬁrst-order sentences has a ﬁnite model, but that T itself has only inﬁnite
models. Therefore, a proof that uses the Compactness Theorem to show that
a query is not ﬁrst-order deﬁnable on all structures does not automatically
translate to a proof that the query is not ﬁrst-order deﬁnable on all ﬁnite
structures. Similar obstacles arise when using the method of ultraproducts.
While it is still possible to use the Compactness Theorem and the method
of ultraproducts to study the expressive power of ﬁrst-order logic on ﬁnite
structures [29], the use of these tools is often somewhat cumbersome or not
intuitive. In contrast, the method of Ehrenfeucht–Fra¨ıss´e games is a tool that
has been successfully applied to the study of ﬁrst-order logic in ﬁnite model
theory. Furthermore, it is a ﬂexible and extendible tool, since variants of
Ehrenfeucht–Fra¨ıss´e games can be formulated and used to study the expressive
power of logics that are stronger than ﬁrst-order logic and do not possess the
Compactness Theorem.
2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
This section is devoted to a presentation of the Ehrenfeucht–Fra¨ıss´e games
and their applications to the analysis of the expressive power of ﬁrst-order
logic on ﬁnite structures.
Deﬁnition 2.3.1. Let r be a positive integer, σ a vocabulary, and A and B
two σ-structures.
The r-move Ehrenfeucht–Fra¨ıss´e game on A and B is played between two
players, called the Spoiler and the Duplicator, according to the following rules.
Each run of the game has r moves. In each move, the Spoiler plays ﬁrst
and picks an element from the universe A of A or from the universe B of B;
the Duplicator then responds by picking an element from the universe of the
other structure (i.e., if the Spoiler has picked an element from A, then the
Duplicator picks an element from B, and vice versa). Let ai ∈A and bi ∈B
be the two elements picked by the Spoiler and the Duplicator in their ith move,
1 ≤i ≤r.
•
The Duplicator wins the run (a1, b1), . . . , (ar, br) if the mapping
ai →bi, 1 ≤i ≤r, and cA
i →cB
j , 1 ≤j ≤s,

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
35
is a partial isomorphism from A to B, which means that it is an iso-
morphism between the substructure A ↾{a1, . . . , ar} of A generated by
{a1, . . . , ar} and the substructure B ↾{b1, . . . , br} of B generated by
{b1, . . . , br}. Otherwise, the Spoiler wins the run (a1, b1), . . . , (ar, br).
•
The Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on A and B if
the Duplicator can win every run of the game, i.e., if (s)he has a winning
strategy for the Ehrenfeucht–Fra¨ıss´e game. Otherwise, the Spoiler wins
the r-move Ehrenfeucht–Fra¨ıss´e game on A and B.
•
We write A ∼r
B to denote that the Duplicator wins the r-move
Ehrenfeucht–Fra¨ıss´e game on A and B.
A typical run of the r-move Ehrenfeucht–Fra¨ıss´e game on A and B is
depicted in Fig. 2.1.
The next proposition follows immediately from Deﬁnition 2.3.1.
Proposition 2.3.2. ∼r is an equivalence relation on the class S of all
σ-structures.
Example 2.3.3. Let A and B be the graphs depicted in Fig. 2.2. Then
•
A ∼2 B, i.e., the Duplicator wins the 2-move Ehrenfeucht–Fra¨ıss´e game
on A, B;
•
A ̸∼3 B, i.e., the Spoiler wins the 3-move Ehrenfeucht–Fra¨ıss´e game on
A, B.
Spoiler
a1 ∈A b2 ∈B b3 ∈B . . . ar ∈A
↕
↕
↕
. . . ↕
Duplicator b1 ∈B a2 ∈A a3 ∈A . . . br ∈B
Fig. 2.1. A typical run of the r-move Ehrenfeucht–Fra¨ıss´e game
A
B
Fig. 2.2. A diﬀerence between the 2-move and the 3-move Ehrenfeucht–Fra¨ıss´e game

36
2 On the Expressive Power of Logics on Finite Models
The Duplicator can win the 2-move game by playing in such a way that
there is an edge between a1 and a2 if and only if there is an edge between
b1 and b2. In contrast, the Spoiler can win the 3-move game by picking three
elements in B with no edge between any two of them.
Note that the description of a winning strategy for the Duplicator in the
Ehrenfeucht–Fra¨ıss´e game, as presented in Deﬁnition 2.3.1, is rather informal.
The concept of a winning strategy for the Duplicator can be made precise,
however, in terms of families of partial isomorphisms with appropriate exten-
sion properties.
Deﬁnition 2.3.4. Let r be a positive integer. A winning strategy for the
Duplicator in the r-move Ehrenfeucht–Fra¨ıss´e game on A and B is a sequence
I0, I1, . . . , Ir of nonempty sets of partial isomorphisms from A to B such that
•
The sequence I0, I1, . . . , Ir has the forth property: For every i < r, every
f ∈Ii, and every a ∈A, there is a g ∈Ii+1 such that a ∈dom(g) and
f ⊆g.
•
The sequence I0, I1, . . . , Ir has the back property: For every i < r, every
f ∈Ii, and every b ∈B, there is a g ∈Ii+1 such that b ∈rng(g) and
f ⊆g.
In eﬀect, the forth property provides the Duplicator with a good move
when the Spoiler picks an element of A, while the back property provides the
Duplicator with a good move when the Spoiler picks an element of B.
The key feature of Ehrenfeucht–Fra¨ıss´e games is that they capture the com-
binatorial content of ﬁrst-order quantiﬁcation; for this reason, Ehrenfeucht–
Fra¨ıss´e games can be used to characterize deﬁnability in ﬁrst-order logic on
an arbitrary class of σ-structures. To describe the precise connection between
ﬁrst-order logic and Ehrenfeucht–Fra¨ıss´e games, we need to bring into the
picture a well-known concept from mathematical logic.
Deﬁnition 2.3.5. Let ϕ be a ﬁrst-order formula over a vocabulary σ. The
quantiﬁer rank of ϕ, denoted by qr(ϕ), is the depth of quantiﬁer nesting in ϕ.
More formally, qr(ϕ) is deﬁned by the following induction on the construction
of ϕ:
•
If ϕ is atomic, then qr(ϕ) = 0.
•
If ϕ is of the form ¬ψ, then qr(ϕ) = qr(ψ).
•
If ϕ is of the form ψ1 ∧ψ2 or of the form ψ1 ∨ψ2, then qr(ϕ) =
max{qr(ψ1), qr(ψ2)}.
•
If ϕ is of the form ∃xψ or of the form ∀xψ, then qr(ϕ) = qr(ψ) + 1.
Note that if a ﬁrst-order formula is in prenex normal form, then its quanti-
ﬁer rank is equal to the number of the quantiﬁers in its preﬁx. For instance, if
ϕ is (∀x)(∀y)(∃z)θ, where θ is quantiﬁer-free, then qr(ϕ) = 3. In contrast, if ϕ

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
37
is (∃x)E(x, x)∨(∃y)(∀z)¬E(y, z), then qr(ϕ) = 2. Note also that if qr(ϕ) = r,
then for every r′ > r there is a ﬁrst-order formula ψ such that qr(ψ) = r′ and
ϕ is logically equivalent to ψ.
Deﬁnition 2.3.6. Let r be a positive integer, and let A and B be two
σ-structures. We write A ≡r B to denote that A and B satisfy the same
ﬁrst-order sentences of quantiﬁer rank r.
Proposition 2.3.7. ≡r is an equivalence relation on the class S of all
σ-structures.
Note that the equivalence relation ≡r is deﬁned using purely logical con-
cepts. The main technical result of this section asserts that ≡r coincides with
the equivalence relation ∼r, which was deﬁned using purely combinatorial
concepts.
Theorem 2.3.8. [19, 27] Let r be a positive integer, and let A and B be two
σ-structures. Then the following statements are equivalent:
1. A ≡r B, i.e., A and B satisfy the same ﬁrst-order sentences of quantiﬁer
rank r.
2. A ∼r B, i.e., the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game
on A and B.
Moreover, the following are true:
•
≡r has ﬁnitely many equivalence classes.
•
Each ≡r-equivalence class is deﬁnable by a ﬁrst-order sentence of quanti-
ﬁer rank r.
Example 2.3.9. Before embarking on the proof of Theorem 2.3.8, let us brieﬂy
revisit Example 2.3.3. As seen in that example, the Spoiler wins the 3-move
Ehrenfeucht–Fra¨ıss´e game on the structures A and B shown in Fig. 2.2. There-
fore, Theorem 2.3.8 tells that there is a ﬁrst-order sentence of quantiﬁer rank
3 that is satisﬁed by one of the two structures, but not by the other. Indeed,
if ϕ is the sentence
∃x∃y∃z(x ̸= y ∧x ̸= z ∧y ̸= z ∧¬E(x, y) ∧¬E(x, z) ∧¬E(y, z)),
then B |= ϕ, but A ̸|= ϕ. Note also that this sentence yields a strategy for the
Spoiler to win the 3-move Ehrenfeucht–Fra¨ıss´e game on A and B: the Spoiler
picks three elements b1, b2, b3 from B such that B, b1, b2, b3 |= (x ̸= y ∧x ̸= z
∧y ̸= z ∧¬E(x, y) ∧¬E(x, z) ∧¬E(y, z)). Another sentence witnessing that
A ̸≡3 B is the sentence
(∀x)(∀y)(∃z)(x ̸= y ∧¬E(x, y) →E(x, z) ∧E(y, z)),

38
2 On the Expressive Power of Logics on Finite Models
which is true on A, but is false on B. In turn, this sentence yields another
strategy for the Spoiler to win the 3-move Ehrenfeucht–Fra¨ıss´e game on A:
Spoiler
b1 ∈B b2 ∈B a3 ∈A
↕
↕
↕
Duplicator a1 ∈A a2 ∈A b3 ∈B.
The Spoiler ﬁrst picks two elements b1, b2 from B such that B, b1, b2 |= x ̸=
y ∧¬E(x, y)∧∀z¬(E(x, z)∧E(y, z)). After the Duplicator has picked elements
a1, a2 from A, the Spoiler picks an element a3 from A such that A, a1, a2, a3 |=
x ̸= y ∧¬E(x, y) →E(x, z) ∧E(y, z); the Duplicator is unable to respond to
this move in such a way that a partial isomorphism is maintained.
We now proceed with the proof of Theorem 2.3.8. One part of this theorem
has a relatively straightforward proof.
Theorem 2.3.10. Let r be a positive integer. If A and B are two σ-structures
such that the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on A and
B, then every ﬁrst-order sentence of quantiﬁer rank r that is true on A is also
true on B. Consequently, if A ∼r B, then A ≡r B.
Proof. We proceed by induction on the quantiﬁer rank of formulas. Assume
that the result holds for all formulas of quantiﬁer rank r over an arbitrary
vocabulary. We have to show that if ϕ is a formula of quantiﬁer rank r + 1
and A, B are two σ-structures such that A ∼r+1 B and A |= ϕ, then B |= ϕ.
The interesting cases are the ones in which ϕ is of the form ∃xψ or of the
form ∀xψ.
Assume that ϕ is of the form ∃xψ, which implies that qr(ψ) = r. We have
to show that B |= ∃xψ. Since A |= ϕ, there is an element a ∈A such that
A, a |= ψ. Let c be a new constant symbol and let ψ[x/c] be the ﬁrst-order
sentence obtained from ψ by replacing every free occurrence of the variable
x by c. Clearly, ψ[x/c] is a sentence of quantiﬁer rank r over the vocabulary
σ ∪{c}. Now view the above element a ∈A as the ﬁrst move of the Spoiler
in a run of the (r + 1)-move Ehrenfeucht–Fra¨ıss´e game on A and B. Let
b ∈B be the response of the Duplicator in this game played according
to the Duplicator’s winning strategy. Therefore, the Duplicator wins the
r-move Ehrenfeucht–Fra¨ıss´e game on (A, a) and (B, b) viewed as structures
over the vocabulary σ ∪{c} (and thus, a and b are distinguished elements
interpreting the constant c). Moreover, (A, a) |= ψ[x/c], so the induction
hypothesis implies that (B, b) |= ψ[x/c]), which, in turn, implies that
B |= ∃xψ.
Next, assume that ϕ is of the form ∀xψ, which again implies that
qr(ψ) = r. We have to show that B |= ∀xψ. Let b be an arbitrary element of B.
View this element as the ﬁrst move of the Spoiler in a run of the (r + 1)-move

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
39
Ehrenfeucht–Fra¨ıss´e game on A and B. Let a ∈A be the response of the
Duplicator in this game played according to the Duplicator’s winning strat-
egy. Therefore, the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on
(A, a) and (B, b) viewed as structures over the vocabulary σ ∪{c}, where, as
in the previous case, c is a new constant symbol. Since A |= ∀xψ, we have
that (A, a) |= ψ[x/c]. Consequently, the induction hypothesis implies that
(B, b) |= ψ[x/c]. 2
To prove the remaining parts of Theorem 2.3.8, we need to ﬁrst introduce
the concept of an (m, r)-type, 0 ≤m ≤r, and establish some basic properties
of this concept. The deﬁnition of an (m, r)-type is by backward induction on
m.
Deﬁnition 2.3.11. Assume that σ is a vocabulary, r is a positive integer, and
x1, . . . , xr are variables of ﬁrst-order logic.
•
An (r, r)-type is a conjunction of atomic or negated atomic formulas over
the vocabulary σ such that every variable occurring in this conjunction is
one of the variables x1, . . . , xr and, for every atomic formula θ over σ with
variables among x1, . . . , xr, either θ or ¬θ occurs as a conjunct.
•
Assume that the concept of an (m + 1, r)-type has been deﬁned, where
0 ≤m ≤r −1. An (m, r)-type is an expression of the form
	
{∃xm+1ϕ : ϕ is an (m + 1, r)-type in S}∧
	
{∀xm+1¬ϕ : ϕ is an (m + 1, r)-type not in S},
where S is a subset of the set of all (m + 1, r)-types.
Lemma 2.3.12. Let σ be a vocabulary, r a positive integer, and m an integer
such that 0 ≤m ≤r.
•
Every (m, r)-type is a ﬁrst-order formula over the vocabulary σ such that
its free variables are among x1, . . . , xm and its quantiﬁer rank is r −m.
•
There are only ﬁnitely many distinct (m, r)-types.
•
For every σ-structure A and every sequence a1, . . . , am of elements of A,
there is exactly one (m, r)-type ϕ such that A, a1, . . . , am |= ϕ.
Proof. We use backward induction on m. Since σ consists of ﬁnitely many
relation and constant symbols, there are ﬁnitely many atomic and negated
atomic formulas over σ with variables among x1, . . . , xr. It follows that every
(r, r)-type is a ﬁnite conjunction of such formulas and, thus, is a ﬁrst-order
formula of quantiﬁer rank 0. Moreover, every sequence a1, . . . , am of elements
from the universe of a structure A satisﬁes a unique (r, r)-type, namely the
conjunction of all atomic and negated atomic formulas over σ that are satisﬁed
by this tuple.
Assume that the properties of the lemma hold for (m + 1, r)-types. In
particular, the set of all (m+1, r)-types is ﬁnite, and hence it has ﬁnitely many

40
2 On the Expressive Power of Logics on Finite Models
subsets, which implies that there are ﬁnitely many (m, r)-types. Moreover, the
deﬁning expression of an (m, r)-type is a ﬁrst-order formula of quantiﬁer rank
r −m, since each (m + 1, r)-type is a ﬁrst-order formula of quantiﬁer rank
r−(m+1) = r−m−1. Finally, assume that A is a σ-structure and a1, . . . , am
is a sequence of elements from A. Let S∗be the set of all (m + 1, r)-types ϕ
such that A, a1, . . . , am |= ∃xm+1ϕ. Then A, a1, . . . , am satisﬁes the (m, r)-
type determined by S∗, i.e., the formula
	
{∃xm+1ϕ : ϕ ∈S∗} ∧
	
{∀xm+1¬ϕ : ϕ ̸∈S∗},
where ϕ ranges over all (m, r)-types. Moreover, if A, a1, . . . , am satisﬁes some
other (m, r)-type determined by a set S, then it is easy to see that S = S∗,
and so A, a1, . . . , am satisﬁes a unique (m, r)-type. 2
Deﬁnition 2.3.13. Let σ be a vocabulary, r a positive integer, m an integer
such that 0 ≤m ≤r, A a σ-structure, and a1, . . . , am a sequence of elements
from the universe of A.
We write ϕA,a1,...,am
r
to denote the unique (m, r)-type satisﬁed by
A, a1, . . . , am. In particular, when m = 0, we write ϕA
r to denote the unique
(0, r)-type satisﬁed by A.
According to Lemma 2.3.12, each expression ϕA,a1,...,am
r
is a ﬁrst-order
formula of quantiﬁer rank r −m with free variables among x1, . . . , xm. In
particular, each ϕA
r is a ﬁrst-order sentence of quantiﬁer rank r. It should
be pointed out that the assumption that the vocabulary σ consists of ﬁnitely
many relation and constant symbols was critical in showing that each (m, r)-
type is a ﬁrst-order formula and also that, for each m and each r with 0 ≤
m ≤r, there are ﬁnitely many distinct (m, r)-types. We are now ready to
complete the proof of Theorem 2.3.8 and also to establish that ϕA
r deﬁnes the
≡r-equivalence class of A.
Theorem 2.3.14. Let r be a positive integer, let A and B be two σ-structures,
and let ϕA
r be the unique (0, r)-type satisﬁed by A. Then the following state-
ments are equivalent:
1. A ≡r B, i.e., A and B satisfy the same ﬁrst-order sentences of quantiﬁer
rank r.
2. B |= ϕA
r .
3. A ∼r B, i.e., the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game
on A and B.
Proof. The implication (1) ⇒(2) follows from the deﬁnitions and the fact that
ϕA
r is satisﬁed by A and has quantiﬁer rank r. The implication (3) ⇒(1)
was established in Theorem 2.3.10. Consequently, it remains to prove the
implication (2) ⇒(3).
Assume that B |= ϕA
r . We describe a winning strategy for the Duplicator
in the r-move Ehrenfeucht–Fra¨ıss´e game on A and B. The key property of the

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
41
Duplicator’s strategy is that, for every run of the game and for every integer
m with 0 ≤m ≤r, if a1, . . . , am and b1, . . . , bm are the elements of A and B
played in the ﬁrst m moves of that run, then A, a1, . . . , am and B, b1, . . . , bm
satisfy the same (m, r)-type.
Assume ﬁrst that the Spoiler begins by playing an element a1 from A.
Let ϕA,a1
r
be the unique (1, r)-type satisﬁed by A, a1. Hence, the sentence
∃x1ϕA,a1
r
is a conjunct of ϕA
r , which implies that B |= ∃x1ϕA,a1
r
. Let b1 be
an element of B such that B, b1 |= ϕA,a1
r
. This element b1 is the Duplicator’s
response to the Spoiler’s ﬁrst move. Assume then that the Spoiler begins by
playing an element b1 from B. Let ϕB,b1
r
be the unique (1, r)-type satisﬁed
by B, b1. We claim that A |= ∃x1ϕB,b1
r
. Otherwise, we would have A |=
∀x1¬ϕB,b1
r
, which implies that ∀x1¬ϕB,b1
r
is a conjunct of ϕA
r . Consequently,
B |= ∀x1¬ϕB,b1
r
, which contradicts the fact that B, b1 |= ϕB,b1
r
.
By continuing to play in this way, the Duplicator ensures that at the end of
the run the sequences a1, . . . , ar and b1, . . . , br are such that A, a1, . . . , ar and
A, b1, . . . , br satisfy the same (r, r)-type, i.e., the same atomic and negated
atomic formulas. This implies that the mapping ai →bi, 1 ≤i ≤r, is a
partial isomorphism. 2
The ﬁrst application of the preceding results is a characterization of ﬁrst-
order deﬁnability on arbitrary classes of structures.
Theorem 2.3.15. Let σ be a vocabulary, C a class of σ-structures, and Q a
Boolean query on C. Then the following statements are equivalent:
1. Q is ﬁrst-order deﬁnable on C.
2. There is a positive integer r such that, for every structure A ∈C and
every structure B ∈C, if Q(A) = 1 and the Duplicator wins the r-move
Ehrenfeucht–Fra¨ıss´e game on A and B, then Q(B) = 1.
Proof. The implication (1) ⇒(2) is an immediate consequence of Theorem
2.3.10. For the other direction, assume that such a positive integer r exists.
Let S be the set of all (0, r)-types of structures A in C such that Q(A) = 1.
Lemma 2.3.12 implies that S is a ﬁnite set, and hence the disjunction

{ϕA
r : A ∈C and Q(A) = 1}
is a ﬁrst-order sentence, which we denote by ϕ. We now claim that ϕ deﬁnes
the query Q on C. If B is a structure in C such that Q(B) = 1, then its
(0, r)-type ϕB
r is one of the disjuncts of ϕ, and so B |= ϕ. Conversely, if B is
a structure in C such that B |= ϕ, then there is a structure A in C such that
Q(A) = 1 and B |= ϕA
r . Theorem 2.3.14 implies that the Duplicator wins the
r-move Ehrenfeucht–Fra¨ıss´e game on A and B, and hence Q(B) = 1. 2
Theorem 2.3.15 gives rise to a combinatorial method for studying ﬁrst-
order deﬁnability and obtaining lower bounds on the expressive power of ﬁrst-
order logic on arbitrary classes of structures.

42
2 On the Expressive Power of Logics on Finite Models
Method 2.3.16 The Method of Ehrenfeucht–Fra¨ıss´e Games for FO.
Let σ be a vocabulary, C a class of σ-structures, and Q a Boolean query on C.
Soundness. To show that Q is not ﬁrst-order deﬁnable on C, it suﬃces to
show that for every positive integer r there are structures Ar and Br in
C such that
•
Q(Ar) = 1 and Q(Br) = 0;
•
the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on A and B.
Completeness. This method is also complete; that is, if Q is not ﬁrst-order
deﬁnable on C, then for every positive integer r such structures Ar and
Br exist.
Note that the soundness of the method of Ehrenfeucht–Fra¨ıss´e games fol-
lows from Theorem 2.3.10, which is the easier part of establishing that the
two equivalence relations ∼r and ≡r coincide. In contrast, the proof of the
completeness of the method requires Theorem 2.3.14. We now illustrate this
method with two easy applications.
Proposition 2.3.17. The Even Cardinality query is not ﬁrst-order deﬁn-
able on the class of all ﬁnite graphs.
Proof. For every n ≥1, let Kn be the totally disconnected graph with n nodes
(Fig. 2.3). It is obvious that, for every r ≥1, every m ≥r, and every n ≥r, the
Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on Km and Kn. Thus,
we can apply the method of Ehrenfeucht–Fra¨ıss´e games using the structures
Km with m ≥r an even number and Kn with n ≥r an odd number. 2
Kn
Km
Fig. 2.3. Even Cardinality is not ﬁrst-order deﬁnable on ﬁnite graphs

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
43
Proposition 2.3.18. The Eulerian query is not ﬁrst-order deﬁnable on the
class of all ﬁnite graphs.
Proof. By deﬁnition, a graph is Eulerian if there is a closed walk that traverses
each edge exactly once. Euler showed that this property holds if and only if
every node has even degree, i.e., an even number of neighbors. For every n ≥1,
let An be the graph depicted in Fig. 2.4. Clearly, An is Eulerian if and only
if n is an even number. Moreover, for every n ≥r, the Duplicator wins the
r-move Ehrenfeucht–Fra¨ıss´e game on An and An+1. Thus, we can apply the
method of Ehrenfeucht–Fra¨ıss´e games using the structures A2n and A2n+1
with 2n ≥r. 2
As seen earlier, the method of Ehrenfeucht–Fra¨ıss´e games is complete,
which implies that if a query Q is not ﬁrst-order deﬁnable on a class C of
structures, then in principle this can be established using the method of
Ehrenfeucht–Fra¨ıss´e games. In practice, however, the following technical diﬃ-
culties may arise when one attempts to apply this method to concrete queries:
•
How does one ﬁnd, for every r ≥1, structures Ar and Br in C such that
Q(Ar) = 1, Q(Br) = 0, and the Duplicator wins the r-move Ehrenfeucht–
Fra¨ıss´e game on Ar and Br?
•
After such candidate structures Ar and Br have been identiﬁed, how does
one show rigorously that Ar ∼r Br?
As a general rule, both these tasks can be challenging. Nonetheless, they
can be eased by pursuing the following two approaches.
•
Whenever possible, analyze the ∼r-equivalence classes, r ≥1, of the struc-
tures in C and obtain explicit descriptions of them.
•
Find general suﬃcient conditions for the Duplicator to win the r-move
Ehrenfeucht–Fra¨ıss´e game, and thus build a “library” of winning strategies
for the Duplicator in this game.
The class L of all ﬁnite linear orders provides an interesting, albeit rather
rare, case in which it is possible to analyze the ∼r-equivalence classes, r ≥1.
c2
c1
cn
b
a
An
Fig. 2.4. Eulerian is not ﬁrst-order deﬁnable on ﬁnite graphs

44
2 On the Expressive Power of Logics on Finite Models
L6 : 1 ≤2 ≤3 ≤4 ≤5 ≤6
L7 : 1 ≤2 ≤3 ≤4 ≤5 ≤6 ≤7
L8 : 1 ≤2 ≤3 ≤4 ≤5 ≤6 ≤7 ≤8
Fig. 2.5. L6 ̸∼3 L7, but L7 ∼3 L8
Before presenting the full analysis, we give a motivating example. For every
n ≥1, we let Ln = ({1, . . ., n}, ≤) be the standard linear order on {1, . . ., n}.
Example 2.3.19. The
following
are
true
for
the
3-move
Ehrenfeucht–
Fra¨ıss´e game (Fig. 2.5).
•
The Spoiler wins the 3-move Ehrenfeucht–Fra¨ıss´e game on L6 and L7.
•
The Duplicator wins the 3-move Ehrenfeucht–Fra¨ıss´e game on L7 and L8.
The Spoiler can win the 3-move Ehrenfeucht–Fra¨ıss´e game on L6 and L7
by playing as follows. The ﬁrst move of the Spoiler is element 4 in L7. In
order to avoid losing in the next move, the Duplicator has to play either
element 4 in L6 or element 3 in L6. If the Duplicator plays 4 in L6, then the
Spoiler plays element 6 in L7. At this point, the Duplicator must play either
element 5 in L6 or element 6 in L6. In the ﬁrst case, the Spoiler wins the run
by playing element 5 in L7; in the second case, the Spoiler wins the run by
playing element 7 in L7. An essentially symmetric argument shows that the
Spoiler can win if the ﬁrst move of the Duplicator is element 3 in L6.
In contrast, consider the 3-move Ehrenfeucht–Fra¨ıss´e game on L7 and L8,
and suppose that the Spoiler plays element 4 in L8. In this case, the Duplicator
responds by playing element 4 in L7. If the Spoiler plays element 6 in L8, then
the Duplicator plays element 6 in L7, and after this can easily maintain a
partial isomorphism no matter what the third move of the Spoiler is. Similarly,
if the second move of the Spoiler is element 7 in L8, then the second move
of the Duplicator is element 6 in L7. We leave it to the reader to ﬁll in the
remaining cases and verify that the Duplicator wins the 3-move Ehrenfeucht–
Fra¨ıss´e game on L7 and L8.
We are now ready to describe the analysis of ∼r, r ≥1, on ﬁnite linear
orders and derive Example 2.3.19 as a special case.
Theorem 2.3.20. Let r, m, and n be positive integers. The following are
equivalent:
•
Lm ∼r Ln.
•
(m = n) or (m ≥2r −1 and n ≥2r −1).
Proof. (Hint) If c is an element of the linear order Ln, then L>c
n
denotes the
linear order with universe {d : c < d ≤n} and, similarly, L<c
n
denotes the

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
45
linear order with universe {d : 1 ≤d < c}. It is easy to see that, for every
positive integer s, we have that Lm ∼s+1 Ln if and only if the following two
conditions hold:
1. For every a ∈Lm, there is a b ∈Ln such that L>a
m ∼s L>b
n
and L<a
m ∼s
L<b
n .
2. For every b ∈Ln, there is an a ∈Lm such that L>a
m ∼s L>b
n
and L<a
m ∼s
L<b
n .
The required result can then be derived from the above fact using induction
on min(m, n). 2
Corollary 2.3.21. The Even Cardinality query is not ﬁrst-order deﬁnable
on the class L of all ﬁnite linear orders.
Proof. Apply the method of Ehrenfeucht–Fra¨ıss´e games using the linear orders
L2m and L2m+1 with m ≥2r −1. 2
As indicated earlier, the class of ﬁnite linear orders provides a rather
rare example of a class of structures for which a complete analysis of the
≡r-equivalence classes, r ≥1, has been obtained. Over the years, however,
researchers have succeeded in identifying general suﬃcient conditions for the
Duplicator to win the r-move Ehrenfeucht–Fra¨ıss´e game. These conditions
give “oﬀ-the-shelf” winning strategies for the Duplicator and thus facilitate
the application of the method of Ehrenfeucht–Fra¨ıss´e games. In what follows,
we shall present such a useful and widely applicable suﬃcient condition dis-
covered by Fagin, Stockmeyer, and Vardi [25], who built on earlier work by
Hanf [36]. Additional useful suﬃcient conditions for the Duplicator to win
the Ehrenfeucht–Fra¨ıss´e game have been found by Schwentick [59], Arora and
Fagin [6], and others (see [24] for a survey). Underlying this work is Gaifman’s
Theorem [28], which, intuitively, asserts that ﬁrst-order logic can express local
properties only. Although we shall not discuss or use Gaifman’s Theorem here,
we shall introduce the fundamental concept of neighborhood, which plays a
key role in both Gaifman’s work and the work on suﬃcient conditions for the
Duplicator to win the Ehrenfeucht–Fra¨ıss´e game.
Deﬁnition 2.3.22. Let A = (A, RA
1 , . . . , RA
m, cA
1 , . . . , cA
s ) be a σ-structure,
let a be an element of A, and let d be a positive integer.
•
The Gaifman graph GA = (A, EA) of A is the undirected graph having
the elements of A as nodes and an edge relation EA deﬁned as follows:
there is an edge EA(b, c) between two elements b and c of A if there is a
relation RA
i , 1 ≤i ≤m, and a tuple (t1, . . . , ts) ∈RA
i
such that b and c
are among t1, . . . , ts.
•
The neighborhood N(a, d) of a of radius d is the set of all nodes whose
distance in the Gaifman graph GA from a or from one of the constants

46
2 On the Expressive Power of Logics on Finite Models
cA
1 , . . . , cA
s is less than d. More formally, N(a, d) is deﬁned by the following
induction on d:
N(a, 1) = {a, cA
1 , . . . , cA
s }.
N(a, d + 1) = N(a, d) ∪{c ∈A : there is a b ∈N(a, d) such that EA(b, c)}.
The following examples reveal that the neighborhood of an element can
vary widely.
Example 2.3.23. Let n ≥1 and d ≥2 be positive integers.
•
If Ln = (Ln, ≤) is a linear order with n elements, then N(a, d) = Ln, for
every a ∈Ln.
•
If Kn = (Kn, E) is a clique with n nodes, then N(a, d) = Kn, for every
a ∈Kn.
•
If Kn = (Kn, E) is a totally disconnected graph with n nodes, then
N(a, d) = {a}, for every a ∈Kn.
•
If Cn = (Cn, E) is a (directed or undirected) cycle Cn with n nodes and
d ≤n/2, then the subgraph GCn ↾N(a, d) of the Gaifman graph GCn
induced by N(a, d) is an undirected path with 2d −1 nodes having a as
its midpoint.
Deﬁnition 2.3.24. Let A = (A, RA
1 , . . . , RA
m, cA
1 , . . . , cA
s ) be a σ-structure,
let a be an element of A, and let d be a positive integer.
•
(A, a) denotes the expansion of A obtained by augmenting it with a as a
distinguished element interpreting a new constant.
•
(A, a) ↾N(a, d) denotes the substructure of (A, a) generated by N(a, d).
•
The d-type of a is the isomorphism type of the structure (A, a) ↾N(a, d).
Note that the universe of (A, a) ↾N(a, d) is N(a, d), since N(a, d) contains
a, cA
1 , . . . , cA
s as members. Moreover, if B = (B, RB
1 , . . . , RB
m, cB
1 , . . . , cB
s ) is a
σ-structure and b is an element of B, then a and b have the same d-type
precisely when there is a one-to-one and onto mapping h : N(a, d) →N(b, d)
such that h(a) = b, h(cA
i ) = cB
i , 1 ≤i ≤s, and for every relation symbol Ri
of arity t, 1 ≤i ≤m, and every t-tuple (a1, . . . , at) from N(a, d), we have
that RA
i (a1, . . . , at) if and only if RB
i (h(a1), . . . , h(at)).
Deﬁnition 2.3.25. Assume that d is a positive integer, σ is a vocabulary, and
A and B are two σ-structures. We say that A and B are d-equivalent if for
every d-type τ they have the same number of elements of d-type τ.
Clearly, d-equivalence is an equivalence relation on the class S of all σ-
structures. The next result, due to Fagin, Stockmeyer and Vardi [25], asserts
that if d is larger than r by a suﬃcient amount, then d-equivalence is actually
a reﬁnement of ≡r-equivalence.
Theorem 2.3.26. For every positive integer r and for every positive integer
d ≥3r−1, if A is d-equivalent to B, then A ≡r B.

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
47
Proof. (Hint) Assume that A is d-equivalent to B, where d ≥3r−1. We can
show that the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on A
and B by maintaining a partial isomorphism between not only the elements
of A and B played thus far, but also between neighborhoods of these points
of suﬃciently large radius. Speciﬁcally, by induction on j ≤r, it can be
shown that the Duplicator can win the r-move Ehrenfeucht–Fra¨ıss´e game via
a winning strategy that has the following property, called the j-matching
condition: If a1, . . . , aj and b1, . . . , bj are the elements of A and B played
in the ﬁrst j moves of a run, then A ↾∪j
i=1N(ai, 3r−j) is isomorphic to
B ↾∪j
i=1N(bi, 3r−j) via an isomorphism that maps ai to bi, for 1 ≤i ≤j.
Note that the Duplicator can ensure that the 1-matching condition holds as
follows. If the Spoiler plays an element a1 in A (or an element b1 in B), then, by
d-equivalence, there is an element b1 in B (or an element a1 in A) such that a1
and b1 have the same d-type, which implies that A ↾N(a1, 3r−1) is isomorphic
to B ↾N(b1, 3r−1) via an isomorphism that maps a1 to b1. The inductive step
from j to j + 1 uses d-equivalence combined with a counting argument to the
eﬀect that the Duplicator can always ﬁnd at least one element with the same
d-type as the last element played by the Spoiler, but not contained in the
union of neighborhoods of radius 3r−(j+1) of the elements played so far. 2
Theorem 2.3.26 gives rise to a new method for studying ﬁrst-order deﬁn-
ability.
Method 2.3.27 Let σ be a vocabulary, C a class of σ-structures, and Q a
Boolean query on C. To show that Q is not ﬁrst-order deﬁnable on C, it suﬃces
to show that, for every positive integer r, there are structures Ar and Br in
C such that
•
Q(Ar) = 1 and Q(Br) = 0.
•
Ar is d-equivalent to Br for some d ≥3r.
Although, by Theorem 2.3.26, this method is sound, it is not complete.
For instance, it cannot be used to analyze ﬁrst-order deﬁnability on the class
L of all ﬁnite linear orders, since, for all positive integers d, m, and n, the
linear order Lm is d-equivalent to the linear order Ln if and only if m = n. In
particular, this method cannot be used to show that Even Cardinality is
not ﬁrst-order deﬁnable on ﬁnite linear orders. Nonetheless, whenever applica-
ble, Method 2.3.27 is usually technically simpler than Method 2.3.16, since it
replaces the task of proving that the Duplicator wins the r-move Ehrenfeucht–
Fra¨ıss´e game with the task of analyzing and counting d-types. Moreover, the
analysis of d-types often provides a clue for ﬁnding candidate structures Ar
and Br. In the remainder of this section, we present several applications of
Method 2.3.27 to ﬁnite model theory.
Proposition 2.3.28. The Connectivity query is not ﬁrst-order deﬁnable
on ﬁnite graphs.

48
2 On the Expressive Power of Logics on Finite Models
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
Br
Ar
4d
2d
2d
Fig. 2.6. Connectivity is not ﬁrst-order deﬁnable on ﬁnite graphs
Proof. For every r and every d ≥3r−1, let Ar be a cycle with 4d nodes and
let Br be the union of two disjoint cycles each with 2d nodes, as depicted in
Fig. 2.6. Clearly, each d-type in Ar or in Br is a path with 2d −1 nodes.
Moreover, Ar is d-equivalent to Br, since each structure contains exactly 4d
points of this d-type. 2
Proposition 2.3.29. The 2-Colorability query is not ﬁrst-order deﬁnable
on ﬁnite graphs.
Proof. For every r, let d = 3r−1, and let Ar be a cycle with 6d nodes and
let Bd be the union of two disjoint cycles each with 3d nodes, as depicted in
Fig. 2.7. Clearly, Ar is 2-colorable, but Br is not, since Ar is an even cycle,
while Br contains an odd cycle. Moreover, Ar is d-equivalent to Br. 2
Proposition 2.3.30. The Acyclicity query is not ﬁrst-order deﬁnable on
ﬁnite graphs.
Proof. Let Ar and Br be the two structures depicted in Fig. 2.8 Clearly, Ar
is acyclic, Br contains a cycle, and Ar is d-equivalent to Br. 2
Exercise 2.3.31. Show that the following queries are not ﬁrst-order deﬁnable
on the class of all ﬁnite graphs:
•
k-Colorability, for every ﬁxed k ≥3;
•
Planarity;
•
Rigidity.

2.3 Ehrenfeucht–Fra¨ıss´e Games for First-Order Logic
49
6d
..........................
..........................
..........................
..........................
3d
..........................
..........................
..........................
..........................
3d
Br
Ar
Fig. 2.7. 2-Colorability is not ﬁrst-order deﬁnable on ﬁnite graphs
4d
Ar
2d
2d
Br
Fig. 2.8. Acyclicity is not ﬁrst-order deﬁnable on ﬁnite graphs

50
2 On the Expressive Power of Logics on Finite Models
Exercise 2.3.32. Show that the Connectivity query is not ﬁrst-order deﬁn-
able on the class O of all ﬁnite ordered graphs G = (V, E, ≤).
Hint. Use the analysis of ≡r-equivalence on linear orders.
2.4 Computational Complexity
This section is a brief interlude on computational complexity and a ﬁrst
encounter with the connections between computational complexity and logics
on ﬁnite structures. These connections are explored in depth in Chap. 3 of
this volume.
2.4.1 Complexity Classes
In his 1993 Turing Award Lecture [37], Hartmanis described computational
complexity as “the quantitative study of solvability”. Indeed, the main goal of
computational complexity is to characterize the inherent diﬃculty of solvable
decision problems by placing them into classes according to the time resources
or space resources required to solve them in some model of computation, which
is usually either the (deterministic) Turing machine or the nondeterministic
Turing machine. The following major complexity classes will be of interest to
us here; their precise deﬁnitions can be found in [55].
It is well known and easy to show that the following containments hold:
L ⊆P ⊆NP ⊆PSPACE ⊆EXPTIME ⊆NEXPTIME.
It is also conjectured and widely believed that each of the above containments
is a proper one, but proving this remains the central open problem in the ﬁeld
of computational complexity to date. It has been established, however, that
if there is an exponential gap in the amount of the resource (space or time)
used in deﬁning two complexity classes, then one is properly contained in the
other. These results, which are known as space and time hierarchy theorems
(see [55]), imply that
L ⫋PSPACE,
P ⫋EXPTIME,
NP ⫋NEXPTIME.
Table 2.1. Some major computational complexity classes
Class
Resource bound
L
Logarithmic space
P
Polynomial time
NP
Nondeterministic polynomial time
PSPACE
Polynomial space
EXPTIME
Exponential time
NEXPTIME
Nondeterministic exponential time

2.4 Computational Complexity
51
A possible approach to separating two complexity classes is to show that there
is a structural property possessed by one class but not by the other. Clearly,
each of the deterministic classes L, P, PSPACE, and EXPTIME is closed
under complements. In contrast, the class NP of all problems solvable by a
nondeterministic polynomial-time bounded Turing machine is not known to be
closed under complements. Thus, the question “is NP = coNP?” constitutes
another major open problem in the ﬁeld of computational complexity. The
same state of aﬀairs holds true for the class NEXPTIME.
Each of the aforementioned complexity classes contains problems that are
complete for the class, i.e., problems that embody the intrinsic computational
diﬃculty of the class at hand. More precisely, let C be a complexity class and
Q a decision problem. We say that Q is C-complete if Q is in C and Q is
C-hard, i.e., for every Q′ ∈C, there is a “suitable” many–one reduction f of
Q′ to Q, so that for every input x,
x ∈Q′ ⇐⇒f(x) ∈Q.
If C is the class P of all polynomial-time solvable problems, then “suitable”
means that f is computable in logarithmic space. For NP and all other
larger classes, “suitable” means that f is computable in polynomial time.
Representative natural NP-complete problems include Boolean satisﬁability
(Sat), 3-Colorability, and Hamiltonian Path (see [30]). The prototyp-
ical PSPACE-complete problem is QBF, the satisﬁability problem for quan-
tiﬁed Boolean formulas [63].
2.4.2 The Complexity of Logic
Vardi [67] singled out certain fundamental decision problems that arise from
the analysis of the satisfaction relation between sentences of a logic L and
ﬁnite structures.
Deﬁnition 2.4.1. [67] Let L be a logic.
•
The combined complexity of L is the following decision problem: given a
ﬁnite structure A and an L-sentence ψ, does A |= ψ?
•
The data complexity of L is the family of the following decision prob-
lems Qψ, one for each ﬁxed L-sentence ψ: given a ﬁnite structure A, does
A |= ψ?
•
The expression complexity of L is the family of the following decision prob-
lems QA, one for each ﬁxed ﬁnite structure A: given an L-sentence ψ, does
A |= ψ?
The combined-complexity problem for L is also known as the model-
checking problem for L. In this problem, the input consists of both a ﬁnite
structure and an L-sentence. The data complexity and the expression com-
plexity are the restricted cases of the combined-complexity problem in which

52
2 On the Expressive Power of Logics on Finite Models
the L-sentence is kept ﬁxed or the ﬁnite structure is kept ﬁxed, respectively.
Note that the data complexity and the expression complexity are not single
decision problems, but families of decision problems. The next deﬁnition pro-
vides a way to “measure” the computational complexity of these families of
decision problems.
Deﬁnition 2.4.2. [67] Let L be a logic and C a complexity class.
•
The data complexity of L is in C if for each L-sentence ψ, the decision
problem Qψ is in C.
•
The data complexity of L is C-complete if it is in C and there is at least
one L-sentence ψ such that the decision problem Qψ is C-complete.
•
The expression complexity of L is in C if for each ﬁnite structure A, the
decision problem QA is in C.
•
The expression complexity of L is C-complete if it is in C and there is
at least one ﬁnite structure A such that the decision problem QA is C-
complete.
The next result pinpoints the data complexity, expression complexity, and
combined complexity of ﬁrst-order logic.
Theorem 2.4.3. The following hold for ﬁrst-order logic FO.
•
The data complexity of FO is in L.
•
The expression complexity of FO is PSPACE-complete
•
The combined complexity of FO is PSPACE-complete.
Proof. (Hint) For simplicity, assume that ψ is a ﬁrst-order sentence in prenex
normal form. Given a ﬁnite structure A, one can check whether A |= ψ by
examining each possible instantiation of quantiﬁers in ψ one at a time (this
requires logarithmic space), while keeping track of the number of them in
binary with the aid of a counter. Since there are polynomially many such
instantiations, only logarithmically many cells are used to keep track of the
counter, so the entire computation requires O(log(|A|) space, where |A| is the
cardinality of the universe of A.
If the sentence ψ is part of the input, then the above computation can
be carried out in a space bounded by a polynomial in |A|, so the combined
complexity of FO is in PSPACE. Finally, the expression complexity of FO is
PSPACE-complete (and hence the combined complexity of FO is PSPACE-
complete as well) because, for every ﬁxed ﬁnite structure A with at least
two distinct elements, the satisﬁability problem QBF for quantiﬁed Boolean
formulas is easily reducible to the expression complexity problem QA. 2
Theorem 2.4.3 shows that an exponential gap exists between the data
complexity of ﬁrst-order logic and the expression complexity of ﬁrst-order
logic, and that the expression complexity of ﬁrst-order logic is as hard as
the combined complexity of ﬁrst-order logic. As pointed out by Vardi [67],

2.4 Computational Complexity
53
this phenomenon is also encountered in several other logics studied in ﬁnite
model theory.
The r-move Ehrenfeucht–Fra¨ıss´e game gives rise to the natural decision
problem of determining the winner of this game. In fact, there are two versions
of this problem, one in which the number of moves is ﬁxed and one in which
the number of moves is part of the input. The next two results identify the
computational complexity of these problems.
Proposition 2.4.4. Let r be a ﬁxed positive integer. The following problem
is in L and, hence, also in P: given two ﬁnite structures A and B, does the
Duplicator win the r-move Ehrenfeucht–Fra¨ıss´e game on A and B?
Proof. By Theorem 2.3.8, for each ﬁxed r, there are ﬁnitely many ≡r-classes
and each such class is ﬁrst-order deﬁnable; moreover, the proof of Lemma
2.3.12 provides an explicit construction of the ﬁrst-order formulas that deﬁne
the ≡r-equivalence classes. The conclusion now follows from the fact that, by
Theorem 2.4.3, the data complexity of FO is in L. 2
Pezzoli [56] established that if the number of moves is part of the input,
then determining the winner of the r-move Ehrenfeucht–Fra¨ıss´e game is a
much harder task.
Theorem 2.4.5. The following problem is PSPACE-complete: given a posi-
tive integer r ≥1 and two ﬁnite structures A and B, does the Duplicator win
the r-move Ehrenfeucht–Fra¨ıss´e game on A and B?
This result is proved via a reduction from QBF that entails the construc-
tion of rather complicated combinatorial gadgets. It should be pointed out
that, unlike many other decision problems in which integers are part of the
input, here the computational complexity remains the same (the problem is
PSPACE-complete) irrespective of whether the number r of moves is given in
unary or in binary. The reason is that if r is bigger than max{|A|, |B|}, then
r can be replaced by max{|A|, |B|}; moreover, this quantity is given in unary,
since at least max{|A|, |B|} bits are needed to encode A and B.
As shown in Sect.2.3, ﬁrst-order logic has severely limited expressive power
on ﬁnite graphs. In particular, none of the queries Disconnectivity, k-
Colorability, for k ≥2, and Hamiltonian Path is ﬁrst-order deﬁnable on
the class of all ﬁnite graphs. Recall also that these queries are easily expressible
in existential second-order logic ESO, one of the two syntactically simplest
fragments of second-order logic. This increase in expressive power, however,
is accompanied by an increase in complexity.
Proposition 2.4.6. The data complexity of ESO is NP-complete.
Proof. Let Ψ be a ﬁxed ESO-sentence (∃S1) · · · (∃Sm)ϕ(S1, . . . , Sm), where
ϕ(S1, . . . , Sm) is a ﬁrst-order sentence. Given a ﬁnite structure A, one can
check that A |= Ψ by ﬁrst “guessing” relations S′
1, . . . , S′
m on A and then

54
2 On the Expressive Power of Logics on Finite Models
verifying that (A, S′
1, . . . , S′
m) |= ϕ(S1, . . . , Sm). This computation can be
carried out in nondeterministic polynomial time, since the size of the relations
guessed is polynomial in |A| and the data complexity of ﬁrst-order logic is in
P. Consequently, the data complexity of ESO is in NP.
Since 3-Colorability is deﬁnable by a monadic ESO-sentence and it is
an NP-complete problem, it follows that the data complexity of monadic ESO
is NP-complete; hence, the data complexity of ESO is also NP-complete. 2
Vardi [67] has shown that both the expression complexity of ESO and
the combined complexity of ESO are NEXPTIME-complete; this is another
instance of the exponential-gap phenomenon between the data complexity and
the expression (and combined) complexity of a logic.
The link between the data complexity of ESO and NP turns out to be much
stronger. The exact connection is provided by the following result, which has
become known as Fagin’s Theorem and constitutes the prototypical result of
descriptive complexity.
Theorem 2.4.7. [21] The following are equivalent for a Boolean query Q on
the class F of all ﬁnite σ-structures:
•
Q is in NP.
•
Q is ESO-deﬁnable on F.
In other words, NP = ESO on F.
Fagin’s Theorem asserts that, in a precise sense, ESO captures NP on the
class of all ﬁnite structures and, thus, provides a logic-based and machine-
independent characterization of NP. Moreover, it makes it possible to refor-
mulate the “NP
?= coNP” question in terms of logic alone.
Corollary 2.4.8. The following statements are equivalent:
•
NP is closed under complements (in other words, NP = coNP).
•
ESO is closed under complements on the class F of all ﬁnite structures
(in other words, ESO[F] = USO[F]).
•
3-Colorability is USO-deﬁnable on the class of all ﬁnite graphs.
•
Hamiltonian Path is USO-deﬁnable on the class of all ﬁnite graphs.
Proof. The result follows from Fagin’s Theorem (Theorem 2.4.7) and the NP-
completeness of 3-Colorability and Hamiltonian Path. 2
2.5 Ehrenfeucht–Fra¨ıss´e Games for Existential
Second-Order Logic
In
this
section,
we
consider
certain
extensions
of
the
Ehrenfeucht–
Fra¨ıss´e games that are powerful enough to characterize deﬁnability in exis-
tential second-order logic.

2.5 Ehrenfeucht–Fra¨ıss´e Games for Existential Second-Order Logic
55
Deﬁnition 2.5.1. Let s1, . . . , sk, r be positive integers, let σ be a vocabu-
lary, and let A, B be two σ-structures. The (⟨s1, . . . , sk⟩, r) Ehrenfeucht–
Fra¨ıss´e game on A and B is played according to the following rules. In a run
of the game:
•
The Spoiler picks relations S1, . . . , Sk of arities s1, . . . , sk on A.
•
The Duplicator picks relations S′
1, . . . , S′
k of arities s1, . . . , sk on B.
•
After
this,
the
two
players
engage
in
a
run
of
the
r-move
Ehrenfeucht–Fra¨ıss´e game on the expanded structures (A, S1, . . . , Sk) and
(B, S′
1, . . . , S′
k).
•
Let (a1, b1), . . . , (ar, br) be the elements of A×B picked by the two players
in their r moves. The Duplicator wins this run if the mapping
ai →bi, 1 ≤i ≤r, and cA
i →cB
j , 1 ≤j ≤s,
is a partial isomorphism, that is, an isomorphism between the substructure
(A, S1, . . . , Sk) ↾{a1, . . . , ar} of (A, S1, . . . , Sk) generated by {a1, . . . , ar}
and the substructure (B, S′
1, . . . , S′
k) ↾{b1, . . . , br} of (B, S′
1, . . . , S′
k) gen-
erated by {b1, . . . , br}. Otherwise, the Spoiler wins the run.
•
The Duplicator wins the (⟨s1, . . . , sk⟩, r) game on A and B if the Duplica-
tor can win every run of the game, i.e., if (s)he has a winning strategy for
this game. Otherwise, the Spoiler wins the (⟨s1, . . . , sk⟩, r)-Ehrenfeucht–
Fra¨ıss´e game on A and B.
Using Theorem 2.3.8 and the semantics of existential second-order logic,
it is quite straightforward to establish the following result.
Proposition 2.5.2. Let Ψ be an ESO-sentence of the form (∃P1) · · · (∃Pk)ψ,
where each Pi is a relation symbol of arity si and ψ is a ﬁrst-order sentence
of quantiﬁer rank r. If A |= Ψ and the Duplicator wins the (⟨s1, . . . , sk⟩, r)
Ehrenfeucht–Fra¨ıss´e game on A and B, then B |= Ψ.
In turn, this result gives rise to a combinatorial method for establishing
limitations on the expressive power of existential second-order logic on arbi-
trary classes of structures. Moreover, it is not hard to show that the method
is complete as well.
Method 2.5.3 The Method of Ehrenfeucht–Fra¨ıss´e Games for ESO.
Let σ be a vocabulary, C a class of σ-structures, and Q a Boolean query on C.
Soundness. To show that Q is not ESO-deﬁnable on C, it suﬃces to show
that for every sequence of positive integers s1, . . . , sk, r, there are struc-
tures A and B in C such that
•
Q(A) = 1 and Q(B) = 0;
•
the Duplicator wins the (⟨s1, . . . , sk⟩, r) Ehrenfeucht–Fra¨ıss´e game on
A and B.

56
2 On the Expressive Power of Logics on Finite Models
Completeness. This method is also complete, i.e., if Q is not ESO-deﬁnable
on C, then for every sequence s1, . . . , sk, r of positive integers, such struc-
tures A and B exist.
Corollary 2.4.8 and Method 2.5.3 imply that the NP
?= coNP question is
equivalent to a problem about combinatorial games.
Corollary 2.5.4. The following statements are equivalent:
•
NP ̸= coNP;
•
For every s1, . . . , sk, r, there are ﬁnite graphs G and H such that
–
G is not 3-Colorable and H is 3-Colorable;
–
the Duplicator wins the (⟨s1, . . . , sk⟩, r) Ehrenfeucht–Fra¨ıss´e game on
G and H.
Although (⟨s1, . . . , sk⟩, r) Ehrenfeucht–Fra¨ıss´e games yield a sound and
complete method for studying ESO-deﬁnability (and thus potentially leading
to the separation of NP from coNP), so far this approach has had rather
limited success. The reason is that formidable combinatorial diﬃculties arise
in implementing this method when one of the integers si is bigger than 1, that
is, when dealing with ESO-formulas in which at least one of the existentially
quantiﬁed second-order variables has an arity bigger than 1. Nonetheless,
this method has made it possible to obtain lower bounds for deﬁnability in
monadic ESO, which is the fragment of existential second-order logic that can
be analyzed using (⟨1, 1, . . . , 1⟩, r) Ehrenfeucht–Fra¨ıss´e games.
In certain cases, the study of ESO-deﬁnability can be made easier using
a variant of the (⟨s1, . . . , sk⟩, r) Ehrenfeucht–Fra¨ıss´e games that has become
known as Ajtai–Fagin games. In what follows in this section, we present the
intuition behind the Ajtai–Fagin games and highlight some of their appli-
cations to the study of deﬁnability in monadic ESO. The ﬁrst observation is
that, when the method of Ehrenfeucht–Fra¨ıss´e games or one of their variants is
used to show that a particular query is not deﬁnable in a certain logic, one can
expand the scope of the game and view the selection of the structures A and B
as being part of the Duplicator’s moves. Now, one of the main diﬃculties with
the (⟨s1, . . . , sk⟩, r) Ehrenfeucht–Fra¨ıss´e games is that in eﬀect the Duplicator
has to select the structure B before the Spoiler has picked relations S1, . . . , Sk
on A. To make the Duplicator’s task easier, Ajtai and Fagin [4] introduced a
variant of the (⟨s1, . . . , sk⟩, r) Ehrenfeucht–Fra¨ıss´e games in which the Dupli-
cator selects the structure B after the Spoiler has picked relations S1, . . . , Sk
on A. The next deﬁnition introduces the Ajtai–Fagin games for monadic ESO;
it can be easily extended to games for the full ESO with notational modiﬁca-
tions only.
Deﬁnition 2.5.5. Let C be a class of σ-structures, Q a Boolean query on C,
and k, r two positive integers. The (k, r) Ajtai–Fagin game for Q on C is
played according to the following rules. In a run of the game:

2.5 Ehrenfeucht–Fra¨ıss´e Games for Existential Second-Order Logic
57
•
The Duplicator picks a structure A ∈C such that Q(A) = 1.
•
The Spoiler picks k unary relations S1, . . . , Sk on A (i.e., k subsets of A).
•
The Duplicator picks a structure B ∈C such that Q(B) = 0 and then picks
k unary relations S′
1, . . . , S′
k on B (i.e., k subsets of B).
•
After
this,
the
two
players
engage
in
a
run
of
the
r-move
Ehrenfeucht–Fra¨ıss´e game on the expanded structures (A, S1, . . . , Sk) and
(B, S′
1, . . . , S′
k).
The winning conditions are as in Deﬁnition 2.5.1.
Note that another diﬀerence between the Ajtai–Fagin games and the
Ehrenfeucht–Fra¨ıss´e games considered earlier is that each Ajtai–Fagin game
is deﬁned with respect to a particular Boolean query, i.e., the query itself is
one of the parameters of the game. The Ajtai–Fagin games give rise to the
following method for investigating deﬁnability in monadic ESO.
Method 2.5.6 The Method of Ajtai–Fagin Games for monadic ESO.
Let σ be a vocabulary, C a class of σ-structures, and Q a Boolean query on C.
Soundness. To show that Q is not monadic ESO-deﬁnable on C, it suﬃces
to show that for every k and every r, the Duplicator wins the (k, r) Ajtai–
Fagin game for Q on C.
Completeness. This method is also complete, i.e., if Q is not monadic ESO-
deﬁnable on C, then for every k and every r, the Duplicator wins the (k, r)
Ajtai–Fagin game for Q on C.
Fagin [22] showed that the Connectivity query is not monadic ESO-
deﬁnable on the class of all ﬁnite graphs, using Ehrenfeucht–Fra¨ıss´e games for
monadic ESO. Later on, Fagin, Stockmeyer and Vardi [25] obtained a much
simpler proof of this result using Ajtai–Fagin games for monadic ESO and
Theorem 2.3.26 about d-equivalence.
Theorem 2.5.7. The Connectivity query is not monadic ESO-deﬁnable
on the class of all ﬁnite graphs.
Proof. (Sketch) We shall show that, for every positive integer k and every
positive integer r, the Duplicator wins the (k, r) Ajtai–Fagin game for Con-
nectivity on the class of all ﬁnite graphs.
Suppose that k is a positive integer, A = (A, E) is an undirected cycle,
and S1, . . . , Sk are unary relations on A. For every node b ∈A, we deﬁne the
color of b to be the Boolean vector c(b) = (c1, . . . , ck) such that if b ∈Si,
then ci = 1; otherwise, ci = 0. Note that the number of colors depends only
on k. Moreover, it is easy to see that, for every d ≥1 and every a ∈A, the
neighborhood N(a, d) of a in (A, S1, . . . , Sk) consists of 2d −1 points whose
distance from a in A is at most d, and is completely determined by the colors
of these points (this, of course, hinges on the fact that each Si is a unary
relation on A). Consequently, the number of diﬀerent d-types depends only
on k and d (and not on the cardinality |A| of A).

58
2 On the Expressive Power of Logics on Finite Models
Using these facts, we can show that the Duplicator wins the (k, r) Ajtai–
Fagin game for Connectivity on the class of all ﬁnite graphs by playing
according to the following strategy:
•
The Duplicator picks a large enough cycle A such that, for all unary
relations S1, . . . , Sk on A, there are at least 4d points with the same d-
type in (A, S1, . . . , Sk), where d = 3r−1.
•
After the Spoiler picks unary relations S1, . . . , Sk on A, there are two nodes
ap and aq in A that have the same d-type and are such that N(ap, 2d) ∩
N(aq, 2d) = ∅.
•
The Duplicator constructs B = B0 ⊕B1, consisting of two disjoint cycles
B0 and B1 constructed as follows:
–
The Duplicator disconnects A by “pinching” it at ap, aq.
–
The Duplicator creates B0 by joining ap and aq+1 in the ﬁrst compo-
nent.
–
The Duplicator creates B1 by joining ap+1 and aq in the second com-
ponent.
•
Finally, the Duplicator picks the same unary relations S1, . . . , Sk in B as
the ones picked by the Spoiler on A.
Note that the structures (A, S1, . . . , Sk) and (B, S1, . . . , Sk) are d-equivalent,
as it is not too hard to verify that each node in A has the same d-type as
its “clone” in B. Consequently, the Duplicator wins the r-move Ehrenfeucht–
Fra¨ıss´e game on these structures. 2
Since the Disconnectivity query is monadic ESO-deﬁnable on the class
of all ﬁnite graphs, we obtain the following separation between monadic ESO
and monadic USO on ﬁnite graphs.
Corollary 2.5.8. Monadic ESO is not closed under complements on the class
of all ﬁnite graphs.
It should be pointed out that Theorem 2.5.7 and Corollary 2.5.8 do not
have any implications for the NP
?= coNP problem, because Connectivity is
a polynomial-time-computable query and monadic ESO cannot express all NP
queries. Any breakthroughs towards the separation of NP from coNP using
combinatorial games will entail proving limitations on the expressive power of
existential second-order formulas in which the existentially quantiﬁed second-
order variables have an arity bigger than one. So far, however, the successes
of combinatorial games have been essentially limited to monadic existential
second-order logic. In particular, the following test problem is open.
Problem 2.5.9. Show that there is a Boolean query Q on ﬁnite graphs such
that
•
Q is in NP (and hence Q is ESO-deﬁnable);
•
Q is not binary ESO-deﬁnable, i.e., Q is not deﬁnable by any ESO-sentence
(∃P1) · · · (∃Pk)ψ, where each Pi is a binary relation symbol.

2.6 Logics with Fixed-Point Operators
59
Nonetheless, combinatorial games have been successfully used to establish
limitations on the expressive power of monadic ESO over the class of ﬁnite
graphs with “built-in” predicates, such as a successor relation [16] or a total
order [59]. Such results are viewed as the ﬁrst stepping stone towards analyzing
deﬁnability in binary existential second-order logic.
Theorem 2.5.10. The Connectivity query is not monadic ESO-deﬁnable
on the class of ﬁnite structures with successor, i.e., ﬁnite structures of the
form G = (V, E, Suc), where E is a binary relation on V and Suc is the graph
of a successor function on V .
Theorem 2.5.11. The Connectivity query is not monadic ESO-deﬁnable
on the class of ﬁnite ordered graphs, i.e., ﬁnite structures of the form
G = (V, E, ≤), where E is a binary relation on V
and ≤is a linear
order on V .
2.6 Logics with Fixed-Point Operators
In Sect. 2.3, we used Ehrenfeucht–Fra¨ıss´e games to establish that ﬁrst-order
logic has severely limited expressive power on the class G of all ﬁnite graphs; in
particular, ﬁrst-order logic fails to express such basic polynomial-time com-
putable queries as Transitive Closure, Acyclicity, 2-Colorability,
Eulerian, and Planarity. Several diﬀerent mechanisms can be used to
augment the syntax of ﬁrst-order logic, so that the resulting logic has strictly
higher expressive power on ﬁnite structures. We have already seen that second-
order quantiﬁcation is such a mechanism. In fact, Fagin’s Theorem (Theorem
2.4.7) calibrates the exact gain in expressive power that is achieved when
only existential second-order quantiﬁcation in preﬁx form is allowed; more-
over, it implies that, unless P = NP, even the syntactically simplest frag-
ments of second-order logic can express queries that are not polynomial-time
computable.
As mentioned earlier, the limited expressive power of ﬁrst-order logic on
ﬁnite graphs can be interpreted as an inability to express recursion. This real-
ization suggests that higher expressive power can also be achieved by augment-
ing the syntax of ﬁrst-order logic with mechanisms that embody recursion.
Perhaps the most natural such mechanism is to use ﬁxed points of operators
that describe recursive speciﬁcations; this approach has been used fruitfully in
many diﬀerent areas of computer science, including computability theory, logic
programming, and the denotational semantics of programming languages. As
a motivating example, let us consider the factorial function f(n), n ≥0, which
is usually deﬁned inductively as




f(0) = 1
f(n) = nf(n −1).

60
2 On the Expressive Power of Logics on Finite Models
Alternatively, the factorial function can be deﬁned as a ﬁxed point of the
recursive speciﬁcation
f = λn.(n = 0 →1 □nf(n −1)).
Observe that the building blocks of the above recursive speciﬁcation are opera-
tions on functions, such as deﬁnition by cases and multiplication. Here, we are
interested in developing a formalism for specifying queries recursively. The key
idea is to describe recursive speciﬁcations using formulas of ﬁrst-order logic
and then to augment the syntax of ﬁrst-order logic with ﬁxed points of such
speciﬁcations. Before making this idea precise, we need to develop the basics
of ﬁxed-point theory.
2.6.1 Operators and Fixed Points
Let A be a set and k a positive integer. A k-ary operator on A is a mapping
Φ : P(Ak) →P(Ak), where P(Ak) is the power set of Ak (that is, the set of
all k-ary relations on the universe A of A).
A k-ary relation P is a ﬁxed point of the operator Φ if P = Φ(P). Thus,
every ﬁxed point of Φ satisﬁes the recursive speciﬁcation
(x1, . . . , xk) ∈P ⇐⇒(x1, . . . , xk) ∈Φ(P).
An operator may have no ﬁxed points whatsoever or it may have more than
one ﬁxed point. For instance, the unary operator Φ(P) = P, where P is the
complement of P, has no ﬁxed points. In contrast, let Φ be a binary operator
such that if G = (V, E) is a graph and P is a binary relation on V , then
Φ(P) = {(a, b) : G |= E(a, b) ∨P(a, b) ∨(∃z)(E(a, z) ∧P(z, b))}.
This operator may have several ﬁxed points, since every transitive relation P
containing the edge relation is a ﬁxed point of it.
A k-ary relation P ∗is the least ﬁxed point of Φ if P ∗is a ﬁxed point of Φ
and, for every ﬁxed point P of Φ, we have that P ∗⊆P. We write lfp(Φ) to
denote the least ﬁxed point of Φ (if it exists). For instance, if Φ is the above
binary operator on graphs G = (V, E), then lfp(Φ) is the transitive closure of
the relation E. The property of having a least ﬁxed point is shared by every
operator that is monotone; furthermore, the least ﬁxed point of a monotone
operator can be obtained by iterating the operator. We now spell out these
concepts and facts in precise terms.
Deﬁnition 2.6.1. Let Φ : P(Ak) →P(Ak) be a k-ary operator on a set A.
•
The ﬁnite stages Φn, n ≥1, of Φ are deﬁned by the induction




Φ1
= Φ(∅)
Φn+1 = Φ(n
m=1 Φm).

2.6 Logics with Fixed-Point Operators
61
In general, for every ordinal α, the stage Φα of Φ is deﬁned by the trans-
ﬁnite induction
Φα = Φ(
β<α Φβ).
We write Φ∞= 
α Φα for the union of all stages of Φ.
•
The operator Φ is monotone, if for every two k-ary relations P1, P2 on A
such that P1 ⊆P2, we have that Φ(P1) ⊆Φ(P2).
The next result, which is known as the Knaster–Tarski Theorem, describes
the fundamental properties of monotone operators.
Theorem 2.6.2. [43, 64] Let Φ be a monotone k-ary operator on a set A.
•
The sequence of stages of Φ is monotone, that is, if α < β, then Φα ⊆Φβ.
Consequently, for every ordinal α, we have that Φα+1 = Φ(Φα).
•
Φ has a least ﬁxed point lfp(Φ).
•
There is an ordinal γ < |Ak|+, where |Ak|+ is the smallest cardinal greater
than the cardinal |Ak| of Ak, such that
lfp(Φ) = Φ∞= Φγ = Φδ, for every δ > γ.
In particular, if A is a ﬁnite set, then there is an integer s ≤|A|k such
that
lfp(Φ) = Φ∞= Φs = Φδ, for every δ > s.
•
The least ﬁxed point of Φ is equal to the intersection of all ﬁxed points
of Φ.
Proof. Since Φ is monotone, it is easy to show by transﬁnite induction that
the sequence of stages is also monotone, that is, if α < β, then Φα ⊆Φβ. Since
each Φα is a k-ary relation on A, it has at most |Ak| elements. It follows that
there must exist an ordinal γ < |Ak|+ such that Φγ = Φγ+1. Consequently,
Φγ is a ﬁxed point of Φ, and also Φ∞= Φγ = Φδ, for every δ > γ. Moreover,
using the monotonicity of Φ again, it is easy to show by transﬁnite induction
that if P is a ﬁxed point of Φ, then Φα ⊆P, for every α. Consequently, Φγ
is the least ﬁxed point lfp(Φ) of Φ, and also the intersection of all of its ﬁxed
points. 2
Deﬁnition 2.6.3. Let Φ be a monotone k-ary operator on a set A. The
closure ordinal of Φ, denoted by cl(Φ), is the smallest ordinal γ such that
Φγ = 
β<γ Φβ.
Note that if A is a ﬁnite set, then cl(Φ) is a positive integer.
Let Φ be a k-ary operator on a set A. A k-ary relation P ∗is the greatest
ﬁxed point of Φ if P ∗is a ﬁxed point of Φ and, for every ﬁxed point P of Φ,
we have that P ⊆P ∗. We write gfp(Φ) to denote the greatest ﬁxed point of
Φ (if it exists). Every monotone operator has a greatest ﬁxed point that can
be obtained via an iteration that is dual to the iteration used to obtain the

62
2 On the Expressive Power of Logics on Finite Models
least ﬁxed point of the operator. Speciﬁcally, the dual stages Φα of Φ, where
α is an ordinal, are deﬁned by the transﬁnite induction




Φ1 = Φ(Ak)
Φα = Φ(
β<α Φβ).
We also write Φ∞= 
α Φα for the intersection of all dual stages of Φ. If Φ is
monotone, then its greatest ﬁxed point gfp(Φ) is equal to Φ∞and also equal
to the union of all ﬁxed points of Φ. Moreover, there is an ordinal γ < |Ak|+
such that
gfp(Φ) = Φ∞= Φγ = Φδ, for every δ > γ.
The duality relationship between the least ﬁxed point and the greatest
ﬁxed point of a monotone k-ary operator Φ can also be seen by considering the
dual operator ˘Φ of Φ, where ˘Φ(P) = Φ(P) and P = Ak −P is the complement
of P. If Φ is a monotone operator, then so is its dual ˘Φ. Moreover, using
transﬁnite induction, it is easy to show that ˘Φα = Φα, for every ordinal α.
Consequently, gfp(Φ) = lfp( ˘Φ). Similarly, it is easy to show that lfp(Φ) =
gfp( ˘Φ).
As an example of an operator with interesting greatest ﬁxed points, let Φ
be a binary operator such that if G = (V, E) is a graph and P is a binary
relation on V , then
Φ(P) = {(a, b) : G |= (∀a′)(E(a, a′) →(∃b′)(E(b, b′) ∧P(a′, b′))) ∧
(∀b′)(E(b, b′) →(∃a′)(E(a, a′) ∧P(a′, b′)))}.
The greatest ﬁxed point gfp(Φ) of Φ is the greatest bisimulation relation on
G = (V, E); the concept of bisimulation plays an important role in modal
logic [66] and also in the semantics of concurrent processes [53]. The same
example can also be used to illustrate the concept of the dual operator ˘Φ of
Φ, which in this case is deﬁned by
˘Φ(P) = {(a, b) : G |= (∃a′)(E(a, a′) ∧(∀b′)(E(b, b′) →P(a′, b′))) ∧
(∃b′)(E(b, b′) ∧(∀a′)(E(a, a′) →P(a′, b′)))}.
In what follows, we shall focus on operators that are deﬁnable using for-
mulas of some logical formalism. Let σ be a vocabulary, S a k-ary relation
symbol not in σ, and ϕ(x1, . . . , xk, S) a formula of some logic over the vocab-
ulary σ ∪{S} with free variables among x1, . . . , xk. On every σ-structure A,
the formula ϕ(x1, . . . , xk, S) gives rise to a k-ary operator Φ : P(Ak) →P(Ak)
such that if P is a k-ary relation on A, then
Φ(P) = {(a1, . . . , ak) : A |= ϕ(a1, . . . , ak, P)}.
For instance, both the operator whose least ﬁxed point is the transitive closure
of the edge relation E of a graph G = (V, E) and the operator whose greatest

2.6 Logics with Fixed-Point Operators
63
ﬁxed point is the greatest bisimulation relation on G = (V, E) are deﬁnable
using ﬁrst-order formulas. In what follows, we shall use the terms “the least
ﬁxed point of a formula” and “the greatest ﬁxed point of a formula” for the
least ﬁxed point and the greatest ﬁxed point, respectively, of the operator
associated with the formula. Similarly, we shall use the term “the closure
ordinal of a formula” for the closure ordinal of the operator associated with
the formula, and we shall denote it by cl(ϕ).
Operators also arise from formulas with parameters. Speciﬁcally, assume
that σ is a vocabulary, S1, S2, . . . , Sm are relation symbols not in σ, and
ϕ(x1, . . . , xk, y1, . . . , yn, S1, . . . , Sm) is a formula of some logic over the vocab-
ulary σ
∪
{S1, . . . , Sm} with free variables among x1, . . . , xk, y1, . . . , yn.
Assume also that the arity of the relation symbol Si is equal to k. For every
σ-structure A, every sequence b1, . . . , bn of elements from the universe A of A,
and every sequence T1, . . . , Ti−1, Ti+1, . . . , Tm of relations on A whose arities
match those of S1, . . . , Si−1, Si+1, . . . , Sm, the formula ϕ gives rise to a k-ary
operator Φ : P(Ak) →P(Ak) such that
Φ(P) = {a : A |= ϕ(a, b, T1, . . . , Ti−1, P, Ti+1, . . . , Tm)},
where a = (a1, . . . , ak) and b = (b1, . . . , bn). Note that operators with param-
eters can also be thought of as operators (without parameters) on structures
expanded with the given parameters.
As an example, let ϕ(x1, y1, S) be the ﬁrst-order formula E(y1, x1) ∨
(∃z)(S(z) ∧E(z, x1)), in which y1 is a parameter. If G = (V, E) is a graph
and a is a node in V , then this formula gives rise to a unary operator Φ such
that
Φ(P) = {b : G |= E(a, b) ∨(∃z)(P(z) ∧E(z, b))}.
The least ﬁxed point lfp(Φ) then consists of all nodes b in V that are reachable
from a. Similarly, let ϕ(x1, y1, S1, S2) be the ﬁrst-order formula E(y1, x1) ∨
(∃z)(S1(z)∧S2(z)∧E(z, x1)), in which y1 and S2 are parameters. If G = (V, E)
is a graph, a is a node in V , and T is a subset of V , then this formula gives
rise to a unary operator Φ such that
Φ(P) = {b : G |= E(a, b) ∨(∃z)(P(z) ∧T (z) ∧E(z, b))}.
The least-ﬁxed point lfp(Φ) then consists of all nodes b in V that are reachable
from a via a path in which every intermediate node is in T .
It is easy to see that if ϕ(x1, . . . , xk, S) is an arbitrary ﬁrst-order formula
over the vocabulary σ ∪{S}, then, for every n ≥1, there is a ﬁrst-order
formula ϕn(x1, . . . , xk) over the vocabulary σ such that it deﬁnes the nth stage
Φn of the operator Φ associated with ϕ(x1, . . . , xk, S) on every σ-structure
A. Consequently, if ϕ(x1, . . . , xk, S) is a ﬁrst-order formula such that the
associated operator Φ is monotone on every ﬁnite σ-structure, then for every
ﬁnite σ-structure A, there is an integer s such that the least ﬁxed point lfp(Φ)
of Φ is deﬁnable by ϕs(x1, . . . , xk) on A. In general, however, this integer

64
2 On the Expressive Power of Logics on Finite Models
depends on A, and there may be no integer s such that ϕs(x1, . . . , xk) deﬁnes
the least ﬁxed point lfp(Φ) of Φ on every ﬁnite σ-structure, because lfp(Φ) may
not be ﬁrst-order deﬁnable. For instance, if ϕ(x, y, S) is the formula E(x, y) ∨
(∃z)(E(x, z)∧S(z, y)), then the least ﬁxed point lfp(Φ) is the transitive closure
of E; moreover, for every n ≥1, ϕn(x, y) is a ﬁrst-order formula asserting
that there is a path of length at most n from x to y. This formula deﬁnes the
transitive closure of E on every ﬁnite graph of diameter at most n, but, as
we have seen earlier, there is no ﬁrst-order formula that deﬁnes the transitive
closure of E on every ﬁnite graph.
2.6.2 Least Fixed-Point Logic
We now examine how to augment the syntax of ﬁrst-order logic with least ﬁxed
points and greatest ﬁxed points of operators deﬁnable by logical formulas.
Since we want our operators to be monotone, it is natural to focus on formulas
that give rise to monotone operators.
Let σ be a vocabulary, C a class of σ-structures, and ϕ(x1, . . . , xk, S)
a formula of some logic over the vocabulary σ ∪{S}, where S is a k-
ary relation symbol and the free variables of ϕ are among x1, . . . , xk.
We say that ϕ(x1, . . . , xk, S) is monotone on C if, for every structure
A ∈C, the operator Φ associated with ϕ(x1, . . . , xk, S) is monotone. More
generally, let ϕ(x1, . . . , xk, y1, . . . , yn, S, S1, . . . , Sm) be a formula of some
logic over the vocabulary σ ∪{S, S1, . . . , Sm}, where S is a k-ary rela-
tion symbol and the free variables of ϕ are among x1, . . . , xk, y1, . . . , yn.
We say that ϕ(x1, . . . , xk, y1, . . . , yn, S, S1, . . . , Sm) is monotone on C if,
for every structure A ∈C, every sequence b1, . . . , bn of elements from
the universe A of A, and every sequence T1, . . . , Tm of relations on
A whose arities match those of S1, . . . , Sm, the operator Φ associated
with the formula ϕ(x1, . . . , xk, y1, . . . , yn, S, S1, . . . , Sm) and the parameters
b1 . . . , bn, T1, . . . , Tm is monotone.
So, it is tempting to consider augmenting the syntax of ﬁrst-order logic
with the least ﬁxed points and the greatest ﬁxed points of ﬁrst-order formulas
that are monotone on the class F of all ﬁnite σ-structures. Serious diﬃculties
arise in doing so, however. Speciﬁcally, it is known that there is no algorithm
for testing whether a given ﬁrst-order formula is monotone on F [5]. Con-
sequently, if the syntax of ﬁrst-order logic is augmented with the least ﬁxed
points of ﬁrst-order formulas that are monotone on F, then the resulting logic
does not have an eﬀective syntax. One way to bypass this obstacle is to restrict
attention to positive formulas, since positivity is a syntactic property of for-
mulas that implies monotonicity and is easily checkable. More precisely, let
ϕ(S) be a ﬁrst-order formula over a vocabulary containing a k-ary relation
symbol S. We say that ϕ(S) is positive in S if every occurrence of S in ϕ(S) is
within an even number of negations. Equivalently, a ﬁrst-order formula ϕ(S)
is positive in S if and only if, after all occurrences of the negation symbol
in ϕ(S) are “pushed inside”, no occurrence of S is negated in the resulting

2.6 Logics with Fixed-Point Operators
65
formula. It is easy to verify that if ϕ(x1, . . . , xk, S) is positive in S and the
free variables of ϕ(x1, . . . , xk, S) are among x1, . . . , xk, then it is monotone
on the class S of all σ-structures (ﬁnite and inﬁnite). Moreover, there is a
linear-time algorithm for testing whether a given ﬁrst-order formula is posi-
tive. At this point, it is also worth recalling a classical result in mathematical
logic to the eﬀect that if a ﬁrst-order formula is monotone on the class S of
all σ-structures (ﬁnite and inﬁnite), then it is logically equivalent to a posi-
tive ﬁrst-order formula. Thus, positivity is a syntactic property of ﬁrst-order
formulas that, up to logical equivalence, exhausts the semantic property of
monotonicity of ﬁrst-order formulas on S.
In view of the above, we shall augment the syntax of ﬁrst-order logic with
the least ﬁxed point and the greatest ﬁxed point of operators deﬁnable by
positive ﬁrst-order formulas. However, in order to obtain a logic whose syntax
is closed under the formation rules used, we shall close the syntax under
applications of the operations of ﬁrst-order logic (that is, Boolean connectives
and ﬁrst-order quantiﬁcation) and also under applications of least ﬁxed points
and greatest ﬁxed points of positive formulas, where, as with ﬁrst-order logic,
a formula ϕ(S) of the extended formalism is positive in a relation symbol
S if every occurrence of S in ϕ(S) is within an even number of negations.
The resulting logic is least ﬁxed-point logic LFP, whose precise syntax and
semantics are given in the next deﬁnition.
Deﬁnition 2.6.4. Let σ be a vocabulary and let S1, . . . , Sn, . . . be a sequence
of relation symbols such that for every m ≥1, this sequence contains inﬁnitely
many relation symbols of arity m.
LFP Syntax. The collection of LFP-formulas over σ is deﬁned inductively
as follows:
•
Every atomic formula θ over σ ∪{S1, . . . , Sn, . . .} is an LFP-formula.
The set free(θ) is the union of the set of all ﬁrst-order variables occur-
ring in θ and the set of all relation symbols Si occurring in θ.
•
If ϕ and ψ are LFP-formulas, then so are ¬ϕ, ϕ∧ψ, ϕ∨ψ. Moreover,
free(¬ϕ) = free(ϕ), and free(ϕ ∧ψ) = free(ϕ ∨ψ) = free(ϕ) ∪free(ψ).
•
If ϕ is an LFP-formula and x is a ﬁrst-order variable, then ∃xϕ
and ∀xϕ are LFP-formulas. Moreover, free(∃xϕ) = free(∀xϕ) =
free(ϕ) \ {x}.
•
Assume that ϕ is an LFP-formula, Si is a k-ary relation symbol in
free(ϕ) which is positive in ϕ (that is, every occurrence of Si in
ϕ is within an even number of negation symbols), x = (x1, . . . , xk)
is a k-tuple of ﬁrst-order variables each of which is in free(ϕ), and
u = (u1, . . . , uk) is a k-tuple of ﬁrst-order variables not occurring in
ϕ. Then the expressions [lfp Six.ϕ](u) and [gfp Six.ϕ](u) are LFP-
formulas. Moreover, free([lfp Six.ϕ](u)) = free([gfp Six.ϕ](u)) =
(free(ϕ) \ {x1, . . . , xk, Si}) ∪{u1, . . . , uk}.
Notation.
If ϕ is such that Si is the only relation symbol from
S1, . . . , Sn, . . . that occurs free in ϕ and all free ﬁrst-order variables

66
2 On the Expressive Power of Logics on Finite Models
of ϕ are among x = (x1, . . . , xk), then we shall often write ϕ∞(u)
instead of [lfp Six.ϕ](u).
LFP Semantics. The semantics of least ﬁxed-point logic is deﬁned by a
straightforward induction on the construction of LFP-formulas. For
instance, the semantics of [lfp Six.ϕ](u) is the least ﬁxed point of
the operator associated with ϕ on a σ-structure A and parameters
from A corresponding to the ﬁrst-order variables and relation symbols
in free([lfp Six.ϕ](u)). Speciﬁcally, assume that ϕ is an LFP-formula
such that free(ϕ) ⊆{x1, . . . , xk, y1, . . . , yn, S1, . . . , Sm} and Si is a k-
ary relation symbol that is positive in ϕ. Write x = (x1, . . . , xk) and
y = (y1, . . . , yn). Let A be a σ-structure, a a k-tuple from A, b an n-
tuple from A, and T1, . . . , Ti−1, Ti+1, . . . , Tm relations on A whose ari-
ties match those of the relation symbols S1, . . . , Si−1, Si+1, . . . Sm. Then
A, a |= [lfp Six.ϕ](u) if a ∈lfp(Φ), where Φ is the k-ary operator on A
such that
Φ(P) = {a ∈Ak : A |= ϕ(a, b, T1, . . . , Ti−1, P, Ti+1, . . . , Tm)}.
Similarly, the semantics of [gfp Six.ϕ](u) is the greatest ﬁxed point
of the operator associated with ϕ on a σ-structure A and parameters
from A corresponding to the ﬁrst-order variables and relation symbols in
free([gfp Six.ϕ](u)).
As an example, if ϕ(x1, y1, S1, S2) is the ﬁrst-order formula E(y1, x1) ∨
(∃z)(S1(z) ∧S2(z) ∧E(z, x1)), then for every graph G = (V, E), every node a
in V , and every subset T of V , the LFP-formula [lfp S1(x1).ϕ](u) deﬁnes the
set of nodes u reachable from a via a path in which every intermediate node
is in T .
The syntax of least ﬁxed-point logic LFP, as presented in Deﬁnition 2.6.4,
allows arbitrary nesting of least ﬁxed points and greatest ﬁxed points, as well
as interleaving of least and greatest ﬁxed points with the operations of ﬁrst-
order logic. Although the full syntax of LFP will be used in other chapters in
this volume, in the remainder of this chapter we shall focus on LFP1, which
is one of the syntactically simplest and most well-studied fragments of LFP.
Informally, LFP1 is the extension of ﬁrst-order logic obtained by augmenting
the syntax of ﬁrst-order logic with the least ﬁxed points of positive formulas
(without parameters) and then closing under conjunctions, disjunctions, and
existential and universal ﬁrst-order quantiﬁcation. The precise deﬁnition of
LFP1 follows.
Deﬁnition 2.6.5. Let σ be a vocabulary. The collection of LFP1-formulas
over σ is deﬁned inductively as follows:
•
Every ﬁrst-order formula over σ is an LFP1-formula over σ.
•
If k is a positive integer, S is a k-ary relation symbol not in σ,
ϕ(x1, . . . , xk, S) is a ﬁrst-order formula over the vocabulary σ ∪{S} that

2.6 Logics with Fixed-Point Operators
67
is positive in S, and u1, . . . , uk are ﬁrst-order variables, then the expres-
sion [lfp Sx.ϕ](u) is an LFP1-formula, where x = (x1, . . . , xk) and
u = (u1, . . . , uk). Since ϕ(x1, . . . , xk, S) contains no parameters, we shall
use the expression ϕ∞(u1 . . . , uk) to denote the formula [lfp Sx.ϕ](u) in
what follows.
•
If φ and ψ are LFP1-formulas over σ, then φ ∧ψ and φ ∨ψ are LFP1-
formulas over σ.
•
If ψ is an LFP1-formula over σ and x is a ﬁrst-order variable, then ∃xψ
and ∀xψ are LFP1-formulas over σ.
Since every LFP1-formula is an LFP-formula, the semantics of LFP1 is inher-
ited from the semantics of LFP.
The study of LFP1-deﬁnable relations on ﬁxed inﬁnite structures is the
focus of Moschovakis’s monograph Elementary Induction on Abstract Struc-
tures [54], where they are called inductive relations. It should also be pointed
out that in Immerman’s book Descriptive Complexity [40], LFP is denoted by
FO(LFP) (the closure of FO under least ﬁxed points) and LFP1 is denoted
by LFP(FO) (least ﬁxed points of ﬁrst-order formulas).
Note that LFP1-formulas are closed under the positive operations of ﬁrst-
order logic, but they are not closed under negation. Consequently, for every
class C of σ-structures, it is an interesting problem to determine whether or not
the collection of LFP1-deﬁnable queries on C is closed under complements. In
what follows, we shall explore the expressive power of LFP1 on the class F of
all ﬁnite σ-structures and we shall also study the complementation problem
for LFP1-deﬁnable queries on F. We begin by presenting several examples
that illustrate the expressive power of LFP1 on ﬁnite structures.
Example 2.6.6. Transitive Closure and Connectivity. Let ϕ(x, y, S) be
the existential and positive in S ﬁrst-order formula
E(x, y) ∨(∃z)(E(x, z) ∧S(z, y)).
As seen earlier, ϕ∞(x, y) deﬁnes the Transitive Closure query T C on the
class of all graphs G = (V, E). Thus, T C is an example of a query that is
LFP1-deﬁnable, but not FO-deﬁnable. Note that for every graph G = (V, E)
(ﬁnite or inﬁnite), we have that cl(ϕ) ≤ω.
Observe that the LFP1-formula (∀x)(∀y)ϕ∞(x, y) deﬁnes the Connec-
tivity query CN on the class of all graphs; this gives another example of a
query that is LFP1-deﬁnable, but not FO-deﬁnable.
If ψ(x, y, S) is the existential and positive in S ﬁrst-order formula
E(x, y) ∨(∃z)(S(x, z) ∧S(z, y)),
then ψ∞(x, y) is an LFP1-formula that also deﬁnes the Transitive Closure
query T C on the class of all graphs. Although ϕ(x, y, S) and ψ(x, y, S) have
the same least ﬁxed points, their stages behave diﬀerently. Speciﬁcally, for

68
2 On the Expressive Power of Logics on Finite Models
every n ≥1, the nth stage ϕn(x, y) deﬁnes all pairs of nodes that are connected
via a path of length at most n, while the nth stage ψn(x, y) deﬁnes all pairs
of nodes that are connected via a path of length at most 2n. Thus, on a ﬁnite
structure A, we have that cl(ϕ) ≤|A|, while cl(ψ) ≤log(|A|).
Example 2.6.7. Path Systems. Let σ be a vocabulary consisting of a unary
relation symbol and a ternary relation symbol. Thus, a σ-structure is a struc-
ture of the form S = (F, A, R), where A is a subset of F and R is a ternary
relation on F. Such structures can be thought of as encoding proof systems in
which F is a set of formulas, A is a set of axioms, and R is a ternary rule of
inference, such as modus ponens or resolution (that is, R(f, g, h) means that
f can be derived from g and h using the rule R). In this framework, a formula
f ∈F is a theorem of S if either f is one of the axioms in A or it can be
derived from other previously derived theorems g and h of S using the rule of
inference R.
The following unary query, called Path System, arises naturally now:
given a ﬁnite σ-structure S = (F, A, R) and a formula f ∈F, is f a theorem
of S? The computational complexity of this query was investigated by Cook
[13], who showed that it is P-complete under logarithmic space reductions.
In fact, this was the ﬁrst problem shown to be complete for polynomial-time
computability, and its discovery gave rise to the theory of P-completeness
(see [32]).
Using Ehrenfeucht–Fra¨ıss´e games, it can be proved that Path Systems
is not FO-deﬁnable. It is easy to see, however, that Path Systems is LFP1-
deﬁnable. Indeed, if ϕ(x, T) is the existential and positive in T ﬁrst-order
formula
A(x) ∨(∃y)(∃z)(T (y) ∧T (z) ∧R(x, y, z)),
then Path Systems is deﬁnable by the least ﬁxed point ϕ∞(x) of ϕ(x, T ).
Example 2.6.8. Acyclicity. Let ψ(x, S) be the universal and positive in S
ﬁrst-order formula
(∀y)(E(y, x) →S(y)).
Let G = (V, E) be a directed graph. Clearly, the ﬁrst stage ψ1(x) deﬁnes the
set of all nodes x of in-degree equal to 0. Similarly, the second stage ψ2(x)
deﬁnes the set of all nodes x that either have an in-degree equal to 0 or have
the property that if y is a node such that E(y, x), then y has an in-degree
equal to 0. By continuing this analysis for all stages ψn(x), n ≥1, it can be
seen that, on every ﬁnite directed graph G = (V, E), the least ﬁxed point
ψ∞(x) deﬁnes the set of all nodes in V such that “no path down from x leads
to a cycle”, that is, the set of all nodes x such that there is no sequence of
nodes y1, . . . , ym such that E(y1, x), E(y2, y1), . . ., E(ym, ym−1) and such that
ym is a node on a cycle of G. It follows that Acyclicity is an LFP1-deﬁnable
query, since it is deﬁnable by the LFP1-formula (∀x)ψ∞(x).
Although our main focus is on ﬁnite structures, it is worth pointing out
that on every directed graph G = (V, E) (ﬁnite or inﬁnite), the least ﬁxed

2.6 Logics with Fixed-Point Operators
69
point ψ∞(x) of ψ(x, S) deﬁnes the well-founded part of E, that is the set of
all nodes x in V such that there is no inﬁnite descending E-chain E(y1, x),
E(ym+1, ym), m ≥1. For ﬁnite directed graphs, of course, the well-founded
part of E is the set of all nodes x such that no path down from x leads to
a cycle. It should also be pointed out that the closure ordinal of the formula
ψ(x, S) can be arbitrarily large. Indeed, if G = (V, E) is a well-ordering of
rank α, then cl(ψ) = α.
Example 2.6.9. Geography. Every ﬁnite directed graph G = (V, E) gives
rise to a two-person game played according to the following rules: Player I
and Player II take turns to pick nodes in V ; if a is the last node picked, then
the player whose turn is next must pick a node b such that E(a, b), or else
this player loses. This abstracts a game played between two children in which
they take turns to write down the name of a city whose ﬁrst letter is the same
as the last letter of the city written down in the previous step of the game.
Consider now the following unary query, called Geography: given a ﬁnite
directed graph G = (V, E) and a node v in V , is v a winning position for Player
I? It is well known that this query is P-complete (see [32]); moreover, using
Ehrenfeucht–Fra¨ıss´e games, it can be shown that it is not FO-deﬁnable. It is
easy to see, however, that Geography is LFP1-deﬁnable. Indeed, if ϕ(x, S)
is the universal-existential and positive in S ﬁrst-order formula
(∀y)¬E(x, y) ∨(∀y)(E(x, y) →(∃z)(E(y, z) ∧S(z))),
then on every directed graph G = (V, E), the least ﬁxed point ϕ∞(x) of
ϕ(x, S) deﬁnes the set of all winning positions for Player I.
As a by-product of Theorem 2.6.2 and Examples 2.6.7 and 2.6.9, we can
determine the data complexity of LFP and of LFP1.
Proposition 2.6.10. The data complexity of LFP is P-complete; the data
complexity of LFP1 is P-complete as well.
Proof. (Sketch) Given a ﬁnite σ-structure, the least ﬁxed points and the great-
est ﬁxed points of LFP-formulas can be evaluated by iterating the stages of
the associated operator a polynomial number of times in the size of the given
structure. Moreover, each step in the iteration amounts to evaluating a ﬁrst-
order formula on the structure obtained by expanding the given σ-structure
with the current stage of the operator. Thus, each step in the iteration can
be carried out in a time bounded by a polynomial in the size of the given
σ-structure, since by Theorem 2.4.3, the data complexity of FO is in P. It fol-
lows that the data complexity of LFP (and, a fortiori, of LFP1) is in P. Since
LFP1 can express P-complete queries, such as Path Systems and Geogra-
phy, it follows that the data complexity of LFP1 (and, a fortiori, of LFP) is
P-complete. 2
It is also known that the expression complexity and the combined com-
plexity of LFP and of LFP1 are EXPTIME-complete [67]; this is yet another

70
2 On the Expressive Power of Logics on Finite Models
instance of the exponential-gap phenomenon between the data complexity and
the expression (and combined) complexity of a logic.
Let σ be a vocabulary containing at least one relation symbol of arity 2
or higher, and let F be the class of all ﬁnite σ-structures. Although LFP can
express P-complete queries on F, it cannot express every polynomial-time-
computable query on F. Indeed, in the next section we shall show that
LFP cannot express counting queries, such as Even Cardinality. Thus,
the following proper containments hold on F:
FO(F) ⊂LFP(F) ⊂P.
Immerman [38, 39] and Vardi [67], however, showed that LFP can express all
polynomial-time-computable queries on classes of ordered ﬁnite structures,
that is, on classes of ﬁnite structures in which one of the relations is a linear
order on the universe of the structure.
Theorem 2.6.11. [38, 39, 67] . Let C be a class of ordered ﬁnite structures.
The following are equivalent for a query Q on C.
•
Q is polynomial-time computable.
•
Q is LFP-deﬁnable on C.
In other words, P(C) = LFP(C).
So far, we have focused on recursive speciﬁcations of single queries. In many
areas of computer science, however, it is quite common to specify objects recur-
sively using mutual recursion, that is, the object of interest is deﬁned together
with several other auxiliary objects via a simultaneous recursive speciﬁcation.
In what follows, we formalize the mechanism of mutual recursion for queries
and explore its basic properties.
Deﬁnition 2.6.12. Let A be a set.
•
A system of operators on a A is a ﬁnite sequence (Φ1, . . . , Φm) of mappings
Φi : P(Ak1) × · · · × P(Akm) →P(Aki),
1 ≤i ≤m.
•
A sequence (P1, . . . , Pm) of relations on A is a ﬁxed point of the system
(Φ1, . . . , Φm) if Pi ⊆Aki, for 1 ≤i ≤m, and (Φ1(P1), . . . , Φm(Pm)) =
(P1, . . . , Pm).
•
A sequence (P1, . . . , Pm) of relations on A is the least ﬁxed point of the
system (Φ1, . . . , Φm) if it is a ﬁxed point of (Φ1, . . . , Φm) and, for every ﬁxed
point (P ′
1, . . . , P ′
m) of (Φ1, . . . , Φm), we have that Pi ⊆P ′
i, for 1 ≤i ≤m.
We write lfp(Φ1, . . . , Φm) to denote the least ﬁxed point of (Φ1, . . . , Φm),
if it exists.
•
A
system
(Φ1, . . . , Φm)
is
monotone
if,
for
every
two
sequences
(P1, . . . , Pm), (P ′
1, . . . , P ′
m) of relations on A such that Pi ⊆P ′
i ⊆Aki,
1 ≤i ≤m, we have that Φi(P1, . . . , Pm) ⊆Φi(P ′
1, . . . , P ′
m), for 1 ≤i ≤m.

2.6 Logics with Fixed-Point Operators
71
•
The (ﬁnite) stages (Φn
1 , . . . , Φn
m), n ≥1, of the system (Φ1, . . . , Φm) are
deﬁned by the following simultaneous induction:




Φ1
i
= Φi(∅, . . . , ∅),
1 ≤i ≤m
Φn+1
i
= Φi(Φn
1 , . . . , Φn
m), 1 ≤i ≤m.
In general, for every ordinal α, the stage (Φα
1 , . . . , Φα
m) is deﬁned by the
simultaneous transﬁnite induction
Φα
i = Φi(
β<α Φβ
1, . . . , 
β<α Φβ
m), 1 ≤i ≤m.
We write (Φ∞
1 , . . . , Φ∞
m) = (
α Φα
1 , . . . , 
α Φα
m) for the union of the stages.
Using simultaneous transﬁnite induction, it is easy to verify that the
Knaster–Tarski Theorem (Theorem 2.6.2) extends to monotone systems of
operators.
Theorem 2.6.13. Let A be a set, and (Φ1, . . . , Φm) a monotone system of
operators on A.
•
(Φ1, . . . , Φm) has a least ﬁxed point lfp(Φ1, . . . , Φm).
•
There is an ordinal γ such that for every δ > γ,
lfp(Φ1, . . . , Φm) = (Φ∞
1 , . . . , Φ∞
m) = (Φγ
1, . . . , Φγ
m) = (Φδ
1, . . . , Φδ
m).
If A is a ﬁnite set, then there is an integer s ≤m
i=1 |A|ki such that for
every δ > s,
lfp(Φ1, . . . , Φm) = (Φ∞
1 , . . . , Φ∞
m) = (Φs
1, . . . , Φs
m) = (Φδ
1, . . . , Φδ
m).
•
The least ﬁxed point lfp(Φ1, . . . , Φm) of (Φ1, . . . , Φm) is equal to the (coor-
dinatewise) intersection of all ﬁxed points of (Φ1, . . . , Φm).
Deﬁnition 2.6.14. Let (Φ1, . . . , Φm) be a monotone system of operators on
A. The closure ordinal of this system, denoted by cl(Φ1, . . . , Φm), is the small-
est ordinal γ such that
(Φγ
1, . . . , Φγ
m) = (

β<γ
Φβ
1, . . . ,

β<γ
Φβ
m).
We now consider systems of operators arising from ﬁrst-order formulas.
Deﬁnition 2.6.15. Let σ be a vocabulary.
•
A system of ﬁrst-order formulas is a sequence
(ϕ1(x1, S1, . . . , Sm), . . . , ϕm(xm, S1, . . . , Sm))
of ﬁrst-order formulas over the vocabulary σ ∪{S1, . . . , Sm} such that each
xi is a sequence of variables whose length is equal to the arity of the relation
symbol Si, 1 ≤i ≤m. (Of course, some of the relation symbols S1, . . . , Sm
may not occur in the formula ϕi.)

72
2 On the Expressive Power of Logics on Finite Models
•
If A is a σ-structure, then a system of ﬁrst-order formulas as deﬁned above
gives rise to a system (Φ1, . . . , Φm) of operators on A such that for every
i ≤m,
Φi(P1, . . . , Pm) = {ai : A |= ϕi(ai, P1, . . . , Pm)}.
•
Let (ϕ1(x1, S1, . . . , Sm), . . . , ϕm(xm, S1, . . . , Sm)) be a system of ﬁrst-order
formulas, each of which is positive in S1, . . . , Sm. We write (ϕ∞
1 , . . . , ϕ∞
m)
for the least ﬁxed point of the monotone system associated with this system
of positive ﬁrst-order formulas. Similarly, we write cl(ϕ1, . . . , ϕm) for the
closure ordinal of this system.
Example 2.6.16. Even Path and Odd Path. Let ϕ1(x, y, S1, S2) be the pos-
itive ﬁrst-order formula
E(x, y) ∨(∃z)(E(x, z) ∧S2(z, y)),
and let ϕ2(x, y, S1, S2) be the positive ﬁrst-order formula
(∃z)(E(x, z) ∧S1(z, y)).
Consider the least ﬁxed point (ϕ∞
1 , ϕ∞
2 ) of the system consisting of these two
formulas. It is easy to see that ϕ∞
1 deﬁnes the Odd Path query OP on graphs
and ϕ∞
2 deﬁnes the Even Path query EP on graphs, where, for every graph
G = (V, E),
OP(G) = {(a, b) ∈V 2 : there is a path of odd length from a to b}
EP(G) = {(a, b) ∈V 2 : there is a path of even length from a to b}.
The next result asserts that least ﬁxed points of systems of positive ﬁrst-
order formulas have the same expressive power as LFP1-formulas. Moreover,
it asserts that systems consisting of positive existential and positive universal
ﬁrst-order formulas are as powerful as systems of arbitrary positive ﬁrst-order
formulas.
Theorem 2.6.17. Let σ be a vocabulary, let C be a class of σ-structures each
of which has at least two elements in its universe, and let Q be a query on C.
Then the following statements are equivalent:
1. Q is LFP1-deﬁnable on C.
2. There is a system (ϕ1(x1, S1, . . . , Sm), . . . , ϕm(xm, S1, . . . , Sm)) of pos-
itive ﬁrst-order formulas such that ϕ∞
m
deﬁnes Q on C and each
ϕi(xi, S1, . . . , Sm) is either a positive existential ﬁrst-order formula or a
positive universal ﬁrst-order formula, 1 ≤i ≤m.
3. There is a system (ϕ1(x1, S1, . . . , Sm), . . . , ϕm(xm, S1, . . . , Sm)) of posi-
tive ﬁrst-order formulas such that ϕ∞
m deﬁnes Q on C.

2.6 Logics with Fixed-Point Operators
73
Proof. (Sketch) Since the direction (2) ⇒(3) is trivial, it suﬃces to estab-
lish the directions (1) ⇒(2) and (3) ⇒(1). The proof of (1) ⇒(2) is by
induction on the construction of LFP1-formulas. For concreteness, suppose
that we are given the LFP1-formula (∃y)ϕ∞(x, y), where ϕ(x, y, S) is a ﬁrst-
order formula of the form (∀z)(∃w)θ(x, y, z, w, S) that is positive in S, and
where θ(x, y, z, w, S) a quantiﬁer-free formula and S a binary relation symbol.
Consider the system
(ϕ1(x, y, z, S1, S2, S3), ϕ2(x, y, S1, S2, S3), ϕ3(x, S1, S2, S3)),
where
ϕ1(x, y, z, S1, S2, S3) ≡(∃w)θ(x, y, z, w, S2)
ϕ2(x, y, S1, S2, S3) ≡(∀z)S1(x, y, z)
ϕ3(x, S1, S2, S3) ≡(∃y)S2(x, y),
and where S1 is a ternary relation symbol, S2 a binary one, and S3 a unary
one. By transﬁnite induction on the stages and using the monotonicity of the
formulas, it is not hard to verify that the given LFP1-formula (∃y)ϕ∞(x, y)
is logically equivalent to ϕ∞
3 (x).
The other steps of this direction are quite similar. For instance, sup-
pose we are given the LFP1-formula ϕ∞(x, y) ∧ψ∞(x, y), where ϕ(x, y, S)
and ψ(x, y, S) are ﬁrst-order formulas that are positive in S. By the induc-
tion hypothesis, we may assume that there are systems (ϕ1, . . . , ϕm) and
(ψ1, . . . , ψs) of positive existential and positive universal ﬁrst-order formulas
such that ϕ∞(x, y) is logically equivalent to ϕ∞
m(x, y) and ψ∞(x, y) is logically
equivalent to ψ∞
s (x, y). Suppose that the relation variables in the ﬁrst system
are S1, . . . , Sm and in the second system T1, . . . , Ts. Consider the system
(ϕ1, . . . , ϕm, ψ1, . . . , ψs, χ),
where χ is the formula Sm(x, y) ∧Ts(x, y). Then the given LFP1-formula
ϕ∞(x, y) ∧ψ∞(x, y) is logically equivalent to χ∞(x, y).
We now focus on the direction (3) ⇒(1). Again, for concreteness, suppose
we are given the system (ϕ1(x, S1, S2), ϕ2(y, z, S1, S2)), where ϕ1 and ϕ2 are
ﬁrst-order formulas that are positive in S1, S2, and where S1 is a unary relation
symbol, and S2 is a binary relation symbol. Let S be a 5-ary relation symbol
and let ϕ(u, v, x, y, z, S) be the ﬁrst-order formula
(u ̸= v ∧ϕ1(x, T1, T2) ∨(u = v ∧ϕ2(y, z, T1, T2)),
which is positive in S, and where
T1 = {x′ : (∃u′)(∃v′)(u′ ̸= v′ ∧S(u′, v′, x′, u′, u′)}
T2 = {(y′, z′) : (∃u′)S(u′, u′, u′, y′, z′)}.

74
2 On the Expressive Power of Logics on Finite Models
By induction on the stages and using the monotonicity of the formulas, one
can verify that for every ordinal α, we have that ϕα
1 (x) is logically equivalent
to (∃u)(∃v)((u ̸= v) ∧ϕα
1 (u, v, x, u, u)), while at the same time ϕα
2 (y, z) is
logically equivalent to (∃u)(ϕα(u, u, u, y, z). It follows that ϕ∞
1 (x) is logically
equivalent to (∃u)(∃v)((u ̸= v) ∧ϕ∞(u, v, x, u, u)) and ϕ∞
2 (y, z) is logically
equivalent to (∃u)ϕ∞(u, u, u, y, z). 2
Several remarks are in order now. In Moschovakis’s book [54], the equiva-
lence between statements (1) and (2) is attributed to P. Aczel (in an unpub-
lished note); the same monograph contains a detailed proof of the direction
(3) ⇒(1), which is often called the Simultaneous Induction Lemma.
Theorem 2.6.17 is a basic and extremely useful result about the expressive
power of least ﬁxed-point logic LFP1. It shows that, although on the face of
it from Deﬁnition 2.6.5 the syntax of LFP1 is quite restricted, LFP1 is robust
enough to simulate least ﬁxed points of systems of positive ﬁrst-order for-
mulas. It also facilitates the task of showing that a query is LFP1-deﬁnable,
because quite often it is easier to deﬁne a query by mutual recursion using a
system of positive ﬁrst-order formulas. Furthermore, the equivalence between
statements (1) and (2) in Theorem 2.6.17 reveals that no hierarchy of progres-
sively more expressive sublogics of LFP1 arises when one restricts the length
of quantiﬁer alternation in the formulas occurring in systems. Thus, there
are just two main sublogics of least ﬁxed-point logic obtained by imposing
restrictions on the quantiﬁcation pattern: ELFP1 and ULFP1. The former is
the sublogic of LFP1 determined by systems of positive existential ﬁrst-order
formulas, while the latter is the sublogic of LFP1 determined by systems
of positive universal ﬁrst-order formulas. In what follows, we shall consider
certain fragments of ELFP1 that have played an important role in database
theory.
2.6.3 Datalog and Datalog(̸=)
Datalog can be succinctly described as the data sublanguage of logic pro-
gramming. More formally, a Datalog program π is a ﬁnite set of function-free,
̸=-free, and negation-free rules of the form
t0 : −t1, . . . , tm,
where each ti is an atomic formula R(x1, . . . , xn) for some n-ary relation
symbol, n ≥1; in addition, t0 may be a 0-ary relation symbol standing
for “true”. The expression t0 is the the head of the rule, and the expres-
sion t1, . . . , tm is the body of the rule. The relation symbols that occur in
the heads of the rules of a given Datalog program π are usually called the
intensional database predicates (IDBs) of π, and all others are the exten-
sional database predicates (EDBs) of π. One of the IDBs is designated as
the goal of π. Note that IDBs may occur in the bodies of rules and, thus,

2.6 Logics with Fixed-Point Operators
75
a Datalog program can be viewed as a simultaneous recursive speciﬁcation
of the IDBs. Given a set of relations for the EDBs of π, each IDB is orig-
inally instantiated to the empty relation and then the rules of the Datalog
program are applied repeatedly until no new tuples are added to the IDBs.
An application of a rule entails adding to the IDB in the head of the rule
all tuples that satisfy the head of the rule. This is an informal description of
the “bottom-up” evaluation of a Datalog program, and it provides the pro-
cedural semantics of that program. Alternatively, a Datalog program can be
given declarative semantics using least ﬁxed points of a recursive speciﬁcation
(see [1, 65] for precise deﬁnitions). The query deﬁned by a Datalog program
π is the query whose value on a structure A is the value of the goal of π with
the relations of A as EDBs of π. If the goal of π is 0-ary, then π deﬁnes a
Boolean query.
Example 2.6.18. Transitive Closure revisited. Consider the following Dat-
alog program having E as its only EDB and S as its only IDB:




S(x, y) : −E(x, y)
S(x, y) : −E(x, z), S(z, y)
This program deﬁnes the Transitive Closure query. Note that the Tran-
sitive Closure query is also deﬁnable by the following Datalog program:




S(x, y) : −E(x, y)
S(x, y) : −S(x, z), S(z, y)
Example 2.6.19. Path Systems revisited. Consider the following Datalog
program having A and R as its EDBs and T as its only IDB:




T (x) : −A(x)
T (x) : −T (y), T (z), R(x, y, z)
This program deﬁnes the Path Systems query.
Note that Example 2.6.19 reveals that the data complexity of Datalog is
P-complete, that is, it is the same as that of the full LFP, even though Datalog
is a small fragment of it.
Example 2.6.20. Non-2-Colorability. Consider the following Datalog pro-
gram having E as its only EDB, O and Q as its IDBs, and Q as its 0-ary goal
predicate:






O(x, y) : −E(x, y)
O(x, y) : −E(x, z), E(z, w), O(w, y)
Q
: −O(x, x)
In this program, O deﬁnes the set of pairs of nodes connected via a path of
odd length. Consequently, Q deﬁnes the set of all graphs that contain a cycle
of odd length, that is, the set of all graphs that are not 2-colorable.

76
2 On the Expressive Power of Logics on Finite Models
As seen earlier in Example 2.6.6, the Transitive Closure query is deﬁn-
able as the least ﬁxed point of an existential and positive in S ﬁrst-order
formula. Similarly, as seen in Example 2.6.7, the Path Systems query is
deﬁnable as the least ﬁxed point of an existential and positive in T ﬁrst-order
formula. Moreover, these formulas are ̸=-free and negation-free (that is, they
are also positive in E). In the other direction, the Non-2-Colorability
query is deﬁnable by the formula (∃x)ϕ∞(x, x), where ϕ(x, y, O) is the fol-
lowing existential ﬁrst-order formula that is positive in O and E, and also
̸=-free:
E(x, y) ∨(∃z)(∃w)(E(x, z) ∧E(z, w) ∧O(w, y)).
Chandra and Harel [12] were the ﬁrst to point out that these connections are
not accidental.
Proposition 2.6.21. [12] Let C be a class of structures and Q a query on C.
The following statements are then equivalent:
•
Q is deﬁnable on C by a Datalog program.
•
Q is deﬁnable on C by ϕ∞
m for some system (ϕ1, . . . , ϕm) of ﬁrst-order
formulas such that each ϕi is of the form (∃zi)ψi and ψi is a conjunction
of atomic formulas.
Proof. (Hint) Every rule of a Datalog program gives rise to a formula of a sys-
tem of the required form. Speciﬁcally, the body of the rule is ﬁrst rewritten
as a conjunction of the atomic formulas occurring in it; after this, the vari-
ables occurring in the body, but not in the head of the rule, are existentially
quantiﬁed out. Conversely, every formula in such a system can be viewed as
a rule of a Datalog program. 2
Although Datalog can express P-complete queries, it is strictly less expres-
sive than LFP1. As we shall see next, some of the limitations of Datalog are
consequences of preservation properties possessed by Datalog queries.
Deﬁnition 2.6.22. Let σ be a vocabulary.
•
A homomorphism h : A →B between two σ-structures A and B is a
mapping h from the universe A of A to the universe B of B with the
following properties:
–
for every constant symbol c in σ, we have that h(cA) = cB;
–
for every relation symbol R in σ and every tuple a from A, if a ∈RA,
then h(a) ∈RB.
•
Let Q be a k-ary query on a class C of σ-structures. We say that Q is
preserved under homomorphisms if, for every two structures A, B in C,
every homomorphism h : A →B, and every k-tuple a from A, if a ∈Q(A),
then h(a) ∈Q(B).
•
Let Q be a Boolean query on a class C of σ-structures. We say that Q is
preserved under homomorphisms if, for every two structures A, B in C
such that there is a homomorphism from A to B, if A |= Q, then B |= Q.

2.6 Logics with Fixed-Point Operators
77
Proposition 2.6.23. Let σ be a vocabulary. Every Datalog-deﬁnable query is
preserved under homomorphisms on the class S of all σ-structures.
Proof. (Sketch) Proposition 2.6.21 implies that the system of operators asso-
ciated with a Datalog program is deﬁnable by ﬁrst-order formulas that are
positive in every relation symbol occurring in them and also are ̸=-free. Using
this fact and induction on the stages of the system, it is easy to show that
each stage of the system is preserved under homomorphisms on S. 2
Consider the existential ﬁrst-order sentence (∃x)(∃y)(x ̸= y) asserting that
there are at least two distinct elements in the universe. An immediate con-
sequence of Proposition 2.6.23 is that this sentence is not equivalent to any
Datalog sentence, because it is not preserved under homomorphisms.
Datalog(̸=) is the extension of Datalog in which ̸= is allowed in the rules.
The next example illustrates the syntax of Datalog(̸=).
Example 2.6.24. Node-Avoiding Path. Let Q be the following query on
graphs: given a graph G = (V, E) and three nodes a, b, c, is there a path
from a to b that avoids c?
This query is deﬁnable by the following Datalog(̸=)-program:
T (x, y, w) : −E(x, y) ∧w ̸= x ∧w ̸= y
T (x, y, w) : −E(x, z) ∧T (z, y, w) ∧w ̸= x.
It is easy to see that Q is not preserved under homomorphisms and, conse-
quently, it is not expressible in Datalog.
Note that the above query is also deﬁnable by the least ﬁxed point of the
existential and positive in T ﬁrst-order formula
(E(x, y) ∧w ̸= x ∧w ̸= y) ∨(∃z)(E(x, z) ∧T (z, y, w) ∧w ̸= x).
This is an instance of a more general result that is analogous to Proposition
2.6.21. Speciﬁcally, a query Q is deﬁnable on a class C by a Datalog(̸=) pro-
gram if and only if Q is deﬁnable on C by ϕ∞
m for some system (ϕ1, . . . , ϕm)
of ﬁrst-order formulas such that each ϕi is of the form (∃zi)ψi and ψ is a
conjunction of atomic formulas and inequalities ̸=.
We now present an example of a query on undirected graphs that is deﬁn-
able by a Datalog(̸=) program, but proving this fact requires some machinery
from graph theory.
Example 2.6.25. The Even Simple Path query asks: given a graph G =
(V, E) and two nodes a, b, is there a simple path of even length from a to b?
Using some results of Fortune, Hopcroft, and Wyllie [26] about the Graph
Homeomorphism Problem, it can be shown that Even Simple Path on
directed graphs is an NP-complete problem. In contrast, there is a polynomial-
time algorithm for Even Simple Path when the inputs are undirected

78
2 On the Expressive Power of Logics on Finite Models
graphs. Moreover, in an unpublished note, Yannakakis showed that the follow-
ing Datalog(̸=) program with Q as its goal deﬁnes the Even Simple Path
query on undirected graphs:










T (x, y, w) : −E(x, y) ∧w ̸= x ∧w ̸= y
T (x, y, w) : −E(x, z) ∧T (z, y, w) ∧w ̸= x
P(x, y)
: −E(x, y)
P(x, y)
: −Q(x, w), E(w, y), T (x, w, y)
Q(x, y)
: −P(x, w), E(w, y), T (x, w, y).
The correctness of this program is established by proving the following on
undirected graphs:
•
T deﬁnes the Node-Avoiding Path query.
•
P deﬁnes the Odd Simple Path query (that is, “is there a simple path
of odd length from a to b?”).
•
Q deﬁnes the Even Simple Path query.
The proof proceeds by induction on the stages of the above Datalog(̸=) pro-
gram and makes use of Menger’s Theorem, a well-known result in graph theory
which asserts that if an undirected graph G = (V, E) and two nodes a, b have
the property that every two paths from a to b intersect at some intermediate
node, then there is a node c diﬀerent from a and b such that all paths from a
to b intersect at c (Menger’s Theorem is a special case of the Max Flow–Min
Cut Theorem; see [18]).
A one-to-one homomorphism between two σ-structures A and B is a
homomorphism h : A →B that is also a one-to-one mapping from A to
B. The next result is proved along the lines of the proof of Proposition 2.6.23.
Proposition 2.6.26. Every Datalog(̸=)-deﬁnable query is preserved under
one-to-one homomorphisms on the class S of all σ-structures.
Consider the universal ﬁrst-order sentence (∀x)(∀y)(x ̸= y →E(x, y)),
which asserts that G = (V, E) is a complete graph. Since this sentence is
not preserved under one-to-one homomorphisms, it is not equivalent to any
Datalog(̸=) sentence. Thus, on the class G of all ﬁnite graphs, Datalog(̸=) is
strictly more expressive than Datalog, but strictly less expressive than LFP1.
Another diﬀerence between Datalog(̸=) and LFP1 has to do with closure
ordinals on inﬁnite structures. As seen earlier in Example 2.6.8, there are
positive universal ﬁrst-order formulas whose closure ordinal can be arbitrar-
ily large on inﬁnite structures. In contrast, it is not hard to prove that, on
every inﬁnite structure, the closure ordinal of every of Datalog(̸=) program
is at most ω. This follows from the fact that existential quantiﬁcation dis-
tributes over an inﬁnite union, that is, (∃x)(∞
n=1 Pn) is logically equivalent
to ∞
n=1(∃x)Pn.

2.6 Logics with Fixed-Point Operators
79
2.6.4 The Complementation Problem for LFP1 and a Normal
Form for LFP
The structure of arithmetic is the structure N = (N, +, ×), where N is the
set of all natural numbers, and + and × are ternary relations for the graphs
of the addition and multiplication functions on the natural numbers. The
expressive power of LFP1 on N = (N, +, ×) was ﬁrst studied by Kleene [42]
and Spector [62], who established the following important result, known as
the Kleene–Spector Theorem (see [54]).
Theorem 2.6.27. Let N = (N, +, ×) be the structure of arithmetic.
•
LFP1(N) = USO(N), that is, a relation R ⊆N k is LFP1-deﬁnable on
N if and only if it is deﬁnable on N by a universal second-order formula.
•
LFP1(N) is not closed under complements.
Several remarks are now in order, so that the Kleene–Spector Theorem be
put into the right perspective. First, if σ is a vocabulary and A is an arbitrary
σ-structure, then LFP1(A) ⊆USO(A). The reason for this is that if ϕ(x, S)
is a ﬁrst-order formula that is positive in S over the vocabulary σ ∪{S}, then
it is easy to see that the least ﬁxed point ϕ∞(x) is deﬁnable on A by the
USO-formula
(∀S)((∀z)(ϕ(z, S) ↔S(z))) →S(x)),
which asserts that x belongs to every ﬁxed point of ϕ. Indeed, this formula
deﬁnes the least ﬁxed point of ϕ(x, S), because, as seen in Theorem 2.6.2,
the least ﬁxed point of a monotone operator is the intersection of all its ﬁxed
points. If A is an arbitrary inﬁnite σ-structure, then LFP1(A) may be prop-
erly contained in USO(A); for instance, this is the case for the structure
Q = (Q, <), where Q is the set of rational numbers and < is the standard
linear order on Q. In contrast, the Kleene–Spector Theorem asserts that the
LFP1-deﬁnable relations coincide with the USO-deﬁnable ones on the struc-
ture N = (N, +, ×) of arithmetic; thus, this result provides a “constructive”
characterization of universal second-order logic on N. Moschovakis [54] has
shown that the Kleene–Spector Theorem actually extends to countable struc-
tures A possessing a ﬁrst-order coding machinery for ﬁnite sequences, that
is, countable structures in which ﬁnite sequences of arbitrary length can be
encoded by individual elements and decoded in a ﬁrst-order-deﬁnable way.
Moreover, on such countable structures A there is a binary USO-deﬁnable
relation whose projections are exactly all unary USO-deﬁnable relations (such
relations are called universal USO-deﬁnable relations). Using this fact and a
diagonalization argument, it can be shown that the USO-deﬁnable relations
on such structures A are not closed under complements. In particular, the
LFP1-deﬁnable relations on N are not closed under complements.
Chandra and Harel [10] initiated the study of LFP on ﬁnite structures;
moreover, motivated by the Kleene–Spector Theorem, they conjectured that
the LFP1-deﬁnable queries on the class G of all ﬁnite graphs were not closed

80
2 On the Expressive Power of Logics on Finite Models
under complements. This conjecture, however, was refuted by Immerman [38,
39], who showed that if C is an arbitrary class of ﬁnite structures, then LFP1(C)
is closed under complements. In what follows, we shall outline a proof of this
result and, in the process of doing so, we shall present some other fundamental
properties of LFP1.
Deﬁnition 2.6.28. Let σ be a vocabulary.
•
Let ϕ(x1, . . . , xk, S) be a ﬁrst-order formula that is positive in S over the
vocabulary σ ∪{S}. For every σ-structure A and every k-tuple a ∈Ak, we
write
|a|ϕ =

min{α : A |= ϕα(a)} if A |= ϕ∞(a)
∞
if A |= ¬ϕ∞(a)
•
Let ϕ(x, S) be a ﬁrst-order formula that is positive in S over σ ∪{S} and
let ψ(y, T ) be a ﬁrst-order formula that is positive in T over σ ∪{T }.
The stage comparison queries ⪯∗
ϕ,ψ and ≺∗
ϕ,ψ associated with the formulas
ϕ(x, S) and ψ(y, T ) are the queries such that for every σ-structure A,
a ⪯∗
ϕ,ψ b ⇐⇒ϕ∞(a) ∧(|a|ϕ ≤|b|ψ)
a ≺∗
ϕ,ψ b ⇐⇒|a|ϕ < |b|ψ.
Note that if a ≺∗
ϕ,ψ b, then |a|ϕ < ∞and, thus, a ∈ϕ∞.
•
We write ⪯∗
ϕ and ≺ϕ for the queries ⪯∗
ϕ,ϕ and ≺ϕ,ϕ, respectively.
The next two examples illustrate the meaning of the stage comparison
queries ⪯∗
ϕ and ≺ϕ for concrete formulas ϕ.
Example 2.6.29. Let G = (V, E) be a graph and let ϕ(x, y, S) be the formula
E(x, y) ∨(∃z)(E(x, z) ∧S(z, y)),
whose least ﬁxed point deﬁnes the transitive closure of E. A moment’s
reﬂection reveals that ⪯∗
ϕ is the distance query on graphs. More precisely,
(a, a′) ⪯∗
ϕ (b, b′) holds if and only if there is a path from a to a′ and either
there is no path from b to b′ or the length of the shortest path from a to a′ is
at most equal to the length of the shortest path from b to b′.
Example 2.6.30. As in Examples 2.6.7 and 2.6.19, assume that a proof system
is encoded by a structure S = (F, A, R), where F is a set of formulas, A is a
set of axioms, and R is a ternary rule of inference. Let ψ(x, T ) be the formula
A(x) ∨(∃y)(∃z)(T (y) ∧T (z) ∧R(x, y, z)),
whose least ﬁxed point deﬁnes the set of all theorems of this proof system.
Then the stage comparison queries ⪯∗
ψ and ≺∗
ψ compare lengths of derivations
of theorems of S. In particular, f ≺∗
ψ g holds if and only if f is a theorem of
S and either g is not a theorem of S or f has a derivation in the proof system
S that is shorter than any derivation of g.

2.6 Logics with Fixed-Point Operators
81
Theorem 2.6.31. (The Stage Comparison Theorem [54].) Let σ be a vocab-
ulary. If ϕ(x, S) and ψ(y, T ) are positive ﬁrst-order formulas, then the stage
comparison queries ⪯∗
ϕ,ψ and ≺∗
ϕ,ψ are LFP1-deﬁnable on the class of all
σ-structures.
Proof. (Hint) The stage comparison queries satisfy the equivalences
x ⪯∗
ϕ,ψ y ⇐⇒Φ|y|ψ(x) ⇐⇒
Φ(x, {x′ : |x′|ϕ < |y|ψ})
x ≺∗
ϕ,ψ y ⇐⇒¬Ψ |x|ϕ(y) ⇐⇒¬Ψ(y, {y′ : |y′|ψ < |x|ϕ}).
Note that if x ∈ϕ∞, then, for every y′, we have that |y′|ψ < |x|ϕ holds if
and only if ¬(x ⪯∗
ϕ,ψ y′). It follows that the stage comparison queries satisfy
the following recursive speciﬁcations:
x ⪯∗
ϕ,ψ y ⇐⇒ϕ(x, {x′ : x′ ≺∗
ϕ,ψ y})
x ≺∗
ϕ,ψ y ⇐⇒¬ψ(y, {y′ : ¬ (x ⪯∗
ϕ,ψ y′}).
This motivates us to consider the system (χ1(x, y, S1, S2), χ2(x, y, S1, S2)) of
the ﬁrst-order formulas
χ1(x, y, S1, S2) ≡ϕ(x, {x′ : S2(x′, y)})
χ2(x, y, S1, S2) ≡¬ψ(y, {y′ : ¬S1(x, y′)}).
Note that these formulas are positive in both S1 and S2, and thus their system
has a least ﬁxed point (χ∞
1 , χ∞
2 ). Using transﬁnite induction, it can be shown
that χ∞
1 deﬁnes ⪯∗
ϕ,ψ, and that χ∞
2 deﬁnes ≺∗
ϕ,ψ. 2
While the Stage Comparison Theorem is a result about the class of all
structures, the next theorem is rather special to classes of ﬁnite structures.
Theorem 2.6.32. (The Complementation Theorem for LFP1 [38, 39].) Let
σ be a vocabulary. If C is a class of ﬁnite σ-structures, then LFP1(C) is closed
under complements.
Proof. (Sketch) It suﬃces to show that if ϕ(x, S) is a ﬁrst-order formula that
is positive in S over the vocabulary σ ∪{S}, then the complement ¬ϕ∞is
LFP1-deﬁnable on C.
Let Maxϕ be the query that, given a σ-structure A, returns the set of
all tuples a in ϕ∞on A such that, for every b ∈ϕ∞on A, we have that
|b|ϕ ≤|a|ϕ. In other words, Maxϕ(A) consists of all tuples from A that enter
the “last” stage of the evaluation of ϕ∞on A. Note that if A is an inﬁnite
structure, then Maxϕ(A) may be empty, because there may be no “last” stage
in the evaluation of ϕ (this happens precisely when the closure ordinal clϕ
on A is a limit ordinal). For instance, this is the case when G = (V, E) is
a graph of inﬁnite diameter and ϕ(x, y, S) is the formula whose least ﬁxed
point deﬁnes the transitive closure of the edge relation E. In contrast, if A is
a ﬁnite structure, then Maxϕ(A) ̸= ∅(unless ϕ∞= ∅on A).

82
2 On the Expressive Power of Logics on Finite Models
We shall now show that Maxϕ is LFP1-deﬁnable on the class of all ﬁnite
σ-structures. Note that Maxϕ satisﬁes the equivalence
a ∈Maxϕ(A) ⇐⇒A |= (a ∈ϕ∞) ∧(∀b)(|a|ϕ < |b|ϕ →|a|ϕ + 1 < |b|ϕ).
It is easy to ﬁnd a positive ﬁrst-order formula ψ such that, on ﬁnite structures,
ψ simulates ϕ with a “one-step” delay, that is, for every tuple c ∈ϕ∞, we
have that c enters ψ∞exactly one stage after the stage where it enters ϕ∞.
Using stage comparison queries, the above equivalence can be rewritten as
a ∈Maxϕ(A) ⇐⇒A |= (a ∈ϕ∞) ∧(∀b)((b ⪯∗
ϕ a) ∨(a ≺∗
ψ,ϕ b)).
The Stage Comparison Theorem (Theorem 2.6.31) immediately implies that
Maxϕ is LFP1-deﬁnable on the class of all ﬁnite σ-structures.
It is now easy to show that the complement ¬ϕ∞is LFP1-deﬁnable on the
class of all ﬁnite σ-structures. Indeed, if A is a ﬁnite σ-structure, then
A |= ¬ϕ∞(a) ⇐⇒A |= (∃y)(y ∈Maxϕ ∧y ≺∗
ϕ a). 2
With some extra work and using the ideas in the proof of Theorem 2.6.32,
it is possible to establish the following normal form for least ﬁxed-point logic
LFP on classes of ﬁnite structures.
Theorem 2.6.33. [38, 39] If σ is a vocabulary and C is a class of ﬁnite
σ-structures, then every LFP-deﬁnable query on C is LFP1-deﬁnable on C.
Consequently, LFP(C) = LFP1(C).
Informally, this result asserts that on ﬁnite structures the nesting of
least ﬁxed points, greatest ﬁxed points, and negations can be eliminated and
reduced to a single formation of the least ﬁxed point of a positive ﬁrst-order
formula combined with the positive operations of ﬁrst-order logic (disjunction,
conjunction, and universal and existential quantiﬁcation).
2.6.5 Partial Fixed-Point Logic
The fundamental idea behind least ﬁxed-point logic LFP is that recursive
speciﬁcations involving positive ﬁrst-order formulas can be given meaningful
ﬁxed point semantics, because, by the Knaster-Tarski Theorem (Theorem
2.6.2), every positive ﬁrst-order formula has a least ﬁxed point. Can more
powerful logics be obtained by giving ﬁxed point semantics to speciﬁcations
involving arbitrary (not just positive) ﬁrst-order formulas? There are two main
motivations behind this question, which we now describe brieﬂy.
Recall that on every class of ﬁnite structures, least ﬁxed-point logic
is at least as expressive as ﬁrst-order logic, but it is no more expressive
than polynomial-time computability. In particular, on the class of all ﬁnite

2.6 Logics with Fixed-Point Operators
83
structures, LFP cannot express every polynomial-time-computable query,
even though it can express P-complete queries. As discussed at length in
Chap. 3 of this volume, one of the outstanding open problems in ﬁnite
model theory is whether or not there is a logic that captures P on the
class of all ﬁnite structures. This has motivated the study of ﬁxed-point
logics that are at least as expressive as least ﬁxed-point logic, but are
still within the realm of polynomial-time computability on ﬁnite structures.
One such logic is inﬂationary ﬁxed-point logic IFP, which, however, was
shown by Gurevich and Shelah [35] to have the same expressive power
as LFP on classes of ﬁnite structures (see Chap. 3 for the precise deﬁni-
tions of IFP and a presentation of some of its main properties on ﬁnite
structures).
The second motivation for studying logics with more powerful ﬁxed point
mechanisms has to do with the problem of ﬁnding logics that can express
queries in higher computational-complexity classes, beyond P and NP. The
most prominent logic in this family is partial ﬁxed-point logic, whose main
features we shall describe in the remainder of this section.
Let Φ : P(Ak) →P(Ak) be an arbitrary (not necessarily monotone) k-ary
operator on a ﬁnite set A. As seen earlier, the ﬁnite stages Φn, n ≥1, of Φ
are deﬁned by the induction




Φ1
= Φ(∅)
Φn+1 = Φ(Φn).
If Φ is not monotone, then the sequence Φn, n ≥1, need not be an increasing
one. Nonetheless, since A is a ﬁnite set and each Φn is a k-ary relation on
A, there must exist two positive integers m and m′ such that m < m′ and
Φm = Φm′. Let m′ be the smallest integer greater than m having this property.
If m′ = m + 1, then Φm is actually a ﬁxed point of Φ, and thus the sequence
of stages of Φ converges to this ﬁxed point. If, however, m′ > m + 1, then the
sequence of stages of Φ cycles without ever reaching a ﬁxed point of Φ. This
state of aﬀairs motivates us to use the concept of the partial ﬁxed point of an
operator Φ.
Deﬁnition 2.6.34. Let Φ : P(Ak) →P(Ak) be an arbitrary (not necessarily
monotone) k-ary operator on a ﬁnite set A. The partial ﬁxed point pfp(Φ)
of Φ is a stage Φm such that Φm = Φm+1, if such a stage exists, or the empty
relation ∅otherwise.
If A is a ﬁnite structure and Φ is the operator associated with some formula
ϕ(x1, . . . , xk, S) on A, then the partial ﬁxed point pfp(ϕ) of ϕ(x1, . . . , xk, S)
is the partial ﬁxed point pfp(Φ) of Φ.
Abiteboul and Vianu [2] introduced partial ﬁxed-point logic PFP on ﬁnite
structures, which is the extension of ﬁrst-order logic obtained by augmenting
the syntax and the semantics with partial ﬁxed points of formulas.

84
2 On the Expressive Power of Logics on Finite Models
Deﬁnition 2.6.35. Let σ be a vocabulary.
•
The collection of PFP-formulas over σ is deﬁned inductively by adding
the following rule to the rules for the syntax of ﬁrst-order logic. Assume
that ϕ is a PFP-formula, S is a k-ary relation symbol in free(ϕ), x =
(x1, . . . , xk) is a k-tuple of ﬁrst-order variables each of which is in free(ϕ),
and u = (u1, . . . , uk) is a k-tuple of ﬁrst-order variables not occurring
in ϕ. Then the expression [pfp S.ϕ](u) is a PFP-formula; moreover,
free([pfp S.S](u)) = free(ϕ) \ {x1 . . . , xk, S}.
•
If A is a ﬁnite σ-structure, and a is a k-tuple from A, then A, a |=
[pfp S.ϕ](u) if a ∈pfp(Φ), where Φ is the operator associated with ϕ
on A.
Clearly, if ϕ(x1, . . . , xk, S) is a formula that is positive in S, then the partial
ﬁxed point pfp(ϕ) of ϕ is equal to its least ﬁxed point lfp(ϕ). It follows that
on ﬁnite structures, partial ﬁxed-point logic PFP is at least as expressive as
least ﬁxed-point logic LFP. More precisely, if C is a class of ﬁnite structures,
then
LFP(C) ⊆PFP(C).
Let ϕ(x1, . . . , xk, S) be an arbitrary ﬁrst-order formula over the vocabulary
σ ∪{S}, where S is a k-ary relation symbol. It is easy to see that, on every
ﬁnite structure A, the partial ﬁxed point pfp(ϕ) can be evaluated in poly-
nomial space. To do this, one has to compute in succession the stages Φn of
the operator Φ associated with ϕ(x1, . . . , xk, S), while at the same time main-
taining a counter that stores in binary the number n of the current stage. At
any given time in this computation, a polynomial amount of space is used
to store the current stage Φn, to compute the next stage Φn+1, and to test
whether Φn+1 = Φn. If Φn+1 = Φn, then the computation terminates and
returns Φn as the value of the partial ﬁxed point pfp(ϕ) of ϕ(x1, . . . , xk, S)
on A. Otherwise, Φn is replaced by Φn+1 and the counter is incremented by
one. If at some point the value of the counter exceeds 2|A|k (which is the
total number of k-ary relations on A), then the computation terminates and
returns the empty relation ∅as the value of the partial ﬁxed point pfp(ϕ) of
ϕ(x1, . . . , xk, S) on A. Thus, on every class C of ﬁnite structures, we have that
LFP(C) ⊆PFP(C) ⊆PSPACE.
The next example shows that PFP can actually express PSPACE-complete
queries.
Example 2.6.36. Generalized Path Systems. Let σ be a vocabulary
consisting of a unary relation symbol and a ternary relation symbol. As in
Example 2.6.7, a σ-structure is of the form S = (F, A, R), where A is a subset
of F and R is a ternary relation on F; moreover, such a structure can be
interpreted as consisting of a set F of formulas, a set A of axioms, and a

2.6 Logics with Fixed-Point Operators
85
ternary rule of inference R. Let ϕ(x, T ) be the following existential ﬁrst-order
formula over the vocabulary σ ∪{T }:
A(x) ∨(∃y)(∃z)(T (y) ∧¬T (z) ∧R(x, y, z)).
Intuitively, a ﬁxed point of this formula can be viewed as a recursive speciﬁca-
tion of a nonmonotonic proof system in which a formula x is a theorem of the
system if it is an axiom in A or it can be derived from the rule of inference R
using a theorem y of the proof system and a nontheorem z of the proof system.
Let pfp(ϕ) be the partial ﬁxed point of the formula ϕ(x, T ). Grohe [33]
showed that evaluating pfp(ϕ) on ﬁnite σ-structures is a PSPACE-complete
problem. It follows that, unless P = PSPACE, the partial ﬁxed point pfp(ϕ)
cannot be evaluated in polynomial time and, a fortiori, it cannot be expressed
in LFP.
The preceding remarks and Example 2.6.36 imply the following result
concerning the data complexity of PFP.
Proposition 2.6.37. The data complexity of PFP is PSPACE-complete.
Let σ be a vocabulary containing at least one relation symbol of arity 2
or higher, and let F be the class of all ﬁnite σ-structures. Although PFP can
express P-complete queries on F, it cannot express every polynomial-time
computable query on F. Indeed, in the next section we shall show that the
expressive power of PFP on F has limitations that are similar to those of
LFP on F, namely, PFP cannot express counting queries, such as Even
Cardinality. Thus, the following proper containment holds on F:
PFP(F) ⊂PSPACE.
The state of aﬀairs, however, is diﬀerent on classes of ordered ﬁnite structures.
Theorem 2.6.38. [2, 67]. Let C be a class of ordered ﬁnite structures. The
following are equivalent for a query Q on C:
•
Q is polynomial-space computable.
•
Q is PFP-deﬁnable on C.
In other words, PSPACE(C) = PFP(C).
Chapter 3 contains a proof of the above theorem. Here, we discuss brieﬂy
the history of this result and state who should be credited with the various
parts of the work. Chandra and Harel [11] introduced and studied a logic
called RQL, which is an extension of ﬁrst-order logic FO with recursion
embodied in the form of WHILE looping. Vardi [67] proved that on classes of
ordered ﬁnite structures, a query is polynomial-space computable if and only
if it is RQL-deﬁnable. Later on, Abiteboul and Vianu [2] introduced partial
ﬁxed-point logic PFP and showed that on classes of ﬁnite structures, RQL

86
2 On the Expressive Power of Logics on Finite Models
has the same expressive power as PFP. From these results, it follows that
PSPACE = PFP on every class C of ordered ﬁnite structures.
In this section, we have shown that on the class F
of all ﬁnite
σ-structures, LFP can express P-complete problems and PFP can express
PSPACE-complete problems. At the same time, we have asserted that these
logics cannot express such basic counting properties as Even Cardinality
on F, but have given no proof of this fact. This will be done in the next
section, where we shall bring into the picture a family of inﬁnitary logics
with ﬁnitely many variables, shall introduce new combinatorial games for
analyzing their expressive power, and shall apply the methodology of games
to derive lower bounds for expressibility in ﬁxed-point logics and in inﬁnitary
logics with ﬁnitely many variables.
2.7 Inﬁnitary Logics with Finitely Many Variables
The syntax of the logics that we have encountered thus far is ﬁnitary. Mathe-
matical logicians, however, have also investigated in depth logics whose syntax
has inﬁnitary constructs. Such logics can be obtained by augmenting the syn-
tax of ﬁrst-order logic with disjunctions and conjunctions over inﬁnite sets
of formulas, with inﬁnite strings of quantiﬁers, or with both these types of
constructs. Moreover, diﬀerent families of inﬁnitary logics can be obtained by
imposing cardinality restrictions on the size of the inﬁnitary constructs allowed
(see [17, 41]). The inﬁnitary logic L∞ω is the most powerful among all logics
with inﬁnitary connectives and with ﬁnite strings of quantiﬁers. In addition
to the rules of ﬁrst-order logic, the syntax of L∞ω has the following two rules:
•
If Φ is an arbitrary set of L∞ω-formulas, then the inﬁnitary disjunction
 Φ is also an L∞ω-formula.
•
If Φ is an arbitrary set of L∞ω-formulas, then the inﬁnitary conjunction
 Φ is also an L∞ω-formula.
The inﬁnitary formulas  Φ and  Φ have straightforward semantics. For
instance, if Φ is a set of L∞ω-sentences and A is a structure, then A |=  Φ
if and only if there is at least one L∞ω-sentence ϕ in Φ such that A |= ϕ.
Although L∞ω can make interesting distinctions on inﬁnite structures, it
turns out that this logic is too powerful on classes of ﬁnite structures to be
of any use. Speciﬁcally, it is easy to see that every Boolean query Q on the
class F of all ﬁnite σ-structures is L∞ω-deﬁnable. For every ﬁnite structure
A, let ψA be a ﬁrst-order sentence that deﬁnes A up to isomorphism; such a
sentence asserts that there are precisely as many elements as the cardinality
of the universe A of A, and states which tuples are in the relations of A and
which are not. Since Boolean queries are closed under isomorphisms, Q is
deﬁnable by the L∞ω-sentence 
{A:Q(A)=1} ψA. Note that Q is also deﬁnable
by the L∞ω-sentence 
{A:Q(A)=0} ¬ψA. Thus, every query on the class F

2.7 Inﬁnitary Logics with Finitely Many Variables
87
of all ﬁnite σ-structures can be deﬁned by both a countable disjunction of
ﬁrst-order formulas and a countable conjunction of ﬁrst-order formulas.
2.7.1 The Inﬁnitary Logic Lω
∞ω
In general, L∞ω-formulas may have an inﬁnite number of distinct variables.
Barwise [8] introduced a family of fragments of L∞ω in which there is a ﬁnite
upper bound on the number of distinct variables in each formula.
Deﬁnition 2.7.1. Let σ be a vocabulary.
•
For every positive integer k, we write FOk to denote the collection of all
ﬁrst-order formulas over σ with at most k distinct variables.
•
For every positive integer k, the k-variable inﬁnitary logic Lk
∞ω is the
collection of all L∞ω-formulas over σ with at most k distinct variables.
•
The ﬁnite-variable inﬁnitary logic Lω
∞ω is the collection of all L∞ω-
formulas over σ with ﬁnitely many variables, that is,
Lω
∞ω =

k≥1
Lk
∞ω.
Note that, although each Lk
∞ω-formula has at most k distinct variables,
there is no restriction on the number of occurrences of each variable in the for-
mula. In particular, even FOk-formulas may be of unbounded quantiﬁer rank.
In many cases, this makes it possible to deﬁne interesting properties by judi-
ciously reusing the available variables, in spite of the limited supply of distinct
variables. To illustrate this point, for every positive integer m, let θm be a ﬁrst-
order sentence asserting that there are at least m elements in the universe of
the structure. It can be shown that on the class G of all ﬁnite graphs, θm is not
equivalent to any ﬁrst-order sentence with fewer than m variables. In contrast,
it is easy to see that on the class L of all ﬁnite linear orders, θm is equivalent
to a sentence of FO2. For instance, θ4 is equivalent to the FO2-sentence
(∃x)(∃y)[y < x ∧(∃x)(x < y ∧(∃y)(y < x))].
It follows that L2
∞ω can deﬁne arbitrary cardinalities on L, since, for every
set S of integers, we have that
n ∈S ⇐⇒Ln |=

m∈S
(θm ∧¬θm+1).
In particular, the Even Cardinality query is L2
∞ω-deﬁnable on L.
The original motivation behind the introduction of ﬁnite-variable inﬁni-
tary logics was to study inductive deﬁnability on ﬁxed inﬁnite structures.
Indeed, Barwise [8] used the inﬁnitary logics Lk
∞ω, k ≥1, as a tool to solve an
open problem concerning the closure ordinals of positive ﬁrst-order formulas
on ﬁxed inﬁnite structures. Since the 1980s, however, these logics have found

88
2 On the Expressive Power of Logics on Finite Models
many uses and applications in ﬁnite model theory, where they have become
quite indispensable in the study of ﬁxed-point logics. The main reason for
this is that on classes of ﬁnite structures, Lω
∞ω subsumes the ﬁxed-point
logics LFP and PFP that we encountered earlier. Moreover, deﬁnability in
the inﬁnitary logics Lk
∞ω, k ≥1, can be characterized in terms of certain
combinatorial games in a manner analogous to the characterization of
ﬁrst-order deﬁnability in terms of Ehrenfeucht–Fra¨ıss´e games.
Before spelling out the connection between ﬁxed-point logics and Lω
∞ω
in more precise terms, we present a relevant example. Let ϕn(x, y) be the
ﬁrst-order formula
(∃z1) . . . (∃zn−1)(E(x, z1) ∧. . . ∧E(zn−1, y)),
which deﬁnes the query “there is a path of length n from x to y”, n ≥1. At
ﬁrst sight, it appears that this query cannot be expressed with fewer than
n + 1 variables, since, in addition to the variables x and y, another n −1
variables seem to be needed in order to describe the intermediate nodes
on a path of length n from x to y. It turns out, however, that just three
variables, x, y, and z, suﬃce to express this query; the third variable z can be
repeatedly reused in such a way that it ranges over the intermediate points on
a path from x to y. Speciﬁcally, it can be shown by induction on n that each
formula ϕn(x, y) is equivalent to an FO3-formula ψn(x, y) whose variables are
among x, y, and z. First, ψ1(x, y) is equivalent to the atomic formula E(x, y).
Assume now that ϕn(x, y) is equivalent to an FO3-formula ψn(x, y) whose
variables are x, y, and z. Then ϕn+1(x, y) is equivalent to the FO3-formula
(∃z)[E(x, z) ∧(∃x)(z = x ∧ψn(x, y))],
whose variables are x, y, and z. Consequently, the Connectivity query is
L3
∞ω-deﬁnable by the sentence
(∀x)(∀y)(

n≥1
ψn(x, y)).
The preceding construction can be extended and applied to the stages of
every ﬁrst-order-deﬁnable operator; this makes it possible to show that the
stages of every ﬁrst-order-deﬁnable operator are deﬁnable by an Lk
∞ω-formula
for some positive integer k that depends only on the formula deﬁning the
operator and not on the particular level of the stage. A detailed proof of the
next result can be found in [46, 49]
Theorem 2.7.2. Assume that σ is a vocabulary, S is a m-ary relation symbol
not in σ, and ϕ(x1, . . . , xm, S) is a ﬁrst-order formula over the vocabulary
σ∪{S} such that the number of variables (free and bound) of ϕ(x1, . . . , xm, S)
is equal to k.
•
For every positive integer n ≥1, there is an FOk-formula ϕn(x1, . . . , xm)
that deﬁnes the nth stage Φn of the operator Φ associated with the formula
ϕ(x1, . . . , xm, S) on every σ-structure.

2.7 Inﬁnitary Logics with Finitely Many Variables
89
•
The partial ﬁxed point pfp(ϕ) of ϕ(x1, . . . , xm, S) is Lk
∞ω-deﬁnable on
the class of all ﬁnite σ-structures.
Consequently, if C is a class of ﬁnite σ-structures, then
LFP(C) ⊆PFP(C) ⊆Lω
∞ω(C).
For arbitrary ﬁrst-order formulas ϕ(x1, . . . , xm, S), only the ﬁnite stages
of the associated operator were deﬁned earlier. Recall, however, that if
ϕ(x1, . . . , xm, S) is a positive ﬁrst-order formula, we have actually deﬁned the
stages Φα of the associated operator Φ for an arbitrary ordinal α (Deﬁnition
2.6.1). It can be shown that each such stage Φα is deﬁnable by an Lk
∞ω-formula,
where k is the number of variables (free and bound) in ϕ(x1, . . . , xm, S).
It is not true, however, that every LFP-deﬁnable query on the class S of
all σ-structures is Lω
∞ω-deﬁnable. For instance, the Well-Foundedness
query is LFP-deﬁnable on S, but it is not L∞ω-deﬁnable on S (see [17]);
consequently, this query is not Lω
∞ω-deﬁnable either. Intuitively, Lω
∞ω cannot
subsume LFP on the class S of all σ-structures, because the closure ordinals
of positive ﬁrst-order formulas can be arbitrarily large and so the least ﬁxed
point of a positive formula cannot be obtained by taking the disjunction over
the formulas deﬁning the stages of the formula (this would require taking a
disjunction over a proper class, which is not allowed in the syntax of L∞ω).
It is true, however, that if C is a class of σ-structures of bounded cardinality
(that is, there is a cardinal number λ such that the universe of each structure
in C has cardinality at most λ), then LFP(C) ⊆Lω
∞ω(C).
2.7.2 Pebble Games and Lω
∞ω-Deﬁnability
The ﬁnite-variable inﬁnitary logic Lω
∞ω can be used as a tool in studying
ﬁxed-point logics on ﬁnite structures. In particular, certain structural proper-
ties of Lω
∞ω are inherited by the ﬁxed-point logics LFP and PFP. Moreover,
lower bounds for deﬁnability in Lω
∞ω yield immediately similar results for
deﬁnability in LFP and PFP. The advantage of Lω
∞ω over LFP and PFP is
that, for every positive integer k, deﬁnability in Lk
∞ω can be characterized in
terms of combinatorial k-pebble games, which we introduce next.
Deﬁnition 2.7.3. Let k be a positive integer, σ a vocabulary, and A and B
two σ-structures.
The k-pebble game on A and B is played between two players, called
the Spoiler and the Duplicator, each of whom has k pebbles that are labeled
1, . . . , k. In each move, the Spoiler selects one of the two structures and
either places a pebble that is not currently used on an element of the chosen
structure or removes a pebble from an element of the chosen structure. The
Duplicator responds by either placing the pebble with the same label on an
element of the other structure or by removing the pebble with the same label
from an element of the other structure.

90
2 On the Expressive Power of Logics on Finite Models
Assume that at some point in time during the game, r pebbles have been
placed on each structure, where 1 ≤r ≤k, and let (ai, bi) ∈A × B, 1 ≤i ≤r,
be the pairs of elements of A and B such that the label of the pebble on ai is
the same as the label of the pebble on bi. The Spoiler wins the k-pebble game
on A and B at this point in time if the mapping ai →bi, 1 ≤i ≤r, is not an
isomorphism between the substructures of A and B generated by {a1, . . . , ar}
and {b1, . . . , br}, respectively.
The Duplicator wins the k-pebble game on A and B if the above never
happens, which means that the Duplicator has a winning strategy that allows
him to continue playing “forever” by maintaining a partial isomorphism at
every point in time.
The above description of a winning strategy for the Duplicator in the
k-pebble game is rather informal. The concept of a winning strategy can
be made precise, however, in terms of families of partial isomorphisms
with appropriate closure and extension properties. Recall that a partial
isomorphism from a σ-structure A to a σ-structure B is an isomorphism
from a substructure of A to a substructure of B. In particular, every partial
isomorphism from A to B must map each constant cA
j of A to the constant
cB
j of B, 1 ≤j ≤s, where s is the number of distinct constant symbols in σ.
Thus, when viewed as a set of ordered pairs, each partial isomorphism from
A to B must contain all pairs (cA
j , cB
j ), 1 ≤j ≤s.
Deﬁnition 2.7.4. A winning strategy for the Duplicator in the k-pebble
game on A and B is a nonempty family I of partial isomorphisms from A
to B with the following properties:
1. If f ∈I, then |f −{(cA
1 , cB
1 ), . . . , (cA
s , cB
s )}| ≤k.
2. I is closed under subfunctions:
If g ∈I and f is a function such that {(cA
1 , cB
1 ), . . . , (cA
s , cB
s )} ⊆f ⊆g,
then f ∈I.
3. I has the forth property up to k:
If f ∈I and |f −{(cA
1 , cB
1 ), . . . , (cA
s , cB
s )}| < k, then for every a ∈A,
there is a g ∈I such that f ⊆g and a ∈dom(g).
4. I has the back property up to k:
If f ∈I and |f −{(cA
1 , cB
1 ), . . . , (cA
s , cB
s )}| < k, then for every b ∈B,
there is a g ∈I such that f ⊆g and b ∈rng(g).
Intuitively, the second condition provides the Duplicator with a “good”
move when the Spoiler removes a pebble from an element of A or B, while
the last two conditions provide the Duplicator with “good” moves when the
Spoiler places a pebble on an element of A or of B.
Several properties of the k-pebble game follow easily from the deﬁnitions.
For instance, if k′ ≥k and the Spoiler wins the k-pebble game on A and B,
then the Spoiler also wins the k′-pebble game on A and B. Moreover, for
every k ≥1, the relation “the Duplicator wins the k-pebble game on A and
B” is an equivalence relation on the class S of all σ-structures.

2.7 Inﬁnitary Logics with Finitely Many Variables
91
The following examples illustrate k-pebble games on concrete ﬁnite
structures.
Example 2.7.5. For every m ≥1, let Km be the m-clique, that is, the
complete graph with m nodes. It is quite clear that for every k ≥1,
•
the Duplicator wins the k-pebble game on Kk and Kk+1;
•
the Spoiler wins the (k + 1)-pebble game on Kk and Kk+1.
The case k = 4 is illustrated in Fig. 2.9.
Note that the same state of aﬀairs holds for the Ehrenfeucht–Fra¨ıss´e game
on cliques: the Duplicator wins the k-move Ehrenfeucht–Fra¨ıss´e game on Kk
and Kk+1, but the Spoiler wins the (k + 1)-move Ehrenfeucht–Fra¨ıss´e game
on Kk and Kk+1.
Example 2.7.6. For every m ≥1, let Lm be the linear order with m elements.
It is easy to see that for all positive integers m and n with m < n,
the Spoiler wins the 2-pebble game on Lm and Ln. In the ﬁrst two moves,
the Spoiler places his two pebbles on the two smallest elements of Ln; it is
then in the best interests of the Duplicator to place his two pebbles on the
two smallest elements of Lm. In his next two moves, the Spoiler moves the
pebble from the smallest element of Ln and places it on the third smallest
element of Ln; the Duplicator has to follow suit with similar moves on Lm.
By continuing playing in this way, the Spoiler forces the placement of pebbles
with the same label on progressively bigger elements of the two linear orders.
Since m < n, eventually the Duplicator “runs out of elements” in Lm and
cannot duplicate the move of the Spoiler.
In view of Theorem 2.3.20, this example shows a dramatic diﬀerence
between the pebble games and the Ehrenfeucht–Fra¨ıss´e games, since for
every r and for all suﬃciently large m and n, the Duplicator wins the r-move
Ehrenfeucht–Fra¨ıss´e game on Lm and Ln.
Example 2.7.7. For every m ≥3, let Am be a directed cycle with 2m nodes
and let Bm be the union of two disjoint directed cycles, each with m nodes,
as depicted in Fig. 2.10.
K4
K5
Fig. 2.9. Graphs illustrating the 4-pebble game and the 5-pebble game

92
2 On the Expressive Power of Logics on Finite Models
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
Bm
Am
Fig. 2.10. The Spoiler wins the 3-pebble game on Am and Bm
It is easy to see that for every m ≥3, the Spoiler wins the 3-pebble game
on Am and Bm. In the ﬁrst two moves, the Spoiler places his ﬁrst pebble on
a node in the top cycle of Bm and his second pebble on a node in the bottom
cycle of Bm; thus, the Duplicator has to respond by placing his ﬁrst two peb-
bles on elements of Am (presumably as far apart as possible). From this point
on, the Spoiler keeps his ﬁrst pebble ﬁxed in the top cycle, but uses his second
and third pebbles to force a walk along edges of the bottom cycle, in the same
way as the Spoiler moved from smaller to bigger elements in Example 2.7.6.
Eventually, the three pebbles of the Duplicator are lined up along adjacent
nodes in Am, but this does not hold for the pebbles of the Spoiler in Bm.
This example should be contrasted with the fact that, as implied by the
proof of Proposition 2.3.28, for every r ≥1 and for all suﬃciently large values
of m, the Duplicator wins the r-move Ehrenfeucht–Fra¨ıss´e game on Am and
Bm.
We are now ready to present the connection between k-pebble games and
deﬁnability in the k-variable inﬁnitary logics Lk
∞ω, k ≥1.
Deﬁnition 2.7.8. Let k be a positive integer, and let A and B be two
σ-structures.
•
We say that A is Lk
∞ω-equivalent to B, denoted by A ≡k
∞ω B, if A and
B satisfy the same Lk
∞ω-sentences.
•
We write A ≡k
ωω B to denote that A and B satisfy the same FOk-
sentences.

2.7 Inﬁnitary Logics with Finitely Many Variables
93
•
Let a1, . . . , ar be a sequence of elements from A and let b1, . . . , br be a
sequence of elements from B, for some r ≤k. We say that (A, a1, . . . , ar)
is Lk
∞ω-equivalent to (B, b1, . . . , br) if, for every Lk
∞ω-formula ϕ(v1, . . . , vr)
with free variables among v1, . . . , vr, we have that
A |= ϕ(v1/a1, . . . , vr/ar) ⇐⇒B |= ϕ(v1/a1, . . . , vr/br).
We write (A, a1, . . . , ar) ≡k
∞ω (B, b1, . . . , br) to denote that (A, a1, . . . , ar)
is Lk
∞ω-equivalent to (B, b1, . . . , br).
Clearly, ≡k
∞ω is an equivalence relation on the class S of all σ-structures,
which we call Lk
∞ω-equivalence. The next result asserts that Lk
∞ω-equivalence
coincides with the equivalence relation that arises from the k-pebble game.
Here, we shall only outline the main ideas of the proof; complete details can
be found in [46].
Theorem 2.7.9. [8, 38] Let k be a positive integer, and let A and B be two
σ-structures. The following statements are then equivalent:
•
A ≡k
∞ω B.
•
The Duplicator wins the k-pebble game on A and B.
Moreover, if A and B are ﬁnite, then the above statements are also
equivalent to
•
A ≡k
ωω B.
Proof. (Outline) Assume ﬁrst that A and B are two σ-structures such that
A ≡k
∞ω B. We have to show that there is a family I of partial isomorphisms
on A and B that provides a winning strategy for Player II in the k-pebble
game, as described in Deﬁnition 2.7.4.
We take I to be the family of all partial isomorphisms f between A and
B such that the following hold:
•
|f −{(cA
1 , cB
1 ), . . . , (cA
1 , cB
s )}| ≤k.
•
If a1, . . . , ar are elements in the domain of f other than the elements
cA
1 , . . . , cA
s
interpreting the constant symbols, and b1 = f(a1), . . . , br =
f(ar) are their images under f, then (A, a1, . . . , ar) ≡k
∞ω (B, b1, . . . , br).
To show that I is a winning strategy for the Duplicator, ﬁrst note that I
is nonempty, because A ≡k
∞ω B, and thus the function f with f(cA
j ) = cB
j ,
1 ≤j ≤s, is a member of I (if σ has no constant symbols, then I contains the
empty partial isomorphism). Moreover, I is clearly closed under subfunctions.
To show that I has the forth property up to k, it suﬃces to show that for
all r < k, if we have two sequences of distinct elements a1, . . . , ar in A and
b1, . . . , br in B such that
(A, a1, . . . , ar) ≡k
∞ω (B, b1, . . . , br),

94
2 On the Expressive Power of Logics on Finite Models
then, for every element a in A that is diﬀerent from a1, . . . , ar, there is an
element b in B that is diﬀerent from b1, . . . , br and is such that
(A, a1, . . . , ar, a) ≡k
∞ω (B, b1, . . . , br, b).
Assume that no such b ∈B exists for a certain a ∈A. Then, for every b ∈B
that is diﬀerent from b1, . . . , br, there is an Lk
∞ω-formula ψb(v1, . . . , vr, v)
such that
(A, a1, . . . , ar, a) |= ψb(v1, . . . , vr, v)
and
(B, b1, . . . , br, b) ̸|= ψb(v1, . . . , vr, v).
Hence,
(A, a1, . . . , ar) |= (∃v)

(v1 ̸= v) ∧· · · ∧(vr ̸= v) ∧
	
b∈B
ψb(v1, . . . , vr, v)

,
and, at the same time,
(B, b1, . . . , br) ̸|= (∃v)

(v1 ̸= v) ∧· · · ∧(vr ̸= v) ∧
	
b∈B
ψb(v1, . . . , vm, v)

.
But this is a contradiction, since
(∃v)

(v1 ̸= v) ∧· · · ∧(vm ̸= v) ∧
	
b∈B
ψb(v1, . . . , vm, v)

is an Lk
∞ω-formula and (A, a1, . . . , ar) ≡k
∞ω (B, b1, . . . , br). The back property
up to k is established in an analogous manner, using an inﬁnitary conjunction
over elements of A. Note that if A and B are ﬁnite σ-structures, then these
conjunctions are actually ﬁnitary. Using this observation, we can mimic the
preceding argument with ≡k
ωω in place of ≡k
∞ω in the deﬁnition of the winning
strategy I. It follows that if A and B are ﬁnite σ-structures satisfying the
same FOk-sentences, then the Duplicator wins the k-pebble game on A and B.
Conversely, let I be a winning strategy for the Duplicator in the k-pebble
game on A and B. We have to show that A and B satisfy the same
Lk
∞ω-sentences. This is a consequence of the following stronger statement,
which can be proved by induction on the construction of Lk
∞ω-formulas using
the closure and extension properties of I:
If ψ(v1, . . . , vr) is an Lk
∞ω-formula whose variables are among v1, . . . , vk
and whose free variables are among v1, . . . , vr, then for all f ∈I and for all
(not necessarily distinct) elements a1, . . . , ar from the domain of f, we have
A |= ψ(v1/a1, . . . , vr/ar) ⇐⇒B |= ψ(v1/f(a1), . . . , vm/f(ar)).
2
As a consequence of Theorem 2.7.9, we obtain a characterization of
Lω
∞ω-deﬁnability on classes of ﬁnite structures.

2.7 Inﬁnitary Logics with Finitely Many Variables
95
Corollary 2.7.10. Let σ be a vocabulary, C a class of ﬁnite σ-structures,
and Q a Boolean query on C. The following statements are then equivalent:
1. Q is Lω
∞ω-deﬁnable on C.
2. There is a positive integer k such that, for every structure A ∈C and
every structure B ∈C, if Q(A) = 1 and the Duplicator wins the k-pebble
game on A and B, then Q(B) = 1.
Proof. If Q is Lω
∞ω-deﬁnable on C, then there is a positive integer k such that Q
is deﬁnable on C by some Lk
∞ω-sentence θ. Theorem 2.7.9 implies that if A and
B are structures in C such that Q(A) = 1 and the Duplicator wins the k-pebble
game on A and B, then B |= θ, and hence Q(B) = 1. Note that the assumption
that C consists of ﬁnite structures has not been used in this direction.
For the other direction, assume that k is a positive integer with the
property that if A and B are structures in C such that Q(A) = 1 and
the Duplicator wins the k-pebble game on A and B, then Q(B) = 1. For
every structure A ∈C, let ΨA be the set of all FOk-sentences ψ such that
A |= ψ. Note that ΨA is actually a countable set, because there are countably
many ﬁrst-order formulas; consequently,  ΨA is an Lk
∞ω-sentence. Let
A1, . . . , An, . . . be a list of representatives of all isomorphism types of struc-
tures A in C, with Q(A) = 1. Such a list is countable, since there are countably
many non-isomorphic ﬁnite structures. Using Theorem 2.7.9, it is easy to see
that the Lk
∞ω-sentence { ΨAn : n ≥1} deﬁnes the query Q on C. 2
Method 2.7.11. The Method of k-Pebble Games for Lω
∞ω. Let σ be a
vocabulary, C a class of ﬁnite σ-structures, and Q a Boolean query on C.
Soundness. To show that Q is not Lω
∞ω-deﬁnable on C, it suﬃces to show
that for every positive integer k, there are structures Ak and Bk in C
such that
•
Q(Ak) = 1 and Q(Bk) = 0;
•
the Duplicator wins the k-pebble game on Ak and Bk.
Completeness. This method is also complete, that is, if Q is not Lω
∞ω-
deﬁnable on C, then for every positive integer k, such structures Ak and
Bk exist.
We note that the above method is sound for arbitrary classes of σ-
structures, not just classes of ﬁnite σ-structures. Moreover, it can be shown
that it is complete for classes of σ-structures of bounded cardinality. We now
present some applications of this method.
Proposition 2.7.12. Let G be the class of all ﬁnite graphs.
•
The Even Cardinality query is not Lω
∞ω-deﬁnable on G. Consequently,
the Even Cardinality query is neither LFP-deﬁnable nor PFP-deﬁnable
on G.

96
2 On the Expressive Power of Logics on Finite Models
•
For every k ≥1, the query “does the graph contain a (k + 1)-clique?” is
not Lk
∞ω-deﬁnable on G.
Proof. This is an immediate consequence of Example 2.7.5, Theorem 2.7.10,
and Theorem 2.7.2. 2
Proposition 2.7.13.
[16] The query Hamiltonian Path is not Lω
∞ω-
deﬁnable on the class G of all ﬁnite graphs. Consequently, the query
Hamiltonian Path is neither LFP-deﬁnable nor PFP-deﬁnable on G.
Proof. For every m ≥1 and every n ≥1, let Km × Cn be the product graph
of the totally disconnected m-node graph Km with the n-node cycle Cn, as
depicted in Fig. 2.11.
It is easy to see that Km × Cn has a Hamiltonian Path if and only if
m ≤n. This holds because, in order to visit two nodes of Km by traveling
along edges of Km × Cn, one has to visit a node of Cn. Moreover, it is quite
clear that for every k ≥1, the Duplicator wins the k-pebble game on Kk ×Ck
and Kk+1×Ck. Since Kk×Ck has a Hamiltonian Path, but Kk+1×Ck does
not, the conclusions follow immediately from Theorems 2.7.10, and 2.7.2. 2
As an exercise, we invite the reader to apply Method 2.7.11 and show
that the Perfect Matching query is not Lω
∞ω-deﬁnable on G. Note that,
using the same method, Dawar [14] showed that 3-Colorability is not
Lω
∞ω-deﬁnable on G. This is a technically diﬃcult result that requires the
construction of complicated graphs Ak and Bk, k ≥1, such that Ak is
Km
×
Cn
Fig. 2.11. Hamiltonian Path is not Lω
∞ω-deﬁnable

2.7 Inﬁnitary Logics with Finitely Many Variables
97
3-colorable, B is not 3-colorable, and the Duplicator wins the k-pebble game
on Ak and Bk. In contrast, 2-Colorability is Lω
∞ω-deﬁnable on G; in fact,
it is L4
∞ω-deﬁnable, since Non-2-Colorability is deﬁnable by a Datalog
program with at most four variables in each rule, as shown in Example 2.6.20.
It should be pointed out that, although Method 2.7.11 can be used to
establish limitations on the expressive power of LFP and PFP on the class
G of all ﬁnite graphs, this method cannot be used to establish such results
on the class O of all ﬁnite ordered graphs. The reason for this is that every
query on O is L2
∞ω-deﬁnable, since the isomorphism type of every ordered
ﬁnite structure is deﬁnable by an FO2-sentence (this is an extension of the
fact that FO2 can express every ﬁxed ﬁnite cardinality on linear orders). In
particular, Hamiltonian Path and 3-Colorability are L2
∞ω-expressible
on O. Consequently, Method 2.7.11 cannot be used to establish limitations
on the expressive power of LFP and PFP on the class O of all ordered ﬁnite
graphs; this is not surprising, since, as stated in Theorems 2.6.11 and 2.6.38,
LFP captures PTIME and PFP captures PSPACE on O.
Up to this point, k-pebble games have been used to establish mainly
negative results, that is, lower bounds for deﬁnability in Lω
∞ω and, a fortiori,
lower bounds for deﬁnability in LFP and in PFP. These games, however,
can also be used to establish positive results in the form of structural
properties of Lω
∞ω, which, in many cases, are inherited by LFP and PFP.
Moreover, k-pebble games can be used to unveil certain deeper connections
between LFP and Lω
∞ω. As will be seen in the remainder of this section,
all these results involve an in-depth study of the family of the equivalence
relations ≡k
∞ω, k ≥1, using k-pebble games.
2.7.3 0–1 Laws for Lω
∞ω
A major direction of research in ﬁnite model theory has focused on the study
of the asymptotic probabilities of queries on classes of ﬁnite structures. This
is the topic of Chap. 4 of this volume. Here, we present a brief overview of
0–1 laws for the inﬁnitary logic Lω
∞ω.
Deﬁnition 2.7.14. Let σ be a vocabulary, C a class of ﬁnite σ-structures,
and Q a Boolean query on C.
•
For every n ≥1, we write Cn to denote the subclass of C consisting of all
structures A in C with universe {1, . . ., n}.
•
For every n ≥1, let μn be a probability measure on Cn.
–
We write μn(Q) to denote the probability of the query Q on Cn with
respect to the measure μn, n ≥1.
–
The asymptotic probability μ(Q) of the query Q with respect to the
family of measures μn, n ≥1, is deﬁned as
μ(Q) = lim
n→∞μn(Q),
provided the limit exists.

98
2 On the Expressive Power of Logics on Finite Models
Of all measures on classes of ﬁnite structures, the uniform measure is the
most well-studied one. More precisely, if C is a class of ﬁnite σ-structures and Q
is a Boolean query on C, then the value μn(Q) of the uniform measure is equal
to the fraction of structures in Cn that satisfy the query Q, n ≥1. Combinato-
rialists have studied in depth the asymptotic probabilities of queries on ﬁnite
graphs with respect to the uniform measure. For instance, it is well known that
μ(4-Regular) = 0, μ(2-Colorability) = 0, and μ(Hamiltonian Path) =
1. Note, however, that μ(Even Cardinality) does not exist, since we have
that μ2n(Even Cardinality) = 1 and μ2n+1(Even Cardinality) = 0.
In the late 1960s and early 1970s, researchers raised the question of
whether there was a connection between the deﬁnability of a query Q in some
logic and its asymptotic probability with respect to a given measure. The next
deﬁnition captures a case in which such a connection exists, and it is tight.
Deﬁnition 2.7.15. Let L be a logic, let σ be a vocabulary consisting of
relation symbols only, let C be a class of ﬁnite σ-structures, and let μn, n ≥1,
be a family of measures on Cn.
We say that L has a 0–1 law on C with respect to μn, n ≥1, if for every
L-deﬁnable query Q on C, we have that μ(Q) = 0 or μ(Q) = 1.
Note that the presence of constant symbols causes a failure of the 0–1
law for ﬁrst-order logic with respect to the uniform measure. Indeed, if σ is
a vocabulary containing a constant symbol c and a unary relation symbol
P, then it is quite easy to verity that μ(P(c)) = 1/2. This explains why,
in Deﬁnition 2.7.15, it was assumed that the vocabulary consists of relation
symbols only.
Over the years, there has been an extensive investigation of 0–1 laws
for various logics with respect to the uniform measure on classes of ﬁnite
σ-structures and, in particular, on the class F of all ﬁnite σ-structures. This
investigation started with the independent discovery by Glebskii et al. [31]
and Fagin [23] that ﬁrst-order logic FO has a 0–1 law with respect to the
uniform measure on the class F of all ﬁnite σ-structures. After this, Blass,
Gurevich, and Kozen [9] showed that least ﬁxed-point logic LFP has a 0–1 law
with respect to the uniform measure on F, and Kolaitis and Vardi [44] showed
that partial ﬁxed-point logic PFP has a 0–1 law with respect to the uniform
measure on F. These 0–1 laws for progressively more expressive logics turned
out to be special cases of the 0–1 law for the inﬁnitary logic Lω
∞ω with respect
to the uniform measure on F, a result established by Kolaitis and Vardi [46].
Theorem 2.7.16. Let σ be a vocabulary consisting of relation symbols only.
The ﬁnite-variable inﬁnitary logic Lω
∞ω then has a 0–1 law with respect to
the uniform measure on the class F of all ﬁnite σ-structures.
Proof. (Hint) For every k ≥1, let θk be the conjunction of all extension
axioms for σ with at most k variables, that is, the conjunction of all
FOk-sentences that assert that every substructure with fewer than k elements

2.7 Inﬁnitary Logics with Finitely Many Variables
99
has an extension to a substructure with k elements. Fagin [23] showed that
μ(θk) = 1, where μn is the uniform measure on Fn, n ≥1. Let Ak be a model
of θk, and let [Ak]≡k∞ω = {B ∈F : Ak ≡k
∞ω B} be the ≡k
∞ω-equivalence class
of Ak. Using the characterization of ≡k
∞ω via k-pebble games in Theorem
2.7.9, it can be shown that [Ak]≡k∞ω = {B ∈F : B |= θk}. Consequently,
μ([Ak]≡k∞ω) = 1, which easily implies that the 0–1 law holds for the k-variable
inﬁnitary logic Lk
∞ω. 2
Since the asymptotic probability of the Even Cardinality query does
not exist, Theorem 2.7.16 gives another proof that Even Cardinality is
not Lω
∞ω-deﬁnable on the class F of all ﬁnite σ-structures.
The next result characterizes when a 0–1 law holds for the k-variable
inﬁnitary logics Lk
∞ω, k ≥1, on a class of ﬁnite structures with respect to an
arbitrary measure.
Theorem 2.7.17. Let σ be a vocabulary consisting of relation symbols only,
let C a class of ﬁnite σ-structures, and let μn be a measure on Cn, n ≥1.
Then, for every positive integer k, the following two statements are equivalent:
1. The k-variable inﬁnitary logic Lk
∞ω has a 0–1 law with respect to μn,
n ≥1, on C.
2. There is an equivalence class D of ≡k
∞ω on C such that μ(D) = 1.
In eﬀect, Theorem 2.7.17 reveals that Lk
∞ω has a 0–1 law if and only if
there is a “giant” Lk
∞ω-equivalence class; all other Lk
∞ω-equivalence classes
must have an asymptotic probability equal to 0. Moreover, the existence of
a 0–1 law for Lk
∞ω can be established using k-pebble games.
As described in Chap. 4, Shelah and Spencer [61] investigated 0–1 laws
for ﬁrst-order logic FO on the class G of all ﬁnite graphs under nonuniform
measures on Gn of the form p(n) = n−α, where α is a ﬁxed real number.
Their main ﬁnding was that for all real α ∈(0, 1), FO has a 0–1 law on G
with respect to the measures p(n) = n−α if and only if α is an irrational
number. It follows that if α ∈(0, 1) is rational, then the 0–1 law fails for
the ﬁnite-variable inﬁnitary logic Lω
∞ω on G with respect to the measures
p(n) = n−α. Moreover, McArthur [52] showed that the 0–1 law also fails
for Lω
∞ω on G with respect to the measures p(n) = n−α when α ∈(0, 1) is
irrational. Thus, the 0–1 law fails for Lω
∞ω on G with respect to every measure
of the form p(n) = n−α, where 0 < α < 1.
2.7.4 Deﬁnability and Complexity of Lk
∞ω-Equivalence
If L is a logic and σ is a vocabulary, then two σ-structures A and B are
L-equivalent
if
they
satisfy
the
same
L-sentences.
The
concept
of
L-equivalence gives rise to the following decision problem: given two
ﬁnite σ-structures A and B, are they L-equivalent? Strictly speaking, this
decision problem is not a query on ﬁnite structures, since, according to

100
2 On the Expressive Power of Logics on Finite Models
Deﬁnition 2.2.1, queries take single structures, not pairs of structures, as
inputs. It is easy, however, to view this decision problem as a query on
an expanded vocabulary σ1 + σ2 that consists of two disjoint copies of the
relation and constant symbols in the vocabulary σ together with two unary
predicates D1 and D2. Using the vocabulary σ1 + σ2, a pair (A, B) of two
σ-structures A and B is identiﬁed with a single σ1 + σ2-structure A + B
deﬁned as follows: the universe of A + B is the union A ∪B of the universes
of A and B, the relation symbol D1 is interpreted by the universe A of
A, the relation symbol D2 is interpreted by the universe B of B, and the
remaining relation and constant symbols of σ1 + σ2 are interpreted by the
corresponding relations and constants of A and B. This encoding makes it
possible to formally view queries on pairs of σ-structures as queries on single
σ1 + σ2-structures.
Note that FO-equivalence coincides with the Isomorphism Problem,
since the isomorphism type of every ﬁnite σ-structure is FO-deﬁnable; as
a result, FO-equivalence is not FO-deﬁnable. The same line of reasoning
shows that Lω
∞ω-equivalence is not Lω
∞ω-deﬁnable. In what follows, we
shall investigate the logical deﬁnability and computational complexity of
Lk
∞ω-equivalence, k ≥1.
Using Theorem 2.7.9 and the inﬁnitary syntax of Lk
∞ω, it is easy to see
that Lk
∞ω-equivalence is Lk
∞ω-deﬁnable, k ≥1. Indeed, as in the proof of
Theorem 2.7.10, for every ﬁnite σ-structure A, let ΨA be the conjunction of
all FOk-sentences satisﬁed by A; clearly, ΨA is an Lk
∞ω-sentence. Note that
for every Lk
∞ω-sentence Ψ, there are Lk
∞ω-sentences Ψ 1 and Ψ 2 over σ1 + σ2
such that for all σ-structures A and B, the following hold:
•
A + B |= Ψ 1 if and only if A |= Ψ.
•
A + B |= Ψ 2 if and only if B |= Ψ.
Finally, let A1, . . . , An, . . . be a list of representatives of all isomorphism
types of ﬁnite σ-structures. Then Lk
∞ω-equivalence on σ is deﬁnable by the
Lk
∞ω-sentence

{(Ψ 1
Ai ∧Ψ 2
Ai) : i ≥1}.
The preceding construction shows that Lk
∞ω is powerful enough to express
its own equivalence, but provides no information about the computa-
tional complexity of Lk
∞ω-equivalence. Nonetheless, the characterization
of Lk
∞ω-equivalence in terms of k-pebble games can be used to show that
Lk
∞ω-equivalence is LFP-deﬁnable and, thus, it is also polynomial-time
computable. This result, whose proof is outlined next, was obtained
by Dawar, Lindell and Weinstein [15] and by Kolaitis and Vardi [45]
independently.
Proposition 2.7.18. Let σ be a vocabulary and k a positive integer. There
is then a positive ﬁrst-order formula ϕ(x1, . . . , xk, y1, . . . , yk, S) over the
vocabulary σ1 + σ2 such that the least ﬁxed point ϕ∞(x1, . . . , xk, y1, . . . , yk)

2.7 Inﬁnitary Logics with Finitely Many Variables
101
of this formula deﬁnes the query “given two σ-structures A, B and two
k-tuples (a1 . . . , ak) ∈Ak and (b1, . . . , bk) ∈Bk, is (A, a1, . . . , ak) ̸≡k
∞ω
(B, b1 . . . , bk)?”
Consequently, for each k ≥2, Lk
∞ω-equivalence is LFP-deﬁnable.
Proof. From the proof of Theorem 2.7.9, it follows that (A, a1, . . . , ak) ̸≡k
∞ω
(A, b1 . . . , bk) if and only if the Spoiler wins the k-pebble game on A and
B starting with the conﬁguration (a1, . . . , ak, b1, . . . , bk), that is, the Spoiler
wins the k-pebble game when the game begins with pebbles of the same label
placed on ai and bi, i = 1, . . . , k. The latter statement is deﬁnable by the least
ﬁxed point ϕ∞of a positive ﬁrst-order formula ϕ(x1, . . . , xk, y1, . . . , yk, S) over
the vocabulary σ1 +σ2 with a total of 2k distinct variables, which, intuitively,
asserts that the Spoiler wins in the initial conﬁguration or in the “next”
move of the game. More precisely, ϕ(x1, . . . , xk, y1, . . . , yk, S) is the formula
χ(x1, . . . , xk, y1, . . . , yk) ∨(∨k
i=1ψi(x1, . . . , xk, y1, . . . , yk, S)),
where
•
χ is a quantiﬁer-free formula stating that xi
∈D1, yi
∈D2, for
i
=
1, . . . , k, and the substructures generated by {x1, . . . , xk} and
{y1, . . . , yk} are not isomorphic;
•
ψi is the formula
(∃xi ∈D1)(∀yi ∈D2)S(x1, . . . , xk, y1, . . . , yk)∨
(∃yi ∈D2)(∀xi ∈D1)S(x1, . . . , xk, y1, . . . , yk). 2
Proposition 2.7.18 implies that for every k ≥2, Lk
∞ω-equivalence is
in P. Grohe [34] established the following matching lower bound for the
computational complexity of Lk
∞ω-equivalence.
Theorem 2.7.19. Let σ be a vocabulary containing at least one binary
relation symbol. For each positive integer k ≥2, the following problem is
P-complete: given two ﬁnite σ-structures A and B, does the Duplicator win
the k-pebble game on A and B?
Consequently, for each k ≥2, Lk
∞ω-equivalence is P-complete.
This result can be proved via an intricate reduction from the Monotone
Circuit Value Problem. Note that it provides a sharp contrast between the
k-pebble game and the r-move Ehrenfeucht–Fra¨ıss´e game, since, by Theorem
2.4.4, for each ﬁxed r ≥1, determining the winner in the r-move Ehrenfeucht–
Fra¨ıss´e game is solvable in logarithmic space (and, hence, it is unlikely to be
P-complete). Note that if the number k of pebbles is also part of the input,
then determining the winner in the k-pebble game is solvable in exponential
time. It has been conjectured, but has not been proved, that this upper
bound is tight, which means that the following query is EXPTIME-complete:

102
2 On the Expressive Power of Logics on Finite Models
given a positive integer k and two ﬁnite σ-structures A and B, does the
Duplicator win the k-pebble game on A and B? This would complement
Theorem 2.4.5 to the eﬀect that, when the number r of moves is part of the
input, determining the winner in the r-move Ehrenfeucht–Fra¨ıss´e game is a
PSPACE-complete problem.
For every ﬁnite σ-structure B, let [B]k
∞ω be the Lk
∞ω-equivalence class of
B on ﬁnite σ-structures, that is,
[B]k
∞ω = {A ∈F : A ≡k
∞ω B}.
Clearly, [B]k
∞ω can also be viewed as a Boolean query Qk
B on the class F of all
ﬁnite σ-structures: given a ﬁnite σ-structure A, is A ≡k
∞ω B? For every ﬁnite
σ-structure B and every k-tuple b from B, we can also consider the related
k-ary query Qk
B,b on F such that, given a ﬁnite σ-structure A, we have that
Qk
B,b(A) = {a ∈Ak : (A, a) ≡k
∞ω (B, b)}.
Theorem 2.7.9 implies that the query Qk
B is deﬁnable by the Lk
∞ω-sentence
 ΨB, where, as earlier, ΨB is the set of all FOk-sentences satisﬁed by B.
Similarly, each query Qk
B,b is Lk
∞ω-deﬁnable as well. Dawar, Lindell, and
Weinstein [15] established a much stronger result by showing that all queries
Qk
B and Qk
B,b are actually FOk-deﬁnable. This was achieved via a careful
adaptation to Lk
∞ω of Scott’s theorem [60] to the eﬀect that the isomorphism
type of every countable structure is deﬁnable in the inﬁnitary logic Lω1ω.
Here, we outline a diﬀerent proof, which was given in [49]. As a stepping
stone, we ﬁrst establish the following result.
Proposition 2.7.20. Let B be a ﬁnite σ-structure and let b1, . . . , bl be an
enumeration of all k-tuples from B. For every positive integer k, there is
a system SB = (ϕB,bi(x1, . . . , xk, Tb1, . . . , Tbl), 1 ≤i ≤l) of FOk-formulas
that are positive in Tb1, . . . , Tbl and have the property that ϕ∞
B,bi(x1, . . . , xk)
deﬁnes the complement of the query Qk
B,bi, 1 ≤i ≤l. Thus, for every ﬁnite
σ-structure A and every k-tuple a from A,
(A, a) ≡k
∞ω (B, b) ⇐⇒A, a |= ¬ϕ∞
B,bi(x1, . . . , xk).
Proof. (Outline) For every i ≤l, let χB,bi(x1, . . . , xk) be the conjunc-
tion of all atomic or negated atomic formulas η(x1, . . . , xk) such that
B, bi |= η(x1, . . . , xk). Moreover, for every j such that 1 ≤j ≤k and every
element b from the universe of B, let bi[j/b] be the k-tuple obtained from the
k-tuple bi = (bi
1, . . . , bi
k) by replacing bi
j by b. We then consider the system
SB = (ϕB,bi, 1 ≤i ≤l), where ϕB,bi(x1, . . . , xk, Tb1 . . . , Tbl) is the formula
¬χB,bi(x1, . . . , xk) ∨[
k
j=1
(∃xj)
	
b∈B
Tbi[j/b](x1, . . . , xk)] ∨
[
k
j=1

b∈B
(∀xj)Tbi[j/b](x1, . . . , xk)].

2.7 Inﬁnitary Logics with Finitely Many Variables
103
By induction on m simultaneously for all i ≤l, it can be shown that on
every σ-structure A the component Φm
B,bi, 1 ≤i ≤l, of the mth stage of the
system SB consists of all k-tuples a from A such that the Spoiler can win
the k-pebble game on (A, a) and (B, b) within m rounds. 2
By combining Theorem 2.7.2 with Proposition 2.7.20, we can now obtain
the result of Dawar, Lindell, and Weinstein [15] to the eﬀect that every
≡k
∞ω-equivalence class is FOk-deﬁnable.
Theorem 2.7.21. Let k be a positive integer, B a ﬁnite σ-structure, and b
a k-tuple from B.
•
The k-ary query Qk
B,b is deﬁnable by some FOk-formula θB,b(x1, . . . , xk).
•
The Boolean query Qk
B is deﬁnable by some FOk-sentence θB of FOk.
In other words, for each ﬁxed positive integer k and each ﬁxed ﬁnite
σ-structure B, the following query is FOk-deﬁnable: “Given a ﬁnite
σ-structure A, does the Duplicator win the k-pebble game on A and B?”
Proof. (Outline) Let b1, . . . , bl be an enumeration of all k-tuples from the
universe of B and let SB = (ϕB,bi, 1 ≤i ≤l), be the system of positive
FOk-formulas used in the proof of Theorem 2.7.20. Theorem 2.7.2 implies that
for every i ≤l and every m ≥1, there is an FOk-formula ϕm
B,bi(x1, . . . , xk)
that deﬁnes the component Φm
B,bi of the mth stage of this system.
Let us now apply the system SB to the structure B itself. There is then
a positive integer m0 such that on B, the least ﬁxed point of this system is
equal to its m0th stage, that is, for every i ≤l,
B |= (∀x1 . . . ∀xk)[ϕm0
B,bi(x1, . . . , xk) ↔ϕm0+1
B,bi (x1, . . . , xk)].
It can then be shown that the query Qk
B,b is deﬁnable by the following
FOk-formula θB,b(x1, . . . , xk):
¬ϕm0
B,b(x1, . . . , xk)∧[
l	
i=1
(∀x1. . .∀xk)(ϕm0
B,bi(x1, . . . , xk) ↔ϕm0+1
B,bi (x1, . . . , xk))].
Finally, the query Qk
B is deﬁnable by the FOk-sentence
(∃x1 . . . ∃xk)(
l
i=1
θB,bi(x1, . . . , xk)). 2
Theorem 2.7.21 yields the following normal form for Lk
∞ω-deﬁnability on
ﬁnite structures, k ≥1, a result due to Dawar, Lindell, and Weinstein [15].
Corollary 2.7.22. Let σ be a vocabulary and k a positive integer. For every
Lk
∞ω-sentence ψ, there are FOk-sentences ψm, m ≥1, such that for every
ﬁnite σ-structure A, we have that
A |= ψ ⇐⇒A |=
∞

i=1
ψm.

104
2 On the Expressive Power of Logics on Finite Models
Proof. The class of ﬁnite σ-structures that satisfy ψ is equal to the union of
all ≡k
∞ω-equivalence classes of ﬁnite σ-structures that satisfy ψ. Thus, the
desired sentences ψm are the FOk-sentences θB, where B varies over all ﬁnite
σ-structures that satisfy ψ. 2
Since Lk
∞ω and FOk are closed under negations, we also have that on
the class of all ﬁnite σ-structures, every Lk
∞ω-sentence is equivalent to a
countable conjunction of FOk-sentences. Thus, the expressive power of Lk
∞ω
on ﬁnite structures reduces to a single application of inﬁnitary disjunction or
inﬁnitary conjunction to a countable set of FOk-sentences.
2.7.5 Least Fixed-Point Logic vs. Partial Fixed-Point Logic
on Finite Structures
We now take a closer look at the relationship between least ﬁxed-point
logic LFP and partial ﬁxed-point logic PFP on ﬁnite structures. Since every
LFP-formula is also a PFP-formula, we have that on the class F of all ﬁnite
σ-structures, LFP(F) ⊆PFP(F). Recall that Theorem 2.6.11 asserts that on
the class O of all ordered ﬁnite σ-structures, we have that LFP(O) = P(O);
moreover, Theorem 2.6.38 asserts that PFP(O) = PSPACE(O). Conse-
quently, LFP(O) ̸= PFP(O) if and only if P ̸= PSPACE. Thus, showing
that PFP has strictly higher expressive power than LFP on the class O of
all ordered ﬁnite σ-structures amounts to resolving one of the outstanding
open problems in computational complexity. Chandra and Harel [11] raised
the question of how LFP and PFP compare in terms of expressive power on
F and conjectured that LFP(F) ̸= PFP(F). Initially, researchers in ﬁnite
model theory speculated that this conjecture was not equivalent to any open
problem in complexity theory; moreover, they felt that it would be possible
to conﬁrm it using existing techniques. To justify this intuition, recall that,
by Fagin’s Theorem (Theorem 2.4.7), ESO = NP on every class C of ﬁnite
σ-structures. Consequently, showing that LFP(O) ̸= ESO(O) amounts to
establishing that P ̸= NP. In contrast, LFP(F) ̸= ESO(F), since, as shown in
this section, the Even Cardinality query is not LFP-deﬁnable on F, but,
of course, it is ESO-deﬁnable on F. Similarly, PFP(F) ̸= ESO(F), since the
Even Cardinality query is not PFP-deﬁnable on F. So, it seems plausible
that one could separate LFP from PFP on F by introducing suitable com-
binatorial games that would make it possible to diﬀerentiate between these
two ﬁxed-point logics on F; of course, these games would have to be diﬀerent
from the k-pebble games, k ≥1, since k-pebble games capture deﬁnability
in the ﬁnite-variable inﬁnitary logic Lω
∞ω, which subsumes both LFP and
PFP on classes of ﬁnite structures. It turned out, however, that this intuition
was wrong. Indeed, a decade after Chandra and Harel [11] formulated
their conjecture, Abiteboul and Vianu [3] established that the separation of
LFP from PFP on the class F of all ﬁnite σ-structures is literally equivalent
to the separation of P from PSPACE. In what follows, we shall highlight
some of the key ideas that go into the proof of this result. For a complete

2.7 Inﬁnitary Logics with Finitely Many Variables
105
proof, we refer the reader to the paper by Abiteboul and Vianu [3] and to
the subsequent excellent exposition by Dawar, Lindell, and Weinstein [15].
Deﬁnition 2.7.23. Let σ be a vocabulary and k a positive integer.
•
If A is a ﬁnite σ-structure and a is a k-tuple of elements of A, then the
k-type of a on A is the collection of all Lk
∞ω-formulas ϕ(x) such that
A |= ϕ(a).
•
If A is a ﬁnite σ-structure and a, b are two k-tuples of elements of A, then
we write A ≡k,A
∞ω b to denote that a and b have the same k-type on A.
As we have seen, LFP cannot express the Even Cardinality query
on F, but it can express every polynomial-time-computable query on O.
It follows that no LFP-formula ψ(x, y) exists such that for every ﬁnite
σ-structure A, this formula deﬁnes a linear order on the universe A of A. In
contrast, Abiteboul and Vianu [3] showed that, for every k ≥1, there is an
LFP-formula such that, for every ﬁnite σ-structure A, this formula deﬁnes
(in a sense that has to be made precise) a linear order on the set of the
equivalence classes of the equivalence relation ≡k,A
∞ω.
By deﬁnition, a linear preorder on a set B is a binary relation ⪯on B
that is reﬂexive and transitive, and has the property that, for every b1 and
b2 in B, we have that b1 ⪯b2 or b2 ⪯b1. Every linear preorder ⪯gives rise
to an equivalence relation ≡deﬁned by the condition: b1 ≡b2 if and only if
b1 ⪯b2 and b2 ⪯b1. Moreover, ⪯induces a linear order, also denoted by ⪯,
on the quotient set B/ ≡of the equivalence classes of ≡, where [b1]≡⪯[b2]≡
if and only if b1 ⪯b2. The next theorem is the key technical result in [3];
here, we shall give a hint of a diﬀerent proof that was presented in [15].
Theorem 2.7.24. Let σ be a vocabulary and F the class of all ﬁnite
σ-structures. For every positive integer k, there is an LFP-deﬁnable 2k-ary
query Qk on F such that for every ﬁnite σ-structure A, the value Qk(A) of
this query on A is a linear preorder on Ak whose induced equivalence relation
coincides with the equivalence relation ≡k,A
∞ω of k-types on A.
Proof. (Hint) Using the characterization of Lk
∞ω-equivalence in terms of
k-pebble games, it is possible to design a color-reﬁnement algorithm such
that on every ﬁnite σ-structure A, it inductively preorders all k-tuples from
A according to their k-type on A. This algorithm is naturally expressed
in inﬂationary ﬁxed point logic IFP, which, as shown by Gurevich and
Shelah [35], has the same expressive power as LFP on the class of all ﬁnite
σ-structures (see also Chap. 3 for additional information on IFP). 2
We can ﬁnally present Abiteboul and Vianu’s surprising resolution of
Chandra and Harel’s conjecture.
Theorem 2.7.25. [3] Let σ be a vocabulary and F the class of all ﬁnite
σ-structures. The following statements are then equivalent:
1. LFP(F) = PFP(F).
2. P = PSPACE.

106
2 On the Expressive Power of Logics on Finite Models
Proof. (Hint) Assume ﬁrst that LFP(F) = PFP(F). As seen in Exam-
ple 2.6.36, PFP can express PSPACE-complete queries on F. Therefore,
such queries are LFP-deﬁnable on F. Since every LFP-deﬁnable query is
polynomial-time computable, it follows that PSPACE ⊆P.
For the other direction, assume that P = PSPACE. We have to show that
LFP(F) = PFP(F). This will require essentially all the machinery we have
developed in this section. Fix a positive integer k. If A is a ﬁnite σ-structure,
then the equivalence relation ≡k,A
∞ω induces a quotient structure A/ ≡k,A
∞ω
whose universe consists of the equivalence classes [a]≡k,A
∞ω of k-tuples from A.
Let
F/ ≡k
∞ω= {A/ ≡k,A
∞ω: A ∈F}
be the class of all these quotient structures. Theorem 2.7.24 implies that
there is an LFP-deﬁnable query that deﬁnes a linear order on the universe of
every quotient structure A/ ≡k,A
∞ω in F/ ≡k
∞ω. Consequently, LFP(F/ ≡k
∞ω)
= P(F/ ≡k
∞ω). We can now use transfer properties between F and F/ ≡k
∞ω
to show that PFP(F) ⊆LFP(F), as indicated in the diagram below:
ϕ ∈PFP(F)
≡
ψ ∈LFP(F)
⏐⏐
⏐⏐
ϕ∗∈PFP(F/ ≡k
∞ω) ≡ψ∗∈LFP(F/ ≡k
∞ω)
Speciﬁcally, assume that Q is a query on F deﬁnable by a PFP-formula
ϕ with k distinct variables. The formula ϕ can be “transformed” to a
PFP-formula ϕ∗over the vocabulary of the quotient structures, so that ϕ∗
deﬁnes the “transformation” of the query Q to a query Q∗on F/ ≡k
∞ω. Since
Q∗is PFP-deﬁnable on F/ ≡k
∞ω, it is polynomial-space computable. The
hypothesis PSPACE = P implies that Q∗is polynomial-time computable,
and hence Q∗is LFP-deﬁnable on F/ ≡k
∞ω. Let ψ∗be an LFP-formula
that deﬁnes Q∗on F/ ≡k
∞ω. We can now “pull back” ψ∗and obtain an
LFP-formula ψ that deﬁnes the query Q on F. Thus, PFP(F) ⊆LFP(F). 2
Thus, the diﬀerence in computational power between polynomial-time
and polynomial-space computations, if any, amounts to the diﬀerence in
expressive power between least ﬁxed points and partial ﬁxed points of
ﬁrst-order formulas on the class of all ﬁnite structures.
2.8 Existential Inﬁnitary Logics with Finitely
Many Variables
In Sect. 2.7, we saw that the ﬁnite-variable inﬁnitary logics Lk
∞ω and the
k-pebble games, k ≥1, provide powerful tools for analyzing the expressive
power of least ﬁxed-point logic LFP. Our goal in this section is to develop
a similar methodology for analyzing the expressive power of the existential

2.8 Existential Inﬁnitary Logics with Finitely Many Variables
107
fragment of LFP and, in particular, the expressive power of Datalog and
Datalog(̸=). To this eﬀect, we shall introduce ﬁnite-variable existential
inﬁnitary logics and certain asymmetric pebble games that turn out to be
tailored for the study of Datalog and Datalog(̸=).
2.8.1 The Inﬁnitary Logics ∃Lk
∞ω and ∃Lk
∞ω(̸=)
Informally, an existential ﬁnite-variable inﬁnitary logic is a fragment of Lω
∞ω
in which the rules for constructing formulas do not include applications
of universal quantiﬁcation or negation. These fragments can be further
diﬀerentiated depending on whether the basic formulas include negated
equalities or negated atomic formulas. We now formally deﬁne two of these
fragments, originally introduced by Kolaitis and Vardi [47].
Deﬁnition 2.8.1. Let σ be a vocabulary.
•
For every positive integer k, we write ∃Lk
∞ωto denote the collection of
all L∞ω-formulas that have at most k distinct variables and are obtained
from atomic formulas (which may be equality statements) using existential
quantiﬁcation, inﬁnitary conjunction, and inﬁnitary disjunction. We
write ∃FOkto denote the collection of all ﬁrst-order ∃Lk
∞ω-formulas.
•
The ﬁnite-variable existential inﬁnitary logic ∃Lω
∞ω is the union of all
∃Lk
∞ω’s, that is,
∃Lω
∞ω =
∞

k=1
∃Lk
∞ω.
•
For every positive integer k, we write ∃Lk
∞ω(̸=) to denote the collection of
all L∞ω-formulas that have at most k distinct variables and are obtained
from atomic formulas and negated equality statements (that is, formulas of
the form t1 ̸= t2, where t1, t2 are among the k variables and the constant
symbols of σ), using existential quantiﬁcation, inﬁnitary conjunction, and
inﬁnitary disjunction. We write ∃FOk(̸=) to denote the collection of all
ﬁrst-order ∃Lk
∞ω(̸=)-formulas.
•
The ﬁnite-variable existential inﬁnitary logic ∃Lω
∞ω(̸=) is the union of all
∃Lk
∞ω(̸=)’s, that is,
∃Lω
∞ω(̸=) =
∞

k=1
∃Lk
∞ω(̸=).
As an example, the expression
(∃z)(E(x, z) ∧(∃x)(x = z ∧(∃z)(E(x, z) ∧E(z, y))))
is an ∃FO3-formula that deﬁnes the query “there is a path of length 3 from x
to y”. Actually, for every m ≥1, the query “there is a path of length m from
x to y” is ∃FO3-deﬁnable. This is a special case of a result concerning the

108
2 On the Expressive Power of Logics on Finite Models
relationship between Datalog and ∃Lω
∞ω. Before stating this result in precise
terms, we need to introduce a parametrization of Datalog programs based on
the number of variables occurring in the rules.
For every positive integer k, let k-Datalog be the collection of all Datalog
programs in which the body of every rule has at most k distinct variables
and also the head of every rule has at most k variables (the variables of
the body may be diﬀerent from the variables of the head). For instance,
the Non-2-Colorability query is expressible in 4-Datalog, since, as seen
in Example 2.6.20, it is deﬁnable by the goal predicate Q of the Datalog
program below, which asserts the existence of a cycle of odd length:






O(x, y) : −E(x, y)
O(x, y) : −E(x, z), E(z, w), O(w, y)
Q
: −O(x, x)
A complete proof of the next result can be found in [50].
Theorem 2.8.2. Let σ be a vocabulary, k a positive integer, and
φ1(x1, . . . , xn1, S1, . . . , Sl), . . . , φl(x1, . . . , xnl, S1, . . . , Sl)
a system of positive ∃FOk-formulas over the vocabulary σ ∪{S1, . . . , Sl}. The
following statements are then true for the above system and for the operator
Φ associated with it:
•
For every m ≥1, each component Φm
i , 1 ≤i ≤l, of the stage
Φm = (Φm
1 , . . . , Φm
l ) is ∃FOk-deﬁnable on the class S of all σ-structures.
•
Each component φ∞
i , 1 ≤i ≤l, of the least ﬁxed point (φ∞
1 , . . . , φ∞
l ) of
the system is ∃FOk-deﬁnable on the class of all σ-structures.
Consequently, every query deﬁnable by a k-Datalog program on the class S of
all σ-structures is also ∃Lk
∞ω-deﬁnable on S. In symbols,
k-Datalog(S) ⊆∃Lk
∞ω(S).
Proof. (Hint) This result can be proved by induction on m simultaneously
for all i ≤l. As was the case with Theorem 2.7.2, the key idea is to reuse
variables judiciously. Some additional technical diﬃculties arise from the
limited syntax of ∃Lk
∞ω. These are overcome by using the following closure
property of ∃FOk-deﬁnable queries, which has to be established separately:
If Q is an ∃FOk-deﬁnable query and π : {1, . . ., k} →{1, . . ., k} is a func-
tion, then the query Qπ is also ∃FOk-deﬁnable, where, for every σ-structure
A and every sequence (a1, . . . , ak) of elements from the universe of A,
(a1, . . . , ak) ∈Qπ(A) ⇐⇒(aπ(1), . . . , aπ(k)) ∈Q(A).
By reﬁning the proof of Proposition 2.6.21, it can be shown that
every query deﬁnable by a k-Datalog program is also deﬁnable by the

2.8 Existential Inﬁnitary Logics with Finitely Many Variables
109
least ﬁxed point of a system of positive ∃FOk-formulas. Consequently,
k-Datalog(S) ⊆∃Lk
∞ω(S). 2
A result similar to Theorem 2.8.2 can be established about the relationship
between k-Datalog(̸=) and ∃Lω
∞ω(̸=).
Theorem 2.8.3. Let k be a positive integer. Every query deﬁnable by a
k-Datalog(̸=) program on the class S of all σ-structures is also ∃Lk
∞ω(̸=)-
deﬁnable on S.
It should be pointed out that on the class F of all ﬁnite σ-structures,
k-Datalog is properly contained in ∃Lω
∞ω, since the latter can express queries
that are not computable. Similarly, k-Datalog(̸=) is properly contained in
∃Lω
∞ω(̸=) on F.
The preservation properties of Datalog and Datalog(̸=) in Propo-
sitions 2.6.23 and 2.6.26 extend to ∃Lω
∞ω
and ∃Lω
∞ω(̸=). Speciﬁcally,
every ∃Lω
∞ω-deﬁnable query is preserved under homomorphisms and every
∃Lω
∞ω-deﬁnable query is preserved under one-to-one homomorphisms. These
preservation properties give rise to suﬃcient, but not necessary, conditions for
inexpressibility in ∃Lω
∞ω or in ∃Lω
∞ω(̸=). In what follows, we shall introduce
a variant of pebble games that can actually characterize deﬁnability in these
two inﬁnitary logics.
2.8.2 Existential Pebble Games
The k-pebble game is a symmetric game, in the sense that the Duplicator
wins the k-pebble game on A and B if and only if (s)he wins the k-pebble
game on B and A. This is a consequence of the following two properties of
the k-pebble game:
1. In each move of the game, the Spoiler can choose either of the two
structures, and place a pebble on or remove a pebble from that structure.
2. The payoﬀcondition is that the substructures generated by the pebbled
elements must be isomorphic.
Thus, we can reverse the order of A and B without aﬀecting the winner of the
k-pebble game. We are interested in games that can characterize deﬁnability
in the k-variable existential inﬁnitary logics ∃Lk
∞ω, k ≥1. A closer scrutiny
of the relationship between k-pebble games and Lk
∞ω reveals that moves
of the Spoiler on the structure B correspond to universal quantiﬁcation in
Lk
∞ω-formulas. This suggests that games for ∃Lk
∞ω should be such that the
Spoiler is limited to always playing on A (and the Duplicator is limited to
always playing on B). Moreover, the payoﬀcondition should be modiﬁed
appropriately to take account of the absence of negation and universal
quantiﬁcation in ∃Lk
∞ω. These considerations led to the introduction of
existential k-pebble games in [50].

110
2 On the Expressive Power of Logics on Finite Models
Deﬁnition 2.8.4. Let k be a positive integer, σ a vocabulary, and A and B
two σ-structures. The (∃, k)-pebble game on A and B is played between two
players, called the Spoiler and the Duplicator, each of whom has k pebbles
that are labeled 1, . . . , k. In each move, the Spoiler either places a pebble
that is not currently used on an element of A or removes a pebble from
an element of A. The Duplicator responds by either placing the pebble with
the same label on an element of B or by removing the pebble with the same
label from an element of B. Assume that at some point in time during the
game, r pebbles have been placed on each structure, where 1 ≤r ≤k, and let
(ai, bi) ∈A × B, 1 ≤i ≤r, be the pairs of elements of A and B such that
the label of the pebble on ai is the same as the label of the pebble on bi.
The Spoiler wins the (∃, k)-pebble game on A and B at this point in time
if the mapping ai →bi, 1 ≤i ≤r, is not a homomorphism between the sub-
structures of A and B generated by {a1, . . . , ar} and {b1, . . . , br}, respectively.
The Duplicator wins the (∃, k)-pebble game on A and B if the above never
happens, which means that the Duplicator has a winning strategy that allows
him to continue playing “forever” by maintaining a partial homomorphism
at every point in time.
The (∃, ̸=, k)-pebble game on A and Bis deﬁned in an entirely analogous
way, with the exception that the payoﬀcondition for the Duplicator is that the
mapping ai →bi, 1 ≤i ≤r, is a one-to-one homomorphism between the sub-
structures of A and B generated by {a1, . . . , ar} and {b1, . . . , br}, respectively.
The concept of a winning strategy for the Duplicator in the (∃, k)-pebble
game and the (∃, ̸=, k)-pebble game can be made precise in terms of families
of partial homomorphisms or partial one-to-one homomorphisms with
appropriate closure and extension properties.
Deﬁnition 2.8.5. A winning strategy for the Duplicator in the (∃, k)-pebble
game (or, in the (∃, ̸=, k)-pebble game) on A and B is a nonempty family I
of partial homomorphisms (or, partial one-to-one homomorphisms) from A
to B with the following properties:
1. If f ∈I, then |f −{(cA
1 , cB
1 ), . . . , (cA
s , cB
s )}| ≤k.
2. I is closed under subfunctions:
If g ∈I and f is a function such that {(cA
1 , cB
1 ), . . . , (cA
s , cB
s )} ⊆f ⊆g,
then f ∈I.
3. I has the forth property up to k:
If f ∈I and |f −{(cA
1 , cB
1 ), . . . , (cA
1 , cB
s )}| < k, then for every a ∈A,
there is a g ∈I such that f ⊆g and a ∈dom(g).
Spoiler plays on A : a1 a2 . . . ar
↓
↓· · · ↓
Duplicator plays on B : b1 b2 . . . br
r ≤k
Fig. 2.12. A typical run of the (∃, k)-pebble game on A and B

2.8 Existential Inﬁnitary Logics with Finitely Many Variables
111
It is clear that if the Duplicator wins the k-pebble game on A and B, then
the Duplicator also wins the (∃, k)-pebble game on A and B. The converse,
however, is not always true. Intuitively, it is easier for the Duplicator to
win the (∃, k)-pebble game than it is to win the k-pebble game, because
the Spoiler cannot switch between the two structures. Note also that, unlike
the k-pebble game, the (∃, k)-pebble game is asymmetric. For instance, the
Spoiler wins the (∃, k + 1)-pebble game on the cliques Kk+1 and Kk, but the
Duplicator wins the (∃, k + 1)-pebble game on the cliques Kk and Kk+1. A
similar state of aﬀairs holds for the (∃, ̸=, k)-pebble game.
We now present the connection between existential pebble games and
deﬁnability in the ﬁnite-variable existential inﬁnitary logics.
Deﬁnition 2.8.6. Let k be a positive integer, and let A and B be two
σ-structures.
•
We write A ⪯∃,k
∞ω B to denote that every ∃Lk
∞ω-sentence that is true on
A is also true on B.
•
We write A ⪯∃,k
ωω B to denote that every ﬁrst-order sentence of ∃Lk
∞ω
that is true on A is also true on B.
•
Let a1, . . . , ar be a sequence of elements from A and let b1, . . . , br be a
sequence of elements from B, for some r ≤k. We write (A, a1, . . . , ar)
⪯∃,k
∞ω (B, b1, . . . , br) to denote that for every ∃Lk
∞ω-formula ϕ(v1, . . . , vr)
with free variables among v1, . . . , vr, we have that
A |= ϕ(v1/a1, . . . , vr/ar) =⇒B |= ϕ(v1/b1, . . . , vr/br).
The relation ⪯∃,̸=,k
∞ω
is deﬁned in a similar manner, with ∃Lk
∞ω(̸=) in place
of ∃Lk
∞ω.
Theorem 2.8.7. [47] Let k be a positive integer, and let A and B be two
σ-structures. The following statements are then equivalent:
•
A ⪯∃,k
∞ω B.
•
The Duplicator wins the (∃, k)-pebble game on A and B.
Moreover, if B is ﬁnite, then the above statements are also equivalent to
•
A ⪯∃,k
ωω B.
A similar result holds for ∃Lk
∞ω(̸=) and the (∃, ̸=, k)-pebble game.
As a consequence of Theorem 2.8.7, we obtain a characterization of
∃Lω
∞ω-deﬁnability on classes of ﬁnite structures.
Corollary 2.8.8. Let σ be a vocabulary, C a class of ﬁnite σ-structures, and
Q a Boolean query on C. The following statements are then equivalent:

112
2 On the Expressive Power of Logics on Finite Models
1. Q is ∃Lω
∞ω-deﬁnable on C.
2. There is a positive integer k such that, for every structure A∈C and every
structure B ∈C, if Q(A) = 1 and the Duplicator wins the (∃, k)-pebble
game on A and B, then Q(B) = 1.
Thus, we have a sound and complete method for studying ∃Lω
∞ω-
deﬁnability on classes of ﬁnite structures.
Method 2.8.9 The Method of (∃, k)-Pebble Games for ∃Lω
∞ω. Let σ
be a vocabulary, C a class of ﬁnite σ-structures, and Q a Boolean query on C.
Soundness. To show that Q is not ∃Lω
∞ω-deﬁnable on C, it suﬃces to show
that, for every positive integer k, there are structures Ak and Bk in C
such that
•
Q(Ak) = 1 and Q(Bk) = 0;
•
the Duplicator wins the (∃, k)-pebble game on A and B.
Completeness. This method is also complete, that is, if Q is not ∃Lω
∞ω-
deﬁnable on C, then, for every positive integer k, such structures Ak and
Bk exist.
A similar method can be used for studying ∃Lω
∞ω(̸=)-deﬁnability on
classes of ﬁnite structures using (∃, ̸=, k)-pebble games, k ≥1.
We now present some results concerning the descriptive and computa-
tional complexity of determining the winner in the (∃, k)-pebble game, k ≥1.
These results should be compared with the results in Propositions 2.7.18
and 2.7.20 and in Theorem 2.7.21 about the descriptive and computational
complexity of determining the winner in the k-pebble game, k ≥1.
Theorem 2.8.10. [50] Let σ be a vocabulary and let k be a positive integer.
1. The query “Given two σ-structures A and B, does the Spoiler win the
(∃, k)-pebble game on A and B?” is LFP-deﬁnable. As a result, there is
a polynomial-time algorithm such that, given two ﬁnite σ-structures A
and B, it determines whether the Spoiler wins the (∃, k)-pebble game on
A and B.
2. For every ﬁnite σ-structure B, there is a k-Datalog program ρB that
expresses the query “Given a σ-structure A, does the Spoiler win the
(∃, k)-pebble game on A and B?”
Proof. (Sketch) For notational simplicity, let us assume that the vocab-
ulary σ consists of relation symbols only. Let θ(x1, . . . , xk, y1, . . . , yk) be
a quantiﬁer-free formula over the vocabulary σ1 + σ2 asserting that the
correspondence xi →yi, 1 ≤i ≤k, is not a mapping or that it is a
mapping that is not a homomorphism from the substructure generated by
x1, . . . , xk over the vocabulary σ1 to the substructure induced by y1, . . . , yk
over the vocabulary σ2. In particular, θ is the disjunction of the following
formulas:

2.8 Existential Inﬁnitary Logics with Finitely Many Variables
113
•
xi = xj ∧yi ̸= yj, for every i, j ≤k such that i ̸= j.
•
R1(xi1, . . . , xim) ∧¬R2(yi1, . . . , yim), for every m-ary relation symbol R
in σ and every m-tuple (i1, . . . , im) of indices from the set {1, . . . , k}.
Let T be a 2k-ary relation symbol not in the vocabulary σ1 + σ2 and let
ϕ(x1, . . . , xk, y1, . . . , yk, T ) be the following positive ﬁrst-order formula over
the vocabulary σ1 + σ2 ∪{T }:
θ(x1, . . . , xk, y1, . . . , yk) ∨
k
j=1
(∃xj ∈D1)(∀yj ∈D2)T (x1, . . . , xk, y1, . . . , yk).
It is easy to verify that if A and B are σ-structures, and (a1, . . . , ak) and
(b1, . . . , bk) are k-tuples of elements from A and B respectively, then the
following statements are equivalent:
1. A + B |= ϕ∞(a1, . . . , ak, b1, . . . , bk).
2. The
Spoiler
wins
the
(∃, k)-pebble
game
on
(A, a1, . . . , ak)
and
(B, b1, . . . , bk).
Let ψ be the sentence (∃x1) · · · (∃xk)(∀y1) · · · (∀yk)ϕ∞(x1, . . . , xk, y1, . . . , yk)
of least ﬁxed point logic LFP. Consequently, for every σ-structure A and
every σ-structure B, the following statements are equivalent:
1. A + B |= ψ.
2. The Spoiler wins the (∃, k)-pebble game on A and B.
Note that the positive ﬁrst-order formula ϕ above involves existential quan-
tiﬁers that are interpreted over the elements of A, and universal quantiﬁers
that are interpreted over the elements of B. Consequently, if B is a ﬁxed ﬁnite
σ-structure, then the universal quantiﬁers can be replaced by ﬁnitary conjunc-
tions over the elements of the universe B of B, and thus ϕ can be transformed
to a k-Datalog program ρB that expresses the query “Given a ﬁnite σ-structure
A, does the Spoiler win the existential k-pebble game on A and B?” In what
follows, we describe this k-Datalog program in some detail. The goal of ρB is a
0-ary predicate S. Let b = (b1, . . . , bk) be a k-tuple of elements of B. For each
such k-tuple, we introduce a k-ary relation symbol Tb and the following rules:
•
For every i and j such that bi ̸= bj, we have a rule
Tb(x′
1, . . . , x′
k) : −
,
with an empty body, where x′
i = x′
j = xi and x′
s = xs, for s ̸= i, j.
Intuitively, these rules say that the correspondence xi →bi, 1 ≤i ≤k, is
not a mapping.
•
For every m-ary relation symbol R of σ and every m-ary tuple (i1, . . . , im)
such that
B, bi1, . . . , bim |= ¬R(xi1, . . . , xim),

114
2 On the Expressive Power of Logics on Finite Models
we have a rule
Tb(x1, . . . , xk) : −R(xi1, . . . , xim).
Intuitively, these rules say that the correspondence xi →bi, 1 ≤i ≤k, is
not a partial homomorphism.
•
For every j such that 1 ≤j ≤k, we have a rule
T (x1, . . . , xk) : −
	
c∈B
Tb[j/c](x1, . . . , xj−1, y, xj+1, . . . , xk),
where b[j/c] = (b1, . . . , bj−1, c, bj+1, . . . , bk) and y is a new variable (note,
however, that the body of the rule has k variables).
•
For the goal predicate S, we have the rule
S : −
	
b∈Bk
Tb(x1, . . . , xk).
2
As stated in Theorem 2.7.19, Grohe [34] showed that if σ is a vocabulary
containing at least one binary relation symbol, then for every k ≥2, the
following query is P-complete: “given two ﬁnite σ-structures A and B, does
the Duplicator win the k-pebble game on A and B?” In this query, both
structures A and B are part of the input. Recall, however, that the complexity
drops if the structure B is kept ﬁxed. Indeed, as shown in Theorem 2.7.21,
for each ﬁxed positive integer k and for each ﬁxed ﬁnite σ-structure B, the
following query is FOk-deﬁnable (and, hence, solvable in logarithmic space):
“given a ﬁnite σ-structure A, does the Duplicator win the k-pebble game
on A and B?” In contrast, we now show that determining the winner in the
(∃, k)-pebble game can be P-complete, even for a ﬁxed k and a ﬁxed B.
Proposition 2.8.11. There are a vocabulary σ consisting of relation symbols
of arity at most 3 and a ﬁnite σ-structure B such that the following query
is P-complete: “given a ﬁnite σ-structure A, does the Duplicator win the
(∃, 3)-pebble game on A and B?”
Proof. We shall describe a logarithmic-space reduction from the satisﬁability
problem Horn 3-Sat for Horn formulas with at most three literals per
clause, which is a well-known P-complete problem (see [32])
Let σ be a vocabulary consisting of two unary relation symbols N1 and
P1, two binary relation symbols N2 and P2, and two ternary relation symbols
N3 and P3. intuition These relation symbols will represent the various types
of clauses that may occur in a Horn formula with at most three literals per
clause. Speciﬁcally, N1 and P1 will represent the unit clauses ¬x and x, N2
and P2 will represent the binary Horn clauses ¬x∨¬y and ¬x∨y, and N3 and
P3 will represent the ternary Horn clauses ¬x ∨¬y ∨¬z and ¬x ∨¬y ∨z. Let
B be the Boolean σ-structure whose relations are the sets of satisfying truth
assignments of Horn clauses with at most three literals per clause. More pre-
cisely, the universe of B is the set {0, 1} and the relations of B are as follows:

2.8 Existential Inﬁnitary Logics with Finitely Many Variables
115
•
N B
1 = {0} and P B
1 = {1};
•
N B
2 = {0, 1}2 −{(1, 1)} and P B
2 = {0, 1}2 −{(1, 0)};
•
N B
3 = {0, 1}3 −{(1, 1, 1)} and N B
3 = {0, 1}3 −{(1, 1, 0)}.
If ϕ is a Horn formula with at most three literals per clause, then ϕ can be
encoded by a ﬁnite σ-structure Aϕ such that the universe A of A is the set
of all variables occurring in ϕ and the relations on A represent the clauses of
ϕ. For instance, N A
2 consists of all pairs (x, y) of variables such that ¬x ∨¬y
is a clause of ϕ, and P A
3
consists of all triples (x, y, z) of variables such that
¬x ∨¬y ∨z is a clause of ϕ. Clearly, Aϕ can be constructed in logarithmic
space from ϕ.
We now claim that ϕ is satisﬁable if and only if the Duplicator wins
the (∃, 3)-pebble game on Aϕ and B. If ϕ is satisﬁable, then a satisfying
truth assignment is a homomorphism from Aϕ to B. Hence, the Duplicator
can win the (∃, 3)-pebble game on Aϕ and B by using the values of this
homomorphism to respond to the moves of the Spoiler. In fact, in this case the
Duplicator can win the (∃, k)-pebble game on Aϕ and B for every k ≥1. The
other direction requires more work. We start with the observation that the
well-known polynomial-time marking algorithm for Horn satisﬁability is read-
ily expressible in 3-Datalog. More precisely, consider the following 3-Datalog
program π with T and P as its IDB predicates and P as its goal predicate:












T (z) : −P1(z)
T (z) : −P2(x, z), T (x)
T (z) : −P3(x, y, z), T (x), T (y)
P
: −N1(x), T (x)
P
: −N2(x, y), T (x), T (y)
P
: −N3(x, y, z), T (x), T (y), T (z)
It is easy to verify that B does not satisfy the goal predicate P. Moreover, a
Horn formula ϕ with at most three literals per clause is unsatisﬁable if and
only if the structure Aϕ satisﬁes the goal predicate P. This holds because the
ﬁrst three rules of π mimic the marking algorithm for Horn satisﬁability by
putting into the predicate T all variables of ϕ that must take the value “true”
in every satisfying truth assignment; the last three rules capture the possible
ways in which a Horn formula may be found to be unsatisﬁable by this
algorithm because all variables occurring in some negative clause are forced to
take the value “true”. Assume now that the Duplicator wins the (∃, 3)-pebble
game on Aϕ and B. We claim that ϕ is satisﬁable. If this is not the case,
then Aϕ satisﬁes the goal predicate P of the above 3-Datalog program π.
Since the Duplicator wins the (∃, 3)-pebble game on Aϕ and B, Theorem
2.8.8 implies that B satisﬁes the goal predicate P of π, which is not true. 2
Obviously, Proposition 2.8.11 implies that, when both structures A and
B are part of the input, then determining the winner in the (∃, 3)-pebble
game is a P-complete problem. In fact, it is known that this holds for every
ﬁxed k ≥2 and for vocabularies consisting of a binary relation symbol

116
2 On the Expressive Power of Logics on Finite Models
and a ﬁxed number of unary relation symbols [48]. As stated earlier, it has
been conjectured, but remains to be proved, that determining the winner
in the k-pebble game when k is part of the input is an EXPTIME-complete
problem. In contrast, determining the winner in the (∃, k)-pebble game when
k is part of the input has been shown to be EXPTIME-complete.
Theorem 2.8.12. [48] The following problem is EXPTIME-complete: given
a positive integer k, a vocabulary σ consisting of one binary relation symbol
and a number of unary relation symbols, and two ﬁnite σ-structures A and
B, does the Duplicator win the (∃, k)-pebble game on A and B?
We note that some of the results about Datalog and (∃, k)-pebble games
that we have presented here have found numerous applications to the study of
constraint satisfaction problems, which is the topic of Chap. 6 of this volume.
2.8.3 Descriptive Complexity of Fixed Subgraph Homeomorphism
Queries
The original motivation behind the introduction of (∃, k)-pebble games and
(∃, ̸=, k)-pebble games in [47] was to develop tools for analyzing the expressive
power of Datalog and Datalog(̸=). We now close this chapter by presenting a
case study of the expressibility of certain important graph-theoretic problems
in Datalog(̸=) using (∃, ̸=, k)-pebble games.
Deﬁnition 2.8.13. Let H and G be two directed graphs.
A homeomorphism h : H ⇝G from H to G is a one-to-one mapping
from the nodes of H to the nodes of G such that h maps the edges of H to
pairwise node-disjoint simple paths of G.
The concept of a homeomorphism gives rise to a family of decision
problems on directed graphs, one for each ﬁxed ﬁnite directed graph H.
Deﬁnition 2.8.14. Let H be a ﬁxed ﬁnite directed graph. The Fixed Sub-
graph Homeomorphism Query with Pattern H, denoted by FiSH(H),
asks: given a directed graph G and a one-to-one mapping from the nodes of
H to the nodes of G, is there a homeomorphism h : H ⇝G extending this
mapping?
The following examples illustrate some typical members of this family of
queries.
Example 2.8.15. Let H be a directed graph consisting of two parallel directed
edges, that is, H has four nodes s1, s2, t1, t2 and two edges (s1, t1), (s2, t2),
as depicted in the upper part of Fig. 2.13.
FiSH(H) is then the 2-Disjoint Paths query: given a directed graph G
and four nodes s′
1, s′
2, t′
1, t′
2, does G contain two node-disjoint simple paths
from s′
1 to t′
1 and from s′
2 to t′
2? This is depicted in the lower part of Fig. 2.13.
If H is taken to be a graph consisting of m parallel directed edges, this
example generalizes to the m-Disjoint Paths query, m ≥2.

2.8 Existential Inﬁnitary Logics with Finitely Many Variables
117
-
-
s2
t2
t1
s1
-
-
t′
2
t′
1
-
-
-
-
s′
2
s′
1
Fig. 2.13. The 2-Disjoint Paths query
Example 2.8.16. If C3 is a directed cycle with three nodes, then FiSH(C3)
is the following query: given a directed graph G and three nodes a1, a2, a3,
is there a simple cycle in G containing these nodes?
If H is taken to be a directed cycle Cm with m nodes, m ≥3, this
example generalizes to the following query: given a directed graph G and m
nodes a1, . . . , am, is there a simple cycle in G containing these m nodes?
Fortune, Hopcroft, and Wyllie [26] obtained a complete classiﬁcation of
the computational complexity of all FiSH(H) queries as H ranges over all
ﬁnite directed graphs. Before stating this classiﬁcation result, we need one
more concept.
Deﬁnition 2.8.17. A star graph is a directed graph that consists either of a
single source node and edges emanating from this node or of a single sink node
and edges terminating on this node. Star graphs are depicted in Fig. 2.14.
Theorem 2.8.18. [26] The following dichotomy holds for the computational
complexity of the Fixed
Subgraph
Homeomorphism
Query
with
Pattern H, where H ranges over all ﬁnite directed graphs:
?


-
6
I
6

-
R ?


Fig. 2.14. Star graphs

118
2 On the Expressive Power of Logics on Finite Models
•
If H is a star graph, then FiSH(H) is in P.
•
If H is not a star graph, then FiSH(H) is NP-complete.
Let us digress for a moment and explain why the preceding result is a
dichotomy theorem. Ladner [51] showed that if P ̸= NP, then there is a
decision problem Q such that
•
Q ∈NP −P;
•
Q is not NP-complete.
Thus, if P ̸= NP, then NP contains problems of intermediate complexity
between polynomial-time solvability and NP-completeness. Theorem 2.8.18,
however, asserts that no FiSH(H) query is a problem of such intermediate
complexity; this dichotomy is illustrated in Fig. 2.15.
Note that the dichotomy in the computational complexity of FiSH(H)
queries is proper only if P ̸= NP. We now present a dichotomy in the
descriptive complexity of FiSH(H) queries that does not depend on any
complexity-theoretic assumptions.
Theorem 2.8.19.
[47] The following dichotomy holds for the descriptive
complexity of the Fixed
Subgraph
Homeomorphism
Query
with
Pattern H, where H ranges over all ﬁnite directed graphs:
•
If H is a star graph, then FiSH(H) is ∃Lω
∞ω(̸=)-deﬁnable; in fact, it is
deﬁnable in Datalog(̸=).
•
If H is not a star graph, then FiSH(H) is not ∃Lω
∞ω(̸=)-deﬁnable.
Proof. (Hint) If H is a star graph, then the FiSH(H) query is solvable in
polynomial time using a max ﬂow algorithm, which can be expressed by a
Datalog(̸=) program.
The 2-Disjoint Paths query is the key case of the results concerning
the inexpressibility of FiSH(H) in Datalog(̸=) when H is not a star graph.
To this eﬀect, one can show that, for every k ≥1, there are directed graphs
Ak and Bk such that the following hold:
↗
NP-complete
FiSH(H)
NP −P
↘
P
Fig. 2.15. The dichotomy in the computational complexity of FiSH(H) queries

References
119
•
Ak satisﬁes the 2-Disjoint Paths query, but Bk does not;
•
the Duplicator wins the (∃, ̸=, k)-pebble game on Ak, Bk.
The graph Ak consists of two disjoint suﬃciently long paths. The graph
Bk, however, is much more complicated and so is the description of the
Duplicator’s winning strategy in the (∃, ̸=, k)-pebble game on Ak and Bk.
This graph is extracted from the reduction of 3-Sat to 2-Disjoint Paths
used by Fortune, Hopcroft, and Wyllie [26] to establish that the 2-Disjoint
Paths query is NP-hard. 2
Several remarks are in order now. The ﬁrst is that the proof of Theorem
2.8.19 reveals that certain constructions used to prove NP-hardness can
also be used to obtain interesting structures on which to play combinatorial
games and establish lower bounds for deﬁnability. Note that the dichotomy
in the descriptive complexity of FiSH(H) queries cannot be proved using
preservation properties of Datalog(̸=), because these queries are preserved
under one-to-one homomorphisms.
It is an open problem to signiﬁcantly strengthen the lower bound in
Theorem 2.8.19 by establishing that if H is not a star graph, then the
FiSH(H) query is not Lω
∞ω-deﬁnable. The critical step would be to show
that the 2-Disjoint Paths query is not Lω
∞ω-deﬁnable.
As a by-product of their celebrated work on the graph minor problem,
Robertson and Seymour [57, 58] showed that every FiSH(H) query is
solvable in polynomial time when restricted to undirected graphs. It would
be interesting to carry out a detailed study of the descriptive complexity
of FiSH(H) queries on undirected graphs. A preliminary investigation by
Barland [7] showed that the FiSH(C3) query is LFP-deﬁnable on the class
G of all ﬁnite undirected graphs. This suggests that if there is a dichotomy
in the descriptive complexity of FiSH(H) queries on undirected graphs, then
the boundary of that dichotomy is going to be diﬀerent from the boundary
of the dichotomy in Theorem 2.8.19.
Acknowledgments
I am truly grateful to Timos Antonopoulos, Costas D. Koutras, and Scott
Weinstein for reading carefully an earlier version of this chapter and oﬀering
numerous corrections and suggestions.
References
1. S. Abiteboul, R. Hull, and V. Vianu. Foundations of Databases. Addison-Wesley,
1995.
2. S. Abiteboul and V. Vianu.
Datalog extensions for database queries and
updates. Journal of Computer and System Sciences, 43:62–124, 1991.

120
2 On the Expressive Power of Logics on Finite Models
3. S. Abiteboul and V. Vianu. Generic computation and its complexity. In Proc.
23rd ACM Symp. on Theory of Computing, pages 209–219, 1991.
4. M. Ajtai and R. Fagin. Reachability is harder for directed than for undirected
ﬁnite graphs. Journal of Symbolic Logic, 55(1):113–150, 1990.
5. M. Ajtai and Y. Gurevich. Monotone versus positive. Journal of the ACM,
34:1004–1015, 1987.
6. S. Arora and R. Fagin. On winning strategies in Ehrenfeucht-Fra¨ıss´e games.
Theoretical Computer Science, 174:97–121, 1997.
7. I. Barland.
Expressing Optimization Problems as Integer Programs, and
Undirected Path Problems: a Descriptive Complexity Approach.
PhD thesis,
University of California, Santa Cruz, 1996.
8. J. Barwise.
On Moschovakis closure ordinals.
Journal of Symbolic Logic,
42:292–296, 1977.
9. A. Blass, Y. Gurevich, and D. Kozen. A zero–one law for logic with a ﬁxed
point operator. Information and Control, 67:70–90, 1985.
10. A. Chandra and D. Harel. Computable queries for relational databases. Journal
of Computer and System Sciences, 21:156–178, 1980.
11. A. Chandra and D. Harel.
Structure and complexity of relational queries.
Journal of Computer and System Sciences, 25:99–128, 1982.
12. A. Chandra and D. Harel. Horn clause queries and generalizations. Journal of
Logic Programming, 1:1–15, 1985.
13. S. A. Cook. An observation of time–storage trade-oﬀ. Journal of Computer
and System Sciences, 9:308–316, 1974.
14. A. Dawar.
A restricted second-order logic for ﬁnite structures.
Information
and Computation, 143:154–174, 1998.
15. A. Dawar, S. Lindell, and S. Weinstein. Inﬁnitary logic and inductive deﬁnability
over ﬁnite structures. Information and Computation, 119:160–175, 1995.
16. M. de Rougemont. Second-order and inductive deﬁnability on ﬁnite structures.
Zeitschrift f¨ur Mathematische Logik und Grundlagen der Mathematik, 33:47–63,
1987.
17. M. A. Dickmann. Larger inﬁnitary languages. In J. Barwise and S. Feferman,
editors, Model-Theoretic Logics, pages 317–363. Springer, 1985.
18. R. Diestel. Graph Theory. Springer, 1997.
19. A. Ehrenfeucht.
An application of games to the completeness problem for
formalized theories. Fundamenta Mathematicae, 49:129–141, 1961.
20. H. B. Enderton. A Mathematical Introduction to Logic. Academic Press, New
York, 1972.
21. R. Fagin. Generalized ﬁrst-order spectra and polynomial-time recognizable sets.
In R. M. Karp, editor, Complexity of Computation, SIAM-AMS Proceedings,
volume 7, pages 43–73, 1974.
22. R. Fagin.
Monadic generalized spectra.
Zeitschrift f¨ur Mathematische Logik
und Grundlagen der Mathematik, 21:89–96, 1975.
23. R. Fagin. Probabilities on ﬁnite models. Journal of Symbolic Logic, 41:50–58,
1976.
24. R. Fagin.
Easier ways to win logical games.
In N. Immerman and Ph. G.
Kolaitis, editors, Descriptive Complexity and Finite Models, DIMACS Series
in Discrete Mathematics and Theoretical Computer Science, volume 31, pages
1–32. American Mathematical Society, 1997.

References
121
25. R. Fagin, L. Stockmeyer, and M. Y. Vardi. On monadic NP vs. monadic co-NP.
Information and Computation, 120(1):78–92, July 1995.
26. S. Fortune, J. Hopcroft, and J. Wyllie. The directed homeomorphism problem.
Theoretical Computer Science, 10:111–121, 1980.
27. R. Fra¨ıss´e. Sur quelques classiﬁcations des syst`emes de relations. Publications
Scientiﬁques de l’Universit´e d’ Alger, Series A, 1:35–182, 1954.
28. H. Gaifman.
On local and nonlocal properties.
In J. Stern, editor, Logic
Colloquium ’81, pages 105–135. North-Holland, 1982.
29. H. Gaifman and M. Y. Vardi. A simple proof that connectivity is not ﬁrst-order
deﬁnable.
Bulletin of the European Association for Theoretical Computer
Science, 26:43–45, June 1985.
30. M. R. Garey and D. S. Johnson. Computers and Intractability – A Guide to
the Theory of NP-Completeness. W. H. Freeman, 1979.
31. Y. V. Glebskii, D. I. Kogan, M. I. Liogonki, and V. A. Talanov.
Range
and degree of realizability of formulas in the restricted predicate calculus.
Cybernetics, 5:142–154, 1969.
32. R. Greenlaw, H. J. Hoover, and W. L. Ruzzo. Limits to Parallel Computation:
P-Completeness Theory. Oxford University Press, New York, 1995.
33. M. Grohe. Complete problems for ﬁxed-point logics. Journal of Symbolic Logic,
60(2):517–527, 1995.
34. M. Grohe. Equivalence in ﬁnite-variable logics is complete for polynomial time.
Combinatorica, 19(4):507–523, 1999.
35. Y. Gurevich and S. Shelah. Fixed point extensions of ﬁrst-order logic. Annals
of Pure and Applied Logic, 32:265–280, 1986.
36. W. Hanf.
Model-theoretic methods in the study of elementary logic.
In
J. Addison, L. Henkin, and A. Tarski, editors, The Theory of Models, pages
132–145. North-Holland, 1965.
37. J Hartmanis.
Turing Award Lecture: On computational complexity and the
nature of computer science. Communications of the ACM, 37:37–43, 1994.
38. N. Immerman. Upper and lower bounds for ﬁrst-order expressibility. Journal
of Computer and System Sciences, 25:76–98, 1982.
39. N. Immerman. Relational queries computable in polynomial time. Information
and Control, 68:86–104, 1986.
40. N. Immerman. Descriptive Complexity Springer, 1999.
41. H. J. Keisler. Model Theory for Inﬁnitary Logic. North-Holland, 1971.
42. S. C. Kleene. Arithmetical predicates and function quantiﬁers. Transactions of
the American Mathematical Society, 79:312–340, 1955.
43. B. Knaster. Un th´eor`eme sur les fonctions d’ensembles. Annales de la Soci´et´e
Polonaise de Mathematique, 6:133–134, 1928.
44. Ph. G. Kolaitis and M. Y. Vardi. The decision problem for the probabilities of
higher-order properties. In Proc. 19th ACM Symp. on Theory of Computing,
pages 425–435, 1987.
45. Ph. G. Kolaitis and M. Y. Vardi. Fixpoint logic vs. inﬁnitary logic in ﬁnite-
model theory. In Proc. 6th IEEE Symp. on Logic in Computer Science, pages
46–57, 1992.
46. Ph. G. Kolaitis and M. Y. Vardi. Inﬁnitary logic and 0–1 laws. Information
and Computation, 98:258–294, 1992.
Special issue: Selections from the Fifth
Annual IEEE Symposium on Logic in Computer Science.

122
2 On the Expressive Power of Logics on Finite Models
47. Ph. G. Kolaitis and M. Y. Vardi. On the expressive power of Datalog: tools
and a case study. Journal of Computer and System Sciences, 51(1):110–134,
August 1995.
Special Issue: Selections from Ninth Annual ACM SIGACT–
SIGMOD–SIGART Symposium on Principles of Database Systems (PODS),
Nashville, TN, April 1990.
48. Ph. G. Kolaitis and J. Panttaja. On the complexity of existential pebble games.
In 2003 Annual Conference of the European Association for Computer Science
Logic, CSL ’03, Lecture Notes in Computer Science, volume 2803, Springer,
pages 314–329, 2003.
49. Ph. G. Kolaitis and M. Y. Vardi. On the expressive power of variable-conﬁned
logics. In Proceedings of 11th Annual IEEE Symposium on Logic in Computer
Science - LICS ’96, pages 348–59, 1996.
50. Ph. G. Kolaitis and M. Y. Vardi. Conjunctive-query containment and constraint
satisfaction. Journal of Computer and System Sciences, pages 302–332, 2000.
Earlier version in: Proc. 17th ACM Symp. on Principles of Database Systems
(PODS ’98).
51. R. E. Ladner. On the structure of polynomial time reducibility. Journal of the
Association for Computing Machinery, 22(1):155–171, 1975.
52. M. McArthur. Convergence and 0–1 laws for Lk
∞ω under arbitrary measures.
In 1994 Annual Conference of the European Association for Computer Science
Logic, CSL ’94, Lecture Notes in Computer Science, volume 933, pages 228–241.
Springer, 1995.
53. R. Milner.
Operational and algebraic semantics of concurrent processes.
In
J. van Leeuween, editor, Handbook of Theoretical Computer Science, volume B,
pages 1201–1242. MIT Press/Elsevier, 1990.
54. Y. N. Moschovakis.
Elementary Induction on Abstract Structures.
North-
Holland, 1974.
55. C. H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994.
56. E. Pezzoli. Computational complexity of Ehrenfeucht–Fra¨ıss´e games on ﬁnite
structures. In Proc. 12th International Workshop on Computer Science Logic,
CSL ’98, Lecture Notes in Computer Science, volume 1584, pages 159–170.
Springer, 1999.
57. N. Robertson and P. D. Seymour. Disjoint paths – a survey. SIAM Journal of
Algebraic and Discrete Methods, 6:300–305, 1985.
58. N. Robertson and P. D. Seymour.
Graph Minors. XIII. The disjoint paths
problem. Journal of Combinatorial Theory B, 63:65–110, 1995.
59. T. Schwentick.
Graph connectivity and monadic NP.
In Proc. 35th IEEE
Symp. on Foundations of Computer Science, pages 614–622, 1994.
60. D. Scott. Logic with denumerably long formulas and ﬁnite strings of quantiﬁers.
In J. W. Addison, L. Henkin, and A. Tarski, editors, The Theory of Models,
pages 320–341. North-Holland, 1965.
61. S. Shelah and J. Spencer. Zero–one laws for sparse random graphs. Journal of
the American Mathematical Society, 1:97–115, 1988.
62. C. Spector. Inductively deﬁned sets of natural numbers. In Inﬁnitistic Methods,
pages 97–102. Pergamon, 1961.
63. L. J. Stockmeyer.
The polynomial-time hierarchy.
Theoretical Computer
Science, 3:1–22, 1977.
64. A. Tarski. A lattice theoretical ﬁxpoint theorem and its applications. Paciﬁc
Journal of Mathematics, 5:285–309, 1955.

References
123
65. J. D. Ullman.
Database and Knowledge-Base Systems, volumes I and II.
Computer Science Press, 1989.
66. J. van Benthem. Correspondence theory. In D. M. Gabbay and F. Guenthner,
editors, Handbook of Philosophical Logic, volume 2, pages 167–247. Reidel, 1984.
67. M. Y. Vardi. The complexity of relational query languages. In Proc. 14th ACM
Symp. on Theory of Computing, pages 137–146, 1982.


3
Finite Model Theory and Descriptive
Complexity
Erich Gr¨adel
This chapter deals with the relationship between logical deﬁnability and
computational complexity on ﬁnite structures. Particular emphasis is given
to game-based evaluation algorithms for various logical formalisms and to
logics capturing complexity classes.
In addition to the most common logical systems such as ﬁrst-order and
second-order logic (and their fragments), this survey focuses on algorithmic
questions and complexity results related to ﬁxed-point logics (including
ﬁxed-point extensions of ﬁrst-order logic, the modal μ-calculus, the database
query language Datalog, and ﬁxed-point logics with counting).
Finally, it is discussed how the general approach and the methodology of
ﬁnite model theory can be extended to suitable domains of inﬁnite structures.
As an example, some results relating metaﬁnite model theory to complexity
theory are presented.
3.1 Deﬁnability and Complexity
One of the central issues in ﬁnite model theory is the relationship between
logical deﬁnability and computational complexity. We want to understand
how the expressive power of a logical system – such as ﬁrst-order or second-
order logic, least ﬁxed-point logic, or a logic-based database query language
such as Datalog – is related to its algorithmic properties. Conversely, we want
to relate natural levels of computational complexity to the deﬁning power of
logical languages, i.e., we want logics that capture complexity classes.1
The aspects of ﬁnite model theory that are related to computational
complexity are also referred to as descriptive complexity theory. While
computational complexity theory is concerned with the computational
resources such as time, space, or the amount of hardware that are necessary
to decide a property, descriptive complexity theory asks for the logical
1 For a potential application of such results, see Exercise 3.5.32.

126
3 Finite Model Theory and Descriptive Complexity
resources that are necessary to deﬁne it. In this chapter we shall give a
survey of descriptive complexity theory. We shall assume that the reader is
familiar with fundamental notions of logic and complexity theory. Speciﬁcally
we assume familiarity with ﬁrst-order logic and with deterministic and
non-deterministic complexity classes. See the appendix to this chapter for a
brief survey on alternating complexity classes.
In Sect. 3.1, we discuss some basic issues concerning the relationship
between logic and complexity, we introduce model-checking games, and we
determine in a detailed way the complexity of ﬁrst-order model checking.
In Sect. 3.2, we make precise the notion of a logic capturing a complexity
class. As our ﬁrst capturing result, we prove Fagin’s Theorem, which says
that existential second-order logic captures NP. In a limited scenario, namely
for the domain of ordered structures, we then derive capturing results for a
number of other complexity classes, including PTIME and LOGSPACE, by
use of fragments of second-order logic (such as second-order Horn logic) and
by extensions of ﬁrst-order logic (such as transitive closure logics).
Section 3.3 is devoted to ﬁxed-point logics. These are probably the most
important logics for ﬁnite model theory and also play an important role in
many other ﬁelds of logic in computer science. We shall discuss many variants
of ﬁxed point logics, including least, inﬂationary and partial ﬁxed point logic,
the modal μ-calculus, and the database query language Datalog. We shall
explain model checking issues, capturing results for PTIME and PSPACE,
and also discuss structural issues for these logics.
In Sect. 3.4 we introduce logics with counting. One of the limitations of
common logics on ﬁnite structures is an inability to count. By adding to ﬁrst-
order logic and, in particular, to ﬁxed-point logic an explicit counting mecha-
nism, one obtains powerful logics that come quite close to capturing PTIME.
Section 3.5 is devoted to capturing results on certain speciﬁc domains
of unordered structures, via a technique called canonization. While the
general problem of whether there exists a logic capturing PTIME on all
ﬁnite structures is still open (and it is widely conjectured that no such logic
exists), canonization permits us to ﬁnd interesting domains of structures
where ﬁxed-point logic or ﬁxed-point logic with counting can express all
of PTIME.
Finally, in Sect. 3.6 we discuss the extension of the general approach and
methods of ﬁnite model theory to suitable domains of inﬁnite structures, i.e.,
the generalization of ﬁnite model theory to an algorithmic model theory. We
discuss several domains of inﬁnite structures for which this approach makes
sense, and then treat, as an example, the domain of metaﬁnite structures, for
which capturing results have been studied in some detail.
3.1.1 Complexity Issues in Logic
One of the central issues in the relationship between complexity theory
and logic is the algorithmic complexity of the common reasoning tasks for

3.1 Deﬁnability and Complexity
127
a logic. There are numerous such tasks, but most of them can be easily
reduced to two (at least for logics with reasonable closure properties), namely
satisﬁability testing and model checking. The satisﬁability problem for a
logic L on a domain D of structures takes formulae ψ ∈L as inputs, and the
question to be answered is whether there exists in D a model for ψ. Although
satisﬁability problems are of fundamental importance in many areas of logic
and its applications, they do not really play a crucial role in ﬁnite model
theory. Nevertheless, they are considered occasionally and, moreover, some
of the central results of ﬁnite model theory have interesting connections with
satisﬁability problems. We shall point out some such relations later.
On the other hand, model-checking problems occupy a central place in
ﬁnite model theory. For a logic L and a domain D of (ﬁnite) structures, the
model-checking problem asks, given a structure A ∈D and a formula
ψ ∈L, whether it is the case that A |= ψ. A closely related problem is
formula evaluation (or query evaluation): given a structure A and a
formula ψ(x) (with free variables x), the problem is to compute the relation
deﬁned by ψ on A, i.e. the set ψA := {a : A |= ψ(a)}. Obviously, the
evaluation problem for a formula with k free variables on a structure with n
elements reduces to nk model-checking problems.
Note that a model-checking problem has two inputs: a structure and
a formula. We can measure the complexity in terms of both inputs, and
this is what is commonly refered to as the combined complexity of the
model-checking problem (for L and D). However, in many cases, one of the
two inputs is ﬁxed, and we measure the complexity only in terms of the other.
If we ﬁx the structure A, then the model-checking problem for L on this
structure amounts to deciding ThL(A) := {ψ ∈L : A |= ψ}, the L-theory
of A. The complexity of this problem is called the expression complexity
of the model-checking problem (for L on A). For ﬁrst-order logic (FO) and
for monadic second-order logic (MSO) in particular, such problems have a
long tradition in logic and numerous applications in many ﬁelds. Of even
greater importance for ﬁnite model theory are model-checking problems for a
ﬁxed formula ψ, which amounts to deciding the model class of ψ inside D,
ModD(ψ) := {A ∈D : A |= ψ}. Its complexity is the structure complexity
or data complexity of the model-checking problem (for ψ on D).
Besides the algorithmic analysis of logic problems, there is another aspect
of logic and complexity that has become even more important for ﬁnite model
theory, and which is really the central programme of descriptive complexity
theory. The goal here is to characterize complexity from the point of view
of logic (or, more precisely, model theory)2 by providing, for each important
complexity level, logical systems whose expressive power (on ﬁnite structures,
or on a particular domain of ﬁnite structures) coincides precisely with that
2 There also exist other logical approaches to complexity, based for instance on
proof theory. Connections to the ﬁnite model theory approach exist, but the
ﬂavour is quite diﬀerent.

128
3 Finite Model Theory and Descriptive Complexity
complexity level. For a detailed deﬁnition, see Sect. 3.2. We shall see that
there have been important successes in this programme, but that there also
remain diﬃcult problems that are still open.
3.1.2 Model Checking for First-Order Logic
We shall now discuss the problem of evaluating ﬁrst-order formulae on ﬁnite
structures using a game-based approach. Model-checking problems, for almost
any logic, can be cast as strategy problems for appropriate model-checking
games (also called Hintikka games).3 With any formula ψ(x), any structure A
(of the same vocabulary as ψ), and any tuple a of elements of A, we associate
a model-checking game G(A, ψ(a)). It is played by two players, Veriﬁer
and Falsiﬁer. Veriﬁer (sometimes also called Player 0, or ∃, or Eloise) tries
to prove that A |= ψ(a), whereas Falsiﬁer (also called Player 1, or ∀, or
Abelard) tries to establish that the formula is false. For ﬁrst-order logic, the
evaluation games are very simple, in the sense that winning conditions are
positional, and that the games are well-founded, i.e. all possible plays are
ﬁnite (regardless of whether the input structure is ﬁnite or inﬁnite). For more
powerful logics, notably ﬁxed-point logics, model checking-games may have
inﬁnite plays and more complicated winning conditions (see Sect. 3.3.4).
The Game G(A, ψ(a))
Let A be a ﬁnite structure and let ψ(x) be a relational ﬁrst-order formula,
which we assume to be in negation normal form, i.e. built up from atoms
and negated atoms by means of the propositional connectives ∧, ∨and the
quantiﬁers ∃, ∀. Obviously, any ﬁrst-order formula can be converted in linear
time into an equivalent one in negation normal form. The model-checking
game G(A, ψ(a)) has positions (ϕ, ρ) such that ϕ is a subformula of ψ, and
ρ : free(ϕ) →A is an assignment from the free variables of ϕ to elements of
A. To simplify the notation we usually write ϕ(b) for a position (ϕ, ρ) where
ρ assigns the tuple b to the free variables of ϕ. The initial position of the
game is the formula ψ(a).
Veriﬁer (Player 0) moves from positions associated with disjunctions and
with formulae starting with an existential quantiﬁer. From a position ϕ ∨ϑ,
she moves to either ϕ or ϑ. From a position ∃yϕ(b, y), Veriﬁer can move to any
position ϕ(b, c), where c ∈A. Dually, Falsiﬁer (Player 1) makes corresponding
moves from conjunctions and universal quantiﬁcations. At atoms or negated
atoms, i.e. positions ϕ(b) of the form b = b′, b ̸= b′, Rb, or ¬Rb, the game is
over. Veriﬁer has won the play if A |= ϕ(b); otherwise, Falsiﬁer has won.
Model-checking games are a way of deﬁning the semantics of a logic. The
equivalence to the standard deﬁnition can be proved by a simple induction.
3 These games should not be confounded with the games used for model comparison
(Ehrenfeucht–Fra¨ıss´e games) that describe the power of a logic for distinguishing
between two structures.

3.1 Deﬁnability and Complexity
129
Proposition 3.1.1. Veriﬁer has a winning strategy for the game G(A, ψ(a))
if, and only if, A |= ψ(a).
This suggests a game-based approach to model checking: given A and
ψ, construct the game G(A, ψ) and decide whether Veriﬁer has a winning
strategy from the initial position. Let us therefore look a little closer at
strategy problems for games.
3.1.3 The Strategy Problem for Finite Games
Abstractly, we can describe a two-player game with positional winning
conditions by a directed game graph G = (V, V0, V1, E), with a partioning
V = V0 ∪V1 of the nodes into positions where Player 0 moves and positions
where Player 1 moves. The possible moves are described by the edge relation
E ⊆V × V . We call w a successor of v if (v, w) ∈E, and we denote the set
of all successors of v by vE. To decribe the winning conditions, we adopt
the convention that Player σ loses at positions v ∈Vσ where no moves are
possible. (Alternatively, one could explicitly include in the game description
the sets S0, S1 of winning terminal positions for each player.)
A play of G is a path v0, v1, . . . formed by the two players starting from a
given position v0. Whenever the current position vn belongs to Vσ, Player σ
chooses a move to a successor vn+1 ∈vnE; if no move is available, then
Player σ has lost the play. If this never occurs, the play goes on inﬁnitely and
the winner has to be established by a winning condition on inﬁnite plays. For
the moment, let us say that inﬁnite plays are won by neither of the players.4
A strategy for a player is a function deﬁning a move for each situation in
a play where she has to move. Of particular interest are positional strategies,
which do not depend on the history of the play, but only on the current
position. Hence, a positional strategy for Player σ in G is a (partial)
function f : Vσ →V which indicates a choice (v, f(v)) ∈E for positions
v ∈Vσ. A play v0, v1, . . . is consistent with a positional strategy f for
Player σ if vn+1 = f(vn) for all vn ∈Vσ. A strategy for a player is winning
from position v0 if she wins every play starting from v0 that is consistent
with that strategy. We say that a strategy is winning on a set W if it is
winning from each position in W. The winning region Wσ for Player σ is
the set of positions from which she has a winning strategy.
A game is well-founded if all its plays are ﬁnite. Note that a model-
checking game G(A, ψ(a)) for a ﬁrst-order formula ψ has a ﬁnite game graph
if, and only if, A is ﬁnite, but it is well-founded in all cases. In general,
however, games with ﬁnite game graphs need not be well-founded.
A game is determined if, from each position, one of the players has
a winning strategy, i.e. if W0 ∪W1 = V . Well-founded games are always
4 We shall later introduce games with more interesting winning conditions for inﬁ-
nite plays.

130
3 Finite Model Theory and Descriptive Complexity
determined, and so are large classes of more general games (such as games in
the Borel hierarchy; see [82, 96]).
We denote by Game the strategy problem for games with ﬁnite game
graphs and positional winning conditions, i.e.
Game = {(G, v) : Player 0 has a winning strategy in G from position v}.
It is obvious that the Game problem can be solved in polynomial time.
Denote by W n
σ the set of positions from which Player σ has a strategy to win
the game in at most n moves. Then W 0
σ = {v ∈V1−σ : vE = ∅} is the set
of winning terminal positions for Player σ, and we can compute the sets W n
σ
inductively by using
W n+1
σ
:= {v ∈V0 : vE ∩W n
σ ̸= ∅} ∪{v ∈V1 : vE ⊆W n
σ }
until W n+1
σ
= W n
σ .
To see that Game can actually be solved in linear time, a little more
work is necessary. The following algorithm is a variant of depth-ﬁrst search,
and computes the entire winning sets for both players in time O(|V | + |E|).
Theorem 3.1.2. Winning regions of ﬁnite games can be computed in linear
time.
Proof. We present an algorithm that computes, for each position, which
player, if any, has a winning strategy for the game starting at that position.
During the computation three arrays are used:
•
win[v] contains either 0 or 1, indicating which player wins, or ⊥if we do
not know yet, or if none of the players has a winning strategy from v;
•
P[v] contains the predecessors of v; and
•
n[v] is the number of those successors for which win[v] = ⊥.
A linear-time algorithm for the Game problem
Input: A game G = (V, V0, V1, E)
forall v ∈V do
(∗1: initialization ∗)
win[v] := ⊥
P[v] := ∅
n[v] := 0
enddo
forall (u, v) ∈E do
(∗2: calculate P and n ∗)
P[v] := P[v] ∪{u}
n[u] := n[u] + 1
enddo

3.1 Deﬁnability and Complexity
131
forall v ∈V0
(∗3: calculate win ∗)
if n[v] = 0 then Propagate(v, 1)
forall v ∈V1
if n[v] = 0 then Propagate(v, 0)
return win end
procedure Propagate(v, σ)
if win[v] ̸= ⊥then return
win[v] := σ
(∗4: mark v as winning for Player σ ∗)
forall u ∈P[v] do
(∗5: propagate change to predecessors ∗)
n[u] := n[u] −1
if u ∈Vσ or n[u] = 0 then Propagate(u, σ)
enddo
end
The heart of this algorithm is the procedure Propagate(v, σ) which is
called any time we have found that Player σ has a winning strategy from
position v. Propagate(v, σ) records this fact and investigates whether we are
now able to determine the winning player for any of the predecessors of v.
This is done by applying the following rules:
•
If the predecessor u belongs to Player σ, then this player has a winning
strategy from u by moving to position v.
•
If the predecessor u belongs to the opponent of Player σ, if win[u] is
undeﬁned, and if the winning player has already been determined for all
successors w of u, then win[w] = σ for all of those successors, and hence
Player σ wins from u regardless of the choice of her opponent.
Since parts 4 and 5 of the algorithm are reached only once for each posi-
tion v, the inner part of the loop in part 5 is executed at most 
v |P[v]| = |E|
times. Therefore the running time of the algorithm is O(|V | + |E|).
The correctness of the value assigned to win[v] is proved by a straightfor-
ward induction on the number of moves in which the corresponding player can
ensure that she wins. Note that the positions satisfying n[v] = 0 in part 3 are
exactly those without outgoing edges even if n[v] is modiﬁed by Propagate. □
Game is known to be a PTIME-complete problem (see [57]). This remains
the case for strictly alternating games, where E ⊆V0 × V1 ∪V1 × V0.
Indeed, any game can be transformed into an equivalent strictly alternating
one by introducing for each move (u, v) ∈Vσ × Vσ a new node e ∈V1−σ and
by replacing the move (u, v) by two moves (u, e) and (e, u).
The Game problem (sometimes also called the problem of alternating
reachability) is a general combinatorial problem that reappears in diﬀerent
guises in many areas. To illustrate this by an example, we shall now show
that the satisﬁability problem for propositional Horn formulae is essentially
the same problem as Game.

132
3 Finite Model Theory and Descriptive Complexity
Satisﬁability for Horn Formulae
It is well known that Sat-Horn, the satisﬁability problem for propositional
Horn formulae, is
•
PTIME-complete [57], and
•
solvable in linear time [36, 68].
Using the Game problem, we can obtain very simple proofs for both
results. Indeed, Game and Sat-Horn are equivalent under log–lin reductions,
i.e. reductions that are computable in linear time and logarithmic space. The
reductions are so simple that we can say that Game and Sat-Horn are
really the same problem.
Theorem 3.1.3. Sat-Horn is log–lin equivalent to Game.
Proof. Game
≤log−lin
Sat-Horn.
Given
a
ﬁnite
game
graph
G
=
(V, V0, V1, E), we can construct in time O(|V | + |E|) a proposi-
tional Horn formula ψG consisting of the clauses u ←v for all edges
(u, v) ∈E with u ∈V0, and the clauses u ←v1 ∧· · · ∧vm for all nodes u ∈V1,
where uE = {v1, . . . , vm}. The minimal model of ψG is precisely the winning
set W0 for Player
0. Hence v ∈W0 if the Horn formula ψG ∧(0 ←v) is
unsatisﬁable.
Sat-Horn ≤log−lin Game: Given a Horn formula ψ(X1, . . . , Xn) =

i∈I Ci with propositional variables X1, . . . , Xn and Horn clauses Ci of the
form Hi ←Xi1 ∧· · · Xim (where the head of the clause, Hi, is either a
propositional variable or the constant 0), we deﬁne a game Gψ as follows. The
positions of Player 0 are the initial position 0 and the propositional variables
X1, . . . , Xn, and the positions of Player 1 are the clauses of ψ. Player 0 can
move from a position X to any clause Ci with head X, and Player 1 can
move from a clause Ci to any variable occurring in the body of Ci. Formally,
Gψ = (V, E), V = V0 ∪V1 with V0 = {0} ∪{X1, . . . , Xn}, V1 = {Ci : i ∈I},
and
E = {(X, C) ∈V0 × V1 : X = head(C)} ∪{(C, X) ∈V1 × V0 : X ∈body(C)}.
Player 0 has a winning strategy for Gψ from position X if, and only if, ψ |= X.
In particular, ψ is unsatisﬁable if, and only if, Player 0 wins from position 0. □
3.1.4 Complexity of First-Order Model Checking
Roughly, the size of the model-checking game G(A, ψ) is the number of
diﬀerent instantiations of the subformulae of ψ with elements from A. It is in
many cases not eﬃcient to construct the full model-checking game explicitly
and then solve the strategy problem, since many positions of the game will
not really be needed.

3.1 Deﬁnability and Complexity
133
To measure the size of games, and the resulting time and space bounds
for the complexity of model checking as precisely as possible, we use, besides
the formula length |ψ|, the following parameters. The closure cl(ψ) is the
set of all subformulae of ψ. Obviously, |cl(ψ)| ≤|ψ|, and in some cases |cl(ψ)|
can be much smaller than |ψ|. The quantiﬁer rank qr(ψ) is the maximal
nesting depth of quantiﬁers in ψ, and the width of ψ is the maximal number
of free variables in subformulae, i.e.
width(ψ) = max{|free(ϕ)| : ϕ ∈cl(ψ)}.
Instead of considering the width, one can also rewrite formulae with as
few variables as possible.
Lemma 3.1.4. A ﬁrst-order formula ψ has width k if, and only if, it is
equivalent, via a renaming of bound variables, to a ﬁrst-order formula with
at most k distinct variable symbols.
Bounded-variable fragments of logics have received a lot of attention in
ﬁnite model theory. However, here we state the results in terms of formula
width rather than number of variables to avoid the necessity to economize
on the number of variables. Given the close connection between games
and alternating algorithms, it is not surprising that the good estimates for
the complexity of model-checking games are often in terms of alternating
complexity classes. We now describe an alternating model-checking algorithm
for ﬁrst-order logic that can be viewed as an on-the-ﬂy construction of the
model-checking game while playing it.
Theorem 3.1.5. There is an alternating model-checking algorithm that,
given a ﬁnite structure A and a ﬁrst-order sentence ψ, decides whether
A |= ψ in time O(|ψ| + qr(ψ) log |A|) and space O(log |ψ| + width(ψ) log |A|)
(assuming that atomic statements are evaluated in constant time).
Proof. We present a recursive alternating procedure ModelCheck(A, ρ, ψ)
that, given a ﬁnite structure A, a ﬁrst-order formula ψ that may contain free
variables, and an assignment ρ : free(ψ) →A, decides whether A |= ψ[ρ].
ModelCheck(A, ρ, ψ)
Input: a ﬁrst-order formula ψ in negation normal form
a ﬁnite structure A (with universe A),
an assignment ρ : free(ψ) →A
if ψ is an atom or negated atom then
if A |= ψ[ρ] accept else reject
if ψ = η ∨ϑ then do
guess ϕ ∈{η, ϑ}, and let ρ′ := ρ |free(ϕ)
ModelCheck(A, ρ′, ϕ)
if ψ = η ∧ϑ then do

134
3 Finite Model Theory and Descriptive Complexity
universally choose ϕ ∈{η, ϑ}, and let ρ′ := ρ |free(ϕ)
ModelCheck(A, ρ′, ϕ)
if ψ = ∃xϕ then do
guess an element a of A
ModelCheck(A, ρ[x →a], ϕ)
if ψ = ∀xϕ then do
universally choose an element a of A
ModelCheck(A, ρ[x →a], ϕ)
A straightforward induction shows that the procedure is correct. The
time needed by the procedure is the depth of the syntax tree of ψ plus the
time needed to produce the variable assignments. On each computation path,
at most qr(ψ) elements of A have to be chosen, and each element needs
log |A| bits. Hence the time complexity is O(|ψ| + qr(ψ) log |A|). During the
evaluation, the algorithm needs to maintain a pointer to the current position
in ψ and to store the current assignment, which needs free(ϕ) log |A| bits
for the current subformula ϕ. Hence the space needed by the algorithm is
O(log |ψ| + width(ψ) log |A|).
□
Theorem 3.1.6. The
model-checking
problem
for
ﬁrst-order
logic
is
PSPACE-complete. For any ﬁxed k ≥2, the model-checking problem for
ﬁrst-order formulae of width at most k is PTIME-complete.
Proof. Membership of these complexity classes follows immediately from
Theorem 3.1.5 via the facts that alternating polynomial time coincides
with polynomial space and alternating logarithmic space coincides with
polynomial time.
Completeness follows by straightforward reductions from known complete
problems. QBF, the evaluation problem for quantiﬁed Boolean formulae, is
PSPACE-complete. It reduces to ﬁrst-order model checking on the ﬁxed struc-
ture (A, P) with A = {0, 1} and P = {1}. Given a quantiﬁed Boolean formula
ψ without free propositional variables,we can translate it into a ﬁrst-order
sentence ψ as follows: replace every quantiﬁcation ∃Xi or ∀Xi over a proposi-
tional variable Xi by a corresponding ﬁrst-order quantiﬁcation ∃xi or ∀xi and
replace atomic propositions Xi by atoms Pxi. Obviously, ψ evaluates to true
if, and only if, (A, P) |= ϕ′. This proves that the expression complexity and
the combined complexity of ﬁrst-order model checking is PSPACE-complete.
To see that the model-checking problem for ﬁrst-order formulae of width
2 is PTIME-complete, we reduce to it the Game problem for strictly alter-
nating games, with Player 0 moving ﬁrst. Given a strictly alternating game
graph G = (V, V0, V1, E), we construct formulae ψi(x) of width 2, expressing
the fact that Player 0 has a winning strategy from x ∈V0 in n rounds. Let
ψ1(x) := ∃y(Exy ∧∀z¬Eyz)
ψi+1(x) := ∃y(Exy ∧∀z(Eyz →ψi(z)).

3.1 Deﬁnability and Complexity
135
Obviously, ψn has width 2, and G |= ψn(v) if, and only if, Player 0 can win
from position v in at most n rounds. Now, if Player 0 has a winning strategy,
then she also has one for winning in at most n rounds, where n = |V |,
since otherwise the game will be caught in a loop. Hence any instance G, v
of the Game problem (for strictly alternating games), with v ∈V0, can be
reduced to the instance G, ψn(v) of the model-checking problem for ﬁrst-order
formulae of width 2.
□
Remark.
The argument for PTIME-completeness applies also in fact to
propositional modal logic (ML) [55]. Instead of the formulae ψn(x) constructed
above, we take the modal formulae
ϕ1 := 32false,
ϕn+1 := 32ϕn.
Corollary 3.1.7. The model-checking problem for ML is PTIME-complete.
If we consider a ﬁxed formula ψ, Theorem 3.1.5 tells us that the data
complexity of ﬁrst-order logic is much lower than the expression or combined
complexity.
Corollary 3.1.8. Let ψ be a ﬁrst-order sentence. Then
{A : A ﬁnite, A |= ψ} ∈ALOGTIME.
In particular, the evaluation problem for any ﬁxed ﬁrst-order sentence can be
computed deterministically in logarithmic space.
3.1.5 Encoding Finite Structures by Words
Complexity theory, at least in its current form, is based on classical computa-
tional models, most notably Turing machines, that take as inputs words over
a ﬁxed ﬁnite alphabet. If we want to measure the complexity of problems
on ﬁnite structures in terms of these notions, we have to represent structures
by words so that they can be used as inputs for, say, Turing machines.
This may seem a trivial issue, and for purely algorithmic questions (say
for determining the cost of a model-checking algorithm) it indeed often is.
However, the programme of ﬁnite model theory is to link complexity with
logical deﬁnability in a deeper way, and for this purpose the represention of
structures by words needs careful consideration. It is also at the source of
some major unresolved problems that we shall discuss later.
At least implicitly, an encoding of a ﬁnite structure by a word requires
that we select an ordered representation of the structure. To see this, consider
the common encoding of a graph G = (V, E) by its adjacency matrix. Once
we have ﬁxed an enumeration of V , say V = {v0, . . . , vn−1}, we can represent
the graph by the word w0 · · · wn2−1, where win+j = 1 if (vi, vj) ∈E and
win+j = 0 otherwise, i.e. row after row of the adjacency matrix. However, this

136
3 Finite Model Theory and Descriptive Complexity
encoding is not canonic. There are n! possibilities of enumerating V , so there
may be up to n! diﬀerent encodings of the same graph by binary strings.
But if the graphs come along with a linear order, we do have a canonic way
of enumerating the elements and therefore a canonic encoding. Let us now
discuss encodings of arbitrary ﬁnite structures (of ﬁnite vocabulary) by words.
Deﬁnition 3.1.9. For any vocabulary τ, we write Fin(τ) for the class of
ﬁnite τ-structures and Ord(τ) for the class of all structures (A, <), where
A ∈Fin(τ) and < is a linear order on A (the universe of A).
For any structure (A, <) ∈Ord(τ) of cardinality n and for any k, we can
identify Ak with the set {0, . . . , nk −1}, by associating each k-tuple with its
rank in the lexicographical ordering induced by < on Ak. Ordered structures
can be encoded as binary strings in many natural ways. The particular choice
of an encoding is not important. We only need the following conditions to be
satisﬁed.
Deﬁnition 3.1.10. An encoding code : Ord(τ) →Σ∗(over any ﬁnite
alphabet Σ) is good if it identiﬁes isomorphic structures, if its values are
polynomially bounded, if it is ﬁrst-order deﬁnable, and if it allows to compute
eﬃciently the values of atomic statements. Formally, this means that the
following conditions are satisﬁed:
(i) code(A, <) = code(B, <) if and only if (A, <) ∼= (B, <).
(ii) |code(A, <)| ≤p(|A|) for some polynomial p.
(iii) For all k ∈N and all symbols σ ∈Σ, there exists a ﬁrst-order formula
βσ(x1, . . . , xk) of vocabulary τ ∪{<} such that, for all structures
(A, <) ∈Ord(τ) and all a ∈Ak, the following equivalence holds:
(A, <) |= βσ(a) iﬀthe a-th symbol of code(A, <) is σ.
(iv) Given code(A, <), a relation symbol R of τ, and (a representation of) a
tuple a, one can eﬃciently decide whether A |= Ra.
The precise meaning of ‘eﬃciently’ in clause (iv) depends on the context
(e.g. the problem that is studied, the machine model considered, and the level
of abstraction at which one is studying a given problem). For the analysis
of algorithms, one often assumes that atomic statements are evaluated
in constant (or even unit) time on a Random Access Machine (RAM). A
minimal requirement is that atoms can be evaluated in linear time and
logarithmic space.
A convenient encoding is given as follows. Let < be a linear order on
A and let A = (A, R1, . . . , Rt) be a τ-structure of cardinality n. Let ℓ
be the maximal arity of R1, . . . , Rt. With each relation R of arity j, we
associate a string χ(R) = w0 · · · wnj−10nℓ−nj ∈{0, 1}nℓ, where wi = 1
if the ith tuple of Aj belongs to R, and wi = 0 otherwise. Now, we set
code(A, <) = 1n0nℓ−nχ(R1) · · · χ(Rt).

3.1 Deﬁnability and Complexity
137
Exercise 3.1.11 Prove that this encoding is good. In fact, this encoding lends
itself to a very simple logical description in the following sense: if, besides
(or instead of) the linear ordering <, the corresponding successor relation S
and the constants 0, e for the ﬁrst and last elements with respect to < are
available, then the encoding is deﬁnable by quantiﬁer-free formulae βσ(x).
We can ﬁx any good encoding function and understand ordered structures
to be represented by their encodings. With an unordered structure A, we asso-
ciate the set of all encodings code(A, <), where < is a linear order on A. So,
when we say that an algorithm M decides a class K of τ-structures, we actually
mean that M decides the set of encodings of structures in K, i.e. the language
code(K) := {code(A, <) : A ∈K and < is a linear order on A}.
It thus makes sense to ask whether such a K belongs to a complexity class,
such as P or NP. In particular, we can ask how complicated it is to decide
the class of models of a logical sentence.
Word Structures
We have seen how classes of structures are encoded by languages. On the other
hand, any language L ⊆Γ ∗can also be considered as a class of structures over
the vocabulary {<} ∪{Pa : a ∈Γ}. Indeed, a word w = w0 . . . wm−1 ∈Γ ∗is
described by the structure B(w) with universe {0, . . . , m −1}, with the usual
interpretation of < and where Pa = {i : wi = a}.
Isomorphism Invariance
We have seen that encoding an unordered structure involves selecting an
ordering on the universe. In general, diﬀerent orderings produce diﬀerent
encodings. However, we want to consider properties of structures, not of their
encodings, An algorithm that decides whether a structure has a certain prop-
erty gets encodings code(A, <) as inputs and should produce the same answer
(yes or no) for all encodings of the same structure. That is, the outcome of
the algorithm should not depend on the particular ordered representation of
the structure, but only on its isomorphism type. In other words the algorithm
should be isomorphism-invariant. For most of the algorithms considered
here isomorphism invariance is obvious, but in general it is an undecidable
property.
Exercise 3.1.12 A ﬁrst-order sentence ψ of vocabulary τ ∪{<} is order-
invariant on a class K of τ-structures if its truth on any structure in K does not
depend on the choice of the linear ordering <. That is, for any A ∈K and any
pair <, <′ of linear orderings on A we have that (A, <) |= ψ ⇐⇒(A, <′) |= ψ.

138
3 Finite Model Theory and Descriptive Complexity
Prove that it is undecidable whether a given ﬁrst-order formula is order-
invariant on ﬁnite structures. Hint: use Trakhtenbrot’s Theorem. A ﬁrst-order
sentence ψ, in which < and Q do not occur, has a ﬁnite model with at least
two elements if, and only if, ψ →∀x∃y(x < y ∨Qx) is not order-invariant.
3.2 Capturing Complexity Classes
We have already mentioned that the research programme of descriptive
complexity theory links complexity with logic in a deeper way than a
complexity analysis of model-checking algorithms can do. We are looking
for results saying that, on a certain domain D of structures, a logic L (such
as ﬁrst-order logic, least ﬁxed-point logic, or a fragment of second-order
logic) captures a complexity class Comp. This means that (1) for every ﬁxed
sentence ψ ∈L, the data complexity of evaluating ψ on structures from D is
a problem in the complexity class Comp, and (2) every property of structures
in D that can be decided with complexity Comp is deﬁnable in the logic L.
Two important examples of such results are Fagin’s Theorem, which
says that existential second-order logic captures NP on the class of all
ﬁnite structures, and the Immerman–Vardi Theorem, which says that least
ﬁxed-point logic captures PTIME on the class of all ordered ﬁnite structures.
On ordered ﬁnite structures, logical characterizations of this kind are known
for all major complexity classes. On the other hand, it is not known, and
it is one of the major open problems in the area, whether PTIME can be
captured by any logic if no ordering is present.
In Sect. 3.2.1, we prove Fagin’s Theorem and relate it it to the spectrum
problem, which is a classical problem in mathematical logic. In Sect. 3.2.2, we
make precise the notion of a logic capturing a complexity class on a domain
of ﬁnite structures. We then show in Sect. 3.2.3 that on ordered structures,
second-order Horn logic captures polynomial time. In Sects. 3.2.4 and 3.2.5,
we discuss logics that capture logarithmic space complexity classes.
3.2.1 Capturing NP: Fagin’s Theorem
The spectrum of a ﬁrst-order sentence ψ is the set of cardinalities of its
ﬁnite models, i.e.
spectrum(ψ) := {k ∈N : ψ has a model with k elements}.
As early as 1952, Scholz [93] posed the problem of characterizing the
class of spectra, i.e. the subsets S ⊆N for which there exists a ﬁrst-order
sentence ψ such that spectrum(ψ) = S. A more speciﬁc problem is the
complementation problem for spectra, posed by Asser [7], who asked
whether the complement of each spectrum is also a spectrum.

3.2 Capturing Complexity Classes
139
Note that the spectrum of a ﬁrst-order sentence ψ of relational vocabulary
τ = {R1, . . . , Rm} can be viewed as the set of ﬁnite models of the existential
second-order sentence ∃R1 · · · ∃Rmψ. Since all relation symbols are quantiﬁed,
this is a sentence over the empty vocabulary, i.e. its models are just sets.
Thus there is a one-to-one correspondence between the spectra of ﬁrst-order
sentences and the classes of ﬁnite models of existential second-order sentences
over the empty vocabulary. If we allow diﬀerent vocabularies for existential
second-order sentences, this naturally leads to the notion of a generalized
spectrum [43].
Deﬁnition 3.2.1. Existential second-order logic, sometimes denoted by Σ1
1,
is the set of formulae of the form ∃R1 · · · ∃Rmϕ, where m ∈N, R1, . . . , Rm
are relation symbols of any ﬁnite arity, and ϕ is a ﬁrst-order formula.
A generalized spectrum is the class of ﬁnite models of a sentence in
existential second-order logic.
Example 3.2.2. The class of bipartite graphs is a generalized spectrum. It is
deﬁned by the sentence
∃R∀x∀y(Exy →(Rx ↔¬Ry)).
Exercise 3.2.3 Prove that the class of Hamiltonian graphs, the class of
k-colourable graphs (for any ﬁxed k), and the class of graphs that admit
a perfect matching are generalized spectra. (A perfect matching in an
undirected graph G = (V, E) is a set M ⊆E of edges such that every node
belongs to precisely one edge of M.)
Theorem 3.2.4 (Fagin). Let K be an isomorphism-closed class of ﬁnite
structures of some ﬁxed non-empty ﬁnite vocabulary. Then K is in NP if and
only if K is deﬁnable by an existential second-order sentence, i.e. if and only
if K is a generalized spectrum.
Proof. First,
we
show
how
to
decide
a
generalized
spectrum.
Let
ψ
:=
∃R1 · · · ∃Rmϕ be an existential second-order sentence. We shall
describe a non-deterministic polynomial-time algorithm M which, given an
encoding code(A, <) of a structure A, decides whether A |= ψ. First, M
non-deterministically guesses relations R1, . . . , Rm on A. A relation Ri is
determined by a binary string of length nri, where ri is the arity of Ri and
n = |A|. Then M decides whether (A, R1, . . . , Rm) |= ϕ. Since ϕ is ﬁrst-order,
this can be done in logarithmic space and therefore in polynomial time.
Hence the computation of M consists of guessing a polynomial number
of bits, followed by a deterministic polynomial-time computation. Obviously,
M decides the class of ﬁnite models of ψ.
Conversely, let K be an isomorphism-closed class of τ-structures and let
M be a non-deterministic one-tape Turing machine which, given an input
code(A, <), decides in polynomial time whether A belongs to K. We shall con-
struct an existential second-order sentence ϕ whose ﬁnite models are precisely

140
3 Finite Model Theory and Descriptive Complexity
the structures in K. The construction given here is not quite the standard
one. It is optimized so that it can be easily adapted to other situations, in
particular for giving a capturing result for PTIME (see Section 3.2.3).
Let M = (Q, Σ, q0, F +, F −, δ), where Q is the set of states, Σ is the
alphabet of M, q0 is the initial state, F + and F −are the set of accepting and
rejecting states, and δ : (Q × Σ) →P(Q × Σ × {−1, 0, 1}) is the transition
function. Without loss of generality, we can assume that all computations of
M for an input code(A, <) reach an accepting or rejecting state after at most
nk −1 steps (where n is the cardinality of A).
We represent a computation of M for an input code(A, <) by a tuple
X of relations on A, and we shall construct a ﬁrst-order sentence ψM of
vocabulary τ ∪{<} ∪{X} such that
(A, < X) |= ψM ⇐⇒the relations X represent an accepting
computation of M on code(A, <).
To represent the nk time and space parameters of the computation we
identify numbers up to nk −1 with tuples in Ak. Given a linear order, the
associated successor relation and the least and greatest element are of course
deﬁnable. Note, further, that if a successor relation S and constants 0, e for
the ﬁrst and last elements are available, then the induced successor relation
y = x + 1 on k-tuples is deﬁnable by a quantiﬁer-free formula

i<k
	
j<i
(xj = e ∧yj = 0) ∧Sxiyi ∧
	
j>i
xj = yj

.
Hence, for any ﬁxed integer m, the relation y = x + m is also expressible.
The description X of a computation of M on code(A, <) consists of the
following relations.
(1) For each state q ∈Q, the predicate
Xq := {t ∈Ak : at time t, M is in state q}.
(2) For each symbol σ ∈Σ, the predicate
Yσ := {(t, a) ∈Ak × Ak : at time t, cell a contains the symbol σ}.
(3) The head predicate
Z := {(t, a) ∈Ak × Ak : at time t, the head of M is on position a}.
The sentence ψM is the universal closure of the conjunction
START ∧COMPUTE ∧END.
The subformula START enforces the condition that the conﬁguration of
M at time t = 0 is C0(A, <), the input conﬁguration on code(A, <). Recall

3.2 Capturing Complexity Classes
141
that a good encoding is represented by ﬁrst-order formulae βσ(x) (condition
(iii) of the deﬁnition of good encodings). We set
START := Xq0(0) ∧Z(0, 0) ∧
	
σ∈Σ

βσ(x) →Yσ(0, x)

.
The subformula COMPUTE describes the transitions from one conﬁgu-
ration to the next. It is the conjunction of the formulae
NOCHANGE :=
	
σ∈Σ

Yσ(t, x) ∧(y ̸= x) ∧(t
′ = t + 1) ∧Z(t, y) →Yσ(t
′, x)

and
CHANGE :=
	
q∈Q
σ∈Σ

PRE[q, σ] →

(q′,σ′,m)∈δ(q,σ)
POST[q′, σ′, m]

where
PRE[q, σ] := Xq(t) ∧Z(t, x) ∧Yσ(t, x) ∧t
′ = t + 1
POST[q′, σ′, m] := Xq′(t
′) ∧Yσ′(t
′, x ∧∃y(x + m = y ∧Z(t
′, y)).
NOCHANGE expresses the fact that the contents of tape cells that are
not currently being scanned do not change from one conﬁguration to the
next, whereas CHANGE enforces the changes in the relations Xq, Yσ, and Z
imposed by the transition function.
Finally, we have the formula
END :=
	
q∈F −
¬Xq(t),
which enforces acceptance by forbidding rejection.
Claim 1. If M accepts code(A, <), then (A, <) |= (∃X)ψM.
This follows immediately from the construction of ψM, since for any
accepting computation of M on code(A, <) the intended meaning of X
satisﬁes ψM.
Claim 2. If (A, < X) |= ψM, then M accepts code(A, <).
Suppose that (A, < X) |= ψM. For any M-conﬁguration C with state
q, head position p, and tape content w0 · · · wnk−1 ∈Σ∗, and for any time
j < nk, let CONF[C, j] be the conjunction of the atomic statements that
hold for C at time j, i.e.
CONF[C, j] := Xq(j) ∧Z(j, p) ∧
nk−1
	
i=0
Ywi(j, i)
where j, p and i are the tuples in Ak representing the numbers j, p, and i.

142
3 Finite Model Theory and Descriptive Complexity
(a) Let C0 be the input conﬁguration of M for input code(A, <). Since
(A, <, X) |= START, it follows that
(A, <, X) |= CONF[C0, 0].
(b) Owing to the subformula COMPUTE of ψM, we have, for all non-ﬁnal
conﬁgurations C and all j < nk −1, that
ψM ∧CONF[C, j] |=

C′∈Next(C)
CONF[C′, j + 1],
where Next(C) = {C′ : C ⊢M C′} is the set of successor conﬁgurations
of C. It follows that there exists a computation
C0(A, <) = C0 ⊢M C1 ⊢M · · · ⊢M Cnk−1 = Cend
of M on code(A, <) such that, for all j < nk,
(A, <, X) |= CONF[Cj, j].
(c) Since (A, <, X) |= END, the conﬁguration Cend is not rejecting. Thus,
M accepts code(A, <).
This proves Claim 2. Clearly, one can axiomatize linear orders in ﬁrst-order
logic. Hence
A ∈K
iﬀ
A |= (∃<)(∃X)(“< is a linear order” ∧ψM).
This proves that K is a generalized spectrum.
□
Exercise 3.2.5 Prove that every set in NP can be deﬁned by a Σ1
1-sentence
whose ﬁrst-order part has an ∀∗∃∗-preﬁx. Furthermore, prove that this
cannot be reduced to ∀∗. Finally, prove that it can be reduced to ∀∗if
(a) existential second-order quantiﬁcation over function symbols is allowed,
or
(b) if we consider only ordered structures with an explicitly given successor
relation and constants 0, e for the ﬁrst and last elements.
There are several interesting consequences of Fagin’s Theorem. First of
all, the NP-completeness of SAT (the satisﬁability problem for propositional
logic) is an easy corollary of Fagin’s Theorem.
Theorem 3.2.6 (Cook and Levin). SAT is NP-complete.
Proof. It is obvious that SAT is an NP-problem. It remains to show that
any problem K in NP can be reduced to SAT. Since, as explained above,
words can be viewed as special kinds of ﬁnite structures, we can assume that
K ⊆Fin(τ) for some ﬁnite vocabulary τ. By Fagin’s Theorem, there exists a
ﬁrst-order sentence ψ such that
K = {A ∈Fin(τ) : A |= ∃R1 · · · ∃Rmψ}.

3.2 Capturing Complexity Classes
143
We now present a logspace reduction that associates with every input
structure A ∈Fin(τ) a propositional formula ψA. Given A, replace in ψ
•
all subformulae ∃xiϕ by 
ai∈A ϕ[xi/ai],
•
all subformulae ∀xiϕ by 
ai∈A ϕ[xi/ai], and
•
all τ-atoms Pa by their truth values in A.
Since the τ-atoms can be evaluated eﬃciently, this translation is com-
putable eﬃciently. Viewing the atoms Ria as propositional variables, we have
obtained a propositional formula ψA such that
A ∈K
⇐⇒
A |= ∃R1 · · · ∃Rmψ
⇐⇒
ψA ∈SAT.
□
Fagin’s Theorem is readily extended to the higher levels of the polynomial-
time hierarchy , and thus to a correspondance between second-order logic
and the polynomial-time hierarchy.
Corollary 3.2.7. Let K be an isomorphism-closed class of ﬁnite structures of
some ﬁxed non-empty vocabulary τ. Then code(K) is in the polynomial-time
hierarchy PH if and only if there exists a second-order sentence ψ such that
K is the class of ﬁnite models of ψ.
In the statement of Fagin’s Theorem, we required the vocabulary to be
non-empty. The case of the empty vocabulary, i.e. spectra, is diﬀerent, because
the natural way of specifying a ﬁnite set is to write down its size n in binary,
and so the length of the encoding is logarithmic in n, whereas encodings of
structures of non-empty vocabularies have polynomial length. The formula
constructed in the proof of Fagin’s Theorem talks about computations that
are polynomial in n, and hence, in the case of spectra, exponential in the
length of the input. As a consequence, Fagin’s characterization of generalized
spectra in terms of NP implies a characterization of spectra in terms of
NEXPTIME. This has also been established in a diﬀerent way in [71].
Corollary 3.2.8 (Jones and Selman). A set S ⊆N is a spectrum if and
only if S ∈NEXPTIME.
Hence the complementation problem for spectra is really a complexity-
theoretic problem: spectra are closed under complementation if, and only if,
NEXPTIME = Co-NEXPTIME.
Exercise 3.2.9 Prove that a set S ⊆N is in EXPTIME if and only if it is a
categorical spectrum, i.e. the spectrum of a ﬁrst-order sentence that has, up
to isomorphism, at most one model in any ﬁnite cardinality.

144
3 Finite Model Theory and Descriptive Complexity
3.2.2 Logics That Capture Complexity Classes
Fagin’s Theorem gives a precise correspondence between a logic and a com-
plexity class: a property of ﬁnite structures is decidable in non-deterministic
polynomial time exactly when it is deﬁnable in existential second-order
logic. The same is true for the correspondence between the polynomial-time
hierarchy and SO, as given by Corollary 3.2.7.
Note that the results on the model-checking complexity of ﬁrst-order logic
do not give such precise correspondences. We know by Theorem 3.1.5 and
Corollary 3.1.8 that whenever a property of ﬁnite structures is ﬁrst-order
deﬁnable, it is decidable in LOGSPACE and in fact even in ALOGTIME.
But we do not have a result giving the converse, and in fact the converse is
false. There are computationally very simple properties of ﬁnite structures
that are not ﬁrst-order deﬁnable; one of them is the property of having an
even number of elements.
Hence the natural question arises of whether complexity classes other than
NP and the polynomial-time hierarchy can also be precisely captured by logics.
For most of the popular complexity classes, notably PTIME, we do not know
whether this is possible on the domain of all ﬁnite structures. But we have a lot
of interesting capturing results if we do not consider arbitrary ﬁnite structures,
but certain speciﬁc domains. In particular we have close correspondences
between logic and complexity for the domain of ordered ﬁnite structures.
By a model class we always mean a class K of structures of a ﬁxed
vocabulary τ that is closed under isomorphism, i.e. if A ∈K and A ∼= B, then
also B ∈K. We speak of a domain of structures instead, if the vocabulary
is not ﬁxed. For a domain D and vocabulary τ, we write D(τ) for the class
of τ-structures in D.
Intuitively, a logic L captures a complexity class Comp on D if the L-
deﬁnable properties of structures in D are precisely those that are decidable
in Comp. Here is a more detailed deﬁnition.
Deﬁnition 3.2.10. Let L be a logic, Comp a complexity class, and D a
domain of ﬁnite structures. We say that L captures Comp on D if
(1) For every vocabulary τ and every sentence ψ ∈L(τ), the model-checking
problem for ψ on D(τ) is in the complexity class Comp.
(2) For every model class K ⊆D(τ) whose membership problem is in Comp,
there exists a sentence ψ ∈L(τ) such that
K = {A ∈D(τ) : A |= ψ}.
By Fagin’s Theorem, the logic Σ1
1 captures NP on the domain of all
ﬁnite structures, and by Corollary 3.2.7, second-order logic captures the
polynomial-time hierarchy.
We sometimes simply write L ⊆Comp to say that condition (1) of Deﬁni-
tion 3.2.10 is satisﬁed for L and Comp on the domain of all ﬁnite structures.

3.2 Capturing Complexity Classes
145
A classical result, from the ‘prehistory’ of ﬁnite model theory, says that
a language is regular (i.e. recognizable by a ﬁnite automaton) if, and only if,
it is deﬁnable in monadic second-order logic (MSO). As words can be viewed
as a special domain of structures, this is a capturing result in the sense of
Deﬁnition 3.2.10.
Theorem 3.2.11 (B¨uchi, Elgot, and Trakhtenbrot). On the domain of
word structures, monadic second-order logic captures the regular languages.
There are numerous extensions and ramiﬁcations of this theorem, most
of them established in the context of automata theory. We refer to [95, 97]
for a proof and further results. However, the emphasis of most of the work in
ﬁnite model theory is on structures more complicated structures than words,
and concerns complexity levels higher than the regular languages.
3.2.3 Capturing Polynomial Time on Ordered Structures
In this section, we present a logical characterization of polynomial time
on ordered structures, in terms of second-order Horn logic. Other such
characterizations will follow in subsequent sections.
Deﬁnition 3.2.12. Second-order Horn logic, denoted by SO-HORN, is
the set of second-order sentences of the form
Q1R1 · · · QmRm∀y1 · · · ∀ys
t	
i=1
Ci
where Qi ∈{∃, ∀}, the Ri are relation symbols, and the Ci are Horn clauses
with respect to R1, . . . , Rm. More precisely, each Ci is an implication of the
form
H ←β1 ∧· · · ∧βm
where each βj is either a positive atom Rkz, or a ﬁrst-order formula that
does not contain R1, . . . , Rm. The conjunction β1 ∧· · · ∧βm is called the
body of the clause. H, the head of the clause, is either an atom Rjz or the
Boolean constant 0 (for false).
Thus the ﬁrst-order parts of the sentences in SO-HORN are universal
Horn sentences with respect to the quantiﬁed predicates R1, . . . , Rm, but
may use arbitrary ﬁrst-order information about the ‘input predicates’ from
the underlying vocabulary. Σ1
1-HORN denotes the existential fragment
of SO-HORN, i.e. the set of SO-HORN sentences where all second-order
quantiﬁers are existential.
Example 3.2.13. The problem GEN is a well-known P-complete prob-
lem [57, 70]. It may be presented as the set of structures (A, S, f, a) in the
vocabulary of one unary predicate S, one binary function f, and a constant a,

146
3 Finite Model Theory and Descriptive Complexity
such that a is contained in the closure of S under f. Clearly, the complement of
GEN is also P-complete. It is deﬁned by the following sentence of Σ1
1-HORN:
∃R∀y∀z

(Ry ←Sy) ∧(Rfyz ←Ry ∧Rz) ∧(0 ←Ra)

.
Example 3.2.14. The circuit value problem (CVP) is also P-complete [57],
even when restricted to circuits with a fan-in of 2 over NAND gates. Such
a circuit can be considered as a structure (V, E, I+, I−, out), where (V, E)
is a directed acyclic graph, I+ and I−are monadic predicates, and a is a
constant. Here Exy means that node x is one of the two input nodes for y;
I+ and I−contain the input nodes with values 1 and 0, respectively; and out
stands for the output node.
We shall take for granted that E is a connected, acyclic graph with a
fan-in of 2, sources I+ ∪I−, and sink out. The formula ∃T ∃F∀x∀y∀zϕ, where
ϕ is the conjunction of the clauses
T x ←I+x
Fx ←I−x
T y ←Fx ∧Exy
Fz ←T x ∧Exz ∧T y ∧Eyz ∧y ̸= z
0 ←T x ∧Fx
T x ←x = out
then states that the circuit (V, E, I+, I−, out) evaluates to 1.
Exercise 3.2.15 To justify the deﬁnition of SO-HORN, show that the
admission of quantiﬁers over functions, or of ﬁrst-order preﬁxes of a more
general form, would make the restriction to Horn clauses pointless. Any such
extension of SO-HORN has the full power of second-order logic.
Theorem 3.2.16. Every sentence ψ ∈SO-HORN is equivalent to some
sentence ψ′ ∈Σ1
1-HORN.
Proof. It suﬃces to prove the theorem for formulae of the form
ψ := ∀P∃R1 · · · ∃Rm∀zϕ,
where ϕ is a conjunction of Horn clauses. An arbitrary formula in SO-HORN
may then be brought to existential form by successively removing the inner-
most universal second-order quantiﬁer. We ﬁrst prove the following claim.
Claim.
A formula ∃R∀zϕ(P, R) ∈Σ1
1-HORN is true for all predicates P
(on a given structure A) if it holds for those predicates P that are false at at
most one point.

3.2 Capturing Complexity Classes
147
Let k be the arity of P. For every k-tuple a, let P a = Ak −{a}, i.e. the
predicate that is false at a and true at all other points. By assumption, there
exist predicates R
a such that
(A, P a, R
a) |= ∀zϕ.
Now, take any predicate P ̸= Ak, and let Ri := 
a̸∈P Ra
i . We claim that
(A, P, R) |= ∀zϕ.
Suppose that this is false; there then exists a relation P ̸= Ak, a clause C
of ϕ, and an assignment ρ : {z1 . . . , zs} →A such that (A, P, R) |= ¬C[ρ]. We
now show that there then exists a tuple a such that also (A, P a, R
a) |= ¬C[ρ].
If the head of C[ρ] is Pu, then take a = u ̸∈P. If the head of C[ρ] is Riu,
then choose some a ̸∈P such that u ̸∈Ra
i ; such an a must exist because u ̸∈
Ri. Finally, if the head is 0, take an arbitrary a ̸∈P. The head of C[ρ] is clearly
false in (A, P a, R
a). The atom Pa does not occur in the body of C[ρ], because
a ̸∈P and all atoms in the body of C[ρ] are true in (A, P, R); all other atoms of
the form Pv that might occur in the body of the clause remain true for P a also.
Moreover, every atom Riv in the body remains true if Ri is replaced by Ra
i
(because Ri ⊆Ra
i ). This implies that the clause (A, P a, R
a) |= ¬C[ρ], and thus
(A, P a, R
a) |= ¬∀zϕ,
which contradicts our assumption.
Thus the claim has been established. This implies that the original
formula ψ is equivalent to the conjunction
∃R∀zϕ0 ∧∀y(∃R)∀zϕ1,
where ϕ1 and ϕ0 are obtained from ϕ by replacing every atom Pu by u ̸= y
(which is true iﬀu ∈P y), or by (u = u) (which is always true), respec-
tively. It is easy to transform this conjunction into an equivalent formula
in Σ1
1-HORN.
□
Theorem 3.2.17. If ψ ∈SO-HORN, then the set of ﬁnite models of ψ is in
PTIME.
Proof. We can restrict our attention to sentences ψ = ∃R1 · · · ∃Rm∀z 
i Ci in
Σ1
1-HORN. Given any ﬁnite structure A of appropriate vocabulary, we reduce
the problem of whether A |= ψ to the satisﬁability problem for a propositional
Horn formula by the same technique as in the proof of Theorem 3.2.6.
Replace the universal quantiﬁers ∀zi by conjunctions over the elements
ai ∈A and omit the quantiﬁer preﬁx. Then substitute in the body of each
clause the ﬁrst-order formulae that do not involve R1, . . . , Rm by their truth
values in A. If there is any clause that is already made false by this partial
interpretation (i.e. the head is false and all atoms in the body are true),

148
3 Finite Model Theory and Descriptive Complexity
then reject ψ. Otherwise, omit all clauses that are already made true (i.e.
the head is true or a conjunct of the body is false) and delete the conjuncts
already interpreted from the remaining clauses. Consider the atoms Riu as
propositional variables. The resulting formula is a propositional Horn formula
whose length is polynomially bounded in the cardinality of A and which is
satisﬁable if and only if A |= ψ. The satisﬁability problem for propositional
Horn formulae can be solved in linear time.
□
Theorem 3.2.18 (Gr¨adel).
On
ordered
structures,
SO-HORN
and
Σ1
1-HORN capture PTIME.
Proof. This follows from an analysis of our proof of Fagin’s Theorem. If the
Turing machine M happens to be deterministic, then the sentence ∃XψM
constructed in that proof can easily be transformed to an equivalent sentence
in Σ1
1-HORN.
To see this, recall that ψM
is the universal closure of START ∧
NOCHANGE ∧CHANGE ∧END. The formulae START, NOCHANGE,
and END are already in Horn form. The formula CHANGE has the form
	
q∈Q
σ∈Σ

PRE[q, σ] →

(q′,σ′,m)∈δ(q,σ)
POST[q′, σ′, m]

,
where
PRE[q, σ] := Xq(t) ∧Z(t, x) ∧Yσ(t, x) ∧t
′ = t + 1
POST[q′, σ′, m] := Xq′(t
′) ∧Yσ′(t
′, x) ∧∃y(x + m = y ∧Z(t
′, y)).
For a deterministic M, we have for each pair (q, σ) a unique value
δ(q, σ) = (q′, σ′, m). In this case, the implication PRE[q, σ] →POST[q′, σ′, m]
can be replaced by the conjunction of the Horn clauses
PRE[q, σ] →Xq′(t
′)
PRE[q, σ] →Yσ′(t
′, x)
PRE[q, σ] ∧y = x + m →Z(t
′, y).
□
Exercise 3.2.19 Prove that, contrary to the case of Fagin’s Theorem, the
assumption that a linear order is explicitly available cannot be eliminated,
since linear orderings are not axiomatizable by Horn formulae.
Exercise 3.2.20 In [47], where the results of this section were proved, a
weaker variant of SO-HORN was used, in which the body may not contain
arbitrary ﬁrst-order formulae of the input vocabulary, but only atoms and

3.2 Capturing Complexity Classes
149
negated input atoms. Prove that the two variants of SO-HORN are equivalent
on ordered structures with a successor relation and with constants for the
ﬁrst and last elements, but not on ordered structures without a successor
relation. Hint: sentences in the weak variant of SO-HORN are preserved
under substructures, i.e. if A |= ψ and B ⊆A, then also B |= ψ.
3.2.4 Capturing Logarithmic Space Complexity
In this section and the next, we describe two approaches to deﬁning logics
that capture logarithmic space complexity classes on ordered structures. The
ﬁrst approach is based on restrictions of second-order logic, similarly to the
deﬁnition of SO-HORN, whereas the second technique adds transitive closure
operators to ﬁrst-order logic.
Deﬁnition 3.2.21. Second-order Krom logic, denoted by SO-KROM, is
the set of second-order formulae
Q1R1 · · · QmRm∀y1 · · · ∀ys
t	
i=1
Ci
where every clause Ci is a disjunction of at most two literals of the form
(¬)Riy and of a ﬁrst-order formula that does not contain R1, . . . , Rm. Such
formulae are Krom (i.e. in 2-CNF) with respect to the quantiﬁed predicates.
Σ1
1-KROM is the existential fragment of SO-KROM. The intersection of
Σ1
1-HORN and Σ1
1-KROM is denoted by Σ1
1-KROM-HORN.
Example 3.2.22. The reachability problem (‘Is there a path in the graph
(V, E) from a to b?’) is complete for NLOGSPACE via ﬁrst-order translations.
Its complement is expressible by a formula from Σ1
1-KROM-HORN,
∃T ∀x∀y∀z

T xx ∧(T xz ←T xy ∧Eyz) ∧(0 ←T ab)

.
As in the case of SO-HORN, it is also known that every sentence of
SO-KROM is equivalent to a sentence of Σ1
1-KROM (see [47]).
Proposition 3.2.23. For every sentence ψ ∈SO-KROM, the set of ﬁnite
models of ψ is in NLOGSPACE.
The proof is analogous to the proof of Theorem 3.2.17. It uses the fact
that 2-SAT, the satisﬁability problem for propositional Krom formulae, is in
NLOGSPACE. On ordered structures, SO-KROM captures NLOGSPACE.
We shall indicate the general idea of the proof here. Suppose that M is an
O(log n)-space-bounded non-deterministic Turing machine with an input tape
carrying a representation code(A, <) of an input structure, and one or more
separate work tapes. A reduced conﬁguration of M reﬂects the control state
of M, the content of the work tapes, and the positions of the heads on the

150
3 Finite Model Theory and Descriptive Complexity
input tape and the work tapes. Thus a conﬁguration is speciﬁed by a reduced
conﬁguration together with the input. Given that reduced conﬁgurations of M
for the input code(A, <) have a logarithmic length with respect to |A|, we can
represent them by tuples c = c1, . . . , cr ∈Ar for ﬁxed r. The initial reduced
conﬁguration on any input code(A, <) is represented by the tuple 0. Assume
that M has a single accepting state, say state 1, and let the ﬁrst component of
the reduced conﬁguration describe the state. The condition that y represents
an accepting conﬁguration is then expressed by ACCEPT(y) := (y1 = 1).
Further, it is not diﬃcult (although it is somewhat lengthy) to write down
a quantiﬁer-free formula NEXT(x, y) such that, for every successor structure
(A, S, 0, e) and every tuple c representing a reduced conﬁguration,
(A, S, 0, e) |= NEXT(c, d)
if, and only if, d represents a reduced successor conﬁguration of c for the input
(A, <). Taking the disjunctive normal form NEXT(x, y) = 
i NEXTi(x, y),
we can express the staement that M does not accept the input code(A, <)
by the sentence
ψM :=∃R∀x∀y

R0 ∧
	
i
(Ry ←Rx ∧NEXTi(x, y))
∧(2 ←Ry ∧ACCEPT(y)

.
This proves that, on ordered structures, the complement of every problem
in NLOGSPACE is deﬁnable in SO-KROM. Since NLOGSPACE is closed
under complements, and since the formula ψM is in fact in Σ1
1-KROM-HORN,
we have proved the following result.
Theorem 3.2.24 (Gr¨adel).
On ordered structures, the logics SO-KROM,
Σ1
1-KROM, and Σ1
1-KROM-HORN capture NLOGSPACE.
Remark. The characterizations of P and NLOGSPACE by second-order
Horn and Krom logics can also be reformulated in terms of generalized
spectra. The notion of a generalized spectrum can be appropriately modiﬁed
to the notions of a generalized Horn spectrum and a generalized Krom
spectrum. Let a model class be any isomorphism-closed class of structures of
some ﬁxed ﬁnite signature. Fagin’s Theorem and Theorems 3.2.18 and 3.2.24
can then be summarized as follows:
•
A model class of ﬁnite structures is NP iﬀit is a generalized spectrum.
•
A model class of ordered structures is in P iﬀit is a generalized Horn
spectrum.
•
A model class of ordered structures is in NLOGSPACE iﬀit is a
generalized Krom spectrum.

3.2 Capturing Complexity Classes
151
3.2.5 Transitive Closure Logics
One of the limitations of ﬁrst-order logic is the lack of a mechanism for
unbounded iteration or recursion. This has motivated the study of more
powerful languages that add recursion in one way or another to ﬁrst-order
logic. A simple but important example of a query that is not ﬁrst-order
expressible is reachability. By adding transitive closure operators to FO, we
obtain a natural family of logics with a recursion mechanism.
Deﬁnition 3.2.25. Transitive closure logic, denoted by TC, is obtained
by augmenting the syntax of ﬁrst order logic by the following rule for building
formulae:
Let ϕ(x, y) be a formula with variables x = x1, . . . , xk and y = y1, . . . , yk,
and let u and v be two k-tuples of terms. Then
[tcx,y ϕ(x, y)](u, v)
is a formula which says that the pair (u, v) is contained in the transitive
closure of the binary relation on k-tuples that is deﬁned by ϕ. In other words,
A |= [tcx,y ϕ(x, y)](a, b) if, and only if, there exist an n ≥1 and tuples
c0, . . . , cn in Ak such that c0 = a, cn = b, and A |= ϕ(ci, ci+1), for all i < n.
Of course, it is understood that ϕ can contain free variables other than
x and y; these will also be free in the new formula. Moreover, transitive
closure logic is closed under the usual ﬁrst-order operations. We can thus
build Boolean combinations of TC-formulae, we can nest TC-operators, etc.
Example 3.2.26. A directed graph G
=
(V, E) is acyclic if, and only
if, G |= ∀z[tcx,yExy](z, z). It is well known that a graph is bipartite
(2-colourable) if, and only if, it does not contain a cycle of odd length. This is
expressed by the TC-formula ∀x∀y([tcx,yx ̸= y∧∃zExz∧Ezy](x, y) →¬Eyx).
Exercise 3.2.27 Show that, for every ψ ∈TC, the set of ﬁnite models of ψ
is decidable in NLOGSPACE.
The same idea as in the proof of Theorem 3.2.24 shows that, on ordered
structures, TC captures NLOGSPACE. The condition that an O(log n)-space-
bounded Turing machine M accepts code(A, <) is expressed by the formula
∃z

ACCEPT(z) ∧[tcx,y NEXT(x, y)](0, z)

.
Theorem 3.2.28 (Immerman).
On
ordered
structures,
TC
captures
NLOGSPACE.
An interesting variant of TC is deterministic transitive closure
logic, denoted DTC, which makes deﬁnable the transitive closure of any
deterministic deﬁnable relation. The syntax of DTC is analogous to TC,

152
3 Finite Model Theory and Descriptive Complexity
allowing us to build formulae of the form [dtcx,y ϕ(x, y)](u, v), for any
formula ϕ(x, y). The semantics can be deﬁned by the equivalence
[dtcx,y ϕ(x, y)](u, v) ≡[tcx,y ϕ(x, y) ∧∀z(ϕ(x, z) →y = z)](u, v).
It is clear that transitive closures of deterministic relations can be checked
by deterministic Turing machines using only logarithmic space. Conversely,
acceptance by such machines amounts to deciding a reachability problem (‘is
there an accepting conﬁguration that is reachable from the input conﬁgura-
tion?’) with respect to the successor relation ⊢M on conﬁgurations. Of course,
for deterministic Turing machines, ⊢M is deterministic. We already know
that on ordered structures, ⊢M is ﬁrst-order deﬁnable, and hence acceptance
can be deﬁned in DTC.
Theorem 3.2.29 (Immerman). On ordered ﬁnite structures DTC captures
LOGSPACE.
In particular, separating DTC from TC on ordered ﬁnite structures would
amount to separating the complexity classes LOGSPACE and NLOGSPACE.
However, on the domain of arbitrary ﬁnite structures, we can actually
separate these logics [51].
Given a graph G = (V, E), let 2G be the graph with vertex set V × {0, 1}
and edges ⟨(u, i), (v, j)⟩for (u, v) ∈E, i, j ∈{0, 1}. It is easy to see that on
the class of all ‘double graphs’ 2G, DTC collapses to FO. Take any tuple
¯u = (u1, i1), . . . , (uk, ik) of vertices in a double graph 2G, and let the closure
of ¯u be the set {u1, . . . , uk} × {0, 1}. Switching the second component of any
node is an automorphism of 2G, and hence no deﬁnable deterministic path
from u can leave the closure of u. That is, if 2G |= [dtcx,yϕ(x, y)](u, v), then
each node of v belongs to the closure of u. Therefore DTC-deﬁnable paths
are of bounded length, and can thus be deﬁned by ﬁrst-order formulae. On
the other hand the usual argument (based on Ehrenfeucht–Fra¨ıss´e games)
showing that transitive closures are not ﬁrst-order deﬁnable applies also to
the class of double graphs. Hence DTC is strictly less powerful than TC on
double graphs. In [51] other graph classes are identiﬁed on which TC is more
expressive than DTC. An interesting example is the class of all hypercubes.
Theorem 3.2.30. On ﬁnite graphs, DTC ⊊TC.
TC is a much richer and more complicated logic than DTC also in
other respects. For instance, DTC has a positive normal form: formulae
¬[dtcxyϕ(x, y)](u, v) can be rewritten using the dtc operator only positively.
On the other hand, the alternation hierarchy in TC is strict [52].
3.3 Fixed-Point Logics
One of the distinguishing features of ﬁnite model theory compared with
other branches of logic is the eminent role of various kinds of ﬁxed-point
logics. Fixed-point logics extend a basic logical formalism (such as ﬁrst-order

3.3 Fixed-Point Logics
153
logic, conjunctive queries, or propositional modal logic) by a constructor for
forming ﬁxed points of relational operators.
What do we mean by a relational operator? Note that any formula
ψ(R, x) of vocabulary τ ∪{R} can be viewed as deﬁning, for every τ-structure
A, an update operator Fψ : P(Ak) →P(Ak) on the class of k-ary relations
on A, namely
Fψ : R →{a : (A, R) |= ψ(R, a)}.
A ﬁxed point of Fψ is a relation R for which Fψ(R) = R. In general, a
ﬁxed point of Fψ need not exist, or there may exist many of them. However,
if R happens to occur only positively in ψ, then the operator Fψ is monotone,
and in that case there exists a least relation R ⊆Ak such that Fψ(R) = R.
The most inﬂuential ﬁxed-point formalisms in logic are concerned with least
(and greatest) ﬁxed points, so we shall discuss these ﬁrst. In ﬁnite model
theory, a number of other ﬁxed-point logics are important as well, and the
structure, expressive power, and algorithmic properties of these logics have
been studied intensively. We shall discuss them later.
3.3.1 Some Fixed-Point Theory
There is a well-developed mathematical theory of ﬁxed points of monotone
operators on complete lattices. A complete lattice is a partial order (A, ≤)
such that each set X ⊆A has a supremum (a least upper bound) and an
inﬁmum (a greatest lower bound). Here we are interested mainly in power
set lattices (P(Ak), ⊆) (where A is the universe of a structure), and later in
product lattices (P(B1) × · · · × P(Bm), ⊆). For simplicity, we shall describe
the basic facts of ﬁxed-point theory for lattices (P(B), ⊆), where B is an
arbitrary (ﬁnite or inﬁnite) set.
Deﬁnition 3.3.1. Let F : P(B) →P(B) be a function.
(1) X ⊆B is a ﬁxed point of F if F(X) = X.
(2) A least ﬁxed point or a greatest ﬁxed point of F is a ﬁxed point X of
F such that X ⊆Y or Y ⊆X, respectively, for each ﬁxed point Y of F.
(3) F is monotone, if X ⊆Y =⇒F(X) ⊆F(Y ) for all X, Y ⊆B.
Theorem 3.3.2 (Knaster
and
Tarski).
Every
monotone
operator
F : P(B) →P(B) has a least ﬁxed point lfp(F) and a greatest ﬁxed point
gfp(F). Further, these ﬁxed points may be written in the form
lfp(F) =

{X : F(X) = X} =

{X : F(X) ⊆X}
gfp(F) =

{X : F(X) = X} =

{X : F(X) ⊇X}.
Proof. Let S = {X ⊆B : F(X) ⊆X} and Y =  S. We ﬁrst show that Y
is a ﬁxed point of F.
F(Y ) ⊆Y . Clearly, Y ⊆X for all X ∈S. As F is monotone, it follows that
F(Y ) ⊆F(X) ⊆X. Hence F(Y ) ⊆ S = Y .

154
3 Finite Model Theory and Descriptive Complexity
Y ⊆F(Y ). As F(Y ) ⊆Y , we have F(F(Y )) ⊆F(Y ), and hence F(Y ) ∈S.
Thus Y =  S ⊆F(Y ).
By deﬁnition, Y is contained in all X such that F(X) ⊆X. In particular
Y is contained in all ﬁxed points of F. Hence Y is the least ﬁxed point of F.
The argument for the greatest ﬁxed point is analogous.
□
Least ﬁxed points can also be constructed inductively. We call an operator
F : P(B) →P(B) inductive if the sequence of its stages Xα (where α is
an ordinal), deﬁned by
X0 := ∅,
Xα+1 := F(Xα), and
Xλ :=

α<λ
Xα for limit ordinals λ,
is increasing, i.e. if Xβ ⊆Xα for all β < α. Obviously, monotone operators
are inductive. The sequence of stages of an inductive operator eventually
reaches a ﬁxed point, which we denote by X∞. The least ordinal β for which
Xβ = Xβ+1 = X∞is called cl(F), the closure ordinal of F.
Lemma 3.3.3. For
every
inductive
operator
F
:
P(B)
→
P(B),
|cl(F)| ≤|B|.
Proof. Let |B|+ denote the smallest cardinal greater than |B|. Suppose that
the claim is false for F. Then for each α < |B|+ there exists an element
xα ∈Xα+1 −Xα. The set {xα : α < |B|+} is a subset of B of cardinality
|B|+ > |B|, which is impossible.
□
Proposition 3.3.4. For monotone operators, the inductively constructed
ﬁxed point coincides with the least ﬁxed point, i.e. X∞= lfp(F).
Proof. As X∞is a ﬁxed point, lfp(X) ⊆X∞. For the converse, we show
by induction that Xα ⊆lfp(F) for all α. As lfp(F) = {Z : F(Z) ⊆Z}, it
suﬃces to show that Xα is contained in all Z for which F(Z) ⊆Z.
For α = 0, this is trivial. By monotonicity and the induction hypothesis,
we have Xα+1 = F(Xα) ⊆F(Z) ⊆Z. For limit ordinals λ with Xα ⊆Z for
all α < λ we also have Xλ = 
α<λ ⊆Z.
□
The greatest ﬁxed point can be constructed by a dual induction, starting
with Y 0 = B, by setting Y α+1 := F(Y α) and Y λ = 
α<λ Y α for limit
ordinals. The decreasing sequence of these stages then eventually converges
to the greatest ﬁxed point Y ∞= gfp(F).
The least and greatest ﬁxed points are dual to each other. For every
monotone operator F, the dual operator F d : X →F(X) (where X denotes
the complement of X) is also monotone, and we have that
lfp(F) = gfp(F d) and gfp(F) = lfp(F d).

3.3 Fixed-Point Logics
155
Exercise 3.3.5 Prove this.
Everything said so far holds for operators on arbitrary (ﬁnite or inﬁ-
nite) power set lattices. In ﬁnite model theory, we consider operators
F : P(Ak) →P(Ak) for ﬁnite A only. In this case the inductive constructions
will reach the least or greatest ﬁxed point in a polynomial number of steps.
As a consequence, these ﬁxed points can be constructed eﬃciently.
Lemma 3.3.6. Let F : P(Ak) →P(Ak) be a monotone operator on a ﬁnite
set A. If F is computable in polynomial time (with respect to |A|), then so
are the ﬁxed points lfp(F) and gfp(F).
3.3.2 Least Fixed-Point Logic
LFP is the logic obtained by adding least and greatest ﬁxed points to
ﬁrst-order logic.
Deﬁnition 3.3.7. Least ﬁxed-point logic (LFP) is deﬁned by adding to the
syntax of ﬁrst-order logic the following least ﬁxed-point formation rule: If
ψ(R, x) is a formula of vocabulary τ ∪{R} with only positive occurrences
of R, if x is a tuple of variables, and if t is a tuple of terms (such that the
lengths of x and t match the arity of R), then
[lfpRx . ψ](t) and [gfpRx . ψ](t)
are formulae of vocabulary τ. The free ﬁrst-order variables of these formulae
are those in (free(ψ) −{x : x in x}) ∪free(t).
Semantics. For any τ-structure A providing interpetations for all free
variables in the formula, we have that A |= [lfpRx . ψ](t) if t
A (the tuple of
elements of A interpreting t) is contained in lfp(Fψ), where Fψ is the update
operator deﬁned by ψ on A. Similarly for greatest ﬁxed points.
Example 3.3.8. Here is a ﬁxed-point formula that deﬁnes the transitive
closure of the binary predicate E:
TC(u, v) := [lfpT xy . Exy ∨∃z(Exz ∧T zy)](u, v).
Note that in a formula [lfpRx . ϕ](t), there may be free variables in ϕ
additional to those in x, and these remain free in the ﬁxed-point formula.
They are often called parameters of the ﬁxed-point formula. For instance,
the transitive closure can also be deﬁned by the formula
ϕ(u, v) := [lfpT y . Euy ∨∃x(T x ∧Exy)](v)
which has u as a parameter.
Exercise 3.3.9 Show that every LFP-formula is equivalent to one without
parameters (at the cost of increasing the arity of the ﬁxed-point variables).

156
3 Finite Model Theory and Descriptive Complexity
Example 3.3.10. Let ϕ := ∀y(y < x →Ry) and let (A, <) be a partial order.
The formula [lfpRx . ϕ](x) then deﬁnes the well-founded part of <. The
closure ordinal of Fϕ on (A, <) is the length of the longest well-founded
initial segment of <, and (A, <) |= ∀x[lfpRx . ϕ](x) if, and only if, (A, <) is
well-founded.
Exercise 3.3.11 Prove that the LFP-sentence
ψ := ∀y∃zFyz ∧∀y[lfpRy . ∀x(Fxy →Rx)](y)
is an inﬁnity axiom, i.e. it is satisﬁable but does not have a ﬁnite model.
Example 3.3.12. The Game query asks, given a ﬁnite game G = (V, V0, V1, E),
to compute the set of winning positions for Player 0 (see Section 3.1.3). The
Game query is LFP-deﬁnable, by use of [lfpWx . ϕ](x) with
ϕ(W, x) := (V0x ∧∃y(Exy ∧Wy)) ∨(V1 ∧∀y(Exy →Wy)).
The Game query plays an important role for LFP. It can be shown that
every LFP-deﬁnable property of ﬁnite structures can be reduced to Game by
a quantiﬁer-free translation [31]. Hence Game is complete for LFP via this
notion of reduction, and thus a natural candidate if one is trying to separate
a weaker logic from LFP.
Exercise 3.3.13 Prove that the problem GEN and the circuit value problem
(see Examples 3.2.13 and 3.2.14) are expressible in LFP.
The duality between the least and greatest ﬁxed points implies that for
any formula ψ,
[gfpRx . ψ](t) ≡¬[lfpRx . ¬ψ[R/¬R]](t),
where ψ[R/¬R] is the formula obtained from ψ by replacing all occurrences
of R-atoms by their negations. (As R occurs only positively in ψ, the same
is true for ¬ψ[R/¬R].) Because of this duality, greatest ﬁxed points are
often omitted in the deﬁnition of LFP. On the other hand, it is sometimes
convenient to keep the greatest ﬁxed points, and to use the duality (and de
Morgan’s laws) to translate LFP-formulae to negation normal form, i.e. to
push negations all the way to the atoms.
Capturing Polynomial Time
From the fact that ﬁrst-order operations are polynomial-time computable and
from Lemma 3.3.6, we can immediately conclude that every LFP-deﬁnable
property of ﬁnite strucures is computable in polynomial time.
Proposition 3.3.14. Let ψ be a sentence in LFP. It is decidable in poly-
nomial time whether a given ﬁnite structure A is a model of ψ. In short,
LFP ⊆PTIME.

3.3 Fixed-Point Logics
157
Obviously LFP, is a fragment of second-order logic. Indeed, by the
Tarski–Knaster Theorem,
[lfpRx . ψ(R, x)](y) ≡∀R((∀x(ψ(R, x) →Rx)) →Ry).
We next relate LFP to SO-HORN.
Theorem 3.3.15. Every formula ψ ∈SO-HORN is equivalent to some
formula ψ∗∈LFP.
Proof. By Theorem 3.2.16, we can assume that ψ = (∃R1) · · · (∃Rm)ϕ ∈
Σ1
1-HORN. By combining the predicates R1, . . . , Rm into a single predicate
R of larger arity and by renaming variables, it is easy to transform ψ into an
equivalent formula
ψ′ := ∃R∀x∀y
	
i
Ci ∧
	
j
Dj,
where the Ci are clauses of the form Rx ←αi(R, x, y) (with exactly
the same head Rx for every i) and the Dj are clauses of the form
0 ←βj(R, x, y). The clauses Ci deﬁne, on every structure A, a monotone
operator F : R →{x : 
i ∃yαi(x, y)}. Let Rω be the least ﬁxed point of this
operator. Obviously A |= ¬ψ if and only if A |= βi(Rω, a, b) for some i and
some tuple a, b. But Rω is deﬁned by the ﬁxed-point formula
αω(x) := [lfpRx .

i
∃yαi(x, y)](x).
Hence,
for
β
:=
∃x∃y 
j βj(x, y),
ψ
is
equivalent
to
the
formula
ψ∗:= ¬β[Rz/αω(z)] obtained from ¬β by substituting all occurrences
of atoms Rz by αω(z). Clearly, this formula is in LFP.
□
Hence SO-HORN ≤LFP ≤SO. As an immediate consequence of
Theorems 3.2.18 and 3.3.15 we obain the Immerman–Vardi Theorem.
Theorem 3.3.16 (Immerman and Vardi).
On ordered structures, least
ﬁxed-point logic captures polynomial time.
However, on unordered structures, SO-HORN is strictly weaker than LFP.
3.3.3 The Modal μ-Calculus
A fragment of LFP that is of fundamental importance in many areas
of computer science (e.g. controller synthesis, hardware veriﬁcation, and
knowledge representation) is the modal μ-calculus (Lμ). It is obtained by
adding least and greatest ﬁxed points to propositional modal logic (ML). In
other words Lμ relates to ML in the same way as LFP relates to FO.
Modal logics such as ML and the μ-calculus are evaluated on transition
systems (alias Kripke structures, alias coloured graphs) at a particular node.

158
3 Finite Model Theory and Descriptive Complexity
Given a formula ψ and a transition system G, we write G, v |= ψ to denote
that G holds at node v of G. Recall that formulae of ML, for reasoning
about transition systems G = (V, (Ea)a∈A, (Pb)b∈B), are built from atomic
propositions Pb by means of the usual propositional connectives and the
modal operators ⟨a⟩and [a]. That is, if ψ is a formula and a ∈A is an action,
then we can build the formulae ⟨a⟩ψ and [a]ψ, with the following semantics:
G, v |= ⟨a⟩ψ iﬀG, w |= ψ for some w such that (v, w) ∈Ea,
G, v |= [a]ψ iﬀG, w |= ψ for all w such that (v, w) ∈Ea.
If there is only one transition relation, i.e. A = {a}, then we simply write 2
and 3 for [a] and ⟨a⟩, respectively.
ML can be viewed as an extension of propositional logic. However, in our
context it is more convenient to view it as a simple fragment of ﬁrst-order
logic. A modal formula ψ deﬁnes a query on transition systems, associating
with G a set of nodes ψG := {v : G, v |= ψ}, and this set can be deﬁned
equivalently by a ﬁrst-order formula ψ∗(x). This translation maps atomic
propositions Pb to atoms Pbx, it commutes with the Boolean connectives,
and it translates the modal operators by use of quantiﬁers as follows:
(⟨a⟩ψ)∗(x) := ∃y(Eaxy ∧ψ∗(y))
([a]ψ)∗(x) := ∀y(Eaxy →ψ∗(y)).
Note that the resulting formula has width 2 and can thus be written with
only two variables. We have proved the following proposition.
Proposition 3.3.17. For every formula ψ ∈ML, there exists a ﬁrst-order
formula ψ∗(x) of width 2, which is equivalent to ψ in the sense that G, v |= ψ
iﬀG |= ψ∗(v).
The modal fragment of ﬁrst-order logic is the image of propositional
modal logic under this translation. It has turned out that the modal fragment
has interesting algorithmic and model-theoretic properties (see [3] and the
references given there).
Deﬁnition 3.3.18. The modal
μ-calculus Lμ extends ML (including
propositional variables X, Y, . . . , which can be be viewed as monadic second-
order variables) by the following rule for building ﬁxed point formulae: If ψ is
a formula in Lμ and X is a propositional variable that only occurs positively
in ψ, then μX.ψ and νX.ψ are also Lμ-formulae.
The semantics of these ﬁxed-point formulae is completely analogous
to that for LFP. The formula ψ deﬁnes on G (with universe V , and with
interpretations for other free second-order variables that ψ may have besides
X) the monotone operator Fψ : P(V ) →P(V ) assigning to every set X ⊆V
the set ψG(X) := {v ∈V : (G, X), v |= ψ}. Now,
G, v |= μX.ψ iﬀv ∈lfp(Fψ)
G, v |= νX.ψ iﬀv ∈gfp(Fψ).

3.3 Fixed-Point Logics
159
Example 3.3.19. The formula μX.ϕ ∨⟨a⟩X asserts that there exists a path
along a-transitions to a node where ϕ holds.
The formula ψ := νX.

a∈A⟨a⟩true ∧
a∈A[a]X

expresses the assertion
that the given transition system is deadlock-free. In other words, G, v |= ψ if no
path from v in G reaches a dead end (i.e. a node without outgoing transitions).
Finally, the formula νX.μY.⟨a⟩((ϕ ∧X) ∨Y ) says that there exists a path
from the current node on which ϕ holds inﬁnitely often.
Exercise 3.3.20 Prove that the formulae in Example 3.3.19 do indeed express
the stated properties.
The translation from ML into FO is readily extended to a translation
from Lμ into LFP.
Proposition 3.3.21. Every formula ψ ∈Lμ is equivalent to a formula
ψ∗(x) ∈LFP.
Proof. By induction. A formula of form μX.ϕ is translated to [lfpXx . ϕ∗](x),
and similarly for greatest ﬁxed points.
□
Further the argument proving that LFP can be embedded into SO also
shows that Lμ is a fragment of MSO.
Let us turn to algorithmic issues. The complexity of the model-checking
problem for Lμ is a major open problem, as far as combined complexity and
expression complexity are concerned (see Section 3.3.5). However, the data
complexity can be settled easily.
Proposition 3.3.22 (data complexity of Lμ). Fix any formula ψ ∈Lμ.
Given a ﬁnite transition system G and a node v, it can be decided in
polynomial time whether G, v |= ψ. Further, there exist ψ ∈Lμ for which the
model checking problem is PTIME-complete.
Proof. As Lμ is a fragment of LFP, the ﬁrst claim is obvious. For the second
claim, recall that the Game problem for strictly alternating games is PTIME-
complete (see Section 3.1.2). Player 0 has a winning strategy from position
v ∈V0 in the game G = (V, V0, V1, E) if, and only if, G, v |= μX.32X.
□
Despite this result, it is not diﬃcult to see that the μ-calculus does not
suﬃce to capture PTIME, even in very restricted scenarios such as word
structures. Indeed, as Lμ is a fragment of MSO, it can only deﬁne regular
languages, and of course, not all PTIME-languages are regular. However, we
shall see in Section 3.5.3 that there is a multidimensional variant of Lμ that
captures the bisimulation-invariant fragment of PTIME.
For more information on the μ-calculus, we refer to [5, 21, 56] and the
references therein.

160
3 Finite Model Theory and Descriptive Complexity
3.3.4 Parity Games
For least ﬁxed-point logics, the appropriate evaluation games are parity
games. These are games of possibly inﬁnite duration where each position is
assigned a natural number, called its priority, and the winner of an inﬁnite
play is determined according to whether the least priority seen inﬁnitely
often during the play is even or odd. It is open whether winning sets and
winning strategies for parity games can be computed in polynomial time.
The best algorithms known today are polynomial in the size of the game, but
exponential with respect to the number of priorities. Practically competitive
model-checking algorithms for the modal μ-calculus work by solving the
strategy problem for the associated parity game (see e.g. [73]).
Deﬁnition 3.3.23. We describe a
parity game by a labelled graph
G = (V, V0, V1, E, Ω), where (V, V0, V1, E) is a game graph as in Section 3.1.2,
and Ω : V →N assigns to each position a priority. The set V of positions
may be ﬁnite or inﬁnite, but the number of diﬀerent priorities must be ﬁnite; it
is called the index of G. Recall that a ﬁnite play of a game is lost by the player
who gets stuck, i.e. cannot move. The diﬀerence to the games of Section 3.1.2
is that we have diﬀerent winning conditions for inﬁnite plays v0v1v2 . . . . If the
smallest number appearing inﬁnitely often in the sequence Ω(v0)Ω(v1) . . . of
priorities is even, then Player 0 wins the play; otherwise, Player 1 wins.
Recall that a positional strategy of Player σ is a partial function
f : Vσ →V with (v, f(v)) ∈E. A strategy f is said to be winning on a
set of positions W ⊆V if any play that starts at a position in W and is
consistent with f is winning for Player σ. Further, Wσ, the winning region
of Player σ, is the set of positions from which Player σ has a winning strategy
(which, a priori, need not be positional).
Exercise 3.3.24 (Combination of positional strategies).
Let f and f ′
be positional strategies for Player σ that are winning on the sets W and W ′,
respectively. Let f ◁f ′ be the positional strategy deﬁned by
(f ◁f ′)(x) :=

f(x)
if x ∈W
f ′(x)
otherwise.
Prove that f ◁f ′ is winning on W ∪W ′.
The Positional Determinacy Theorem for parity games states that parity
games are always determined (i.e., from each position, one of the players has
a winning strategy) and in fact, positional strategies always suﬃce. This was
proved independently by Emerson and Jutla [40] and by Mostowski [86]. Ear-
lier, Gurevich and Harrington [62] had proved that Muller games (which are
more general than parity games) are determined via ﬁnite-memory strategies.

3.3 Fixed-Point Logics
161
Theorem 3.3.25 (Positional Determinacy). In any parity game, the set
of positions can be partitioned into two sets W0 and W1 such that Player 0
has a positional strategy that is winning on W0 and Player 1 has a positional
strategy that is winning on W1.
Here, we only prove this theorem for the case of ﬁnite game graphs.
The presentation is inspired by a similar proof due to Ehrenfeucht and
Mycielski [39] for mean payoﬀgames; see also [12]. For the general case, we
refer the reader to [102] or [97].
Proof. Let G = (V, V0, V1, E, Ω) be a parity game with a ﬁnite set V of
positions. We call a position v ∈V live if it is non-terminal (i.e. if there is at
least one possible move from v). The theorem trivially holds for games with
at most one live position. We now proceed by induction over the number of
live positions.
For every live position v in G and for σ = 0, 1, we deﬁne the game G[v, σ],
which is the same as G except that we change v to a terminal position
where Player σ wins. (Technically this means that we put v into V1−σ and
delete all outgoing edges from v.) By the induction hypothesis, the Forgetful
Determinacy Theorem holds for G[v, σ], and we write W0[v, σ] and W1[v, σ]
for the winning regions of G[v, σ].
It suﬃces to show that for every live position u in G, one of the players has
a positional strategy to win G from u. By Exercise 3.3.24, these strategies can
then be combined into positional strategies that win on the entire winning
regions.
Clearly,
W0[v, 1] ⊆W0 and W1[v, 0] ⊆W1.
Moreover, any positional strategy f for Player σ that is winning from position
u in the game G[v, 1−σ] is also winning from u in the game G and avoids v (i.e.
no play that starts at u and is consistent with f ever hits position v). Now let
Aσ :=

v live
Wσ[v, 1 −σ].
We call positions u ∈Aσ strong winning positions for Player σ because,
informally speaking, Player σ can win G from u even if she gives away some
live positions to her opponent. Similarly, positions outside A0 ∪A1 are called
weak positions. It remains to show that from weak positions also, one of the
players has a positional winning strategy. In fact, one of the players wins,
with a positional winning strategy, from all weak positions.
By the induction hypothesis, if u is not in A1−σ, then, for all live positions
v of G, we have that u ∈Wσ[v, σ] and, moreover, Player σ has a positional
strategy fv by which, starting at any position u ̸∈A1−σ, she either wins or
eventually reaches v.
We distinguish two cases, depending on whether or not there exist strong
winning positions that are live (terminal positions are, of course, always
strong).

162
3 Finite Model Theory and Descriptive Complexity
Case (i).
Suppose that there exists a live position v ∈Aσ. In this case,
Player σ also wins from every weak position u.
We already know that Player σ has a positional strategy f to win G from
v, and a positional strategy fv by which she either wins G or reaches v from
u. We can easily combine f and fv into a positional winning strategy f ∗to
win G from u: we set f ∗(x) := f(x) if f is winning from x, and f ∗(x) := fv(x)
otherwise.
Case (ii).
Suppose now that all live positions are weak. We claim that in
this case, Player 0 wins from all live (i.e. all weak) positions if the minimal
priority on G is even, and Player 1 wins from all live positions if the minimal
priority is odd.
Since all live positions are weak, we already know that Player σ has, for
every live position y, a positional strategy fy by which she either wins or
reaches y from any live position in G.
Take now a live position v of minimal priority, and put σ = 0 if Ω(v) is
even, and σ = 1 if Ω(v) is odd. In addition, pick any live position w ̸= v. We
combine the positional winning strategies fv and fw into a new positional
strategy f with
f(x) :=

fw(x)
if x = v
fv(x)
otherwise.
We claim that f is a winning strategy for Player σ from all live positions
of G. If a play in G in which Player 0 moves according to f hits v only ﬁnitely
often, then this play eventually coincides with a play consistent with fv,
and is therefore won by Player σ. But if the play hits v inﬁnitely often, the
minimal priority seen inﬁnitely often is Ω(v), and hence Player σ wins also
in this case.
□
Exercise 3.3.26 Let G be a parity game with winning sets W0 and W1.
Obviously every positional winning strategy for Player 0 has to remain inside
W0, i.e. f(V0 ∩W0) ⊆W0. However, remaining inside the winning region does
not suﬃce for winning a game! Construct a parity game and a positional
strategy f for Player 0 such that all plays consistent with f remain insiside
W0, yet are won by Player 1. Hint: a trivial game with two positions suﬃces.
Exercise 3.3.27 A
future
game
is
any
game
on
a
game
graph
G = (V, V0, V1, E) where the winning condition does not depend on ﬁnite
preﬁxes of plays. This means that whenever π = v0v1 · · · and π′ = v′
0v′
1 · · · are
two inﬁnite plays of G such that for some n and m vmvm+1 · · · = v′
nv′
n+1 · · · ,
then π and π′ are won by the same player. Obviously parity games are a
special case of future games.
Prove that for every future game G, the winning region of Player 0 is a
ﬁxed point (not necessarily the least one) of the operator Fψ, deﬁned by the
formula ψ(X) := (V0 ∧3X)∨(V1 ∧2X). Since Fψ is monotone, the least and

3.3 Fixed-Point Logics
163
greatest ﬁxed points exist, and lfp(Fψ) ⊆W0 ⊆gfp(Fψ). Find conditions
(on parity games) implying that W0 = lfp(Fψ) or that W0 = gfp(Fψ).
Theorem 3.3.28. It can be decided in NP ∩Co-NP whether a given position
in a parity game is a winning position for Player 0.
Proof. A node v in a parity game G = (V, V0, V1, E, Ω) is a winning position
for Player σ if there exists a positional strategy f : Vσ →V which is winning
from position v. It therefore suﬃces to show that the question of whether
a given f : Vσ →V is a winning strategy for Player σ from position v can
be decided in polynomial time. We prove this for Player 0; the argument for
Player 1 is analogous.
Given G and f : V0 →V we obtain a reduced game graph Gf = (V, Ef)
by keeping only the moves that are consistent with f, i.e.
Ef = {(v, w) : (v ∈Vσ ∧w = f(v)) ∨(v ∈V1−σ ∧(v, w) ∈E}.
In this reduced game, only the opponent, Player 1, makes non-trivial moves.
We call a cycle in (V, Ef) odd if the smalest priority of its nodes is odd.
Clearly, Player 0 wins G from position v via strategy f if, and only if, in Gf,
no odd cycle and no terminal position w ∈V0 are reachable from v. Since the
reachability problem is solvable in polynomial time, the claim follows.
□
In fact, Jurdzi´nski [72] proved that the problem is in UP ∩Co-UP, where
UP denotes the class of NP-problems with unique witnesses. The best known
deterministic algorithms to compute winning partitions of parity games have
running times that are polynomial with respect to the size of the game graph,
but exponential with respect to the index of the game [73].
Theorem 3.3.29. The
winning
partition
of
a
parity
game
G
=
(V, V0, V1, E, Ω) of index d can be computed in space O(d · |E|) and time
O

d · |E| ·
 |V |
⌊d/2⌋
⌊d/2⌋
.
The Unfolding of a Parity Game
Let G = (V, V0, V1, E, Ω) be a parity game. We assume that the minimal prior-
ity in the range of Ω is even, and that every node v with minimal priority has
a unique successor s(v) (i.e. vE = {s(v)}). This is no loss of generality. We can
always tranform a parity game in such a way that all nodes with non-maximal
priority have unique successors (i.e. choices are made only at the least relevant
nodes). If the smallest priority in the game is odd, we consider instead the dual
game (with the roles of the players switched and priorities decreased by one).
Let T be the set of nodes with minimal priority and let G−be the game
obtained by deleting from G all edges (v, s(v)) ∈T × V so that the nodes in

164
3 Finite Model Theory and Descriptive Complexity
T become terminal positions. We deﬁne the unfolding of G as a sequence of
games Gα (where α ranges over the ordinals) which all coincide with G−up
to the winning conditions for the terminal positions v ∈T . For every α, we
deﬁne a decomposition T = T α
0 ∪T α
1 , where T α
σ is the set of v ∈T in which
we declare, for the game Gα, Player σ to be the winner. Further, for every
α, we write W α
σ for the winning set of Player σ in the game Gα. Note that
W α
σ depends of course on the decomposition T = T α
0 ∪T α
1 (this also applies
concerning positions outside T ). In turn, the decomposition of T for α + 1
depends on the winning sets W α
σ in Gα. We set
T 0
0 := T
T α+1
0
:= {v ∈T : s(v) ∈W α
0 }
T λ
0 :=

α<λ
T α
0 for limit ordinals λ.
By determinacy, V = W α
0 ∪W α
1 for all α, and with increasing α, the
winning sets of Player 0 are decreasing and the winning sets of Player 1 are
increasing:
W 0
0 ⊇W 1
0 ⊇· · · W α
0 ⊇W α+1
0
⊇· · ·
W 0
1 ⊆W 1
1 ⊆· · · W α
1 ⊆W α+1
1
⊆· · · .
Hence there exists an ordinal α (whose cardinality is bounded by the
cardinality of V ) for which W α
0 = W α+1
0
=: W ∞
0
and W α
1 = W α+1
1
=: W ∞
1 .
We claim that these ﬁxed points coincide with the winning sets W0 and W1
for the original game G.
Lemma 3.3.30 (Unfolding Lemma). W0 = W ∞
0
and W1 = W ∞
1 .
Proof. It suﬃces to deﬁne a strategy f for Player 0 and a strategy g for Player
1 for the game G, by means of which Player σ wins from all positions v ∈W ∞
σ .
First, we ﬁx a winning strategy f α for Player 0 in Gα, with winning set
W α
0 = W ∞
0 . Note that f α can be trivially extended to a strategy f for the
game G, since the nodes in T have unique successors in G. We claim that f
is in fact a winning strategy in G from all positions v ∈W α
0 .
To see this, consider any play v0v1v2 . . . in G from position v0 ∈W α
0
against f. Such a play can never leave W α
0 . If vi ∈W α
0 \ T , then vi+1 ∈W α
0
because f is a winning strategy for Gα; and if vi ∈W α
0 ∩T = W α+1
0
∩T , then
vi ∈T α+1
0
, which implies, by the deﬁnition of T α+1
0
, that vi+1 = s(vi) ∈W α
0 .
But a play that never leaves W α
0 is necessarily won by Player 0: either it goes
only ﬁnitely often through positions in T , and then coincides from a certain
point onwards with a winning play in Gα, or it goes inﬁnitely often through
positions in T , in which case Player 0 wins because the minimal priority that
is hit inﬁnitely often is even.

3.3 Fixed-Point Logics
165
To construct a winning strategy for Player 1 in the game G, we deﬁne,
for every node v ∈W ∞
1 , the ordinal
ρ(v) := min{β : v ∈W β
1 }.
We ﬁx, for every ordinal α, a winning strategy gα for Player 1 with winning
set W α
1 in the game Gα, and set
g(v) := gσ(v)(v) for all v ∈V1 \ T
and g(v) := s(v) for v ∈V1 ∩T .
Consider any play v0v1v2 . . . in G from position v0 ∈W ∞
1
against g. We
claim that whenever vi ∈W ∞
1 , then
(1) vi+1 ∈W ∞
1 ,
(2) ρ(vi+1) ≤ρ(vi), and
(3) if vi ∈T , then ρ(vi+1) < ρ(vi).
If vi ∈W ∞
1
\ T and ρ(vi) = α, then vi ∈W α
1 , and therefore (since Player 1
moves locally according to his winning strategy gα and Player 0 cannot leave
winning sets of her opponent) vi+1 ∈W α
1 . But if vi ∈W ∞
1 ∩T and ρ(vi) = α,
then vi ∈T α
1 , α = β + 1 is a successor ordinal, and vi+1 = s(vi) ∈W β
1 (by
the deﬁnition of T α
1 ). Hence ρ(vi+1) ≤β < ρ(vi).
Properties (1), (2), and (3) imply that the play stays inside W ∞
1
and that
the values ρ(v) are decreasing. Since there are no inﬁnite strictly descending
chains of ordinals, the play eventually remains inside W α
1 , for a ﬁxed α, and
outside T (since moves from T would reduce the value of σ(v)). Hence the
play eventually coincides with a play in Gα in which Player 1 plays according
to his winning strategy gα. Thus, Player 1 wins.
□
3.3.5 Model-Checking Games for Least Fixed-Point Logic
For the purpose of deﬁning evaluation games for LFP-formulae and analysing
the complexity of model checking, it is convenient to make the following
assumptions. First, the ﬁxed-point formulae should not contain parameters
(the reason for this will be discussed below). Second, the formula should be in
negation normal form, i.e. negations apply to atoms only, and third, it should
be well-named, i.e. every ﬁxed-point variable is bound only once and the free
second-order variables are distinct from the ﬁxed-point variables. We write
Dψ(T ) for the unique subformula in ψ of the form [fpT x . ϕ(T, x)] (where fp
means either lfp or gfp). For technical reasons, we assume, ﬁnally, that each
ﬁxed-point variable T occurs in Dψ(T ) only inside the scope of a quantiﬁer.
This is a common assumption that does not aﬀect the expressive power. We
say that T ′ depends on T if T occurs free in Dψ(T ′). The transitive closure
of this dependency relation is called the dependency order, denoted by
<ψ. The alternation level alψ(T ) of T in ψ is the maximal number of

166
3 Finite Model Theory and Descriptive Complexity
alternations between least and greatest ﬁxed-point variables on the <ψ-paths
from T . The alternation depth ad(ψ) of a ﬁxed-point formula ψ is the
maximal alternation level of its ﬁxed point variables.
Consider now a ﬁnite structure A and an LFP-formula ψ(x), which we
assume to be well-named, in negation normal form, and without parameters.
The model-checking game G(A, ψ(a)) is a parity game. As in the case of ﬁrst-
order logic, the positions of the game are expressions ϕ(b), i.e. subformulae
of ψ that are instantiated by elements of A. The initial position is ψ(a). The
moves are as in the ﬁrst-order game, except for the positions associated with
ﬁxed-point formulae and with ﬁxed-point atoms. At such positions there is
a unique move (by Falsiﬁer, say) to the formula deﬁning the ﬁxed point. For
a more formal deﬁnition, recall that as ψ is well-named, there is, for any
ﬁxed-point variable T in ψ, a unique subformula [fp T x . ϕ(T, x)](y). From
position [fpT x . ϕ(T, x)](b), Falsiﬁer moves to ϕ(T, b), and from any ﬁxed
point atom T c, she moves to the position ϕ(T, c).
Hence the case where we do not have ﬁxed points the game is the usual
model-checking game for ﬁrst-order logic. Next, we consider the case of a
formula with only one ﬁxed-point operator, which is an lfp. The intuition is
that from position [lfp T x . ϕ(T, x)](b), Veriﬁer tries to establish that b enters
T at some stage α of the ﬁxed-point induction that is deﬁned by ϕ on A. The
game goes to ϕ(T, b) and from there, as ϕ is a ﬁrst-order formula, Veriﬁer can
either win the ϕ-game in a ﬁnite number of steps, or force it to a position T c,
where c enters the ﬁxed point at some stage β < α. The game then resumes
at position ϕ(c), associated again with ϕ. As any descending sequence of
ordinals is ﬁnite, Veriﬁer will win the game in a ﬁnite number of steps. If the
formula is not true, then Falsiﬁer can either win in a ﬁnite number of steps or
force the play to go through inﬁnitely many positions of the form T c. Hence,
these positions should be assigned priority 1 (and all other positions higher
priorities) so that such a play will be won by Falsiﬁer. For gfp-formulae, the
situation is reversed. Veriﬁer wants to force an inﬁnite play, going inﬁnitely
often through positions T c, so gfp-atoms are assigned priority 0.
In the general case, we have a formula ψ with nested least and greatest
ﬁxed points, and in an inﬁnite play of G(A, ψ(a)) one may see diﬀerent ﬁxed
point variables inﬁnitely often. But one of these variables is then the smallest
with respect to the dependency order <ψ. It can be shown that A |= ψ iﬀ
this smallest variable is a gfp-variable (provided the players play optimally).
Hence, the priority labelling should assign even priorities to gfp-atoms
and odd priorities to lfp-atoms. Further, if T <ψ T ′ and T, T ′ are ﬁxed-point
variables of diﬀerent kinds, then T -atoms should get a lower priority than
T ′-atoms.
As the index of a parity game is the main source of diﬃculty in computing
winning sets, the number of diﬀerent priorities should be kept as small as pos-
sible. We can avoid the factor of 2 appearing in common constructions of this
kind by adjusting the deﬁnitions of the alternation level and alternation depth,
setting al∗
ψ(T ) := alψ(T ) + 1 if alψ(T ) is even or odd and T is an lfp-variable

3.3 Fixed-Point Logics
167
or a gfp-variable, respectively. In all other cases, al∗
ψ(T ) = alψ(T ). Finally, let
ad∗(ψ) be the maximal value of ad∗
ψ(T ) for the ﬁxed-point variables in ψ. The
priority labelling Ω on positions of G(A, ψ) is then deﬁned by Ω(T b) = al∗
ψ(T )
for ﬁxed-point atoms, and Ω(ϕ(b)) = ad∗(ψ) for all other formulae.
This completes the deﬁnition of the game G(A, ψ(a)). Note that the
priority labelling has the properties described above, and that the index of
G(A, ψ(a)) is at most ad(ψ) + 1.
Theorem 3.3.31. Let ψ(x) be a well-named and parameter-free LFP-formula
in negation normal form, and let A be a relational structure. A |= ψ(a) if and
only if Player 0 has a winning strategy for the parity game G(A, ψ(a)).
Proof. This is proved by induction on ψ. The interesting case concerns
ﬁxed-point formulae ψ(x) := [gfpT x . ϕ(x)](x).
In the game G(A, ψ(a)), the positions of minimal priority are the
ﬁxed-point atoms T b, which have unique successors ϕ(b). By the induction
hypothesis we know that, for every interpretation T0 of T , (A, T0) |= ϕ(a)
iﬀPlayer 0 has a winning strategy for G((A, T0), ϕ(a)). By the unfold-
ing of greatest ﬁxed points, we also know that A |= [gfpT x . ϕ(x)](a) if
(A, T α) |= ϕ(a) for all approximations T α.
By
ordinal
induction,
one
can
immediately
see
that
the
games
G((A, T α), ϕ(a)) coincide with the unfolding of the game G = G(A, ψ(a)) to
the games Gα. By the Unfolding Lemma, we conclude that Player 0 wins the
game G(A, ψ(a)) if, and only if, she wins all games Gα which is the case if,
and only if, (A, T α) |= ϕ(a) for all α, which is equivalent to A |= ψ(a).
For least ﬁxed-point formulae we proceed by dualization.
□
Clearly, the size of the game G(A, ψ(a)) (and the time complexity of its
construction) is bounded by |cl(ψ)| · |A|width(ψ). Hence, for LFP-formulae of
bounded width, the size of the game is polynomially bounded.
Corollary 3.3.32. The model-checking problem for LFP-formulae of bounded
width (and without parameters) is in NP ∩Co-NP, in fact in UP ∩Co-UP.
As formulae of the μ-calculus can be viewed as LFP-formulae of width 2,
the same bound applies to Lμ. (For a diﬀerent approach to this problem, which
does not mention games explicitly, see [100].) It is a well-known open problem
whether the model-checking problem for Lμ can be solved in polynomial time.
Exercise 3.3.33 Prove that if the model-checking problem for Lμ can
be solved in polynomial time, then the same is true for (parameter-
free) LFP-formulae of width k, for any ﬁxed k
∈
N. Hint: given
a ﬁnite structure A
=
(A, R1, . . . , Rm), with relations of Ri of ari-
ties
ri
≤
k,
let
Gk(A)
be
the
transition
system
with
universe
Ak, unary relations R∗
i
=
{(a1, . . . , ak)
:
(a1, . . . , ari)
∈
Ri} and
Iij = {(a1, . . . , ak) : ai = aj}, and binary relations Ej = {(a, b) : ai = bi

168
3 Finite Model Theory and Descriptive Complexity
for i ̸= j} (for j = 1, . . . , k) and Eσ = {(a, b) : bi = aσ(i) for i = 1, . . . , k} for
each substitution σ : {1, . . ., k} →{1, . . . , k}. Translate formulae ψ ∈LFP
of width k into formulae ψ∗∈Lμ such that A |= ψ(a) iﬀGk(A), a |= ψ∗.
(See [55, pp. 110–111] for details.)
By Theorem 3.3.29, we obtain the following deterministic complexity
bounds for LFP model checking.
Theorem 3.3.34. Given a ﬁnite structure A and a formula ψ(a) of width
k and alternation depth d, it can be decided whether A |= ψ(a) in space
O(d · |cl(ψ)| · |A|k) and time
O

d2 ·
|cl(ψ)| · |A|k
⌊(d + 1)/2⌋
⌊(d+3)/2⌋
.
Corollary 3.3.35. The model-checking problem for LFP-formulae of bounded
width and bounded alternation depth is solvable in polynomial time.
Fixed-Point Formulae with Parameters
We have imposed the condition that the ﬁxed-point formulae do not contain
parameters. If parameters are allowed, then, at least with a naive deﬁnition
of width, Corollary 3.3.32 is no longer true (unless UP = PSPACE). The
intuitive reason is that parameters allow us to ‘hide’ ﬁrst-order variables in
ﬁxed-point variables. Indeed, Dziembowski [37] proved that QBF, the evalu-
ation problem for quantiﬁed Boolean formulae, can be reduced to evaluating
LFP-formulae with two ﬁrst-order variables (but an unbounded number of
monadic ﬁxed-point variables) on a ﬁxed structure with three elements. Hence
the expression complexity of evaluating such formulae is PSPACE-complete.
A similar argument works for the case where also the number of ﬁxed-point
variables is bounded, but the structure is not ﬁxed (combined complexity
rather than expression complexity). We remark that the collection of all
unwindings in inﬁnitary logic of LFP-formulae with k variables, including
parameters, is not contained in any bounded width fragment of inﬁnitary logic.
LFP-Formulae of Unbounded Width
For LFP-formulae of unbounded width, Theorem 3.3.34 gives only an
exponential time bound. In fact, this cannot be improved, even for very
simple LFP-formulae [99].
Theorem 3.3.36 (Vardi).
The model-checking problem for LFP-formulae
(of unbounded width) is EXPTIME-complete, even for formulae with only
one ﬁxed-point operator, and on a ﬁxed structure with only two elements.
We defer the hardness proof to Section 3.3.10, where we shall show that
the expression complexity is EXPTIME-hard even for Datalog, which is a
more restricted formalism than LFP.

3.3 Fixed-Point Logics
169
3.3.6 Deﬁnability of Winning Regions in Parity Games
We have seen that the model-checking problem for the μ-calculus or LFP
can be reduced to the problem of computing winning regions in parity
games. In fact, there is also a reduction in the reverse direction. We can
represent any parity game G = (V, V0, V1, E, Ω) with a priority function
Ω : V →{0, . . . d −1} by a transition system (V, E, V0, V1, P0, . . . , Pd−1),
where Pi = {V : Ω(v) = i}. We can then construct, for every ﬁxed d ∈N, a
formula Wind of the μ-calculus that deﬁnes the winning region of Player 0 in
any parity game with priorities 0, . . . , d −1. We set
Wind = νX0μX1νX2 . . . λXd−1
d−1

j=0

(V0 ∧Pj ∧3Xj) ∨(V1 ∧Pj ∧2Xj)

.
In this formula, the ﬁxed-point operators alternate between ν and μ, and
hence λ = ν if d is odd, and λ = μ if d is even.
Theorem 3.3.37. For every d ∈N, the formula Wind deﬁnes the winning
region of Player 0 in parity games with priorities 0, . . . , d −1.
Proof. We have to show that, for any parity game G = (V, V0, V1, P0, . . . , Pd−1)
and every position v ∈V ,
G, v |= Wind ⇐⇒Player 0 has a winning strategy for G from v.
To see this, let G∗be the model-checking game for the formula Wind on
G, v and identify Veriﬁer with Player 0 and Falsiﬁer with Player 1. Hence,
Player 0 has a winning strategy for G∗if, and only if, G, v |= Wind.
By the construction of model-checking games, G∗has positions of the form
(ϕ, u), where u ∈V and ϕ is a subformula of Wind. The priority of a position
(Xi, u) is i, and when ϕ is not a ﬁxed point variable, the priority of (ϕ, u) is d.
We claim that the game G∗is essentially, i.e. up to elimination of stupid
moves and contraction of several moves into one, the same as the the original
game G. To see this, we compare playing G from a current position u ∈V0 ∪Pi
with playing G∗from any position (ϕk, u), where ϕk is the subformula of
Wind that starts with νXk or μXk.
In G, Player 0 selects at position u a successor w ∈uE, and the play
proceeds from w. In G∗, the play goes from (ϕk, u) through positions
(ϕk+1, u) . . . , (ϕd−1, u) to (ϑ, u), where
ϑ =
d−1

j=0

(V0 ∧Pj ∧3Xj) ∨(V1 ∧Pj ∧2Xj)

.
The only reasonable choice for Veriﬁer (Player 0) at this point is to move to
the position (V0∧Pi∧3Xi, u), since with any other move she would lose imme-
diately. But from there, the only reasonable move of Falsiﬁer (Player 1) is to

170
3 Finite Model Theory and Descriptive Complexity
go to position (3Xi, u), and it is now the turn of Player 0 to select a successor
w ∈vE and move to position (Xi, w) from which the play proceeds to (ϕi, w).
Thus one move from u to w in G corresponds to a sequence of moves
in G∗from (ϕk, u) to (ϕi, w), but the only genuine choice is the move from
(3Xi, u) to (Xi, w), i.e. the choice of a successor w ∈uE. In G, the position
u has priority i, and in G∗the minimal, and hence relevant, priority that is
seen in the sequence of moves from (ϕk, u) to (ϕi, w) is that of (Xi, u) which
is also i. The situation for positions u ∈V1 ∩Pi is the same, except that
the play in G∗now goes through (2Xi, u) and it is Player 1 who selects a
successor w ∈uE and moves to (Xi, w).
Hence the (reasonable) choices that have to be made by the players in G∗
and the relevant priorities that are seen are the same as in a corresponding
play of G. Thus, Player 0 has a winning strategy for G from v if, and only if,
Player 0 has a winning strategy for G∗from position (ϕ0, v). But since G∗is
the model-checking game for Wind on G, with initial position (ϕ0, v), this is
the case if, and only if, G, v |= Wind.
□
Corollary 3.3.38. The following three problems are algorithmically equiva-
lent, in the sense that if one of them admits a polynomial-time algorithm,
then all of them do.
(1) Computing winning regions in parity games.
(2) The model-checking problem for LFP-formulae of width at most k, for
any k ≥2.
(3) The model-checking problem for the modal μ-calculus.
The formulae Wind also play an important role in the study of the
alternation hierarchy of the modal μ-calculus. Clearly, Wind has alternation
depth d and it has been shown that there is no formula in the μ-calculus
with alternation depth < d can be equivalent to Wind. Hence the alternation
hierarchy of the μ-calculus is strict [4, 20].
3.3.7 Simultaneous Fixed-Point Inductions
A more general variant of LFP permits simultaneous inductions over several
formulae. A simultaneous induction is based on on a system of operators of
the form
F1 : P(B1) × · · · × P(Bm) −→P(B1)
...
Fm : P(B1) × · · · × P(Bm) −→P(Bm),
forming together an operator
F = (F1, . . . , Fm) : P(B1) × · · · × P(Bm) −→P(B1) × · · · × P(Bm).

3.3 Fixed-Point Logics
171
Inclusion on the product lattice P(B1) × · · · × P(Bm) is componentwise.
Accordingly, F is monotone if, whenever Xi ⊆Yi for all i, then also
Fi(X) ⊆Fi(Y ) for all i.
Everything said above about least and greatest ﬁxed points carries over
to simultaneous induction. In particular, a monotone operator F has a
least ﬁxed point lfp(F) which can be constructed inductively, starting with
X
0 = (∅, . . . , ∅) and iterating F until a ﬁxed point X
∞is reached.
One can extend the logic LFP by a simultaneous ﬁxed point formation rule.
Deﬁnition 3.3.39. Simultaneous least ﬁxed-point logic, denoted by
S-LFP, is the extension of ﬁrst-order logic by the following rule.
Syntax.
Let
ψ1(R, x1), . . . , ψm(R, xm)
be
formulae
of
vocabulary
τ ∪{R1, . . . , Rm}, with only positive occurrences of R1, . . . , Rm, and, for
each i ≤m, let xi be a sequence of variables matching the arity of Ri. Then
S :=
⎧
⎪
⎨
⎪
⎩
R1x1
:= ψ1
...
Rmxm := ψm
is a system of update rules, which is used to build formulae [lfp Ri : S](t) and
[gfp Ri : S](t) (for any tuple t of terms whose length matches the arity of Ri).
Semantics.
On
each
structure
A,
S
deﬁnes
a
monotone
operator
SA = (S1, . . . , Sm) mapping tuples R = (R1, . . . , Rm) of relations on A to
SA(R) = (S1(R), . . . , Sm(R)) where Si(R) := {a : (A, R) |= ψi(R, a)}. As the
operator is monotone, it has a least ﬁxed point lfp(SA) = (R∞
1 , . . . , R∞
m).
Now A |= [lfpRi : S](a) if a ∈R∞
i . Similarly for greatest ﬁxed points.
Example 3.3.40. We return to the circuit value problem for circuits with
fan-in 2 and NAND gates (see Example 3.2.14). Simultaneous LFP-deﬁnitions
of the nodes evaluating to true and false in the given circuit (V, E, I+, I−)
are given by the formulae [lfpT : S](z) and [lfpF : S](z), respectively, where
S is the system
T z := I+z ∨∃x(Exz ∧Fx)
Fz := I−z ∨∃x∃y(Exz ∧Eyx ∧x ̸= y ∧T x ∧T y).
Elimination of Simultaneous Fixed-Points
The question arises of whether simultaneous ﬁxed points provide more
expressive power than simple ones. We shall prove that this is not the case.
Simultaneous least ﬁxed points can be simulated by nested simple ones, via a

172
3 Finite Model Theory and Descriptive Complexity
technique that is sometimes called the Bekic principle [5]. We shall consider
only the case of two monotone operators
F : P(A) × P(B) →P(A)
G : P(A) × P(B) →P(B).
We write (F ∞, G∞) for the least ﬁxed point of the combined operator (F, G).
For any ﬁxed X ⊆A, the operator GX : P(B) →P(B) with GX(Y ) :=
G(X, Y ) is also monotone, and therefore has a least ﬁxed point lfp(GX) ⊆B.
Lemma 3.3.41. The
operator
E
on
P(A),
deﬁned
by
E(X)
:=
F(X, lfp(GX)), is monotone and has the least ﬁxed point lfp(E) = F ∞.
Proof. If X ⊆X′, then a trivial induction shows that Gα
X ⊆Gα
X′ for all
stages Gα
X and Gα
X′ of the induced operators GX and GX′. As a consequence,
lfp(GX) ⊆lfp(GX′) and E(X) = F(X, lfp(GX)) ⊆F(X′, lfp(GX′)) =
E(X′). This shows that E is monotone.
Note that lfp(GF ∞) ⊆G∞, because GF ∞(G∞) = G(F ∞, G∞) = G∞.
Hence G∞is a ﬁxed point of GF ∞and therefore contains the least ﬁxed
point lfp(GF ∞). Further,
E(F ∞) = F(F ∞, lfp(GF ∞)) ⊆F(F ∞, G∞) = F ∞.
As lfp(E) = {X : E(X) ⊆X} it follows that lfp(E) ⊆F ∞.
It remains to show that F ∞⊆lfp(E). We proceed by induction, showing
that the stages (F α, Gα) of the operator (F, G) and the stages Eα of E satisfy
(F α, Gα) ⊆(lfp(E), lfp(Glfp(E)).
For α = 0, this is clear. Further,
F α+1 = F(F α, Gα) ⊆F(lfp(E), lfp(Glfp(E))) = E(lfp(E) = lfp(E)
Gα+1 = G(F α, Gα) ⊆G(lfp(E), lfp(Glfp(E))) = Glfp(E)(lfp(Glfp(E))
= lfp(Glfp(E)).
Finally, for limit ordinals the induction argument is trivial.
□
We are now ready to show that for any system
S :=
⎧
⎪
⎨
⎪
⎩
R1x1
:= ψ1
...
Rmxm := ψm
the formulae [lfp Ri : S](x) are equivalent to simple LFP formulae. Further,
the translation does not increase the number and arity of the ﬁxed-point
variables R1, . . . , Rm, nor the alternation depth (i.e. the changes between
least and greatest ﬁxed points). It therefore remains valid for interesting

3.3 Fixed-Point Logics
173
fragments of LFP, such as monadic LFP and alternation-free LFP, and also
for the modal μ-calculus (see [5]). It does, however, increase the nesting depth
of ﬁxed-point operators. (We remark that there are alternative elimination
techniques that do not increase the nesting depth, but instead augment the
arity of the ﬁxed-point operators.)
Theorem 3.3.42. S-LFP ≡LFP.
Proof. Obviously LFP is contained in S-LFP. For the converse, we restrict
our attention to simultaneous inductions over two formulae. The general case
is treated by analogous arguments.
Given a system
S :=

Rx := ψ(R, T )
T y := ϕ(R, T )
we claim that
[lfp R : S](u) ≡[lfpRx . ψ(R, [lfpT y . ϕ])](u)
[lfp T : S](v) ≡[lfpT y . ϕ([lfpRx . ψ], T )](v).
We shall prove the ﬁrst equivalence. We ﬁx a structure A and consider
the operator SA = (F, G) with F : (R, T ) →{a : A |= ψ(R, T, a)} and
G : (R, T ) →{a : A |= ϕ(R, T, a)}. Writing (F ∞, G∞) for the least ﬁxed
point of (F, G) we have that A |= [lfp R : S](a) iﬀa ∈F ∞.
The
formula
ψ(R, [lfpT y
.
ϕ])
deﬁnes
on
A
the
operator
E : R →F(R, lfp(GR)) with GR : T
→G(R, T ), and we have that
A |= [lfpRx . ψ(R, [lfpT y . ϕ])](a) iﬀa ∈lfp(E). But, by the previous
lemma, F ∞= lfp(E).
□
While we have shown that simultaneous ﬁxed points do not provide more
expressive power, they permit us to write formulae in a more modular and
more readable form.
Positive LFP
While LFP and the modal μ-calculus allow arbitrary nesting of least and
greatest ﬁxed points, and arbitrary interleaving of ﬁxed points with Boolean
operations and quantiﬁers, classical studies of inductive deﬁnability over ﬁrst-
order logic (such as [85]) focus on a more restricted logic. Let LFP1 (sometimes
also called positive LFP) be the extension of ﬁrst-order logic that is obtained
by taking least ﬁxed points of positive ﬁrst-order formulae (without param-
eters) and closing them under disjunction, conjunction, and existential and
universal quantiﬁcation, but not under negation (for a more formal deﬁnition,
see the Chap. 2. LFP1 can be conveniently characterized in terms of simul-
taneous least ﬁxed points. We just state the result; for a proof see Chap. 2
again.

174
3 Finite Model Theory and Descriptive Complexity
Theorem 3.3.43. A query is deﬁnable in LFP1 if and only if it is deﬁnable
by a formula of the form [lfpR : S](x), where S is a system of update rules
Rix := ϕi(R, x) with ﬁrst-order formulae ϕi. Moreover, we can require,
without diminishing the expressive power, that each of the formulae ϕi in the
system is either a purely existential formula or a purely universal formula.
3.3.8 Inﬂationary Fixed-Point Logic
LFP is only one instance of a logic with an explicit operator for forming
ﬁxed points. A number of other ﬁxed-point extensions of ﬁrst-order logic (or
fragments of it) have been extensively studied in ﬁnite model theory. These
include inﬂationary, partial, non-deterministic, and alternating ﬁxed point
logics. All of these have in common that they allow the construction of ﬁxed
points of operators that are not necessarily monotone.
An operator G : P(B) →P(B) is called inﬂationary if G(X) ⊇X for
all X ⊆B. With any operator F one can associate an inﬂationary operator
G, deﬁned by G(X) := X ∪F(X). In particular, inﬂationary operators are
inductive, so iterating G yields a ﬁxed point, called the inﬂationary ﬁxed
point of F.
Exercise 3.3.44 Prove the following facts. (1) Monotone operators need not
be inﬂationary, and inﬂationary operators need not be monotone. (2) An
inﬂationary operator need not have a least ﬁxed point. (3) The least ﬁxed
point of an inﬂationary operator (if it exists) may be diﬀerent from the
inductive ﬁxed point. (4) However, if F is a monotone operator, then its
inﬂationary ﬁxed point and its least ﬁxed point coincide.
The logic IFP is deﬁned with a syntax similar to that of LFP, but without
the requirement that the ﬁxed-point variable occurs only positively in the
formula, and with a semantics given by the associated inﬂationary operator.
Deﬁnition 3.3.45. IFP is the extension of ﬁrst-order logic by the following
ﬁxed-point formation rule. For every formula ψ(R, x), every tuple x of
variables, and every tuple t of terms (such that the lengths of x and t match
the arity of R), we can build a formula [ifpRx . ψ](t).
Semantics. On a given structure A, we have that A |= [ifpRx . ψ](t) if t
A
is contained in the union of the stages Rα of the inﬂationary operator Gψ
deﬁned by Gψ(R) := R ∪Fψ(R).
By the last item of Exercise 3.3.44, least and inﬂationary inductions are
equivalent for positive formulae, and hence IFP is at least as expressive as
LFP. On ﬁnite structures, inﬂationary inductions reach the ﬁxed point after
a polynomial number of iterations, hence every IFP-deﬁnable class of ﬁnite
structures is decidable in polynomial time.
Proposition 3.3.46. IFP captures PTIME on ordered ﬁnite structures.

3.3 Fixed-Point Logics
175
Least Versus Inﬂationary Fixed-Points
As both logics capture PTIME, IFP and LFP are equivalent on ordered ﬁnite
structures. What about unordered structures? It was shown by Gurevich and
Shelah [63] that the equivalence of IFP and LFP holds on all ﬁnite structures.
Their proof does not work on inﬁnite structures, and indeed there are some
important aspects in which least and inﬂationary inductions behave diﬀer-
ently. For instance, there are ﬁrst-order operators (on arithmetic, say) whose
inﬂationary ﬁxed point is not deﬁnable as the least ﬁxed point of a ﬁrst-order
operator. Further, the alternation hierarchy in LFP is strict, whereas IFP has
a positive normal form (see Exercise 3.3.52 below). Hence it was conjectured
by many that IFP might be more powerful than LFP. However, Kreutzer [80]
showed recently that IFP is equivalent to LFP on arbitrary structures. Both
proofs, by Gurevich and Shelah and by Kreutzer, rely on constructions
showing that the stage comparison relations of inﬂationary inductions are
deﬁnable by lfp inductions.
Deﬁnition 3.3.47. For every inductive operator F : P(B) →P(B), with
stages Xα and an inductive ﬁxed point X∞, the F -rank of an element b ∈B
is |b|F := min{α : b ∈Xα} if b ∈X∞, and |b|F = ∞otherwise. The stage
comparison relations of G are deﬁned by
a ≤F b
iﬀ
|a|F ≤|b|F < ∞
a ≺F b
iﬀ
|a|F < |b|F .
Given a formula ϕ(R, x), we write ≤ϕ and ≺ϕ for the stage comparison
relations deﬁned by the operator Fϕ (assuming that it is indeed inductive),
and ≤inf
ϕ
and ≺inf
ϕ
for the stage comparison relations of the associated
inﬂationary operator Gϕ : R →R ∪{a : A |= ϕ(R, a)}.
Example 3.3.48. For the formula ϕ(T, x, y) := Exy ∨∃z(Exz ∧T yz) the
relation ≺ϕ on a graph (V, E) is distance comparison:
(a, b) ≺ϕ (c, d) iﬀdist(a, b) < dist(c, d).
Stage comparison theorems are results about the deﬁnability of stage
comparison relations. For instance, Moschovakis [85] proved that the stage
comparison relations ≤ϕ and ≺ϕ of any positive ﬁrst-order formula ϕ are
deﬁnable by a simultaneous induction over positive ﬁrst-order formulae. For
results on the equivalence of IFP and LFP one needs a stage comparison
theorem for IFP inductions.
We ﬁrst observe that the stage comparison relations for IFP inductions
are easily deﬁnable in IFP. For any formula ϕ(T, ¯x), the stage comparison
relation ≺inf
ϕ is deﬁned by the formula
[ifpx ≺y . ϕ[T u/u ≺x](x) ∧¬ϕ[T u/u ≺x](y)](x, y).
However, what we need to show is that the stage comparison relation for IFP
inductions is in fact LFP-deﬁnable.

176
3 Finite Model Theory and Descriptive Complexity
Theorem 3.3.49 (Inﬂationary Stage Comparison). For any formula
ϕ(R, x) in FO or LFP, the stage comparison relation ≺inf
ϕ
is deﬁnable in
LFP. On ﬁnite structures, it is even deﬁnable in positive LFP.
See [38, 63] for proofs in the case of ﬁnite structures and [80] for the more
diﬃcult construction in the general case. From this result, the equivalence of
LFP on IFP follows easily.
Theorem 3.3.50 (Kreutzer). For every IFP-formula, there is an equivalent
LFP-formula.
Proof. For any formula ϕ(R, x), [ifpRx . ϕ](x) ≡ϕ({y : y ≺inf
ϕ x}, x).
□
Stage comparison theorems also have other interesting consequences. For
instance, Moschovakis’s Theorem implies that on ﬁnite structures, greatest
ﬁxed points (i.e. negations of least ﬁxed points) can be expressed in positive
LFP. This gives a normal form for LFP and IFP (see [67]).
Theorem 3.3.51 (Immerman). On ﬁnite structures, every LFP-formula
(and hence also every IFP-formula) is equivalent to a formula in LFP1.
This result fails on inﬁnite structures. On inﬁnite structures, there exist
LFP formulae that are not equivalent to positive formulae, and in fact the
alternation hierarchy of least and greatest ﬁxed points is strict (see [20, 85]).
Exercise 3.3.52 Prove that every IFP-formula is equivalent to one that uses
ifp-operators only positively. Hint: assuming that structures contain at least
two elements and that a constant 0 is available, a formula ¬[ifpRx . ψ(R, x)]
is equivalent to an inﬂationary induction on a predicate T x y which, for
y ̸= 0, simulates the induction deﬁned by ψ, checks whether the ﬁxed point
has been reached, and then makes atoms T x0 true if x is not contained in
the ﬁxed point.
In ﬁnite model theory, owing to the Gurevich-Shelah Theorem, the two
logics LFP and IFP have often been used interchangeably. However, there are
signiﬁcant diﬀerences that are sometimes overlooked. Despite the equivalence
of IFP and LFP, inﬂationary inductions are a more powerful concept than
monotone inductions. The translation from IFP-formulae to equivalent
LFP-formulae can make the formulae much more complicated, requires an
increase in the arity of ﬁxed-point variables and, in the case of inﬁnite
structures, introduces alternations between least and greatest ﬁxed points.
Therefore it is often more convenient to use inﬂationary inductions in explicit
constructions, the advantage being that one is not restricted to inductions
over positive formulae. For an example, see the proof of Theorem 3.5.26
below. Furthermore, IFP is more robust, in the sense that inﬂationary ﬁxed
points remain well deﬁned even when other non-monotone operators (e.g.
generalized quantiﬁers) are added to the language (see, for instance, [35]).

3.3 Fixed-Point Logics
177
The diﬀerences between least and inﬂationary ﬁxed points are particularly
signiﬁcant in the context of modal logic, i.e. when we compare the modal
μ-calculus Lμ with its inﬂationary counterpart. For instance, Lμ has the
ﬁnite-model property, the satisﬁability problem is decidable (complete for
EXPTIME), the model-checking problem is in NP ∩Co-NP (and conjec-
tured by many to be solvable in polynomial time), and there are practical,
automata-based techniques for solving the algorithmic problems associated
with Lμ. Finally, in terms of expressive power, Lμ can be characterized as the
bisimulation-invariant fragment of monadic second-order logic (MSO) [69].
On the other hand, the inﬂationary counterpart of Lμ, the model iteration
calculus (MIC) [33], behaves very diﬀerently. The ﬁnite-model property
fails, the satisﬁability problem is undecidable (and not even in the arithmetic
hierarchy), the model-checking problem is PSPACE-complete, and the
expressive power goes beyond monadic second-order logic even on words.
The appropriate model-checking games for inﬂationary ﬁxed-point logics
such as IFP and MIC are backtracking games
[34]. These games are
a generalization of parity games with an additional rule allowing players,
under certain conditions, to return to an earlier position in the play and
revise a choice or to force a countback on the number of moves. This new
feature makes backtracking games more powerful so that they can capture
inﬂationary inductions. Accordingly, winning strategies become more complex
objects and computationally harder than for parity games.
3.3.9 Partial Fixed-Point Logic
Another ﬁxed-point logic that is relevant to ﬁnite structures is the
partial ﬁxed-point logic (PFP). Let ψ(R, x) be an arbitrary formula
deﬁning on a ﬁnite structure A a (not necessarily monotone) operator
Fψ : R →{a : A |= ψ(R, a)}, and consider the sequence of its ﬁnite stages
R0 := ∅, Rm+1 = Fψ(Rm).
This sequence is not necessarily increasing. Nevertheless, as A is ﬁnite,
the sequence either converges to a ﬁxed point, or reaches a cycle with a
period greater than one. We deﬁne the partial ﬁxed point of Fψ as the
ﬁxed point that is reached in the former case, and as the empty relation
otherwise. The logic PFP
is obtained by adding to ﬁrst-order logic the
partial-ﬁxed-point formation rule, which allows us to build from any
formula ψ(R, x) a formula [pfp Rx . ψ(R, x)](t), saying that t is contained in
the partial ﬁxed point of the operator Fψ.
Note that if R occurs only positively in ψ, then
[lfp Rx . ψ(R, x)](t) ≡[pfp Rx . ψ(R, x)](t),
so we have that LFP ≤PFP. However, PFP seems to be much more powerful
than LFP. For instance, while a least-ﬁxed-point induction on ﬁnite struc-
tures always reaches the ﬁxed point in a polynomial number of iterations, a
partial-ﬁxed-point induction may need an exponential number of stages.

178
3 Finite Model Theory and Descriptive Complexity
Example 3.3.53. Consider the sequence of stages Rm deﬁned by the formula
ψ(R, x) :=

Rx ∧∃y(y < x ∧¬Ry)

∨

¬Rx ∧∀y(y < x →Ry)

∨∀yRy
on a ﬁnite linear order (A, <). It is easily seen than the ﬁxed point reached
by this induction is the set R = A, but before this ﬁxed point is reached,
the induction goes in lexicographic order through all possible subsets of A.
Hence the ﬁxed point is reached at stage 2n −1, where n = |A|.
Simultaneous Inductions.
As in the case of LFP, one can also extend IFP and PFP by simultaneous
inductions over several formulae, but again, the simultaneous ﬁxed-point
logics S-IFP and S-PFP are not more expressive than their simple variants.
However, the proof is a little diﬀerent than in the case of LFP. It requires
that one encodes several relations into one and hence increases the arity of
the ﬁxed point variables. As a consequence, it seems to be unknown whether
simultaneous monadic PFP collapses to simple monadic PFP.
Complexity
Although a PFP induction on a ﬁnite structure may go through exponentially
many stages (with respect to the cardinality of the structure), each stage can
be represented with polynomial storage space. As ﬁrst-order formulae can be
evaluated eﬃciently, it follows by a simple induction that PFP-formulae can
be evaluated in polynomial space.
Proposition 3.3.54. For every formula ψ ∈PFP, the set of ﬁnite models of
ψ is in PSPACE; in short: PFP ⊆PSPACE.
On ordered structures, one can use techniques similar to those used in pre-
vious capturing results, to simulate polynomial-space-bounded computation
by PFP-formulae [2, 99].
Theorem 3.3.55 (Abiteboul, Vianu, and Vardi). On ordered ﬁnite
structures, PFPcaptures PSPACE.
Proof. It remains to prove that every class K of ﬁnite ordered structures that
is recognizable in PSPACE, can be deﬁned by a PFP-formula.
Let M be a polynomially space-bounded deterministic Turing machine
with state set Q and alphabet Σ, recognizing (an encoding of) an ordered
structure (A, <) if and only if (A, <) ∈K. Without loss of generality, we can
make the following assumptions. For input structures of cardinality n, M
requires space less than nk−2, for some ﬁxed k. For any conﬁguration C of M,
let Next(C) denote its successor conﬁguration. The transition function of M is
adjusted so that Next(C) = C if, and only if, C is an accepting conﬁguration.

3.3 Fixed-Point Logics
179
We
represent
any
conﬁguration
of
M
with
a
current
state
q,
tape
inscription
w1 · · · wm,
and
head
position
i,
by
the
word
#w1 · · · wi−1(qwi)wi+1 · · · wm−1# over the alphabet Γ := Σ ∪(Q×Σ)∪{#},
where m = nk and # is merely used as an end marker to make the following
description more uniform. When moving from one conﬁguration to the next,
Turing machines make only local changes. We can therefore associate with
M a function f : Γ 3 →Γ such that, for any conﬁguration C = c0 · · · cm, the
successor conﬁguration Next(C) = c′
0 · · · c′
m is determined by the rules
c′
0 = c′
m = #
and
c′
i = f(ci−1, ci, ci+1) for 1 ≤i ≤m −1.
Recall that we encode structures so that there exist ﬁrst-order formulae
βσ(y) such that (A, <) |= βσ(a) if and only the ath symbol of the input con-
ﬁguration of M for input code(A, <) is σ. We now represent any conﬁguration
C in the computation of M by a tuple C = (Cσ)σ∈Γ of k-ary relations, where
Cσ := {a : the a-th symbol of C is σ}.
The conﬁguration at time t is the stage t + 1 of a simultaneous pfp
induction on (A, <), deﬁned by the rules
C#y :=∀z(y ≤z) ∨∀z(z ≤y)
and, for all σ ∈Γ −{#},
Cσy :=

βσ(y) ∧
	
γ∈Γ
∀x¬Cγx

∨
∃x∃z

x + 1 = y ∧y + 1 = z ∧

f(α,β,γ)=σ
Cαx ∧Cβy ∧Cγz)

The ﬁrst rule just says that each stage represents a word starting and ending
with #. The other rules ensure that (1) if the given sequence C contains only
empty relations (i.e. if we are at stage 0), then the next stage represents the
input conﬁguration, and (2) if the given sequence represents a conﬁguration,
then the following stage represents its successor conﬁguration.
By our convention, M accepts its input if and only the sequence of
conﬁgurations becomes stationary (i.e. reaches a ﬁxed point). Hence M
accepts code(A, <) if and only if the relations deﬁned by the simultaneous
pfp induction on A of the rules described above are non-empty. Hence K is
PFP-deﬁnable.
□
An alternative characterization of PSPACE is possible in terms of the
database query language while consisting essentially of ﬁrst-order relational
updates and while-loops. Vardi [99] proved that while captures PSPACE on
ordered ﬁnite structures and Abiteboul and Vianu proved that while and
PFP are equivalent on ﬁnite structures.

180
3 Finite Model Theory and Descriptive Complexity
Least Versus Partial Fixed-Point Logic
From the capturing results for PTIME and PSPACE we immediately obtain
the result that PTIME = PSPACE if, and only if, LFP = PFP on ordered
ﬁnite structures. The natural question arises of whether LFP and PFP
can be separated on the domain of all ﬁnite structures. For a number of
logics, separation results on arbitrary ﬁnite structures can be established by
relatively simple methods, even if the corresponding separation on ordered
structures would solve a major open problem in complexity theory. For
instance, we have proved by quite a simple argument that DTC ⊊TC,
and it is also not very diﬃcult to show that TC ⊊LFP (indeed, TC is
contained in stratiﬁed Datalog, which is also strictly contained in LFP; see
Sect. 3.3.10). Further, it is trivial that LFP is less expressive than Σ1
1 on all
ﬁnite structures. However the situation is diﬀerent for LFP vs. PFP.
Theorem 3.3.56 (Abiteboul and Vianu). LFP and PFP are equivalent
on ﬁnite structures if, and only if, PTIME = PSPACE.
3.3.10 Datalog and Stratiﬁed Datalog
Datalog and its extensions are a family of rule-based database query languages
that extend the conjunctive queries by a relational recursion mechanism
similar to the one used in ﬁxed-point logics. Indeed, as we shall see, Datalog
can be seen as a fragment of least ﬁxed point logic. For the purpose of
this section we simply identify a relational database with a ﬁnite relational
structure. This is not adequate for all aspects of database theory, but for
the questions considered here it is appropriate. For further information on
databases, see [1], for example.
Deﬁnition 3.3.57. A
Datalog
rule
is
an
expression
of
the
form
H ←B1 ∧· · · ∧Bm, where H, the head of the rule, is an atomic for-
mula Ru, and B1 ∧· · · ∧Bm, the body of the rule, is a conjunction of
literals (i.e. atoms or negated atoms) of the form Sv or ¬Sv where u, v are
tuples of variables or constants. The relation symbol R is called the head
predicate of the rule. We also allow Boolean head predicates. A Datalog
rule is positive if it does not contain negative literals.
A Datalog program Π is a ﬁnite collection of rules such that none of its
head predicates occurs negated in the body of any rule. The predicates that
appear only in the bodies of the rules are called input predicates. The input
vocabulary of Π is the set of input predicates and constants appearing in Π.
Example 3.3.58. The Datalog program Πreach consists of the three rules
T xy ←Exy,
T xz ←T xy ∧T yz,
Ry ←T ay.
The input vocabulary is {E, a}, and the head predicates are T and R.

3.3 Fixed-Point Logics
181
Given a structure A over the input vocabulary, the program com-
putes an interpretation of the head predicates, i.e. it deﬁnes an expansion
Π(A) := (A, R1, . . . , Rk) of A, where the Ri are the values of the head predi-
cates as computed by Π. This interpretation can be deﬁned in several equiva-
lent ways, for instance via minimal-model semantics or ﬁxed-point semantics.
We can read a Datalog rule ϕr := Rx ←B1 ∧· · · ∧Bm, and associate with
the program Π the universal closure of the conjunction over these formulae:
ψ[Π] := ∀z
	
ϕr∈Π
ϕr.
We can compare expansions of A by componentwise inclusion of the addi-
tional predicates: (A, R1, . . . , Rk) ⊆(A, R′
1. . . . , R′
k) if Ri ⊆R′
i for all i.
Acording to the minimal-model semantics, Π(A) is the minimal expansion
(A, Rμ
1, . . . , Rμ
k) that satisﬁes ψ[Π].
Example 3.3.59. The
formula
associated
with
the
program
Πreach
of
Example 3.3.58 is
∀x∀y∀z((T xy ←Exy) ∧(T xz ←T xy ∧T yz) ∧(Ry ←T ay)).
The minimal expansion of a graph G = (V, E) with a distinguished node
a is Πreach(G, a) = (G, a, T, R) where T is the transitive closure of E and R
is the set of points reachable by a path from a.
Exercise 3.3.60 Prove that minimal-model semantics is well-deﬁned: for
every Datalog program Π and every input database A, there is a unique
minimal expansion of A that is a model of ψ[Π].
For the case of ﬁxed-point semantics, we read a rule Rx ←β(x, y)
as an update operator: whenever an instantiation β(a, b) of the body of the
rule is true for the current interpretation of the head predicates, make the
corresponding instantiation Ra of the head true. Initially, let all head pred-
icates be empty. At each stage, apply simultaneously the update operators
for all rules of the program to the current interpretation of (R1, . . . , Rk).
Iterate this operation until a ﬁxed point (R∞
1 , . . . , R∞
k ) is reached. Now let
Π(A) := (A, R∞
1 , . . . , R∞
k ).
Exercise 3.3.61 Prove
that
minimal-model
semantics
and
ﬁxed-point
semantics coincide: for all Π and A, (Rμ
1, . . . , Rμ
k) = (R∞
1 , . . . , R∞
k ).
Deﬁnition 3.3.62. A Datalog query is a pair (Π, R) consisting of a
Datalog program Π and a designated head predicate R of Π. With every
structure A, the query (Π, R) associates the result (Π, R)A, the interpretation
of R as computed by Π from the input A.
We now relate Datalog to LFP. We shall show that each Datalog query
(Π, R) is equivalent to a formula ψ(x) ∈LFP, in fact one of very special form.

182
3 Finite Model Theory and Descriptive Complexity
Let Π be a Datalog program with input vocabulary τ
and head
predicates R1, . . . , Rk. We ﬁrst normalize the rules such that all rules
with head predicate Ri have the same head Rix1 · · · xki. This can be
done
by
appropriate substitutions
in
the
rule
body
and
by
adding
equalities. For instance, a rule Rxyyx ←β(x, y, z) can be rewritten as
Rx1x2x3x4 ←β(x1, x2, y) ∧x3 = x2 ∧x4 = x1. We then have a program
containing, for each head predicate Ri, rules rij of the form Rix ←βij(x, y),
where βij is a conjunction of literals and equalities. We then combine the
update operators associated with the same head predicate and describe the
update of Ri by the existential ﬁrst-order formula γi(x) := 
j ∃yβij(x, y). As
a consequence, the ﬁxed-point semantics of Π is described by the system
S :=
⎧
⎪
⎨
⎪
⎩
R1x := γ1
...
Rkx := γk
of ﬁrst-order update rules, and the query (Π, Ri) is equivalent to the formula
[lfpRi : S](x). Hence every Datalog query is equivalent to an LFP-formula,
in which ﬁxed-point operators are applied only to existential formulae.
Deﬁnition 3.3.63. Existential ﬁxed-point logic, denoted EFP, is the set
of (simultaneous) LFP-formulae without universal quantiﬁers and without
gfp-operators, and where negations are applied to atomic formulae only.
We have seen that Datalog ⊆EFP. The converse is also true, which can be
established by a straightforward induction: with every formula ψ ∈EFP one
associates a Datalog program Πψ with a distinguished head predicate Hψ such
that the query (Πψ, Hψ) is equivalent to ψ. We leave the details as an exercise.
Proposition 3.3.64. Datalog is equivalent to EFP.
We know that LFP captures PTIME on ordered ﬁnite structures. The
question arises of whether Datalog is suﬃciently powerful to do the same.
The answer depends on the precise variant of Datalog and on the notion of
ordered structures that is used. We distinguish three cases.
(1) A simple monotonicity argument shows that Datalog is weaker than
PTIME on structures where only a linear order, but not a successor relation, is
given. If A is a substructure of B, then (Π, R)A ⊆(Π, R)B for every Datalog
query (Π, R). Of course, there even exist very simple ﬁrst-order queries that
are not monotone in this sense. Note that this argument does break down on
databases where a successor relation S (rather than just a linear order), and
constants 0 and e for the ﬁrst and last elements are given. Exercise: why?
(2) In the literature, Datalog programs are often required to contain only
positive rules, i.e. the input predicates also can be used only positively. This
restricted variant is too weak to capture PTIME, even on successor structures.
If input predicates can be used only positively, then queries are monotone
under extensions of the input relations: if a database B is obtained from A
by augmenting some of the input relations, then again (Π, R)A ⊆(Π, R)B.

3.3 Fixed-Point Logics
183
Exercise 3.3.65 Prove this monotonocity property, and give examples of
ﬁrst-order queries that cannot be deﬁned by Datalog programs.
(3) In the case of programs with negations of input predicates and
databases with a successor relation and constants 0 and e for the ﬁrst
and last elements, we can capture PTIME by Datalog. This was originally
established in [13, 91] and is implicit also in [67].
Theorem 3.3.66 (Blass, Gurevich, and Papadimitriou). On successor
structures, Datalog (with negations of input predicates) captures PTIME.
Proof. This result can be established in several ways, for instance by a
reduction from Σ1
1-HORN (making use of the fact that PTIME is closed
under complement). Instead, we give a direct proof.
It is clear that Datalog queries are computable in polynomial time. It
remains to prove that every class K of ﬁnite successor structures that is
recognizable in PTIME can be deﬁned by a Boolean Datalog query.
Let M be a polynomial-time Turing machine with state set Q and
alphabet Σ, recognizing (an encoding of) a successor structure A if and only
if A ∈K. We denote the cardinality of the input structure A by n and assume
that the computation time of M on A is less than nk.
The construction is similar to the proof of Theorem 3.3.55. Conﬁgurations
of M are represented by words #w1 · · · wi−1(qwi)wi+1 · · · wm−1# over the
alphabet Γ := Σ∪(Q×Σ)∪{#}, where m = nk, and we describe the behaviour
of M by a function f : Γ 3 →Γ such that, for any conﬁguration C = c0 · · · cm,
the successor conﬁguration Next(C) = c′
0 · · · c′
m is determined by the rules
c′
0 = c′
m = #
and
c′
i = f(ci−1, ci, ci+1) for 1 ≤i ≤m −1.
Let S be a 2k-ary relation symbol and let ΠS be a Datalog program with
head predicate S, computing the successor relation on k-tuples (associated
with the lexicographic order deﬁned by the given successor relation). Recall
that we can encode successor structures so that there exist quantiﬁer-free
formulae βσ(y) such that A |= βσ(a) if, and only if, the ath symbol of the
input conﬁguration of M for code(A) is σ. Let (Πσ, Hσ) be a Datalog query
equivalent to βσ(y).
We represent the computation of M by a tuple C = (Cσ)σ∈Γ of 2k-ary
relations, where
Cσ := {(a, t) : the ath symbol of the conﬁguration at time t is σ}.
The Datalog program associated with M consists of
(1) the program ΠS deﬁning the successor relation on k-tuples;
(2) the programs Πσ for describing the input;

184
3 Finite Model Theory and Descriptive Complexity
(3) the rules
C#0 t
C#e t
Cσy 0 ←Hσy for all σ ∈Γ −{#};
(4) for all α, β, γ, σ with f(α, β, γ) = σ, the rule
Cσy t
′ ←Sx y ∧Sy z ∧St t
′ ∧Cαxt ∧Cβy t ∧Cγz t;
(5) the rule
Acc ←Cqwx t
for any accepting state q and any symbol w.
The ﬁrst two rules in (3) say that each conﬁguration starts and ends
with #; the following set of rules ensures that the conﬁguration at time 0
is the input conﬁguration. The rules in (4) imply that from time t to time
t
′ = t + 1 the computation proceeds as required by M, and the last rule
makes the Boolean predicate Acc true if and only if an accepting state has
been reached. Obviously, M accepts the input structure A if, and only if, the
query (ΠM, Acc) evaluates to true on A.
□
Almost the same proof shows that the expression complexity of Datalog
(and hence of LFP) is EXPTIME-complete (see also Theorem 3.3.36).
Theorem 3.3.67. The evaluation problem for Datalog programs (with head
predicates of unbounded arity) is complete for EXPTIME, even for programs
with only positive rules, and for a ﬁxed database with only two elements.
Proof. By the results of Section 3.3.5, LFP-formulae, and hence also Datalog
programs, can be evaluated in polynomial time with respect to the size of
the input structure and in exponential time with respect to the length of the
formula (or program).
To prove completeness, we ﬁx a database A with two elements and constant
symbols 0, 1 (or, alternatively, two unary relations P0 = {0} and P1 = {1}).
Let M be a deterministic Turing machine that accepts or rejects input words
w = w0 · · · wm−1 ∈{0, 1}∗in time 2md (for some ﬁxed d). For every input x
for M, we construct a Datalog program ΠM,w which evaluates, on the ﬁxed
database A, a Boolean head predicate Acc to true if, and only if, M accepts w.
The construction is similar to that in the proof of Theorem 3.3.66, with
the following two diﬀerences. Whereas in the previous proof k was ﬁxed and
n depended on the input, it is now the other way round, with n := 2 and
k := md. Further, the description of the input conﬁguration is now simpler:
we just explicitly list the atomic facts deﬁning the input conﬁguration for the
given input w. Note that this is the only part of the program that depends
on w; the remaining rules depend only on M and the length of the input.
Finally note that the program contains only positive rules.
□

3.3 Fixed-Point Logics
185
Stratiﬁed Datalog
Datalog deﬁnes in a natural way queries that require recursion (such as
transitive closure), but is very weak in other respects, mainly because it does
not include negation.
There exist various possible ways to add negation to Datalog.
Deﬁnition 3.3.68. A
stratiﬁed
Datalog
program
is
a
sequence
Π
=
(Π0, . . . , Πr) of basic Datalog programs, which are called the
strata of Π, such that each of the head predicates of Π is a head predicate
in precisely one stratum Πi and is used as an input predicate only in higher
strata Πj, where j > i. In particular, this means that
(1) if a head predicate of stratum Πj occurs positively in the body of a rule
of stratum Πi, then j ≤i, and
(2) if a head predicate of stratum Πj occurs negatively in the body of a rule
of stratum Πi, then j < i.
The semantics of a stratiﬁed program is deﬁned stratum by stratum.
The input predicates of a stratum Πi are either input predicates of the
entire program Π or are head predicates of a lower stratum. Hence, once the
lower strata are evaluated, we can compute the interpretation of the head
predicates of Πi as in the case of basic Datalog programs.
Clearly the power of stratiﬁed Datalog is between that of Datalog and
LFP, and hence stratiﬁed Datalog provides yet another formalism that
captures PTIME on ordered structures. On unordered structures stratiﬁed
Datalog is strictly more expressive than Datalog (as it includes all of
ﬁrst-order logic) but strictly less powerful than LFP. The main example
separating LFP from Stratiﬁed Datalog is the Game query, which deﬁnes
the winning positions of Player 0 in a strictly alternating game. It is deﬁned
by the LFP formula [lfpWx . ∃y(Exy ∧∀z(Eyz →Wz)](x). This involves a
recursion through a universal quantiﬁer, which in general cannot be done in
stratiﬁed Datalog [31, 79].
Theorem 3.3.69 (Dahlhaus and Kolaitis). No stratiﬁed Datalog program
can express the Game query. Hence stratiﬁed Datalog ⊊LFP.
Example 3.3.70. Another interesting class of examples showing the limits
of stratiﬁed Datalog is that of well-foundedness properties, or statements
saying that on all inﬁnite paths one will eventually hit a node with a certain
property P. These are typical statements in the ﬁeld of veriﬁcation (expressed
in CTL by the formula AFP).
In LFP, the well-foundedness of a partial order ≺would be expressed as
∀y[lfpWy . ∀x(x ≺y →Wx)](y). The CTL-formula AFP is expressed in Lμ
by μX.P ∨2X and in LFP by [lfpRx . Px ∨∀y(Exy →Ry)](x).
On ﬁnite structures, such properties are deﬁnable by stratiﬁed Datalog
programs, since they are essentially negations of reachability problems for

186
3 Finite Model Theory and Descriptive Complexity
cycles. Indeed, AFP means that there is no path that eventually cycles and
on which P is globally false. This can be expressed by the following stratiﬁed
program:
T xy ←¬Px ∧Exy ∧¬Py
T xz ←T xy ∧Eyz ∧¬Pz
Sx ←T xx
Sx ←¬Px ∧Exy ∧Sy
Rx ←¬Sx
The ﬁrst stratum computes the set T of all pairs of nodes (u, v) such that
there exists a path from u to v on which P is false, and the set S of all nodes
from which there exists such a path that eventually cycles. Here the ﬁniteness
of the graph is used in an essential way, because only this guarantees that
every inﬁnite path eventually reaches a cycle. The second stratum takes the
complement of S.
However, it can be shown that no stratiﬁed Datalog program can express
such statements on inﬁnite structures (even countable ones).
Another variant of Datalog, called Datalog LITE, which can express all
CTL properties and moreover admits linear-time evaluation algorithms (and
which is incomparable with stratiﬁed Datalog), has been deﬁned and studied
in [45].
A stratiﬁed Datalog program is linear if in the body of each rule there is
at most one occurrence of a head predicate of the same stratum (but there
may be arbitrary many occurrences of head predicates from lower strata).
Example 3.3.71. The program Πreach in Example 3.3.58 is not linear, but by
replacing the second, non-linear rule T xz ←T xy ∧T yz by the linear rule
T xz ←T xy ∧Eyz we obtain an equivalent linear program. However, one
pays a price for the linearization. The original program reaches the ﬁxed
point after O(log m) iterations, while the linear program needs m iterations,
where m is the length of the longest path in the graph.
Linear programs suﬃce to deﬁne transitive closures, so it follows by a
straightforward induction that TC ⊆linear stratiﬁed Datalog. The converse
is also true (see [38, 46]).
Proposition 3.3.72. Linear stratiﬁed Datalog is equivalent to TC.
Corollary 3.3.73. On ordered structures, linear stratiﬁed Datalog captures
NLOGSPACE.
3.4 Logics with Counting
From the point of view of expressiveness, ﬁrst-order logic has two main
deﬁciencies: it lacks the power to express anything that requires recursion
(the simplest example is transitive closure) and it cannot count, as witnessed

3.4 Logics with Counting
187
by the impossibility to express that a structure has even cardinality, or,
more generally, by the 0-1 law. We have already discussed a number of logics
that add recursion in one way or another to FO (or part of it), notably the
various forms of ﬁxed-point logic. On ordered ﬁnite structures, some of these
logics can express precisely the queries that are computable in PTIME or
PSPACE. However, on arbitrary ﬁnite structures they do not, and almost all
known examples showing this involve counting. Whereas in the presence of
an ordering, the ability to count is inherent in ﬁxed-point logic, hardly any
of this ability is retained in its absence. For instance, as LFP and PFP are
fragments of Lω
∞ω, the 0-1 law also holds for them.
Therefore Immerman proposed that counting quantiﬁers should be
added to logics and asked whether a suitable variant of ﬁxed-point logic
with counting would suﬃce to capture PTIME. Although Cai, F¨urer and
Immerman [23] eventually answered this question negatively, ﬁxed-point
logic with counting has turned out to be an important and robust logic, that
deﬁnes a natural level of expressiveness and allows one to capture PTIME
on interesting classes of structures.
3.4.1 Logics with Counting Terms
There are diﬀerent ways of adding counting mechanisms to a logic, which
are not necessarily equivalent. The most straightforward possibility is the
addition of quantiﬁers of the form ∃≥2, ∃≥3, etc., with the obvious meaning.
While this is perfectly reasonable for bounded-variable fragments of ﬁrst-
order logic or inﬁnitary logic (see e.g. [58, 89]), it is not general enough for
ﬁxed-point logic, because it does not allow for recursion over the counting
parameters i in quantiﬁers ∃≥ix. In fact, if the counting parameters are ﬁxed
numbers, then adjoining the quantiﬁers ∃≥ix does not give additional power
to logics such as FO or LFP, since they are closed under the replacement
of ∃≥i by i existential quantiﬁers (where as their restrictions to bounded
width are not). These counting parameters should therefore be considered
as variables that range over natural numbers. To deﬁne in a precise way a
logic with counting and recursion, one extends the original objects of study,
namely ﬁnite (one-sorted) structures A, to two-sorted auxiliary structures A∗
with a second numerical (but also ﬁnite) sort.
Deﬁnition 3.4.1. With any one-sorted ﬁnite structure A with universe A,
we associate the two-sorted structure A∗:= A ˙∪⟨{0, . . . , |A|}; ≤, 0, e⟩, where
≤is the canonical ordering on {0, . . ., |A|}, and 0 and e stand for the ﬁrst
and the last element. Thus, we have taken the disjoint union of A with a
linear order of length |A| + 1.
We start with ﬁrst-order logic over two-sorted vocabularies σ ∪{≤, 0, e},
with semantics over structures A∗deﬁned in the obvious way. We shall use
Latin letters x, y, z, . . . for the variables over the ﬁrst sort, and Greek letters
λ, μ, ν, . . . for variables over the second sort. The two sorts are related by

188
3 Finite Model Theory and Descriptive Complexity
counting terms, deﬁned by the following rule. Let ϕ(x) be a formula with a
variable x (over the ﬁrst sort) among its free variables. Then #x[ϕ] is a term
in the second sort, with the set of free variables free(#x[ϕ]) = free(ϕ) −{x}.
The value of #x[ϕ] is the number of elements a that satisfy ϕ(a).
Counting logics of this form were introduced by Gr¨adel and Otto [54]
and have been studied in detail in [89]. We start with ﬁrst-order logic with
counting, denoted by (FO + C), which is the closure of two-sorted ﬁrst-order
logic under counting terms. Here are two simple examples that illustrate the
use of counting terms.
Example 3.4.2. On
a
undirected
graph
G
=
(V, E),
the
formula
∀x∀y(#z[Exz] = #z[Eyz]) expresses the assertion that every node has
the same degree, i.e., that G is regular.
Example 3.4.3. We present below a formula ψ(E1, E2) ∈(FO + C) which
expresses the assertion that two equivalence relations E1 and E2 are isomor-
phic; of course a necessary and suﬃcient condition for this is that for every
i, they have the same number of elements in equivalence classes of size i:
ψ(E1, E2) ≡(∀μ)(#x[#y[E1xy] = μ] = #x[#y[E2xy] = μ]).
3.4.2 Fixed-Point Logic with Counting
We now deﬁne (inﬂationary) ﬁxed point logic with counting (IFP +
C) and partial ﬁxed point logic with counting (PFP + C) by adding
to (FO + C) the usual rules for building inﬂationary or partial ﬁxed points,
ranging over both sorts.
Deﬁnition 3.4.4. Inﬂationary ﬁxed point logic with counting, (IFP + C), is
the closure of two-sorted ﬁrst-order logic under the following rules:
(1) The rule for building counting terms.
(2) The usual rules of ﬁrst-order logic for building terms and formulae.
(3) The ﬁxed-point formation rule. Suppose that ψ(R, x, μ) is a formula of
vocabulary τ ∪{R} where x = x1, . . . , xk, μ = μ1, . . . , μℓ, and R has
mixed arity (k, ℓ), and that (u, ν) is a k +ℓ-tuple of ﬁrst- and second-sort
terms, respectively. Then
[ifp Rxμ . ψ](u, ν)
is a formula of vocabulary τ.
The semantics of [ifp Rxμ . ψ] on A∗is deﬁned in the same way as for
the logic IFP, namely as the inﬂationary ﬁxed point of the operator
Fψ : R −→R ∪{(a, i) | (A∗, R) |= ψ(a, i)}.

3.4 Logics with Counting
189
The deﬁnition of (PFP + C) is analogous, where we replace inﬂationary
ﬁxed points by partial ones. In the literature, one also ﬁnds diﬀerent variants
of ﬁxed-point logic with counting where the two sorts are related by counting
quantiﬁers rather than counting terms. Counting quantiﬁers have the form
(∃i x) for ‘there exist at least i x’, where i is a second-sort variable. It is
obvious that the two deﬁnitions are equivalent. In fact, (IFP + C) is a very
robust logic. For instance, its expressive power does not change if one permits
counting over tuples, even of mixed type, i.e. terms of the form #x,μϕ. One
can of course also deﬁne least ﬁxed-point logic with counting, (LFP + C),
but one has to be careful with the positivity requirement (which is more
natural when one uses counting quantiﬁers rather than counting terms). The
equivalence of LFP and IFP readily translates to (LFP + C) ≡(IFP + C).
Further, there are a number of other logical formalizations of the concept of
inductive deﬁnability with counting that turn out to have the same expressive
power as (IFP + C) (see [54] and Sect.3.4.3 below for details).
Example 3.4.5. An interesting example of an (IFP + C)-deﬁnable query is the
method of stable colourings for graph-canonization. Given a graph G with a
colouring f : V →0, . . . , r of its vertices, we deﬁne a reﬁnement f ′ of f, giving
to a vertex x the new colour f ′x = (fx, n1, . . . , nr) where ni = #y[Exy∧(fy =
i)]. The new colours can be sorted lexicographically so that they again form
an initial subset of N. Then the process can be iterated until a ﬁxed point, the
stable colouring of G is reached. It is easy to see that the stable colouring of a
graph is polynomial-time computable and uniformly deﬁnable in (IFP + C).
On many graphs, the stable colouring uniquely identiﬁes each vertex,
i.e. no two distinct vertices get the same stable colour. This is the case, for
instance, for all trees. Further, Babai, Erd¨os, and Selkow [8] proved that the
probability that this happens on a random graph with n nodes approaches 1
as n goes to inﬁnity. Thus stable colourings provide a polynomial-time graph
canonization algorithm for almost all ﬁnite graphs.
We now discuss the expressive power and evaluation complexity of ﬁxed-
point logic with counting. We are mainly interested in (IFP + C)-formulae
and (PFP + C)-formulae without free variables over the second sort, so that
we can compare them with the usual logics without counting.
Exercise 3.4.6 Even without making use of counting terms, IFP over two-
sorted structures A∗is more expressive than IFP over A. To prove this, con-
struct a two-sorted IFP-sentence ψ such that A∗|= ψ if, and only if, |A| is even.
It is clear that counting terms can be computed in polynomial-time.
Hence the data complexity remains in PTIME for (IFP + C) and in PSPACE
for (PFP + C). We shall see below that these inclusions are strict.
Theorem 3.4.7. On ﬁnite structures,
(1) IFP ⊊(IFP + C) ⊊PTIME.
(2) PFP ⊊(PFP + C) ⊊PSPACE.

190
3 Finite Model Theory and Descriptive Complexity
Inﬁnitary Logic with Counting
Let Ck
∞ω be the inﬁnitary logic with k variables Lk
∞ω, extended by the quanti-
ﬁers ∃≥m (‘there exist at least m’) for all m ∈N. Further, let Cω
∞ω := 
k Ck
∞ω.
Proposition 3.4.8. (IFP + C) ⊆Cω
∞ω.
Due to the two-sorted framework, the proof of this result is a bit more
involved than for the corresponding result without counting, but not really
diﬃcult. We refer to [54, 89] for details.
The separation of (IFP + C) from PTIME has been established by Cai,
F¨urer, and Immerman [23]. The proof also provides an analysis of the method
of stable colourings for graph canonization. We have deswcribed this method
in its simplest form in Example 3.4.5. More sophisticated variants compute
and reﬁne colourings of k-tuples of vertices. This is called the k-dimensional
Weisfeiler–Lehman method and, in logical terms, it amounts to labelling
each k-tuple by its type in k + 1-variable logic with counting quantiﬁers. It
was conjectured that this method could provide a polynomial-time algorithm
for graph isomorphism, at least for graphs of bounded degree. However,
Cai, F¨urer, and Immerman were able to construct two families (Gn)n∈N and
(Hn)n∈N of graphs such that on one hand, Gn and Hn have O(n) nodes and
degree three, and admit a linear-time canonization algorithm, but on the
other hand, in ﬁrst-order (or inﬁnitary) logic with counting, Ω(n) variables
are necessary to distinguish between Gn and Hn. In particular, this implies
Theorem 3.4.7.
Inﬂationary vs. Partial Fixed-Points
By Theorem 3.3.56, partial ﬁxed-point logic collapses to inﬂationary ﬁxed-
point logic if, and only if, PTIME = PSPACE. The analogous result in the
presence of counting is also true [54, 89]: PTIME = PSPACE ⇐⇒(IFP + C)
= (PFP + C).
3.4.3 Datalog with Counting
Fixed-point formulae have the reputation of being diﬃcult to read, and many
people ﬁnd formalisms such as Datalog easier to understand. In the presence
of a successor relation, Datalog (with negation over input predicates) is
suﬃcient to capture PTIME and hence is equally expressive as LFP. In
general, however, Datalog and even its most natural extensions, notably
stratiﬁed Datalog, are weaker than LFP.
Counting terms can also be added to Datalog. We conclude this section
by discussing Datalog with counting. We show that (Datalog + C) is closed
under negation and equivalent to (IFP + C). In the presence of counting,
the common extensions of Datalog, notably stratiﬁed Datalog, are therefore
equivalent to Datalog.

3.4 Logics with Counting
191
Deﬁnition 3.4.9. Datalog with counting, denoted by (Datalog + C),
extends Datalog by allowing two-sorted head predicates and counting terms.
The two-sorted head atoms have the form Rxμ, where x ranges over the ﬁrst
sort, i.e. over elements of the input database A, and μ ranges over the second
sort. For any atom Rxyμ we have a counting term #x[Rxyμ]. A term over
the second sort is called an arithmetical term. The arithmetical terms are
either 0, e, counting terms, or t + 1, where t is also an arithmetical term.
Thus, a program in (Datalog + C) is a ﬁnite set of clauses of the form
H ←B1 ∧· · · ∧Bm
where the head H is an atomic formula R(x, μ), and B1, . . . , Bm are atomic
formulae Rxμ or equalities of terms (over the ﬁrst or the second sort).
For every input database, the program computes intensional relations
via the inﬂationary ﬁxed-point semantics. Note that for classical Datalog
programs, it makes no diﬀerence whether the ﬁxed-point semantics is deﬁned
to be inﬂationary or not, since the underlying operator is monotone anyway.
However, for programs in (Datalog + C), the semantics has to be inﬂationary,
since otherwise, the equalities of arithmetical terms give rise to non-monotone
operators. For the same reason, the minimum-model semantics will no longer
be deﬁned. Since inﬂationary ﬁxed-point semantics is one of the various
equivalent ways to deﬁne the semantics of Datalog, both the syntax and the
semantics of (Datalog + C) generalize Datalog in a natural way.
One could also introduce counting in an (at ﬁrst sight) more general form,
namely by allowing counting terms of the form #x,μ[Rxμyν]. While this may
be convenient for writing a program in shorter and more understandable
form, it does not aﬀect the power of (Datalog + C).
Exercise 3.4.10
[54] Prove that counting over tuples, even of mixed type,
does not increase the expressive power of (Datalog + C).
Hence cardinalities of arbitrary predicates can be equated in a Datalog
program: we take the liberty of writing equalities such as |Q| = |R| in the
body of a rule, for simplicity. The following technical lemma is essential for
reducing (IFP + C) to (Datalog + C).
Lemma 3.4.11. Let Π be a (Datalog + C) program with head predicates
Q1, . . . , Qr. There exists another (Datalog + C) program Π′, whose head
predicates include Q1, . . . , Qr and a Boolean control predicate C∗such that
•
(Π′, Qi) = (Π, Qi) for all i;
•
(Π′, C∗) is true on all databases and C∗becomes true only at the last
stage of the evaluation of Π′.
Proof. In addition to C∗, we add a unary head predicate C0 and, for every
head predicate Qi of Π a new head predicate Q′
i of the same arity. Then, Π′
is obtained by adding the following clauses to Π:

192
3 Finite Model Theory and Descriptive Complexity
C0x
Q′
ixμ ←Qixμ
for 1 ≤i ≤r
C∗←C0x ∧(|Q1| = |Q′
1|) ∧· · · ∧(|Qr| = |Q′
r|)
Observe that Q′
i simply lags one step behind Qi. The atom C0x is necessary
to avoid the possibility that C∗is set to true in the ﬁrst stage.
□
Lemma 3.4.11 essentially says that we can attach to any program a
Boolean control predicate which becomes true when the evaluation of the
program is terminated. We can then compose two Datalog programs while
making sure that the evaluation of the second program starts only after
the ﬁrst has been terminated. As an initial application, we shall show that
(Datalog + C) is closed under negation.
Lemma 3.4.12. The complement of a (Datalog + C) query is also a
(Datalog + C) query.
Proof. Let (Π, Q) be a (Datalog + C) query, and let Π′ be the program
speciﬁed in Lemma 3.4.11. Take a new variable z, and new head predicates
˜Q and R with arity(R) = arity(Q) and arity( ˜Q) = arity(Q) + 1. Construct
Π′′ by adding to Π′ the rules
˜Qxμz ←Qxμ
Rxμ ←C∗∧(#z[ ˜Qxμz] = 0).
The query (Π′′, R) is the complement of (Π, Q).
□
Diﬃculties in expressing negation are the reason why, in the absence of
counting (or of an ordering), Datalog is weaker than ﬁxed-point logic. Also,
the limited form of negation that is available in Stratiﬁed Datalog (which
does not allow for ‘recursion through negation’) does not suﬃce to express
all ﬁxed-point queries. (Datalog + C) does not have these limitations, and is
equally expressive as (IFP + C).
Theorem 3.4.13 (Gr¨adel and Otto). (Datalog + C) ≡(IFP + C).
It is obvious that (Datalog + C) ⊆(IFP + C). For the converse, we can
construct by induction, for every formula ψ ∈(IFP + C), a (Datalog + C)
program Πψ with goal predicate Qψ such that (Πψ, Qψ) is equivalent to ψ.
Exercise 3.4.14 For atomic formulae, disjunctions, and existential quan-
tiﬁcation the construction is obvious, and closure under negation has
already been proved. Complete the proof for applications of counting
terms, i.e formulae ψ(y, μ, ν) := #x[ϕ(x, y, μ)] = ν, and ﬁxed point formulae
ψ := [ifpRxμ . ϕ(R, x, μ)](y, ν). The construction makes use of Lemma 3.4.11.

3.5 Capturing PTIME via Canonization
193
Example 3.4.15. To illustrate the expressive power of (Datalog + C) we show
below a program for the Game query (for strictly alternating games). The
Game query is the canonical example that separates LFP from Stratiﬁed Dat-
alog [31, 79]. Game is deﬁnable in ﬁxed-point logic, by the formula [lfpWx .
∃y(Exy ∧∀z(Eyz →Wz))](x) that deﬁnes the winning positions for Player 0.
Here is a (Datalog + C) program with goal predicate Z, deﬁning Game:
Wxλ ←Exy ∧V yμ ∧λ = μ + 1
Fyzμ ←Eyz ∧Wzμ
V yμ ←#z[Eyz] = #z[Fyzμ]
Zx ←Wxμ
The evaluation of this program on a game graph G assigns to W (or V ) a set of
pairs (x, μ) ∈V × N, such that Player 0 has a winning strategy from position
x in at most μ moves when she (or Player 1, respectively) begins the game.
3.5 Capturing PTIME via Canonization
We have seen that there are a number of logics that capture polynomial time
on ordered ﬁnite structures, but none of them suﬃces to express all of PTIME
in the absence of a linear order. Indeed, it has been conjectured that no logic
whatsoever can capture PTIME on the domain of all ﬁnite structures. We
shall discuss this problem further at the end of this section. But, of course,
even if this conjecture should turn out to be true, it remains an important
issue to capture PTIME on other relevant domains besides ordered structures.
3.5.1 Deﬁnable Linear Orders
An obvious approach is to try to deﬁne linear orders and then apply the
known results for capturing complexity classes on ordered structures.
Deﬁnition 3.5.1. Let D be a domain of ﬁnite structures and let L a logic. We
say that D admits L-deﬁnable linear orders if, for every vocabulary τ, there
exists a formula ψ(x, y, ¯z) ∈L(τ) such that there exists in every structure A ∈
D(τ) a tuple ¯c for which the relation {(a, b) : A |= ψ(a, b, c)} is a linear order on
A. The elements in c are called the parameters of the order deﬁned by ψ on A.
Example 3.5.2. Let D consist of all structures (A, E, R1, . . . , ) such that
(A, E) is an undirected cycle. D admits LFP-deﬁnable linear orders (with
two parameters), via the formula
ψ(x, y, z1, z2) := Ez1z2 ∧[lfpRxy . (x = z1 ∧y = z2)∨∃u(Rxu ∧Euy ∧y ̸= z1)
∨∃u(Ruy ∧Eux ∧x ̸= y](x, y).
Furthermore, straightforward automorphism arguments show that we cannot
deﬁne linear orders with fewer than two parameters.

194
3 Finite Model Theory and Descriptive Complexity
Exercise 3.5.3 Let D be the domain of structures (A, E, R1, . . . , ) such
that (A, E) is isomorphic to a ﬁnite rectangular grid. Show that D admits
LFP-deﬁnable linear orders.
Exercise 3.5.4 Let K be a class of τ-structures with the following property.
For every m ∈N, there exists a structure A ∈K such that for every m-tuple
a in A there exists a non-trivial automorphism of A, a. Then K does not
admit deﬁnable orders in any logic.
On any domain that admits LFP-deﬁnable linear orders, we can capture
PTIME by using LFP-formulae that express polynomial-time properties on
ordered structures, and modify them appropriately.
Proposition 3.5.5. If D admits LFP-deﬁnable linear orders, then LFP
captures polynomial time on D.
Proof. It only remains to show that every polynomial-time model class K ⊆
D(τ) is L-deﬁnable. Let ϕ(x, y, z) be a formula deﬁning a linear order on
the structures in D(τ). As LFP captures PTIME on ordered structures, there
exists a formula ψ ∈LFP(τ ∪{<}) such that, for every structure A ∈D(τ) and
every linear order < on A, we have that (A, <) |= ψ iﬀA ∈K. It follows that
A ∈K ⇐⇒A |= ∃z

“{(x, y) : ϕ(x, y, z)} is a linear order”∧
ψ[u < v/ϕ(u, v, z)]

,
where ψ[u < v/ϕ(u, v, z)] is the formula obtained from ψ by replacing every
atom of the form u < v by ϕ(u, v, z).
□
3.5.2 Canonizations and Interpretations
Let S be any set and let ∼be an equivalence relation on S. A canonization
function for (S, ∼) is a function f : S →S associating with every element a
canonical member of its equivalence class. That means that f(s) ∼s for all
s ∈S, and f(s) = f(s′) whenever s ∼s′.
In ﬁnite model theory, we are interested in canonization algorithms for
ﬁnite structures, either up to isomorphism or up to a coarser equivalence rela-
tion, such as indistinguishability in some logic or bisimulation. As algorithms
take encodings of structures as inputs, and as the encoding of a structure is
determined by an ordering of its universe, we can view canonization of struc-
tures as an operation that associates with every structure A an ordered one,
say (A′, <), such that A′ is equivalent to A, and such that equivalent structures
are mapped to the same ordered structure (and hence the same encoding).
For a class K of structures, we write K< for the class of expansions (A, <)
of structures A ∈K by some linear order.

3.5 Capturing PTIME via Canonization
195
Deﬁnition 3.5.6. Let K be a class of ﬁnite τ-structures, and let ∼be an
equivalence relation on K. A canonization function for ∼on K is a function
f : K →K< that associates with every structure A ∈K an ordered structure
f(A) = (A′, <) with A′ ∼A, such that f(A) ∼= f(B) whenever A ∼B.
Interpretations
We are especially interested in canonizations that are deﬁned by interpre-
tations. The notion of an interpretation is very important in mathematical
logic, and for model theory in particular. Interpretations are used to deﬁne
a copy of a structure inside another one, and thus permit us to transfer
deﬁnability, decidability, and complexity results between theories.
Deﬁnition 3.5.7. Let
L
be
a
logic,
let
σ, τ
be
vocabularies, where
τ = {R1, . . . , Rm} is relational, and let ri be the arity of Ri. A (one-
dimensional) L[σ, τ]-interpretation is given by a sequence I of formulae
in L(σ) consisting of
•
δ(x), called the domain formula,
•
ε(x, y), called the equality formula, and,
•
for every relation symbol R ∈τ (of arity r), a formula ϕR(x1, . . . , xr).
An L[σ, τ]-interpretation induces two mappings, one between structures,
and the other between formulae. For a τ-structure A and a σ-structure B, we
say that I interprets A in B (in short, I(B) = A) if there exists a surjective
map h : δB →A, called the coordinate map, such that
•
for all b, c ∈δB,
B |= ε(b, c) ⇐⇒h(b) = h(c);
•
for every relation R of A and all b1, . . . , br ∈δB,
B |= ϕR(b1, . . . , bk) ⇐⇒(h(b1), . . . , h(bk)) ∈R,
i.e. h−1(R) = (δB)k ∩ϕB
R .
Hence I
=
⟨δ, ε, ϕR1, . . . , ϕRm⟩deﬁnes (together with the function
h : δB →A) an interpretation of A = (A, R1, . . . , Rm) in B if and only if
ε(x, y) deﬁnes a congruence on the structure (δB, ϕB
R1, . . . , ϕB
Rm) and h is an
isomorphism from the quotient structure (δB, ϕB
R1, . . . , ϕB
Rm)/εB to A.
Besides the mapping B →I(B) from σ-structures to τ-structures, I also
deﬁnes a mapping from τ-formulae to σ-formulae. With every τ-formula ψ it
associates a σ-formula ψI, which is obtained by relativizing every quantiﬁer
Qx to δ(x), replacing equalities u = v by ε(u, v), and replacing every atom
Ru by the corresponding formula ϕR(u).
Lemma 3.5.8 (Interpretation Lemma). For every interpretation I and
every structure A, we have that
A |= ψI ⇐⇒I(A) |= ψ.

196
3 Finite Model Theory and Descriptive Complexity
We shall omit δ or ε from an interpretation if they are trivial, in the
sense that δ(x) holds for all x and that ε(x, y) is equivalent to x = y.
The notion of an interpretation can be generalized in various ways. In
particular, a k-dimensional
interpretation is given by a sequence
δ(x), ε(x, y), ϕR1(x1, . . . , xr1), . . . , ϕRm(x1, . . . , xrm), where x, y, x1, . . . are
disjoint k-tuples of distinct variables. A k-dimensional interpretation of A in
B represents elements of A by elements or equivalence classes of Bk, rather
than B.
Exercise 3.5.9 Show that up to ﬁrst-order interpretation, all ﬁnite structures
are graphs (see e.g. [66, Chapter 5] and [38, Chapter 11.2]). More precisely,
for every vocabulary τ, construct an FO[{E}, τ]-interpretation I and an
FO[τ, {E}]-interpretation J such that, for every ﬁnite structure A (with at
least two elements), I(A) is a graph and J(I(A)) ∼= A. It then follows that
for every model class K ⊆Fin(τ), K is decidable in polynomial time if, and
only if, the class of graphs {I(A) : A ∈K} is so.
Deﬁnition 3.5.10. Let L be a logic and ∼an equivalence relation on a class
K of τ-structures. We say that (K, ∼) admits L-deﬁnable canonization if
there exists an L[τ, τ ∪{<}]-interpretation I such that the function A →I(A)
is a canonization function for ∼. For any domain D of structures, we say that
(D, ∼) admits L-deﬁnable canonization if (D(τ), ∼) does for every vocabulary
τ. Finally, we say that D admits L-deﬁnable canonization if (D, ∼=) does.
Example 3.5.11. (Deﬁnable canonization versus deﬁnability of order.)
Whenever D admits L-deﬁnable linear orders, and L is closed under ﬁrst-order
operations, D also admits L-deﬁnable canonization. This is obvious if the
formula ϕ< deﬁning the order has no parameters. If it uses parameters, then
it may deﬁne, for each structure A, a family of ordered expansions (A, <).
But these expansions can be compared by use of the lexicographic order
of their encodings. As L is closed under ﬁrst-order operations, the minimal
expansion with respect to this lexicographical order is L-deﬁnable, which
gives an L-deﬁnable canonization.
Note, however, that there exist deﬁnable canonizations even in cases
where no order is deﬁnable. Consider for instance the class of ﬁnite directed
paths Pn (for n ∈N), and take their ‘double graphs’ (see Section 3.2.5),
i.e. the graphs 2Pn = (V, E), where V
= {0, . . . , n −1} × {0, 1} and
E = {⟨(m, i), (m+1, j)⟩: 0 ≤m < n−1, i, j ∈{0, 1}}. On this class, no order
is deﬁnable in any logic and with any ﬁnite number of parameters (to see this
use Exercise 3.5.4). However, the class admits DTC-deﬁnable canonization.
We shall explain the construction, which is uniform for all n, informally.
The obvious equivalence relation on 2Pn, where (m, i) ∼(m′, j) iﬀm = m′,
is ﬁrst-order deﬁnable, and so Pn is interpretable in 2Pn. Further, the nodes
0 and n −1 are deﬁnable in Pn, and so (Cn, 0), the directed n-cycle with
a distinguished point, is interpretable in 2Pn as well. It therefore suﬃces to
show that an ordered copy of 2Pn is interpretable in (Cn, 0). We represent

3.5 Capturing PTIME via Canonization
197
nodes of 2Pn by edges and inverse edges of Cn: the node (m, 0) is represented
in Cn by the pair (m, m + 1) and the node (m, 1) by the pair (m + 1, m). The
order on these pairs is
(0, 1) < (1, 0) < (1, 2) < (2, 1) < · · · < (n −2, n −1) < (n −1, n −2).
The
domain
formula
for
the
interpretation
(of
2Pn
in
Cn)
is
δ(x, y) := Exy∨Eyz. It is not diﬃcult to see that the edge relation and the lin-
ear order are deﬁnable using DTC operators. The details are left to the reader.
A simple but interesting example of deﬁnable canonization is tree
canonization via ﬁxed-point logic with counting.
Proposition 3.5.12. The class of (directed) trees admits (IFP + C)-deﬁnable
canonization.
Proof. The interpretation I that we construct maps a tree T = (V, E) (with
n nodes) to an ordered tree I(T ) = ({1, . . . , n}, E′, <), where < is the natural
order. That is, the interpretation is one-dimensional, maps nodes to numbers,
and is deﬁned by the formulae δ(μ) := ∃ν(ν < μ), ϕ<(μ, ν) := μ < ν, and a
formula ϕE′(μ, ν) that we do not explicitly construct.
The construction of E′ is based on an inductively deﬁned ternary
relation F ⊆V × {1, . . ., n}2 that encodes the sequence of binary relations
Fv := {(i, j) : (v, i, j) ∈F}. For each node v of T , let Tv denote the subtree of
T with root v, and let Sv be the graph ({1, . . . , |Tv|}, Fv). The construction
will ensure that Sv is isomorphic to Tv.
If v is a leaf, let Fv = ∅. Suppose now that v has children v1, . . . , vm, and
that the graphs Sv1, . . . , Svm have already been constructed. To deﬁne Sv, we
compute the code words wi = code(Svi, <) (where < is the natural order)
and arrange them in lexicographic order. Now let Sv be the graph with nodes
1, . . . , |Tv|, obtained by ﬁrst taking a copy of the Svi with the smallest code
word, then taking a copy of the second, and so on, and ﬁnally adding another
node that is connected to the roots of the copies of the Svi. Obviously, Sv
determines Fv, and Sv ∼= Tv.
It is clear that the inductive construction of F can be done via an (IFP
+ C)-formula ψF (x, μ, ν). Now take ϕE′(μ, ν) := ∃xψF (x, μ, ν).
□
Theorem 3.5.13. Let D be a domain of (ﬁnite) structures, and let L be a
logic that captures PTIME on D<. If D admits L-deﬁnable canonization,
then L captures PTIME on D also.
Proof. Let K ∈D(τ) be a model class tht is decidable in polynomial time,
and let ψ ∈L(τ ∪{<}) be a formula deﬁning K< inside D<(τ). Further, let
I be an L[τ, τ ∪{<}]-interpretation that deﬁnes a canonization on D(τ). By
the Interpretation Lemma,
A |= ψI ⇐⇒I(A) |= ψ ⇐⇒I(A) ∈K< ⇐⇒A ∈K.
Hence L captures PTIME on D.
□

198
3 Finite Model Theory and Descriptive Complexity
This result is important because it has been shown, in particular in
the work of Grohe [58–60], that a number of interesting domains admit
canonization via ﬁxed-point logic with counting (IFP + C). Among these are
(1) the domain of ﬁnite (labelled) trees (see Proposition 3.5.12);
(2) the class of planar graphs [58] and, more generally, any domain of
structures, whose Gaifman graphs are embeddable in a ﬁxed surface [59];
(3) any domain of structures of bounded tree width [60].
Corollary 3.5.14. (IFP + C) captures PTIME on any of these domains.
Further, the results extend to domains that can be reduced to any of
the domains mentioned above by simple deﬁnable operations such as adding
or deleting a vertex or edge. An example is that of nearly planar (or apex)
graphs, which become planar when one vertex is removed.
3.5.3 Capturing PTIME up to Bisimulation
In mathematics, we consider isomorphic structures as identical. Indeed,
it almost goes without saying that relevant mathematical notions do not
distinguish between isomorphic objects. As classical algorithmic devices
work on ordered representations of structures rather than the structures
themselves, our capturing results rely on an ability to reason about canonical
ordered representations of isomorphism classes of ﬁnite structures.
However, in many application domains of logic, structures are distin-
guished only up to equivalences coarser than isomorphism. Perhaps the
best-known example is the modelling of the computational behaviour of
(concurrent) programs by transition systems. The meaning of a program
is usually not captured by a unique transition system. Rather, transition
systems are distinguished only up to appropriate notions of behavioural
equivalence, the most important of these being bisimulation.
In such a context, the idea of a logic capturing PTIME gets a new twist.
One would like to express in a logic precisely those properties of structures
that are
(1) decidable in polynomial time, and
(2) invariant under the notion of equivalence being studied.
Let us look at one speciﬁc problem in this context, the problem of
bisimulation-invariant properties of transition systems.
Deﬁnition 3.5.15. Let
G
=
(V, (Ea)a∈A, (Pb)b∈B)
and
G′
=
(V ′, (E′
a)a∈A, (P ′
b)b∈B) be two transition systems of the same vocabu-
lary. A bisimulation between G and G′ is a non-empty relation Z ⊆V × V ′,
respecting the Pb in the sense that v ∈Pb iﬀv′ ∈P ′
b, for all b ∈B and
(v, v′) ∈Z, and satisfying the following back and forth conditions.

3.5 Capturing PTIME via Canonization
199
Forth.
for all (v, v′) ∈Z, a ∈A and every w such that (v, w) ∈Ea, there
exists a w′ such that (v′, w′) ∈E′
a and (w, w′) ∈Z.
Back. for all (v, v′) ∈Z, a ∈A and every w′ such that (v′, w′) ∈E′
a, there
exists a w such that (v, w) ∈Ea and (w, w′) ∈Z.
A rooted transition system is a pair (G, u), where G is a transition
system G and u is a node of G. Two rooted transition systems (G, u) and
(G′, u′) are bisimilar, denoted by G, u ∼G′, u′, if there is a bisimulation Z
between G and G′ with (u, u′) ∈Z.
Exercise 3.5.16 Bisimulation is a greatest ﬁxed point. Prove that two nodes
u, u′ of a transition system G are bisimilar, i.e. (G, u) ∼(G, u′) if, and only if,
G |= [gfpRxy .
	
b∈B
Pbx ↔Pby∧
	
a∈A
(∀x′ . Eaxx′)(∃y′ . Eayy′)Rx′y′∧
	
a∈A
(∀y′ . Eayy′)(∃x′ . Eaxx′)Rx′y′](u, u′).
A class S of rooted transition systems is invariant under bisimulation
if, whenever (G, u) ∈S and (G, u) ∼(G′, u′), then also (G′, u′) ∈S. We
say that a class S of ﬁnite rooted transition systems is in bisimulation-
invariant PTIME if it is invariant under bisimulation, and if there exists
a polynomial-time algorithm deciding whether a given pair (G, u) belongs to
S. A logic L is invariant under bisimulation if all L-deﬁnable properties of
rooted transition systems are.
Exercise 3.5.17 Prove that ML, the modal μ-calculus Lμ, and the inﬁnitary
modal logic ML∞are invariant under bisimulation.
Clearly, Lμ ⊆bisimulation-invariant PTIME. However, as pointed out in
Section 3.3.3, Lμ is far too weak to capture this class, mainly because it is
essentially a monadic logic. Instead, we have to consider a multidimensional
variant Lω
μ of Lμ.
But before we deﬁne this logic, we should explain the main technical
step, which relies on deﬁnable canonization, but of course with respect to
bisimulation rather than isomorphism. For simplicity of notation, we consider
only transition systems with a single transition relation E. The extension to
the case of several transition relations Ea is completely straightforward.
With a rooted transition system G = (V, E, (Pb)b∈B), u, we associate a
new transition system
G∼
u := (V ∼
u , E∼, (P ∼
b )b∈B),
where V ∼
u
is the set of all ∼-equivalence classes [v] of nodes v ∈V that are
reachable from u. More formally, let [v] denote the bisimulation equivalence
class of a node v ∈V . Then

200
3 Finite Model Theory and Descriptive Complexity
V ∼
u := {[v] : there is a path in G from u to v}
P ∼
b := {[v] ∈V ∼
u : v ∈Pb}
E∼:= {([v], [w]) : (v, w) ∈E}.
As shown in the following exercise, the pair G∼
u , [u] is, up to isomorphism,
a canonical representant of the bisimulation equivalence class of G, u.
Exercise 3.5.18 Prove that (1) (G, u) ∼(G∼
u , [u]), and (2) if (G, u) ∼(H, v),
then (G∼
u , [u]) ∼= (H∼
v , [v]).
It follows that a class S of rooted transition systems is bisimulation-
invariant if and only if S = {(G, u) : (G∼
u , [u]) ∈S}. Let CR∼be the domain
of canonical representants of ﬁnite transition systems, i.e.
CR∼:= {(G, u) : (G∼
u , [u]) ∼= (G, u)}.
Proposition 3.5.19. CR∼admits LFP-deﬁnable linear orderings.
Proof. We show that for every vocabulary τ = {E} ∪{Pb : b ∈B}, there
exists a formula ψ(x, y) ∈LFP(τ) which deﬁnes a linear order on every
transition system in CR∼(τ).
Recall that bisimulation equivalence on a transition system is a greatest
ﬁxed point. Its complement, bisimulation inequivalence, is a least ﬁxed point,
which is the limit of an increasing sequence ̸∼i deﬁned as follows: u ̸∼0 v if u
and v do not have the same atomic type, i.e. if there exists some b such that
one of the nodes u, v has the property Pb and the other does not. Further,
u ̸∼i+1 v if the sets of ∼i-classes that are reachable in one step from u and v
are diﬀerent. The idea is to reﬁne this inductive process, by deﬁning relations
≺i that order the ∼i-classes. On the transition system itself, these relations
are pre-orders. The inductive limit ≺of the pre-orders ≺i deﬁnes a linear
order of the bisimulation equivalence classes. But in transition systems in
CR∼, bisimulation classes have only one element, so ≺actually deﬁnes a
linear order on the set of nodes.
To make this precise, we choose an order on B and deﬁne ≺0 by
enumerating the 2|B| atomic types with respect to the propositions Pb, i.e.
x ≺0 y :=

b∈B

¬Pbx ∧Pby ∧
	
b′<b
Pb′x ↔Pb′y

.
In what follows, x
∼i
y
can be taken as an abbreviation for
¬(x ≺i y ∨y ≺i x), and similarly for x ∼y. We deﬁne x ≺i+1 y by the condi-
tion that either x ≺i y, or x ∼i y and the set of ∼i-classes reachable from x is
lexicographically smaller than the set of ∼i-classes reachable from y. Note that
this inductive deﬁnition of ≺is not monotone, so it cannot be directly captured
by an LFP-formula. However, as we know that LFP ≡IFP, we can use an IFP-
formula instead. Explicitly, ≺is deﬁned by [ifpx ≺y . ψ(≺, x, y)](x, y), where

3.5 Capturing PTIME via Canonization
201
ψ(≺, x, y) := x ≺0 y ∨

x ∼y∧
(∃y′ . Eyy′)

(∀x′ . Exx′)x′ ̸∼y′∧
(∀z.z ≺y′)

∃x′′(Exx′′ ∧x′′ ∼z) ↔
∃y′′(Eyy′′ ∧y′′ ∼z)

.
□
Exercise 3.5.20 Complete
the
proof
by
showing
that
the
formula
[ifpx ≺y . ψ(≺, x, y)](x, y) indeed deﬁnes the order described above.
Corollary 3.5.21. On the domain CR∼, LFP captures PTIME.
In fact, this result already suﬃces to give an abstract capturing result
for bisimulation-invariant PTIME (in the sense of the following section): by
composing the mapping from rooted transition systems to their canonical
representants with LFP queries on these representants, we obtain an abstract
logic with recursive syntax and polynomial-time semantics that describes
precisely the polynomial-time computable, bisimulation-invariant queries on
rooted transition systems.
In many situations (such as for polynomial time on arbitrary ﬁnite struc-
tures), we would actually be quite happy with such an abstract capturing
result. However, in the bisimulation-invariant scenario we can do better and
capture PTIME in terms of a natural logic, the multidimensional μ-calculus
Lω
μ.
Deﬁnition 3.5.22. The syntax of the k-dimensional μ-calculus Lk
μ (for
transition systems G = (V, E, (Pb)b∈B)) is the same as the syntax of the
usual μ-calculus Lμ with modal operators ⟨i⟩, [i] for a ∈A, i = 1, . . . , k, and
⟨σ⟩, [σ] for every substitution σ : {1, . . . , k} →{1, . . . , k}. Let S(k) be the set
of all these substitutions.
The semantics is diﬀerent, however. A formula ψ of Lk
μ is interpreted on a
transition system G = (V, E, (Pb)b∈B) at node v by evaluating it as a formula
of Lμ on the modiﬁed transition system
Gk = (V k, (Ei)1≤i≤k, (Eσ)σ∈S(k), (Pb,i)b∈B,1≤i≤k)
at node v := (v, v, . . . , v). Here V k = V × · · · × V and
Ei := {(v, w) ∈V k × V k : (vi, wi) ∈E and vj = wj for j ̸= i}
Eσ := {(v, w) ∈V k × V k : wi = vσ(i) for all i}
Pb,i := {v ∈V k : vi ∈Pb}
That is, G, v |=Lk
μ ψ iﬀGk, (v, . . . , v) |=Lμ ψ. The multidimensional
μ-calculus is Lω
μ = 
k<ω Lk
μ.

202
3 Finite Model Theory and Descriptive Complexity
Remark. Instead of evaluating a formula ψ ∈Lk
μ at single nodes v of G, we
can also evaluate it at k-tuples of nodes: G, v |=Lkμ ψ iﬀGk, v |=Lμ ψ.
Example 3.5.23. Bisimulation is deﬁnable in L2
μ (in the sense of the remark
just made). Let
ψ∼:= νX .
 	
b∈B
(Pb,1 ↔Pb,2) ∧[1]⟨2⟩X ∧[2]⟨1⟩X

.
For every transition system G, we have that G, v1, v2 |= ψ∼if, and only if, v1
and v2 are bisimilar in G. Further, we have that
G, v |= μY . ⟨2⟩(ψ∼∨⟨2⟩Y )
if, and only if, there exists in G a point w that is reachable from v (by a path
of length ≥1) and bisimilar to v.
Exercise 3.5.24 Prove that Lω
μ is invariant under bisimulation. Further,
show that Lω
μ can be embedded in LFP.
This exercise establishes the easy direction of the desired result: Lω
μ ⊆
bisimulation-invariant PTIME. For the converse, it suﬃces to show that
LFP and Lω
μ are equivalent on the domain CR∼. Let S be a class of rooted
transition systems in bisimulation-invariant PTIME. For any (G, u), we have
that (G, u) ∈S if its canonical representant (G∼
u , [u]) ∈S. If LFP and Lω
μ are
equivalent on CR∼, then there exists a formula ψ ∈Lω
μ such that G∼
u , [u] |= ψ
iﬀ(G∼
u , [u]) ∈S. By the bisimulation invariance of ψ, it follows that G, u |= ψ
iﬀ(G, u) ∈S.
Proposition 3.5.25. On the domain CR∼, LFP ≤Lω
μ. More precisely, for
each formula ψ(x1, . . . , xk+1) ∈LFP of width ≤k + 1, there exists a formula
ψ∗∈Lk+1
μ
such that for each (G, u) ∈CR∼, we have that G |= ψ(u, v) iﬀ
G, u, v |= ψ∗.
Note that although, ultimately, we are interested only in formulae ψ(x)
with just one free variable, we need more general formulae, and evaluation
of Lk
μ-formulae over k-tuples of nodes, for the inductive treatment. In all
formulae, we shall have at least x1 as a free variable, and we always interpret
x1 as u (the root of the transition system). We remark that, by an obvious
modiﬁcation of the formula given in Exercise 3.5.23, we can express in Lk
μ
the assertion that xi ∼xj for any i, j.
Atomic formulae are translated from LFP to Lω
μ according to
(xi = xj)∗:= xi ∼xj
(Pbxi)∗:= Pb,ix
(Exixj)∗:= ⟨i⟩xi ∼xj
(Xxσ(1) · · · xσ(r))∗:= ⟨σ⟩X.

3.5 Capturing PTIME via Canonization
203
Boolean connectives are treated in the obvious way, and quantiﬁers are
translated by use of ﬁxed points. To ﬁnd a witness xj satisfying a formula
ψ, we start at u (i.e. set xj = x1), and search along transitions (i.e. use the
μ-expression for reachability). That is, let j/1 be the substitution that maps
j to 1 and ﬁxes the other indices, and translate ∃xjψ(x) into
⟨j/1⟩μY . ψ∗∨⟨j⟩Y.
Finally, ﬁxed points are ﬁrst brought into normal form so that variables appear
in the right order, and then they are translated literally, i.e. [lfpXx . ψ](x)
translates into μX . ψ∗.
The proof that the translation has the desired property is a straightfor-
ward induction, which we leave as an exercise (see [90] for details). Altogether
we have established the following result.
Theorem 3.5.26 (Otto).
The
multidimensional
μ-calculus
captures
bisimulation-invariant PTIME.
Otto has also established capturing results with respect to other equiv-
alences. For ﬁnite structures A, B, we say that A ≡k B if no ﬁrst-order
sentence of width k can distinguish between A and B. Similarly, A ≡C
k B if A
and B are indistinguishable by ﬁrst-order sentences of width k with counting
quantiﬁers of the form ∃≥ix, for any i ∈N.
Theorem 3.5.27 (Otto). There exist logics that eﬀectively capture ≡2-
invariant PTIME and ≡C
2 -invariant PTIME on the class of all ﬁnite
structures.
For details, see [89].
3.5.4 Is There a Logic for PTIME?
To discuss the problem of whether PTIME can be captured on the domain
of all ﬁnite structures, we need to make precise the notion of a logic, and
to reﬁne the notion of a logic capturing a complexity class, so as to exclude
pathological examples such the following, which is due to Gurevich [61].
Example 3.5.28. Let the syntax of our ‘logic’ consist of all pairs (M, k),
where M is a Turing machine, and k a natural number. A ﬁnite τ-structure
A is a model of (M, k) if there exists a model class K ⊆Fin(τ) such that
A ∈K, and M accepts an encoding code(B, <) of a ﬁnite τ-structure B in
time |B|k if, and only if, B ∈K. Note that this ‘logic’ captures PTIME on
ﬁnite structures. But the example is pathological, not mainly because of its
unusual format, but because its semantics is not eﬀective: it is undecidable
whether a Turing machine accepts an isomorphism-closed class of structures.
Another example of this kind is order-invariant LFP. The τ-sentences of
this logic are the LFP-sentences of vocabulary τ ∪{<} such that, for all ﬁnite

204
3 Finite Model Theory and Descriptive Complexity
τ-structures A and all linear orders <, <′ on A, we have that (A, <) |= ψ
if and only if (A, <′) |= ψ. This deﬁnes the syntax. The semantics is the
obvious one: a structure A is a model of ψ if, and only if, (A, <) |= ψ for
some, and hence all, linear orders on A. This ‘logic’ also captures PTIME,
but again it has an undesirable feature: it is undecidable whether a given
sentence ψ ∈LFP is order-invariant (compare Exercise 3.1.12), so the ‘logic’
does not have an eﬀective syntax.
We start by deﬁning a general notion of a logic on ﬁnite structures by
imposing two requirements: an eﬀective syntax and an isomorphism-invariant
semantics.
Deﬁnition 3.5.29. A logic on a domain D of ﬁnite structures is a pair
(L, |=), where L is a function that assigns to each vocabulary τ a decidable
set L(τ) (whose elements are called τ-sentences), and |= is a binary relation
between sentences and ﬁnite structures, so that for each sentence ψ ∈L(τ),
the class {A ∈D(τ) : A |= ψ} is closed under isomorphism.
Recall that, by Deﬁnition 3.2.10, a logic captures PTIME on a domain D
if every polynomial-time decidable model class in D is deﬁnable in that logic,
and if, for every sentence of the logic, the model-checking problem on D can
be solved in polynomial time. To exclude pathological examples such the
ﬁrst one above, we impose in addition the condition that for each sentence,
a polynomial-time model-checking algorithm can be eﬀectively constructed.
Deﬁnition 3.5.30. A logic (L, |=) eﬀectively captures PTIME on a
domain D of ﬁnite structures if it captures PTIME in the sense of Deﬁni-
tion 3.2.10 and, moreover, there exists a computable function, which associates
with every sentence ψ ∈L(τ) an algorithm M and a polynomial p, such that
M decides {A ∈D(τ) : A |= ψ} in time p(n). We simply say that (L, |=)
eﬀectively captures PTIME if it does so on the class of all ﬁnite structures.
This deﬁnition can be modiﬁed in the obvious way to other complexity
classes. All capturing results that we have proved so far are eﬀective in this
sense.
Exercise 3.5.31 A complexity class C is recursively indexable on a domain
D if there is a recursive index set I, a computable function f mapping every
i ∈I to (the code of) a Turing machine Mi, and an appropriate resource
bound (e.g. a polynomial bounding the running time of Mi) such that:
(1) The class Ki of all structures from D accepted by Mi is in C, and,
moreover, Mi together with the given resource bound witnesses the
membership of Ki in the complexity class C.
(2) For each model class K ∈C on the domain D, there is an i ∈I such that
Mi decides K.

3.6 Algorithmic Model Theory
205
Prove that there is a logic that eﬀectively captures C on the domain D if,
and only if, C is recursively indexable on D.
The above deﬁnition of a logic may seem too abstract for practical
purposes. However, it is justiﬁed by the equivalence with recursive indexings,
as described in the exercise above, and by a result of Dawar [32], which shows
that if there is any logic that eﬀectively captures PTIME, then there also exists
a natural one. More precisely, Dawar proved that, from any logic eﬀectively
capturing PTIME, one could extract a model class K that is complete for
PTIME under ﬁrst-order reductions. As a consequence, PTIME would also be
eﬀectively captured by the logic FO[Qω
K], which adjoins to FO the vectorized
Lindst¨om quantiﬁers associated with K (see [32, 38] for more information).
Exercise 3.5.32 Many ﬁnite-model theorists conjecture that there is no logic
that eﬀectively captures PTIME on ﬁnite structures. If you are the ﬁrst to
prove this, you may win one million dollars. Why?
3.6 Algorithmic Model Theory
3.6.1 Beyond Finite Structures
For a long time, descriptive complexity theory has been concerned almost
exclusively with ﬁnite structures. Although important problems remain open,
the relationship between deﬁnability and complexity on ﬁnite structures is
now fairly well understood, and there are interesting connections to ﬁelds such
as databases, knowledge representation, and computer-aided veriﬁcation.
However, for many applications, the strict limitation to ﬁnite structures
is too restrictive. In most of the ﬁelds mentioned above, there have been
considerable eﬀorts to extend the relevant methodology from ﬁnite structures
to suitable domains of inﬁnite ones. In particular, this is the case for
databases and computer-aided veriﬁcation where inﬁnite structures (like
constraint databases or transition systems with inﬁnite state spaces) are of
increasing importance.
Finite model theory should therefore be generalized to a more compre-
hensive algorithmic model theory that extends the research programme, the
general approach, and the methods of ﬁnite model theory to interesting
domains of inﬁnite structures. From a more general theoretical point of view,
one may ask what domains of inﬁnite structures are suitable for such an
extension. More speciﬁcally, one may ask what conditions must be satisﬁed
by a domain D of structures that are not necessarily ﬁnite such that the
approach and methods of ﬁnite model theory make sense. There are two
obvious and fundamental conditions:
Finite representations. Every structure A ∈D should be representable in a
ﬁnite way (e.g. by a binary string, an algorithm, a collection of automata,
an axiomatization in some logic, an interpretation, . . . ).

206
3 Finite Model Theory and Descriptive Complexity
Eﬀective semantics. For the relevant logics (e.g. ﬁrst-order logic), the model-
checking problem on D should be decidable. That is, given a sentence
ψ ∈L and a representation of a structure A ∈D, it should be decidable
whether A |= ψ.
These are just minimal requirements, which may need to be reﬁned
according to the context and the questions to be considered. We may, for
instance, also require the following:
Closure. For every structure A ∈D and every formula ψ(x), the expansion
(A, ψA) of A with the relation deﬁned by ψ, should as well be contained
in D.
Eﬀective query evaluation. Suppose that we have ﬁxed a way of representing
structures. Given a representation of A ∈D and a formula ψ(x), we
should be able to compute a representation of ψA (or of the expanded
structure (A, ψA)).
Note that, contrary to the case of ﬁnite structures, query evaluation does not
necessarily reduce to model checking. Further, instead of just eﬀectiveness
of these tasks, it may be required that they can be performed within some
complexity bounds.
3.6.2 Finitely Presentable Structures
We brieﬂy survey here some domains of inﬁnite but ﬁnitely presentable
structures which may be relevant to algorithmic model theory. We shall then
discuss in a more detailed way metaﬁnite structures, for which descriptive
complexity issues have already been studied quite intensively.
Recursive structures are countable structures whose functions and
relations are computable and therefore ﬁnitely presentable. They have been
studied quite intensively in model theory since the 1960s (see e.g. [6, 42]).
Although recursive model theory is very diﬀerent from ﬁnite model theory,
there have been some papers studying classical issues of ﬁnite model theory
on recursive structures and recursive databases [50, 64, 65, 94]. However,
for most applications, the domain of recursive structures is far too large. In
general, only quantiﬁer-free formulae admit eﬀective evaluation algorithms.
Constraint databases provide a database model that admits inﬁnite
relations that are ﬁnitely presented by quantiﬁer-free formulae (constraints)
over some ﬁxed background structure. For example, to store geometrical
data, it is useful not just to have a ﬁnite set as the universe of the database,
but to include all real numbers ‘in the background’. Also, the presence
of interpreted functions on the real numbers, such as addition and multi-
plication, is desirable. The constraint database framework introduced by
Kanellakis, Kuper, and Revesz [74] meets both requirements. Formally, a
constraint database consists of a context structure A, such as (R, <, +, ·), and
a set {ϕ1, . . . , ϕm} of quantiﬁer-free formulae deﬁning the database relations.
Constraint databases are treated in detail in [81] and in Chap. 5 of this book.

3.6 Algorithmic Model Theory
207
Automatic structures are structures whose functions and relations
are represented by ﬁnite automata. Informally, a relational structure
A = (A, R1, . . . , Rm) is automatic if we can ﬁnd a regular language Lδ ⊆Σ∗
(which provides names for the elements of A) and a function ν : Lδ →A
mapping every word w ∈Lδ to the element of A that it represents. The
function ν must be surjective (every element of A must be named) but need
not be injective (elements can have more than one name). In addition, it must
be recognizable by ﬁnite automata (reading their input words synchronously)
whether two words in Lδ name the same elements, and, for each relation Ri
of A, whether a given tuple of words in Lδ names a tuple in Ri.
Example 3.6.1. (1) All ﬁnite structures are automatic.
(2) Some important examples of automatic structures are Presburger
arithmetic (N, +), and its expansions Np := (N, +, |p) by the relation x |p y
which says that x is a power of p dividing y. Using p-ary encodings (starting
with the least signiﬁcant digit), it is not diﬃcult to construct automata
recognizing equality, addition, and |p.
(3) For p ∈N, let Tree(p) := ({0, . . . , p −1}∗, (σi)i<p, <, el), where
σi(x) := xi, x < y means that xz = y for some z, and el(x, y) means that x
and y have equal length. Obviously, these structures are automatic as well.
Automatic structures provide a vast playground for ﬁnite-model theorists,
with many examples of high relevance to computer science. There are also
interesting connections to computational group theory, where automatic
groups have already been studied quite intensively [41, 44]. The general
notion of structures presentable by automata was proposed in [75], and their
theory has been developed in [16, 18, 19, 92].
The notion of an automatic structure can be modiﬁed and generalized in
many directions. By using automata over inﬁnite words, we obtain the notion
of ω-automatic structures (which, unlike automatic structures, may have
uncountable cardinality).
Example 3.6.2. (1) All automatic structures are ω-automatic.
(2) The additive group of reals, (R, +), and indeed the expanded structure
Rp := (R, +, ≤, |p, 1) are ω-automatic, where
x |p y iﬀx = pn and y = kx for some n, k ∈Z.
(3)
The
tree
structures
Tree(p)
can
be
extended
in
a
natu-
ral
way
to
the
(uncountable)
ω-automatic
structures
Treeω(p)
=
({0, . . . , p −1}≤ω, (σi)i<p, ⪯, el).
Unlike the class of recursive structures, automatic structures and ω-
automatic structures admit eﬀective (in fact, automatic) evaluation of all
ﬁrst-order queries and possess many other pleasant algorithmic properties.
Theorem 3.6.3. The model checking problems for ﬁrst-order logic on the
domains of automatic or ω-automatic structures are decidable.

208
3 Finite Model Theory and Descriptive Complexity
There are a number of extensions of this result, for instance to
the extension of ﬁrst-order logic by the quantiﬁer ‘there exist inﬁnitely
many’ [19]. There also are model-theoretic characterizations of automatic
and ω-automatic structures, in terms of interpretations into appropriate
expansions of Presburger arithmetic, trees, or the additive group of reals (see
Examples 3.6.1 and 3.6.2). We write A ≤FO B to denote that there exists a
ﬁrst-order interpretation of A in B. Note that the domains of automatic and
ω-automatic structures are closed under ﬁst-order interpretations.
Theorem 3.6.4 (Blumensath and Gr¨adel). (1) For every structure A,
the following are equivalent:
(i) A is automatic.
(ii) A ≤FO Np for some (and hence all) p ≥2.
(iii) A ≤FO Tree(p) for some (and hence all) p ≥2.
(2) For every structure A, the following are equivalent:
(i) A is ω-automatic.
(ii) A ≤FO Rp for some (and hence all) p ≥2.
(iii) A ≤FO Treeω(p) for some (and hence all) p ≥2.
For a proof, see [19] There are similar characterizations for tree-
automatic structures [16]. For further results on automatic structures,
see [10, 16, 18, 19, 75–78, 92].
The model-theoretic characterizations of automatic and ω-automatic
structures in terms of interpretability suggest a general way to obtain other
domains of inﬁnite structures that may be interesting for algorithmic model
theory: ﬁx a structure A with ‘nice’ (algorithmic and/or model-theoretic)
properties and an appropriate notion of interpretation, and consider the
class of all structures that are interpretable in A. Obviously, each structure
in this class is ﬁnitely presentable (by an interpretation). Further, many
‘nice’ properties are preserved by interpretations, and so every structure in
the class inherits them from A. In particular, every class of queries that
is eﬀective on A and closed under ﬁrst-order operations is eﬀective on the
closure of A under ﬁrst-order interpretations. This approach is also relevant
to the domain of structures that we discuss next.
Tree-interpretable structures are structures that are interpretable in
the inﬁnite binary tree T 2 = ({0, 1}∗, σ0, σ1) via a (one-dimensional) MSO-
interpretation. By Rabin’s Theorem, monadic second-order formulae can
be eﬀectively evaluated on T 2. Since MSO is closed under one-dimensional
interpretations, the Interpretation Lemma implies that tree-interpretable
structures admit eﬀective evaluation for MSO. Tree-interpretable structures
generalize various notions of inﬁnite graphs that have been studied in
logic, automata theory and, veriﬁcation. Some examples are context-free
graphs [87, 88], which are the conﬁguration graphs of pushdown automata,
HR-equational and VR-equational graphs [27], which are deﬁned via

3.6 Algorithmic Model Theory
209
certain graph grammars, and preﬁx-recognizable graphs [25], which can
for instance be deﬁned as graphs of the form (V, (Ea)a∈A), where V is a reg-
ular language and each edge relation Ea is a ﬁnite union of sets X(Y × Z) =
{(xy, xz) : x ∈X, y ∈Y, z ∈Z}, for regular languages X, Y, Z. In fact, some
of these classes coincide with the class of tree-interpretable graphs (see [17]).
Theorem 3.6.5. For any graph G
=
(V, (Ea)a∈A), the following are
equivalent:
(i) G is tree-interpretable.
(ii) G is VR-equational.
(iii) G is preﬁx-recognizable.
(iv) G is the restriction to a regular set of the conﬁguration graph of a
pushdown automaton with ε-transitions.
On the other hand, the classes of context-free graphs and of HR-equational
graphs are strictly contained in the class of tree-interpretable graphs.
Exercise 3.6.6 Prove that every tree-interpretable structure is automatic. Is
the converse also true?
Tree-Constructible Structures: the Caucal Hierarchy
The question arises of whether there are even more powerful domains than the
tree-interpretable structures on which monadic second-order logic is eﬀective.
An interesting way to obtain such domains is to use tree constructions that
associate with any structure a kind of tree unravelling. A simple variant is
the unfolding of a labelled graph G from a given node v to the tree T (G, v).
Courcelle and Walukiewicz [28, 29] have shown that the MSO-theory of
T (G, v) can be eﬀectively computed from the MSO-theory of (G, v). A more
general operation, applicable to relational structures of any kind, has been
invented by Muchnik. Given a relational structure A = (A, R1, . . . , Rm),
let its iteration A∗= (A∗, R∗
1, . . . , R∗
m, suc, clone) be the structure with
universe A∗, relations R∗
i = {(wa1, . . . , war) : w ∈A∗, (a1, . . . , ar) ∈Ri},
the successor relation suc = {(w, wa) : w ∈A∗, a ∈A}, and the predicate
clone consisting of all elements of the form waa. It is not diﬃcult to see
that unfoldings of graphs are ﬁrst-order interpretable in their iterations.
Muchnik’s Theorem states that the monadic theory of A∗is decidable if the
monadic theory of A is so (for proofs, see [11, 101]). We deﬁne the domain
of tree-constructible structures to be the closure of the domain of ﬁnite
structures under (one-dimensional) MSO-interpretations and iterations. By
Muchnik’s Theorem, and since eﬀective MSO model checking is preserved
under interpretations, the tree constructible structures are ﬁnitely presentable
and admit eﬀective evaluation of MSO-formulae.
The tree-constructible graphs form the Caucal hierarchy, which was
deﬁned in [26] in a slighly diﬀerent way. The deﬁnition is easily extended to

210
3 Finite Model Theory and Descriptive Complexity
arbitrary structures: let C0 be the class of ﬁnite structures, and let Cn+1 be
the class of structures that are interpretable in the iteration A∗of a structure
A ∈Cn. There are a number of diﬀerent, but equivalent, ways to deﬁne the
levels of the Caucal hierarchy. For instance, one can use the inverse rational
mappings given in [25] rather than monadic interpretations, and simple
unfoldings rather than iterations without changing the hierarchy [24]. Equiv-
alently, the hierarchy can be deﬁned via higher-order pushdown automata.
It is known that the Caucal hierarchy is strict, and that it does not exhaust
the class of all structures with a decidable MSO-theory. We refer to [24, 98]
for details and further information.
3.6.3 Metaﬁnite Structures.
The class of inﬁnite structures for which descriptive complexity theory has
been studied most intensively is the class of the metaﬁnite structures, pro-
posed by Gr¨adel and Gurevich [48], and studied also in [30, 49, 53, 84]. These
structures are somewhat reminiscent of the two-sorted structures that we
used to deﬁne ﬁxed-point logic with counting, (IFP + C). There, the second
sort was a ﬁnite linear order ({0, . . . , n}, <). Metaﬁnite structures are similar
two-sorted structures, with the essential diﬀerences that (1) the numerical sort
need not be ﬁnite, (2) the structures may contain functions from the ﬁrst to
the second sort, and (3) operations more general than counting are considered.
Deﬁnition 3.6.7. A
(simple)
metaﬁnite
structure
is
a
triple
D = (A, R, W) consisting of the following:
(i) A ﬁnite structure A, called the primary part of D.
(ii) A ﬁnite or inﬁnite structure R, called the secondary (or numerical) part
of D. We always assume that R contains two distinguished elements 0
and 1 (or true and false).
(iii) A ﬁnite set W of functions w : Ak →R.
The vocabulary of D is the triple τ(D) = (τa, τr, τw), where each compo-
nent of τ(D) is the set of relation or function symbols in the corresponding
component of D. (We always consider constants as functions of arity 0.) The
two distinguished elements 0, 1 of R are named by constants of τr.
Example 3.6.8. (R-structures) The descriptive complexity theory over the
real numbers developed by Gr¨adel and Meer [53] (see Sect. 3.6.5) is based
on R-structures, which are simple metaﬁnite structure with a secondary part
R = (R, +, −, ·, /, ≤, (cr)r∈R). It is convenient to include subtraction and
division as primitive operations and assume that every element r ∈R is
named by a constant cr, so that any rational function g : Rk →R (i.e. any
quotient of two polynomials) can be written as a term.
There are many variations of metaﬁnite structures. An important one is
metaﬁnite structures with multiset operations. Any function f : A →R

3.6 Algorithmic Model Theory
211
deﬁnes a multiset mult(f) = {{f(a) : a ∈A}} over R (where the notation
{{. . .}} indicates that we may have multiple occurrences of the same element).
For any set R, let fm(R) denote the class of all ﬁnite multisets over R. In some
of the metaﬁnite structures that we consider, the secondary part R is not just
a (ﬁrst-order) structure in the usual sense, but instead it comes with a collec-
tion of multiset operations Γ : fm(R) →R, mapping ﬁnite multisets over R to
elements of R. Some natural examples on, say, the real numbers are addition,
multiplication, counting, mean, maximum, and minimum. The use of multiset
operations will become clearer when we introduce logics for metaﬁnite struc-
tures. Let us just remark that multiset operations are a natural way to make
precise the notion of aggregates in database query languages such as SQL.
Example 3.6.9. (Arithmetical structures).
Of particular interest to us are
metaﬁnite structures, whose secondary part is a structure N over the natural
numbers such that
•
N includes at least the constants 0, 1, the functions +, · , the ordering rela-
tion <, and the multiset operations max, min,  (sum), and  (product).
•
All functions, relations, and multiset operations of N can be evaluated in
polynomial time.
We call metaﬁnite structures of this kind arithmetical structures. A
simple arithmetical structure is obtained from an arithmetical structure by
omitting the multiset operations.
By itself, the notion of metaﬁnite structures contains nothing revolution-
ary: they are just a special kind of two-sorted structures. The interesting
feature of metaﬁnite model theory is not just the structures themselves, but
the logics, which access the primary and the secondary part in diﬀerent ways
and are designed so that the approach and methods of ﬁnite model theory
remain meaningful and applicable. An important feature of these logics is
that they contain, besides formulae and terms in the usual sense, a calculus
of weight terms from the primary to the secondary part.
Deﬁnition 3.6.10. Let L be any of the logics for ﬁnite structures, such as
FO, LFP, . . . as described in the previous sections, and let τ = (τa, τr, τw) be a
vocabulary for metaﬁnite structures (where τr may or may not have names for
multiset operations). The appropriate modiﬁcation of L for reasoning about
metaﬁnite structures D = (A, R, W) of vocabulary τ is deﬁned as follows. We
ﬁx a countable set V = {x0, x1, . . .} of variables ranging over elements of the
primary part A only. The point terms (deﬁning functions f : Ak →A), the
weight terms (deﬁning functions w : Ak →R), and the formulae (deﬁning
relations R ⊆Ak) of L[τ] are deﬁned inductively as follows:
(1) Point terms are deﬁned in the usual way, by closing the set of variables
V under application of function symbols from τa.

212
3 Finite Model Theory and Descriptive Complexity
(2) Weight terms can be built by applying weight function symbols from
τw to point terms, and function symbols from τr to previously deﬁned
weight terms. Note that there are no variables ranging over R.
(3) Atomic formulae are equalities of point terms, equalities of weight terms,
expressions Pt1 · · · tr containing relations symbols P ∈τa and point
terms t1, . . . , tr, or expressions Qf1 · · · fr containing predicates Q ∈τr
and weight terms f1, . . . , fr.
(4) All the rules of L for building formulae (via propositional connectives,
quantiﬁers, and other operators) may be applied, taking into account
the condition that only variables from V may be used.
(5) In addition, we have the characteristic function rule: if ϕ(x) is a
formula, then χ[ϕ](x) is a weight term.
(6) If τw contains multiset operations, these provide additional means
for building new weight terms. Let F(x, y) be a weight term, ϕ(x, y)
a formula (both with free variables among x, y), and Γ a multiset
operation. The expression
Γx(F(x, y) : ϕ)
is then a weight term with free variables y. (If ϕ = true, we simplify this
notation to ΓxF(x, y).)
The semantics for (1)–(4) is the obvious one. A term χ[ϕ](x) evaluates
to 1 if ϕ(x) is true, and to 0 otherwise. Finally, let G(y) be a weight term
Γx(F(x, y) : ϕ) formed by application of a multiset operation. The weight
term F(x, y) deﬁnes, on a metaﬁnite structure D = (A, R, W), a function
F D : Ak+m →R. For any ﬁxed tuple b, the collection of values F D(a, b), as
a ranges over those tuples such that ϕ(a, b) is true, forms a ﬁnite multiset
(F : ϕ)D(b) := {{F D(a, b) : a ∈Ak such that D |= ϕ(a, b)}}.
The interpretation of G(b) on D is obtained by applying Γ to this multiset, i.e.
GD(b) := Γ((F : ϕ)D(b)).
Example 3.6.11. (Binary representations.) Consider arithmetic structures
with a primary part of the form A = ({0, . . . , n −1}, <, P) where P is a
unary relation. P is interpreted as a bit sequence u0 · · · un−1 representing
the natural number n−1
i=0 ui2i (where ui = 1 iﬀA |= P(i)). The number
represented by P is deﬁnable by the term

x

χ[Px]

y
(2 : y < x)

.
Example 3.6.12. (Counting elements.) On arithmetic structures, ﬁrst-order
logic can count. For any formula ϕ(x), there is a weight term #x[ϕ(x)]
counting the number of tuples a such that ϕ(a) is true, namely
#x[ϕ(x)] :=

x
χ[ϕ].

3.6 Algorithmic Model Theory
213
3.6.4 Metaﬁnite Spectra
Does descriptive complexity theory generalize in a meaningful way from ﬁnite
to metaﬁnite structures? To give some evidence that such generalizations
are indeed possible and fruitful, we focus here on generalizations of Fagin’s
Theorem to (1) arithmetical structures, and (2) R-structures (see the
examples given above).
Recall that Fagin’s Theorem says that generalized spectra (or, equiv-
alently, the properties of ﬁnite structures that are deﬁnable in existential
second-order logic) coincide with the complexity class NP. To discuss possible
translations to metaﬁnite structures, we need to make precise two notions:
•
The notion of a metaﬁnite spectrum, i.e. a generalized spectrum of
metaﬁnite structures.
•
The
notion
of
complexity
(in
particular,
deterministic
and
non-
deterministic polynomial time) in the context of metaﬁnite structures.
For a ﬁxed structure R, let Mτ[R] denote the class of metaﬁnite structures
with a secondary part R and vocabulary τ = (τa, τr, τw) (where, of course,
τr is the vocabulary of R). We start with two notions of metaﬁnite spectra.
Deﬁnition 3.6.13. A class K ⊆Mτ[R] is a metaﬁnite spectrum if there
exists a ﬁrst-order sentence ψ of a vocabulary τ′ ⊇τ such that D ∈K if and
only if there exists an expansion D′ ∈Mτ ′[R] of D with D′ |= ψ. (Note that
the secondary part is not expanded.) A primary metaﬁnite spectrum is
deﬁned in a similar way, except that only the primary part of the structures is
expanded, and not the set of weight functions. This means that the expanded
structures D′ have the same set of weight functions as D.
These two notions of metaﬁnite spectra correspond to two variants
of existential second-order logic. The more restrictive variant allows
second-order quantiﬁcation over primary relations only, whereas the general
one allows quantiﬁcation over weight functions as well. Thus, a primary
metaﬁnite spectrum is the class of structures D ∈Mτ[R] which are models
of an existential second-order sentence of the form ∃R1 · · · ∃Rmψ, where
R1, . . . , Rm are relation variables over the primary part, and ψ is ﬁrst-order.
Since relations over the primary part can be replaced by their characteristic
functions, a metaﬁnite spectrum in the more general sense is the class of
models of a sentence ∃F1 · · · ∃Fmψ, where the Fi are function symbols ranging
over weight functions. We shall see that both notions of metaﬁnite spectra
capture (suitable variants of) non-deterministic polynomial-time in certain
contexts, but fail to do so in others.
In general, the notion of complexity for problems on metaﬁnite strucures
depends on the computation model used and on the cost (or size) associated
with the elements of the secondary part. For instance, if the secondary part
consists of natural numbers or binary strings, then a natural notion of cost
is given by the number of bits. On the other hand, below we shall study

214
3 Finite Model Theory and Descriptive Complexity
complexity over real numbers with respect to the Blum–Shub–Smale model,
and there every element of R will be treated as a basic entity of cost one.
Let ∥r∥denote the cost of r. For a metaﬁnite structure D = (A, R, W) ∈
Mτ[R], let |D| := |A| and let max D := maxw∈W maxa ∥w(a)∥, the cost of
the maximal weight. Assuming R and τ to be ﬁxed, then ∥D∥, the cost of
representing D, is polynomially bounded in |A| and max D (via a polynomial
that depends only on the vocabulary of D). Since most of the popular com-
plexity classes are invariant under polynomial increase of the relevant input
parameters, it therefore makes sense to measure the complexity in terms of
|D| and max D. For instance, an algorithm on a class of metaﬁnite structures
runs in polynomial time or in logarithmic space if, for every input D, the
computation terminates in at most q(|D|, max D) steps, for some polynomial
q, or uses at most O(log |D| + log max D) of work space, respectively.
We ﬁrst discuss arithmetical structures, as described in Example 3.6.9,
assuming that the cost of natural numbers is given by the length of their
binary representations. So the question is whether, or under what cir-
cumstances, NP is captured by the class of metaﬁnite spectra or primary
metaﬁnite spectra. The original proof of Fagin’s Theorem generalizes to the
case of arithmetical structures with weights that are not too large.
Deﬁnition 3.6.14. A class K of metaﬁnite structures has small weights if
there exists a k ∈N such that max D ≤|D|k for all D ∈K. As max D stands
for the cost of the largest weight this means that the values of the weights
are bounded by a function 2p(|D|) for some polynomial p.
We obtain the following ﬁrst generalization of Fagin’s result.
Theorem 3.6.15 (Gr¨adel and Gurevich).
Let K ⊆Mτ[N] be a class of
arithmetical structures with small weights which is closed under isomorphisms.
The following are equivalent:
(i) K is in NP.
(ii) K is a primary generalized spectrum.
Proof. It is obvious that (ii) implies (i). The converse can be reduced to
Fagin’s Theorem as follows. We assume that for every structure D = (A, N, W)
in K, we have that max D ≤nk, where n = |D| = |A|; further, we suppose
without loss of generality, that an ordering < on A is available (otherwise
we expand the vocabulary with a binary relation < and add a conjunct
β(<) asserting that < is a linear order). We can then identify Ak with the
initial subset {0, . . . , nk −1} of N, viewed as bit positions of the binary
representations of the weights of D. With every D ∈K we associate a ﬁnite
structure Df by expanding the primary part A as follows: for every weight
function w ∈W of arity j, we add a new relation Pw of arity j + k, where
Pw := {(a, t) : the tth bit of w(a) is 1}.

3.6 Algorithmic Model Theory
215
Then K is in NP if and only if Kf = {Df : D ∈K} is an NP-set of ﬁnite
structures, and, in fact, we can choose the encodings in such a way that D
and Df are represented by the same binary string. Thus, if K is in NP, then,
by Fagin’s Theorem, Kf is a generalized spectrum, deﬁned by a ﬁrst-order
sentence ψ.
As in Example 3.6.11, one can construct a ﬁrst-order sentence α (whose
vocabulary consists of the weight functions w ∈τw and the corresponding
primary relations Pw) which expresses the assertion that the Pw encode the
weight functions w in the sense deﬁned above. Then ψ ∧α is a ﬁrst-order
sentence witnessing that K is a primary metaﬁnite spectrum.
□
The above result also holds for arithmetical structures without multiset
operations. However, without the restriction that the weights are small, it
is no longer true that every NP-set is a primary metaﬁnite spectrum. If
we have inputs with huge weights compared with the primary part, then
relations over the primary part cannot code enough information to describe
computations that are bounded by a polynomial in the length of the weights.
It is tempting to use unrestricted metaﬁnite spectra instead. However,
metaﬁnite spectra in the general sense capture a much larger class than NP.
Theorem 3.6.16 (Gr¨adel and Gurevich). On arithmetical structures,
metaﬁnite spectra capture the recursively enumerable sets.
We sketch the proof here. It is not diﬃcult to show that every metaﬁnite
spectrum of arithmetical structures is recursively enumerable. For the
converse, we ﬁrst note that any tuple a ∈Nk can be viewed as an arithmetical
structure with an empty primary vocabulary and k nullary weight functions
a1, . . . , ak. Thus an arithmetical relation S
⊆Nk can be viewed as a
special class of arithmetical structures. We show ﬁrst that every recursively
enumerable set S ⊆Nk is a metaﬁnite spectrum. In particular, there exist
undecidable metaﬁnite spectra.
By Matijasevich’s Theorem (see [83]), every recursively enumerable set
S ⊆Nk is Diophantine, i.e. can be represented as
S = {a ∈Nk : there exists b1, . . . , bm ∈N such that Q(a, b) = 0}
for some polynomial Q ∈Z[x1, . . . , xk, y1, . . . , ym]. Let P, P ′ ∈N[x, y] such
that Q(x, y) = P(x, y) −P ′(x, y). Thus S is a metaﬁnite spectrum; the
desired ﬁrst-order sentence uses additional weight functions b1, . . . , bm and
asserts that P(a, b) = P ′(a, b).
This can be extended to any recursively enumerable class of arithmetical
structures, with an arbitrary vocabulary. To see this, we encode structures
D ⊆Mτ[N] by tuples c(D) ∈Nk, where k depends only on τ. (In fact, it is
no problem to reduce k to 1.) Similarly to the case of ﬁnite structures, an
encoding involves the selection of a linear order on the primary part. In fact,
it is often more convenient to have a ranking of the primary part rather
than just a linear ordering.

216
3 Finite Model Theory and Descriptive Complexity
Deﬁnition 3.6.17. Suppose that R contains a copy of (N, <). A ranking of a
metaﬁnite structure D = (A, R, W) is a bijection r : A →{0, . . ., n −1} ⊆R.
A class K ⊆Mτ[R] is ranked if τ contains a weight function r whose
interpretation on every D ∈K is a ranking.
The Coding Lemma for arithmetical structures [48] says that for every
vocabulary τ there exists an encoding function that associates with every
ranked arithmetical τ-structure D a tuple code(D) ∈Nk with the following
properties:
(1) code is deﬁnable by ﬁrst-order terms.
(2) The primary part and the weight functions of D can be reconstructed
from code(D) in polynomial time.
(3) There exists a polynomial p(n, m) such that ci(D) ≤2p(|D|,max D) for
every i ≤k.
Now let K ⊆Mτ[N] be recursively enumerable. The set
code(K) := {code(D, r) : D ∈K, r is a ranking of D} ⊆Nk
is then also recursively enumerable and therefore Diophantine. The desired
ﬁrst-order sentence ψ uses, besides the symbols of τ, a unary weight function
r and nullary weight functions b1, . . . , bm and expresses the assertions (i) that
r is a ranking and (ii) that Q(code(D, r), b)) = 0 for a suitable polynomial
Q ∈Z[x1, . . . , xk, y1, . . . , ym] deﬁning code(K).
3.6.5 Descriptive Complexity over the Real Numbers
There are other contexts in which metaﬁnite spectra do indeed capture (a
suitable notion of) non-deterministic polynomial time. An important example
are computations over the real numbers based on the model of Blum, Shub,
and Smale.
Computation over R
In 1989 Blum, Shub, and Smale [15] introduced a model for computations
over the real numbers (and other rings as well), which is now usually called
the BSS machine. The important diﬀerence from, say, the Turing model is
that real numbers are treated as basic entities and that arithmetic operations
on the reals are performed in a single step, independently of the magnitude or
complexity of the numbers involved. In particular, the model abstracts from
the problems that in actual computers real numbers have to be approximated
by bit sequences, that the complexity of arithmetic operations depends on
the length of these approximate representations, that rounding errors occur,
and that exact testing for 0 is impossible in practice. Similar notions of
computations over arbitrary ﬁelds or rings had been investigated earlier

3.6 Algorithmic Model Theory
217
in algebraic complexity theory (see [22] for a comprehensive treatment).
A novelty of the approach of Blum, Shub, and Smale is that their model
is uniform (for all input lengths) whereas the ideas explored in algebraic
complexity (such as straight-line programs, arithmetic circuits, and decision
trees) are typically non-uniform. One of the main purposes of the BSS
approach was to create a uniform complexity theory dealing with problems
that have an analytical and topological background, and to show that certain
problems remain hard even if arbitrary reals are treated as basic entities.
Many basic concepts and fundamental results of classical computability
and complexity theory reappear in the BSS model: the existence of universal
machines, the classes PR and NPR (real analogues of P and NP), and the
existence of NPR-complete problems. Of course, these ideas appear in a
diﬀerent form, with a strong analytical ﬂavour: typical examples of unde-
cidable, recursively enumerable sets are complements of certain Julia sets,
and the ﬁrst problem that was shown to be NPR-complete is the question of
whether a given multivariate polynomial of degree four has a real root [15].
As in the classical setting, all problems in the class NPR are decidable within
exponential time (but this is not as trivial as in the classical case), and the
PR versus NPR question is one of the major open problems.
However, there also are many diﬀerences between classical and real
complexity theory. Just to mention a few, we note that the meaning of space
resources seems to be very diﬀerent, that certain separation results between
complexity classes can be established (such as NCR ⊊PR and NPR ⊊EXPR)
whose analogues in the classical theory are open, and that some discrete prob-
lems seem to change their complexity behaviour when considered in the BSS
model. For a detailed treatment we refer the interested reader to the book [14].
The BSS Model
Let R∗:= 
k∈N Rk, or (almost) equivalently, the set of functions X : N →R
with X(n) = 0 for all but ﬁnitely many n. For any X ∈R∗, we call
|X| := max{n : X(n) ̸= 0} the length of X. Note that R∗× R∗can be
identiﬁed with R∗in a natural way by concatenation. A Blum–Shub–Smale
machine – in what follows called a BSS machine – is essentially a Random
Access Machine over R which can evaluate rational functions at unit cost
and whose registers can store arbitrary real numbers.
Deﬁnition 3.6.18. A BSS machine M over R is given by a ﬁnite set I of
instructions labelled by 0, . . . , N. The input and output spaces are subsets of
R∗. A conﬁguration is a quadruple (k, r, w, x) ∈I × N × N × R∗, where k is
the instruction currently being executed, r and w are the numbers of the so
called ‘copy registers’ (see below) and x describes the content of the registers
of the machine. Given an input x ∈R∗, the computation is started with a
conﬁguration (0, 0, 0, x). If a conﬁguration (k, r, w, x) with k = N is reached,
the computation stops; in that case the value of x is the output computed
by the machine. The instructions of M are of the following types:

218
3 Finite Model Theory and Descriptive Complexity
•
Computation. An instruction k of this type performs an update x0 ←gk(x)
of the ﬁrst register, where gk is a rational function on Rm (for some m).
Simultaneously, the copy registers may be updated by rules r ←r + 1 or
r ←0, and similarly for w. The other registers remain unchanged. The
next instruction will be k + 1.
•
Branch. k: if x0 ≥0 goto ℓelse goto k + 1. The contents of the registers
remain unchanged.
•
Copy. k : xw ←xr, i.e. the content of the ‘read register’ is copied into the
‘write register’. The next instruction is k + 1; all other registers remain
unchanged.
A set L ⊆R∗is in PR if there exists a BSS machine whose running
time on every X ∈R∗is bounded by a polynomial in |X|, and which
accepts X if and only if X ∈L. The analogue of NP is the class NPR.
A set L ⊆R∗is in NPR if there exists a set L′ ∈PR and a constant
k such that L = {X ∈R∗: (∃Y
∈R∗)(|Y | ≤|X|k ∧(X, Y ) ∈L′)}.
Equivalently, NPR can be deﬁned as the class of problems over R∗that are
decidable in polynomial time by a non-deterministic BSS machine, i.e. a
BSS machine that can non-deterministically guess real numbers Y ∈R at
unit cost.
Encodings.
Recall that R-structures are metaﬁnite structures D
=
(A, R, W) with a second sort R = (R, +, −, ·, /, ≤, (cr)r∈R). We want to relate
decision problems for R-structures (described by logical formulae) to decision
problems on R∗(decided by BSS-machines). We ﬁrst consider an example.
Example 3.6.19. (4-Feasibility.)
The ﬁrst problem that was shown to be
NPR-complete was the problem of whether a real polynomial of degree at
most four in n unknowns (where n varies with the input) has a real zero.
This problem can be considered as a decision problem on R-structures as
follows. Let A = {0, . . . , n}. The coeﬃcients of a homogeneous polynomial
g ∈R[X0, . . . , Xn] can be coded via a function C : A4 →R, such that
g =

0≤i,j,k,ℓ≤n
C(i, j, k, ℓ)XiXjXkXℓ.
We
obtain
an
arbitrary
(not
necessarily
homogeneous)
polynomial
f ∈R[X1, . . . , Xn] of degree four by setting X0 = 1 in g. Thus, every
multivariate polynomial f of degree at most four is represented by the
R-structure (A, R, {C}), where A = ({0, . . . , n}, <, 0, n) and C is a function
from A4 into R.
Observe that R∗can be viewed as the class of all R-structures where the
primary part is a ﬁnite linear order ({0, . . . , n −1}, <), and W consists of a
single unary function X : {0, . . . , n −1} →R. Hence decision problems on R∗
can be regarded as a special case of decision problems on R-structures (in the

3.6 Algorithmic Model Theory
219
same way as words can be considered as special cases of ﬁnite structures).
Conversely, R-structures D = (A, R, W) can be encoded in R∗. We choose a
ranking on A and replace all functions and relations in the primary part by
the appropriate characteristic functions χ : Ak →{0, 1} ⊆R. This gives a
structure whose primary part is a plain set A, with functions X1, . . . , Xt of
the form Xi : Ak →R and with the ranking r : A →R. Each of the functions
Xi can be represented by a tuple x0, . . . , xm−1 ∈Rm, where m = |A|k
and xi = X(a(i)), and where a(i) is the ith tuple in Ak with respect to
the lexicographic order induced by r. The concatenation of these tuples
gives an encoding code(D, r) ∈R∗(which depends on the ranking r that
was chosen).
Obviously, for structures D of a ﬁxed ﬁnite signature, the length of
code(D, r) is bounded by some polynomial nℓ, where n = |D| and ℓdepends
only on the signature. Thus we can also view code(D, r) = (x0, . . . , xnℓ−1)
as a single function XD : Aℓ→R, where X(a(i)) = xi for all i < nℓ.
Thus, encoding an R-structure in R∗basically means representing the whole
structure by a single function (of appropriate arity) from {0, . . . , n −1}
into R.
Furthermore, this encoding is ﬁrst-order deﬁnable in the following
sense.
Lemma 3.6.20. For every signature τ, there is a ﬁrst-order formula β(X, r)
of signature τ ∪{X, r} such that, for all R-structures D of signature τ, for
all rankings r, and for all functions X,
(D, X, r) |= β(X, r)
iﬀ
X = code(D, r).
As in the case of ﬁnite structures, we say that a class K of R-structures
is in the complexity class PR or NPR if the set of its encodings is. Recall
that a metaﬁnite spectrum of R-structures is a set K of R-structures that
is deﬁnable by an existential second-order sentence ∃Y1 · · · ∃Yrψ, where ψ
is ﬁrst-order and the variables Yi range over weight functions Yi : Ak →R.
Fagin’s Theorem now has the following analogue in the real setting.
Theorem 3.6.21 (Gr¨adel and Meer). Let K be a class of R-structures.
Then K ∈NPR if and only if K is a metaﬁnite spectrum.
Proof. It is easy to see that metaﬁnite spectra are in NPR. Suppose that
ψ = ∃Y1 · · · Yrϕ. Given an input structure D, we guess assignments for all
functions Yi and evaluate ϕ on (D, Y1, . . . , Yr) in polynomial time.
For the converse, let K ∈NPR and let K′ be the corresponding problem
in PR, with K = {D : ∃Y ((D, Y ) ∈K′)}. Let M be a polynomial-time BSS
machine deciding K′, and let m be a natural number such that M stops
on encodings of (D, Y ) after less than nm steps and uses at most nm −3
registers, where n = |D|.

220
3 Finite Model Theory and Descriptive Complexity
We ﬁrst suppose that we have a ranking r : A →R available. From r, the
induced (lexicographic) ranking rm : Am →R is ﬁrst-order deﬁnable: we can
identify the element in A of maximal rank and thus have the number term n
available; we can then use rm(t) as an abbreviation for
r(t1)nm−1 + · · · r(tm−1)n + r(tm).
We can then identify Am with the initial subset {0, . . . , nm −1} of N. Thus, in
the formulae to be constructed below, m-tuples t = t1, . . . , tm of variables are
considered to range over natural numbers t < nm. Conditions such as t = 0
or t = s + s′ can then be expressed by ﬁrst-order formulae of vocabulary {r}.
The computation of M for a given input code(D, Y ) can be represented
by a function Z : A2m →R as follows:
•
Z(0, t) is the instruction executed by M at time t.
•
Z(1, t) and Z(2, t) are the indices of the read and write registers of M at
time t.
•
Z(j + 3, t) is the content of register j at time t.
We construct a ﬁrst-order formula ψ with the property that, for all ranked
structures (D, Y ) and all Z, we have that (D, Y, Z) |= ψ iﬀZ represents an
accepting computation of M for code(D, Y ).
We ﬁrst have to express the assertion that at time t = 0, the function Z
encodes the input conﬁguration of M on (D, Y ). Thus we need a subformula
stating that Z(i, 0) = 0 for i = 0, 1, 2 and that the values Z(j + 3, 0) encode
the input (D, Y ). By Lemma 3.6.20 this can be expressed in ﬁrst-order logic.
Second, we have to ensure that for every t < nm −1, if the sequence
⟨Z(j, t) : j = 0, . . . , nm −1⟩represents a conﬁguration of M, then the
sequence of values Z(j, t + 1) represents the successor conﬁguration. The
formula asserting this has the form
∀t
N
	
k=0
(Z(0, t) = k →ϕk)
where ϕk describes transitions performed by the instruction k.
Consider for example a computation instruction k : x0 ←g(x0, . . . , xℓ),
and assume in addition that it increases the index of the read register by 1
and sets the index of the write register back to 0. The formula ϕk then has
to express the following:
•
Z(0, t + 1) = k + 1 (the next instruction is k + 1);
•
Z(1, t + 1) = Z(1, t) + 1 (the read register index is increased by 1);
•
Z(2, t + 1) = 0 (the write register index is set back to 0);
•
Z(3, t+1) = g(Z(3, t), Z(4, t), . . . , Z(ℓ+3, t)) (into register 0, M writes the
result of applying the rational function g to the register contents at time t).
•
Z(j, t + 1) = Z(j, t) for all j > 3 (the other registers remain unchanged).

3.6 Algorithmic Model Theory
221
Clearly, these conditions are ﬁrst-order expressible. It should be noted that
whenever f0, . . . , fℓare number terms and g : Rℓ→R is a rational function,
then g(f0, . . . , fℓ) is also a number term.
For another example illustrating the explicit use of the embedding func-
tion, consider a copy instruction k : xw ←xr. Here the formula has to express
(besides the updating of the instruction number, etc. which is done as above),
the assertion that the content of the register Z(2, t) at time t+1 is the same as
the content of the register Z(1, t) at time t. This is expressed by the formula
∀j∀j
′([Z(1, t) = rm(j) ∧Z(2, t) = rm(j
′)]
→Z(j
′ + 3, t + 1) = Z(j + 3, t)).
To express the assertion that M accepts its input, we just have to say
that Z(3, nm −1) = 1 (by convention, the result of the computation, if it is
a single number, is stored in register 0).
Combining all these subformulae in the appropriate way, we obtain the
desired formula ψ. It then follows that for all structures D,
D ∈K
iﬀD |= (∃Y )(∃Z)ψ,
which proves the theorem for the case of ranked structures.
Finally, we do away with the assumption that the input structures are
ranked. If no ranking is given on the input structures D, we can introduce
one by existentially quantifying over the function r and adding a conjunct
α(r) which asserts that r is one–one and that, for all t with r(t) ̸= 0, there
exists an element s such that r(s) + 1 = r(t). It follows that
K = {D : D |= (∃r)(∃Y )(∃Z)(α ∧ψ)}.
□
Example 3.6.22. (Logical
description
of
4-Feasibility.)
An
existential
second-order sentence for the 4-feasibility problem quantiﬁes two functions
X : A →R and Y : A4 →R where X(1), . . . , X(n) describes the zero and
Y (u) is the partial sum of all monomials up to u ∈A4 in f(X1, . . . , Xn)
(according to the lexicographical order on A4). Thus the 4-feasibility problem
is described by the sentence
ψ := (∃X)(∃Y )

Y (0) = C(0) ∧Y (n) = 0 ∧∀u(u ̸= 0 →
Y (u) = Y (u −1) + C(u) 4
i=1 X(ui))

.
Indeed, D |= ψ if and only if the polynomial f of degree four deﬁned by D
has a real zero.

222
3 Finite Model Theory and Descriptive Complexity
Capturing Results for Other Complexity Classes
By combining the general ideas of descriptive complexity theory on ﬁnite
structures with the approach described here, one can ﬁnd logical charac-
terizations for many other complexity levels, notably for polynomial time,
provided that the given R-structures are ranked (i.e. an ordering on the ﬁnite
part is available). This is carried out in some detail in [30, 53].
Acknowledgements
I am grateful for comments, corrections, and other contributions to Dietmar
Berwanger, Achim Blumensath, Anuj Dawar, Phokion Kolaitis, Stephan
Kreutzer, Antje Nowack, and Martin Otto.
3.7 Appendix: Alternating Complexity Classes
Alternating algorithms are a generalization of non-deterministic algorithms,
based on two-player games. Indeed, one can view non-deterministic algorithms
as the restriction of alternating algorithms to solitaire (i.e. one-player) games.
Since complexity classes are mostly deﬁned in terms of Turing machines, we
focus on the model of alternating Turing machines. But note that alternating
algorithms can be deﬁned in terms of other computational models, also.
Deﬁnition 3.7.1. An alternating Turing machine is a non-deterministic
Turing machine whose state set Q is divided into four classes Q∃, Q∀,
Qacc, and Qrej. This means that there are existential, universal, accepting
and rejecting states. States in Qacc ∪Qrej are ﬁnal states. A conﬁguration of
M is called existential, universal, accepting, or rejecting according to its state.
The computation graph GM,x of an alternating Turing machine M for
an input x is deﬁned in the same way as for a non-deterministic Turing
machine. Nodes are conﬁgurations (instantaneous descriptions) of M, there is
a distinguished starting node C0(x) which is the input conﬁguration of M for
input x, and there is an edge from conﬁguration C to conﬁguration C′ if, and
only if, C′ is a successor conﬁguration of C. Recall that for non-deterministic
Turing machines, the acceptance condition is given by the Reachability
problem: M accepts x if, and only if, in the graph GM,x some accepting
conﬁguration Ca is reachable from C0(x). For alternating Turing machines,
acceptance is deﬁned by the Game problem (see Sect. 3.1.3): the players
here are called ∃and ∀, where ∃moves from existential conﬁgurations and
∀from universal ones. Further, ∃wins at accepting conﬁgurations and loses
at rejecting ones. By deﬁnition, M accepts x if, and only if, Player ∃has a
winning strategy from C0(x) for the game on GM,x.

3.7 Appendix: Alternating Complexity Classes
223
Complexity Classes
Time and space complexity are deﬁned as for nondeterministic Turing
machines. For a function F : N →R, we say that an alternating Turing
machine M is F-time-bounded if for all inputs x, all computation paths from
C0(x) terminate after at most F(|x|) steps. Similarly, M is F-space-bounded
if no conﬁguration of M that is reachable from C0(x) uses more than F(|x|)
cells of work space. The complexity classes ATIME(F) and ASPACE(F)
contain all problems that are decidable by, respectively, F-time bounded and
F-space bounded alternating Turing machines.
The following classes are of particular interest:
•
ALOGSPACE = ASPACE(O(log n)),
•
APTIME = 
d∈N ATIME(nd),
•
APSPACE = 
d∈N ASPACE(nd).
Alternating Versus Deterministic Complexity
There is a general slogan that parallel time complexity coincides with
sequential space complexity. Indeed, by standard techniques of complexity
theory, one can easily show that, for well-behaved (i.e. space-constructible)
functions F, ATIME(F) ⊆DSPACE(F 2) and DSPACE(F) ⊆NSPACE(F)
⊆ATIME(F 2) (see [9] for details). In particular,
•
APTIME = PSPACE;
•
AEXPTIME = EXPSPACE.
On the other hand, alternating space complexity corresponds to exponen-
tial deterministic time complexity.
Theorem 3.7.2. For any space-constructible function F(n) ≥log n, we have
that ASPACE(F) = DTIME(2O(F )).
Proof. The proof is closely associated with the Game problem. For any
F-space-bounded alternating Turing machine M, one can, given an input x,
construct the computation graph GM,x in time 2O(F (|x|) and then solve the
Game problem in order to decide the acceptance of x by M.
For the converse, we shall show that for any G(n) ≥n and any constant
c, DTIME(G) ⊆ASPACE(c · log G).
Let L ∈DTIME(G). There is then a deterministic one-tape Turing
machine M that decides L in time G2. Let Γ = Σ ∪(Q × Σ) ∪{∗} and
t = G2(n). Every conﬁguration C = (q, i, w) (in a computation on some input
of length n) can be described by a word
c = ∗w0 · · · wi−1(qwi)wi+1 · · · wt∗∈Γ t+2.
The ith symbol of the successor conﬁguration depends only on the symbols
at positions i −1, i, and i + 1. Hence, there is a function fM : Γ 3 →Γ such

224
3 Finite Model Theory and Descriptive Complexity
that, whenever symbols a−1, a0, and a1 are at positions i −1, i and i + 1 of
some conﬁguration c, the symbol fM(a−1, a0, a1) will be at position i of the
successor conﬁguration c′.
The following alternating algorithm A decides L:
Input: x
Existential step:
guess s ≤t,
guess (q+a) ∈Qacc × Σ , i ∈{0, . . ., s}
b := (q+a)
for j = 1 . . . s do
Existential step: guess a−1, a0, a1 ∈Γ 3
verify that fM(a−1, a0, a1) = b. If not, reject.
Universal step:
choose k ∈{−1, 0, 1}
b := ak
i := i + k
od
if ith symbol of input conﬁguration of M on x equals b then accept
else reject.
The algorithm A needs space O(log G(n)). If M accepts the input x, then
Player ∃has the following winning strategy for the game on CA,x: the value
chosen for s is the time at which M accepts x, and (q+a), i are chosen so that
the conﬁguration of M at time s is of the form ∗w0 · · · wi−1(q+a)wi+1 · · · wt∗.
At the jth iteration of the loop (that is, at conﬁguration s −j), the symbols
at positions i −1, i, i + 1 of the conﬁguration of M at time s −j are chosen
for a−1, a0, a1.
Conversely, if M does not accept the input x, the ith symbol of the conﬁg-
uration at time s is not (q+a). The following holds for all j: if, in the jth iter-
ation of the loop, Player ∃chooses a−1, a0, a1, then either f(a−1, a0, a1) ̸= b,
in which case Player ∃loses immediately, or there is at least one k ∈{−1, 0, 1}
such that the (i + k)th symbol of the conﬁguration at time s −j diﬀers from
ak. Player ∀then chooses exactly this k. At the end, ak will then be diﬀerent
from the ith symbol of the input conﬁguration, so Player ∀wins.
Hence A accepts x if, and only if, M does so.
□
In particular, it follows that
•
ALOGSPACE = PTIME;
•
APSPACE = EXPTIME.
The
relationship
between
the
major
deterministic
and
alternating
complexity classes is summarized by the following diagram:
LOGSPACE ⊆
PTIME
⊆PSPACE ⊆EXPTIME ⊆EXPSPACE ⊆. . .
||
||
||
||
ALOGSPACE ⊆APTIME ⊆APSPACE ⊆AEXPTIME ⊆. . .

References
225
Alternating Logarithmic Time
For time bounds F(n) < n, the standard model of alternating Turing
machines needs to be modiﬁed a little by an indirect access mechanism. The
machine writes down, in binary, an address i on an separate index tape to
access the ith symbol of the input. Using this model, it makes sense to deﬁne,
for instance, the complexity class ALOGTIME = ATIME(O(log n)).
Example 3.7.3. Construct an ALOGTIME algorithm for the set of palin-
dromes (i.e., words that are same when read from right to left and from left
to right).
Important examples of problems in ALOGTIME are
•
the model-checking problem for propositional logic;
•
the data complexity of ﬁrst-order logic.
The results mentioned above relating alternating time and sequential
space hold also for logarithmic time and space bounds. Note, however, that
these do not imply that ALOGTIME = LOGSPACE, owing to the quadratic
overheads. It is known that ALOGTIME ⊆LOGSPACE, but the converse
inclusion is an open problem.
References
1. S. Abiteboul, R. Hull, and V. Vianu.
Foundations of Databases.
Addison-
Wesley, 1995.
2. S. Abiteboul and V. Vianu.
Datalog extensions for database queries and
updates. Journal of Computer and System Sciences, 43:62–124, 1991.
3. H. Andr´eka, J. van Benthem, and I. N´emeti. Modal languages and bounded
fragments of predicate logic. Journal of Philosophical Logic, 27:217–274, 1998.
4. A. Arnold.
The mu-calculus alternation-depth is strict on binary trees.
RAIRO Informatique Th´eorique et Applications, 33:329–339, 1999.
5. A. Arnold and D. Niwi´nski. Rudiments of μ-Calculus. North-Holland, 2001.
6. C. Ash and J. Knight.
Computable Structures and the Hyperarithmetical
Hierarchy. Elsevier, 2000.
7. G. Asser. Das Repr¨asentantenproblem im Pr¨adikatenkalk¨ul der ersten Stufe
mit Identit¨at.
Zeitschrift f¨ur Mathematische Logik und Grundlagen der
Mathematik, 1:252–263, 1955.
8. L. Babai, P. Erd¨os, and S. Selkow.
Random graph isomorphism.
SIAM
Journal of Computing, 9:628–635, 1980.
9. J. Balc´azar, J. D´ıaz, and J. Gabarr´o. Structural Complexity II. Springer, 1990.
10. M. Benedikt, L. Libkin, T. Schwentick, and L. Segouﬁn. Deﬁnable relations and
ﬁrst-order query languages over strings. Journal of the ACM, 50:694–751, 2003.
11. D. Berwanger and A. Blumensath. The monadic theory of tree-like structures.
In E. Gr¨adel, W. Thomas, and T. Wilke, editors, Automata, Logic, and
Inﬁnite Games. Springer, 2002.

226
3 Finite Model Theory and Descriptive Complexity
12. H. Bj¨orklund, S. Sandberg, and S. Vorobyov.
Memoryless determinacy of
parity and mean payoﬀgames: A simple proof. Theoretical Computer Science,
310:365–378, 2003.
13. A. Blass and Y. Gurevich. Existential ﬁxed point logic. In E. B¨orger, editor,
Computation Theory and Logic, Lecture Notes in Computer Science, No. 270,
pages 20–36. Springer, 1987.
14. L. Blum, F. Cucker, M. Shub, and S. Smale. Complexity and Real Computation.
Springer, 1998.
15. L. Blum, M. Shub, and S. Smale. On a theory of computation and complexity
over the real numbers. Bulletin of AMS, 21:1–46, 1989.
16. A. Blumensath. Automatic structures. Diplomarbeit, RWTH Aachen, 1999.
17. A. Blumensath. Preﬁx-recognisable graphs and monadic second-order logic.
Technical Report AIB-06-2001, RWTH Aachen, 2001.
18. A. Blumensath and E. Gr¨adel.
Automatic structures.
In Proc. 15th IEEE
Symp. on Logic in Computer Science, pages 51–62, 2000.
19. A. Blumensath and E.
Gr¨adel.
Finite presentations of inﬁnite structures:
Automata and interpretations.
Theory of Computing Systems, 37:641–674,
2004.
20. J. Bradﬁeld. The modal μ-calculus alternation hierarchy is strict. Theoretical
Computer Science, 195:133–153, 1998.
21. J. Bradﬁeld and C. Stirling.
Modal logics and mu-calculi.
In J. Bergstra,
A. Ponse, and S. Smolka, editors, Handbook of Process Algebra, pages 293–332.
Elsevier, 2001.
22. P. B¨urgisser, M. Clausen, and A. Shokrollahi. Algebraic Complexity Theory.
Springer, 1997.
23. J. Cai, M. F¨urer, and N. Immerman. An optimal lower bound on the number
of variables for graph identiﬁcation. Combinatorica, 12:389–410, 1992.
24. A. Carayol and S. W¨ohrle. The caucal hierarchy of inﬁnite graphs in terms
of logic and higher-order pushdown automata.
In Proceedings of FSTTCS,
Lecture Notes in Computer Science, No. 2914, Springer, 2003.
25. D. Caucal. On inﬁnite transition graphs having a decidable monadic theory.
In Automata, Languages and Programming, 23rd International Colloquium,
ICALP96, Lecture Notes in Computer Science, No. 1099, pages 194–205.
Springer, 1996.
26. D. Caucal.
On inﬁnite terms having a decidable monadic theory.
In Pro-
ceedings of 27th International Symposium on Mathematical Foundations of
Computer Science MFCS 02, Lecture Notes in Computer Science, No. 2420,
pages 165–176. Springer, 2002.
27. B. Courcelle. The monadic second-order logic of graphs II: Inﬁnite graphs of
bounded width. Mathematical Systems Theory, 21:187–221, 1989.
28. B. Courcelle.
The monadic second-order logic of graphs IX: Machines and
their behaviours. Theoretical Computer Science, 151:125–162, 1995.
29. B. Courcelle and I. Walukiewicz. Monadic second-order logic, graph coverings
and unfoldings of transition systems.
Annals of Pure and Applied Logic,
92:35–62, 1998.
30. F. Cucker and K. Meer. Logic which capture complexity classes over the reals.
Journal of Symbolic Logic, 64:363–390, 1999.
31. E. Dahlhaus.
Skolem normal forms concerning the least ﬁxed point.
In
E. B¨orger, editor, Computation Theory and Logic, Lecture Notes in Computer
Science, No. 270, pages 101–106, Springer, 1987.

References
227
32. A. Dawar. Generalized quantiﬁers and logical reducibilities. Journal of Logic
and Computation, 5:213–226, 1995.
33. A. Dawar, E. Gr¨adel, and S. Kreutzer.
Inﬂationary ﬁxed points in modal
logic. ACM Transactions on Computational Logic, 5:282–315, 2004.
34. A. Dawar, E. Gr¨adel, and S. Kreutzer. Backtracking games and inﬂationary
ﬁxed points. Theoretical Computer Science, 350:174–187, 2006.
35. A. Dawar and L. Hella.
The expressive power of ﬁnitely many generalized
quantiﬁers. Information and Computation, 123:172–184, 1995.
36. W. F. Dowling and J. H. Gallier.
Linear-time algorithms for testing the
satisﬁability of propositional horn formulae. Journal of Logic Programming,
1(3):267–284, 1984.
37. S. Dziembowski. Bounded-variable ﬁxpoint queries are PSPACE-complete. In
10th Annual Conference on Computer Science Logic CSL 96, Selected papers,
Lecture Notes in Computer Science, No. 1258, pages 89–105. Springer, 1996.
38. H.-D. Ebbinghaus and J. Flum.
Finite Model Theory, 2nd edition edition.
Springer, 1999.
39. A. Ehrenfeucht and J. Mycielski. Positional strategies for mean payoﬀgames.
International Journal of Game Theory, 8:109–113, 1979.
40. A. Emerson and C. Jutla. Tree automata, mu-calculus and determinacy. In
Proc. 32nd IEEE Symp. on Foundations of Computer Science, pages 368–377,
1991.
41. D. Epstein, J. Cannon, D. Holt, S. Levy, M. Paterson, and W. Thurston.
Word Processing in Groups. Jones and Bartlett, Boston, 1992.
42. Yu. L. Ershov, S. S. Goncharov, A. Nerode, and J. B. Remmel. Handbook of
Recursive Mathematics. North-Holland, 1998.
43. R. Fagin.
Generalised ﬁrst order spectra and polynomial time recognizable
sets. In R. Karp, editor, Complexity of Computation. SIAM-AMS Proceedings
7, pages 43–73, 1974.
44. B. Farb. Automatic groups: A guided tour. L’Enseignement Math´ematique,
38:291–313, 1992.
45. G. Gottlob, E. Gr¨adel, and H. Veith. Datalog LITE: A deductive query lan-
guage with linear time model checking. ACM Transactions on Computational
Logic, 3:42–79, 2002.
46. E. Gr¨adel.
On transitive closure logic.
In Proceedings of 5th Workshop on
Computer Science Logic CSL 91, Lecture Notes in Computer Science, No. 626,
pages 149–163, Springer, 1991.
47. E. Gr¨adel. Capturing complexity classes by fragments of second-order logic.
Theoretical Computer Science, 101:35–57, 1992.
48. E. Gr¨adel and Y. Gurevich.
Metaﬁnite model theory.
Information and
Computation, 140:26–81, 1998.
49. E. Gr¨adel, Y. Gurevich, and C. Hirsch. The complexity of query reliability,
17th ACM Symposium on Principles of Database Systems PODS 98, ACM
Press, 1998.
50. E. Gr¨adel and A. Malmstr¨om. 0-1 laws for recursive structures. Archive of
Mathematical Logic, 38:205–215, 1999.
51. E. Gr¨adel and G. McColm. On the power of deterministic transitive closures.
Information and Computation, 119:129–135, 1995.
52. E. Gr¨adel and G. McColm. Hierarchies in transitive closure logic, stratiﬁed dat-
alog and inﬁnitary logic. Annals of Pure and Applied Logic, 77:166–199, 1996.

228
3 Finite Model Theory and Descriptive Complexity
53. E. Gr¨adel and K. Meer. Descriptive complexity theory over the real numbers.
In J. Renegar, M. Shub, and S. Smale, editors, Mathematics of Numerical
Analysis: Real Number Algorithms, Lectures in Applied Mathematics No. 32,
pages 381–403. AMS, 1996.
54. E. Gr¨adel and M. Otto.
Inductive deﬁnability with counting on ﬁnite
structures. Computer Science Logic, 6th Workshop, CSL ‘92, Selected Papers,
Lecture Notes in Computer Science, No. 702, pages 231–247, Springer, 1993.
55. E. Gr¨adel and M. Otto. On logics with two variables. Theoretical Computer
Science, 224:73–113, 1999.
56. E. Gr¨adel, W. Thomas, and T. Wilke, editors. Automata, Logics, and Inﬁnite
Games. Lecture Notes in Computer Science No. 2500. Springer, 2002.
57. R. Greenlaw, J. Hoover, and W. Ruzzo.
Limits to Parallel Computation.
P-Completeness Theory. Oxford University Press, 1995.
58. M. Grohe. Fixed-point logics on planar graphs. In Proc. 13th IEEE Symp. on
Logic in Computer Science, pages 6–15, 1998.
59. M. Grohe. Isomorphism testing for embeddable graphs through deﬁnability.
In Proc. 32nd ACM Symp. on Theory of Computing, pages 63–72, 2000.
60. M. Grohe and J. Mari˜no. Deﬁnability and descriptive complexity on databases
of bounded tree-width. In Proceedings of ICDT 99, Lecture Notes in Computer
Science, No. 1540, pages 70–82, Springer, 1999.
61. Y. Gurevich. Logic and the challenge of computer science. In E. B¨orger, edi-
tor, Current Trends in Theoretical Computer Science, pages 1–57. Computer
Science Press, 1988.
62. Y. Gurevich and L. Harrington. Trees, automata and games. In Proceedings
of the 14th Annual ACM Symposium on Theory of Computing, STOC ’82,
pages 60–65, 1982.
63. Y. Gurevich and S. Shelah. Fixed-point extensions of ﬁrst-order logic. Annals
of Pure and Applied Logic, 32:265–280, 1986.
64. D. Harel. Towards a theory of recursive structures. In Proceedings of 23rd Inter-
national Symposium on Mathematical Foundations of Computer Science MFCS
98, Lecture Notes in Computer Science, No. 1450, pages 36–53. Springer, 1998.
65. T. Hirst and D. Harel. More about recursive structures: Descriptive complexity
and zero–one laws. In Proc. 11th IEEE Symp. on Logic in Computer Science,
pages 334–348, 1996.
66. W. Hodges. Model Theory. Cambridge University Press, 1993.
67. N. Immerman. Relational queries computable in polynomial time. Information
and Control, 68:86–104, 1986.
68. A. Itai and J. Makowsky.
Uniﬁcation as a complexity measure for logic
programming. Journal of Logic Programming, 4:105–117, 1987.
69. D. Janin and I. Walukiewicz. On the expressive completeness of the proposi-
tional mu-calculus with respect to monadic second order logic. In Proceedings
of 7th International Conference on Concurrency Theory CONCUR ’96,
Lecture Notes in Computer Science, No. 1119, pages 263–277. Springer, 1996.
70. N. Jones and W. Laaser.
Complete problems for deterministic polynomial
time. Theoretical Computer Science, 3:105–117, 1977.
71. N. Jones and A. Selman.
Turing machines and the spectra of ﬁrst-order
formulas. Journal of Symbolic Logic, 39:139–150, 1974.
72. M. Jurdzi´nski.
Deciding the winner in parity games is in UP ∩Co-UP.
Information Processing Letters, 68:119–124, 1998.

References
229
73. M. Jurdzi´nski. Small progress measures for solving parity games. In STACS
2000, 17th Annual Symposium on Theoretical Aspects of Computer Science,
Proceedings, Lecture Notes in Computer Science, No. 1770, pages 290–301.
Springer, 2000.
74. P. Kanellakis, G. Kuper, and P. Revesz. Constraint query languages. Journal
of Computer and Systems Sciences, 51:26–52, 1995.
75. B. Khoussainov and A. Nerode.
Automatic presentations of structures.
In
LCC ’94: Selected Papers from the International Workshop on Logical and
Computational Complexity, Lecture Notes in Computer Science, No. 960,
pages 367–392. Springer, 1995.
76. B. Khoussainov, S. Rubin, and F. Stephan.
On automatic partial orders.
Proceedings of 18th Annual IEEE Symposium on Logic in Computer Science,
LICS 03, pages 168–177, 2003.
77. B. Khoussainov, A. Nies, S. Rubin, and F. Stephan. Automatic structures:
Richness and limitations.
Proceedings of 19th Annual IEEE Symposium on
Logic in Computer Science, LICS 04, pages 44–53, 2004.
78. B. Khoussainov, S. Rubin, and F. Stephan.
Deﬁnability and regularity in
automatic structures. In Proceedings of STACS 04, pages 440–451, 2004.
79. P. Kolaitis. The expressive power of stratiﬁed logic programs. Information
and Computation, 90:50–66, 1991.
80. S. Kreutzer. Expressive equivalence of least and inﬂationary ﬁxed point logic.
In Proceedings of 17th IEEE Symp. on Logic in Computer Science LICS02,
pages 403–410, 2002.
81. G. Kuper, L. Libkin, and J. Paredaens, editors.
Constraint Databases.
Springer, 2000.
82. D. Martin. Borel determinacy. Annals of Mathematics, 102:336–371, 1975.
83. Y. Matijasevich. Hilbert’s Tenth Problem. MIT Press, 1993.
84. K. Meer.
Query languages for real number databases based on descriptive
complexity over R. In Proc. 24th International Symposium on Mathematical
Foundations of Computer Science MFCS 99, Lecture Notes in Computer
Science Nr. 1672, pages 12–22. Springer, 1999.
85. Y. Moschovakis. Elementary Induction on Abstract Structures. North-Holland,
1974.
86. A. Mostowski.
Games with forbidden positions.
Technical Report 78,
University of Gdansk, 1991.
87. D. Muller and P. Schupp.
Groups, the theory of ends, and context-free
languages. Journal of Computer and System Sciences, 26:295–310, 1983.
88. D. Muller and P. Schupp.
The theory of ends, pushdown automata, and
second-order logic. Theoretical Computer Science, 37:51–75, 1985.
89. M. Otto. Bounded Variable Logics and Counting. Springer, 1997.
90. M. Otto. Bisimulation-invariant Ptime and higher-dimensional mu-calculus.
Theoretical Computer Science, 224:237–265, 1999.
91. C. Papadimitriou. A note on the expressive power of Prolog. Bulletin of the
EATCS, 26:21–23, 1985.
92. S. Rubin. Automatic Structures.
PhD thesis, University of Auckland, New
Zealand, 2004.
93. H. Scholz.
Ein ungel¨ostes Problem in der symbolischen Logik.
Journal of
Symbolic Logic, 17:160, 1952.

230
3 Finite Model Theory and Descriptive Complexity
94. A. Stolboushkin.
Towards recursive model theory.
In J. Makowsky and
E. Ravve, editors, Logic Colloquium 95, Lecture Notes in Logic, No. 11, pages
325–338. Springer, 1998.
95. H. Straubing.
Finite Automata, Formal Logic, and Circuit Complexity.
Birkh¨auser, Boston, 1994.
96. W. Thomas. On the synthesis of strategies in inﬁnite games. In Proceedings of
STACS 95, Lecture Notes in Computer Science, No. 900, pages 1–13. Springer,
1995.
97. W. Thomas. Languages, automata, and logic. In G. Rozenberg and A. Salomaa,
editors, Handbook of Formal Languages Vol. 3, pages 389–455. Springer, 1997.
98. W. Thomas. Constructing inﬁnite graphs with a decidable MSO-theory. In
Proceedings of the 28th International Symposium on Mathematical Founda-
tions of Computer Science MFCS 03, Lecture Notes in Computer Science,
No. 2747, pages 113-124, Springer, 2003.
99. M. Vardi. The complexity of relational query languages. In Proceedings of the
14th ACM Symposium on the Theory of Computing, pages 137–146, 1982.
100. M. Vardi. On the complexity of bounded-variable queries. In Proc. 14th ACM
Symp. on Principles of Database Systems, pages 266–267, 1995.
101. I. Walukiewicz. Monadic second-order logic on tree-like structures. Theoretical
Computer Science, 275:311–346, 2001.
102. W. Zielonka. Inﬁnite games on ﬁnitely coloured graphs with applications to
automata on inﬁnite trees. Theoretical Computer Science, 200:135–183, 1998.

4
Logic and Random Structures
Joel Spencer
In the world of randomization almost everything seems to be possible.
– Michael Rabin
4.1 An Instructive Example
We begin with a rather easy random model which illustrates many of the
concepts we shall deal with. We call it the simple unary predicate with
parameters n, p, and denote it by SU(n, p). The model is over a universe Ω of
size n, a positive integer. We imagine each x ∈Ω ﬂipping a coin to decide if
U(x) holds, and the coin comes up heads with probability p. Here we have p
real, 0 ≤p ≤1. Formally we have a probability space on the possible U over
Ω deﬁned by the properties Pr[U(x)] = p for all x ∈Ω and the events U(x)
being mutually independent. We consider sentences in a ﬁrst-order language.
In this language, we have only equality (we shall always assume we have
equality) and the unary predicate U. (The cognoscenti should note that Ω
has no further structure and, in particular, is not considered an ordered set.)
This is a rather spartan language. One thing we can say is
Y ES := ∃xU(x),
that U holds for some x ∈Ω. Simple probability gives
Pr[SU(n, p) |= Y ES] = 1 −(1 −p)n
As p moves from zero to one, Pr[Y ES] moves monotonically from zero to
one. We are interested in the asymptotics as n →∞. At ﬁrst blush this seems
trivial: for p = 0, SU(n, p) never models Y ES while for any constant p > 0,
lim
n→∞Pr[SU(n, p) |= Y ES] = lim
n→∞1 −(1 −p)n = 1

232
4 Logic and Random Structures
In an asymptotic sense, Y ES has already almost surely occurred by the time
p reaches any positive constant.
This leads us to a critical notion. We do not restrict ourselves to p
constant but rather consider p = p(n) as a function of n. What is the
parametrization p = p(n) that best enables us to see the transformation
of Pr[SU(n, p(n)) |= Y ES] from zero to one? Some reﬂection leads to the
parametrization p(n) = c/n. If c is a positive constant, then
lim
n→∞Pr[SU(n, p(n)) |= Y ES] = lim
n→∞1 −(1 −c
n)n = 1 −e−c
(Technically, as p ≤1 always, this parametrization is not allowable for n < c
– but since we are only concerned with limits as n →∞this will not concern
us.) If we think of c going from zero to inﬁnity, then the limit probability is
going from zero to one. We are actually interested less (in this exposition) in
the actual limits than in whether the limits are zero or one.
We say that a property A holds almost always (with respect to a given
p(n)) if limn→∞Pr[SU(n, p(n)) |= A] = 1. We say that A holds almost
never if the above limit is zero or, equivalently, if ¬A holds almost surely.
This notion is extremely general. Whenever we have, for all suﬃciently large
positive integers n, a probability space over models of size n, we can speak of a
property A holding almost surely or almost never. For the particular property
Y ES, the exact results above have the following simple consequences:
•
If p(n) ≪n−1 then Y ES holds almost never.
•
If p(n) ≫n−1 then Y ES holds almost surely.
Thus, for example, when p(n) = n−1.01, Y ES holds almost never, while when
p(n) = n−0.99, Y ES holds almost surely.
We shall say that n−1 is a threshold function for the property Y ES. More
generally, suppose we have a notion of a random model on n vertices with
a probability p of some predicate. We say p0(n) is a threshold function for
a property A if, whenever p(n) ≪p0(n), the property A holds almost never,
and whenever p(n) ≫p0(n) the property A holds almost surely. This notion,
due to Paul Erd˝os and Alfred R´enyi, says roughly that p0(n) is the “region”
around which Pr[A] is moving from near zero to near one. The threshold
function, when it exists, is not totally determined – we could have taken
5/n as the threshold function for Y ES – but is basically determined up to
constant factors. In a rough way we think of p(n) increasing through the
functions of n – for example from n−2 to n−1 to n−1 ln n to ln−5 n – and the
threshold function is that place where Pr[A] changes.
A natural problem for probabilists is to determine the threshold function,
if one exists, for a given property A. For logicians, the natural question
would be to determine all possible threshold functions for all properties
A expressible in a given language L. Unfortunately there are technical
diﬃculties (especially with later more complex models) with threshold

4.1 An Instructive Example
233
functions – properties A need not be monotone, threshold functions need not
exist, and, worst of all, the limits of probabilities might not exist. Rather,
the logician looks for a zero–one law, of which the following is prototypical.
Theorem 4.1.1. Let p = p(n) satisfy p(n) ≫n−1 and 1 −p(n) ≫n−1.
Then, for any ﬁrst-order property A,
lim
n→∞Pr[SU(n, p) |= A] = 0 or 1
Further, the limiting value depends only on A and not on the choice of p(n)
within that range.
Our approach to this theorem, which will also be used in later more
complex cases, is to ﬁnd an explicit theory T such that
•
every A ∈T holds almost surely;
•
T is complete.
Will this suﬃce? When T |= B, ﬁniteness of proof gives us the result that
B follows from some A1, . . . , As ∈T and hence from A1 ∧. . . ∧As. But the
ﬁnite conjunction of events holding almost surely holds almost surely, so B
would hold almost surely. By completeness, either T |= B or T |= ¬B, and in
the latter case ¬B holds almost surely so that B holds almost never.
In our situation, T is given by two simple schemas.
1. (For r ≥1.) There exist distinct x1, . . . , xr with U(xi) for 1 ≤i ≤r.
2. (For r ≥1.) There exist distinct x1, . . . , xr with ¬U(xi) for 1 ≤i ≤r.
Note that the number X of x with U(x) has a binomial distribution with
parameters n, p(n) – that the event X ≥r holds almost surely follows from
basic probabilistic ideas and from the assumption np(n) →∞. The second
schema follows from n(1 −p(n)) →∞, reversing the roles of U and ¬U.
Why is this T complete? Proving completeness of a theory T is bread and
butter to the logic community – from the myriad of methods, we choose a
combinatorial approach based on the Ehrenfeucht game, as described in Sect.
4.14. Let t ≥1 be arbitrary and let M1, M2 be two countable models of T . It
suﬃces to show that Duplicator wins the game EHR(M1, M2; t).
In our case the Duplicator’s strategy is simple. A countable model M of
T must have an inﬁnite number of x ∈M with U(x) (as for all r ≥1 it must
have at least r such x) and, similarly, an inﬁnite number of x ∈M with
¬U(x). Now when Spoiler selects, say, a new x ∈M1 with U(x) Duplicator
simply selects a new x′ ∈M2 with U(x′) – as there are only a ﬁnite number
t of moves, he cannot run out of possible x′.
In this instance the countable models of T were particularly simple –
indeed the theory T was ℵ0-categorical; all countable models were isomorphic.
In future more complex situations this will generally not be the case, and
indeed we ﬁnd the study of the countable models of the almost sure theory
T to be quite intriguing in its own right.

234
4 Logic and Random Structures
4.2 Random Graphs
A graph G consists of a set of vertices V and an areﬂexive symmetric binary
relation on V . We write the relation x ∼y and say that x, y are adjacent.
Pictorially, there is an edge from x to y. For the graph theorists, our graphs
are undirected, with neither loops nor multiple edges. The random graph
G(n, p) (n ≥1 integral, p real, 0 ≤p ≤1) is on a vertex set V of size n,
where,for each distinct x, y, Pr[x ∼y] = p and these events are mutually
independent. We may think of each pair x, y of vertices as ﬂipping a coin to
decide whether or not to have an edge between them, where the probability
that the coin comes up heads is p.
It is a relatively rare area of mathematics that has an explicit starting
point. The subject of random graphs began with a monumental paper by
Paul Erd˝os and Alfred R´enyi in 1960. The very title of their paper, “On the
evolution of random graphs,” speaks to a critical vantage point. As the edge
probability p increases, the random graph G(n, p) increases in complexity.
For many natural properties A, there will be a threshold function p0(n) for
its occurence. As in Sect. 4.1, when p(n) ≪p0(n) A will hold almost never,
while when p(n) ≫p0(n) A will hold almost always. Finding threshold
functions has been a major preoccupation for researchers in random graphs.
Let us give some examples, together with some intuitive justiﬁcation for the
threshold functions.
•
Containing a K4 – i.e. containing four vertices with all six pairs adjacent.
The threshold function is n−2/3. There are
n
4

∼n4/24 possible K4s and
each has six adjacencies with probability p6, so that the expected number
of K4s is ∼n4p6/24. When p(n) ≪n−2/3 this expectation goes to zero,
so that almost surely there are none of them. When p(n) ≫n−2/3 this
expectation goes to inﬁnity. By itself, this does not imply that almost
surely there is at least one K4 but more reﬁned methods – in particular,
an examination of the variance of the number of K4s – do show that
almost surely there will be a K4.
•
Containing a triangle. The threshold function is n−1, for reasons similar
to those above.
•
No isolated vertices. In ﬁrst-order language ∀x∃yx ∼y. Here n−1 ln n is the
threshold function. Roughly, a given vertex x has probability (1−p)n−1 ∼
e−pn of being isolated. When pn > (1 + ε) ln n, this probability is o(n−1),
so that the expected number of isolated vertices is o(1) and almost surely
there are none. When pn < (1 −ε) ln n, this probability is ≫n−1, so that
the expected number of isolated vertices goes to inﬁnity, and more reﬁned
techniques show that almost surely there are isolated vertices.
•
Connectivity. This was one of the most beautiful results in the Erd˝os–
R´enyi paper. It turns out that connectivity has the same behavior as
no isolated vertices. Their result was amazingly precise. We parametrize
p = (ln n)/n + c/n. For c any real (positive or negative) constant,

4.3 Extension Statements
235
lim
n→∞Pr[G(n, p) connected] = e−e−c.
•
Every two vertices have a common neighbor. In ﬁrst order language
∀x1∀x2∃y1y1 ∼x1 ∧y1 ∼x2. The threshold function is n−1/2 ln1/2 n. Any
x1, x2 have an expected number (n−2)p2 ∼np2 of common neighbors. This
would naturally lead us to consider p = n−1/2. Indeed, for p ≪n−1/2 a ran-
domly chosen x1, x2 will not have a common neighbor, while for p ≫n−1/2
a randomly chosen x1, x2 will have a common neighbor, and indeed many
common neighbors. But this does not suﬃce for every pair x1, x2 to have
a common neighbor; for that one needs the extra polylogarithmic term.
•
Every two vertices are joined by a path of length three. In ﬁrst-order
language ∀x1∀x2∃y1∃y2x1 ∼y1 ∧y1 ∼y2 ∧y2 ∼x2. The threshold function
is n−2/3 ln1/3 n. Any x1, x2 have
n−2
2

∼n2/2 potential paths (choices
of y1, y2) of length three, and each potential path has three adjacencies
with probability p3, so that the expected number of paths is ∼n2p3/2.
This would lead us to consider p = n−2/3 as a threshold function but, as
above, an extra polylogarithmic term is needed to assure that every pair
x1, x2 has such a path.
These threshold functions, and countless others, seemed to this author
to have a common property: the power of n involved was always a rational
number. There might be other, generally polylogarithmic, factors but they
would be of smaller order than the power of n. Nowhere, so it seemed, was
there a natural property with a threshold function, say, p = n−π/7. In 1988
this author and Saharon Shelah were able to give a formal justiﬁcation for
this observation, and this result is the centerpiece of our discussions.
Theorem 4.2.1. Let 0 < α < 1, α irrational. Set p(n) = n−α. Then, for
every ﬁrst-order property A,
lim
n→∞Pr[G(n, p) |= A] = 0 or 1.
The situation where α > 1 has also been studied. It turns out to be
considerably simpler than the 0 < α < 1 case and will not be considered here.
Our approach will be that used in Sect. 4.1. We shall ﬁnd a theory T = Tα
such that each A ∈Tα holds almost surely, and Tα will be shown to be
complete, using countable models and the Ehrenfeucht game. We shall need
several preliminaries.
4.3 Extension Statements
The examples above, “Every vertex has a neighbor,” “every two vertices
have a common neighbor,” and “every two vertices are joined by a path of
length three”, are all examples of a vital kind of ﬁrst-order statement that
we shall call extension statements. These statements are of the form “For

236
4 Logic and Random Structures
all x1, . . . , xr, there exist y1, . . . , yv P”, where P is that certain adjacencies
between some yi, yj and some xi, yj must exist. P never considers adjacencies
between pairs xi, xj and never demands nonadjacency. We allow the case
r = 0, so that the extension statement reduces to a purely existential
statement, but require v > 0.
To formalize this, we deﬁne a rooted graph to be a pair (R, H), where
H is a graph (with V (H) and E(H) denoting its vertex and edge sets,
respectively) and R is a proper subset of the vertices. Labeling the roots
x1, . . . , xr and the nonroots y1, . . . , yv, we deﬁne the extension statement
Ext(R, H) to be that for all x1, . . . , xr there exist y1, . . . , yr having the
edges of H, where we do not examine the edges between the roots and we
allow extra edges. A rooted graph (R, H) has three parameters. The number
of roots is denoted by r. The number of nonroots is denoted by v. The
number of edges (where edges between roots are not counted) is denoted by
e. Perhaps surprisingly, r plays a relatively minor role. The key parameter,
as the examples below will indicate, is the sign of v −eα.
We call (R, H) dense if v −eα < 0 and sparse if v −eα > 0. The irrational-
ity of α comes in at this point, making this a strict dichotomy. We further
call (R, H) rigid if, for all S with R ⊆S ⊂V (H), the rooted graph (S, H) is
dense. (As S may be R itself, “rigid” implies “dense”.) We call (R, H) safe
if, for all S with R ⊂S ⊆V (H), the rooted graph (R, H|S) is sparse. (Here
H|S is the restriction of H to S; we simply throw all other vertices away.
As S may be V (H) itself, “safe” implies “sparse”.) Very roughly we think of
“rigid” as meaning dense through and through, and “safe” as meaning sparse
through and through. We call (R, H|S) a subextension of (R, H), and we call
(S, H) a nailextension (we are nailing down some more roots) of (R, H).
Let us look at several examples with α = π/7 = 0.448 · · ·. We have
selected this α because it seems to have no special properties whatsoever.
•
Every two vertices have a neighbor. H has y1 adjacent to x1, x2;
r = 2, v = 1 and e = 2, so v −eα > 0 and (R, H) is sparse and safe.
•
Every three vertices have a neighbor. H has y1 adjacent to x1, x2, x3;
r = 3, v = 1 and e = 3, so v −eα < 0 and (R, H) is dense and rigid.
•
Every vertex lies in a K5. H has y1, y2, y3, y4, x1 with all ten adjacencies;
r = 1, v = 4 and e = 10, so v −eα < 0 and (R, H) is dense and rigid.
•
Every vertex lies in a K4. H has y1, y2, y3, x1 with all six adjacencies;
r = 1, v = 3 and e = 10, so v −eα > 0 and (R, H) is dense and rigid.
•
Every two vertices lie in a K4 except, possibly, they may be nonadjacent.
H has y1, y2, x1, x2 with ﬁve adjacencies (not x1, x2): r = 2, v = 2 and
e = 5, so v −eα < 0 and (R, H) is dense and rigid.
•
Every three vertices have a common neighbor, which itself has a (diﬀerent)
neighbor. H has y1 adjacent to x1, x2, x3, and y2 adjacent to y1. Here
r = 3, v = 2, e = 4 and v −eα > 0, so that (R, H) is sparse. But (R, H)
is not safe, since the subextension “every three vertices have a common
neighbor” (S = {x1, x2, x3, y1}) is not sparse.

4.4 Closure
237
•
Every four vertices have a common neighbor which itself has a (diﬀerent)
neighbor. H has y1 adjacent to x1, x2, x3, x4, and y2 adjacent to y1. Here
r = 4, v = 2, e = 5 and v −eα < 0, so that (R, H) is dense. But nailing
down y1, by setting S = R ∪{y1}, gives (S, H) with r = 5, v = 1, e = 1
and v −eα > 0, so that y2 is ﬂapping in the wind and (R, H) is not rigid.
It can be shown that Ext(R, H) holds almost surely if and only if
(R, H) is safe. Let us see the intuitive justiﬁcation. Given the x1, . . . , xr we
have ∼cnv choices for y1, . . . , yv and each choice will have the needed e
adjacencies with probability pe; hence the expected number of extensions is
∼cnvpe ∼cnv−eα. When v −eα < 0 this expected number goes to zero, so
almost surely a random x1, . . . , xr will not have an extension. If there is a
subextension (R, H|S) which is not sparse (and hence dense) almost surely a
random x1, . . . , xr cannot be extended to H|S and hence cannot be extended
to H. The converse requires more work.
What about “rigid”? It is not the case that every three vertices have a
common neighbor; indeed, a random three vertices almost surely will not
have a common neighbor. But some sets of three vertices do have a common
neighbor. (Take a vertex y1, and take three of its neighbors x1, x2, x3 –
those three vertices have the common neighbor y1.) When x1, x2, x3 have a
common neighbor, that is a special property of the triple. It is not special
when x1, x2 have a common neighbor since every pair of vertices have a
common neighbor. It will turn out that all special properties of bounded sets
of vertices are describable in terms of rigid extensions.
4.4 Closure
Fix α ∈(0, 1) irrational and t ≥1. Let G be any graph, although we shall be
interested in G ∼G(n, p) with p = n−α. Let X be any set of vertices of G.
We deﬁne the t-closure of X, denoted by clt(X).
Our ﬁrst deﬁnition of clt(X) is algorithmic. We say y1, . . . , yv form an
(R, H) extension over x1, . . . , xr if they have the required adjacencies of H
between the yi, yj and the xi, yj. We say y1, . . . , yv form a rigid extension
over x1, . . . , xr if they form an (R, H) extension for some rigid (R, H). Now
begin with X. If any y1, . . . , yv with (critically) v ≤t form a rigid extension
over X, then add those vertices to X. Iterate until there are no further rigid
extensions. The ﬁnal set is clt(X).
The second deﬁnition is that clt(X) is the minimal set Z containing X
which does not have any rigid extensions of at most t vertices.
Justifying the assertion that these two deﬁnitions are equivalent and
indeed that they are well deﬁned (e. g. that the ﬁrst does not depend on the
order in which rigid extensions are added on) requires a series of relatively
elementary combinatorial lemmas, which we shall omit here. As an example,
cl4(x1, x2) might consist of x1, x2; y1, y2 adjacent to each other and to both

238
4 Logic and Random Structures
x1, x2; y3, y4, y5, y6, forming a K5 with y2; and y7 being a common neighbor
of x2, y1, y5.
Lemma 4.4.1 (Nonexistence Lemma). For every t ≥1 almost surely
clt(∅) = ∅in G ∼G(n, n−α).
Proof When (∅, H) is rigid (or even just dense) it has v vertices and e edges
with v −eα < 0 so that the expected number of copies of H is ∼cnvpe,
which goes to zero. Hence, almost surely, there is no copy of H. With t ﬁxed,
there are only a ﬁnite number of such H’s to consider, so almost surely none
of them exist as subgraphs of G.
Let x1, . . . , xr ∈G, x′
1, . . . , x′
r ∈G′. We see that their t-closures are isomor-
phic, and write clt(x1, . . . , xr) ∼= clt(x′
1, . . . , x′
r) if there is a graph isomorphism
ϕ between the t-closures which preserves both adjacency and nonadjacency
and which satisﬁes ϕ(xi) = x′
i for 1 ≤i ≤r. When H is the restriction of
G to clt(x1, . . . , xr) we write clt(x1, . . . , xr) ∼= H, but with the additional
understanding that the roots x1, . . . , xr are in speciﬁed positions in H. For
completion we include the case t = 0: we deﬁne the 0-closure of X to be X
and say that cl0(x1, . . . , xr) ∼= cl0(x′
1, . . . , x′
r) if the map ϕ with ϕ(xi) = x′
i for
1 ≤i ≤r is a graph isomorphism on these sets of r vertices. Observe that stat-
ing clt(x1, . . . , xr) ∼= H is a ﬁrst-order predicate. In the example of the preced-
ing paragraph, it would consist of stating the existence of the y1, . . . , y7 with
their appropriate adjacencies and then, for each of the ﬁnite list of possible
(R, H) rigid extensions with v ≤4, the nonexistence of z1, . . . , zv having those
adjacencies over x1, . . . , y7. A priori, the t-closure might be arbitrarily large,
and the following lemma plays an important role in limiting its possibilities.
Lemma 4.4.2 (Finite Closure Lemma). For all α ∈(0, 1) and irrational,
r, t ≥1 integers, there exists K such that, in G ∼G(n, n−α), almost surely
|clt(x1, . . . , xr)| < r + K for all x1, . . . , xr.
Proof: We set ε = min(eα −v)/v over all integers v, e with v ≤t and
v −eα ≤0. Note, critically, that the restriction v ≤t allows us to restrict
to a ﬁnite number of cases, and thus the min does exist and (as α is
irrational) is positive. We set K = ⌈r/ε⌉.
Suppose that the result was false and there was R = {x1, . . . , xr} with
a larger t-closure. Then there would be a sequence R = R0 ⊂R1 ⊂. . . ⊂Rl
where each Ri+1 was rigid over Ri with fewer than t nonroots and Rj having a
size in [r+K, r+K +t). (That is, we continue taking rigid extensions and stop
when at least r+K vertices are in the set.) Let Hi be the restriction of G to Ri
and set H equal to the ﬁnal Hl. Let (Ri−1, Hi) have parameters vi, ei. Then
H has V = r + l
i=1 vi vertices and at least E = l
i=1 ei edges. Roughly,
the r roots are our capital and each extension costs us eα −v. Formally,
V −Eα ≤r +
l

i=1
(vi −ei)α ≤r −ε
l

i=1
vi ≤r −Kε < 0.
The existence of such an H would then violate the Nonexistence Lemma.

4.5 The Almost Sure Theory
239
4.5 The Almost Sure Theory
To describe the almost sure theory T = Tα, we require one more somewhat
technical point. When (R, H) is safe, we want every x1, . . . , xr to have an
(R, H) extension y1, . . . , yv. But we further need that these y’s have no
additional properties relative to the x’s. We deﬁne this in the ﬁrst-order
world via rigid extensions. Roughly we want to say that any rigid extension
over the x’s and y’s is really just over the xs.
Deﬁnition. We say that y1, . . . , yv is t-generic over x1, . . . , xr if the
following holds. Consider any z1, . . . , zw distinct from the x’s and y’s with
(critically) w ≤t, which forms a rigid extension over x1, . . . , xr, y1, . . . , yv.
Then there are no edges between any zi and any yj.
The almost sure theory Tα consists of two schemas.
•
Nonexistence. (For H with v vertices, e edges, and v −eα < 0) There does
not exist a copy of H. To express it in slicker form – for all t ≥1, clt(∅) = ∅.
•
Generic Extension. (For (R, H) safe, t ≥0) For all x1, . . . , xr, there exist
y1, . . . , yv such that the following apply:
1. y1, . . . , yv form an (R, H) extension over x1, . . . , xv.
2. There are no additional edges of the form yi, yj or yi, xj except those
mandated by H.
3. y1, . . . , yv is t-generic over x1, . . . xv. (For t = 0, exclude this condition.)
We have seen by the Nonexistence Lemma that each A in the Nonexis-
tence schema holds almost surely. We indicate the argument for the Generic
Extension schema. Let (R, H) be safe. For any x = (x1, . . . , xr), let N(x)
denote the number of (R, H) extensions y = (y1, . . . , yv). Let x1, . . . , xr be
selected randomly so that N = N(x) becomes a random variable. We have
seen that the expectation μ := E[N] ∼cnvpe, which goes to inﬁnity like a
positive power of n. At the heart of this (and the one fairly technical part of
the probability analysis) is a large-deviation result: for any ﬁxed ε > 0,
Pr[|N(x) −μ| > εμ] = o(n−r).
Actually, the probability can be bounded by exp[n−λ] for a positive λ, but
the above suﬃces for our purposes. Here N counts extensions and so is the
sum of ∼cnv indicator random variables (one for each distinct extension)
each of which are one (i.e., the extension is there) with probability pe. If we
could think of N as a binomial distribution with parameters cnv, pe, then the
above large-deviation result would follow from standard probability results,
known as the Chernoﬀbounds. The diﬃculty arises from the fact that the
indicator random variables are not independent, the potential extensions
have a complex overlap pattern. Most of the potential extensions (as v is
ﬁxed and n →∞) do not overlap, and so their indicator random variables
are independent. Still, it requires some technical skill, which we omit from
this presentation, to show the large-deviation result.

240
4 Logic and Random Structures
Given the large-deviation result, we can easily deduce a counting theorem:
almost surely the number of extensions N(x) lies between μ(1 ± ε) for all
choices of x. This follows since there are only O(nr) choices for the roots
and the failure probability is o(n−r) for any particular choice. Now, modulo
some combinatorial work, we can deduce Generic Extension. For each x,
the number of (R, H) extensions is Θ(nv−eα). How many of these are not
t-generic? There are only a ﬁnite number of ways y can be not t-generic over
x. One shows that for each such possibility the number of such extensions is
(using the counting theorem upper bound) at most O(nv′−αe′) where v′ −αe′
is smaller than v −eα. Roughly, the existence of a rigid extension would add
v1 vertices and e1 edges with v1 −e1α < 0 and that would decrease v −eα.
The total number of non-t-generic extensions over x is then bounded by a
constant times a smaller power of n. For n suﬃciently large, this is smaller
than the total number of extensions and therefore some (R, H) extension –
indeed, almost all such extensions – will be t-generic.
The completeness of Tα can be shown via the Ehrenfeucht game but
requires a surprisingly subtle strategy for Duplicator. Let G, G′ be models
of Tα, ﬁx the number of rounds u ≥1, and consider the Ehrenfeucht game
EHR(G1, G2; u).
Deﬁne integers t0, t1, . . . , tu as follows. Set t0 = 0 and (for convenience)
t1 = 1. Given ti, select ti+1, where the following apply:
1. ti+1 ≥ti.
2. Almost surely in G(n, n−α), for every X of size i + 1, the ti-closure of X
has a size of at most ti+1 vertices outside of X.
Of course, the existence of ti+1 requires the Finite Closure Lemma. Now
we describe Duplicator’s strategy. Let xj, x′
j denote the vertices of G, G′
respectively selected in the jth round. Let 0 ≤i ≤u and set s = u −i for
convenience. Duplicator plays so that after the sth round (or, equivalently,
with i rounds remaining) the ti-closure of (x1, . . . , xs) and the ti-closure of
(x′
1, . . . , x′
i) are isomorphic, the isomorphism sending xi to x′
i.
At the start of the game, setting t = tu, the Nonexistence Schema assures
that clt(∅) is the same in G and G′, so Duplicator is ﬁne. At the end of
the game, the 0-closures are isomorphic, which is precisely the condition for
Duplicator to have won. It thus suﬃces to show (the hard part) that if this
condition is satisﬁed for i, then regardless of Spoiler’s move Duplicator has
a response that preserves the condition for i −1.
To avoid subscripts, let us ﬁx i and write BIG := ti, SMALL := ti−1,
x = (x1, . . . , xs) and x′ = (x′
1, . . . , x′
s). By symmetry, we can assume that
Spoiler plays next in G. Let y denote his next move. There are two basic
cases which we dub Inside and Outside.
We say y is Inside if y ∈clBIG(x). As SMALL ≤BIG, this then
determines clSMALL(x, y) which lies entirely inside clBIG(x). Duplicator
checks the isomorphism ϕ between the BIG-closures of x, x′ and selects
y′ = ϕ(y), the vertex corresponding to y under the isomorphism.

4.6 The Case p Constant
241
Otherwise, y is Outside. Let OLD denote the BIG-closure of x. Dupli-
cator calculates clSMALL(x, y) and sets NEW equal to those vertices of
it which are not already in OLD. Our deﬁnition of BIG, which in turn
depends on the Finite Closure Lemma, assures us that NEW has at most
BIG vertices. Say NEW over OLD forms an (R, H) extension. We need
now a combinatorial lemma (proof omitted) that any nonsafe extension
contains a rigid subextension. From this it follows that (R, H) must be safe,
since otherwise there would be a nonempty NEW −, rigid over OLD, but
then it would be in OLD by the closure deﬁnition. Duplicator then goes
over to G′, and by t-generic extension (t = SMALL) ﬁnds a NEW ′ over
OLD′ = clBIG(x′) with precisely the same edges and selects y′ as the vertex
of NEW ′ corresponding to y. This immediately gives the result that the
SMALL-closure of x′, y′ contains a copy of the SMALL-closure of x, y and
some combinatorial lemmas involving t-genericity ensure that it contains
nothing more and that the two SMALL-closures are isomorphic.
This shows that Tα is complete, and hence the zero-one law.
4.6 The Case p Constant
One of the original motivations for considering this area was a beautiful
result shown independently by Glebskii et al. and by Fagin. Let 0 < p < 1 be
constant. They showed a Zero-One Law for this G(n, p), that every ﬁrst-order
A holds either almost surely or almost never.
With our machinery the proof is quite quick. The theory T is given by
one schema. (For all r, s ≥0) For all distinct x1, . . . , xr, y1, . . . , ys there exists
a distinct z adjacent to all of the xi and to none of the yj.
Fix r, s, p. We call z a witness (relative to the x’s and y’s) if it has
precisely the desired adjacencies. Each z has a probability ε := pr(1 −p)s
of being a witness. The events of being a witness are independent (involving
disjoint edge sets) so the probability is (1 −ε)n−r−s that there is no witness.
There are
n
r
n−r
s

≤nr+s choices for the x’s and y’s. Hence the probability
that any such choice produces no witness is ≤nr+s(1 −ε)n−r−s. Fixing r, s, p
ﬁxes ε > 0 and exponential decay kills oﬀpolynomial growth, so the failure
probability goes to zero.
The graphs G modeling T are said by Peter Winkler to have the Alice’s
Restaurant property. Members of a certain generation may remember the
refrain, “You can get anything you want at Alice’s Restaurant.” All possible
witnesses are there.
Let G, G′ model T . Duplicator’s stategy is simplicity itself. Staying alive.
When xi is played in G, Duplicator looks for x′
i ∈G′ with the appropriate
adjacencies to the previously selected vertices. By the Alice’s Restaurant
property, she never gets stuck.

242
4 Logic and Random Structures
4.7 Countable Models
Whenever we have a zero-one law, we have the complete theory T of those
sentences holding almost surely. By the G¨odel Completeness Theorem, such
a theory must have a ﬁnite or countable model. The models cannot be ﬁnite,
since for every r ≥1 the sentence “There exist distinct x1, . . . , xr” is in the
almost sure theory since it holds for all n ≥r. Thus T must have a countable
model – in our case a countable graph G. What does G look like? The ﬁrst
question is whether G is unique – that is, whether T is ℵ0-categorical.
Consider ﬁrst the Alice’s Restaurant theory T for p constant. This is
ℵ0-categorical by an elegant argument. Let G, G′ be two countable models
of T , both labeled by the positive integers. We build up an isomorphism
Φ : G →G′ by alternating left stages and right stages. After n steps the map
Φ will map n elements of G into n elements of G′, preserving adjacency and
nonadjacency. For a left stage, let x be the least element of G for which Φ(x)
is not deﬁned. We require of Φ(x) that, for any a ∈G for which Φ(a) has
been deﬁned, Φ(x) must be either adjacent or nonadjacent to Φ(a) depending
on whether x is adjacent or nonadjacent to a. By Alice’s Restaurant, we can
ﬁnd such an x′. In the right stage we reverse the roles of G, G′. Let x′ be the
least element of G′ for which Φ−1(x′) is not deﬁned, and ﬁnd x = Φ−1(x′)
with the appropriate adjacencies. By step 2n, vertices 1, . . . , n have been used
up in both G and G′ so that at the end of this inﬁnite process all vertices
have been used up and Φ is a bijection giving the desired isomorphism. The
countable graph G satisfying Alice’s Restaurant is sometimes called the Rado
graph in honor of the late Richard Rado.
What about the theory Tα for 0 < α < 1 irrational? This is not ℵ0-
categorical. We indicate two arguments that create (well, prove the existence
of) diﬀerent countable models.
Consider rigid extensions with r = 1, and so of the form ({x}, H), with
parameters v, e where (∅, H) is safe. (With α = π/7, an example is H = K5.)
For such an H almost surely there exist copies of H but most vertices do not
lie in such copies. Suppose ({x}, Hi) is a sequence of such extensions with
parameters vi, ei. For any s, deﬁne the graph Hs to be the union of H1, . . . , Hs.
Here, we consider the Hi as disjoint vertex sets except for the common vertex
x. Suppose further that there almost surely exists a copy of Hs. Such a
sequence can be shown to exist for any α by employing a little number theory.
The key is to ﬁnd vi, ei such that vi −eiα is only very slightly negative. Now
we can create a model in which some element is in a copy of Hs for all s. We
add a constant symbol c to our logic and add the inﬁnite schema (for s ≥1)
that c is in a copy of Hs. Any ﬁnite segment of this system is consistent,
since in T itself one has that there exists a copy of Hs. By compactness there
exists a model and the element corresponding to c has the desired property.
Now we create a special countable graph Gα that models Tα. The vertices
will be the positive integers. For every safe rooted graph (R, H) and every
r = |R| distinct integers x = (x1, . . . , xr) consider the witness demand that

4.8 A Dynamic View
243
there must exist a y = (y1, . . . , yv) forming an (R, H) extension over x.
Witness demands would include, continuing with our standard α = π/7
example, that there exists a y1 adjacent to 167, 233 or that there exist
y1, y2, y3 forming a K4 with 26. We include the case R = ∅so that one
demand is that there exist y1, y2 forming an edge. We turn the witness
demands into a countable list. Now satisfy them one by one using new points
in a minimal way. That is, when we need a y1 adjacent to 167, 233 pick a
vertex, say 23801, that has not been touched before (at any stage, only a
ﬁnite number of points have been touched) and join it to 167, 233 and nothing
else. There are two very nice properties of this construction. First, Gα is a
model of Tα. (As you might expect, these minimal extensions are t-generic for
all t.) Second, and quite surpisingly, Gα is unique. That is, it does not depend
on the ordering of the witness demands nor on the choice of new points to
satisfy them. These graphs Gα seem quite intriguing objects worthy of study
simply as countable graphs. For any ﬁnite set X of vertices, let us deﬁne the
closure cl(X) as the union of the t-closures of X over all t, noting this is not
a ﬁrst-order concept. In this procedure at some ﬁnite time all vertices of X
have been touched. Let Y be the value of cl(X) at that moment. After this
time, all extensions of Y are via safe extensions and one can show that cl(X)
remains the same. That is, in Gα all ﬁnite sets have ﬁnite closure.
The two models created are diﬀerent, since in the ﬁrst there is an x with
cl({x}) inﬁnite, while in the second there is no such x.
4.8 A Dynamic View
We have seen that for ﬁxed irrational α ∈(0, 1), any ﬁrst-order A holds almost
surely or almost never in G(n, n−α). Now we consider A ﬁxed and vary α –
thinking roughly of the evolution of the random graph as we consider p = n−α
with α decreasing from one to zero. To study that evolution, we deﬁne
fA(α) = lim
n→∞Pr[G(n, n−α) |= A]
To avoid the problems at rational α, we simply deﬁne the domain of fA to
be the irrational α ∈(0, 1). Our goal is to describe the possible functions
fA. Note that fA(α) = 1 when A is in the theory Tα, otherwise fA(α) = 0.
We have given an explicit description of the theories Tα. In this sense the
function fA is described independently of probabilistic calculation. We seek
to understand the relationships within the continuum of theories Tα.
We begin with a continuity result. Fix A and the irrational α. We claim
that fA(β) is constant in some interval (α −ε, α + ε) around α. Suppose A is
in Tα (otherwise, take ¬A). Then A follows from a ﬁnite number of axioms
of Tα. These in turn depend on notions of dense and sparse rooted graphs,
which depend on whether v −eα is positive or negative. For any particular
v, e, whatever the sign of v −eα, that sign remains constant in some interval

244
4 Logic and Random Structures
around α. The ﬁnite number of axioms leads to a ﬁnite number of pairs v, e
and so all signs remain constant in some interval. For β in that interval, Tβ
has these same axioms and so A is in Tβ. (It is known, however, that the
theories Tα are all diﬀerent. Between any two α, α′ lies a rational a/b and it
is known that there is a graph H such that the existence of a copy of H has
a threshold function n−a/b.)
The discontinuities of fA must therefore come at the rational a/b ∈(0, 1).
We deﬁne the spectrum Sp(A) to be those rational points of discontinuity.
The classical theory of random graphs gives natural examples. Existence of a
K4 has a spectrum {2/3}. Existence of a K5 has a spectrum {1/2}. We can
put these together: “There exists a K4 and there does not exist a K5” to give
a spectrum {2/3, 1/2} – here as G evolves Pr[A] starts near zero, jumps to
one at n−2/3 when K4’s appear, and jumps back down to zero at n−1/2 when
K5’s appear. With some technical work, it is not diﬃcult to get any ﬁnite set
of rationals in (0, 1) as a spectrum in this way. This author once conjectured
that all spectra were such ﬁnite sets. That proved not to be the case.
4.9 Inﬁnite Spectra via Almost Sure Encoding
Here we shall describe a ﬁrst-order A with an inﬁnite spectrum. The central
idea will be to take a second-order sentence and give it an almost sure
encoding in the ﬁrst order language.
For deﬁniteness, we shall work near α =
1
3. By a K3,k is meant a set
x1, x2, x3; y1, . . . , yk with all yj adjacent to all three x’s. Basic random graph
theory gives that the sentence “There exists a K3,k” has a threshold function
n−1/3−1/k. (There are e = 3k edges and v = 3 + k vertices and (∅, K3,k) is
sparse and safe if and only if v −eα > 0.) Let N(x1, x2, x3) denote the set of
common neighbors of x1, x2, x3. Then, for 1/3 + 1/k > α > 1/3 + 1/(k + 1),
the maximal size |N(x1, x2, x3)| is k. Consider then the property, call it A∗,
that the maximal size |N(x1, x2, x3)| is even. This would have all values
1/3 + 1/k as spectral points. It is not possible to write this property in
the ﬁrst-order language. We shall, however, give an almost sure encoding, a
ﬁrst-order sentence that almost surely has the same truth value as A∗.
Let us look in the second-order world. How can we say that a set S (which
will be N(x1, x2, x3) in our application) has even size. We write
EV EN(S) : ∃R∀x¬R(x, x) ∧∀x,yR(x, y) ↔R(y, x) ∧∀x∈S∃!y∈SR(x, y).
That is, there exists an areﬂexive symmetric binary relation on S (i.e. a
graph) which is a matching – each vertex has precisely one neighbor. How
can we say that S is bigger than or equal in size to T ? Similarly, we write
BIGGER(S, T ), that there exists an areﬂexive symmetric binary relation R
that yields an injection from T −S to S −T . For every y ∈T −S, there is a
x ∈S −T with R(y, x), and we do not have R(y1, x) and R(y2, x) for distinct
y1, y2 ∈T −S and x ∈S −T . Now we can write A∗in second order:

4.9 Inﬁnite Spectra via Almost Sure Encoding
245
A∗: ∃x1,x2,x3EV EN[N(x1, x2, x3)]∧
∧∀z1,z2,z3BIGGER[N(x1, x2, x3), N(z1, z2, z3)].
Now for the almost sure encoding. We deﬁne the ﬁrst-order ternary
predicate (considering u as a variable symbol)
Ru(x, y) := ∃v[v ∼x ∧v ∼y ∧v ∼u],
that u, x, y have a common neighbor. Our basic idea (though it will need
modiﬁcation) is to replace the second-order ∃R with the ﬁrst-order ∃u and
then to replace all instances of the binary R with the new binary Ru.
Lemma 4.9.1 (Representation Lemma). For any s and any symmetric
areﬂexive R on 1, . . . , s that holds for l pairs with l < k/3,
∀x1,...,xs∃u
	
1≤i<j≤s
(Ru(xi, xj) ↔R(i, j))
is a theorem of T = Tα for all 1/3 + 1/k > α > 1/3 + 1/(k + 1).
Consider the rooted graph, call it (S, H), with roots 1, . . . , s and nonroot
u, and then, for each 1 ≤i < j ≤s a nonroot vij with edges from vij to i, j, u.
(S, H) has v = 1 + l nonroots and e = 3l edges. Our bound on l assures that
v −eα > 0 so that (S, H) is sparse, and some easy combinatorial work shows
that it is safe as well. In Tα we have the 1-Generic Extension axiom for (S, H).
For all x1, . . . , xs there exists a u and vij having the above edges and no more,
so that, when R(i, j) holds, we do have Ru(xi, xj). Suppose now that ¬R(i, j);
can u, xi, xj have a common neighbor? A common neighbor to three vertices
is a rigid extension in our range α > 1/3 so this would violate 1-genericity.
We outline a second argument more for those readers in the random graph
community. Set p = n−1/3−ε so that 1/k > ε > 1/(k + 1). Any particular
Ru(x, y) holds with probability roughly np3 ∼n−3ε, that being the expected
number of common neighbors. Say u is a witness if Ru(x, y) holds for the l
needed pairs. Then u would be a witness with a probability of roughly n−3lε.
There are n potential witnesses, so the expected number of witnesses would be
roughly n1−3lε. As 3lε < 1, this expected number goes to inﬁnity, and almost
surely for every choice of the x’s there is one. There are a number of ques-
tions here (for one thing, u, u′ being witnesses are no longer fully independent
events) that need to be ﬂeshed out, but this can be turned into a full proof.
We have a small technical problem. We want to say EV EN(S), where
S = N(x1, x2, x3) has at most k elements, by saying that there is a matching
R. Such an R would have perhaps k/2 edges while our Representation Lemma
only gives us Ru with at most k/3 edges. We puﬀup the Representation
Lemma by replacing ∃R with ∃u1,u2 and replacing R with Ru1 ∨Ru2. Now
we represent all R with up to just fewer than 2k/3 edges. To write it out
in full, “N(x1, x2, x3) is even” is replaced by “there exist u1, u2 such that

246
4 Logic and Random Structures
for all y adjacent to x1, x2, x3 there exists a unique y′ ̸= y adjacent to
x1, x2, x3 with either y, y′, u1 or y, y′, u2 having a common neighbor”. Sim-
ilarly, BIGGER(S, T ) may require an injection R of k edges. We therefore
replace ∃R with ∃u1,u2,u3,u4 and R with Ru1 ∨Ru2 ∨Ru3 ∨Ru4. With this,
BIGGER(N(x1, x2, x3), N(x′
1x′
2x′
3)) becomes a ﬁrst-order predicate. We
have given an almost sure encoding that transforms the second order A∗
into a totally ﬁrst-order (though hardly natural to those in graph theory!)
sentence A which has the desired inﬁnite spectrum.
The notion of an almost sure encoding is an intriguing one and will appear
several more times. One is given a property P in some large language L+
and one wishes to ﬁnd (or, in one example later, to disprove the existence of)
a sentence A in a given smaller language L which is an almost sure encoding
of it. By this we mean that the probability of P and A diﬀering in truth
value goes to zero as the model size goes to inﬁnity. Of course, one also has
to ﬁx the probability measure, in our case G(n, p(n)) with some particular
p(n). Hella, Kolaitis
and Luosto have called two languages L, L′ “almost
everywhere equivalent” if for every P in one language there is an A in the
other where, as above, the probability of P, A diﬀering in truth value goes to
zero as the model size goes to inﬁnity. One particularly intriguing problem
they give involves G(n, p) with p = 1/2: Is monadic existential second-order
logic almost everywhere equivalent to monadic universal second-order logic?
They conjecture that the answer is no, but it does seem diﬃcult to show
negative results about the existence of an almost sure encoding.
4.10 The Jump Condition
We have already mentioned that the theories Tα are all distinct. However,
if we ﬁx the quantiﬁer depth u of the sentences we are examining, the values
α fall into deﬁnite intervals. Let us recall the sequence t0, . . . , tu from Sect.
4.5. We had t0 = 0, t1 = 1, and ti+1 = max[ti, ⌈(u −i)ε−1⌉] where ε was the
minimum value of v−1(eα−v) over all integers v, e with v ≤ti and v−eα ≤0.
We may try to deﬁne this sequence for rational α as well. It does not always
work. Take, for example, u = 5 and α = 1/3 + 10−6. With t1 = 1, we take
v = 1 and e = 3 to give ε = 3 · 10−6. This yields a t2 of roughly 4
3106, which
is bigger than the numerator 106 + 1 of α. Now, in trying to deﬁne t3, we
have v, e with v ≤t2 and v −eα = 0, so that ε = 0 and the process explodes.
This is not a surprise, the zero-one law is not supposed to hold for rational
α. But it will hold on sentences of quantiﬁer depth u if the rational α is not
too rational. To be precise, let XPLu denote the set of rational α for which
the sequence t0, . . . , tu is not well deﬁned, together (a technical point) with
those α for which the sequence is well deﬁned and α has a numerator of at
most tu. For α ̸∈XPLu we do get a zero-one law. It turns out that XPLu
is a well-ordered set under the ordering >. (There is a lot of pretty number
theory involved in studying XPLu, which is quite reminiscent of continued

4.11 The Complexity Condition
247
fractions. The example above actually shows that 1/3 + 1/m ∈EXP5 for all
large integers m, so that EXP5 is inﬁnite. Here 1/3 is an accumulation point
of EXP5 but only from larger values.) That is, for every a/b ∈XPLu (except
the smallest) there is an (a/b)−∈XPLu which is the biggest element of
XPLu smaller than a/b. Then XPLu splits the unit interval into intervals I
from (going down) a/b to (a/b)−. (We include the I from the smallest value
of XPLu to zero.) Inside each interval, the sequences t0, . . . , tu are the same.
Further, the truth value of any A of quantiﬁer depth u remains the same as
α ranges over such an I. (Basically, one only needs notions of safe and dense
rooted graphs up to v = tu, and these notions are the same for all α in the
interval.) To rewrite this as a condition on possible fA:
Jump Condition. If f = fA for some ﬁrst-order A then there is a u such that
f is constant on each interval I deﬁned by the splitting set XPLu.
4.11 The Complexity Condition
For α ∈(0, 1] rational, let us deﬁne gA(α) to be the limiting value of fA(α−ε)
as ε approaches zero from above. Since EXPu is well ordered under >, this is
well deﬁned. Indeed, for α ∈EXPu this gives the value of fA on the interval
from α to the next α−. Since the intervals I deﬁned above partition the unit
interval, gA will determine fA.
For α ∈(0, 1], we deﬁne a theory T −
α . This will be the limiting theory of
the Tα+ε as ε approaches zero from above. Recall that the splitting into dense
and sparse rooted graphs was not a strict dichotomy for α rational, because
of the possibility that v −eα = 0. In T −
α , we simply consider such rooted
graphs as sparse, as that is their status in Tα+ε with ε positive. This can be
shown to give a complete theory, and gA(α) = 1 precisely when A lies in this
theory. We have a most surprising complexity condition on the functions gA.
Complexity Condition:
{0a1b : A ∈T −
a/b} ∈PH.
To see this, let us ﬁx the quantiﬁer depth u and consider how diﬃcult it
is to ﬁnd if A ∈T −
a/b as a function of the denominator b. We can, as before,
deﬁne the sequence t0, . . . , tu. Here, having deﬁned ti, we deﬁne ε by only
looking at those v, e with v ≤ti and v −e(a/b) strictly negative. But then
v −e(a/b) has a denominator of at most tib and so ε ≥(tib)−1. Other terms
(considering u ﬁxed) supply bounded factors; basically ti goes up by at most
a factor of b as i increases. That is, ti = O(bi).
We can write any A of quantiﬁer depth u in the form
A : Qx1Qx2 · · · QxuP(x1, . . . , xu)
where Q is either ∃or ∀, very possibly taking diﬀerent values at diﬀerent
times, and P is a Boolean expression composed from the atoms xi = xj and

248
4 Logic and Random Structures
xi ∼xj. The truth value of A in T −
a/b can now be turned into a game between
two players. We shall call them Spoiler and Duplicator as before, though this
game is not the Ehrenfeucht game. Duplicator’s object is to show that A is
a consequence of T −
a/b, and Spoiler tries to show that it is not.
The Game Board. The game board has levels 0, 1, . . . , u. Each level has a
ﬁnite set of positions. At level 0 are the possible values of cl0(x1, . . . , xu).
(Recall that these are determined by the graph on {x1, . . . , xu} and, to
be formally correct, the equalities amongst the xi.) At level i are the
possible values of the ti-closure of x1, . . . , xu−i. When i = u, the top
level, there is only one possible tu-closure of ∅, namely ∅, so there is only
a single position.
The Initial Position. The top-level position ∅.
The Winning Final Positions. The 0-position determines the truth value
of P(x1, . . . , xu) – we call a 0-position winning if P is true, otherwise we
call it losing.
The Permitted Moves. All moves go down one level. Let H and H′ be
positions on the levels i and i −1 respectively. Moving from H to H′
is permitted if and only if, in T −
a/b, the following is a theorem: Given
any x1, . . . , xu−i with ti-closure H, there exists an xu−i+1 such that the
ti−1-closure of x1, . . . , xu−i, xu−i+1 is H′. We have argued that the Tα
are complete via the Ehrenfeucht game, but it could have been done
syntactically. The key result is that in Tα, for any positions H, H′ on the
levels i, i −1, either the above is a theorem or there is a theorem that
says: Given any x1, . . . , xu−i with ti-closure H there does not exist an
xu−i+1 such that the ti−1-closure of x1, . . . , xu−i, xu−i+1 is H′.
The Rules of the Game. There are u rounds. In the ith round when xi is
quantiﬁed existentially (i.e. Q = ∃) it is Duplicator’s move, and when it
is quantiﬁed universally it is Spoiler’s move. In either case, the permitted
moves are given above so that the position moves through the levels and at
the end of the u rounds is on the bottom level. Those positions have been
designated winning and losing, and Duplicator wins or loses accordingly.
This game description works for any Tα or T −
a/b. But with T −
a/b, we can
bound the game complexity by noting that each position is given by a graph
(together with designated vertices) of size polynomial in b, certainly O(bu),
and hence can be described by a sequence of bits of length O(b2u). Therefore
winning the game has a complexity in the polynomial hierarchy at level u.
Well, not quite. We also have to examine whether a move H to H′ is per-
missible. To “prove” that the move is permissible, Duplicator draws a picture
of H and H′. When the move is Inside she simply designates the new move
xu−i+1 and the set H′ which is the new closure. When the move is Outside,
she states which vertices of H are still in H′ plus she adds the new vertices
(called NEW in the completeness proof) with all edges and a designated
vertex xu−i+1. She further lists the sequence of rigid extensions that give

4.12 Nonconvergence via Almost Sure Encoding
249
the ti+1-closure. All this can be done with a polynomial-length string. Now
Spoiler is allowed a polynomial-length string to show that Duplicator has been
duplicitous. He can show that one of the rigid extensions is not really rigid by
nailing down some vertices so that the extension becomes sparse. He can show
(in the Outside case) that NEW is not really safe over H by demonstrating
a dense subextension. Finally, he can show that the ti+1-closure is more than
H′ by exhibiting, inside Duplicator’s picture of H ∪H′, a dense extension.
(There is a theorem that dense extensions must contain rigid subextensions,
so he need not show that his extension is rigid.) This shows that the
permissibility of a move is in the second level of the polynomial heirarchy.
Remarkably, the Jump Condition and the Complexity Condition charac-
terize the possible functions fA. We have seen, albeit in outline form, that
these conditions are necessary. That they are suﬃcient is technically quite
challenging. In personal communication, an argument for the suﬃciency has
been outlined by G´abor Tardos.
4.12 Nonconvergence via Almost Sure Encoding
Let us turn to the random ordered graph G<(n, p). The underlying model is
still a vertex set Ω of size n and a probability space of graphs on Ω where
each pair of vertices is adjacent with independent probability p. In addition,
the set Ω is totally ordered by a built-in relation <. This relation is part
of the language. For convenience, we can assume Ω = {1, . . . , n}. Now 1 is
uniquely deﬁned as that element with nothing less than it, and 2 is uniquely
deﬁned as that element with only 1 less than it. We can that express 1 ∼2
by the ﬁrst order sentence
∃x∃y(x ̸= y) ∧(x < y) ∧[∀zz < y →z = x] ∧x ∼y.
This event (for n ≥2) has probability p. We shall write y = x + 1 if x < y
and there is no z in between them. When y ̸= 1 we write x = y −1 when
y = x + 1. Note, however, that addition and subtraction are in general not
deﬁned in this language.
We shall restrict our attention to p = 1/2. The example above shows that
there is no zero-one law, that Pr[A] need not converge to zero or one. We aim
for the following stronger negative result of Compton, Hansen, and Shelah.
Theorem 4.12.1. There is an A for which limn→∞Pr[G<(n, 1/2) |= A] does
not exist.
The central idea is to encode arithmetic on an ordered set S, ﬁrst using
second-order language and then in ﬁrst-order with an almost sure encoding.
The second-order encoding is standard. We say that on S there exist ternary
relations +(x, y, z) and ∗(x, y, z) (with the interpretations x + y = z and
x · y = z, respectively) such that the following apply:

250
4 Logic and Random Structures
1. +(x, 1, z) if and only if z = x + 1 as described above.
2. When y ̸= 1, +(x, y, z) if and only if +(x, y −1, z −1)
3. ∗(x, 1, z) if and only if z = x
4. When y ̸= 1, ∗(x, y, z) if and only if there exists a u with ∗(x, y −1, u)
and +(x, u, z).
When this occurs, we say S is arithmetizable. Now for the almost sure encod-
ing. For c ≤d, we write Rc,d(x, y, z) if x, y ≤z and (critically) there exists
an e with c ≤e < d such that e is adjacent to x, y, z and no other elements of
S. We say S is ﬁrst-order arithmetizable if there exist c, d and c′, d′ such that
Rc,d, Rc′,d′ have the properties of “plus” and “times” enumerated above. For
our speciﬁc purposes we shall consider only S of the form {1, . . . , u} though
one could give similar results for more general S with a little more technical
work. We make all logarithms to base 2 in what follows, for deﬁniteness.
Lemma 4.12.2 (Representation Lemma). Let u ≤0.9 log1/3 n. Then
almost surely there exist c ≤d such that Rc,d is the ternary relation + on
{1, . . . , u} and also c ≤d such that Rc,d is ∗.
Let + have s instances. Observe that s < u2. Consider a pair c, d with
u < c and d = c + s. We call c a witness if Rc,d is indeed + on {1, . . . , u}
There is an arrangement (indeed, many such) of the edges between {1, . . . , u}
and {c, . . . , d −1} such that c is a witness. This occurs if us pairs have a
particular set of adjacencies (and no more), and so has a probability 2−us of
occurring. There are ∼n potential witnesses c so that the expected number
of witnesses is bigger than roughly n2−us. We have bounded u so that
us < u3 < (0.9)3 log n, and so this expected number goes to inﬁnity. Some
technical work shows that almost surely there is a witness. (Actually, the
technical work isn’t so diﬃcult here. We can pick ∼c′n log−1/3 n values c so
that the intervals [c, d) are disjoint, and so the events that c is a witness are
mutually independent over those diﬀerent c’s.) Representing ∗is the same.
Indeed, with further technical work (perhaps modifying the bound on u), one
could almost surely represent every ternary, even k-ary, relation R.
Similar arguments, which we exclude, show that when u > C log1/3 n
(where C is a computable absolute constant) the Representation Lemma
almost surely fails and {1, . . . , u} is not ﬁrst-order arithmetizable. For
deﬁniteness, let us take C = 900. Now the maximal u such that {1, . . ., u} is
ﬁrst-order arithmetizable is determined up to a factor of 1000.
Once we have arithmetized {1, . . ., u} we are oﬀto the races. We can say
that u is prime, that u is a Fermat prime; there is a large spectrum here.
Certainly we can talk about log u.
Now we can give our ﬁrst-order sentence A: There exists u such that
1. {1, . . . , u} is ﬁrst-order arithmetizable
2. {1, . . . , u + 1} is not ﬁrst-order arithmetizable
3. log u modulo 40 is one of 1, 2, . . ., 20.

4.13 No Almost Sure Representation of Evenness
251
Why does this work? The size n of the model almost surely determines
u up to a factor of 1000 and so log u is almost surely determined up to an
additive term of 10. For some n, this range of log u will all be in 1, . . . , 20
modulo 40, while for other n this range will all be in 21, . . ., 39, 0 modulo 40.
This gives inﬁnite subsequences of n on which our sentence has a limiting
probility of one and zero respectively, the worst kind of nonconvergence.
Almost sure encoding can be used to show nonconvergence by encoding
arithmetic in other contexts. We shall examine, in outline form, G(n, n−1/4).
Note that we do not include < as a built-in predicate here. We arithmetize
a set S in the second-order language by saying that there exists a binary
< and ternary +, ∗with the desired ﬁrst-order properties. For u ̸∈S, we
deﬁne a ternary Ru on S, letting Ru(x, y, z) be the ﬁrst order property
that u, x, y, z have a common neighbor. Also, for u, x ̸∈S we have the
binary relation Ru,x(y, z) = Ru(x, y, z). (We actually need further technical
work here in that such relations are symmetric while < is not.) We say
that S is ﬁrst-order arithmetizable if there exist u1, u2, u3, u4 such that
Ru1,u2, Ru3, Ru4 play the role of <, +, ∗. At p = n−1/4, any four vertices have
probability (1 −p4)n−4 ∼e−1 of having no common neighbor. Basically, each
Ru acts like an independent (this part takes some technical work) random
ternary predicate with a probability of occurance 1 −e−1. Key here is that
both 1 −e−1 and e−1 are bounded away from zero. Letting S have size s, a
given u witnesses a particular ternary R with probability at least e−t, where
t =
s
3

is the number of triples. The expected number of witnesses is at
least ne−t. For s ≤ln1/3 n this goes to inﬁnity and one can show that almost
surely +, ∗, < are represented. We cannot quantify over all subsets S in the
ﬁrst-order language but instead look at sets S = N(x1, x2, x3, x4), the set of
common neighbors of x1, x2, x3, x4. One can show that there are such S’s of
all sizes up to roughly ln n/ ln ln n. On sets S, T of size O(ln1/3 n) we can say
BIGGER(S, T ) in the ﬁrst-order language (as done in Sect. 4.9) by saying
there exist u1, u2 such that Ru1,u2 gives an injection from T to S. It is then
a ﬁrst-order property of x1, x2, x3, x4 that S = N(x1, x2, x3, x4) is arithmeti-
zable but there is no “bigger” arithmetizable S′ = N(x′
1, x′
2, x′
3, x′
4). Such an
S would almost surely have a size Θ(ln1/3 n). But when S is arithmetizable,
we can say a wide variety of things about its size u. In particular, we get a
nonconvergent sentence by saying that there exist x1, x2, x3, x4 such that the
size u = |N(x1, x2, x3, x4)| has log u between 1 and 20 modulo 40.
4.13 No Almost Sure Representation of Evenness
In this section we restrict ourselves to the random ordered graph G<(n, p)
with p = 1/2. We set, for any property A,
fA(n) = Pr[G<(n, p) |= A]
We shall outline the proof of the following result of Saharon Shelah.

252
4 Logic and Random Structures
Theorem 4.13.1. For any ﬁrst-order A
lim
n→∞fA(n + 1) −fA(n) = 0.
This provides an interesting counterpoint to the Compton, Hansen, and
Shelah result discussed earlier. There are A’s for which fA(n) does not
converge, but it cannot oscillate back and forth too fast. There is a very
nice corollary: There is no ﬁrst-order sentence that provides an almost sure
representation for the property that the number n of vertices is even. For such
an A would have fA(2n) →1 and fA(2n + 1) →0, which would contradict
the slow oscillation of Shelah’s Theorem. We ﬁnd, in general, that it is quite
diﬃcult to prove negative results about almost sure representation, and in
this context Shelah’s result is particularly striking.
We link G<(n, p) and G<(n + 1, p) by the following procedure. Take a
random graph on 2n + 1 ordered vertices, and call it G ∼G<(2n + 1, p).
Restricting to a random subset S of size precisely n gives G(n), with a
distribution that is that of G<(n, p). Restricting to a random set S of size
precisely n + 1 similarly gives G(n+1) ∼G<(n + 1, p). We thus have
fA(n + 1) −fA(n) =

G
μ(G)
 
Pr[G(n+1) |= A] −Pr[G(n) |= A]
!
where μ(G) is the probability that G<(2n+1, p) is G. Shelah actually showed
that for every G on 2n + 1 ordered vertices



Pr[G(n+1) |= A] −Pr[G(n) |= A]



 →0
Fix G and a property A. Consider the property that G restricted to S
satisﬁes A as a function of S. For example, a sentence such as
∃x∀y∃zz ∼y ∧y ∼x
would turn into
∃x(x ∈S) ∧[∀y(y ∈S) →∃z(z ∈S) ∧(z ∼x) ∧(z ∼y)] .
Such a property A∗is a Boolean function of the variables x ∈S for
x = 1, . . . , 2n + 1. Here we turn to circuit complexity – the function may
be represented by a circuit with primitives x ∈S. Each ∃x is an OR gate with
fan-in 2n+1 (that is, all x), and each ∀x is an AND gate also with fan-in 2n+1.
The statements x ∼y and x < y then have deﬁnite truth values and so do not
appear in the circuit. A∗is then represented by a bounded-depth polynomial-
size circuit. It is a deep theorem of circuit complexity (due originally to
Razborov) that such a circuit cannot determine majority – that is, cannot be
true if and only if at least half of the 2n+1 inputs are true. Some further tech-
nical work shows that no such circuit can distinguish between a random n and
n+1 inputs being true - that the diﬀerence in the probability that the circuit
yields true in the two experiments must tend to zero. This gives Shelah’s result.

4.14 The Ehrenfeucht Game
253
4.14 The Ehrenfeucht Game
The Ehrenfeucht game is a powerful and very general method for showing
that two models have (or do not have) the same ﬁrst-order properties. We
consider ﬁrst the speciﬁc example of graphs. Let G, H be two graphs and let
t be a positive integer. We describe the Ehrenfeucht game EHR(G, H; t).
The Board A copy of G and a copy of H on disjoint vertex sets.
The Players Spoiler and Duplicator.
The Play There are t rounds. In the i-th round Spoiler goes ﬁrst. He selects
either a vertex from G or a vertex from H. Then Duplicator goes. She
selects a vertex from the graph that Spoiler did not select from. We let
xi denote the vertex selected from G in the ith round and yi the vertex
selected from H in the ith round, regardless of who selected them. We
note that Spoiler’s choice of which graph to choose from can change from
round to round.
The Winner Duplicator wins if and only if the map from xi to yi preserves
adjacency and equality. That is, xi, xj are adjacent in G precisely when
yi, yj are adjacent in H. Further, xi = xj precisely when yi = yj.
We note that when the graphs both have at least t vertices, there is no point
in Spoiler selecting an xj equal to a previous xi, as then Duplicator would
simply select yj = yi. Hence we could add the requirement that Spoiler always
picks a new vertex. Then Duplicator would also always pick a new vertex.
Theorem 4.14.1. Duplicator wins EHR[G, H; t] if and only if G, H have the
same truth values on all ﬁrst-order sentences of quantiﬁer depth t.
We illustrate this fundamental result with an example. Suppose G has an
isolated vertex and H does not. The property ∀x∃yx ∼y has quantiﬁer depth
t = 2. Spoiler selects the isolated vertex x1 ∈G and Duplicator must select
some y1 ∈H. As y1 is not isolated, Spoiler moves over to H and selects a
y2 ∈H adjacent to y1. Now Duplicator is stuck, there is no x2 ∈G adjacent
to x1 for her to select.
As an immediate corollary, G, H are elementarily equivalent if and only if
Duplicator wins EHR[G, H; t] for every positive integer t. Note, however, that
this is not the same as Duplicator winning a game with an inﬁnite number
of moves.
Corollary 4.14.2. Let T be a consistent theory with no ﬁnite models. Then
T is complete if and only if, for every two countable models G, H of T and
every positive integer t, Duplicator wins EHR[G, H; t].
If T is complete, the models G, H are necessarily elementarily equivalent
so that Duplicator wins. If T is not complete, there is a sentence A such that
T + A and T + ¬A are both consistent and so they have countable models
G, H. Letting t be the quantiﬁer depth of A, Spoiler would win EHR[G, H; t].

254
4 Logic and Random Structures
Let us generalize to ﬁrst-order languages (we could go even further) with
a ﬁnite number of relation symbols R of varying arity. This would include the
ordered graph (with < as well as adjacency) or the simple unary language
(with only one unary U and equality) of Sect. 4.1. Let G, H be two models of
the language. Then EHR[G, H; t] is played as described above, with Spoiler
and Duplicator selecting x1, . . . , xt ∈G and y1, . . . , yt ∈H. For Duplicator to
win, she now has to preserve all the relations. That is, let R be any relation
symbol of arity l, say. Then R(xi1, . . . , xil) must have the same truth value
as R(yi1, . . . , yil) for every choice of i1, . . . , il from 1, . . . , t.
4.15 About the References
Among the other surveys of this area, we recommend those of Compton [3],
Winkler [26], Lynch [15], and this author [23]. The Ehrenfeucht game was
ﬁrst given in [5]. (It was essentially found in earlier work by Fra¨ıss´e and is
sometimes referred to as the Ehrenfeucht–Fra¨ıss´e game.) The classic zero-one
law for random graphs with p = 1/2 (often called the uniform distribution)
is due to Glebskii et al. [8] and Fagin [7]. The classic paper that began the
theory of random graphs was that by Paul Erd˝os and Alfred R´enyi [6]. The
basic text on random graphs is that by Bollob´as [2].
The zero-one Law for p = n−α appeared ﬁrst in [17]. An approach using
the Ehrenfeucht game is given in [21]. A syntactic proof of the completeness
of the Tα is given in [22]. An examination of the countable models of Tα is
given in [20]. The text [1] also includes some of this material.
In this brief chapter we have examined only a few examples of random
structures. Among the many others we shall mention [14] on unary func-
tions, [18, 24] on random unary predicates with order (considerably diﬀerent
from sect. 4.1!), and [11] on random partially ordered sets. Luczak and
Shelah [12] have considered an interesting random graph model on vertex set
1, . . . , n where the adjacency probability between i and j depends on |i −j|.
While we have restricted ourselves here to ﬁrst-order logic there are a
number of papers considering stronger logics. Generally, these give negative
results that a zero-one law or convergence does not always hold. A nice
example is given by Kaufmann and Shelah [10], giving a nonconvergent
second-order sentence on G(n, p) with p = 1/2. Many such results, including
those on the random ordered graph given in the text above, can be found
in [4]. Shelah [16] has shown that, on the random ordered graph, no ﬁrst order
sentence can almost surely encode the evenness of the model. Hella, Kolaitis,
and Luosto [9] have considered the general problem of almost sure equivalence.
Spencer [19] has examined the random graph theory of extension state-
ments in some detail. Luczak and Spencer [13] have used some detailed random
graph theory to give a near characterization of those p = p(n) (not just those
of the form n−α) for which the zero-one law holds. Spencer and Tardos [25]
have given the necessary conditions on the function fA(α) deﬁned in the text.

References
255
References
1. N. Alon and J. Spencer. The Probabilistic Method. Wiley, 1991.
2. B. Bollob´as. Random Graphs. Academic Press, 1985.
3. K.J. Compton, 0 −1 laws in logic and combinatorics. In I. Rival, editor,
Algorithms and Order, pages 353–383, NATO ASI Series, Kluwer Academic,
Dordrecht, 1988.
4. K.J. Compton, C.W. Henson, and S. Shelah. Nonconvergence, undecidability
and intractability in asymptotics problems. Annals of Pure and Applied Logic,
36:207-224, 1987.
5. A. Ehrenfeucht. An application of games to the completeness problem for
formalized theories. Fundamenta Mathematicae, 49:129–141, 1961.
6. P. Erd˝os and A. R´enyi. On the Evolution of Random Graphs. Matematikai
Kutat´o Int´ezet K¨ozlem´enyei, 5:17-60, 1960.
7. R. Fagin. Probabilities in ﬁnite models. Journal of Symbolic Logic, 41:50–58,
1976.
8. Y.V. Glebskii, D.I. Kogan, M.I. Liagonkii, and V.A. Talanov. Range and degree
of realizability of formulas in the restricted predicate calculua. Cybernetics,
5:142–154. (Russian original: Kibernetica,5:17-27, 1969.)
9. L. Hella, P.G. Kolaitis, and K. Luosto. Almost everywhere equivalence of logics
in ﬁnite model theory. Bulletin of Symbolic Logic, 2:422–443, 1996.
10. M. Kaufmann and S. Shelah. On random models of ﬁnite power and monadic
logic. Discrete Mathematics, 54:285–293, 1983.
11. T. Luczak. First order properties of random posets. Order, 8:291–297, 1991.
12. T. Luczak and S. Shelah. Convergence in homogeneous random graphs. Random
Structures & Algorithms, 6:371–392, 1995.
13. T. Luczak and J. Spencer. When does the zero-one law hold? Journal of the
American Mathematical Society, 4:451-468, 1991.
14. J. Lynch. Probabilities of ﬁrst-order sentences about unary functions. Transac-
tions of the American Mathematical Society, 287:543–568, 1985.
15. J. Lynch. Special year on logic and algorithms tutorial notes: Random ﬁnite
models. DIMACS Technical Report 97-56, 1997.
16. S. Shelah. Very weak zero one law for random graphs with order and random
binary functions. Random Structures & Algorithms, 9:351–358, 1995.
17. S. Shelah and J. Spencer. Zero–one laws for sparse random graphs. Journal of
the American Mathematical Society, 1:97–115, 1988.
18. S. Shelah and J. Spencer. Random sparse unary predicates. Random Structures
& Algorithms, 5:375-394, 1994.
19. J. Spencer. Threshold functions for extension statements. Journal of Combina-
torial Theory Series A, 53:286–305, 1990.
20. J. Spencer. Countable sparse random graphs. Random Structures & Algorithms,
1:205-214, 1990.
21. J.
Spencer. Zero-one
laws
via
the
Ehrenfeucht
game.
Discrete Applied
Mathematics, 30:235-252, 1991.
22. J. Spencer. Sparse random graphs: a continuum of complete theories. In
D. Miklos, editor, Proceedings of the International Conference “Sets, Graphs
and Numbers”, pages 679–690. Colloq. Math. Soc. J´anos Bolyai 60. North-
Holland, 1991.
23. J. Spencer. Zero–one laws with variable probability. Journal of Symbolic Logic,
58:1-14, 1993.

256
4 Logic and Random Structures
24. J. Spencer and K. StJohn. Random unary predicates: Almost sure theories and
countable models. Random Structures & Algorithms, 13:229–248, 1998.
25. J. Spencer and G. Tardos. Ups and downs of ﬁrst order sentences on random
graphs. Combinatorica, 20:263-280, 2000.
26. P. Winkler. Random structures and zero–one laws. In N.W. Sauer, R.E.
Woodrow and B. Sands, editors, Finite and Inﬁnite Combinatorics in Sets
and Logic, pages 399–420. NATO Advanced Science Institutes Series, Kluwer
Academic, Dordrecht 1993.

5
Embedded Finite Models and Constraint
Databases
Leonid Libkin
5.1 Introduction
The goal of this chapter is to answer two questions:
1. How does one store an inﬁnite set in a database?
2. And what does it have to do with ﬁnite model theory?
Clearly, one cannot store an inﬁnite set, but instead one can store a ﬁnite
representation of an inﬁnite set and write queries as if the entire inﬁnite set
were stored. This is the key idea behind constraint databases, which emerged
relatively recently as a very active area of database research. The primary
motivation comes from geographical and temporal databases: how does one
store a region in a database? More importantly, how does one design a query
language that makes the user view a region as if it were an inﬁnite collection
of points stored in the database?
Finite representations used in constraint databases are ﬁrst-order formu-
lae; in geographical applications, one often uses Boolean combinations of linear
or polynomial inequalities. One of the most challenging questions in the devel-
opment of the theory of constraint databases has been that of the expressive
power: what are the limitations of query languages for constraint databases?
These questions were easily reduced to questions about the expressiveness of
query languages over ordinary ﬁnite relational databases, with the additional
condition that databases may store numbers and arithmetic operations may
be used in queries. This is exactly the setting of embedded ﬁnite model theory.
It turned out that the classical techniques for analyzing the expressive
power of relational query languages no longer worked in this new setting.
In the past several years, however, most questions about the expressive
power have been settled, by using new techniques that mix the ﬁnite and
the inﬁnite, and bring together results from a number of ﬁelds such as model
theory, algebraic geometry, and symbolic computation.
In this chapter we present a variety of results on embedded ﬁnite models
and constraint databases. The core part of this chapter deals with new

258
5 Embedded Finite Models and Constraint Databases
techniques for analyzing expressive power in the mixed setting. These
techniques, which come in the form of collapse results, reduce many ques-
tions over constraint databases or embedded ﬁnite models to the classical
ﬁnite-model-theory setting.
5.1.1 Organization
In Sect. 5.2, we describe the setting of embedded ﬁnite models, and explain
connections with relational database theory. Sect. 5.3 contains a brief
introduction into constraint databases.
Sect. 5.4 gives an overview of collapse results; it also deﬁnes various
semantics of logical formulae, and introduces the notion of genericity. Sections
5.5 and 5.6 describe collapse results for various semantics and various notions
of genericity. In Sect. 5.7 we look into connections between collapse results
and various model-theoretic notions, and in Section 5.8 we describe a close
relationship between collapse results and the notion of the VC dimension,
which is of interest in model theory and machine learning. Sect. 5.9 presents
results on the expressive power of query languages over constraint databases
that use two diﬀerent techniques: reduction to the case of embedded ﬁnite
models, and the analysis of the topological structure of constraint databases.
Sections 5.10 and 5.11 deal with topics motivated by database consid-
erations. Sect. 5.10 studies query safety, which means guaranteeing ﬁnite
output for relational databases, and some geometric properties for constraint
databases. Section 5.11 brieﬂy analyzes the problems of aggregate operators
and higher-order features in constraint databases.
5.2 Relational Databases and Embedded Finite Models
In classical ﬁnite model theory, we work with ﬁnite structures and deal with
sentences such as
∃x∃y∀z(¬E(z, x) ∨¬E(z, y))
which says that the diameter of an (undirected) graph with edge-set E is at
least 3. In embedded ﬁnite model theory, we still work with ﬁnite structures
but deal with sentences like
∃x∃y (E(x, y) ∧(y = x · x + 1))
which says that there is an edge (x, y) in a graph with y = x2 + 1. It is
assumed here that the nodes of a graph come from some domain that is
equipped with arithmetic operations such as addition and multiplication; for
example, the nodes could be natural, rational, or real numbers.
To illustrate the diﬀerence, consider as an example a relational signature
of directed graphs, consisting of a single edge-predicate E. Suppose we want
to ﬁnd the composition of E with itself; that is, to ﬁnd pairs (a, b) in a

5.2 Relational Databases and Embedded Finite Models
259
directed graph that are connected by a path of length at most 2. This is done
by writing a formula
ϕ(x, y) ≡∃z (E(x, z) ∧E(z, y)).
This formula gives us a conjunctive query; it can be written in a variety of
relational database languages: as
q(x, y) :- E(x, z), E(z, y)
in Datalog, or
π#1,#4 (σ#2=#3 (R × R) )
in relational algebra, or
SELECT R1.Source, R2.Destination
FROM R R1, R R2
WHERE R1.Destination=R2.Source
in SQL.
Now suppose that the nodes of the graph are natural numbers, and we
are only willing to consider paths E(x, z), E(z, y) in which x, y, z are related
by some condition: for example, x + y = z. It is straightforward to rewrite
the above query in ﬁrst-order logic as
ϕ′(x, y) ≡∃z (E(x, z) ∧E(z, y) ∧(x + y = z)),
or in SQL as
SELECT R1.Source, R2.Destination
FROM R R1, R R2
WHERE R1.Destination=R2.Source
AND R1.Source + R2.Destination = R2.Source
But what about relational algebra? The most natural way seems to be
π#1,#4 (σ(#2=#3)∧(#1+#4=#2) (R × R) );
however, relational algebra does not allow arithmetic operations in its
selection predicates.
At the ﬁrst glance, this is easy to remedy: just add arithmetic predicates
to the selection conditions. While this seems to be easy, there appear to be
two serious problems.
Expressive power. We know that ﬁrst-order logic, and thus relational algebra,
cannot express most recursive and counting queries, such as the transitive
closure of a relation or the parity of a set. However, this was proved under
the assumption that only equality and order comparisons are allowed on

260
5 Embedded Finite Models and Constraint Databases
nodes of graphs. How does one prove the analogous result (if it is true)
if nodes are numbers, and arithmetic operations are used in formulae?
It appears that the standard techniques for proving expressivity
bounds are not directly applicable in this case. Tools based on locality
cannot tell us anything meaningful, owing to the presence of order; 0-1
laws are inapplicable altogether, and games become unmanageable as
the duplicator must maintain partial isomorphism not only for the graph
edges but also for all the arithmetic predicates as well. It thus seems
that entirely diﬀerent techniques are needed to solve the problem of the
expressive power in this setting.
Query Evaluation. It is clear that the query ϕ′ above can be evaluated by the
usual bottom-up technique: we ﬁrst construct R × R, then select all the
tuples (a, b, c, d) with b = c and a + d = b, and then project out the ﬁrst
and the last components. However, what if the condition is not x + y = z
but that z is a perfect square? The query will then be rewritten as
ϕ′′(x, y) ≡∃z (E(x, z) ∧E(z, y) ∧(∃u (z = u · u))),
and the selection condition will have to evaluate ∃u (z = u · u) with u
ranging over the inﬁnite set of natural numbers! In this particular case,
it appears that the evaluation is possible: one does not have to check all
u ∈N, but only u ≤z. However, one can have more complex conditions,
for example ∃x1 . . . ∃xk p(x1, . . . , xk) = 0, where p is some polynomial
with integer coeﬃcients. The truth value of this sentence cannot be
determined algorithmically, as this would imply solving Hilbert’s tenth
problem. Thus, it is not always possible to evaluate queries with arith-
metic conditions. In general, one would encounter this problem in dealing
with any undecidable theory.
To give another example of potential problems with query evaluation,
consider the following query ψ(x), saying that x2 belongs to S:
∃y S(y) ∧(x · x = y).
This query is clearly evaluable, but its output depends on whether one
works with real numbers, or integers; for example, over the reals, the
output is {−√a, √a | a ∈S}, but over the integers one has to select
integers from this set. Thus, the output is diﬀerent depending on the
range of the quantiﬁer ∃y: whether it is R or Z. Also, it is not immediately
clear how a query processor can look at the query above and transform
the declarative speciﬁcation involving a quantiﬁer over an inﬁnite set into
a ﬁnite evaluable query such as {−√a, √a | a ∈S}.
To deal with these problems, we now have to give a formal deﬁnition
of the setting. Intuitively, we are dealing with ﬁnite relational structures
whose elements come from some interpreted domain with some interpreted
operations. Formally, the object of our study is the following:

5.2 Relational Databases and Embedded Finite Models
261
Deﬁnition 5.2.1. Let M = ⟨U, Ω⟩be an inﬁnite structure on a set U, where
the signature Ω contains some function, predicate, and constant symbols.
Let SC be a relational signature {R1, . . . , Rl} where each relation symbol Ri
has arity pi > 0. Then an embedded ﬁnite model (that is, an SC -structure
embedded into M) is a structure
D
=
⟨A, RD
1 , . . . , RD
l ⟩,
where each RD
i
is a ﬁnite subset of U pi, and A is the union of all elements
that occur in the relations RD
1 , . . . , RD
l . The set A is called the active domain
of D, and is denoted by adom(D).
The examples of structures M that will be used most often will be real and
natural numbers with various arithmetic operations, for example ⟨N, +, ·⟩,
the
real
ordered
ﬁeld
⟨R, +, ·, 0, 1, <, ⟩,
and
the
real
ordered
group
⟨R, +, −, 0, 1, <⟩.
The notation SC comes from the database name schema for the relational
vocabulary of a ﬁnite structure.
In the setting where we mix ﬁnite and inﬁnite structures, ﬁrst-order logic
(FO) must be deﬁned carefully. Note that we have two diﬀerent universes
that can be quantiﬁed over: the universe U of the inﬁnite structure M, and
the active domain A of the ﬁnite structure D.
Deﬁnition 5.2.2. Given a structure M = ⟨U, Ω⟩and a relational signature
SC, ﬁrst-order logic (FO) over M and SC , denoted by FO(SC , M), is deﬁned
as follows:
•
Any atomic FO formula in the language of M is an atomic FO(SC, M)
formula. For any p-ary symbol R from SC and terms t1, . . . , tp in the
language of M, R(t1, . . . , tp) is an atomic FO(SC , M) formula.
•
Formulae of FO(SC, M) are closed under the Boolean connectives (∨, ∧,
and ¬).
•
If ϕ is an FO(SC , M) formula, then
∃x ϕ,
∀x ϕ,
∃x∈adom ϕ,
and
∀x∈adom ϕ
are FO(SC , M) formulae.
The class of ﬁrst-order formulae in the language of M will be denoted by
FO(M) (that is, the formulae built up from atomic M-formulae by Boolean
connectives and quantiﬁcation ∃, ∀). The class of formulae not using the
symbols from Ω will be denoted by FO(SC ) (in this case all four quantiﬁers
are allowed).
The notions of free and bound variables are standard. For the semantics,
given a FO(SC, M) formula ϕ(x1, . . . , xn), and ⃗a = (a1, . . . , an) ∈U n, we
deﬁne the relation (M, D) |= ϕ(⃗a). When M is understood, we usually write
just D |= ϕ(⃗a). The notion of satisfaction is standard, with only the case of

262
5 Embedded Finite Models and Constraint Databases
quantiﬁcation requiring explanation. Let ϕ(x, ⃗y) be a formula, and let ⃗b be a
tuple of elements of U, of the same length as ⃗y. Then
(M, D) |= ∃x ϕ(x,⃗b)
⇔
(M, D) |= ϕ(a,⃗b) for some a ∈U
(M, D) |= ∀x ϕ(x,⃗b)
⇔
(M, D) |= ϕ(a,⃗b) for all a ∈U
(M, D) |= ∃x∈adom ϕ(x,⃗b)
⇔
(M, D) |= ϕ(a,⃗b) for some a ∈adom(D)
(M, D) |= ∀x∈adom ϕ(x,⃗b)
⇔
(M, D) |= ϕ(a,⃗b) for all a ∈adom(D).
The quantiﬁers ∃x ∈adom ϕ and ∀x ∈adom ϕ are called active-domain
quantiﬁers. Note that they are deﬁnable with the unrestricted quantiﬁers ∃
and ∀, as adom(D) is deﬁnable by an FO formula. However, we ﬁnd it more
convenient to have them explicitly in the syntax so that we can use both
restricted and unrestricted quantiﬁers in the same formula.
Deﬁnition 5.2.3. By FOact(SC, M), we denote the fragment of FO(SC, M)
that uses only quantiﬁers ∃x∈adom and ∀x∈adom. Formulae in this fragment
are called the active-domain semantics formulae.
Sometimes we shall also refer to the standard interpretation of the unre-
stricted quantiﬁers ∃and ∀as the natural semantics of ﬁrst-order formulae,
and to the class FO(SC, M) as the class of natural-semantics formulae.
Our goal is to study FO(SC , M). In particular, we shall show that the solu-
tions to the crucial problems of expressive power and query evaluation depend
heavily on the model-theoretic properties of M. In fact, we shall see the full
range of expressivity – from all computable properties to just FOact(SC )-
deﬁnable properties – for various structures M. Of course it is highly undesir-
able to have a query language that expresses all computable queries, since in
the database setting we want to keep the complexity low, and we want queries
to be optimizable. The latter situation is much more attractive, since essen-
tially one is dealing with the familiar relational calculus on ﬁnite databases.
5.3 Constraint Databases
The ﬁeld of constraint databases (CDB) was initiated in 1990, and since then
has become a well-established topic in the database ﬁeld. It grew out of the
research on Datalog and constraint logic programming (CLP). The original
motivation was to combine work in these two areas, with the goal of obtaining
a database-style, optimizable version of constraint logic programming. The
key idea was that the notion of a tuple in a relational database could be
replaced by a conjunction of constraints from an appropriate language (for
example, linear arithmetic constraints), and that many of the features of
the relational model could be extended in an appropriate way. In particular,
standard query languages such as those based on ﬁrst-order logic and Datalog
could be extended, at least in principle, to such a model.

5.3 Constraint Databases
263
The primary motivation for constraint databases comes from the ﬁeld of
spatial and spatio-temporal databases, and geographical information systems
(GIS). One wants to store an inﬁnite set – say, a region on the real plane – in
a database and query it as if all the points (inﬁnitely many) were stored. This
is clearly impossible. However, it is possible to store a ﬁnite representation of
an inﬁnite set, and to make this completely transparent to the user, who can
still access the data as though inﬁnitely many points were stored.
To illustrate how inﬁnite geometric objects can be represented with
various classes of constraints, we use the following examples.
Consider Fig. 5.1. This ﬁgure can be described, using polynomial
inequalities with integer coeﬃcients as follows:
(x2/25 + y2/16 = 1) ∨(x2 + 4x + y2 −2y ≤4)
∨(x2 −4x + y2 −2y ≤−4) ∨(x2 + y2 −2y = 8 ∧y < −1) .
The ﬁrst equality describes the outer ellipse of the ﬁgure, the second and third
disjuncts describe the “eyes”, and the last disjunct describes the “mouth”.
If we restrict ourselves to inequalities involving linear functions, the face
in Fig. 5.1 can no longer be deﬁned. It can, however, be approximated as
follows (Fig. 5.2):
(−5 ≤x ≤5 ∧y = −4) ∨(−5 ≤x ≤5 ∧y = 4)
∨(x = 5 ∧−4 ≤y ≤4) ∨(x = −5 ∧−4 ≤y ≤4)
∨(−3 ≤x ≤−1 ∧0 ≤y ≤2) ∨(1 ≤x ≤3 ∧0 ≤y ≤2)
∨(3y = −x −6 ∧−2 ≤y ≤−1) ∨(3y = x −6 ∧−2 ≤y ≤−1) .
The ﬁrst four disjuncts describe the outer rectangle. The next two disjuncts
describe the “eyes”, and the last two describe the “mouth”.
Fig. 5.1. An example of two-variable polynomial constraints
Fig. 5.2. An example of two-variable linear arithmetic constraints

264
5 Embedded Finite Models and Constraint Databases
What makes the sets depicted in Figs. 5.1 and 5.2 special is that they are
deﬁnable by FO formulae over some structures, in this case the real ﬁeld and
the real ordered group.
Deﬁnition 5.3.1. Given a structure M = ⟨U, Ω⟩, a set X ⊆U n is called
M-deﬁnable (or deﬁnable over M, or just deﬁnable if M is understood) if
there exists an FO formula ϕ(x1, . . . , xn) in the language of M such that
X
=
{(a1, . . . , an) ∈U n | M |= ϕ(a1, . . . , an)}.
We now consider two classes of deﬁnable sets that are especially relevant
in the context of constraint databases.
Deﬁnition 5.3.2. We use the abbreviations R for the real ﬁeld (that is,
⟨R, +, ·, 0, 1, <⟩) and Rlin for the real ordered group (⟨R, +, −, 0, 1, <⟩). Sets
deﬁnable over R are called semialgebraic and sets deﬁnable over Rlin are
called semilinear.
A remarkable property of both Rlin and R is that they admit quantiﬁer
elimination; that is, every formula is equivalent to a quantiﬁer-free one. For
Rlin this is a simple consequence of Fourier-Motzkin elimination; for R, this
is a celebrated result of Tarski.
Thus, every semialgebraic set in Rn is a Boolean combination of sets
given by polynomial equalities and inequalities of the form
p(x1, . . . , xn) {=, >, <} 0,
where p is a polynomial (with rational or integer coeﬃcients). Similarly, a
semilinear set in Rn is a Boolean combination of sets given by linear equalities
and inequalities of the form
a1 · x1 + . . . + an · xn {=, >, <} b,
where the ais and b are rational or integer coeﬃcients. That is, a semilinear
set is a Boolean combination of half-spaces and hyperplanes in Rn.
The set shown in Fig. 5.1 is semialgebraic, and the set shown in Fig. 5.2
is semilinear. In general, the majority of geographical applications represent
regions by linear constraints; that is, regions are semilinear sets. If linear
constraints are not suﬃcient, one can use polynomial constraints instead.
We are now ready to present a mathematical model of constraint
databases.
Deﬁnition 5.3.3. Let M = ⟨U, Ω⟩be an inﬁnite structure on a set U, and
let SC be a relational signature {R1, . . . , Rl}, where each relation Ri has
arity pi > 0. Then a constraint database of schema SC is a tuple
D
=
⟨RD
1 , . . . , RD
l ⟩,
where each RD
i
is a deﬁnable subset of U pi. The superscript D is omitted if
it is clear from the context.

5.3 Constraint Databases
265
Thus, the only diﬀerence between the deﬁnition of a constraint database
and an embedded ﬁnite model is that in the former we interpret the SC-
predicates by deﬁnable sets, and in the latter we interpret them by ﬁnite sets.
The deﬁnition of FO(SC, M) is the same for constraint databases as
it is for embedded ﬁnite models, except that we do not use the restricted
quantiﬁcation ∃x∈adom and ∀x∈adom. The quantiﬁers are thus interpreted
as ranging over the entire inﬁnite set U. As linear and polynomial constraints
play a special role in the theory of constraint databases, we introduce a
special notation for them.
Deﬁnition 5.3.4. If M is the real ﬁeld, we write FO + Poly(SC ) for
FO(SC, R), or just FO + Poly if SC is clear from the context. If M is the real
ordered group, we write FO + Lin(SC ) (or just FO + Lin) for FO(SC , Rlin).
The notation FO + Poly stands for FO with polynomial constraints,
and FO + Lin stands for for FO with linear constraints. An example of
deﬁnability in FO + Poly is the property that all points in a relation S lie
on a common circle: ∃a∃b∃r (∀x∀y S(x, y) →(x −a)2 + (y −b)2 = r2). In
general, FO + Poly can deﬁne many useful topological concepts, such as
closure, interior, and boundary. These are deﬁnable in FO + Lin as well. For
example, the FO + Lin query α(x, y),
∀ε > 0∃x′∃y′
S(x′, y′) ∧(x −ε < x′ < x + ε) ∧(y −ε < y′ < y + ε)

tests whether the pair (x, y) is in the closure of a set S ⊆R2.
In FO + Poly one can also deﬁne the convex hull of a set. To see how
this is done in the two-dimensional case, assume that a semialgebraic set
S ∈R2 is given. Then ϕ(x, y) given by the formula
∃x1, y1, x2, y2, x3, y3 ∃λ1, λ2, λ3
⎛
⎜
⎜
⎜
⎜
⎝
S(x1, y1) ∧S(x2, y2) ∧S(x3, y3)
∧λ1 ≥0 ∧λ2 ≥0 ∧λ3 ≥0
∧λ1 + λ2 + λ3 = 1
∧(x = λ1 · x1 + λ2 · x2 + λ3 · x3)
∧(y = λ1 · y1 + λ2 · y2 + λ3 · y3)
⎞
⎟
⎟
⎟
⎟
⎠
is true on (x, y) iﬀ(x, y) ∈conv(S). In general, to deﬁne the convex hull of a
set S in Rn, one uses Carath´eodory’s Theorem which states that ⃗x is in the
convex hull of S ⊆Rn iﬀ⃗x is in the convex hull of some n + 1 points in S,
and one codes this by an FO formula just as we did above for the case of R2.
We note again that these examples demonstrate the crucial property of
constraint databases: query languages based on FO view the database as if
it were inﬁnitely many tuples stored in memory. We refer to the database
relations in exactly the same way as we do for the usual relational databases.
Now that we have deﬁned constraint databases and have seen some
examples of querying, we consider the same issues that we addressed in the
context of embedded ﬁnite models: expressive power and query evaluation.

266
5 Embedded Finite Models and Constraint Databases
Expressive power. We have seen that FO + Poly is a rather expressive
language for talking about properties of semialgebraic sets, and that
many topological properties of semilinear sets can already be expressed in
the weaker language FO + Lin. We next turn to a very basic topological
property: connectivity. Suppose we are given a semialgebraic or semilinear
set S, and we want to test whether it is topologically connected. Can we
do this in FO + Poly or FO + Lin?
At ﬁrst, it seems that the answer is “no”. Indeed, it appears that topo-
logical connectivity is rather close to graph connectivity. Take an undi-
rected graph G and embed it in R3 without self-intersections. The embed-
ding is then topologically connected iﬀG is a connected graph. However,
we know only that FO cannot express graph connectivity; there is nothing
yet that tells us that similar bounds exist for FO + Lin and FO + Poly.
Query Evaluation. Suppose we are given an FO(SC, M) query ϕ(⃗x) and a
constraint database D over M. How does one evaluate ϕ on D? The answer
to this is very simple – one just puts the deﬁnition of relations in D into
ϕ. For example, if ϕ(x) ≡∃y (S(x, y) ∧(p1(x, y) > 0)) and S is given by
p2(x, y) < 0, where p1, p2 are polynomials, then by putting the deﬁnition of
S into ϕ we obtain a new formula ϕD(x) ≡∃y ((p2(x, y) < 0)∧(p1(x, y) >
0)). As this is an FO formula, it gives us a constraint database.
This may look a little bit like cheating, and of course it is. For example,
how does one check that D |= ϕ(1)? To do so, one must be able to
check whether ϕD(1) is true in R; in general, one must be able to check
whether ϕD(⃗a) is true in a given structure M, where ϕD is the result of
substituting deﬁnitions of relations in SC in the query ϕ. This can only
be done if the FO theory of the underlying structure M is decidable. This
property certainly holds for Rlin and R (in fact, they satisfy a much
stronger property of having quantiﬁer elimination); however, for many
structures, this property does not hold (for example, ⟨N, +, ·⟩).
We shall see in the remainder of this chapter that the correspondence
between the problems of topological connectivity of constraint databases and
graph connectivity in the embedded setting is not an accident: in fact, the
majority of expressivity bounds for constraint databases are obtained by
rather simple reductions to embedded ﬁnite models.
5.4 Collapse and Genericity: An Overview
The next ﬁve sections will deal primarily with the setting of embedded ﬁnite
models. In this short section, we give an overview of the main results.
Many results on expressive power use the notion of genericity, which
comes from the classical relational database setting. Informally, this notion
is sometimes stated as a data independence principle: when one evaluates
queries on relational databases, the exact values of elements stored in the

5.4 Collapse and Genericity: An Overview
267
database are not important. For example, the answer to the query “Does
the graph have diameter 2?” is the same for the graph {(1, 2), (1, 3), (1, 4)}
and the graph {(a, b), (a, c), (a, d)}, which is obtained by the mapping
1 →a, 2 →b, 3 →c, 4 →d.
In general, generic queries commute with permutations of the domain.
Queries expressible in FO(SC , M) need not be generic: for example, the
query given by ∃x S(x) ∧x > 1 is true on S = {2} but false on S = {0}.
However, as all queries deﬁnable in standard relational languages – relational
calculus, Datalog, etc. – are generic, to reduce questions about FO(SC , M) to
questions in ordinary ﬁnite-model theory, it suﬃces to restrict one’s attention
to generic queries.
We now deﬁne genericity of Boolean queries (which are just classes of
SC-structures) and non-Boolean queries (which map a ﬁnite SC-structure to
a ﬁnite subset of U m, m > 0). We also deﬁne genericity in the ordered and
unordered settings. The reason for considering the ordered setting separately
is twofold: ﬁrst, most structures of interest in applications are ordered, and
second, in several proofs we need to introduce the order relation to obtain
the desired results.
Given a function π : U →U, we extend it to ﬁnite SC -structures D by
replacing each occurrence of a ∈adom(D) with π(a).
Deﬁnition 5.4.1. •
A Boolean query Q is totally generic (or order-generic)
if for every partial injective function (or partial monotone injective func-
tion, respectively) π deﬁned on adom(D), we have Q(D) = Q(π(D)).
•
A non-Boolean query Q is totally generic (or order-generic) if for
every partial injective function (or partial monotone injective func-
tion, respectively) π
deﬁned on adom(D) ∪adom(Q(D)), we have
π(Q(D)) = Q(π(D)).
Order-genericity of course assumes that U is linearly ordered. Clearly, total
genericity is stronger than order-genericity. Some examples of totally generic
queries are all queries deﬁnable in relational algebra, Datalog, the While lan-
guage, and in fact in almost every language studied in relational database the-
ory. As a concrete example, consider the parity query. Since for any injective
π : U →U it is the case that card(X) = card(π(X)), parity is totally generic.
Examples of order-generic queries include queries deﬁnable in relational
calculus and Datalog with order (that is, order comparisons are allowed in
selection predicates and Datalog rules).
5.4.1 Approaches to Proving Expressivity Bounds
How can one prove bounds on FO(SC, M)? Probably by reducing the problem
to something we know about. And we know a lot about FO over ﬁnite struc-
tures, ordered or unordered. In our terms, this is either FOact(SC , ⟨U, ∅⟩),
which we denote by FOact(SC ) (that is, there are no operations on U, and

268
5 Embedded Finite Models and Constraint Databases
everything is restricted to the active domain), or FOact(SC , ⟨U, <⟩), which will
be denoted by FOact(SC, <) (that is, the only predicate on U is the order <).
To reduce the expressivity of FO(SC , M) to FOact(SC , <) or FOact(SC),
we have to deal with two problems: unrestricted quantiﬁcation over U, and
the presence of M-deﬁnable constraints in formulae. Fig. 5.3 illustrates
possible approaches to the problem.
We need to go from the upper right corner to the lower left corner. One
possibility is to move left ﬁrst, and then down. To move left, we must prove
that for a given M, FO(SC, M) and FOact(SC , M) have the same power.
That is, all unrestricted quantiﬁcation can be eliminated. This will be called
natural-active collapse. To move down, we would have liked to prove that
FOact(SC , M) = FOact(SC, <), but this is impossible for the following reason.
Lemma 5.4.2. FOact(SC , <) deﬁnes only order-generic queries.
On the other hand, queries deﬁnable in FOact(SC, M) need not be generic.
Thus, we attempt to prove the next best thing: that all generic queries in
FOact(SC , M) and FOact(SC, <) are the same. This is called active generic
collapse.
Another possibility is to go down ﬁrst from the right upper corner. For
the same reasons as before, we have to restrict ourselves to generic queries,
and attempt to prove that any generic query in FO(SC, M) is deﬁnable in
FO(SC, <). This is called natural-generic collapse. Then, to go left, we have
to prove the natural-active collapse over a very simple structure ⟨U, <⟩.
Let us now summarize the deﬁnitions of that collapse results that we shall
be proving here.
Deﬁnition 5.4.3. We say that a structure M admits:
•
natural-active collapse if FO(SC, M) = FOact(SC , M) for every SC;
•
active-generic collapse if, for every SC, the classes of order-generic
queries in FOact(SC, M) and FOact(SC, <) are the same (assuming M is
ordered);
FOact(SC, M) =============
natural-active
collapse
FO(SC, M)
FOact(SC, <)
active
generic
collapse
(((((((((
============== FO(SC, <)
natural
generic
collapse
(((((((((
Fig. 5.3. Approaches to proving bounds for FO(SC, M)

5.5 Active-Generic Collapse
269
•
natural-generic collapse if, for every SC, the classes of order-generic
queries in FO(SC , M) and FO(SC, <) are the same (assuming M is
ordered).
We shall also consider collapse results for totally generic queries, but
they will of lesser importance. The next two sections deal with collapse
results: Sect. 5.5 discusses active generic collapse, and Sect. 5.6 discusses
natural-active collapse and natural-generic collapse.
5.5 Active-Generic Collapse
Our goal is to prove active-generic collapse over any ordered structure. We
do this by proving a Ramsey property, deﬁned below, and then showing that
it implies this collapse.
We start with a simple example that illustrates the main idea of the
proof. Suppose we have a sentence Φ of FO + Poly:
∀x∈adom ∀y∈adom S(x, y) →(¬(x = y2) ∧¬(y = x2)).
In general, given a sentence, one cannot decide whether it deﬁnes a generic
query. So assume for the moment that the given sentence happens to express
a generic query. How does one show then that this query is deﬁnable in FO
without polynomial constraints (for example, how does one prove that this
query is not parity)? Clearly, one needs a systematic way of ﬁnding counterex-
amples for each non-FO query. This is provided by the following observation.
Let X = {33i | i > 0} ⊂N. Then, for any x, y ∈X, we have x ̸= y2, because
3j = 2 · 3i does not hold for any i, j > 0. Thus, if adom(S) ⊂X, then
S |= Φ. Now, assume that Φ expresses a generic query Q. Given any ﬁnite
relation S, we can ﬁnd a monotone embedding π of its active domain into
X. Thus, Q(S) = Q(π(S)) by genericity, and we know that Q(π(S)) is true.
Hence, Q(S) is true for all S, and thus Φ cannot express a non-ﬁrst-order
generic query.
This is the basic idea behind the proof of active-generic collapse: we ﬁrst
show that for each formula, its behavior on some inﬁnite set is described by
a ﬁrst-order formula. This is called the Ramsey property. We then show how
genericity and the Ramsey property imply the collapse.
5.5.1 The Ramsey Property
Deﬁnition 5.5.1. Let M = ⟨U, Ω⟩be an ordered structure. We say that an
FOact(SC , M) formula ϕ(⃗x) has the Ramsey property if the following is true:
Let X be an inﬁnite subset of U. Then there exists an inﬁnite set
Y ⊆X and an FOact(SC , <) formula ψ(⃗x) such that for any instance

270
5 Embedded Finite Models and Constraint Databases
D of SC with adom(D) ⊂Y , and for any ⃗a over Y , it is the case
that D |= ϕ(⃗a) ↔ψ(⃗a).
We speak of the total Ramsey property if ψ is an FOact formula in the
language of SC (note the absence of order).
In the rest of this section, we prove the Ramsey property. We ﬁx an
ordered structure M = ⟨U, Ω⟩and a schema SC. The following simple lemma
will often be used as a ﬁrst step in proofs of collapse results. Before stating
it, note that for any FO(SC, M), subformulae (x = y) can be viewed as both
atomic FO(SC) and atomic FO(M) formulae. For the rest of the chapter,
we choose to view them as atomic FO(M) formulae; that is, atomic FO(SC)
formulae are only those of the form R(· · · ) for R ∈SC.
Lemma 5.5.2. Let ϕ(⃗x) be an FO(SC, M) formula. Then there exists an
equivalent formula ψ(⃗x) such that every atomic subformula of ψ is either an
FO(SC) formula or an FO(M) formula. Furthermore, it can be assumed that
none of the variables ⃗x occurs in an FO(SC) atomic subformula of ψ(⃗x). If
ϕ is an FOact(SC , M) formula, then ψ is also an FOact(SC, M) formula.
Proof. Introduce m fresh variables z1, . . . , zm, where m is the maxi-
mal arity of a relation in SC, and replace any atomic formula of the
form R(t1(⃗y), . . . , tl(⃗y)), where l
≤
m and the tis are M-terms, by
∃z1 ∈adom . . . ∃zl ∈adom 
i(zi = ti(⃗y)) ∧R(z1, . . . , zl). Similarly, use exis-
tential quantiﬁers to eliminate ⃗x-variables from FO(SC) atomic formulae. 2
The key in the inductive proof of the Ramsey property is the case of
FO(M) subformulae. For this, we ﬁrst recall the inﬁnite version of Ramsey’s
Theorem, in the form most convenient for our purposes.
Theorem 5.5.3 (Ramsey). Given an inﬁnite ordered set X, and any
partition of the set of all ordered m-tuples x1 < . . . < xm of elements of X
into l classes A1, . . . , Al, there exists an inﬁnite subset Y ⊆X such that all
ordered m-tuples of elements of Y belong to the same class Ai.
Lemma 5.5.4. Let ϕ(⃗x) be an FO(M) formula. Then ϕ has the Ramsey
property.
Proof. Consider a (ﬁnite) enumeration of all the ways in which the variables ⃗x
may appear in the order of U. For example, if ⃗x = (x1, . . . , x4), one possibility
is x1 = x3, x2 = x4, and x1 < x2. Let P be such an arrangement, and ζ(P)
a ﬁrst-order formula that deﬁnes it (x1 = x3 ∧x2 = x4 ∧x1 < x3 in the
above example). Note that there are ﬁnitely many such arrangements P; let
P be the set of all of these. Each P induces an equivalence relation on ⃗x,
for example {(x1, x3), (x2, x4)} for the P above. Let ⃗xP be a subtuple of ⃗x
containing a representative of each class (e.g. (x1, x4)), and let ϕP (⃗xP ) be
obtained from ϕ by replacing all variables from an equivalence class by the
chosen representative. Then ϕ(x) is equivalent to

5.5 Active-Generic Collapse
271

P ∈P
ζ(P) ∧ϕP (⃗xP ) .
Let P′ ⊆P and P0 ∈P′. Let X ⊆U be an inﬁnite set. Assume that ψ(⃗x) is
given by

P ∈P′
ζ(P) ∧ϕP (⃗xP ).
We shall now show that there exists an inﬁnite set Y ⊆X and a quantiﬁer-free
FO(<) formula γP0(⃗x) such that ψ is equivalent to
γP0(⃗x) ∨

P ∈P′−{P0}
ζ(P) ∧ϕP (⃗xP )
for tuples ⃗x of elements of Y .
To see this, suppose that P0 has m equivalence classes. Consider a
partition of tuples of Xm, ordered according to P0, into two classes: A1, the
class of those tuples for which ϕP0(⃗xP0) is true, and A2, the class of those
for which ϕP0(⃗xP0) is false. By Ramsey’s Theorem, for some inﬁnite set
Y ⊆X, either all ordered tuples over Y m are in A1 or all are in A2. In the
ﬁrst case, ψ is equivalent to ζ(P0) ∨
P ∈P′−{P0} ζ(P) ∧ϕP (⃗xP ), and in the
second case ψ is equivalent to ¬ζ(P0) ∨
P ∈P′−{P0} ζ(P) ∧ϕP (⃗xP ), proving
the claim.
The lemma now follows by applying this claim inductively to every
partition P ∈P, passing to smaller inﬁnite sets, while getting rid of all
the formulae containing symbols other than = and <. At the end, we
have an inﬁnite set over which ϕ is equivalent to a quantiﬁer-free FO(<)
formula.
2
Now a simple inductive argument proves the following.
Proposition 5.5.5. Let
M
be
any
ordered
structure.
Then
every
FOact(SC , M) formula has the Ramsey property.
Proof. By Lemma 5.5.2, we assume that every atomic subformula is an
FOact(SC ) formula or an FO(M) formula. The base cases for the induction are
those of FOact(SC ) formulae, where there is no need to change the formula or
ﬁnd a subset, and of FO(M) atomic formulae, which is given by Lemma 5.5.4.
Let ϕ(⃗x) = ϕ1(⃗x) ∧ϕ2(⃗x), and let X ⊆U be inﬁnite. First, ﬁnd ψ1,
Y1 ⊆X such that for any D and ⃗a over Y1, D |= ϕ1(⃗a) ↔ψ1(⃗a). Next, by
using the hypothesis for ϕ2 and Y1, ﬁnd an inﬁnite Y2 ⊆Y1 such that for any
D and ⃗a over Y2, D |= ϕ2(⃗a) ↔ψ2(⃗a). Then take ψ = ψ1 ∧ψ2 and Y = Y2.
The case of ϕ = ¬ϕ′ is trivial.
For the existential case, let ϕ(⃗x) = ∃y∈adom ϕ1(y, ⃗x). By the hypothesis,
we ﬁnd Y ⊆X and ψ1(y, ⃗x) such that, for any D and ⃗a over Y and any b ∈Y
we have D |= ϕ1(b,⃗a) ↔ψ1(b,⃗a). Let ψ(⃗x) = ∃y ∈adom.ψ1(y, ⃗x). Then,
for any D and ⃗a over Y , D |= ψ(⃗a) iﬀD |= ψ1(b,⃗a) for some b ∈adom(D)
iﬀD |= ϕ1(b,⃗a) for some b ∈adom(D) iﬀD |= ϕ1(⃗a), thus ﬁnishing the
proof.
2

272
5 Embedded Finite Models and Constraint Databases
It is clear from the proof of Proposition 5.5.5 that only the case of atomic
FO(M) formulae requires the introduction of the order relation. Thus, if
atomic FO(M) formulae had the total Ramsey property over M, so would all
FOact(SC , M) formulae. In general, this cannot be guaranteed for arbitrary
M (consider, for example, ⟨U, <⟩). However, there is an important class of
structures on the reals for which this statement can be shown.
We say that M = ⟨R, Ω⟩is analytic if Ω consists of real analytic functions.
For example, ⟨R, +, ·⟩is analytic.
Lemma 5.5.6. Let F = {fi(⃗x)}i∈I be a countable family of real analytic
functions, where ⃗x = (x1, . . . , xl). Assume that none of the functions in F
is identically zero. Let X ⊆R be a set of cardinality of the continuum. Then
there is a set Y ⊆X of cardinality of the continuum such that, for any tuple
⃗c of l distinct elements of Y , none of fi(⃗c), where i ∈I, equals zero.
The proof of this result, which we omit here, is a Zorn’s lemma argument
based on the fact that a nonzero real analytic function can have at most
countably many zeros.
Proposition 5.5.7. Let M = ⟨R, Ω⟩be analytic. Then every FOact(SC, M)
formula has the total Ramsey property.
Proof sketch. We only need to modify the proof of Lemma 5.5.4, to show
the total Ramsey property of atomic FO(M) formulae. This can be done by
using Lemma 5.5.6 in place of Ramsey’s Theorem.
2
5.5.2 Collapse Results
We now show how the Ramsey property implies active-generic collapse.
Recall (see Sect. 5.4) that an m-ary query, m > 0, is a mapping from ﬁnite
SC-structures on U to ﬁnite subsets of U m. We start with the following
observation.
Lemma 5.5.8. If Q is an order-generic query on SC-structures over an
inﬁnite set U, then adom(Q(D)) ⊆adom(D) for every SC-structure D.
Proof. First note that for any ﬁnite subsets Y ⊂X of an inﬁnite ordered set
U, any x ∈X −Y , and any number n > 0, we can ﬁnd monotone injective
maps π1, . . . , πn deﬁned on X such that for all i, j, πi(Y ) = πj(Y ), but all
π1(x), . . . , πn(x) are distinct. This is true because U has either an inﬁnitely
descending or an inﬁnitely ascending chain; in each case it is easy to construct
the πis.
Now suppose that Z = adom(Q(D)) −adom(D) is nonempty for an
order-generic query Q. Let X = adom(Q(D)) ∪adom(D), Y = adom(D),
and n = card(Z) + 1. Construct π1, . . . , πn as above. Now, for every
i, j, we have πi(Q(D))
= Q(πi(D)) = Q(πj(D)) = πj(Q(D)); hence
π1(Z) = . . . = πn(Z). In particular, for every x ∈Z, πi(x) ∈π1(Z), whence
card(π1(Z)) = card(Z) ≥n. This contradiction proves the lemma.
2

5.6 Natural-Active Collapse
273
Lemma 5.5.9. Assume that every FOact(SC, M) formula has the Ramsey
property. Then M admits active-generic collapse.
Proof. Let Q be an order-generic query deﬁnable in FOact(SC, M). By the
Ramsey property, we can ﬁnd an inﬁnite X ⊆U and an FOact(SC, <)-
deﬁnable Q′ that coincides with Q on X. We claim that they coincide
everywhere. Let D be an SC-structure. Since X is inﬁnite, there exists
a partial monotone injective map π from adom(D) into X. Since Q′ is
FOact(SC , <)-deﬁnable, it is order-generic, and thus Q and Q′ do not extend
active domains. Hence, π(Q(D)) = Q(π(D)) = Q′(π(D)) = π(Q′(D)), from
which Q(D) = Q′(D) follows.
2
We now put Proposition 5.5.5 and Lemma 5.5.9 together:
Theorem 5.5.10. Every ordered structure admits active-generic collapse.
Thus, no matter what functions and predicates there are in M, ﬁrst-order
logic cannot express more generic active-semantics queries over it than just
FOact(SC , <). In particular, we have the following.
Corollary 5.5.11. Let M be an arbitrary structure. Then queries such
as parity, majority, connectivity, transitive closure, and acyclicity are not
deﬁnable in FOact(SC, M).
Proof. Assume otherwise, and extend M to M< by adding the symbol <,
to be interpreted as a linear order. Then FOact(SC , M<) deﬁnes one of the
above queries, for an appropriate SC. Since all the queries listed above are
order-generic, we obtain from Theorem 5.5.10 that FOact(SC , <) deﬁnes
them, which is not the case.
2
We conclude by showing a stronger collapse result over analytic structures.
Corollary 5.5.12. If M = ⟨R, Ω⟩is analytic, then any totally generic query
deﬁnable in FOact(SC, M) is deﬁnable in FOact(SC).
This is indeed a stronger version of collapse, as there exist totally generic
queries in FOact(SC , <)−FOact(SC) (even for very simple vocabularies SC).
5.6 Natural-Active Collapse
So far, we have dealt with formulae that use only the restricted quantiﬁcation
∀x∈adom and ∃x∈adom. We next move to unrestricted quantiﬁcation, where
quantiﬁers are allowed to range over the inﬁnite universe of a structure M. Our
ultimate goal is to prove natural-active collapse: FO(SC , M) = FOact(SC, M).
We start by showing that there is a reason to believe that this may hold
for some structures M, although not for all of them. We then review some
notions from model theory that help us distinguish good structures (for which

274
5 Embedded Finite Models and Constraint Databases
the collapse holds) from bad ones (for which it does not). After that, we give
a gentle introduction to the main ideas of the proof of the natural-active
collapse, considering a simple case of linear constraints (that is, FO + Lin)
and one unrestricted existential quantiﬁer to be eliminated. After that, we
present a general proof and an algorithm, and revisit the collapse for generic
queries.
5.6.1 Collapse: Failure and Success
We have seen that the active-generic collapse holds for every ordered structure
Does this extend to the natural-active collapse? To give a negative answer,
consider the structure N = ⟨N, +, ·⟩. (We may include an order relation < as
well, but it is deﬁnable: x < y iﬀ¬(x = y) ∧∃z (y = x + z).) Let SC consist
of a single unary predicate S. From the active generic collapse, we know
that parity is not deﬁnable in FOact(SC, N). However, we have the following
proposition.
Proposition 5.6.1. Parity is deﬁnable in FO(SC , N). Consequently, N does
not admit natural-active collapse.
Proof. Let p1, p2, . . . enumerate the prime numbers. Consider three predicates
on N: P0(x) holds iﬀx is prime, P1(x, y) holds iﬀy equals px, and P2(x)
holds iﬀx is the product of an even number of distinct primes. Note that
P0, P1, and P2 are recursive, and thus deﬁnable over N. The way to express
parity is then the following: given a set S = {x1, . . . , xn} with x1 < . . . < xn,
we code it as cS = px1 · . . . · pxn. Suppose we have a formula ϕ(c) which holds
iﬀc = cS. Then parity is expressed as
¬∃xS(x) ∨∃c (ϕ(c) ∧P2(c)).
Thus, it remains to show how to express ϕ. It can be deﬁned by the following
formula:
∀p P0(p) →

(∃y(c = p · y)) →¬∃y(c = p · p · y)
∧(∃y(c = p · y)) ↔∃x (S(x) ∧P1(x, p))

.
This says that for every prime p that divides c, c is not divisible by p2, and
p is of the form px for some x ∈S, which forces c to be cS. This completes
the proof.
2
One may observe that there is nothing speciﬁc to parity in the proof
above. In particular, the coding scheme can be easily extended to ﬁnite
SC-structures for any SC, and the fact that every recursive predicate on N
is deﬁnable in N allows us to state the following proposition.
Proposition 5.6.2. For
any
SC,
every
computable
property
of
ﬁnite
SC-structures is deﬁnable in FO(SC, N).
2

5.6 Natural-Active Collapse
275
In fact, FO(SC, N) can even express properties that are not computable.
Thus, we have witnessed a rather dramatic failure of natural-active
collapse. Is there then something that gives us hope of recovering it for some
structures? Let us ﬁrst look at the simplest possible M: ⟨U, ∅⟩. It turns out
that in this case the collapse can be proven rather easily.
Theorem 5.6.3. For every schema, FO(SC ) = FOact(SC).
Proof. We consider the case of nonempty ﬁnite structures. If an FOact(SC)
formula ψ(⃗x) equivalent to an FO(SC) formula ϕ(⃗x) is found in this case,
then for arbitrary ﬁnite SC-structures, a formula equivalent to ϕ is given
by (∃x ∈adom(x = x) ∧ψ(⃗x)) ∨(¬∃x ∈adom(x = x) ∧ϕ∅(⃗x)), where ϕ∅(⃗x)
is a quantiﬁer-free formula equivalent to the formula obtained from ϕ by
replacing each occurrence of a predicate from SC by false.
Now the proof is by induction on the structure of the formula. The cases
of atomic formulae and Boolean connectives are obvious. For the existential
case, we deﬁne a transformation [γ]x that eliminates all free occurrences of
the variable x from quantiﬁer-free formulae:
•
If γ is (x = x), then [γ]x = true.
•
If γ is (x = y) or R(. . . , x, . . .), then [γ]x = false.
•
If γ is any other atomic formula, then [γ]x = γ.
•
If γ = γ1 ∨γ2, then [γ]x = [γ1]x ∨[γ2]x.
•
If γ = ¬γ′, then [γ]x = ¬[γ′]x.
Let ϕ(⃗z) = ∃xα(x,⃗z) where z = (z1, . . . , zn). By the hypothesis, α
is equivalent to an FOact(SC) formula α′(x,⃗z). Assume, without loss of
generality, that α′ is of the form Qy1 ∈adom . . . Qym ∈adom β(x, ⃗y,⃗z), where
β is quantiﬁer-free.
Deﬁne ϕ0(⃗z) ≡∃x ∈adom α′(x,⃗z), ϕi(⃗z) ≡α′(zi,⃗z) and ϕ∞(⃗z) ≡
Qy1 ∈adom . . . Qym∈adom [β(x, ⃗y,⃗z)]x. Let
ϕ′(⃗z) ≡ϕ0 ∨(
n

i=1
ϕi) ∨ϕ∞.
We now show that D |= ϕ(⃗a) ↔ϕ′(⃗a) for every nonempty D and every
⃗a ∈Un. First, note that for every ⃗b ∈adom(D)m, the following three state-
ments are equivalent: (i) D |= [β(x,⃗b,⃗a)]x; (ii) for some c ̸∈adom(D) and
not in ⃗a, D |= β(c,⃗b,⃗a); (iii) for all c ̸∈adom(D) and not in ⃗a, D |= β(c,⃗b,⃗a).
Indeed, these equivalences hold for atomic formulae, and they are preserved
under Boolean connectives.
Since all quantiﬁed variables yi range over the active domain, we then
obtain that D |= ϕ∞(⃗a) iﬀfor some c ̸∈adom(D) and not in ⃗a, D |= α′(c,⃗a).
This implies the required equivalence D |= ϕ(⃗a) ↔ϕ′(⃗a).
2
Thus, natural-active collapse is a meaningful concept: there are structures
that admit it. On the other hand, we know that there are restrictions on
structures that admit this collapse. We next discuss such restrictions.

276
5 Embedded Finite Models and Constraint Databases
5.6.2 Good Structures vs. Bad Structures: O-minimality
We start with a minimal requirement a structure M must satisfy to admit
natural-active collapse. Suppose we have an FO(M) formula, that is, a
formula that does not use symbols from SC. What does it mean for it to be
equivalent to an FOact(SC, M) formula? In the absence of a ﬁnite structure,
this means being equivalent to a quantiﬁer-free FO(M) formula. Thus, to
admit the collapse, a structure M must admit quantiﬁer elimination: that is,
for every formula ϕ(⃗x) of FO(M), there is a quantiﬁer-free FO(M) formula
ψ(⃗x) such that M |= ∀⃗x ψ(⃗x) ↔ϕ(⃗x).
Classical model theory provides us with many examples of such structures;
some of them have been mentioned already in the introduction, and a few
are listed below:
•
⟨U, <⟩, where < is a dense order without endpoints on U.
•
⟨R, +, −, 0, 1, <⟩– this is a consequence of Fourier elimination.
•
⟨R, +, ·, 0, 1, <⟩– this is, of course, Tarski’s classical result on quantiﬁer
elimination for real closed ﬁelds.
•
⟨N, +, <, 0, 1, (≡k)k>0⟩, where x ≡k y iﬀx = y(modk) – this is Presburger
arithmetic.
However, quantiﬁer elimination alone is not suﬃcient to guarantee the
collapse. Indeed, any structure M admits a deﬁnitional expansion to some
M′ that has quantiﬁer elimination (simply by adding new symbols for all
deﬁnable predicates). Thus, if we take such an expansion N′ of N = ⟨N, +, ·⟩,
we still have that all computable properties of ﬁnite SC-structures are
deﬁnable in FO(SC, N′), but FOact(SC, N′) cannot deﬁne parity.
To impose additional restrictions, we consider the model-theoretic notion
of o-minimality. An ordered structure M = ⟨U, Ω⟩is o-minimal if every
deﬁnable set is a ﬁnite union of points and open intervals. Here, deﬁnable
sets are those of the form {x ∈U | M |= ϕ(x)}, where ϕ is a ﬁrst-order
formula in the language of Ω and constants for elements of U.
An interval is given by its endpoints, a and b, and it is either an open
interval (a, b) = {c | a < c < b}, a closed interval [a, b] = {c | a ≤c ≤b}, or
one of the half-open half-closed versions [a, b) or (a, b]; by considering +∞and
−∞as endpoints, we also have unbounded versions of the above: {c | c < b},
{c | c ≤b}, {c | c > a}, and {c | c ≥a}. Also, an equivalent deﬁnition of
o-minimality is that every deﬁnable set is a ﬁnite union of intervals.
Let us list some important examples of o-minimal structures.
•
⟨Q, <, (q)q∈Q⟩is o-minimal. Indeed, every ﬁrst-order formula ϕ(x) is
equivalent to a quantiﬁer-free one, which is then a Boolean combination
of ﬁnitely many formulae of the form x = q or x < q. Let q1 < . . . < qk be
the ﬁnite set of all constants that occur in such formulae. Consider then
the intervals (−∞, q1), {q1}, (q1, q2), {q2}, . . . , {qk}, (qk, ∞). It is clear
that the set deﬁned by ϕ is a union of some of those.

5.6 Natural-Active Collapse
277
•
A more complex example is that of the real ﬁeld, ⟨R, +, ·, 0, 1, <⟩. Consider
a formula ϕ(x). Since the real ﬁeld has quantiﬁer elimination, ϕ(x) is equiv-
alent to a Boolean combination of formulae of the form p(x) > 0, where p is
a polynomial with real coeﬃcients. Consider all such polynomials which are
not identically zero, and let q1 < . . . < qk be the ﬁnite set of all the roots of
these polynomials (each can have only ﬁnitely many). We thus again obtain
the result that the set deﬁned by ϕ(x) is a union of some intervals among
(−∞, q1), {q1}, (q1, q2), {q2}, . . . , {qk}, (qk, ∞), as no polynomial used in
the representation of ϕ(x) can change sign on such an interval.
•
The same quantiﬁer elimination argument shows that the real ordered
group ⟨R, +, −, 0, 1, <⟩is o-minimal.
•
There are other interesting examples of o-minimal structures, where
proving o-minimality is very hard. The most notable one is that of the
exponential ﬁeld, ⟨R, +, ·, ex⟩. Others include the expansion of the real
ﬁeld with the Gamma-function or with restricted analytic functions.
We shall present more properties of o-minimal structures before proving
natural-active collapse in Section 5.6.5.
5.6.3 Collapse Theorem and Corollaries
Our goal now is to show the following.
Theorem 5.6.4 (Natural-Active Collapse). Let M
=
⟨U, Ω⟩be an
o-minimal structure that admits quantiﬁer elimination. Then it admits
natural-active collapse.
Furthermore, if the theory of M is decidable and the quantiﬁer elimination
procedure is eﬀective, then there is an algorithm that, for every FO(SC, M)
formula, constructs an equivalent FOact(SC, M) formula.
2
The proof of this theorem will be presented in Section 5.6.5, after we
present the main ideas in the simpler case of linear constraints, that is, where
M is ⟨R, +, −, 0, 1, <⟩.
We ﬁrst state some corollaries of this result. Since the real ﬁeld and
the real-ordered group are o-minimal and admit quantiﬁer elimination, we
conclude that they also admit natural-active collapse.
Corollary 5.6.5. Every natural-semantics FO + Lin (or FO + Poly) for-
mula is equivalent to an active-domain semantics FO + Lin (or FO + Poly,
respectively) formula.
2
Combining this with active-generic collapse, we obtain the following.
Corollary 5.6.6. Let Q be an order-generic query expressible in FO + Poly
or FO + Lin. Then Q is expressible in FOact(SC , <). In particular, queries
such as parity, majority, connectivity, transitive closure, and acyclicity are
not deﬁnable in FO + Poly.
2

278
5 Embedded Finite Models and Constraint Databases
Thus, the expressive power of FO + Poly and FO + Lin is remarkably
constrained – they cannot express more generic queries than FO queries over
ordered ﬁnite structures, despite the fact that they possess great expressive
power for nongeneric queries, as we saw in Sect. 5.3.
Before we present the proof, we give a simple example of a transformation
from FO(SC , M) to FOact(SC, M). Let SC contain one binary predicate
S, and let M be the real ﬁeld (that is, we are dealing with FO + Poly).
Consider the sentence
Φ ≡∃a∃b∀x∀y (S(x, y) →a · x + b = y),
which says that S lies on a line. Note that this can be reformulated as follows:
S lies on a line iﬀevery triple of elements of S is collinear. Given three points
(x1, y1), (x2, y2), (x3, y3) in R2, there is a quantiﬁer-free FO + Poly formula
χ(x1, x2, x3, y1, y2, y3) that tests whether these points are collinear. Indeed,
such points are collinear iﬀeither x1 = x2 = x3, or y1 = y2 = y3, or two
points coincide, or, in the case when all three points are diﬀerent, they can
be ordered either as xi1 < xi2 < xi3, yi1 < yi2 < yi3 or xi1 < xi2 < xi3,
yi1 > yi2 > yi3, and (xi2 −xi1)(yi3 −yi2) = (xi3 −xi2)(yi2 −yi1). We now
express Φ by an equivalent active-domain formula,
∀x1, x2, x3, y1, y2, y3 ∈adom
 S(x1, y1) ∧S(x2, y2) ∧S(x3, y3) →
χ(x1, x2, x3, y1, y2, y3)

.
Of course, this transformation is very ad hoc, and takes into account the
semantics of the original formula Φ. In what follows, we present a more
general transformation.
5.6.4 Collapse Algorithm: the Linear Case
The general proof of natural-active collapse is by induction on the formulae.
The cases of atomic formulae and Boolean connectives are simple: for atomic
formulae, there is no need to change anything, and one just propagates the
connectives. The only hard case is that of the unrestricted quantiﬁcation
∃xϕ. We now consider an FO + Lin sentence Φ ≡∃zϕ(z), where
ϕ(z) ≡Qy1∈adom . . . Qym ∈adom α(z, ⃗y),
and where each Q is either ∃or ∀. (Of course we could have considered an
open formula Φ(⃗x) with free variables, as we shall do in the next section.
However, our goal here is to present the ideas of the proof, so we make the
assumption that there are no free variables. It will turn out that they do not
add to the complexity of the proof, but they make notation heavier.)
Using Lemma 5.5.2, we can further assume that α is a Boolean
combination of formulae of the following form:

5.6 Natural-Active Collapse
279
1. atomic SC-formulae Rj(⃗u), where Rj ∈SC and ⃗u only has variables
from ⃗y;
2. linear constraints involving z: z ϑ m
i=1 ai · yi + b, where ϑ is = or <;
3. linear constraints not involving z: m
i=1 ai · yi + b ϑ 0.
Let f1(⃗y), . . . , fp(⃗y) enumerate the (ﬁnitely many) functions that occur
as right-hand sides m
i=1 ai · yi + b of linear constraints in item 2 above (that
is, those involving z). We also assume that one of the functions fi is the
function f(⃗y) = y1.
Fix an SC-structure D, and let A = adom(D). Let
B0 = {fi(⃗a) | i = 1, . . . , p,⃗a ∈Am}.
Note that A ⊆B0. Assume that B0 = {b1, . . . , bk} with b1 < . . . < bk.
6
6
b1
bi
bi+1
bk
z1
z2
•
•
•
•
Fig. 5.4. Illustration to the natural-active collapse for the linear case
If z1 ∈(bi, bi+1) satisﬁes ϕ, then any other z2 from this interval satisﬁes
ϕ, as illustrated in Fig. 5.4. Indeed, the variable z is used only in atomic sub-
formulae of the form of item 2, that is, z ϑ fj(⃗y). Thus, for any instantiation
⃗a for ⃗y from the active domain A, we have D |= α(z1,⃗a) ↔α(z2,⃗a), since the
signs of z1 and z2 with respect to all fj(⃗a) are the same. Since all variables ⃗y
range over A, this implies D |= ϕ(z1) ↔ϕ(z2). Similarly, we note that for any
z1, z2 < b1, or for any z1, z2 > bk, it is also the case that D |= ϕ(z1) ↔ϕ(z2).
Thus, if ϕ is witnessed by an element in an interval (bi, bi+1), or (−∞, b1),
or (bk, ∞), it is witnessed by every element of the interval. Hence, if we deﬁne
B1 = {b + b′
2
| b, b′ ∈B0} ∪{b −1 | b ∈B0} ∪{b + 1 | b ∈B0},
we conclude that D |= ∃zϕ(z) iﬀD |= ϕ(b) for some b ∈B1.
A nice property of B1 is that it is deﬁnable in FO + Lin under the
active-domain semantics. In fact, using the deﬁnition of B1, we just rewrite
∃zϕ(z) as an equivalent active-domain semantics sentence:
∃⃗u∈adom ∃⃗v∈adom
⎛
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
 p
i=1
p
j=1(ϕ([ fi(⃗u)+fj(⃗v)
2
/ z]))

∨
 p
i=1 ϕ([(fi(⃗u) −1) / z])

∨
 p
i=1 ϕ([(fi(⃗u) + 1) / z])

⎞
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

280
5 Embedded Finite Models and Constraint Databases
where f1, . . . , fp are all the linear functions used in constraints of the form
z = fi(⃗y) or z < fi(⃗y) in the formula ϕ and the function f(⃗y) = y1.
Note that the proof of the existence of a sentence equivalent to Φ is
constructive. Furthermore, the simple proof sketched in this section contains
the main ingredients of the general proof. To eliminate an unrestricted
quantiﬁer from ϕ(⃗x) ≡∃zα(z, ⃗x), we deﬁne some partition of U into a ﬁnite
union of intervals 
i Ii(⃗x), such that:
•
if ϕ(⃗a) is witnessed by c ∈Ii(⃗a), then it is witnessed by any c′ ∈Ii(⃗a);
•
each interval Ii(⃗x) is deﬁnable by an FO(SC, M) formula, parametrically
in ⃗x, and so is a representative of each such interval; and
•
the maximum number of intervals Ii(⃗x) is uniformly bounded for all ⃗x.
5.6.5 Collapse Algorithm: the General Case
We start by listing some important properties of o-minimal structures. The
key is the uniform bound on the number of intervals in deﬁnable sets.
Theorem 5.6.7 (Uniform Bounds). If M is o-minimal, and γ(⃗y, x) is a
ﬁrst-order formula in the language of M, then there is an integer Kγ such
that, for each tuple ⃗a from U, the set {x | M |= γ(⃗a, x)} is composed of fewer
than Kγ intervals.
This is a very strong and deep result. O-minimality simply tells us that for
every γ(⃗y, x) and every ⃗a, the set γ(M,⃗a) = {x | M |= γ(⃗a, x)} is a ﬁnite union
of intervals. It is conceivable that the number of intervals in γ(M,⃗a) depends
on ⃗a in such a way that there is no bound on this number when ⃗a ranges over
U. The Uniform Bounds Theorem tells us that such a situation is impossible:
there is an an upper bound on the number of intervals that depends only on
γ, and not on ⃗a. As a side remark, the Uniform Bounds Theorem also implies
that a structure elementarily equivalent to an o-minimal one is o-minimal
itself.
We note, however, that for many familiar o-minimal structures, such as
the real ﬁeld or the real ordered group, the Uniform Bounds Theorem is
trivial. Indeed, for the real ﬁeld, the proof of o-minimality based on quantiﬁer
elimination (given in Sect. 5.6.2) immediately yields uniform bounds, as the
number of intervals is determined by the number of polynomials used in the
formula, and by their degrees (recall that the number of intervals is deter-
mined by the total number of roots of all nonzero polynomials used in the
formula).
For every γ(⃗y, x) in the language of M and constants, and every ⃗a over
M, by the ith interval of γ(⃗a, ·) we shall mean the ith interval of γ(M,⃗a), in
the usual ordering on U. We shall use the following simple facts:

5.6 Natural-Active Collapse
281
•
For every formula γ(⃗y, x), and every i, there exists a ﬁrst-order formula
denoted by ˆγi(⃗y, x) such that M |= ˆγi(⃗a, c) iﬀc is in the ith interval of
γ(⃗a, ·). In what follows, we always assume that the distinguished variable
x is the last one.
•
If the quantiﬁer elimination procedure is eﬀective, and atomic sentences
of M are decidable, then Kγ is computable for each γ. Indeed, for each i,
we can write a sentence Γi ≡∃x∃⃗y ˆγi(⃗y, x) and check whether it is true
in M, using quantiﬁer elimination and recursiveness of M. Eventually, we
ﬁnd an i such that Γi is false; this follows from Theorem 5.6.7. Thus, Kγ
can be taken to be this i.
•
Since intervals are ﬁrst-order deﬁnable, we can use them in formulae.
For example, given a formula γ(⃗y, x), a number i, and another formula
β(⃗z, x), we can write a ﬁrst-order formula α(⃗y,⃗z, x) saying that every
x from the ith interval of γ(⃗y, ·) satisﬁes β(⃗z, x). This of course is just
∀x (ˆγi(⃗y, x) →β(⃗z, x)), but we shall occasionally use the interval notation
in formulae, to simplify the presentation.
Natural-Active Collapse: Eliminating One Existential Quantiﬁer
This is the key case in proving the collapse, as the proof is by induction on
the formulae, and this is the only case where there is a need to do something.
We consider an FOact(SC, M) formula
α(⃗x, z)
≡
Qy1 ∈adom . . . Qym∈adom β(⃗x, ⃗y, z) ,
where β(⃗x, ⃗y,⃗z) is quantiﬁer-free, and has the following properties:
•
every atomic subformula of β is either an FO(SC) formula or an FO(M)
formula (where equalities are considered to be FO(M) formulae);
•
there exists at least one FO(M) atomic subformula of β, and at least one
⃗y-variable (that is, m > 0); and
•
z does not occur in atomic FO(SC) subformulae.
Let F be the collection of all FO(M) atomic subformulae of β, and their
negations.
For formulae σ(⃗x, ⃗y, z), ρ(⃗x, ⃗y, z), and τ(⃗x, ⃗y, z) from F, for i ≤Kρ and
j ≤Kτ, we let σρτ
ij (⃗x, ⃗y,⃗s,⃗t), where card(⃗s) = card(⃗t) = card(⃗y), be the
formula deﬁned as follows:
σρτ
ij (⃗x, ⃗y,⃗s,⃗t)
≡
∀u

(ˆρi(⃗x,⃗s, u) ∧ˆτj(⃗x,⃗t, u)) →σ(⃗x, ⃗y, u)

.
Let ϕ(⃗x) be ∃z α(⃗x, z).
Lemma 5.6.8. Let D be a nonempty ﬁnite SC-structure over M. Let
ϕ, α, β, F be as above. Let ⃗a be a tuple over U. Then D |= ϕ(⃗a) if and only

282
5 Embedded Finite Models and Constraint Databases
if there exist ⃗b,⃗c ∈adom(D)m, two formulae ρ(⃗x, ⃗y, z) and τ(⃗x, ⃗y, z) in F
and i ≤Kρ, and j ≤Kτ such that for the ith interval of ρ(⃗a,⃗b, ·) and the
jth interval of τ(⃗a,⃗c, ·), denoted by I0 and I1, respectively, the following three
conditions hold:
1. I0 ∩I1 ̸= ∅.
2. For all ⃗e ∈adom(D)m, and all c, c′ ∈I0 ∩I1, we have M |= σ(⃗a,⃗e, c) ↔
σ(⃗a,⃗e, c′) for all σ ∈F.
3. D |= α′(⃗b,⃗c,⃗a), where α′(⃗s,⃗t, ⃗x) is obtained from α(⃗x, z) by replacing
each subformula σ(⃗x, ⃗y, z) from F by σρτ
ij (⃗x, ⃗y,⃗s,⃗t).
Proof. For the only if part, assume that D |= ϕ(⃗a). That is, D |= ∃zα(⃗a, z).
Let d witness this; that is, D |= α(⃗a, d). For every ⃗e over adom(D) of the
same length as ⃗y, and every atomic FO(M) subformula ρ(⃗x, ⃗y, z) of β, we
deﬁne Id(⃗e, ρ) to be the maximal interval of ρ(M,⃗a,⃗e) = {c | M |= ρ(⃗a,⃗e, c)}
containing d, in the case when M |= ρ(⃗a,⃗e, d), or the the maximal interval
of ¬ρ(M,⃗a,⃗e) containing d, in the case when M |= ¬ρ(⃗a,⃗e, d). Let Id be the
collection {Id(⃗e, ρ) | ⃗e ∈adom(D)|⃗y|, ρ ∈F}. Since for each ⃗e and ρ we have
d ∈Id(⃗e, ρ), we obtain that  Id ̸= ∅.
Now note that for any ﬁnite collection of intervals I1, . . . , Ip, there are two
indices i and j such that p
l=1 Il = Ii ∩Ij. Then there are two intervals I0
and I1 in Id such that I0 ∩I1 =  Id. Let ⃗b be such that I0 is the ith interval
of ρ(⃗a,⃗b, M), and let ⃗c be such that I1 is the jth interval of τ(⃗a,⃗c, M), where
ρ, τ ∈F (that is, ρ, τ are either atomic FO(M) subformulae of ϕ or negations
of such atomic subformulae).
Let ⃗e ∈adom(D)|⃗y|. Pick any σ ∈F and any c, c′ ∈I0 ∩I1. Since
I0 ∩I1 =  Id, we obtain that c, c′ ∈I0 ∩I1 ⊆Id(⃗e, σ), which implies
M |= σ(⃗a,⃗e, c) ↔σ(⃗a,⃗e, c′). This proves conditions 1 and 2 in the lemma.
To prove condition 3, notice that, for every FO(M) atomic subformula
σ(⃗x, ⃗y, z) of ϕ and every ⃗e ∈adom(D)|⃗y|, we have
σ(⃗a,⃗e, d)
↔
∀u ∈I0 ∩I1 σ(⃗a,⃗e, u) ,
since I0 ∩I1 =  Id.
Now, for any subformula γ(⃗x, ⃗y, z) of α(⃗x, z), let γ′(⃗s,⃗t, ⃗x, ⃗y) be the result
of replacing each σ(⃗x, ⃗y, z) from F by σρτ
ij (⃗x, ⃗y,⃗s,⃗t).
We can now restate the above equivalence as
(∗)
D |= σ(⃗a,⃗e, d) ↔σ′(⃗a,⃗e,⃗b,⃗c)
for every ⃗e ∈adom(D)|⃗y| (where ⃗b and ⃗c are the tuples necessary to deﬁne
I0 ∩I1 above), where σ(⃗x, ⃗y, z) is atomic or negated atomic (i.e. σ ∈F).
The above equivalence is preserved under Boolean combinations and
active quantiﬁcation over variables from ⃗y in σ. Hence we obtain (∗) for every
σ that is a subformula of α. Finally, this gives us
D |= α(⃗a, d) ↔α′(⃗a,⃗b,⃗c) .

5.6 Natural-Active Collapse
283
Since D |= α(⃗a, d), we conclude that D |= α′(⃗a,⃗b,⃗c), proving condition 3.
To prove the if part, assume that there exist ⃗b,⃗c ∈adom(D)m, ρ, τ ∈F,
and i ≤Kρ, j ≤Kτ such that for I0, I1 deﬁned as in the statement of the
lemma, conditions 1, 2, and 3 hold. Let d be an arbitrary element of I0 ∩I1.
We claim that D |= α(⃗a, d), thus proving D |= ϕ(⃗a).
Indeed, for every FO(M) atomic subformula σ(⃗x, ⃗y, z) of α, we have
σ(⃗a,⃗e, d)
↔
∀u ∈I0 ∩I1 σ(⃗a,⃗e, u) ,
for every ⃗e over adom(D) – this follows from condition 2. That is, σ(⃗a,⃗e, d) ↔
σρτ
ij (⃗a,⃗e,⃗b,⃗c). As before, since this equivalence is preserved under Boolean
combinations with FO(SC) atomic formulae, and under active-domain
quantiﬁcation over variables from ⃗y, we obtain
D |= α(⃗a, d) ↔α′(⃗b,⃗c, a) ,
thus proving D |= α(⃗a, d). The lemma is proved.
2
The Transformation Algorithm
The algorithm that converts natural-semantics formulae into active-semantics
formulae works by induction on the structure of the formulae. In the case
of atomic formulae, there is no need to change anything. For Boolean
connectives, suppose that ϕ ≡χ ∨ψ. Let χact and ψact be FOact(SC, M)
formulae equivalent to χ and γ. Then χact ∨ψact is an FOact(SC , M) formula
equivalent to ϕ. We deal with negation and conjunction similarly.
The only nontrivial case is that of an existential quantiﬁer ∃zα(⃗x, z). To
handle it, we use Lemma 5.6.8. For now, assume that we are dealing with
nonempty SC-structures. By the induction hypothesis, we assume that α is
an FOact(SC, M) formula. We ﬁrst put α in the form required by Lemma
5.6.8 by taking the conjunction with a true sentence ∃y ∈adom(y = y)
(since adom is nonempty) to ensure that there are quantiﬁers and atomic
FO(M) formulae, then using Lemma 5.5.2 to separate FO(M) and FO(SC)
formulae, and ﬁnally putting α into prenex form. Once α is in the right
form, we apply Lemma 5.6.8, noticing that it translates into a ﬁrst-order
description. The step-by-step process of doing so is described in the
algorithm Natural-Active shown on the next page. Note that every
occurrence of an unrestricted quantiﬁer ∀or ∃is of the form ∀yγ or
∃xγ, where γ is an FO(M) formula. Since M has quantiﬁer elimination,
this means that every occurrence of unrestricted quantiﬁcation can be
eliminated.
Summing up, we have the following.

284
5 Embedded Finite Models and Constraint Databases
Algorithm Natural–Active
Input:
FO(SC, M) formula ϕ(⃗x)
Output: FOact(SC, M) formula ϕact(⃗x)
1. If ϕ is an atomic formula, then ϕact = ϕ.
2. If ϕ = ψ ∗χ, then ϕact = ψact ∗χact where ∗∈{∨, ∧}; if ϕ = ¬ψ, then
ϕact = ¬ψact.
3. If ϕ = ∃x∈adom ψ, then ϕact = ∃x∈adom ψact.
4. Let ϕ(⃗x) = ∃z α0(⃗x, z).
4.1 Let α(⃗x, z) be a formula equivalent to α0
act which is of the form
Qy1 ∈adom . . . Qym ∈adom β(⃗x, ⃗y, z),
where β(⃗x, ⃗y, ⃗z) is quantiﬁer-free and has the following properties: every
atomic subformula of β is either an FO(SC) formula or an FO(M) formula;
there exists at least one FO(M) atomic subformula of β, m > 0, and z does
not occur in FO(SC) subformulae.
4.2 Let F be the collection of all atomic FO(M) subformulae of α, and their
negations.
4.3 Let K = maxγ∈F Kγ.
4.4 For every pair of formulae ρ, σ ∈F, and every i, j < K, deﬁne χρσ
ij (⃗x,⃗s,⃗t)
to be the quantiﬁer-free FO(M) formula equivalent to ∃u

ˆρi(⃗x,⃗s, u) ∧
ˆσj(⃗x,⃗t, u)

. Note that | ⃗s |=| ⃗t |= m.
4.5 For each ρ, σ ∈F, each i, j < K, and each τ ∈F, deﬁne τ ρσ
ij (⃗x, ⃗y,⃗s,⃗t) as a
quantiﬁer-free formula equivalent to
∀u

ˆρi(⃗x,⃗s, u) ∧ˆσj(⃗x,⃗t, u) →τ(⃗x, ⃗y, u)

4.6 For each ρ, σ ∈F and each i, j < K, deﬁne αρσ
ij (⃗x,⃗s,⃗t) as α in which every
FO(M) atomic subformula τ(⃗x, ⃗y, z) ∈F is replaced by τ ρσ
ij (⃗x, ⃗y,⃗s,⃗t).
4.7 Let sameβ(⃗x,⃗r, u, v) be (ρ(⃗x,⃗r, u) ↔ρ(⃗x,⃗r, v)), where the conjunction is
taken over all the FO(M) atomic subformulae ρ of β.
4.8 For each ρ, σ ∈F, each i, j < K, deﬁne ηρσ
ij (⃗x,⃗s,⃗t,⃗r) as a quantiﬁer-free
formula equivalent to
∀u, v

(ˆρi(⃗x,⃗s, u) ∧ˆσj(⃗x,⃗t, u) ∧ˆρi(⃗x,⃗s, v) ∧ˆσj(⃗x,⃗t, v)) →sameβ(⃗x,⃗r, u, v)

.
4.9 For each ρ, σ
∈
F and each i, j
<
K, deﬁne πρσ
ij (⃗x,⃗s,⃗t) as ∀⃗r ∈
adom ηρσ
ij (⃗x,⃗s,⃗t,⃗r).
4.10 Output, as ϕact(⃗x), the formula
∃⃗s∈adom ∃⃗t∈adom

ρ,σ∈F

i,j<K
(χρσ
ij (⃗x,⃗s,⃗t) ∧πρσ
ij (⃗x,⃗s,⃗t) ∧αρσ
ij (⃗x,⃗s,⃗t)).

5.6 Natural-Active Collapse
285
Proposition 5.6.9. Let M be o-minimal and admit quantiﬁer elimination.
Let ϕ(⃗x) be any FO(SC, M) ﬁrst-order formula, and let ϕact be the output of
Natural-Active on ϕ. Then, for every nonempty ﬁnite SC-structure D,
D |= ∀⃗x ϕ(⃗x) ↔ϕact(⃗x). Furthermore, if M is recursive and the quantiﬁer
elimination procedure is eﬀective, then there is an eﬀective procedure yielding
such a ϕact for an input ϕ.
2
To conclude the proof of Theorem 5.6.4, we have to deal with the case
of adom(D) being empty. Let ϕ(⃗x) be an FO(SC , M) formula. Let ϕ′
∅(⃗x) be
obtained from ϕ by replacing each occurrence of R(· · · ), where R ∈SC, by
false. Note that ϕ′
∅is an FO(M) formula. Let ϕ∅be a quantiﬁer-free formula
equivalent to ϕ′
∅. A simple induction on formulae shows that for the empty
SC-instance, ∅SC, it is the case that ∅SC |= ϕ(⃗a) iﬀM |= ϕ∅(⃗a), for every ⃗a.
Thus, an FOact(SC, M) formula
ϕ′(⃗x)
≡
[(∃x∈adom (x = x)) ∧ϕact(⃗x)]
∨[(¬∃x∈adom (x = x)) ∧ϕ∅(⃗x)]
has the property that D |= ∀⃗x ϕ(⃗x) ↔ϕ′(⃗x), for arbitrary D. This concludes
the proof of Theorem 5.6.4.
2
5.6.6 Collapse Without O-minimality
We have seen that quantiﬁer elimination is necessary for natural-active col-
lapse. What about o-minimality? It turns out that there are non-o-minimal
structures that admit this collapse. Consider the structure Z = ⟨Z, +, <⟩. It is
not o-minimal: for example, the formula ϕ(x) given by ∃y (y + y = x) deﬁnes
the set of even numbers. The same example, though, shows that natural-active
collapse fails over Z: the Boolean query ∃x (S(x) ∧ϕ(x)) is not expressible in
FOact({S}, Z), since ϕ cannot be expressed by a quantiﬁer-free formula.
However, it is well known that Z admits quantiﬁer elimination in an
extended signature. Let x ∼k y iﬀx = y(mod k). These relations are deﬁnable
over Z, and the structure Z0 = ⟨Z, +, <, 0, 1, (∼k)k>0⟩does admit quantiﬁer
elimination. We thus have an example of a structure that has quantiﬁer
elimination, is not o-minimal, and admits natural-active collapse.
Proposition 5.6.10. Z0 admits the natural-active collapse.
Proof sketch. The proof is again by induction, and we consider the only
nontrivial case of existential quantiﬁcation. To simplify the notation, assume
that we have a sentence Φ ≡∃zϕ(z), where
ϕ(z) ≡Qy1 ∈adom . . . Qym ∈adom α(z, ⃗y),
and where each Q is either ∃or ∀.

286
5 Embedded Finite Models and Constraint Databases
Using Lemma 5.5.2, we can assume that α is a Boolean combination of:
1. atomic SC-formulae with free variables among ⃗y;
2. linear constraints f(z, ⃗y) ϑ 0, where f is a linear function and ϑ is an =,
or <, or ≤comparison;
3. constraints of the form f(z, ⃗y) ∼c p for c ∈N and 0 ≤p < c, where again
f is a linear function.
Let c be the maximum number for which one of the ∼c relations occurs in α.
Let χi(x) enumerate all satisﬁable formulae of the form
	
1<b≤c
x ∼b pb,
where pb < b, and similarly let χm
i (⃗y) enumerate all satisﬁable conjunctions
χi1(y1) ∧. . . ∧χim(ym). Then ϕ(z) is equivalent to
∃z
 
i
χi(z) ∧Qy1 ∈adom . . . Qym ∈adom
 
j
χm
j (⃗y) ∧α(z, ⃗y)

.
Note that if we know all the residues for z and ⃗y modulo all the positive
integers not exceeding c, then we can infer the truth value of each constraint
of the form f(z, ⃗y) ∼b p for every b ≤c and pb < b. Thus, we can assume
without loss of generality that constraints of the form f(z, ⃗y) ∼b p do not
appear in α, unless f is identically z or one of the yis.
To eliminate ∃z from the formula above, we proceed just as in the case of
FO + Lin. Let g1(⃗y), . . . , gl(⃗y) enumerate all the linear functions that occur
in constraints of the form zϑgi(⃗y), and the function g(⃗y) = y1. We ﬁx a ﬁnite
set A, and deﬁne a set B0 as {gi(⃗a) | i ≤l,⃗a ∈Am}. Note that A ⊆B0. Let
b1 < . . . < bk list the elements of B0.
Suppose we have an SC-structure D with adom(D) = A, and suppose
that ϕ(z0) holds. Assume that bi < z0 < bi+1. Then the same argument as
in the proof of the collapse for FO + Lin shows that any other z′
0 ∈(bi, bi+1)
that agrees with z0 on all χjs also satisﬁes ϕ. This shows the following: if there
is a z0 satisfying ϕ, then there is one such that |z0 −bi| ≤c for some bi. In
particular, if D |= Φ, then there exists a z0 ∈B1 such that D |= ϕ(z0), where
B1 = {b + p, b −p | b ∈B0, 0 ≤p ≤c}. Just as in the case of FO + Lin, this
set B1 is deﬁnable in FO(SC, Z0). Thus, under the assumption that α uses
only ∼k relations to compare a variable with a constant, we can rewrite Φ as
∃⃗u∈adom

−c≤b≤c
l
i=1
ϕ((gi(⃗u) + b) / z),
thus eliminating an unrestricted quantiﬁer ∃z. Notice that, unlike the case of
FO + Lin, we need m additional active-domain quantiﬁers (instead of 2m),
as the proof does not require witnesses which are middles of some intervals
(bi, bi+1).
2

5.6 Natural-Active Collapse
287
5.6.7 Natural-Generic Collapse
The natural-generic collapse result says that order-generic queries in
FO(SC, M) can be expressed in FO(SC , <). We now derive this collapse
result as a corollary to the two collapse results shown so far.
Corollary 5.6.11 (Natural-Generic Collapse). Let M = ⟨U, Ω⟩be an
o-minimal structure. Then it admits natural-generic collapse.
Proof. Let Q be an order-generic query deﬁnable in FO(SC , M). Consider a
deﬁnitional expansion M′ of M obtained by extending Ω with new symbols
for all M-deﬁnable predicates. Such an M′ admits quantiﬁer elimination,
and then, by use of natural-active collapse, we obtain that Q is deﬁnable
in FOact(SC, M′). From the active-generic collapse, we conclude that Q is
deﬁnable in FOact(SC, <) (and thus in FO(SC , <)).
2
While the active-generic collapse holds for all ordered structures, and the
bounds of Theorem 5.6.4 are the best currently known for the natural-active
collapse, Corollary 5.6.11 has been extended to a larger class of structures.
The proof of the result is rather involved, but we shall present a statement
of the result below.
The new condition on the structures uses the Vapnik-Chervonenkis (VC)
dimension, a central concept in computational learning theory. Suppose that
S is an inﬁnite set, and C ⊆2S is a family of subsets of S. Let F ⊂S be
ﬁnite; we say that C shatters F if the collection {F ∩C | C ∈C} is 2F. The
Vapnik-Chervonenkis dimension of C, VCdim(C), is the maximal cardinality
of a ﬁnite set shattered by C. If arbitrarily large ﬁnite sets are shattered by
C, we let VCdim(C) = ∞.
This applies to ﬁrst-order structures as follows. Let M = ⟨U, Ω⟩, and let
ϕ(⃗x, ⃗y) be a formula in the language of M with |⃗x| = n, |⃗y| = m. For each
⃗a ∈U n, we deﬁne ϕ(⃗a, M) = {⃗b ∈U m | M |= ϕ(⃗a,⃗b)}, and let Fϕ(M) be
{ϕ(⃗a, M) | ⃗a ∈Un}. Families of sets arising in such a way are called deﬁnable
families.
Deﬁnition 5.6.12. M is said to have ﬁnite VC dimension if every deﬁnable
family in M has ﬁnite VC dimension.
2
Examples of structures that have ﬁnite VC dimension include:
•
every o-minimal structure;
•
⟨N, +, <⟩and ⟨Z, +, <⟩;
•
every linear order;
•
ordered Abelian groups (that is, Abelian groups in which addition is
monotone with respect to the order).
In particular, the class is a proper extension of the class of all o-minimal
structures. The following is a deep result which we present here without proof:

288
5 Embedded Finite Models and Constraint Databases
FOact(SC, M) =========================
o-minimal and
quantiﬁer elimination:
natural-active
collapse
FO(SC, M)
FOact(SC, <)
all ordered
structures:
active-generic
collapse
(((((((((
========================== FO(SC, <)
ﬁnite
VC dimension:
natural-generic
collapse
(((((((((
Fig. 5.5. Summary of collapse results
Theorem 5.6.13. Let M be an ordered structure that has ﬁnite VC
dimension. Then M admits natural-generic collapse.
2
We shall discuss the relationship between the VC dimension and various
forms of collapse in Sect. 5.8.
The diagram in Fig. 5.5 summarizes what has been achieved towards
proving the collapse results.
5.7 Model Theory and Collapse Results
While most collapse results proved so far apply to o-minimal structures, we
have seen a couple of examples outside of the o-minimal world. So it is natural
to ask what really causes the natural-active or other forms of collapse: are
there some properties of the underlying structure that cause it to happen?
The goal of this section is to give a partial answer to this question. We
start by presenting a technical condition, called pseudo-ﬁnite homogeneity,
that ensures a form of collapse that is closely related to natural-active
collapse. We then describe a couple of model-theoretic conditions that are
often easy to verify, and that imply pseudo-ﬁnite homogeneity and thus
the collapse. We shall see a number of examples of collapse outside of the
o-minimal context that are implied by those conditions.
We start with the following deﬁnition.
Deﬁnition 5.7.1. We say that a structure M admits restricted quantiﬁer
collapse if for every SC, every FO(SC , M) formula is equivalent to an
FO(SC, M) formula in which SC-relations do not appear in the scope of
unrestricted quantiﬁers.

5.7 Model Theory and Collapse Results
289
For example, in the formula ∃x∈adom∀y∈adom (S(x, y) →∀z∃u x2+y =
z2 + u), the SC-relation S appears only in the scope of two active-
domain quantiﬁes ∃x ∈adom and ∀y ∈adom. However, for the formula
∃u∃v (∀x ∈adom∀y ∈adom S(x, y) →y = u · x + v) this is not the case, as
S appears in the scope of the quantiﬁers ∃u and ∃v.
Note that if M admits restricted quantiﬁer collapse, and if M′ is the
expansion of M with all deﬁnable predicates, then every FO(SC , M) formula
is equivalent to an FOact(SC, M′) formula. In particular, if M admits
quantiﬁer elimination, then restricted quantiﬁer collapse implies natural-
active collapse. Furthermore, restricted quantiﬁer collapse always implies
natural-generic collapse. Thus:
restricted
quantiﬁer
collapse
+ QE
=
natural-
active
collapse
⇒
restricted
quantiﬁer
collapse
⇒
natural
generic
collapse
Remark. Although we shall provide all the necessary model-theoretic def-
initions here, the reader needs some inﬁnite model theory background to
understand the proofs in this section. In particular, many proofs using tech-
niques from classical inﬁnite model theory are only sketched. We nevertheless
encourage the reader without such a background to read this section (perhaps
skipping the proofs) to see many new examples of collapse results.
We shall also assume that we are dealing with structures in a ﬁnite or
countable language; this assumption can easily be avoided at the expense of
some additional arguments involving inﬁnite cardinals, which we prefer not
to deal with here.
5.7.1 Pseudo-ﬁnite Homogeneity
We start with a few deﬁnitions from model theory. For a structure M,
its theory is denoted by Th(M). Two structures M1 and M2 of the same
language are elementarily equivalent (written M1 ≡M2) if their theories
are the same; that is, if they satisfy the same FO-sentences. For a subset
A of M, and an n-tuple ⃗a, the n-type of ⃗a over A (or just the type, if n is
understood), tpM(⃗a/A), is the set of all formulae in n free variables, in the
language of M plus constants for the elements of A, that are satisﬁed by ⃗a.
A model M is called ω-saturated if every consistent 1-type over a ﬁnite
subset of M is realized in M. It is known that, for every M, there exists an
ω-saturated elementary extension M′.
Let L(SC, M) be the language that is the expansion of L(M), the language
of M, with all the relation symbols in SC. A structure in this language is a pair
(M′, D), where M′ is a structure in the language of M and D is an interpreta-
tion of SC symbols over M′ (not necessarily ﬁnite). Let F(SC , M) be the the-
ory of all L(SC, M) structures (M′, D), where M′ |= Th(M) and D is ﬁnite.
We now call an SC -structure D on M pseudo-ﬁnite if (M, D) |= F(SC, M).

290
5 Embedded Finite Models and Constraint Databases
Deﬁnition 5.7.2. We say that M has ω-pseudo-ﬁnite homogeneity property,
or ω-PFH for short, if for any model M′ of Th(M), any two pseudo-ﬁnite
SC-structures D1, D2 on M′, and any bijective and L(M)-elementary map
h : D1 →D2 such that (M′, D1, D2, h) is ω-saturated, it is the case that for
every a ∈M′ there exists b ∈M′ such that h ∪{(a, b)} is elementary.
Theorem 5.7.3. If M has ω-PFH, then it admits restricted quantiﬁer
collapse.
Proof sketch. Let ϕ be an FO(SC , M) sentence. Assume that ϕ is not equiv-
alent to any restricted quantiﬁer sentence. Let αi enumerate all restricted
quantiﬁer FO(SC, M) sentences; then, for every αi, we can ﬁnd a model
(Mi, D1
i , D2
i ) such that Mi ≡M, D1
i |= ϕ, D2
i |= ¬ϕ, and D1
i , D2
i agree on
αi. By compactness, we have a model (M′, D1, D2) such that D1, D2 agree
on all FOact(SC, M) sentences, and D1 |= ϕ and D2 |= ¬ϕ.
A standard model-theoretic argument shows that we can further assume
that there is a partial L(SC, M)-isomorphism h : D1 →D2 that is also an
elementary map in the language of M, and, furthermore, that (M, D1, D2, h)
is ω-saturated. By ω-PFH, for any k > 0, h can be extended k times back and
forth to an L(M)-elementary map, which is a partial L(SC, M)-isomorphism,
since its domain includes adom(D1) and its range includes adom(D2). Thus,
h is an L(SC, M)-elementary map, which contradicts the statement that
D1 |= ϕ and D2 |= ¬ϕ.
2
The notion of pseudo-ﬁnite homogeneity may not be a very easy one
to check for a given structure; however, other model-theoretic properties
imply it, and thus they imply restricted quantiﬁer collapse. We shall see two
examples below.
5.7.2 Finite Cover Property and Collapse
Similarly to the deﬁnition of ω-saturation, we can deﬁne ω1-saturated
structures by requiring that types over countable sets (rather than just
ﬁnite sets) be realized. By requiring that the structure (M′, D1, D2, h) in the
deﬁnition of PFH be ω1-saturated, we obtain a stronger notion of ω1-PFH.
We now say that M has the pseudo-ﬁnite saturation property, or PFS for
short, if for any model M′ of the theory of M and any pseudo-ﬁnite set A in M′
such that (M′, A) is ω1-saturated, every consistent 1-type over A is realized
in (M′, (a)a∈A). This property is easier to connect to other model-theoretic
properties, and, furthermore, we can state the following proposition.
Proposition 5.7.4. Pseudo-ﬁnite saturation implies ω1-PFH, and thus it
implies restricted quantiﬁer collapse.
Proof. Let (M′, D1, D2, h) be ω1-saturated, where D1, D2 are pseudo-ﬁnite.
Let a ∈M′, A = adom(D1), and p = tpM′(a/A). Let h(p) = {ϕ(x, h(⃗a)) |
ϕ(x,⃗a) ∈p}. Then h(p) is a type over adom(D2); by pseudo-ﬁnite saturation,
it is realized by some b ∈M′, and thus h ∪{(a, b)} is elementary.
2

5.7 Model Theory and Collapse Results
291
One known result about pseudo-ﬁnite saturation is that it holds for
structures that do not have the ﬁnite cover property. Recall that a structure
M has the ﬁnite cover property if there is a formula ϕ(x, ⃗y) such that, for
every n > 0, one can ﬁnd tuples ⃗a1, . . . ,⃗an such that ∃x 
j̸=i ϕ(x,⃗aj) holds
for each i ≤n, but ∃x 
j≤n ϕ(x,⃗aj) does not hold.
Since every M that
does not have the cover property has pseudo-ﬁnite saturation, it also admits
restricted quantiﬁer collapse.
In model theory, a number of examples of structures without the ﬁnite
cover property have been collected; for example, every structure whose theory
is categorical in every uncountable power is such a structure. Some of the
best known examples are:
•
The ﬁeld of complex numbers ⟨C, +, ·⟩(in fact, any algebraically closed
ﬁeld of characteristic p, where p is zero or prime).
•
⟨N, π⟩, where π : N →N is a permutation without ﬁnite cycles.
•
⟨N, succ⟩.
Corollary 5.7.5. The three structures above admit restricted quantiﬁer
collapse.
As another example, we consider the ﬁrst-order theory of ﬁnitely many
successor relations. This is a decidable theory (in fact, even the monadic
second-order theory is decidable, by a classical result by B¨uchi) with many
applications in computer science. Let Σ be a ﬁnite alphabet, and let Σ∗
be the set of all ﬁnite strings over Σ, with ε being the empty string. For
each a ∈Σ, let fa be the unary function that appends a at the end of its
argument: fa(x) = x · a. We now have the following.
Proposition 5.7.6. For any ﬁnite Σ, the structure ⟨Σ∗, ε, (fa)a∈Σ⟩admits
restricted quantiﬁer collapse.
Proof sketch. We show that M = ⟨Σ∗, ε, (fa)a∈Σ⟩does not have the ﬁnite
cover property. We need a little preparation. Our proof will use the following
known result: M does not have the ﬁnite cover property if (a) no formula
α(⃗x, ⃗y) deﬁnes an inﬁnite linear order on M, and (b) for every α(⃗x, ⃗y), there
is a formula β(⃗x) such that β(⃗x) holds iﬀthe number of ⃗y for which α(⃗x, ⃗y)
holds is inﬁnite.1
Let ga(x) be the following deﬁnable function: if the last symbol of x
is a, then g removes it; otherwise ga(x) = x. Then it is easy to see that
1 The reader familiar with this subject will notice that our condition (b) is not
suﬃcient to conclude that M does not have the ﬁnite cover property: instead, one
would need to show a stronger property (b′): namely, for any formula α(⃗x, ⃗y, ⃗z)
such that α(M, ⃗z) is an equivalence relation E⃗z for every ⃗z, there is a formula
β(⃗z) such that β(⃗z) holds iﬀE⃗z has ﬁnitely many equivalence classes. However,
using quantiﬁer elimination for M, one can show that M eliminates imaginaries
and thus each equivalence relation is of the form {(⃗u, ⃗w) | f(⃗u) = f(⃗v)} for some
deﬁnable function f. Therefore, (b) implies (b′).

292
5 Embedded Finite Models and Constraint Databases
⟨Σ∗, ε, (fa)a∈Σ⟩has quantiﬁer elimination in the language ⟨(fa, ga)a∈Σ, ε⟩.
Using this, one easily concludes (a).
To show (b), we deﬁne the distance between two strings x and y, d(x, y),
as the minimal length of a term t built from fa, ga, ε such that t(x) = y. If
one thinks of Σ∗as an inﬁnite |Σ|-ary tree, then d(u, v) is simply the distance
in this tree. We deﬁne d(⃗x, ⃗y) as the minimal distance between a component
of ⃗x and a component of ⃗y. Note that for each ﬁxed i, d(⃗x, ⃗y) < i is deﬁnable.
Given a formula α(⃗x, ⃗y), assume without loss of generality that it is a
Boolean combination of formulae v = t(u), where v, u are variables among
⃗x, ⃗y and the ts are terms. Let k be the maximum length of a term in α. We
deﬁne γ(⃗x) as
∀⃗y α(⃗x, ⃗y) →
	
i
(d(yi, ⃗x) < m(k + 2)) ∧(d(yi, ε) < m(k + 2)),
where m is the length of ⃗y. We claim that γ(⃗x) holds iﬀthe number of ⃗y such
that α(⃗x, ⃗y) holds is ﬁnite. Then we take β ≡¬γ.
One direction is trivial. Assume that γ(⃗x) does not hold; then one can
ﬁnd ⃗y for which α(⃗x, ⃗y) holds, and divide ⃗y into two parts, ⃗y1 and ⃗y2, such
that d(⃗y2, (⃗y1, ⃗x, ε)) > k + 1. Now let s be a suﬃciently long string; deﬁne
s · ⃗y2 as the result of adding s as a preﬁx to all strings in ⃗y2. It is clear that
α(⃗x, (⃗y1, s · ⃗y2)) still holds, which completes the proof, since s is arbitrary. 2
The results of this section have some limitations; in particular, all
structures with the pseudo-ﬁnite saturation property are stable, which means
that one cannot deﬁne inﬁnite linear orders in them. To deal with ordered
structures (which are the ones most typically used in applications), we
present a diﬀerent model-theoretic notion that implies ω-PFS.
5.7.3 Isolation and Collapse
Let M be a structure, let A be a subset of it, and let p be a 1-type over A.
Let p′ be a subset of p. We say that p′ isolates p if p is the only type over A
that contains p′.
Deﬁnition 5.7.7. We say that M has the isolation property if, for every
model M′ of the theory of M, any pseudo-ﬁnite set A in M′, and any element
a, there is a ﬁnite set A′ ⊆A such that tpM′(a/A′) isolates tpM′(a/A).
This gives us a number of new examples of structures that admit restricted
quantiﬁer collapse, thanks to the following proposition.
Proposition 5.7.8. If M has the isolation property, then it has ω-PFH (and
thus admits restricted quantiﬁer collapse).
Proof. Assume that we have an ω-saturated (M′, D1, D2, h), where D1, D2
are two pseudo-ﬁnite SC -structures, and h is elementary. Let a ∈M′. Let

5.7 Model Theory and Collapse Results
293
Ai = adom(Di); then A1, A2 are pseudo-ﬁnite sets. Let p = tpM′(a/A1); by
isolation, there is a ﬁnite set A′
1 ⊆A1 such that p′ = tpM′(a/A′
1) isolates p.
For each ϕ ∈p, let ϕh be ϕ in which every c ∈A1 is replaced by
h(c). Since h is elementary, any ﬁnite conjunction of formulae ϕh, ϕ ∈p,
is satisﬁable in M′, and thus, by compactness, h(p) = {ϕh | ϕ ∈p} is
consistent. Furthermore, a straightforward compactness argument shows
that h(p′) isolates h(p). Since A′
1 is ﬁnite, h(p′) is countable, and thus, by
saturation, it is realized by an element b ∈M′. Since h(p′) isolates h(p), b is
of type h(p), which shows that h ∪{(a, b)} is elementary.
2
As the simplest example of the isolation property, consider the theory
of linear order, whose models are ordered sets ⟨U, <⟩. Let M be such a
structure, and let A be a pseudo-ﬁnite set. For every a ∈U and every ﬁnite
set A0, either there are two consecutive elements of A0, say b < c, such that
(b, c) ∩A0 = ∅and b ≤a ≤c, or a > m, where m is the maximal element
of A0, or a < m′, where m′ is the minimal element of A0. As this condition
is FO-deﬁnable, it must be true for the pseudo-ﬁnite set A. We claim that
tpM(a/A) is isolated by tpM(a/A′), where A′ = {b, c}, or A′ = {m}, or
A′ = {m′}, depending on which of the three cases is true. We prove this for
the case of b ≤a ≤c; the other cases are similar.
To show that tpM(a/A′) isolates tpM(a/A), we must prove that for any
a′, (M, a, b, c) ≡(M, a′, b, c) implies (M′, a, (d)d∈A) ≡(M′, a′, (d)d∈A). This
is easy to see by an Ehrenfeucht–Fra¨ıss´e game argument. By the assumption,
the duplicator has a winning strategy on ([b, c], a) and ([b, c], a′). For the
winning strategy on (M′, a, (d)d∈A) and (M′, a′, (d)d∈A), the duplicator uses
the above strategy for moves in the interval [b, c], and copies the spoiler’s
moves elsewhere.
What about more complex examples? First, it is easy to extend the
example above to the case of ordered sets with some additional unary
relations. That is:
Corollary 5.7.9. Let M be a structure with one binary relation, interpreted
as a linear ordering, and ﬁnitely many unary relations. Then M admits
restricted quantiﬁer collapse.
2
As our next example, we revisit the theory of k successor relations, that
is, ⟨Σ∗, ε, (fa)a∈Σ⟩. This structure is the inﬁnite k-ary tree in which we have
only successor relations available. It is considered most often in the context of
monadic second-order logic, which can deﬁne the preﬁx relation in addition to
the successor relations. So we now consider an extension, ⟨Σ∗, ε, (fa)a∈Σ, ≺⟩,
where x ≺y means that x is a preﬁx of y. The question is: does this structure
admit the collapse?
The technique of Sect. 5.7.2 does not work here, since ⟨Σ∗, ε, (fa)a∈Σ, ≺⟩
does have the ﬁnite cover property: structures that do not have it cannot
deﬁne an inﬁnite linear order; on the other hand, it is easy to deﬁne the
lexicographic ordering in the presence of ≺. This turns out to be one of the
examples where isolation does the job.

294
5 Embedded Finite Models and Constraint Databases
Proposition 5.7.10. M = ⟨Σ∗, ε, (fa)a∈Σ, ≺⟩admits restricted quantiﬁer
collapse.
Proof. Let x ⪯y mean x ≺y or x = y. Let x ⊓y be the longest common
preﬁx of the strings x and y, and let x −y be deﬁned as follows: if x = y · z,
then x −y = z; if y ̸⪯x, then x −y = ε. Let L ⊆Σ∗be a star-free
language. Deﬁne PL to be the set of pairs of strings (x, y) such that y ⪯x and
x −y ∈L. It is not hard to show that PL is deﬁnable in ⟨Σ∗, ε, (fa)a∈Σ, ≺⟩
(using the fact that star-free languages are exactly those deﬁnable over
strings considered as ﬁnite models).
Before we prove the collapse, we must collect a few more properties of
M. The following is true for any ﬁnite (and hence pseudo-ﬁnite) set A in
any structure M′ elementarily equivalent to M. The meet of all elements of
A equals the meet of some pair of elements of A. Moreover, for any c ∈M′,
c ⊓A, the longest preﬁx of c that is also a preﬁx of some element of A, equals
c ⊓a for some a ∈A. Furthermore, there exist four not necessarily distinct
elements a1, a2, a3, a4 ∈A such that a1 ⊓a2 ⪯c ⊓A ⪯a3 ⊓a4, and there are
no a′, a′′ such that a1 ⊓a2 ≺a′ ⊓a′′ ≺a3 ⊓a4.
We shall use the following known result on deﬁnability in M. Every formula
ϕ(⃗x) is equivalent to a disjunction of the formulae αi(⃗x) ∧βi(⃗x) such that the
following is true. Each αi(⃗x) is a quantiﬁer-free formula that speciﬁes, for each
xi, xj, xk, xl, whether xi ⊓xj = ε and whether xi ⊓xj ≺xk ⊓xl. Each βi(⃗x)
is a conjunction of the formulae PL(xi ⊓xj, xk ⊓xl) where αi(⃗x) implies that
there are no elements of the form xp ⊓xq such that xi ⊓xj ≺xp ⊓xq ≺xk ⊓xl.
We now show that M has the isolation property, and thus admits restricted
quantiﬁer collapse. Let M′ be elementarily equivalent to M, let A be a pseudo-
ﬁnite set, and let c ∈M′. Find (at most) four elements a1, a2, a3, a4 ∈A
such that a1 ⊓a2 ⪯c ⊓A ⪯a3 ⊓a4, and there are no a′, a′′ such that
a1 ⊓a2 ≺a′ ⊓a′′ ≺a3 ⊓a4. Then the above result characterizing deﬁnability
in M easily implies that tpM′(c/{a1, a2, a3, a4}) isolates tpM(c/A).
2
The notion of isolation could just as well be called ω-isolation: a type
over a set is isolated by a type of a subset of cardinality < ω. We could then
introduce a notion of λ-isolation for any cardinal λ. The cardinal λ of interest
to us here is ω1; the notion of ω1-isolation says that tpM(a/A), for A pseudo-
ﬁnite, is isolated by tpM(a/A′), where A′ ⊆A is ﬁnite or countable. Just
as ω-isolation implies ω-PFH and restricted quantiﬁer collapse, ω1-isolation
implies ω1-PFH, and thus the same collapse. We shall now use ω1-isolation to
give an alternative proof of restricted quantiﬁer collapse for Z = ⟨Z, +, <⟩. We
already know this result: Proposition 5.6.10 showed natural-active collapse
for Z0, which is an expansion of Z that has quantiﬁer elimination. But we
provide the proof below to illustrate the power of model-theoretic techniques.
Proposition 5.7.11. Z admits restricted quantiﬁer collapse.
Proof. Let M be a model of Th(Z), and A a pseudo-ﬁnite set in M. Since A is
pseudo-ﬁnite, for any a, either there exist a1 < a2 ∈A such that a1 ≤a ≤a2
and (a1, a2) ∩A = ∅, or a > m, where m is the maximal element of A, or

5.8 The VC Dimension and Collapse Results
295
a < m′, where m′ is the minimal element of A. We assume, without loss of
generality, that we are dealing with the ﬁrst case.
Let f(⃗y) be a linear function with integer coeﬃcients. For any ﬁnite set
A and an element a, we have a uniquely deﬁned tuple ⃗bA,f
−
of elements of
A such that f(⃗bA,f
−) ≤a, and for any other tuple ⃗c of elements of A, either
f(⃗c) > a, or f(⃗c) < f(⃗bA,f
−), or f(⃗c) = f(⃗bA,f
−) and ⃗c is above ⃗bA,f
−
in the
lexicographic ordering. In other words, ⃗bA,f
−
is the lexicographically smallest
tuple of elements of A on which f reaches its maximum value which does not
exceed a. Since the above can be stated in FO, such a tuple ⃗bA,f
−
is uniquely
determined for a pseudo-ﬁnite set A.
Similarly, we deﬁne ⃗bA,f
+
to be the lexicographically smallest tuple of
elements of A on which f reaches its minimum value which lies above a.
Again, this is well deﬁned for a pseudo-ﬁnite set A.
We now let A′ be the set that has a1, a2 and all the components of all
⃗bA,f
−
and ⃗bA,f
+
as f ranges over all linear functions with integer coeﬃcients.
Since such tuples are unique for each f, the set A′ is countable. We claim
that tpZ(a/A′) isolates tpZ(a/A).
For
this
purpose,
it
is
convenient
to
use
Z0,
the
expansion
of
Z
with
∼k, k
>
1,
which
admits
quantiﬁer
elimination.
Suppose
tpZ(a/A′)
=
tpZ(a′/A′); it then suﬃces to show that the Z0-atomic
types of a and a′ over A are the same. As tpZ(a/A′) speciﬁes all a −a1 ∼k nk
and a2 −a ∼k n′
k relations for all k > 1, and all constants a1, a2 ∈A′, a
and a′ agree on all the formulae f(x, ⃗y) −g(x, ⃗y) ∼k nk, where f, g are linear
functions, ⃗y takes values in A, and 0 ≤nk < k. By quantiﬁer elimination
for Z0, we may assume that other atomic formulae are of the form xϑf(⃗y),
where f is a linear function with integer coeﬃcients, and ϑ is one of <, >, =.
Suppose that a > f(⃗b) holds for some ⃗b over A. Then either f(⃗b) < f(⃗bA,f
−),
or f(⃗b) = f(⃗bA,f
−) and ⃗bA,f
−
is lexicographically smaller than ⃗b. Since all the
components of ⃗bA,f
−
are in A′ and the types of a and a′ over A′ are the same,
we conclude that a′ > f(⃗bA,f
−) and thus a′ > f(⃗b). The cases in which ϑ is >
or = are similar. Hence, tpZ0(a/A) = tpZ0(a′/A), which proves ω1-isolation. 2
In conclusion, we remark that the techniques of the two previous subsec-
tions – using the ﬁnite cover property or isolation to prove the collapse – are
completely disjoint. While every structure that does not have the ﬁnite cover
property is stable, every structure with the isolation property is unstable; in
particular, one can deﬁne an inﬁnite linear order on such a structure.
5.8 The VC Dimension and Collapse Results
In this section we consider the relationship between the Vapnik-Chervonenkis
dimension, a concept from statistics and learning theory, and collapse results.
We have seen one powerful result (Theorem 5.6.13): any structure whose

296
5 Embedded Finite Models and Constraint Databases
deﬁnable families have ﬁnite VC dimension admits natural-generic collapse.
It turns out that the VC dimension is even more closely related to collapse
results: namely,
natural-
active
collapse
⇒
restricted
quantiﬁer
collapse
⇒
ﬁnite
VC dimension
⇒
natural-
generic
collapse
as the result below demonstrates.
Theorem 5.8.1. Let M admit restricted quantiﬁer collapse. Then M-
deﬁnable families have ﬁnite VC dimension.
Proof. In this proof, we shall use a complexity class AC0/poly deﬁned as
follows. (We use a slightly nonstandard deﬁnition, in terms of FO-formulae
rather than circuits, as it is more convenient for our purposes.) Consider a
class of ﬁnite SC-structures C, and assume that adom(D) of size n is always
of the form {0, . . . , n −1}. Such a class belongs to AC0/poly if there exists a
vocabulary SC ′ disjoint from SC, a function h from N to SC ′-structures, and
a sentence ΦC of FO(SC ∪SC ′) such that (a) adom(h(n)) ⊆{0, . . . , n −1},
and (b) for each SC-structure of size n, we have D ∈C iﬀ(D, h(n)) |= ΦC.
In other words, we use ΦC to decide whether D ∈C, and ΦC uses D as well
as some polynomial-size “advice” h(n). Some strong lower bounds have been
proved for AC0/poly; they imply, for example, that parity, and importantly
for us, 3-colorability, are not in AC0/poly.
Now assume that M admits restricted quantiﬁer collapse and has inﬁnite
VC dimension. We obtain a contradiction by showing that 3-colorability is in
AC0/poly.
To proceed, we need the following known (and nontrivial) result: if M has
inﬁnite VC dimension, then there is a formula ϕ(⃗x, y) (where y is a single vari-
able) that deﬁnes a family of inﬁnite VC dimension. Take this formula ϕ; then,
for each n, there is a set Yn ⊂M of size n that is shattered by {ϕ(⃗a, M) | ⃗a}.
Now expand the language of M with a binary relation E (to be interpreted
as a ﬁnite graph), and consider the sentence Ψ:
∃⃗x1∃⃗x2∃⃗x3
)
∀y∈adom
⎛
⎝
(ϕ(⃗x1, y) ∧¬ϕ(⃗x2, y) ∧¬ϕ(⃗x3, y))
∨(¬ϕ(⃗x1, y) ∧ϕ(⃗x2, y) ∧¬ϕ(⃗x3, y))
∨(¬ϕ(⃗x1, y) ∧ϕ(⃗x2, y) ∧ϕ(⃗x3, y))
⎞
⎠
∧
∀y1 ∈adom∀y2 ∈adom E(y1, y2) →¬
⎛
⎝
(ϕ(⃗x1, y1) ∧ϕ(⃗x1, y2))
∨(ϕ(⃗x2, y1) ∧ϕ(⃗x2, y2))
∨(ϕ(⃗x3, y1) ∧ϕ(⃗x3, y2))
⎞
⎠
*
.
The fact that ϕ deﬁnes a family that shatters each Yn lets us model second-
order quantiﬁers over Yn; in particular, for any graph G with adom(G) ⊆Yn,
G |= Ψ iﬀG is 3-colorable.

5.8 The VC Dimension and Collapse Results
297
Since M admits restricted quantiﬁer collapse, we may assume that Ψ is
equivalent to a sentence Ψ ′ of the form
Qz1 ∈adom . . . Qzm∈adom α(⃗z),
where α is a Boolean combination of formulae E(zi, zj) and formulae βl(⃗z),
l ≤k, over M.
For each βl which has p free variables, introduce a new p-ary relation
symbol Rl. Let SC ′ = {Rl | l ≤k}. Next, for each n, ﬁx a bijection
πn : {0, . . ., n −1} →Yn. Let h(n) be an SC ′-structure on {0, . . ., n −1} in
which a tuple (a1, . . . , ap) belongs to Rl iﬀβl(πn(a1), . . . , πn(ap)) holds in M.
Finally, let Ψ ′′ be Ψ ′ in which every subformula βl(⃗u) is replaced by Rl(⃗u). We
then conclude that, for any graph G on nodes {0, . . ., n −1}, (G, h(n)) |= Ψ ′′
iﬀG is 3-colorable, which contradicts the fact that 3-colorability is not in
AC0/poly. This proves the theorem.
2
A natural question, then, is the following: what kind of bounds on
FO(SC, M) can one show for structures M of inﬁnite VC dimension? Clearly
we cannot hope to prove natural-active or restricted quantiﬁer collapse; but
is it possible to prove some meaningful bounds, and if so, how?
While our understanding of the limits of collapse results is by no means
complete, in the list below we shall give three examples of very diﬀerent
behaviors of FO over ﬁnite models embedded into structures with inﬁnite
VC dimension.
•
In some cases, there is no collapse at all. We have seen that any computable
query over ﬁnite SC-structures can be expressed in FO(SC, N), and N has
inﬁnite VC dimension. (To see this directly, assume as we did before that
a set X = {x1, . . . , xk} with x1 < . . . < xk is coded by 2x1 · 3x2 · . . . · pxk
k
where pk is the kth prime. Let ϕ(x, y) say that y is in the set coded by x.
Then the family {ϕ(n, N) | n ∈N} has inﬁnite VC dimension.)
•
In another example, we get a collapse to a logic which is more pow-
erful than FO. Namely, we shall show in Section 5.8.1 that, over the
random graph RG, FO(SC , RG) collapses to active MSO, that is,
MSOact(SC , RG). Recall that MSO (monadic second-order logic) extends
FO with quantiﬁcation over sets. In the active version MSOact, this set
quantiﬁcation is over subsets of adom(D).
•
In the last example, we do not know whether natural-generic collapse
can be proved. Nevertheless, we succeed in showing that generic queries
can be evaluated in AC0. As AC0 is one of very few complexity classes
for which lower bounds have been proved, this suﬃces to conclude that
queries such as parity are not expressible. The structure for which this
result is proved (in Section 5.8.2), extends ⟨Σ∗, fa, ≺⟩from the previous
section by adding string length comparisons.

298
5 Embedded Finite Models and Constraint Databases
5.8.1 Random Graph and Collapse to MSO
In this section, we give an example of a nicely behaved structure, with a decid-
able theory and quantiﬁer elimination, that does not admit natural-active
collapse. This structure, however, admits a collapse to monadic second-order
logic.
This structure is the random graph RG = ⟨U, E⟩on a countably inﬁnite
set U: that is, any model that satisﬁes every sentence that is true in almost all
ﬁnite undirected graphs. Here “almost all” is with respect to the uniform prob-
ability distribution: E(a, b) holds with probability 1/2, independently for each
pair (a, b). It is known that the set of all such sentences forms a complete the-
ory with inﬁnite models, and that this theory is decidable and ω-categorical.
The latter means that up to isomorphism, there is only one countable model.
Other, nonprobabilistic descriptions of RG exist. For example, let U =
{u0, u1, . . .}, and deﬁne E as follows: (ui, uj) ∈E iﬀeither the ith bit of the
binary representation of j or the jth bit of the binary representation of i is 1.
The random graph satisﬁes the following extension axioms, for each n > 0:
∀x1, . . . , xn
	
i̸=j
xi ̸= xj →

	
M⊆{1,...,n}
∃z ̸∈⃗x
 	
i∈M
E(z, xi)∧
	
j̸∈M
¬E(z, xj)

In other words, let T be a ﬁnite subset of U and S ⊆T . Then the extension
axioms say that there exists a z ̸∈T such that for all x ∈S, (z, x) ∈E,
and for all x ∈T −S, (z, x) ̸∈E. It is immediately clear from the extension
axioms that RG has inﬁnite VC dimension; in fact, the family deﬁnable by
the formula E(x, y) shatters arbitrarily large ﬁnite sets.
Recall that MSO is a restriction of second-order logic in which second-
order variables range over sets. In the active-domain fragment of MSO, they
range over subsets of adom(D).
Theorem 5.8.2. FO(SC, RG) = MSOact(SC , RG).
Proof. The idea is to use the extension axioms to model MSO queries.
Consider an MSOact formula
ϕ(⃗x) ≡QX1 ⊆adom . . . QXm ⊆adom Qy1 ∈adom . . . Qyn ∈adom α( ⃗X, ⃗x, ⃗y),
where the Xis are second-order variables, the yjs are ﬁrst-order variables, and
α is a Boolean combination of SC- and RG-formulae in variables ⃗x, ⃗y, and
formulae Xi(xj) and Xi(yj). Construct a new FO(SC , RG) formula ϕ′(⃗x) by
replacing each QXi ⊆adom with Qzi ̸∈adom ∪⃗x (which is FO-deﬁnable),
and changing every atomic subformula Xi(u) to E(zi, u). It is then easy to
see, from the extension axioms, that ϕ′ is equivalent to ϕ.
For the other direction, we proceed by induction on the formulae. The only
nontrivial case is that of unrestricted existential quantiﬁcation. Suppose we
have an MSOact(SC , RG) formula ϕ(⃗x, z), with ⃗x = (x1, . . . , xn), of the form

5.8 The VC Dimension and Collapse Results
299
Q ⃗X ⊆adom Q⃗y∈adom α( ⃗X, ⃗x, ⃗y, z),
where α again is a Boolean combination of atomic SC- and RG-formulae, as
well as formulae Xi(u), where u is one of the ﬁrst-order variables z, ⃗x, ⃗y. We
want to ﬁnd an MSOact formula equivalent to ∃z ϕ.
Such a formula is a disjunction of ∃z ∈adom ϕ ∨

i ϕ(⃗x, xi) ∨∃z ̸∈
adom ϕ. The former is an MSOact(SC, RG) formula. To eliminate z from the
latter, all we have to know about z is its connections to ⃗x and to the active
domain in the random graph; the former is taken care of by a disjunction
listing all subsets of {1, . . . , n}, and the latter by a second-order quantiﬁer
over the active domain. For I ⊆{1, . . . , n}, let χI(⃗x) be a quantiﬁer-free
formula saying that no xi, xj, with i ∈I, j ̸∈I, could be equal. Introduce a
new second-order variable Z and deﬁne an MSOact formula ψ(⃗x) as
∃Z ⊆adom

I⊆{1,...,n}

χI(⃗x) ∧Q ⃗X ⊆adom Q⃗y∈adom αZ
I ( ⃗X, Z, ⃗x, ⃗y)

,
where αZ
I ( ⃗X, Z, ⃗x, ⃗y) is obtained from α by:
1. replacing each E(z, xi) by true for i ∈I and false for i ̸∈I,
2. replacing each E(z, yj) by Z(yj), and
3. replacing each Xi(z) by false.
The extension axioms then ensure that ψ is equivalent to ∃z ̸∈adom ϕ.
2
Thus, RG provides an example of a structure with quantiﬁer elimination
and a decidable ﬁrst-order theory that does not admit natural-active collapse.
At the same time, one can establish meaningful bounds on the expressiveness
of queries over RG: for example, each generic query in FO(SC, RG) is in
MSOact(SC). (This does not immediately follow from the active-generic
collapse, as we do not include any order relation. One can show that the
order is not needed, by modifying the proof of Lemma 5.5.4 using some
special properties of RG.) Thus, every generic query in FO(SC , RG) can be
evaluated in PSPACE (in fact, even in the polynomial hierarchy).
5.8.2 Complexity Bounds for Generic Queries
We now revisit the structure ⟨Σ∗, (fa)a∈Σ, ≺⟩considered in Sect. 5.7.3.
Recall that Σ here is a ﬁnite alphabet, Σ∗is the set of all ﬁnite strings over
Σ, fa is a function that adds a at the end of its argument, and ≺is the preﬁx
relation. We now extend it to a structure S = ⟨Σ∗, (fa)a∈Σ, ≺, el⟩, which
adds a binary predicate el, interpreted as follows: el(x, y) iﬀ|x| = |y|, where
| | stands for the length of a ﬁnite string.
Despite looking rather arbitrary, this structure arises naturally in the
study of logical properties of formal languages, and has a number of nice
properties. For example, the subsets of Σ∗deﬁnable in S are precisely

300
5 Embedded Finite Models and Constraint Databases
the regular languages. Moreover, in a certain sense, S is the most general
structure whose deﬁnable relations are precisely tuples of strings accepted
by ﬁnite automata. That is, any other structure on Σ∗whose deﬁnable
relations are tuples accepted by ﬁnite automata can be interpreted in S.
The characterization of deﬁnable relations via automata also implies the
decidability of the theory of S.
Using the isolation property, we have proved restricted quantiﬁer collapse
for ⟨Σ∗, (fa)a∈Σ, ≺⟩. However, it is impossible to prove the collapse for S
as its deﬁnable families may have inﬁnite VC dimension. To see this, let
Σ = {a, b}, and consider a formula ϕ(x, y) saying that there is a preﬁx of x
that has the same length as y and ends with an a:
∃z∃v

z ⪯x ∧el(z, y) ∧fa(v) = z

For each n, let An = {bi | i ≤n}, and let A be an arbitrary subset of An. Let
sA be a string of length n whose ith position is a iﬀbi ∈A. Then, for each
i ≤n, ϕ(sA, bi) holds iﬀbi ∈A. This shows that arbitrarily large ﬁnite sets
can be shattered by families deﬁnable in S.
This still leaves open the possibility of proving natural-generic collapse
for S; however, we do not know if it holds in S. Nevertheless, we can prove
reasonably good bounds for FO(SC , S). For this, we need the complexity
class AC0/poly used in Theorem 5.8.1. As this class is a very modest
extension of FOact(SC, <), some good bounds can be derived.
Proposition 5.8.3. Every generic query in FO(SC, S) can be evaluated in
AC0/poly. In particular, queries such as parity and connectivity are not
expressible in FO(SC , S).
Proof sketch. First, we explain the complexity model used here, which is
applicable to the evaluation of generic queries. Given an SC-structure D
with |adom(D)| = n, we code elements of the active domain by the numbers
0, . . . , n −1 represented in binary, and then code tuples and relations in a
standard fashion, using special delimiter characters. Using this coding, we
show that every generic sentence Φ can be evaluated in AC0/poly. This is
done in three steps:
1. First, we show that it suﬃces to restrict quantiﬁcation to strings of length
at most mD, where mD = max{|x| | x ∈adom(D)}. This is proved by
an Ehrenfeucht–Fra¨ıss´e game argument. More precisely, one shows the
following. Let Σ≤m = {x ∈Σ∗| |x| ≤m}. Then, for each SC , there is a
ﬁxed constant lSC such that if the duplicator can win in k+lSC rounds on
the restrictions of (S, D1) and (S, D2) to (Σ≤mD1 , D1) and (Σ≤mD1, D2),
then the duplicator can win in k rounds on (S, D1) and (S, D2).
2. Second, we deﬁne an ordering < on Σ∗: x < y if either |x| < |y|, or |x| = |y|
and x is lexicographically less than y. Viewing Σ∗as an inﬁnite tree, this
amounts to traversing it, level by level, from left to right. Now, by generic-
ity, we may assume that adom(D) is an initial segment of this ordering <.

5.9 Expressiveness of Constraint Query Languages
301
3. Finally, we deﬁne an advice function f that, for each n, codes all the
relations of S on the ﬁrst n′ elements of Σ∗in the order <. Here n′ is the
number of all strings of length at most m, where m is the length of the nth
string in the <-order. For a given SC-structure D with |adom(D)| = n,
f codes all the relations of S on Σ≤mD. Assuming that adom(D) is an
initial segment of <, we conclude that the size of f(n) is polynomial in n.
By step 1, we know that quantiﬁcation over Σ≤mD suﬃces. As f(n)
provides all the information about S on Σ≤mD, we conclude that
with f, a generic query can be expressed in FO, and thus it belongs
to AC0/poly.
2
5.9 Expressiveness of Constraint Query Languages
In this section, we return to constraint databases and study the expressive
power of standard query languages such as FO + Lin and FO + Poly. We
shall deal mostly with the fundamental topological property of connectivity,
which is also important in many applications of constraint databases as
spatial databases. That is, we deal with the following problem:
Problem: CONNECTIVITY
Input:
an M-deﬁnable set S ⊆Rk.
Output: true if S is topologically connected, and false otherwise.
The question is whether CONNECTIVITY is deﬁnable in FO(SC, M),
where SC consists of just S. We shall deal mostly with the cases where M
is the real ﬁeld or the real ordered group (and thus S is semialgebraic or
semilinear); then, by deﬁnability, we mean deﬁnability in FO + Poly and
FO + Lin. We remarked in Section 5.3 that the problem looks akin to the
problem of ﬁnite graph connectivity, simply because any ﬁnite graph can be
embedded into R3 without self-intersections, and the result of the embedding
is topologically connected iﬀthe original graph is connected. At that point, we
did not know whether FO + Poly and FO + Lin deﬁne graph connectivity.
Now we know that they do not. However, we shall choose a diﬀerent and
less ad hoc way to proceed, as the results we present here give us more than
nondeﬁnability of connectivity, and can be used for dimensions 1 and 2 as well.
In the next section, we shall see a reduction from topological connectivity
to a deﬁnability problem for embedded ﬁnite models. In Sect. 5.9.2 we present
a diﬀerent technique, based on the topological structure of deﬁnable sets. In
Sect. 5.9.3, we study queries that separate FO + Poly from FO + Lin.
5.9.1 Reductions to the Finite Case
Recall that MAJORITY is the following problem: “given two ﬁnite sets A
and B, is card(A) > card(B)?” We now prove the following.

302
5 Embedded Finite Models and Constraint Databases
Proposition 5.9.1. Assume that FO + Poly can deﬁne CONNECTIVITY
when the input is restricted to semilinear sets. Then FO + Poly can deﬁne
MAJORITY.
Proof. Suppose we are given two ﬁnite sets A and B. Assume, without loss
of generality, that a, b > 0 for all a ∈A and b ∈B (if not, add maxa∈A |a| + 1
to all elements of A, and likewise for B; this can be deﬁned in FO + Lin).
Let A = {a1, . . . , an} and B = {b1, . . . , bm}, where a1 < . . . < an and
b1 < . . . < bm. This is shown in Fig. 5.6 for n = 6 and m = 4.
Let C = B ∪{0}. Assume that C = {c1, . . . , cm+1}, where c1 = 0, and
ci = bi−1 for 1 < i ≤m + 1. For each 1 ≤i < n and 1 ≤j < m + 1, deﬁne
a semilinear set Xij in R2 as the union of the following ﬁve sets:
X1
ij = {(x, y) | y = ai, cj ≤x ≤(2cj + cj+1)/3}
X2
ij = {(x, y) | x = (2cj + cj+1)/3, ai ≤y ≤(ai + ai+1)/2}
X3
ij = {(x, y) | y = (ai + ai+1)/2, (2cj + cj+1)/3 ≤x ≤(cj + 2cj+1)/3}
X4
ij = {(x, y) | x = (cj + 2cj+1)/3, (ai + ai+1)/2 ≤y ≤ai+1}
X5
ij = {(x, y) | y = ai+1, (cj + 2cj+1)/3 ≤x ≤cj+1}.
This is shown in the right picture in Fig. 5.6: the ﬁve sets correspond to the
ﬁve segments of the thick line. We then deﬁne a set X as
{(x, 0) | a1 ≤x ≤an} ∪{(x, an) | a1 ≤x ≤an} ∪
n−1

i=1
m

j=1
Xij.
This set is shown in the left picture in Fig. 5.6 (in fact, we show the
lines as straight, but it should be kept in mind that in every rectangle
[cj, cj+1] × [ai, ai+1] they are given by Xij).
We next observe that X is deﬁnable in FO + Lin from A and B. Indeed,
C is deﬁnable, and then every Xij is deﬁnable, as follows from its deﬁnition.
(The main reason for going from (cj, ai) to (cj+1, ai+1) by “steps” rather
than a straight line was to achieve deﬁnability in FO + Lin.) Secondly,
card(B) ≥card(A) iﬀthe set X is connected – this is because the “line”
from (0, 0) reaches the ceiling iﬀcard(B) ≥card(A). Thus, X is connected
iﬀMAJORITY is false on A and B, which completes the proof.
2
b1
b2
b3
b4
a1
a2
a3
a4
a5
a6
cj
ai
cj+1
ai+1
Fig. 5.6. Illustration of the proof of Proposition 5.9.1

5.9 Expressiveness of Constraint Query Languages
303
We immediately derive the following corollary from this result and the
fact that FO + Lin suﬃces to construct X from A and B:
Corollary 5.9.2. Neither FO + Lin nor FO + Poly can deﬁne CONNEC-
TIVITY. Furthermore, CONNECTIVITY is not deﬁnable in FO({S}, M)
if M is an o-minimal expansion of the real ﬁeld R.
The reduction technique is not limited to the CONNECTIVITY prob-
lem. We invite the reader to draw simple pictures that give similar reductions
for problems such as homeomorphism of two 2-dimensional sets, the existence
of exactly one (or at most one, or at least one) hole, or being simply connected.
5.9.2 Topological Properties
In this section, we give a diﬀerent proof that topological connectivity is
not deﬁnable in FO + Poly. The proof relies on topological properties of
semialgebraic sets, and on a criterion for indistinguishability of two sets in
R2 by certain FO + Poly queries.
Note that connectivity is a query about topological properties of its
input. Formally, a Boolean query Q on sets in Rk is called topological if it
is invariant under homeomorphisms: for any homeomorphism h : Rk →Rk
and any S ⊆Rk, Q(S) is true iﬀQ(h(S)) is true.
Some examples of
topological queries are connectivity, having exactly one hole, and having
exactly k connected components. Some examples of nontopological queries
are properties such as “being a line”, “containing the origin” etc.
It turns out that the expressive power of FO + Poly with respect to
topological queries on R2 can be nicely characterized. The characterization is
based on the fact that every semialgebraic set S is locally conic around any
point. This is illustrated in Fig. 5.7: there is a small neighborhood of a point
⃗x such that the intersection of this neighborhood with the set S is isotopic
to the cone with center at ⃗x and the base that is the intersection of S with
the boundary of the neighborhood.
More precisely, let Bε(⃗x) be {⃗y
∈R2
| ∥⃗y −⃗x ∥≤ε} and let
B◦
ε(⃗x) = {⃗y ∈R2 | ∥⃗y −⃗x ∥= ε}. Then, for each semialgebraic set S and
⃗x ∈R2, there is ε > 0 such that S∩Bε(⃗x) is isotopic to the cone with the center
at ⃗x and the base B◦
ε(⃗x)∩S. Furthermore, for any ε′ < ε, Bε′(⃗x)∩S is isotopic
to the same cone, so we can talk about the topological type of a cone of S
around ⃗x. We shall use tpS(⃗x) to denote the topological type of such a cone.
Fig. 5.7. Cones

304
5 Embedded Finite Models and Constraint Databases
.
Fig. 5.8. Four cone types
There are four cone types that are of special interest: the full cone, the
half-cone, the line, and the empty cone, shown in Figure 5.8. The ﬁrst is the
cone type of a point in the interior of a set S. The second is the cone type of
a point on the boundary of a two-dimensional region. The third is the type of
a point in a one-dimensional segment of S. And the last one is the type of a
point outside S, or of an isolated point of S. It turns out that for any closed
semialgebraic set S ⊆R2, these are the only cone types that can be realized by
inﬁnitely many points – all other cone types have only ﬁnitely many realizers.
We write S ∼tp S′ if, for every topological type T of a cone,
card({x ∈S | tpS(x) = T })
=
card({x ∈S′ | tpS′(x) = T }).
Note that this condition is somewhat reminiscent of that for Hanf-locality,
which says that each local neighborhood must have equally many realizers in
two structures.
Cone types characterize the expressive power of FO + Poly with respect
to topological queries as follows.
Theorem 5.9.3. Let Q be a topological FO + Poly query over a schema with
one binary relation, and let S ∼tp S′, where S, S′ are closed semialgebraic
sets in R2. Then Q(S) is true iﬀQ(S′) is true.
The proof of this result is rather involved. The main idea is as follows. It is
possible to deﬁne a set of elementary transformations on closed semialgebraic
subsets of R2 such that these transformations preserve elementary equivalence
with respect to topological FO + Poly sentences, and such that every two sets
satisfying S ∼tp S′ can be transformed to the same subset of R2.
Another Proof That Connectivity Is Not in FO + Poly
Suppose that connectivity is tested by a (topological) FO + Poly query Q.
Consider S1 and S2, shown in Fig. 5.9: S1 is a disk, and S2 is a disjoint union
of two disks. Both S1 and S2 realize the same cone types (the full, the half,
and the empty cones), and both have inﬁnitely many realizers for each of
these types. Thus, S1 ∼tp S2, and by Theorem 5.9.3 we must have Q(S1) iﬀ
Q(S2). Thus, Q cannot deﬁne connectivity, as S1 is connected and S2 is not.
It is natural to ask whether Theorem 5.9.3 can be extended to schemas
with two or more relation symbols; in particular, to topological queries over
multiple regions on the plane. It turns out that the answer is negative.

5.9 Expressiveness of Constraint Query Languages
305
S1
S2
Fig. 5.9. Proving that connectivity is not in FO + Poly
Suppose that we have two relation symbols, S and T , and assume that S
is interpreted as an area shown in light gray, and T as an area shown in dark
gray. Fig. 5.10 gives two instances of (S, T ): in instance I1, on the left, T lies
inside S, and in instance I2, on the right, S lies inside T .
We can see that I1 ∼tp I2, as both instances realize the same cone types. At
the same time, I1 and I2 can be separated by a topological FO + Poly query.
The latter statement is by no means trivial. An obvious way to separate I1
from I2 would be to say: “traversing any line from −∞to +∞, we ﬁrst enter S
and then T ”. However, it is easy to show that this property, while expressible
in FO + Poly, is not topological. Nevertheless, a rather complicated construc-
tion yields a topological FO + Poly query that separates I1 from I2.
5.9.3 Linear vs. Polynomial Constraints
All expressivity bounds proved so far, in the ﬁnite and inﬁnite contexts,
apply to both FO + Lin and FO + Poly. In this section we show a few
queries that separate the two. As R and Rlin share many model-theoretic
properties, in particular most of the properties that were crucial for proving
collapse results, new techniques are needed to separate them.
Most separation results are based on the simple observation that mul-
tiplication is not deﬁnable in Rlin (indeed, by quantiﬁer elimination, every
Rlin-deﬁnable function is piecewise linear). To show that an FO + Poly
query Q is not expressible in FO + Lin, we then prove that adding Q to
FO + Lin would enable us to deﬁne multiplication.
We start with two examples, which can be stated for either ﬁnite or
semilinear sets. For both queries, the input is a set S ⊆R2. The queries are:
Fig. 5.10. Topological equivalence for multiple regions

306
5 Embedded Finite Models and Constraint Databases
•
conv(S), which returns the convex hull of S, and
•
collinear(S), which returns the set of triples s1, s2, s3 ∈S (that is, a
subset of R6) which are collinear.
We have already seen that conv(·) is an FO + Poly query. collinear(·) is
expressible in FO + Poly as well, as FO + Poly can test whether any three
given points (x1, y1), (x2, y2), (x3, y3), are collinear.
Proposition 5.9.4. Neither conv nor collinear is expressible in FO + Lin,
even if its argument is a ﬁnite set.
Proof sketch. The main idea is illustrated in Figure 5.11. Assume that
collinear is deﬁnable in FO + Lin. Suppose we are given four distinct points
u, v, w, s in R2. Then, in FO + Lin, we can test whether the lines l(u, v) and
l(w, s), passing through u, v and w, s respectively, are parallel. Indeed, such
lines are not parallel iﬀthere is a point p such that both collinear(u, v, p) and
collinear(w, s, p) hold (Fig. 5.11 (b)).
However, testing whether two lines are parallel is suﬃcient to deﬁne
multiplication, as shown in Fig. 5.11 (a). If the lines passing through (0, 1)
and (x, 0), and through (0, y) and (z, 0) are parallel, then z = x · y. Thus,
collinear is not an FO + Lin query.
Finally, conv is not expressible, since three distinct points are collinear iﬀ
one of them is in the convex hull of two others.
2
Note that the query convex(S), testing whether an n-dimensional
semilinear set S ⊆Rn is convex, can be deﬁned in FO + Lin, as S is
convex iﬀfor every two points (x1, . . . , xn), (y1, . . . , yn) ∈S, the point
( 1
2(x1 + y1), . . . , 1
2(xn + yn)) is in S. Another positive expressibility result is
obtained for testing whether a semilinear set S ⊆R2 is a line, since S is a
line if either it is a vertical line or it is the graph of a function, and for any
⃗x, ⃗y,⃗z ∈S, ⃗x + (⃗y −⃗z) ∈S. All these conditions are FO + Lin-expressible.
(a)
(b)
x
z
y
1
u
v
w
s
p
Fig. 5.11. Inexpressibility of conv and collinear in FO + Lin

5.10 Query Safety
307
We now consider one more example: the query ExistsLine(S) is true iﬀ
the set S ⊆R2 contains the graph of a line, i.e. {(x, y) | ax + b = y} for some
a, b ∈R. Along the same lines as the proof of Proposition 5.9.4, we can show
that ExistsLine is not deﬁnable in FO + Lin. Let u, w ≥0 and v > 1, and
consider the set Su,v,w ⊆R2 deﬁned as follows:
Su,v,w
=
⎧
⎪
⎪
⎨
⎪
⎪
⎩
(x, y)








x ≤0, y ≤0
or 0 ≤x ≤1, 0 ≤y ≤v
or 1 ≤x ≤u, v ≤y
or u ≤x, w ≤y.
⎫
⎪
⎪
⎬
⎪
⎪
⎭
.
This set is shown in Fig. 5.12. It is easy to see that ExistsLine(Su,v,w) is
true iﬀw ≤u · v; thus, in FO + Lin + ExistsLine one can deﬁne, for example,
the set {(x, y) | y = x2, x > 1}, which is clearly not FO + Lin-deﬁnable.
Hence, ExistsLine is not an FO + Lin query.
However, not all results separating FO + Lin and FO + Poly are so
simple. Consider the following FO + Poly query ψ(x1, x2, y1, y2):
∀λ

(0 ≤λ ≤1) →S(λ · x1 + (1 −λ) · x2,
λ · y1 + (1 −λ) · y2)

,
which says that the segment between (x1, y1) and (x2, y2) is contained in S ⊆
R2. By the same method as the one we used for ExistsLine, one can show that
this is not an FO + Lin query. But now consider a slight modiﬁcation of this
query: suppose we want to know whether the segment connecting two points
on the boundary of a set S lies entirely in S. It turns out that this query is
inexpressible in FO + Lin; the proof of this fact, however, is far from obvious.
5.10 Query Safety
In the previous sections, we worked with two diﬀerent kinds of objects: arbi-
trary FO(SC, M) formulae (for which we proved results such as natural-active
collapse) and queries deﬁnable in FO(SC, M) (for which we proved results
1
v
u
u*v
1
v
u
u*v
w
w
Fig. 5.12. Proving that “contains a line” is not in FO + Lin

308
5 Embedded Finite Models and Constraint Databases
such as the active-generic collapse). Queries, unlike arbitrary formulae, are
required to have certain closure properties: they return ﬁnite outputs on
embedded ﬁnite models.
This notion of closure is well known in classical relational database theory
under the name of safety: one is often interested in looking at only those
formulae in FOact(SC) that return ﬁnite results. For example, assuming
an inﬁnite domain U and one relation S, the formula ¬S(x) produces the
inﬁnite set U −adom(D). It is known that for FOact(SC), one can identify
a recursive subset of safe formulae; that is, the set of formulae that always
return ﬁnite results on ﬁnite SC -structures, and such that every formula
with this property is equivalent to one from this set.
In this section we consider the problem of safety in the context of embed-
ded ﬁnite models and constraint databases. For the former, we encounter a
familiar situation, where the behavior of formulae depends greatly on the
properties of the underlying structures. For some structures, most notably
Rlin and R (linear and polynomial constraints), we can give a nice syntactic
characterization. The safety problem also arises in the context of constraint
databases. Although the ﬂavor is quite diﬀerent, we shall show that it reduces
to the ﬁnite safety problem.
5.10.1 Finite and Inﬁnite Query Safety
Recall that the output of an FO(SC, M) formula ϕ(x1, . . . , xn) on a ﬁnite
SC-structure D is ϕ(D)
def
= {⃗a ∈U n | D |= ϕ(⃗a)}.
Deﬁnition 5.10.1. An FO(SC, M) formula ϕ(⃗x) is safe on a ﬁnite SC-
structure D if ϕ(D) is ﬁnite. A formula is safe if it is safe on every ﬁnite
structure.
We now deﬁne the following problems:
Problem: SAFETY
Input:
an FO(SC , M) formula ϕ(⃗x).
Output: true if ϕ is safe, and false otherwise.
Problem: STATE-SAFETY
Input:
an FO(SC , M) formula ϕ(⃗x) and a ﬁnite SC-structure D.
Output: true if ϕ is safe on D, and false otherwise.
It is known that in general the SAFETY problem is undecidable even for
M = ⟨U, ∅⟩and ϕ an FOact(SC ) formula. On the other hand, one can easily
show the following.
Proposition 5.10.2. Let M = ⟨U, ∅⟩. Then the STATE-SAFETY problem
is decidable.
Proof sketch. By Theorem 5.6.3, we can assume that ϕ is an FOact(SC)
formula. Then it is safe on D iﬀevery tuple in the output contains only

5.10 Query Safety
309
elements of adom(D) (by genericity, if at least one tuple contains some
element c ̸∈adom(D), then any other c′ ̸∈adom(D) can be substituted
for c). This condition can easily be tested by considering a set c1, . . . , cm of
distinct elements not in adom(D), where m is the number of free variables in
ϕ, and checking all tuples in adom(D) ∪{c1, . . . , cm}.
2
We now turn to the safety problem for constraint databases. Consider
a situation where we have a linear constraint database D, but we want to
write queries against D in FO + Poly. The main reasons for considering this
situation are the following. Linear constraints are used to represent spatial
data in many applications, and they have several advantages over polynomial
constraints: the quantiﬁer elimination procedure is less costly, and numerous
algorithms have been developed to deal with ﬁgures represented by linear
constraints. As FO + Lin is more limited than FO + Poly (for example, it
cannot deﬁne the convex hull of a set), one may want to use FO + Poly to
get extra expressive power.
However, as soon as the class of constraints used in queries is more general
than the class used to deﬁne constraint database instances, we encounter
the safety problem again: the output of an FO + Poly query may fail to
be semilinear. More generally, if constraint databases are required to have
certain geometric properties, then the safety problem is the problem of
whether those geometric properties are preserved by a given query language.
Sect. 5.10.4 deals with this problem.
5.10.2 Safe Translations
The main goal of this section is to show that the safety of formulae is greatly
aﬀected by the properties of the underlying structure M. To state these
results formally, we use the following concept.
Deﬁnition 5.10.3. We say that there is a safe translation of FOact(SC, M)
formulae if there is a function ϕ →ϕsafe on FOact(SC , M) formulae such
that for every ϕ,
1. ϕsafe is safe, and
2. if ϕ is safe for D, then ϕ(D) = ϕsafe(D).
A translation is canonical if ϕsafe(D) = ∅whenever ϕ is not safe on D. A
translation is recursive if the function ϕ →ϕsafe is recursive.
It turns out that recursive safe translations need not exist even for
structures with decidable theories.
Proposition 5.10.4. There exists a structure M that is recursive and
has a decidable ﬁrst-order theory, and for which there is no recursive safe
translation of FOact(SC, M) formulae.

310
5 Embedded Finite Models and Constraint Databases
Proof sketch. Consider a structure M whose domain U is the disjoint union of
•
the set of Turing machines, appropriately coded as strings;
•
the set of input strings to a Turing machine;
•
the set of traces, i.e. full descriptions of a partial run of a Turing machine
on an input word.
The signature of M consists of one ternary relation P, which holds for
a triple (M, w, t) iﬀt is a trace for a Turing machine M on an input word
w. The key point is that there is no structure or ordering on the traces
themselves: hence one cannot determine in ﬁrst-order logic whether or not
a trace is maximal. In fact, using a quantiﬁer elimination argument, one can
show that the ﬁrst-order theory of M is decidable.
Let SC contain a single unary relation S. For any Turing machine M, let
ϕM(t) be the query ∃!w ∈adom(w = w) ∧∃w ∈adomP(M, w, t). That is, if
S = {w}, then ϕM checks whether t is a trace of M on w.
Assume that there is a recursive safe translation, and consider ϕM
safe(t).
Assuming further that we can check the equivalence of ϕM
safe and ϕM, we
would be able to enumerate all machines that halt on every input, which is
clearly impossible.
Thus, to obtain a contradiction, we need to show how to verify the
equivalence of ϕM
safe and ϕM. For that, we simply turn them into FO(M)
formulae ψM(w, t) and ψM
safe(w, t) by replacing each subformula of the form
S(z) by w = z. The resulting FO(M) formulae are then true for (w, t)
iﬀt is in the output of the corresponding query on input {w}. Thus,
∀w∀t (ψM(w, t) ↔ψM
safe(w, t)) holds iﬀϕM
safe and ϕM are equivalent. The
result now follows from the decidability of the theory of M.
2
If one drops the condition that the theory of M be decidable, but insists
on computable functions and predicates in Ω, the situation is even worse:
there need not be any safe translations at all (recursive or not).
Proposition 5.10.5. There is a structure M
=
⟨N, P⟩, where P is a
computable predicate, such that there is no safe translation of FOact(SC, M)
formulae.
Proof. Let P be a ternary predicate deﬁned as follows: P(i, j, k) iﬀthe ith
Turing machine on the input j makes at least k moves (assuming some
standard encoding of machines and inputs). Consider a schema that consists
of a single binary relation S. Assume, contrary to the proposition, that there
is a safe translation over M. Let ϕ(k) ≡∃i, j ∈adom S(i, j) ∧P(i, j, k), and
let ψ(k) be ϕsafe. Note that ψ is an active-domain formula in the language of
S and P. We now show how to use ψ to decide the halting problem.
Suppose we are given the ith machine Mi and the input j. We assume with-
out loss of generality that Mi makes at least one move on j. Deﬁne a database
D in which S consists of a single tuple (i, j). Since we know that ψ is safe, we

5.10 Query Safety
311
then compute the minimum number l such that D ̸|= ψ(l). It is computable
since (a) it exists, and (b) for each k, it is decidable whether D |= ψ(k).
Assume that D |= ϕ(l). Then Mi does not halt on j. Indeed, if Mi halts,
then ϕ(D) is ﬁnite, and hence ϕ(D) = ψ(D), but we have l ∈ϕ(D) −ψ(D).
Assume that D ̸|= ϕ(l). Then Mi makes k < l moves on j, and thus halts.
Hence, D |= ϕ(l) iﬀMi halts on j. Since it is decidable whether D |= ϕ(l),
we obtain a contradiction.
2
On the other hand, for some structures M, recursive safe translations can
be obtained.
Proposition 5.10.6. Let M be o-minimal, be based on a dense order, admit
eﬀective quantiﬁer elimination, and have a decidable theory (for example, M
can be Rlin or R). Then there exists a recursive canonical safe translation of
FOact(SC , M) formulae.
Proof sketch. Given an FOact(SC , M) formula ϕ, let α(x) be a formula
deﬁning the active domain of the output of ϕ. Let Ψ be an FOact(SC, M)
sentence equivalent to
¬∃x1, x2 ((x1 < x2) ∧(∀x x1 < x < x2 →α(x)))
(which exists, by natural-active collapse). Deﬁne ϕsafe as ϕ ∧Ψ. The proposi-
tion then follows from the following easy claim: D |= Ψ iﬀϕ(D) is ﬁnite.
2
Corollary 5.10.7. Let M be as in Proposition 5.10.6. Then the STATE-
SAFETY problem over M is decidable.
Thus, to obtain a nice syntactic characterization of safe queries, we must
deal with structures that have good properties (just as in the case of collapse
results).
5.10.3 Finite Query Safety: Characterization
To give an idea of the characterization of safety that we are about to
provide, let us modify slightly an example that we used in Section 5.2:
ϕ(x) ≡(x > 1) ∧∃y S(y) ∧(x · x = y). Assuming that the underlying struc-
ture is the real ﬁeld R, the output of this formula is contained in the output
of ∃y S(y) ∧(x · x = y), which is {−√a, √a | a ∈S}. Thus, there is an upper
bound on the output of ϕ, which is given by applying certain functions to the
active domain. This is the central idea of the range-restriction we are about to
deﬁne. But ﬁrst we introduce the notion of an eﬀective syntax for safe queries.
Deﬁnition 5.10.8. We say that a class Q of queries captures the class
of safe queries in FO(SC, M) if every query in Q is safe and deﬁnable in
FO(SC, M), and every safe FO(SC , M) query is equivalent to a query in Q.
If there exists a recursively enumerable class Q of queries that captures
safe queries in FO(SC, M), we say that the class of safe FO(SC , M) queries
has an eﬀective syntax.

312
5 Embedded Finite Models and Constraint Databases
Proposition 5.10.4 (more precisely, the construction presented in the proof
of Proposition 5.10.4) implies that there are structures M with a decidable
ﬁrst-order theory but without an eﬀective syntax for safe FO(SC, M).
Proposition 5.10.6, on the other hand, shows that there is an eﬀective syntax
for FO + Lin and FO + Poly queries, as one can express, in those languages,
the question whether the output of a query is ﬁnite. This way of guaranteeing
eﬀective syntax is quite inelegant, and tells us nothing about the structure
of safe queries. Below, we present a much better description, based on the
notion of deﬁnable functions.
Deﬁnition 5.10.9. Given M = ⟨U, Ω⟩, a function f : U k →U is M-
deﬁnable (or just deﬁnable if M is understood) if its graph {(a1, . . . , ak, a) ∈
U k+1 | a = f(a1, . . . , ak)} is an M-deﬁnable set.
From now on, we assume that adom(D) ̸= ∅. The case of empty SC-
structures can be dealt with easily, as in this case an FO(SC, M) formula
reduces to a ﬁxed FO(M) formula, whose ﬁniteness can be tested in the
o-minimal case.
Deﬁnition 5.10.10. Given M = ⟨U, Ω⟩, a query in range-restricted form is
a pair Q = (F, ϕ(x1, . . . , xn)), where ϕ(⃗x) is an FO(SC , M) formula, and F
is a ﬁnite collection of deﬁnable functions.
The semantics is deﬁned as follows. First, for a set X, let
F(X)
=
{f(⃗a) | f ∈F,
⃗a ∈Xarity(f) }.
Then, for any ﬁnite SC-structure D, deﬁne
Q(D)
=
ϕ(D) ∩(F(adom(D)))n.
That is, the ﬁnite set F(adom(D)) provides an upper bound on the
output of Q (every constant in Q(D) must be contained in F(adom(D))),
and then ϕ is evaluated within this set. Since F is ﬁnite, and every function
in F is deﬁnable, we obtain the following.
Lemma 5.10.11. Every query in range-restricted form over M is safe and
deﬁnable in FO(SC, M).
We now can state the main result of this section.
Theorem 5.10.12. Let M be any o-minimal structure based on a dense
linear order. Assume that there is at least one deﬁnable constant in M. Then
there is a function Make Safe that takes as input an FO(SC, M) formula
ϕ(⃗x), and outputs a ﬁnite set F of deﬁnable functions such that the query
Q = (F, ϕ) is equivalent to ϕ on any ﬁnite SC-structure D on which ϕ is
safe. Furthermore, if M is decidable and has eﬀective quantiﬁer elimination,
then Make Safe is recursive.

5.10 Query Safety
313
The proof of this theorem will be given later in this section. But ﬁrst we
shall state some corollaries.
Corollary 5.10.13 (Range-Restricted = Safe). Let M be as in Theorem
5.10.12. Then the class of range-restricted queries captures the class of safe
FO(M, SC) queries.
We now consider speciﬁcally the cases of polynomial and linear constraints.
Deﬁnition 5.10.14. (a) A query in the linear range-restricted form is a pair
Q = (F, ϕ), where ϕ is an FO + Lin formula and F is a ﬁnite collection of
linear functions (that is, functions of the form ⟨⃗a, ⃗x⟩+ b). The semantics is
deﬁned in the same way as for range-restricted queries above.
(b)
A
query
in
the
polynomial
range-restricted
form
is
a
pair
Q = (P, ϕ(x1, . . . , xn)), where ϕ is an FO + Poly formula and P is a
ﬁnite collection of multivariate polynomials with a distinguished variable z.
The semantics is deﬁned as follows. For a set X, and p(z, ⃗y), let p(X) be
the set of all roots of polynomials of the form p(z,⃗a), where ⃗a is a tuple
over X, provided such a univariate polynomial is not identically zero. Let
P(X) = 
p∈P p(X). Then Q(D) is deﬁned as ϕ(D) ∩(P(adom(D)))n.
Corollary 5.10.15. (a) The class of queries in the linear range-restricted
form captures the class of safe FO + Lin queries.
(b) The class of queries in the polynomial range-restricted form captures
the class of safe FO + Poly queries.
Proof. (a) A function deﬁnable over Rlin is piecewise linear. Thus it suﬃces
to apply Theorem 5.10.12, and take all the linear functions of which functions
in F are composed.
(b) Similarly, we apply Theorem 5.10.12 and obtain a set F of semialge-
braic functions. Each semialgebraic function f(⃗y) is known to be algebraic.
That is, there exists a polynomial p(z, ⃗y) such that p(z, ⃗y) = 0 iﬀz = f(⃗y).
The result follows from this.
2
Algebraic Formulae and the Proof of Theorem 5.10.12
We shall ﬁrst give an analog of range-restriction using certain FO(M)
formulae, and then show how to derive a set F of deﬁnable functions from
such a characterization. The FO(M) that formulae we shall use are algebraic
formulae. They have distinguished parameters, which we shall always denote
by ⃗y and separate from the single other variable by a semicolon. Assume that
⃗y is of length m. An FO(M) formula γ(x; ⃗y) is called algebraic if, for each ⃗b
in U m, there are only ﬁnitely many a ∈U that satisfy γ(a,⃗b). For example,
the formula γ(x; y) ≡(x2 = y) is algebraic over R.
From the Uniform Bounds Theorem (Theorem 5.6.7), we obtain the
following useful fact about algebraic formulae.

314
5 Embedded Finite Models and Constraint Databases
Lemma 5.10.16. Let M be o-minimal, and γ(x; ⃗y) algebraic. Then there
exists a number K such that for any ⃗b ∈U m, the set {a ∈U | M |= γ(⃗a;⃗b)}
has fewer than K elements.
We now need a syntactic characterization of algebraic formulae over
o-minimal structures. Let Ξ = {ξ1(x; ⃗y), . . . , ξk(x; ⃗y)} be a collection of
formulae. Let
sameΞ(x, x′; ⃗y)
≡
k	
i=1
(ξi(x; ⃗y) ↔ξi(x′; ⃗y)).
Now deﬁne
βΞ(x; ⃗y) ≡∀x′, x′′ 
x′ < x < x′′ →(∃z x′ ≤z ≤x′′ ∧¬sameΞ(x, z; ⃗y))

.
Proposition 5.10.17. Let M be an o-minimal structure based on a dense
order. Then a formula γ(x; ⃗y) is algebraic iﬀthere exists a collection of
FO(M) formulae Ξ such that γ is equivalent to βΞ.
Proof. Let Ξ be a collection of formulae, and assume that βΞ is not algebraic.
That is, for some ⃗b over U, βΞ(M;⃗b) = {a | M |= βΞ(a;⃗b)} is inﬁnite. Since
M is o-minimal, βΞ(M;⃗b) is a ﬁnite union of points and intervals. Since < is
dense, this means that there exist a0 < b0 ∈U such that [a0, b0] ⊆βΞ(M;⃗b).
We now consider the formulae ξ′
i(x) = ξi(x;⃗b) for all ξi ∈Ξ. Since both
ξ′
i(M) = ξi(M;⃗b) and ¬ξ′
i(M) = ¬ξi(M;⃗b) are ﬁnite unions of intervals and
< is dense, for every nondegenerate interval J, it is the case that either
J ∩ξ′
i(M) or J ∩¬ξ′
i(M) contains an inﬁnite (closed) interval. Using this
fact, we construct a sequence of intervals as follows: I0 = [a0, b0], and I1 ⊆I0
is an interval that is contained either in I0 ∩ξ′
1(M) or in I0 ∩¬ξ′
1(M). At the
jth step, Ij ⊆Ij−1 is an interval that is contained either in Ij−1 ∩ξ′
j(M) or
in Ij−1 ∩¬ξ′
j(M). Let I = Ik. Then, for any c, d ∈I, M |= ξi(c,⃗b) ↔ξi(d;⃗b).
Since I = [a′, b′] ⊆[a0, b0] and M |= βΞ(c;⃗b) for all c ∈I, we obtain that,
for every c ∈(a′, b′), there exists a d ∈[a′, b′] such that M |= ¬sameΞ(c, d;⃗b).
That is, for some ξi ∈Ξ, M |= ¬(ξi(c;⃗b) ↔ξi(d;⃗b)), which is impossible by
the construction of I. This proves that βΞ is algebraic.
For the converse, for any γ(x; ⃗y), we let Ξ consist of just γ. That is,
βΞ(x; ⃗y) is
∀x′, x′′ 
x′ < x < x′′ →(∃z x′ ≤z ≤x′′ ∧¬(γ(x; ⃗y) ↔γ(z; ⃗y)))

.
We claim that γ and βΞ are equivalent, if γ is algebraic. Fix any ⃗b of the same
length as ⃗y, and assume that γ(a;⃗b) holds. If βΞ(a;⃗b) does not hold, then
there exist a′ < a < a′′ such that for every c ∈[a′, a′′], γ(c;⃗b) ↔γ(a;⃗b) holds;
thus, γ(c;⃗b) holds for inﬁnitely many c, contradicting the algebraicity of γ.
Hence βΞ(a;⃗b) holds. Conversely, assume that βΞ(a;⃗b) holds. If γ(a;⃗b) does

5.10 Query Safety
315
not hold, then there is an interval containing a on which γ(·;⃗b) does not hold.
Indeed, ¬γ(M;⃗b) is a ﬁnite union of intervals, whose complement is a ﬁnite set
of points, so the above observation follows from the density of the ordering.
We now pick a′ < a′′ such that γ(·;⃗b) does not hold on [a′, a′′]. Since βΞ(a;⃗b)
holds, we ﬁnd c ∈[a′, a′′] such that ¬(γ(a;⃗b) ↔γ(c;⃗b)) holds; that is, γ(c;⃗b)
holds for c ∈[a′, a′′], which is impossible. Thus, we conclude that γ(a;⃗b) holds,
proving that for any ⃗b, ∀x (γ(x;⃗b) ↔βΞ(x;⃗b)). This ﬁnishes the proof.
2
Given an algebraic formula γ(x; ⃗y) and a set X ⊆U, let γ(X) be the set
of all a that make γ(a;⃗b) true, as ⃗b ranges over tuples of elements of X. Note
that if X is ﬁnite, then so is γ(X).
We now deﬁne a query in the algebraic range-restricted form as a
pair Q
=
(γ(x; ⃗y), ϕ(x1, . . . , xn)), where ϕ is an FO(SC , M) formula,
and γ
is an algebraic FO(M) formula. The semantics is deﬁned as
Q(D) = ϕ(D) ∩(γ(adom(D)))n. Clearly, Q is safe.
Proposition 5.10.18. Let M be any o-minimal structure based on a dense
linear order. Then there is a function Make Safe′ that takes as input an
FO(SC, M) formula ϕ(x1, . . . , xn), and outputs an algebraic formula γ(x; ⃗y)
such that the query Q = (γ, ϕ) is equivalent to ϕ on all structures D for
which ϕ is safe. Furthermore, if M has eﬀective quantiﬁer elimination, then
Make Safe′ is recursive.
Proof. Let ψ(z) be a one-variable FO(SC, M) formula that deﬁnes the active
domain of the output of ϕ. That is, it is the disjunction of all formulae
∃⃗x(i)ϕ(z, ⃗x(i)) where ⃗x(i) is ⃗x except for the ith component, and (z, ⃗x(i)) is the
tuple in which z is inserted in the ith position. Note that ϕ is safe on D iﬀψ is.
Let M′ be a deﬁnable expansion of M that has quantiﬁer elimination,
and hence admits natural-active collapse. We can thus assume that ψ is an
FOact(SC , M′) formula. Let
ψ(z) ≡Qw1 ∈adom . . . Qwl ∈adom α(z, ⃗w),
where α(z, ⃗w) is quantiﬁer-free, and all atomic subformulae R(· · · ) contain
only variables, excluding z. Let Ξ = {ξi(z, ⃗w) | i = 1, . . . , k} be the collection
of all FO(M′) atomic subformulae of α. We may assume without loss of
generality that the length of ⃗w is nonzero, and that Ξ is nonempty (just as
we did in the proof of natural-active collapse).
We deﬁne sameΞ(a, b, ⃗w), as before, to be k
i=1(ξi(a, ⃗w) ↔ξi(b, ⃗w)), and
deﬁne γ(x; ⃗w) to be βΞ(x; ⃗w). We let Make Safe(ψ) output γ. Note that γ is
actually an FO(M) formula, since M′ is a deﬁnable expansion.
Since γ
is algebraic by Proposition 5.10.17, we must show that
{a | D |= ψ(a)} = {a ∈γ(D) | D |= ψ(a)} for every nonempty database for
which ψ is safe.
Assume otherwise; that is, for some nonempty D for which ψ is safe, we
have D |= ψ(a) but a ̸∈γ(D). Let ⃗c1, . . . ,⃗cM be an enumeration of all tuples

316
5 Embedded Finite Models and Constraint Databases
of of elements of adom(D) of the same length as ⃗w. Note that M > 0. Since
a ̸∈γ(D), we have that for each i = 1, . . . , M, there exist a′
i, a′′
i such that
a′
i < a < a′′
i and M |= sameΞ(a, c,⃗ci) for all c ∈[a′
i, a′′
i ].
Let b′ = max{a′
i} and b′′ = min{a′′
i }. We have b′ < a < b′′, and for each ⃗c
(of length the same as ⃗w) over the active domain, we have ξi(a;⃗c) ↔ξi(c,⃗c)
for every c ∈[b′, b′′]. From this, by a simple induction on the structure of the
formula (using the fact that z does not appear in any atomic formula R(· · · )),
we obtain that D |= α(a,⃗c) ↔α(c,⃗c) for every ⃗c over adom(D) and every c ∈
[b′, b′′], and thus D |= ψ(a) ↔ψ(c), which implies that ψ is not safe for D. This
contradiction proves the correctness of Make Safe′, and the proposition.
2
To conclude the proof of Theorem 5.10.12, we have to show how to obtain
deﬁnable functions from algebraic formulae.
Proposition 5.10.19. Let M be o-minimal, such that there is at least one
deﬁnable constant. Let γ(x; ⃗y) be algebraic. Then there is a ﬁnite collection
F of deﬁnable functions f(⃗y) such that γ(X) ⊆F(X) for any set X ⊆U.
Moreover, if M is decidable, then the set F can be found eﬀectively.
Proof. Let c be a deﬁnable constant over M. Given γ, let K be an integer
such that the set {a ∈U | M |= γ(a,⃗b)} has fewer than K elements for every
⃗b (see Lemma 5.10.16). For each i < K, deﬁne fi(⃗y) to be the ith element
(in the order <) that makes γ(·, ⃗y) true, if it exists, and c, if there is no such
element. Let F = {fi | i < K}. Clearly, each fi is a deﬁnable function and
γ(X) ⊆F(X). If M is decidable, then K can be found, and thus F can be
constructed eﬀectively.
2
We now ﬁnally complete the proof of Theorem 5.10.12. Given an
FO(SC, M) formula ϕ(⃗x), we ﬁrst apply Proposition 5.10.18 to obtain an
algebraic formula γ giving a bound on the output (if it is ﬁnite), and then
apply Proposition 5.10.19 to obtain a set of functions F that puts a bound
on the output of ϕ. If M is decidable and quantiﬁer elimination is eﬀective,
then γ can be eﬀectively found (as the natural-active collapse is eﬀective),
and there is an algorithm for constructing F from γ.
2
5.10.4 Inﬁnite Query Safety: Reduction
The question of query safety over constraint databases reduces to preserving
certain geometric properties of regions in Rk. If M = ⟨U, Ω⟩is an inﬁ-
nite structure, let DS(M) be the class of deﬁnable sets over M, that is,
DS(M) = 
n<ω DSn(M), and DSn(M) is the collection of deﬁnable subsets
of U n. We use SAlgn for semialgebraic sets in Rn.
Let SC consist of an m-ary relation symbol S, and let ψ(x1, . . . , xn) be an
FO(SC, M) formula. It deﬁnes a map from DSm(M) to DSn(M) as follows:
for any X ∈DSm(M), ψ(X) = {⃗y | (M, X) |= ψ(⃗y)}.
Now let C be a class of objects in DS(M). We say that an FO(SC, M)
formula ψ preserves C if for any X ∈C, ψ(X) ∈C. The safety question for

5.10 Query Safety
317
constraint databases is the following. Is there an eﬀective syntax for the class
of C-preserving queries?
We now show how this problem can be reduced to ﬁnite query safety for
embedded ﬁnite models.
Deﬁnition 5.10.20. The class C has a canonical representation in DS(M)
if there is a recursive injective function g : N →N with a computable inverse,
and for each n, two functions coden : 2Un →2Um and decoden : 2Um →2Un,
where m = g(n), such that:
1. decoden ◦coden(x) = x if x ∈DSn(M);
2. |coden(x)|< ω if x ∈C; decoden(x) ∈C if x is ﬁnite;
3. coden is FO(M)-deﬁnable on DSn(M);
4. decoden is FO(M)-deﬁnable on ﬁnite sets.
Intuitively, the canonical representation is a ﬁnite representation of C
within DS(M) that can be deﬁned in ﬁrst-order logic over M. For example,
one approach to obtaining a canonical representation of convex polytopes
would be to compute their vertices. This suﬃces to reconstruct the polytope,
and the vertices can be deﬁned by a ﬁrst-order formula.
Similarly to the ﬁnite case, we say that there is an eﬀective syntax for
C-preserving FO(SC, M) formulae if there exists a recursively enumerable
set of C-preserving FO(SC, M) formulae such that every C-preserving
FO(SC, M) formula is equivalent to a formula in this set.
Theorem 5.10.21. Let M = ⟨U, Ω⟩be o-minimal, based on a dense order,
and decidable, and have eﬀective quantiﬁer elimination. Suppose C is a class
that has a canonical representation in DS(M). Then there is an eﬀective
syntax for C-preserving FO(SC , M) formulae.
Proof. Consider an enumeration of all safe FO(SC , M) queries ⟨ϕi⟩on ﬁnite
structures (from Proposition 5.10.18, we know that it exists). Let ϕ use an
extra relation symbol of arity m, and assume that n is such that g(n) = m
(where g comes from the deﬁnition of canonical representations). Let ϕi have
l parameters, and again let k be such that g(k) = l. If n and k can be found
for a given ϕi, we let ψ be
decodek ◦ϕi ◦coden.
This produces the required enumeration. We have to check that every query
of the form decodek ◦ϕi ◦coden preserves C, and for every C preserving ψ, we
can get a ϕ such that decode ◦ϕ ◦code coincides with ψ. It is clear that the
ﬁrst condition is satisﬁed: if we have X ∈C, then coden(X) is ﬁnite, hence
ϕi(coden(X)) is ﬁnite too, and thus the output of decodek is in C.
For the converse, suppose we have a C-preserving query ψ : DSn(M) →
DSk(M). Deﬁne α as follows: α = codek ◦ψ ◦decoden. That is, α is a query
DSm(M) →DSl(M). Given this, we notice that

318
5 Embedded Finite Models and Constraint Databases
decodek ◦α ◦coden = decodek ◦codek ◦ψ ◦decoden ◦coden = ψ
on DSn(M). Thus, it remains to show that α is safe. Let X ⊂U m be ﬁnite.
Then decoden(X) ∈C, decoden(X) ⊂U n, and Y = ψ(decoden(X)) ∈DSk(M)
is in C, too. Hence, codek(Y ) is ﬁnite.
2
We now give two applications to semialgebraic sets and FO + Poly. The
ﬁrst one gives an example of a geometric class for which coding is easy.
Proposition 5.10.22. The class of convex polytopes has a canonical repre-
sentation in SAlg. Consequently, the class of FO + Poly queries preserving
the property of being a convex polytope has an eﬀective syntax.
Proof. Given a convex polytope X in Rn, its vertices can be found as
V (X) = {⃗x ∈Rn | ⃗x ∈X, ⃗x ̸∈conv(X −⃗x)}, where conv(·) denotes the
convex hull. Thus, V (X) is deﬁnable in FO + Poly. We now deﬁne coden.
To simplify the notation, we let it produce a pair of n-ary relations, but
it can be straightforwardly coded by one relation. If X = conv(V (X)),
then coden(X) = (V (X), ∅); otherwise, coden(X) = (Rn, X). The function
decoden : 2Rn × 2Rn →2Rn is deﬁned as follows:
decoden(Y, Z) =
 
(⃗y1,...,⃗yn+1)∈Y
conv({⃗y1, . . . , ⃗yn+1}) if Y ̸= Rn,
Z otherwise.
Clearly, decoden ◦coden is the identity function for any semialgebraic set;
these functions are also ﬁrst-order deﬁnable. If X is a polytope, V (X) is ﬁnite,
and, by Carath´eodory’s Theorem, each point of X is contained in the convex
hull of at most n+1 vertices of X. Hence, card(coden(X)) ≤card(V (X))n+1.
If (Y, Z) is ﬁnite, then decoden(Y ) is conv(Y ), and thus a convex polytope.
This proves the proposition.
2
The second example deals with the case where C is a class of semilinear
sets. We now give two diﬀerent approaches to showing the following.
Theorem 5.10.23. There is an eﬀective syntax for the class of FO + Poly
queries preserving semilinearity.
One approach to showing this is to prove that the class of semilinear sets
has a canonical representation in the class of semialgebraic sets. This is true,
although the coding scheme is quite complex and not very intuitive. Another
way of showing this theorem is based on the proposition below.
Proposition 5.10.24. For any n > 0, there is an FO + Poly sentence
over SC containing one n-ary relation symbol, which tests whether the input
(which is a semialgebraic set S ⊆Rn) is semilinear.
2

5.10 Query Safety
319
An eﬀective syntax for FO + Poly queries preserving semilinearity
can then be obtained simply by inserting tests for the input and out-
put being semilinear, and returning the empty set if semilinearity is not
preserved. However, the decision procedure is not much simpler than the
canonical representation, and we are thus very far from a usable language
for FO + Poly-deﬁnable queries preserving semilinearity. But the very
fact that such a language exists is an interesting and nontrivial property
of FO + Poly.
5.10.5 Deciding Safety
The safety of FOact(SC) formulae is already undecidable. However, there are
some nice syntactic subclasses of FOact(SC) for which safety is guaranteed.
We now consider one such subclass – conjunctive queries. The class of
conjunctive queries is deﬁned as a {∃, ∧}-fragment of FOact(SC), that is, as
the set of formulae built from atomic formulae S(·), where S ∈SC, using
conjunction and existential quantiﬁcation only. Outputs of such formulae
cannot extend the active domain, and hence they are safe. We now consider a
natural analog of conjunctive queries over embedded ﬁnite models. Although
they are no longer guaranteed to produce an output containing only elements
of the active domain, their safety remains decidable for underlying structures
such as Rlin and R.
A conjunctive query (CQ) is an FO(SC, M) formula of the form
ϕ(⃗x)
≡
∃⃗y∈adom α1(⃗x, ⃗y) ∧. . . ∧αk(⃗x, ⃗y) ∧γ(⃗x, ⃗y),
where α1(⃗x, ⃗y), . . . , αk(⃗x, ⃗y), k ≥0 are formulae of the form S(⃗u), where
S ∈SC and ⃗u is a subtuple of (⃗x, ⃗y), and γ is an FO(M) formula.
Theorem 5.10.25. Let M be o-minimal, based on a dense order, and
decidable, and admit eﬀective quantiﬁer elimination. Then it is decidable
whether a given conjunctive query in FO(SC, M) is safe.
Proof. Given two formulae ϕ(⃗x) and ψ(⃗x), by the containment ϕ ⊆ψ we
mean ϕ(D) ⊆ψ(D) for any ﬁnite D. From Proposition 5.10.18 we obtain that
for any FO(SC, M) formula ϕ(⃗x), there exists an active-semantics CQ ψ(⃗x)
such that ϕ is safe iﬀϕ ⊆ψ. The theorem now follows from the lemma below.
Lemma 5.10.26. Let M be as in Theorem 5.10.25. Then containment is
decidable for conjunctive queries.
Proof. Suppose we are given CQs ϕ(⃗x) and ψ(⃗x). We claim that one can
eﬀectively ﬁnd a number k such that ϕ ⊆ψ iﬀfor every D with at most k
tuples, ϕ(D) ⊆ψ(D). This clearly implies the result, as the latter condition
can be expressed as an FO(M) sentence.

320
5 Embedded Finite Models and Constraint Databases
To prove the claim, assume that ϕ(⃗x) is ∃⃗y∈adom l
i=1 αi(⃗ui)∧γ(⃗x, ⃗y). We
claim that k can be taken to be l plus the length of ⃗y. Assume there is an ⃗a ∈
ϕ(D)−ψ(D). Let ⃗b witness D |= ϕ(⃗a); we then see that there is a structure D′
that contains at most k tuples from D such that D′ |= ϕ(⃗a) (it has to contain
enough tuples to ensure that all elements of ⃗b are in adom(D′)), and that
l
i=1 αi(⃗ui) holds. But then D′ |= ¬ψ(⃗a), for otherwise we would have D |=
ψ(⃗a). Thus, any counterexample to containment is witnessed by a ≤k-element
structure. This ﬁnishes the proof of Lemma 5.10.26 and of the theorem.
2
The proof can be extended to show a slightly more general result:
Corollary 5.10.27. It is decidable whether any Boolean combination of
FO + Lin or FO + Poly conjunctive queries is safe.
Note, however, that the safety of conjunctive queries is not decidable over
every structure.
Proposition 5.10.28. Let N = ⟨N, +, ·⟩. Then the safety of conjunctive
queries in FO(SC, N) is undecidable, for any SC.
Proof. Deﬁne ϕ(⃗x) to be p(⃗x) = 0 for some Diophantine equation. This is
a CQ in FO(SC, M), and it is safe iﬀp(⃗x) = 0 has ﬁnitely many solutions.
However, this property of Diophantine equations is undecidable.
2
Some decidability results can be shown for constraint databases as well.
We shall give only one example here, for the case of queries preserving the
property of being a convex polytope.
Lemma 5.10.29. Let ϕ(x1, . . . , xn) be a union of FO + Poly conjunctive
queries that mention one m-ary relational symbol S. Then one can eﬀectively
ﬁnd two numbers k and l such that ϕ preserves the property of being a convex
polytope iﬀ, for every convex polytope D in Rm with at most k vertices, the
output ϕ(D) is a convex polytope with at most l vertices in Rn.
With this lemma, one can show the following result.
Proposition 5.10.30. It
is
decidable
whether
a
union
of
conjunctive
FO + Poly queries preserves the property of being a convex polytope.
Proof. Note that for each i, there is an FO + Poly query ψi for each i that
tests whether a set D is a convex polytope with at most i vertices: it checks
that the set of vertices V (D) = {x ∈D | x ̸∈conv(D −x)} has at most i ele-
ments, and that D = conv(V (D)). In order to check whether ϕ in FO + Poly
preserves convex polytopes, one applies Lemma 5.10.29 to compute the num-
bers k and l, and then writes a sentence saying that for every set V in Rm with
at most k elements, applying ϕ to conv(V ) yields a polytope with at most l
vertices. Since conv and ψl are deﬁnable, this property can be expressed as
an FO(R) sentence. The proposition now follows from the decidability of the
theory of R.
2

5.10 Query Safety
321
5.10.6 Dichotomy Theorem for Embedded Finite Models
We now show a simple but powerful combinatorial structure theorem, saying
that over a well-behaved structure, outputs of safe queries cannot grow
arbitrarily large in terms of the size of the input. We use the notation size(D)
for the size of a ﬁnite structure, measured here as the total number of tuples.
It can be measured equivalently as the cardinality of the active domain,
or the number of tuples multiplied by their arity, and all the results will
still hold.
Theorem 5.10.31 (Dichotomy Theorem). Let M be o-minimal and based
on a dense order. Let ϕ(⃗x) be an FO(SC , M) formula. Then there exists a
polynomial pϕ : R →R such that, for any ﬁnite SC-structure D, either ϕ(D)
is inﬁnite or size(ϕ(D)) ≤pϕ(size(D)).
Proof. Expand Ω by one constant (this does not violate o-minimality) and
apply Theorem 5.10.12.
2
The Dichotomy Theorem can also be stated in terms of a function mea-
suring the growth of the output size. We deﬁne growthϕ : N →N ∪{∞} as
growthϕ(n) = max{size(ϕ(D)) | size(D) = n}.
Corollary 5.10.32. Let ϕ(⃗x) be an FO(SC , M) formula for M as in Theo-
rem 5.10.31. Then there exists a polynomial pϕ such that, for every n ∈N,
either growthϕ(n) = ∞or growthϕ(n) ≤pϕ(n).
2
As we have often seen in this chapter, the assumptions about the structure
are extremely important. Below, we show that the Dichotomy Theorem fails
over some simple decidable structures on the natural numbers.
Proposition 5.10.33. Let
M
=
⟨N, +, <, 1⟩.
Then
there
exists
an
FOact(SC , M) formula ϕ(x) such that growthϕ(n) = 2n for every n > 0.
Proof. Let SC consist of one unary relation S. We show that there exists
an FOact(SC , M) sentence Ψ such that S
|=
Ψ iﬀS is of the form
Sn = {2i | 1 ≤i ≤n}. This is done by letting Ψ be
(∃x∈adom x = 1 + 1 ∧S(x))
∧(∀x∈adom x = 1 + 1 ∨x > 1 + 1)
∧(∀x∈adom x = 1 + 1 ∨∃y∈adom y + y = x)
∧(∀x∈adom (∀y∈adom y < x ∨y = x) ∨(∃y∈adom y = x + x)).
Now deﬁne ϕ(x) as Ψ ∧¬(x < 1) ∧(∃y ∈adom x < y ∨x = y). Then, for S
not of the form Sn, we have ϕ(S) = ∅, and ϕ(Sn) = {1, 2, 3, . . ., 2n}. Since
card(Sn) = n, this implies growthϕ(n) = 2n for n > 0.
2

322
5 Embedded Finite Models and Constraint Databases
The Dichotomy Theorem gives easy expressivity bounds based on the
growth of the output size. For example, even if we use exponentiation, we still
cannot express any queries with superpolynomial growth, since ⟨R, +, ·, ex⟩
is o-minimal.
To give another application, consider the following problem: given a
polyhedron P and ε > 0, ﬁnd a triangulation of P of mesh < ε. That
is, a triangulation such that the diameter of each simplex (a triangle in
dimension 2) is less than ε. Every polyhedron admits such a triangulation.
The output of such a query can be structured in several ways, for example
by storing the information about the face structure of the triangulation.
We impose only one requirement, that the vertices of the triangulation be
computable.
Proposition 5.10.34. Let M = ⟨R, Ω⟩be an o-minimal expansion of the
real ﬁeld R. Then there is no FO(SC , M) formula that ﬁnds a triangulation
of a given polygon with a given mesh. This continues to hold if we restrict
ourselves to convex polytopes on a plane.
Proof. Suppose that such a formula exists; now consider a new query that
does the following. Its input is one binary relation containing a set X of
points ⃗x1, . . . , ⃗xn on the real plane, and one unary relation containing a single
real number ε > 0. First, in FO + Poly, construct conv(X), and then ﬁnd
vertices of a triangulation with mesh < ε. This is clearly a safe query, so, by
the Dichotomy Theorem, there exists a polynomial p such that the number
of vertices of the triangulation is at most m = p(n + 1) (n + 1 is the size
of the input). Let d be the maximal distance between the points ⃗xi, ⃗xj (and
thus the diameter of conv(X)). Since the segment [⃗xi, ⃗xj] with d(⃗xi, ⃗xj) = d
must be covered by the simplexes of the triangulation, it is possible to ﬁnd
a number ε such that it cannot be covered by fewer than m + 1 triangles of
diameter ε, and hence the number of points in the triangulation is greater
than m. This contradiction proves the proposition.
2
Analogs of the results for growth bounds can be obtained in the constraint
database setting as well; we give one example below.
Proposition 5.10.35. Let ϕ(⃗x) be an FO + Poly formula that preserves
the property of being a convex polytope. Then there exists a polynomial pϕ
such that, whenever D is a convex polytope with n vertices, ϕ(D) has at most
pϕ(n) vertices.
5.11 Database Considerations
In this section, we consider two aspects of embedded ﬁnite models and
constraint databases, motivated primarily by database considerations: adding
aggregate functions, and higher-order features.

5.11 Database Considerations
323
5.11.1 Aggregate Operators
Aggregate operators such as COUNT, SUM, and AVG form an indispensable
part of database query languages for the relational data model. How can they
be used in the settings of embedded ﬁnite models and constraint databases?
We shall now brieﬂy consider two aggregate operators. The average
operator, present in all commercial database systems, returns the average
value of a column of a relation. The volume operator, used in geographical
information systems, returns the volume (or area) of a set. Here we investi-
gate the possibility of incorporating these operators into languages such as
FO + Poly and FO + Lin.
Let ϕ(⃗x, ⃗y) be a formula in FO(SC, M), with ⃗x and ⃗y being of length n and
m, respectively. For ⃗a ∈U n, we deﬁne ϕ(⃗a, D) to be {⃗b ∈U m | D |= ϕ(⃗x, ⃗y)}.
Let Avg(C) be the average value of a ﬁnite set C ⊂R; we let Avg(C) = 0
if C is empty or inﬁnite. We say that the average operator Avg is deﬁnable
over M if, for every vocabulary SC and every FO(SC, M) formula ϕ(⃗x, y),
there exists an FO(SC , M) formula ψ(⃗x, z) such that for every SC -structure
D, D |= ψ(⃗a, c) iﬀc = Avg(ϕ(⃗a, D)).
An easy application of collapse results shows the following.
Proposition 5.11.1. Let M = ⟨R, Ω⟩be o-minimal, and such that the
expansion M = ⟨R, Ω, +, ·⟩is o-minimal as well (for example, R, Rlin). Then
the average operator Avg is not deﬁnable over M.
We leave this as an exercise, but we shall soon prove a more general
result. Since Avg is not deﬁnable, one may consider several ways to overcome
this. One possibility is to approximate it, rather than deﬁne it precisely.
What could such an approximation be? Clearly, we cannot hope to deﬁne
an ε-interval around the value of Avg(ϕ(⃗a, D)), as then that value would be
deﬁnable as the center of the interval. Instead, we settle for a little less: we
want to produce a formula deﬁning a nonempty set that lies in that ε-interval.
We say that the average operator Avgε, ε > 0, is deﬁnable over M if, for
every vocabulary SC and every FO(SC , M) formula ϕ(⃗x, y), there exists an
FO(SC, M) formula ψ(⃗x, z) such that for every SC -structure D, and every
⃗a, the following two conditions hold:
1. D |= ∃z ψ(⃗a, z) (that is, ψ(⃗a, D) ̸= ∅); and
2. if D |= ψ(⃗a, c), then |c −Avg(ϕ(⃗a, D))| < ε.
We say that the average operator Avgε
I, ε > 0, is deﬁnable over M if the
above is true whenever ϕ(⃗a, D) ⊆I = [0, 1].
We shall now show the inexpressibility result for these queries. Recall that
all previous inexpressibility results (with the exception of the result on topo-
logical queries) were proved by reductions to generic queries. Here we cannot
easily ﬁnd such reductions, as approximating queries are extremely non-
generic: they do not say anything about the behavior on the ε-interval, other

324
5 Embedded Finite Models and Constraint Databases
than that some point of the interval satisﬁes the formula. The proof below
shows a way to circumvent the problem of “extremely nongeneric” queries.
Theorem 5.11.2. Let M = ⟨R, Ω⟩be o-minimal, and such that the expansion
M = ⟨R, Ω, +, ·⟩is o-minimal as well. Then the average operators Avgε (for
any ε > 0) and Avgε
I (for 0 < ε < 1/2) are not deﬁnable over M.
Proof. Let SC consist of two unary relations, U1 and U2. Let c1, c2 > 1 be two
real numbers. We say that Φ is a (c1, c2)-separating sentence if, for any ﬁnite
instance D of SC, it is the case that card(U1) > c1 · card(U2) implies D |= Φ
and card(U2) > c2 · card(U1) implies D |= ¬Φ. Note that this deﬁnition says
nothing about the case when (1/c2)·card(U2) ≤card(U1) ≤c1 ·card(U2), and
thus a direct application of bounds on the expressiveness of generic queries
is impossible.
Lemma 5.11.3. Let M be as in the theorem, let c1, c2 > 1, and let SC be as
above. Then no (c1, c2)-separating sentence is deﬁnable in FO(SC, M).
Proof of the lemma. Assume that there is a (c1, c2)-separating sentence Φ.
From the natural-active collapse, we conclude that there is an FOact(SC, M′)
(c1, c2)-separating sentence Φ′ for some deﬁnable expansion M′ of M that
has quantiﬁer elimination. From the Ramsey property of active-semantics
formulae (Proposition 5.5.5), we obtain that there is an inﬁnite set Y ⊆U
and an FOact(SC, <) sentence Ψ such that, for every SC-structure D with
adom(D) ⊂Y , we have D |= Φ′ iﬀD |= Ψ. Thus, it remains to show that
FOact(SC , <) cannot express a (c1, c2)-separating sentence Ψ on instances
over an inﬁnite set.
Assume that it can, and let q be the quantiﬁer rank of Ψ. We now
consider two instances over Y . In both instances D1 and D2, all elements
of U1 precede U2 in the linear order <. In D1, card(U1) = ⌈c1(2q + 1)⌉and
card(U2) = 2q +1; in D2, card(U1) = 2q +1 and card(U2) = ⌈c2(2q +1)⌉. Since
Ψ is a (c1, c2)-separating sentence, we must have D1 |= Ψ and D2 |= ¬Ψ.
It is then easy to obtain a contradiction by showing that D1 |= Ψ iﬀ
D2 |= Ψ. This is done by proving that the duplicator can win in a q-round
Ehrenfeucht–Fra¨ıss´e game on D1 and D2. This follows from the fact that
for every n, m > 2q, the duplicator can win a q-round game on two ordered
sets of cardinalities n and m. Thus, in the case of D1 and D2, the duplicator
picks separate strategies for U1 and U2, and whenever the spoiler plays in
U1, the duplicator forgets about the moves in U2 and responds in U1 using
the strategy for U1, and likewise in the case when the spoiler plays in U2. 2
Now assume that Avgε
I is deﬁnable. Again, SC consists of two unary
predicates, U1 and U2. Let Δ = (1 −2ε)/16. Given two ﬁnite sets U1 and U2,
we translate them into intervals [0, Δ] and [1 −Δ, 1]. By translating a ﬁnite
set X with min X = c, max X = d > c into an interval [a, b], we mean that
we map it to the set X′ containing exactly the numbers of the form

5.11 Database Considerations
325
a + (x −c)(b −a)
d −c
,
where x
∈
X; clearly X′
⊂
[a, b]. As the
next step, we deﬁne
U 0
1 = U ′
1 ∪{4Δ −x | x ∈U ′
1} and U 0
2 = U ′
2 ∪{2 −4Δ −x | x ∈U ′
2}.
We observe that U 0
1 ⊆[0, 4Δ] and U 0
2 ⊆[1 −4Δ, 1].
The preceding argument shows that U 0
1 and U 0
2 are FO + Poly-deﬁnable.
Thus, the set C = U 0
1 ∪U 0
2 ⊂[0, 1] is deﬁnable in FO + Poly. Now easy
calculations show that
Avg(C)
=
1
8 −ε
4 +
m
n + m · 3 + 2ε
4
,
where n is the cardinality of U1 and m is the cardinality of U2.
We now deﬁne a sentence Φ by letting D |= Φ iﬀAvgε(C) = Avgε
I(C) >
1/2. Let
c0 = 1 +
16ε
3 −6ε > 1.
Assume that m > c0 · n. Plugging this into the equation for Avg(C), we
derive Avg(C) > 1/2 + ε; thus, in this case, Avgε(C) > 1/2 no matter which
ε-approximation of the average is picked, and thus D |= Φ. Similarly, if we
assume that n > c0·m, we derive Avg(C) < 1/2−ε, and thus Avgε(C) < 1/2
and D |= ¬Φ. Hence, Φ is a (c0, c0)-separating sentence, which is deﬁnable in
FO(SC, ⟨R, Ω, +, ·⟩). This contradiction proves the theorem.
2
We now brieﬂy consider the spatial aggregate operator volume. First,
it is easy to see that it is not deﬁnable in the languages FO + Lin and
FO + Poly. As was mentioned earlier, those languages have the following
fundamental closure property: on a semilinear constraint database D, an
FO + Lin query returns a semilinear set, and likewise, on a semialgebraic
constraint database, an FO + Poly query returns a semialgebraic set.
This closure property can no longer be guaranteed if one allows volume
operators, that is, operators Vol that, for every formula ϕ(⃗x, ⃗y), produce a
formula ψ(⃗x, z) ≡Vol⃗y ϕ(⃗x, ⃗y) such that D |= ψ(⃗a, v) iﬀv = Vol(ϕ(⃗a, D)).
To see this for the semilinear case, consider a semilinear set S ⊆R3 deﬁned
by (x > 0) ∧(0 < y < x) ∧(0 < z < x). Let ϕ(x, y, z) be S(x, y, z). Then
Vol(y, z) ϕ(x, y, z) is true on a pair (a, v) with a > 0 iﬀv = a2, which
shows the failure of closure. In the case of semialgebraic sets, one can deﬁne
functions such as ln x or arctan(x) with the help of the volume. These
functions are not semialgebraic.
Volume is not deﬁnable, but can it be approximated? The reason to
think that this may be the case is the following result. Suppose ϕ(⃗x, ⃗y) is an
FO(R) formula, deﬁning a semialgebraic set S ⊆[0, 1]n+m. Then, for every
ε > 0, there is an FO(R) formula ψε(⃗x, z) such that, for every ⃗a ∈[0, 1]n,
R |= ∃z ϕ(⃗a, z), and for any 0 ≤v ≤1 such that R |= ϕ(⃗a, v), we have
|v −V | < ε, where V is the volume of the set {⃗b ∈[0, 1]m | R |= ϕ(⃗a,⃗b)}.

326
5 Embedded Finite Models and Constraint Databases
To achieve approximability of volume in FO + Poly, we only have to
replace FO(R) formulae by FO(SC, R) (that is, FO + Poly) formulae. This
motivates the following deﬁnition. We say that, for ε > 0, the operator Volε
I
is deﬁnable in FO + Poly if, for every SC and every FO + Poly formula
ϕ(⃗x, ⃗y), there exists a formula ψ(⃗x, z) such that, for any semialgebraic
constraint database D, and every ⃗a ∈[0, 1]n, the following holds:
1. D |= ∃z ψ(⃗a, z), and
2. if D |= ψ(⃗a, v), then 0 ≤v ≤1 and |v −Vol(ϕ(⃗a, D) ∩[0, 1]m)| < ε.
However, it turns out that this innocent-looking move from FO(R) to
FO + Poly (that is, FO(SC , R)) changes the picture completely.
Theorem 5.11.4. The operator Volε
I is not deﬁnable in FO + Poly, for
any ε < 1/2.
Proof sketch. The proof is again by reduction to separating sentences; however,
the reduction is more involved than that for the Avg operator. In particular,
the reduction can only be carried out if the input constraint database is ﬁnite
and has an initial segment of natural numbers as its active domain. To prove
that FO + Poly cannot deﬁne a separating sentence on such structures, one
can no longer use games, and instead has to rely on circuit lower bounds. 2
Note that the bound 1/2 is tight: for every ε > 1/2, Volε
I is deﬁnable, as
the cases where the volume is 0 or 1 can be tested in FO + Poly, and in all
other cases, 1/2 is an approximation.
5.11.2 Higher-Order Features
So far, we have dealt only with ﬁrst-order logic over embedded ﬁnite models
and constraint databases. As we have shown a number of limitations of
FO(SC, M) in both contexts, it is natural to ask how to extend it to
overcome those shortcomings. The question arises in both the embedded
and the constraint setting. In the ﬁrst case, the solution is rather easy, and
essentially follows the standard techniques of (ﬁnite) model theory, such as
adding ﬁxpoint operators or second-order quantiﬁcation. Still, one has to
be careful to avoid getting undecidable languages over nice structures, such
as the real ﬁeld. In the constraint setting, the answer to this question is a
little trickier, but we shall see that nice languages can still be obtained that
express properties such as topological connectivity.
In the embedded case, we deal here only with adding second-order quan-
tiﬁcation, but the reader should see that one can similarly add ﬁxpoint or
transitive closure operators, for example. In the case of constraint databases,
we speciﬁcally consider the case of topological connectivity, although other
topological queries inexpressible in FO + Poly could be considered as well.

5.11 Database Considerations
327
Second-Order Logic over Embedded Finite Models.
One can deﬁne this logic in the general way, as SO(SC , M), by extending
FO(SC, M) with second-order quantiﬁers
∃S ϕ,
∀S ϕ,
where S is a relation symbol not in SC. The semantics is that for some
S ⊆U k, ϕ holds, where k is the arity of S (or ϕ holds for all S, in the case
of the universal quantiﬁer). Alternatively, we can deﬁne an active-semantics
version of the above, where the quantiﬁers are
∃S ∈adom ϕ,
∀S ∈adom ϕ,
and the semantics changes in such a way that S must be a subset of adom(D)k.
We shall denote the fragment of SO(SC, M) in which all – ﬁrst-order and
second-order – quantiﬁers range over the active domain by SOact(SC, M).
We start by noticing the following:
Proposition 5.11.5. Active-generic
collapse
holds
over
every
structure
M for second-order logic. That is, every order-generic query deﬁnable in
SOact(SC , M) is deﬁnable in SOact(SC).
Proof. We expand M to M< by adding a symbol <, interpreted as a linear
order (if it is not there already). The proof now follows the proof for
ﬁrst-order logic, by establishing the Ramsey property (the proof that the
Ramsey property implies the collapse does not change). As the proof of the
Ramsey property is by induction on the formulae, the only additional case to
be considered is that of second-order quantiﬁcation. It is almost the same as
the case of ﬁrst-order quantiﬁcation (see the proof of Proposition 5.5.5). Note
that the order relation < can be eliminated from SOact(SC , <) formulae, as
it is deﬁnable in second-order logic.
2
Establishing natural-active collapse is harder, as the most naive approach
cannot possibly succeed.
Proposition 5.11.6. Every computable property of ﬁnite SC-structures is
expressible in SO(SC , R).
Proof. In second-order logic over R (in fact, even Rlin), one can deﬁne the
set of natural numbers by the following formula ϕ(n):
∃P [P(0)∧(∀x (0 < |x| < 1 →¬P(x)))∧(∀x > 0 (P(x) ↔P(x−1)))] ∧P(n).
Then, for any ﬁnite SC -structure over R, one can state in second-order logic
that there exists an isomorphic structure over N, and in ﬁrst-order logic over
⟨N, +, ·⟩one can test an arbitrary computable property of such a structure. 2

328
5 Embedded Finite Models and Constraint Databases
At
the
same
time,
every
generic
query
in
SOact(SC , R)
is
in
SOact(SC ) and thus its complexity is in the polynomial hierarchy; hence
SO(SC, R) ̸= SOact(SC, R).
To overcome this problem, we introduce a hybrid second-order logic
HSO(SC, M) as a restriction of SO(SC, M), in which all second-order
quantiﬁers range over the active domain (but ﬁrst-order quantiﬁers can still
range over U). Then HSOact(SC , M) is the restriction of HSO(SC, M) in
which all ﬁrst-order quantiﬁers range over the active domain.
Proposition 5.11.7. Let M be o-minimal and admit quantiﬁer elimination.
Then hybrid second-order logic has a natural-active collapse over M: that is,
HSO(SC, M) = HSOact(SC , M). Furthermore, if the theory of M is decidable
and quantiﬁer elimination is eﬀective, then there is an eﬀective transformation
of HSO(SC, M) formulae into equivalent HSOact(SC, M) formulae.
The proof of this result is very similar to the proof in the ﬁrst-order case.
It is by induction on the formulae, with only the case of ∃zα being nontrivial.
In this case, one proves the exact analog of Lemma 5.6.8, by using essentially
the same proof, as the equivalences (∗) in that proof are preserved under the
addition of active-domain second-order quantiﬁers.
Thus, every generic query in HSO(SC , R) is deﬁnable in SOact(SC); that
is, the behavior of hybrid second-order logic is similar to that of ﬁrst-order
logic, as one can apply known bounds from ﬁnite model theory in the
embedded context.
Connectivity and Constraint Databases
While it has been shown that topological connectivity is not deﬁnable in
languages such as FO + Lin and FO + Poly, it is a very useful query in
many applications of spatial databases, and one would want to have a
language capable of expressing it. The situation is somewhat similar to that
of ﬁrst-order logic on ﬁnite relational structures. As FO cannot express graph
connectivity or transitive closure, one enriches the logic by adding ﬁxpoints,
transitive closure operators, or second-order quantiﬁcation, to give it enough
power to express some desirable queries.
A similar approach is unlikely to work for constraint databases. If one
adds ﬁxpoints straightforwardly to FO + Lin or FO + Poly, one loses the
crucial closure property. To see this, note that by iterating the semilinear
relation x = 2y, one obtains relations x = 4y, x = 8y, . . ., x = 2ny, . . ., and
thus one can deﬁne the set of all powers of 2. This set is not semilinear (nor
semialgebraic), which shows that FO + Lin and FO + Poly are not closed
under ﬁxpoint operators.
To remedy this, we take the simplest possible approach: if we need topo-
logical connectivity, we just add it to the language. In this way, we obtain the
languages FO + Poly+C and FO + Lin+C by extending the deﬁnition of the
language by the following: for every formula ϕ(⃗x, ⃗y), there is a new formula

5.11 Database Considerations
329
ψ(⃗x)
≡
C⃗y ϕ(⃗x, ⃗y).
The semantics is as follows. Given a constraint database D, and a tuple ⃗a of
the same length as ⃗x, let ϕ(⃗a, D) = {⃗b | D |= ϕ(⃗a,⃗b)}. Then
D |= ψ(⃗a)
iﬀ
ϕ(⃗a, D) is connected.
The main property of these languages is that they are closed; the proofs,
however, are quite diﬀerent for the semialgebraic and the semilinear case.
Proposition 5.11.8. FO + Poly + C is closed; that is, on a semialgebraic
constraint database, an FO + Poly + C query produces a semialgebraic set.
Proof. The proof is by induction on the formulae. The only nontrivial case
is that of ψ(⃗x) ≡C⃗y ϕ(⃗x, ⃗y). Assume that on D, ϕ deﬁnes a set S ⊆Rn+m,
where n is the length of ⃗x and m is the length of ⃗y. Let S⃗a denote the set
{⃗b | (⃗a,⃗b) ∈S} ⊆Rm for ⃗a ∈Rn. A result in algebraic geometry known
as the Local Triviality Theorem states that for any semialgebraic set S as
deﬁned above, there is a partition Rn = Y1 ∪. . . ∪Yk such that each Yi is
semialgebraic, and for ⃗a1,⃗a2 ∈Yi, the sets S⃗a1 and S⃗a2 are homeomorphic. In
particular, either all sets S⃗a,⃗a ∈Yi are connected, or none of them is. Hence,
the result of ψ on D is a union of some Yis, and thus semialgebraic.
2
The reason we cannot use the same proof for FO + Lin is that the Local
Triviality Theorem fails over Rlin. In the proof above, we used only a part
of that theorem, which says that the ﬁbers S⃗a have ﬁnitely many topological
types. But it also asserts that there are semialgebraic homeomorphisms
between sets S⃗a1 and S⃗a2, ⃗a1,⃗a2 ∈Yi. An analog of this statement does
not hold for semilinear sets, and hence the Local Triviality Theorem is not
applicable in the semilinear case. (In fact, one can prove local triviality for
o-minimal expansions of the real ﬁeld R.)
There are two ways of circumventing the problem. One, quite complex, is
to show that the ﬁrst part of the Local Triviality Theorem still holds for the
case of semilinear sets. But we can also give a simple direct proof of closure
of FO + Lin + C, which does not require the Local Triviality Theorem.
Proposition 5.11.9. FO + Lin + C is closed; that is, on a semilinear
constraint database, an FO + Lin + C query produces a semilinear set.
Proof. The proof again is by induction on the formulae, and we consider only
the case of ψ(⃗x) ≡C⃗y ϕ(⃗x, ⃗y). Assume that on D, ϕ deﬁnes a semilinear set
S ⊆Rn+m. Since S is semilinear, it has a representation of the form
k
i=1
ψi,
ψi ≡
li	
j=1
⟨⃗aij, ⃗x⟩ϑ ⟨⃗bij, ⃗y⟩+ cij
where ⟨·, ·⟩denotes the inner product. Let Zi be the subset of Rn+m deﬁned
by ψi. For every ⃗a ∈Rn, the set Zi
⃗a is a convex polyhedron, and thus it is
connected (unless it is empty).

330
5 Embedded Finite Models and Constraint Databases
Let T1, . . . , Tr be an arbitrary collection of semilinear sets in Rp. Deﬁne
a relation Ti ≈Tj if cl(Ti) ∩Tj ̸= ∅or cl(Tj) ∩Ti ̸= ∅, where cl(·) denotes the
closure of a set. Then T1 ∪. . . ∪Tk is connected iﬀthe undirected graph with
the Tis as vertices and ≈as the edge relation is connected.
Using this fact, we conclude the proof as follows. Given an undirected
graph G on nodes 1, . . . , k, we write ⃗a →D G if
there is an edge (i, j) in G
iﬀ
Zi
⃗a ≈Zj
⃗a.
We have seen earlier that closure is FO + Lin-deﬁnable. Hence, there is an
FO + Lin formula αG(⃗x) such that D |= αG(⃗a) iﬀ⃗a →D G. This and the
statement in the previous paragraph, imply that

G connected
αG(⃗x)
is equivalent to ψ(⃗x), where the disjunction is taken over connected undirected
graphs on {1, . . ., k}. This proves closure, since the above is an FO + Lin
formula.
2
Note that the formula produced in the proof of Proposition 5.11.9 may
be very large, as the number of connected graphs on a k-element set is
exponential in k. It turns out that a much more compact formula can always
be obtained; the proof of this, however, is much more involved than the simple
proof that we provided above. See the bibliographic notes for more detail.
5.12 Bibliographic Notes
Sections 5.2 and 5.3
For a general introduction to ﬁnite model theory, see [31, 48, 57] and the
previous chapters of this book. A standard reference on database theory is [1],
which also covers many topics of ﬁnite model theory. Constraint databases
were introduced in [49]; for a comprehensive treatment of this topic, see [55].
Mixing the ﬁnite and the inﬁnite in the context of databases is discussed
in a number of papers; see, for example, [25, 37]. The semialgebraic “face”
example is taken from [22], and the semilinear one from [55].
Other approaches to combining the ﬁnite and the inﬁnite in model theory
include metaﬁnite structures [37] (which, in our terminology, can be described
as triples consisting of a ﬁnite structure D, an inﬁnite structure M, and a
set of functions from adom(D) to tuples over M), recursive structures [43]
(inﬁnite structures in which every relation is computable, and thus has a ﬁnite
description by means of a Turing machine), and automatic structures [20, 51]
(in which predicates are given by ﬁnite automata, as opposed to arbitrary
Turing machines).

5.12 Bibliographic Notes
331
Section 5.4
The notion of genericity is standard in the ﬁeld of relational databases,
see [1, 46]. Various forms of collapse results were introduced in [11, 45, 61].
Section 5.5
The active-generic collapse was proved independently in [11] and [59]. The
Ramsey property is from [11], and the proof given here follows closely the
one in [15]. Analytic signatures and total collapse are also discussed in [15].
For a survey of Ramsey theory, see [36]. That there exist properties deﬁnable
in FOact(SC, <) but not FOact(SC ) is shown in [1] (the result is attributed
to Gurevich).
Section 5.6
Proposition 5.6.1 is a standard exercise on coding in ﬁrst-order logic over
⟨N, +, ·⟩(cf. [32]); the result was explicitly stated in this form in [41]. The
natural-active collapse without an interpreted structure (Theorem 5.6.3)
was proved in [45]. An earlier weaker result [3] showed that unrestricted
quantiﬁcation can always be replaced by quantiﬁcation over some ﬁnite
superset of the active domain (the “4 Russians Theorem”).
The concept of o-minimality was introduced in [62], and has been
extensively studied in the model-theoretic literature; see [75] for an overview.
The o-minimality of the exponential ﬁeld is from [79]; [74] shows that it does
not have quantiﬁer elimination. The Uniform Bounds Theorem (Theorem
5.6.7) is from [63]. For general model-theoretic properties of structures, see
standard texts such as [26].
The natural-active collapse (Theorem 5.6.4) is from [15]. It was proved
earlier by nonconstructive means in [14]. The linear case, sketched in Section
5.6.4, was proved in [61]. (See also [71].) The material of Sect. 5.6.5 is from [15],
except for Proposition 5.6.10, which is from [34]. A version of the algorithm
for natural-active collapse adapted to FO + Poly was presented in [57].
A diﬀerent proof of natural-active collapse for FO + Poly was given in [8].
It applies only to ﬁnite structures in which all relations are unary, but achieves
much better complexity bounds than the general algorithm presented here.
The natural-generic collapse (Sect. 5.6.7) was the ﬁrst collapse result
proved for polynomial constraints, see [11]. That proof used the technique
of nonstandard universes; here we derived the result as a corollary of the
natural-active collapse. Some extensions of this collapse result are known,
for example for quasi-o-minimal structures [9] (which include all o-minimal
ones, as well as ⟨N, +, <⟩) and for a larger class of structures with ﬁnite VC
dimension (Theorem 5.6.13) [7].
More expressivity bounds were proved in [27], which showed that parity
is not deﬁnable in FO + Poly even if the input is a set of natural numbers

332
5 Embedded Finite Models and Constraint Databases
such that the distance between two consecutive elements is 1 or 2. That
paper also extended some expressivity bounds to algebraically closed ﬁelds.
Section 5.7
For the general model-theoretic background, the reader is referred to [26, 44].
The notion of pseudo-ﬁnite homogeneity was introduced in [9, 34]. Theorem
5.7.3 is from [34], as are the notion of pseudo-ﬁnite saturation and Proposition
5.7.4. The proof of Proposition 5.7.6 uses the fact that term algebras are
stable, and some conditions for showing that a structure does not have the
ﬁnite cover property; these conditions can be found in [44, 64].
The isolation property, Proposition 5.7.8, and Corollary 5.7.9 are from [9].
Proposition 5.7.10 is from [19]. Proposition 5.7.11 is a special case of a
more general result (which shows the isolation property for quasi-o-minimal
structures) in [9]; see also [34].
Section 5.8
For more on the VC dimension and its applications in learning theory,
see [5, 21]. For applications in logic, and for the basic facts used in the proof
of Theorem 5.8.1, see [56, 68, 75]. In particular, [56] shows that o-minimal
structures have ﬁnite VC dimension.
The class AC0/poly used in the section is a standard complexity class
(a.k.a. nonuniform AC0); see, for example, [48, 57]. Bounds for AC0/poly
implying the inexpressibility of queries such as parity and connectivity can
be found in [4, 29, 35].
Theorem 5.8.1 is from [19]. The material of Sect. 5.8.1 is partly from [59]
(which showed one direction of Theorem 5.8.2; the other direction is from [18]).
In [15] it is shown how to use a random ternary relation to express even more
queries (for example, parity), thereby refuting a conjecture in [41] that tied
such expressivity results to the decidability of the theory of the underlying
structure. For basic information about deﬁnability over random graphs (and
more generally, random structures), the reader is referred to [31, 44, 57, 69]).
The material of Sect. 5.8.2, including Proposition 5.8.3, is from [19] (which
gives a slightly better complexity bound). The structure S was studied in [23],
where the connection with regular languages was shown; in [20], which showed
how to interpret automatic structures in it; and in [19], where further model-
theoretic properties, including inﬁnite VC dimension, were proved.
Section 5.9
The material on reductions (Sect. 5.9.1) is from [41], which shows many
inexpressibility results for FO + Poly by reducing them to parity. Topo-
logical properties (Section 5.9.2) of constraint databases were studied

5.12 Bibliographic Notes
333
in [53, 54, 60, 67]. The conical local structure of semialgebraic sets is
described in the texts [10, 22]. Theorem 5.9.3 is from [53]. The failure of
Theorem 5.9.3 for multiple regions was shown in [39].
Sect. 5.9.3 is based on [77], which contains many examples of queries that
are expressible and inexpressible in FO + Lin. More examples of the power of
FO + Lin can be found in [2], where it was also conjectured that ExistsLine
is not expressible in FO + Lin. That was ﬁrst proved in [13], but the proof
was very complicated; the simple proof given here is due to [66]. The result
for the line segment connecting two boundary points is due to [13].
Section 5.10
Safety is a central notion in relational database theory; see [1]. See [78] for
undecidability of safety for ﬁrst-order logic. Safety with scalar functions was
studied in [33]. The STATE-SAFETY problem was introduced in [3, 6],
where decidability was proved for some structures (e.g. ⟨N, <⟩).
The concept of safe translation is from [16]. Proposition 5.10.4 is from [70]
(where a complete description of the structure and the proof of decidability
can be found). Propositions 5.10.5 and 5.10.6 are from [16]. Extensions to
Datalog are discussed in [65, 72].
Sect. 5.10.3 follows [16] closely, except that here we have presented
range-restriction in terms of deﬁnable functions, rather than just algebraic
formulae. For the properties of semilinear and semialgebraic functions used
in the proof of Corollary 5.10.15, see [58, 75].
The reduction from inﬁnite safety to ﬁnite safety (Theorem 5.10.21),
as well as the canonical representation for convex polytopes, is from [16].
More examples of canonical representations can be found in [16]. The ﬁrst
proof of Theorem 5.10.23 is based on applying Theorem 5.10.21 to canonical
representations for semilinear sets, given in [76]. The other proof uses the
decidability of semilinearity, proved in [30].
The decidability result for the safety of conjunctive queries over o-minimal
structures is from [16]; it uses the decidability of containment, proved in [47].
(See also Chapter 2 of [55], which discusses some subtle points related to
the decidability result of [47].) The undecidability of ﬁniteness of the set of
solutions of a Diophantine equation (which proves Proposition 5.10.28) is
from [28]. Proposition 5.10.30 is from [16]. All results in the section on the
Dichotomy Theorem are from [16].
Section 5.11
Aggregation is a standard feature of database query languages [1, 73]. The
results dealing with the average operator are from [17]. How to play a game
on ordered sets is described in [42].

334
5 Embedded Finite Models and Constraint Databases
That volumes can be approximated for ﬁrst-order formulae over the real
ﬁeld was shown in [50, 52]. Theorem 5.11.4, showing that these results do
not extend to constraint databases, is from [17].
Hybrid logics were introduced in [15], where some collapse results were
proved. There exist higher-order logics that capture complexity classes over
constraint databases deﬁned with order [38] and with linear constraints [40].
The material on connectivity is from [12]. The Local Triviality Theorem
used in the proof of Proposition 5.11.8 can be found in [10, 22, 75]. The
proof of Proposition 5.11.9 in [12] is more involved and relies on special
properties of cylindric decompositions [24] of semilinear sets; the simple proof
presented here is due to [80] (the simplicity is achieved at the expense of
exponential-size formulae).
Acknowledgments
Special thanks to Martin Otto who carefully read two early drafts and
provided numerous suggestions. The second draft of this chapter was used in
a seminar at the University of Freiburg; I would like to thank the participants
for their comments, in particular J¨org Flum and Markus Junker. I greatly
beneﬁted from comments and suggestions by Michael Benedikt, Martin
Grohe, Luc Segouﬁn, and Mihalis Yannakakis. Partial support was provided
by grants from NSERC and CITO, by the European Commission Marie Curie
Excellence grant MEXC-CT-2005-024502, and by EPSRC grant E005039.
References
1. S. Abiteboul, R. Hull, and V. Vianu. Foundations of Databases. Addison-Wesley,
1995.
2. F. Afrati, T. Andronikos, and T. Kavalieros. On the expressiveness of query
languages with linear constraints: capturing desirable spatial properties.
In
Constraint Databases and Applications, Lecture Notes in Computer Science
vol. 1191, pages 105–115, Springer 1997.
3. A. K. Ailamazyan, M. M. Gilula, A. P. Stolboushkin and G. F. Shvarts.
Reduction of a relational model with inﬁnite domains to the ﬁnite-domain case.
Doklady Akademii Nauk SSSR, 286(1):308–311, 1986.
Translation in Soviet
Physics – Doklady, 31:11–13, 1986.
4. M. Ajtai. Σ1
1 formulae on ﬁnite structures. Annals of Pure and Applied Logic,
24:1–48, 1983.
5. M. Anthony and N. Biggs.
Computational Learning Theory.
Cambridge
University Press, 1992.
6. A. Avron and J. Hirshfeld. On ﬁrst order database query languages. In IEEE
Symposium on Logic in Computer Science, pages 226–231, 1991.
7. J. Baldwin and M. Benedikt. Stability theory, permutations of indiscernibles,
and embedded ﬁnite models.
Transactions of the American Mathematical
Society 352:4937–4969, 2000.

References
335
8. S. Basu.
New results on quantiﬁer elimination over real closed ﬁelds and
applications to constraint databases. Journal of the ACM, 46:537–555, 1999.
9. O. Belagradek, A. Stolboushkin, and M. Taitslin.
Extended order-generic
queries. Annals of Pure and Applied Logic, 97:85–125, 1999.
10. R. Benedetti and J.-J. Risler. Real Algebraic and Semi-algebraic Sets. Hermann,
Paris, 1990.
11. M. Benedikt, G. Dong, L. Libkin and L. Wong. Relational expressive power of
constraint query languages. Journal of the ACM, 45:1–34, 1998.
12. M. Benedikt, M. Grohe, L. Libkin and L. Segouﬁn. Reachability and connectiv-
ity queries in constraint databases. Journal of Computer and System Sciences,
66(1):169–206, 2003.
13. M. Benedikt and H. J. Keisler. Deﬁnability with a predicate for a semi-linear
set. Journal of Symbolic Logic 68(1):319-351, 2003.
14. M. Benedikt and L. Libkin. On the structure of queries in constraint query lan-
guages. In IEEE Symposium on Logic in Computer Science, pages 25–34, 1996.
15. M. Benedikt and L. Libkin.
Relational queries over interpreted structures.
Journal of the ACM, 47:644–680, 2000.
16. M. Benedikt and L. Libkin.
Safe constraint queries.
SIAM Journal on
Computing, 29:1652–1682, 2000.
17. M. Benedikt and L. Libkin. Aggregate operators in constraint query languages.
Journal of Computer and System Sciences, 64:628–654, 2000.
18. M. Benedikt and L. Libkin. Unpublished notes, 1999.
19. M. Benedikt, L. Libkin, T. Schwentick, and L. Segouﬁn. Deﬁnable relations and
ﬁrst-order query languages over strings. Journal of the ACM, 50(5):694-751,
2003.
20. A. Blumensath and E. Gr¨adel. Automatic structures. In IEEE Symposium on
Logic in Computer Science, pages 51–62, 2000.
21. A. Blumer, A. Ehrenfeucht, D. Haussler, and M. Warmuth. Learnability and
the Vapnik-Chervonenkis dimension. Journal of the ACM, 36:929–965, 1989.
22. J. Bochnak, M. Coste, and M.-F. Roy. Real Algebraic Geometry. Springer, 1998.
23. V. Bruy`ere, G. Hansel, C. Michaux, and R. Villemaire. Logic and p-recognizable
sets of integers. Bulletin of the Belgian Mathematical Society 1:191–238, 1994.
24. B. F. Caviness and J. R. Johnson, eds. Quantiﬁer Elimination and Cylindrical
Algebraic Decomposition. Springer, 1998.
25. A. Chandra and D. Harel. Computable queries for relational databases. Journal
of Computer and System Sciences, 21(2):156–178, 1980.
26. C. C. Chang and H. J. Keisler. Model Theory. North-Holland, 1990.
27. O. Chapuis and P. Koiran. Deﬁnability of geometric properties in algebraically
closed ﬁelds. Mathematical Logic Quarterly, 45:533–550, 1999.
28. M. Davis. On the number of solutions of Diophantine equations. Proceedings
of the AMS, 35:552–554, 1972.
29. L. Denenberg, Y. Gurevich and S. Shelah.
Deﬁnability by constant-depth
polynomial-size circuits. Information and Control, 70:216–240, 1986.
30. F. Dumortier, M. Gyssens, L. Vandeurzen, and D. Van Gucht.
On the
decidability of semi-linearity of semi-algebraic sets, and its implications for
spatial databases. Journal of Computer and System Sciences, 58:535–571, 1999.
Correction in Journal of Computer and System Sciences, 59:557–562, 1999.
31. H.-D. Ebbinghaus and J. Flum. Finite Model Theory. Springer, 1995.
32. H. B. Enderton. A Mathematical Introduction to Logic. Academic Press, New
York, 1972.

336
5 Embedded Finite Models and Constraint Databases
33. M. Escobar-Molano, R. Hull and D. Jacobs. Safety and translation of calculus
queries with scalar functions. In ACM Symposium on Principles of Database
Systems, pages 253–264, 1993.
34. J. Flum and M. Ziegler. Pseudo-ﬁnite homogeneity and saturation. Journal of
Symbolic Logic, 64:1689–1699, 1999.
35. M. Furst, J. Saxe, and M. Sipser.
Parity, circuits, and the polynomial-time
hierarchy. Mathematical Systems Theory, 17:13–27, 1984.
36. R. L. Graham, B .L. Rothschild, and J .H. Spencer. Ramsey Theory. Wiley,
New York, 1990.
37. E. Gr¨adel and Y. Gurevich.
Metaﬁnite model theory.
Information and
Computation, 140:26–81, 1998.
38. E. Gr¨adel and S. Kreutzer.
Descriptive complexity theory for constraint
databases. In Conf. on Computer Science Logic, pages 67–81, 1999.
39. M. Grohe and L. Segouﬁn. On ﬁrst-order topological queries. ACM Transactions
on Computational Logic, 3:336–358, 2002.
40. S. Grumbach and G. Kuper. Tractable recursion over geometric data. In Proc.
of Constraint Programming, pages 450–462, 1997.
41. S. Grumbach and J. Su.
Queries with arithmetical constraints.
Theoretical
Computer Science, 173:151–181, 1997.
42. Y. Gurevich.
Toward logic tailored for computational complexity.
In
Computation and Proof Theory, pages 175–216, Springer 1984.
43. D. Harel.
Towards a theory of recursive structures.
In Conference on
Mathematical Foundations of Computer Science, pages 36–53, 1998.
44. W. Hodges. Model Theory. Cambridge, 1993.
45. R. Hull and J. Su.
Domain independence and the relational calculus.
Acta
Informatica, 31:513–524, 1994.
46. R. Hull and C. K. Yap. The format model: a theory of database organization.
Journal of the ACM, 31:518–537, 1984.
47. O. H. Ibarra and J. Su. A technique for proving decidability of containment
and equivalence of linear constraint queries. Journal of Computer and System
Sciences, 59:1–28, 1999.
48. N. Immerman. Descriptive Complexity. Springer, 1999.
49. P. Kanellakis, G. Kuper, and P. Revesz. Constraint query languages. Journal
of Computer and System Sciences, 51:26–52, 1995. Extended abstract in ACM
Symposium on Principles of Database Systems, pages 299–313, 1990.
50. M. Karpinski and A. Macintyre. Approximating the volume of general Pfaﬃan
bodies. In Structures in Logic and Computer Science: A Selection of Essays in
Honor of A. Ehrenfeucht, Lecture Notes in Computer Science vol. 1261, pages
162–173, Springer 1997.
51. B. Khoussainov and A. Nerode. Automatic presentations of structures. In Logic
and Computational Complexity, Lecture Notes in Computer Science vol. 960,
pages 367–392, Springer 1994.
52. P. Koiran.
Approximating the volume of deﬁnable sets.
In Symposium on
Foundations of Computer Science, pages 134–141, 1995.
53. B. Kuijpers, J. Paredaens, and J. Van den Bussche. Topological elementary
equivalence of closed semi-algebraic sets in the real plane. Journal of Symbolic
Logic, 65:1530–1555, 2000.
54. B. Kuijpers and J. Van den Bussche.
On capturing ﬁrst-order topological
properties of planar spatial databases. In Int. Conf. on Database Theory, pages
187–198, 1999.

References
337
55. G. Kuper, L. Libkin and J. Paredaens, eds. Constraint Databases. Springer,
2000.
56. M. C. Laskowski. Vapnik-Chervonenkis classes of deﬁnable sets. Journal of the
London Mathematical Society, 45:377–384, 1992.
57. L. Libkin. Elements of Finite Model Theory. Springer, 2004.
58. D. Marker, M. Messmer, and A. Pillay. Model Theory of Fields. Springer, 1996.
59. M. Otto and J. Van den Bussche. First-order queries on databases embedded
in an inﬁnite structure. Information Processing Letters, 60:37–41, 1996.
60. C. Papadimitriou, D. Suciu, and V. Vianu.
Topological queries in spatial
databases. Journal of Computer and System Sciences, 58:29–53, 1999.
61. J. Paredaens, J. Van den Bussche, and D. Van Gucht. First-order queries on
ﬁnite structures over the reals.
SIAM Journal on Computing, 27:1747–1763,
1998.
62. A. Pillay and C. Steinhorn. Deﬁnable sets in ordered structures. Bulletin of
the AMS, 11:159–162, 1984.
63. A. Pillay and C. Steinhorn.
Deﬁnable sets in ordered structures. III.
Transactions of the American Mathematical Society, 309:469–476, 1988.
64. B. Poizat. A Course in Model Theory. Springer, 2000.
65. P. Revesz. Safe query languages for constraint databases. ACM Transactions
on Database Systems, 23:58–99, 1998.
66. L. Segouﬁn. Personal communication, 2001.
67. L. Segouﬁn and V. Vianu. Querying spatial databases via topological invariants.
Journal of Computer and System Sciences, 61:270–301, 2000.
68. S. Shelah.
Stability, the f.c.p., and superstability.
Annals of Mathematical
Logic, 3:271–362, 1971.
69. J. Spencer. The Strange Logic of Random Graphs. Springer, 2001.
70. A. Stolboushkin and M. Taitslin. Finite queries do not have eﬀective syntax.
Information and Computation, 153:99–116, 1999.
71. A. Stolboushkin and M. Taitslin.
Linear vs. order constraint queries over
rational databases.
In ACM Symposium on Principles of Database Systems,
pages 17–27, 1999.
72. A. Stolboushkin and M. Taitslin. Safe stratiﬁed datalog with integer order does
not have syntax. ACM Transactions on Database Systems, 23:100–109, 1998.
73. J. D. Ullman and J. Widom. A First Course in Database Systems. Prentice-Hall,
1997.
74. L. van den Dries.
Remarks on Tarski’s problem concerning (R,+,*,exp). In
Logic Colloquium 82, pages 97–121, North-Holland, 1984.
75. L. van den Dries.
Tame Topology and O-Minimal Structures.
Cambridge
University Press, 1998.
76. L. Vandeurzen, M. Gyssens, and D. Van Gucht. An expressive language for
linear spatial database queries. In ACM Symposium on Principles of Database
Systems, pages 109–118, 1998.
77. L. Vandeurzen, M. Gyssens and D. Van Gucht.
On the expressiveness of
linear-constraint query languages for spatial databases. Theoretical Computer
Science 254:423–463, 2001.
78. M. Y. Vardi. The decision problem for database dependencies.
Information
Processing Letters, 12:251–254, 1981.
79. A. J. Wilkie. Model completeness results for expansions of the ordered ﬁeld
of real numbers by restricted Pfaﬃan functions and the exponential function.
Journal of the American Mathematical Society, 9:1051–1094, 1996.
80. M. Yannakakis. Personal communication, 1999.


6
A Logical Approach to Constraint Satisfaction
Phokion G. Kolaitis and Moshe Y. Vardi
6.1 Introduction
Since the early 1970s, researchers in artiﬁcial intelligence (AI) have investi-
gated a class of combinatorial problems that have become known, collectively,
as the Constraint-Satisfaction problem (CSP). The input to such
a problem consists of a set of variables, a set of possible values for the
variables, and a set of constraints between the variables; the question is to
determine whether there is an assignment of values to the variables that
satisﬁes the given constraints. The study of constraint satisfaction occupies
a prominent place in artiﬁcial intelligence, because many problems that arise
in various areas can be modeled as constraint-satisfaction problems in a
natural way; these areas include Boolean satisﬁability, temporal reasoning,
belief maintenance, machine vision, and scheduling (see [20, 50, 56, 64]). In
its full generality, constraint satisfaction is an NP-complete problem. For this
reason, researchers in artiﬁcial intelligence have pursued both heuristics for
constraint-satisfaction problems and tractable cases obtained by imposing
various restrictions on the input (see [20, 24, 34, 54, 58]).
Over the past decade, it has become clear that there is an intimate
connection between constraint satisfaction and various problems in database
theory and ﬁnite-model theory. The goal of this chapter is to describe several
such connections. We start in Sect. 6.2 by deﬁning the constraint-satisfaction
problem and showing how it can be phrased also as a homomorphism prob-
lem, a conjunctive-query evaluation problem, or a join-evaluation problem. In
Sect. 6.3, we discuss the computational complexity of constraint satisfaction
and show that it can be studied from two perspectives, a uniform perspective
and a nonuniform perspective. We relate both perspectives to the study of
the computational complexity of query evaluation. In Sect. 6.4, we focus
on the nonuniform case and describe a Dichotomy Conjecture, asserting
that every nonuniform constraint-satisfaction problem is either in PTIME
or NP-complete. In Sect. 6.5, we examine the complexity of nonuniform
constraint satisfaction from a logical perspective and show that it is related

340
6 Constraint Satisfaction
to the data complexity of a fragment of existential second-order logic. We
continue in Sect. 6.6, where we oﬀer a logical approach, via deﬁnability in
Datalog, to establishing the tractability of nonuniform constraint-satisfaction
problems. In Sect. 6.7, we leverage the connection between Datalog and
certain pebble games, and show how these pebble games oﬀer an algorithmic
approach to solving uniform constraint-satisfaction problems. In Sect. 6.8, we
relate these pebble games to consistency properties of constraint-satisfaction
instances, a well-known approach in constraint solving. Finally, in Sect. 6.9,
we show how the same pebble games can be used to identify large “islands
of tractability” in the constraint-satisfaction terrain that are based on the
concept of bounded treewidth.
Much of the logical machinery used in this chapter is described in detail
in Chap. 2. For a book-length treatment of constraint satisfaction from
the perspective of graph homomorphism, see [44]. Two books on constraint
programming and constraint processing are [3, 23].
6.2 Preliminaries
The standard terminology in AI formalizes an instance P of constraint
satisfaction as a triple (V, D, C), where
•
V is a set of variables;
•
D is a set of values, referred to as the domain;
•
C is a collection of constraints C1, . . . , Cq, where each constraint Ci is
a pair (t, R), and where t is a k-tuple over V , k ≥1, referred to as the
scope of the constraint, and R is a k-relation on D.
A solution of such an instance is a mapping h : V →D such that, for each
constraint (t, R) in C, we have that h(t) ∈R, where h is deﬁned on tuples
componentwise, that is, if t = (a1, . . . , ak), then h(t) = (h(a1), . . . , h(ak)).
The Constraint-Satisfaction problem asks whether a given instance is
solvable, i.e., whether it has a solution. Note that, without loss of generality,
we may assume that all constraints (t, Ri) involving the same scope t have
been consolidated into a single constraint (t, R), where R is the intersection
of all relations Ri constraining t. Thus, we can assume that each tuple t of
variables occurs at most once in the collection C.
Consider the Boolean satisﬁability problem 3-Sat: given a 3CNF-formula
ϕ with variables x1, . . . , xn and clauses c1, . . . , cm, is ϕ satisﬁable? Such
an instance of 3-Sat can be thought of as a Constraint-Satisfaction
instance in which the set of variables is V = {x1, . . . , xn}, the domain is
D = {0, 1}, and the constraints are determined by the clauses of ϕ. For
example, a clause of the form (¬x ∨¬y ∨z) gives rise to the constraint
((x, y, z), {0, 1}3 −{(1, 1, 0)}). In an analogous manner, 3-Colorability can
be modeled as a Constraint-Satisfaction problem. Indeed, an instance

6.2 Preliminaries
341
G = (V, E) of 3-Colorability can be thought of as a Constraint-
Satisfaction instance in which the set of variables is the set V of the
nodes of the graph G, the domain is the set D = {r, b, g} of three col-
ors, and the constraints are the pairs ((u, v), Q), where (u, v) ∈E and
Q = {(r, b)(b, r), (r, g)(g, r), (b, g)(g, b)} is the disequality relation on D.
Let A and B be two relational structures1 over the same vocabulary. A
homomorphism h from A to B is a mapping h : A →B from the universe A
of A to the universe B of B such that, for every relation RA of A and every
tuple (a1, . . . , ak) ∈RA, we have that (h(a1), . . . , h(ak)) ∈RB. The existence
of a homomorphism from A to B is denoted by A →B, or by A →h B,
when we want to name the homomorphism h explicitly. An important
observation made in [29]2 is that every such constraint-satisfaction instance
P = (V, D, C) can be viewed as an instance of the Homomorphism problem,
asking whether there is a homomorphism between two structures AP and
BP that are obtained from P in the following way:
•
The universe of AP is V and the universe of BP is D;
•
The relations of BP are the distinct relations R occurring in C;
•
The relations of AP are deﬁned as follows: for each distinct relation R on
D occurring in C, we have the relation RA = {t : (t, R) ∈C}. Thus, RA
consists of all scopes associated with R.
We call (AP, BP) the homomorphism instance of P. Conversely, it is also clear
that every instance of the homomorphism problem between two structures A
and B can be viewed as a constraint-satisfaction instance CSP(A, B) by sim-
ply “breaking up” each relation RA on A as follows: we generate a constraint
(t, RB) for each t ∈RA. We call CSP(A, B) the constraint-satisfaction
instance of (A, B). Thus, as pointed out in [29], the constraint-satisfaction
problem can be identiﬁed with the homomorphism problem.
To illustrate the passage from the constraint-satisfaction problem to the
homomorphism problem, let us consider 3-Sat. A 3CNF-formula ϕ with
variables x1, . . . , xn and clauses c1, . . . , cm gives rise to a homomorphism
instance (Aϕ, Bϕ), deﬁned as follows:
•
Aϕ = ({x1, . . . , xn}, Rϕ
0 , Rϕ
1 , Rϕ
2 , Rϕ
3 ), where Rϕ
i is the ternary relation
consisting of all triples (x, y, z) of variables that occur in a clause of ϕ with i
negated literals, 0 ≤i ≤3; for instance, Rϕ
2 consists of all triples (x, y, z) of
variables such that (¬x∨¬y ∨z) is a clause of ϕ (here, we assume without
loss of generality that the negated literals precede the positive literals).
•
Bϕ
=
({0, 1}, R0, R1, R2, R3), where Ri consists of all triples that
satisfy a 3-clause in which the ﬁrst i literals are negated; for instance,
R2 = {0, 1}3 −{1, 1, 0}.
Note that Bϕ does not depend on ϕ. It is clear that ϕ is satisﬁable if and
only if there is a homomorphism from Aϕ to Bϕ (in symbols, Aϕ →Bϕ).
1 We consider only ﬁnite structures in this chapter.
2 An early version appeared in [30].

342
6 Constraint Satisfaction
As another example, 3-Colorability is equivalent to the problem of
deciding whether there is a homomorphism h from a given graph G to the
complete graph K3 = ({r, b, g}, {(r, b)(b, r), (r, g)(g, r), (b, g)(g, b)} with three
nodes. More generally, k-Colorability, k ≥2, amounts to the existence of
a homomorphism from a given graph G to the complete graph Kk with k
nodes (also known as the k-clique).
Numerous other important NP-complete problems can be viewed as
special cases of the Homomorphism problem (and, hence, also of the
Constraint-Satisfaction problem). For example, consider the Clique
problem: given a graph G and an integer k, does G contain a clique of size
k? Considered as a Homomorphism instance this is equivalent to asking if
there is a homomorphism from the complete graph Kk to G. Considered as
a Constraint-Satisfaction instance, the set of variables is {1, 2, . . ., k},
the domain is the set V of nodes of G, and the constraints are the pairs
((i, j), E) such that i ̸= j, 1 ≤i, j ≤k, and E is the edge relation of G.
For another example, consider the Hamiltonicity problem: given a graph
G = (V, E), does it have a Hamiltonian cycle? This is equivalent to asking
if there is a homomorphism from the structure (V, CV , ̸=) to the structure
(V, E, ̸=), where CV is some cycle on the set V of nodes of G and ̸= is the
disequality relation on V . The NP-completeness of the Homomorphism
problem was pointed out explicitly in [53]. In this chapter, we use both the
traditional AI formulation of constraint satisfaction and the formulation in
terms of the Homomorphism problem, as each has its own advantages.
It turns out that in both formulations constraint satisfaction can be
expressed as a database-theoretic problem. We start with the homomorphism
formulation, which is intimately related to conjunctive-query evaluation [48].
A conjunctive query Q of arity n is a query deﬁnable by a positive exis-
tential ﬁrst-order formula ϕ(X1, . . . , Xn) that has conjunction as its only
propositional connective, that is, by a formula of the form
∃Z1 . . . ∃Zmψ(X1, . . . , Xn, Z1, . . . , Zm),
where ψ(X1, . . . , Xn, Z1, . . . , Zm) is a conjunction of (positive) atomic
formulas. The
free
variables X1, . . . , Xn
of
the
deﬁning
formula
are
called the distinguished variables of Q. Such a conjunctive query is usu-
ally written as a rule, whose head is Q(X1, . . . , Xn) and whose body is
ψ(X1, . . . , Xn, Z1, . . . , Zm). For example, the formula
∃Z1∃Z2(P(X1, Z1, Z2) ∧R(Z2, Z3) ∧R(Z3, X2))
deﬁnes a binary conjunctive query Q, which becomes, in the form of a rule,
Q(X1, X2) :- P(X1, Z1, Z2), R(Z2, Z3), R(Z3, X2).
If a formula deﬁning a conjunctive query Q has no free variables (i.e., if it is a
sentence), then Q is a Boolean conjunctive query. For example, the sentence

6.2 Preliminaries
343
∃Z1∃Z2∃Z3(E(Z1, Z2) ∧E(Z2, Z3) ∧E(Z3, Z1))
deﬁnes the Boolean conjunctive query “is there a cycle of length 3?”.
If D is a database and Q is a n-ary query, then Q(D) is the n-ary relation
on D obtained by evaluating the query Q on D, that is, the collection of all
n-tuples from D that satisfy the query (see Chap. 2). The Conjunctive-
Query Evaluation problem asks: given a n-ary query Q, a database D, and
an n-tuple a from D, is a ∈Q(D)? Let Q1 and Q2 be two n-ary queries that
have the same tuple of distinguished variables. We say that Q1 is contained
in Q2, and write Q1 ⊆Q2, if Q1(D) ⊆Q2(D) for every database D. The
Conjunctive-Query Containment problem asks: given two conjunctive
queries Q1 and Q2, is Q1 ⊆Q2? These concepts can be deﬁned for Boolean
conjunctive queries in an analogous manner. In particular, if Q is a Boolean
query and D is a database, then Q(D) = 1 if D satisﬁes Q; otherwise,
Q(D) = 0. Moreover, the containment problem for Boolean queries Q1 and
Q2 is equivalent to asking whether Q1 logically implies Q2.
It is well known that conjunctive-query containment can be reformulated
both as a Conjunctive-Query Evaluation problem and as a Homo-
morphism problem. What links these problems together is the canonical
database DQ associated with Q. This database is deﬁned as follows. Each
variable occurring in Q is considered a distinct element in the universe
of DQ. Every predicate in the body of Q is a predicate of DQ as well;
moreover, for every distinguished variable Xi of Q, there is a distinct
monadic predicate Pi (not occurring in Q). Every subgoal in the body of
Q gives rise to a tuple in the corresponding predicate of DQ; moreover, if
Xi is a distinguished variable of Q, then Pi(Xi) is also a (monadic) tuple
of DQ. Thus, returning to the preceding example, the canonical database
of the conjunctive query ∃Z1∃Z2(P(X1, Z1, Z2) ∧R(Z2, Z3) ∧R(Z3, X2))
consists of the facts P(X1, Z1, Z2), R(Z2, Z3), R(Z3, X2), P1(X1), P2(X2).
The relationship between conjunctive-query containment, conjunctive-query
evaluation, and homomorphisms is provided by the following classical result,
due to Chandra and Merlin.
Theorem 6.2.1. [11] Let Q1 and Q2 be two conjunctive queries that have the
same tuple (X1, . . . , Xn) of distinguished variables. The following statements
are then equivalent:
•
Q1 ⊆Q2.
•
(X1, . . . , Xn) ∈Q2(DQ1).
•
There is a homomorphism h : DQ2 →DQ1.
It follows that the Homomorphism problem can be viewed as a
Conjunctive-Query Evaluation problem or as a Conjunctive-Query
Containment problem. For this purpose, for a structure A, we view the
universe A = {X1, . . . , Xn} of A as a set of individual variables and associate
with A the Boolean conjunctive query ∃X1 . . . ∃Xn ∧t∈RA R(t); we call this

344
6 Constraint Satisfaction
query the canonical conjunctive query of A and denote it by QA. It is clear
that A is isomorphic to the canonical database associated with QA.
Corollary 6.2.2. Let A and B be two structures over the same vocabulary.
The following statements are then equivalent:
•
A →B.
•
B |= QA.
•
QB ⊆QA.
As an illustration, we have that a graph G is 3-colorable iﬀK3 |= QG iﬀ
QK3 ⊆QG.
A relational join, denoted by the symbol 1, is a conjunctive query
with
no
existentially
quantiﬁed
variables.
Thus,
relational-join
evalu-
ation is a special case of conjunctive-query evaluation. For example,
E(Z1, Z2)∧E(Z2, Z3)∧E(Z3, Z1) is a relational join that, when evaluated on
a graph G = (V, E), returns all triples of nodes forming a 3-cycle. There is a
well-known connection between the traditional AI formulation of constraint
satisfaction and the formulation in terms of relational-join evaluation that we
describe next. Suppose we are given a Constraint-Satisfaction instance
(V, D, C). We can assume without loss of generality that, in every constraint
(t, R) ∈C, the elements in t are distinct. (Suppose to the contrary that
ti = tj. Then we can delete from R every tuple in which the ith and jth
entries disagree, and then project out that j-th column from t and R.) We can
thus view every element of V as a relational attribute, every tuple of distinct
elements of V as a relational schema, and every constraint (t, R) as a relation
R over the schema t (see [1]). It now follows from the deﬁnition of constraint
satisfaction that CSP can be viewed as a relational-join evaluation problem.
Proposition 6.2.3.
[6, 42] A constraint-satisfaction instance (V, D, C) is
solvable if and only if 1(t,R)∈C R is nonempty.
Note that Proposition 6.2.3 is essentially the same as Corollary 6.2.2.
Indeed, the condition B |= QA amounts to the nonemptiness of the relational
join obtained from QA by dropping all existential quantiﬁers and using the
relations from B as interpretations of the relational symbols in QA. Moreover,
the homomorphisms from A to B are precisely the tuples in the relational
join associated with the constraint-satisfaction instance CSP(A, B).
6.3 The Computational Complexity
of Constraint Satisfaction
The Constraint-Satisfaction problem is NP-complete, because it is
clearly in NP and also contains NP-hard problems as special cases, including
3-Sat, 3-Colorability, and Clique. As explained in Garey and Johnson’s

6.3 The Computational Complexity of Constraint Satisfaction
345
classic monograph [36], one of the main ways to cope with NP-completeness
is to identify polynomial-time solvable cases of the problem at hand that
are obtained by imposing restrictions on the possible inputs. For instance,
Horn 3-Sat, the restriction of 3-Sat to Horn 3CNF-formulas, is solvable in
polynomial-time using a unit-propagation algorithm. Similarly, it is known
that 3-Colorability restricted to graphs of bounded treewidth is solvable
in polynomial time (see [26]). In the case of constraint satisfaction, the
pursuit of tractable cases has evolved over the years from the discovery of
isolated cases to the discovery of large “islands of tractability” of constraint
satisfaction. In what follows, we give an account of some of the progress made
in this area. Using the fact that the Constraint-Satisfaction problem
can be identiﬁed with the Homomorphism problem, we begin by introducing
some terminology and notation that will enable us to formalize the concept
of an “island of tractability” of constraint satisfaction.
In general, an instance of the Homomorphism problem consists of two
relational structures A and B. Thus, all restricted cases of this problem can
be obtained by imposing restrictions on the input structures A and B.
Deﬁnition 6.3.1. Let A, B be two classes of relational structures. We write
CSP(A, B) to denote the restriction of the Homomorphism problem to input
structures from A and B. In other words,
CSP(A, B) = {(A, B) : A ∈A, B ∈B and A →B}.
An island of tractability of constraint satisfaction is a pair (A, B) of
classes of relational structures such that CSP(A, B) is in the complexity class
PTIME of all decision problems solvable in polynomial time.
(A more general deﬁnition of islands of tractability of constraint satisfaction
would consider classes of pairs (A, B) of structures, see [28]. We do not
pursue this more general deﬁnition here.)
The ultimate goal in the pursuit of islands of tractability of constraint
satisfaction is to identify or characterize classes A and B of relational
structures such that CSP(A, B) is in PTIME. The basic starting point in
this investigation is to consider the cases in which one of the two classes
A, B is as small as possible, while the other is as large as possible. This
amounts to considering the cases in which one of A, B is the class All of all
relational structures over some arbitrary, but ﬁxed, relational vocabulary,
while the other is a singleton, consisting of some ﬁxed structure over that
vocabulary. Thus, the starting point of the investigation is to determine, for
ﬁxed relational structures A, B, the computational complexity of the decision
problems CSP({A}, All) and CSP(All, {B}).
Clearly, for each ﬁxed A, the decision problem CSP({A}, All) can be
solved in polynomial time, because, given a structure B, the existence of a
homomorphism from A to B can be checked by testing all functions h from
the universe A of A to the universe B of B (the total number of such functions

346
6 Constraint Satisfaction
is |B||A|, which is a polynomial number in the size of the structure B when A
is ﬁxed). Thus, having a singleton structure “on the left’ is of little interest.
At the other extreme, however, the situation is quite diﬀerent, since the
computational complexity of CSP(All, {B}) may very well depend on the
particular structure B. Indeed, CSP(All, {K3}) is NP-complete, because it is
the 3-Colorability problem; in contrast, CSP(All, {K2}) is in P, because
it is the 2-Colorability problem. For simplicity, in what follows, for every
ﬁxed structure B, we deﬁne CSP(B) = CSP(All, {B}) and call this the
nonuniform Constraint-Satisfaction problem associated with B. For
such problems, we refer to B as the template. Thus, the ﬁrst major goal in
the study of the computational complexity of constraint satisfaction is to
identify those templates B for which CSP(B) is in PTIME. This goal gives
rise to an important open decision problem:
The Tractability-Classification problem: Given a relational structure
B, decide whether CSP(B) is in PTIME.
In addition to the family of nonuniform constraint-satisfaction problems
CSP(B), where B is a relational structure, we also study decision problems
of the form CSP(A, All), where A is a class of structures. We refer to such
problems as uniform Constraint-Satisfaction problems.
It is illuminating to consider the complexity of uniform and nonuniform
constraint satisfaction from the perspective of query evaluation. As argued
in [67] (see Chap. 2), there are three ways to measure the complexity of
evaluating queries (we focus here on Boolean queries) expressible in a query
language L:
•
The combined complexity of L is the complexity of the following decision
problem: given an L-query Q and a structure A, does A |= Q? In symbols,
{⟨Q, A⟩: Q ∈L and A |= Q}.
•
The expression complexity of L is the complexity of the following decision
problems, one for each ﬁxed structure A:
{Q : Q ∈L and A |= Q}.
•
The data complexity of L is the complexity of the following decision
problems, one for each ﬁxed query Q ∈L:
{A : A |= Q}.
As discussed in Chap. 2, the data complexity of ﬁrst-order logic is in
LOGSPACE, which means that, for each ﬁrst-order query Q, the problem
{A : A |= Q} is in LOGSPACE. In contrast, the combined complexity for
ﬁrst-order logic is PSPACE-complete. Furthermore, the expression complex-
ity for ﬁrst-order logic is also PSPACE-complete. In fact, for all but trivial

6.4 Nonuniform Constraint Satisfaction
347
structures A, the problem {Q : Q ∈FO and A |= Q} is PSPACE-complete.
This exponential gap between data complexity, on one hand, and combined
and expression complexity, on the other hand, is typical [67]. For conjunctive
queries, on the other hand, both the combined complexity and the expression
complexity are NP-complete.
Consider now the uniform constraint-satisfaction problem CSP(A, All) =
{(A, B) : A ∈A, and A →B}, where A is a class of structures. By
Corollary 6.2.2, we have that
CSP(A, All) = {(A, B) : A ∈A, B is a structure and B |= QA}.
Thus, studying the complexity of uniform constraint satisfaction amounts
to studying the combined complexity for a class of conjunctive queries, as
considered, for example, in [12, 39, 62]. In contrast, consider the nonuniform
Constraint-Satisfaction problem CSP(B) = {A : A →B}. By Corol-
lary 6.2.2, we have that CSP(B) = {A : B |= QA}. Thus, studying the com-
plexity of nonuniform constraint satisfaction amounts to studying the expres-
sion complexity of conjunctive queries with respect to diﬀerent structures.
This is a problem that has not been studied in the context of database theory.
6.4 Nonuniform Constraint Satisfaction
The ﬁrst major result in the study of nonuniform constraint-satisfaction
problems was obtained by Schaefer [63], who, in eﬀect, classiﬁed the com-
putational complexity of all Boolean nonuniform constraint-satisfaction
problems. A Boolean structure is simply a relational structure with a
2-element universe, that is, a structure of the form B = ({0, 1}, RB
1 , . . . , RB
m).
A Boolean nonuniform constraint-satisfaction problem is a problem of the
form CSP(B) with a Boolean template B. These problems are also known as
Generalized-Satisfiability problems, because they can be viewed as vari-
ants of Boolean-satisﬁability problems in which the formulas are conjunctions
of generalized connectives [36]. In particular, they contain the well-known
problems k-Sat, k ≥2, 1-in-3-Sat, Positive 1-in-3-Sat, Not-All-Equal
3-Sat, and Monotone 3-Sat as special cases. For example, as seen earlier,
3-Sat is CSP(B), where B = ({0, 1}, R0, R1, R2, R3) and Ri is the set of
all triples that satisfy a 3-clause in which the ﬁrst i literals are negated, for
i = 0, 1, 2, 3 (thus, R0 = {0, 1}3 −{(0, 0, 0)}). Similarly, Monotone 3-Sat
is CSP(B), where B = ({0, 1}, R0, R3).
Ladner [51] showed that if PTIME ̸= NP, then there are decision problems
in NP that neither are NP-complete nor belong to PTIME. Such problems
are called intermediate problems. Consequently, it is conceivable that a given
family of NP-problems contains intermediate problems. Schaefer [63], how-
ever, showed that the family of all Boolean nonuniform constraint-satisfaction
problems contains no intermediate problems.

348
6 Constraint Satisfaction
Theorem 6.4.1. (Schaefer’s Dichotomy Theorem [63])
•
If B = ({0, 1}, RB
1 , . . . , RB
m) is a Boolean structure, then either CSP(B)
is in PTIME or CSP(B) is NP-complete.
•
The Tractability-Classification problem for Boolean structures is
decidable; in fact, there is a polynomial-time algorithm to decide, given a
Boolean structure B, whether CSP(B) is in PTIME or is NP-complete.
Schaefer’s Dichotomy Theorem can be described pictorially as in Fig. 6.1.
Schaefer [63] actually showed that there are exactly six types of Boolean
structures such that CSP(B) is in PTIME, and provided explicit descriptions
of them. Speciﬁcally, he showed that CSP(B) is in PTIME precisely when at
least one of the following six conditions is satisﬁed:
•
Every relation RB
i , 1 ≤i ≤m, of B is 0-valid, that is, RB
i
contains the
all-zeros tuple (0, . . . , 0).
•
Every relation RB
i , 1 ≤i ≤m, of B is 1-valid, that is, RB
i
contains the
all-ones tuple (1, . . . , 1).
•
Every relation RB
i , 1 ≤i ≤m, of B is bijunctive, that is, RB
i is the set of
truth assignments satisfying some 2-CNF formula.
•
Every relation RB
i , 1 ≤i ≤m, of B is Horn, that is, RB
i
is the set of
truth assignments satisfying some Horn formula.
•
Every relation RB
i , 1 ≤i ≤m, of B is dual Horn, that is, RB
i is the set
of truth assignments satisfying some dual Horn formula.
•
Every relation RB
i , 1 ≤i ≤m, of B is aﬃne, that is, RB
i
is the set of
solutions to a system of linear equations over the two-element ﬁeld.
Schaefer’s Dichotomy Theorem established a dichotomy and a decidable
classiﬁcation of the complexity of CSP(B) for Boolean templates B. After
that result, Hell and Neˇsetˇril [43] established a dichotomy theorem for CSP(B)
problems in which the template B is an undirected graph: if B is bipartite, then
CSP(B) is solvable in polynomial time; otherwise, CSP(B) is NP-complete. To
illustrate this dichotomy theorem, let Cn, n ≥3, be a cycle with n elements.
Then CSP(Cn) is in PTIME if n is even, and is NP-complete if n is odd.
↗
NP-complete
CSP(B)
NP −PTIME, not NP-complete
↘
P
Fig. 6.1. Dichotomy Theorem

6.4 Nonuniform Constraint Satisfaction
349
The preceding two dichotomy results raise the challenge of classifying the
computational complexity of CSP(B) for arbitrary relational templates B.
Addressing this question, Feder and Vardi formulated the following conjecture.
Conjecture 6.4.2. (Dichotomy Conjecture [29]) If B = (B, RB
1 , . . . , RB
m)
is an arbitrary relational structure, then either CSP(B) is in PTIME or
CSP(B) is NP-complete.
In other words, the Dichotomy Conjecture says that the picture above
describes the complexity of nonuniform constraint-satisfaction problems
CSP(B) for arbitrary structures B. The basis for the conjecture is not only
the evidence from Boolean constraint satisfaction and undirected constraint
satisfaction, but also from our seeming inability to carry out the diagonaliza-
tion argument of [51] using the constraint-satisfaction machinery [27].
The Dichotomy Conjecture inspired intensive research eﬀorts that
signiﬁcantly advanced our understanding of the complexity of nonuniform
constraint satisfaction. In particular, Bulatov conﬁrmed two important
cases of this conjecture. We say that a structure B = (B, RB
1 , . . . , RB
m) is a
3-element structure if B contains at most three elements. We say that B is
conservative if all possible monadic relations on the universe are included,
that is, every nonempty subset of B is one of the relations RB
i of B.
Theorem 6.4.3. [8, 9] If B a 3-element structure or a conservative struc-
ture, then either CSP(B) is in PTIME or CSP(B) is NP-complete. Moreover,
in both cases the Tractability-Classification problem is decidable in
polynomial time.
In spite of the progress made, the Dichotomy Conjecture remains unre-
solved in general. The research eﬀorts towards this conjecture, however, have
also resulted in the discovery of broad suﬃcient conditions for tractability
and intractability of nonuniform constraint satisfaction that have provided
unifying explanations for numerous seemingly disparate tractability and
intractability results, and have also led to the discovery of new islands
of tractability of CSP(B). These broad suﬃcient conditions are based on
concepts and techniques from two diﬀerent areas: universal algebra and logic.
The approach via universal algebra yields suﬃcient conditions for
tractability of CSP(B) in terms of closure properties of the relations in B
under certain functions on its universe B. Let R be a n-ary relation on a set
B and let f : Bk →B a k-ary function. We say that R is closed under f, if
whenever t1 = (t1
1, t2
1, . . . , tn
1), . . . , tk = (t1
k, t2
k, . . . , tn
k) are k (not necessarily
distinct) tuples in R, then the tuple
(f(t1
1, . . . , t1
k), f(t2
1, . . . , t2
k), . . . , f(tn
1, . . . , tn
k))
is also in R. We say that f : Bk →B is a polymorphism of a structure
B = (B, R1, . . . , Rm) if each of the relations Rj, 1 ≤j ≤m, is closed under
f. It is easy to see that f is a polymorphism of B if and only if f is a

350
6 Constraint Satisfaction
homomorphism from Bk to B, where Bk is the kth power of B. By deﬁnition,
the kth power Bk is the structure (Bk, R′
1 . . . , R′
m) over the same vocabulary
as B with universe Bk and relations R′
j, 1 ≤j ≤m, deﬁned as follows: if
Rj is of arity n, then R′
j(s1, . . . , sn) holds in Bk if and only if Rj(si
1, . . . , si
n)
holds in B for 1 ≤i ≤n.
We write Pol(B) for the set of all polymorphisms of B. As it turns out,
the complexity of CSP(B) is intimately connected to the kinds of functions
that Pol(B) contains. This connection was ﬁrst unveiled in [29], and explored
in depth by Jeavons and his collaborators; for a recent survey, see [10].
In particular, they showed that if Pol(B1) = Pol(B2) for two structures
B1 and B2 (over ﬁnite vocabularies), then CSP(B1) and CSP(B2) are
polynomially reducible to each other. Thus, the polymorphisms of a template
B characterize the complexity of CSP(B). The above-mentioned dichotomy
results for 3-element and conservative constraint satisfaction are based on a
rather deep analysis of the appropriate sets of polymorphisms.
6.5 Monotone Monadic SNP and Nonuniform
Constraint Satisfaction
We discussed earlier how nonuniform constraint satisfaction is related to the
study of the expression complexity of conjunctive queries. We now show that
it can also be viewed as the study of the data complexity of second-order
logic. This will suggest a way to identify islands of tractability via logic.
As described in Chaps. 2 and 3, existential second-order logic (ESO)
deﬁnes, by Fagin’s Theorem, precisely the complexity class NP. The class
SNP (for strict NP) [46, 57] is a fragment of ESO, consisting of all existential
second-order sentences with a universal ﬁrst-order part, namely sentences of
the form (∃S′)(∀x)Φ(x, S, S′), where Φ is a ﬁrst-order quantiﬁer-free formula.
We refer to the relations over the input vocabulary S as input relations and
to the relations over the quantiﬁed vocabulary S′ as existential relations.
3-Sat is an example of an SNP problem. The input structure consists of four
ternary relations C0, C1, C2, C3, on the universe {0, 1}, where Ci corresponds
to a clause with three variables, with the ﬁrst i of them negated. There is
a single existential monadic relation T describing a truth assignment. The
condition that must be satisﬁed states that for all x1, x2, x3, if C0(x1, x2, x3)
then T (x1) or T (x2) or T (x3), and similarly for the remaining Ci by negating
T (xj) if j ≤i. Formally, we can express 3-Sat with the SNP sentence
(∃T )(∀x1, x2, x3) ((C0(x1, x2, x3) →T (x1) ∨T (x2) ∨T (x3))∧
(C1(x1, x2, x3) →¬T (x1) ∨T (x2) ∨T (x3))∧
(C2(x1, x2, x3) →¬T (x1) ∨¬T (x2) ∨T (x3))∧
(C3(x1, x2, x3) →¬T (x1) ∨¬T (x2) ∨¬T (x3))).
It is easy to see that CSP(B) is in SNP for each structure B. For each ele-
ment a in the universe of B, we introduce an existentially quantiﬁed monadic

6.5 Monotone Monadic SNP and Nonuniform Constraint Satisfaction
351
relation Ta; intuitively, Ta(x) indicates that a variable x has been assigned a
value a by the homomorphism. The sentence ϕB says that the sets Ta cover
all elements in the universe,3 and that the tuples in the input relations satisfy
the constraints imposed by the structure B. Thus, if R(a1, . . . , an) does not
hold in B, then ϕB contains the conjunct ¬(R(x1, . . . , xn)∧n
i=1 Tai(xi)). For
example, 3-Colorability over a binary input relation E can be expressed
by the sentence
(∃C1, C2, C3)(∀x, y) ((C1(x) ∨C2(x) ∨C3(x))∧
¬(E(x, y) ∧C1(x) ∧C1(y))∧
¬(E(x, y) ∧C2(x) ∧C2(y))∧
¬(E(x, y) ∧C3(x) ∧C3(y))).
It follows that CSP(B) = {A : A |= ϕB}. Thus, the study of the complexity
of nonuniform constraint satisfaction can be viewed as the study of the data
complexity of certain SNP sentences.
A close examination of ϕB above shows that it actually resides in a syn-
tactic fragment of SNP. For monotone SNP, we require that all occurrences
of an input relation Ci in Φ have the same polarity (the polarity of a relation
is positive if it is contained in an even number of subformulas with a negation
applied to it, and it is negative otherwise); by convention, we assume that
this polarity is negative, so that the Ci can be interpreted as constraints, in
the sense that imposing Ci on more elements of the input structure can only
make the instance “less satisﬁable”. For monadic SNP, we require that the
existential structure S′ consist of monadic relations only. Normally we assume
that the language contains also the equality relation, so both equalities and
inequalities are allowed in Φ, unless we say without inequality, which means
that the ̸= relation cannot be used (note that equalities can always be
eliminated here). We refer to the class in which all restrictions hold, that is,
monotone monadic SNP without inequality, as MMSNP. It is clear then that
nonuniform constraint satisfaction can be expressed in MMSNP.
What is the precise relationship between nonuniform constraint satisfac-
tion and MMSNP? It is easy to see that MMSNP is more expressive than
nonuniform constraint satisfaction. The property asserting that the input
graph is triangle-free is clearly in MMSNP (in fact, it can be expressed by
a universal ﬁrst-order sentence), but it can be easily shown that there is no
graph G such that CSP(G) consists of all triangle-free graphs [29]. From a
computational point of view, however, MMSNP and nonuniform constraint
satisfaction turn out to be equivalent.
Theorem 6.5.1. [29] Every problem in MMSNP is polynomially equivalent
to CSP(B) for some template B. The equivalence is obtained by a randomized
Turing reduction4 from CSP to MMSNP and by a deterministic Karp
reduction from MMSNP to CSP.
3 It is not necessary to require disjointness.
4 G. Kun has recently announced a derandomization of this reduction.

352
6 Constraint Satisfaction
An immediate corollary is that the Dichotomy Conjecture holds for CSP
if and only if it holds for MMSNP. At the same time, MMSNP seems to
be a maximal class with this property. Speciﬁcally, any attempt to relax
the syntactical restrictions of MMSNP yields a class that is polynomially
equivalent to NP, and, consequently, a class for which the dichotomy fails.
Theorem 6.5.2. [29]
•
Every problem in NP has a polynomially equivalent problem in monotone
monadic SNP with inequality.
•
Every problem in NP has a polynomially equivalent problem in monadic
SNP without inequality.
•
Every problem in NP has a polynomially equivalent problem in monotone
SNP without inequality.
By Ladner’s Theorem, it follows that if PTIME ̸= NP, then there are
intermediate problems, which are neither in PTIME nor NP-complete, in each
of monotone monadic SNP with inequality, monadic SNP without inequality,
and monotone SNP without inequality. This is the sense in which MMSNP
is a maximal class for which we would expect a dichotomy theorem to hold.
The fact that each constraint-satisfaction problem CSP(B) can be
expressed by the MMSNP sentence ϕB suggests a way to identify templates
B for which CSP(B) is tractable: characterize those templates B for which
ϕB is equivalent to a sentence in a logic whose data complexity is in PTIME.
We discuss this approach in the next section.
6.6 Datalog and Nonuniform Constraint Satisfaction
Consider all tractable problems of the form CSP(B). In principle, it
is conceivable that every such problem requires a completely diﬀerent
algorithm. In practice, however, there seem to be two basic algorithmic
approaches
for
solving
tractable
constraint-satisfaction
problems:
one
based on a logical framework and one based on an algebraic framework.5
Feder and Vardi [29] conjectured that these two algorithmic approaches
cover all tractable constraint-satisfaction problems. Their group-theoretic
approach, which extended the algorithm used to solve aﬃne Boolean
constraint-satisfaction problems [63], has been subsumed recently by a
universal-algebraic approach [8, 9]. We discuss the logical approach here.
As described in Chap. 2, a Datalog program is a ﬁnite set of rules of the
form t0 :- t1, . . . , tm, where each ti is an atomic formula R(x1, . . . , xn). The
relational predicates that occur in the heads of the rules are the intensional
database predicates (IDBs), while all the others are the extensional database
5 The two approaches, however, are not always cleanly separated; in fact, they can
be fruitfully combined to yield new tractable classes; see [17].

6.6 Datalog and Nonuniform Constraint Satisfaction
353
predicates (EDBs). One of the IDBs is designated as the goal of the program.
Note that IDBs may occur in the bodies of rules and, thus, a Datalog
program is a recursive speciﬁcation of the IDBs with a semantics obtained
via least ﬁxedpoints of monotone operators. Each Datalog program deﬁnes
a query which, given a set of EDB predicates, returns the value of the goal
predicate. Moreover, this query is computable in polynomial time, since
the bottom-up evaluation of the least ﬁxedpoint of the program terminates
within a polynomial number of steps (in the size of the given EDBs). It
follows that Datalog has data complexity in PTIME. Thus, expressibility
in Datalog is a suﬃcient condition for tractability of a query. This suggests
trying to identify those templates B for which the MMSNP sentence ϕB is
equivalent to a Boolean Datalog query.
It should be noted, however, that Datalog queries are preserved under
homomorphisms. This means that if A →h A′ and t ∈P(A) for a Datalog
program M with goal predicate P, then h(t) ∈P(A′). In contrast, constraint-
satisfaction problems are not preserved under homomorphisms, though their
complements are. If B is a relational structure, then we write CSP(B) for
the complement of CSP(B), that is, the class of all structures A such that
there is no homomorphism h : A →B. If A →h A′ and A ∈CSP(B), then
it does not follow that A′ ∈CSP(B). On the other hand, if A →h A′ and
A ∈CSP(B), then A′ ∈CSP(B), since homomorphisms compose. Thus,
rather then try to identify those templates B for which ϕB is equivalent to
a Boolean Datalog query, we try to identify those templates B for which the
negated sentence ¬ϕB is equivalent to a Boolean Datalog query.
Along this line of investigation, Feder and Vardi [29] provided a unifying
explanation for the tractability of many nonuniform CSP(B) problems by
showing that the complement of each of these problems is expressible in
Datalog. It should be pointed out, however, that Datalog does not cover all
tractable constraint-satisfaction problems. For example, it was shown in [29]
that Datalog cannot express the complement of aﬃne Boolean constraint-
satisfaction problems; see also [5]. Aﬃne Boolean constraint-satisfaction
problems and their generalizations require algebraic techniques to establish
their tractability [8, 29]).
For every positive integer k, let k-Datalog be the collection of all Datalog
programs in which the body of every rule has at most k distinct variables
and also the head of every rule has at most k variables (the variables of
the body may be diﬀerent from the variables of the head). For example, the
query Non-2-Colorability is expressible in 3-Datalog, since it is deﬁnable
by the goal predicate Q of the following Datalog program, which asserts that
a cycle of odd length exists:
P1(X, Y ) : −E(X, Y )
P0(X, Y ) : −P1(X, Z), E(Z, Y )
P1(X, Y ) : −P0(X, Z), E(Z, Y )
Q : −P1(X, X).

354
6 Constraint Satisfaction
The fact that expressibility in Datalog and, more speciﬁcally, expressibil-
ity in k-Datalog provide suﬃcient conditions for tractability gives rise to two
classiﬁcation problems:
•
The k-Datalog-Classification problem: Given a relational structure
B and k > 1, decide whether CSP(B) is expressible in k-Datalog?
•
The Datalog-Classification problem: Given a relational structure B,
decide whether CSP(B) is expressible in k-Datalog for some k > 1.
The universal-algebraic approach does oﬀer some suﬃcient conditions
for CSP(B) to be expressible in Datalog. We mention two examples here.
A k-ary function f : Bk →B with k ≥3 is a near-unanimity function if
f(a1, . . . , ak) = b, for every k-tuple (a1, . . . , ak) such that at least k −1 of
the ai’s are equal to b. Note that the ternary majority function from {0, 1}3
to {0, 1} is a near-unanimity function.
Theorem 6.6.1. [29] Let B be relational structure, and let k ≥3. If Pol(B)
contains a k-ary near-unanimity function, then CSP(B) is expressible in
k-Datalog.
Since the number of k-ary functions over the universe B of B is ﬁnite,
checking the condition of the preceding theorem for a given k is clearly
decidable. It is not known, however, whether it is decidable to check, given
B, whether Pol(B) contains a k-ary near-unanimity function for some k.
One special class of Datalog consists of those programs whose IDB
predicates are all monadic. We refer to such Datalog programs as monadic
Datalog programs. It can easily be seen that the Horn case of Boolean
constraint satisfaction can be dealt with by monadic programs. Consider, for
example, a Boolean template with three relations: H1 is a monadic relation
corresponding to positive Horn clauses (“facts”), H2 is a ternary relation
corresponding to Horn clauses of the form p ∧q →r, and H3 is a ternary
relation corresponding to negative Horn clauses of the form ¬p ∨¬q ∨¬r.
Unsatisﬁability of Horn formulas with at most three literals per clause can
then be expressed by the following monadic Datalog program:
H(X) : −H1(X)
H(X) : −H(X), H2(Y, Z, X)
Q : −H(X), H(Y ), H(Z), H2(X, Y, Z)
It turns out that we can fully characterize expressibility in monadic
Datalog. A k-ary function f is a set function if f(a1, . . . , ak) = f(b1, . . . , bk)
whenever {a1, . . . , ak} = {b1, . . . , bk}. In other words, a set function depends
only the set of its arguments. As a concrete example, the binary Boolean
functions ∧and ∨are set functions.
Theorem 6.6.2. [29] Let B be relational structure with universe B. The
following two statements are then equivalent:

6.7 Datalog, Games, and Constraint Satisfaction
355
•
CSP(B) is expressible in monadic Datalog.
•
Pol(B) contains a |B|-ary set function.
Since the number of |B|-ary functions over the universe B of B is ﬁnite,
checking the condition of the theorem is clearly decidable; in fact, it is in NEX-
PTIME. Thus, the classiﬁcation problem for monadic Datalog is decidable.
The main reason for the focus on Datalog as a language to solve
constraint-satisfaction problems is that its data complexity is in PTIME.
Datalog, however, is not the only logic with this property. We know, for
example, that the data complexity of ﬁrst-order logic is in LOGSPACE.
Thus, it would be interesting to characterize the templates B such that
CSP(B) is expressible in ﬁrst-order logic. This turns out to have an intimate
connection to expressibility in (nonrecursive) Datalog.
Theorem 6.6.3. [5, 60] Let B be a relational structure. The following are
equivalent:
•
CSP(B) is expressible in ﬁrst-order logic.
•
CSP(B) is expressible by a ﬁnite union of conjunctive queries.
It is known that a Datalog program is always equivalent to a (possibly
inﬁnite) union of conjunctive queries. A Datalog program is bounded if it is
equivalent to a ﬁnite union of conjunctive queries [35]. It is known that a
Datalog program is bounded if and only if it is equivalent to a ﬁrst-order
formula [2, 61]. Thus, expressibility of nonuniform CSP in ﬁrst-order logic
is a special case of expressibility in Datalog. Concerning the classiﬁcation
problem, Larose, Loten, and Tardif [52] have shown that there is an algorithm
to decide, given a structure B, whether CSP(B) is expressible in ﬁrst-order
logic; actually, this problem turns out to be NP-complete.
In another direction, we may ask if there are constraint-satisfaction
problems that cannot be expressed by Datalog, but can be expressed in least
ﬁxedpoint logic (LFP), whose data complexity is also in PTIME. This is an
open question. It was conjectured in [29] that if CSP(B) is expressible in
LFP, then it is also expressible in Datalog.
6.7 Datalog, Games, and Constraint Satisfaction
So far, we have focused on using Datalog to obtain tractability for nonuni-
form constraint satisfaction. Kolaitis and Vardi [48] showed how the logical
framework also provides a unifying explanation for the tractability of uniform
constraint-satisfaction problems. Note that, in general, tractability results
for the nonuniform case do not uniformize. Thus, tractability results for each
problem in a collection of nonuniform CSP(B) problems do not necessarily
yield a tractable case of the uniform Constraint-Satisfaction problem.
The reason is that both of the structures A and B are part of the input to

356
6 Constraint Satisfaction
the uniform Constraint-Satisfaction problem, and the running times of
the polynomial-time algorithms for CSP(B) may very well be exponential in
the size of B. We now leverage the intimate connection between Datalog and
pebble games to shed new light on expressibility in Datalog, and show how
tractability via k-Datalog does uniformize.
As discussed in Chap. 2, Datalog can be viewed as a fragment of least
ﬁxedpoint logic (LFP); furthermore, on the class All of all ﬁnite structures,
LFP is subsumed by the ﬁnite-variable inﬁnitary logic Lω
∞ω = 
k>0 Lk
∞ω
(see Chap. 2). Here we are interested in the existential positive fragments of
∃Lk
∞ω, where k s a positive integer, which are tailored for the study of Datalog
Theorem 6.7.1. [48] Let k be a positive integer. Every k-Datalog query
over ﬁnite structures is expressible in ∃Lk
∞ω. Thus, k-Datalog ⊆∃Lk
∞ω on
ﬁnite structures.
We make use here of the (∃, k)-pebble games discussed in Chap. 2. We
saw there that if k is a positive integer and Q is a Boolean query on a class
C of ﬁnite structures, then Q is expressible in ∃Lk
∞ω on C iﬀfor all A, B ∈C
such that A |= Q and the Duplicator wins the (∃, k)-pebble game on A and
B, we have that B |= Q. The next theorem establishes a connection between
expressibility in k-Datalog and (∃, k)-pebble games. (A closely related, but
somewhat less precise, such connection was established in [29].) In what
follows, if A is a class of structures and B is a structure, we write CSP(A, B)
to denote the class of structures A such that A ∈A and A →B.
Theorem 6.7.2. [48] Let k be a positive integer, B a relational structure,
and A a class of relational structures such that B ∈A. The following
statements are then equivalent:
•
CSP(A, B) is expressible in k-Datalog on A.
•
CSP(A, B) is expressible in ∃Lk
∞ω on A.
•
CSP(A, B) is equal to the class
{A ∈A : The Spoiler wins the (∃, k)-pebble game on Aand B}.
Recall also from Chap. 2 that the query “Given two structures A and B,
does the Spoiler win the (∃, k)-pebble game on A and B?” is deﬁnable in
LFP; as a result, there is a polynomial-time (in fact, O(n2k)) algorithm that,
given two structures A and B, determines whether the Spoiler wins the
(∃, k)-pebble game on A and B.
By combining Theorem 6.7.2 with the results of Chap. 2, we obtain
the following uniform tractability result for classes of constraint-satisfaction
problems expressible in Datalog.
Theorem 6.7.3. [48] Let k be a positive integer, let A be a class of relational
structures, and let B = {B ∈A : ¬CSP(A, B) is expressible in k-Datalog}.
Then the uniform Constraint-Satisfaction problem CSP(A, B) is solvable
in polynomial time. Moreover, the running time of the algorithm is O(n2k),
where n is the maximum of the sizes of the input structures A and B.

6.8 Games and Consistency
357
Intuitively, if we consider the class of all templates B for which k-Datalog
solves CSP(B), then computing the winner in the existential k-pebble game
oﬀers a uniform polynomial-time algorithm. That is, the algorithm deter-
mining the winner in the existential k-pebble game is a uniform algorithm
for all (nonuniform) constraint-satisfaction problems that can be expressed
in k-Datalog.
The characterization in terms of pebble games also sheds light on nonuni-
form constraint satisfaction. As described in Chap. 2, for every relational
structure B and every positive integer k, there is a k-Datalog program ρk
B
that expresses the query “Given a structure A, does the Spoiler win the
(∃, k) pebble game on A and B?” As an immediate consequence of this fact,
we obtain the result that CSP(B) is expressible in k-Datalog if and only if it
is expressible by a speciﬁc k-Datalog program.
Theorem 6.7.4. [29, 48] CSP(B) is expressible in k-Datalog if and only if
it is expressible by ρk
B.
It follows that CSP(B) is expressible in k-Datalog if and only if ¬ϕB
is logically equivalent to ρk
B, where ϕB is the MMSNP sentence express-
ing CSP(B). Unfortunately, it is not known whether the equivalence of
complemented MMSNP to Datalog is decidable.
6.8 Games and Consistency
One of the most fruitful approaches to coping with the intractability of con-
straint satisfaction has been the introduction and use of various consistency
concepts that make explicit some additional constraints implied by the original
constraints. The connection between consistency properties and tractability
was ﬁrst described in [31, 32]. In a similar vein, the relationship between local
consistency and global consistency was investigated in [21, 65, 66]. Intuitively,
local consistency means that any partial solution on a set of variables can
be extended to a partial solution containing an additional variable, whereas
global consistency means that any partial solution can be extended to a global
solution. Note that if the inputs are such that local consistency implies global
consistency, then there is a polynomial-time algorithm for constraint satisfac-
tion; moreover, in this case a solution can be constructed via a backtrack-free
search. We now describe this approach from the Datalog perspective. The
crucial insight is that the key concept of strong k-consistency [21] is equivalent
to a property of winning strategies for the Duplicator in the (∃, k)-pebble
game. Speciﬁcally, an instance of a constraint-satisfaction problem is strongly
k-consistent if and only if the family of all k-partial homomorphisms f is
a winning strategy for the Duplicator in the (∃, k)-pebble game on the two
relational structures that represent the given instance.

358
6 Constraint Satisfaction
The connection between pebble games and consistency properties, how-
ever, is deeper than just a mere reformulation of the concept of strong k-
consistency. Indeed, as mentioned earlier, consistency properties underlie the
process of making explicit new constraints that are implied by the original
constraints. A key technical step in this approach is the procedure known as
“establishing strong k-consistency”, which propagates the original constraints,
adds implied constraints, and transforms a given instance of a constraint-
satisfaction problem to a strongly k-consistent instance with the same solu-
tion space [15, 21]. In fact, strong k-consistency can be established if and only
if the Duplicator wins the (∃, k)-pebble game. Moreover, whenever strong
k-consistency can be established, one method for doing this is to ﬁrst com-
pute the largest winning strategy for the Duplicator in the (∃, k)-pebble game
and then modify the original problem by augmenting it with the constraints
expressed by the largest winning strategy; this method gives rise to the least
constrained instance that establishes strong k-consistency and, in addition,
satisﬁes a natural coherence property. By combining this result with known
results concerning the deﬁnability of the largest winning strategy, it follows
that the algorithm for establishing strong k-consistency in this way (with k
ﬁxed) is actually expressible in least ﬁxedpoint logic; this strengthens the
fact that strong k-consistency can be established in polynomial time when
k is ﬁxed. If we consider nonuniform constraint satisfaction, it follows that
for every relational structure B, the complement of CSP(B) is expressible
by a Datalog program with k variables if and only if CSP(B) coincides with
the collection of all relational structures A such that establishing strong k-
consistency on A and B implies that there is a homomorphism from A to B.
We start the formal treatment by returning ﬁrst to (∃, k)-pebble games.
Recall from Chap. 2 that a winning strategy for the Duplicator in the (∃, k)-
pebble game on A and B is a nonempty family of k-partial homomorphisms
(that is, partial homomorphisms deﬁned on at most k elements) from A to
B that is closed under subfunctions and has the forth property up to k. A
conﬁguration for the (∃, k)-pebble game on A and B is a 2k-tuple a, b, where
a = (a1, . . . , ak) and b = (b1, . . . , bk) are elements of Ak and Bk, respectively,
such that if ai = aj, then bi = bj; this means that the correspondence ai →bi,
1 ≤i ≤k, is a partial function from A to B, which we denote by ha,b. A
winning conﬁguration for the Duplicator in the existential k-pebble game on
A and B is a conﬁguration a, b for this game such that ha,b is a member
of some winning strategy for the Duplicator in this game. We denote by
Wk(A, B) the set of all such conﬁgurations. The following results show that
expressibility in ∃Lk
∞ω can be characterized in terms of the set Wk(A, B).
Proposition 6.8.1.
[49] If F and F′ are two winning strategies for the
Duplicator in the (∃, k)-pebble game on two structures A and B, then the
union F ∪F′ is also a winning strategy for the Duplicator. Consequently,
there is a largest winning strategy for the Duplicator in the (∃, k)-pebble

6.8 Games and Consistency
359
game, namely the union of all winning strategies, which is precisely the set
Hk(A, B) = {ha,b : (a, b) ∈Wk(A, B)}.
Corollary 6.8.2. [48] Let k be a positive integer and Q a k-ary query on a
class C of ﬁnite structures. The following two statements are then equivalent:
•
Q is expressible in ∃Lk
∞ω on C.
•
If A, B are two structures in C, (a, b) ∈Wk(A, B), and A |= Q(a), then
B |= Q(b).
The following lemma is a crucial deﬁnability result.
Lemma 6.8.3. [48] There is a positive-in-S ﬁrst-order formula ϕ(x, y, S),
where x and y are k-tuples of variables, such that the complement of its least
ﬁxedpoint on a pair (A, B) of structures deﬁnes the set Wk(A, B) of all
winning conﬁgurations for the Duplicator in the (∃, k)-pebble game on A, B.
We now formally deﬁne the concepts of i-consistency
and strong
k-consistency.
Deﬁnition 6.8.4. Let P = (V, D, C) be a constraint-satisfaction instance.
•
A partial solution on a set V ′ ⊂V is an assignment h : V ′ →D that
satisﬁes all the constraints whose scope is contained in V ′.
•
P is i-consistent if, for every i −1 variables v1, . . . , vi−1, for every partial
solution on these variables, and for every variable vi ̸∈{v1, . . . , vi−1},
there is a partial solution on the variables v1, . . . , vi−1, vi extending the
given partial solution on the variables v1, . . . , vi−1.
•
P is strongly k-consistent if it is i-consistent for every i ≤k.
To illustrate these concepts, consider the Boolean formula
(¬x1 ∨x3) ∧(¬x2 ∨x3) ∧(x2 ∨¬x3).
It is easy to verify that this formula, viewed as a constraint-satisfaction
instance, is strongly 3-consistent. For instance, the partial solution x2 = 0,
x3 = 0 can be extended to the solution x1 = 0, x2 = 0, x3 = 0, and the
partial solution x1 = 1, x3 = 1 can be extended to the solution x1 = 1,
x2 = 1, x3 = 1. In contrast, the Boolean formula
(x1 ∨x2) ∧(¬x1 ∨x3) ∧(¬x2 ∨x3) ∧(x2 ∨¬x3)
is satisﬁable and strongly 2-consistent, but not 3-consistent (hence, it is not
strongly 3-consistent either). The reason is that the partial solution x2 = 0,
x3 = 0 cannot be extended to a solution, since the only solutions of this for-
mula are x1 = 0, x2 = 1, x3 = 1 and x1 = 1, x2 = 1, x3 = 1. Note that the con-
cepts of strong 2-consistency and strong 3-consistency were ﬁrst studied in the
literature under the names of arc consistency and path consistency (see [23]).
A key insight is that the concepts of i-consistency and strong k-consistency
can be naturally recast in terms of existential pebble games.

360
6 Constraint Satisfaction
Proposition 6.8.5. [49] Let P be a CSP instance, and let (AP, BP) be the
associated homomorphism instance.
•
P is i-consistent if and only if the family of all partial homomorphisms
from AP to BP with i −1 elements in their universe has the i-forth
property.
•
P is strongly k-consistent if and only if the family of all k-partial
homomorphisms from AP to BP is a winning strategy for the Duplicator
in the (∃, k)-pebble game on AP and BP.
Let us now recall the concept of establishing strong k-consistency,
as
deﬁned, for instance, in [15, 21]. This concept has been deﬁned rather
informally in the AI literature to mean that, given a constraint-satisfaction
instance P, we associate with it another instance P′ that has the following
properties: (1) P′ has the same set of variables and the same set of values as
P (2) P′ is strongly k-consistent; (3) P′ is at least as constrained as P; and
(4) P and P′ have the same space of solutions. The next deﬁnition formalizes
the above concept in the context of the homomorphism problem (see [19, 49]).
Deﬁnition 6.8.6. Let A and B be two relational structures over a k-ary
vocabulary σ (i.e., every relation symbol in σ has an arity of at most k).
Establishing strong k-consistency for A and B means that we associate two
relational structures A′ and B′ with them with the following properties:
•
A′ and B′ are structures over some k-ary vocabulary σ′ (in general,
diﬀerent from σ); moreover, the universe of A′ is the universe A of A,
and the universe of B′ is the universe B of B.
•
CSP(A′, B′) is strongly k-consistent.
•
If h is a k-partial homomorphism from A′ to B′, then h is a k-partial
homomorphism from A to B.
•
If h is a function from A to B, then h is a homomorphism from A to B
if and only if h is a homomorphism from A′ to B′.
If the structures A′ and B′ have the above properties, then we say that A′
and B′ establish strong k-consistency for A and B.
A constraint-satisfaction instance P is coherent if every constraint (t, R) of
P completely determines all constraints (u, Q) in which all variables occurring
in u are among the variables of t. We formalize this concept as follows.
Deﬁnition 6.8.7. An instance A, B of the homomorphism problem is coher-
ent if its associated constraint-satisfaction instance CSP(A, B) has the follow-
ing property: for every constraint (a, R) of CSP(A, B) and every tuple b ∈R,
the mapping ha,b is well deﬁned and is a partial homomorphism from A to B.
Note that a constraint-satisfaction instance can be made coherent in
polynomial time by constraint propagation.

6.8 Games and Consistency
361
The main result of this section is that strong k-consistency can be
established precisely when the Duplicator wins the (∃, k)-pebble game. More-
over, one method for establishing strong k-consistency is to ﬁrst compute
the largest winning strategy for the Duplicator in this game and then to
generate an instance of the constraint-satisfaction problem consisting of all
the constraints embodied in the largest winning strategy. Furthermore, this
method gives rise to the largest coherent instance that establishes strong
k-consistency (and, hence, the least constrained such instance).
Theorem 6.8.8. [49] Let k be a positive integer, let σ be a k-ary vocabulary,
and let A and B be two relational structures over σ with universes A and
B, respectively. It is possible to establish strong k-consistency for A and B if
and only if Wk(A, B) ̸= ∅. Furthermore, if Wk(A, B) ̸= ∅, then the following
sequence of steps gives rise to two structures A′ and B′ that establish strong
k-consistency for A and B:
1. Compute the set Wk(A, B).
2. For every i
≤
k and for every i-tuple a
∈
Ai, form the set
Ra = {b ∈Bi : (a, b) ∈Wk(A, B)}.
3. Form a Constraint-Satisfaction instance P with A as the set of
variables, B as the set of values, and {(a, Ra) : a ∈∪k
i=1Ai} as the
collection of constraints.
4. Let (A′, B′) be the homomorphism instance of P.
In addition, the structures A′ and B′ obtained above constitute the largest
coherent instance establishing strong k-consistency for A and B, that is, if
(A′′, B′′) is another such coherent instance, then for every constraint (a, R)
of CSP(A′′, B′′), we have that R ⊆Ra.
The key step in the procedure described in Theorem 6.8.8 is the ﬁrst
step, in which the set Wk(A, B) is computed. The other steps simply
“re-format” Wk(A, B). From Lemma 6.8.3 it follows that we can establish
strong k-consistency by computing the ﬁxedpoint of a monotone ﬁrst-order
formula. We can now relate the concept of strong k-consistency to the results
in [29] regarding Datalog and nonuniform CSP.
Theorem 6.8.9. [49] Let B be a relational structure over a vocabulary σ.
The following two statements are then equivalent:
•
CSP(B) is expressible in k-Datalog.
•
For every structure A over σ, establishing strong k-consistency for A, B
implies that there is a homomorphism from A to B.
Given the fundamental role that the set Wk(A, B) plays here, it is natural
to ask about the complexity of computing it. To turn this question into a
decision problem, we just ask about the nonemptiness of this set.

362
6 Constraint Satisfaction
Theorem 6.8.10. [45] The problem {(A, B, k) : Wk(A, B) ̸= ∅}, with k
encoded in unary, is EXPTIME-complete. In words, the following problem is
EXPTIME-complete: given a positive integer k and two structures A and B,
does the Duplicator win the (∃, k)-pebble game on A and B?
This result is rather surprising. After all, the complexity of constraint
satisfaction is “only” NP-complete. In contrast, the complexity of establishing
strong k-consistency is provably exponential and not in PTIME. This oﬀers
an a posteriori justiﬁcation of the practice of establishing only a “low degree”
of consistency, such as arc consistency or path consistency [3, 23].
6.9 Uniform Constraint Satisfaction
and Bounded Treewidth
So far, we have focused on the pursuit of islands of tractability of nonuniform
constraint satisfaction, that is, islands of the form CSP(B) = CSP(All, {B}),
where B is a ﬁxed template. Even when we discussed uniform constraint
satisfaction, it was with respect to tractable templates. In this section we
focus on uniform constraint satisfaction of the form CSP(A, All), where A
is a class of structures. The goal is to identify conditions on A that ensure
uniform tractability.
As is well known, many algorithmic problems that are “hard” on arbi-
trary structures become “easy” on trees. This phenomenon has motivated
researchers to investigate whether the concept of a tree can be appropriately
relaxed while maintaining good computational behavior. As part of their
seminal work on graph minors, Robertson and Seymour introduced the
concept of treewidth, which, intuitively, measures how “tree-like” a structure
is; moreover, they showed that graphs of bounded treewidth exhibit such good
behavior; see [59].
Deﬁnition 6.9.1. A tree decomposition of a relational structure A is a
labeled tree T such that the following conditions hold:
•
Every node of T is labeled by a nonempty subset of the universe A of A,
•
For every relation R of A and every tuple (a1, . . . , an) in R, there is a
node of T whose label contains {a1, . . . , an},
•
For every a ∈A, the set of nodes of T whose labels include a forms a
subtree of T .
The width of a tree decomposition T is the maximum cardinality of a label
of a node in T minus 1. The treewidth of A, denoted tw(A), is the smallest
positive integer k such that A has a tree decomposition of width k. We write
T (k) to denote the class of all structures A such that tw(A) < k.
Clearly, if T is a tree, then tw(T) = 1. Similarly, if n ≥3 and Cn is the
n-element (directed) cycle, then tw(C) = 2. At the other end of the scale,

6.9 Uniform Constraint Satisfaction and Bounded Treewidth
363
tw(Kk) = k−1, for every k ≥2. Computing the treewidth of a structure is an
intractable problem. Speciﬁcally, the following problem is NP-complete [4]:
given a graph H and an integer k ≥1, is tw(H) ≤k? Nonetheless,
Bodlaender [7] has shown that for every ﬁxed integer k ≥1, there is a linear-
time algorithm such that, given a structure A, it determines whether or not
tw(A) < k. In other words, each class T (k) is recognizable in polynomial time.
Dechter and Pearl [25] and Freuder [33] have shown that the classes of
structures of bounded treewidth give rise to large islands of tractability of
uniform constraint satisfaction.
Theorem 6.9.2. [25, 33] If k ≥2 is a positive integer, then CSP(T (k), All)
is in PTIME.
The polynomial-time algorithm for CSP(T (k), All) in the above theorem
is often described as a bucket-elimination algorithm [22]. It should be noted
that it is not a constraint-propagation algorithm. Instead, this algorithm
uses the bound on the treewidth to test whether a solution to the constraint-
satisfaction problem exists by solving a join-evaluation problem in which all
intermediate relations are of bounded arity.
Kolaitis and Vardi [48], and Dalmau, Kolaitis and Vardi [18] have
investigated certain logical aspects of the treewidth of a relational structure
and have shown that this combinatorial concept is closely connected to the
deﬁnability of the canonical conjunctive query of the structure in a fragment
of ﬁrst-order logic with a ﬁxed number of variables. This has made it possible
to show that the tractability of CSP(T (k), All) can be explained in purely
logical terms. Moreover, it led to the discovery of larger islands of tractability
of uniform constraint satisfaction.
Deﬁnition 6.9.3. Let k ≥2 be a positive integer.
•
FOk is the collection of all ﬁrst-order formulas with at most k distinct
variables.
•
Lk is the collection of all FOk-formulas built using atomic formulas,
conjunction, and existential ﬁrst-order quantiﬁcation only.
Intuitively, queries expressible in FOk and Lk are simply ﬁrst-order queries
and conjunctive queries, respectively, with a bound k on the number of distinct
variables (each variable, however, may be reused any number of times).
As an example, it is easy to see that if Cn is the n-element cycle, n ≥3,
then the canonical conjunctive query QCn is expressible in L3. For instance,
QC4 is logically equivalent to (∃x∃y∃z)(E(x, y) ∧E(y, z) ∧(∃y)(E(z, y) ∧
E(y, x))). As mentioned earlier, for every n ≥3, we have that tw(Cn) = 2.
The logics FOk and Lk are referred to as variable-conﬁned logics [47].
The complexity of query evaluation for such queries has been studied in [68].
Since in the case of in data complexity the queries are ﬁxed, bounding the
number of variables does not change the data complexity. The change in the
expression and the combined complexity, however, is quite dramatic, as the

364
6 Constraint Satisfaction
combined complexity of FOk has been shown to be in PTIME [68]. (More
generally, the exponential gap between data complexity and expression and
combined complexity shrinks when the number of variables is bounded.)
The next result shows that the relationship we have just seen in the
example above, between the treewidth and the number of variables needed
to express the canonical conjunctive query of a cycle, is not an accident.
Theorem 6.9.4. [48] Let k ≥2 be a positive integer. If A ∈T (k), then the
canonical conjunctive query QA is expressible in Lk.
Corollary 6.9.5. CSP(T (k), All) can be solved in polynomial time by deter-
mining, given a structure A ∈T (k) and an arbitrary structure B, whether
B |= QA.
A precise complexity analysis of CSP(T (k), All) is provided in [37], where
it is shown that the problem is LOGFCL-complete; by deﬁnition, LOGCFL
is the class of decision problems that are logspace-reducible to a context-free
language. Note that, in contrast, the combined complexity of evaluating
FOk-queries, for k > 3, is PTIME-complete [68].
Theorem 6.9.4 can be viewed as a logical recasting of the bucket-
elimination algorithm. It derives the tractability of CSP(T (k), All) from
the fact that the canonical conjunctive query QA can be written using at
most k variables. Consequently, evaluating this query amounts to solving a
join-evaluation problem in which all intermediate relations are of bounded
arity. For an investigation of how the ideas underlying Theorem 6.9.4 can be
used to solve practical join-evaluation problems, see [55].
It turns out, however, that we can also approach solving CSP(T (k), All)
from the perspective of k-Datalog and (∃, k)-pebble games. This is because
Lk is a fragment of ∃Lk
∞ω, whose expressive power, as seen earlier, can be
characterized in terms of such games.
Theorem 6.9.6. [18] Let k ≥2 be a positive integer.
•
If B is an arbitrary, but ﬁxed, structure, then T (k) ∩CSP(T (k), {B}) is
expressible in k-Datalog.6
•
CSP(T (k), All) can be solved in polynomial time by determining whether,
given a structure A ∈T (k) and an arbitrary structure B, the Duplicator
wins the (∃, k)-pebble on A and B.
The situation for bounded-treewidth structures, as described by Theo-
rem 6.9.6, should be contrasted with the situation for bounded-cliquewidth
structures [16]. Let C(k) be the class of structures with a cliquewidth bounded
by k. It has been shown in [16] that CSP(C(k), {B}) is in PTIME for each
structure B. Since, however, complete graphs have a bounded cliquewidth, it
6 The intersection with T (k) ensures that only structures with a treewidth bounded
by k are considered.

6.9 Uniform Constraint Satisfaction and Bounded Treewidth
365
follows that the Clique problem can be reduced to CSP(C(k), All), implying
NP-hardness of the latter.
As a consequence of Theorem 6.9.6, we see that CSP(T (k), All) can be
solved in polynomial time using a constraint-propagation algorithm that is
quite diﬀerent from the bucket-elimination algorithm in Theorem 6.9.2. It
should be noted, however, that this requires knowing that we have been
given an instance A, B where tw(A) ≤k. In contrast, the bucket-elimination
algorithm can be used for arbitrary constraint-satisfaction instances (with no
tractability guarantee, in general).
The classes CSP(T (k), All) enjoy also nice tractability properties from
the perspective of Parametrized Complexity Theory [26], as they are ﬁxed-
parameter tractable, and, in a precise technical sense, are maximal with this
property under a certain complexity-theoretic assumption (see [41]).
The development so far shows that T (k) provides an island of tractability
for uniform constraint satisfaction. We now show that this island can be
expanded.
Deﬁnition 6.9.7. Let A and B be two relational structures.
•
We say that A and B are homomorphically equivalent, denoted by
A ∼h B, if both A →B and B →A hold.
•
We say that B is the core of A, and write core(A) = B, if B is a
substructure of A, A →B holds, and A →B′ fails for each proper
substructure B′ of B.
Clearly, core(Kk) = Kk and core(Cn) = Cn. On the other hand, if H
is a 2-colorable graph with at least one edge, then core(H) = K2. It should
be noted that cores play an important role in database query processing and
optimization (see [11]). The next result shows that they can also be used to
characterize when the canonical conjunctive query is deﬁnable in Lk.
Theorem 6.9.8. [18] Let k ≥2 be a positive integer and A a relational
structure. The following are then equivalent:
•
QA is deﬁnable in Lk.
•
There is a structure B ∈T (k) such that A ∼h B.
•
core(A) ∈T (k).
The tight connection between deﬁnability in Lk and the boundedness of
the treewidth of the core suggests a way to expand the “island” T (k).
Deﬁnition 6.9.9. If k ≥2 is a positive integer, then H(T (k)) is the class of
relational structures A such that core(A) has a treewidth less than k.
It should be noted that T (k) is properly contained in H(T (k)), for every
k ≥2. Indeed, it is known that there are 2-colorable graphs of arbitrarily
large treewidth. In particular, grids are known to have these properties
(see [26]). Yet these graphs are members of H(T (2)), since their core is K2.

366
6 Constraint Satisfaction
Theorem 6.9.10. [18] Let k ≥2 be a positive integer.
•
If
B
is
an
arbitrary,
but
ﬁxed,
structure,
then
H(T (k)) ∩
CSP(H(T (k)), {B}) is expressible in k-Datalog.
•
CSP(H(T (k)), All) is in PTIME. Moreover, CSP(H(T (k)), All) can be
solved in polynomial time by determining whether, given a structure
A ∈H(T (k)) and an arbitrary structure B, the Spoiler or the Duplicator
wins the (∃, k)-pebble on A and B.
Theorem 6.9.10 yields new islands of tractability for uniform constraint
satisfaction, which properly subsume the islands of tractability constituted by
the classes of structures of bounded treewidth. This expansion of the tractabil-
ity landscape comes, however, at a certain price. Speciﬁcally, as seen earlier,
for every ﬁxed k ≥2, there is a polynomial-time algorithm for determining
membership in T (k) [7]. In contrast, it has been shown that, for every ﬁxed
k ≥2, determining membership in H(T (k)) is an NP-complete problem [18].
Thus, these new islands of tractability are, in some sense, “inaccessible”.
Since H(T (k)) contains structures of arbitrarily large treewidth, the
bucket-elimination algorithm cannot be used to solve CSP(H(T (k)), All)
in polynomial time. Thus, Theorem 6.9.10 also shows that determining the
winner of the (∃, k)-pebble is a polynomial-time algorithm that applies to
islands of tractability not covered by the bucket-elimination algorithm.
It is now natural to ask whether there are classes A of relational structures
that are larger than the classes H(T (k)) such that CSP(A, All) is solvable
in polynomial time. A remarkable result by Grohe [40] shows essentially
that, if we ﬁx the vocabulary, no such classes exist, provided a certain
complexity-theoretic hypothesis is true.
Theorem 6.9.11.
[40] Assume that FPT ̸= W[1]. If A is a recursively
enumerable class of relational structures over some ﬁxed vocabulary such
that CSP(A, All) is in PTIME, then there is a positive integer k such that
A ⊆H(T (k)).
The hypothesis FPT ̸= W[1] is a statement in Parametrized Complexity
Theory that is analogous to the hypothesis PTIME ̸= NP, and it is widely
accepted as being true (see [26]). In eﬀect, Theorem 6.9.11 is a converse
to Theorem 6.9.10 for ﬁxed vocabularies. Together, these two theorems
yield a complete characterization of all islands of tractability of the form
CSP(A, All), where A is a class of structures over some ﬁxed vocabulary.
Moreover, they reveal that all tractable cases of the form CSP(A, All) can
be solved by the same polynomial-time algorithm, namely, the algorithm
for determining the winner in the (∃, k)-pebble game. In other words, all
tractable cases of constraint satisfaction of the form CSP(A, All) can be
solved in polynomial time using constraint propagation.
It is important to emphasize that the classes H(T (k)) are the largest
islands of tractability for uniform constraint satisfaction only under the

References
367
assumption in Theorem 6.9.11 of a ﬁxed vocabulary. For variable vocabular-
ies, there has been a long line of research on the impact of the “topology” of
conjunctive queries on the complexity of their evaluation; this line of research
goes back to the study of acyclic joins in [69]. The connection between
acyclic joins and acyclic constraints was pointed out in [42]. This is still an
active research area. Chekuri and Rajaraman [12] showed that the uniform
constraint-satisfaction problem CSP(Q(k), All) is solvable in polynomial
time, where Q(k) is the class of structures of querywidth k. Gottlob, Leone,
and Scarcello [39] have deﬁned another notion of width, called hypertree
width. They have shown that the querywidth of a structure A provides a
strict upper bound on the hypertree width of A, but that the class H(k) of
structures of hypertree width at most k is polynomially recognizable (unlike
the class Q(k)), and that CSP(H(k), All) is tractable. For further discussion
of the relative merits of various notions of “width”, see [38]. This is an active
area of research (see [13, 14]).
Acknowledgments
We are grateful to Benoit Larose and Scott Weinstein for helpful comments
on a previous draft of this chapter. This work was supported in part by NSF
grants CCR-9988322, CCR-0124077, CCR-0311326, and ANI-0216467, and
by a Guggenheim Fellowship. Part of this work was done while the second
author was visiting the Isaac Newton Institute for Mathematical Science, as
part of a Special Programme on Logic and Algorithms.
References
1. S. Abiteboul, R. Hull, and V. Vianu. Foundations of Databases. Addison-Wesley,
1995.
2. M. Ajtai and Y. Gurevich. Datalog vs ﬁrst-order logic. Journal of Computer
and System Sciences, 49(3):562–588, 1994.
3. K. Apt. Principles of Constraint Programming. Cambridge Univ. Press, 2003.
4. S. Arnborg, D. G. Corneil, and A. Proskurowski.
Complexity of ﬁnding
embeddings in a k-tree.
SIAM Journal of Algebraic and Discrete Methods,
8:277–284, 1987.
5. A. Atserias. On digraph coloring problems and treewidth duality. In Proc. 20th
IEEE Symp. on Logic in Computer Science, pages 106–115, 2005.
6. W. Bibel.
Constraint satisfaction from a deductive viewpoint.
Artiﬁcial
Intelligence, 35:401–413, 1988.
7. H. L. Bodlaender. A linear-time algorithm for ﬁnding tree-decompositions of
small treewidth.
In Proc. 25th ACM Symp. on Theory of Computing, pages
226–234, 1993.
8. A. A. Bulatov. A dichotomy theorem for constraints on a three-element set. In
Proc. 43rd Symp. on Foundations of Computer Science, pages 649–658, 2002.

368
6 Constraint Satisfaction
9. A. A. Bulatov.
Tractable conservative constraint satisfaction problems.
In
Proc. 18th IEEE Symp. on Logic in Computer Science, pages 321–330, 2003.
10. A. A. Bulatov, P. Jeavons, and A. A. Krokhin. Classifying the complexity of con-
straints using ﬁnite algebras. SIAM Journal on Computing, 34(3):720–742, 2005.
11. A. K. Chandra and P. M. Merlin.
Optimal implementation of conjunctive
queries in relational databases.
In Proc. 9th ACM Symp. on Theory of
Computing, pages 77–90, 1977.
12. C. Chekuri and A. Rajaraman. Conjunctive query containment revisited. In
Ph.G. Kolaitis and F. Afrati, editors, Proc. 6th Int’l Conf. on Database Theory,
Lecture Notes in Computer Science, volume 1186, pages 56–70. Springer, 1997.
13. H. Chen and V. Dalmau.
Beyond hypertree width: Decomposition methods
without decompositions. In Proc. 11th Int’l Conf. on Principles and Practice
of Constraint Programming, Lecture Notes in Computer Science, volume 3709,
pages 167–181. Springer, 2005.
14. D. A. Cohen, P. Jeavons, and M. Gyssens.
A uniﬁed theory of structural
tractability for constraint satisfaction and spread cut decomposition. In Proc.
19th Int’l Joint Conf. on Artiﬁcial Intelligence, pages 72–77, 2005.
15. M. C. Cooper.
An optimal k-consistency algorithm.
Artiﬁcial Intelligence,
41(1):89–95, 1989.
16. B. Courcelle, J. A. Makowsky, and U. Rotics. Linear time solvable optimization
problems on graphs of bounded cliquewidth.
Theory of Computing Systems,
33:125–150, 2000.
17. V. Dalmau. Generalized majority–minority operations are tractable. In Proc.
20th IEEE Symp. on Logic in Computer Science, pages 438–447, 2005.
18. V. Dalmau, Ph. G. Kolaitis, and M.Y. Vardi. Constraint satisfaction, bounded
treewidth, and ﬁnite-variable logics. In P. Van Hentenryck, editor, Proc. 8th
Int’l Conf. on Constraint Programming, Lecture Notes in Computer Science,
volume 2470, pages 310–326. Springer, 2002.
19. V. Dalmau and J. Pearson. Closure functions and width 1 problems. In Proc.
5th Int’l Conf. on Principles and Practice of Constraint Programming, Lecture
Notes in Computer Science, volume 1713, pages 159–173. Springer, 1999.
20. R. Dechter.
Constraint networks.
In S. C. Shapiro, editor, Encyclopedia of
Artiﬁcial Intelligence, pages 276–185. Wiley, New York, 1992.
21. R. Dechter.
From local to global consistency.
Artiﬁcial Intelligence, 55(1):
87–107, May 1992.
22. R. Dechter. Bucket elimination: a unifying framework for reasoning. Artiﬁcial
Intelligence, 113(1–2):41–85, 1999.
23. R. Dechter. Constraint Processing. Morgan Kaufmman, 2003.
24. R. Dechter and I. Meiri. Experimental evaluation of preprocessing algorithms
for constraint satisfaction problems. Artiﬁcial Intelligence, 68:211–241, 1994.
25. R. Dechter and J. Pearl.
Tree clustering for constraint networks.
Artiﬁcial
Intelligence, pages 353–366, 1989.
26. R. G. Downey and M. R. Fellows. Parametrized Complexity. Springer, 1999.
27. T. Feder.
Constraint satisfaction: A personal perspective.
Technical report,
Electronic Colloquium on Computational Complexity, 2006. Report TR06-021.
28. T. Feder and D. Ford. Classiﬁcation of bipartite boolean constraint satisfaction
through delta-matroid intersection.
Technical report, Electronic Colloquium
on Computational Complexity, 2005. Report TR05-016.

References
369
29. T. Feder and M. Y. Vardi. The computational structure of monotone monadic
SNP and constraint satisfaction: a study through Datalog and group theory.
SIAM J. on Computing, 28:57–104, 1998.
30. T. A. Feder and M. Y. Vardi. Monotone monadic SNP and constraint satisfac-
tion. In Proc. 25th ACM Symp. on Theory of Computing, pages 612–622, 1993.
31. E. C. Freuder.
Synthesizing constraint expressions.
Communications of the
ACM, 21(11):958–966, November 1978.
32. E. C. Freuder. A suﬃcient condition for backtrack-free search. Journal of the
Association for Computing Machinery, 29(1):24–32, 1982.
33. E. C Freuder. Complexity of k-tree structured constraint satisfaction problems.
Proc. 7th National Conference on Artiﬁcial Intelligence, pages 4–9, 1990.
34. D. H. Frost. Algorithms and Heuristics for Constraint Satisfaction Problems.
PhD thesis, Department of Computer Science, University of California, Irvine,
1997.
35. H. Gaifman, H. Mairson, Y. Sagiv, and M. Y. Vardi. Undecidable optimization
problems for database logic programs. In Proc. 2nd IEEE Symp. on Logic in
Computer Science, pages 106–115, 1987.
36. M. R. Garey and D. S. Johnson. Computers and Intractability - A Guide to
the Theory of NP-Completeness. W. H. Freeman and Co., 1979.
37. G. Gottlob, N. Leone, and F. Scarcello. The complexity of acyclic conjunctive
queries. In Proc. 39th IEEE Symp. on Foundation of Computer Science, pages
706–715, 1998.
38. G. Gottlob, N. Leone, and F. Scarcello. A comparison of structural CSP decom-
position methods.
In Proc. 16th Int’l Joint Conf. on Artiﬁcial Intelligence,
pages 394–399, 1999.
39. G. Gottlob, N. Leone, and F. Scarcello. Hypertree decompositions and tractable
queries. In Proc. 18th ACM Symp. on Principles of Database Systems, pages
21–32, 1999.
40. M. Grohe.
The complexity of homomorphism and constraint satisfaction
problems seen from the other side. In Proc. 44th IEEE Symp. on Foundations
of Computer Science, pages 552–561, 2003.
41. M. Grohe, T. Schwentick, and L. Segouﬁn. When is the evaluation of conjunc-
tive queries tractable?
In Proc. 33rd ACM Symp. on Theory of Computing,
pages 657–666, 2001.
42. M. Gyssens, P. G. Jeavons, and D. A. Cohen. Decomposition constraint satisfac-
tion problems using database techniques. Artiﬁcial Intelligence, 66:57–89, 1994.
43. P. Hell and J. Neˇsetˇril.
On the complexity of H-coloring.
Journal of
Combinatorial Theory, Series B, 48:92–110, 1990.
44. P. Hell and J. Neˇsetˇril. Graphs and Homomorphisms. Oxford Lecture Series in
Mathematics and Its applications, No. 28. Oxford University Press, 2004.
45. Ph. G. Kolaitis and J. Panttaja. On the complexity of existential pebble games.
In Proc. 12th Conf. Computer Science Logic, Lecture Notes in Computer
Science, volume 2803, pages 314–329. Springer, 2003.
46. Ph. G. Kolaitis and M. Y. Vardi. The decision problem for the probabilities of
higher-order properties. In Proc. 19th ACM Symp. on Theory of Computing,
pages 425–435, 1987.
47. Ph. G. Kolaitis and M. Y. Vardi. On the expressive power of variable-conﬁned
logics. In Proc. 11th IEEE Symp. on Logic in Computer Science, pages 348–359,
1996.

370
6 Constraint Satisfaction
48. Ph.G. Kolaitis and M.Y. Vardi. Conjunctive-query containment and constraint
satisfaction. Journal of Computer and System Sciences, pages 302–332, 2000.
49. Ph.G. Kolaitis and M.Y. Vardi.
A game-theoretic approach to constraint
satisfaction. In Proc. of the 17th National Conference on Artiﬁcial Intelligence,
pages 175–181, 2000.
50. V. Kumar.
Algorithms for constraint-satisfaction problems.
AI Magazine,
13:32–44, 1992.
51. R. E.—Ladner. On the structure of polynomial time reducibility. Journal of
The Association for Computing Machinery, 22:155–171, 1975.
52. B. Larose, C. Loten, and C. Tardif. A characterisation of ﬁrst-order constraint
satisfaction problems. In Proc. 21st IEEE Symp. on Logic in Computer Science,
pages 201–210, 2006.
53. L. A. Levin.
Universal sorting problems.
Problemy Peredaci Informacii,
9:115–116, 1973. In Russian. English translation in Problems of Information
Transmission 9:265–266, 1973.
54. A. K. Mackworth and E. C. Freuder. The complexity of constraint satisfaction
revisited. Artiﬁcial Intelligence, 59(1–2):57–62, 1993.
55. B. J. McMahan, G. Pan, P. Porter, and M. Y. Vardi.
Projection pushing
revisited. In Proc. 9th Int’l Conf. on Extending Database Technology, Lecture
Notes in Computer Science, volume 2992, pages 441–458. Springer, 2004.
56. P. Meseguer. Constraint satisfaction problems: an overview. AI Communica-
tions, 2:3–16, 1989.
57. C. Papadimitriou and M. Yannakakis. Optimization, approximation and com-
plexity classes. Journal of Computer and System Sciences, 43:425–440, 1991.
58. J. Pearson and P. Jeavons.
A survey of tractable constraint satisfaction
problems.
Technical Report CSD-TR-97-15, Royal Holloway University of
London, 1997.
59. N. Robertson and P. D. Seymour. Graph minors IV: Tree-width and well-quasi-
ordering. Journal of Combinatorial Theory, Series B, 48(2):227–254, 1990.
60. E. Rosen.
Finite Model Theory and Finite Variable Logics.
Ph.D. Thesis,
University of Pennsylvania, 1995.
61. B. Rossman. Existential positive types and preservation under homomorphi-
sisms. In Proc. 20th IEEE Symp. on Logic in Computer Science, pages 467–476,
2005.
62. Y. Saraiya.
Subtree Elimination Algorithms in Deductive Databases.
PhD
Thesis, Department of Computer Science, Stanford University, 1991.
63. T. J. Schaefer. The complexity of satisﬁability problems. In Proc. 10th ACM
Symp. on Theory of Computing, pages 216–226, 1978.
64. E. P. K. Tsang. Foundations of Constraint Satisfaction. Academic Press, 1993.
65. P. van Beek.
On the inherent tightness of local consistency in constraint
networks. In Proc. 11th National Conference on Artiﬁcial Intelligence, pages
368–373, 1994.
66. P. van Beek and R. Dechter. Constraint tightness and looseness versus local
and global consistency. Journal of The Association for Computing Machinery,
44(4):549–566, 1997.
67. M. Y. Vardi. The complexity of relational query languages. In Proc. 14th ACM
Symp. on Theory of Computing, pages 137–146, 1982.
68. M. Y. Vardi. On the complexity of bounded-variable queries. In Proc. 14th
ACM Symp. on Principles of Database Systems, pages 266–76, 1995.
69. M. Yannakakis. Algorithms for acyclic database schemes. In Proc. 7 Int’l Conf.
on Very Large Data Bases, pages 82–94, 1981.

7
Local Variations on a Loose Theme:
Modal Logic and Decidability
Maarten Marx and Yde Venema
7.1 Introduction
This chapter is about decidability and complexity issues in modal logic; more
speciﬁcally, we conﬁne ourselves to satisﬁability (and the complementary
validity) problems. The satisﬁability problem is the following: for a ﬁxed
class of models, to determine whether a given formula ϕ is satisﬁable in some
model of that class (a more precise deﬁnition will follow). The general picture
is that modal logic behaves quite well in this respect. In fact, many authors
follow Vardi [58] in calling modal logic robustly decidable on the ground that
most of the nice computational properties of modal logic are preserved if one
considers extensions or variants of the basic system. The main aim of this
chapter is to reﬁne and analyze this picture.
To start with, we should clarify what we are talking about when using
the term “modal logic”. Traditionally, propositional modal logic would be
described as an extension of propositional logic with operators 2 and 3 for
talking about the necessity and possibility of a formula being true. However,
nowadays the term “modal logic” is used for a plethora of formalisms, with
applications in various disciplines ranging from linguistics to economics,
see [11, 17, 39, 56] for a sample of applications in computer science.
And while (propositional) modal logics will usually still be an extension of
classical propositional logic with a number of modal operators, the intended
meanings of these operators diﬀer enormously. For instance, the formula 2aϕ
could mean “player a knows that ϕ is the case” in a formalization of game
theory, or “after the execution of program a, ϕ will be the case” in a formal
language for program veriﬁcation. Fortunately, on a technical level, all these
formalisms still have a lot in common. That is why this chapter ﬁrst introduces
the notion of a modal system as a triple consisting of a (propositional) modal
language, a class of models and a truth function. This deﬁnition covers most
of the systems that appear in the literature under the name “modal logic”; in
particular, the familiar system of basic modal logic, to be discussed in Sect. 7.3.

372
7 Modal Logic and Decidability
Now that we know what modal logic is, can we say what makes it so
robustly decidable? If we conﬁne ourselves to basic modal logic, the answer
seems to be aﬃrmative. As we shall see further on, the fact that the truth
of basic modal formulas is invariant under bisimulations ensures that basic
modal logic has the tree model property. That is, every satisﬁable modal
formula is satisﬁable in a special, “loose”, model based on a tree. This makes
it much easier to check whether a given modal formula is satisﬁable: one
only needs to worry about these loose models. And since the bisimulation
invariance property transfers to many extensions and variants of the basic
modal system, so does the decidability of the satisﬁability problem.
This analysis, due to Vardi [58], in terms of a looseness principle, will form
the main theme of our chapter. However, it can only form part of the story.
For instance, suppose that we are interested not just in decidability, but also
in the computational complexity of the satisﬁability problem. Not all loose
modal systems are in the same complexity class, so there must be principles
besides looseness that determine the computational behavior of a modal
system. Or, what if we happen to be working with a modal system that does
not allow trees as models? Will this necessarily make the logic undecidable?
Answers to such questions cannot be precise and general at the same time
— note that the problem of whether a given modal axiom determines a
decidable modal logic (“logic” here in the technical sense; see below), is
itself undecidable! Nevertheless, we believe that it is possible to provide
some rough guidelines, and we shall discuss some of these in this chapter; in
particular, at the end of Sect. 7.3, we discuss two locality principles.
Thus, it is our aim to act as the reader’s travel guide in the landscape
of modal logics by pointing out some interesting decidability and complexity
theoretic phenomena and by suggesting an interpretation of these phenomena
as local variations on a loose theme. On the trip we shall introduce some
important modal systems and proof methods — but we have not aimed for
a complete or systematic overview in this respect. (For instance, we shall not
employ any automata-theoretic methods.) No previous exposure of the reader
to modal logic is assumed. Finally, we do not usually provide credits or give
references in running text; these are supplied in the “Notes” paragraphs that
ﬁnish each section.
Overview of chapter In the next section we explain our interpretation of the
terms “modal logic” and “modal systems”, and we deﬁne the notion of bisim-
ulation. Section 7.3 discusses basic modal logic, giving a detailed proof of the
decidability of its satisﬁability problem; analyzing this proof, we introduce the
notions of looseness and locality. In the section after that, we use a number of
examples to show what happens if we play around a bit with these principles.
Section 7.5 is devoted to a more ﬁne-grained, complexity-theoretic study of the
modal satisﬁability problem. In the last section, we show how one can use the
principles discussed in the earlier parts of the chapter to ﬁnd large fragments
of ordinary ﬁrst-order logic that have a decidable satisﬁability problem.

7.2 Modal Systems and Bisimulations
373
7.2 Modal Systems and Bisimulations
In this section, we discuss our interpretation of the term “modal logic” by
deﬁning and explaining the notion of a modal system. We also introduce the
fundamental notion of similarity between two modal models, namely that of
a bisimulation. The link between modal logic and bisimulation is that modal
formulas cannot distinguish bisimilar points.
Modal Systems
A modal system consists of a modal language L, a class of models K, and a
function ⊩interpreting formulas of the language in the models. As models,
we shall consider only relational structures, that is, structures consisting of
a nonempty domain or universe together with a number of relations on it.
By the size of a model M, we always denote the size of its domain. The
elements of the universe of a model will be called states, points, or worlds.
In the modal part of this chapter we shall conﬁne ourselves to models that
have a number of binary relations (usually just one, which we denote by R)
and a countable number of unary relations P0, P1, . . . See Figure 7.1 for a
graphical presentation of these models.
A modal language is a simple yet expressive language for talking about
such relational structures. In this chapter we consider only propositional
modal languages; these can be described as extensions of the classical
propositional language with a collection of modal connectives such as the
unary modal operator 3. Like the boolean connectives, the modal operators
do not bind variables. The size of a formula ϕ (notation |ϕ|) in a modal
language L(Φ) (i.e., with propositional variables from a set Φ) is its length
over the alphabet Φ ∪{¬, ∧, (, ), ∇i}i∈I, where {∇i | i ∈I} denotes the set of
modal connectives of L.
6

I
-
P0, P1
P1
P1
P0
M1
A model M = (W, R, P0, P1) can be seen
as a colored directed graph; the edges give
the relation R, and the colors show the inter-
pretation of the unary predicates. (Note that
points can have more than one color.) The
graph part (W, R) of the model is also called
a modal frame.
Fig. 7.1. Graphical representation of a model

374
7 Modal Logic and Decidability
Finally, ⊩is a function which takes a model M and a formula ϕ and
returns a subset of the domain of M that we shall think of as the meaning
of ϕ in the model. The standard terminology for stating that s ∈⊩(M, ϕ) is
that ϕ is true or holds at s in M, and the standard notation is
M, s ⊩ϕ.
The meaning of the propositional variable pi is the corresponding set Pi, and
thus
M, s ⊩pi ↔Pis.
For the Boolean connectives we have the standard interpretation in mind,
which requires that ¬ϕ is true at a state iﬀϕ is false (i.e., not true) at it,
and that ϕ ∧ψ holds precisely at those states where both ϕ and ψ hold.
The conditions on modal systems mentioned so far still allow for an
enormous freedom in deﬁning the semantics of the modal connectives. But
even in this very wide and general setting we can introduce the notions of
satisﬁability and validity associated with such a triple: we call a formula valid
if it is true at every state of every model of the system, and satisﬁable if it
is true at some state of some model of the system. The validity problem of
a modal system is the problem of deciding whether a given formula of the
language is valid or not; the satisﬁability problem is deﬁned analogously.
Given our constraints on the interpretation of Boolean negation, it is obvious
that a formula ξ is valid in a class K of models if and only if its negation
¬ξ is not satisﬁable in any model in K. Hence, for any class of models K,
there are constant-time reductions between the satisﬁability problem and the
complement of the validity problem. We shall use this fact in what follows
without explicit mention; also, we shall use the term “complexity of a modal
system” when referring to its satisﬁability problem.
Each of the three ingredients of a modal system — the language L,
the class K of models, and the interpretation function ⊩— inﬂuences the
complexity of the satisﬁability problem. We shall see that many important
and interesting modal systems have a decidable satisﬁability problem, but
the above deﬁnition of a modal system is also wide enough to allow for
systems whose satisﬁability problem is highly undecidable. Our aim in this
chapter is to provide some rough guidelines for determining the complexity
of a modal system. For the sake of a simple exposition, we ﬁrst restrict our
attention to a simple yet interesting type of models: those of the signature
with one binary relation R and a number of unary relations. Even with this
signature ﬁxed, we still have an enormous freedom in deﬁning the modal
language L and the meaning of the modal connectives given by the function
⊩. What, then, the reader will ask, is particularly modal about a system?
We shall now state a further restriction on modal systems which is very
characteristic of modal logic. It concerns the discriminatory power of modal
languages.

7.2 Modal Systems and Bisimulations
375
Bisimulation
An informative way to identify a language is by saying which diﬀerences
between models it is blind to. In the case of modal logic, the fundamental
concept of equivalence between structures involves the notion of bisimulation.
Deﬁnition 7.2.1. Given two models M
=
(W, R, Pi)i∈I
and M′
=
(W ′, R′, P ′
i)i∈I, a nonempty relation Z ⊆W × W ′ is a bisimulation between
M and M′ if the following three conditions hold, for all states s ∈W and
s′ ∈W ′ that are linked by Z:
(base) for all i: Pis iﬀP ′
is′;
(forth) for all t ∈W such that Rst, there is a t′ ∈W ′ with R′s′t′ and tZt′;
(back) for all t′ ∈W ′ such that R′s′t′, there is a t ∈W with Rst and tZt′.
If there is some bisimulation Z linking s and s′, then we say that s and s′
are bisimilar; as notation we use: s ↔s′, or M, s ↔M′, s′ if we wish to
make the models explicit.
Figure 7.2 contains two simple examples of bisimulating models (the
models bisimulate horizontally) in a language with only one unary relation
P. Figure 7.3 shows two models which do not bisimulate at the roots. All
states in both models satisfy the same unary relations; M′ has all of the
ﬁnite branches that M has, but in addition it contains an inﬁnite branch.
We can now make the crucial restriction on ⊩precise: we want the truth
of modal formulas to be invariant under bisimulations. That is, our basic
p
p
w0
w1

-
p
w

p
¬p
w
v

-
¬p
p
¬p
p
v1
w1
v0
w0
. . .
-
-
-
Fig. 7.2. Two examples of bisimulating models
M′
w′
M
w


 


. . .


 


. . .
~
~
~
~ . . . . .
Fig. 7.3. M, w and M′, w′ are not bisimilar

376
7 Modal Logic and Decidability
interest is in a truth deﬁnition for the modal connectives that makes the
semantics satisfy the following constraint:
if M, s ↔M′, s′, then for all ϕ: M, s ⊩ϕ iﬀM′, s′ ⊩ϕ.
(7.1)
We shall call any system in which ⊩meets this constraint a modal system in
the narrow sense.
But why would we be interested in a language that cannot see the
diﬀerence between bisimilar states (if not for technical reasons)? Apart from
the original logical considerations that we are about to describe, an important
reason stems from theoretical computer science. Here, or more speciﬁcally in
the ﬁeld of process theory, one models processes as labeled transition systems;
these are relational structures like the one we describe here, though usually
with a collection of binary relations instead of just one. The idea here is that
a state s in a model M represents some state of the process: the predicates
Pi correspond to various direct observations that we can make about states,
and the relations Rj correspond to the various transition steps that the
process may take. A pair (s, t) belonging to the relation Rj indicates that at
s the process can take an Rj-step, thus reaching the state t, where new direct
observations can be made, or new steps can be taken. Now, in this context,
states that are bisimilar cannot be distinguished from a process-theoretic
point of view and thus represent the same state. Thus, bisimulation serves
as one of the most fundamental notions of identity between process states.
This explains why languages designed for expressing properties of processes
should indeed be blind to the distinction between bisimilar states.
Let us turn to some concrete examples. We ﬁrst give some examples of
operators which meet this requirement:
M, s ⊩3ϕ if M, t ⊩ϕ for some t such that Rst;
M, s ⊩⟨∗⟩ϕ if there is some path s = s0Rs1Rs2 . . . Rsn = t through M
such that M, t ⊩ϕ (including the empty path);
M, s ⊩⃗∞ϕ if there is some path s = s0Rs1Rs2 . . . through M
such that M, si ⊩ϕ for inﬁnitely many i.
We shall show later on that indeed, 3 does not break the bisimulation invari-
ance (see (7.2) below; the proofs for the other operators are left to the reader).
The operators ⟨̸=⟩, E, P, and U deﬁned below are not invariant under
bisimulations. Figure 7.4 shows two models M1, M2, both of signature R, P,
and worlds s1, s2, which bisimulate. The valuation of P is indicated in the
models. Since both s1 and s2 have no successors, they bisimulate because
they are both not in P. It is easy to see that ⟨̸=⟩p, Ep and Pp are all true
at s1 and all false at s2. A counterexample to the bisimulation invariance of
the binary connective U is provided just above Figure 7.7 on page 398. The
semantics of the operators is deﬁned as follows:

7.2 Modal Systems and Bisimulations
377
6
↔
P
s1
s2
M1
M2
Fig. 7.4. The modal operators ⟨̸=⟩, E and P are not invariant under bisimulations
M, s ⊩⟨̸=⟩ϕ
if M, t ⊩ϕ for some t such that s ̸= t;
M, s ⊩Eϕ
if M, t ⊩ϕ for some t in M;
M, s ⊩Pϕ
if M, t ⊩ϕ for some t such that Rts;
M, s ⊩U(ϕ, ψ) if M, u ⊩ϕ for some u such that Rsu;
while M, t ⊩ψ for all t satisfying Rst and Rtu.
It seems that 3 is the simplest nontrivial operator that satisﬁes the condition
of bisimulation invariance. The modal system in which we take 3 as the
only modal operator, in which we allow every relational structure (of the
appropriate signature) as a model, and in which ⊩has the standard deﬁnition,
is called the basic modal logic. It is discussed in detail in Sect. 7.3.
Some Comments
Before turning to the discussion of the basic modal system, a few comments
are in place.
First, it was not our intention to give very rigid deﬁnitions. For instance,
the question of whether the universal diamond E constitutes a modal system
in the narrow sense is really dependent on the perspective that one takes.
Earlier on we said that E is not bisimulation-invariant, but what if we take as
our class of models precisely those in which R is the universal relation on the
model (that is, ∀xy Rxy)? In this case the truth deﬁnition for E does satisfy the
standard, “bisimulation-invariant” clause for the diamond E; the only thing is
that now, our class of models is not closed under taking bisimilar models. . .
Second, in our introductory discussion we avoided the word “logic”. In
principle, we prefer to use this word in the technical sense only, referring
to a set of formulas that satisﬁes certain closure properties. For instance, a
normal modal logic should be closed under the familiar law of Modus Ponens,
and under the rule of Necessitation; the latter means that 2ϕ belongs to
the logic whenever ϕ does. We can associate such a logic with many modal
systems; in particular, when the system’s class of models is deﬁned through
some property of the binary relation(s) only, the collection of valid formulas
will form a logic in the technical sense. Thus the validity problem can often
be identiﬁed with a membership problem, namely that of a formula in a

378
7 Modal Logic and Decidability
logic. In a number of cases, we shall forget our principles and follow custom
in referring to this associated logic instead of to the modal system.
Finally, the term “modal system in the narrow sense” should not be taken
too literally; by playing around with the class K of models, the reader will
easily see that our deﬁnition covers a wide range of modal logics. In fact, if
we allow languages with more than one modality, then even various versions
of ﬁrst-order logic itself, such as the ﬁnite-variable fragments, can be seen as
modal systems in the narrow sense!
7.3 Basic Modal Logic
In this section, we shall introduce the basic system of modal logic and discuss
its close connection to the notion of bisimulation. We shall provide a fairly
detailed proof of the decidability of the satisﬁability problem for basic modal
logic and analyze this result in terms of looseness and locality.
Deﬁnition 7.3.1. Given a set Φ of propositional variables, the collection
L3(Φ) of basic modal formulas in Φ is given by the following rule:
ϕ ::= p | ¬ϕ | ϕ ∧ψ | 3ϕ,
where p ranges over elements of Φ. This means that ϕ is either an atomic
formula consisting of a proposition letter in Φ, or a more complex formula
obtained from simpler ones by applying one of the connectives ¬, ∧, or 3.
We shall use the standard Boolean abbreviations and also the modal “box”
operator 2, where 2ϕ abbreviates ¬3¬ϕ.
If the collection Φ of proposition letters is either irrelevant or clear from
context, we shall frequently omit it, writing L3 instead of L3(Φ). In order to
interpret the formulas of this language in a model of the kind discussed above,
we represent such a model as a triple M = (W, R, V ) where W is a nonempty
set of states, R is the binary relation of the model, and V : Φ →P(W) is
a valuation mapping proposition letters to subsets of W. Let M denote the
class of all such models.
Deﬁnition 7.3.2. Given a model M = (W, R, V ), a state s ∈W, and a
formula ϕ, we deﬁne the notion of ϕ being true at s, denoted by M, s ⊩ϕ,
recursively as follows:
M, s ⊩p
if s ∈V (p);
M, s ⊩¬ϕ
if not M, s ⊩ϕ;
M, s ⊩ϕ ∧ψ if M, s ⊩ϕ and M, s ⊩ψ;
M, s ⊩3ϕ
if M, t ⊩ϕ for some t such that Rst.
If ϕ is true at every state of the model we say that ϕ holds throughout M,
denoted by M ⊩ϕ; if ϕ holds at some state in M, we say that ϕ is satisﬁable
in M.

7.3 Basic Modal Logic
379
The language of the basic modal system is L3, its class of models is M,
and ⊩is as in the ﬁrst part of this deﬁnition. Depending on the context, we
let K denote either the basic modal system itself or its logic, that is, the set
of valid formulas in this system.
As the reader can easily verify, it holds that
M, s ⊩2ϕ if M, t ⊩ϕ for all t such that Rst.
The ﬁrst thing we should check is whether we have met our design crite-
rion (7.1) with this deﬁnition of ⊩. Suppose that M and M′ are two modal
models, and that Z is a bisimulation between M and M′. We shall prove by
a formula induction that every basic modal formula ϕ satisﬁes the following:
for all s ∈W and s′ ∈W ′: sZs′ implies that M, s ⊩ϕ iﬀM′, s′ ⊩ϕ. (7.2)
We leave the base step and the boolean cases of the inductive step as exercises
for the reader, and concentrate on the modal case of the inductive step.
Suppose that ϕ is of the form 3ψ, and assume that Z links the state s in M
to s′ in M′. For reasons of symmetry, it suﬃces to show that M, s ⊩ϕ only
if M′, s′ ⊩ϕ.
Suppose that M, s ⊩3ψ. By the truth deﬁnition, it follows that there is
a state t in W such that Rst and M, t ⊩ψ. From the fact that s and s′ are
linked by the bisimulation Z, we may infer that there is some R-successor t′
of s′ such that s′Zt′. The inductive hypothesis gives us that M′, t′ ⊩ψ; but
we may then conclude from R′s′t′ that M′, s′ ⊩3ψ, which is precisely what
we were after. This proves (7.2) and shows that basic modal logic indeed
constitutes a bisimulation-invariant system.
Invariance Under Bisimulation
So our deﬁnition fulﬁlls our design criterion, but how powerful is this modal
language precisely? In other words, how many of the bisimulation-invariant
properties can we express in this language? It should be obvious from the
truth deﬁnition of basic modal logic that we can consider L3 as a fragment
of ﬁrst-order logic. In fact, we have a kind of functional completeness result
as long as we consider ﬁrst-order properties: every ﬁrst-order deﬁnable
bisimulation-invariant property is deﬁnable by a modal formula. In other
words, when it comes to expressing bisimulation-invariant properties, modal
logic is just as strong as ﬁrst-order logic. In order to state this result formally
we need a translation from modal to ﬁrst-order formulas.
Deﬁnition 7.3.3. Assume that we have an enumeration x = x0, x1, . . . of
ﬁrst-order variables. Consider the following translation of L3-formulas to
ﬁrst-order formulas:

380
7 Modal Logic and Decidability
ST xi(p) = Pxi
ST xi(¬ϕ) = ¬ST xi(ϕ)
ST xi(ϕ ∧ψ) = ST xi(ϕ) ∧ST xi(ψ)
ST xi(3ψ) = ∃xi+1(Rxixi+1 ∧ST xi+1(ϕ)).
When we speak of “the” standard translation of a modal formula ϕ, we are
usually referring to the formula ST x0(ϕ).
We can now see modal logic as a fragment of ﬁrst-order logic because
every modal formula is equivalent to its standard translation. Formally (but
blurring the distinction between a modal and a ﬁrst-order model a little), we
can prove that for every modal formula ϕ, for every model M, and for every
state s in M we have the following equivalence:
M, s ⊩ϕ ↔M |= ST x0(ϕ)[x0 →s].
(7.3)
Here [x0 →s] denotes any assignment which sends x0 to s. The simple proof
of (7.3) is left to the reader.
Observation 1 The map in Deﬁnition 7.3.3 has no upper bound on the num-
ber of variables used in the ﬁrst-order translation of a modal formula. However,
one could be very parsimonious and deﬁne the formulas ST x(ϕ) and ST y(ϕ)
through a mutual recursion, of which the interesting clauses run as follows:
ST x(3ψ) = ∃y(Rxy ∧ST y(ϕ))
ST y(3ψ) = ∃x(Ryx ∧ST x(ϕ)).
This shows that, in fact, the translation of modal logic to ﬁrst-order logic
can be carried out within the two variable fragment of ﬁrst-order logic. We
shall come back to this observation later on.
Now we are ready to state the celebrated Characterization Theorem for
modal logic.
Theorem 7.3.4. Let ϕ(x) be a ﬁrst-order formula in the signature consisting
of a binary R and a set {Pi | i ∈I} of unary predicates. Then ϕ(x) is
invariant under bisimulations if and only if it is equivalent to the standard
translation of a modal formula.
The proof of the functional completeness part of the theorem (the left-
to-right direction) falls outside the scope of this book but can be found in
any good textbook on modal logic; see the notes. The other direction of the
theorem, which just states that the modal language obeys the design criterion
(7.1), is the more important one for us here. One way to look at (7.1) is that
once we know that a formula is satisﬁable at some state in some model, we
know by the invariance result that it is also satisﬁable in any bisimilar state in
any bisimilar model. This means that we can transform the original model into
one that suits our purposes best. Obviously, this method applies to any notion
of invariance for any language. The nice thing about bisimulation, however, is
that it allows the freedom of completely unraveling a model into a tree model.

7.3 Basic Modal Logic
381
Deﬁnition 7.3.5. Given a model M = (W, R, V ) and a state s1 in M,
we deﬁne the unraveling or unwinding of M around s1 as the following
model Mu
s1 = ( ⃗Ws1, ⃗R, ⃗V ). Its universe ⃗Ws1 is deﬁned as the set of all ﬁnite
paths through M starting at s1; formally, ⃗Ws1 is the collection of all tuples
⟨s1, . . . , sn⟩(with n ≥1) that satisfy Rsisi+1 for all i < n. The relation ⃗R
holds of the tuples s = ⟨s1, . . . , sn⟩and t = ⟨t1, . . . , tm⟩if and only if t is
obtained from s by adding an R-successor of sn. Formally, we put ⃗Rst if
m = n + 1 and si = ti for all 1 ≤i ≤n. Finally, the truth of a proposition
letter at a tuple is completely determined by its truth in M at the last element
of the tuple. Formally, let last(⟨s1, . . . , sn⟩) denote the state sn, and deﬁne
⃗V by ⃗V (p) = {s ∈⃗Ws1 | last(s) ∈V (p)}.
An example of an unraveling is given in Figure 7.5. Another example can
be found in Figure 7.2, in which the model on the lower right-hand side is (an
isomorphic copy of) the unraveling of the model on the lower left-hand side.
The operation of unraveling is also well known from process theory: the
points of the unravelled model Mu
s1 can be viewed as the process histories
or traces that start at s. From a technical perspective, the unraveling of M
around s1 has certain desirable properties:
•
there exists a point with no predecessor, the root;
•
⃗R is acyclic; and
•
⃗R is injective in the sense that every point except the root has a unique
predecessor.
In other words, the graph ( ⃗Ws1, ⃗R) is a tree. It is useful to look at this tree
as being a normal form of the model.
One can easily check that for any model M and any state s in M, the
(graph of the) function last : ⃗Ws →W constitutes a bisimulation between
Mu
s and M that links ⟨s⟩to s. But it immediately follows from this that ⟨s⟩
(in Mu
s ) satisﬁes exactly the same formulas as s (in M). Combining this with
the observation that unravelings are trees, we ﬁnd that every satisﬁable basic
modal formula is also satisﬁable in a tree. We say that a modal system (L, K, ⊩
) has the tree model property if, for every satisﬁable formula ξ in L, there exists
a tree in K in which ξ is satisﬁable. Thus we have established the following.
Theorem 7.3.6. The basic modal system has the tree model property.
The following observation is a driving force behind our search for decidable
modal fragments of ﬁrst-order logic.
s0
s1
s2
s3
*
j
j
*
⟨s0⟩
⟨s0, s1⟩
⟨s0, s2⟩
⟨s0, s1, s3⟩
⟨s0, s2, s3⟩
*
j
-
-
Fig. 7.5. Example of an unraveling

382
7 Modal Logic and Decidability
Observation 2. In proving the last theorem we did not use any property of
basic modal logic other than its invariance under bisimulation. This means
that, in fact, any modal system with a bisimulation-invariant semantics
has the tree model property — provided, of course, that tree models are
admissible in the system!
Games
In order to facilitate a comparison with the Ehrenfeucht-Fra¨ıss´e games often
used in ﬁrst-order logic, it is convenient to rephrase the notion of a bisimu-
lation between two models in game-theoretic terms. Let M = (W, R, V ) and
M′ = (W ′, R′, V ′) be two models, and let s0 and s′
0 be two states in M and
M′, respectively.
We deﬁne the bisimulation game as a variant of the familiar Ehrenfeucht-
Fra¨ıss´e games. In each round of the bisimulation game, ∀selects one of the
two models and, inside this model, he chooses a successor of the element
played in the previous round (in the ﬁrst round he chooses a successor of s0
or s′
0). ∃responds with a successor of the last element played in the other
structure. The length l of the game is deﬁned as the number of rounds and
can be either ﬁnite or inﬁnite. A match of the game thus gives rise to two
sequences: s = s0, s1, s2, · · · and s′ = s′
0, s′
1, s′
2, · · · , of elements in M and M′,
respectively.
∃wins this match of the game if for each i, si and s′
i agree on the truth
of all propositional variables; otherwise, ∀wins. We say that ∃has a winning
strategy in the game Gl
b(M, M′, s, s′) of l rounds played in M, s, M′, s′ if ∃
can win every match of length at most l starting in the states s and s′.
It should be fairly clear that ∀is trying to spoil a bisimulation between
M, s and M′, s′, while ∃has the opposite intention. Indeed we have a precise
game-theoretic characterization of the notion of bisimulation.
Proposition 7.3.7. There exists a bisimulation between M, s and M′, s′ if
and only if ∃has a winning strategy in the game Gω
b (M, M′, s, s′).
As a corollary, we ﬁnd that the truth of modal formulas is preserved when
∃has a winning strategy in the game Gω
b (M, M′, s, s′). What is interesting
about these games is that they facilitate a more ﬁne-grained perspective on
such connections. In particular, if ∃has a winning strategy in a game of ﬁxed
ﬁnite length n, what can we say about the preservation of modal formulas?
Quite a lot, according to the proposition below; in order to formulate it, we
need the notion of the modal depth of a formula — the straightforward analog
of ﬁrst-order logic’s quantiﬁer depth.
Deﬁnition 7.3.8. The modal depth d3(ϕ) of a modal formula is inductively
deﬁned as follows:

7.3 Basic Modal Logic
383
d3(p) = 0
d3(¬ψ) = d3(ψ)
d3(ψ1 ∧ψ2) = max(d3(ψ1), d3(ψ2))
d3(3ψ) = 1 + d3(ψ).
Proposition 7.3.9. Let Φ be a ﬁnite set of proposition letters, and let n be
some natural number. The following are then equivalent:
1. ∃has a winning strategy in the game Gn
b (M, M′, s, s′).
2. M, s and M′, s′ satisfy the same L3(Φ) formulas up to modal depth n.
We omit the fairly standard proof of this proposition — the notes contain
references. The analogous proposition relating Gω
b (M, M′, s, s′) and the full
modal language does not hold, as is witnessed by the models in Figure 7.3.
What have we gained from this slightly more ﬁne-grained analysis of
modal logic? We have already seen that any satisﬁable modal formula ξ can
also be satisﬁed at the root s of a tree model M: take, for instance, some
unraveling of the original model. From Proposition 7.3.9 we can conclude
that such a ξ can also be satisﬁed in a bounded-depth tree model M′: simply
take the tree model M and throw away all states that are further than d
steps away from the root s (where d is the modal depth of ξ). It is obvious
that ∃has a winning strategy in the bisimulation game Gd
b (M, M′, s, s).
From this it follows that ξ holds at the root s of the bounded-depth tree M′.
Finite Trees
We shall now show that the satisﬁability problem for the basic modal language
(with respect to the class of all models) is indeed decidable. We shall do so by
establishing the bounded model property. A modal language is said to have this
property with respect to a class K of models if every formula ξ that is satisﬁable
in some model in K can in fact be satisﬁed in a ﬁnite model in K of bounded size
(that is, the size of the model is bounded by some computable function on |ξ|).
Now, in order to show that the language of basic model logic has this
bounded model property, let ξ be an arbitrary satisﬁable formula. We have
already seen that we may assume that ξ is true at the root of a tree model M
of depth not exceeding the modal depth of ξ. This tree model might still be
inﬁnite because of inﬁnite branching, but now we recursively prune the tree
as follows. Starting at the root, for every subformula of ξ of the form 3ϕ, we
choose a successor of the root at which ϕ is true (if such a successor exists at
all). Obviously, at most b successors can be chosen, where b is the number of
diamond subformulas of ξ. Hence, by deleting from the model all successors
that have not been chosen, together with their descendants, we obtain a tree
model whose branching degree at the root is at most b. A simple veriﬁcation
shows that ξ still holds at the root. Now we repeat this process at each of

384
7 Modal Logic and Decidability
the chosen successors of the root and continue until the leaves of the tree are
reached. Obviously, ξ is still satisﬁed at the root.
Thus we have proved the following.
Proposition 7.3.10. Any satisﬁable modal formula ξ can be satisﬁed at the
root of a ﬁnite tree model, of which the depth is bounded by the modal depth of
ξ and the branching degree is bounded by the number of diamond subformulas
of ξ.
The decidability of basic modal logic is a straightforward corollary of this.
(For instance, we can use the standard translation, the equivalence (7.3), and
the fact that ﬁrst-order model checking is decidable.)
Theorem 7.3.11. The basic modal system K has a decidable satisﬁability
problem.
We shall now describe a decision procedure which on input ξ systemati-
cally tries to build the tree model for ξ described in Proposition 7.3.10. The
procedure is based on a simple but powerful idea: it tries to build a model
(W, R, V ) in which
1. the states are ﬁnite sets Δ of “relevant” formulas;
2. we have the following “truth = membership” principle:
ϕ ∈Δ ↔M, Δ ⊩ϕ,
(7.4)
for all relevant formulas ϕ and for all states Δ in the model.
Suppose we can build such a model for an input formula ξ. Then by the truth
lemma (7.4), ξ is satisﬁable if it belongs to some state Δ in our model. Our
implementation of the decision procedure is based purely on the proof of the
truth lemma; hence, in order to motivate the procedure, we now indicate
how to arrive at this proof. Fix a formula ξ.
Let us ﬁrst conﬁne the collection of relevant formulas. This set will change
from state to state but, basically, all relevant formulas will be subformulas
of ξ; we need a little extra, though. Given a formula ϕ, let ∼ϕ denote the
formula ψ if ϕ is of the form ¬ψ; otherwise, ∼ϕ is the formula ¬ϕ; we say
that a set Σ of formulas is closed under taking single negations if ∼ϕ ∈Σ
whenever ϕ ∈Σ. This notion enables us to pretend that a ﬁnite set is closed
under taking negations by treating ∼ϕ as if it were the real negation of ϕ.
Now, given a set of formulas Σ, let Cl(Σ) be the smallest set of formulas
that extends Σ and is closed under taking subformulas and single negations.
When ξ is a formula, we denote the set Cl({ξ}) of relevant ξ formulas as
Cl(ξ); it is easy to see that the cardinality of Cl(ξ) is linear in the length of ξ.
Each state of our model M = (W, R, V ) will be a subset of Cl(ξ), but
rather than precisely deﬁne the universe W now, we assume here that we
have deﬁned it, and gather suﬃcient requirements to be placed on this
deﬁnition to enable a proof of (7.4). First we consider the valuation: the

7.3 Basic Modal Logic
385
truth lemma prescribes a unique way to deﬁne V , at least for the proposition
letters occurring in ξ: V (p) = {Δ | p ∈Δ}. For a deﬁnition of the relation
R, we shall be rather opportunistic. Again we use the truth lemma as our
guideline: it shows that if R(Δ, Δ′) is to hold, then we should avoid the
existence of a relevant formula 3ϕ such that ϕ ∈Δ′ but 3ϕ ̸∈Δ. Now, R is
deﬁned by turning this requirement into a deﬁnition: we put (Δ, Δ′) into R
precisely when the above situation does not occur.
Let us now see what requirements we have to impose on the set W;
that is, suppose that we want to give an inductive proof of the “truth =
membership” principle. Assume that with each state Δ, we have associated
a collection Σ ⊇Δ of relevant formulas.
Obviously, the atomic case of the truth lemma holds by the deﬁnition of
V . For the inductive boolean cases to go through, it is suﬃcient to require
that Δ is maximal with respect to being a propositionally consistent subset of
Σ. That is, Δ and Σ have to satisfy the following condition Prop-Max(Δ, Σ):
– (for each ∼ϕ ∈Σ): ∼ϕ ∈Δ ↔ϕ ̸∈Δ; and
– (for each ϕ ∧ψ ∈Σ): ϕ ∧ψ ∈Δ ↔ϕ ∈Δ and ψ ∈Δ.
The inductive modal case imposes two further constraints, one for each
direction of the truth lemma. We met the ﬁrst one already when we deﬁned
our relation R, but given that Prop-Max(Δ, Σ) holds, we can reformulate
this condition as follows:
•
if R(Δ, Δ′), then for all 3ψ ∈Σ: ∼3ψ ∈Δ implies ∼ψ ∈Δ′.
This formulation clearly brings about the conditions that each successor of Δ
should satisfy. The other direction of the truth lemma for the case ϕ = 3ψ
presents an existential requirement:
•
if 3ψ ∈Δ, then there has to be a Δ′ such that ψ ∈Δ′ and R(Δ, Δ′).
Observe that in this last existential requirement we encounter the branch-
cutting argument that we saw earlier on. Then we only kept successor states
if there was a reason in the form of a 3ψ formula; now, we only create a
successor if we need it as a witness for such a formula. The search for suitable
successors is the driving force behind our algorithm.
But what about these associated sets of relevant formulas? Will every for-
mula in Cl(ξ) be relevant throughout the procedure? No, and this is precisely
what will bound the recursion depth of the algorithm: the set of relevant for-
mulas will decrease as we move away from the root of the model. This is remi-
niscent of the bounded depth of the tree model in Proposition 7.3.10. In partic-
ular, the set of relevant formulas for a state Δ which is m steps away from the
root will consist of all formulas from Cl(ξ) of modal depth at most d3(ξ)−m.
The algorithm presented in Figure 7.6 implements this search for a tree
model. We claim that for sets of formulas Δ and Σ such that Σ is closed
under taking subformulas and single negations, K-World(Δ, Σ) will be true
iﬀthere exists a tree model M such that at the root s, for all ψ ∈Σ,
(M, s ⊩ψ ↔ψ ∈Δ). This function can be used to solve the satisﬁability

386
7 Modal Logic and Decidability
Assume that Δ and Σ are ﬁnite sets of formulas such that Δ ⊆Σ and
Σ is closed under taking subformulas and single negations.
K-World(Δ, Σ) if and only if
•
Prop-Max(Δ, Σ), and
•
for each formula 3ψ ∈Δ there is a set Δψ ⊆Σ such that
–
ψ ∈Δψ,
–
(∀3ϕ ∈Σ) : ∼3ϕ ∈Δ ⇒∼ϕ ∈Δψ, and
–
K-World(Δψ, Cl({ϕ | 3ϕ ∈Σ})).
Fig. 7.6. The function K-World decides K satisﬁability
problem for the basic modal system, since ξ is satisﬁable iﬀthere exists a set
Δ ⊆Cl(ξ) such that ξ ∈Δ and K-World(Δ, Cl(ξ)) is true.
Note that with each recursive call of K-World, the size of the set Σ
decreases, since we include formulas of smaller modal depth only. Thus the
recursion depth is bounded by the modal depth of the input formula ξ.
That the function is correct can be proved by induction on the size of Σ;
we leave this to the reader. By an appeal to Savitch’s Theorem (PSPACE =
NPSPACE), it is not hard to see that the procedure runs in PSPACE. We
shall come back to this aspect in Section 7.5.
This ﬁnishes the proof of Theorem 7.3.11; in the remainder of this chapter
we shall analyze this proof and see how much of it can be used for other
(modal) logics.
Looseness and Locality
In analyzing this decidability proof, we can distinguish a number of relevant
properties of the basic modal system. First of all, bismulation invariance
ensures that, in order to check the satisﬁability of a modal formula, we only
have to worry about “loose” tree models. We shall call this the looseness
principle of basic modal logic; this property has recently gained status as
either the single or at least the crucial property that makes modal logic so
robustly decidable.
However, we believe that looseness is not all there is to say in relation
to explaining the decidability (or low complexity) of the basic modal system
K. The semantics of the basic modal language shows that modal formulas
only have a limited access to the model. This is what we dub the locality
principle of modal logic, and one can make this rather vague notion precise
in (at least) two ways.
First, in the above proof we used the fact that the eﬀect of a modal
formula is bounded by its modal depth. In particular, when working in a tree
model we can prune the relevant neighborhood of a state even further by
the method of selecting witnesses for 3-subformulas. All in all, we ﬁnd that

7.3 Basic Modal Logic
387
in order to check whether a modal formula holds at a given state of some
tree model, one only has to worry about a bounded, “local” part of the tree
model. In particular, what the basic modal language does not have is global
expressive power. We say that a modal system (L, K, ⊩) has global expressive
power if it can deﬁne the universal diamond E; that is, if there is a formula
ϕ(p) such that for every model M in K and every state s in M, we have
M, s ⊩ϕ(p) ↔M, t ⊩p for some t in M.
By the ﬁrst locality principle, we mean the lack of global expressive power.
Later on, we shall see that if we add even the tiniest bit of global expressive
power to the basic modal system, we destroy its ﬁnite tree property and lift
the complexity of the satisﬁability problem from PSPACE to EXPTIME.
We have already met the second locality principle in Observation 1. From
the fact that the basic modal language belongs to the two-variable fragment
FO2 of ﬁrst-order logic, we may conclude that the satisﬁability problem
for the basic modal system can be reduced to that for FO2. But, for every
modal language in which the connectives have a ﬁrst-order truth deﬁnition,
we can come up with a “standard translation”, so if the language has only
ﬁnitely many connectives, this standard translation remains within a ﬁxed
ﬁnite-variable fragment. Hence, if we consider a modal system (L, K, ⊩)
in which L has only ﬁnitely many connectives and in addition, the class
of models K allows a deﬁnition in some ﬁnite-variable fragment, then the
satisﬁability problem for the modal system can be reduced to that of some
ﬁnite-variable fragment FOk. Why are we interested so much in these ﬁxed
ﬁnite-variable fragments? As we shall see later, one reason is that they have
tractable model checking problems, whereas the full ﬁrst-order language does
not. To be concrete, given a ﬁnite ﬁrst-order model M and a ﬁrst-order
sentence ξ, the problem of whether M |= ξ is decidable in PTIME in M
and in ξ, if ξ is from a ﬁxed-variable fragment, whereas it is in PSPACE if
ξ is an arbitrary ﬁrst-order sentence. With the second locality principle, we
shall mean this reducibility of the satisﬁability problem to the satisﬁability
of some ﬁxed ﬁnite-variable fragment of ﬁrst-order logic (or perhaps of
some higher-order formalism, as in the case of K∗which we shall discuss
later on).
It will be useful later to state what we mean by looseness and locality in
terms of the bisimulation game. Since it is ∀who tries to spoil a bisimulation,
the strength of the bisimulation relation is determined by the moves ∀is
allowed to make. Indeed, ∀’s powers are limited. First, observe that although
a match is made up of long sequences of pairs of states, after every round it
is only the last pair which is important. Given such a pair, ∀is allowed to
choose a new element, but only if it is a successor of a state in the pair. ∃
replies and then the players check whether the match is over because ∀has
won or not. If not, the previous pair “is deleted from memory” and the game
continues.

388
7 Modal Logic and Decidability
We could view the game as being played by moving two windows across
the models. These windows completely hide the model from view, except for
at most two states. Both players move the windows across the models, and ∀
has the initiative. Now, the principle of looseness means that the states which
are visible through the window are always connected by the accessibility
relation (this shows we could equally well have dubbed the “looseness
principle a “locality” principle as well). The second locality principle is
embodied in the ﬁxed ﬁnite dimension of the window. (To describe the ﬁrst
locality principle, games do not seem to be the optimal way.)
Summarizing, it seems that these looseness and locality principles in
tandem cause the decidability of the basic modal system: looseness means
that one only has to check trees, and the ﬁrst locality principle adds that in
fact ﬁnite trees suﬃce. (For the contribution of the second locality principle,
the reader will have to wait until we discuss the generalization of the modal
language to the guarded and packed fragments of ﬁrst-order logic in Sect. 7.6.)
There can be no doubt that looseness is the most important property for the
decidability of a modal system; in fact, if we conﬁne ourselves to the class M
of all modal models, it will be hard to ﬁnd a bisimulation-invariant system
with an undecidable satisﬁability problem! The reason for this is that the
modal mu-calculus is decidable, and this modal system can be characterized
as the bisimulation-invariant fragment of monadic second-order logic over a
signature of binary relations.
7.3.1 Notes
Recent years have seen a proliferation of modern textbooks on modal logics,
of which we mention those by Chagrov & Zakharyaschev [14], Popkorn [49]
and Blackburn, de Rijke, & Venema [9].
The standard translation, in various forms, can be found in the work of
a number of writers on modal and tense logic in the 1960s. Van Benthem [4]
ﬁrst made clear the importance of systematic use of the standard translation
to access results and techniques from classical modal theory. The observation
that at most two variables are needed to translate basic modal formulas
into ﬁrst-order logic is due to Gabbay [20]. The earliest systematic study
of ﬁnite-variable fragments seems to be due to Henkin [26] in the setting
of algebraic logic, while Immerman & Kozen [34] studied the link with
complexity and database theory. See Otto [47] for more on ﬁnite-variable
logics, or Marx & Venema [43] for a modal perspective on these logics.
Bisimulations
were
ﬁrst
introduced
(under
a
diﬀerent
name)
by
van Benthem [4, 5]. The notion was introduced independently in com-
puter science, as an equivalence relation on process graphs; the ﬁrst reference
seems to be Park [48], while the classic computer science paper on the
subject is Hennessy & Milner [28]; the latter paper also discusses ﬁnitary
approximations to bisimulations. The notion of unraveling a modal model

7.4 Some Variations
389
stems from Dummett & Lemon [16]. Proposition 7.3.9 is analogous to similar
characterizaions of logical equivalence for ﬁrst-order logic, due to Ehrenfeucht
and Fra¨ıss´e (see [31]).
Theorem 7.3.4, the Characterization Theorem which identiﬁes modal
logic as the bisimulation-invariant fragment of ﬁrst-order logic, is due to
van Benthem [4, 6]. The back-and-forth clauses of a bisimulation can be
adapted to analyze the expressivity of a wide range of modal logics, and
such analyses are now commonplace. For instance, Janin & Walukiewicz [35]
have proved that Kozen’s modal mu-calculs is the bisimulation-invariant
fragment of a natural monadic second-order logic over process graphs.
Related model-theoretic characterizations can be found in Immerman &
Kozen [34] (for ﬁnite-variable logics). Rosen [51] has presented a version
of the Characterization Theorem that also works for the case of ﬁnite
models.
Finite models have long been used to establish decidability, both in modal
logic and elsewhere. Arguments based on ﬁnite axiomatizability together
with the ﬁnite model property can be traced back to Harrop [25]. The
computational complexity of the satisﬁability problem for the basic modal
system was established by Ladner [37]: it is PSPACE-complete. The function
K-World is a slight variation of Ladner’s procedure. The presentation given
here is taken from Spaan [55].
The problem of whether M |= ξ for a given a ﬁnite ﬁrst-order model M
and a ﬁrst-order sentence ξ, is PTIME-complete when ξ is from a ﬁxed ﬁnite-
variable fragment (see Immerman [33], Vardi [57]), but PSPACE-complete
when ξ is an arbitrary ﬁrst-order sentence (Chandra & Merlin [15]).
7.4 Some Variations
In this section, we shall consider some modal systems that are variations
on the basic modal system. Apart from our wish to introduce some new
proof techniques for establishing decidability of a modal system, such as
the ﬁltration and mosaic methods, our aim in this section is to clarify the
looseness and locality principles that we have just introduced.
We shall ﬁrst investigate some modal systems that are fairly “tight” in the
sense that their class of models is based on grid-like structures; as we shall
see, such a lack of looseness brings these systems close to the danger zone of
undecidability. Nevertheless, if the locality principles still hold, decidability is
still possible. The second system that we consider is obtained by adding just
a grain of global expressive power to the basic modal language, while keeping
the looseness condition. We shall see that the system is still decidable, but it
no longer has the ﬁnite-tree property. Finally, we consider a modal system in
which the operator is not bisimulation-invariant at all; however, as we shall
see, it does have another kind of looseness property, and this enables us to
prove its decidability.

390
7 Modal Logic and Decidability
7.4.1 Neither Locality nor Looseness: Grid Logics
In this subsection, we consider modal systems that cannot be called loose
or local. We shall ﬁrst meet a simple modal system that is tailored towards
encoding the N × N-tiling problem, and is undecidable; as a contrast, we shall
also discuss a second system with grid-like models which has a decidable
satisﬁability problem.
A Tiling Logic
In looking for the opposite of looseness one is bound to end up with a grid.
Grids are well known in complexity theory, since they play an important role
in the formulation of a class of complete problems for various complexity
classes: tiling problems. A tile is a one-by-one square which has a “color” on
each of its sides; these colors are given by four functions “right”, “left”, “up”,
and “down”. Given a set T of tiles, a tiling of the grid N × N by T is a map
t from N × N to T satisfying, for all n, m ∈N,
right(t(n, m)) = left(t(n + 1, m)),
up(t(n, m))
= down(t(n, m + 1)).
Tiles are assumed to be ﬁxed in orientation, so the above conditions say that
colors of adjacent tiles match. (We note that it is not necessary to use all tiles
of T in a tiling of N × N.) If such a tiling exists, we say that T can tile N × N.
The following problem is undecidable:
N × N tiling: Given a ﬁnite set T of tiles, can T tile N × N?
We shall now deﬁne a modal system Tile which is tailored to encode the
above tiling problem. The language of Tile contains two unary modalities 3r
and 3u plus the universal modality E. In a model of the form (W, Rr, Ru, V ),
these modalities receive their meaning in the usual way:
M, s ⊩3rϕ ↔M, t ⊩ϕ for some t with Rrst,
M, x ⊩3uϕ ↔M, t ⊩ϕ for some t with Rust,
M, x ⊩Eϕ
↔M, t ⊩ϕ for some t.
In the intended class of grid models, Rr and Ru are (the graphs of) two
commuting total functions. In particular, grid models satisfy the following
condition:
∀xyz((Rrxy ∧Ruxz) →∃w(Rrzw ∧Ruyw)).
(7.5)
Because of this, the class of grid models is not closed under unraveling; hence,
Tile does not satisfy the looseness principle. It is also rather obvious that the
ﬁrst locality principle fails as well, in the presence of the universal modality;
we leave it to the reader to verify that the class of grid models can be
deﬁned using three variables only, and Tile thus satisﬁes the second locality
principle.

7.4 Some Variations
391
Theorem 7.4.1. The satisﬁability problem of Tile is undecidable.
Proof. Obviously, we reduce the N × N-tiling problem to the satisﬁability
problem for Tile. We present a procedure that outputs, for every instance T
of the tiling problem, a formula ϕT such that
AϕT is Tile-satisﬁable iﬀT can tile N × N.
(7.6)
(Recall that A is the box version of E; that is, Aϕ abbreviates ¬E¬ϕ.)
Take, for any set T = {T1, . . . , Tk} of tiles, a corresponding set {t1, . . . , tk}
of propositional variables. Deﬁne ϕT as the conjunction of the following
formulas (where i ranges over 1,. . . ,k):
(A1) 
1≤i≤k ti
(A2i) ti →
i̸=j ¬tj
(A3i) ti →3r
{tj | right(Ti) = left(Tj)}
(A4i) ti →3u
{tj | up(Ti) = down(Tj)}.
It follows almost immediately that T tiles N × N if and only if there
exists a Tile model where ϕT holds throughout. (The reader should verify
that in the proof of the left-to-right direction of (7.6) the property (7.5) of
grid models is crucial.) This, in turn, is equivalent to the formula AϕT being
satisﬁable in some Tile model. Thus (7.6) holds and we have reduced the
undecidable tiling problem to the Tile satisﬁability problem.
2
We hasten to remark that the undecidability of this system has nothing
to do with the fact that we are dealing with more than one modality here;
one can easily transform this example into an undecidable modal system in
the basic modal language extended with the universal modality, or in the
basic modal language proper.
It is interesting to note that without the universal access to the models
provided by A, these grid logics become quite harmless. In fact, their grid-like
nature ensures that every satisﬁable formula ξ is satisﬁable in a model whose
size is at most |ξ|2 + 1.
Theorem 7.4.2. Let Tile−be the modal system Tile, but now without the
universal modality. Then every Tile−-satisﬁable formula ξ is satisﬁable in a
Tile−model of size at most |ξ|2 + 1. As a corollary, Tile−has a decidable
satisﬁability problem.
Proof. Let M satisfy ξ at s. Let k be the modal depth of ξ, we then have that
k ≤|ξ|. By Proposition 7.3.9, ξ is still satisﬁable in the model M′, deﬁned as
the substructure of M with universe s together with all states reachable in
at most k (Rr- or Ru-)steps from s. Clearly, the size of the universe of M′
is at most k2. Unfortunately, M′ is not a Tile model, because not every state
has an Rr and Ru successor. In order to mend this, we add one dummy state
x to the universe of M′ and put a link from w to x for all states w (including
x itself) that do not have a successor yet. That is, we deﬁne W −= W ′ ∪{x}

392
7 Modal Logic and Decidability
and R−
r = R′
r ∪{(w, x) | R′
rwy for no y in M′}, and likewise for R−
u . Let the
valuation stay the same, i.e., we deﬁne V −(p) = V ′(p) for all p.
The resulting model M−is a Tile model. Clearly, ξ is still satisﬁed at s
in this new model, since x is “too far away” to have any eﬀect on the truth of
ξ. This proves the ﬁrst part of the theorem. Decidability now follows because
it is decidable whether a ﬁnite model is a Tile model.
2
S52
The second logic that we consider here is also based on grid-like structures,
but here we require only that the models are two-dimensional in nature; there
will be no orderings or functions around. The language has two diamonds,
30 and 31, with the standard truth deﬁnition. The models are of the form
M = (W, ≡0, ≡1, V ), where we require that (W, ≡0, ≡1) is in fact a square
over some set U. That is, W consists of the set U × U of all pairs over U,
and s ≡i t holds if si = ti: the ith coordinate of s and the ith coordinate of
t should be the same. We denote the resulting system by S52.
As a modal system, S52 might look rather obscure, but as a logic, it is
well known. In fact, it is the exact modal counterpart of a restricted fragment
of ﬁrst-order logic with two variables in a signature that has a binary relation
symbol R for every propositional variable r. This can be seen as follows. First,
observe that the S52 model M = (W, ≡0, ≡1, V ) with W = U ×U is uniquely
determined by the ﬁrst-order model (U, V ) for the signature described. Also
observe that we may identify assignments s mapping the two variables x0 and
x1 to U with pairs (s(x1), s(x0)) ∈W. Thus, viewing the states of the modal
models as assignments, we may read the statement “ϕ holds in (U, V ) under
assignment s” modally as “in model (U × U, ≡0, ≡1, V ), ϕ is true at state s”.
Because S52 models are squares, the truth deﬁnition of the diamonds can be
rewritten exactly as the deﬁnition of the ﬁrst-order existential quantiﬁers:
M, (a, b) ⊩31ϕ ↔there exists a′ such that M, (a′, b) ⊩ϕ.
Thus 3i is another way of writing ∃xi. In a similar way, one can deﬁne modal
systems S5n corresponding to ﬁrst-order logic with n variables for any n. See
the notes for references.
It will be obvious that this class of models is not closed under unraveling,
and that S52 will not have the tree model property. Concerning the locality
principles, observe that this system has full global expressive power: the
“combined” operator 3031 behaves just like the universal diamond E.
Nevertheless, the system is decidable, and a proof of this uses some kind of
ﬁnite model property as well.
Here, instead of deﬁning a ﬁnite model for ξ by selecting points out of
the old model, we shall identify points in the big model and deﬁne the ﬁnite
model as some sort of quotient structure, which we call a ﬁltration of the
original model. It will turn out that this ﬁltration will not be a square itself

7.4 Some Variations
393
but a square-like structure, which we dub a pseudo-square here. That is to
say, in the underlying frame (W, R0, R1) both R0 and R1 are equivalence
relations, and their composition should be the universal relation. That is,
(W, R0, R1) has to validate
∀xy∃z(R0xz ∧R1zy).
(7.7)
For these kind of structures, we can prove the following proposition, which
establishes the bounded ﬁnite model property of the language with respect to
the class of pseudo-squares. (In fact, the system does have the bounded ﬁnite
model property, but this is much harder to establish.) As we saw before,
decidability follows immediately, because it is decidable whether a ﬁnite
structure is a pseudo-square.
Proposition 7.4.3. Any S52-formula ξ is satisﬁable in a square iﬀit is
satisﬁable in a pseudo-square of size not exceeding 2|ξ|. As a consequence,
S52 has a decidable satisﬁability problem.
Proof. We shall concentrate on the left-to-right direction of this proof, since
we are interested only in explaining the notion of ﬁltration at the moment.
(For the other direction of the proof, one shows that given a pseudo-square
model, one can always ﬁnd a square that is bisimilar to it — in fact, bisimilar
through a functional bisimulation; see the notes.)
Suppose ξ is satisﬁed somewhere in the square model M = (W, ≡0, ≡1, V ).
From this we shall prove that ξ is true somewhere in a ﬁltration Mf of M. As
we have mentioned already, ﬁltrating a model means collapsing it. But when
will two points in the original model be identiﬁed? Generally, taking a quotient
of a structure means identifying points without “relevant” diﬀerences; in the
present context this can be interpreted as “satisfying the same subformulas of
ξ”. Formally, we deﬁne Cl(ξ) to be the smallest set of formulas containing ξ
which is closed under subformulas. Now, we deﬁne the following relation on W:
s ∼s′ ↔for all ϕ in Cl(ξ) : M, s ⊩ϕ iﬀM, s′ ⊩ϕ.
Obviously, ∼is an equivalence relation. Our ﬁltrated model will be based on
the equivalence classes of this relation, and so we introduce some notation:
by ¯s we denote the equivalence class of a point s, and by W f, the set of these
classes. Note that |W f| ≤2|ξ| as |Cl(ξ)| is bounded by |ξ|.
What would be a good deﬁnition for the relations R0 and R1 on W f? In
general, this is where the ﬁltration method needs some creative input. Now, if
the only requirement were that ξ were to be true somewhere in the resulting
model, there would be a whole family of deﬁnitions that work (in the sense
that they ensure (7.8) below). But the extra constraint, namely that the
resulting model should be a pseudo-square, imposes some extra restrictions.
Nevertheless, the following deﬁnition works:
Ri¯s¯t if for all 3iϕ ∈Cl(ξ): M, s ⊩3iϕ iﬀM, s′ ⊩3iϕ.

394
7 Modal Logic and Decidability
(Observe that this is well deﬁned, by the fact that ∼-equivalent points agree
about all formulas in Cl(ξ).) Finally, the deﬁnition of V f is rather obvious:
V f(p) = {¯s ∈W f | s ∈V (p)}.
Note that this is well deﬁned for all proposition letters p occurring in ξ.
We can prove the main claim concerning ﬁltration:
for all formulas ϕ ∈Cl(ξ): M, s ⊩ϕ iﬀMf, ¯s ⊩ϕ.
(7.8)
This claim is proved by a formula induction. Leaving the straightforward
induction base and the boolean cases of the inductive step to the reader, we
concentrate on the case where ϕ is of the form 30ψ. (The case where ϕ is of
the form 31ψ is of course completely analogous.)
First, assume that M, s ⊩30ψ. Then, by deﬁnition, there is some s′ in
M such that s ≡0 s′ and M, s′ ⊩ψ. By the inductive hypothesis, this gives
that Mf, ¯s′ ⊩ψ. It easily follows from the deﬁnitions that s ≡0 s′ implies
R0¯s¯s′. But then it follows immediately that Mf, ¯s ⊩30ψ. For the other
direction, suppose that Mf, ¯s ⊩30ψ. Then, for some ¯t in Mf, we have
that R0¯s¯t and Mf, ¯t ⊩ψ. Hence, by the inductive hypothesis, we have that
M, t ⊩ψ. But then, from reﬂexivity of ≡0, it follows that M, t ⊩30ψ, and
so from R0¯s¯t we may infer, using only the deﬁnition of R0, that M, s ⊩30ψ.
This proves (7.8), so in order to prove the left-to-right direction of the
proposition we have only to show that Mf is a pseudo-square. We leave it to
the reader to verify that both R0 and R1 are equivalence relations. In order
to check the other condition, let ¯s and ¯t be points in Mf. Now the fact that
M is a square and that s and t are pairs comes in handy. Let z = (s0, t1).
Then s ≡0 z ≡1 t. But it then follows that R0¯s¯z and R1¯z¯t, which shows that
the composition of R0 and R1 is indeed the universal relation on Mf.
2
What can we conclude from the examples Tile, Tile−, and S52? Not
that looseness is a necessary condition for a modal system to be decidable:
witness Tile−and S52. On the other hand, it should be clear that dropping
the looseness principle leads us to the immediate vicinity of the danger zone:
adding only a grain of global expressive power will turn the highly decidable
logic Tile−into the undecidable Tile.
Concerning S52, it is very interesting to observe what happens if we move
to higher dimensions. For instance, there seem to be two three-dimensional
counterparts of S52, according to which relation between two triples one
takes to be the accessibility relation for 3i:
s ≡i t if sj = tj for all j ̸= i,
s ∼i t if si = ti.
In the second, relatively loose, interpretation the resulting logic is decidable.
In the ﬁrst interpretation, one obtains a class of rather tight models; the

7.4 Some Variations
395
resulting logic is undecidable. Since it is this logic that corresponds to a
three-variable fragment of ﬁrst-order logic (in a way similar to that discussed
above for S52), this makes an interesting case for the second locality principle.
7.4.2 Universal Access: K∗
We now consider the modal system K∗obtained by expanding the basic
modal language with the modality ⟨∗⟩, keeping the class of models intact
and giving both 3 and ⟨∗⟩the standard interpretation. Recall that the
meaning of ⟨∗⟩was deﬁned using the reﬂexive transitive closure R∗of the
relation R.
Let us ﬁrst see where K∗stands with respect to the looseness and
locality principles. We have seen already that ⟨∗⟩is invariant under bisim-
ulations, whence we have an analogue of Theorem 7.3.6: any K∗-satisﬁable
formula is satisﬁable in a tree model. K∗also meets the second locality
principle, at least if we are allowed to include ﬁnite-variable fragments
of the inﬁnitary language Lω1ω (an extension of ﬁrst-order logic in which
countable conjunctions and disjunctions are allowed). For it is easy to see
that K∗-formulas have correspondents in the three-variable fragment of this
language: simply add the following clause for ⟨∗⟩to the standard translation
of L3:
ST x(⟨∗⟩ψ) = ∃y(R∗xy ∧ST y(ϕ)),
ST y(⟨∗⟩ψ) = ∃x(R∗yx ∧ST x(ϕ)).
Here we use the fact that the reﬂexive transitive closure can be expressed
using three variables only; for instance, R∗xy could stand for the following
abbreviation:
x = y ∨Rxy ∨∃y′ (Rxy′ ∧Ry′y) ∨∃y′ (∃y (Rxy ∧Ryy′) ∧Ry′y) ∨. . .
However, K∗violates the ﬁrst locality principle in the following way: if r is
the root of a tree model M, then we have
M, r ⊩⟨∗⟩ϕ ↔M, s ⊩ϕ for some s in M,
as the reader can easily check. In fact, unlike the basic modal system, K∗
does not have the ﬁnite tree model property; for instance, the following
satisﬁable formula is not satisﬁable on any ﬁnite tree:
[ ∗](p →⟨∗⟩¬p) ∧[ ∗](¬p →⟨∗⟩p).
(It is satisﬁable on the natural numbers with successor, with p interpreted as
the even numbers.)
Summarizing, the present system is loose, and it satisﬁes the second
but not the ﬁrst locality principle. What about its decidability, or the ﬁnite
model property? In fact, both properties hold, as we shall see now. We ﬁrst
prove that K∗has the bounded model property.

396
7 Modal Logic and Decidability
Proposition 7.4.4. Any satisﬁable K∗formula ξ is satisﬁable on a model
of size 2O(|ξ|).
Proof. Suppose that ξ is satisﬁable in some model M = (W, R, V ). We again
deﬁne a collection of relevant formulas. This time, we need a new closure rule:
we call a set X of formulas ∗-closed if it contains 3⟨∗⟩ϕ whenever it contains
⟨∗⟩ϕ. Now let FL(ξ) be the smallest set of formulas containing ξ which is
∗-closed, besides being closed under taking subformulas and single negations.
It is not diﬃcult to prove that the cardinality of FL(ξ) is linear in the
size of ξ.
The method that we use to construct a ﬁnite model for ξ is, just as in the
case of S52, that of ﬁltration. We deﬁne the following relation on points of M:
s ∼s′ ↔for all ϕ in FL(ξ) : M, s ⊩ϕ iﬀM, s′ ⊩ϕ.
Again, it is obvious that ∼is an equivalence relation, and again, our ﬁltrated
model will be based on the collection W f of equivalence classes of this
relation; it is convenient to identify the equivalence class of s with the color
of s, which we deﬁne as the set c(s) = {ϕ ∈FL(ξ) | M, s ⊩ϕ}. Note that
|W f| ≤2O(|ξ|), as |FL(ξ)| is bounded by |ξ|.
To ﬁnish the deﬁnition of the ﬁltrated model, we deﬁne the relation Rf
on colors as follows:
Rfcd ↔for all 3ϕ ∈FL(ξ): (ϕ ∈d ⇒3ϕ ∈c).
The valuation V f is then deﬁned as V f(p) = {c ∈W f | p ∈c}.
The key claim of the ﬁltration proof is the following.
Claim 1. For all formulas ϕ ∈FL(ξ) and all colors c, ϕ ∈c iﬀMf ⊩ϕ.
Proof of Claim The proof follows by an induction on the complexity of ϕ.
We treat only the case where ϕ is of the form ⟨∗⟩ψ.
First suppose that ⟨∗⟩ψ ∈c. Assume that c is the color of s in M; that is,
M, s ⊩⟨∗⟩ψ. By deﬁnition, there is a sequence of states s1, . . . , sn in M such
that s = s1, Rsisi+1 for all i, and M, sn ⊩ψ. By the deﬁnition of colors, it
follows that ψ ∈c(sn). Also, it is easy to show that Rfc(si)c(si+1) for all i.
But then it follows immediately that Mf, c ⊩⟨∗⟩ψ.
For the other direction, suppose that Mf, c ⊩⟨∗⟩ψ. By the truth
deﬁnition of ⟨∗⟩, there must be colors c1, . . . , cn such that c = c1, Rfcici+1
for all i, and M, cn ⊩ψ. It follows from the inductive hypothesis that ψ ∈cn.
From this, and the observation that ϕ →⟨∗⟩ϕ is valid in any model, it follows
that ⟨∗⟩ψ ∈cn.
We now show that
If Rfdd′, then ⟨∗⟩χ ∈d′ implies ⟨∗⟩χ ∈d.
(7.9)
Suppose that Rfdd′ and ⟨∗⟩χ ∈d′. It follows that ⟨∗⟩χ belongs to FL(ξ), and
so 3⟨∗⟩χ is in FL(ξ) as well, by ∗-closure. But then, by the deﬁnition of Rf,

7.4 Some Variations
397
we ﬁnd that 3⟨∗⟩χ is in d. Since d is a color, there must be some w in W such
that d = c(w). By deﬁnition, we have that M, w ⊩3⟨∗⟩χ. From this it is easy
to derive that M, w ⊩⟨∗⟩χ, and so again, by deﬁnition, we have ⟨∗⟩χ ∈d.
But, from (7.9) and ⟨∗⟩ψ ∈cn, an easy downward inductive proof shows
that ⟨∗⟩ψ ∈ci for all i. In particular, we ﬁnd that ⟨∗⟩ψ belongs to c1 = c.
This ﬁnishes the proof of the claim.
Thus ξ is satisﬁable in a model of size 2O(|ξ|).
2
The last proposition implies decidability, as it is decidable whether a
K∗formula is satisﬁable on a ﬁnite model. The idea of colors can also be
used directly in an algorithm which tries to construct a model like Mf. This
construction uses the same idea as the K-World algorithm given earlier: states
are identiﬁed with subsets of Cl(ξ). Let S0 consists of all sets Δ ⊆Cl(ξ) for
which Prop-Max(Δ, Cl(ξ)) holds and which satisfy ϕ ∈Δ ⇒⟨∗⟩ϕ ∈Δ, for
all ⟨∗⟩ϕ ∈Cl(ξ). (For the deﬁnition of Prop-Max(Δ, Cl(ξ)), see Sect. 7.3.)
Clearly S0 can be eﬀectively computed and |S0| ≤2O(|ξ|). We now inductively
construct a sequence of collections of sets of formulas S0 ⊋S1 ⊋S2 ⊋S3 · · · .
During this construction, just as in the K-World algorithm, we try to ﬁnd
witnesses for diamond formulas. We say that a set Δ ∈Si is ready if Si
contains witnesses for all diamond formulas in Δ:
•
for every formula 3ψ ∈Δ there is a Δψ ∈Si such that RfΔΔψ and
ψ ∈Δψ, and
•
for every formula ⟨∗⟩ψ ∈Δ there are Δ1, Δ2, . . . , Δn ∈Si such that
Δ = Δ1, RfΔiΔi+1 and ψ ∈Δn,
If every set in Si is ready and Si contains a set Δ with ξ ∈Δ, then the
algorithms returns “ξ is satisﬁable”. If there is no set in Si containing ξ,
then the algorithms returns “ξ is not satisﬁable”. Otherwise, let Si+1 consist
of all ready sets in Si, and we continue the construction. Since Si ⊋Si+1,
the construction is guaranteed to terminate in at most 2O(|ξ|) stages. The
correctness of the algorithm can be shown along the lines of the proof of the
last proposition. Thus we have established the following.
Theorem 7.4.5. It is decidable whether a given K∗formula is satisﬁable.
7.4.3 Generalizing Looseness: the Until Operator
In this subsection, we consider the modal system given by the propositional
language expanded with the binary until operator U, the class of all models
of the form (W, R, V ), and an interpretation of U as given above (recalled
below). We have already mentioned that truth in this language is not
bisimulation-invariant, and we are thus not dealing with a modal system
in the narrow sense; in particular, we shall see that there are satisﬁable U-
formulas that are not satisﬁable in any tree. Nevertheless, we shall show that
this system does have some kind of loose model property, and we shall use this

398
7 Modal Logic and Decidability
property for showing that it has a decidable satisﬁability problem. In fact,
this “looseness property” is the reason why we take a look at this operator: it
shows in a relatively simple setting how to generalize the notions of looseness
and tree models. These generalizations are made in the section on guarded
fragments.
To start with, let LU be the language obtained by expanding the classical
propositional language with the binary connective U. Recall that M is the
class of all models of the form (W, R, V ). It is convenient to use the following
notation: for s and u elements of W,
M, su ⊩ψ iﬀM, t ⊩ψ, for all t satisfying Rst and Rtu.
(7.10)
This is because we can now rephrase the truth deﬁnition of the until operator
as follows:
M, s ⊩U(ϕ, ψ) iﬀM, u ⊩ϕ and M, su ⊩ψ, for some u such that Rsu.
(7.11)
We call the resulting modal system (LU, M, ⊩) the until system. In order to
see why truth of LU-formulas is not invariant under bisimulations, consider
the formula U(p, ⊤)∧¬U(p, p). (Here ⊤abbreviates (p∨¬p).) This formula is
satisﬁable and its smallest irreﬂexive model contains three points; see model
M1 in Figure 7.7. Note that in the unraveling M2 of the model M1, U(p, p)
holds at the root of the tree. This shows that LU is really a more expressive
language than L3. In fact, one can show that the formula U(p, ⊤) →U(p, p)
holds throughout any tree model, whence U(p, ⊤) ∧¬U(p, p) is not satisﬁable
in any tree model. This shows that the until system does not have the tree
model property.
Decidability
Unlike our earlier proofs, we shall not use any kind of ﬁnite model property
in order to prove decidability for the until system. This is not because the
system does not have the bounded ﬁnite model property (it does); our proof
6
6

I
I
6
p
p
p
¬p
¬p
M1
M2
Fig. 7.7. Until formulas are not invariant under bisimulations

7.4 Some Variations
399
method is for didactic purposes. The idea behind the mosaic method that
we employ is that instead of transforming a model into a ﬁnite model, we
could just as well “deconstruct” it into a ﬁnite “toolkit”, which we shall call
a linked set of mosaics. One then has to show that a formula is satisﬁable if
and only if there exists such a linked set of mosaics for it.
What, then, are mosaics? One could best describe them as little pieces of
a model that, if linked together in a nice way, contain suﬃcient information
to reconstruct another model which looks suﬃciently like the original one to
preserve the truth of LU-formulas. In this way we will establish a loose model
property for the until system: any satisﬁable formula is satisﬁable in a model
consisting of these isomorphic copies of mosaics that hang together only very
loosely. (Later on in the chapter, we shall come back to this issue in more
technical detail.)
Concerning the notion of a mosaic, the ﬁrst question is what information
we are interested in. This question is easy to answer: as in the ﬁltration proof
for S52, we are interested only in the truth of subformulas of ξ. The second
question then should be: which parts are we going to cut out of the model?
Here we need to deﬁne a new concept. We call a subset of the domain of a
model M = (W, R, V ) packed if every two distinct elements s and t of the
subset are R-related (that is, we require that Rst or Rts). Our patchwork
pieces will then be packed sets of size at most three.
The number three here derives from the fact that the truth deﬁnition
of U(ϕ, ψ) employs three variables. In fact, if one were to try to devise a
standard translation or a bisimulation game for the LU-language, the number
three would show up as the minimal number of variables needed and as the
minimal size of the windows that cover the models during the game. During
a game, one would see that these windows would be placed only on packed
sets of the models.
Abstracting from the origin of these pieces, we arrive at the following
deﬁnition. From now on, we let ξ be an arbitrary but ﬁxed LU formula; ξ is
the formula whose satisﬁability needs to be decided. We let Cl(ξ) denote the
set of subformulas of ξ.
Deﬁnition 7.4.6. A ξ-type mosaic is a quadruple μ = (X, R, Aϕ, Bϕ)ϕ∈Cl(ξ)
such that X is a set of size at most three; R and every Bϕ are binary relations
on X; and every Aϕ is a unary relation on X. When ξ is clear from the
context, we shall use simply the term “mosaic”.
The basic idea underlying this deﬁnition is that Aϕ holds of a point if we
“want” ϕ to be true at it, while Bϕ holds of a pair of points if we “want” ϕ
to be true at every point between them. Obviously, not every such structure
is part of a model — we need some further constraints for that. We call a
mosaic coherent if it satisﬁes the following conditions (phrased in ﬁrst-order
logic and to be read universally):

400
7 Modal Logic and Decidability
(C0) Rxy ∨Ryx ∨x = y,
(C1) A¬ϕx ↔¬Aϕx,
(C2) Aϕ∧ψx ↔Aϕx ∧Aψx,
(C3) Bϕ∧ψxy ↔Bϕxy ∧Bψxy,
(C4) (Rxy ∧Ryz ∧Bϕxz) →Aϕy,
(C5) (Rxy ∧Aϕy ∧Bψxy) →AU(ϕ,ψ)x.
A few words of explanation: C0 reﬂects the fact that we have taken only
packed subsets of the model as the domain of our mosaic mini-models. C1–C3
are selfexplanatory; note that there is no analog of C1 for the B-predicates,
since there is a hidden universal quantiﬁer in the meaning of a predicate
Bϕ, see (7.10). Finally, C4 and C5 are rather obvious consequences of our
intuitive meaning of the A- and B-predicates and the truth deﬁnition of the
until operator.
The conditions C0–C5 take care of all universal constraints on the A- and
B-predicates; but of course there are existential demands as well, which we
shall call requirements. A requirement of a mosaic μ = (X, R, Aϕ, Bϕ)ϕ∈Cl(ξ)
is one of the two following types of object:
(a) (AU(ϕ,ψ), s) such that AU(ϕ,ψ)s,
(b) (not Bϕ, s, t) such that Rst and not Bϕst.
In order to explain the requirements of type (a), suppose that we want the
formula U(ϕ, ψ) to be true at a point s; if there is a point t in the mosaic
such that Rst, Aϕt, and Bψst, then the mosaic itself directly fulﬁlls the
requirement. This will rarely be the case, however; the whole point of the
mosaic method is that requirements can be fulﬁlled by distinct mosaics as
well, as follows. A link between two mosaics μ and μ′ is simply a partial
isomorphism between the two structures. We say that a link f : μ %→μ′ fulﬁlls
the requirement (AU(ϕ,ψ), s) of μ if there is some t in μ′ with Rf(s)t, Aϕt,
and Bψf(s)t. Likewise, a link f : μ %→μ′ fulﬁlls the requirement (notBϕ, s, t)
if there is some u in μ′ with Rf(s)u, Ruf(t), and ¬Aϕu.
A collection L of mosaics is called a linked set of mosaics if every require-
ment of every mosaic μ ∈L is fulﬁlled via some link f : μ %→μ′ to some μ′ also
in L. It is a linked set of mosaics for ξ if it contains a mosaic with nonempty Aξ.
The main theorem concerning mosaics is the following. (In order to follow
the main line of the chapter, the reader could skip the details of the proof.)
Proposition 7.4.7. An LU-formula ξ is satisﬁable if and only if there is a
linked set of mosaics for ξ.
Proof. The left-to-right direction of the proof is easy. Suppose that M =
(W, R, V ) is a model for ξ. Out of this model, we cut a linked set of mosaics
for ξ, as follows. Let X be the collection of triples ⃗x = ⟨x1, x2, x3⟩such that
Rx1x2, Rx2x3, and Rx1x3. Associate with any such triple a mosaic μ⃗x based
on the set {x1, x2, x3}, with R as in M and with every Aϕ and Bϕ deﬁned as
given by the truth of ϕ in M. We leave it as an exercise for the reader to verify
that the collection of all these mosaics indeed forms a linked set of mosaics.

7.4 Some Variations
401
The right-to-left direction of the proposition is the hard one, although the
key idea underlying its proof is quite intuitive. We construct a model for ξ
step by step; that is, we approximate our model via a series of ﬁnite structures
that we call networks. A network is a structure N = (W, R, Aϕ, Bϕ)ϕ∈Cl(ξ)
of the same type as a mosaic but not bounded in size. A network is called
coherent if it satisﬁes the conditions C1–C5 above. To ask for C0 would be
too much; instead, we require coherent networks to satisfy the following:
(liveness) every packed set X of size at most three comes from a mosaic; that
is, for each such set X ⊆W there is a partial isomorphism f : N %→μ
such that f is deﬁned on X.
Liveness means that, through the mosaics, we are in control of certain small
parts of the model: the packed sets of size at most three. Why only these
sets? The truth deﬁnition of U provides the answer. The meaning of U(ϕ, ψ)
depends only on these small packed sets in the model.
A defect of a network is a requirement that is not directly fulﬁlled in
the network itself, and a network is called saturated if it has no defects. A
network is perfect if it both coherent and saturated.
This
name
is
well
chosen,
since
perfect
networks
are
the
ones
that we are after. The reason for this is that with every network
N = (W, R, Aϕ, Bϕ)ϕ∈Cl(ξ) we can associate a modal model in an obvious
way: it is deﬁned as the structure N ◦= (W, R, V ◦), where V ◦(p) = Ap for
all variables p occurring in ξ. But only for perfect networks can we prove the
following truth lemma.
Claim 1. If N is a perfect network, then for all formulas ϕ ∈Cl(ξ) and all
points s, t in N:
1. s ∈Aϕ iﬀM, s ⊩ϕ.
2. If Rst, then (s, t) ∈Bϕ iﬀM, st ⊩ϕ.
Proof of Claim The proof of this claim is by induction on the complexity
of ϕ. We consider only the case where ϕ is of the form U(ψ, χ), and only
prove part 2 of the claim (the ﬁrst part is simpler).
By the induction hypothesis and the truth deﬁnition of U, in order to
prove part 2 it suﬃces to show that for all pairs of points s and t such that
Rst, we have that (s, t) ̸∈Bϕ iﬀu ̸∈Aϕ for some u with Rsu and Rut. The
left-to-right direction immediately follows from the fact that N is perfect and
thus all requirements of type (b) are fulﬁlled. For the other direction, suppose
that s, t and u are points satisfying Rst, Rsu, Rtu and u ̸∈Aϕ. Observe that
{s, t, u} is a packed set of size at most three, so that we may use the liveness
condition. This yields a partial isomorphism f from N to some mosaic μ
such that f is deﬁned for each of s, t, and u. It follows that Rf(s)f(t),
Rf(s)f(u), Rf(t)f(u), and f(u) ̸∈Aϕ; but then it follows from condition C4
that (f(s), f(t)) ̸∈Bϕ. Returning to N, this shows that (s, t) ̸∈Bϕ, which is
what we needed to prove. This ﬁnishes the proof of the claim.

402
7 Modal Logic and Decidability
It follows from the above claim that in order to show that ξ is satisﬁable,
it suﬃces to show that there is a perfect network for it, that is, a perfect
network such that Aξ is not empty.
Claim 2. There is a perfect network for ξ.
Proof of Claim The proof of this claim falls out into three parts. First we
show that there is some network for ξ (not necessarily perfect). This is easy,
since we are given a linked set of mosaics for ξ: as our network we simply
take any mosaic with a nonempty Aξ.
The second and main part of the proof consists in showing that any defect
of any network can be repaired; that is, we can ﬁnd a bigger network in which
the defect no longer occurs. Without going into too much technical detail,
let us see how to repair a defect of type (b) (defects of type (a) are repaired
in a similar way).
Suppose that s and t are points of the network N such that Rst and not
Bϕst for some subformula ϕ of ξ, while there is no point u between s and
t such that ¬Aϕu. The idea now is simply to repair this defect by adding a
new point to the network. What kind of point? Well, since we have Rst we
know that s and t come from a mosaic; that is, there is a partial isomorphism
f from N to some mosaic μ. Obviously, (notBϕ, f(s), f(t)) is a requirement
of this mosaic. But since we are working with a linked set of mosaics, there
must be some link g between μ and μ′ and some u in μ′ such that Rg(f(s))u,
Rug(f(t)), and ¬Aϕu. Now we simply add an entirely new point r to the
network, and make sure that the relations between s, t, and r are such that
this part of the model is isomorphic to μ′. It is thus obvious that we have
repaired the defect, and that the new structure is a network. In order to keep
the liveness condition, it is essential not to relate r to any other point besides
s and t: in this way, the only new packed sets are {r, s, t} and its subsets.
Finally, these two parts provide the material and the tools for constructing
the desired perfect network for ξ. Starting from the mosaic for ξ (which
is of course a network), we repair defects, one by one, step by step, thus
constructing a sequence N0, N1, . . . of networks. Using some standard
combinatorics, we can ensure that the limit of the chain of networks is a
network without defects. In particular, if we always take new points from a
ﬁxed set, say ω, we can enumerate the set of all (potential) defects of any
network in the chain; if at each step of the construction we repair the current
network’s defect with the lowest number in this enumeration, we can create
a perfect network. This ﬁnishes the proof of the claim.
2
Theorem 7.4.8. It is decidable whether a given LU-formula is satisﬁable.
Proof. We can adjust the “elimination algorithm” given for the system K∗
in order to deal with mosaics. This is done as follows. Let S be the set of
all ξ-type mosaics (up to isomorphism). Let S0 ⊆S be the subset containing

7.4 Some Variations
403
all coherent mosaics. S0 can be computed eﬀectively, since coherence can be
checked eﬀectively. It is not hard to show that |S| ≤2O(|ξ|). We now induc-
tively construct a sequence of sets of mosaics S0 ⊋S1 ⊋S2 ⊋S3 · · · , just as
in the proof for the system K∗. The idea is that we delete mosaics from Si
if they have a requirement which cannot be fulﬁlled inside Si. The details of
this construction will be spelled out in the section on guarded fragments.
2
What is important to remember is that the until system has a kind of loose
model property: if a formula ξ is satisﬁable then there is a linked set of mosaics
for it, and if there is such a set for ξ, then the proof of Proposition 7.4.7 shows
how to construct a loose model for ξ. We shall come back to this in Section 7.6
Notes
Tiling problems (or domino problems, as they are sometimes called) were
introduced by Wang [61] and have since been used in a variety of forms
to prove undecidability and complexity results. An accessible proof of the
undecidability of the N × N tiling problem, a result due to Berger [8], can be
found in the monograph by B¨orger, Gr¨adel & Gurevich [10]. Our discussion
of the logic Tile was based on Spaan [55], where an example is presented in a
language that expands the basic modal language with the universal diamond.
The modal system S52 (S5 square) has a long history in the algebraic
disguise of the class of diagonal-free cylindric algebras of dimension two,
see the monograph [27]. The bounded ﬁnite model property of S52 was
ﬁrst established by Segerberg [53]. The fact that every pseudo-square
bisimulates by a functional bisimulation with a square can be found in Marx
& Venema [43]. The higher-dimensional counterparts of S52 are studied as
modal logics in Venema [59, 60].
The modal system K∗can best be seen as a fragment of propositional
dynamic logic (PDL) in which there is only one atomic program. For more
information on PDL, the reader is referred to the handbook article by
Harel [24]. The decidability of PDL was proved by Fischer & Ladner [18].
The elimination algorithm leading to Theorem 7.4.5 is due to Pratt [50].
The operators “Since” and “Until” were introduced by Hans Kamp
in order to prove expressive (in)completeness results for temporal logics
over classes of linear ﬂows of time. Nowadays, they belong to the standard
repertoire of temporal logics in computer science; see [39]. A bisimulation
variant which characterizes this language over arbitrary models was found by
Kurtonina & de Rijke [36]; for some decidability results over classes of linear
ﬂows of time, see Burgess & Gurevich [12]. Our Theorem 7.4.8 and its proof
are based on results and proofs related to the loosely guarded fragment that
are due to van Benthem.
The ﬁltration method has been used extensively as a tool for proving
decidability results for modal logics, since Lemmon [38] and Segerberg [52]
further developed ideas dating back to McKinsey & Tarski [44]. The mosaic

404
7 Modal Logic and Decidability
method for proving decidability of a logic was developed by N´emeti [45]; it has
since been used for a wide range of logics, often related to a multi-dimensional
modal setting. With hindsight, even G¨odel’s proof of the decidability of the
satisﬁability problem for ∀2∃∗prenex sentences can be called a mosaic-style
proof as well; see the very clear exposition in [10].
7.5 Modal Complexity
In the previous sections, we have discussed the decidability of the satisﬁ-
ability problem for several modal systems, gathering various results along
the way. For instance, for the basic modal system K, we saw that every
satisﬁable formula can be satisﬁed in an exponential-size tree model with
branches of polynomial depth; for S52, we could do no better than ﬁnding
an exponential-size quasi-model.
In this section, we take a closer look at such diﬀerences, examining how
they aﬀect the complexity of the modal systems that we present. Our goal
is not to give precise reductions and matching algorithms — this is very
well documented in the literature. Rather, we shall paint with a broad
brush and try to convey once more our earlier message that looseness and
locality are key notions in understanding the decidability and complexity
of modal systems. To do this we discuss modal systems whose satisﬁability
problems are complete for the complexity classes NP, PSPACE, EXPTIME,
and NEXPTIME, respectively. We believe that these systems, besides being
complete for these classes, indeed form very indicative examples.
Our agenda for the section is set out in Table 7.1. We assume that the
reader has at least a basic understanding of complexity classes such as NP,
PSPACE, EXPTIME, etc. Completeness and hardness are understood in this
chapter by means of polynomial-time many-one reductions. (The reader is
referred to [3] for basic deﬁnitions.) In this section, we concentrate on the sat-
isﬁability problem — recall that C-completeness of the satisﬁability problem
for a modal system implies co-C-completeness of the validity problem.
The layout of this section is summarized in Table 7.1. Every column represents
a modal system and the complexity class for which its satisﬁability problem is
complete. The third row indicates whether satisﬁable formulas can be satisﬁed
in tree models for that logic, and the fourth row whether the modal system
Table 7.1. Layout of Section 7.3
modal system/logic
S5
Func
K
K∗
S52
complete for
NP
NP
PSPACE
EXPTIME
NEXPTIME
tree model property
*
yes
yes
yes
no
global expressive power
yes
no
no
yes
yes
subsection
7.5.1
7.5.1
7.5.2
7.5.3
7.5.4

7.5 Modal Complexity
405
is expressive enough to deﬁne the universal modality. We mention these two
properties because they correspond to the looseness and ﬁrst locality principle,
respectively (as mentioned before, we shall meet the second locality principle
again in the last section). The star in the ﬁrst column marks the special role
of the logic S5, which is the logic of the universal modality E by itself.
We shall often use the tractability result concerning model checking that
we mentioned earlier on when discussing the second locality principle. In this
section, we conﬁne ourselves to modal languages with a ﬁnite number of ﬁrst-
order deﬁnable modal operators. For modal formulas in such a language, the
model checking problem (i.e., given as input a (ﬁnite) model M, a state s and
a formula ξ, to determine whether M, s ⊩ξ), is solvable in PTIMEin the size
of both the model and the formula. Also, for an elementary (i.e., deﬁnable by a
single ﬁrst-order sentence) class of models K, the membership problem (given
as input a ﬁnite model M, to determine whether M belongs to K), is also solv-
able in PTIME. We shall call a modal system elementary if it has an elemen-
tary class of models and each of its operators has a ﬁrst-order truth deﬁnition.
7.5.1 NP and the Polysize Model Property
The class NP of nondeterministic polynomial-time algorithms is the smallest
complexity class that we shall consider for the satisﬁability problem for modal
systems. The reason for this is that every nontrivial modal logic contains
the collection of all valid propositional formulas; hence we can reduce the
NP-complete satisﬁability problem for propositional logic to that of the
modal system. So NP is a nice class to work with since we only have to show
an upper bound. Unfortunately, there are not many modal systems with a
satisﬁability problem in NP.
How can we show that the satisﬁability problem is in NP for a given modal
system? The easiest route and the one that modal logicians most often take is
via the polysize model property. A modal system is said to have this property
if every satisﬁable formula ξ is satisﬁable in a model whose size is bounded by
p(|ξ|) for a ﬁxed polynomial p. Using the two complexity results mentioned
above, namely, PTIME for both the model checking and the membership
problem, it is easy to show that for elementary modal systems, the polysize
model property implies NP-completeness of the satisﬁability problem.
Let us see then, if we can ﬁnd modal systems with this polysize model
property; we shall conﬁne ourselves to the basic modal language. In Sect. 7.3,
we showed that every satisﬁable formula ϕ can be satisﬁed in an at most
|ϕ|-ary tree of depth at most |ϕ|: a model whose size is exponential in |ϕ|.
Thus, if we want a polysize model, we should restrict either the width or the
depth of such trees. This is possible if we consider smaller classes of models.
Restricting the width is easy: we consider only models in which R is
a total function. The cut-oﬀargument in Section 7.3 yields a linear-sized
model. Recall from Deﬁnition 7.3.8 that d3(ξ) denotes the modal depth of ξ.

406
7 Modal Logic and Decidability
Proposition 7.5.1. Let Func be the modal system (L3, ⊩, F) such that ⊩
is the standard deﬁnition and F is the class of models in which R is a
total function. Let ξ be a formula in L3. If ξ is Func-satisﬁable, then it is
Func-satisﬁable in a model containing at most d3(ξ) + 1 states.
As a corollary, the satisﬁability problem for Func is in NP.
An extremely simple way of bounding the depth is to make the accessibil-
ity relation total; a state at which ϕ holds is then a witness for 3ϕ at every
state in the model.
Note, however, that making the accessibility relation total breaks with the
ﬁrst locality principle! Nevertheless, the resulting modal system, which we
shall call S5 after the name of the logic associated with it, has a satisﬁability
problem in NP.
Proposition 7.5.2. Let S5 be the modal system (L3, ⊩, U) such that ⊩is the
standard deﬁnition and U is the class of models in which R is the universal
relation. Let ξ be a formula in the basic modal language. If ξ is S5-satisﬁable
then it is S5-satisﬁable in a model containing at most |ξ| states.
As a corollary, the satisﬁability problem for S5 is in NP.
Proof. Let M = (M, R, V ) be a model such that R = M × M and M, s ⊩ξ.
Choose, for every subformula 3ϕ of ξ, a state t ∈M such that ϕ holds at t
(if such a state exists). Let M′ be the submodel of M consisting of s plus the
selected states. By our pruning argument of Section 7.3, M′, s ⊩ξ, because
R is the universal relation.
2
This ﬁnishes our discussion of NP and the polysize model property. Modal
systems with this property are few and far between. In the next subsection,
we shall see that for the basic modal system we can get only an exponential
upper bound on the size of a model.
7.5.2 PSPACE and Polynomially Deep Paths
In Section 7.3 we showed that every satisﬁable formula ξ in the basic modal
language is satisﬁable in a ﬁnite tree model M, with depth and branching
degree both bounded by the length |ξ| of the formula. The good news about
this argument is that it can be used to show that satisﬁability for K can be
decided in PSPACE. On the other hand, the upper bound that it establishes on
the size of M is no better than exponential — at this stage, the reader might
wonder whether this is an optimal bound. Here we show that it is — up to a
polynomial. In fact, the satisﬁability problem of K is complete for PSPACE.
We now deﬁne, for each natural number n, a satisﬁable formula ξ(n) with
the following two properties:
•
the size of ξ(n) is quadratic in n; and
•
when ξ(n) is satisﬁed in any model M at state s, then M contains as a sub-
structure an isomorphic copy of the binary tree of depth n whose root is s.

7.5 Modal Complexity
407
Thus the size of the smallest model satisfying ξ(n) is exponential in |ξ(n)|. The
idea underlying the deﬁnition of ξ(n) is very simple: take n propositional vari-
ables p0, . . . , pn−1, and write a formula which, when satisﬁed, forces a binary-
branching tree in which every possible valuation on {p0, . . . , pn−1} occurs at
some leaf. Thus the model certainly contains 2n diﬀerent states. The formula
is constructed using two “macros”: branch(pi) and store(pi) deﬁned as follows:
branch(pi) := 3(pi ∧2pi) ∧3(¬pi ∧2¬pi)
store(pi)
:= (pi →2pi) ∧(¬pi →2¬pi).
The formula ξ(n) is then given by
branch(p0) ∧
	
1≤i<n
2i(branch(pi) ∧
	
0≤j<i
store(pj)),
(7.12)
in which 2i abbreviates a sequence of boxes, of length i. The formula works
as follows. Suppose M, s ⊩ξ(n). Then the branch part of ξ(n) states that
every node t reachable in i R-steps from s has two diﬀerent successors, one
forcing pi ∧2pi and the other forcing ¬pi ∧2¬pi. The store part of the
formula states that successors of t created by the branch part satisfy precisely
the same proposition letters p0, . . . , pi−1 as does t. We leave it to the reader
to verify that the interplay of the branch and store macros forces a binary
tree of depth n, as desired.
PSPACE lower bound. Of course, failure of the polysize model property
for the basic modal system does not in itself imply that its satisﬁability
problem cannot be decided in NP. However, in fact the lower bound of
this problem is known to be PSPACE. This result can be obtained by an
interpretation of the validity problem of quantiﬁed boolean formulas. This
interpretation is based on the same two macros branch and store.
In a similar way, one can establish the existence of exponential-sized
models and a PSPACE lower bound for the modal system with ⟨∗⟩as its only
modal operator (i.e., the fragment of K∗of formulas in which the ordinary
diamond 3 does not occur). To overcome the diﬃculty that ⟨∗⟩has direct
one-step access to all states in a tree one has to add additional propositional
variables to encode the depth of the tree. See the notes for details.
PSPACE upper bound. The K-World algorithm for the basic modal
system K (see Figure 7.6) runs in PSPACE. Recall that for any formula
ξ, ξ is K satisﬁable iﬀthere exists a set Δ ⊆Cl(ξ) such that ξ ∈Δ and
K-World(Δ, Cl(ξ)) is true. All sets encountered in the execution of K-World
are subsets of Cl(ξ). Each subset of Cl(ξ) can be represented in space O(|ξ|),
by using pointers to a copy of the formula. Therefore, at each level of the
recursion, O(|ξ|) space is used. After d3(ξ) recursive calls (d3(ξ) being the
modal depth of ξ), there are no more 3ψ formulas in Σ and the recursion
stops. Thus the recursion depth is bounded by d3(ξ) ≤|ξ|, and hence the
total amount of space required by the algorithm is O(|ξ|2). The existential
demands in the algorithm (there exists a set Δ with ξ ∈Δ such that . . . ,

408
7 Modal Logic and Decidability
and for all 3ψ ∈Δ, there exists . . . ) make the algorithm nondeterministic.
But PSPACE = NPSPACE by Savitch’s Theorem.
A crucial point in the PSPACE upper-bound argument is that we can
represent a complete branch of the tree model for ξ using only polynomial
space. Two factors are important here. First, only a polynomial number of
formulas is relevant for each world. And second, the depth of the branches is
bounded by the modal depth of the input formula. This is caused by the ﬁrst
locality principle: a lack of global expressive power. In the next subsection we
show that adding such expressive power to the basic modal language destroys
this polynomial-depth property.
7.5.3 EXPTIME and Exponentially Deep Paths
Now we shall see that global expressive power in combination with another
diamond destroys the polynomially bounded deptLh of the satisfying tree
models for the basic modal system. In particular, we shall create a satisﬁable
formula which, when satisﬁed, forces a branch in the model containing an
exponential number of colors. Thus the PSPACE algorithm sketched in the
previous subsection will not work anymore. In fact, the additional expressive
power will be enough to show that the satisﬁability problem is EXPTIME-
hard. We again consider the system K∗of Subsect. 7.4.2. We want to show
that its language is strong enough to force the existence of exponentially
deep R-paths. A simple way of doing so employs binary counters.
By a binary counter we mean a device that can have a natural number
as its value, represented as a binary string of 0s and 1s; it should also be
possible to increment this value by one. We use a set {p0, . . . , pn−1} of
propositional variables to implement an n-ary binary counter (“n-ary” means
that the counter is reset to zero after reaching the value 2n −1). We use
these variables to encode the n bits of the counter, with p0 encoding the
least signiﬁcant and pn−1 the most signiﬁcant bit. The variable pi being
true in a given state, encodes the fact that the ith bit of the counter is 1 in
that state. The key idea of an encoding into the modal language lies in the
following characterization of adding 1 to a binary counter. If a = an−1 . . . a0
and b = bn−1 . . . b0 are two n-bit counters, then b = a + 1(mod 2n) precisely
when the following holds: either bi = 0 and ai = 1 for all i (this is when we
start counting at 0 again), or, for some k ≤n −1, we have
(1) ak = 0, and bk = 1,
(2) aj = 1 and bj = 0 for all j < k, and
(3) ai = bi for all i > k.
In a picture:
10110 0 1111 a
00000 0 0001
10110 1 0000 b = a + 1.
k

7.5 Modal Complexity
409
We want to write a formula γ(n) which forces a counter to take all values
from 0 to 2n −1, in consecutive states, thereby forcing an exponentially deep
path. We shall take care that the formula has a length of only O(n2). The
formula γ(n) is a conjunction of four formulas. The ﬁrst conjunct expresses
the fact that the counter is initially set to 0:
¬p0 ∧. . . ∧¬pn−1.
The other conjuncts of γ(n) must hold globally in a model. To achieve that
aim, we use the dual [ ∗] of ⟨∗⟩([ ∗]ϕ abbreviates ¬⟨∗⟩¬ϕ). It is clear that
the root s of a tree model has M, s ⊩[ ∗]ϕ if and only if, for all t, M, t ⊩ϕ.
The second conjunct expresses that every state has a successor:
[ ∗]3⊤.
The next two conjuncts take care of addition. They express that whenever
an R-transition is made in the model, the binary counter is increased by one.
First, we deal with the simple case of resetting the counter:
[ ∗]((p0 ∧. . . ∧pn−1) →2(¬p0 ∧. . . ∧¬pn−1)).
Finally, the last conjunct of γ(n) covers the case when we have to “carry
one”. This conjunct is itself a conjunction, having a conjunct of the following
form for every k such that 0 ≤k < n:
[ ∗]((¬pk ∧
	
j<k
pj) →2(pk ∧
	
j<k
¬pj) ∧
	
i>k
store(pi)),
where store(pi) is deﬁned in the previous subsection and the empty
conjunction is set to true.
We leave it to the reader to check the correctness of this formula. Note
that the sole use of [ ∗] was to make statements in the basic modal language
true everywhere in the model. This use is crucial, however: Proposition 7.3.10
states that a formula in the basic modal language can only force models with
R-paths of at most its modal depth. Now the modal depth of γ(n) is just
two (one for [ ∗], and one for 3), for every n, while the minimal R-depth of
models satisfying γ(n) is 2n.
Complexity bounds. In the previous subsection, we saw that the polynomi-
ally bounded depth of models was the key to a PSPACE upper bound. The
present result does not yet show that such an upper bound is not possible,
but it renders it unlikely (see the notes). And, indeed, the satisﬁability
problem for K∗is EXPTIME-complete. For the lower bound we refer to the
notes. The upper bound follows from the K∗decision algorithm presented
in the previous section. Recall that the algorithm tried to construct a set of
ready subsets of Cl(ξ). We remarked that the construction would terminate
after 2O(|ξ|) stages. Computing which sets in Si are ready can be done in

410
7 Modal Logic and Decidability
time polynomial in the size of Si, which is at most exponential in |ξ|. Thus
the whole construction can be carried out in deterministic exponential time.
We note that all results carry over to the modal system K+E (the basic
modal system expanded with the universal modality E). In particular, the
formula γ(n) with ¬⟨∗⟩¬ substituted by ¬E¬ causes an exponentially deep
path. This result will be used in the next section.
7.5.4 NEXPTIME
We now consider a modal system in which matters get even worse: the system
S52. For the deﬁnitions of S52 and its square and pseudo-square models, see
Section 7.4.1.
This system does not have the tree model property. In addition, the
language has global expressive power: for every ϕ, if a model M satisﬁes
2120ϕ, then M ⊩ϕ. So we expect that the satisﬁability problem will have
a high complexity. This is indeed the case. This system is strong enough to
interpret the system K + E of the previous subsection, inheriting its EXP-
TIME lower bound. But S52 lacks the tree-like models of K + E on which the
EXPTIME upper bound is based. We shall sketch an argument that S52 is
strong enough to force exponential grids, which is the key to a NEXPTIME
lower-bound result. A matching upper bound follows from earlier results:
every satisﬁable formula ξ is satisﬁable in a pseudo-square of size at most
2|ξ|, by Proposition 7.4.3. Being a pseudo-square is a ﬁrst-order property. As
we saw in the subsection on NP, testing whether a modal formula is satisﬁed
in a model takes time polynomial in the formula and the size of the model.
Thus for the same reasons as why the polysize model property leads to an
NP upper bound, we obtain here a NEXPTIME upper bound.
We start with the interpretation of the K + E satisﬁability problem. For
this purpose, we use a translation reminiscent of the two-variable version of
the standard translation (read r as Rxy, 31 as ∃y, and 30 as ∃x, and read
w as the assertion expressing that x = y). Let (·)t be a translation function
which maps propositional variables to propositional variables, commutes with
the booleans, and translates the diamonds as follows:
(3ϕ)t = 31(r ∧30(w ∧ϕt))
(Eϕ)t = 3130(w ∧ϕt),
where r and w are ﬁxed variables not occurring in the input language. Their
function becomes clear in the proof of the next proposition.
Proposition 7.5.3. Let ξ be a formula in the basic modal language expanded
with the universal modality. Then ξ is K + E-satisﬁable if and only if w ∧ξt
is S52-satisﬁable.
Proof. (⇒) Let M = (W, R, V ) be a Kripke model and let M, s ⊩ξ. We deﬁne
a square S52-model M∗= (W × W, ≡0, ≡1, V ∗), with V ∗deﬁned as follows:

7.5 Modal Complexity
411
V ∗(w) = {(x, x) | x ∈W}
V ∗(r) = R
V ∗(p) = {(x, x) | x ∈V (p)}.
An easy induction shows that M∗, (s, s) ⊩w ∧ξt.
(⇐) Let M = (W, ≡0, ≡1, V ) be a square S52 model and M, (s, t) ⊩w∧ξt.
Deﬁne a Kripke model M◦whose domain consists of all pairs in W where
w holds; of which the valuation V ◦is simply the restriction of V to these
w-pairs; and in which the accessibility relation R◦holds between (x, y) and
(x′, y′) iﬀM, (x, y′) ⊩r. A simple induction shows that for all w-pairs (x, y)
and for all formulas ϕ, we have that M, (x, y) ⊩ϕt ↔M◦, (x, y) ⊩ϕ.
2
This result immediately shows that the S52 satisﬁability problem is
EXPTIME-hard. In fact, it is even hard for NEXPTIME. This lower bound
can be shown by a reduction to a tiling problem very similar to the one
used to show undecidability in Section 7.4. In this case we tile not the grid
N × N but the ﬁnite grid 2n × 2n. It is known that this problem is complete
for nondeterministic time exponential in n. Here we provide the key idea
underlying the reduction, which is that for every n, we can deﬁne a satisﬁable
formula ξ(n) with the properties that
•
the length of ξ(n) is quadratic in n, and
•
if ξ(n) is satisﬁed in an S52 model M, then M contains as a substructure
an isomorphic copy of the structure (2n × 2n, Sv, Sh), where Sv, Sh are
the vertical and horizontal successor functions in the grid 2n × 2n.
Once we have expressed this, it is straightforward to ﬁnd a formula saying
that a tiling exists, just as in Section 7.4. Because of space limitations we can
give only a very rough sketch. The ﬁrst conjunct of ξ(n) is the translation of
the formula γ(2n) of the previous subsection. We assume that γ(2n) is created
from variables x0, . . . , xn−1 and y0, . . . , yn−1. So there are two binary counters,
that together specify in binary notation a pair ⟨k, l⟩in the grid 2n × 2n.
Let M be a Kripke model such that M, s ⊩γ(2n). Let M∗be the square
S52 model as deﬁned in the proof of Proposition 7.5.3. In M∗we have,
besides the tree structure of the Kripke model, also all “grid points”: that is,
for all worlds w, w′ ∈W, the pair (w, w′) exists in the model M∗. We can use
these pairs to relate the counter information in w and w′. More concretely, we
write formulas ensuring that at (w, w′), a propositional variable Sv holds if
and only if w encodes the grid pair ⟨k, l⟩and w′ encodes its vertical successor
⟨k, l + 1⟩. We again use the characterization of adding one in binary in order
to create a formula of the required small size. For the full proof, we refer to
the notes.
We have seen in Proposition7.5.3 how the EXPTIME modal logic K + E
“lives” inside the NEXPTIME logic S52. Also, we saw that the “extra”
points available in the grid models lead to higher complexity. In the next
section, we shall do the same but with more variables. We look at ﬁrst-order

412
7 Modal Logic and Decidability
logic and ﬁnd decidable fragments living inside it. In analogy with the last
result, we can say that the key feature of these fragments is that they cannot
speak about the “extra grid points”.
7.5.5 Notes
Most complexity-theoretic classiﬁcations of modal satisﬁability and validity
problems come from the computer science literature. This work can be
roughly divided into three groups: temporal logics describing computations,
logics for reasoning about knowledge, and description logics. Pointers to this
vast literature can be found in the handbook articles by Stirling [56] and
Calvanese et alii [13] for temporal logics and description logics, respectively,
and in the monograph by Fagin et alii [17] for epistemic logics. Here we
provide only the sources for the results in this section.
The NP-completeness of S5 was proved by Ladner [37]. The results on
PSPACE come also from [37]: both the upper and the lower bound for
the basic modal system K are established there. Ladner’s procedure for K
is like the one given in Figure 7.6, save that he uses “concrete tableaux”
(that is, his algorithm speciﬁes how to construct the required atoms) rather
than “abstract tableaux” (which factor out the required boolean reasoning).
Concrete tableaux were also used by Halpern and Moses [23] to construct
PSPACE algorithms for multimodal versions of K, S4, and indeed S5; as
these authors show, logics containing two S5 modalities are PSPACE-hard.
The EXPTIME-hardness of K∗and K + E is due to Fischer & Lad-
ner [18] (who work in the richer setting of propositional dynamic logic). An
EXPTIME procedure for PDL using an “elimination algorithm” was given
by Pratt [50]. We used this idea in the proof of Theorem 7.4.5, and shall do
so again in the next section on the guarded fragment. For other applications
of the method, see for instance [23], where Halpern & Moses apply it to a
multimodal logic equipped with a common knowledge operator.
The modal system Func+E is an example of a modal system in which
exponentially deep paths can be forced but which is still decidable in
PSPACE, a result due to Sistla & Clarke [54]. We stress that adding the
universal modality causes the complexity to go up from NP. Note that in
this system there are no models which can be considered to be binary trees.
Indeed, Spaan [55] has provided a suﬃcient condition for EXPTIME-hardness
of the satisﬁability problem of modal systems. This criterion requires the
existence of models which can be considered as ﬁnite binary trees, and an
expansion of the basic modal language which is powerful enough to make
statements which hold everywhere in such a tree model.
The fact that the square tiling problem with a width given in binary is
hard for nondeterministic exponential time was established by F¨urer [19].
The lower bound for S52 was established by Marx [40].

7.6 Modal Logic and First-Order Logic
413
7.6 Modal Logic and First-Order Logic
The previous sections were centered around the question of what determines
the decidability and complexity of the satisﬁability problem for various
modal systems. We identiﬁed the looseness property of modal logics as the
main principle guiding their nice computational properties; we also met two
locality principles that inﬂuence the complexity of a modal system. It now
seems natural to try and see how far we can push these ideas concerning
looseness and locality to larger fragments of ﬁrst-order logic than the modal
fragment formed by the range of the standard translation map. The aim of
this section is to identify a number of decidable fragments of ﬁrst-order logic;
that is, sets of ﬁrst-order formulas for which it is decidable whether a given
formula in the subset is satisﬁable in some ﬁrst-order model or not.
Convention. We work in a relational ﬁrst-order language with equality.
Thus the language contains neither constants nor function symbols. For a
sequence of variables x = x1, . . . , xn, we shall frequently write ∃xϕ, which, as
usual, has the same meaning as ∃x1 · · · ∃xnϕ. However, we view ∃x not as an
abbreviation but as a primitive operator. In particular, this means that the
subformulas of ∃xϕ are just ∃xϕ itself, together with the subformulas of ϕ.
By writing ϕ(x) we indicate that the free variables of ϕ are among x1, . . . , xn.
7.6.1 Guarded Fragments
In order to ﬁnd larger “loose” fragments of ﬁrst-order logic, we reconsider
the game-theoretic characterization of the modal fragment of ﬁrst-order
logic. Recall that bisimulations can be deﬁned using a certain two-pebble
Ehrenfeucht-Fra¨ıss´e game in which the universal player’s moves are restricted
in a certain way. We shall analyze these restrictions and implement them in
the standard Ehrenfeucht-Fra¨ıss´e games for ﬁrst-order logic; then we shall
be ready to push all modal decidability arguments through for these guarded
fragments.
Consider once again the bisimulation game from Section 7.3, and the two
crucial properties:
Locality The game is played by moving a window of ﬁxed size (two, in this
case) across the models.
Looseness The window can only be placed on parts of the model in which all
diﬀerent points are related by the accessibility relation.
How do we generalize this to ﬁrst-order logic? We implement the locality
principle by considering fragments of ﬁrst-order logic using a ﬁxed ﬁnite
number of variables. The looseness principle can be generalized in (at least)
two diﬀerent ways, leading to diﬀerent fragments of ﬁrst-order logic. To state
these generalizations, we need two notions, both of which are well known in
ﬁnite model theory.

414
7 Modal Logic and Decidability
Deﬁnition 7.6.1. Let M = (D, I) be a model for some ﬁrst-order language.
A tuple (a1, . . . , an) of objects in D is called live in M if either a1 = · · · = an
or (a1, . . . , an) ∈I(P) for some predicate symbol P.
A subset A of D is called guarded if there is some live tuple (a1, . . . , an)
such that A ⊆{a1, . . . , an}. In particular, singleton sets are always guarded;
note also that guarded sets are always ﬁnite. A is packed or pairwise guarded
if it is ﬁnite and each of its two-element subsets is guarded.
These notions can help us to incorporate the looseness principle into
Ehrenfeucht-Fra¨ıss´e games as follows: player ∀can only move pebbles in such
a way that all conﬁgurations of pebbles that ever occur on the board are
placed on guarded or packed sets.
Deﬁnition 7.6.2. Let M = (D, I) and M′ = (D′, I′) be two models. A
partial isomorphism between M and M′ is a bijection f : A →A′ between
some subsets A of D and A′ of D′ such that, for all predicate symbols P and
all tuples a in A (of the appropriate length), we have that a ∈I(P) if and
only if f(a) ∈I′(P).
Now, for a partial isomorphism f : A0 →A′
0 between M′ and M′,
we deﬁne the guarded game Gg(M, M′, f) as a variant of the familiar
Ehrenfeucht-Fra¨ıss´e game. Here, in each round of the game, ∀selects a struc-
ture and a guarded set within that structure; ∃responds with a guarded set
in the other structure. A match of the game thus gives rise to two sequences
A = A0, A1, . . . and A′ = A′
0, A′
0, . . . of subsets of D and D′, respectively. ∃
wins this match if there are local isomorphisms fn : An →A′
n (n ∈ω) such
that f0 = f and, for each n, fn and fn+1 agree on the intersection An ∩An+1
while their inverses agree on A′
n ∩A′
n+1.
Now let a in M and a′ in M′ be (possibly empty) sequences of elements
such that f(ai) = a′
i for all i. When ∃has a winning strategy in the guarded
game Gg(M, M′, f) we say that a and a′ are g-bisimilar.
The packed game Gp(M, M′, f) and the notion of packed bisimilarity are
deﬁned in the same way but using packed sets instead of guarded ones.
These restrictions on the moves of player ∀have direct syntactical coun-
terparts in the form of restrictions on quantiﬁcation: the idea is that we only
allow quantiﬁcation in the form ∃xϕ, where ϕ has to meet certain criteria.
Deﬁnition 7.6.3. We say that a formula ϕ packs a set of variables
{x1, . . . , xk} if ϕ is a conjunction of formulas of the form xi = xj or
R(xi1, . . . , xin) or ∃yR(xi1, . . . , xin) such that for every xi ̸= xj, there is a
conjunct in ϕ in which xi and xj both occur free.
The packed fragment PF is deﬁned as the smallest set of ﬁrst-order
formulas which contains all atomic formulas and is closed under the boolean
connectives and under packed quantiﬁcation. That is, whenever ψ is a packed
formula, π packs Free(π), and Free(ψ) ⊆Free(π), then ∃x(π ∧ψ) is packed
as well; π is called the guard of this formula. The guarded fragment GF is

7.6 Modal Logic and First-Order Logic
415
the subfragment of PF in which we allow only guarded quantiﬁcation; that
is, packed quantiﬁcation in which the guard π is an atomic formula.
PF n and GF n denote the restrictions to n variables and at most n-ary
predicate symbols of PF and GF, respectively.
When we want to be speciﬁc about the free variables occurring in the
formulas, we shall often write ∃y (π(x, y) ∧ψ(x, y)) for the quantiﬁed packed
formulas, tacitly assuming that x and y do not share any variables.
Typical examples of guarded (and thus also packed) sentences are
∀xy(Rxy →Ryx), ∃xy (Rxy ∧Ryx ∧(Rxx ∨Ryy)), and the standard
translation of a formula in the basic modal language (with R functioning as
guard). A typical nonexample is ∀xyz((Rxy ∧Ryz) →Rxz): it is neither
guarded nor packed. For an example of a packed formula which is not
guarded, consider ∃xyz((Rxy ∧Rxz ∧Ryz) ∧¬Cxyz).
Note that the notion of packedness only places meaningful restrictions on
pairs of distinct variables: since the formula x = x packs the set of variables
{x}, the formula ∃x(x = x ∧ψ(x)), (i.e., with a single quantiﬁcation over the
variable x) is a packed formula, at least, provided that ψ(x) is packed. When
ψ(x) is guarded, then ∃x(x = x ∧ψ(x)) is also guarded. Since this formula
is equivalent to ∃xψ(x), this shows that packedness allows a fairly mild form
of ordinary quantiﬁcation, namely over formulas with one free variable. A
nice corollary of this is that we may perform the standard translation of the
universal modality E within the two-variable guarded fragment:
ST x(Eϕ) = ST y(Eϕ) = ∃x(ST x(ϕ)) ≡∃x(x = x ∧ST x(ϕ)).
A similar translation to ﬁrst-order logic can be deﬁned for the language with
the until modality U. Its range is the packed fragment with three variables.
The interesting clause here is
ST x(U(ϕ, ψ)) = ∃y(Rxy ∧ST y(ϕ) ∧∀z((Rxz ∧Rzy) →ST z(ψ))).
This
formula
is
not
packed
itself,
because
in
the
subformula
∀z ((Rxz ∧Rzy) →ST z(ψ))) the guard Rxz ∧Rzy does not pack its
own free variables {x, y, z}. But, of course, the formula is equivalent to
∃y (Rxy ∧ST y(ϕ) ∧∀z ((Rxz ∧Rzy ∧Rxy) →ST z(ψ)))
which is packed. It is not hard to convert this example into a proof showing
that every formula in the Until language is equivalent to a packed formula.
The (adjusted) translation is another example of a packed sentence that is
not guarded.
We have deﬁned ﬁrst-order fragments by incorporating restrictions on the
moves in an Ehrenfeucht-Fra¨ıss´e game into the syntax. It is obvious that
packed formulas are preserved when player ∃has a winning strategy. But,
in fact, the fragments precisely characterize the formulas which are invariant
under the corresponding games.

416
7 Modal Logic and Decidability
Deﬁnition 7.6.4. A ﬁrst-order formula ϕ(x) is invariant under guarded
(packed) bisimulation if, for all g-bisimilar (p-bisimilar, respectively) tuples
a in M and a′ in M′ we have that M |= ϕ[a] iﬀM′ |= ϕ[a′].
Theorem 7.6.5. Let ξ be a ﬁrst-order formula. The following are then
equivalent:
(i) ξ is equivalent to a formula in the packed (guarded) fragment.
(ii) ξ is invariant under packed (guarded) bisimulations.
This theorem can be relativized in the usual way to n-variable fragments
and the corresponding n-pebble games. This is the ﬁrst analogue of a modal
theorem (the Characterization Theorem 7.3.4). In the section on basic modal
logic we saw that this theorem allowed us to prove that every satisﬁable
formula was satisﬁable in a tree. These trees were obtained by unraveling or
unwinding the model. Analogous notions of unraveling and tree models can
be deﬁned for the guarded and packed fragments as well; here, we conﬁne
ourselves to the notion of a loose model.
Deﬁnition 7.6.6. Let M = (D, I) be a ﬁrst-order structure. We call M a
loose model of degree k ∈N if there is some acyclic connected undirected
graph G = (G, E) and a function f mapping nodes of G to subsets of D of size
not exceeding k such that for every live tuple ¯s from M, the set L(s) = {k ∈
G | si ∈f(k) for all si}, is a nonempty and connected subset of G.
In words, we call a model M = (D, I) loose if we can associate a connected
graph G = (G, E) with it in the following way. Each node t of the graph
corresponds to a small subset f(t) of the model; a good way of thinking about
this is that t “describes” f(t). We then require that the graph “covers” the
entire model in the sense that any a ∈D belongs to one of these sets (this
follows from the fact that for any a ∈D, the “tuple” a is live). The fact that
each set L(a) is connected whenever a is live implies that diﬀerent nodes of
the graph will not give contradictory descriptions of the model. Finally, the
looseness of the model stems intuitively from the acyclicity of G and the con-
nectedness of the sets L(a), because this ensures that when we walk through
the graph we may describe diﬀerent parts of the model, but we never have
to worry about returning to the same part once we have left it. Summarizing,
we may see the graph as a loose, coherent collection of descriptions of local
submodels of the model. The loose models are the ones for which we can ﬁnd
such a graph. Note that the degree of a loose model corresponds directly to
the second locality principle that we identiﬁed at the end of Sect. 7.3.
Now we can announce our second modally ﬂavored theorem: it establishes
the loose model property for the packed fragment.
Theorem 7.6.7. Every satisﬁable packed formula ξ can be satisﬁed on a
loose model of degree not exceeding the number of variables occurring in ξ.
And, as we shall see later on, this property indeed plays a crucial role in
the proof of the following result.

7.6 Modal Logic and First-Order Logic
417
Theorem 7.6.8. It is decidable whether a packed formula is satisﬁable. In
fact, the satisﬁability problems for both the guarded and the packed fragment
are complete for 2EXPTIME.
The doubly exponential lower bound may raise doubts concerning the
relevance of this result. Fortunately, there are some large and very natural
fragments for which better bounds may be obtained, and here the second
notion of “locality” comes into play. This is because not only does the concept
of looseness generalize to these fragments, but we can also give analogous
versions for the notion of locality. Recall that we introduced this concept
when we saw that the basic modal language could be translated into the
two-variable fragment of ﬁrst-order logic. This suggests that we might try
to improve on Theorem 7.6.8 by considering ﬁnite-variable fragments of PF
and GF. And, indeed, it turns out that “bringing locality into the language”
brings down the complexity by one exponent!
In the case of the guarded fragment, we can formulate this result in a nice
way, by imposing conditions on the ﬁrst-order signature rather than on the
number of variables used. Recall that the signature of the modal fragment
of ﬁrst-order logic consists of unary relation symbols and one binary symbol.
In general, we call a ﬁrst-order signature L n-bounded if all relation symbols
in L have arity at most n. It is not very diﬃcult to see that every guarded
sentence in an n-bounded signature can be rewritten using only n variables.
Thus, just as in the basic modal case, the signature determines the number
of variables. Note that this property is lost for the full packed fragment, as
we can pack arbitrarily large sets with binary relations.
In any case, by implementing both looseness and locality in ﬁrst-order
logic we may obtain the following result.
Theorem 7.6.9. Fix a natural number n.
(i) The satisﬁability problem for formulas in the packed fragment PF n is
decidable in EXPTIME.
(ii) Hence, the satisﬁability problem for sentences in the guarded fragment
in the n-bounded signature is decidable in EXPTIME.
Note that for n ≥2 the satisﬁability problem for the guarded fragment
GF n is also EXPTIME-hard. This holds by the interpretation of the modal
system K + E using the standard translation. However, by also implementing
the ﬁrst locality principle (namely no global expressive power) it is even
possible to bring the complexity down to PSPACE, see the notes.
Finally, what about ﬁnite models? Several subfragments of the packed
fragment, including the guarded fragment, are known to have the ﬁnite model
property. For the full packed fragment, this was an open problem at the time
of writing this chapter, but recently, a positive solution to this problem has
been obtained. For reasons of space limitations, we cannot go into detail
here — see the notes for references.

418
7 Modal Logic and Decidability
7.6.2 Decidability and Complexity
This subsection provides the proofs of all the results mentioned above. The
main idea behind the proofs is given by the mosaic method that we met in
the decidability proof for the until system. Roughly speaking, this method
is based on the idea of deconstructing models into a (modulo isomorphism)
ﬁnite collection of ﬁnite submodels and, conversely, of building up new,
“nice”, models from such parts.
This subsection is structured as follows. We start with a formal deﬁnition
of the notion of mosaics and some related concepts. We then state the main
result concerning the mosaic method, namely the Mosaic Theorem, stating
that a packed formula has a model if and only if there is a bounded set of
bounded-size mosaics for it. This enables us to deﬁne our decision algorithms
and establish their complexity. We then continue by proving the Mosaic
Theorem. In doing so, we obtain as a by-product the loose model property
for the packed fragment.
Linked Sets of Mosaics
Mosaics form the key tools in our proof; for a formal deﬁnition we need
some syntactic preliminaries. Given a ﬁrst-order formula ξ, we let Var(ξ)
and Free(ξ) denote the sets of variables and free variables, respectively,
occurring in ξ. Let V
be a set of variables. A V -substitution is any
partial map σ
: V
→V . The result of performing a substitution σ
on the formula ψ is denoted by ψσ. (We can and may assume that if
Var(ψ) ⊆V , then Var(ψσ) ⊆V . For instance, when substituting y for x
in Rxz ∧∀y (Rzy →Qxy), we have to rename the bound variable y, as in
Ryz ∧∀u (Rzu →Qyu). The point is that we do not need to use a fresh
variable u for this: instead, we may reuse x, giving Ryz ∧∀x (Rzx →Qyx).)
As before, we shall employ a notion of closure to delineate a ﬁnite set of rel-
evant formulas, i.e., formulas that for some reason critically inﬂuence the truth
of a given formula ξ. Also, recall that the single negation ∼ϕ of a formula ϕ
denotes the formula ψ if ϕ is of the form ¬ψ; otherwise, ∼ϕ is the formula ¬ϕ.
Deﬁnition 7.6.10. Let Σ be a set of packed formulas in the set V
of
variables. We call Σ V -closed if Σ is closed under subformulas, single
negations, and V -substitutions (that is, if ψ belongs to Σ, then so does ψσ
for every V -substitution σ). By Clg(ξ), we denote the smallest Var(ξ)-closed
set of formulas containing ξ.
For the remainder of this section, we ﬁx a packed formula ξ — all
deﬁnitions to come should be understood as being relativized to ξ. The
number of variables occurring in ξ (free or bound) is denoted by k; that
is, k is the size of Var(ξ). It can easily be veriﬁed that the sets of guarded
and packed formulas are both closed under taking subformulas; hence, the

7.6 Modal Logic and First-Order Logic
419
set Clg(ξ) consists of guarded (packed, respectively) formulas. An easy
calculation shows that the cardinality of Clg(ξ) is bounded by kk · (2|ξ|) (kk
is the number of Var(ξ)-substitutions).
The following notion is the counterpart of the maximally propositionally
consistent sets that we have met in earlier decidability proofs. The deﬁning
conditions again derive from a desire to prove a truth lemma.
Deﬁnition 7.6.11. Let X ⊆Var(ξ) be a set of variables. An X-type is a set
Γ ⊆Cl g(ξ) with free variables in X satisfying, for all formulas ϕ ∧ψ, ∼ϕ,
and ϕ in Clg(ξ) with free variables in X, the following conditions:
(T1) ϕ ∧ψ ∈Γ iﬀϕ ∈Γ and ψ ∈Γ;
(T2) ϕ ̸∈Γ iﬀ∼ϕ ∈Γ;
(T3) ϕ, xi = xj ∈Γ only if ϕσ ∈Γ (for any substitution σ mapping xi to
xj and/or xj to xi, while leaving all other variables ﬁxed); and
(T4) if ψ(x, z) and π(x, z) are in Γ, then so is ∃y (π(x, y) ∧ψ(x, y))
(provided that the latter formula belongs to Clg(ξ)).
The next deﬁnition introduces our key tool for proving the decidability
of the packed fragment: mosaics and linked sets of mosaics. Basically, a
mosaic consists of a set X of variables in Var(ξ) and a set Γ encoding the
relevant information about some small part of a model. Here “small” means
that its size is bounded by the number of objects that can be named using
variables in X, and “relevant” refers to all formulas in Clg(ξ) whose free
variables are in X. It turns out that a ﬁnite set of such mosaics contains
suﬃcient information to construct a model for ξ, provided that the set links
the mosaics together in a nice way. Here is a more formal deﬁnition.
Deﬁnition 7.6.12. A mosaic is a pair (X, Γ) such that X ⊆Var(ξ) and
Γ ⊆Cl g(ξ). A mosaic (X, Γ) is coherent if Γ is an X-type.
A link between two mosaics (X, Γ) and (X′, Γ ′) is a renaming (that is, an
injective substitution) σ with dom(σ) ⊆X and ran(σ) ⊆X′ which satisﬁes,
for all formulas ϕ ∈Clg(ξ), ϕ ∈Γ iﬀϕσ ∈Γ ′.
A
requirement
of
a
mosaic
is
a
formula
of
the
form
ϕ(x)
=
∃y (π(x, y)∧ψ(x, y)) belonging to Γ. A mosaic (X′, Γ ′) fulﬁlls the requirement
∃y (π(x, y) ∧ψ(x, y)) of a mosaic (X, Γ) via the link σ, if, for some variables
u, v in X′, we have that σ(x) = u and that π(u, v) and ψ(u, v) belong to Γ ′.
A set S of mosaics is linked if every requirement of every mosaic in S is
fulﬁlled via some link to some mosaic in S. S is a linked set of mosaics for
ξ if it is linked and ξ ∈Γ for some (X, Γ) in S.
Note that a mosaic (X, Γ) may fulﬁll its own requirements, either via the
identity map or via some other map from X to X.
The key result concerning mosaics is the following Mosaic Theorem.
Theorem 7.6.13 (Mosaic Theorem). Let ξ be a packed formula. Then ξ
is satisﬁable if and only if there is a linked set of mosaics for ξ.

420
7 Modal Logic and Decidability
Proof. The hard, right-to-left, direction of the theorem is proved in
Lemma 7.6.14 below; here we prove only the other direction.
Suppose that ξ is satisﬁed in the model M = (D, I). In a straightforward
way we can “cut out” from M a linked set of mosaics for ξ. Consider the set
of partial assignments of elements in D to variables in Var(ξ). For each such
α, let (Xα, Γα) be the mosaic given by Xα = dom(α) and
Γα = {ϕ ∈Clg(ξ) | M |= ϕ[α]}.
We leave it to the reader to verify that this collection forms a linked set of
mosaics for ξ.
2
In establishing the hard direction of this proposition, we shall in fact
prove something stronger: starting from a linked set of mosaics for a formula
ξ we shall show that there is a loose or tree-like model for ξ.
First, however, we want to show that the Mosaic Theorem is the key
for proving the decidability of the packed fragment, and also for ﬁnding an
upper bound for its complexity.
The Decision Algorithm and Its Complexity
The Mosaic Theorem tells us that any packed formula ξ is satisﬁable if and
only if there is a linked set of mosaics for ξ. Thus in order to decide whether
ξ is satisﬁable, it suﬃces to give an algorithm which decides the existence
of a linked set of mosaics for ξ. We shall establish the upper complexity
bound for the satisﬁability problem of packed formulas by implementing
such an algorithm. The following observations are easy consequences of our
deﬁnitions; recall that k denotes the number of variables occurring in ξ.
•
We have already observed that the cardinality of Cl g(ξ) is bounded by
kk · 2|ξ|.
•
The number of mosaics does not exceed 2k · 22|ξ|·kk; using the big O
notation, this gives at most 2O(|ξ|)·kk mosaics.
•
given sets X, Γ with X ⊆Var(ξ) and Γ ⊆Clg(ξ), it is decidable in time
2O(|ξ|)·kk whether (X, Γ) is a coherent mosaic.
Our algorithm is very similar to the one we used for the until system in
Subsect. 7.4.3. Let S0 be the set of all coherent mosaics. By the observations
above, S0 contains fewer than 2O(|ξ|)·kk elements and can be constructed in
time 2O(|ξ|)·kk. We now inductively construct a sequence of sets of mosaics
S0 ⊋S1 ⊋S2 ⊋S3 · · · , as follows. We call a mosaic μ in a set Si Si-ready if
each of its requirements is fulﬁlled in (some mosaic of) Si. Note that one can
determine the Si-readiness of a mosaic (X, Γ) by checking, for each require-
ment ϕ(x) ∈Γ, whether there is a link σ to some mosaic (X′, Γ ′) ∈Si which
fulﬁlls the requirement. If every mosaic μ in Si is Si-ready, then return “YES”
if Si contains a mosaic (X, Γ) with ξ ∈Γ, and “NO” if Si contains no such

7.6 Modal Logic and First-Order Logic
421
mosaic. If, on the other hand, there are mosaics in Si that are not Si-ready,
then we let Si+1 consist of the Si-ready mosaics and continue the algorithm.
Clearly the algorithm is correct; and since Si ⊋Si+1, the construction
must halt after at most |S0| many stages. So let us now see about the
complexity. At each stage i, the algorithm determines the Si-ready mosaics;
we claim that this can be done in time exponential in kk · O(|ξ|).
To check whether a given link between two given mosaics fulﬁlls some given
requirement is a task that takes time linear in the size of each mosaic, and so
time quadratic in kk · 2|ξ|. In order to ﬁnd out whether a given mosaic (X, Γ)
in a set Si is Si-ready, the algorithm has to check, for every requirement ϕ(x)
of the mosaic, for every link σ, and for every mosaic (X′, Γ ′) in Si, whether
σ is a link between the mosaics fulﬁlling the requirement. Clearly, then, for a
given mosaic, this takes time at most kk·2|ξ| (for the number of requirements)
times kk (for the number of links) times |Si| (for the number of mosaics)
times (kk · 2|ξ|)2 (for the checking time). Note that Si is the only number in
this product that is exponential in kk · O(|ξ|). Hence, in order to compute all
the Si-ready mosaics, the algorithm needs time exponential in O(|ξ|) · kk.
As the size of S0 is bounded by 2O(|ξ|)·kk, the whole computation can
be performed in time exponential in O(|ξ|) · kk. Hence, if we consider a
formula ξ in a packed fragment with a ﬁxed number of variables, |S0| is singly
exponential in |ξ|. In general, however, the number of variables k occurring
in a formula depends on the formula’s length and hence, in general, |S0| is
doubly exponential in |ξ|. Thus, pending the proof of the next lemma, this
shows the upper complexity bounds given in Theorems 7.6.8 and 7.6.9.
Step-by-Step Construction and Loose Models
We now show the hard direction of the Mosaic Theorem and establish, as a
by-product, the “loose model property” of Theorem 7.6.7.
Lemma 7.6.14. Let ξ be a packed formula. If there is a linked set of mosaics
for ξ, then ξ is satisﬁable in a loose model of degree |Var(ξ)|.
Proof. Assume that S is a linked set of mosaics for ξ. Using a step-by-step
construction, we shall build a model for ξ, together with a graph G and
a function f mapping nodes of G to subsets of the domain of the model.
At each stage of the construction, we shall be dealing with some kind of
approximation of the ﬁnal model and graph; these approximations will be
called networks and are fairly complex structures.
A network is a quintuple (M, G, μ, α, σ) such that M = (D, I) is a model
for the ﬁrst-order language; G = (G, E) is a connected, adirected, and acyclic
graph; μ : G →S is a map associating a mosaic μt = (Xt, Γt) in S with each
node t of the graph; and α is a map associating a map αt : Xt →D with each
node t of the graph. (This map is thus a partial assignment of the variables
occurring in ξ.) And, ﬁnally, σ is a map associating with each edge (t, t′) of

422
7 Modal Logic and Decidability
the graph a link σtt′ from μt to μt′ (we shall usually simplify our notation by
writing σ instead of σtt′).
The idea is that each mosaic μt is supposed to give a complete description
of the relevant requirements that we impose on a small part of the model-to-
be. Which part? This is given by the assignment αt. And the word “relevant”
refers to the fact that we are interested only in the formulas inﬂuencing the
truth of ξ; that is, the formulas in Clg(ξ). The links between neighboring
mosaics are there to ensure that distinct mosaics agree on the part of the
model that they both have access to.
Now, obviously, if we want all of this to work properly we have to impose
some conditions on the networks. In order to formulate these, we need some
auxiliary notation. For a subset A ⊆D, let L(A) denote the set of nodes in
G that have “access” to A; formally, we deﬁne L(A) = {t ∈G | A ⊆ran(αt)}.
For a tuple a = (a1, . . . , an) of elements in D we set L(a) = L({a1, . . . , an}).
Now a network is called coherent if it satisﬁes the following conditions (all to
be read as universally quantiﬁed):
(C1) Px ∈Γt iﬀM |= Px[αt];
(C2) xi = xj ∈Γt iﬀαt(xi) = αt(xj);
(C3) L(A) is nonempty for every guarded set A ⊆D;
(C4) L(A) is connected for every guarded set A ⊆D;
(C5) if Ett′, then σtt′(x) = x′ iﬀαt(x) = αt′(x′).
A few words of explanation about these conditions: (C1) and (C2) ensure
that every mosaic is a complete description of the atomic formulas that
hold in the part of the model it refers to. Condition (C3) states that no
guarded set in the model remains unseen from the graph, and the conditions
(C4) and (C5) are the crucial ones that ensure that remote parts of the
graph cannot contain contradictory information about the model — how this
works precisely will become clear later on. Note that condition (C5) has two
directions: the left-to-right direction states that neighboring mosaics have
common access to part of the model, while the other direction makes them
agree on their requirements concerning this common part.
The motivation for using these networks is that in the end we want any
formula ϕ(x) ∈Clg(ξ) to hold in M under the assignment αt if and only
if ϕ(x) belongs to Γt. Coherence on its own is not suﬃcient to make this
happen. A defect of a network consists of a formula ∃y (π(x, y) ∧ψ(x, y))
which is a requirement of the mosaic μt for some node t while there is no
neighboring node t′ such that μt′ fulﬁlls ∃y (π(x, y) ∧ψ(x, y)) via the link
σtt′. A coherent network N is perfect if it has no defects. We say that N is
a network for ξ if for some t ∈G, μt = (Xt, Γt) is such that ξ ∈Γt.
Claim 1. If N = (M, G, μ, α, σ) is a perfect network, then
(i) M is a loose model of degree |Var(ξ)|, and
(ii) for all formulas ϕ(x) ∈Clg(ξ) and all nodes t of G,
ϕ ∈Γt iﬀM |= ϕ[αt].

7.6 Modal Logic and First-Order Logic
423
Proof of Claim For part (i) of the claim, let N = (M, G, μ, α, σ) be the per-
fect network for ξ. Let M = (D, I). As the function f mapping nodes of G to
subsets of D, we simply take the map that assigns the range of αt to the node t.
Since the domain of each map αt is always a subset of Var(ξ), it follows imme-
diately that f(t) will always be a set of size at most |Var(ξ)|. Now take an arbi-
trary live tuple s in M; it follows from (C3) and (C4) that L(s) is a nonempty
and connected part of the graph G. Thus M is a loose model of degree |Var(ξ)|.
We prove part (ii) of the claim by induction on the complexity of ϕ. For
atomic formulas, the claim follows by conditions (C1) and (C2), and the
boolean case of the induction step is straightforward (since Γt is an X-type)
and is left to the reader. We concentrate on the case where ϕ(x) is of the
form ∃y (π(x, y) ∧ψ(x, y)).
First, assume that ϕ(x) ∈Γt. Since N is perfect there is a node t′ in G and
variables u, v in Xt′ such that Ett′, π(u, v), and ψ(u, v) belong to Γt′, while the
link σ from μt to μt′ maps x to u. By the induction hypothesis, we ﬁnd that
M |= π(u, v) ∧ψ(u, v)[αt′].
(7.13)
But, from condition (C5), it follows that αt′(x) = αt(u); hence (7.13) implies
that
M |= ∃y (π(x, y) ∧ψ(x, y))[αt],
which is what we were after.
Now suppose, in order to prove the converse direction, that M |= ϕ(x)[αt].
Let a denote αt(x); there are then b in D such that M |= π(x, y)[ab] and
M |= ψ(x, y)[ab]. Our ﬁrst aims are to prove that
L(ab) ̸= ∅
(7.14)
and
L(A) is connected for every A ⊆{a, b}.
(7.15)
Note that if we are working in the guarded fragment, then π(x, y) is
an atomic formula, and hence it follows from M |= π(x, y)[ab] that ab is
live. Thus {a, b} is guarded, and hence (7.14) follows directly by condition
(C3). In fact, every A ⊆{a, b} is guarded in this case, and so (7.15) follows
immediately by condition (C4).
In the more general case of the packed fragment we have to work a little
harder. First, observe that it does follow from M |= π(x, y)[ab] and the
conditions on π(x, y) in the deﬁnition of packed quantiﬁcation that {c, d}
is guarded, and thus L(c, d) ̸= ∅, for every pair (c, d) of points taken from
ab. It follows from (C4) that {L(c, d) | c, d taken from ab} is a collection of
nonempty, connected, pairwise overlapping subgraphs of the acyclic graph
G. It is fairly straightforward to prove, for instance by induction on the size
of the graph G, that any such collection must have a nonempty intersection.
From this, (7.14) and (7.15) follow almost immediately.

424
7 Modal Logic and Decidability
We thus may assume the existence of a node t′ in G such that
{a, b} ⊆ranαt′. Let u and v in Xt′ be the variables such that αt′(u) = a and
αt′(v) = b. The induction hypothesis implies that π(u, v) and ψ(u, v) belong
to Γt′, and hence ϕ(u) ∈Γt′ by the coherence of μt′. Since both t and t′
belong to L(a), it follows from (7.15) that there is a path from t to t′ within
L(a), say t′ = s0Es1E . . . Esn = t. Let σi be the link between the mosaics of
si and si+1, and deﬁne ρ to be the composition of these maps. It follows by
an easy inductive argument on the length of the path that ρ is a link between
μt′ and μt such that ρ(u) = x. Hence, by the deﬁnition of a link, we have
that ϕ(x) ∈Γt′. This ﬁnishes the proof of the claim.
By Claim 1, in order to prove the lemma it suﬃces to construct a perfect
network for ξ. This construction uses a step-by-step argument; to start the
construction, we need some coherent network for ξ.
Claim 2. There is a coherent network for ξ.
Proof of Claim By our assumption about ξ, there is a coherent mosaic
μ = (X, Γ) such that ξ ∈Γ. Without loss of generality we may assume that
X is the set {x1, . . . , xn} (otherwise, we can take an isomorphic copy of μ in
which X does have this form). Let a1, . . . , an be a list of objects such that,
for all i and j, we have that ai = aj if and only if the formula xi = xj belongs
to Γ. Deﬁne D = {a1, . . . , an}, and put the tuple (ai1, . . . , aik) in the inter-
pretation I(P) of the k-ary predicate symbol P precisely if Pxi1 . . . xin ∈Γ.
Let M be the resulting model (D, I), and deﬁne G as the trivial graph with
one node 0 and no edges. Let μ(0) be the mosaic μ; let α0 : X →D be given
by α(xi) = ai; and, ﬁnally, let σ00 be the identity map from X to X.
We leave it for the reader to verify that the quintuple (M, G, μ, α, σ) is a
coherent network for ξ. This ﬁnishes the proof of the claim.
The crucial step of this construction is to show that any defect of a
coherent network can be repaired.
Claim 3. For any coherent network N = (M, G, μ, α, σ) and any defect of
N there is a coherent network N + that extends N and lacks this defect.
Proof of Claim Suppose that ϕ(x) is a defect of N because it is a
requirement of the mosaic μt and not fulﬁlled by any neighboring mosaic μt′.
We shall deﬁne an extension N + of N in which this defect is repaired.
Since S is a linked set of mosaics and μt belongs to S, μt is linked to a
mosaic (X′, Γ ′) ∈S in which the requirement is fulﬁlled via some link ρ. Let
Y be the set of variables in X′ that do not belong to the range of ρ; suppose
that Y = {y1, . . . , yk} (with all yi being distinct). For the sake of a smooth
presentation, assume that Γ ′ contains the formulas ¬x′ = y for all variables
x′ ∈X′ and y ∈Y (this is not without loss of generality — we leave the
general case as an exercise for the reader). Take a set {c1, . . . , ck} of fresh

7.6 Modal Logic and First-Order Logic
425
objects (that is, no ci is an element of the domain D of M), and let γ be the
assignment with domain X′ deﬁned as follows:
γ(x′) =
αt(x) if x′ = ρ(x),
ci
if x′ = yi.
Let
t′
be
an
object
not
belonging
to
G.
Now
deﬁne
the
network
N + = (M+, G+, μ+, α+, σ+) as follows:
D+ = D ∪{c1, . . . , ck},
I+(P) = I(P) ∪{d | for some x, d = γ(x) and Px ∈Γ ′},
G+ = G ∪{t′},
E+ = E ∪{(t, t′)},
and μ+, α+ and σ+ are given by the obvious extensions of μ, α, and σ,
namely by putting μ+
t′ = (X′, Γ ′), α+
t′ = γ, and σtt′ = ρ.
Since the interpretation I+ agrees with I on “old” tuples, it is a straight-
forward exercise to verify that the new network N + satisﬁes the conditions
(C1 - C3) and (C5).
In order to check that condition (C4) holds, take some guarded subset A
from D+; we shall show that L+(A) is a connected subgraph of G+. It is rather
easy to see that L+(A) is identical to either L(A) or L(A)∪{t′}; hence by the
connectedness of L(A), it suﬃces to prove, on the assumption that t′ ∈L+(A)
and L(A) ̸= ∅, that t ∈L(A). Hence, suppose that t′ ∈L+(A); that is, each
a ∈A is in the range of γ. But if L(A) ̸= ∅, each such point a must be old;
hence, by the deﬁnition of γ, each a ∈A must belong to ran(αt). This gives
the result that t ∈L(A), as required. This ﬁnishes the proof of the claim.
As in the proof for the until system, the previous two claims show that by
using some standard combinatorics we can construct a chain of networks such
that their limit is a perfect network. This ﬁnishes the proof of the lemma.
2
7.6.3 Notes
The roots of the decidability proof in this section date back to 1986, when
N´emeti [45] showed that the equational theory of the class Crs of relativized
cylindric set algebras is decidable. The ﬁrst-order counterpart of this result
is that a certain subfragment of the guarded fragment is decidable.
The importance of this result for ﬁrst-order logic was realized in 1994
when Andr´eka, van Benthem & N´emeti introduced the guarded fragment and
showed that many nice properties of the basic modal system K generalize to it.
In particular, these authors established a characterization in terms of guarded
bisimulations, decidability, and a kind of tree model property. The journal ver-
sion of their paper is [2]. Some time later, van Benthem [7] generalized some of
the results, introducing the loosely guarded fragment. The slightly more gen-
eral packed fragment was introduced by Marx [41] in order to give a semantic

426
7 Modal Logic and Decidability
characterization in terms of packed bisimulations (Theorem 7.6.5). (An exam-
ple of a packed sentence which is not equivalent to a loosely guarded sentence
in the same signature is ∃xyz(∃wCxyw ∧∃wCxzw ∧∃wCzyw ∧¬Cxyz).)
The mosaic-based decision algorithms used by Andr´eka, van Benthem &
N´emeti were essentially optimal, a result established by Gr¨adel [21]. In that
paper, Gr¨adel also deﬁnd and established the loose model property for the
loosely guarded fragment. Our deﬁnition of a loose model is based on the
deﬁnition of a tree model given there. Gr¨adel & Walukiewicz [22] showed that
the same bounds obtain when the guarded fragment is expanded with least
and greatest ﬁxed-point operators. Marx, Schlobach & Mikulas [42] deﬁned
a PSPACE complete guarded fragment with the ﬁnite tree model property.
This fragment satisﬁes both locality principles.
The ﬁnite model property for the guarded fragment and several sub-
fragments of the packed fragment was established in an algebraic setting
by Andr´eka, Hodkinson & N´emeti [1]. Gr¨adel [21] provided a direct proof
for the guarded fragment. After we ﬁnished the writing of this chapter,
Hodkinson [32] proved the ﬁnite model property of the full packed fragment.
All these results are based on variants of a result due to Herwig [29]. The use
of Herwig’s Theorem to establish the ﬁnite model property and to eliminate
the need of step-by-step constructions originates with Hirsch et alii [30].
Acknowledgments
We are very grateful to Carlos Areces, Edith Hemaspaandra, and Carla
Piazza for scrutinizing earlier versions of this manuscript and for making
many suggestions for improvement. We would also like to thank Moshe Vardi
and Scott Weinstein for inviting us to participate in this project.
References
1. H. Andr´eka, I. Hodkinson, and I. N´emeti.
Finite algebras of relations are
representable on ﬁnite sets. Journal of Symbolic Logic, 64(1):243–267, 1999.
2. H. Andr´eka, J. van Benthem, and I. N´emeti. Modal languages and bounded
fragments of predicate logic. Journal of Philosophical Logic, 27(3):217–274, 1998.
3. J. Balc´azar, J. D´ıaz, and J. Gabarr´o.
Structural Complexity I.
EATCS
Monographs on Theoretical Computer Science, No. 11. Springer, 1988.
4. J. van Benthem.
Modal Correspondence Theory.
PhD thesis, Mathematisch
Instituut & Instituut voor Grondslagenonderzoek, University of Amsterdam,
1976.
5. J. van Benthem. Modal Logic and Classical Logic. Bibliopolis, Naples, 1983.
6. J. van Benthem. Exploring Logical Dynamics. Studies in Logic, Language and
Information. CSLI Publications, Stanford, 1996.
7. J. van Benthem. Dynamic bits and pieces. Technical Report LP-97-01, Institute
for Logic, Language and Computation, University of Amsterdam, 1997.

References
427
8. R. Berger. The undecidability of the domino problem. Memoirs of the American
Mathematical Society, 66: 1–72, 1966.
9. P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Cambridge University
Press, 2001.
10. E. B¨orger, E. Gr¨adel, and Y. Gurevich.
The Classical Decision Problem.
Springer, 1997.
11. A. Borgida.
Description logics in data management.
IEEE Transactions on
Knowledge and Data Engineering, 7:671–682, 1995.
12. J.P. Burgess and Y. Gurevich. The decision problem for linear temporal logic.
Notre Dame Journal of Formal Logic, 26:115–128, 1985.
13. D. Calvanese, G. De Giacomo, D. Nardi, and M. Lenzerini.
Reasoning in
expressive description logics.
In A. Robinson and A. Voronkov, editors,
Handbook of Automated Reasoning, pages 1581–1634. Elsevier Science, 1999.
14. A. Chagrov and M. Zakharyaschev. Modal Logic. Oxford Logic Guides No. 35.
Oxford University Press, Oxford, 1997.
15. A. Chandra and P. Merlin.
Optimal implementation of conjunctive queries
in relational databases. In Proceedings of 9th ACM Symposium on Theory of
Computing, pages 77–90, 1977.
16. M.A.E. Dummett and E.J. Lemmon. Modal logics between S4 and S5. Zeitschrift
f¨ur mathematische Logik und Grundlagen der Mathematik, 5:250–264, 1959.
17. R. Fagin, J.Y. Halpern, Y. Moses, and M.Y. Vardi. Reasoning about Knowledge.
MIT Press, 1995.
18. M. Fischer and R. Ladner. Propositional dynamic logic of regular programs.
Journal of Computer and System Sciences, 18(2):194–211, 1979.
19. M. F¨urer. The computational complexity of the unconstrained limited domino
problem (with implications for logical decision problems).
In E. B¨orger, G.
Hasenjaeger and D. R¨odding, Logic and Machines: Decision Problems and
Complexity. Lecture Notes in Computer Science No. 171, pages 312–319.
Springer, 1981.
20. D.M. Gabbay. An irreﬂexivity lemma with applications to axiomatizations of
conditions on linear frames.
In U. M¨onnich, editor, Aspects of Philosophical
Logic, pages 67–89. Reidel, 1981.
21. E. Gr¨adel.
On the restraining power of guards.
Journal of Symbolic Logic,
64(4):1719–1742, 1999.
22. E. Gr¨adel and I. Walukiewicz. Guarded ﬁxed point logic. In Proceedings of
14th IEEE Symposium on Logic in Computer Science LICS ’99, Trento, 1999.
23. J.Y. Halpern and Y.O. Moses.
A guide to completeness and complexity for
modal logics of knowledge and belief. Artiﬁcial Intelligence, 54:319–379, 1992.
24. D. Harel. Dynamic logic. In D.M. Gabbay and F. Guenther, editors, Handbook
of Philosophical Logic, volume 2, pages 497–604. Reidel, Dordrecht, 1984.
25. R. Harrop. On the existence of ﬁnite models and decision procedures for proposi-
tional calculi. Proceedings of the Cambridge Philosophical Society, 54:1–13, 1958.
26. L. Henkin.
Logical Systems Containing Only a Finite Number of Symbols.
S´eminiare de Mathematique Sup´erieures 21.
Les Presses de l’Universit´e de
Montr´eal, Montr´eal, 1967.
27. L. Henkin, J. D. Monk, and A. Tarski.
Cylindric Algebras, Parts I and II.
North-Holland, 1971 and 1985.
28. M. Hennessy and R. Milner. Algebraic laws for indeterminism and concurrency.
Journal of the ACM, 32:137–162, 1985.

428
7 Modal Logic and Decidability
29. B. Herwig. Extending partial isomorphisms on ﬁnite structures. Combinatorica,
15:365–371, 1995.
30. R. Hirsch, I. Hodkinson, M. Marx, Sz. Mikul´as, and M. Reynolds. Mosaics and
step-by-step. Remarks on “A modal logic of relations”. In E. Orlowska, editor,
Logic at Work. Essays Dedicated to the Memory of Elena Rasiowa, Studies in
Fuzziness and Soft Computing, pages 158–167. Springer, 1999.
31. W. Hodges. Model Theory. Cambridge University Press, 1993.
32. I. Hodkinson. Loosely guarded fragment of ﬁrst-order logic has the ﬁnite model
property. Studia Logica, 70(2):205–240, 2002.
33. N. Immerman. Upper and lower bounds for ﬁrst-order expressibility. Journal
of Computer and System Sciences, 25:76–98, 1982.
34. N. Immerman and D. Kozen.
Deﬁnability with bounded number of bound
variables.
In Proceedings of the Symposium on Logic in Computer Science,
pages 236–244, Washington, 1987. Computer Society Press.
35. D. Janin and I. Walukiewicz.
On the expressive completeness of the propo-
sitional μ-calculus w.r.t. monadic second-order logic.
In Proceedings of
CONCUR ’96, 1996.
36. N. Kurtonina and M. de Rijke. Bisimulations for temporal logic. Journal of
Logic, Language and Information, 6:403–425, 1997.
37. R. Ladner. The computational complexity of provability in systems of modal
propositional logic. SIAM Journal of computing, 6(3):467–480, 1977.
38. E.J. Lemmon. Algebraic semantics for modal logics [Parts I and II]. Journal of
Symbolic Logic, pages 46–65 and 191–218, 1966.
39. Z. Manna and A. Pnueli.
The Temporal Logic of Reactive and Concurrent
Systems. Vol. 1, Speciﬁcation. Springer, 1992.
40. M. Marx.
Complexity of products of modal logics.
Journal of Logic and
Computation, 9(2):221–238, 1999.
41. M. Marx.
Tolerance logic.
Journal of Logic, Language and Information
10:353–373, 2001.
42. M. Marx, S. Schlobach, and Sz. Mikul´as. Labelled deduction for the guarded
fragment. In D. Basin et al., editors, Labelled Deduction, Applied Logic Series,
pages 193–214. Kluwer Academic, 2000.
43. M. Marx and Y. Venema. Multi-dimensional Modal Logic. Applied Logic Series.
Kluwer Academic, 1997.
44. J.C.C. McKinsey and A. Tarski.
The algebra of topology.
Annals of
Mathematics, pages 141–191, 1944.
45. I. N´emeti.
Free Algebras and Decidability in Algebraic Logic.
DSc. thesis,
Mathematical Institute of the Hungararian Academy of Sciences, Budapest,
1986 (in Hungarian; English version in [46]).
46. I. N´emeti.
Decidability of weakened versions of ﬁrst-order logic.
In Logic
Colloquium ’92, pages 177–242, Stanford, 1995. CSLI Publications.
47. M. Otto. Bounded Variable Logics and Counting. A Study in Finite Models.
Lecture Notes in Logic No. 9. Springer, 1997.
48. D. Park.
Concurrency and automata on inﬁnite sequences.
In P. Deussen,
editor, Theoretical Computer Science.
Lecture Notes in Computer Science
No. 104, pages 167–183. Springer, 1981.
49. S. Popkorn.
First Steps in Modal Logic.
Cambridge University Press,
Cambridge, 1992.
50. V. Pratt. Models of program logics. In Proceedings of the 20th IEEE symposium
on Foundations of Computer Science, pages 115–122, 1979.

References
429
51. E. Rosen. Modal logic over ﬁnite structures. Journal of Logic, Language and
Information, 6:427–439, 1997.
52. K. Segerberg.
An Essay in Classical Modal Logic.
Filosoﬁska Studier 13.
University of Uppsala, 1971.
53. K. Segerberg. Two-dimensional modal logic.
Journal of Philosophical Logic,
2:77–96, 1973.
54. A. Sistla and E. Clarke.
Complexity of propositional linear temporal logics.
Journal of the ACM, 32(3):733–749, 1985.
55. E. Spaan.
Complexity of Modal Logics.
PhD thesis, Institute for Logic,
Language and Computation, University of Amsterdam, 1993.
56. C. Stirling. Modal and temporal logics. In S. Abramsky, D.M. Gabbay, and
T.S.E. Maibaum, editors, Handbook of Logic in Computer Science I, pages
641–761. Clarendon Press, 1992.
57. M. Vardi. On the complexity of bounded-variable queries. In N. Immerman and
Ph. G. Kolaitis, editors, Descriptive Complexity and Finite Models, volume 31
of DIMACS Series in Discrete Mathematics and Theoretical Computer Science,
pages 149–184. American Mathematical Society, 1996.
58. M. Vardi. Why is modal logic so robustly decidable? In DIMACS Series in
Discrete Mathematics and Theoretical Computer Science 31, pages 149–184.
American Math. Society, 1997.
59. Y. Venema. Many-Dimensional Modal Logic. PhD thesis, Institute for Logic,
Language and Computation, University of Amsterdam, 1992.
60. Y. Venema. Cylindric modal logic. Journal of Symbolic Logic, 60(2):591–623,
1995.
61. H. Wang. Proving theorems by pattern recognition II. Bell Systems Techical
Journal, 40:1–41, 1961.


Index
0–1 law (see also zero–one law), 6, 98
2-Colorability, 32, 48, 346
2-Disjoint Paths query, 29, 118
3-Colorability, 340, 342, 344–346
3-Sat, 340, 341, 344, 345, 347, 350
Abiteboul, S., 178
active
domain, 261
quantiﬁcation, 262
active-generic collapse, 268
in ordered structures, 273
Acyclicity query, 33, 48, 68
aggregate operator, 323
AVG, 323
approximation of, 323
VOL, 325
approximation of, 326
Ajtai–Fagin game, 56
method for monadic ESO, 57
aleph-nought categorical, 233
Alice’s Restaurant, 241
alternation depth, 166
alternation level, 165
arc consistency, 362
arithmetical structures, 211
arithmetical term, 191
Articulation Point query, 29
artiﬁcial intelligence, 339
asymptotic probability, 97
automatic structure, 207
back property up to k, 90
basic modal
formula, 378
system, 379
binary string, 28
bisimulation, 198, 375
game, 20, 382
invariance, 21, 199, 379, 416
Blass, A., 183
Blum, L., 216
Boolean query, 2, 29
bounded-variable fragment, 133
BSS machine, 216, 217
B¨uchi, J., 145
bucket-elimination algorithm, 363
canonical conjunctive query, 344
canonical database, 343
canonization, 195
deﬁnable, 196
capture
a complexity class, 14, 138, 144
eﬀectively, 17, 204
Caucal hierarchy, 209
Chandra–Merlin Theorem, 343
circuit value problem, 146, 156
class of σ-structures, 29
Clique, 344
closed under subfunctions, 90
closure, 237
of a formula, 133
closure ordinal, 61, 154
coherence, 360

432
Index
collapse, 268
active-generic, 268
in ordered structures, 273
and VC dimension, 296
natural-active, 268, 274
algorithm for, 284
and o-minimality, 277
failure of, 274
for FO + Lin, 277, 278, 280
for FO + Poly, 277
for Presburger arithmetic, 285
over empty vocabulary, 275
natural-generic, 269
and o-minimality, 287
and VC dimension, 288
relationship between, 289
restricted quantiﬁer, 289
and ﬁnite cover property, 291
and isolation property, 292
and PFH, 290
and VC dimension, 296
colored directed graph, 28
combined complexity, 13, 51, 127, 346,
347
complete lattice, 153
complexity
combined complexity, 13, 51, 127,
346, 347
data complexity, 13, 51, 127, 346,
351, 352
descriptive complexity, 127
expression complexity, 13, 51, 127,
346, 347
structure complexity, 127
Compton, K., 249
cone type, 303
and FO + Poly, 304
conﬁguration, 358
winning, 358
conjunctive query, 259, 342
cannonical, 344
containment problem, 343
evaluation problem, 343
connectivity
and closed languages, 329
and FO + Poly, 302
deﬁning in constraint query
languages, 328
reduction to majority, 302
topological, 301
Connectivity query, 29, 33, 47, 50, 57, 67
consistency, 357–362
global, 357
local, 357
constraint database, 265
constraint query languages, expressive-
ness of, 301
constraint-satisfaction problem, 339
Cook, S., 142
core, 365
counting term, 188
Dahlhaus, E., 185
data complexity, 13, 51, 127, 346, 351,
352
database
canonical, 343
constraint, 265
Datalog, 74, 180, 352–362
bounded, 355
linear, 186
monadic, 354, 355
stratiﬁed, 185
with counting, 191
Datalog program, 74
goal of, 74
Datalog(̸=), 77
Datalog-Classiﬁcation problem, 354
Dawar, A., 205
deﬁnable
family, 287
query, 30
set, 264
dependency order, 165
Dichotomy Conjecture, 12, 349
Dichotomy Theorem, 348
dichotomy theorem, 348, 349
directed graph, 28
colored, 28
ordered, 28
Disconnectivity query, 32
domain, 144
EDB, 74
Ehrenfeucht game (see also
Ehrenfeucht–Fra¨ıss´e game), 233,
253

Index
433
Ehrenfeucht–Fra¨ıss´e game (see also
Ehrenfeucht game), 9, 34
r-move, 34
method for ESO, 55
method for FO, 42
winning strategy, 36
elementary equivalence, 8
Elgot, C., 145
embedded ﬁnite model, 261
encoding (of structures by strings), 136
equivalence
elementary, 8
homomorphic, 365
Erd¨os, P., 232, 234
ESO, 31
establishing strong k-consistency, 360
Eulerian query, 33, 43
Even Cardinality query, 29, 33, 42, 45, 95
Even Path query, 72
Even Simple Path query, 77
existential ﬁxed-point logic, 182
existential inﬁnitary logic, 107
existential k-pebble game, 109
existential second-order logic, 31, 139
expression complexity, 13, 51, 127, 346,
347
extension axioms, 298
face, 263
Fagin’s Theorem, 15, 54, 350
Fagin, R., 139, 142, 150, 241
Fin(τ), 136
ﬁnite cover property, 291
and ﬁnite strings, 291
ﬁnite σ-structure, 28
ﬁnite stage, 60
ﬁrst-order logic
over embedded ﬁnite models, 261
with linear constraints, 265
with polynomial constraints, 265
FiSH(H) query, 116
ﬁxed point, 60, 153
greatest, 61, 153
inﬂationary, 174
least, 60, 153
of relational operators, 153
partial, 177
Fixed Subgraph Homeomorphism
query, 116
FOk, 87
FO + Lin, 265
FO + Poly, 265
FO + Poly vs FO + Lin, 305
formula
basic modal, 378
monotone, 64
positive, 64
formula evaluation, 127
formulae
active-domain, 262
forth property up to k, 90
Gaifman graph, 45
Game, 130, 156
game
backtracking, 177
bisimulation, 20, 382
Borel, 130
combinatorial comparison, 8
determined, 129
Ehrenfeucht (see also Ehrenfeucht–
Fra¨ıss´e), 233, 253
Ehrenfeucht–Fra¨ıss´e (see also
Ehrenfeucht), 9, 34
existential k-pebble, 109
k-pebble, 89
model-checking game, 128
parity, 160
strictly alternating, 131
well-founded, 128, 129
GEN, 145, 156
Generalized Path Systems query, 84
generalized-satisﬁability problem, 347
generic query, 267
Geography query, 69
GIS, 263
Glebskii, Y., 241
global consistency, 357
G¨odel’s Completeness Theorem, 242
Gr¨adel, E., 148, 150, 188, 192, 210, 214,
219
graph, 28, 234
Gaifman graph, 45
ordered, 249
random, 234
rooted, 236
greatest ﬁxed point, 61, 153
Grohe, M., 198

434
Index
guarded
fragment, 414
game, 414
set, 414
Gurevich, Y., 175, 183, 203, 210, 214
Hamiltonian Path query, 32, 33, 96
Hansen, C., 249
Hella, L., 246
homeomorphism, 116
homomorphic equivalence, 365
homomorphism, 76, 341
one-to-one, 78
homomorphism problem, 341
Horn 3-Sat, 345
Horn formulae, 131
propositional, 148
i-consistency, 359
IDB, 74
IFP, 105, 174
Immerman, N., 151, 152, 157, 176, 187
inﬁnitary logic, 86, 356
existential positive, 356, 359
ﬁnite-variable, 356, 359
inﬂationary ﬁxed-point logic, 174
intermediate problems, 347
interpretation, 195
invariance
order, 137, 203
under bisimulation, 21, 199, 379, 416
under isomorphism, 137
island of tractability, 345, 365–367
isolation property, 292
and collapse, 293
and collapse over strings, 294
and Presburger arithmetic, 294
isomorphism, 28
canon, 17
invariance, 137
join, relational, 344
Jones, N., 143
Jurdzi´nski, M., 163
k-Colorability query, 32, 48
k-colorability, 33
k-consistency
establishing strong, 360
strong, 359
k-Datalog, 353, 354, 356, 361
k-Datalog-Classiﬁcation problem, 354
k-pebble game, 89
method of, 95
winning strategy, 90
Karp’s Theorem, 9
Kleene–Spector Theorem, 79
Knaster, B., 153
Knaster–Tarski Theorem, 61
Kolaitis, Ph., 185, 246
Kreutzer, S., 175
Kripke structure, 157
Lω
∞ω, 87
Lω
ω1ω, 7
Lk
∞ω, 87
Lk
ω1ω, 7
L∞ω, 9, 86
Lω1ω, 3
Ladner’s Theorem, 347, 352
least ﬁxed point, 60, 153
least ﬁxed-point logic, 65, 155, 355,
356
Levin, L., 142
LFP, 65, 155, 355, 356
LFP1, 66
local consistency, 357
local deﬁnability, 30
logic
capturing a complexity class, 14, 138,
144
deterministic transitive closure, 151
eﬀectively capturing a complexity
class, 17, 204
existential ﬁxed-point, 182
existential inﬁnitary, 107
existential second-order, 31, 139, 213
ﬁxed-point with counting, 188
inﬁnitary, 86, 356
inﬂationary ﬁxed-point, 174
least ﬁxed-point, 65, 155
monadic second-order, 31, 145
partial ﬁxed-point, 84, 177
propositional modal, 135, 158
second-order, 143
second-order Horn, 145
second-order Krom, 149
transitive closure, 151

Index
435
universal second-order, 31
with counting, 187
Luosto, K., 246
Matijasevich, Y., 215
Meer, K., 219
metaﬁnite structure, 210
MIC, 177
ML, 135, 158
MMSNP, 351
modal
μ-calculus, 158
depth of formula, 382
iteration calculus, 177
language, 373
propositional logic, 135, 158
system, 373
model
embedded ﬁnite, 261
saturated, 289
with ﬁnite cover property, 291
with isolation property, 292
with PFH, 290
model checking
for ﬁrst-order logic, 134
model checking
for μ-calculus, 159
for ML, 135
model class, 127, 144
model property
bounded, 383
loose, 416
polysize, 405
tree, 21, 381
model-checking game, 128
model-checking problem, 13, 127
monadic Datalog, 354, 355
monadic second-order logic, 31, 145
monotone monadic SNP without
inequality, 351
mosaic, 399, 419
linked set of, 419
Moschovakis, Y., 175
MSO, 31, 145
μ-calculus, 158
multidimensional, 201
natural-active collapse, 268
and o-minimality, 277
natural-generic collapse, 269
near-unanimity function, 354
neighborhood, 45
network, 401, 421
Node Avoiding Path query, 77
Non-2-Colorability, 353
o-minimal structure, 276
examples of, 276
Odd Path query, 72
operator, 60
closure ordinal of, 61
ﬁnite stage of, 60
inductive, 154
inﬂationary, 174
monotone, 60, 153
relational, 153
stage of, 61
Ord(τ), 136
order invariance, 137, 203
order, deﬁnable, 193
ordered directed graph, 28
ordered structure, 136
Otto, M., 188, 192, 203
packed
fragment, 414
set, 414
Papadimitriou, C., 183
parameter, 155
Parametrized Complexity Theory, 365
parity game, 160
unfolding of, 163
partial ﬁxed point, 83
partial ﬁxed-point logic, 84, 177
partial isomorphism, 28
partially isomorphic, 9
k-, 9
path consistency, 362
Path Systems query, 68, 75
pebble game, 356
PFH, 290
PFP, 84, 177
PH (Polynomial Hierarchy), 248
Planarity query, 33, 48
play, 129
point term, 211
polymorphism, 349
polynomial hierarchy, 143, 248

436
Index
positional strategy, 129, 160
preservation theorem
2-invariant, 21
bisimulation, 21
existential, 21
guarded bisimulation, 22
homomorphism, 22
pseudo-ﬁnite
homogeneity, 290
set, 289
quantiﬁcation, active-domain, 262
quantiﬁer elimination, 264
and collapse, 276
for Presburger arithmetic, 276
over the reals, 264
quantiﬁer rank, 36, 133
query, 29
Boolean, 2, 29
conjunctive, 259
generic, 267
complexity bounds for, 300
k-ary, 29
L-deﬁnable, 3, 30
order-generic, 267
preserved under homomorphisms,
76
safe, 308
and Dichotomy Theorem, 321
and range-restriction, 312
capturing of, 312, 313
in constraint query languages, 316
in FO + Lin and FO + Poly, 313
safety
and outputs of queries, 321
decidability of, 308
deciding in constraint query
languages, 319
translation, 309
topological, 303
totally-generic, 267
query evaluation, 127
R, 264
Rlin, 264
Rabin, M., 231
Rado, R., 242
Ramsey
property, 270
in ordered structures, 271
Theorem, 270
random graph, 298
and collapse to MSO, 298
reachability, 149
recursively indexable, 204
regular languages, 145
relational algebra, 259
relational join, 344
R´enyi, A., 232, 234
restricted quantiﬁer collapse, 289
Rigidity query, 32, 48
rule, 74
body of, 74
head of, 74
S52, 392
safe
query, 308
translation, 309
existence of, 311
nonexistence of, 309
SAT, 142
satisﬁability, 127
for propositional Horn formulae, 131
for propositional logic, 142
Schaefer’s Dichotomy Theorem, 12,
348
schema, 261
second-order logic, 143
existential, 31, 139, 213
Horn, 145
Krom, 149
monadic, 31, 145
over embedded ﬁnite models, 327
Selman, A., 143
semantics
active-domain, 262
natural, 262
semialgebraic set, 264
semilinear set, 264
set
deﬁnable, 264
pseudo-ﬁnite, 289
semialgebraic, 264
semilinear, 264
set function, 354, 355

Index
437
Shelah, S., 175, 235, 249, 251
Shub, M., 216
Σ1
1-HORN, 145
σ-structure, 28
ﬁnite, 28
simultaneous induction, 171, 178
Smale, S., 216
SNP, 350
monotone monadic, without
inequality, 351
SO-HORN, 145, 157
SO-KROM, 149
spectrum, 138, 244
categorical, 143
generalized, 139, 150
metaﬁnite, 213
stable colouring, 189
stage, 61, 154
stage comparison, 175
queries, 80
theorem, 81
standard translation, 380, 415
star graph, 117
strategy, 129
positional, 129, 160
winning, 129
strong k-consistency, 359
establishing, 360
structure
o-minimal, 276
and uniform bounds, 280
examples of, 276
of ﬁnite VC dimension, 287
substructure, 28
generated by, 28
system
of formulas, 71
of operators, 70
Tardos, G., 249
Tarski, A., 153
TC, 151
template, 346
theory, 13, 127
threshold function, 232
tiling problems, 390
topological query, 303
Tractability-Classiﬁcation problem, 346,
348, 349
Trakhtenbrot, B., 145
transition system, 158
transitive closure, 15, 151
transitive closure logic, 151
deterministic, 151
Transitive Closure query, 29, 67, 75
tree decomposition, 362
treewidth, 362
type, 289
(m, r)-type, 39
(r, r)-type, 39
d-type, 46
undirected graph, 2, 28
unfolding lemma, 164
Uniform Bounds Theorem, 280
uniform deﬁnability, 30
universal second-order logic, 31
universe, 28
unraveling, 21, 381
until operator, 397
USO, 31
Vardi, M.Y., 157, 178
variable-conﬁned logics, 363
VC dimension, 287
and natural-generic collapse, 288
and restricted quantiﬁer collapse, 296
Vianu, V., 178
vocabulary, 28
weight term, 211
well-founded, 156
Well-Foundedness query, 32
width, 133
Winkler, P., 241
winning condition
positional, 128
winning region, 129, 160
winning strategy, 129
witness, 241, 242
word structure, 137
zero–one law (see also 0–1 law), 233

Monographs in Theoretical Computer Science • An EATCS Series
K. Jensen
Coloured Petri Nets
Basic Concepts, Analysis Methods
and Practical Use, Vol. 1
2nd ed.
K. Jensen
Coloured Petri Nets
Basic Concepts, Analysis Methods
and Practical Use, Vol. 2
K. Jensen
Coloured Petri Nets
Basic Concepts, Analysis Methods
and Practical Use, Vol. 3
A. Nait Abdallah
The Logic of Partial Information
Z. Fülöp, H. Vogler
Syntax-Directed Semantics
Formal Models Based
on Tree Transducers
A. de Luca, S. Varricchio
Finiteness and Regularity
in Semigroups and Formal Languages
E. Best, R. Devillers, M. Koutny
Petri Net Algebra
S.P. Demri, E.S. Orlowska
Incomplete Information:
Structure, Inference, Complexity
J.C.M. Baeten, C.A. Middelburg
Process Algebra with Timing
L.A. Hemaspaandra, L. Torenvliet
Theory of Semi-Feasible Algorithms
E. Fink, D. Wood
Restricted-Orientation Convexity
Zhou Chaochen, M.R. Hansen
Duration Calculus
A Formal Approach to Real-Time
Systems
M. Große-Rhode
Semantic Integration
of Heterogeneous Software
Speciﬁcations
H. Ehrig, K. Ehrig, U. Prange,
G. Taentzer
Fundamentals of Algebraic
Graph Transformation
W. Michiels, E. Aarts, J. Korst
Theoretical Aspects of Local Search

Texts in Theoretical Computer Science • An EATCS Series
K. Weihrauch
Computable Analysis
An Introduction
J. Hromkoviˇc
Algorithmics for Hard Problems
Introduction to Combinatorial
Optimization, Randomization,
Approximation, and Heuristics
2nd ed.
S. Jukna
Extremal Combinatorics
With Applications
in Computer Science
P. Clote, E. Kranakis
Boolean Functions
and Computation Models
L.A. Hemaspaandra, M. Ogihara
The Complexity Theory Companion
C.S. Calude
Information and Randomness
An Algorithmic Perspective
2nd ed.
J. Hromkoviˇc
Theoretical Computer Science
Introduction to Automata,
Computability, Complexity,
Algorithmics, Randomization,
Communication and Cryptography
K. Schneider
Veriﬁcation of Reactive Systems
Formal Methods and Algorithms
S. Ronchi Della Rocca, L. Paolini
The Parametric Lambda Calculus
A Metamodel for Computation
Y. Bertot, P. Castéran
Interactive Theorem Proving
and Program Development
Coq’Art: The Calculus
of Inductive Constructions
L. Libkin
Elements of Finite Model Theory
M. Hutter
Universal Artiﬁcial Intelligence
Sequential Decisions
Based on Algorithmic Probability
G. P˘aun, G. Rozenberg, A. Salomaa
DNA Computing
New Computing Paradigms
2nd corr. printing
W. Kluge
Abstract Computing Machines
A Lambda Calculus Perspective
J. Hromkoviˇc
Design and Analysis of Randomized
Algorithms
Introduction to Design Paradigms
J. Hromkoviˇc
Dissemination of Information
in Communication Networks
Broadcasting, Gossiping, Leader
Election, and Fault Tolerance
R. Kurki-Suonio
A Practical Theory of Reactive
Systems
Incremental Modeling of Dynamic
Behaviors
F. Drewes
Grammatical Picture Generation
A Tree-Based Approach
J. Flum, M. Grohe
Parameterized Complexity Theory
D. Bjørner
Software Engineering 1
Abstraction and Modelling
D. Bjørner
Software Engineering 2
Speciﬁcation of Systems and
Languages
D. Bjørner
Software Engineering 3
Domains, Requirements, and
Software Design
E. Grädel et al.
Finite Model Theory and
Its Applications

