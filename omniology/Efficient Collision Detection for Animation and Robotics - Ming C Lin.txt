Ecien
t
Collisi
on
Detection
for
Animation
and
Rob
otics
Ming
C.
Lin
Departmen
t
of
Electrical
Engineering
and
Computer
Science
Univ
ersit
y
of
California,
Berk
eley
Berk
eley
,
CA,

Ecien
t
Collisi
on
Detection
for
Animation
and
Rob
otics
b
y
Ming
Chieh
Lin
B.S.
(Univ
ersit
y
of
California
at
Berk
eley)
	
M.S.
(Univ
ersit
y
of
California
at
Berk
eley)
		
A
dissertation
submitted
in
partial
satisfaction
of
the
requiremen
ts
for
the
degree
of
Do
ctor
of
Philosoph
y
in
Engineering
-
Electrical
Engineering
and
Computer
Sciences
in
the
GRADUA
TE
DIVISION
of
the
UNIVERSITY
of
CALIF
ORNIA
at
BERKELEY
Committee
in
c
harge:
Professor
John
F.
Cann
y
,
Chair
Professor
Ronald
F
earing
Professor
Andrew
P
ac
k
ard
		

Ecien
t
Collisi
on
Detection
for
Animation
and
Rob
otics
Cop
yrigh
t
c

		
b
y
Ming
Chieh
Lin

i
Abstract
Ecient
Col
lision
Dete
ction
for
A
nimation
and
R
ob
otics
b
y
Ming
Chieh
Lin
Do
ctor
of
Philosoph
y
in
Electrical
Engineering
and
Computer
Science
Univ
ersit
y
of
California
at
Berk
eley
Professor
John
F.
Cann
y
,
Chair
W
e
presen
t
ecien
t
algorithms
for
collision
detection
and
con
tact
determina-
tion
b
et
w
een
geometric
mo
dels,
describ
ed
b
y
linear
or
curv
ed
b
oundaries,
undergoing
rigid
motion.
The
heart
of
our
collision
detection
algorithm
is
a
simple
and
fast
incremen
tal
metho
d
to
compute
the
distance
b
et
w
een
t
w
o
con
v
ex
p
olyhedra.
It
uti-
lizes
con
v
exit
y
to
establish
some
lo
cal
applicabilit
y
criteria
for
v
erifying
the
closest
features.
A
prepro
cessing
pro
cedure
is
used
to
sub
divide
eac
h
feature's
neigh
b
oring
features
to
a
constan
t
size
and
th
us
guaran
tee
exp
ected
constan
t
running
time
for
eac
h
test.
The
exp
ected
constan
t
time
p
erformance
is
an
attribute
from
exploiting
the
geometric
coherence
and
lo
calit
y
.
Let
n
b
e
the
total
n
um
b
er
of
features,
the
exp
ected
run
time
is
b
et
w
een
O
(
p
n)
and
O
(n)
dep
ending
on
the
shap
e,
if
no
sp
ecial
initial-
ization
is
done.
This
tec
hnique
can
b
e
used
for
dynamic
collision
detection,
planning
in
three-dimensional
space,
ph
ysical
sim
ulation,
and
other
rob
otics
problems.
The
set
of
mo
dels
w
e
consider
includes
p
olyhedra
and
ob
jects
with
surfaces
describ
ed
b
y
rational
spline
patc
hes
or
piecewise
algebraic
functions.
W
e
use
the
exp
ected
constan
t
time
distance
computation
algorithm
for
collision
detection
b
e-

ii
t
w
een
con
v
ex
p
olyhedral
ob
jects
and
extend
it
using
a
hierarc
hical
represen
tation
to
distance
measuremen
t
b
et
w
een
non-con
v
ex
p
olytop
es.
Next,
w
e
use
global
algebraic
metho
ds
for
solving
p
olynomial
equations
and
the
hierarc
hical
description
to
devise
ecien
t
algorithms
for
arbitrary
curv
ed
ob
jects.
W
e
also
describ
e
t
w
o
dieren
t
approac
hes
to
reduce
the
frequency
of
colli-
sion
detection
from
0
@
N


A
pairwise
comparisons
in
an
en
vironmen
t
with
n
mo
ving
ob
jects.
One
of
them
is
to
use
a
priorit
y
queue
sorted
b
y
a
lo
w
er
b
ound
on
time
to
collision;
the
other
uses
an
o
v
erlap
test
on
b
ounding
b
o
xes.
Finally
,
w
e
presen
t
an
opp
ortunistic
global
path
planner
algorithm
whic
h
uses
the
incremen
tal
distance
computation
algorithm
to
trace
out
a
one-dimensional
sk
eleton
for
the
purp
ose
of
rob
ot
motion
planning.
The
p
erformance
of
the
distance
computation
and
collision
detection
algo-
rithms
attests
their
promise
for
real-time
dynamic
sim
ulations
as
w
ell
as
applications
in
a
computer
generated
virtual
en
vironmen
t.
Appro
v
ed:
John
F.
Cann
y

iii
Ac
kno
wledgemen
ts
The
successful
completion
of
this
thesis
is
the
result
of
the
help,
co
op-
eration,
faith
and
supp
ort
of
man
y
p
eople.
First
of
all,
I
w
ould
lik
e
to
thank
Professor
John
Cann
y
for
the
in-
sigh
tful
discussions
w
e
had,
his
guidance
during
m
y
graduate
studies
at
Berk
eley
,
his
patience
and
supp
ort
through
some
of
the
w
orst
times
in
m
y
life.
Some
of
the
results
in
this
thesis
w
ould
not
ha
v
e
b
een
p
ossible
without
his
suggestions
and
feedbac
ks.
I
am
also
grateful
to
all
m
y
committee
mem
b
ers
(Professor
R.
F
ear-
ing,
A.
P
ac
k
ard,
and
J.
Malik),
esp
ecailly
Professor
Ronald
F
earing
and
Andrew
P
ac
k
ard
for
carefully
pro
ofreading
m
y
thesis
and
pro
viding
con-
structiv
e
criticism.
I
w
ould
lik
e
to
extend
m
y
sincere
appreciation
to
Professor
Dinesh
Mano
c
ha
for
his
c
heerful
supp
ort
and
collab
oration,
and
for
sharing
his
in
v
aluable
exp
erience
in
\job
h
un
ting".
P
arts
of
Chapter

and
a
section
of
Chapter

in
this
thesis
are
the
result
of
our
join
t
w
ork.
Sp
ecial
thanks
are
due
to
Brian
Mirtic
h
for
his
help
in
re-implem
e
n
ting
the
distance
algorithm
(describ
ed
in
Chapter
)
in
ANSI
C,
thorough
testing,
bug
rep
orting,
and
his
input
to
the
robustness
of
the
distance
computation
for
con
v
ex
p
olyhedra.
I
wish
to
ac
kno
wledge
Professor
Da
vid
Bara
at
Carnegie
Mellon
Uni-
v
ersit
y
for
the
discussion
w
e
had
on
one-dimensional
sw
eeping
metho
d.
I
w
ould
also
lik
e
to
thank
Professor
Raimond
Seidel
and
Professor
Herb
ert
Edelsbrunner
for
commen
ts
on
rectangle
in
tersection
and
con
v
ex
decom-
p
osition
algorithms;
and
to
Professor
George
V
anecek
of
Purdue
Univ
er-
sit
y
and
Professor
James
Cremer
for
discussions
on
con
tact
analysis
and
dynamics.
I
also
appreciate
the
c
hance
to
con
v
erse
ab
out
our
w
ork
through
elec-
tronic
mail
corresp
ondence,
telephone
con
v
ersation,
and
in-p
erson
in
ter-
action
with
Dr.
Da
vid
Strip
e
in
Sandia
National
Lab,
Ric
hard
Mastro
and
Karel
Zik
an
in
Bo
eing.
These
discussions
help
ed
me
disco
v
er
some
of
the
p
ossible
researc
h
problems
I
need
to
address
as
w
ell
as
future
application
areas
for
our
collision
detection
algorithms.

iv
I
w
ould
also
lik
e
to
thank
all
m
y
long
time
college
pals:
Yv
onne
and
Rob
ert
Hou,
Caroline
and
Gani
Jusuf,
Alfred
Y
eung,
Leslie
Field,
Dev
Chen
and
Gautam
Doshi.
Thank
y
ou
all
for
the
last
six,
sev
en
y
ears
of
friendship
and
supp
ort,
esp
ecially
when
I
w
as
at
Den
v
er.
Berk
eley
can
nev
er
b
e
the
same
wthout
y
ou!!!
And,
I
am
not
forgetting
y
ou
all:
Isab
ell
Mazon,
the
\Cann
y
Gang",
and
all
m
y
(0+)
ocemates
and
labmates
for
all
the
in
tellectual
con
v
er-
sations
and
casual
c
hatting.
Thanks
for
the
#
Cory
Hall
and
Rob
otics
Lab
memories,
as
w
ell
as
the
man
y
fun
hours
w
e
shared
together.
I
also
wish
to
express
m
y
gratitude
to
Dr.
Colb
ert
for
her
gen
uine
care,
00%
atten
tiv
eness,
and
buo
y
an
t
spirit.
Her
viv
acit
y
w
as
con
tagious.
I
could
not
ha
v
e
made
it
without
her!
Last
but
not
least,
I
w
ould
lik
e
to
thank
m
y
family
,
who
are
alw
a
ys
supp
ortiv
e,
caring,
and
mainly
resp
onsible
for
m
y
enormous
amoun
t
of
h
uge
phone
bills.
I
ha
v
e
gone
through
some
traumatic
exp
eriences
during
m
y
y
ears
at
CAL,
but
they
ha
v
e
b
een
there
to
catc
h
me
when
I
fell,
to
stand
b
y
m
y
side
when
I
w
as
do
wn,
and
w
ere
AL
W
A
YS
there
for
me
no
matter
what
happ
ened.
I
w
ould
lik
e
to
ac
kno
wledge
them
for
b
eing
m
y
\moral
bac
kb
one",
esp
ecially
to
Dad
and
Mom,
who
taugh
t
me
to
b
e
strong
in
the
face
of
all
adv
ersities.
Ming
C.
Lin

v
Con
ten
ts
List
of
Figures
viii

In
tro
duction

.
Previous
W
ork
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Ov
erview
of
the
Thesis
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

Bac
kground

.
Basic
Concenpts
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Mo
del
Represen
tations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Data
Structures
and
Basic
T
erminology
:
:
:
:
:
:
:
:
:
:
:
:
:

..
V
oronoi
Diagram
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
V
oronoi
Region
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Ob
ject
Mo
deling
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Motion
Description
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
System
of
Algebraic
Equations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

An
Incremen
tal
Distance
Computation
Algorithm

.
Closest
F
eature
P
air
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Applicabilit
y
Criteria
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
P
oin
t-V
ertex
Applicabilit
y
Criterion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
P
oin
t-Edge
Applicabilit
y
Criterion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
P
oin
t-F
ace
Applicabilit
y
Criterion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Sub
division
Pro
cedure
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Impleme
n
tation
Issues
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
The
Algorithm
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Description
of
the
Ov
erall
Approac
h
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Geometric
Subroutines
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Analysis
of
the
Algorithm
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Exp
ected
Running
Time
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Pro
of
of
Completeness
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Numerical
Exp
erimen
ts
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


vi
.
Dynamic
Collision
Detection
for
Con
v
ex
P
olyhedra
:
:
:
:
:
:
:
:
:
:


Extension
to
Non-Con
v
ex
Ob
jects
and
Curv
ed
Ob
jects

.
Collision
Detection
for
Non-con
v
ex
Ob
jects
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Sub-P
art
Hierarc
hical
T
ree
Represen
tation
:
:
:
:
:
:
:
:
:
:
:

..
Detection
for
Non-Con
v
ex
P
olyhedra
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Collision
Detection
for
Curv
ed
Ob
jects
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Collision
Detection
and
Surface
In
tersection
:
:
:
:
:
:
:
:
:
:

..
Closest
F
eatures
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Con
tact
F
orm
ulation
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Coherence
for
Collision
Detection
b
et
w
een
Curv
ed
Ob
jects
:
:
:
:
:
:

..
Appro
ximating
Curv
ed
Ob
jects
b
y
P
olyhedral
Mo
dels
:
:
:
:
:

..
Con
v
ex
Curv
ed
Surfaces
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Non-Con
v
ex
Curv
ed
Ob
jects
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


In
terference
T
ests
for
Multiple
Ob
jects

.
Sc
heduling
Sc
heme
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Bounding
Time
to
Collision
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
The
Ov
erall
Approac
h
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Sw
eep
&
Sort
and
In
terv
al
T
ree
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Using
Bounding
V
olumes
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
One-Dimensional
Sort
and
Sw
eep
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
In
terv
al
T
ree
for
D
In
tersection
T
ests
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Other
Approac
hes
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
BSP-T
rees
and
Octrees
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Uniform
Spatial
Sub
division
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Applications
in
Dynamic
Sim
ulation
and
Virtual
En
vironmen
t
:
:
:
:


An
Opp
ortunistic
Global
P
ath
Planner
	
.
Bac
kground
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	0
.
A
Maxim
um
Clearance
Roadmap
Algorithm
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
..
Denitions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
..
The
General
Roadmap
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Dening
the
Distance
F
unction
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
		
.
Algorithm
Details
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
00
..
F
reew
a
ys
and
Bridges
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
..
Tw
o-Dimensional
W
orkspace
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
..
Three-Dimensional
W
orkspace
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
..
P
ath
Optimization
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Pro
of
of
Completeness
for
an
Opp
ortunistic
Global
P
ath
Planner
:
:
0
.
Complexit
y
Bound
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Geometric
Relations
b
et
w
een
Critical
P
oin
ts
and
Con
tact
Constrain
ts


vii
.
Brief
Discussion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


Conclusions

.
Summary
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
F
uture
W
ork
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
..
Ov
erlap
Detection
for
Con
v
ex
P
olyhedra
:
:
:
:
:
:
:
:
:
:
:
:
0
..
In
tersection
T
est
for
Conca
v
e
Ob
jects
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Collision
Detection
for
Deformable
ob
jects
:
:
:
:
:
:
:
:
:
:
:

..
Collision
Resp
onse
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

Bibliograph
y

A
Calculating
the
Nearest
P
oin
ts
b
et
w
een
Tw
o
F
eatures

B
Pseudo
Co
de
of
the
Distance
Algorithm
	

viii
List
of
Figures
.
A
winged
edge
represen
tation
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Applicabilit
y
T
est:
(F
a
;
V
b
)
!
(E
a
;
V
b
)
since
V
b
fails
the
applicabilit
y
test
imp
osed
b
y
the
constrain
t
plane
C
P
.
R

and
R

are
the
V
oronoi
regions
of
F
a
and
E
a
resp
ectiv
ely
.
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
P
oin
t-V
ertex
Applicabilit
y
Criterion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
P
oin
t-Edge
Applicabilit
y
Criterion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
V
ertex-F
ace
Applicabilit
y
Criterion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Prepro
cessing
of
a
v
ertex's
conical
applicabilit
y
region
and
a
face's
cylindrical
applicabilit
y
region
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
An
example
of
Flared
V
oronoi
Cells:
C
P
F
corresp
onds
to
the
ared
constrain
t
place
C
P
of
a
face
and
C
P
E
corresp
onds
to
the
ared
con-
strain
t
plane
C
P
of
an
edge.
R
0

and
R
0

are
the
ar
e
d
V
oronoi
regions
of
unp
erturb
ed
R

and
R

.
Note
that
they
o
v
erlap
eac
h
other.
:
:
:
:

.
(a)
An
o
v
erhead
view
of
an
edge
lying
ab
o
v
e
a
face
(b)
A
side
view
of
the
face
out
w
ard
normal
b
ounded
b
y
the
t
w
o
out
w
ard
normals
of
the
edge's
left
and
righ
t
faces.
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
A
Side
View
for
P
oin
t-V
ertex
Applicabilit
y
Criterion
Pro
of
:
:
:
:
:
:

.	
An
Ov
erhead
View
for
P
oin
t-Edge
Applicabilit
y
Criterion
Pro
of
:
:
:

.0
A
Side
View
for
P
oin
t-Edge
Applicabilit
y
Criterion
Pro
of
:
:
:
:
:
:
:

.
A
Side
View
for
P
oin
t-F
ace
Applicabilit
y
Criterion
Pro
of
:
:
:
:
:
:
:

.
Computation
time
vs.
total
no.
of
v
ertices
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
P
olytop
es
Used
in
Example
Computations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
An
example
of
sub-part
hierarc
h
y
tree
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
An
example
for
non-con
v
ex
ob
jects
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
T
angen
tial
in
tersection
and
b
oundary
in
tersection
b
et
w
een
t
w
o
B

ezier
surfaces
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Closest
features
b
et
w
een
t
w
o
dieren
t
orien
tations
of
a
cylinder
:
:
:

.
Hierarc
hical
represen
tation
of
a
torus
comp
osed
of
B

ezier
surfaces
:
:


ix
.
A
sc
hematized
-d
conguration
space
and
the
partition
of
free
space
in
to
x

-c
hannels.
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Tw
o
c
hannels
C

and
C

joining
the
c
hannel
C

,
and
a
bridge
curv
e
in
C

.
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
A
pictorial
example
of
an
inection
p
oin
t
in
C
S

R
vs.
its
view
in
R

y
at
the
slice
x
=
x
0
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
An
example
of
the
algorithm
in
the
-d
w
orkspace
:
:
:
:
:
:
:
:
:
:
:
0


Chapter

In
tro
duction
The
problem
of
collision
detection
or
con
tact
determination
b
et
w
een
t
w
o
or
more
ob
jects
is
fundamen
tal
to
computer
animation,
ph
ysical
based
mo
deling,
molecular
mo
deling,
computer
sim
ulated
en
vironmen
ts
(e.g.
virtual
en
vironmen
ts)
and
rob
ot
motion
planning
as
w
ell
[,

,

,
0
,

,

,

,
	
,
0
,

,

,

].
(De-
p
ending
on
the
con
ten
t
of
applications,
it
is
also
called
with
man
y
dieren
t
names,
suc
h
as
in
terference
detection,
clash
detection,
in
tersection
tests,
etc.)
In
rob
otics,
an
essen
tial
comp
onen
t
of
rob
ot
motion
planning
and
collision
a
v
oidance
is
a
geo-
metric
reasoning
system
whic
h
can
detect
p
oten
tial
con
tacts
and
determine
the
exact
collision
p
oin
ts
b
et
w
een
the
rob
ot
manipulator
and
the
obstacles
in
the
w
orkspace.
Although
it
do
esn't
pro
vide
a
complete
solution
to
the
path
planning
and
obstacle
a
v
oidance
problems,
it
often
serv
es
as
a
go
o
d
indicator
to
steer
the
rob
ot
a
w
a
y
from
its
surrounding
obstacles
b
efore
an
actual
collision
o
ccurs.
Similarly
,
in
computer
animation,
in
teractions
among
ob
jects
are
sim
ulated
b
y
mo
deling
the
con
tact
constrain
ts
and
impact
dynamics.
Since
prompt
recognition
of
p
ossible
impacts
is
a
k
ey
to
successful
resp
onse
to
collisions
in
a
timely
fashion,
a
simple
y
et
ecien
t
algorithm
for
collision
detection
is
imp
ortan
t
for
fast
and
realistic
animation
and
sim
ulation
of
mo
ving
ob
jects.
The
in
terference
detection
problem
has
b
een
considered
one
of
the
ma
jor
b
ottlenec
ks
in
ac
heiving
real-time
dynamic
sim
ulation.
Collision
detection
is
also
an
in
tegral
part
of
man
y
new,
exciting
tec
hnolog-


ical
dev
elopmen
ts.
Virtual
protot
yping
systems
create
electronic
represen
tations
of
mec
hanical
parts,
to
ols,
and
mac
hines,
whic
h
need
to
b
e
tested
for
in
terconnectivit
y
,
functionalit
y
,
and
reliabilit
y
.
The
goal
of
these
systems
is
to
sa
v
e
pro
cessing
and
man
ufacturing
costs
b
y
a
v
oiding
the
actual
ph
ysical
man
ufacture
of
protot
yp
es.
This
is
similar
to
the
goal
of
CAD
to
ols
for
VLSI,
except
that
virtual
protot
yping
is
more
demanding.
It
requires
a
complete
test
en
vironmen
t
con
taining
h
undreds
of
parts,
whose
complex
in
teractions
are
based
on
ph
ysics
and
geometry
.
Collision
detection
is
vital
comp
onen
t
of
suc
h
en
vironmen
ts.
Another
area
of
rising
in
terests
is
syn
thetic
en
vironmen
t,
commonly
kno
wn
as
\virtual
realit
y"
(whic
h
is
a
comprehensiv
e
term
promoting
m
uc
h
h
yp
es
and
hop
es).
In
a
syn
thetic
en
vironmen
t,
virtual
ob
jects
(most
of
them
stationary)
are
created
and
placed
in
the
w
orld.
A
h
uman
participan
t
ma
y
wish
to
mo
v
e
the
virtual
ob
jects
or
alter
the
scene.
Suc
h
a
simple
action
as
touc
hing
and
grasping
in
v
olv
es
geometric
con
tacts.
A
collision
detection
algorithm
m
ust
b
e
implem
en
te
d
to
ac
hiev
e
an
y
degree
of
realism
for
suc
h
a
basic
motion.
Ho
w
ev
er,
often
there
are
h
undreds,
ev
en
thousands
of
ob
jects
in
the
virtual
w
orld,
a
naiv
e
algorithm
w
ould
probably
tak
e
hours
just
to
c
hec
k
for
p
ossible
in
terference
whenev
er
a
h
uman
participan
t
mo
v
es.
This
is
not
acceptable
for
an
in
teractiv
e
virtual
en
vironmen
t.
Therefore,
a
simple
y
et
ecien
t
collision
detection
algorithm
is
almost
indisp
ensable
to
an
in
teractiv
e,
realistic
virtual
en
vironmen
t.
The
ob
jectiv
e
of
collision
detection
is
to
automatically
rep
ort
a
geometric
con
tact
when
it
is
ab
out
to
o
ccur
or
has
actually
o
ccurred.
It
is
t
ypically
used
in
order
to
sim
ulate
the
ph
ysics
of
mo
ving
ob
jects,
or
to
pro
vide
the
geometric
information
whic
h
is
needed
in
path
planning
for
rob
ots.
The
static
collision
detection
problem
is
often
studied
and
then
later
extended
to
a
dynamic
en
vironmen
t.
Ho
w
ev
er,
the
c
hoice
of
step
size
can
easily
aect
the
outcome
of
the
dynamic
algorithms.
If
the
p
osition
and
orien
tation
of
the
ob
jects
is
kno
wn
in
adv
ance,
the
collision
detection
can
b
e
solv
ed
as
a
function
of
time.
A
related
problem
to
collision
detection
is
determining
the
minim
um
Eu-
clidean
distance
b
et
w
een
t
w
o
ob
jects.
The
Euclidean
distance
b
et
w
een
t
w
o
ob
jects
is
a
natural
measuremen
t
of
pr
oximity
for
reasoning
ab
out
their
spatial
relationship.


A
dynamic
solution
to
determining
the
minim
um
separation
b
et
w
een
t
w
o
mo
ving
ob
jects
can
b
e
a
useful
to
ol
in
solving
the
in
terference
detection
problem,
since
the
distance
measuremen
t
pro
vides
all
the
necessary
lo
cal
geometric
information
and
the
solution
to
the
pro
ximit
y
question
b
et
w
een
t
w
o
ob
jects.
Ho
w
ev
er,
it
is
not
necessary
to
determine
the
exact
amoun
t
of
separation
or
p
enetration
b
et
w
een
t
w
o
ob
jects
to
decide
whether
a
collision
has
tak
en
place
or
not.
That
is,
determining
the
minim
um
separation
or
maxim
um
p
enetration
mak
es
a
m
uc
h
stronger
statemen
t
than
what
is
necessary
to
answ
er
the
collision
detection
problem.
But,
this
additional
kno
wl-
edge
can
b
e
extremely
useful
in
computing
the
in
teraction
forces
and
other
p
enalt
y
functions
in
motion
planning.
Collision
detection
is
usually
coupled
with
an
appropriate
resp
onse
to
the
collision.
The
collision
resp
onse
is
generally
application
dep
enden
t
and
man
y
algo-
rithms
ha
v
e
b
een
prop
osed
for
dieren
t
en
vironmen
ts
lik
e
motion
con
trol
in
anima-
tion
b
y
Mo
ore
and
Wilhelm
[],
ph
ysical
sim
ulations
b
y
Bara,
Hahn,
P
en
tland
and
Williams
[,
,
0]
or
molecular
mo
deling
b
y
T
urk
[].
Since
simplicit
y
and
ease
of
implem
en
tati
on
is
considered
as
one
of
the
imp
ortan
t
factors
for
an
y
practical
algo-
rithm
in
the
computer
graphics
comm
unit
y
,
most
collision
detection
algorithms
used
for
computer
animation
are
rather
simple
but
not
necessary
ecien
t.
The
simplest
algorithms
for
collision
detection
are
based
up
on
using
b
ounding
v
olumes
and
spatial
decomp
osition
tec
hniques.
T
ypical
examples
of
b
ounding
v
olumes
include
cub
oids,
spheres,
o
ctrees
etc.,
and
they
are
c
hosen
due
to
the
simplicit
y
of
nding
collisions
b
et
w
een
t
w
o
suc
h
v
olumes.
Once
the
t
w
o
ob
jects
are
in
the
vicinit
y
of
eac
h
other,
spatial
decomp
osition
tec
hniques
based
on
sub
division
are
used
to
solv
e
the
in
terfer-
ence
problem.
Recursiv
e
sub
division
is
robust
but
computationally
exp
ensiv
e,
and
it
often
requires
substan
tially
more
memory
.
F
urthermore
the
con
v
ergence
to
the
solu-
tion
corresp
onding
to
the
con
tact
p
oin
t
is
linear.
Rep
eating
these
steps
at
eac
h
time
instan
t
mak
es
the
o
v
erall
algorithm
v
ery
slo
w.
The
run
time
impact
of
a
sub
division
based
collision
detection
algorithm
on
the
ph
ysical
sim
ulation
has
b
een
highligh
ted
b
y
Hahn
[].
As
in
terest
in
dynamic
sim
ulations
has
b
een
rising
in
computer
graphics
and
rob
otics,
collision
detection
has
also
receiv
ed
a
great
deal
of
atten
tion.
The
im-


p
ortance
of
collision
detection
extends
to
sev
eral
areas
lik
e
rob
ot
motion
planning,
dynamic
sim
ulation,
virtual
realit
y
applications
and
it
has
b
een
extensiv
ely
studied
in
rob
otics,
computational
geometry
,
and
computer
graphics
for
more
than
a
decade
[,

,

,

,
,

,

,

,
,

,

].
Y
et,
there
is
no
practical,
ecien
t
algo-
rithm
a
v
ailable
y
et
for
general
geometric
mo
dels
to
p
erform
collision
detection
in
real
time.
Recen
tly
,
P
en
tland
has
listed
collision
detection
as
one
of
the
ma
jor
b
ottlenec
ks
to
w
ards
real
time
virtual
en
vironmen
t
sim
ulations
[	
].
In
this
thesis,
w
e
presen
t
an
ecien
t
algorithm
for
collision
detection
b
et
w
een
ob
jects
with
linear
and
curv
ed
b
oundaries,
undergoing
rigid
motion.
No
assumption
is
made
on
the
motion
of
the
ob
ject
to
b
e
expressed
as
a
closed
form
function
of
time.
A
t
eac
h
instan
t,
w
e
only
assume
the
kno
wledge
of
p
osition
and
orien
tation
with
resp
ect
to
a
global
origin.
W
e
rst
dev
elop
a
fast,
incremen
tal
distance
computation
algorithm
whic
h
k
eeps
trac
k
of
a
pair
of
closest
features
b
et
w
een
t
w
o
con
v
ex
p
olyhedra.
The
exp
ected
running
time
of
this
algorithm
is
constan
t.
Next
w
e
will
extend
this
incremen
tal
algorithm
to
non-con
v
ex
ob
jects
b
y
using
sub-part
hierarc
h
y
tree
represen
tation
and
to
curv
ed
ob
jects
b
y
com
bining
lo
cal
and
global
equation
solving
tec
hniques.
In
addition,
t
w
o
metho
ds
are
describ
ed
to
reduce
the
frequency
of
in
terference
detections
b
y
()
a
priorit
y
queue
sorted
b
y
lo
w
er
b
ound
on
time
to
collisions
()
sw
eeping
and
sorting
algorithms
and
a
geometric
data
structure.
Some
examples
for
applications
of
these
algorithms
are
also
briey
men
tioned.
The
p
erformance
of
these
algorithms
sho
ws
great
promise
for
real-time
rob
otics
sim
ulation
and
computer
animation.
.
Previous
W
ork
Collision
detection
and
the
related
problem
of
determining
minim
um
dis-
tance
has
a
long
history
.
It
has
b
een
considered
in
b
oth
static
and
dynamic
(mo
ving
ob
jects)
v
ersions
in
[],
[],
[],
[
],
[],
[],
[	
],
[0],
[],
[
].
One
of
the
earlier
surv
ey
on
\clash
detection"
w
as
presen
ted
b
y
Cameron
[].
He
men
tioned
three
dieren
t
approac
hes
for
dynamic
collision
detection.
One
of
them
is
to
p
erform
static
collision
detection
rep
etitiv
ely
at
eac
h
discrete
time
steps,


but
it
is
p
ossible
to
miss
a
collision
b
et
w
een
time
steps
if
the
step
size
is
to
o
large.
Y
et,
it
w
ould
b
e
a
w
aste
of
computation
eort
if
the
step
size
is
to
o
small.
Another
metho
d
is
to
use
a
space-time
approac
h:
w
orking
directly
in
the
four-dimensional
sets
whic
h
form
the
abstract
mo
des
of
the
motion
shap
es
(sw
ept
v
olumes
in
D
).
Not
only
is
it
dicult
to
visualize,
but
it
is
also
a
c
hallenging
task
to
mo
del
suc
h
sets,
esp
ecially
when
the
motion
is
complex.
The
last
metho
d
is
to
using
sw
eeping
v
olume
to
represen
t
mo
ving
ob
jects
o
v
er
a
p
erio
d
of
time.
This
seems
to
b
e
a
rather
in
tuitiv
e
approac
h,
but
rather
restrictiv
e.
Unless
the
motion
of
the
ob
jects
are
already
kno
wn
in
adv
ance,
it
is
imp
ossible
to
sw
eep
out
the
en
v
elop
e
of
the
mo
ving
ob
jects
and
it
suppresses
the
temp
oral
information.
If
t
w
o
ob
jects
are
b
oth
mo
ving,
the
in
tersection
of
t
w
o
sw
eeping
v
olume
do
es
not
necessarily
indicate
an
actual
\clash"
b
et
w
een
t
w
o
ob
jects.
Lo
cal
prop
erties
ha
v
e
b
een
used
in
the
earlier
motion
planning
algorithms
b
y
Donald,
Lozano-P

erez
and
W
esley
[,

]
when
t
w
o
features
come
in
to
con
tact.
In
[],
Lozano-P

erez
and
W
esley
c
haracterized
the
collision
free
motion
planning
problem
b
y
using
a
p
oin
t
rob
ot
na
vigating
in
the
conguration
space
b
y
gro
wing
the
stationary
obstacles
with
the
size
of
the
rob
ot.
As
long
as
the
p
oin
t
rob
ot
do
es
not
en
ter
a
forbidden
zone,
a
collision
do
es
not
tak
e
place.
A
fact
that
has
often
b
een
o
v
erlo
ok
ed
is
that
collision
dete
ction
for
con
v
ex
p
olyhedra
can
b
e
done
in
linear
time
in
the
w
orst
case
b
y
Sanc
heti
and
Keerthi
[].
The
pro
of
is
b
y
reduction
to
linear
programming.
If
t
w
o
p
oin
t
sets
ha
v
e
disjoin
t
con
v
ex
h
ulls,
then
there
is
a
plane
whic
h
separates
the
t
w
o
sets.
Letting
the
four
parameters
of
the
plane
equations
b
e
v
ariables,
add
a
linear
inequalit
y
for
eac
h
v
ertex
of
p
olyhedron
A
that
sp
ecies
that
the
v
ertex
is
on
one
side
of
the
plane,
and
an
inequalit
y
for
eac
h
v
ertex
of
p
olyhedron
B
that
sp
ecies
that
it
is
on
the
other
side.
Megiddo
and
Dy
ers
w
ork
[0],
[
],
[	]
sho
w
ed
that
linear
programming
is
solv
able
in
linear
time
for
an
y
xed
n
um
b
er
of
v
ariables.
More
recen
t
w
ork
b
y
Seidel
[	]
has
sho
wn
that
linear
time
linear
programming
algorithms
are
quite
practical
for
a
small
n
um
b
er
of
v
ariables.
The
algorithm
of
[	]
has
b
een
implem
en
ted,
and
seems
fast
in
practice.
Using
linear-time
prepro
cessing,
Dobkin
and
Kirkpatric
k
w
ere
able
to
solv
e
the
collision
detection
problem
as
w
ell
as
compute
the
separation
b
et
w
een
t
w
o
con
v
ex


p
olytop
es
in
O
(l
og
jAj

l
og
jB
j)
where
A
and
B
are
p
olyhedra
and
j

j
denotes
the
total
n
um
b
er
of
faces
[].
This
approac
h
uses
a
hierarc
hical
description
of
the
con
v
ex
ob
jects
and
extension
of
their
previous
w
ork
[].
This
is
one
of
the
b
est
kno
wn
theoretical
b
ounds.
The
capabilit
y
of
determining
p
ossible
con
tacts
in
dynamic
domains
is
im-
p
ortan
t
for
computer
animation
of
mo
ving
ob
jects.
W
e
w
ould
lik
e
an
animator
to
p
erform
impact
determination
b
y
itself
without
high
computational
costs
or
m
uc
h
co
ding
eorts.
Some
algorithms
(suc
h
as
Bo
yse's
[]
and
Cann
y's
[])
solv
e
the
problem
in
more
generalit
y
than
is
necessary
for
computer
animation;
while
others
do
not
easily
pro
duce
the
exact
collision
p
oin
ts
and
con
tact
normal
direction
for
col-
lision
resp
onse
[].
In
one
of
the
earlier
animation
pap
ers
addressing
the
issue
of
collision
detection,
Mo
ore
and
Wilhelms
[]
men
tioned
the
metho
d
based
on
the
Cyrus-Bec
k
clipping
algorithm
[],
whic
h
pro
vides
a
simple,
robust
alternativ
e
but
runs
in
O
(n

m

)
time
for
m
p
olyhedra
and
n
v
ertices
p
er
p
olyhedron.
The
metho
d
w
orks
b
y
c
hec
king
whether
a
p
oin
t
lies
inside
a
p
olygon
or
p
olyhedron
b
y
using
a
inner
pro
duct
calculation
test.
First,
all
v
ertices
from
p
olyhedron
B
are
tested
against
p
oly-
hedron
A,
and
then
all
v
ertices
from
A
are
tested
for
inclusion
in
B
.
This
approac
h
along
with
sp
ecial
case
treatmen
ts
is
reasonably
reliable.
But,
the
computation
runs
in
O
(n

)
time
where
n
is
the
n
um
b
er
of
v
ertices
p
er
p
olyhedron.
Hahn
[
]
used
a
hierarc
hical
metho
d
in
v
olving
b
ounding
b
o
xes
for
in
tersec-
tion
tests
whic
h
run
in
O
(n

)
time
for
eac
h
pair
of
p
olyhedra
where
n
is
the
n
um
b
er
of
v
ertices
for
eac
h
p
olyhedron.
The
algorithm
sw
eeps
out
the
v
olume
of
b
ounding
b
o
xes
o
v
er
a
small
time
step
to
nd
the
exact
con
tact
lo
cations.
In
testing
for
in
terference,
it
tak
es
ev
ery
edge
to
c
hec
k
against
eac
h
p
olygon
and
vice
v
ersa.
Its
p
erformance
is
comparable
to
Cyrus-Bec
k
clipping
algorithm.
Our
algorithm
is
a
simple
and
ecien
t
metho
d
whic
h
runs
in
exp
ected
constan
t
time
for
eac
h
pair
of
p
olyhedra,
indep
enden
t
of
the
geometric
complexit
y
of
eac
h
p
olyhedron.
(It
w
ould
only
tak
e
O
(m

)
time
for
m
p
olyhedra
with
an
y
n
um
b
er
of
v
ertices
p
er
p
olyhedron.)
This
pro
vides
a
signican
t
gain
in
sp
eed
for
computer
animation,
esp
ecially
for
p
olyhedra
with
a
large
n
um
b
er
of
v
ertices.
In
applications
in
v
olving
dynamic
sim
ulations
and
ph
ysical
motion,
geomet-


ric
coherence
has
b
een
utilized
to
devise
algorithms
based
on
lo
cal
features
[].
This
has
signican
tly
impro
v
ed
the
p
erformance
of
collision
detection
algorithms
in
dy-
namic
en
vironmen
ts.
Bara
uses
cac
hed
edges
and
faces
to
nd
a
separating
plane
b
et
w
een
t
w
o
con
v
ex
p
olytop
es
[].
Ho
w
ev
er,
Bara
's
assumption
to
cac
he
the
last
\witnesses"
do
es
not
hold
when
relativ
e
displacemen
t
of
ob
jects
b
et
w
een
successiv
e
time
steps
are
large
and
when
closest
features
c
hanges,
it
falls
bac
k
on
a
global
searc
h;
while
our
metho
d
w
orks
fast
ev
en
when
there
are
relativ
ely
large
displacemen
ts
of
ob-
jects
and
c
hanges
in
closest
features.
As
for
curv
ed
ob
jects,
Herzen
and
etc.
[
]
ha
v
e
describ
ed
a
general
al-
gorithm
based
on
time
dep
enden
t
parametric
surfaces.
It
treats
time
as
an
extra
dimension
and
also
assumes
b
ounds
on
deriv
ativ
es.
The
algorithm
uses
sub
division
tec
hnique
in
the
resulting
space
and
can
therefore
b
e
slo
w.
A
similar
metho
d
us-
ing
in
terv
al
arithmetic
and
sub
division
has
b
een
presen
ted
for
collision
detection
b
y
Du
[	
].
Du
has
extended
it
to
dynamic
en
vironmen
ts
as
w
ell.
Ho
w
ev
er,
for
com-
monly
used
spline
patc
hes
computing
and
represen
ting
the
implicit
represen
tations
is
computationally
exp
ensiv
e
as
stated
b
y
Homann
[].
Both
algorithms,
[	,

],
exp
ect
a
closed
form
expression
of
motion
as
a
function
of
time.
In
[0],
P
en
tland
and
Williams
prop
oses
using
implici
t
functions
to
represen
t
shap
e
and
the
prop
ert
y
of
the
\inside-outside"
functions
for
collision
detection.
Besides
its
restriction
to
implicits
only
,
this
algorithm
has
a
dra
wbac
k
in
terms
of
robustness,
as
it
uses
p
oin
t
samples.
A
detailed
explanation
of
these
problems
are
describ
ed
in
[	].
Bara
has
also
pre-
sen
ted
an
algorithm
for
nding
closest
p
oin
ts
b
et
w
een
t
w
o
con
v
ex
closed
ob
jects
only
[].
In
the
related
problem
of
computing
the
minim
um
separation
b
et
w
een
t
w
o
ob
jects,
Gilb
ert
and
his
collab
orators
computed
the
minim
um
distance
b
et
w
een
t
w
o
con
v
ex
ob
jects
with
an
exp
ected
linear
time
algorithm
and
used
it
for
collision
de-
tection.
Our
w
ork
shares
with
[
],
[	
],
and
[]
the
calculation
and
main
tenance
of
closest
p
oin
ts
during
incremen
tal
motion.
But
whereas
[],
[	],
and
[
]
require
exp
ected
linear
time
to
v
erify
the
closest
p
oin
ts,
w
e
use
the
prop
erties
of
con
v
ex
sets
to
reduce
this
c
hec
k
to
constan
t
time.
Cameron
and
Culley
further
discussed
the
problem
of
in
terp
enetration
and


pro
vided
the
in
tersection
measuremen
t
for
the
use
in
a
p
enalt
y
function
for
rob
ot
mo-
tion
planning
[
].
The
classical
non-linear
programming
approac
hes
for
this
problem
are
presen
ted
in
[]
and
[	].
More
recen
tly
,
Sanc
heti
and
Keerthi
[
]
discussed
the
computation
of
pro
ximit
y
b
et
w
een
t
w
o
con
v
ex
p
olytop
es
from
a
complexit
y
view-
p
oin
t,
in
whic
h
the
use
of
quadratic
programming
is
prop
osed
as
an
alternativ
e
to
compute
the
separation
and
detection
problem
b
et
w
een
t
w
o
con
v
ex
ob
jects
in
O
(n)
time
in
a
xed
dimension
d,
where
n
is
the
n
um
b
er
of
v
ertices
of
eac
h
p
olytop
es.
In
fact,
these
tec
hniques
are
used
b
y
researc
hers
Karel
Zik
an
[	],
Ric
hard
Mastro,
etc.
at
the
Bo
eing
Virtual
Realit
y
Researc
h
Lab
oratory
as
a
mean
of
computing
the
distance
b
et
w
een
t
w
o
ob
jects.
Meggido's
result
in
[
]
stated
that
w
e
can
solv
e
the
problem
of
minimi
z-
ing
a
con
v
ex
quadratic
function,
sub
ject
to
linear
constrain
ts
in
R

in
linear
time
b
y
transforming
the
quadratic
programming
using
an
appropriate
ane
transformation
of
R

(found
in
constan
t
time)
to
a
linear
programming
problem.
In
[0],
Megiddo
and
T
amir
ha
v
e
further
sho
wn
that
a
large
class
of
separable
con
v
ex
quadratic
trans-
p
ortation
problems
with
a
xed
n
um
b
er
of
sources
and
separable
con
v
ex
quadratic
programming
with
nonnegativit
y
constrain
ts
and
a
xed
n
um
b
er
of
linear
equalit
y
constrain
ts
can
b
e
solv
ed
in
linear
time.
Belo
w,
w
e
will
presen
t
a
short
description
of
ho
w
w
e
can
reduce
the
distance
computation
problem
using
quadratic
programming
to
a
linear
programming
problem
and
solv
e
it
in
linear
time.
The
con
v
ex
optimization
problem
of
computing
the
distance
b
et
w
een
t
w
o
con
v
ex
p
olyhedra
A
and
B
b
y
quadratic
programming
can
b
e
form
ulated
as
follo
ws:
Minimize
kv
k

=
kq
 pk

,
s.t.
p

A,
q

B
sub
ject
to
n

X
i=

i
p
i
=
p;
n

X
i=

i
=
;

i

0
n

X
j
=

j
q
j
=
q
=
p
+
v
;
n

X
j
=

j
=
;

j

0
where
p
i
and
q
j
are
v
ertices
of
A
and
B
resp
ectiv
ely
.
The
v
ariables
are
p,
v
,

i
's
and

j
's.
There
are
(n

+
n

+
)
constrain
ts:
n

and
n

linear
constrain
ts
from
solving

i
's
and

j
's
and

linear
constrain
ts
eac
h
from
solving
the
x;
y
;
z
 co
ordinates
of
p
and
v
resp
ectiv
ely
.
Since
w
e
also
ha
v
e
the
nonnegativit
y
constrain
ts
for
p
and
v
,
w
e
can

	
displace
b
oth
A
and
B
to
ensure
the
co
ordinates
of
p

0
and
to
nd
the
solutions
of

systems
of
equations
(in

o
ctan
ts)
to
v
erify
that
the
constrain
ts,
the
x;
y
;
z
 co
ordinates
of
v

0,
are
enforced
as
w
ell.
According
to
the
result
on
separable
quadratic
programming
in
[0],
this
QP
problem
can
b
e
solv
ed
in
O
(n

+
n

)
time.
Ov
erall,
no
go
o
d
collision
detection
algorithms
or
distance
computation
metho
ds
are
kno
wn
for
general
geometric
mo
dels.
Moreo
v
er,
most
of
the
litera-
ture
has
fo
cussed
on
collision
detection
and
the
separation
problem
b
et
w
een
a
pair
of
ob
jects
as
compared
to
handling
en
vironmen
ts
with
m
ultiple
ob
ject
mo
dels.
.
Ov
erview
of
the
Thesis
Chapter

through

of
this
thesis
deal
with
algorithms
for
collision
detection,
while
c
hapter

giv
es
an
application
of
the
collision
detection
algorithms
in
rob
ot
motion
planning.
W
e
b
egin
in
Chapter

b
y
describing
the
basic
kno
wledge
necessary
to
follo
w
the
dev
elopmen
t
of
this
thesis
w
ork.
The
core
of
the
collision
detection
algorithms
lies
in
Chapter
,
where
the
incremen
tal
distance
computation
algorithm
is
describ
ed.
Since
this
metho
d
is
esp
ecially
tailored
to
w
ard
con
v
ex
p
olyhedra,
its
extension
to
w
ard
non-con
v
ex
p
olytop
es
and
the
ob
jects
with
curv
ed
b
oundaries
is
describ
ed
in
Chapter
.
Chapter

giv
es
a
treatmen
t
on
reducing
the
frequency
of
collision
c
hec
ks
in
a
large
en
vironmen
t
where
there
ma
y
b
e
thousands
of
ob
jects
presen
t.
Chapter

is
more
or
less
self
con
tained,
and
describ
es
an
opp
ortunistic
global
path
planner
whic
h
uses
the
tec
hniques
describ
ed
in
Chapter

to
construct
a
one-dimensional
sk
eleton
for
the
purp
ose
of
rob
ot
motion
planning.
Chapter

describ
ed
some
computational
geometry
and
mo
deling
concepts
whic
h
leads
to
the
dev
elopmen
t
of
the
algorithms
presen
ted
in
this
thesis,
as
w
ell
as
the
ob
ject
mo
deling
to
the
input
of
our
algorithms
describ
ed
in
this
thesis.
Chapter

con
tains
the
main
result
of
thesis,
whic
h
is
a
simple
and
fast
algorithm
to
compute
the
distance
b
et
w
een
t
w
o
p
olyhedra
b
y
nding
the
closest
fea-
tures
b
et
w
een
t
w
o
con
v
ex
p
olyhedra.
It
utilizes
the
geometry
of
p
olyhedra
to
establish
some
lo
cal
applicabilit
y
criteria
for
v
erifying
the
closest
features,
with
a
prepro
cessing
pro
cedure
to
reduce
eac
h
feature's
neigh
b
ors
to
a
constan
t
size,
and
th
us
guaran
tees

0
exp
ected
constan
t
running
time
for
eac
h
test.
Data
from
n
umerous
exp
erimen
ts
tested
on
a
broad
set
of
con
v
ex
p
olyhedra
in
R

sho
w
that
the
exp
ected
running
time
is
c
on-
stant
for
nding
closest
features
when
the
closest
features
from
the
previous
time
step
are
kno
wn.
It
is
linear
in
total
n
um
b
er
of
features
if
no
sp
ecial
initialization
is
done.
This
tec
hnique
can
b
e
used
for
dynamic
collision
detection,
ph
ysical
sim
ulation,
plan-
ning
in
three-dimensional
space,
and
other
rob
otics
problems.
It
forms
the
heart
of
the
motion
planning
algorithm
describ
ed
in
Chapter
.
In
Chapter
,
w
e
will
discuss
ho
w
w
e
can
use
the
incremen
tal
distance
com-
putation
algorithm
in
Chapter

for
dynamic
collision
detection
b
et
w
een
non-con
v
ex
p
olytop
es
and
ob
jects
with
curv
ed
b
oundary
.
Since
the
incremen
tal
distance
com-
putation
algorithm
is
designed
based
up
on
the
prop
erties
of
con
v
ex
sets,
extension
to
non-con
v
ex
p
olytop
es
using
a
sub-part
hierarc
hical
tree
represen
tation
will
b
e
de-
scrib
ed
in
detail
here.
The
later
part
of
this
c
hapter
deals
with
con
tact
determination
b
et
w
een
geometric
mo
dels
describ
ed
b
y
curv
ed
b
oundaries
and
undergoing
rigid
mo-
tion.
The
set
of
mo
dels
include
surfaces
describ
ed
b
y
rational
spline
patc
hes
or
piece-
wise
algebraic
functions.
In
con
trast
to
previous
approac
hes,
w
e
utilize
the
exp
ected
constan
t
time
algorithm
for
trac
king
the
closest
features
b
et
w
een
con
v
ex
p
olytop
es
describ
ed
in
Chapter

and
lo
cal
n
umerical
metho
ds
to
extend
the
incremen
tal
nature
to
con
v
ex
curv
ed
ob
jects.
This
approac
h
preserv
es
the
coherence
b
et
w
een
successiv
e
motions
and
exploits
the
lo
calit
y
in
up
dating
their
p
ossible
con
tact
status.
W
e
use
lo
cal
and
global
algebraic
metho
ds
for
solving
p
olynomial
equations
and
the
geomet-
ric
form
ulation
of
the
problem
to
devise
ecien
t
algorithms
for
non-con
v
ex
curv
ed
ob
jects
as
w
ell,
and
to
determine
the
exact
con
tact
p
oin
ts
when
collisions
o
ccur.
P
arts
of
this
c
hapter
represen
t
join
t
w
ork
with
Dinesh
Mano
c
ha
of
the
Univ
ersit
y
of
North
Carolina
at
Chap
el
Hill.
Chapter

complemen
ts
the
previous
c
hapters
b
y
describing
t
w
o
metho
ds
whic
h
further
reduce
the
frequency
of
collision
c
hec
ks
in
an
en
vironmen
t
with
m
ultiple
ob
jects
mo
ving
around.
One
assumes
the
kno
wledge
of
maxim
um
acceleration
and
v
elo
cit
y
to
establish
a
priorit
y
queue
sorted
b
y
the
lo
w
er
b
ound
on
time
to
collision.
The
other
purely
exploits
the
spatial
arrangemen
t
without
an
y
other
information
to
reduce
the
n
um
b
er
of
pairwise
in
terference
tests.
The
rational
b
ehind
this
w
ork


comes
from
the
fact
that
though
eac
h
pairwise
in
terference
test
only
tak
es
exp
ected
constan
t
time,
to
c
hec
k
for
all
p
ossible
con
tacts
among
n
ob
jects
at
all
time
can
b
e
quite
time
consuming,
esp
ecially
if
n
is
in
the
range
of
h
undreds
or
thousands.
This
n

factor
in
the
collision
detection
computation
will
dominate
the
run
time,
once
n
increases.
Therefore,
it
is
essen
tial
to
come
up
with
either
heuristic
approac
hes
or
go
o
d
theoretical
algorithms
to
reduce
the
n

pairwise
comparisons.
Chapter

is
indep
enden
t
of
the
other
c
hapters
of
the
thesis,
and
presen
ts
a
new
rob
ot
path
planning
algorithm
that
constructs
a
global
sk
eleton
of
free-space
b
y
the
incremen
tal
lo
cal
metho
d
describ
ed
in
Chapter
.
The
curv
es
of
the
sk
eleton
are
the
lo
ci
of
maxima
of
an
articial
p
oten
tial
eld
that
is
directly
prop
ortional
to
distance
of
the
rob
ot
from
obstacles.
This
metho
d
has
the
adv
an
tage
of
fast
con
v
er-
gence
of
lo
cal
metho
ds
in
uncluttered
en
vironmen
ts,
but
it
also
has
a
deterministic
and
ecien
t
metho
d
of
escaping
lo
cal
extremal
p
oin
ts
of
the
p
oten
tial
function.
W
e
rst
describ
e
a
general
roadmap
algorithm,
for
conguration
spaces
of
an
y
dimension,
and
then
describ
e
sp
ecic
applications
of
the
algorithm
for
rob
ots
with
t
w
o
and
three
degrees
of
freedom.


Chapter

Bac
kground
In
this
c
hapter,
w
e
will
describ
e
some
mo
deling
and
computational
geome-
try
concepts
whic
h
leads
to
the
dev
elopmen
t
of
the
algorithms
presen
ted
later
in
this
thesis,
as
w
ell
as
the
ob
ject
mo
deling
for
the
input
to
our
collision
detection
algo-
rithms.
Some
of
the
materials
presen
ted
in
this
c
hapter
can
b
e
found
in
the
b
o
oks
b
y
Homann,
Preparata
and
Shamos
[,

].
The
set
of
mo
dels
w
e
used
include
rigid
p
olyhedra
and
ob
jects
with
surfaces
describ
ed
b
y
rational
spline
or
piecewise
algebraic
functions.
No
deformation
of
the
ob
jects
is
assumed
under
motion
or
external
forces.
(This
ma
y
seem
a
restrictiv
e
constrain
t.
Ho
w
ev
er,
in
general
this
assumption
yields
v
ery
satisfactory
results,
unless
the
ob
ject
nature
is
exible
and
deformable.)
.
Basic
Concenpts
W
e
will
rst
review
some
of
the
basic
concepts
and
terminologies
whic
h
are
essen
tial
to
the
later
dev
elopmen
t
of
this
thesis
w
ork.
..
Mo
del
Represen
tations
In
solid
and
geometric
mo
deling,
there
are
t
w
o
ma
jor
represen
tations
sc
hemata:
B-rep
(b
oundary
represen
tation)
and
CSG
(constructiv
e
solid
geometry).
Eac
h
has


its
o
wn
adv
an
tages
and
inheren
t
problems.

Boundary
Represen
tation:
to
represen
t
a
solid
ob
ject
b
y
describing
its
surface,
suc
h
that
w
e
ha
v
e
the
complete
information
ab
out
the
in
terior
and
exterior
of
an
ob
ject.
This
represen
tation
giv
es
us
t
w
o
t
yp
es
of
description:
(a)
geometric
{
the
parameters
needed
to
describ
e
a
face,
an
edge,
and
a
v
ertex;
(b)
top
ological
{
the
adjacencies
and
incidences
of
v
ertices,
edges,
and
faces.
This
represen
tation
ev
olv
es
from
the
description
for
p
olyhedra.

Constructiv
e
Solid
Geometry:
to
represen
t
a
solid
ob
ject
b
y
a
set-theoretic
Bo
olean
expression
of
primitive
ob
jects.
The
CSG
op
erations
include
rotation,
trans-
lation,
r
e
gularize
d
union,
r
e
gularize
d
interse
ction
and
r
e
gularize
d
dier
enc
e.
The
CSG
standard
primitiv
e
s
are
the
sphere,
the
cylinder,
the
cone,
the
parallelepip
ed,
the
tri-
angular
prism,
and
the
torus.
T
o
create
a
primitiv
e
part,
the
user
needs
to
sp
ecify
the
dimensions
(suc
h
as
the
heigh
t,
width,
and
length
of
a
blo
c
k)
of
these
primitiv
e
s.
Eac
h
ob
ject
has
a
lo
c
al
c
o
or
dinate
fr
ame
asso
ciated
with
it.
The
conguration
of
eac
h
ob
ject
is
expressed
b
y
the
basic
CSG
op
erations
(i.e.
rotation
and
translation)
to
place
eac
h
ob
ject
with
resp
ect
to
a
global
world
c
o
or
dinate
fr
ame.
Due
to
the
nature
of
the
distance
computation
algorithm
for
con
v
ex
p
oly-
top
es
(presen
ted
in
Chapter
),
whic
h
utilizes
the
adjacencies
and
incidences
of
fea-
tures
as
w
ell
as
the
geometric
information
to
describ
e
the
geometric
em
b
edding
re-
lationship,
w
e
ha
v
e
c
hosen
the
(mo
died)
b
oundary
represen
tation
to
describ
e
eac
h
p
olyhedron
(describ
ed
in
the
next
section).
Ho
w
ev
er,
the
basic
concept
of
CSG
rep-
resen
tation
is
used
in
constructing
the
subpart
hierarc
hical
tree
to
describ
e
the
non-
con
v
ex
p
olyhedral
ob
jects,
since
eac
h
con
v
ex
piece
encloses
a
v
olume
(can
b
e
though
t
of
as
an
ob
ject
primitiv
e
).


..
Data
Structures
and
Basic
T
erminology
Giv
en
the
t
w
o
ma
jor
dieren
t
represen
tation
sc
hema,
next
w
e
will
describ
e
the
mo
died
b
oundary
represen
tation,
whic
h
w
e
use
to
represen
t
con
v
ex
p
olytop
e
in
our
algorithm,
as
w
ell
as
some
basic
terminologies
describing
the
geometric
relation-
ship
b
et
w
een
geometric
en
tities.
Let
A
b
e
a
p
olytop
e.
A
is
partitioned
in
to
features
f

;
:
:
:
;
f
n
where
n
is
the
total
n
um
b
er
of
features,
i.e.
n
=
f
+
e
+
v
where
f,
e,
v
stands
for
the
total
n
um
b
er
of
faces,
edges,
v
ertices
resp
ectiv
ely
.
Eac
h
feature
(except
v
ertex)
is
an
op
en
subset
of
an
ane
plane
and
do
es
not
con
tain
its
b
oundary
.
This
implies
the
follo
wing
relationships:
[f
i
=
A;
i
=
;
:
:
:
;
n
f
i
\
f
j
=
;;
i
=
j
Denition:
B
is
in
the
b
oundary
of
F
and
F
is
in
c
ob
oundary
of
B
,
if
and
only
if
B
is
in
the
closure
of
F
,
i.e.
B

F
and
B
has
one
few
er
dimension
than
F
do
es.
F
or
example,
the
cob
oundary
of
a
v
ertex
is
the
set
of
edges
touc
hing
it
and
the
cob
oundary
of
an
edge
is
the
t
w
o
faces
adjacen
t
to
it.
The
b
oundary
of
a
face
is
the
set
of
edges
in
the
closure
of
the
face.
W
e
also
adapt
the
winged
edge
represen
tation.
F
or
those
readers
who
are
not
familiar
with
this
terminology
,
please
refer
to
[].
Here
w
e
giv
e
a
brief
description
of
the
winged
edge
represen
tation:
The
edge
is
orien
ted
b
y
giving
t
w
o
inciden
t
v
ertices
(the
head
and
tail).
The
edge
p
oin
ts
from
tail
to
head.
It
has
t
w
o
adjacen
t
faces
cob
ounding
it
as
w
ell.
Lo
oking
from
the
the
tail
end
to
w
ard
the
head,
the
adjacen
t
face
lying
to
the
righ
t
hand
side
is
what
w
e
called
the
\righ
t
face"
and
similarly
for
the
\left
face"
(please
see
Fig..).
Eac
h
p
olyhedron
data
structure
has
a
eld
for
its
features
(faces,
edges,
v
ertices)
and
V
oronoi
cells
describ
ed
b
elo
w
in
Sec
...
Eac
h
feature
(a
v
ertex,
an
edge,
or
a
face)
is
describ
ed
b
y
its
geometric
parameters.
Its
data
structure
also
includes
a
list
of
its
b
oundary
,
cob
oundary
,
and
V
or
onoi
r
e
gions
(dened
later
in
Sec
..).


HE
TE
Right
Face
Left
Face
E
Figure
.:
A
winged
edge
represen
tation
In
addition,
w
e
will
use
the
w
ord
\ab
o
v
e"
and
\b
eneath"
to
describ
e
the
relationship
b
et
w
een
a
p
oin
t
and
a
face.
In
the
homogeneous
represen
tation
where
a
p
oin
t
P
is
presen
ted
as
a
v
ector
(P
x
;
P
y
;
P
z
;
)
and
F
's
normalized
unit
out
w
ard
normal
N
F
is
presen
ted
as
v
ector
(a;
b;
c;
 d),
where
 d
is
the
directional
distance
from
the
origin
and
the
v
ector
n
=
(a;
b;
c)
has
the
magnitude
of
.
The
plane
whic
h
F
lies
on
is
describ
ed
b
y
the
plane
equation
ax
+
by
+
cz
+
d
=
0.
A
p
oin
t
P
is
ab
ove
F
,
P

N
F
>
0
A
p
oin
t
P
is
on
F
,
P

N
F
=
0
A
p
oin
t
P
is
b
ene
ath
F
,
P

N
F
<
0
So,
if
 d
>
0,
then
the
origin
lies
 d
units
b
eneath
the
face
F
and
vice
v
ersa.
Similarly
,
let
~
e
b
e
the
v
ector
represen
ting
an
edge
E
.
Let
H
E
=
(H
x
;
H
y
;
H
z
)
and
T
E
=
(T
x
;
T
y
;
T
z
).
~
e
=
H
E
 T
E
=
(H
x
 T
x
;
H
y
 T
y
;
H
z
 T
Z
;
0)
where
H
E
and
T
E
are
the
head
and
tail
of
the
edge
E
resp
ectiv
ely
.
An
edge
E
p
oin
ts
into
a
face
F
,
~
e

N
F
<
0
An
edge
E
is
p
ar
al
lel
to
a
face
F
,
~
e

N
F
=
0
An
edge
E
p
oin
ts
out
of
a
face
F
,
~
e

N
F
>
0


..
V
oronoi
Diagram
The
pro
ximit
y
problem,
i.e.
\giv
en
a
set
S
of
N
p
oin
ts
in
R

,
for
eac
h
p
oin
t
p
i

S
what
is
the
set
of
p
oin
ts
(x;
y
)
in
the
plane
that
are
closer
to
p
i
than
to
an
y
other
p
oin
t
in
S
?",
is
often
answ
ered
b
y
the
retraction
approac
h
in
computational
geometry
.
This
approac
h
is
commonly
kno
wn
as
constructing
the
V
or
onoi
diagr
am
of
the
p
oin
t
set
S
.
This
is
an
imp
ortan
t
concept
whic
h
w
e
will
revisit
in
Chapter
.
Here
w
e
will
giv
e
a
brief
denition
of
V
oronoi
diagram.
The
in
tuition
to
solv
e
the
pro
ximit
y
problem
in
R

is
to
partition
the
plane
in
to
regions,
eac
h
of
these
is
the
set
of
the
p
oin
ts
whic
h
are
closer
to
a
p
oin
t
p
i

S
than
an
y
other.
If
w
e
kno
w
this
partitioning,
then
w
e
can
solv
e
the
problem
of
pro
ximit
y
directly
b
y
a
simple
query
.
The
partition
is
based
on
the
set
of
closest
p
oin
ts,
e.g.
bisectors
whic
h
ha
v
e

or

closest
p
oin
ts.
Giv
en
t
w
o
p
oin
ts
p
i
and
p
j
,
the
set
of
p
oin
ts
closer
to
p
i
than
to
p
j
is
just
the
half-plane
H
i
(p
i
;
p
j
)
con
taining
p
i
.
H
i
(p
i
;
p
j
)
is
dened
b
y
the
p
erp
endicular
bisector
to
p
i
p
j
.
The
set
of
p
oin
ts
closer
to
p
i
than
to
an
y
other
p
oin
t
is
formed
b
y
the
in
tersection
of
at
most
N
 
half-planes,
where
N
is
the
n
um
b
er
of
p
oin
ts
in
the
set
S
.
This
set
of
p
oin
ts,
V
i
,
is
called
the
V
or
onoi
p
olygon
asso
ciate
d
with
p
i
.
The
collection
of
N
V
oronoi
p
olygons
giv
en
the
N
p
oin
ts
in
the
set
S
is
the
V
or
onoi
diagr
am,
V
or
(S
),
of
the
p
oin
t
set
S
.
Ev
ery
p
oin
t
(x;
y
)
in
the
plane
lies
within
a
V
oronoi
p
olygon.
If
a
p
oin
t
(x;
y
)

V
(i),
then
p
i
is
a
ne
ar
est
p
oint
to
the
p
oin
t
(x;
y
).
Therefore,
the
V
oronoi
diagram
con
tains
all
the
information
necessary
to
solv
e
the
pro
ximit
y
problems
giv
en
a
set
of
p
oin
ts
in
R

.
A
similar
idea
applies
to
the
same
problem
in
three-dimensional
or
higher
dimensional
space
[
,
].
The
extension
of
the
V
oronoi
diagram
to
higher
dimensional
fe
atur
es
(instead
of
p
oin
ts)
is
called
the
generalized
V
oronoi
diagram,
i.e.
the
set
of
p
oin
ts
closest
to
a
fe
atur
e,
e.g.
that
of
a
p
olyhedron.
In
general,
the
generalized
V
oronoi
diagram
has
quadratic
surface
b
oundaries
in
it.
Ho
w
ev
er,
if
the
ob
jects
are
con
v
ex,
then
the
generalized
V
oronoi
diagram
has
planar
b
oundaries.
This
leads
to
the
denition
of
V
or
onoi
r
e
gions
whic
h
will
b
e
describ
ed
next
in
Sec
...


..
V
oronoi
Region
A
V
or
onoi
r
e
gion
asso
ciated
with
a
fe
atur
e
is
a
set
of
p
oin
ts
exterior
to
the
p
olyhedron
whic
h
are
closer
to
that
feature
than
an
y
other.
The
V
oronoi
regions
form
a
partition
of
space
outside
the
p
olyhedron
according
to
the
closest
feature.
The
collection
of
V
oronoi
regions
of
eac
h
p
olyhedron
is
the
V
oronoi
diagram
of
the
p
olyhedron.
Note
that
the
V
oronoi
diagram
of
a
con
v
ex
p
olyhedron
has
linear
size
and
consists
of
p
olyhedral
regions.
A
c
el
l
is
the
data
structure
for
a
V
oronoi
region.
It
has
a
set
of
constrain
t
planes
whic
h
b
ound
the
V
oronoi
region
with
p
oin
ters
to
the
neigh
b
oring
cells
(whic
h
share
a
constrain
t
plane
with
it)
in
its
data
structure.
If
a
p
oin
t
lies
on
a
constrain
t
plane,
then
it
is
equi-distan
t
from
the
t
w
o
features
whic
h
share
this
constrain
t
plane
in
their
V
oronoi
regions.
Using
the
geometric
prop
erties
of
con
v
ex
sets,
applicabilit
y
criteria
(ex-
plained
in
Sec..)
are
established
based
up
on
the
V
oronoi
regions.
If
a
p
oin
t
P
on
ob
ject
A
lies
inside
the
V
oronoi
region
of
f
B
on
ob
ject
B
,
then
f
B
is
a
closest
feature
to
the
p
oin
t
P
.
(More
details
will
b
e
presen
ted
in
Chapter
.)
In
Chapter
,
w
e
will
describ
e
our
incremen
tal
distance
computation
al-
gorithm
whic
h
utilizes
the
concept
of
V
oronoi
regions
and
the
prop
erties
of
con
v
ex
p
olyhedra
to
p
erform
collision
detection
in
exp
ected
constan
t
time.
After
giving
the
details
of
p
olyhedral
mo
del
represen
tations,
in
the
next
section
w
e
will
describ
e
more
general
ob
ject
mo
deling
to
include
the
class
of
non-p
olyhedral
ob
jects
as
w
ell,
with
emphasis
on
curv
ed
surfaces.
.
Ob
ject
Mo
deling
The
set
of
ob
jects
w
e
consider,
b
esides
con
v
ex
p
olytop
es,
includes
non-
con
v
ex
ob
jects
(lik
e
a
torus)
as
w
ell
as
t
w
o
dimensional
manifolds
describ
ed
using
p
olynomials.
The
class
of
parametric
and
implicit
surfaces
describ
ed
in
terms
of
piecewise
p
olynomial
equations
is
curren
tly
considered
the
state
of
the
art
for
mo
d-
eling
applications
[,

].
These
include
free-form
surfaces
describ
ed
using
spline
patc
hes,
primitiv
e
ob
jects
lik
e
p
olyhedra,
quadrics
surfaces
(lik
e
cones,
ellipsoids),


torus
and
their
com
binations
obtained
using
CSG
op
erations.
F
or
arbitrary
curv
ed
ob
jects
it
is
p
ossible
to
obtain
reasonably
go
o
d
appro
ximations
using
B-splines
Most
of
the
earlier
animation
and
sim
ulation
systems
are
restricted
to
p
oly-
hedral
mo
dels.
Ho
w
ev
er,
mo
deling
with
surfaces
b
ounded
b
y
linear
b
oundaries
p
oses
a
serious
restriction
in
these
systems.
Our
con
tact
determination
algorithms
for
curv
ed
ob
jects
are
applicable
on
ob
jects
describ
ed
using
spline
represen
tations
(B

ezier
and
B-spline
patc
hes)
and
algebraic
surfaces.
These
represen
tations
can
b
e
used
as
prim-
itiv
es
for
CSG
op
erations
as
w
ell.
T
ypically
spline
patc
hes
are
describ
ed
geometrically
b
y
their
con
trol
p
oin
ts,
knot
v
ectors
and
order
con
tin
uit
y
[].
The
con
trol
p
oin
ts
ha
v
e
the
prop
ert
y
that
the
en
tire
patc
h
lies
in
the
con
v
ex
h
ull
of
these
p
oin
ts.
The
spline
patc
hes
are
represen
ted
as
piecewise
B

ezier
patc
hes.
Although
these
mo
dels
are
describ
ed
geometrically
using
con
trol
p
olytop
es,
w
e
assume
that
the
B

ezier
surface
has
an
algebraic
form
ulation
in
homogeneous
co
ordinates
as:
F(s;
t)
=
(X
(s;
t);
Y
(s;
t);
Z
(s;
t);
W
(s;
t)):
(:)
W
e
also
allo
w
the
ob
jects
to
b
e
describ
ed
implici
tly
as
algebraic
surfaces.
F
or
exam-
ples,
the
quadric
surfaces
lik
e
spheres,
cylinders
can
b
e
simply
describ
ed
as
a
degree
t
w
o
algebraic
surface.
The
algebraic
surfaces
are
represen
ted
as
f
(x;
y
;
z
)
=
0.
..
Motion
Description
All
ob
jects
are
dened
with
resp
ect
to
a
global
co
ordinate
system,
the
world
c
o
or
dinate
fr
ame.
The
initial
conguration
is
sp
ecied
in
terms
of
the
origin
of
the
system.
As
the
ob
jects
undergo
rigid
motion,
w
e
up
date
their
p
ositions
using
a



matrix,
M
,
used
to
represen
t
the
rotation
as
w
ell
as
translational
comp
onen
ts
of
the
motion
(with
resp
ect
to
the
origin).
The
collision
detection
algorithm
is
based
only
on
lo
cal
features
of
the
p
olyhedra
(or
con
trol
p
olytop
e
of
spline
patc
hes)
and
do
es
not
require
the
p
osition
of
the
other
features
to
b
e
up
dated
for
the
purp
ose
of
collision
detection
at
ev
ery
instan
t.

	
..
System
of
Algebraic
Equations
Our
algorithm
for
collision
detection
for
algebraic
surface
form
ulates
the
problem
of
nding
closest
p
oin
ts
b
et
w
een
ob
ject
mo
dels
and
con
tact
determination
in
terms
of
solving
a
system
of
algebraic
equations.
F
or
most
instances,
w
e
obtain
a
zero
dimensional
algebraic
system
consisting
of
n
equations
in
n
unkno
wns.
Ho
w
ev
er
at
times,
w
e
ma
y
ha
v
e
an
o
v
erconstrained
system,
where
the
n
um
b
er
of
equations
is
more
than
the
n
um
b
er
of
unkno
wns
or
an
underconstrained
system,
whic
h
has
innite
n
um
b
er
of
solutions.
W
e
will
b
e
using
algorithms
for
solving
zero
dimensional
systems
and
address
ho
w
they
can
b
e
mo
died
to
other
cases.
In
particular,
w
e
are
giv
en
a
system
of
n
algebraic
equations
in
n
unkno
wns:
F

(x

;
x

;
:
:
:
;
x
n
)
=
0
.
.
.
(.)
F
n
(x

;
x

;
:
:
:
;
x
n
)
=
0
Let
their
degrees
b
e
d

,
d

,
:
:
:
,
d
n
,
resp
ectiv
ely
.
W
e
are
in
terested
in
computing
all
the
solutions
in
some
domain
(lik
e
all
the
real
solutions
to
the
giv
en
system).
Curren
t
algorithms
for
solving
p
olynomial
equations
can
b
e
classied
in
to
lo
cal
and
global
metho
ds.
Lo
cal
metho
ds
lik
e
Newton's
metho
d
or
optimization
routines
need
go
o
d
initial
guesses
to
eac
h
solution
in
the
giv
en
domain.
Their
p
erfor-
mance
is
a
function
of
the
initial
guesses.
If
w
e
are
in
terested
in
computing
all
the
real
solutions
of
a
system
of
p
olynomials,
solving
equations
b
y
lo
cal
metho
ds
requires
that
w
e
kno
w
the
n
um
b
er
of
real
solutions
to
the
system
of
equations
and
go
o
d
guesses
to
these
solutions.
The
global
approac
hes
do
not
need
an
y
initial
guesses.
They
are
based
on
algebraic
approac
hes
lik
e
resultan
ts,
Gr}
obner
bases
or
purely
n
umerical
tec
hniques
lik
e
the
homotop
y
metho
ds
and
in
terv
al
arithmetic.
Purely
sym
b
olic
metho
ds
based
on
resultan
ts
and
Gr}
obner
bases
are
rather
slo
w
in
practice
and
require
m
ultiprecision
arithmetic
for
accurate
computations.
In
the
con
text
of
nite
precision
arithmetic,
the
main
approac
hes
are
based
on
resultan
t
and
matrix
computations
[],
con
tin
ua-

0
tion
metho
ds
[]
and
in
terv
al
arithmetic
[	,

].
The
recen
tly
dev
elop
ed
algorithm
based
on
resultan
ts
and
matrix
computations
has
b
een
sho
wn
to
b
e
v
ery
fast
and
accurate
on
man
y
geometric
problems
and
is
reasonably
simple
to
implem
en
t
using
linear
algebra
routines
b
y
Mano
c
ha
[].
In
particular,
giv
en
a
p
olynomial
system
the
algorithm
in
[
]
reduces
the
problem
of
ro
ot
nding
to
an
eigen
v
alue
problem.
Based
on
the
eigen
v
alue
and
eigen
v
ectors,
all
the
solutions
of
the
original
system
are
computed.
F
or
large
systems
the
matrix
tends
to
b
e
sparse.
The
order
of
the
matrix,
sa
y
N
,
is
a
function
of
the
algebraic
complexit
y
of
the
system.
This
is
b
ounded
b
y
the
Bezout
b
ound
of
the
giv
en
system
corresp
onding
to
the
pro
duct
of
the
degrees
of
the
equations.
In
most
applications,
the
equations
are
sparse
and
therefore,
the
order
of
the
resulting
matrix
is
m
uc
h
lo
w
er
than
the
Bezout
b
ound.
Go
o
d
algorithms
are
a
v
ailable
for
computing
the
eigen
v
alues
and
eigen
v
ectors
of
a
matrix.
Their
running
time
can
b
e
as
high
as
O
(N

).
Ho
w
ev
er,
in
our
applications
w
e
are
only
in
terested
in
a
few
solutions
to
the
giv
en
system
of
equations
in
a
corresp
onding
domain,
i.e.
real
eigen
v
alues.
This
corresp
onds
to
nding
selected
eigen
v
alues
of
the
matrix
corre-
sp
onding
to
the
domain.
Algorithms
com
bining
this
with
the
sparsit
y
of
the
matrix
are
presen
ted
in
[]
and
they
w
ork
v
ery
w
ell
in
practice.
The
global
ro
ot
nders
are
used
in
the
prepro
cessing
stage.
As
the
ob
jects
undergo
motion,
the
problem
of
collision
detection
and
con
tact
determination
is
p
osed
in
terms
of
a
new
algebraic
system.
Ho
w
ev
er,
the
new
algebraic
system
is
obtained
b
y
a
sligh
t
c
hange
in
the
co
ecien
ts
of
the
previous
system
of
equations.
The
c
hange
in
co
ecien
ts
is
a
function
of
the
motion
b
et
w
een
successiv
e
instances
and
this
is
t
ypically
small
due
to
temp
oral
and
spatial
coherence.
Since
the
ro
ots
of
an
algebraic
system
are
a
con
tin
uous
function
of
the
co
ecien
ts,
the
ro
ots
c
hange
sligh
tly
as
w
ell.
As
a
result,
the
new
set
of
ro
ots
can
b
e
computed
using
lo
cal
metho
ds
only
.
W
e
can
either
use
Newton's
metho
d
to
compute
the
ro
ots
of
the
new
set
of
algebraic
equations
or
in
v
erse
p
o
w
er
iterations
[
]
to
compute
the
eigen
v
alues
of
the
new
matrix
obtained
using
resultan
t
form
ulation.


Chapter

An
Incremen
tal
Distance
Computation
Algorithm
In
this
c
hapter
w
e
presen
t
a
simple
and
ecien
t
metho
d
to
compute
the
distance
b
et
w
een
t
w
o
con
v
ex
p
olyhedra
b
y
nding
and
trac
king
the
closest
p
oin
ts.
The
metho
d
is
generally
applicable,
but
is
esp
ecially
w
ell
suited
to
rep
etitiv
e
distance
calculation
as
the
ob
jects
mo
v
e
in
a
sequence
of
small,
discrete
steps
due
to
its
incremen
tal
nature.
The
metho
d
w
orks
b
y
nding
and
main
taining
a
pair
of
closest
features
(v
ertex,
edge,
or
face)
on
the
t
w
o
p
olyhedra
as
the
they
mo
v
e.
W
e
tak
e
adv
an
tage
of
the
fact
that
the
closest
features
c
hange
only
infrequen
tly
as
the
ob
jects
mo
v
e
along
nely
discretized
paths.
By
prepro
cessing
the
p
olyhedra,
w
e
can
v
erify
that
the
closest
features
ha
v
e
not
c
hanged
or
p
erformed
an
up
date
to
a
neigh
b
oring
feature
in
exp
ected
constan
t
time.
Our
exp
erimen
ts
sho
w
that,
once
initialized,
the
exp
ected
running
time
of
our
incremen
tal
algorithm
is
c
onstant
indep
enden
t
of
the
complexit
y
of
the
p
olyhedra,
pro
vided
the
motion
is
not
abruptly
large.
Our
metho
d
is
v
ery
straigh
tforw
ard
in
its
conception.
W
e
start
with
a
candidate
pair
of
features,
one
from
eac
h
p
olyhedron,
and
c
hec
k
whether
the
closest
p
oin
ts
lie
on
these
features.
Since
the
ob
jects
are
con
v
ex,
this
is
a
lo
cal
test
in
v
olving
only
the
neigh
b
oring
features
(b
oundary
and
cob
oundary
as
dened
in
Sec.
..)
of
the
candidate
features.
If
the
features
fail
the
test,
w
e
step
to
a
neigh
b
oring
feature
of
one
or
b
oth
candidates,
and
try
again.
With
some
simple
prepro
cessing,
w
e
can


guaran
tee
that
ev
ery
feature
has
a
constan
t
n
um
b
er
of
neigh
b
oring
features.
This
is
ho
w
w
e
can
v
erify
a
closest
feature
pair
in
exp
ected
constan
t
time.
When
a
pair
of
features
fails
the
test,
the
new
pair
w
e
c
ho
ose
is
guaran
teed
to
b
e
closer
than
the
old
one.
Usually
when
the
ob
jects
mo
v
e
and
one
of
the
closest
features
c
hanges,
w
e
can
nd
it
after
a
single
iteration.
Ev
en
if
the
closest
features
are
c
hanging
rapidly
,
sa
y
once
p
er
step
along
the
path,
our
algorithm
will
tak
e
only
sligh
tly
longer.
It
is
also
clear
that
in
an
y
situation
the
algorithm
m
ust
terminate
in
a
n
um
b
er
of
steps
at
most
equal
to
the
n
um
b
er
of
feature
pairs.
This
algorithm
is
a
k
ey
part
of
our
general
planning
algorithm,
describ
ed
in
Chap.
That
algorithm
creates
a
one-dimensional
roadmap
of
the
free
space
of
a
rob
ot
b
y
tracing
out
curv
es
of
maximal
clearance
from
obstacles.
W
e
use
the
algorithm
in
this
c
hapter
to
compute
distances
and
closest
p
oin
ts.
F
rom
there
w
e
can
easily
compute
gradien
ts
of
the
distance
function
in
conguration
space,
and
thereb
y
nd
the
direction
of
the
maximal
clearance
curv
es.
In
addition,
this
tec
hnique
is
w
ell
adapted
for
dynamic
collision
detection.
This
follo
ws
naturally
from
the
fact
that
t
w
o
ob
jects
collide
if
and
only
if
the
distance
b
et
w
een
them
is
less
than
or
equal
to
zero
(plus
some
user
dened
tolerance).
In
fact,
our
approac
h
pro
vide
more
geometric
information
than
what
is
necessary
,
i.e.
the
distance
information
and
the
closest
feature
pair
ma
y
b
e
used
to
compute
in
ter-ob
ject
forces.
.
Closest
F
eature
P
air
Eac
h
ob
ject
is
represen
ted
as
a
con
v
ex
p
olyhedron,
or
a
union
of
con
v
ex
p
olyhedra.
Man
y
real-w
orld
ob
jects
that
ha
v
e
curv
ed
surfaces
are
represen
ted
b
y
p
olyhedral
appro
ximations.
The
accuracy
of
the
appro
ximations
can
b
e
impro
v
ed
b
y
increasing
the
resolution
or
the
n
um
b
er
of
v
ertices.
With
our
metho
d,
there
is
little
or
no
degradation
in
p
erformance
when
the
resolution
is
increased
in
the
con
v
ex
case.
F
or
noncon
v
ex
ob
jects,
w
e
rely
on
sub
division
in
to
con
v
ex
pieces,
whic
h
unfortunately
,
ma
y
tak
e
O
((n
+
r

)l
og
r
)
time
to
partition
a
nondegenerate
simple
p
olytop
e
of
gen
us
0,
where
n
is
the
n
um
b
er
of
v
ertices
and
r
is
the
n
um
b
er
of
r
eex
e
dges
of
the
original


noncon
v
ex
ob
ject
[,

].
In
general,
a
p
olytop
e
of
n
v
ertices
can
alw
a
ys
b
e
partitioned
in
to
O
(n

)
con
v
ex
pieces
[].
Giv
en
the
ob
ject
represen
tation
and
data
structure
for
con
v
ex
p
olyhedra
describ
ed
in
Chapter
,
here
w
e
will
dene
the
term
closest
fe
atur
e
p
air
whic
h
w
e
quote
frequen
tly
in
our
description
of
the
distance
computation
algorithm
for
con
v
ex
p
olyhedra.
The
closest
pair
of
features
b
et
w
een
t
w
o
general
con
v
ex
p
olyhedra
is
dened
as
the
pair
of
features
whic
h
con
tain
the
closest
p
oin
ts.
Let
p
olytop
es
A
and
B
denote
the
con
v
ex
sets
in
R

.
Assume
A
and
B
are
closed
and
b
ounded,
therefore,
compact.
The
distance
b
et
w
een
ob
jects
A
and
B
is
the
shortest
Euclidean
distance
d
AB
:
d
AB
=
inf
pA;q
B
j
p
 q
j
and
let
P
A

A,
P
B

B
b
e
suc
h
that
d
AB
=j
P
A
 P
B
j
then
P
A
and
P
B
are
a
pair
of
closest
p
oin
ts
b
et
w
een
ob
jects
A
and
B
.
F
or
eac
h
pair
of
features
(f
A
and
f
B
)
from
ob
jects
A
and
B,
rst
w
e
nd
the
pair
of
nearest
p
oin
ts
(sa
y
P
A
and
P
B
)
b
et
w
een
these
two
fe
atur
es.
Then,
w
e
c
hec
k
whether
these
p
oin
ts
are
a
pair
of
closest
p
oin
ts
b
etwe
en
A
and
B
.
That
is,
w
e
need
to
v
erify
that
f
B
is
truly
a
closest
feature
on
B
to
P
A
and
f
A
is
truly
a
closest
feature
on
A
to
P
B
This
is
v
erication
of
whether
P
A
lies
inside
the
V
oronoi
region
of
f
B
and
whether
P
B
lies
inside
the
V
oronoi
region
of
f
A
(please
see
Fig.
.).
If
either
c
hec
k
fails,
a
new
(closer)
feature
is
substituted,
and
the
new
pair
is
c
hec
k
ed
again.
Ev
en
tually
,
w
e
m
ust
terminate
with
a
closest
pair,
since
the
distance
b
et
w
een
eac
h
candidate
feature
pair
decreases,
as
the
algorithm
steps
through
them.
The
test
of
whether
one
p
oin
t
lies
inside
of
a
V
oronoi
region
of
a
feature
is
what
w
e
call
an
\applicabilit
y
test".
In
the
next
section
three
in
tuitiv
e
geometric
applicabilit
y
tests,
whic
h
are
the
essen
tial
comp
onen
ts
of
our
algorithm,
will
b
e
de-
scrib
ed.
The
o
v
erall
description
of
our
approac
h
and
the
completeness
pro
of
will
b
e
presen
ted
in
more
detail
in
the
follo
wing
sections.


R1
R2
Fa
CP
Object B
Object A
Vb
Pa
Ea
(a)
Figure
.:
Applicabilit
y
T
est:
(F
a
;
V
b
)
!
(E
a
;
V
b
)
since
V
b
fails
the
applicabilit
y
test
imp
osed
b
y
the
constrain
t
plane
C
P
.
R

and
R

are
the
V
oronoi
regions
of
F
a
and
E
a
resp
ectiv
ely
.


.
Applicabilit
y
Criteria
There
are
three
basic
applicabilit
y
criteria
whic
h
w
e
use
throughout
our
distance
computation
algorithm.
These
are
(i)
p
oin
t-v
ertex,
(ii)
p
oin
t-edge,
and
(iii)
p
oin
t-face
applicabilit
y
conditions.
Eac
h
of
these
applicabilit
y
criteria
is
equiv
alen
t
to
a
mem
b
ership
test
whic
h
v
eries
whether
the
p
oint
lies
in
the
V
oronoi
region
of
the
fe
atur
e.
If
the
ne
ar
est
p
oints
on
t
w
o
features
b
oth
lie
inside
the
V
oronoi
region
of
the
other
feature,
then
the
t
w
o
features
are
a
closest
feature
pair
and
the
p
oin
ts
are
closest
p
oin
ts
b
et
w
een
the
p
olyhedra.
..
P
oin
t-V
ertex
Applicabili
t
y
Criterion
If
a
v
ertex
V
of
p
olyhedron
B
is
truly
a
closest
feature
to
p
oin
t
P
on
p
olyhe-
dron
A,
then
P
m
ust
lie
within
the
V
oronoi
region
b
ounded
b
y
the
constrain
t
planes
whic
h
are
p
erp
endicular
to
the
cob
oundary
of
V
(the
edges
touc
hing
V
).
This
can
b
e
seen
from
Fig...
If
P
lies
outside
the
region
dened
b
y
the
constrain
t
planes
and
hence
on
the
other
side
of
one
of
the
constrain
t
planes,
then
this
implies
that
there
is
at
least
one
edge
of
V
's
cob
oundary
closer
to
P
than
V
.
This
edge
is
normal
to
the
violated
constrain
t.
Therefore,
the
pro
cedure
will
w
alk
to
the
corresp
onding
edge
and
iterativ
ely
call
the
closest
feature
test
to
v
erify
whether
the
fe
atur
e
c
ontaining
P
and
the
new
e
dge
are
the
closest
features
on
the
t
w
o
p
olyhedra.
..
P
oin
t-Edge
Applicabili
t
y
Criterion
As
for
the
p
oin
t-edge
case,
if
edge
E
of
p
olyhedron
B
is
really
a
closest
feature
to
the
p
oin
t
P
of
p
olyhedron
A,
then
P
m
ust
lie
within
the
V
oronoi
region
b
ounded
b
y
the
four
constrain
t
planes
of
E
as
sho
wn
in
Fig...
Let
the
head
and
tail
of
E
b
e
H
E
and
T
E
resp
ectiv
ely
.
Tw
o
of
these
planes
are
p
erp
endicular
to
E
passing
through
the
head
H
E
and
the
tail
T
E
of
E
.
The
other
t
w
o
planes
con
tain
E
and
one
of
the
normals
to
the
cob
oundaries
of
E
(i.e.
the
righ
t
and
the
left
faces
of
E
).
If
P
lies
inside
this
w
edge-shap
ed
V
oronoi
region,
the
applicabilit
y
test
succeeds.
If
P
fails
the
test
imp
osed
b
y
H
E
(or
T
E
),
then
the
pro
cedure
will
w
alk
to
H
E
(or


V
 ObjectB
P
ObjectA
Voronoi Region
Figure
.:
P
oin
t-V
ertex
Applicabilit
y
Criterion
T
E
)
whic
h
m
ust
b
e
closer
to
P
and
recursiv
ely
call
the
general
algorithm
to
v
erify
whether
the
new
vertex
and
the
fe
atur
e
c
ontaining
P
are
the
t
w
o
closest
features
on
t
w
o
p
olyhedra
resp
ectiv
ely
.
If
P
fails
the
applicabilit
y
test
imp
osed
b
y
the
righ
t
(or
left)
face,
then
the
pro
cedure
will
w
alk
to
the
righ
t
(or
left)
face
in
the
cob
oundary
of
E
and
call
the
general
algorithm
recursiv
ely
to
v
erify
whether
the
new
fac
e
(the
righ
t
or
left
face
of
E
)
and
the
fe
atur
e
c
ontaining
P
are
a
pair
of
closest
features.
..
P
oin
t-F
ace
Applicabili
t
y
Criterion
Similarly
,
if
a
face
F
of
p
olyhedron
B
is
actually
a
closest
feature
to
P
on
p
olyhedron
A,
then
P
m
ust
lie
within
F
's
V
oronoi
region
dened
b
y
F
's
prism
and
ab
o
v
e
the
plane
con
taining
F
,
as
sho
wn
in
Fig...
F
's
prism
is
the
region
b
ounded
b
y
the
constrain
t
planes
whic
h
are
p
erp
endicular
to
F
and
con
tain
the
edges
in
the
b
oundary
of
F
.
First
of
all,
the
algorithm
c
hec
ks
if
P
passes
the
applicabilit
y
constrain
ts
imp
osed
b
y
F
's
edges
in
its
cob
oundary
.
If
so,
the
feature
con
taining
P
and
F


E
Te
He
Right-Face
 P
Left-Face
ObjectA
Voronoi Region
Figure
.:
P
oin
t-Edge
Applicabilit
y
Criterion
are
a
pair
of
closest
features;
else,
the
pro
cedure
will
once
again
w
alk
to
the
edge
corresp
onding
to
a
failed
constrain
t
c
hec
k
and
call
the
general
algorithm
to
c
hec
k
whether
the
new
e
dge
in
F
's
b
oundary
(i.e.
E
F
)
and
the
fe
atur
e
c
ontaining
P
are
a
pair
of
the
closest
features.
Next,
w
e
need
to
c
hec
k
whether
P
lies
ab
o
v
e
F
to
guaran
tee
that
P
is
not
inside
the
p
olyhedron
B
.
If
P
lies
b
eneath
F
,
it
implies
that
there
is
at
least
one
feature
on
p
olyhedron
B
closer
to
the
feature
con
taining
P
than
F
or
that
collision
is
p
ossible.
In
suc
h
a
case,
the
nearest
p
oin
ts
on
F
and
the
feature
con
taining
P
ma
y
dene
a
lo
cal
minim
um
of
distance,
and
stepping
to
a
neigh
b
oring
feature
of
F
ma
y
increase
the
distance.
Therefore,
the
pro
cedure
will
call
up
on
a
O
(n)
routine
(where
n
is
the
n
um
b
er
of
features
of
B
)
to
searc
h
for
the
closest
feature
on
the
p
olyhedron
B
to
the
feature
con
taining
P
and
pro
ceed
with
the
general
algorithm.


N
F 2
  F
P
F
Voronoi Region
ObjectA
Figure
.:
V
ertex-F
ace
Applicabilit
y
Criterion
..
Sub
division
Pro
cedure
F
or
v
ertices
of
t
ypical
con
v
ex
p
olyhedra,
there
are
usually
three
to
six
edges
in
the
cob
oundary
.
F
aces
of
t
ypical
p
olyhedra
also
ha
v
e
three
to
six
edges
in
the
b
oundaries.
Therefore,
frequen
tly
the
applicabilit
y
criteria
require
only
a
few
quic
k
tests
for
eac
h
round.
When
a
face
has
more
than
v
e
edges
in
its
b
oundary
or
when
a
v
ertex
has
more
than
v
e
edges
in
its
cob
oundary
,
the
V
oronoi
region
asso
ciated
with
eac
h
feature
is
prepro
cessed
b
y
sub
dividing
the
whole
region
in
to
smaller
cells.
That
is,
w
e
sub
divide
the
prismatic
V
oronoi
region
of
a
face
(with
more
than
v
e
edges)
in
to
quadrilateral
cells
and
divide
the
V
oronoi
region
of
a
v
ertex
(with
more
than
v
e
cob
oundaries)
in
to
p
yrmidal
cells.
After
sub
division,
eac
h
V
oronoi
cell
is
dened
b
y

or

constrain
t
planes
in
its
b
oundary
or
cob
oundary
.
Fig..
sho
ws
ho
w
this
can
b
e
done
on
a
v
ertex's
V
oronoi
region
with

constrain
t
planes
and
a
face's
V
oronoi
region
with

constrain
t
planes.
This
sub
division
pro
cedure
is
a
simple
algorithm
whic
h
can
b
e
done
in
linear
time
as
part
of
prepro
cessing,
and
it
guaran
tees
that
when
the
algorithm
starts,
eac
h
V
oronoi
region
has
a
constan
t
n
um
b
er
of
constrain
t

	
planes.
Consequen
tly
,
the
three
applicabilit
y
tests
describ
ed
ab
o
v
e
run
in
c
onstant
time.
..
Implemen
tati
on
Issues
In
order
to
minimi
ze
online
computation
time,
w
e
do
all
the
sub
division
pro
cedures
and
compute
all
the
V
oronoi
regions
rst
in
a
one-time
computational
eort.
Therefore,
as
the
algorithm
steps
through
eac
h
iteration,
all
the
applicabil-
it
y
tests
w
ould
lo
ok
uniformly
alik
e
|
all
as
\p
oin
t-cell
applicabilit
y
test",
with
a
sligh
t
dierence
to
the
p
oin
t-face
applicabilit
y
criterion.
There
will
no
longer
b
e
an
y
distinction
among
the
three
basic
applicabilit
y
criteria.
Eac
h
feature
is
an
op
en
subset
of
an
ane
plane.
Therefore,
end
p
oin
ts
are
not
consider
part
of
an
edge.
This
is
done
to
simplify
the
pro
of
of
con
v
ergence.
Though
w
e
use
the
winged
edge
represen
tation
for
our
implem
en
tation,
all
the
edges
are
not
delib
erately
orien
ted
as
in
the
winged
edge
represen
tation.
W
e
also
use
h
ysteresis
to
a
v
oid
cycling
in
degenerate
cases
when
there
is
more
than
one
feature
pair
separated
at
appro
ximately
the
same
distance.
W
e
ac
hiev
e
this
b
y
making
the
V
oronoi
regions
o
v
erlap
eac
h
other
with
small
and
\ared"
displace-
men
ts.
T
o
illustrate
the
\ared
V
oronoi
cells",
w
e
demonstrate
them
b
y
an
example
in
Fig.
..
Note
that
all
the
constrain
t
planes
are
tilted
out
w
ard
b
y
a
small
angular
displacemen
t
as
w
ell
as
innitesimal
translational
displacemen
t.
The
angular
dis-
placemen
t
is
used
to
ensure
the
o
v
erlap
of
adjacen
t
regions.
So,
when
a
p
oin
t
falls
on
the
b
orderline
case,
it
will
not
ip
bac
k
and
forth
b
et
w
een
the
t
w
o
adjacen
t
V
oronoi
regions.
The
small
translational
displacemen
t
in
addition
to
angular
displacemen
t
is
needed
for
n
umerical
problem
arising
from
p
oin
t
co
ordinate
transformations.
F
or
an
example,
if
w
e
transform
a
p
oin
t
p
b
y
a
homogeneous
matrix
T
and
transform
it
bac
k
b
y
T
 
,
w
e
will
not
get
the
same
p
oin
t
p
but
p
0
with
small
dierences
in
eac
h
of
its
co
ordinate,
i.e.
T
 
(T
p)=neq
p.
All
faces
are
con
v
ex,
but
b
ecause
of
sub
division
they
can
b
e
coplanar.
Where
the
faces
are
coplanar,
the
V
oronoi
regions
of
the
edges
b
et
w
een
them
is
n
ull
and
face
constrain
ts
p
oin
t
directly
to
the
next
V
oronoi
region
asso
ciated
with
their
neigh
b
oring

0
R1
R2
R3
R5
R6
R4
Va
Fb
Object A
Object B
(b)
Rb
Ra
Figure
.:
Prepro
cessing
of
a
v
ertex's
conical
applicabilit
y
region
and
a
face's
cylin-
drical
applicabilit
y
region


CPE
R1’
CPF
CP
R2’
R2
R1
Object A
Figure
.:
An
example
of
Flared
V
oronoi
Cells:
C
P
F
corresp
onds
to
the
ared
constrain
t
place
C
P
of
a
face
and
C
P
E
corresp
onds
to
the
ared
constrain
t
plane
C
P
of
an
edge.
R
0

and
R
0

are
the
ar
e
d
V
oronoi
regions
of
unp
erturb
ed
R

and
R

.
Note
that
they
o
v
erlap
eac
h
other.


coplanar
faces.
In
addition,
the
order
of
the
applicabilit
y
test
in
eac
h
case
do
es
not
aect
the
nal
result
of
the
algorithm.
Ho
w
ev
er,
to
ac
hiev
e
faster
con
v
ergence,
w
e
lo
ok
for
the
constrain
t
plane
whic
h
is
violated
the
most
and
its
asso
ciated
neigh
b
oring
feature
to
con
tin
ue
the
v
erication
pro
cess
in
our
implem
en
tation.
W
e
can
also
calculate
ho
w
frequen
tly
w
e
need
to
c
hec
k
for
collision
b
y
taking
in
to
consideration
the
maxim
um
magnitude
of
acceleration
and
v
elo
cit
y
and
initial
separation.
W
e
use
a
priorit
y
queue
based
on
the
lo
w
er
b
ound
on
time
to
collision
to
detect
p
ossible
in
tersection
at
a
timely
fashion.
Here
the
step
size
is
adaptiv
ely
set
according
to
the
lo
w
er
b
ound
on
time
to
collision
w
e
calculate.
F
or
more
information
on
this
approac
h,
please
see
Chapter

of
this
thesis.
In
the
next
section,
w
e
will
sho
w
ho
w
these
applicabilit
y
conditions
are
used
to
up
date
a
pair
of
closest
features
b
et
w
een
t
w
o
con
v
ex
p
olyhedra
in
exp
ected
c
onstant
time.
.
The
Algorithm
Giv
en
a
pair
of
features,
there
are
altogether

p
ossible
cases
that
w
e
need
to
consider:
()
a
pair
of
v
ertices,
()
a
v
ertex
and
an
edge,
()
a
v
ertex
and
a
face,
()
a
pair
of
edges,
()
an
edge
and
a
face,
and
()
t
w
o
faces.
In
general,
the
case
of
t
w
o
faces
or
edge-face
rarely
happ
ens.
Ho
w
ev
er,
in
applications
suc
h
as
path
planning
w
e
ma
y
end
up
mo
ving
along
maximal
clearance
paths
whic
h
k
eep
t
w
o
faces
parallel,
or
an
edge
parallel
to
a
face.
It
is
imp
ortan
t
to
b
e
able
to
detect
when
w
e
ha
v
e
suc
h
a
degenerate
case.
..
Description
of
the
Ov
erall
Approac
h
Giv
en
a
pair
of
features
f
A
and
f
B
eac
h
from
con
v
ex
p
olyhedra
A
and
B
resp
ectiv
ely
,
except
for
cases
(),
()
and
(),
w
e
b
egin
b
y
computing
the
nearest
p
oin
ts
b
et
w
een
f
A
and
f
B
.
The
details
for
computing
these
nearest
p
oin
ts
b
et
w
een
f
A
and
f
B
are
rather
trivial,
th
us
omitted
here
(please
refer
to
App
endix
A
if
necessary).


Ho
w
ev
er,
w
e
w
ould
lik
e
to
reinforce
one
p
oin
t.
W
e
do
not
assume
innitely
long
edges
when
w
e
compute
these
nearest
p
oin
ts.
The
nearest
p
oin
ts
computed
giv
en
t
w
o
features
are
the
actual
p
oin
ts
on
the
features,
not
some
virtual
p
oin
ts
on
innitely
extended
edges,
i.e.
nearest
p
oin
ts
b
et
w
een
edges
ma
y
b
e
their
endp
oin
ts.
()
If
the
features
are
a
pair
of
v
ertices,
V
A
and
V
B
,
then
b
oth
V
A
and
V
B
ha
v
e
to
satisfy
the
p
oin
t-v
ertex
applicabilit
y
conditions
imp
osed
b
y
eac
h
other,
in
order
for
them
to
b
e
the
closest
features.
If
V
A
fails
the
p
oin
t-v
ertex
applicabilit
y
test
imp
osed
b
y
V
B
or
vice
v
ersa,
then
the
algorithm
will
return
a
new
pair
of
features,
sa
y
V
A
and
E
B
(the
edge
whose
corresp
onding
constrain
t
w
as
violated
in
the
p
oin
t-v
ertex
applicabilit
y
test),
then
con
tin
ue
v
erifying
the
new
feature
pair
un
til
it
nds
a
closest
pair.
()
Giv
en
a
v
ertex
V
A
and
an
edge
E
B
from
A
and
B
resp
ectiv
ely
,
the
algorithm
will
c
hec
k
whether
the
v
ertex
V
A
satises
the
p
oin
t-edge
applicabilit
y
conditions
imp
osed
b
y
the
edge
E
B
and
whether
the
nearest
p
oin
t
P
E
on
the
edge
E
B
to
V
A
satises
the
p
oin
t-v
ertex
applicabilit
y
conditions
imp
osed
b
y
the
v
ertex
V
A
.
If
b
oth
c
hec
ks
return
\true",
then
V
A
and
E
B
are
the
closest
features.
Otherwise,
a
corresp
onding
new
pair
of
features
(dep
ending
on
whic
h
test
failed)
will
b
e
returned
and
the
algorithm
will
con
tin
ue
to
w
alk
closer
and
closer
to
w
ard
a
pair
of
closest
features.
()
F
or
the
case
of
a
v
ertex
V
A
and
a
face
F
B
,
b
oth
of
the
p
oin
t-face
applicabilit
y
tests
imp
osed
b
y
the
face
F
B
to
the
v
ertex
V
A
and
the
p
oin
t-v
ertex
applicabilit
y
criterion
b
y
V
A
to
the
nearest
p
oin
t
P
F
on
the
face
m
ust
b
e
satised
for
this
pair
of
features
to
qualify
as
a
closest-feature
pair.
Otherwise,
a
new
pair
of
features
will
b
e
returned
and
the
algorithm
will
b
e
called
again
un
til
the
closest-feature
pair
is
found.
()
Similarly
,
giv
en
a
pair
of
edges
E
A
and
E
B
as
inputs,
if
their
nearest
p
oin
ts
P
A
and
P
B
satisfy
the
p
oin
t-edge
applicabilit
y
criterion
imp
osed
b
y
E
B
and
E
A
,
then
they
are
a
pair
of
closest
features
b
et
w
een
t
w
o
p
olyhedra.
If
not,
one
of
the
edges
will
b
e
c
hanged
to
a
neigh
b
oring
v
ertex
or
a
face
and
the
v
erication
pro
cess
will
b
e
done
again
on
the
new
pair
of
features.
()
When
a
giv
en
pair
of
features
is
an
edge
E
A
and
a
face
F
B
,
w
e
rst
need
to
decide


whether
the
edge
is
parallel
to
the
face.
If
it
is
not,
then
either
one
of
t
w
o
edge's
endp
oin
ts
and
the
face,
or
the
edge
and
some
other
edge
b
ounding
the
face
will
b
e
the
next
candidate
pair.
The
former
case
o
ccurs
when
the
head
or
tail
of
the
edge
satises
the
p
oin
t-face
applicabilit
y
condition
imp
osed
b
y
the
face,
and
when
one
endp
oin
t
of
E
is
closer
to
the
plane
con
taining
F
than
the
other
endp
oin
t
of
E
.
Otherwise,
the
edge
E
and
the
closest
edge
E
F
on
the
face's
b
oundary
to
E
will
b
e
returned
as
the
next
candidate
features.
If
the
edge
and
the
face
are
parallel,
then
they
are
the
closest
features
pro
vided
three
conditions
are
met.
(i)
The
edge
m
ust
cut
the
\applicabilit
y
prism"
P
r
ism
F
whic
h
is
the
region
b
ounded
b
y
the
constrain
t
planes
p
erp
endicular
to
F
B
and
passing
through
F
B
's
b
oundary
(or
the
region
sw
ept
out
b
y
F
B
along
its
normal
direction),
that
is
E
\
P
r
ism
F
=
;
(ii)
the
face
normal
m
ust
lie
b
et
w
een
the
face
normals
of
the
faces
b
ounding
the
edge
(see
Fig.
.,
Sec.
.,
and
the
pseudo
co
de
in
App
endix
B),
(iii)
the
edge
m
ust
lie
ab
o
v
e
the
face.
There
are
sev
eral
other
situations
whic
h
ma
y
o
ccur,
please
see
App
endix
B
or
the
pro
of
of
completeness
in
Sec.
.
for
a
detailed
treatmen
t
of
edge-face
case.
()
In
the
rare
o
ccasion
when
t
w
o
faces
F
A
and
F
B
are
giv
en
as
inputs,
the
algorithm
rst
has
to
decide
if
they
are
parallel.
If
they
are,
it
will
in
v
ok
e
an
o
v
erlap-c
hec
king
subroutine
whic
h
runs
in
linear
time
in
the
total
n
um
b
er
of
edges
of
F
A
and
F
B
.
(Note:
it
actually
runs
in
constan
t
time
after
w
e
prepro
cess
the
p
olyhedra,
since
no
w
all
the
faces
ha
v
e
constan
t
size
of
b
oundaries.)
If
they
are
b
oth
parallel,
F
A
's
pro
jection
do
wn
on
to
the
face
F
B
o
v
erlaps
F
B
and
eac
h
face
is
ab
o
v
e
the
other
face
relativ
e
to
their
out
w
ard
normals,
then
they
are
in
fact
the
closest
features.
But,
if
they
are
parallel
y
et
not
o
v
erlapping,
then
w
e
use
a
linear
time
pro
cedure
[]
to
nd
the
closest
pair
of
edges,
sa
y
E
A
and
E
B
b
et
w
een
F
A
and
F
B
,
then
in
v
ok
e
the
algorithm
again
with
this
new
pair
of
candidates
(E
A
;
E
B
).
If
F
A
and
F
B
are
not
parallel,
then
rst
w
e
nd
the
closest
feature
(either
a
v
ertex
or
an
edge)
f
A
of
F
A
to
the
plane
con
taining
F
B
and
vice
v
ersa.
Then,
w
e
c
hec
k
if
this
closest
feature
f
A
satisfy
the
applicabilit
y
constrain
t
imp
osed
b
y
F
B
.
If
so,
the
new
candidate
pair
will
b
e
this
closest
feature
f
A
and
F
B
;
otherwise,
w
e


E
NR
NL
NF
Object A
F
(a)
(b)
NF
E
F
Object A
E x NR
NL x E
PR
NL
PL
NR
Figure
.:
(a)
An
o
v
erhead
view
of
an
edge
lying
ab
o
v
e
a
face
(b)
A
side
view
of
the
face
out
w
ard
normal
b
ounded
b
y
the
t
w
o
out
w
ard
normals
of
the
edge's
left
and
righ
t
faces.


en
umerate
o
v
er
all
edge-pairs
b
et
w
een
t
w
o
faces
to
nd
a
closest
pair
of
edges
and
pro
ceed
from
there.
If
one
face
lies
on
the
\far
side"
of
the
other
(where
the
face
is
b
eneath
the
other
face
relativ
e
to
their
face
out
w
ard
normals)
or
vice
v
ersa,
then
the
algorithm
in
v
ok
es
a
linear-time
routine
to
step
a
w
a
y
from
this
lo
cal
minim
um
of
distance,
and
pro
vides
a
new
pair
of
features
m
uc
h
closer
than
the
previous
pair.
Please
refer
to
App
endix
B
for
a
complete
description
of
face-face
case.
..
Geometric
Subroutines
In
this
section,
w
e
will
presen
t
some
algorithms
for
geometric
op
erations
on
p
olytop
es.
They
are
used
in
our
implem
en
tation
of
the
algorithms
describ
ed
in
this
thesis.

Edge
&
F
ace's
Prism
In
tersection:
T
o
test
for
the
in
tersection
of
a
p
ar
al
lel
edge
E
A
to
F
B
within
a
prism
P
r
ism
F
sw
ept
out
b
y
a
face
F
B
along
its
face
normal
direction
N
F
,
w
e
c
hec
k
whether
p
ortion
of
this
edge
lies
within
the
in
terior
region
of
P
r
ism
F
.
This
region
can
b
e
visualized
as
the
space
b
ounded
b
y
n
planes
whic
h
are
p
erp
endicular
to
the
face
F
B
and
passing
through
the
n
edges
in
its
b
oundary
.
Supp
ose
F
i
is
a
face
of
the
prismatic
region
P
r
ism
F
and
p
erp
endicular
to
the
face
F
B
and
passing
through
the
edge
E
i
b
ounding
F
B
.
T
o
test
for
E
A
's
in
tersection
within
the
prism
P
r
ism
F
,
w
e
need
to
c
hec
k
whether
E
A
in
tersects
some
face
F
i
of
R
F
.
W
e
can
p
erform
this
test
with
easy
and
ecien
t
implem
e
n
tation

of
this
in
tersection
test.
W
e
rst
parameterize
the
edge
E
A
b
et
w
een
0
and
l
where
l
is
the
length
of
E
A
.
The
idea
is
to
in
tersect
the
in
terv
als
of
the
edge
E
A
con
tained
in
the
exterior

of
eac
h
half-space
with
eac
h
constrain
t
plane
in
the
prism
of
a
face
F
B
.

suggested
b
y
Brian
Mirtic
h

W
e
dene
the
exterior
half-space
of
eac
h
constrain
t
plane
to
b
e
the
half-space
where
all
the
p
oin
ts
satisfy
the
applicabilit
y
constrain
ts
imp
osed
b
y
F
B
's
b
oundary
.
The
"p
oin
t-cell-c
hec
kp"
routine
in
the
pseudo
co
de
can
clarify
all
the
am
biguit
y
.
Please
refer
to
App
endix
B
if
necessary
.


First,
w
e
decide
whether
the
edge
E
A
p
oin
ts
in
w
ard
or
out
w
ard
of
eac
h
h
yp
erplane
F
i
of
the
region
b
y
taking
the
inner
pro
duct
of
E
A
's
unit
directional
v
ector
with
F
i
's
out
w
ard
normal
N
F
i
.
Then,
w
e
can
decide
whic
h
p
ortion
of
E
A
in
tersect
the
exterior
half-space
of
F
i
b
y
taking
another
inner
pro
duct
of
the
head
of
E
A
and
F
i
's
out
w
ard
normal
normalized
b
y
the
inner
pro
duct
of
E
A
and
N
F
i
to
calculate
the
relativ
e
\inclusion"
factor
of
E
A
inside
of
the
prism
region.
The
relativ
e
(b
eginning
and
ending)
inclusion
factors
should
b
e
in
the
range
of
0
and
l
for
an
indication
of
an
edge-face's
prism
in
tersection.
Pseudo
co
de
for
this
approac
h
just
describ
ed
is
listed
in
App
endix
B.
This
geometric
test
is
used
in
our
implem
en
tation
of
distance
computation
algorithm
as
a
subroutine
to
c
hec
k
whether
a
giv
en
edge
in
tersects
the
V
oronoi
prism
of
a
giv
en
face
to
test
their
eligibilities
b
e
a
pair
of
closest
features.

F
ace
&
F
ace's
Prisim
In
tersection:
T
o
c
hec
k
if
t
w
o
con
v
ex
p
olygons
A
and
B
are
o
v
erlapping,
one
of
the
basic
approac
hes
is
to
v
erify
if
there
is
some
v
ertex
of
A
lying
on
the
\inside"
of
al
l
edges
in
the
b
oundary
of
B
or
vice
v
ersa.
The
\inside"
refers
to
the
interior
half-plane
of
the
edge,
not
necessary
the
in
terior
of
the
p
olygon.
A
n-sided
con
v
ex
p
olygon
is
formed
b
y
the
in
tersection
of
in
terior
half-planes
of
n
edges.
W
e
can
use
the
fact
that
t
w
o
p
olygons
do
no
o
v
erlap
if
there
exists
a
separating
line
passing
through
one
edge
in
the
b
oundary
of
either
face.
The
p
olygons
o
v
erlap,
if
and
only
if
none
of
the
edges
in
the
b
oundary
of
b
oth
p
olygons
forms
a
separating
line.
F
or
our
o
wn
application,
w
e
are
in
terested
to
v
erify
whether
a
face
A's
pro-
jection
do
wn
to
the
plane
con
taining
the
face
B
o
v
erlaps
with
the
face
B
,
where
A
and
B
are
p
ar
al
lel
and
in
R

.
T
o
nd
a
separating
line
b
et
w
een
t
w
o
suc
h
p
olygons
in
R

,
w
e
c
hec
k
if
there
exists
a
supp
orting
plane
passing
through
an
edge
in
the
b
oundary
of
one
p
olygon
suc
h
that
all
v
ertices
of
the
other
p
olygon
lies
in
the
\exte-
rior
half-space"
of
the
supp
orting
plane.
The
supp
orting
plane
is
p
erp
endicular
the
p
olygon
and
con
taining
an
edge
in
the
p
olygon's
b
oundary
.
This
approac
h
runs
in
O
(N

)
time
where
N
is
the
n
um
b
er
of
edges
of
eac
h
p
olygon.


An
elegan
t
approac
h
whic
h
runs
in
O
(M
+
N
)
can
b
e
found
in
[
,

],
where
the
t
w
o
p
olygons
A
and
B
eac
h
has
M
,
N
v
ertices
resp
ectiv
ely
.
This
approac
h
not
only
determines
whether
t
w
o
con
v
ex
p
olygon
in
tersect
or
not,
it
also
nds
the
in
tersections
b
et
w
een
them.
The
basic
approac
h
is
to
\adv
ance"
along
the
edges
of
A
and
B
to
nd
the
\in
ternal
c
hain"
of
v
ertices
whic
h
form
the
in
tersection
p
olygon.
Please
refer
to
[,

]
for
all
the
details.
..
Analysis
of
the
Algorithm
A
careful
study
of
all
of
the
ab
o
v
e
c
hec
ks
sho
ws
that
they
all
tak
e
time
in
prop
ortion
to
the
size
of
the
b
oundary
and
cob
oundary
of
eac
h
feature.
Therefore,
after
sub
division
prepro
cessing,
all
lo
cal
tests
run
in
constan
t
time
since
eac
h
feature
no
w
has
constan
t
n
um
b
er
of
neigh
b
oring
features.
The
only
exception
to
this
is
when
f
A
is
a
face,
and
f
B
lies
under
the
plane
con
taining
f
A
(or
vise
v
ersa).
In
this
case,
w
e
can
not
use
a
lo
cal
feature
c
hange,
b
ecause
this
ma
y
lead
to
the
pro
cedure
getting
stuc
k
in
a
lo
op.
Geometrically
,
w
e
are
mo
ving
around
the
lo
cal
minim
um
of
the
distance
function,
in
whic
h
w
e
ma
y
b
ecome
trapp
ed.
When
this
situation
o
ccurs,
w
e
searc
h
among
all
the
features
of
ob
ject
A
to
nd
a
closest
feature
to
the
f
B

.
This
is
not
a
constan
t
time
step,
but
note
that
it
is
imp
ossible
for
the
algorithm
to
mo
v
e
to
suc
h
an
opp
osing
face
once
it
is
initialized
and
giv
en
a
reasonable
step
size
(not
more
than
a
few
degrees
of
rotation).
So
this
situation
can
only
o
ccur
when
the
algorithm
is
rst
called
on
an
arbitrary
pair
of
features.
The
algorithm
can
tak
e
an
y
arbitrary
pair
of
features
of
t
w
o
p
olyhedra
and
nd
a
true
pair
of
closest
features
b
y
iterativ
ely
c
hec
king
and
c
hanging
features.
In
this
case,
the
running
time
is
prop
ortional
to
the
n
um
b
er
of
feature
pairs
tra
v
ersed
in
this
pro
cess.
It
is
not
more
than
the
pro
duct
of
the
n
um
b
ers
of
features
of
the
t
w
o
p
olyhedra,
b
ecause
the
distance
b
et
w
een
feature
pairs
m
ust
alw
a
ys
decrease
when
a
switc
h
is
made,
whic
h
mak
es
cycling
imp
ossible.
Empirically
,
it
seems
to
b
e
not
w
orse
than
linear
when
started
from
an
arbitrary
pair
of
features.
Ho
w
ev
er,
once

W
e
can
also
use
a
v
ery
exp
ensiv
e
pr
epr
o
c
essing
step
to
nd
a
feature
on
the
opp
osite
side
of
the
p
olyhedron
of
the
curren
t
face.
But,
this
in
v
olv
es
searc
hing
for
all
facets
whose
the
out
w
ard
normals
p
oin
ting
in
the
opp
osite
direction,
i.e.
the
dot
pro
duct
of
the
t
w
o
face
out
w
ard
normals
is
negativ
e.

	
it
nds
the
closest
pair
of
features
or
a
pair
in
their
vicinit
y
,
it
only
tak
es
exp
ected
constan
t
time
to
up
date
a
closest
feature
pair
as
the
t
w
o
ob
jects
translate
and
rotate
in
three-space.
The
o
v
erall
computational
time
is
shorter
in
comparison
with
other
algorithms
a
v
ailable
at
the
presen
t
time.
If
the
t
w
o
ob
jects
are
just
touc
hing
or
in
tersecting,
it
giv
es
an
error
message
to
indicate
collision
and
terminates
the
pro
cedure
with
the
con
tacting-feature
pair
as
returned
v
alues.
A
pseudo
co
de
is
giv
en
in
App
endix
B.
The
completeness
pro
of
of
this
algorithm
is
presen
ted
in
Sec.
.
and
it
should
giv
e
readers
a
b
etter
insigh
t
to
the
algorithm.
..
Exp
ected
Running
Time
Our
approac
h
w
orks
w
ell
b
y
taking
adv
an
tage
of
\con
tin
uit
y
of
motion"
or
geometric
coherence
b
et
w
een
discrete
time
steps.
When
the
motion
is
abruptly
large,
the
p
erformance
do
esn't
ac
hiev
e
the
p
oten
tial
of
this
algorithm
though
it
still
t
ypically
nds
a
pair
of
closest
features
in
sub-linear
time.
One
of
the
frequen
tly
ask
ed
questions
is
ho
w
to
c
ho
ose
step
size
so
that
w
e
can
preserv
e
the
geometric
coherence
to
exploit
the
lo
calit
y
of
closest
feature
pairs
in
small
discrete
steps.
This
question
can
b
e
addressed
indirectly
b
y
the
follo
wing
analysis:
F
or
relativ
ely
spherical
ob
jects,
the
exp
ected
running
time
t
is
prop
ortional
to
p
n.
F
or
cylindrical
ob
jects,
the
exp
ected
running
time
t
is
prop
ortional
to
n,
where
n
is
the
n
um
b
er
of
faces
(or
v
ertices)
p
er
p
olyhedron.
This
is
deriv
ed
from
the
follo
wing
reasoning:
Giv
en
a
tessellated
sphere
whic
h
has
N
faces
around
its
equator,
when
the
ob
jects
are
rotated
X
degrees,
it
tak
es
roughly
k
X
0=
N
=
K

N
steps
to
up
date
the
closest
feature
pair,
where
k
and
K
are
the
adjustmen
t
constan
ts.
And
the
total
n
um
b
er
of
features
(v
ertices)
for
the
sphere
is
O
(N

).
Therefore,
the
n
um
b
er
of
steps
(or
accum
ulated
running
time)
is
prop
ortional
to
p
n,
where
n
=
O
(N

)
is
the
total
n
um
b
er
of
features
(v
ertices
or
faces).
A
similar
argumen
t
holds
for
the
cylindrical
ob
jects.
With
this
observ
ation,
w
e
can
set
the
step
size
to
preserv
e
the
coherence
at
eac
h
step.
Ho
w
ev
er,
it
is
not
necessary
since
the
o
v
erall
run
time
is
go
v
erned
b
y
the

0
n
um
b
er
of
in
termediate
feature
pairs
tra
v
ersed
in
the
pro
cess
and
the
algorithm
can
alw
a
ys
nd
the
pair
of
closest
features,
giv
en
an
y
step
size.
.
Pro
of
of
Completeness
The
algorithm
tak
es
an
y
pair
of
features
on
t
w
o
p
olyhedra
and
returns
a
pair
of
closest
features
b
y
iterativ
ely
c
hec
king
and
c
hanging
features.
Through
eac
h
applicabilit
y
test,
the
algorithm
steps
closer
and
closer
to
a
pair
of
closest
features.
That
is,
after
eac
h
applicabilit
y
c
hec
k,
the
distance
b
et
w
een
the
up
dated
feature-pair
is
smaller
than
that
of
the
previous
feature-pair
if
a
switc
h
of
feature-pairs
is
made.
T
o
v
erify
if
a
giv
en
pair
of
features
is
the
closest
pair,
eac
h
step
tak
es
running
time
prop
ortional
to
the
n
um
b
er
of
neigh
b
oring
features
(b
oundaries
and/or
cob
oundaries
of
the
features).
Since
eac
h
feature
has
a
constan
t
n
um
b
er
of
neigh
b
oring
features,
eac
h
v
erication
step
tak
es
only
constan
t
time
in
all
cases
except
when
a
feature
lies
b
eneath
a
face
and
inside
the
face's
V
oronoi
region
(this
corresp
onds
to
a
lo
cal
minim
um
of
distance
function).
Th
us
w
e
call
this
pair
of
features
as
an
\exceptional"
feature
pair.
This
situation
only
o
ccurs
after
a
large
motion
in
a
single
step
when
the
actual
closest
feature
of
A
is
on
the
other
(or
opp
osite)
side
of
the
last
closest
feature
on
A.
Let
n
b
e
the
n
um
b
er
of
features
from
eac
h
ob
ject.
If
the
algorithm
nev
er
encoun
ters
a
lo
cal
minim
um
,
the
algorithm
will
return
a
pair
of
closest
feature
in
O
(n

)
time
since
there
are
at
most
n

feature-pairs
to
v
erify
using
constan
t-time
applicabilit
y
criteria
and
other
subroutines.
If
the
algorithm
runs
in
to
an
exceptional
pair
of
features,
then
it
is
necessary
to
in
v
ok
e
a
linear-time
routine
to
con
tin
ue
the
v
erication
pro
cess.
W
e
will
sho
w
later
that
the
algorithm
calls
the
linear-time
routine
at
most
n
times.
Hence,
the
algorithm
con
v
erges
in
O
(n

)
time.
Lemma

Eac
h
applicabilit
y
test
and
closest
feature-pair
v
erifying
subroutine
will
necessarily
return
a
new
pair
of
features
closer
in
distance
than
the
previous
pair
when
a
switc
h
of
feature-pairs
is
made.


Pro
of:
The
algorithm
w
orks
b
y
nding
a
pair
of
closest
features.
There
are
t
w
o
categories:
()
non-degenerate
cases
{
v
ertex-v
ertex,
v
ertex-edge,
and
v
ertex-face
()
degenerate
cases
{
edge-edge,
edge-face,
and
face-face.
F
or
non-degenerate
and
edge-edge
cases,
the
algorithm
rst
tak
es
an
y
pair
of
features
f
A
and
f
B
,
then
nd
the
nearest
p
oin
ts
P
A
and
P
B
b
et
w
een
them.
Next,
it
c
hec
ks
eac
h
nearest
p
oin
t
against
the
applicabilit
y
constrain
ts
of
the
other
feature.
The
distance
b
et
w
een
t
w
o
features
is
the
distance
b
et
w
een
the
nearest
p
oin
ts
of
t
w
o
features,
whic
h
is
the
same
as
the
distance
b
et
w
een
one
nearest
p
oin
t
to
the
other
feature.
Therefore,
if
w
e
can
nd
another
feature
f
0
A
closer
to
P
B
or
another
feature
f
0
B
closer
to
P
A
,
w
e
ha
v
e
sho
wn
the
distance
b
et
w
een
eac
h
candidate
feature
pair
is
less
after
the
switc
h.
Please
note
that
edge-edge
is
a
sp
ecial
degenerate
case,
since
it
can
p
ossibly
ha
v
e
either
one
pair
or
man
y
pairs
of
nearest
p
oin
ts.
When
a
pair
of
edges
has
one
pair
of
nearest
p
oin
ts,
it
is
considered
as
all
other
non-degenerate
cases.
When
b
oth
edges
are
parallel,
they
can
p
ossibly
ha
v
e
innitely
man
y
pairs
of
nearest
p
oin
ts.
In
suc
h
a
case,
w
e
still
treat
it
as
the
other
non-degenerate
cases
b
y
c
ho
osing
the
nearest
p
oin
ts
to
b
e
the
midp
oin
ts
of
the
line
segmen
ts
whic
h
con
tains
the
en
tire
sets
of
nearest
p
oin
ts
b
et
w
een
t
w
o
edges.
In
this
manner,
the
edge-edge
degenerate
case
can
b
e
easily
treated
as
in
the
other
non-degenerate
cases
and
the
pro
of
of
completeness
applies
here
as
w
ell.
The
other
t
w
o
degenerate
cases
m
ust
b
e
treated
dieren
tly
since
they
ma
y
con
tain
innitely
man
y
closest
p
oin
t
pairs.
W
e
w
ould
lik
e
to
recall
that
edges
and
faces
are
treated
as
op
en
subsets
of
lines
and
planes
resp
ectiv
ely
.
That
is,
the
edge
is
considered
as
the
set
of
p
oin
ts
b
et
w
een
t
w
o
endp
oin
ts
of
the
edge,
excluding
the
head
and
the
tail
of
the
edge;
similarly
,
a
face
is
the
set
of
p
oin
ts
in
terior
to
its
b
oundary
(excluding
the
edges
and
v
ertices
in
its
b
oundary).
This
guaran
tees
that
when
a
switc
h
of
features
is
made,
the
new
features
are
strictly
closer.
W
e
will
rst
sho
w
that
eac
h
applicabilit
y
test
returns
a
pair
of
candidate
features
closer
in
distance
than
the
previous
pair
when
a
switc
h
of
feature
pairs
is
made.
Then,
w
e
sho
w
the
closest
feature
v
erifying
subroutines
for
b
oth
edge-face
and


face-face
cases
necessarily
return
a
closer
pair
of
features
when
a
switc
h
of
feature
pairs
is
made.
(I)
P
oin
t-V
ertex
Applicabilit
y
Criterion
If
v
ertex
V
is
truly
the
closest
feature
to
p
oin
t
P
,
then
P
m
ust
lie
within
the
region
b
ounded
b
y
the
planes
whic
h
are
p
erp
endicular
to
the
cob
oundaries
of
V
(the
edges
touc
hing
V
).
If
so,
the
shortest
distance
b
et
w
een
P
and
the
other
ob
ject
is
clearly
the
distance
b
et
w
een
P
and
V
(b
y
the
denition
of
V
oronoi
region)
.
When
P
lies
outside
one
of
the
plane
b
oundaries,
sa
y
C
E

,
the
constrain
t
plane
of
an
edge
E

touc
hing
V
,
then
there
is
at
least
one
p
oin
t
on
E

closer
to
P
than
V
itself,
i.e.
the
distance
b
et
w
een
the
edge
E

(whose
constrain
t
is
violated)
and
P
is
shorter
than
the
distance
b
et
w
een
V
and
P
.
This
can
b
e
seen
from
Fig...
When
a
p
oin
t
P
lies
directly
on
the
bisector
C
E

b
et
w
een
V
and
E

,
then
P
is
equi-distan
t
from
b
oth
features;
else,
P
is
closer
to
V
if
P
is
inside
of
V
's
V
oronoi
region,
and
vice
v
ersa.
Therefore,
eac
h
P
oin
t-V
ertex
Applicabilit
y
test
is
guaran
teed
to
generate
a
pair
of
features
that
is
closer
in
distance
than
the
previous
pair
(whic
h
fails
the
P
oin
t-V
ertex
Applicabilit
y
test),
when
a
switc
h
of
feature
pairs
o
ccurs.
(I
I)
P
oin
t-Edge
Applicabilit
y
Criterion
If
edge
E
is
really
the
closest
feature
to
p
oin
t
P
,
then
P
m
ust
lie
within
the
region
b
ounded
b
y
the
four
constrain
t
planes
generated
b
y
the
cob
oundary
(the
left
and
righ
t
faces)
and
b
oundary
(the
t
w
o
end
p
oin
ts)
of
E
.
This
is
the
V
oronoi
region
of
E
.
If
this
is
the
case,
the
shortest
distance
b
et
w
een
P
and
the
other
ob
ject
is
the
distance
b
et
w
een
P
and
E
(see
Fig..
and
Sec.
..
for
the
construction
of
p
oin
t-
edge
constrain
t
planes.)
When
P
fails
an
applicabilit
y
constrain
t,
sa
y
C
F
,
imp
osed
b
y
the
left
(or
righ
t)
face
of
the
edge
E
,
there
is
at
least
one
p
oin
t
on
the
corresp
onding
face
closer
to
P
than
E
,
i.e.
the
distance
b
et
w
een
P
and
the
corresp
onding
face
is
shorter
than
the
distance
b
et
w
een
P
and
E
(as
in
Fig..	).
If
P
fails
the
applicabilit
y
criterion
C
V
imp
osed
b
y
the
head
(or
tail)
of
E
,
then
P
is
closer
to
the
corresp
onding
endp
oin
t
than
to
E
itself
(as
in
Fig..0).
Therefore,
the
distance
b
et
w
een
the
new
pair
of
features
is
guaran
teed
to
b
e
shorter
than
that
of
the
previous
pair
whic
h
fails


V
E1
E2
E3
P
Voronoi Region
a
b
b < a
Figure
.:
A
Side
View
for
P
oin
t-V
ertex
Applicabilit
y
Criterion
Pro
of
the
P
oin
t-Edge
Applicabilit
y
Criterion,
when
a
switc
h
of
feature
pairs
is
made.
(I
I
I)
P
oin
t-F
ace
Applicabilit
y
Criterion
If
the
face
F
is
actually
the
closest
feature
to
a
p
oin
t
P
,
then
P
m
ust
lie
within
the
prism
b
ounded
b
y
the
constrain
t
planes
whic
h
are
orthogonal
to
F
and
con
taining
the
edges
in
F
's
b
oundary
and
ab
o
v
e
F
(b
y
the
denition
of
V
oronoi
region
and
p
oin
t-face
applicabilit
y
criterion
in
Sec.
..).
If
P
fails
one
applicabilit
y
constrain
t,
sa
y
C
E

imp
osed
b
y
one
of
F's
edges,
sa
y
E

,
then
E

is
closer
to
P
than
F
itself.
When
a
p
oin
t
lies
b
eneath
a
face
F
and
within
the
prism
b
ounded
b
y
other
constrain
t
planes,
it
is
p
ossible
that
P
(and
of
course,
the
ob
ject
A
whic
h
con
tains
P
)
lies
inside
of
the
ob
ject
B
con
taining
F
.
But,
it
is
also
p
ossible
that
P
lies
out
side
of
B
and
on
the
other
side
of
B
from
F.
This
corresp
onds
to
a
lo
cal
minim
um
of
distance
function.
It
requires
a
linear-time
routine
to
step
to
the
next
feature-pair.
The
linear-time
routine
en
umerates
all
features
on
the
ob
ject
B
and
searc
hes
for
the
closest
one
to
the
feature
f
A
con
taining
P
.
This
necessarily
decreases
the
distance


b
E
P
b  >  a
Voronoi Rgn.
a
Figure
.	:
An
Ov
erhead
View
for
P
oin
t-Edge
Applicabilit
y
Criterion
Pro
of
P
E              HE
TE
Voronoi Region
Figure
.0:
A
Side
View
for
P
oin
t-Edge
Applicabilit
y
Criterion
Pro
of


F
EF
NF
Voronoi Region
P
Figure
.:
A
Side
View
for
P
oin
t-F
ace
Applicabilit
y
Criterion
Pro
of
b
et
w
een
the
closest
feature
candidates
base
up
on
the
minim
um
distance
information
during
the
searc
h.
Therefore,
w
e
can
conclude
that
the
distance
decreases
when
a
switc
h
of
feature
pairs
is
made
as
the
result
of
P
oin
t-F
ace
Applicabilit
y
T
est.
(IV)
V
erifying
Subroutines
in
Edge-F
ace
Case
With
the
exception
of
edge-edge
(as
men
tioned
earlier
in
the
b
eginning
of
the
pro
of
),
only
edge-face
and
face-face
ma
y
ha
v
e
m
ultiple
pairs
of
closest
p
oin
ts
and
require
a
more
complex
treatmen
ts.
Whereas,
the
closest
feature
v
erication
for
the
other
non-degenerate
cases
and
edge-edge
solely
dep
ends
on
p
oin
t-v
ertex,
p
oin
t-edge,
and
p
oin
t-face
applicabilit
y
tests
whic
h
w
e
ha
v
e
already
studied.
No
w
w
e
will
examine
eac
h
of
these
t
w
o
cases
closely
.

Edge-F
ac
e
(E
,
F
)
The
inden
tation
corresp
onds
to
the
lev
el
of
nested
lo
ops
in
the
pseudo
co
de
(Ap-
p
endix
B).
Please
cross-reference
if
necessary
.


Giv
en
an
edge
E
and
a
face
F
,
the
algorithm
rst
c
hec
ks
IF
E
AND
F
ARE
P
ARALLEL,
i.e.
the
t
w
o
endp
oin
ts
H
E
and
T
E
are
equi-distan
t
from
the
face
F
(i.e.
their
signed
distance
is
the
same).
The
signe
d
distance
b
et
w
een
H
E
and
F
can
b
e
computed
easily
b
y
H
E

N
F
where
N
F
is
F
's
unit
out
w
ard
normal
and
similarly
for
the
signed
distance
b
et
w
een
F
and
H
T
.
THEN,
when
the
head
H
E
and
tail
T
E
of
the
edge
E
are
equi-distan
t
from
the
face
F
,
the
subroutine
c
hec
ks
IF
E
INTERSECTS
F
'S
PRISM
REGION,
(i.e.
the
region
b
ounded
b
y
F
's
constrain
t
planes
constructed
from
the
edges
in
F
's
b
oundary).
THEN,
if
E
in
tersects
the
prism
region
of
F
,
the
algorithm
c
hec
ks
IF
THE
HEAD
H
E
(OR
T
AIL
T
E
)
OF
E
LIES
ABO
VE
THE
F
A
CE
F
.
THEN,
it
will
c
hec
k
IF
THE
F
A
CE
OUTW
ARD
NOR-
MAL
N
F
IS
\BOUNDED"
BY
THE
NORMALS
OF
THE
EDGE'S
LEFT
AND
RIGHT
F
A
CES,
sa
y
N
L
and
N
R
resp
ectiv
ely
,
to
v
erify
that
the
face
F
lies
inside
the
V
oronoi
region
of
the
edge
E
,
not
in
the
V
oronoi
region
of
E
's
left
or
righ
t
face
(F
L
or
F
R
).
This
is
done
b
y
c
hec
king
if
(N
L

~
E
)

N
F
>
0
and
(
~
E

N
R
)

N
F
>
0,
where
N
F
is
the
out
w
ard
normal
of
the
face
F
,
~
E
is
the
edge
v
ector
(as
describ
ed
in
Sec.
..),
and
N
R
,
N
L
denote
the
out
w
ard
normal
of
the
edge's
righ
t
and
left
face
resp
ectiv
ely
.
THEN,
the
edge
E
and
the
face
F
will
b
e
returned
as
the
closest
feature
pair,
since
E
and
F
lie
within
the
V
oronoi
region
of
eac
h
other.
ELSE,
it
returns
the
righ
t
or
left
face
(F
R
or
F
L
)
of
E
,
whic
h
ev
er
is
closer
to
F
.
ELSE,
when
the
head
H
E
(implies
E
also)
lies
b
eneath
F
,
then
it
will
in
v
ok
e
a
subroutine
e-nd-min
whic
h
nds
the
closest
feature
on
the
p
olyhedron
B
con
taining
F
to
E
b
y
en
umerating
all
the
features
on
B
.
Then
the
algorithm
will
return
E
and
this
new
feature
f
B
as
the
next
candidates
for
the
closest
feature
pair
v
erication.
ELSE,
E
do
es
not
in
tersect
the
prism
dened
b
y
F
's
b
oundary
edges,
then
there
is
at
least
one
edge
of
F
's
b
oundary
whic
h
is
closer
to
E


than
the
in
terior
of
F
is
to
E
(b
y
the
denition
of
V
oronoi
region).
So,
when
the
test
is
failed,
it
calls
a
constan
t
time
routine
(whic
h
tak
es
time
prop
ortional
to
the
constan
t
n
um
b
er
of
face's
b
oundary)
and
returns
the
edge
E
and
the
closest
edge
or
v
ertex,
sa
y
f
F
,
on
the
F
's
b
oundary
to
E
.
ELSE,
the
algorithm
c
hec
ks
IF
ONE
END
POINT
LIES
ABO
VE
THE
F
A
CE
F
AND
THE
OTHER
LIES
BENEA
TH
F
.
THEN,
if
so
there
is
one
edge
on
F
's
b
oundary
whic
h
is
closer
to
E
than
the
in
terior
of
F
.
So,
the
algorithm
will
nd
the
closest
edge
or
v
ertex
f
B
,
whic
h
has
the
minim
um
distance
to
E
among
all
edges
and
v
ertices
in
F
's
b
oundary
,
and
return
(E
,
f
B
)
as
the
next
candidate
pair.
ELSE,
one
endp
oin
t
H
E
(or
T
E
)
of
E
is
closer
(the
magnitude
j
V
E

N
F
j
instead
of
the
signed
distance
is
used
for
comparison
here)
to
F
than
the
other
endp
oin
t,
the
algorithm
will
c
hec
k
IF
THE
CLOSER
ENDPOINT
V
E
LIES
INSIDE
OF
F
's
PRISM
REGION
(b
ounded
b
y
constrain
t
planes
generated
b
y
edges
in
F
's
b
oundary),
C
el
l
F
,
as
in
the
v
ertex-face
case.
THEN,
if
closer
endp
oin
t
V
E
lies
inside
of
F
's
prism
region,
then
the
algorithm
will
next
v
erify
IF
THIS
ENDPOINT
LIES
ABO
VE
THE
F
A
CE
F
(to
detect
a
lo
cal
minim
um
of
distance
function).
THEN,
if
V
E
(the
closer
endp
oin
t
to
F
)
is
ab
o
v
e
F
the
algorithm
next
v
eries
IF
THE
CLOSEST
POINT
P
F
ON
F
TO
V
E
SA
TISFIES
V
E
'S
APPLICA-
BILITY
CONSTRAINTS.
THEN,
if
so
the
algorithm
returns
V
E
and
F
as
the
closest
feature
pair.
ELSE
some
constrain
t
plane
in
V
E
's
V
oronoi
cell
C
el
l
V
E
is
violated.
This
constrain
t
plane
is
generated
b
y
an
edge,
sa
y
E
0
,
in
V
E
's
cob
ound-
ary
.
This
edge
E
0
is
closer
to
F
,
so
the
algo-
rithm
will
return
(E
0
,
F
)
as
the
next
candidate
pair.
ELSE,
if
the
closer
endp
oin
t
V
E
of
E
lies
b
eneath
F
,
then
the
algorithm
nds
the
closest
feature
f
B
on
the
p
olyhedron
B
to
V
E
The
algorithm
returns
(V
E
,
f
B
)
as
the
next
candidate
feature
pair.


ELSE,
if
the
closer
endp
oin
t
V
E
of
E
to
F
lies
outside
of
F
's
prism
region,
then
there
is
one
edge
on
F
's
b
oundary
whic
h
is
closer
to
E
than
the
in
terior
of
F
.
So,
the
algorithm
will
nd
the
closest
edge
or
v
ertex
f
B
,
whic
h
has
the
minim
um
distance
to
E
among
all
edges
and
v
ertices
in
F
's
b
oundary
,
and
return
(E
,
f
B
)
as
the
next
candidate
pair.
(V)
V
erifying
Subroutines
in
F
ace-F
ace
Case

F
ac
e-F
ac
e
(F
A
,
F
B
)
The
n
um
b
ering
system
(n)
in
this
pro
of
is
annotated
for
easy
reference
within
the
pro
of.
The
inden
tation
corresp
onds
to
the
lev
el
of
nested
lo
ops
in
the
pseudo
co
de
(App
endix
B).
(0)
Giv
en
t
w
o
faces,
F
A
and
F
B
,
the
algorithm
rst
c
hec
ks
IF
THEY
ARE
P
AR-
ALLEL.
()
THEN,
if
they
are
parallel,
it
in
v
ok
es
a
subroutines
whic
h
runs
in
constan
t
time
(prop
ortional
to
the
pro
duct
of
n
um
b
ers
of
b
oundaries
b
et
w
een
t
w
o
faces,
whic
h
is
a
constan
t
after
sub
division)
to
c
hec
k
IF
THE
OR
THOGONAL
PR
OJECTION
OF
F
A
ON
TO
THE
PLANE
OF
F
B
O
VERLAPS
F
B
(i.e.
F
A
in
tersects
the
prism
region
of
F
B
).
()
THEN,
if
they
o
v
erlapp
ed,
the
algorithm
next
c
hec
ks
IF
P
A
(implies
F
A
as
w
ell,
since
t
w
o
faces
are
parallel)
LIES
ABO
VE
F
B
,
where
P
A
is
one
of
the
p
oin
ts
on
F
A
and
its
pro
jection
do
wn
to
the
F
B
is
in
the
o
v
erlap
region.
()
THEN,
if
P
A
(th
us
F
A
)
lies
ab
o
v
e
F
B
,
the
algorithm
next
c
hec
ks
IF
P
B
(THUS
F
B
)
ALSO
LIES
ABO
VE
F
A
,
where
P
B
is
one
of
the
p
oin
ts
and
its
pro
jection
do
wn
to
the
F
B
is
in
the
o
v
erlap
region.
()
THEN,
if
P
B
(th
us
F
B
)
is
ab
o
v
e
F
A
and
vice
v
ersa,
w
e
ha
v
e
a
pair
of
closest
p
oin
ts
(P
A
,
P
B
)
satisfy
the
resp
ectiv
e
applicabilit
y
constrain
ts
of
F
B
and
F
A
.
So,
P
A
and
P
B
are
the
closest
p
oin
ts
on
A
and
B
;
and
the

	
features
con
taining
them,
F
A
and
F
B
,
will
b
e
returned
as
the
closest
features.
()
ELSE,
if
P
B
(th
us
F
B
)
lies
b
eneath
F
A
,
then
the
algorithm
nds
the
closest
feature
f
A
on
p
olyhedron
A
con
taining
F
A
to
F
B
b
y
en
umerating
all
features
of
A
to
searc
h
for
the
feature
whic
h
has
minim
um
distance
to
F
B
.
So,
the
new
pair
of
features
(f
A
,
F
B
)
is
guaran
teed
to
b
e
closer
than
(F
A
,
F
B
).
()
ELSE,
if
P
A
(th
us
F
A
)
lies
b
eneath
F
B
,
the
algorithm
nds
the
closest
feature
f
B
on
p
olyhedron
B
con
taining
F
B
to
F
A
and
returns
(F
A
,
f
B
)
as
the
next
candidate
feature
pair.
This
pair
of
new
features
has
to
b
e
closer
than
F
A
to
F
B
since
f
B
has
the
shortest
distance
among
all
features
on
B
to
F
A
.
()
ELSE,
if
F
A
and
F
B
are
parallel
but
the
pro
jection
of
F
A
do
es
not
o
v
erlap
F
B
,
a
subroutine
en
umerates
all
p
ossible
com
bination
of
edge-
pairs
(one
from
the
b
oundary
of
eac
h
face
resp
ectiv
ely)
and
computes
the
distance
b
et
w
een
eac
h
edge-pair
to
nd
a
pair
of
closest
edges
whic
h
has
the
minim
um
distance
among
all.
This
new
pair
of
edges
(E
A
,
E
B
)
is
guaran
teed
to
b
e
closer
than
the
t
w
o
faces,
since
t
w
o
faces
F
A
and
F
B
do
not
con
tain
their
b
oundaries.
()
ELSE,
if
F
A
and
F
B
are
not
parallel,
this
implies
there
is
at
least
one
v
ertex
or
edge
on
F
A
closer
to
F
B
than
F
A
to
F
B
or
vice
v
ersa.
So,
the
algorithm
rst
nds
the
closest
v
ertex
or
edge
on
F
A
to
the
plane
con
taining
F
B
,

B
.
(	)
VER
TEX:
if
there
is
only
a
single
closest
v
ertex
V
A
to
the
plane
con
taining
F
B
,
V
A
is
closer
to
F
B
than
F
A
is
to
F
B
since
t
w
o
faces
are
not
parallel
and
their
b
oundaries
m
ust
b
e
closer
to
eac
h
other
than
their
in
terior.
Next,
the
algorithm
c
hec
ks
if
V
A
lies
within
the
V
oronoi
region
of
F
B
.
(0)
THEN,
if
so
V
A
and
F
B
will
b
e
returned
as
the
next
can-
didate
pair.
()
ELSE,
the
algorithm
nds
the
closest
v
ertex
(or
edge)
on
F
B
to

A
,
and
pro
ceeds
as
b
efore.
()
VER
TEX:
if
there
is
only
a
single
v
ertex
V
B
clos-
est
to
the
plane

A
con
taining
F
A
,
the
algorithm
c
hec
ks
if
V
B
lies
inside
of
F
A
's
V
oronoi
region
b
ounded
b
y
the
constrain
t
planes
generated
b
y
the
edges
in
F
A
's
b
ound-
ary
and
ab
o
v
e
F
A
.

0
()
THEN,
if
V
B
lies
inside
of
F
A
's
V
oronoi
region,
then
F
A
and
V
B
will
naturally
b
e
the
next
candidate
pair.
This
new
pair
of
features
is
closer
than
the
previous
pair
as
already
ana-
lyzed
in
(0).
()
ELSE,
the
algorithm
p
erforms
a
searc
h
of
all
edge
pairs
from
the
b
oundary
of
F
A
and
F
B
and
returns
the
closest
pair
(E
A
,
E
B
)
as
the
next
candidate
feature
pair.
()
EDGE:,
similarly
if
the
closest
feature
on
F
B
to

A
is
an
edge
E
B
,
the
algorithm
once
again
c
hec
ks
if
E
B
cuts
F
A
's
prism
to
determine
whether
F
A
and
E
B
are
the
next
candidate
features.
()
THEN,
the
algorithm
c
hec
ks
IF
THE
END
POINT
OF
E
B
LIES
ABO
VE
F
A
.
()
THEN,
the
new
pair
of
candidate
features
is
F
A
and
E
B
since
E
B
lies
within
F
A
's
V
oronoi
region.
()
ELSE,
the
algorithm
searc
hes
for
the
closest
feature
f
A
whic
h
has
the
minim
um
distance
among
all
other
features
on
A
to
E
B
and
returns
(f
A
,
E
B
)
as
the
next
pair
of
candidate
features.
()
ELSE,
if
not,
then
this
implies
that
nei-
ther
face
con
tains
the
closest
p
oin
ts
since
nei-
ther
F
A
nor
F
B
's
V
oronoi
regions
con
tain
a
clos-
est
p
oin
t
from
the
other's
b
oundary
.
So,
the
algorithm
will
en
umerate
all
the
edge-pairs
in
the
b
oundaries
of
F
A
and
F
B
to
nd
the
pair
of
edges
whic
h
is
closest
in
distance.
This
new
pair
of
edges
(E
A
,
E
B
)
is
guaran
teed
to
b
e
closer
than
the
t
w
o
faces.
(	)
EDGE:
if
there
are
t
w
o
closest
v
ertices
on
F
A
to

B
,
then
the
edge
E
A
con
taining
the
t
w
o
v
ertices
is
closer
to

B
than
F
A
is.
Next,
the
algorithm
c
hec
ks
IF
E
A
INTERSECTS
THE
PRISM
REGION
OF
F
B
,
as
in
the
edge-face
case.
(0)
THEN,
the
algorithm
c
hec
ks
IF
THE
END
POINT
OF
E
A
LIES
ABO
VE
F
B
.
()
THEN,
if
so
the
edge
E
A
and
F
B
will
b
e
returned
as
the
next
candidate
pair.


()
ELSE,
the
algorithm
searc
hes
for
the
closest
fea-
ture
f
B
whic
h
has
the
minim
um
distance
among
all
other
features
on
B
to
E
A
and
returns
(E
A
,
f
B
)
as
the
next
pair
of
candidate
features.
()
ELSE,
if
this
is
not
the
case,
then
the
algorithm
nds
the
closest
v
ertex
(or
edge)
on
F
B
to
the
plane
con
taining
F
A
,
sa
y

A
and
pro
ceeds
as
b
efore,
from
blo
c
k
()
to
blo
c
k
().
In
either
degenerate
case
(edge-face
or
face-face),
a
pair
of
features
closer
in
distance
is
alw
a
ys
pro
vided
when
a
switc
h
of
feature
pairs
is
made.
All
the
v
eri-
fying
subroutines
run
in
c
onstant
time
(prop
ortional
to
the
n
um
b
er
of
b
oundary
or
cob
oundary
of
features
or
the
pro
duct
of
n
um
b
ers
of
b
oundaries
b
et
w
een
t
w
o
fea-
tures),
except
where
an
edge
lies
b
eneath
a
face
or
when
a
face
lies
b
eneath
a
face.
In
suc
h
lo
cal
cases,
a
linear-time
routine
is
in
v
ok
ed.
T
o
sum
up,
all
the
applicabilit
y
tests
and
closest
feature-pair
v
erifying
sub-
routines
generate
a
pair
of
new
features
closer
in
distance
than
the
previous
pair
when
a
switc
h
of
feature-pairs
is
made.
Corollary
The
algorithm
tak
es
O
(n

)
time
to
nd
the
closest
feature
pair,
since
eac
h
pair
of
features
is
visited
at
most
once,
and
eac
h
step
tak
es
at
most
linear
time.
O
(n

)
is
a
rather
lo
ose
upp
er
b
ound.
W
e
can
nd
a
tigh
ter
b
ound
on
the
running
time
if
w
e
study
the
lo
cal
minim
um
case
in
greater
details.
As
a
result
of
a
new
analysis,
w
e
claim
in
Lemma

that
the
algorithm
should
con
v
erge
in
O
(n

)
time.
The
pro
of
is
stated
b
elo
w.
Lemma

The
algorithm
will
con
v
erge
in
O
(n

)
time.
Pro
of:
Except
for
the
case
of
a
lo
cal
minim
um
whic
h
corresp
onds
to
the
situation
where
one
feature
lies
under
the
plane
con
taining
the
other
face,
all
the
applicabilit
y
tests
and
subroutines
run
in
constan
t
time.
Th
us
the
o
v
erall
running
time
is
O
(n

)
in
this
case,
since
the
algorithm
can
only
exhaustiv
ely
visit
O
(n

)
pairs
of
features


and
no
lo
oping
can
p
ossibly
exist
if
it
do
esn't
encoun
ter
lo
cal
minima
(b
y
Lemma
).
As
men
tioned
earlier,
when
a
lo
cal
minim
um
is
encoun
tered,
a
linear-time
routine
is
in
v
ok
ed.
But
it
is
not
necessary
to
call
this
linear-time
routine
more
than
n
times
to
nd
the
closest
feature-pair.
The
reasons
are
the
follo
wing:
W
e
claim
that
w
e
will
not
revisit
the
same
feature
t
wice
in
a
linear
time
c
hec
k.
W
e
will
pro
v
e
b
y
con
tradiction.
Assume
that
the
linear
time
routine
is
called
to
nd
a
closest
feature
in
B
to
f
A
.
The
routine
will
nev
er
again
b
e
called
with
(f
A
,
B
)
as
argumen
t.
Supp
ose
it
w
as,
i.e.
supp
ose
that
f
B
w
as
the
result
of
the
call
to
the
linear
time
routine
with
input
(f
A
;
B
)
and
after
sev
eral
iterations
from
(f
A
,
f
B
)
!
:
:
:
!
(f
0
A
,
f
0
B
)
w
e
come
to
a
feature
pair
(f
A
,
f
0
B
)
and
that
the
linear
routine
is
in
v
ok
ed
to
nd
the
closest
feature
on
B
to
f
A
.
Once
again,
f
B
m
ust
b
e
returned
as
the
closest
feature
to
f
A
.
But,
this
violates
Lemma

since
the
distance
m
ust
strictly
decrease
when
c
hanges
of
features
are
made,
whic
h
is
not
true
of
the
regular
sequence
(f
A
;
f
B
)
!
:
:
:
!
(f
A
;
f
0
B
)
!
:
:
:
!
(f
A
;
f
B
).
Similarly
,
the
routine
will
not
b
e
called
more
than
once
with
(f
B
,
A)
as
argumen
ts.
Th
us,
the
linear-time
routine
can
b
e
called
at
most
n
times,
where
n
is
the
total
n
um
b
er
of
features
of
ob
ject
B
(or
A).
Therefore,
the
closest-feature
algorithm
will
con
v
erge
in
O
(n

)
time,
ev
en
in
the
w
orst
case
where
lo
cal
minim
a
are
encoun
tered.
.
Numerical
Exp
erimen
ts
The
algorithm
for
con
v
ex
p
olyhedral
ob
jects
describ
ed
in
this
c
hapter
has
b
een
impleme
n
ted
in
b
oth
Sun
Common
Lisp
and
ANSI
C
for
general
con
v
ex
ob
jects.
(The
extension
of
this
algorithm
to
non-con
v
ex
ob
jects
is
presen
ted
in
the
next
c
hap-
ter.)
The
input
data
are
arbitrary
pairs
of
features
from
t
w
o
giv
en
p
olyhedral
ob
jects
in
three
dimensional
space.
The
routine
outputs
a
pair
of
the
closest
features
(and
a
pair
of
nearest
p
oin
ts)
for
these
t
w
o
ob
jects
and
the
Euclidean
distance
b
et
w
een
them.
Numerous
examples
in
three
dimensional
space
ha
v
e
b
een
studied
and
tested.
Our
implem
en
tation
in
ANSI
C
giv
es
us
an
exp
ected
constan
t
time
p
erformance
of


0.0
100.0
200.0
300.0
total number of vertices
0.0
20.0
40.0
60.0
80.0
100.0
120.0
computation time in microseconds
Figure
.:
Computation
time
vs.
total
no.
of
v
ertices
0-0
usec
p
er
ob
ject
pair
of
arbitrary
complexit
y
on
SGI
Indigo
XZ
(00-00
usec
p
er
ob
ject
pair
on
a
.
Mips
.
Mega
ops
Sun
Sparc
Station)
for
relativ
e
small
rotational
displacemen
t.
Fig..
sho
ws
the
exp
ected
constan
t
time
p
erformance
for
p
olygonized
spherical
and
cylindrical
ob
jects
of
v
arious
resolutions.
Eac
h
data
p
oin
t
is
tak
en
as
the
a
v
erage
v
alue
of
000
trials
with
the
relativ
e
rotation
of

degree
p
er
step.
(The
closest
features
rarely
c
hange
if
t
w
o
ob
jects
are
translated
along
the
line
connecting
the
closest
feature
pair.)
W
e
w
ould
lik
e
to
men
tion
that
the
accum
ulated
run
time
for
000
trials
sho
ws
sligh
tly
increasing
trend
for
total
v
ertices
o
v
er
000,
this
is
due
to
the
fact
that
the
n
um
b
er
of
feature
pair
c
hanges
for
the
same
amoun
t
of
rotation
increases
if
the
resolution
of
ob
jects
increases.
F
or
spherical
and
most
ob
jects,
the
run
time
is
roughly
O
(
p
n)
where
n
is
n
um
b
er
of
v
ertices
for
eac
h
ob
ject
with
a
extremely
small
constan
t.
F
or
the
cylindrical
ob
jects
where
the
total
n
um
b
er
of
facets
to
appro
ximate
the
quadratic
surface
is
linear
with
the
n
um
b
er
of
v
ertices,
the
total
accum
ulated
run
time
is
exp
ectedly
sub-linear
with
the
total
n
um
b
er
of
v
ertices.


F
or
t
w
o
con
v
ex
h
ulls
of
teap
ots
(eac
h
has
0
v
ertices,

edges,
and
0	0
faces),
the
algorithm
tak
es
roughly
0,
,
00,
0
usec
for
,
,
0,
0
degrees
of
relativ
e
rotation
and
displacemen
ts.
Note
that
when
the
relativ
e
mo
v
em
en
t
b
et
w
een

ob
jects
b
ecomes
large,
the
run
time
seems
to
increase
as
w
ell,
this
is
due
to
the
fact
that
the
geometric
coherence
do
esn't
hold
as
w
ell
in
the
abrupt
motions.
Nev
ertheless,
the
algorithm
con
tin
ues
to
p
erform
w
ell
compared
to
other
algorithms.
The
examples
w
e
used
in
our
sim
ulation
include
a
wide
v
ariet
y
of
p
olytop
es:
cub
es,
rectangular
b
o
xes,
cylinders,
cones,
frustrums,
and
a
Puma
link
of
dieren
t
sizes
as
sho
wn
in
Fig...
In
particular,
the
n
um
b
er
of
facets
or
the
resolution
for
cylinders,
cones
and
frustrums
ha
v
e
b
een
v
aried
from
,
0,
,
,
up
to
0
in
order
to
generate
a
ric
her
set
of
p
olytop
es
for
testing
purp
ose.
Due
to
the
programming
language's
nature,
Lisp
co
de
usually
giv
es
a
longer
run
time
(roughly
0
times
slo
w
er
than
the
implem
en
tation
written
in
ANSI
C).
T
o
giv
e
readers
a
feeling
of
sp
eed
dierence
the
exp
ected
run
time
obtained
from
our
Lisp
co
de
is
.
msec
whic
h
is
roughly
0
times
slo
w
er
than
our
C
imple-
men
tation
(from
the
same
Sun
SP
AR
C
station
describ
ed
ab
o
v
e),
indep
enden
t
of
ob
ject
complexit
y
.
The
exp
erimen
t
results
obtained
from
our
Lisp
co
de
are
briey
summarized
in
T
able
.
M
and
M
stand
for
the
n
um
b
er
of
v
ertices
for
eac
h
ob
ject
resp
ectiv
ely;
and
N
stands
for
the
total
n
um
b
er
of
v
ertices
b
et
w
een
the
t
w
o
ob
jects.
The
a
v
erage
CPU
time
is
tak
en
o
v
er
0
trials
of
exp
erimen
tal
runs.
(Eac
h
trial
pic
ks
all

arbitrary
p
erm
uted
com
bination
of
feature
pairs
to
initialize
the
computation
and
calculates
the
a
v
erage
run
time
based
up
on
these

runs.)
With
initialization
to
the
previous
closest
feature,
the
routine
can
almost
alw
a
ys
k
eep
trac
k
of
the
closest
features
of
t
w
o
giv
en
p
olytop
es
in
exp
ected
constan
t
time
(ab
out

to

msec).
Without
initialization
(i.e.
no
previous
closest
feature
pair
is
giv
en),
the
algorithm
runs
in
a
v
erage
time
not
w
orse
than
linear
in
the
total
n
um
b
er
of
v
ertices.
This
is
what
w
e
w
ould
exp
ect,
since
it
seems
unlik
ely
that
the
algorithm
w
ould
need
to
visit
a
giv
en
feature
more
than
once.
In
practice,
w
e
b
eliev
e
our
algorithm
compares
v
ery
fa
v
orably
with
other
algorithms
designed
for
distance
computations
or
collision
detection.
Since
the
nature
of
problem
is
not
the
same,
w
e
cannot
pro
vide
exact
comparisons
to
some
of
the
previous
algorithms.
But,
w
e
can
briey
commen
t
on
the


   (a)
(b)
(c)
(d)
(e)
(f)
Figure
.:
P
olytop
es
Used
in
Example
Computations


Ob
jects
M
+
M
=
N
w/o
Init
w/
Init
(a),(b)

+

=


.
(a),(f
)

+

=


.
(a),(c)

+

=


.
(d),(e)

+

=
	

.
(c),(c)
	
+

=


.0
T
able
.:
Av
erage
CPU
Time
in
Milliseconds
n
um
b
er
of
op
erations
in
v
olv
ed
in
a
t
ypical
calculation.
F
or
an
a
v
erage
computation
to
trac
k
or
up
date
a
pair
of
closest
features,
eac
h
run
tak
es
roughly
0-0
usec
on
a
SGI
Indigo
XZ
or
	-
arithmetic
op
erations
(roughly
-
op
erations
to
nd
the
nearest
p
oin
ts,

x

op
erations
on

p
oin
t
transformations,

x

x

op
erations
for
t
w
o
applicabilit
y
tests
and
eac
h
in
v
olv
es

inner
pro
duct
calculations)
indep
enden
t
of
the
mac
hines.
By
comparing
the
n
um
b
er
of
arithmetic
op
erations
in
the
previous
implem
en
te
d
algorithms,
w
e
b
eliev
e
that
our
implem
en
tation
giv
es
b
etter
p
erformance
and
probably
is
the
fastest
implem
en
te
d
collision
detection
algorithm.
(Please
see
[],
[],
[],
[0
],
[	],
[],
[
],
and
[	0].)
This
is
esp
ecially
true
in
a
dynamic
en
vironmen
t
where
the
tra
jectories
are
not
kno
wn
(nor
are
they
in
closed
form
ev
en
b
et
w
een
impacts,
but
are
giv
en
b
y
ellip-
tic
in
tegrals).
The
exp
e
cte
d
c
onstant
time
p
erformance
comes
from
the
fact
that
e
ach
up
date
of
the
closest
feature
pair
in
v
olv
es
only
the
constan
t
n
um
b
er
of
neigh
b
oring
features
(after
the
initialization
and
prepro
cessing
pro
cedures).
The
sp
eed
of
algo-
rithm
is
an
attribute
from
the
incr
emental
nature
of
our
approac
h
and
the
geometric
coherence
b
et
w
een
successiv
e,
discrete
mo
v
em
en
ts.
.
Dynamic
Collision
Detection
for
Con
v
ex
P
oly-
hedra
The
distance
computation
algorithm
can
b
e
easily
used
for
detecting
colli-
sion
while
the
ob
jects
are
mo
ving.
This
is
done
b
y
iterativ
ely
c
hec
king
the
distance


b
et
w
een
an
y
pair
of
mo
ving
ob
jects.
If
the
distance
is
less
than
or
equal
to
zero
(plus

-
a
small
safet
y
margin
dened
b
y
the
user),
then
a
collision
is
declared.
W
e
can
set
the
step
size
of
the
algorithm
once
w
e
obtain
the
initial
p
osition,
distance,
v
elo
cit
y
and
acceleration
among
all
ob
ject
pairs.
W
e
also
use
a
simple
queuing
sc
heme
to
reduce
the
frequency
of
collision
c
hec
ks
b
y
relying
on
the
fact
that
only
the
ob
ject
pairs
whic
h
ha
v
e
a
small
(Chapter
).
F
urthermore,
w
e
will
not
need
to
transform
all
the
V
oronoi
regions
and
all
features
of
p
olyhedra
but
only
the
closest
p
oin
ts
and
the
new
candidate
features
(if
necessary),
since
lo
cal
applicabilit
y
constrain
ts
are
all
w
e
need
for
trac
king
a
closest
pair
of
closest
features.
The
transformation
is
done
b
y
taking
the
relativ
e
transfor-
mation
b
et
w
een
t
w
o
ob
jects.
F
or
example,
giv
en
t
w
o
ob
jects
mo
ving
in
space,
their
motions
with
resp
ect
to
the
origin
of
the
w
orld
frame
can
b
e
c
haracterized
b
y
the
transformation
matrices
T
A
and
T
B
resp
ectiv
ely
.
Then,
their
relativ
e
motion
can
b
e
represen
ted
b
y
the
homogeneous
relativ
e
transformation
T
AB
=
T
 
B
T
A
.


Chapter

Extension
to
Non-Con
v
ex
Ob
jects
and
Curv
ed
Ob
jects
Most
of
ob
jects
in
the
real
w
orld
are
not
simple,
con
v
ex
p
olyhedral
ob
jects.
Curv
ed
corners
and
comp
osite
ob
jects
are
what
w
e
see
mostly
in
the
man-made
en
vi-
ronmen
t.
Ho
w
ev
er,
w
e
can
use
the
union
of
con
v
ex
p
olyhedra
to
mo
del
a
non-con
v
ex
ob
ject
and
reasonably
rened
p
olyhedral
appro
ximation
for
curv
ed
b
oundaries
as
w
ell.
In
this
c
hapter,
w
e
will
discuss
ho
w
w
e
extend
the
collision
detection
algorithm
(de-
scrib
ed
in
Chapter
)
from
con
v
ex
ob
jects
to
non-con
v
ex
ob
jects.
Then,
the
extension
to
the
curv
ed
ob
jects
will
b
e
describ
ed
later
in
the
c
hapter
as
w
ell.
.
Collision
Detection
for
Non-con
v
ex
Ob
jects
..
Sub-P
art
Hierarc
hical
T
ree
Represen
tation
Noncon
v
ex
ob
jects
can
b
e
either
comp
osite
solid
ob
jects
or
they
can
b
e
articulated
b
o
dies.
W
e
assume
that
eac
h
noncon
v
ex
ob
ject
is
giv
en
as
a
union
of
con
v
ex
p
olyhedra
or
is
comp
osed
of
sev
eral
noncon
v
ex
subparts,
eac
h
of
these
can
b
e
further
represen
ted
as
a
union
of
con
v
ex
p
olyhedra
or
a
union
of
non-con
v
ex
ob
jects.
W
e
use
a
sub-part
hierarc
h
y
tree
to
represen
t
eac
h
noncon
v
ex
ob
ject.
A
t
eac
h
no
de
of
the
tree,
w
e
store
either
a
con
v
ex
sub-part
(at
a
lea
v
e)
or
the
union
of
sev
eral
con
v
ex

	
Figure
.:
An
example
of
sub-part
hierarc
h
y
tree

0
subparts.
Dep
ending
on
the
applications,
w
e
rst
construct
the
con
v
ex
h
ull
of
a
rigid
non-con
v
ex
ob
ject
or
dynamic
b
ounding
b
o
x
for
articulated
b
o
dies
at
eac
h
no
de
and
w
ork
up
the
tree
as
part
of
prepro
cessing
computation.
W
e
also
include
the
con
v
ex
h
ull
or
dynamic
b
ounding
b
o
x
of
the
union
of
sub-parts
in
the
data
structure.
The
con
v
ex
h
ull
(or
the
b
ounding
b
o
x)
of
eac
h
no
de
is
the
con
v
ex
h
ull
(or
b
ounding
b
o
x)
of
the
union
of
its
c
hildren.
F
or
instance,
the
ro
ot
of
the
sub-part
hierarc
h
y
tree
for
a
comp
osite
solid
non-con
v
ex
ob
ject
is
the
noncon
v
ex
ob
ject
with
its
con
v
ex
h
ull
in
its
data
structure;
eac
h
con
v
ex
sub-part
is
stored
at
a
lea
v
e.
The
ro
ot
of
the
sub-part
hierarc
hical
tree
for
a
Puma
arm
is
the
b
ounding
b
o
x
of
the
en
tire
arm
whic
h
consists
of

links;
and
eac
h
lea
v
e
stores
a
con
v
ex
link.
F
or
example,
in
Fig.
.,
the
ro
ot
of
this
tree
is
the
aircraft
and
the
con
v
ex
h
ull
of
the
aircraft
(outlined
b
y
the
wire
frames).
The
no
des
on
the
rst
lev
el
of
the
tree
store
the
subparts
and
the
union
of
the
subparts
of
the
aircraft,
i.e.
the
left
and
righ
t
wings
(b
oth
con
v
ex),
the
con
v
ex
b
o
dy
of
airplane,
and
the
union
of
the
tail
pieces.
Please
note
that
at
the
no
de
where
the
union
of
the
tail
pieces
are
stored,
a
con
v
ex
h
ull
of
union
of
these
tail
pieces
is
also
stored
there
as
w
ell.
This
no
de,
whic
h
stores
the
union
of
all
tail
pieces,
further
branc
hes
out
to

lea
v
es,
eac
h
of
whic
h
stores
a
con
v
ex
tail
piece.
F
or
a
rob
ot
manipulator
lik
e
a
Puma
arm,
eac
h
link
can
b
e
treated
as
a
con
v
ex
subpart
in
a
lea
v
e
no
de.
The
ro
ot
of
this
tree
can
b
e
a
simple
b
ounding
b
o
x
of
the
en
tire
Puma
arm
whose
conguration
ma
y
b
e
c
hanging
throughout
the
duration
of
its
task.
(Therefore,
the
b
ounding
b
o
x
ma
y
b
e
c
hanging
as
w
ell.
Of
course,
the
eciency
of
our
distance
computation
algorithm
in
Chapter

is
lost
when
applied
to
a
c
hanging
v
olume,
since
the
V
oronoi
regions
will
b
e
c
hanging
as
the
v
olume
of
the
ob
ject
c
hanges
and
the
prepro
cessing
computation
is
not
utilized
to
its
maxim
um
extend.
Ho
w
ev
er,
in
Chapter

w
e
will
presen
t
another
simple
y
et
ecien
t
approac
h
to
deal
with
suc
h
a
situation.)
In
addition,
not
only
can
w
e
apply
the
hierarc
hical
subpart
tree
represen
ta-
tion
to
p
olyhedral
mo
dels,
w
e
can
also
use
it
for
non-con
v
ex
curve
d
ob
jects
as
w
ell.
Dep
ending
on
the
represen
tation
of
the
curv
ed
ob
jects
(parametric,
algebraic,
B

ezier,


or
B-spline
patc
hes),
eac
h
no
de
of
the
tree
will
store
a
p
ortion
(suc
h
as
a
patc
h)
of
the
curv
ed
surfaces
and
the
ro
ot
of
the
tree
is
the
en
tire
curv
ed
ob
ject
and
the
con
v
ex
h
ull
of
its
p
olyhedral
appro
ximation.
F
or
more
treatmen
ts
on
the
non-con
v
ex
curv
ed
ob
jects,
please
refer
to
Sec.
...
..
Detection
for
Non-Con
v
ex
P
olyhedra
Giv
en
the
subpart
tree
represen
tation,
w
e
examine
the
p
ossible
in
terference
b
y
a
recursiv
e
algorithm
at
eac
h
time
step.
The
algorithm
will
rst
c
hec
k
for
collision
b
et
w
een
t
w
o
paren
t
con
v
ex
h
ulls.
Of
course,
if
there
is
no
in
terference
b
et
w
een
t
w
o
paren
ts,
there
is
no
collision
and
the
algorithm
up
dates
the
closest-feature
pair
and
the
distance
b
et
w
een
them.
If
there
is
a
collision,
then
it
will
expand
their
c
hildren.
All
c
hildren
of
one
paren
t
no
de
are
c
hec
k
ed
against
all
c
hildren
of
the
other
paren
t
no
de.
If
there
is
also
a
collision
b
et
w
een
the
c
hildren,
then
the
algorithm
will
recursiv
ely
call
up
on
itself
to
c
hec
k
for
p
ossible
impacts
among
the
c
hildren's
c
hildren,
and
so
on.
In
this
recursiv
e
manner,
the
algorithm
will
only
signal
a
collision
if
there
is
actually
an
impact
b
et
w
een
the
sub-parts
of
t
w
o
ob
jects;
otherwise,
there
is
no
collision
b
et
w
een
the
t
w
o
ob
jects.
F
or
instance,
assume
for
simplicit
y
that
one
noncon
v
ex
ob
ject
is
comp
osed
of
m
con
v
ex
p
olyhedra
and
the
other
is
comp
osed
of
n
con
v
ex
p
olyhedra,
the
algorithm
will
rst
c
hec
k
for
collision
b
et
w
een
the
t
w
o
con
v
ex
h
ulls
of
these
t
w
o
ob
jects.
If
there
is
a
collision,
mn
con
v
ex
p
olyhedra-pairs
will
b
e
tested
for
p
ossible
con
tacts.
If
there
is
a
collision
b
et
w
een
an
y
one
of
these
mn
pairs
of
con
v
ex
p
olyhedra,
then
the
t
w
o
ob
jects
in
terp
enetrate;
otherwise,
the
t
w
o
ob
jects
ha
v
e
not
y
et
in
tersected.
Fig.
.
sho
ws
ho
w
this
algorithm
w
orks
on
t
w
o
simplied
aircraft
mo
dels.
In
Fig.
.,
w
e
rst
apply
the
algorithm
describ
ed
in
Chapter

to
the
con
v
ex
h
ulls
of
the
t
w
o
aircrafts.
If
they
do
not
in
tersect,
then
the
algorithm
terminates
and
rep
orts
no
collision.
In
the
next
step,
the
algorithm
con
tin
ues
to
trac
k
the
motion
of
the
t
w
o
planes
and
nds
their
con
v
ex
h
ulls
o
v
erlap.
Then,
the
algorithm
go
es
do
wn
the
tree
to
the
next
lev
el
of
tree
no
des
and
c
hec
k
whether
there
is
a
collision
among
the
subparts
(the
wings,
the
b
o
dies,
and
the
union
of
subparts,
i.e.
the
union
of
tail


pieces).
If
not,
the
algorithm
will
not
rep
ort
a
collision.
Otherwise,
when
there
is
an
actual
p
enetration
of
subparts
(suc
h
as
t
w
o
wings
in
terp
enetrating
eac
h
other),
then
a
collision
is
rep
orted.
W
e
w
ould
lik
e
to
clarify
one
fact
that
w
e
nev
er
need
to
construct
the
V
oronoi
regions
of
the
non-con
v
ex
ob
jects,
since
it
is
absolutely
unnecessary
giv
en
the
subpart
hierarc
hical
tree.
Instead,
at
the
prepro
cessing
step
w
e
only
construct
the
V
oronoi
regions
for
eac
h
con
v
ex
piece
at
eac
h
no
de
of
the
subpart
hierarc
hical
tree.
When
w
e
p
erform
the
collision
c
hec
ks,
w
e
only
k
eep
trac
k
of
the
closest
feature
pairs
for
the
con
v
ex
h
ulls
of
paren
t
no
des,
unless
a
collision
has
tak
en
place
b
et
w
een
the
con
v
ex
h
ulls
of
t
w
o
non-con
v
ex
ob
jects
or
the
b
ounding
b
o
xes
of
articulated
b
o
dies.
Under
suc
h
a
situation,
w
e
ha
v
e
to
trac
k
the
closest
pair
of
features
for
not
only
the
con
v
ex
h
ulls
or
b
ounding
b
o
xes
at
the
paren
t
no
des,
but
also
among
all
p
ossible
subpart
pairs
at
the
c
hildren
no
des
as
w
ell.
This
can
lead
to
O
(n

)
of
comparisons,
if
eac
h
ob
ject
is
consisted
of
n
subparts
and
the
trees
only
ha
v
e
t
w
o
lev
els
of
lea
v
e
no
des.
Ho
w
ev
er,
w
e
can
ac
hiev
e
a
b
etter
p
erformance
if
w
e
ha
v
e
a
go
o
d
hierarc
h
y
of
the
mo
del.
F
or
complex
ob
jects,
using
a
deep
hierarc
hical
tree
with
lo
w
er
branc
hing
factor
will
k
eep
do
wn
the
n
um
b
er
of
no
des
whic
h
need
to
b
e
expanded.
This
approac
h
guaran
tees
that
w
e
nd
the
earliest
collision
b
et
w
een
t
w
o
non-con
v
ex
ob
jects
while
reducing
computation
costs.
F
or
example,
giv
en
n
subparts,
w
e
can
further
group
them
in
to
t
w
o
subassem
blies
and
eac
h
has
n
subparts.
Eac
h
subassem
bly
is
further
divided
in
to
sev
eral
smaller
groups.
This
pro
cess
generates
a
deep
hierarc
hical
tree
with
lo
w
er
branc
hing
factor,
th
us
reduces
the
n
um
b
er
of
expansions
needed
whenev
er
the
con
v
ex
h
ulls
(or
b
ounding
b
o
xes)
at
the
top-lev
el
paren
t
no
des
collide.


Figure
.:
An
example
for
non-con
v
ex
ob
jects


.
Collision
Detection
for
Curv
ed
Ob
jects
In
this
section

,
w
e
analyze
the
problem
of
collision
detection
b
et
w
een
curv
ed
ob
jects
represen
ted
as
spline
mo
dels
or
piecewise
algebraic
surfaces.
Dieren
t
t
yp
es
of
surface
represen
tations
ha
v
e
b
een
desrib
ed
in
Chapter
,
please
refer
to
it
if
necessary
.
W
e
sho
w
that
these
problems
reduce
to
nding
solutions
of
a
system
of
algebraic
equations.
In
particular,
w
e
presen
t
algebraic
form
ulations
corresp
onding
to
closest
p
oin
ts
determination
and
geometric
con
tacts.
..
Collision
Detection
and
Surface
In
tersection
In
geometric
and
solid
mo
deling,
the
problem
of
computing
the
in
tersection
of
surfaces
represen
ted
as
spline
surfaces
or
algebraic
surfaces
has
receiv
ed
a
great
deal
of
atten
tion
[].
Giv
en
t
w
o
surfaces,
the
problem
corresp
onds
to
computing
all
comp
onen
ts
of
the
in
tersection
curv
e
robustly
and
accurately
.
Ho
w
ev
er,
for
collision
detection
w
e
are
actually
dealing
with
a
restricted
v
ersion
of
this
problem.
That
is,
giv
en
t
w
o
surfaces
w
e
w
an
t
to
kno
w
whether
they
in
tersect.
In
general,
giv
en
t
w
o
spline
surfaces,
there
is
no
go
o
d
and
quic
k
solution
to
the
problem
of
whether
they
in
tersect
or
ha
v
e
a
common
geometric
con
tact.
The
simplest
solution
is
based
on
c
hec
king
the
con
trol
p
olytop
es
(a
con
v
ex
b
ounding
b
o
x)
for
collision
and
using
sub
division.
Ho
w
ev
er,
w
e
ha
v
e
highligh
ted
the
problems
with
this
approac
h
(in
Chapter
)
in
terms
of
p
erformance
when
the
t
w
o
ob
jects
are
close
to
touc
hing.
Our
approac
h
is
based
on
form
ulating
the
problem
in
terms
of
solving
systems
of
algebraic
equations
and
using
global
metho
ds
for
solving
these
equations,
and
lo
cal
metho
ds
to
up
date
the
solutions.
..
Closest
F
eatures
Giv
en
the
homogeneous
represen
tation
of
t
w
o
parametric
surfaces,
F(s;
t)
=
(X
(s;
t),
Y
(s;
t),
Z
(s;
t),
W
(s;
t))
and
G(u;
v
)
=
(X
(u;
v
),
Y
(u;
v
);
Z
(u;
v
),
W
(u;
v
));

This
is
the
result
of
join
t
w
ork
with
Prof.
Dinesh
Mano
c
ha
at
the
Univ
ersit
y
of
North
Carolina,
Chap
el
Hill


the
closest
fe
atur
es
b
et
w
een
t
w
o
p
olyhedra
corresp
ond
to
the
closest
p
oin
t
sets
on
the
surface.
The
closest
p
oin
ts
are
c
haracterized
b
y
the
prop
ert
y
that
the
corresp
ond-
ing
surface
normals
are
collinear.
This
can
b
e
expressed
in
terms
of
the
follo
wing
v
ariables.
Let
F

(s;
t;
u;
v
;


)
=
(F(s;
t)
 G(u;
v
))
F

(s;
t;
u;
v
;


)
=


(G
u
(u;
v
)

G
v
(u;
v
))
F

(s;
t;
u;
v
;


)
=
(F
s
(s;
t)

F
t
(s;
t))
F

(s;
t;
u;
v
;


)
=


(G
u
(u;
v
)

G
v
(u;
v
));
where
F
s
;
F
t
;
G
u
;
G
v
corresp
ond
to
the
partial
deriv
ativ
es.
The
closest
p
oin
ts
b
et
w
een
the
t
w
o
surfaces
satisfy
the
follo
wing
equations:
F

(s;
t;
u;
v
;


)
=
F

(s;
t;
u;
v
;


)
 F

(s;
t;
u;
v
;


)
=
0
B
B
B
B
@
0
0
0

C
C
C
C
A
:
(.)
F

(s;
t;
u;
v
;


)
=
F

(s;
t;
u;
v
;


)
 F

(s;
t;
u;
v
;


)
=
0
B
B
B
B
@
0
0
0

C
C
C
C
A
:
This
results
in

equations
in

unkno
wns.
These
constrain
ts
b
et
w
een
the
closest
features
can
also
b
e
expressed
as:
H

(s;
t;
u;
v
)
=
(F(s;
t)
 G(u;
v
))

G
u
(u;
v
)
=
0
H

(s;
t;
u;
v
)
=
(F(s;
t)
 G(u;
v
))

G
v
(u;
v
)
=
0
(.)
H

(s;
t;
u;
v
)
=
(F(s;
t)
 G(u;
v
))

F
s
(s;
t)
=
0
H

(s;
t;
u;
v
)
=
(F(s;
t)
 G(u;
v
))

F
t
(s;
t)
=
0;
where

corresp
onds
to
the
dot
pro
duct.
This
results
in
four
equations
in
four
un-
kno
wns.
Let
us
analyze
the
algebraic
complexit
y
of
these
t
w
o
system
of
equations
cor-
resp
onding
to
closest
features.
Lets
consider
the
rst
system
corresp
onding
to
(.).
In
particular,
giv
en

rational
parametric
surfaces
F(s;
t)
and
G(u;
v
),
b
oth
of
their


n
umerators
and
denominators
are
p
olynomials
of
degree
n,
the
degrees
of
n
umerators
and
denominators
of
the
partials
are
n
 
and
n
resp
ectiv
ely
in
the
giv
en
v
ari-
ables
(due
to
quotien
t
rule).
The
n
umerator
and
denominator
of
F

(s;
t;
u;
v
;


)
ha
v
e
degree
n
and
n
due
to
subtraction
of
t
w
o
rational
p
olynomials.
As
for
F

(s;
t;
u;
v
;


),
taking
the
cross
pro
duct
doubles
the
degrees
for
b
oth
the
n
umer-
ator
and
denominator;
therefore,
the
degrees
for
the
n
umerator
and
denominator
of
F

(s;
t;
u;
v
;


)
are
n
 
and
n
resp
ectiv
ely
.
T
o
eliminate


from
F

(s;
t;
u;
v
;


),
w
e
get
F

(X
(s;
t;
u;
v
;


))
F

(X
(s;
t;
u;
v
;


))
=
F

(Y
(s;
t;
u;
v
;


))
F

(Y
(s;
t;
u;
v
;


))
=
F

(Z
(s;
t;
u;
v
;


))
F

(Z
(s;
t;
u;
v
;


))
(:)
After
cross
m
ultiplic
ation
to
clear
out
the
denominators
w
e
get
t
w
o
p
olynomails
of
degree
n
 
eac
h.
Once
again,
b
y
the
same
reasoning
as
stated
ab
o
v
e,
b
oth
the
n
umerators
and
denominators
of
F

(s;
t;
u;
v
;


)
and
F

(s;
t;
u;
v
;


)
ha
v
e
degrees
of
n
 
and
n.
By
similar
metho
d
men
tioned
ab
o
v
e,
w
e
can
eliminate


from
F

(s;
t;
u;
v
;


).
W
e
get
t
w
o
p
olynomial
equations
of
degree
n
 
eac
h
after
cross
m
ultiplic
ation.
As
a
result
the
system
has
a
Bezout
b
ound
of
(n
 )

(n
 )

.
Eac
h
equation
in
the
second
system
of
equations
has
degree
n
 
(obtained
after
computing
the
partials
and
addition
of
t
w
o
rational
p
olynomials)
and
therefore
the
o
v
erall
algebraic
complexit
y
corresp
onding
to
the
Bezout
b
ound
is
(n
 )

.
Since
the
later
system
results
in
a
lo
w
er
degree
b
ound,
in
the
rest
of
the
analysis
w
e
will
use
this
system.
Ho
w
ev
er,
w
e
are
only
in
terested
in
the
solutions
in
the
domain
of
in
terest
(since
eac
h
surface
is
dened
on
a
subset
of
the
real
plane).
Bara
has
used
a
form
ulation
similar
to
(.)to
k
eep
trac
k
of
closest
p
oin
ts
b
et
w
een
closed
con
v
ex
surfaces
[]
based
on
lo
cal
optimization
routines.
The
main
problem
is
nding
a
solution
to
these
equations
for
the
initial
conguration.
In
general,
these
equations
can
ha
v
e
more
than
one
solution
in
the
asso
ciated
domain,
i.e.
the
real
plane,
(ev
en
though
there
is
only
one
closest
p
oin
t
pair)
and
the
optimization
routine
ma
y
not
con
v
erge
to
the
righ
t
solution.
A
simple
example
is
the
form
ulation
for
the
problem
of
collision
detection
b
et
w
een
t
w
o
spheres.
There
is
only
one
pair
of
closest
p
oin
ts,
ho
w
ev
er
equations
(.)
or
(.)
ha
v
e
four
pairs
of
real
solutions.
Giv
en
t
w
o
algebraic
surfaces,
f
(x;
y
;
z
)
=
0
and
g
(x;
y
;
z
)
=
0,
the
problem


( a )
Tangent Plane
Contact Point
Intersection
is a boundary point
( b )
Figure
.:
T
angen
tial
in
tersection
and
b
oundary
in
tersection
b
et
w
een
t
w
o
B

ezier
surfaces
of
closest
p
oin
t
determination
can
b
e
reduced
to
nding
ro
ots
of
the
follo
wing
system
of

algebraic
equations:
f
(x

;
y

;
z

)
=
0
g
(x

;
y

;
z

)
=
0
(.)
0
B
B
B
B
@
f
x
(x

;
y

;
z

)
f
y
(x

;
y

;
z

)
f
z
(x

;
y

;
z

)

C
C
C
C
A
=


0
B
B
B
B
@
g
x
(x

;
y

;
z

)
g
y
(x

;
y

;
z

)
g
z
(x

;
y

;
z

)

C
C
C
C
A
0
B
B
B
B
@
x

y

z


C
C
C
C
A
 0
B
B
B
B
@
x

y

z


C
C
C
C
A
=


0
B
B
B
B
@
g
x
(x

;
y

;
z

)
g
y
(x

;
y

;
z

)
g
z
(x

;
y

;
z

)

C
C
C
C
A
Giv
en
t
w
o
algebraic
surfaces
of
degree
n,
w
e
can
eliminate


b
y
setting
f
x
(x;y
;z
)
g
x
(x

;y

;z

)
=
f
y
(x;y
;z
)
g
y
(x;y
;z
)
.
After
cross
m
ultiplic
ation,
w
e
ha
v
e
a
p
olynomial
equation
of
n-,
since
eac
h
partial
has
degree
of
n
 
and
the
m
ultiplication
results
in


the
degree
sum
of
n
 .
T
o
eliminate


,
w
e
set
x

 x

g
x
(x

;y

;z

)
=
y

 y

g
y
(x

;y

;z

)
and
the
degree
of
the
resulting
p
olynomial
equation
is
n.
W
e
ha
v
e
six
quations
after
elim-
inating


and


:
t
w
o
of
degrees
(n
 )
and
four
of
degress
n
resp
ectiv
ely
(
from
eliminating


and

from
f
(x

;
y

;
z

)
and
g
(x

;
y

;
z

)).
Therefore,
the
Bezout
b
ound
of
the
resulting
system
can
b
e
as
high
as
N
=
(n
 )

n

.
In
general,
if
the
system
of
equations
is
sparse,
w
e
can
get
a
tigh
t
b
ound
with
Bernstein
b
ound
[].
The
Bernstein
b
ound
for
Eqn.
.
is
n

(n

+
)(n
 )

.
Cann
y
and
Emiris
calculate
the
Bernstein
b
ounds
ecien
tly
b
y
using
sparse
mixed
resultan
t
form
ula-
tion
[].
F
or
example,
the
Bernstein
b
ounds

for
the
case
of
n
=
;
;
;
;
;
;
;
	
are
;
;
;

00
;

00
;
	
;

0

;


,
while
the
Bezout
b
ounds
are
;
	;
	
;
00
00;

	
00
;


;



resp
ectiv
ely
.
Ev
en
for
small
v
alues
of
n,
N
can
b
e
large
and
therefore,
the
algebraic
complexit
y
of
computing
the
closest
p
oin
ts
can
b
e
fairly
high.
In
our
applications
w
e
are
only
in
terested
in
the
real
solutions
to
these
equations
in
the
corresp
onding
domain
of
in
terest.
The
actual
n
um
b
er
of
real
solutions
ma
y
c
hange
as
the
t
w
o
ob
jects
undergo
motion
and
some
congurations
can
result
in
innite
solutions
(e.g.
when
a
closest
pair
corresp
onds
to
a
curv
e
on
eac
h
surface,
as
sho
wn
for
t
w
o
cylinders
in
Fig.
..
).
As
a
result,
it
is
fairly
non-trivial
to
k
eep
trac
k
of
all
the
closest
p
oin
ts
b
et
w
een
ob
jects
and
up
dating
them
as
the
ob
jects
undergo
motion.
..
Con
tact
F
orm
ulation
The
problem
of
collision
detection
corresp
onds
to
determining
whether
there
is
an
y
con
tact
b
et
w
een
the
t
w
o
ob
jects.
In
particular,
it
is
assumed
that
in
the
b
eginning
the
ob
jects
are
not
o
v
erlapping.
As
they
undergo
motion,
w
e
are
in
terested
in
kno
wing
whether
there
is
an
y
con
tact
b
et
w
een
the
ob
jects.
There
are
t
w
o
t
yp
es
of
con
tacts.
They
are
tangen
tial
con
tact
and
b
oundary
con
tact.
In
this
section,
w
e
form
ulate
b
oth
of
these
problems
in
terms
of
a
system
of
algebraic
equations.
In
the
next
section,
w
e
describ
e
ho
w
the
algorithm
tests
for
these
conditions
as
the
ob
ject

These
gures
are
calculated
b
y
John
Cann
y
and
Ioannis
Emiris
using
their
co
de
based
on
the
sparse
mixed
resultan
t
form
ulation.

	
undergo
es
rigid
motion.

T
angential
Interse
ction
:
This
corresp
onds
to
a
tangen
tial
in
tersection
b
et
w
een
the
t
w
o
surfaces
at
a
geometric
con
tact
p
oin
t,
as
in
Fig..(a).
The
con
tact
p
oin
t
lies
in
the
in
terior
of
eac
h
surface
(as
opp
osed
to
b
eing
on
the
b
oundary
curv
e)
and
the
normal
v
ectors
at
that
p
oin
t
are
collinear.
These
constrain
ts
can
b
e
form
ulated
as:
F(s;
t)
=
G(u;
v
)
(.)
(F
s
(s;
t)

F
t
(s;
t))

G
u
(u;
v
)
=
0
(F
s
(s;
t)

F
t
(s;
t))

G
v
(u;
v
)
=
0
The
rst
v
ector
equation
corresp
onds
to
a
con
tact
b
et
w
een
the
t
w
o
surfaces
and
the
last
t
w
o
equations
represen
t
the
fact
that
their
normals
are
collinear.
They
are
expressed
as
scalar
triple
pro
duct
of
the
v
ector
The
last
v
ector
equation
represen
ted
in
terms
of
cross
pro
duct
corresp
onds
to
three
scalar
equations.
W
e
obtain

equations
in

unkno
wns.
This
is
an
o
v
erconstrained
system
and
has
a
solution
only
when
the
t
w
o
surfaces
are
touc
hing
eac
h
other
tangen
tially
.
Ho
w
ev
er,
w
e
solv
e
the
problem
b
y
computing
all
the
solutions
to
the
rst
four
equations
using
global
metho
ds
and
substitute
them
in
to
the
fth
equation.
If
the
giv
en
equations
ha
v
e
a
common
solution,
than
one
of
the
solution
of
the
rst
four
equation
will
satisfy
the
fth
equation
as
w
ell.
F
or
the
rst
three
equations,
after
cross
m
ultiplication
w
e
get

p
olynomial
equations
of
degree
n
eac
h.
The
dot
pro
duct
results
in
the
addition
of
degrees
of
the
n
umerator
p
olynomials.
Therefore,
w
e
get
a
p
olynomial
equation
of
degree
n
 
from
the
fourth
equation.
Therefore,
the
Bezout
b
ound
of
the
system
corresp
onding
to
the
rst
four
equations
is
b
ounded
b
y
N
=
(n)

(n
 ),
where
n
is
the
parametric
degree
of
eac
h
surface.
Similarly
for
t
w
o
algebraic
surfaces,
the
problem
of
tangen
tial
in
tersection
can
b
e
form
ulated
as:
f
(x;
y
;
z
)
=
0
g
(x;
y
;
z
)
=
0
(.)

0
0
B
B
B
B
@
f
x
(x;
y
;
z
)
f
y
(x;
y
;
z
)
f
z
(x;
y
;
z
)

C
C
C
C
A
=

0
B
B
B
B
@
g
x
(x;
y
;
z
)
g
y
(x;
y
;
z
)
g
z
(x;
y
;
z
)

C
C
C
C
A
In
this
case,
w
e
obtain

equations
in

unkno
wns
(after
eliminating
)
and
these
equations
corresp
ond
to
an
o
v
erconstrained
system
as
w
ell.
These
o
v
er-
constrained
system
is
solv
ed
in
a
manner
similar
to
that
of
parametric
surfaces.
The
rst
t
w
o
equations
are
of
degrees
n.
T
o
eliminate

from
the
third
equa-
tion,
w
e
get
a
p
olynomial
equation
of
degree
(n-)
due
to
cross
m
ultiplication
and
taking
partial
with
resp
ect
to
x;
y
;
z
.
The
Bezout
b
ound
for
the
rst
three
equations
is
N
=
n

(n
 ).

Boundary
Interse
ction
:
Suc
h
in
tersections
lie
on
the
b
oundary
curv
e
of
one
of
the
t
w
o
surfaces.
Sa
y
w
e
are
giv
en
a
B

ezier
surface,
dened
o
v
er
the
domain,
(s;
t)

[0;
]

[0;
],
w
e
obtain
the
b
oundary
curv
es
b
y
substituting
s
or
t
to
b
e
0
or
.
The
resulting
problem
reduces
to
solving
the
equations:
F(s;
)
=
G(u;
v
)
(:)
Other
p
ossible
b
oundary
in
tersections
can
b
e
computed
in
a
similar
manner.
The
in
tersection
p
oin
ts
can
b
e
easily
computed
using
global
metho
ds.
An
ex-
ample
has
b
een
sho
wn
in
Figure
.(b)
Tw
o
ob
jects
collide
if
one
of
these
sets
of
equations,
(.)
or
(.)
for
para-
metric
surfaces
and
(.)
for
algebraic
surfaces,
ha
v
e
a
common
solution
in
their
domain.
In
a
few
degenerate
cases,
it
is
p
ossible
that
the
system
of
equations
(.)
and
(.)
ha
v
e
an
innite
n
um
b
er
of
solutions.
One
suc
h
example
is
sho
wn
for
t
w
o
cylinders
in
Fig...
In
this
case
the
geometric
con
tact
corresp
onds
to
a
curv
e
on
eac
h
surface,
as
opp
osed
to
a
p
oin
t.
These
cases
can
b
e
detected
using
resultan
t
metho
ds
as
w
ell
[].


( a )
( b )
Closest
Points
Point Sets
Closest
Figure
.:
Closest
features
b
et
w
een
t
w
o
dieren
t
orien
tations
of
a
cylinder
.
Coherence
for
Collision
Detection
b
et
w
een
Curv
ed
Ob
jects
In
most
dynamic
en
vironmen
ts,
the
closest
features
or
p
oin
ts
b
et
w
een
t
w
o
mo
ving
ob
jects
c
hange
infrequen
tly
b
et
w
een
t
w
o
time
frames.
W
e
ha
v
e
used
this
coherence
prop
ert
y
in
designing
the
exp
ected
constan
t
time
algorithm
for
collision
detection
among
con
v
ex
p
olytop
es
and
applied
to
non-con
v
ex
p
olytop
es
as
w
ell.
In
this
section
w
e
utilize
this
coherence
prop
ert
y
along
with
the
algebraic
form
ulations
presen
ted
in
the
previous
section
for
curv
ed
mo
dels.
..
Appro
ximating
Curv
ed
Ob
jects
b
y
P
olyhedral
Mo
d-
els
W
e
appro
ximate
eac
h
ph
ysical
ob
ject
with
curv
ed
b
oundary
b
y
a
p
olyhedra
(or
p
olygonal
mesh).
Suc
h
appro
ximations
are
used
b
y
rendering
algorithms
utiliz-


ing
p
olygon
rendering
capabilities
a
v
ailable
on
curren
t
hardw
are.
These
p
olyhedral
mo
dels
are
used
for
collision
detection,
based
on
the
almost
constan
t
time
algorithm
utilizing
lo
cal
features.
Ev
en
tually
a
geometric
con
tact
is
determined
b
y
solving
the
equations
highligh
ted
in
the
previous
section.
W
e
use
an
-p
olytop
e
appro
ximation
for
a
curv
ed
surface.
It
is
dened
as:
Denition:
Let
S
b
e
a
surface
and
P
is
-p
olytop
e
appro
ximation,
if
for
all
p
oin
ts,
p
on
the
b
oundary
of
p
olytop
e
P
,
there
is
a
p
oin
t
s
on
S
suc
h
that
k
s
 p
k
.
Similarly
for
eac
h
p
oin
t
s
on
S
,
there
is
a
p
oin
t
p
on
the
b
oundary
of
P
suc
h
that
k
p
 s
k
.
An
-p
olytop
e
appro
ximation
is
obtained
using
either
a
simple
mesh
gener-
ation
algorithm
or
an
adaptiv
e
sub
division
of
the
surfaces.
Giv
en
a
user
dened
,
algorithms
for
generating
suc
h
meshes
are
highligh
ted
for
parametric
B-spline
surfaces
in
[]
and
for
algebraic
surfaces
in
[
].
In
our
implem
en
tation
w
e
used
an
inscrib
ed
p
olygonal
appro
ximation
to
the
surface
b
oundary
.
W
e
use
the
-p
olytop
e
appro
ximations
for
con
v
ex
surfaces
only
.
In
suc
h
cases
the
resulting
p
olytop
e
is
con
v
ex
as
w
ell.
Often
a
curv
ed
mo
del
can
b
e
repre-
sen
ted
as
a
union
of
con
v
ex
ob
jects.
Suc
h
mo
dels
are
represen
ted
hierarc
hically
,
as
describ
ed
in
Section
...
Eac
h
p
olytop
e
at
a
leaf
no
de
corresp
onds
to
an
-p
olytop
e
appro
ximation.
..
Con
v
ex
Curv
ed
Surfaces
In
this
section
w
e
presen
t
an
algorithm
for
t
w
o
con
v
ex
spline
surfaces.
The
input
to
the
algorithm
are
t
w
o
con
v
ex
B-spline
surfaces
(sa
y
S
A
and
S
B
)
and
their
asso
ciated
con
trol
p
olytop
es.
It
is
assumed
that
the
surfaces
ha
v
e
at
least
rst
order
con
tin
uit
y
.
W
e
compute
an
-p
olytop
e
appro
ximation
for
eac
h
spline
surface.
Let
P
A
and
P
b
b
e

A
-p
olytop
e
and

B
-p
olytop
e
appro
ximations
of
S
A
and
S
B
,
resp
ectiv
ely
.
If
the
ob
jects
do
not
collide,
there
ma
y
b
e
no
need
to
nd
the
exact
closest
p
oin
ts
b
et
w
een
them
but
a
rough
estimate
of
lo
cation
to
preserv
e
the
prop
ert
y
of
geometric
coherence.
In
this
case,
w
e
k
eep
trac
k
of
the
closest
p
oin
ts
b
et
w
een
P
A
and
P
B
.
Based
on
those
closest
p
oin
ts,
w
e
ha
v
e
a
go
o
d
b
ound
on
the
actual
distance


b
et
w
een
the
t
w
o
surfaces.
A
t
an
y
instance
let
d
p
b
e
the
minim
um
distance
b
et
w
een
P
A
and
P
B
(computed
using
the
p
olyhedral
collision
detection
algorithm).
Let
d
s
b
e
the
minim
um
distance
b
et
w
een
the
t
w
o
surfaces.
It
follo
ws
from
the
-appro
ximation:
d
p
 
A
 
B

d
s

d
p
:
(:)
The
algorithm
pro
ceeds
b
y
k
eeping
trac
k
of
the
closest
p
oin
ts
b
et
w
een
P
A
and
P
B
and
up
dating
the
b
ounds
on
d
s
based
on
d
p
.
Whenev
er
d
p


A
+

B
,
w
e
use
Gauss
Newton
routines
to
nd
the
closest
p
oin
ts
b
et
w
een
the
surfaces
S
A
and
S
B
.
In
particular,
w
e
form
ulate
the
problem:
F
or
Gauss
Newton
routines,
w
e
w
an
t
to
minimi
ze
the
function
H(s;
t;
u;
v
)
=

X
i=
(H
i
(s;
t;
u;
v
))

;
where
H
i
are
dened
in
(.).
W
e
use
Gauss-Newton
algorithm
to
minimi
ze
H.
The
initial
guess
to
the
v
ariables
is
computed
in
the
follo
wing
manner.
W
e
use
the
line,
sa
y
L
A;B
,
joining
the
closest
p
oin
ts
of
P
A
and
P
B
as
an
initial
guess
to
the
line
joining
the
closest
p
oin
ts
of
S
A
and
S
B
(in
terms
of
direction).
The
initial
estimate
to
the
v
ariables
in
the
equations
in
(.)
is
obtained
b
y
nding
the
in
tersection
of
the
line
L
A;B
with
the
surfaces,
F(s;
t)
and
G(u;
v
).
This
corresp
onds
to
a
line-surface
in
tersection
problem
and
can
b
e
solv
ed
using
sub
division
or
algebraic
metho
ds
[,
].
As
the
surfaces
mo
v
e
along,
the
co
ecien
ts
of
the
equations
in
(.)
are
up
dated
according
to
the
rigid
motion.
The
closest
p
oin
ts
b
et
w
een
the
resulting
surfaces
are
up
dated
using
Gauss
Newton
routines.
Finally
,
when
these
closest
p
oin
ts
coincide,
there
is
a
collision.
In
practice,
the
con
v
ergence
of
the
Gauss
Newton
routines
to
the
closest
p
oin
ts
of
S
A
and
S
B
is
a
function
of

A
and

B
.
In
fact,
the
c
hoice
of

in
the
-p
olytop
e
appro
ximation
is
imp
ortan
t
to
the
o
v
erall
p
erformance
of
the
algorithm.
Ideally
,
as

!
0,
w
e
get
a
ner
appro
ximation
of
the
curv
ed
surface
and
b
etter
the
con
v
ergence
of
the
Gauss
Newton
routines.
Ho
w
ev
er,
a
smaller

increases
the
n
um
b
er
of
features
in
the
resulting
p
olytop
e.
Though
p
olyhedral
collision
detection
is
an
exp
ected
constan
t
time
algorithm
at
eac
h
step,
the
o
v
erall
p
erformance
of
this
algorithm
is
go
v
erned
b
y
the
total
n
um
b
er
of
feature
pairs
tra
v
ersed
b
y
the
algorithm.
The
latter
is
dep
enden
t


on
motion
and
the
resolution
of
the
appro
ximation.
Consequen
tly
,
a
v
ery
small

can
slo
w
do
wn
the
o
v
erall
algorithm.
In
our
applications,
w
e
ha
v
e
c
hosen

as
a
function
of
the
dimension
of
a
simple
b
ounding
b
o
x
used
to
b
ound
S
A
.
In
particular,
let
l
b
e
dimension
of
the
smallest
cub
e,
enclosing
S
A
.
W
e
ha
v
e
c
hosen

=

l
,
where
:0



:0.
This
has
w
ork
ed
w
ell
in
the
examples
w
e
ha
v
e
tested
so
far.
The
algorithm
is
similar
for
surfaces
represen
ted
algebraically
.
Ob
jects
whic
h
can
b
e
represen
ted
as
a
union
of
con
v
ex
surfaces,
w
e
use
the
hierarc
hical
rep-
resen
tation
and
the
algorithm
highligh
ted
ab
o
v
e
on
the
leaf
no
des.
..
Non-Con
v
ex
Curv
ed
Ob
jects
In
this
section
w
e
outline
the
algorithm
for
non-con
v
ex
surfaces
whic
h
cannot
b
e
represen
ted
as
a
union
of
con
v
ex
surfaces.
A
common
example
is
a
torus
and
ev
en
a
mo
del
of
a
teap
ot
describ
ed
b
y
B-spline
surfaces
comes
in
this
category
.
The
approac
h
highligh
ted
in
terms
of
-p
olytop
es
is
not
applicable
to
non-con
v
ex
surfaces,
as
the
resulting
p
olytop
e
is
non-con
v
ex
and
its
con
v
ex
decomp
osition
w
ould
result
in
man
y
con
v
ex
p
olytop
es
(of
the
order
of
O
(=)).
Giv
en
t
w
o
B-spline
non-con
v
ex
surface
surfaces,
w
e
decomp
ose
them
in
to
a
series
of
B

ezier
surfaces.
After
decomp
osition
w
e
use
a
hierarc
hical
represen
tation
for
the
non-con
v
ex
surface.
The
heigh
t
of
the
resulting
tree
is
t
w
o.
Eac
h
leaf
no
de
corresp
onds
to
the
B

ezier
surface.
The
no
des
at
the
rst
lev
el
of
the
tree
corresp
ond
to
the
con
v
ex
h
ull
of
the
con
trol
p
olytop
e
of
eac
h
B

ezier
surface.
The
ro
ot
of
the
tree
represen
ts
the
union
of
the
con
v
ex
h
ull
of
all
these
p
olytop
es.
An
example
of
suc
h
a
hierarc
hical
represen
tation
is
sho
wn
in
Fig..
for
a
torus.
The
torus
is
comp
osed
of
biquadratic
B

ezier
surfaces,
sho
wn
at
the
leaf
no
des.
The
con
v
ex
p
olytop
es
at
the
rst
lev
el
are
the
con
v
ex
h
ull
of
con
trol
p
olytop
es
of
eac
h
B

ezier
surface
and
the
ro
ot
is
a
con
v
ex
h
ull
of
the
union
of
all
con
trol
p
oin
ts.
The
algorithm
pro
ceeds
on
the
hierarc
hical
represen
tation,
as
explained
in
Section
.
Ho
w
ev
er,
eac
h
leaf
no
de
is
a
B

ezier
surface.
The
fact
that
eac
h
surface
is
non-con
v
ex
implies
that
the
closest
p
oin
ts
of
the
p
olytop
es
ma
y
not
b
e
a
go
o
d
appro
ximation
to
the
closest
p
oin
ts
on
the
surface.
Moreo
v
er,
t
w
o
suc
h
surfaces


Figure
.:
Hierarc
hical
represen
tation
of
a
torus
comp
osed
of
B

ezier
surfaces


can
ha
v
e
more
than
one
closest
feature
at
an
y
time.
As
a
result,
lo
cal
optimization
metho
ds
highligh
ted
in
the
previous
sections
ma
y
not
w
ork
for
the
non-con
v
ex
ob
jects.
The
problem
of
collision
detection
b
et
w
een
t
w
o
B

ezier
surfaces
is
solv
ed
b
y
nding
all
the
solutions
to
the
equations
(.)
and
(.).
A
real
solution
in
the
domain
to
those
equations
implies
a
geometric
collision
and
a
precise
con
tact
b
et
w
een
the
mo
dels.
The
algebraic
metho
d
based
on
resultan
ts
and
eigen
v
alues
is
used
to
nd
all
the
solutions
to
the
equations
(.)
and
(.)
[
].
This
global
ro
ot
nder
is
used
when
the
con
trol
p
olytop
es
of
t
w
o
B

ezier
surfaces
collide.
A
t
that
instan
t
the
t
w
o
surfaces
ma
y
or
ma
y
not
ha
v
e
a
geometric
con
tact.
It
is
p
ossible
that
all
the
solutions
to
these
equations
are
complex.
The
set
of
equations
in
(.)
represen
ts
an
o
v
erconstrained
system
and
ma
y
ha
v
e
no
solution
in
the
complex
domain
as
w
ell.
Ho
w
ev
er,
w
e
apply
the
algebraic
metho
d
to
the
rst
four
equations
in
(.)
and
compute
all
the
solutions.
The
total
n
um
b
er
of
solutions
of
a
system
of
equations
is
b
ounded
b
y
the
Bezout
b
ound.
The
resultan
t
metho
d
computes
all
these
solutions.
As
the
ob
jects
mo
v
e,
w
e
up
date
the
co
ecien
ts
of
these
equations
based
on
the
rigid
motion.
W
e
obtain
a
new
set
of
equations
corresp
onding
to
(.)
and
(.),
whose
co
ecien
ts
are
sligh
tly
dieren
t
as
compared
to
the
previous
set.
All
the
ro
ots
of
the
new
set
of
equations
are
up
dated
using
Newton's
metho
d.
The
previous
set
of
ro
ots
are
used
as
initial
guesses.
The
o
v
erall
approac
h
is
lik
e
homotopy
metho
ds
[],
This
pro
cedure
represen
ts
an
algebraic
analog
of
the
geometric
coherence
exploited
in
the
earlier
section.
As
the
t
w
o
ob
jects
mo
v
e
closer
to
eac
h
other,
the
imaginary
comp
onen
ts
of
some
of
the
ro
ots
start
decreasing.
Finally
,
a
real
collision
o
ccurs,
when
the
imaginary
comp
onen
t
of
one
of
the
ro
ots
b
ecomes
zero.
W
e
do
not
ha
v
e
to
trac
k
all
the
paths
corresp
onding
to
the
total
n
um
b
er
of
solutions.
After
a
few
time
steps
w
e
only
k
eep
trac
k
of
the
solutions
whose
imaginary
comp
onen
ts
are
decreasing.
This
is
based
on
the
fact
that
the
n
um
b
er
of
closest
p
oin
ts
is
m
uc
h
lo
w
er
than
the
Bezout
b
ound
of
the
equations.


Chapter

In
terference
T
ests
for
Multiple
Ob
jects
In
a
t
ypical
en
vironmen
t,
there
are
mo
ving
ob
jects
and
stationary
obstacles
as
w
ell.
Assume
that
there
are
N
ob
jects
mo
ving
around
in
an
en
vironmen
t
of
M
stationary
obstacles.
Eac
h
of
N
mo
ving
ob
jects
is
also
considered
as
a
mo
ving
obstacle
to
the
other
mo
ving
ob
jects.
Keeping
trac
k
of
the
distance
for
0
@
N


A
+
N
M
pairs
of
ob
jects
at
all
time
can
b
e
quite
time
consuming,
esp
ecially
in
a
large
en
vironmen
t.
In
order
to
a
v
oid
unnecessary
computations
and
to
sp
eed
up
the
run
time,
w
e
presen
t
t
w
o
metho
ds:
one
assumes
the
kno
wledge
of
maxim
um
acceleration
and
v
elo
cit
y
,
the
other
purely
exploits
the
spatial
arrangemen
t
without
an
y
other
information
to
reduce
the
n
um
b
er
of
pairwise
in
terference
tests.
F
or
the
sc
heduling
sc
heme
in
whic
h
w
e
assume
the
dynamics
(v
elo
cities,
accelerations,
etc.)
is
kno
wn,
w
e
rely
on
the
fact
that
only
the
ob
ject
pairs
whic
h
ha
v
e
a
small
separation
are
lik
ely
to
ha
v
e
an
impact
within
the
next
few
time
instances,
and
those
ob
ject
pairs
whic
h
are
far
apart
from
eac
h
other
cannot
p
ossibly
come
to
in
terfere
with
eac
h
other
un
til
certain
time.
F
or
spatial
tests
to
reduce
the
n
um
b
er
of
pairwise
comparisons,
w
e
assume
the
en
vironmen
t
is
rather
sparse
and
the
ob
jects
mo
v
e
in
suc
h
a
w
a
y
that
the
geometric
coherence
can
b
e
preserv
ed,
i.e.
the
assumption
that
the
motion
is
essen
tially
con
tin
uous
in
time
domain.


.
Sc
heduling
Sc
heme
The
algorithm
main
tains
a
queue
(implem
e
n
ted
as
a
heap)
of
all
pairs
of
ob
jects
that
migh
t
collide
(e.g.
a
pair
of
ob
jects
whic
h
are
rigidly
attac
hed
to
eac
h
other
will
not
app
ear
in
the
queue).
They
are
sorted
b
y
lo
w
er
b
ound
on
time
to
collision;
with
the
one
most
lik
ely
to
collide
(i.e.
the
one
that
has
the
smallest
appro
ximate
time
to
collision)
app
earing
at
the
top
of
the
heap.
The
appro
ximation
is
a
lo
w
er
b
ound
on
the
time
to
collision,
so
no
collisions
are
missed.
Non-con
v
ex
ob
jects,
whic
h
are
represen
ted
as
hierarc
h
y
trees
as
describ
ed
in
Chapter
,
are
treated
as
single
ob
jects
from
the
p
oin
t
of
view
of
the
queue.
That
is,
only
the
ro
ots
of
the
hierarc
h
y
trees
are
paired
with
other
ob
jects
in
the
queue.
The
algorithm
rst
has
to
compute
the
initial
separation
and
the
p
ossible
collision
time
among
all
pairs
of
ob
jects
and
the
obstacles,
assuming
that
the
mag-
nitude
of
relativ
e
initial
v
elo
cit
y
,
relativ
e
maxim
um
acceleration
and
v
elo
cit
y
limits
among
them
are
giv
en.
After
initialization,
at
eac
h
step
it
only
computes
the
closest
feature
pair
and
the
distance
b
et
w
een
one
ob
ject
pair
of
our
in
terests,
i.e.
the
pair
of
ob
jects
whic
h
are
most
lik
ely
to
collide
rst;
mean
while
w
e
ignore
the
other
ob
ject
pairs
un
til
one
of
them
is
ab
out
to
collide.
Basically
,
the
algorithm
puts
all
the
ob
ject
pairs
to
sleep
un
til
the
clo
c
k
reac
hes
the
\w
ak
eup"
time
for
the
rst
pair
on
top
of
the
heap.
W
ak
eup
time
W
i
for
eac
h
ob
ject
pair
P
i
is
dened
as
W
i
=
t
i
w
+
t
0
where
t
i
w
is
the
lo
w
er
b
ound
on
the
time
to
collision
for
eac
h
pair
P
i
for
most
situations
(with
exceptions
describ
ed
in
the
next
sub-section)
and
t
0
is
the
curren
t
time.
..
Bounding
Time
to
Collision
Giv
en
a
tra
jectory
that
eac
h
mo
ving
ob
ject
will
tra
v
el,
w
e
can
determine
the
exact
collision
time.
Please
refer
to
[]
for
more
details.
If
the
path
that
eac
h
ob
ject
tra
v
els
is
not
kno
wn
in
adv
ance,
then
w
e
can
calculate
a
lo
w
er
b
ound
on
collision
time.
This
lo
w
er
b
ound
on
collision
time
is
calculated
adaptiv
ely
to
sp
eed
up
the
p
erformance
of
dynamic
collision
detection.

	
Let
a
max
b
e
an
upp
er
b
ound
on
the
relativ
e
acceleration
b
et
w
een
an
y
t
w
o
p
oints
on
an
y
pair
of
ob
jects.
The
b
ound
a
max
can
b
e
easily
obtained
from
b
ounds
on
the
relativ
e
absolute
linear
~
a
lin
and
relativ
e
rotational
accelerations
~
a
r
ot
and
relativ
e
rotational
v
elo
cities
~
!
r
of
the
b
o
dies
and
their
diameters:
~
a
max
=
~
a
lin
+
~
a
r
ot

~
r
+
~
!
r

(~
!
r

~
r
)
where
r
is
the
v
ector
dierence
b
et
w
een
the
cen
ters
of
mass
of
t
w
o
b
o
dies.
Let
d
b
e
the
initial
separation
for
a
giv
en
pair
of
ob
jects,
and
v
i
(where
~
v
i
=
~
v
lin
+
~
!
r

~
r
)
the
initial
relativ
e
v
elo
cit
y
of
closest
p
oin
ts
on
these
ob
jects.
Then
w
e
can
b
ound
the
time
t
c
to
collision
as
t
c
=
q
v

i
+
a
max
d
 v
i
a
max
(.)
This
is
the
minim
um
safe
time
that
is
added
to
the
curren
t
time
to
giv
e
the
w
ak
eup
time
for
this
pair
of
ob
jects.
T
o
a
v
oid
a
\Zeno's
parado
x"
condition
where
smaller
and
smaller
times
are
added
and
the
collision
is
nev
er
reac
hed,
w
e
m
ust
add
a
lo
w
er
b
ound
to
the
time
incremen
t.
So
rather
than
just
adding
t
c
as
deriv
ed
ab
o
v
e,
w
e
added
t
w
=
max
(t
c
;
t
min
),
where
t
min
is
a
constan
t
(sa
y

mSec
or

F
r
ameRate
)
whic
h
determines
the
eectiv
e
time
resolution
of
the
calculation.
As
a
side
note
here,
w
e
w
ould
lik
e
to
men
tion
the
fact
that
since
w
e
can
calculate
the
lo
w
er
b
ound
on
collision
time
adaptiv
ely
,
w
e
can
giv
e
a
fairly
go
o
d
estimate
of
exact
collision
time
to
the
precision
in
magnitude
of
t
min
.
In
addition,
since
the
lo
w
er
b
ound
on
time
to
collision
is
calculated
adaptiv
ely
for
the
ob
ject
most
lik
ely
to
collide
rst,
it
is
imp
ossible
for
the
algorithm
to
fail
to
detect
an
in
terp
enetration.
This
can
b
e
done
b
y
mo
difying
t
min
,
the
eectiv
e
time
resolution,
and
the
user
dened
safet
y
tolerance

according
to
the
en
vironmen
t
so
as
to
a
v
oid
the
case
where
one
ob
ject
collides
with
the
other
b
et
w
een
time
steps.

is
used
b
ecause
the
p
olyhedra
ma
y
b
e
actually
shrunk
b
y

amoun
t
to
appro
ximate
the
actual
ob
ject.
Therefore,
the
collision
should
b
e
declared
when
the
distance
b
et
w
een
t
w
o
con
v
ex
p
olytop
es
is
less
than
.
This
is
done
to
ensure
that
w
e
can
alw
a
ys
rep
ort
a
collision
or
near-misses.

0
..
The
Ov
erall
Approac
h
Our
sc
heme
for
dynamic
sim
ulation
using
our
distance
computation
algo-
rithm
is
an
iterativ
e
pro
cess
whic
h
con
tin
uously
inserts
and
deletes
the
ob
ject
pairs
from
a
heap
according
to
their
appro
ximate
time
to
collision,
as
the
ob
jects
mo
v
e
in
a
dynamic
en
vironmen
t.
It
is
assumed
that
there
is
a
function
A
i
(t)
giv
en
for
eac
h
ob
ject,
whic
h
returns
the
ob
ject's
p
ose
at
time
t,
as
a
x
matrix.
Initially
,
all
p
oses
are
determined
at
t
=
0,
and
the
distance
calculation
algorithm
in
Chapter

is
run
on
all
pairs
of
ob
jects
that
migh
t
collide.
The
pairs
are
inserted
in
to
the
heap
according
to
their
appro
ximate
time
to
collision.
Then
the
rst
pair
of
ob
jects
is
pulled
o
the
queue.
Its
closest
feature
pair
at
t
=
0
will
b
e
a
v
ailable,
and
the
distance
measuring
algorithm
from
Chapter
refdist
is
run.
If
a
collision
has
o
ccurred
and
b
een
rep
orted,
then
the
pair
is
re-inserted
in
the
queue
with
a
minim
um
time
incremen
t,
t
min
.
If
not,
a
new
lo
w
er
b
ound
on
time-to-collision
for
that
pair
is
computed,
and
the
pair
is
re-inserted
in
the
queue.
This
pro
cess
is
rep
eated
un
til
the
w
ak
eup
time
of
the
head
of
the
queue
exceeds
the
sim
ulation
time.
Note
that
the
lo
w
er
b
ound
on
collision
time
is
calculated
adaptiv
ely
for
the
pair
most
lik
ely
to
collide.
Therefore,
no
collision
can
b
e
missed.
W
e
will
not
need
to
w
orry
ab
out
those
sleeping
pairs
(whic
h
will
not
collide
b
efore
their
w
ak
e-up
time),
un
til
the
clo
c
k
reac
hes
the
w
ak
e-up
time
W
i
for
eac
h
pair
P
i
.
This
sc
heme
describ
ed
ab
o
v
e
can
tak
e
care
of
all
ob
ject
pairs
ecien
tly
so
that
the
distan
t
ob
ject
pairs
w
ak
e
up
m
uc
h
less
frequen
tly
.
Th
us,
it
reduces
the
run
time
in
a
signican
t
w
a
y
.
If
no
upp
er
b
ounds
on
the
v
elo
cit
y
and
acceleration
can
b
e
assumed,
in
the
next
section
w
e
prop
ose
algorithms
whic
h
imp
ose
a
b
ounding
b
o
x
hierarc
h
y
on
eac
h
ob
ject
in
the
en
vironmen
t
to
reduce
the
naiv
e
b
ound
of
0
@
N


A
pairwise
comparisons
for
a
dynamic
en
vironmen
t
of
n
ob
jects.
Once
the
ob
ject
pairs'
b
ounding
b
o
xes
already
collide,
then
w
e
can
apply
the
algorithm
describ
ed
in
Chapter

to
p
erform


collision
detection
and
to
nd
the
exact
con
tact
p
oin
ts
if
applicable.
.
Sw
eep
&
Sort
and
In
terv
al
T
ree
In
the
three-dimensional
w
orkspace,
if
t
w
o
b
o
dies
collide
then
their
pro
jec-
tions
do
wn
to
the
lo
w
er-dimensional
x
 y
;
y
 z
;
x
 z
h
yp
erplanes
m
ust
o
v
erlap
as
w
ell.
Therefore,
if
w
e
can
ecien
tly
up
date
their
o
v
erlapping
status
in
eac
h
axis
or
in
a
-dimensional
plane,
w
e
can
easily
eliminate
the
ob
ject
pairs
whic
h
are
denitely
not
in
con
tact
with
eac
h
other.
In
order
to
quic
kly
determine
all
ob
ject
pairs
o
v
er-
lapping
in
the
lo
w
er
dimensions,
w
e
imp
ose
a
virtual
b
ounding
b
o
x
hierarc
h
y
on
eac
h
b
o
dy
.
..
Using
Bounding
V
olumes
T
o
compute
exact
collision
con
tacts,
using
a
b
ounding
v
olume
for
an
in-
terference
test
is
not
sucien
t,
but
it
is
rather
ecien
t
for
eliminating
those
ob
ject
pairs
whic
h
are
of
no
immedi
ate
in
terests
from
the
p
oin
t
of
collision
dete
ction.
The
b
ounding
b
o
x
can
either
b
e
spherical
or
rectangular
(ev
en
elliptical),
dep
ending
on
the
application
and
the
en
vironmen
t.
W
e
prefer
spherical
and
rectangular
v
olume
due
to
their
simplicit
y
and
suitabilit
y
in
our
application.
Consider
an
en
vironmen
t
where
most
of
ob
jects
are
elongated
and
only
a
few
ob
jects
(probably
just
the
rob
ot
manipulators
in
most
situations)
are
mo
ving,
then
rectangular
b
ounding
b
o
xes
are
preferable.
In
a
more
dynamic
en
vironmen
t
lik
e
a
vibrating
parts
feeder
where
all
ob
jects
are
rather
\fat"
[]
and
b
ouncing
around,
then
spherical
b
ounding
b
o
xes
are
more
desirable.
If
the
ob
jects
are
con-
ca
v
e
or
articulated,
then
a
subpart-hierarc
hical
b
ounding
b
o
x
represen
tation
(similar
to
subpart-hierarc
hical
tree
represen
tation,
with
eac
h
no
de
storing
a
b
ounding
b
o
x)
should
b
e
emplo
y
ed.
The
reasons
for
using
eac
h
t
yp
e
of
the
b
ounding
v
olumes
are
as
follo
ws.
Using
a
spherical
b
ounding
v
olume,
w
e
can
precompute
the
b
o
x
during
the
prepro
cessing
step.
A
t
eac
h
time
step,
w
e
only
need
to
up
date
the
cen
ter
of
eac
h


spherical
v
olume
and
get
the
minim
um
and
maxim
um
x;
y
;
z
 co
ordinates
almost
instan
taneously
b
y
subtracting
the
measuremen
t
of
radius
from
the
co
ordinates
of
the
cen
ter.
This
in
v
olv
es
only
one
v
ector-matrix
m
ultipli
cation
and
six
simple
arithmetic
op
erations
(
addition
and

subtraction).
Ho
w
ev
er,
if
the
ob
jects
are
rather
oblong,
then
a
sphere
is
a
rather
p
o
or
b
ounding
v
olume
to
use.
Therefore,
a
rectangular
b
ounding
b
o
x
emerges
to
b
e
a
b
etter
c
hoice
for
elogated
ob
jects.
T
o
imp
ose
a
virtual
rectangular
b
ounding
v
olume
on
an
ob
ject
rotating
and
translating
in
space
in
v
olv
es
a
recomputation
of
the
rectangular
b
ound-
ing
v
olume.
Recomputing
a
rectangular
b
ounding
v
olume
is
done
b
y
up
dating
the
maxim
um
and
minim
um
x;
y
;
z
 co
ordinates
at
eac
h
time
instance.
This
is
a
simple
pro
cedure
whic
h
can
b
e
done
at
constan
t
time
for
eac
h
b
o
dy
.
W
e
can
up
date
the
\min"
and
\max"
b
y
the
follo
wing
approac
hes:
Since
the
b
ounding
b
o
xes
are
con
v
ex,
the
maxim
um
and
minim
um
in
the
x;
y
;
z
 co
ordinates
m
ust
b
e
the
co
ordinates
of
v
ertices.
W
e
can
use
a
mo
died
vertex-fac
e
routine
from
the
incremen
tal
distance
computation
algorithm
describ
ed
in
Chapter
.
W
e
can
set
up

imaginary
b
oundary
w
alls,
eac
h
of
these
w
alls
is
lo
cated
at
the
maximal
and
minim
al
x;
y
;
z
 co
ordinates
p
ossible
in
the
en
vironmen
t.
Giv
en
the
previous
b
ounding
v
olume,
w
e
can
up
date
eac
h
v
ertex
of
the
b
ounding
v
olume
b
y
p
erforming
only
half
of
mo
died
vertex-fac
e
test,
since
all
the
v
ertices
are
alw
a
ys
in
the
V
oronoi
regions
of
these
b
oundary
w
alls.
W
e
rst
nd
the
nearest
p
oin
t
on
the
b
oundary
w
all
to
the
previous
v
ertex
(after
motion
transformation)
on
the
b
ounding
v
olume,
then
w
e
v
erify
if
the
nearest
p
oin
t
on
the
b
oundary
w
all
lies
inside
of
the
V
oronoi
region
of
the
previous
v
ertex.
If
so,
the
previous
v
ertex
is
still
the
extremal
p
oin
t
(minim
um
or
maxim
um
in
x;
y
,
or
z
 axis).
When
a
constrain
t
is
violated
b
y
the
nearest
p
oin
t
on
the
face
(w
all)
to
the
previous
extremal
v
ertex,
the
next
feature
returned
will
b
e
the
neigh
b
oring
vertex,
instead
of
the
neigh
b
oring
edge.
This
is
a
simple
mo
dication
to
the
p
oin
t-v
ertex
applicabilit
y
criterion
routine.
It
still
preserv
es
the
prop
erties
of
lo
calit
y
and
coherence
w
ell.
This
approac
h
of
recomputing
b
ounding
v
olume
dynamically
in
v
olv
es

p
oint-vertex
applicabilit
y
tests.
Another
simple
metho
d
can
b
e
used
based
on
the
prop
ert
y
of
con
v
exit
y
.
A
t
eac
h
time
step,
all
w
e
need
to
do
is
to
c
hec
k
if
the
curren
t
minim
um
(or
max-


im
um)
v
ertex
in
x (or
y
;
z
 )co
ordinate
still
has
the
smallest
(or
largest)
x (or
y
;
z
 )co
ordinate
v
alues
in
comparison
to
its
neigh
b
oring
v
ertices.
By
p
erforming
this
v
erication
pro
cess
recursiv
ely
,
w
e
can
recompute
the
b
ounding
b
o
xes
at
exp
ected
constan
t
rate.
Once
again,
w
e
are
exploiting
the
temp
oral
and
geometric
coherence
and
the
lo
calit
y
of
con
v
ex
p
olytop
es.
W
e
only
up
date
the
b
ounding
v
olumes
for
the
mo
ving
ob
jects.
Therefore,
if
al
l
ob
jects
are
mo
ving
around
(esp
ecially
in
a
rather
unpredictable
w
a
y),
it's
hard
to
preserv
e
the
coherence
w
ell
and
the
up
date
o
v
erhead
ma
y
slo
w
do
wn
the
o
v
erall
computation.
But,
w
e
can
sp
eed
up
the
p
erformance
of
this
approac
h
b
y
realizing
that
w
e
are
only
in
terested
in
one
co
ordinate
v
alue
of
v
ertices
for
eac
h
up
date,
sa
y
x
co
ordinate
while
up
dating
the
minim
um
or
maxim
um
v
alue
in
x-axis.
Therefore,
there
is
no
need
to
transform
the
other
co
ordinates,
sa
y
y
and
z
v
alues,
in
up
dating
the
x
extremal
v
ertices
during
the
comparison
with
neigh
b
oring
v
ertices.
Therefore,
w
e
only
need
to
p
erform

v
ector-v
ector
m
ultiplicati
ons.
(
comes
from

up
dates
in
minim
um
and
maxim
um
in
x;
y
;
z
 co
ordinates
and
eac
h
up
date
in
v
olv
es

v
ector-
v
ector
m
ultiplications,
assuming
eac
h
v
ertex
has

neigh
b
oring
v
ertices.)
F
or
conca
v
e
and
articulated
b
o
dies,
w
e
need
to
use
a
hierarc
hical
b
ounding
b
o
x
structure,
i.e.
a
tree
of
b
ounding
b
o
xes.
Before
the
top
lev
el
b
ounding
b
o
xes
collide,
there
is
no
need
to
imp
ose
a
b
ounding
v
olume
on
eac
h
subpart
or
eac
h
link.
Once
the
collision
o
ccurs
b
et
w
een
the
paren
t
b
ounding
b
o
xes,
then
w
e
compute
the
b
ounding
b
o
xes
for
eac
h
c
hild
(subpart
or
link
age).
A
t
last
w
e
w
ould
lik
e
to
briey
men
tion
that
in
order
to
rep
ort
\near-misses",
w
e
should
\gro
w"
the
b
ounding
b
o
xes
b
y
a
small
amoun
t
to
ensure
that
w
e
p
erform
the
exact
collision
detection
algorithm
when
t
w
o
ob
jects
are
ab
out
to
collide,
not
after
they
collide.
Giv
en
the
details
of
computing
b
ounding
v
olume
dynamically
,
w
e
will
presen
t
t
w
o
approac
hes
whic
h
use
\sort
and
sw
eep"
tec
hniques
and
a
geometric
data
struc-
ture
to
quic
kly
p
erform
in
tersection
test
on
the
real
in
terv
als
to
reduce
the
n
um
b
er
of
pairwise
comparison.


..
One-Dimensi
onal
Sort
and
Sw
eep
In
computational
geometry
,
there
are
sev
eral
algorithms
whic
h
can
solv
e
the
o
v
erlapping
problem
for
d-dimensional
b
ounding
b
o
xes
in
O
(nl
og
d 
n
+
s)
time
where
s
is
the
n
um
b
er
of
pairwise
o
v
erlaps
[
,

,
0
].
This
b
ound
can
b
e
impro
v
ed
using
coherence.
Let
a
one-dimensional
b
ounding
b
o
x
b
e
[b;
e]
where
b
and
e
are
the
real
n
um
b
ers
represen
ting
the
b
eginning
and
ending
p
oin
ts.
T
o
determine
all
pairs
of
o
v
erlapping
in
terv
als
giv
en
a
list
of
n
in
terv
als,
w
e
need
to
v
erify
for
all
pairs
i
and
j
if
b
i

[b
j
;
e
j
]
or
b
j

[b
i
;
e
i
],


i
<
j

n.
This
can
b
e
solv
ed
b
y
rst
sorting
a
list
of
all
b
i
and
e
i
v
alues,
from
the
lo
w
est
to
the
highest.
Then,
the
list
is
tra
v
ersed
to
nd
all
the
in
terv
als
whic
h
o
v
erlap.
The
sorting
pro
cess
tak
es
O
(nl
og
n)
and
O
(n)
to
sw
eep
through
a
sorted
list
and
O
(s)
to
output
eac
h
o
v
erlap
where
s
is
the
n
um
b
er
of
o
v
erlap.
F
or
a
sparse
and
dynamic
en
vironmen
t,
w
e
do
not
an
ticipate
eac
h
b
o
dy
to
mak
e
a
relativ
ely
large
mo
v
em
en
t
b
et
w
een
time
steps,
th
us
the
sorted
list
should
not
c
hange
m
uc
h.
Consequen
tly
the
last
sorted
list
w
ould
b
e
a
go
o
d
starting
p
oin
t
to
con
tin
ue.
T
o
sort
a
\nearly
sorted"
list
b
y
bubble
sort
or
insertion
sort
can
b
e
done
in
O
(n
+
e)
where
e
is
the
n
um
b
er
of
exc
hanges.
All
w
e
need
to
do
no
w
is
to
k
eep
trac
k
of
\status
c
hange",
i.e.
from
o
v
erlap-
ping
in
the
last
time
step
to
non-o
v
erlapping
in
the
curren
t
time
step
and
vise
v
ersa.
W
e
k
eep
a
list
of
o
v
erlapping
in
terv
als
at
all
time
and
up
date
it
whenev
er
there
is
a
status
c
hange.
This
can
b
e
done
in
O
(n
+
e
x
+
e
y
+
e
z
)
time,
where
e
x
;
e
y
;
e
z
are
the
n
um
b
er
of
exc
hanges
along
the
x;
y
;
z
-co
ordinate.
Though
the
up
date
can
b
e
done
in
linear
time,
e
x
;
e
y
;
e
z
can
b
e
O
(n

)
with
an
extremely
small
constan
t.
Therefore,
the
exp
e
cte
d
run
time
is
linear
in
the
total
n
um
b
er
of
v
ertices.
T
o
use
this
approac
h
in
a
three-dimensional
w
orkspace,
w
e
pre-sort
the
mini-
m
um
and
maxim
um
v
alues
of
eac
h
ob
ject
along
the
x;
y
;
z
 axis
(as
if
w
e
are
imp
osing
a
virtual
b
ounding
b
o
x
hierarc
h
y
on
eac
h
b
o
dy),
sw
eep
through
eac
h
nearly
sorted
list
ev
ery
time
step
and
up
date
the
list
of
o
v
erlapping
in
terv
als
as
w
e
men
tioned
b
efore.
If
the
en
vironmen
t
is
sparse
and
the
motions
b
et
w
een
time
frames
are
\smo
oth",
w
e


exp
ect
the
extra
eort
to
c
hec
k
for
collision
will
b
e
negligible.
This
\pre-ltering"
pro
cess
to
eliminate
the
pairs
of
ob
jects
not
lik
ely
to
collide
will
run
essen
tially
in
linear
time.
A
similar
approac
h
has
b
een
men
tioned
b
y
Bara
in
[
].
This
approac
h
is
esp
ecially
suitable
for
an
en
vironmen
t
where
only
a
few
ob
jects
are
mo
ving
while
most
of
ob
jects
are
stationary
,
e.g.
a
virtual
w
alk-through
en
vironmen
t.
..
In
terv
al
T
ree
for
D
In
tersection
T
ests
Another
approac
h
is
to
extend
the
one-dimensional
sorting
and
sw
eeping
tec
hnique
to
higher
dimensional
space.
Ho
w
ev
er,
as
men
tioned
earlier,
the
time
b
ound
will
b
e
w
orse
than
O
(n)
for
t
w
o
or
three-dimensional
sort
and
sw
eep
due
to
the
dicult
y
to
mak
e
a
tree
structure
dynamic
and
exible
for
quic
k
insertion
and
deletion
of
a
higher
dimensional
b
o
xes.
Nev
ertheless,
for
more
dense
or
sp
ecial
en
vironmen
ts
(suc
h
as
a
mobile
rob
ot
mo
ving
around
in
a
ro
om
cluttered
with
mo
ving
obstacles,
suc
h
as
p
eople),
it
is
more
ecien
t
to
use
an
in
terv
al
tree
for
-dimensional
in
tersection
tests
to
reduce
the
n
um
b
er
of
pairwise
c
hec
ks
for
o
v
erlapping.
W
e
can
signican
tly
reduce
the
extra
eort
in
v
erifying
the
exc
hanges
c
hec
k
ed
b
y
the
one-dimensional
sort
and
sw
eep.
Here
w
e
will
briey
describ
e
the
data
structure
of
an
in
terv
al
tree
and
ho
w
w
e
use
it
for
in
tersection
test
of
-dimensional
rectangular
b
o
xes.
An
in
terv
al
tree
is
actually
a
r
ange
tr
e
e
prop
erly
annotated
at
the
no
des
for
fast
searc
h
of
real
in
terv
als.
Assume
that
n
in
terv
als
are
giv
en,
as
[b

;
e

];



;
[b
n
;
e
n
]
where
b
i
and
e
i
are
the
endp
oin
ts
of
the
in
terv
al
as
dened
ab
o
v
e.
The
range
tree
is
constructed
b
y
rst
sorting
all
the
endp
oin
ts
in
to
a
list
(x

;



;
x
m
)
in
ascending
order,
where
m

n.
Then,
w
e
construct
the
range
tree
top-do
wn
b
y
splitting
the
sort
list
L
in
to
the
left
subtree
L
l
and
the
righ
t
subtree
L
r
,
where
L
l
=
(x

;



;
x
p
)
and
L
r
=
(x
p+
;



;
x
m
).
The
ro
ot
has
the
split
v
alue
x
p
+x
p+

.
W
e
construct
the
subtrees
within
eac
h
subtree
recursiv
ely
in
this
fashion
till
eac
h
lea
v
e
con
tains
only
an
endp
oin
t.
The
construction
of
the
range
tree
for
n
in
terv
als
tak
es
O
(nl
og
n)
time.
After
w
e
construct
the
range
tree,
w
e
further
link
all
no
des
con
taining
stored
in
terv
als
in
a
doubly
link
ed
list
and
annotate
eac
h
no
de
if
it
or
an
y
of
its
descendan
t
con
tains


stored
in
terv
als.
The
em
b
ellished
tree
is
called
the
interval
tr
e
e.
W
e
can
use
the
in
terv
al
tree
for
static
query
,
as
w
ell
as
for
the
rectangle
in
tersection
problem.
T
o
c
hec
k
for
rectangle
in
tersection
using
the
sw
eep
algorithm:
w
e
tak
e
a
sw
eeping
line
parallel
to
the
y
axis
and
sw
eep
in
increasing
x
direction,
and
lo
ok
for
o
v
erlapping
y
in
terv
als.
As
w
e
sw
eep
across
the
x
axis,
y
in
terv
als
app
ears
or
disapp
ear.
Whenev
er
there
is
an
app
earing
y
in
terv
al,
w
e
c
hec
k
to
see
if
the
new
in
terv
al
in
tersects
the
old
set
of
in
terv
als
stored
in
the
in
terv
al
tree,
rep
ort
all
in
terv
als
it
in
tersects
as
rectangle
in
tersection,
and
add
the
new
in
terv
al
to
the
tree.
Eac
h
query
of
in
terv
al
in
tersection
tak
es
O
(l
og
n
+
k
)
time
where
k
is
the
n
um
b
er
of
rep
orted
in
tersection
and
n
is
the
n
um
b
er
of
in
terv
als.
Therefore,
rep
orting
in
tersection
among
n
rectangles
can
b
e
done
in
O
(nl
og
n
+
K
)
where
K
is
the
total
n
um
b
er
of
in
tersecting
rectangles.
.
Other
Approac
hes
Here
w
e
will
also
briey
men
tion
a
few
dieren
t
approac
hes
whic
h
can
b
e
used
in
other
en
vironmen
ts
or
applications.
..
BSP-T
rees
and
Octrees
One
of
the
commonly
used
tree
structure
is
BSP-tree
(binary
space
parti-
tioning
tree)
to
sp
eed
up
in
tersection
tests
in
CSG
(constructiv
e
solid
geometry)
[].
This
approac
h
construct
a
tree
from
separating
planes
at
eac
h
no
de
recursiv
ely
.
It
partitions
eac
h
ob
ject
in
to
groups
of
parts
whic
h
are
close
together
in
binary
space.
When,
the
separation
planes
are
c
hosen
to
b
e
aligned
with
the
co
ordinate
axes,
then
a
BSP
tree
b
ecomes
more
or
less
lik
e
an
o
ctree.
One
can
think
of
an
o
ctree
as
tree
of
cub
es
within
cub
es.
But,
the
size
of
the
cub
e
v
aries
dep
ending
on
the
n
um
b
er
of
ob
jects
o
ccup
ying
that
region.
A
sparsely
p
opulated
region
is
co
v
ered
b
y
one
large
cub
e,
while
a
densely
o
ccupied
region
is
divided
in
to
more
smaller
cub
es.
Eac
h
cub
e
can
b
e
divided
in
to

smaller
cub
es
if
necessary
.
So,
eac
h
no
de
in
the
tree
has

c
hildren
(lea
v
es).


Another
mo
died
v
ersion
of
BSP-T
ree
prop
osed
b
y
V
anecek
[]
is
a
m
ulti-
dimensional
space
partitioning
tree
called
Br
ep-Index.
This
tree
structure
is
used
for
collision
detection
[0
]
b
et
w
een
mo
ving
ob
jects
in
a
system
called
Pr
oxima
dev
elop
ed
at
Prudue
Univ
ersit
y
.
The
problem
with
tree
structures
is
similar
to
that
of
using
-d
in
terv
al
tree
that
its
up
date
(insertion
and
deletion)
is
inexible
and
cum
b
ersome,
esp
ecially
for
a
large
tree.
The
o
v
erhead
of
insertion
and
deletion
of
a
no
de
in
a
tree
can
easily
dominate
the
run
time,
esp
ecially
when
a
collision
o
ccurs.
The
tree
structures
also
cannot
capture
the
temp
oral
and
spatial
coherence
w
ell.
..
Uniform
Spatial
Sub
division
W
e
can
divide
the
space
in
to
unit
cells
(or
v
olumes)
and
place
eac
h
ob
ject
(or
b
ounding
b
o
x)
in
some
cell(s)
[].
T
o
c
hec
k
for
collisions,
w
e
ha
v
e
to
examine
the
cell(s)
o
ccupied
b
y
eac
h
b
o
x
to
v
erify
if
the
cell(s)
is(are)
shared
b
y
other
ob
jects.
But,
it
is
dicult
to
set
a
near-optimal
size
for
eac
h
cell
and
it
requires
tremendous
amoun
t
of
allo
cated
mem
ory
.
If
the
size
of
the
cell
is
not
prop
erly
c
hosen,
the
computation
can
b
e
rather
exp
ensiv
e.
F
or
an
en
vironmen
t
where
almost
all
ob
jects
are
of
uniform
size,
lik
e
a
vibrating
parts
feeder
b
o
wl
or
molecular
mo
deling
[,

],
this
is
a
rather
ideal
algorithm,
esp
ecially
to
run
on
a
parallel-computing
mac
hine.
In
fact,
Ov
ermars
has
sho
wn
that
using
a
hash
table
to
lo
ok
up
an
enetry
,
w
e
can
use
a
data
structure
of
O(n)
storage
space
to
p
erform
the
p
oin
t
lo
cation
queries
in
constan
t
time
[].
.
Applications
in
Dynamic
Sim
ulation
and
Vir-
tual
En
vironmen
t
The
algorithms
presen
ted
in
this
c
hapter
ha
v
e
b
een
utilized
in
dynamic
sim
ulation
as
w
ell
as
in
a
w
alk-through
en
vironmen
t.
These
applications
attest
for
the
practicalit
y
of
the
algorithms
and
the
imp
ortance
of
the
problem
natures.
The
algorithm
describ
ed
in
Sec.
.
and
the
distance
computation
algorithm
describ
ed
in
Chapter

ha
v
e
b
een
used
in
the
dynamics
sim
ulator
written
b
y
Mirtic
h


[].
It
reduces
the
frequency
of
the
collision
c
hec
ks
signican
tly
and
helps
to
sp
eed
up
the
calculations
of
the
dynamic
sim
ulator
considerably
.
Our
vision
of
this
dynamic
sim
ulator
is
the
abilit
y
to
to
sim
ulate
thousands
of
small
mec
hanical
parts
on
a
vibrating
parts
feeder
in
real
time.
Lo
oking
at
our
curren
t
progress,
w
e
b
eliev
e
suc
h
a
goal
is
attainable
using
the
collision
detection
algorithms
describ
ed
in
this
thesis.
A
t
the
same
time,
the
algorithm
describ
ed
in
Sec.
..
is
curren
tly
under
testing
to
b
e
ev
en
tually
in
tegrated
in
to
a
W
alk-Through
en
vironmen
t
dev
elop
ed
at
the
Univ
ersit
y
of
North
Carolina,
Chap
el
Hill
on
their
in-house
Pixel
Plane
mac
hine
[].
In
a
virtual
w
orld
lik
e
\w
alk-through
en
vironmen
t"
where
a
h
uman
needs
to
in
teract
with
his/her
surrounding,
it
is
imp
ortan
t
that
the
computer
can
sim
ulate
the
in
teractions
of
the
h
uman
participan
ts
with
the
passiv
ely
or
activ
ely
c
hanging
en
vironmen
t.
Since
the
usual
mo
dels
of
\w
alk-through"
are
rather
complex
and
ma
y
ha
v
e
thousands
of
ob
jects
in
the
w
orld,
an
algorithm
as
describ
ed
in
Sec.
..
b
ecomes
an
essen
tial
comp
onen
t
to
generate
a
realism
of
motions.

	
Chapter

An
Opp
ortunistic
Global
P
ath
Planner
The
algorithm
describ
ed
in
Chapter

is
a
k
ey
part
of
our
general
planning
algorithm
presen
ted
in
this
c
hapter.
This
path
planning
algorithm
creates
an
one-
dimensional
roadmap
of
the
free
space
of
a
rob
ot
b
y
tracing
out
curv
es
of
maximal
clearance
from
obstacles.
W
e
use
the
distance
computation
algorithm
to
incremen
tall
y
compute
distances
b
et
w
een
the
rob
ot
pieces
and
the
nearb
y
obstacles.
F
rom
there
w
e
can
easily
compute
gradien
ts
of
the
distance
function
in
conguration
space,
and
thereb
y
nd
the
direction
of
the
maximal
clearance
curv
es.
This
is
done
b
y
rst
nding
the
pairs
of
closest
features
b
et
w
een
the
rob
ot
and
the
obstacles,
and
then
k
eeping
trac
k
of
these
closest
pairs
incremen
tally
b
y
calls
to
this
algorithm.
The
curv
es
traced
out
b
y
this
algorithm
are
in
fact
maximall
y
clear
of
the
obstacles.
As
men
tioned
earlier,
once
a
pair
of
initialization
features
in
the
vicinit
y
of
the
actual
closest
pair
is
found,
the
algorithm
tak
es
a
v
ery
short
time
(usually
constan
t)
to
nd
the
actual
closest
pair
of
features.
Giv
en
the
closest
features,
it
is
straigh
t
forw
ard
to
compute
the
gradien
t
of
the
distance
function
in
conguration
space
whic
h
is
what
w
e
need
to
trace
the
sk
eleton
curv
es.
In
this
c
hapter,
w
e
will
describ
e
an
opp
ortunistic
global
path
planner
whic
h
uses
the
opp
ortunistic
lo
cal
metho
d
(Chapter
)
to
build
up
the
one-dimensional
sk
eleton
(or
freew
a
y)
and
global
computation
to
nd
the
critical
p
oin
ts
where
linking

	0
curv
es
(or
bridges)
are
constructed.
.
Bac
kground
There
ha
v
e
b
een
t
w
o
ma
jor
approac
hes
to
motion
planning
for
manipulators,
(i)
lo
cal
metho
ds,
suc
h
as
articial
p
oten
tial
eld
metho
ds
[0],
whic
h
are
usually
fast
but
are
not
guaran
teed
to
nd
a
path,
and
(ii)
global
metho
ds,
lik
e
the
rst
Roadmap
Algorithm
[
],
whic
h
is
guaran
teed
to
nd
a
path
but
ma
y
sp
end
a
long
time
doing
it.
In
this
c
hapter,
w
e
presen
t
an
algorithm
whic
h
has
c
haracteristics
of
b
oth.
Our
metho
d
is
an
incremen
tal
construction
of
a
sk
eleton
of
free-space.
Lik
e
the
p
oten
tial
eld
metho
ds,
the
curv
es
of
this
sk
eleton
lo
cally
maximiz
es
a
certain
p
oten
tial
function
that
v
aries
with
distance
from
obstacles.
Lik
e
the
Roadmap
Algorithm,
the
sk
eleton,
computed
incremen
tall
y
,
is
ev
en
tually
guaran
teed
to
con
tain
a
path
b
et
w
een
t
w
o
congurations
if
one
exists.
The
size
of
the
sk
eleton
in
the
w
orst
case,
is
comparable
with
the
w
orst-case
size
of
the
roadmap.
Unlik
e
the
lo
cal
metho
ds,
our
algorithm
nev
er
gets
trapp
ed
in
lo
cal
extremal
p
oin
ts.
Unlik
e
the
Roadmap
Algorithm,
our
incremen
tal
algorithm
can
tak
e
adv
an-
tage
of
a
non-w
orst-case
en
vironmen
t.
The
complexit
y
of
the
roadmap
came
from
the
need
to
tak
e
recursiv
e
slices
through
conguration
space.
In
our
incremen
tal
algorithm,
slices
are
only
tak
en
when
an
initial
searc
h
fails
and
there
is
a
\bridge"
through
free
space
linking
t
w
o
\c
hannels".
The
new
algorithm
is
no
longer
recursiv
e
b
ecause
bridges
can
b
e
computed
directly
b
y
hill-clim
bi
ng
.
The
bridges
are
built
near
\in
teresting"
critical
p
oin
ts
and
inection
p
oin
ts.
The
conditions
for
a
bridge
are
quite
strict.
P
ossible
candidate
critical
p
oin
ts
can
b
e
lo
cally
c
hec
k
ed
b
efore
a
slice
is
tak
en.
W
e
exp
ect
few
slices
to
b
e
required
in
t
ypical
en
vironmen
ts.
In
fact,
w
e
can
mak
e
a
stronger
statemen
t
ab
out
completeness
of
the
algo-
rithm.
The
sk
eleton
that
the
algorithm
computes
ev
en
tually
con
tains
paths
that
are
homotopic
to
all
paths
in
free
space.
Th
us,
once
w
e
ha
v
e
computed
slices
through
all
the
bridges,
w
e
ha
v
e
a
complete
description
of
free-space
for
the
purp
oses
of
path
planning.
Of
course,
if
w
e
only
w
an
t
to
nd
a
path
joining
t
w
o
giv
en
p
oin
ts,
w
e
stop
the
algorithm
as
so
on
as
it
has
found
a
path.

	
The
tracing
of
individual
sk
eleton
curv
es
is
a
simple
enough
task
that
w
e
exp
ect
that
it
could
b
e
done
in
real
time
on
the
rob
ot's
con
trol
hardw
are,
as
in
other
articial
p
oten
tial
eld
algorithms.
Ho
w
ev
er,
since
the
rob
ot
ma
y
ha
v
e
to
bac
ktrac
k
to
pass
across
a
bridge,
it
do
es
not
seem
w
orth
while
to
do
this
during
the
searc
h.
F
or
those
readers
already
familiar
with
the
Roadmap
Algorithm,
the
follo
w-
ing
description
ma
y
help
with
understanding
of
the
new
metho
d:
If
the
conguration
space
is
R
k
,
then
w
e
can
construct
a
h
yp
ersurface
in
R
k
+
whic
h
is
the
graph
of
the
p
oten
tial
function,
i.e.
if
P
(x

;
:
:
:
;
x
k
)
is
the
p
oten
tial,
the
h
yp
ersurface
is
the
set
of
all
p
oin
ts
of
the
form
(x

;
:
:
:
;
x
k
;
P
(x

;
:
:
:
;
x
k
)).
The
sk
eleton
w
e
dene
here
is
a
subset
of
a
roadmap
(in
the
sense
of
[])
of
this
h
yp
ersurface.
This
w
ork
builds
on
a
considerable
v
olume
of
w
ork
in
b
oth
global
motion
planning
metho
ds
[]
[],
[],
[],
and
lo
cal
planners,
[0
].
Our
metho
d
shares
a
common
theme
with
the
w
ork
of
Barraquand
and
Latom
b
e
[]
in
that
it
attempts
to
use
a
lo
cal
p
oten
tial
eld
planner
for
sp
eed
with
some
pro
cedure
for
escaping
lo
cal
maxima.
But
whereas
Barraquand
and
Latom
b
e's
metho
d
is
a
lo
cal
metho
d
made
global,
w
e
ha
v
e
tak
en
a
global
metho
d
(the
Roadmap
Algorithm)
and
found
a
lo
cal
opp
ortunistic
w
a
y
to
compute
it.
Although
our
starting
p
oin
t
w
as
completely
dieren
t,
there
are
some
other
similarities
with
[].
Our
\freew
a
ys"
resem
ble
the
v
alleys
in
tuitiv
ely
describ
ed
in
[].
But
the
main
dierence
b
et
w
een
our
metho
d
and
the
metho
d
in
[]
is
that
w
e
ha
v
e
a
guaran
teed
(and
reasonably
ecien
t)
metho
d
of
escaping
lo
cal
p
oten
tial
extremal
p
oin
ts
and
that
our
p
oten
tial
function
is
computed
in
the
conguration
space.
The
c
hapter
is
organized
as
follo
ws:
Section
.
con
tains
a
simple
and
gen-
eral
description
of
roadmaps.
The
description
delib
erately
ignores
details
of
things
lik
e
the
distance
function
used,
b
ecause
the
algorithm
can
w
ork
with
almost
an
y
function.
Section
.
giv
es
some
particulars
of
the
application
of
articial
p
oten
tial
elds.
Section
.
describ
es
our
incremen
tal
algorithm,
rst
for
rob
ots
with
t
w
o
de-
grees
of
freedom,
then
for
three
degrees
of
freedom.
Section
.
giv
es
the
pro
of
of
completeness
for
this
algorithm.

	
.
A
Maxim
um
Clearance
Roadmap
Algorithm
W
e
denote
the
space
of
all
congurations
of
the
rob
ot
as
C
S
.
F
or
example,
for
a
rotary
join
t
rob
ot
with
k
join
ts,
the
conguration
space
C
S
is
R
k
,
the
set
of
all
join
t
angle
tuples
(

;
:
:
:
;

k
).
The
set
of
congurations
where
the
rob
ot
o
v
erlaps
some
obstacle
is
the
conguration
space
obstacle
C
O
,
and
the
compleme
n
t
of
C
O
is
the
set
of
free
(non-o
v
erlapping)
congurations
F
P
.
As
describ
ed
in
[],
F
P
is
b
ounded
b
y
algebraic
h
yp
ersurfaces
in
the
parameters
t
i
after
the
standard
substitution
t
i
=
tan(

i

).
This
result
is
needed
for
the
complexit
y
b
ounds
in
[]
but
w
e
will
not
need
it
here.
A
roadmap
is
a
one-dimensional
subset
of
F
P
that
is
guaran
teed
to
b
e
connected
within
eac
h
connected
comp
onen
t
of
F
P
.
Roadmaps
are
describ
ed
in
some
detail
in
[]
where
it
is
sho
wn
that
they
can
b
e
computed
in
time
O
(n
k
log
n(d
O
(n

)
))
for
a
rob
ot
with
k
degrees
of
freedom,
and
where
free
space
is
dened
b
y
n
p
olynomial
constrain
ts
of
degree
d
[
].
But
n
k
ma
y
still
b
e
to
o
large
for
man
y
applications,
and
in
man
y
cases
the
free
space
is
m
uc
h
simpler
than
its
w
orst
case
complexit
y
,
whic
h
is
O
(n
k
).
W
e
w
ould
lik
e
to
exploit
this
simplicit
y
to
the
maxim
um
exten
t
p
ossible.
The
results
of
[]
suggest
that
in
practice
free
space
is
usually
m
uc
h
simpler
than
the
w
orst
case
b
ounds.
What
w
e
will
describ
e
is
a
metho
d
aimed
at
getting
a
minim
al
description
of
the
connectivit
y
of
a
particular
free
space.
The
original
description
of
roadmaps
is
quite
tec
hnical
and
in
tricate.
In
this
pap
er,
w
e
giv
e
a
less
formal
and
hop
efully
more
in
tuitiv
e
description.
..
Denitions
Supp
ose
C
S
has
co
ordinates
x

;
:
:
:
;
x
k
.
A
slice
C
S
j
v
is
a
slice
b
y
the
h
y-
p
erplane
x

=
v
.
Similarly
,
slicing
F
P
with
the
same
h
yp
erplane
giv
es
a
set
denoted
F
P
j
v
.
The
algorithm
is
based
on
the
k
ey
notion
of
a
c
hannel
whic
h
w
e
dene
next:
A
channel-slic
e
of
free
space
F
P
is
a
connected
comp
onen
t
of
some
slice
F
P
j
v
.

	
The
term
c
hannel-slice
is
used
b
ecause
these
sets
are
precursors
to
c
hannels.
T
o
construct
a
c
hannel
from
c
hannel
slices,
w
e
v
ary
v
o
v
er
some
in
terv
al.
As
w
e
do
this,
for
most
v
alues
of
v
,
all
that
happ
ens
is
that
the
connected
comp
onen
ts
of
F
P
j
v
c
hange
shap
e
con
tin
uously
.
As
v
increases,
there
are
ho
w
ev
er
a
nite
n
um
b
er
of
v
alues
of
v
,
called
critic
al
values,
at
whic
h
there
is
some
top
ological
c
hange.
Some
ev
en
ts
are
not
signican
t
for
us,
suc
h
as
where
the
top
ology
of
a
comp
onen
t
of
the
cross-section
c
hanges,
but
there
are
four
imp
ortan
t
ev
en
ts:
As
v
increases
a
connected
comp
onen
t
of
F
P
j
v
ma
y
app
ear
or
disapp
ear,
or
sev
eral
comp
onen
ts
ma
y
join,
or
a
single
comp
onen
t
ma
y
split
in
to
sev
eral.
The
p
oin
ts
where
joins
or
splits
o
ccur
are
called
inter
esting
critic
al
p
oints.
W
e
dene
a
c
hannel
as
a
maximal
connected
union
of
cross
sections
that
con
tains
no
image
of
in
teresting
critical
p
oin
ts.
W
e
use
the
notation
F
P
j
(a;b)
to
mean
the
subset
of
F
P
where
x


(a;
b)

R.
A
channel
through
F
P
is
a
connected
comp
onen
t
of
F
P
(a;b)
con
taining
no
splits
or
joins,
and
(maximali
t
y)
whic
h
is
not
con
tained
in
a
connected
comp
onen
t
of
F
P
(c;d)
con
taining
no
splits
or
joins,
for
(c;
d)
a
prop
er
sup
erset
of
(a;
b).
See
Fig.
.
for
an
example
of
c
hannels.
The
prop
ert
y
of
no
splits
or
joins
can
b
e
stated
in
another
w
a
y
.
A
maximal
connected
set
C
j
(a;b)

F
P
j
(a;b)
is
a
c
hannel
if
ev
ery
subset
C
j
(e;f
)
is
connected
for
(e;
f
)

(a;
b).
..
The
General
Roadmap
No
w
to
the
heart
of
the
metho
d.
A
roadmap
has
t
w
o
comp
onen
ts:
(i)
F
reew
a
ys
(called
silhouette
curv
es
in
[])
and
(ii)
Bridges
(called
linking
curv
es
in
[
]).
A
freew
a
y
is
a
connected
one-dimensional
subset
of
a
c
hannel
that
forms
a
bac
kb
one
for
the
c
hannel.
The
k
ey
prop
erties
of
a
freew
a
y
are
that
it
should
span
the
c
hannel,
and
b
e
con
tin
uable
in
to
adjacen
t
c
hannels.
A
freew
a
y
sp
ans
a
c
hannel
if
its
range
of
x

v
alues
is
the
same
as
the
c
hannels,
i.e.
a
freew
a
y
for
the
c
hannel
C
j
(a;b)
m
ust
ha
v
e
p
oin
ts
with
all
x

co
ordinates
in
the
range
(a;
b).
A
freew
a
y
is
c
ontinuable
if
it
meets

	
CO
Channels
x1
Figure
.:
A
sc
hematized
-d
conguration
space
and
the
partition
of
free
space
in
to
x

-c
hannels.

	
another
freew
a
y
at
its
endp
oin
ts.
i.e.
if
C
j
(a;b
)
and
C
0
j
(b;c)
are
t
w
o
adjacen
t
c
hannels,
the
b
endp
oin
t
of
a
freew
a
y
of
C
j
(a;b)
should
meet
an
endp
oin
t
of
a
freew
a
y
of
C
0
j
(b;c)
.
(T
ec
hnically
,
since
the
in
terv
als
are
op
en,
the
w
ord
\endp
oin
t"
should
b
e
replaced
b
y
\limit
p
oin
t")
In
general,
when
a
sp
ecic
metho
d
of
computing
freew
a
y
curv
es
is
c
hosen,
there
ma
y
b
e
sev
eral
freew
a
ys
within
one
c
hannel.
F
or
example,
in
the
rest
of
this
c
hapter,
freew
a
ys
are
dened
using
articial
p
oten
tial
functions
whic
h
are
directly
prop
ortional
to
distance
from
obstacles.
In
this
case
eac
h
freew
a
y
is
the
lo
cus
of
lo
cal
maxima
in
p
oten
tial
within
slices
F
P
j
v
of
F
P
as
v
v
aries.
This
lo
cus
itself
ma
y
ha
v
e
some
critical
p
oin
ts,
but
as
w
e
shall
see,
the
freew
a
y
curv
es
can
b
e
extended
easily
past
them.
Since
there
ma
y
b
e
sev
eral
lo
cal
p
oten
tial
maxima
within
a
slice,
w
e
ma
y
ha
v
e
sev
eral
disjoin
t
freew
a
y
curv
es
within
a
single
c
hannel,
but
with
our
incremen
tal
roadmap
construction,
this
is
p
erfectly
OK.
No
w
to
bridges.
A
bridge
is
a
one-dimensional
set
whic
h
links
freew
a
ys
from
c
hannels
that
ha
v
e
just
joined,
or
are
ab
out
to
split
(as
v
increases).
Supp
ose
t
w
o
c
hannels
C

and
C

ha
v
e
joined
in
to
a
single
c
hannel
C

,
as
sho
wn
in
Fig.
..
W
e
kno
w
that
the
freew
a
ys
of
C

and
C

will
con
tin
ue
in
to
t
w
o
freew
a
y
curv
es
in
C

.
These
freew
a
ys
within
C

are
not
guaran
teed
to
connect.
Ho
w
ev
er,
w
e
do
kno
w
that
b
y
denition
C

is
connected
in
the
slice
slice
x

=
v
through
the
critical
p
oin
t,
so
w
e
add
linking
curv
es
from
the
critical
p
oin
t
to
some
freew
a
y
p
oin
t
in
eac
h
of
C

and
C

.
It
do
es
not
matter
whic
h
freew
a
y
p
oin
t,
b
ecause
the
freew
a
y
curv
es
inside
the
c
hannels
C

and
C

m
ust
b
e
connected
within
eac
h
c
hannel,
as
w
e
sho
w
in
Sec.
..
By
adding
bridges,
w
e
guaran
tee
that
whenev
er
t
w
o
c
hannels
meet
(some
p
oin
ts
on)
their
freew
a
ys
are
connected.
Once
w
e
can
sho
w
that
whenev
er
c
hannels
meet,
their
freew
a
ys
do
also
(via
bridges),
w
e
ha
v
e
sho
wn
that
the
roadmap,
whic
h
is
the
union
of
freew
a
ys
and
bridges,
is
connected.
The
pro
of
of
this
v
ery
in
tuitiv
e
result
is
a
simple
inductiv
e
argumen
t
on
the
(nite
n
um
b
er
of
)
c
hannels,
giv
en
in
Sec.
..
The
basic
structure
of
the
general
Roadmap
Algorithm
follo
ws:

	
C2
Bridge
Freeways
C3
C1
Figure
.:
Tw
o
c
hannels
C

and
C

joining
the
c
hannel
C

,
and
a
bridge
curv
e
in
C

.

	
.
Start
tracing
a
freew
a
y
curv
e
from
the
start
conguration,
and
also
from
the
goal.
.
If
the
curv
es
leading
from
the
start
and
goal
are
not
connected,
en
umerate
a
split
or
join
p
oin
t,
and
add
a
bridge
curv
e
\near"
the
split
or
join
(x

-co
ordinate
of
the
slice
sligh
tly
greater
than
that
of
the
join
t
p
oin
t
for
a
join,
sligh
tly
less
for
a
split).
.
Find
all
the
p
oin
ts
on
the
bridge
curv
e
that
lie
on
other
freew
a
ys,
and
trace
from
these
freew
a
ys.
Go
to
step
().
The
algorithm
terminates
at
step
()
when
either
the
start
and
goal
are
connected,
in
whic
h
case
the
algorithm
signals
success
and
returns
a
connecting
path,
or
if
it
runs
out
of
split
and
join
p
oin
ts,
in
whic
h
case
there
is
no
path
connecting
the
start
and
goal.
This
description
is
quite
abstract,
but
in
later
sections
w
e
will
giv
e
detailed
description
of
the
approac
h
in
t
w
o-
and
three-dimensional
conguration
spaces.
Three
things
distinguish
our
new
algorithm
from
the
previous
Roadmap
Algorithm.
The
most
imp
ortan
t
is
that
the
new
algorithm
is
not
recursiv
e.
Step

in
v
olv
es
adding
a
bridge
curv
e
whic
h
is
t
w
o
pieces
of
curv
e
found
b
y
hill-clim
bi
ng
on
the
p
oten
tial.
In
the
original
roadmap
algorithm,
linking
curv
es
had
to
b
e
dened
recursiv
ely
,
b
ecause
it
is
not
p
ossible
to
hill-clim
b
to
a
maxim
um
with
an
algebraic
curv
e.
Another
dierence
is
that
the
freew
a
ys
do
not
necessarily
lie
near
the
b
oundary
of
free
space
as
they
did
in
[].
In
our
presen
t
implem
en
tation
w
e
are
in
fact
using
maxim
um
clearance
freew
a
ys.
But
the
most
imp
ortan
t
dierence
is
that
w
e
no
w
only
en
umerate
true
split
or
join
p
oin
ts.
F
or
a
rob
ot
with
k
degrees
of
freedom
and
an
en
vironmen
t
of
complexit
y
n,
it
can
b
e
sho
wn
that
there
are
at
most
O
(n
(k
 )
)
p
oten
tial
split
or
join
p
oin
ts.
(Please
refer
to
Sec.
pro
of.planner
for
the
pro
of
on
the
upp
er
b
ound
for
the
maxim
um
n
um
b
er
of
in
teresting
critical
p
oin
ts.)
But
man
y
exp
erimen
ts
with
implem
e
n
ted
planners
in
recen
t
y
ears
ha
v
e
sho
wn
that
the
n
um
b
er
of
true
splits
or
joins
in
t
ypical
conguration
spaces
is
m
uc
h
lo
w
er.
In
our
new
algorithm,
w
e
can
mak
e
a
purely
lo
cal
test
on
a
p
oten
tial
split
or
join
p
oin
t
to
see
if
it
is
really
qualied.
The
v
ast
ma
jorit
y
of
candidates
will
not
b
e,
so
w
e
exp
ect
far

	
few
er
than
O
(n
(k
 )
)
bridges
to
b
e
required.
Denition
A
p
oin
t
p
in
R
k
+
is
an
inter
esting
critic
al
p
oint
if
for
ev
ery
neigh
b
orho
o
d
U
of
p,
one
of
the
follo
wing
holds:
(i)
The
in
tersection
U
\
x
 

(x

(p)
+
)
consists
of
sev
eral
connected
comp
onen
ts
for
all
sucien
tly
small
.
This
is
a
generalized
split
p
oin
t.
(ii)
The
in
tersection
U
\
x
 

(x

(p)
 )
consists
of
sev
eral
comp
onen
ts
for
all
su-
cien
tly
small
.
This
is
a
generalized
join
p
oin
t.
W
e
will
assume
the
en
vironmen
t
is
generic,
i.e.
there
is
no
sp
ecial
top
ology
suc
h
that
a
small
p
erturbation
will
c
hange
the
clearance
of
the
paths.
This
is
true
for
almost
all
practical
situations:
most
obstacles
ha
v
e
a
reasonably
large
in
terior
space
that
a
small
p
erturbation
will
not
aect
m
uc
h
of
the
obstacle
conguration
space.
Based
on
the
transv
ersalit
y
condition
of
general
p
osition
assumptions
in
[],
the
in
teresting
critical
p
oin
ts
can
b
e
computed
as
follo
ws.
Let
S
b
e
the
set
of
equations
used
to
calculate
the
critical
p
oin
ts.
The
set
S
is
dened
b
y
inequalities,
and
its
b
oundary
is
a
union
of
surfaces
of
v
arious
dimensions.
Let
S

b
e
suc
h
a
surface;
it
will
b
e
dened
as
the
in
tersection
of
sev
eral
conguration
space
constrain
t
surfaces.
Eac
h
of
these
is
giv
en
b
y
an
equation
of
the
form
f
i
=
0.
T
o
nd
the
critical
p
oin
ts
of
suc
h
a
surface
w.r.t.
the
function
x

(:),
w
e
rst
dene
a
p
olynomial
g
as
follo
ws:
g
=
l
X
i=
f

i
(:)
and
then
solv
e
the
system
g
=
;
@
@
x

g
=
0



@
@
x
k
g
=
0
(:)
where
l
is
the
n
um
b
er
of
equations
whic
h
are
zero
on
S

,
the
x

;
:
:
:
;
x
k
are
co
ordinates
whic
h
are
orthogonal
to
x

,
and

is
an
innitesimal
that
is
used
to
simplify
the
computation
(see
[
]).
It
can
b
e
sho
wn
[
]
that
the
solutions
of
in
terest
can
b
e
reco
v
ered
from
the
lo
w
est
degree
co
ecien
t
in

of
the
resultan
t
of
this
system.
This
normally
in
v
olv
es

		
computing
a
sym
b
olic
determinan
t
whic
h
is
a
p
olynomial
in

[].
But
a
more
practical
approac
h
is
to
reco
v
er
only
the
lo
w
est
co
ecien
t
in

b
y
using
straigh
t
line
program
represen
tations
and
dieren
tiating
[].
T
o
en
umerate
all
the
in
teresting
critical
p
oin
ts
is
computationally
exp
ensiv
e,
since
w
e
ha
v
e
to
solv
e
O
(n
(k
 )
)
systems
of
non-linear
equations.
Th
us,
w
e
also
plan
to
exp
erimen
t
with
randomly
c
hosen
slice
v
alues
in
some
b
ounded
ranges,
alternating
with
slices
tak
en
at
true
split
or
join
p
oin
ts.
The
rationale
for
this
is
that
in
practice
the
\range"
of
slice
v
alues
o
v
er
whic
h
a
bridge
joins
t
w
o
freew
a
ys
is
t
ypically
quite
large.
There
is
a
go
o
d
probabilit
y
of
nding
a
v
alue
in
this
range
b
y
using
random
v
alues.
Occasionally
there
will
b
e
a
wide
range
of
slice
v
alues
for
a
particular
bridge,
but
man
y
irrelev
an
t
split
and
join
p
oin
ts
ma
y
b
e
en
umerated
with
v
alues
outside
this
range.
T
o
mak
e
sure
w
e
do
not
mak
e
suc
h
easy
problems
harder
than
they
should
b
e,
our
implem
en
tation
alternates
slices
tak
en
near
true
split
and
join
p
oin
ts
with
slices
tak
en
at
random
x

v
alues.
.
Dening
the
Distance
F
unction
The
idea
of
our
approac
h
is
to
construct
a
p
oten
tial
eld
whic
h
rep
els
the
p
oin
t
rob
ot
in
conguration
space
a
w
a
y
from
the
obstacles.
Giv
en
a
goal
p
osition
and
a
description
of
its
en
vironmen
t,
a
manipulator
will
mo
v
e
along
a
\maxim
um
p
oten
tial"
path
in
an
\articial
p
oten
tial
eld".
The
p
osition
to
b
e
reac
hed
represen
ts
a
critical
p
oin
t
that
will
b
e
link
ed
b
y
the
bridge
to
the
nearest
maxim
um
,
and
the
obstacles
represen
t
repulsiv
e
surfaces
for
the
manipulator
parts.
Let
C
O
denote
the
obstacles,
and
x
the
p
osition
in
R
k
.
The
articial
p
o-
ten
tial
eld
U
ar
t
(x)
induces
an
articial
repulsion
from
the
surface
of
the
obstacles.
U
ar
t
(x)
is
a
non-negativ
e
function
whose
v
alue
tends
to
zero
as
an
y
part
of
the
rob
ot
approac
hes
an
obstacle.
One
of
the
classical
analytical
p
oten
tial
elds
is
the
Euclidean
distance
function.
Using
the
shortest
distance
to
an
obstacle
O
,
w
e
ha
v
e
prop
osed
the
follo
wing
p
oten
tial
eld
U
ar
t
(x):

00
U
ar
t
(x)
=
min
ij
(D
(O
i
;
L
j
(x)))
where
D
(O
i
;
L
j
(x))
is
the
shortest
Euclidean
distance
b
et
w
een
an
obstacle
O
i
and
the
link
L
j
when
the
rob
ot
is
at
conguration
x.
D
(O
i
;
L
j
(x))
is
obtained
b
y
a
lo
cal
metho
d
for
fast
computation
of
distance
b
et
w
een
con
v
ex
p
olyhedra
in
Chapter
.
Notice
that
the
prop
osed
U
ar
t
(x)
is
not
a
con
tin
uously
dieren
tiable
function
as
in
man
y
p
oten
tial
eld
metho
ds.
U
ar
t
(x)
is
pie
c
ewise
con
tin
uous
and
dieren
tiable.
This
is
p
erfectly
all
righ
t
for
the
application
in
our
Roadmap
algorithm.
In
fact
it
will
b
e
a
lo
w
er
en
v
elop
e
of
smo
oth
functions.
This
is
all
the
b
etter
b
ecause
it
means
that
lo
cal
maxima
that
do
not
o
ccur
where
the
function
is
smo
oth
are
all
the
more
sharply
dened.
The
graph
of
the
distance
function
certainly
has
a
str
atic
ation
in
to
a
nite
n
um
b
er
of
smo
oth
pieces
[
].
Its
maxima
will
b
e
the
union
of
certain
lo
cal
maxima
of
these
smo
oth
pieces.
So
w
e
can
still
use
the
system
of
equations
dened
earlier
to
nd
them.
With
this
sc
heme,
a
manipulator
mo
v
es
in
suc
h
a
w
a
y
to
maximi
ze
the
articial
p
oten
tial
eld
U
ar
t
(x).
But
lik
e
an
y
lo
cal
metho
d,
just
follo
wing
one
curv
e
of
suc
h
maxima
is
not
guaran
teed
to
reac
h
the
goal.
Th
us,
the
need
for
bridges.
.
Algorithm
Details
The
algorithm
tak
es
as
input
a
geometric
description
of
the
rob
ot
links
and
obstacles
as
con
v
ex
p
olyhedra
or
unions
of
con
v
ex
p
olyhedra.
It
also
tak
es
the
initial
and
goal
congurations,
and
the
kinematic
description
of
the
rob
ot,
sa
y
via
Dena
vit-Harten
b
erg
parameters.
The
output
is
a
path
b
et
w
een
the
initial
and
goal
congurations
represen
ted
as
a
sequence
of
closely
spaced
p
oin
ts
(more
closely
than
the
C-space
distance
to
the
nearest
obstacle
at
that
p
oin
t),
assuming
suc
h
a
path
exists.
If
there
is
no
path,
the
algorithm
will
ev
en
tually
disco
v
er
that,
and
output
\NO
P
A
TH".
The
p
oten
tial
function
is
a
map
U
ar
t
:
C
S
!
R.
The
graph
of
the
function
is
a
surface
in
C
S

R.
Let
u
and
v
denote
t
w
o
co
ordinate
axes,
the
Roadmap

0
Algorithm
xes
v
and
then
follo
ws
the
extremal
p
oin
ts
in
direction
u
as
the
v
alue
of
v
v
aries.
But,
the
new
algorithm
diers
from
the
original
roadmap
algorithm[
]
in
the
follo
wing
resp
ects:

It
do
es
not
alw
a
ys
construct
the
en
tire
roadmap

In
the
new
algorithm,
v
=
x
i
,
where
x
i
is
one
of
the
CS
co
ordinates
while
u
=
h,
where
h
is
the
heigh
t
of
the
p
oten
tial
function.
Y
et,
in
the
original,
v
=
x
i
and
u
=
x
j
where
x
i
and
x
j
are
b
oth
CS
co
ordinates.

The
original
Roadmap
algorithm
xes
the
x
i
co
ordinate
and
follo
ws
extremal
p
oin
ts
(maxima,
minima
and
saddles)
in
x
j
,
to
generate
the
silhouette
curv
es.
On
the
other
hand,
the
new
algorithm
xes
x
i
,
and
follo
ws
only
maxima
in
h.

The
new
algorithm
is
not
recursiv
e.
Recursion
w
as
necessary
in
the
original
b
ecause
there
is
no
single
algebraic
curv
e
that
connects
an
arbitrary
p
oin
t
to
an
extrem
um
in
u.
But
the
new
algorithm
uses
n
umerical
hill-clim
bing
whic
h
has
no
suc
h
limitation.
..
F
reew
a
ys
and
Bridges
A
roadmap
has
t
w
o
ma
jor
comp
onen
ts
{
freew
a
ys
and
bridges.
They
are
generated
as
follo
wing:
F
reew
a
y
T
racing
is
done
b
y
trac
king
the
lo
cus
of
lo
cal
maxima
in
distance
within
eac
h
slice
normal
to
the
sw
eeping
direction.
Small
steps
are
made
in
the
sw
eep
direction,
and
the
lo
cal
maxima
recomputed
n
umerically
.
F
reew
a
y
tracing
con-
tin
ues
in
b
oth
directions
along
the
freew
a
y
un
til
it
terminates
in
one
of
t
w
o
w
a
ys:
(a)
The
freew
a
y
runs
in
to
an
inection
p
oin
t,
a
p
oin
t
where
the
curv
e
tangen
t
b
ecomes
orthogonal
to
the
sw
eep
direction.
It
is
alw
a
ys
p
ossible
to
con
tin
ue
past
these
p
oin
ts
b
y
adding
a
bridge.
(b)
The
freew
a
y
runs
in
to
an
obstacle.
This
is
a
normal
termination,
and
the
tracing
simply
stops
and
the
algorithm
bac
ktrac
ks.

0
Bridges
b
egin
alw
a
ys
at
inection
p
oin
ts
or
critical
p
oin
ts
and
terminate
alw
a
ys
at
freew
a
y
p
oin
ts
within
the
same
slice.
The
algorithm
simply
follo
ws
the
gradien
t
of
the
p
oten
tial
function
from
the
start
p
oin
t
within
the
slice
un
til
it
reac
hes
a
lo
cal
maxim
um
,
whic
h
m
ust
b
e
a
freew
a
y
p
oin
t.
En
umeration
of
Critical
P
oin
ts
Critical
p
oin
ts
are
calculated
as
in
Section
.
But
most
of
these
critical
p
oin
ts
will
not
b
e
in
teresting.
W
e
can
c
hec
k
lo
cally
among
all
the
critical
p
oin
ts
to
see
if
they
qualify
to
b
e
a
\split"
or
\join".
This
test
c
hec
ks
if
the
p
oin
t
has
a
neigh
b
orho
o
d
that
is
\saddle-lik
e".
It
is
based
on
the
orien
tations
of
the
CSpace
b
oundary
surface
normals
at
the
critical
p
oin
t.
Random
Slicing
Optionally
,
the
user
ma
y
wish
to
add
roadmaps
of
randomly
c
hosen
slices,
rather
than
calculating
man
y
critical
p
oin
ts
(or
rather
than
calculating
them
at
all,
but
then
of
course,
completeness
will
b
e
lost).
This
is
a
recursiv
e
pro
cedure,
and
in
v
olv
es
c
ho
osing
a
v
v
alue
at
random,
making
a
recursiv
e
call
to
the
algorithm
on
this
v
-slice.
Random
slicing
ma
y
also
b
e
used
within
the
slice
itself,
and
so
on,
whic
h
leads
to
a
depth-k
recursion
tree.
If
this
is
done,
some
searc
h
heuristics
m
ust
b
e
added
to
guide
the
c
hoice
of
where
in
the
tree
the
next
slice
(and
hence
the
next
c
hild)
should
b
e
added.
The
heuristic
also
needs
to
trade
o
random
slicing
and
critical
p
oin
t
en
umeration.
The
goal
of
the
heuristic
is
to
en
umerate
enough
random
slices
that
the
algorithm
will
ha
v
e
a
go
o
d
c
hance
of
success
on
\easy"
en
vironmen
ts
(in
tuitiv
ely
where
there
are
large
passages
b
et
w
een
c
hannels)
without
ha
ving
to
explore
to
o
man
y
critical
p
oin
ts.
Y
et
it
should
still
nd
its
w
a
y
around
a
dicult
en
vironmen
t
using
the
critical
slices
without
ha
ving
w
asted
most
of
its
time
taking
random
slices.
Giv
en
the
general
outline
of
our
algorithm,
w
e
will
no
w
giv
e
an
instan
tiation
on
-D
and
a
detailed
description
of
ho
w
it
can
b
e
applied
to
-D.

0
y
R
x = x0
P inflect
x
y
R
Portion of silhouette curve in CS x R
Slice projection at x = x0 in R-y plane
P inflect
Figure
.:
A
pictorial
example
of
an
inection
p
oin
t
in
C
S

R
vs.
its
view
in
R

y
at
the
slice
x
=
x
0
..
Tw
o-Dimensional
W
orkspace
Starting
from
the
initial
p
osition
p
init

C
S
,
w
e
rst
x
one
of
the
axes
of
C
S
and
then
tak
e
the
x
co
ordinate
of
a
slice
to
b
e
the
x
co
ordinate
of
p
init
.
Then
w
e
searc
h
this
slice
to
nd
the
nearest
lo
cal
maxim
um
.
(This
lo
cal
maxim
um
is
a
freew
a
y
p
oin
t.)
Next,
w
e
build
a
bridge
b
et
w
een
the
p
oin
t
p
init
and
this
lo
cal
maxim
um
.
A
t
the
same
time,
w
e
b
egin
tracing
a
freew
a
y
curv
e
from
the
goal.
If
the
goal
is
not
on
the
maxim
um
con
tour
of
the
p
oten
tial
eld,
then
w
e
m
ust
build
a
bridge
to
link
it
to
the
nearest
lo
cal
maxim
um
.
Afterw
ards,
w
e
trace
the
lo
cus
of
this
lo
cal
maxim
um
as
x
v
aries
un
til
w
e
reac
h
an
endp
oin
t.
If
the
curren
t
p
osition
p
loc
on
the
curv
e
is
the
goal
G,
then
w
e
can
terminate
the
pro
cedure.
Otherwise,
w
e
m
ust
v
erify
whether
p
loc
is
a
\dead-end"
or
an
inection
p
oin
t
of
the
slice
x
=
x
0
.
(See
Fig.
..)
If
p
loc
is
a
p
oin
t
of
inection,
then
w
e
can
con
tin
ue
the
curv
e
b
y
taking
a
slice
at
the
neigh
b
orho
o
d
of
the
inection
p
oin
t
and
hill-clim
bi
ng
along
the
gradien
t
direction
ne
ar
the
inection
p
oin
t.
This
searc
h
necessarily
tak
es
us
to
another
lo
cal
maxim
um
.

0
Fig.
.
demonstrates
ho
w
the
algorithm
w
orks
in
-d
C
S
.
This
diagram
is
a
pro
jection
of
a
constructed
p
oten
tial
eld
in
C
S
x
R
on
to
the
x-y
plane
of
the
-d
C
S
.
The
shaded
area
is
the
C
O
in
the
conguration
space.
The
solid
curv
es
represen
t
the
con
tour
of
maxim
um
p
oten
tial,
while
the
dashed
curv
es
represen
t
the
minim
a.
F
urthermore,
the
path
generated
b
y
our
planner
is
indicated
b
y
arro
ws.
In
addition,
the
v
ertical
lines
sym
b
olize
c
hannel
slices
through
the
in
teresting
critical
p
oin
ts
and
inection
p
oin
ts.
When
this
pro
cedure
has
b
een
tak
en
to
its
conclusion
and
b
oth
endp
oin
ts
of
the
freew
a
y
terminate
at
dead-ends,
then
at
this
p
oin
t
it
is
necessary
to
tak
e
a
slice
at
some
v
alue
of
x.
Our
planner
generates
sev
eral
random
x-v
alues
for
slices
(at
a
uniformly
spaced
distribution
along
the
span
of
the
freew
a
y),
in
terw
ea
ving
them
with
an
en
umeration
of
all
the
in
teresting
critical
p
oin
ts.
If
after
a
sp
ecied
n
um
b
er
of
random
v
alues,
our
planner
fails
to
nd
a
connecting
path
to
a
nearb
y
lo
cal
maxim
um
,
then
it
will
tak
e
a
slice
through
an
in
teresting
critical
p
oin
t.
Eac
h
slice,
b
eing
-dimensional,
itself
forms
the
bridge
curv
e
(or
a
piece
of
it
do
es).
W
e
call
this
pro
cedure
rep
eatedly
un
til
w
e
reac
h
the
goal
p
osition
G
or
ha
v
e
en
umerated
all
the
in
teresting
critical
p
oin
ts.
The
algorithm
is
describ
ed
sc
hematically
b
elo
w:

Algorithm
Pro
cedure
FindGoal
(En
vironmen
t,
p
init
,
G)
if
(p
init
=
G)
then
Explore(p
init
)
and
Explore(G)
else
return(F
oundGoal);
ev
en
:=
false;
While
(
CritPtRemain
and
NotOnSk
eleton(G)
)
do
if
(ev
en)
then
x
:=
Random
(x-range)
else
x
:=
x-co
ord(next-crit-pt());
T
ak
eSlice(x);

0
Pinit
Boundary
Boundary
y
x
G
Silhouette
(freeway)
Bridge
Inflection Point
Inflection Point
Critical Points
Critical Point
Figure
.:
An
example
of
the
algorithm
in
the
-d
w
orkspace
ev
en
:=
not
ev
en;
end(while);
End(FindGoal);
F
unction
Explore(p)
%
T
race
out
a
curv
e
from
p
q
:=
searc
h-up&do
wn(p);
%
T
o
mo
v
e
up
&
do
wn
only
in
y
,
using
gradien
t
near
p
if
new(q)
then
%
new()
c
hec
ks
if
q
is
already
on
the
curv
e
b
egin(if
)
<e,e>
:=
trace(q);
%
trace
out
the
curv
e
from
q,
output
t
w
o
end
p
oin
ts
if
inection(e)
then
Explore(e);

0
if
inection(e)
then
Explore(e);
%
inection(p)
c
hec
ks
if
p
is
an
inection
p
oin
t
end(if
);
End(Explore);
F
unction
T
ak
eSlice(x-co
ordinate(p))
%
This
function
generates
all
p
oin
ts
on
the
slice
and
explore
%
all
the
maxima
on
the
slice.
old-pt
:=
nd-pt(x-co
ordinate);
%
nd-pt()
nd
all
the
p
oin
ts
on
the
x-co
ordinate.
%
It
mo
v
es
up&do
wn
un
til
reac
hes
another
maxim
um
.
new-pt
:=
n
ull;
F
or
(eac
h
pt
in
the
old-pt)
do
<up,do
wn>
:=
searc
h-up&do
wn(pt);
%
<up,do
wn>
is
a
pair
of
p
oin
ts
of
0,,or
pts
new-pt
:=
new-pt
+
<up,do
wn>;
F
or
(eac
h
pt
in
the
new-pt)
do
Explore(pt);
End(T
ak
eSlice);
..
Three-Dimensi
onal
W
orkspace
F
or
a
three-dimensional
w
orkspace,
the
construction
is
quite
similar.
Start-
ing
from
the
initial
p
osition
p
init
and
the
goal
G,
w
e
rst
x
one
axis,
X
.
W
e
trace
from
the
start
p
oin
t
to
a
lo
cal
maxim
um
of
distance
within
the
Y
-Z
plane
con
taining
the
start
p
oin
t.
Then
w
e
follo
w
this
lo
cal
maxim
um
b
y
taking
steps
in
X
.
If
this
curv
e
terminates
in
an
inection
p
oin
t,
w
e
can
alw
a
ys
reac
h
another
maxim
um
b
y
follo
wing
the
direction
of
the
p
oten
tial
gradien
t
just
b
eyond
the
inection
p
oin
t
in
X
.
Ev
en
tually
,
though,
w
e
exp
ect
to
terminate
b
y
running
in
to
an
obstacle.

0
When
w
e
wish
to
en
umerate
a
critical
p
oin
t,
the
bridge
curv
e
is
the
same
as
the
rst
segmen
t
that
w
e
used
to
get
from
p
init
on
to
the
freew
a
y
.
That
is,
w
e
trace
from
the
critical
p
oin
t
along
the
direction
of
the
gradien
t
within
the
curren
t
Y
-Z
slice.
There
will
b
e
t
w
o
directions
out
w
ard
from
the
critical
p
oin
t
along
whic
h
the
distance
increases.
W
e
follo
w
b
oth
of
these,
whic
h
giv
es
us
a
bridge
curv
e
linking
freew
a
ys
of
t
w
o
distinct
c
hannels.
If
w
e
decide
to
use
random
slicing,
w
e
select
a
slice
F
P
j
x
normal
to
the
x-
axis
and
call
the
algorithm
of
the
last
section
on
that
slice.
W
e
require
it
to
pro
duce
a
roadmap
con
taining
an
y
freew
a
y
p
oin
ts
that
w
e
ha
v
e
found
so
far
that
lie
in
this
slice.
This
algorithm
itself
ma
y
tak
e
random
slices,
so
w
e
need
to
limit
the
total
n
um
b
er
of
random
slices
tak
en
b
efore
w
e
en
umerate
the
next
in
teresting
critical
p
oin
t
(in
-D),
so
that
random
slicing
do
es
not
dominate
the
running
time.
..
P
ath
Optimizati
on
After
the
solution
path
is
obtained,
w
e
plan
to
smo
oth
it
b
y
the
classical
principles
of
v
ariational
calculus,
i.e.
to
solv
e
a
classical
t
w
o
p
oin
ts
b
oundary
v
alue
problem.
Basically
w
e
minim
ize
the
p
oten
tial
whic
h
is
a
function
of
b
oth
distance
and
smo
othness
to
nd
a
lo
c
al
ly
optimal
(smo
oth)
path.
Let
s
b
e
the
arc
that
is
the
path
rened
from
a
sequence
of
p
oin
ts
b
et
w
een
a
and
b
in
space,
r
b
e
the
shortest
Euclidean
distance
b
et
w
een
the
p
oin
t
rob
ot
and
the
obstacle,
and

b
e
the
curv
ature
of
the
path
at
eac
h
p
oin
t.
The
cost
function
for
path
optimization
that
w
e
w
an
t
to
minim
iz
e
is:
f
(s;
r
;
)
=
Z
b
a
(
A
r

+
B


)ds
where
r
,
,
and
s
are
functions
of
a
p
oin
t
P
i
in
a
giv
en
p
oin
t
sequence,
and
A;
B
are
adjustmen
t
constan
ts.
T
aking
the
gradien
t
of
this
function
with
resp
ect
to
eac
h
p
oin
t
P
i
giv
es
us
the
direction
of
an
impro
v
ed,
lo
c
al
ly
optimal
path.
This
can
b
e
done
in
the
follo
wing
manner:
giv
en
a
sequence
of
p
oin
ts
(P

;
P

;



;
P
k
),
w
e
w
an
t
to
minimi
ze
the
cost
function

0
g
(P
i
)
=
X
i
A
r
(P
i
)

jS
i
j
+
B
(P
i
)

jS
i
j
(.)
where
S
i
and
(P
i
)
are
dened
as:
S
i
=
P
i+
 P
i 

(P
i
)
=
\P
i 
;
P
i
;
P
i+
jS
i
j
No
w,
taking
the
gradien
t
w.r.t.
P
i
,
w
e
ha
v
e
rg
(P
i
)
=
X
i
 A
r
(P
i
)

rr
(P
i
)jS
i
j
+
B
(P
i
)r(P
i
)jS
i
j
(.)
The
most
exp
ensiv
e
pro
cedure
in
computing
the
ab
o
v
e
gradien
t
is
to
com-
pute
the
distance
at
eac
h
p
oin
t.
By
using
the
incremen
tal
distance
calculation
algo-
rithm
describ
ed
in
Chapter
,
w
e
can
compute
the
distance
b
et
w
een
the
rob
ot
and
the
closest
obstacle
in
constan
t
time.
Since
w
e
ha
v
e
to
do
this
computation
for
a
sequence
of
p
oin
ts,
the
computation
time
for
eac
h
iteration
to
smo
oth
the
curv
e
traced
out
b
y
our
planner
is
linear
in
the
total
n
um
b
er
of
p
oin
ts
in
a
giv
en
sequence.
After
sev
eral
iterations
of
computing
the
gradien
t
of
the
summation
in
Eqn..,
the
solution
path
will
ev
en
tually
b
e
smo
oth
and
lo
c
al
ly
optimal.
.
Pro
of
of
Completeness
for
an
Opp
ortunistic
Global
P
ath
Planner
Careful
completeness
pro
ofs
for
the
roadmap
algorithm
are
giv
en
in
[]
and
[	].
These
pro
ofs
apply
with
v
ery
sligh
t
mo
dication
to
the
roadmap
algorithm
that
w
e
describ
e
in
this
pap
er.
The
roadmap
of
[]
is
the
set
of
extremal
p
oin
ts
in
a
certain
direction
in
free
space.
Therefore
it
h
ugs
the
b
oundary
of
free
space.
The
roadmap
describ
ed
in
this
pap
er
follo
ws
extrema
of
the
distanc
e
function,
and
therefore
sta
ys
w
ell
clear
of
obstacles
(except
at
critical
p
oin
ts).
But
in
fact
the
t
w
o
are
v
ery
similar

0	
if
w
e
think
of
the
gr
aph
of
the
distanc
e
function
in
R
n
.
This
is
a
surface
S
in
R
(n+)
and
if
w
e
follo
w
the
extrema
of
distance
on
this
surface,
the
roadmap
of
this
pap
er
is
exactly
a
roadmap
in
the
sense
of
[]
and
[	
].
The
silhouette
curv
es
of
[]
corresp
ond
to
the
freew
a
y
curv
es
of
this
pap
er,
and
the
linking
curv
es
corresp
ond
to
bridges.
Recall
the
basic
prop
ert
y
required
of
roadmaps:
Denition
A
subset
of
R
of
a
set
S
satises
the
r
o
admap
c
ondition
if
ev
ery
connected
comp
onen
t
of
S
con
tains
a
single
connected
comp
onen
t
of
R.
F
or
this
denition
to
b
e
useful,
there
is
an
additional
requiremen
t
that
an
y
p
oin
t
in
S
can
\easily"
reac
h
a
p
oin
t
on
the
roadmap.
There
is
one
minor
optimization
that
w
e
tak
e
adv
an
tage
of
in
this
pap
er.
That
is
to
trace
only
maxima
of
the
distance
function,
rather
than
b
oth
maxima
and
minim
a.
This
can
also
b
e
applied
to
the
original
roadmap.
F
or
those
readers
not
familiar
with
the
earlier
pap
ers,
w
e
giv
e
here
an
infor-
mal
sk
etc
h
of
the
completeness
pro
of.
W
e
need
some
notation
rst.
Let
S
denote
the
surface
in
R
(n+)
whic
h
is
the
graph
of
the
distance
function.
S
is
an
n-dimensional
set
and
is
semi-algebraic
if
conguration
space
is
suitably
parametrized.
This
simply
means
that
it
can
b
e
dened
as
a
b
o
olean
com
bination
of
inequalities
whic
h
are
p
olynomials
in
the
conguration
space
parameters.
One
of
the
co
ordinates
in
conguration
space
R
n
b
ecomes
the
swe
ep
dir
e
c-
tion.
Let
this
direction
b
e
x

.
Almost
an
y
direction
in
C
S
will
w
ork,
and
heuristics
can
b
e
used
to
pic
k
a
direction
whic
h
should
b
e
go
o
d
for
a
particular
application.
When
w
e
tak
e
slices
of
the
distance
surface
S
,
they
are
tak
en
normal
to
the
x

co-
ordinate,
so
S
j
a
means
S
\
(x

=
a).
Also,
for
a
p
oin
t
p
in
R
(n+)
,
x

(p)
is
the
x

-co
ordinate
of
p.
The
other
co
ordinate
w
e
are
in
terested
in
is
the
distance
itself,
whic
h
w
e
think
of
as
the
heigh
t
of
the
distance
surface.
So
for
a
p
oin
t
p
in
R
(n+)
,
h(p)
is
the
v
alue
of
the
distance
at
this
conguration.

0
F
or
this
pap
er,
w
e
use
a
sligh
tly
dieren
t
denition
of
silhouettes,
taking
only
lo
cal
maxima
in
to
accoun
t.
W
e
will
assume
henceforth
that
the
conguration
space
is
b
ounded
in
ev
ery
co
ordinate.
This
is
certainly
alw
a
ys
the
case
for
an
y
practical
rob
ot
w
orking
in
a
conned
en
vironmen
t,
suc
h
as
industrial
rob
ot
manipulators,
mobile
rob
ots,
etc.
If
it
is
not
b
ounded,
there
are
tec
hnical
w
a
ys
to
reduce
to
a
b
ounded
problem,
see
for
example
[
].
The
set
of
free
congurations
is
also
assumed
to
b
e
closed.
The
closed
and
b
ounded
assumptions
ensure
that
the
distance
function
will
attain
lo
cally
maximal
v
alues
on
ev
ery
connected
comp
onen
t
of
free
space.
A
silhouette
p
oint
is
a
lo
cally
maximal
p
oin
t
of
the
function
h(:)
on
some
slice
S
j
a
of
S
.
The
silhouette
(S
)
of
S
is
the
set
of
all
suc
h
p
oin
ts
for
all
a.
The
k
ey
prop
erties
of
the
silhouette
are
([],
[	]):
(i)
Within
eac
h
slice
of
S
,
eac
h
connected
comp
onen
t
of
S
j
a
m
ust
con
tain
at
least
one
silhouette
p
oin
t.
(ii)
The
silhouette
should
b
e
one-dimensional.
(iii)
The
critical
p
oin
ts
of
the
silhouette
w.r.t
the
function
x

(:)
should
include
the
critical
p
oin
ts
of
the
set
S
.
Clearly
,
using
lo
cal
maxima
will
satisfy
prop
ert
y
(i).
This
is
true
simply
b
ecause
a
con
tin
uous
function
(in
this
case,
a
distance
function
with
the
v
alue
zero
on
the
b
oundary
and
p
ositiv
e
v
alues
in
the
in
terior)
has
a
lo
cal
maxim
um
in
a
compact
set.
F
or
prop
ert
y
(ii)
w
e
require
that
the
directions
x

and
h
b
e
\generic"
(see
the
earlier
pap
ers).
This
is
easily
done
b
y
pic
king
a
general
x

,
but
h
ma
y
not
b
e
generic
a
priori.
Ho
w
ev
er,
rather
than
the
true
distance
h,
w
e
assume
that
the
distance
plus
a
v
ery
small
linear
com
bination
of
the
other
co
ordinates
is
used.
This
linear
com
bination
can
b
e
arbitrarily
small,
and
w
e
assume
that
it
is
small
enough
that
it
do
es
not
signican
tly
aect
the
clearance
of
silhouette
p
oin
ts.
F
or
prop
ert
y
(iii),
w
e
depart
somewhat
from
the
original
denition.
The
critical
p
oin
ts
of
the
silhouette
curv
es
that
w
e
ha
v
e
traced
can
b
e
disco
v
ered
during
the
tracing
pro
cess
(they
are
the
p
oin
ts
where
the
curv
e
tangen
t
b
ecomes
orthogo-
nal
to
x

).
But
w
e
need
to
nd
all
(or
a
sucien
t
set
of
)
critical
p
oin
ts
to
ensure


completeness.
All
critical
p
oin
ts
do
indeed
lie
on
silhouette
curv
es,
but
since
our
algorithm
is
incremen
tal,
w
e
ma
y
not
disco
v
er
these
other
curv
es
unless
w
e
encoun
ter
p
oin
ts
on
them.
So
w
e
need
a
systematic
w
a
y
to
en
umerate
the
critical
p
oin
ts
of
S
,
since
these
will
serv
e
as
starting
p
oin
ts
for
tracing
the
silhouette
curv
es
that
w
e
need
for
completeness.
In
fact,
not
all
critical
p
oin
ts
of
S
are
required.
There
is
a
subset
of
them
called
inter
esting
critic
al
p
oints
that
are
sucien
t
for
our
purp
ose.
In
tuitiv
ely
,
the
in
teresting
critical
p
oin
ts
are
the
split
or
join
p
oin
ts
in
higher
dimensions.
They
can
b
e
dened
as
follo
ws:
Denition
A
p
oin
t
p
in
R
k
+
is
an
inter
esting
critic
al
p
oint
if
for
ev
ery
neigh
b
orho
o
d
U
of
p,
one
of
the
follo
wing
holds:
(i)
The
in
tersection
U
\
x
 

(x

(p)
+
)
consists
of
sev
eral
connected
comp
onen
ts
for
all
sucien
tly
small
.
This
is
a
generalized
split
p
oin
t.
(ii)
The
in
tersection
U
\
x
 

(x

(p)
 )
consists
of
sev
eral
comp
onen
ts
for
all
su-
cien
tly
small
.
This
is
a
generalized
join
p
oin
t.
F
rom
the
denition
ab
o
v
e,
it
follo
ws
that
as
w
e
sw
eep
the
plane
x

=
a
through
S
,
the
n
um
b
er
of
connected
comp
onen
ts
of
S
j
a
c
hanges
only
when
the
plane
passes
though
in
teresting
critical
p
oin
ts.
Denition
No
w
w
e
can
dene
the
roadmap
of
the
surface
S
.
The
roadmap
R(S
)
is
dened
as
follo
ws:
Let
P
C
(S
)
b
e
the
set
of
in
teresting
critical
p
oin
ts
of
x

(:)
on
S
,
P
C
()
b
e
the
set
of
critical
p
oin
ts
of
x

(:)
on
the
silhouette,
and
P
C
the
union
of
these
t
w
o.
The
roadmap
is
then:
R(S
)
=
(S
)
[
(
[
pP
c
L(p))
(:)
That
is,
the
roadmap
of
S
is
the
union
of
the
silhouette
(S
)
and
v
arious
linking
curv
es
L(p).
The
linking
curv
es
join
critical
p
oin
ts
of
S
or

to
other
silhouette
p
oin
ts.


The
new
roadmap
algorithm
has
an
adv
an
tage
o
v
er
the
original
in
that
it
is
not
restricted
to
algebraic
curv
e
segmen
ts.
This
is
b
ecause
the
original
w
as
form
ulated
to
giv
e
precise
algorithmic
b
ounds
on
the
planning
problem,
whereas
the
new
algorithm
appro
ximates
the
silhouette
b
y
tracing.
T
racing
is
just
as
easy
for
man
y
t
yp
es
of
non-algebraic
curv
es
as
for
algebraic
ones.
This
allo
ws
us
to
do
linking
in
a
single
step,
whereas
algebraic
linking
curv
es
m
ust
b
e
dened
recursiv
ely
.
W
e
generate
linking
curv
es
in
the
presen
t
con
text
b
y
simply
xing
the
x

co
ordinate
and
hill-clim
bing
to
a
lo
cal
maxim
um
in
h(:).
The
curv
e
traced
out
b
y
the
hill-clim
bi
ng
pro
cedure
starts
at
the
critical
p
oin
t
and
ends
at
a
lo
cal
maxim
um
(whic
h
will
b
e
a
silhouette
p
oin
t)
of
the
distance
within
the
same
x

slice.
Th
us
it
forms
a
linking
curv
e
to
the
silhouette.
If
w
e
are
at
an
in
teresting
critical
p
oin
t,
there
will
b
e
t
w
o
opp
osing
directions
(b
oth
normal
to
x

)
along
whic
h
the
distance
function
increases.
T
racing
in
b
oth
directions
links
the
critical
p
oin
t
to
silhouette
p
oin
ts
on
b
oth
c
hannels
that
meet
at
that
critical
p
oin
t.
Theorem
R(S
)
satises
the
roadmap
condition.
Pro
of
Let
a

;
:
:
:
;
a
m
b
e
the
x

-co
ordinates
of
the
critical
p
oin
ts
P
C
,
and
assume
the
a
i
's
are
arranged
in
ascending
order.
The
pro
of
is
b
y
induction
on
the
a
i
's.
Our
inductiv
e
h
yp
othesis
is
that
the
roadmap
condition
holds
to
the
\left"
of
a
i 
.
That
is,
w
e
assume
that
R(S
)j
a
i 
=
R(S
)
\
x
 l

(x


a
i 
)
satises
the
roadmap
condition
as
a
subset
of
S
j
a
i 
.
The
base
case
is
x

=
a

.
If
w
e
ha
v
e
c
hosen
a
general
direction
x

,
the
set
S
j
a

consists
of
a
single
p
oin
t
whic
h
will
also
b
e
part
of
the
roadmap.
F
or
the
inductiv
e
step
w
e
start
with
some
basic
results
from
Chapter

in
[],
whic
h
state
that
w
e
can
smo
othly
deform
or
retract
a
manifold
(or
union
of
manifolds
lik
e
the
surface
S
)
in
the
absence
of
critical
p
oin
ts.
In
this
case,
it
implies
that
the
set
S
j
<a
i
can
b
e
smo
othly
retracted
on
to
S
j
a
i 
,
b
ecause
the
in
terv
al
(a
i 
;
a
i
)
is
free
of
critical
v
alues.
There
is
also
a
retraction
whic
h
retracts
R(S
)j
<a
i
on
to
R(S
)j
a
i 
.
These
retractions
imply
that
there
are
no
top
ological
c
hanges
in
R(S
)
or
S
in
the
in
terv
al
(a
i 
;
a
i
),
and
if
R(S
)j
a
i 
satises
the
roadmap
condition,
then
so
do
es
R(S
)j
<a
i
.


So
all
that
remains
is
the
transition
from
R(S
)j
<a
i
to
R(S
)j
a
i
.
Let
p
i
b
e
the
critical
p
oin
t
whose
x

co
ordinate
is
a
i
.
The
roadmap
condition
holds
for
R(S
)j
<a
i
,
i.e.
eac
h
comp
onen
t
of
S
j
<a
i
con
tains
a
single
comp
onen
t
of
R(S
)j
<a
i
.
The
only
w
a
y
for
the
condition
to
fail
as
x

increases
to
a
i
is
if
the
n
um
b
er
of
silhouette
curv
e
comp
onen
ts
increases,
i.e.
when
p
i
is
a
critical
p
oin
t
of
the
silhouette,
or
if
the
n
um
b
er
of
connected
comp
onen
ts
of
S
decreases,
whic
h
happ
ens
when
p
i
is
a
join
p
oin
t.
Let
us
consider
these
cases
in
turn:
If
p
i
is
a
critical
p
oin
t
of
the
silhouette,
the
tangen
t
to
the
silhouette
at
p
i
is
normal
to
x

.
By
assumption,
a
new
comp
onen
t
of
the
silhouette
app
eared
at
p
i
as
x

increased
to
a
i
.
This
means
that
in
the
slice
x

=
a
i
 
(for

small
enough)
there
is
no
lo
cal
maxim
um
in
the
neigh
b
orho
o
d
of
p
i
.
On
the
other
hand,
there
m
ust
b
e
a
lo
cal
maxim
um
of
distance
in
this
slice,
whic
h
w
e
can
nd
b
y
hill-clim
bing.
So
to
link
suc
h
a
critical
p
oin
t,
w
e
mo
v
e
b
y

in
the
 x

direction
(or
its
pro
jection
on
S
so
that
w
e
remain
on
the
surface)
to
a
nearb
y
p
oin
t
q
i
.
Then
w
e
hill
clim
b
from
q
i
in
the
slice
x

=
a
i
 
un
til
w
e
reac
h
a
lo
cal
maxim
um
,
whic
h
will
b
e
a
silhouette
p
oin
t.
This
pair
of
curv
es
links
p
i
to
the
existing
roadmap,
and
so
our
inductiv
e
h
yp
othesis
is
pro
v
ed
for
R(S
)j
a
i
.
A
t
join
p
oin
ts,
though,
the
linking
curv
e
will
join
p
i
to
a
silhouette
p
oin
t
in
eac
h
of
the
t
w
o
c
hannels
whic
h
meet
at
p
i
.
If
these
t
w
o
c
hannels
are
in
fact
separate
connected
comp
onen
ts
of
S
j
<a
i
,
the
linking
curv
e
will
join
their
resp
ectiv
e
roadmaps.
Those
roadmaps
are
b
y
h
yp
othesis
connected
within
eac
h
connected
comp
onen
t
of
S
j
<a
i
.
Th
us
the
union
of
these
roadmaps
and
the
linking
curv
e
is
a
single
connected
curv
e
within
the
connected
comp
onen
t
of
S
j
a
i
whic
h
con
tains
p
i
.
Th
us
w
e
ha
v
e
pro
v
ed
the
inductiv
e
h
yp
othesis
for
a
i
if
p
i
is
a
join
p
oin
t.
W
e
ha
v
e
pro
v
ed
that
R(S
)
satises
the
roadmap
condition.
And
it
is
easy
to
link
arbitrary
p
oin
ts
in
free-space
with
the
roadmap.
T
o
do
this
w
e
simply
x
x

and
hill-clim
b
from
the
giv
en
p
oin
t
using
the
distance
function.
Th
us
our
algorithm
is
complete
for
nding
collision-free
paths.
Note
that
w
e
do
not
need
to
construct
conguration
space
explicitly
to
compute
the
roadmap.
Instead
it
suces
to
b
e
able
to
compute
the
in
teresting
critical


p
oin
ts,
and
to
b
e
able
to
compute
the
distance
function
and
its
gradien
t.
This
should
not
surprise
the
reader
familiar
with
dieren
tial
top
ology
.
Morse
theory
has
already
sho
wn
us
that
the
top
ology
of
manifolds
can
b
e
completely
c
haracterized
b
y
lo
oking
lo
cally
at
critical
p
oin
ts.
.
Complexit
y
Bound
Since
our
planner
probably
do
es
not
need
to
explore
all
the
critical
p
oin
ts,
this
b
ound
can
b
e
reduced
b
y
nding
only
those
inter
esting
critical
p
oin
ts
where
adding
a
bridge
helps
to
reac
h
the
goal.
If
n
is
the
n
um
b
er
of
obstacle
features
(faces,
edges,
v
ertices)
in
the
en
vironmen
t
and
the
conguration
space
is
R
k
,
then
the
n
um
b
er
of
\in
teresting
critical
p
oin
ts"
is
at
most
O
((d)
k
n
(k
 )
).
As
men
tioned
earlier,
the
algorithm
is
no
longer
recursiv
e
in
calculating
the
critical
p
oin
ts
and
linking
curv
es
(bridges)
as
in
[],
the
complexit
y
b
ound
calculated
in
[
]
do
es
not
apply
here.
.
Geometric
Relations
b
et
w
een
Critical
P
oin
ts
and
Con
tact
Constrain
ts
Let
n
b
e
the
n
um
b
er
of
obstacle
features
in
the
en
vironmen
t
and
the
rob
ot
has
constan
t
complexit
y
.
F
ree
space
F
P
is
b
ordered
b
y
O
(n)
constrain
t
surfaces.
Eac
h
constrain
t
surface
corresp
onds
to
an
elemen
tary
con
tact,
either
face-v
ertex
or
edge-edge,
b
et
w
een
a
feature
of
the
rob
ot
and
a
feature
of
the
en
vironmen
t.
Other
t
yp
es
of
con
tacts
are
called
non-elemen
tary
,
and
can
b
e
view
ed
as
m
ultiple
elemen
tary
con
tacts
at
the
same
p
oin
t,
e.g.
v
ertex-edge.
They
corresp
ond
to
in
tersections
of
constrain
t
surfaces
in
conguration
space.
Denition
An
elementary
c
ontact
is
a
lo
cal
con
tact
dened
b
y
a
single
equation.
It
corresp
onds
to
a
constrain
t
surface
in
conguration
space.
F
or
example,
face-v
ertex
or
edge-edge.


Denition
A
non-elementary
c
ontact
is
a
lo
cal
con
tact
dened
b
y
t
w
o
or
more
equa-
tions.
It
corresp
onds
to
an
in
tersection
or
conjunction
of
t
w
o
or
more
constrain
t
surfaces
in
conguration
space.
F
or
example,
v
ertex-edge
or
v
ertex-v
ertex.
There
are
O
(n)
of
non-elemen
tary
con
tacts
if
the
rob
ot
has
constan
t
complexit
y
.
W
e
can
represen
t
C
O
in
disjunctiv
e
form:
C
O
=
(
_
e
i

edg
es(obstacl
es)
f
j

f
aces(r
obot)
O
e
i
;f
j
)
_
(
_
e
j

edg
es(r
obot)
f
i

f
aces(obstacl
es)
O
e
j
;f
i
)
where
O
e
i
;f
j
is
an
o
v
erlap
predicate
for
p
ossible
con
tact
of
an
edge
and
a
face.
See
[]
for
the
denition
of
O
e
i
;f
j
.
F
or
a
xed
rob
ot
complexit
y
,
the
n
um
b
er
of
branc
hes
for
the
disjunctiv
e
tree
gro
ws
linearly
w.r.t.
the
en
vironmen
t
complexit
y
.
Eac
h
O
e
i
;f
j
has
constan
t
size,
if
the
p
olyhedron
is
prepro
cessed
(describ
ed
in
Chapter
).
Eac
h
clause,
O
e
i
;f
j
,
is
a
conjunction
of
inequalities.
This
disjunctiv
e
tree
structure
is
useful
for
computing
the
maxim
um
n
um
b
er
of
critical
p
oin
ts
b
y
com
binatorics.
The
in
teresting
critical
p
oin
ts
(whic
h
corresp
ond
to
the
non-elemen
tary
con
tacts)
o
ccur
when
t
w
o
or
more
constrain
t
surfaces
lie
under
one
clause.
Using
the
disjunctiv
e
tree
structure,
w
e
can
calculate
the
upp
er
b
ound
for
the
maxim
um
n
um
b
er
of
critical
p
oin
ts
b
y
com
binatorial
means
(b
y
coun
ting
the
n
um
b
er
of
systems
of
equations
w
e
m
ust
solv
e
to
nd
all
the
critical
p
oin
ts).
Generically
,
at
most
k
surfaces
in
tersect
in
k
dimensions.
F
or
a
rob
ot
with
k
degrees
of
freedom
and
an
en
vironmen
t
of
complexit
y
n,
(i.e.
n
is
the
n
um
b
er
of
feature
constrain
ts
b
et
w
een
rob
ot
and
obstacles)
the
n
um
b
er
of
critical
p
oin
ts
is
(d)
k
0
@
n
+
k
k

A
=
O
((d)
k
n
k
)
where
d
is
the
maxim
um
degree
of
constrain
t
p
olynomial
equations.
This
is
an
upp
er
b
ound
on
the
n
um
b
er
of
critical
p
oin
ts
from
[]
and
[].
Therefore,
for
a
giv
en
rob
ot
(with
xed
complexit
y),
there
are
at
most
O
((d)
k
n
k
)
critical
p
oin
ts
in
terms


of
n,
where
k
is
the
dimension
of
conguration
space
and
n
is
the
n
um
b
er
of
obstacle
features.
(NOTE:
W
e
only
use
the
ab
o
v
e
argumen
t
to
pro
v
e
the
upp
er
b
ound,
not
to
calculate
critical
p
oin
ts
in
this
fashion.)
These
O
((d)
k
n
k
)
in
tersection
p
oin
ts
fall
in
to
t
w
o
categories:
(a)
All
the
con
tacts
are
elemen
tary;
(b)
one
or
more
con
tacts
are
non-elemen
tary
.
When
all
con
tacts
are
elemen
tary
,
i.e.
all
con
tact
p
oin
ts
are
distinct
on
the
ob
ject,
free
space
in
a
neigh
b
orho
o
d
of
the
in
tersection
p
oin
t
is
homeomorphic
to
the
in
tersection
of
k
half-
spaces
(one
side
of
a
constrain
t
surface),
and
forms
a
cone.
This
t
yp
e
of
in
tersection
p
oin
t
cannot
b
e
a
split
or
join
p
oin
t,
and
do
es
not
require
a
bridge.
Ho
w
ev
er
if
one
or
more
con
tacts
are
non-elemen
tary
,
then
the
in
tersection
p
oin
t
is
a
p
oten
tial
split
or
join
p
oin
t.
But
b
ecause
the
O
(n)
non-elemen
tary
con
tact
surfaces
ha
v
e
co
dimension

,
there
are
only
O
(n
(k
 )
)
systems
of
equations
that
dene
critical
p
oin
ts
of
t
yp
e
(b),
and
therefore
at
most
O
((d)
k
n
k
 
)
p
ossible
p
oin
ts.
In
teresting
critical
p
oin
ts
ma
y
b
e
either
in
tersection
p
oin
ts,
and
w
e
ha
v
e
seen
that
there
are
O
((d)
k
n
(k
 )
)
candidates;
or
they
ma
y
lie
on
higher
dimensional
in
tersection
surfaces,
but
these
are
certainly
dened
b
y
few
er
than
k
equations,
and
the
n
um
b
er
of
p
ossible
critical
p
oin
ts
is
not
more
than
O
((d)
k
n
(k
 )
)
[],
[].
Therefore,
the
n
um
b
er
of
in
teresting
critical
p
oin
ts
is
at
most
O
((d)
k
n
(k
 )
).
.
Brief
Discussion
By
follo
wing
the
maxima
of
a
w
ell-designed
p
oten
tial
eld,
and
taking
slice
pro
jections
through
critical
p
oin
ts
and
at
random
v
alues,
our
approac
h
builds
in-
cremen
tally
an
obstacle-a
v
oiding
path
to
guide
a
rob
ot
to
w
ard
the
desired
goal,
b
y
using
the
distance
computation
algorithm
describ
ed
in
Chapter
.
The
tec
hniques
prop
osed
in
this
c
hapter
pro
vide
the
planner
with
a
systematic
w
a
y
to
escap
e
from
these
lo
cal
maxima
that
ha
v
e
b
een
a
long
standing
problem
with
using
the
p
oten
tial
eld
approac
h
in
rob
ot
motion
planning.
This
path
planning
algorithm,
computed
from
lo
cal
information
ab
out
the
geometry
of
conguration
space
b
y
using
the
incremen
tal
distance
computation
tec
h-
niques,
requires
no
exp
ensiv
e
precomputation
steps
as
in
most
global
metho
ds
dev
el-


op
ed
th
us
far.
In
a
t
w
o
dimensional
space,
this
metho
d
is
comparable
with
using
a
V
oronoi
Diagram
for
path
planning.
In
three-dimensional
space,
ho
w
ev
er,
our
metho
d
is
more
ecien
t
than
computing
h
yp
erb
olic
surfaces
for
the
V
oronoi
diagram
metho
d.
In
the
w
orst
case,
it
should
run
at
least
as
fast
as
the
original
roadmap
algorithm.
But,
it
should
run
faster
in
almost
all
practical
cases.


Chapter

Conclusions
.
Summary
A
new
algorithm
for
computing
the
Euclidean
distance
b
et
w
een
t
w
o
p
oly-
hedra
has
b
een
presen
ted
in
Chapter
.
It
utilizes
the
con
v
exit
y
of
p
olyhedra
to
establish
three
imp
ortan
t
applicabilit
y
criteria
for
trac
king
the
closest
feature
pair.
With
sub
division
tec
hniques
to
reduce
the
size
of
cob
oundaries/b
oundaries
when
ap-
propriate,
its
exp
ected
run
time
is
c
onstant
time
in
up
dating
the
closest
feature
pair.
If
the
previous
closest
features
ha
v
e
not
b
een
pro
vided,
it
is
t
ypically
sublinear
in
the
total
n
um
b
er
of
v
ertices,
but
linear
for
cylindrical
ob
jects.
Besides
its
eciency
and
simplicit
y
,
it
is
also
complete
|
it
is
guaran
teed
to
nd
the
closest
feature
pair
if
the
ob
jects
are
separated;
it
giv
es
an
error
message
to
indicate
collision
(when
the
distance

,
the
user
dened
safet
y
tolerance)
and
returns
the
con
tacting
feature
pair
if
they
are
just
touc
hing
or
in
tersecting.
The
metho
dology
describ
ed
can
b
e
emplo
y
ed
in
distance
calculations,
col-
lision
detection,
motion
planning,
and
other
rob
otics
problems.
In
Chapter
,
this
algorithm
is
extended
for
dynamic
collision
detection
b
et
w
een
noncon
v
ex
ob
jects
b
y
using
subpart
hierarc
hical
tree
represen
tation.
In
Chapter
,
w
e
also
presen
ted
an
extension
of
the
exp
ected
constan
t
time
distance
computation
algorithm
to
con
tact
determination
b
et
w
een
con
v
ex
ob
jects
with
curv
ed
surfaces
and
b
oundary
.
Since
the
distance
computation
algorithm
describ
ed
in
Chapter

runs
in
exp
ected
constan
t

	
time
once
initialized,
the
algorithm
is
extremely
useful
in
reducing
the
error
b
y
in-
creasing
the
resolution
of
p
olytop
e
appro
ximations
for
con
v
ex
ob
jects
with
smo
oth
curv
ed
surfaces.
Rening
the
appro
ximation
to
reduce
error
will
no
longer
ha
v
e
a
detrimen
tal
side
eect
in
running
time.
In
Chapter
,
w
e
prop
osed
tec
hniques
to
reduce
0
@
N


A
pairwise
in
tersec-
tion
tests
for
a
large
en
vironmen
t
of
n
mo
ving
ob
jects.
One
of
them
is
to
use
the
priorit
y
queue
(implem
en
te
d
as
a
heap)
sorted
b
y
the
lo
w
er
b
ound
on
time
to
collsion;
the
other
is
to
use
the
sw
eeping
and
sorting
tec
hniques
and
geometric
data
structures
along
with
hierarc
hical
b
ounding
b
o
xes
to
eliminate
the
ob
jects
pairs
whic
h
are
def-
initely
not
in
the
vicinit
y
of
eac
h
other.
These
algorithms
w
ork
w
ell
in
practice
and
help
to
ac
hiev
e
almost
real
time
p
erformance
for
most
en
vironmen
ts.
One
of
our
applications
is
path
planning
in
the
presence
of
obstacles
de-
scrib
ed
in
Chapter
.
That
algorithm
traces
out
the
sk
eleton
curv
es
whic
h
are
lo
ci
of
maxima
of
a
distance
function.
This
is
done
b
y
rst
nding
the
pairs
of
closest
features
b
et
w
een
the
rob
ot
and
the
obstacles,
and
then
k
eeping
trac
k
of
these
clos-
est
pairs
incremen
tall
y
b
y
calls
to
our
incremen
tal
distance
computation
algorithm.
The
curv
es
traced
out
b
y
this
algorithm
are
in
fact
maximall
y
clear
of
the
obsta-
cles.
It
is
v
ery
computationally
economical
and
ecien
t
to
use
our
exp
ected
constan
t
time
distance
calculation
for
the
purp
ose
of
computing
the
gradien
t
of
the
distance
function.
.
F
uture
W
ork
The
c
hapters
in
this
thesis
address
w
ork
whic
h
has
b
een
studied
in
rob
otics,
computational
geometry
and
computer
graphics
for
sev
eral
y
ears.
The
treatmen
t
of
these
topics
w
as
far
from
exhaustiv
e.
There
is
no
shortage
of
op
en
problems
a
w
aiting
for
new
ideas
and
inno
v
ativ
e
solutions.

0
..
Ov
erlap
Detection
for
Con
v
ex
P
olyhedra
The
core
of
the
collision
detection
algorithm
is
built
up
on
the
concepts
of
V
oronoi
regions
for
con
v
ex
p
olyhedra.
As
men
tioned
earlier
in
Chapter
,
the
V
oronoi
regions
form
a
partition
of
space
outside
the
p
olyhedron.
But
the
algorithm
can
p
ossibly
run
in
to
a
cyclic
lo
op
when
in
terp
enetration
o
ccurs,
if
no
sp
ecial
care
is
tak
en
to
prohibit
suc
h
ev
en
ts.
Hence,
if
the
p
olyhedra
can
o
v
erlap,
it
is
imp
ortan
t
that
w
e
add
a
mo
dule
whic
h
detects
in
terp
enetration
when
it
o
ccurs
as
w
ell.

Pseudo
V
oronoi
Regions:
This
small
mo
dule
can
b
e
constructed
based
up
on
similar
ideas
of
space
partitioning
to
the
interior
space
of
the
con
v
ex
p
olyhedra.
The
partitioning
do
es
not
ha
v
e
to
form
the
exact
V
oronoi
regions
since
w
e
are
not
in
terested
in
kno
wing
the
closest
features
b
et
w
een
t
w
o
in
terp
enetrating
p
olyhedra
but
only
to
detect
suc
h
a
case.
A
close
appro
ximation
with
simple
calculation
can
pro
vide
the
necessary
to
ols
for
detecting
o
v
erlapping.
This
is
done
b
y
barycen
tric
partition
of
the
in
terior
of
a
p
olyhedron.
W
e
rst
calculate
the
cen
troid
of
eac
h
con
v
ex
p
olyhedron,
whic
h
is
the
w
eigh
ted
a
v
erage,
and
then
construct
the
constrain
t
planes
of
eac
h
face
to
the
cen
troid
of
the
p
olyhedron.
These
in
terior
constrain
t
planes
of
a
face
F
are
the
h
yp
erplanes
passing
through
the
cen
troid
and
eac
h
edge
in
F
's
b
oundary
and
the
h
yp
erplane
con
taining
the
face
F
.
If
all
the
faces
are
equi-distan
t
from
the
cen
troid,
these
h
yp
erplanes
form
the
exact
V
oronoi
diagrams
for
the
in
terior
of
the
p
olyhedron.
Otherwise,
they
will
pro
vide
a
reasonable
space
partition
for
the
purp
ose
of
detecting
in
terp
enetration.
The
data
structure
of
these
in
terior
pseudo
V
oronoi
regions
is
v
ery
m
uc
h
lik
e
the
exterior
V
oronoi
regions
describ
ed
in
Chapter
.
Eac
h
region
asso
ciated
with
eac
h
face
has
e
+

h
yp
erplanes
dening
it,
where
e
is
the
n
um
b
er
of
edges
in
the
face's
b
oundary
.
Eac
h
h
yp
erplane
has
a
p
oin
ter
directing
to
a
neigh
b
oring
region
where
the
algorithm
will
step
to
next,
if
the
constrain
t
imp
osed
b
y
this
h
yp
erplane
is
violated.
In
addition,
a
typ
e
eld
is
added
in
the
data
structure
of
a
V
oronoi
cell
to
indicate
whether
it
is
an
in
terior
or
exterior
V
oronoi
region.


The
exact
V
oronoi
regions
for
the
in
terior
space
of
the
p
olyhedron
can
also
b
e
constructed
b
y
computing
all
the
equi-distan
t
bisectors
of
all
facets.
But,
suc
h
an
elab
orate
precomputation
is
not
necessary
unless
w
e
are
also
in
terested
in
computing
the
degree
of
in
terp
enetration
for
constructing
some
t
yp
e
of
p
enalt
y
functions
in
collision
resp
onse
or
motion
planning.
As
t
w
o
con
v
ex
p
olyhedral
ob
jects
mo
v
e
and
pass
through
eac
h
other,
the
c
hange
of
feature
pairs
also
indicate
suc
h
a
motion
since
the
p
oin
ters
asso
ciated
with
eac
h
constrain
t
plane
k
eep
trac
k
of
the
pseudo
closest
features
b
et
w
een
t
w
o
ob
jects
during
p
enetration
phase
as
w
ell.

Other
Applications
In
addition,
b
y
app
ending
this
small
mo
dule
to
the
exp
ected
constan
t
time
algorithm
describ
ed
in
Chapter
,
w
e
can
sp
eed
up
the
run
time
whenev
er
one
can-
didate
feature
lies
b
eneath
another
candidate
feature
(this
scenario
corresp
onds
to
lo
cal
minima
of
distance
function).
W
e
no
longer
need
the
linear
searc
h
to
en
umerate
all
features
on
one
p
olyhedron
to
nd
the
closest
feature
on
one
p
olyhedron
to
the
other.
By
tra
v
eling
through
the
in
terior
space
of
t
w
o
con
v
ex
ob
jects,
w
e
can
step
out
of
the
lo
cal
minim
a
at
the
faster
pace.
This
can
b
e
simply
done
b
y
replacing
the
linear
time
searc
h
b
y
the
o
v
erlap
detection
mo
dule
describ
ed
here,
whenev
er
a
feature
lies
b
eneath
another
face.
Ho
w
ev
er,
to
ensure
con
v
ergence,
w
e
will
need
to
construct
the
exact
V
oronoi
regions
of
the
in
terior
space
or
use
sp
ecial
cases
analysis
to
guaran
tee
that
eac
h
switc
h
of
feature
necessarily
decreases
the
distance
b
et
w
een
t
w
o
ob
jects.
..
In
tersection
T
est
for
Conca
v
e
Ob
jects

New
Approac
hes
for
Collision
Detection
b
et
w
een
Non-con
v
ex
Ob
jects
Curren
tly
,
w
e
are
also
in
v
estigating
other
p
ossibilities
of
solving
the
in
tersec-
tion
problem
for
non-con
v
ex
ob
jects.
Though
sub-part
hierarc
hical
tree
represen
tation
is
an
in
tuitiv
e
and
natural
approac
h,
w
e
ha
v
e
run
in
to
the
problem
of
extending
this


approac
h
for
an
y
general
input
of
mo
dels.
This
is
due
to
the
fact
that
there
is
no
optimal
con
v
ex
decomp
osition
algorithm,
but
near-optimal
algorithm
[
].
A
simple
con
v
ex
decomp
osition
do
es
not
necessarily
giv
e
us
the
decomp
osition
c
haracterizing
the
geometry
structure
of
the
ob
ject.
Th
us,
it
is
hard
to
exploit
the
strength
of
this
metho
dology
.
Another
solution
is
to
use
the
concept
of
\destructiv
e
solid
geometry",
that
is
to
represen
t
eac
h
non-con
v
ex
ob
ject
b
y
b
o
olean
op
erations
of
C
=
A
 X
i
B
i
where
A
and
B
i
's
are
con
v
ex
and
C
is
the
non-con
v
ex
ob
ject.
By
examining
the
o
v
erlap
b
et
w
een
A

of
the
ob
ject
C

and
B

i
of
the
ob
ject
C

(where
B

i
represen
ts
one
of
the
notc
hes
or
conca
vities
of
C

),
w
e
ha
v
e
the
relev
an
t
information
for
the
actual
con
tact
lo
cation
within
the
conca
vities.
Again,
w
e
only
ha
v
e
to
k
eep
trac
k
of
the
lo
cal
closest
feature
pairs
within
the
conca
vities
of
our
in
terests,
once
the
con
v
ex
h
ulls
of
t
w
o
non-con
v
ex
ob
jects
in
tersect.
W
e
plan
to
use
the
fact
that
certain
ob
ject
t
yp
es,
esp
ecially
cylinders,
ha
v
e
a
b
ounded
n
um
b
er
of
closest
feature
pairs.
In
addition,
w
e
can
p
ossibly
com
bine
the
priorit
y
queue
and
sw
eeping
and
sorting
tec
hniques
describ
ed
in
Chapter

with
the
basic
algorithm
for
noncon
v
ex
ob
jects
to
further
reduce
the
n
um
b
er
of
in
tersection
tests
needed
inside
of
the
con-
ca
vities.

Automated
Generation
of
the
Sub-P
art
Hierarc
hical
Represen
tation
T
o
supp
ort
the
sim
ulation,
geometric
mo
deling
to
represen
t
three-dimensional
ob
jects
is
necessary
for
collision
detection
and
dynamics
computation.
F
urthermore,
to
automate
the
pro
cess
of
generating
the
hierarc
hical
represen
tation
will
b
e
extremely
useful
in
handling
complex,
non-con
v
ex
ob
jects
in
a
computer
generated
sim
ulation.
Our
collision
detection
algorithm
for
non-con
v
ex
ob
jects
uses
the
sub-part
hierarc
hical
tree
represen
tation
to
mo
del
eac
h
non-con
v
ex
ob
ject.
If
the
ob
jects
are
generated
b
y
hand,
this
represen
tation
is
easy
to
use.
Ho
w
ev
er,
if
w
e
are
giv
en
a
set
of
faces
describing
the
non-con
v
ex
ob
ject
without
an
y
sp
ecial
format,
w
e
can
use


a
con
v
ex
decomp
osition
mo
dule
whic
h
do
es
not
necessarily
giv
e
us
an
optimal
con-
v
ex
decomp
osition
of
the
non-con
v
ex
ob
jects,
since
the
problem
itself
is
NP-complete
[,

,

,

].
Therefore,
applying
our
sub-part
hierarc
hical
tree
represen
tation
directly
to
the
output
of
a
non-optimal
con
v
ex
decomp
osition
routine
ma
y
not
yield
satisfactory
results
for
the
purp
ose
of
collision
detection,
esp
ecially
if
w
e
ha
v
e
n
umer-
ous
n
um
b
er
of
con
v
ex
pieces.
One
p
ossibilit
y
is
to
establish
a
criterion
for
grouping
no
des,
e.g.
maximiz
e
v
olume(A[B
)
v
olume(conv
(A[B
))
,
where
conv
(P
)
represen
ts
the
con
v
ex
h
ull
of
P
.
So
far,
in
our
sim
ulation,
w
e
ha
v
e
to
build
the
sub-part
hierarc
hical
tree
b
y
b
oth
visual
insp
ection
of
the
data
and
extracting
the
information
b
y
hand,
in
order
to
tak
e
adv
an
tage
of
the
geometry
of
the
original
ob
ject.
This
is
a
rather
painful
and
time
consuming
pro
cess.
One
prop
osed
solution
w
ould
b
e
to
generate
all
mo
dels
b
y
a
Computer
Aided
Geometric
Design
to
ol
whic
h
has
only
union
as
a
primitiv
e
and
all
primitiv
e
v
olumes
are
con
v
ex.
Ho
w
ev
er,
to
mak
e
a
general
system
for
collision
detection,
w
e
still
ha
v
e
to
face
the
problem
when
w
e
are
giv
en
only
the
face
information
without
an
y
sp
ecial
format
to
extract
the
geometry
information
to
construct
the
sub-part
hierarc
hical
tree.
This
is
an
in
teresting
and
c
hallenging
geometry
and
mo
deling
problem.
..
Collision
Detection
for
Deformable
ob
jects
One
of
most
c
hallenging
problems
is
collision
detection
for
ob
jects
of
de-
formable
materials
or
with
time
v
arying
surfaces.
In
terms
of
complexit
y
,
deformable
ob
jects
oer
us
the
greatest
c
hallenge
for
the
problem
of
con
tact
determination.
Our
algorithms
presen
ted
in
this
thesis
w
ork
extremely
w
ell
with
rigid
b
o
dies.
Whereas
using
deformable
mo
dels,
it
is
v
ery
dicult
to
predict
where
conca
vit
y
and
degeneracy
ma
y
b
e
in
tro
duced
due
to
external
forces,
and
the
shap
e
of
ob
jects
can
b
e
c
hanged
in
all
p
ossible
w
a
ys.
Therefore,
the
problem
of
collision
detection
b
ecomes
rather
complex
and
almost
imp
ossible
to
solv
e
in
teractiv
ely
.
Some
w
ork
has
b
een
done
for
time-dep
enden
t
parametric
surfaces
[].
Herzen
and
etc.
use
a
hierarc
hical
algorithm
whic
h
rst
nds
the
p
oten
tial
collision
o
v
er
large


v
olumes
and
then
renes
the
solution
to
smaller
v
olumes.
The
b
ound
on
these
v
ol-
umes
are
deriv
ed
from
the
deriv
ativ
es
with
resp
ect
to
time
and
the
parameters
of
the
surfaces.
Though
it
is
reasonably
robust
and
applicable
for
deforming
time-dep
enden
t
surfaces,
it
cannot
guaran
tee
to
detect
collisions
for
surfaces
with
un
b
ounded
deriv
a-
tiv
es.
In
man
y
in
teractiv
e
en
vironmen
ts,
the
deriv
ativ
es
of
the
surface
with
resp
ect
to
time
are
not
obtainable
and
this
approac
h
cannot
w
ork
under
suc
h
a
circumstance.
Another
commonly
used
metho
d
is
to
mo
del
the
deformable
ob
jects
b
y
nite
elemen
t
metho
ds
and
no
dal
analysis
[0].
Ho
w
ev
er,
this
approac
h
is
computationally
to
o
exp
ensiv
e.
Unless
w
e
use
sp
ecialized
parallel
mac
hines
to
sim
ulate
the
motions,
its
sp
eed
is
not
satisfactory
.
Bara
and
Witkin
use
p
olyhedral
appro
ximation
to
handle
the
deformable
ob
jects
[]
for
the
purp
ose
of
collision
detection.
If
the
mo
del
is
v
ery
rened,
this
approac
h
ma
y
yield
reasonable
results;
ho
w
ev
er,
ev
en
with
the
use
of
coherence
based
on
a
culling
step
to
reduce
the
n
um
b
er
of
the
p
olygon-p
olygon
in
tersection
tests,
the
resulting
algorithm
still
tak
es
longer
than
linear
time.
F
or
lo
w
resolution
of
the
p
olyhedral
mo
del,
the
visual
eect
generated
b
y
this
algorithm
w
ould
b
e
v
ery
discon-
certing
(the
view
er
ma
y
see
in
tersecting
facets
frequen
tly)
and
the
n
umerical
solution
will
b
e
rather
p
o
or
for
the
purp
ose
of
sim
ulating
dynamics
and
robust
in
tegration.
Sn
yder
and
etc.
[
]
presen
t
a
general
collision
detection
algorithm
for
an
y
t
yp
e
of
surface
b
y
using
in
terv
al
arithmetics,
optimization
routines,
and
man
y
other
n
umerical
metho
ds.
Although
the
algorithm
can
b
e
used
for
a
large
class
of
v
arious
mo
dels,
it
is
extremel
y
slo
w.
As
Sn
yder
admitted,
it
cannot
b
e
used
for
real
time
sim
ulation.
Ho
w
ev
er,
these
da
ys
it
is
not
acceptable
to
sp
end
h
undreds
of
hours
generating
a
few
seconds
of
sim
ulation.
One
of
the
imp
ortan
t
factors
as
w
e
men
tion
in
the
in
tro
duction
is
sp
eed,
i.e.
ho
w
quic
kly
the
algorithm
can
generate
results.
Our
algorithm
is
esp
ecially
tailored
for
rigid
b
o
dies,
since
the
V
oronoi
regions
are
constructed
based
on
the
prop
erties
of
con
v
ex
p
olyhedra.
F
or
linear
deformation
where
the
ob
jects
remain
con
v
ex,
w
e
can
transform
the
precomputed
V
oronoi
regions
for
the
purp
ose
of
collision
detection
b
et
w
een
exible
ob
jects.
But,
in
most
situations,
the
deformable
ob
ject
ma
y
b
ecome
lo
cally
non-con
v
ex
and
the
algorithm
describ
ed
in
Chapter

cannot
b
e
easily
mo
died
to
ecien
tly
handle
suc
h
a
con
tact
during
the


deformation
phase.
Ho
w
ev
er,
it
is
p
ossible
that
w
e
use
the
algorithms
describ
ed
in
this
thesis
as
a
top
lev
el
mo
dule
un
til
the
impacts
o
ccurs
or
external
forces
are
applied
to
the
deformable
ob
jects,
for
the
purp
ose
of
eliminating
collision
c
hec
ks.
But,
a
fast
and
exact
metho
d
is
still
needed.
This
leads
to
a
new
area
of
exciting
researc
h.
..
Collision
Resp
onse
In
a
ph
ysically-based
dynamic
sim
ulation,
there
are
t
w
o
ma
jor
comp
onen
ts
to
a
successful
and
realistic
system
displa
y:
collision
detection
and
collision
resp
onse.
Giv
en
that
w
e
ha
v
e
understo
o
d
the
problem
of
collision
detection
reasonably
w
ell
for
the
rigid
ob
jects,
another
related
problem
is
to
resolv
e
the
dicult
y
of
sim
ulating
the
ph
ysics
of
real
w
orld
ob
jects:
Con
tact
forces
m
ust
b
e
calculated
and
applied
un
til
separation
nally
o
ccurs;
in
addition,
ob
jects'
v
elo
cities
m
ust
b
e
adjusted
during
the
con
tact
course
in
resp
onse
to
the
impacts.
All
these
pro
cesses
are
considered
as
a
part
of
dynamics
resp
onse
to
the
collision
follo
wing
the
basic
la
ws
of
ph
ysics.
An
automated
dynamics
generator
allo
ws
the
user
to
in
teract
with
a
c
hang-
ing
en
vironmen
t.
Suc
h
an
en
vironmen
t
can
arise
b
ecause
of
activ
e
motion
(lo
como-
tion)
or
passiv
e
motion
(riding
a
v
ehicle).
F
urthermore,
mo
deling
ph
ysics
of
dynamics
tigh
tly
couples
in
teraction
with
force
feedbac
k
b
et
w
een
h
uman
participan
ts
in
the
vir-
tual
w
orld
and
guided
agen
t
(i.e.
graphic
images
sla
v
ed
to
other
h
uman
participan
ts);
it
also
tigh
tly
couples
among
h
uman
participan
ts
and
the
force
feedbac
k
devices.
It
con
tributes
to
realistic
p
ortra
y
al
of
autonomous
mo
v
eme
n
ts
of
all
virtual
ob
jects
in
the
syn
thetic
en
vironmen
ts.
Most
dynamic
sim
ulators
[,
,

,

,
	
]
mak
e
simplication
of
mo
dels
in
sim
ulating
the
ph
ysics
of
translating
and
rotating
ob
jects,
and
mostly
on
frictionless
impacts.
Recen
tly
,
Keller
applied
Routh's
frictional
impact
equations
[]
to
a
few
simplied
cases
with
n
umerous
assumptions
[	].
W
ang
and
Mason
also
c
haracterize
frictional
impacts
for
the
t
w
o-dimensional
impacts
[].
Curren
tly
Mirtic
h
and
Cann
y
are
in
v
estigating
a
b
etter
approac
h
to
mo
del
the
three-dimensional
frictional
impact,
whic
h
will
b
e
extremely
useful
for
a
general-purp
ose
dynamics
sim
ulator
in
computer
generated
virtual
en
vironmen
t
or
rob
otics
sim
ulation
for
man
ufacturing
purp
oses.


Man
y
op
en
problems
are
still
left
to
b
e
addressed.
The
goal
of
researc
h
in
this
area
w
ould
b
e
to
sim
ulate
the
dynamics
(the
geometric
comp
onen
t,
the
ph
ysics
mo
dule,
the
n
umerical
in
tegrator,
and
motion
con
trol)
in
real
time.


Biblio
graph
y
[]
L.
E.
Andersson
and
N.
F.
Stew
ard.
Maximal
distance
for
rob
otic
sim
ulation:
the
con
v
ex
case.
Journal
of
Optimization
The
ory
and
Applic
ations,
(No.
):{
,
	.
[]
C.
Ba
ja
j
and
T.
Dey
.
Con
v
ex
decomp
osition
of
p
olyhedra
and
robustness.
SIAM
J.
of
Comput.,
(No.
):	{,
		.
[]
D.
Bara.
Curv
ed
surfaces
and
coherence
for
non-p
enetrating
rigid
b
o
dy
sim
u-
lation.
A
CM
Computer
Gr
aphics,
():	{,
		0.
[]
D.
Bara.
Issues
on
computing
con
tact
forces
for
non-p
enetrating
rigid
b
o
dies.
A
lgorithmic
a,
V
ol.
0(-):	{
,
Aug/Sept/Oct
		.
[]
Da
vid
Bara
and
Andrew
Witkin.
Dynamic
sim
ulation
of
non-p
enetrating
ex-
ible
b
o
dies.
Computer
Gr
aphics,
():0{0
,
July
		.
[]
J.
Barraquand,
B.
Langlois,
and
J-C.
Latom
b
e.
Rob
ot
motion
planning
with
man
y
degrees
of
freedom
and
dynamic
constrain
ts.
In
Pr
o
c
e
e
dings
th
Int.
Symp
R
ob
otics
R
ese
ar
ch,
T
oky
o,
Japan,
		.
[]
R.
Barzel
and
A.
Barr.
A
mo
deling
system
based
on
dynamic
constrain
ts.
A
CM
Computer
Gr
aphics,
():{	,
	.
[]
D.
N.
Bernstein.
The
n
um
b
er
of
ro
ots
of
a
system
of
equations.
F
unktsional'nyi
A
naliz
i
Ego
Prilozheniya,
	():{,
Jul-Sep
	.


[	]
J.
E.
Bobro
w.
A
direct
minimi
zation
approac
h
for
obtaining
distance
b
et
w
een
con
v
ex
p
olyhedra.
International
Journal
of
R
ob
otics
R
ese
ar
ch,
(No.
):{,
		.
[0]
W.
Bouma
and
Jr.
G.
V
anecek.
Collision
detection
and
analysis
in
a
ph
ysi-
cally
based
sim
ulation.
In
Pr
o
c
e
e
ding
of
the
Se
c
onde
Eur
o
gr
aphics
Workshop
on
A
nimation
and
Simulation,
		.
Vienna
Austria.
[]
J.
W.
Bo
yse.
In
terference
detection
among
solids
and
surfaces.
Comm.
A
CM,
():{	,
		.
[]
S.
A.
Cameron.
A
study
of
the
clash
detection
problem
in
rob
otics.
Pr
o
c.
IEEE
ICRA,
pages
pp.
{	,
	.
[]
S.
A.
Cameron
and
R.
K.
Culley
.
Determining
the
minim
um
translational
dis-
tance
b
et
w
een
t
w
o
con
v
ex
p
olyhedra.
Pr
o
c.
IEEE
ICRA,
pages
pp.
	{	,
	.
[]
J.
Cann
y
.
Computing
roadmaps
of
general
semi-algebraic
sets.
In
AAECC-	,
pages
	{0,
		.
[]
J.
Cann
y
and
B.
Donald.
Simplied
v
oronoi
diagrams.
Discr
et
Comput.
Ge
om-
etry,
pages
	{,
	.
[]
J.
Cann
y
and
I.
Emiris.
An
ecien
t
algorithm
for
the
sparse
mixed
resultan
t.
In
G.
Cohen,
T.
Mora,
and
O.
Moreno,
editors,
Pr
o
c.
0th
Intern.
Symp.
on
Applie
d
A
lgebr
a,
A
lgebr
aic
A
lgorithms
and
Err
or-Corr
e
cting
Co
des,
pages
	{
0.
Springer
V
erlag,
Ma
y
		.
Lect.
Notes
in
Comp.
Science
.
[]
J.
F.
Cann
y
.
Collision
detection
for
mo
ving
p
olyhedra.
IEEE
T
r
ans.
P
AMI,
:pp.
00{0	,
	.
[]
J.
F.
Cann
y
.
The
Complexity
of
R
ob
ot
Motion
Planning.
MIT
Press,
Cam
bridge,
MA,
	.

	
[	]
J.
F.
Cann
y
.
Constructing
roadmaps
of
semi-algebraic
sets
I:
Completeness.
A
rticial
Intel
ligen
c
e,
:0{,
	.
[0]
J.
F.
Cann
y
and
M.
C.
Lin.
An
opp
ortunistic
global
path
planner.
A
lgorithmic
a,
Sp
e
cial
Issue
on
Computational
R
ob
otics,
V
ol.
0(-):0{0
,
Aug/Sept/Oct
		.
[]
J.F.
Cann
y
.
Generalized
c
haracteristic
p
olynomials.
Journal
of
Symb
olic
Com-
putation,
	():{0,
		0.
[]
B.
Chazelle.
Con
v
ex
partitions
of
p
olyhedra:
A
lo
w
er
b
ound
and
w
orst-case
optimal
algorithm.
SIAM
J.
Comput.,
:{0,
	.
[]
B.
Chazelle
and
L.
P
alios.
T
riangulating
a
non-con
v
ex
p
olytop
e.
Discr
ete
&
Comput.
Ge
om.,
():0{,
		0.
[]
J.
Cohen,
M.
Lin,
D.
Mano
c
ha,
and
M.
P
onamgi.
Exact
collision
detection
for
in-
teractiv
e,
large-scaled
en
vironmen
ts.
T
ec
h
Rep
ort
#TR	-00,
		.
Univ
ersit
y
of
North
Carolina,
Chap
el
Hill.
[]
James
F.
Cremer
and
A.
James
Stew
art.
The
arc
hitecture
of
newton,
a
general-
purp
ose
dynamics
sim
ulator.
In
IEEE
Int.
Conf.
on
R
ob
otics
and
A
utomation,
pages
0{
,
Ma
y
		.
[]
D.
P
.
Dobkin
and
D.
G.
Kirkpatric
k.
A
linear
algorithm
for
determining
the
separation
of
con
v
ex
p
olyhedra.
J.
A
lgorithms,
():pp.
{	,
	.
[]
D.
P
.
Dobkin
and
D.
G.
Kirkpatric
k.
Determining
the
separation
of
prepro-
cessed
p
olyhedra
{
a
unied
approac
h.
In
Pr
o
c.
th
Internat.
Col
lo
q.
A
utomata
L
ang.
Pr
o
gr
am,
Lecture
Notes
in
Computer
Science
,
pages
00{.
Springer-
V
erlag,
		0.
[]
B.
R.
Donald.
Motion
planning
with
six
degrees
of
freedom.
Master's
thesis,
MIT
Articial
In
telligence
Lab.,
	.
AI-TR-	.

0
[	]
T
om
Du.
In
terv
al
arithmetic
and
recursiv
e
sub
division
for
implicit
functions
and
constructiv
e
solid
geometry
.
A
CM
Computer
Gr
aphics,
():{	,
		.
[0]
M.
E.
Dy
er.
Linear
algorithms
for
t
w
o
and
three-v
ariable
linear
programs.
SIAM
J.
on
Computing,
:pp.
{,
	.
[]
H.
Edelsbrunner.
A
new
approac
h
to
rectangle
in
tersections,
part
i&ii.
Intern.
J.
Computer
Math.,
:pp.
0	{	,
	.
[]
H.
Edelsbrunner.
A
lgorithms
in
Combinatorial
Ge
ometry.
Springer-V
erlag,
Berlin,
Heidelb
erg,
New
Y
ork,
London,
P
aris,
T
oky
o,
	.
[]
I.
Emiris
and
J.
Cann
y
.
A
general
approac
h
to
remo
ving
degeneracies.
In
IEEE
F
OCS,
pages
0{,
		.
[]
S.
F.
F
ahlman.
A
planning
system
for
rob
ot
construction
tasks.
A
rtic
al
Intel-
ligne
c
e,
:pp.
{	,
	.
[]
G.
F
arin.
Curves
and
Surfac
es
for
Computer
A
ide
d
Ge
ometric
Design:
A
Pr
ac-
tic
al
Guide.
Academic
Press
Inc.,
		0.
[]
D.
Filip,
R.
Magedson,
and
R.
Mark
ot.
Surface
algorithms
using
b
ounds
on
deriv
ativ
es.
Computer
A
ide
d
Ge
ometric
Design,
:	{,
	.
[]
Jr.
G.
V
anecek.
Brep-index:
A
m
ulti-dim
ensional
space
partitioning
tree.
A
CM/SIGGRAPH
Symp
osium
on
Solid
Mo
deling
F
oundations
and
CAD
Ap-
plic
ations,
pages
{,
		.
Austin
T
exas.
[]
E.
G.
Gilb
ert
and
C.
P
.
F
o
o.
Computing
the
distance
b
et
w
een
general
con
v
ex
ob
jects
in
three
dimensional
space.
IEEE
T
r
ans.
R
ob
otics
A
utomat.,
(),
		0.
[	]
E.
G.
Gilb
ert
and
S.
M.
Hong.
A
new
algorithm
for
detecting
the
collision
of
mo
ving
ob
jects.
Pr
o
c.
IEEE
ICRA,
pages
pp.
{,
		.
[0]
E.
G.
Gilb
ert
and
D.
W.
Johnson.
Distance
functions
and
their
application
to
rob
ot
path
planning
in
the
presence
of
obstacles.
IEEE
J.
R
ob
otics
A
utomat.,
RA-:pp.
{0,
	.


[]
E.
G.
Gilb
ert,
D.
W.
Johnson,
and
S.
S.
Keerthi.
A
fast
pro
cedure
for
computing
the
distance
b
et
w
een
ob
jects
in
three-dimensional
space.
IEEE
J.
R
ob
otics
and
A
utomation,
v
ol
RA-:pp.
	{0,
	.
[]
G.H.
Golub
and
C.F.
V
an
Loan.
Matrix
Computations.
John
Hopkins
Press,
Baltimore,
		.
[]
J.
K.
Hahn.
Realistic
animation
of
rigid
b
o
dies.
A
CM
Computer
Gr
aphics,
():pp.
		{0,
	.
[]
Mark
Hall
and
Jo
e
W
arren.
Adaptiv
e
p
olygonalization
of
implicitl
y
dened
surfaces.
IEEE
Computer
Gr
aphics
and
Applic
ations,
0():{,
No
v
em
b
er
		0.
[]
B.
V.
Herzen,
A.
H.
Barr,
and
H.
R.
Zatz.
Geometric
collisions
for
time-
dep
enden
t
parametric
surfaces.
A
CM
Computer
Gr
aphics,
(),
August
		0.
[]
C.
Homann.
Ge
ometric
&
Solid
Mo
deling.
Morgan
Kaufmann
Publishers,
Inc.,
San
Mateo,
CA,
		.
[]
J.E.
Hop
croft,
J.T.
Sc
h
w
artz,
and
M.
Sharir.
Ecien
t
detection
of
in
tersections
among
spheres.
The
International
Journal
of
R
ob
otics
R
ese
ar
ch,
():{0,
	.
[]
Kass,
Witkin,
Bara,
and
Barr.
An
in
tro
duction
to
ph
ysically
based
mo
deling.
Course
Notes
0,
		.
[	]
J.
B.
Keller.
Impact
with
friction.
Journal
of
Applie
d
Mathematics,
V
ol.
,
Marc
h
	.
[0]
O.
Khatib.
Real-time
obstable
a
v
oidance
for
manipulators
and
mobile
rob
ots.
IJRR,
():	0{	,
	.
[]
J.C.
Latom
b
e.
R
ob
ot
Motion
Planning.
Klu
w
er
Academic
Publishers,
		.


[]
A.
Lingas.
The
p
o
w
er
of
non-rectilinear
holes.
In
Pr
o
c.
	th
Internat.
Col
lo
q.
A
utomata
L
ang.
Pr
o
gr
am.,
v
olume
0
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
	{.
Springer-V
erlag,
	.
[]
T.
Lozano-P

erez
and
M.
W
esley
.
An
algorithm
for
planning
collision-free
paths
among
p
olyhedral
obstacles.
Comm.
A
CM,
(0):pp.
0{0,
		.
[]
T.
Lozano-P

erez
and
M.
W
esley
.
An
algorithm
for
planning
collision-free
paths
among
p
olyhedral
obstacles.
Comm.
A
CM,
(0):0{
0,
		.
[]
D.
Mano
c
ha.
A
lgebr
aic
and
Numeric
T
e
chniques
for
Mo
deling
and
R
ob
otics.
PhD
thesis,
Computer
Science
Division,
Departmen
t
of
Electrical
Engineering
and
Computer
Science,
Univ
ersit
y
of
California,
Berk
eley
,
Ma
y
		.
[]
D.
Mano
c
ha.
Solving
p
olynomial
systems
for
curv
e,
surface
and
solid
mo
del-
ing.
In
A
CM/SIGGRAPH
Symp
osium
on
Solid
Mo
deling,
pages
	{,
		.
Revised
v
ersion
to
app
ear
in
IEEE
Computer
Graphics
and
Applications.
[]
D.
Mano
c
ha
and
J.
F.
Cann
y
.
Ecien
t
teniques
for
m
ultip
olynomial
resultan
t
algorithms.
Pr
o
c
e
e
dings
of
ISSA
C'	,
		.
Bonn,
German
y
.
[]
N.
Megiddo.
Linear-time
algorithms
for
linear
programming
in
R

and
related
problems.
SIAM
J.
Computing,
:pp.
	{,
	.
[	]
N.
Megiddo.
Linear
programming
in
linear
time
when
the
dimension
is
xed.
Jour.
A
CM,
:pp.
{,
	.
[0]
N.
Megiddo
and
A.
T
amir.
Linear
time
algorithms
for
some
separable
quadratic
programming
problems.
Op
er
ations
R
ese
ar
ch
letters,
():0{,
		.
[]
J.
Milnor.
On
the
b
etti
n
um
b
ers
of
real
v
arieties.
Pr
o
c.
A
mer.
Math.
So
c.,
:{0,
	.
[]
B.
Mirtic
h
and
J.
Cann
y
.
Impusle-based,
real
time
dynamic
sim
ulation.
Submit-
ted
to
A
CM
SIGGRAPH,
		.
Univ
ersit
y
of
California,
Berk
eley
.


[]
M.
Mo
ore
and
J.
Wilhelms.
Collision
detection
and
resp
onse
for
computer
ani-
mation.
A
CM
Computer
Gr
aphics,
():pp.
	{	,
	.
[]
A.
P
.
Morgan.
P
olynomial
con
tin
uation
and
its
relationship
to
the
sym
b
olic
reduction
of
p
olynomial
systems.
In
Symb
olic
and
Numeric
al
Computation
for
A
rticial
Intel
ligen
c
e,
pages
{,
		.
[]
M.
Orlo
wski.
The
computation
of
the
distance
b
et
w
een
p
olyhedra
in
-space.
Presen
ted
SIAM
Conf.
on
Geometric
Mo
deling
and
Rob
otics,
	.
Alban
y
,
NY.
[]
J.
O'Rourk
e,
C.-B
Chien,
T.
Olson,
and
D.
Naddor.
A
new
linear
algorithm
for
in
tersecting
con
v
ex
p
olygons.
Computer
Gr
aphics
and
Image
Pr
o
c
essing,
	:{
	,
	.
[]
J.
O'Rourk
e
and
K.
J.
Sup
o
wit.
Some
NP-hard
p
olygon
decomp
osition
problems.
IEEE
T
r
ans.
Inform.
The
ory,
IT-0:{	0,
	.
[]
M.
H.
Ov
ermars.
P
oin
t
lo
cation
in
fat
sub
divisions.
Inform.
Pr
o
c.
L
ett.,
:{
,
		.
[	]
A.
P
en
tland.
Computational
complexit
y
v
ersus
sim
ulated
en
vironmen
t.
Com-
puter
Gr
aphics,
():{	
,
		0.
[0]
A.
P
en
tland
and
J.
Williams.
Go
o
d
vibrations:
Mo
dal
dynamics
for
graphics
and
animation.
Computer
Gr
aphics,
():{	
,
		0.
[]
F.
P
.
Preparata
and
M.
I.
Shamos.
Computational
Ge
ometry.
Springer-V
erlag,
New
Y
ork,
	.
[]
W.
E.
Red.
Minim
um
distances
for
rob
ot
task
sim
ulation.
R
ob
otics,
:pp.
{
,
	.
[]
J.
Reif.
Complexity
of
the
Mover's
Pr
oblem
and
Gener
alizations,
c
hapter
,
pages
pp.
{.
Ablex
publishing
corp.,
New
Jersey
,
	.
edited
b
y
J.T.
Sc
h
w
artz
and
M.
Sharir
and
J.
Hop
croft.


[]
D.
F.
Rogers.
Pr
o
c
e
dur
al
Elements
for
Computer
Gr
aphics.
McGra
w-Hill
Bo
ok
Compan
y
,
	.
[]
Edw
ard
J.
Routh.
Elementary
R
igid
Dynamics.
	0.
[]
J.
Rupp
ert
and
R.
Seidel.
On
the
dicult
y
of
tetrahedralizing
-dimensional
non-
con
v
ex
p
olyhedra.
In
Pr
o
c.
of
the
Fifth
A
nnual
Symp
osium
on
Computational
Ge
ometry,
pages
0{	.
A
CM,
		.
[]
N.
Sanc
heti
and
S.
Keerthi.
Computation
of
certain
measures
of
pro
ximit
y
b
e-
t
w
een
con
v
ex
p
olytop
es:
A
complexit
y
viewp
oin
t.
Pr
o
c
e
e
dings
of
IEEE
ICRA'	,
:0{
,
Ma
y
		.
[]
J.T.
Sc
h
w
artz
and
M.
Sharir.
On
the
`Piano
Movers'
Pr
oblem,
II.
Gener
al
T
e
ch-
niques
for
Computing
T
op
olo
gic
al
Pr
op
erties
of
R
e
al
A
lgebr
aic
Manifolds,
c
hap-
ter
,
pages
{.
Ablex
publishing
corp.,
New
Jersey
,
	.
[	]
R.
Seidel.
Linear
programming
and
con
v
ex
h
ulls
made
easy
.
In
Pr
o
c.
th
A
nn.
A
CM
Conf.
on
Computational
Ge
ometry,
pages
{,
Berk
eley
,
California,
		0.
[0]
H.
W.
Six
and
D.
W
o
o
d.
Coun
ting
and
rep
orting
in
tersections
of
d-ranges.
IEEE
T
r
ans.
on
Computers,
C-(No.
),
Marc
h
	.
[]
J.
Sn
yder,
A.
W
o
o
dbury
,
K
Fleisc
her,
B.
Currin,
and
A.
Barr.
In
terv
al
metho
ds
for
m
ulti-p
oin
t
collisions
b
et
w
een
time-dep
enden
t
curv
ed
surfaces.
Computer
Gr
aphics,
Pr
o
c
e
e
dings
of
A
CM
SIGGRAPH'	,
pages
{,
August
		.
[]
D.
Sturman.
A
discussion
on
the
dev
elopmen
t
of
motion
con
trol
systems.
In
SigGr
aph
Course
Notes:
Computer
A
nimation:
-D
Motion
Sp
e
cic
ation
and
Contr
ol,
n
um
b
er
0,
	.
[]
W.
Thibault
and
B.
Na
ylor.
Set
op
erations
on
p
olyhedra
using
binary
space
partitioning
trees.
Computer
Gr
aphics
{
SIGGRAPH',
(),
	.


[]
R.
Thom.
Sur
l'homologie
des
v
arietes
algebriques
reelles.
Dier
ential
and
Com-
binatorial
T
op
olo
gy,
pages
{,
	.
[]
G.
T
urk.
In
teractiv
e
collision
detection
for
molecular
graphics.
Master's
thesis,
Computer
Science
Departmen
t,
Univ
ersit
y
of
North
Carolina
at
Chap
el
Hill,
		.
[]
Y
u
W
ang
and
Matthew
T.
Mason.
Mo
deling
impact
dynamics
for
rob
otic
op-
erations.
In
IEEE
Int.
Conf.
on
R
ob
otics
and
A
utomation,
pages
{,
Ma
y
	.
[]
C.
G.
Gibson
K.
Wirthm
uller
and
A.
A.
du
Plessis
E.
J.
N.
Lo
oijenga.
T
op
olo
gic
al
Stability
of
Smo
oth
Mappings.
Springer-V
erlag,
Berlin
.
Heidelb
erg
.
New
Y
ork,
	.
[]
Andrew
Witkin,
Mic
hael
Gleic
her,
and
William
W
elc
h.
In
teractiv
e
dynamics.
Computer
Gr
aphics,
():{,
Marc
h
		0.
[	]
Andrew
Witkin
and
William
W
elc
h.
F
ast
animation
and
con
trol
of
nonrigid
structures.
Computer
Gr
aphics,
():{
,
August
		0.
[	0]
P
.
W
olfe.
Finding
the
nearest
p
oin
ts
in
a
p
olytop
e.
Math.
Pr
o
gr
amming,
:pp.
{	,
	.
[	]
K.
Zik
an
and
W.
D.
Curtis.
In
tersection
and
separations
of
p
olytop
es.
Bo
eing
Computer
Servic
es
T
e
chnolo
gy,
BCSTECH-	-0,
		.
A
note
on
collision
and
in
terference
detection.


App
endix
A
Calculating
the
Nearest
P
oin
ts
b
et
w
een
Tw
o
F
eatures
In
this
app
endix,
w
e
will
describ
ed
the
equations
whic
h
the
implem
en
tation
of
the
distance
computation
algorithm
describ
ed
in
Chapter

is
based
up
on.
(I)
VER
TEX-VER
TEX:
The
nearest
p
oin
ts
are
just
the
v
ertices.
(I
I)
VER
TEX-EDGE:
Let
the
v
ertex
b
e
V
=
(V
x
;
V
y
;
V
z
;
)
and
the
edge
E
ha
v
e
head
H
E
=
(H
x
;
H
y
;
H
z
;
),
tail
T
E
=
(T
x
;
T
y
;
T
z
;
),
and
~
e
=
H
E
 T
E
=
(E
x
;
E
y
;
E
z
;
0).
Then,
the
nearest
p
oin
t
P
E
on
the
edge
E
to
the
v
ertex
V
can
b
e
found
b
y:
P
E
=
T
E
+
min(;
max(0;
(V
 T
E
)

~
e
j
~
e
j

))
~
e
(A:)
(I
I
I)
VER
TEX-F
A
CE:
Let
the
v
ertex
b
e
V
=
(V
x
;
V
y
;
V
z
;
);
If
w
e
use
a
normalized
unit
face
out
w
ard
normal
v
ector,
that
is
the
normal
n
=
(a;
b;
c)
of
the
face
has
the
magnitude
of

and
N
F
=
(n;
 d)
=
(a;
b;
c;
 d)
and
 d
is
the
signe
d
distance
of
the
face
F
from
the
origin,
and
the
v
ertex
V
dened
as
ab
o
v
e.
W
e
dene
a
new
v
ector
quan
tit
y
~
n
F
b
y
~
n
F
=
(n;
0).
The
nearest
p
oin
t
P
F
on
F
to
V
can
b
e
simply
expressed
as:


P
F
=
V
 (V

N
F
)
~
n
F
(A:)
(IV)
EDGE-EDGE:
Let
H

and
T

b
e
the
head
and
tail
of
the
edge
E

resp
ectiv
ely
.
And
H

and
T

b
e
the
head
and
tail
of
the
edge
E

as
w
ell.
V
ectors
~
e

and
~
e

are
dened
as
~
e

=
H

 T

and
~
e

=
H

 T

.
W
e
can
nd
for
the
nearest
p
oin
t
pair
P

and
P

on
E

and
E

b
y
the
follo
wing:
P

=
H

+
s(T

 H

)
=
H

 s
~
e

(A.)
P

=
H

+
u(T

 H

)
=
H

 u
~
e

where
s
and
u
are
scalar
v
alues
parameterized
b
et
w
een
0
and

to
indicate
the
relativ
e
lo
cation
of
P

and
P

on
the
edges
E

and
E

.
Let
~
n
=
P

 P

and
j
~
n
j
is
the
shortest
distance
b
et
w
een
the
t
w
o
edges
E

and
E

.
Since
~
n
m
ust
b
e
orthogonal
to
the
v
ectors
~
e

and
~
e

,
w
e
ha
v
e:
~
n

~
e

=
(P

 P

)

~
e

=
0
(A.)
~
n

~
e

=
(P

 P

)

~
e

=
0
By
substituting
Eqn.(
A.)
in
to
these
equations
(A.),
w
e
can
solv
e
for
s
and
u:
s
=
(
~
e


~
e

)[(H

 H

)

~
e

]
 (
~
e


~
e

)[(H

 H

)

~
e

]
det
(A.)
u
=
(
~
e


~
e

)[(H

 H

)

~
e

]
 (
~
e


~
e

)[(H

 H

)

~
e

]
det
where
det
=
((
~
e


~
e

)

(
~
e


~
e

))
 (
~
e


~
e

)

(
~
e


~
e

).
Ho
w
ev
er,
to
mak
e
sure
P

and
P

lie
on
the
edges
E

and
E

,
s
and
u
are
truncated
to
the
range
[0,]
whic
h
giv
es
the
correct
nearest
p
oin
t
pair
(P

;
P

)
(V)
EDGE-F
A
CE:
Degenerate,
w
e
don't
compute
them
explicitly
.
Please
see
the
pseudo
co
de
in
App
endix
B
for
the
detailed
treatmen
t.


(VI)
F
A
CE-F
A
CE:
Degenerate,
w
e
don't
compute
them
explicitly
.
Please
see
the
pseudo
co
de
in
App
endix
B
for
the
detailed
treatmen
t.

	
App
endix
B
Pseudo
Co
de
of
the
Distance
Algorithm
P
AR
T
I
-
Data
Structure
type
VEC
{
REAL
X
%%
X-coordinate
REAL
Y
%%
Y-coordinate
REAL
Z
%%
Z-coordinate
REAL
W
%%
scaling
factor
}
type
VERTEX
{
REAL
X,
Y,
Z,
W;
FEATURE
*edges;
%%
pointer
to
its
coboundary
-
a
list
of
edges
CELL
*cell;
%%
vertex's
Voronoi
region
};
type
EDGE
{
VERTEX
*H,
*T;
%%
the
head
and
tail
of
this
edge
FACE
*fright,
*fleft;
%%
the
right
and
left
face
of
this
winged
edge
VEC
vector;
%%
unit
vector
representing
this
edge

0
CELL
*cell;
%%
edge's
Voronoi
region
};
type
FACE
{
FEATURE
*verts;
%%
list
of
vertices
on
the
face
FEATURE
*edges;
%%
list
of
edges
bounding
the
face
VEC
norm;
%%
face's
unit
outward
normal
CELL
*cell;
%%
face's
PRISM,
NOT
including
the
plane
of
face
POLYHEDRON
*cobnd;
%%
the
polyhedron
containing
the
FACE
};
type
FEATURE
{
union{
%%
features
are
union
of
VERTEX
*v;
%%
vertices,
EDGE
*e;
%%
edges,
FACE
*f;
%%
and
faces
};
FEATURE
*next;
%%
pointer
to
next
feature
};
struct
CELL
{
VEC
cplane;
%%
one
constraint
plane
of
a
Voronoi
region:
%%%%
cplane.X
*
X
+
cplane.Y
*
Y
+
cplane.Z
*
Z
+
cplane.W
=
0
%%%%
PTR
*neighbr;
%%
ptr
to
next
feature
if
this
app
test
fails
CELL
*next;
%%
if
there
are
more
planes
in
this
V.
region
};
type
POLYHEDRON
{
FEATURE
*verts;
%%
all
its
vertices
FEATURE
*edges;
%%
all
its
edges
FEATURE
*faces;
%%
all
its
faces
CELL
*cells;
%%
all
the
Voronoi
regions
assoc.
with
features


VEC
pos;
%%
its
current
location
vector
VEC
rot;
%%
its
current
direction
vector
};
P
AR
T
I
I
-
Algorithm
%%%
vector
or
vertex
operation:
dot
product
PROCEDURE
vdot
(v,
v)
RETURN
(v.X*v.X
+
v.Y*v.Y
+
v.Z*v.Z
+
v.W*v.W)
%%%
vector
operation:
cross
product
PROCEDURE
vcross
(v,
v)
RETURN
(v.Y*v.Z-v.Z*v
.Y,
v.Z*v.X-v.X*
v.Z,
v.X*v.Y-v.Y*v.X
)
%%%
vector
operation:
triple
product
PROCEDURE
triple(v,
v,
v)
RETURN
(vdot(vcross(v,
v,
v))
%%%
distance
function:
it
tests
for
the
type
of
features
in
order
%%%
to
calculate
the
distance
between
them.
It
takes
in

features
%%%
and
returns
the
distance
between
them.
Since
it
is
rather
simple,
%%%
we
only
document
its
functionality
and
input
here.
PROCEDURE
dist(feat,
feat)
%%%
Given

features
"feat"
and
"feat",
this
routine
finds
the
%%%
nearest
point
of
one
feature
to
another:
PROCEDURE
nearest-pt(feat,
feat)
%%%
Given

faces
"Fa"
and
"Fb",
it
find
the
closest
vertex
%%%
or
edges
in
Fb's
boundary
to
the
plane
containing
Fa
PROCEDURE
closestToFplane(F
a,
Fb)
%%%
Given
an
edge
E
and
a
face
F,
it
finds
the
closest
vertex
%%%
or
edge
in
the
boundary
of
the
face
F
PROCEDURE
closestToE(E,
F)


%%%
Given

faces
"Fa"
and
"Fb",
it
find
the
pair
of
edges
%%%
closest
in
distance
between

given
faces
PROCEDURE
closest-edges(Fa,
Fb)
%%%
Given

faces,
it
determines
if
the
projection
of
Fa
down
%%%
to
Fb
overlaps
with
Fb.
This
can
be
implemented
with
best
%%%
known
bound
O(N+M)
by
marching
along
the
boundary
of
Fa
and
%%%
Fb
to
find
the
intersecting
edges
thus
the
overlap
polygon,
%%%
where
N
and
M
is
the
number
of
vertices
of
Fa
and
Fb.
PROCEDURE
overlap(Fa,
Fb)
%%%
This
is
the
linear
time
routine
used
to
find
the
closest
%%%
feature
on
one
"polyhedron"
to
a
given
feature
"feat"
PROCEDURE
find-closest(feat
,
polyhedron)
%%%
Point-Cell
Applicability
Condition:
%%%
This
routine
returns
TRUE
if
P
satisfies
all
applicability
%%%
constraints
of
the
Voronoi
cell,
"Cell";
it
returns
the
%%%
neighboring
feature
whose
constraint
is
violated
the
most
%%%
if
"P"
fails
at
least
one
constraint
of
"Cell".
PROCEDURE
point-cell-checkp
(P,
Cell)
min
=
0
NBR
=
NULL
while
(NOT(Cell.cplane
=
NULL))
Do
test
=
vdot(P,
Cell.cplane)
if
(test
<
min)
then
min
=
test
NBR
=
Cell.neighbor
Cell
=
Cell.next
RETURN
NBR
%%%
Point-Face
Applicability
Condition
PROCEDURE
point-face-checkp
(P,
F)
NBR
=
point-cell-checkp
(P,
F.cell)
if
(NBR
=
NULL)
then
if
vdot(P,
F.norm)
>
0


then
RETURN(NBR)
else
RETURN(find-closest
(P,
F.cobnd))
else
RETURN(NBR)
%%
This
procedure
returns
TRUE
if
Ea
lies
within
the
%%
prismatic
region
swept
out
by
Fb
along
its
face
normal
%%
direction,
FALSE
otherwise.
PROCEDURE
E-FPrism(E,
F)
min
=
0
max
=
length(Ea)
for
(cell
=
Fb.cell
till
cell=NULL;
cell
=
cell.next)
norm
=
vdot(Ea.vector,cell
.cpla
ne)
%%
Ea
points
inward
of
the
hyperplane
if
(norm
>
0)
%%
compute
the
relative
inclusion
factor
then
K
=
vdot(Ea.H,
cell.cplane)
/
norm
if
(K
<
max)
{
then
max
=
K
if
(min
>
max)
RETURN(FALSE)
}
%%
Ea
points
outward
from
the
hyperplane
else
if
(norm
<
0)
%%
compute
the
relative
inclusion
factor
then
K
=
vdot(Ea.T,
cell.cplane)
/
norm
if
(K
>
min)
{
min
=
K
if
(max
<
min)
RETURN(FALSE)}
%%
norm
=
0
if
the
edge
Ea
and
Ei
are
parallel
else
if
vdot(Ea.H,
cell.cplane)
<
0
RETURN(FALSE)
RETURN(TRUE)
%%%
Vertex-Vertex
case:
PROCEDURE
vertex-vertex
(Va,
Vb)
NBRb
=
point-cell-checkp
(Va,
Vb.cell)
if
(NBRb
=
NULL)
then
NBRa
=
point-cell-checkp
(Vb,
Va.cell))
if
(NBRa
=
NULL)


then
RETURN
(Va,
Vb,
dist(Va,Vb))
else
close-feat-checkp
(NBRa,
Vb)
else
close-feat-checkp
(Va,
NBRb)
%%%
Vertex-Edge
case:
PROCEDURE
vertex-edge
(Va,
Eb)
NBRb
=
point-cell-checkp(
Va,
Eb.cell)
if
(NBRb
=
NULL)
then
NBRa
=
point-cell-checkp(ne
arest
-pt(
Va,
Eb),
Va.cell)
if
(NBRa
=
NULL)
then
RETURN
(Va,
Eb,
dist(Va,Eb))
else
close-feat-checkp
(NBRa,
Eb)
else
close-feat-checkp
(Va,
NBRb)
%%%
Vertex-Face
case:
PROCEDURE
vertex-face
(Va,
Fb)
NBRb
=
point-face-checkp
(Va,Fb)
if
(NBRb
=
NULL)
then
NBRa
=
point-cell-checkp
(nearest-pt(Va,
Fb),
Va.cell)
if
(NBRa
=
NULL)
then
RETURN
(Va,
Fb,
dist(Va,Fb))
else
close-feat-checkp
(NBRa,
Fb)
else
close-feat-checkp
(Va,
NBRb)
%%%
Edge-Edge
case:
PROCEDURE
edge-edge
(Ea,
Eb)
NBRb
=
point-cell-checkp
(nearest-pt(Eb,
Ea),
Eb.cell)
if
(NBRb
=
NULL)
then
NBRa
=
point-cell-checkp
(nearest-pt(Ea,
Eb),
Ea.cell))
if
(NBRa
=
NULL)
then
RETURN
(Ea,
Eb,
dist(Ea,Eb))
else
close-feat-checkp
(NBRa,
Eb)
else
close-feat-checkp
(Ea,
NBRb)
%%%
Edge-Face
case:
PROCEDURE
edge-face
(Ea
Fb)
if
(vdot(Ea.H,
Fb.norm)
=
vdot(Ea.T,
Fb.norm))


then
if
(E-FPrism(Ea,
Fb.cell)
#
NULL)
then
if
(vdot(Ea.H,
Fb.norm)
>
0)
then
cp_right
=
triple(E.fright.nor
m,
Ea.vector,
Fb.norm)
cp_left
=
triple(E.vector
,
F.fleft.norm,
Fb.norm)
if
(cp_right
>=
0)
then
if
(cp_left
>=
0)
then
RETURN
(Ea,
Fb,
dist(Ea,Fb))
else
close-feat-checkp
(Ea.fleft,
Fb)
else
close-feat-checkp
(Ea.fright,
Fb)
else
close-feat-check
p
(Ea,
find-closest(Ea,
Fb.cobnd))
else
close-feat-checkp
(Ea,
closestToE(Ea,
Fb))
else
if
(sign(vdot(Ea.H,
Fb.norm))
#
sign(vdot(Ea.T,
Fb.norm)))
then
close-feat-checkp
(Ea,
closestToE(Ea,
Fb))
else
if
(dist(Ea.H,
Fb)
<
dist(Ea.T,
Fb))
%%
dist
returns
unsigned
magnitude
then
sub-edge-face(Ea
.H,
Ea,
Fb)
else
sub-edge-face(Ea
.T,
Ea,
Fb)
%%%
Sub-Edge-Face
case:
PROCEDURE
sub-edge-face
(Ve,
E,
F)
NBRb
=
point-cell-checkp
(Ve,
F.cell)
if
(NBRb
=
NULL)
then
if
(vdot(Ve,
F.norm)
>
0)
then
NBRa
=
point-cell-checkp
(nearest-pt(Ve,
F),
Ve.cell)
if
(NBRa
=
NULL)
then
RETURN
(Ve,
F,
dist(Ve,F))
else
close-feat-check
p
(NBRa,
F)
else
close-feat-checkp
(Ve,
find-closest(Ve
,
F.cobnd))
else
close-feat-checkp
(E,
closestToE(E,
F))
%%%
Face-Face-case:
PROCEDURE
face-face
(Fa
Fb)
if
(abs(vdot(Fa.norm
,
Fb.norm))
=
)
%%
check
if
Fa
and
Fb
parallel
then
if
(overlap(Fa,
Fb))
then
if
(vdot(Va,
Fb.norm)
>
0)
then
if
(vdot(Vb,
Fa.norm)
>
0)
then
RETURN
(Fa,
Fb,
dist(Fa,Fb))


else
close-feat-checkp
(find
-clos
est(F
b,
Fa.cobnd),Fb)
else
close-feat-check
p
(Fa,
find-closest(Fa,
Fb.cobnd))
else
close-feat-checkp
((closest-edges
(Fa,
Fb))
else
NBRa
=
closestToFplane(Fb,
Fa)
if
(type(NBRa)
=
VERTEX)
%%
check
if
NBRa
is
a
vertex
then
NBRb
=
point-face-checkp
(NBRa,
Fb)
if
(NBRb
=
NULL)
then
close-feat-check
p
(NBRa,
Fb)
else
sub-face-face(Fa
,
Fb)
else
if
(E-FPrism(NBRa,
Fb.cell))
then
if
(vdot(NBRa.H,
Fb.norm)
>
0)
then
close-feat-checkp
(NBRa,
Fb)
else
close-feat-checkp
(NBRa,
find-closest(NBRa,
Fb.cobnd))
else
sub-face-face(Fa
,
Fb)
%%%
Sub-Face-Face:
PROCEDURE
sub-face-face(Fa,
Fb)
NBRb
=
closestToFplane(Fa
,
Fb)
if
(type(NBRb)
=
VERTEX)
%%
Is
NBRb
a
vertex?
then
NBRa
=
point-face-checkp
(NBRb,
Fa)
if
(NBRa
=
NULL)
then
close-feat-checkp
(Fa,
NBRb)
else
close-feat-checkp
(closest-edges(
Fa,Fb
))
else
if
(E-FPrism(NBRb,
Fa.cell))
then
if
(vdot(NBRb.H,
Fa.norm)
>
0)
then
close-feat-check
p
(Fa,
NBRb)
else
close-feat-check
p
((find-closest(
NBRb,
Fa.cobnd),
NBRb)
else
close-feat-checkp
(closest-edges(
Fa,Fb
))
%%%
The
main
routine
PROCEDURE
close-feat-checkp
(feat,
feat)
case
(type(feat),
type(feat))
(VERTEX,
VERTEX)
RETURN
vertex-vertex(feat
,
feat)
(VERTEX,
EDGE)
RETURN
vertex-edge(feat,
feat)
(VERTEX,
FACE)
RETURN
vertex-face(feat,
feat)


(EDGE,
VERTEX)
RETURN
reverse(vertex-edg
e(fea
t,
feat)
(EDGE,
EDGE)
RETURN
edge-edge(feat,
feat)
(EDGE,
FACE)
RETURN
edge-face(feat
feat)
(FACE,
VERTEX)
RETURN
reverse(vertex-fac
e(fea
t,
feat))
(FACE,
EDGE)
RETURN
reverse(edge-face(
feat
,
feat))
(FACE,
FACE)
RETURN
face-face(feat,
feat)
%%
To
check
if
two
objects
collide
by
their
minimum
separation
if
(dist(feat,feat
)
~
0)
then
PRINT
("Collision")

