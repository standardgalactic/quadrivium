
Praise for Modeling Business Objects with XML Schema 
This is definitely the book I have been waiting for: one that bases the 
development of XML schemas on a sound methodology. There are no 
heuristics here. Modeling Business Objects with XML Schema is knowledgeable, 
well-founded, and always practice-oriented. The reader is presented with 
the entire functionality of XML Schema, and also with manageable solutions 
for when the barriers of this schema language are reached. Berthold Daum 
discusses Sumerian cuneiform, Asset Oriented Modeling, canonical XML, 
object language binding, and schema evolution with equal virtuosity, and 
in doing so he manages to have jazz trumpeter Miles Davis perform as an 
XML element. A must-read for every XML developer. 
---Roland B6ndgen, Program Manager, The XML Academy, 
Software AG 
Modeling Business Objects with XML Schema is an excellent resource for 
XML Schema authors who model and build enterprise class systems 
with XML. 
~Tom Marrs, J2EE/XML Architect, Distributed Computing 
Solutions, Inc. 
Modeling Business Objects with XML Schema is an informative book that 
effectively explains its subject by providing a meaningful perspective and 
enlightening examples. 
~Daniel Krech, Semantic Web Technologist, Eikco, LLC. 

This Page Intentionally Left Blank

Modeling Business Objects 
with XML Schema 

This Page Intentionally Left Blank

Modeling 
Business 
Objects 
with 
XML 
Schema 
BLRTHOLD DAUM 
M O R G A N  K A U F H A N N  P U B L I S H E R S  

Copublished by Morgan Kaufmann Publishers and dpunkt.verlag 
Morgan Kaufmann Publishers 
Senior Editor'. Tim Cox 
Publishing Services Managers: Edward Wade, 
Simon Crump 
Editorial Coordinator: Stacie Pierce 
Project Managers: Howard Severson, Kevin Sullivan 
Cover Design: Yvo 
Cover Image: I. Burgum and P. Boorman/Getty Images 
Text Design: Side by Side Studios 
Composition: TBH Typecast, Inc. 
Illustration: Dartmouth Publishing, Inc. 
Copyeditor: Judith Brown 
Proofreader: Jennifer McClain 
Indexer: Ty Koontz 
Interior Printer: The Maple-Vail Book Manufacturing Group 
Cover Printer: Phoenix Color 
dpunkt.verlag 
Senior Editor: Ren6 Sch6nfeldt 
Designations used by companies to distinguish their products are often claimed as 
trademarks or registered trademarks. In all instances in which Morgan Kaufmann 
Publishers is aware of a claim, the product names appear in initial capital or all capital 
letters. Readers, however, should contact the appropriate companies for more complete 
information regarding trademarks and registration. 
Morgan Kaufmann Publishers 
An Imprint of Elsevier Science 
340 Pine Street, Sixth Floor 
San Francisco, CA 94104-3205, USA 
http://www.mkp.com 
Available in Germany, Austria, and Switzerland from 
dpunkt.verlag GmbH 
Pdngstrafi, e 19b 
D-69115 Heidelberg, Germany 
http://www.dpunkt.de 
9 2003 by Elsevier Science (USA) and dpunkt.verlag GmbH (Germany) 
All fights reserved. 
Printed in the United States of America 
07 06 05 04 03 
S 4 3 2 1 
No part of this publication may be reproduced, stored in a retrieval system, or transmitted 
in any form or by any means--electronic, mechanical, photocopying, or otherwise-- 
without the prior written permission of the publisher. 
Library of Congress Control Number: 2003102703 
MK ISBN: 1-55860-816-8 
dpunkt ISBN: 3-89864-218-6 
This book is printed on acid-free paper. 

Contents 
Foreword xvii 
Acknowledgements xix 
Introduction 
xxi 
PART I 
1.1 
1.2 
1.3 
1.4 
1.5 
1.6 
1.7 
THE MODEL 
Foundations 
3 
A Core Concept 
4 
1.1.1 
Life Is a Document 
4 
1.1.2 
Scripture 
6 
1.1.3 
Other Forms of Documents 
7 
Linear Concepts 
8 
1.2.1 
Sequence 
8 
1.2.2 
Hierarchy 9 
Nonlinear Concepts 
11 
1.3.1 
Bags 11 
1.3.2 
Annotations 
12 
1.3.3 
Cross-References 
13 
Document-Centric vs. Data-Centric Content 
Document Schemata 
14 
1.5.1 
A First Schema 
15 
1.5.2 
Choice 23 
1.5.3 
Recursion 24 
Grammars 26 
1.6.1 
Formal Grammars 27 
1.6.2 
Backus-Naur-Form (BNF) 28 
1.6.3 
Regular Sets and Regular Expressions 
1.6.4 
Trees, Hedges, and Forests 31 
Regular Types 34 
1.7.1 
Types as Regular Expressions 
35 
1.7.2 
Basic Composition 
35 
1.7.3 
Basic Type Algebra 37 
14 
30 
vii 

viii 
Contents 
2 
2.1 
2.2 
2.3 
2.4 
2.5 
3 
3.1 
3.2 
3.3 
3.4 
3.5 
3.6 
3.7 
1.7.4 
1.7.5 
1.7.6 
Subtypes 38 
Generic Types 39 
Deterministic Types 39 
Conceptual Modeling 
41 
Motivation 
42 
Principles of Conceptual Modeling 43 
Entity Relationship Diagrams 44 
Reality of Conceptual Modeling 47 
Introducing Asset Oriented Modeling 48 
2.5.1 
AOM Basics 48 
2.5.2 
Assets 50 
2.5.3 
Arcs and Clusters 52 
2.5.4 
Properties 
53 
2.5.5 
Types 57 
2.5.6 
Inheritance 
60 
2.5.7 
Constraints 
62 
2.5.8 
Level 2 Structures 
62 
2.5.9 
Models and Namespaces 
66 
2.5.10 Summary 68 
Everybody Likes Jazz 71 
Informal Description 
72 
The Conceptual Model, First Draft 
Asset or Property? 
73 
3.3.1 
The Jazz Model 
74 
Normalization 
76 
Partitioned Normal Form 
78 
Resolving i s_a Relationships 
80 
Introducing Level 2 Structures 
81 
73 
PART II 
THE IMPLEMENTATION 
4 
XMLBasics 89 
4.1 
4.2 
Namespaces 90 
The XML Information Model 91 
4.2.1 
Overview 91 
4.2.2 
Document Node 93 
4.2.3 
Elements 95 

Contents 
Ix 
4.3 
4.4 
Attributes 
96 
Processing Instructions 97 
Unexpanded Entity Reference 
97 
Character 
97 
Comment 98 
Document Type Declaration 
98 
Canonical Text 
101 
Canonical Whitespace 
102 
Resolved References 
102 
Removal of Redundant Nodes 
103 
Canonical Elements 
104 
Canonical Attributes 
104 
Canonical Processing Instructions 
Canonical Comments 
105 
105 
4.2.4 
4.2.5 
4.2.6 
4.2.7 
4.2.8 
4.2.9 
4.2.10 Unparsed Entity 98 
4.2.11 
Notation 99 
4.2.12 Namespace 
99 
4.2.13 An Example 
100 
XML Canonical Form 
101 
4.3.1 
4.3.2 
4.3.3 
4.3.4 
4.3.5 
4.3.6 
4.3.7 
4.3.8 
105 
The Document Type Definition (DTD) 
4.4.1 
Document 
106 
4.4.2 
Elements 
107 
4.4.3 
Attributes 
109 
4.4.4 
Cross-References 
111 
4.4.5 
Extension Mechanisms 
111 
4.4.6 
Document Composition 
112 
4.4.7 
Schema Composition and Reuse Mechanisms 
4.4.8 
DTD Deficiencies 
114 
5 
XMLSchema 
117 
113 
5.1 
5.2 
An Appetizer 
118 
Simple Data Types 
5.2.1 
5.2.2 
5.2.3 
5.2.4 
5.2.5 
5.2.6 
5.2.7 
5.2.8 
5.2.9 
5.2.10 Union Types 
137 
5.2.11 
User-Defined Data Types 
120 
Value Space 
120 
Lexical Representations and Canonical Representation 
Fundamental Facets 
120 
120 
Built-in Primitive Data Types 
121 
Constructed Types 
127 
Extending Data Types by List 127 
Restricted Data Types 
128 
Built-in Constructed Data Types 
131 
The Hierarchy of Built-in Primitive and Constructed Data Types 
138 
136 

x 
Contents 
5.3 
Structure in XML Schema 
139 
5.3.1 
Hierarchy 139 
5.3.2 
Elements and Complex Types 141 
5.3.3 
Particles and Model Groups 
143 
5.3.4 
Cardinality Constraints 
149 
5.3.5 
Default Values and Fixed Values 
150 
5.3.6 
Mixed Content 
150 
5.3.7 
Simple Content 
152 
5.3.8 
Complex Content 
153 
5.3.9 
Type Hierarchies 
156 
5.3.10 Empty Elements 
156 
5.3.11 Attributes 
159 
5.3.12 Global and Local Types 
160 
5.3.13 Global Elements and Attributes 
161 
5.3.14 Recursive Structures 
162 
5.3.15 Wildcards 
168 
5.3.16 Nullability 
169 
5.3.17 Uniqueness, Keys, Reference 
170 
5.3.18 Deterministic Types 
176 
6 
Authoring XML Schema 
179 
6.1 
6.2 
6.3 
6.4 
Namespaces 
180 
6.1.1 
Target Namespace 
180 
6.1.2 
Qualified and Unqualified Names 
6.1.3 
Wildcards 
182 
6.1.4 
Schema Default Namespace 
183 
Reuse Mechanisms 
184 
6.2.1 
6.2.2 
6.2.3 
6.2.4 
6.2.5 
Schema Composition 
190 
Global Elements and Global Types 
Groups 
185 
Attribute Groups 
186 
Instance Type Overriding 
186 
Substitution Groups 
188 
6.3.1 
The Schema Clause 
6.3.2 
Locating Schemata 
6.3.3 
Include 
191 
6.3.4 
Redefine 
192 
6.3.5 
Import 
194 
6.3.6 
Notation 
195 
6.3.7 
Annotations 
195 
190 
191 
180 
184 
Usage Patterns 
196 
6.4.1 
Chameleon Components and Type Libraries 
197 
6.4.2 
Defining Schema Families 200 

Contents 
xi 
7 
RelaxNG 
215 
7.1 
7.2 
7.3 
Structure 
7.1.1 
7.1.2 
7.1.3 
7.1.4 
7.1.5 
7.1.6 
216 
The Relax NG Data Model 
216 
Elements and Attributes 
216 
Model Groups and Particles 
217 
Empty and notAllowed 223 
Annotations 
224 
Default and Fixed Values 225 
Types, Grammars, Patterns 
226 
7.2.1 
Data Types in Relax NG 226 
7.2.2 
Grammars and Named Patterns 
228 
7.2.3 
External Patterns and Grammars 233 
7.2.4 
Keys and Key References 240 
Namespaces and Name Classes 
241 
7.3.1 
Namespaces 
241 
7.3.2 
Name Classes and Wildcards 
243 
7.3.3 
Comparison with DTDs 246 
7.3.4 
Comparison with XML Schema 246 
7.3.5 
Tool Support for Relax NG 247 
8 
From Conceptual Model to Schema 
8.1 
8.2 
8.3 
A Knowledge Base 250 
8.1.1 
Jazz Musicians 
250 
8.1.2 
Styles 253 
8.1.3 
Collaborations 
253 
8.1.4 
Albums 254 
8.1.5 
Reviews 257 
8.1.6 
Critics 257 
Implementation in XML Schema 
8.2.1 
8.2.2 
8.2.3 
8.2.4 
8.2.5 
8.2.6 
8.2.7 
8.2.8 
8.2.9 
8.2.10 Business Objects critic and style 
Implementation in Relax NG 291 
8.3.1 
Creating a Type Library 291 
8.3.2 
Handling Inheritance 
292 
258 
Design Options 
258 
Business Objects 258 
Creating a Type Library 260 
Handling Inheritance 
262 
The Complete Type Library 265 
Implementing a Business Object 271 
Dealing with Cross-References 277 
Using Substitution Groups 280 
Implementing Clusters 284 
287 
249 

xll 
Contents 
8.4 
9 
9.1 
9.2 
9.3 
9.4 
9.5 
9.6 
8.3.3 
8.3.4 
8.3.5 
8.3.6 
8.3.7 
8.3.8 
The Complete Type Library 296 
Implementing a Business Object 304 
Dealing with Cross-References 308 
Resolving Multiple Display Labels 311 
Implementing Clusters 314 
Business Objects critic and style 
316 
Summary 318 
8.4.1 
Synopsis of Implementation Steps 318 
8.4.2 
Remarks 320 
Validation beyond XML Schema 
323 
About Meaning 324 
Constraints 324 
9.2.1 
Constraints in XML Schema 327 
9.2.2 
Constraints beyond XML Schema 330 
Constraints in Conceptual Models 337 
Validation of General Constraints 
341 
9.4.1 
Hard-Coded Constraint Checks 341 
9.4.2 
XSLT 344 
9.4.3 
Schematron 
348 
An XML Processing Model 
360 
A Framework for Schema Languages 362 
PART III THE ENVIRONMENT 
10 
10.1 
10.2 
10.3 
10.4 
Reality Check: The World Is Object-Oriented 
Object-Oriented Implementations of the XML Data Model 
Encapsulation and Behavior 367 
Class, Instance, Type 369 
10.3.1 
Class Hierarchies 369 
10.3.2 
Type Hierarchies Based on Behavior 369 
10.3.3 
Type Hierarchies Based on Syntax 370 
10.3.4 
Object-Oriented Types vs. XML Types 370 
Simple Types 373 
10.4.1 
10.4.2 
10.4.3 
10.4.4 
10.4.5 
10.4.6 
String Data Types 374 
Binary Data Types 374 
The Boolean Data Type 374 
Exact Numeric Types 374 
Approximate Numeric Types 375 
Date and Time 375 
365 
366 

Contents 
x|li 
10.5 
10.6 
10.7 
10.8 
10.9 
10.10 
10.11 
10.12 
11 
11.1 
11.2 
11.3 
11.4 
11.5 
11.6 
10.4.7 
Other Data Types 376 
10.4.8 
Type Restrictions 
376 
10.4.9 
Type Extensions 
376 
10.4.10 Null Values 376 
10.4.11 Implementing a Type Hierarchy 377 
Complex Types 377 
10.5.1 
Hierarchy 377 
10.5.2 
Sequence 
381 
10.5.3 
Repetition 
383 
10.5.4 
Choice 
384 
10.5.5 
Recursion 
385 
10.5.6 
Global and Local Elements 
386 
Global Types 387 
Inheritance 
388 
Polymorphism 
389 
Dynamic Marshaling 389 
Constraints 
390 
10.10.1 Simple Types 390 
10.10.2 Cross-References 391 
10.10.3 When to Check 391 
10.10.4 Conceptual Constraints 
391 
10.10.5 Automatic Code Generation 
392 
Identity 393 
Visibility 394 
Reality Check: The World Is Relational 
Motivation 
396 
Databases 
396 
The Relational Data Model 397 
The Relational Algebra 398 
Normalization 
401 
11.5.1 
Defining the Target Format 402 
11.5.2 
The Original Schema 403 
11.5.3 
Steamrolling the Schema 405 
11.5.4 
Introducing Key Relationships 
406 
11.5.5 
Preserving Sequential Order 410 
11.5.6 
Recomposing Original Document Nodes 
Brief Introduction to SQL 415 
11.6.1 
Queries 415 
11.6.2 
Table Creation 
418 
395 
414 

X|V 
Contents 
11.7 
11.8 
11.9 
11.10 
11.11 
12 
12.1 
12.2 
12.3 
12.4 
11.6.3 
Table Modification 
418 
11.6.4 
Views 419 
11.6.5 
SQL-99 419 
Simple Data Types 421 
11.7.1 
11.7.2 
11.7.3 
11.7.4 
11.7.5 
11.7.6 
11.7.7 
11.7.8 
11.7.9 
11.7.10 Null Values 
String Data Types 421 
Binary Data Types 422 
The Boolean Data Type 422 
Exact Numeric Types 422 
Approximate Numeric Types 
Date and Time 423 
Other Data Types 423 
Type Restrictions 
423 
Type Extensions 
424 
424 
422 
Complex Types 424 
11.8.1 
Hierarchy 424 
11.8.2 
Sequence 426 
11.8.3 
Choice 428 
11.8.4 
Recursion 430 
Constraints 
430 
From Relational Tables to XML Schema 431 
Mediation between RDBMS and XML Databases 433 
11.11.1 Tamino X-Node 433 
11.11.2 Experanto 444 
Schema Evolution 
Derived Types 446 
12.1.1 
12.1.2 
12.1.3 
12.1.4 
12.1.5 
445 
Schema-Conservative Evolution 446 
Using Chameleon Components 
447 
Creating Derived Schemata 450 
Dialecting with Substitution Groups 451 
Inhibiting Change 453 
Authoring for Redefinition 
454 
12.2.1 
Adding an Attribute to a Simple Type Element 455 
12.2.2 
Appending Child Nodes to Nested Structures 457 
12.2.3 
Inserting Elements at an Arbitrary Position 
459 
12.2.4 
Allowing Choices 461 
12.2.5 
Conservative Schema Modification 
464 
Open Content Model 
Versioning 467 
465 

Contents 
xv 
13 
13.1 
13.2 
14 
14.1 
14.2 
Schemata in Large Environments 
471 
Combining Diverse Schemata 472 
13.1.1 
The Problem 
472 
13.1.2 
Model Fusion 472 
13.1.3 
Combining Document Instance Sets 475 
13.1.4 
Schema-Driven View Definition 
479 
13.1.5 
Embedded Queries 480 
13.1.6 
Model-Driven Schema Mediation 
486 
Centralized and Decentralized Change Management 
487 
13.2.1 
Decentralized Change Management of Document Instances 488 
13.2.2 
Decentralized Change Management of Document Schemata 488 
Outlook 
491 
Integration of Core Technologies 
492 
Grammar-Driven Data Models 
492 
14.2.1 
XML as a Mainstream Technology 493 
Appendix 495 
Glossary 499 
Bibliography 503 
Index 507 
About the Author 
535 

This Page Intentionally Left Blank

Foreword 
Dave Hollander 
CTO, Contivo, Inc. 
Co-chair, W3C XML Schema Working Group 
"Too complicated! Way too much to learn! Nobody will understand this! Do we 
really have to implement this?" 
XML is simple--why are XML schemas so complex? 
In spite of early criticisms, World Wide Web Consortium (W3C) XML 
schemas have become an important part of our evolving information infra- 
structure. How important? Internet search engines can find over one quarter of 
a million documents that discuss XML schemas. Web Services, ebXML, OAGI, 
and most recent e-commerce specifications use W3C XML schemas. Vendors 
like BEA, IBM, Microsoft, Oracle, Sun, and a host of others have implemented 
schemas. In short, understanding XML Schema and its complexities has be- 
come essential for architects, developers, and managers who are building infor- 
mation-driven systems. 
To understand Schema's complexity, we have to look at its origins. In August 
of 1998, the group that developed XML gathered at the Metastructures 1998 & 
XML Developers Conference in Montreal to understand how the community at 
large was adopting our work. After the conference, 45 attendees gathered to 
outline how to continue what the XML 1.0 Recommendation had started. 
Schemas were one of the five work areas identified. Teams formed, chairs were 
nominated, and the effort began to formally charter working groups under the 
W3C. In November of 1998, we had our first meeting, gathering face-to-face in 
Chicago. 
XML is simple. It is simple because during its creation, we were able to rely 
on over 100 years of combined experience in the Standardized Generalized 
Markup Language (SGML). This shared experience helped us to establish the ten 
design goals that are listed at the beginning of the XML 1.0 Recommendation. 
We had a common understanding of these goals; for example, when we 
declared, "It shall be easy to write programs which process XML documents," 
we all meant that programmers should be able to write the basic code "over a 
holiday weekend." XML's simplicity is the direct result of asking ourselves, at 
nearly every meeting, "Is this necessary for success?" and using our shared expe- 
rience and goals to answer "No" as much as possible. 
XML schemas are complex. The W3C XML Schema Working Group did not 
have the benefit of a single, shared experience like SGML. The Working Group 
xvii 

xviit 
Foreword 
had to find a way to combine ideas and features from a wide variety of sources: 
Document Type Definitions (DTDs) from SGML; submissions to the W3C, 
including DDML, SOX, DCD, and XML-Data; and experience from other tech- 
nology areas such as object-oriented programming, databases, and UML. The 
Working Group members, whose experience ranged from database standards, to 
e-commerce, to the study of ancient manuscripts, all brought needs and 
requirements with them. 
For 30 months, the Working Group met 16 times face-to-face, held telecon- 
ferences once or twice a week, and formed dozens of task forces. We produced 
countless drafts and analyzed comments from thousands of reviewers. It 
became clear that we could not create a simple specification. This concerned the 
Working Group, yet we knew that it was important to finish our work and that 
others would fill in the gaps. In May of 2001 we released our three specifications 
and continued our work. As I write this, we are preparing the agenda for the 
23rd face-to-face meeting. 
Today, complaints continue, but at a much lower volume. Developers who 
are implementing schema-aware tools are filling one of the critical gaps. While 
these tools make it a lot easier for users of XML schemas, they cannot be 
expected to do all the work. Writing schemas is more than getting the syntax 
of XML Schema right. The schemas should be designed in such a way that the 
documents they describe are easy to author, update, and retrieve. They should 
be prepared for evolution and take into consideration corporate standards. 
In fact, XML and XML schemas are now taking the enterprise world by storm. 
Understanding how to leverage their abilities is essential to those who already 
use XML in fields such as the Web, content and knowledge management, and 
e-business. But it is equally important that experts in other technologies, such as 
object-oriented or relational technology, build their understanding of XML 
schemas. 
This book guides you through understanding schemas in a systematic way, 
from the basic conceptsmtype systems, type derivation, inheritance, and name- 
space handlingmthrough advanced concepts in schema design. The early chap- 
ters describe the problem domain that schemas address. They provide insight 
into the motivations behind schemas and the problems that they can solve. 
The middle of the book delivers detailed explanations and examples of how to 
use the myriad features available in XML Schema and compares these to other 
similar languages. These chapters illustrate the design issues that the Working 
Group faced and that schema designers will face. The final chapters put it all 
together and describe how schemas can be applied to real applications. 
Specifications such as the XML Schema Recommendations produced by the 
W3C Working Group must focus on defining technology and do not have the 
luxury of explaining motivation, design issues, and applications. This book fills 
that need admirably. 

Acknowledgements 
The production of a book is always teamwork, but the merits (or the blame) 
mostly go to the author whose name happens to be on the cover. So, the fol- 
lowing paragraphs not only express my deep-felt gratitude toward all the people 
that helped to bring this book into the world, but also serve the purpose of self- 
protection. 
In particular, if you are feeling uncomfortable with the book's content, don't 
blame me; blame the reviewers, Daniel Krech and Dave Hollander. Personally, I 
think they did a wonderful job and really helped to bring the book into shape. 
Especially enjoyable were my discussions with Dave about the intricacies of the 
XML Schema type system and the Unique Particle Attribution. There were also 
two anonymous reviewers who preferred to remain in the dark~probably for 
good reasons. So, this is also in honor of the Unknown Reviewer. 
The next ones to blame are the people at Morgan Kaufmann Publishers and 
dpunkt.verlag for giving me the opportunity to publish this work. Maybe they 
already regret it. Thanks go especially to Tim Cox and Stacie Pierce from Mor- 
gan Kaufmann, who patiently helped me through the materialization and pub- 
lication of the book, and to Ren6 Sch(~nfeldt from dpunkt. Production was 
managed at Morgan Kaufmann by Howard Severson initially, then later in the 
process by Kevin Sullivan, who took over from an already exhausted Howard. 
Copyediting and proofreading were done by Judith Brown and Jennifer 
McClain, respectively. They are the ones to blame for any problems with gram- 
mar and spelling. Authors are never responsible for these sorts of problems. 
They can adopt a rather liberal attitude to grammar and orthography. The 
copyeditors and proofreaders have to do all the hard work. I think they deserve 
a big hand. 
If you dislike the page layout, blame goes to the interior designer, Mark Ong 
at Side by Side Studios. I, in fact, like it a lot. My first reaction to the finished 
proofs was, "Wow, this really looks nice!" So, a big hand for Mark, and for Bill 
Turner at TBH Typecast, who did the typesetting. Thanks for that, Bill. 
Finally, big thanks--I think from all of us--go to you, the reader. (If you 
acquired this book by unlawful means, ignore this and don't read on.) By buy- 
ing this book, you made this production possible. And despite all the electronic 
gadgets I own, I still like making books. 
Berthold Daum 
berthold.daum@bdaum.de 
February 2003 
xix 

This Page Intentionally Left Blank

Introduction 
XML Schema is an industry standard. No, it did not become an industry stan- 
dard by gradual adoption--it was a standard defined under the direct collabora- 
tion of various IT industry groups such as middleware manufacturers and 
database manufacturers. In fact, it was adopted by the contributing industry 
groups long before the final recommendation was published, a fact that marks 
the transition of XML from a documentation language to a mainstream data 
definition language for the whole IT industry. 
XML Schema is the result of a political process. Different interests had to be 
negotiated, and the result is a compromise~a compromise that probably does 
not make everybody perfectly happy, but a compromise everybody can live 
with. The outcome of such a political process usually is complex in nature, and 
XML Schema is no different in that respect. Sure, some early concepts were 
dropped and the hierarchy of built-in types was streamlined in the final recom- 
mendation, but XML Schema is still a "fat" schema definition language by any 
standard. Just have a look at Figure 5.3 (page 140). 
Confused? Just wait until you have a look into the standard itself. It is not 
easy reading, by any means. The language is highly formal (a delight for math- 
ematicians), and the semantic network of definitions and constraints is very 
delicate. Getting into it requires time, effort, and patience. The XML Schema 
Primer [Fallside2001], which has been published as Part Zero of the recommen- 
dation, is, in contrast, much more accessible and serves as a first introduction 
into XML Schema authoring. 
In the meantime, most of the critical voices have ceased. The developers who 
have to implement validating parsers and schema editors are simply too busy to 
complain, and most users have calmed down now that the first XML 
Schema-aware schema editors have appeared on the market. Editors such as 
Altova's XML Spy (www.altova.com) and Tibco's TurboXML (www.tibco.com) have 
made working with XML Schema a lot easier. I, for example, have used XML 
Spy in the process of writing this book to validate the schemata and create the 
schema diagrams. 
None of the existing validators and editors was fully conforming to the XML 
Schema Recommendation at the time of writing; even the W3C's reference 
xxl 

xxil 
Introduction 
implementation XSV (XML Schema Validator) was incomplete in some points. 
This shows that the implementation of the standard is quite a project, indeed. 
By the time this book hits the bookshops, however, existing validators should 
be quite complete and standard conforming. Some recent validating parsers, 
such as Apache's Xerces 2.0.0, are already quite impressive. 
HOW THIS BOOK IS ORGANIZED 
This book does not start with XML Schema right away. I believe that the appear- 
ance of XML marks a major shift, a paradigm change in data models. The sim- 
ple data structures of the past such as relational tables or object-oriented-type 
hierarchies cannot satisfy the requirements of global computer networks, espe- 
cially not the requirements of application-to-application communication in 
electronic business. XML marks a shift toward data structures that are defined 
by grammars. In fact, XML is nothing but a language for defining grammars. We 
call such data models "grammar driven." 
Part I, "The Model," introduces therefore the mathematical foundations of 
grammars and document schemata. We begin the design of a related set of doc- 
ument schemata by defining a conceptual model, a practice that is well estab- 
lished among the database community, but is fairly uncommon among the 
documentation crowd. 
[] In Chapter 1, "Foundations," we introduce the basic concepts of document 
creation, beginning with some really ancient concepts. We then present the 
mathematical theory of regular sets, regular grammars, and regular types, 
which can serve as a solid foundation for most document types, in particular 
for XML documents. 
[] In Chapter 2, "Conceptual Modeling," we discuss Asset Oriented Modeling 
(AOM), a modeling method that is based on these theories and that produces 
models that can be easily transformed into XML schemata. We will also in- 
troduce our first example, the conceptual model of a simple bookshop. 
[] In Chapter 3, "Everybody Likes Jazz," we introduce the second major exam- 
ple, a knowledge base about jazz music and jazz musicians. This model will 
explain most principles of conceptual modeling and serve as a basis for later 
XML examples. 
Part II, "The Implementation," introduces XML Schema. We do not, how- 
ever, ignore what is going on beyond XML Schema. Although XML Schema has 
been adopted widely as the industry standard for schema definition, some crit- 
ical comments regarding XML Schema have resulted in the creation of a leaner 
schema language: Relax NG. During the course of this book we will compare 
the concepts of XML Schema with the concepts of Relax NG. This should allow 
a clearer understanding of the shortcomings and advantages of both schema 

Introduction 
xxlil 
languages. We will also have a look at a validation language with a different 
scope than XML Schema and Relax NG: Schematron. We are then going to 
implement the conceptual models developed in Part I using XML Schema and 
Relax NG. 
[] Chapter 4, "XML Basics," serves as a refresher for your XML knowledge. We 
discuss XML namespaces, the XML information set, the XML canonical 
form, and how to write Document Type Definitions (DTDs). We do not re- 
peat the basic XML syntaxmyou should already know where to put the angle 
brackets. 
[] Chapter 5, "XML Schema," discusses the XML Schema recommendation in 
detail. Starting from a very simple example, we move into the type system of 
XML Schema, discussing simple and complex types. 
[] Chapter 6, "Authoring XML Schema," discusses the namespace concept of 
XML Schema, as well as the possibilities for reuse and schema composition. 
Finally, we present some usage patterns, such as chameleon components, 
type substitution, and dangling types. 
[] In Chapter 7, "Relax NG," we introduce Relax NG as an alternate schema def- 
inition language and discuss the pros and cons of Relax NG compared to 
XML Schema. 
[] In Chapter 8, "From Conceptual Model to Schema," we translate our con- 
ceptual model from Chapter 2 (the bookshop) into XML Schema and Relax 
NG. This chapter serves as a longer example of implementation techniques 
with both schema languages. 
[] Chapter 9, "Validation beyond XML Schema," discusses alternate concepts 
for defining constraints on document types. We analyze which constraints 
can be defined with the means of XML Schema and for which constraints we 
have to look elsewhere. We show how to implement constraint validation 
with imperative programming, XSLT, or Schematron. 
In Part III, "The Environment," we discuss issues of schema design in large 
environments. XML Schema, in particular, was not primarily designed as an 
improved DTD for the SGML community but rather as a schema language to 
support the application of XML in new scenarios such as databases and ap- 
plication-to-application messaging. For example, there are close connections 
between XML Schema and SQL-99, and many concepts that existed already 
in SQL-99 were adopted, refined, and extended by XML Schema. Yet, object- 
oriented concepts such as type hierarchies are also found in XML Schema, so 
it makes sense to investigate how XML schemata can be mapped to object- 
oriented structures, and vice versa. 
[] In Chapter 10, "Reality Check: The World Is Object-Oriented," we compare 
the concepts of XML Schema with object-oriented concepts. We show how 
XML structures can be bound to object-oriented structures. 

xxiv 
Introduction 
m In Chapter 11, "Reality Check: The World Is Relational," we compare the 
concepts of XML Schema with relational concepts. We show how XML struc- 
tures can be mapped to relational structures and discuss two commercial 
implementations. 
m In Chapter 12, "Schema Evolution," we discuss schema evolution. We show 
how new schemata can be derived from existing schemata in a conservative 
manner, and how we can author schemata that are extensible and evolvable. 
m In Chapter 13, "Schemata in Large Environments," we discuss some tech- 
niques that allow the application of XML schemata in large environments, 
such as mediation and decentralized change management. We show how 
views across multiple schemata can be formulated, for example with XQuery. 
[] In Chapter 14, "Outlook," we draw some conclusions and argue that XML 
Schema has transformed XML from a niche technology into a mainstream 
technology. 
WHO SHOULD READ THIS BOOK? 
The first group of people who should read this book is, of course, schema 
designers. System architects, programmers, and document authors will also find 
useful information here. 
Because XML is taking the enterprise world by storm, people educated in 
other technologies, such as object-oriented technology or relational technology, 
will come in touch with XML. This can happen at any stage of application 
development, from conceptual modeling over schema design to implementa- 
tion. Understanding the basic concepts of XML Schemamtype system, type 
derivation, inheritance, namespace handling~is essential for any of those spe- 
cialists. This book covers all the necessary steps. For two examples, we first 
develop a conceptual model and then derive XML schemata from those models. 
Database administrators especially will have increasing exposure to XML and 
XML Schema. For these persons, the book will provide insight into the concepts 
of XML Schema and how it can be mapped to relational structures. 
Application programmers will also find some helpful information. We dis- 
cuss how the inheritance hierarchies in object-oriented languages correlate with 
the type hierarchies in XML Schema, and we develop a methodology to gener- 
ate language bindings from XML schemata. 
WHAT ARE THE PREREQUISITES? 
Basic knowledge of XML--especially of the XML syntaxmis required. If you are 
new to XML, you will find The XML Handbook by Charles Goldfarb and Paul 
Prescod [Goldfarb2000] a good introduction. 

Introduction 
XXV 
In Chapter 9 especially, you will need some knowledge of XSLT. Michael 
Kay's XSLT Programmer's Reference [Kay2001] is an excellent introduction to 
XSLT. 
Chapter 10 will be easier to read if you already have basic knowledge 
of object-oriented concepts. There is a wide range of literature about these 
topics, including Bertrand Meyer's Object-Oriented Software Construction [Meyer 
1997], and the less voluminous An Introduction to Object-Oriented Programming 
[Budd1997]. 
Similarly, Chapter 11 will be easier if you already have an understanding 
of relational concepts. Database System Concepts, by Abraham Silberschatz, 
Henry F. Korth, and S. Sudarshan [Silberschatz2001], for example, is a good and 
comprehensive introduction into that topic. 

This Page Intentionally Left Blank

Modeling Business Objects 
with XML Schema 

This Page Intentionally Left Blank


This Page Intentionally Left Blank

1.1 
1.2 
1.3 
1.4 
1.5 
1.6 
1.7 
A Core Concept 
Linear Concepts 
Nonlinear Concepts 
Document-Centric vs. 
Data-Centric Content 
Document Schemata 
Grammars 
Regular Types 
fter a browse through the history of documentation and 
scripture, this chapter discusses some basic concepts that 
determine the structure of documents. We then turn to schema 
definition and give a first glimpse of the three schema languages 
featured in this book: DTD, XML Schema, and Relax NG. 
Beginning with Section 1.6, the chapter becomes somewhat 
mathematical. Readers with an aversion to mathematics may 
skip the rest of the chapter. Those of you who stick with it will 
gain a better understanding of how schema languages are con- 
structed and used. First, we discover that schema definition is 
closely related to the mathematical discipline of formal lan- 
guages and that each schema definition (or most of it) can be 
expressed with a grammar. 
Regular expressions are a popular method for constraining 
string expressions. The marriage of regular expressions with 
grammars results in the definition of regular languages that 
form a solid basis for the definition of XML schemata. Finally, we 
extend this calculus to the definition of data types, an important 
aspect when we consider that XML, programming languages, 
and database technology increasingly grow together. 

4 
Chapter 1 Foundations 
1.1 A CORE CONCEPT 
The document metaphor seems to be a core concept in business, administra- 
tion, science, and information technology. The following sections give a brief 
overview of its historical development, and how this metaphor has been gener- 
alized today into a more abstract concept. 
1.1.1 Life Is a Document 
It seems that in modern societies the document is more important than what 
the document is about. A person, for example, only exists in the view of insti- 
tutions and state officials if there are documents that certify the existence of 
that very person. A person who cannot produce documents certifying her 
nationality would be regarded as stateless. A person without "papers" does not 
have an official identity. 
The same applies to business: Although a legally binding business contract 
can be established by the shaking of hands, it is common practice to put such a 
business contract in writing. Basically every exchange of goods, services, and 
money is accompanied by documents: purchase orders, bills of material, general 
ledger, invoices, receipts, and so on. A whole industry sector is dedicated to pro- 
ducing and consuming documents. While blue,collar workers are mainly 
responsible for the production of industrial goods, the task of white-collar 
workers is to produce and consume documents. 
Documents are also all important in science. They are used to communicate 
scientific results between scientists, and scientific study--apart from experimen- 
tal work and field study--consists mainly of studying documents. The reputa- 
tion of a scientist is measured by how many documents this scientist has 
published, and how often these documents are referenced in documents pro- 
duced by other scientists. This is important for designers of documentation sys- 
tems: The easier a system makes cross-referencing, the more likely it will be 
adopted by the scientific community. 
More and more we find the document metaphor at the core of the infra- 
structure of large IT systems, not only because the authoring, managing, and 
retrieval of documents is an important application area, but also because soft- 
ware components are becoming more and more complex. In the early days of 
programming with assembler or FORTRAN, subroutines were simple constructs 
that could easily be controlled with simple parameters: plain integers, floating- 
point numbers, strings, and addresses. Today, reusable software components 
can be huge and highly complex modules, controlled via similarly complex 
interfaces. Take, for example, a web service. The protocol of a web service is 
described with a language called WSDL (Web Service Description Language) 
[Christensen2001], and the syntax of messages passed to a web service can be 
described with the language XML Protocol [Williams2001], formerly called 
SOAP. 

1.1 A Core Concept 
$ 
The following example shows how a purchase order could be serialized in 
XML. This document could be sent to a shopping system that would execute 
the order. 
<?xml version="1.0" encoding="UTF-8"?> 
<order orderNo="NILE01709" orderDate="04/23/2002"> 
<customer customerNo=" BD023432"> 
<name> 
<firs t>J ohn</firs t> 
<l ast>Doe</l ast> 
</name> 
<address> 
<street>747 Sunset Strip</street> 
<town>Mi ami </town> 
<zi p>99999</z i p> 
<state>FL</state> 
<country>USA</country> 
</address> 
</customer> 
<orderltem amount="1"> 
<CD productNo="9488149012" year="1999"> 
<title>suite africaine</titl e> 
<publ i sher>harmoni a mundi</publ i sher> 
<contri butor ki nd="performer">Romano</contri butor> 
<contri butor ki nd="performer">Scl avi s</contri butor> 
<contri butor ki nd="performer">Texi er</contri butor> 
<contri butor ki nd="performer">Le Querrec</contri butor> 
</CD> 
</orderItem> 
<orderltem amount="1"> 
<book ISBN="0140053972" year="1977"> 
<title>On Photography</ti tl e> 
<publ i sher>Pengui n</publ i sher> 
<author>Susan Sontag</author> 
<pri ce>19.95</pri ce> 
</book> 
</orderltem> 
</order> 

6 
Chapter~l Foundations 
Because this message is formulated in a well-established document standard, 
it can be checked for valid syntax before it is passed to the executing software 
component, provided the syntax has been described in a document schema. We 
come to this shortly. 
By using document standards and document technology in core areas of the 
IT infrastructure such as databases and messaging, the IT industry can draw on 
almost 9,000 years of human experience. Join me for a quick tour through 
ancient information processing. 
1.1.2 Scripture 
In common understanding the concept of documents is intrinsically linked 
with the concept of scripture. However, there are also other forms of docu- 
ments, which will be discussed in the next section. 
The advent of writing systems dates back 9,000 years and seems to coincide 
with the transition from hunter-gatherer societies to more agrarian societies. 
The first evidence of writing systems appeared in stones with incisions, which 
were used as counting tokens, probably to count property such as land, ani- 
mals, or measures of grain (see Figure 1.1.) 
Writing in the form of pictographs (see Figure 1.2) appeared between 4100 
and 3800 B.C. in the Sumerian culture, in Mesopotamia (Iraq). These picto- 
graphs represented concepts such as hand, sun, woman, head. Stylized picto- 
graphs--impressed in clay with a wedge-shaped stylusmbecame the script 
known as cuneiform, as shown in Figure 1.3. 
Similar to the Sumerian script, Chinese script is based on pictographs. How- 
ever, it is not known whether Chinese script was influenced by Sumerian script 
or vice versa. The first recorded Chinese pictographs date back to 2500 B.C., and 
a full writing system was developed by the nineteenth century B.C. (In the pro- 

1.1 A Core Concept 
7 
cess, the Chinese also invented paper.) These pictographs underwent a gradual 
stylization into the well-known "square characters." Since pictographs can only 
express "real-world" concepts, combinations of pictographs were introduced to 
express abstract ideas. To a certain extent, characters for phonetic sounds were 
also introduced. Chinese script was adopted by other Asian countries, and in 
the fourth century B.C. the Japanese developed their script from Korean and 
Chinese. 
Near the end of the fourth millennium B.C., the Egyptian culture introduced 
the concept of sound. Pictographs-hieroglyphsmrepresented syllables. Hiero- 
glyphs (see Figure 1.4), however, only represented consonants, not vowels. They 
were used to represent the first sound in the word depicted by the pictograph, a 
concept called acrophony. The same concept is found in Phoenician script, 
which influenced Aramaic, Hebrew, and Greek script. It was up to the Greeks 
(about 800 B.C.) to represent vowels with letters and basically to invent our 
modern alphabet. The Greek alphabet led to Latin (see Figure 1.5) and Cyrillic, 
while Aramaic led to Arabic and most of the scripts used in India. 
Figure 1.5 Phoenician, early Greek, and Roman alphabets (fonts courtesy of 
Jack Kilmon). 
1.1.3 Other Forms of Documents 
Long before scripture drawings and painting were used in documents, there 
were cave paintings dating to 25,000 B.C. Whether these paintings were used as 
documents or were purely decorative we don't know. But it seems probable that 
such paintings had a documentation purpose, maybe for teaching. Hunter- 
gatherer societies also had a requirement for records. We know, for example, 
that the X-ray drawings by Australian Aborigines--made on tree bark or in the 
sand--served to distribute the result of a hunt among relatives. 

8 
Chapter 1 Foundations 
However, hunter-gatherers and nomadic societies had a problem with tangi- 
ble documents: They would have to carry them around. So, these societies used 
a different form of documentation: information encoded into songs and tales 
that could be transmitted orally. While these nontangible formats have not 
always been regarded as documents, our digital age widens our understanding 
of what is a document. Digital documents are nontangible, too--not bound to 
a particular material manifestation. We recognize document formats that 
include media other than writing or drawing, such as images, voice, sound, or 
video clips. They may not necessarily be persistent and may exist only during a 
limited, possibly short, time span, such as messages between middleware com- 
ponents, SMS messages, or traffic jam notifications to a car's navigation system. 
In this sense we can define a document as an artifact with the purpose of con- 
veying information. And in this book, we deal predominantly with documents 
based on script. 
1.2 LINEAR CONCEPTS 
Before we look into document schemata in detail, let's first investigate which 
principles guide the organization of document instances. This will help to 
explain the purpose of certain schema language constructs, such as the ch0i ce 
or sequence operators in XML Schema. 
1.2.1 Sequence 
It is in the very nature of script that text is ordered in a sequential fashion. 
Unlike images or drawings, which leave the initiative to the eye of the reader, 
script leads the reader along a narrative. This has been the case from the begin- 
ning of writing, when pictographs were set one after each other (see Figure 1.6). 
The direction of writing varies from culture to culture: Western scripts (even 
Klingon) run from left to right, Hebrew and Arabic run from right to left, and 
Chinese script (and scripts derived from Chinese) run from top to bottom. 
The sequential organization of documents results from the fact that script is 
the manifestation of speech. Speech happens in time, which establishes a nat- 
ural order between the spoken words. Sequential organization of text is essen- 
tial to support the text's narrative. 
However, there are also cases where sequence establishes an order of a higher 
kind. Consider, for example, an encyclopedia or dictionary. The sequence of 
topics in an encyclopedia does not support a narrative because there is no nar- 
rative that runs across topics. Here, a sequence of topics is established to make 
navigation easy. Because the topics are ordered alphabetically we know that we 
can find the topic saxophone between the topics saw and say. 

1.2 Linear Concepts 
9 
Figure 1.6 Four proverbs in Sumerian cuneiform. The sequential pattern of 
each proverb is clearly visible. 
The following piece of code shows an XML description of a jazz album listing 
the tracks in sequential order. The position of the track nodes within the album 
node defines an order relationship between the track nodes. 
<a I bum> 
<title>The Koeln Concert</title> 
<track><ti tl e>Part l</ti tl e></track> 
<track><ti tl e>Part I la</ti tl e></track> 
<track><ti tl e>Part I Ib</ti tl e></track> 
</album> 
1.2.2 Hierarchy 
The concept of hierarchy, too, is older than the art of writing. Poems and songs, 
for example, are structured into stanzas and verses, so there is a relationship 
between the part and the whole. This structuring of information is necessary for 
various reasons. There are physical reasons: A singer may run out of breath 
when a verse is too long, a story may be too long to be told during an evening, 
or an output buffer may be too small to hold the whole message. Early business 
applications, for example, had to restrict the physical length of messages to 80 
bytes, a format inherited from punched card technology. There are also reasons 
caused by perception: The human short-term memory can only hold a limited 
amount of information. Structuring information into groups of smaller units 
makes it easier for the listener or reader to process that information. 

] 0 
Chapter 1 Foundations 
Figure 1.7 Sequence and hierarchy. 
Any structure of a linear text sequence can be easily transformed into a hier- 
archy. Text elements are structured into groups, these form larger groups, and 
this process can be repeated until only a single group exists. As shown in Figure 
1.7, such hierarchical group structures do have a 1:1 mapping to tree structures. 
Tree structures are the dominant structuring principle for text documents, and 
as we have already seen in Section 1.1.1, XML supports this concept by allowing 
us to decorate each tree node with a tag. 
The following listing of the marked-up description of Carla Bley's Escalator 
over the Hill exhibits a clear hierarchical structure: title and track elements 
are child nodes of a l bum. The track elements, in turn, consist of child elements 
title and duration. 
<al bum> 
<title>Escalator over the hill</title> 
<track> 
<title>Hotel Overture</ti tl e> 
<durat i on>PTM13S 12</du rat i on> 
</track> 
<track> 
<title>This is here...</title> 
<durati on>PTM6</durati on> 
</track> 
<track> 
<title>Like animal s</title> 
<durati on>PTMiS20</durati on> 
</track> 
</album> 

1.3 Nonlinear Concepts 
] ] 
1.3 NONLINEAR CONCEPTS 
Sequential order is certainly the dominating principle for the arrangement of 
text elements within a document. However, there are many cases where it is 
not possible to establish a clear sequential order. This means that different 
readers might read the text elements in a different sequence (and different 
authors would place text elements differently in the document layout). Addi- 
tional navigational concepts are required to help the reader move around 
within the document. 
1.3.1 Bags 
Take for example the Sumerian cuneiform from Figure 1.6. While the narrative 
of the proverb defines the sequential order of each proverb, the order in which 
the proverbs are arranged on the document is not obvious. In fact, the order in 
which these proverbs are arranged probably did not matter at all. Or, the author 
might have placed the proverb that was most important to him at the top. But 
that is a subjective decision. 
We find the same situation in our modern newspapers. Articles in a news- 
paper are not arranged in a strict logical order. The most important news is 
placed on the front page (although for many readers it is debatable what is 
most important), while the rest of the articles are grouped along themes into 
several sections: politics, business, regional, cultural, sports. Within these sec- 
tions the arrangement of articles on a page is more a matter of aesthetics and 
perception than logic: The page must look well balanced, and in Western cul- 
tures the articles considered important are positioned at the top, while more 
obscure topics vanish in the corners at the bottom. 
In software systems we sometimes have to use a prescribed sequence of ele- 
ments, especially if these elements are not identified within a message. A Java 
message call, for example, requires the parameters to be in the same order as in 
the definition of the method. Other systems that identify parameters by names 
may allow varying sequences of parameters. For example, in XML-RPC, param- 
eters are represented without parameter names--parameters are identified by 
position only. SOAP, which evolved from XML-RPC, identifies parameters by 
their names, so sequence does not matter. 
We call collections of items for which a clear logical order cannot be estab- 
lished, or is not required, a bag. The following two XML representations for a 
jazz performance are equally valid: It does not matter if we give the location 
first or if we give the time first. 
<performedAt> 
<location>Dixie Park</l ocation> 
<time>1910-O3-27T17:15 :O0</time> 
</performedAt> 

12 
Chapter 1 Foundations 
<performedAt> 
<time>1910-03-27T17:15 :O0</time> 
<l ocat i on>Di xi e Park</l ocat i on> 
</performedAt> 
1.3.2 Annotations 
Some texts have more footnotes than regular text. The purpose of a footnote is 
to introduce a new aspect or an additional explanation or example without dis- 
rupting the main narrative. 1 But footnotes are only one possible form of anno- 
tation; there are many others such as margin notes, sidebars, or help texts. 
Margin notes act as entry points into a text. Readers can quickly scan the mar- 
gins for a topic of interest and, if found, continue to read about this topic in the 
text. Margin notes support nonlinear reading: Readers are not forced to read 
through the text until they get to the point of interest, but can easily skip text 
areas. 
Sidebars are used to place background information or elements of entertain- 
ment into separate text units without disrupting the main narrative. Take for 
example the description of a route in a travel guide. Readers would expect the 
main narrative to help them organize the trip along that route. Background 
information embedded in the text, such as a fairy tale from that region or an 
article about the regional flora and fauna, would disturb readers in their effort 
to organize the trip. So, it is better to place this information in a visually sepa- 
rated sidebar. 
Help texts assist readers in performing a certain task. Usually, these texts are 
kept out of sight. Readers who already know how to perform the given task 
do not have to scan through the sometimes-extensive help texts. Readers who 
need assistance can navigate to these help texts in order to get the necessary 
instructions. A typical application for help texts is computer software, but 
printed documents also come with help texts. Take for example the tax form. 
The instructions on how to fill out the form are usually printed on a separate 
sheet or on the back of the main document. To establish a relation between 
the single elements of the main document and specific help texts, cross- 
referencing techniques are used. For example, the elements on the main docu- 
ment are numbered and so are the help instructions, so that they can be easily 
located. 
1. Too many footnotes indicate a bad writing style and document the author's inability 
to get a clear understanding of the inner logic of his material. 

1.3 Nonlinear Concepts 
13 
1.3.3 Cross-References 
Annotations introduce a variation into the concept of sequence, but they never 
question the main narrative. After reading a footnote or a sidebar, the reader 
continues with the main text. Cross-references are different in that respect. A 
cross-reference points to a remote text element from which the reader may or 
may not return. Texts that are extensively cross-referenced establish--besides 
the main narrative given by the text sequence--a multitude of alternate narra- 
tives given by the different paths that follow sequences of cross-references. 
The concept of cross-references has led to the development of the hypertext 
metaphor. This goes back to 1945 when Vannevar Bush postulated the idea of 
associative indexing in the article "As We May Think" [Bush1945]. Ted Nelson 
coined the term hypertext in an article published in Literary Machines: 
By "hypertext" (we) mean non-sequential writing--text that branches and al- 
lows choice to the reader, best read at an interactive screen. [Nelson1982] 
While cross-references within a document can add to the consistency of a 
document because they can relate the different parts of a document to each 
other, cross-references between different documents can become disturbing to 
the reader. "Lost in hyperspace" is a common buzz phrase that describes the loss 
of orientation when readers follow hyperlinks from document to document. 
Unlike the previously discussed nonlinear concepts (bags and annotations), 
cross-references cannot be modeled as a tree. For bags and annotations this is 
still possible by allowing tree nodes to contain unordered sets of child nodes. 
Cross-references, in contrast, completely ignore the concept of hierarchy. To 
describe cross-references formally, other concepts must be understood, such as 
node-and-arc models or primary/foreign keys. Cross-referencing allows for arbi- 
trarily complex document structures. And so, it is possible, for example, to seri- 
alize the content of a relational database into a single document where the 
relations between the database tables are kept as cross-references. 
The following piece of XML shows a cross-reference from a child element 
sample to a child element track: The node sample specifies in attribute trackRef a 
reference to the trackNo attributes of track nodes. 
<a I bum> 
<title>The Koeln Concert</title> 
<track trackNo="tl"><title>Part l</title></track> 
<track trackNo="t2"><title>Part lla</title></track>> 
<track trackNo="t3"><ti tl e>Part I Ib</ti tl e></track> 
<sample trackRef="t2"> 
http://www, ni I e. com/cds/mp3/koel nConcert/part2 .mp3 
</sample> 
</album> 

14 
Chapter 1 Foundations 
1.4 DOCUMENT-CENTRIC VS. DATA-CENTRIC CONTENT 
This brings us to two juxtaposed document concepts, which are discussed in the 
SGML and XML communities under the names document-centric content 
model and data-centric content model. (I am not perfectly happy with this 
wording: "Document-centric document" sounds a bit like "humane human.") 
The previous section already gave an example of a data-centric document: A 
relational database, for example, can be seen as a data-centric document. But 
there are simpler examples for data-centric documents: the phone book, com- 
pany directories, index cards, and punched cards. 
Now, what differentiates a document-centric document from a data-centric 
document? Apart from presentation issues, the main difference is that 
document-centric content follows a narrative, but data-centric content does 
not. This implies that the sequence of document elements in a data-centric doc- 
ument is not determined by a narrative but by logical criteria: The entries in a 
phone book, for example, are ordered lexically by name. In a relational database 
table the table entries are not ordered at all; they can be retrieved in any order 
as requested by the user. 
Of course, these two document forms are not mutually exclusive. Document- 
centric documents may contain data-centric parts, and vice versa. For example, 
a product description that follows a narrative may contain a (data-centric) table 
that lists the product features, and a data-centric document such as a product 
catalog may contain descriptive elements (mini-narratives) within each product 
entry. 
Historically, data-centric documents are as old as document-centric docu- 
ments, probably older. Script was invented to record information, not to write 
novels. The earliest documents we know (the incision stones shown in Figure 
1.1) seem to be data-centric. But perhaps these stones were placed in sequence 
to tell a story. Who knows? 
1.5 DOCUMENT SCHEMATA 
Document schemata define document types by defining constraints on the docu- 
ment structure and document content. We say that a document instance that 
complies with a given document schema belongs to the document type defined 
by this document schema. We call two document schema definitions equivalent 
when both define the same document type; that is, when the set of valid docu- 
ments described by each schema is identical. 
While constraints on the document content affect the semantics of a docu- 
ment, constraints on the document structure can be regarded as syntactical 
constraints. In Section 1.6 we will see that structural constraints can be well 
described with the help of formal grammars. A document instance can thus be 

1.5 Document Schemata 
l $ 
regarded as a sentence of some formal language. Since the theory of formal lan- 
guages is a well-studied and generally well understood discipline, we can gain 
substantially from this approach. But before we start to explore the fundamen- 
tals of grammars, let's first look at three document schemata that actually define 
the same document type. 
1.5.1 A First Schema 
The following three listings serve as a first look at the three schema languages 
used in this book: DTD, XML Schema, and Relax NG. All three listings define 
the same document type. The purchase order shown in Section 1.1.1 is a valid 
instance of this document type. Of course, there exist many other schema lan- 
guages, such as DSD, SOX, TREX, and XDR, but DTD, XML Schema, and Relax 
NG are currently the most relevant schema languages. 
[] XML DTD was introduced with the XML 1.0 specification [Bray2000]. 
[] XML Schema became a W3C recommendation by May 2, 2001 [Fallside- 
2001], [Thompson2001], [Biron2001]. 
[] Relax NG was published by the Organization for the Advancement of Struc- 
tured Information Standards (OASIS) on December 3, 2001 [Clark2001], 
[Murata2001]. 
These first examples introduce the three schema languages and give a first 
impression of the code. You need not understand these schemata in every detail 
yet, as the three schema languages will be covered in Chapters 4, 5, 6, and 7. 
During the course of this book, schemata will be presented in all three 
schema languages. Note that these schema languages are not mutually exclu- 
sive. It is possible--and sometimes necessary--to define both a DTD and a 
schema in another schema language such as XML Schema or Relax NG. DTDs 
don't provide a rich type system and have no narnespace support. XML 
Schema, on the other hand, does not provide means to specify document com- 
position, and with Relax NG, it is not possible to define default and fixed values 
for elements and attributes. So, sometimes it is necessary to combine. 
DTD 
We'll start with the DTD version of the purchase order document. 
<?xml version="1.0" encoding="UTF-8"?> 
<!ELEMENT order (customer, orderltem+)> 
<!ATTLIST order 
orderNo CDATA #REQUIRED 
orderDate CDATA #IMPLIED 

116 
Chapter 1 Foundations 
<!ELEMENT customer (name, address)> 
<!ATTLIST customer 
customerNo CDATA #REQUIRED 
<!ELEMENT orderltem (CD ] book)> 
<!ATTLIST orderltem 
amount CDATA #REQUIRED 
<!ELEMENT name (first, middle?, last)> 
<!ELEMENT address (street, town, zip, state, country?)+> 
<!ELEMENT CD (title, publisher, contributor*,price)> 
<!ATTLIST CD 
productNo CDATA #REQUIRED 
year CDATA #IMPLIED 
<!ELEMENT book (title, publisher, author*, price)> 
<!ATTLIST book 
ISBN CDATA #REQUIRED 
year CDATA #IMPLIED 
<!ELEMENT first (#PCDATA)> 
<!ELEMENT middle (#PCDATA)> 
<!ELEMENT last (#PCDATA)> 
<!ELEMENT street (#PCDATA)> 
<!ELEMENT town (#PCDATA)> 
<!ELEMENT zip (#PCDATA)> 
<!ELEMENT state (#PCDATA)> 
<!ELEMENT country (#PCDATA)> 
<!ELEMENT title (#PCDATA)> 
<!ELEMENT contributor (#PCDATA)> 
<!ELEMENT price (#PCDATA)> 
<!ATTLIST contributor 
kind CDATA #REQUIRED 
<!ELEMENT publisher (#PCDATA)> 
<!ELEMENT author (#PCDATA)> 

1.5 Document Schemata 
17 
Readers fluent in XML will have no trouble interpreting this schema. The 
element order is made up of the elements customer and orderltem. Element cus- 
tomer is required exactly once, while orderltem can have one or several occur- 
rences, indicated by the + modifier. In addition, the element order must have 
the attribute orderNo and may have the attribute orderDate. Similarly, the other 
elements are described in the same way, until the whole document tree is cov- 
ered. The leaf elements of this treemthe elements first, middl e, last, etc.---con- 
tain character data, indicated by #PCDATA. Interesting, too, is the definition 
of the element order Item that consists of a choice of the elements CD and book. 
We will discuss choices in more detail in the next section. DTDs are covered in 
Section 4.4. 
XIVIL Schema 
The next listing shows the same schema formulated with XML Schema. In fact, 
the DTD in the previous listing was generated from the schema shown here 
with the help of a commercial tool (XML Spy). 
<?xml version="1.0" encoding="UTF-8"?> 
<xs : schema xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
el ementFormDefaul t="qual i fled" attri buteFormDefaul t="unqual i Bed"> 
<xs :el ement name="order"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name=" customer"> 
<xs: compl exType> 
<xs: sequence> 
<xs: e I emen t name = "n ame" > 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="first '' type="xs:string"/> 
<xs:element name="middle" type="xs:string" 
mi nOccurs="O"/> 
<xs:element name="last" type="xs:string"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs: el ement name =''addreSs'' maxOccurs="unbounded"> 
<xs: compl exType> 
<xs:sequence> 

118 
Chapter 1 Foundations 
<xs:element name:"street" type="xs:string"/> 
<xs: el ement name="town" type="xs: string"/> 
<xs:element name="zip" type="xs:string"/> 
<xs: el ement name="state" type="xs: stri ng"/> 
<xs: el ement name:"country" type="xs :stri ng" 
mi nOccurs="O"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 
<xs:attribute name="customerNo" use="required"/> 
</xs: compl exType> 
</xs:el ement> 
<xs :el ement name="orderltem" maxOccurs="unbounded"> 
<xs: compl exType> 
<xs: choice> 
<xs: el ement name="CD"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement ref="ti tl e"/> 
<xs:element ref:"publ isher"/> 
<xs:element name="contributor" minOccurs="O" 
maxOccurs=" unbounded"> 
<xs: compl exType> 
<xs: s impl eContent> 
<xs :extension base="xs :string"> 
<xs:attribute name="kind" use="required"/> 
</xs :extension> 
</xs: simpl eContent> 
</xs: compl exType> 
</xs: el ement> 
<xs:element name="price" type="xs:decimal"/> 
</xs: sequence> 
<xs:attribute name="productNo" use="required"/> 
<xs:attribute name="year" use="optional"/> 
</xs: compl exType> 

1.5 Document Schemata 
19 
</xs : el ement> 
<xs :el ement name="book"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement ref="titl e"/> 
<xs:element ref="publ isher"/> 
<xs: el ement name=" author" type="xs: string" 
mi nOccurs="O" maxOccurs="unbounded"/> 
<xs:element name="price" type="xs:decimal"/> 
</xs :sequence> 
<xs :attri bute name=" ISBN" use="requi red"/> 
<xs:attribute name="year" use="optional"/> 
</xs: compl exType> 
</xs : el ement> 
</xs :choice> 
<xs: attribute name=" amount" use="requi red"/> 
</xs : comp I exType> 
</xs :el ement> 
</xs: sequence> 
<xs :attri bute name="orderNo" use="requi red"/> 
<xs: attri bute name="orderDate"/> 
</xs :compl exType> 
</xs :el ement> 
<xs:element name="title" type="xs:string"/> 
<xs:element name="publisher" type="xs:string"/> 
</xs: schema> 
This looks quite different. One reason is that XML Schema uses the XML syn- 
tax itself. XML Schema is a bit more verbose than a DTD: Cardinality con- 
straints, for example, are spelled out as mi n0ccurs and max0ccurs instead of using 
the cryptic, albeit convenient, DTD notations ?,*, and +. The same is true for 
the choice clause, which replaces the "1" compositor, and the sequence clause, 
which replaces the "," compositor. 
The other main difference is that the structure of a schema formulated with 
XML Schema exhibits the same hierarchy as the later document instances: Ele- 
ments that are nested into other elements are nested into those elements in the 
schema definition, too. This allows for defining elements with a local scope. In 
DTDs, in contrast, all element definitions have a global scope. 

20 
Chapter I 
Foundations 
In this listing we have defined three elements with a global scope: the root 
element order, and the elements title and publisher that are reused in different 
places. Within the hierarchy, these elements are referred to by the clauses 
ref="ti tl e" and ref="publ i sher". 
Of course, in XML Schema we could define title and publisher locally, too. 
This would allow us, for example, to use pub l i sher elements with a different lay- 
out for CDs and books. In contrast, such a schema could not be represented as a 
DTD because all elements are declared globally. In a DTD we would have to 
rename the publ i sher element as book-publ i sher and as CD-publ i sher to cater to 
differing element structures. This is not always desirable, so this example dem- 
onstrates a clear advantage of XML Schema over DTDs. Chapters 5 and 6 will 
discuss XML Schema in its full glory. 
Relax NG 
Finally, here is the same document type defined in Relax NG: 
<?xml version="1.0"?> 
<grammar ns="" xmlns="http://relaxng.org/ns/structure/l.0" 
da t a typeL i b ra ry= "h t t p: //www. w3. o rg /2001/XM LS c h ema- data types "> 
<start> 
<el ement name="order"> 
<optional> 
<attribute name="orderDate"/> 
</optional> 
<attri bute name="orderNo"/> 
<el ement name="customer"> 
<attribute name="customerNo"/> 
<el ement name="name"> 
<el ement name="first"> 
<data type="stri ng"/> 
</el ement> 
<optional> 
<el ement name="mi ddl e"> 
<data type="stri ng"/> 
</el ement> 
</optional> 
<element name="l ast"> 
<data type="stri ng"/> 
</el ement> 

1.5 
Document Schemata 
21 
</element> 
<oneOrMore> 
<el ement name="address"> 
<el ement name="street"> 
<data type="stri ng"/> 
</element> 
<el ement name="town"> 
<data type="stri ng"/> 
</element> 
<element name="zi p"> 
<data type="stri ng"/> 
</element> 
<el ement name="state"> 
<data type="stri ng"/> 
</element> 
<optional> 
<el ement name="country"> 
<data type="stri ng"/> 
</element> 
</optional> 
</element> 
</oneOrMore> 
</element> 
<oneOrMore> 
<el ement name="orderItem"> 
<attribute name="amount "/> 
<choice> 
<el ement name="CD"> 
<attribute name="productNo"/> 
<optional> 
<attribute name="year"/> 
</optional> 
<ref name="ti tl ePattern"/> 
<ref name="publ i sherPattern"/> 
<zeroOrMore> 

22 
Chapter 1 Foundations 
<element name="contri butor"> 
<data type="stri ng"/> 
<optional> 
<attribute name:"ki nd"/> 
</optional> 
</element> 
</zeroOrMore> 
<ref name="pri cePattern"/> 
</element> 
<el ement name="book"> 
<attribute name=" ISBN"/> 
<optional> 
<attri bute name:"year"/> 
</optional> 
<ref name="ti tl ePattern"/> 
<ref name="publ i sherPattern"/> 
<zeroOrMore> 
<el ement name="author"> 
<data type="stri ng"/> 
</element> 
</zeroOrMore> 
<ref name="pri cePattern"/> 
</element> 
</choice> 
</element> 
</oneOrMore> 
</element> 
</start> 
<define name="publ i sherPattern"> 
<el ement name="publ i sher"> 
<data type="stri ng"/> 
</element> 
</define> 
<define name="ti tl ePattern"> 
<element name="titl e"> 

1.5 Document Schemata 
23 
<data type="stri ng"/> 
</element> 
</define> 
<define name="pri cePattern"> 
<element name="pri ce ''> 
<data type="decimal "/> 
</element> 
</define> 
</grammar> 
Relax NG also uses an XML syntax to describe schemata. The first difference 
is that a schema is not called a schema but a grammar, giving a clear hint that 
schemata can be described with grammars. Section 1.6 will introduce gram- 
mars--so be prepared. What is different, too, is that cardinality constraints are 
not expressed with mi n0ccurs and max0ccurs but by enveloping an expression in 
an optional, one0rM0re, or zero0rMore clause. 
However, these are minor differences. A more important difference is that 
Relax NG does not recognize global element definitions as DTDs and XML 
Schema do. Instead it introduces the concept of patterns, which are declared by 
a define clause. These constructs and the ability to combine various patterns and 
grammars are the strong points of Relax NG. They make it possible to develop 
complex schemata from simple building blocks. Another nice twist is the uni- 
form syntax for attribute and element definition. Relax NG is discussed in detail 
in Chapter 7. 
1.5.2 Choice 
The concept of sequence is the dominant organizing concept within docu- 
ments. Constraining the sequence of elements is the most frequent operation 
that we encounter when defining a schema for a given document type. For 
example, the customer section within a document must consist of the cus- 
tomer's name and address, given in this sequence. The customer's name is made 
up of the elements first, middle, last, which must always appear in the docu- 
ment in this sequence. As we have seen in the schemata above, each schema 
language has the means to specify a prescribed sequence. 
However, if we only had to deal with sequence, we would not need a schema. 
It would be sufficient simply to provide an example document. A schema is 
only required if there is an element of choice in how we can author a docu- 
ment. In fact, our example already contains an element of choice: A single 
orderItem element may contain either a CD element or a book element, as shown 
in Section 1.1.1. This choice is specified explicitly, using a "l" in the DTD, or 
the cho ice clause in XML Schema and Relax NG. 

24 
Chapter 1 Foundations 
But choices are not limited to these explicitly specified alternatives. Choices 
can come in other disguises, too: 
m Optional elements are another form of choice. For example, the customer's 
name may be given with or without a middle name. Formally, we can de- 
scribe an option as an alternative between a content element and an empty 
element. 
m Repeating elements contain an element of choice, as it is up to the document 
author when to stop the repetition. Repeating elements can be formally de- 
scribed as a combination of recursion (see next section) and choice. 
1.5.3 Recursion 
Recursion is a universal and powerful concept, especially in the formulation of 
grammars. Recursion means to perform an operation, and then to perform the 
same operation on the results of the previous operation, and so on. We can eas- 
ily see that recursion is one of the main ingredients of life. For example, the 
growth of a single biological cell into a complex organism can be seen as a 
recursive process. A cell doubles its genetic information and then splits into two 
cells. The same process is again performed by these two cells, resulting in four 
cells. Then the four cells repeat this process, and so on. At some point this pro- 
cess stops, however, and that is where the concept of choice plays a role in 
recursion. Recursion without choice results in cancer. 
Now, where does recursion play a role in document schemata? We have 
already mentioned repeating elements. A list of elements can be defined by the 
following recursive process: 
1. Add a single list entry to the document. 
2. Add an empty element to the document (in this case the list ends), or add 
a list to the document. 
But recursion can create more complex structures than simple repetitions. A 
typical example is a list for machine parts where each part entry contains 
entries for subparts, which in turn contain entries for sub-subparts, and so on: 
1. Create a part entry. 
2. Within the part entry create entries for subparts. 
3. Treat each subpart entry as a part entry. 
This is different from ordinary repetition: With recursion we can specify hier- 
archical structures of arbitrary depth. Without recursion we could only specify 
structures of limited depth. 
The following listings give a short example of a recursive part structure in the 
three schema languages. Similar structures are found in genealogies, in tax- 
onomies, in arithmetic expression, or in the folder structure of your computer's 
file system. First, in the DTD the part element definition refers to itself in the 
list of child elements: 

1.5 Document Schemata 
25 
<?xml version="1.0" encoding="UTF-8"?> 
<!ELEMENT partlist (part+)> 
<!ELEMENT part (description, part*)> 
<!ATTLIST part 
partNo CDATA #REQUIRED 
<!ELEMENT description (#PCDATA)> 
In XML Schema the part element definition refers to itself in the sequence of 
child elements: 
<?xml version="l.O" encoding="UTF-8"?> 
<xs: schema xml ns: xs="http://www, w3. org/2001/XMLSchema" 
el ementFormDefaul t="qual ified" attributeFormDefaul t="unqual ified"> 
<xs: el ement name="partl i st"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement ref="part" maxOccurs="unbounded ''/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs: el ement name="part"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="description" type="xs:string"/> 
<xs: el ement ref="part" mi nOccurs="O" maxOccurs:"unbounded"/> 
</xs : sequence> 
<xs :attri bute name="partNo" use="requi red"/> 
</xs: compl exType> 
</xs: el ement> 
</xs: schema> 
Finally, in Relax NG the part list is constructed by referring to the partPattern 
recursively: 
<?xml version="l.O"?> 
<grammar ns="" xml ns="http://rel axng.org/ns/structure/1.0" 
datatypeLi brary=" http://www, w3. org/2001/XMLSchema-dat atypes "> 
<start> 

26 
Chapter 1 Foundations 
<el ement name="partl i st"> 
<oneOrMore> 
<ref name=" partPattern"/> 
</oneOrMore> 
</el ement> 
</start> 
<define name="part Pattern"> 
<el ement name="part"> 
<attribute name="partNo"/> 
<element name="descri pti on"> 
<datatype=" st ring"/> 
</element> 
<zeroOrMore> 
<ref name=" partPattern"/> 
</zeroOrMore> 
</element> 
</define> 
</grammar> 
The following sections will demonstrate that the three basic concepts 
m sequence 
m choice 
m recursion 
are sufficient to describe document structures of a complexity that suits almost 
any purpose. 
1.6 GRAMMARS 
This introduction to formal grammars will provide a sound mathematical basis 
for XML schemata, because any schema can be regarded as a grammar that 
defines a particular language. The whole concept of XML is to provide a "lan- 
guage factory," and the many existing XML-based markup languages demon- 
strate clearly that this factory produces some output. 
Grammatical analysis goes back to the fourth century B.C. when Panini in 
India defined a grammar for Sanskrit. Plato also studied the grammar of the 
Greek language in his dialogue Cratylus. The study of formal grammars, how- 
ever, in which we are interested here, began as late as the mid-1950s when 
Noam Chomsky [Chomsky1956] published his work on structural linguistics. 

1.6 Grammars 
27 
1.6.1 Formal Grammars 
The theory of formal grammars is closely related to other theories of computa- 
tion, such as the theory of recursive functions (G6del), the theories of Turing on 
computation, and Kleene's theory of regular sets and regular expressions (see 
Section 1.6.3). 
Mathematicians define a formal grammar G as a production system consisting 
of the following: 
m A finite alphabet ~. The concept of an alphabet used here is a very general 
one. An alphabet can, for example, consist of all Unicode characters; but it 
may also consist of all keywords of a programming language, all pictographs 
of the Sumerian script, the sounds of a bird song (bird songs do have a gram- 
mar!Z), or the element and attribute names defined for an XML document 
type. 
n A finite set of non-terminal symbols N. As the name says, these symbols will 
not appear in the final document instance but are used only in the produc- 
tion process. 
-, A start symbol S taken out of the set of non-terminal symbols N. 
m A finite set of generative rules R. Each rule transforms an expression of non- 
terminal symbols and alphabet symbols (terminal symbols) into another ex- 
pression of non-terminal symbols and alphabet symbols. 
Such a system is called a production system because it can be used to produce 
language sentences (or document instances) from the language (or document 
type) defined with grammar G. The production starts with the start symbol S. 
By applying the rules first to S, and then recursively to the outcome of the pre- 
vious transformation, it is possible to generate a valid "sentence" of the formal 
language defined by the grammar. The production stops when the expression 
contains no more non-terminal symbols. All valid "sentences" of a given lan- 
guage can be generated in this way. The process of generation is completely 
mechanistic and can be easily transferred to a computer. Let's look at an exam- 
ple. The following little grammar generates currency amounts. 
The alphabet is 
{0,1,2,3,4,5,6,7,8,9, $, . } 
The set of non-terminal symbols is 
{ CURR, NUMBER, DIGIT } 
2. This is not really surprising. Any message emitted from a finite state automatonm 
through which a brain can be seenmcomplies to a grammar. 

28 
Chapter 1 Foundations 
The start symbol is 
CURR 
The rules are 
(1) CURR -> $ NUMBER . DIGIT DIGIT 
(2) NUMBER -> DIGIT 
(3) NUMBER -> DIGIT NUMBER 
(4) DIGIT -> 0 
(5) DIGIT-> I 
(13) DIGIT -> 9 
Now we can generate a bit: 
CURR 
$ NUMBER . DIGIT DIGIT 
$ DIGIT NUMBER . DIGIT DIGIT 
$ DIGIT DIGIT NUMBER . DIGIT DIGIT 
$ DIGIT DIGIT DIGIT . DIGIT DIGIT 
$934.50 
Start symbol 
after rule (1) 
after rule (3) 
after rule (3) 
after rule (2) 
after rules (13), (7), (8), (9), (4) 
Conversely, the grammar can be used to construct a parser that decides for a 
given input stream if that input stream is a valid sentence of the language 
defined by the grammar G. This is basically what XML parsers do. Actually, 
there are two parsers: The first checks if the input document complies with the 
XML syntax as defined in the XML 1.0 specification. A document that passes 
that test is called well formed. The second parser is constructed from the schema 
definition. A document that passes this test, too, is called valid. 
Unfortunately, the general parsing problem is undecidable. Constructing a 
parser from a grammar can result in a parser that never stops (except, perhaps, 
with a stack overflow exception). Thus, for several decades, researchers have 
aimed to constrain grammars in such a way that it is always possible to decide if 
an input stream belongs to the language defined by the grammar--in other 
words, that the parser always stops with a positive or negative result. 
1.6.2 Backus-Naur-Form (BNF) 
The class of decidable grammars is actually very clearly defined. It consists of all 
so-called context-free grammars, meaning that the left-hand side of the gram- 
mar rules must only contain a single non-terminal symbol. A grammar that 
cannot be expressed in such a way is not decidable. 

1.6 Grammars 
29 
One particular notation of context-free grammars is the Backus-Naur-Form 
(BNF). John Backus and Peter Naur introduced this class of grammars with their 
formal notation to describe the syntax of the ALGOL 60 programming lan- 
guage. Today, BNF remains the most frequently used grammar notation to 
define programming languages and other formal languages. 
The BNF notation is quite simple. It introduces only a few metasymbols: 
Symbol 
Meaning 
oo= 
I 
< 
> 
is defined as 
alternative, or 
angle brackets surround non-terminal symbols 
Terminal symbols are the symbols from the grammar's alphabet and are writ- 
ten without the angle brackets. 
A BNF rule has the following form: 
non-terminal 
..= sequence_of_alternatives 
consisting of strings of 
terminals or non-terminals 
separated by I 
Our little example from above would look like this in BNF: 
<CURR> "'= $ <NUMBER> . <DIGIT> <DIGIT> 
<NUMBER> "'= <DIGIT> I <DIGIT <NUMBER> 
<DIGIT> "'= 0 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 I 9 
Although BNF was designed to describe the syntax of ALGOL 60, it is inter- 
esting to know that it did not succeed in defining the language completely. The 
definition of ALGOL 60 required additional constraints. Only programs that sat- 
isfy these additional constraints are valid ALGOL 60 programs. One of these 
constraints requires that program variables that are referenced in a statement 
must be declared in the declaration part of the program. It can be proven that 
this constraint cannot be defined with the formalism of BNF. 
What has this to do with documents? Well, syntactically the declaration and 
usage of variables in ALGOL 60 is equivalent to cross-referencing within a doc- 
ument (the ID-IDREF construct in SGML and XML). Each cross-reference in a 
document must point to the cross-reference's definition within the document. 
Dangling cross-references (cross-references that point to nowhere) are not 
allowed. This cross-reference constraint cannot be captured with the means 
of BNF. 
The question is, should such a constraint be captured in a grammar? This 
would be possible by adopting a grammar model that is more general than BNF, 
but experience tells us that such grammars result in parsers that are difficult to 

30 
Chapter 1 Foundations 
build and are slow in execution. It is better to keep the parser simple, and to test 
the additional constraints separately. 
The problem with BNF for document processing is that even BNF is too gen- 
eral in many cases. BNF languages require parsers that may have to look far 
ahead in the input stream to decide which branch to take. This makes the 
parser slow and resource hungry. Let's look into alternative grammar models in 
order to see if we can find something more efficient. 
1.6.3 Regular Sets and Regular Expressions 
A well-known calculus to describe sets of string expressions is the calculus of 
regular expressions. For Perl and Python programmers, regular expressions are 
daily exercise, and as Java 1.4 introduces a library for regular expressions, Java 
programmers should soon know them by heart as well. 
Regular expressions are algebraic expressions that describe patterns. String 
patterns are the most popular, but patterns of other items can also be described. 
We will revisit regular expressions (patterns) in this role in Section 5.2.7 and in 
the appendix, where we discuss the lexical representation of XML data types in 
XML Schema. Here, we are more interested in how regular expressions can be 
utilized to describe the structure of documents or document parts; that is, how 
regular expressions can be used to describe how document parts must be 
arranged to form a valid document. 
Regular expressions (and also the term itself) were invented by the mathe- 
matician Stephen Cole Kleene [Kleene1956] in the mid-1950s as a notation to 
describe "regular sets" of symbol strings. The basics of regular set algebra are 
quite simple. We assume a finite alphabet ~. Again, this alphabet can contain 
any kind of symbols, but for the purpose of this explanation, we assume that it 
only contains ASCII letters. 
We can define the following constants: 
Symbol 
Definition 
a 
Notation 
The empty set 
The empty string 
Literal character with a contained in 
And we can define the following three operations: 
Definition 
Example 
RS 
RIS 
Concatenation. 
RS denoting the set { ab I a in R 
and b in S } 
The set union 
{" ab", "c"} {"x" , "yz"} : 
{"abx", "abyz", "cx", 
"cyz"} 
{"ab", "c"} I {"x", "yz"} 
= {"ab", "c"" , "x", "yz"} 

1.6 Grammars 
31 
R* 
The "Kleene" star, also call powerset. 
R* denotes the smallest superset of R 
that contains a and is closed under 
string concatenation. This is the set 
of all strings that can be constructed 
by concatenating zero or more strings 
in R. Obviously, R* consists only of 
the empty string (if R contained only 
the empty string) or is infinite. 
{ "ab" 
" " 
"a b" 
, 
c 
}* 
= 
{e, 
, 
"c", "abab", "abc", 
"cab", "cc", "ababab", 
"ababc", "abcab", "abcc", 
"cabab", "cabc", "ccab", 
"ccc", . . . }. 
Obviously, E* denotes 
the set of all strings that 
can be constructed from 
alphabet ~;. 
An expression combined from the above constants and operators is called a 
regular expression and describes a regular set. Each regular set can be obtained 
from a given alphabet with a finite number of concatenations, unions, and 
"Kleene" star operations. 
Look familiar? Well, a DTD model group definition looks very much the 
same, and something like 
(CD I book)* 
is in fact a regular expression. 
The 11 axioms and two rules in Table 1.1 (page 32) define the complete alge- 
bra for regular expressions. Such algebra can come in handy when we want to 
refactor schema definitions and other regular expressions. All theorems about 
regular expressions can be derived from these axioms with the help of the two 
rules. 
The rich set of regular expression operators, as we know them from lan- 
guages such as Perl, can all be derived from the three basic operators, concate- 
nation, set union, and powerset. The extreme simplicity of regular expressions 
allows the construction of very simple and fast parsers. However, regular expres- 
sions are far less powerful than BNF grammars. 
In the context of document processing, regular expressions are interesting 
because they can easily describe the nodes of a tree-structured document. They 
can cover all the basic structures of sequence, choice, and repetition. However, 
regular expressions cannot describe the depth structure of a whole document. 
This is because regular expressions do not cover recursion. So it is impossible to 
describe, for example, a parts list of arbitrary depth with a regular expression. 
What we therefore have to do is to combine recursion with regular expressions. 
One way to achieve this is to introduce regular grammars. 
1.6.4 
Trees, Hedges, 
and 
Forests 
The Hedge-Regular Grammar (HRG) [Murata1995] is such a combination. HRGs 
(sometimes also called Forest-Regular Grammars or simply Hedge-Grammars) 
have obtained much attention recently because they are well suited to describe 

3;2 
Chapter I 
Foundations 
Table 1.1 All theorems about regular expressions can be derived from these 
11 axioms and 2 rules. 
Axiom/Rule 
Axiom 1: (RIS)[T : R[ (SIT) 
Axiom 2: (RS)T = R(ST) 
Axiom 3: RIS = RIS 
Axiom 4: R(SIT) : RSIRT 
Axiom 5: (RIS)T : RTIST 
Axiom 6: RJR = R 
Axiom 7: RE - R 
Axiom 8: {}R = {} 
Axiom 9:{}R[ : R 
Axiom 10: R* = RR* J e 
Axiom 11: R* : (RIO* 
Rule of Substitution 
Rule of Solution 
of Equations 
Description 
Set union is associative. 
Concatenation is associative. 
Set union is commutative. 
Concatenation is left distributive to the set union. 
Concatenation is right distributive to the set union. 
Set union is idempotent. 
The empty string is neutral to the string concatenation. 
The empty set is the null element for string 
concatenation. 
The empty set is neutral to the set union. 
The empty string reconstructs the powerset that was 
concatenated with its own operand. 
The empty string added to the operand of a powerset 
does not influence the powerset. 
Let R, S, T, R', and S' be regular expressions with: 
R=S 
Let ct be a symbol that occurs in both R and S. If R' is 
obtained by the substitution of tx in R with T, and S' 
is obtained by the substitution of (x in S by T, then 
R'=S' 
Let R, S, and T be regular expressions with: 
R = SRIT 
If S does not include e then 
R=S*T 
XML documents. Parsers obtained from HRGs are simple and fast, and HRGs 
have additional benefits, which will be discussed below. In particular, the defi- 
nition of RELAX and Relax NG (see Chapter 7) is directly based on HRGs. 
Now what exactly is an HRG? An HRG consists of 
[] A finite alphabet Z. 
m A finite set N of non-terminal symbols. 
m A starting set S. This starting set is a regular set of non-terminal symbols out 
of N. If X consists of a single non-terminal symbol out of N, we speak of a 
Tree-Regular Grammar. 

1.6 Grammars 
]3 
[] A finite set R of production rules. Each of these rules has the form 
A ::: x(r) 
where A is a non-terminal symbol out of N, x is a terminal symbol out of ~;, 
and r is a regular expression of non-terminal symbols out of N. In particular, 
r can be empty. 
Let's look at an example. We want to define a grammar for documents con- 
taining a part list, similar to the one in Section 1.5.3. Each part list contains an 
unlimited number of parts. Each part description consists of a part number, a 
description, and a list of subparts. We can define a grammar for such documents 
in the following way: 
The alphabet E consists of the terminal symbols 
{part-list(), 
part(), part-no(), description(), 
a, b, c ..... 
z, O, 1 ..... 
9} 
The set N of non-terminal symbols consists of 
{LIST-OF-MATERIALS, PART, PART-NO, DESCRIPTION, LETTER, DIGIT} 
The starting set X consists of a single non-terminal symbol 
{ LIST-OF-MATERIALS } 
The set R of production rules consists of 
LIST-OF-MATERIALS ::= part-list(PART*) 
PART ::= part(PART-NO DESCRIPTION PART*) 
PART-NO ::= part-no(DIGIT*) 
DESCRIPTION ::= description(LETTER*) 
LETTER ::= (albl...Iz) 
DIGIT ::= (0111...19) 
We have defined here a tree-regular grammar because the start set consists 
only of a single non-terminal symbol. Basically, documents that consist of a sin- 
gle root node can be described with a tree-regular grammar. Document nodes 
such as XML elements, however, are not trees but hedges (ordered lists of trees). 
This is the case for the document node part (). If we wanted to describe the con- 
tent of this node with a grammar, we could use the same grammar except that 
we would define the start set as {PART-N0 DESCRIPTION PART*}. 
The grammar above also contains a recursion: A part() node can contain 
other part () nodes. This possibility makes the HRG more expressive than plain 
regular expressions. However, HRGs are not as powerful as BNF grammars; they 
can only describe treelike or forestlike structures. But they are more powerful 
than DTDs. 
In particular, HRGs allow us to describe context-sensitive content models. 
Take for example the following production rules: 
CATALOGUE ::= catalogue(LIST-OF-MATERIALS PRICELIST) 

34 
Chapter 1 Foundations 
LIST-OF-MATERIALS : := part-l i st (PART*) 
PART ::= part(PART-NO DESCRIPTION PART*) 
PRICELIST ::= pricelist(PART-WITH-PRICE*) 
PART-WITH-PRICE ::= part(PART-NO DESCRIPTION PRICE) 
PRICE ::= price(DIGIT*) 
Here, we describe a catalogue document containing two lists. Both lists con- 
tain elements tagged with part(), but the first list contains the classical ex- 
plosion part-list, while the second contains a flat part list where each part 
element has an additional pri ce element. 
Such a content model cannot be defined with DTDs because DTDs do not 
differentiate between non-terminal and terminal symbols. 
In contrast, both XML Schema and Relax NG provide a mechanism for rep- 
resenting non-terminal symbols. In Relax NG a pattern definition (see Section 
7.2.2) is equivalent to the usage of a non-terminal in a grammar. In XML 
Schema, groups and attribute groups serve the same purpose (see Sections 6.2.2 
and 6.2.3). 
One nice feature about HRGs is that HRG languages can be combined using 
Boolean set operators (union, intersection, negation) and still stay HRG lan- 
guages. This allows for a highly modular design of document schemata and the 
automatic generation of complex document schemata from simple building 
blocks. 
1.7 REGULAR TYPES 
We have seen how regular grammars can be used to define document types. We 
have seen, too, that DTDs use regular expressions to define the type of docu- 
ment nodes. XML Schema also provides an explicit constructor (compl exType) for 
type definition. Therefore, it seems sensible to provide a unified formalism for 
both document type definition and element type definition. We achieve that by 
introducing a new substitution operation into regular expressions. This opera- 
tion replaces the powerset operator and makes regular expressions equivalent to 
regular grammars. 
An exciting aspect of these regular types is that they can be applied to gen- 
eral data types, allowing much finer control over content than traditional data 
type declarations. 3 Functional programming languages such as ML or Haskell 
can exploit the possibilities of regular types. Examples are the fxp parser for ML, 
the HaXm! libraries for Haskell, and the development of XDuce [Hosoya2000a], 
a functional language based on ML with built-in support for XML data types. 
3. A datatype should be understood not as a particular physical representation of data 
values, but as a set of constraints describing a set of values. 

1.7 Regular Types 
35 
These languages handle XML document nodes in a type-safe way--the compiler 
is able to check on the type-safety of operations applied to document nodes. 
But also in imperative languages such as Java, C++, or C#, the typing of docu- 
ment nodes plays a crucial role when we bind a document schema to an object- 
oriented class hierarchy, as discussed in Chapter 10. 
We will use regular types in the context of conceptual modeling as discussed 
in Chapter 2. 
1.7.1 Types as Regular Expressions 
The classic data types, as we know them from early programming languages and 
database systems, are fairly basic: String, Integer, Float, Boolean, Binary, Date, 
Time make a typical working set of data types. A whole generation of program- 
mers has happily lived with this set of data types. 
Later, abstract data types were introduced, an idea that was picked up and 
made more sophisticated by object-oriented programming. Abstract data types 
did widen the concept of data types, as they also subsumed complex data types. 
A new data type can be constructed by forming a pattern out of existing data 
types, in particular the above-mentioned primitive data types. 
While this approach allows the construction of rather complex data types 
and similarly complex type hierarchies (for a comparison between object- 
oriented type models and document-oriented type models, see Chapter 10), it 
does not allow the finer control over the content of primitive data types. In 
classical type systems, a text document is a string is a string is a string. The 
internal structure of the string is of no concern to the type system. 4 
This situation is totally unacceptable when it comes to the exchange of doc- 
uments and text-based messages. Help comes in the form of regular expressions. 
As regular expressions allow us to restrict textual documents to certain patterns, 
they allow us to effectively sub-type strings and thus introduce whole hierar- 
chies of document types. The following sections discuss the basics of such a 
type theory. The discussion is based on [Hosoya2000], but is extended with the 
introduction of the substitution operation. 
1.7.2 Basic Composition 
To define a full set of regular expressions, we need three basic notations: 
m Variable. A variable stands for an arbitrary expression. We denote a variable 
with an uppercase character, such as  
4. Even in classical programming this is not always satisfactory. Take for example a 
Java program that wants to send an SQL command to a relational database via JDBC. 
The SQL command is just a string constant (or variable) and cannot be syntax checked 
by the Java compiler. The result is that bugs that could be detected at compile time are 
detected later, during the execution of the program. 

36 
Chapter 1 Foundations 
m Tagged expression. This is denoted by t IX]. In XML a tagged expression would 
be represented by a tagged element, the element content representing the ex- 
pression in the brackets. An empty element is denoted by t []. 
[] Empty sequence. We denote this with (). In XML an empty sequence would be 
represented by nothing. 
To combine these elements we only need three simple operators: concatena- 
tion, union, and substitution. The principles of concatenation are as follows: 
m X, Y denotes a concatenation of the expressions X and Y. 
[] Concatenation is an associative operation: (X,Y),Z is equivalent to X, (Y,Z). 
See also Axiom 2 in Table 1.1. 
[] Concatenation is not a commutative operation: X, Y is not necessarily equiv- 
alent to Y, X. 
The union operator follows these principles: 
m X NY denotes that a pattern can consist of either X or Y. 
m This is an associative operation: (XNY)[Z is equivalent to X[ (Y[Z) (Axiom 1). 
m It is also a commutative operation: X[Y is equivalent to Y[X (Axiom 3). 
m Both concatenation and tagging are distributive in respect to the union: 
X, (YNZ) is equivalent to (X, Y) [ (X,Z) (Axioms 4 and 5), and t [X NY] is equiva- 
lent to t [X] [t [Y]. 
To use substitution, an expression can be enclosed by curly brackets and dec- 
orated with a label: 
I{X} 
A later reference to that label is substituted with the content between the 
curly brackets. The syntax for the referencing label consists only of the label 
name: 
For example: 
I{X,Y},Z,I 
is equivalent to 
X,Y,Z,X,Y 
In particular, substitution can be used to express recursive structures. For 
example: 
l{t[l,l] l ()} 

1.7 Regular Types 
37 
denotes a binary tree structure. Note that the union with the empty sequence is 
essential here because it allows for stopping the recursion process. Without this 
possibility of choice, the expression would match only infinite structures. 
The operations described in the following paragraphs are all derived from the 
previous three operators. 
m Option. X? denotes X or the empty sequence. X? can be derived from the union 
operator: 
x? == xl(). 
m Powerset. X* denotes the set of recurring concatenation of X. This includes the 
empty sequence.  can be derived from the previous operators in the fol- 
lowing way: 
X* :: l{(X,l)? 
m Interleaving. X&Y denotes that X is concatenated with Y, or that Y is concate- 
nated with X.  
can be derived from the previous operators by 
X&Y :: X,Y [ Y,X. 
m Non-empty powerset. X+ denotes recurrence of X, which happens at least once. 
X+ can be derived from the previous operators by 
X+ == X,X*. 
As we have seen, recursive types can be expressed with three basic constructs: 
concatenation, union, and substitution. All other operators can be derived from 
these. 
1.7.3 Basic Type Algebra 
The distributive properties of concatenation and tagging in respect to the union 
allow us to factor out certain expression parts when we construct a union from 
two different types: 
t[X,Y,Z] I t [X,Y] 
First, we factor out the tag: 
t [ (X, Y,Z) i (X, Y) ] 
Then we can factor out the first concatenation operand: 
t[X, ((Y,Z) [ (Y))] 

38 
Chapter 1 Foundations 
We then expand the clause (Y) with the empty sequence: 
t[X, ((Y,Z)I (Y, ()))] 
and factor out the next concatenation operand: 
t[X,Y, (ZI ())] 
Finally, we abbreviate the union expression: 
t[X,Y,Z?] 
In Section 1.7.6 we will see that this technique is essential when converting 
nondeterministic expressions into deterministic ones. 
1.7.4 Subtypes 
When we define data types on the basis of regular expressions, we can establish 
a hierarchy of types. Type hierarchies play a role in XML Schema when it comes 
to deriving element types from existing complex element types by restriction or 
extension. We say that a type X is a subtype Y (X <= Y), if any valid instance of X 
is also a valid instance of Y. The subtype relationship forms a partial order for 
regular expression types: We may have two types for which no subtype rela- 
tionship exists. However, it is always possible to construct a supertype that 
encloses both types as subtypes. 
It is possible to deduct the subtype relationship from the regular expressions 
that define both types. We can start with simple expressions: 
X<=XIY 
because the right side is a union of X with some other expression type. From this 
it follows that 
X<=X? 
as X? is defined by X J(). 
It is also true that 
X,X, .... X <= X* 
as X* contains concatenations of X with itself in any length. Furthermore, con- 
catenation, union, and tagging are conservative regarding the subtype relation: 
If X <= Y then also 
X,Z <= Y,Z 

1.7 Regular Types 
39 
and 
xlz<=YlZ 
and 
t[X] <= t[Y] 
This is also true within a recursion: If  <- Y then also 
l{t[X,l]} 
<= l{t[Y,l]} 
and 
l{t[X I I]} <: l{t[Y I I]} 
1.7.5 Generic Types 
Finally, the generic tagged expression-[X] is a supertype to any t [X]: 
t[x] <=-Ix] 
Using a generic tagged expression and recursion we can define a completely 
generic type: 
1 { (-[I] I String I Integer I Float I Boolean I BinarYl Datel Time)* } 
This type subsumes all tagged structures and all of the specified primitive types. 
1.7.6 Deterministic Types 
A deterministic type is a type that can be described with a deterministic regular 
expression. An advantage to deterministic types is that their instances are easier 
and faster to parse. 
A regular expression is deterministic if at each choice point of the parsing pro- 
cess it is possible to decide which branch to take without having to look 
ahead. 
Take for example the regular expression 
((a,b) I (a,c)) 
This expression is not deterministic because each branch begins with a. At this 
point, it is impossible to decide which branch to take without looking one step 
ahead: The branches are only differentiated by b and c. 

40 
Chapter 1 Foundations 
The XML 1.0 specification, for example, requires that a content model defi- 
nition made with a DTD be deterministic. This is to maintain compatibility 
with SGML: SGML processors may flag a nondeterministic content model as 
ambiguous. XML Schema also requires a deterministic content model (Unique 
Particle Attribution). In Relax NG this requirement has been dropped. 
In many cases it is possible to transform a nondeterministic expression into a 
deterministic expression. In the example above, we can factor out the a and get 
a,(blc) 
Now it is possible to decide at the choice expression which branch to take 
because each branch begins with a different expression (b and c). 
Similarly, (a,b) [ (c&a) is not deterministic because the expression (c&a) allows 
valid instances of (a, c). Here we would need to resolve the expression first into 
(a,b) I ((a,c) I (c,a)) 
Then, by using the fact that the union operator is associative, we can transform 
it into 
((a,b) [ (a,c))I (c,a) 
and finally into 
(a, (blc)) I (c,a) 

2.1 
2.2 
2.3 
2.4 
2.5 
Motivation 
Principles of Conceptual 
Modeling 
Entity Relationship 
Diagrams 
Reality of Conceptual 
Modeling 
Introducing Asset 
Oriented Modeling 
T 
o some this chapter might come as a surprise: Conceptual 
modeling is a topic that is not frequently discussed in the 
context of XML. But XML has become a mainstream enterprise 
technology with applications far beyond the classical docu- 
ment applications of SGML. In enterprises, XML plays a role 
as an integration format for diverse data formats, typically for 
inter-application messaging. Relational databases are equipped 
with XML layers, and native XML-database and XML-enabled 
middleware has appeared on the market. In these application 
fields, solid engineering practices dominate and conceptual 
modeling is an issue indeed. 
In this chapter we investigate how traditional conceptual 
modeling methods such as Entity Relationship Diagrams might 
be applied to the complex XML data structures. We then intro- 
duce a new conceptual modeling method, Asset Oriented Mod- 
eling (AOM), that is particularly suited for the grammar-based 
data structures of XML. 
41 

42 
Chapter 2 Conceptual Modeling 
2.1 
MOTIVATION 
Conceptual modeling techniques are well known in enterprise software 
construction. Up to 80% of effort goes into the design phase of an implemen- 
tation, only 20% into the implementation. Prior to the implementation of an 
application, a requirements analysis is performed, which results in an informal 
description of the business domain. Based on the requirements analysis, the 
conceptual model captures the business domain with more formal (and mostly 
visual) means. 
A sound conceptual model documents that the participating analysts and 
engineers have understood the problem. It defines a common reference point 
for discussion between the different groups involved in the development of an 
application or an application system. The conceptual model thus forms the 
basis for the technical architecture. In particular, this is true when projects use 
different implementation paradigms side by side. For example, if we want to 
store data in a relational database, but communicate with client applications 
and peers in XML format, and in addition need an object-oriented Java access 
layer, things are becoming less than simple. Keeping, for example, the inheri- 
tance hierarchies in such an environment in sync can prove more difficult than 
managing a bag of bees. 
A conceptual model can be of great benefit here (see Figure 2.1). It defines 
the reference point from which all particular implementations are derived. 
Therefore, the conceptual model itself should be independent from a given 
technical infrastructuremit should not matter if SQL or XML is used to store the 
Conceptual model 
<element name="a"> 
<attribute name="b"/> 
<attribute name="c"/> 
<attribute name="d"/> 
</element> 
a 
blc 
I 
dl 
I 
class a { 
String b, c, d; 
} 
Java 
XML Schema 
SQL 
Figure 2.1 The conceptual model as a central point of information. 
Implementations that are derived from the model are always 
synchronized. 

2.2 Principles of Conceptual Modeling 
43 
data. Changes to the information structure are applied to the conceptual model 
first, and are then carried through to the various implementations. 
That a model should be implementation neutral does not mean that the 
selection of the correct modeling method does not depend on the technology 
used for the implementation. In the development of IT we have witnessed how 
the different paradigms in information representation have also spawned 
related conceptual modeling methods. When relational databases were intro- 
duced, Entity Relationship Diagrams became the conceptual method of choice. 
When object-oriented languages became popular, UML (an object-oriented 
modeling method) evolved. Now, with XML becoming a mainstream technol- 
ogy, we should expect to see modeling methods that are particularly close to 
grammars and the information model of XML. In fact, we will present such a 
modeling method in the following chapters. 
Choosing a modeling method that follows the current trend in information 
technology has several advantages: 
[] The model is better understood by programmers; implementation is easier 
and faster. 
[] Older modeling methods may not be suited to capturing the structure of the 
new application domains that evolve with the new technologies. 
[] A modeling method that closely matches the implementation method is bet- 
ter suited to support roundtrip engineering. 
2.2 PRINCIPLES OF CONCEPTUAL MODELING 
What is the purpose of a conceptual model? A conceptual model is created--as 
the name suggestsBat an early stage during the project development cycle, usu- 
ally after requirements analysis, when most of the details are still unclear. This 
differentiates a conceptual model from an implementation model. An imple- 
mentation model serves as a blueprint for a concrete implementation; the con- 
ceptual model, in contrast, provides the audience with a bird's-eye view and 
does not drown them in detail. 
The purpose of a conceptual model is communication--communication be- 
tween the various parties involved in development. It may be faster to imple- 
ment an application without creating a conceptual model first. However, 
developers may have a nasty surprise when clients tell them that the delivered 
application was not what they bargained for. A conceptual model adds extra 
safety to the development process. It helps to detect errors and misconceptions 
in an early phase of development. CASE tools (computer-aided software engi- 
neering) can help to generate code parts directly from a conceptual model, so 
some of the extra effort is rewarded when implementing the application. 
The language used to describe the model must therefore be easy to under- 
stand by all parties involved, not only by those who are going to implement 
the system. This excludes implementation languages as modeling languages. I 

44 
Chapter 2 Conceptual Modeling 
therefore do not advocate the use of markup languages, such as XML and SGML 
and their schema definition languages, as modeling languages. A model formu- 
lated in XML Schema or Relax NG would, for example, be well understood by 
schema authors, but all other parties, such as business architects, systems 
analysts, and database specialists, would be left out. 
Now, what makes a good conceptual model? The following guiding princi- 
ples are based on Esko Marjomaa's research [Marjomaa2002]" 
n Conceptualization. Only conceptual aspects of the modeled domain (Universe 
of Discourse) should be taken into account when constructing the concep- 
tual schema. 
[] Completeness. The conceptual schema should describe all the relevant aspects 
of the modeled domain. 
[] Formalization. It should be possible to formalize conceptual schemata in or- 
der to allow unambiguous implementation. 
[] Intelligibleness. Conceptual schemata should be easy to interpret and 
understand. 
[] Correspondence. There should be a one-to-one correspondence between the 
entities of the model and the entities of the modeled domain. 
[] Invariance. Conceptual schemata should be constructed on the basis of such 
entities that are invariant during certain time periods within the modeled 
domain. 
[] Decomposition. In order to construct a good conceptual schema it is impor- 
tant first to construct relevant subschemata and then to search for connec- 
tions between them. 
The principles of formalization and inteUigibleness are somewhat opposite to 
each other. A highly formalized model may not be understood by everyone. 
Sometimes an informal description can be more useful. 
2.3 ENTITY RELATIONSHIP DIAGRAMS 
The first conceptual modeling method, Entity Relationship Modeling, was in- 
vented by Peter Chen in the 1970s [Chen1976]. ERM is so simple that every- 
body can understand it: For ERM the world consists of entities. Entities may 
have attributes, and we can have relationships between entities. Entities of the 
same type form an entity set, and relationships of the same type form a relation- 
ship set. All this is defined in a rather informal way. 
As an example of the Entity Relationship method, we reverse engineer the 
document schemata given in Chapter 1 and present the conceptual model in 
the original notation of 1976. Figure 2.2 shows the results. The rectangles 
represent entity sets. Entity attributes are represented by ellipsoids. Double- 
outlined rectangles represent weak entities (entities that are subordinate to other 
entities). The triangle represents a generalization (product is a generalization of 

2.3 Entity Relationship Diagrams 
45 
customerlD 
orderNo 
customer 
contributor 
Figure 2.2 Preserving the heritage: the purchase order example as an Entity 
Relationship Diagram. 
book and CD). Relationships are represented by rhombs. An arrow restricts the 
cardinality to 1; otherwise the cardinality is not restricted. In our example, one 
customer can order several products, and each product is attributed with an 
amount. 
This example, however, has a few problems. First, a book can only have one 
author, as author is represented as an entity attribute. This restriction does not 
apply to contri butor, as contri butor is represented as an entity. However, con- 
tri butor looks a bit incomplete. It has, for example, no attribute for a name. 
Also, in terms of a conceptual model, authors, contributors, and publishers 
should be modeled as entities in their own right. Authors, contributors, and 
publishers are, after all, real-world entities and not mere attributes of books and 
CDs. However, this semantic information is not contained in the document 
schemata. Here, we see the limits of reverse engineering. 
Figure 2.3 shows the conceptual model that we would prefer; still, this model 
also has shortcomings. ERM was developed when relational databases came 
into use, and although it is a fairly generic modeling method, it reflects some of 
the limitations of relational technology. First, attributes must be atomic; that is, 
they cannot exhibit a deeper structure. That is why name is modeled as an 
entity--the only way to equip it with the structure of first, middle, last. But in 
the real world a name is not so much a first-order entity as a property of an 
entity. Second, we have no way of showing that some attributes, such as mi ddl e, 

46 
Chapter 2 Conceptual Modeling 
/ 
 u 'is"e  I 
contributor 
publisher I 
0 
Figure 2.3 Improved version of our order example. 
year, or 0rderDate, are optional. In relational technology there are no optional 
fields in a record; absent values are represented as null values. 
In the years after the invention of ERM, many dialects appeared using differ- 
ent notations. Among them was Information Engineering, developed by Clive 
Finkelstein [Finkelstein1998], and made popular through his collaboration with 
James Martin [Martin1993]. 
When the world turned object-oriented, various object-oriented dialects of 
ERM appeared, such as Semantic Object Modeling (SOM), developed by David 
Kroenke [Kroenke1995], and Nijssen's Information Analysis Methodology 
(NIAM), which finally became the Object Role Modeling (ORM) method 
[Halpin1999] used in Microsoft's Visio product. This development culminated 
in the definition of the Unified Modeling Language (UML) by the Object Man- 
agement Group [Booch1997]. UML, however, has abandoned the idea of a 
generic conceptual modeling method and offers instead a variety of specialized 
modeling methods such as class diagram, business case diagram, state dia- 
gram, activity diagram, connectivity diagram, and deployment diagram. This 
puts UML more into the league of object-oriented implementation modeling 
languages. 

2.4 Reality of Conceptual Modeling 
47 
2.4 REALITY OF CONCEPTUAL MODELING 
Conceptual modeling did not remain the pen-and-paper method originally 
devised by Peter Chen. Modeling tools were introduced that allow for designing 
models interactively on the computer screen. Most of the modeling also allows 
for deriving some code from the model definition. This, however, poses a prob- 
lem. Today, development cycles are not linear. You don't start with a conceptual 
model, implement it, and that's it. Instead, after implementing a first version, 
you go through various tests, gather experiences from the users, and design a 
new version. Development, today, happens incrementally and iteratively. Dur- 
ing these iterations, the conceptual model, the implementation model, and the 
code must be kept in sync. 
One technique to achieve synchronization is called roundtrip engineering. This 
means that changes made to the code are automatically reflected back into the 
model. The model always stays informed about the current state of the applica- 
tion code and vice versa. When changes are made to the model, it is possible to 
automatically carry these changes forward to the code. 
Roundtrip engineering requires a high degree of integration between code 
management and model management and the consistent use of the same mod- 
eling tools throughout the project. In small and medium projects this should 
not be difficult to ensure. In large projects, however, it becomes almost impossi- 
ble. Hundreds of developers may be working on the same project, probably 
located all over the world, and probably working with different tools. Under 
these circumstances it is almost impossible to synchronize all changes made to 
the code and automatically reflect them back into the model. 
So, conceptual modeling can become a drag factor when code changes must 
be reflected back into the model. This is especially true when the philosophy of 
the enterprise data model is used. This philosophy postulates that the whole 
enterprise must be seen as one consistent information model. When this huge 
model is centrally administered and every change must be approved by the 
central administration, the result is a cumbersome bureaucracy that can slow 
down the development process considerably. The same is true for large docu- 
ment schemata that are centrally administered. Section 13.2 will discuss some 
issues surrounding centralized and decentralized change management for 
schemata. 
Ad hoc business collaborations as we find them in electronic business and 
virtual enterprises have the opposite requirements. Here, the partners do not 
want to integrate their various information models into a single consistent 
model. What they require are information systems that collaborate in a loosely 
coupled fashion, usually with the help of mediating middleware between the 
participating software systems. The same is true for company mergers. Here, 
too, the systems have simply to collaborate, but with the prospect of long-term 
integration. Conceptual modeling must tackle this area as well. 

48 
Chapter 2 Conceptual Modeling 
2.5 INTRODUCING ASSET ORIENTED MODELING 
Asset Oriented Modeling (AOM) is a new conceptual modeling method that was 
designed especially for XML and open environments. AOM is used throughout 
the book to represent information structures visually. There are two reasons 
why we should use a new modeling method: 
[] The classic enterprise information model is giving way to an open network 
information model. The new scenario exposes problems in the existing clas- 
sical modeling methods: They are not flexible enough for network structures 
and are too slow for Internet speed. 
9 With XML we have a powerful technology to describe complex information 
structures based on a document model. Again, problems with classical mod- 
eling methods are revealed: They are not expressive enough for the highly 
complex document structures, and they are often too complex to be easily 
adopted by schema designers. 
AOM was born out of these requirements. It is a lean modeling method with 
only a few concepts to grasp. What differentiates this method from other mod- 
eling methods are the following points: 
n A unified approach to entities and relationships allows us to describe infor- 
mation structures that are beyond the scope of traditional modeling meth- 
odsmfor example, relationships between relationships and inheritance be- 
tween relationships. 
9 Regular expressions, regular grammars, and regular types (see Sections 1.6 
and 1.7) play a central role in AOM. In particular, this allows XML-like struc- 
tures to be defined in a very compact way. 
9 Namespaces allow merging of models and model parts. 
The following sections introduce the basic concepts of AOM and demon- 
strate its application with some step-by-step examples. Chapter 3 will discuss a 
larger model that will then be transformed into XML Schema in Relax NG in 
Chapter 8. You can also find detailed information about AOM on its web site, 
www. aomode l in g. org. 
2.5.1 AOM Basics 
The main components in AOM for describing the structure of an information 
model are assets and arcs. Unlike the various flavors of Entity Relationship Mod- 
eling, AOM does not distinguish between entities and relationships (or between 
classes and associations as UML does). Assets are not the same as entities, and 
arcs are not the same as relationships. AOM uses assets and arcs more in the way 
the Resource Description Framework (RDF) uses nodes and arcs. The classical 
entities and relationships are both represented in AOM as assets. Or, to be pre- 

2.5 Introducing Asset Oriented Modeling 
49 
cise, AOM treats everything--even entities--as relationships. Let's see how this 
works. 
Take for example a classical entity type, Customer. Let's say this entity type is 
related to entity type Person by an i s_a relationship, and with entity type 
Account by a has relationship. So the classical model would have three entity 
types: Customer, Person, and Account, and two relationship types: i s_a and has. 
However, we could interpret this situation quite differently. We could see 
Customer as a binary relationship that relates an account to a person. If we also 
want to include the fact that a customer resides at a given address, then Cus- 
tomer becomes a ternary relationship between Person, Account, and Address. In 
fact, a relationship might relate any number of items to each other. Generally, 
we allow n-ary relationships. 
Do we also have 1-ary (unary) relationships? Of course we have. Take for 
example a bicycle. A bicycle can be seen as a binary relationship because it 
relates the front wheel and the back wheel to each other. What about a mono- 
cycle? Obviously, a monocycle represents a unary relationship. That might 
sound like one hand clapping, but mathematically it is perfectly correct. 
Let's put this all together and look at a first example. What was said for 
the monocycle applies in the model in Figure 2.4 to 0valet Item. 0valet Item is a 
unary relationship referring to CD. The binary relationship orders relates the two 
Person 
I buysFor I~ ~ 
CD 
buyer~x~ 
Customer 
Account 
~u 
0rderltem 
ct 
Address ~~t orders ~/~ 
l message 
Shop 
receives | receiver 
I 
v 
Figure 2.4 Simple model for a music shop. Note 
that arcs do not represent a relationship but simply 
connect an asset with other assets that play a role in 
the context of the first asset. Arcs can be decorated 
with role names. 

50 
Chapter 2 Conceptual Modeling 
relationships Customer and 0rderltem to each other. Finally, the binary relation- 
ship receives relates the relationships orders and Shop to each other. 
Modeling this example in a classical modeling method would give us some 
trouble because in classic theory it is not clear if orders is a relationship or an 
entity. If we decided for a relationship orders, we would have trouble with rela- 
tionship receives, as this relationship would now relate an entity (Shop) with 
another relationship (orders)--a concept that is not supported in classical mod- 
eling methods. 
In classical ERM, if we decided for an entity, we would first have to reify the 
act of ordering into an entity Order. (To reify means to make into a thing.) Then 
we would have to invent additional relationships to relate Order to Customer and 
r 
The model gets bigger. Unfortunately, these scenarios where we would have 
to treat relationships as entities are not uncommon. In modern business scenar- 
ios, any business relationship manifests itself sooner or later as a business docu- 
ment and, alas, becomes an entity. 
So far, we have not discussed how to represent the end nodes of our graph: 
Person, CD, Account, Address, and Shop. Shouldn't we represent these assets differ- 
ently--as entities? I think not. These assets are always potential relationships. 
For example, if we add an asset Department to Shop, then Shop becomes a unary 
relationship. As long as Department is not added, Shop is, well, a 0-ary relation- 
ship. If this sounds a bit uncommon, consider that the concept of zero was un- 
common itself until the number zero was invented only some time ago in 
Arabia. The advantage is that with this concept, a given model is easier to 
extend. When we want to add Department to Shop, we just connect it with an arc, 
but we do not have to convert Shop from an entity into a relationship. 
AOM's concept of using relationships over relationships is based on Bernhard 
Thalheim's Higher Order Entity Relationship Modeling (HERM) [Thalheim- 
2000], although Thalheim still differentiates between entities and relationships. 
In this respect AOM is closer to the relational approach, where both entities and 
relationships are represented as tables. It was E. F. Codd, the father of relational 
algebra, who stated that there is no reason to distinguish between entity type 
and relationship type [Codd1991]). Consequently, relational database schemata 
translate nicely into AOM. 
The following sections will introduce AOM's language elements in a more 
formal way. 
2.5.2 Assets 
Now, let's take a closer look at the definition of assets (Figure 2.5): 
m Label. The asset label is optional and defines one or several display names for 
asset instances. If omitted, the display name of instances is identical to the 
asset name. Labels are not necessarily unique. 

2.5 Introducing Asset Oriented Modeling 
51 
Label 
I 
Name 
>Scope, ...< 
{Key} 
, , o  
Property 
, ~  
Constraint 
. o .  
Operation 
~ 1 7 6  
Annotations 
o . o  
Figure 2.5 Asset definition schema. 
A solid label without display names denotes an abstract asset, that is, an 
asset that cannot have instances. 
u Name. The asset name identifies an asset within a scope. 
[] Scope. The scope defines one or several contexts for assets. All asset definitions 
are only valid within the specified scope(s). A typical example for using 
scopes is versioning. If no scope is specified, the model scope applies. 
[] Key. One or several optional primary keys identify asset instances uniquely. 
Composite keys must be decorated with a name. For single property keys, the 
name defaults to the name of the property. 
n Property. Properties contain the "data" of asset instances (see next section). 
Optionally, a property can be constrained by a data type definition. 
[] Constraints. These can be used to define additional restrictions for properties. 
Constraints can be defined for single properties, across properties, or across 
assets. 
[] Operations. Asset operations define abstract access methods to asset instances. 
The semantics depend on the implementation. 
[] Annotations. These are an extension mechanism, similar to tagged values in 
UML. AOM allows XML syntax for annotations. 
At this point we need a proper definition of a key: In the most general sense 
a key can be expressed as a function over some asset properties k - f(nl,n2,...), 
which uniquely identifies the asset. However, for many implementation sys- 
tems this definition is too general. AOM therefore only supports keys defined by 
the following specification: 
A key is constituted by an unordered set of properties that uniquely identifies 
an asset. A primary key is constituted by the minimal set of such properties. 

52 
Chapter 2 Conceptual Modeling 
The distinction between asset name and display label is an important one. It 
gives AOM the same descriptive power as a regular grammar. The asset name 
takes the function of a non-terminal symbol, while the display names act as 
terminal symbols. 
2.5.3 Arcs and Clusters 
Arcs and clusters are the "glue" between assets. While arcs introduce an element 
of hierarchy into the model, clusters represent choice. 
A~K$ 
Assets are connected by directed arcs. An arc that points from asset A to asset B, 
as shown in Figure 2.6, indicates that asset B plays a role in asset A. Arcs do not 
represent relationships in the sense of Entity Relationship Diagrams. Relation- 
ships are represented in AOM as assets. Let's take a closer look at the elements in 
Figure 2.6: 
m Role. Arcs can be decorated with a role name. If no role name is defined, the 
implicit role name is the name of the target asset. 
[] [n..m]. In addition, an arc can be decorated with a cardinality constraint (see 
Table 2.1). 
[] >range. The range attribute is an additional constraint for arcs, restricting the 
possible set of target instances to a specific container (for details see Section 
2.5.8). 
[] (key). In the rare cases where a target asset specifies more than one primary 
key, the key can be specified by its name. 
When the cardinality constraints like the ones defined in Table 2.1 are used 
to decorate the edges of a graph (such as the arcs in a conceptual model), this 
can result in constraints that can never be satisfied. For example, in Figure 2.7, 
each instance of asset type C requires the existence of at least two instances of 
asset type A and at most one instance of asset type B. This contradicts the 
Asset A 
>range 
Asset B 
key 1 
key 2 
. . o  
Figure 2.6 Arc connecting assets. 

2.5 Introducing Asset Oriented Modeling 
53 
Table 2.1 Cardinality constraints for arcs. 
Notation 
Description 
[n..m] 
0 <- n <- m 
An unlimited upper bound is denoted with an asterisk *. 
* 
[O..*] 
+ 
[1..*] 
? 
[0..1] 
no decoration 
[1.. 1] 
-~ [2..*] ~J 
Figure 2.7 Contradictory cardinality constraints. 
implicit constraint between B and A, which dictates a 1:1 relation between 
both. 
Therefore, we should always make sure that the intersection of all constraint 
cardinalities used within a complex structure is not empty. This is always the 
case when we only use the last four constraint types (*, +, ?, no decoration): 
Their intersection always contains [1.. 1]. 
Clusters 
Arcs can be clustered. A cluster describes a situation where an arc leads from one 
asset to a set of alternative assets. As shown in Figure 2.8 (page 54), a cluster is 
denoted with a small circle at the origin point, containing the choice operator 
I- Clusters can also be used in classification relationships. Figure 2.9 (page 54) 
shows how a cluster can be applied to i s_a arcs. What this says is that a cus- 
tomer is either a person or a company. 
2.5.4 Properties 
In AOM, properties can be atomic or complex. Again this is different from clas- 
sical modeling methods where properties (or attributes) can only be atomic. 
Properties in AOM can have 

54 
Chapter 2 Conceptual Modeling 
Person 
buyer~,. 
Customer 
product 
Account 
Orderltem 
Address 
orders 
lmessage 
[ sh~ 
receives ~
1
 
Figure 2.8 The example from Figure 2.4 extended with a 
cluster. A customer now orders either a CD or a book. 
Company 
Person 
Customer 
Figure 2.9 A clustered i s_a relationship. 
[] An undefined type. In this case, only the name of the property is specified. 
[] An explicitly defined type (see next section). 
[] A local type definition. 
Local types are defined via a regular expression (see Section 1.7) using the fol- 
lowing syntax: 

2.5 Introducing Asset Oriented Modeling 
55 
Syntax 
prop (...) 
...) 
(sub ..... sub) 
(sub&...&sub) 
(sub[ ... [sub) 
Description 
Complex property, consist- 
ing of property name and 
a particle containing 
subproperties. 
A property particle. The 
parentheses contain nested 
expressions combining the 
following operators. 
Sequence (ordered list) 
Bag (unordered list) 
Choice (alternative) 
Example 
See following rows. 
author (name (firs t, l as t), 
birthDate) 
Property author consists of sub- 
property name, followed by sub- 
property bi rthDate. Subproperty 
name consists of subproperty first 
followed by subproperty last. 
part (i d, (maker&grade)) 
Property part consists of sub- 
properties i d, maker, and grade, 
with i d always in the first 
position and maker and grade 
following in any order. 
speaker((bass,middle,treble) 
[ (low,high)) 
A speaker system is either a 
three-way bass-middle-treble 
system or a two-way low-high 
system. 
Both properties and particles can be suffixed with one of the following 
modifiers: 
Syntax 
Description 
Example 
(no modifier) mandatory [1.. 1] 
? 
optional [0.. 1] 
last 
A last name is always required. 
middle? 
Not everybody has a middle 
name, so this property is 
optional. 

$6 
Chapter 2 Conceptual Modeling 
+ 
repeated [1..n] 
optional and repeated [O..n] 
phoneNo+ 
At least one phone number is 
required. 
sponsor(name, url )* 
An arbitrary number of sponsors 
is allowed. 
[n.. m] 
minimum of n occurrences 
and a maximum of m 
occurrences with 
0 <= n <= m 
phoneNo[1..4] 
The number of phone 
numbers is restricted to 
a maximum of 4. 
Recursive structures can be defined by using the substitution operation 
as introduced in Section 1.7. We use the following syntax to define recursive 
properties" 
Syntax. 
Description 
Example 
1 abel { } 
Label declaration. 
Establishes a reference point 
for the expression within 
the curly brackets. Unlike a 
tag, a label does not appear 
in instances. It is a pure 
metanotation. 
sect { ti tl e, para* } 
represents the property 
sequence 
titl e,para* 
and allows this sequence to 
be referenced by label sect. 
I abel 
Label reference. 
Refers to an earlier defined 
reference point. The current 
label occurrence is substi- 
tuted with the expression 
designated by the earlier 
label declaration. 
block (sect { ti tl e, para* }, 
anno,sect,sect) 
is equivalent to 
block (ti t I e, para*, anno, tit I e, 
para*, ti tl e, para*) 
In particular, labeling allows the 
definition of recursive 
structures. 
recur{part (recur*) } 
is a typical treelike part list: 
part (part (part (...)*)*)* 
Note that the use of a modifier 
such as * or ? is essential here. It 
ensures that the definition can 

2.5 Introducing Asset Oriented Modeling 
51 
have finite instances. In 
contrast, the expression 
recur{part (recur+) } 
would have only infinite 
productions. 
Figure 2.10 shows how this syntax can be used within an asset definition. 
The definition of properties is straightforward: 
[] customerID is a property with a (yet) undefined type. This property is also 
used as a primary key, as denoted in the slot under the asset name. 
[] name contains subproperties first, middl e, and last. Subproperty first may oc- 
cur several times, and subproperty mi ddl e is optional. 
[] title is optional but may occur several times. 
[] phone must occur at least once and at most four times. 
[] shippingAddress and bi I I ingAddress are identically structured, but bi I I ing- 
Address is optional. 
~Customer 
{customerlD} 
* 
customerlD 
name(first+,middle?,last) 
birthDate 
title* 
phone[1 ..4] 
shippingAddress( 
street, town,state, ZIP) 
billingAddress( 
street, town,state, Zip) ? 
Figure 2.10 Definition of a Customer asset. 
2.5.5 Types 
Simple types can be assigned to a property in order to constrain the values 
of that property to atomic values of the type's value domain. The notation is 
simple: 
type propertyname 
AOM does not introduce its own type system but allows the use of existing 
type systems, for example, Java types, SQL types, and XML Schema built-in 
types. The default type system for properties is defined in the global model def- 
inition; however, it is also possible to mix types from several type systems into 

58 
Chapter 2 Conceptual Modeling 
one model. Types not belonging to the default type system are prefixed with a 
type system identifier, for example, sql_TIME, or xs_string. 
AOM allows extending, restricting, or combining simple types by specifying 
type expressions. 
Syntax 
Description 
Example 
type 
(typelltype2) 
(typel,type2) 
{val uel, val ue2 .... O} 
type (param=val ue) 
Single type 
Type union 
Type sequence 
Type restriction by 
enumeration. The listed 
values are the only 
values possible for the 
property. 
float 
Property contains a floating- 
point value. 
(fl0atlint) 
Property contains a floating- 
point or integer value. 
(NMTOKEN, i nt) 
Property contains a name 
token followed by an integer 
value, such as "USD 5". 
int{1,2,3} 
Property contains one 
of the listed integers. 
{I,II,III} 
Property contains one 
of the listed values of 
undefined type. 
Type parameter. Depends decimal (fractionDigits=2) 
on the type system used Property contains decimal 
(for example, restricting 
values with two fractional 
facets in XML Schemata digits. 
see Section 5.2.7). 
The following type modifiers can be used: 
Syntax 
Description 
Example 
Optional type 
(used in sequences) 
(NMTOKEN?, i nt) 
Property contains an integer that 
can optionally be prefixed with a 
name token. 
List extension of type with 
at least one occurrence 
(NMTOKEN, i nt+) 
Property contains a name token that 
is followed by at least one integer. 

2.5 Introducing Asset Oriented Modeling 
59 
[n.. m] 
Optional list extension 
of type 
List extension of type with 
at least n occurrences and 
at most m occurrences 
with 0 <= n <= m. 
(NMTOKEN,i nt*) 
Property contains a name token that 
may be followed by integers. 
(NMTOKEN, i nt [2:4] ) 
Property contains a name token 
followed by 2-4 integers. 
Complex properties are defined via a local definition, as shown earlier. Alter- 
natively, a complex property may be defined via a complex type definition, 
which is nothing but the name of an asset that defines the structure of the 
property. Any asset can be used as a type. 
With AOM, we can combine several complex types with the union operator: 
Syntax 
Description 
Example 
type 
Complex type 
(typelJ type2) 
Type union 
person 
Property contains a structure as 
defined in asset person. 
(person J company) 
Property contains either a structure 
as defined in asset person or a 
structure as defined in asset company. 
In the example shown in Figure 2.11, all properties have been decorated with 
type definitions. The atomic types are borrowed from XML Schema, assuming 
Figure 2.11 Completely typed customer asset. 

60 
Chapter 2 Conceptual Modeling 
XML Schema was defined as the default type system on the model level. The 
only complex type is Address, which is used for both shippingAddvess and 
bil]ingAddvess. This type is defined as an abstract asset (note the grayed-out 
asset label), so it cannot have instances of its own. 
2.5.6 Inheritance 
In AOM, the i s_a relationship defines an inheritance relationship (see Figure 
2.12). Features of the target asset, such as properties, keys, constraints, opera- 
tions, annotations, in- and outgoing arcs, are inherited by the origin asset. The 
origin asset may override inherited features. 
Multiple inheritance is possible, provided the definitions made in assets A1 
and A2 are compatible. Definitions inherited by asset B from both A1 and A2 
are constructed by intersection: If two definitions are incompatible, their inter- 
section is empty. Figure 2.13 shows how to construct an asset CDforSale from 
assets CD and Product by multiple inheritance. What this says is that COf0rSale is 
both a CD and a product. 
Clustered inheritance works like a generalization. The inherited definitions are 
combined by the choice operator. In Figure 2.14, a customer is either a person or 
a company. 
Ii ers~ 
ame(string first+, 
string middle?, 
string last) 
ate birthDate 
l is_a 
, 
Ii ust~ 
customerlD} 
oken customerlD 
ate birthDate? 
~Customer 
{customerlD} 
* 
token customerlD 
name(string first+, 
string middle?, 
string last) 
date birthDate? 
Figure 2.12 Asset Customer 
inherits properties from asset 
Person but overrides the defi- 
nition of property bi rthDate 
by making it optional. 

2.5 Introducing Asset Oriented Modeling 
61 
Is 'D 
tring title 
I description? 
I track(string title, 
[ short duration)+ 
is a 
is a 
Product 
i {productNo} 
I NMTOKEN productNo 
I decimal price 
.. Ldescription+ 
J 
~CDforSale 
{productNo} 
* 
NMTOKEN productNo 
decimal price 
string title 
description 
track(string title, 
short duration)+ 
Figure 2.13 Multiple inheritance. 
The asset CDforSale inherits properties 
from both CD and Product. As the 
definitions of property description 
clash, the intersection of both 
definitions is constructed. The 
intersection of cardinality constraint 
[0..1] (?) with cardinality constraint 
[1..*] (+) results in [1..]. 
Ii ers~ 
ame(string first+, 
string middle?, 
string last) 
ate birthDate 
is_a ~I~ is_a 
Customer 
LcustomerlD 
Iompany 
1 
ring name 
tring taxlD 
I Customer I 
Consumer 
I Customer I 
Ii 
orp orateCustomer 
ustomerlD 
ring name 
tring taxlD 
customerlD 
name(string first+, 
string middle?, 
string last) 
date birthDate 
L_ 
rders~~__. ~ 
rderNo 
I orders 
._{Product ] 
FProduct 
l 
LorderNo 
- LProductNo 
~ 
~CProductNo j 
Figure 2.14 Clustered inheritance. The diagram on the right shows how clustered inheritance 
can be resolved. We get two different asset types Consumer and CorporateCustomer, but united 
under the same display label Customer. Consequently, instances would all be named Customer. 

62 
Chapter 2 Conceptual Modeling 
2.5.7 Constraints 
Again, AOM does not introduce its own constraint language but allows the use 
of existing constraint languages. One example is OCL, which is mostly used in 
UML scenarios. This book uses an XPath-like constraint language, which will 
allow us, for example, to transform conceptual constraints easily into Schema- 
tron expressions (discussed in Chapter 9) or to use XPath-enabled DOM imple- 
mentations for constraint checking. 
Constraints can be defined in order to introduce additional restrictions for 
properties. In AOM constraints can be defined 
m for single properties or subproperties 
[] between subproperties of a single property 
[] between properties of a single asset 
[] and across different assets 
For example, say we want to require that a middle name not be specified if 
there is more than one first name specified. This would read as 
not(name/first[2]) or not(name/middle) 
To relate a constraint expression to a specific property or subproperty, a con- 
straint can be equipped with a context expression that is separated from the con- 
straint expression with a double colon. For example, we can transform the 
above constraint to 
name:: not(first[2]) or not(middle) 
by factoring out name. 
A constraint that needs to access property values in other assets can do so by 
exploiting the access structure provided by the arcs between assets. Let's assume 
that we want to add a constraint to asset A that needs to access values in asset B. 
If there is an arc leading from asset A to asset B, we can access properties in asset 
B from asset A by 
B/propname 
If a role name is specified for the arc, we can use 
rol ename/propname 
instead. Figure 2.15 shows a constraint between the two assets orders and 
Customer. 
2.5.8 Level 2 Structures 
The language elements outlined above are sufficient to define the basic struc- 
ture of an information system. Assets can represent both the entities and re- 

2.5 Introducing Asset Oriented Modeling 
63 
Figure 2.15 Defining a constraint 
between two assets. The property 
orderDate in instances of asset orders 
must always contain values that are 
larger than those in property bi rthDate 
in the corresponding instances of 
asset Customer. 
lationships of a conceptual model. The ability to specify structured property 
avoids the need to introduce artificial entities and keeps the model compact. 
However, large systems require large models, and viewers can get lost in the 
cobweb of interrelated assets. AOM therefore introduces a notation for addi- 
tional structures defined on top of an existing model. These are generically 
called Level 2 Structures (L2S). 
L2S serve three interrelated purposes: 
[] L2S improve the perceptibility of the model by arranging assets that are 
closely connected into groups, and by demarcating these groups. 
9 L2S usually represent real-world objects. Within a business scenario, typical 
Level 2 Structures represent business objects and business documents. 
Business objects are assets or groups of assets that play a role in a business 
process. 
Business documents are assets or groups of assets that are exchanged as 
messages between business objects within the context of a business process. 
9 L2S provide a hint regarding modularization for later implementations of 
the model. In XML Schema, for example, an L2S would typically be imple- 
mented as a separate schema file. In Java, an L2S would typically be imple- 
mented as a separate package. 
Each L2S can group together several assets (and/or other L2S, as L2S can 
be nested). They are demarcated by a labeled box. Multiple labels (aliases) are 

64 
Chapter 2 Conceptual Modeling 
possible. Figure 2.16 shows how to group the assets in a simple shop model. 
Customers can order books or CDs. When they do so, they may order several 
items in varying amounts. Items consist either of books or CDs. The shop 
receives those orders. 
Customers, books, CDs, and shops are first-order business objects because 
they play a role in the business process. Not so clear is where to put the assets 
orders, 0rderItem, and receives. Since each act of ordering will result in a pur- 
chase order (a business document) that will list multiple order items, we place 
the assets orders and 0rderI tern into the same L2S. Receiving an order is a func- 
tion of the Shop business object, so the asset receives goes into one L2S with 
asset Shop. 
Within each L2S, one designated asset acts as the identifying asset (each 
marked with a bold outline). In our example the following assets are used as 
identifying assets: Customer, CD, Book, orders, Shop. 
The following constraints apply to identifying assets: 
[] Identifying assets should have a key. A key allows identifying instances of L2S 
uniquely. This makes sense: Especially in an open environment, each busi- 
ness object and each business document should have a globally unique iden- 
tifier that can be used as a key. Each web page has one! 
1 
|,Customer , 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
' 
C 
~ buysFor 
! 
I 
| 
',,, [ Account 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I_ 
client 
Address 
Company 
is a 
I Book 
i, 
I CD 
' I 
I 
I 
-- 
I 
-- 
I 
I 
I 
I 
I 
', 
!! 
l!il 
15 
' 
'- 
t' 
! 
I' l' Order 
] 
product~[ product 
," ,'i 
[ Orderltem 
I 
' 
i or er __.V+ 
',, 
L . . . . . . .  
! 
-1 
I Shop 
' 
I 
I 
I 
* 
i message 
Shop 
I 
" [ receives ]receiv~ 
',,, 
I 
-! 
1 
L 
Figure 2.16 Applying Level 2 Structures, step 1. 

2.5 Introducing Asset Oriented Modeling 
65 
m Starting from the identifying asset of an L2S, we must be able to reach any as- 
set belonging to that L2S by following the arcs in the indicated direction. 
This constraint will allow us to interpret each L2S as an aggregation and will 
later allow us to easily implement Level 2 Structures as hierarchical struc- 
tures, such as XML document types. 
The example in Figure 2.16 presents a problem: We would like to use asset 
Shop as the identifying asset of L2S Shop, but the arc coming from asset receives 
has the wrong direction. This is a common problem when grouping into L2S. 
To comply with this constraint we must reverse the direction of the offend- 
ing arc. This reversal represents a change of interpretation: An asset that was 
originally superior to the identifying asset now becomes a subaltern of the iden- 
tifying asset. 
Arc reversal renders any cardinality constraint of that arc invalid. Therefore, 
the reversed arcs are decorated with "*" to indicate that no cardinality con- 
straint exists for this arc. 
In addition, the reversal of an arc renders its role name invalid. It may 
require the specification of a new role name. 
Let's see what this operation does to our Sh0p example (Figure 2.17). We have 
reversed the arc leading from asset receives to asset Shop. We can interpret this 
~,Book 
',Customer , 
I- 
I 
I 
' 
I 
I 
! 
! 
I 
! 
I 
I 
I 
>Customer 
I 
I , buysFor 
I 
I 
I 
,"[Acc~ 
~- 
I 
' 
( 
! 
! 
I , 
Address 
I 
I 
I 
I 
Company 
is_a 
/is_a 
ustomer 
',Order 
I 
I 
I 
I 
I 
I 
I 
i 
, _....d__ 
L__ t 
, 
' orders 
I 
I 
I 
I 
.. 
I 
L . . . . . . .  
I 
I 
I ICD 
, 
I' 
-- 
I 
--I 
I:l 
I: 
I, 
..! ~ ..... 
A _2 
product 
Orderltem 
---T- 
product 
n 
"~1 
I 
3, 
! 
! 
! 
! 
! 
! 
! 
! 
! 
_1 
II llSho p 
.......... 
I 
...... 
T!__ 
I I'' 
! 
: 
! 
L 
I 
Figure 2.17 Applying Level 2 Structures, step 2. 

Chapter 2 Conceptual Modeling 
as an acquisition of asset receives by asset Shop. To comply with the rules, we 
have also dropped the role name and the cardinality constraints (by adding an 
asterisk). 
The same operation was applied to the arc with the role name buyer leading 
from Customer to buysF0r. We had the same problem there: buysF0r could not be 
reached from identifying item Customer. We have reversed this arc, removed any 
cardinality constraints, and dropped the role name. 
But what have we done to the arc with the role name c] ient? This arc points 
back to asset Customer. Arcs that are local to an L2S are also local to any instance 
of the business object represented by the L2S. For example, the arc leading from 
Customer to Account would lead in an instance A from Customer A to Account A 
and not to an arbitrary account. This is the desired behavior for most arcs con- 
necting assets within an L2S, and consequently the range of these arcs is by 
default restricted to one instance. 
Not so for arc client. For this arc it would not make sense to point back to 
the same customer instance. Instead we want this arc to point at other Customer 
instances. We therefore must loosen the range constraint of this arc, and we do 
this by decorating the arc with the name of the L2S, which in our case is Cus- 
tomer, too. By doing so, we indicate that this arc may point to all instances of 
the L2S Customer. 
2.5.9 Models and Namespaces 
In AOM each model can consist of 
m Assets 
[] Arcs connecting assets 
[] Level 2 Structures (L2S) that group items together 
[] Global definitions 
Figure 2.18 shows the graphical representation of the global definitions that 
can be made in AOM and a concrete example. 
[] Name. The name of the model. 
[] Namespaces. The default namespace and additional namespaces with their pre- 
fixes (see below). Namespaces are identified by a globally unique URI. The 
definition of a default namespace is mandatory. 
The syntax for namespace prefixes is prefix=namespace. 
[] Scopes. A user-defined context for the model. Multiple scopes are allowed. A 
typical application for using scopes is versioning. If no scope is supplied, the 
model is valid in a global scope. 
[] Type systems. The type systems used for simple types, such as Java, XML 
Schema, SQL. Type systems should be specified with a globally unique URI. 
First, a default type system is defined, followed by additional type systems 
with their prefix. 

2.5 Introducing Asset Oriented Modeling 
67 
Name 
Namespaces 
Scopes 
Type systems 
Constraint 
languages 
Operation 
vocabulary 
Annotations 
(a) 
Name 
Namespaces 
Scopes 
Type systems 
CDOrderModel 
http://www.jazzshop.com/orders 
j az=http://www.jazz.org 
Versl Vers2 Vers2.1 
http://www.w3.org/2001/XMLSchema 
(b) 
Figure 2.18 The global model settings describe the 
use of namespaces, type systems, constraint languages, 
and other information. 
m Constraint language. The language used for specifying constraints, such as 
OCL or XPath. Constraint languages should be specified via a globally 
unique URI. 
First, a default constraint language is defined, followed by additional con- 
straint languages with their prefix. 
m Operation vocabulary. The vocabulary namespaces for defining abstract opera- 
tions. These vocabularies are user defined. First, a default operation vocabulary 
is defined, followed by additional operation vocabularies with their prefix. 
[] Annotations. An extension mechanism, similar to tagged values in UML. 
However, AOM allows XML syntax. 

Chapter 2 Conceptual Modeling 
The example in Figure 2.18(b) defines a default namespace, an additional 
namespace with prefix jaz, three scopes, and a default type system. 
The purpose of namespaces in AOM is to globally identify assets in a unique 
way. The default namespace that must be defined with each model applies to all 
assets, unless these items use an explicit namespace prefix (separated from the 
name with a colon). The combination of name and namespace identifies an 
item unambiguously within a given scope. This feature allows for merging mod- 
els. The ability to merge two or more models becomes important in large sce- 
narios, where applications are developed by multiple groups, or when formerly 
distinct applications grow together. Using different namespaces for different 
models prevents clashes between equally named assets or L2S. On the other 
hand, it is also possible to force assets from different models to merge, by 
assigning them to a common namespace and giving them the same name. 
When two models are merged, the result is basically a union of both models. 
However, the following rules apply when definitions clash: 
n Equally named assets belonging to the same namespace and the same scope 
are merged. 
m Level 2 Structures are merged when their identifying assets are merged. In 
this case their labels are combined by a union. 
When two assets are merged, their properties are combined per union. 
Equally named properties are combined in a single particle with the help of a 
choice operator. 
Similar rules apply to asset labels, keys, constraints, operations, and anno- 
tations. Detailed merging rules are documented on the AOM web site 
(www.aomodeling.org). 
Figure 2.19 shows our completed bookshop model. Section 13.1 shows how 
to combine two models using the model developed in this chapter and the 
model developed in Chapter 3. 
2.5.10 Summary 
AOM is a new modeling method that is particularly (but not exclusively) tar- 
geted at XML environments. Its main features can be summarized as follows: 
m A OM is expressive. By representing relationships in their reified form as assets, 
AOM allows us to define, describe, and visualize higher-order relationships 
that is, relationships between relationships. AOM Level 2 Structures can be 
used to model large-scale objects by aggregating several lower-level assets. 
These structures are closely related to objects of the real world and allow an 
intuitive and natural model of the business domain. They are also easy to im- 
plement in the form of XML documents. 
m A OM is compact. Due to the fact that AOM allows the definition of properties 
with complex structures, AOM models are usually very compact. The regular 

2.5 Introducing Asset Oriented Modeling 
69 
Ii Customer I I .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
 
I 
, 
,'1 persOn 
t 
C~ 
t 
I
1
~
 
' 
! name(first, middle?,last) 
name 
i 
I 
I 
I date birthDate 
DUN 
I 
I 
I 
W' 
I 
is a 
! 
I 
-- 
-- 
I 
I 
I 
! 
>Customer 
! 
I 
! 
(" 
~ 
customerln 
I 
iIt~1 
buysFor 
iii 
I 
I 
I f 
ccount i--l-- 
i accountNo 
I I decimal balance 
I 
" 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I.. 
Address 
street 
town 
zip 
state 
country? 
phone[1 ..4] 
11 Book 
I 
I Book 
I 
I 
I 
I 
I 
I 
I ,, 
I 
I 
ISBN 
title 
publisher 
author* 
decimal price 
[ Order 
' 
i. 
I 
I 
I 
' 
I 
I 
I 
I 
I ,orders 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
s.= . . . . .  
orderNo 
date orderDate 
,',CD 
. . . . .  
| . . . .  
, i 
l llcD 
I 
11 
i 
1 
1 
1 
1 
productNo 
I I 
I 
I 
title 
i 
i 
i 
i 
i 
I 
publisher 
! 
II 
contributor* 
i 
I 
I 
I 
! I decimal price 
i 
I 
I 
I 
j 
I 
j 
Orderltem 
amount 
orderDate > 
C 
Customer/birthDate 
I 
[Shop 
, _  
I 
. 
I nessage 
I 
I i receives 
I 
I 
! 
! 
Shop 
, 
name 
product 
. . . .  
! 
! 
I 
I 
! 
! 
! 
! 
! 
I 
I 
I 
! 
! 
! 
! 
! 
I 
Name 
Bookshop 
Namespaces 
href://www.nile.com 
Type systems http://www.w3.org/2001/XMLSchema 
Constraint 
languages 
http:/lwwww3 orglTRlxpath20 
Figure 2.19 The completed bookshop model. Note the namespace definitions 
for model, type system, and constraint language. 
expression syntax for properties allows the definition of structures of arbi- 
trary complexity. 
[] AOM is modular. By attaching globally unique namespace identifiers to 
models and/or assets, AOM is able to merge models both horizontally and 

10 
Chapter 2 Conceptual Modeling 
vertically. This allows the distributed development of models and the inte- 
gration of foreign models. 
m A OM is simple. The metamodel (Figure 2.20) of AOM is very simple, which 
makes AOM easy to learn and to use. 
~model 
{defaultNamespace, name}* 
name 
defaultNamespace 
namespacePrefix* 
scope* 
defaultTypesystem 
typesystemPrefix* 
defaultConstraintLanguage 
constraintLanguagePrefix* 
defaultOperationVocabulary 
operationVocabularyPrefix* 
annotation* ~ 
9 
asset 
name 
(abstractldisplayLabel*) 
name 
scope* 
key( name ?, field+ ) * 
property( type ?, reg Expr)* 
constraint(context? ,text)* 
operation(con text?, text)* 
annotation( context ?, text) * 
originl 
ltarget l 
[arc 
1 
"r 
I role? 
IminOccurs? I 
[2..*] 
I maxOccurs? 
[range? 
Lkey ? 
J 
Name 
Namespaces 
Scopes 
aomMetaModel 
http://www.aomodeling.org/aom/2001 
AOM1.0 
Iidentifies ~ 
~ 
1 
J identified! 
~ 
~" identi 
Figure 2.20 AOM metamodel. The recursive arc at the Leve12Structure asset indicates 
that L2S can be nested. In this, the nested L2S may act as an identifying item of the 
containing L2S. 

3.1 
3.2 
3.3 
3.4 
3.5 
3.6 
3.7 
Informal Description 
The Conceptual Model, 
First Draft 
Asset or Property? 
Normalization 
Partitioned Normal Form 
Resolving i s_a 
Relationships 
Introducing Level 2 
Structures 
I 
n this chapter we will model a small knowledge base. This will 
provide us with the information structures from which we can 
draw examples for the following chapters. I have chosen an 
example about jazz music and jazz musicians, first, because I 
think this example is pretty cool, and second, because it allows 
us to apply our modeling techniques to an area that is not so 
well understood as the classical purchase order example. 
As you probably know, the relationships among jazz musi- 
cians are manifold and complex. New bands and projects are 
set up all the time, and there are many forms of collaboration. 
In this respect, jazz music very much resembles electronic busi- 
ness, where business relations are much more short-lived than 
in the old economy. This chapter develops this example in 
detail, starting with an informal verbal description and then for- 
malizing this description into a conceptual model. 
71 

72 
Chapter 3 Everybody Likes Jazz 
3.1 INFORMAL DESCRIPTION 
A popular method for modeling an information domain is to start with an 
informal, verbal description of the scenario. The scenario should be described in 
short, simple sentences. 
A jazz musician is a person. 
A person has a name and a birth date. 
The birth date may not be known. 
A jazz musician collaborates with other jazz musicians. 
During a certain period of time a jazz musician belongs to a style. 
A style is dominant during a certain period of time. 
Instrumentalists, jazz singers, jazz composers are jazz musicians. 
An instrumentalist plays one or several instruments. 
A jam session is a form of collaboration. 
A jam session is performed at a location and at a particular time. 
A project is a form of collaboration (during a certain period of time). 
A band is a form of collaboration (during a certain period of time). 
A collaboration can result in one or several albums. 
An album has a publisher, a product number, and a title. 
An album has one or several tracks. 
A track has a duration and a title. 
An album may have one or several samples. 
A sample provides an MP3 URL for a track. 
A jazz musician may produce a solo album. 
Albums and jazz musicians are reviewed in magazines by critics. 
A critic is a person. 
The actual relationships are, as a matter of fact, much more complicated. For 
example, we could include a full taxonomy for musical instruments and styles. 
But for the purpose of this example, this description might do. 
To prepare the construction of the conceptual model, we perform a simple 
grammatical analysis. In each sentence we identify the nouns (jazz musician, 
person, name, birth date, band, collaboration, location, album, etc.) and verbs (is, 
has, col l aborate, plays, etc.). This will help us to identify relevant information 
items. 

3.3 Asset or Property? 
73 
3.2 THE CONCEPTUAL MODEL, FIRST DRAFT 
We are now going to transform this informal description into a more formal 
conceptual model. In traditional conceptual modeling (such as ERM or Object 
Role Modeling), nouns would end up as entities (or attributes) and verbs 
would end up as relationships. But we will use AOM instead, so both nouns 
and verbs will become assets. This simplification will spare us the classical 
design dilemma: Do I choose an entity or relationship to model an item that 
could be both? In our example, this is c011ab0rati0n-c011ab0rate. In one sen- 
tence it behaves like an entity; in another sentence it acts as a relationship. In 
AOM this dilemma does not exist, and the only choice is which name to 
choose for the asset. In such cases we usually decide for the noun form, which 
is col I aboration. 
When modeling verbs as assets, there are two notable exceptions: 
[] The verb has indicates either that an asset has a property, as in 
A person has a name and a birth date. 
or that an asset aggregates other assets, as in 
An album has one or several tracks. 
In this case we represent the verb has with a simple arc leading from asset 
type album to asset type track. As explained in Section 2.5.1, it is the asset 
type album that could be regarded as a relationship between tracks. 
[] The expression is a indicates a classification: 
A jazz musician is a person. 
The noun on the right-hand side (person) is usually the more general term 
than the noun on the left-hand side (jazz musician). Again, we represent the 
verb is with a simple arc leading from jazz musician to person. We indicate 
the special role of this connection by decorating the arc with i s_a. 
3.3 ASSET OR PROPERTY? 
There is still a design decision to make. Especially for aggregations, we have to 
decide if we want to model the aggregated items as assets or as properties of the 
aggregating item. This distinction is not always easy. However, there are a few 
guidelines: 
m Anything that plays a certain role in the context of our business is definitely 
an asset. So, the decision about what becomes an asset and what a property 
may depend on the business process. For example, in the context of our jazz 
knowledge base, it may be sufficient to model instrument as a property. But if 
we plan to implement a supply chain for a music shop, instrument would def- 
initely be an asset, and an important one. 

74 
Chapter 3 Everybody Likes Jazz 
m In many cases the distinction between a property and an asset can be made 
using a simple rule: A property can belong to an asset, but an asset cannot 
belong to a property. For example, a duration cannot have a track. 
9 An item that is only connected to a single asset is always a candidate for be- 
coming a property. In contrast, an item that has other connections, too, 
must be modeled as an asset. Take for example: 
An album has one or several tracks of a given duration. 
track could be modeled as a property of project if we did not have the 
following: 
An album may have one or several samples. 
and 
A sample provides an MP3 URL for a track. 
There is a cross-reference between sample and track that could not be mod- 
eled if sample and track were properties, sample puts track in relation to an 
MP3 URL. So we must model both track and sample as separate assets, but we 
can model the MP3 URL as a property of sample. 
m Because AOM allows complex properties, we will find that complex informa- 
tion items that must be modeled in classical modeling methods as separate 
entities may be modeled as structured properties in AOM. This will result in 
a compact model. 
3.3.1 The Jazz Model 
Let's discuss the model, shown in Figure 3.1, from left to right. First, a style has 
a name. This is not mentioned in the informal description. Informal descrip- 
tions usually make assumptions about the background knowledge of the reader, 
for example, the knowledge that most things and concepts do have a name. So, 
we have introduced a name, and we have declared it as a key, assuming that the 
name of a style is unique. 
We have introduced two subproperties for the period, defining the start and 
the end of the period. Again, this stems from background knowledge. Periods 
do have a start and an end. At this point we do not determine how precise the 
start and end date should be. Here, for describing the period when a certain jazz 
style was dominant, it would be sufficient to specify both dates by year only. 
Alternatively, we could specify a period by giving a start date and the length of 
the interval. Notice that we have also introduced a description property. 
Although not required by the informal description, it may be useful to describe 
the style in a few words. 
The asset bel ongsTo establishes a relationship between a style and a jazz musi- 
cian. This is a many-to-many relationship because one jazz musician may 
belong to several styles during his or her life, and of course many jazz musicians 
belong to one style. This relationship is attributed again with a period, which 

3.3 Asset or Property? 
75 
Figure 3.1 The Jazz model, Draft 1. 
may differ from the period defined in the style. This attribute defines a period 
during which a given jazz musician belongs to a given style. 
The asset jazzMusieian does not have its own properties but inherits every- 
thing from the asset person. ]azzMusician itself is marked as an abstract asset, 
indicated by the solid label box. So there will be no ]azzMusician instances. 
Instances will be instrumental i sts, jazzComposers, or jazzSingers. 
The assets instrumentalist, jazzComposer, and jazzSinger have a property 
instrument. In case of an instrumentalist, this property is constrained by the 
cardinality [1..*] (+) because an instrumentalist has to play at least one instru- 
ment. The others are free to play as many instruments as they like, or not to 
play any instrument at all. 

76 
Chapter 3 Everybody Likes Jazz 
The definition of person is straightforward. At this stage we have declared the 
name property as a key, which will cause us some trouble later. We have made 
property birthDate optional because of The birth date may not be known. 
The asset influences relates jazz musicians to other jazz musicians. Again, this 
is a many-to-many relationship, as one musician can influence many others but 
also can be influenced by several others. For this asset, the definition of role 
names is mandatory to differentiate both arrows leading to jazzMusician. 
The asset produces describes the relationship between jazz musicians and solo 
albums. A jazzMusician may produce several solo albums, so this is a one-to- 
many relationship. 
The asset col laboration acts as a classification for the various concrete collab- 
orations such as jamSession, project, and band. Because it does not have its own 
instances, it is marked as abstract. Collaboration relates at least two jazz musi- 
cians (otherwise it wouldn't be a collaboration) to an unlimited set of albums. 
The modeling of album is straightforward. To identify an album uniquely, we 
have chosen both properties publisher and pr0ductN0 to form a composite key. 
Because composite keys must be named, we have given it the name a l bumKey. 
We have chosen to model the verb reviewed as a noun and to attribute it with 
a publishing date of the review. The result is asset review. This asset relates a 
critic, a magazine, and an album or jazz musician to each otherma ternary rela- 
tionship. The choice between album and jazz musician is modeled via a cluster. 
The asset critic inherits everything from asset person but overrides the prop- 
erty name because it needs only one occurrence of first. The modeling of asset 
magazine is straightforward. The assets band and project are very similar. Both 
have a name and a period during which they exist. We assume that the name is 
unique, so we use it as a key. 
The asset jamSession is different. A jam session is performed at a certain time 
and at a certain place. We have modeled this with property performedAt. Because 
we are not interested in a particular sequence of location and time, we have 
used the operator & here. We have declared performedAt as a key, which should 
be sufficiently unique. 
3.4 NORMALIZATION 
After we have obtained a first draft of our model, we should normalize it. Unlike 
relational technology, XML and object-oriented formats allow a physical data 
format that follows the structures of the actual business data very closely. There 
is no need to break complex information items into a multitude of "flat" tables. 
We will find that an XML document can represent a conceptual asset almost 
unmodified. This does not mean that no normalization is required. We must 
still make sure that our information model does not have redundancies, and 
that we end up with an implementation that not only consistently matches the 

3.4 Normalization 
71 
real-world relationships between information items but is also easy to maintain. 
We make sure that 
m Asset types are primitive; that is, their properties do not contain information 
structures that could be modeled as independent asset types. For example, 
the asset type album must not embed data from jazzMusician. 
[] Asset types are minimal; that is, they do not contain redundant properties, 
meaning none of their properties can be derived from other properties. For 
example, the asset type person must not contain a property age, as this can be 
derived from bi rthDate. 
[] Asset types must be complete; that is, other assets that may be present in the 
real-world scenario can always be derived from the asset types defined in the 
model. Our model is not complete. A jazz album typically lists the participat- 
ing musicians and which instruments each musician played on this album. 
This requires that we introduce a sentence like 
A jazz musician plays one or several instruments on an album. 
into our informal description and model it appropriately (see Section 3.5). 
[] Asset types must not be redundant; that is, none of the defined asset types in 
the model can be derived from other asset types in the model. In our exam- 
ple, we have a redundant asset. A band is a kind of project--the main differ- 
ence is that it exists over a longer period of time and probably produces more 
albums. On an informal level, there is a semantic difference between both, 
but structurally they are the same. 
We fix this by deleting the asset band. In order to allow instances of band, 
however, we decorate asset project with two display labels: band and project. 
The consequence is that in the schema, both are treated equally but in- 
stances can have either name. 
[] All asset types must have a unique meaning. 
[] Assets should have a key. Keys must be minimal; that is, they must consist of 
the smallest set of properties that can uniquely identify an instance. In our 
example, not every asset has a key. (For example, belongsTo, influences, re- 
view, critic, and magazine don't have a key.) We should introduce suitable 
keys for these assets, jazzMusician, instrumentalist, jazzSinger, and jazzCom- 
poser do not need their own key, because they inherit one from person. If an 
asset type does not have suitable properties that can act as keys, we can eas- 
ily equip them with some kind of a unique property (for example, by gener- 
ating a UUID for each instance). 
In particular, keys are required when an asset has outgoing arcs and we 
plan to implement the model in a relational environment. Here, in our XML 
environment, it is very likely that we will implement the triangle album, 
track, sample with relational techniques (such graphs cannot be reduced to 
tree structures). Therefore we equip asset track with a new property trackN0 
that we declare as a key. 

18 
Chapter 3 Everybody Likes Jazz 
3.5 PARTITIONED NORMAL FORM 
While the steps mentioned before result in a pretty robust model, there is one 
more thing we can do. Assets ultimately result in XML elements or documents, 
and can thus be subject to transformations (for example, via an XSLT 
stylesheet). To make the keys robust against such transformations, we should 
make sure that each asset is in Partitioned Normal Form (PNF). 
An asset type or property is in Partitioned Normal Form (PNF) if the atomic 
properties of an asset constitute a key of the asset and all non-atomic proper- 
ties and subproperties are in Partitioned Normal Form themselves. 
Or, in other words: 
All complex structures in the model (assets and complex properties) must 
have atomic child nodes that can act as a key. 
What is the PNF good for? If we plan to store assets in relational databases, 
PNF is essential. Relational technology requires us to fragment all complex 
structures into flat relational tables. Keys that span complex structures would be 
lost during such a transformation to First Normal Form (1NF) (see Section 11.5). 
But also in an XML environment, keys constituted from atomic fields are a good 
idea. For cross-references, XML Schema allows multifield keys (see Section 
5.3.17), but each field must be atomic. DTDs and Relax NG, however, are even 
more limited: They allow only a single atomic field as a key for cross-references. 
In our example, the following assets are not in PNF: 
[] person, because the key name(first,middle?,last) is a composite. A solution 
would be to introduce a personal ID. Here, we opt to introduce an atomic 
ID composed from last name, middle name, and first name, such as Min- 
gusCharl es. 
[] jamSession, because the key performedAt(time&location) is a composite. Here, 
we opt for a different solution. We resolve the property performedAt into two 
independent properties: time and location. These two properties are atomic 
and can thus constitute a multifield primary key that conforms to PNF. An 
implementation of this key with DTDs or Relax NG would, however, cause 
troubles because these schema languages do not support multifield keys. 
Because AOM requires us to name a composite key, we decorate this key 
with the name j sKey. 
Figure 3.2 shows our conceptual Jazz model after we have applied the 
changes suggested by normalization. We have made the following changes: 
m Removed the redundancy between assets band and project by deleting as- 
set band and decorating asset project with the two display labels band and 
project. 
[] Introduced a new property ID into asset person and declared it as the primary 
key. 

3.5 Partitioned Normal Form 
79 
Figure 3.2 The Jazz model, Draft 2. 
m Resolved property performedAt in asset jamSession into time and location. 
We declared the combination of these two properties as a primary key and 
named it j sKey. 
m Introduced a new asset p lays that relates albums and jazz musicians. It is at- 
tributed with an instrument property. At least one instrument must be speci- 
fied. (For a jazz singer, that would be "vocals.") 
m Factored out the definition of complex property period into an abstract asset 
period. We use this asset as a type definition. We have also improved this def- 
inition by making the subproperty to optional. This allows us to model peri- 
ods that have not ended yet. 

80 
Chapter 3 Everybody Likes Jazz 
3.6 RESOLVING is a RELATIONSHIPS 
In the next step we "flatten" the model by resolving some of the i s_a relation- 
ships. We do this to prepare the model for implementation with different tech- 
nologies. While object-oriented technologies are well suited to capture deep 
hierarchies of superclasses and subclasses (although this may sometimes result 
in less than well maintainable implementations), the implementation of such 
data structures with relational technology or with XML would be rather awk- 
ward. XML Schema does support inheritance relationships between data types 
(although only single inheritance), but it does not support inheritance between 
document nodes. 
For the purpose of manual conversion of the Jazz model into XML schemata 
(see Chapter 8), it is a good idea to resolve the i sa relationships wherever this 
is possible. When using a modeling tool such as KLEEN [KLEEN2002], this step 
should not be necessary because the modeling tool should be able to resolve 
inheritance relations before generating code. 
We have the following options: 
[] Explicitly copy the features of the parent into the child asset types, then re- 
move the parent asset. For example, we could copy the arcs and properties 
of asset type collaboration into the asset types jamSession and project. This 
would also allow us to sharpen the cardinality constraints for jamSession" A 
jam session produces at most one album. 
For asset jazzMusician, this operation would be far from simple, despite 
the fact that there are no properties to inherit. We would also need to copy 
the incoming and outgoing arcs. For the incoming arcs (from influence, col- 
I aboration, produces, plays, bel ongsTo), we would need to introduce clusters at 
the origin point of each arc. 
[] Fold the child assets into the parent asset. This is possible when the children 
don't differ very much from each other. The result is a very compact model. 
Take for example instrumentalist, jazzSinger, and jazzComposer. These as- 
sets only differ in the cardinality of instrument. If we can tolerate losing that 
differentiation (we could later remedy this loss by introducing an explicit 
constraint), we move instrument into the parent asset jazzMusician, then re- 
move the children. The cardinality of instrument is set to "*" (obtained by 
union of the individual cardinalities). 
What remains is to introduce a feature that indicates the type of the child 
instance. Here we have two options: 
[] Create a property that specifies the instance type. For example, we can indi- 
cate instrumentalist, jazzSinger, and jazzComposer by an extra property 
named kind. We can declare the property as an enumeration type with the 
values instrumental ist, jazzSinger, and jazzComposer. Note that with this ap- 

3.7 Introducing Level 2 Structures 
81 
proach, the asset instances are no longer named instrumental i st, jazzSinger, 
and jazzComposer, but jazzMusician. 
To remedy the cardinality problem, we can introduce a constraint saying 
that kind must either be different from "instrumentalist" or there must be at 
least one instrument child. 
kind ! = instrumentalist or count(instrument) > 0 
[] Indicate the child type by display labels in the parent type. For example, we 
could add three display labels instrumentalist, jazzSinger, and jazzComposer 
to jazzMusician. Instances of jazzMusician would then be instrumentalist, 
jazzSinger, or jazzComposer instances. 
To remedy the cardinality problem, we can introduce a constraint: 
not(self::instrumentalist) or count(instrument) > 0 
For asset jazzMusician, the second option (using multiple display labels) 
would be the most elegant option. But for tutorial purposes the additional prop- 
erty kind is created. 
After applying these operations, our model would look like Figure 3.3 
(page 82), which reflects the following changes: 
[] We have combined the assets instrumentalist, jazzComposer, and jazzSinger 
into a generic asset jazzMusician. In this asset we have introduced a new 
property, ki nd. The (yet undefined) type of this new property is restricted by 
the enumeration instrumentalist, jazzComposer, jazzSinger. To capture the 
restriction for instrumentalists, we have defined an explicit constraint. 
[] We have resolved the abstract asset collaboration into the concrete assets 
jamSession and project. These assets only inherited arcs from collaboration; 
there were no properties to inherit. 
[] We did not resolve abstract asset person into the concrete assets jazzMusician 
and critic. This would introduce too many redundant definitions into the 
model. We also want to keep at least one abstract asset, to see how we can 
deal with it later, during implementation. 
3.7 INTRODUCING LEVEL 2 STRUCTURES 
In our model we use Level 2 Structures (L2S) to model business objects. Business 
objects are assets that play a prominent role in our scenario. Identifying a busi- 
ness object requires that we have an idea not only about the structure of the 
information, but also about the purpose of that information. 
In our example, all jazzMusician asset types, style, all collaboration asset 
types, album, and review could be L2S. Jazz musicians are clearly the most impor- 
tant topic in our knowledge base, but similarly important are style and the var- 
ious collaborations, al bum could play a role if we plan to connect our knowledge 
base with an online shop for CDs. The asset magazine does not play a prominent 
role in our scenario; therefore, we include it in the L2S review. 

82 
Chapter 3 Everybody Likes Jazz 
Figure 3.3 The Jazz model, Draft 3. 
After determining all the dominant assets in our model, we group the 
remaining assets around these selected assets, demarcate these groups with a 
Level 2 box, and arrive at the diagram shown in Figure 3.4. 
Remember the constraint that must be enforced when constructing L2S from 
assets: 
Starting from the identifying asset of an L2S, we must be able to reach any 
asset belonging to that L2S by following the arcs in the indicated direction. 
This constraint will allow us to interpret each L2S as an aggregation and later 
make it easy to implement the L2S in the form of hierarchical data models such 
as XML documents. 

3.7 Introducing Level 2 Structures 
83 
Figure 3.4 The Jazz model, Draft 4. 

114 
Chapter 3 Everybody Likes Jazz 
When we check this constraint for our model, we encounter three problems: 
m From the assets bel0ngsTo and influences, both arrows lead to asset jazzMusi- 
cian. This is bad, because when starting at jazzMusician, we cannot reach be- 
10ngsT0 and influences. 
m Asset produces cannot be reached from jazzMusician. 
m Asset plays cannot be reached from album. 
To solve these problems, we simply reverse one of the arcs for each of the 
assets belongsTo and influences. This results in a slightly different interpretation. 
We are now saying: 
A jazzMusician has a "belonging" to a style. 
and 
A jazzMusician has influences from other jazz musicians. 
In the case of influences, the decision as to which of the two arrows to reverse 
depends on which jazz musician should be assigned influence assets: the one 
who is influenced, or the one who influences others. It is better to take the first 
option: Jazz musicians might tell you who influenced them, but they are not 
likely to tell you who they influenced. 
We also reverse the arcs leading from album to plays and from jazzMusician to 
produces. We decorate each reversed arc with an asterisk to remove any cardi- 
nality constraint and remove its role name. 
We also take the opportunity to fix a problem with keys. The asset review def- 
initely needs a key, because it is an identifying asset of L2S review. The identify- 
ing asset of an L2S should indeed always have a key, because otherwise, 
instances of such an L2S could become inaccessible when stored in a database. 
We therefore have introduced a property ID for asset review, which could be a 
generated identifier such as a UUID or a URL for a web page. Figure 3.5 shows 
the results. 
There is still one problem with asset influence: Jazz musicians hardly influ- 
ence themselves, but this is exactly what we have specified. Remember that arcs 
that are local to an L2S are also local to instances of the L2S. To allow a jazz 
musician to be influenced by other jazz musicians, we must loosen the range 
constraint of the arc i nfluencedBy. We do this by decorating this arc with 
>jazzMusician (the display name of the L2S). 
Structurally, our conceptual model is now complete. We finish the definition 
of the model by rendering a few more details, such as global model settings 
(default namespace, default type system, and default constraint language), and 
by decorating atomic properties with data types from XML Schema (see Section 
5.2). There is one exception: Later, we want the property descri pti on to contain 
complex XHTML content, but at the moment we do not want to specify this 
further. We therefore extract this property as an empty asset for later detailing. 
Figure 3.6 (page 86) shows the results. 

3.7 Introducing Level 2 Structures 
85 
Figure 3.5 The Jazz model, Draft 5. 

Chapter 3 Everybody Likes Jazz 
Figure 3.6 The Jazz model, final draft. 

.--I 

This Page Intentionally Left Blank

4.1 
4.2 
4.3 
4.4 
Namespaces 
The XML Information 
Model 
XML Canonical Form 
The Document Type 
Definition (DTD) 
I 
n this part of the book we will implement the conceptual 
models that we have developed in Part I as XML schemata in 
three ways~in the form of DTDs, in XML Schema, and in Relax 
NG. But before we do so, an overview of the concepts and facil- 
ities of all three schema languages is presented. 
This chapter deals with the DTD as it is defined in the XML 
1.0 specification [Bray2000]. But before we go into the DTD 
details, we will look at some advanced XML topics, such as XML 
namespaces, the XML information model, and canonical XML. 
A good understanding of namespaces and the XML Information 
Set is essential for appreciating the various features in XML 
Schema definition languages. 
This discussion assumes that you are already familiar with the 
XML syntax. If not, there are many excellent books that provide 
an introduction to XML. 
89 

90 
Chapter 4 XML Basics 
4.1 NAMESPACES 
XML namespaces are defined in [Bray1999]. Namespaces are important for 
schema composition. Using namespaces helps to avoid name conflicts. Take for 
example a document that includes parts described by different document stan- 
dards, such as XHTML, SVG, SMIL, SOAP, and your own schema definitions. 
Without namespaces it would be almost impossible to avoid name clashes. For 
this reason I recommend that you always define a target namespace with a 
schema, and I discourage the use of DTDs for schema definition. 
Namespaces must be declared in an XML document instance with the help 
of the xml ns attribute or an attribute with the prefix xml ns:. The first defines the 
default namespace; the second defines namespaces that are associated with a 
namespace prefix. For example: 
xml ns ="http://www. w3. org/2001/XMLSchema" 
defines the XML Schema namespace as the default namespace. In contrast, 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
associates the XML Schema namespace with the prefix xs:. 
The scope of such a namespace definition is the element where it is defined 
plus all child elements (unless a child element overrides it with another name- 
space declaration). So, if we declare namespaces in the root element of a docu- 
ment, their scope is usually the whole document. 
We say that the name of an element is qualified if the element is within the 
scope of a default namespace declaration, or if its name is specified with a 
namespace prefix. Attributes are qualified if they are specified with a namespace 
prefix. (Default namespaces do not apply to attributes.) For example: 
<customer xml ns="http://www, ni I e. com/customers" 
xml ns: a="http://www, ni I e. com/addresses" 
customerNo =''BD023432''> 
<name> 
<first>John</first> 
<l ast>Doe</l ast> 
</name> 
<a: address> 
<a:street>747 Sunset Strip</a:street> 
<a" town>Mi ami </a" town> 
<a: zi p>99999</a: zi p> 
<a: state>FL</a: state> 

4.2 The XML Information Model 
91 
<a: country>USA</a: country> 
<a : address> 
</customer> 
In this example all elements are qualified. The ones without a prefix belong 
to namespace http://www, ni 1 e.c0m/customers, and the ones with prefix a: belong 
to namespace http://www.nile.com/addresses. The attribute customerNo is not 
qualified. 
Care must be taken if documents are composed from multiple entities (see 
Section 4.4.6). If namespace declarations were contained in an unexpanded 
entity (see Section 4.2.6), they would not be visible and the whole document 
would not be processed correctly. 
4.2 THE XML INFORMATION MODEL 
The principal information model of XML is defined in a W3C recommendation 
called the "XML Information Set" [Cowan2001]. The XML Information Set is 
independent of the actual representation of a document; the document may 
exist in the serialized form of an XML text file, in the form of a DOM tree, in 
the form of Java objects, and others. So, for the discussion of the XML informa- 
tion model, the concrete XML syntax is irrelevant. 
In its current state this recommendation describes the abstract data model 
of the XML 1.0 recommendation [Bray2000], including XML namespaces 
[Bray1999], but does not cover new features introduced with XML Schema. In 
particular, it does not support type definitions for elements. For attributes, only 
those types that can be defined with a DTD are featured. Also, there is no sup- 
port for the advanced integrity constraints that can be defined with XML 
Schema such as the key, keyref, and unique clauses (see Section 5.3.17). 
4.2.1 Overview 
Table 4.1 (page 92) lists all the information items that constitute the XML Infor- 
mation Set, with examples in serialized XML form. The XML Information Set 
has a tree structure, with the nodes of the tree made up of the information 
items in Table 4.1. Figure 4.1 (page 94)shows the structure of the XML Informa- 
tion Set using the AOM modeling language defined in Chapter 2. 
Note that the information set of a document instance defined under a DTD 
changes when a DTD-aware parser processes the document. Default and fixed 
values declared in the DTD may change the value of attributes in the document 
instance. Attributes declared in the DTD may be added to the attribute set of a 
document element in the document instance. Notations and unparsed entities 
declared in the DTD are added to the document node of the document 
instance. If this additional information is contained in an external DTD subset 
and the parser chooses to use this information (nonvalidating parsers are free to 

92 
Chapter 4 
XML Basics 
Table 4.1 Information items of the XML Information Set. 
Information Item 
Description 
Attribute 
Character 
Comment 
Document 
Document type 
declaration 
Element 
Namespace 
Notation 
Attributes can be specified with elements. 
Example: 
<order orderDate="2002-05-03">... </order> 
Characters that appear in the content of an element, as a 
character reference, or in a CDATA section are first-order 
information objects in the XML information model. 
Example: 
<I ast>Brubeck</l ast> 
A comment block within a document. 
Example: 
<!--Schema created by KLEEN XSD generator version 0.01--> 
The whole document entity. 
Example: 
<?xml version="1.0" encoding="OTF-8"?> 
<order> 
</order> 
A declaration that defines the type of a document. A document 
type declaration can define an internal subset and a reference to 
an external subset (DTD). 
Example: 
<!DOCTYPE book SYSTEM 
"http://www. book. org/book"> 
Either the root element of a document or a child element of 
another element. 
Example: 
<name> 
<l ast>Brubeck</l ast> 
</name> 
A definition that establishes a separate space for element names 
in order to avoid name conflicts. 
Example: 
<xs: schema 
xml ns: xs=" http://www, w3. org/200 i/XMLSchema"> 
The notation declaration serves as an extension mechanism. It 
allows you to associate an internal name with an external or 
public identification. 
Example: 
<!NOTATION jpeg SYSTEM "viewer.exe"> 
(continued) 

4.2 The XML Information Model 
93 
Table 4.1 Continued 
Information Item 
Processing 
instruction 
Unexpanded 
entity 
Unparsed entity 
Description 
An instruction that advises XML processors about actions to 
take. 
<?xml :stylesheet type="text/xsl" 
href="xml -shockwave. xs I "?> 
An entity reference that for some reason could not be expanded. 
Example: 
<!ENTITY smallprint SYSTEM 
"http://www. shady, org/l ega1404, xml "> 
Unparsed entities are non-XML entities, such as images, audio 
files, binaries, etc. 
Example: 
<!ENTITY picture SYSTEM 
"http://www.jazz.org/el I ington.jpg" NDATA jpeg> 
make use of an external DTD or not), the information set of the document 
instances changes. 
Similarly, a schema defined with XML Schema may change the information 
set of a document instance: Default and fixed values declared in the DTD may 
change the value of attributes and elements in the document instance. Attributes 
declared in the DTD may be added to the attribute set of a document element in 
the document instance. 
The following sections discuss each of these information items in detail. 
4.2.2 Document Node 
An XML document is defined as a document node in its own right. This node 
has the following properties: 
[] Children. A document node can own exactly one element node--the root el- 
ement, also called document element. Besides this element, a document node 
can contain other child nodes: processing instructions, comments, and a 
document type declaration. Processing instructions and comments defined 
in the Document Type Definition (DTD) are not included in the information 
set of the document node. (Processing instructions defined in the Document 
Type Definition are child nodes of the document type declaration node, dis- 
cussed in Section 4.2.9.) 
[] Document element. The root element of the document. This element con- 
tains all other document elements as children, grandchildren, and further 
descendants. 

94 
Chapter 4 XML Basics 
unparsedEntity 
name 
systemldentifier 
publicldentifier 
declarationBaseURI 
Name 
Namespaces 
XML Information Set 
http://www.w3.org/TR/xml-infoset 
Ii tati~ 
ame 
ystemldentifier 
ublicIdentifier 
eclaration BaseU RI 
documentTypeDeclaration 
systemldentifier 
publicldentifier 
] child 
processinglnstruction 
target 
content 
baseURI 
notation 
rcomment 
]i 
" 
[.content 
arent 
Ii nexpandedEntity 
~ * 
ame 
ystemldentifier 
ublicldentifier 
parent 
eclarationBaseURI 
Ii haracter 
1 ~ * 
haracterCode 
lementContentWhitespace 
parent 
child 
child 
child 
child 
document 
baseURI 
characterEncodingScheme 
standalone 
version 
J 
documentElement ~F~ 
parent 
.~lement 
namespaceName 
IocalName 
prefix 
baseURI 
J 
J 
-~1- ~ 
e- 
e- 
J 
J 
reference 
reference 
in-scopeNames 
p amespace 
~J 
E I prefix 
~- LnamespaceName 
attribute 
namespaceName 
IocalName 
prefix 
normalized value 
specified 
attributeTy~ 
ownerElement j 
Figure 4.1 Metamodel of the XML Information Set. 

4.2 The XML Information Model 
95 
[] Notations. An unordered set of notation information items, one for each no- 
tation declared in the DTD (see Section 4.2.11). 
[] Unparsed entities. An unordered set of unparsed entity information items (see 
Section 4.2.10), one for each unparsed entity declared in the DTD. 
[] Base URL The base URI of the document entity. Base URIs can be specified ex- 
plicitly with the xml :base attribute as defined in the "XML Base" recommen- 
dation [Marsh2001]. 
[] Character encoding scheme. The code system used for this document. By de- 
fault, XML uses the UTF-8 code system for character encoding. However, it is 
possible to declare other code systems such as UTF-16 for a document. In an 
XML file this is done with an encoding declaration in the document prolog: 
<?xml version="1.0" encoding="UTF-16 '' standal one= "yes " ?> 
[] Standalone. An indication of the standalone status of the document. The 
value "true" indicates that a document does not rely on external markup def- 
initions such as default values or entity declarations. 
[] Version. The XML version of the document, currently 1.0. 
4.2.3 Elements 
Element nodes may have one or several child nodes. They can be other ele- 
ments, attributes, processing instructions, comments, character data, unparsed 
and unexpanded entities, and in-scope namespaces. Elements can repeat within 
a context, except the document element, which must occur exactly once. 
An element has the following properties: 
m Namespace name. The name of the namespace of the respective element type. 
The chosen namespace name should be globally unique. 
[] Local name. The local part of the element type name (excluding namespace 
prefix). 
[] Prefix. The namespace prefix in the element type name. This prefix serves as 
a shorthand notation for the element's namespace. 
[] Children. An ordered list of child nodes. This can be other elements, process- 
ing instructions, unexpanded entities, characters, and comments. 
[] Attributes. An unordered set of attribute information items, one for each at- 
tribute (either specified in the document instance or defaulted from the 
DTD). 
[] Namespace attributes. An unordered set of attribute information items, one for 
each namespace declaration (specified or defaulted from the DTD). Name- 
space attributes are declared by using the prefix xml ns:. For example, 
<xs: schema 
xml ns: xs=" http://www, w3. org/2001/XMLSchema"> 
defines a namespace attribute for the XML Schema namespace. This attribute 
is owned by the <xs:schema> element. 

96 
Chapter 4 XML Basics 
In addition, a declaration of the form xml ns-" ", which undeclares the de- 
fault namespace, counts as a namespace attribute. 
[] In-scope namespaces. An unordered set of namespace information items, one 
for each of the namespaces in effect for this element. These are not only 
namespaces that have been declared with this element but also namespaces 
that have been declared with parent elements, or the default namespace. In 
addition, XML's own namespace, http://www, w3. org/XML/1998/namespace, with 
the prefix xml, belongs to the in-scope namespaces. 
[] Base URI. The base URI of the element. Base URIs can be specified explicitly 
with the xml :base attribute, as defined in the "XML Base" recommendation 
[Marsh2001]. 
[] Parent. A reference to the parent node, either the document node or an ele- 
ment node. 
4.2.4 Attributes 
The attribute nodes of an element always form an unordered list--that is, it is 
not possible to make statements about the order in which the attributes of an 
element occur. Attributes are always leaf nodes; they do not have child nodes. 
Each attribute has a local name and can have a namespace identifier. The local 
name (also, the combination of local name and namespace identifier) is not 
required to be unique within a document: Attributes with the same name may 
appear in different contexts in a document (under different owner elements). 
Attributes must not repeat within a context. 
Attributes have the following properties: 
[] Namespace name. The name of the namespace of the respective attribute type. 
n Local name. The local part of the attribute type name (excluding namespace 
prefix). 
m Prefix. The namespace prefix in the attribute type name. 
n Normalized value. The normalized attribute value, consisting of a normalized 
character string. A character string is normalized by reducing whitespace 
within the string to a single whitespace character and by removing any 
whitespace from the beginning and end of the string. 
m Specified indicator. Indicates whether this attribute was actually specified in 
the start tag of its element, or if it was defaulted from the DTD. 
m Attribute type. An indication of the type declared for this attribute in the 
DTD. Legitimate values are ID, IDREF, IDREFS, ENTITY, ENTITIES, NM- 
TOKEN, NMTOKENS, NOTATION, CDATA, and ENUMERATION (see Section 
4.4.3). 
[] References. An attribute may refer to another document item depending on 
its type: 
Attributes of type IDREF and IDREFS refer to elements. 
Attributes of type ENTITY, ENTITIES refer to unparsed entities. 
Attributes of type NOTATION refer to notation items. 
[] Owner element. A reference to the element that owns the attribute. 

4.2 The XML Information Model 
97 
4.2.5 Processing Instructions 
Processing instructions are evaluated by XML processors. For example, a pro- 
cessing instruction can cause a web browser to invoke an XSLT processor to 
convert the document into HTML: 
<?xml -Stylesheet href="convert.xsl" type="text/xsl "?> 
A processing instruction information item has the following properties: 
[] Target. A string representing the target part of the processing instruction. In 
the example above, this is xml :Stylesheet. 
[] Content. A string representing the content of the processing instruction. In the 
example, href="c0nvert.xsl" type="text/xsl ". 
[] Base URI. The base URI of the processing instruction. Base URIs can be speci- 
fied explicitly with the xml :base attribute, as defined in the "XML Base" rec- 
ommendation [Marsh2001]. 
[] Notation. The notation information item named by the target (see Section 
4.2.11). 
[] Parent. A reference to the element that contains the processing instruction. 
4.2.6 Unexpanded Entity Reference 
Normally, the information set describes an XML document with all parsed enti- 
ties expanded. However, there may be cases when a processor chooses not to 
expand an entity, for example, when the entity definition is not accessible. In 
this case, the entity is represented by an unexpanded entity information item 
with the following properties: 
m Name. The name of the entity referenced. 
m System identifier. The system identifier of the entity. 
m Public identifier. The public identifier of the entity, consisting of a normalized 
character string. A character string is normalized by reducing whitespace 
within the string to a single whitespace character and by removing any 
whitespace from the beginning and end of the string. 
[] Declaration base URL The base URI relative to which the system identi- 
fier should be resolved (that is, the base URI of the resource within which 
the entity declaration occurs). Base URIs can be specified explicitly with 
the xml :base attribute, as defined in the "XML Base" recommendation 
[Marsh2001]. 
9 Parent. A reference to the element that contains the unexpanded entity 
reference. 
4.2.7 Character 
There is a character information item for each data character that appears in the 
document, whether literally, as a character reference, or within a CDATA sec- 
tion. A character information item has the following properties: 

98 
Chapter 4 XML Basics 
[] Character code. The ISO 10646 (Universal Multiple-Octet Coded Character Set 
(UCS)) character code. The character code ranges from 0 to #xl0FFFF, though 
not every value in this range is a legal XML character code: 
#x9 I #xA I #xD I [#x20-#xD7FF] I 
[#xEOOO-#xFFFD] I [#xIOOOO-#xlOFFFF] 
This is the complete range of Unicode characters except xFFFE and xFFFF. 
[] Element content whitespace. A Boolean indicating whether the character is 
whitespace appearing within element content. 
[] Parent. A reference to the element that contains the character. 
The XML Information Set specification does not specify how these character 
information items are aggregated in text nodes. This has resulted in various 
incompatible text node implementations. For example, XPath combines all 
characters within a node in a text child node, while DOM allows several text 
fragment child nodes. (DOM Level 3 remedies this situation by introducing an 
additional attribute, whol eText.) 
4.2.8 Comment 
A comment information item has the following properties: 
[] Content. A string representing the content of the comment. 
[] Parent. A reference to the element that contains the comment. 
4.2.9 Document Type Declaration 
If the XML document has a document type declaration, then the information 
set contains a single document type declaration information item, which has 
the following properties: 
m System identifier. The system identifier of the external DTD subset. 
m Public identifier. The public identifier of the external DTD subset, consisting of 
a normalized character string. A character string is normalized by reducing 
whitespace within the string to a single whitespace character and by remov- 
ing any whitespace from the beginning and end of the string. 
[] Children. An ordered list of processing instruction information items repre- 
senting processing instructions appearing in the DTD. 
[] Parent. A reference to the document node that contains the document type 
declaration. 
4.2.10 Unparsed Entity 
There is an unparsed entity information item for each unparsed general entity 
declared in the DTD. Unparsed entities are non-XML entities, such as images, 

4.2 The XML Information Model 
99 
audio files, and binaries. An unparsed entity information item has the following 
properties: 
[] Name. The name of the entity. 
[] System identifier. The system identifier of the external subset. 
[] Public identifier. The public identifier of the external subset, consisting of a 
normalized character string. A character string is normalized by reducing 
whitespace within the string to a single whitespace character and by remov- 
ing any whitespace from the beginning and end of the string. 
[] Declaration base URL The base URI relative to which the system identi- 
fier should be resolved (that is, the base URI of the resource within which 
the entity declaration occurs). Base URIs can be specified explicitly with 
the xm] :base attribute, as defined in the "XML Base" recommendation 
[Marsh2001]. 
[] Notation. The notation information item named by the notation name (see 
next section). 
4.2.11 Notation 
There is a notation information item for each notation declared in the DTD. 
Notations are used to identify the format of unparsed entities, the format of 
attributes declared with type NOTATION, and the processor for a processing 
instruction. A notation information item has the following properties: 
[] Name. The internal name of the entity. 
[] System identifier. The system identifier of the referenced entity. 
[] Public identifier. The public identifier of the referenced entity, consisting of a 
normalized character string. A character string is normalized by reducing 
whitespace within the string to a single whitespace character and by remov- 
ing any whitespace from the beginning and end of the string. 
[] Declaration base URL The base URI relative to which the system identi- 
fier should be resolved (that is, the base URI of the resource within which 
the entity declaration occurs). Base URIs can be specified explicitly with 
the xm] :base attribute, as defined in the "XML Base" recommendation 
[Marsh2001]. 
4.2.12 Namespace 
Each element in the document has a namespace information item for each 
namespace that is in scope for that element (see Section 4.2.3). A namespace 
information item has the following properties: 
[] Prefix. The prefix whose binding this item describes. Syntactically, in a name- 
space declaration this is the part of the attribute name following the xml ns: 
prefix. 
[] Namespace name. The URI of the namespace to which the prefix is bound. 

100 
Chapter 4 XML Basics 
4.2.13 An Example 
For the following (very small) XML document, let's discuss the XML Informa- 
tion Set. 
<j :album xmlns:j="http://www.jazz.org/encyclopedia" 
productNo=" 1064"> 
<j : publ i sher>http://www, ecmrecords, com</j : publ i sher> 
</j : al bum> 
Document Mode 
The document node has only one child node: the element j:al bum. This is also 
the document element. There are no notations or unparsed entities. There is no 
explicit base URI specification, so the base URI defaults to the actual location of 
the document that we assume at http://www.jazz.org/albums/. There is also no 
explicit XML prolog, so the default values apply for the XML version, the encod- 
ing scheme, and the standalone attribute: "1.0," "UTF-8," and "yes." 
Elements 
Element j :album has several child nodes: the namespace attribute xmlns:j, the 
attribute productN0, the child element j :publisher, and several whitespace char- 
acters, j-al bum has the namespace name of "http://www.jazz.org/encyclopedia," 
the local name is "album," the prefix is "j." There is a single in-scope namespace 
"http://www.jazz.org/encyclopedia." There is no explicit base URI specification, 
so the base URI is inherited from the parent node that is the document node. 
Element j:publisher has 25 child nodes: the characters of "http://www 
.ecmrecords.com." j :publisher has the namespace name of "http://www.jazz.org 
/encyclopedia," the local name is "publisher," the prefix is "j." There is a single 
in-scope namespace "http://www.jazz.org/encyclopedia." There is no explicit base 
URI specification, so the base URI is inherited from the parent node, which is the 
element j : a] bum. 
Attributes 
The 
attribute 
productN0 
has 
the 
namespace name "http://www.jazz.org 
/encyclopedia," which it has inherited from its owner element j :album. The local 
name is "productNo," but there is no namespace prefix. The normalized value is 
"1064," the specified indicator is "true," the attribute type has no value. The 
attribute does not refer to other document items. 
Characters 
There are 25 non-whitespace character nodes and several whitespace characters 
(line feeds, carriage returns, and blanks) contained in the document. Each char- 
acter is coded under ISO 10646. The whitespace characters all belong to parent 
element j :album, while the non-whitespace characters belong to parent element 
j :publ i sher. For the whitespace characters, the whitespace indicator is set to true. 

4.3 XML Canonical Form 
101 
Namespaces 
There is one namespace defined in this documentm"j" is the prefix, and 
"http://www.jazz.org/encyclopedia" is the namespace name. 
4.3 XML CANONICAL FORM 
The XML Information Set as discussed above represents XML documents in an 
abstract form. The lexical form of an XML document allows many variations for 
the same content. For example, attributes may appear in arbitrary order, redun- 
dant namespace declarations are possible, character content may be expressed 
with or without CDATA, and so on. This makes it difficult for humans and 
machines to determine whether two given XML documents are equivalentm 
not identical by the letter but equivalent by content. And this is not the only 
problem. Cryptographic methods used by message digests and digital signatures 
rely on the textual representation of a document. With different text represen- 
tations, equivalent documents would, for example, have different digital signa- 
tures. The proposed W3C recommendation "XML-Signature Syntax and 
Processing" [Eastlake2002] therefore relies on the existing methods for produc- 
ing canonical XML. 
The W3C recommendation "Canonical XML" [Boyer2001] defines a canoni- 
cal form for XML documents, a syntactical form that allows simple character 
string comparison of two XML documents. However, this recommendation 
does not cover the new features introduced with XML Schema, such as the 
canonical form for the various new data types. Therefore, XML Schema itself 
defines a canonical form for the lexical representation of all built-in data types 
defined in XML Schema. 
4.3.1 Canonical Text 
Acceptable forms of text in XML documents meet the following requirements: 
[] Canonical XML documents are always encoded in UTF-8. 
[] All line breaks are normalized to #xA. 
[] Character entity references are resolvedmthat is, they are replaced by the ref- 
erenced entities. Here, the character entity eur0 is replaced with its definition 
in the ENTITY clause: 
Noncanonical 
Canonical 
<...!ENTITY euro #x2OAC> 
<pri ce>&euro; 50. O0</pri ce> 
<pri ce>&#x2OAC; 50. O0</pri ce> 
m Canonical text does not contain the characters &, <, >, nor the carriage return 
character (# 
These characters are replaced by &amp;, &lt;, &gt;, and &# 

102 
Chapter 4 XML Basics 
[] CDATA sections are replaced with their character content. Here, the CDATA 
wrapping around the if instruction is removed. By doing so, the unparsed 
character data becomes parsed character data, so we have to replace < with 
&It;. 
Noncanonical 
Canonical 
<! ECDATAE 
if (pubYear < 100) 
pubYear+=1900; 
]]> 
if (pubYear &It; 100) 
pubYear+=1900; 
4.3.2 Canonical Whitespace 
Acceptable forms for whitespace in canonical XML documents meet the follow- 
ing requirements: 
m Whitespace outside of the document element and within start and end tags 
is normalized. (A character string is normalized by reducing whitespace 
within the string to a single whitespace character and by removing any 
whitespace from the beginning and end of the string.) 
m Attribute values are normalized; that is, whitespace within the attribute value 
string is reduced to a single whitespace character, and whitespace at the be- 
ginning and end of the string is removed. 
m All whitespace in character content is retained (excluding characters re- 
moved during line feed normalizationnsee above). Here, all whitespace 
within tags, and within the value of attribute ref, is normalized: 
Noncanonical 
Canonical 
<al bum > 
<al bum> 
<title>So 
long</titl e> 
<title>So 
Iong</title> 
<reviews 
ref="rl 
r2"> 
<reviews ref="rl r2"> 
</ 
al bum> 
</al bum> 
4.3.3 Resolved References 
The resolution of parsed entity references involves the following steps: 
m Parsed entity references are replaced by the referenced entities. 
m Default attributes and fixed attributes are added to each element if not al- 
ready present. Here, we have resolved entity 1 egal D0c with the content of the 
file http://www.book.org/modules/legal to which it refers. We have also in- 
cluded the default value of attribute review in the document content. 

4.3 XML Canonical Form 
103 
Noncanonical 
<!ENTITY legalDoc SYSTEM 
"http://www. book. org/modul es/l egal "> 
<!ATTLIST review 
versi on CDATA "1.0"> 
<revi ew> 
Buy this book! 
&legaldoc; 
</review> 
Canonical 
<review version=" 1.0"> 
Buy this book! 
<legal>This article does not 
express the opinion of its 
author.</l egal> 
</review> 
4.3.4 Removal of Redundant Nodes 
In canonical XML, the XML declaration and Document Type Definition (DTD) 
are removed. The XML declaration is no longer necessary since the canonical 
document is always a standalone document in UTF-8 code. The DTD is no 
longer necessary, as all default and fixed values and all referenced entities have 
been resolved. 
Redundant namespace nodes are also removed. An element's namespace 
node is redundant when the nearest parent element has a namespace node in 
the node-set with the same local name and value. Here, we have removed the 
namespace declaration in element title because the parent element book 
already declared the same namespace. We have also removed the XML declara- 
tion and the D0CTYPE declaration. 
Noncanonical 
Canonical 
<?xml version="1.0"?> 
<!DOCTYPE book SYSTEM 
"ht tp://www, book. org/book "> 
<book xml ns= 
"http://www. book. org"> 
<title xml ns= 
"http://www. book. org"> 
The light of the day 
</title> 
</book> 
<book xml ns="http://www, book. org> 
<title> 
The light of the day 
</title> 
</book> 

104 
Chapter 4 XML Basics 
4.3.5 Canonical Elements 
The child nodes of an element (elements, attributes, processing instructions, 
comments, character data, unparsed and unexpanded entities, and in-scope 
namespaces) are ordered in the following sequence: 
1. The element itself. 
2. Namespaces: Namespaces are ordered in lexical sequence. 
3. Attributes: The attribute nodes are sorted lexicographically, with the 
namespace URI as the primary sort criterion and the local name as the 
secondary sort criterion. 
4. Child elements in the given sequence. 
Empty elements are expanded to start-end tag pairs. Here, we have brought 
namespace declarations and attributes into the correct order. We have also 
expanded the empty element <i sPayed/> to a start tag and end tag. 
Noncanonlcal 
Canonical 
<i nstrument name="saxophone" 
maker="Sel mer" 
i d="71r8" 
xml ns=" http://www, jazz. org"> 
<isPaid/> 
</instrument> 
<instrument 
xml ns=" http://www, jazz. org" 
i d="71r8 '' maker="Selmer" 
name="saxophone"> 
<i sPai d></i sPai d> 
<\instrument> 
4.3.6 Canonical Attributes 
The canonical form of an attribute consists of 
n a space character 
[] the attribute's qualified name 
[] an equality sign 
9 a double quote 
[] the value as a canonical string with normalized whitespace (see Section 
4.3.2) 
m a double quote 
Here, we have normalized the whitespace in the attribute value, removed 
whitespace between element name and attribute and between equality sign and 
quote, and replaced the single quotes with double quotes: 
Noncanonical 
Canonical 
<instrument 
name= 'tenor 
saxophone '/> 
<instrument name="tenor saxophone"/> 

4.4 The Document Type Definition (DTD) 
105 
4.3.7 Canonical Processing Instructions 
Processing instruction (PI) nodes consist of 
-, the opening PI symbol (<?) 
[] the PI target name of the node 
[] a leading space and the string value if the string value is not empty 
[] the closing PI symbol (?>) 
[] for PIs outside the document element, a separating #xA character between 
processing instruction and document element 
Here, we have removed unnecessary whitespace: 
Noncanonical 
Canonical 
<?xml .stylesheet 
type="text/xsl" 
href="xml -shockwave. xs I" 
?> 
<?xml "styl esheet 
type=" text/xs I" 
href="xml -shockwave. xs I "?> 
4.3.8 Canonical Comments 
For canonical XML without comments, all comments are removed. For canoni- 
cal XML with comments, comments are normalized in the following way: 
[] the opening comment symbol (<!--) 
[] the string value of the node 
[] the closing comment symbol (-->) 
[] for comments outside the document element, a separating #xA character be- 
tween comment and document element 
4.4 
THE DOCUMENT TYPE DEFINITION (DTD) 
In this section we move from the instance to the schema. As stated in Section 
1.5, a schema defines a document type (or a class of documents) by imposing a 
set of constraints on the document instances. For example, we can postulate 
that documents of type book must start with an introduction, followed by a 
table of contents, followed by one or several chapters, followed by an index. 
This schema would clearly reject any document with the table of contents 
somewhere between the chapters. 
Traditionally, document types are defined in XML with the help of a Docu- 
ment Type Definition (DTD). The DTD has its legacy in SGML. Because of its 
deficiencies (see Section 4.4.8), it has sparked a variety of alternate schema lan- 
guages for XML, among them schema languages such as XDR, RELAX, Trex, or 
SOX. This has culminated in the definition of the W3C's XML Schema, the now 
official way to define XML schemata. 

106 
Chapter 4 XML Basics 
However, DTDs are still popular. DTDs are much simpler than XML Schema. 
Schemata defined with a DTD are more compact than those defined with XML 
Schema. Tool support for XML Schema is still patchy but, fortunately, is quickly 
improving. Last but not least, there is a large pool of XML and SGML experts 
who are well versed in DTDs, while a similar skill pool for XML Schema has still 
to develop. Therefore, the rest of the chapter discusses how to define a docu- 
ment schema with a DTD. 
4.4.1 Document 
The first thing to know about a Document Type Definition is that a document 
instance does not necessarily need one. A document instance without a Docu- 
ment Type Definition is only constrained by the XML syntaxmit must only be 
well formed, provided that no other schema definition exists for this document 
instance (through XML Schema, XDR, Relax NG, etc.). This well-formedness is 
sufficient for parsers and similar XML processors to process any XML document 
even if no DTD exists, or if the DTD cannot be accessed. 
Note, however, that processing a document without the DTD can yield dif- 
ferent results from processing with the DTD. A DTD can contain definitions 
that are relevant for the document content, such as default and fixed values and 
entity declarations. Only when a document is declared as standalone (see Sec- 
tion 4.2.2) is it semantically safe to process it without its DTD. When a DTD is 
specified and can be accessed, XML can validate the content of the document 
instance against the Document Type Definition. Since not all XML processors 
are able to do so, we differentiate between validating and nonvalidating XML 
processors. 
The next important thing to know about a Document Type Definition is that 
it comes in parts. A DTD can consist of an internal and an external subset. The 
external subset exists as a separate physical entity, such as a file, and is refer- 
enced by a document instance via a DOCTYPE declaration with a SYSTEM identifier: 
<!DOCTYPE book SYSTEM "http://www.book.org/book"> 
or via a DOCTYPE declaration with a PUBLIC identifier: 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
The SYSTEM identifier points via a URI to the physical entity containing the 
external DTD subset. The PUBLIC identifier identifies a publicly known docu- 
ment type such as a W3C standard. Such DTD subsets are usually built into the 
XML client, for example, into an XHTML browser. The document instance, 
however, may specify an additional URI after the public identifier to help the 
client to locate the DTD subset. 
The internal subset of a DTD is specified within the document instance. In 
this case, too, a D0CTYPE declaration is used, but without the SYSTEM identifier. 
Instead, DTD components are specified locally. 

4.4 The Document Type Definition (DTD) 
101 
<ID0CTYPE book [ 
]> 
Of course, it does not make much sense to define a document type for a sin- 
gle document instance. But the internal subset makes much more sense when it 
is combined with an external subset. It allows us to extend the definition of the 
external subset for individual document instances. For example, if we have a 
book that also has a glossary, we might append the definition for the glossary 
within the internal DTD subset of this document. The most common reason for 
internal subsets is to define, redefine, or extend entitiesmboth character entities 
and the entities that define the structure of documents. 
When we define both an external and internal DTD subset, we can combine 
both D0CTYPE declarations into one: 
<!DOCTYPE book SYSTEM "http://www.book.org/book" [ 
,
,
o
 
]> 
4.4.2 Elements 
Now, let's look at the components of a Document Type Definition. In a DTD, all 
XML elements are defined on a global level. This means that it is not possible to 
define identically named elements of different types in different contexts. For 
example, if we have a document 
<CD> 
<ti tl e>Sahara</ti tl e> 
<track> 
<title>Ebony Queen</ti tl e> 
<durati on>8: 58</durati on> 
</track> 
<track> 
<ti tl e>Rebi rth</ti tl e> 
<durati on>5:19</durati on> 
</track> 
</CD> 
all t i t le elements must have the same type definition. It would not be possible 
to have different element type definitions for CO/title and C0/track/title. This 
is fine in the above example, but a serious restriction in other cases. 
The definition of elements in a DTD is very close to the definition of regular 
sets. In fact, we could see a DTD as a Hedge-Regular Grammar (HRG) (see Sec- 
tion 1.6.4). The ELEMENT and ATTLIST components of a DTD could be seen as pro- 
duction rules of such a grammar. 

108 
Chapter 4 XML Basics 
The following example could be a complete DTD for the document type book 
mentioned above: 
<!ELEMENT book (title+,authors)> 
< ! ELEMENT ti tl e ANY> 
<!ELEMENT authors (author+)> 
<! ELEMENT author (firstName,mi ddl eName?, l astName)> 
<!ATTLIST author 
author-id ID #REQUIRED 
role (contributorleditor) "contributor"> 
<!ELEMENT firstName (#PCDATA)> 
<!ELEMENT middleName (#PCDATA)> 
<!ELEMENT lastName (#PCDATA)> 
The difference between a DTD and the definition of a regular grammar is that 
all non-terminal symbols are identical with the tag names in the document 
instances. This identity is the reason for the fact that DTDs do not allow us to 
define identically named elements of differing types in different contexts 
(which XML Schema and Relax NG allow). It is also responsible for the fact that 
DTDs are not equivalent with Hedge-Regular Grammars; they only define a sub- 
set of HRG languages. 
But back to the basics. The DTD statement 
< I ELEMENT book (t i t I e+, authors) > 
can be seen as a grammar's production rule because it describes the production 
of a <book>... </book> element. The <book> tags enclose the rest of the production 
consisting of (ti tl e+, authors). The production of the non-terminal symbols 
t i t le and authors is defined in the following rules. Recursive definitions are pos- 
sible, as in 
<!ELEMENT sectien (title, (abstract?,sectien+)Ibody)> 
The production stops when a terminal symbol is reached. The following termi- 
nal symbols are possible: 
ANY 
Wildcard: The element can contain mixed content, including 
character data and child elements. 
EMPTY 
#PCDATA 
Denotes an empty element. 
The element contains parsed character data. (Parsed character data 
must not contain characters such as < or &.) 

4.4 The Document Type Definition (DTD) 
109 
Model Groups 
If the right side of a production rule contains non-terminal symbols, then this 
is either a single non-terminal symbol or a model group. Basically, a model 
group is a regular expression (see Section 1.6.3) consisting of non-terminal 
and/or terminal symbols. 
The following operators (also called connectors) can be used to combine 
these symbols: 
(child) 
(childl,child2 ..... childn) 
(childllchild2 I... Ichildn) 
(childl, (child21 (child3,child4)),child5) 
Single symbol, no operator 
required 
Sequence, elements separated by 
comma 
Choice, elements separated by the 
vertical bar 
Parentheses are used to denote 
complex structures 
In addition, non-terminal symbols and expressions in parentheses can 
be postfixed with a modifier that denotes the cardinality of the symbol or 
expression: 
Symbol 
Cardinality Constraint 
No modifier 
? 
+ 
One occurrence, item is mandatory [1..1] 
One occurrence, item is optional [0..1] 
Multiple occurrences, item is mandatory [1..n] 
Multiple occurrences, item is optional [0..n] 
In the example given earlier we defined 
<!ELEMENT authors (author+)> 
because the element <authors> can contain multiple <author> elements, but 
must contain at least one of them. We defined 
<!ELEMENT author (firstName, middleName?, lastName)> 
because the element <author> must contain the elements <firstName> and <I ast- 
Name>, but may or may not contain the element <mi ddl eName>. 
4.4.3 Attributes 
Each non-terminal symbol (each tag name) may have a supplementary ATTLIST 
production rule for the definition of attributes. ATTLIST rules list all attributes 
of an element: 

110 
Chapter 4 XML Basics 
<!ATTLIST author 
author-id ID #REQUIRED 
role (contributor[editor) "contributor"> 
Here, ATTLIST defines the attributes for element author. These are author-id 
and role. Each single attribute definition consists of an attribute name, an 
attribute type, and a default value specification. 
ATTLIST rules are always terminal because XML attributes cannot have a 
complex structure. The attribute types can be selected from a few built-in prim- 
itive types: 
CDATA 
Character data. 
NMTOKEN 
Nametoken. Valid nametokens consist of letters, 
digits, and the characters., -, _, or" from the XML 
character set (see Section 4.2.7). 
NMTOKENS 
NMTOKEN list (separated by whitespace). 
(writer[editor[artist) 
Enumeration. Each token must be a valid 
nametoken. 
NOTATION (nl[n2[ ...) 
Enumeration of notation symbols (see Section 4.4.5). 
ID 
Element identifier. This must be a valid name. 
Element identifiers must be unique in the context of 
a document. (Names start with a letter or with _ and 
can contain letters, digits,., -, or _. Names must not 
start with the string "xml" or variations thereof, such 
as XML, xML, XmL, etc.) 
IDREF 
Reference to an element ID. 
IDREFS 
IDREF list (separated by whitespace). 
ENTITY 
Reference to an unparsed entity. The referenced 
ENTITY must have been declared with an ENTITY 
instruction. 
ENTITIES 
ENTITY list (separated by whitespace). 
The following default value specifications can be used for attribute defini- 
tions: 
#IMPLIED 
Attribute is neither required nor does it have a 
default value. 
#REQUIRED 
Attribute must be specified in document instance. 
"yes" 
Default value. An attribute with the specified default 
value is inserted into the document instance when 
the instance does not specify the attribute. 

4.4 The Document Type Definition (DTD) 
111 
#FIXED "vl" 
In our example, 
Fixed content. If the instance specifies the attribute, 
it must have this value. If not, the attribute with this 
value is inserted into the instance. 
<!ATTLIST author 
author-id ID #REQUIRED 
role (contributor]editor) "contributor"> 
defines that an author element must always specify an attribute author-id of 
type ID. If the attribute role is specified, it must have either the value "contrib- 
utor" or "editor". If this attribute is not specified, the default value role="con- 
tri butor" is inserted into the document. For example, 
<author author-id="AmblerEric">... </author> 
results in 
<author author-id="AmblerEric" role="contributor">...</author> 
4.4.4 Cross-References 
The ID and IDREF attribute types can be used to establish cross-references 
between elements. This allows us to establish networklike document structures 
that cannot be captured in tree structures. In particular, it is possible to define 
documents that mimic relational tables by using the ID and IDREF constructs. 
Attributes of type ID act as primary keys, while attributes of type IDREF act as for- 
eign keys. Most XML DOM implementations allow for locating elements by ID, 
too. 
4.4.5 Extension Mechanisms 
The NOTATION attribute type acts as a type extension mechanism for elements. 
A NOTATION type attribute refers to one or several NOTATION declarations. For 
example: 
<!NOTATION arabianYear 
SYSTEM "http'//www.book.org/datatypes/arabianYear"> 
<!NOTATION romanYear 
SYSTEM "http://www.book.org/datatypes/romanYear"> 
<!ATTLIST book 
pubDate NOTATION (arabianYearlromanYear) "romanYear"> 

112 
Chapter 4 XML Basics 
By referring to several NOTATION declarations, a NOTATION attribute can imple- 
ment a type union. Each NOTATION declaration declares a specific data type. A cus- 
tom XML processor can check this data type, possibly by using a helper 
application. 
In practical applications, the NOTATION construct is rarely used, especially as 
there are now better ways to define data types for XML attributes and elements 
with XML Schema. 
4.4.6 Document Composition 
A DTD can declare user-defined entities. These entities can be used within the 
document text and are replaced in the document by the entity definition when 
the document is processed and when the entity definition is accessible. Locally 
defined entities are used to abbreviate frequently used terms and phrases or to 
introduce a symbolic notation for commonly needed constants. For example: 
<!ENTITY legal "All rights preserved"> 
<!ENTITY piAlmost "3.141593"> 
Externally defined entities are used to modularize schemata. For example, 
<!ENTITY legaIDoc SYSTEM "http://www.book.org/modules/legal"> 
includes the contents of file http://www, book. org/modu 1 es/1 ega 1 in the document 
content. 
Using external entities can modularize both the definition of schemata and 
document instances. This can be helpful when documents are very large and 
complex. External entities can contain references to other entities, so it's pos- 
sible to construct large entity trees. SGML authors, especially, have developed a 
high art of modularization with entities. 
However, when external entities are used too extensively for modularization, 
the maintenance of schemata becomes difficult. In addition, the use of external 
entities in some application areas is not recommended. For example, if XML is 
used as a message format, external entities should be avoided; standalone docu- 
ments are preferred. Also, XML database systems will usually resolve all external 
entities before they store a document. When the document is retrieved again, it 
looks different: The external entities are now included. 
Both entity types discussed above are parsed entities (they contain XML con- 
tent that can be parsed). In addition, XML recognizes unparsed entities--enti- 
ties that contain non-XML data such as images, audio files, and video clips. An 
unparsed image entity, for example, can be referenced with 
<! ENTITY cover 
SYSTEM "http://www.book.org/images/dimitrios.gif" NDATA GIF> 

4.4 The Document Type Definition (DTD) 
113 
4.4.7 Schema Composition and Reuse Mechanisms 
Parameter entities are only used within a DTD; they do not appear within the 
content of XML instances. A parameter entity is an abbreviation for a string 
that is used frequently within a DTD, thus allowing these strings to be factored 
out. 
A parameter entity can be declared through 
<!ENTITY ~ entity-name "string-value"> 
All occurrences of ~0enti ty-name within the DTD will be substituted with string- 
val ue. Because the string value may contain other references to parameter enti- 
ties, the concept of parameter entities is quite powerful. 
A parameter entity may not only relate to a simple string value but also to a 
public identifier or to a system identifier. This makes it possible to compose a 
DTD from several parts. Typically, a complex DTD consists only of a small root 
unit containing a set of parameter entity declarations referring to the various 
components that constitute the DTD. Our book DTD could look like this: 
<!ENTITY ~ common SYSTEM "common.ent"> 
<!ENTITY ~ author SYSTEM "author.ent"> 
~common; 
~author; 
The file common, ent could, for example, contain the definitions 
< I ELEMENT book (t i t I e+, authors) > 
< l ELEMENT ti tl e ANY> 
<!ELEMENT authors (author+)> 
while the file author, ent would contain the definitions 
<[ELEMENT author (firstName,middleName?,lastName)> 
<!ATTLIST author 
author-id ID #REQUIRED 
role (contributor[editor) "contributor"> 
<!ELEMENT firstName (#PCDATA)> 
<!ELEMENT middleName (#PCDATA)> 
<!ELEMENT lastName (#PCDATA)> 
However, this technique quickly reaches its limits. Document schemata 
made up of dozens of separate entity files are difficult to manage; because there 
is no namespace concept, name clashes are all too common. 

114 
Chapter 4 XML Basics 
One important application of parameter entities is to implement a schema 
extension mechanism. Take for example our book schema. A book instance may 
only consist of one or several t i t le elements and one authors element. We are 
not allowed to add some detail information to specific instances, such as com- 
ments, a table of contents, or reviews. 
If we want to allow arbitrary extensions to a document schema on the 
instance level, we can utilize parameter entities. First we define the external 
DTD subset in the following way: 
<!ENTITY ~ details ""> 
<!ELEMENT book (title+,authors ~details;)> 
Here, we define an empty parameter entity named details and append it to 
the definition of element book. So, this definition is equivalent to 
<!ELEMENT book (title+,authors)> 
But if we override the definition of entity details within the internal DTD sub- 
set, things look completely different: 
DOCTYPE book SYSTEM "http://www.book.org/book" [ 
<!ENTITY ~ details ",publishersReview" > 
<!ELEMENT publishersReview ANY> 
]> 
Now the rule 
<I ELEMENT book (t i t I e+, authors ~detai I s; ) > 
is resolved to 
<!ELEMENT book (title+,authors,publishersReview)> 
and we can add a pub lishersReview element as a child element to the book 
element. 
4.4.8 DTD Deficiencies 
In the past, DTDs were the standard way to define a schema for an XML docu- 
ment type. This has changed with the release of the XML Schema Recommen- 
dation by the W3C. Compared to XML Schema, DTDs have several deficiencies: 
[] The syntax of a DTD is different from XML syntax. This inhibits the use of 
the vast array of XML tools for editing, validating, parsing, and transforming 
DTDs. 

4.4 The Document Type Definition (DTD) 
115 
[] DTDs do not support namespaces. Although DTDs allow the use of prefix: 
name combinations for element and attribute names, they interpret these 
combinations as simple names. This can lead to confusion. 
9 DTDs only recognize a small range of built-in data types that can only be ap- 
plied to attributes. For example, we cannot define elements and attributes 
that must be numeric or integers. Thus, the content of elements and the 
value of attributes are always regarded as character data. This can have un- 
pleasant effects when a processor wants to compare two elements containing 
numeric values. Because the processor does not know that the element con- 
tent is numeric, 6 is regarded as greater than 139594; -1 is regarded as smaller 
than -5; the floating-point number 3.7e-10 is regarded as larger than 2.0e+16; 
and so on. Languages such as XPath, therefore, have explicit means of inter- 
preting the content of an element or attribute as numeric. 
[] There is no standard way to create user-defined data types. Type definitions 
with the NOTATION mechanism require custom extensions to XML proces- 
sors and are rarely portable. 
m DTDs do not provide a special mechanism for specifying sequences of ele- 
ments with no specified order. For a given model group (el,e2,e3) the ele- 
ments e l...e3 must appear in the document instance in the exact sequence 
as defined in the DTD. To simulate such an unordered sequence (a bag), all 
possible permutations must be given as alternatives: ( (e 1, e2, e3) I (e 1, e3, e2) 
I (e2,el,e3) I .-. ). In contrast, SGML allows for specifying such sequences 
with (el&e2&e3). We will see that XML Schema provides means for specifying 
bags, too. 
m The definition of general cardinality constraints such as [2:4] is not sup- 
ported. Again we must enumerate all possible combinations: ( (e, e), (e, e, e), 
(e,e,e,e)). When there is no upper bound, such as [4:*], we need to write 
this as (e,e,e,e+). 
9 In DTDs all elements are defined on the global level. This makes it impossible 
to define context-sensitive elements---elements with the same name but dif- 
ferent structures in different contexts. 
9 DTDs do not allow the definition of multifield cross-reference keys, nor is it 
possible to use element values as keys (only attributes can be defined as type 
ID). Keys cannot be scoped, either; they are always defined on the global 
level. This can require document authors to construct rather complex key 
values to simulate multifield keys or scoped keys. 
Section 3.5 showed how to construct a composite key value. In a docu- 
ment where we want to index jazzMusician elements by name, for example, 
we have to construct a composite key value from the constituents of the 
name element, such as MingusCharles. If in the same document we also want 
to index jazz musicians by instrument, we must prefix the key values with a 
scope prefix in order to distinguish musician keys from instrument keys, for 
example, musi ci an#MonkThel oni ous and i nstrument#pi ano. 

This Page Intentionally Left Blank

5.1 
5.2 
5.3 
An Appetizer 
Simple Data Types 
Structure in XML 
Schema 
T 
he XML Schema Working Draft was first published in May 
1999, and the final recommendation was released in May 
2001. It consists of three parts. Part Zero is a very readable (but 
non-normative) XML Schema primer, written by David C. Fall- 
side (http://www.w3.org/TR/xmlschema-O). Part One specifies 
XML Schema structures (http://www.w3.org/TR/xmlschema-1), 
and Part Two specifies XML Schema data types (http://www. 
w3.org/TR/xmlschema-2). These parts are harder to read, some- 
times resembling certain legal texts. 
During their work, the XML Schema Working Group could 
include experiences with several other already existing schema 
languages, such as XSchema, DDML, XML-Data, XDR, and 
SOX. Now, with the XML Schema recommendation released, 
most XML communities are moving toward XML Schema. 
This chapter gives a complete introduction to the type sys- 
tem of XML Schema. We begin with simple XML Schema data 
typesmthe most important advantage of XML Schema over 
DTDs apart from the support for namespaces. XML Schema 
data types have also been adopted by other schema languages 
such as Relax NG (see Chapter 7). The rest of the standard will 
be covered in Chapter 6. 
117 

118 
Chapter 5 XML Schema 
S.1 
AN APPETIZER 
Although XML Schema is a complex standard, moving from a DTD to XML 
Schema is quite simple: Just feed your schema editor a DTD, and export it in 
XML Schema format. Things become more complicated when you move into 
advanced concepts: user-defined data types, for example, or modularized 
schemata with multiple namespaces. But these are things that you can't do at 
all with DTDs. 
Becoming an XML Schema expert requires some effort to master the language 
and exploit its full potential. Moving from DTD authoring to XML Schema 
authoring is like moving from a Model T Ford to a Porsche: If you can't control 
it, you will easily drive it through the next fence. On the other hand, you don't 
have to go uphill in reverse gear (for lack of a fuel pump in the Model T). 
Just as an appetizer let's look at a very small DTD: 
<!ELEMENT person (name, birthDate)> 
<!ELEMENT name (#PCDATA)> 
<!ELEMENT birthDate (#PCDATA)> 
And here is the equivalent schema for a simple person element containing a 
name and birth date written in XML Schema: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs 9 
schema xml ns: xs=" ht tp://www, w3. org/2001/XMLSchema "> 
<xs: el ement name="person"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="name" type="xs:string"/> 
<xs:element name="birthDate" type="xs:string"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs: schema> 
Well, that doesn't look too difficult. Here, we define a document type with a 
root element named person. This root element has two child elements named 
name and bi rthOate. When we look at the schema diagram in Figure 5.1, the con- 
cept is even easier to grasp. 
We see that XML Schema works quite differently from DTDs: Elements can 
be defined within the element definition of another element. One advantage is 
that the code (and also the diagram) displays the later tree structure of the doc- 

5.1 An Appetizer 
119 
i  er, on 
name ] 
[IbirthDate] 
Figure 5.1 The person element 
contains name and bi rthDate in a 
sequence. 
ument instances quite well. Global element definitions as in a DTD are possible, 
too, but we will deal with this later. 
We also see that an element containing other elements is defined as a com- 
plex type element. Type declarations, type="xs:string", replace the (#PCDATA) 
declarations from the DTD. This brings us to one of the most outstanding fea- 
tures of XML Schema and--apart from its support for namespacesmits most 
important improvement over DTDs: its support for data types. We will therefore 
start with an extensive discussion of simple data types in XML Schema. Later 
sections discuss how data structures (that is, complex data types) can be defined 
and how namespaces are handled. Finally, we will have a look at XML Schema's 
reuse mechanisms that allow the modularization of schemata and the construc- 
tion of type libraries. We will see that XML Schema offers concepts like inheri- 
tance, generic types, and polymorphism that are similar to concepts found in 
object-oriented programming, yet at the same time are quite different. 
In contrast to DTDs, XML Schema uses XML syntax for schema definition. 
The concepts throughout this chapter are explained using the following nota- 
tion to document the features of a syntactical construct in XML Schema: 
Name 
Attributes 
Contains 
simpleType 
final? 
id? 
name? 
annotation? 
(restriction I list i union) 
The Name column specifies the element name of the construct (the tag 
name). The Attributes column contains the attributes that this element may 
have. (The question mark denotes an optional attribute.) The Contains column 
defines the possible child elements. 
The definition for simpleType given above would allow, for example, the fol- 
lowing schema clause: 
<xs :simpl eType name="pri ce"> 
<xs:restriction base="xs:decimal "> 
<xs: fractionDigits val ue="2"/> 
<xs:minlncl usive val ue="0.00"/> 
</xs: restri cti on> 
</xs: s imp l eType> 

120 
Chapter 5 XML Schema 
5.2 SIMPLE DATA TYPES 
Simple data types in XML Schema are constructed by means of a few basic con- 
cepts: value space, lexical space, fundamental facets, constraining facets, and 
type extensions. The following sections discuss these basic concepts and then 
present the data types that are built into XML Schema. 
5.2.1 Value Space 
The type system of XML Schema makes a clear distinction between value space 
and lexical space. While the value space consists of an abstract collection of valid 
values for a data type, the lexical space contains the lexical representation of 
these valuesmthat is, the tokens as they appear in the XML document. Take for 
example an integer. The value of integer 5 is always the same; the lexical repre- 
sentation, however, can differ: 5, 005, five, V, *****, and so on. 
5.2.2 Lexical Representations and Canonical Representation 
The XML Schema recommendation defines which lexical representations are 
valid for a given data type. In some cases, there is only one possible representa- 
tion, but in many cases, various kinds of lexical representations are allowed. 
Take for example data type b00]ean: XML Schema allows the representation 
"true" and "false" but also the representation "1" (for "true") and "0" (for 
"false"). 
In such cases where XML Schema allows several lexical representations, one 
representation is designated as the canonical representation. For data type 
boo]ean this is the representation "true" or "false." Canonical representations 
are important when we want to compare two document instances for equality: 
It is first necessary to convert both documents into the canonical form, before 
they can be compared by character string comparison. Section 4.3 already dis- 
cussed the W3C recommendation "Canonical XML" [Boyer2001]. Because XML 
data types are not covered by this recommendation, the XML Schema specifica- 
tion explicitly defines the canonical formats of its own data types. 
5.2.3 Fundamental Facets 
XML Schema defines basic data types in a very systematic way. The properties of 
data types are classified in so-called facets. Each facet describes a specific aspect 
of a data type, such as equality, cardinality, and length. Again, these facets are 
classified into two categories: 
9 Fundamental facets define the basic value space properties of data types. They 
are used to declare the primitive data types that are built into the standard. 
They are not used to declare derived data types (built-in or user defined). 

5.2 Simple Data Types 
121 
[] Constraining facets are used, as the name says, to constrain the value space or 
lexical space of a data type. They are used to derive new data types from ex- 
isting data types by restriction. This is discussed in detail in Section 5.2.7. 
XML Schema defines the following fundamental facets: 
Facet 
Description 
equal 
Defines equality between values of a data type. For example, 
two items are equal if their values (not necessarily their string 
representations in the lexical space) are equal. Every value space 
in XML Schema supports the notion of equality, so this facet 
has the value "true" for every data type. 
ordered 
Defines order relations between values of a data type. The order 
relation can be total or partial. For example, numeric values are 
totally ordered, date values are partially ordered, and string 
values are not ordered at all. This may seem odd, but the 
ordering of strings depends on the localization context, and for 
date values it is impossible to determine an order relation 
between a date that specifies a time zone and one that comes 
without one. 
bounded 
Defines whether the values of a data type are restricted by 
an upper and/or lower bound. For example, float values are 
bounded (due to their IEEE 754-1985 representation), while 
decimal values are not bounded. 
cardi nal ity 
Defines whether the value space of a data type is finite or 
countable infinite. (Uncountable infinite data types do not 
exist in the recommendation.) For example, enumerations are 
finite, and integer numbers are countable infinite. Float values 
are also finite due to their IEEE 754-1985 representation, 
although in mathematics real numbers are uncountable 
infinite. 
numeri c 
Defines whether a data type is numeric or not. 
5.2.4 Built-in Primitive Data Types 
Using fundamental facets, XML Schema defines a set of built-in primitive data 
types. Table 5.1 lists these data types with their respective lexical representa- 
tions. Canonical representations are printed in bold, and the other representa- 
tions are followed by the reason why they are not canonical. The table also lists 
which constraining facets may be applied to each data type in order to derive 
other data types from it (see Section 5.2.7). 

122 
Chapter 5 XML Schema 
Table 5.1 Built-in primitive datatypes in XML Schema. Canonical representations are 
printed in bold typeface. Built-in datatypes belong to the XML Schema 
namespace, which is represented here with prefix "xs:". 
Possible 
Lexical 
Constraining 
Data Type 
Description 
Representation 
Facets 
xs: string 
Character string of 
Some string 
1 ength 
ordered=no 
unlimited length, 
mi nLength 
bounded=no 
XML Schema does not 
maxLength 
define an ordering 
cardinality=infinite 
relation for strings! 
pattern 
numeric=no 
en umerat i on 
whiteSpace 
xs:boolean 
ordered=no 
bounded=no 
cardinality=finite 
numeric=no 
Boolean value. 
true, false 
pattern 
I, 0 
whi teSpace 
x s: dec i mal 
ordered=total 
bounded=no 
cardinality=infinite 
numeric=yes 
Decimal number. 
A minimum precision 
of 18 digits must be 
supported by 
conforming processors. 
-1.23 
126.54 
0.0 
+100000.00 (+ sign) 
210 (no decimal point) 
totaIDigits 
fract i onDi gi ts 
pattern 
whiteSpace 
enumerati on 
maxlnclusive 
maxExcl usive 
minlnclusive 
minExclusive 
xs:float 
ordered=total 
bounded=yes 
cardinality=finite 
numeric=yes 
A single-precision 32- 
bit floating-point type 
according to IEEE 754- 
1985. 
127.433E12 
-12.78E-2, 12 
INF, -INF, 0,-0 
NaN 
-1E4 (no decimal point) 
+22.0 (+ sign) 
1.20e+04 (lowercase e) 
pattern 
enumerati on 
whi teSpace 
maxl ncl us i ve 
maxExcl usive 
minlnclusive 
minExclusive 
(continued on next page) 

5.2 
Simple Data Types 
123 
Data Type 
xs:double 
ordered=total 
bounded=yes 
cardinality=finite 
numeric=yes 
Description 
A double-precision 
64-bit floating-point 
type according to 
IEEE 754-1985. 
Possible 
Lexical 
Constraining 
Representation 
Facets 
127.433E12 
pattern 
-12.78E-2, 12 
enumeration 
INF,-INF, 0,-0 
whiteSpace 
NaN 
maxl nc I us i ve 
-1E4 (no decimal point) maxExclusive 
+22.0 (+ sign) 
minInclusive 
1.20e+04 (lowercase e) 
mi nExcl us i ve 
xs:duration 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
Specifies a period of 
time. 
The value space is a 
six-dimensional space 
where the coordinates 
designate the Gregorian 
year, month, day, hour, 
minute, and second. 
The lexical representa- 
tion follows the format 
PnYnMnDTnHnMnS. 
An optional fractional 
part for seconds is 
allowed. Negative 
durations are allowed, 
too. 
Examples: 
PTSH3M33.3S 
PIY3M 
-PT5H 
PT40H 
pattern 
enumeration 
whiteSpace 
maxlnclusive 
maxExcl usive 
minlnclusive 
minExclusive 
xs:time 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
A specific time of day as 
defined in w 5.3 of ISO 
8601. 
The lexical representa- 
tion follows the format 
hh :mm: ssZ. 
An optional fractional 
part for seconds is 
allowed. 
Z denotes an optional 
time zone: Z for UTC 
time, or a signed time 
difference in format 
hh :mm. 
Examples: 
05:20:23.2 
20:O0:OOZ 
13:20:00-05:00 (explicit 
time zone used) 
pattern 
enumeration 
whiteSpace 
maxlncl usive 
maxExcl usive 
minlnclusive 
minExclusive 
(continued on next page) 

124 
Chapter 5 
XML Schema 
Table 5.1 (continued) 
Data Type 
Description 
xs:date 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
A Gregorian calendar 
date according to 
w 5.2.1 of ISO 8601. 
Lexical 
Representation 
The lexical representa- 
tion follows the format 
CCYY-MM-DDZ. Z denotes 
an optional time zone. 
To accommodate values 
outside the range 
1-9999, additional 
digits and a negative 
sign can be added to 
the left. (The year 0000 
is prohibited.) 
Examples: 
1999-05-31 
2000-01-01Z 
2001-07-17+05:00 (ex- 
plicit time zone used) 
Possible 
Constraining 
Facets 
pattern 
enumerati on 
whiteSpace 
maxlnclusive 
maxExcl usive 
minlnclusive 
minExclusive 
xs :dateTime 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
A specific instant of 
time (a combination 
of date and time) as 
defined in w 5.4 of ISO 
8601. 
The lexical representa- 
tion follows the format 
CCYY-MM-DDThh :mm: ssZ 
with T acting as a 
separating character 
between date and time. 
Z denotes an optional 
time zone. 
Examples: 
2001-12-01 TO5:20:23.2 
1999-05-31T13:20:00- 
05:00 (explicit time 
zone used) 
pattern 
enumerati on 
whiteSpace 
maxlnclusive 
maxExcl usive 
minlnclusive 
minExcl usive 
xs :gYearMonth 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
Represents a specifc 
Gregorian month in a 
specific Gregorian year. 
The lexical representa- 
tion follows the format 
CCYY-MMZ. Z denotes an 
optional time zone. 
Example: 
2001-12 
pattern 
enumeration 
wh i teSpace 
maxlncl usi ve 
maxExcl usive 
minlnclusive 
minExclusive 
(continued on next page) 

5.2 
Simple Data Types 
125 
Data Type 
xs:gYear 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
Description 
Represents a Gregorian 
year. 
Lexical 
Representation 
The lexical representa- 
tion follows the format 
CCYYZ. Z denotes an 
optional time zone. 
Example: 
2001 
Possible 
Constraining 
Facets 
pattern 
enumeration 
whiteSpace 
maxlncl usi ve 
maxExcl usive 
minlnclusive 
minExcl usive 
xs :gMonthDay 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
Specifies a recurring 
Gregorian date. 
The lexical representa- 
tion follows the format 
--MM-DD7. Z denotes an 
optional time zone. 
Example: 
--04-01 
pattern 
enumeration 
whiteSpace 
maxlncl usive 
maxExcl us i ve 
minlnclusive 
minExclusive 
xs.gMonth 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
Denotes a Gregorian 
The lexical 
month that recurs every representation follows 
year. 
the format --MM--Z. Z 
denotes an optional 
time zone. 
Example: 
--05-- 
pattern 
enumeration 
whiteSpace 
maxlnclusive 
maxExcl usive 
minlnclusive 
minExclusive 
xs "gDay 
ordered=partial 
bounded=no 
cardinality=infinite 
numeric=no 
Denotes a Gregorian 
day that recurs every 
month. 
The lexical 
representation follows 
the format ---DDZ. Z 
denotes an optional 
time zone. 
Example: 
---01 
pattern 
enumeration 
whiteSpace 
maxlnclusive 
maxExcl usive 
minlnclusive 
minExclusive 
(continued on next page) 

126 
Chapter 5 XML Schema 
Table 5.1 (continued) 
Data Type 
xs:hexBi nary 
ordered=no 
bounded=no 
cardinality=infinite 
numeric=no 
Description 
Arbitrary hex-encoded 
binary data. 
Lexical 
Representation 
FFFF3 
0100 
9a7f (lowercase letters) 
Possible 
Constraining 
Facets 
length 
minLength 
maxLength 
pattern 
enumeration 
whiteSpace 
xs :base64Bi nary 
ordered=no 
bounded=no 
cardinality=infinite 
numeric=no 
Base64-encoded 
arbitrary binary data. 
The entire binary 
stream is encoded using 
the Base64 Content- 
Transfer-Encoding 
defined in Section 6.8 
of RFC 2045. 
aGVsbG8gd29ybGQh 
length 
minLength 
maxLength 
pattern 
enumeration 
whiteSpace 
xs:anyURI 
ordered=no 
bounded=no 
cardinality=infinite 
numeric=no 
A Uniform Resource 
Identifier (URI) 
reference. 
http://www. 
xmlarchitecture.org 
length 
minLength 
maxLength 
pattern 
enumeration 
whiteSpace 
xs :QName 
ordered=no 
bounded=no 
cardinality=infinite 
numeric=no 
XML qualified names 
consisting of name- 
space name and local 
part. 
xsl:for-each 
xs:attribute 
length 
minLength 
maxLength 
pattern 
enumeration 
whiteSpace 
xs :NOTATION 
ordered=no 
bounded=no 
cardinality=infinite 
numeric=no 
Represents the 
NOTATION attribute 
type from XML 
attributes. 
This data type is 
abstract; the user must 
derive his or her own 
data type from it. 
length 
minLength 
maxLength 
pattern 
enumeration 
whiteSpace 

5.2 Simple Data Types 
127 
5.2.5 Constructed Types 
XML Schema derives additional built-in data types from these primitive data 
types. This is done with a simpl eType declaration. 
Name 
Attributes 
Contains 
simpleType 
final ? 
id? 
name? 
annotation 
(restriction I list I union) 
XML Schema uses three methods for constructing built-in data types. 1 These 
methods can also be employed by schema authors to construct their own data 
types. 
m Restriction. The value space or the lexical space of the original data type is re- 
stricted by constraining facets. For example, the data type integer is derived 
from the primitive data type decimal by constraining the facet fracti0nDigits 
to O. For details see Section 5.2.7. 
9 Extension by list. This allows a sequence of values of the same simple data 
type. For example, the data type NMTOKENS is constructed from data type 
NMTOKEN by concatenating a list of NMTOKEN values. For details see the next 
section. 
9 Extension by union. The value space of the new data type is a union of the 
value spaces of multiple existing simple data types. This extension method 
is not used to construct built-in data types but can be used to define user- 
defined data types. For details see Section 5.2.10. 
The application of these methods by XML Schema to the built-in data types 
results in a rather large hierarchy of built-in derived data types, which are listed 
in Section 5.2.8. In terms of the theory of regular types, restrictions create sub- 
types (see Section 1.7.4), while extensions create supertypes. 
When defining user-defined types, users have the ability to inhibit further 
type construction. This is done with the final attribute, which can take one of 
the following values: #al ], 1 i st, uni on, restri cti on. This allows inhibiting fur- 
ther construction by any method (#all) or by a specific method. 
5.2.6 Extending Data Types by List 
Most data types can be extended to a list of this base data type. Within an XML 
element or attribute instance, the values of a list are separated by whitespace. 
Therefore, this extension method can only be applied to data types that do not 
1. The XML Schema Recommendation Part Two uses the term "derived" instead of 
"constructed" in this context. Since this terminology clashes with the semantics 
defined for "derived" in Part One of the recommendation, we use the term 
"constructed." 

128 
Chapter 5 XML Schema 
allow whitespace in the lexical representation. In particular, it is not possible to 
nest lists. 
In contrast to the type system of Relax NG (see Chapter 7), XML Schema 
does not allow the construction of lists with members of different data types. 
Name 
Attributes 
Contains 
list 
id 
annotation? 
i t emType 
s imp I eType ? 
The following example shows how we can define a vector consisting of an 
arbitrary number of double-precision floating-point numbers: 
<xs: simpl eType name="tVector"> 
<xs:l ist itemType="xs:double"/> 
</xs :simpl eType> 
A possible instance of such a type could look like the following: 
127.433E12 0 -12.78E-2 
Extension by list defines a supertype of the base data type. The value space of 
the base data type is just a subset of the value space of the list data type (list 
length = 1). 
5.2.7 Restricted Data Types 
In contrast, constructing a data type by applying constraints results in a subtype 
of the base data type, because the value space of the new data type is restricted; 
that is, it is a subset of the value space of the base data type. 
Name 
Attributes 
Contains 
restriction 
base 
annotation? 
id? 
simpl eType? 
(minExclusive I minlnclusive I maxExclusive I 
maxlnclusive I totaIDigits I fractionDigits I 
length I minLength I maxLength I enumeration I 
whiteSpace I pattern)* 
XML Schema classifies the constraints that can restrict a data type into con- 
straining facets. Each facet controls a different aspect of a data type, for exam- 
ple, the total number of digits or the number of fractional digits for a decimal 
data type. As shown earlier in Table 5.1, each primitive data type defines which 
constraining facet may be applied to it. 

5.2 Simple Data Types 
129 
Facet 
length 
minLength 
maxLength 
pattern 
The following constraining facets are available in XML Schema: 
Description 
Defines the length for an atomic data type value (number of 
characters for strings, number of octets for binary, etc.). 
<xs:simpl eType name="tUsZi p"> 
<xs: restri cti on base="xs: string"> 
<xs: length value="5"/> 
</xs :restri ction> 
</xs: s impl eType> 
Defines the number of elements for a list type. 
<xs :simpl eType name="tVector"> 
<xs:l ist itemType="xs:double"/> 
</xs: s i mpl eType> 
<xs: simpl eType name="tVector3D"> 
<xs: restri cti on base="tVector"> 
<xs: length value-"3"/> 
</xs: res tri cti on> 
</xs: s impl eType> 
Defines the minimum length for atomic types or the 
minimum number of elements for list types. 
Defines the maximum length for atomic types or the 
maximum number of elements for list types. 
Constrains the values of a data type by constraining the 
lexical space of a data type to match a specified character 
pattern. Patterns are defined via regular expressions. The 
syntax for the specification of patterns uses almost the same 
tokens and escape symbols as other languages that support 
patterns. (See the appendix for a complete listing of the 
pattern language.) 
Example: 
<xs :simpl eType name="tRegNo"> 
<xs:restriction base="xs: string"> 
<xs :pattern 
value=" ( (\p{ tu} I \d) {4}-) {4} (\p{ ku} I \d) {4} "/> 
</xs: restri cti on> 
</xs:simpl eType> 

130 
Chapter 5 XML Schema 
enumerati on 
whiteSpace 
maxlncl usive/ 
maxExcl usive 
minInclusive/ 
minExclusive 
totaIDigits 
Constrains the string to five substrings separated by "-". Each 
substring consists of four uppercase letters or decimal digits. 
Example: 
E343-8873- KYZO-733A-4844 
Constrains the value space of a data type to a specified 
enumeration of values. 
Example: 
<xs :simpl eType name="tCol orName"> 
<xs.restriction base="xs 9 
string"> 
<xs:enumeration val ue="red"/> 
<xs :enumeration val ue="green"/> 
<xs :enumeration val ue="bl ue"/> 
</xs:restri ction> 
</xs :simpl eType> 
This is not really a constraining facet, but it defines a policy 
of how whitespace in input values is handled: preserve (keep 
all whitespace characters), replace (replace each whitespace 
character with the blank character), collapse (reduce all 
sequences of whitespace characters to a single blank 
character). 
Upper bound for the value space of a data type. maxIncl usive 
includes the specified value, maxExcl us ive excludes the 
specified value. 
Lower bound for the value space of a data type. minInclusive 
includes the specified value, minExclusive excludes the 
specified value. 
Example: 
<xs :simpl eType name="tGrade"> 
<xs: restri cti on base="xs: integer"> 
<xs:minlnclusive value="1"/> 
<xs :maxExcl usive val ue="6"/> 
</xs: restri cti on> 
</xs: s impl eType> 
Specifies an integer data type with the possible values 1, 2, 3, 
4, 5. 
Maximum total number of decimal digits in values of data 
types derived from data type decimal. 

5.2 Simple Data Types 
131 
fractionDigits 
Maximum number of decimal digits in the fractional part of 
values of data types derived from decimal. 
Example: 
<xs: simpl eType name="tAccount"> 
<xs:restriction base="xs:decimal "> 
<xs:totaIDigits value=" 15"/> 
<xs: fractionDigits val ue="2"/> 
</xs: restri ction> 
</xs: s i mpl eType> 
Defines a decimal data type with at most 15 decimal digits 
and two fractional digits. 
5.2.8 Built-in Constructed Data Types 
By applying the constraining facets explained above and by applying list exten- 
sions, XML Schema defines a hierarchy of built-in constructed data types (see 
Table 5.2 and Figure 5.2). Built-in data types belong to the XML Schema name- 
space, represented here with prefix "xs:". 
Table 5.2 Built-in constructed data types in XML Schema. Built-in data types belong 
to the XML Schema namespace, represented here with the prefix "xs :". 
Data Type 
xs: normal i zedStri ng 
A string with normalized whitespace; that 
is, the string must not contain the carriage 
return (#xD), line feed (#xA), or tab (#x9) 
characters. 
Derived By 
<xs:restriction base="xs :string"> 
<xs :whiteSpace val ue="repl ace"/> 
</xs: restri cti on> 
Examples: 
"A normal ized 
string" 
"Not a 
normal ized string" 
xs:token 
A string that does not contain the line feed 
(#xA) or tab (#x9) character, does not have 
leading or trailing spaces (#x20), and does 
not have internal sequences of two or 
more spaces. 
<xs:restriction 
base="xs: normal i zedStri ng"> 
<xs:whiteSpace value="col lapse"/> 
</xs: restri cti on> 
Examples: 
"A valid token" 
"Not a 
valid token " 
(continued on next page) 

132 
Chapter 5 XML Schema 
Table 5.2 (continued) 
Data Type 
xs:language 
Language identifiers as defined by ISO 639 
and ISO 3166. 
Derived By 
i 
<xs:restriction base="xs :token ''> 
<xs: pattern val ue = 
"( [a-zA-Z] { 2 } I [i I] - [a-zA-Z] +I [xX] - [a-zA- 
Z] {1,8}) (- [a-za-Z] {1,8})*"/> 
</xs:restri ction> 
Examples: 
"en-GB" 
"en-US" 
"fr-CA" 
xs: NMTOKEN 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
<xs:restriction base="xs:token ''> 
<xs :pattern val ue="\c+"/> 
</xs: restri cti on> 
Examples: 
"nametoken" 
"not a nametoken" 
xs: NMTOKENS 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
<xs: restri ct i on> 
<xs:simpl eType> 
<xs: 1 i st i temType="xs: NMTOKEN"/> 
</xs :simpl eType> 
<xs:mi nLength val ue="l"/> 
</xs:restri ction> 
Examples: 
"nametokenl nametoken2 nametoken3" 
xs:Name 
Represents the corresponding attribute 
type from XML 1.0 (DTD). 
<xs:restriction base="xs:token ''> 
<xs:pattern val ue="\i \c*"/> 
</xs: restri cti on> 
Examples: 
"goodName" 
"5badName" 
(continued on next page) 

5.2 Simple Data Types 
133 
Data Type 
xs: NCName 
Represents the corresponding attribute 
type from XML 1.0 (DTD). 
xs:ID 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
xs:IDREF 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
xs:IDREFS 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
xs:ENTITY 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
xs:ENTITIES 
Represents the corresponding attribute 
type from XML 1.0 (DTD). (See Section 
4.4.3.) 
Derived By 
<xs: restri ct i on base="xs :Name"> 
<xs:pattern value="[\i-[:]] [\c-[:]]*" /> 
</xs: restri cti on> 
Examples: 
"goodNCName" 
"ex: badNCName" 
<xs: restri cti on base="xs: NCName"/> 
<xs: restri cti on base="xs: NCName"/> 
xs:restriction> 
<xs :simpl eType> 
<xs: l i st i temType="xs: IDREF"/> 
</xs: s imp l eType> 
<xs :mi nLength value=" 1 "/> 
</xs: restri cti on> 
<xs: restri cti on base="xs: NCName"/> 
<xs: restri cti on> 
<xs :simpl eType> 
<xs:l ist itemType="xs:ENTITY"/> 
</xs: s impl eType> 
<xs :mi nLength val ue=" 1"/> 
</xs: restri ction> 
(continued on next page) 

134 
Chapter 5 XML Schema 
Table 5.2 (continued) 
Data Type 
xs:integer 
The standard mathematical integer data 
type of arbitrary length. 
Derived By 
<xs:restriction base="xs:decimal "> 
<xs: fracti onDi gi ts 
value="O" fixed="true" /> 
</xs: restri cti on> 
Examples: 
"1234567" 
"123.40" (not an integer) 
xs: non Pos i t i ve Integer 
Integer less than or equal to zero. 
<xs:restriction base="xs: integer"> 
<xs:maxlncl usive val ue="O"/> 
</xs: restri cti on> 
xs: negat i ve Integer 
Integer less than zero. 
<xs:restriction 
base =''xs: non Pos i t i ve Integer"> 
<xs:maxlncl usive val ue="-l"/> 
</xs:restri ction> 
xs: l ong 
Integer in the range of 
-9223372036854775808 to 
9223372036854775807. 
<xs:restriction base="xs: integer"> 
<xs :mi n Incl usive 
val ue="-9223372036854775808"/> 
<xs :maxIncl usi ve 
v a I ue= "9223372036854775807 "/> 
</xs: restri cti on> 
xs:int 
Integer in the range of-2147483648 to 
2147483647. 
<xs:restriction base="xs: long"> 
<xs :mi nlncl usive 
va I ue="-2147483648"/> 
<xs :maxl ncl us i ve 
va I ue=" 2147483647"/> 
</xs: restri cti on> 
xs:short 
Integer in the range of -32768 to 32767. 
<xs:restriction base="xs: int"> 
<xs:minlncl usive val ue="-32768"/> 
<xs :maxlncl usive val ue="32767"/> 
</xs :restri ction> 
(continued on next page) 

5.2 Simple Data Types 
135 
Data Type 
xs:byte 
Integer in the range of-128 to 127. 
Derived By 
<xs:restriction base="xs: short"> 
<xs:minlncl usive val ue="-128"/> 
<xs:maxlncl usive val ue="127"/> 
</xs: restri cti on> 
xs: nonNegat i vel nteger 
Integer greater than or equal to zero. 
<xs: resri cti on base="xs: i nteger"> 
<xs:minlncl usive val ue="O"/> 
</xs:restri ction> 
xs:unsignedLong 
Integer in the range of 0 to 
18446744073709551615. 
<xs:restriction 
base= "xs: nonNegat i ve Integer"> 
<xs :maxlncl usi ve 
va I ue=" 18446744073709551615"/> 
</xs: restri cti on> 
xs:unsignedlnt 
Integer in the range of 0 to 4294967295. 
<xs: restri cti on base="xs: unsi gnedLong"> 
<xs :maxl ncl usi ve 
val ue="4294967295"/> 
</xs: restri cti on> 
xs: unsi gnedShort 
Integer in the range of 0 to 65535. 
<xs: restrict i on base="xs: uns i gnedlnt"> 
<xs:maxlncl usive val ue="65535"/> 
</xs: restri cti on> 
xs :unsignedByte 
Integer in the range of 0 to 255. 
<xs:restriction base="xs: unsi gnedShort"> 
<xs :maxIncl usive val ue="255"/> 
</xs: restri ct i on> 
xs: pos i t i ve I nteger 
Integer greater than zero. 
<xs:restriction 
base="xs: nonNegat i vel nteger"> 
<xs:minlnclusive value=" 1"/> 
</xs: restri cti on> 

136 
Chapter 5 XML Schema 
Figure 5.2 Built-in data types in XML Schema. Primitive data types are printed in 
reverse. Dashed lines indicate construction by list; solid lines indicate derivation by 
restriction. 
5.2.9 The Hierarchy of Built-in Primitive 
and Constructed Data Types 
The built-in primitive data types listed in Section 5.2.4 and the built-in con- 
structed data types listed in Section 5.2.8 establish a hierarchy of data types as 
shown in Figure 5.2. Constructed data types are obtained from primitive data 
types and other constructed data types by restriction and list extension. Please 
note that these operations do not establish a hierarchy in terms of subtype and 
supertype. While type restriction always results in a subtype of the base type, 
list extension always results in a supertype of the base type. This is the reason 
why we use the term constructed data type in contrast to derived data type as 
used in the XML Schema Recommendation, Part Two. The formal definition of 
derived in Part One of the recommendation does not allow for type extension by 
list or union. 

5.2 Simple Data Types 
137 
5.2.10 Union Types 
With the uni on operation, it is possible to combine disparate data types in a sin- 
gle data type. The new data type is a supertype to all the contributing member 
data types: Its value space is the union of the value spaces of all contributing 
member data types. The member data types can be either referenced by name in 
the memberTypes attribute or defined locally using simpl eType declarations within 
the uni on element. 
Name 
Attributes 
Contains 
union 
id 
annotation? 
memberTypes 
simpleType* 
In the following schema fragment, a string data type t lSBN is defined. The 
pattern facet restricts valid strings to the typical ISBN patterns, such as 0-646- 
27288-8. (For an explanation of the pattern syntax, see the appendix.) A second 
data type, tProductN0, is defined next, representing custom product numbers. 
These product numbers start with "9-" followed by two groups of three to five 
decimal characters, followed by a single decimal character, for example, 9-234- 
9393-0. 
We can then use these two type definitions to construct a union type 
t ISBNorProductNo allowing both patterns. We could use this combined data type 
for a catalog containing books and other products. 
<xs :simpl eType name="tlSBN"> 
<xs:restriction base="xs :string ''> 
<xs:pattern value="(\d)-(\d){3}-(\d){5}-(\d)"/> 
</xs: restri cti on> 
</xs:simpl eType> 
<xs :simpl eType name="tProductNo"> 
<xs:restriction base="xs :string"> 
<xs:pattern value="9-((\d) {3,5}-) {2} (\d)"/> 
</xs: restri ction> 
</xs:simpl e Type> 
<xs :simpl eType name="tlSBNorProductNo ''> 
<xs:union memberTypes="tlSBN tProductNo"/> 
</xs: s impl eType> 

138 
Chapter 5 XML Schema 
In this example the patterns of the two member types t ISBN and tProductNo 
are chosen in such a way that their lexical value domains overlap. In such cases 
the sequence of the member types given in the uni on clause matters: An XML 
Schema-aware processor would first try to match an instance string to the t I SBN 
pattern, and if that failed, to the tProductNo pattern. However, individual 
instances may enforce the usage of a specific member type via the xsi :type 
attribute (see Section 6.2.4). 
5.2.11 User-Defined Data Types 
As mentioned in Section 5.2.5, it is possible for users to construct their own 
data types from built-in data types. Let's look at an example. We want to 
declare a schema for asset jazzMusician defined in Figure 3.5. We choose to rep- 
resent the property kind as an attribute. Since only three values are allowed, 
we want to declare the attribute accordingly, restricting its value range to 
instrumental i st, jazzSi nger, and jazzComposer. We can achieve this with the fol- 
lowing definition: 
<xs:attribute name = "kind"> 
<xs: simpl eType> 
<xs:restriction base = "xs:NMTOKEN"> 
<xs:enumeration value = "instrumentalist"/> 
<xs:enumeration value = "jazzSinger"/> 
<xs:enumeration value = "jazzComposer"/> 
</xs: restri cti on> 
</xs :simpl eType> 
</xs :attribute> 
What we do is declare a simple data type on the fly. This new anonymous 
data type is only used for the attribute with the name "kind" and is derived 
from the built-in data type xs :NMTOKEN by restriction. We then use three occur- 
rences of the xs:enumeration facet to define the three possible values. 
Similarly, we could define an element duration (for the duration property of 
asset track): 
<xs:element name = "duration"> 
<xs:simpl eType> 
<xs:restriction base = "xs:duration"> 
<xs:maxlnclusive value = "PT77M"/> 

5.3 Structure in XML Schema 
139 
</xs : restri ction> 
</xs :simpl eType> 
</xs: el ement> 
Here, we use a restricted form of the built-in data type xs:duration in that we 
only allow durations smaller or equal to 77 minutes. 
5.3 
STRUCTURE IN XML SCHEMA 
As you can see in Figure 5.3 (page 140), the definition of a document structure 
with XML Schema is a rather complex undertaking. Understanding the interre- 
lated concepts of XML Schema takes a while of reading forward and backward. 
Be patient. The best method is to learn the most basic constructs first and worry 
about advanced features such as global definitions and reuse mechanisms later: 
1. The root element of a document is defined on the schema level via an 
element definition. 
2. This root element has a complex type. 
3. Complex type declarations combine other (global and local) elements 
that again may have a complex type, or otherwise have a simple type. 
4. This combination is achieved via model groups consisting of sequences, 
choices, or bags. 
5. Particles can further constrain model groups by introducing cardinality 
constraints. 
5.3.1 Hierarchy 
XML documents have a clear hierarchical structure. There is a root element that 
has child elements that in turn can have other child elements, and so on. Addi- 
tionally, each element may be decorated with attributes. 
On the schema level, two types of elements can be defined: 
m The first element definition specifies the root element for all document 
instances. 
[] Subsequent element declarations on the schema level are used to specify 
global elements. They may or may not appear in instance documents, and 
will certainly not appear in root position. Instead, this set of element defini- 
tions acts as a kind of local library for element definitions. 
Readers will find this concept similar to the definition of a document struc- 
ture with DTDs, where all element definitions happen on the global level. Typi- 
cally, we define elements that occur in several places as global elements to avoid 

140 
Chapter 5 XML Schema 
Figure 5.3 The XML Schema metamodel. The relationships between the different 
syntactical elements of a schema definition are complex, indeed. 

5.3 Structure in XML Schema 
141 
redundant local definitions. Also, global element definitions can be used to 
specify recursive element structures. Section 5.3.12 discusses global elements in 
more detail. 
5.3.2 Elements and Complex Types 
Elements are defined in XML Schema with the el ement clause: 
Name 
Attributes 
Contains 
element 
(abstract I final)? 
block? 
(default I fixed)? 
form? 
id? 
maxOccurs? 
minOccurs? 
(name I ref) 
nillable? 
substi tuti onGroup? 
type? 
annotation? 
(simpleType I complexType)? 
(unique I key I keyref)* 
All these attributes and child elements of the element clause will be discussed 
in the following sections. Let's begin with the most basic ones. The required 
attribute name defines the name of the element (the tag): 
<xs :el ement name="l ocati on"/> 
Optionally, each element definition can include a type specification. This 
can be a simple type, as discussed in Section 5.2. The type attribute can refer to 
a built-in type or to a user-defined type. In the following example we refer to 
the built-in type normal izedString. (The prefix xs: was defined as a prefix for the 
XML Schema namespace--see Section 6.1.) 
<xs:element name="location '' type="xs:normalizedString"/> 
Where there is a simple type there must also be a complex type. Indeed, the 
c0mplexType declaration in XML Schema is used to aggregate several XML ele- 
ments and attributes into a single data type. Consequently, each node in an 
XML document has a data typemwhether explicitly defined or not. Leaf 
nodes--elements without child elements and attributes, and attributesmadhere 
to a simple data type, while all other nodes are of a complex type. 

142 
Chapter 5 XML Schema 
Name 
compl exType 
Attrlbutes 
Contalns 
abstract? 
annotati on? 
bl ock? 
simpl eContent 
final ? 
compl exContent 
id? 
(group [ all [ choice [ sequence)? 
mixed? 
(attribute [ attributeGroup)* 
name ? 
anyAt t ri bute ? 
Complex types are always user-defined types with one notable exception: The 
built-in type xs :anyType is a generic complex type, to which all other complex 
types are subtypes. Complex types can be defined at a global level, or locally as 
implicit data types. Here is an example for such a local type definition: 
<xs:element name = "period"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="from" type="xs:date"/> 
<xs:element name="to" type="xs:date"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
Here is the equivalent DTD (ignoring type declarations): 
<!ELEMENT period (from, to)> 
<!ELEMENT from (#PCDATA)> 
<!ELEMENT to (#PCDATA)> 
In this example, the complex type consists of a particle--a complex structure 
containing child elements. (The next section will discuss particles in detail.) 
There are several content models for complex types: 
u Particles define child element structures. 
[] Simple content relates to a simple data type that can be extended by local 
definitions. 
u Complex content relates to an earlier defined complex data type or to the 
built-in data type xs :anyType. This complex type can then be restricted by lo- 
cal definitions. 
All of these content models can contain attribute definitions. Section 5.3.11 
discusses the definition of attributes. 

5.3 Structure in XML Schema 
143 
Even in the case when an element contains only a single child element, it 
must be defined via a complex type with a particle (see next section). Since par- 
ticles are defined via connectors (sequence, choice, all), we have to define a 
rather meaningless connectormin this example xs:sequence. Semantically it 
does not matter which one you choose, but for reasons of style, select 
xs :sequence. 
<xs: el ement name="i ntluence"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="i ntluencedBy" type="xs: NMTOKEN"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
5.3.3 Particles and Model Groups 
In the example above we defined a particle consisting of a sequence of ele- 
ments. XML Schema defines a particle as one of the following: 
[] an element declaration (see Section 5.3.2) 
[] a wildcard (see Section 5.3.15) 
[] a model group 
In addition, particles can have a cardinality constraint (see Section 5.3.4) 
specified with mi nOccurs and maxOccurs. 
Model Groups 
Model groups are similar to DTD model groups, but the syntax is completely 
different and there is a new connector. Model groups can be constructed using 
three kinds of connectors: 
[] sequence 
m all 
[] choi ce 
The xs:sequence connector has the following child nodes: 
Name 
Attributes 
Contains 
sequence 
id? 
maxOccurs? 
minOccurs? 
annotation? 
(element I group I choice I sequence I any)* 

144 
Chapter 5 XML Schema 
This connector has the same semantics as the, connector in an XML DTD or 
the , operator in a regular expression (see Section 1.7). It specifies an ordered 
sequence of elements--that is, it requires that instance documents adhering to 
this schema always use elements in the prescribed sequence. Given the schema 
fragment 
<xs:element name = "period"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name= " from" type:"xs:date"/> 
<xs:element name="to" type="xs:date"/> 
</xs: sequence> 
</xs: compl exType> 
</xs:el ement> 
the following instance fragment is valid 
<period> 
<from> 1917-05-23</from> 
<to> 1918- I 1-05</to> 
</period> 
but not 
<period> 
<to> 1918-11-05</to> 
<from> 1917-05-23</from> 
</period> 
The xs:all connector has the following child nodes: 
Name 
all 
Attributes 
Contains 
id? 
annotation? 
maxOccu rs ? 
e 1 ement* 
minOccurs? 
This connector has no equivalent in the XML DTD, but it has the same 
semantics as the & connector in an SGML DTD or the & operator in a regular 
expression (see Section 1.7). It does not require a particular order of elements 
in the document instance--it specifies a bag of elements. Given the schema 
fragment 

5.3 Structure in XML Schema 
145 
<xs:element name = "performedAt"> 
<xs: compl exType> 
<xs:all> 
<xs:element name = "location" 
type = "xs:normalizedString"/> 
<xs:element name = "time" type = "xs:dateTime"/> 
</xs:all> 
</xs: compl exType> 
</xs: el ement> 
both of the following instance fragments are correct: 
<performedAt> 
<location>Dixie Park</l ocation> 
<time>1910-03-27T17:15:00</time> 
</performedAt> 
<performedAt> 
<time> 1910-03-27T17:15: 00</t ime> 
<location>Dixie Park</l ocation> 
</performedAt> 
But this is not correct: 
<performedAt> 
<time> 1910-03-27T17:15: 00</t ime> 
</performedAt> 
As you can see, XML Schema makes it easy to specify unordered sequences. 
With the DTD we had to resort to specifying alternatives of all possible permu- 
tations of the child elements, a quite laborious process. 
Note: When nesting particles, there is one restriction with the xs:all connec- 
tor. The xs:all connector cannot directly contain other connectors (but it 
may contain other complex elements constructed with other connectors). 
It also may not be a child element of other connectors. This is to avoid non- 
deterministic expressions and keep parsers simple (see also Sections 5.3.4 and 
5.3.18). 
The following example is invalid for two reasons: (1) The all connector is 
the child of an xs :sequence connector, and (2) the all connector contains an 
xs: choi ce connector. 

146 
Chapter 5 XML Schema 
<xs : compl exType> 
<xs:sequence> 
<xs'all> 
<xs'choice> 
o o o  
</xs'choice> 
</xs'all> 
</xs 9 
sequence> 
</xs. compl exType> 
The xs" choi ce connector has the following child nodes: 
Name 
Attributes 
Contains 
sequence 
id 
maxOccurs 
minOccurs 
annotation? 
(element i group I choice I sequence i any)* 
This connector has the same semantics as the I connector in an XML DTD or 
the I operator in a regular expression (see Section 1.7). It specifies alternatives of 
elementsnthat is, it requires that the instance documents use only one element 
out of the defined list. Given the schema fragment 
<xs:element name = "message"> 
<xs: compl exType> 
<xs: choi ce> 
<xs:element name="from" type="xs:string"/> 
<xs:element name="to" type="xs:string"/> 
</xs:choice> 
</xs: compl exType> 
</xs: el ement> 
the following instance fragments are possible: 
<message> 
<from>John</from> 
</message> 
<message> 
<to>John</to> 
</message> 

5.3 Structure in XML Schema 
147 
But this is not possible: 
<message> 
<from>john</from> 
<to>john</to> 
</message> 
Here is the equivalent DTD: 
<!ELEMENT message (from[ to)> 
<!ELEMENT from (#PCDATA)> 
<!ELEMENT to (#PCDATA)> 
The xs:sequence and xs:choice connectors can be nested to create complex 
element structures. For example: 
<xs:element name = "collaborationContext"> 
<xs: compl exType> 
<xs :choice> 
<xs: sequence> 
<xs :el ement name= " from" type="xs :date"/> 
<xs:element name="to" type="xs:date"/> 
</xs: sequence> 
<xs: sequence> 
<xs:el ement name="l ocation '' 
type="xs: normal i zedStri ng"/> 
<xs:element name="time" type="xs:dateTime"/> 
</xs :sequence> 
<xs: sequence> 
<xs:element name="time" type="xs:dateTime"/> 
<xs :el ement name="l ocati on" 
type="xs: normal i zedStri ng"/> 
</xs :sequence> 
</xs:choi ce> 
</xs :compl exType> 
</xs: el ement> 

148 
Chapter 5 XML Schema 
Here is the equivalent DTD fragment (ignoring type declarations): 
< ! ELEMENT col 1 aborat i onContext 
((from, to)I 
(location, time)I 
(time, location))> 
<!ELEMENT from (#PCDATA)> 
<!ELEMENT to (#PCDATA)> 
<!ELEMENT location (#PCDATA)> 
<!ELEMENT time (#PCDATA)> 
<!ELEMENT time (#PCDATA)> 
<IELEMENT |ocation (#PCDATA)> 
Here, we have defined an alternative that consists either of a sequence of from 
and to elements, or of a bag of location and time elements. Note that we have 
resolved the bag into two xs:sequence connectors, as it is not allowed to define 
an xs.all connector inside an xs. choi ce connector. 
The following instance fragments would be possible: 
<collaborationContext> 
<period> 
<from>1917-O5-23</from> 
<to>1918-11-O5</to> 
</period> 
</collaborationContext> 
<collaborationContext> 
<performedAt> 
<location>Dixie Park</location> 
<time>1910-O3-27T17:15:OO</time> 
</performedAt> 
</collaborationContext> 
<col I aborat i onContext> 
<performedAt> 
<time>1910-O3-27T17:15: O0</time> 
<location>Dixie Park</l ocation> 
</performedAt> 
</col I aborat i onContext> 
Note: For a discussion of nondeterministic choice groups, see Section 5.3.18. 

5.3 Structure in XML Schema 
149 
5.3.4 Cardlnality Constraints 
Cardinality constraints can be applied to particles. A particle is either an ele- 
ment, a wildcard (see Section 5.3.15), or a model group: 
u mi n0ccurs defines the minimum of occurrences of the particular element or 
particle. 
m max0ccurs defines the maximum of occurrences of the particular element or 
particle. 
Obviously, the following constraints apply for the values of min0ccurs and 
maxOccurs" 
0 <= minOccurs 
0 <= maxOccurs 
minOccurs <: maxOccurs 
A special "unbounded" value for max0ccurs allows an unlimited number of 
occurrences. For both mi n0ccurs and max0ccurs the default value is 1; so, if nei- 
ther is specified, an element or particle has to appear once and only once. Com- 
pared to the cardinality operators available in DTDs (+, ?, *), the combination of 
mi n0ccurs and max0ccurs offers advanced functionality (see Table 5.3). 
Note: A max0ccurs value greater than I is not allowed for elements that con- 
tain an xs. a11 connector, or for elements contained in an xs. a11 connector. 
This is to avoid nondeterministic expressions (see also Section 5.3.3). 
Table 5.3 Cardinality constraints in XML Schema and DTD. 
XML Schema 
DTD 
minOccurs 
maxOccurs 
Cardinality Operator 
1 
1 
None 
1 
Unbounded 
+ 
0 
1 
? 
0 
Unbounded 
* 
n 
m 
No equivalent 
n 
Unbounded 
No equivalent 
0 
0 
No equivalent 
Description 
Single element required 
Multiple elements, at 
least one required 
Optional single element 
Multiple elements, 
optional 
At least n elements, at 
most m elements 
At least n elements 
No element 

150 
Chapter 5 XML Schema 
For example, this album has exactly one title and one or several tracks: 
<xs: el ement name = "al bum"> 
<xs: compl exType> 
<xs :sequence> 
<xs:element name="title '' type="xs:string"/> 
<xs: el ement name="track '' type="xs: string" maxOccurs:"unbounded"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
Here is the equivalent DTD fragment: 
<!ELEMENT album (title, 
track+)> 
<!ELEMENT tit|e (#PCDATA)> 
<!ELEMENT track (#PCDATA)> 
5.3.5 Default Values and Fixed Values 
DTDs allow us to define default values and fixed values for attributes. In con- 
trast to DTDs, XML Schema allows us to define default values and fixed values 
for elements, too. This is done via the attributes defaul t and fixed. For example: 
<xs :el ement name="ki nd" 
type="xs: NMTOKEN" 
defau I t="i nstrumental i st"/> 
<xs :el ement name="version" 
type="xs :decimal" 
fixed=" I. 0"/> 
Note that these schema declarations modify--just like the DTD default 
and fixed values--the content of the instance document. The content seen by 
a schema-aware application is different from the content seen by a non- 
schema-aware application parser. 
5.3.6 Mixed Content 
By default, an element of complex type must only contain attributes and child 
elements, but no other content, such as text. To allow mixed content--content 
consisting of child elements and text--we specify the attribute mixed="true" in a 
c0mplexType declaration. This method of declaring mixed content for an ele- 
ment is superior to the mixed content declaration in a DTD: We can control not 
only the number and types of child elements but also their sequence, with the 

5.3 Structure in XML Schema 
151 
help of an xs :sequence connector. If we do not want to control the sequence, we 
just use an xs.all connector instead. In fact, we may use an arbitrary complex 
particle consisting of several nested connectors in connection with the mixed 
declaration. 
The following example instance document shows a typical mixed content 
element descri pt i on: 
<description>The album <albumTitle>Truth is Marching In</albumTitle> 
from the <performer>Albert Ayler Quintet</performer> consists of 
<noOfTracks>2</noOfTracks> tracks: <trackNo>l</trackNo>- 
<trackTitle>Truth is marching In</trackTitle>, <trackNo>2</trackNo>- 
<trackTitle>Our Prayer</trackTitle>.</description> 
We can define such an element type with the following specification: 
<xs :element name="description ''> 
<xs :compl exType mixed="true ''> 
<xs: sequence> 
<xs:element name="albumTitle '' type="xs:string"/> 
<xs:element name="performer" type="xs:string"/> 
<xs:element name="noOfTracks '' type="xs:positivelnteger"/> 
<xs: sequence maxOccurs:"unbounded"> 
<xs :el ement name="trackNo" type="xs :posi ti velnteger"/> 
<xs:element name="trackTitle '' type="xs:string"/> 
</xs :sequence> 
</xs: sequence> 
</xs : compl exType> 
</xs :el ement> 
Here is the equivalent DTD fragment (ignoring type declarations): 
<! ELEMENT description (#PCDATA I albumTitle I performer I noOfTracks I 
(trackNo, trackTi tl e) +) *> 
<!ELEMENT albumTitle (#PCDATA)> 
<!ELEMENT performer (#PCDATA)> 
<!ELEMENT noOfTracks (#PCDATA)> 
<!ELEMENT trackNo (#PCDATA)> 
<!ELEMENT trackTitle (#PCDATA)> 
In this example, we have defined a header consisting of album title, per- 
former, and number of tracks, followed by a repeating group consisting of track 

1 $2 
Chapter 5 XML Schema 
number and track title. All the defined elements must appear in the prescribed 
order, but because we have specified mixed:"true", arbitrary text may be inter- 
spersed between the elements. Without this declaration the document instance 
fragment would have to look like this: 
<description> 
<albumTitle>Truth is Marching In</albumTitle> 
<performer>Albert Ayler Quintet</performer> 
<noOfTrac ks>2</noOfTracks> 
<t rac kNo> l</t rac kNo> 
<trackTitle>Truth is marching In</trackTitle> 
<trackNo>2</trackNo> 
<trackTi tl e>Our Prayer</trackTi tl e> 
</description> 
5.3.7 Simple Content 
Simple content definitions refer to existing simple data types, as discussed in 
Section 5.2 (built-in or user defined), via an extension or restriction clause. They 
are usually used to define leaf elements that may contain attributes (see Section 
5.3.11). 
Name 
Attributes 
Contains 
simpl eContent id? 
annotation? 
(restriction I extension) 
Name 
Attributes 
Contains 
extension 
base 
id? 
annotation? 
(attribute I attributeGroup)* 
anyAttribute? 
Name 
restriction 
Attributes 
base 
id? 
Contains 
annotation? 
simpl eType? 
(minExclusive I minlnclusive I maxExclusive I 
maxlnclusive I totaIDigits I fractionDig its I 
length I minLength I maxLength I enumeration I 
whiteSpace I pattern)* 
(attribute I attributeGroup)* 
anyAttri bute? 

5.3 Structure in XML Schema 
153 
Here is an example of a simple content definition: 
<xs: compl exType name="wei ght"> 
<xs: s impl eContent> 
<xs: extensi on base="xs: nonNegati velnteger"> 
<xs:attri bute name="uni t" type="xs :NMTOKEN"/> 
</xs:extension> 
</xs: s imp l eContent> 
</xs: compl exType> 
5.3.8 Complex Content 
Complex content definitions refer to existing complex data types (user defined 
or the only built-in complex data type, xs:anyType) via an extension or restric- 
tion clause. They are usually used to exploit existing complex type definitions 
(see also Section 6.2) and to define empty elements (see Section 5.3.10). A type 
extension can be used to add extra particles and/or attributes to a base type. 
Name 
Attributes 
Contains 
compl exContent 
i d? 
mixed? 
annotation? 
(restriction I extension) 
Name 
extension 
Attributes 
Contains 
base 
id? 
annotation? 
(group I all I choice I sequence)? 
(attribute I attributeGroup)* 
anyAttri bute? 
Name 
restriction 
Attributes 
base 
id? 
Contains 
annotation? 
(group I all I choice I sequence)? 
(attribute I attributeGroup)* 
anyAttribute? 
Note: The new definition describes a superset of instances compared to the 
base type only if the particles and attributes that are added (or all elements 
contained in those particles) are optional. In this case, the instances of the 
base type are represented by the new type definition, too. This means that 
not every extended type is a supertype of the base type. 

154 
Chapter 5 XML Schema 
Given the following type definition, 
<xs: compl exType name="tPeri od"> 
<xs: sequence> 
<xs: el ement name=" from" type="xs: date"/> 
<xs:element name="to" type="xs:date"/> 
</xs: sequence> 
</xs: compl exType> 
we add an optional mode element to the complex type definition named tPeri od: 
<xs: compl exType name="tPeri odWi thMode"> 
<xs: compl exContent> 
<xs:extension base="tPeri od"> 
<xs: sequence> 
<xs: el ement name="mode" type="xs :normal i zedStri ng" mi nOccurs="O"/> 
</xs: sequence> 
</xs :extension> 
</xs: compl exContent> 
</xs: compl exType> 
The result would be equivalent to the following type definition: 
<xs: compl exType name="tPeri odWi thMode"> 
<xs: sequence> 
<xs: el ement name=" from" type=" xs: date"/> 
<xs:element name="to" type="xs:date"/> 
<xs:element name="mode '' type="xs:normalizedString" minOccurs="O"/> 
</xs: sequence> 
</xs: compl exType> 
Because the new element is optional (mi n0ccurs-"0"), the definition covers all 
instances of the original type tOeri od, too. If the new element were not defined 
as optional, the extension would not be a supertype, because the new instance 
set would not cover the instances of the original type definition. 
Note that additional elements are always added at the end of a child element 
sequence. XML Schema does not provide a way to specify a particular position 
where a new element should be inserted. 
In contrast, the restriction clause can be used to add constraints to a compo- 
nent. Given the original type definition, 

5.3 Structure in XML Schema 
155 
<xs :compl exType name="tPersonName"> 
<xs: sequence> 
<xs: el ement name="first '' type="xs: string" maxOccurs="unbounded ''/> 
<xs:element name="middle" type="xs:string '' minOccurs="O"/> 
<xs: el ement name="l ast" type="xs: string"/> 
</xs: sequence> 
</xs: compl exType> 
the following definition describes a subset of the original instance set (only 
those names with a single first name and no middle name): 
<xs :compl exType name="tPersonNameWi thOnlyOneFi rstName"> 
<xs: compl exContent> 
<xs: restri cti on base="tPersonName ''> 
<xs: sequence> 
<xs :el ement name:"first" maxOccurs=" 1"/> 
<xs:el ement name="l ast"/> 
</xs:sequence> 
</xs: restri ction> 
</xs: compl exContent> 
</xs: compl exType> 
Here, the definition of max0ccurs=" 1" is essential because we wish to override the 
max0ccuvs=" unb0unded" value. 
Actually, the original type definition of 
<xs: compl exType name="tPersonName"> 
<xs: sequence> 
<xs :el ement name="first" type="xs: string" maxOccurs="unbounded ''/> 
<xs:element name="middle" type="xs:string '' minOccurs="O"/> 
<xs:element name="last '' type="xs:string"/> 
</xs :sequence> 
</xs: compl exType> 
is only an abbreviated form of 
<xs: compl exType name="tPersonName"> 
<xs: compl exContent> 
<xs:restriction base="xs: anyType"> 

156 
Chapter 5 XML Schema 
<xs :sequence> 
<xs :el ement name="first" type="xs: stri ng" maxOccurs="unbounded"/> 
<xs:element name="middle" type="xs:string '' minOccurs="O"/> 
<xs:element name="last" type="xs:string"/> 
</xs: sequence> 
</xs: restri cti on> 
</xs: compl exContent> 
</xs: compl exType> 
Any complex type in XML Schema is a restriction of the only built-in com- 
plex type in XML Schema: xs :anyType. 
5.3.9 Type Hierarchies 
Extension and restriction applied on complex elements result in type definition 
hierarchies. This should not be misunderstood as a type hierarchy in terms of 
subtypes and supertypes. Although deriving a complex type A from another 
complex type B by restriction always results in a true type hierarchy (A being a 
subtype of B), this cannot be said for type extension. A type obtained by ex- 
tension is a supertype of the original type only if the added features (elements 
and attributes) are optional (min0ccurs="0"). This is a must if we want to keep 
the extended schema compatible with existing document instances. Table 5.4 
shows under which conditions a type derivation results in a subtype/supertype 
relation. 
On the other hand, many supertypes cannot be derived by type extension. 
For example, it is not possible to insert an optional child element into a 
sequence of elements at any position other than the end of the sequence. It is 
also not possible to add alternatives to elements (that is, replace an element 
with a choice group). 
5.3.10 Empty Elements 
Unlike the DTD, XML Schema does not have an explicit notation for empty ele- 
ments. Instead, the complex content clause can be used for that purpose: 
<xs: el ement name="track"> 
<xs: compl exType> 
<xs: compl exContent> 
<xs:restriction base="xs: anyType"> 
<xs:attribute name="title '' type="xs:string"/> 

5.3 
Structure in XML Schema 
157 
Table 5.4 Constraints for complex type restriction. 
Constraint 
Supertype 
Subtype 
Default value 
No default value 
Default value defined 
Fixed value 
No fixed value 
Fixed value defined 
Type 
No type declaration Type defined 
Cardinality 
[minOccurs, 
maxOccurs] 
Type A defined 
[nl,ml] 
Type B defined, and B 
is subtype of A 
[n2,m2] 
with 
nl <=n2 
and m2 < ml 
or 
nl < n2 
and m2 <= ml 
Remarks 
Defining a default value for a child 
element or attribute excludes those 
instances that do not contain this 
element or attribute. 
Defining a fixed value for a child 
element or attribute excludes those 
instances where this element or 
attribute does contain a different 
value. 
No type declaration is equivalent 
to ur-type in XML Schema. Any 
type in XML Schema is a subtype 
of the ur-type. 
The narrower range rn2,m2] 
excludes instances that 
violate that range but are well 
within the [nl,ml] range. 
<xs:attribute name="duration" type="xs:duration"/> 
</xs: restri cti on> 
</xs: compl exContent> 
</xs: compl exType> 
</xs: el ement> 
We use the built-in complex type xs:anyType as a base type. We restrict this 
generic base type to the two attributes title and duration. These definitions 
result in valid instance fragments such as 
<track title="Off Minor" duration="PT3M08S"/> 

158 
Chapter 5 XML Schema 
As we saw in Section 5.3.8, we can abbreviate this restriction to xs:anyType with 
the following, preferred construct: 
<xs: el ement name="track"> 
<xs: compl exType> 
<xs:attribute name="title" type="xs:string"/> 
<xs:attribute name="duration" type="xs:duration"/> 
</xs: compl exType> 
</xs: el ement> 
Here is the equivalent DTD (ignoring type declarations): 
<!ELEMENT track EMPTY> 
<!ATTLIST track 
title CDATA #IMPLIED 
duration CDATA #IMPLIED 9 
The same element without attributes 
<track/> 
would have the following definition: 
<xs :el ement name="track"> 
<xs: compl exType> 
<xs: compl exContent> 
<xs:restriction base="xs: anyType"> 
</xs: restri cti on> 
</xs: compl exContent> 
</xs: compl exType> 
</xs: el ement> 
This can be abbreviated to 
<xs: el ement name="track"> 
<xs: compl exType/> 
</xs:el ement> 
Here is the equivalent DTD: 
<!ELEMENT track EMPTY9 

5.3 Structure in XML Schema 
159 
5.3.11 Attributes 
Attributes can be added to all content models: particles, simple content, and 
complex content. Attributes are defined with the xs:attri bute clause. 
Name 
Attributes 
Contains 
attribute 
(default J fixed)? 
form? 
id? 
(name I ref) 
type? 
use? 
annotation? 
simpl eType? 
This clause always contains the definition of the attribute name. Optionally, 
it can define a type (simple types only) and can contain a use clause and a 
default or fixed value definition. The use clause can have the values required, 
optional, and prohibited. 
<xs: el ement name="track"> 
<xs: compl exType> 
<xs :simpl eContent> 
<xs: extens i on base="xs: normal i zedStri ng"> 
<xs: at t ri bute name ='' durat i on" 
type="xs: durat i on" 
use=" requi red"/> 
</xs :extension> 
</xs :simpl eContent> 
</xs: compl exType> 
</xs :el ement> 
Here is the equivalent DTD fragment (ignoring type declarations): 
<!ELEMENT track (#PCDATA)> 
<!ATTLIST track 
duration CDATA #REQUIRED > 
In this example, we have defined duration as an attribute of track. The type 
was set to the built-in type xs:duration and the use clause to required, meaning 
that this attribute must be specified in instance documents. A valid instance of 
this element would be 
<track duration:"PT3MO8S">Off Minor</track> 

160 
Chapter 5 XML Schema 
If a type has multiple attributes, the sequence of their definition does not mat- 
ter, as the attribute nodes of an element form an unordered set (see Section 
4.2.4). 
Unlike elements, attributes cannot be placed into model groups. The conse- 
quence is that we do not have the ability to define elements with mutually 
exclusive attributes. For example, we might want to define an element person 
that either has an attribute age or an attribute birthDate. The only option is to 
define a choice group with two local person elements: one with the attribute 
age, the other with the attribute birthDate---or even better, to implement both 
birthDate and age as elements! In Chapter 7 we will see how Relax NG deals 
with this problem. 
5.3.12 Global and Local Types 
Both simple types and complex types can be defined on a global level, that is, 
on the schema level. Such types must be named. This makes it possible to refer 
to these type definitions when they are used locally. For example, 
<xs:simpleType name="material "> 
<xs:restriction base="xs: string"> 
<xs: enumerat i on val ue="brass "/> 
<xs :enumeration val ue="wood"/> 
</xs: restri cti on> 
</xs: simpl eType> 
or 
<xs: compl exType name="tPeri od"> 
<xs: sequence> 
<xs:element name="from '' type="xs:date"/> 
<xs:element name="to" type="xs:date"/> 
</xs :sequence> 
</xs: compl exType> 
Typically, we define global types when these type definitions are used in sev- 
eral places. We can refer to such type definitions in element definitions and in 
extension and restriction clauses" 
<xs:element name="period" type="tPeriod"/> 
or 

5.3 Structure in XML Schema 
161 
<xs'extension base="tPeri od"> 
o
o
,
 
</xs "extension> 
or 
<xs'restriction base="tPeri od"> 
e e e  
</xs" restri cti on> 
Global types can be defined as abstract using the clause abstract="true". Such 
types cannot be used for type designation in element definitions, but can only 
be used to derive other types via extension or restriction. This can be done 
either within the schema or in the document instance with an xs i "type declara- 
tion (see Section 6.2.4). 
On the other hand, it is possible to declare a global type as final using the 
attribute final. This attribute may specify "restriction", "extension", or "#all" as 
a value. If "restricti0n" is specified, it is not possible to derive other types by 
restriction. Similarly, "extension" means it is not possible to derive other types 
by extension, and "#all", to derive other types by any method. 
5.3.13 Global Elements and Attributes 
Similar to types, elements and attributes may also be defined on a global level. 
Global elements and attributes are defined on the schema level following the 
definition of the document root element. Again, the definition of global ele- 
ments and attributes makes sense when we want to refer to this definition from 
several places. 
In the following schema we define a global element title after the definition 
of root element jazzMusi ci an: 
<?xml version="1.0" encoding="UTF-8"?> 
<xs : schema ...> 
<xs'element name = "jazzMusician"> 
o
e
o
 
</xs" el ement> 
<!--Global element definition begin here --> 
<xs.element name = "title" type = "xs'string"/> 
</xs'schema> 
When we want to reuse this definition we simply use an element reference 
like this: 
<xs .el ement ref="ti tl e"> 

162 
Chapter 5 XML Schema 
Global definition is the only way to define an element in a DTD. This has 
drawbacks: It is impossible to define elements with the same name but of differ- 
ent types in different contexts. 
5.3.14 Recursive Structures 
Global definition of elements is one way in XML Schema to define recursive ele- 
ment structures. For example, 
<xs:element name = "part"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="productNo" type="xs:token"/> 
<xs :el ement ref="part" mi nOccurs="O '' maxOccurs="unbounded ''/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
defines a recursive tree of part elements. Because the child element definition 
refers to the containing element, the containing element must be defined as a 
global element. 
Here is the equivalent DTD fragment (ignoring type declarations): 
<!ELEMENT part (productNo, part*)> 
<!ELEMENT productNo (#PCDATA)> 
This technique has a disadvantage: It is not possible to define context- 
specific recursive element structures. For example, if we want two different part 
treesmone allowing mixed content, the other not allowing mixed contentm 
and we want to use them in the same document, we have a problem. However, 
it is relatively easy to define context-specific recursions by using the group con- 
struct, discussed in detail in Section 6.2.2. Groups are defined on a global level 
and can refer to themselves and thus establish recursive structures. Nothing 
stops us from defining several recursive groups with different layouts and refer- 
encing them from context-specific but equally named elements: 
<xs: group name=" gDetai I edLi s tPart"> 
<xs: sequence> 
<xs: el ement ref="productNo"/> 
<xs: el ement name="part" maxOccurs="unbounded" mi nOccurs="O"> 
<xs: compl exType> 
<xs:sequence> 

5.3 
Structure in XML Schema 
163 
<xs :group ref="gDetai ledLi stPart"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs:element name="details" type="xs:string"/> 
</xs: sequence> 
</xs :group> 
<xs :group name="gShortLi stPart"> 
<xs:sequence> 
<xs :element ref="productNo"/> 
<xs: el ement name="part" maxOccurs="unbounded" mi nOccurs="O"> 
<xs: compl exType> 
<xs: sequence> 
<xs :group ref="gShortLi stPart"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs :sequence> 
</xs :group> 
<xs : el ement name="productNo" type="xs: string"/> 
Here, we have defined two recursive groups gDetailedListPart and gShort- 
Li stPart. Note that element productNo is defined as a global element because it 
has an identical definition in both groups. We can now set up a root element 
containing two different lists in different contexts, but both lists are con- 
structed from elements with tag part (see Figure 5.4). 
~_ ~ 
[-~__p~du~No I 
shortList [
~
~
 
part [~gShortListPart J~_~~ 
V " ~ 
I 
1..~ 
'- ['p-a~t-[~'~'~g ShortListPart 
I 
detail.List ~ 
part [~gDetailedListPart~ 
['pa~t-~gDetailedListPart 
I,= 
I-F details ] 
Figure 5.4 Two context-specific recursive lists constructed via groups. 

I~F~ 
Chapter 5 XML Schema 
<xs :el ement name="catal ogue"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="shortLi st"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="part '' maxOccurs="unbounded ''> 
<xs: compl exType> 
<xs: group ref ='' gShortLi stPart "/> 
</xs :compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs :compl exType> 
</xs: el ement> 
<xs :el ement name="detai I edLi st"> 
<xs: compl exType> 
<xs:sequence> 
<xs:element name="part" maxOccurs="unbounded ''> 
\xs: compl exType> 
<xs: group ref="gDeta i I edLi stPart"/> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs: compl exType> 
</xs:el ement> 
Used in this way, groups work similarly to non-terminal symbols in gram- 
mars--their names do not appear in instance documents. Consequently, by 
using group constructs, we should be able to express any schema that can be 
described by a regular grammar. This is not possible with DTDs! 
Here is a valid instance document. (For an explanation of the namespace 
attributes in the xs'schema clause, see Section 6.1.) 
<cata I ogue xml ns: xs i =" http://www, w3. org/2001/XMLSchema- instance" 
xs i : noNamespaceSchema Locat i on ='. catalogue, xsd"> 

5.3 Structure in XML Schema 
165 
<shortList> 
<part> 
<productNo>234</productNo> 
<part> 
<productNo>345</productNo> 
</part> 
</part> 
<part> 
<productNo>5467</productNo> 
</part> 
</shortList> 
<detailedList> 
<part> 
<productNo>234</productNo> 
<details>speaker</details> 
</part> 
<part> 
<productNo>345</productNo> 
<part> 
<productNo>5467</productNo> 
<details>valve</details> 
</part> 
<details>amplifier</details> 
</part> 
</detailedList> 
</catalogue> 
XML Schema wouldn't be XML Schema if it did not offer at least two solu- 
tions to a problem. Another way to define recursive structures in XML Schema 
is via global complex types. We want to create two part lists--one containing 
part elements with mixed content, the other containing part elements without 
mixed content. To do so we define two different types tPart and tPartMi xed that 
introduce part elements of different types locally. These part elements refer 
recursively to the previously defined type declarations. 
Here is the definition of a recursive part structure without mixed content: 
<xs :compl exType name="tPart"> 
<xs:sequence> 

166 
Chapter 5 XML Schema 
<xs:element name="name" type="xs:string"/> 
<xs:element name="price" type="xs:decimal"/> 
<xs:element name="part" type="tPart '' 
mi nOccurs="O" maxOccurs="unbounded"/> 
</xs: sequence> 
</xs: compl exType> 
The definition for the recursive part structure with mixed content looks quite 
similar: 
<xs: compl exType name="tPartMi xed" mi xed="true"> 
<xs: sequence> 
<xs:element name="name" type="xs:token"/> 
<xs:element name="price" type="xs:decimal"/> 
<xs:element name="part" type="tPartMixed '' 
mi nOccurs="O" maxOccurs="unbounded"/> 
</xs: sequence> 
</xs: compl exType> 
We can then use both type definitions to define local part elements that are 
recursive but have a different type (see Figure 5.5): 
<xs : el ement name="root"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="partsWi thoutText"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="part" 
type="tPart" maxOccurs="unbounded"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs: el ement name="partsWi thText"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="part" 
type="tPartMi xed" maxOccurs="unbounded"/> 

5.3 
Structure in XML Schema 
167 
Figure 5.5 Two context-specific recursive lists constructed via global types. 
</xs:sequence> 
</xs:complexType> 
</xs:element> 
</xs:sequence> 
</xs:complexType> 
</xs:element> 
Now we can define a document instance that can contain both types of part 
elements nested in unlimited depth: 
<root> 
<partsWithoutText> 
<part> 
<name>mouthpiece</name> 
<price>130</price> 
<part> 
<name>reed</name> 
<price>2</price> 
</part> 
</part> 

168 
Chapter 5 XML Schema 
<part> 
<name>body</name> 
<price>15OO</price> 
</part> 
</partsWithoutText> 
<partsWithText> 
<part>The part<name>mouthpiece</name>costs<price>130</price> 
and contains: <part>The part<name>reed</name>costs<price>2</price> 
</part></part> 
<part>The part<name>body</name>costs<price>15OO</price></part> 
</partsWithText> 
</root> 
5.3.15 Wildcards 
A wildcard (an element or attribute of no further specified content) can be 
declared with the XML Schema elements <xs: any/> or <xs: anyAttri bute/>. 
Name 
Attributes 
Contains 
any 
id? 
annotation? 
maxOccurs ? 
minOccurs? 
processContents? 
Name 
Attributes 
Contains 
anyAttri bute 
id? 
annotation? 
namespace? 
processContents? 
Using wildcards allows for the inclusion of elements and attributes from for- 
eign schemata and namespaces (see Section 6.1.3). In this way, sections of 
XHTML, SVG, RDF, or other content could be included in a document. For 
example: 
<xs :element name="description"> 
<xs: compl exType> 
<xs: sequence> 
<xs:any processContents="s kip"/> 
</xs: sequence> 
</xs :compl exType> 
</xs: el ement> 

5.3 Structure in XML Schema 
169 
The attributes namespace and processContents will be explained in Section 
6.1.3. 
5.3.16 Nullability 
DTDs only support the concept of optional elements: An element is either 
present or absent. Besides allowing optional elements (with min0ccurs="0"), 
XML Schema introduces a new concept. Instance elements can be set to "nil" 
by specifying the attribute xsi :ni l:"true". (Here, xsi: denotes the namespace 
prefix for XML Schema Instances http://www.w3.org/2OO1/XMLSchema-instance.) 
In the schema, the attribute 
<xs:element ... nillable="true"/> 
declares whether an element is nillable, or not (the default value is "false"). 
Nilled elements must not have any content, but they are allowed to have 
attributes! 
With the following schema fragment, 
<xs:element name="bodyPart '' nil lable="true"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="productNo" type="xs: token"/> 
</xs :sequence> 
<xs :attri bute name="col or" type="tCol orName"/> 
</xs: compl exType> 
</xs :el ement> 
we allow things like colored null values: 
<bodyPart xsi :nil="true" color="red"/> 
<bodyPart col or="green"> 
<productNo>x93932</productNo> 
</bodyPart> 
<bodyPart xsi :nil="true" color="blue"/> 
Exciting! 
Note that a nilled element is a new concept: It is neither an absent element 
(defined via min0ccurs="0") nor an empty element (see Section 5.3.10). 
In my opinion, the concept of nilled elements is of limited value. It was 
introduced to improve the compatibility of XML with certain relational data- 
base products. However, mapping, for, example, a nullable SQL field to a nill- 
able XML element may work for a specific application, but it is not a general 

170 
Chapter S XML Schema 
solution. Traditionally, in many applications nullable database fields are al- 
ready mapped to optional XML elements. So relational null values already have 
a defined representation in XML (an optional element or attribute). To repre- 
sent the new nillable elements in object-oriented or relational data models 
would therefore require a new representation in these applications. 
However, the concept makes sense if we wish to express different flavors of 
nothingness. A value may be absent for different reasons: It could be absent 
because it represents real nothingness (such as a person without a middle 
name), because the document author did not know the value (middle name 
exists, but is unknown), or it could be absent for some technical reasons (server 
breakdown, for example). These reasons could be coded into the attributes of a 
nilled element so that appropriate action can be taken. 
5.3.17 Uniqueness, Keys, Reference 
Similar to the DTDs, XML Schema provides built-in data types ID and IDREF for 
modeling cross-references between document elements. However, the main 
purpose of these data types is to provide backward compatibility with existing 
XML documents. 
XML Schema introduces a more flexible concept for keys, key references, and 
uniqueness with the key, keyref, and unique clauses. These are not hampered by 
the inherent restrictions of the DTD key concept: 
[] DTDs do not allow keys to have a specific data type, as keys must be specified 
with the ID and IDREF data types. 
[] Elements cannot be declared as keys. Only attributes can be declared as keys 
with data type ID. 
[] The data type ID can only define keys that are global for the whole docu- 
ment instance, and therefore must be unique within the scope of the whole 
document instance. 
[] ID and IDREF cannot handle composite keys. This may be required when we 
want to represent relational structures in an XML document. XML Schema 
allows composite keys. However, it must be noted that using composite keys 
creates a problem for schema validators: In general, for schemata containing 
composite keys and key references, it is not possible to determine whether 
the schema has valid instances [Fan2001]. 
Unique 
The uni que clause allows us to define nodes or node combinations that must be 
unique within a specified scope. This scope is determined by the location where 
the uni que clause is defined. 

5.3 Structure in XML Schema 
171 
Name 
Attributes 
Contains 
unique 
id? 
annotation? 
name 
selector 
fiel d+ 
Name 
Attributes 
Contains 
selector 
id? 
annotation? 
xpath 
Name 
Attributes 
Contains 
fiel d 
i d? 
annotati on? 
xpath 
The name attribute identifies the uni que constraint. It can be referenced in a 
keyref clause (discussed shortly). 
The selector element defines in its xpath attribute the document element to 
which the uni que constraint applies. This is done with an XPath expression rel- 
ative to the location where the uni que clause was defined. 
Similarly, the field elements (there can be several) define in their xpath 
attributes which combination of fields constitutes a unique value. Nodes within 
such a combination may have various data types, such as string, decimal, float, 
and so on. Here, the XPath expression is relative to the element specified in the 
sel ect0r clause. 
The XPath syntax is described fully in [Clark1999]. However, for our pur- 
poses, it is sufficient to know that document node hierarchies are expressed by 
the node names separated by slashes, that attribute names are prefixed with the 
@ character, that. denotes the current node, and that the choice operator [ sep- 
arates alternative paths. 
Let's assume we have a document with a root element a l bum. This root ele- 
ment contains child element track, which in turn contains title elements. We 
want to make sure that each track has a different title. We must therefore 
declare the t i t l e element as unique. We do so by placing a uni que clause into 
the definition of element track: 
<xs'element name="album '' ...> 
<xs 9 
compl exType> 
<xs "sequence> 
<xs "el ement name="track"> 
<xs 9 
compl exType> 
<xs'sequence> 

112 
Chapter 5 XML Schema 
<xs:element name="title" type="xs:string"/> 
</xs: sequence> 
<xs: attri bute name="trackNo" type="xs: short" use="requi red"/> 
<xs:attribute name="duration" type="xs:duration"/> 
</xs: compl exType> 
</xs: el ement> 
<xs: el ement name="sampl e"> 
<xs: compl exType> 
<xs :attri bute name="trackRef" type="xs :short"/> 
<xs: attribute name="mp3" type="xs: anyURI "/> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs: compl exType> 
e
e
,
 
<xs:unique name="uni queTi tl e"> 
<xs:selector xpath="track"/> 
<xs:field xpath="titl e"/> 
</xs :unique> 
</xs :el ement> 
Here we declare the element title as unique within the context of album. 
That is achieved by placing the xs:uni que clause into the scope of element album 
and by selecting the track element in the xs:select0r element of the xs:unique 
clause. The xpath specification in the field element locates the attribute ti t le rel- 
ative to the context specified in the xs:sel ector element. 
Key 
The key clause allows us to define nodes or node combinations as a primary key 
within a specified scope. Keys must be unique, too, but they must also be 
present within the scope where the key clause is defined. Therefore, it does not 
make sense to define an element that has been declared as a key as optional 
(min0ccurs="0"), nor to define it as nillable. 
Name 
key 
Attributes 
Contains 
id? 
annotation? 
name 
selector 
field+ 

5.3 Structure in XML Schema 
173 
The name attribute identifies the key constraint. It can be referenced in a 
keyref clause (see next section). The syntax of the selector and key clauses is 
the same as for the uni que specification. 
Let's assume we want to refer to track elements by their trackN0 attribute. We 
place the key clause into the scope of the root element album: 
<xs :el ement name="al bum" ...> 
,
e
o
 
<xs: key name="primaryKeyTrackNo"> 
<xs:sel ector xpath="track"/> 
<xs :field xpath="@trackNo"> 
</xs: key> 
</xs :el ement> 
Keyref 
The keyref clause allows us to define nodes or node combinations as a foreign 
key within a specified scope. 
Name 
Attributes 
Contains 
keyref 
id? 
annotation? 
name? 
selector 
refer 
field+ 
.
.
.
.
.
.
 
Again, the syntax of the selector and key clauses is the same as for the unique 
specification. The name attribute is optional and has no defined function. 
The attribute refer identifies the corresponding key or unique definition. Yes, 
you can refer to a unique clause! Contrary to a key clause, however, the unique 
clause does not guarantee that the reference can be resolved (it allows dangling 
references). 
The type of the keyref node (or the combination of types) must match the 
type (or combination of types) of the corresponding key or uni que definition. 
If a document instance contains those nodes that make up a foreign key, it 
must also contain the document nodes to which the foreign key relates. Other- 
wise the document would not be valid. 
Let's assume our a l bum contains a second list, sampl e, where each item refers 
to an item in the track list via its attribute trackRef. We could establish a cross- 
reference between these two lists in the following way: 
<xs:element name="album" ...> 
,
e
,
 
<xs: key name="primaryKeyTrackNo"> 
<xs:selector xpath="track"/> 

| 14 
Chapter 5 XML Schema 
<xs :field xpath="@trackNo"/> 
</xs:key> 
<xs:keyref name="foreignKeylSBN '' refer="primaryKeyTrackNo"> 
<xs:sel ector xpath="sampl e"/> 
<xs :field xpath="@trackRef"/> 
</xs: keyref> 
</xs: el ement> 
Finally, let's look at a more advanced example. We'll assume our sampl e ele- 
ment is constructed from a choice group consisting of elements goodSamp] e, bad- 
Sample, and uglySample. Each of these elements has an attribute trackRef. 
How do we construct a foreign key for a choice group? We make use of the 
XPath choice connector and specify alternate paths in the selector clause. In 
the following listing we define the complete schema for our album documents. 
The root element a l bum has two child elements: sampl e (defined as a global ele- 
ment) and track. The root element also contains a definition for a primary key 
pkTrack with the selector track and the key field @trackNo. The foreign key is 
defined with fkSample with the selector sample/goodSample i sample/badSample [ 
sample/uglySampl e and the key field trackRef. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs:schema xml ns :xs="http://www.w3.org/2OO1/XMLSchema" 
el ementFormDefaul t="qual i Bed" 
attri buteFormDefaul t="unqual i fled"> 
<xs:el ement name="al bum"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name:"track"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="title" type="xs:string"/> 
</xs: sequence> 
<xs:attribute name:"trackNo" type="xs:short" use:"required"/> 
<xs:attribute name="duration" type="xs:duration"/> 
</xs: compl exType> 
</xs: el ement> 
<xs: el ement re f:"samp I e"/> 
</xs: sequence> 
</xs: compl exType> 

5.3 
Structure in XML Schema 
175 
<xs: key name="pkTrack"> 
<xs :sel ector xpath="track"/> 
<xs :fiel d xpath="@trackNo"/> 
</xs: key> 
<xs:unique name="uni queTi tl e"> 
<xs:sel ector xpath="track"/> 
<xs:field xpath="ti tl e"/> 
</xs:unique> 
<xs: keyref name="fkSampl e" refer="pkTrack"> 
<xs : selector 
xpath="sample/goodSample I sample/badSample I sample/uglySample"/> 
<xs :field xpath="@trackRef"/> 
</xs: keyref> 
</xs: el ement> 
<xs: el ement name="sampl e"> 
<xs: compl exType> 
<xs:choice> 
<xs :el ement name="goodSampl e"> 
<xs: compl exType> 
<xs :attri bute name="trackRef" type="xs: short"/> 
<xs:attribute name="mp3" type="xs:anyURI"/> 
</xs: compl exType> 
</xs :el ement> 
<xs:el ement name="badSampl e"> 
<xs: compl exType> 
<xs:attribute name="trackRef" type="xs:short"/> 
<xs:attribute name="mp3" type="xs:anyURI"/> 
</xs: compl exType> 
</xs: el ement> 
<xs :el ement name="ugl ySampl e"> 
<xs: compl exType> 
<xs:attribute name="trackRef" type="xs:short"/> 
<xs: attribute name="mp3" type="xs :anyURI"i/> 
</xs: compl exType> 
</xs :el ement> 
</xs:choice> 

176 
Chapter 5 XML Schema 
</xs : compl exType> 
</xs: el ement> 
</xs: schema> 
The following code shows a valid document instance of the schema defined 
above: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<a I bum> 
<sample> 
<goodSample trackref="l" mp3="http://www.jazz.org/sampleA.mp3"/> 
</sampl e> 
<sample> 
<badSampl e trackref="2"/> 
</sample> 
<track trackNo="l" duration="PTM10S47"> 
<title>happy for you</title> 
</track> 
<track trackNo="2" duration="PTM3S13"> 
<title>bad feel ings</titl e> 
</track> 
</album> 
Note: This schema could not be expressed as a DTD. The ID/IDREF construct 
used in DTDs to establish cross-references requires ID and IDREF attributes to 
have NMTOKEN values. NMTOKEN values, however, must start with a letter. 
This does not fit with our integer track numbers. In addition, DTDs do not 
have a uni que construct. 
5.3.18 Deterministic Types 
Appendix E of the second edition of the XML 1.0 Recommendation notes that 
content models should be deterministic (unambiguous). This requirement 
exists for the purpose of compatibility with SGML. SGML parsers may flag a 
nondeterministic schema as ambiguous. XML Schema also requires content 
models such as ch0 ice groups and al 1 groups to be deterministic (Unique Particle 
Attribution). 
A content model is deterministic if all particles defined in the model can be 
reduced to a deterministic regular expression (see Section 1.7.6). A regular 

5.3 Structure in XML Schema 
177 
expression is deterministic if at each choice point it is possible to decide which 
branch to take without having to look ahead. Let's look at an example: 
<xs : compl exType name="tName"> 
<!-- This schema fragment violates the Unique Particle Attribution 
constraint! --> 
<xs: choi ce> 
<xs: sequence> 
<xs :element name="first"/> 
<xs :el ement name="l ast"/> 
</xs: sequence> 
<xs: sequence> 
<xs :el ement name="first"/> 
<xs :el ement name="mi ddl e"/> 
<xs :el ement name="l ast"/> 
</xs :sequence> 
</xs:choice> 
</xs: compl exType> 
This type definition is not deterministic because both choice branches begin 
with the same elements. However, the same type can be easily expressed in a 
deterministic (and more compact) way: 
<xs: compl exType name="tName"> 
<xs: sequence> 
<xs: el ement name="first"/> 
<xs :el ement name:"mi ddl e" mi nOccurs="O"/> 
<xs:el ement name="l ast"/> 
</xs : sequence> 
</xs: compl exType> 
The Unique Particle Attribution is subject to an ongoing debate. The ques- 
tion is: What is more desirable, efficient parsers or easier schema authoring? 
Arguably, if somebody should suffer, it should be the machine and not the 
human. But nondeterminism can cause the parser to suffer very much, indeed, 
as a look-ahead may stretch across several megabytes. And then it is the end 
user who suffers because of unacceptable response times. 
It is not always possible to make a definition deterministic. The follow- 
ing schema was written to describe a small orchestra consisting of either seven 

1111 
Chapter 5 XML Schema 
saxophone players or three guitarists. It violates the Element Declarations Consis- 
tent constraint: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs: schema xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
el ement FormDefaul t=" qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<!-- This schema violates the Element Declarations Consistent 
constraint! --> 
<xs :el ement name="orchestra"> 
<xs: compl exType> 
<xs:choice> 
<xs:element name="musician '' minOccurs="7" maxOccurs="7"> 
<xs: compl exType> 
<xs :sequence> 
<xs :el ement name="saxophone"/> 
</xs:sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs :el ement name="musi ci an" mi nOccurs="3" maxOccurs="3"> 
<xs: comp I exType> 
<xs : sequence> 
<xs:el ement name:"gui tar"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs :choice> 
</xs: compl exType> 
</xs: el ement> 
</xs :schema> 
This structure is nondeterministic because both branches begin with a musi- 
ci an tag. There is no way we could refactor this structure into an equivalent 
nondeterministic structure. In XML Schema, the above schema is illegal: Using 
an element (musician) with different type declarations within the same choice 
clause is not allowed. In such cases we are required to change the document 
structure, for example, to rename the musician elements as saxophonist and 
guitari st, or to use a different namespace for each musician element. 

6.1 
6.2 
6.3 
6.4 
Namespaces 
Reuse Mechanisms 
Schema Composition 
Usage Patterns 
N 
ow that you have been introduced to the type system of 
XML Schema in Chapter 5, we continue our tour de force 
in this chapter. The first section discusses the overall structure of 
schemata written with XML Schema and how namespaces are 
handled. The next two sections cover reuse mechanisms and 
schema composition. (Schema composition is a must if we want 
to define multi-namespace schemata.) The final section, "Usage 
Patterns," discusses some best practices for authoring XML 
schemata with XML Schema. 
179 

180 
Chapter 6 Authoring XML Schema 
6.1. NAMESPACES 
XML Schema provides full support for XML namespaces (see Section 4.1), so 
much so that the whole concept of schemata is based on the concept of target 
namespaces. In addition, schemata can ask their instances to qualify elements 
and attributes with namespace declarations, and wildcards can be used to 
include content from foreign namespaces. 
6.1.1 Target Namespace 
The main mechanism for namespace support with XML Schema is the target- 
Namespace declaration. Each schema file that contains a targetNamespace declara- 
tion serves as a description of that particular namespace. A schema file may 
describe only a single namespace, but there can be several schema files for the 
same target namespace. For example: 
<xs : schema xml ns: xs="http://www, w3. org/2001/XMLSchema" 
targetNamespace=" http://www, j azz. org"> 
As shown in Figure 6.1, the namespace serves as the connecting element 
between document instances and schemata. For each namespace declared in a 
document instance, an XML processor will try to find a corresponding schema 
definition. The document instance may help the XML processor in this process 
by specifying a schema location. But this is not required, and the XML proces- 
sor is free to choose a different schema definition, for example, a built-in 
schema definition (see Section 6.3.2). 
It is also possible to define schemata without a target namespace. These 
schemata can be used to describe unqualified elements (discussed next), or they 
can be assigned to a namespace when they are used--for example, when they 
are imported into another schema. 
6.1.2 Qualified and Unqualified Names 
A schema may ask that the local elements and attributes of its target namespace 
be specified in qualified or in unqualified form in document instances (see Sec- 
tion 4.1). A document instance has two ways to qualify element and attribute 
names: 
m It can equip elements and attributes with a namespace prefix. 
[] It can define a default namespace. 
A schema can ask for qualified names for each element or attribute individu- 
ally, using the f0rm="qualified" attribute within element and attribute defini- 
tions. It can also specify el ementFormDefaul t="qual ified" or attri buteFormDefaul t= 
"qualified" as attributes of the <schema> clause. This will ask for qualification of 
all elements or attributes unless they are specified with form="unqual ified". 

6.1 Namespaces 
181 
Figure 6.1 Schemata are connected to instances via namespaces. Optionally, an 
instance may specify a schema location. The same logic applies when a schema 
imports types from other schemata, as shown in the lower section of this diagram. 
Note that these declarations apply only to local elements and attributes, 
not to global elements (see Section 5.3.13). Global elements must always 
appear in qualified form in document instances, either qualified by prefix or by 
using a default namespace. The reason for this is that a processor must be able 
to locate the schema definition that belongs to an element's namespace. Since 
local elements always have a global ancestor element, the processor is always 
able to determine the namespace, because the global ancestor element is 
always qualified. 

182 
Chapter 6 Authoring XML Schema 
However, this can lead to disturbing situations. The combination of el ement- 
FormDefaul t="unqual ified" and not providing a default namespace in a document 
instance can make the authoring of document instances difficult. Document 
authors need to know which elements are defined locally and which elements 
are defined globallymglobal elements must be specified with a namespace pre- 
fix, while local elements must not be specified with a namespace prefix. 
The consequence is: Always use el ementF0rmDefault="qual ified". Either deco- 
rate both local and global elements consistently with namespace prefixes, 
or define a default namespace for the document instance and do not prefix 
local and global elements. Since attributes inherit their in-scope name- 
spaces from their owner elements, it is fine to specify attributeFormDefault= 
"unqua I i fled". 
6.1.3 Wildcards 
The wildcards <xs:any/> and <xs :anyAttri bute/> are used to declare elements 
and attributes that can contain content from other namespaces (see Section 
5.3.15). This namespace is defined with the attribute namespace. 
Wildcards can be processed by an XML processor in three ways: 
[] processContents="skip" indicates that there are no constraints regarding the 
content of the element or attribute. It is sufficient that the content is well 
formed. An XML processor will not check the content for validity. 
[] processContents="lax" requires that the element or attribute is valid when it 
is declared. If the processor cannot obtain the corresponding schema defini- 
tion, the content is not checked. 
[] processContents="strict" requires that the element or attribute is declared in 
the specified namespace or in the document instance via an xsi :type decla- 
ration (see Section 6.2.4), and that it is valid. This instruction requires the 
XML processor to obtain the corresponding schema definition and to per- 
form the necessary checks. This is the default value. 
The attribute namespace can be used to specify a list of namespace identifiers. 
This list can contain 
m Explicit namespace URIs. 
[] The string "##targetNamespace". This specifies the target namespace of the 
current schema. 
m The string "##local ". This specifies the namespace of the respective docu- 
ment instance. 
As an alternative to a list, the following string values can be specified: 
[] "##any". Any namespace. This is also the default value of the namespace 
attribute. This value is often used together with processContents="skip". 
[] "##other". Any namespace other than the target namespace. 

6.1 Namespaces 
183 
The following example defines an element description that must contain 
valid XHTML content: 
<xs: el ement name ='' descri pt i on"> 
<xs: compl exType> 
<xs: sequence> 
<xs :any namespace="http://www.w3.org/1999/xhtml" 
processContent s=" st ri ct"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
6.1.4 Schema Default Namespace 
Because a schema defined with XML Schema is an XML document, too, it is 
possible to define a default namespace for the schema itself. This default name- 
space applies to all elements and attributes used in the schema definition that 
are not decorated with a namespace prefix. This includes the XML Schema dec- 
larations such as <element>, <attribute>, <simpleType>, or <compl exType>. 
Basically, we have three options for assigning a default namespace: 
[] Use the target namespace as the default namespace. In this case we do not have 
to prefix the items that we define in the schema and that belong to the target 
namespace. Instead, we prefix all XML Schema declarations with an appro- 
priate prefix such as xs:. This is the preferred method for using the default 
namespace because it makes schema composition easy: Unqualified defini- 
tions (those that do not belong to a namespace) from external schema parts 
that we include (see Section 6.3.3) are automatically added to the default 
namespace (which is the target namespace). This is the desired behavior. For 
example: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs: schema xml ns :xs="http://www. w3. org/2OOl/XMLSchema" 
targetNamespace=" http://www, jazz. org" 
xml ns ='' ht tp://www, jazz. org" 
el ement FormDe fau I t ='' qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs :el ement name:"jazzMusi ci an" type="tJazzMusi ci an"/> 
0
0
,
 
</xs:schema> 
[] Use the XML Schema namespace as the default namespace. In this case we do 
not have to prefix the XML Schema declarations, but we have to prefix the 

184 
Chapter 6 Authoring XML Schema 
elements, types, and attributes that we define in the schema. This method is 
less flexible than the previous method: Unqualified definitions from in- 
cluded schemata would be added to the XML Schema namespace, which is 
not desired. For example: 
<schema xml ns="http://www.w3.org/2OO1/XMLSchema" 
targetNamespace=" http 9 
jazz. org" 
xml ns :j azz=" http://www, j azz. org" 
el ementFormDefaul t="qual i fled" 
attri buteFormDefaul t="unqual i Bed"> 
<el ement name:"j azz: j azzMus i c i an" type =''jazz: tJ azzMus i c i an"/> 
o o o  
</schema> 
nn Use no default namespace at all. In this case we have to prefix XML Schema de- 
clarations, and the elements, types, and attributes that we define in the 
schema. Again, this method causes trouble when unqualified definitions are 
included from external schemata. These definitions would not belong to any 
namespace, which results in an error when the schema is used. For example: 
<?xml version="l.O" encoding="UTF-8"?> 
<xs: schema xml ns: xs=" http://www, w3. org/200 i/XMLSchema" 
ta rgetNames pace=" ht tp://www, j azz. org" 
xml ns: jazz:" ht tp://www, jazz. org" 
e I ement FormDefau I t= "qua I i fled" 
attri buteFormDefaul t="unqual i Bed"> 
<xs:element name="jazz:jazzMusician" type="jazz:tJazzMusician"/> 
o o o  
</xs:schema> 
Clearly, the first option (using the target namespace as the default namespace) 
is the way to go. 
6.2 REUSE MECHANISMS 
XML Schema provides various mechanisms for elements reusing existing decla- 
rations, in particular global elements and types and various group constructs. 
6.2.1 Global Elements and Global Types 
Sections 5.3.12 and 5.3.13 discussed the definition of global elements and 
global types. The question for the schema author is: When should I use global 
elements, and when is it better to define a global type? 

6.2 Reuse Mechanisms 
185 
The answer is easy: Types are much more flexible constructs than elements. 
In almost all cases, it is better to define a global type instead of a global element. 
Global types can be used for element declaration, but it is also possible to derive 
other types from them via restriction and extension. In addition, we can build 
separate type libraries and import them with the import statement (see Section 
6.3.5). In contrast, a global element can only be referred to, and that's it 
(almost). 
There are two exceptions where a global element is more appropriate: 
[] Defining recursive structures is only possible by reference, and reference re- 
quires global elements (see Section 5.3.14). Using global elements is not the 
only way to define recursive structures, but it is the simplest. 
[] Elements that are subject to substitution (see Section 6.2.5) must be defined 
as global elements. 
Of course, nothing stops us from using global elements and global types in 
combination. A global element can always refer to a global type definition. This 
solution provides the most flexibility. We can easily redefine types and use type 
libraries, while allowing other schemas that are importing our schema to apply 
substitution mechanisms to the globally defined elements. 
6.2.2 Groups 
A group definition can furnish a model group with a name. Groups can only be 
defined globally on the schema level. In Section 5.3.14 we used groups to define 
context-specific recursive structures. Groups are the most flexible construct for 
defining complex document structures. 
Name 
Attributes 
Contains 
group 
(name I ref ) 
annotation? 
(all I choice I sequence)? 
For example, we define a group: 
<xs :group name="gName"> 
<xs: sequence> 
<xs: el ement name="first "/> 
<xs:el ement name="l ast"/> 
</xs :sequence> 
</xs :group> 
This group can now be referenced by name instead of explicitly specifying a 
model group: 

186 
Chapter 6 Authoring XML Schema 
<xs :el ement name="name"> 
<xs: compl exType> 
<xs :group ref="gName"/> 
</xs: compl exType> 
</xs: el ement> 
6.2.3 Attribute Groups 
Similar to groups, attribute groups can combine several attribute definitions 
into a single named group. Attribute groups can only be defined globally on the 
schema level. 
Name 
Attributes 
Contains 
attri buteGroup 
i d? 
(name I ref) 
annotation? 
(attribute I attributeGroup)* 
anyAttribute? 
For example, we define the attribute group: 
<xs :attri buteGroup name="aName"> 
<xs:attribute name="first" type="xs:string"/> 
<xs:attribute name="last" type="xs'string"/> 
</xs: attri buteGroup> 
The whole group can then be referenced by specifying the group name instead 
of specifying each individual attribute. 
<xs :el ement name="person"> 
<xs: compl exType> 
o o o  
<xs :attributeGroup ref:"aName"/> 
</xs: compl exType> 
</xs: el ement> 
6.2.4 Instance Type Overriding 
XML Schema allows document instances to override the type of elements (but 
not of attributes) locally with another type definition. This can be done with 
the xsi:type attribute. "xsi:" is the prefix for the namespace http:// 
www.w3.0rg/2001/XMLSchema-instance and must be declared in the document 

6.2 Reuse Mechanisms 
187 
instance. This namespace contains all XML Schema declarations that may 
appear in document instances. 
The new type can be a built-in type or a type defined globally in the schema, 
but must be a type that is derived 1 from the original type of the element. In the 
following example from Section 5.2.10, we use an xsi :type definition in the 
document instance to select a specific member element from a union type: 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema xml ns :xs="http://www.w3 .org/2OOl/XMLSchema" 
e I emen t Fo rmDe fau I t = "qua I i fled" 
xml ns="href://www, ni I e. corn" 
targetNamespace=" href://www, ni I e. com" 
attri buteFormDefaul t=" unqual i fled"> 
<xs :simpl eType name="tlSBN"> 
<xs:restriction base="xs: stri ng"> 
<xs:pattern value="(\d)-(\d){3}-(\d){5}-(\d)"/> 
</xs: restri cti on> 
</xs: s imp l eType> 
<xs :simpl eType name="tProductNo"> 
<xs:restriction base="xs: string"> 
<xs:pattern val ue="9-((\d) {3,5}-) {2} (\d)"/> 
</xs: restri cti on> 
</xs: simpl eType> 
<xs :simpl eType name="tlSBNorProductNo"> 
<xs:union memberTypes="tlSBN tProductNo"/> 
</xs: simpl eType> 
<xs: el ement name="product"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="productNo" 
type = "t I S BNorProduct No"/> 
</xs :sequence> 
</xs: compl exType> 
1. In the case of simple types, XML Schema uses the narrower definition of derived as 
defined in Part One of the XML Schema Recommendation. Derivation by list exten- 
sion or union is not allowed for instance type overriding. However, the member types 
of a union or a list are valid derivations of the corresponding union or list type. 

188 
Chapter 6 Authoring XML Schema 
</xs: el ement> 
</xs:schema> 
In a particular document instance, we can ensure that the tProductN0 type 
definition is used by an XML processor by overriding the type definition of its 
productNo element via xsi "type="tProductNo"" 
<?xml version="1.0" encoding="UTF-8"?> 
<product xmlns="href://www.ni le.com"> 
<productNo xml ns :xs i =" http://www, w3. org/2OO1/XMLSchema- instance" 
xsi : type="tProductNo">O-646-27288-8</productNo> 
</product> 
This is possible because tProductNo is a member type of tlSBNorProductNo, and 
consequently is regarded as derived from tISBNorProductNo. Without this over- 
riding, the content of this productNo instance would be interpreted as of type 
tISBN because tISBN is specified first in the union clause, and "0-646-27288-8" 
satisfies the t I SBN pattern. 
Of course, the discrimination between tISBN and tProductNo does not make 
much sense if we only want to validate a document. But for other XML proces- 
sors, different types might imply different semantics; in such cases, type over- 
riding would enforce different behavior. 
Overriding schema type definitions in a document instance is, of course, also 
possible for complex types, provided the complex type definition was not deco- 
rated with a block attribute. The block attribute can take the values #all, 
restriction, extension, or combinations of restriction and extension. It is there- 
fore possible to inhibit selectively the restriction or the extension of a complex 
type in document instances, or to inhibit both. (The block attribute is not 
allowed for simple type definitions. However, we can inhibit the overriding of 
simple types by using the block attribute in the definition of elements.) 
Typical use cases for instance type overriding are 
m The type defined in the schema is abstract. The instance must specify a con- 
crete derived type. 
m The document schema is fairly generic and does not define the type of ele- 
ments but leaves this task to document instances. One application that heav- 
ily uses this technique is SOAP. 
[] We want to convey meta-information to the application as in the example 
given above. 
6.2.5 Substitution Groups 
Substitution groups are a kind of alias mechanism for elements. An element is 
called substitutable if it specifies a so-called head element via the substitution- 
Group attribute. The element referring to the head element must be of a type 

6.2 Reuse Mechanisms 
189 
that can be derived 2 (via extension or restriction) from the type of the head ele- 
ment, and both the head element and the referring element must be defined 
globally. 
Since head elements and referring elements can belong to different name- 
spaces, substitution groups are a great way to cross namespace borders. For 
example, when we include or import definitions (see Sections 6.3.3 and 6.3.5) 
from another schema file, there are always cases when we might not want to 
use the defined element names but would like to rename. This can be done with 
substitution groups, as long as the elements were defined globally. Substitution 
groups allow mediating between different namespaces and different schema 
parts. 
Let's assume we have a schema file with target namespace http:// 
www.jazz.0rg/generic and that this file contains the definition for an element 
instrument: 
<xs: el ement name="i nstrument" type="xs: stri ng" abstract="true"/> 
This element is not intended to appear in instance documents, as we have 
defined it as abstract. We now want to define another schema with target name- 
space http://www.myMusicShop.com/instruments in which we import the above 
definition. However, we do not want to keep the name instrument but would 
prefer to use specific instruments like saxophone and trombone. We can 
achieve this with a substitution group: 
<xs:element xmlns:j:"http://www.jazz.org/generic" 
name="saxophone" substi tuti onGroup="j : i nstrument"/> 
<xs:element xmlns:j="http://www.jazz.org/generic" 
name="trombone" type="xs : normal i zedStri ng" 
subst i tut i onGroup="j : i nstrument"/> 
For the element trombone, we have restricted the type to xs:normal izedString. 
This is possible, since instrument was defined with xs:string, and xs :n0rmal ized- 
String is a restriction of xs:string. However, if instrument was defined with type 
xs:token, then the definition of trombone would be invalid because xs :normal- 
i zedString is not derived from xs:token (see Section 5.2.9). 
It is possible to protect an element against the definition of substitution 
groups by defining it as final. The final attribute can take the values #all, 
restriction, and extension, or a combination of restriction and extension. It is 
therefore possible to protect an element against specific substitution methods. 
2. In the case of simple types, XML Schema uses a narrower definition of derived as 
defined in Part One of the XML Schema Recommendation. Derivation by list exten- 
sion or union is not allowed for substitution groups. However, the member types of a 
union or list are valid derivations of the corresponding union or list type. 

190 
Chapter 6 Authoring XML Schema 
Similarly, it is possible to protect an element against the application of sub- 
stitution groups in document instances by decorating it with a bl0ck attribute. 
This attribute can take the value #al I, the values restriction, extension, substi- 
tut i on, or combinations thereof. 
For an application of substitution groups in a larger example, please see Sec- 
tion 6.4.2. 
6.3 SCHEMA COMPOSITION 
A schema does not necessarily consist of a single file but may consist of several 
components, may refer to type libraries, and so forth. This section discusses 
the various possibilities, such as include, import, and redefine, for composing 
schemata within the same namespace and across namespaces. 
Theoretically, these mechanisms allow for construction of very deep inclu- 
sion and redefinition hierarchies. (COBOL copy code experts will be delighted.) 
However, it is good practice to keep these hierarchies as flat as possible. 
This improves readability and avoids cyclic inclusions and contradicting 
redefinitions. 
6.3.1 The Schema Clause 
The schema clause is the root element of any schema file. 
Name 
Attributes 
Contains 
schema 
attri buteFormDefaul t? 
bl ockDefaul t ? 
el ement FormDefau I t ? 
finaIDefaul t? 
id? 
targetNamespace? 
version? 
(include [ import l redefine l 
annotation)* 
((simpleType [ complexType [ group [ 
attri buteGroup l 
element l attribute I notation), 
annotation*)* 
xml : l ang? 
The schema clause defines the default values for the form attributes in 
attribute definitions, form attributes in element definitions, block attributes, 
and final attributes. As child elements, it contains definitions that must be 
made on the schema level such as global types, global elements and attributes, 
groups and attribute groups, and notation declarations. The schema clause may 
also be decorated with one or several annotations. 

6.3 Schema Composition 
191 
6.3.2 Locating Schemata 
XML instances may specify the schemata that can be used for validation of the 
instance via the xsi :schemaL0cati0n attribute. Because this declaration is located 
in the document instance, it must be qualified with the namespace for XML 
Schema instances that must be declared in the document instance, too. 
xml ns: xs i =" http://www, w3. org/2001/XMLSchema- instance" 
xsi : schemaLocati on="http://www, jazz. org/encycl opedi a 
ht tp://www, jazz. org/encyc I oped i a. xsd" 
The schemaLocation attribute contains one or several pairs of URIs. The first 
URI in each pair identifies the namespace, while the second URI in each pair 
specifies the location of the corresponding schema. Note that the latter is only 
a hint from the document author to the XML processor about where to find the 
schema. It is up to the processor to use this schema reference or not. For exam- 
ple, an SVG processor or a SMIL processor may discard this reference and use 
its built-in schema definition for the SVG or SMIL namespace. The location of 
schemata that do not have a namespace can be specified with the attribute 
noNamespaceSchemaLocat i on. 
6.3.3 Include 
The mechanisms for inclusion, redefinition, and import allow us to establish 
and use type libraries. Type libraries are useful because they help to standardize 
type definitions within a corporation or across corporations. 
A schema definition can include any number of external schema files. How- 
ever, there is a condition: An included external schema file must have the same 
target namespace definition as the including file, or no target namespace defini- 
tion at all. In the latter case, the definitions in the included schema are adapted 
to the target namespace of the including schema. 
The include, redefine (Section 6.3.4), and import (Section 6.3.5) clauses must 
always be located at the beginning of a schema clause. 
Name 
Attributes 
Contains 
include 
id? 
annotation? 
schema Loca t i on 
For example: 
<xs : i ncl ude schemaLocat i on : "http://www.j azzstore, com/cd, xsd"/> 
This clause has basically the same effect as pasting the content of http://www 
.jazzstore.c0m/cd.xsd into the current schema file. 

192 
Chapter 6 Authoring XML Schema 
6.3.4 Redefine 
The redefine clause works similarly to the i ncl ude clause. A redefined external 
schema file must have the same target namespace definition as the including 
file, or no target namespace definition at all. What is different from the i ncl ude 
clause is that redefine allows modification of the included definitions. For exam- 
ple, simple types can be restricted, and complex types can be extended or 
restricted. 
The include, import, and redefine clauses must always be located at the begin- 
ning of a schema clause. 
Name 
Attributes 
redefine 
id? 
schemaLocati on 
Contains 
(annotation I simpleType I complexType I 
group I attributeGroup)* 
Given the following schema in file tName.xsd, 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema xml ns: xs="http://www, w3. org/2001/XMLSchema" 
el ement FormDefau I t= "qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs: compl exType name="tName"> 
<xs: sequence> 
<xs:el ement name="first" maxOccurs="unbounded ''/> 
<xs:element name="middle" minOccurs="O"/> 
<xs: el ement name="l ast"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: schema> 
we can now include this type definition in another schema and at the same 
time redefine it: 
<xs: redefine schemaLocati on="tName.xsd"> 
<xs: compl exType name="tName"> 
<xs: compl exContent> 
<xs: restri cti on base="tName"> 
<xs :sequence> 
<xs:element name="first" maxOccurs="l"/> 

6.3 Schema Composition 
193 
<xs :el ement name="l ast"/> 
</xs: sequence> 
</xs: restri ction> 
</xs: compl exContent> 
</xs: compl exType> 
</xs: redefine> 
Note that the name of the redefined complex type and the name of the base 
type are identical (tName)! This is required by the redefinition mechanism. It is 
possible to redefine all or only some of the included types. 
It is also possible to redefine groups and attribute groups. Given the follow- 
ing schema in file gName.xsd, 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema xml ns :xs ='' http://www, w3. org/2001/XMLSchema" 
e I emen t Fo rmDe f au I t = "qua I i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<xs :group name="gName"> 
<xs: sequence> 
<xs :el ement name="first"/> 
<xs :element name="l ast"/> 
</xs :sequence> 
</xs :group> 
o o o  
</xs:schema> 
we can now extend this group via a redefinition: 
<xs: redefine schemaLocati on="gName.xsd"> 
<xs :group name="gName"> 
<xs: sequence> 
<xs :group ref="gName"/> 
<xs:element name="middle" minOccurs="O"/> 
</xs :sequence> 
</xs :group> 
</xs: redefine> 
Again, the redefined group has the same name as the group to which it refers. 

194 
Chapter 6 Authoring XML Schema 
6.3.5 Import 
In contrast to include, the import clause can combine several schemata from 
different target namespaces. This is important since a single schema definition 
only supports a single target namespace. Multi-namespace schemata or in- 
stances must therefore be composed from several schema files. 
The include, import, and redefine clauses must always be located at the begin- 
ning of a schema clause. 
Name 
Attributes 
Contains 
import 
id 
annotation? 
namespace 
schemaLocation 
A multi-namespace schema defines the namespaces used with their prefixes 
via a standard namespace declaration in the schema element. Directly after the 
schema element, the necessary import statements are specified to import the for- 
eign namespaces. 
Optionally, the import statement may specify the schema location in order to 
help the XML processor to locate the schema file that defines that namespace. 
However, for the XML processor, this is only one possible source of informa- 
tion. Document instances may specify schema locations for the various name- 
spaces, too, and the processor is free to use built-in namespace definitions for 
particular namespaces (see Section 6.3.2). 
The following schema imports the XHTML namespace and assigns the prefix 
html : to it. We can then, for example, refer to the XHTML blockquote element 
definition. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns: html ="http://www. w3. org/1999/xhtml" 
targetNamespace=" http://www, j azz. org" 
xml ns=" http://www, jazz. org" 
el ement FormDefaul t="qual i Bed" 
attri buteFormDefaul t=" unqual i fled"> 
<xs: import namespace="http://www, w3. org/1999/xhtml "/> 
<xs :el ement name="descri pti on"> 
<xs: compl exType> 
<xs: sequence> 
e e o  
<xs:element ref="html :blockquote"> 

6.3 Schema Composition 
195 
<XS : sequence> 
<xs: compl exType> 
</xs :el ement> 
</xs:schema> 
Note: The namespace attribute in the import clause is optional, too. An import 
without a namespace attribute imports definitions without namespace qualifi- 
cation. Consequently, it allows unqualified references (references without a 
namespace prefix or a default namespace) to external definitions. 
6.3.6 Notation 
The notation element supports the simple abstract type NOTATION and provides 
the functionality known from the XML 1.0 NOTATION declarations (see Sec- 
tion 4.2.11). Its purpose is to provide compatibility for the translation of DTDs 
into XML Schema. 
Name 
Attributes 
Contains 
notation 
id? 
appinfo? 
name 
public? 
system? 
The following example includes a jpeg image in a document and defines 
application viewer.exe as its processor. 
<xs : notat i on name=" jpeg" publ i c ='' image/jpeg" system="vi ewer. exe"/> 
6.3.7 Annotations 
Any element of an XML Schema definition can contain one or several annota- 
tions. Annotations can contain both appinfo elements and documentation ele- 
ments as child elements, appinf0 elements contain user-defined information for 
machine consumption, while documentation elements contain information for 
human readers. 
Name 
Attributes 
Contains 
annotation 
(appinfo I documentation)* 
Here is an example of using appinfo to describe physical properties of a 
schema element to a native XML database (Software AG's Tamino, see also Sec- 
tion 11.11.1): 

196 
Chapter 6 Authoring XML Schema 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs: schema xml ns: xs="http://www, w3. org/200 I/XMLSchema" 
xml ns: x=" http://www, w3. org/1999/xhtml" 
xmlns:tsd = 
"http 9 
softwareag, com/tami no/Tami noSchemaDefini t i on" 
targetNamespace=" http://www, ni I e. com" 
xml ns=" http://www, ni I e. com" 
el ement FormDefaul t="qual i fled" 
a t t r i but eFo rmDe f au I t =" unqua I i fled "> 
<xs:element name = "productNo" type = "xs:NMTOKEN"> 
<xs:annotation> 
<xs: appi nfo> 
<tsd: el ement I n fo> 
<tsd:physical> 
<tsd:native> 
<tsd: index> 
<tsd: standard/> 
</tsd: index> 
</tsd:native> 
</tsd:physical> 
</tsd: el ement Info> 
</xs:appi nfo> 
<xs: documentat i on> 
Element <x:i>productNo</x:i> is to be stored as a native XML 
element. It is used as a standard index to allow efficient 
access to album documents by <x:i>productNo</x:i>. 
</xs: documentati on> 
</xs: annotat i on> 
</xs:el ement> 
</xs: schema> 
Note that XHTML is used to mark up the documentation text. This should be 
adopted as a best practice. (Similarly, HTML is consistently used to mark up doc- 
umentation in Java source code and JavaDocs.) 
6.4 USAGE PATTERNS 
The following sections discuss some advanced techniques that exploit the mod- 
ularity and reuse mechanism of XML Schema. These patterns also qualify as 
best practices recommendations. 

6.4 Usage Patterns 
197 
6.4.1 Chameleon Components and Type Libraries 
Reusing XML Schema components requires some consideration. It requires that 
we design the single components with their possible reuse purposes in mind. 
One aspect of this is how we treat namespaces. 
When furnishing a generic schema component such as a type library with a 
fixed target namespace, we have already restricted the possible reuse scenarios. 
We have removed one point of variation (one degree of freedom)rathe compo- 
nent has lost some flexibility. It now contains type definitions that belong to a 
dedicated namespace; we cannot use it in other scenarios where other name- 
spaces are in effect. 
So, it is a good idea not to equip generic components with a target name- 
space. Such components are called chameleon components. They can easily be 
inserted into other schema files that do have a target namespace, and of course, 
we want them to blend into that target namespace. This is in fact the case: XML 
adds included components that do not have a target namespace to the target 
namespace of the including schema. 
Let's look at an example. We define a small type library named customer.xsd 
(see Figure 6.2) with just a single type tCustomer: 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema xml ns: xs="http://www, w3. org/200 I/XMLSchema" 
e I ement Fo rmDe fau I t = "qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs:compl exType name="tCustomer"> 
<xs: sequence> 
<xs:element name="customerlD" type="xs-string"/> 
<xs :el ement name="name"> 
<xs" compl exType> 
-customerlD 
tCustomer 
name 
Figure 6.2 The chameleon component customer.xsd. 
-first 
type I xs:string 
last 
type I xs:slring 

198 
Chapter 6 Authoring XML Schema 
<xs: sequence> 
<xs: el ement name= "first " type="xs: stri ng"/> 
<xs:element name="last" type="xs:string"/> 
</xs :sequence> 
</xs :compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs: compl exType> 
</xs :schema> 
We can use this type definition in a schema such as the following invoice 
schema (see Figure 6.3): 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema targetNamespace="http://www.ni I e.com/bi I I ing" 
xml ns: xs=" http://www, w3. org/200 I/XMLSchema" 
xml ns="http://www, ni I e. com/bi I I i ng" 
el ement FormDefaul t="qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs: i ncl ude schemaLocat i on=" customer, xsd"/> 
<xs :el ement name="i nvoi ce"> 
<xs: comp I exType> 
<xs: sequence> 
<xs :el ement name="customer" type="tCustomer"/> 
<xs: el ement name="i tem"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="Amount" type="xs:positivelnteger"/> 
<xs:element name="productNo" type="xs:string"/> 
<xs:element name="price" type="xs:decimal"/> 
</xs: sequence> 
</xs: compl exType> 
</xs:el ement> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs :schema> 

6.4 Usage Patterns 
199 
Figure 6.3 Invoice schema using type library customer.xsd. 
What is important here is how we define the default schema namespace. As 
you can see, the default schema namespace is the same as the target namespace, 
while the XML Schema namespace is linked with the prefix xs:. Consequently, 
we have to decorate each XML Schema term, such as sequence or comp]exType, 
with the prefix xs:, whilemand this is importantuthe elements of invoice do 
not need a qualifying prefix. If we had chosen to define the default schema 
namespace differently, we would need to qualify all elements of i nvoi ce with a 
prefix because they belong to the target namespace. This would also apply to 
the elements included from the type library customer.xsd. This, of course, is not 
possible, as customer.xsd is defined without a namespace. 
So, the golden rule for schema design is 
target namespace = default schema namespace 
With this policy and with chameleon components, we can easily create type 
libraries that can be included in schemata of different target namespaces. 
Note that we can also apply this technique on the document instance level. 
We can include chameleon components into document instances using the 
noNamespaceSchemaLocation declaration, as discussed in Section 6.3.2. The com- 
ponent will be added to the default namespace of the document. 

200 
Chapter 6 Authoring XML Schema 
6.4.2 Defining Schema Families 
A common problem, especially in electronic businesses, is adapting schemata to 
national, regional, or cultural standards and customs. For example, the address 
element of an invoice looks different in Europe and in the United States. We 
would rather not have to provide an extra document schema for each local con- 
text. One way to achieve this is to define an abstract master schema. This 
schema defines the basic structure of the document but leaves the details to the 
various localized schema extensions. 
Using Substitution Groups 
An elegant way to define such a master schema and later extend it is to make 
use of substitution groups (see Section 6.2.5). Remember, a substitution group 
allows us to use the members of a substitution group in lieu of the head element 
to which each member of the substitution group refers. 
The strategy we use is to define the master schema in such a way that any 
document node where we need variability can act as the head element for a 
substitution group. We define such head elements as global elements (a require- 
ment for substitution groups), and we define them as abstract elements. This 
ensures that we cannot create document instances before we have actually sub- 
stituted all head elements with a concrete implementation. 
Here is an example for an invoice master schema (see also Figure 6.4): 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema xml ns : xs ='' http://www, w3. org/2001/XMLSchema" 
el ement FormDefaul t="qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs:el ement name:"i nvoi ce"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement ref=" abstractAddress"/> 
<xs :el ement name="i tem" maxOccurs="unbounded"> 
<xs: compl exType> 
<xs :sequence> 
<xs:element name="amount" type="xs:positivelnteger"/> 
<xs: el ement name="productNo" type="xs: string"/> 
<xs:element name="price" type="xs:decimal"/> 
</xs: sequence> 
</xs: compl exType> 
</xs:el ement> 

6.4 Usage Patterns 
201 
Figure 6.4 Master schema for country-independent invoices. 
<xs: el ement name="paymentTerms"> 
<xs: compl exType> 
<xs: sequence> 
<xs :any processContents="skip"/> 
</xs: sequence> 
</xs: compl exType> 
</xs :el ement> 
</xs: sequence> 
</xs : compl exType> 
</xs:el ement> 
<xs:element name="abstractAddress" type="xs:anyType" abstract="true"/> 
</xs: schema> 
Here, we have included the element abstractAddress as a point of variability. 
This element is defined as a global element and is referred to in the definition of 
the root element invoice. We have declared element abstractAddress as abstract. 
We have also declared the type as xs:anyType. This is the only built-in com- 
plex type in XML Schema, and it is a type from which all other complex types 
can be derived. Remember that the member of the substitution group that will 
later replace element abstractAddress must have a type that can be derived from 
the type of abstractAddress, xs:anyType gives us the most flexibility. The only 
limitation is that we cannot replace abstractAddress with an element of a simple 
type. 

202 
Chapter 6 Authoring XML Schema 
Of course, we could define head element abstractAddress with a specific com- 
plex type, if we wish to restrict the possible replacements for this element. How- 
ever, as we cannot foresee the future, we may at some time be faced with an 
address format that cannot be derived from the type of abstractAddress. For this 
reason we have chosen xs:anyType, which allows us any address format, even if 
it isan address on Mars. 
Now, let's see how we can instantiate this abstract master schema with a con- 
crete address definition (see Figure 6.5). 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs:schema xml ns :xs-"http://www.w3.org/2OO1/XMLSchema" 
el ement FormDefaul t="qual i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<xs: include schemaLocation="invoiceMaster.xsd"/> 
<xs :el ement name="UKAddress" substi tuti onGroup="abstractAddress"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="name" type="xs:string"/> 
<xs:element name="street" type="xs:string"/> 
<xs:element name="city" type="xs:string"/> 
<xs:element name="country" type="xs:string"/> 
[ UXAddr es, 
. 
,_~- 
I substcrp[ abstractAddress m " --~] 
l,n ame 
............. I 
[ type [ xs:string ] 
l -street 
.................. I 
l type I xs:string I 
I Zcity 
pcountry 
! 
I I 
i 
i 
l-p,.(,d e 
! 
1 t, e !  trin  I 
Figure 6.5 Concrete address element definition. 

6.4 Usage Patterns 
203 
<xs :el ement name="postcode" type="xs: string"/> 
</xs :sequence> 
</xs: compl exType> 
</xs :el ement> 
</xs: schema> 
Here, we have defined a complete localized invoice schema for the United 
Kingdom. First, we have included our master schema. Then we have defined a 
global element OKAddress and have declared it as a member of the substitution 
group abstractAddress. Because abstractAddress was defined with type xs:any- 
Type, we can now furnish UKAddress with any complex type definition of our 
choice. 
Based on this schema definition we can now create a document instance: 
<?xml version="1.0" encoding="UTF-8"?> 
<invoice xmlns:xsi="http://www.w3.org/2OOl/XMLSchema-instance" 
xs i : noNamespaceSchema Locat i on= "UKI nvo i ce. xsd"> 
<UKAddress> 
<name>Mary O' Donerthy</name> 
<street>107 Oxford Street</street> 
<ci ty>Cambri dge</ci ty> 
<country>United Ki ngdom</country> 
<postcode>CBl 1jR</postcode> 
</UKAddress> 
<i tern> 
<amount>2</amount> 
<productNo>471 l-3</productNo> 
<pri ce>9.95</pri ce> 
</item> 
<item> 
<amount>l</amount> 
<productNo>1278-4</productNo> 
<pri ce>5. O0</pri ce> 
</item> 
<paymentTerms><b>Pay soon ! </b></paymentTerms> 
</invoice> 

204 
Chapter 6 Authoring XML Schema 
This instance is a valid instance of schema OKInvoice.xsd. Note that we must 
use element OKAddress instead of element abstractAddress because abstract- 
Address was defined as abstract. In the same way, we could define invoice 
schemata for the United States, Germany, France, Italy, and so on, all based on 
i nvoi ceMaster.xsd. 
Substitution groups are a good way to achieve variability in a single name- 
space, but they also have drawbacks: 
-, All variable elements and their substitutions must be defined as global ele- 
ments, so it is not possible to define context-specific (local) elements here. 
[] Things get out of hand when there are several context drivers. For example, 
the address of an invoice may depend on the location, the layout of the 
items in the invoice may depend on the industry sector, and the layout of 
the payment terms may depend on the target audience (corporate, con- 
sumer). As these context drivers may appear in various combinations, the 
number of possible concrete schemata can become quite large. 
Using Type Substitution 
Another technique to allow variability in schemata is to use abstract types. 
When a particular schema instance is written, concrete types substitute for 
these abstract types. The schema supplies these concrete types in the form of a 
type library, so that instance authors may select the types they need from that 
library. The library can be defined in the same schema, or it can be defined in a 
separate file that is then included in the schema file. 
The following example illustrates this technique. Again, we have imple- 
mented an invoice schema (see Figures 6.6 and 6.7). This time all elements 
(except the root element) are defined as local elements, but they refer to 
abstract types that are defined globally. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema xml ns: xs="http://www, w3. org/2001/XMLSchema" 
e I ement FormDefau I t = "qua I i Bed" 
attri buteFormDefaul t =''unqual i Bed"> 
<xs:el ement name="i nvoi ce"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name:" address" type:"tAddress"/> 
<xs: el ement name="i tem" type="t Item" maxOccurs="unbounded ''/> 
<xs: el ement name="paymentTerms" type="tPaymentTerms"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 

6.4 Usage Patterns 
205 
address 
type'[ tAcidreSs 
item 
[ invoice [~ --- ~- 
type"["tlten~ 
| 
v 
..00 
PaymentTerms 
type ! tPaymentTerms 
Figure 6.6 A master schema for invoice using 
abstract types. 
lname 
[ 
tyPe ] xs:string,] 
s~re't 
! 
~olx~:~trin~l 
.d,, 
i 
0 UKAddress ~ 
[ iYpe i x~:~tringi 
|'c~ 
ii 
[ type I xs:string [ 
/ "p~176 
........ 1 
tElectronlcltem 
Wamount 
type [ xs:positivelnteger 
~productNo 
type [ .xs'string 
~prlce 
- type [ xsidecima, 
~'payableTil, 
] 
~tConsumerPaymentTerms 
, 
_ 
_ 
lr rdiscOunt 
[iype [ xs:decimal ~ 
tChemlcalltem 
[Wquantity 
~ '1 
l~ei ~:~d~' I 
'un', 
i 
~Pel ~s:~~ 
I 
-I m.,e~., ] 
Figure 6.7 Type library for type substitution in invoice document instances. 

206 
Chapter 6 Authoring XML Schema 
<xs:complexType name="tAddress" abstract="true"> 
<xs: compl exContent> 
<xs: rest ri ct i on base=" xs: anyType"/> 
</xs: compl exContent> 
</xs: compl exType> 
<xs :compl exType name="tltem" abstract="true"> 
<xs: compl exContent> 
<xs: restriction base="xs:anyType"/> 
</xs: compl exContent> 
</xs: compl exType> 
<xs :compl exType name="tPaymentTerms" abstract="true"> 
<xs: compl exContent> 
<xs:restriction base="xs: anyType"/> 
</xs: compl exContent> 
</xs: compl exType> 
<!-- type library for address types ---> 
<xs: compl exType name="tUKAddress"> 
<xs : compl exContent> 
<xs: restriction base="tAddress"> 
<xs :sequence> 
<xs: el ement name="name" type="xs: stri ng"/> 
<xs:element name= " street '' type="xs:string"/> 
<xs:element name="city '' type="xs:string"/> 
<xs:element name= " country '' type="xs:string"/> 
<xs :el ement name="postcode" type="xs :stri ng"/> 
</xs: sequence> 
</xs: restri cti on> 
</xs: compl exContent> 
</xs: compl exType> 
<!-- type library for item types --> 
<xs :compl exType name="tEl ectroni cltem"> 

6.4 Usage Patterns 
201 
<xs: compl exContent> 
<xs:restriction base="tltem ''> 
<xs: sequence> 
<xs:element name="amount '' type="xs:positivelnteger"/> 
<xs:element name="productNo" type="xs:string"/> 
<xs:element name="price '' type="xs:decimal"/> 
</xs: sequence> 
</xs: restri cti on> 
</xs :compl exContent> 
</xs: compl exType> 
<xs: compl exType name="tChemi cal Item"> 
<xs : compl exContent> 
<xs:restriction base="tltem"> 
<xs: sequence> 
<xs:element name="quantity" type="xs:decimal"/> 
<xs: el ement name ='' un i t" type ='' xs: NMTOKEN"/> 
<xs:element name="material "/> 
<xs:element name="pricePerUnit" type="xs:decimal"/> 
</xs: sequence> 
</xs: restri cti on> 
</xs: compl exContent> 
</xs: compl exType> 
<!-- type library for payment term types --> 
<xs: compl exType name="tConsumerPaymentTerms"> 
<xs : compl exContent> 
<xs: restri cti on base="tPaymentTerms"> 
<xs: sequence> 
<xs:element name="payableTill" type="xs:date"/> 
<xs :el ement name="di scount" type="xs:decimal "/> 
</xs: sequence> 
</xs: restri cti on> 
</xs :compl exContent> 
</xs: compl exType> 
</xs: schema> 

208 
Chapter 6 Authoring XML Schema 
Also in this case, the concrete types that substitute for the abstract types 
must have been derived from the corresponding abstract types. We see that, for 
example, tConsumerPaymentTerms was defined with a base type tPaymentTerms. It 
can, therefore, substitute for tPaymentTerms in any occurrence that specifies tPay- 
mentTerms. 
We have also defined the abstract types with the most general complex type 
(xs:anyType). This allows us maximum flexibility for the types in the respective 
type libraries. 
Applying this technique requires a bit more work on the part of document 
authors. The document author has to specify which type is used with which 
element: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<i nvoi ce xml ns :xsi="http://www.w3 .org/2OOl/XMLSchema-i nstance" 
xs i : noNames paceSchemaLoca t i on= "i nvo i ceMas ter2. xsd "> 
<address xsi :type="tUKAddress"> 
<name>Mary O' Donerthy</name> 
<street>107 Oxford Street</street> 
<ci ty>Cambri dge</ci ty> 
<country>Uni ted Ki ngdom</country> 
<postcode>CBl iJR</postcode> 
</address> 
<item xsi : type="tEl ectroni cl tem"> 
<amount>2</amount> 
<productNo>471 l-3</productNo> 
<pri ce>9.95</pri ce> 
</item> 
<item xsi :type="tChemical Item"> 
<quanti ty>12.5</quanti ty> 
<uni t>l i ter</uni t> 
<material>double destillated water</material> 
<pri cePerUni t>O. 52</pri cePerUni t> 
</item> 
<paymentTerms xsi : type="tConsumerPaymentTerms"> 
<payabl eTi I 1 >2002-05-20</payabl eTi I 1 > 
<di scount>O</di scount> 
</paymentTerms> 
</invoice> 

6.4 Usage Patterns 
209 
The concrete types for address, item, and paymentTerms elements are deter- 
mined within the document instance. This allows a wide variety of document 
flavors without the need to create a huge number of schemata. Context-specific 
(local) elements are also possible. 
Once again, this approach has a few drawbacks: 
[] It requires more effort from document authors. 
[] It cannot be used to extend a schema from the "outside." The master schema 
must define or include a library containing all valid types. 
[] It may allow the document author too much freedom. For example, a certain 
industry sector may only want items of a specific type used in an invoice, but 
document authors are free to mix item types at their discretion. For instance, 
in this example we mixed electronic items and chemical items in one in- 
voice. 
Using Dangling Type Definitions 
Our final technique is based on multiple namespaces. We use the fact that the 
definition of a schema location in the import directive is optional, and that a 
document instance may specify schema locations for namespaces used in the 
document. Note that the declaration of a schema location is only a hint to the 
XML processor about where a schema for that namespace may be found (see 
Section 6.3.5). 
In the master schema we simply avoid declaring types that we want to keep 
variable. Instead, we import the namespaces that contain these type definitions 
but don't tell the processor where to find these namespaces. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema targetNamespace="http://www, ni I e. com/bi I 1 i ng" 
xml ns: xs: "h t tp: //www. w3. o rg / 200 I/XM LSc h ema" 
xml ns: ba="http://www, ni I e. com/bi I 1 i ng/types/address" 
xml ns :bi ="http://www. ni I e. com/bi I I i ng/types/i tem" 
xml ns: bp=" http://www, ni I e. com/bi 11 i ng/types/terms" 
xml ns="http://www, ni I e. com/bi I I i ng" 
el ementFormDefaul t =''qual i fed" 
attri buteFormDefaul t=" unqual i fled"> 
<xs: import namespace="http://www, ni I e. com/bi I I i ng/types/address "/> 
<xs: import namespace="http://www, nile. com/bi I I i ng/types/i tem"/> 
<xs: import 
namespace=" http://www, ni I e. com/bi I I i ng/types/terms "/> 
<xs: el ement name:"i nvoi ce"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name ='' address" type="ba: tAddress"/> 

210 
Chapter 6 Authoring XML Schema 
<xs : el ement name="i tem" type="bi : t Item" maxOccurs="unbounded"/> 
<xs: el ement name="paymentTerms" type="bp: tPaymentTerms"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs :schema> 
This approach is called "dangling types" because the types for the elements 
address, item, and paymentTerms are not declared in the schema (see Figure 6.8). 
Instead, we have put these types into namespaces of their own, which we 
import via corresponding import statements. Because these import statements do 
not have a schemahocation attribute, it is still unclear where the type declaration 
resides. 
Three schema files containing the necessary type declarations are presented 
next. 
UKAddress.xsd 
<?xml version:"1.0" encoding="UTF-8"?> 
<xs: schema 
targetNamespace=" http://www, nile. com/bi II i ng/types/address" 
xml ns: xs=" http://www, w3. org/200 I/XMLSchema" 
xml n s = "h t tp://www, n i I e. c om/bi I 1 i ng/types/addres s" 
e I ement FormDefau I t=" qua I i fled" 
attri buteFormDefau I t="unqual i fled"> 
<xs:compl exType name="tAddress"> 
<xs: sequence> 
<xs:element name="name" type="xs:string"/> 
Figure 6.8 The master invoice schema with dangling types. 

6.4 Usage Patterns 
211 
<xs :el ement name="street" type="xs :stri ng"/> 
<xs:element name="city" type="xs:string"/> 
<xs:element name= " country '' type="xs:string"/> 
<xs :el ement name="postcode" type="xs :stri ng"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: schema> 
El ectroni cItem.xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema targetNamespace="http://www, ni I e. com/bi I I i ng/types/i tem" 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns=" http://www, nile. com/bi I I i ng/types/i tem" 
el ementFormDefaul t="qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs :compl exType name="tltem"> 
<xs :sequence> 
<xs:element name="amount" type="xs:positivelnteger"/> 
<xs: el ement name="productNo" type="xs: string"/> 
<xs:element name="price" type="xs:decimal"/> 
</xs :sequence> 
</xs: compl exType> 
</xs :schema> 
Con sumerPaymentTerms, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema 
ta rge tNames pace= "h t tp://www, n i I e. com/b i I I i ng/types / te rms" 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns-" http://www, nile. com/bi I I i ng/types/terms" 
e I ement FormDefau I t=" qua I i fled" 
a t t ri bute Fo rmDe fau I t =" unqua I i fled "> 
<xs :compl exType name="tPaymentTerms"> 
<xs: sequence> 
<xs:element name="payableTill" type="xs:date"/> 
<xs:element name="discount" type="xs:decimal"/> 
</xs: sequence> 

212 
Chapter 6 Authoring XML Schema 
</xs : compl exType> 
</xs: schema> 
We can now create a document instance. Within the document instance we 
connect the namespaces with the files that define the respective types. Other 
document instances may assign other document declaration files to the corre- 
sponding type namespaces, and so, can customize the schema. 
<?xml version="1.0" encoding="UTF-8"?> 
<invoice 
xml ns="http://www, ni I e. corn/hi I I i ng" 
xml ns: ba="http://www, ni I e. com/bi I I i ng/types/address" 
xml ns :hi ="http://www. ni I e. com/bi I I i ng/types/i tem" 
xml ns: bp:"http://www, n i I e. com/bi I I i ng/types/terms" 
xml ns :xsi =" http://www, w3. org/2001/XMLSchema-i nstance" 
xsi : schemaLocati on= 
"http://www. ni I e. com/bi I 1 i ng 
http://www, ni I e. com/bi I 1 i ng/i nvoi ceMaster3 .xsd 
http://www, ni I e. com/bi I 1 i ng/types/address 
http://www, ni I e. com/bi I 1 i ng/types/address/UKAddress, xsd 
http://www, ni I e. com/bi I 1 i ng/types/i tem 
http://www, nile. com/bi I I i ng/types/i tem/El ectroni cl tem. xsd 
http ://www. nile. com/bi I 1 i ng/types/terms 
http://www, nile. com/bi I I i ng/types/terms/ConsumerPaymentTerms, xsd" 
<address> 
<ba: name>Mary O' Donerthy</ba: name> 
<ba:street>107 Oxford Street</ba:street> 
<ba: ci ty>Cambri dge</ba: ci ty> 
<ba: country>Uni ted Ki ngdom</ba: country> 
<ba:postcode>CBl IjR</ba: postcode> 
</address> 
<item> 
<bi : amount>2</bi :amount> 
<b i : p roduc tNo>471 i- 3</b i : p roduct No> 
<bi :pri ce>9.95</bi :price> 
</item> 
<item> 
<bi : amount>l</bi :amount> 
<bi : productNo>1713-2</bi : productNo> 

6.4 Usage Patterns 
213 
<bi :pri ce>5.00</bi :price> 
</item> 
<paymentTerms> 
<bp: payabl eTi I 1 >2002-05-20</bp: payabl eTi I 1 > 
<bp: di scount>O</bp: di scount> 
</paymentTerms> 
</invoice> 
This technique does not have the drawbacks of the previous method. In par- 
ticular, it is possible to extend schemata from the "outside" simply by creating 
new type declaration files and using them in document instances. However, this 
method has a few disadvantages of its own: 
[] Documents are required to use multiple namespaces, basically one name- 
space for each variation point. When singleonamespace documents or no- 
namespace documents are required, this technique cannot be used. 
[] It is not possible to validate the master schema in isolation because the refer- 
enced types are not declared. But even if we provide type declaration files, 
schema validators may not find them as long as we don't supply schemaL0ca- 
t i on attributes. With some parsers, we even witnessed problems with docu- 
ment instance validation. (Remember, the instance specifies the locations of 
the various schemata.) 
So, the best advice is to treat this method cautiously but to keep it in mind as 
XML Schema-aware XML processors get more mature. 

This Page Intentionally Left Blank

7.1 
7.2 
7.3 
Structure 
Types, Grammars, 
Patterns 
Namespaces and 
Name Classes 
I 
t didn't take long after the XML Schema Recommendation 
was released on May 2, 2001, until a specification for an alter- 
nate schema definition language was launched. It was August 
11, and this was Relax NG. The proposal was backed by OASIS, 
one of the organizations behind the definition of the ebXML 
standard. OASIS (www.oasis-open.org) hosts some web pages 
that provide further information and tools regarding Relax NG 
[Clark2001] [Murata2001]. 
Relax NG has its roots in James Clark's TREX and in Murata 
Makoto's RELAX. For Relax NG, they got together to define a 
schema language that is of similar power to XML Schema, but 
more elegant and simpler to use. Make no mistake, I am not 
advocating that you now discard XML Schema and switch to 
Relax NG. The industry standard is XML Schema, and most 
XML tools and XML middleware support XML Schema and not 
Relax NG. 
Relax NG is discussed here to give you a deeper understand- 
ing of the subject by comparing the two standards. The discus- 
sion will be somewhat shorter than for XML Schema. Relax NG 
does not currently define its own type system, but relies on the 
XML Schema type system, discussed in Section 5.2. 
215 

216 
Chapter 7 Relax NG 
7.1 STRUCTURE 
In this section, we discuss elementary Relax NG constructs for defining the 
structure of XML documents such as elements, attributes, groups, and particles. 
7.1.1 The Relax NG Data Model 
The data model of Relax NG is based on the XML Information Set (see Section 
4.2). In Relax NG each XML document is represented by an element (the root 
element). Each element consists of 
[] A name consisting of namespace URI and the local name. An empty name- 
space URI represents the absence of any namespace. 
[] A context, consisting of a base URI and namespace map (in-scope name- 
spaces), that maps prefixes to namespace URIs and may also declare a default 
namespace. 
[] A set of attributes. Each attribute consists of a name and a string value. 
[] An ordered sequence of zero or more children. Each child is either an ele- 
ment or a non-empty string. Consecutive children are allowed, but consecu- 
tive strings are not allowed. (Two consecutive strings collapse to a single 
string.) 
7.1.2 Elements and Attributes 
The definition of elements and attributes in Relax NG is straightforward. In fact, 
the definitions of elements and attributes are so similar that they can be dis- 
cussed side by side. 
<?xml version="1.0 '' encoding="UTF-8"? > 
<grammar 
xml ns=" http://rel axng. org/ns/structure/1.0" 
datatypeLi brary=" http://www, w3. org/2001/XMLSchema-datatypes "> 
<start> 
<el ement name="track"> 
<data type= " normal izedString"/> 
<attribute name="durati on"> 
<data type="durati on"/> 
</attribute> 
</el ement> 
</start> 
</grammar> 

7.1 Structure 
217 
The attribute xml ns="http://rel axng.org/ns/structure/1.0" establishes a name- 
space for the Relax NG vocabulary. 
Here is the equivalent DTD (ignoring type declarations): 
<!ELEMENT track (#PCDATA)> 
<!ATTLIST track 
duration CDATA #REQUIRED > 
The children of an element are simply enclosed between the element tags. 
The sequence of definitions is binding for elements, but not for attributes. 
(Remember that attributes form an unordered set.) 
Both element content and attribute values are declared with <data>, which 
can include a type definition. We already mentioned that Relax NG uses the 
XML Schema type system for simple types. This is specified in the <grammar> 
clause in the datatypeLibrary attribute, so Relax NG is open to other type sys- 
tems, too. We will have a closer look at data types in Relax NG in Section 7.2.1. 
A type system content specification is <text/>, which denotes text content. 
This is equivalent to #PCDATA in DTDs and to <data type="stri ng"/>. There is also 
an abbreviation for 
<attribute name=" ID"> 
<text/> 
</attribute> 
that can be written as 
<attribute name=" ID"/> 
A similar abbreviation for elements is not possible. 
7.1.3 Model Groups and Particles 
Alternatives are enclosed in a <choice> clause; sequences are enclosed in a 
<group> clause. As we have seen, for top-level sequences (within an element def- 
inition), an explicit <group> definition is not necessary (in contrast to XML 
Schema, which would require an <xs:sequence> definition in this position). 
Here is a larger example: 
<?xml version="1.0" encoding="UTF-8"?> 
<grammar 
xml ns=" http://rel axng. org/ns/structure/i. 0" 
datatype Li brary=" http://www, w3. org/2001/XMLSchema-datatypes "> 
<start> 
<el ement name=" col I aborat i onContext"> 
<choice> 

218 
Chapter 7 RelaxNG 
<group> 
<el ement name="from"> 
<data type= " date " /> 
</element> 
<el ement name="to"> 
<data type="date"/> 
</element> 
</group> 
<group> 
<element name="l ocati on"> 
<data type= " normal izedString"/> 
</element> 
<element name="time"> 
<data type="dateTime"/> 
</element> 
</group> 
<group> 
<el ement name="time"> 
<data type="dateTime"/> 
</element> 
<element name="l ocation"> 
<data type= " normal izedString"/> 
</element> 
</group> 
</choice> 
</element> 
</start> 
</grammar> 
Here is the equivalent DTD (ignoring type declarations): 
<l ELEMENT col laborationContext 
((from, to)I 
(location, time)I (time, location))> 
<IELEMENT from (#PCDATA)> 
<!ELEMENT to (#PCDATA)> 
<!ELEMENT location (#PCDATA)> 

7.1 Structure 
219 
<!ELEMENT time (#PCDATA)> 
<!ELEMENT time (#PCDATA)> 
<!ELEMENT location (#PCDATA):, 
It is possible to define alternatives of attributes, too, but in a different way 
than in XML Schema (and DTDs): 
<el ement name=" person"> 
<choice> 
<attribute name="age"/> 
<attri bute name="bi rthDate"/> 
</choice> 
<el ement/> 
Here, both attributes are mutually exclusive, a construct not possible with 
DTDs and XML Schema. 
Interleaving 
Relax NG contains a clause that is similar to <xs :a] ]> or to the & operator in 
SGML. <interl eave> defines an interleaving of the content of its child patterns. 
In the following example, the sequence of the child elements location and time 
does not matter. 
<?xml version="1.0" encoding="UTF-8"?> 
<g ramma r 
xml ns=" http://rel axng. org/ns/structure/1.0" 
datatypeL i brary=" http://www, w3. org/2001/XMLSchema-dat atypes "> 
<start> 
<el ement name="performedAt"> 
<interleave> 
<element name="l ocati on"> 
<data type= " normal izedString"/> 
</element> 
<el ement name="time"> 
<data type="dateTime"/> 
</element> 
</interleave> 
</element> 
</start> 
</grammar> 

22(1 
Chapter 7 Relax NG 
However, <interl eave> differs somewhat from the corresponding connectors 
in SGML and XML Schema: Although (a, b) &c is equivalent to (a, b, c) I (c, b, a), 
using <interl eave> instead of & would produce all possible permutations of a, b, 
and cmthat is, <interl eave> cuts through all substructures: 
(a,b,c) I (a,c,b) I (b,a,c) I (b,c,a) I (c,b,a) I (c,a,b) 
As long as <interleave> contains only leaf items, it is equivalent to the 
<xs: al 1 > connector in XML Schema. Remember that <xs: al 1 > must not contain 
other connectors, a restriction that does not exist for <i nterl eave>. 
A common application for < 
is to interleave text between child 
elements: 
<?xml version:"1.0" encoding:"UTF-8"?> 
<grammar 
xml ns=" ht tp://re I axng. org/ns / s t ruct ure/1.0" 
datatype L i brary=" http://www, w3. org/2001/XMLSchema-datatypes "> 
<start> 
<choice> 
<element name="descri pti on"> 
<interleave> 
<text/> 
<el ement name="al bumTi tl e"> 
<text/> 
</element> 
<el ement name="performer"> 
<text/> 
</el ement> 
<el ement name="noOfTracks"> 
<data type="posi tivelnteger"/> 
</element> 
<oneOrMore> 
<el ement name:"trackNo"> 
<data type="posi tivelnteger"/> 
</el ement> 
<el ement name="trackTi tl e"> 
<text/> 
</el ement> 

7.1 Structure 
221 
</oneOrMore> 
</interleave> 
</element> 
</choice> 
</start> 
</grammar> 
(Remember that <text/> is equivalent to <text/><text/>...<text/>. In connec- 
tion with <interleave>, one occurrence of <text/> can intermingle with all child 
nodes.) 
Fortunately, there is a handy abbreviation for the same task, the connector 
<mixed>. Our example now looks like this: 
<?xml version="1.0" encoding="UTF-8"?> 
<g ramma r 
xml ns-" http://rel axng. org/ns/structure/l. 0" 
data t ypeL i b ra ry= "h ttp: //www. w3. o rg /2001/XM LSc h ema- d a ta types "> 
<start> 
<choice> 
<element name="descri pti on"> 
<mixed> 
<element name="al bumTi tl e"> 
<text/> 
</el ement> 
<el ement name="performer"> 
<text/> 
</element> 
<el ement name="noOfTracks"> 
<data type="posi ti velnteger"/> 
</element> 
<oneOrMore> 
<el ement name="trackNo"> 
<data type="posi ti velnteger"/> 
</element> 
<element name="trackTi tl e"> 
<text/> 
</element> 

222 
Chapter 7 Relax NG 
</oneOrMore> 
</mixed> 
</element> 
</choice> 
</start> 
</grammar> 
Here is the equivalent DTD (ignoring type declarations): 
<!ELEMENT description (#PCDATA I albumTitle I performer I noOfTracks I 
(trackNo, trackTi tle)+)*> 
<!ELEMENT albumTitle (#PCDATA)> 
<!ELEMENT performer (#PCDATA)> 
<!ELEMENT noOfTracks (#PCDATA)> 
<!ELEMENT trackNo (#PCDATA)> 
< ! ELEMENT trackTi t 1 e (#PCDATA) 9 
For attributes, it does not matter if we combine them with <interleave> or 
<group>. Because attributes always form an unordered set, the sequence of their 
definition does not matter. 
Cardinality Constraints 
The cardinality of model groups or single elements can be declared by embed- 
ding them into the following clauses: 
[] <zero0rMore> defines a cardinality of [0:*] and is equivalent to the modifier * 
in DTDs. 
[] <one0rMore> defines a cardinality of [1:*] and is equivalent to the modifier + 
in DTDs. 
[] <optional> defines a cardinality of [0:1] and is equivalent to the modifier ? in 
DTDs. This clause can also be used to define optional attributes: 
<optional> 
<attribute name="mi ddl eName"/> 
</optional> 
The following example defines an album with exactly one title and one or 
several tracks. 
<?xml version="1.0" encoding="UTF-8"?> 
<grammar 
xml ns:"http://rel axng. org/ns/structure/l. 0" 
datatype L i brary=" http://www, w3. org/2001/XMLSchema-dat atypes "> 

7.1 
Structure 
223 
<start> 
<element name="al bum"> 
<element name="titl e"> 
<text/> 
</element> 
<oneOrMore> 
<element name="track"> 
<text/> 
</element> 
</oneOrMore> 
</element> 
</start> 
</grammar> 
Here is the equivalent DTD: 
<!ELEMENT album (title, 
track+)> 
<!ELEMENT title 
(#PCDATA)> 
<!ELEMENT track (#PCDATA)> 
Relax NG does not support the more general cardinality constraints of XML 
Schema (see Section 5.3.4) but restricts its functionality in this area to that of 
DTDs. 
7.1.4 Empty and notAIIowed 
Empty elements are denoted by <empty/>: 
<element name = "isALivingLegend"> 
<empty/> 
</element> 
Here is the equivalent DTD: 
< ! ELEMENT i sALi vi ngLegend EMPTY> 

224 
Chapter 7 Relax NG 
In terms of regular algebra (see Section 1.6.3), the <empty/> clause is equiva- 
lent to the empty string. Concatenating it with other clauses within a group 
makes no difference. The following clause, 
<group> 
<element name = "first"/> 
<empty/> 
<element name = "last"/> 
</group> 
is equivalent to 
<group> 
<element name = "first"/> 
<element name = "last"/> 
</group> 
The notA1 lowed clause behaves similarly toward choice groups. In terms of 
relational algebra, the notAllowed clause represents the empty set: It never 
matches with anything. 
<choice> 
<element name = "age"/> 
<element name = "birthDate"/> 
<notAl I owed/> 
</choice> 
What is it good for? Usually, the notA1 lowed clause is used as a placeholder 
when we want to define abstract patterns and later merge in another pattern. 
This is discussed in detail in Section 7.2.3. 
7.1.5 Annotations 
Relax NG treats anything within a schema that does not belong to the Relax NG 
core namespace as an annotation. For example, we could use the annotation 
logic of XML Schema within Relax NG: 
<rng: e I ement name= "al bum" 
xml ns=" http://rel axng. org/ns/structure/1.0" 
xml ns: xs=" ht tp://www, w3. o rg/2001/XMLSchema"> 
<xs: annotati on> 
<xs: documentat i on> 

7.1 Structure 
225 
A web page describing a jazz album 
</xs: documentati on> 
</xs: annotati on> 
0
0
,
 
</rng:el ement> 
7.1.6 Default and Fixed Values 
Relax NG does not support default and fixed values. There are various reasons 
for this: 
s Default and fixed values modify the information set of a document instance. 
The document can have a different meaning when processed by a schema- 
aware application instead of a non-schema-aware application. 
[] Default and fixed values do not fit well into the calculus of Hedge-Regular 
Grammars (HRGs) (see Section 1.6.4). Relax NG schemata, however, are 
100% pure HRGs. 
[] Default and fixed values behave badly when merging schemata with union 
and intersection. 
Because many existing applications rely on the schema-defining default val- 
ues for instance attributes, an accompanying specification [Clark2001a] pro- 
vides the necessary compatibility with DTDs. Default values are defined via an 
annotation (see previous section). A special annotation tag defaultValue has 
been reserved to declare default values. The following DTD, 
<! ELEMENT saxophone (#PCDATA)> 
<!ATTLIST saxophone 
material (brasslplastic)"brass" 
> 
could be expressed in Relax NG as 
<el ement name="saxophone" 
xml ns=" http://rel axng. org/ns/structure/l. 0" 
xml ns: a=" http://rel axng. org/ns/compat i bi I i ty/annotati ons/l. 0" 
<optional> 
<attribute name="material" a:defaultValue="brass"> 
<choice> 
<val ue>brass</val ue> 
<val ue>pl as t i c</val ue> 
</choice> 

226 
Chapter 7 Relax NG 
</attribute> 
</optional> 
<text/> 
</el ement> 
In contrast to XML Schema, Relax NG only provides backward compatibility 
to DTDs; it does not support default values for elements. 
7.2 TYPES, GRAMMARS, PATTERNS 
In this section, we discuss how types are defined in Relax NG, and which con- 
structs are provided for reusing existing declarations. 
7.2.1. Data Types in Relax NG 
As already mentioned, Relax NG does not have a system of simple types of its 
own. Instead, it allows us to adopt foreign type systems such as the built-in 
types from XML Schema (see Section 5.2). The <data> clause is used to specify 
the type system used for each document node individually: 
<el ement name="from"> 
B 
<data type:"dateTime" datatypeLibrary= 
"http://www.w3. org/2001/XMLSchema-datatypes"/> 
</el ement> 
Each node inherits the datatypeLibrary attribute from its parent elements, so 
it is usually sufficient to specify this attribute for the root element only. An ele- 
ment containing a <data> clause must not contain child elements or <text/> 
children. However, it may contain attributes. 
If the type system features parameterized types, the <data> clause may 
include parameters. For example, when using the XML Schema data types, 
parameter clauses can specify constraining facets that derive customized types 
by restriction (see Section 5.2.7): 
<el ement name=" durat i on "> 
<data type="unsi gnedShort"> 
<param name="maxlncl usi ve">4620</param> 
</data> 
</el ement> 
Enumerations, of course, cannot be defined via parameters. Therefore, Relax 
NG allows the use of the <choice> clause for defining enumerations: 

7.2 Types, Grammars, Patterns 
227 
<el ement name="jazzMusi ci an"> 
<attribute name="ki nd"> 
<choice> 
<va I ue>i nstrumental i st</val ue> 
<val ue>j azzComposer</val ue> 
<val ue>j azzS i nger</va I ue> 
</choice> 
</attribute> 
</element> 
Here is the equivalent DTD: 
<!ELEMENT jazzMusician EMPTY> 
<!ATTLIST jazzMusician 
kind (instrumentalist I jazzComposer I jazzSinger) #REQUIRED> 
It is also possible to define lists in Relax NG. Unlike XML Schema, where a 
list extends a given simple type (see Section 5.2.6), a list in Relax NG is a con- 
struct in its own right: 
<el ement name="3dVector"> 
<list> 
<data type="float"/> 
<data type="float"/> 
<data type="float"/> 
</list> 
</element> 
Obviously, this is a more powerful construct than in XML Schema because it 
allows combining items of different types in a list, such as 
<el ement name=" currencyAmount"> 
<list> 
<data type="stri ng"/> 
<data type="decimal "/> 
</list> 
</element> 
This allows us to specify the inner structure of elements, such as 
<currencyAmount>USD 49. O0</currencyAmount> 

228 
Chapter 7 Relax NG 
A list of unlimited length of such currency amounts could be defined by 
enclosing a cardinality constraint specification. 
<el ement name=" currencyAmount"> 
<list> 
<oneOrMore> 
<data type="stri ng"/> 
<data type="decimal "/> 
</oneOrMore> 
</list> 
</element> 
A union type (see Section 5.2.10) can be defined with the help of the 
<choi ce> clause: 
<el ement name="uni tedCol or"> 
<choice> 
<list> 
<data type=" unsi gnedByte"/> 
<data type=" unsi gnedByte"/> 
<data type="unsi gnedByte"/> 
</list> 
<choice> 
<val ue>red<val ue> 
<val ue>green<val ue> 
<val ue>bl ue<val ue> 
</choice> 
</choice> 
</element> 
Here we have combined a list of three unsignedByte items (R-G-B) with an 
enumeration of color names. Actually, we could drop the second pair of 
<ch0i ce> brackets because the choice operation is associative. 
7.2.2 Grammars and Named Patterns 
As we have seen, Relax NG relies on existing type systems in the case of simple 
types, with the XML Schema type system being the prime candidate. Relax NG 
also allows us to derive new simple types from these imported types, either by 

7.2 Types, Grammars, Patterns 
229 
restriction (parameters, enumeration) or by extension (list, choice). As for com- 
plex types, we will seek in vain for such a thing in Relax NG. What we find 
instead is the construct of named patterns. 
A pattern is anything discussed so far, such as element and attribute defini- 
tions, model groups, and particles. Naming these patterns allows us to reuse 
previous patterns, and also to introduce recursions. The concept of named pat- 
terns works like this: 
<?xml version="1.0" encoding="OTF-8"?> 
<g ramma r> 
<start> 
<el ement name:"customer"> 
<el ement name="CustomerlD"> 
<text/> 
</element> 
<ref name="pName"/> 
<element name="mail ingAddress"> 
<ref name="pAddressContent"/> 
</element> 
<element name=" shi ppi ngAddress"> 
<ref name=" pAddressContent"/> 
</element> 
</element> 
</start> 
<define name="pAddressContent"> 
<element name="street"> 
<text/> 
</element> 
<el ement name="town"> 
<text/> 
</element> 
<element name="state"> 
<text/> 
</element> 
<element name="zi p"> 
<text/> 
</element> 

230 
Chapter 7 Relax NG 
</define> 
<define name="pName"> 
<el ement name="name"> 
<el ement name="first"> 
<text/> 
</el ement> 
<optional> 
<el ement name="mi ddl e"> 
<text/> 
</el ement> 
</optional> 
<element name="l ast"> 
<text/> 
</element> 
</element> 
</define> 
</grammar> 
Here is the equivalent DTD: 
<!ELEMENT customer (customerlD, name, mailingAddress, shippingAddress) > 
<! ELEMENT customerID #PCDATA > 
<! ELEMENT name (first, middle?, last) > 
<! ELEMENT first #PCDATA > 
<! ELEMENT midd|e #PCDATA > 
<! ELEMENT last #PCDATA > 
<! ELEMENT mai|ingAddress (street, town, state, zip) > 
<! ELEMENT shippingAddress (street, town, state, zip) > 
<! ELEMENT street #PCDATA > 
<! ELEMENT town #PCDATA > 
<! ELEMENT state #PCDATA 9 
<! ELEMENT zip #PCDATA 9 
The <grammar> clause encloses one or multiple <define> clauses and a single 
<start> clause. These clauses behave just like production rules in a grammar for 
a formal language (see Section 1.6) and are called patterns. The <start> clause is 
where the production of the whole grammar begins. In fact, the <start> clause 

7.2 Types, Grammars, Patterns 
231 
is a pattern itself. The <define> clauses contain the subpatterns. These subpat- 
terns are applied via <ref> clauses, here contained in the start subpattern. Such 
a ref clause can refer to any named pattern within the same <grammar> clause. 
As we can see in the example above, a pattern does not necessarily consist of 
a single element or attribute definition, but can contain multiples of these. It 
may even contain only the content of such a definition. A named pattern can 
therefore fulfill the role of global types, global elements, groups, and attribute 
groups known from XML Schema. 
As mentioned earlier, named patterns can also be used to define recursive 
structures. The following defines a treelike structure of parts and subparts: 
<?xml version="1.0" encoding="UTF-8"?> 
<g ramma r> 
<start> 
<ref name="pPart"/> 
</start> 
<define name="pPart"> 
<el ement name="part"> 
<attribute name="partlD"> 
<zeroOrMore> 
<ref name="pPart"> 
<zeroOrMore> 
</element> 
</define> 
</grammar> 
Here is the equivalent DTD: 
<!ELEMENT part (part*) > 
<!ATTLIST part 
partID CDATA #REQUIRED > 
It is also possible to nest grammars. This is useful when we need to define pat- 
terns that are local to context. A typical application is the definition of locally 
different, but identically named structures. Take for example the definition of a 
schema for a musical instrument with all its parts. The part list is defined as a 
recursive structure. Additionally, we want to have a choice if all parts are 
declared with only a partIO attribute or with a partIO attribute and a price ele- 
ment. This requires that we define two independent recursive structures with 
the same name. In a DTD we have no way of expressing such a structure. In 

232 
Chapter 7 Relax NG 
XML Schema we have to resort to group definitions. In Relax NG we use nested 
grammars: 
<?xml version="1.0" encoding="UTF-8"?> 
<grammar> 
<start > 
<ref name:"p Instrument"/> 
</start> 
<define name="plnstrument"> 
<el ement name="instrument"> 
<choice> 
<grammar> 
<start> 
<ref name="pPart"/> 
</start> 
<define name="pPart"> 
<el ement name="part ''> 
<attribute name="partlD ''> 
<zeroOrMore> 
<ref name="pPart"> 
<zeroOrMore> 
</el ement> 
</define> 
</grammar> 
<grammar> 
<start> 
<ref name="pPart"/> 
</start> 
<define name="pPart"> 
<el ement name="part"> 
<attri bute name="partlD"> 
<el ement name="pri ce"> 
<text/> 
</element> 

7.2 Types, Grammars, Patterns 
233 
<zeroOrMore> 
<ref name="pPart"> 
<zeroOrMore> 
</element> 
</define> 
</grammar> 
</choice> 
</element> 
</define> 
</grammar> 
7.2.3 External Patterns and Grammars 
External patterns and grammars can be used in Relax NG for the construction 
of multi-component schemata. In the following sections, we discuss these com- 
position techniques. 
Referencing Patterns 
We can, of course, also refer to patterns that are stored externally. If we had 
stored the grammar of the last example in file part. rng, then we could utilize it 
in the following definition: 
<el ement name="i nstrument"> 
<el ement name="col or"> 
<text/> 
</element> 
<oneOrMore> 
<external Ref href="part.rng"/> 
</oneOrMore> 
</element> 
Merging Grammars 
Similarly, we can merge external grammars into the current grammar. This is 
done with the <include> clause, a direct child of the <grammar> clause: 
<grammar> 
<include href="part.rng"/> 
o
o
o
 
</grammar> 

234 
Chapter 7 Relax NG 
Redefinition 
It is possible to override one or more named patterns when a grammar is 
included. This is done by embedding appropriate define clauses into the i nc] ude 
clause. For example: 
<grammar> 
<include href="customer, rng"> 
<define name="pName"> 
<el ement name:"name"> 
<text/> 
</element> 
</define> 
</include> 
</grammar> 
Here, we have replaced the name element of the pName pattern in the customer 
example from above with a pattern containing a simpler name element. 
Customizing Patterns 
When we merge grammars, it is not uncommon for two patterns with the same 
name to clash. For each pattern, we can control how the identically named pat- 
terns are merged with the comb i ne attribute. This attribute may have the value 
choice or interleave. For example: 
<define name="pName" combine="choice"> 
<el ement name="name"> 
<el ement name="first"> 
<text/> 
</element> 
<element name="l ast"> 
<text/> 
</element> 
</element> 
</define> 
<define name="pName" combine="choice"> 
<el ement name:"name"> 
<el ement name="first"> 
<text/> 

7.2 Types, Grammars, Patterns 
235 
</element> 
<el ement name="mi ddl e"> 
<text/> 
</element> 
<el ement name="l ast"> 
<text/> 
</element> 
</element> 
</define> 
This results in a <choice> expression for both patterns. By factoring out 
<first> and <last>, we arrive finally at 
<define name="pName"> 
<el ement name="name"> 
<el ement name="first"> 
<text/> 
</element> 
<optional> 
<element name="mi ddl e"> 
<text/> 
</element> 
</optional> 
<el ement name="l ast"> 
<text/> 
</element> 
</element> 
</define> 
In the next example we use interleave to merge two attribute groups. 
Remember that attributes always form an unordered set; the sequence of their 
definition does not matter. 
<define name="plnstrumentAttributes" combine="interleave"> 
<attribute name="col or"> 
<attribute name="wei ght"> 
</define> 
<define name="plnstrumentAttributes '' combine="interleave"> 

236 
Chapter 7 Relax NG 
<attribute name="material "> 
</define> 
This results in 
<define name="plnstrumentAttri butes"> 
<interleave> 
<attribute name="col or"> 
<attribute name="wei ght"> 
<attribute name="material "> 
</interleave> 
</define> 
Note that the interleave clause is actually redundant, as attributes always 
form an unordered set. It is actually sufficient that only one of the two patterns 
to be merged specifies a c0mbi ne mode. 
The big question, of course, is: What happens if one of two equally named 
patterns is defined with combine="choice" and the other with combine="inter- 
leave"? Not muchmthis is considered an error. 
Abstract Patterns 
In some cases, it is useful to be able to specify an empty pattern. This can be 
done with the <n0tA] ]owed/> clause introduced in Section 7.1.4: 
<define name="pattern"> 
<notAl I owed/> 
</define> 
A grammar may specify such a pattern and reference to it. However, it be- 
comes a valid pattern only if another grammar that contains equally named 
patterns is merged into the current grammar. This feature allows us to define 
generic (or incomplete) grammars that are concretized and completed by a later 
merge. 
Let's assume we want to define a generic grammar that describes an abstract 
one-to-many relationship. We could use such a grammar to describe, for exam- 
ple, the relationship between musicians and collaborations, between musicians 
and instruments, between a collaboration and albums, and so on. 
<?xml version="1.0" encoding="UTF-8"?> 
<g ramma r> 
<start> 
<ref name="pOne"/> 

7.2 Types, Grammars, Patterns 
237 
<zeroOrMore> 
<ref name="pMany"/> 
</zeroOrMore> 
</start> 
<define name="pOne"> 
<notAl I owed/> 
</define> 
<define name="pMany"> 
<notAl I owed/> 
</define> 
</grammar> 
This grammar is perfectly valid, but it has no instance documents. If we 
include the two other grammars below, which provide definitions for pone and 
pMany, we get a completed grammar, with the content of the pone and the pMany 
roles depending on the definition of the included grammar(s): 
<?xml version="l.O" encoding="UTF-8"?> 
<g ramma r> 
<define name="pOne" combine="choice"> 
<element name="mul ti Instrumental i st"> 
<el ement/> 
</define> 
</grammar> 
<g ramma r> 
<define name="pMany" combine="choice"> 
<el ement name="i nstrument"> 
<el ement/> 
</define> 
</grammar> 
And the result is 
<g ramma r> 
<start> 
<ref name="pOne"/> 

238 
Chapter 7 Relax NG 
<zeroOrMore> 
<ref name="pMany"/> 
</zeroOrMore> 
</start> 
<define name="pOne"> 
<el ement name="mul ti Instrumental i st"> 
o o o  
<element/> 
</define> 
<define name="pMany"> 
<el ement name:"instrument"> 
o o o  
<el ement/> 
</define> 
</grammar> 
This ability to define abstract patterns should not be underrated. It allows us 
to formulate generic schema prototypes that solve common problems and to 
apply this solution later to concrete problem areas by instantiating the schema 
prototype with concrete patterns. 
Section 6.4.2 discussed the design of schema families in the context of XML 
Schema. One example was the adaptation of generic business documents to spe- 
cific country or region formats. In Relax NG, a generic invoice document 
schema would specify the pattern for the shipping and billing addresses as 
<notAll0wed/>. Depending on where the schema is used, this abstract pattern 
could then be instantiated with a country-specific address pattern. 
Here is the master invoice schema equivalent to the schema given in Section 
6.4.2 but formulated in Relax NG: 
<?xml version="1.0" encoding="UTF-8"?> 
<g ramma r 
xml ns=" http://rel axng. org/ns/structure/l. 0" 
datatypeLi brary=" http://www, w3. org/2001/XMLSchema-dat atypes "> 
<start> 
<ref name="abstractAddress"/> 
<element name="i nvoi ce"> 
<ref name:"abstractAddress"/> 
<oneOrMore> 
<el ement name="item"> 

7.2 Types, Grammars, Patterns 
239 
<el ement name="amount"> 
<data type="posi ti velnteger"/> 
</element> 
<el ement name="productNo"> 
<data type="stri ng"/> 
</element> 
<element name="pri ce ''> 
<data type="decimal "/> 
</el ement> 
</element> 
</oneOrMore> 
<el ement name="paymentTerms"> 
<ref name="el ementO"/> 
</element> 
</element> 
</start> 
<define name:"any"> 
<el ement> 
<anyName/> 
<mixed> 
<zeroOrMore> 
<choice> 
<ref name= " any" /> 
<attribute> 
<anyName/> 
</attribute> 
</choice> 
</zeroOrMore> 
</mixed> 
</element> 
</define> 
<define name=" abstractAddress"> 
<notAl I owed/> 
</define> 
</grammar> 

240 
Chapter 7 Relax NG 
We see the definition of the abstract pattern abstractAddress. This is the 
anchor point for merging concrete address patterns, such as 
<?xml version="1.0" encoding="UTF-8"?> 
<grammar 
xml ns="http://rel axng. org/ns/structure/l. 0" 
datatype L i brary=" ht tp://www, w3. org/2001/XMLSchema-datatypes "> 
<start> 
<el ement name="UKAddress"> 
<el ement name:"name"> 
<text/> 
</element> 
<el ement name:"street"> 
<text/> 
</element> 
<element name="ci ty"> 
<text/> 
</element> 
<el ement name="country"> 
<text/> 
</element> 
<el ement name="postcode"> 
<text/> 
</element> 
</el ement> 
</start> 
</grammar> 
This schema illustrates another point: The pattern "any" shows how to trans- 
late an XML Schema element containing an <xs-any> definition. Relax NG does 
not provide a similar construct. Here, it is necessary to write a generic pattern 
that allows any content. This is done in pattern "any." This pattern defines a 
mixed element of any name (see Section 7.3.2) containing an unconstrained 
model group consisting recursively of either the pattern "any" or an attribute of 
any name. 
7.2.4 Keys and Key References 
Relax NG does not presently define its own concept for keys and key references. 
This is subject to a future specification. However, to provide compatibility with 

7.3 Namespaces and Name Classes 
241 
existing applications, it supports the key and key references concept of DTDs. 
Attributes defined with data type ID serve as keys, and attributes defined with 
data types IDREF and IDREFS serve as key references (see Section 4.4.4). 
7.3 NAMESPACES AND NAME CLASSES 
In this section, we discuss the use of namespaces and more classes in Relax NG. 
In contrast to XML Schema, Relax NG allows for multi-namespace schema 
definitions. 
7.3.1 Namespaces 
The treatment of namespaces in Relax NG is straightforward. They don't play a 
central role as in XML Schema, where they are used to identify the schema. 
Instead, multiple namespaces can be used within a single schema. Each element 
and attribute definition can be equipped with an individual namespace specifi- 
cation. This is done with the ns attribute: 
<element name="style" ns="http://www.jazz.org"> 
</el ement> 
It is not necessary to provide a namespace attribute for each element defini- 
tion. If no namespace attribute is specified, the namespace of an element 
defaults to the namespace of the nearest ancestor element. If no such ancestor 
exists, the namespace defaults to the empty string. It is also possible to specify 
the empty string explicitly: ns="" overrides existing namespace definitions with 
the default namespace. 
Attributes and Namespaces 
For attributes, the behavior is different. If no namespace attribute is specified for 
an attribute, its namespace defaults to the empty string. This is because of the 
fact that the XML Namespaces Recommendation [Bray1999] does not apply the 
default namespace to attributes. 
However, it is possible to force the defaulting behavior for attributes to be 
identical to that for elements. This can be achieved by specifying the name of 
the attribute as a name class (see Section 7.3.2): 
<attribute> 
<name>durati on</name> 
</attribute> 
Clauses such as <name>, <value>, and <nsName> also inherit namespace defini- 
tions from their nearest ancestor. 

242 
Chapter 7 Relax NG 
Namespace Prefixes 
An alternative syntax for declaring namespaces for elements and attributes 
makes use of namespace prefixes: 
<element name="j :jazzMusician" xmlns:j="http://www.jazz.org"> 
<attribute name:"j : ID"/> 
<el ement name="j : name"> 
<element name="j :first"> 
<text/> 
</el ement> 
</element> 
e e e  
</element> 
This syntax can be more convenient in cases when we have to deal with multi- 
ple namespaces. 
Chameleon Components 
An earlier section discussed how external patterns can be included in the cur- 
rent grammar. When doing so, it is sometimes necessary to cast the included 
pattern into a new namespace. This can easily be achieved by adding an ns 
attribute to the external Ref clause. Given the example from Section 7.2.3 this 
would look like 
<e I eme n t name =" i n s t rumen t "> 
<el ement name:"col or"> 
<text/> 
</element> 
<oneOrMore> 
<external Ref href="part, rng" ns="http://www.jazz.org"/> 
</oneOrMore> 
</element> 
This would cause the included part definition to be converted to 
<define name:"pPart" ns="http://www.jazz.org"> 
<el ement name="part"> 
<attribute> 
<n ame>pa rt I D</name> 
</attribute> 

7.3 Namespaces and Name Classes 
243 
<zeroOrMore> 
<ref name="pPart"> 
<zeroOrMore> 
</element> 
</define> 
The condition for the conversion is that the external pattern does not 
already have a namespace attribute. This is not the case here, so pattern pPart is 
assigned to the new namespace. This namespace definition would then be 
inherited by the element defined in this pattern, and also by the nested 
attribute definition because this was defined with an explicit <name> clause. 
7.3.2 Name Classes and Wildcards 
With the introduction of name classes and an algebra for name classes, Relax 
NG offers a powerful tool for the definition of generic elements and attributes, 
known as wildcards. In the examples above we have almost always defined ele- 
ments and attributes with name constants, specified in the name attribute. For 
example, the element definition 
<element name="track"> 
<attribute name="durati on"> 
<data type="durati on"/> 
</attribute> 
<text/> 
</element> 
would only match instances such as 
<track duration="PT13M56S">What Love?</track> 
where the element is called "track" and the attribute is called "duration." 
In Relax NG, however, it is possible not only to define a name constant but 
also to define a name class for an element or an attribute. In this case, all those 
instances satisfy the schema where the respective attribute or element name 
belongs to the corresponding name class. 
Generic Name Classes 
The most generic name class in Relax NG is anyName (as we saw in Section 7.2.3 
when simulating xs :any), which covers, as the name says, any attribute or ele- 
ment name regardless of its local name and its namespace URI. The definition 
<attribute> 

244 
Chapter 7 Relax NG 
<anyName/> 
</attribute> 
describes a generic attribute that can have any name. 
$coped Names 
Then there is the name class nsName, 
<el ement> 
<nsName ns="http://www.jazz.org"/> 
<text/> 
</element> 
which is satisfied by instance elements with any name belonging to namespace 
http://www.jazz.org. 
Combining Name Classes 
Name classes can be combined with <choice> and <except> clauses. For example, 
<choice> 
<nsName ns="http://www.jazz.org"/> 
<nsName ns="http://www, review.org"/> 
</choice> 
contains all names that belong to the namespaces http://www.jazz.org or 
http://www, revi ew.org. The next example, 
<anyName> 
<except> 
<nsName ns="http://www.jazz.org"/> 
</except> 
</anyName> 
contains all names except those in the namespace http://www.jazz .org. It is pos- 
sible to abbreviate this with 
<except> 
<nsName ns="http://www.j azz. org"/> 
</except> 
Individual names can also be combined with name classes: 
<choice> 
<nsName ns="http://www.jazz.org"/> 

7.3 Namespaces and Name Classes 
245 
<name>rev: source<name/> 
</choice> 
or 
<except> 
<name>rev: source<name/> 
</except> 
This allows us, for example, to define a schema for an element review that 
may contain arbitrary child elements. But when a location child element is 
specified, it must have an href attribute: 
<el ement name="revi ew"> 
<zeroOrMore> 
<el emen t> 
<except> 
<name>l ocat i on</n ame> 
</except> 
<mixed> 
<zeroOrMany> 
<attribute> 
<anyName/> 
</attribute> 
</zeroOrMany> 
</mixed> 
</text> 
</element> 
</zeroOrMore> 
<optional> 
<element name="l ocation"> 
<attribute name="href"> 
<data type="anyURI"/> 
</attribute> 
<text/> 
</element> 
</optional> 
</element> 

246 
Chapter 7 Relax NG 
First we have defined a sequence of arbitrary elements but have excluded ele- 
ments with name ]0cati on from this definition. Then we have added an extra 
optional definition for the element ]0cati0n. 
7.3.3 Comparison with DTDs 
Compared to the XML DTD, Relax NG has many advantages, but some of 
its concepts result in a few restrictions. One concept is that definitions that 
alter the information set of an XML document should not appear in a schemata 
a schema should only define the validation of documents. Consequently, Re- 
lax NG 
[] does not support the specification of default values 
[] does not support the specification of entities 
[] does not support the specification of notations 
[] does not specify whether whitespace is significant 
All these definitions would influence the information set (the content) of 
document instances. The philosophy of Relax NG is that any content should be 
defined in the document itself. This improves the capability of processors to 
interpret a document instance correctly, even if the schema is not available. 
While this is a very clean approach to schema definition, it has drawbacks in 
practical application. In many cases it is necessary to use Relax NG in combina- 
tion with another schema language, such as DTDs or XML Schema. The accom- 
panying specification RELAX NG DTD Compatibility [Clark2OOla] therefore 
provides backward compatibility for default values. 
In other areas Relax NG has significant advantages over DTDs: 
m Relax NG uses XML syntax to represent schemata. XML processors such as 
parsers, XSLT stylesheets, and so on can be used on schemata as well. 
m Relax NG supports data typing. Rather than reinvent the wheel, it supports 
foreign type systems--for example, the rich type system of XML Schema. Ru- 
mors have it that its own type system is under consideration. 
m Relax NG supports XML namespaces. 
m Relax NG does not require schemata to be deterministic. The grammar is de- 
fined in such a way that parsers don't get confused with nondeterministic 
constructs (see Section 5.3.18). 
7.3.4 Comparison with XML Schema 
Compared to XML Schema, Relax NG offers some advantages: 
m Relax NG is a very lean language. The effort to learn the basic concepts of Re- 
lax NG is considerably lower than with XML Schema. 

7.3 Namespaces and Name Classes 
24[7 
m Attributes and elements are defined in very much the same way. For in- 
stance, it is possible to define attributes that are mutually exclusive; this is 
not possible with XML Schema. 
m By providing only two constructs for reusemgrammars and patternsmthe 
concepts for schema modularization and module reuse are easier to grasp 
than in XML Schema, which, with its rich arsenal of reuse facilities, can be 
overwhelming to the beginner. 
m In Relax NG, multi-namespace schemata can be defined without the need to 
split the schema into several files. 
m Relax NG is directly based on the concept of Hedge-Regular Grammars (see 
Section 1.6.4), making it possible to exploit the properties of these grammars: 
It is easy to construct a grammar for the union, intersection, and difference 
between Relax NG-defined schemata. This makes the composition of gram- 
mars from building blocks easy and provides a good environment to facili- 
tate schema evolution (see Chapter 12). 
[] Relax NG allows for nondeterministic structures. Schema authors do not 
have to deal with this technical issue. 
[] Parser construction for Relax NG-defined grammars is simpler and parsers 
can be faster. 
Relax NG also has some disadvantages compared to XML Schema: 
[] As noted above, Relax NG intentionally does not provide support for default 
and fixed values, notations, and whitespace handling. 
[] For cross-references, Relax NG provides only backward compatibility with 
DTDs. In particular, multifield keys, typed keys, and scoped keys are not sup- 
ported. Note, however, that multifield key/keyref constructs found in XML 
Schema can make a schema undecidable [Fan2001]. Keys and key references 
are subject to future Relax NG specifications. 
[] XML Schema has been designed with relational databases in mind. It was de- 
signed as a superset of the type and structural system of SQL-99, and conse- 
quently deriving XML schemata from relational schemata and vice versa 
should be simpler with XML Schema than with Relax NG. This is an impor- 
tant aspect in enterprise applications. 
[] XML Schema is an official W3C standard and already an established industry 
standard. RELAX, the predecessor of Relax NG, is an official standard in 
Japan. 
7.3.5 Tool Support for Relax NG 
Relax NG does not currently have the same strong industry support as XML 
Schema. For example, de facto industry standards such as the Xerces DOM can 
validate document instances against schemata written in XML Schema, but not 
against Relax NG schemata. The same is true for editors. Leading schema editors 

248 
Chapter 7 Relax NG 
such as XML Spy offer support for editing and validating XML Schema visually, 
taking much pain out of the authoring process. This same level of support is 
currently not available for Relax NG. 
However, the OASIS support page for Relax NG, at http://www.oasis-open 
.org/committees/relax-ng/#resources, lists quite a few Relax NG-enabled validators, 
generators, and converters that can help during the authoring and validation 
process of XML schemata. There are validators that can validate a schema defi- 
nition, instance generators that can produce document instances from Relax 
NG schemata, and converters that can convert a DTD or XML Schema to Relax 
NG. In fact, a converter was used to produce some of the code in this chapter. 
Interesting, too, is RelaxNGCC, a tool that can generate Java source code 
from a given Relax NG grammar. Basically, this is a compiler-compiler that 
translates a grammar into a parser. 

8.1 
8.2 
8.3 
8.4 
A Knowledge Base 
Implementation in 
XML Schema 
Implementation in 
Relax NG 
Summary 
O 
ur tour through DTDs, XML Schema, and Relax NG in the 
previous chapters ends here, where we are now going to 
apply our knowledge to the construction of schemata from a 
conceptual model. 
First we take a look at the knowledge base for which we 
want to develop the schemata. We will then go through the 
various steps for implementation in XML Schema, beginning 
with design decisions and how to map business objects onto 
schemata. You will see how to create a type library and how to 
model inheritance relationships in the various schema lan- 
guages. The application of substitution groups and the imple- 
mentation of wildcards and cross-references are demonstrated. 
Then we repeat the whole process by implementing the model 
in Relax NG. The last section summarizes the implementation 
steps. 
249 

250 
Chapter 8 From Conceptual Model to Schema 
8.1 A KNOWLEDGE BASE 
The following selection of XML documents forms the jazz knowledge base. 
These documents are of course neither complete nor representative. The same 
namespace is used for these documents as in the conceptual model: http: 
//www.jazz.org/encycl opedi a. In the schemata defined in Sections 8.2 and 8.3 we 
will specify that element names must be qualified within document instances, 
and that attribute names need not be qualified. The document instances below 
define each target namespace as the default namespace. This ensures that all 
element names are qualified. 
8.1.1 Jazz Musicians 
Keith Jarrett was born May 8, 1945, and has played piano since the age of 3. He 
has produced several solo albums, only one of which is listed here, and numer- 
ous albums in collaborations (see "Collaborations," below), especially within 
the Keith Jarrett Trio. 
<?xml version="1.0" encoding:"UTF-8"?> 
<jazzMusician xmlns="http://www.jazz.org/encyclopedia" 
xml ns: xs i = "h ttp://www, w3. o rg/2001/XM LSc hema- i n stance" 
xsi : schemaLocati on="http://www, j azz. org/encycl opedi a 
. ./schemata/jazzMusi ci an .xsd" > 
< I D>J a rret tKe i th</I D> 
<name> 
<first>Kei th</first> 
<I ast>jarrett</l ast> 
</name> 
<b i rthDa te> 1945-05-08</b i rthDa te> 
<ki nd>j azzComposer</ki nd> 
<ins t rument>p i ano</i ns t rumen t> 
<produces> 
<al bum> 
<publ i sher>ht tp://www, ecmrecords, com</publ i sher> 
<prod u ct No> 1064</p rod u c t No> 
</album> 
</produces> 
</jazzMusician> 

8.1 A Knowledge Base 
251 
Gary Peacock is a bass player but plays piano and vibraphone, too. He has 
played with Paul Bley and Albert Ayler, and is a member of the Keith Jarrett 
Trio. 
<?xml version="1.0" encoding:"UTF-8"?> 
<jazzMusi ci an xml ns="http://www.j azz. org/encycl opedi a" 
xml ns :xs i =" http://www, w3. org/2001/XMLSc hema- i nstance" 
xsi : schemaLocati on:"http://www.j azz. org/encycl opedi a 
../schemata/j azzMusi ci an. xsd"> 
< I D>Pea c oc kGa ry</I D> 
<name> 
<first>Gary</first> 
<I ast>Peacock</l ast> 
</name> 
<ki nd>i nstrumental i st</ki nd> 
<instrument>double bass</i nstrument> 
<i nstrument>pi ano</i nstrument> 
<i nstrument>vi braphone</i nstrument> 
<influence> 
<i nfluencedBy> 
<j azzMusi c i an>< I D>BI eyPaul </I D></j azzMus i c i an> 
</i nfluencedBy> 
</influence> 
<influence> 
<i nfluencedBy> 
<j azzMusi ci an><l D>Ayl erAl bert</l D></j azzMusi ci an> 
</i nfluencedBy> 
</influence> 
</j azzMus i ci an> 
Born August 9, 1942, Jack DeJohnette is a jazz composer who also plays 
drums and piano. He is a member of the Keith Jarrett Trio but has also played 
with Miles Davis and others not listed here. 
<?xml version="1.0" encoding="UTF-8"?> 
<j azzMus i ci an xml ns=" http://www, jazz. org/encyc I opedi a" 
xml ns: xs i = "h ttp://www, w3. org/2001/XMLSc hema- ins tance" 
xsi : schemaLocati on=" http://www, jazz. org/encycl opedi a 
../schemata/jazzMusician.xsd" 
> 

252 
Chapter 8 From Conceptual Model to Schema 
< I D>DeJohnet t eJ ac k</I D> 
<n ame><fi rs t>j ac k</fi rs t> 
<I ast>DeJohnette</l ast> 
</name> 
<bi rthDate>1942-O8-O9</bi rthDate> 
<ki nd>j azzComposer</ki nd> 
<i nstrument>drums</i nstrument> 
<i nstrument>pi ano</i nstrument> 
<influence> 
<i nfluencedBy> 
<j azzMus i c i an>< I D>Dav i sMi I es </I D></j azzMus i c i an> 
</i nfluencedBy> 
</influence> 
</jazzMusician> 
Born July 13, 1936, saxophonist Albert Ayler was one of the most prominent 
proponents of Free Jazz. 
<?xml version="1.0" encoding="UTF-8"?> 
<j azzMus i ci an xml ns="http://www, jazz. org/encyc I opedi a" 
xml ns: xs i =" http://www, w3. org/200 i/XMLSchema- instance" 
xsi : schemaLocati on:"http://www, j azz. org/encycl opedi a 
../schemata/jazzMusician.xsd" > 
<I D>Ayl erAl bert</ID> 
<name> 
<first>Al bert</first> 
<I ast>Ayl er</l ast> 
</name> 
<bi rthDate>1936-07-13</bi rthDate> 
<ki nd>i nstrumental i st</ki nd> 
<i nstrument>saxophone</i nstrument> 
<bel ongsTo> 
<period> 
<from> 1963</from> 
<to>1970</to> 
</period> 
<style> 

8.1 A Knowledge Base 
253 
<name>freeJazz</name> 
</style> 
</bel ongsTo> 
</jazzMusician> 
8.1.2 Styles 
As an example of style, we will use Free Jazz, which was dominant from the 
early 1960s to the mid-1970s. The description element contains text in XHTML 
format. 
<?xml version="1.0 '' encoding="UTF-8"?> 
<style xmlns="http://www.jazz.org/encyclopedia" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- i nstance" 
xsi : schemaLocati on="http://www, jazz. org/encycl opedi a 
../schemata/styl e. xsd"> 
<name>freeJazz</name> 
<domi nantDuri ng> 
<from>1960</from> 
<to>1975</to> 
</domi nantDuri ng> 
<description> 
<p xmlns="http://www.w3.org/1999/xhtml">The term "free jazz" came into 
usage through the title of the groundbreaking 1960 album <quote>Free Jazz - 
A Collective Improvisation</quote> by the <em>Ornette Coleman Double 
Quartet</em>.<br/>Free jazz continued to develop in the mid-1960s primarily 
within the context of the Black Arts Movement that flourished from the mid- 
1960s to the mid-1970s and had a renaissance in the mid- to late 1990s.</p> 
</description> 
</style> 
Note the namespace definition in element <p> under <description>. The 
element description contained a wildcard specifying the namespace http://www 
.w3.org/1999/xhtml and the processing as "lax." This requires an appropriate 
namespace definition for the content of the wildcard. Since many processors 
have the XHTML namespace built in, they will check this content for validity. 
8.1.3 Collaborations 
The Keith Jarrett Trio has existed in its present form since 1983, with bassist 
Gary Peacock, drummer Jack DeJohnette, and Keith Jarrett at the piano. 

254 
Chapter 8 From Conceptual Model to Schema 
<?xml version="1.0 '' encoding="UTF-8"?> 
<band xmlns="http://www.jazz.org/encyclopedia" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- instance" 
xs i : schemaLocat i on ='' http://www, jazz. org/encycl opedi a 
../schemata/proj ect. xsd" > 
<name>Keith Jarrett Trio</name> 
<peri od> 
<from>1983</from> 
</period> 
<result> 
<al bum> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<p rod u ct No> 1780</p rod uct No> 
</album> 
</result> 
<j azzMusi ci an> 
<ID>JarrettKei th</ID> 
</jazzMusi cian> 
<jazzMusician> 
< I D>Pea c oc kGa ry</I D> 
</jazzMusi cian> 
<jazzMusi cian> 
< I D>DeJ ohnet teJ ac k</I D> 
</jazzMusi cian> 
</band> 
8.1.4 Albums 
Inside Out is a recent album of the Keith Jarrett Trio. We list the musicians with 
the instruments they play on this album. We list the five tracks, too, and finally, 
we have an MP3 sample for track 1. 
<?xml version="1.0" encoding="UTF-8"?> 
<album xmlns="http://www.jazz.org/encyclopedia" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- ins tance" 
xsi : schemaLocati on=" http://www, jazz. org/encycl opedi a 
../schemata/album.xsd" > 
<publ i sher>http://www, ecmrecords, com</publ i sher> 

8.1 A Knowledge Base 
255 
<product No> 1780</p rod uct No> 
<title>Inside out</title> 
<track trackNo="tl"> 
<title>From The Body</title> 
</track> 
<track trackNo="t2"> 
<title>Inside Out</title> 
</track> 
<track trackNo="t3"> 
<title>341 Free Fade</title> 
</track> 
<track trackNo="t4"> 
<tit I e>Ri ot</t i t I e> 
</track> 
<track trackNo="t5"> 
<title>When I Fall In Love</title> 
</track> 
<sample> 
<MP3> 
ht tp://www, jazz. org/samp I es/Ja rret tKe i th / Ins i deOut / FromTheBody 
</MP3> 
<track trackNo="tl"/> 
</sample> 
<plays> 
<i nstrument>pi ano</i nstrument> 
<jazzMusician> 
< I D>Jarrett Kei t h</I D> 
</jazzMusician> 
</plays> 
<plays> 
<instrument>double bass</i nstrument> 
<j azzMusi ci an> 
<I D>PeacockGary</ID> 
</jazzMusician> 
</plays> 

256 
Chapter 8 From Conceptual Model to Schema 
<plays> 
<i nstrument>drums</i nstrument> 
<jazzMusician> 
< ID>DeJohnetteJack</I D> 
</jazzMusi cian> 
</plays> 
</album> 
The K~ln Concert is one of Keith Jarrett's solo albums. There are four tracks. 
<?xml version="1.0 '' encoding="UTF-8"? > 
<al bum xml ns="http://www.jazz .org/encycl opedi a" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- i nstance" 
xs i : schemaLocat i on=" http://www, jazz. org/encycl opedi a 
../schemata/al bum.xsd" > 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<productNo>1064</productNo> 
<title>The Koeln Concert</title> 
<track trackNo="tl"> 
<title>Part I</title> 
</track> 
<track trackNo="t2"> 
<title>Part IIa</title> 
</track> 
<track trackNo="t3"> 
<title>Part IIb</title> 
</track> 
<track trackNo="t4"> 
<title>Part IIc</title> 
</track> 
<plays> 
<i nstrument>pi ano</i ns t rument> 
<j azzMus i ci an> 
<ID>JarrettKei th</ID> 
</jazzMusician> 
</plays> 
</album> 

8.1 A Knowledge Base 
257 
8.1.5 Reviews 
A review of the album Inside Out appeared in the jazz e-zine all about jazz, writ- 
ten by Glenn Astarita. 
<?xml version="1.0" encoding="UTF-8"?> 
<review xmlns="http://www.jazz.org/encyclopedia" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- instance" 
xsi : schemaLocati on="http://www, jazz. org/encycl opedi a 
../schemata/review.xsd" > 
< I D>r I O01_048</I D> 
<pu bDa t e>200 i- I O</pu bDa te> 
<al bum> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<product No> 1780</p rod u ct No> 
</album> 
<magazine> 
<name>all about JAZZ</name> 
<URI >http://www. a I I aboutj azz. com</URl > 
</magazine> 
<critic> 
<I D>Astari taGl enn</l D> 
</critic> 
</review> 
8.1.6 Critics 
Finally, here is the cri tic document for Glenn Astarita: 
<?xml version="1.0" encoding="UTF-8"?> 
<cri ti c xml ns="http://www.jazz, org/encycl opedi a" 
xml ns :xsi =" http://www, w3. org/2OO1/XMLSchema-i nstance" 
xsi : schemaLocati on="http://www, jazz. org/encycl opedi a 
../schemata/review.xsd" > 
<I D>Astari taGl enn</l D> 
<name> 
<first>Gl enn</first> 
<I ast>Astari ta</l ast> 
</name> 
</critic> 

258 
Chapter 8 From Conceptual Model to Schema 
8.2 IMPLEMENTATION IN XML SCHEMA 
Let's return to the conceptual model of Section 3.7 (shown again here in Fig- 
ure 8.1). This model has already been partitioned by introducing Level 2 Struc- 
tures. Also, most of the inheritance relationships were resolved. Note that this 
was done in order to allow for easy manual implementation of the model. 
A computer-based modeling tool such as KLEEN [KLEEN2002] (www.aomodeling 
.org) would not require this step but would resolve inheritance relationships 
automatically. 
8.2.1 Design Options 
One extreme in the implementation of a model would be to create one schema 
for each asset. However, with this design decision, we would run into fragmen- 
tation problems similar to relational techniques. Because the existence of some 
asset instances can depend on the presence of other asset instances, we would 
have to implement extra constraints to keep the referential integrity of the 
model intact. If, for example, we deleted a certain instance of asset jazzMusi ci an, 
we would also have to delete all instances of the assets bel0ngsT0, influence, and 
produces that depend on that instance of jazzMusician. 
The other extreme would be to create a single schema containing the whole 
model. Such an implementation, however, would not scale well. Since in- 
stances of assets may refer to each other, we would end up with a single huge 
document containing the whole knowledge base. Instances of such a schema 
can become very big, and consequently various operations (loading, saving, 
parsing, transformation, etc.) would become very slow. For example, deleting 
an instance of asset album would require reading the whole knowledge base, de- 
leting one a l bum node with its child nodes, and then writing back the whole 
model. This situation will improve when manufacturers of XML database sys- 
tems implement partial update operations for documents, so that only a partic- 
ular node is rewritten. But still it might be necessary to lock the whole 
document against concurrent updates while an update operation is in progress, 
because cross-references may point into the node being updated. 
In addition, databases are not the only technology that is affected negatively 
by huge documents. The same applies for parsers, XSLT processors, browsers, 
and so on. So, the all-in-one document approach is not a good option, even in 
terms of schema maintenance. The resulting huge schemata are difficult to 
maintain, and the reuse of schemata is virtually impossible. The rule "divide 
and conquer," or modularization, has always been an important principle in 
software engineering. 
8.2.2 Business Objects 
There is a natural way to determine the boundaries of schemata. In enterprise 
software engineering, the term "business objects" denotes units that exist in 

8.2 Implementation in XML Schema 
259 
Figure 8.1 Conceptual model of jazz knowledge base revisited. 

260 
Chapter 8 From Conceptual Model to Schema 
their own right (their existence does not depend on the presence of other units) 
and that play a role in the business process. When we determine our schema 
boundaries along such business objects, we get the following advantages: 
[] As the existence of business objects does not depend on other objects, we do 
not have to watch integrity constraints when we insert, update, or delete 
schema instances in a database. Deleting a single business object, for exam- 
ple, does not require the deletion of other business objects, as each business 
object is a first-class citizen and has a life of its own. 
[] Modifications done to a single business object do not lock the whole model. 
Concurrent update operations to other business objects remain possible. 
[] The implementation fits well with current standards in application design. 
For example, the construction of a Java access layer for such a document 
would result in an implementation of the corresponding Java business object 
class. 
[] The resulting set of schemata is very intuitive. Each schema instance (each 
XML document) represents a business object that is either a real-world object 
or a business document. 
When we look at our AOM model in Figure 4.1, we see that the Level 2 Struc- 
tures neatly correspond to business objects. Each of the units demarcated by a 
Level 2 Structure has instances that exist in their own right. Although these 
instances refer to instances of other units, they do not depend on them. In fact, 
the term "Level 2 Structure" is just a generic expression for the term "business 
object." 
Our model has the following business objects: jazzMusician, style, jam- 
Session, project, album, review, critic. This would result in a set of equally 
named schemata. 
8.2.3 Creating a Type Library 
In AOM every asset can be used as a type (see Section 2.5.5). In our model we 
have made explicit use of this feature by defining a period as asset period and 
using this type in various places. Of course, we would like to mirror this reuse 
strategy in our implementation. This is not difficult: We implement peri 0d as a 
separate complex type named peri 0d_type. In principle, we can implement each 
asset in this form, because formally each asset is a type, too. This technique 
makes the whole schema more flexible for later modifications to the schema. 
(See also Chapter 12 for schema evolution techniques.) 
We can put all these type definitions into a separate file that acts as a type 
library. The definitions in this file can be reused between the various schema 
files (jazzMusician, style, jamSession, project, album, review, critic) if we include 
this file in each via an appropriate i ncl ude statement. Let's call this type library 
Jazz Encycl opedi a_Type Lib. xsd. 

8.2 Implementation in XML Schema 
261 
Now, what does the code for peri od_type look like in XML Schema? 
<xs.comp] exType name="period_type"> 
<xs.sequence> 
<xs-element name="from '' type="xs.gYear"/> 
<xs'element name="to" type="xs.gYear" min0ccurs="0"/> 
</xs" sequence> 
</xs. comp] exType> 
This is a very simple schema part that defines a complex type consisting of a 
sequence of two elements (see Figure 8.2). Note that this is not the only way 
such a type could be implemented. Alternatively, we could have implemented 
the elements from and to as attributes, depending on our personal preferences. 
In the context of this example, however, we will stay with elements. The reason 
for doing so is simply that attributes would not show up in the XML Spy dia- 
grams. A synopsis of the never-ending attribute vs. element debate is found in 
[Daum2002]. 
Of course, we could also implement peri od_type as a global group: 
<xs'group name="period_type"> 
<xs- sequence> 
<xs'element name= " from" type="xs'gYear"/> 
<xs-element name="to" type="xs-gYear" minOccurs="O"/> 
</xs 9 
sequence> 
</xs .group> 
However, we find that the tag name compl exType quite satisfactorily describes 
what we want to define: the type of a node. Also, should we opt to implement 
some properties as attributes, complexType has the advantage of allowing the 
application of both elements and attributes within the same c0mpl exType defini- 
tion. This is not possible with the group clause. 
So, we use comp] exType for the definition of the other types, too. But before 
we can continue to create the code for the other assets in the model, we need to 
look at some finer points of inheritance. 
period_type [~ 
, 
, 
to 
I 
I 
I 
. 
! 
', type | xs:gYear , 
II . . . .  
I 
I 
Figure 8.2 The structure of 
complex type period_type. 

262 
Chapter 8 From Conceptual Model to Schema 
8.2.4 
Handling 
Inheritance 
Life would be too easy if we could continue in such a straightforward way as 
above. Implementing i s_a relationships is a bit trickier. In our example we have 
two i s_a relationships: one leading from jazzMusi ci an to person, the other lead- 
ing from cri tic to person. 
Let's discuss XML Schema first. Implementing a person_type and inheriting 
from it into jazzMusi ci an_type is straightforward. We simply use person_type as a 
base type of jazzMusician_type and extend it by appending the additional ele- 
ments. This is depicted in Figures 8.3 and 8.4. 
Here is the code for person_type: 
<xs'compl exType name="person_type"> 
<xs: sequence> 
<xs. el ement name=" ID" type="xs. NMTOKEN"/> 
<xs 9 
el ement name="name"> 
<xs. compl exType> 
<xs 9 
sequence> 
<xs- el ement name="first" type="xs 9 
token" 
maxOccu rs =" unbounded "/> 
<xs.element name="middle" type="xs.token '' minOccurs="O"/> 
<xs'element name="last" type="xs'token"/> 
</xs 9 
sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs:element name="birthDate" type="xs:date" minOccurs="O"/> 
</xs -sequence> 
</xs: compl exType> 
Here is the code for jazzMusi cian_type derived from person_type: 
<xs'compl exType name="jazzMusi ci an_type"> 
<xs" compl exContent> 
<xs. extensi on base="person_type"> 
<xs: sequence> 
<xs: el ement name-"ki rid"> 
<xs: simpl eType> 
<xs: restri ction base-"xs: string"> 
<xs: enumerat i on va 1 ue-" i nstrumenta 1 i st"/> 

8.2 Implementation in XML Schema 
263 
Figure 8.3 The complex type person_type. 
Figure 8.4 The complex type jazzMusician_type derived from person_type 
by extension. 

264 
Chapter 8 From Conceptual Model to Schema 
<xs: enumerat i on val ue="j azzComposer"/> 
<xs: enumerat i on val ue="j azzSi nger"/> 
</xs: restri ct i on> 
</xs: simpl eType> 
</xs:element> 
<xs: element name="instrument" type="xs: token" 
mi nOccurs="O" maxOccurs="unbounded"/> 
</xs: sequence> 
</xs:extension> 
</xs: compl exContent> 
</xs: compl exType> 
This has worked quite well, but this is only the simplest case of inheritance: 
No properties are overridden, and we don't have to deal with multiple in- 
heritance. Things don't look so simple for the relationship between critic and 
person. Here, the subproperty first is overridden, because critic uses this sub- 
property with a different cardinality constraint. However, we are lucky. Since 
cri t i c is a subtype of person (the narrower cardinality constraint for subprop- 
erty first diminishes the set of possible instances), we can derive this type by 
restriction (see Figure 8.5): 
<xs- compl exType name=" cri t i c_type"> 
<xs 9 
compl exContent> 
Figure 8.5 The complex type cri t i c_type derived from person_type by restriction. 

8.2 Implementation in XML Schema 
265 
<xs: restri ct i on base="person_type"> 
<xs" sequence> 
<xs'element name="ID" type="xs.NMTOKEN"/> 
<xs'el ement name="name"> 
<xs 9 
complexType> 
<xs 9 
sequence> 
<xs: el ement name="flrst" type="xs: token"/> 
<xs.element name="middle" type="xs'token" 
mi nOccurs="O"/> 
<xs-element name="last" type="xs'token"/> 
</xs 9 
sequence> 
</xs- compl exType> 
</xs "el ement> 
<xs'element name="birthDate" type="xs'date '' minOccurs="O"/> 
</xs. sequence> 
</xs. restri cti on> 
</xs- compl exContent> 
</xs 9 
compl exType> 
Unfortunately, if properties are overridden in such a way that the new type is 
not a subtype of the inherited type (for example, if we want to allow multiple 
birth dates), we are out of luck. In these cases we can resolve the inheritance by 
the AOM inheritance rules (see Section 3.6), and then translate the resolved 
assets into a schema. But many inheritance relationships can be mapped to 
XML Schema, as we can always use combinations of type restriction and type 
extension. 
8.2.5 The Complete Type Library 
The creation of type definitions for the other assets is straightforward. Because 
we have already defined period_type, we can utilize this type in the definitions 
of bel0ngsT0_type, pr0ject_type, and style_type. The implementation of these 
types is straightforward. We define each property and subproperty as a local ele- 
ment. This way, we do not run into name conflicts when the same property 
names should be used in different assets for different property types. 
What is a bit out of the ordinary is the implementation of the property ki nd 
in asset jazzMusician. This property was defined as an enumeration with no spe- 
cific type, so we will select the most general type for this element: xs.string. 
This built-in type will allow all enumeration values. 

2(Wi 
Chapter 8 From Conceptual Model to Schema 
www_j az z_org_encyc 1 oped i a_TYPE LIB. xsd 
This file implements all asset types used in our model. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema targetNamespace=" http'//www, j azz. org/encycl opedi a" 
xml ns=" http'//www, j azz. org/encyc I opedi a" 
xml ns" xhtml =" http 9 
w3. org/1999/xhtml" 
xml ns: xs=" http 9 
w3. org/2001/XMLSchema" 
el ementFormDefaul t =''qual i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<!--Asset type perso--> 
<xs" compl exType name="person_type"> 
<xs" sequence> 
<xs- el ement name=" ID" type="xs 9 
NMTOKEN"/> 
<xs 9 
el ement name="name"> 
<xs 9 
compl exType> 
<xs "sequence> 
<xs.element name="first" type="xs.token '' 
maxOccurs=" unbounded"/> 
<xs.element name="middle" type="xs.token" minOccurs="O"/> 
<xs" el ement name="l ast" type="xs 9 
token"/> 
</xs. sequence> 
</xs. compl exType> 
</xs -el ement> 
<xs.element name="birthDate" type="xs'date" minOccurs="O"/> 
</xs 9 
sequence> 
</xs. compl exType> 
<!--Asset type period--> 
<xs" comp I exType name= "peri od_type"> 
<xs. sequence> 
<xs'element name= " from" type="xs-gYear"/> 
<xs.element name="to '' type="xs.gYear '' minOccurs="O"/> 
</xs 9 
sequence> 
</xs. compl exType> 
<!--Asset type jazzMusician--> 
<xs" compl exType name="jazzMus i ci an_type"> 

8.2 Implementation in XML Schema 
267 
<xs" compl exContent> 
<xs" extensi on base="person_type"> 
<xs "sequence> 
<xs'el ement name="ki nd"> 
<xs 9 
simpl eType> 
<xs'restriction base="xs 9 
string"> 
<xs'enumeration value="instrumental ist"/> 
<xs" enumerat i on val ue="j azzComposer"/> 
<xs .enumerati on val ue="j azzSi nger"/> 
</xs" restri cti on> 
</xs 9 
simpl eType> 
</xs "el ement> 
<xs'element name="instrument" type="xs-token" 
mi nOccurs-"O" maxOccurs="unbounded"/> 
</xs 9 
sequence> 
</xs "extension> 
</xs" compl exContent> 
</xs" compl exType> 
<!--Asset type belongsTo--> 
<xs'compl exType name="belongsTo_type"> 
<xs'sequence> 
<xs.element name="period" type="period_type"/> 
</xs 9 
sequence> 
</xs" compl exType> 
<!--Asset type influence--> 
<xs'compl exType name="influence_type"/> 
<i--Asset type produces--> 
<xs" compl exType name="produces_type"/> 
<!--Asset type jamSession--> 
<xs" compl exType name="jamSession_type"> 
<xs "sequence> 
<xs'element name="time" type="xs'dateTime"/> 
<xs'element name="location" type="xs.token"/> 
</xs 9 
sequence> 
</xs. compl exType> 

2~ 
Chapter 8 From Conceptual Model to Schema 
<!--Asset type project--> 
<xs" compl exType name="project_type"> 
<xs. sequence> 
<xs "el ement name="name" type="xs'token"/> 
<xs .el ement name="peri od" type="peri od_type"/> 
</xs 9 
sequence> 
</xs" compl exType> 
<!--Asset type style--> 
<xs'compl exType name="style_type"> 
<xs 9 
sequence> 
<xs'element name="name" type="xs'token"/> 
<xs" el ement name=" domi nantDuri ng"> 
<xs 9 
compl exType> 
<xs .sequence> 
<xs.element name="period" type="period_type"/> 
</xs "sequence> 
</xs. compl exType> 
</xs-el ement> 
</xs "sequence> 
</xs- compl exType> 
<!--Asset type description--> 
<xs-compl exType name="description_type"> 
<xs: sequence> 
<xs:any namespace-"http://wv~v.w3.org/lggg/xhtml" 
proces sContent s-" 1 ax"/> 
</xs: sequence> 
</xs" compl exType> 
<!--Asset type critic--> 
<xs" comp I exType name="cri t i c_type"> 
<xs" compl exContent> 
<xs" restri cti on base="person_type"> 
<xs" sequence> 
<xs-element name="ID" type="xs-NMTOKEN"/> 
<xs 9 
el ement name="name"> 
<xs 9 
compl exType> 

8.2 Implementation in XML Schema 
269 
<xs" sequence> 
<xs'element name="first" type="xs'token"/> 
<xs'element name="middle" type="xs'token '' 
mi nOccurs="O"/> 
<xs.element name="last" type="xs'token"/> 
</xs 9 
sequence> 
</xs" compl exType> 
</xs 9 
el ement> 
<xs.element name="birthDate" type="xs.date '' minOccurs="O"/> 
</xs 9 
sequence> 
</xs" restri cti on> 
</xs" compl exContent> 
</xs- compl exType> 
<!--Asset type album--> 
<xs" compl exType name="al bum_type"> 
<xs" sequence> 
<xs'element name="publ i sher" type="xs'anyURl"/> 
<xs'element name="productNo '' type="xs'NMTOKEN"/> 
<xs.element name="title '' type="xs'string"/> 
</xs 9 
sequence> 
</xs "compl exType> 
<!--Asset type track--> 
<xs" compl exType name="track..type"> 
<xs -sequence> 
<xs.element name="title" type="xs'string"/> 
<xs'element name="duration" type="xs'duration '' minOccurs="O"/> 
</xs 9 
sequence> 
<xs: attri bute name="trackNo" type="xs: ID"/> 
</xs" compl exType> 
<!--Asset type sample--> 
<xs'compl exType name="sampl e_type"> 
<xs. sequence> 
<xs'element name="MP3 '' type="xs'anyURl"/> 
</xs 9 
sequence> 
</xs 9 
compl exType> 

210 
Chapter 8 From Conceptual Model to Schema 
<!--Asset type plays--> 
<xs. compl exType name="pl ays_type"> 
<xs" sequence> 
<xs.element name="instrument '' type="xs.token '' 
maxOccurs="unbounded ''/> 
</xs. sequence> 
</xs. compl exType> 
<!--Asset type review--> 
<xs'compl exType name="review_type"> 
<xs" sequence> 
<xs.element name="ID" type="xs.NMTOKEN"/> 
<xs.element name="pubDate" type="xs.gYearMonth"/> 
</xs 9 
sequence> 
</xs" compl exType> 
<!--Asset type magazine--> 
<xs" compl exType name="magazi he_type"> 
<xs 9 
sequence> 
<xs.element name="name" type="xs'string"/> 
<xs.element name="URI" type="xs .anyURI''/> 
</xs :sequence> 
</xs" compl exType> 
</xs: schema> 
The highlighted piece of code in the definition of description_type shows 
some detail that we have added to asset descri pti on. Remember that we left the 
definition of asset description unfinished in Section 3.7 because we wanted to 
add some detail later. We have now decided to leave that task (of adding detail) 
to the W3C's XHTML Working Group, and to simply create a wildcard. 
We have set processContents to "lax" (see Section 5.3.15) for this wildcard 
and have declared the namespace as "http.//www.w3.org/1999/xhtml ". This will 
cause processors to check the element for valid content if an XHTML schema 
definition is available and accessible, but to accept the element as valid if such a 
schema definition is not available or accessible. The namespace attribute reflects 
the XHTML namespace URI. 
In the definition of track_type, we have made an exception and imple- 
mented trackNo as an attribute of type ID. This is to provide backward compati- 
bility with DTDs--trackN0 is used as a key for cross-references. This backward 
compatibility costs something: The preferred choice would be to implement 
trackNo as an unsignedByte attribute or element to allow numeric key values. 
Now, with type ID in place, all key values must start with a letter. 

8.2 Implementation in XML Schema 
271 
8.2.6 Implementing a Business Object 
So far, we have only created complex types that perfectly describe the structure 
of each asset and have not bothered with the connecting arcs between the 
assets. This is what we want to do now. Each L2S contains a tree of assets, with 
the identifying asset in the top position. Remember that we chose the L2S in 
such a way that they represent business objects of our business scenario (see 
Section 3.7). 
Let's begin with L2S jazzMusi cian. The identifying item here is asset jazzMusi- 
cian. We implement this asset as the root element of the jazzMusician docu- 
ment. The type assigned to this element is derived from type jazzMusician_type 
by extension. The extension consists of the other assets in this L2S (belongsT0, 
influence, and produces) that are implemented as child elements of jazzMusician. 
We use an i ncl ude statement to access the type definitions in our previously 
defined type library. For a flexible schema layout, we implement each asset as a 
global element (which is always possible since asset names are unique within 
a model), and refer to these definitions as needed. Figure 8.6 (page 272) shows a 
diagram of the finished schema. 
jazzMusi cian.xsd 
This file implements the L2S jazzMusician with all outgoing arcs. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema targetNamespace="http 9 
j azz. org/encyc I opedi a" 
xml ns" xs=" http'//www, w3. org/2001/XMLSchema" 
xml ns=" http 9 
j azz. org/encyc I opedi a" 
xml ns" xsg=" http 9 
aomodel i ng. org/KLEEN/XSDgenerator" 
e I ement FormDefau I t = "qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs" i nc I ude schemaLocat i on="www_j azz_org_encyc Ioped i a_TYPEL I B. xsd"/> 
<!--Asset jazzMusi cian--> 
<xs" el ement name="j azzMus i ci an"> 
<xs 9 
compl exType> 
<xs" compl exContent> 
<xs" extens i on base="j azzMus i c i an_type"> 
<xs.sequence> 
<xs: element ref:"produces" 
minOccurs:"O" maxOccurs="unbounded"/> 
<xs: el ement ref="bel ongsTo" 
II 
II 
minOccurs="O" maxOccurs= unbounded /> 
<xs: el ement ref="i nfluence" 
II 
II 
minOccurs="O" maxOccurs= unbounded /> 

272 
Chapter 8 From Conceptual Model to Schema 
Figure 8.6 The finished schema for business object jazzMusician. 

8.2 Implementation in XML Schema 
273 
</xs 9 
sequence> 
</xs "extension> 
</xs. compl exContent> 
</xs. compl exType> 
<xs: key name="pkjazzMusi ci an_ID"> 
<xs: selector xpath:" ."/> 
<xs:field xpath="ID"/> 
</xs:key> 
</xs'el ement> 
<!--Asset produces--> 
<xs.el ement name="produces"> 
<xs 9 
compl exType> 
<xs. compl exContent> 
<xs'extensi on base="produces_type"> 
<xs. sequence> 
<xs :el ement name="album" mi nOccurs="O" maxOccurs="unbounded"> 
<xs:annotation> 
<xs: documentat i on> 
refers to key pk__album_albumKey i n schema album, xsd 
</xs: documentat i on> 
<xs:appinfo> 
<xsg: refersToSchema 
xml ns: xl i nk="http: //www. w3. org/1999/xi i nk" 
xl ink- href="al bum. xsd" 
x] ink'type="simp| e" 
keyName=" pkal bum_al bumKey"/> 
</xs:appinfo> 
</xs: annotat i on> 
<xs: compl exType> 
<xs:a11> 
<xs: el ement name="publ i sher" type="xs: anyURI"/> 
<xs: element name="productNo" type="xs: NMTOKEN"/> 
</xs:all> 
</xs: compl exType> 
</xs :element> 

274 
Chapter 8 From Conceptual Model to Schema 
</xs "sequence> 
</xs "extension> 
</xs" compl exContent> 
</xs: compl exType> 
</xs" el ement> 
<!--Asset bel ongsTo--> 
<xs :el ement name="bel ongsTo"> 
<xs" compl exType> 
<xs. compl exContent> 
<xs" ext ens i on base=" bel ongsTo_type"> 
<xs" sequence> 
<xs :el ement name="styl e" maxOccurs="unbounded"> 
<xs: annotat i on> 
<xs: documentat i on> 
refers to key pk_,style_name in schema style.xsd 
</xs: documentat i on> 
<xs: appi nfo> 
<xsg: refersToSchema 
xl ink: href="style, xsd" 
xl ink: type="simple" 
xml ns: x 1 i n k=" http: //~n~r w3. org/1999/x 1 ink" 
k eyN ame = "p k__ s t y 1 e_n ame" / 9 
</xs:appinfo> 
</xs: annotat i on> 
<xs: comp] exType> 
<xs:all> 
<xs: el ement name="name" type="xs: token"/> 
</xs:all> 
</xs: compl exType> 
</xs: e| ement> 
</xs. sequence> 
</xs.extension> 
</xs" compl exContent> 
</xs" compl exType> 
</xs : el ement> 
<!--Asset influence--> 

8.2 Implementation in XML Schema 
27S 
<xs" el ement name="i nfluence"> 
<xs" compl exType> 
<xs" compl exContent> 
<xs. extensi on base="i nfluence_type"> 
<xs" sequence> 
<xs: el ement maxOccurs="unbounded" mi nOccurs="O" 
name="i nfluencedBy"> 
<xs: annotat i on> 
<xs: documentat i on> 
refers to key pkjazzMusician_ID in schema jazzMusician.xsd 
</xs :documentation> 
<xs:appinfo> 
<xsg:refersToSchema xl ink:href="jazzMusician.xsd" 
xl ink: type=" s imp1 e" 
xml ns: xl ink=" http: //www. w3. org/1999/xl ink" 
keyName=" pkj azzMus i c i an_I D"/> 
</xs:appinfo> 
</xs: annotat i on> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name-"j azzMus i ci an"> 
<xs: compl exType> 
<xs:a11> 
<xs: el ement name-" ID" type="xs: NHTOKEN"/> 
</xs:a11> 
</xs: compl exType> 
</xs :element> 
</xs: sequence> 
</xs: compl exType> 
</xs:element> 
</xs :sequence> 
</xs :extension> 
</xs: compl exContent> 
</xs: compl exType> 
</xs: el ement> 
</xs: schema> 

276 
Chapter 8 From Conceptual Model to Schema 
The first highlighted group represents the arcs to the assets belongsTo, influ- 
ence, and produces. They are simply implemented as references to the global ele- 
ments implementing these assets. 
The next highlighted group sets up a key for the element jazzMusician. This 
is based on the key definition in the model. We select the only key field "ID" 
and compose a key name from the asset name and the key definition. The pre- 
fix pk identifies this key as a primary key (not that the key is really needed in 
this schema). Keys defined in XML Schema (or for that matter in a DTD or in 
Relax NG) are used to index elements with multiple occurrences within a docu- 
ment instance for cross-referencing. This is not the case for element jazz- 
Musician. Within one document instance, we have exactly one root element 
jazzMusician, and it is not a target for cross-referencing. However, we keep this 
key definition as a schema representation of the original AOM key definition. 
What follows is the code for the asset produces. This asset does not have prop- 
erties, but it has an arc into another business object (to asset album). How do we 
implement such an arc? That depends primarily on how we want to process the 
documents later. In an instance document, we could, for example, represent 
such an arc with an XLink clause pointing to the referenced a l bum document. 
Here, we have taken a relational approach and have created a foreign key repre- 
sented by the element album. This element contains as its only elements the key 
fields of asset album. We used the connector xs.all to group the key fields 
together because the sequence of key fields does not matter. Document in- 
stances could contain values for pub l i sher and productNo and thus refer to a con- 
crete album instance. 
Combining the corresponding instances of jazzMusicians and album would 
require a query language such as XQuery. Such a query language could evaluate 
the data in the foreign key fields in jazzMusician/belongsTo/al bum and in the pri- 
mary key fields of an a l bum instance, and could then join both documents. To 
make this connection visible to human and machine readers of the schema, it is 
documented in an annotation. The documentation clause is for human readers; 
the appinf0 clause is for applications. 
The same technique is used when implementing asset bel0ngsT0. Here, we 
have created a foreign key element representing the asset style. This element 
contains as its only child element the key field name. 
Again, the same logic is used to implement asset influence. Remember that 
the arrow with the role name i nfluencedBy was declared with range constraint 
>jazzMusician. Thus, it can point to other instances of the jazzMusician schema. 
So, we don't implement this arc as an instance-internal cross-reference but in 
the same manner as the other arcs leading out of the Level 2 Structure j azzMusi- 
ci an. Note, too, that the element influence does not directly contain the element 
jazzMusici an as a child. We have wrapped element influencedBy around jazzMusi- 
ci an to carry the role name of this arc into the schema. 

8.2 Implementation in XML Schema 
277 
We have added the attributes mi nOccurs="O" and maxOccurs="unb0unded" to the 
definition of element i nfluencedBy to reflect the unconstrained cardinality of this 
arc. Of course, we could have used a different method to implement this arc. 
We could have used data type NMTOKENS instead of NMTOKEN for the key field. This 
would allow us to get rid of the maxOccurs="unbounded" attribute. In case of mul- 
tiple arc targets, the document instance would need only a single i nfluencedBy 
element because multiple key values can be coded into the NMTOKENS key field. 
However, this technique is only possible with key data types that do not allow 
whitespace (such as NMTOKEN, ID, numbers, etc.) and when the key consists of 
a single field. 
The next section discusses how to implement cross-reference arcs that are 
local to an instance. 
8.2.7 Dealing with Cross-References 
With the implementation of business object album, we arrive at a new problem: 
album does not have a hierarchical structure. True, both assets track and sample 
can be implemented as child elements of a root element a l bum, but there is a 
cross-reference between track and sample. Please note that this arc does not have 
a range specification, so the arc is local to the instances of schema albummit 
always points from an album track to a sample of the same album. 
This is a typical case for applying a cross-reference construct consisting of a 
key clause and a keyref clause. With the key clause, we define a primary key for 
each trackma primary key scoped to one instance document of schema album. 
The way to implement this in XML Schema is to introduce a key clause at the 
origin of the arc representing the cross-reference. This clause defines a local pri- 
mary key for the tracks of an a l bum document. It must be defined within the 
scope of the a l bum element (the root element) because it must be accessible to 
other child elements (such as sampl e) of a l bum. 
Notice how the key "pk track_trackNo" is defined in the schema below. The 
key selector is set to "./track" in order to select the track child elements for this 
key. The field clause specifies the single key field. 
In the definition for element sampl e, the code that implements the arc lead- 
ing from sample to track is highlighted. This is the same technique we used 
above for arcs that cross the boundaries of business objects. What is different 
is that we have also created a keyref definition named "fk 
sample_track". This 
keyref definition establishes a foreign key, and it refers to our primary key 
"pk track 
trackN0". The selector clause specifies the element album/sample 
/track, which implements the arc. We were able to use the relative path nota- 
tion ./track because this keyref definition is defined in the scope of element 
album/sample. Note that we have implemented the foreign key field trackNo as an 
attribute in order to provide backward compatibility with DTDs. 

278 
Chapter 8 From Conceptual Model to Schema 
album.xsd 
This file implements the L2S album with all outgoing arcs. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs'schema attri buteFormDefaul t="unqual ified" 
el ement FormDefau I t= "qua I i fled" 
targetNamespace:" http'//www, jazz. org/encyc I opedi a" 
xml ns=" http://www, j azz. org/encycl opedi a" 
xml ns 9 
xs=" http://www, w3. org/2001/XMLSchema" 
xml ns: xsg = "h t tp'//www, aomode I i ng. o rg/KLEEN/XSDgenera to r"> 
<xs: i nc I ude schemaLocat i on="www_j azz_org_encycl opedi a_TYPELI B. xsd"/> 
<! --Asset al bum--> 
<xs:el ement name="al bum"> 
<xs" compl exType> 
<xs. compl exContent> 
<xs'extension base="al bum_type"> 
<xs: sequence> 
<xs'element maxOccurs="unbounded" ref="track"/> 
<xs:el ement maxOccurs="unbounded" mi nOccurs="O" ref="sampl e"/> 
<xs'element maxOccurs:"unbounded" minOccurs:"O" ref:"plays"/> 
</xs: sequence> 
</xs "extension> 
</xs: compl exContent> 
</xs: compl exType> 
<xs: key name="pkmal bum_al bumKey"> 
<xs:selector xpath=". "/> 
<xs:field xpath="publ isher"/> 
<xs:field xpath="productNo"/> 
</xs" key> 
<xs: key name="pk tracktrackNo"> 
<xs: sel ector xpath="./track"/> 
II 
'1 
<xs:field xpath= @trackNo /> 
</xs: key> 
</xs : el ement> 
<!--Asset track--> 
<xs: el ement name="track" type="track_type"/> 

8.2 Implementation in XML Schema 
279 
<!--Asset sample--> 
<xs-el ement name="sampl e ''> 
<xs 9 
compl exType> 
<xs- compl exContent> 
<xs.extension base=" sampl e_type"> 
<xs. sequence> 
<xs: el ement name:"track"> 
<xs: compl exType> 
<xs: attri bute name="trackNo" type="xs: IDREF"/> 
</xs: comp 1 exType> 
</xs :element> 
</xs" sequence> 
</xs .extension> 
</xs. compl exContent> 
</xs" compl exType> 
<xs: keyref name:"fk__sample_track" refer="pk__tracktrackNo"> 
<xs:selector xpath="./track"/> 
<xs :field xpath="@trackNo"/> 
</xs: keyref> 
</xs'el ement> 
<!--Asset plays--> 
<xs'el ement name="pl ays"> 
<xs 9 
compl exType> 
<xs. compl exContent> 
<xs-extension base="pl ays_type"> 
<xs. sequence> 
<xs. el ement name=" j azzMus i c i an"> 
<xs'annotation> 
<xs" documentat i on> 
refers to key pkmjazzMusician_ID in schema jazzMusician.xsd 
</xs" documentati on> 
<xs'appinfo> 
<xsg- refersToSchema x l ink" href="j azzMus i ci an. xsd" 
xl i nk'type="simpl e" 
xml ns" x l ink=" http 9 
w3. org/1999/xi ink" 
keyName = "pk 
j azzMu s i c i an_l D"/> 

280 
Chapter 8 From Conceptual Model to Schema 
</xs :appi nfo> 
</xs: annotati on> 
<xs: compl exType> 
<xs:all> 
<xs :el ement name=" ID" type="xs :NMTOKEN"/> 
</xs:all> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs :extension> 
</xs: compl exContent> 
</xs: compl exType> 
</xs: el ement> 
</xs: schema> 
The element plays has an arc leading to business object jazzMusician. This 
is implemented in the usual way, as already explained in the previous section. 
Figure 8.7 illustrates the structure of business object album. 
8.2.8 Using Substitution Groups 
Now we define the two business objects that have been modeled as a single 
asset: project and band. This was expressed by decorating the asset project with 
two display labels: project and band. Consequently, we also create only one 
schema for them. 
We implement this construct by first creating a complex type definition for 
asset project. We call this type project_asset. Next we define an element named 
project with the type project_asset. In this element we can include code for the 
key definitions made in asset project. Now we have two options to create an 
element band: 
[] We create it as a member of a substitution group. This is the preferred option 
because this way we do not have to replicate the key definition but can in- 
herit it from the head element of the substitution group. This option was 
chosen in the code below: Element band refers to substitution group project. 
[] Another option would be to create the element band as a normal element of 
type pr0ject_asset. This would be necessary if we wanted to create this ele- 
ment as a local element because substitution groups can only be used on a 
global level. 
Of course, we also could have created project asset as an element and could 
m 
have used it as the head of a substitution group. In this case we would need to 

8.2 Implementation in XML Schema 
281 
Figure 8.7 The structure of business object album. The identity constraints 
(key/keyref) are not visible in this diagram. 
declare this element as abstract because the model does not allow instances of 
name project_asset. Because we experienced some problems with validators 
when the head element of a substitution group is declared as abstract, we have 
chosen this way of implementing project_asset as a complex type. 
Finally, the last possibility is to choose a shortcut, and simply create an ele- 
ment for project and use it as the head element in the definition of element 
band. But this approach does not separate clearly between asset and display 

282 
Chapter 8 From Conceptual Model to Schema 
labels and could lead to problems later when the schema grows. It is better to 
use the kind of indirection shown in the code below. 
project.xsd 
This file implements the L2S project with all outgoing arcs. It also defines a sub- 
stitution group for the display name band. 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs .schema targetNamespace="http 9 
a" 
xml ns 9 
xs=" http 9 
w3. org/2001/XMLSc hema" 
xml ns=" http 9 
j azz. org/encycl opedi a" 
xml ns" xsg=" http 9 
aomodel i ng. org/KLEEN/XSDgenerator" 
e I ement Fo rmDe fau I t = "qua I i fled" 
a t t ri but eFo rmDe fau I t =" unqua I i fled "> 
<xs" i ncl ude schemaLocati on="www_j azz_org_encycl opedi a_TYPELI B. xsd"/> 
<!--Asset project--> 
<xs: compl exType name="project_asset"> 
<xs" compl exContent> 
<xs. extensi on base="project_type"> 
<xs. sequence> 
<xs" el ement name="result" mi nOccurs="O '' maxOccurs="unbounded"> 
<xs 9 
compl exType> 
<xs. sequence> 
<xs.el ement name="a|bum"> 
<xs" annotat i on> 
<xs" documentati on> 
refers to key pk album_albumKey in schema album.xsd 
</xs" documentati on> 
<xs'appinfo> 
<xsg" refersToSchema 
xl ink'href="album.xsd" xlink'type="simple" 
xml ns" xl i nk="http'//www, w3. org/1999/xl ink" 
k eyName= "pk a I bum_a I b umKey"/> 
</xs" appi nfo> 
</xs "annotation> 
<xs 9 
compl exType> 
<xs'all> 
<xs.element name="publ i sher" type="xs "anyURI''/> 
<xs'el ement name="productNo" type="xs "NMTOKEN"/> 

8.2 
Implementation in XML Schema 
283 
</xs.all> 
</xs- compl exType> 
</xs .el ement> 
</xs 9 
sequence> 
</xs "compl exType> 
</xs .el ement> 
<xs. el ement name="j azzMus i ci an" 
mi nOccurs="2 '' maxOccurs="unbounded"> 
<xs" annotati on> 
<xs- documentat i on> 
refers to key pkmjazzMusician_ID in schema jazzMusician.xsd 
</xs-documentati on> 
<xs "appinfo> 
<xsg.refersToSchema xl ink.href="jazzMusician.xsd" 
xl ink'type="simpl e '' 
xml ns" xl ink=" http 9 
w3. org/1999/xl ink" 
keyName =''pkmj azzMusi ci an_ID"/> 
</xs "appinfo> 
</xs" annotation> 
<xs 9 
compl exType> 
<xs.all> 
<xs'element name="ID" type="xs.NMTOKEN"/> 
</xs.all> 
</xs- compl exType> 
</xs "el ement> 
</xs 9 
sequence> 
</xs "extension> 
</xs- compl exContent> 
</xs" compl exType> 
<xs:element name="project" type="project asset"> 
m 
<xs" key name:"pkmproject_name"> 
<xs'sel ector xpath=". "/> 
<xs.field xpath="name"/> 
</xs" key> 
</xs. el ement> 
<xs-element name="band" substitutionGroup:"project"/> 
</xs" schema> 

284 
Chapter 8 From Conceptual Model to Schema 
Figure 8.8 Defining business objects band and project via a substitution group. 
Again, we have defined the arcs leading to jazzMusician and to album as ele- 
ments whose child elements contain the foreign key values. Note that the ele- 
ment album is wrapped by element result because we wanted to carry the role 
name of the arc leading from project/band to al bum into the schema. Figure 8.8 
illustrates the schema for project/band. 
8.2.9 Implementing Clusters 
Asset review contains a cluster with arcs leading to jazzMusician and album. This 
indicates that a review instance relates either to a jazzMusician instance or to an 

8.2 Implementation in XML Schema 
285 
album instancemthat is, a review either honors the life and work of a particular 
jazz musician, or praises the newest jazz album on the market. 
The way to implement this in XML Schema is via a choi ce clause. 
review.xsd 
This file implements the L2S review with all outgoing arcs. 
<?xml version="l.O" encoding="UTF-8"?> 
<xs" schema targetNamespace="http 9 
org/encycl opedi a" 
xml ns" xs =" ht tp'//www, w3. org/2001/XMLSc hema" 
xml ns=" http 9 
jazz. org/encycl opedi a" 
xml ns. xsg=" ht tp'//www, aomode I i ng. org/KLEEN/XSDgenera tor" 
el ementFormDefaul t =''qual i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<xs" i nc I ude schemaLocat i on="www_j azz_org_encyc I opedi a_TYPELI B. xsd"/> 
<!--Asset review--> 
<xs. el ement name:" revi ew"> 
<xs 9 
compl exType> 
<xs" compl exContent> 
<xs" extensi on base="revi ew_type"> 
<xs. sequence> 
<xs: choice> 
<xs'el ement name="al bum"> 
<xs "annotation> 
<xs" documentat i on> 
refers to key pk 
album albumKey in schema album.xsd 
m 
</xs" documentati on> 
<xs'appinfo> 
<xsg'refersToSchema xl ink.href="album.xsd" 
xl i nk'type="simpl e" 
xml ns" xl i nk="http 9 
w3. org/1999/xl i nk" 
keyName=" pk 
a I bum_a I bumKey"/> 
</xs'appinfo> 
</xs. annotation> 
<xs 9 
compl exType> 
<xs'all> 
<xs'element name="publ i sher" type="xs .anyURl''/> 
<xs" el ement name="productNo" type="xs "NMTOKEN"/> 

2~ 
Chapter 8 From Conceptual Model to Schema 
</xs.all> 
</xs. compl exType> 
</xs "el ement> 
<xs.element name="jazzMusici an"> 
<xs "annotation> 
<xs" documentat i on> 
refers to key pkmjazzMusician_ID in schema jazzMusician.xsd 
</xs" documentati on> 
<xs.appinfo> 
<xsg.refersToSchema xl ink-href="jazzMusician.xsd" 
xl ink.type="simpl e" 
xml ns" xl i nk=" http 9 
w3. org/1999/xl i nk" 
keyName= "pk 
j azzMus i ci an_l D"/> 
</xs- appi nfo> 
</xs .annotation> 
<xs 9 
compl exType> 
<xs.all> 
<xs.element name="ID '' type="xs'NMTOKEN"/> 
</xs.all> 
</xs" compl exType> 
</xs.el ement> 
</xs:choice> 
<xs'el ement ref="magazi ne"/> 
<xs- el ement name=" cri t i c"> 
<xs" annotati on> 
<xs" documentat i on> 
refers to key pk 
critic_ID in schema critic.xsd 
</xs. documentati on> 
<xs "appinfo> 
<xsg. refersToSchema xl ink'href="cri ti c.xsd" 
xl ink'type="simpl e '' 
xml ns" xl i nk=" http 9 
w3. org/1999/xl ink" 
keyName=" pkmcri t i c_l D"/> 
</xs'appinfo> 
</xs'annotation> 
<xs 9 
compl exType> 
<xs.all> 

8.2 Implementation in XML Schema 
287 
<xs : el ement name=" ID" type="xs: NMTOKEN"/> 
</xs:all> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 
</xs :extension> 
</xs: compl exContent> 
</xs: compl exType> 
<xs:key name="pk review ID"> 
m 
<xs:selector xpath=". "/> 
<xs:flel d xpath=" ID"/> 
</xs:key> 
</xs :el ement> 
<!--Asset magazine--> 
<xs: el ement name="magazi ne" type="magazi ne_type"/> 
</xs: schema> 
The two arcs are implemented in the usual way, but they are simply con- 
nected via the choice clause. So an instance element review may only refer to 
one of either album or jazzMusician. The structure of business object review is 
shown in Figure 8.9 (page 288). 
8.2.10 Business Objects critic and style 
Finally, we show the schemata for the assets critic and style. 
critic.xsd 
This file implements the L2S critic (Figure 8.10, page 289). 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema targetNamespace=" http 9 
jazz. org/encyc I opedi a" 
xml ns" xsg=" http 9 
aomodel i ng. org/KLEEN/XSDgenerator" 
xml ns" xs=" ht tp'//www, w3. org/2001/XM LSc hema" 
xml ns=" http.//www, j azz. org/encycl opedi a" 
el ementFormDefaul t =''qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs" i nc I ude schemaLocat i on="www_j azz_org_encycl opedi a_TYPELI B. xsd"/> 
<!--Asset critic--> 

288 
Chapter 8 From Conceptual Model to Schema 
Figure 8.9 The structure of business object review. 

8.2 Implementation in XML Schema 
289 
Figure 8.10 The structure of business object critic. 
<xs'element name="critic" type="critic_type"> 
<xs.key name="pk critic ID"> 
w 
<xs-selector xpath=". "/> 
<xs'field xpath=" ID"/> 
</xs" key> 
</xs -el ement> 
</xs "schema> 
style.xsd 
Finally, this file implements the L2S style according to the diagram in Figure 
8.11 (page 290). 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema targetNamespace=" http 9 
jazz. org/encyc I opedi a" 
xml ns: xsg:"http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
xml ns: xs=" ht tp://www, w3. org/2001/XMLSc hema" 
xml ns=" http://www, jazz. org/encyc I opedi a!' 
el ementFormDefaul t="qual i fled" 
attri buteFormDefaul t=" unqual i fled"> 

290 
Chapter 8 From Conceptual Model to Schema 
Figure 8.11 The structure of business object style. 
<xs" i ncl ude schemaLocati on="www_j azz_org_encycl opedi a_TYPELIB.xsd"/> 
<!--Asset style--> 
<xs .el ement name="styl e"> 
<xs 9 
compl exType> 
<xs- compl exContent> 
<xs: extens i on base=" styl e_type"> 
<xs .sequence> 
<xs .el ement ref="descri pti on"/> 
</xs -sequence> 
</xs -extension> 
</xs" compl exContent> 
</xs" compl exType> 
<xs-key name="pk style name"> 
m 
<xs'selector xpath ='' . "/> 
<xs.field xpath="name"/> 
</xs'key> 
</xs" el ement> 
<!--Asset description--> 
<xs.element name="description" type="description_type"/> 
</xs 9 
schema> 

8.3 Implementation in Relax NG 
291 
8.3 IMPLEMENTATION IN RELAX NG 
For comparison, we implement the model shown in Figure 8.1 again, but this 
time in Relax NG. 
8.3.1 Creating a Type Library 
Again, our approach will be to first implement the asset types and then extend 
these definitions with the implementation of keys and arcs. Since Relax NG 
does not feature a type system similar to the complex types in XML Schema, we 
might consider using the more generic pattern feature instead for this task. 
Let's start with the same asset as in Section 8.2. The asset period serves as a 
type that is used for property type declarations in various other assets. We 
implement this asset as a pattern named peri od_type. 
peri od_type, rng 
This file implements the asset type period. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng :grammar xml ns: rng="http://rel axng .org/ns/structure/1.0" 
xml ns =" ht tp://www, jazz. org/encyc I opedi a" 
ns=" http://www, jazz. org/encycl opedi a" 
datatypeLi brary=" http://www, w3. org/2001/XMLSc hema-dat atypes "> 
<rng: define name="peri od_type"> 
<rng: el ement name:"from"> 
<rng:data type="gYear"/> 
</rng:el ement> 
<rng:optional> 
<rng: el ement name="to"> 
<rng: data type="gYear ''/> 
</rng:el ement> 
</rng:optional> 
</rng'define> 
</rng. grammar> 
This pattern defines the content of any element of type peri od, its child ele- 
ments, and their simple data types. As a target namespace, we have declared the 
namespace of our jazz encyclopedia model. This is done with attribute ns. We 

292 
Chapter 8 From Conceptual Model to Schema 
have also set the default namespace as identical to the target namespace; conse- 
quently, we have to prefix the Relax NG vocabulary. 
As shown in Section 7.2.3, we can apply this pattern wherever an element of 
type period is used. For example: 
<rng-el ement name="peri od"> 
<rng'external Ref href="period_type.rng"/> 
</rng.el ement> 
The mechanism is very simple: It is a simple textual inclusion of the refer- 
enced file. As shown in Section 7.2.3, we can also pack together several such 
pattern declarations within a grammar. We can then include this external 
grammar in our current grammar and directly reference types with 
<rng" ref name ="peri od_type"/> 
instead of 
<rng- external Ref href="peri od_type, rng"/>. 
8.3.2 Handling Inheritance 
Simple inheritance relationships could be resolved with the same technique. 
We could just include the pattern reference for the inherited type in the defini- 
tion of the inheriting type. However, this technique does not work in more 
advanced cases of inheritance. Because we have no way to override definitions 
within a referenced pattern, we cannot use this technique to implement inheri- 
tance relationships where inherited properties are overridden by the inheriting 
asset. If we want to achieve that, we must break each structure into its smallest 
ingredients and define each as a pattern. This allows us later to override (or re- 
define) each property and subproperty of a type. 
Let's see how the definition of the asset type person looks when we imple- 
ment it this way. 
person_type, rng 
This file implements the asset type person. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng .grammar xml ns" rng="http://rel axng. org/ns/structure/l. 0" 
xml ns=" http'//www, jazz. org/encycl opedi a" 
ns=" http'//www, j azz. org/encycl opedi a" 
dat atype Library=" http 9 
w3. org/2001/XMLSchema-datatypes "> 
<rng" define name="person_type"> 

8.3 
Implementation in Relax NG 
293 
<rng: ref name="plD"/> 
<rng: ref name="pName"/> 
<rng: ref name="pBi rthDate"/> 
</rng :define> 
<rng:define name="plD"> 
<rng:el ement name=" ID"> 
<rng: data type="NMTOKEN ''/> 
</rng:el ement> 
</rng:define> 
<rng:define name="pName"> 
<rng: el ement name:"name"> 
<rng: ref name="pName, first"/> 
<rng: ref name="pName.mi ddl e"/> 
<rng: ref name="pName. Iast"/> 
</rng:el ement> 
</rng:define> 
<rng: define name="pName, first"> 
<rng: oneOrMore> 
<rng: el ement name="first"> 
<rng:data type="token"/> 
</rng :el ement> 
</rng :oneOrMore> 
</rng:define> 
<rng:define name="pName.mi ddl e"> 
<rng:optional> 
<rng:el ement name="mi ddl e"> 
<rng:data type="token"/> 
</rng:el ement> 
</rng:optional> 
</rng:define> 
<rng: define name="pName. 1 ast"> 
<rng: el ement name=" 1 ast"> 
<rng:data type="token"/> 
</rng:el ement> 
</rng :define> 

294 
Chapter 8 From Conceptual Model to Schema 
<rng:define name="pBi rthDate"> 
<rng:optional> 
<rng:el ement name="bi rthDate"> 
<rng:data type="date"/> 
</rng:el ement> 
</rng:optional> 
</rng: define> 
</rng :grammar> 
We have defined a pattern around each individual element. This a bit 
lengthy, but the effort will pay off. Of course, we have to be careful about name 
clashes. We cannot just prefix each type with a p and use it as a pattern name. 
There may be several local type definitions with the same name. Since patterns 
are always defined on the global level, we must in such cases rename that pat- 
tern. A general approach is to use the full path of an element, as shown in the 
pName.first, pName.middle, pName, last patterns. Since pattern names don't appear 
in the document instance, we are completely free to choose any pattern name 
we like. 
Let's assume that we stored this grammar in file pers0n_type.rng. We can 
reuse this grammar for the definition of jazzMusici antype. We refer to the exter- 
nal grammar with an include clause. In the case of jazzMusici an_type, the inher- 
itance involves simple extension of the person type definition, so nothing needs 
to be overridden. We simply concatenate additional patterns containing defini- 
tions for the properties kind and instrument. 
Again, we have implemented these properties as elements. Of course, we 
could have implemented some of these properties (for instance, the property 
kind) as attributes, but we stay with elements as in Section 8.2. 
j azzMusi ci an_type, rng 
This file implements the asset type jazzMusician. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng "grammar xml ns" rng="http'//rel axng .org/ns/structure/1.0" 
xml ns=" http 9 
jazz. org/encycl opedi a" 
ns--" ht tp.//www, jazz. org/encyc I opedi a" 
dat atype L i brary ='' http'//www, w3. org/2001/XMLSchema-datatypes "> 
<rng: i ncl ude href="person_type, rng"/> 
<rng" define name = "j azzMus i c i an_type"> 
<rng.el ement name="jazzMusi ci an"> 
<rng" ref name="person_type"/> 

8.3 Implementation in Relax NG 
295 
<rng: ref name="pKind"/> 
<rng: zeroOrMore> 
<rng: ref name="plnstrument"/> 
</rng: zeroOrMore> 
</rng:el ement> 
</rng :define> 
<rng :define name="pKi nd"> 
<rng:el ement name="ki nd"> 
<rng:choice> 
<rng: val ue>i nstrumental i st</rng: value> 
<rng: val ue>j azzComposer</rng: va I ue> 
<rng: val ue>j azzS i nger</rng: val ue> 
</rng:choice> 
</rng:el ement> 
</rng :define> 
<rng: define name="p Instrument"> 
<rng:el ement name="i nstrument"> 
<rng:data type="token"/> 
</rng:el ement> 
</rng :define> 
</rng: grammar> 
Note that Relax NG does not require us to define a data type for the enumer- 
ation values. They are just taken as text. 
Next, we have the implementation of asset type critic, which is a subtype 
of pers0n_type, too. However, critic overrides the cardinality constraints of 
name/first with a new value. So, we override the definition of the pFi rst pattern 
when including the pers0n_type grammar. 
cri ti c_type.rng 
This file implements the asset type critic. 
<?xml version="1.0 '' encoding="UTF-8"? > 
<rng-grammar xml ns "rng-"http'//rel axng.org/ns/structure/1.0" 
xml ns=" http 9 
jazz. org/encyc I opedi a" 
ns=" http 9 
jazz. org/encyc I opedi a" 
datatype L i brary=" http'//www, w3. org/2001/XMLSc hema-dat atypes "> 

296 
Chapter 8 From Conceptual Model to Schema 
<rng: i ncl ude href="person_type, rng"> 
<rng: define name="pName, first"> 
<rng: 9 
1 ement name="first"> 
<rng :data type="token"/> 
</rng:element> 
</rng:define> 
</rng: include> 
<rng'define name="cri ti c_type"> 
<rng. ref name="person_type"/> 
</rng" define> 
</rng -grammar> 
In contrast to XML Schema, where we derived the type critic_type from 
pers0n_type by restriction and had to repeat all elements, including the ones 
that did not change, Relax NG only requires us to specify the changed pattern. 
Also, Relax NG can override patterns, even when the new type is not a restric- 
tion of the base type. Consequently, inheritance relationships can be mapped 
onto a Relax NG implementation in more cases than is possible with XML 
Schema. 
Breaking complex structures into their smallest ingredients and defining 
each of those as its own pattern is only required for those types that are inher- 
ited by other types. However, I recommend this as a standard technique when 
defining reusable components and schemata with Relax NG. It allows the 
derivation of new schemata easily by including the old schema and overriding 
the patterns that have changed. Schemata implemented in such a way will lend 
themselves easily to later schema evolution (see Section 12.2.1). 
8.3.3 The Complete Type Library 
In the following type library, we will not follow this advice to break structures 
into their smallest parts. This will save a bit of space and improve the readabil- 
ity of the code. 
When implementing schemata with Relax NG, it makes sense to implement 
each type in a separate file instead of storing all type definitions in one big type 
library. In particular, this is true when we want to inherit definitions between 
types across multiple inheritance levels, since we can override patterns only 
within the i nc] ude clause. 
The following code lists the remaining type definitions, each as a separate 
grammar stored in a separate file. peri0d_type, pers0n_type, jazzMusician_type, 
and cri ti c_type are not listed again, as they have already appeared in the previ- 
ous section. Comments are minimal, as the code is almost self-explanatory. 

8.3 Implementation in Relax NG 
297 
al bum_type, rng 
This file implements the asset type album. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng 9 
grammar xml ns" rng="http'//rel axng .org/ns/structure/1.0" 
xml ns=" http'//www, j azz. org/encyc I opedi a" 
ns=" http 9 
j azz. org/encycl opedi a" 
data type L i b ra ry= "h t tp" //www. w3. o rg / 2001/XM LS c h ema- d a ta types "> 
<!--Asset type album--> 
<rng.define name="al bum_type"> 
<rng-element name="publ i sher"> 
<rng.data type="anyURl"/> 
</rng-el ement> 
<rng.el ement name="productNo"> 
<rng'data type="NMTOKEN ''/> 
</rng.el ement> 
<rng.element name="ti tle"> 
<rng'text/> 
</rng'el ement> 
</rng'define> 
</rng" grammar> 
bel ongsTo_type, rng 
This file implements the asset type belongsTo. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng :grammar xml ns: rng=" http://tel axng. org/ns/structure/1.0" 
xml ns=" http://www, jazz. org/encycl opedi a" 
ns=" http://www, jazz. org/encyc I opedi a" 
datatype L i brary ='' http://www, w3. org/2001/XMLSc hema-dat atypes "> 
<!--Asset type belongsTo--> 
<rng" incl ude href="period_type, rng"/> 
<rng- define name="bel ongsTo_type"> 
<rng'el ement name="period"> 
<rng" ref name="peri od_type"/> 

298 
Chapter 8 From Conceptual Model to Schema 
</rng:el ement> 
</rng" define> 
</rng" g ramma r> 
descri pt i on_type, rng 
This file implements the asset type description. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng "grammar xml ns" rng="http.//rel axng.org/ns/structure/1.0" 
xml ns="http.//www, jazz. org/encycl opedi a" 
ns="http'//www, jazz. org/encycl opedi a"> 
<!--Asset type description--> 
<rng" define name=" descri pt i on_type"> 
<rng-external Ref href="anyXhtml, rng"/> 
</rng'define> 
</rng 9 
grammar> 
Here we have to implement a wildcard. Relax NG does not have its own wild- 
card construct; instead we have to express the wildcard with a structure similar 
to that discussed in Section 7.2.3. We have put this definition into a separate file 
so that we can reuse it whenever we need it. The following pattern anyXhtml 
describes any content from the XHTML namespace. We have made use of a 
name class, to restrict the element names to this namespace (see Section 7.3.2). 
anyXhtml, rng 
This file implements a wildcard with the XHTML namespace. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng :grammar xml ns: rng="http://rel axng. org/ns/structure/l. 0" 
xml ns=" http://www, w3. org/1999/xhtml "> 
<rng: start> 
<rng: ref name="anyXhtml "/> 
</rng: start> 
<rng'define name="anyXhtml "> 
<rng'el ement> 
<rng'nsName ns="http.//www.w3.org/1999/xhtml "/> 

8.3 Implementation in Relax NG 
79 t ) 
<rng:mixed> 
<rng: zeroOrMore> 
<rng:choice> 
<rng: ref name ='' anyXhtml "/> 
<rng:attribute> 
<rng: anyName/> 
</rng: attribute> 
</rng:choice> 
</rng: zeroOrMore> 
</rng:mixed> 
</rng:el ement> 
</rng:define> 
</rng :grammar> 
i nfluence_type, rng 
This file implements the asset type influence. 
<?xml version="1.0 '' encoding="UTF-8"? > 
<rng 9 
grammar xml ns- rng="http 9 
axng. org/ns/structure/1.0" 
xml ns=" http 9 
jazz. org/encyc I opedi a" 
ns=" http 9 
j azz. org/encycl opedi a" 
datatype L i brary ='' http'//www, w3. org/2001/XMLSc hema-dat atypes "> 
<!--Asset type influence--> 
<rng'define name="i nfluence_type"> 
<rng 9 
empty/> 
</rng" define> 
</rng- g r amma r> 
jamSessi on_type, rng 
This file implements the asset type j amSession. 
<?xml version="1.0 '' encoding="UTF-8"? > 
<rng:grammar xml ns:rng="http://rel axng.org/ns/structure/l.0" 
xml ns=" http://www, j azz. org/encycl opedi a" 
ns=" http://www, j azz. org/encyc I opedi a" 
datatype L i brary ='' http://www, w3. org/2001/XMLSchema-datatypes "> 

300 
Chapter 8 From Conceptual Model to Schema 
<!--Asset type jamSession--> 
<rng" define name="j amSessi on_type"> 
<rng" el ement name="t ime"> 
<rng'data type="dateTime"/> 
</rng-el ement> 
<rng'el ement name="l ocation"> 
<rng'data type="token"/> 
</rng.el ement> 
</rng .define> 
</rng. g ramma r> 
magazi ne_type, rng 
This file implements the asset type magazine. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng .grammar xml ns- rng="http'//rel axng.org/ns/structure/1.0" 
xml ns=" http'//www, jazz. org/encyc I opedi a" 
ns=" http 9 
jazz. org/encyc I opedi a" 
data typeL i b ra ry = "h ttp" //www. w3. o rg / 2001/XM LSc hema- d a ta types "> 
<!--Asset type magazine--> 
<rng'define name="magazi ne_type"> 
<rng'el ement name="name"> 
<rng'text/> 
</rng'el ement> 
<rng" el ement name="URl "> 
<rng-data type="anyURl"/> 
</rng'el ement> 
</rng'define> 
</rng .grammar> 
pl ays_type, rng 
This file implements the asset type plays. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng "grammar xml ns" rng="http'//rel axng.org/ns/structure/1.0" 
xml ns=" http 9 
j azz. org/encycl opedi a" 

8.3 Implementation in Relax NG 
301 
ns=" http://www, jazz. org/encycl opedi a" 
datatypeL i bra ry=" http://www, w3. org/200 I/XMLS c hema-dat atypes "> 
<!--Asset type plays--> 
<rng:define name="pl ays_type"> 
<rng :oneOrMore> 
<rng:el ement name:"i nstrument"> 
<rng:data type="token"/> 
</rng:el ement> 
</rng: oneOrMore> 
</rng :define> 
</rng :grammar> 
produces_type, rng 
This file implements the asset type produces. Remember, the define clause must 
always contain a child element. Because asset produces does not have a property, 
we use the empty clause to specify the empty content model. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng -grammar xml ns" rng="http'//rel axng.org/ns/structure/l. 0" 
xml ns="http 9 
jazz. org/encyc I opedi a" 
ns=" ht tp'//www, j azz, org/encyc I opedi a" 
data t ypeL i b ra ry= "h t t p" //www. w3. o rg /2001/XM LS c h ema- data types "> 
<!--Asset type produces--> 
<rng" define name="produces_type"> 
<rng "empty/> 
</rng-define> 
</rng" g r amma r> 
project_type, rng 
This file implements the asset type project. 
<?xml version="1.0 '' encoding="UTF-8"?> 
<rng:grammar xml ns:rng="http://rel axng.org/ns/structure/l.0" 
xml ns=" http://www, jazz. org/encyc I opedi a" 
ns=" http://www, jazz. org/encycl opedi a" 
datatype Library=" http://www, w3. org/2001/XMLSc hema-dat atypes "> 

302 
Chapter 8 From Conceptual Model to Schema 
<!--Asset type project--> 
<rng" i ncl ude href="peri od_type, rng"/> 
<rng" define name="project_type"> 
<rng'el ement name:"name"> 
<rng.data type="token"/> 
</rng'el ement> 
<rng" el ement name="peri od"> 
<rng" ref name="peri od_type"/> 
</rng'el ement> 
</rng-define> 
</rng" grammar> 
revi ew_type, rng 
This file implements the asset type review. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng: grammar xml ns: rng=" http://rel axng. org/ns/structure/I. 0" 
xml ns=" http://www, jazz. org/encyc I opedi a" 
ns=" http://www, j azz. org/encycl opedi a" 
data typeL i b ra ry= "h t tp: //www. w3. o rg / 2001/XM LSc h ema- d a t a types "> 
<!--Asset type review--> 
<rng:define name="revi ew_type"> 
<rng:el ement name=" ID"> 
<rng: data type="NMTOKEN ''/> 
</rng:el ement> 
<rng:el ement name="pubDate"> 
<rng:data type="gYearMonth"/> 
</rng:el ement> 
</rng:define> 
</rng:grammar> 
sampl e_type, rng 
This file implements the asset type sample. 
<?xml version="1.0" encoding="OTF-8"?> 
<rng "grammar xml ns. rng="http 9 
axng.org/ns/structure/1.0" 

8.3 Implementation in Relax NG 
303 
xml ns=" ht tp'//www, jazz. org/encyc I opedi a" 
ns=" http 9 
jazz. org/encycl opedi a" 
datatype Li brary=" http 9 
w3. org/2001/XMLSchema-datatypes "> 
<!--Asset type sample--> 
<rng'define name="sampl e_type"> 
<rng'el ement name="MP3"> 
<rng'data type="anyURl"/> 
</rng.el ement> 
</rng "define> 
</rng "grammar> 
styl e_type, rng 
This file implements the asset type style. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng 9 
grammar xml ns" rng="http'//rel axng .org/ns/structure/1.0" 
xml ns=" http 9 
jazz. org/encyc I opedi a" 
ns=" http 9 
jazz. org/encycl opedi a"> 
<!--Asset type style--> 
<rng" i ncl ude href="peri od_type, rng"/> 
<rng'define name="styl e_type"> 
<rng'el ement name:"name"> 
<rng'data type="token"/> 
</rng'el ement> 
<rng" el ement name:"domi nantDuri ng"> 
<rng" ref name="peri od_type"/> 
</rng'el ement> 
</rng "define> 
</rng .grammar> 
tracktype, rng 
Finally, this file implements the asset type track. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng'grammar xml ns'rng="http'//rel axng.org/ns/structure/l. 0" 
xml ns= "http 9 
jazz. org/encyc I opedi a" 

304 
Chapter 8 From Conceptual Model to Schema 
ns=" http 9 
jazz. org/encyc I opedi a" 
data t ypeL i b ra ry= "h t tp" //www. w3. o rg / 2001/XM LS c h ema- d a ta types "> 
<!--Asset type track--> 
<rng'define name="track_type"> 
<rng'attri bute name="trackNo"> 
<rng.data type=" ID"/> 
</rng'attribute> 
<rng.element name="ti tl e"> 
<rng:text/> 
</rng:el ement> 
<rng'optional> 
<rng.el ement name="duration"> 
<rng'data type="durati on"/> 
</rng.el ement> 
</rng.optional> 
</rng:define> 
</rng" g ramma r> 
The property trackNo is used as a key for cross-references. Because Relax 
NG relies on the DTD logic for keys and key references, we have to implement 
trackNo as an attribute of type ID. 
8.3.4 Implementing a Business Object 
As in Section 8.2.6, we start with the business object jazzMusician and the iden- 
tifying item jazzMusician. We implement this asset as the root element of the 
schema jazzMusi cian. rng. The type assigned to this element is derived from type 
jazzMusician_type. The extension consists of the other assets in this Level 2 
Structure (belongsTo, influence, and produces) that are implemented as child ele- 
ments of jazzMusician. 
At certain points, you will notice XML Schema language elements within 
this code, especially for key expressions and for annotations. All these elements 
are prefixed with xs., so Relax NG will treat them as annotations. We have 
opted to implement only the primary and foreign keys of cross-references with 
the old DTD-style logic of ID and IDREF attributes, because only those are nec- 
essary for the validation of a single document. References across document and 
schema boundaries are not evaluated by the parser, but can serve as informa- 
tion for suitable XML middleware. 
We implement each asset as its own pattern and refer to it with an rng: ref 
clause. As noted earlier, it is advisable to break clown the structure even more 

8.3 Implementation in Relax NG 
305 
and implement each property and subproperty as its own pattern. This provides 
a better basis for later schema evolution (see Chapter 12). We don't do this here, 
however, for reasons of space and readability. 
The highlighted block in the implementation of asset jazzMusician declares 
an attribute that is not present in the conceptual model. This is attribute 
xsi :schemaLocation. The definition allows document instances to contain such 
an attribute. We thus achieve interoperability with XML Schema where docu- 
ment instances can declare a schema location via this attribute. 
jazzMusi ci an. rng 
This file implements the L2S jazzMusician with all outgoing arcs. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng: grammar xml ns: rng="http://rel axng. org/ns/structure/1.0" 
xml ns=" http://www, jazz. org/encycl opedi a" 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns :xs i =" http://www, w3. org/2OO1/XMLSchema- i nstance" 
xml ns : xsg=" http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
ns=" http://www, j azz. org/encycl opedi a" 
datatypeL i brary=" http://www, w3. org/2001/XMLSchema-datatypes "> 
<!--Asset jazzMusician--> 
<rng" i ncl ude href="j azzMus i ci an_type, rng"/> 
<rng'start> 
<rng: el ement name="j azzMus i c i an"> 
<rng- re f name =''j azzMus i c i an_type"/> 
<rng: attri bute name="xs i : schemaLocat i on"> 
<rng:data type="anyURI"/> 
</rng: attribute> 
<rng" zeroOrMore> 
<rng" ref name= " produces " /> 
</rng" zeroOrMore> 
<rng" zeroOrMore> 
<rng" ref name="bel ongsTo"/> 
</rng" zeroOrMore> 
<rng" zeroOrMore> 
<rng'ref name="i nfluence"/> 
</rng" zeroOrMore> 

306 
Chapter 8 From Conceptual Model to Schema 
<xs:key name="pk jazzMusician_ID"> 
<xs'selector xpath:". "/> 
<xs.field xpath=" ID"/> 
</xs-key> 
</rng:el ement> 
</rng'start> 
<!--Asset produces--> 
<rng" i ncl ude href="produces_type, rng"/> 
<rng'define name="produces"> 
<rng" el ement name="produces"> 
<rng. ref name="produces_type"/> 
<rng" zeroOrMore> 
<rng" el ement name="al bum"> 
<xs'annotation> 
<xs. documentat i on> 
refers to key pk album albumKey in schema album.xsd 
m 
</xs" documentat i on> 
<xs'appinfo> 
<xsg- refersToSchema 
xml ns" xl ink=" http://www, w3. org/1999/xl ink" 
xl ink" href="al bum.xsd" 
xl i nk'type="simpl e" 
keyName= "pk 
a I bum_a I bumKey"/> 
</xs'appinfo> 
</xs "annotation> 
<rng" i nterl eave> 
<rng'element name="publ i sher"> 
<rng'data type="anyURl"/> 
</rng'el ement> 
<rng'el ement name="productNo"> 
<rng'data type="NMTOKEN"/> 
</rng:el ement> 
</rng 9 
i nterl eave> 
</rng:el ement> 
</rng" zeroOrMore> 

8.3 Implementation in Relax NG 
307 
</rng.el ement> 
</rng :define> 
<!--Asset bel ongsTo--> 
<rng. i ncl ude href="bel ongsTo_type, rng"/> 
<rng" define name="bel ongsTo"> 
<rng'el ement name="bel ongsTo"> 
<rng" ref name="bel ongsTo_type"/> 
<rng" oneOrMore> 
<rng.element name="style" maxOccurs="unbounded"> 
<xs'annotation> 
<xs. documentati on> 
refers to key pkmstyle_name in schema style.xsd 
</xs" documentati on> 
<xs.appinfo> 
<xsg. refersToSchema 
xl ink. href="styl e.xsd" 
xl i nk'type="simpl e" 
xml ns :xl ink=" http 9 
w3. org/1999/xl ink" 
keyN ame=" pk sty I e_name"/> 
</xs "appi nfo> 
</xs'annotation> 
<rng" interleave> 
<rng 9 
el ement name="name"> 
<rng'data type="token"/> 
</rng'el ement> 
</rng: i nterl eave> 
</rng'el ement> 
</rng: oneOrMore> 
</rng 9 
el ement> 
</rng "define> 
<!--Asset influence--> 
<rng" include href="influence_type, rng"/> 
<rng.define name="i nfluence"> 
<rng. el ement name="i nfluence"> 

308 
Chapter 8 From Conceptual Model to Schema 
<rng" ref name:"influence_type"/> 
<rng. zeroOrMore> 
<rng. el ement name="i nfluencedBy"> 
<xs" annotati on> 
<xs" documentat i on> 
refers to key pk jazzMusician_ID in schema jazzMusician.xsd 
</xs. documentat i on> 
<xs:appinfo> 
<xsg" refersToSchema xl ink: href="jazzMusi ci an .xsd" 
xl ink'type="simpl e" 
xml ns: xl i nk=" http 9 
w3. org/1999/xi i nk" 
keyName= "p k j azzMu s i c i an_I D"/> 
</xs" appi nfo> 
</xs "annotation> 
<rng'el ement name="j azzMusi ci an"> 
<rng: i nterl eave> 
<rng:el ement name=" ID"> 
<rng. data type="NMTOKEN ''/> 
</rng'el ement> 
</rng 9 
i nterl eave> 
</rng'el ement> 
</rng'el ement> 
</rng: z e roOrMo re> 
</rng'el ement> 
</rng-define> 
</rng 9 
grammar> 
8.3.5 Dealing with Cross-References 
We now move to the implementation of business object a l bum. (Compare this 
with Section 8.2.7.) album does not have a hierarchical structure--there is a 
cross-reference between track and sampl e. 
Relax NG does not provide support for keys and key references, but for back- 
ward compatibility with DTDs, it allows the use of ID, IDREF, and IDREFS for 
attribute types. Attributes of this type act as keys and key references. A Relax 
NG-specific solution for keys and key references is expected for future releases. 
Here, we have defined attribute sampl e/track/OtrackN0 as a key reference with 
type IDREF. The corresponding key track/OtrackNo with type IDis defined in 
track_type, rng shown in Section 8.3.3. 

8.3 
Implementation in Relax NG 
309 
al bum. rng 
This file implements the L2S a l bum with all outgoing arcs. 
<?xml version="l.O" encoding="UTF-8"?> 
<rng:grammar xml ns:rng="http://rel axng.org/ns/structure/l.0" 
xml ns="http://www, j azz. org/encycl opedi a" 
xml ns : xs=" http://www, w3. org/200 i/XMLSchema" 
xml n s: xs i = "h t tp://www, w3. o rg/2001/XM LS c h ema- ins tance" 
xml ns: xsg=" http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
ns=" ht tp://www, jazz. org/encyc I opedi a" 
datatypeL i brary=" http://www, w3. org/2001/XMLSc hema-dat atypes "> 
<!--Asset album--> 
<rng" i ncl ude href="al bum_type, rng"/> 
<rng'start> 
<rng" el ement name="al bum"> 
<rng" ref name:"al bum_type"/> 
<rng'attribute name="xsi -schemaLocation"> 
<rng'data type="anyURl"/> 
</rng'attri bute> 
<rng" oneOrMore> 
<rng" ref name="track ''/> 
</rng" oneOrMore> 
<rng 9 
zeroOrMore> 
<rng" ref name="sampl e"/> 
</rng" zeroOrMore> 
<rng- zeroOrMore> 
<rng" ref name="pl ays"/> 
</rng" zeroOrMore> 
<xs'key name="pk al bum_al bumKey"> 
<xs'selector xpath=". "/> 
<xs.field xpath="publ isher"/> 
<xs "fiel d xpath="productNo"/> 
</xs. key> 
</rng'el ement> 
</rng" start> 

]10 
Chapter 8 From Conceptual Model to Schema 
<!--Asset track--> 
<rng" i ncl ude href="track_type, rng"/> 
<rng :define name="track"> 
<rng: el ement name="track"> 
<rng" ref name="track_type ''/> 
</rng'el ement> 
</rng-define> 
<!--Asset sample--> 
<rng" i ncl ude href="sampl e_type, rng"/> 
<rng'define name="sampl e"> 
<rng" e I ement name=" samp I e"> 
<rng: ref name="sampl e_type"/> 
<rng:el ement name="track"> 
<rng" attribute name="trackNo"> 
<rng:data type="IDREF"/> 
</rng'attri bute> 
</rng'el ement> 
</rng:el ement> 
</rng :define> 
<!--Asset plays--> 
<rng" i ncl ude href:"pl ays_type, rng"/> 
<rng.define name="pl ays"> 
<rng.element name="pl ays"> 
<rng:ref name="pl ays_type"/> 
<rng:el ement name="j azzMusi ci an"> 
<xs "annotation> 
<xs: documentati on> 
refers to key pkmjazzMusician_ID in schema jazzMusician.xsd 
</xs: documentat i on> 
<xs .appi nfo> 
<xsg:refersToSchema xl ink:href="jazzMusician.xsd" 
xl ink.type="simpl e" 
xml ns" xl ink=" http 9 
w3. org/1999/xl ink" 
keyName=" p kmj azzMus i ci an_I D"/> 

8.3 Implementation in Relax NG 
311 
</xs:appinfo> 
</xs: annotat i on> 
<rng: i nterl eave> 
<rng:el ement name=" ID"> 
<rng: data type="NMTOKEN"/> 
</rng:el ement> 
</rng: i nterl eave> 
</rng:el ement> 
</rng:el ement> 
</rng:define> 
</rng :grammar> 
8.3.6 Resolving Multiple Display Labels 
In Section 8.2.8 we implemented the business objects band and project (which 
have a shared definition in asset project) with the help of substitution groups. 
In Relax NG we implement this asset as a single pattern. But instead of using a 
name attribute for the top element definition, we use a name class definition 
(see Section 7.3.2). This name class consists of the two names band and project. 
We had to deal with another problem, too. The arc leading from project to 
jazzMusician was decorated with the constraint [2..*]. The definition of such 
general constraints is not supported in the Relax NG schema language. We have 
to simulate this by concatenating two references to jazzMusician: Instead of 
jazzMusician[2 
*] we use jazzMusician 
jazzMusician+. To achieve this with 
the least effort, we have factored out the implementation of this reference into 
a separate pattern called jazzMusician_Ref. 
project.rng 
This file implements the L2S project with all outgoing arcs. 
<?xml version="1.0 '' encoding="UTF-8"?> 
<rng :grammar xml ns: rng=" http://rel axng. org/ns/structure/1.0" 
xml ns =" ht tp://www, jazz. o rg/en cyc I opedi a" 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns: xs i =" ht tp://www, w3. o rg/2001/XM LSchema- ins tance" 
xml ns : xsg=" http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
ns=" http://www, jazz. org/encyc I opedi a" 
datatype L i brary=" http://www, w3. org/2001/XMLSchema-datatypes "> 
<!--Asset project--> 
<!--Asset band--> 

3112 
Chapter 8 From Conceptual Model to Schema 
<rng" include href="project_type, rng"/> 
<rng.start> 
<rng" el ement> 
<rng:choice> 
<rng: n ame>proj ect </rng: name> 
<rng: name>band</rng: name> 
</rng:choice> 
<rng" ref name="project_type"/> 
<rng" attri bute name="xsi 9 
schemaLocati on"> 
<rng'data type="anyURl"/> 
</rng.attri bute> 
<rng" zeroOrMore> 
<rng: el ement name="resul t"> 
<rng'el ement name="al bum"> 
<xs" annotati on> 
<xs" documentati on> 
refers to key pk 
album albumKey in schema album.xsd 
m 
</xs" documentat i on> 
<xs'appinfo> 
<xsg: refersToSchema 
xl i nk" href="al bum. xsd" 
xl ink: type="simpl e" 
xml ns" xl i nk-"http 9 
w3. org/1999/xi i nk" 
k eyName= "pk 
a I bum_a I bumKey"/> 
</xs "appinfo> 
</xs: annotati on> 
<rng" i nterl eave> 
<rng'element name="publ i sher"> 
<rng'data type="anyURl"/> 
</rng:el ement> 
<rng:el ement name="productNo"> 
<rng.data type="NMTOKEN"/> 
</rng:el ement> 
</rng 9 
i nterl eave> 
</rng.el ement> 
</rng:el ement> 
</rng" zeroOrMore> 

8.3 
Implementation in Relax NG 
313 
<rng:ref name:"jazzMusician Ref"/> 
<rng: oneOrMore> 
<rng:ref name="jazzMusician Ref"/> 
</rng: oneOrMore> 
<xs.key name="pk jazzMusician_ID"> ~ 
<xs'selector xpath=". "/> 
<xs'field xpath=" ID"/> 
</xs" key> 
<xs" key name="pk al bum_al bumKey"> 
<xs'selector xpath=". "/> 
<xs'field xpath="publ i sher"/> 
<xs.field xpath=" productNo"/> 
</xs" key> 
</rng'el ement> 
</rng" start> 
<rng:define name="jazzMusician Ref"> 
<rng" el ement name="j azzMus i ci an"> 
<xs-annotation> 
<xs" documentat i on> 
refers to key pk jazzMusician_ID in schema jazzMusician.xsd 
</xs" documentati on> 
<xs'appinfo> 
<xsg- refersToSchema xl ink. href=" j azzMusi ci an .xsd" 
xl i nk'type="simpl e" 
xml ns'xl i nk="http 9 
w3. org/1999/xi ink" 
keyName=" pkmj azzMus i c i an_l D"/> 
</xs'appinfo> 
</xs -annotation> 
<rng" interleave> 
<rng'el ement name=" ID"> 
<rng'data type="NMTOKEN"/> 
</rng .el ement> 
</rng 9 
i nterl eave> 
</rng.el ement> 
</rng:define> 
</rng" g r amma r> 

314 
Chapter 8 From Conceptual Model to Schema 
8.3.7 Implementing Clusters 
Asset review contains a cluster with arcs leading to jazzMusician and album. As in 
Section 8.2.9, the implementation with a choice clause is straightforward. 
revi ew. rng 
This file implements L2S review with all outgoing arcs. 
<?xml version="1.0" encoding="UTF-8"?> 
<rng:grammar xml ns:rng="http://rel axng.org/ns/structure/l.0" 
xml ns = "h t tp://www, j azz. org/en cyc Ioped i a" 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns: xs i =" http://www, w3. org/200 i/XMLSchema- i nstance" 
xml ns: xsg=" http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
ns=" http://www, jazz. org/encyc I opedi a" 
datatype L i brary=" htt p://www, w3. org/2001/XMLSc hema-dat atypes "> 
<!--Asset review--> 
<rng" i ncl ude href="revi ew_type, rng"/> 
<rng'start> 
<rng" el ement name="revi ew"> 
<rng: ref name="revi ew_type"/> 
<rng'attribute name="xsi "schemaLocation"> 
<rng'data type="anyURl "/> 
</rng'attribute> 
<rng: choice> 
<rng: el ement name:"al bum"> 
<xs "annotation> 
<xs. documentat i on> 
refers to key pk 
album albumKey in schema album.xsd 
m 
</xs" documentati on> 
<xs'appinfo> 
<xsg. refersToSchema xl ink.href="al bum.xsd" 
xl i nk'type="simpl e" 
xml ns" xl i nk="http 9 
w3. org/1999/xl i nk" 
keyName=" p kma I bum_a I bumKey"/> 
</xs "appinfo> 
</xs "annotation> 

8.3 Implementation in Relax NG 
315 
<rng. interleave> 
<rng.element name="publ i sher"> 
<rng'data type="anyURl"/> 
</rng .el ement> 
<rng'el ement name="productNo"> 
<rng'data type="NMTOKEN ''/> 
</rng.el ement> 
</rng" i nterl eave> 
</rng.el ement> 
<rng" el ement name="j azzMus i c i an"> 
<xs" annotati on> 
<xs" documentati on> 
refers to key pkmjazzMusician_ID in schema jazzMusician.xsd 
</xs- documentati on> 
<xs-appinfo> 
<xsg" refersToSchema xl ink" href ='' j azzMusi ci an .xsd" 
xl ink'type="simpl e '' 
xml ns" xl i nk="http 9 
w3. org/1999/xl ink" 
keyN ame=" pk 
j azzMus i c i an_l D"/> 
</xs.appinfo> 
</xs- annotati on> 
<rng" interleave> 
<rng.el ement name=" ID"> 
<rng" data type="NMTOKEN ''/> 
</rng'el ement> 
</rng 9 
i nterl eave> 
</rng.el ement> 
</rng:choice> 
<rng" ref name="magazi ne"/> 
<rng'el ement name="cri tic"> 
<xs" annotati on> 
<xs" documentat i on> 
refers to key pk 
critic 
ID in schema critic.xsd 
m 
</xs" documentati on> 
<xs'appinfo> 

316 
Chapter 8 From Conceptual Model to Schema 
<xsg'refersToSchema xl ink'href="critic.xsd" 
xl ink'type="simpl e" 
xml ns" xl i n k=" http 9 
w3. org/1999/xi ink" 
keyName= "p kmcri t i c_I D"/> 
</xs "appinfo> 
</xs "annotation> 
<rng'interleave> 
<rng'el ement name=" ID"> 
<rng.data type="NMTOKEN ''/> 
</rng'el ement> 
</rng 9 
i nterl eave> 
</rng'el ement> 
<xs'key name="pk review ID"> 
m 
<xs'selector xpath=". "/> 
<xs.fiel d xpath=" ID"/> 
</xs" key> 
</rng "el ement> 
</rng. start> 
<!--Asset magazine--> 
<rng" include href="magazi ne_type, rng"/> 
<rng: define name="magazi ne"> 
<rng: el ement name="magazi ne"> 
<rng" ref name="magazi ne_type"/> 
</rng'el ement> 
</rng'define> 
</rng'grammar> 
8.3.8 Business Objects cri ti c and style 
As before, the schemata for the business objects critic and style are presented 
last. 
critic.rng 
This file implements the L2S cri t i c. 

8.3 Implementation in Relax NG 
31 7 
<?xml version="1.0 '' encoding="UTF-8"?> 
<rng:grammar xml ns:rng="http://rel axng.org/ns/structure/l.0" 
xml ns = "ht tp://www, jazz. org/en cyc I opedi a" 
xml ns : xs=" http://www, w3. org/2001/XMLSc hema" 
xml ns :xs i =" http://www, w3. org/200 I/XMLSchema- instance" 
xml ns: xsg=" http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
ns=" ht tp://www, jazz. org/encyc I opedi a" 
datatypeL i brary=" http://www, w3. org/2001/XMLSchema-dat atypes "> 
<!--Asset jazzMusician--> 
<rng" i ncl ude href="cri ti c_type, rng"/> 
<rng'start> 
<rng'el ement name="cri tic"> 
<rng- ref name =''cri ti c_type"/> 
<rng.attribute name="xsi "schemaLocation"> 
<rng'data type="anyURl"/> 
</rng'attri bute> 
<xs'key name="pk critic ID"> 
<xs'selector xpath=". "/> 
<xs.field xpath=" ID"/> 
</xs'key> 
</rng'el ement> 
</rng.start> 
</rng 9 
grammar> 
style.rng 
Finally, this file implements the L2S sty1 e. 
<?xm] version="1.0" encoding="UTF-8"?> 
<rng:grammar xm] ns:rng="http://re] axng.org/ns/structure/1.0" 
xm] ns=" http://www, jazz. org/encyc] opedi a" 
xm] ns: xs=" http://www, w3. org/2001/XMLSchema" 
xm] ns: xs i =" http://www, w3. org/2001/XMLSc hema- i nstance" 
xml ns: xsg="http://www, aomodel i ng. org/KLEEN/XSDgenerator" 
ns= "ht tp://www, jazz. org/encyc I oped i a" 
data typeL i bra ry=" ht tp://www, w3. org/2001/XM LS c hema- data types "> 
<!--Asset style--> 

318 
Chapter 8 From Conceptual Model to Schema 
<rng" i ncl ude href="styl e_type, rng"/> 
<rng'start> 
<rng" el ement name="styl e"> 
<rng" ref name="styl e_type"/> 
<rng: attribute name="xs i 9 
schemaLocat i on"> 
<rng'data type="anyURl"/> 
</rng.attribute> 
<rng'ref name="descri pti on"/> 
<xs" key name="pk styl e_name"> 
<xs.sel ector xpath=" ."/> 
<xs.field xpath="name"/> 
</xs'key> 
</rng 9 
el ement> 
</rng" start> 
<!--Asset description--> 
<rng" i ncl ude href =''descri pti on_type, rng"/> 
<rng" define name ='' descri pt i on"> 
<rng.el ement name="descri pti on"> 
<rng" ref name=" descri pt i on_type"/> 
</rng'el ement> 
</rng.define> 
</rng 9 
grammar> 
8.4 SUMMARY 
After these rather extensive code examples, we give a short overview of the 
implementation steps and problems associated with the implementation. 
8.4.1 Synopsis of Implementation Steps 
The implementation process involves seven steps. 
Step 1 
Prepare the conceptual model for implementation. Resolve complex inheri- 
tance relationships, including key definitions, property definitions, incoming 
and outgoing arcs. 

8.4 Summary 
319 
Step 2 
Implement each asset type. This includes the asset's own and inherited 
properties. 
m Under XML Schema, use complex types (see Sections 8.2.3 and 8.2.4). All 
type definitions belonging to a given namespace can be stored within one 
type library document (see Section 8.2.5). 
m Under Relax NG, use grammars (see Sections 8.3.1 and 8.3.2). Implement 
each property and subproperty as a separate pattern. Each grammar should 
be stored in a separate file to allow for overriding each pattern later (see Sec- 
tion 8.3.3). 
Step 3 
Create separate schema documents for each business object--usually the top 
Level 2 Structures (see Sections 8.2.6 and 8.3.4). If a business object should con- 
tain assets from different namespaces and you are implementing under XML 
Schema, you must split the schema document into several documents---one for 
each namespace. 
Step 4 
Implement each asset (see Sections 8.2.6 and 8.3.4). Use the previous asset type 
definitions from step 2 as base types. 
n Under XML Schema, implement each asset as a global element. 
n Under Relax NG, implement each asset as a separate pattern. 
Within each business object schema, select the identifying asset as the root 
element. 
Step 5 
Implement primary keys (see Sections 8.2.6 and 8.3.4). Although not always 
needed for the validation of the single instance elements, explicit definition of 
primary (and foreign) keys can help suitable processors to check referential 
integrity between documents. Under XML Schema, the key clause can be used 
to declare keys. Since Relax NG does not provide a key concept of its own, the 
same (XML Schema) key clauses may be used under Relax NG, too, where they 
are treated as annotations. 
Step 6 
For arcs there are four possibilities: 
1. The arc carries a range attribute. In this case, the arc is treated like an arc 
to another business object (see case 4). 
2. The arc establishes the tree hierarchy within the business object. In this 
case, the target element is implemented as a child element of the arc ori- 
gin. This is done by referring to the global definition of the asset element. 

320 
Chapter 8 From Conceptual Model to Schema 
In case 1 and in the remaining cases, 3 and 4, a foreign key definition must 
be implemented as a child element of the arc origin (see Sections 8.2.6 and 
8.3.4). This key definition should contain an element for the role name (if any), 
an element for the target asset, and an xs.all (or rng:interleave) group con- 
taining the key fields of the arc target. The types of the foreign key fields should 
mirror the types of the primary key fields (except for type ID, which must be 
matched by IDREF). 
3. The arc runs against the tree hierarchy. In this case, the arc must be im- 
plemented as a cross-reference (see Sections 8.2.7 and 8.3.5). If possible, 
choose an implementation form that is compatible with DTD standards 
(ID/IDREF), as not all XML processors support the full key/keyref con- 
struct introduced by XML Schema. Only in this case, the key and key ref- 
erence definitions will be utilized for document validation. When imple- 
menting under Relax NG, you might want to include the XML Schema 
key and keyref clauses for documentation, as Relax NG does not have a 
key concept of its own. 
4. Arcs that point to another business object cannot have a keyref definition, 
as this definition would not be able to refer to a key definition within the 
same schema. However, it makes sense to document the arc by including 
a suitable annotation. 
Arcs emanating from clusters are implemented in the same way, except that 
they form a choice group with the other cluster members (see Sections 8.2.9 
and 8.3.7). i s_a arcs are not implemented. 
Step 7 
In the final step, we take care of display labels. Under XML Schema, we use sub- 
stitution groups (see Section 8.2.8); under Relax NG, we use name classes (see 
Section 8.3.6). 
8.4.2 Remarks 
The example schemata shown in this chapter are directly derived from a nor- 
malized conceptual model in which the amount of redundant information has 
been minimized. Consequently, the instances of these schemata are not naviga- 
tional. For example, an a l bum instance does not contain information about the 
band that produced this album because this information is already contained in 
a band instance. Providing users with meaningful information, however, often 
requires including redundant information in a document (such as the name of 
the band that produced the album). Redundancy, on the other hand, makes 
updates to the document base complicated and error prone. 
The solution is not to present the documents in their raw form to the user, 
but to provide "cooked" views of the document set. Such views can combine 

8.4 Summary 
321 
information from several document types (in our example, from album and band) 
in a new document type. Such views can be produced with various means, such 
as a Java servlet, an XSLT stylesheet, or an XQuery [Boag2002] expression, and 
typically require that the document base is stored in a database. In our jazz 
knowledge base, for example, we would have to find the band instance that 
refers to a given album in its resul t element. A database system would allow us 
to index the resul t elements of band and thus to quickly retrieve matching band 
documents. The primary and foreign key definitions that we have created in the 
various schemata are good clues for a database system as to which document 
elements should be indexed. 
We should also not mistake the elements derived from conceptual arcs for 
navigational links (for example, the result element in band, which identifies an 
a l bum). Although the navigational structure of a document base can be derived 
from the conceptual structure, it usually differs from the latter. For example, the 
navigational structure of our Jazz model would also contain reversed arcs (such 
as from a l bum to band) and shortcuts. We might like to have hyperlinks from a 
jazzMusician instance to all album instances to which the musician has con- 
tributed. In many cases we would not want to insert these navigational struc- 
tures into the original documents but, rather, keep them in separate documents, 
such as an XLink linkbase or a topic map [Daum2002], for easy maintenance. 
The arcs of the conceptual model serve as a basis from which such documents 
can be derived. 


9.1 
9.2 
9.3 
9.4 
9.5 
9.6 
About Meaning 
Constraints 
Constraints in 
Conceptual Models 
Validation of General 
Constraints 
An XML Processing 
Model 
A Framework for 
Schema Languages 
I 
n this chapter we look over the fence of pure structural docu- 
ment validation. Although XML Schema does allow us to de- 
fine constraints that refer to the content of elements of attributes 
in the form of simple data types, there are many aspects of 
semantic integrity that cannot be covered in this way. 
The chapter discusses various methods for modeling and 
implementing advanced semantic constraints, such as cross-field 
and cross-document constraints. The classical method is to hard- 
code constraints using imperative programming with program- 
ming languages such as Java, C++, or Perl. Alternatively, it is 
possible to soft-code constraints as rules in the form of XSLT 
stylesheets or as Schematron schemata. 
In all these methods, XPath plays a pivotal role as a common 
language to formulate constraints, one reason to adopt XPath for 
the conceptual model as well. In particular, the emerging XPath 
2.0 specification [Berglund2002], with its support for XML 
Schema data types, looks very promising. 
With this abundance of schema languages and validation 
methods, we analyze the individual steps during the validation of 
a document and how the various schema languages cover them. 
The last section discusses a current standardization effort for the 
integration of these diverse approaches to schema validation. 
323 

324 
Chapter 9 Validation beyond XML Schema 
9.1 ABOUT MEANING 
When XML became popular, one naYve opinion was that--in contrast to 
HTML--XML documents would express meaning, which would allow semantic 
processing of documents. This opinion was based on the fact that tags in XML 
documents are like spoken language--that is, they transfer the meaning of an 
element to the human reader. However, nothing stops a schema author from 
naming a field for body height with a <sa] ary> tag. No XML processor would 
complain, and human readers would be completely misled. This is in contrast 
to HTML or XML-based application languages, such as SVG, SMIL, and many 
others, where the meaning of tags is clearly described in the language defini- 
tion, and processors implement the desired behavior. In HTML, for example, 
the tag <B> has a clear meaning: The content of the element is to be printed in 
bold typeface. Tags in XML do not have predefined semantics--actually, the 
XML specification does not define specific tags at all. The same applies for 
attribute names, with a few exceptions. There are a few predefined attribute 
names in XML, such as xm] :]ang and xmlns, that, indeed, have clearly defined 
semantics. 
To attribute XML tags with meaning requires extra effort beyond the defini- 
tion of XML schemata. The buzzword is ontologies. An ontology is composed of 
a vocabulary and additional formal means to describe the semantic relation- 
ships between the members of the vocabulary, such as thesauri, semantic net- 
works, constraint systems, and axioms. Ontologies are one subject of the 
standardization efforts of the W3C activity "Semantic Web" but also of stan- 
dardization efforts such as ebXML. Here, the discussion will be restricted to con- 
straints. For a detailed discussion of ontologies, see [Daum2002]. 
The fact that an XML schema does not associate individual tags with a spe- 
cific meaning should not lead us to the conclusion that the same is true for the 
whole document. The next section will show that an XML schema imposes a set 
of constraints on the set of instance documents, and thus indeed defines a lim- 
ited amount of formal semantics for those documents. Additional semantics 
can be specified for documents by using methods for constraint definition 
beyond XML Schema, such as the Schematron (see Section 9.4.3). And, of 
course, general semantics can be specified via XML processing instructions (see 
Section 4.2.5) or appinf0 elements (see Section 6.3.7), which bind a document to 
a given application. 
9.2 CONSTRAINTS 
Apart from the definition of vocabularies and thesauri that can provide a base 
for understanding the meaning of tags, constraints are an important concept in 
the definition of formal semantics. This can be explained with a concrete exam- 

9.2 Constraints 
325 
ple. Assume that we have a document containing the attribute duration in an 
element track: 
<track durati on=" PT5M33.3S"/> 
A human reader (who is acquainted with the ISO notation of time periods) 
can indeed derive some meaning from this element instance. For a nonvalidat- 
ing XML parser, however, this element instance does not transmit any mean- 
ing. All the parser can recognize is that "track" is the element name, "duration" 
is an attribute name, and "PT5M33.3S" is a string value associated with this 
attribute name. 
The picture changes when we define a schema for this element and make 
this schema accessible to an XML processor: 
<xs: el ement name="track"> 
<xs: compl exType> 
<xs:attribute name="duration" use="optional"> 
<xs:simpl eType> 
<xs:restriction base="xs: durati on"> 
<xs:maxlncl usive val ue="PT25M"/> 
<xs:minlncl usive val ue="PTIOS"/> 
</xs: restri cti on> 
</xs: s impl eType> 
</xs :attribute> 
</xs: compl exType> 
</xs :el ement> 
A validating processor that has access to this schema might gain some intel- 
ligence from it: 
[] First, it learns that the attribute value is of type duration and can interpret it 
accordingly. Because duration values are ordered, it can compare the dura- 
tion values of document instances with each other. 
[] Second, it learns the upper and lower bounds of the duration value and can 
come to the conclusion that the value in the instance is not exceedingly 
small or exceedingly large. 
The concept of constraints is not restricted to single values. In fact, a schema 
is nothing but a huge constraint itself. It constrains the set of valid documents 
to a subset of the alphabet's powerset (see Section 1.5). Even if the schema only 
imposed structural constraints, we could still get certain useful semantic infor- 
mation from this. Take for example the following schema definition: 

326 
Chapter 9 Validation beyond XML Schema 
<xs : el ement name="doc"> 
<xs: compl exType> 
<xs:all> 
<xs :el ement name="a"/> 
<xs :el ement name="b"/> 
<xs: el ement name:"c"/> 
</xs:all> 
</xs: compl exType> 
</xs: el ement> 
This schema allows elements a, b, and c to appear in any order within d0c. Now 
compare it with the following structure: 
<xs :element name="doc"> 
<xs: compl exType> 
<xs:sequence> 
<xs :element name="d"> 
<xs: compl exType> 
<xs: sequence> 
<xs :element name="a"/> 
<xs :element name="b"/> 
</xs : sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs: element name="c"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
From this schema we can learn that the elements a and b obviously have a 
closer relationship with each other than a and c or b and c. We are also told that 
sequence matters: b must follow a, and c must follow d, which unites a and b 
into a substructure. This schema does not inform us about the concrete seman- 
tics of the document instances; however, given that schema, we learn some 
semantic aspects about the document instances, such as the relationships 
between document elements. It is exactly this semantic aspect that gets lost 
when we flatten a complex structure into the relational First Normal Form to 
store it in a relational database. 

9.2 Constraints 
327 
Section 9.2.2 gives a practical example of how such structural constraints can 
be used to express semantic relationships between two document nodes. 
9.2.1 Constraints in XML Schema 
Apart from document structure, XML Schema allows us to define additional 
constraints for document instances: 
m Data types. In contrast to DTDs, which provide only a few basic data types for 
attributes, XML Schema allows us to constrain both leaf elements and 
attributes with a large variety of simple data types. A hierarchy of built-in 
data types and a rich set of facets to construct additional data types with the 
help of constraining facets, list extension, and type union allow us to con- 
strain element and attribute content in nearly any imaginable way (see Sec- 
tion 5.2.5). 
[] Uniqueness and cross-references. XML Schema refines and extends the cross- 
referencing concept found in DTDs. The unique, key, and keyref constructs 
complement the ID and IDREF data types known from DTDs (see Section 
4.4.4). The cross-reference constraints are cross-field constraints, because 
they relate the contents of one document node instance to the contents of 
another. 
As an example, we look again at the schema album from Section 8.2.7, along 
with its diagram, in Figure 9.1 (page 328). This schema already defines some 
cross-references, but it has been extended with additional constraints. 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema attributeFormDefaul t="unqual ified" 
e I ement FormDefau I t ='' qua I i fled" 
targetNamespace=" http 9 
jazz. org/encycl opedi a" 
xml ns=" http'//www, jazz. org/encyc I opedi a" 
xml ns-xs ='' http-//www, w3. org/2001/XMLSchema" 
xml ns" xsg=" http 9 
aomodel i ng. org/KLEEN/XSDgenerator"> 
<xs" i ncl ude schemaLocat i on="www_j azz_org_encycl opedi a_TYPELI B. xsd"/> 
<!--Asset album--> 
<xs.el ement name="al bum"> 
<xs 9 
compl exType> 
<xs: compl exContent> 
<xs" extens i on base="al bum_type"> 
<xs .sequence> 
<xs'element maxOccurs="unbounded" ref="track"/> 
<xs. el ement maxOccurs="unbounded" mi nOccurs="O" ref=" sampl e"/> 

328 
Chapter 9 Validation beyond XML Schema 
Figure 9.1 The structure of schema album.xsd. 
<xs'element maxOccurs="unbounded '' minOccurs="O" ref="plays"/> 
</xs .sequence> 
</xs "extension> 
</xs. compl exContent> 
</xs" compl exType> 
<xs'unique name="unique track title"> 
w 
<xs ~ selector xpath="./track"/> 

9.2 Constraints 
329 
<xs:field xpath="ti tl e"/> 
</xs.unique> 
0
o
o
 
<xs" key name="pk track_trackNo"> 
<xs.sel ector xpath=" ./track"/> 
<xs.field xpath="@trackNo"/> 
</xs.key> 
</xs. el ement> 
<I --Asset track--> 
<xs" el ement name="track" type="track_type"/> 
<!--Asset sample--> 
<xs" el ement name=" samp I e"> 
<xs 9 
compl exType> 
<xs" compl exContent> 
<xs "extensi on base="sampl e_type"> 
<xs "sequence> 
<xs" el ement name="track"> 
<xs 9 
compl exType> 
<xs'attri bute name="trackNo" type="xs" IDREF"/> 
</xs" compl exType> 
</xs" el ement> 
</xs .sequence> 
</xs .extension> 
</xs 9 
compl exContent> 
</xs 9 
compl exType> 
<xs" keyref name="fk 
sample_track" refer="pk 
track_trackNo"> 
<xs'sel ector xpath=" ./track"/> 
<xs-field xpath="@trackNo"/> 
</xs 9 
keyref> 
</xs" el ement> 
<I--Asset plays--> 
o l e  
</xs'schema> 
This schema defines a cross-field constraint by means of XML Schema. For 
each track referenced in a sample/track/@trackNo attribute, there must exist a 

330 
Chapter 9 Validation beyond XML Schema 
track element with a corresponding album/track/@trackNo attribute. As shown 
above, this sort of constraint can be easily implemented with XML Schema. 
Note that we have applied this constraint to derived types. The definition 
of sample/track/@trackN0 is contained in sample_type, while the definition of 
album/track/OtrackNo is contained in track_type. The introduction of such a 
cross-field constraint to the album schema effectively sub-types the album element 
type. 
We have added another constraint, too. We wanted to ensure that every 
track has a different title. We can define this constraint with the help of the 
unique clause as shown above. Note that this is a cross-field constraint, too, as it 
relates different a l bum/track/ti t le element instances to each other. 
9.2.2 Constraints beyond XML Schema 
The constraining power of XML Schema ends when it comes to general cross- 
field constraints or even cross-document constraints. 
Cross-Field Constraints 
Let's return to our jazz example. There are a few properties that are good candi- 
dates for cross-field constraints. Take for example the definition of type peri 0d- 
Type, which is used in several schemata: 
<xs- compl exType name="peri od_type"> 
<xs: sequence> 
<xs" el ement name=" from" type="xs: gYear"/> 
<xs:element name="to" type="xs'gYear" minOccurs="O"/> 
</xs -sequence> 
</xs. compl exType> 
What immediately springs to mind is that the value of the from element must be 
smaller than or equal to the value of the to element if it exists. However, there 
is no way to define this in XML Schema. 
For another example let's return for a moment to our album schema from the 
previous section. There is one more thing that we want to constrain: the total 
duration of an album. We want to restrict the sum of all track durations by an 
upper limit, let's say 240 minutes. Again, this constraint is impossible to express 
in XML Schema. (Section 9.4 discusses how we can validate such constraints.) 
But beware. Sometimes it is possible to express a constraint in XML Schema 
when it is not so obvious. Take for example the schema jazzMusician. During 
the modeling process we introduced a constraint: If a jazz musician is an instru- 
mentalist, he or she must play at least one instrument (see Section 3.6). In Sec- 
tion 8.2.4 we arrived at the following type definition for jazzMusician: 

9.2 Constraints 
331 
<xs" compl exType name=" j azzMus i c i an_type"> 
<xs" compl exContent> 
<xs. extensi on base="person_type"> 
<xs -sequence> 
<xs'element name="ki nd"> 
<xs "simpl eType> 
<xs-restriction base="xs -stri ng"> 
<xs'enumeration value="instrumental ist"/> 
<xs'enumeration val ue="jazzComposer"/> 
<xs -enumeration val ue="j azzSi nger"/> 
</xs" restri cti on> 
</xs 9 
simpl eType> 
</xs" el ement> 
<xs.element name="instrument" type="xs.token" 
mi nOccurs="O" maxOccurs="unbounded"/> 
</xs -sequence> 
</xs .extension> 
</xs. compl exContent> 
</xs" compl exType> 
This schema, of course, does not implement the above constraint. But we can 
try to express this constraint by means of XML Schema. 
We duplicate the sequence clause and place it into a ch0i ce clause. Within the 
first choice branch we restrict the possible values of kind to instrumental i st and 
set mi nOccurs-"l" for element instrument (we could also just drop the mi nOccuvs 
clause). In the second branch we restrict the values of kind to jazzComp0ser and 
jazzSi nger. 
<xs" compl exType name=" j azzMus i c i an_type"> 
<xs" compl exContent> 
<xs-extension base=" person_type"> 
<xs'choice> 
<xs 9 
sequence> 
<xs -el ement name="ki nd"> 
<xs 9 
simpl eType> 
<xs-restriction base="xs "stri ng"> 
<xs'enumeration value="instrumental ist"/> 
</xs- restri cti on> 

332 
Chapter 9 Validation beyond XML Schema 
</xs : s impl eType> 
</xs: el ement> 
<xs: el ement name=" i nstrument" type="xs: token" 
mi nOccurs="1" maxOccurs="unbounded"/> 
</xs: sequence> 
<xs :sequence> 
<!-- This violates the Unique Particle Attribution 
constraint! --> 
<xs:el ement name="ki nd"> 
<xs: simpl eType> 
<xs:restriction base="xs: string"> 
<xs: enumerat i on val ue="j azzComposer"/> 
<xs :enumeration val ue="j azzSi nger"/> 
</xs: restri cti on> 
</xs: s impl eType> 
</xs: el ement> 
<xs: e I ement name=" ins t rument" type= "xs: token" 
mi nOccurs="O" maxOccurs="unbounded"/> 
</xs :sequence> 
</xs:choice> 
</xs :extension> 
</xs: compl exContent> 
</xs :compl exType> 
Well, this failed. Expressing the constraint 
kind i= "instrumentalist" or count(instrument) > 0 
by means of type restriction and structure resulted in a nondeterministic 
schemamthe schema does not satisfy XML Schema's Unique Particle Attribu- 
tion constraint. Each branch of the ch0i ce clause begins with an element named 
ki nd. To decide which branch to take, the parser would have to look ahead into 
the content of each kind element and check the content against the respective 
type definition. So this schema is wrong! 
The same schema translated to Relax NG, however, would be correct. Relax 
NG does not require nondeterministic content models: 
<rng :grammar xml ns: rng="http://rel axng .org/ns/structure/1.0" 
xml ns="http://www, j azz. org/encycl opedi a" 
ns=" http://www, jazz. org/encyc I opedi a" 
datatype L i brary=" htt p://www, w3. org/2001/XMLSc hema-datatypes "> 

9.2 Constraints 
333 
<rng" i ncl ude href="person_type, rng"/> 
<rng.define name="jazzMusi ci an_type"> 
<rng'el ement name="j azzMusi ci an"> 
<rng. ref name="person_type"/> 
<rng'choice> 
<rng'group> 
<rng'el ement name="ki nd"> 
<rng" val ue>i nstrumental i st</rng 9 
value> 
</rng .el ement> 
<rng" oneOrMore> 
<rng" ref name="plnstrument"/> 
</rng 9 
oneOrMore> 
</rng:group> 
<rng'group> 
<rng'el ement name="ki nd"> 
<rng'choice> 
<rng 9 
val ue>j azzComposer</rng: val ue> 
<rng" val ue>j azzSi nger</rng 9 
value> 
</rng-choice> 
</rng'el ement> 
<rng" zeroOrMore> 
<rng" ref name="plnstrument"/> 
</rng" zeroOrMore> 
</rng'group> 
</rng'choi ce> 
</rng:el ement> 
</rng-define> 
<rng "define name="pl nstrument"> 
<rng 9 
el ement name:"i nstrument"> 
<rng'data type="token"/> 
</rng'el ement> 
</rng'define> 
</rng- grammar> 
In XML Schema a solution for this problem would be to define the type 
jazzMusician_type 
as 
abstract, 
to 
derive 
types 
intrumenta]ist_type, 

334 
Chapter 9 Validation beyond XML Schema 
jazzComposer_type, and jazzSinger_type from this abstract type, and to use the 
xsi .type mechanism (see Section 6.2.4) to instantiate the abstract type in the 
document instance: 
<xs'complexType name="jazzMusician_type" abstract="true"> 
<xs" compl exContent> 
<xs" extensi on base="person_type"> 
<xs" sequence> 
<xs. el ement name="i nstrument" 
type="xs 9 
token" 
mi nOccurs:"O" 
maxOccurs="unbounded"/> 
</xs 9 
sequence> 
</xs :extension> 
</xs" compl exContent> 
</xs: compl exType> 
<xs. compl exType name="i nstrumental i st_type"> 
<xs" compl exContent> 
<xs: restri cti on base="jazzMusi ci an_type"> 
<xs: sequence> 
<xs" el ement name=" instrument" 
type="xs .token '' 
minOccurs="l" 
maxOc c u rs = "u n bou n ded "/> 
</xs "sequence> 
</xs" restri cti on> 
</xs" compl exContent> 
</xs" compl exType> 
<xs'compl exType name="jazzSi nger_type"> 
<xs" compl exContent> 
<xs" extens i on base =''j azzMus i c i an_type"/> 
</xs" compl exContent> 
</xs: compl exType> 
<xs.compl exType name="jazzComposer_type"> 
<xs" compl exContent> 
<xs" extens i on base="j azzMus i c i an_type"/> 
</xs. compl exContent> 
</xs" compl exType> 

9.2 Constraints 
335 
Document instances of jazz musicians must now specify a concrete type 
using the xsi: type notation. This is also the reason why we were able to omit 
the element kind: The kind of jazz musician is sufficiently described via the 
xs i" type attribute. 
<?xml version="1.0" encoding="UTF-8"?> 
<j azzMus i ci an xml ns="http 9 
azz. org/encycl opedi a" 
xml ns" xs i =" ht tp'//www, w3. org/2001/XMLSc hema- ins tance" 
xs i" schemaLocat i on=" http'//www, j azz. org/encycl opedi a 
../schemata/j azzMusi ci an. xsd" 
xs i 9 
type=" i nstrumenta I i st_type"> 
<ID>jarrettKei th</ID> 
<name> 
<first>Kei th</first> 
<I ast>jarrett</l ast> 
</name> 
<b i rthDa te> 1945-05- 08</b i rthDa te> 
<i nstrument>pi ano</i nstrument> 
<produces> 
<al bum> 
<pub l i sher>http'//www, ecmrecords, com</publ i sher> 
<product No> 1064</product No> 
</album> 
</produces> 
</jazzMusician> 
Cross-Document Constraints 
Cross-document constraints are constraints that involve multiple documents, 
even documents from different document types. Typically we have four types: 
[] Uniqueness constraints. A document that has an identifying primary key may 
have the constraint that there is only one document with that key value. For 
example, if we have a jazzMusician document with an ID value of "Bley- 
Carla," we don't want to have other documents with the same ID value 
around. 
[] Referential integrity constraints. A document can rely on the fact that other 
documents to which it refers exist. For example, a band document 
"ArtEnsembleOfChicago" may rely on the presence of jazzMusician docu- 
ments for the musicians collaborating in the band: "BowieLester," "Mitchell- 
Roscoe," "JarmanJoseph," "FavorsMalachi," and "MoyeDon." 

336 
Chapter 9 Validation beyond XML Schema 
[] Cardinality constraints. Given that a document relies on the existence of other 
documents, it may require that a certain number of those documents exist. 
Take for example the documents band, jamSessi0n, project. All these collabo- 
rations refer to at least two jazzMusician documents. Otherwise we could 
hardly speak of collaboration 
However, this constraint type can be expressed with a normal cardinality 
constraint for the document node that implements the foreign key. Thus, we 
can express the cardinality constraint by means of XML Schema, and refer- 
ential integrity does the rest. In Section 8.2.8 the above relationship was ex- 
pressed with 
<xs.el ement name="j azzMusi ci an" 
mi nOccurs="2" maxOccurs="unbounded"> 
<xs "annotation> 
<xs. documentati on> 
refers to key pkmjazzMusician_ID in schema jazzMusician.xsd 
</xs. documentat i on> 
<xs'appinfo> 
<xsg: refersToSchema xl ink'href="jazzMusician.xsd" 
xl i nk: type=" s impl e" 
xml ns. xl ink=" http 9 
w3. org/1999/xl i nk" 
keyName="pk j azzMus i ci an_l D"/> 
</xs. appi nfo> 
</xs "annotation> 
<xs: comp I exType> 
<xs. al I> 
<xs'element name="ID" type="xs'NMTOKEN"/> 
</xs.all> 
</xs" compl exType> 
</xs "el ement> 
What remains is to check the referential integrity for each jazzMusician 
element. 
m General constraints. There may be additional semantic relationships between 
different documents. For example, the peri0d/fr0m date in the band or project 
document or the time date in a jamSessi0n document should not be smaller 
than the birth date of the jazz musicians collaborating in such a band, 
project, or jam session. 
While cross-field constraints are relatively easy to validate (as we will see in 
Section 9.4), the same cannot be said for cross-document constraints. In rela- 
tional databases, in contrast, constraints across multiple tables are not a big 

9.3 Constraints in Conceptual Models 
337 
issue. SQL provides the necessary means to check these constraints, such as 
integrity rules and triggers (see Section 11.9). 
That the situation with XML documents is different has nothing to do with 
the inherent properties of XML. What makes the validation of cross-document 
constraints difficult is not XML by itself but the fact that XML is used in a dif- 
ferent scenario. In general, we cannot make a closed world assumption for a set 
of XML documents as we can for a relational database. Instead, we can expect 
that the documents will be distributed across several servers, even the whole 
Internet. Some of these servers may be mobile, and not all may be accessible at 
a given time. This makes it practically impossible to maintain referential integ- 
rity and other cross-document constraints at all times. The all too familiar 404- 
response code for dangling hyperlinks in HTML documents illustrates this 
situation. So, in many cases it will be necessary to replace the traditional cross- 
document constraint validation, which is executed before a document is stored 
or updated, with a process of synchronization and repair that is applied after a 
document has been stored. 
9.3 CONSTRAINTS IN CONCEPTUAL MODELS 
Defining constraints in a conceptual model requires a constraint definition lan- 
guage. Several formal constraint definition languages have been defined in the 
past. Most of these languages never left the academic sphere. Adoption in the 
industry has been poor because the formalism of these languages makes them 
difficult for industry programmers and designers to read. A specification lan- 
guage that is not understood by programmers is worse than an informal specifi- 
cation of constraints in natural language. 
This is one reason for the definition of the Object Constraint Language (OCL), 
which has been part of the Unified Modeling Language (UML) since UML 1.1. 
There is a need to describe additional constraints about the objects in the model. 
Such constraints are often described in natural language. Practice has shown that 
this will always result in ambiguities. In order to write unambiguous constraints, so- 
called formal languages have been developed. The disadvantage of traditional for- 
mal languages is that they are useable to persons with a strong mathematical 
background, but difficult for the average business or system modeler to use. 
[0CL1997] 
However, OCL is also not widely adopted. The tool support for OCL is patchy 
at best. One notable exception is a recent open source CASE tool, ArgoUML 
(argouml.tigris.org), and its commercial offspring, Poseidon (www.gentleware 
.corn). Both include an OCL-to-Java compiler. 
What makes the situation even more difficult for our purposes is that OCL is 
designed for object-oriented design methods and object-oriented implementa- 
tions. OCL was not really designed with the document data model in mind. 

338 
Chapter 9 Validation beyond XML Schema 
That can make the definition of constraints for document-centric models 
difficult. Therefore, the following sections concentrate on the use of XPath 
[Clark1999] as a constraint language. This choice has several advantages: 
[] Document designers, stylesheet editors, and programmers familiar with XML 
know XPath well. 
[] XPath constraints can be easily translated into XSLT stylesheets or Schema- 
tron schemata (see Section 9.4.2), which can be used to validate documents. 
[] XPath is sufficiently powerful to express arbitrary constraints. Although 
XPath 1.0 does not support XML Schema data types (for example, compari- 
son of date and time values), XPath 2.0 will offer full support. 
The following example shows how to formulate constraints with XPath in an 
AOM conceptual model. AOM (see Chapter 2) is not limited to a single con- 
straint language but allows the use of arbitrary constraint languages, even 
mixed within one model. 
Now, let's see how we define a constraint for an asset property in AOM: 
m Properties in an asset are addressed with an XPath expression consisting of 
the name of the property. Subproperties specify the path of the subproperty 
relative to the asset, for example, name/] ast. 
[] Properties in other assets are addressed by including the arc leading to this 
asset in the XPath expression. If the arc has a role name, we include the 
role name in the path, too. For example, if we want to address the property 
publisher in asset album from asset project, we write result/album/publisher. 
Take for example the asset jamSession. We want to express the constraint that 
a jam session must not start before the birth date of a participating musician. 
We define the constraint within asset jamSession and do not specify an explicit 
context: 
not(time <= jazzMusician/birthDate) 
So, the context of this constraint defaults to jamSession, and time addresses 
property jamSession/time. The expression jazzMusician/birthDate addresses 
property birthDate in asset jazzMusician, which can be reached via an arc from 
asset jamSession. This arc has the cardinality constraint [2..*], and conse- 
quently this constraint must hold for at least two j azzMusician instances 
referred to by jamSession. 
Let's briefly discuss the various constraints defined in the example, shown in 
Figure 9.2. First, the asset period contains the constraint 
from <= to 
which defines that the beginning of a period must be smaller than or equal to 
the end. This constraint applies to the assets bel0ngsT0, style, project, and band 
because asset peri 0d is used in these assets as the type. 

9.3 
Constraints in Conceptual Models 
339 
Figure 9.2 The Jazz conceptual model with added constraints. 

340 
Chapter 9 Validation beyond XML Schema 
Asset person contains the constraint 
ID = concat (name/l ast,name/first[1]) 
This constraint postulates that the ID of a person must be obtained from the 
concatenation of its last name with the first occurrence of a first name. This 
constraint applies to both assets critic and jazzMusician because both inherit 
from person via the i s_a relationship. 
Next, the asset jazzMusi ci an contains the constraint 
kind ! = "instrumentalist" or count(instrument) > 0 
This constraint specifies that an instrumentalist must play at least one instru- 
ment. As already pointed out in Section 9.2.2, it is possible to model this con- 
straint completely by means of structure and type constraints. The conceptual 
model could reflect this by defining asset jazzMusician as 
( {instrumentalist} 
kind 
token instrument+ 
[ {jazzComposer,jazzSinger} kind 
token instrument* 
} 
However, the original definition with the added constraint has advantages in 
terms of readability. 
The two assets band and project contain the constraint 
not(period/from <= jazzMusician/birthDate) 
This constraint makes sure that the beginning of the period during which a 
band or project exists is greater than the birth date of each participating musi- 
cian. period/from refers to the subproperty from of property period. This sub- 
property is defined in the asset type period. Note that the simpler expression 
period/from > jazzMusician/birthDate 
is true when the birth date of at least one musician is greater than period/from. 
This is not what we want. In a similar way, the asset jamSession contains the 
constraint 
not(time <= jazzMusician/birthDate) 
which we have already discussed. 
Finally, the asset album contains the constraint 
sum(track/duration) 
<= PT4H 

9.4 Validation of General Constraints 
341 
This constraint states that the sum of all track/durati0n properties must be less 
than or equal to four hours. 
9.4 VALIDATION OF GENERAL CONSTRAINTS 
This section covers how constraints, as discussed in Section 9.3, can be imple- 
mented. By formulating constraints in XPath, we have the advantage of choices 
among several implementation options. 
9.4.1 Hard-Coded Constraint Checks 
One of the most commonly used methods for validating general constraints 
(which often appear in the form of Business Rules) is hard-coding them into 
the application logic. For example, in a Java application, the application code 
would parse the document instances into DOM trees, and then would test the 
DOM nodes for compliance with the constraints. 
An advantage to using XPath for constraint expressions is that these expres- 
sions can be used directly with newer DOM APIs, which can save a substantial 
amount of coding effort. The current working draft of the "Document Object 
Model (DOM) Level 3 XPath Specification" [Whitmer2002] defines an (optional) 
access layer to the document node via XPath expressions. This would allow us to 
address document elements directly with their path specification and formulate 
constraints as XPath filter expressions. For example, the constraint 
ID = concat(name/last,name/first[1]) 
could be tested with the following Java DOM call, 
if (!evaluate("ID = concat(name/last,name/first[l])", 
jazzMusician, null, XpathResult.BOOLEAN TYPE, null). 
m 
getBool eanVal ue() ) 
throw new ConstraintException("ID does not match name"); 
where jazzMusician represents the root node of a jazzMusician document. Note 
that this code is hypothetical, as the specification mentioned above is still a 
working draft. 
Current XPath processors usually come packaged within XSLT processors 
(because XPath was once a part of the XSL specification). However, there are 
also standalone XPath processors available, such as Jaxen (www. jaxen.org). An 
interesting development is also JXPath, which is part of Apache's Jakarta 
project. JXPath allows the use of XPath expressions to access Java data struc- 
tures (www.apache.org). 

342 
Chapter 9 Validation beyond XML Schema 
Things get a bit more complicated when we want to check cross-document 
constraints. The following Java code illustrates how the constraint 
not(time <= jazzMusician/birthDate) 
which checks between jamSession and jazzMusician, can be validated by using 
standard DOM Level 2 API access methods: 
public boolean checkEventDateVsBirthData(Document jamDoc) { 
// set result 
boolean result = true; 
// get a "time" element 
NodeLi st timeLi st = jamDoc.getEl ementsByTagName("time") ; 
Element startDateElement = (Element) timeList.item(O) ; 
// get start date value 
String startDateValue = getText(startDateElement) ; 
// convert to Date 
Date startDate = toDate(startDateValue); 
// Get jazzMusician elements 
NodeLi st musi ci ans = jamDoc.getEl ementsByTagName("jazzMusi ci an") ; 
// now loop over the "jazzMusician" children 
for (int i=O; i < musicians.getLength(); i++) { 
// get a single "jazzMusician" child 
Element oneMusician = (Element) musicians.item(i); 
// get the ID element 
NodeList ids = oneMusician.getElementsByTagName("ID") ; 
Element id = (Element) ids.item(O); 
// check if this item has content 
if (id.hasChildNodes()) { 
// get the string content 
String musicianID = getText(id); 
// Perform query for jazzMusicians identified by musicianID 
Document jazzMusicianDoc = 
performQuery ("j azzMusi ci an lID"+"=' "+musi ci an I D+" ']" 
if (jazzMusicianDoc == null) { 
System.out.println("Error: Referenced jazzMusician" 
+musicianID+" does not exist"); 
result = false; 
} else { 
// get birthDate 
NodeLi st bi rthDateLi st = 
j azzMus i ci anDoc, getEl ementsByTagName ("bi rthDate") 
Element birthDateElement = (Element) birthDateList.item(O) ; 
// get string value 

9.4 Validation of General Constraints 
343 
S t r i n g  birthDateValue = getText(birthDateE1ement); 
// convert t o  date 
Date b i  rthDate = toDate(bi rthDateVal ue) ; 
// compare with startDate 
i f  (startDate.compareTo(birthDate) 
<= 0) { 
// Report v i o l a t i o n  o f  i n t e g r i t y  constraint 
System. out. p r i  n t 1 n 
("Error: S t a r t  date before b i r t h  date o f "  
r e s u l t  = fa1 se; 
+ musicianID); 
1 
1 
I 
I 
r e t u r n  result; 
I 
// Convert XML date formats i n t o  Java Date object 
p r i v a t e  Date toDate(String s) throws java.text .ParseException { 
// determine formatting s t r i n g  
S t r i n g  f = (s.indexOf("T",O) 
>= 0 ? 
"Yyyy-MM-dd T HH : IIIII 
: s s 'I : 
// dateTime 
(s.indexOf(":", 
1) >= 0 ? 
// time 
"HH:mm:ss" 
: "yyyy-MM-dd")); 
// date 
// check f o r  e x p l i c i t  time zone 
i n t  p = Math.max (s.indexOf("+", 
8),s.indexOf("-". 
8)); 
i f  (p >= 0) { 
f += " z l ~ .  , // indicate time zone i n  formatting s t r i n g  
s = s. substri ng (0,p-l)+"GMT"+s. 
substri ng(p) ; 
// keep Simp1 eDateFormat happy 
1 
else i f  (s.charAt(s.length()-1) 
== Z) { 
// check f o r  UTC time zone 
f += "z". 
s = s.substring(O,s.length()-1) 
+ "UTC"; 
I 
1 
// create SimpleDateFormat object 
SimpleDateFormat d f  = new SimpleDateFormat ( f ); 
// and use i t  as a parser 
r e t u r n  df.parse(s) ; 
I 
The method tollate() is required to convert the xs:date or xs:dateTime for- 
mats into java.uti1 .Date objects. 

344 
Chapter 9 Validation beyond XML Schema 
What is not shown here is the implementation of the method perform- 
Query(). This method is used to fetch documents by key. The implementation of 
this method depends, as a matter of fact, on the storage medium: relational 
database, native XML database, file system, and so on. 
9.4.2 XSLT 
The advantage of such hard-coded constraints lies in performance benefits. The 
disadvantage, however, is that the change of a constraint requires rebuilding 
the application (at least to recompile all classes that implement this constraint). 
The alternative is to soft-code constraints. This can be done by writing an XSLT 
stylesheet [Clark1999a] that validates the document instances. Again, the use of 
XPath for constraint expressions has an advantage here: XSLT is based on 
XPath--both were once parts of the XSL specification. Running such an XSLT 
stylesheet against a document instance could result in another XML document 
containing an error report on which constraints have been violated. 
The following stylesheet checks instances of the a l bum schema (see Section 
8.2.7) for the constraint 
sum(track/duration) <= PT4H 
I have deliberately chosen this constraint because it presents a problem. 
PT4H is an expression that is not understood by XPath 1.0 or XSLT 1.0, as 
neither specification supports XML Schema data types. We have the option 
of either using an XSLT extensionmfor example, one provided by EXSLT 
(www.exslt.org)--or waiting for the first XPath/XSLT processors supporting XML 
Schema data types. XPath 2.0 [Berglund2002] will support XML Schema data 
types, and so will XSLT 2.0 [Kay2002]. 
The other option would be to fall back to pre-XML Schema times and express 
the duration in seconds. Then the constraint would look like this: 
sum(track/duration) <= 14400 
But let's assume we already have an XSLT 2.0 processor. We create a little 
stylesheet to implement the above constraint. (For an introduction to XSLT, see 
[Kay2001].) First, we set up the namespaces for XSLT and for the Jazz model. For 
the Jazz model namespace we use j: as a prefix. We have also set up a name- 
space prefix xf: for XPath and XQuery Functions, which are needed to define a 
literal of type xs:duration. 
<xs I :styl esheet xml ns :xs I ="http://www. w3. org/1999/XSL/Transform" 
xml ns :j =" http://www, jazz. org/encyc I opedi a" 
xml ns: xf=" http://www, w3. org/2OO2/O4/xquery- funct ions" 
vers i on: "2.0"> 
<!-- XSLT 2.0 required! --> 

9.4 Validation of General Constraints 
345 
<xsl :template match="/"> 
<xsl :apply-templates/> 
</xsl :template> 
<xsl :template match="j :album"> 
<probl ems> 
<xsl :attribute name="album"> 
<xsl :value-of select="j:title"/> 
</xs I : attri bute> 
<xsl:if test="sum(j:track/j:duration) 
> xf:duration('PT4H')"> 
<xsl:text>Total track duration exceeds 4 hours: </xsl:text> 
<xsl :value-of select="sum(j :track/j :duration)"/> 
</xsl :i f> 
</problems> 
</xsl :template> 
</xsl : styl esheet> 
The first template is the document node template and simply directs tem- 
plate processing to its child elements (which is the album element). 
The second rule matches the context a l bunv--that is, the root element of album 
instances. It contains an <xsl :if> clause, which checks the constraint. Because 
we want to produce output when the constraint fails, the test clause contains 
the Boolean negation of the constraint: 
sum(j:track/j:duration) 
> xf:duration('PT4H') 
The expression xf: durat i on (' PT4H' ) constructs a literal of type xs: durat i on with 
the specified value. The rest is just producing meaningful output. 
Now we run the following document through this stylesheet: 
<?xml version="1.0" encoding="UTF-8"?> 
<album xml ns="http://www.jazz.org/encyclopedia" 
xml ns: xs i =" ht tp://www, w3. org/2001/XMLSchema- i ns tance" 
xs i : schemaLocat i on="../schemata/al bum. xsd"> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<product No> 1780</p rod uc t No> 
<title>Inside out</titl e> 
<track trackNo="tl"> 
<title>From The Body</title> 
<durat i on>PT iH</durat i on> 
</track> 

34145 
Chapter 9 Validation beyond XML Schema 
<track trackNo="t2"> 
<title>Inside Out</titl e> 
<durat i on>PT iH</du rati on> 
</track> 
<track trackNo="t3"> 
<title>341 Free Fade</title> 
<durat i on>PT iH</durat i on> 
</track> 
<track trackNo="t4"> 
<t i t I e>Ri ot</t i t I e> 
<durati on>PTIH</durati on> 
</track> 
<track trackNo="t5"> 
<title>When I Fall In Love</title> 
<durati on>PTiH</durati on> 
</track> 
</album> 
If our document instance contains tracks with a total duration longer than four 
hours, the following output document is produced: 
<?xml version="1.0" encoding="utf-8"?> 
<problems xmlns:j="http://www.jazz.org/encyclopedia" 
al bum="Inside out"> 
Total track duration exceeds 4 hours: xf:duration('PT5H') 
</problems> 
The next example shows how to check constraints across documents. To do 
this, we make use of the XSLT document() function. We use XSLT 1.0 here 
despite the fact that XML Schema data types are involved. But first we have to 
explain how to address a document by key. When our documents are stored in 
a database system, retrieving a document by key is usually an efficient opera- 
tion. Database systems can construct indexes and allow for searching data 
objects by key via an index. 
The way such a query is passed to the database systemmin particular within 
the parameter of the document() functionmdepends on the database system 
used. For example, a database system may require that the database is specified 
by URL and the document type and key are specified in the query part of the 
string. A query may consist of the following URL: 
http://www, j azzserver, org/encyc I opedi a?j azzMus i c i an [ I D=' Peacoc kGary ' ] 

9.4 Validation of General Constraints 
34/ 
However, the format of database access is currently not standardized in any 
way, and different database systems may use different formats. The format used 
here is that of the native XML database Tamino (www.soflwareag.com). Here, we 
assume that all XML files are stored in a plain file system, and that the file name 
is constructed from the name of the document type and the key, such as 
jazzMusician PeacockGary.xml 
m 
and this is what we pass to the document () function. 
The constraint, which we implement in the following sty|esheet, is 
not(period/from <= jazzMusician/birthDate) 
Again, we first set up the namespaces and write the template for the document 
node: 
<?xml version:"1.0" encoding="utf-8"?> 
<xs I : styl esheet xml ns :xs I ="http://www. w3. org/1999/XSL/Trans form" 
xml ns :j =" http://www, jazz. org/encyc I opedi a" 
version="1.0"> 
<xsl :template match:"/"> 
<xsl :apply-templ ares/> 
</xsl :template> 
<xsl :template match="j :band"> 
<probl ems> 
<xsl : attribute name="name"> 
<xsl :value-of select="j :name"/> 
</xsl : attri bute> 
<xsl :apply-templates/> 
</problems> 
</xsl :template> 
<xsl .template match="j .jazzMusi ci an"> 
<xsl "choose> 
<xsl:when test = "document(concat('jazzMusician 
',j-ID,'.xml'))"> 
n 
<xsl'if test = 
"number(../j :period/j :from) &It;= 
number(substri ng (document (concat (' jazzMusi ci an ' ,j" ID,' .xml ' ) ) 
/*/j .bi rthDate, 1,4))"> 
Unborn band member <xsl.value-of select="j'ID"/> 
</xsl "if> 

348 
Chapter 9 Validation beyond XML Schema 
</xsl "when> 
<xsl .otherwise> 
Mi ssi ng document 
<xsl "value-of select="concat('jazzMusi cian_' ,j" ID, '.xml ')"/> 
</xsl" otherwi se> 
</xsl "choose> 
</xs I 9 
templ ate> 
<xsl :template match="*"> 
</xsl .template> 
</xsl : styl esheet> 
In the second template we prepare the output document and then apply 
templates to all child elements. This has the advantage of allowing us to process 
each jazzMusi ci an element individually, thus producing a detailed error report. 
The third template contains the actual constraint check. First, in the 
<xsl :choose> clause, we make sure that the referenced jazzMusician file really 
exists (we do a check for referential integrity). If not, we give an error message. 
Note that this does not work with all XSLT processors. Some processors may 
just throw an exception when the referenced document does not exist. When 
the document () function fails, an XSLT processor is free to throw an exception or 
to return an empty node list. The purpose of the <xsl: choose> clause is to catch 
the case of empty node lists. 
In case of success, the <xsl :if> clause performs the actual constraint check. 
Because the peri od/from element only contains the year, we also extract the year 
from the birth date delivered by the document () function. Since XPath 1.0 is not 
type aware, we use the number() function to convert both strings into a number 
before we compare them. The final template is used to override the built-in 
default clause and does nothing. 
9.4.3 Schematron 
The technique discussed in the previous section has been sophisticated by 
Schematron (http://www.ascc.net/xml/schematron). Schematron can be used inde- 
pendently or in conjunction with DTDs, XML Schema, and Relax NG. With 
Schematron, schema authors do not need to dig deep into XSLT but can formu- 
late constraints with XPath and a few additional statements. A Schematron 
schema can be formulated as a separate standalone document, or it can be 
embedded into XML Schema or Relax NG in the form of annotations. Valida- 
tors that are not Schernatron aware will ignore these statements, while Schema- 
tron processors can extract the embedded Schematron statements to process 
them. An interesting development is the Sun Multi-Schema XML Validator 

9.4 Validation of General Constraints 
349 
Schematron Add-on, which can process Relax NG schemata with embedded 
Schematron statements in one step. 
In the standalone form, the Schematron compiler translates the Schematron 
schema into an XSLT stylesheet and then utilizes the stylesheet to validate doc- 
ument instances. The Schematron compiler is actually implemented as an XSLT 
stylesheet, too. A Windows front end that streamlines this process is available at 
www.topologi.com. 
Schematron introduces a few of its own declarations: schema, phase, pattern, 
rule, assert, report, key, and diagnostics. Figure 9.3 (page 350) shows the meta- 
model of Schematron with all language elements. The clauses assert and report 
define single tests (a single constraint). These can be grouped together with the 
pattern clause. The phase clause is used to organize the workflow within a vali- 
dation suite. These declarations are covered briefly in the following pages. 
Schema 
The schema clause defines a Schematron schema. 
Name 
Attributes 
Contains 
schema 
id? 
title? 
fpi? 
ns* 
ns? 
p* 
defaul tPhase? 
phase* 
icon? 
pattern+ 
schema Version? 
p* 
di agnostics? 
Within the schema declaration, the definition of phase and pattern is essential. 
Patterns combine one or several assertion rules to a group. There must be at 
least one pattern group defined in a schema. Patterns are referenced by phases. 
Each phase element may refer to one or several patterns via child elements 
named act i re. Which phases are executed during a validation can be specified 
via parameters (such as command line parameters) when the validation sheet is 
executed against document instances. If no such phase is specified, the phase 
defined in attribute defaul tPhase is executed. If no such attribute is specified, all 
phases in the schema are executed. If no phases are defined in a schema, all pat- 
terns are executed. 
The functions of other child elements and attributes are as follows: 
m The child elements ti tl e and p serve documentation purposes, ti tl e con- 
tains the schema title, while p elements may contain marked-up content for 
further description. 
-, The ns child elements can be used to declare namespaces used in the docu- 
ment instance. The syntax is <ns prefix="prefix" uri="uri"/>. 

350 
Chapter 9 Validation beyond XML Schema 
f 
schema 
id? 
fpi? 
ns? 
icon? 
schemaVersion? 
title? 
ns(prefix, uri)* 
p(id?,class, icon?)* 
defaultPhase 
? 
active 
phase 
{id} 
id 
fpi? 
icon? 
p(id?,class, icon?)* 
1 
diagnostics 
pattern 
{name} 
name 
see? 
fpi? 
id? 
1 
icon? 
p(id?,class, icon?)* 
f 
l 
assert 
report 
assertion 
test 
role? 
id? 
icon? 
subject? 
(#PCDATA I name(path?) 
I emph I dir(value) I span(class?) )* 
[rule 
=i context? 
I abstract? 
I role? 
Lid? 
Iip ey 
name} 
ame 
ath 
con? 
diagnostic 
L_ 
{id} 
* 
id 
icon? 
(#PCDATA I value-of(select) 
I emph I dir(value) I span(class?) )* 
Figure 9.3 The metamodel of Schematron with all language elements. 
s 

9.4 Validation of General Constraints 
351 
[] The ns attribute can define a namespace for the vocabulary defining r0] e val- 
ues (see "Rule" section). 
[] The icon attribute may specify a URI pointing to an icon such as a GIF file. 
This will appear in the output document. 
[] The fpi attribute allows specifying an SGML Formal Public Identifier. 
[] Finally, there is a group of diagnostics. This is a set of detailed descriptions 
that explain the reason why a rule has produced a message. These diagnostics 
are referred to by assert and report clauses (explained below). The output of 
diagnostics is optional and can be set with a parameter before execution. 
Phase 
The organization into phases allows various validation sequences that are exe- 
cuted on different occasions to be combined into a single schema. The patterns 
to be checked in a phase are specified via the act i ve child elements. 
Name 
Attributes 
Contains 
phase 
id 
p* 
fpi? 
active* 
icon? 
Phases are used to organize the workflow. For example, we could have a 
phase that is executed when a new document instance is created, and another 
phase that is executed when a document instance is deleted. Another applica- 
tion for phases is to combine validation sequences for different purposes. One 
phase could check document instances for structure violations, another phase 
could check for best practices or corporate standards, and another could check 
for accessibility. Or, we could have different phases for new documents, draft 
documents, and final documents. 
Pattern 
pattern clauses combine one or several rules into one group. Patterns are 
referred to by phases. 
Name 
Attributes 
Contains 
pattern 
name 
p* 
see? 
rule* 
fpi? 
id? 
icon? 

352 
Chapter 9 Validation beyond XML Schema 
Patterns are named; the name is displayed with the produced message in the 
output document. The i d attributes may be used to identify a pattern. This 
value is specified by phase clauses via their act i ve child elements to list a pattern 
as active. The see attribute may point to additional documentation via a URL. 
Each pattern may list several rules to be executed. Which rule is executed 
depends on its context attribute (see "Rule"). The first rule with a matching con- 
text expression is executed; thereafter, the execution of the pattern stops. The 
context attribute consists of an XPath expression (XPath with the extensions 
defined in XSLT). 
Rule 
Rule clauses organize one or several constraints into one group. The context 
attribute controls the execution of the rule. 
Name 
Attributes 
Contains 
rule 
context? 
abstract? 
role? 
id? 
( assert I report I key I extends )+ 
Rules can be declared as abstract. In this case they are not executed but are 
only referred to by other rules to inherit their properties. This is done via the 
extends clause: <extends rule="rule-id">. Abstract rules cannot define a context 
attribute; the context is defined by the inheriting rules. 
The rol e attribute can be used by schema authors to classify or annotate the 
rule. The schema author may specify arbitrary values; a vocabulary can be 
defined with the ns attribute in the schema clause. The role attribute has no 
influence on the validation process. 
Each rule contains one or several assert, report, key, or extends clauses. 
Assert and Report 
Both assert and report clauses are structurally identical: 
Name 
Attributes 
Contains 
assert 
report 
test 
role? 
id? 
diagnostics? 
icon? 
subject? 
(#PCDATA I name I emph I dir I span)* 

9.4 Validation of General Constraints 
353 
The test attribute contains the XPath expression to be checked by the rule 
within the specified context. An assert rule will fire when the test fails, while a 
report rule will fire when the test succeeds. The effect is that the message speci- 
fied in the body of the clause is written to the output document. This message 
can be marked up with several tags (name, emph, di r, span): 
m The name clause can be used to insert variable content into the text: <name 
path="xpath-expression">. If path is omitted, it defaults to ". ", thus resulting 
in the current document node. 
[] emph, di r, and span have the same meaning as in HTML. 
Key 
The key clause exploits the key mechanism of XSLT within rules to check for 
cross-reference constraints. 
Name 
Attributes 
Contains 
key 
name 
path 
icon? 
The attribute name specifies the name of the key. path specifies an XPath 
expression identifying the document node constituting the key. Defined keys 
can be referred to from XPath expressions within a rule via the XSLT function 
key(name,value). But beware: Only a few XSLT processors, such as Saxon and 
MSXML, support the key construct. 
Diagnostics 
The diagnostics attribute may specify one or several IDs of diagnostic messages 
(see "Assert and Report") that further explain the reason why the rule fired. 
Name 
Attributes 
Contains 
di agnostics 
di agnosti c* 
Name 
Attributes 
Contains 
diagnostic 
id 
icon? 
(#PCDATA I value-of I emph I dir I span)* 
The di agnostics section contains a set of diagnostic messages. These are iden- 
tified by their i d and referred to by assert or report clauses. The body of a diag- 
nostic message contains text that can be marked up with val ue-of, emph, di r, or 
span. (val ue-of has the same meaning as in XSLT.) 

354 
Chapter 9 Validation beyond XML Schema 
$chematron Example 1 
The following example implements the constraint 
sum(track/duration) <= 14400 
Again, we specify the duration in seconds (integers) because XSLT 1.0, on 
which Schematron relies, does not support XML Schema data types. 
The schema contains only a single pattern and a set of diagnostics. There are 
no phases defined, so the only pattern is always executed when a document is 
validated by the schema. First, we declare the Schematron namespace as the 
default namespace, and a namespace prefix for our Jazz model. The latter is also 
defined in an ns child element. The xml ns :j attribute defines the namespace for 
the schema, while the ns child element defines the same namespace for the val- 
idation sheet generated from the schema. 
<?xml version="1.0 '' encoding="utf-8"?> 
<schema xmlns="http://www.ascc.net/xml/schematron" 
xml ns :j =" http://www, jazz. org/encyc I opedi a"> 
<title>Schematron for jazz album</title> 
<ns prefix="j '' uri="http://www.jazz.org/encyclopedia"/> 
<pattern name="al bum"> 
<rule context="j :album"> 
<assert test="sum(j:track/j:duration) &It; = 14400" 
di agnosti cs="durl dur2" 
i con="buglO, gi f"> 
Total album duration too long. 
</assert> 
</rule> 
</pattern> 
<di agnosti cs> 
<diagnostic id="durl"> 
Sum over track durations should not exceed 14400! 
</diagnostic> 
<diagnostic id="dur2"> 
The actual duration was 
<value-of select="sum(j :track/j :duration)"/>. 
</diagnostic> 
</diagnostics> 
</schema> 

9.4 Validation of General Constraints 
355 
Figure 9.4 Schematron output for example 1. 
The pattern contains a single rule with an assert clause. This clause sets up 
the context (root element album) and test for the constraint sum(track/durati0n) 
<= 14400. If this test fails, the message "Total album duration too long." is writ- 
ten to the output document. Since this assert clause refers to the diagnostic ele- 
ments durl and dur2, the messages defined in these elements will be written to 
the output document if the output of diagnostics was not suppressed. Also, an 
image pointer will be generated there because we have specified an icon. 
The output is produced as an HTML file and should look like Figure 9.4. 
$r 
Example 2 
The next example is our cross-document constraint: 
not(period/from <= jazzMusician/birthDate) 
The implementation with Schematron makes use of the fact that Schematron 
accepts the XSLT extensions to XPath, in particular the document () function. 
We have implemented two phases. The first phase checks only for referential 
integrity~that the jazzMusician document, to which band/jazzMusician/ID 
refers, exists. Note that, as above, depending on the XSLT processor used, an 
unresolved reference may abort the validation with an exception. 
The second phase checks the actual constraint. 
<?xml version="1.0" encoding="utf-8"?> 
<schema xml ns=" http://www, ascc. net/xml/schematron" 
xml ns :j =" http://www, jazz. org/encyc I opedi a"> 

356 
Chapter 9 Validation beyond XML Schema 
<title>Schematron for jazz band</title> 
<ns prefix:"j" uri:"http'//www.jazz.org/encyclopedia"/> 
<phase id="Referential "> 
<active pattern="integrity '' /> 
</phase> 
<phase id="Ful l"> 
<active pattern="birthDate" /> 
</phase> 
<pattern name="Referential Integrity" id="integrity"> 
<rule context = "j-band/j'jazzMusician"> 
<report test = 
"document (concat (' j azzMus i c i an_', j" I D,'. xml ' ) )/j azzMus i c i an" 
di agnost i cs=" col 1 "> 
Referenced document does not exist! 
</report> 
</rule> 
</pattern> 
<pattern name="Check birthDate" id="birthDate"> 
<rule context = "j.band/j'jazzMusician"> 
<report test = "number(../j'period/j.from) > number(substring 
(document (concat('jazzMusician ',j. ID, '.xml ')) 
/*/j : bi rthDate, 1,4) )" 
di agnosti cs="col 2"> 
Unborn band member! 
</report> 
</rule> 
</pattern> 
<diagnostics> 
<diagnostic id="col 1"> 
No document for jazz musician <value-of select="j.ID"/> was found. 
</diagnostic> 
<diagnostic id="col 2"> 
The birth date of jazz musician <value-of select="j.ID"/> was after the 
begin of the collaboration. 
</diagnostic> 
</diagnostics> 
</schema> 
Also in this case, it would be possible to embed the Schematron instructions 
into the XML Schema file for band, as discussed in the next section. 

9.4 Validation of General Constraints 
357 
Embedding $chematron into XML Schema 
One of the nice things about Schematron is that we can include the above con- 
straints as annotations in an XML Schema file. When this file is processed with 
the Schematron compiler, it will automatically harvest the Schematron state- 
ments from the annotation/appinfo elements. Here is the album schema from Sec- 
tion 8.2.7 with Schematron statements included: 
<?xml version="1.0" encoding="OTF-8"?> 
<xs" schema attri buteFormDefaul t="unqual i fled" 
e 1 emen t Fo rmDe fau 1 t = "qua 1 i fled" 
targetNamespace=" http'//www, j azz. org/encyc 1 opedi a" 
xml ns=" http.//www, jazz. org/encycl opedi a" 
xml ns" xs=" http'//www, w3. org/2001/XMLSc hema" 
xml ns- xsg=" ht tp'//www, aomode 1 i ng. org/KLE EN/XSDgenera tor" 
xml ns" sch="http.//www, ascc. net/xml/schemat ron"> 
<xs" annotati on> 
<xs.appinfo> 
<sch-title>Schematron for jazz album</sch-title> 
<sch-ns prefix="j" uri="http-//www.jazz.org/encyclopedia"/> 
</xs "appi nfo> 
</xs "annotation> 
<xs. incl ude schemaLocation="www.jazz.org_encyclopedi a_TYPELIB.xsd"/> 
<!--Asset album--> 
<xs'el ement name="al bum"> 
<xs-annotation> 
<xs-appinfo> 
<sch'pattern name="al bum"> 
<sch'rule context="j .al bum"> 
<sch-assert test="sum(j'track/j-duration) &It;= 14400" 
diagnostics="durl dur2" 
i con="buglO, gi f"> 
Total album duration too long. 
</sch:assert> 
</sch:rule> 
</sch :pattern> 
</xs :appinfo> 
</xs: annotati on> 
<xs: compl exType> 

358 
Chapter 9 Validation beyond XML Schema 
<xs" comp I exContent> 
<xs" extens i on base="al bum_type"> 
<xs .sequence> 
<xs.el ement maxOccurs="unbounded '' ref="track"/> 
<xs "el ement maxOccurs="unbounded" mi nOccurs="O" ref="sampl e"/> 
<xs'el ement maxOccurs="unbounded '' mi nOccurs="O '' ref="pl ays"/> 
</xs 9 
sequence> 
</xs .extension> 
</xs 9 
compl exContent> 
</xs 9 
compl exType> 
</xs" el ement> 
<!--Asset track--> 
e o e  
<!--Asset sample--> 
.
e
o
 
<!--Asset plays--> 
,
o
0
 
<xs" annotati on> 
<xs:appinfo> 
<sch-di agnostics> 
<sch'diagnostic i d="durl"> 
Sum over track durations should not exceed 14400! 
</sch 9 
di agnost i c> 
<sch:diagnostic id="dur2"> 
The actual duration was 
<value-of select="sum(j .track/j .duration)"/>. 
</sch" di agnost i c> 
</sch" di agnost i cs> 
</xs.appi nfo> 
</xs -annotation> 
</xs 9 
schema> 
To be consistent with the rest of the schema definition, we have here pre- 
fixed all Schematron element names with sch.. The default namespace is set to 

9.4 Validation of General Constraints 
359 
our jazz target namespace. However, the prefix j. must still be specified with an 
ns element to identify the jazz namespace to the resulting validation sheet. 
Embedding $chematron into Relax NG 
Embedding Schematron declarations into Relax NG is even simpler, and using 
the multi-schema validator mentioned earlier allows us to validate the com- 
bined schema in one step. The validator currently only supports the Schema- 
tron declarations rule, assert, and report. 
<rng.grammar xml ns" rng="http'//rel axng.org/ns/structure/1.0" 
xml ns=" http'//www, jazz. org/encyc I opedi a" 
xml ns" xs =" ht tp'//www, w3. org/2001/XM LSc hema" 
xml ns 9 
xsi =" http.//www, w3. org/2001/XMLSchema-i nstance" 
xml ns 9 
xsg="http 9 
aomodel i ng. org/KLEEN/XSDgenerator" 
xml ns" sch="http 9 
ascc. net/xml/schematron" 
ns=" http 9 
jazz. org/encyc I opedi a" 
da t a type L i b r a ry= "h t t p" //www. w3. o rg / 2001/XM LS c h ema- d a t a types "> 
< ! --Asset al bum--> 
<rng" include href="album_type, rng"/> 
<rng'start> 
<rng'el ement name="al bum"> 
<rng" ref name="al bum__type"/> 
<rng" attri bute name="xs i 9 
schemaLocat i on"> 
<rng'data type="anyURI"/> 
</rng'attri bute> 
<rng" oneOrMore> 
<rng'ref name="track"/> 
</rng" oneOrMo re> 
<rng" zeroOrMore> 
<rng" ref name="sampl e"/> 
</rng" zeroOrMore> 
<rng" zeroOrMore> 
<rng" ref name="pl ays"/> 
</rng" zeroOrMore> 
<sch.assert test="sum(track/duration) &It;= 14400"> 
Total album duration too long. 
</sch'assert> 
</rng.el ement> 

360 
Chapter 9 Validation beyond XML Schema 
</rng'start> 
<!--Asset track--> 
<rng" i ncl ude href="track_type, rng"/> 
<rng-define name="track"> 
<rng'el ement name="track"> 
<rng. ref name="track_type"/> 
</rng .el ement> 
</rng.define> 
o
o
o
 
</rng'grammar> 
Here, it is not necessary to use a ru] e clause to specify the context of the 
assert clause. The context is simply defined by the location where the assert 
clause is specified (the album element). 
9.5 AN XML PROCESSING MODEL 
In this book we have looked at three different schema definition languages: 
DTDs (the legacy), the "object-oriented" XML Schema, and grammar-based 
Relax NG. Each has its merits and its weaknesses. The reader will have noticed 
that, for example, XML Schema and Relax NG do not cover external entities, so 
many applications will have to continue using DTDs. DTDs, on the other hand, 
cannot handle namespaces; and Relax NG has no concept of default and fixed 
values, and for cross-references, it relies on DTD logic. 
We have also looked at several techniques to implement semantic con- 
straints, which allow us to test not only if a document is valid but also if it is 
meaningfulman important topic as we move toward the Semantic Web. One of 
these techniques is Schematron, a schema language based on assertions. 
For the implementer, this raises the question of how this all fits together. 
Which schema language is the correct one to use? Do we need to use a second 
schema language in addition to the first choice? What does the parser do, and 
what part of the implementation must be customized? In Figure 9.5, the docu- 
ment parsing process has been divided into sharply defined minitasks. This is in 
part based on Simon St. Laurent's analysis in "Toward a Layered Model for 
XML" [St.Laurent1999]. 
Most parsers handle several steps in this process. As mentioned in Section 
9.4.3, there is actually a parser that does it all (Sun Microsystem's multi-schema 
validator with Schematron add-on). However, in other cases, it may be neces- 
sary to run a document through several parsers and passes, and combine the 
output from these passes. 

9.5 An XML Processing Model 
361 
Figure 9.5 Tasks during the validation of an XML document. There is actually only 
one task (hierarchical structure validation) that is fully supported by all schema 
languages. (Checkmarks in parentheses denote partial support for a task.) 

362 
Chapter 9 Validation beyond XML Schema 
9.6 A FRAMEWORK FOR SCHEMA LANGUAGES 
The multitude of schema languages indicates that there is not a single schema 
language fit for all purposes. XML Schema is best suited where XML is used in 
connection with databases and application-to-application messaging, such as 
electronic business and the integration of heterogeneous data formats. The tra- 
ditional SGML community would probably like to stay with DTDs, enhanced by 
namespace support, or might migrate to Relax NG. In areas where documents 
need to be checked for complex structural constraints and for semantic con- 
straints, Schematron shines. 
A current standardization effort at ISO/IEC tries to combine the concepts of 
all of these schema languages into a modular framework. The Document Schema 
Definition Language (DSDL) [Holman2001] is "a multipart International Stan- 
dard defining a modular set of specifications for describing the document struc- 
tures, data types, and data relationships in structured information resources." 
DSDL identifies six regions relevant to schema definitions: 
m Grammar-oriented schema languages, naming Relax NG as an example. 
[] Primitive data type semantics, naming Part Two (data types) of the XML 
Schema Recommendation as an initial basis. 
[] Path-based integrity constraints, with Schematron as an initial basis. 
[] Object-oriented schema languages. This part is initially based on Part One 
(structure) of the XML Schema Recommendation and the sections of Part 
Two of W3C XML Schema describing the derivation of new simple types and 
the syntax for referring to primitive data types. 
[] Information item manipulation such as default values (as in DTDs), syn- 
onyms, and the eliding of information items. 
[] Namespace-aware processing with DTD syntax, basically covering the XML 
V1.0 specification plus XML namespaces. 
Such a framework could help to gain a clearer understanding of the various 
schema languages and how they relate to each other. It could do the same for 
schema validation as the ISO layer model has done for communication. 


This Page Intentionally Left Blank

10.1 
Object-Oriented 
Implementations of 
the XML Data Model 
10.2 
Encapsulation and 
Behavior 
10.3 
Class, Instance, Type 
10.4 
Simple Types 
10.5 
Complex Types 
10.6 
Global Types 
10.7 
Inheritance 
10.8 
Polymorphism 
10.9 
Dynamic Marshaling 
10.10 Constraints 
10.11 Identity 
10.12 Visibility 
E 
xcept in environments dominated by the documentation 
aspect, XML and XML schemata do not exist in isolation but 
have to integrate with other core technologies of enterprise IT, 
such as relational databases and object-oriented programming. 
This is probably the most important difference between SGML 
and XML. SGML flourished in documentation scenarios. XML, in 
contrast, intrudes into many traditional areas of enterprise tech- 
nology: data storage, data integration, and message exchange. 
It is therefore essential that we get a clear understanding not 
only of the synergy effects between these existing technologies 
and XML but also of the "impedance mismatch" between these 
technologies and XML. 
This chapter discusses XML Schema in context with object- 
oriented technologies; Chapter 11 deals with relational envi- 
ronments. The first part of this chapter explains some basic 
concepts of the object-oriented model and then compares it 
with the XML data model. We will see that both models follow 
concepts that are in parts alien, even opposed to each other. 
That will cause some problems when it comes time to im- 
plement integrated solutions in which object-oriented and 
document-related techniques are "married." What makes this 
365 

366 
Chapter 10 Reality Check: The World Is Object-Oriented 
marriage so important is that object-oriented languages are the 
primary language used to combine processing logic with XML 
documents, despite the fact that functional languages such as 
Haskell are better suited to emulate the complex type system of 
XML. Java, especially, has strong XML support, followed by C++ 
and C#, but other O0 languages such as SmallTalk or Eiffel pro- 
vide XML access layers, too. 
10.1 OBJECT-ORIENTED IMPLEMENTATIONS 
OF THE XML DATA MODEL 
The most precise mapping of the XML Information Set onto object-oriented 
structures is the Document Object Model (DOM). The DOM defines a full appli- 
cation programming interface for XML documents on a generic level. It pro- 
vides access to the various nodes of a document such as document, element, and 
attribute, and to node lists. By doing so, it allows clients not only to navigate 
within XML documents but also to retrieve, add, modify, or delete elements and 
content. To provide a language-independent specification, DOM uses the OMG 
IDL (Object Management Group Interface Description Language) as defined in 
the CORBA 2.2 specification. DOM bindings are defined for many languages, 
such as Java, C++, ECMAScript (JavaScript), and others. 
There are currently three DOM API levels: Level 1, Level 2, Level 3 [LeHors 
2002]. Apart from other improvements, DOM Level 2 adds an event model to 
the DOM specification, while DOM Level 3 adds an XML Content Model, load 
and save, document validation with DTD or XML Schema, better namespace 
handling, and optional support for XPath. I will not go into the details of DOM 
API programming, as these are usually well covered in the many excellent text- 
books about XML with Java. 
Section 9.4.1 gave an example for using the DOM API with Java. We saw how 
constraints can be checked using standard DOM Level 2 access methods or 
using the new XPath access methods defined as an add-on to DOM Level 3. 
What is discussed here is not a physical mapping of XML structures onto object- 
oriented structures as the DOM does, but a semantic mapping of conceptual 
structures onto both XML structures and object-oriented structures. In an OO 
application we want to be able to deal with jazzMusician, band, album, customer, 
and purchaseOrder objects instead of having to deal with Document, El ement, Node, 
and NodeList objects. And, we want to be able to map existing O0 class hierar- 
chies onto XML structures. 

10.2 Encapsulation and Behavior 
367 
So, what we need is a binding between XML structures and OO structures on 
the semantic level. Needless to say, there is no standard method to achieve that. 
In fact, it must be possible to customize such a binding according to the 
requirements of the application. And we want to keep the OO class hierarchy as 
similar as possible to the type inheritance hierarchy in the XML Schema. 
Several products, such as Sun's JAXB (java.sun.com/xml/jaxb), Enhydra's Zeus 
(zeus.enhydra.org), and Breeze XML Studio (www.breezefactor.com), provide a 
framework to define such bindings. Other products are Castor (www.castor.org) 
and JaxMe (jaxme.sourceforge.net). 
u JAXB is currently only available in an early access release supporting only 
DTDs. The final draft of JAXB vl.0, which supports XML Schema, should be 
available when this book publishes and will set the standard for Java-XML 
data binding. JAXB 1.0 will only support a subset of XML Schema, not cover- 
ing wildcards, keys and key references, and NOTATION types. 
[] Zeus is an open source development currently in beta status. It supports XML 
Schema. 
[] Breeze Studio is a commercial product supporting XML Schema with the 
commitment to integrate JAXB when the standard becomes available. 
Binding involves five phases--two phases when creating the application and 
three when running the application. The two phases during creation are 
[] Definition of the binding by the programmer. The programmer has to de- 
scribe how elements and attributes defined in the schema are mapped to Java 
classes and fields. 
[] Generation of the classes. This step is performed by the binding framework. 
The three phases when running the application are 
[] The unmarshaling process reads a document into fields of class instances. This 
involves the parsing of the document. 
[] In the modification process the client code modifies these fields via get.., and 
set.., methods. 
[] The marshaling process converts the instance fields back into an XML 
document. 
Before describing these steps in detail, let's look at the similarities and differ- 
ences between the object-oriented data model and the XML data model. 
10.2 ENCAPSULATION AND BEHAVIOR 
The term "object-oriented" gives a clear hint about the concept of OO lan- 
guages. Similar to real-world objects, software objects expose only their exterior 
to the client. The internal structure is of no concern to the client. This is called 

31511 
Chapter 10 Reality Check: The World Is Object-Oriented 
encapsulation. The object encapsulates its internal mechanism. Its functionality 
is offered to the client via an interface. Take for example an electric lamp. The 
lamp has an internal structure: wiring, electric contacts, and so forth. What is 
exposed to the client is the switch with which to turn the lamp on or off. Tak- 
ing a screwdriver and trying to switch on the lamp by connecting internal wires 
would be both inconvenient and dangerous. The same applies to software 
objects. 
Objects also expose a behavior. Our lamp, for example, changes its state when 
I press the switch. Press the switch once, and the lamp is lit. Press the switch 
twice, and the lamp is switched off again. The lamp, it seems, has an internal 
state that influences the reaction that is caused by the press on the button. The 
behavior of each object can be described by stimulus-response patterns. Each 
stimulus (each client action at the object's interface) generates a certain re- 
sponse that can be observed by the client via the interface. This response 
depends on the stimulus and, of course, on the internal state. Or looked at 
another way, the internal state may be modified by a stimulus. 
This sounds very much like an automaton, and, in fact, an object can be 
described as a finite state automaton, Its behavior can be completely described 
by a finite number of finite sequences of stimulus-response patterns. For soft- 
ware objects, the stimuli consist of messages that are sent to the object, and, 
similarly, the responses are messages that are sent back to the client. While 
some object-oriented languages (for example, SmallTalk) use this message 
metaphor, other object-oriented languages, such as Java and C++, have pack- 
aged the message concept into method calls. A method call consists of a method 
name, parameters, and a return value. Both name and parameters constitute 
the stimulus message that is sent to the object, while the return value contains 
the response message. In languages such as C++ and Java, methods are not clas- 
sified by their name but by their signature. The method signature consists of 
the message name, the number of parameters, and the data types of all these 
parameters. For example, the method switch(b001ean) is different from the 
method swi tch (fl0at). 
Some OO languages support the concept of public object variables, allowing 
clients to access these variables. This may seem to violate the principle of 
encapsulation, but it does not. Object variables that are published at the ob- 
ject's interface are simply an abbreviation: The compiler translates read accesses 
to such a variable into a get... () method and write accesses into a set... () 
method. So, under the surface, the stimulus-response mechanism is still at 
work. 
When we compare these object-oriented concepts of encapsulation and 
behavior with the document-centric model, we see that both models are in 
opposition. First, a document does not expose behavior. Second, a document is 
not encapsulated. Everything in a document is public. The contents may be 
encrypted, but they are still publicly visible. 

10.3 Class, Instance, Type 
369 
10.3 CLASS, INSTANCE, TYPE 
In this chapter we want to analyze how the type hierarchies in XML Schema 
relate to object-oriented type hierarchies. But before we do this, we must get a 
clear understanding of how type hierarchies in object-oriented languages are 
established, as we can identify three different concepts of hierarchy in these 
languages: class hierarchies, type hierarchies based on behavior, and type hier- 
archies based on syntax. 
When taking a peek into the interior of an object, we can differentiate be- 
tween the procedures that process incoming messages and the variables that 
hold state information. We say that objects belong to the same class if they have 
the same procedures. The individual objects of such a class, the class instances, 
differ only in the state they are currently in. If we regard objects as finite state 
automatons, we can say that two objects belong to the same class if they have 
the same state transition table. The actual state may differ for these two objects, 
but the state transition table is identical. 
10.3.1 Class Hierarchies 
Subclasses are classes that can be derived from a parent class by adding some 
functionality, such as new object variables or new methods. In terms of automa- 
ton theory, a subclass adds new states and new rows to the state transition table. 
However, most OO languages also allow us to derive subclasses from parent 
classes by overriding (modifying) existing functionality. By using inheritance 
mechanisms between parent class and subclass, it is only necessary to specify 
the new or modified functionality when implementing a class. The purpose of 
class hierarchies is to establish a mechanism for software reuse, not to establish 
an order relation between objects. 
10.3.2 Type Hierarchies Based on Behavior 
In contrast to class hierarchies, type hierarchies classify objects by behavior. 
Behavior in this sense means behavior at the interface: The same sequence of 
stimuli must generate the same sequence of responses. At this point we are not 
interested in side effects (writing to a file, drawing a window on the screen, 
playing a sound, etc.). Using stimulus response sequences, we can establish a 
subtype/supertype relation. A subtype must expose the same behavior as the par- 
ent type to all messages accepted by the object of the parent type but may 
expose additional behavior to other messages. The consequence is that we can 
substitute a parent type with a subtype without the client noticing (as long as 
the client is only looking at the interface). This is called polymorphism. Objects 
of the same type may belong to different classes as long as they expose the same 

370 
Chapter 10 Reality Check: The World Is Object-Oriented 
behavior. These objects have a different implementation, but the functionality 
is identical. 
Again, the object-oriented concept of types is opposed to the concept used in 
XML. In XML a type is defined by a set of structural constraints, while in object- 
oriented terms a type is a set of behavioral constraints. 
10.3.3 Type Hierarchies Based on Syntax 
Practical OO implementation, however, does not use this behavioral concept to 
establish a type hierarchy. This is because in order to support polymorphism, 
the compiler would have to know the exact behavior of a type. This is not 
always possible, as the implementation may not be available, and determining 
a behavioral type from an implementation is far from trivial. In terms of com- 
putational theory it is not decidable if two behavioral types are equal. Existing 
OO languages, therefore, use a different, syntactical notion of type. For exam- 
ple, a Java interface describes the methods that must be supported by a given 
type. It also can declare public variables, but we may ignore this here, as public 
variables are only an abbreviation for get.., and set.., methods. All methods 
are just described with their signature (name plus parameter types) and the 
return type. 
Classes implement one or several interfaces. The type of a class instance, an 
object, is determined by the interfaces that the class implements. In fact, an 
object can belong to several types if the class implements several interfaces, and 
the object can be used in all places where such a type is expected. If, for exam- 
ple, the class MusicTeacher implements both interfaces Musician and Teacher, 
then an instance of MusicTeacher can be used in the role of type Musician and in 
the role of type Teacher. 
Subtypes can be derived from parent types by adding method calls (or public 
variables) to the interface definition. This, of course, can also be achieved by 
combining several interface definitions. For example, we could define an inter- 
face MusicTeacher by combining Musician and Teacher. Consequently, Music- 
Teacher is a subtype of both Musician and Teacher. Subtypes can substitute a 
parent type in any occasion where the parent type is used, without violating 
type-safety. However, because this type concept is not based on behavior, this 
substitution can cause a complete change of the program's behavior. 
10.3.4 Object-Oriented Types vs. XML Types 
It is this notion of substitutability that establishes a type hierarchy in the OO 
world. In contrast, the notion of subtypes in XML is based on set theory. A doc- 
ument type A is a subtype of document type B if every instance of A is also an 
instance of B. The consequence is that the relationship between subtype and 
parent type is not maintained when we map XML structures on OO structures 
and vice versa. 

10.3 Class, Instance, Type 
371 
Let's look at an example. The following XML type, 
<xs'compl exType name="CD_type"> 
<xs: sequence> 
<xs.element name="title '' type="xs'string"/> 
<xs.element name="productNo" type="xs'string"/> 
</xs -sequence> 
</xs. compl exType> 
could be mapped on the following Java interface definition: 
publ i c interface CD_type { 
String getTitle() ; 
void setTitle(String) ; 
String getProductNo() ; 
void setProductNo(String) ; 
We can now create a subtype of CD: 
public interface CDforSale_type extends CD_type { 
java.math.BigDecimal getPrice() ; 
void getPrice(java.math.BigDecimal) ; 
} 
The corresponding XML Schema definition, 
<xs" compl exType name="CDforSal e_type"> 
<xs: compl exContent> 
<xs- extensi on base="CD"> 
<xs 9 
sequence> 
<xs-element name="price" type="xs.decimal"/> 
</xs 9 
sequence> 
</xs .extension> 
</xs .compl exContent> 
</xs" compl exType> 
is by no means a subtype of CD; the instances of CDforSal e are not instances of 
the XML type CD because they contain an additional element. 

312 
Chapter 10 Reality Check: The World Is Object-Oriented 
Note that there is a slight inaccuracy in our mapping. Since all Java interface 
variables can contain the null value, too, our XML type definitions should have 
a min0ccurs:"0" with each child element: 
<xs: compl exType name="CD"> 
<xs: sequence> 
<xs:element name="title '' type="xs:string '' minOccurs="O"/> 
<xs: el ement name="productNo '' type="xs: string" mi nOccurs="O"/> 
</xs: sequence> 
</xs: compl exType> 
and 
<xs: compl exType name="CDforSal e"> 
<xs: compl exContent> 
<xs :extension base="CD"> 
<xs: sequence> 
<xs:element name="price" type="xs:decimal" minOccurs="O"/> 
</xs:sequence> 
</xs "extension> 
</xs: compl exContent> 
</xs: compl exType> 
In this case, the XML type CDforSal e is a supertype of XML type CD (while the 
Java type CDforSale is a subtype of Java type CD)! 
) 
Extension/ 
restriction 
9 
Extended or " 
restricted type 
,~ 
DX 
Complex type 
TX 
Figure 10.1 Hierarchical relationships between types 
can always be maintained when mapping XML Schema 
types onto object-oriented types. 

10.4 Simple Types 
373 
Supertype 
TO 
Subtyping, 
no feature override 
Complex type 
TX 
Extension 
Narrower subtype, / 
no appended features// 
( 
Subtype 
.... ~ 
RX 
EX 
Figure 10.2 When mapping object-oriented types onto XML Schema types, the 
hierarchical relationships can only be maintained under certain conditions. 
Conclusion: An XML Schema type DX constructed by extension from another 
XML Schema type TX can always be mapped onto a subtype SO of the corre- 
sponding OO supertype TO (see Figure 10.1). The same is true for derivation 
by restriction (because an OO subtype can override features of its supertype). 
On the other hand, an OO subtype EO of an OO type TO can be mapped 
onto an extension EX of the corresponding XML Schema supertype TX only if 
the OO subtype SO does not override features of its supertype TO (see Fig- 
ure 10.2). An OO subtype RO of OO type TO can be mapped onto a restriction 
RX of the corresponding XML Schema supertype TX only if the OO subtype TO 
overrides features of its supertype TO by narrowing them (making the set of 
instances smaller), and refrains from appending additional features. 
10.4 SIMPLE TYPES 
This section discusses how the simple types defined in XML Schema can be 
mapped onto types in OO languages. Some OO languages such as C++ and Java 
implement primitive types (types that are not objects). Java, for example, provides 
the following primitive types: byte, short, int, ]ong, char, float, double, b0o]ean. 1 
Other languages such as SmallTalk do not have primitive types. In such lan- 
guages every type consists of objectsmin OO lingo, of first-class citizens. 
1. The Sun XML Datatypes Library (xsdlib) is one example of a Java implementation of 
the XML Schema type system. 

374 
Chapter 10 Reality Check: The World Is Object-Oriented 
10.4.1 String Data Types 
The primitive data type string as defined in XML Schema is based on the Uni- 
code character set and is of unlimited length. In object-oriented languages the 
character set used depends on the particular language: While Java supports 
Unicode, most other OO languages support only ASCII. Most OO languages 
support strings of virtually unlimited length; some older languages such as 
Simula or object-oriented dialects of Pascal limit strings to a length of 255 char- 
acters. Java, for example, implements strings as first-class citizens in the form 
of the java.lang.String class, allowing a maximum number of characters of 
2,147,483,647 (because the implementation stores the number of characters in 
an i nt variable). 
XML Schema data types derived from string, such as normalizedString or 
token, are not supported as built-in data types in OO languages. However, it 
would be possible to implement such types in the form of user-defined classes. 
On the other hand, it is possible to define XML Schema data types derived from 
string that match the characteristics of a particular programming language, and 
to use these data types consistently when authoring XML schemata. 
10.4.2 Binary Data Types 
Since XML is text based, it does not support binary data in native format. 
Instead, XML Schema offers two encoded binary formats: he 
and 
base64Binary. Both formats support binary data of unlimited length. 
Most O0 languages do not provide an explicit concept for binary data. In 
Java, for example, binary data would be stored in arrays of data type byte. 
10.4.3 The Boolean Data Type 
XML Schema supports Boolean values with the data type boolean. Most OO lan- 
guages implement a Boolean data type. Java, for example, has a built-in data 
type b001 ean. 
10.4.4 Exact Numeric Types 
The only primitive exact numeric data type in XML Schema is decimal. All other 
exact data types, such as integer, long, i nt, short, are derived from this data type 
by restriction. XML Schema does not restrict the upper and lower bounds of 
decimal but requires processors to support at least 18 decimal digits. 
Most OO languages (except perhaps COBOL++) don't have built-in support 
for decimal data types but may provide appropriate support via class libraries. 
For example, Java 2 provides a decimal data type in the library java.math. The 
class java.math.BigDecimal supports decimal numbers with an unlimited num- 
ber of decimal and fractional digits. 

10.4 Simple Types 
375 
The integer data type is found as a built-in data type in most O0 languages 
(except in those that don't have built-in data types at all, such as Sma11Talk). In 
Java, for example, we find the following integer data types: 
XML 
Java 
Range 
integer 
java.math.Biglnteger 
unlimited 
l ong 
l ong 
-9,223,372,036,854, 775,808 
9,223,372,036,854,775,807 
i nt 
i nt 
-2,147,483,648 
2,147,483,647 
short 
short 
-32,768 
32,767 
uns i gnedShort 
char 
0 
65,535 
byte 
byte 
-128 
127 
10.4.5 Approximate Numeric Types 
XML Schema supports the approximate numeric types float and d0ubl e for sin- 
gle and double precision floating-point numbers according to IEEE 754-1985. 
With these data types we find the highest compatibility with OO languages, as 
IEEE 754-1985 has been adopted by practically all OO languages. 
10.4.6 Date and Time 
XML Schema provides a rich set of date and time data types based on ISO 8601. 
dateTime specifies a precise instant in time (a combination of date and time), 
date specifies a Gregorian calendar date, and time specifies a time of day. All 
three types can be specified with or without a time zone. The data type duration 
specifies an interval in years, months, days, hours, minutes, and seconds, and 
allows negative intervals, too. 
Not all OO languages provide built-in support for date and time. Java pro- 
vides support for date and time in class library java.util: The classes 
java.util.Date, java.util.Calendar, and java.util.GregorianCalendar provide 
extensive support for date and time arithmetic, java.util .Date is almost equiv- 
alent to the XML Schema type dateTime with a resolution of milliseconds. 2 
2. However, these Java types always require the specification of a time zone, which is 
optional in XML Schema. Also, the date components (year, month, day, etc.) are 
restricted in size in Java, which is not the case in XML Schema. 

376 
Chapter 10 Reality Check: The World Is Object-Oriented 
Section 9.4.1 showed a conversion routine from the XML Schema xs:date and 
xs :dateTime formats into java.uti I .Date objects. 
Most O0 languages (including Java) do not provide built-in support for in- 
tervals. However, such a data type can easily be implemented as a specific class. 
10.4.7 Other Data Types 
XML Schema supports URIs with the data type anyORI. Java supports URLs 
(a subtype of URIs) with the class java.net.ORL. Java 1.4 improves the support 
for URIs by adding class java.net.ORI. 
The QName data type in XML Schema specifies qualified names. It consists of a 
local part and a namespace part. It is relatively easy to represent such a qualified 
name in O0 languages: It can be implemented as a tuple consisting of a name- 
space URI and the local name (string). 
10.4.8 Type Restrictions 
XML Schema provides a rich set of constraining facets to derive user-defined 
simple data types from built-in data types. Object-oriented languages allow us 
to implement user-defined data types that are directly or indirectly derived from 
built-in data types. The additional constraints can be implemented within the 
access method belonging to objects of these types. 
10.4.9 Type Extensions 
Restriction is not the only way in XML Schema to derive user-defined types. 
Type extensions such as type union and type extension by list are possible, too. 
In most O0 languages there is no construct like a type union. (C++ recognizes 
the construct of a vari ant, which it inherited from C.) One solution is to use a 
type of the least common denominator, but some type-safety may be lost. In 
the worst case the most general type must be used, such as Object in Java. 
Extension by list can easily be simulated in object-oriented languages 
through an appropriate collection type object such as java.util .List in Java. 
Some languages such as Eiffel support parameterized types, allowing the imple- 
mentation of type-specific lists, such as a list of integers, a list of strings, and so 
on. Other languages such as Java must resort to a collection of general objects. 
(Java will support parameterized types with version 1.5.) This less type-safe 
solution requires casting a list element back into its specific data type when it is 
retrieved from the list. 
10.4.10 Null Values 
In O0 languages, null values are possible when a data type is implemented as a 
class, and usually not possible when a data type is primitive. In Java, for exam- 

10.5 Complex Types 
377 
ple, the data types such as int, short, char, float, or double do not allow null 
values. For this purpose, Java provides wrapper classes: java.lang. Integer, 
java.lang.Float, or java.lang.Double. 
Traditionally, OO null values are used to signal the absence of an XML 
element or attribute when an element or attribute is optional. This leaves us 
with the question of what to do when an element was defined as nillable (see 
Section 5.3.16). The answer is simple: It is in general not possible to represent 
a nilled element by a null value. The element may, for example, contain 
other attributes, so it must be represented by an object. Instead, the attribute 
xsi :ni 1 ="true" must be represented by a Boolean field within the object. 
10.4.11 Implementing a Type Hierarchy 
A consistent approach to mapping the XML Schema type system onto an OO 
language is not to map directly to built-in primitive types, but to implement a 
hierarchy of classes that closely matches the XML hierarchy of built-in types. A 
generic class XML0bject could be at the top of such a hierarchy. This class could 
provide some features that are common to all XML objects, such as marshaling 
and unmarshaling. Derived from this generic class, we would find classes such 
as XMLAnyType, XMLAnySimpleType, XMLString, XMLNormal izedString, XMLToken, XMLNM- 
TOKEN, and so on. These classes could implement the specific constraints for 
each built-in XML Schema data type. User-defined types could be derived from 
these classes, too. 
10.5 COMPLEX TYPES 
This section shows how the various constructs found in XML schemata, such as 
hierarchy, sequence, choice, and so on, can be mapped onto OO constructs. 
Java has been chosen as the implementation language. 
10.5.1 Hierarchy 
Leaf elements (elements that do not contain child elements) of a cardinality 
<= 1 and attributes can be implemented as simple fields of the data types shown 
in the previous section. Note that in Java it is not possible to express on a field 
level that an element is optional or not. However, it would be possible to add 
the necessary checks to the set... () access routines of a field. If an element is 
optional, it must be implemented as an object (reference) type and not as a 
primitive type (for example, as java. lang. Integer or our own XMLInteger instead 
of i nt) to allow for null values. 

378 
Chapter 10 Reality Check: The World Is Object-Oriented 
The following example shows how leaf elements can be translated into Java. 
XML Schema 
<xs :el ement name="name"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="first '' type="xs:string"/> 
<xs:element name="middle" minOccurs="O" type="xs:string"/> 
<xs:element name="last '' type="xs:string"/> 
</xs: sequence> 
</xs: compl exType> 
</xs :el ement> 
Java Interface 
public interface Name { 
XMLString getFirst() ; 
void setFirst(XMLString first) ; 
XMLString getMiddle() ; 
void setMiddle(XMLString middle) ; 
XMLString getLast() ; 
void setLast(XMLString last); 
public static final String SName = "name"; 
public static final String SFirst = "first"; 
public static final String SMiddle = "middle"; 
public static final String SLast = "last"; 
The last four instructions define the string constants that represent the tag 
names associated with this interface. These constants are used during the mar- 
shaling and unmarshaling process. 
Java Implementation 
public class Namelmpl implements Name { 
private XMLString first; 
private XMLString middle; 
private XMLString last; 

10.5 Complex Types 
379 
public XMLString getFirst() 
{ 
return first; 
} 
public void setFirst(XMLString first) { 
if (first == null) throw new CardinalityException(); 
this.first = first; 
} 
public XMLString getMiddle() { 
return middle; 
} 
public void setMiddle(XMLString middle) { 
this.middle = middle; 
} 
public XMLString getLast() { 
return last; 
} 
public void setLast(XMLString last) { 
if (last == null) throw new CardinalityException(); 
this.last = last; 
} 
Complex elements with a cardinality of <= 1 are implemented in the same 
way, except that the child elements are represented by fields with the type of 
the child node. 
XML Schema 
<xs :el ement name="person"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name:"name"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="first" type="xs:string"/> 
<xs:element name="middle" minOccurs="O" type="xs:string"/> 
<xs:element name="last" type="xs:string"/> 
</xs: sequence> 
</xs :compl exType> 
</xs :el ement> 
<xs:element name="birthDate '' type="xs:date"/> 
</xs: sequence> 

3110 
Chapter 10 Reality Check: The World Is Object-Oriented 
</xs : compl exType> 
</xs: el ement> 
3ava Interface 
public interface Name { 
XMLString getFirst() ; 
void setFirst(XMLString first) ; 
XMLString getMiddle() ; 
void setMiddle(XMLString middle) ; 
XMLString getLast() ; 
void setLast(XMLString last); 
public static final String SName = "name"; 
public static final String SFirst = "first"; 
public static final String $Middle = "middle"; 
public static final String $Last = "last"; 
} 
public interface Person { 
Name getName () ; 
void setName(Name name); 
XMLDate getBirthDate() ; 
void setBirthDate(XMLDate date) ; 
public static final String SName = "person"; 
public static final String $BirthDate = "birthDate"; 
} 
The representation of repeating elements requires some more effort. Such 
an element must be represented as a collection data type (List, ArrayList, 
LinkedList, Vector). These data types have their own interface, which makes it 
possible to iterate through the list, access list elements, and modify the list. Ele- 
ments contained in a list always have the data type Object (the most general 
data type in Java). When retrieving an element from the list it is necessary to 
cast it into the appropriate type. 
XML Schema 
<xs :el ement name="al bum"> 
<xs: compl exType> 
<xs: sequence> 

10.5 Complex Types 
381 
<xs.element name="track" maxOccurs="unbounded"> 
</xs'element> 
</xs'sequence> 
</xs" compl exType> 
</xs "el ement> 
Java Interface 
public interface Track { 
,
o
,
 
} 
public interface Album { 
o o o  
java.util .List getTrackLi st () ; 
void setTrackList(java.util.List tracks); 
,
o
o
 
} 
Cl lent Code 
java.util .List tracks = myAl bum. getTrackLi st () ; 
Track myTrack = (Track) tracks.get(O) ; 
Alternatively, we could implement a type-safe access layer around such a col- 
lection type, replicating all its access methods. Languages such as Eiffel or Pizza 
allow us to use generics (parameterized types) to specify collection types such as 
a list of track elements. Again, control for cardinality constraints could be built 
into the implementation of setTrackLi st (). 
10.5.2 Sequence 
Maintaining sequence information is normally not a big problem when trans- 
lating XML schemata into OO interfaces, as access is always performed field by 
field and by name. Also, the sequence in repeating elements is maintained: List 
items are ordered and can be accessed by an index. 
However, there is one case that causes a problem. Let's assume that a schema 
constructs a complex element by using an all connector. The consequence is 
that a sequence of elements in the document instance may arrive in a different 
order than the one defined in the schema. That does not really matter, as we 
normally access elements by name. But if we want to access an element by posi- 
tion, we are in trouble (XPath, for example, allows such things). We cannot 

382 
Chapter 10 Reality Check: The World Is Object-Oriented 
determine the name of the element in question from the schema, because the 
instance may have a different element order. The relationship between tag and 
position is determined by the document instance. 
XML Schema 
<xs :element name="performedAt"> 
<xs: compl exType> 
<xs:all> 
<xs:element name="location '' type="xs:string"/> 
<xs:element name="time '' type="xs:time"/> 
</xs:all> 
</xs: compl exType> 
</xs:el ement> 
XML Instance 1 
<performedAt> 
<location>Cotton C1 ub</1 ocation> 
<t i me>20: 00</t i me> 
</performedAt> 
location has position 1, time has position 2, time follows location. 
XML Instance 2 
<performedAt> 
<time>20:OO</time> 
<location>Cotton Cl ub</location> 
</performedAt> 
location has position 2, time has position 1, time precedes location. 
3ava Interface 
public interface PerformedAt { 
XMLString getLocati on () ; 
void setLocation(XMLString location) ; 
XMLTime getTime() ; 
void setTime(XMLTime time); 
public static final String $Name = "performedAt"; 

10.5 Complex Types 
383 
public static final String $Location = "location"; 
public static final String $Time = "time"; 
Once converted to Java, the relationship between tag and position is lost. We 
are not able to ask: Was time given before or after location? 
The problem also affects marshaling. Unmarshaling instance 2 into our Java 
structure should not cause problems: The unmarshaling process receives a tag 
and maps the element in the correct field. But when this data structure is mar- 
shaled again into XML, the information of the original sequence is no longer 
present, and the resulting XML will look like instance 1. This is, of course, unac- 
ceptable. The <xs:all > connector does not mean that the sequence of elements 
in an instance does not matter, it only means that all sequences are valid. (The 
XML Information Set [Cowan2001] (see Section 4.2) defines the child elements 
of a document as an ordered set.) 
To solve this problem, it would be necessary to resolve the a l 1 connector into 
a choice of all possible permutations of the a l 1 list. However, this can result in a 
rather large amount of interface definitions. Section 10.9 discusses an alternate 
approach to this problem. 
10.5.3 Repetition 
One more point about sequences requires consideration: repeating sequences. 
Repetitions are mapped onto collection types such as Li st, ArrayLi st, and so on. 
The elements of such a collection type now do not contain an XML element but 
an XML model group (a sequence of elements). We represent such a model 
group with its own object type (LocationAndDate). 
XML Schema 
<xs: el ement name="tourDates"> 
<xs: compl exType> 
<xs: sequence maxOccurs="unbounded"> 
<xs:element name="location" type="xs:string"/> 
<xs:element name="date" type="xs:date"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
Java Interface 
public interface LocationAndDate { 
XMLString getLocati on () ; 

384 
Chapter 10 Reality Check: The World Is Object-Oriented 
void setLocation(XMLString location) ; 
XMLDate getDate() ; 
void setDate(XMLDate date); 
public static final String $Location = "location"; 
public static final String SDate = "date"; 
} 
public interface TourDates { 
java.util .List getLocationAndDateList() ; 
void setLocationAndDateList(java.util.List tourDates); 
public static final String $Name = "tourDates"; 
} 
Client Code 
java.util .List Events = myTour.getLocationAndDateList() ; 
LocationAndDate oneEvent = (LocationAndDate) Events.get(O) ; 
XMLString loc = oneEvent.getLocation() ; 
XMLDate date = oneEvent.getDate(); 
10.5.4 Choice 
There is not much choice when we want to map a choice group onto O0 struc- 
tures: We have to implement it as a sequence (except in C++, where we might 
exploit the antediluvian vari ant construct), but with the additional constraint 
that only one of these fields in this sequence is not nul l. If we want to enforce 
this constraint, we have to provide an access method that sets all branches of 
the choice model group in a single step. 
XML Schema 
<xs: el ement name="i tem"> 
<xs: compl exType> 
<xs: sequence> 
<xs: choi ce> 
<xs: el ement name ='' amount" type="xs: uns i gnedShort "/> 
<xs: sequence> 
<xs:element name="quantity" type="xs:decimal"/> 
<xs:element name="unit" type="xs:token"/> 
</xs: sequence> 
</choice> 

10.5 Complex Types 
385 
<xs: el ement name="productNo" type="xs: NMTOKEN"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
3ava Interface 
public interface QuantityAndUnit { 
XMLDecimal getQuantity() ; 
void setQuantity(XMLDecimal quantity) ; 
XMLString getUnit() ; 
void setUnit(XMLString unit); 
public static final String $Quantity = "quantity"; 
public static final String SUnit = "unit"; 
} 
publ i c interface Item { 
XMLUnsignedShort getAmount () ; 
Quanti tyAndUni t getQuanti tyAndUni t () ; 
void set AmountOrQuanti tyAndUni t (XMLUns i gnedShort amount, 
QuantityAndUnit quantityAndUnit) ; 
String getProductNo() ; 
void setProductNo(String productNo); 
public static final String $Name = "item"; 
public static final String SAmount = "amount"; 
public static final String SProductNo = "productNo"; 
Sequences within a choice group must be implemented as their own object 
type, as shown with Quanti tyAndUni t. The method setAmountOrQuanti tyAndUni t is 
used to set both branches of the choice group in one step. Thus, the implemen- 
tation of this method can check if only one parameter is not null. 
The implementation of repeating choice groups is similar to the implemen- 
tation of repeating sequences. If the choice group in the example above were to 
repeat, we would implement it as a list of AmountOrQuanti tyAndUni t objects. 
10.5.5 Recursion 
Recursion is relatively easy to model. The recursive element is implemented as 
its own object type. This type contains fields that hold objects that refer recur- 
sively (directly or indirectly) to it. 

386 
Chapter 10 Reality Check: The World Is Object-Oriented 
XML Schema 
<xs: el ement name="part ''> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="productNo" type="xs :NMTOKEN"/> 
<xs:element name="name" type="xs:string"/> 
<xs: el ement ref="part" mi nOccurs="O '' maxOccurs="unbounded ''/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
3ava Interface 
public interface Part { 
XMLString getProductNo() ; 
void setProductNo(XMLString product) ; 
XMLString getName() ; 
void setName(XMLString name); 
Li st getPartLi st () ; 
void setPartList(List parts); 
public static final String $ProductNo = "productNo"; 
public static final String $name = "Name"; 
} 
The objects contained in the list have type Part. Client code would have to 
cast these list elements to type Part: 
List subparts = myPart.getPartList() ; 
Part subpart = (Part) subparts.get(O); 
10.5.6 Global and Local Elements 
The mapping shown above works well for elements defined globally. However, 
in the case of complex elements that are defined locally, we may run into name 
clashes. Remember that elements defined locally with the same tag names may 
have different types. So far, we have derived the interface names directly from 
the tag names by capitalizing the first letter. 
As a matter of fact, this problem is easy to solve. We just name interfaces for 
locally defined elements differently, preferably by using the full path name. 
Using such a naming convention for a locally defined element perf0rmedAt (as 
child of jamSessi0n), we would arrive at the following interface: 

10.6 Global Types 
387 
public interface JamSessionPerformedAt { 
XMLString getLocati on () ; 
void setLocation(XMLString location) ; 
XMLTime getTime() ; 
void setTime(XMLTime time); 
public static final String $Name = "performedAt"; 
public static final String SLocation = "location"; 
public static final String STime = "time"; 
The constant $Name for the tag name, however, stays the same. 
10.6 GLOBAL TYPES 
Global XML Schema types can be mapped onto OO structures in much the 
same way as XML elements. The only difference is that no tag name is declared 
for the type structure. 
XML Schema 
<xs.compl exType name="CDType"> 
<xs. sequence> 
<xs.element name="title" type="xs'string"/> 
<xs.element name="productNo" type="xs'string"/> 
</xs 9 
sequence> 
</xs" compl exType> 
Java Interface 
publ i c interface CD_type { 
String getTitle(); 
void setTitle(String title); 
String getProductNo() ; 
void setProductNo(String productNo); 
public static final String STitle = "title"; 
public static final String $productNo = "productNo"; 
An element CD defined with type CD_type 
<x s" e I eme n t name =" C D" type = "C D_typ e"/> 

388 
Chapter 10 Reality Check: The World Is Object-Oriented 
can then be declared as 
public interface CD extends CD_type{ 
public static final String $CD = "CD"; 
} 
10.7 INHERITANCE 
Section 10.3 already covered type hierarchies in O0 languages. We found that 
object-oriented languages such as Java allow us to derive a subtype from a par- 
ent type by extending the definition of the parent type, and that the subtype 
inherits features from the parent type. This is very much in sync with deriva- 
tion by extension in XML Schema. This inheritance mechanism should there- 
fore be relatively easy to map between both data models. For example, if we 
want to extend the above CD_type with a price element, we can use the existing 
CD_type interface and extend it, too. 
XML Schema 
<xs'compl exType name-"CDforSal e_type"> 
<xs" compl exContent> 
<xs'extension base="CD type"> 
<xs 9 
sequence> 
<xs:element name="price" type="xs.decimal"/> 
</xs 9 
sequence> 
</xs :extension> 
</xs- compl exContent> 
</xs- compl exType> 
3ava Interface 
public interface CDforSale_type extends CD_type{ 
XMLDecimal getPrice() ; 
void setPrice(XMLDecimal price) ; 
public static final String $Price = "price"; 
} 
XML Schema can also derive types by restriction, for example, by excluding 
optional child elements or attributes from the definition of a complex type. 
Within an O0 implementation, such restricting constraints can easily be added 
by sharpening the constraints defined in the access method implementations 
(or by adding new constraints). For example, if we want to exclude an optional 

10.9 Dynamic Marshaling 
389 
(min0ccurs="0") element from a restricted type, we simply override its access 
methods with methods that throw an exception when they are used. 
10.8 POLYMORPHISM 
In object-oriented languages, the term polymorphism denotes the ability to use 
instances of a given type in the role of another type, usually instances of a sub- 
type in the role of the supertype (substitutability). For example, given the above 
parent type CD_type and the subtype CDforSal e_type, we can use CDforSal e_type 
anywhere CD_type is used. 
XML Schema has a similar concept. We can use a type that has been derived 
from a parent type anywhere the parent type is used. 
[] This applies, for example, to substitution groups. Elements that belong to a 
substitution group can replace the head element anywhere the head element 
is specified. Remember that the type of a substitution group element must be 
a type that is derived from the type of the head element. 
[] Similarly, document instances may explicitly declare a type (via xsi .type) for 
an element or attribute used in the document instance. The condition is that 
this type is derived from the type under which the element or attribute was 
declared in the schema. 
Since the subtyping characteristic in Java and XML Schema is equivalent, as 
pointed out in the previous section, we can implement a Java binding of a given 
schema and trust that this binding can handle all documents with types derived 
from the original schema. 
10.9 DYNAMIC 
MARSHALING 
This section presents a proposal for how to solve the sequence problem with the 
<xs.all > connector (see Section 10.5). Two new fields are included in the inter- 
face definition: an integer field first and an integer array next: 
publ i c i nterface PerformedAt { 
XMLString getLocation() ; 
void setLocation(XMLString location) ; 
XMLTime getTime() ; 
void setTime(XMLTime time); 
public static final String SName = "performedAt"; 
public static final String SLocation = "location"; 
public static final String STime = "time"; 

390 
Chapter 10 Reality Check: The World Is Object-Oriented 
public int first; 
public int next[] = new int[2]; 
} 
These two fields are filled by the unmarshaling process, which records the 
sequence of elements found in the document instance. For example, if the doc- 
ument is 
<performedAt> 
<location>Cotton Cl ub</location> 
<t i me>20: O0</t ime> 
</performedAt> 
the content of first is O, the content of next[O] is 1, and the content of next[l] 
is-1. If the instance is 
<performedAt> 
<t i me>20: O0</t ime> 
<location>Cotton Cl ub</location> 
</performedAt> 
the content of first is 1, the content of next [0] is-1, and the content of next [1] 
is O. 
Now the marshaling process, instead of just writing out the elements in the 
sequence of their definition, can use the information in first and next and write 
the elements in this sequence. The elements in the output document will have 
the same order as in the original document. The content of first and next could 
also be used to address elements by position. 
10.10 CONSTRAINTS 
As mentioned earlier, the object-oriented data model is based on encapsulation. 
The data within an object can only be accessed via methods. This makes it pos- 
sible to implement all kinds of constraints in these access methods, including 
the constraints defined in an XML Schema. 
10.10.1 Simple Types 
The simplest constraints are those implied by simple types. These constraints 
are defined in XML Schema in the form of constraining facets such as mi n Inclu- 
sive, maxExclusive, fractionDigits, pattern, and so on. Facets such as minlnclu- 
sire or fractionDigits are easy to implement in very few instructions; pattern, 
however, can require serious programming in some O0 languages. Fortunately, 

10.10 Constraints 
391 
Java 1.4 comes with a regex class that provides exactly the functionality to 
implement the pattern facet. 
10.10.2 Cross-References 
Cross-references that are defined in XML Schema via ID, IDREF, key, and keyref 
can, of course, also be checked. For example, a set.., method for a list could 
check the list for duplicates and thus establish that the list elements are unique. 
Or, it could check if the list elements can be found in another specified list, and 
are thus suitable as references. 
10.10.3 When to Check 
Should we check constraints within access methods? Or would it be better to 
postpone the constraint validation until the final XML document is created 
(marshaled)? The problem with the first method is that constraints can get in 
the way when we want to modify content, especially if a constraint affects sev- 
eral fields. Also, a constraint can be checked more than once, which degrades 
performance. 
However, the second method also has drawbacks. First, it is more difficult to 
identify the client code that caused the constraint violation. Second, if the doc- 
ument modification happens in an interactive environmentmfor example, 
when filling out a formmit is not very friendly to end users to tell them about a 
wrong field located at the beginning of the form after they have completed the 
whole form. 
A good compromise is to implement constraints that affect a single field only 
in their respective access methods, and to test cross-field constraints in a sepa- 
rate step that can be invoked before the XML document is marshaled. 
10.10.4 Conceptual Constraints 
Conceptual models define additional constraints, in particular constraints that 
span multiple fields and multiple documents. Section 9.2.2 discussed such con- 
straints that cannot be modeled with XML Schema. Section 9.4 showed how to 
check such constraints with application code, XSLT, and Schematron. 
Section 9.4.1 showed an implementation of the constraint 
not(time <= jazzMusician/birthDate) 
for document type jamSession. There, we relied on the DOM API to access docu- 
ment nodes. The listing below shows an implementation based on an XML 
binding as outlined in the previous sections. Note that we deal with two docu- 
ment types: jamSessi0n and jazzMusician. The binding for document type 
jazzMusician has been put into a separate Java package named jazzMusician to 
avoid name clashes. 

392 
Chapter 10 Reality Check: The World Is Object-Oriented 
public boolean checkEventDateVsBirthDate(jamSession jam) { 
// set result 
boolean result = true; 
// get a "time" element 
XMLDateTime time = jam.getTime(); 
Date startDate = time.getValue(); 
// Get jazzMusician elements 
java.util.List jazzMusicianList = jam.getJazzMusicianList(); 
// now loop over the "jazzMusician" children 
for (int i=O; i < jazzMusicianList.getLength(); i++) { 
// get a single "jazzMusician" child 
JazzMusician oneMusician = (jazzMusician) jazzMusicianList.item(i) ; 
// now get ID of musician 
XMLNMTOKEN id = oneMusician.getID(); 
// Perform query with this ID 
jazzMusician.JazzMusician jmdoc = 
performQuery ("j azzMusi ci an lID"+"= '"+i d+" ']" 
if (jmdoc == null) { 
System.out.println("Error: Referenced jazzMusician" 
+id+" does not exist"); 
result = false; 
} else { 
// get birthDate 
XMLDate birthDate = jmdoc.getBirthDate() ; 
if (startDate.compareTo(birthDate.getValue()) <= O) { 
// Report violation of integrity constraint 
System. out. pri ntl n 
("Error: Start date before birth date of "+id); 
result = false; 
} 
} 
} 
return result; 
10.10.5 Automatic Code Generation 
The code above is much shorter than the code in Section 7.1.1, which is based 
on the DOM API. It is also more intuitive. However, it is not as short and com- 
pact as the original constraint specification: 
not(time <= jazzMusician/birthDate) 
This raises the question: Is there a way that we can automatically generate 
code like the above from the constraint specification given in the conceptual 

10.11 Identity 
393 
Figure 10.3 Applying XSLT stylesheets in XML/Java binding environment. 
model? The answer is simple: not yet. The different implementations for bind- 
ing XML Schema to object-oriented structures all generate different layouts, and 
many of these implementations have not yet reached a stable state. Once a 
standard binding method is established (this will probably be based on JAXB), 
the implementation of a constraint generator becomes an issue, too. 
What is possible with current technology is shown in Figure 10.3. Instead of 
marshaling the Java data structures representing our input document to an out- 
put document file, we marshal it into a DOM representation. We can then use a 
suitable XPath processor (such as Jaxen) to apply the conceptual constraints for- 
mulated in XPath (see Section 9.3). 
10.1 1 IDENTITY 
The concept of keys (primary keys and foreign keys) is alien to the object- 
oriented concept. Instead, OO uses the concept of object identity. Objects are 
addressed by reference using an object identifier that is allocated whenever a new 

394 
Chapter 10 Reality Check: The World Is Object-Oriented 
object is created. In contrast, relational databases (see Section 11.2) allow us to 
select table rows by content (XML databases also allow us to select XML docu- 
ments by content, via XPath or XQuery). 
This can create problems when we want to map several XML data types to 
OO structures and want to navigate within these structures. As discussed in Sec- 
tion 8.4.2, the XML documents may not contain the necessary navigation 
structures, and consequently the necessary object references in the OO imple- 
mentation are missing. There are two ways to solve this: 
m A map is created that describes the navigational model structure. Each map 
node points to the related map nodes and to the represented object. 
[] Content-based addressing is implemented. This can be done again, for exam- 
ple, with maps. Primary and foreign keys of an asset are mapped to their 
owning object. This allows all necessary navigation to be performed within a 
larger structure. 
10.12 VISIBILITY 
Most object-oriented languages implement a concept of visibility. An object 
class and its features can be defined with various degrees of visibility. Private fea- 
tures are only visible for the class itself; public features are visible for everyone. 
In Java, the default setting for the visibility of a class or feature is visibility 
within the same package. A package combines classes that are in some sense 
interrelated. The concept of packages can be compared with XML namespaces, 
as packages are used to avoid name clashes as well. When mapping XML 
schemata onto Java classes, we usually want to map each namespace onto a sep- 
arate package. Since packages can be nested, we can even mimic the hierarchi- 
cal organization of XML namespaces. For example, given the namespaces 
http://www, jazz. org/encycl opedi a 
and 
http://www.jazz.org/shop 
we can map those onto the packages 
org. jazz. encycl opedi a 
and 
org.jazz.shop 
which are both contained in package jazz. 

11.1 
Motivation 
11.2 
Databases 
11.3 
The Relational Data 
Model 
11.4 
The Relational 
Algebra 
11.5 
Normalization 
11.6 
Brief Introduction 
to SQL 
11.7 Simple Data Types 
11.8 Complex Types 
11.9 
Constraints 
11.10 From Relational Tables 
to XML Schema 
11.11 
Mediation between 
RDBMS and XML 
Databases 
I 
n today's enterprise environments, relational databases are the 
strategic method for data storage. For an enterprise-strength 
XML, it is crucial to integrate with this technology. This chapter 
explores paths of migration from and to relational databases 
as well as concepts of collaboration between the XML format 
and the relational format. 
The chapter starts by giving an introduction into the re- 
lational data model and its implementationuSQL. We then 
compare the features found in SQL (data types and tables) with 
those offered by XML Schema. We will show how XML 
schemata can be translated into relational schemata, and vice 
versa. Finally, we will discuss two commercial implementations 
(Tamino X-Node and Experanto) that collaborate with relational 
databases via schema mapping. 
395 

396 
Chapter 11 Reality Check: The World Is Relational 
11.1 MOTIVATION 
Relational databases became a strategic data storage technology when client- 
server architectures in enterprises emerged. With different clients requiring dif- 
ferent views on the same data, the ability to freely construct complex data 
structures from the simplest data atoms was crucial--a requirement that the 
classical hierarchical database systems could not fulfill. Relational technology 
made the enterprise data view possible, with one (big) schema describing the 
information model of the whole enterprise. Thus, each relational schema 
defines one ontology, one Universe of Discourse. 
And this is the problem. Most enterprises cannot afford to be a data island 
anymore. Electronic business, company mergers, collaborations such as auto- 
mated supply chains or virtual enterprises require that information can be 
exchanged between enterprises and that the cost of conversion is low. This is 
not the case if conversion happens only on a bilateral level, starting from 
scratch with every new partner. 
XML represents a way to avoid this chaos. Because of its extensibility, XML 
allows the use of generic, pivot formats for various proprietary company for- 
mats. Usually business groups and associations define these formats. If such a 
format does not satisfy the needs of a specific partner completely, it is relatively 
easy to remedy by dialecting---extending the generic format with additional spe- 
cific elements. This is why the integration of XML with relational technology is 
all important for enterprise scenarios. We will see that XML Schema has been 
designed very carefully with this goal in mind. 
11.2 DATABASES 
Logically, relational databases have a very simple structure. The fact that the 
implementation of a good relational database management system (RDBMS) is 
not simple at all, and that developers of RDBMSs have invested an incredible 
amount of work to get decent performance out of this clear and logical concept, 
is a different story. 
When discussing relational databases in context with XML, there are two 
application areas to keep in mind: 
[] One application is to represent existing data in the RDBMS in XML format. 
This is important for organizations that store most of their enterprise data in 
relational form and want to leverage this data for electronic business. 
[] The second is to store existing XML data in relational databases. With mech- 
anisms for referential integrity, transaction logic, backup, and recovery, a 
database always provides safer storage for data than a simple file system. Of 

11.3 The Relational Data Model 
397 
course, it is not always necessary to select an RDBMS for that purpose. Native 
XML databases can store XML data more efficiently and require less effort 
when creating an appropriate data model. However, a native XML database is 
not always at hand, and an RDBMS may provide easier access to the data 
from existing legacy applications. 
The Standard Query Language (SQL) is the widely accepted standard for 
accessing an RDBMS (see Section 11.6). Originally developed to support data- 
base table creation, query, update, delete, and insert operations, SQL has been 
enhanced and expanded over the years and now includes additional means for 
constraint validation and support of object-oriented databases. SQL-99 goes far 
beyond the relational data model. However, most RDBMSs don't support SQL- 
99, and if they do, they only support a subset. I will therefore restrict the dis- 
cussion to SQL-92 but give notice where new SQL-99 features solve problems 
that cannot be solved with SQL-92. Most RDBMSs implement a subset of SQL- 
92 but enhance it with proprietary extensions. In this discussion, I will stay 
close to the ANSI or ISO standard. 
Representing the content of a relational database in XML is relatively easy. 
The SQL-99 table and type system (and hence the table and type systems of pre- 
vious SQL editions) is a strict subset of the XML Schema type system. XML 
Schema looks the way it looks because it was designed to be compatible with 
SQL-99 (thanks to the intensive participation of DBMS manufacturers). Thus we 
can easily represent existing relational data with XML Schema without infor- 
mation loss. The opposite waymstoring XML data in relational databases with- 
out information loss--is not so easy, however. 
11.3 THE RELATIONAL DATA MODEL 
A relational database basically consists of a set of two-dimensional tables. These 
tables are organized in unnamed rows and named columns. In relational algebra, 
tables are called relationships, columns are called attributes, and rows are called 
tuples. Each row contains a data record, and within such a record, each column 
represents a data field. Duplicate rows are not allowed. The sequence of rows 
and columns is not ordered. Two tables have the same type if they have the same 
set of columns. 
Keys are used to identify rows in a table uniquely. Each key consists of one or 
several fields (columns) chosen in a way that the value or the combined values 
identify each row uniquely. A key that consists of a minimum number of fields 
and still satisfies this condition is called a primary key. Foreign keys are field com- 
binations whose combined values can match with primary keys in other tables. 
This allows us to use tables as relationships: A table that has two foreign keys 
can relate two other tables to each other. That is the whole idea behind the rela- 
tional data model: A table represents a relationship. 

398 
Chapter 11 
Reality Check: The World Is Relational 
11.4 THE RELATIONAL ALGEBRA 
Equally simple is the relational algebra. First, there are set operations: 
[] Union A w B 
[] Intersection A r~ B 
[] Difference A - B 
The operations can be applied to two tables of the same type. The result 
(shown below) is a table with rows reflecting the union, intersection, and dif- 
ference between the rows of the original tables. 
Table A 
Table B 
productNo 
title 
productNo 
title 
53008 
Round Midnight 
9039 
Sahara 
3012 
Take Five 
53008 
Round Midnight 
AwB 
AraB 
A-B 
productNo 
title 
productNo 
title 
productNo 
53008 
Round 
53008 
Round 
3012 
Midnight 
Midnight 
3012 
Take Five 
9039 
Sahara 
title 
Take 
Five 
Then there are three specific relational operations: 
m Cartesian product 
[] Projection 
[] Selection 
In a Cartesian product, given two tables A and B, the Cartesian product A x B 
consists of all rows (al, a2, . . . , an, bl, b2, 9 9 
bn) where (al, a2, . . . , an) is a row 
from A and (bl, b2,..., 
bn) is a row from B. So, if A has 3 columns and 5 rows, 
and B has 2 columns and 3 rows, A x B has 5 columns and 15 rows. A smaller 
example is shown below: 

11.4 The Relational Algebra 
399 
Table A 
Table B 
productNo 
title 
productNo 
price 
53008 
Round Midnight 
3012 
9.95 
3012 
Take Five 
9039 
17.95 
53008 
12.95 
AxB 
A.productNo 
A.title 
B.productNo 
B.price 
53008 
Round 
Midnight 
3012 
9.95 
3012 
Take Five 
9039 
17.95 
53008 
Round 
Midnight 
53008 
12.95 
3012 
Take Five 
3012 
9.95 
53008 
Round 
Midnight 
9039 
17.95 
3012 
Take Five 
53008 
12.95 
In projection, given a table A, P(A, Cl, C2,.. 9 ,Cn) is called a projection of table 
A on (Cl, C2, 9 .. ,Cn) if all columns ai in A that are not specified in (Q, c2, .. 9 ,Cn) 
are removed from A. Duplicate rows that may have been created in the process 
are removed, too. For example: 
Table A 
productNo 
title 
artist 
53008 
Round Midnight 
Thelonious Monk 
3012 
Take Five 
Dave Brubeck 
Table P(A, artist, title) 
artist 
Thelonious Monk 
Dave Brubeck 
title 
Round Midnight 
Take Five 

400 
Chapter 11 Reality Check: The World Is Relational 
In selection, given a table A and a Boolean function F with arguments from 
the set of columns {al, a2, 9 9 a,} in A, the selection A : F of table A with selec- 
tor predicate F consists of all rows from A (and only such rows) satisfying pred- 
icate F. For example: 
Table A 
productNo 
title 
53008 
Round Midnight 
3012 
Take Five 
9039 
Sahara 
Table A : productNo > 5000 
productNo 
title 
53008 
Round Midnight 
9039 
Sahara 
This is all we need. We can now derive two well-known relational operators 
from the basic operations defined above: 
m The general join operation A x B 9 F is nothing but a Cartesian product of two 
tables A and B followed by a selection with some predicate F. 
n In case of the familiar natural join operation A r B the predicate F consists of 
a test of one or several column pairs from A and B for equality. Because this 
results in identical columns, a projection is also performed, to drop duplicate 
columns. The following example shows a natural join of tables A and B by 
column productNo: 
Table A 
Table B 
productNo 
title 
productNo 
price 
53008 
Round Midnight 
3012 
9.95 
3012 
Take Five 
9039 
17.95 
53008 
12.95 
Table A r 
B 
productNo 
title 
price 
53008 
Round Midnight 
12.95 
3012 
Take Five 
9.95 

11.5 Normalization 
401 
One problem with two-dimensional tables is that we must specify all fields in 
all records. For example, if we have a table person that contains columns for first 
name, middle name, and last name, then any person record stored in the table 
must have a first name, middle name, and last name. This is clearly not accept- 
able, and consequently, relational databases recognize the concept of null val- 
ues. Any data field in a relational database can contain a "real" value or a null 
value that means a real value is not known. It is possible to deny the use of null 
values for certain columns. In particular, columns used for primary keys must 
not contain null values. 
Null values allow the introduction of a new operation" the outer join. The 
outer join is constructed from the join operation by uniting the rows of the 
join with the rows of the original tables A and/or B. Because A and B have a dif- 
ferent type than the result of the join A x B 9 F, the rows of A and B are padded 
with null values before that operation: (ax, az, ..., 
an, null, null, ..., 
null) and 
(null, null, ..., 
null, bx, b2, ..., 
bn). 
If only the padded rows of table A are added, we speak of a left outer join; if 
only the padded rows of table B are added, we speak of a fight outer join. If both 
are added, we speak of the full outer join. The following example shows a right 
outer natural join by column productNo. 
Table A 
Table B 
productNo 
title 
productNo 
price 
53008 
Round Midnight 
3012 
Take Five 
3012 
9.95 
9039 
17.95 
53008 
12.95 
Right Outer Natural Join 
productNo 
title 
price 
53008 
Round Midnight 
12.95 
3012 
Take Five 
9.95 
9039 
12.95 
11.5 NORMALIZATION 
The design of relational models requires a sequence of normalization steps. 
Each step splits the complex data structures of the original model into simpler 
constructs and reduces redundancies and dependencies between data items. 

402 
Chapter 11 
Reality Check: The World Is Relational 
This starts with First Normal Form (1NF), which requires that all column values 
are atomic. This is in stark contrast to the XML data model with its hierarchy of 
complex elements. 
The relational normalization continues with Second Normal Form (2NF) up 
to 5NF. These Normal Forms deal more or less with the relationships between 
column values and keys. In the context of this book they are of no interest; it is 
the 1NF that causes us some problems. 
When registering XML schemata with an XML-enabled relational database, it 
is the XML access layer of the database that will perform this normalization for 
us. It will resolve the hierarchical structure of the XML schema into a set of flat 
SQL tables. To understand this process, we will do this transformation manually. 
11.5.1 Defining the Target Format 
We will construct a small relational database and demonstrate normalization to 
First Normal Form. We sidestep a course in SQL for now by constructing our 
database in the form of an XML document! This has the additional benefit of 
showing us how relational structures can be implemented in XML. 
9 The concept is simple: The root element of our document represents the 
whole database. The tables are represented as repeating child elements of this 
root element. The column values are child elements of these elements, that 
is, grandchildren of the root element. A person table, for example, would look 
like this: 
<person> 
<firs t n ame>Joe</firs t n ame> 
<middlename xsi :ni l="true"/> 
<I astname>Henderson</l astname> 
</person> 
<person> 
<Brstname>Jel I y</firstname> 
<mi ddl ename>Rol 1 </mi ddl ename> 
<I astname>Morton</l astname> 
</person> 
e e e  
<person> 
<Brstname>Earl </firstname> 
<middlename xsi :ni l="true"/> 
<I astname>Hi nes</l astname> 
</person> 
Note that we have used nil values here to represent relational null values. 
This is just to make the XML layout more similar to the relational layout. As nil 

11.5 Normalization 
403 
values can only be used with elements and not with attributes, we always repre- 
sent table columns with elements. 
11.5.2 The Original Schema 
What we are going to do is to normalize our album schema from Chapter 8. We 
have included all global definitions as local definitions and simplified this 
schema a bitmat this point we are not interested in data types and annotations. 
We have also enclosed this album in a root element database. Figure 11.1 shows 
a diagram of the database. 
<xs : schema targetNamespace=" http://www, jazz. org/encycl opedi a" 
xml ns: xs =" ht tp://www, w3. org/2001/XMLSchema" 
xml ns=" http://www, j azz. org/encycl opedi a" 
e I emen t FormDe fau I t = "qua I i fled" 
attri buteFormDefaul t =''unqual i fled"> 
<xs.el ement name="database"> 
<xs. compl exType> 
<xs 9 
sequence> 
<xs "el ement name="al bum" mi nOccurs="O '' maxOccurs="unbounded"> 
H publisher I 
H productNo I 
H title 1 
,r.ck,,,o i 
I database ~ 
album ~ 
-"----'1-'..~'" 
', 
, 
7- ~ 
~ 
~'----'-'-~ 
" 
~ 
: 
'-J duration i 
0"~ 
I 
I 
! 
 
M,31 
~- -~ sample 
I 
~- "- -- ".. -.,. "- ~,,~,~- 
,, 
0.S- 
- q 
.ol 
! 
! 
i 
n 
[-', plays 
' 
1..~ 
~''0.~" 
- 
- 
L~jazzMusiclan~ 
i D 
Figure 11.1 The a] bum database, definitely not in Normal Form. 

404 
Chapter 11 
Reality Check: The World Is Relational 
<xs: compl exType> 
<xs-sequence> 
<xs'element name="publ i sher"/> 
<xs :el ement name="productNo"/> 
<xs :el ement name="ti tl e"/> 
<xs.el ement name="track" maxOccurs="unbounded"> 
<xs" compl exType> 
<xs: sequence> 
<xs "e I ement name:" trackNo"/> 
<xs.element name:"ti tle"/> 
<xs:element name:"duration" minOccurs:"O"/> 
</xs 9 
sequence> 
</xs" compl exType> 
</xs" el ement> 
<xs "el ement name="sampl e" mi nOccurs="O '' maxOccurs="unbounded"> 
<xs" compl exType> 
<xs'sequence> 
<xs.el ement name="MP3"/> 
<xs'el ement name:"track"> 
<xs: compl exType> 
<xs" sequence> 
<xs-el ement name:"trackNo"/> 
</xs 9 
sequence> 
</xs" compl exType> 
</xs" el ement> ~ 
</xs: sequence> 
</xs" compl exType> 
<xs'keyref name="fk 
sample_track" refer="pk 
track_trackNo"> 
<xs'sel ector xpath=" ./track"/> 
<xs:field xpath:"trackNo"/> 
</xs 9 
keyref> 
</xs" el ement> 
<xs :el ement name="pl ays" mi nOccurs="O" maxOccurs="unbounded"> 
<xs: compl exType> 
<xs "sequence> 

11.5 Normalization 
405 
<xs" el ement name="i nstrument" maxOccurs="unbounded"/> 
<xs "el ement name="j azzMusi ci an"> 
<xs 9 
compl exType> 
<xs.all> 
<xs "el ement name=" ID"/> 
</xs.all> 
</xs" compl exType> 
</xs.el ement> 
</xs .sequence> 
</xs: compl exType> 
</xs. el ement> 
</xs "sequence> 
</xs" compl exType> 
<xs'key name="pk album albumKey"> 
m 
<xs'selector xpath ='' . "/> 
<xs'field xpath="publ isher"/> 
<xs.field xpath="productNo"/> 
</xs" key> 
<xs" key name="pkmtrack_trackNo"> 
<xs-sel ector xpath=" ./track"/> 
<xs:field xpath="trackNo"/> 
</xs: key> 
</xs. el ement> 
</xs" sequence> 
</xs: compl exType> 
</xs .el ement> 
</xs: schema> 
11.5.3 Steamrolling the Schema 
We are now going to convert this table into First Normal Form. Plainly speak- 
ing, 1NF means that each table field contains only a leaf element. This is clearly 
not the case with album. Three child elements (plays, track, sample) of album 
are repeating elements and, in addition, have a complex structure. They are 
tables themselves. We therefore remove these child elements from a l bum and 
make them child elements of database; they become full database tables (see 
Figure 11.2, page 406). 

406 
Chapter 11 
Reality Check: The World Is Relational 
publisher I 
,,-" album _~--- 
productNo I 
', 
', 
title I 
,, 
', 
trackNo I 
,, 
! 
"" 
I 
,-J, track 
--- 
title 
I ,, 
database 
. . . .  
I 
--, duration 
, 
! 
i 
I 
I 
! 
' 
I 
: 
MP3 
,,_ ,- ........ [~ 
, ~ sample 
--- 
' 
I 
,, 
;_-~' -" 
track 
: 
trackNo 
I 
I 
I 
: 
instrument 
i;,. 
.0-(--- 
' 
"-"~-:~- 
jazzMuslcian 
[~-(-EI~-~-~ 
ID 
Figure 11.2 Much better, but still not perfect. Note that we made track optional 
because its former parent node album was optional. 
There are still two columns that contain fields with complex structures: 
jazzMusician and track. This is easy to solve. We can simply collapse jazzMusi- 
cian and ID into jazzMusicianlD; track and trackNo into trackTrackNo. 
11.5.4 Introducing Key Relationships 
Unfortunately, our effort to flatten the a] bum schema has resulted in a loss of 
structural information. The tables a] bum, p lays, track, and samp] e are completely 
uncorrelated. We solve this problem by declaring the combination of pub] isher 
and productNo as a primary key for a] bum records, and by introducing elements 
a] bumPub] isher and a] bumPr0ductNo into the tables p] ays, track, and samp]e. These 
fields can then act as foreign keys relating to the album record to which a partic- 
ular record from p] ays, track, or samp]e belongs (see Figure 11.3). 
In the following listing, all the primary and secondary keys are defined. All 
keys are now defined on the database level. Because of this, trackNo as a key for 
track has become ambiguous--trackNo is only unique in the context of one 

11.5 Normalization 
407 
database [~ 
I 
I 
I 
I 
~__ ~ 
publisher 
,-J, album 
--- 
productNo 
I ' ~'--'-'---7.-'~7":' - 
I 
0o~ 0 
' 
title 
I 
I 
I 
I 
' 
I 
' 
trackNo 
I 
I 
I 
I 
I 
I 
q title I 
dur.,,on I 
. 
II 
-~ albumPublisher 
qalbumProductNo 
/I I 
]1 ! 
I 
,-~ track 
--- 
I 
! 
! 
I 
I 
I 
I 
'' 
~ 
,-J, sample 
I , ~-----~-~- 
i 
0~ 
O 
! 
! 
! 
I 
! 
I 
I 
! 
I 
! 
! 
! 
! 
! 
! 
! 
i-i p,.s I~ 
0~ 
MP3 [ 
trackTrackNo [ 
albumPublisher 
albumProductNo 
instrument[ 
jazzMusiclanlD I 
albumPubltsher 
albumProductNo 
Figure 11.3 The album database in First Normal Form. 
album element. We have fixed this by adding albumPubl i sher and albumProductNo 
to the keys pk track_trackNo and fk sample_track. 
We have also removed the maxOccurs="unbounded" from plays/instrument. 
Instead of having one plays element with several instrument elements, we will 
have several plays elements with the same jazzMusician and album but with dif- 
ferent instruments. (plays represents a ternary relationship between album, 

408 
Chapter 11 
Reality Check: The World Is Relational 
jazzMusician, and instrument.) Finally, we made element duration mandatory 
but nillable. 
<xs:schema targetNamespace="http://www.jazz.org/encyclopedi a" 
xml ns: xs=" http://www, w3. org/2001/XMLSchema" 
xml ns=" http://www, jazz. org/encycl opedi a" 
el ement FormDefau I t=" qual i Bed" 
attri buteFormDefaul t="unqual i fled"> 
<xs: el ement name="database"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="al bum" mi nOccurs="O" maxOccurs="unbounded"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="publ i sher"/> 
<xs :el ement name="productNo"/> 
<xs :el ement name="ti tl e"/> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs:element name="track" minOccurs="O" maxOccurs="unbounded"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="trackNo"/> 
<xs:element name="ti tl e"/> 
<xs :element name="duration" ni I I able="true"/> 
<xs: el ement name="al bumPubl i sher"/> 
<xs: el ement name="al bumProductNo"/> 
</xs: sequence> 
</xs: compl exType> 
</xs :el ement> 
<xs :el ement name="sampl e" mi nOccurs="O" maxOccurs="unbounded"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="MP3"/> 
<xs :el ement name="trackTrackNo"/> 
<xs: el ement name="a I bumPubl i sher"/> 

11.5 Normalization 
409 
<xs" el ement name=" al bumProductNo"/> 
</xs 9 
sequence> 
</xs- compl exType> 
</xs .el ement> 
<xs" el ement name="pl ays" mi nOccurs="O" maxOccurs="unbounded"> 
<xs" compl exType> 
<xs "sequence> 
<x s" e I eme n t n ame =" i n s t r ume n t "/> 
<xs "el ement name="j azzMusi ci an I D"/> 
<xs'element name="albumPubl i sher"/> 
<xs" el ement name=" al bumProductNo"/> 
</xs 9 
sequence> 
</xs 9 
compl exType> 
</xs :el ement> 
</xs 9 
sequence> 
</xs: compl exType> 
<xs'key name="pk album albumKey"> 
<xs'selector xpath="al bum"/> 
<xs'field xpath="publ isher"/> 
<xs:field xpath="productNo"/> 
</xs" key> 
<xs.key name="pk track trackNo"> 
<xs'selector xpath="track"/> 
<xs:field xpath="albumPubl isher"/> 
<xs :fiel d xpath="al bumProductNo"/> 
<xs'field xpath="trackNo"/> 
</xs. key> 
<xs" keyref name="fkmpl ays_al bum" refer="pk 
al bum_al bumKey"> 
<xs'selector xpath="pl ays"/> 
<xs "fiel d xpath="al bumPubl i sher"/> 
<xs.field xpath="al bumProductNo"/> 
</xs 9 
keyref> 
<xs" keyref name="fkmtrack 
al bum" refer="pk 
al bum_al bumKey"> 
<xs-selector xpath="track"/> 
<xs:field xpath="albumPubl isher"/> 
<xs :field xpath="al bumProductNo"/> 

410 
Chapter 11 
Reality Check: The World Is Relational 
</xs : keyref> 
<xs:keyref name="fk sampl e_al bum" refer="pk 
al bum_al bumKey"> 
<xs'sel ector xpath="sampl e"/> 
<xs:field xpath="albumPubl isher"/> 
<xs :fiel d xpath="a I bumProductNo"/> 
</xs 9 
keyref> 
<xs'keyref name="fk sample_track" refer="pkmtrack_trackNo"> 
<xs.sel ector xpath="sampl e"/> 
<xs.field xpath="albumPubl isher"/> 
<xs.field xpath="al bumProductNo"/> 
<xs'field xpath="trackTrackNo"/> 
</xs 9 
keyref> 
</xs "el ement> 
</xs .schema> 
11.$.$ Preserving Sequential Order 
Although we have ~ now remodeled the parent-child relations of the original 
schema by introducing primary and foreign keys, we still face some information 
loss: The cardinality constraints are gone. The constraint that an album must 
contain at least one track is no longer there! We cannot express this constraint 
in terms of relational syntax. Relational database systems, however, allow ex- 
pressing such constraints via Integrity Rules (see Section 11.9). 
And there is still another information loss: Repeating elements in XML are 
ordered. In the original document we would have been able to address the sec- 
ond track element with the XPath expression album/track[2]. In a relational 
table, in contrast, the rows form an unordered set. There is no guarantee that a 
query returns the rows in the sequence in which they were inserted. Fortu- 
nately, our track table contains a column trackN0. We could use this field to sort 
returned records when we query the database. If the sequence of the p lays and 
sampl e records were important, too, we would have to introduce similar num- 
bering fields into these elements. 
A document instance of our schema would now look like the following: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<database xml ns="http 9 
jazz. org/encyc I opedi a" 
xml ns" xs i =" ht tp'//www, w3. org/2001/XMLSchema- instance" 
xs i" schemaLocati on=" http 9 
jazz. org/encycl opedi a 
al bumRDB.xsd"> 
<al bum> 

11.5 
Normalization 
411 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<productNo>1780</productNo> 
<title>Inside out</titl e> 
</album> 
<al bum> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<productNo>1064</productNo> 
<title>The K61n Concert</title> 
</album> 
<track> 
<trackNo>l</trackNo> 
<title>From The Body</title> 
<duration xsi :ni l="true"></duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<al bumProductNo>1780</al bumProductNo> 
</track> 
<track> 
<trackNo>2</trackNo> 
<title>Inside Out</title> 
<duration xsi :nil="true"></duration> 
<a I bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<al bumProductNo>1780</al bumProductNo> 
</track> 
<track> 
<trackNo>3</trackNo> 
<title>341 Free Fade</title> 
<duration xsi :nil="true"></duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1780</a I bumProduct No> 
</track> 
<track> 
<trackNo>4</trackNo> 
<ti tl e>Ri ot</ti tl e> 
<duration xsi :nil="true"></duration> 
<a I bumPubl i sher>http://www, ecmrecords, com</a I bumPubl i sher> 

412 
Chapter 11 
Reality Check: The World Is Relational 
<a I bumProd uctNo> 1780</a I bumProductNo> 
</track> 
<track> 
<trackNo>5</trackNo> 
<title>When I Fall In Love</title> 
<duration xsi :ni l="true"></duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1780</a I bumProductNo> 
</track> 
<track> 
<t ra c kNo> 1</t rac kNo> 
<title>Part I</title> 
<duration xsi :nil ="true"x/duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1064</ai bumProductNo> 
</track> 
<track> 
<trackNo>2</trackNo> 
<title>Part IIa</title> 
<duration xsi :ni l ="true"x/duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1064</a I bumProductNo> 
</track> 
<track> 
<trackNo>3</trackNo> 
<title>Part IIb</title> 
<duration xsi :nil="true"></duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1064</a I bumProdu ct No> 
</track> 
<track> 
<trackNo>4</trackNo> 
<title>Part IIc</title> 
<duration xsi :ni l="true"></duration> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 

11.5 
Normalization 
413 
<a I bumProductNo> 1064</a I bumProductNo> 
</track> 
<sample> 
<MP3> 
http://www, j azz. org/sampl es/JarrettKei th/Insi deOut/FromTheBody 
</MP3> 
<t rac kTrac kNo> l</t rac kT rac kNo> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1780</a I bumProductNo> 
</sample> 
<plays> 
<i nstrument>pi ano</i nstrument> 
<j azzMusi ci an ID>JarrettKei th</j azzMusi ci an ID> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1780</a I bumProductNo> 
</plays> 
<plays> 
<instrument>double bass</i nstrument> 
<j azzMus i c i an I D>Peacoc kGa ry</j azzMus i c i an I D> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProduct No> 1780</a I bumProductNo> 
</plays> 
<plays> 
<i nst rument>drums</i nstrument> 
<j azzMus i c i an I D>DeJohnet teJ ac k</j azzMus i c i an I D> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1780</a I bumProductNo> 
</plays> 
<plays> 
<i nstrument>pi ano</i nstrument> 
<j azzMusi c i an ID>JarrettKei th</j azzMusi c i an ID> 
<al bumPubl i sher>http://www, ecmrecords, com</al bumPubl i sher> 
<a I bumProductNo> 1064</a I bumProduct No> 
</plays> 
</database> 

414 
Chapter 11 
Reality Check: The World Is Relational 
We now have a document with content in relational First Normal Form. The 
original element album that represented a business object is split into many sep- 
arate records distributed over various tables. 
11.5.6 Recomposing Original Document Nodes 
We could apply relational operations on the content to create composite 
records that combine records from the various tables. To recombine all the 
tables album, plays, track, and sample we would need to perform the following 
steps: 
1. Compute the natural left outer join between a l bum and p lays using the 
keys pk al bum_al bumKey and fk pl ays_al bum as a selection constraint. We 
choose the outer join because albums without p l ays elements are allowed. 
In the process, the fields albumPublisher and albumProductNo from table 
plays are removed. 
2. Sort the table track in ascending order using the field trackNo as sort 
criterion. 
3. Compute the natural join between the result from step 1 and the sorted 
track table from step 2 using the keys pk album_albumKey and fk track_ 
a l bum as a selection constraint. We do not use an outer join here because 
albums require at least one track. In the process, the fields albumPubl i sher 
and a l bumProductNo from table track are removed. 
4. Compute the natural left outer join between a l bum and sampl e using the 
keys pk al bum_al bumKey and fk sampl e_al bum as a selection constraint. We 
choose the outer join because albums without sample elements are al- 
lowed. In the process, the fields albumPublisher and albumProductNo from 
table sampl e are removed. 
5. Finally, we have to consider the relationship between sample and track. 
We throw out all records for which the selection constraint given by the 
keys pk track_trackNo and fk sample_track does not hold. After this op- 
eration, the column sample/trackTrackNo has become redundant. We per- 
form a projection to remove this column. 
6. We have a name clash. Both album and track contain a column named 
title. We rename these elements albumTitle and trackTitle. 
The above operations result in a set of records that looks like the following: 
<al bum> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<productNo>1780</productNo> 
<al bumTitl e>Inside out</al bumTi tl e> 
<j azzMus i c i an I D>Ja rret t Ke i th</j azzMu s i c i an I D> 
<i nstrument>pi ano</i nstrument> 
<t rac kNo> l</t rac kNo> 
<trackTitle>From The Body</trackTitle> 

11.6 Brief Introduction to SQL 
415 
<MP3> 
http ://www. jazz. org/samp I es/J arrett Kei th/l ns i deOut/FromTheBody 
</MP3> 
</album> 
<al bum> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<p rod u c t No> 1780</p rod u ct No> 
<al bumTitl e>Inside out</al bumTi tl e> 
<j azzMusi ci an I D>JarrettKei th</j azzMusi ci anlD> 
<i nstrument>pi ano</i nstrument> 
<trackNo>2</trackNo> 
<trackTitl e>Inside Out</trackTi tl e> 
<MP3> 
http://www, jazz. org/samp I es/J arrett Kei th/I ns i deOut / FromTheBody 
</MP3> 
</album> 
For every valid combination of album, plays, track, and sample we get a new 
record. What we do not get with pure relational operations is the nice tree struc- 
ture of the original document, although SQL provides some means for aggrega- 
tion in queries (see next section). This is left to application logic, either 
expressed in some programming language or by means of SQL-99 [Krishna- 
murthy2000]. 
11.6 BRIEF INTRODUCTION TO SQL 
This section gives a brief introduction to SQL-92 and then discusses how SQL- 
99 extends SQL-92. Note that this section is intended to give an overview about 
the features of SQL, not to provide an in-depth tutorial. Interested readers may 
refer to the many excellent textbooks about this topic, such as [Silberschatz 
2001]. Although implementations of SQL-99 are scarce and incomplete, it is 
important because the type and structural system of XML Schema was designed 
as a superset of the type and structural system of SQL-99. 
11.6.1 Queries 
The query part of SQL is based on relational algebra with certain modifications 
and enhancements. A typical SQL query looks like 
select 
Cl, C2 ..... 
Cn 
from t 1, t 2 ..... 
t m 
where P 

416 
Chapter 11 Reality Check: The World Is Relational 
with C1, C2 ..... 
C n being column names, tl, t2, .... 
t m being table names, and P 
a predicate. If a column name does not uniquely identify a column, it must be 
prefixed with the table name, using the familiar dot notation. This query is 
equivalent to the following relational operations: 
1. Constructing a Cartesian product from t~, t2 ..... 
t m. This is specified in the 
from clause by listing the participating tables. 
The from clause may also specify a join. This is done by specifying the 
join type (inner join, left outer join, right outer join, full outer join), the 
join predicate (natural, on predicate), and which columns of the join are 
used (using r 
C2 .... , Cn); for example: 
from (tl natural full outer join t 2 using C1, C2 ..... Cn) 
2. Applying a selection with predicate P. This is done in the where clause. The 
where clause allows comparisons between columns and/or constants. 
Comparisons between arithmetic expressions and between string expres- 
sions are possible, too. These comparisons can be combined in a Boolean 
expression with the operators and, or, and not. 
3. Projecting the result onto columns Cl, C2 ..... Cn. This is specified in the 
select clause. Alternatively, the sel ect clause may specify an asterisk (*) 
to denote all columns, meaning to skip this step. 
In contrast to pure relational theory, SQL allows duplicates in tables 
and query results. The keyword distinct can be specified after select to 
remove duplicates; the keyword all, to keep duplicates. 
The select clause can be used to apply arithmetic operations (+,-,*,/) 
on column names, provided these columns have a numeric type; for 
example: 
select prodNo, price*l.15 
Aggregating functions such as avg(), min(), max(), sum(), and count() 
are used to compute the average, minimum, maximum, sum, and num- 
ber of rows over columns. 
A variety of string operations (concatenation, substring, conversion 
from upper- to lowercase and vice versa, etc.) are also available. 
The sel ect clause can be used to rename the columns of the query re- 
sult using the keyword as. For example, 
select Cl, C 2 ..... C n as R 1, R 2 ..... R n 
renames the columns CI, C2, .... Cn to R 1, R 2 ..... R n. 
There are a few optional clauses that can be specified after the where clause: 
[] Sorting the result is possible by specifying the clause 
order by C~, Cj .... 

11.6 Brief Introduction to SQL 
417 
with Ci, Cj specifying the sort fields. The keywords asc or desc may be ap- 
pended to specify ascending or descending order. 
m Aggregation of query results is possible with the clause 
group by Ck, Cl .... 
This will result in a single result record for each combination of Ck and Cl. The 
sel ect clause must cumulate all columns that are not specified in the group by 
clause but are specified in the sel ect clause with aggregating functions such as 
sum() or avg(). 
It is possible to apply additional predicates on the results of the group by 
clause to select only certain rows from the result set obtained by group by. This 
is done with the clause 
havi ng Q 
where Q is a selection predicate. 
Select statements can be nestedmthat is, the result of a query can be used as 
an input table for another query. The where clause provides several operators to 
relate to such result sets. For example, 
select CI, C2 ..... 
an 
from tl, t2 ..... 
tm 
where P and (Ci, Cj) in 
(select DI, D2 
from Ul ~ u2, ~ 9 
9 
,Um 
where Q) 
tests whether the value tuple (Ci, Cj) is found in the result set of the nested 
query. Similarly, it is possible to test whether a given value is greater or smaller 
than all or some of the values returned by the nested query. 
Query results can be combined with set operations such as union, intersec- 
tion, and difference. This is done with the operators union, intersect, and 
except. A condition is that both operands of such an operation have an identi- 
cal column schema: 
( select Cl, C2 .... 
,C n from tl, t2 ..... t m where P ) 
union 
( select Cl, C2 .... ,CR from Ul, u2,...,Um where Q ) 
Although there is more to know about SQL queries, this should be sufficient 
for a brief introduction. In addition to queries, SQL provides commands 
for table creation, for inserting, updating, and deleting table rows, and for 
administration. 

418 
Chapter 11 
Reality Check: The World Is Relational 
11.6.2 Table Creation 
Tables are created with the create command: 
create table t (Cl DI , C2 D2 ..... 
Cn Dn , 
(i ntegri ty-constrai ntl), 
(i ntegri ty-constrai ntk) ) 
Cl, 
C 2 ..... 
C n define the column names, and D1, D2 .... ,D, define the data types 
of each column (see Section 11.7). Each of the C~ D~ pairs can be postfixed with 
not null to indicate that no null values are allowed in this column. 
Other integrity constraints are 
primary key (Ci, Cj .... ) 
to define a primary key consisting of the columns Ci, Cj .... (similar to the key 
clause in XML Schema), 
foreign key (Ci, Cj .... ) references r 
to define a foreign key consisting of the columns Ci, Cj,... (similar to the 
keyref clause in XML Schema) and referring to table t, and 
check P 
with P being a predicate over the columns Cl, 
C2 ..... Cn. This predicate is 
checked whenever a new row is inserted or a row is updated. 
The command alter table is used to modify existing tables (adding or re- 
moving of columns), and the command drop table is used to remove tables 
from a schema. 
11.6.3 Table Modification 
Rows can be deleted from a table with the de l ete command: 
delete from t where P 
The from clause specifies the table, the where clause (see Section 11.6.1) speci- 
fies a predicate P, which selects the rows to be deleted. 
New rows can be created with the insert command: 
insert into t values (Vl, v2 ..... 
Vn) 
The into clause specifies the table; the values clause specifies a value for each 
column. As rows in a table form an unordered set, it is not necessary to specify 
where to insert the new row. 

11.6 Brief Introduction to SQL 
419 
Existing rows can be modified with the update command: 
update t set Ci = E~, Cj = Ej .... where P 
The set clause specifies which columns should be modified. The expressions 
Ei, Ej are the new values and can consist of constants, or arithmetic or string 
algebraic expressions computing a new value. These expressions can refer to 
existing column values. The where clause (see Section 11.6.1) specifies a predi- 
cate P, which selects the rows to be modified. 
Multiple update, insert, and delete operations can be combined in transac- 
tions. The end of a transaction (and the beginning of the next) is defined with 
the commands commit work or rollback work. 
11.6.4 Views 
The ability to create views on a schema is an important facility of SQL. Views 
are typically used to give users restricted access to the tables of a schema. This 
allows decentralized maintenance of a data pool: In a large corporation, indi- 
vidual aspects of a table can be maintained by different departments without 
the need to perform each update through a central administration. For exam- 
ple, if we have a table customer, the sales department can be responsible for the 
sales contacts and sales history of a customer, the accounting department can 
be responsible for the customers' accounts, and so forth. 
In SQL a view is created with the create view command: 
create view v as Q 
Q can be any legal query expression, including query expressions across mul- 
tiple tables and on aggregations. The created view v can then be used in the from 
clause of a query instead of a table. 
Updates on views are possible, too, but they are restricted on views that are 
defined by simple query expressions. Most implementations, for example, do 
not support updates on views that are defined with query expressions contain- 
ing aggregates (group by). 
Views can be defined across multiple tables by utilizing SQL's join facilities. 
Such a view can represent a set of multiple tables as a single virtual table to the 
user. 
11.6.5 SQL-99 
SQL-99 introduces object-orientation into relational databases. By doing so, it 
departs from pure relational theory; consequently, the approach of SQL-99 is 
called object-relational. Nevertheless, SQL-99 maintains backward compatibility 
with earlier versions of SQL. The most important change is that SQL-99 allows 

4[20 
Chapter 11 
Reality Check: The World Is Relational 
non-atomic, structured table columns (also called nested tables). In particular, 
SQL-99 introduces built-in constructors such as row and array. It is also possible 
to define your own structured data types: 
create type T 
as (Cl DI, C2 D2 ..... Cn DR) 
C1, 
C 2 ..... 
C n define the column names, and D1, D2 ..... 
D n define the data 
types of each column, including other structured types and collections. These 
data types can be used everywhere types are specified, including the create 
table command. 
We can access the components of such a structured type by using the famil- 
iar dot notation, for example, customer.name.first. User-defined types cannot be 
used directly in arithmetic expressions and comparisons; instead the user must 
provide appropriate access methods. Such methods are declared in the create 
type command: 
create type T 
as (Cl DI, C2 D2 ..... CR Dn) 
method m (Ci Di , Cj Dj .... ) 
But they must be implemented in a separate clause: 
create method (C~ D~, Cj Dj .... ) for T 
begin 
set self.Ck = Ek; 
set self.Cn = En; 
end 
Ek, 9 .., En are expressions derived from the parameters Ci, Cj..... The table 
columns are addressed via sel f. Ck, 9 
9 
9 self. C n. 
SQL-99 allows the construction of type hierarchies. The expression 
create type T1 under T2 
establishes an inheritance relationship where T1 inherits columns and methods 
from T2. 
Tables can be derived from a type, 
create table t of T 
with t specifying the table name and T the name of a defined type. The table t 
is created with a column for each property of type T. The table also inherits the 
methods of T. In terms of object-oriented programming, each row in table t is 
now an instance of type T. Because these rows are regarded as objects, an object 

11.7 Simple Data Types 
421 
identifier is generated for each row. These object identifiers can be used to refer 
to these rows. It is possible to store such identifiers in other tables: Their data 
type is ref (t), with t identifying the table that is referred to. This reference data 
type allows the new pointer notation in queries: 
SELECT tl.Ci-> Ck 
Given that Ci is a column of type ref(t2), this expression results in column 
tz.Ck with the rows identified by the object identifiers stored in tl.Ci. 
Of course, there is much more to SQL-99. Its features would surely fill a book 
of its own. 
11.7 SIMPLE DATA TYPES 
For the description of SQL data types, I refer to the current working draft for 
SQL 200x (SQL-4) [Melton2001]. Earlier SQL standards (SQL-99, SQL-92, etc.) 
and existing implementations differ in some points from this description. How- 
ever, this working draft is currently the best reference point for comparing XML 
Schema data types with SQL data types. The mapping between XML Schema 
data types and SQL data types is described in detail in [Melton2OOla] and 
[Eisenberg2002]. 
11.7.1 String Data Types 
The primitive data type string as defined in XML Schema is based on the Uni- 
code character set (independent of the actual encoding!) and is of unlimited 
length. In SQL there are several corresponding character string types: CHARACTER, 
CHARACTER VARYING, CHARACTER LARGE OBJECT (CLOB). (There are also other spellings, 
such as CHAR and VARCHAR, which are used in earlier SQL editions.) CLOBs are 
restricted in certain aspects: They cannot be used in primary or foreign keys or 
unique column combinations. 
All character string types are based on character sets supported by SQL. SQL 
supports various character sets, including ASCII and Unicode. This may require 
that XML strings be mapped to SQL strings and vice versa. This mapping is 
implementation defined. In addition, SQL string data types have a fixed or max- 
imum length. The data type CHARACTER has a fixed, schema-defined length (the 
maximum length is implementation defined, varying between 255 and 4,000 in 
implementations), while the data type CHARACTER VARYING supports strings of 
variable length. Again, the maximum length is implementation defined. The 
CHARACTER LARGE OBJECT typically supports string lengths of up to 2GB. In XML, 
these data types can be modeled by restricting the string data type with the 
constraining facets 1 ength or maxLength. 
In SQL, there are no equivalent standard data types for XML Schema data 
types derived from string, such as normal izedString or token. 

422 
Chapter 11 Reality Check: The World Is Relational 
11.7.2 Binary Data Types 
Since XML is text based, it does not support binary data in native format. 
Instead, XML Schema offers two encoded binary formats: hexBinary and 
base64Bi nary. Both formats support binary data of unlimited length. 
SQL supports the binary data type BINARY LARGE OBJECT that supports 
large strings of binary data. (Earlier SQL standards also recognize BIT and BIT 
VARYING.) 
11.7.3 The Boolean Data Type 
XML Schema supports Boolean values with the data type boolean. SQL supports 
Boolean values with data type BOOLEAN. 
11.7.4 Exact Numeric Types 
The only primitive exact numeric data type in XML Schema is decimal. All other 
exact data types such as integer, long, i nt, short, and so on, are derived from 
this data type by restriction. XML Schema does not restrict the upper and lower 
bound of decimal but requires processors to support at least 18 decimal digits. 
The SQL data type DECIMAL is almost equivalent to the decimal data type in XML 
Schema. The maximum number of decimal digits is implementation defined, 
ranging from 18 to 38 decimal digits. 
There is no direct equivalent for the XML Schema integer data type in 
SQL. However, this data type can be represented in SQL by data type DECIMAL 
with no fractional digits. For the following integer data types there is a direct 
equivalence: 
XML 
SQL 
Range 
long 
BIGINT- 
int 
INTEGER 
short 
SMALLINT 
9,223,372,036,854, 775,808 
9,223,372,036,854, 775,807 
-2,147,483,648 
2,147,483,647 
-32,768 
32,767 
11.7.5 Approximate Numeric Types 
XML Schema supports the approximate numeric types float and double for sin- 
gle and double precision floating-point numbers according to IEEE 754-1985. 
With these data types we find the highest compatibility between SQL and O0 
languages, as IEEE 754-1985 has been adopted by SQL-92 and practically all O0 
languages. However, the naming can be confusing: 

11.7 Simple Data Types 
423 
XML 
SQL 
Precision 
float 
REAL 
32 bit 
double 
FLOAT 
64 bit 
The SQL data type DOUBLE PRECISION (128 bit) does not have an equivalent in 
XML Schema. 
11.7.6 Date and Time 
XML Schema provides a rich set of date and time data types based on ISO 8601. 
dateTime specifies a precise instant in time (a combination of date and time), 
date specifies a Gregorian calendar date, and time specifies a time of day. All 
three types can be specified with or without a time zone. The data type duration 
specifies an interval in years, months, days, hours, minutes, and seconds, and 
allows negative intervals, too. 
SQL supports date and time values with the data types TIME, DATE, and TIME- 
STAMP. While both TIME and TIMESTAMP can be specified with or without a time 
zone, DATE can only be specified without a time zone. (Note: The ODBC data- 
base interface does not support TIME and TIMESTAMP with time zone.) TIME and 
TIMESTAMP support fractions of seconds. The resolution is implementation 
dependent. 
SQL provides a data type INTERVAL with features similar to the XML Schema 
data type duration. However, not many DBMSs implement this data type. 
11.7.7 Other Data Types 
XML Schema supports URIs with the data type anyURI. SQL does not have an 
equivalent to anyURI. However, URIs can easily be stored in CHARACTER VARYING 
fields. 
The QName data type in XML Schema specifies qualified names. It consists of a 
local part and a namespace part. It is relatively easy to represent such a qualified 
name in SQL: It is simply mapped to a tuple consisting of a namespace URI and 
the local name (both stored in CHARACTER VARYING columns). Note that it would 
be wrong just to store a qualified name as a local name with a prefix! The map- 
ping between prefix and namespace may change at any time. 
11.7.8 Type Restrictions 
XML Schema provides a rich set of constraining facets to derive user-defined 
simple data types from built-in data types. SQL allows parameterizing built-in 
types but in a limited way. For example, it is possible to control the length of a 
CHARACTER column, or to control the number of decimal and fractional dig- 
its in a DECIMAL column. Other parameters such as the constraining facets 

424 
Chapter 11 Reality Check: The World Is Relational 
minlnclusive or maxExclusive in XML Schema do not exist in the SQL type sys- 
tem. However, SQL offers other ways to constrain the value of a column (see 
Section 11.9). 
11.7.9 Type Extensions 
Restriction is not the only way in XML Schema to derive user-defined types. 
Type extensions such as type union and extension by list are possible, too. SQL- 
92 has no equivalent construct. If such types must be mapped onto relational 
types, the only choice is to store values of these types in their lexical represen- 
tation, that is, to use the type CHARACTER VARYING or CLOB in SQL. In contrast, 
SQL-99 allows representing list extensions by defining an ARRAY. A LIST collec- 
tion type is planned for future versions. 
11.7.10 Null Values 
All SQL data types support the notion of null values. XML Schema allows n ill 
values for elements but not for attributes (see Section 5.3.16). 
11.8 COMPLEX TYPES 
Section 11.5 already showed a few examples of how complex types can be 
mapped onto relational structures. We have seen that relational fields that may 
either contain a value or null can represent optional elements. We have also 
seen that repeating elements almost always result in a separate table. Each 
record in this table contains a foreign key referring to the primary key of the 
former parent element. 
This section discusses how to express hierarchy in relational terms, and how 
to implement the three basic regular expression operators (sequence, choice, 
recursion) with the relational methods of SQL-92. 
SQL-99, in contrast, allows the definition of structured types. These types can 
then be used in a column definition to declare a column of complex content. 
Of course, this can make the SQL representation of XML content much 
simpler. 
11.8.1 Hierarchy 
Leaf elements (elements that do not contain child elements) of a cardinality 
<- 1 and attributes can be implemented as simple table columns (see Table 
11.1). Complex elements and leaf elements with cardinality > 1, however, must 
be implemented as tables. Equipping the parent with a primary key and the 
child with a foreign key referring to this primary key can preserve parent-child 
relationships. 

11.8 Complex Types 
425 
Table 11.1 Translating leaf elements into a relational schema. Note that we 
have to constrain the maximum length of string values, as SQL 
requires specifying a maximum length for VARCHAR. 
XML Schema 
SQL-92 
<xs :el ement name="track"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="trackNo" 
type="xs: unsi gnedByte"/> 
<xs:element name="titl e" 
type="xs :stri ng"/> 
<xs :element name="duration" 
type=" xs: uns i gnedShort" 
mi nOccurs =" 0"/> 
</xs: sequence> 
</xs: compl exType> 
</xs:el ement> 
<xs: key name="pTrack"> 
<xs: sel ector xpath="track"/> 
<xs :fiel d xpath="trackNo"/> 
</xs:key> 
CREATE TABLE track 
( trackNo SMALLINT NOT NULL, 
title VARCHAR(255) NOT NULL, 
duration INTEGER, 
PRIMARY KEY ( trackNo ) 
) 
Take for example the track element in the example in Section 11.5. Element 
track is a complex child element of album. Because it is complex, we have to 
implement it as a separate table. We introduce two fields albumPublisher and 
a l bumProductNo to form a foreign key. This key refers to the primary key defined 
for table a l bum, which consists of the fields publisher and productNo (see Table 
11.2). 
Because track is defined as a repeating element in album, we also add the 
fields al bumPubl i sher and al bumProductNo to the primary key of track. Otherwise 
the key would not be unique, as trackN0 is only unique within the context of 
one al bum instance. 
In some cases, however, the creation of a separate table for a complex ele- 
ment can be overkill. Take for example a complex element such as 
name(first,middle?,last). In such cases we are better off resolving this element 
into three leaf elements, such as name_first, name_middle?, name_last. 
As mentioned above, SQL-99 solves this problem by introducing user-defined 
structured types. It would be possible to define a structured type for 
name (firs t ,mi ddl e ?, l as t), 
CREATE TYPE personName 
AS ( first VARCHAR(20) NOT NULL, 
mi dd I e CHAR (2) 
last VARCHAR(30) NOT NULL 
) 

426 
Chapter 11 
Reality Check: The World Is Relational 
Table 11.2 Translating complex element track into a relational schema. 
XML Schema 
SQL-92 
<xs: el ement name="al bum"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="publ i sher"/> 
<xs "el ement name="productNo"/> 
<xs:element name="ti tl e"/> 
<xs :el ement name="track" 
maxOccurs="unbounded'~ 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement name="trackNo"/> 
<xs:element name="ti tl e"/> 
<xs :el ement name="durati on" 
mi nOccurs=" 0"/> 
</xs:sequence> 
</xs: compl exType> 
</xs:el ement> 
</xs :sequence> 
</xs: compl exType> 
<xs: key 
name=" pkmal bum_al bumKey"> 
<xs:selector xpath=" ."/> 
<xs:field xpath="publ isher"/> 
<xs: field xpath=" productNo"/> 
</xs:key> 
</xs :el ement> 
CREATE TABLE album 
( publ i sher 
VARCHAR(255) NOT NULL, 
productNo 
CHAR(32) NOT NULL, 
title 
VARCHAR(255) NOT NULL, 
PRIMARY KEY 
(publ i sher, productNo ) 
) 
CREATE TABLE track 
( trackNo SMALLINT NOT NULL, 
title VARCHAR(255) NOT NULL, 
duration INTEGER, 
al bumPubl i sher 
VARCHAR(255) NOT NULL, 
al bumProductNo 
CHAR(32) NOT NULL, 
PRIMARY KEY (al bumPubl i sher, 
al bumProductNo, 
trackNo), 
FOREIGN KEY 
( albumPubl isher, 
al bumProductNo ) 
references al bum 
) 
and then use it in a column definition: 
CREATE TABLE person 
( name personName NOT NULL, 
ID VARCHAR (32) 
) 
The subfields of a type can be accessed via a dot notation, such as 
person, name. Iast 
11.8.2 Sequence 
Again, as far as leaf elements are concerned, sequence is easy to establish. A 
sequence of leaf elements is simply translated into a sequence of table columns. 

11.8 Complex Types 
427 
However, for complex elements we lose this sequence information when the 
complex element forms a table. If the sequence of complex child elements is 
essential, we must make sure in later queries that the various tables are joined in 
the right sequence. The SQL query 
SELECT * FROM album NATURAL LEFT OUTER JOIN track WHERE ... 
joins the two tables album and track in the correct order. The * notation after 
the SELECT stands for "all fields." In this case, where more than one table is 
specified after the FROM keyword, it delivers the Cartesian product. 
In our case, however, it would be better to perform an explicit projection. 
There are three reasons for this: First, we were just lucky that the album schema 
specified all leaf elements in front of the complex element track. If, for exam- 
ple, the element title followed the element track, the query shown above 
would deliver the wrong result. Second, we need to rename a column because 
both a l bum and track contain a t i t l e column. Third, we would like to remove 
the duplicate columns publ i sher/al bumPubl i sher and productNo/al bumProductNo. 
SELECT publ i sher, 
productNo, 
album.title AS albumTitle, 
trackNo, 
track.title AS trackTitle, 
duration 
FROM album NATURAL LEFT OUTER JOIN track 
WHERE ... 
The AS clause is used to rename a column. 
For repeating elements (which form their own table), sequence information 
is lost, too. Rows in relational databases form an unordered set. To maintain the 
sequence information between the element occurrences, we must equip each of 
the table rows with a field that numbers the rows in the original sequence, such 
as trackN0 in the table track. Later queries can then use the ORDER BY operation 
to reestablish the original sequence. 
SELECT publ i sher, 
productNo, 
album.title AS albumTitle, 
trackNo, 
track.title AS trackTitle, 
duration 
FROM album NATURAL LEFT OUTER JOIN track 
WHERE ... 
ORDER BY publisher, productNo, trackNo 

428 
Chapter 11 
Reality Check: The World Is Relational 
11.8.3 Choice 
A construct such as the choice connector does not exist in relational schemata. 
If the choice connector combines two leaf elements, the implementation is rel- 
atively easy: Both elements become fields in the table. In each row, one of the 
fields must have a value and the other must be null (see Table 11.3). 
For complex elements combined by a choice connector, the situation is 
tricky. Both elements are implemented as a table that points via a foreign key to 
the parent table. If we want to reconstruct the document instances in a query, 
we must compute the union of two subqueries: The first subquery joins the par- 
ent table with the left child table; the second subquery joins the parent table 
with the right child table. However, unions are only possible when both 
operands have the same structure. This can sometimes require some ingenuity. 
The general solution is to cast all noncompatible fields of each operand into a 
character string and then concatenate these fields into a single character string. 
This allows a successful union of both subqueries. 
Let's assume the following table structure: 
CREATE TABLE item 
( amount INTEGER NOT NULL, 
productNo CHAR(32) NOT NULL, 
price DECIMAL(12,2) NOT NULL, 
PRIMARY KEY ( productNo ) 
) 
Table 11.3 Translating leaf element choices into a relational schema. Note 
that one of the columns amount or quanti ty must be null. 
XML Schema 
SQL-92 
<xs: el ement name="i tem"> 
<xs: compl exType> 
<xs: sequence> 
<xs: choice> 
<xs: el ement name="amount" 
type="xs: unsi gnedShort"/> 
<xs: el ement name=" quant i ty" 
type="xs: decimal "/> 
</choice> 
<xs :el ement name="productNo" 
type = "xs : NMTO KEN "/> 
</xs: sequence> 
</xs: compl exType> 
</xs :el ement> 
CREATE TABLE item 
( amount INTEGER, 
quantity DECIMAL, 
productNo CHAR(32) NOT NULL, 
) 

11.8 Complex Types 
429 
CREATE TABLE product 
( productNo CHAR(32) NOT NULL, 
name VARCHAR(40) NOT NULL, 
descri pti on (255) 
FOREIGN KEY 
( al bumProductNo ) 
references al bum 
) 
CREATE TABLE course 
( productNo CHAR(32) NOT NULL, 
name VARCHAR(40) NOT NULL, 
duration INTEGER, 
trainer VARCHAR(20), 
FOREIGN KEY 
( a lbumProductNo ) 
references al bum 
) 
Now let's assume that an item is the parent of either a product or a course. 
Product and course have a different layout, so a direct union is impossible. The 
following SQL query solves the problem: 
( SELECT amount, 
productNo, 
price, 
name, 
description 
FROM item NATURAL INNER JOIN product ) 
UNION 
( SELECT amount, 
productNo, 
price, 
name, 
'<duration>' ]] (CAST duration AS VARCHAR(IO)]] '</duration>' 
]] '<trainer>' J] trainer ]] '</trainer>' 
FROM item NATURAL INNER JOIN course ) 
In the second SELECT clause we use string concatenation to combine duration 
and trainer into a single character string. This string is type compatible with 
description, so the UNION operator can succeed. 
In SQL-99 the problem of alternative complex types is much simpler to solve. 
Both product and course can be defined as structured types. Table items would 
simply contain two additional columns product and course, where either one or 
the other is null. Querying this table would require neither a join nor a union. 

430 
Chapter 11 
Reality Check: The World Is Relational 
Table 11.4 Translating recursive elements into relational structures. 
XML Schema 
SQL-92 
<xs: el ement name="part"> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement name="productNo" 
type = "x s: NMTO KEN "/> 
<xs:el ement name:"name" 
type:"xs: string"/> 
<xs: el ement ref="part" 
mi nOccurs:"O" 
maxOccurs="unbounded"/> 
</xs: sequence> 
</xs: compl exType> 
</xs :element> 
CREATE TABLE part 
( productNo CHAR(32) NOT NULL, 
name VARCHAR(255) NOT NULL, 
PRIMARY KEY ( productNo ), 
FOREIGN KEY 
( productNo )references part 
) 
CREATE TABLE item 
( amount INTEGER NOT NULL, 
price DECIMAL(12,2) NOT NULL, 
product product, 
course course 
) 
11.8.4 
Recursion 
Recursion is relatively easy to model. The recursive element is implemented as a 
table. This table has a primary key and a foreign key, with the foreign key refer- 
ring to this primary key (see Table 11.4). 
However, recursion is not easy to query: 
Only SQL-99 introduces the ability to query recursive structures with an arbi- 
trary depth. In earlier SQL standards it is possible to query such structures only 
to a limited depth. 
1 1.9 
CONSTRAINTS 
SQL defines a rich arsenal for validating the integrity of relational data: 
n Domain constraints are the most elementary form of integrity constraints. Do- 
main constraints are used to constrain the value of a single column. They are 
used to test values inserted into the database and to test queries to make sure 
that a comparison is valid. Domain constraints resemble the constraining 
facets for simple types in XML Schema but have more expressive power. For 
example, a domain constraint can contain a subquery, thus allowing the im- 
plementation of cross-field constraints. 

11.9 Constraints 
431 
SQL-99 introduces a S IMI LAR predicate to test whether strings conform to reg- 
ular expression syntax. This is comparable to the pattern facet in XML 
Schema, which constrains the lexical space of a data type to conform to the 
specified regular expression syntax. Consequently, the predicate SIMILAR can 
be used to mimic this constraining facet. 
m Referential integrity constraints are used to declare columns or combinations of 
columns as unique, as a primary key, or as a foreign key. This functionality is 
practically equivalent to the unique, key, and keyref constructs in XML 
Schema. These constraints are applied when records are inserted, updated, or 
deleted. Operations that would violate these constraints are rejected. 
[] Cascading actions allow the DBMS to automatically maintain referential in- 
tegrity by propagating operations such as DELETE or UPDATE along referen- 
tial chains. For example, in our small database in Section 7.2.4, we estab- 
lished primary/foreign key relations from the tables plays, track, and sample 
to table a l bum. If we deleted an a l bum record, a cascading delete operation 
would also delete all records from plays, track, and sample that referred to 
this specific album record. 
[] General assertions are constraints that the database must always satisfy. An as- 
sertion defines a general query with a Boolean result. This query is executed 
with each operation that is performed on a table for which the assertion is 
defined. If the query fails, the operation is rejected. Since general assertions 
can contain complex queries, they can cause considerable overhead. There is 
no equivalent construct in XML Schema, but when storing XML documents 
in a relational database, general assertions can be used to maintain the struc- 
tural integrity of the document instances. 
[] Triggers consist of SQL statements that are executed automatically by the 
DBMS as a side effect of database operations. Triggers contain a criterion that 
specifies under which conditions the specified statements are executed. Trig- 
gers are not defined in SQL-92, but many database implementations support 
them. SQL-99 defines a standardized model for triggers. 
As you can see, the support for constraints in SQL far surpasses the possibili- 
ties provided by XML Schema. However, not every mechanism defined in the 
standard is implemented in existing DBMSs. For example, Oracle 9i does not 
support general assertions but supports triggers. 
11.10 FROM RELATIONAL TABLES TO XML SCHEMA 
Translating relational data into XML is a frequent operation. Especially when 
legacy enterprise data must be put on the Web, XML is the format of choice 
because XML is ideally suited to act as a pivot format from which many other 
web formats can be generated (Figure 11.4, page 432). The relational data is first 
translated into a presentation-neutral XML format, which can then be trans- 
formed into the target formats. 

432 
Chapter 11 Reality Check: The World Is Relational 
F 
XML 
<cd-order> 
<customer> 
<name> 
<first>John</first> 
<last>Doe</last> 
</name> 
<customer> 
<item> 
<amount>l </amount> 
<productNo>7234-4</productNo> 
<title>Cool Cats</title> 
</item> 
</cd-order> 
.
.
.
.
.
.
.
.
.
 
Figure 11.4 XML in the role of a pivot data format. 
~1-1 HTMLI 
-I-I WMLI 
---J PDFI 
Constructing an XML schema from a relational table definition is simple and 
straightforward. The table is converted into an XML element; the sequence of 
table columns is converted into a sequence of child elements. Mapping SQL 
data types to simple XML Schema data types is also not a problem (see Section 
11.6). Primary keys are converted into key clauses; foreign keys are converted 
into keyref clauses. Unique constraints are converted into unique clauses. Also, 
some suitable domain constraints may be represented by user-defined simple 
data types obtained by applying the appropriate constraining facets to built-in 
XML Schema data types. 
However, with this technique, we only arrive at flat normalized XML 
schemata, similar to the one obtained in Section 11.5. To construct a deeply 
nested, treelike XML data structure from a relational schema requires a different 
approach: 
u If we are still in possession of the conceptual model that served as a basis for 
the relational implementation, we can use this conceptual model to create 
the XML schemata. We can then map the elements of the relational schema 
onto the elements of the XML schema. 
u If we are only in possession of the relational schema, a serious reengineering 
effort is required. 
In the first step we re-create the conceptual model (see Chapters 2 and 3). 
Each table is remodeled as an asset; the table columns become properties. 
Foreign/primary key relations are translated into an arc originating from the 
asset to which the primary key belongs. The cardinality constraint of all arcs is 
"*" (no cardinality constraint). 
However, this model is not really complete. We are unable to learn from the 
relational schema which columns and which key relationships represent alter- 

11.11 
Mediation between RDBMS and XML Databases 
433 
natives. In many cases, it will be impossible to find out if two fields or two child 
tables are mutually exclusive. In some cases, however, this knowledge may be 
hidden in SQL constraints and SQL queries. 
In the second step we determine Level 2 Structures, and in the third step we 
translate the conceptual model into XML Schema (see Chapter 8). 
11.11 
MEDIATION 
BETWEEN RDBMS 
AND XML DATABASES 
In this section we introduce two commercial products, Tamino X-Node and 
Experanto, that can mediate between relational data structures and XML. 
11.11.1 Tamino X-Node 
Software AG's (www.softwareag.com) Tamino XML Server is one of the leading 
native XML databases. Tamino is able to handle generic (schema-less) XML doc- 
uments, but for the most efficient operation it requires the definition of 
schemata where it uses a subset of XML Schema. Document instances can be 
validated against the schema. 
In addition, a Tamino schema describes physical propertiesmfor example, 
which document nodes should be used to index the document, and in which 
form. These additional definitions are included in appinf0 sections in the 
schema file. These appi nf0 sections can also contain information about the stor- 
age location of each node--as native XML data within the Tamino data storage, 
or as relational data. Via its X-Node component, Tamino can access connected 
(and possibly remote) RDBMSs. Since the storage location can differ from docu- 
ment node to document node, Tamino can compose virtual XML documents 
from data stored in its own data storage, in relational databases, or other data 
sources. This not only works for retrieval but also for update, store, and delete 
operations. The following gives an overview of how the mapping between XML 
nodes and relational tables and columns is described within the schema's 
appi nfo sections. 
Let's assume that we store information about jazz albums in a relational data- 
base. The following tables are defined: 
CREATE TABLE album 
( publisher VARCHAR(255) NOT NULL, 
productNo CHAR(32) NOT NULL, 
title VARCHAR(255) NOT NULL, 
PRIMARY KEY (publisher, productNo ) 
) 
CREATE TABLE track 

434 
Chapter 11 
Reality Check: The World Is Relational 
( trackNo SMALLINT NOT NULL, 
title 
VARCHAR(255) NOT NULL, 
duration INTEGER, 
albumPublisher VARCHAR(255) NOT NULL, 
albumProductNo CHAR(32) NOT NULL, 
PRIMARY KEY ( albumPublisher, albumProductNo , trackNo ), 
FOREIGN KEY ( albumPublisher, albumProductNo ) 
references al bum 
) 
CREATE TABLE plays 
( albumPublisher VARCHAR(255) NOT NULL, 
albumProductNo CHAR(32) NOT NULL, 
jazzMusicianlD VARCHAR(64) NOT NULL, 
PRIMARY KEY ( al bumPubl i sher, al bumProductNo , 
jazzMusicianlD, 
instrument ), 
FOREIGN KEY ( albumPublisher, albumProductNo ) 
references al bum 
FOREIGN KEY (jazzMusicianlD) 
references jazzMusician 
We want to map these SOL schemata to an XML schema similar to the album 
schema in Chapter 8. In the process, we want to extend the schema and add a 
sampl e node. The resulting XML Schema could look like the following: 
<xs : schema xml ns :xs = "http://www.w3.org/2OO1/XMLSchema" 
targetNamespace = "http://www.jazz. org/encycl opedi a" 
el ementFormDefaul t = "qual ified" 
xmlns = "http://www.jazz.org/encyclopedia"> 
<xs: el ement name = "al bum"> 
<xs: compl exType> 
<xs:sequence> 
<xs:element name = "publisher" type = "xs:anyURl"/> 
<xs:element name = "productNo" type = "xs:NMTOKEN"/> 
<xs:element name = "title" 
type = "xs:string"/> 
<xs:element ref = "track" maxOccurs = "unbounded"/> 
<xs:element ref = "sample" 
minOccurs = "0" maxOccurs = "unbounded"/> 
<xs:element ref = "plays" 
minOccurs = "0" maxOccurs = "unbounded"/> 
</xs :sequence> 
</xs: compl exType> 

11.11 
Mediation between RDBMS and XML Databases 
435 
</xs :el ement> 
<xs:element name = "track"> 
<xs: compl exType> 
<xs :sequence> 
<xs:element name = "title" type = "xs:string"/> 
<xs:element name = "duration" type = "xs:int" 
mi nOccurs = "0"/> 
</xs :sequence> 
<xs:attribute name = "trackNo" type = "xs:ID" use = "required"/> 
</xs: compl exType> 
</xs :el ement> 
<xs:element name = "sample"> 
<xs: compl exType> 
<xs :sequence> 
<xs:element name = "MP3" type = "xs:anyURl"/> 
<xs:element name = "track"> 
<xs: compl exType> 
<xs:attribute name = "trackNo" 
type = "xs: IDREF" use = "requi red"/> 
</xs: compl exType> 
</xs :el ement> 
</xs: sequence> 
</xs: compl exType> 
</xs :el ement> 
<xs:element name = "plays"> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name = "instrument" type = "xs:token" 
maxOccurs = "unbounded"/> 
<xs:element name = "jazzMusician"> 
<xs: comp I exType> 
<xs:all> 
<xs:element name = "ID" type = "xs:NMTOKEN"/> 
</xs:all> 
</xs: compl exType> 
</xs: el ement> 
</xs: sequence> 

4[36 
Chapter 11 Reality Check: The World Is Relational 
</xs : comp I exType> 
</xs: el ement> 
</xs: schema> 
Note that the duration element has type xs:int instead of xs:duration. This 
was derived from the SQL tables where duration was defined as INTEGER. Most 
SQL databases do not support the SQL data type INTERVAL. We have also added 
the definition for element sample and have established a cross-reference 
between sample and track. 
We can now use this schema as input for Tamino's Schema editor, as shown 
in Figure 11.5. This editor allows us to map the schema nodes to physical 
resources such as SQL tables and columns. Basically, each complex element 
such as track and pl ays is mapped to the corresponding SQL table. The leaf ele- 
ments and attributes, in contrast, are mapped to columns of those tables. The 
exceptions are the element sample and its child elements. These elements are 
mapped to native fields within Tamino. The consequence is that album 
instance documents reside in part within Tamino and in part in the connected 
ODBC database. Nevertheless, it is possible to execute complex queries and to 
perform update operations (which are carried forward to the connected ODBC 
database). 
Let's take a closer look at how the definition of the album node looks now: 
<xs:schema 
xml ns :xs = "http://www.w3.org/2OO1/XMLSchema" 
xml ns:tsd = 
"http://namespaces. softwareag, com/tami no/Tami noSchemaDefini t i on" 
el ementFormDefaul t = "qual ified"> 
<xs:annotation> 
<xs:appinfo> 
<tsd:schemalnfo name = "album"> 
<tsd:collection name = "encyclopedia"/> 
<tsd:doctype name = "schema"> 
<tsd:logical> 
<tsd: content>cl osed</tsd: content> 
</tsd:logical> 
</tsd:doctype> 
</tsd: schemalnfo> 
</xs :appinfo> 
</xs: annotati on> 
<xs:element name : "album"> 
<xs:annotation> 

11.11 
Mediation between RDBMS and XML Databases 
437 
Figure 11.5 The album schema in the Tamino Schema Editor. 
<xs :appinfo> 
<tsd: el ement Info> 
<tsd:physical> 
<tsd.map> 
<tsd:subTreeSQL schema = "jazz" 
table = "album" 
useri d = "bd" 
password = "password" 
datasource = "j azzODBC" 
sq I p ri ma rykeys = "&quot; pub I i s her&quot; 
&quot; productNo&quot; "/> 

438 
Chapter I l 
Reality Check: The World Is Relational 
</tsd.map> 
</tsd:physical> 
</tsd: el ement I nfo> 
</xs :appi nfo> 
</xs: annotati on> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name = "publisher" type = "xs:anyURI"> 
<xs: annotati on> 
<xs:appinfo> 
<tsd: el ement I nfo> 
<tsd:physical> 
<tsd.map> 
<tsd:nodeSQL column = "publisher"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement Info> 
</xs:appinfo> 
</xs: annotat i on> 
</xs :el ement> 
<xs:element name = "productNo" type = "xs:NMTOKEN"> 
<xs:annotation> 
<xs:appinfo> 
<tsd: el ement Info> 
<tsd:physical> 
<tsd.map> 
<tsd:nodeSQL column = "productNo"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement I nfo> 
</xs :appi nfo> 
</xs: annotati on> 
</xs :el ement> 
<xs:element name = "title" type = "xs:string"> 
<xs:annotation> 

11.11 
Mediation between RDBMS and XML Databases 
439 
<xs :appinfo> 
<tsd: el ement Info> 
<tsd:physical> 
<tsd.map> 
<tsd:nodeSQL column = "title"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement Info> 
</xs:appinfo> 
</xs: annotati on> 
</xs :el ement> 
<xs:element ref = "track" maxOccurs = "unbounded"/> 
<xs:element ref = "sample" 
minOccurs = "0" maxOccurs = "unbounded"/> 
<xs:element ref = "plays" 
minOccurs = "0" maxOccurs = "unbounded"/> 
</xs: sequence> 
</xs :compl exType> 
</xs: el ement> 
<xs:element name = "track"> 
<xs: annotati on> 
<xs:appinfo> 
<tsd: el ement I nfo> 
<tsd:physical> 
<tsd.map> 
<tsd: subTreeSQL 
schema = "jazz" 
table = "track" 
userid = "bd" 
password = "password" 
datasource = "jazzODBC" 
sql pri marykeys=" &quot; a I bumPubl i sher&quot; 
&quot; al bumProductNo&quot; 
&quot; trackNo&quot; "> 
<tsd: access Predicate> 
al bumProductNo = al bum. productNo 
AND albumPublisher = album.publisher 
</tsd: accessPredi care> 

440 
Chapter 11 
Reality Check: The World Is Relational 
</tsd: subTreeSQL> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement Info> 
</xs :appi nfo> 
</xs: annotati on> 
<xs: compl exType> 
<xs: sequence> 
<xs: el ement 
<xs:annota 
<xs:appi 
<tsd:e 
<tsd 
<tsd.map> 
name = "title" type = "xs:string"> 
tion> 
nfo> 
I ementlnfo> 
:physical> 
<tsd:nodeSQL column = "title"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement I nfo> 
</xs :appinfo> 
</xs: annotati on> 
</xs :el ement> 
<xs:element name = "duration" type = "xs:int" minOccurs = "0"> 
<xs: annotati on> 
<xs:appinfo> 
<tsd: el ement Info> 
<tsd:physical> 
<tsd.map> 
<tsd:nodeSQL column = "duration"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement Info> 
</xs :appinfo> 
</xs: annotati on> 
</xs: el ement> 

11.11 
Mediation between RDBMS and XML Databases 
441 
</xs 9 
sequence> 
<xs.attribute 
name = "trackNo" type = "xs'ID" use = "required"> 
<xs.annotation> 
<xs .appinfo> 
<tsd" attri butel nfo> 
<tsd.physical> 
<tsd.map> 
<tsd'nodeSQL column = "trackNo"/> 
</tsd.map> 
</tsd.physical> 
</tsd 9 
attri butel nfo> 
</xs .appi nfo> 
</xs .annotation> 
</xs:attribute> 
</xs" compl exType> 
</xs" el ement> 
<xs.element name = "sample"> 
<xs 9 
compl exType> 
<xs. sequence> 
<xs.element name = "MP3" type = "xs'anyURl"/> 
<xs.element name : "track"> 
<xs 9 
compl exType> 
<xs.attribute 
name = "trackNo" 
type = "xs. IDREF" use = "required"/> 
</xs : compl exType> 
</xs:el ement> 
</xs: sequence> 
</xs: compl exType> 
</xs :el ement> 
<xs:element name = "plays"> 
<xs:annotation> 
<xs:appinfo> 
<tsd: el ement Info> 
<tsd:physical> 
<tsd.map> 

442 
Chapter 11 
Reality Check: The World Is Relational 
<tsd: subTreeSQL 
schema = "jazz" 
table = "plays" 
userid = "bd" 
password = "password" 
datasource = "jazzODBC" 
sql pri marykeys="&quot; al bumPubl i sher&quot; 
&quot; al bumProductNo&quot; 
&quot ;j azzMusi ci anID&quot; 
&quot; i nstrument&quot; "/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement I nfo> 
</xs :appinfo> 
</xs: annotat i on> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name = "instrument" 
type = "xs:token" maxOccurs = "unbounded"> 
<xs:annotation> 
<xs :appinfo> 
<tsd: el ement I nfo> 
<tsd:physical> 
<tsd.map> 
<tsd:nodeSQL column = "instrument"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement Info> 
</xs :appinfo> 
</xs: annotati on> 
</xs :el ement> 
<xs:element name = "jazzMusician"> 
<xs: compl exType> 
<xs:all> 
<xs:element name = "ID" type = "xs:NMTOKEN"> 
<xs:annotation> 
<xs:appinfo> 
<tsd: el ement Info> 

11.11 
Mediation between RDBMS and XML Databases 
443 
<tsd:physical> 
<tsd.map> 
<tsd:nodeSQL column = "jazzMusicianID"/> 
</tsd.map> 
</tsd:physical> 
</tsd: el ement Info> 
</xs :appinfo> 
</xs: annotati on> 
</xs: el ement> 
</xs:all> 
</xs: compl exType> 
</xs: el ement> 
</xs :sequence> 
</xs: compl exType> 
</xs :el ement> 
</xs: schema> 
We can see that mappings to SQL tables used for complex elements are 
described with a tsd. subTreeSQL element. Specified in its attributes are the name 
of the SQL schema (the name of the database), the name of the table, user ID, 
and password to allow Tamino to acCess these tables, and the name of the ODBC 
data source through which this table is accessed. This setup would allow us to 
combine various tables from different data sources into one XML document. 
The attribute sqlprimarykeys specifies the primary key fields of the specified 
table. For element track, the additional clause 
<tsd: accessPredi cate> 
al bumProductNo = al bum. productNo 
AND albumPublisher = album.publisher 
</tsd:accessPredi cate> 
specifies a join criterion to match records from table track to records of table 
album. The content of the accessPredicate clause will appear in the SQL WHERE 
clause generated by the Tamino X-Node. 
For leaf elements and attributes, the mapping is simpler: We only have to 
specify the column of the SQL table that has been specified in the ancestor of 
the respective XML element or attribute. Take for example the element 
plays/jazzMusician/ID. We have specified column jazzMusicianlD. Because the 
nearest ancestor with a table specification is the element p l ays and the table 
specified there is the SQL table plays, we refer to column jazzMusicianID in table 
plays. 

A AA 
Chapter 11 
Reality Check: The World Is Relational 
11.11.2 Experanto 
Another mediator software between relational databases and the XML world 
is IBM's Experanto (formerly XTABLES), which allows transparent access to 
RDBMSs and other data sources such as web services. Experanto features a com- 
pletely different architecture from Tamino's. The core of the system is a power- 
ful XQuery engine. 
XQuery 1.0 is currently a w3c Working Draft [Boag2002]. XQuery builds 
heavily on XPath 2.0 and offers functionality similar to XSLT, but uses an SQL- 
like syntax to formulate queries. One of its strengths is that it is possible to 
define functions in XQuery, and XQuery functions may be used recursively as 
targets of new queries. An XQuery function thus defines a particular view of the 
information base. 
Experanto exploits this feature of XQuery. For relational tables declared to 
the system, Experanto automatically generates a default view--an XQuery func- 
tion that can retrieve a raw table record in XML format. Users can define cus- 
tom views and queries on the basis of this default view. Because XQuery allows 
joining data sources, views across multiple tables can be defined. 
Experanto is basically a schema-less system: The (virtual) document types are 
constructed by defining XQuery expressions, not by defining schemata using a 
common schema language. When a schema is needed for the virtual document 
type--for example, to serve as input to binding generators such as Sun's JAXB, 
Enhydra's Zeus, or Breeze XML Studio (see Section 10.1)--the author must cre- 
ate an additional explicit schema. In Section 13.1 we will discuss the problems 
of view definition in more detail. 
Because XQuery~as the name says--is purely a solution for querying XML 
data sources, and not for their modification, Experanto can only query the con- 
nected data sources, but not update them. 

12.1 Derived Types 
12.2 Authoring for 
Redefinition 
12.3 Open Content Model 
12.4 Versioning 
S 
chemata usually do not stay the same over a long period of 
time. Instead they undergo an evolution to satisfy new re- 
quirements. This is a well-known phenomenon in the database 
community, and the daily bread of database administrators. 
XML schemata are no different. And since XML is used in an 
open and dynamic environment such as the Internet, changes 
to XML schemata are even more likely to happen. Basically, 
there are three types of changes that can be applied to an XML 
schema: 
m New child nodes (elements or attributes) can be added to an 
element. 
m Child nodes may be removed from an element. 
[] General structural changes are applied to the schema: Data 
types of elements or attributes may be changed; elements 
may be regrouped or groups may be resolved. 
In real life, the second case (removal of child nodes) will 
rarely happen. Most of the time document schemata are ex- 
tended to allow a wider variety of document instances. There- 
fore, only the first and third cases are discussed here. 
4145 

446 
Chapter 12 Schema Evolution 
12.1 DERIVED TYPES 
Section 6.2.4 discussed how document instances can override the type defini- 
tion of an element. In the case of complex types it is possible to append, for 
example, additional child elements to an existing sequence of child elements. 
12.1.1 Schema-Conservative Evolution 
Evolution techniques that do not require modifying the existing schemata are 
known as schema-conservative evolution. Usually, this requires that these sche- 
mata have been designed with flexibility and extensibility in mind. In par- 
ticular, the new, extended types that we might want to use in our document 
instances must already be defined in the schema or in an associated type library. 
Section 6.4 discussed several usage patterns for type libraries, such as chame- 
leon components, type substitution, and dangling types. Let's see if and how 
these techniques can be used as a basis for evolvable schemata: 
[] Chameleon components (see Section 6.4.1) do not define their own namespace. 
Thus, they can blend into the namespace of the original schema. This tech- 
nique requires that these components be included in the original schema. Be- 
cause chameleon components can be derived from each other (provided 
their definitions were not declared as final), we can use them to implement 
evolvable schemata. The domain of a schema may be extended by adding 
new types to the included type library, without the need to modify the origi- 
nal schema. This allows for schema-conservative evolution. The next section 
gives an example using this technique. 
[] Type substitution (see Section 6.4.2) is based on abstract types and requires 
that a concrete type be explicitly specified in the document instance. This 
technique requires that the definition of concrete types used in the docu- 
ment instances be supplied by the original schema. The domain of the 
schema may only be extended by adding new concrete types to the original 
schema. Conservative schema evolution is not possible. 
[] Dangling types (see Section 6.4.2) is a technique whereby the master schema 
refers to undefined types belonging to different namespaces. The document 
instances define the location of the schemata for these namespaces and thus 
complete the type definition. However, it is hardly appropriate to classify 
dangling types as a schema evolution technique. Basically, each document 
instance constructs its own virtual schema, while the master schema defines 
a common pattern for all these virtual schemata. This means that new ex- 
tended types can be added without touching the master schema. However, 
not every XML processor can deal with this sort of flexibility. An XML data- 
base, for example, may determine the document type and the physical stor- 
age requirements from a given schema and not from the virtual schema con- 
structed by a document instance. 

12.1 Derived Types 
447 
12.1.2 Using Chameleon Components 
Let's look at an example of how to define and use chameleon components 
for schema evolution. Given the schema file period type.xsd defining type 
peri od_type that describes a period of time: 
peri od_type.xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema xml ns .xs="http 9 
w3. org/2OO1/XMLSchema" 
el ementFormDefaul t =''qual i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<xs'compl exType name="peri od_type"> 
<xs "sequence> 
<xs.element name="from '' type="xs'gYear"/> 
<xs'element name="to" type="xs:gYear" minOccurs="O"/> 
</xs "sequence> 
</xs 9 
compl exType> 
</xs 9 
schema> 
Note that we have defined this schema without a target namespace, so it can 
be included in any namespace. We can now define an extended type period- 
Wi thName_type for a period of time that is decorated with a name (like "Roaring 
Twenties," "Boring Eighties," etc.). This can be done within the same schema 
file or in a separate schema file. Here, we opt to define the new type in a sepa- 
rate schema file: 
peri odWi thName_type, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs .schema xml ns'xs="http.//www.w3 .org/2OO1/XMLSchema" 
e I ement FormDefau I t ='' qua I i Bed" 
attri buteFormDefaul t=" unqual i fled"> 
<xs" i nc I ude schemaLocat i on=" peri od_type, xsd"/> 
<xs" compl exType name="peri odWi thName_type"> 
<xs. compl exContent> 
<xs" extensi on base="peri od_type"> 
<xs: sequence> 
<xs'element name="name" type="xs.string" minOccurs="O"/> 
</xs 9 
sequence> 
</xs -extension> 

Chapter 12 Schema Evolution 
</xs" compl exContent> 
</xs" compl exType> 
</xs'schema> 
The second schema definition includes the first schema definition and then 
refers to the type period_type defined there as a base ~e. Also, this schema is 
defined as a chameleon component, so it can blend into any namespaces when 
it is included in other schemata. The following schema, style_type.xsd, makes 
use of this by including both schemata defined above in its target namespace 
http.//www.jazz.org/encycl opedi a. It defines a complex type, style_type, that, in 
turn, refers to period_type. By including the schema periodWithName_type.xsd, 
too, we introduce a point of variability: 
styl e_type, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema targetNamespace="http 9 
jazz. org/encycl opedi a" 
xml ns" xs=" http'//www, w3. org/2001/XMLSchema" 
xml ns=" http'//www, j azz. org/encycl opedi a" 
el ementFormDefaul t="qual i Bed" 
attri buteFormDefaul t="unqual i fled" 
version="1.0"> 
<xs" i ncl ude schemaLocat i on="peri od_type, xsd"/> 
<xs- i ncl ude schemaLocat i on="peri odWi thName_type, xsd"/> 
<xs :compl exType name="styl e_type"> 
<xs 9 
sequence> 
<xs.element name="name" type="xs'token"/> 
<xs. el ement name="domi nantDuri ng"> 
<xs 9 
compl exType> 
<xs .sequence> 
<xs. el ement name="peri od" type="peri od_type"/> 
</xs 9 
sequence> 
</xs 9 
compl exType> 
</xs" el ement> 
</xs. sequence> 
</xs" compl exType> 
</xs: schema> 
We use this schema in the definition of the next schema, style.xsd, which 
also has target namespace http.//www.jazz.org/encyclopedia: 

12.1 Derived Types 
449 
style.xsd 
<?xml version="1.0 '' encoding="UTF-8"?> 
<xs'schema attributeFormDefaul t="unqual ified" 
el ement FormDefaul t ='' qual i fled" 
targetNamespace ='' ht tp'//www, jazz. org/en cyc I opedi a" 
xml ns=" http 9 
jazz. org/encycl opedi a" 
xml ns" xs=" http'//www, w3. org/2001/XMLSchema"> 
<xs" i ncl ude schemaLocati on="styl e_type.xsd"/> 
<xs" include schemaLocation="description_type.xsd"/> 
<!--Asset style--> 
<xs .el ement name="styl e"> 
<xs 9 
compl exType> 
<xs" compl exContent> 
<xs'extension base="styl e_type"> 
<xs" sequence> 
<xs .el ement ref="descri ption"/> 
</xs 9 
sequence> 
</xs "extension> 
</xs. compl exContent> 
</xs" compl exType> 
<xs'key name="pk style name"> 
<xs'selector xpath=". "/> 
<xs-field xpath="name"/> 
</xs" key> 
</xs" el ement> 
</xs 9 
schema> 
This schema definition refers to the definition of peri od_type ma styl e_type m 
that is, by default, peri od instances are of type peri od_type. However, instances 
can now override this default type with peri odWi thName_type because the schema 
contains a definition of peri odWi thName_type, and peri odWi thName_type is derived 
from period_type. This allows period instances to be extended with a name 
element: 
<?xm] version="l.O" encoding="OTF-8"?> 
<styl e xml ns="http'//www.j azz. org/encycl opedi a" 
xml ns" xs i =" http 9 
w3. org/2001/XMLSc hema- i nstance" 
xsi 9 
schemaLocati on="http'//www.jazz .org/encycl opedi a styl e.xsd"> 

450 
Chapter 12 Schema Evolution 
<name>freeJazz</name> 
<domi nantDuri ng> 
<peri od xs i : type="peri odWi thName_type"> 
<from> 1960</from> 
<to>1975</to> 
<name>Sixties to mid-Seventies</name> 
</period> 
</domi nantDuri ng> 
</style> 
12.1.3 Creating Derived Schemata 
Schema authors are normal human beings, too, who cannot foresee the future. 
It is unlikely that all future requirements are already covered in a schema or 
type library. When such requirements come up, we must create new schemata. 
We can derive new, extended schemata from a given schema with the help of 
the redefine clause (see Section 6.3.3). Redefinition allows us to modify the defi- 
nition of complex and simple types and the definition of groups and attribute 
groups of the redefined schema. 
Type definitions can be replaced with derived type definitions. Also, group 
and attribute group definitions can be replaced with subsets or supersets of 
themselves. Typical reasons for a schema redefinition are the following: 
[] We want to append a child element (or a group of child elements) to an ex- 
isting complex type definition or to a group definition. 
[] We want to add an attribute to an existing complex type definition or to an 
attribute group definition. 
However, there is one constraint. When we construct a new schema, we want 
to make sure that the instances that were valid under the old schema are also 
valid under the new schema. An existing document instance does not necessar- 
ily refer to a given schema file but may simply rely on the namespace associa- 
tion to identify the schema. When, for example, we registered the new schema 
with the XML client, the client would use the new schema definition for exist- 
ing instances as well. So, the new schema definition must also cover the exist- 
ing instances. 
The new schema must therefore define a supertype of the original schema. 
This requires that when we extend a complex type definition, the extension 
must comply with the rules defined in Section 5.3.9, in particular: 
[] An extension of a complex type must not introduce cardinality constraints 
that are narrower than in the original definition. 

12.1 Derived Types 
451 
m The types used for child elements and attributes must be supertypes of the 
types used in the original type definition (or equal). 
[] We must not introduce new default or fixed values for existing child ele- 
ments and attributes. New fixed values could render existing instances in- 
valid, while new default values could change the semantics of existing 
instances. 
[] If we introduce new child elements, we must make sure that these elements 
are optional (that mi n0ccurs is set to "0"). New attributes must not be defined 
as required. The same logic applies when we extend existing groups or 
attribute groups. 
12.1.4 Dialecting with Substitution Groups 
Substitution groups (see Section 6.2.5) allow us to use differently named ele- 
ments in lieu of the original head elements. The type of the substitution ele- 
ments must be derived (restriction or extension) from the type of the head 
elements. This technique allows us to extend a schema by creating a dialect of 
the original schema. In contrast to redefinitions, where we change the defini- 
tion of an element, we use substitution groups to add a variant of an existing 
element. 
Section 6.4.2 discussed the use of substitution groups for the definition of 
schema families. There, we used abstract head elements within the definition of 
the master schema. Here, we do not deal with an abstract master schema, but 
with a concrete schema, possibly with existing document instances. The use of 
substitution groups will guarantee that the existing document instances are still 
accepted by the new schema because the original (nonabstract) head elements 
stay alive. 
Let's look at an example of how to use substitution groups for schema evolu- 
tion. Take for example the following little schema jazzMusicianList.xsd defin- 
ing a list of jazz musicians: 
j azzMus i ci anLi st. xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema targetNamespace ='' http://www, jazz. org/encyc I opedi a" 
xml ns=" http://www, j azz. org/encycl opedi a" 
xml ns: xs =" http://www, w3. org/2001/XMLSchema" 
el ementFormDefaul t="qual i fled" 
attri buteFormDefaul t =''unqual i fled"> 
<xs: i ncl ude schemaLocati on="jazzMusi ci an. xsd"/> 
<xs :el ement name="j azzMus i ci anLi st" type="jazzMusi ci anLi st_type"/> 
<xs :compl exType name="jazzMusi ci anLi st_type"> 

452 
Chapter 12 Schema Evolution 
<xs:sequence maxOccurs="unbounded" > 
<xs :el ement ref="j azzMusi ci an"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: schema> 
We now want to extend the definition of j azzMusi c i an by inserting a con- 
tract number. We give the new element a new name: jazzMusicianWithContract. 
Since the type of element jazzMusician was already an extension of ~e 
jazzMusician_type, we simply repeat the definition of jazzMusician but insert 
the new element contractNo. 
j azzMus i c i anWi thContract, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs "schema targetNamespace="http.//www.jazz .org/encycl opedi a" 
xml ns" xs=" http 9 
w3. org/2001/XMLSchema" 
xml ns= "http.//www. jazz. org/encyc I opedi a" 
el ementFormDefaul t =''qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs" i ncl ude schemaLocati on=" jazzMusi ci anLi st .xsd"/> 
<xs. i ncl ude schemaLocati on="www_j azz_org_encycl opedi a_TYPELIB.xsd"/> 
<xs- el ement name="j azzMus i ci anWi thContract" 
substi tuti onGroup="j azzMusi ci an"> 
<xs 9 
compl exType> 
<xs" compl exContent> 
<xs "extension base="j azzMusi ci an_type"> 
name=" contractNo" type="xs :stri ng"/> 
ref =''prOduces'' 
mi nOccurs="O" maxOccurs="unbounded"/> 
<xs:el ement ref="bel ongsTo" 
mi nOccurs="O '' maxOccurs="unbounded"/> 
<xs :el ement ref="i nfluence" 
mi nOccurs="O" maxOccurs="unbounded ''/> 
</xs: sequence> 
</xs :extension> 
</xs: compl exContent> 
</xs :compl exType> 
<xs-sequence> 
<xs.el ement 
<xs.element 

12.1 Derived Types 
453 
</xs : el ement> 
</xs:schema> 
Under this schema we are now able to define jazzMusicianLi st elements con- 
taining both jazzMusi ci an and jazzMusi ci anWi thC0ntract elements. The schema 
still accepts existing instance documents. 
If we want to define a special list type containing only jazzMusicianWithC0n- 
tract elements, we can ripple the substitution through to the list definition. We 
add the following definition to schema jazzMusicianWithC0ntract.xsd: 
<xs : el ement name="j azzMus i ci anWi thContractLi st" 
subs t i tut i onGroup= "j azzMus i c i an Li s t "> 
<xs: compl exType> 
<xs: compl exContent> 
<xs:restriction base="j azzMusi ci anLi st_type"> 
<xs: sequence maxOccurs="unbounded"> 
<xs: el ement ref="j azzMus i ci anWi thContract"/> 
</xs :sequence> 
</xs: restri cti on> 
</xs: compl exContent> 
</xs: compl exType> 
</xs:el ement> 
This restricts the content of the list type jazzMusicianWithContractList to 
jazzMusicianWithContract elements, as shown in Figure 12.1 (page 454). 
12.1.5 Inhibiting Change 
There may be cases where we want to protect schema definitions from change. 
XML Schema provides two mechanisms to do so: 
[] The final attribute can be used to control the derivation of types and the def- 
inition of substitution groups in schemata (see Sections 5.2.5, 5.3.12, and 
6.2.5). 
[] The block attribute can be used to control the modification of types and the 
application of substitution groups in document instances (see Sections 6.2.4 
and 6.2.5). 
The values of these attributes are not inherited by derived types. However, it 
is possible to define default values for these attributes on the schema level, 
using the attributes finalDefault and blockDefault. Note that these attributes 
should be used cautiously in order not to prevent later schema extension. 

454 
Chapter 12 Schema Evolution 
Fibre 12.1 Creating a dialect with substitution groups: jazzMusi r anWi thContract 
is derived from jazzMusi ci an by extending jazzMusi ci an_type with contractNo, and 
jazzMusi ci anWi thContractLi st is derived from jazzMusi ci anLi st by restricting its 
content to j azzMus i ci anWi thContract child elements. 
12.2 AUTHORING FOR REDEFINITION 
In some cases, we will have requirements that cannot be met by extending an 
existing schema. Among those requirements are 
[] We want to extend an element that was declared with a simple type with an 
attribute. 
[] We want to append child elements to a nested structure of elements. 
[] We want to insert a new element at an arbitrary position in a sequence of 
elements. 

12.2 Authoring for Redefinition 
455 
[] We want to replace an element with a choice model group. 
All these cases cannot be solved with the functionality of type derivation, in 
particular with the functionality of type extension. However, we can define a 
schema in such a way that it is open to the above extensions. In general, this is 
done with soft-coding techniques and indirections instead of hard-coding 
structures. 
The following sections discuss what steps to take so that we can solve the 
above cases with normal type derivation, and thus by redefining the schema. 
12.2.1 Adding an Attribute to a Simple Type Element 
Restrictions and extensions can only refer to top-level type definitions. Such 
global type definitions are equipped with a name, and can consequently be 
referred to by that name. But what if we have an element declaration where the 
element is declared with a simple built-in type such as xs:string or xs:integer? 
Such an element does not have a global type definition, and thus could not be 
extended with an attribute definition. 
Let's assume we have an original schema CD.xsd that contains an element 
price with a declared type of xs :decimal : 
CD.xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs : schema targetNamespace="http://www, ni I e. com" 
xml ns: xs=" http://www, w3. org/2001/XMLSc hema" 
xml ns=" http://www, ni I e. com" 
e I ement FormDe fau I t = "qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs :element name="CD"> 
<xs: compl exType> 
<xs: sequence> 
<xs :el ement ref="ti tl e"/> 
<xs :element ref:"publ i sher"/> 
<xs:element name="price" type="xs:decimal"/> 
</xs: sequence> 
<xs:attribute name="productNo" use="required"/> 
<xs:attribute name="year '' use="optional"/> 
</xs: compl exType> 
</xs: el ement> 
</xs: schema> 

456 
Chapter 12 Schema Evolution 
Later we want to redefine this schema to add an attribute currency to the 
price elementmno chance. The local type definition makes this impossible. If 
we really want this sort of flexibility, we have to author the original schema in a 
different way. For each element with a simple type we have to create a global 
complex type definition (see Section 5.3.12) with simple content (see Section 
5.3.7). A similar technique was discussed in the context of creating type libraries 
with Relax NG (see Section 8.3.2). 
Instead of declaring element price with 
<xs.element name="price" type="xs.decimal"/> 
we declare it with 
<xs-element name="price" type="price_type"/> 
and add the following type definition to the schema file: 
<xs- compl exType name="pri ce_type"> 
<xs" s impl eContent> 
<xs-extension base="xs'decimal "/> 
</xs. s impl eContent> 
</xs" compl exType> 
This allows us later to redefine the original schema with 
CD_pri ceWi thCurrency, xsd 
<xs- schema xml ns" xs="http 9 
w3. org/2OO1/XMLSchema" 
el ementFormDefaul t="qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs: redefine schemaLocati on="CD.xsd"> 
<xs'compl exType name="pri ce_type"> 
<xs- s impl eContent> 
<xs'extension base="pri ce_type"> 
<xs" attri bute name =''currency'' type="xs 9 
NMTOKEN" 
use="optional "/> 
</xs "extension> 
</xs" s impl eContent> 
</xs. compl exType> 
</xs 9 
redefine> 
</xs 9 
schema> 

12.2 Authoring for Redefinition 
457 
12.2.2 Appending Child Nodes to Nested Structures 
Similarly, we run into trouble with redefinition when complex types are defined 
locally. In Section 8.2.4 we defined a schema for the type person_type. The ele- 
ment name within person_type was defined with a local complex type definition: 
<xs" schema xml ns" xs =" ht tp-//www, w3. org/2001/XMLSchema" 
e I emen t FormDe fau I t = "qua I i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<xs'compl exType name="person_type"> 
<xs" sequence> 
<xs-element name="ID '' type="xs-NMTOKEN"/> 
<xs 9 
el ement name:"name"> 
<xs 9 
compl exType> 
<xs- sequence> 
<xs.element name="first '' type="xs-token '' 
maxOccurs=" unbounded"/> 
<xs'element name="middle" type="xs'token '' minOccurs="O"/> 
<xs.element name="last" type="xs'token"/> 
</xs 9 
sequence> 
</xs. compl exType> 
</xs -el ement> 
<xs-el ement name="bi rthDate" type="xs 9 
date" mi nOccurs="O"/> 
</xs 9 
sequence> 
</xs. compl exType> 
</xs 9 
schema> 
If we should want to extend this definition later by adding a nickname or a 
title to the name element, we are out of luck. But if the original schema defini- 
tion looked like the following, we would have no problems: 
<xs .schema xml ns'xs="http-//www.w3.org/2OO1/XMLSchema" 
e I ement FormDefaul t= "qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs'compl exType name="person_type"> 
<xs" sequence> 
<xs.element name="ID" type="xs'NMTOKEN"/> 
<xs-el ement name="name '' type="name_type ''/> 

458 
Chapter 12 Schema Evolution 
<xs:element name="birthDate" type="xs.date" minOccurs="O"/> 
</xs 9 
sequence> 
</xs" compl exType> 
<xs.compl exType name="name_type"> 
<xs. sequence> 
<xs'element name="first" type="xs'token" 
maxOccurs="unbounded"/> 
<xs'element name="middle" type="xs.token '' minOccurs="O"/> 
<xs'element name="last" type:"xs.token"/> 
</xs 9 
sequence> 
</xs. compl exType> 
</xs "schema> 
Note that we have already discussed a similar technique in the context of cre- 
ating type libraries with Relax NG in Section 8.3.2. 
We can now easily redefine this schema and extend the definition for 
name_type" 
<?xml version="1.0" encoding="UTF-8"?> 
<xs'schema xml ns'xs="http.//www.w3.org/2OO1/XMLSchema" 
e I ement FormDefau I t= "qua I i fled" 
attri buteFormDefaul t:"unqual i fled"> 
<xs :redefine schemaLocati on="person_type, xsd"> 
<xs- compl exType name="name_type"> 
<xs. compl exContent> 
<xs" extensi on base="name_type"> 
<xs-sequence> 
<xs:element name="title" type="xs'token" minOccurs="O"/> 
<xs" el ement name="ni ckname" type="xs, token" 
mi nOccurs="O" maxOccurs:"unbounded"/> 
</xs 9 
sequence> 
</xs'extension> 
</xs" compl exContent> 
</xs: compl exType> 
</xs 9 
redefine> 
</xs 9 
schema> 

12.2 Authoring for Redefinition 
459 
12.2.3 Inserting Elements at an Arbitrary Position 
In the previous example we were able to add the child elements title and nick- 
name to the definition of element name. However, there was a hitch: We could 
only append these new elements to the end of the sequence of child elements. 
This is unfortunate because we would prefer the child element t i t le at the top 
of the list and nickname between mi ddl e and last. Fortunately, there is a trick we 
can use to prepare the original schema for such extensions. Instead of (or in 
addition to) introducing the complex type name_type as in the example above, 
we add an empty group (see Section 6.2.2) at each position where we plan later 
extensions. Figure 12.2 (page 460) shows a diagram; here is the code: 
<xs.compl exType name="name_type"> 
<xs -sequence> 
<xs "group ref=" beforeFi rst"/> 
<xs'element name="first '' type="xs.token" 
maxOccurs:" unbounded"/> 
<xs'group ref="beforeMi ddl e"/> 
<xs'element name="middle '' type="xs'token" minOccurs="O"/> 
<xs "group ref="beforeLast"/> 
<xs'element name="last '' type="xs:token"/> 
</xs -sequence> 
</xs" compl exType> 
<xs'group name="beforeFi rst"> 
<xs. sequence> 
</xs.sequence> 
</xs "group> 
<xs'group name="beforeMi ddl e"> 
<xs. sequence> 
</xs.sequence> 
</xs-group> 
<xs "group name="beforeLast"> 
<xs'sequence> 
</xs.sequence> 
</xs'group> 

460 
Chapter 12 Schema Evolution 
Figure 12.2 Schema person_type.xsd opened up for name extensions. 
Now, we can easily insert new elements at any position within element name, 
just by redefining the appropriate groups: 
<?xml version="1.0" encoding="UTF-8"?> 
<xs: schema xml ns :xs = "http://www. w3. org/2001/XMLSchema" 
e I ement FormDefau I t= "qua I i fled" 
a t t ri bute Fo rmDe fau I t=" unqua I i fled "> 
<xs:redefne schemaLocati on="person_type, xsd"> 
<xs :group name="beforeFi rst"> 
<xs: sequence> 
<xs:group ref="beforeFi rst"/> 
<xs:element name="title" type="xs:token" minOccurs="O"/> 

12.2 Authoring for Redefinition 
461 
</xs:sequence> 
</xs:group> 
<xs:group name="beforeLast"> 
<xs:sequence> 
<xs:group ref="beforeLast"/> 
<xs:element name="nickname" type="xs:token '' minOccurs="O"/> 
</xs:sequence> 
</xs:group> 
</xs:redefine> 
</xs:schema> 
Similarly, we can allow the later extension of elements with attributes by 
declaring them with an empty attribute group (see Section 6.2.3). However, this 
is not really necessary. Attributes can always be appended via type extension, as 
their sequence does not matter. 
12.2.4 Allowing Choices 
Let's assume that at some point we are no longer satisfied with the mere option 
to specify a birth date for a person. Instead we would like to have a full curricu- 
lum vitae (CV) containing birth date, eventually a death date, and other events. 
However, because we still have to support existing documents, we have to cre- 
ate a supertype of pers0nType. We can do this by replacing the element bi rthDate 
with a choice model group containing both bi rthDate and the new complex ele- 
ment CV. 
The problem is that we cannot generalize a type in this way by type deriva- 
tion. Type derivation would allow us only to append a choice group after bi rth- 
Date, but this is not what we want. Again, we have to plan for this sort of 
extensibility in the definition of the original schema. We simply replace the ele- 
ment birthDate with a group reference. On the global level we define a group 
that contains a choice model group with element bi rthDate as the only alterna- 
tive (see Figure 12.3, page 462). 
person_type, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs :schema xml ns :xs="http://www. w3. org/2OO1/XMLSchema" 
el ement FormDefau I t ='' qua I i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs:compl exType name="person_type"> 
<xs: sequence> 
<xs: el ement name=" ID" type="xs :NMTOKEN"/> 

462 
Chapter 12 Schema Evolution 
Figure 12.3 The person_type schema prepared for choice extensions. 
<x s" e I eme n t name =" name" ty p e = "n ame_ty p e"/> 
<xs'group ref="bi rthDateChoi ce" mi nOccurs="O"/> 
</xs .sequence> 
</xs" compl exType> 
<xs.group name="bi rthDateChoi ce"> 
<xs.choice> 
<xs'el ement name="bi rthDate" type="xs'date" mi nOccurs="O"/> 
</xs.choice> 
</xs'group> 
</xs 9 
schema> 

12.2 Authoring for Redefinition 
463 
Figure 12.4 The redefinition of the choice group. Note the replication of 
bi rthDateChoi ce in the redefinition. 
Now, we can easily redefine schema person_type.xsd and add alternatives to 
the choice group (see Figure 12.4). 
personWi thCV_type, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs" schema xml ns. xs="http 9 
w3. org/2001/XMLSchema" 
e I ement FormDefau I t= "qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs. redefine schemaLocati on="person_type, xsd"> 
<xs'group name="bi rthDateChoi ce"> 
<xs. choice> 
<xs'group ref="bi rthDateChoi ce"/> 
<xs'el ement name="cv"> 
<xs 9 
compl exType> 
<xs" sequence> 
<xs.element name="birthDate" type="xs.date"/> 
<xs.element name="died" type="xs'date '' minOccurs="O"/> 
<xs'el ement name="event" 
mi nOccurs="O" maxOccurs="unbounded"> 
<xs 9 
compl exType> 

Chapter 12 Schema Evolution 
<xs: sequence> 
<xs:element name="date" type="xs:date"/> 
<xs:element name="kind" type="xs:token"/> 
</xs :sequence> 
</xs: compl exType> 
</xs :el ement> 
</xs: sequence> 
</xs: c0mpl exType> 
</xs :el ement> 
</xs:choice> 
</xs :group> 
</xs: redefine> 
</xs: schema> 
12.2.5 Conservative Schema Modification 
When redefining or modifying a schema to adapt to changing requirements, we 
want to make sure that the new schema also covers existing documents. This 
means that the new document type must be a supertype of the original docu- 
ment type. Keep these additional guidelines in mind when modifying schema: 
m A general rule is never to make cardinality constraints narrower. So, it is fine 
to make maxOccurs greater and mi nOccurs smaller. However, making maxOccurs 
smaller or mi n0ccurs greater could exclude existing instances. 
This logic also applies when adding new elements or attributes or when 
dropping elements or attributes. A nonexistent element can be seen as an el- 
ement with min0ccurs="0" and max0ccurs="0". If we want to add a new ele- 
ment, we just imagine that it already exists with min0ccurs="0" and max- 
0ccurs="0", and consequently we leave min0ccurs at "0" and only increase 
max0ccurs to comply with the above rule. This means that all new elements 
must be optional. On the other hand, if we no longer need a given element, 
we simply set min0ccurs="0". This makes the element optional, so both new 
and old instances are covered. 
The same applies to attributes. New attributes should be added with 
use="0pti0nal ", and for attributes that we no longer need, use should be set 
to opt i onal, too. 
[] Be Cautious with the definition of fixed and default values. Never introduce 
new fixed or default values or modify existing fixed values, because this 
could render existing instances invalid. But, are we allowed to modify default 
values or to remove declarations for default or fixed values? Doing so would 
not make existing instances invalid, but it would change the content (and se- 
mantics) of these instances. Applications that rely on these values could fail. 

12.3 Open Content Model 
46$ 
So, the best thing is not to touch the definitions for default and fixed values 
during schema evolution. 
m When changing the simple type of an element, only change it into a super- 
type. Otherwise it could exclude existing instances from the schema. This 
means that we can always extend a simple type with extension by list (see 
Section 5.2.6) or with a type union (see Section 5.2.10). 
m When introducing a choice into a schema, the same rules apply as to all 
choices: The choice should not make the schema nondeterministic (see Sec- 
tion 5.3.18). 
12.3 OPEN CONTENT MODEL 
All the evolution techniques discussed so far require modifying existing sche- 
mata or creating new schemata. Document authors are usually not equipped to 
do this; they may not have the necessary knowledge, tools, or access rights to 
implement a new schema or modify an existing one. So, if a document author 
needs to embed new elements or attributes into a document, he or she may 
have to apply to the schema author. The modification may take time, especially 
if the schema author has a large backlog of work or has other priorities. 
To solve this problem, XML Schema provides an extension mechanism that 
allows document authors to introduce elements that were not defined in the 
corresponding schemata. This mechanism is the wildcard extension mecha- 
nism (see Sections 5.3.15, 6.1.3, and [Costello2000]). 
Other, earlier schema languages used a simple attribute on the schema level 
to indicate whether the content model of a schema was open or closed. An open 
content model means that the document author is free to introduce new ele- 
ments and attributes whenever and wherever he or she desires. Early drafts of 
XML Schema also featured such an attribute, but it was dropped in favor of the 
more controlled approach with wildcards. The wildcard mechanism, though, 
requires a bit more work from the schema author. 
Schema authors must specify an <any> or <anyAttri bute> wildcard in any posi- 
tion where the document authors are later allowed to introduce their own ele- 
ments or attributes. Take for example the following schema definition for 
person_type. 
person..wi 1 dcard, xsd 
<?xml version="1.0" encoding="UTF-8"?> 
<xs : schema xml ns :xs="http://www. w3. org/2OO1/XMLSchema" 
xml ns=" http://www, jazz. org/encyc I opedi a" 
ta rg et N ames pace= "h ttp: //www. jazz. o rg/encyc I oped i a" 
el ementFormDefaul t =''qual i fled" 
attri buteFormDefaul t="unqual i fled"> 
<xs:compl exType name="person_type"> 

Chapter 12 Schema Evolution 
<xs : sequence> 
<xs: el ement name="name"> 
<xs: compl exType> 
<xs: sequence> 
<xs:any namespace="##other" processContents="lax" 
mi nOccurs="O"/> 
<xs:element name= "first " type="xs:token" 
maxOccurs="unbounded"/> 
<xs: el ement name="mi ddl e" type="xs: token" mi nOccurs="O"/> 
<xs:element name="last" type="xs:token"/> 
</xs :sequence> 
</xs: compl exType> 
</xs: el ement> 
<xs: el ement name="bi rthDate" type="xs :date" mi nOccurs="O"/> 
<xs :any processContents="l ax" 
maxOccurs="unbounded" minOccurs="O '' /> 
</xs :sequence> 
<xs: attri bute name=" ID" type="xs :NMTOKEN" use="requi red"/> 
<xs: anyAttri bute processContents="l ax"/> 
</xs: compl exType> 
<xs: el ement name="person" type="person_type"/> 
</xs: schema> 
This schema allows document authors to introduce new elements in the fol- 
lowing positions: 
m a single element as child element of element name before child element first 
m an unlimited number of elements after element bi rthDate 
Also, elements of type person_type may be equipped with an unlimited num- 
ber of arbitrary attributes. Namespace control for all these elements and 
attributes is possible with the attributes processContents and namespace. 
Note the use of the specification namespace="##0ther" for the first wildcard. 
This was done in order to avoid nondeterminism (see Section 5.3.18). Without 
this specification, the wildcard may contain elements from the same name- 
space. When encountering a first element in a document instance, a parser 
would not be able to decide if this element should be accepted by the wildcard 
or by the following element specification without looking ahead. 
In the following example we have exploited this variability by creating a 
document instance with additional elements. We have inserted an e:title 

12.4 Versioning 
467 
element before person/name/first and appended an e:gender element after 
person/bi rthDate. 
<?xml version="1.0" encoding="UTF-8"?> 
<person xmlns="http://www.jazz.org/encyclopedia" 
xml ns: e=" http://www, j azz. org/encyc I opedi a/extens i ons" 
xml ns: xs i = "h t tp://www, w3. o rg/2001/XM LSc hema- i ns tanc e" 
xsi : schemaLocati on="http://www.j azz. org/encycl opedi a 
person_type_wi I dcard, xsd" 
ID="NMTOKEN"> 
<name> 
<e:title>Mrs.</e:title> 
<first>Bi I I i e</first> 
<l ast>Hol i day</l ast> 
</name> 
<bi rthDate>1915-04-07</bi rthDate> 
<e: gender>femal e</e: gender> 
</person> 
Because we have not given a schema definition for namespace http://www 
.jazz.org/encyclopedia/extensions and because processContents is set to "lax," 
XML processors will check the elements e: ti tl e and e: gender only for well- 
formedness. 
12.4 
VERSIONING 
When browsing the Web, we can find two best practices for reflecting version 
changes in schemata: 
1. Change the target namespace of the new schema version. 
2. Do not change the target namespace of the new schema version. 
In fact, both practices are applicable. Practice 1, however, only applies when 
you want to inhibit existing instances from using the new schema version, and 
when you want to inhibit other existing schemata from importing, including, 
or redefining the new schema version, for example, in the following cases: 
m A new schema version differs dramatically from former schemata, so that 
compatibility for existing instances and importing schemata cannot be 
maintained. 
[] The old schema contains a severe bug, so you want existing document in- 
stances to invalidate. 

468 
Chapter 12 Schema Evolution 
In such cases you can enforce invalidation of the new schema version for 
existing resources by introducing a new target narnespace. In most cases, you 
may want to keep older schema versions around to allow existing applications 
to operate. 
In all other cases we fall back to option 2. When you have designed the new 
schema in an upward-compatible way, so that existing resources can continue 
to use it, you have several options for indicating the version of a schema to 
applications. This will allow applications to evaluate the schema version and 
use the extended features of the new version. 
1. Indicate the new schema version by storing it in a different location. The 
sooner you forget about this option, the better. The xsi :schemaLocation is 
only a hint to XML processors about where to locate a schema. The 
processor is free to decide otherwise. 
2. Indicate the schema version via the standard version attribute in the 
schema clause. 
<xs" schema versi on="1.0"> 
This attribute can indicate the schema version to the schema author and 
can be used to convey version information during the authoring process 
of schemata. For example, if we combine several schema components in 
one large schema, we want to make sure that the version attributes of 
each imported or included schema component fit with the version of the 
importing module. 
However, XML parsers do not evaluate this attribute. Applications 
would be required to preparse the document and its schema to obtain the 
value of this attribute. In case of multipart schemata, this can become 
quite a task. 
3. Indicate the schema version using a version attribute defined explicitly in 
the document root element (and possibly in child elements). This is prob- 
ably the most versatile option for conveying version information to appli- 
cations. An explicit attribute version with a fixed value is defined in the 
schema in the root element of the document. XML parsers will include 
this attribute in the document instance as seen by the parser's client; the 
application is automatically informed about the value of the version 
attribute. 
<xs'schema xml ns'xs="http 9 
el ement FormDefaul t=" qual i fled" 
attri buteFormDefaul t=" unqual i fled" 
version="3.0"> 
<xs 9 
compl exType name=" peri od_type"> 
<xs'sequence> 

12.4 Versioning 
4~9 
<xs: el ement name=" from" type="xs: gYear"/> 
<xs:element name="to '' type="xs:gYear '' minOccurs="O"/> 
</xs: sequence> 
<xs: attribute name="vers i on" type="xs: NMTOKENS" 
fixed="1.0 2.0 3.0"/> 
</xs: compl exType> 
</xs :schema> 
This example uses the data type NMTOKENS for the version attribute. This 
allows us to specify a list of all valid application versions for that schema 
part. We can use version attributes to implement a finer-grained version 
control than on the global level. We can equip each document element 
with a version attribute to indicate the version of that particular element. 
Such version attributes can either reflect the version of the schema 
(and should then be in sync with the version attribute in the schema 
clause), or they can reflect the version number(s) of compatible applica- 
tion versions. Of course, nothing stops us from introducing two different 
attributes: schemaVersion and appl icationVersion. 

This Page Intentionally Left Blank

13.1 Combining Diverse 
Schemata 
13.2 Centralized and 
Decentralized 
Change Management 
T 
he large environments of certain corporations or govern- 
ment administration pose particular problems to schema 
developers. In some cases, existing schemata were developed in 
isolation by various business units; in other cases, schemata 
were inherited during the acquisition of whole companies. In 
most of these cases it is not possible to change these schemata 
to integrate them into one consistent set of schemata because 
these would render large information bases invalid. In such 
cases mediation techniques [Wiederhold1997] are necessary to 
make the various business units collaborate. These techniques 
are, of course, not restricted to large corporations; they can also 
be applied when small and medium companies cooperate in 
electronic business scenarios. 
At the other end of the scale are enterprise data models: 
huge, consistent schemata that cover virtually every nook and 
cranny within an enterprise. These schemata are notoriously dif- 
ficult to maintain. Both the relational discipline and the object- 
oriented discipline have developed techniques to manage the 
decentralized change of such schemata. We take a look at these 
techniques to see what we can learn from them for the decen- 
tralized change management of XML schemata. 
471 

472 
Chapter 13 Schemata in Large Environments 
13.1 COMBINING DIVERSE SCHEMATA 
There are many situations in which we will not only have to extend an existing 
schema but will have to combine diverse schemata into a single, consolidated 
schema. Typical scenarios are company mergers or the establishment of a sup- 
ply chain or virtual enterprise. The following sections will discuss the problems 
and possible solutions for the combination of diverse schemata. Please keep in 
mind that most of the topics discussed in these sections are subject to ongoing 
research and do not represent well-established industry standards. 
13.1.1 The Problem 
When we want to combine several schemata, we have a couple of options: 
[] Define a mapping between two schemata on a bilateral basis. 
[] Define a new schema covering the domain of the complete schema combi- 
nation, and define a mapping between the new schema and the contributing 
original schemata. 
In most cases we will select the second option, as this will reduce the number 
of mappings if we have more than two contributing schemata. 
In some cases the original schemata will describe the same domain; for exam- 
ple, they may describe a certain product but will differ in the names used for ele- 
ments and attributes. There may be structural differences, too: One schema 
might describe details that the other schema does not. Also, the content of in- 
stance elements may not be compatible. While one organization might specify 
the product dimensions in metric values, the other organization might use 
imperial measures. 
In other cases, the domains of the original schemata might be fundamentally 
different but will overlap in certain areas. In such cases we might construct a 
fusion of both models in order to leverage synergy effects from the combination 
of both domains. 
13.1.2 Model Fusion 
Take for example the models given in Chapters 2 and 3. The model in Chapter 
2 describes the information set of a bookshop (see Figure 13.1). In Chapter 3 we 
developed a model for a jazz knowledge base (see Figure 13.2). However, there is 
an area where both models overlap: The album asset type of the jazz knowledge 
base could be mapped to the CD asset type of the bookshop model. In this case a 
fusion of both models unleashes substantial synergies. Taken by itself our book- 
shop model would only allow queries such as: 
Which CDs did customer A buy? 
Which contributor was the most frequently named on CDs bought by customer A? 
When was CD X bought by customer A? 

13.1 Combining Diverse Schemata 
473 
Figure 13.1 The bookshop model from Chapter 2. 
But with a fusion of both models, we can exploit the knowledge contained in 
the jazz encyclopedia and give recommendations to a customer: 
Which contributor was the most frequently named on CDs bought by customer A, 
and which other CDs produced by this contributor do we stock? 
Which CDs belong to the same jazz style as CD X and were produced by musicians 
who have influenced the contributors of CD X or were influenced by them? 

414 
Chapter 13 Schemata in Large Environments 
Figure 13.2 The jazz encyclopedia model from Chapter 3. 

13.1 Combining Diverse Schemata 
475 
The following sections discuss how we can implement such a fusion between 
two overlapping information domains. 
13.1.3 Combining Document Instance Sets 
There are basically two options when we wish to combine two sets of document 
instances: 
[] Convert the instance documents of both information domains into a com- 
mon, consolidated format. 
[] Leave the instance documents in their original format and use a mediator 
that facilitates the querying, navigation, and update across both instance 
sets. 
The first option is only applicable when we deal with long-term integration 
between two different information bases and if the information bases are not 
accessed by third parties that might be affected by a format change. In all other 
cases, especially in cases of short-term and temporary collaboration, the original 
information bases are left untouched. Nevertheless, the use of mediators re- 
quires us to construct a new generic document format that can serve as a com- 
mon document format for operations between the two disparate information 
bases. 
In relational technology the combination of different data sources can be 
achieved by defining views across multiple tables (see Section 11.6.4). In XML 
scenarios we basically have the same option: to construct a view defining a vir- 
tual document type that is composed from various source document types. The 
technology to achieve this is currently only emerging. Section 11.11.2 men- 
tioned XQuery. XQuery 1.0 is currently a W3C Working Draft [Boag2002], so 
you should regard the example given below with caution. 
XQuery has strong relations to XPath 2.0 and to XSLT but has a more user- 
friendly syntax. One of the outstanding features of XQuery is its join facilities, 
which allow us to formulate queries across multiple document types. Since 
XQuery allows wrapping queries in explicit function definitions, it facilitates 
the formulation of views across multiple document types. 
Let's look at an example. We have a collection of XML documents describing 
the CDs offered in our online bookshop. We assume that the instance docu- 
ments are stored in a collection such as a file directory or a database with the 
name "bookshop." 
<?xml version="1.0" encoding="UTF-8"?> 
<CD xmlns="href://www.ni le.com" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- i nstance" 
xsi :schemaLocation="href://www.ni le.com CD.xsd"> 
<productNo>cd1780</productNo> 

476 
Chapter 13 Schemata in Large Environments 
<title>Inside out</titl e> 
<pub l i sher>http://www, ecmrecords, com</publ i sher> 
<price> 17.95</pri ce> 
</CD> 
In addition, we have a collection, "encyclopedia," which contains a knowl- 
edge base about jazz musicians. In this collection there are documents of type 
album describing albums produced by jazz musicians: 
<?xml version="1.0 '' encoding="UTF-8"?> 
<al bum xml ns="http://www.jazz .org/encycl opedi a" 
xml ns :xs i =" http://www, w3. org/2001/XMLSchema- i nstance" 
xsi :schemaLocation="http://www.jazz.org/encyclopedia album.xsd"> 
<pub l i sher>http://www, ecmrecords, com</publ i sher> 
<p rod uct No> 1780</prod uct No> 
<title>Inside out</title> 
<plays> 
<j azzMus i ci an>< I D>JarrettKei th</I D></j azzMus i ci an> 
<ins t rument>p i ano</i ns t rument> 
</plays> 
<plays> 
<j azzMus i c i an>< I D>Peacoc kGary</I D></j azzMus i c i an> 
<i nstrument>doubl e bass</i nstrument> 
</plays> 
<plays> 
<j azzMusi ci an>< I D>DeJohnetteJ ac k</I D></j azzMus i ci an> 
<i nstrument>drums</i nstrument> 
</plays> 
</album> 
We want to combine these two document types into one virtual document 
type combinedCD. We want to match the CD documents to the album documents 
by publisher and productNo. Note that the product number of CD documents is 
prefixed with cd. This is not the case in the album documents. 
The resulting documents should have a layout similar to the CB documents, 
but we want to add the information contained in the <pl ays> nodes of the al bum 
documents. We want to add this information in a modified layout, in the form 
of <musician> nodes, with the ID of each jazzMusician specified as an attribute. 

13.1 Combining Diverse Schemata 
477 
The result of the query should look like this: 
<comb i nedCD> 
<title>Inside out</titl e> 
<productNo>cd1780</productNo> 
<publ i sher>http://www, ecmrecords, com</publ i sher> 
<musician ID = "JarrettKeith"> 
<i nstrument>pi ano</i nstrument> 
</musician> 
<musician ID = "PeacockGary"> 
<instrument>double bass</i nstrument> 
</musician> 
<musician ID = "DeJohnetteJack"> 
<ins t rument>d rums </i ns t rument> 
</musician> 
<price> 17.95</pri ce> 
< / c omb i n edCD> 
The following query does the trick: 
namespace s="href://www.ni le.com" 
namespace j:"http://www.jazz.org/encyclopedia" 
for $cd in collection("bookshop")/s:CD 
let $title 
:= $cd/s:title, 
$productNo := $cd/s:productNo, 
$publisher := $cd/s:publisher, 
Sprice := $cd/s:price 
let $album := 
col I ect i on (" encycl opedi a") / 
j : a I bum [ conca t (" cd ", j : productNo/text ()) = 
$productNo/text () ] 
Iet $plays : = $al bum/j : plays 
return 
<combi nedCD> 
<ti tle>{$ti tle/text () }</title> 
<productNo>{$productNo/text () }</productNo> 
<pub] i sher>{$pub] i sher/text () }</pub] i sher> 
{for $musician in $album/j:plays 
return 

418 
Chapter 13 Schemata in Large Environments 
<musician ID={$musician/j :jazzMusician/j: ID/text () }> 
<i nstrument>{ $mus i c i an/j: i n strument/text () }</i nstrument> 
</musician> 
} 
<pri ce>{$pri ce/text () }</pri ce> 
</combi nedCD> 
The construction of this query is straightforward. The first section--after 
defining the two namespaces--contains the selection part of the query. Using 
for and let clauses, variables are instantiated with node lists extracted from the 
queried document base (collection). The for clause selects all CD documents 
from collection bookshop. The join to document type album is performed by the 
let $al bum clause. Note that we have used an XPath filter expression to select 
album documents with the matching productNo and publisher. The concat func- 
tion is used to adapt the album product numbers to the CD product numbers. 
The second part of the query (beginning with the first return clause) contains 
the construction part of the query where new document instances of the com- 
bined document type are produced. All construction elements are highlighted. 
Note that the construction part contains a subquery that transforms all p lays 
elements into a different format (musi ci an). This intermingling of selection and 
construction is typical for XQuery. 
Let's now wrap this query in a function definition and use this function as a 
target for further queries: 
namespace s="href://www.ni le.com" 
namespace j ="http://www. jazz. org/encyc I opedi a" 
define function combinedCBView() returns xs:AnyType { 
for $cd in collection("bookshop")/s:CD 
o o o  
} 
for $x in r 
return 
<overvi ew> 
<ti tle>{$x/ti tle}</ti tle> 
<musi ci ans>{count ($x/musi ci an) }</musicians> 
</overview> 
We see that functions can be typed using the type system of XML Schema. 
The example above can only give a glimpse into the features of XQuery; a com- 
plete description would fill another book. XQuery is a powerful language and, 
despite its early stage (still a Working Draft), is already adopted by the industry: 

13.1 Combining Diverse Schemata 
47'9 
IBM, Microsoft, Oracle, and Software AG have all produced working prototypes 
of XQuery processors. 
Unfortunately, for our purpose of information integration, XQuery is of lim- 
ited use. XQuery is a pure query language; update operations are not defined in 
XQuery. SQL, in contrast, provides update operations that can even be applied 
to views. The definition of a generic XML transformation and integration lan- 
guage is still very much a research topic. At present we know only one XML 
transformation language allowing the definition of updatable XML views: 
XPathLog [May2001] is a fusion of XPath with Prolog. 
13.1.4 Schema-Driven View Definition 
A view defined with a query or transformation language with a built-in set of 
construction operators, such as XQuery (or XSLT), effectively establishes a new 
document type. However, this document type is not explicitly represented by a 
schema written in standard schema language, such as XML Schema or Relax 
NG. When integrating information from diverse sources, we would want to use 
the new combined document type in lieu of the original schemata and would 
require a schema to support our XML development environment. For example, 
instead of using the original schemata for the document types CD and a] bum, 
we would prefer to use a new schema, c0mbinedCD. There are many reasons for 
creating a new, explicit schema definition for the combined document type, in 
particular: 
m A schema can provide additional information that is not contained in docu- 
ment instances, such as defaults for elements and attributes. 
m Visual schema editors can show the structure of the document type in the 
form of a diagram. 
[] Binding generators such as JAXB, Zeus, or Breeze XML Studio (see Section 
10.1) need a schema to create a binding into an object-oriented language. 
[] Agents can exploit published schemata in order to navigate through complex 
information structures. 
All this is not possible on the basis of only the XQuery view definition. Of 
course, most parts of a schema definition could be derived from the query defi- 
nition, but not all: For example, the query does not contain information about 
default values or constraints such as keys and key references. 
What we want to define is a schema like the one shown in Figure 13.3 (page 
480). How can we now relate the query definition shown in the previous sec- 
tion to such a schema definition? Basically, we have two options: 
[] We embed query expressions into the schema definition and extract the 
complete query from the schema definition later. This technique will be 
demonstrated in the next section. This solution has two advantages: It is rel- 
atively easy to develop and maintain schema and query synchronously, and 

480 
Chapter 13 Schemata in Large Environments 
Figure 13.3 A schema diagram for the virtual document type combinedCD. 
schema components with the embedded query parts can be reused. The dis- 
advantage is that we have to touch the schema definition if we want to 
change the mapping. For example, we might have to use different mappings 
for the same schema in different scenarios. 
[] The alternative is to rely on natural mapping between the elements and 
attributes defined in the schema and the elements and attributes defined by 
the construction part of the query based on the qualified names and paths of 
these elements and attributes. The advantage is that we can easily exchange 
the mapping while leaving the schemata untouched. The disadvantage is 
that it is more difficult to keep the schema and the query in sync, especially 
when schema components are reused. 
13.1.5 Embedded Queries 
As an example for the embedding of query expressions into a schema defini- 
tion, we use the schema given in Figure 13.3. Into this schema definition we 
embed XQuery fragments that describe the mapping between comb i nedCD and r 
with respect to album. We use the annotation/appinfo logic (see Section 6.3.6) of 
XML Schema to specify the mapping. Similarly, we could embed the XQuery 
fragments into Relax NG (see Section 7.1.5). 

13.1 Combining Diverse Schemata 
481 
<?xml version="1.0" encoding="UTF-8"?> 
<xs. schema xml ns: j ="http://www. jazz. org/encycl opedi a" 
xml ns: s="href://www, ni 1 e. corn" 
xml ns: q=" http: //www. w3. org/TR/xquery" 
xml ns :xs =" http://www, w3. org/2001/XMLSchema" 
el ement FormDefaul t ='' qual i fled" 
attri buteFormDefaul t=" unqual i fled"> 
<xs:annotation> 
<xs :appi nfo> 
<q: query> 
namespace s="href://www, ni I e. corn" 
namespace j ="http://www. jazz. org/encyc 1 opedi a" 
define function combinedCDView() returns xs:AnyType 
</q:query> 
</xs :appi nfo> 
</xs: annotat i on> 
<xs: el ement name ='' combi nedCD"> 
<xs:annotation> 
<xs:appinfo> 
<q: query> 
for $cd in collection("bookshop")/s:CD 
let $title 
:= $cd/s:title, 
$productNo : = $cdls :productNo, 
$publ i sher : = $cdls: publ i sher, 
$price : = $cdls: price 
let $album := collection("encyclopedia")/ 
j: al bum [concat ("cd", j : productNoltext ()) = 
$productNo/text () ] 
</q:query> 
</xs :appi nfo> 
</xs: annotat i on> 
<xs: compl exType> 
<xs :sequence> 
<xs:element name="title" type="xs:string"> 
<xs: annotati on> 
<xs:appinfo> 
<q: query>$ti tl e/text () </q: query> 
</xs:appinfo> 
</xs : annotat i on> 

482 
Chapter 13 Schemata in Large Environments 
</xs : el ement> 
<xs: el ement name="productNo" type="xs: NMTOKEN"> 
<xs:annotation> 
<xs :appi nfo> 
<q: query>$productNo/text ()</q: query> 
</xs: appi nfo> 
</xs: annotati on> 
</xs: el ement> 
<xs :el ement name="publ i sher" type="xs: anyURI"> 
<xs: annotati on> 
<xs:appinfo> 
<q: que ry>$pub ] i sher/text () </q: query> 
</xs:appinfo> 
</xs:annotati on> 
</xs :el ement> 
<xs: el ement name="musi ci an" maxOccurs="unbounded"> 
<xs:annotation> 
<xs:appinfo> 
<q:query>for $musician in $album/j:plays</q:query> 
</xs:appi nfo> 
</xs: annotati on> 
<xs: compl exType> 
<xs: sequence> 
<xs:element name="instrument" type="xs:string ''> 
<xs:annotation> 
<xs :appi nfo> 
<q: query>$musi ci an/j : instrument/text () </q: query> 
</xs :appi nfo> 
</xs: annotati on> 
</xs: el ement> 
</xs: sequence> 
<xs:attribute name="ID '' type="xs:NMTOKEN '' use="required ''> 
<xs:annotation> 
<xs :appi nfo> 
<q: query> 
$musi ci an/j : jazzMusi ci an/j : IO/text () 
</q:query> 
</xs :appi nfo> 

13.1 Combining Diverse Schemata 
4183 
</xs : annotati on> 
</xs :attribute> 
</xs: compl exType> 
</xs :el ement> 
<xs:element name="price" type="xs:decimal"> 
<xs:annotation> 
<xs :appi nfo> 
<q: query>$cd/s: pri ce/text () </q: query> 
</xs :appinfo> 
</xs: annotat i on> 
</xs: el ement> 
</xs: sequence> 
</xs: compl exType> 
</xs: el ement> 
</xs: schema> 
The XQuery fragments (highlighted) are embedded into the schema by 
wrapping them in a <q:query> element. It is relatively easy to derive a complete 
XQuery query expression from this schema definition with the embedded frag- 
ments. The next listing shows an XSLT transformation that will do exactly this: 
<?xml version="1.0" encoding="utf-8" standal one= "yes " ?> 
<xs I : styl esheet xml ns :xs I ="http://www. w3. org/1999/XSL/Transform" 
xml ns: q=" http://www, w3. org/TR/xquery" 
xml ns : xs=" http://www, w3. org/2001/XMLSchema" 
version="l.O" > 
<!-- use text output mode because XQuery has a non-XML syntax --> 
<xsl :output method="text" indent="no"/> 
<!-- define key access structures for global elements 
<xsl :key name="global element" 
match="//xs:schema/xs:el ement" use="@name"/> 
<xs I : 
<XS 
<XS 
</xsl 
< ! - -  
<xsl : 
--> 
process schema clause for namespace declarations 
--> 
templ ate match="xs :schema"> 
l :value-of sel ect="xs: annotati on/xs: appi nfo/q: query"/> 
l :apply-templ ates/> 
:template> 
process elements (in case of top-level only the first) 
--> 
template 
match="xs:element[position() = I or name(..) l= 'xs:schema']"> 

Chapter 13 Schemata in Large Environments 
<!-- check if this refers to global element --> 
<xsl .variable name="el em"> 
<xsl -choose> 
<xsl :when test ='' ./@ref"> 
<!-- yes - get global element via key --> 
<xsl "copy-of select="key( 'global_element', ./@ref)"/> 
</xsl "when> 
<xsl "otherwise> 
<!-- no - just use current node --> 
<xsl "copy-of select ='' . "/> 
</xsl -otherwise> 
</xsl "choose> 
</xsl "variable> 
<!-- get the element's name --> 
<xsl'variable name="name" select="$elem/*/@name"/> 
<!-- get the element's query expression 
--> 
<xsl .variable name="query '' 
sel ect="$el em/*/xs 9 
annotati on/xs 9 
appi nfo/q 9 
query/text ()"/> 
<!-- if this starts with 'for' or 'let' we have to generate before the 
element and add a result clause 
--> 
<xsl 9 
vari able name="i sHead" 
select="starts-with(normal ize-space($query) ,' for ') 
or starts-wi th (normal i ze-space ($query/text ()), 'l et ' )"/> 
<!-- Generate FLWR expression 
--> 
<xsl 9 
i f test="$i sHead"> 
<xsl : text> {</xsl. text> 
<xsl .val ue-of sel ect="$query"/> 
<xsl 9 
text> return </xsl 9 
text> 
</xs I : i f> 
<!-- Now generate the constructor --> 
<xsl 9 
text>&l t ;</xsl- text> 
<xsl "val ue-of sel ect="$name"/> 
<!-- before closing the tag generate attributes 
--> 
<xsl .for-each select="$elem/*/xs.complexType/xs.attribute"> 
<xsl .cal l -templ ate name="att-query"> 
<xsl "with-param name="attribute" select="."/> 

13.1 Combining Diverse Schemata 
~$ 
</xsl :cal l-template> 
</xsl : for-each> 
<xs I : text>&gt; </xs I : text> 
<!--was there a 'let' or 'for' expression 
--> 
<xsl : choose> 
<xsl :when test="$isHead"> 
<!-- yes, just do child elements --> 
<xsl :apply-templates/> 
</xsl :when> 
<xsl : otherwi se> 
<!-- no, insert query expression, but wrap in curly brackets 
<xsl :value-of select='concat(" {",$query,"} ")'/> 
</xsl : otherwi se> 
</xsl : choose> 
<!-- closing tag 
--> 
<xsl :text>&l t;/</xsl :text> 
<xsl :value-of select="$name"/> 
<xs I : text>&gt; </xs I : text> 
<!-- closing bracket 
--> 
<xsl : i f test="$i sHead"> 
<xsl : text>}</xsl : text> 
</xs I : i f> 
</xsl :template> 
<!-- template for attributes --> 
<xs I : templ ate name=" att-query"> 
<xsl :param name="attribute"/> 
<!-- get attribute name --> 
<xsl :variable name="name" select="$attribute/"@name"/> 
<!-- get query expression 
--> 
<xsl :variable name="query" 
sel ect="$attri bute/xs: annotati on/xs :appi nfo/q: query/text () "/> 
<!-- just insert a blank 
--> 
<xsl : text> </xsl : text> 
<!-- append the name followed by '=' 
--> 
<xsl :value-of select="$name"/> 
- - >  

Chapter 13 Schemata in Large Environments 
<xsl : text>=</xsl : text> 
<!-- and the query expression --> 
<xsl :value-of select =' concat (" {",$query,"} ") '/> 
</xsl :template> 
<!-- template to catch annotations 
--> 
<xsl :template match="xs:annotation"> 
</xsl :template> 
</xsl :styl esheet> 
To run this example, an XSLT processor that supports xsl :key clauses is 
required, such as SAXON. This example can handle global and local elements, 
and attributes, but is by no means complete. There is no support for multi- 
component schemata, nor for elements and attributes in global types or global 
groups, and so on. This is left to interested readers as an exercise. 
Note that the original XQuery syntax is used for better readability. XQuery, 
however, features an alternative syntax that would be better suited for the 
embedded use of XQuery. XQueryX [Malhotra2001] provides the same seman- 
tics as XQuery, but uses XML syntax to allow processing of query expressions 
with XML processors. In particular, it would allow cross-checking the XML 
Schema definitions against the XQueryX definitions by means of XSLT. 
This technique of embedding also works with addressing mechanisms and 
transformation languages other than XQuery. In simple cases we may succeed 
by embedding XPath expressions, but XSLT, XPathLog, and others are also can- 
didates for schema-embedded view definition. 
13.1.6 Model-Driven Schema Mediation 
Another possibility for combining domains is to create a new conceptual model 
(see Chapter 2) of the combined domain. By using the modeling language's 
extension mechanism, we can describe the mapping between the domains 
within the conceptual model. An appropriate generator could produce both 
schemata and queries from these definitions. 
In AOM we can use the annotation mechanism to include query expressions 
in the conceptual model. This allows us to define those query expressions wher- 
ever appropriate: in assets, in Level 2 Structures, and on the model level. To 
identify the query language, we use an appropriately defined namespace prefix. 
Figure 13.4 shows a possible mapping for the musician property of asset CD. 
We assume that the prefixes j: and q: have been defined as 
j :http://www. j azz. org/encycl opedi a 
q=http://www, w3. org/TR/xquery 

13.2 Centralized and Decentralized Change Management 
4117' 
productNo 
title 
publisher 
musician(ID, instrument)+ 
decimal price 
A 
musician::<q:map> 
for$musician in j:album[concat("cd",j:productNo/text0)= 
productNo/text()]/j:plays 
return 
<lD>{$musician/j:jazzMusician/j:lD/text0}</ID> 
<instrument>{$musician/j:instrument/text0}<instrument> 
</q:map> 
9 
J 
Figure 13.4 Asset CD with a mapping to j : al bum properties. 
The context expression musician:: relates this annotation to the property 
musician; the query expression derives the instance values for the subproperties 
ID and instrument. 
Since AOM supports the merging of models, we have the option of either 
specifying information structures and mappings within the same conceptual 
model, or separating them into two different models and later merging these 
models. This would allow reusing the same information structures with differ- 
ent mappings. 
13.2 CENTRALIZED AND DECENTRALIZED 
CHANGE MANAGEMENT 
The theme of centralized vs. decentralized change management of information 
resources is as old as the first time-sharing system. Centralized change manage- 
ment is quite easy to accomplish: All changes pass through a central instancem 
usually to the owner of the information objectmto be approved or rejected. In 
large organizations, however, this can result in considerable bureaucratic over- 
head, slowing down operations. 
Take for example a business object Customer. Such a business object may have 
a large number of features, such as billing address, shipping address, account, 
preferences, track record, and so on. In a large company, not every feature is 
important to every department: The shipping department is purely interested in 
the shipping address; the sales department is interested in the account, billing 
address, and the track record; the marketing department may want to know the 
preferences. It makes sense that the maintenance of these features is performed 

Chapter 13 Schemata in Large Environments 
by the corresponding departments. A centralized change management, how- 
ever, would slow down operation: To make a change to the account, the sales 
department would have to apply to the owner of the business object Customer 
(possibly the creator of that object) to perform this change. 
This problem occurs on two levels: on the instance level and on the schema 
level. Let's first discuss decentralized change management for instances of busi- 
ness objects. 
13.2.1 Decentralized Change Management 
of Document Instances 
Relational technology has paved the way for decentralized change manage- 
ment. SQL allows for defining views (see Section 11.6.4) that restrict access to a 
set of relational tables constituting a business object. For example, the shipping 
department operates with a particular view that only gives them access rights to 
the shipping address of a customer. This technique allows each department to 
apply changes to those parts of a business object they are responsible for. 
A similar technology for XML is currently not in sight. Section 12.4 described 
how views on XML documents could be defined with the help of XQuery, but 
XQuery is a pure query language that does not allow updates. 
13.2.2 Decentralized Change Management 
of Document Schemata 
The same problem occurs during the evolution of schemata. If, for example, the 
marketing department needs new elements and attributes in the schema parts 
describing the customer's preferences, it would not be appropriate to bother the 
core information object group with such a task. In SQL this problem is relatively 
easy to solve. The business object Customer exists in the form of multiple rela- 
tional tables. So, it is possible to decentralize the maintenance of the schema by 
assigning the task of table maintenance to those departments that benefit the 
most from a table. 
In object-oriented programming, a real problem exists. Business objects are 
usually implemented in OO as a large class hierarchy. Changes to members of 
the class hierarchy can easily break the delicate inheritance and containment 
relationships that exist in object-oriented structures. The problem of decentral- 
ized change management has therefore sparked the development of a new pro- 
gramming paradigm on top of the OO paradigm: subject-oriented programming 
[Ossher1994]. In subject-oriented programming, large business objects are 
segmented into so-called subjects, which can be maintained individually. Com- 
position rules describe how the subjects are merged into a class hierarchy repre- 
senting the business object. 
The situation in XML is similar: Business objects tend to be large hierarchical 
structures (not an ensemble of flat atomic tables as in relational technology). In 

13.2 Centralized and Decentralized Change Management 
489 
the past, when schemata were authored using DTDs, schema authors made 
extensive use of external entities. Typically, a complex DTD was segmented into 
a few dozen separate external entities. This allowed for the decentralized main- 
tenance of the schema. 
With XML Schema we have similar possibilities. We can use i nc]ude and 
import to compose large schemata from smaller modules. Reusable structures 
such as named simple and complex type definitions, named group and attribute 
group definitions, and global elements allow for coarse- and fine-grained 
decomposition of schemata (see Chapter 6). The use of namespaces prevents 
name clashes between the different schema parts, as shown in Figure 13.5. 
.... Shipping 
www.corp.com/shipping 
<shi ppi ng-~ ..... 
address> I 
[ 
I 
www.corp.com 
~ 
<Custome 
_.. 
www.corp.com/sales 
<bi i I i ng_X~ 
~- 
address> I 
* 
www.corp.com/sales 
Sales 
department 
<account>%~11 
+ 
! 
Core 
business objects 
www.corp.com/marketing 
<preferenc 
I 
'--- Marketing 
www.corp.com/sales 
<track-reco 
Figure 13.5 Managing change: The Core Business Objects group only cares about 
the core component of a business object and the integration. The individual aspects 
of a business object are implemented in the form of schema components that are 
imported into the core component. Using different namespaces for each aspect or 
each instance responsible for change helps to prevent name clashes. 

This Page Intentionally Left Blank

14.1 Integration of Core 
Technologies 
14.2 Grammar-Driven 
Data Models 
I 
t is time to draw some conclusions. The definition of XML 
Schema marks a new step in the development of markup lan- 
guages, but it doesn't stop there. For XML, XML Schema has 
opened the door to various information technologies such as 
databases and enterprise application programming, while for 
these technologies, it has provided a common exchange format 
that will lead to unprecedented levels of integration. 
491 

492 
Chapter 14 Outlook 
14.1 INTEGRATION OF CORE TECHNOLOGIES 
XML Schema contributes to integration by combining existing concepts used in 
the enterprise world with markup technology. The core concepts are relational 
databases and object-oriented programming languages. Chapters 10 and 11 
showed how XML Schema has integrated these concepts, for example, the SQL- 
99 type system. Future versions of SQL, such as SQL-200x, are being developed 
with the XML Schema type system in mind. It is likely that development of 
object-oriented languages will also reflect what XML Schema has achieved. 
Object-oriented languages will probably adopt a few things from functional lan- 
guages (for example, Haskell), which are already well equipped to emulate the 
complex type systems found in markup languages like XML. 
Object-oriented programming and relational databases evolved in the closed- 
world scenarios of client-server enterprise computing. For the new open world 
of electronic business and worldwide information exchange, their data models 
are far too rigid. The data models required for the new scenarios are best char- 
acterized by the document metaphor. Documents have accompanied business 
transactions as long as there has been written history, as seen in our discussion 
of ancient documents and grammars at the beginning of this book. 
14.2. GRAMMAR-DRIVEN 
DATA MODELS 
A core concept for describing documents, grammars are currently the most flex- 
ible method for describing complex data models. Formal grammars have been 
used for ages (well, at least since ALGOL 60) to describe the structure of com- 
puter programs. So it seems logical to use grammars to describe complex data 
structures, too. Grammar-driven data models can provide a strong basis for the 
global exchange of information. This, and because schema languages are based 
on grammars, is why a grammar-driven modeling method was adopted for this 
book. Chapters 2, 3, and 8 demonstrated how to describe conceptual data mod- 
els with Asset Oriented Modeling (AOM) and how to derive XML schemata 
from such models. 
The grammar metaphor will lead the way in the development of XML 
Schema. During the course of the book, especially in Chapters 7 and 8, we have 
compared XML Schema with an alternate schema language: Relax NG. Its foun- 
dation in regular grammars shows clearly on the surface, leading to a lean and 
elegant schema language. However, since Relax NG fails to integrate concepts 
from relational technology and object-oriented technology, it cannot make it 
into mainstream information technology. Nevertheless, XML Schema can learn 
from Relax NG, particularly in the area of nondeterministic schemata (Unique 
Particle Attribution and Element Declarations Consistent--see Section 5.3.18), 
where a more flexible approach is highly desired. 

14.2 Grammar-Driven Data Models 
493 
14.2.1 XML as a Mainstream Technology 
Currently, the major base recommendations of the W3C are being redesigned to 
support XML Schema. In particular, XPath 2.0 (and with it XQuery) will sup- 
port XML Schema data types, and so will XSLT 2.0. The IT industry has also 
taken XML Schema to its heart. Since May 2001, when the XML Schema Rec- 
ommendation was published, XML Schema has gained considerable support 
from the industry, especially in the areas of tool support, APIs, databases, and 
middleware: 
[] A number of XML Schema-enabled productivity tools have been released. 
Among them are schema editors such as XML Spy and TurboXML. These 
tools already have a high degree of maturity and are invaluable aids when 
authoring XML Schema. As these tools become more and more sophisti- 
cated, they will ease the initially steep learning curve for XML Schema, 
bringing more schema authors to XML Schema and attracting people from 
outside the XML camp. 
[] XML Schema-compliant Application Programming Interfaces (APIs) exist 
in the form of XML Schema-compliant SAX and DOM implementations, 
in particular for the programming languages Java and C++. XML Schema- 
compliant binding technologies such as JAXB are in development. 
[] By the time this book goes to market, also the first native XML databases 
conforming to XML Schema or subsets will go to market. Relational data- 
bases that implement SQL-99 or SQL-200x or parts thereof should have no 
trouble supporting XML Schema. 
[] In the middleware area, basically all relevant standards have moved to XML 
Schema. The web services trinity (SOAP, WSDL, UDDI) is based on XML 
Schema, and so is ebXML. BizTalk moved to XML Schema at an early stage. 
With XML Schema, enterprise IT has gained an industry-strength schema 
language that opens up the huge enterprise information resources to the open 
scenarios of the Internet and electronic business by providing a powerful tool 
for data integration and application-to-application communication. For the 
XML community, XML Schema has changed the scenario completely: It has 
transformed XML from a niche technology into a mainstream technologyma 
tremendous window of opportunity for those of us working in the field. 

This Page Intentionally Left Blank

APPENDIX 
Regular Expressions 
for Patterns 
The pattern facet uses the familiar regular expression syntax to restrict the lexi- 
cal space of data types. This appendix gives an overview of the pattern syntax. 
Complex regular expressions can be constructed from simpler ones with the 
help of operators. Let S and T be arbitrary regular expressions, c and d be normal 
characters, and C be a character class (listed below). 
A normal character c is any character that is not a rnetacharacter. Meta- 
characters are., \, ?, *, +, {, }, (,), [, and ]. 
Expression 
Meaning 
c-d 
ST 
SIT 
^S 
S-T 
S? 
S* 
S+ 
S{n,m} 
S{n} 
S{n,} 
The string consisting of character c. 
The string consisting of a character belonging to character 
class C. 
The string consisting of any single character whose code 
value is between c and d (inclusive). 
Concatenation. All strings st with s matching S and t 
matching T. 
Choice. All strings s that match S or T. 
Negation. All strings s that do not match S. 
Difference. All strings s that match S but not T. 
Option. All strings s that match S, or the empty string. 
Powerset. All strings s matching k repetitions of S 
(including k - 0). 
All strings s matching k repetitions of S (including k > 0). 
All strings s matching k repetitions of S (n <-- k <= m). 
All strings s matching exactly n repetitions of S. 
All strings s matching at least n repetitions of S. 
495 

496 
Appendix 
Escape sequences can be used to represent characters that would otherwise 
be regarded as metacharacters. 
Escape Sequence 
Represented Character 
\n 
The newline character (#xA) 
\r 
The return character (#xD) 
\t 
The tab character (#x9) 
\\ 
\ 
\l 
I 
\. 
\- 
\^ 
A 
\? 
? 
\* 
* 
\+ 
+ 
\{ 
[ 
\) 
] 
\( 
( 
\) 
) 
\[ 
[ 
\] 
] 
Character classes are represented by the following escape sequence: 
\p{X} 
A character belonging to the category denoted by X 
Letter categories: 
Category 
L 
Lu 
L1 
Lt 
Lm 
L0 
(see the following tables). 
Represented Characters 
All letters. 
Only uppercase letters. 
Only lowercase letters. 
First character of a word may be uppercase depending on 
language (see Unicode technical report #21). 
Modifier. Various characters such as accents modifying the 
pronunciation of a character. 
Other. 

Appendix 
497 
Marks categories: 
Category 
M 
Mn 
Mc 
Me 
Represented Characters 
All marks. 
All marks, except nonspacing marks. 
Marks combined with whitespace. 
Enclosing marks. 
Numbers categories: 
Category 
Represented 
Characters 
N 
All numbers. This includes numbers that do not rely on 
decimal digits such as roman numbers, encircled numbers, 
bracketed numbers, etc. 
Nd 
Only decimal digits. 
N] 
Letter digits such as roman numbers. 
No 
All other digit symbols. 
Punctuation categories: 
Category 
Represented 
Characters 
P 
All punctuation symbols. 
Pc 
Connector. All connecting symbols, for example, the 
underscore. 
Pd 
Dash. Various connecting dash symbols. 
Ps 
Open. All opening symbols such as opening parentheses or 
brackets. 
Pe 
Close. All closing symbols such as closing parentheses or 
brackets. 
Pi 
Initial quote (may behave like Ps or Pe depending on 
usage). 
Pf 
Final quote (may behave like Ps or Pe depending on usage). 
Po 
Other punctuation symbols. 
Separator categories: 
Category 
Represented 
Characters 
Z 
All separators. 
Zs 
Separating space character. 

498 
Appendix 
Z1 
Zp 
Symbol categories: 
Category 
S 
Sm 
Sc 
Sk 
So 
Other categories: 
Category 
C 
Cc 
Cf 
Co 
Cn 
Abbreviations: 
Escape Sequence 
\s 
\S 
\i 
\I 
\c 
\C 
\d 
\D 
Line separators. 
Paragraph separators. 
Represented Characters 
All symbols. 
Mathematical symbols. 
Currency symbols ($, s 
Modifier. Various characters such as accents modifying the 
pronunciation of a character, similar to Lm. 
Other symbols. 
Represented Characters 
All other characters. 
Control. Nonprintable control characters. 
Formatting characters. 
Private use for user-defined characters. 
Not assigned (no specific meaning within Unicode). 
Equivalent To 
Legend 
[^(\n I \r)] 
Anything except newline or carriage 
return. 
[(#x201 \t [ \n [ \r)] 
XML whitespace characters. 
[^\s] 
XML non-whitespace characters. 
The set of initial XML name characters (Letter I '_' I ':'). 
[^\i] 
Anything except initial XML name 
characters. 
The set of XML name characters (NameChar). 
[^\c] 
Anything except XML name 
characters. 
\p { Nd } 
Decimal digits. 
[^\d] 
Anything except decimal digits. 

Glossary 
Aggregation A complex entity composed of less complex entities. 
AOM Asset Oriented Modeling (see Chapter 2). A modeling method based on regu- 
lar grammars, and unifying the dual concepts of entities and relationships into the 
single concept of assets. 
API Application Programming Interface. A description of the features of a program 
module for the client software wanting to use this module. 
Asset In AOM an asset is an abstract notion for any object or relationship between 
objects that we want to include in a model. 
Association A relationship that somehow correlates entities with others. 
Browser A user agent that presents HTML or XML pages on a computer screen and 
supports navigation over the World Wide Web. 
Business object A business object represents a real-world entity from the business 
problem domain that plays a role within the business scenario. 
Business process A networklike construct of business objects to describe a complex 
value creating (or servicing) business activity. 
Canonical form A preferred syntax and lexical representation for a given content. 
The canonical form allows comparison of objects by their string representation: 
When their string representations are equal, their content is equal, too. 
CASE Computer-aided software engineering. CASE tools support the design of soft- 
ware systems and can automatically generate certain parts of the implementation. 
Roundtrip engineering allows changes in the implementation to be reflected back 
into the conceptual design. 
Constraint A Boolean relation between the properties of one or more information 
items. 
DOM Document Object Model. The DOM provides an API to describe, access, cre- 
ate, and modify SGML-based documents, such as XML or HTML documents. 
DTD Document Type Definition. DTDs define the valid content of an XML 
document. 
499 

500 
Glossary 
Encoding The code system used for a given text. Code systems define a supported 
character set and the mapping of the characters onto a range of integers (character 
codes). 
Entity In XML, entities are used for text substitution, for single characters as well as 
for document parts. In conceptual modeling, an entity is an abstract notion of an 
object that we want to include in a model. 
Facet In XML Schema, a specific constraint defining or restricting the domain of a 
data type. 
Foreign key A key (a property or combination of properties) that can be used to 
refer to external information items. See also Primary key. 
Information set The abstract description of XML document contents, independent 
of syntax. 
Instance An individual of a certain class or type. 
Internet The largest network in the world. The Internet features a three-level hier- 
archy consisting of backbone networks, midlevel networks, and stub networks. It 
spans many different physical networks around the world with various protocols, 
including the Internet Protocol TCP/IP. 
Kleene star An operation that produces the set of all possible concatenations of 
symbols from a given set, including the empty string. 
Lexical space In XML Schema, the lexical space of a data type is defined by the set 
of character strings required to represent all values of this data type. Each value 
may have several representations within the lexical space; one specific representa- 
tion is designated as the canonical form. 
Markup Syntactical means to make text more readable or to add meta-information 
to a text. In English prose, markup consists of punctuation, parentheses, dashes, 
footnotes, and so on. In XML, markup consists of tags. 
Mediation A process that allows diverse software systems to interoperate. Media- 
tion implies syntactical and semantic conversion. See also Ontology. 
Namespace A concept to uniquely separate a set of identifiers from other identi- 
tiers. Namespaces are used to avoid name clashes. In XML, namespaces are identi- 
fied by means of a unique URI. 
Nil value In XML a nil value is an artificial value indicating that a given element 
does not have a value. However, a nilled element may own attributes. 
Nondeterminism Feature of the p-calculus to describe the situation that the 
receiver of a communication when two or more processes "compete" for it cannot 
be predetermined. The process system evolves differently depending on who makes 
the race. 
Normalized string A character string is normalized by reducing whitespace within 
the string to a single whitespace character and by removing any whitespace from 
the beginning and end of the string. 

Glossary 
501 
Null value In object-oriented programming and SQL, a null value is an artificial 
value indicating that a certain variable or column does not have a value. 
Object Constraint Language (OCL) A language defining constraints, pre- and post- 
conditions, and navigation within UML diagrams. 
Object-oriented programming A mainstream programming technique whereby 
data is encapsulated into object instances and can be accessed via the methods 
defined for a given object class. 
Ontology An agreement about a shared conceptualization. Complete ontologies 
consist of vocabularies, thesauri, constraints, and axioms. 
Parser A program that breaks a text string into a series of tokens, labeling each 
token with its grammatical role. XML parsers usually require that a document be 
well formed. Validating parsers can check a document instance against its schema 
definition. 
Powerset See Kleene star. 
Primary key A unique key (a property or combination of properties) that can be 
used to identify an information item. See also Foreign key. 
Regular expression An expression describing a regular set. 
Regular set A set of symbol strings is called regular if it can be obtained from a 
given alphabet of symbols with a finite number of concatenations, unions, and 
Kleene star operations. 
Relational algebra Used to model the data stored in relational databases and 
queries defined on the data. The main relational functions are the set functions like 
union, intersection, and Cartesian product, plus selection (keeping only some 
rows) and projection (keeping only some columns). Relational algebra was devel- 
oped by E. F. Codd. 
Relational database management system (RDBMS) A database system based on 
the relational data model. Queries in relational databases are formulated with SQL. 
Relax NG An alternate schema definition language, issued by the Organization for 
the Advancement of Structured Information Standards (OASIS). 
SAX Simple API for XML. An API that provides methods for parsing XML docu- 
ments (see Parser) and for retrieving elements. 
Schema A definition that defines syntactic and semantic constraints of a certain 
class of information items. 
SGML Standard Generalized Markup Language. A generic language for represent- 
ing documents. SGML is defined in ISO 8879:1986. 
SQL Structured Query Language. SQL is used as an interface to relational database 
management systems (RDBMSs). A series of standards by ISO and ANSI culminated 
in SQL-99 (SQL-3). While the original implementation of SQL in 1986 only sup- 
ported flat tables, SQL-99 strives to provide relational support for complex objects. 
Currently, most RDBMSs support SQL-92. 

$02 
Glossary 
Tag A syntactical means to mark up text. In XML, tags are enclosed in angled 
brackets and can own attributes. 
Ternary association, ternary relationship A relationship between three information 
items. 
Transformation The process of translating an XML document into a differentm 
XML or non-XML--document, for example, for presentation purposes. Transfor- 
mation may include changes in the structure, the vocabulary, the content, and the 
encoding of a document. Popular transformation engines are XSLT processors. 
Unicode A 16-bit character set standard. Unicode covers all major modern written 
languages. 
URI Universal Resource Identifier. A URI uniquely identifies a resource (typically a 
resource on the Internet) with a short string. URIs are defined in http://www.w3.org 
/hypertext/WWW/Addressing/URL/URI_Overview.html. The most common kind of 
URIs are URLs. 
URL Uniform Resource Locator. A URL specifies the address of an Internet resource, 
such as a web page, an image, a sound file, or a script. URLs consist of a transfer 
protocol specification, such as http: or ftp:, a domain name, such as www.w3.org, and 
a path specification, such as http://www.w3.org/hypertext/WWW/Addressing/URL/. 
View An interface to an information item or a set of information items, exposing 
only a limited property set. 
W3C World Wide Web Consortium. A nonprofit organization responsible for the 
development of World Wide Web standards (recommendations). 
Well formed An XML document is well formed if it complies with the syntax con- 
straints defined in the XML 1.0 Recommendation. 
Whitespace Any character that does not ink the paper when printed, for example: 
blank, newline, tab. 
XML Extensible Markup Language. As a "slimmed-down" version of SGML, XML 
became a W3C recommendation in 1998. The XML V l.0 Recommendation speci- 
fies the syntax of well-formed documents and how document classes can be de- 
fined with a DTD. 
XML Schema A W3C recommendation since May 2001, XML Schema introduces 
a hierarchy of built-in and user-defined data types, namespace support, and ad- 
vanced facilities for structure definition and modularization of schemata, thus 
offering an alternative to schema definition with DTDs. 
XPath The W3C recommendation for XPath defines the syntax and semantics of 
access operators to XML document nodes. 
XQuery The W3C Working Draft for XQuery defines the syntax and semantics of 
an XML query language. XQuery is based on XPath V2.0. 
XSLT The W3C recommendation for the Extensible Stylesheet Language (Transfor- 
mations) defines the syntax and semantics of template-based document transfor- 
mation. XSLT is based on XPath. 

Bibliography 
[Berglund2002] Anders Berglund, Scott Boag, Don Chamberlin, Mary F. Fernandez, 
Michael Kay, Jonathan Robie, J&6me Simeon; XML Path Language (XPath) 
2.0, W3C Working Draft; 15 November 2002 
[Biron2001] Paul V. Biron, Ashok Malhotra (eds.); XML Schema Part 2: Datatypes, 
W3C Recommendation; 2 May 2001 
[Boag2002] Scott Boag, Don Chamberlin, Mary F. Fernandez, Daniela Florescu, 
Jonathan Robie, J&6me Simeon; XQuery 1.0: An XML Query Language, W3C 
Working Draft; 15 November 2002 
[Booch1997] G. Booch, I. Jacobson, J. Rumbaugh; The Unified Modeling Language 
for Object Oriented Development, Documentation set, Version 1.0; Rational 
Software Corporation; 1997 
[Boyer2001] John Boyer; Canonical XML, Version 1.0; W3C Recommendation; 15 
March 2001 
[Bray1999] Tim Bray, Dave Hollander, Andrew Layman; Namespaces in XML, 
World Wide Web Consortium; 14 January 1999 
[Bray2000] Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler; Extensible 
Markup Language (XML) 1.0 (Second Edition); W3C Recommendation; 6 
October 2000 
[Buck2000] Lee Buck, Jonathan Robie, Scott Vorthmann; The Schema Adjunct 
Framework, Draft; 30 November 2000; Extensibility specification 
[Budd1997] Timothy Budd; An Introduction into Object-Oriented Programming, 
Second Edition; Addison-Wesley; Reading, MA; 1997 
[Bush1945] Vannevar Bush; As We May Think; The Atlantic Monthly; July 1945 
[Chen1976] P. P. Chen; The Entity-Relationship Model: Toward a Unified View of 
Data; ACM Transactions on Database Systems 1:1 pp. 9-36; 1976 
[Chomsky1956] Noam Chomsky; Three Models for the Description of Language; 
IRE Transactions on Information Theory IT-2:113-124; 1956 
[Christensen2001] Erik Christensen, Francisco Curbera, Greg Meredith, Sanjiva 
Weerawarana; Web Services Description Language (WSDL) 1.1; W3C Note; 15 
March 2001 
503 

5t)41 
Bibliography 
[Clark1999] James Clark, Steve DeRose; XML Path Language (XPath), Version 1.0, 
W3C Recommendation; 1999 
[Clark1999a] James Clark (ed.); XSL Transformations (XSLT), Version 1.0, W3C Rec- 
ommendation; 16 November 1999 
[Clark2001] James Clark, Murata Makoto; RELAX NG Tutorial, Committee Specifi- 
cation; 3 December 2001; OASIS 
[Clark2001a] James Clark, Murata Makoto; RELAX NG DTD Compatibility, Com- 
mittee Specification; 3 December 2001; OASIS 
[Codd1991] E. F. Codd; The Relational Model for Database Management (version 
2); Addison-Wesley, Reading, MA; 1991. 
[Costello2000] Roger L. Costello, John C. Schneider; Challenge of XML Schemas-- 
Schema Evolution; The MITRE Corp.; 2000 
[Cowan2001] John Cowan, Richard Tobin (eds.); XML Information Set, W3C Rec- 
ommendation; 24 October 2001 
[Cowan2002] John Cowan; XML 1.1, W3C Candidate Recommendation; 15 Octo- 
ber 2002 
[Daum2002] Berthold Daum, Udo Merten; System Architecture with XML; Morgan 
Kaufmann Publishers; 2002 
[Eastlake2002] Donald Eastlake, Joseph Reagle, David Solo; XML-Signature Syntax 
and Processing, W3C Recommendation; 12 February 2002 
[Eisenberg2002] Andrew Eisenberg, Jim Melton; SQL/XML is Making Good 
Progress; SIGMOD Volume 31, Number 2; June 2002 
[Fallside2001] David C. Fallside (ed.); XML Schema Part 0: Primer, W3C Recom- 
mendation; 2 May 2001 
[Fan2001] W. Fan, L. Libkin; On XML Integrity Constraints in the Presence of DTDs; 
In Proc. ACM PODS; 2001 
[Finkelstein1998] Clive Finkelstein; "Information Engineering Methodology," 
Handbook on Architectures of Information Systems, eds. P. Bernus, K. Mer- 
tins, and G. Schmidt, Springer-Verlag, Berlin, pp. 405-427; 1998 
[Goldfarb2000] Charles F. Goldfarb, Paul Prescod; The XML Handbook, Second Edi- 
tion; Addison-Wesley; Harlow; 2000 
[Grosso2001] Paul Grosso, Daniel Veillard; XML Fragment Interchange, W3C Can- 
didate Recommendation; 12 February 2001 
[Halpin1999] Terry Halpin; Entity Relationship Modeling from an ORM Perspec- 
tive; The Journal of Conceptual Modeling; December1999-August2000 
[Holman2001] G. Ken Holman; Information Technology--Document Description 
and Processing Languages, ISO/IEC JTC 1/SC34; 2001 
[Hosoya2000] Haruo Hosoya, J6r6me Vouillon, Benjamin C. Pierce; Regular Expres- 
sion Types for XML; Department of Computer and Information Science, Uni- 
versity of Pennsylvania; 2000 

Bibliography 
$05 
[Hosoya2000a] Haruo Hosoya, Benjamin Pierce; XDuce: A Typed XML Processing 
Language (Preliminary Report), in Proceedings of Third International Work- 
shop on the Web and Databases (WebDB2000) 
[Kay2001] Michael Kay; XSLT Programmer's Reference 2nd Edition; wrox; 2001 
[Kay2002] Michael Kay; XSL Transformations (XSLT). Version 2.0, W3C Working 
Draft; 15 November 2002 
[Kleene1956] Stephen Cole Kleene; Representation of Events in Nerve Nets and 
Finite Automata; Automata Studies; Princeton; 1956 
[KLEEN2002] KLEEN White Paper; www.aomodeling.org; 2002 
[Krishnamurthy2000] Vishu Krishnamurthy, Muralidhar Krishnaprasad; Effectively 
Publishing XML Data Using Object-Relational Technology, H2-2000-457; 
Oracle Corporation; 2000 
[Kroenke1995] David M. Kroenke; Database Processing: Fundamentals, Design, and 
Implementation; MacMillan; 1995 
[LeHors2002] Arnaud Le Hors, Gavin Nicol, Lauren Wood, Mike Champion, Steve 
Byrne; Document Object Model (DOM) Level 3 Core Specification, Version 
1.0, W3C Working Draft; 22 October 2002 
[Malhotra2001] Ashok Malhotra, Jonathan Robie, Michael Rys; XML Syntax for 
XQuery 1.0 (XQueryX), W3C Working Draft; 7 June 2001 
[Malhotra2002] Ashok Malhotra, Jim Melton, Jonathan Robie, Norman Walsh; 
XQuery 1.0 and XPath 2.0 Functions and Operators Version 1.0; W3C Work- 
ing Draft; 15 November 2002 
[Marjomaa2002] Esko Marjomaa; "Peircean" Reorganization in Conceptual Model- 
ing Terminology; Journal of Conceptual Modeling, Issue 23; January 2002 
[Marsh2001] Jonathan Marsh; XML Base, W3C Recommendation 27; June 2001 
[Martin1993] James Martin; Principles of Object Oriented Analysis and Design; 
Prentice Hall, Englewood Cliffs, NJ; 1993 
[May2001] Wolfgang May; Integration of XML Data in XPathLog; Institut fiir Infor- 
matik, Universit~it Freiburg, Germany; 2001 
[Melton2001] Jim Melton (ed.); Foundation (SQL/Foundation), ISO-ANSI Working 
Draft; American National Standards Institute; 2001 
[Melton2001a] Jim Melton (ed.); XML-Related Specifications (SQL/XML), ISO-ANSI 
Working Draft; American National Standards Institute; 2001 
[Meyer1997] Bertrand Meyer; Object-Oriented Software Construction; Prentice Hall 
PTR; Upper Saddle River, NJ; 1997. 
[Murata1995] Murata Makoto; Forest-Regular Languages and Tree-Regular Lan- 
guages; 26 May 1995 
[Murata2001] James Clark, Murata Makoto; RELAX NG Specification, Committee 
Specification; 3 December 2001; OASIS 

$06 
Bibliography 
[Naur1960] Peter Naur (ed.); Revised Report on the Algorithmic Language ALGOL 
60; Communications of the ACM, Vol. 3 No.5, pp. 299-314; May 1960. 
[Nelson1982] Ted. H. Nelson, Literary Machines; Mindful Press; 1982 
[OCL1997] Object Constraint Language Specification, Version 1.1; joint docu- 
ment from Rational Software, Microsoft, Hewlett-Packard, Oracle, Sterling 
Software, MCI Systemhouse, Unisys, ICON Computing, IntelliCorp, i-Logix, 
IBM, ObjecTime, Platinum Technology, Ptech, Taskon, Reich Technologies, 
Softeam; 1997 
[Ossher1994] Harold Ossher, William Harrison, Frank Budinsky, Ian Simmonds; 
Subject-Oriented Programming: Supporting Decentralized Development of 
Objects; IBM Thomas J. Watson Research Center; 1994 
[Silberschatz2001] Abraham Silberschatz, Henry F. Korth, S. Sudarshan; Database 
System Concepts, Fourth Edition, McGraw-Hill; 2001 
[St.Laurent1999] Simon St.Laurent; Toward a Layered Model for XML; simonstl 
.corn; 1999 
[Thalheim2000] Thalheim, Bernhard; Entity-Relationship Modeling; Springer- 
Verlag; Heidelberg; 2000 
[Thompson2001] Henry S. Thompson, David Beech, Murray Maloney, Noah 
Mendelsohn (ed.); XML Schema Part 1: Structures, W3C Recommendation; 2 
May 2001 
[Whitmer2002] Ray Whitmer; Document Object Model (DOM) Level 3 XPath Spec- 
ification, Version 1.0, W3C Working Draft; 28 March 2002 
[Wiederhold199 7] Gio Wiederhold, Michael Genesereth; "The Conceptual Basis for 
Mediation Services"; IEEE Expert, v. 12, n. 5, pp. 38-47; Sept.-Oct. 1997 
[Williams2001] Stuart Williams, Mark Jones; XML Protocol Abstract Model; W3C 
Working Draft; 9 July 2001 

Index 
Symbols and Numbers 
< > (angle brackets) in BNF 
notation, 29 
::= (colon-equals) in BNF 
notation, 29 
{ } (curly braces) in regular set 
notation, 30 
( ) (parentheses) for empty 
sequence notation, 36 
+ (plus sign) 
as AOM particle or property 
modifier, 56 
as AOM property type 
modifier, 58 
for cardinality constraints for 
arcs, 53 
for cardinality constraints in 
DTDs, 109 
? (question mark) 
as AOM particle or property 
modifier, 55 
as AOM property type 
modifier, 58 
for cardinality constraints for 
arcs, 53 
for cardinality constraints in 
DTDs, 109 
* (star) 
as AOM particle or property 
modifier, 56 
as AOM property type 
modifier, 59 
for cardinality constraints for 
arcs, 53 
for cardinality constraints in 
DTDs, 109 
for powerset operator, 31, 37 
for reversed arcs, 65 
I (vertical bar) 
in BNF notation, 29 
in regular set notation, 30 
1NF (First Normal Form). See 
normalization of relational 
data structures 
A 
abbreviations for pattern 
constraining facet (XML 
Schema), 498 
abstract data types 
defining abstract master 
schema using (XML 
Schema), 204-209 
limitations, 35 
abstract master schema (XML 
Schema) 
defining using abstract types, 
204-209 
defining using dangling type 
definitions, 209-213 
defining using substitution 
groups, 200-204 
abstract patterns (Relax NG), 
236-240 
acrophony, 7 
administration, document 
metaphor's importance 
for, 4 
aggregation 
complex data types for (XML 
Schema), 141 
modeling aggregated items 
assets or properties in 
AOM, 73-76 
agrarian societies, writing 
and, 6 
a] bum asset 
as business object, 260 
hierarchical order in, 10 
Inside Out XML document, 
254-257 
KOln Concert XML document, 
256-257 
L2S and, 81 
overview, 76 
sequential order in, 9 
a] bum business object 
with cross-field constraints 
(Relax NG), 332-333 
with cross-field constraints 
(XML Schema), 327-332, 
333-335 
for jazz knowledge base 
(Relax NG), 308-311 
for jazz knowledge base 
(XML Schema), 277-280, 
281 
a ] bum database, 401-415 
converting table to 1NF 
(flattening), 405-406 
defining the target format, 
402-403 
Integrity Rules for cardinality 
constraints, 410 
introducing key 
relationships, 406-410 
keys, 406-407 
overview of normalization 
process, 401-402 
preserving sequential order, 
410-414 
recomposing original 
document nodes, 
414-415 
repeating elements, 410 
507 

$08 
Index 
a] bum database (continued) 
schema to be normalized, 
403-405 
a] bum schema normalization. 
See a] bum database 
al bum_type grammar 
(Relax NG), 297 
algebra 
for regular expressions, 
30-31, 32 
for regular types, 37-38 
relational, 398-401 
ALGOL 60, 29 
a l ] connector (XML Schema), 
144-146 
alphabets 
for formal grammars, 27 
for grammar generating 
currency amounts, 27 
for HRGs, 32 
regular sets and, 30, 31 
alter table command (SQL), 
418 
angle brackets < > in BNF 
notation, 29 
annotation clause (XML 
Schema), 195-196 
annotations 
of AOM assets, 51 
of AOM models, 67 
footnotes, 12 
help texts, 12 
margins and nonlinear 
reading, 12 
in Relax NG, 224-225 
sidebars, 12 
in XML Schema, 195-196 
ANY terminal symbol in DTDs, 
108 
any wildcards (XML Schema) 
declaring, 168, 182 
namespaces and, 182-183 
open content model and, 
465-466 
processing methods for, 182 
anyAttri bute wildcards (XML 
Schema) 
declaring, 168, 182 
namespaces and, 182-183 
open content model and, 
465-466 
processing methods for, 182 
anyName name class (Relax NG), 
243-246 
anyType built-in data type 
(XML Schema) 
for empty elements, 157-158 
as generic complex type, 142, 
201 
substitution groups and, 201 
anyURI primitive data type 
(XML Schema) 
mapping onto OO types, 376 
overview, 126 
SQL equivalent function, 423 
anyXhtml grammar (Relax NG), 
298-299 
AOM (Asset Oriented 
Modeling), 48-70 
arcs, 52-53 
assets, 48-52 
basics, 48-50 
clusters, 53, 54 
constraints, 51, 62 
differentiation from other 
modeling methods, 48 
ERM entities and 
relationships and, 48-50 
inheritance, 60-61 
Level 2 Structures (L2S), 
62-66 
main features, 68-70 
merging rules, 68 
for model-driven schema 
mediation, 486-487 
models, 66-68 
namespaces, 66, 67, 68 
properties, 53-57 
reasons for using, 48 
type expressions, 58 
types, 57-60 
Web site, 48, 68 
XML Information Set 
modeled in, 91, 94 
XPath for constraint 
formulation in, 323, 
338-341 
See also specific components 
Apache's Jakarta project, 341 
appi n fo element (XML 
Schema), 195-196 
arcs (AOM) 
assets connected by, 52 
cardinality constraints for, 
52-53, 65 
clusters, 53, 54 
constraints across assets 
using, 62 
key specification, 52 
overview, 52-53 
range, 52 
RDF arcs and, 48 
reversal for identifying 
assets, 65 
role name, 52 
AroUML CASE tool, 337 
"As We May Think," 13 
assert clause (Schematron), 
352-353 
Asset Oriented Modeling. 
See AOM (Asset Oriented 
Modeling) 
assets (AOM) 
annotations, 51 
completely typed example, 
59 
constraints across, 62 
constraints between 
properties, 51, 62 
definition schema, 50-51 
entities and relationships as, 
48-50 
identifying assets of L2S, 
64-65 
keys, 51 
L2S grouping of, 62-63 
labels, 50-51 
merging, 68 
modeling aggregated items 
as, 73-76 
modeling nouns and verbs 
as, 73 
name, 51, 52 
normalization requirements 
for, 76-77 
operations, 51 
overview, 48-52 
in PNF, 78 
properties of, 51 
properties vs., 73-74 
RDF nodes and, 48 
scope, 51 
associative operations, 36 
Astarita, Glenn 

Index 
$09 
cri ti c XML document for, 
257 
review XML document for, 
257 
asterisk. See star (*) 
ATTLIST rules in DTDs, 109-110 
attribute groups (XML Schema), 
186 
attribute type property of 
attributes (XML), 96 
attri buteFormDefaul t 
specification (XML 
Schema), 180-181 
attributes (relational database), 
397 
attributes (Relax NG) 
defining alternatives, 219 
generic (wildcards), 243-244 
interleaving, 222 
merging attribute groups, 
235-236 
namespaces and, 241 
overview, 216-217 
attributes (XML) 
built-in primitive types, 
110-111 
canonical form, 104 
definition in DTDs, 109-111 
example, 100 
information item (XML 
Information Set), 92, 96, 
100 
normalization of values, 102 
properties of information 
item, 96 
property of elements (XML), 
95 
attributes (XML Schema) 
adding to simple type 
element, 455-456 
attribute groups, 186 
default values, 150 
defining, 159-160 
DTD equivalent, 159 
fixed values, 150 
global, 161-162 
qualified names for, 180-182 
redefining, 193 
automatic code generation, OO 
environments and, 
392-393 
axioms in algebra for regular 
expressions, 32 
Ayler, Albert, XML document 
for, 252-253 
B 
Backus-Naur-Form (BNF), 29-30 
bags, 11-12 
band asset 
deletion of, 77, 78 
overview, 76 
band business object (XML 
Schema), 280-282, 284 
base URI property (XML) 
of document node, 95 
of elements, 96 
of processing instructions, 97 
base64Bi navy primitive data 
type (XML Schema) 
OO languages and, 374 
overview, 126 
SQL binary types and, 422 
behavior of objects 
overview, 368 
type hierarchies based on, 
369-370 
bel ongsTo asset 
L2S and, 84 
overview, 74-75 
bel ongsTo_type grammar 
(Relax NG), 297-298 
binding between XML and OO 
structures 
phases during creation, 367 
phases when running the 
application, 367 
products for, 367 
Bley, Carla, 10 
b] ock attribute (XML Schema), 
453 
BNF (Backus-Naur-Form), 29-30 
bookshop example 
combining model with jazz 
knowledge base model, 
472-475 
completed AOM model for, 
68, 69 
L2S structures, 64, 65-66 
simple AOM model for, 
49-50 
boolean primitive data type 
(XML Schema) 
mapping onto OO types, 374 
overview, 122 
SQL BOOLEAN type and, 422 
Boolean set operators, HRGs 
and, 34 
bounded fundamental facet 
(XML Schema), 121 
Breeze XML Studio, 367 
built-in data types (XML 
Schema) 
constructed types, 127, 
131-136 
hierarchy of, 136 
primitive types, 121-126 
built-in primitive types (XML), 
110-111 
Bush, Vannevar, 13 
business documents 
advantages as schema 
boundaries, 258, 260 
defined, 258, 260 
L2S representation of, 63 
Level 1 Structure as, 260 
metaphor's importance, 4 
business objects 
al bum (Relax NG), 308-311 
al bum (XML Schema), 
277-280, 281 
band (XML Schema), 
280-282, 284 
clusters in (Relax NG), 
314-316 
clusters in (XML Schema), 
284-287 
critic (Relax NG), 316-317 
cri t i c (XML Schema), 260, 
287, 289 
decentralized change 
management and, 488-489 
implementing for jazz 
knowledge base (XML 
Schema), 271-277 
jazzMusician (Relax NG), 
304-308 
jazzMusi ci an (XML Schema), 
271-277 
LIS representation for jazz 
knowledge base (XML 
Schema), 260 
business objects 

$10 
Index 
business objects (continued) 
L2S representation (AOM), 
63 
multiple display labels and 
(Relax NG), 311-313 
navigation and 
implementation of, 
320-321 
project (Relax NG), 311-313 
project (XML Schema), 280, 
282-284 
review (Relax NG), 314-316 
review (XML Schema), 
284-287, 288 
style (Relax NG), 317-318 
styl e (XML Schema), 
289-290 
substitution groups for (XML 
Schema), 280-284 
byte built-in constructed data 
type (XML Schema) 
mapping onto OO types, 
374-375 
overview, 135 
C 
canonical form (XML), 101-105 
for attributes, 104 
for comments, 105 
for elements, 104 
for processing instructions, 
105 
for removal of redundant 
nodes, 103 
for resolved references, 
102-103 
for text, 101-102 
W3C recommendation, 101 
for whitespace, 102 
canonical representations 
(XML Schema) 
of built-in primitive data 
types, 121-126 
lexical representations vs., 
120 
"Canonical XML" 
recommendation (W3C), 
101 
cardinality constraints 
arc reversal and, 65 
for arcs (AOM), 52-53 
for complex data types (XML 
Schema), 149-150, 157 
cross-document, 336 
DTDs and, 109, 115, 149, 150 
making narrower, avoiding, 
464 
mapping XML Schema 
hierarchies onto OO 
constructs and, 377-380 
Relax NG, 222-223 
on XML Schema particles, 
139, 143, 149-150 
cardinal i ty fundamental facet 
(XML Schema), 121 
Cartesian product operation 
in relational algebra, 398-399 
in SQL queries, 416 
cascading actions (SQL), 431 
CASE tools, 337 
Castor, 367 
cave paintings, as documents, 7 
CD schema file, 455-456 
CDATA primitive attribute type 
(XML), 110 
CDATA sections (XML), 
canonical form and, 102 
CD_pri ceWi thCurrency schema 
file, 456 
centralized change 
management, 
decentralized vs., 487-488 
chameleon schema 
components 
Relax NG, 242-243 
for schema evolution (XML 
Schema), 446, 447-450 
XML Schema, 197-199 
character code property of 
characters (XML), 98 
character encoding scheme 
property of document 
node (XML), 95 
characters (XML) 
canonical form for text, 
101-102 
example, 100 
information item (XML 
Information Set), 87-89, 
92, 100 
metacharacters, 495 
properties, 97-98 
Chen, Peter, 44, 47 
child nodes (XML Schema), 
appending to nested 
structures, 457-458 
children property (XML) 
of document node, 93 
of DTD information item, 
98 
of elements, 95 
Chinese script, 6-7 
choice 
mapping XML Schema 
choice groups onto OO 
structures, 384-385 
need for schemata and, 
23-24 
nondeterminism and, 465 
redefinition to allow, 
461-464 
translating XML Schema into 
SQL, 428-430 
<choice> clause (Relax NG) 
alternatives enclosed in, 
217-219 
for combining name classes, 
244 
for enumerations, 226-227 
merging grammars and, 
234-235 
for union type, 228 
choi ce connector (XML 
Schema) 
I connector in DTD and, 146 
foreign keys for choice 
groups, 174 
mapping choice groups onto 
OO structures, 384-385 
nesting, 147-148 
nondeterminism and, 465 
overview, 146-147 
redefinition for, 461-464 
translating into SQL, 
428-430 
Chomsky, Noam, 26 
Clark, James, 215 
classes (OO languages) 
hierarchies, 369 
instances, 369 
overview, 369 
visibility, 394 
classic data types, 35 
clustered inheritance (AOM), 
60, 61 

Index 
$11 
clusters 
AOM, 53, 54 
business objects and 
(Relax NG), 314-316 
business objects and 
(XML Schema), 284-287 
Codd, E. F., 50 
col I aboration asset 
L2S and, 81 
overview, 76 
XML document for, 253-254 
colon-equals (::=) in BNF 
notation, 29 
combi nedCD virtual document 
type, 479-480 
combining diverse schemata, 
472-487 
combining document 
instance sets, 475-479 
embedded queries, 480-486 
model fusion, 472-475 
model-driven schema 
mediation, 486-487 
problem statement, 472 
schema-driven view 
definition, 479-480 
combining name classes 
(Relax NG), 244-246 
comments (XML) 
canonical form, 105 
information item (XML 
Information Set), 98 
normalization, 105 
commutative operations, 36 
compactness of AOM, 68-69 
completeness 
of asset types, 77 
conceptual modeling 
principle of, 44 
complex content (XML 
Schema) 
definitions, 153-156 
model, 142 
complex data types (XML 
Schema) 
aggregation using, 141 
attributes, 159-160 
cardinality constraints, 
149-150, 157, 377-380 
complex content, 153-156 
constraints for restricting, 
157 
content models for, 142 
described, 139 
deterministic, 176-178 
empty elements, 156-158 
global attributes, 161-162 
global elements, 161-165, 
386-387 
global types, 160-161, 
387-388 
local types, 160-161 
mapping onto OO 
constructs, 377-387 
mapping onto relational 
structures, 424-430 
mixed content, 150-152 
model groups, 143-148 
nullability, 169-170 
recursive structures using 
global elements, 162-165 
recursive structures using 
global types, 165-168 
redefining, 192 
for root element, 139 
simple content, 152-153 
type definition hierarchies, 
156 
wildcards, 168-169 
xs :anyType as generic type 
for, 143 
c0mpl exType declaration (XML 
Schema) 
overview, 141 
type libraries and, 261 
See also complex data types 
(XML Schema) 
composite keys of assets 
(AOM), 51 
concatenation operation 
for regular expressions, 36 
for regular sets, 30 
conceptual modeling, 41-47 
ad-hoc business 
collaborations and, 47 
benefits, 42-43 
communication as purpose 
of, 43 
constraints in, 327-341, 
391-392 
enterprise software 
development and, 42, 47 
Entity Relationship 
Diagrams, 44-46 
guiding principles, 44 
implementation neutrality 
of, 42--43 
IT trends and, 43 
iterative development cycles 
and, 47 
for jazz knowledge base, 
Draft 1, 73, 75 
for jazz knowledge base, 
Draft 2, 78-79 
for jazz knowledge base, 
Draft 3, 81, 82 
for jazz knowledge base, 
Draft 4, 82, 83 
for jazz knowledge base, 
Draft 5, 84-85 
for jazz knowledge base, final 
draft, 84, 86, 259 
for jazz knowledge base, with 
added constraints, 339 
model fusion, 472-475 
model-driven schema 
mediation, 486-487 
reality of, 47 
roundtrip engineering for, 47 
XML and, 41 
See also AOM (Asset Oriented 
Modeling) 
conceptualization, conceptual 
modeling principle of, 44 
connectors for model group 
construction (XML 
Schema), 143-148 
constraining facets (XML 
Schema) 
of built-in primitive data 
types, 122-126 
defined, 121 
implementing in OO 
languages, 390-391 
OO languages and, 376 
for restricted data types, 
129-131 
SQL type parameters and, 
423-424 
constraints 
in ALGOL 60, 29 
in AOM, 51, 62 
in conceptual models, 
327-341, 391-392 
cross-document, 335-337 
cross-field, 330-335 

512 
Index 
constraints (continued) 
cross-reference, 29, 327-330 
data types as, 34 
on data types (XML Schema), 
157, 327 
duration (Schematron), 
354-355 
duration (XSLT), 344-346 
Element Declarations 
Consistent (XML Schema), 
178 
formal semantics and, 
324-325 
hard-coded, 323, 341-344 
on identifying assets, 64-65, 
82 
language for AOM models, 
67 
on multiple values, 325-326 
OO environments and, 
390-393 
relational environments and, 
430-431 
Schematron for validating, 
348-360 
semantic vs. syntactical, 14, 
23 
soft-coded, 323, 344-348 
in SQL, 430-431 
structural or syntactical, 14 
uniqueness, 327 
wildcards and (XML 
Schema), 182 
in XML Schema, 157, 
327-330 
XPath for, 323, 338-341 
XSLT for validating, 344-348 
See also cardinality 
constraints; Schematron 
constructed data types (XML 
Schema) 
built-in types, 127, 131-136 
extended by list, 127-128, 
376 
extended by union, 127, 
137-138, 376 
hierarchy of built-in data 
types, 136 
mapping onto OO types, 
374-376 
overview, 127 
restricted, 127, 128-131 
content models 
context-sensitive, 33-34 
deterministic vs. 
nondeterministic, 40, 
176-178 
open, for schema evolution, 
465-467 
content property (XML) 
of comments, 98 
of processing instructions, 97 
context expressions (AOM), 62 
context for Relax NG elements, 
216 
context-free grammars 
Backus-Naur-Form (BNF), 
29-30 
defined, 28 
context-sensitive content 
models, HRGs for defining, 
33-34 
context-sensitive elements, 
DTDs and, 115 
converters (Relax NG), 248 
corporate environments. See 
large environments 
correspondence, conceptual 
modeling principle of, 44 
Cratylus, 26 
create command (SQL), 418 
create type command (SQL- 
99), 420 
c rit i c asset 
as business object, 260 
is a relationship resolution, 
n 
81 
overview, 76 
XML document for Astarita, 
257 
cri t i c business object 
Relax NG, 316-317 
XML Schema, 260, 287, 289 
cri ti c_type complex type 
(XML Schema), derivation 
of, 264-265 
cri t i c_type grammar (Relax 
NG), 295-296 
cross-document constraints, 
335-337 
cardinality constraints, 336 
general constraints, 336 
referential integrity 
constraints, 335 
Schematron for, 355-356 
uniqueness constraints, 335 
validating, 336-337 
XSLT for, 346-348 
cross-field constraints 
al bum schema and (XML 
Schema), 327-332, 
333-335 
for al bum schema (Relax NG), 
332-333 
beyond XML Schema, 
330-335 
cross-references 
ALGOL 60 variables and, 29 
BNF and cross-reference 
constraints, 29 
checking XML Schema cross- 
references in OO 
languages, 391 
constraints, 29, 327-330 
DTDs and, 111, 115 
grammars and, 29-30 
hypertext development 
and, 13 
internal vs. between 
documents, 13 
for jazz knowledge base 
(XML Schema), 277-280 
as nonlinear ordering, 13 
cuneiform writing, 6, 9, 11 
curly braces ({}) in regular set 
notation, 30 
customizing patterns (Relax 
NG), 234-236 
D 
dangling type definitions 
(XML Schema) 
defining abstract master 
schema using, 209-213 
schema evolution and, 446 
<data> clause (Relax NG), 226 
data models 
enterprise, 471 
grammar-driven, 492 
OO implementations (XML), 
366-367 
relational, 397 
Relax NG, 216 
See also XML Information 
Set 

Index 
$113 
data type substitution. 
See substitution groups 
(XML Schema) 
data types 
abstract, 35 
of AOM properties, 54-55, 
57-60 
classic, 35 
constraints, 34, 156, 327 
defining with SQL-99, 420 
DTD limitations, 115 
hierarchy based on behavior 
(OO languages), 369-370 
hierarchy based on syntax 
(OO languages), 370 
hierarchy in XML Schema, 
38-39, 156 
hierarchy of built-in data 
types (XML Schema), 136 
inheritance in XML Schema, 
262-265 
primitive types supported by 
DTDs, 110-111 
regular, 34-40 
as regular expressions, 35 
Relax NG, 226-228 
simple data types (XML 
Schema), 120-139 
type expressions (AOM), 58 
user-defined, 115 
XML Schema vs. DTD, 119 
XML vs. OO, 370-373 
See also complex data types 
(XML Schema); object- 
oriented data types; 
regular types; simple 
data types (XML Schema); 
SQL data types; type 
systems 
data-centric content, 
document-centric content 
vs., 14 
date primitive data type (XML 
Schema), 124 
dateTime primitive data type 
(XML Schema) 
OO languages and, 375-376 
overview, 124 
SQL types and, 423 
decentralized change 
management 
centralized change 
management vs., 487-488 
of document instances, 488 
of document schemata, 
488-489 
decimal primitive data type 
(XML Schema) 
mapping onto OO types, 
374-375 
overview, 122 
SQL DECIMAL type and, 422 
declaration base URI property 
(XML) 
of unexpanded entity 
reference, 97 
of unparsed entity, 99 
decomposition, conceptual 
modeling principle of, 44 
defaults 
schema namespace (XML 
Schema), 183-184 
type system for properties 
(AOM), 57 
values, cautions regarding 
(XML Schema), 464-465 
values for attributes (XML 
Schema), 150 
values (Relax NG), 225 
DeJohnette, Jack 
in Keith Jarrett Trio, 253-254 
XML document for, 
251-252 
delete command (SQL), 418, 
419 
derived data types (XML 
Schema), 446-454 
block attribute and, 453 
chameleon schema 
components, 446, 447-450 
creating derived schemata, 
450-451 
final attribute and, 446, 453 
fundamental facets and, 120 
inhibiting change form, 453 
schema-conservative 
evolution techniques, 446 
substitution groups for 
schema evolution, 446, 
451-453, 454 
See also constructed data 
types (XML Schema) 
derived schemata, 450-451 
descri pti on_type grammar 
(Relax NG), 298 
deterministic content models, 
nondeterministic vs., 40, 
176-178 
deterministic regular 
expressions, 39 
deterministic types 
defined, 39 
regular types, 39-40 
in XML Schema, 176-178 
di agnostic section 
(Schematron), 353 
di agn0sti cs attribute 
(Schematron), 353 
difference operation in 
relational algebra, 398 
digital documents, 8 
D0CTYPE declaration 
referencing external subset of 
DTD, 106, 107 
referencing internal subset of 
DTD, 106-107 
SYSTEM identifier, 106 
document element property of 
document node (XML), 93 
document instances 
combining document 
instance sets, 475-479 
decentralized change 
management of, 488 
DTDs and, 106-107 
formal languages and, 14-15 
generators for (Relax NG), 
248 
namespaces as connection 
with schemata, 180, 181 
overriding types (XML 
Schema), 186-188 
document nodes (XML) 
example, 100 
information item (XML 
Information Set), 92, 93, 
95, 100 
properties, 93, 95 
Document Object Model 
(DOM), 341, 366 
"Document Object Model 
(DOM) Level 3 XPath 
Specification," 341 
Document Schema Definition 
Language (DSDL), 362 

$114 
Index 
document schemata, 14-26 
choices in, 23-24 
composition with XML 
Schema, 190-196 
decentralized change 
management of, 488-489 
document types defined by, 
14 
DTD example, 15-17 
DTDs vs. XML Schema, 106 
equivalent definitions, 14 
recursion in, 24-26 
Relax NG example, 20-23 
XML Schema example, 
17-20 
See also schema evolution 
Document Type Definition. See 
DTD (Document Type 
Definition) 
document types 
document schemata 
defining, 14 
regular types, 34-40 
XML Schema constructor for, 
34 
documentation element (XML 
Schema), 195 
document-centric content 
data-centric content vs., 14 
object-oriented concepts vs., 
368 
documents 
defined, 8 
document-centric vs. data- 
centric content, 14 
early forms of, 6-8 
linear order in, 8-10 
metaphor's pervasive 
importance, 4 
nonlinear order in, 11-13 
nontangible, 8 
scripture, 6-7 
See also document instances 
DOM (Document Object 
Model), 341, 366 
domain constraints (SQL), 
430-431 
d0ub] e primitive data type 
(XML Schema) 
mapping onto OO types, 375 
overview, 123 
SQL FLOAT type and, 422-423 
drop table command (SQL), 
418 
DSDL (Document Schema 
Definition Language), 362 
DTD (Document Type 
Definition), 105-115 
attributes, 109-111 
cardinality constraints and, 
109, 115, 149, 150 
context-sensitive content 
models and, 34 
cross-references, 111 
deficiencies, 114-115, 170 
deterministic DTDs, 40 
document composition, 112 
document instances and, 
106-107 
DTD-aware parsers and the 
XML Information Set, 91, 
93 
elements, 107-109 
extension mechanisms, 
111-112 
external subset, 106, 107 
information item (XML 
Information Set), 92, 98 
internal subset, 106-107 
introduction of, 15 
model groups, 109 
non-terminal symbols and, 
34, 108, 109 
overview, 105-106 
parameter entities in, 
113-114 
purchase order document 
schema example, 15-17 
recursion example, 24-25 
regular expressions in, 31 
regular grammars vs., 108 
Relax NG vs., 23, 246, 
360-361 
schema composition and 
reuse mechanisms, 
113-114 
Schematron vs., 360-361 
terminal symbols, 108 
translation into XML 
Schema, 195 
user-defined entities, 112 
XML processing model and, 
360-361 
XML Schema vs., 19, 106, 
118-119, 170, 360-361 
DTD equivalents for Relax NG 
cardinality constraints, 223 
defining alternatives, 
218-219 
empty elements, 223 
enumerations, 227 
interleaving, 222 
named patterns, 230 
recursive structures, 231 
DTD equivalents for XML 
Schema 
attributes, 159 
cardinality constraints, 150 
el ement clause, 142 
empty elements, 158, 159 
mixed content, 151 
model groups, 147, 148 
recursive structures, 162 
duration constraint 
Schematron for, 354-355 
XSLT for, 344-346 
duration primitive data type 
(XML Schema) 
OO languages and, 375-376 
overview, 123 
SQL types and, 423 
XML Schema declaration 
for, 138-139 
dynamic marshaling, 389-390 
E 
Egyptian hieroglyphs, 7 
el ement clause (XML Schema) 
default values in, 150 
DTD equivalent, 142 
fixed values in, 150 
local type definition with, 
142 
name attribute, 141 
overview, 141-143 
type attribute, 141 
element content whitespace 
property of characters 
(XML), 98 
Element Declarations 
Consistent constraint 
(XML Schema), 178 

Index 
515 
el ement FormDefaul t 
specification (XML 
Schema), 180-182 
elements (Relax NG) 
defining alternatives, 
217-219 
empty, 223-224 
generic (wildcards), 243-246 
interleaving, 219-222 
overview, 216-217 
elements (XML) 
canonical form, 104 
definition in DTDs, 107-108 
example, 100 
information item (XML 
Information Set), 92, 
95-96, 100 
NOTATION attribute type as 
extension mechanism, 
111-112 
properties, 95-96 
elements (XML Schema) 
adding an attribute to a 
simple type element, 
455-456 
complex type, 119 
defining, 141-143 
document instances 
overriding types, 186-188 
empty, 156-158 
global, 161-162, 386-387 
hierarchy of definitions, 139 
inserting at an arbitrary 
position, 459-461 
mapping global and local 
elements onto OO 
structures, 386-387 
nested definitions for, 118, 
119 
nillable, 169-170 
protecting from substitution 
groups, 189-190 
qualified names for, 180-182 
substitution groups for, 
188-189 
translating hierarchies into 
Java, 377-381 
translating hierarchies into 
relational schema, 424-426 
embedded XQuery fragments, 
480-486 
<empty>/clause (Relax NG), 
223-224 
empty elements 
Relax NG, 223-224 
XML Schema, 156-158 
empty patterns (Relax NG), 236 
empty sequence notation, 36 
empty set (Relax NG), 224 
EMPTY terminal symbol in 
DTDs, 108 
encapsulation of objects, 
367-368 
Enhydra's Zeus, 367 
enterprise data models, 471. See 
also large environments 
enterprise software 
development, conceptual 
modeling and, 42, 47 
entities 
as AOM assets, 48-50 
parameter entities in DTDs, 
113-114 
unexpanded entity reference 
(XML), 93, 97 
unparsed (XML), 93, 95, 
98-99 
user-defined (XML), 112 
ENT I T I ES built-in constructed 
data type (XML Schema), 
133 
ENT I T I ES primitive attribute 
type (XML), 110 
ENT I TY built-in constructed 
data type (XML Schema), 
133 
ENT I TY primitive attribute type 
(XML) 
overview, 110 
for user-defined entities, 112 
Entity Relationship Diagrams 
purchase order example, 
44-46 
relational databases and, 43 
Entity Relationship Modeling. 
See ERM (Entity 
Relationship Modeling) 
enumerat i on constraining facet 
(XML Schema), described, 
130 
enumerations in Relax NG, 
226-227 
environments. See large 
environments; object- 
oriented environments; 
relational environments 
equal fundamental facet 
(XML Schema), 121 
equivalent document schema 
definitions, 14 
ERM (Entity Relationship 
Modeling) 
AOM vs., 48-50 
development of, 44 
dialects, 46 
purchase order example, 
44-46 
Escalator Over the Hill, 10 
escape sequences for 
metacharacters, 496 
evolution of schemata. See 
schema evolution 
<except> clause (Relax NG), 
combining name classes 
with, 244-246 
except operator (SQL), 417 
Experanto, 444 
expressiveness of AOM, 68 
EXSLT, 344 
extension by list method for 
constructed data types 
(XML Schema) 
mapping to OO types and, 
376 
overview, 127-128 
extension by union method. 
See union data types (XML 
Schema) 
F 
facets. See constraining facets 
(XML Schema); fundamen- 
tal facets (XML Schema) 
Fallside, David C., 117 
families of schemata. See 
schema families (XML 
Schema) 
fie l d element (XML Schema), 
171, 172 
final attribute (XML Schema), 
189-190, 446, 453 
Finkelstein, Clive, 46 

$16 
Index 
First Normal Form (1NF). 
See normalization of 
relational data structures 
#FIXED primitive attribute type 
(XML), 111 
fixed values 
cautions regarding (XML 
Schema), 464-465 
Relax NG, 225-226 
XML Schema, 150 
float primitive data type (XML 
Schema) 
mapping onto OO types, 375 
overview, 122 
SQL REAL type and, 422-423 
footnotes, 12 
foreign key integrity 
constraint (SQL), 418 
foreign keys 
defining in SQL, 418 
OO languages and, 393-394 
of relational databases, 397 
XML Schema, 173-176 
Forest-Regular Grammars. See 
HRGs (Hedge-Regular 
Grammars) 
formalization, conceptual 
modeling principle of, 44 
fract i onDi gi ts constraining 
facet (XML Schema) 
described, 131 
implementing in OO 
languages, 390 
Free Jazz style, XML document 
for, 253 
from clause (SQL), 416, 418 
fundamental facets (XML 
Schema) 
defined, 120 
list of, 121 
fxp parser, regular types and, 34 
G 
gDay primitive data type (XML 
Schema), 125 
general assertions (SQL), 431 
generative rules for formal 
grammars 
BNF, 29 
currency amount generation 
example, 27 
defined, 27 
generators 
automatic code, OO 
environments and, 
392-393 
for document instances 
(Relax NG), 248 
generic elements and attributes 
(Relax NG). See name 
classes (Relax NG) 
generic types 
overview, 39 
xs: anyType (XML Schema), 
142, 157-158, 201 
global attributes (XML 
Schema), 161-162 
global elements (XML Schema) 
global types vs., 184-185 
global types with, 185 
mapping onto OO structures, 
386-387 
overview, 161-162 
recursive structures using, 
162-165, 185 
substitution and, 185 
global types (XML Schema) 
global elements vs., 184-185 
global elements with, 185 
mapping onto OO structures, 
387-388 
overview, 160-161 
recursive structures and, 185 
substitution and, 185 
gMonth primitive data type 
(XML Schema), 125 
gMonthDay primitive data type 
(XML Schema), 125 
government environments. See 
large environments 
grammars 
alphabet for, 27 
Backus-Naur-Form (BNF), 
29-30 
context-free, 28 
cross-reference constraints 
and, 29-30 
example for generating 
currency amounts, 27-28 
generative rules for, 27 
grammar-driven data models, 
492 
history of grammatical 
analysis, 26 
HRGs (Hedge-Regular 
Grammars), 31-34 
mathematical definition, 27 
non-terminal symbols for, 27 
parser construction from, 28 
as production systems, 27 
regular expressions and, 
30-31 
start symbol for, 27 
tree-regular, 33 
grammars (Relax NG) 
al bum_type, 297 
anyXhtml, 298-299 
bel ongsTo_type, 297-298 
cri t i c_type, 295-296 
descri pti on_type, 298 
empty patterns and, 236 
generating Java source code 
from, 248 
i nfluence_type, 299 
j amSess i on_type, 299-300 
jazzMusi ci an_type, 294-295 
magazi ne_type, 300 
merging external grammars, 
233 
named patterns and, 
229-233 
nested, 231-233 
overriding named patterns, 
234 
person_type, 292-294 
pl ays_type, 300-301 
produces_type, 301 
project_type, 301-302 
purchase order example, 
20-23 
recursive structures using, 
231 
sampl e_type, 302-303 
styl e_type, 303 
track_type, 303-304 
Greek script, 7 
group by clause (SQL), 417 
<group> clause (Relax NG), 
217-218 
groups (XML Schema) 
overview, 185-186 
redefining, 193 
gYear primitive data type 
(XML Schema), 125 
gYearMonth primitive data type 
(XML Schema), 124 

Index 
$111 
H 
hard-coded constraints, 323, 
341-344 
has, conceptual model in AOM 
and, 73 
Haskell, regular types exploited 
by, 34-35 
HaXml libraries, regular types 
and, 34 
head element (XML Schema) 
defining as global and 
abstract, 200, 202 
specifying using substitution 
groups, 188-189 
Hedge-Regular Grammars. See 
HRGs (Hedge-Regular 
Grammars) 
help texts, nonlinear access of, 
12 
HERM (Higher Order Entity Re- 
lationship Modeling), 50 
hexBi nary primitive data type 
(XML Schema) 
OO languages and, 374 
overview, 126 
SQL binary types and, 422 
hierarchy 
of built-in data types (XML 
Schema), 136 
of classes (OO languages), 
369 
mapping XML Schema 
elements onto OO 
constructs, 377-381 
mapping XML Schema types 
to OO types and, 377 
overview, 9-10 
translating XML Schema 
elements into relational 
schema, 424-426 
of types based on behavior 
(OO languages), 369-370 
of types based on syntax 
(OO languages), 370 
of types (XML Schema), 
38-39, 156 
of XML Schema element 
definitions, 139 
hieroglyphs, 7 
Higher Order Entity 
Relationship Modeling 
(HERM), 50 
HRGs (Hedge-Regular 
Grammars) 
AOM and, 48 
benefits, 31-32, 33-34 
Boolean set operators and, 
34 
context-sensitive content 
models defined by, 33-34 
defined, 32-33 
DTDs as, 107 
DTDs vs., 108 
overview, 31-34 
parsers obtained from, 32 
recursion in, 33 
tree-regular grammars vs., 33 
HTML, meaning in, 324 
hunter-gatherer societies, 
documents in, 7-8 
hypertext, 13 
I 
IBM's Experanto, 444 
I D built-in constructed data 
type (XML Schema) 
backward compatibility and, 
170 
overview, 133 
I D primitive attribute type 
(XML) 
for cross-references, 111 
overview, 110 
identifying assets of L2S 
arc reversal for, 65 
constraints, 64-65, 82 
key for, 64 
IDREF built-in constructed data 
type (XML Schema) 
backward compatibility and, 
170 
overview, 133 
IDREF primitive attribute type 
(XML) 
for cross-references, 111 
overview, 110 
IDREFS built-in constructed 
data type (XML Schema), 
133 
IDREFS primitive attribute type 
(XML), 110 
implementation 
conceptual model 
independence from, 42-43 
navigation and, 320-321 
object-oriented XML data 
model implementations, 
366-367 
synopsis of steps for, 
318-320 
See also Relax NG 
implementation for jazz 
knowledge base; XML 
Schema implementation 
for jazz knowledge base 
# IMPLI ED primitive attribute 
type (XML), 110 
import clause (XML Schema), 
194-195 
i ncl ude clause (XML Schema), 
191 
influences asset 
L2S and, 84 
overview, 76 
influence_type grammar (Relax 
NG), 299 
informal description of jazz 
knowledge base, 72 
Information Engineering, 46 
information technology. See IT 
(information technology) 
infrastructure, conceptual 
model independence 
from, 42-43 
inheritance 
clustered (AOM), 60, 61 
i s_a relationship defining 
(AOM), 60 
in jazz knowledge base 
implementation (Relax 
NG), 292-296 
in jazz knowledge base 
implementation (XML 
Schema), 262-265 
mapping XML Schema onto 
OO structures, 388-389 
multiple (AOM), 60, 61 
of types (XML Schema), 
262-265 
in-scope namespaces property 
of elements (XML), 96 
insert command (SQL), 418, 
419 
Inside Out album 
review, XML document for, 
257 
XML document for, 254-257 

$18 
Index 
instances of documents. See 
document instances 
instrumental i st asset 
i s_a relationship resolution, 
80-81 
overview, 75 
i nt built-in constructed data 
type (XML Schema) 
mapping onto OO types, 
374-375 
overview, 134 
SQL INTEGER type and, 422 
i nteger built-in constructed 
data type (XML Schema) 
mapping onto OO types, 
374-375 
overview, 134 
integrating core technologies, 
492 
integrity constraints. See 
referential integrity 
constraints 
intelligibleness, conceptual 
modeling principle of, 44 
<interleave> clause (Relax NG) 
merging attribute groups, 
235-236 
overview, 219-222 
interleaving operation, 
derivation of, 37 
intersect operator (SQL), 417 
intersection operation 
in relational algebra, 398 
in SQL queries, 417 
into clause (SQL), 418 
invariance, conceptual 
modeling principle of, 44 
invoice master schema 
defining using abstract types 
(XML Schema), 204-209 
defining using dangling type 
definitions (XML Schema), 
209-213 
defining using substitution 
groups (XML Schema), 
200-204 
Relax NG example, 238-240 
i s_a relationship (AOM) 
inheritance defined by, 60 
modeling from informal 
description, 73 
resolving in jazz knowledge 
base, 80-81 
IT (information technology) 
conceptual modeling and, 43 
document metaphor's 
importance for, 4-6 
iterative development, 
conceptual modeling and, 
47 
I 
Jakarta project of Apache, 341 
j amSes s i on asset 
as business object, 260 
i s_a relationship resolution, 
80, 81 
overview, 76 
PNF and, 78, 79 
j amSess i on_type grammar 
(Relax NG), 299-300 
Jarrett, Keith 
in Keith Jarrett Trio, 253-254 
K61n Concert XML document, 
256-257 
XML document for, 250 
Java 
hard-coded constraint checks 
using, 341-344 
integer data types, 375 
package for jazzMusici an 
asset, 391-392 
regex class, 390-391 
source code generation from 
Relax NG grammars, 248 
Unicode support by, 374 
visibility, 394 
Java conversions from XML 
Schema 
applying XSLT stylesheets in 
XML/Java binding 
environment, 393 
approximate numeric types, 
375 
binary data, 374 
boolean data type, 374 
choice groups, 384-385 
complex elements, 379-380 
date and time data types, 
375-376 
date formats into Java 
objects, 343 
exact numeric types, 374-375 
global types, 387-388 
inheritance, 388-389 
leaf elements, 378-379 
null values, 376-377 
pattern constraining facet, 
390-391 
recursion, 385-386 
repeating elements, 380-381 
repeating sequences, 383-384 
sequence information, 
381-383 
JAXB, 367 
Jaxen XPath processor, 341 
JaxMe, 367 
jazz knowledge base example 
albums, 254-256 
assets in, 74-76 
collaborations, 253-254 
combining model with 
bookshop model, 472-475 
conceptual model, Draft 1, 
73, 75 
conceptual model, Draft 2, 
78-79 
conceptual model, Draft 3, 
81, 82 
conceptual model, Draft 4, 
82, 83 
conceptual model, Draft 5, 
84-85 
conceptual model, final draft, 
84, 86, 259 
conceptual model, with 
added constraints, 339 
critics, 257 
cross-references, 13 
hierarchical order in albums, 
10 
implementation in Relax NG, 
291-318 
implementation in XML 
Schema, 258-290 
informal description, 72 
L2S for business objects, 
81-86 
modeling aggregated items as 
assets or properties, 73-76 
modeling nouns and verbs as 
assets, 73 
musicians, 250-253 
nonlinear order for 
performance information, 
11-12 
normalization, requirements 
for, 76-77 

Index 
519 
Partitioned Normal Form 
(PNF), 78-79 
resolving i s_a relationships, 
80-81 
reviews, 257 
sequential order in 
albums, 9 
styles, 253 
See also Relax NG 
implementation for jazz 
.knowledge base; XML 
Schema implementation 
for jazz knowledge base; 
specific assets and business 
objects 
jazzC0mposer asset 
i s a relationship resolution, 
m 
80-81 
overview, 75 
dazzEncycl opedi a_Typeki b type 
library, creating, 260-261 
jazzMusi ci an asset 
as business object, 260 
i s a relationship resolution, 
D 
80, 81 
Java package for, 391-392 
L2S and, 81, 84 
overview, 75 
XML documents for 
musicians, 250-253 
XML Schema declaration for, 
138-139 
jazzMusi ci an business object 
Relax NG, 304-308 
XML Schema, 271-277 
jazzMusi ci anLi st schema file, 
451-452, 454 
jazzMusi ci an_type complex 
type (XML Schema) 
cri ti c_type derived from, 
264-265 
derivation from person_type, 
262-264 
jazzMusi ci an_type grammar 
(Relax NG), 294-295 
j azzMusi ci anWi thContract 
schema file, 452-453, 454 
j azzMus i c i anWi thContract Li s t 
schema file, 453, 454 
jazzSinger asset 
i s_a relationship resolution, 
80-81 
overview, 75 
join operations in relational 
algebra, 400-401 
K 
Keith Jarrett Trio 
Inside Out XML document, 
254-257 
XML document for, 254-255 
key clause 
Schematron, 353 
XML Schema, 172-173 
keys and key references (Relax 
NG), 240-241 
keys of assets (AOM) 
atomic child nodes as, 78 
defined, 51 
for identifying assets of L2S, 
64 
minimal, 77 
normalization and, 77 
outgoing arcs in relational 
environments and, 77 
PNF and, 78 
specification for arcs, 52 
types of, 51 
keys (RDBMS), 397 
keys (XML Schema) 
foreign, 173-176 
OO languages and, 393-394 
primary, 172-173 
KLEEN AOM modeling tool, 
258 
"Kleene" star. See powerset 
operation 
Kleene, Stephen Cole, 30 
knowledge base, jazz. See jazz 
knowledge base example 
K6ln Concert album, XML 
document for, 256-257 
Kroenke, David, 46 
L 
L2S (Level 2 Structures), 62-66 
business documents 
represented by, 63 
business objects represented 
by, 63 
constraints on identifying 
assets, 64-65, 82 
identifying assets, 64-65 
for jazz knowledge base, 
81-86 
modularization and, 63 
purposes, 63 
shop examples, 64, 65-66 
labels of AOM assets 
names vs., 52 
overview, 50-51 
as terminal symbols, 52 
language built-in constructed 
data type (XML Schema), 
132 
large environments, 471-489 
centralized and decentralized 
change management, 
487-489 
combining diverse schemata, 
472-487 
combining document 
instance sets, 475-479 
embedded queries, 480-486 
mediation techniques in, 471 
model fusion, 472-475 
model-driven schema 
mediation, 486-487 
schema-driven view 
definition, 479-480 
left outer join operation in 
relational algebra, 401 
length constraining facet (XML 
Schema), 129 
letter categories for pattern 
constraining facet (XML 
Schema), 496 
Level 2 Structures. See L2S 
(Level 2 Structures) 
lexical representations (XML 
Schema) 
of built-in primitive data 
types, 122-126 
defined, 120 
lexical space (XML Schema) 
constraining facets and, 121 
defined, 120 
line breaks, XML canonical 
form for, 101 
linear concepts, 8-10. See also 
hierarchy; sequence 
lists (Relax NG), 227-228 
Literary Machines, 13 
local elements (XML Schema), 
mapping onto OO 
structures, 386-387 

520 
Index 
local name property (XML) 
of attributes, 96 
of elements, 95 
local types 
for AOM properties, 54-55 
in XML Schema, 160-161 
1 ong built-in constructed data 
type (XML Schema) 
mapping onto OO types, 
374-375 
overview, 134 
SQL B I G I NT type and, 422 
M 
magazine asset 
L2S and, 81 
overview, 76 
magazi ne_type grammar 
(Relax NG), 300 
Makoto, Murata, 215 
margins, nonlinear reading 
and, 12 
Marjomaa, Esko, 44 
marks categories for pattern 
constraining facet (XML 
Schema), 497 
marshaling, dynamic, 389-390 
Martin, James, 46 
master schema. See abstract 
master schema (XML 
Schema) 
maxExc 1 us i ve constraining facet 
(XML Schema) 
described, 130 
implementing in OO 
languages, 390 
maxlncl usi ve constraining facet 
(XML Schema), 130 
maxLength constraining facet 
(XML Schema), 129 
maxOccurs cardinality 
constraint (XML Schema), 
149-150 
meaning 
unique, as asset type 
requirement, 77 
XML and, 324 
mediation 
combining document 
instance sets, 475-479 
model-driven schema 
mediation, 486-487 
techniques in large 
environments, 471 
between XML databases and 
RDBMS, 433-444 
merging 
AOM assets, 68 
AOM models, 68 
attribute groups (Relax NG), 
235-236 
external grammars (Relax 
NG), 233 
messages in OO languages, 368 
metacharacters 
defined, 495 
escape sequences for, 496 
metamodels 
Schematron, 350 
XML Information Set, 94 
XML Schema, 140 
method calls 
constraints and, 390-393 
overview, 368 
mi nExcl us i ve constraining facet 
(XML Schema), 130 
minimal asset types, defined, 
77 
minimal keys of assets, defined, 
77 
mi nlncl usi ve constraining facet 
(XML Schema) 
described, 130 
implementing in OO 
languages, 390 
mi nLength constraining facet 
(XML Schema), 129 
mi n0ccurs cardinality 
constraint (XML Schema), 
149-150 
mixed content definitions in 
XML Schema, 150-152 
ML, regular types exploited by, 
34-35 
model fusion, 472--475 
model groups in DTDs, 109 
model groups (Relax NG) 
cardinality constraints, 
222-223 
defining alternatives, 217-219 
interleaving, 219-222 
model groups (XML Schema) 
cardinality constraints from 
particles, 139 
complex types and, 139 
DTD equivalents, 147, 148 
nested connectors, 147-148 
overview, 143-148 
xs 9 al 1 connector for 
constructing, 144-146 
xs: choi ce connector for 
constructing, 146-147 
XS : sequence connector for 
constructing, 143-144 
model-driven schema 
mediation, 486-487 
models (AOM) 
components, 66 
global definitions in, 66-67 
merging, 68 
modularization 
AOM for, 69-70 
L2S and, 63 
multi-namespace schemata 
(XML Schema) 
abstract master schema based 
on, 209-213 
import clause for, 194-195 
multiple display labels, 
resolving in Relax NG, 
311-313 
multiple inheritance (AOM), 
60, 61 
N 
name attribute (XML Schema) 
of e 1 emen t clause, 141 
of key clause, 172-173 
of keyref clause, 173 
of unique clause, 171 
Name built-in constructed data 
type (XML Schema), 132 
name classes (Relax NG) 
combining, 244-246 
generic, 243-244 
overview, 243 
scoped names, 244 
name property (XML) 
of unexpanded entity 
reference, 97 
of unparsed entity, 99 
named patterns (Relax NG) 
nesting grammars, 231-233 
overview, 229-231 
recursive structures using, 
231 
redefining, 234 

Index 
.$21 
names 
of AOM arc roles, 52 
of AOM assets, 51, 52 
of AOM models, 66 
qualified and unqualified 
(XML Schema), 180-182 
of Relax NG elements, 216 
namespace attributes property 
of elements (XML), 95-96 
namespace name property 
(XML) 
of attributes, 96 
of elements, 95 
of namespace, 99 
namespaces (AOM) 
default, 68 
for models, 66 
purpose, 68 
.vocabulary namespaces for 
models, 67 
namespaces (Relax NG), 
241-243 
attributes and, 241 
chameleon components, 
242-243 
combining name classes and, 
244 
ns attribute for, 241 
prefixes, 242 
scoped names and, 244 
namespaces (XML) 
declaring, 90 
example, 101 
importance of, 90 
information item (XML 
Information Set), 92, 99, 
101 
not supported by DTDs, 115 
properties of elements, 
95-96 
properties of information 
item, 99 
qualified elements and, 
90-91 
removal of redundant nodes 
in canonical form, 103 
namespaces (XML Schema), 
180-184 
as connection between 
document instances and 
schemata, 180, 181 
default schema namespace, 
183-184 
multi-namespace schemata, 
194-195, 209-213 
qualified and unqualified 
names, 180-182 
targetNamespace declaration, 
180 
wildcards, 182-183 
See also target namespace 
(XML Schema) 
navigation, business object 
implementation and, 
320-321 
NCName built-in constructed data 
type (XML Schema), 133 
negati veInteger built-in 
constructed data type 
(XML Schema), 134 
Nelson, Ted, 13 
nesting 
appending child nodes to 
nested structures (XML 
Schema), 457-458 
connectors (XML Schema), 
147-148 
element definitions (XML 
Schema), 118, 119 
grammars (Relax NG), 
231-233 
particles (XML Schema), 145 
newspapers, nonlinear order 
in, 11 
NIAM (Nijssen's Information 
Analysis Methodology), 46 
nillable elements (XML 
Schema) 
elements declared as keys 
and, 172 
overview, 169-170 
NMTOKEN built-in constructed 
data type (XML Schema), 
132 
NMTOKEN primitive attribute type 
(XML), 110 
NMTOKENS built-in constructed 
data type (XML Schema), 
132 
NMTOKENS primitive attribute 
type (XML), 110 
nondeterminism, choice and, 
465 
nondeterministic content 
models, deterministic vs., 
40, 176-178 
nonlinear concepts, 11-13. See 
also annotations; bags; 
cross-references 
nonNegati velnteger built-in 
constructed data type 
(XML Schema), 135 
n0nP0si ti veInteger built-in 
constructed data type 
(XML Schema), 134 
non-terminal symbols 
AOM asset names as, 52 
BNF notation for, 29 
DTDs vs. regular grammars 
and, 108 
DTDs vs. XML Schema or 
Relax NG and, 34 
in formal grammars, 27 
for grammar generating 
currency amounts, 27 
for HRGS, 32 
model groups vs., 109 
start symbol, 27 
See also start symbol 
normalization 
of attribute values (XML), 
102 
of comments (XML), 105 
Partitioned Normal Form 
(PNF), 78-79 
of relational data structures, 
401-415 
requirements in AOM, 76-77 
normalization of relational data 
structures, 401-415 
converting table to 1NF 
(flattening), 405-406 
defining the target format, 
402-403 
Integrity Rules for cardinality 
constraints, 410 
introducing key 
relationships, 406-410 
keys, 406-407 
overview, 401-402 
preserving sequential order, 
410-414 
recomposing original 
document nodes, 414-415 
repeating elements, 410 
schema to be normalized, 
403-405 
normalized value property of 
attributes (XML), 96 

522 
Index 
norma I i zedStri ng built-in 
constructed data type 
(XML Schema) 
overview, 131 
SQL and, 421 
n0tA1 lowed clause (Relax NG), 
224, 236 
notation 
BNF, 29 
information item (XML 
Information Set), 92, 99 
regular set algebra, 30-31 
for regular types, 35-37 
for XML Schema syntactical 
constructs, 119 
notation element (XML 
Schema), 195 
NOTATION primitive attribute 
type (XML) 
as extension mechanism for 
elements, 111-112 
overview, 110 
NOTATION primitive data type 
(XML Schema), 126 
notation property (XML) 
of document node, 93 
of processing instructions, 97 
of unparsed entity, 99 
nouns, modeling as assets, 73 
ns attribute (Relax NG), 241 
nsName class (Relax NG), 244 
null values 
in OO languages, 376-377 
in SQL, 424 
nullability of elements (XML 
Schema), 169-170, 172 
numbers categories for pattern 
constraining facet (XML 
Schema), 497 
numeri c fundamental facet 
(XML Schema), 121 
O 
OASIS Web sites, 215, 248 
Object Constraint Language 
(OCL), 337 
object identifiers (SQL-99), 
420-421 
Object Role Modeling (ORM), 
46 
object-oriented data types 
hierarchies based on 
behavior, 369-370 
hierarchies based on syntax, 
370 
mapping XML Schema 
simple types onto, 
373-377 
primitive types, 373-377 
substitutability of 
(polymorphism), 369-370 
XML types vs., 370-373 
object-oriented environments 
automatic code generation 
and, 392-393 
behavior of objects, 368 
binding between XML and 
OO structures, 367 
constraints, 390-393 
decentralized change 
management in, 488 
document-centric 
environments vs., 368 
dynamic marshaling, 
389-390 
encapsulation of objects, 
367-368 
ERM dialects for, 46 
inheritance, 388-389 
keys and, 393-394 
mapping complex types from 
XML Schema, 377-387 
mapping global types from 
XML Schema, 387-388 
mapping simple types from 
XML Schema, 373-377 
messages, 368 
method calls, 368 
object identity, 393-394 
polymorphism, 369-370, 389 
SQL-99 and, 419-421 
visibility, 394 
XML data model 
implementations, 366-367 
See also Java 
OCL (Object Constraint 
Language), 337 
1NF (First Normal Form). See 
normalization of relational 
data structures 
ontologies, 324 
open content model, 465-467 
operations 
of AOM assets, 51 
vocabulary for AOM 
models, 67 
See also specific kinds 
option operation, 37 
optional elements, 24 
oral documents, 8 
order by clause (SQL), 416-417 
ordered fundamental facet 
(XML Schema), 121 
ORM (Object Role Modeling), 
46 
outer join operations in 
relational algebra, 401 
owner element property of 
attributes (XML), 96 
P 
Panini, 26 
parameter entities in DTDs, 
113-114 
parent property (XML) 
of characters, 98 
of comments, 98 
of DTD information item, 98 
of elements, 96 
of processing instructions, 97 
of unexpanded entity 
reference, 97 
parentheses for empty sequence 
notation, 36 
parsers 
construction from grammars, 
28 
DTD-aware parsers and the 
XML Information Set, 91, 
93 
general parsing problem as 
undecidable, 28 
from HRGs, 32 
XML, 28 
particles (XML Schema) 
cardinality constraints with, 
139, 143, 149-150 
child element structures 
defined by, 142 
defined, 142 
nesting, 145 
Partitioned Normal Form 
(PNF), 78-79 

Index 
523 
pattern clause (Schematron), 
351-352 
pattern constraining facet 
(XML Schema) 
described, 129-130 
implementing in OO 
languages, 390-391 
regular expressions for, 
495-498 
patterns (Relax NG) 
abstract, 236-240 
advantages, 23 
customizing, 234-236 
defined, 229 
empty, 236 
named, 229-233 
peri od_type, 291-292 
redefining, 234 
referencing external patterns, 
233 
#PCDATA terminal symbol in 
DTDs, 108 
Peacock, Gary 
in Keith Jarrett Trio, 253-254 
XML document for, 251 
peri 0d asset, as type definition, 
79 
peri od_type complex type 
(XML Schema), 260, 261 
period_type pattern (Relax 
NG), 291-292 
peri 0d_type schema file, 447 
peri odWi thName_type schema 
file, 447-448 
person asset 
overview, 76 
PNF and, 78 
person element (XML Schema), 
118-119 
person_type complex type 
(XML Schema) 
jazzMusi ci an_type derived 
from, 262-264 
overview, 262, 263 
person_type grammar (Relax 
NG), 292-294 
person_type schema file, 
461-462 
person_wi 1 dcard schema file, 
465-466 
personWi thCV_type schema file, 
463-464 
phase clause (Schematron), 351 
Phoenician script, 7 
PI nodes. See processing 
instructions (XML) 
pictographs, 6 
Plato, 26 
pl ays asset 
L2S and, 84 
overview, 79 
p l ays_type grammar (Relax 
NG), 300-301 
plus sign (+) 
as AOM particle or property 
modifier, 56 
as AOM property type 
modifier, 58 
for cardinality constraints for 
arcs, 53 
for cardinality constraints in 
DTDs, 109 
PNF (Partitioned Normal 
Form), 78-79 
polymorphism 
defined, 369-370 
XML Schema and, 389 
Poseidon CASE tool, 337 
posi ti velnteger built-in 
constructed data type 
(XML Schema), 135 
powerset operation 
defined, 31 
derivation of, 37 
non-empty, 37 
notation, 31, 37 
substitution operation 
replacing, 34 
prefix property (XML) 
of attributes, 96 
of elements, 95 
of namespace, 99 
prehistoric documents, 7-8 
primary key integrity 
constraint (SQL), 418 
primary keys 
of assets (AOM), 51 
defining in SQL, 418 
OO languages and, 393-394 
of relational databases, 397 
XML Schema key clause for, 
172-173 
primitive types 
asset types (AOM), 77 
for attributes (XML), 110-111 
fundamental facets for (XML 
Schema), 120 
hierarchy of XML Schema 
built-in types, 136 
in OO languages, 373-377 
XML Schema built-in types, 
121-126 
processContents (XML 
Schema), wildcards and, 
182 
processing instructions (XML) 
canonical form, 105 
information item (XML 
Information Set), 93, 97 
properties, 97 
produces asset 
L2S and, 84 
overview, 76 
produces_type grammar (Relax 
NG), 301 
production rules 
ATTLIST rules in DTDs, 
109-110 
element declaration in DTDs 
and, 108 
for HRGs, 33 
production systems, formal 
grammars as, 27 
project asset 
as business object, 260 
is a relationship resolution, 
m 
80, 81 
overview, 76 
properties of, 77, 78 
project business object 
Relax NG, 311-313 
XML Schema, 280, 282-284 
project asset complex type 
(XML Schema), 280 
projection operation 
in relational algebra, 399 
SQL queries, 416 
project_type grammar (Relax 
NG), 301-302 
properties (AOM) 
of assets, 51 
assets vs., 73-74 
combining complex types 
with union operator, 59 
completely typed asset 
example, 59 

524 
Index 
properties (AOM) (continued) 
complex, 54-55, 59 
context expressions relating 
constraints to, 62 
default type system for, 57 
defining, 57 
explicitly defined types for, 
57-60 
items connected to single 
assets as, 74 
local types for, 54-55 
mixing types from several 
systems for, 57-58 
modeling aggregated items 
as, 73-76 
modifiers, 55-56 
overview, 53-57 
in PNF, 78 
recursive structures, 56-57 
type modifiers, 58-59 
undefined type for, 54 
value access by constraints, 
62 
property keys of assets (AOM), 
51 
public identifier property 
(XML) 
of DTD information item, 
98 
of unexpanded entity 
reference, 97 
of unparsed entity, 99 
punctuation categories for 
pattern constraining facet 
(XML Schema), 497 
purchase order examples 
Entity Relationship 
Diagrams, 44-46 
grammar using Relax NG, 
20-23 
schema using DTD, 15-17 
schema using XML Schema, 
17-20 
serialization in XML, 5 
Q 
QName primitive data type (XML 
Schema) 
mapping onto OO types, 376 
overview, 126 
SQL equivalent function, 423 
qualified elements (XML), 
90-91~ 
qualified names 
object-oriented, 376 
SQL, 423 
XML Schema, 180-182 
queries (SQL), 415-4 17 
Cartesian product in, 416 
from clause, 416 
group by clause, 417 
nested select statements, 417 
order by clause, 416-417 
projection operation in, 416 
on recursive structures (SQL- 
99), 430 
se 1 ect clause, 416 
selection operation in, 416 
set operations, 417 
typical query, 415-416 
where clause, 416 
See also SQL (Standard Query 
Language) 
queries (XQuery). See XQuery 
question mark (?) 
as AOM particle or property 
modifier, 55 
as AOM property type 
modifier, 58 
for cardinality constraints for 
arcs, 53 
for cardinality constraints in 
DTDs, 109 
R 
range of arcs (AOM), 52 
RDBMS (relational database 
management system) 
mediation between XML 
databases and, 433-444 
overview, 396-397 
representing data in XML 
format, 396 
storing XML data in, 
396-397 
See also relational 
environments; SQL 
(Standard Query Language) 
RDF (Resource Description 
Framework), 48 
recursion 
in AOM properties, 65-67 
defined, 24 
for defining generic types, 39 
in document schemata, 
24-26 
DTD example, 24-25 
in HRGs, 33 
mapping XML Schema onto 
Java, 385-386 
regular expressions combined 
with, 31 
in Relax NG, 25-26, 231 
repetition and, 24 
SQL and, 430 
substitution operation for 
expressing, 36-37 
XML Schema example, 25 
XML Schema structures using 
global complex types, 
165-168 
XML Schema structures using 
global elements, 162-165, 
185 
redefine clause (XML Schema), 
192-193 
redefining patterns (Relax NG), 
234 
redefinition (XML Schema) 
adding an attribute to a 
simple type element, 
455-456 
to allow choices, 461-464 
appending child nodes to 
nested structures, 457-458 
authoring for, 454-465 
conservative schema 
modification, 464-465 
for derived schemata, 
450-451 
inserting elements at an 
arbitrary position, 459-461 
need for, 454-455 
reasons for, 450 
redefine clause for, 192-193 
redundancy 
asset types and, 77 
removal of redundant nodes 
in XML canonical form, 
103 
refer attribute of keyref clause 
(XML Schema), 173 
references property of attributes 
(XML), 96 

Index 
525 
referential integrity constraints 
cross-document, 335 
in SQL, 418, 431 
regex class (Java), 390-391 
regular expressions 
algebra for, 30-31, 32 
AOM and, 48 
data types as, 35 
defined, 30, 31 
deterministic, 39 
grammars and, 31 
for pattern constraining facet 
(XML Schema), 495-498 
recursion combined with, 31 
regular sets and, 30-31 
regular grammars. See HRGs 
(Hedge-Regular Grammars) 
regular sets, calculus describing, 
30-31 
regular types, 34-40 
AOM and, 48 
applied to general data types, 
34-35 
basic algebra, 37-38 
basic composition, 35-37 
benefits of, 34, 35 
deterministic, 39-40 
functional programming 
languages exploiting, 
34-35 
generic, 39 
notation for, 35-36 
subtypes, 38-39 
relational algebra, 398-401 
Cartesian product operation, 
398-399 
difference operation, 398 
general join operation, 400 
intersection operation, 398 
natural join operation, 400 
outer join operations, 401 
projection operation, 399 
selection operation, 400 
union operation, 398 
relational environments 
constraints, 430-431 
data model, 397 
databases, 396--397 
decentralized change 
management in, 488 
mapping complex types from 
XML Schema, 424-430 
mapping simple types from 
XML Schema, 421-427 
mediation between RDBMS 
and XML databases, 
433-444 
motivation for XML 
integration with, 396 
normalization, 401-415 
relational algebra, 398-401 
SQL overview, 415-421 
translating tables to XML 
Schema, 431-433 
views across multiple tables 
with XQuery, 475-479 
See also SQL (Standard Query 
Language) 
relationships 
database, 397 
ERM, AOM assets and, 48-50 
RELAX, 215 
Relax NG 
annotations, 224-225 
attributes, 216-217 
cardinality constraints, 
222-223 
chameleon components, 
242-243 
data model, 216 
data types, 226-228 
default values, 225 
DTDs vs., 23, 246, 360-361 
elements, 216-217 
embedding Schematron into, 
359-360 
empty elements, 223-224 
enumerations, 226-227 
external patterns and 
grammars, 233-240 
fixed values, 225-226 
grammars and named 
patterns, 228-233 
interleaving, 219-222 
introduction of, 15, 215 
invoice master schema 
example, 238-240 
keys and key references, 
240-241 
lists, 227-228 
model groups and particles, 
217-223 
name classes and wildcards, 
243-246 
namespaces, 241-243 
non-terminal symbols 
and, 34 
notAl lowed clause, 224, 236 
purchase order grammar 
example, 20-23 
recursion example, 25-26 
Schematron vs., 360-361 
structure, 216-226 
tool support for, 247-248 
Web site for information and 
tools, 215 
XML processing model and, 
360-361 
XML Schema vs., 23, 128, 
246-247, 360-361 
See also DTD equivalents for 
Relax NG 
Relax NG implementation for 
jazz knowledge base, 
291-318 
album business object, 
308-311 
al bum_type grammar, 297 
anyXhtml grammar, 298-299 
bel ongsTo_type grammar, 
297-298 
business object 
implementation, 304-308 
clusters, 314-316 
conceptual model for, 259 
cri t i c business object, 
316-317 
cri t i c_type grammar, 
295-296 
cross-references, 308-311 
descri pt i on_type grammar, 
298 
i nfluence_type grammar, 299 
inheritance, 292-296 
j amSess i on_type grammar, 
299-300 
jazzMusi ci an business object, 
304-308 
j azzMusi ci an_type grammar, 
294-295 
magazi ne_type grammar, 300 
multiple display levels, 
311-313 
peri0d_type pattern, 291-292 
person_type grammar, 
292-294 

$26 
Index 
Relax NG implementation 
for jazz knowledge 
base (continued) 
p I ays_type grammar, 
300-301 
producestype grammar, 301 
project business object, 
311-313 
proj ect_type grammar, 
301-302 
revi ew business object, 
314-316 
samp] e_type grammar, 
302-303 
sty] e business object, 
317-318 
sty] e_type grammar, 303 
synopsis of steps for, 318-320 
track_type grammar, 
303-304 
type library, complete code 
for, 296-304 
type library, creating, 
291-292 
RelaxNGCC, 248 
repeating elements 
overview, 24 
translating repeating 
sequences from XML 
Schema into Java, 383-384 
translating XML Schema 
elements into Java, 
380-381 
report clause (Schematron), 
352-353 
#REQU I RED primitive attribute 
type (XML), 110 
resolved references, XML 
canonical form for, 
102-103 
Resource Description 
Framework (RDF), 48 
restricted data types (XML 
Schema) 
constraining facets available, 
129-131 
mapping onto OO types, 376 
overview, 128-131 
restriction method for 
constructing, 127, 128 
SQL type parameters and, 
423-424 
restriction method for 
constructed data types 
(XML Schema), 127, 
128-131 
reuse mechanisms (XML 
Schema), 184-190 
attribute groups, 186 
chameleon schema 
components, 197-199 
global elements and global 
types, 184-185 
groups, 185-186 
instance type overriding, 
186-188 
substitution groups, 188-190 
rev i ew asset 
as business object, 260 
L2S and, 81, 84 
overview, 76 
XML document for Inside Out 
review, 257 
review business object 
Relax NG, 314-316 
XML Schema, 284-287, 288 
right outer join operation in 
relational algebra, 401 
root element (Relax NG), 216 
root element (XML Schema) 
defined, 139 
schema clause as, 190 
roundtrip engineering, 47 
rul e clause (Schematron), 352 
Rule of Solution of Equations, 
32 
Rule of Substitution, 32 
S 
sampl e_type grammar (Relax 
NG), 302-303 
schema clause (Schematron), 
349, 351 
schema clause (XML Schema) 
overview, 190 
placement of i ncl ude, 
redefine, and import 
clauses in, 191 
schema composition (XML 
Schema), 190-196 
annotation clause, 195-196 
import clause, 194-195 
i nc 1 ude clause, 191 
locating schemata, 191 
notation element, 195 
overview, 190 
redefine clause, 192-193 
schema clause, 190 
schema definition languages 
framework for, 362 
XML processing model, 
360-361 
schema evolution, 445--469 
by appending new child 
elements to existing 
elements, 446-454 
by authoring for redefinition, 
454-465 
chameleon components for, 
446, 447-450 
decentralized change 
management and, 487-488 
derived schemata for, 
450-451 
derived types for, 446-454 
by extending an existing 
schema, 454-465 
inhibiting change, 453 
by introducing new 
elements, 465-467 
open content model for, 
465-467 
schema-conservative 
techniques, 446 
substitution groups for, 446, 
451-453, 454 
types of changes for, 445 
versioning changes, 467-469 
schema families (XML Schema) 
defining using abstract types, 
204-209 
defining using dangling type 
definitions, 209-213 
defining using substitution 
groups, 200-204 
schema files (XML Schema) 
import clause for, 194-195 
i nc l ude clause for, 191 
redefine clause for, 192-193 
target namespace and, 180 
schema-driven view definition, 
479-480 
schemaLocation attribute (XML 
Schema), 191 
Schematron, 348-360 

Index 
527 
assert clause, 352-353 
cross-document constraint 
example, 355-356 
diagnostic section, 353 
di agnostics attribute, 353 
duration constraint example, 
354-355 
embedding into Relax NG, 
359-360 
embedding into XML 
Schema, 357-359 
key clause, 353 
metamodel, 350 
other schema definition 
languages vs., 360-361 
overview, 348-349 
pattern clause, 351-352 
phase clause, 351 
report clause, 352-353 
rule clause, 352 
schema clause, 349, 351 
Web site, 348 
Windows front end, 349 
XML processing model and, 
360-361 
science, document metaphor's 
importance for, 4 
scope 
of AOM assets, 51 
of AOM models, 66 
of uni que clause (XML 
Schema), 170-171 
of XML namespaces, 90 
scoped names (Relax NG), 244 
scripture, 6-7 
select clause (SQL) 
nested statements, 417 
overview, 416 
selection operation 
in relational algebra, 400 
in SQL queries, 416 
sel ector element (XML 
Schema), 171, 172 
Semantic Object Modeling 
(SOM), 46 
semantic (sequence) 
constraints, 14, 23 
"Semantic Web" activity 
(W3C), 324 
separator categories for pattern 
constraining facet (XML 
Schema), 497-498 
sequence 
defining in Relax NG, 
217-218 
DTD deficiencies, 115 
dynamic marshaling and, 
389-390 
of element children (Relax 
NG), 216 
narrative vs. topical, 8 
overview, 8-9 
translating repeating 
sequences from XML 
Schema into Java, 383-384 
translating XML Schema 
information into Java, 
381-383 
translating XML Schema into 
SQL, 426-427 
sequence connector (XML 
Schema) 
al 1 connector and, 145-146 
nesting, 147-148 
overview, 143-144 
sequence constraints, 14, 23 
set clause (SQL), 419 
set operations in relational 
algebra, 398 
SGML, XML vs., 365 
short built-in constructed data 
type (XML Schema) 
mapping onto OO types, 
374-375 
overview, 134 
SQL SMALLINT type and, 422 
sidebars, 12 
simple content (XML Schema) 
definitions, 151-152 
model, 142 
simple data types (XML 
Schema), 120-139 
adding an attribute to an 
element, 455-456 
built-in constructed types, 
131-136 
built-in primitive types, 
121-126 
changing, cautions 
regarding, 465 
constraining facets, 121, 
390-391 
constructed types, 127-128, 
131-138 
document instances 
overriding, 186-188 
extending by list, 127-128 
foreign keys, 173-176 
fundamental facets, 120-121 
hierarchy of types, 136 
lexical representations and 
canonical representations, 
120 
mapping onto OO types, 
373-377 
mapping onto SQL data 
types, 421-424 
primary keys, 172-173 
redefining, 192 
references, 173-176 
restricted types, 127, 
128-131 
union types, 127, 137-138 
uniqueness, 170-172 
user-defined types, 138-139 
value space vs. lexical space, 
120 
simpl eType declaration (XML 
Schema) 
for constructed types, 127 
example, 119 
simplicity of AOM, 70 
SOAP (XML Protocol), web 
services and, 4 
society, document metaphor's 
importance for, 4 
soft-coded constraints, 323, 
344-348 
software, increasing complexity 
of, 4 
Software AG's Tamino X-Node, 
433-443 
SOM (Semantic Object 
Modeling), 46 
specified indicator property of 
attributes (XML), 96 
speech 
hierarchical order in, 9 
sequential order in, 8 
SQL data types 
approximate numeric, 
422-423 
binary, 422 
BOOLEAN, 422 
create type command 
(SQL-99), 420 

$28 
Index 
SQL data types (continued) 
date and time, 423 
deriving tables from 
(SQL-99), 420-421 
exact numeric, 422 
extensions, 424 
restrictions, 423-424 
string, 421 
SOL (Standard Query 
Language), 415-421 
alter table command, 418 
cascading actions, 431 
choice and, 428-430 
create command, 418 
create type command 
(SQL-99), 420 
delete command, 418, 419 
deriving tables from types 
(SQL-99), 420-421 
development of, 397 
domain constraints, 430-431 
drop table command, 418 
except operator, 417 
from clause, 416, 418 
general assertions, 431 
group by clause, 417 
insert command, 418, 419 
intersect operator, 417 
into clause, 418 
nested select statements, 417 
null values, 424 
object identifiers (SQL-99), 
420-421 
order by clause, 416-417 
qualified names, 423 
queries, 415-4 17 
as RDBMS standard, 397 
recursion and, 430 
referential integrity 
constraints, 418, 431 
select clause, 416 
sequence and, 426-427 
set clause, 419 
set operations, 417 
SQL-99, 419-421 
storing URIs, 423 
table creation, 418 
table modification, 418-419 
triggers, 431 
type extensions, 424 
type restrictions, 423-424 
un i on operator, 417 
update command, 419 
views, 419 
where clause, 416 
XML Schema compatibility 
with, 397 
See also relational 
environments 
standalone property of 
document node (XML), 95 
standardization 
ontologies and, 324 
for schema definition 
languages, 362 
type libraries and (XML 
Schema), 191 
See also W3C 
star (*) 
as AOM particle or property 
modifier, 56 
as AOM property type 
modifier, 59 
for cardinality constraints for 
arcs, 53 
for cardinality constraints in 
DTDs, 109 
for powerset operation, 31, 
37 
for reversed arcs, 65 
start symbol 
in formal grammars, 27 
for grammar generating 
currency amounts, 28 
starting set for HRGs, 32 
string primitive data type 
(XML Schema) 
mapping onto OO types, 374 
overview, 122 
SQL character string types 
and, 421 
structural constraints, 14 
s tyl e asset 
as business object, 260 
Free Jazz XML document, 
253 
L2S and, 81 
overview, 74 
style business object 
Relax NG, 317-318 
XML Schema, 289-290 
styl e schema file, 448, 
449-450 
style_type grammar (Relax 
NG), 303 
styl e_type schema file, 448 
substitution groups (XML 
Schema) 
for business objects, 280-284 
context drivers and, 204 
context-specific local 
elements and, 204 
defining abstract master 
schema using, 200-204 
for elements, 188-189 
protecting elements from, 
189-190 
for schema evolution, 446, 
451-453, 454 
schema-conservative 
evolution not possible 
with, 446 
substitution operation 
global types vs. global 
elements and (XML 
Schema), 185 
notation for, 36 
powerset operation replaced 
by, 34 
recursive structures expressed 
by, 36-37, 56-57 
in regular expressions, 34 
substi tuti onGroup attribute 
(XML Schema), 188-189 
subtypes 
mapping between XML and 
OO structures and, 
370-373 
in OO languages, 369-370 
of regular types, 38-39 
Sumerian cuneiform, 6, 9, 11 
Sun Multi-Schema XML 
Validator Schematron. See 
Schematron 
Sun's JAXB, 367 
supertypes, derived schemata 
and, 450-451 
symbol categories for pattern 
constraining facet (XML 
Schema), 498 
symbols, non-terminal. See 
non-terminal symbols 
syntactical (structural) 
constraints, 14 
SYSTEM identifier of DOCTYPE 
declaration, 106 
system identifier property 
(XML) 
of DTD information item, 98 

Index 
$29 
of unexpanded entity 
reference, 97 
of unparsed entity, 99 
T 
tables (RDBMS) 
creating in SQL, 416 
creating rows with SQL, 418, 
419 
deleting rows with SQL, 418, 
419 
deriving from types (SQL-99), 
420-421 
modifying rows with SQL, 
419 
modifying with SQL, 
418-419 
nested with SQL-99, 419-420 
overview, 397 
removing with SQL, 418 
translating into XML 
Schema, 431-433 
views across multiple tables 
with XQuery, 475-479 
views with SQL, 419 
See also relational 
environments 
tagged expressions 
generic, 39 
notation, 36 
Tamino X-Node, 433-443 
target namespace (XML 
Schema) 
for chameleon schema 
components, 197-199 
connecting schemata with 
document instances, 180, 
181 
declaring, 180 
as default namespace, 183 
for imported external schema 
files, 194 
for included external schema 
files, 191 
for redefined external 
schema files, 192 
schema files and, 180 
##targetNamespace string for, 
182 
for type libraries, 197-199 
See also namespaces (XML 
Schema) 
target property of processing 
instructions (XML), 97 
targetNamespace declaration 
(XML Schema), 180 
terminal symbols 
in DTDs, 108 
labels of AOM assets as, 52 
text, XML canonical form for, 
101-102 
Thalheim, Bernhard, 50 
time primitive data type (XML 
Schema) 
OO languages and, 375-376 
overview, 123 
SQL types and, 423 
token built-in constructed data 
type (XML Schema) 
overview, 131 
SQL and, 421 
tool support for Relax NG, 
247-248 
total Di gi ts constraining facet 
(XML Schema), 130 
track asset, trackNo property, 
77 
track_type grammar (Relax 
NG), 303-304 
tree-regular grammars, 33 
TREX, 215 
triggers (SQL), 431 
tuples, 397 
type attribute of el ement clause 
(XML Schema), 141 
type hierarchies. See hierarchy 
type libraries (Relax NG) 
for jazz knowledge base, 
complete code, 296-304 
for jazz knowledge base, 
creating, 291-292 
type libraries (XML Schema) 
import clause for, 194-195 
include clause for, 191 
inheritance and, 262-265 
for jazz knowledge base, 
complete code, 265-270 
for jazz knowledge base, 
creating, 260-261 
redefine clause for, 192-193 
standardization and, 191 
target namespace for, 
197-199 
type substitution. See substitu- 
tion groups (XML Schema) 
type systems 
for AOM models, 66 
default for AOM properties, 
57 
mixing for AOM properties, 
57-58 
U 
UML (Unified Modeling 
Language), 43, 46, 337 
unexpanded entity reference 
(XML) 
information item (XML 
Information Set), 93, 97 
properties, 97 
union data types 
OO languages and, 376 
Relax NG, 228 
SQL and, 424 
XML Schema, 127, 137-138 
union operation 
combining complex types 
with, 59 
for merging in AOM, 68 
for regular expressions, 36 
for regular sets, 30 
in relational algebra, 398 
in SQL queries, 417 
XML Schema data types con- 
structed by, 127, 137-138 
un i on operator (SQL), 417 
unique clause (XML Schema), 
170-172 
unique meaning, as asset type 
requirement, 77 
Unique Particle Attribution 
as deterministic content 
model, 40 
deterministic data types and, 
176-178 
uniqueness constraints 
cross-document, 335 
in XML Schema, 327 
unparsed entities (XML) 
information item (XML 
Information Set), 93, 
98-99 
properties of information 
item, 98-99 
property of document node 
(XML), 95 

530 
Index 
unqualified names (XML 
Schema), 180, 182 
uns i gnedByte built-in 
constructed data type 
(XML Schema), 135 
unsignedlnt built-in 
constructed data type 
(XML Schema), 135 
uns i gnedLong built-in 
constructed data type 
(XML Schema), 135 
uns i gnedShort built-in 
constructed data type 
(XML Schema) 
mapping onto OO types, 
374-375 
overview, 135 
update command (SQL), 419 
usage patterns (XML Schema), 
196-213 
chameleon schema 
components and type 
libraries, 197-199 
defining abstract master 
schema using abstract 
types, 204-209 
defining abstract master 
schema using dangling 
type definitions, 209-213 
defining abstract master 
schema using substitution 
groups, 200-204 
user-defined data types (DTD), 
deficiencies for, 115 
user-defined data types (XML 
Schema) 
fundamental facets and, 120 
mapping onto OO types, 376 
overview, 138-139 
SQL type parameters and, 
423-424 
user-defined entities 
declaration in DTDs, 112 
local vs. external, 112 
UTF-8 encoding, XML 
canonical form and, 101 
V 
valid XML documents, defined, 
28 
validating cross-document 
constraints, 336-337 
validating general constraints 
hard-coded constraint checks 
for, 341-344 
Schematron for, 348-360 
XSLT for, 344-348 
validating processors 
for Relax NG, 248 
XML Schema and, 325 
value space (XML Schema) 
constraining facets and, 121 
defined, 120 
values 
default (Relax NG), 225 
default (XML Schema), 150 
fixed (Relax NG), 225-226 
fixed (XML Schema), 150 
normalization (XML), 102 
variable notation, 35 
verbs, modeling as assets, 73 
version property of document 
node (XML), 95 
versioning changes in 
schemata, 467-468 
vertical bar (I) 
in BNF notation, 29 
in regular set notation, 30 
views 
across multiple tables with 
XQuery, 475-479 
schema-driven view 
definition, 479-480 
SQL, 419 
visibility in OO languages, 394 
W 
W3C 
"Canonical XML" 
recommendation, 101 
"Semantic Web" activity, 324 
"XML Information Set" 
recommendation, 91 
XML Schema 
recommendation, 117 
XML Schema Working 
Group, 117 
"XML-Signature Syntax and 
Processing" 
recommendation, 101 
XQuery Working Draft, 444, 
475 
Web sites 
AOM, 48, 68 
Apache, 341 
Breeze XML Studio, 367 
CASE tools, 337 
Castor, 367 
EXSLT, 344 
JAXB, 367 
Jaxen, 341 
JaxMe, 367 
KLEEN AOM modeling tool, 
258 
OASIS, 215, 248 
products binding XML and 
OO structures, 367 
Relax NG information and 
tools, 215, 248 
Schematron, 348 
Software AG, 433 
W3C XML Schema 
recommendation, 117 
Windows front end for 
Schematron, 349 
Zeus, 367 
well-formed XML documents, 
defined, 28 
where clause (SQL), 416 
whitespace, XML canonical 
form, 102 
whi teSpace constraining facet 
(XML Schema), 130 
wildcards (Relax NG). See name 
classes (Relax NG) 
wildcards (XML Schema) 
declaring, 168, 182 
defined, 168 
namespaces and, 182-183 
processing methods for, 182 
using, 168-169, 182-183 
Windows front end for 
Schematron, 349 
wwwj azz_o rg_encyc I oped i a 
TYPELIB.xsd type library 
(XML Schema), 265-270 
X 
XDuce, XML data types 
supported by, 34 
XML 
bag example, 11-12 
canonical form, 101-105 
conceptual modeling and, 41 
cross-reference example, 13 

Index 
$]1 
hierarchical structure 
example, 10 
integer data types, 375 
as mainstream technology, 
493 
meaning and, 324 
mediation between databases 
and RDBMS, 433-444 
namespaces, 90-91 
OO types vs. XML types, 
370-373 
parsers, 28 
processing model, 360-361 
purchase order serialized 
in, 5 
qualified elements, 90-91 
representing RDBMS data in 
XML format, 396 
sequential order example, 9 
SGML vs., 365 
storing data in relational 
databases, 396-397 
XML Information Set, 
91-101 
See also canonical form 
(XML); XML Information 
Set 
XML DTD. See DTD (Document 
Type Definition) 
XML Information Set, 91-101 
attributes information item, 
92, 96, 100 
character information item, 
92, 97-98, 100 
comment information item, 
92, 98 
document node information 
item, 92, 93, 95, 100 
DTD information item, 92, 
98 
DTD-aware parsers and, 91, 
93 
elements information item, 
92, 95-96, 100 
example, 100-101 
metamodel of, 94 
namespace information item, 
92, 99, 101 
notation information item, 
92, 99 
OO implementations, 
366-367 
processing instructions 
information item, 93, 97 
Relax NG data model based 
on, 216 
table of information items, 
92-93 
unexpanded entity reference 
information item, 93, 97 
unparsed entity information 
item, 93, 98-99 
W3C recommendation, 91 
XML Information Set, 91-93, 
94 
XML Schema and, 93 
"XML Information Set" 
recommendation 
(W3C), 91 
XML Protocol, web services 
and, 4 
XML Schema 
annotation clause, 195-196 
attribute groups, 186 
attributes, 159-160 
basic constructs, 139 
best practice 
recommendations, 
196-213 
built-in constructed types, 
131-136 
built-in primitive types, 
121-126 
cardinality constraints, 
149-150 
chameleon schema 
components, 197-199 
complex content definitions, 
153-156 
complex types, 142-143 
constraining facets, 121 
constraints, 157, 327-330 
constructed types, 127-128, 
131-138 
default values for attributes, 
150 
defining schema families, 
200-213 
deterministic types, 176-178 
DTD vs., 19, 106, 118-119, 
170, 360-361 
element clause, 141-143 
element definition types, 139 
embedding Schematron into, 
357-359 
empty elements, 156-158 
explicit type definition 
constructor, 34 
extending simple types by 
list, 127-128 
field element, 171, 172 
fixed values for attributes, 
150 
fundamental facets, 120-121 
global attributes, 161-162 
global elements, 161-165, 
184-185 
global types, 160-161, 
184-185 
grammar-driven data models 
and, 492 
groups, 185-186 
hierarchy of built-in types, 
136 
hierarchy of data type 
definitions, 156 
hierarchy of element 
definitions, 139 
import clause, 194-195 
include clause, 191 
instance type overriding, 
186-188 
for integrating core 
technologies, 492 
introduction of, 15 
key clause, 172-173 
keyref clause, 173-176 
lexical representations and 
canonical representations, 
120 
local types, 160-161 
as mainstream technology, 
493 
meaning and, 324 
metamodel, 140 
mixed content definitions, 
150-152 
model groups, 139, 143-148 
namespaces, 180-184 
non-terminal symbols 
and, 34 
notation element, 195 
nullability, 169-170 
outlook for, 491-493 
particles, 139, 142 
person element example, 
118-119 
polymorphism and, 389 

532 
Index 
XML Schema (continued) 
purchase order document 
schema example, 17-20 
recursion example, 25 
recursive structures using 
global complex types, 
165-168 
recursive structures using 
global elements, 162-165 
redefine clause, 192-193 
Relax NG vs., 23, 128, 
246-247, 360-361 
restricted types, 127, 
128-131 
reuse mechanisms, 184-190 
root element, 139 
schema clause, 190 
schema composition, 
190-196 
Schematron vs., 360-361 
select0r element, 171, 172 
simple content definitions, 
152-153 
simple data types, 120-139 
simpleType example, 119 
SQL compatibility, 397 
substitution groups, 188-190 
targetNamespace declaration, 
180 
translation of DTDs into, 195 
union types, 127, 137-138 
unique clause, 170-172 
usage patterns, 196-213 
user-defined types, 138-139 
value space vs. lexical space, 
120 
versioning changes in 
schemata, 467-468 
W3C recommendation, 117 
wildcards, 168-169 
XML Information Set and, 93 
XML processing model and, 
360-361 
See also DTD equivalents for 
XML Schema 
XML Schema implementation 
for jazz knowledge base, 
258-290 
a] bum business object, 
277-280, 281 
band business object, 
280-282, 284 
business object 
implementation, 271-277 
business objects for, 258, 260 
clusters, 284-287 
conceptual model for, 259 
cri tic business object, 287, 
289 
cross-references, 277-280 
design options, 258 
inheritance of types, 262-265 
jazzMusi ci an business object, 
271-277 
project business object, 280, 
282-284 
revi ew business object, 
284-287, 288 
sty] e business object, 
289-290 
substitution groups, 280-284 
synopsis of steps for, 318-320 
type library, complete code 
for, 265-270 
type library, creating, 
260-261 
xml ns or xmlns: attributes, 
namespace declaration 
using, 90 
"XML-Signature Syntax and 
Processing" 
recommendation (W3C), 
101 
XPath 
advantages as a constraint 
language, 338 
constraint formulation, 323, 
338-341 
DOM and, 341 
limitations, 344 
standalone processors, 341 
XML Schema uni que clause 
and, 170-171 
XQuery and, 444 
XQuery 
Experanto for, 444 
fragments embedded in 
schemata, 480-486 
for views across multiple 
tables, 475-479 
Working Draft, 444, 475 
XSLT transformation for 
embedded fragments, 
483-486 
xs : a ] ] connector (XML 
Schema), 144-146 
xs :any wildcards (XML 
Schema) 
declaring, 168, 182 
namespaces and, 182-183 
processing methods for, 182 
xs: anyAttri bute wildcards 
(XML Schema) 
declaring, 168, 182 
namespaces and, 182-183 
processing methods for, 182 
xs :anyType built-in data type 
(XML Schema) 
for empty elements, 157-158 
as generic complex type, 142, 
201 
substitution groups and, 201 
xs: anyORI primitive data type 
(XML Schema) 
mapping onto OO types, 376 
overview, 126 
SQL equivalent function, 423 
xs: attri butefroup definition 
(XML Schema), 186 
xs: base64Bi nary primitive data 
type (XML Schema) 
OO languages and, 374 
overview, 126 
SQL binary types and, 422 
xs :boo] ean primitive data type 
(XML Schema) 
mapping onto OO types, 374 
overview, 122 
SQL BOOLEAN type and, 422 
xs: byte built-in constructed 
data type (XML Schema) 
mapping onto OO types, 
374-375 
overview, 135 
xs:choi ce connector (XML 
Schema) 
I connector in DTD and, 146 
nesting, 147-148 
overview, 146-147 
xs :date primitive data type 
(XML Schema), 124 
xs :dateTime primitive data type 
(XML Schema) 
OO languages and, 375-376 
overview, 124 
SQL types and, 423 

Index 
.$3] 
xs:decimal primitive data type 
(XML Schema) 
mapping onto O0 types, 
374-375 
overview, 122 
SQL DECIMAL type and, 422 
xs: doubl e primitive data type 
(XML Schema) 
mapping onto O0 types, 
375 
overview, 123 
SQL FLOAT type and, 422-423 
xs :durati on primitive data type 
(XML Schema) 
O0 languages and, 375-376 
overview, 123 
SQL types and, 423 
XML Schema declaration for, 
138-139 
xs:ENTITIES built-in 
constructed data type 
(XML Schema), 133 
xs: ENTITY built-in constructed 
data type (XML Schema), 
133 
xs: field element (XML 
Schema), 171, 172 
xs:float primitive data type 
(XML Schema) 
mapping onto O0 types, 
375 
overview, 122 
SQL REAL type and, 422-423 
xs :gDay primitive data type 
(XML Schema), 125 
xs :gMonth primitive data type 
(XML Schema), 125 
xs: gMonthDay primitive data 
type (XML Schema), 125 
xs: group definition (XML 
Schema), 185-186 
xs:gYear primitive data type 
(XML Schema), 125 
xs :gYearMonth primitive data 
type (XML Schema), 124 
xs:hexBinary primitive data 
type (XML Schema) 
O0 languages and, 374 
overview, 126 
SQL binary types and, 422 
xs:ID built-in constructed data 
type (XML Schema) 
backward compatibility and, 
170 
overview, 133 
xs : IDREF built-in constructed 
data type (XML Schema) 
backward compatibility and, 
170 
overview, 133 
xs: IDREFS built-in constructed 
data type (XML Schema), 
133 
xs: i nt built-in constructed 
data type (XML Schema) 
mapping onto O0 types, 
374-375 
overview, 134 
SQL INTEGER type and, 422 
xs: integer built-in 
constructed data type 
(XML Schema) 
mapping onto O0 types, 
374-375 
overview, 134 
xsi :schemaLocation attribute 
(XML Schema), 191 
xsi: type attribute (XML 
Schema), 186-188 
xs : 1 anguage built-in 
constructed data type 
(XML Schema), 132 
xs : 1 ong built-in constructed 
data type (XML Schema) 
mapping onto O0 types, 
374-375 
overview, 134 
SQL B I G I NT type and, 422 
XSLT 
applying stylesheets in 
XML/Java binding 
environment, 393 
cross-document constraints 
using, 346-348 
duration constraint using, 
344-346 
version 1.0 limitations, 344 
XQuery and, 444 
for XQuery fragments 
embedded in schemata, 
483-486 
xs :Name built-in constructed 
data type (XML Schema), 
132 
xs: NCName built-in constructed 
data type (XML Schema), 
133 
xs: negati veInteger built-in 
constructed data type 
(XML Schema), 134 
xs : NMTOKEN built-in constructed 
data type (XML Schema), 
132 
xs: NMTOKENS built-in 
constructed data type 
(XML Schema), 132 
xs: nonNegati veInteger built-in 
constructed data type 
(XML Schema), 135 
xs: nonPosi ti veInteger built-in 
constructed data type 
(XML Schema), 134 
xs :normal i zedStri ng built-in 
constructed data type 
(XML Schema) 
overview, 131 
SQL and, 421 
xs :NOTATION primitive data type 
(XML Schema), 126 
xs :posi ti veInteger built-in 
constructed data type 
(XML Schema), 135 
xs :QName primitive data type 
(XML Schema) 
mapping onto O0 types, 376 
overview, 126 
SQL equivalent function, 423 
xs : sel ector element (XML 
Schema), 171, 172 
xs: sequence connector (XML 
Schema) 
nesting, 147-148 
overview, 143-144 
xs: al 1 connector and, 
145-146 
xs: short built-in constructed 
data type (XML Schema) 
mapping onto O0 types, 
374-375 
overview, 134 
SQL SMALLINT type and, 422 
xs: string primitive data type 
(XML Schema) 
mapping onto O0 types, 374 
overview, 122 
SQL character string types 
and, 421 

$34 
Index 
xs :time primitive data type 
(XML Schema) 
O0 languages and, 375-376 
overview, 123 
SOL types and, 423 
xs: token built-in constructed 
data type (XML Schema) 
overview, 131 
SOL and, 421 
xs: unique clause (XML 
Schema), 170-172 
xs : uns i gnedByte built-in 
constructed data type 
(XML Schema), 135 
xs :unsignedInt built-in 
constructed data type 
(XML Schema), 135 
xs: unsi gnedLong built-in 
constructed data type 
(XML Schema), 135 
xs :unsi gnedShort built-in 
constructed data type 
(XML Schema) 
mapping onto O0 types, 
374-375 
overview, 135 
Z 
Zeus, 367 

About the Author 
Berthold Daum holds a Ph.D. in mathematics and was a codeveloper of 
NATURAL 4GL at Software AG. He has lectured in database design at the Uni- 
versity of Karlsruhe (Germany) and has practical experience in the design 
and implementation of large distributed online systems. In the 1980s, he 
became involved in artificial intelligence and was a member of the ISO 
standardization committee for PROLOG. He has published various articles 
in trade magazines and scientific publications, and is coauthor with Udo 
Merten of System Architecture with XML. Currently he runs a consulting 
agency for industrial communication. 
535 

This Page Intentionally Left Blank

