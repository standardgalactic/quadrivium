
 Introduction to Programming with Fortran

      

Ian Chivers • Jane Sleightholme
Introduction to Programming 
with Fortran
With Coverage of Fortran 
90, 95, 2003, 2008 and 77

Ian Chivers
Rhymney Consulting
UK
Jane Sleightholme
Fortranplus
UK
ISBN 978-0-85729-232-2
e-ISBN 978-0-85729-233-9
DOI 10.1007/978-0-85729-233-9
Springer London Dordrecht Heidelberg New York
British Library Cataloguing in Publication Data
A catalogue record for this book is available from the British Library
Library of Congress Control Number: 2011941580
© Springer-Verlag London Limited 2012
Apart from any fair dealing for the purposes of research or private study, or criticism or review, as permitted 
under the Copyright, Designs and Patents Act 1988, this publication may only be reproduced, stored or 
transmitted, in any form or by any means, with the prior permission in writing of the publishers, or in the case 
of reprographic reproduction in accordance with the terms of licenses issued by the Copyright Licensing 
Agency. Enquiries concerning reproduction outside those terms should be sent to the publishers.
The use of registered names, trademarks, etc., in this publication does not imply, even in the absence of 
a speciﬁ c statement, that such names are exempt from the relevant laws and regulations and therefore free 
for general use.
The publisher makes no representation, express or implied, with regard to the accuracy of the  information 
contained in this book and cannot accept any legal responsibility or liability for any errors or omissions 
that may be made.
Printed on acid-free paper
Springer is part of Springer Science+Business Media (www.springer.com)

v
 The material in the book has evolved ﬁ rstly from our combined experience of working 
in Computing Services within the University of London at
 King’s College, IDC (1986–2002) and JS (1985–2008) 
• 
 Chelsea College, JS (1978–1985) 
• 
 Imperial College, IDC (1978–1986) 
• 
in the teaching, advice and support of Fortran and related areas, and secondly in the 
provision of commercial training courses. The following are some of the organisa-
tions we’ve provided training for:
 AWE, Aldermaston. 
• 
 Centre for Ecology and Hydrology, Wallingford. 
• 
 DTU – Danish Technical University. 
• 
 Environment Agency, Worthing. 
• 
 JET – Joint European Torus. 
• 
 The Met Ofﬁ ce, Bracknell and Exeter. 
• 
 Natural Resources Canada, Ottowa. 
• 
 QinetiQ, Farnborough. 
• 
 Rolls Royce, Derby. 
• 
 SHMU, Slovak Hydrometeorological Institute, Bratislava, Slovakia. 
• 
 University of Ulster, Jordanstown, Northern Ireland. 
• 
 Veritas DGC Ltd., Crawley. 
• 
 Westland Helicopters, Yeovil. 
• 
 The examples in the book are based on what will work with compilers that support 
the Fortran 2008 standard. 
 Thanks are due to:
 The staff and students at King’s College, Chelsea College and Imperial College. 
• 
 The people who have attended the commercial courses. Its been great fun teaching 
• 
you and things have been very lively at times. 
 Acknowledgement 

vi
Acknowledgement
 The people on the Fortran 90 list and comp.lang.fortran. Access to the expertise 
• 
of several hundred people involved in the use and development of Fortran on a 
daily basis across a wide range of disciplines is inestimable. 
 The people at NAG for the provision of beta test versions of their Fortran 
• 
compilers. 
  The people at Intel for the provision of beta test versions of their Fortran 
• 
compilers. 
 The staff and facilities at PTR Associates. It is a pleasure training there. 
• 
 Helmut Michels at the Max-Planck-Institut for permission to use the dislin 
• 
library. 
 The patience of our families during the time required to develop the courses upon 
• 
which this book is based and whilst preparing the camera-ready copy. 
 Finally Helen Desmond and Beverley Ford at Springer for their enthusiasm and 
• 
encouragement! 
 Our Fortran home page is:
 
• http://www.fortranplus.co.uk/ 
 All of the program examples can be found there. 
 If you would like to contact us our email addresses are: 
 Ian D Chivers: ian@rhymneyconsulting.co.uk 
 Jane Sleightholme: jane@fortranplus.co.uk 

vii
 1 Overview .................................................................................................. 
1
1.1 Introduction ...................................................................................... 
1
1.2 Program Examples ........................................................................... 
5
1.3 Further Reading ............................................................................... 
5
1.3.1 The Fortran Standard ........................................................... 
5
1.3.2 J3 and WG5 Working Documents ....................................... 
5
1.3.3 Compiler Documentation ..................................................... 
5
1.3.4 Books ................................................................................... 
7
 2 Introduction to Problem Solving ........................................................... 
9
2.1 Introduction ...................................................................................... 
10
2.2 Natural Language ............................................................................. 
10
2.3 Artiﬁ cial Language .......................................................................... 
10
2.3.1 Notations .............................................................................. 
11
2.4 Resume ............................................................................................. 
11
2.5 Algorithms ....................................................................................... 
11
2.5.1 Top-Down ............................................................................ 
12
2.5.2 Bottom-Up ........................................................................... 
12
2.5.3 Stepwise Reﬁ nement ............................................................ 
13
2.6 Module Programming ...................................................................... 
13
2.7 Object Oriented Programming ......................................................... 
13
2.8 Systems Analysis and Design .......................................................... 
13
2.8.1 Problem Deﬁ nition ............................................................... 
14
2.8.2 Feasibility Study and Fact Finding ...................................... 
14
2.8.3 Analysis ................................................................................ 
14
2.8.4 Design .................................................................................. 
15
2.8.5 Detailed Design .................................................................... 
15
2.8.6 Implementation .................................................................... 
15
2.8.7 Evaluation and Testing ......................................................... 
15
2.8.8 Maintenance ......................................................................... 
16
2.9 Conclusions ...................................................................................... 
16
 Contents

viii
Contents
2.10 Problems ........................................................................................ 
16
2.11 Bibliography .................................................................................. 
17
 3 Introduction to Programming Languages ............................................ 
19
 3.1 Introduction .................................................................................... 
19
 3.2 Some Early Theoretical Work ........................................................ 
20
 3.3 What Is a Programming Language? ............................................... 
20
 3.4 Program Language Development and Engineering ....................... 
20
 3.5 The Early Days .............................................................................. 
20
 3.5.1 Fortran’s Origins .............................................................. 
20
 3.5.2 Fortran 77 ......................................................................... 
21
 3.5.3 Cobol ................................................................................ 
21
 3.5.4 Algol ................................................................................. 
22
 3.6  Chomsky and Program Language Development ............................ 
22
 3.7 Lisp ................................................................................................ 
23
 3.8 Snobol ............................................................................................ 
23
 3.9 Second-Generation Languages ...................................................... 
24
 3.9.1 PL/1 and Algol 68 ............................................................ 
24
 3.9.2 Simula .............................................................................. 
24
 3.9.3 Pascal ................................................................................ 
24
 3.9.4 APL .................................................................................. 
25
 3.9.5 Basic ................................................................................. 
25
 3.9.6 C ....................................................................................... 
25
3.10 Some Other Strands in Language Development ............................ 
26
3.10.1 Abstraction, Stepwise Reﬁ nement and Modules ............. 
26
3.10.2 Structured Programming .................................................. 
26
3.10.3 Data Structuring and Procedural Programming ............... 
26
3.10.4 Standardisation ................................................................. 
27
3.11 Ada ................................................................................................. 
27
3.12 Modula ........................................................................................... 
28
3.13 Modula 2 ........................................................................................ 
28
3.14 Other Language Developments ...................................................... 
28
3.14.1 Logo ................................................................................. 
29
3.14.2 Postscript, TeX and LaTeX .............................................. 
29
3.14.3 Prolog ............................................................................... 
29
3.14.4 SQL .................................................................................. 
29
3.14.5 ICON ................................................................................ 
30
3.15 Object Oriented Programming ....................................................... 
30
3.15.1 Simula .............................................................................. 
31
3.15.2 Smalltalk .......................................................................... 
31
3.15.3 Oberon and Oberon 2 ....................................................... 
31
3.15.4 Eiffel ................................................................................. 
32
3.15.5 C++ ................................................................................... 
32
3.15.6 Java ................................................................................... 
33
3.15.7 C# ..................................................................................... 
33

ix
Contents
3.16 Back to Fortran! ............................................................................. 
34
3.16.1 Fortran 90 ......................................................................... 
34
3.16.2 Fortran 95 ......................................................................... 
35
3.16.3 ISO Technical Reports TR15580 and TR15581 .............. 
36
3.16.4 Fortran 2003 ..................................................................... 
36
3.16.5 DTR 19767 Enhanced Module Facilities ......................... 
37
3.16.6 Fortran 2008 ..................................................................... 
37
3.16.7 The Future ........................................................................ 
37
3.17 Internet Resources .......................................................................... 
38
3.17.1 Standards Information ...................................................... 
38
3.17.2 Fortran Discussion Lists ................................................... 
38
3.17.3 Other Sources ................................................................... 
39
3.18  Summary ........................................................................................ 
39
3.19 Bibliography .................................................................................. 
39
 4 Introduction to Programming ................................................................ 
45
 4.1 Introduction .................................................................................... 
45
 4.2 Language Strengths and Weaknesses ............................................. 
46
 4.3 Elements of a Programming Language .......................................... 
46
 4.3.1 Data Description Statements ............................................ 
47
 4.3.2 Control Structures ............................................................ 
47
 4.3.3 Data-Processing Statements ............................................. 
47
 4.3.4 Input and Output (I/O) Statements ................................... 
47
 4.4 Variables—Name, Type and Value ................................................ 
49
 4.5 Notes .............................................................................................. 
51
 4.6 Some More Fortran Rules .............................................................. 
52
 4.7 Fortran Character Set ..................................................................... 
52
 4.8 Good Programming Guidelines ..................................................... 
54
 4.9 Compilers ....................................................................................... 
54
4.10 Program Development ................................................................... 
55
4.11 Problems ........................................................................................ 
56
 5 Arithmetic ................................................................................................ 
57
 5.1 An Introduction to Arithmetic in Fortran ....................................... 
58
 5.2 Example 1: Simple Arithmetic Expressions in Fortran ................. 
58
 5.3 Rounding and Truncation ............................................................... 
61
 5.3.1 Example 2: Type Conversion and Assignment ................ 
61
 5.3.2 Example 3: Integer Division and Real Assignment ......... 
62
 5.4 Example 4: Time Taken for Light to Travel 
from the Sun to Earth ..................................................................... 
63
 5.5 The parameter Attribute ........................................................... 
64
 5.6 Range, Precision and Size of Numbers .......................................... 
65
 5.7 Health Warning: Optional Reading, Beginners are Advised 
to Leave Until Later ....................................................................... 
67
 5.7.1 Example 5: Default Kinds ................................................ 
67
 5.7.2 Selecting Different Integer Kind Types ............................ 
68

x
Contents
 5.7.3 Selecting Different Real Kind Types................................ 
69
 5.7.4 Specifying Kind Types for Literal Integer 
and Real Constants ........................................................... 
69
 5.7.5 Positional Number Systems ............................................. 
70
 5.7.6 Bit Data Type and Representation Model ........................ 
70
 5.7.7 Integer Data Type and Representation Model .................. 
71
 5.7.8 Real Data Type and Representation Model ...................... 
71
 5.7.9 IEEE 754 .......................................................................... 
72
5.7.10 Testing the Numerical Representation of Different 
Kind Types on a System ................................................... 
72
5.7.11 Example 6: Using the Numeric Enquiry Functions ......... 
72
5.7.12 Example 7: Binary Representation of Different Integer 
Kind Type Numbers ......................................................... 
77
5.7.13 Example 8: Binary Representation of a Real Number ..... 
79
5.7.14 Summary of How to Select the Appropriate Kind Type ...  
80
 5.8 
Variable Status............................ ................................................... 
80
 5.9 
Summary.................................... .................................................... 
80
5.10 
Problems................................... ..................................................... 
81
5.11 
Bibliography................................................................................... 
83
 6 Arrays 1: Some Fundamentals .............................................................. 
85
 6.1 
Tables of Data ................................................................................ 
86
 6.1.1 Telephone Directory ......................................................... 
86
 6.1.2 Book Catalogue ................................................................ 
86
 6.1.3 Examination Marks or Results ......................................... 
87
 6.1.4 Monthly Rainfall .............................................................. 
87
 6.2 
Arrays in Fortran ............................................................................ 
88
 6.2.1 The dimension Attribute .............................................. 
88
 6.2.2 An Index ........................................................................... 
88
 6.2.3 Control Structure .............................................................. 
88
 6.3 
Example 1: Monthly Rainfall ........................................................ 
89
 6.3.1 Possible Missing Data ...................................................... 
91
 6.4 
Example 2: People’s Weights and Setting the Array Size 
with a Parameter ............................................................................ 
93
 6.5 
Summary ........................................................................................ 
94
 6.6 
Problems ........................................................................................ 
95
 7 Arrays 2: Further Examples .................................................................. 
99
 7.1 
Varying the Array Size at Run Time .............................................. 100
 7.1.1 Example 1: Allocatable Arrays ........................................ 100
 7.2 
Higher-Dimension Arrays .............................................................. 101
 7.2.1 Example 2: Two Dimensional Arrays and a Map ............ 101
 7.2.2 Example 3: Sensible Tabular Output ................................ 103
 7.2.3 Example 4: Average of Three Sets of Values ................... 103
 7.2.4 Example 5: Booking Arrangements in a Theatre 
or Cinema ......................................................................... 105
 7.3 Additional Forms of the Dimension Attribute 
and do Loop Statement .................................................................. 106

xi
Contents
7.3.1 Example 6: Voltage from −20 to +20 Volts.......................... 106
7.3.2 Example 7: Longitude from −180 to +180 .......................... 107
7.3.3 Notes .................................................................................... 107
7.4 The Do Loop and Straight Repetition .............................................. 107
7.4.1 Example 8: Table of Liquid Conversion Measurements ...... 107
7.4.2 Example 9: Means and Standard Deviations ....................... 108
7.5 Summary .......................................................................................... 109
7.6 Problems .......................................................................................... 110
 8 Whole Array and Additional Array Features ...................................... 113
8.1 Terminology ..................................................................................... 113
8.1.1 Rank ..................................................................................... 114
8.1.2 Bounds ................................................................................. 114
8.1.3 Extent ................................................................................... 114
8.1.4 Size ....................................................................................... 114
8.1.5 Shape .................................................................................... 114
8.1.6 Conformable ........................................................................ 114
8.1.7 Array Element Ordering ...................................................... 114
8.2 Whole Array Manipulation .............................................................. 115
8.2.1 Assignment .......................................................................... 115
8.2.2 Expressions .......................................................................... 115
8.2.3 Example 1: One Dimensional Whole Arrays in Fortran ...... 116
8.2.4 Example 2: Two Dimensional Whole Arrays in Fortran ..... 117
8.3 Array Sections .................................................................................. 118
8.3.1 Example 3: Rank 1 Array Sections ...................................... 118
8.3.2 Example 4: Rank 2 Array Sections ...................................... 118
8.4 Array Constructors ........................................................................... 120
8.4.1 
Example 5: Rank 1 Array Initialisation – Explicit Values ..... 120
8.4.2 Example 6: Rank 1 Array Initialisation Using 
an Implied do Loop .............................................................. 121
8.4.3 Example 7: Rank 1 Arrays and the dot_product Intrinsic .... 121
8.5 Initialising Rank 2 Arrays ................................................................ 122
8.5.1 Example 8: Initialising a Two Dimensional Array .............. 122
8.6 Miscellaneous Array Examples ....................................................... 123
8.6.1 Example 9: Rank 1 Arrays and a Step Size 
of 2 in Implied Do Loop ...................................................... 123
8.6.2 Example 10: Rank 1 Array and the sum 
Intrinsic Function ................................................................. 124
8.6.3 Example 11: Rank 2 Arrays and the sum 
Intrinsic Function ................................................................. 125
8.6.4 Example 12: Masked Array Assignment 
and the Where Statement ..................................................... 126
8.6.5 Notes .................................................................................... 127
8.7 The forall Statement and forall Construct ............................ 128
8.7.1 Syntax .................................................................................. 128
8.7.2 Array Element Ordering and Physical 
and Virtual Memory ............................................................. 128

xii
Contents
 8.8 
Summary ........................................................................................ 129
 8.9 
Problems ........................................................................................ 129
8.10 
Bibliography .................................................................................. 130
 9 Output of Results .................................................................................... 131
 9.1 
Introduction .................................................................................... 131
 9.2 
Example 1: Integers – I Format or Edit Descriptor ....................... 132
 9.3 
Example 2: The x Edit Descriptor ................................................. 133
 9.4 
Reals – F Format or Edit Descriptor .............................................. 134
 9.4.1 Example 3: Metric and Imperial Conversion 
and the f Edit Descriptor .................................................. 135
 9.4.2 Example 4: Overﬂ ow and Underﬂ ow and the f Edit 
Descriptor ......................................................................... 136
 9.5 
Reals – E Format or Edit Descriptor .............................................. 137
 9.5.1 Example 5: Simple e Edit Descriptor Usage .................... 138
 9.6 
Spaces ............................................................................................ 138
 9.7 
Characters – A Format or Edit Descriptor ..................................... 139
 9.7.1 
Example 6: Character Output and the a Edit Descriptor ..... 139
 9.7.2 Example 7: Headings ....................................................... 140
 9.8 
Example 8: Mixed Type Output in a Format Statement ................ 140
 9.9 
Common Mistakes ......................................................................... 141
9.10 
Open (and Close) ........................................................................... 141
9.10.1 The Open Statement ......................................................... 141
9.10.2 Example 9: Open and Close Usage .................................. 142
9.10.3 Writing ............................................................................. 142
9.11 
Repetition ....................................................................................... 143
9.12 
Some More Examples .................................................................... 145
9.13 
Example 10: Implied Do Loops and Array Sections 
for Array Output ............................................................................ 146
9.13.1  Example 11: Whole Array Output .................................. 147
9.14 
Formatting for a Line Printer ......................................................... 148
9.14.1 Mechanics of Carriage Control ........................................ 149
9.14.2 Generating a New Line on Both Line Printers 
and Terminals ................................................................... 149
9.15 
Example 12: Timing of Writing Formatted Files .......................... 150
9.16 
Example 13: Timing of Writing Unformatted Files ...................... 151
9.17 
Summary ........................................................................................ 153
9.18 
Problems ........................................................................................ 153
10 Reading in Data ....................................................................................... 155
10.1 
Reading from the Terminal or Keyboard Versus Reading 
from Files ....................................................................................... 156
10.2 
Fixed Fields on Input ..................................................................... 156
10.2.1 Integers and the I Format ................................................. 156
10.2.2 Example 1: Skipping Data Whilst Reading ..................... 156
10.2.3 Reals and the F Format .................................................... 157
10.2.4 Reals and the E Format .................................................... 158

xiii
Contents
 10.3 Blanks, Nulls and Zeros ............................................................... 161
 10.4 Characters .................................................................................... 161
 10.5 Skipping Spaces and Lines .......................................................... 162
 10.6 Reading ........................................................................................ 163
 10.7 File Manipulation Again .............................................................. 164
 10.8 Reading Using Array Sections ..................................................... 164
 10.9 Timing of Reading Formatted Files ............................................. 165
10.10 Timing of Reading Unformatted Files ......................................... 167
10.11 Errors When Reading ................................................................... 168
10.12 Flexible Input Using Internal Files .............................................. 168
10.13 Summary ...................................................................................... 169
10.14 Problems ...................................................................................... 170
11 Files ........................................................................................................... 171
 11.1 Introduction .................................................................................. 171
 11.2 Data Files in Fortran .................................................................... 172
 11.3 Summary of Options on Open ..................................................... 173
 11.4 More Foolproof I/O ...................................................................... 175
 11.5 Summary ...................................................................................... 176
 11.6 Problems ...................................................................................... 177
12 Functions .................................................................................................. 179
 12.1 Introduction .................................................................................. 179
 12.2 An Introduction to Predeﬁ ned Functions and Their Use ............. 180
 12.2.1 Example 1: Simple Function Usage ............................. 180
 12.3 Generic Functions ........................................................................ 181
 12.3.1 Example 2: The abs Generic Function ....................... 181
 12.4 Elemental Functions ..................................................................... 182
 12.4.1 Example 3: Elemental Function Use ............................ 182
 12.5 Transformational Functions ......................................................... 182
 12.5.1 Example 4: Simple Transformational Use ................... 182
 12.5.2 Example 5: Intrinsic dot_product Use ................... 183
 12.6 Notes on Function Usage ............................................................. 183
 12.7 Example 6: Easter ........................................................................ 183
 12.8 Intrinsic Procedures ..................................................................... 185
 12.9 Supplying Your Own Functions ................................................... 185
 12.9.1 Example 7: Simple User Deﬁ ned Function .................. 186
12.10 An Introduction to the Scope of Variables, Local Variables 
and Interface Checking ................................................................ 188
12.11 Recursive Functions ..................................................................... 188
12.11.1 Example 8: Recursive Factorial Evaluation ................. 189
12.12 Example 9: Recursive Version of gcd .......................................... 190
12.13 Example 10: After Removing Recursion ..................................... 191
12.14 Internal Functions ........................................................................ 192
12.14.1 Example 11: Stirling’s Approximation ........................ 192
12.15 Pure Functions ............................................................................. 193
12.15.1 Pure Constraints ........................................................... 194

xiv
Contents
12.16 Elemental Functions ..................................................................... 194
12.17 Resumé ......................................................................................... 195
12.18 Formal Syntax .............................................................................. 196
12.19 Rules and Restrictions .................................................................. 196
12.20 Problems ...................................................................................... 197
12.21 Bibliography ................................................................................ 197
12.21.1 Recursion and Problem Solving ................................... 198
13 Control Structures .................................................................................. 199
 13.1 Introduction .................................................................................. 200
 13.2 Selection Among Courses of Action ............................................ 200
 13.2.1 The Block if Statement ................................................. 201
 13.2.2 The Case Statement ...................................................... 205
 13.3 The Three Forms of the do Statement .......................................... 207
 13.3.1 Example 5: Sentinel Usage........................................... 208
 13.3.2 Cycle and Exit .............................................................. 209
 13.3.3 Example 6: e**x Evaluation ......................................... 209
 13.3.4 Example 7: Wave Breaking on an Offshore Reef ......... 210
 13.4 Summary ...................................................................................... 212
 13.4.1 Control Structure Formal Syntax ................................. 213
 13.5 Problems ...................................................................................... 213
 13.6 Bibliography ................................................................................ 215
14 Characters ............................................................................................... 217
 14.1 Introduction .................................................................................. 217
 14.2 Character Input ............................................................................. 218
 14.3 Character Operators ..................................................................... 219
 14.4 Character Substrings .................................................................... 221
 14.5 Character Functions ..................................................................... 222
 14.6 Collating Sequence ...................................................................... 223
 14.7 Finding Out About the Character Set Available .......................... 225
 14.8 Scan Function Example ............................................................... 226
 14.9 Summary ...................................................................................... 227
14.10 Problems ...................................................................................... 228
15 Complex ................................................................................................... 231
 15.1 Introduction .................................................................................. 231
 15.2 Example 1 .................................................................................... 232
 15.3 Example 2 .................................................................................... 234
 15.4 Complex and Kind Type .............................................................. 234
 15.5 Summary ...................................................................................... 234
 15.6 Problem ........................................................................................ 235
16 Logical ...................................................................................................... 237
 16.1 Introduction .................................................................................. 237
 16.2 I/O ................................................................................................ 240
 16.3 Summary ...................................................................................... 241
 16.4 Problems ...................................................................................... 241

xv
Contents
17 Introduction to Derived Types ............................................................... 243
17.1 
Introduction .................................................................................... 243
17.2 
Example 1: Dates ........................................................................... 244
17.3 
Type Deﬁ nition .............................................................................. 244
17.4 
Variable Deﬁ nition ......................................................................... 245
17.4.1 
Example 1 Variant Using Modules .................................. 245
17.5 
Example 2: Address Lists .............................................................. 246
17.6 
Example 3: Nested User Deﬁ ned Types ........................................ 247
17.7 
Problem .......................................................................................... 249
17.8 
Bibliography .................................................................................. 249
18 An Introduction to Pointers ................................................................... 251
18.1 
Introduction .................................................................................... 251
18.2 
Some Basic Pointer Concepts ........................................................ 252
18.3 
The associated Intrinsic Function ........................................... 253
18.4 
Referencing a and b Before Allocation or Pointer 
Assignment .................................................................................... 254
18.4.1 
gfortran ............................................................................ 254
18.4.2 
Intel .................................................................................. 255
18.4.3 
Nag .................................................................................. 255
18.5 
Pointer Allocation and Assignment ............................................... 255
18.6 
Memory Leak Examples ................................................................ 256
18.7 
Non-standard Pointer Example ...................................................... 258
18.8 
Problems ........................................................................................ 259
19 Introduction to Subroutines ................................................................... 261
19.1 
Introduction .................................................................................... 262
19.2 
Example 1 ...................................................................................... 262
19.2.1 
Deﬁ ning a Subroutine ...................................................... 264
19.2.2 
Referencing a Subroutine ................................................ 265
19.2.3 
Dummy Arguments or Parameters 
and Actual Arguments ..................................................... 265
19.2.4 
Intent ................................................................................ 265
19.2.5 
Local Variables ................................................................ 266
19.2.6 
Local Variables and the Save Attribute ........................... 266
19.2.7 
Scope of Variables ........................................................... 266
19.2.8 
Status of the Action Carried Out in the Subroutine......... 267
19.2.9 
Modules ‘containing’ Procedures .................................... 267
19.3 
Why Bother with Subroutines? ...................................................... 267
19.4 
Summary ........................................................................................ 268
19.5 
Problems ........................................................................................ 268
20 Subroutines: 2 .......................................................................................... 269
20.1 
More on Parameter Passing ........................................................... 269
20.1.1 
Assumed-Shape Array ..................................................... 269
20.1.2 
Deferred-Shape Array ..................................................... 270
20.1.3 
Automatic Arrays ............................................................ 270

xvi
Contents
 20.2 Example 1 – Assumed Shape Parameter Passing ........................ 270
 20.2.1 Notes ............................................................................. 272
 20.3 Character Arguments and Assumed-Length 
Dummy Arguments ...................................................................... 272
 20.4 Rank 2 and Higher Arrays as Parameters .................................... 273
 20.4.1 Notes ............................................................................. 275
 20.5 Automatic Arrays and Median Calculation ................................. 275
 20.5.1 Internal Subroutines and Scope .................................... 278
 20.6 Recursive Subroutines – Quicksort .............................................. 279
 20.6.1 Note – Recursive Subroutine ........................................ 281
 20.6.2 Note – Flexible Design ................................................. 282
 20.6.3 Note – Timing Information .......................................... 282
 20.7 Elemental Subroutines ................................................................. 282
 20.8 Summary ...................................................................................... 283
 20.9 Problems ...................................................................................... 283
20.10 Bibliography ................................................................................ 285
20.11 
Commercial Numerical and Statistical Subroutine Libraries ......... 285
21 Modules .................................................................................................... 287
 21.1 Introduction .................................................................................. 287
 21.2 Basic Module Syntax ................................................................... 288
 21.3 Modules for Global Data ............................................................. 288
 21.4 
Modules for Precision Speciﬁ cation and Constant Deﬁ nition ....... 288
 21.4.1 Note .............................................................................. 290
 21.5 Modules for Sharing Arrays of Data ............................................ 290
 21.6 Modules for Derived Data Types ................................................. 292
 21.6.1 Person Data Type .......................................................... 292
 21.7 Private, Public and Protected Attributes ...................................... 294
 21.8 The Use Statement ....................................................................... 295
 21.9 Notes on Module Usage and Compilation ................................... 295
21.10 Formal Syntax .............................................................................. 295
21.10.1 Interface ........................................................................ 295
21.10.2 Implicit and Explicit Interfaces .................................... 296
21.10.3 Explicit Interface .......................................................... 296
21.11 Summary ...................................................................................... 296
21.12 Problems ...................................................................................... 297
22 Simple Data Structuring in Fortran ...................................................... 299
 22.1 Introduction .................................................................................. 299
 22.2 
Singly Linked List: Reading in an Arbitrary Amount of Text ....... 300
 22.3 Singly Linked List: Reading in an Arbitrary Quantity 
of Numeric Data ........................................................................... 302
 22.4 Ragged Arrays ............................................................................. 305
 22.5 Ragged Arrays and Variable Sized Data Sets .............................. 306
 22.6 Perfectly Balanced Tree ............................................................... 307

xvii
Contents
22.7 
Date Class ...................................................................................... 309
22.7.1 
Notes: DST in the USA ................................................... 324
22.8 
Problems ........................................................................................ 324
22.9 
Bibliography .................................................................................. 324
23 Operator Overloading ............................................................................ 327
23.1 
Introduction .................................................................................... 327
23.2 
Other Languages ............................................................................ 327
23.3 
Example ......................................................................................... 328
23.4 
Problem .......................................................................................... 329
24 Generic Programming ............................................................................ 331
24.1 
Introduction .................................................................................... 331
24.2 
Generic Programming and Other Languages ................................ 331
24.3 
Generic Example ........................................................................... 332
24.3.1 
Generic Quicksort in C++ ............................................... 339
24.3.2 
Generic Quicksort in C# .................................................. 340
24.3.3 
Summary ......................................................................... 341
24.4 
Problem .......................................................................................... 341
24.5 
Bibliography .................................................................................. 342
25 Mathematical Examples ......................................................................... 343
25.1 
Introduction .................................................................................... 343
25.2 
Using Linked Lists for Sparse Matrix Problems ........................... 344
25.2.1 
Inner Product of Two Sparse Vectors .............................. 344
25.3 
Solving a System of First-Order Ordinary Differential 
Equations Using Runge–Kutta–Merson ........................................ 348
25.3.1 
Note: Alternative Form of the Allocate Statement .......... 354
25.3.2 
Note: Automatic Arrays .................................................. 355
25.3.3 
Note: Subroutine as a Dummy Procedure Argument ...... 355
25.3.4 
Note: Compilation When Using Modules ....................... 355
25.4 
A Subroutine to Extract the Diagonal Elements of a Matrix ......... 356
25.5 
The Solution of Linear Equations Using Gaussian 
Elimination .................................................................................... 357
25.5.1 
Notes ................................................................................ 361
25.6 
Allocatable Function Results ......................................................... 362
25.7 
Elemental e**x Function ............................................................... 364
25.8 
Problems ........................................................................................ 365
25.9 
Bibliography .................................................................................. 365
26 Object Oriented Programming .............................................................. 367
26.1 
Introduction .................................................................................... 367
26.2 
Brief Review of the History of Object Oriented Programming ..... 367
26.3 
Background Technical Material ..................................................... 368
26.4 
Type Declaration Statements ......................................................... 369
26.4.1 
TYPE ............................................................................... 369
26.4.2 
CLASS ............................................................................ 369

xviii
Contents
 26.4.3 Attributes ...................................................................... 369
 26.4.4 Passed Object Dummy Arguments ............................... 370
 26.4.5 Derived Types and Structure Constructors ................... 370
 26.4.6 Structure Constructors and Generic Names ................. 371
 26.4.7 Assignment ................................................................... 371
 26.4.8 Intrinsic Assignment Statement ................................... 371
 26.4.9 Deﬁ ned Assignment Statement .................................... 372
26.4.10 Polymorphic Variables ................................................. 372
26.4.11 Executable Constructs Containing Blocks ................... 372
26.4.12 ASSOCIATE Construct ................................................ 372
26.4.13 Select Type Construct ................................................... 372
 26.5 Example 1 – The Basic Shape Class ............................................ 373
 26.5.1 Key Points .................................................................... 374
 26.5.2 Notes ............................................................................. 377
 26.5.3 Example 1 with Private Data ........................................ 378
 26.5.4 Solution 1 with an Interface to Use the Class 
Name for the Structure Constructor ............................. 379
 26.5.5 Public and Private Accessibility ................................... 381
 26.6 Example 2 – Simple Inheritance .................................................. 381
 26.6.1 Base Shape Class .......................................................... 382
 26.6.2 Circle – Derived Type 1 ................................................ 382
 26.6.3 Rectangle – Derived Type 2 ......................................... 385
 26.6.4 Simple Inheritance Test Program ................................. 386
 26.7 Example 3 – Polymorphism and Dynamic Binding .................... 388
 26.7.1 Base Shape Class .......................................................... 388
 26.7.2 Circle – Derived Type 1 ................................................ 390
 26.7.3 Rectangle – Derived Type 2 ......................................... 390
 26.7.4 Shape Wrapper Module ................................................ 390
 26.7.5 Display Subroutine ....................................................... 391
 26.7.6 Test Program ................................................................. 391
 26.7.7 Program Output ............................................................ 394
 26.8 Summary ...................................................................................... 395
 26.9 Problems ...................................................................................... 396
26.10 Bibliography ................................................................................ 396
27 Introduction to Parallel Programming ................................................. 397
 27.1 Introduction .................................................................................. 397
 27.2 Parallel Computing Classiﬁ cation ................................................ 399
 27.3 Amdahl’s Law .............................................................................. 399
 27.3.1 Amdahl’s Law Graph 1–8 Processors or Cores ............ 400
 27.3.2 Amdahl’s Law Graph 2–64 Processors or Cores .......... 400
 27.4 Gustafson’s Law ........................................................................... 403
 27.4.1 Gustafson’s Law Graph 1–64 Processors or Cores ...... 403
 27.5 Memory Access ........................................................................... 406
 27.6 Cache ............................................................................................ 406
 27.7 Bandwidth and Latency ............................................................... 406
 27.8 Flynn’s Taxonomy........................................................................ 407

xix
Contents
 27.9 Consistency Models ..................................................................... 407
27.10 Threads and Threading ................................................................ 408
27.11 Threads and Processes ................................................................. 408
27.12 Data Dependencies ....................................................................... 408
27.13 Race Conditions ........................................................................... 408
27.14 Mutual Exclusion – Mutex ........................................................... 408
27.15 Monitors ....................................................................................... 408
27.16 Locks ............................................................................................ 409
27.17 Synchronization ........................................................................... 409
27.18 Granularity and Types of Parallelism ........................................... 409
27.19 Partitioned Global Address Space – PGAS ................................. 409
27.20 Fortran and Parallel Programming ............................................... 410
27.21 MPI .............................................................................................. 410
27.22 OpenMP ....................................................................................... 412
27.23 Coarray Fortran ............................................................................ 413
27.24 Other Parallel Options .................................................................. 413
27.24.1 PVM ............................................................................. 414
27.24.2 HPF ............................................................................... 414
27.25 Top 500 Supercomputers ............................................................. 414
27.26 Summary ...................................................................................... 415
27.27 Bibliography ................................................................................ 415
27.27.1 Computer Hardware ..................................................... 415
27.27.2 Intel ............................................................................... 415
27.27.3 Computer Operating Systems ....................................... 416
27.27.4 Parallel Programming ................................................... 416
28 MPI – Message Passing Interface .......................................................... 417
 28.1 Introduction .................................................................................. 417
 28.2 MPI Programming ....................................................................... 417
 28.3 Compiler and Implementation Combination ............................... 418
 28.4 Individual Implementation ........................................................... 418
 28.4.1 MPICH2 ....................................................................... 418
 28.4.2 Open MPI ..................................................................... 418
 28.5 Compiler and MPI Combinations Used in the Book ................... 419
 28.6 The MPI Memory Model ............................................................. 419
 28.7 Example 1 – Hello World............................................................. 419
 28.8 Example 2 – Hello World Using Send and Receive .................... 422
 28.9 Example 3 – Serial Solution for pi Calculation ........................... 425
28.10 Example 4 – Parallel Solution for pi Calculation ........................ 432
28.11 Example 5 – Work Sharing Between Processes ........................... 439
28.12 Summary ...................................................................................... 443
28.13 Problem ........................................................................................ 444
29 OpenMP ................................................................................................... 445
 29.1 Introduction .................................................................................. 445
 29.2 OpenMP Memory Model ............................................................. 446
 29.3 Example 1 – Hello World............................................................. 447

xx
Contents
 29.4 Example 2 – Hello World Using Default Variable Data Scoping .... 450
 29.5 Example 3 – Hello World with Private 
thread_number Variable ........................................................ 451
 29.6 Example 4 – Parallel Solution for pi Calculation ........................ 452
 29.7 Summary ...................................................................................... 455
 29.8 Problem ........................................................................................ 455
30 Coarray Fortran ...................................................................................... 457
 30.1 Introduction .................................................................................. 457
 30.2 Coarray Terminology ................................................................... 458
 30.3 Example 1 – Hello World............................................................. 459
 30.4 Example 2 – Broadcasting Data ................................................... 459
 30.5 Example 3 – Parallel Solution for Pi Calculation ........................ 460
 30.6 Example 4 – Work Sharing .......................................................... 463
 30.7 Summary ...................................................................................... 467
 30.8 Problem ........................................................................................ 467
31 C Interop .................................................................................................. 469
 31.1 Introduction .................................................................................. 469
 31.2 ISO_C_BINDING Module .......................................................... 469
 31.3 Named Constants and Derived Types in the Module ................... 469
 31.4 Character Interoperability ............................................................ 470
 31.5 Procedures in the Module ............................................................ 471
 31.6 Interoperability of Intrinsic Types................................................ 471
 31.7 Other Aspects of Interoperability ................................................. 471
 31.8 C_LOC Examples ........................................................................ 472
 31.9 Example 1 .................................................................................... 473
31.9.1 Gfortran Output ............................................................. 475
31.9.2 Intel Output .................................................................... 475
31.9.3 Nag Output ..................................................................... 476
31.10 Example 2 .................................................................................... 476
31.11 Bibliography ................................................................................ 478
31.12 Problem ........................................................................................ 478
32 ISOTR 15580 IEEE Arithmetic ............................................................. 479
 32.1 Introduction .................................................................................. 479
 32.2 History .......................................................................................... 480
 32.3 IEEE 754 Speciﬁ cations .............................................................. 481
32.3.1 Single Precision Floating Point Format ......................... 482
32.3.2 Double Precision Floating Point Format ....................... 484
32.3.3 Two Classes of Extended Floating Point Formats ......... 484
32.3.4 Accuracy Requirements ................................................. 484
32.3.5 Base Conversion – Converting Between Decimal 
and Binary Floating Point Formats and Vice Versa ....... 484
32.3.6 Exception Handling ....................................................... 485
32.3.7 Rounding Directions ...................................................... 485
32.3.8 Rounding Precisions ...................................................... 485

xxi
Contents
32.4 
Resumé .......................................................................................... 485
32.5 
ISO TR 15580 ................................................................................ 486
32.5.1 
IEEE_FEATURES Module ............................................. 486
32.5.2 
IEEE_EXCEPTIONS Module ........................................ 486
32.5.3 
IEEE_ARITHMETIC Module  ....................................... 488
32.6 
Summary ........................................................................................ 493
32.7 
Bibliography .................................................................................. 493
32.7.1 
Web-Based Sources ......................................................... 494
32.7.2 
Hardware Sources ............................................................ 495
32.7.3 
Operating Systems ........................................................... 496
32.7.4 
Java and IEEE 754 ........................................................... 497
32.7.5 
C and IEEE 754 ............................................................... 497
33 Miscellaneous Features and Examples .................................................. 499
33.1 
Introduction .................................................................................... 499
33.2 
Keyword and Optional Arguments ................................................ 499
33.3 
Allocatable Dummy Arrays ........................................................... 501
33.4 
Non Recursive Quicksort ............................................................... 504
33.4.1 
Gfortran ........................................................................... 516
33.4.2 
Intel .................................................................................. 516
33.4.3 
Nag .................................................................................. 517
33.4.4 
Notes – Version Control Systems .................................... 517
33.5 
Simple Graphics Programming – Dislin ........................................ 518
33.6 
Problem .......................................................................................... 529
33.6.1 
Hint .................................................................................. 529
33.7 
Bibliography .................................................................................. 530
34 Converting from Fortran 77 ................................................................... 531
34.1 
Introduction .................................................................................... 531
34.2 
Deleted Features ............................................................................ 532
34.3 
Obsolescent Features ..................................................................... 532
34.3.1 
Arithmetic if .................................................................... 532
34.3.2 
Real and Double Precision Do Control Variables ........... 532
34.3.3 
Shared Do Termination and Non-enddo Termination ..... 532
34.3.4 
Alternate Return .............................................................. 532
34.3.5 
Pause Statement ............................................................... 533
34.3.6 
Assign and Assigned Goto Statements ............................ 533
34.3.7 
Assigned Format Statements ........................................... 533
34.3.8 
H Editing ......................................................................... 533
34.4 
Better Alternatives ......................................................................... 533
34.5 
Commercial Conversion Tools ....................................................... 534
34.5.1 
Convert ............................................................................ 534
34.5.2 
Forcheck .......................................................................... 534
34.5.3 
Forstruct ........................................................................... 534
34.5.4 
Forstudy ........................................................................... 535

xxii
Contents
34.5.5 
Fortran90-Lint ................................................................. 535
34.5.6 
Plusfort ............................................................................ 535
34.5.7 
VAST/77to90 ................................................................... 535
34.6 
Example of plusFORT Capability from Polyhedron Software ...... 535
34.6.1 
Original Fortran 66 .......................................................... 535
34.6.2 
Fortran 77 Version ........................................................... 536
34.6.3 
Fortran 90 Version ........................................................... 537
34.7 
Summary ........................................................................................ 538
Appendix A: Glossary ..................................................................................... 539
Appendix B: ASCII Character Set ................................................................ 547
Appendix C: Intrinsic Functions and Procedures ........................................ 549
Appendix D: English and Latin Texts ........................................................... 593
Appendix E: Coded Text Extract ................................................................... 595
Appendix F: Formal Syntax ........................................................................... 597
Appendix G: Compiler Options ..................................................................... 603
Index ................................................................................................................. 607 

1
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_1, © Springer-Verlag London Limited 2012
 1.1 Introduction 
 The book aims to provide coverage of a reasonable working subset of the Fortran 
programming language. The subset chosen should enable you to solve quite a wide 
range of frequently occurring problems. 
 This book has been written for both complete beginners with little or no pro-
gramming background and experienced Fortran programmers who want to update 
their skills and move to a modern version of the language. 
 Chapters  2 and  3 provide a coverage of problem solving and the history and 
development of programming languages. Chapter  2 is essential for the beginner as 
the concepts introduced there are used and expanded on throughout the rest of the 
book. Chapter  3  should be read at some point but can be omitted initially. 
Programming languages evolve and some understanding of where Fortran has come 
from and where it is going will prove valuable in the longer term.
 Chapter  2 looks at problem solving in some depth, and there is a coverage of the 
• 
way we deﬁ ne problems, the role of algorithms, the use of both top-down and 
bottom-up methods, and the requirement for formal systems analysis and design 
for more complex problems. 
 Chapter  3 looks at the history and development of programming languages. This 
• 
is essential as Fortran has evolved considerably from its origins in the mid-1950s, 
through the ﬁ rst standard in 1966, the Fortran 77 standard, the Fortran 90 stan-
dard, the Fortran 95 standard, TR 15580 and TR 15581, Fortran 2003 and Fortran 
2008. It helps to put many of the current and proposed features of Fortran into 
 Chapter 1 
 Overview 
 I don’t know what the language of the year 2000 will look like, 
but it will be called Fortran. 
 C.A.R. Hoare 

2
1 Overview
context. Languages covered include Cobol, Algol, Lisp, Snobol, PL/1, Algol 68, 
Simula, Pascal, APL, Basic, C, Ada, Modula, Modula 2, Logo, Prolog, SQL, 
ICON, Oberon, Oberon 2, Smalltalk, C++, C# and Java. 
 Chapters  4 through  8 cover the major features provided in Fortran for numeric pro-
gramming in the ﬁ rst instance and for general purpose programming in the second. Each 
chapter has a set of problems. It is essential that a reasonable range of problems are 
attempted and completed, as it is impossible to learn any language without practice.
 Chapter  4 provides an introduction to programming with some simple Fortran 
• 
examples. For people with a knowledge of programming this chapter can be 
covered fairly quickly. 
 Chapter  5 looks at arithmetic in some depth, with a coverage of the various 
• 
numeric data types, expressions and assignment of scalar variables. There is also 
a thorough coverage of the facilities provided in Fortran to help write programs 
that work on different hardware platforms. 
 Chapter  6 is an introduction to arrays and do loops. The chapter starts with some 
• 
examples of tabular structures that one should be familiar with. There is then an 
examination of what concepts we need in a programming language to support 
manipulation of tabular data. 
 Chapter  7 takes the ideas introduced in Chap.  6 and extends them to higher-
• 
dimensioned arrays, additional forms of the dimension attribute and correspond-
ing form of the do loop, and the use of looping for the control of repetition and 
manipulation of tabular information without the use of arrays. 
 Chapter  8 looks at more of the facilities offered for the manipulation of whole 
• 
arrays and array sections, ways in which we can initialise arrays using construc-
tors, look more formally at the concepts we need to be able to accurately describe 
and understand arrays, and ﬁ nally look at the differences between the way Fortran 
allows us to use arrays and the mathematical rules governing matrices. 
 Chapters  9 ,  10 and  11 look at input and output (I/O) and ﬁ le handling in Fortran. 
An understanding of I/O is necessary for the development of so-called production, 
non interactive programs. These are essentially fully developed programs that are 
used repeatedly with a variety of data inputs and results.
 Chapter  9 looks at output of results and how to generate something that is more 
• 
comprehensible and easy to read than what is available with free format output 
and also how to write the results to a ﬁ le rather than the screen. 
 Chapter  10 extends the ideas introduced in Chap.  12 on output to cover input of 
• 
data, or reading data into a program and also considers ﬁ le I/O. 
 Chapter  11 provides a coverage of ﬁ les. 
• 
 Chapter  12 introduces the ﬁ rst building block available in Fortran for the con-
struction of programs for the solution of larger, more complex problems. It looks at 
the functions available in Fortran, the so-called intrinsic functions and procedures 
(over 100 of them) and covers how you can deﬁ ne and use your own functions. 
 It is essential to develop an understanding of the functions provided by the 
language and when it is necessary to write your own. 

3
1.1 Introduction
 Chapter  13 introduces more formally the concept of control structures and 
their role in structured programming. Some of the control structures available in 
Fortran are introduced in earlier chapters, but there is a summary here of those 
already covered plus several new ones that complete our coverage of a minimal 
working set. 
 Chapters  14 through  16 complete our coverage of the intrinsic facilities in Fortran 
for data typing.
 Chapter  14 looks at the character data type in Fortran. There is a coverage of I/O 
• 
again, with the operators available—only one in fact. 
 Chapter  15 looks at the last numeric data type in Fortran, the complex data type. 
• 
This data type is essential to the solution of a small class of problems in mathe-
matics and engineering. 
 Chapter  16 looks at the logical data type. The material covered here helps con-
• 
siderably in increasing the power and sophistication of the way we use and con-
struct logical expressions in Fortran. This proves invaluable in the construction 
and use of logical expressions in control structures. 
 Chapter  17 introduces derived or user deﬁ ned types with a small number of 
examples. 
 Chapter  18 looks at the dynamic data-structuring facilities now available in 
Fortran with the addition of pointers. This chapter looks at the basic syntax of 
pointers. They are used in range of examples in later chapters in the book. 
  The next two chapters look at the second major building block in Fortran—
the subroutine. Chapter  19 provides a gentle introduction to some of the funda-
mental concepts of subroutine deﬁ nition and use and Chapter   20     extends these 
ideas.  
 Chapter  21 introduces one of modern Fortran’s major key features—A Fortran 
module can be thought of as equivalent to a class in C++, Java and C#. the mod-
ule. This chapter looks at the basic syntax, with a couple of simple examples. 
 Chapter  22 looks at simple data structuring in Fortran, as we have now covered 
modules in a bit more depth. 
 Chapter  23 looks brieﬂ y at operator overloading, ﬁ rst introduced in Fortran 90. 
 Chapter  24 looks at generic programming. 
 Chapter  25 has a small set of mathematical examples. 
 Chapter  26 introduces object oriented programming in Fortran. 
 Chapters  27 through  30 look at parallel programming in Fortran with coverage of 
MPI, OpenMP and Coarray Fortran. 
 Chapter  31 looks at C interoperability. 
 Chapter  32 looks at IEEE Arithmetic support in Fortran. 
 Chapter  33 looks at a number of miscellaneous Fortran features. 
 Chapter  34 looks at converting from Fortran 77 to more modern Fortran. 
 Some of the chapters have annotated bibliographies. These often have pointers 
and directions for further reading. The coverage provided cannot be seen in isolation. 
The concepts introduced are by intention brief, and fuller coverage must be sought 
where necessary. 

4
1 Overview
 There are several appendices:
  Appendix A—This is a glossary which provides coverage of both the new con-
• 
cepts provided by Fortran and a range of computing terms and ideas. 
 Appendix B—The ASCII character set. 
• 
 Appendix C—Contains a list of some of the more commonly used intrinsic pro-
• 
cedures in Fortran and includes an explanation of each procedure with a cover-
age of the rules and restrictions that apply and examples of use where 
appropriate. 
 Appendix D—Contains the English and Latin text extracts used in one of the 
• 
problems in the chapter on characters. 
 Appendix E—Contains the coded text extract used in one of the problems in 
• 
Chapter  17 . 
 Appendix F—Formal syntax 
• 
 Appendix G—Sample compiler options 
• 
 This book is not and cannot possibly be completely self-contained and exhaustive 
in its coverage of the Fortran language. Our ﬁ rst intention has been to produce a 
coverage of the features that will get you started with Fortran and enable you to 
solve a range of problems successfully. 
 All in all Fortran is an exciting language, and it has caught up with language 
developments of the last 50 years. 
 Several Fortran compilers have been used whilst writing this book. These 
include:
 NAG Fortran Builder 5.1, 5.2, for Windows 
• 
 NAG Fortran Compiler 5.1, 5.2, 5.3 for Windows 
• 
 NAG Fortran Compiler 5.1, 5.2 for Linux. 
• 
 Intel Fortran 11.x, 12.x for Windows. 
• 
 Intel Fortran 12.x for Linux. 
• 
 gnu gfortran 4.x for Windows. 
• 
 gnu gfortran 4.x for Linux. 
• 
 g95 for Linux. 
• 
 pgi 10.x—Cray Hector service 
• 
 Cray 1.0.1—Cray Hector service 
• 
 Oracle Solaris Studio 12.0, 12.1, 12.2 for Linux 
• 
 Our recommendation is that you use at least two compilers in the development of 
your code. Moving code between compilers and platforms teaches you a lot. 
 We are the current owners of the Fortran 90 list, and quoting the introduction 
“This list covers all aspects of Fortran 90 and HPF, the new standard(s) for Fortran. 
The emphasis should be on the *new* features of Fortran 90. It welcomes contribu-
tions from people who write Fortran 90 applications, teach it in courses, want to port 
programs and use it on (super)computers.” 
 Visit:
 
• http://www.jiscmail.ac.uk/lists/comp-fortran-90.html for more information. 

5
1.3 Further Reading
 Ian Chivers is also Editor of Fortran Forum, the SIGPLAN Special Interest 
Publication on Fortran, ACM Press. Visit 
 http://portal.acm.org/citation.cfm?id=J286 for more information. 
 1.2  Program Examples 
 All of the program examples are available on line at   http://www.fortranplus.co.uk/  
 1.3  Further Reading 
 Mastery of any programming language requires working with technical documenta-
tion. You will have to refer to or use one or more of the sources below if you want 
to progress as a Fortran programmer. 
 1.3.1  The Fortran Standard 
 The ISO site  http://www.iso.org/iso/search.htm?qt=fortran&sort=rel&type=simple
&pub-lished=on has details of how to obtain a copy. It is 338 Swiss Francs. 
 In the UK the standard can be obtained from the BSI. Details are given below: 
 http://shop.bsigroup.com/en/ProductDetail/?pid=000000000030185076 It is 356 
UK pounds. 
 You should be able to buy the standard from the standards organisations in your 
country. Google is a good place to start/ 
 1.3.2  J3 and WG5 Working Documents 
 Working documents can be found at the J3 and WG5 sites. The last working docu-
ment for the Fortran 2003 standard can be found at both the J3 and WG5 sites. WG5 
have the document available at:  ftp://ftp.nag.co.uk/sc22wg5/N1601-N1650/ and is 
document number n1601. It can also be found at the J3 site.  http://www.j3-fortran.
org/doc/year/04/04-007.pdf 
 1.3.3  Compiler Documentation 
 The compiler may come with documentation. Here are some details for a number of 
compilers. 

6
1 Overview
 1.3.3.1  g95 
 A manuals is available at
 http://ftp.g95.org/G95Manual.pdf Visit 
 http://www.g95.org/index.shtm for up to date information. 
 1.3.3.2  gfortran 
 Manuals are available at
 http://gcc.gnu.org/wiki/GFortran#manuals The following 
 http://gcc.gnu.org/onlinedocs/gcc-4.5.2/gfortran.pdf is a 236 page pdf. 
 1.3.3.3  Intel 
 Windows. The following will end up available after a complete install.
 Intel MKL
• 
 Release notes 
• 
 Reference Manual 
• 
 User Guide 
• 
 Parallel Debugger Extension
• 
 Release Notes 
• 
 Compiler
• 
 Reference Manual, Visual Studio Help ﬁ les or html. 
• 
 User Guide, Visual Studio Help ﬁ les or html. Intel also provide the 
• 
 following  http://software.intel.com/en-us/articles/intel-software-technical-
documentation/  
 1.3.3.4  Nag 
Windows 
 Fortran Builder Help
• 
 Fortran Builder Tutorial—44 pages 
• 
 Fortran Builder Operation Guide—67 pages 
• 
 Fortran Language Guide—115 pages 
• 
 Compiler Manual—149 pages 
• 
 LAPACK Guide—70 pages (440MB as PDF!) 
• 

7
1.3 Further Reading
 GTK + Library—201 pages 
• 
 OpenGL/GLUT Library—38 pages 
• 
 SIMDEM Library—78 pages 
• 
 1.3.3.5  Oracle/Sun 
 Oracle make available a range of documentation. From within Oracle Solaris 
Studio
 Help
• 
 Help Contents 
• 
 Online Docs and Support 
• 
 .. 
• 
 .. 
• 
 Quick Start Guide and you will get taken to the Oracle site by some of these 
• 
entries. 
 You can also download a 300+ MB zip ﬁ le which contains loads of Oracle docu-
mentation. You should be able to locate (after some rummaging around)
 Sun Studio 12: Fortran Programming Guide—174 pages 
• 
 Sun Studio 12: Fortran User’s Guide—216 pages 
• 
 Sun Studio 12: Fortran Library Reference—144 pages 
• 
 Fortran 95 Interval Arithmetic Programming Reference—166 pages Happy 
• 
reading :-)      
 1.3.4  Books 
 Adams, J.C., Brainerd, W.S., Hendrickson, R.A., Maine, R.E., Martin, J.T., Smith, 
B.T.: The Fortran 2003 Handbook: The Complete Syntax, Features and Procedures. 
Springer, London (2008) 31 Oct 2008, ISBN-10: 1846283787, ISBN-13: 978-
1846283789. 
 It covers the whole of the Fortran 2003 standard in a lot of depth. The content and 
structure of the book follows that of the standard directly. A much easier read than 
the standard, and a lot cheaper. 

9
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_2, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are:
 To examine some of the ideas and concepts involved in problem solving. 
• 
 To introduce the concept of an algorithm. 
• 
 To introduce two ways of approaching algorithmic problem solving. 
• 
 To introduce the ideas involved with systems analysis and design, i.e., to show 
• 
the need for pencil and paper study before using a computer system. 
 Chapter 2 
 Introduction to Problem Solving  
 They constructed ladders to reach to the top of the enemy’s 
wall, and they did this by calculating the height of the wall 
from the number of layers of bricks at a point which was 
facing in their direction and had not been plastered. The 
layers were counted by a lot of people at the same time, and 
though some were likely to get the ﬁ gure wrong the majority 
would get it right… Thus, guessing what the thickness of a 
single brick was, they calculated how long their ladder would 
have to be. 
 Thucydides, The Peloponnesian War 
 ‘When I use a word,’ Humpty Dumpty said, in a rather scornful 
tone, ‘it means just what I choose it to mean—neither more
nor less.’ 
 ‘The question is,’ said Alice, ‘whether you can make words 
mean so many different things.’ 
 Lewis Carroll, Through the Looking Glass 
and What Alice Found There 

10
2 Introduction to Problem Solving
 2.1  Introduction 
 It is informative to consider some of the dictionary deﬁ nitions of problem:
 A matter difﬁ cult of settlement or solution, Chambers. 
• 
 A question or puzzle propounded for solution, Chambers. 
• 
 A source of perplexity, Chambers. 
• 
 Doubtful or difﬁ cult question, Oxford. 
• 
 Proposition in which something has to be done, Oxford. 
• 
 A question raised for enquiry, consideration, or solution, Webster’s. 
• 
 An intricate unsettled question, Webster’s. 
• 
 A common thread seems to be a question that we would like answered or solved. So 
one of the ﬁ rst things to consider in problem solving is how to pose the problem. This 
is often not as easy as is seems. Two of the most common methods to use here are:
 In natural language. 
• 
 In artiﬁ cial or stylised language. 
• 
 Both methods have their advantages and disadvantages. 
 2.2  Natural Language 
 Most people use natural language and are familiar with it, and the two most common 
forms are the written and spoken word. Consider the following language usage:
 The difference between a 3 year-old child and an adult describing the world. 
• 
 The difference between the way an engineer and a physicist would approach the 
• 
design of a car engine. 
 The difference between a manager and a worker considering the implications of 
• 
the introduction of new technology. 
 Great care must be taken when using natural language to deﬁ ne a problem and 
a solution. It is possible that people use the same language to mean completely 
different things, and one must be aware of this when using natural language whilst 
problem solving. 
 Natural language can also be ambiguous: Old men and women eat cheese. Are 
both the men and women old? 
 2.3  Artiﬁ cial Language 
 The two most common forms of artiﬁ cial language are technical terminology and 
notations. Technical terminology generally includes both the use of new words and 
alternate use of existing words. Consider some of the concepts that are useful when 
examining the expansion of gases in both a theoretical and practical fashion:

11
2.5 Algorithms
 Temperature. 
• 
 Pressure. 
• 
 Mass. 
• 
 Isothermal expansion. 
• 
 Adiabatic expansion. 
• 
 Now look at the following:
 A chef using a pressure cooker. 
• 
 A garage mechanic working on a car engine. 
• 
 A doctor monitoring blood pressure. 
• 
 An engineer designing a gas turbine. 
• 
 Each has a particular problem to solve, and all will approach their problem in their 
own way; thus they will each use the same terminology in slightly different ways. 
 2.3.1  Notations 
 Some examples of notations are:
 Algebra. 
• 
 Calculus. 
• 
 Logic. 
• 
 All of the above have been used as notations for describing both problems and 
their solutions. 
 2.4  Resume 
 We therefore have two ways of describing problems and they both have a learning 
phase until we achieve sufﬁ cient understanding to use them effectively. Having 
arrived at a satisfactory problem statement we next have to consider how we get the 
solution. It is here that the power of the algorithmic approach becomes useful. 
 2.5  Algorithms 
 An algorithm is a sequence of steps that will solve part or all of a problem. One of 
the most easily understood examples of an algorithm is a recipe. Most people have 
done some cooking, if only making toast and boiling an egg. 
 A recipe is made up of two parts:
 A check list of things you need. 
• 
 The sequence or order of steps. 
• 

12
2 Introduction to Problem Solving
 Problems can occur at both stages, e.g., ﬁ nding out halfway through the recipe that 
you do not have an ingredient or utensil; ﬁ nding out that one stage will take an hour 
when the rest will be ready in 10 min. Note that certain things can be done in any 
order—it may not make any difference if you prepare the potatoes before the carrots. 
 There are two ways of approaching problem solving when using a computer. 
They both involve algorithms, but are very different from one another. They are 
called top-down and bottom-up. 
 2.5.1  Top-Down 
 In a top-down approach the problem is ﬁ rst speciﬁ ed at a high or general level: 
prepare a meal. It is then reﬁ ned until each step in the solution is explicit and in the 
correct sequence, e.g., peel and slice the onions, then brown in a frying pan before 
adding the beef. One drawback to this approach is that it is very difﬁ cult to teach to 
beginners because they rarely have any idea of what primitive tools they have at 
their disposal. Another drawback is that they often get the sequencing wrong, e.g., 
now place in a moderately hot oven is frustrating because you may not have lit the 
oven (sequencing problem) and secondly because you may have no idea how hot 
moderately hot really is. However, as more and more problems are tackled, 
top-down becomes one of the most effective methods for programming. 
 2.5.2  Bottom-Up 
 Bottom-up is the reverse to top-down! As before you start by deﬁ ning the problem 
at a high level, e.g., prepare a meal. However, now there is an examination of what 
tools, etc. you have available to solve the problem. This method lends itself to teach-
ing since a repertoire of tools can be built up and more complicated problems can 
be tackled. Thinking back to the recipe there is not much point in trying to cook a 
six course meal if the only thing that you can do is boil an egg and open a tin of 
beans. The bottom-up approach thus has advantages for the beginner. However, 
there may be a problem when no suitable tool is available. A colleague and friend 
of the authors learned how to make Bechamel sauce, and was so pleased by his suc-
cess that every other meal had a course with a Bechamel sauce. Try it on your eggs 
one morning. Here is a case of specifying a problem, prepare a meal, and using an 
inappropriate but plausible tool, Bechamel sauce. 
 The effort involved in tackling a realistic problem, introducing the constructs as 
and when they are needed and solving it is considerable. This approach may not 
lead to a reasonably comprehensive coverage of the language, or be particularly 
useful from a teaching point of view. Case studies do have great value, but it helps 
if you know the elementary rules before you start on them. Imagine learning French 
by studying Balzac, before you even look at a French grammar book. You can learn 
this way but even when you have ﬁ nished, you may not be able to speak to a 

13
2.8 Systems Analysis and Design
Frenchman and be understood. A good example of the case study approach is given 
in the book Software Tools, by Kernighan and Plauger. 
 In this book our aim is to gradually introduce more and more tools until you 
know enough to approach the problem using the top-down method, and also realise 
from time to time that it will be necessary to develop some new tools. 
 2.5.3  Stepwise Reﬁ nement 
 Both of the above techniques can be combined with what is called stepwise reﬁ nement. 
The original ideas behind this approach are well expressed in a paper by Wirth, entitled 
“program Development by Stepwise Reﬁ nement”, published in 1971. It means that 
you start with a global problem statement and break the problem down in stages, into 
smaller and smaller subproblems that become more and more amenable to solution. 
When you ﬁ rst start programming the problems you can solve are quite simple, but as 
your experience grows you will ﬁ nd that you can handle more complex problems. 
 When you think of the way that you solve problems you will probably realise that 
unless the problem is so simple that you can answer it straightaway some thinking and 
pencil and paper work are required. An example that some may be familiar with is 
in practical work in a scientiﬁ c discipline, where coming unprepared to the situation 
can be very frustrating and unrewarding. It is therefore appropriate to look at ways 
of doing analysis and design before using a computer. 
 2.6  Module Programming 
 As the problems we try solving become more complex we need to look at ways of 
managing the construction of programs that comprise many parts. Modula 2 was 
one of the ﬁ rst languages to support this methodology and we will look at modular 
programming in more depth in a subsequent chapter. 
 2.7  Object Oriented Programming 
 There is a class of problems that are best solved by the treatment of the components 
of these problems as objects. We will look at the concepts involved in object 
oriented programming and object oriented languages in the next chapter. 
 2.8  Systems Analysis and Design 
 When one starts programming it is generally not apparent that one needs a method-
ology to follow to become successful as a programmer. This is usually because the 
problems are reasonably simple, and it is not necessary to be explicit about all of the 

14
2 Introduction to Problem Solving
stages one has gone through in arriving at a solution. As the problems become more 
complex it is necessary to become more rigorous and thorough in one’s approach, 
to keep control in the face of the increasing complexity and to avoid making 
mistakes. It is then that the beneﬁ t of systems analysis and design becomes obvious. 
Broadly we have the following stages in systems analysis and design:
 Problem deﬁ nition. 
• 
 Feasibility study and fact ﬁ nding. 
• 
 Analysis. 
• 
 Initial system design. 
• 
 Detailed design. 
• 
 Implementation. 
• 
 Evaluation. 
• 
 Maintenance. 
• 
and each problem we address will entail slightly different time spent in each of these 
stages. Let us look at each stage in more detail. 
 2.8.1  Problem Deﬁ nition 
 Here we are interested in deﬁ ning what the problem really is. We should aim at 
providing some restriction on both the scope of the problem, and the objectives we 
set ourselves. We can use the methods mentioned earlier to help us out. It is essen-
tial that the objectives are:
 Clearly deﬁ ned. 
• 
 Understood and agreed to by all people concerned, when more than one person 
• 
is involved. 
 Realistic. 
• 
 2.8.2  Feasibility Study and Fact Finding 
 Here we look to see if there is a feasible solution. We would try and estimate the cost 
of solving the problem and see if the investment was warranted by the beneﬁ ts, 
i.e., cost-beneﬁ t analysis. 
 2.8.3  Analysis 
 Here we look at what must be done to solve the problem. Note that we are interested 
in ﬁ nding out what we need to do, but that we do not actually do it at this stage. 

15
2.8 Systems Analysis and Design
 2.8.4  Design 
 Once the analysis is complete we know what must be done, and we can proceed to 
the design. We may ﬁ nd there are several alternatives, and we thus examine alternate 
ways in which the problem can be solved. It is here that we use the techniques of 
top-down and bottom-up problem solving, combined with stepwise reﬁ nement to 
generate an algorithm to solve the problem. We are now moving from the logical to 
the physical side of the solution. This stage ends with a choice among several alter-
natives. Note that there is generally not one ideal solution, but several, each with its 
own advantages and disadvantages. 
 2.8.5  Detailed Design 
 Here we move from the general to the speciﬁ c, The end result of this stage should 
be a speciﬁ cation that is sufﬁ ciently tightly deﬁ ned speciﬁ cation to generate actual 
program code. 
 It is at this stage that it is useful to generate pseudocode. This means writing out 
in detail the actions we want carried out at each stage of our overall algorithm. We 
gradually expand each stage (stepwise reﬁ nement) until it becomes Fortran—or 
whatever language we want. 
 2.8.6  Implementation 
 It is at this stage that we actually use a computer system to create the program(s) that 
will solve the problem. It is here that we actually need to know enough about a pro-
gramming language to use it effectively to solve our problem. This is only one stage in 
the overall process, and mistakes at any of the stages can create serious difﬁ culties.  
 2.8.7  Evaluation and Testing 
 Here we try to see if the program(s) we have produced will actually do what they are 
supposed to. We need to have data sets that enable us to say with conﬁ dence that the 
program really does work. This may not be an easy task, as quite often we only have 
numeric methods to solve the problem, which is why we are using the computer in 
the ﬁ rst place—hence we are relying on the computer to provide the proof; i.e., we 
have to use a computer to determine the veracity of the programs—and as Heller 
says, Catch 22. 

16
2 Introduction to Problem Solving
 2.8.8  Maintenance 
 It is rare that a program is run once and never used again. This means that there will 
be an ongoing task of maintaining the program, generally to make it work with 
different versions of the operating system or compiler, and to incorporate new features 
not included in the original design. It often seems odd when one starts programming 
that a program will need maintenance, as we are reluctant to regard a program in the 
same way as a mechanical object like a car that will eventually fall apart through 
use. Thus maintenance means keeping the program working at some tolerable level, 
often with a high level of investment in manpower and resources. Research in this 
area has shown that anything up to 80% of the manpower investment in a program 
can be in maintenance. 
 2.9  Conclusions 
 A drawback, inherent in all approaches to programming and to problem solving in 
general, is the assumption that a solution is indeed possible. There are problems 
which are simply insoluble—not only problems like balancing a national budget, 
weather forecasting for a year, or predicting which radioactive atom will decay, but 
also problems which are apparently computationally solvable. 
 Knuth gives the example of a chess problem—determining whether the game is 
a forced victory for white. Although there is an algorithm to achieve this, it requires 
an inordinately long time to complete. For practical purposes it is unsolvable. 
 Other problems can be shown mathematically to be undecidable. The work of 
Gödel in this area has been of enormous importance, and the bibliography contains 
a number of references for the more inquisitive and mathematically orientated 
reader. The Hofstader coverage is the easiest, and least mathematical. 
 As far as possible we will restrict ourselves to solvable problems, like learning a 
programming language. 
 Within the formal world of Computer Science our description of an algorithm 
would be considered a little lax. For our introductory needs it is sufﬁ cient, but a 
more rigorous approach is given by Hopcroft and Ullman in Introduction to 
Automata Theory, Languages and Computation, and by Beckman in Mathematical 
Foundations of programming. 
 2.10  Problems 
 1.  What is an algorithm? 
 2.  What distinguishes top-down from bottom-up approaches to problem solving? 
Illustrate your answer with reference to the problem of a car, motor-cycle or 
bicycle having a ﬂ at tire. 

17
2.11 Bibliography
 2.11 Bibliography 
 Aho, A.V., Hopcroft, J.E., Ullman, J.D.: The Design and Analysis of Computer Algorithms, 
Addison-Wesley, Reading (1982) 
 Theoretical coverage of the design and analysis of computer algorithms. 
 Beckman, F.S.: Mathematical Foundations of Programming, Addison-Wesley, Reading (1981) 
Good clear coverage of the theoretical basis of computing. 
 Bulloff, J.J., Holyoke, T.C., Hahn, S.W.: Foundations of mathematics—symposium papers com-
memorating the 60th birthday of Kurt Gödel, Springer-Verlag, Berlin/Heidelberg/New York 
(1969) 
 The comment by John von Neumann highlights the importance of Gödel’s work, Kurt Gödel’s 
achievement in modern logic is singular and monumental—indeed it is more than a monument, 
it is a landmark which will remain visible far in space and time. Whether anything comparable 
to it has occurred in the logic of modern times may be debated. In any case, the conceivable 
proxima are very, very few. The subject of logic has certainly changed its nature and possibili-
ties with Gödel’s achievement. 
 Dahl, O.J., Dijkstra, E.W., Hoare, C.A.R.: Structured Programming, Academic Press, London, 
New York (1972) 
 This is the seminal book on structured programming. 
 Davis, M.: Computability and Unsolvability, Dover, New York (1982) 
 The book is an introduction to the theory of computability and noncomputability—the theory of 
recursive functions in mathematics. Not for the mathematically faint hearted! 
 Davis, W.S.: Systems Analysis and Design, Addison-Wesley, Reading (1983) 
 Good introduction to systems analysis and design, with a variety of case studies. Also looks at 
some of the tools available to the systems analyst. 
 Fogelin, R.J.: Wittgenstein, Routledge and Kegan Paul (1980) 
 The book provides a gentle introduction to the work of the philosopher Wittgenstein, who exam-
ined some of the philosophical problems associated with logic and reason. 
 Gödel, K.: On Formally Undecidable Propositions of Principia Mathematica and Related Systems. 
Oliver and Boyd, New York (1962) 
 An English translation of Gödel’s original paper by Meltzer, with quite a lengthy introduction by 
R.B. Braithwaite, then Knightbridge Professor of Moral Philosophy at Cambridge University, 
England, and classiﬁ ed under philosophy at the library at King’s, rather than mathematics. 
 Hofstadter, D.: The Eternal Golden Braid, Harvester Press, Hassocks (1979) 
 A very readable coverage of paradox and contradiction in art, music and logic, looking at the work 
of Escher, Bach and Gödel, respectively. 
 Hopcroft, J.E., Ullman, J.D.: Introduction to Automata Theory, Languages and Computation. 
Addison-Wesley, Reading (1979) 
 Comprehensive coverage of the theoretical basis of computing. 
 Kernighan, B.W., Plauger, P.J., Software Tools. Addison-Wesley, Reading (1976) 
 Interesting essays on the program development process, originally using a nonstandard variant of 
Fortran. Also available using Pascal. 
 Knuth, D.E.: The Art of Computer Programming, Addison-Wesley, Reading
 vol 1. Fundamental Algorithms (1974) 
 vol 2. Semi-numerical Algorithms (1978) 
 vol 3. Sorting and Searching (1972) contains interesting insights into many aspects of algorithm 
design. Good source of specialist algorithms, and Knuth writes with obvious and infectious 
enthusiasm (and erudition). 
 Millington, D.: Systems Analysis and Design for Computer Applications. Ellis Horwood, 
Chichester (1981) 
 Short and readable introduction to systems analysis and design. 
 Wirth, N.: Program development by stepwise reﬁ nement. Commun. ACM.  14( 4 ) , 221–227 (1971) 
 Clear and simple exposition of the ideas of stepwise reﬁ nement. 

19
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_3, © Springer-Verlag London Limited 2012
 Aims 
 The primary aim of this chapter is to provide a short history of program language 
development and give some idea as to the concepts that have had an impact on 
Fortran. It concentrates on some but not all of the major milestones of the last 
40 years, in roughly chronological order. The secondary aim is to show the breadth 
of languages available. The chapter concludes with coverage of a small number of 
more specialised languages. 
 3.1  Introduction 
 It is important to realise that programming languages are a recent invention. They 
have been developed over a relatively short period—55 years—and are still 
undergoing improvement. Time spent gaining some historical perspective will 
help you understand and evaluate future changes. This chapter starts right at the 
beginning and takes you through some, but not all, of the developments during 
this 55 year span. The bulk of the chapter describes languages that are reasonably 
widely available commercially, and therefore ones that you are likely to meet. 
The chapter concludes with a coverage of some more specialised and/or recent 
developments. 
 Chapter 3 
 Introduction to Programming Languages  
 We have to go to another language in order to think clearly 
about the problem. 
 Samuel R. Delany, Babel-17 

20
3 Introduction to Programming Languages
 3.2  Some Early Theoretical Work 
 Some of the most important early theoretical work in computing was that of Turing 
and von Neumann. Turing’s work provided the base from which it could be shown 
that it was possible to get a machine to solve problems. The work of von Neumann 
added the concept of storage and combined with Turing’s work to provide the basis 
for most computers designed to this day. 
 3.3  What Is a Programming Language? 
 For a large number of people a programming language provides the means of getting a 
digital computer to solve a problem. There is a wide range of problems and an equally 
wide range of programming languages, with particular languages being suited to a 
particular class of problems, all of which often appears bewildering to the beginner.  
 3.4  Program Language Development and Engineering 
 There is much in common between the development of programming languages and 
the development of anything from the engineering world. Consider the car: old cars 
offer much of the same functionality as more modern ones, but most people prefer 
driving newer models. The same is true of programming languages, where you can 
achieve much with the older languages, but the newer ones are easier to use. 
 3.5  The Early Days 
 A concept that proves very useful when discussing programming languages is that of 
the level of a machine. By this is meant how close a language is to the underlying 
machine that the program runs on. In the early days of programming (up to 1954) 
there were only two broad categories: machine languages and assemblers. The lan-
guage that digital machines use is that of 0 and 1, i.e., they are binary devices. Writing 
a program in terms of patterns of 0 and 1 was not particularly satisfactory and the 
capability of using more meaningful mnemonics was soon introduced. Thus it was 
realised quite quickly that one of the most important aspects of programming lan-
guages is that they have to be read and understood by both machines and humans. 
 3.5.1  Fortran’s Origins 
 The next stage was the development of higher-level languages. The ﬁ rst of these was 
Fortran and it was developed over a 3 year period from 1954 to 1957 by an IBM team 

21
3.5 The Early Days
led by John Backus. This group achieved considerable success, and helped to prove 
that the way forward lay with high-level languages for computer-based problem 
solving. Fortran stands for formula translation and was used mainly by people with a 
scientiﬁ c background for solving problems that had a signiﬁ cant arithmetic content. 
It was thus relatively easy, for the time, to express this kind of problem in Fortran. 
 By 1966 and the ﬁ rst standard Fortran:
 Was widely available. 
• 
 Was easy to teach. 
• 
 Had demonstrated the beneﬁ ts of subroutines and independent compilation. 
• 
 Was relatively machine independent. 
• 
 Often had very efﬁ cient implementations. 
• 
 Possibly the single most important fact about Fortran was, and still is, its wide-
spread usage in the scientiﬁ c community. 
 3.5.2  Fortran 77 
 The next standard in 1977 (actually 1978, and thus out by one—a very common 
programming error, more of this later!) added character handling, but little else in 
the way of major new features, really tidying up some of the deﬁ ciencies of the 1966 
standard. One important feature sometimes overlooked was backwards compatibil-
ity. This meant that the standard did not invalidate any standard conformant Fortran 
66 program. This protected investment in old code. 
 3.5.3  Cobol 
 The business world also realised that computers were useful and several languages 
were developed, including FLOWMATIC, AIMACO, Commercial Translator and 
FACT, leading eventually to Cobol—common Business Orientated Language. There 
is a need in commercial programming to describe data in a much more complex 
fashion than for scientiﬁ c programming, and Cobol had far greater capability in this 
area than Fortran. The language was unique at the time in that a group of competi-
tors worked together with the objective of developing a language that would be 
useful on machines used by other manufacturers. 
 The contributions made by Cobol include:
 Firstly the separation among:
• 
 The task to be undertaken. 
 –
 The description of the data involved. 
 –
 The working environment in which the task is carried out. 
 –
 Secondly a data description mechanism that was largely machine independent. 
• 
 Thirdly its effectiveness for handling large ﬁ les. 
• 
 Fourthly the beneﬁ t to be gained from a programming language that was easy to read.    
• 

22
3 Introduction to Programming Languages
 Modern developments in computing—of report generators, ﬁ le-handling soft-
ware, fourth-generation development tools, and especially the increasing availabil-
ity of commercial relational database management systems—are gradually replacing 
the use of Cobol, except where high efﬁ ciency and/or tight control are required. 
 3.5.4  Algol 
 Another important development of the 1950s was Algol. It had a history of develop-
ment from Algol 58, the original Algol language, through Algol 60 eventually to the 
Revised Algol 60 Report. Some of the design criteria for Algol 58 were:
 The language should be as close as possible to standard mathematical notation 
• 
and should be readable with little further explanation. 
 It should be possible to use it for the description of computing processes in 
• 
publications. 
 The new language should be mechanically translatable into machine programs. 
• 
 A sad feature of Algol 58 was the lack of any input/output facilities, and this 
meant that different implementations often had incompatible features in this area. 
 The next important step for Algol occurred at a UNESCO-sponsored conference 
in June 1959. There was an open discussion on Algol and the outcome was Algol 
60, and eventually the Revised Algol 60 Report. 
 It was at this conference that John Backus gave his now famous paper on a 
method for deﬁ ning the syntax of a language, called Backus Normal Form, or BNF. 
The full signiﬁ cance of the paper was not immediately recognised. However, BNF 
was to prove of enormous value in language deﬁ nition, and helped provide an inter-
face point with computational linguistics. 
 The contributions of Algol to program language development include:
 block structure. 
• 
 Scope rules for variables because of block structure. 
• 
 The BNF deﬁ nition by Backus—most languages now have a formal deﬁ nition. 
• 
 The support of recursion. 
• 
 Its offspring. 
• 
 Thus Algol was to prove to make a contribution to programming languages that 
was never reﬂ ected in the use of Algol 60 itself, in that it has been the parent of one 
of the main strands of program language development. 
 3.6  Chomsky and Program Language Development 
 Programming languages are of considerable linguistic interest, and the work of 
Chomsky in 1956 in this area was to prove of inestimable value. Chomsky’s system 
of transformational grammar was developed in order to give a precise mathematical 

23
3.8 Snobol
description to certain aspects of language. Simplistically, Chomsky describes gram-
mars, and these grammars in turn can be used to deﬁ ne or generate corresponding 
kinds of languages. It can be shown that for each type of grammar and language 
there is a corresponding type of machine. It was quickly realised that there was a 
link with the earlier work of Turing. 
 This link helped provide a ﬁ rm scientiﬁ c base for programming language devel-
opment, and modern compiler writing has come a long way from the early work of 
Backus and his team at IBM. It may seem unimportant when playing a video game 
at home or in an arcade, but for some it is very comforting that there is a ﬁ rm theo-
retical basis behind all that fun. 
 3.7  Lisp 
 There were also developments in very specialized areas. List processing was 
proving to be of great interest in the 1950s and saw the development of IPLV 
between 1954 and 1958. This in turn led to the development of Lisp at the end of 
the 1950s. Lisp has proved to be of considerable use for programming in the 
areas of artiﬁ cial intelligence, playing chess, automatic theorem proving and 
general problem solving. It was one of the ﬁ rst languages to be interpreted rather 
than compiled. Whilst interpreted languages are invariably slower and less efﬁ -
cient in their use of the underlying computer systems than compiled languages, 
they do provide great opportunities for the user to explore and try out ideas whilst 
sitting at a terminal. The power that this gives to the computational problem 
solver is considerable. 
 Possibly the greatest contribution to program language development made by 
Lisp was its functional notation. One of the major problems for the Lisp user has 
been the large number of Lisp ﬂ avours, and this has reduced the impact that the 
language has had and deserved. 
 3.8  Snobol 
 Snobol was developed to aid in string processing, which was seen as an important 
part of many computing tasks, e.g., parsing of a program. Probably the most impor-
tant thing that Snobol demonstrated was the power of pattern matching in a pro-
gramming language, e.g., it is possible to deﬁ ne a pattern for a title that would 
include Mr, Mrs, Ms, Miss, Rev, etc., and search for this pattern in a text using 
Snobol. Like Lisp it is generally available as an interpreter rather than a compiler, 
but compiled versions do exist, and are often called Spitbol. Pattern-matching capa-
bilities are now to be found in many editors and this makes them very powerful and 
useful tools. It is in the area of text manipulation that Snobol’s greatest contribution 
to program language development lies. 

24
3 Introduction to Programming Languages
 3.9  Second-Generation Languages 
 3.9.1  PL/1 and Algol 68 
 It is probably true that Fortran, Algol 60 and Cobol are the three main ﬁ rst-generation 
high-level languages. The 1960s saw the emergence of PL/1 and Algol 68. PL/1 was 
a synthesis of features of Fortran, Algol 60 and Cobol. It was soon realised that 
whilst PL/1 had great richness and power of expression this was in some ways offset 
by the greater difﬁ culties involved in language deﬁ nition and use. 
 These latter problems were also true of Algol 68. The report introduced its own 
syntactic and semantic conventions and thus forced another stage in the learning 
process on the prospective user. However, it has a small but very committed user 
population who like the very rich facilities provided by the language. 
 3.9.2  Simula 
 Another strand that makes up program language development is provided by Simula, 
a general purpose programming language developed by Dahl, Myhrhaug and 
Nygaard of the Norwegian Computing Centre. The most important contribution that 
Simula makes is the provision of language constructs that aid the programming of 
complex, highly interactive problems. It is thus heavily used in the areas of simulation 
and modelling. It was effectively the ﬁ rst language to offer the opportunity of object 
orientated programming, and we will come back to this very important development 
in programming languages later in this chapter. 
 3.9.3  Pascal 
 The designer of Pascal, Niklaus Wirth, had participated in the early stages of the 
design of Algol 68 but considered that the generality and complexity of Algol 68 
was a move in the wrong direction. Pascal (like Algol 68) had its roots in Algol 60 
but aimed at providing expressive power through a small set of straightforward 
concepts. This set is relatively easy to learn and helps in producing readable and 
hence more comprehensible programs. 
 It became the language of ﬁ rst choice within the ﬁ eld of computer science during 
the 1970s and 1980s, and the comment by Wirth sums up the language very well: 
“although Pascal had no support from industry, professional societies, or govern-
ment agencies, it became widely used. The important reason for this success was 
that many people capable of recognising its potential actively engaged themselves 
in its promotion. As crucial as the existence of good implementations is the avail-
ability of documentation. The conciseness of the original report made it attractive 
for many teachers to expand it into valuable textbooks. Innumerable books appeared 

25
3.9 Second-Generation Languages
between 1977 and 1985, effectively promoting Pascal to become the most wide-
spread language used in introductory programming courses. Good course material 
and implementations are the indispensable prerequisites for such an evolution.” 
 3.9.4  APL 
 APL is another interesting language of the early 1960s. It was developed by Iverson 
early in the decade and was available by the mid to late 1960s. It is an interpretive 
vector and matrix based language with an extensive set of operators for the manipu-
lation of vectors, arrays, etc., of whatever data type. As with Algol 68 it has a small 
but dedicated user population. A possibly unfair comment about APL programs is 
that you do not debug them, but rewrite them! 
 3.9.5  Basic 
 Basic stands for Beginners All Purpose Symbolic Instruction Code, and was devel-
oped by Kemeny and Kurtz at Dartmouth during the 1960s. Its name gives a clue to 
its audience and it is very easy to learn. It is generally interpreted, though compiled 
versions do exist. It has proved to be well suited to the rapid development of small 
programs. It is much criticised because it lacks features that encourage or force the 
adoption of sound programming techniques. 
 3.9.6  C 
 There is a requirement in computing to be able to access the underlying machine 
directly or at least efﬁ ciently. It is therefore not surprising that computer profession-
als have developed high-level languages to do this. This may well seem a contradic-
tion, but it can be done to quite a surprising degree. Some of the earliest published 
work was that of Martin Richards on the development of BCPL. 
 This language directly inﬂ uenced the work of Ken Thompson and can be clearly 
seen in the programming languages B and C. The UNIX operating system is almost 
totally written in C and demonstrates very clearly the beneﬁ ts of the use of high-
level languages wherever possible. 
 With the widespread use of UNIX within the academic world C gained considerable 
ground during the 1970s and 1980s. UNIX systems also offered much to the profes-
sional software developer, and became widely used for large-scale software develop-
ment and as Ritchie says: “C is quirky, ﬂ awed, and an enormous success. While 
accidents of history surely helped, it evidently satisﬁ ed a need for a system implemen-
tation language efﬁ cient enough to displace assembly language, yet sufﬁ ciently abstract 
and ﬂ uent to describe algorithms and interactions in a wide variety of environments.”  

26
3 Introduction to Programming Languages
 3.10  Some Other Strands in Language Development 
 There are many strands that make up program language development and some of 
them are introduced here. 
 3.10.1  Abstraction, Stepwise Reﬁ nement and Modules 
 Abstraction has proved to be very important in programming. It enables a complex 
task to be broken down into smaller parts concentrating on what we want to happen 
rather than how we want it to happen. This leads almost automatically to the ideas 
of stepwise reﬁ nement and modules, with collections of modules to perform spe-
ciﬁ c tasks or steps. 
 3.10.2  Structured Programming 
 Structured programming in its narrowest sense concerns itself with the development 
of programs using a small but sufﬁ cient set of statements and, in particular, control 
statements. It has had a great effect on program language design, and most lan-
guages now support the minimal set of control structures. 
 In a broader sense structured programming subsumes other objectives, including 
simplicity, comprehensibility, veriﬁ ability, modiﬁ ability and maintenance of programs. 
 3.10.3  Data Structuring and Procedural Programming 
 By the 1970s languages started to emerge that offered the ability to organise data 
logically—so called data structuring, and we will look at two of these in the cover-
age below—C and Pascal. 
 C provided this facility via structs and Pascal did it via records. These languages 
also offered two ways of processing the data—directly or via procedures. The terms 
concrete and abstract data type are sometimes also used in the literature. 
 An example may help here. Consider a date. This is typically made up of three 
components, a day, a month and a year. In C we can create a user deﬁ ned type called 
a date using structs. We can then create variables of this type. This is done in Pascal 
in a similar way using records. 
 Access to the components of a date (day, month and year) can then either be 
direct—an example of a concrete data type, or indirect (via procedures)—an abstract 
data type. 
 Simplistically direct access (or concrete data types) offer the beneﬁ t of efﬁ ciency, 
and the possibility of lack of data integrity. In our date example we may set a day to 
the value 31 when the month is February. 

27
3.11 Ada
 Indirect access (or abstract data types) are slightly less efﬁ cient as we now have 
the overhead of a procedure call to access the data, but better opportunity for data 
integrity as we can provide hidden code within the procedures to ensure that the day, 
month and year combinations are valid. 
 Fortran did not provide this facility until the Fortran 90 standard. 
 3.10.4  Standardisation 
 The purposes of a standard are quite varied and include:
 Investment in people: by this we mean that the time spent in learning a standard 
• 
language pays off in the long term, as what one learns is applicable on any hard-
ware/software platform that has a standard conformant compiler. 
 Portability: one can take the code one has written for one hardware/software 
• 
platform and move it to any hardware/software platform that has a standard con-
formant compiler. 
 Known reference point: when making comparisons one starts with reference to 
• 
the standard ﬁ rst, and then between the additional functionality of the various 
implementations 
 These are some but not all of the reasons for the use of standards. Their impor-
tance is summed up beautifully by Ronald G. Ross in his introduction to the Cannan 
and Otten book on the SQL standard: “Anybody who has ever plugged in an electric 
cord into a wall outlet can readily appreciate the inestimable beneﬁ ts of workable 
standards. Indeed, with respect to electrical power, the very fact that we seldom 
even think about such access (until something goes wrong) is a sure sign of just how 
fundamentally important a successful standard can be.” 
 3.11  Ada 
 Ada represents the culmination of many years of work in program language devel-
opment. It was a collective effort and the main aim was to produce a language suit-
able for programming large-scale and real-time systems. Work started in 1974 with 
the formulation of a series of documents by the American Department of Defence 
(DoD), which led to the Steelman documents. It is a modern algorithmic language 
with the usual control structures and facilities for the use of modules, and allows 
separate compilation with type checking across modules. 
 Ada is a powerful and well-engineered language. Its widespread use is certain as 
it has the backing of the DoD. However, it is a large and complex language and 
consequently requires some effort to learn. It seems unlikely to be widely used 
except by a small number of computer professionals. 

28
3 Introduction to Programming Languages
 3.12  Modula 
 Modula was designed by Wirth during the 1970s at ETH, for the programming of 
embedded real-time systems. It has many of the features of Pascal, and can be taken 
for Pascal at a glance. The key new features that Modula introduced were those of 
processes and monitors. 
 As with Pascal it is relatively easy to learn and this makes it much more attractive 
than Ada for most people, achieving much of the capability without the complexity.  
 3.13  Modula 2 
 Wirth carried on developing his ideas about programming languages and the culmi-
nation of this can be seen in Modula 2. In his words: “In 1977, a research project 
with the goal to design a computer system (hardware and software) in an integrated 
approach, was launched at the Institut fur Informatik of ETH Zurich. This system 
(later to be called Lilith) was to be programmed in a single high level language, 
which therefore had to satisfy requirements of high level system design as well as 
those of low level programming of parts that closely interact with the given hard-
ware. Modula 2 emerged from careful design deliberations as a language that 
includes all aspects of Pascal and extends them with the important module concept 
and those of multi-programming. Since its syntax was more in line with Modula 
than Pascal’s the chosen name was Modula 2.” 
 The language’s main additions with regard to Pascal are:
 The module concept, and in particular the facility to split a module into a 
• 
deﬁ nition part and an implementation part. 
 A more systematic syntax which facilitates the learning process. In particular, 
• 
every structure starting with a keyword also ends with a keyword, i.e., is properly 
bracketed. 
 The concept of process as the key to multiprogramming facilities. 
• 
 So-called low-level facilities, which make it possible to breach the rigid type 
• 
consistency rules and allow one to map data with Modula 2 structure onto a store 
without inherent structure. 
 The procedure type, which allows procedures to be dynamically assigned to 
• 
variables. 
 A sad feature of Modula 2 has been the long time taken to arrive at a standard for 
the language. 
 3.14  Other Language Developments 
 The following is a small selection of language developments that the authors ﬁ nd 
interesting—they may well not be included in other people’s coverage. 

29
3.14 Other Language Developments
 3.14.1  Logo 
 Logo is a language that was developed by Papert and colleagues at the Artiﬁ cial 
Intelligence Laboratory at MIT. Papert is a professor of both mathematics and edu-
cation, and has been much inﬂ uenced by the psychologist Piaget. The language is used 
to create learning environments in which children can communicate with a computer. 
The language is primarily used to demonstrate and help children develop fundamental 
concepts of mathematics. Probably the turtle and turtle geometry are known by educa-
tionists outside of the context of Logo. Turtles have been incorporated into the Smalltalk 
computer system developed at Xerox Palo Alto Research Centre—Xerox PARC.  
 3.14.2  Postscript, TeX and LaTeX 
 The 1980s saw a rapid spread in the use of computers for the production of printed 
material. The 3 languages are each used quite extensively in this area. 
 Postscript is a low-level interpretive programming language with good graphics 
capabilities. Its primary purpose is to enable the easy production of pages containing 
text, graphical shapes and images. It is rarely seen by most end users of modern 
desktop publishing systems, but underlies many of these systems. It is supported by 
an increasing number of laser printers and typesetters. 
 TeX is a language designed for the production of mathematical texts, and was 
developed by Donald Knuth. It linearises the production of mathematics using a 
standard computer keyboard. It is widely used in the scientiﬁ c community for the 
production of documents involving mathematical equations. 
 LaTex is Leslie Lamport’s version of TeX, and is regarded by many as more 
friendly. It is basically a set of macros that hide raw TeX from the end user. The 
TeX/LaTeX ratio is probably 1–9 (or so I’m reliably informed by a TeXie). 
 3.14.3  Prolog 
 Prolog was originally developed at Marseille by a group led by Colmerauer in 1972/73. 
It has since been extended and developed by several people, including Pereira (L.M.), 
Pereira (F), Warren and Kowalski. Prolog is unusual in that it is a vehicle for logic pro-
gramming. Most of the languages described here are basically algorithmic languages 
and require a speciﬁ cation of how you want something done. Logic programming con-
centrates on the what rather than the how. The language appears strange at ﬁ rst, but has 
been taught by Kowalski and others to 10-year-old children at schools in London.  
 3.14.4  SQL 
 SQL stands for Structured Query Language, and was originally developed by people 
mainly working for IBM in the San Jose Research Laboratory. It is a relational 

30
3 Introduction to Programming Languages
database language, and enables programmers to deﬁ ne, manipulate and control 
data in a relational database. Simplistically, a relational database is seen by a user 
as a collection of tables, comprising rows and columns. It has become the most 
important language in the whole database ﬁ eld. 
 3.14.5  ICON 
 ICON is in the same family as Snobol, and is a high-level general purpose pro-
gramming language that has most of the features necessary for efﬁ cient processing 
of nonnumeric data. Griswold (one of the original design team for Snobol) has 
learnt much since the design and implementation of Snobol, and the language is a 
joy to use in most areas of text manipulation. 
 It is available for most systems via anonymous FTP from a number of sites on the 
Internet. 
 3.15  Object Oriented Programming 
 Object oriented represents a major advance in program language development. The 
concepts that this introduces include:
 Classes. 
• 
 Objects. 
• 
 Messages. 
• 
 Methods. 
• 
 These in turn draw on the ideas found in more conventional programming 
languages and correspond to
 Extensible data types. 
• 
 Instances of a class. 
• 
 Dynamically bound procedure calls. 
• 
 Procedures of a class. 
• 
 Inheritance is a very powerful high-level concept introduced with object oriented 
• 
programming. It enables an existing data type with its range of valid operations 
to form the basis for a new class, with more data types added with corresponding 
operations, and the new type is compatible with the original. 
 Fortran 2003 offered support for object oriented programming. This is achieved 
via the module facility rather than the class facility found in other languages like 
C++, Java and C#. 

31
3.15 Object Oriented Programming
 3.15.1  Simula 
 As was mentioned earlier, the ﬁ rst language to offer functionality in this area was 
Simula, and thus the ideas originated in the 1960s. The book Simula Begin by 
Birtwistle, Dahl, Myhrhaug and Nygaard is well worth a read as it represents one of 
the ﬁ rst books to introduce the concepts of object oriented programming. 
 3.15.2  Smalltalk 
 Language plus use of a computer system. 
 Smalltalk has been under development by the Xerox PARC Learning Research 
Group since the 1970s. In their words: “Smalltalk is a graphical, interactive pro-
gramming environment. As suggested by the personal computer vision, Smalltalk is 
designed so that every component in the system is accessible to the user and can be 
presented in a meaningful way for observation and manipulation. The user interface 
issues in Smalltalk revolve around the attempt to create a visual language for each 
object. The preferred hardware system for Smalltalk includes a high resolution 
graphical display screen and a pointing device such as a graphics pen or mouse. 
With these devices the user can select information viewed on the screen and invoke 
messages in order to interact with the information.” Thus Smalltalk represents a 
very different strand in program language development. The ease of use of a system 
like this has long been appreciated and was ﬁ rst demonstrated commercially in the 
Macintosh microcomputers. 
 Wirth has spent some time at Xerox PARC and has been inﬂ uenced by their 
work. In his own words “the most elating sensation was that after 16 years of work-
ing for computers the computer now seemed to work for me.” This inﬂ uence can be 
seen in the design of the Lilith machine, the original Modula 2 engine, and in the 
development of Oberon as both a language and an operating system. 
 3.15.3  Oberon and Oberon 2 
 As Wirth says: “The programming language Oberon is the result of a concentrated 
effort to increase the power of Modula-2 and simultaneously to reduce its complex-
ity. Several features were eliminated, and a few were added in order to increase the 
expressive power and ﬂ exibility of the language.” 
 Oberon and Oberon 2 are thus developments beyond Modula 2. The main new 
concept added to Oberon was that of type extension. This enables the construction 
of new data types based on existing types and allows one to take advantage of what 
has already been done for that existing type. 

32
3 Introduction to Programming Languages
 Language constructs removed included:
 Variant records. 
• 
 Opaque types. 
• 
 Enumeration types. 
• 
 Subrange types. 
• 
 Local modules. 
• 
 WITH statement. 
• 
 type transfer functions. 
• 
 Concurrency. 
• 
 The short paper by Wirth provides a fuller coverage. It is available at ETH via 
anonymous FTP. 
 3.15.4  Eiffel 
 Eiffel was originally developed by Interactive Software Engineering Inc. (ISE) 
founded by Bertrand Meyer. Meyer’s book Object-Oriented Software Construction 
contains a detailed treatment of the concepts and theory of the object technology 
that led to Eiffel’s design. 
 The language ﬁ rst became available in 1986, and the ﬁ rst edition of Meyer’s 
book was published in 1988. The following is a quote from the Wikipedia entry. 
 The design goal behind the Eiffel language, libraries, and programming methods 
is to enable programmers to create reliable, reusable software modules. Eiffel sup-
ports multiple inheritance, genericity, polymorphism, encapsulation, type-safe con-
versions, and parameter covariance. Eiffel’s most important contribution to software 
engineering is design by contract (DbC), in which assertions, preconditions, post-
conditions, and class invariants are employed to help ensure program correctness 
without sacriﬁ cing efﬁ ciency. 
 3.15.5  C++ 
 Stroustrup did his Ph.D thesis at the Computing Laboratory, Cambridge University, 
England, and worked with Simula. He had previously worked with Simula at the 
University of Aarhus in Denmark. His comments are illuminating: “but was pleas-
antly surprised by the way the mechanisms of the Simula language became increas-
ingly helpful as the size of the program increased. The class and co-routine 
mechanisms of Simula and the comprehensive type checking mechanisms ensured 
that problems and errors did not (as I—and I guess most people—would have 
expected) grow linearly with the size of the program. Instead, the total program 
acted like a collection of very small (and therefore easy to write, comprehend and 
debug) programs rather than a single large program.” 

33
3.15 Object Oriented Programming
 He designed C++ to provide Simula’s functionality within the framework of C’s 
efﬁ ciency, and he succeeded in this goal as C++ is a widely used object oriented 
programming language. The major disadvantage now concerns the largely incom-
patible class libraries that exist. It is hoped that the various standards bodies address 
this problem in the immediate future. 
 3.15.6  Java 
 Bill Joy (of Sun fame) had by the late 1980s decided that C++ was too complicated and 
that an object oriented environment based upon C++ would be of use. At around about 
the same time James Gosling (mister emacs) was starting to get frustrated with the imple-
mentation of an SGML editor in C++. Oak was the outcome of Gosling’s frustration. 
 Sun over the next few years ended up developing Oak for a variety of projects. It 
wasn’t until Sun developed their own web browser, Hotjava, that Java as a language 
hit the streets. And as the saying goes  the rest is history. 
 Java is a relatively simple object oriented language. Whilst it has its origins in 
C++ it has dispensed with most of the dangerous features. It is OO throughout. 
Everything is a class. 
 It is interpreted and the intermediate byte code will run on any machine that has 
a Java virtual machine for it. This is portability at the object code level, unlike 
portability at the source code level—which is what we expect with most conven-
tional languages. Some of the safe features of the language include:
 Built in garbage collection. 
• 
 No pointers—everything is passed by reference. 
• 
 It is multithreaded, which makes it a delight for many applications. It has an 
extensive windows toolkit, the so called AWT that was in the original release of the 
language and Swing that came in later. 
 It is under continual development and at the time of writing was in its seventh 
major release. 
 3.15.7  C# 
 C# is a new language from Microsoft and is a key part of their .net framework. It is 
a modern, well-engineered language in the same family of programming languages 
in terms of syntax as C, C++ and Java. If you have a knowledge of one of these 
languages it will look very familiar. 
 One of the design goals was to produce a component oriented language, and to 
build on the work that Microsoft had done with OLE, ActiveX and COM:
 ActiveX is a set of technologies that enables software components to interact with 
• 
one another in a networked environment, regardless of the language in which they 
were created. ActiveX was built on the Component Object Model (COM).  

34
3 Introduction to Programming Languages
 COM is the object model on which ActiveX Controls and OLE are built. COM 
• 
allows an object to expose its functionality to other components and to host 
applications. It deﬁ nes both how the object exposes itself and how this 
exposure works across processes and networks. COM also deﬁ nes the object’s 
life cycle.  
 OLE is a mechanism that allows users to create and edit documents containing 
• 
items or objects created by multiple applications. OLE was originally an acro-
nym for Object Linking and Embedding. However, it is now referred to simply 
as OLE. Parts of OLE not related to linking and embedding are now part of 
Active technology. 
 Other design goals included creating a language:
 where everything is an object—C# also has a mechanism for going between 
• 
objects and fundamental types (integers, reals, etc.). 
 Which would enable the construction of robust and reliable software—it has 
• 
garbage collection, exception handling and type safety. 
 Which would use a C/C++/Java syntax which is already widely known and thus 
• 
help programmers converting from one of these languages to C#. 
 It has been updated three times since its original release. Some of the more 
important features added in C# 2 were Generics, Iterators, Partial Classes, Nullable 
Types and Static Classes. The major feature that C# 3 added for most people was 
LINQ, a mechanism for data querying. C# 4 was released in 2010 and added a 
number of additional features. 
 3.16  Back to Fortran! 
 We ﬁ nish off with a coverage of the developments since the Fortran 77 standard. 
Practically all of the Fortran compilers available today support the Fortran 90 and 
95 standards. Many also support several features of the 2003 standard, and some 
also implement one or more features from the Fortran 2008 standard. See the fol-
lowing document
 http://www.fortranplus.co.uk/resources/fortran_2003_2008_
compiler_support.pdf   
for up to date information on what each compiler offers in terms of standard support. 
 3.16.1  Fortran 90 
 Almost as soon as the Fortran 77 standard was complete and published, work began 
on the next version. The language drew on many of the ideas covered in this chapter 

35
3.16 Back to Fortran!
and these help to make Fortran 90 a very promising language. Some of the new 
features included:
 New source form, with blanks being signiﬁ cant and names being up to 31 
• 
characters. 
 Implicit none 
• 
 Better control structures. 
• 
 Control of the precision of numerical computation. 
• 
 Array processing. 
• 
 Pointers. 
• 
 User deﬁ ned data types and operators. 
• 
 Procedures. 
• 
 Modules. 
• 
 Recursion. 
• 
 Dynamic storage allocation. 
• 
 This was the major update that the Fortran community had been waiting a long 
time for. Backwards compatibility was again a key aim. This standard did not invali-
date any standard conformant Fortran 77 program. 
 3.16.2  Fortran 95 
 Fortran was next standardised in 1996—yet again out by one! Firstly we have a 
clear up of some of the areas in the standard that had emerged as requiring clariﬁ ca-
tion. Secondly Fortran 95 added the following major concepts:
 The forall construct. 
• 
 pure and elemental procedures. 
• 
 implicit initialisation of derived-type objects. 
• 
 Initial association status for pointers. 
• 
 The ﬁ rst two help considerably in parallelization of code. Minor features include 
amongst others:
 Automatic deallocation of allocatable arrays. 
• 
 intrinsic SIGN function distinguishes between −0 and +0. 
• 
 intrinsic function NULL returns disconnected pointer. 
• 
 intrinsic function CPU_TIME returns the processor time. 
• 
 References to some pure functions are allowed in speciﬁ cation statements. 
• 
 Nested where constructs. 
• 
 Masked elsewhere construct. 
• 
 Small changes to the CEILING, FLOOR, MAXLOC and MINLOC intrinsic 
• 
functions. 
 Some of these were added to keep Fortran in line with High Performance Fortran 
(HPF). More details are given later. 

36
3 Introduction to Programming Languages
 Part 2 of the standard (ISO/IEC 1539–2:1994) adds the functional speciﬁ cation 
for varying length character data type, and this extends the usefulness of Fortran for 
character applications very considerably. 
 3.16.3  ISO Technical Reports TR15580 and TR15581 
 There are two additional reports that have been published on Fortran. TR 15580 
speciﬁ es three modules that provide access to IEEE ﬂ oating point arithmetic and 
TR15581 allows the use of the allocatable attribute on dummy arguments, function 
results and structure components. 
 3.16.4  Fortran 2003 
 The language is known as Fortran 2003 even though the language did not make it 
through the standardisation process until 2004. It was a major revision.
 Derived-type enhancements: parameterised derived types (allows the kind, 
• 
length, or shape of a derived type’s components to be chosen when the derived 
type is used), mixed component accessibility (allows different components to 
have different accessibility), public entities of private type, improved structure 
constructors, and ﬁ nalisers. 
 Object oriented programming support: enhanced data abstraction (allows one 
• 
type to extend the deﬁ nition of another type), polymorphism (allows the type of 
a variable to vary at run time), dynamic type allocation, select type construct 
(allows a choice of execution ﬂ ow depending upon the type a polymorphic object 
currently has), and type-bound procedures. 
 The associate construct (allows a complex expression or object to be denoted by 
• 
a simple symbol). 
 Data manipulation enhancements: allocatable components, deferred-type param-
• 
eters, volatile attribute, explicit type speciﬁ cation in array constructors, intent 
speciﬁ cation of pointer arguments, speciﬁ ed lower bounds of pointer assignment 
and pointer rank remapping, extended initialisation expressions, MAX and MIN 
intrinsics for character type, and enhanced complex constants. 
 Input/output enhancements: asynchronous transfer operations (allow a program to 
• 
continue to process data while an input/output transfer occurs), stream access 
(allows access to a ﬁ le without reference to any record structure), user speciﬁ ed 
transfer operations for derived types, user speciﬁ ed control of rounding during 
format conversions, the ﬂ ush statement, named constants for preconnected units, 
regularisation of input/output keywords, and access to input/output error messages.  
 Procedure pointers. 
• 
 Scoping enhancements: the ability to rename deﬁ ned operators (supports greater 
• 
data abstraction) and control of host association into interface bodies. 
 Support for IEC 60559 (IEEE 754) exceptions and arithmetic (to the extent a 
• 
processor’s arithmetic supports the IEC standard). 

37
3.16 Back to Fortran!
 Interoperability with the C programming language (allows portable access to 
• 
many libraries and the low-level facilities provided by C and allows the portable 
use of Fortran libraries by programs written in C). 
 Support for international usage: (ISO 10646) and choice of decimal or comma in 
• 
numeric formatted input/output. 
 Enhanced integration with the host operating system: access to command line 
• 
arguments and environment variables and access to the processor’s error mes-
sages (improves the ability to handle exceptional conditions). 
 The earlier web address has details of Fortran compiler conformance to this 
standard. 
 3.16.5  DTR 19767 Enhanced Module Facilities 
 The module system in Fortran has a number of shortcomings and this DTR addresses 
some of the issues. 
 One of the major issues was the so-called recompilation cascade. Changes to one 
part of a module forced recompilation of all code that used the module. Modula 2 
addressed this issue by distinguishing between the deﬁ nition or interface and imple-
mentation. This can now be achieved in Fortran via submodules. 
 3.16.6  Fortran 2008 
 The most recent standard, ISO/IEC 1539–1:2010, commonly known as Fortran 
2008, was approved in September 2010. The new features include:
 Submodules—Additional structuring facilities for modules; supersedes ISO/IEC 
• 
TR 19767:2005 
 Coarray Fortran—a parallel execution model 
• 
 The DO CONCURRENT construct—for loop iterations with no interdependencies  
• 
 The CONTIGUOUS attribute—to specify storage layout restrictions 
• 
 The BLOCK construct—can contain declarations of objects with construct scope  
• 
 Recursive allocatable components—as an alternative to recursive pointers in 
• 
derived types. 
 A more thorough coverage can be found in John Reid’s paper.
  ftp://ftp.nag.co.uk/sc22wg5/N1801-N1850/N1828.pdf  
 3.16.7  The Future 
 The two main work items for WG5 and J3 are shown below. The information is taken 
from the agenda from the Garching meeting—June 27—July 1, 2011 Leibniz 
Supercomputing Centre (LRZ), Boltzmannstr. 1 85748 Garching/Munich, Germany.

38
3 Introduction to Programming Languages
 Review the PDTR Ballot comments on the draft TR on Further Interoperability 
• 
with C, decide on changes, and construct a response document. 
 Consider the technical content of the proposed TR on Further Coarray Features. 
• 
 There is also an effective permanent work item:
 Consider the Fortran defect reports (interpretations) in J3-006. 
• 
 3.17  Internet Resources 
 The Internet provides access to a wealth of information regarding the Fortran family 
of languages. 
 3.17.1  Standards Information 
 The ofﬁ cial home of the standard is
 
• http://www.nag.co.uk/sc22wg5/ 
 We recommend visiting the site to keep up to date with Fortran developments. Their 
ofﬁ cial ftp server can be found at
 
• ftp://ftp.nag.co.uk/sc22wg5/ 
 Copies of all working documents can be found there. 
 3.17.2  Fortran Discussion Lists 
 The ﬁ rst to look at is the Fortran 90 list. Details can be found at
 
• http://www.jiscmail.ac.uk/lists/COMP-FORTRAN-90.html 
 if you subscribe you will have access to people involved in Fortran standardisation, 
language implementors for most of the hardware and software platforms, people 
using Fortran in many very specialised areas, people teaching Fortran, etc. 
 There is also a comp.lang.fortran list available via USENET news. This provides 
access to people worldwide with enormous combined expertise in all aspects of 
Fortran. Invariably someone will have encountered your problem or one very much 
like it and have one or more solutions. 
 There are many people on the Internet who will make the time to provide you 
with very valuable advice. As a point of network etiquette please do not waste band-
width with questions that are answered in the FAQ. Please also spend some time 
developing an understanding of your problem and making some attempt to see if the 

39
3.19 Bibliography
answer lies in the documentation or manuals. In computing services and technical 
support many user problems are labelled RTFM—read the fabulous manual. 
 3.17.3  Other Sources 
 The following URLs are very useful:
 Our Fortran web site.
• 
•  http://www.fortranplus.co.uk 
 The Fortran Wiki.
• 
•  http://fortranwiki.org/ 
 The Fortran Market, maintained by Walt Brainerd.
• 
•  http://www.fortran.com/fortran/market.html 
 Fortran FAQ, maintained by Keith Bierman, Sun.
• 
•  http://www.fortran.com/fortran/FAQ/cont.html 
 3.18  Summary 
 It is hoped that you now have some idea about the wide variety of uses that program-
ming languages are put to. 
 3.19 Bibliography 
 Fortran 2008 Standard, ISO/IEC 1539–1:2010, price CHF 338. Publication date: 
2010-10-06. 
 http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.
htm?csnumber=50459 
 Fortran 2003 Standard, ISO/IEC DIS 1539–1:2004(E) 
 DTR 19767: Enhanced module Facilities: ISO/IEC TR 19767:2004(E) 
 Fortran 77 Standard 
 ftp://ftp.nag.co.uk/sc22wg5/ARCHIVE/Fortran77.html 
 Fortran 66 Standard 
 ftp://ftp.nag.co.uk/sc22wg5/ARCHIVE/Fortran66.pdf 
 The ISO home page is
•  http://www.iso.org/iso/home.htm 

40
3 Introduction to Programming Languages
 The J3 home page is:
•  http://j3-fortran.org 
 The WG5 home page is:
•  http://www.nag.co.uk/sc22wg5/ 
 Both have copies of working documents.
 Adobe Systems Incorporated, Postscript Language: Tutorial and Cookbook, 
Addison-Wesley, 1985. 
 Adobe Systems Incorporated, Postscript Language: Reference Manual, Addison-
Wesley, 1985. 
 Adobe System Incorporated, Postscript Language: program Design, Addison-
Wesley, 1985. 
 The three books provide a comprehensive coverage of the facilities and capabilities 
of Postscript. 
 ACM SIG PLAN, History of programming Languages Conference—HOPL-II, 
ACM Press, 1993. 
 One of the best sources of information on C++, CLU, Concurrent Pascal, Formac, 
Forth, Icon, Lisp, Pascal, Prolog, Smalltalk and Simulation Languages by the people 
involved in the original design and or implementation. Very highly recommended. 
This is the second in the HOPL series, and the ﬁ rst was edited by Wexelblat. Details 
are given later. 
 Adams, J.C., Brainerd, W.S., Hendrickson, R.A., Maine, R.E., Martin J.T., Smith, 
B.T.: The Fortran 2003 Handbook. Springer, London (2009) 
 Their most recent version, and a complete coverage of the 2003 standard. As 
with the Metcalf, Reid and Cohen book some of the authors were on the J3 commit-
tee. Very thorough. 
 Annals of the History of Computing, Special Issue: Fortran’s 25 Anniversary, ACM, 
Article 6,1, 1984. 
 Very interesting comments, some anecdotal, about the early work on Fortran. 
Barnes, J.: Programming in Ada 95. Addison-Wesley, Reading (1996) 
 One of the best Ada books. He was a member of the original design team 
 Bergin, T.J., Gibson, R.G.: History of Programming Languages. Addison-Wesley, 
New York (1996) 
 This is a formal book publication of the Conference Proceedings of HOPL II. 
The earlier work is based on preprints of the papers. 
 Birtwistle, G.M., Dahl, O. J., Myhrhaug, B., Nygaard, K.: Simula Begin. Chart-
well-Bratt Ltd, Lund (1979) 
 A number of chapters in the book will be of interest to programmers unfamiliar 
with some of the ideas involved in a variety of areas including systems and models, 
simulation, and co-routines. Also has some sound practical advice on problem 
solving. 
 Brinch-Hansen, P.: The programming language concurrent Pascal. IEEE Trans. 
Softw. Eng.  1 (2), 199–207 (June 1975) 

41
3.19 Bibliography
 Looks at the extensions to Pascal necessary to support concurrent processes. Cannan, 
S., Otten, G.: SQL—The Standard Handbook. McGraw-Hill, McGraw-Hill (1993) 
 Very thorough coverage of the SQL standard, ISO 9075:1992(E). 
 Chivers , I.D., Clark, M.W.: History and future of Fortran. Data Process.  27 (1), 
(January/February 1985) 
 Short article on an early draft of the standard, around version 90.
Chivers Ian, Essential C# Fast, Springer, ISBN 1-85233-562-9 
 A quick introduction to the C# programming language. 
Chivers, I.D.: A Practical Introduction to Standard Pascal. Ellis Horwood, Chichester 
(1986) 
 A short introduction to Pascal. 
Date, C.J.: A Guide to the SQL Standard. Addison-Wesley, Reading (1997) 
 Date has written extensively on the whole database ﬁ eld, and this book looks at 
the SQL language itself. As with many of Date’s works quite easy to read. Appendix 
F provides a useful SQL bibliography. 
 Deitel, H.M., Deitel, P.J.: Java: How to Program. Prentice-Hall, Upper Saddle River 
(1999) 
 A very good introduction to Java. 
Deitel, H.M., Deitel, P.J., Nieto, T.R.: Simply Visual Basic .Net. Prentice-Hall, 
Upper Saddle River (2003) 
 Good practical introduction to VB .NET. 
Eckstein, R., Loy, M., Wood, D.: Java Swing. O’Reilly, Sebastopol (1998) 
 Comprehensive coverage of the visual interface features available in Java. 
Flanagan, D.: Java in a Nutshell. O’Reilly, Sebastopol (1996) 
 Just what you would expect from this series. Very useful reference text. 
 Geissman, L.B., Separate Compilation in Modula 2 and the Structure of the Modula 
2 Compiler on the Personal Computer Lilith, Dissertation 7286, ETH Zurich. 
 Goldberg, A., Robson, D.: Smalltalk-80, The Language and Its Implementation. 
Addison Wesley, Reading (1983) 
 Harbison, S.P., Steele, G.L.: A C Reference Manual. Prentice-Hall, Englewood 
Cliffs (2002) 
 Very good coverage of the various ﬂ avours of C, including K&R C, Standard C 
1989, Standard C 1995, Standard C 1999 and Standard C++ 
 Jacobi, C.: Code Generation and the Lilith Architecture, Dissertation 7195, ETH 
Zurich 
 Fascinating background reading concerning Modula 2 and the Lilith architecture. 
 Goldberg, A., Robson, D.: Smalltalk 80: The Language and Its Implementation. 
Addison-Wesley, Reading (1983) 
 Written by some of the Xerox PARC people who have been involved with the 
development of Smalltalk. Provides a good introduction (if that is possible with the 
written word) of the capabilities of Smalltalk. 
 Goos, G., Hartmanis, J. (eds.), The programming Language Ada—Reference 
Manual. Springer Verlag, New York (1981) 
 The deﬁ nition of the language. 

42
3 Introduction to Programming Languages
 Griswold, R.E., Poage, J.F., Polonsky, I.P.: The Snobol4 Programming Language. 
Prentice-Hall, Englewood Cliffs (1971) 
 The original book on the language. Also provides some short historical material 
on the language. 
 Griswold, R.E., Griswold, M.T.: The Icon Programming Language. Prentice-Hall, 
Englewood Cliffs (1983) 
 The deﬁ nition of the language with a lot of good examples. Also contains infor-
mation on how to obtain public domain versions of the language for a variety of 
machines and operating systems. 
 Hoare, C.A.R.: Hints on programming Language Design, SIGACT/SIGPLAN 
Symposium on Principles of programming Languages, October 1973. 
 The ﬁ rst sentence of the introduction sums it up beautifully: “I would like in this 
paper to present a philosophy of the design and evaluation of programming lan-
guages which I have adopted and developed over a number of years, namely that the 
primary purpose of a programming language is to help the programmer in the prac-
tice of his art.” 
 Jenson, K., Wirth, N.: Pascal: User Manual and Report. Springer-Verlag, New York 
(1975) 
 The original deﬁ nition of the Pascal language. Understandably dated when one 
looks at more recent expositions on programming in Pascal. 
 Kemeny, J.G., Kurtz, T.E.: Basic Programming. Wiley, New York (1971) 
 The original book on Basic by its designers. 
 Kernighan, B.W., Ritchie D.M.: The C Programming Language. Prentice-Hall, 
Englewood Cliffs (1978) 
 The original work on the C language, and thus essential for serious work with C. 
 Kowalski, R.: Logic Programming in the Fifth Generation, The Knowledge 
Engineering Review, The BCS Specialist Group on Expert Systems. 
 A short paper providing a good background to Prolog and logic programming, 
with an extensive bibliography. 
 Knuth, D.E.: The TeXbook. Addison-Wesley, Reading (1986) 
 Knuth writes with an tremendous enthusiasm and perhaps this is understandable 
as he did design TeX. Has to be read from cover to cover for a full understanding of 
the capability of TeX. 
 Lyons, J., Chomsky. Fontana/Collins, London (1982) 
 A good introduction to the work of Chomsky, with the added beneﬁ t that 
Chomsky himself read and commented on it for Lyons. Very readable. 
 Malpas, J.: Prolog: A Relational Language and Its Applications. Prentice-Hall, 
Englewood Cliffs (1987) 
 A good introduction to Prolog for people with some programming background. 
Good bibliography. Looks at a variety of versions of Prolog. 
 Marcus, C.: Prolog programming: Applications for Database Systems, Expert 
Systems and Natural Language Systems. Addison-Wesley, Reading (1986 ) 

43
3.19 Bibliography
 Coverage of the use of Prolog in the above areas. As with the previous book 
aimed mainly at programmers, and hence not suitable as an introduction to Prolog 
as only two chapters are devoted to introducing Prolog. 
 Metcalf, M., Reid, J., Cohen, M.: Modern Fortran Explained. Oxford University 
Press, Oxford (2011) 
 A clear compact coverage of the main features of Fortran. John Reid is Convener 
of the WG5 committee and Malcolm Cohen was the editor of Fortran 2008. 
 Mossenbeck, H.: Object-Orientated Programming in Oberon-2. Springer-Verlag, 
New York (1995) 
 One of the best introductions to object oriented programming. Uses Oberon-2 as 
the implementation language. Highly recommended. 
 Papert, S.: Mindstorms—Children, Computers and Powerful Ideas. Harvester Press, 
Brighton (1980) 
 Very personal vision of the uses of computers by children. It challenges many 
conventional ideas in this area. 
 Sammet, J.: Programming Languages: History and Fundamentals. Prentice-Hall, 
Englewood Cliffs (1969) 
 Possibly the most comprehensive introduction to the history of program lan-
guage development—ends unfortunately before the 1980s. 
 Sethi, R.: Programming Languages: Concepts and Constructs. Addison-Wesley, 
Reading (1989) 
 The annotated bibliographic notes at the end of each chapter and the extensive 
bibliography make it a useful book. 
 Reiser, M., Wirth, N.: Programming in Oberon—Steps Beyond Pascal and Modula. 
Addison-Wesley, Reading (1992) 
 Good introduction to Oberon. Revealing history of the developments behind 
Oberon. 
 Reiser, M.: The Oberon System: User Guide and Programmer’s Manual. Addison-
Wesley, Reading (1991) 
 How to use the Oberon system, rather than the language. 
 Stroustroup, B.: The C++ Programming Language, 3rd edn. Addison-Wesley, 
Reading (1997) 
 The C++ book. Written by the designer of the language. Massive improvement 
over the earlier editions. 
 Young, S.J.: An Introduction to Ada, 2nd edn. Ellis Horwood, Chichester (1984) 
 A readable introduction to Ada. Greater clarity than the ﬁ rst edition. 
 Wexelblat, R.L.: History of Programming Languages, HOPL I, ACM Monograph 
Series. Academic Press, New York (1978) 
 Very thorough coverage of the development of programming languages up to 
June 1978. Sessions on Fortran, Algol, Lisp, Cobol, APT, Jovial, GPSS, Simula, 
JOSS, Basic, PL/I, Snobol and APL, with speakers involved in the original lan-
guages. Very highly recommended. 

44
3 Introduction to Programming Languages
 Wiener, R.: Software Development Using Eiffel. Prentice Hall, Englewood Cliffs (1995) 
 Wirth, N.: An assessment of the programming language Pascal. IEEE Trans. Softw. 
Eng.  SE-1 (2), 192–198 (June 1975) 
 Wirth, N.: History and Goals of Modula 2. In: Byte, vol 9, 145–152. McGraw-Hill, 
Inc., Peterborough (August 1984) 
 Straight from the horse’s mouth! 
 Wirth, N.: On the design of programming languages. In: Proceedings of the IFIP 
Congress, vol. 74, pp. 386–393. North-Holland, Amsterdam (1974) 
 Wirth, N.: The programming language Pascal. Acta Inform.  1 , 35–63 (1971) 
 Wirth, N.: Modula: a language for modular multiprogramming. Softw. Pract. Exp. 
 7 (1), 3–35 (1977) 
 Wirth, N.: Programming in Modula 2. Springer-Verlag, Berlin (1983) 
 The original deﬁ nition of the language. Essential reading for anyone considering 
programming in Modula 2 on a long term basis. 
 Wirth, N.: Type extensions. ACM Trans. Program. Languages Syst.  10 (2), 204–214 
(April 1988) 
 Wirth, N.: From Modula 2 to Oberon. Softw. Pract. Exp.  18 (7), 661–670 (July 
1988) 
 Wirth, N., Gutknecht, J.: Project Oberon: The Design of an Operating System and 
Compiler. Addison-Wesley, Reading (1992) 
 Fascinating background to the development of Oberon. Highly recommended for 
anyone involved in large scale program development, not only in the areas of pro-
gramming languages and operating systems, but more generally. 

45
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_4, © Springer-Verlag London Limited 2012
 Aims 
 The aims of the chapter are:
 To introduce the idea that there is a wide class of problems that can be solved 
• 
with a computer and, further, that there is a relationship between the kind of 
problem to be solved and the choice of programming language that is used. 
 To give some of the reasons for the choice of Fortran. 
• 
 To introduce the fundamental components or kinds of statements to be found in 
• 
a general purpose programming language. 
 To introduce the three concepts of name, type and value. 
• 
 To illustrate the above with sample programs based on three of the ﬁ ve intrinsic 
• 
data types:
 character, integer and real 
 –
 To introduce some of the formal syntactical rules of Fortran. 
• 
 4.1  Introduction 
 We have seen that an algorithm is a sequence of steps that will solve a part or the 
whole of a problem. A program is the realisation of an algorithm in a programming 
language, and there are at ﬁ rst sight a surprisingly large number of programming 
 Chapter 4 
 Introduction to Programming  
 “Though this be madness, yet there is method in’t” Shakespeare 
 ‘Plenty of practice’ he went on repeating, all the time that Alice 
was getting him on his feet again. ‘plenty of practice.’ 
 The White Knight, Through the Looking Glass and What Alice 
Found There, 
 Lewis Carroll 

46
4 Introduction to Programming
languages. The reason for this is that there is a wide range of problems that are 
solved using a computer, e.g., the telephone company generating itemised bills or 
the meteorological centre producing a weather forecast. These two problems make 
different demands on a programming language, and it is unlikely that the same 
language would be used to solve both. 
 The range of problems that you want to solve will therefore strongly inﬂ uence 
your choice of programming language. Fortran stands for FORmula TRANslation, 
which gives a hint of the expected range of problems for which it is suitable. 
 4.2  Language Strengths and Weaknesses 
 Some of the reasons for choosing Fortran are:
 It is a modern and expressive language; 
• 
 The language is suitable for a wide class of both numeric and nonnumeric 
• 
problems; 
 The language is widely available on a range of hardware and operating system 
• 
platforms; 
 A lot of software already exists that has been written in Fortran. Some 15% of 
• 
code worldwide is estimated to be in Fortran. 
 There are a few warts, however. Given that there has to be backwards compati-
bility with earlier versions some of the syntax is clumsy to say the least. However, 
a considerable range of problems can now be addressed quite cleanly, if one sticks 
to a subset of the language and adopts a consistent style. 
 4.3  Elements of a Programming Language 
 As with ordinary (so-called natural) languages, e.g., English, French, Gaelic, 
German, etc., programming languages have rules of syntax, grammar and spelling. 
The application of these rules in a programming language is more strict. A 
program has to be unambiguous, since it is a precise statement of the actions to be 
taken. Many everyday activities are rather vaguely deﬁ ned—Buy some bread on 
your way home—but we are generally sufﬁ ciently adaptable to cope with the 
variations which occur as a result. if, in a program to calculate wages, we had an 
instruction deduct some money for tax and insurance we could have an awkward 
problem when the program calculated completely different wages for the same 
person for the same amount of work every time it was run. One of the implications 
of the strict syntax of a programming language for the novice is that apparently 
silly error messages will appear when one ﬁ rst starts writing programs. As with 
many other new subjects you will have to learn some of the jargon to understand 
these messages. 

47
4.3 Elements of a Programming Language
 Programming languages are made up of statements. We will look at the various 
kinds of statements brieﬂ y below. 
 4.3.1  Data Description Statements 
 These are necessary to describe the kinds of data that are to be processed. In the 
wages program, for example, there is obviously a difference between people’s 
names and the amount of money they earn, i.e., these two things are not the same, 
and it would not make any sense adding your name to your wages. The technical 
term for this is data type—a wage would be of a different data type (a number) to a 
surname (a sequence of characters). 
 4.3.2  Control Structures 
 A program can be regarded as a sequence of statements to solve a particular 
problem, and it is common to ﬁ nd that this sequence needs to be varied in practice. 
Consider again the wages program. It will need to select among a variety of circum-
stances (say married or single, paid weekly or monthly, etc.,), and also to repeat the 
program for everybody employed. So there is the need in a programming language 
for statements to vary and/or repeat a sequence of statements. 
 4.3.3  Data-Processing Statements 
 It is necessary in a programming language to be able to process data. The kind of 
processing required will depend on the kind or type of data. In the wages program, 
for example, you will need to distinguish between names and wages. Therefore 
there must be different kinds of statements to manipulate the different types of data, 
i.e., wages and names. 
 4.3.4  Input and Output (I/O) Statements 
 For ﬂ exibility, programs are generally written so that the data that they work on 
exist outside the program. In the wages example the details for each person 
employed would exist in a ﬁ le somewhere, and there would be a record for each 
person in this ﬁ le. This means that the program would not have to be modiﬁ ed 
each time a person left, was ill, etc., although the individual records might be 
updated. It is easier to modify data than to modify a program, and it is less likely 
to produce unexpected results. To be able to vary the action there must be some 
mechanism in a programming language for getting the data into and out of the 

48
4 Introduction to Programming
program. This is done using input and output statements, sometimes shortened to 
I/O statements. 
 Let us now consider a simple program which will read in somebody’s ﬁ rst name 
and print it out:
 program ch0401  
 ! 
 ! This program reads in and prints out a name  
 ! 
 implicit none  
 character*20 :: ﬁ rst_name  
 ! 
 print *,' type in your ﬁ rst name.'  
 print *,' up to 20 characters'  
 read *,ﬁ rst_name  
 print *,ﬁ rst_name  
 ! 
 end program ch0401  
 There are several very important points to be covered here, and they will be taken 
in turn:
 Each line is a statement. 
• 
 There is a sequence to the statements. The statements will be processed in the 
• 
order that they are presented, so in this example the sequence is print, read, 
print. 
 The ﬁ rst statement names the program. It makes sense to choose a name that 
• 
conveys something about the purpose of the program. 
 The next three lines are comment statements. They are identiﬁ ed by a !. Comments 
• 
are inserted in a program to explain the purpose of the program. They should be 
regarded as an integral part of all programs. It is essential to get into the habit of 
inserting comments into your programs straightaway. 
 The  
• 
implicit none statement means that there has to be explicit typing of 
each and every data item used in the program. It is good programming practice 
to include this statement in every program that you write, as it will trap many 
errors, some often very subtle in their effect. Using an analogy with a play, where 
there is always a list of the persona involved before the main text of the play we 
can say that this statement serves the same purpose. 
 The character*20  statement is a type declaration. It was mentioned ear-
lier that there are different kinds of data. There must be some way of telling the 
programming language that these data are of a certain type, and that therefore 
certain kinds of operations are allowed and others are banned or just plain stupid! 
It would not make sense to add a name to a number, e.g., what does Fred + 10 
mean? So this statement deﬁ nes that the variable ﬁ rst_name is to be of type 
 character and only character operations are permitted. The concept of a vari-
able is covered in the next section. Character variables of this type can hold up to 
20 characters.

49
4.4 Variables—Name, Type and Value
 The  
• 
print statements print out an informative message to the terminal—in this 
case a guide as to what to type in. The use of informative messages like this 
throughout your programs is strongly recommended. 
 The  
• 
read statement is one of the I/O statements. It is an instruction to read from 
the terminal or keyboard; whatever is typed in from the terminal will end up 
being associated with the variable ﬁ rst_name. Input/output statements will be 
explained in greater detail in later sections. 
 The  
• 
print  statement is another I/O statement. This statement will print out what 
is associated with the variable ﬁ rst_name and, in this case, what you typed in.  
 The  
• 
end program statement terminates this program. It can be thought of as 
being similar to a full stop in natural language, in that it ﬁ nishes the program in 
the same way that a period ( . ) ends a sentence. Note the use of the name given 
in the  program statement at the start of the program. 
 Note also the use of the asterisk in three different contexts. 
• 
 Indentation has been used to make the structure of the program easier to 
• 
determine. Programs have to be read by human beings and we will look at this 
in more depth later.  
 Lastly, when you do run this program, character input will terminate with the 
• 
ﬁ rst blank character. 
 The above program illustrates the use of some of the statements in the Fortran 
language. Let us consider the action of the  read * statement in more detail—in 
particular, what is meant by a variable and a value. 
 4.4  Variables—Name, Type and Value 
 The idea of a variable is one that you are likely to have met before, probably in a 
mathematical context. Consider the following:
 
 
=
circumference
2 r
π   
 
 This is an equation for the calculation of the circumference of a circle. The fol-
lowing represents a translation of this into Fortran:
 
 
=
circumference
2*pi*radius   
 
 There are a number of things to note about this equation:
 Each of the variables on the right-hand side of the equals sign (pi and radius) will 
• 
have a value, which will allow the evaluation of the expression. 
 When the expression is fully evaluated the value is assigned to the variable on the 
• 
left-hand side of the equals sign. 
 In mathematics the multiplication is implied in Fortran we have to use the * 
• 
operator to indicate that we want to multiply 2 by pi by the radius. 
 We do not have access to mathematical symbols like  
• 
p in Fortran but have to use 
variable names based on letters from the Roman alphabet. 

50
4 Introduction to Programming
 The whole line is an example of an arithmetic assignment statement in Fortran. 
 The following arithmetic assignment statement illustrates clearly the concepts of 
name and value, and the difference in the equals sign in mathematics and 
computing:
 
 =
+
I 
I
1  
 
 In Fortran this reads as take the current value of the variable I and add one to it, 
store the new value back into the variable I, i.e., I takes the value I + 1. 
Algebraically,
 
 =
+
I
I
1  
does not make any sense. 
 Variables can be of different types. Table  4.1 shows some of those available in 
Fortran.  
 The concept of data type seems a little strange at ﬁ rst, especially as we com-
monly think of integers and reals as numbers. However, the beneﬁ ts to be gained 
from this distinction are considerable. This will become apparent after you have 
written several programs. 
 Let us now consider another program, one that reads in three numbers, adds them 
up and prints out both the total and the average:
 program ch0402  
 ! 
 ! This program reads in three numbers and sums  
 ! and averages them  
 ! 
 implicit none  
 real :: n1, n2, n3, average  =  0.0, total  =  0.0 
 integer :: n  =  3 
 print *, ' type in three numbers. '  
 print *,' Separated by spaces or commas'  
 read *,n1,n2,n3  
 total =  n1 +  n2 +  n3 
 average  =  total/n  
 print *,'Total of numbers is ',total  
 print *,'Average of the numbers is ',average 
end program ch0402  
 Table 4.1   Variable, type and value 
 Variable_name 
 data_type 
 value_stored 
 temperature 
 real  
 28.55 
 number_of_people 
 integer  
 100 
 ﬁ rst_name 
 character  
 Jane 
   Note the use of underscores to make the variable names easier to read.  

51
4.5 Notes
 4.5  Notes 
 The program has been given a name that means something. 
 There are comments at the start of the program describing what it does. 
 The  implicit none  statement ensures that all data items introduced have to 
occur in a type declaration. 
 The next two statements are type declarations. They deﬁ ne the variables to be of 
real or integer type. Remember integers are whole numbers, whereas real numbers 
are those which have a decimal point. For example, 2 is an integer and 2.7, 
2.00000001, and 2.0 are all real numbers. One of the fundamental distinctions in 
Fortran is between integers and reals. Type declarations must always come at the 
start of a program, before any processing is done. Note that the variables have been 
given sensible names to aid in making the program easier to understand. 
 The variables average, total and n are also given initial values within the type 
declaration. Variables are initially undeﬁ ned in Fortran, so the variables n1, n2, n3 
fall into this category, as they have not been given values at the time that they are 
declared. 
 The ﬁ rst  print  statement makes a text message (in this case what is between 
the apostrophes) appear at the terminal. As was noted earlier, it is good practice to 
put out a message like this so that you have some idea of what you are supposed 
to type in. 
 The  read statement looks at the input from the keyboard (i.e., what you type) 
and in this instance associates these values with the three variables. These values 
can be separated by commas (,), spaces (), or even by pressing the carriage return 
key, i.e., they can appear on separate lines. 
 The next statement actually does some data processing. It adds up the values of 
the three variables (n1, n2, and n3) and assigns the result to the variable total. This 
statement is called an arithmetic assignment statement, and is covered more fully in 
the next chapter. 
 The next statement is another data-processing statement. It calculates the 
average of the numbers entered and assigns the result to average. We could have 
actually used the value 3 here instead, i.e., written average  = total/3 and have exactly 
the same effect. This would also have avoided the type declaration for n. However, 
the original example follows established programming practice of declaring all 
variables and establishing their meaning unambiguously. We will see further 
examples of this type throughout the book. 
 Indentation has been used to make the structure of the program easier to 
determine. 
 The sum and average are printed out with suitable captions or headings. Do not 
write programs without putting captions on the results. It is too easy to make 
mistakes when you do this, or even to forget what each number means. 
 Finally we have the end of the program and again we have the use of the name in 
the  program statement. 

52
4 Introduction to Programming
 4.6  Some More Fortran Rules 
 There are certain things to learn about Fortran which have little immediate meaning 
and some which have no logical justiﬁ cation at all, other than historical precedence. 
Why is a cat called a cat? At the end of several chapters there will be a brief sum-
mary of these rules or regulations when necessary. Here are a few:
 Source is free format. 
• 
 Lowercase letters are permitted, but not required to be recognised. 
• 
 Multiple statements may appear on one line and are separated by the semicolon 
• 
character. 
 There is an order to the statements in Fortran. Within the context of what you 
• 
have covered so far, the order is:
 
 – Program statement. 
 Type declarations, e.g., 
 –
 implicit, integer, real or character. 
 Processing and I/O statements. 
 –
 
 – End program  statement. 
 Comments may appear anywhere in the program, after program and before end; 
• 
they are introduced with a ! character, and can be in line. 
 Names may be up to 63 characters in length and include the underscore character. 
• 
 Lines may be up to 132 characters. 
• 
 Up to 39 continuation lines are allowed (using the ampersand (&) as the continu-
• 
ation character). 
 The syntax of the  
• 
read and  print statement introduced in these examples is
 
 – read format, input-item-list. 
 
 – print format, output-item-list.
 where format is * in the examples and called list directed format ting. 
• 
 and input-item-list is a list of variable names separated by commas. 
• 
 and output-item-list is a list of variable names and/or a sequence of char-
• 
acters enclosed in either ' or ", again separated by commas. 
 if the  
 –
implicit none statement is not used, variables that are not explic-
itly declared will default to  real if the ﬁ rst letter of the variable name is A–H 
or O–Z, and to  integer if the ﬁ rst letter of the variable name is I–N. 
 4.7  Fortran Character Set 
 The following summarises the Fortran character set: 
 Alphanumeric characters
 A–Z: Uppercase letters 
 a–z: Lowercase letters 
 0–9: Digits 
 _: Underscore 

53
4.7 Fortran Character Set
 Special characters 
 Graphic 
 Name of character 
 Blank 
 = 
 Equals 
 + 
 Plus 
 − 
 Minus 
 * 
 Asterisk 
 / 
 Slash or oblique 
 \ 
 Backslash 
 ( 
 Left parenthesis 
 ) 
 Right parenthesis 
 [ 
 Left square bracket 
 ] 
 Right square bracket 
 { 
 Left curly bracket 
 } 
 Right curly bracket 
 , 
 Comma 
 . 
 Period or decimal point 
 : 
 Colon 
 ; 
 Semicolon 
 ! 
 Exclamation mark 
 " 
 Quotation mark 
 % 
 Percent 
 & 
 Ampersand 
 ~ 
 Tilde 
 @ 
 Commercial at 
 < 
 Less than 
 > 
 Greater than 
 ? 
 Question mark 
 ' 
 Apostrophe 
 ` 
 Grave accent 
 ^ 
 Circumﬂ ex accent 
 | 
 Vertical bar or line 
 $ 
 Currency symbol 
 # 
 Number sign 
 The default character type shall support a character set that includes the Fortran 
character set. By supplying non-default character types, the processor may support 
additional character sets. The characters available in the ASCII and ISO 10646 
character sets are speciﬁ ed by ISO/IEC 64 6:1991 (International Reference Version) 
and ISO/IEC 10646–1:2000 UCS-4, respectively; the characters available in other 
non default character types are not speciﬁ ed by the standard, except that one char-
acter in each non-default character type shall be designated as a blank character to 
be used as a padding character. 

54
4 Introduction to Programming
 If you live and work outside of the USA and UK you may well have problems 
with your keyboard when programming. There is a very good entry in Wikipedia on 
keyboards, that is well worth a look at for the curious. 
 4.8  Good Programming Guidelines 
 The following are guidelines, and do not form part of the Fortran language 
deﬁ nition:
 Use comments to clarify the purpose of both sections of the program and the 
• 
whole program. 
 Choose meaningful names in your programs. 
• 
 Use indentation to highlight the structure of the program. Remember that the 
• 
program has to be read and understood by both humans and a computer. 
 Use implicit none in all programs you write to minimise errors. 
• 
 Do not rely on the rules for explicit typing, as this is a major source of errors in 
• 
programming. 
 4.9  Compilers 
 A number of hardware platforms, operating systems and compilers have been used 
when writing this book and earlier books. The following have been used with this 
book:
 NAG Fortran Builder 5.1, 5.2, 5.3 for Windows 
• 
 NAG Fortran Compiler 5.1, 5.2, 5.3 for Linux. 
• 
 Intel Fortran 11.x, 12.x for Windows. 
• 
 Intel Fortran 12.x for Linux. 
• 
 gnu gfortran 4.x for Windows. 
• 
 gnu gfortran 4.x for Linux. 
• 
 Cray Fortran : Version 7.3.1—Cray Hector service 
• 
 g95 for Linux. 
• 
 pgi 10.x—Cray Hector service 
• 
 IBM XL Fortran for AIX, V13.1 (5724-X15), Version: 13.01.0000.0002 
• 
 Oracle Solaris Studio 12.0, 12.1, 12.2 for Linux The following have been used 
• 
with earlier books: 
 The following have been used with earlier books:
 DEC VAX under VMS and later OPEN VMS with the NAG Fortran 90 compiler. 
• 
 DEC Alpha under OPEN VMS using the DEC Fortran 90 compiler. 
• 
 Sun Ultra Sparc under Solaris:
• 
 NAGACE F90 compiler. 
 –
 NAG Ware F95 compiler. 
 –

55
4.10 Program Development
 Sun (Release 1 .x) F90 compiler. 
 –
 Sun (Release 2.x) F90 compiler. 
 –
 PCs under DOS and Windows:
• 
 DEC/Compaq Fortran 90 and Fortran 95 compilers. 
 –
 Intel Compiler (7.x, 8.x). 
 –
 Lahey Fujitsu Fortran 95 (5.7). 
 –
 NAG Fortran 95 Compiler. 
 –
 NAG Salford Fortran 90 Compiler. 
 –
 Salford Fortran 95 Compiler. 
 –
 PCs under Linux:
• 
 Intel Compiler. 
 –
 Lahey Fujitsu Fortran 95 Pro (6.1). 
 –
 NAG Fortran 95 (4.x, 5.x). 
 –
 It is very illuminating to use more than one compiler whilst developing programs.  
 4.10  Program Development 
 A number of ways of developing programs have been used, including:
 Using an integrated development environment, including
• 
 NAG Fortran Builder under Windows. 
 –
 Microsoft Visual Studio with the Intel compiler under Windows. 
 –
 Oracle Sunstudio under SuSe Linux. 
 –
 Using a DOS box and simple command line prompt under Windows. 
• 
 Using ssh to log in to the Hector service. 
• 
  Using a VPN, and SSH to log in to the IBM Power 7 system at Slovak 
• 
Hydrometeorological Institute Jeséniova 17 
 Using a console or terminal window under SuSe Linux. 
• 
 Using X-Windows software to log into the SUN Ultra Sparc systems. 
• 
 Using terminal emulation software to log into the SUN Ultra Sparc. 
• 
 Using DEC terminals to log into the DEC VAX and DEC Alpha systems. 
• 
 Using PCs running terminal emulation software to log into the DEC VAX and 
• 
DEC Alpha systems. 
 It is likely that you will end up doing at least one of the above and probably more. 
The key stages involved are:
 Creating and making changes to the Fortran program source. 
• 
 Saving the ﬁ le. 
• 
 Compiling the program:
• 
 if there are errors you must go back to the Fortran source and make the changes 
 –
indicated by the compiler error messages. 

56
4 Introduction to Programming
 Linking if successful to generate an executable:
• 
 Automatic link. This happens behind the scenes and the executable is gener-
 –
ated for you immediately. 
 Manual link. You explicitly invoke the linker to generate the executable. 
 –
 Running the program. 
• 
 Determining whether the program actually works and gives the results expected.    
• 
 These steps must be taken regardless of the hardware platform, operating system 
and compiler you use. Some people like working at the operating system prompt 
(e.g., DOS, Linux and UNIX), and others prefer working within a development 
environment. Both have their strengths and weaknesses. 
 4.11  Problems 
 1.  Compile and run example 1 in this chapter. Experiment with the following types 
of input. 
 Ian 
 Ian Chivers 
 "Jane Margaret Sleightholme" 
 2.  Compile and run example 2 in this chapter. 
 Think about the following points:
 Is there a difference between separating the input by spaces or commas? 
• 
 do you need the decimal point? 
• 
 What happens when you type in too many data? 
• 
 What happens when you type in too few data? 
• 
 If you have access to more than one compiler repeat the above and compare the 
results. 
 3.  Write a program that will read in your name and address and print them out in 
reverse order. 
 Think about the following points:
 How many lines are there in your name and address? 
• 
 What is the maximum number of characters in the longest line in your 
• 
name and address? 
 What happens at the ﬁ rst blank character of each input line? 
• 
 Which characters can be used in Fortran to enclose each line of text typed 
• 
in and hence not stop at the ﬁ rst blank character? 
 if you use one of the two special characters to enclose text what happens if 
• 
you start on one line and then press the return key before terminating the 
text? 
 The action here will vary between Fortran implementations. 

57
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_5, © Springer-Verlag London Limited 2012
 Aims
 The aims of this chapter are to introduce: 
• 
  The rules for the evaluation of arithmetic expressions to ensure that they are 
• 
evaluated as you intend. 
 The idea of truncation and rounding applied to reals. 
• 
 The use of the  parameter attribute to deﬁ ne or set up constants. 
• 
 The concepts and ideas involved in numerical computation, including:
• 
 Specifying data types using kind-type parameters. 
 –
 The concept of numeric models and positional number systems for integer 
 –
and real arithmetic and their implementation on binary devices. 
 Testing the numerical representation of different kind types on a system. 
 –
 Chapter 5 
 Arithmetic 
 Taking Three as the subject to reason about— 
 A convenient number to state— 
 We add Seven, and Ten, and then multiply out 
 By One Thousand diminished by Eight. 
 The result we proceed to divide, as you see, 
 By Nine Hundred and Ninety and Two: 
 then subtract Seventeen, and the answer must be 
 Exactly and perfectly true. 
 Lewis Carroll, The Hunting of the Snark 
 Round numbers are always false. 
 Samuel Johnsons 

58
5 Arithmetic
 5.1  An Introduction to Arithmetic in Fortran  
 Most problems in the academic and scientiﬁ c communities require arithmetic 
evaluation as part of the algorithm. As the rules for the evaluation of arithmetic 
in Fortran may differ from those that you are probably familiar with, you need to 
learn the Fortran rules thoroughly. In the previous chapter, we introduced the 
arithmetic assignment statement, emphasising the concepts of name, type and 
value. Here we will consider the way that arithmetic expressions are evaluated in 
Fortran. 
 Table  5.1 lists the ﬁ ve arithmetic operators available in Fortran. 
 Exponentiation is raising to a power. Note that the exponentiation operator is the 
* character twice. 
 The following are some examples of valid arithmetic assignment statements in 
Fortran:
 taxable_income  =  gross_wage − personal_allowance  
 cost =  bill +  vat +  service  
 delta =  deltax/deltay  
 area =  pi * radius * radius  
 cube =  big ** 3  
 The above expressions are all simple, and there are no problems when it comes 
to evaluating them. However, now consider the following:
 tax =  gross_wage − personal_allowance * tax_rate  
 This is a poorly written arithmetic expression. There is a choice of doing the 
subtraction before or after the multiplication. Our everyday experience says that the 
subtraction should take place before the multiplication. However, if this expression 
were evaluated in Fortran the multiplication would be done before the subtraction. 
 5.2  Example 1: Simple Arithmetic Expressions in Fortran 
 A complete program to show the correct form in Fortran is as follow: 
 Table 5.1   Fortran operators 
 Mathematical operation 
 Fortran symbol or operator 
 Addition 
 + 
 Subtraction 
 − 
 Division 
 / 
 Multiplication 
 * 
 Exponentiation 
 ** 

59
5.2 Example 1: Simple Arithmetic Expressions in Fortran
 We need to look at three areas here:
 The rules for forming expressions—the syntax. 
• 
 The rules for interpreting expressions—the semantics. 
• 
 The rules for evaluating expressions—optimisation. 
• 
 The syntax rules determine which expressions are valid. The semantics determine 
a valid interpretation, and once this has been done the compiler can replace the expres-
sion with any other one that is mathematically equivalent, generally in the interests 
of optimisation. 
 The rules for the evaluation of expressions in Fortran are as follows:
 Brackets are used to deﬁ ne priority in the evaluation of an expression. 
• 
  Operators have a hierarchy of priority—a precedence. The hierarchy of operators is:  
• 
 Exponentiation: when the expression has multiple exponentiation, the evaluation 
• 
is from right to left. For example,
 
 
=
L 
 I** J** K   
is evaluated by ﬁ rst raising J to the power K, and then using this result as the 
exponent for I; more explicitly,
 
 
(
)
=
L 
 I ** J ** K   
 
 Although this is similar to the way in which we might expect an algebraic expres-
sion to be evaluated, it is not consistent with the rules for multiplication and 
division, and may lead to some confusion. When in doubt, use brackets. 

60
5 Arithmetic
 Multiplication and division: within successive multiplications and divisions, the 
• 
rules regarding any mathematically equivalent expression means that you must 
use brackets to ensure the evaluation you want For example, with
 
 
=
A 
 B *C / D*E   
for real and complex numeric types the compiler does not necessarily evaluate 
in a left to right manner, i.e., evaluate B times C, then divide the result by D and 
ﬁ nally take that result and multiply by E. 
 Addition and subtraction: as for multiplication and division the rules regarding 
• 
any equivalent expression apply. However, it is seldom that the order of addition 
and subtraction is important, unless other operators are involved. 
 The following are all examples of valid arithmetic expressions in Fortran:
 Slope =  (Y1−Y2)/(X1−X2)  
 X1 =  (−B +  ((B*B−4*A*C)**0.5))/(2*A)  
 Q =  Mass_D/2*(Mass_A*Veloc_A/Mass_D)**2  +  & 
 ((Mass_A * Veloc_A)**2)/2  
 Note that brackets have been used to make the order of evaluation more obvious. 
It is often possible to write involved expressions without brackets, but, for the sake 
of clarity, it is often best to leave the brackets in, even to the extent of inserting a few 
extra ones to ensure that the expression is evaluated correctly. The expression will 
be evaluated just as quickly with the brackets as without. Also note that none of the 
expressions is particularly complex. The last one is about as complex as you should 
try: with more complexity than this it is easy to make a mistake. 
 The rule regarding any equivalent expression means if A, B and C are numeric 
then the following are true:
 
 
(
)
A 
 B 
 B 
 A
A 
 B
B 
 A 
A 
 B 
 C 
 A 
B 
 C
+
=
+
-
+
=
-
+
+
=
+
+
  
 
 The last is nominally evaluated left to right, as the additions are of equal 
precedence:
 
 
(
)
A * B 
 B * A
A * B * C 
 A * B * C
=
=
  
and again the last is nominally evaluated left to right, as the multiplications are of 
equal precedence:
 
 
(
)
(
)
A * B 
 A*C 
 A* B
C
A /  B /  C 
 A / B * C
-
=
-
=
  
 
 The last is true for real and complex numeric types only. 

61
5.3 Rounding and Truncation
 Problems arise when the value that a faulty expression yields lies within the 
range of expected values and the error may well go undetected. This may appear 
strange at ﬁ rst, but a computer does exactly what it is instructed to do. If, through a 
misunderstanding on the part of a programmer, the program is syntactically correct 
but logically wrong from the point of view of the problem deﬁ nition, then this will 
not be spotted by the compiler. If an expression is complex, break it down into suc-
cessive statements with elements of the expression on each line, e.g.,
 Temp =  B * B – 4 * A * C  
 X1 =  ( − B +  ( Temp ** 0.5 )) / ( 2 * A )  
 and
 Moment  =  Mass_A * Veloc_A  
 Q =  Mass_D 
/ 
2 
* 
( 
Moment 
/ 
Mass_D 
) 
**2  +  & 
( Moment **2) / 2  
 5.3  Rounding and Truncation 
 When arithmetic calculations are performed one of the following can occur:
 Truncation. This operation involves throwing away part of the number, e.g., with 
• 
14.6 truncating the number to two ﬁ gures leaves 14. 
 Rounding. Consider 14.6 again. This is rounded to 15. Basically, the number is 
• 
changed to the nearest whole number. It is still a real number. What do you think 
will happen with 14.5; will this be rounded up or down? 
 You must be aware of these two operations. They may occasionally cause prob-
lems in division and in expressions with more than one data type. 
 5.3.1  Example 2: Type Conversion and Assignment 
 To see some of the problems that can occur consider the examples below:
 program ch0502  
 implicit none  
 real :: a,b,c  
 integer :: I 
 a =  1.5 
 b =  2.0 
 c =  a / b 
 I =  a / b 
 print *,a,b  
 print *,c  
 print *,I  
 end program ch0502  

62
5 Arithmetic
 After executing these statements  c has the value 0.75, and  I has the value zero! 
This is an example of type conversion across the  =  sign. The variables on the right 
are all real, but the last variable on the left is an integer. The value is therefore made 
into an integer by truncation. In this example, 0.75 is real, so I becomes zero when 
truncation takes place. 
 5.3.2  Example 3: Integer Division and Real Assignment 
 Consider now an example where we assign into a real variable (so that no truncation 
due to the assignment will take place), but where part of the expression on the right-
hand side involves integer division:
 program ch0503  
 implicit none  
 integer :: I, J, K  
 real :: Answer 
 I =  5 
 J =  2 
 K =  4 
 Answer  =  I / J * K  
 print *,I  
 print *, J  
 print *,K  
 print *,Answer  
 end program ch0503 
 The value of Answer is 8, because the I/J term involves integer division. The 
expected answer of 10 is not that different from the actual one of 8, and it is cases 
like this that cause problems for the unwary, i.e., where the calculated result may be 
close to the actual one. In complicated expressions it would be easy to miss some-
thing like this. 
 To recap, truncation takes place in Fortran:
 Across an = sign, when a real is assigned to an integer. 
• 
 In integer division. 
• 
 It is very important to be careful when attempting mixed mode arithmetic—that 
is, when mixing reals and integers. if a real and an integer are together in a division 
or multiplication, the result of that operation will be real; when addition or subtrac-
tion takes place in a similar situation, the result will also be real. The problem arises 
when some parts of an expression are calculated using integer arithmetic and other 
parts with real arithmetic:
 
 
=
+
-
C 
 A 
 B
I /  J   
 

63
5.4 Example 4: Time Taken for Light to Travel from the Sun to Earth 
 The integer division is carried out before the addition and subtraction; hence the 
result of I/J is integer, although all the other parts of the expression will be carried 
out with real arithmetic. 
 5.4  Example 4: Time Taken for Light to Travel 
from the Sun to Earth 
 How long does it take for light to reach the Earth from the Sun? Light travels 
9.46·10 12 km in 1 year. We can take a year as being equivalent to 365.25 days. (As 
all school children know, the astronomical year is 365 days, 5 h, 48 min and 
45.9747 s—hardly worth the extra effort.) The distance between the Earth and Sun 
is about 150,000,000 km. There is obviously a bit of imprecision involved in these 
ﬁ gures, not least since the Earth moves in an elliptical orbit, not a circular one. One 
last point to note before presenting the program is that the elapsed time will be given 
in minutes and seconds. Few people readily grasp fractional parts of a year:
 program ch0504  
 implicit none  
 real :: Light_Minute, Distance, Elapse  
 integer :: Minute, Second  
 real , parameter :: Light_Year =  9.46*10**12  
 ! Light_year : Distance travelled by light  
 ! in one year in km  
 ! Light_minute : Distance travelled by light  
 ! in one minute in km  
 ! Distance : Distance from sun to earth in km  
 ! Elapse : Time taken to travel a  
 ! distance (Distance) in minutes  
 ! Minute : integer number part of elapse  
 ! Second : integer number of seconds  
 ! equivalent to fractional part of elapse  
 ! 
 Light_minute  =  Light_Year/(365.25 * 24.0 * 60.0)  
 Distance  =  150.0 * 10 ** 6  
 Elapse  =  Distance / Light_minute  
 Minute  =  Elapse  
 Second  =  (Elapse - Minute) * 60  
 print *, 'Light takes', Minute, 'Minutes'  
 print *,' ' , Second, 'Seconds'  
 print *, 'To reach the earth from the sun'  
 end program ch0504  
 The calculation is straightforward; ﬁ rst we calculate the distance travelled by 
light in 1 min, and then use this value to ﬁ nd out how many minutes it takes for light 

64
5 Arithmetic
to travel a set distance. Separating the time taken in minutes into whole-number 
minutes and seconds is accomplished by exploiting the way in which Fortran will 
truncate a real number to an integer on type conversion. The difference between 
these two values is the part of a minute which needs to be converted to seconds. 
Given the inaccuracies already inherent in the exercise, there seems little point in 
giving decimal parts of a second. 
 It is worth noting that some structure has been attempted by using comment lines 
to separate parts of the program into fairly distinct chunks. Note also that the com-
ment lines describe the variables used in the program. 
 Can you see any problems with this example? 
 5.5  The parameter Attribute 
 This statement is used to provide a way of associating a meaningful name with a 
constant in a program. Consider a program where  p was going to be used a lot. It 
would be silly to have to type in 3.14159265358, etc., every time. There would be a 
lot to type and it is likely that a mistake could be made typing in the correct value. 
It therefore makes sense to set up  p once and then refer to it by name. However, if 
PI was just a variable then it would be possible to do the following:
 real :: li,pi  
 . 
 pi =  4.0*atan(1.0)  
 . 
 pi =  4*alpha/beta  
 . 
 The pi = 4*alpha/beta statement should have been li = 4*alpha/beta. What has hap-
pened is that, through a typing mistake (p and l are close together on a keyboard), an 
error has crept into the program. It will not be spotted by the compiler. Fortran provides 
a way of helping here with the  parameter statement, which should be preceded with 
a type declaration. The following are correct examples of the  parameter attribute:
 real , parameter :: pi =  4.0*atan(1.0) , C =  2.997925  
and
 real , parameter :: Charge =  1.6021917  
 The advantage of the  parameter attribute is that you could not then assign 
another value to pi, C or Charge. If you tried to do this, the compiler would generate 
an error message. 
 A type statement with a  parameter attribute may contain an arithmetic expression, 
so that some relatively simple arithmetic may be performed in setting up these constants. 
The evaluation must be conﬁ ned to addition, subtraction, multiplication, division and 
integer exponentiation. The following examples help to demonstrate the possibilities:
 real , parameter :: parsec  =  3.08*10**16 , &   
 pi =  4.0*atan(1.0) , & 
radian  =  360./pi  

65
5.6 Range, Precision and Size of Numbers
 5.6  Range, Precision and Size of Numbers 
 The range on integer numbers and the precision and the size of ﬂ oating point 
numbers in computing are directly related to the number of bits allocated to their 
internal representation. Tables  5.2 and  5.3 summarise this information for the two 
most common bit sizes in use for integers and reals—32 bits and 64 bits.  
 Table  5.2 looks at integer numbers. 
 Table  5.3 is a corresponding table for real numbers. 
 Precision is not the same as accuracy. In this age of digital timekeeping, it is easy 
to provide an extremely precise answer to the question What time is it? This answer 
need not be accurate, even though it is reported to tenths (or even hundredths!) of a 
second. Do not be fooled into believing that an answer reported to ten places of 
decimals must be accurate to ten places of decimals. The computer can only retain 
a limited precision. When calculations are performed, this limitation will tend to 
generate inaccuracies in the result. The estimation of such inaccuracies is the domain 
of the branch of mathematics known as Numerical Analysis. 
 To give some idea of the problems, consider an imaginary decimal computer 
which retains two signiﬁ cant digits in its calculations. For example, 1.2, 12.0, 120.0 
and 0.12 are all given to two-digit precision. Note therefore that 1234.5 would 
be represented as 1200.0 in this device. When any arithmetic operation is carried 
out, the result (including any intermediate calculations) will have two signiﬁ cant 
digits. Thus:
 
 
(
)
130
12
140 rounding down from 142
+
=
  
and similarly:
 
 
(
)
17 / 3
5.7 rounding up from 5.666666...
=
  
 Table 5.2  Word size and 
integer numbers 
 N bits 
 Maximum integer 
 64 
 (2**63)–1 
 9,223,372,036,854,774,807 
 32 
 (2**31)–1 
 2,147,483,647 
 Table 5.3  Word size and real 
numbers 
 N bits 
 Precision 
 Smallest real largest real 
 64 
 15–18 
 ~0.5E–308 
 ~0.8E+308 
 32 
 6–9 
 ~0.3E–38 
 ~1.7E38 
 Note that access to what the hardware supports is dependent 
on the operating system and compiler as well 

66
5 Arithmetic
and:
 
 
=
16*16
260   
where there are more involved calculations, the results can become even less attrac-
tive. Assume we wish to evaluate
 
 (
)
16*16 / 0.14   
 
 We would like an answer in the region of 1828.5718, or, to two signiﬁ cant digits, 
1800.0. If we evaluate the terms within the brackets ﬁ rst, the answer is 260/0.14, or 
1857.1428; 1900.0 on the two-digit machine. Thinking that we could do better, we 
could rewrite the fraction as
 
 (
)
16 / 0.14 * 16  
 
 Which gives a result of 1800.0. 
 Algebra shows that all these evaluations are equivalent if unlimited precision is 
available. 
 Care should also be taken when is one is near the numerical limits of the machine. 
Consider the following:
 Z =  B * C / D  
where B, C and D are all 10 30 and we are using 32-bit ﬂ oating point numbers where 
the maximum real is approximately 10 38  . Here the product B * C generates a number 
of 10 60 —beyond the limits of the machine. This is called overﬂ ow as the number is 
too large. Note that we could avoid this problem by retyping this as
 Z =  B * C / D)  
where the intermediate result would now be 10 30 /10 30 , i.e., 1. 
 There is an inverse called underﬂ ow when the number is too small, which is 
illustrated below:
 Z =  X1 * Y1 * Z1  
where X1 and Y1 are 10 −20 and Z1 is 10 20 . The intermediate result of X1 * Y1 is 
10 −40 —again beyond the limits of the machine. This problem could have been over-
come by retyping as
 Z =  X1 * (Y1 * Z1)  
 This is a particular problem for many scientists and engineers with all machines 
that use 32-bit arithmetic for integer and real calculations. This is because there are 
a number of physical constants (Plank constant, elementary charge, Bohr magneton 
etc.,) that will cause arithmetic problems due to their size. This is rarely a problem 
with machines with hardware support for 64-bit arithmetic. 
 How we get around this problem and how we move our programs from one 
platform to another making sure that we are working with the same precision and 
same range of numbers are covered in detail in the next section. 

67
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
 5.7  Health Warning: Optional Reading, Beginners 
are Advised to Leave Until Later 
 It is very important in scientiﬁ c programming to know the range and precision of 
data on the hardware platform on which we are working. The facilities provided in 
Fortran now allow programmers to specify the range and precision they wish to use 
and the compiler will choose an appropriate type. 
 If it is not possible to offer the precision and range requested the compiler returns 
an error code. To avoid this happening the programmer needs to query the computer 
ﬁ rst for details of its data representations before trying to run a program which 
speciﬁ es range and precision. 
 In order to do this we use the  kind intrinsic function, (intrinsic functions are 
covered in depth in Chapter 12 and Appendix C), e.g.:
 real :: x  
 print *, 'Kind number for X  =  ',kind(x)  
 This will print out the  kind number used by your system to represent default real 
variables. These  kind numbers are arbitrary and there is usually no meaning attached 
to them. 
 5.7.1  Example 5: Default Kinds 
 Consider the following program, which demonstrates the use of the  kind function: 
 It is worthwhile actually typing this program in and seeing what answers you get 
for the system you are working on. We have examples of several compilers below.
gfortran 4.3.4, cygwin, Windows.
 integer 4  
 real 4 

68
5 Arithmetic
 char 1 
 logical 4  
 complex 4  
 Intel 12.0.1, Windows
 integer 4  
 real 4 
 char 1 
 logical 4  
 complex 4  
 NAG Fortran Builder 5.3, Windows
 integer 3  
 real 1  
 char 1  
 logical 3  
 complex 1  
 Thus it is up to each compiler implementation to decide what  kind numbers are 
associated with each type and  kind variation. Thus the  kind value on its own should 
not be used across platforms to try to achieve portability. 
 In fact, specifying a  kind number actually is not what is intended by the Fortran 
standard, so two intrinsic functions
 selected_int_kind  
and
 selected_real_kind  
are available instead. They are used to specify the range of numbers for integers and 
the range and precision of numbers for reals, and the compiler will return the 
appropriate  kind numbers that it has assigned to such representations. These  kind 
numbers can be assigned to parameters called  kind type parameters, which can be 
used with real and integer type declarations. Let’s consider the two main numeric 
types to see how this works. 
 5.7.2  Selecting Different Integer  Kind Types 
 The Fortran standard speciﬁ es that only one integer  kind needs to be available, but 
often a machine’s architecture or compiler implementation will offer more. Most 
compiler implementations will offer the following:
 8-bit or one-byte integers. 
• 
 16-bit or two-byte integers. 
• 
 32-bit or four-byte integers. 
• 
and 64-bit or eight byte integers will be available on certain platforms and imple-
mentations. The most common reason for choosing 8-bit or 16-bit integers is to 

69
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
reduce the memory requirements of your program and the most common reason for 
choosing 64-bit integers is to solve specialised problems in mathematics requiring 
large integer numbers. 
 To choose an integer kind other than the default, you specify the range of the 
numbers you require it to lie in, in terms of a power of 10; e.g.,
 integer, parameter :: First  =  selected_int_kind (2)  
 integer (First) :: I,J  
 selects an integer kind  parameter , First, with representation which includes all inte-
gers between –10 2 and 10 2 , i.e., numbers in the range −100–100. The integer kind 
 parameter  can be used in brackets after the integer type statement to specify vari-
ables of this integer kind, e.g., I and J. 
 If there is no integer kind representation for the range speciﬁ ed, the  selected_
int_kind  function returns −1. Unfortunately it is not possible to then test for −1 in 
a type statement, i.e., you will get a compile time error message. We suggest that you 
run the program in Sect.  5.7.11 to ﬁ nd the limits of your machine’s architecture 
before trying to specify a kind  parameter  that it can’t support.  
 5.7.3  Selecting Different Real Kind Types 
 The Fortran standard speciﬁ es that there must be at least two representations of the real 
type, the default plus one other. Often there are more, depending on what the underlying 
hardware can support. When working with real data there are two things to specify—range 
and precision. The precision is the minimum number of signiﬁ cant digits (all ﬂ oating point 
numbers are normalised) to which real numbers are stored, and the range is the power of 
10 of the largest number to be represented. So, for example, to specify that a variable R has 
a kind type that supports 15 signiﬁ cant ﬁ gures and a range 10 ±307  we deﬁ ne a real kind 
 parameter , Long, and then use this with the real type declaration for R as follows:
 integer, parameter :: Long =  selected_real_kind(15,307)   
 real (Long) :: R  
 The only problem is if the underlying hardware can’t support this speciﬁ cation, in 
which case the function will return −1 if the requested precision is unavailable, −2 if 
the range is unavailable, and −3 if both are unavailable. As we mentioned earlier with 
integer kinds, it is not possible to test for negative values in a type declaration, so 
before trying to use different kind types, or even just the default types, you need to 
know what kind types your machine supports and their range and precision.  
 5.7.4  Specifying Kind Types for Literal Integer and Real 
Constants 
 A literal constant is a data object whose value cannot change. An integer constant 1 is of 
default integer kind and a real constant 10.3 is a default real constant. If in a program you 
have chosen a real kind type, other than the default, then to be consistent and also to make 

70
5 Arithmetic
sure that all real arithmetic is done to the precision speciﬁ ed, you need to declare all 
real constants to be of this kind type. This is done by giving the literal constant fol-
lowed by an underscore and a kind number or kind type  parameter , e.g.
 constant_kind  
 For the earlier example with a kind type  parameter  Long, a real literal constant 
of this type would be given as
 − 22.36_Long  
 It is not recommended to use the actual kind number because, as we have seen, 
these are not portable across machines. 
 The convention we use throughout this book if we require a numeric kind type 
other than the defaults is to specify a kind type  parameter , e.g.,
 integer, parameter :: Long  =  selected_real_kind (15,307)  
 and then use it with real type declarations, e.g.,
 real (Long) :: R  
 This still doesn’t make programs completely portable across different hardware 
platforms, so you will ﬁ rstly need to run a program which tests the range of data 
representations. Before doing this we need to know a bit more about the underlying 
representation of numerical data on computer systems. 
 5.7.5  Positional Number Systems 
 Most people take arithmetic completely for granted and rarely think much about the 
subject. It is necessary to look at it in a bit more depth if we are to understand what 
the computer is doing in this area. 
 Our way of working with numbers is essentially a positional one. When we look 
at the number 1,024, for example, we rarely think of it in terms of 1 * 1,000 + 0 * 
100 + 2*10 + 4*1. Thus the normal decimal system we use in everyday life is a posi-
tional one, with a base of 10. 
 We are probably aware that we can use other number bases, and 2, 8 and 16 are fairly 
common alternate number bases. As the computer is a binary device it uses base 2. 
 We are also reasonably familiar with a mantissa exponent or ﬂ oating point com-
bination when the numbers get very large or very small, e.g., a parsec is commonly expressed 
as 3.08 * 10 ** 16, and here the mantissa is 3.08, and the exponent is 10 ** 16. 
 The above information will help in understanding the way in which integers and 
reals are represented on computer systems. 
 5.7.6  Bit Data Type and Representation Model 
 The model is only deﬁ ned for positive integers (or cardinal numbers), where they 
are represented as a sequence of binary digits, and is based on the model:

71
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
 
 
-
=
= å
1
0
2
n
k
k
k
i
b
  
where I is the integer value, n is the number of bits, and b k is a bit value of 0 or 1, 
with bit numbering starting at 0, and reading right to left. Thus the integer 43 and bit 
pattern 101011 is given by:
 
 
(
) (
) (
) (
) (
) (
)
43
1*32
0*16
1*8
0*4
1*2
1*1
=
+
+
+
+
+
  
 
 Or
 
 
(
) (
) (
) (
) (
) (
)
4
3
1
0
5
2
43
1*2
0*2
1*2
0*2
1*2
1*2
=
+
+
+
+
+
  
 
 5.7.7  Integer Data Type and Representation Model 
 The integer data type is based on the model
 
 
=
=
= å
1
1
q
k
k
k
i
s
l r
  
where I is the integer value, s is the sign, q is the number of digits (always positive), r is 
the radix or base (integer greater than 1), and lk is a positive integer (less than r). 
 A base of 2 is typical so 1,023 is
 
 
(
) (
) (
) (
) (
) (
) (
)
(
) (
) (
)
8
9
7
6
5
4
3
2
1
0
1023
1*2
1*2
1*2
1*2
1*2
1*2
1*2
1*2
1*2
1*2
=
+
+
+
+
+
+
+
+
+
  
 
 5.7.8  Real Data Type and Representation Model 
 The real data type is based on the model
 
 
-
=
=
å
1
m
e
k
k
k
x
sb
f b
  
where x is the real number, s is the sign, b is the radix or base (greater than 1), m is 
the number of bits in the mantissa, e is an integer in the range e min to e max , and f k is a 
positive number less than b. 
 This means that with, for example, a 32-bit real there would be 8 bits allocated 
to the exponent and 24 to the mantissa. One of the bits in each part would be used 
to represent the sign and is called the sign bit. This reduces the number of bits that 
can actually be used to represent the mantissa and exponent to 31 and 7, respec-
tively. There is also the concept of normalisation, where the exponent is adjusted so 
that the most signiﬁ cant bit is in position 22—bits are typically numbered 0–22, 
rather than 1–23. This form of representation is not new, and is ﬁ rst documented 

72
5 Arithmetic
around 1750 BC, when Babylonian mathematicians used a sexagesimal (radix 60) 
positional notation. It is interesting that the form they used omitted the exponent! 
 This is the theoretical basis of the representation of these three data types in 
Fortran. 
 This information together with the following provide a good basis for writing 
portable code across a range of hardware. 
 5.7.9  IEEE 754 
 The ﬁ rst standard IEEE 754: 1985 covered binary ﬂ oating point arithmetic. The 
later IEEE 754: 1987 standard added decimal arithmetic. 
 A considerable amount of hardware now offers support for the IEEE 754 stan-
dard. The standard can be purchased from
 
• http://standards.ieee.org 
 Work is under way on the next version and you can ﬁ nd out details of the current 
state of play at
 
• http://grouper.ieee.org/groups/754/ 
 There are quite a lot of good links from this site. 
 5.7.10  Testing the Numerical Representation of Different 
Kind Types on a System 
 You are now ready to write or adapt a program to run on your system in order to test 
the range of  integer  kind types and the range and precision of real kind types. 
 The following program selects several integer and real kind types and by calling 
the intrinsic functions KIND, HUGE, PRECISION and EPSILON produces most of 
the information you need to know about for these kind types. Table  5.4 provides 
details of what these functions do. 
 5.7.11  Example 6: Using the Numeric Enquiry Functions 
 Using the numeric enquiry functions A complete program using the above is as follows:
 Table 5.4  Numeric query 
functions 
 function name  
 Simple explanation 
 kind (x)  
 Returns the kind type 
 tiny (x)  
 Returns the smallest number 
 huge (x)  
 Returns the largest number 
 precision (x)  
 Returns the decimal precision 
 epsilon (x)  
 Smallest difference between two reals 

73
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
 program ch0506  
 implicit none  
 ! 
 ! examples of the use of the kind  
 ! function and the numeric inquiry functions  
 ! 
 ! integer arithmetic  
 ! 
 ! 32 bits is a common word size,  
 ! and this leads quite cleanly  
 ! to the following  
 ! 8 bit integers  
 ! −128 to 127 10**2  
 ! 16 bit integers  
 ! −32768 to 32767 10**4  
 ! 32 bit integers  
 ! −2147483648 to 2147483647 10**9  
 ! 
 ! 64 bit integers are increasingly available.  
 ! this leads to  
 ! −9223372036854775808 to  
 ! 9223372036854775807 10**19  
 ! 
 ! you may need to comment out some of the following  
 ! depending on the hardware platform and compiler  
 ! that you use.  
 Integer                :: I  
 integer ( selected_int_kind( 2)) :: i1  
 integer ( selected_int_kind( 4)) :: i2  
 integer ( selected_int_kind( 9)) :: i3  
 integer ( selected_int_kind(10)) :: i4  
 ! real arithmetic  
 ! 
  ! 32 and 64 bit reals are normally available.  
 ! 
 ! 32 bit reals 8 bit exponent, 24 bit mantissa  
 ! 
 ! 64 bit reals 11 bit exponent 53 bit mantissa  
 ! 
 real :: r  
 real ( selected_real_kind( 6, 37)) :: r1  
 real ( selected_real_kind(15,307) ) :: r2  
 real ( selected_real_kind(15,310) ) :: r3 
 print *, ' '  
 print *, 'integer values'  
 print *, 'kind   huge'  
 print *,' '  

74
5 Arithmetic
 print *,' ',kind(I ),' ',huge(I )  
 print *, ' '  
 print *,' ',kind(i1 ),' ',huge(i1 )  
 print *,' ',kind(i2 ),' ',huge(i2 )  
 print *,' ',kind(i3 ),' ',huge(i3 )  
 print *,' ',kind(i4 ),' ',huge(i4 )  
 print *, ' '  
 print *, ' real values'  
 print *, ' kind huge ' , &  
 'precision epsilon'  
 print *, ' '  
 print *, ' ',kind®,' ' ,huge®,& 
 ' ',precision®,' ',epsilon® 
 print *, ' '  
 print *, ' ',kind(r1 ),' ',huge(r1 ),&  
 ' ',precision(r1),' ',epsilon(r1)  
 print *, ' ',kind(r2 ),' ',huge(r2 ),&  
 ' ',precision(r2),' ',epsilon(r2)  
 print *,' ',kind(r3 ),' ',huge(r3 ),&  
 ' ',precision(r3),' ',epsilon(r3)  
 end program ch0506  
 The output from the Intel compiler under Windows is: 

75
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
 The output from the gfortran (cygwin) compiler under Windows is:   
 The output from the same compiler under SuSe Linux, same dual boot system. 

76
5 Arithmetic
 The NAG Fortran Builder output: 

77
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
 The Oracle Solaris Studio output: 
 Run this program on whatever system you have access to and compare the output 
with the above examples. 
 5.7.12  Example 7: Binary Representation of Different Integer 
Kind Type Numbers 
 Binary representation of different integer kind type numbers For those who wish to 
look at the internal binary representation of integer numbers with a variety of kinds, 
we have included the following program
 selected_int_kind ( 2) means provide at least an integer representation with 
numbers between–10 2 and + 10 2 . 
 selected_int_kind ( 4) means provide at least an integer representation with 
numbers between–10 4 and + 10 4 . 
 selected_int_kind ( 9) means provide at least an integer representation with 
numbers between-10 9 and + 10 9 . 
 We use the  int function to convert from one integer representation to another. 

78
5 Arithmetic
 We use the logical function  btest to determine whether the binary value at that 
position within the number is a zero or a one, i.e., if the bit is set. 
 I_in_Bits is a character string that holds a direct mapping from the internal binary 
form of the integer and a text string that prints as a sequence of zeros or ones:   

79
5.7 Health Warning: Optional Reading, Beginners are Advised to Leave Until Later 
 The do loop indices follow the convention of an 8-bit quantity starting at bit 0 
and ending at bit 7, 16-bit quantities starting at 0 and ending at 15, etc. 
 The numbers written out follow the conventional mathematical notation of hav-
ing the least signiﬁ cant quantity at the right-hand end of the digit sequence, i.e., 
with 127 in decimal we have 1 * 100, 2*10 and 7 * 1, so 00100001 in binary means 
1 * 32 + 1 * 1 decimal. 
 Try running this program on the system you are using. Does it produce the results 
you expect? Experiment with a variety of numbers. Try at least the following 0, + 1, 
–1, –128, 127, 128, –32768, 32767, 32768. 
 5.7.13  Example 8: Binary Representation of a Real Number 
 The following program is a simple variant of the previous one, but we now look at 
a ﬂ oating point number:
 program ch0508  
 !  
 ! use the bit functions in Fortran to write out a  
 ! 32 bit integer number equivalenced to a real  
 ! using the transfer intrinsic as a sequence of  
 ! zeros and ones  
 !  
 implicit none  
 integer 
:: I, J  
 character (len =   32) 
 ::I_in_Bits =   " "  
 real 
 :: x =   −1.0 
 print *,' 1 
2 
3'  
 print *,'1234567890123456789012345678901234567890'  
 print *,I_in_Bits  
 I =   transfer(x,I)  
 do J =   0,31 
 if (btest(i,J)) then  
 I_in_Bits(32-J:32-J) =   '1'  
 else 
 I_in_Bits(32-J:32-J) =   '0'  
 end if  
 end do  
 print *,x  
 print *,I_in_Bits  
 end program ch0508  
 We use the intrinsic function transfer to help out here. The  btest intrinsic takes an 
integer argument, so we need to copy the bit pattern of the real number into an 
integer variable. 

80
5 Arithmetic
 5.7.14  Summary of How to Select the Appropriate Kind Type 
 To write programs that will perform arithmetically in a similar fashion on a variety 
of hardware requires an understanding of:
 The integer data representation model and in practice the word size of the various 
• 
integer kind types. 
 The real data representation model and in practice the word size of the various 
• 
real kind types and the number of bits in both the mantissa and exponent. 
 Armed with this information we can then choose a kind type that will ensure 
minimal problems when moving from one platform to another. End of health 
warning! 
 5.8  Variable Status 
 Fortran has two concepts regarding the status of a variable: deﬁ ned and undeﬁ ned. 
If a program does not provide an initial value (in a type statement) for a variable 
then its status is said to be undeﬁ ned. Consider the following code segment taken 
from the earlier example that calculated the sum and average of three numbers:
 real :: N1, N2, N3, Average =  0.0, Total =  0.0 
integer :: N =  3  
 In the above the variables Average, Total and N all have a deﬁ ned status. However, 
N1, N2 and N3 are said to be undeﬁ ned. The use of undeﬁ ned values is implementa-
tion dependent and therefore not portable. Care must be taken when writing programs 
to ensure that your variables have a deﬁ ned status wherever possible. We will look 
at this area again in subsequent chapters. 
 5.9  Summary 
 The following are some practical rules and guidelines:
 Learn the rules for the evaluation of arithmetic expressions. 
• 
 Break expressions down where necessary to ensure that the expressions are eval-
• 
uated in the way you want. 
 Take care with truncation owing to integer division in an expression. Note that 
• 
this will only be a problem where both parts of the division are  integer. 
  Take care with truncation owing to the assignment statement when there is an inte-
• 
ger on the left-hand side of the statement, i.e., assigning a real into an  integer. 
variable.  
 When you want to set up constants which will remain unchanged throughout the 
• 
program, use the  parameter statement. 

81
5.10 Problems
 do not confuse precision and accuracy. 
• 
  Learn what the default  
• 
kinds are for the numeric types you work with, what the 
maximum and minimum values and precision are for real data, and what the 
maximum and minimum are for  integer data. 
 You have been introduced to the use of the functions  
• 
digits , huge and  pre-
cision, and some of the concepts involved in their use. We will look at func-
tions in much greater depth later on. 
 5.10  Problems 
 1.  Compile and run examples 1 through 3 in this chapter. 
 2.  Have another look at example 4. Compile and run it. It will generate an error on 
some systems. Can you see where the error is? 
 3.  Write a program to calculate the period of a pendulum. This is given mathemati-
cally as
 
 
π
= 2
9.81
length
t
  
use the following Fortran arithmetic assignment statement:
 T =  2 * PI * (LENGTH / 9.81) ** .5  
 The length (LENGTH) is in metres, and the time (T) in seconds.  p was given a 
value earlier in this chapter. 
 Repeat the above using two other methods. Try a hand-held calculator and a 
spreadsheet. Do you get the same answers? 
 4.  Base conversion. 
 In this chapter you have seen a brief coverage of base conversion. The following 
program illustrates some of the problems that can occur when going from base 
10 to base 2 and back again. Which numbers will convert without loss?
 program base_conversion  
 implicit none  
 real :: x1 =  1.0 
 real :: x2 =  0.1 
 real :: x3 =  0.01 
 real :: x4 =  0.001 
 real :: x5 =  0.0001 
 print *,' ',x1  
 print *,' ',x2  
 print *,' ',x3  
 print *,' ',x4  

82
5 Arithmetic
 print *,' ',x5  
 end program base conversion  
 Which do you think will provide the same number as originally entered? 
 5.  Simple subtraction. In this chapter we looked at representing ﬂ oating point num-
bers in a ﬁ nite number of bits. 
 Try the following program:
 program subtract  
 implicit none  
 real :: a =  1.0002  
 real :: b =  1.0001  
 real :: c 
 c =  a-b 
 print *,a  
 print *,b  
 print *,c  
 end program subtract 
 6.  Expression equivalence. We introduced some of the rules that apply in Fortran 
for expression evaluation. In mathematics the following is true:
 
 (
) (
) (
) (
)
-
=
-
=
-
+
2
2
x
y
x*x
y*y
x
y * x
y   
 
 Try the following program:
 program expression_equivalence  
 ! 
 ! simple evaluation of x*x-y*y  
 ! when x and y are similar  
 ! 
 ! we will evaluate in three ways.  
 ! 
 implicit none  
 real :: x =  1. 002  
 real :: y =  1. 001  
 real :: t1, t2, t3, t4, t5 
 t1 =  x-y 
 t2 =  x +  y 
 print *,t1  
 print *,t2  
 t3 =  t1*t2 
 t4 =  x**2-y**2  
 t5 =  x*x-y*y  
 print *,t3  
 print *,t4  
 print *,t5  
 end program expression_equivalence  

83
5.11 Bibliography
 Solve the problem with pencil and paper, calculator and Excel. 
 The last three examples show that you must be careful when using a computer to 
solve problems. 
 7.  The following is a simple variant of ch0504. In this case we initialise light year 
in an assignment statement. do you think you will get the same results as from 
running the earlier example?
 program ch0504p  
 implicit none  
 real :: Light_Minute, Distance, Elapse  
 integer :: Minute, Second  
 real :: Light_Year  
 ! Light_year : Distance travelled by light  
 ! in one year in km  
 ! Light_minute : Distance travelled by light  
 ! in one minute in km  
 ! Distance : Distance from sun to earth in km  
 ! Elapse : Time taken to travel a  
 ! distance (Distance) in minutes  
 ! Minute : integer number part of elapse  
 ! Second : integer number of seconds  
 ! equivalent to fractional part of elapse  
 ! 
 Light_Year =  9.46*10**12  
 Light_minute  =  Light_Year/(365.25 * 24.0 * 60.0)  
 Distance  =  150.0 * 10 ** 6  
 Elapse  =  Distance / Light_minute  
 Minute  =  Elapse  
 Second  =  (Elapse - Minute) * 60  
 print *, ' Light takes ' , Minute, ' Minutes'  
 print *,' ' , Second,' Seconds'  
 print *, ' To reach the earth from sun' 
end program ch0504p  
 5.11  Bibliography 
 Some understanding of numerical analysis is essential for successful use of Fortran 
when programming. As Froberg says “numerical analysis is a science—computation 
is an art.” The following are some of the more accessible books available. 
 Froberg, C.E.: Introduction to Numerical Analysis. Addison-Wesley, Reading 
(1969) 
 The short chapter on numerical computation is well worth a read; it covers some 
of the problems of conversion between number bases and some of the errors that are 

84
5 Arithmetic
introduced when we compute numerically. The Samuel Johnson quote owes its 
inclusion to Froberg! 
 IEEE, IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Std 
754–2008, Institute of Electrical and Electronic Engineers Inc. 
 The formal deﬁ nition of IEEE 754. This is available for purchase at 
http://www.techstreet.com/standards/ieee/754_2008?product_id=1745167 
as both a pdf and printed version. 
 Knuth, D.: Seminumerical Algorithms. Addison-Wesley, Reading (1969) 
 A more thorough and mathematical coverage than Wakerly. The chapter on posi-
tional number systems provides a very comprehensive historical coverage of the 
subject. As Knuth points out the ﬂ oating point representation for numbers is very 
old, and is ﬁ rst documented around 1750 B.C. by Babylonian mathematicians. Very 
interesting and worthwhile reading. 
 Sun, Numerical Computation Guide, SunPro (1993) 
 Very good coverage of the numeric formats for IEEE Standard 754 for Binary 
Floating-Point Arithmetic. All SunPro compiler products support the features of 
the IEEE 754 standard. 
 Wakerly, J.F.: Microcomputer Architecture and Programming. Wiley, New York 
(1981) 
 The chapter on number systems and arithmetic is surprisingly easy. There is a 
coverage of positional number systems, octal and hexadecimal number system con-
versions, addition and subtraction of nondecimal numbers, representation of nega-
tive numbers, two’s complement addition and subtraction, one’s complement 
addition and subtraction, binary multiplication, binary division, bcd or binary coded 
decimal representation and ﬁ xed and ﬂ oating point representations. There is also 
coverage of a number of speciﬁ c hardware platforms, including DEC PDP-11, 
Motorola 68000, Zilog Z8000, TI 9900, Motorola 6809 and Intel 8086. A little old 
but quite interesting nevertheless. 

85
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_6, © Springer-Verlag London Limited 2012
 Aims 
 The aims of the chapter are to introduce the fundamental concepts of arrays and do 
loops, in particular:
 To introduce the idea of tables of data and some of the formal terms used to 
• 
describe them:
 Array. 
 –
 Vector. 
 –
 List and linear list. 
 –
 To discuss the array as a random access structure where any element can be 
• 
accessed as readily as any other and to note that the data in an array are all of the 
same type. 
 To introduce the twin concepts of data structure and corresponding control 
• 
structure. 
 To introduce the statements necessary in Fortran to support and manipulate these 
• 
data structures. 
 Chapter 6 
 Arrays 1: Some Fundamentals  
 Thy gifts, thy tables, are within my brain 
 Full charactered with lasting memory. 
 William Shakespeare, The Sonnets 
 Here, take this book, and peruse it well: 
 The iterating of these lines brings gold. 
 Christopher Marlowe, The Tragical History of Doctor Faustus 

86
6 Arrays 1: Some Fundamentals
 6.1  Tables of Data 
 Consider the examples below. 
 6.1.1  Telephone Directory 
 A telephone directory consists of the following kinds of entries: 
 Name 
 Address 
 Number 
 Adcroft A. 
 61 Connaught Road, Roath, Cardiff 
 223309 
 Beale K. 
 14 Airedale Road, Balham 
 745 9870 
 Blunt R.U. 
 81 Stanlake Road, Shepherds Bush 
 674 4546 
 … 
 … 
 … 
 Sims Tony 
 99 Andover Road, Twickenham 
 898 7330 
 This structure can be considered in a variety of ways, but perhaps the most 
common is to regard it as a table of data, where there are three columns and as 
many rows as there are entries in the telephone directory. 
 Consider now the way we extract information from this table. We would scan 
the name column looking for the name we are interested in, and then read along the 
row looking for either the address or telephone number, i.e., we are using the name 
to look up the item of interest. 
 6.1.2  Book Catalogue 
a Catalogue Could Contain: 
 Author(s) 
 Title 
 Publisher 
 Carroll L. 
 Alice through the looking glass 
 Penguin 
 Steinbeck J. 
 Sweet Thursday 
 Penguin 
 Wirth N. 
 Algorithms plus data structures  = program 
 Prentice-Hall 
 Again, this can be regarded as a table of data, having three columns and many rows. 
We would follow the same procedure as with the telephone directory to extract the 
information. We would use the author to look up what books are available. 

87
6.1 Tables of Data
 6.1.3  Examination Marks or Results 
 This could consist of: 
 Name 
 Physics 
 Maths 
 Biology 
 History 
 English 
 French 
 Fowler L. 
 50 
 47 
 28 
 89 
 30 
 46 
 Barron L. W 
 37 
 67 
 34 
 65 
 68 
 98 
 Warren J. 
 25 
 45 
 26 
 48 
 10 
 36 
 Mallory D. 
 89 
 56 
 33 
 45 
 30 
 65 
 Codd S. 
 68 
 78 
 38 
 76 
 98 
 65 
 This can again be regarded as a table of data. This example has seven columns and 
ﬁ ve rows. We would again look up information by using the Name. 
 6.1.4  Monthly Rainfall 
 The following data are a sample of monthly average rainfall for London in inches: 
 Month 
 Rainfall 
 January 
 3.1 
 February 
 2.0 
 March 
 2.4 
 April 
 2.1 
 May 
 2.2 
 June 
 2.2 
 July 
 1.8 
 August 
 2.2 
 September 
 2.7 
 October 
 2.9 
 November 
 3.1 
 December 
 3.1 
 In this table there are 2 columns and 12 rows. To ﬁ nd out what the rainfall was in 
July, we scan the table for July in the Month column and locate the value in the same 
row, i.e., the rainfall ﬁ gure for July. 
 These are just some of the many examples of problems where the data that are 
being considered have a tabular structure. Most general purpose languages therefore 
have mechanisms for dealing with this kind of structure. Some of the special names 
given to these structures include:
 Linear list. 
• 
 List. 
• 
 Vector. 
• 
 Array. 
• 

88
6 Arrays 1: Some Fundamentals
 The term used most often here, and in the majority of books on Fortran 
 programming, is array. 
 6.2  Arrays in Fortran 
 There are three key things to consider here:
 The ability to refer to a set or group of items by a single name. 
• 
 The ability to refer to individual items or members of this set, i.e., look 
• 
them up.  
 The choice of a control structure that allows easy manipulation of this set or array.  
• 
 6.2.1  The d imension Attribute 
 The dimension attribute deﬁ nes a variable to be an array. This satisﬁ es the ﬁ rst 
requirement of being able to refer to a set of items by a single name. Some examples 
are given below:
 real ,   dimension(1:100) :: Wages  
 integer , dimension(1:10000) :: Sample  
 For the variable Wages it is of type  real and an array of dimension or size 100, i.e., 
the variable array Wages can hold up to 100 real items. 
 For the variable Sample it is of type  integer and an array of dimension or size 
10,000, i.e., the variable Sample can hold up to 10,000 integer items. 
 6.2.2  An Index 
 An index enables you to refer to or select individual elements of the array. In the 
telephone directory, book catalogue, exam marks table and monthly rainfall examples 
we used the name to index or look up the items of interest. We will give concrete 
Fortran code for this in the example of monthly rain fall. 
 6.2.3  Control Structure 
 The statement that is generally used to manipulate the elements of an array is the 
do statement. It is typical to have several statements controlled by the do statement, 
and the block of repeated statements is often called a  do  loop. Let us look at two 
complete programs that highlight the above.  

89
6.3 Example 1: Monthly Rainfall
 6.3  Example 1: Monthly Rainfall 
 Let us look at this earlier example in more depth now. Consider the following: 
 Month 
 Associated integer 
representation 
 Array and index 
 Rainfall value 
 January 
 1 
 RainFall(1) 
 3.1 
 February 
 2 
 RainFall(2) 
 2.0 
 March 
 3 
 RainFall(3) 
 2.4 
 April 
 4 
 RainFall(4) 
 2.1 
 May 
 5 
 RainFall(5) 
 2.2 
 June 
 6 
 RainFall(6) 
 2.2 
 July 
 7 
 RainFall(7) 
 1.8 
 August 
 8 
 RainFall(8) 
 2.2 
 September 
 9 
 RainFall(9) 
 2.7 
 October 
 10 
 RainFall(10) 
 2.9 
 November 
 11 
 RainFall(11) 
 3.1 
 December 
 12 
 RainFall(12) 
 3.1 
 Most of you should be familiar with the idea of the use of an integer as an alternate 
way of representing a month, e.g., in a date expressed as 1/3/2000, for 1st March 
2000 (anglicised style) or January 3rd (americanised style). Fortran, in common 
with other programming languages, only allows the use of integers as an index into 
an array. Thus when we write a program to use arrays we have to map between 
whatever construct we use in everyday life as our index (names in our examples of 
telephone directory, book catalogue, and exam marks) to an integer representation 
in Fortran. The following is an example of an assignment statement showing the use 
of an index:
 RainFall(1) =  3.1 
 We saw earlier that we could use the  dimension attribute to indicate that a vari-
able was an array. In the above example Fortran statement our array is called 
RainFall. In this statement we are assigning the value 10.4 to the ﬁ rst element of the 
array; i.e., the rainfall for the month of January is 10.4. We use the index 1 to repre-
sent the ﬁ rst month. Consider the following statement:
 SummerAverage  =  (RainFall(6)  +  RainFall(7)  +   & RainFall(8))/3  
 This statement says take the values of the rainfall for June, July and August, add 
them up and then divide by 3, and assign the result to the variable SummerAverage, 
thus providing us with the rainfall average for the three summer months—Northern 
Hemisphere of course. 
 The following program reads in the 12 monthly values from the terminal, 
computes the sum and average for the year, and prints the average out.

90
6 Arrays 1: Some Fundamentals
 program ch0601  
 implicit none  
 real :: Total =  0.0, Average =  0.0 
 real , dimension(1:12) :: RainFall  
 integer :: Month 
 print *,' type in the rainfall values'  
 print *,' one per line'  
 do Month =  1,12 
 read *, RainFall(Month)  
 enddo 
 do Month =  1,12 
 Total =  Total +  RainFall(Month)  
 enddo 
 Average  =  Total / 12  
 print *,' Average monthly rainfall was'  
 print *, Average  
 end program ch0601  
 RainFall is the array name. The variable Month in brackets is the index. It takes 
on values from 1 to 12 inclusive, and is used to pick out or select elements of the 
array. The index is thus a variable and this permits dynamic manipulation of the 
array at run time. The general form of the  DO statement is
 do Counter  =  Start, End, Increment  
 The block of statements that form the loop is contained between the do state-
ment, which marks the beginning of the block or loop, and the  enddo statement, 
which marks the end of the block or loop. 
 In this program, the do loops take the form:
 do Month =  1,12 
start  
  … 
 
body 
 enddo 
end 
 The body of the loop in the program above has been indented. This is not required 
by Fortran. However it is good practice and will make programs easier to follow. 
 The number of times that the  do loop is executed is governed by the last part 
of the do statement, i.e., by the
 Counter  =  Start, End, Increment  
 Start as it implies, is the initial value which the counter (or index, or control vari-
able) takes. Each time the loop is executed, the value of the counter will be increased 
by the value of increment, until the value of end is reached. If increment is omitted, 
it is assumed to be 1. No other element of the do statement may be omitted. In order 
to execute the statements within the loop (the body) it must be possible to reach end 
from start. Thus zero is an illegal value of increment. In the event that it is not 
possible to reach end, the loop will not be executed and control will pass to the state-
ment after the end of the loop. 

91
6.3 Example 1: Monthly Rainfall
 In the example above, both loops would be executed 12 times. In both cases, the 
ﬁ rst time around the loop the variable MONTH would have the value 1, the second 
time around the loop the variable MONTH would have the value 2, etc., and the last 
time around the loop MONTH would have the value 12. 
 A summation:
 
 
=
=∑
12
1
·
i
i
i
x   
is often expressed in Fortran as a loop as in this example:
 do Month =  1,12 
 Total =  Total +  RainFall(Month)  
 enddo 
 6.3.1  Possible Missing Data 
 The rainfall data in this example has been taken from the UK Met Ofﬁ ce site. Visit
 http://www.metofﬁ ce.gov.uk/climate/uk/stationdata  
to see where some of the stations are. One of us was born in Wales, the other in 
Yorkshire so we have chosen stations accordingly. 
 The following is one of the mid Wales stations:
  http://www.metofﬁ ce.gov.uk/climate/uk/stationdata/cwmys 
twythdata.txt  
 Here is a sample of data from this site for 2 years. 
 yyyy 
 mm 
 tmax 
 tmin 
 af 
  rain  
 sun 
 degC  
 degC  
 days 
  mm 
 hours  
 1959 
 1 
 4.5  
  −1.9  
 20 
 ––– 
 57.2  
 1959  
  2 
 7.3  
 0.9  
 15 
 –––  
 87.2 
 1959  
 3 
  8.4  
  3.1  
 3 
 –––  
 81.6 
 1959 
  4 
 10.8  
 3.7  
 1 
 ––– 
 107.4 
 1959 
 5 
 15.8  
 5.8  
 1 
 ––– 
 213.5 
 1959  
  6 
  16.9  
 8.2  
 0 
 –––  
 209.4 
 1959 
  7 
 18.5  
 9.5  
 0 
 ––– 
 167.8 
 1959 
 8 
 19.C  
 10.5  
 0 
 ––– 
 164.8 
 1959  
  9  
 18.3  
 5.9  
  0 
 ––– 
  196.5 
 1959 
  19 
  14.8  
 7.9  
 1 
 ––– 
 101.1  
 1959 
 11 
 8.8  
  3.9  
 3 
 ––– 
 38.9  
 1959  
  12  
 7.2  
 2.5  
 3 
  ––– 
 19.2  
 1961  
 1  
 5.4  
  0.2  
 11 
 144.8  
 31.0 
 1961  
  2 
 8.7  
 2.9  
 2 
 112.5 
 45.2 
 1961  
  3  
 10.2  
 2.1  
 10 
 77.2 
 102.6 
 1961  
 4 
 11.9  
 5.0  
 1 
 130.7 
 83.9  
 1961 
 5 
 –––  
  –––  
 ––– 
  66.3  
 173.7  
(continued)

92
6 Arrays 1: Some Fundamentals
 yyyy 
 mm 
 tmax 
 tmin 
 af 
  rain 
 sun  
 degC  
 degC  
 days 
 mm 
 hours 
 1961 
  6 
 –––  
 7.4  
 ––– 
 66.1 
 190.6 
 1961  
  7 
 16.7  
 8.2  
  0 
 141.1 
 149.2 
 1961  
  8  
 16.8  
 10.1  
 0 
 149.5 
  106.6  
 1961  
 9 
  17.4  
 9.3  
 0 
 134.8  
  79.7  
 1962  
  5 
  4.2  
  3 
 117.8  
 102.2  
 1962  
  6  
 6.8  
  1 
 72.8  
 163.9  
 1962  
 7  
 16.8  
 9.1  
 0 
 56.7  
 –  
 1962 
  8 
 15.6  
 9.3  
 0 
 236.2 
 – 
 1962  
  9  
 14.6  
 7.8  
  1 
 218.C  
 – 
 1962  
  19  
  –––  
 –––  
 ––– 
 69.7 
  – 
 1962 
 11 
 7.6  
  1.8  
 9 
 85.2 
  – 
 1962  
  12  
 5.3  
 −1.0  
 18 
 204.4  
 – 
 Wales is relatively wet for the UK! 
 The following station is Whitby:
 http://www.metofﬁ ce.gov.uk/climate/uk/stationdata/whitb 
ydata.txt  
 Here is a sample of the Whitby data. 
 YYYY  
 mm  
 tmax  
 tmin  
 af 
 rain 
 sun  
 degC  
  degC  
  days 
 mm 
 hours 
 1968  
 1 
 6.9  
 1.7  
 12 
 24.4 
 1968  
  2 
 4.3  
 −0.7  
 16 
 45.1 
 1968 
  3 
 9.4  
 3.4  
 2 
 34.5 
 1968  
 4 
 10.8  
 1.6  
 9 
 28.8 
 1968 
 5 
  10.6  
 2.8  
  2 
 37.1  
 1968  
  6 
 16.7  
  6.8  
  0  
 58.5 
 1968 
  7 
 15.C  
 8.1  
 0 
 81.4 
 1968  
 8 
 16.3  
 9.6  
 0 
 28.0 
 1968 
 9 
 15.7  
 –––  
 –––  
 66.0 
 1968  
 10 
 14.7  
 –––  
 ––– 
 35.2 
 1968 
 11  
  8.5  
 5.1  
 1 
 35.1 
 1968  
 12 
 5.7  
 1.5  
 9 
 – 
 1969  
  1 
 7.3  
 2.2  
  6 
 48.4  
 1969 
  2 
 3.1  
 −0.8  
 14 
  46.3  
 1969  
 3  
  4.5  
 0.4  
 9 
  – 
 1969 
 4 
 8.9  
 2.9  
 4  
 52.6 
 1969  
  5 
 11.9  
  6.4  
 0 
 73.7 
 1969 
  6 
 16.0  
 8.2  
 0 
 53.0 
 1969  
 7 
 19.6  
  11.9  
 0 
 39.0 
 1969  
  8  
  17.7  
 12.2  
 0 
 20.6 
 1969 
  9 
 16.5  
 10.3  
 0 
 49.2 
 1969  
 10  
 15.4  
 9.0  
 0 
  9.0 
 1969 
  11 
 7.9  
 2.2  
 4  
 77.2 
 1969  
 12 
  5.8  
  1.4  
 9 
 64.1 

93
6.4 Example 2: People’s Weights and Setting the Array Size with a Parameter 
 Bram Stoker found some of his inspiration for Dracula after staying in the 
town. 
 If you look at the data for some of these stations you will notice that data is 
missing for some months. 
 How do you think you could cope with missing data in Fortran? 
 The SQL standard has the concept of nulls or missing values, and missing data 
in a statistics package is commonly ﬂ agged by an exceptional value e.g. -999. 
 6.4  Example 2: People’s Weights and Setting 
the Array Size with a Parameter 
 In the table below we have ten people, with their names as shown. We associate each 
name with a number—in this case we have ordered the names alphabetically, and 
the numbers therefore reﬂ ect their ordering. WEIGHT is the array name. The number 
in brackets is called the index and it is used to pick out or select elements of the 
array. The table is read as the ﬁ rst element of the array WEIGHT has the value 85, 
the second element has the value 76, etc. 
 Person 
 Associated integer 
representation 
 Array and index 
 Associated value 
 Andy 
 1 
 Weight( 1) 
 85 
 Barry 
 2 
 Weight( 2) 
 76 
 Cathy 
 3 
 Weight( 3) 
 85 
 Dawn 
 4 
 Weight( 4) 
 90 
 Elaine 
 5 
 Weight( 5) 
 69 
 Frank 
 6 
 Weight( 6) 
 83 
 Gordon 
 7 
 Weight( 7) 
 64 
 Hannah 
 8 
 Weight( 8) 
 57 
 Ian 
 9 
 Weight( 9) 
 65 
 Jatinda 
 10 
 Weight(10) 
 76 
 In the ﬁ rst example we so-called hard coded the number 12, which is the number 
of months, into the program. It occurred four times. Modifying the program to work 
with a different number of months would obviously be tedious and potentially error 
prone. 
 In this example we parameterise the size of the array and reduce the effort 
involved in modifying the program to work with a different number of people:
 program ch0602  
 ! The program reads up to number_of_people weights  
 ! into the array Weight  
 ! Variables used  
 ! Weight, holds the weight of the people  
 ! Person, an index into the array  

94
6 Arrays 1: Some Fundamentals
 ! Total, total weight  
 ! Average, average weight of the people  
 ! Parameters used  
 ! NumberOfPeople ,10 in this case.  
 ! The weights are written out so that  
 ! they can be checked  
 ! 
 implicit none  
 integer , parameter :: number_of_people  =  10 
 real :: total  =  0.0, average  =  0.0 
 integer :: person  
 real , dimension(1:number of people) :: weight 
 do person =  1,number_Of_people 
 print *, ' type in the weight for person ',person  
 read *,weight(person)  
 total =  total +  weight(person)  
 enddo 
 average  =  total / number_of_people  
 print *, ' The total of the weights is ',total  
 print *, ' Average Weight is ',average  
 print *,' ',number_of_people,' Weights were '  
 do person =  1,number_of_people 
 print *,weight(person)  
 enddo 
 end program ch0602  
 6.5  Summary 
 The  dimension attribute declares a variable to be an array, and must come at the 
start of a program unit, with other declarative statements. It has two forms and 
examples of both of them are given below. In the ﬁ rst case we explicitly specify the 
upper and lower :
 real , dimension(1:number_of_people) :: Weight  
 In the second case the lower limit defaults to 1
 real , dimension(number_of_people) :: Weight  
 The latter form will be seen in legacy code, especially Fortran 77 code suites. 
 The  parameter attribute declares a variable to have a ﬁ xed value that cannot 
be changed during the execution of a program. In our example above note that this 
statement occurs before the other declarative statements that depend on it. To recap 
the statements covered so far, the order is summarised below. 

95
6.6 Problems
 program 
 First statement 
 integer 
 In any order and the 
 real 
 Declarative 
 dimension and parameter 
 character 
 attributes are added here 
 Arithmetic assignment 
 In any order 
 print * 
 read * 
 Executable 
 do 
 enddo 
 end program 
 Last statement 
 We choose individual members using an index, and these are always of integer 
type in Fortran. 
 The do loop is a very convenient control structure for manipulating arrays, and 
we use indentation to clearly identify loops. 
 6.6  Problems 
  1.  Compile and run example 1 from this chapter. If you live in the UK visit the Met 
Ofﬁ ce site mentioned earlier and choose a site near you, and a year of interest, 
making sure that the data set is complete for that year. 
 If you don’t live in the UK is there a site similar to the Met Ofﬁ ce site that has 
data for the country you are from? 
  2.  Compile and run program 2. 
  3.  Using a do loop and an array rewrite the program which calculated the average 
of three numbers to ten. 
 4.1  Modify the program that calculates the total and average of people’s weights to 
additionally read in their heights and calculate the total and average of their 
heights. Use the data given below, which have been taken from a group of ﬁ rst 
year undergraduates: 
 Height  
 Weight  
 1.85  
 85  
 1.80  
 76  
 1.85  
 85  
 1.70  
 90  
 1.75  
 69  
 1.67  
 83  
 1.55  
 64  
 1.63  
 57  
 1.79  
 65  
 1.78  
 76  

96
6 Arrays 1: Some Fundamentals
 4.2  Your body mass index is given by your weight (in kilos) divided by your height 
(in metres) squared. Calculate and print out the BMI for each person. 
 Grades of obesity according to Garrow as follows:
 Grade 0 (desirable) 20–24.9 
 Grade 1 (overweight) 25–29.9 
 Grade 2 (obese) 30–40 
 Grad 3 (morbidly obese) >40 
 Ideal BMI range, 
 Men, Range 20.1–25 kg/m 2 
 Women, Range 18.7–23.8 kg/m 2 
 4.3  When working on either a UNIX system or a PC in a DOS box it is possible to 
use the following characters to enable you to read data from a ﬁ le or write output 
to a ﬁ le when running your program:
 character   
 Meaning 
 <  
 
 read from ﬁ le 
 >  
 
 write to ﬁ le 
 On a typical UNIX system we could use
 a.out <  data.txt  >  results.txt  
to read the data from the ﬁ le called data.txt and write the output to a ﬁ le called 
results.txt. 
 On a PC in a DOS box the equivalent would be
 program.exe  <  data.txt  >  results.txt  
 This is a quick and dirty way of developing programs that do simple I/O; 
we don’t have to keep typing in the data and we also have a record of the behav-
iour of the program. Rerun the program that prints out the BMI values to write 
the output to a ﬁ le called results.txt. Examine this ﬁ le in an editor. 
  5.  Modify the program that read in your name to read in ten names. Use an array 
and a do loop. When you have read the names into the array write them out in 
reverse order on separate lines. 
 Hint: Look at the formal syntax of the do statement. 
  6.  Modify the rainfall program (which assumes that the measurement is in inches) 
to convert the values to centimetres. One inch equals 2.54 cm. Print out the two 
sets of values as a table. 
 Hint: use a second array to hold the metric measurements. 
  7.  Combine the programs that read in and calculate the average weight with the 
one that reads in peoples names. The program should read the weights into one 
array and the names into another. Allow 20 characters for the length of a name. 

97
6.6 Problems
print out a table linking names and weights. 
  8.  In an earlier chapter we used the following formula to calculate the period of a 
pendulum: 
 
 
(
)
T
*PI* LENGTH / 9.81 **.5
2
=
  
write a program that uses a do loop to make the length go from 1 to 10 m in 1 m 
increments. 
 Produce a table with two columns, the ﬁ rst of lengths and the second of 
periods. 

99
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_7, © Springer-Verlag London Limited 2012
 Aims 
 The aims of the chapter are to extend the concepts introduced in the previous chap-
ter and in particular:
 To set an array size at run time – allocatable arrays. 
• 
 To introduce the idea of an array with more than one dimension and the corre-
• 
sponding control structure to permit easy manipulation of higher-dimensioned 
arrays. 
  To introduce an extended form of the dimension attribute declaration, and the 
• 
corresponding alternative form to the do statement, to manipulate the array in 
this new form. 
 To introduce the do loop as a mechanism for the control of repetition in general, 
• 
not just for manipulating arrays. 
 To formally deﬁ ne the block do syntax. 
• 
 Chapter 7 
 Arrays 2: Further Examples  
 Sir, In your otherwise beautiful poem (The Vision of Sin) there 
is a verse which reads 
 Every moment dies a man, 
 every moment one is born. 
 Obviously this cannot be true and I suggest that in the next 
edition you have it read 
 Every moment dies a man, 
 every moment 1 1/16 is born. 
 Even this value is slightly in error but should be sufﬁ ciently 
accurate for poetry. 
 Charles Babbage in a letter to Lord Tennyson 

100
7 Arrays 2: Further Examples
 7.1  Varying the Array Size at Run Time 
 The earlier examples set the array size in the following two ways:
 Explicitly using a numeric constant 
• 
 Implicitly using a parameterised variable 
• 
 In both cases we knew the size of the array at the time we compiled the program. 
We may not know the size of the array at compile time and Fortran provides the 
allocatable attribute to accommodate this kind of problem. 
 7.1.1  Example 1: Allocatable Arrays 
 Consider the following example.
 program ch0701  
 ! 
 ! This program is a simple variant of ch0602.  
 ! The array is now allocatable  
 ! and the user is prompted for the  
 ! number of people at run time.  
 ! 
 implicit none  
 integer :: Number_Of_People  
 real :: Total =  0.0, Average =  0.0 
 integer :: Person  
 real , dimension(:) , allocatable :: Weight 
 print *, ' How many people?'  
 read *,Number_Of_People  
 allocate (Weight(1:Number_Of_People))  
 do Person =  1,Number_Of_People 
 print *, ' type in the weight for person ', Person  
 read *,Weight(Person)  
 Total =  Total +  Weight(Person)  
 enddo 
 Average =  Total / Number_Of_People  
 print *, ' The total of the weights is ',Total  
 print *, ' Average Weight is ',Average  
 print *, ' ',Number_of_People,' Weights were '  
 do Person =  1,Number_Of_People 
 print *,Weight(Person)  
 enddo 
  end program ch0701  

101
7.2 Higher-Dimension Arrays
 The ﬁ rst statement of interest is the type declaration with the dimension and 
allocatable attributes, e.g.,
 real , dimension(:) , allocatable :: Weight  
 The second is the allocate statement where the value of the variable Number_of_
people is not known until run time, e.g.,
 allocate(Weight(1:Number_Of_People)) 
 We will look more formally at these statements in Chap.  8 . 
 7.2  Higher-Dimension Arrays 
 There are many instances where it is necessary to have arrays with more than one 
dimension. Consider the examples below. 
 7.2.1  Example 2: Two Dimensional Arrays and a Map 
 Consider the representation of the height of an area of land expressed as a two 
dimensional table of numbers e.g., we may have some information represented in a 
simple table as follows: 
 Latitude  
 Longitude  
 1 
 2 
 3 
 1 
 10.0  
 40.0  
 70.0  
 2 
 20.0  
 50.0  
 80.0  
 3 
 30.0  
 60.0  
 90.0  
 The values in the array are the heights above sea level. The example is obviously 
artiﬁ cial, but it does highlight the concepts involved. For those who have forgotten 
their geography, lines of latitude run east–west (the equator is a line of latitude) and 
lines of longitude run north–south (they go through the poles and are all of the same 
length). In the above table therefore the latitude values are ordered by row and the 
longitude values are ordered by column. 
 A program to manipulate this data structure would involve something like the 
following:
 program ch0702  
 ! Variables used  
 ! Height - used to hold the heights above sea level  
 ! Long - used to represent the longitude  
 ! Lat - used to represent the latitude  
 ! both restricted to integer values.  

102
7 Arrays 2: Further Examples
 ! Correct - holds the correction factor  
 implicit none  
 integer , parameter :: n =  3 
 integer :: Lat , Long  
 real , dimension(1:n,1:n) :: Height  
 real , parameter :: Correct =  10.0 
 do Lat =  1, n 
 do Long =  1, n 
 print *, ' type in value at ',Lat,' ',Long  
 read * , Height (Lat, Long)  
 enddo 
 enddo 
 do Lat =  1, n 
 do Long =  1, n 
 Height(Lat,Long) =  Height(Lat, Long) +  Correct  
 enddo 
 enddo 
 print * , ' Corrected data is '  
 do Lat =  1, n 
 do Long =  1, n 
 print * , Height(Lat,Long)  
 enddo 
 enddo 
 end program ch0702 
 Note the way in which indentation has been used to highlight the structure in 
this example. Note also the use of a textual prompt to highlight which data value 
is expected. Running the program highlights some of the problems with the 
simple I/O used in the example above. We will address this issue in the next 
example. 
 The inner loop is said to be nested within the outer one. It is very common to 
encounter problems where nesting is a natural way to express the solution. Nesting 
is permitted to any depth. Here is an example of a valid nested do loop: 
 This example introduces the concept of two indices, and can be thought of as a 
row and column data structure. 

103
7.2 Higher-Dimension Arrays
 7.2.2  Example 3: Sensible Tabular Output 
 The ﬁ rst example had the values printed in a format that wasn’t very easy to work 
with. In this example we introduce a so-called implied do loop, which enables us to 
produce neat and humanly comprehensible output:
 program ch0703  
 ! Variables used  
 ! Height - used to hold the heights above sea level  
 ! Long - used to represent the longitude  
 ! Lat - used to represent the latitude  
 ! 
both restricted to integer values.  
 implicit none  
 integer , parameter :: n =  3 
 integer :: Lat , Long  
 real , dimension(1:n,1:n) :: Height  
 real , parameter :: Correct =  10.0 
 do Lat =  1,n 
 do Long =  1,n 
 read * , Height (Lat, Long)  
 Height(Lat,Long) =  Height(Lat,Long) +  Correct  
 enddo 
 enddo 
 do Lat =  1,n 
 print * , (Height(Lat,Long),Long =  1,n) 
 enddo 
 end program ch0703 
 The key statement in this example is
 print * , (Height(Lat,Long),Long =  1,n) 
 This is called an implied do loop, as the longitude variable takes on values from 
1 through 3 and will write out all three values on one line. 
 We will see other examples of this statement as we go on. 
 7.2.3  Example 4: Average of Three Sets of Values 
 This example extends the previous one. Now we have three sets of measurements 
and we are interested in calculating the average of these three sets. The two new 
data sets are: 

104
7 Arrays 2: Further Examples
 and 
 and we have chosen the values to enable us to quickly check that the calculations for 
the averages are correct. 
 This program also uses implied do loops to read the data, as data in ﬁ les are 
generally tabular:
 program ch0704  
 ! Variables used  
 ! H1,H2,H3 - used to hold the heights above sea level  
 ! H4 - used to hold the average of the above  
 ! Long - used to represent the longitude  
 ! Lat - used to represent the latitude  
 ! 
both restricted to integer values.  
 implicit none  
 integer , parameter :: n =  3 
 integer :: Lat , Long  
 real , dimension(1:n,1:n) :: H1,H2,H3,H4 
 do Lat =  1,n 
 read * , (H1(Lat,Long), Long =  1,n) 
 enddo 
 do Lat =  1,n 
 read * , (H2(Lat,Long), Long =  1,n) 
 enddo 
 do Lat =  1,n 
 read * , (H3(Lat,Long), Long =  1,n) 
 enddo 
 do Lat =  1,n 
 do Long =  1,n 
  H4(Lat,Long) =  (H1(Lat,Long) +  H2(Lat,Long) +  & 
 
H3(Lat,Long)) / n  
 enddo 
 enddo 
 do Lat =  1, n 
 print * , (H4(Lat,Long),Long =  1,n) 
 enddo 
 end program ch0704 
 The original data was accurate to three signiﬁ cant ﬁ gures. The output from the 
above has spurious additional accuracy. We will look at how to correct this in the 
later chapter on output. 

105
7.2 Higher-Dimension Arrays
 7.2.4  Example 5: Booking Arrangements in a Theatre or Cinema 
 A theatre or cinema consists of rows and columns of seats. In a large cinema or a 
typical theatre there would also be more than one level or storey. Thus, a program to 
represent and manipulate this structure would probably have a 2-d or 3-d array. 
Consider the following program extract: 
 Note here the use of the term parameter in conjunction with the integer declara-
tion. This is called an entity orientated declaration. An alternative to this is an attri-
bute-orientated declaration, e.g.,
 integer :: NR,NC,NF  
 parameter :: NR =  5,NC =  10,NF =  3 
 and we will be using the entity-orientated declaration method throughout the rest of 
the book. This is our recommended method as you only have to look in one place to 
determine everything that you need to know about an entity. 

106
7 Arrays 2: Further Examples
 7.3  Additional Forms of the Dimension Attribute 
and do Loop Statement 
 7.3.1  Example 6: Voltage from −20 to +20 Volts 
 Consider the problem of an experiment where the independent variable voltage var-
ies from −20 to +20 V and the current is measured at 1-volt intervals. Fortran has a 
mechanism for handling this type of problem:
 program ch0706  
 implicit none  
 real , dimension(-20:20) :: Current  
 real :: Resistance  
 integer :: Voltage 
 print *,' type in the resistance'  
 read *, Resistance  
 do Voltage =  -20,20 
 Current(Voltage) =  Voltage/Resistance  
 print *, Voltage, ' ', Current(Voltage)  
 enddo 
 end program ch0706 
 We appreciate that, due to experimental error, the voltage will not have exact integer 
values. However, we are interested in representing and manipulating a set of values, 
and thus from the point of view of the problem solution and the program this is a 
reasonable assumption. There are several things to note. 
 This form of the dimension attribute
 dimension(First:Last) 
is of considerable use when the problem has an effective index which does not 
start at 1. 
 There is a corresponding form of the do statement which allows processing of 
problems of this nature. This is shown in the above program. The general form of 
the do statement is therefore:
 do counter =  start, end, increment  
where start, end and increment can be positive or negative. Note that zero is a legiti-
mate value of the dimension limits and of a do loop index. 

107
7.4 The Do Loop and Straight Repetition
 7.3.2  Example 7: Longitude from −180 to +180 
 Consider the problem of the production of a table linking time difference with lon-
gitude. The values of longitude will vary from −180° to +180°, and the time will 
vary from +12 h to −12 h. A possible program segment is:
 program ch0707  
 implicit none  
 real , dimension(-180:180) :: Time =  0 
 integer :: Degree,Strip  
 real :: value 
 do Degree =  -180,165,15  
 value =  Degree/15.  
 do Strip =  0,14 
 Time(Degree +  Strip) =  value 
 enddo 
 enddo 
 do Degree =  -180,180  
 print *,Degree,' ',Time(Degree)  
 end do  
 end program ch0707  
 7.3.3  Notes 
 The values of the time are not being calculated at every degree interval. 
 The variable Time is a real variable. It would be possible to arrange for the time 
to be an integer by expressing it in either minutes or seconds. 
 This example takes no account of all the wiggly bits separating time zones or of 
British Summer Time. 
 What changes would you make to the program to accommodate +180? What is 
the time at −180 and +180? 
 7.4  The Do Loop and Straight Repetition 
 7.4.1  Example 8: Table of Liquid Conversion Measurements 
 Consider the production of a table of liquid measurements. The independent vari-
able is the litre value; the gallon and US gallon are the dependent variables. Strictly 
speaking, a program to do this does not have to have an array, i.e., the DO loop can 

108
7 Arrays 2: Further Examples
be used to control the repetition of a set of statements that make no reference to an 
array. The following shows a complete but simple conversion program:
 program ch0708  
 implicit none  
 ! 
 ! 1 us gallon =  3.7854118 litres  
 ! 1 uk gallon =  4.545 
 
litres  
 ! 
 integer :: litre  
 real 
 
:: gallon,usgallon 
 do litre =  1,10 
 gallon =  litre / 4.545  
 usgallon =  litre / 3.7854118  
 print *,litre, ' ',gallon,' ',usgallon  
 end do  
 end program ch0708 
 Note here that the do statement has been used only to control the repetition of a 
block of statements — there are no arrays at all in this program. 
 This is the other use of the do statement. The do loop thus has two functions — 
its use with arrays as a control structure and its use solely for the repetition of a 
block of statements. 
 7.4.2  Example 9: Means and Standard Deviations 
 In the calculation of the mean and standard deviation of a list of numbers, we can 
use the following formulae. It is not actually necessary to store the values, nor to 
accumulate the sum of the values and their squares. In the ﬁ rst case, we would pos-
sibly require a large array, whereas in the second, it is conceivable that the accumu-
lated values (especially of the squares) might be too large for the machine. The 
following example uses an updating technique which avoids these problems, but is 
still accurate. The do loop is simply a control structure to ensure that all the values 
are read in, with the index being used in the calculation of the updates: 

109
7.5 Summary
 7.5  Summary 
 Arrays can have up to ﬁ fteen dimensions. 
 Do loops may be nested, but they must not overlap. 
 The dimension attribute allows limits to be speciﬁ ed for a block of information 
which is to be treated in a common way. The limits must be integer, and the second 
limit must exceed the ﬁ rst, e.g.,
 real , dimension(−123:-10) :: List  
 real , dimension(0:100, 0:100) :: Surface  
 real , dimension(1:100) :: value  
 The last example could equally be written
 real , dimension(100) :: value  
where the ﬁ rst limit is omitted and is given the default value 1. The array LIST 
would contain 114 values, while Surface would contain 10201. 
 A do statement and its corresponding enddo statement deﬁ ne a loop. The do 
statement provides a starting value, terminal value, and optionally, an increment for 
its index or counter. 
 The increment may be negative, but should never be zero. If it is not present, the 
default value is 1. It must be possible for the terminating value to be reached from 
the starting value. 

110
7 Arrays 2: Further Examples
 The counter in a do loop is ideally suited for indexing an array, but it may be used 
anywhere that repetition is needed, and of course the index or counter need not be 
used explicitly. 
 The formal syntax of the block do construct is
 [ do-construct-name : ] do [label] [ loop-control ] 
 [execution-part-construct]  
 [ label ] end-do 
where the forms of the loop control are
 [ , ] scalar-variable-name =  
 scalar-numeric-expression ,  
 scalar-numeric-expression  
 [ , scalar-numeric-expression ] 
and the forms of the end-do are
 end do [ do-construct-name ]  
 continue  
and [] identify optional components of the block do construct. This statement is 
looked at in much greater depth in Chap.  13 . 
 7.6  Problems 
     1.    Compile and run all the examples in this chapter, except example 5. This is 
covered separately later. 
 2.  Modify the ﬁ rst example to convert the height in feet to height in metres. The 
conversion factor is one 1 ft equals 0.305 m. 
 Hint: You can either overwrite the height array or introduce a second array. 
 3.  The following are two equations for temperature conversion
 
 
=
=
+
c
5 / 9*(t - 32)
f
32
9 / 5*t
  
 
 Write a complete program where t is an integer do loop variable and loop from 
−50 to 250. Print out the values of c, t and f on one line. What do you notice 
about the c and f values? 
 4.  Write a program to print out the 12 times table. Typical output would be of the form:
 
 
=
=
=
 
 
 
 
 
1
*
12
12
2
*
12
24
3
*
12
 
 
 
 
 
 
 
 
 
36   
  
etc. 

111
7.6 Problems
 Hint: You don’t need to use an array here. 
 5.  Write a program to read the following data into a two-dimensional array:
 
 
1
2
3
4
5
6
7
8
9   
 
 Calculate totals for each row and column and produce output similar to that 
shown below:
 
 
 
 
 
 
 
 
 
 
 
 
 
1
2
3
6
4
5
6
15
7
8
9
24
12
15
 
 
 
18 
   
 Hint 1: Example ch0602 shows how to sum over a loop. 
 Hint 2: You need to introduce two one-dimensional arrays to hold the row and 
column totals. You need to index over the rows to get the column totals and over 
the columns to get the row totals. 
 6.  Modify the above to produce averages for each row and column as well as the 
totals. 
 7.  Using the following data from problem 4.1 in Chap.  6 :   
 Use the program that evaluated the mean and standard deviation to do so for 
these heights and weights. 
 In the ﬁ rst case use the program as is and run it twice, ﬁ rst with the heights then 
with the weights. 
 What changes would you need to make to the program to read a height and a 
weight in a pair? 
 Hint: You could introduce separate scalar variables for the heights and weights. 
 8.  Example 5 looked at seat bookings in a cinema or theatre. Here is an example of 
a sample data ﬁ le for this program   

112
7 Arrays 2: Further Examples
 The key for this is as follows:
 
 
=
=
=
C
Confirmed Booking 
P
Provisional Booking 
E
Seat Empty
  
 
 Compile and run the program. The output would beneﬁ t from adding row and 
column numbers to the information displayed. We will come back to this issue in 
a subsequent chapter on output formatting. 
 The data are in a ﬁ le on the web and the address is given below.
 
• http://www.fortranplus.co.uk 
 Problem 4.3 in the last chapter shows how to read data from a ﬁ le. 

113
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_8, © Springer-Verlag London Limited 2012
 Aims 
 The aims of the chapter are:
 To look more formally at the terminology required to precisely describe arrays. 
• 
 To introduce ways in which we can manipulate whole arrays and parts of arrays 
• 
(sections). 
 allocatable arrays – ways in which the size of an array can be deferred until 
• 
execution time. 
 To introduce the concept of array element ordering and physical and virtual 
• 
memory. 
 To introduce ways in which we can initialise arrays using array constructors. 
• 
 To introduce the where statement and array masking. 
• 
 To introduce the forall statement and construct. 
• 
 8.1  Terminology 
 Fortran supports an abundance of array handling features. In order to make the 
description of these features more precise a number of additional terms have to be 
covered and these are introduced and explained below. 
 Chapter 8 
 Whole Array and Additional Array Features 
 A good notation has a subtlety and suggestiveness which at 
times make it seem almost like a live teacher. 
 Bertrand Russell 

114
8 Whole Array and Additional Array Features
 8.1.1  Rank 
 The number of dimensions of an array is called its rank. A one-dimensional array 
has rank 1, a two-dimensional array has rank 2 and so on. 
 8.1.2  Bounds 
 An array’s bounds are the upper and lower limits of the index in each dimension. 
 8.1.3  Extent 
 The number of elements along a dimension of an array is called the extent.
 integer, dimension(−10:15):: Current
 has bounds−10 and 15 and an extent of 26. 
 8.1.4  Size 
 The total number of elements in an array is its size. 
 8.1.5  Shape 
 The shape of an array is determined by its rank and its extents in each dimension. 
 8.1.6  Conformable 
 Two arrays are said to be conformable if they have the same shape, that is, they have 
the same rank and the same extent in each dimension. 
 8.1.7  Array Element Ordering 
 Array element ordering states that the elements of an array, regardless of rank, form 
a linear sequence. The sequence is such that the subscripts along the ﬁ rst dimension 
vary most rapidly, and those along the last dimension vary most slowly. This is best 
illustrated by considering, for example, a rank 2 array A deﬁ ned by
 real , dimension(1:4,1:2) :: A  
 A has 8 real elements whose array element order is 
 A(1,1), A(2,1), A(3,1), A(4,1), A(1,2), A(2,2), A(3,2), A(4,2) 
 i.e., mathematically by column and not row. 

115
8.2 Whole Array Manipulation
 8.2  Whole Array Manipulation 
 The examples of arrays so far have shown operations on arrays via array elements. 
One of the signiﬁ cant features of Fortran is its ability to manipulate arrays as whole 
objects. This allows arrays to be referenced not just as single elements but also as 
groups of elements. Along with this ability comes a whole host of intrinsic proce-
dures for array processing. These procedures are mentioned in Chap.  12 , and listed 
in alphabetical order with examples in Appendix C. 
 8.2.1  Assignment 
 An array name without any indices can appear on both sides of assignment and 
input and output statements. For example, values can be assigned to all the elements 
of an array in one statement:
 real, dimension(1:12):: Rainfall  
 Rainfall =  0.0 
 The elements of one array can be assigned to another:
 integer, dimension(1:50) :: A,B  
 … 
 A =  B 
 Arrays A and B must be conformable in order to do this. 
 The following example is illegal since X is rank 1 and extent 20, whilst Z is rank 1 
and extent 41.
 real, dimension(1:20) :: X  
 real, dimension(1:41) :: Z  
 X =  50.0 Z =  X 
 But the following is legal because both arrays are now conformable, i.e., they are 
both of rank 1 and extent 41:
 real , dimension (−20:20) :: X  
 real , dimension (1:41) :: Y  
 X =  50.0 
Y =  X 
 8.2.2  Expressions 
 All the arithmetic operators available to scalars are available to arrays, but care must 
be taken because mathematically they may not make sense.
 real , dimension (1:50) :: A,B,C,D,E  
 C =  A +  B 
adds each element of A to the corresponding element of B and assigns the result to C.

116
8 Whole Array and Additional Array Features
 E =  C*D 
multiplies each element of C by the corresponding element of D. This is not vector mul-
tiplication. To perform a vector dot product there is an intrinsic procedure  dot_prod-
uct , and an example of this is given in a subsequent section on array constructors. 
 For higher dimensions
 real ,dimension (1:10,1:10) :: F,G,H  
 F =  F**0.5  
takes the square root of every element of F.
 H =  F +  G 
adds each element of F to the corresponding element of G.
 H =  F*G
 multiplies each element of F by the corresponding element of G. The last statement 
is not matrix multiplication. An intrinsic procedure  matmul performs matrix mul-
tiplication; further details are given in Appendix C. 
 8.2.3  Example 1: One Dimensional Whole Arrays in Fortran 
 Consider the following example, which is a solution to a problem set earlier, but is 
now addressed using some of the whole array features of Fortran 

117
8.2 Whole Array Manipulation
 The statements
 real , dimension(1:N) :: RainFall_ins =  0.0 
 real , dimension(1:N) :: RainFall_cms =  0.0 
are examples of whole array initialisation. Each element of the arrays is set to 0.0. 
 The statement
 read *, RainFall_ins 
is an example of whole array I/O, where we no longer have to use a do loop to read 
each element in. 
 Finally, we have the statement
 RainFall_cms  =  RainFall_ins * 2.54 
which is an example of whole array arithmetic and assignment. 
 8.2.4  Example 2: Two Dimensional Whole Arrays in Fortran 
 Here is a two-dimensional example: 

118
8 Whole Array and Additional Array Features
 Note the use of whole arrays in the print statements. The output does look rather 
messy though, and also illustrates array element ordering. 
 8.3  Array Sections 
 Often it is necessary to access part of an array rather than the whole, and this is possible 
with Fortran’s powerful array manipulation features. 
 8.3.1  Example 3: Rank 1 Array Sections 
 Consider the following:
 program ch0803  
 implicit none  
 integer , dimension(−5:5) :: x  
 integer :: I 
 x(−5:−1)  = −1 
 x(0)  = 0 
 x(1:5)  =  1 
 do I =  -5,5 
 print *,' ',I,' ',x(I)  
 end do  
 end program ch0803  
 The statement
 x(−5:−1)  =  −1 
is working with a section of an array. It assigns the value –1 to elements x(–5) 
through x(–l). 
 The statement
 x(1:5)  =  1 
is also working with an array section. It assigns the value 1 to elements x(1) through x(5). 
 8.3.2  Example 4: Rank 2 Array Sections 
 In Chap.  6 we gave an example of a table of examination marks, and this is given 
again below: 
 Name 
 Physics 
 Maths 
 Biology 
 History 
 English 
 French 
 Fowler L. 
 50 
 47 
 28 
 89 
 30 
 46 
 Barron L.W 
 37 
 67 
 34 
 65 
 68 
 98 
 Warren J. 
 25 
 45 
 26 
 48 
 10 
 36 
 Mallory D. 
 89 
 56 
 33 
 45 
 30 
 65 
 Codd S. 
 68 
 78 
 38 
 76 
 98 
 65 

119
8.3 Array Sections
 The following program reads the data in, scales column 3 by 2.5 as the Biology 
marks were out of 40 (the rest are out of 100), calculates the averages for each 
subject and for each person and prints out the results. 

120
8 Whole Array and Additional Array Features
 The statement
 read *, exam_results(r, 1:ncol)  
uses sections to replace the implied do loop in the earlier example. 
 The statement
 Exam_Results(1:nrow,3)  =  2.5 * Exam_Results(1:nrow,3)  
uses array sections in the arithmetic and the assignment. 
 8.4  Array Constructors 
 Arrays can be given initial values in Fortran using array constructors. Some exam-
ples are given below. 
 8.4.1  Example 5: Rank 1 Array Initialisation – Explicit Values 
 The statement
 real , dimension(1:n) :: RainFall  =  & 
 (/3.1,2.0,2.4,2.1,2.2,2.2,1.8,2.2,2.7,2.9,3.1,3.1/)  
provides initial values to the elements of the array Rainfall. 

121
8.4 Array Constructors
 8.4.2  Example 6: Rank 1 Array Initialisation Using an Implied 
do Loop 
 The next example uses a simple variant:   
 The statement
 integer , dimension(1:n) :: Litre =  [(i,i =  1,n)] 
initialises the 10 elements of the Litre array to the values 1,2,3,4,5,6,7,8,9,10 
respectively. 
 8.4.3  Example 7: Rank 1 Arrays and the  dot_product Intrinsic 
 The following example uses an array constructor and the intrinsic procedure  dot_product: 
 program ch0807  
 implicit none  
 integer , dimension(1:3) :: X,Y  
 integer :: result 
 X =  [1,3,5]  
 Y =  [2,4,6]  
 result =  dot_product(X,Y)  
 print *,result  
 end program ch0807  

122
8 Whole Array and Additional Array Features
and result has the value 44, which is obtained by the normal mathematical dot 
product operation, 1*2 + 3*4 + 5*6. 
 The general form of the array constructor is [ list of expressions ] or (/ a list of 
expressions/) where each expression is of the same type. 
 8.5  Initialising Rank 2 Arrays 
 To construct arrays of higher rank than one the intrinsic function RESHAPE must 
be used. An introduction to intrinsic functions is given in Chap.  12 , and an alpha-
betic list with a full explanation of each function is given in Appendix C. To use it 
in its simplest form:
 Matrix  =  reshape ( Source, Shape)  
where Source is a rank 1 array containing the values of the elements required in the 
new array, Matrix, and Shape is a rank 1 array containing the shape of the new array 
Matrix. 
 We consider the rank 1 array B = (1,3,5,7,9,11), and we wish to store these values 
in a rank 2 array A, such that A is the matrix:
 
 
1
7
3
9
5
11
A
æ
ö
ç
÷
= ç
÷
ç
÷
è
ø   
 
 The following code extract is needed:
 integer, dimension(1:6) :: B  
 integer, dimension(1:3, 1:2) :: A 
 B =  (/1,3,5,7,9,11/)  
 A =  reshape(B, (/3,2/))  
 Note that the elements of the source array B must be stored in the array element 
order of the required array A. 
 8.5.1  Example 8: Initialising a Two Dimensional Array 
 The following example illustrates the additional forms of the  reshape function that 
are used when the number of elements in the source array is less than the number of 
elements in the destination. The complete form is
 reshape (source, shape,   pad, order) 

123
8.6 Miscellaneous Array Examples
 8.6  Miscellaneous Array Examples 
 The following are examples of some of the ﬂ exibility of arrays in Fortran. 
 8.6.1  Example 9: Rank 1 Arrays and a Step Size of 2 in Implied 
Do Loop 
 Consider the following example:
 program ch0809  
 implicit none  
 Pad  and  Order  are optional. See Appendix C for a complete explanation of Pad 
and Order: 

124
8 Whole Array and Additional Array Features
 integer : : I  
 integer , dimension(1:10) :: x =  (/(i,i =  1,10)/)  
 integer , dimension(1:5) :: odd =  (/(i,i =  1,10,2)/)  
 integer , dimension(1:5) :: even 
 even =  x(2:10:2)  
 print *,' x'  
 print *,x  
 print *,' odd'  
 print *,odd  
 print *, ' even'  
 print *,even  
 end program ch0809  
 The statement
 integer , dimension(1:5) :: odd =  (/(i,i =  1,10,2)/)  
steps through the array 2 at a time. 
 The statement
 even =  x(2:10:2)  
shows an array section where we go from elements two through ten in steps of two. 
The 2:10:2 is an example of a subscript triplet in Fortran, and the ﬁ rst 2 is the lower 
bound, the 10 is the upper bound, and the last 2 is the increment. Fortran uses the 
term stride to mean the increment in a subscript triplet. 
 8.6.2  Example 10: Rank 1 Array and the  sum Intrinsic Function 
 The following example is based on ch0805. It uses the sum intrinsic to calculate the 
sum of all the values in the Rainfall array.
 program ch0810  
 implicit none  
 real :: Total =  0.0, Average =  0.0 
 real , dimension(12) :: RainFall  =  &
(/3.1,2.0,2.4,2.1,2.2,2.2,1.8,2.2,2.7,2.9,3.1,3.1/)  
 integer :: Month 
 Total =  sum(RainFall)  
 Average  =  Total / 12  
 print *,' Average monthly rainfall was'  
 print *, Average  
 end program ch0810  
 The statement
 Total =  sum(RainFall) 

125
8.6 Miscellaneous Array Examples
replaces the statements below from the earlier example
 do Month =  1,n 
Total =  Total +  RainFall(Month)  
 enddo 
 In this example sum adds up all of the elements of the array Rainfall. 
 So we have three ways of processing arrays:
 Element by element. 
• 
 Using sections. 
• 
 On a whole array basis. 
• 
 The ability to use sections and whole arrays when programming is a major 
advance of the element by element processing supported by Fortran 77. 
 8.6.3  Example 11: Rank 2 Arrays and the  sum Intrinsic 
Function 
 This example is based on the earlier exam results program: 

126
8 Whole Array and Additional Array Features
 This example has several interesting array features:
 We initialise a rank 1 array with the values we want in our exam marks array. The data 
• 
are laid out in the program as they would be in an external ﬁ le in rows and columns.  
 We use  
• 
reshape to initialise our exam marks array. We use the fourth  parameter 
(/2,1/) to populate the rank 2 array with the data in row order. 
 We use  
• 
sum with a  dim of 1 to compute the sums for the subjects. 
 We use  
• 
sum with a  dim of 2 to compute the sums for the people. 
 8.6.4  Example 12: Masked Array Assignment and the Where 
Statement 
 Fortran has array assignment both on an element by element basis and on a whole 
array basis. There is an additional form of assignment based on the concept of a 
logical mask. 
 Consider the example of time zones given in Chap.  7 . The Time array will have 
values that are both negative and positive. We can then associate the positive values 
with the concept of east of the Greenwich meridian, and the negative values with the 
concept of west of the Greenwich meridian e.g.: 

127
8.6 Miscellaneous Array Examples
 8.6.5  Notes 
 The arrays must be conformable, i.e., in our example Time and Direction are the 
same shape. 
 The selective assignment is achieved through the where statement. 
 Both the where and elsewhere blocks can be executed. The formal syntax is:
 where (array logical assignment) 
 array assignment block  
 elsewhere 
 array assignment block  
 end where  
 The ﬁ rst array assignment is executed where Time is positive and the is executed 
where Time is negative. For further coverage of logical expressions see Chaps.  15 
and  18 . 

128
8 Whole Array and Additional Array Features
 8.7  The  forall Statement and  forall Construct 
 The  forall statement and  forall construct were introduced into Fortran to 
keep it inline with High Performance Fortran – HPF. They indicate to the compiler 
that the code can be optimised on a parallel processor. Consider the following exam-
ple where a value is subtracted from the diagonal elements of a square matrix A:
 forall (I =  1:N)
 A(I, I)  =  A(I,I) – Lamda  
 end forall  
 The forall construct allows the calculations to be carried out simultaneously in a 
multiprocessor environment. 
 8.7.1  Syntax 
 forall ( triplet [ , triplet ] … [ , mask ] )  
 variable  =  expression  
 forall ( triplet [ , triplet ] … [ , mask ] )  
 pointer =  >  target  
 The triplet speciﬁ es a value set for an index variable. It has the following 
syntax:
 index =  ﬁ rst : last [ : stride ]  
 First, last and stride are scalar integer expressions. 
 Mask is a scalar logical expression:
 [ name : ] forall ( triplet [ , triplet ] . . . [ , mask ] )  
 … 
 end forall [ name ]  
 Name is an optional name, which identiﬁ es the  forall construct. 
 8.7.2  Array Element Ordering and Physical and Virtual Memory 
 Fortran compilers will store arrays in memory according to the array element order-
ing scheme. Whilst the standard says nothing about how this is implemented it 
generally means in contiguous memory locations. 
 There will be a limit to the amount of physical memory available on any computer 
system. To enable problems that require more than the amount of physical memory 
available to be solved, most implementations will provide access to virtual memory, 
which in reality means access to a portion of a physical disk. 

129
8.9 Problems
 Access to virtual memory is commonly provided by a paging mechanism of 
some description. Paging is a technique whereby ﬁ xed-sized blocks of data are 
swapped between real memory and disk as required. 
 In order to minimise paging (and hence reduce execution time) array operations 
should be performed according to the array element order. 
 Page sizes, past and present, include:
 Sun UltraSparc – 4Kb, 8Kb. 
• 
 DEC Alpha – 8Kb, 16Kb, 32Kb, 64Kb. 
• 
 Intel 80x86 – 4Kb. 
• 
 Intel Pentium PIII – 4Kb, 2Mb, 4Mb. 
• 
 AMD64 – 4Kb, 2Mb, 4Mb – legacy mode 
• 
 AMD64 – 4Kb, 2Mb, 1Gb – 64 bit mode 
• 
 Intel 64 and IA – 32 – 4Kb, 2Mb, 1Gb – depending on mode. 
• 
 See the references at the end of the chapter for more details. 
 8.8  Summary 
 We can now perform operations on whole arrays and partial arrays (array sections) 
without having to refer to individual elements. This shortens program development 
time and greatly clariﬁ es the meaning of programs. 
 Array constructors can be used to assign values to rank 1 arrays within a program 
unit. The  reshape function allows us to assign values to a two or higher rank array 
when used in conjunction with an array constructor. 
 We have introduced the concept of a deferred-shape array. Arrays do not need to 
have their shape speciﬁ ed at compile time, only their rank. Their actual shape is 
deferred until runtime. We achieve this by the combined use of the allocatable attri-
bute on the variable declaration and the allocate statement, which makes Fortran a 
very ﬂ exible language for array manipulation. 
 8.9  Problems 
 1.  Give the rank, bounds, extent and size of the following arrays:
 real , dimension(1:15) :: A  
 integer , dimension(1:3, 0 : 4) :: B  
 real , dimension(−2:2,0:1,1:4) :: C  
 integer , dimension(0:2,1:5) :: D  
 Which two of these arrays are conformable? 
 2.  Write a program to read in ﬁ ve rank 1 arrays, A, B, C, D, E and then store them 
as ﬁ ve columns in a rank 2 array TABLE. 
 3.  Take the ﬁ rst part of Problem 5 in Chap.  7 and rewrite it using the  sum intrinsic 
function. 

130
8 Whole Array and Additional Array Features
 8.10  Bibliography 
 Bhandarkar, D.P.: Alpha Implementation and Architecture: Complete Reference 
and Guide. Digital Press, Newton (1996)
 Amd 
 Visit 
 http://developer.amd.com/documentation/guides/pages/default.aspx 
for details of the AMD manuals. The following ﬁ ve manuals are available for down-
load as pdf s from the above site.
 AMD64 Architecture Programmer’s Manual Volume 1: Application Pro 
• 
gramming 
 AMD64 Architecture Programmer’s Manual Volume 2: System Program ming 
• 
 AMD64 Architecture Programmer’s Manual Volume 3: General Purpose and 
• 
System Instructions 
 AMD64 Architecture Programmer’s Manual Volume 4: 128-bit and 256 bit 
• 
media instructions 
 AMD64 Architecture Programmer’s Manual Volume 5: 64-Bit Media and x87 
• 
Floating-Point Instructions 
 Intel 
 Visit 
 http://www.intel.com/products/processor/manuals/index.htm 
for a list of manuals. The following three manuals are available for download as 
pdf’s from the above site.
 Intel® 64 and IA-32 Architectures Software Developer’s Manual. Volume 1: 
• 
Basic Architecture 
 Intel® 64 and IA-32 Architectures Software Developer’s Manual. Combined 
• 
Volumes 2A and 2B: Instruction Set Reference, A-Z. 
 Intel® 64 and IA-32 Architectures Software Developer’s Manual. Combined 
• 
Volumes 3A and 3B: System Programming Guide, Parts 1 and 2 

131
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_9, © Springer-Verlag London Limited 2012
 Aims 
 The aims here are to introduce the facilities for producing neat output and to show 
how to write results to a ﬁ le, rather than to the terminal. In particular:
 The A, I, E, F, and X layout or edit descriptors. 
• 
 The open, write, and close statements. 
• 
 9.1  Introduction 
 When you have used print * a few times it becomes apparent that it is not always as 
useful as it might be. The data are written out in a way which makes some sense, but 
may not be especially easy to read. Real numbers are written out with all their 
signiﬁ cant places, which is very often rather too many, and it is often difﬁ cult to line 
up the columns for data which are notionally tabular. It is possible to be much more 
precise in describing the way in which information is presented by the program. To 
do this, we use format statements. Through the use of the format we can:
 Specify how many columns a number should take up. 
• 
 Specify where a decimal point should lie. 
• 
 Specify where there should be white space. 
• 
 Specify titles. 
• 
 The format statement has a label associated with it; through this label, the print 
statement associates the data to be written with the form in which to write them. 
 Chapter 9 
 Output of Results  
 Why, sometimes I’ve believed as many as six impossible things 
before breakfast. 
 Lewis Carroll, Through the Looking-Glass 
and What Alice Found There 

132
9 Output of Results
 9.2  Example 1: Integers – I Format or Edit Descriptor 
 Integer format is reasonably straightforward, and offers clues for formats used in 
describing other numbers. I3 is an integer taking three columns. The number is right 
justiﬁ ed, a bit of jargon meaning that it is written as far to the right as it will go, so 
that there are no trailing or following blanks. Consider the following example:
 program ch0901  
 implicit none  
 integer :: T 
 print *, ' '  
 print *,' Twelve times table'  
 print *, ' '  
 do T=1,12 
 print 100, T,T*12  
 100 format(' ',I3,' * 12 = ',I3)  
 end do  
 end program ch0901 
 The ﬁ rst statement of interest is
 print 100, T,T*12  
 The 100 is a statement label. There must be a format statement with this label in 
the program. The variables to be written out are T and 12*T. 
 The second statement of interest is
 100 format(' ',I3,' * 12  =  ',I3) 
 Inside the brackets we have
 '' print out what occurs between the quote marks, in this case one space. 
 , The comma separates items in the format statement. 
 I3 print out the ﬁ rst variable in the print statement right justiﬁ ed in three 
columns 
 , Item separator. 
 ' * 12 =  ' print out what occurs between the quote characters. 
 , Item separator 
 I3 print out the second variable (in this case an expression) right justiﬁ ed in 
three columns. 
 All of the output will appear on one line. 

133
9.3 Example 2: The x Edit Descriptor
 9.3  Example 2: The x Edit Descriptor 
 Now consider the following example:
 program ch0902  
 implicit none  
 integer :: big=10  
 integer :: I 
 do I=1,40 
 print 100,i,big  
 100 format(1x,i3,2x,i12)  
 big=big*10  
 end do  
 end program ch0902  
 The new feature in the format statement is the 1x and 2x edit descriptor. This is 
another way of getting white space into the output, and in this case one space and 
two spaces, respectively. 
 This program will loop and the variable big will overﬂ ow, i.e., go beyond the 
range of valid values for a 32-bit integer. Does the program crash or generate a run 
time error? This is the output from the NAG and Intel compilers. 
 1 
 10 
 2 
 100  
 3 
 1000  
 4 
 10000  
 5 
  100000  
 6 
 1000000  
 7 
 10000000  
 8 
 100000000  
 9 
 1000000000  
 10  
 1410065408  
 11  
 1215752192  
 12  
 −727379968  
 13  
 1316134912  
 14  
 276447232  
 15  
 −1530494976  
 16  
 1874919424  
 17  
 1569325056  
 18  
 −1486618624  
 19  
 −1981284352  
 20  
 1661992960  
  21  
 −559939584  
 22  
 −1304428544  
 23  
 −159383552  
 24  
 −1593835520  
 25  
 1241513984  
(continued)

134
9 Output of Results
 (continued) 
 26  
 −469762048  
 27  
 −402653184  
 28  
 268435456  
 29  
 −1610612736  
 30  
 1073741824  
 31  
 −2147483648  
 32  
 0 
 33  
 0 
 34  
 0 
 35  
 0 
 36  
 0 
 37  
 0 
 38  
 0 
 39  
 0 
 40  
 0 
 Is there a compiler switch to trap this kind of error? 
 9.4  Reals – F Format or Edit Descriptor 
 The F format can be seen as an extension of the integer format, but here we have to 
deal with the decimal point. The form of the F format speciﬁ es where the decimal 
point will occur, and how many digits follow it. Thus, F7.4 means:
 There is a total width of seven. 
• 
 There is a decimal point 
• 
 There are four digits after the decimal point. 
• 
 This means that since the decimal point is also written out, there may be up to 
two digits before the decimal point. As in the case of the integer, any minus sign is 
part of the number, and would take up one column. Thus, the format F7.4 may be 
used for numbers in the range 
 −9.9999 to 99.9999 
 Let us look at the last example more closely. When a number is written out, it is 
rounded; that is to say, if we write out 99.99999 in an F7.4 format, the program will 
try to write out 100.0000! This is bad news, since we have not left enough room for 
all those digits before the decimal point. What happens? Asterisks will be printed. 
In the example above, a number out of range of the format’s capabilities would be 
printed as:
 ******* 

135
9.4 Reals – F Format or Edit Descriptor
 What would a format of F7.0 do? Again, seven columns have been set aside to 
accommodate the number and its decimal point, but this time no digits follow the 
point.
 99. 
 −21375.  
are examples of numbers written in this format. With an F format, there is no way 
of getting rid of the decimal point. 
 The numbers making up the parts of the descriptors must all be positive integers. 
The deﬁ nition of a real format is therefore F followed by two integer numbers, sepa-
rated by a decimal point. The ﬁ rst integer must exceed the second, and the second 
must be greater than or equal to zero. The following are valid examples:
 F4.0 
 F6.2 
 F12.2 
 F16.8 
but these are not valid:
 F4.4 
 F6.8 
 F-3.0 
 F6 
 F.2 
 The program in Section  9.3.1 illustrates the use of both I format and F format. 
 9.4.1  Example 3: Metric and Imperial Conversion 
and the f Edit Descriptor 
 program ch0903  
 implicit none  
 integer :: ﬂ uid 
 real :: litres  
 real :: pints 
 do ﬂ uid=1,10
 litres = ﬂ uid / 1.75  
 pints = ﬂ uid * 1.75  
 print 100 , pints,ﬂ uid,litres  
 100 format(' ',F7.3,' ',I3,' ',F7.3)  
 end do  
 end program ch0903  
 Pints will be printed out in F7.3 format, ﬂ uid will be printed out in I3 format and 
litres will be printed out in F7.3 format. 

136
9 Output of Results
 9.4.2  Example 4: Overﬂ ow and Underﬂ ow and the f Edit Descriptor 
 Consider the following program: 
 In this program the variable small will underﬂ ow and big will overﬂ ow. The 
output from the Intel compiler is: 
 When the number is too small for the format, the printout is what you would 
probably expect. When the number is too large, you get asterisks. When the num-
ber actually overﬂ ows the Intel compiler tells you that the number is too big and 
has overﬂ owed. However the program ran to completion and did not generate a 
run time error.  

137
9.5 Reals – E Format or Edit Descriptor
 9.5  Reals – E Format or Edit Descriptor 
 The exponential or scientiﬁ c notation is useful in cases where we need to provide a 
format which may encompass a wide range of values. If likely results lie in a very 
wide range, we can ensure that the most signiﬁ cant part is given. It is possible to 
give a very large F format, but alternatively, the E format may be used. This takes a 
form such as
 E10.4 
which looks something like the F, and may be interpreted in a similar way. The 10 
gives the total width of the number to be printed out, that is, the number of columns 
it will take. The number after the decimal point indicates the number of positions to 
be written after the decimal point. Since all exponent format numbers are written so 
that the number is between 0.1 and 0.9999…, with the exponent taking care of scale 
shifts, this implies that the ﬁ rst four signiﬁ cant digits are to be printed out. 
 Taking a concrete example, 1,000 may be written as 10**3, or as 0.1 * 10**4. 
This gives us the two parts: 0.1 gives the signiﬁ cant digits (in this case only one 
signiﬁ cant digit), while the 10**4 gives the exponent, namely 4 or +4. In a form that 
looks more like Fortran, this would be written .1E+04, where the E+04 means 
10**4. 
 There is a minimum size for an exponential format. Because of all the extra bits 
and pieces it requires:
 The decimal point. 
• 
 The sign of the entire number. 
• 
 The sign of the exponent. 
• 
 The magnitude of the exponent. 
• 
 The E. 
• 
 The width of the number less the number of signiﬁ cant places should not be less 
than 6. In the example given above, E10.4 meets this requirement. When the exponent 
is in the range 0–99, the E will be printed as part of the number; when the exponent is 
greater, the E is dropped, and its place is taken by a larger value; however, the sign of 
the exponent is always given, whether it is positive or negative. The sign of the whole 
number will usually only be given when it is negative. This means that if the numbers 
are always positive, the rule of six given above can be modiﬁ ed to a rule of ﬁ ve. It is safer 
to allow six places over, since, if the format is insufﬁ cient, all you will get are asterisks. 
 The most common mistake with an E format is to make the edit descriptor too 
small, so that there is insufﬁ cient room for all the padding to be printed. Formats 
like E8.4 just don’t work (on output anyway). The following four are valid E 
formats on output:
 E9.3 
 E11.2 
 E18.7 
 E10.4 

138
9 Output of Results
but the next ﬁ ve would not be acceptable as output formats, for a variety of 
reasons:
 E11.7 
 E6.3 
 E4.0 
 E10 
 E7.3 
 9.5.1  Example 5: Simple e Edit Descriptor Usage 
 This is the same as ch0904 except that we have replaced the F formatting with E 
formatting: 
 We now have three ways to print out ﬂ oating point numbers and each has its use. 
The print * is very useful when developing programs. 
 9.6  Spaces 
 You have seen two ways of generating spaces on output. The ﬁ rst is to use  ' 
characters to enclose blanks in the format statement. The second is to use the X edit 
descriptor. Consider the following.
 print 100, ALPHA,BETA  
 100 format(1X,F10.4,10X,F10.3)  
 The 10X is read rather like any of the other format elements – logically it should 
have been X10, to correspond to I10 or F10.4, but that would be allowing intuition 
to run away with you. Clearly the X3J3 committee felt it important that Fortran 
should have inconsistencies, just like a natural language. 

139
9.7 Characters – A Format or Edit Descriptor
 Remember that these blanks are in addition to any generated as a result of the 
leading blanks on numbers (if any are present). if you wish to leave a single space, 
you must still precede the X by a number (in this case, 1); simply writing X is illegal. 
The general form is therefore a positive integer followed by X. 
 9.7  Characters – A Format or Edit Descriptor 
 This is perhaps the simplest output of all. Since you will already have declared the 
length of a character variable in your declarations,
 character (10) :: B  
when you come to write out B, the length is known – thus you need only specify that 
a character string is to be output:
 print 100,B  
 100 format(1X,A)  
if you feel you need a little extra control, you can append an integer value to the 
A, like A10 (A9 or A1), and so on. if you do this, only the ﬁ rst 10 (9 or 1) characters 
are written out; the remainder are ignored. Do note that 10A1 and A10 are not the 
same thing. 10A1 would be used to print out the ﬁ rst character of ten character vari-
ables, while A10 would write out the ﬁ rst 10 characters of a single character vari-
able. The general form is therefore just A, but if more control is required, this may 
be followed by a positive integer. 
 9.7.1  Example 6: Character Output and the a Edit Descriptor 
 The following program is a simple rewrite of a program from Chap.  4 .
 program ch0906  
 ! 
 ! This program reads in and prints out  
 ! your ﬁ rst name  
 ! 
 implicit none  
 character (20) :: ﬁ rst_name  
 ! 
 print *,' type in your ﬁ rst name.'  
 print *,' up to 20 characters'  
 read *,ﬁ rst_name  
 print 100,ﬁ rst_name  
 100 format(1x,A)  
 ! 
 end program ch0906  

140
9 Output of Results
 9.7.2  Example 7: Headings 
 A simple heading is given in the program below:
 program ch0907  
 implicit none  
 integer :: ﬂ uid 
 real :: litres  
 real : : pints 
 print *,' Pints  Litres'  
 do ﬂ uid=1,10 
 litres = ﬂ uid / 1.75  
 pints = ﬂ uid * 1.75  
 print 100 , pints,ﬂ uid,litres  
 100 format(' ',f7.3,' ',i3,' ',f7.3)  
 end do  
 end program ch0907  
 9.8  Example 8: Mixed Type Output in a Format Statement 
 The following example shows how to mix and match character, integer and real 
output in one format statement:
 program ch0908  
 implicit none  
 character (len=15) :: Firstname  
 integer :: age  
 real :: weight  
 character (len=1) :: sex 
 print *,' type in your ﬁ rst name '  
 read *,Firstname  
 print *,' type in your age in years'  
 read *,age  
 print *,' type in your weight in kilos'  
 read *,weight  
 print *,' type in your sex (f/m)'  
 read *,sex  
 print *,' your personal details are'  
 print *  
 print 100  
 100 format(4x,'ﬁ rst name', 4x , 'age' , 1x , & 'weight' 
, 2x , 'sex')  
 print 200 , ﬁ rstname, age , weight , sex  
 200 format (1x , a , 2x , i3 , 2x , f5.2 , 2x, a)  
 end program ch0908  

141
9.10 Open (and Close)
 Take care to match up the variables with the appropriate edit descriptors. You also 
need to count the number of characters and spaces when lining up the heading.  
 9.9  Common Mistakes 
 It must be stressed that an integer can only be printed out with an I format, and a real 
with an F (or E) format. You cannot use integer variables or expressions with F or E 
edit descriptors or real variables and expressions with I edit descriptors. if you do, 
unpredictable results will follow. There are (at least) two other sorts of errors you 
might make in writing out a value. You might try to write out something which has 
never actually been assigned a value; this is termed an indeﬁ nite value. You might 
ﬁ nd that the letter I is written out. In passing, note that many loaders and link editors 
will preset all values to zero – i.e., unset (indeﬁ nite) values are actually set to zero. 
On better systems there is generally some way of turning this facility off, so that 
undeﬁ ned is really indeﬁ nite. More often than not, indeﬁ nite values are the result of 
mistyping rather than of never setting values. It is not uncommon to type O for 0, or 
1 for either I or l. The other likely error is to try to print out a value greater than the 
machine can calculate – out of range values. Some machines will print out such 
values as R, but some will actually print out something which looks right, and 
such overﬂ ow and underﬂ ow conditions can go unnoticed. Be wary. 
 9.10  Open (and Close) 
 One of the particularly powerful features of Fortran is the way it allows you to 
manipulate ﬁ les. Up to now, most of the discussion has centred on reading from and 
writing to the terminal. It is also possible to read and write to one or more ﬁ les. This 
is achieved using the open, write, read and close statements. In a later chapter we 
will consider reading from ﬁ les but here we will concentrate on writing. 
 9.10.1  The Open Statement 
 This statement sets up a ﬁ le for either reading or writing. A typical form is
 open (unit =  1,ﬁ le =  'data.txt')  
 The ﬁ le will be known to the operating system as data.txt (or will have data as the 
ﬁ rst part of its name), and can be written to by using the unit number. This statement 
should come before you ﬁ rst read from or write to the ﬁ le data. 
 It is not possible to write to the ﬁ le data.txt directly; it must be referenced through 
its unit number. Within the Fortran program you write to this ﬁ le using a statement 
such as

142
9 Output of Results
 write(unit =  1,fmt =  100) XVAL,YVAL  
or
 write(1,100) XVAL,YVAL  
 These two statements are equivalent. Besides opening a ﬁ le, we really ought to 
close it when we have ﬁ nished writing to it:
 close(unit =  1) 
 In fact, on many systems it is not obligatory to open and close all your ﬁ les. 
Almost certainly, the terminal will not require this, since INPUT and OUTPUT 
units will be there by default. At the end of the job, the system will close all your 
ﬁ les. Nevertheless, explicit open and close cannot hurt, and the added clarity gener-
ally assists in understanding the program. 
 9.10.2  Example 9: Open and Close Usage 
 The following program contains all of the above statements:
 program ch0909  
 implicit none  
 integer :: ﬂ uid 
 real :: litres  
 real :: pints 
 open (unit=1,ﬁ le='ch0909.txt')  
 write(unit=1,fmt=200)  
 200 format(' Pints   Litres')  
 do ﬂ uid=1,10 
 litres = ﬂ uid / 1.75  
 pints = ﬂ uid * 1.75  
 write(unit=1,fmt=100) pints,ﬂ uid,litres  
 100 format(' ',f7.3,' ',i3,' ',f7.3)  
 end do  
 close(1)  
 end program ch0909  
 9.10.3  Writing 
 Print is always directed to the ﬁ le OUTPUT; in the case of interactive working, this 
is the terminal. This is not a very ﬂ exible arrangement. write allows us to direct 
output to any ﬁ le, including OUTPUT. The basic form of the write is
 write(6,100) X,Y,Z  
or
 write(unit =  6,fmt =  100) X,Y,Z  

143
9.11 Repetition
 The latter form is more explicit, but the former is probably the one most widely 
used. We have an example here of the use of positionally dependent parameters in 
the ﬁ rst case and equated keywords in the second. With the exceptions of the print 
statement and the read * form of the read, all of the input/output statements allow 
the unit number and the format labels to be speciﬁ ed either by an equated keyword 
(or speciﬁ er) or in a positionally dependent form. if you use the explicit unit = and 
fmt = it does not matter what order the elements are placed in, but if you omit these 
keywords, the unit number must come ﬁ rst, followed by the format label. 
 unit = 6 means that the output will be written to the ﬁ le given the unit number 6. 
In the next chapter we will cover the way in which you may associate ﬁ le names and 
unit numbers, but, for the moment, we will assume that the default is being used. 
The name of the ﬁ le, as deﬁ ned by the system, will depend on the particular system 
you use; a likely name is something like data. A great many of computing’s minor 
complexities can be clariﬁ ed by simple experimentation.
 fmt = 100 simply gives the label of the format to be used. 
 The overworked asterisk may be used, either for the unit or for the format:
 unit = * will write to OUTPUT (the terminal) 
 fmt = * will produce output controlled by the list of variables, often called list 
directed output. 
 The following three statements are therefore equivalent:
 write(unit=*,fmt=*) X,Y,Z  
 write(*,*) X,Y,Z  
 print*,X,Y,Z  
 There are other controls possible on the write, which will be elaborated later. 
 9.11  Repetition 
 Often we need to print more than one number on a line and want to use the same 
layout descriptor. Consider the following:
 print 100,A,B,C,D  
if each number can be written with the same layout descriptor, we can abbreviate 
the format statement to take account of the pattern:
 100 format(1X,4F8.2)  
is equivalent to
 100 format(1X,F8.2,F8.2,F8.2,F8.2)  
as you might anticipate. If the pattern is more complex, we can extend this approach:
 print 100,I,A,J,B,K,C  
 100 format(1X,3(I3,F8.2)) 

144
9 Output of Results
 Bracketing the description ensures that we repeat the whole entity:
 100 format(1X,3(I3,F8.2))  
is equivalent to
 100 format(1X,I3,F8.2, I3,F8.2, I3,F8.2)  
 Repetition with brackets can be rather more complex. In order to give some 
overview of formatted Fortran output, it is helpful to delve a little into the history 
of the language. Many of the attributes of Fortran can be traced back to the days of 
single-user mainframes (with often a fraction of the power of many contemporary 
microcomputers and workstations). These would generally take input from punched 
cards (the traditional 80-column Hollerith card), and would generate output on a line 
printer. In this sort of environment, the individual punched card had a signiﬁ cance 
which lines in a ﬁ le do not have today. Each card could be seen as a single entity – a 
physical record unit. The record was seen as an element of a subdivision within a ﬁ le. 
Even then, there was some confusion between the notion of physical records and ﬁ les 
split into logically distinct subunits, since these sub-units might also be termed 
records. The present Fortran standard merely says that a record does not necessarily 
correspond to a physical entity, although a punched card is usually considered to be 
a record. This leaves us sitting at our terminals in a bemused state, especially since 
we may have no idea what a punched card looks like (an ideal state of affairs!). 
 It is important to have some notion of a record, since most of the formal deﬁ ni-
tions dealing with output (and input) are couched in terms of records. Every time an 
input or output statement is executed your nominal position in the ﬁ le changes. if we 
think in terms of individual records (which may be cards), the notions of current, 
preceding and next record seem fairly straightforward. The current record is simply 
the one we have just read or written, and the other deﬁ nitions follow naturally. 
 The situation becomes less clear when we realise that a single output statement 
may generate many lines of output:
 write(unit =  6,fmt =  101) A,B,C  
 101 format(1X,F10.4)  
writes out three separate lines. Looking at the output alone, there is no way to 
distinguish this from the output generated by
 write(unit =  6,fmt =  101) A  
 write(unit =  6,fmt =  101) B  
 write(unit =  6,fmt =  101) C  
 101 format(1X,F10.4)  
 In the latter case we would probably be happy to consider each line a record, 
although in the previous example we might swither between considering all three 
lines (generated by a single statement) a single record or three records. Consider the 
ﬁ rst of these two examples more closely; each time the format is exhausted – that is 
to say, each time we run out of format description, we start again on a new line 

145
9.12 Some More Examples
(a new record). A new record is begun as each F10.4 is begun. The correct 
interpretation is therefore that three records have been written. 
 The same sort of thing happens in more complex format statements:
 write(unit =  6,fmt =  105) X,I,Y  
 105 format(1X,F8.4,I3,(F8.4))  
would write out a single record containing a real, an integer and a real. Using the 
same format statement with write ( unit = 6, fmt = 105 ) X,I,Y,Z would write out two 
records. The ﬁ rst containing the values of X, I and Y and the second containing 
only Z. if there were still more values
 write(unit =  6,fmt =  105) X,I,Y,Z,A  
would print out three records. The group in brackets – the (F8.4) – is repeated until 
we run out of items. 
 9.12  Some More Examples 
 Since it is the last open bracket which determines the position at which the format 
is repeated, simply writing
 write(unit =  6,fmt =  100) A,I,B,C,J  
 100 format(1X,F8.4,I3,F8.2)  
would imply that A, I and B would be written on one line then, returning to the last 
open brackets (in this case the only open brackets), a new record (or line) is begun 
to write out C and J. A statement like
 100 format(1X,(F8.4),I3,F8.2)  
would return to the (F8.4) group, and then continue to the I3 and F8.2 before repeat-
ing again (if necessary). The same thing happens if the (F8.4) had no brackets 
around it. On the other hand
 100 format(1X,(F8.4),I3,(F8.2))  
contains superﬂ uous brackets around the F8.4, since the repeat statement will never 
return to that group. Are you confused yet? This all seems very esoteric, and really, 
we have only hinted at the complexity which is possible. It is seldom that you have 
to create complex format statements, and clarity is far more important than brevity. 
 When patterned or repeated output is used, we may want to stop when there are 
no more numbers to write out. Take the following example:
 write(unit =  1,fmt =  100) A,B,C,D  
 100 format(1X,4(F6.1,','))  
 This will give output which looks like
 37.4, 29.4, 14.2, -9.1,  

146
9 Output of Results
 The last comma should not be there. We can suppress these unwanted elements 
by using the colon:
 100 format(1X,4(F6.1:','))  
which would then give us
 37.4, 29.4, 14.2, -9.1  
 Since we run out of data at the fourth item, D, the output following is not written 
out. It is a small point, but it does look a lot tidier. There are other ways of achieving 
the same thing. 
 This helps to illustrate another point, namely that you may have formats which 
are more extensive than the lists which reference them:
 write(unit =  1,fmt =  100) A,B,C  
 write(unit =  1,fmt =  100) X,Y  
 100 format(1X,6 F8.2) 
 Both write statements use the format provided, although they write out different 
numbers of data, and neither uses up the whole format. 
 9.13  Example 10: Implied Do Loops and Array 
Sections for Array Output 
 The following program shows how to use both implied do loops and array sections 
to output an array in a neat fashion: 

147
9.13 Example 10: Implied Do Loops and Array Sections for Array Output 
 The print 100 uses an implied do loop and the print 110 uses an array section. 
 9.13.1  Example 11: Whole Array Output 
 Take care when using whole arrays. Consider the following program:
 program ch0911  
 real , dimension(10,10) :: Y  
 integer :: NROWS=6  
 integer :: NCOLS=7  
 integer :: I,J  
 integer :: K=0 
 do I=1,NROWS 
 do J=1,NCOLS 
 K=K+1 
 Y(I,J)=K  
 end do  
 end do  
 write(unit=*,fmt=100)Y  
 100 format(1X,10F10.4)  
 end program ch0911  
 There are several points to note with this example. Firstly, this is a whole array 
reference, and so the entire contents of the array will be written; there is no scope 
for ﬁ ne control. Secondly, the order in which the array elements are written is 
according to Fortran’s array element ordering, i.e., the ﬁ rst subscript varying 1–10 

148
9 Output of Results
(the array bound), with the second subscript as 1, then 1–10 with the second 
subscript as 2 and so on; the sequence is 
 Thirdly we have deﬁ ned values for part of the array. 
 9.14  Formatting for a Line Printer 
 There is one extension to format speciﬁ cations which is relevant to line printers. 
Fortran deﬁ nes four special characters which have an effect on standard line printers 
when they occur in the ﬁ rst character position of a line. This means that a line 
printer which is not under your immediate control can be used to produce neat 
output by sending a ﬁ le to be printed on it. This has a variety of names including, 
spooling, queueing and routing depending on the system. You should check with 
your local system for the exact mechanism to achieve this. 
 The special characters are +, 0, 1 and blank. To be used, they must be the ﬁ rst 
character of the output in each line – as if they were to be printed in column 1. In 
fact, a standard line printer never prints a character that occurs in column 1 at all. 
 Whenever a write statement is begun, the printer advances to a new record; i.e., 
a new line is begun before any data are transferred. if the ﬁ rst character is a special 
character, then this will be interpreted by the line printer. if the ﬁ rst character to be 
printed is a blank, the printer continues printing on that line. The ﬁ rst character is 
also known as the carriage control character. 
 The blank is a do nothing special control. It signiﬁ es that the line is to be printed 
as it is. 
 The zero indicates that you wish to leave an extra line; this is often useful in 
spacing out results to make the output more readable. 
 The 1 makes the output skip down to the top of the next page. This is clearly useful 
for separating logically distinct chunks of output. If you obtain a line printer listing 
of your compiled program, each segment will start at the top of a new page. 
 The plus is a no advance or overprint character. It suppresses the effect of the line 
advance which a write generates. No new line is begun and the previous line is 
overprinted with the new. Overprinting can be useful especially when you wish to 
print out grey scale maps but its use is rather restricted. In particular, it can be a 
dangerous control character. If you have a format starting with a plus in a loop, you 
can make the printer overprint again and again and again . . . and again and again, 
until it has hammered itself into a pulp. This is not a good idea. 
 Similarly, accidental use of the 1 as a control character in a loop will give you 
lots of blank pages. It is just a bit embarrassing to be presented with a 6 in. stack of 
paper which is (almost) blank, because you had a 1 repeatedly in column 1. 

149
9.14 Formatting for a Line Printer
 9.14.1  Mechanics of Carriage Control 
 The following are all quite reasonable ways of generating the blank in column 1:
 write(unit =  6,fmt =  100)A 
 100 format(' ',F10.4)  
or
 write(unit =  6,fmt =  100)A 
 100 format(1X,F10.4)  
or
 write(unit =  6,fmt =  100)A 
 100 format(' THE ANSWER IS ',F10.4)  
 Note, however, that
 write(unit =  6,fmt =  100)A 
 100 format(F8.4)  
could result in problems. if A contained the value 100.2934, the result on a line 
printer would be
 00.2934  
printed at the top of a new page. The 1 is taken as carriage control, and the rest of 
the line then printed. 
 Accidentally printing zeros in column 1 is a little more difﬁ cult, but
 write(unit =  6,fmt =  100)I 
 100 format(I1)  
might just do it. Don’t. 
 Remember that this only applies to line printer output, and not to the terminal. 
Since Fortran only deﬁ nes four characters as carriage control, you will ﬁ nd that 
anything else in column 1 will give unpredictable results. On some systems, a fair 
number of alternatives may be deﬁ ned by the installation, and they may do some-
thing useful. On other systems, they may do something, but they may also fail to 
print the rest of the line. This can be very perplexing. Beware. 
 9.14.2  Generating a New Line on Both Line Printers 
and Terminals 
 There are several ways of generating new lines, other than with a 0 in column 1 of 
your line printer output. A more general approach, which works on both terminals 
and line printers, is through the oblique or slash, /. Each time this is encountered in 
a format statement, a new line is begun.

150
9 Output of Results
 print 101,A,B  
 101 format(1X,F10.4/1X,F10.4)  
would give output like
 100.2317  
 −4.0021 
 This is the same as (F10.4) would have given, but clearly it opens up lots of 
possibilities for formatting output more tidily:
 may be easier to read than using only one line, and it is certainly more compact to 
write than using three separate print statements. It is not necessary to separate / by 
commas, although if you do nothing catastrophic will happen. 
 You may also begin a format description with a /, in order to generate an extra 
line or even generate lots of lines with lots of slashes; e.g.,
 write(unit =  6,fmt =  103)A,B  
 103 format(//1X,F10.4,4(/),1X,F10.4)  
will leave two lines before printing A, and then will generate four new lines before 
writing B (i.e., there will be three lines between A and B – the fourth new line will 
contain B). While a slash by itself, or with another slash, does not have to be separated 
by commas from other groups, a more complex grouping, 4(/), does have to have 
commas and brackets to delimit it. 
 9.15  Example 12: Timing of Writing Formatted Files 
 The following example looks at the amount of time spent in different sections of a 
program with the main emphasis on formatted output:
 program ch0912  
 implicit none  
 integer , parameter :: n=1000000  
 integer , dimension(1:n) :: x=0  
 real , dimension(1:n) :: y=0  
 integer :: I  
 real :: t,t1,t2,t3,t4,t5  
 character*10 :: comment 
 open(unit=10,ﬁ le='ch0912.dat')  
 call cpu_time(t)  

151
9.16 Example 13: Timing of Writing Unformatted Files
 t1=t 
 comment=' Initial '  
 print 100,comment,t1 
 do i=1,n 
 x(i)=I  
 end do  
 call cpu_time(t)  
 t2=t-t1  
 comment = ' integer '  
 print 100,comment,t2  
 y=real(x)  
 call cpu_time(t)  
 t3=t-t1-t2  
 comment = ' real '  
 print 100,comment,t2  
 do i=1,n 
 Write(10,200) x(I)
200 Format (1x,i10)  
 end do  
 call cpu_time(t)  
 t4=t-t1-t2-t3  
 comment = ' I write '  
 print 100,comment,t4  
 do i=1,n 
 Write(10,300) y(I)
300 Format (1x,f10.0)  
 end do  
 call cpu_time(t)  
 t5=t-t1-t2-t3-t4  
 comment = ' r write '  
 print 100,comment,t5  
 100 format(1x,a,2x,f7.3)  
 end program ch0912  
 There is a call to the built-in intrinsic cpu_time to obtain timing information. Try 
this example out with your compiler. Formatted output takes up a lot of time, as we 
are converting from an internal binary representation to an external decimal form. 
 9.16  Example 13: Timing of Writing Unformatted Files 
 The following program is a variant of the above but now the output is in unformatted 
or binary form:   

152
9 Output of Results
 Try this example out with your compiler. Unformatted is very efﬁ cient in terms of 
time. It also has the beneﬁ t for real or ﬂ oating point numbers of no information loss.  

153
9.18 Problems
 9.17  Summary 
 You have been introduced in this chapter to the use of format or layout descriptors 
which will give you greater control over output. 
 The main features are:
 The I format for integer variables. 
• 
 The E and F formats for real numbers. 
• 
 The A format for characters. 
• 
 The X, which allows insertion of spaces. 
• 
 Output can be directed to ﬁ les as well as to the terminal through the write 
statement. 
 The write, together with the open and close statements, also introduces the class 
of Fortran statements which use equated keywords, as well as positionally depen-
dent parameters. 
 The format statement and its associated layout or edit descriptor are powerful 
and allow repetition of patterns of output (both explicitly and implicitly). 
 When output is to be directed to a line printer, the following four characters:
 + 
• 
 0 
• 
 1 
• 
 (blank) 
• 
allow reasonable control over the layout. Care must to be taken with these charac-
ters, since it is possible to decimate forests with little effort. 
 9.18  Problems 
  1.  Rewrite the temperature conversion program which was problem 3 in Chap.  7 
to actually produce the output shown. 
  2.  Write a litres and pints conversion program to produce a similar kind of output 
to problem one above. Start at 0 and make the central column go up to 50. One 
pint is 0.568 l. 
  3.  Information on car fuel consumption is usually given in miles per gallon in 
Britain and the United States and in litres per 100 km in Europe. Just to add an 
extra problem US gallons are 0.8 imperial gallons. 
   Prepare a table which allows conversion from either US or imperial fuel con-
sumption ﬁ gures to the metric equivalent. Use the parameter statement where 
appropriate:
 
 
 1 imperial gallon
4.54596 litres
 1 mile
1.60934 kilometres
=
=
  
 

154
9 Output of Results
  4.  The two most commonly used operating systems for Fortran programming are 
UNIX and DOS. It is possible to use the operating system ﬁ le redirection 
symbols < and > to read from a ﬁ le and write to a ﬁ le, respectively. Rerun the 
program in problem 1 to write to a ﬁ le. Examine the ﬁ le using an editor. 
  5.  Modify any of the above to write to a ﬁ le rather than the terminal. What changes 
are required to produce a general output which will be suitable for both the 
terminal and a line printer? Is this degree of generality worthwhile? 
  6.  To demonstrate your familiarity with formats, reformat problems 1, 2 or 3 to 
use E formats, rather than F (or vice versa). 
  7.    Modify the temperature conversion program to produce output suitable for a line 
printer. Use the local operating system commands to send the ﬁ le to be printed. 
  8.  Repeat for the litres and pints program. 
  9.  What features of Fortran reveal its evolution from punched card input? 
 10.  Try to create a real number greater than the maximum possible on your com-
puter – write it out. Try to repeat this for an integer. You may have to exercise 
some ingenuity. 
 11.  Check what a number too large for the output format will be printed as on your 
local system – is it all asterisks? 
  12.  Write a program which stores litres and corresponding pints in arrays. You should 
now be able to control the output of the table (excluding headings – although this 
could be done too) in a single write or print statement. If you don’t like litres and 
pints, try some other conversion (£ sterling to US dollars, leagues to fathoms, 
Scots miles to Betelgeusian pfnings). The principle remains the same.  
 13.  Fortran is an old programming language and the text formatting functionality 
discussed in this chapter assumes very dumb printing devices. 
 The primary assumption is that we are dealing with so-called monospace fonts, 
i.e., that digits, alphabetic characters, punctuation, etc., all have the same width. 
 If you are using a PC try using:
 Notepad
• 
 and
 Word 
• 
to open your programs and some of the ﬁ les created in this chapter. What hap-
pens to the layout? 
 If you are using Notepad look at the Word wrap and set Font options under the 
edit menu. 
 What fonts are available? What happens to the layout when you choose another 
font? 
 If you are using Word what fonts are available? What happens when you make 
changes to your ﬁ le and exit Word? Is it sensible to save a Fortran source ﬁ le as a 
Word document? 

155
 Aims 
 The aims of this chapter are to introduce some of the ideas involved in reading data 
into a program. In particular, using the following:
 Reading from ﬁ xed ﬁ elds. 
• 
 Integers, reals and characters. 
• 
 Blanks – nulls or zero? 
• 
 read – extensions.
• 
 error handling on input. 
 –
 open – associating unit numbers and ﬁ le names.
• 
 close 
 –
 rewind 
 –
 backspace 
 –
 Chapter 10 
 Reading in Data 
 Winnie-the-Pooh read the two notices very carefully, 
 ﬁ rst from left to right, and afterwards, 
 in case he had missed some of it, from right to left. 
 A A Milne, Winnie-the-Pooh 
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_10, © Springer-Verlag London Limited 2012

156
10 Reading in Data
 10.1  Reading from the Terminal or Keyboard 
Versus Reading from Files 
 It is unlikely that you would use ﬁ xed formats when reading numeric input from the 
terminal or keyboard; they are more likely to be used when reading data from a ﬁ le. 
However the examples that follow do it. We look at reading from ﬁ les later in this 
chapter. 
 10.2  Fixed Fields on Input 
 All the formats described earlier are available, and again they are limited to particu-
lar types. Integers may only be input by the I format, reals with F and E, and char-
acter (alphanumeric) with A. 
 10.2.1  Integers and the I Format 
 Integers are read in with the I edit descriptor. Whereas, on output, integers appear 
right justiﬁ ed, on input they may appear anywhere in the ﬁ eld you have delimited. 
Blanks (by default) are considered not to exist for the purpose of the value read, 
although they do contribute to the ﬁ eld width. Apart from the digits 0–9, the only 
other characters which may appear in an integer ﬁ eld are − and +. 
 10.2.2  Example 1: Skipping Data Whilst Reading 
 Consider the following 12 times table:
 1 * 12  =  12 
 2 * 12  =  24 
 3 * 12  =  36 
 4 * 12  =  48 
 5 * 12  =  60 
 6 * 12  =  72 
 7 * 12  =  84 
 8 * 12  =  96 
 9 * 12  =  108 
 10 * 12  =  120 
 11 * 12  =  132 
 12 * 12  =  144 

157
10.2 Fixed Fields on Input
 The following is a program to read the ﬁ rst and last columns of integer data:
 program ch1001  
 implicit none  
 integer , parameter :: n =  12 
 integer :: I  
 integer , dimension(1:n) :: x  
 integer , dimension(1:n) :: y 
do i =  1,n 
 read 100, x(i),y(I)  
 100 format (2x,i2,9x,i3)  
 print 200,x(i),y(I)  
 200 format(1x,i3,2x,i3) 
end do  
 end program ch1001  
 The
 read 100,x(i),y(I)  
 will try reading values into x(I) and y(I) using format statement
 100 format (2x,i2,9x,i3)  
 which will skip the ﬁ rst two characters on the line or record, read the ﬁ rst value from 
the next two columns, skip the next nine characters and read the last value from the 
next three characters. 
 We recommend that when working with formatted ﬁ les you to use a text editor 
that displays the column and line details. 
 Notepad under Windows has a status bar option under the View menu. Gvim 
under Windows has line and column information available. Under Redhat, vim and 
gedit both display line and column information. User SuSe, kedit and vim display 
line and column information. There should be an editor available on your system 
that has this option. 
 10.2.3  Reals and the F Format 
 Real numbers may be input using a variety of formats and we will look at the F 
format in this example. Consider the following BMI data:
 1.85 85  
 1.80 76  
 1.85 85  
 1.70 90  
 1.75 69  
 1.67 83  
 1.55 64  

158
10 Reading in Data
 1.63 57  
 1.79 65  
 1.78 76  
 The following program will read in the data:
 program ch1002  
 implicit none  
 integer , parameter :: n=10  
 real , dimension(1:n) :: h  
 real , dimension(1:n) :: w  
 real , dimension(1:n) :: bmi  
 integer :: I 
 do i=1,n 
 read 100, h(i),w(I)  
 100 format(f4.2,2x,f3.0)  
 end do  
 bmi=w/(h*h)  
 do i=1,n 
 print 200,bmi(I)  
 200 format (2x, f5. 0)  
 end do  
 end program ch1002  
 To read in the heights we need a total width of four columns with two after the 
decimal point. We then skip two spaces and read in the weights. The data in the ﬁ le 
do not have a decimal point! 
 10.2.4  Reals and the E Format 
 An exponential format number (which may be read in F or E formats) can take a 
number of different forms. The most obvious is the explicit form
 − 1.2E-4  
 where all the components of the value are present – the signiﬁ cant digits to the left 
of the E, the E itself, and the exponent to the right. We can drop (almost) any two of 
these three components, so:
 − 1.2 
 −1.2E 
 −1.2-4  
 −4 
 are all valid values. Only the ﬁ rst two are interpreted as the same numerical value, 
and just giving the exponent part would be interpreted by the format as giving only 

159
10.2 Fixed Fields on Input
the signiﬁ cant digits. if the exponent is to be given, there must be some signiﬁ cant 
digits as well. It is not even enough to give the E and assume that the program will 
interpret this as 10 to the power exponent.
 E-4 
 is not an acceptable exponential format value, although
 1E-4 
 would be. 
 There are opportunities for confusion with E formats.
 read(unit =  *,fmt =  102) X,Y  
 102 format(2E10.3)  
 with:
 10.23 -2  
 would be interpreted as X taking the value 10.23E-2 and Y taking the value 0.0, 
while with
 102 format (2F8.3)  
 X would be 10.23, and Y would be −2.0. 
 Although the decimal point may also be dropped, this might generate confusion 
as well. While
 4E3 
 45 
 45E-4 
 45–4 
 are all valid forms, if an E format is used, a special conversion takes place. A format 
like E10.8, when used with integral signiﬁ cant digits (no decimal point), uses the 8 
as a negative power of 10 scaling e.g.’
 3267E05  
 converts to
 3267*10**8*10**5  
 or
 3267*10**3  
 or
 3.267 

160
10 Reading in Data
 Therefore, the interpretation of, say, 136, read in E format, would depend on the 
format used: 
 value 
 format 
 Interpretation 
 136 
 E10.0 
 136.0 
 136 
 E10.4 
 136.0*10**−4 
 or 
 0.0136 
 136 
 E10.10 
 136.0*10**−10 
 or 
 0.0000000136 
 136. 
 Any above 
 136.0 
 One implication of all this is that the format you use to input a variable may not 
be suitable to output that same variable. So given the data:
 136 
 136 
 136 
 136 
 136. 
 136. 
 136. 
 136. 
 and the program
 program ch1003  
 implicit none  
 real :: x 
 read 100,x  
 100 format(e10.0)  
 print *,x  
 read 200,x  
 200 format(e10.4)  
 print *,x  
 read 300,x  
 300 format(e10.10)  
 print *,x  
 read *,x  
 print *,x  
 read 100,x  
 print *,x  
 read 200,x  
 print *,x  
 read 300,x  
 print *,x  
 read *,x  
 print *,x  
 end program ch1003  

161
10.4 Characters
 We get the following output when the program is compiled with the Intel 
compiler: 
 Other compilers may give slightly different formatting of the output. 
 10.3  Blanks, Nulls and Zeros 
 You can control how Fortran treats blanks in input through two special format 
instructions, BN and BZ. BN is a shorthand form of blanks become null, that is, a 
blank is treated as if it were not there at all. BZ is therefore blanks become zeros. 
 As we have already seen, 1 4 (i.e., the two digits separated by a blank) read in I3 
format would be read as 14; similarly, 14 (one-four-blank) is also 14 when the BN 
format is in operation. All of the blanks are ignored for the purposes of interpreting 
the number. They help to create the width of the number, but otherwise contribute 
nothing. This is the default, which will be in operation unless you specify 
otherwise. 
 The BZ descriptor turns blanks into zeros. Thus, 1 4 (one-blank-four) read in I3 
format is 104, and 14 (one-four-blank) is 140. 
 There is one place where we must be very careful with the use of the BZ format – 
when using exponent format input. Consider
 5.321E+02  
 read in (BZ,E10.3) format. We have speciﬁ ed a ﬁ eld which is ten characters wide; 
therefore the blank in column 10, which follows the E+02, is read as a zero, making 
this E+020. This is probably not what was required. 
 10.4  Characters 
 When characters are read in, it is sufﬁ cient to use the A format, with no explicit 
mention of the size of the character string, since this size (or length) is determined 

162
10 Reading in Data
in the program by the character declaration. This implies that any extra characters 
would not be read in. You may however read in less:
 character (10) :: LIST  
. 
 . 
 read(unit =  5,fmt =  100)LIST  
 100 format(A1)  
 would read only the ﬁ rst character of the input. The remaining nine characters of 
LIST would be set to blank. 
 The notion of blanks as nulls or zeros has no meaning for characters. The blank 
is a legitimate character and is treated as meaningful, completely distinct from the 
notion of a null or a zero. 
 A simple variant on ch1001 which uses the character variable temp to hold the 
text between the two numbers appears below:
 program ch1004  
 implicit none  
 integer , parameter :: n=12  
 integer :: I  
 integer , dimension(1:n) :: x  
 integer , dimension(1:n) :: y  
 character*9 :: temp 
 do i=1,n 
 read 100, x(i),temp,y(I)  
 100 format(2x,i2,a,i3)  
 print 200,x(i),y(I)  
 200 format(1x,i3,2x,i3)  
 end do  
 end program ch1004  
 Note that in the format statement we just use the A edit descriptor and the num-
ber of characters to read is picked up from the variable declaration. 
 10.5  Skipping Spaces and Lines 
 The X format is also useful for input. There may be ﬁ elds in your data which you do 
not wish to read. These are easily omitted by the X format:
 read(unit=*,fmt=100) A,B  
 100 format(F10.4,10X,F8.3)  

163
10.6 Reading
 Similarly, you can jump over or ignore entire records by using the oblique.
Do note, however, that
 read(unit=*,fmt=100) A,B  
 100 format(F10.4/F10.4)  
 would read A from one line (or record) and B from the next. To omit a record 
between A and B, the format would need to be
 100 format(F10.4//F10.4)  
 Another way to skip over a record is
 read(unit=*,fmt=100)  
 100 format()  
 with no variable name at all. 
 10.6  Reading 
 As you have already seen, reading, or the input of information, is accomplished 
through the read statement. We have used
 read *,X,Y 
 for list directed input from the terminal, and
 read(unit=*,fmt=100) X,Y  
 for formatted input from the terminal. These forms may be expanded to
 read(unit=*,fmt=*) X,Y  
 or
 read(unit=*,fmt=100) X,Y  
 for input from the terminal, or to
 read(unit=5,fmt=*) X,Y  
 or
 read(unit=5,fmt=100) X,Y  
 when we wish to associate the read statement with a particular unit number (or for-
mat label, for formatted input). As with the write statement, these last two read 
statements may be abbreviated to
 read(5,*) X,Y  
 and
 read(5,100) X,Y  

164
10 Reading in Data
 10.7  File Manipulation Again 
 The open and close statements are also relevant to ﬁ les which are used as input, 
and they may be used in the same ways. Besides introducing the notion of manipu-
lating lots of ﬁ les, the open statement allows you to change the default for the 
treatment of blanks. The default is to treat blanks as null, but the statement 
 blank='zero' changes the default to treat blanks as zeros. There are other 
parameters on the open, which are considered elsewhere. 
 Once you have opened a ﬁ le, you may not issue another open for the same ﬁ le 
until it has been  closed , except in the case of the  blank = parameter. You may 
change the default back again with
 open(unit=10,ﬁ le='Example.txt')  
 read(unit=10,fmt=100) A,B  
 … 
 open(unit=10,ﬁ le='Example.txt',blank='zero')
read(unit=10,fmt=100) A,B  
 This implies that, within the same input ﬁ le, you may treat some records as blank 
for null, and some as blank for zero. This sounds very dangerous, and is better done 
by manipulating individual formats if it has to be done at all. 
 Given that you may write a ﬁ le, you may also rewind it, in order to get back to 
the beginning. The syntax is similar to the other commands:
 rewind(unit=1)  
 This often comes in useful as a way of providing backing storage, where inter-
mediate data can be stored on ﬁ le and then used later in the processing. 
 The notion of records in Fortran input and output has been introduced. If you are 
conﬁ dent in your understanding of this ambiguous and nebulous concept, you can 
backspace through a ﬁ le, using the statement
 backspace(unit=1)  
 which moves back over a single record on the designated ﬁ le. There is no point in 
trying to backspace or rewind if the input is from the keyboard or terminal. 
 10.8  Reading Using Array Sections 
 Consider the following output: 

165
10.9 Timing of Reading Formatted Files
 A program to read this ﬁ le using array sections is as follows:
 program ch1005  
 implicit none  
 integer , parameter :: nrow=5  
 integer , parameter :: ncol=6  
 real , dimension(1:nrow, 1:ncol) :: & 
 Exam_Results = 0.0  
 real , dimension(1:nrow) :: & 
 People_average = 0.0  
 real , dimension(1:ncol) :: & 
 Subject_Average = 0.0  
 integer :: r,c 
 do r=1,nrow  
 read 100, (exam_results(r,1:ncol)), people_average®) 
100 format(1x,6(1x,f5.1),4x,f6.2)  
 end do  
 read *  
 read 110, subject_average(1:ncol)  
 110 format(1x,6(1x,f5.1))  
 do r=1,nrow  
 print 200,   (exam_results(r,c),c=1,ncol), people_average®)  
 200 format(1x,6(1x,f5.1),' = ',f6.2)  
 end do  
 print *, ' ==== ==== ==== ==== ==== ===='  
 print 210, subject average(1:ncol)  
 210 format(1x,6(1x,f5.1))  
 end program ch1005  
 Note also the use of
 read *  
 to skip a line. 
 If you are on a UNIX or Linux system use diff to compare the input and output 
ﬁ les. They should be the same. 
 10.9  Timing of Reading Formatted Files 
 A program to read a formatted ﬁ le is shown below:
 program ch1006  
 implicit none  
 integer , parameter :: n=1000000  
 integer , dimension(1:n) :: x  
 real , dimension(1:n) :: y  

166
10 Reading in Data
 integer : : I  
 real :: t,t1,t2,t3,t4,t5  
 character*10 :: comment 
 open(unit=10,ﬁ le='ch1006.txt',status='old')  
 call cpu_time(t)  
 t1=t 
 comment=' Initial '  
 print 100,comment,t1  
 do i=1,n 
 read(10,200) x(I)  
 200 format(1x, i10)  
 end do  
 call cpu_time(t)  
 t2=t-t1  
 comment = ' I read '  
 print 10 0,comment,t2  
 do i=1,n 
 read(10,300) y(I)  
 300 format(1x,f10.0)  
 end do  
 call cpu_time(t)  
 t3=t-t1−t2  
 comment = ' r read '  
 print 100,comment,t3  
 100 format(1x,a,2x, f7.3)  
 do I=1,10 
 print *,x(I), ' ' , y(I)  
 end do  
 end program ch1006  
 Some timing data from the Intel compiler follows: 

167
10.10 Timing of Reading Unformatted Files
 10.10  Timing of Reading Unformatted Files 
 The following is a program to read from an unformatted ﬁ le:
 program ch1007  
 implicit none  
 integer , parameter :: n=1000000  
 integer , dimension(1:n) :: x  
 real , dimension(1:n) :: Y  
 integer :: I  
 real :: t, t1, t2, t3, t4,t5  
 character* 10 :: comment 
 open(unit=10,ﬁ le='ch1007.dat',form='unformatted')  
 call cpu_time(t)  
 t1=t 
 comment=' Initial '  
 print 100,comment,t1  
 read(10) x  
 call cpu_time(t)  
 t2=t−t1  
 comment = ' I read '  
 print 100,comment,t2  
 read (10) y  
 call cpu_time(t)  
 t3=t−t1−t2  
 comment = ' r read '  
 print 100,comment,t3  
 100 format(1x,a,2x, f7.3)  
 do I=1,10 
 print *,x(I), ' ' , y(I)  
 end do  
 end program ch1007  
 Some timing data from the Intel compiler follows. 

168
10 Reading in Data
 10.11  Errors When Reading 
 In discussing some aspects of input, it has been pointed out that errors may be made. 
Where such errors are noticed, in the sense that something illegal is being attempted, 
there are two options:
 print a diagnostic message, and allow correction of the mistake. 
• 
 print a diagnostic message, and terminate the program. 
• 
 The only time that the ﬁ rst makes sense is when you are interacting with a pro-
gram at a terminal. Some Fortran implementations provide correction facilities in a 
case like this, but most do not. 
 Chapter 18 looks at how we handle errors in input data, together with a more in-
depth coverage of ﬁ le I/O. 
 10.12  Flexible Input Using Internal Files 
 Sometimes external data does not have a regular structure and it is not possible to use 
the standard mechanisms we have covered so far in this chapter. Fortran provides 
something called internal ﬁ les that allow us to solve this problem. The following 
example is based on a problem encountered whilst working at the following site
 http://www.shmu.sk/sk/?page=1  
 They have data that is in the following format
 #xxxxxxxxxx yyyyyyyyyy  
 where x and y can vary between 1 and 10 digits. The key here is to read the whole 
line (a maximum of 22 characters) and then scan the line for the blank character 
between the x and y digits. 
 We then use the  index intrinsic to locate the position of the blank character. We 
now have enough information to be able to read the x and y integer data into the 
variables n1 and n2.
 program ch1008  
 implicit none  
 integer:: ib1,ib2  
 integer:: n1, n2  
 character(len=22) :: buffer, buff1, buff2  
 ! program to read a record of the form  
 ! #xxxxxxxxxx yyyyyyyyyy  
 ! so that integers n1 = xxxxxxxxxx n2 = yyyyyyyyyy  
 ! where the number of digits varies from 1 to 10  
 ! use internal ﬁ les 

169
10.13 Summary
 print *, "input micael's numbers"  
 read(*,'(a)')buffer  
 ib1 = index(buffer, ' ')  
 ib2 = len_trim(buffer) 
 buff1 = buffer(2:ib1-1)  
 buff2 = buffer(ib1+1:ib2)  
 read(buff1, ' (i10) ')n1  
 read(buff2,'(i10)')n2  
 print*, 'n1 = ' ,n1  
 print*, 'n2 = ' ,n2  
 end program ch1008  
 The statement
 read (buff1, ' (i10) ')n1 
 reads from the string  buff1 and extracts the x number into the variable  n1 , and the 
statement
 read (buff2, '(i10)') n2  
 reads from the string  buff 2 and extracts the y number into the variable  n2 . 
 This is a very powerful feature and allows you to manage quite widely varying 
external data formats in ﬁ les.  buff1 and  buff2 are called internal ﬁ les in Fortran 
terminology. 
 10.13  Summary 
 Values may be read in from the keyboard, terminal or from another ﬁ le through 
ﬁ xed formats. 
 Much of the structure of input format statements is very similar to that of the 
output formats. Broadly speaking, data written out in a particular format may be 
read in by the same format. However, there is greater ﬂ exibility, and quite a variety 
of forms can be accepted on input. 
 A key distinction to make is the interpretation of blanks, as either nulls or zeros; 
alternative interpretations can radically alter the structure of the input data. 
 Fortran allows ﬁ le names to be associated with unit numbers through the open 
statement. This statement allows control of the interpretation of blanks, although 
this can also be done through the BN and BZ formats. 
 Files can also be manipulated through rewind and backspace. 

170
10 Reading in Data
 10.14  Problems 
 1.  Write a program that will read in two reals and one integer, using
 format(F7.3,I4,F4.1)  
 and that, in one instance treats blanks as zeros and in the second treats them as 
nulls. Use print * to print the numbers out immediately after reading them in. 
What do you notice? Can you think of instances where it is necessary to use one 
rather than the other? 
 2.  Write a program to read in and write out a real number using
 format(F7.2)  
 What is the largest number that you can read in and write out with this format? 
What is the largest negative number that you can read in and write out with this 
format? What is the smallest number, other than zero, that can be read in and 
written out? 
 3.  Rewrite two of the earlier programs that used read,* and print,* to use format 
statements. 
 4.  Write a program to read the ﬁ le created by either the temperature conversion 
program or the litres and pints conversion program. Make sure that the programs 
ignore the line printer control characters and any header and title information. 
This kind of problem is very common in programming (writing a program to 
read and possibly manipulate data created by another program). 
 5.  Use the open, rewind, read and write statements to input a value (or values) as a 
character string, write this to a ﬁ le, rewind the ﬁ le, read in the values again, this 
time as real variables with blanks treated as null, and then repeat with blanks as 
zeros. 
 6.  Demonstrate that input and output formats are not symmetric – i.e., what goes in 
does not necessarily come out. 
 7.  Can you suggest why Fortran treats blanks as null rather than zero? 
 8.  What happens at your terminal when you enter faulty data, inappropriate for the 
formats speciﬁ ed? We will look at how we address this problem in Chapter 18. 

171
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_11, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are:
 To review the process of ﬁ le creation at a terminal. 
• 
 To introduce more formally the idea of the ﬁ le as a fundamental entity. 
• 
 To show how ﬁ les can be declared explicitly by the open and close statements. 
• 
 To introduce the arguments for the open and close statements. 
• 
 To demonstrate the interaction between the read/write statements and the open/
• 
close statements. 
 11.1  Introduction 
 When you work interactively at a computer, you are working with ﬁ les, ﬁ les that 
contain programs, ﬁ les that contain data, and perhaps ﬁ les that are libraries. The ﬁ le 
is fundamental to most modern operating systems, and almost all operations are 
carried out on ﬁ les. 
 In this chapter we are going to extend some of your ideas about ﬁ les. Let us con-
sider what kinds of ﬁ les you have met so far:
 1.  Text ﬁ les. These are the source of your programs, compilation listings, etc. They 
can be examined by printing them. They can also be transmitted around a com-
puter system fairly easily. A ﬁ le sent to a printer is a text ﬁ le. Mail messages are 
generally plain text ﬁ les. Note that when mail messages arrive in your mail box 
they will then typically contain additional nonprintable information. 
 Chapter 11 
 Files 
 It is a capital mistake to theorise before one has data. 
 Sir Arthur Conan Doyle 

172
11 Files
 2.  Data ﬁ les. These exist in two main forms: ﬁ rstly those prepared by using an 
editor, (hence a text ﬁ le) and those prepared using a package or program, in a 
computer readable form, but not directly readable by a human. 
 3.  Binary, object or relocatable ﬁ les, e.g., output from the compiler, satellite data. 
They cannot be printed. To examine ﬁ les like these you need to use special utili-
ties, provided by most operating systems. 
 The above categories account for the majority of ﬁ les that you have met so far. 
 If you use a word processor then you will also have met ﬁ les that are textual with 
additional nonprintable information. 
 Let us now consider how we can manipulate ﬁ les using Fortran. They will gener-
ally be data ﬁ les, and will thus be text ﬁ les. They can therefore be listed, etc., using 
standard operating system commands. 
 11.2  Data Files in Fortran 
 These allow us to associate a logical unit number with any arbitrary ﬁ le name during 
the running of the program; e.g.,
 open(unit=1,ﬁ le='data.txt')  
would associate the name data and the logical unit 1, so that
 read(unit=1,fmt=100) X  
would read from data. Note that for this to work on some operating systems the ﬁ le 
data must be local to the session; we specify the name as a character variable. If we 
then wanted to use a subsequent data ﬁ le, we could have another open statement, but 
if we want to use the same logical unit number, we must ﬁ rst close the ﬁ le
 close(unit=1)  
before we
 open(unit=1,ﬁ le='data2.txt')  
 In this way we can keep referring to logical unit 1, but change the ﬁ le associated 
with it. This can be useful in interactive programs where we wish to analyse differ-
ent sets of data, e.g.:
 program ch1101  
 implicit none  
 real :: x  
 character (7) :: which 
 open(unit=5,ﬁ le='input') 
 do 
 write(unit=6,fmt='('' data set name, or end'')') 
 read(unit=5,fmt='(a)') which  

173
11.3 Summary of Options on Open
 if(which == 'end') exit  
 open(unit=1,ﬁ le=which)  
 read(unit=1,fmt=100) x  
 ! ... 
 
 close(unit=1)  
 end do  
 end program ch1101  
 One useful feature of the open statement is that there are other parameters. What 
would happen, for example, if the ﬁ le is not there? To take care of this you can use 
the iostat and status keywords, e.g.,
 open(1,ﬁ le='data.txt',iostat=ﬁ lestat,status='old') 
status can be equated to one of four values:
 status='old' 
 status='new' 
 status='scratch' 
 status='unknown' 
 If we say status = 'new', we are creating a new ﬁ le and it should not matter whether 
a ﬁ le of the same name is present; 'scratch' does not concern us, while 'unknown' 
implies that if a ﬁ le of the correct name is present use it, but if not create a 'new' one. 
if you omit the status = keyword altogether, the value 'unknown' will be assumed, if 
we use status = 'old' and the ﬁ le is not present, this will cause an error which will be 
reﬂ ected in the value associated with the variable  open_ﬁ le_status. Consider the 
following example:
 ... 
 
 open(unit=1,ﬁ le='data.txt',iostat=ﬁ lestat,status='old')  
 if (ﬁ lestat > 0) then 
 print *,' error opening ﬁ le, please check' 
 stop 
 end if  
 read(unit=1,fmt=100) x  
 ... 
 
 The program will terminate after printing an appropriate error message. The 
standard deﬁ nes that if an error occurs then IOSTAT will return a positive integer 
value. A value of zero is returned if there is no error. 
 11.3  Summary of Options on Open 
 unit : The unit number of the ﬁ le to be opened. 
 iostat : The I/O status speciﬁ er designates a variable to store a value indicating the 
status of a data transfer operation. It takes the following form: 

174
11 Files
 iostat= i-var 
 i-var – is a scalar integer variable. When a data transfer statement is executed, i-var 
is set to one of the following values:
 A positive integer indicating that an error condition occurred. 
• 
 A negative integer indicating that an end-of-ﬁ le or end-of-record condition 
• 
occurred. The actual values vary between compilers. 
 Zero indicating no error, end-of-ﬁ le, or end-of-record condition occurred. 
• 
 Execution continues with the statement following the data transfer statement or 
the statement identiﬁ ed by a branch speciﬁ er (if any). 
 An end-of-ﬁ le condition occurs only during execution of a sequential read state-
ment; an end-of-record condition occurs only during execution of a non advancing 
read statement.
 ﬁ le : character expression specifying the ﬁ le name. 
 status : character expression specifying the ﬁ le status. It can be one of 'old', 'new', 
'scratch' or 'unknown'. 
 access : character expression specifying whether the ﬁ le is to be used in a sequential 
or random fashion. Valid values are sequential (the default) or direct. 
 The two most common access mechanisms for ﬁ les are sequential and direct. 
Consider a ﬁ le with 1,000 records. to get at record 789 in a sequential ﬁ le means 
reading or processing the ﬁ rst 788 records. to get at record 789 in a direct access ﬁ le 
means using a record number to immediately locate record 789. 
 form: character expression specifying
 formatted if the ﬁ le is opened for formatted i/o 
or
 unformatted if the ﬁ le is opened for unformatted i/o 
 The default is formatted for sequential access ﬁ les and unformatted for direct 
access ﬁ les. If the ﬁ le exists, form must be consistent with its present characteristics. 
 As noted earlier data are maintained internally in a binary format, not immedi-
ately comprehensible by humans. When we wish to look at the data we must write 
it in a formatted fashion, i.e., as a sequence of printable ASCII characters – text, or 
the written word. This formatting will carry with it an overhead in terms of the time 
required to do it. It will also carry with it the penalty of conversion from one number 
base (internally binary) to another and also loss of signiﬁ cance due to rounding with 
whatever edit descriptors are used, e.g., writing out as F7.4. 
 If we are interested in reusing data on the same system and compiler then we can 
use the unformatted option and avoid both the time overhead (as there is no conver-
sion between the internal and external formats) and the loss of signiﬁ cance associ-
ated with formatted data. 

175
11.4 More Foolproof I/O
 Please note that unformatted ﬁ les are rarely portable between different computer 
systems, and sometimes even between different compilers on the same system. 
 We will look again at the use of unformatted ﬁ les in Chapter ?? when we deal 
with efﬁ ciency and the space-time trade-off.
 recl : integer variable or constant specifying the record length for a direct access ﬁ le. 
It is speciﬁ ed in characters for a formatted ﬁ le and words for an unformatted ﬁ le. 
 blank : character expression having one of the following values:
 ‘null’ if blanks are to be ignored on reading. Note that a ﬁ eld of all blanks is treated 
as 0! 
 ‘zero’ if blanks are to be treated as zeros. 
 11.4  More Foolproof I/O 
 Fortran provides a way of writing more foolproof programs involving I/O. This is 
done via the iostat keyword on the read statement. Consider the following:
 program ch1102  
 implicit none  
 integer :: io_stat_number=−1  
 integer :: i 
 do 
print*,'input integer i:'  
 read (unit=*,fmt=10,&  
 iostat=io stat number) i  
 10 format(i3)  
 print *,' iostat=',io_stat_number  
 if (io_stat_number==0) exit  
 end do  
 print*, 'i = ',i,' read successfully'  
 end program ch1102  
 The following data input should be tried and the values of IO_Stat_Number 
should be examined
 A valid three-digit number + [return] key 
• 
 A three-digit number with an embedded blank, e.g., 12 + [return] key 
• 
 [return] key only 
• 
 [CTRL] + Z 
• 
 Any other nonnumeric character on the keyboard 
• 
 100200300 + [return] key 
• 
 [CTRL] + C 
• 
 This will then enable you to write programs that handle common I/O errors. 

176
11 Files
 Consider the following:
 program ch1103  
 implicit none  
 integer , dimension(10) :: A =& 
 (/−1,−1,−1,−1,−1,−1,−1,−1,−1,−1/)  
 integer :: io stat _number=0  
 integer :: i 
 open(unit=1,ﬁ le='data.txt',status='old')  
 do i=1,10 
 read (unit=1,fmt=10,iostat=io_stat_number) A(I)  
 10 format(I3)  
 if (io_stat_number == 0) then  
 cycle 
 elseif (io_stat_number == −1) then 
 print *,' end of ﬁ le detected at line ',i  
 print *,' please check data ﬁ le' 
 exit 
 elseif (io_stat_number > 0 ) then 
 print *,' non numeric data at line ',i  
 print *,' please correct data ﬁ le' 
 exit 
 endif 
 end do 
 do I=1, 10  
 print * , ' I = ',I,' A(I) = ',A(I)  
 enddo 
 end program ch1103  
 The above program is system speciﬁ c you will need to try it out with your 
compiler(s). 
 What happens with a completely blank line? 
 Note that in the above example the testing for the various conditions only exits 
the do loop for reading data from the ﬁ le. This means that execution would continue 
with the statement immediately after the end do statement. This may not be what we 
want in all cases, and the exit may be replaced with a stop statement to terminate 
execution immediately. 
 11.5  Summary 
 The ﬁ le is a fundamental entity within the operating system. 
 A ﬁ le may be manipulated in Fortran by associating its name with a unit number. 
All subsequent communication within the program is through the unit number. 

177
11.6 Problems
 When a ﬁ le is opened there are a large number of equatable keywords which may 
be employed to establish its characteristics. 
 The default ﬁ le type used in Fortran is sequential formatted, but several other 
esoteric types may be used. 
 11.6  Problems 
 1.  Write a program to write the ﬁ rst 500 integers to a ﬁ le using formatted I/O. Put 
10 values on a line, with a blank as the ﬁ rst character of the line, and eight col-
umns allowed for each integer, with two spaces between integer ﬁ elds. 
 Now write a program to read this ﬁ le into an array, and write the numbers in 
reverse order over the original data, i.e., the data ﬁ le now contains the ﬁ rst 500 
numbers in descending order. 
 Now modify the ﬁ rst program to add the next 500 integers to the same ﬁ le, so 
that the ﬁ le now comprises the ﬁ rst 500 numbers in descending order, and the 
next 500 numbers in ascending order. 
 2.  To write and maintain a crude database of student details, we might do the fol-
lowing: create separate ﬁ les for each year – CLAS1, CLAS2, CLAS3, or COF84, 
COF85, COF86, and so on. In either case there is an unchanging preﬁ x, CLAS 
or COF, and a variable sufﬁ x, which identiﬁ es membership within the overall 
group. In each of the ﬁ les we may wish to record details like name, date of birth, 
address, courses taken, etc. Such ﬁ les will require updating as details change or 
as errors are noted. Write (or sketch out) a program which would select and 
maintain such records and would allow corrected ﬁ les to be printed out. While 
you might feel that the most appropriate tool for this job is an editor, you might 
ﬁ nd it too powerful a tool. An editor can leave ﬁ les in a sorry state. Naturally, any 
program like this should be helpful (so called ‘user friendly’). Is this sort of 
information sensitive enough to require security checks and passwords? 

179
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_12, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are:
 To consider some of the reasons for the inclusion of functions in a programming 
• 
language. 
 To introduce, with examples, some of the predeﬁ ned functions available in 
• 
Fortran. 
 To introduce a classiﬁ cation of intrinsic functions, generic, elemental, 
• 
transformational. 
 To introduce the concept of a user deﬁ ned function. 
• 
 To introduce the concept of a recursive function. 
• 
 To introduce the concept of user deﬁ ned elemental and pure functions. 
• 
 To brieﬂ y look at scope rules in Fortran for variables and functions. 
• 
 To look at internal user deﬁ ned functions. 
• 
 12.1  Introduction 
 The role of functions in a programming language and in the problem-solving 
process is considerable and includes:
 Allowing us to refer to an action using a meaningful name, e.g., sine(x) a very 
• 
concrete use of abstraction. 
 Chapter 12 
 Functions 
 I can call spirits from the vasty deep. 
 Why so can I, or so can any man; but will they come 
 when you do call for them? 
 William Shakespeare, King Henry IV, part 1 

180
12 Functions
 Providing a mechanism that allows us to break a problem down into parts, giving 
• 
us the opportunity to structure our problem solution. 
 Providing us with the ability to concentrate on one part of a problem at a time and 
• 
ignore the others. 
 Allowing us to avoid the replication of the same or very similar sections of code 
• 
when solving the same or a similar subproblem which has the secondary effect 
of reducing the memory requirements of the ﬁ nal program. 
 Allowing us to build up a library of functions or modules for solving particular 
• 
subproblems, both saving considerable development time and increasing our 
effectiveness and productivity. 
 Some of the underlying attributes of functions are:
 They take parameters or arguments. 
• 
 The parameter can be an expression. 
• 
 A function will normally return a value and the value returned is normally depen-
• 
dent on the parameter(s). 
 They can sometimes take arguments of a variety of types. 
• 
 Most languages provide both a range of predeﬁ ned functions and the facility to 
deﬁ ne our own. We will look at the predeﬁ ned functions ﬁ rst. 
 12.2  An Introduction to Predeﬁ ned Functions and Their Use 
 Fortran provides over a hundred intrinsic functions and subroutines. For the pur-
poses of this chapter a subroutine can be regarded as a variation on a function. 
Subroutines are covered in more depth in a later chapter. They are used in a 
straightforward way. if we take the common trigonometric functions, sine, cosine 
and tangent, the appropriate values can be calculated quite simply by:
 
 
( )
( )
( )
=
=
=
x
sin y
z
cos y
a
tan y   
 
 This is in rather the same way that we might say that X is a function of Y, or X is 
sine Y. Note that the argument, Y, is in radians not degrees. 
 12.2.1  Example 1: Simple Function Usage 
 A complete example is given below:
 program ch1201  
 implicit none  
 real :: x 

181
12.3 Generic Functions
 print *, ' type in an angle (in radians) '  
 read *,x  
 print *,' Sine of ', x ,' = ',sin(x)  
 end program ch1201  
 These functions are called intrinsic functions. A selection is follows: 
 function 
 Action 
 Example 
 int 
 Conversion to integer 
 j=int(x) 
 real 
 Conversion to real 
 x=real(j) 
 abs 
 Absolute value 
 x=abs(x) 
 mod 
 Remaindering 
 k=mod(i,j) 
 Remainder when I divided by j 
 sqrt 
 Square root 
 x=sqrt(y) 
 exp 
 Exponentiation 
 y=exp(x) 
 log 
 Natural logarithm 
 x=log(y) 
 log 10 
 Common logarithm 
 x=log10(y) 
 sin 
 Sine 
 x=sin(y) 
 cos 
 Cosine 
 x=cos(y) 
 tan 
 Tangent 
 x=tan(y) 
 asin 
 Arc sine 
 y=asin(x) 
 acos 
 Arccosine 
 y=acos(x) 
 atan 
 Arctangent 
 y=atan(x) 
 atan2 
 Arctangent(a/b) 
 y=atan2(a,b) 
 A complete list is given in Appendix C. 
 12.3  Generic Functions 
 All but four of the intrinsic functions and procedures are generic, i.e., they can be 
called with arguments of one of a number of kind types. 
 12.3.1  Example 2: The  abs Generic Function 
 The following short program illustrates this with the  abs intrinsic function:   

182
12 Functions
 Type this program in and run it on the system you use. 
 It is now possible with Fortran for the arguments to the intrinsic functions to be 
arrays. It is convenient to categorise the functions into either elemental or transfor-
mational, depending on the action performed on the array elements. 
 12.4  Elemental Functions 
 These functions work with both scalar and array arguments, i.e., with arguments 
that are either single or multiple valued. 
 12.4.1  Example 3: Elemental Function Use 
 Taking the earlier example with the evaluation of sine as a basis, we have:
 program ch1203  
 implicit none  
 real , dimension(5) :: x = (/1.0,2.0,3.0,4.0,5.0/) 
 print *,' sine of ', x ,' = ',sin(x)  
 end program ch1203  
 In the above example the sine function of each element of the array x is calcu-
lated and printed. 
 12.5  Transformational Functions 
 Transformational functions are those whose arguments are arrays, and work on 
these arrays to transform them in some way. 
 12.5.1  Example 4: Simple Transformational Use 
 To highlight the difference between an element-by-element function and a transfor-
mational function consider the following examples:
 program ch1204  
 implicit none  
 real , dimension(5) :: x = (/1.0,2.0,3.0,4 . 0,5 . 0/)  
 ! elemental function 
 print *, ' Sine of ' , x , ' = ',sin(x)  
 ! Transformational function 
 print *, ' Sum of ' , x , ' = ',sum(x)  
 end program ch1204  

183
12.7 Example 6: Easter
 The sum function adds each element of the array and returns the sum as a scalar, 
i.e., the result is single valued and not an array. 
 12.5.2  Example 5: Intrinsic  dot_product Use 
 The following program uses the transformational function  dot_ product: 
 program ch1205  
 implicit none  
 real , dimension(5) :: x = (/1.0,2.0,3.0,4.0,5.0/) 
 print *,' Dot product of x with x is'  
 print *,' ',dot_product(x,x)  
 end program ch1205  
 Try typing these examples in and running them to highlight the differences 
between elemental and transformational functions. 
 12.6  Notes on Function Usage 
 You should not use variables which have the same name as the intrinsic functions; 
e.g., what does sin(x) mean when you have declared sin to be a real array? 
 When a function has multiple arguments care must be taken to ensure that the 
arguments are in the correct position and of the appropriate kind type. 
 You may also replace arguments for functions by expressions, e.g.,
 x =  log(2.0)  
or
 x =  log(abs(y))  
or
 x =  log(abs(y) +  z/2.0)  
 12.7  Example 6: Easter 
 This example uses only one function, the mod (or modulus). It is used several times, 
helping to emphasise the usefulness of a convenient, easily referenced function. The 
program calculates the date of Easter for a given year. It is derived from an algo-
rithm by Knuth, who also gives a fuller discussion of the importance of its algo-
rithm. He concludes that the calculation of Easter was a key factor in keeping 

184
12 Functions
arithmetic alive during the Middle Ages in Europe. Note that determination of the 
Eastern churches’ Easter requires a different algorithm:   

185
12.9 Supplying Your Own Functions
 We have introduced a new statement here, the if then endif, and a variant the if 
then else endif. A more complete coverage is given in the chapter on control struc-
tures. The main point of interest is that the normal sequential ﬂ ow from top to bot-
tom can be varied. In the following case,
 if (expression) then  
 block of statements  
 endif 
if the expression is true the block of statements between the if then and the endif 
is executed. If the expression is false then this block is skipped, and execution pro-
ceeds with the statements immediately after the endif. 
 In the following case,
 if (expression) then  
 block 1  
 else 
 block 2  
 endif 
if the expression is true block 1 is executed and block 2 is skipped. if the expression 
is false then block 2 is executed and block 1 is skipped. Execution then proceeds 
normally with the statement immediately after the endif. 
 As well as noting the use of the mod generic function in this program, it is also 
worth noting the structure of the decisions. They are nested, rather like the nested 
do loops we met earlier. 
 12.8  Intrinsic Procedures 
 An alphabetical list of all intrinsic functions and subroutines is given in Appendix 
C. This list provides the following information:
 Function name. 
• 
 Description. 
• 
 Argument name and type. 
• 
 Result type. 
• 
 Classiﬁ cation. 
• 
 Examples of use. 
• 
 This appendix should be consulted for a more complete and thorough under-
standing of intrinsic procedures and their use in Fortran. 
 12.9  Supplying Your Own Functions 
 There are two stages here: ﬁ rstly, to deﬁ ne the function and, secondly, to reference 
or use it. Consider the calculation of the greatest common divisor of two integers. 

186
12 Functions
 12.9.1  Example 7: Simple User Deﬁ ned Function 
 The following deﬁ nes a function to achieve this:
 module gcd_module  
 contains  
 integer function gcd(a,b)  
 implicit none  
 integer , intent(in) :: a,b  
 integer :: temp 
 if (a < b) then  
temp=a  
 else 
 temp=b  
 endif 
 do while ((mod(a, temp) /= 0) .or. (mod(b,temp) / = 0)) 
 temp=temp-1  
 end do  
 gcd=temp  
 end function gcd  
 end module gcd module  
 To use this function, you reference or call it with a form like:
 program ch1207  
 use gcd_module  
 implicit none integer :: i,j,result  
 integer :: gcd 
 print *, ' type in two integers'  
 read *,i,j  
 result=gcd(i,j)  
 print *,' gcd is ',result  
 end program ch1207  
 We will start by talking about the actual function and then cover the following 
statements
 module gcd module  
 contains  
 .. 
 end module gcd_module 
and
 use gcd_module  
later. 
 The ﬁ rst line of the function
 integer function gcd(a,b)  

187
12.9 Supplying Your Own Functions
has a number of items of interest:
 Firstly the function has a type, and in this case the function is of type integer, i.e., 
• 
it will return an integer value. 
 The function has a name, in this case gcd. 
• 
 The function takes arguments or parameters, in this case  
• 
a and  b . 
 The structure of the rest of the function is the same as that of a program, i.e., we 
have declarations, followed by the executable part. This is because both a program 
and a function can be regarded as a program unit in Fortran terminology. We will 
look into this more fully in later chapters. 
 In the declaration we also have a new attribute for the integer declaration. The two 
parameters  a  and  b are of type integer, and the  intent ( in ) attribute means that 
these parameters will NOT be altered by the function. It is good programming practice 
for functions not to have side effects, i.e. not modify their arguments, and do no i/o. 
 The value calculated is returned through the function name somewhere in the 
body of the executable part of the function. In this case  gcd appears on the left-
hand side of an arithmetic assignment statement at the bottom of the function. The 
end of the function is signiﬁ ed in the same way as the end of a program:
 end function gcd  
 We then have the program which actually uses the function  gcd . In the program 
the function is called or invoked with  I and  j as arguments. The variables are called 
 a and  b in the function, and references to  a and  b in the function will use the values 
that  I and  j  have respectively in the main program. We cover the area of argument 
association in the next section. 
 Note also a new control statement, the do while enddo. In the following case,
 do while (expression)  
 block of statements  
 enddo 
the block of statements between the do while and the enddo is executed whilst the 
expression is true. There is a more complete coverage in Chap.  13 . 
 We have two options here regarding compilation. Firstly, to make the function 
and the program into one ﬁ le, and invoke the compiler once. Secondly, to make the 
function and program into separate ﬁ les, and invoke the compiler twice, once for 
each ﬁ le. With large programs comprising one program and several functions it is 
probably worthwhile to keep the component parts in different ﬁ les and compile 
individually, whereas if it consists of a simple program and one function then keep-
ing things together in one ﬁ le makes sense. 

188
12 Functions
 12.10  An Introduction to the Scope of Variables, Local 
Variables and Interface Checking 
 One of the major strengths of Fortran is the ability to work on parts of a problem at 
a time. This is achieved by the use of program units (a main program, one or more 
functions and one or more subroutines) to solve discrete subproblems. Interaction 
between them is limited and can be isolated, for example, to the arguments of the 
function. Thus variables in the main program can have the same name as variables 
in the function and they are completely separate variables, even though they have 
the same name. Thus we have the concept of a local variable in a program unit. 
 In the example above  I, j, result, are local to the main program. The 
declaration of  gcd is to tell the compiler that it is an integer, and in this case it is an 
external function. 
 a and  b in the function  gcd do not exist in any real sense; rather they will be 
replaced by the actual variable values from the calling routine, in this case by what-
ever values  I and  j have.  temp is local to  gcd. 
 A common programming error in Fortran 66 and 77 was mismatches between 
actual and dummy arguments. Problems caused by this were often very subtle and 
hard to ﬁ nd. 
 Fortran 90 introduced a solution to the problem via the use of modules and con-
tains statements. We have added
 module gcd_module  
 contains  
 .. 
 end module gcd_module  
around the function deﬁ nition, which contains the function in a module and the fol-
lowing statement in the main program
 use gcd module  
provides an explicit interface (in Fortran terminology) that requires the compiler to 
check at compile time that the call is correct, i.e. that there are the correct number 
of parameters, they are of the correct type and in this case that the function return 
type is correct. We will cover this area in greater depth in later chapters. 
 12.11  Recursive Functions 
 There is an additional form of the function header that must be used when the func-
tion is recursive. Recursion means the breaking down of a problem into a simpler 
but identical subproblem. The concept is best explained with reference to an actual 

189
12.11 Recursive Functions
example. Consider the evaluation of a factorial, e.g., 5!. From simple mathematics 
we know that the following is true:
 5!=5*4! 
 4!=4*3! 
 3!=3*2! 
 2!=2*1! 
 1!=1 
 and thus 5! = 5*4*3*2*1 or 120. 
 12.11.1  Example 8: Recursive Factorial Evaluation 
 Let us look at a program with recursive function to solve the evaluation of 
factorials.
 module factorial_module  
 implicit none  
 contains  
 recursive integer function factorial(I) result(answer)  
 implicit none  
 integer , intent(in)::I 
 if (I==0) then  
answer=1  
 else 
 answer=i*factorial(I-1)  
 end if  
 end function factorial  
 end module factorial_module  
 program ch1208  
 use factorial_module  
 implicit none  
 integer :: I, f 
 print *, ' type in the number, integer only'  
 read *,I  
 do while(i<0) 
 print *,' factorial only deﬁ ned for '  
 print *,' positive integers: re-input'  
 read *,I  
 end do  
 f=factorial(I)  
 print *, ' answer is' , f  
 end program ch1208  

190
12 Functions
 What additional information is there? Firstly, we have an additional attribute on 
the function header that declares the function to be recursive. Secondly, we must 
return the result in a variable, in this case  answer . Let us look now at what happens 
when we compile and run the whole program (both function and main program). If 
we type in the number 5 the following will happen:
 The function is ﬁ rst invoked with argument 5. The else block is then taken and 
• 
the function is invoked again. 
 The function now exists a second time with argument 4. The else block is then 
• 
taken and the function is invoked again. 
 The function now exists a third time with argument 3. The else block is then 
• 
taken and the function is invoked again. 
 The function now exists a fourth time with argument 2. The else block is then 
• 
taken and the function is invoked again. 
 The function now exists a ﬁ fth time with argument 1. The else block is then taken 
• 
and the function is invoked again. 
 The function now exists a sixth time with argument 0. The if block is executed 
• 
and Answer = 1. This invocation ends and we return to the previous level, with 
Answer = 1*1. 
 We return to the previous invocation and now answer = 2*1. 
• 
 We return to the previous invocation and now answer = 3*2. 
• 
 We return to the previous invocation and now answer = 4*6. 
• 
 We return to the previous invocation and now answer = 5*24. 
• 
 The function now terminates and we return to the main program or calling 
routine. The answer 120 is the printed out. 
 Add a  print *, I statement to the function after the last declaration and type 
the program in and run it. Try it out with 5 as the input value to verify the above 
statements. 
 Recursion is a very powerful tool in programming, and remarkably simple solu-
tions to quite complex problems are possible using recursive techniques. We will 
look at recursion in much more depth in the later chapters on dynamic data types, 
and subroutines and modules. 
 12.12  Example 9: Recursive Version of gcd 
 The following is another example of the earlier gcd function but with the algorithm 
in the function replaced with an alternate recursive solution:
 module gcd_module  
 implicit none  
 contains  
 recursive integer function gcd(i,j) result(answer)  
 implicit none  
 integer , intent(in) :: i,j 

191
12.13 Example 10: After Removing Recursion
 if (j==0) then  
 answer=I  
 else 
 answer=gcd(j,mod(i,j))  
 endif 
 end function gcd  
 endmodule gcd_module  
 program ch1209  
 use gcd_module  
 implicit none  
 integer :: i,j,result  
 print *,' type in two integers'  
 read *,i,j  
 result=gcd(i,j)  
 print *,' gcd is ',result  
 end program ch1209  
 Try this program out on the system you work with, look at the timing information 
provided, and compare the timing with the previous example. The algorithm is a 
much more efﬁ cient algorithm than in the original example, and hence should be 
much faster. On one system there was a 20-fold decrease in execution time between 
the two versions. 
 Recursion is sometimes said to be inefﬁ cient, and the following example looks at 
a nonrecursive version of the second algorithm. 
 12.13  Example 10: After Removing Recursion 
 The following is a variant of the above, with the same algorithm, but with the recur-
sion removed:
 module gcd_module  
 implicit none  
 contains  
 integer function gcd(i,j)  
 implicit none  
 integer , intent(inout) :: i,j  
 integer :: temp 
 do while (j/=0)
 temp=mod(i,j)  
 i=j 
 j=temp  
 end do  
 gcd=I 
 end function gcd  

192
12 Functions
 end module gcd module  
 program ch1210  
 use gcd_module  
 implicit noneinteger :: i,j,result 
 print *,' type in two integers'  
 read *,i,j  
 result=gcd(i,j)  
 print *,' gcd is ',result  
 end program ch1210  
 12.14  Internal Functions 
 An internal function is a more restricted and hidden form of the normal function 
deﬁ nition. 
 Since the internal function is speciﬁ ed within a program segment, it may only be 
used within that segment and cannot be referenced from any other functions or sub-
routines, unlike the intrinsic or other user deﬁ ned functions. 
 12.14.1  Example 11: Stirling’s Approximation 
 In this example we use Stirling’s approximation for large n,
 
 
π
æ
ö
=
ç
÷
è
ø
!
2
n
n
n
n
e
  
and a complete program to use this internal function is given below:
 program ch1211  
 implicit none  
 real :: result,n,r 
 print *, ' type in n and r'  
 read *,n,r  
 ! number of possible combinations that can  
 ! be formed when  
 ! r objects are selected out of a group of n  
 ! n!/r!(n-r)! 
 result=stirling(n)/(stirling(r)*stirling(n-r))  
 print *,result  
 print *,n,r  
 contains  

193
12.15 Pure Functions
 real function stirling (x) 
 real , intent(in) :: x  
 real , parameter :: pi=3.1415927, e =2.7182828  
 stirling=sqrt(2.*pi*x) * (x/e)**x  
 end function stirling  
 end program ch1211  
 The difference between this example and the earlier ones lies in the contains 
statement. The function is now an integral part of the program and could not, for 
example, be used elsewhere in another function. This provides us with a very pow-
erful way of information hiding and making the construction of larger programs 
more secure and bug free. 
 12.15  Pure Functions 
 We mentioned earlier that functions should not have side effects. If your functions 
do have side effects and are running the code on parallel systems we have the addi-
tional problem that it may not actually work! We would also like to be able to take 
advantage of automatic parallelisation if possible. In the following example we 
show how to do this using the  pure preﬁ x speciﬁ cation.
 module gcd_module  
 implicit none  
 contains 
 pure integer function gcd(a,b)  
 implicit none  
 integer , intent(in) :: a,b  
 integer :: temp 
 if (a < b) then
 temp=a  
 else 
 temp=b  
 endif 
 do while ( (mod (a, temp) /= 0) & 
.or. (mod(b,temp) /=0)) 
 temp=temp-1  
 end do  
 gcd=temp  
 end function gcd  
 end module gcd_module  
 program ch1212  
 use gcd_module  
 implicit none  
 integer :: i,j,result 

194
12 Functions
 print *, ' type in two integers'  
 read *,i,j  
 result=gcd(i,j)  
 print *,' gcd is ',result  
 end program ch1212  
 Subroutines can also be made pure. 
 12.15.1  Pure Constraints 
 The following are some of the constraints on pure procedures
 a dummy argument must be intent(in) 
• 
 local variables may not have the save attribute 
• 
 no i/o must be done in the procedure 
• 
 any procedures referenced must be pure 
• 
 you cannot have a stop statement in a pure procedure 
• 
 The above information should be enough to write simple pure functions. 
 12.16  Elemental Functions 
 Fortran 77 introduced the concept of generic intrinsic functions. Fortran 90 added 
elemental intrinsic functions and the ability to write generic user deﬁ ned functions. 
Fortran 95 squared the circle and enabled us to write elemental user deﬁ ned func-
tions. Here is an example to illustrate this.
 module reciprocal_module  
 contains  
 real elemental function reciprocal(a)  
 implicit none  
 real , intent(in) :: a  
 reciprocal=1.0/a  
 end function reciprocal  
 end module reciprocal_module  
 program ch1213  
 use reciprocal_module  
 implicit none  
 real : : x=10.0  
 real , dimension(5) :: y=[1.0,2.0,3.0,4.0,5.0] 
 print *, ' reciprocal of x is ', reciprocal (x)  
 print *, ' reciprocal of y is ', reciprocal (y)   
 end program ch1213  

195
12.17 Resumé
 Hence we can call our own elemental functions with both scalar and array 
arguments. 
 Elemental functions require the use of explicit interfaces, and we have therefore 
used modules to achieve this. 
 12.17  Resumé 
 There are a large number of Fortran supplied functions and subroutines (intrinsic 
functions) which extend the power and scope of the language. Some of these func-
tions are of generic type, and can take several different types of arguments. Others 
are restricted to a particular type of argument. Appendix C should be consulted for 
a fuller coverage concerning the rules that govern the use of the intrinsic functions 
and procedures. 
 When the intrinsic functions are inadequate, it is possible to write user deﬁ ned 
functions. Besides expanding the scope of computation, such functions aid in prob-
lem visualisation and logical subdivision, may reduce duplication, and generally 
help in avoiding programming errors. 
 In addition to separately deﬁ ned user functions, internal functions may be 
employed. These are functions which are used within a program segment. 
 Although the normal exit from a user deﬁ ned function is through the end, other, 
abnormal, exits may be deﬁ ned through the return statement. 
 Communication with nonrecursive functions is through the function name and 
the function arguments. The function must contain a reference to the function name 
on the left-hand side of an assignment. Results may also be returned through the 
argument list. 
 We have also covered brieﬂ y the concept of scope for a variable, local variables, 
and argument association. This area warrants a much fuller coverage and we will do 
this after we have covered subroutines and modules. 
 Here is the output from one compiler. 

196
12 Functions
 12.18  Formal Syntax 
 The syntax of a function is:
 [function preﬁ x] function_statement &  
 [result (result_name) ]  
 [speciﬁ cation part]  
 [execution_part]  
 [internal sub program part]  
 end [function [function name]]  
and preﬁ x is:
 [type speciﬁ cation] recursive  
or
 [recursive] type speciﬁ cation  
and the function_statement is:
 function function_name ([dummy argument name list] )  
 [ ] represent optional parts to the speciﬁ cation. 
 The simple syntax for a module as we have used them in this chapter is
 module module_name  
 contains  
 .. 
 end module module_name  
and
 use module_name  
in the calling routine. 
 12.19  Rules and Restrictions 
 The type of the function must only be speciﬁ ed once, either in the function state-
ment or in a type declaration. 
 The names must match between the function header and end function function 
name statement. 
 If there is a result clause, that name must be used as the result variable, so all 
references to the function name are recursive calls. 
 The function name must be used to return a result when there is no result clause. 
We will look at additional rules and restrictions in later chapters. 

197
12.21 Bibliography
 12.20  Problems 
 1.  Find out the action of the  mod  function when one of the arguments is negative. 
Write your own modulus function to return only a positive remainder. Don’t call 
it  mod ! 
 2.  Create a table which gives the sines, cosines and tangents for −1–91° in 1° inter-
vals. Remember that the arguments have to be in radians. What value will you 
give  p ? One possibility is  p = 4*atan(1.0). Pay particular attention to the follow-
ing angle ranges:
 −1,0,+1 
• 
 29,30,31 
• 
 44,45,46 
• 
 59,60,61 
• 
 89,90,91 
• 
 What do you notice about sine and cosine at 0 and 90 degrees? What do you 
notice about the tangent of 90 degrees? Why do you think this is? 
 Use a calculator to evaluate the sine, cosine at 0 and 90 degrees. do the same for 
the tangent at 90 degrees. Does this surprise you? 
 Repeat using a spreadsheet, e.g., Excel. 
 Are you surprised? 
 Repeat the Fortran program using one or more real kind types. 
 3.  Write a program that will read in the lengths a and b of a right-angled triangle 
and calculate the hypotenuse c. Use the Fortran  sqrt intrinsic. 
 4.  Write a program that will read in the lengths a and b of two sides of a triangle and 
the angle between them 9 (in degrees). Calculate the length of the third side c 
using the cosine rule:
 
 
θ
=
+
-
2
2
2
2
( )
c
a
b
abcos
  
 
 5.  Write a function to convert an integer to a binary character representation. It 
should take an integer argument and return a character string that is a sequence 
of zeros and ones. Use the program in Chap.  5 as a basis for the solution. 
 12.21  Bibliography 
 Abramowitz, M., Stegun, I.: Handbook of Mathematical Functions. Dover, New 
York (1968)
 This book contains a fairly comprehensive collection of numerical algorithms for 
many mathematical functions of varying degrees of obscurity. It is a widely used 
source. 

198
12 Functions
 Association of Computing Machinery (ACM)
 Collected Algorithms, 1960–1974 
  Transactions on Mathematical Software, 1975 – A good source of more special-
ised algorithms. Early algorithms tended to be in Algol, Fortran now 
predominates. 
 12.21.1  Recursion and Problem Solving 
 The following are a number of books that look at the role of recursion in problem 
solving and algorithms. 
 Hofstadter, D.R.: Gödel, Escher, Bach—An Eternal Golden Braid. Harvester Press, 
London (1979 )
 The book provides a stimulating coverage of the problems of paradox and con-
tradiction in art, music and mathematics using the works of Escher, Bach and 
Gödel, and hence the title. There is a whole chapter on recur sive structures and 
processes. The book also covers the work of Church and Turing, both of whom 
have made signiﬁ cant contributions to the theory of computing. 
 Kruse, R.L.: Data Structures and Program Design. Prentice-Hall, Englewood 
Cliffs (1994)
 Quite a gentle introduction to the use of recursion and its role in problem solving. 
Good choice of case studies with explanations of solutions. Pascal is used. 
 Sedgewick, R.: Algorithms in Modula 3. Addison-Wesley, Reading (1993)
 Good source of algorithms. Well written. The gcd algorithm was taken from this 
source. 
 Vowels, R.A.: Algorithms and Data Structures in F and Fortran. Unicomp, 
Tucson (1998)
 The only book currently that uses Fortran 90/95 and F. Visit the Fortran web site 
for more details. They are the publishers. 
 http://www.fortran.com/fortran/market.html 
 Wirth, N.: Algorithms + Data Structures = Programs. Prentice-Hall, Englewood 
Cliffs (1976)
 In the context of this chapter the section on recursive algorithms is a very worth-
while investment in time. 
 Wood, D.: Paradigms and Programming in Pascal. Computer Science Press, 
Rockville (1984)
 contains a number of examples of the use of recursion in problem solving. Also 
provides a number of useful case studies in problem solving. 

199
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_13, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to introduce:
 Selection among various courses of action as part of the algorithm. 
• 
 The concepts and statements in Fortran needed to support the above:
• 
 Logical expressions and logical operators. 
 One or more blocks of statements. 
 The if then endif construct. 
• 
 The if then else if endif construct. 
• 
 To introduce the case statement with examples. 
• 
 To introduce the do loop, in three forms with examples, in particular:
• 
 The iterative do loop. 
 The do while form. 
 The do … if then exit end do or repeat until form. 
 The cycle statement. 
 The exit statement. 
 Chapter 13 
 Control Structures 
 Summarizing: as a slow-witted human being I have a very small 
head and I had better learn to live with it and to respect my 
limitations and give them full credit, rather than try to ignore 
them, for the latter vain effort will be punished by failure. 
 Edsger W. Dijkstra, Structured Programming 

200
13 Control Structures 
 13.1  Introduction 
 When we look at this area it is useful to gain some historical perspective concerning 
the control structures that are available in a programming language. 
 At the time of the development of Fortran in the 1950s there was little theoretical 
work around and the control structures provided were very primitive and closely 
related to the capability of the hardware. 
 At the time of the ﬁ rst standard in 1966 there was still little published work 
regarding structured programming and control structures. The seminal work by 
Dahl, Dijkstra and Hoare was not published until 1972. 
 By the time of the second standard there was a major controversy regarding 
languages with poor control structures like Fortran which essentially were limited 
to the goto statement. The facilities in the language had led to the development and 
continued existence of major code suites that were unintelligible, and the pejorative 
term spaghetti was applied to these programs. Developing an understanding of what 
a program did became an almost impossible task in many cases. 
 Fortran missed out in 1977 on incorporating some of the more modern and intel-
ligible control structures that had emerged as being of major use in making code 
easier to understand and modify. 
 It was not until the 1990 standard that a reasonable set of control structures 
had emerged and became an accepted part of the language. The more inquisitive 
reader is urged to read at least the work by Dahl, Dijkstra and Hoare to develop 
some understanding of the importance of control structures and the role of struc-
tured programming. The paper by Knuth is also highly recommended as it pro-
vides a very balanced coverage of the controversy of earlier times over the goto 
statement. 
 13.2  Selection Among Courses of Action 
 In most problems you need to choose among various courses of action, e.g.,
 if overdrawn, then do not draw money out of the bank. 
• 
 if Monday, Tuesday, Wednesday, Thursday or Friday, then go to work. 
• 
 if Saturday, then go to watch Queens Park Rangers. 
• 
 if Sunday, then lie in bed for another two hours. 
• 
 As most problems involve selection between two or more courses of action it is 
necessary to have the concepts to support this in a programming language. Fortran 
has a variety of selection mechanisms, some of which are introduced below. 

201
13.2 Selection Among Courses of Action
 13.2.1  The Block if Statement 
 The following short example illustrates the main ideas: 
 If today is Sunday then the block of statements between the if and the endif is 
executed. After this block has been executed the program continues with the state-
ments after the endif. If today is not Sunday the program continues with the state-
ments after the endif immediately. This means that the statements after the endif are 
executed whether or not the expression is true. The general form is: 
 The logical expression is an expression that will be either true or false; hence its 
name. Some examples of logical expressions are given below:
 (Alpha >   = 10.1)  
Test if Alpha is greater than or equal to 10.1 
 (Balance <   = 0.0) 
 Test if overdrawn 
 (( Today == Saturday).OR.( Today == Sunday)) 
 Test if today is Saturday or Sunday 
 ((Actual - Calculated) <   = 1.0E-6) 
 Test if Actual minus Calculated is less than or equal to 1.0E-6 

202
13 Control Structures 
 Fortran has the following relational and logical operators: 
 operator 
 Meaning 
 type 
 = = 
 Equal 
 Relational 
 /= 
 Not equal 
 Relational 
 >= 
 Greater than or equal 
 Relational 
 <= 
 Less than or equal 
 Relational 
 < 
 Less than 
 Relational 
 > 
 Greater than 
 Relational 
 .AND. 
 And 
 Logical 
 .OR. 
 Or 
 Logical 
 .NOT. 
 Not 
 Logical 
 The ﬁ rst six should be self-explanatory. They enable expressions or variables to 
be compared and tested. The last three enable the construction of quite complex 
comparisons, involving more than one test; in the example given earlier there was a 
test to see whether today was Saturday or Sunday. 
 Use of logical expressions and logical variables (something not mentioned so 
far) is covered again in a later chapter on logical data types. 
 the ‘if expression then statements endif is called a block if construct. There is a 
simple extension to this provided by the else statement. Consider the following 
example:
 if (Balance > 0.0) then
 • draw money out of the bank else 
 else
 • borrow money from a friend 
 endif 
 Buy a round of drinks. 
 In this instance, one or other of the blocks will be executed. then execution will 
continue with the statements after the endif statement (in this case buy a round). 
 There is yet another extension to the block if which allows an elseif statement. 
Consider the following example: 

203
13.2 Selection Among Courses of Action
 Note that as soon as one of the logical expressions is true, the rest of the test is 
skipped, and execution continues with the statements after the endif. This implies 
that a construction like
 if(I  <  2)then  
 …  
 elseif(I  <  1)then  
 …  
 else  
 …  
 endif  
is inappropriate. if I is less than 2, the latter condition will never be tested. The else 
statement has been used here to aid in trapping errors or exceptions. This is recom-
mended practice. A very common error in programming is to assume that the data 
are in certain well-speciﬁ ed ranges. The program then fails when the data go outside 
this range. It makes no sense to have a day other than Monday, Tuesday, Wednesday, 
Thursday, Friday, Saturday or Sunday. 
 13.2.1.1 Example 1: Quadratic Roots 
 A quadratic equation is:
 
 
+
+
=
2
0
ax
bx
c
  
 
 This program is straightforward, with a simple structure. The roots of the qua-
dratic are either real, equal and real, or complex depending on the magnitude of the 
term B* *2–4 * A * C. The program tests for this term being greater than or less 
than zero: it assumes that the only other case is equality to zero (from the mechanics 
of a computer, ﬂ oating point equality is rare, but we are safe in this instance): 

204
13 Control Structures 
 13.2.1.2 Note 
 Given the understanding you now have about real arithmetic and ﬁ nite precision 
will the else block above ever be executed? 
 13.2.1.3 Example 2: Date Calculation 
 This next example is also straightforward. It demonstrates that, even if the condi-
tions on the if statement are involved, the overall structure is easy to determine. The 
comments and the names given to variables should make the program self-explana-
tory. Note the use of integer division to identify leap years:
 program ch1302  
 implicit none  
 integer : : Year , N , Month , Day , T
!  
 ! calculates day and month from year and  
 ! day-within-year  
 ! t is an offset to account for leap years.  
 ! Note that the ﬁ rst criteria is division by 4  
 ! but that centuries are only  
 ! leap years if divisible by 400  
 ! not 100 (4 * 25) alone.
!  
 print*,' year, followed by day within year' 
read*,Year,N
! 
checking for leap years  
 if ((Year/4)*4 == Year) then

205
13.2 Selection Among Courses of Action
T=1
if ((Year/400)*400 == Year) then  
 T=1
ELSEIF ((Year/100)*100 == Year) then  
 T=0
endif
else  
 T=0
endif  
 ! 
accounting for February
if(N > (59+T))then  
 Day=N+2-T
else  
 Day=N
endif  
 Month=(Day+91)*100/3055
day=(day+91)-(month*3055)/100
month=month-2  
 print*, ' calendar date is ', day , month , year
end program ch1302  
 13.2.2  The Case Statement 
 The case statement provides a very clear and expressive selection mechanism 
between two or more courses of action. Strictly speaking it could be constructed 
from the if the else if endif statement, but with considerable loss of clarity. Remember 
that programs have to be read and understood by both humans and compilers! 
 13.2.2.1 Example 3: Simple Calculator 
 Program ch1303 implicit none  
 !  
 ! Simple case statement example  
 !  
 Integer :: I,J,K  
 character :: operator 
 do  
 print *, ' type in two integers'  
 read *, I,J  
 print *,' type in operator'  
 read '(A)',operator Calculator : &  
 select case (operator) 
 case ('+') Calculator  
 K=I + J  

206
13 Control Structures 
 print *, ' Sum of numbers is ',K  
 case ('-') Calculator 
 K=I−J  
 print *,' Difference is ',K  
 case ('/') Calculator 
 K=I/J  
 print *,' Division is ',K 
 case ('*') Calculator  
 K =I*J  
 print *,' Multiplication is ',K  
 case default Calculator 
 exit  
 end select Calculator  
 end do  
 end program ch1303  
 The user is prompted to type in two integers and the operation that they would 
like carried out on those two integers. The case statement then ensures that the 
appropriate arithmetic operation is carried out. The program terminates when the 
user types in any character other than +, −, * or /. 
 The case default option introduces the exit statement. This statement is used in 
conjunction with the do statement. When this statement is executed control passes to 
the statement immediately after the matching end do statement. In the example above 
the program terminates, as there are no executable statements after the end do.  
 13.2.2.2 Example 4: Counting Vowels, Consonants, etc 
 This example is more complex, but again is quite easy to understand. The user types 
in a line of text and the program produces a summary of the frequency of the char-
acters typed in:
 program ch1304  
 implicit none  
 !  
 ! Simple counting of vowels, consonants,  
 ! digits, blanks and the rest  
 !  
 integer :: Vowels=0 , Consonants=0, Digits=0  
 integer :: Blank=0, Other=0, I  
 character :: Letter  
 character (LEN=80) :: Line read ' (A) ' , Line 
 do I=1,80  
 Letter=Line(I:I)  
 ! the above extracts one character at position I select case 
(Letter) 

207
13.3 The Three Forms of the do Statement
 case ('A','E','I','O','U', &  
 'a','e','I','o','u') 
 Vowels=Vowels + 1  
 case ('B', 'C', 'D', 'F', 'G', 'H', &  
 'J','K','L','M','N','P', &  
 'Q', 'R', 'S', 'T', 'V', 'W', &  
 'X','Y','Z',  
 'b','c','d','f','g','h', &  
 'j','k','l','m','n','p', &  
 'q','r','s','t','v','w',&  
 'x','y','z')  
 Consonants=Consonants + 1  
 case ('1', '2', '3', '4', '5', '6', '7', '8','9', '0') 
 Digits=Digits + 1  
 case (' ') 
 Blank=Blank + 1  
 case default 
 Other=Other+1  
 end select  
 end do  
 print *, ' Vowels = ', Vowels  
 print *, ' Consonants = ', Consonants  
 print *, ' Digits = ', Digits  
 print *, ' Blanks = ',Blank  
 print *, ' Other characters = ', Other  
 end program ch1304  
 13.3  The Three Forms of the do Statement 
 You have already been introduced in the chapters on arrays to the iterative form of 
the do loop, i.e.,
 do Variable = Start, End, Increment
 block of statements 
 end do 
 A complete coverage of this form is given in the three chapters on arrays. There 
are two additional forms of the block do that complete our requirements: 
 The ﬁ rst form is often called a while loop as the block of statements executes 
whilst the logical expression is true, and the second form is often called a repeat 
until loop as the block of statements executes until the statement is true. 
 Note that the while block of statements may never be executed, and the repeat 
until block will always be executed at least once. 

208
13 Control Structures 
 13.3.1  Example 5: Sentinel Usage 
 The following example shows a complete program using this construct:
 program ch1305  
 implicit none  
 ! this program picks up the ﬁ rst occurrence  
 ! of a number in a list.  
 ! a sentinel is used, and the array is 1 more  
 ! than the max size of the list.  
 integer , allocatable , dimension(:) : : A  
 integer :: Mark  
 integer :: I,Howmany 
 open (unit=1,ﬁ le='data.txt' )  
 print *, ' What number are you looking for?'  
 read *, Mark  
 print *, ' How many numbers to search?'  
 read *,Howmany  
 allocate(A(1:Howmany+1) )  
 read(unit=1,fmt=*) (A(i),I=1,Howmany)  
 I = 1  
 A(Howmany+1)= Mark  
 do while(Mark /= A(I)) 
 I = I + 1  
 end do  
 if(I == (Howmany+1)) then 
 print*,' item not in list'  
 else 
 print*,' item is at position ',I  
 endif  
 end program ch1305  
 The repeat until construct is written in Fortran as:
 do  
 …  
 … 
 if (Logical Expression) exit  
 end do  
 There are problems in most disciplines that require a numerical solution. The 
two main reasons for this are either that the problem can only be solved numerically 
or that an analytic solution involves too much work. Solutions to this type of prob-
lem often require the use of the repeat until construct. The problem will typically 
require the repetition of a calculation until the answers from successive evaluations 

209
13.3 The Three Forms of the do Statement
differ by some small amount, decided generally by the nature of the problem. A 
program extract to illustrate this follows: 
 Here the value of the tolerance is set to 1.0E–6. Note again the use of the exit 
statement. The do end do block is terminated and control passes to the statement 
immediately after the matching end do. 
 13.3.2  Cycle and Exit 
 These two statements are used in conjunction with the block do statement. You have 
seen examples above of the use of the exit statement to terminate the block do, and 
pass control to the statement immediately after the corresponding end do 
statement. 
 The cycle statement can appear anywhere in a block do and will immediately 
pass control to the start of the block do. Examples of cycle and exit are given in later 
chapters. 
 13.3.3  Example 6: e**x Evaluation 
 The function etox illustrates one use of the repeat until construct. The function 
evaluates e**x. This may be written as
 
 
2
3
1
x / 1!
x
/ 2!
x / 3!
+
+
+
…  
or
 
 
−
∞
=
+
−
∑
1
1
1
(
1) !
n
n
x
x
n
n   
Every succeeding term is just the previous term multiplied by x/n. At some point the 
term x/n becomes very small, so that it is not sensibly different from zero, and suc-
cessive terms add little to the value. The function therefore repeats the loop until x/n 

210
13 Control Structures 
is smaller than the tolerance. The number of evaluations is not known beforehand, 
since this is dependent on x:
 module etox_module  
 implicit none  
 contains  
 real function etox(x)  
 implicit none  
 real :: term  
 real , intent(in) :: x  
 integer :: nterm  
 real , parameter ::tol = 1.0E-6 
 etox=1.0  
 term=1.0  
 nterm=0  
 do 
 nterm = nterm +1  
 term = ( x / nterm) * term  
 etox = etox + Term  
 if (abs(term) <= tol)exit  
 end do  
 end function etox  
 end module etox module  
 program ch1306  
 use etox module  
 implicit none  
 real , parameter :: x=1.0  
 real : : y 
 print *,' Fortran intrinsic ',exp(x)  
 y=etox(x)  
 print *,' User deﬁ ned etox ',y  
 end program ch1306 
 The whole program compares the user deﬁ ned function with the Fortran intrinsic 
exp function. 
 13.3.4  Example 7: Wave Breaking on an Offshore Reef 
 This example is drawn from a situation where a wave breaks on an offshore reef or 
sand bar, and then reforms in the near-shore zone before breaking again on the 
coast. It is easier to observe the heights of the reformed waves reaching the coast 
than those incident to the terrace edge. 
 Both types of loops are combined in this example. The algorithm employed here 
ﬁ nds the zero of a function. Essentially, it ﬁ nds an interval in which the zero must 

211
13.3 The Three Forms of the do Statement
lie; the evaluations on either side are of different signs. The while loop ensures that 
the evaluations are of different signs, by exploiting the knowledge that the incident 
wave height must be greater than the reformed wave height (to give the lower 
bound). The upper bound is found by experiment, making the interval bigger and 
bigger. Once the interval is found, its mean is used as a new potential bound. The 
zero must lie on one side or the other; in this fashion, the interval containing the zero 
becomes smaller and smaller, until it lies within some tolerance. This approach is 
rather plodding and unexciting, but is suitable for a wide range of problems 
 Here is the program:
 program ch1307  
 implicit none  
 real : : Hi , Hr , Hlow , High , Half , Xl  
 real : : Xh , Xm , D  
 real , parameter :: Tol=1.0E-6  
 ! problem - ﬁ nd hi from expression given  
 ! in function f  
 ! F=A*(1.0-0.8*EXP(-0.6*C/A))-B  
 ! hi is incident wave height 
(c)  
 ! hr is reformed wave height 
(b)  
 ! d is water depth at terrace edge (a) 
 print*,' Give reformed wave height, and water depth'  
 read*,Hr,d  
 !  
 ! for Hlow- let Hlow=hr  
 ! for high- let high=Hlow*2.0  
 !  
 ! check that signs of function results are different  
 ! 
 Hlow = hr  
 high = hlow*2.0  
 xl = f( hlow, hr, d)  
 xh = f( high, hr, d)  
 ! 
 do while ( (xl*xh) >= 0.0)  
 high = high*2.0  
 xh = f(high,hr,d)  
 end do  
 ! 
 do  
 half=(hlow+high) *0.5  
 xm=f(half, hr, d)  
 if((xl*xm) < 0.0)then 
  xh=xm  
 high=half  

212
13 Control Structures 
 else 
 xl=xm  
 hlow=half  
 endif  
 if(abs(high-hlow)<= tol)exit  
 end do  
 print*,' Incident Wave Height Lies Between'  
 print*,Hlow, ' and ',high,' metres'  
 contains  
 real function f(a,b,c)  
 implicit none  
 real , intent (in) :: a  
 real , intent (in) :: b  
 real , intent (in) :: c 
 f=a*(1.0−0.8*exp(−0.6*c/a))−b  
 end function f  
 end program ch1307  
 13.4  Summary 
 You have been introduced in this chapter to several control structures and these 
include:
 The block if. 
• 
 The if then else if. 
• 
 The case construct. 
• 
 The block do in three forms:
• 
 The iterative do or do variable = start,end,increment … end do. 
 –
 The while construct, or do while … end do. 
 –
 The repeat until construct, or do … if then exit end do. 
 –
 The cycle and exit statements, which can be used with do statement in all three 
• 
forms:
 The do variable  
 –
= start,end,increment … end do. 
 The while construct, or do while … end do. 
 –
 The repeat until construct, or do … if then exit end do. 
 –
 These constructs are sufﬁ cient for solving a wide class of problems. There are 
other control statements available in Fortran, especially those inherited from Fortran 
66 and Fortran 77, but those covered here are the ones preferred. We will look in 
Chap.  35 at one more control statement, the so-called goto statement, with recom-
mendations as to where its use is appropriate. 

213
13.5 Problems
 13.4.1  Control Structure Formal Syntax 
 case
 select case ( case variable )
 [ case case selector  
 [executable construct ]  ...  ]  ...  
 [ case DEFAULT  
 [executable construct]  
 end select  
 do 
 do [ label ] 
 [executable construct ]  ...  
 do termination  
 do [ label ] [ , ] loop variable = initial value , 
ﬁ nal value , [ increment ]  
 [executable construct ]  ...  
 do termination  
 do [ label ] [ , ] while (scalar logical expression )  
 [executable construct ]  ...  
 do termination  
if
 if ( scalar logical expression ) then  
 [executable construct ]  ...  
 [ else if ( scalar logical expression then 
 [executable construct ]  ...  ]  ... ]  
 [ else 
 [executable construct ]  ... ]  
 end if 
 13.5  Problems 
 1.  Rewrite the program for the period of a pendulum. The new program should print 
out the length of the pendulum and period, for pendulum lengths from 0 to 
100 cm in steps of 0.5 cm. The program should incorporate a function for the 
evaluation of the period. 
 2.  Write a program to read an integer that must be positive. Hint. use a do while to 
make the user re-enter the value. 
 3.  Using functions, do the following:
 Evaluate n! from n  
• 
= 0 to n  = 10. 
 Calculate 76! 
• 

214
13 Control Structures 
 Now calculate (x**n)/n!, with x  
• 
= 13.2 and n  = 20. 
 Now do it another way. 
• 
 4.  The program ch1307 is taken from a real example. In the particular problem, the 
reformed wave height was 1 m, and the water depth at the reef edge was 2 m. 
What was the incident wave height? Rather than using an absolute value for the 
tolerance, it might be more realistic to use some value related to the re formed 
wave height. These heights are unlikely to be reported to better than about 5% 
accuracy. Wave energy may be taken as proportional to wave height squared for 
this example. What is the reduction in wave energy as a result of breaking on the 
reef or bar for this particular case. 
 5.  What is the effect of using int on negative real numbers? write a program to 
demonstrate this. 
 6.  How would you ﬁ nd the nearest integer to a real number? Now do it another way. 
Write a program to illustrate both methods. Make sure you test it for negative as 
well as positive values. 
 7.  The function etox has been given in this chapter. The standard Fortran function 
EXP does the same job. do they give the same answers? Curiously the Fortran 
standard does not specify how a standard function should be evaluated, or even 
how accurate it should be. 
 The physical world has many examples in which processes require that some 
threshold be overcome before they begin operation: critical mass in nuclear reac-
tions, a given slope to be exceeded before friction is overcome, and so on. 
Unfortunately, most of these sorts of calculations become rather complex and not 
really appropriate here. The following problem tries to restrict the range of cal-
culation, whilst illustrating the possibilities of decision making. 
 8.  If a cubic equation is expressed as
 
 
+
+
+
=
3
2
ax
 bx
cx 
d
0   
and we let
 
 Δ =
−
−
−
3
2
2
3
2
2
 18abcd 
4b d + b c
4ac
27a d   
 
 We can determine the nature of the roots as follows
 
 Δ > 0 :  three distinct real roots   
 
 Δ = 0 :  has a multiple root and all roots are real   
 
 Δ < 0 :  1 real root and 2 non real complex conjugate roots   
 

215
13.6 Bibliography
 Incorporate this into a program, to determine the nature of the roots of a cubic 
from suitable input. 
 9.  The form of breaking waves on beaches is a continuum, but for convenience we 
commonly recognise three major types: surging, plunging and spilling. These 
may be classiﬁ ed empirically by reference to the wave period, T (seconds), the 
breaker wave height, H b (metres), and the beach slope, m. These three variables 
are combined into a single parameter, B, where 
 
 
=
2
b
B
H /(gmT )   
 
 g is the gravitational constant (981 cm s −2 ). if B is less than 0.003, the breakers 
are surging; if B is greater than 0.068, they are spilling, and between these values, 
plunging breakers are observed.
 (i)  On the east coast of New Zealand, the normal pattern is swell waves, with 
wave heights of 1–2 m and wave periods of 10–15 s. During storms, the 
wave period is generally shorter, say 6–8 s, and the wave heights higher, 
3–5 m. The beach slope may be taken as about 0.1. What changes occur in 
breaker characteristics as a storm builds up? 
 (ii)  Similarly, many beaches have a concave proﬁ le. The lower beach generally 
has a very low slope, say less than 1 ° (m  = 0.018), but towards the high-tide 
mark, the slope increases dramatically, to say 10° or more (m  = 0.18). What 
changes in wave type will be observed as the tide comes in? 
 13.6  Bibliography 
 Dahl, O.J., Dijkstra, E.W., Hoare, C.A.R.: Structured Programming. Academic 
Press, London (1972)
 This is the original text, and a must. The quote at the start of the chapter by 
• 
Dijkstra summarises beautifully our limitations when programming and the dis-
cipline we must have to master programming successfully. 
 Knuth, D.E.: Structured Programming with goto Statements, in Current Trends in 
Programming Methodology, vol 1. Prentice-Hall (1977 )
 The chapter by Knuth provides a very succinct coverage of the arguments for the 
• 
adoption of structured programming, and dispels many of the myths concerning 
the use of the goto statement. Highly recommended. 

217
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_14, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are:
 To extend the ideas about characters introduced in earlier chapters. 
• 
 To demonstrate that this enables us to solve a whole new range of problems in a 
• 
satisfactory way. 
 14.1  Introduction 
 For each type in a programming language there are the following concepts:
 Values are drawn from a ﬁ nite domain. 
• 
 There are a restricted number of operations deﬁ ned for each type. 
• 
 For the numeric types we have already met, integers and reals:
 The values are either drawn from the domain of integer numbers or the domain 
• 
of real numbers. 
 The valid operations are addition, subtraction, multiplication, division and 
• 
exponentiation. 
 Chapter 14 
 Characters  
 These metaphysics of magicians, 
 And necromantic books are heavenly; 
 Lines, circles, letters and characters. 
 Christopher Marlowe, The Tragical History of Doctor Faustus 

218
14 Characters
 For the character data type the basic unit is an individual character The complete 
Fortran character set is given in Sect. 4.6 in Chap.  4 . This provides us with 95 print-
ing characters. Other characters may be available. The Wikipedia entry
  http://en.wikipedia.org/wiki/Character_encoding 
 has quite detailed information on how complex this area actually is. 
 As the most common current internal representation for the character data type uses 
8 bits this should provide access to 256 (2 8 ) characters. However, there is little agreement 
over the encoding of these 256 possible characters, and the best you can normally assume 
is access to the ASCII character set, which is given in Appendix B. One of the problems 
at the end of this chapter looks at determining what characters one has available. 
 The only operations deﬁ ned are concatenation (joining character strings together) 
and comparison. 
 We will look into the area of character sets in more depth later in this chapter. We 
can declare our character variables:
 character :: a, string, line  
 Note that there is no default typing of the character variable (unlike integer and 
real data types), and we can use any convenient name within the normal Fortran 
conventions. In the declaration above, each character variable would have been per-
mitted to store one character. This is limiting, and, to allow character strings which 
are several units long, we have to add one item of information:
 character (10) :: A  
 character (16) :: string  
 character (80) :: line 
 This indicates that A holds 10 characters, string holds 16, and line holds 80. if all 
the character variables in a single declaration contain the same number of charac-
ters, we can abbreviate the declaration to
 character(80) :: list, string, line  
 But we cannot mix both forms in the one declaration. We can now assign data to 
these variables, as follows:
 a='ﬁ rst one '  
 string='a longer one '  
 line='the quick brown fox jumps over the lazy dog'  
 The delimiter apostrophe (') or quotation mark (") is needed to indicate that this 
is a character string (otherwise the assignments would have looked like invalid vari-
able names). 
 14.2  Character Input 
 In an earlier chapter we saw how we could use the read * and print * statements to 
do both numeric and character input and output or I/O. When we use this form of 
the statement we have to include any characters we type within delimiters (either the 

219
14.3 Character Operators
apostrophe ' or the quotation mark "). This is a little restricting and there is a slightly 
more complex form of the read statement that allows one to just type the string on 
its own. The following two programs illustrate the differences:
 program ch1401  
 !  
 ! Simple character i/o  
 !  
 character (80) :: line 
 read *, line  
 print *, line  
 end program ch1401  
 This form requires enclosing the string with delimiters. Consider the next form:
 program ch1402  
 !  
 ! Simple character i/o  
 !  
 character (80) :: line 
 read '(a)' , line  
 print *,line  
 end program ch1402  
 With this form one can just type the string in and input terminates with the car-
riage return key. The additional syntax involves '(A)' where '(A)' is a character edit 
descriptor. The simple examples we have used so far have used implied format 
speciﬁ ers and edit descriptors. For each data type we have one or more edit descrip-
tors to choose from. For the character data type only the A edit descriptor is 
available. 
 14.3  Character Operators 
 The ﬁ rst manipulator is a new operator – the concatenation operator //. With this 
operator we can join two character variables to form a third, as in
 character (5) :: ﬁ rst, second  
 character (10) :: third  
 ﬁ rst='three'  
 second='blind'  
 …  
 third=ﬁ rst//second  
 .  
 third=ﬁ rst//'mice'  

220
14 Characters
where there is a discrepancy between the created length of the concatenated string and 
the declared lengths of the character strings, truncation will occur. For example,
 third =   ﬁ rst//' blind mice'  
 will only append the ﬁ rst ﬁ ve characters of the string 'blind mice' i.e., 'blin', and 
third will therefore contain 'three blin'. 
 What would happen if we assigned a character variable of length ‘n’ a string which 
was shorter than n? For example,
 character (4) :: c2  
 c2 =   'AB'  
 The remaining two characters are considered to be blank, that is, it is equivalent 
to saying
 C2 =   'AB'  
 However, while the strings 'AB' and 'AB' are equivalent, 'AB' and 'AB' are not. In 
the jargon, the character strings are always left justiﬁ ed, and the unset characters are 
trailing blanks. If we concatenate strings which have ‘trailing blanks’, the blanks, or 
spaces, are considered to be legitimate characters, and the concatenation begins 
after the end of the ﬁ rst string. Thus
 character (4) :: c2,c3  
 character (8) :: jj  
 c2='a'  
 c3='man'  
 jj=c2//c3  
 print*, 'the concatenation of ',c2, 'and',c3, 'is'  
 print*,JJ  
would appear as
 the concatenation of a and man gives  
 a man  
at the terminal. 
 Sometimes we need to be able to extract parts of character variables – substrings. 
The actual notation for doing this is a little strange at ﬁ rst, but it is very powerful. 
To extract a substring we must reference two items:
 The position in the string at which the substring begins, 
• 
and
 The position at which it ends. 
• 
e.g.,
 string =   'share and enjoy'  

221
14.4 Character Substrings
 14.4  Character Substrings 
 We may extract parts of this string:
 bit =   string(3:5)  
would place the characters 'are' into the variable bit. This may be manipulated 
further:
 bit1 =   string(2:4)//string(9:9)  
 bit2 =   string(5:5) // &  
 string(3:3)//string(1:1)//string(15:15)  
 Note that to extract a single character we reference its beginning position and its 
end (i.e., repeat the same position), so that
 string(3:3)  
gives the single character 'A'. The substring reference can cut out either one of the 
two numerical arguments. if the ﬁ rst is omitted, the characters up to and including 
the reference are selected, so that
 sub =   string(:5)  
would result in sub containing the characters ‘share’. When the second argument is 
omitted, the characters from the reference are selected, so that
 sub =   string(11:)  
would place the characters ‘enjoy’ in the variable sub. In these examples it would 
also be necessary to declare string, sub, bit, bit1 and bit2 to be of character type, of 
some appropriate length.character variables may also form arrays:
 character (10) , dimension(20) :: A 
sets up a character array of 20 elements, where each element contains 10 characters. 
In order to extract substrings from these array elements, we need to know where the 
array reference and the substring reference are placed. The array reference comes 
ﬁ rst, so that
 do I =   1,20  
ﬁ rst =   a(I)(1:1)  
 endo  
places the ﬁ rst character of each element of the array into the variable ﬁ rst. The 
syntax is therefore ‘position in array, followed by position within string’. 
 Any argument can be replaced by a variable:
 string(i:j)  

222
14 Characters
 This offers interesting possibilities, since we can, for example, strip blanks out of 
a string:
 program ch1403  
 implicit none 
 character(80) :: String, Strip  
 integer :: ipos,i,length=80  
 ipos=0  
 print *, 'type in a string'  
 read '(a)',string 
 do i=1,length  
 if(string(i:i) /= ' ') then  
ipos=ipos+1  
 strip(ipos:ipos)=string(i:i)  
 endif  
 end do  
 print*,string  
 print*,strip  
 end program ch1403 
 14.5  Character Functions 
 There are special functions available for use with character variables: Index will 
give the starting position of a string within another string. If, for example, we were 
looking for all occurrences of the string 'Geology' in a ﬁ le, we could construct some-
thing like:
 program ch1404  
 implicit none  
 character (80) :: Line  
 integer :: I 
 do  
read '(A)' , Line  
 I=Index(Line,'Geology')  
 if (I /= 0) then 
 print *, 'String Geology found at position',I  
 print *, 'in line', Line  
 exit  
 endif  
 enddo  
 end program ch1404 
 There are two things to note about this program. Firstly the index function will 
only report the ﬁ rst occurrence of the string in the line; any later occurrences in any 

223
14.6 Collating Sequence
particular line will go unnoticed, unless you account for them in some way. Secondly, 
if the string does not occur, the result of the index function is zero, and given the 
inﬁ nite loop (do end do) the program will crash at run time with an end of ﬁ le error 
message. This isn’t good programming practice. 
 len provides the length of a character string. This function is not immediately 
useful, since you really ought to know how many characters there are in the string. 
 However, as later examples will show, there are some cases where it can be use-
ful. Remember that trailing blanks do count as part of the character string, and 
contribute to the length. 
 The following example illustrates the use of both len and len_trim:
 program ch1405  
 implicit none  
 character (len=20) :: name  
 integer : : name_length 
 print *, 'type in your name'  
 read '(a)' , name  
 !  
 ! show len ﬁ rst  
 ! 
 Name_length=len(name)  
 print *,' name length is ',name_length  
 print *,' ',name(1:name length),'<-end is here'  
 name_length=len_trim(name)  
 print *,' name length is ',name_length  
 print *,' ',name(1:name length),'<-end is here'  
 end program ch1405  
 14.6  Collating Sequence 
 The next group of functions need to be considered together. They revolve around the 
concept of a collating sequence. In other words, each character used in Fortran is 
ordered as a list and given a corresponding weight. No two weights are equal. 
Although Fortran has only 63 deﬁ ned characters, the machine you use will gener-
ally have more; 95 printing characters is a typical minimum number. On this type of 
machine the weights would vary from 0 to 94. There is a deﬁ ned collating sequence, 
the ASCII sequence, which is likely to be the default. The parts of the collating 
sequence which are of most interest are fairly standard throughout all collating 
sequences. 
 In general, we are interested in the numerals (0–9), the alphabetics (A–Z, 
a–z) and a few odds and ends like the arithmetic operators (+ − / *), some punc-
tuation (. and ,) and perhaps the prime (¢). As you might expect, 0–9 carry 
successively higher weights (though not the weights 0–9), as do A to Z and a to z. 

224
14 Characters
The other odds and ends are a little more problematic, but we can ﬁ nd out the 
weights through the function ichar. This function takes a single character as 
argument and returns an integer value. The ASCII weights for the alphanumerics 
are as follows:  
 0–9 
 48–57 
 A–Z 
 65–90 
 One of the exercises is to determine the weights for other characters. The reverse 
of this procedure is to determine the character from its weighting, which can be 
achieved through the function char. char takes an integer argument and returns a 
single character. Using the ASCII collating sequence, the alphabet would be gener-
ated from
 do I =   65, 90  
print*,char(I)  
 enddo  
 This idea of a weighting can then be used in four other functions: 
 Function 
 Action 
 lle 
 lexically less than or equal to 
 lge 
 lexically greater than or equal to 
 lgt 
 lexically greater than 
 llt 
 Lexically less than 
 In the sequence we have seen before, A is lexically less than B, i.e., its weight is 
less. Clearly, we can use ichar and get the same result. For example,
 if (lgt('a', 'b')) then  
 is equivalent to
 if(ichar('a')  >  ichar('b')) then  
but these functions can take character string arguments of any length. They are not 
restricted to single characters. 
 These functions provide very powerful tools for the manipulation of characters, 
and open up wide areas of nonnumerical computing through Fortran. Text format-
ting and word processing applications may now be tackled (conveniently ignoring 
the fact that lower-case characters may not be available). 
 There are many problems that require the use of character variables. These range 
from the ability to provide simple titles on reports, or graphical output, to the provi-
sion of a natural language interface to one of your programs, i.e., the provision of an 
English-like command language. Software Tools by Kernighan and Plauger con-
tains many interesting uses of characters in Fortran. 

225
14.7 Finding Out About the Character Set Available
 14.7  Finding Out About the Character Set Available 
 The following program prints out the characters between 32 and 127.
 program ch1406  
 implicit none  
 integer :: I 
 do I=32,62  
 print*,i,char(i),i+32,char(i+32),i+64,char(I+64)  
 end do  
 I = 63  
 print *,i,char(i),i+32,char(i+32),i+64, 'del'  
 I = 64  
 print *,i,char(i),i+32,char(I+32)  
 end program ch1406  
 This is the output from the Intel compiler under Windows. 
 32 
 64 @ 
 96 ¢ 
 33 ! 
 65 A 
 97 a 
 34 “ 
 66 B 
 98 b 
 35 # 
 67C 
 99 c 
 36 $ 
 68 D 
 100 d 
 37% 
 69 E 
 101 e 
 38 & 
 70F 
 102 f 
 39 ' 
 71 G 
 103 g 
 40 ( 
 72 H 
 104 h 
 41 ) 
 73 I 
 105 I 
 42 * 
 74 J 
 106 j 
 43 + 
 75 K 
 107 k 
 44 , 
 76 L 
 108 l 
 45 - 
 77 M 
 109 m 
 46 . 
 78 N 
 110 n 
 47 / 
 79 O 
 111 o 
 48 0 
 80 P 
 112 p 
 49 1 
 81 Q 
 113 q 
 50 2 
 82 R 
 114 r 
 51 3 
 83 S 
 115 s 
 52 4 
 84 T 
 116 t 
 53 5 
 85 U 
 117 u 
 54 6 
 86 V 
 118 v 
 55 7 
 87 W 
 119 w 
 56 8 
 88 X 
 120 x 
 57 9 
 89 Y 
 121 y 
 58 : 
 90 Z 
 122 z 
 59 ; 
 91 [ 
 123 { 
 60 < 
 92 \ 
 124 | 
(continued)

226
14 Characters
 61 = 
 93 ] 
 125 } 
 62 > 
 94 ^ 
 126 ~ 
 63 ? 
 95 _ 
 127 del 
 64 @ 
 96 ` 
 Try this program out on the system you use. Do the character sets match? 
 14.8  Scan Function Example 
 The following program uses the scan function to locate the position of all of the 
blanks in a string. The syntax of the simple form we use in the program is given 
below.
 scan(string,set) – Scans a string for any one of the characters in a set of 
• 
characters. 
 program ch1407  
 implicit none  
 character (1024) :: string01  
 character (1) :: set=' '  
 integer : : I  
 integer : : l  
 integer :: start,end 
 string01 = &  
 "The important issue about a language, is not so"  
 string01 = trim(string01) // " " // &  
 "much what features the language possesses, but"  
 string01 = trim(string01) // " " // &  
 "the features it does possess, are sufﬁ cient, to"  
 string01 = trim(string01) // " " // &  
 "support the desired programming styles, in the"  
 string01 = trim(string01) // " " // &  
 "desired application areas. "  
 l = len(trim(string01))  
 print *,' Length of string is = ',l  
 print *,' String is'  
 print *,trim(string01)  
 start=1  
 end=l  
 print *,' Blanks at positions '  
 do  
 i=scan(string01(start:end),set)  
 start=start+I  
(continued)

227
14.9 Summary
 if (I==0) exit  
 write(*,10,advance='no'),start-1  
 10 format(i5)  
 end do  
 end program ch1407  
 Note the use of the trim function when using the concatenation operator to initia-
lise the string to the text we want. 
 The output from one compiler is given below.
 Length of string is  =  217  
 String is  
 The important issue about a language, is not so much 
what features the language possesses, but the features 
it does possess, are sufﬁ cient, to support the desired 
programming styles, in the desired application areas.  
 The text in this program is used in two problems at the end of this chapter. 
 14.9  Summary 
 Characters represent a different data type to any other in Fortran, and as a conse-
quence there is a restricted range of operations which may be carried out on them. 
 A character variable has a length which must be assigned in a character declara-
tion statement. 
 Character strings are delimited by apostrophes (') or quotation marks ("). Within 
a character string, the blank is a signiﬁ cant character. 
 Character strings may be joined together (concatenated) with the // operator. 
 Substrings occurring within character strings may be also be manipulated. There 
are a number of functions especially for use with characters:
 achar – return the character in the ASCII character set 
• 
 adjustl – adjust left, remove leading blanks, add trailing blanks 
• 
 adjustr – adjust right – remove trailing blanks, insert leading blanks 
• 
 char – return the character in the processor collating sequence 
• 
 iachar – as above but in the ASCII character set 
• 
 index – locate one string in another 
• 
 len – character length including trailing blanks 
• 
 len_trim – character length without the trailing blanks 
• 
 lle – lexically less than or equal to 
• 
 lge – lexically greater than or equal to 
• 

228
14 Characters
 lgt – lexically greater than 
• 
 llt – lexically less than 
• 
 repeat – concatenate several copies of a string 
• 
 scan – scans a string for anyone of the characters in the set 
• 
 trim – remove the trailing blanks 
• 
 verify – verify that a set of characters contains all the characters in a string 
• 
 A detailed explanation is given in Appendix E. 
 14.10  Problems 
 1.  Suggest some circumstances where PRIME = '''' might be useful. What other 
alternative is there and why do you think we use that instead? 
 2.  Write a program to write out the weights for the Fortran character set. Modify 
this program to print out the weights of the complete implementation deﬁ ned 
character set for your version of Fortran. Is it ASCII? If not, how does it differ? 
 3.  Write a program that produces the following output.
 !  
 "#  
 $%&  
 '()*  
 +,-./  
 012345  
 6789:;<  
 =>?@ABCD  
 EFGHIJKLM  
 NOPQRSTUVW  
 XYZ[\]^_`ab  
 cdefghijklmn  
 opqrstuvwxyz{  
 |}~  
 We assume the ASCII character set in this example. 
 4.  Modify the above program to produce the following output. 
 Again we assume the ASCII character set. 

229
14.10 Problems
   5.  Modify program ch1407 to break the text into phrases, using the comma and 
full stop as breaking characters. The output expected is given below.
 The important issue about a language  
 is not so much what features the language possesses  
 but the features it does possess  
 are sufﬁ cient  
 to support the desired programming styles  
 in the desired application areas 
   6.  Modify the above to break the text into words and count the frequency of occur-
rence of words by length. The output should be similar to that given below.
  1  a
1 
 2  is so it to in
5  
 3  The not the but the are the the
8  
 4  much what does
3  
 5  issue about areas
3  
 6  styles
1 
 7  possess support desired desired
4  
 8  language features language features
4  
 9  important possesses
2  
 10  sufﬁ cient
1 
 11  programming application
2  
   7.  Use the INDEX function in order to ﬁ nd the location of all the strings ‘is’ in the 
following data: 
 If a programmer is found to be indispensable, the best thing to do is to get rid of 
him as quickly as possible. 
   8.  Find the ‘middle’ character in the following strings. Do you include blanks as 
characters? What about punctuation? 
 Practice is the best of all instructors. Experience is a dear teacher, but fools will 
learn at no other. 
   9.  In English, the order of occurrence of the letters, from most frequent to least is 
E, T, A, O, N, R, I, S, H, D, L, F, C, M, U, G, Y, P, W, B, V, K, X, J, Q, Z 
 Use this information to examine the two ﬁ les given in Appendix D (one is a 
translation of the other) to see if this is true for these two extracts of text. The 
second text is in medieval Latin (c. 1320). Note that a fair amount of compres-
sion has been achieved by expressing the passage in Latin rather than modern 
English. Does this provide a possible model for information compression? 
 10.  A very common cypher is the substitution cypher, where, for example, every 
letter A is replaced by (say) an M, every B is replaced by (say) a Y, and so on. 
These enciphered messages can be broken by reference to the frequency of 
occurrence of the letters (given in the previous question). 
 Since we know that (in English) E is the most commonly occurring letter, we 
can assume that the most commonly occurring letter in the enciphered message 
 represents an E; we then repeat the process for the next most common and so 

230
14 Characters
on. Of course, these correspondences may not be exact, since the message may 
not be long enough to develop the frequencies fully. 
 However, it may provide sufﬁ cient information to break the cypher. 
 The ﬁ le given in Appendix E contains an encoded message. Break it. Clue – 
Pg + Fybdujuvef jo Tdjfodf, Jorge Luis Borges. 
 11.  Write a program that counts the total number of vowels in a sentence or text. 
Output the frequency of occurrence of each vowel. 

231
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_15, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are:
 To introduce the last predeﬁ ned numeric data type in Fortran. 
• 
 To illustrate with examples how to use this type. 
• 
 15.1  Introduction 
 This variable type reﬂ ects an extension of the real data type available in Fortran – 
the complex data type, where we can store and manipulate complex variables. 
Problems that require this data type are restricted to certain branches of mathemat-
ics, physics and engineering. Complex numbers are deﬁ ned as having a real and 
imaginary part, i.e.,
 
 =
+
a
x
iy   
where I is the square root of−1. 
 They are not supported in many programming languages as a base type which 
makes Fortran the language of ﬁ rst choice for many people. 
 To use this variable type we have to write the number as two parts, the real and 
imaginary elements of the number, for example,
 complex :: U  
 U =  cmplx(1.0,2.0) 
 Chapter 15 
 Complex  
 Make it as simple as possible, but no simpler. 
 Albert Einstein 

232
15 Complex
represents the complex number 1 + i2. Note that the complex number is enclosed in 
brackets. We can do arithmetic on variables like this, and most of the intrinsic func-
tions such as  log, sin, cos , etc., accept a complex data type as argument. 
 All the usual rules about mixing different variable types, like reals and integers, 
also apply to complex. Complex numbers are read in and written out in a similar 
way to real numbers, but with the provision that, for each single complex value, two 
format descriptors must be given. You may use either E or F formats (or indeed, mix 
them), as long as there are enough of them. Although you use brackets around the 
pairs of numbers in a program, these must not appear in any input, nor will they 
appear on the output. 
 Fortran has a number of functions which help to clarify the intent of mixed mode 
expressions. The functions real,  cmplx and  int can be used to ‘force’ any variable 
to real, complex or integer type. 
 There are a number of intrinsic functions to enable complex calculations to be 
performed. The program segment below uses some of them:
 complex:: z, z1,z2,z3,zbar  
 real :: x,y,x1,y1,  x 2,y2,x3,y3,zmod 
 z1 =  cmplx (1.0, 2.0) 
! 1  +  I2 
 z2 =  cmplx (  x 2, y2) 
!   x 2 +  I y2 
 z3 =  cmplx (x3, y3) 
! x3  +  I y3 
 Z =  Z1*Z2 / Z3  
 x =  real(z) 
! real part of z  
 y =  aimag (z) 
! imaginary part of z  
 zmod =  abs(z) 
! modulus of z  
 ZBAR =  CONJG(Z) 
! complex conjugate of Z  
 15.2  Example 1 
 The second order differential equation:
 
 
+
+
=
2
2
2
( )
d y
dy
y
x t
dt
dt
  
could describe the behaviour of an electrical system, where x(t) is the input voltage 
and y(t) is the output voltage and dy/dt is the current. The complex ratio
 
 
=
−
+
+
2
( )
1/ (
2
1)
( )
y w
w
j w
x w
  
is called the frequency response of the system because it describes the relationship 
between input and output for sinusoidal excitation at a frequency of w and where j 

233
15.2 Example 1
is  −1  . The following program segment reads in a value of w and evaluates the 
frequency response for this value of w together with its polar form (magnitude and 
phase):
 program ch1501  
 implicit none i  
 ! 
 ! program to calculate frequency response of a system  
 ! for a given Omega  
 ! and its polar form (magnitude and phase).  
 ! 
 real :: Omega ,real_part , Imag_part , Magnitude, Phase  
 complex:: Frequency_response  
 ! 
 ! Input frequency Omega  
 ! 
 print *, 'Input frequency'  
 read *,Omega  
 ! 
 Frequency_response = 1.0 / &  
cmplx ( - Omega * Omega + 1.0 , 2.0 * Omega) 
real_part = real(Frequency_response) 
Imag_part = aimag(Frequency_response)  
 ! 
 ! Calculate polar coordinates (magnitude and phase)  
 ! 
 magnitude = abs(frequency_response)  
 phase = atan2 (imag_part, real_part)  
 ! 
 print *, ' at frequency ',omega  
 print *, 'response = ', real_part,' + I ',imag_part  
 print *, 'in polar form'  
 print *, ' magnitude = ', magnitude  
 print *, ' phase = ', phase  
 end program ch1501  

234
15 Complex
 15.3  Example 2 
 Here is a complete example of using some of the intrinsics with complex numbers.
 program ch1502  
 implicit none  
 real:: x,y,x1,y1,  x 2,y2,x3,y3,zmod  
 complex:: z,z1,z2,z3,zbar 
 print*,'input x1,y1,  x 2,y2,x3, y3'  
 read*,x1,y1,  x 2,y2,x3,y3  
 z1 =  cmplx(1.0,2.0)  
 z2 =  cmplx(  x 2,y2) 
 print*, 'z2  =  ',z2 
 z3 =  cmplx(x3−x1, (y3 +  y1)**2)  
 print*, 'z3  =  ',z3 
 z =  z1*z2/z3  
 x =  real (z)  
 y =  aimag(z)  
 zmod =  abs(z)  
 zbar =  conjg(z)  
 print*,'z =  ',z 
 print*,'modulus of z =  ',zmod   
 print*,'complex conjugate of z  =  ',zbar  
 end program ch1502 
 15.4  Complex and Kind Type 
 The standard requires that there be a minimum of two kind types for real numbers 
and this is also true of the complex data type. Chap.  5 must be consulted for a full 
coverage of real kind types. We would therefore use something like the following to 
select a complex kind type other than the default:
 integer , parameter :: &  
Long_complex =  selected_real_kind(15,307)  
 complex (Long_complex) :: Z  
 Chapter  21 includes a good example of how to use modules to deﬁ ne and use 
precision throughout a program and subprogram units. 
 15.5  Summary 
 Complex is used to store and manipulate complex numbers: those with a real and an 
imaginary part. 

235
15.6 Problem
 There are standard functions which allow conversion between the numerical data 
types –  cmplx, real and  int . 
 15.6  Problem 
 1.  The program used in Chap.  12 which calculated the roots of a quadratic had to 
abandon the calculation if the roots were complex. You should now be able to 
remedy this, remembering that it is necessary to declare any complex variables. 
Instead of raising the expression to the power 0.5 in order to take its square root, 
use the function  sqrt . The formulae for the complex roots are 
 
 
−
−
−
±
2
(
4
)
2
2
b
b
ac
i
a
a
  
 
 If you manage this to your satisfaction, try your skills on the roots of a cubic (see 
the problems in Chap.  12 ). 

237
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_16, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are:
 To examine the last predeﬁ ned type available in Fortran: logical. 
• 
 To introduce the concepts necessary to use logical expressions effectively, 
• 
namely:
 Logical variables. 
 –
 Logical operators. 
 –
 The hierarchy of operations. 
 –
 Truth tables. 
 –
 16.1  Introduction 
 Often we have situations where we need ON/OFF, TRUE/FALSE or YES/NO 
switches, and in such circumstances we can use  logical type variables, e.g.,
 logical :: ﬂ ag 
 Logicals may take only two possible values, as shown in the following:
 Flag=.true.  
or
 ﬂ ag=.false.  
 Chapter 16 
 Logical  
 A messenger yes/no semaphore 
 her black/white keys in/out whirl of morse 
 hoopooe signals salvation deviously. 
 Nathaniel Tarn, The Laurel Tree 

238
16 Logical
 Note the full stops, which are essential. With a little thought you can see why 
they are needed. You will already have met some of the ideas associated with logical 
variables from if statements:
 if (a == b) then  
. 
 else 
 . 
 endif 
 The logical expression  (a == b) returns a value true or false, which then deter-
mines the route to be followed; if the quantity is true, then we execute the next state-
ment, else we take the other route. 
 Similarly, the following example is also legitimate:
 logical :: answer  
answer=.true.  
 … 
 if (answer) then 
 … 
 else 
 … 
 endif 
 Again the expression if  (answer) is evaluated; here the variable  answer has 
been set to  .true ., and therefore the statements following the then are executed. 
Clearly, conventional arithmetic is inappropriate with logicals. What does two times 
true mean? (very true?). There are a number of special operators for logicals:
 .not. which negates a logical value (i.e., changes true to false or vice versa). 
 .and. logical intersection. 
 .or.  logical union. 
 To illustrate the use of these operators, consider the following program extract:   
 To gauge the effect of these operators on logicals, we can consult a truth table: 
 x1 
 x2 
 .not.x1 
 x1.and.x2 
 x1.or.x2 
 true 
 true 
 false 
 true 
 true 
 true 
 false 
 false 
 false 
 true 
 false 
 true 
 true 
 false 
 true 
 false 
 false 
 true 
 false 
 false 

239
16.1 Introduction
 As with arithmetic operators, there is an order of precedence associated with the 
logical operators:
 .and. is carried out before 
 .or. and  .not. 
 In dealing with logicals, the operations are carried out within a given level, from 
left to right. Any expressions in brackets would be dealt with ﬁ rst. The logical oper-
ators are a lower order of precedence than the arithmetic operators, i.e., they are 
carried out later. A more complete operator hierarchy is therefore:
 Expressions within brackets. 
• 
 Exponentiation. 
• 
 Multiplication/division. 
• 
 Addition/subtraction. 
• 
 Relational logical ( = =, >, <, >=, <= /=). 
• 
 .and. 
• 
 .or. 
• 
and  .not. 
 Although you can build up complicated expressions with mixtures of operators, 
these are often difﬁ cult to comprehend, and it is generally more straightforward to 
break ‘big’ expressions down into smaller ones whose purpose is more readily 
appreciated. 
 Historically, logicals have not been in evidence extensively in Fortran programs, 
although clearly there are occasions on which they are of considerable use. Their 
use often aids signiﬁ cantly in making programs more modular and comprehensible. 
They can be used to make a complex section of code involving several choices much 
more transparent by the use of one logical function, with an appropriate name. 
Logicals may be used to control output; e.g.,
 logical :: debug  
 … 
 debug=.true.  
 … 
 if(debug)then 
 … 
 print *,'lots of printout'  
 … 
 endif 
ensures that, while debugging a program you have more output. then, when the 
program is correct, run with  debug=.false . 
 Note that Fortran does try to protect you while you use logical variables. You 
cannot do the following:
 logical :: up, down  
up=down+.false.  

240
16 Logical
 or 
 logical :: a2 
 real dimension(10) :: omega  
 . 
a2=omega(3)  
 The compiler will note that this is an error, and will not permit you to run the 
program. This is an example of strong typing, since only a limited number of prede-
termined operations are permitted. The real, integer and complex variable types are 
much more weakly typed (which helps lead to the confusion inherent in mixing 
variable types in arithmetic assignments). 
 16.2  I/O 
 Since logicals may take only the values  .true. and  .false. , the possibilities in 
reading and writing logical values are clearly limited. The L edit descriptor or for-
mat allows logicals to be input and output. On input, if the ﬁ rst nonblank characters 
are either T or .T, the logical value  .true. is stored in the corresponding list item; 
if the ﬁ rst nonblank characters are F or .F, then  .false. is stored. (Note therefore 
that reading, say,  ted and  fahr in an L4 format would be acceptable.) if the ﬁ rst 
nonblank character is not F, T, .F or .T, then an error message will be generated. On 
output, the value T or F is written out, right justiﬁ ed, with blanks (if appropriate). 
Thus,
 logical :: ﬂ ag 
ﬂ ag=.true.  
 print 100, ﬂ ag, .not.ﬂ ag 
 100 format(2L3) 
would produce
 T   F 
at the terminal. 
 Assigning a logical variable to anything other than a  .true. or  .false. 
value in your program will result in errors. The ‘shorthand’ forms of .T, .F, F and T 
are not acceptable in the program. 

241
16.4 Problems
 16.3  Summary 
 Another type of data – logical – is also recognised. A  logical variable may take 
one of two values – true or false.
 There are special operators for manipulating logicals:
• 
 
 – .not. 
 .and.
 
–
 
 .or
 
–
. 
 Logical operators have a lower order of precedence than any others. 
• 
 16.4  Problems 
 1.  Why are the full stops needed in a statement like A =  .true. ? 
 2.  Generate a truth table like the one given in this chapter. 
    3.  Write a program which will read in numerical data from the terminal, but will 
ﬂ ag any data which is negative, and will also turn these negative values into posi-
tive ones. 

243
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_17, © Springer-Verlag London Limited 2012
 Aims 
 The aim of this chapter is to introduce the concepts and ideas involved in using the 
facilities offered in Fortran 90 for the construction and use of user deﬁ ned types:
 The way in which we deﬁ ne our own types. 
• 
 The way in which we declare variables to be of a user deﬁ ned type. 
• 
 The way in which we manipulate variables of our own types. 
• 
 The way in which we can nest types within types. 
• 
 The examples are simple and are designed to highlight the syntax. More complex 
and realistic examples of the use of user deﬁ ned data types are to be found in later 
chapters. 
 17.1  Introduction 
 In the coverage so far we have used the intrinsic types provided by Fortran. The only 
data structuring technique available has been to construct arrays of these intrinsic 
types. Whilst this enables us to solve a reasonable variety of problems, it is 
 Chapter 17 
 Introduction to Derived Types 
 Russell’s theory of types leads to certain complexities in the 
foundations of mathematics… Its interesting features for our 
purposes are that types are used to prevent certain erroneous 
expressions from being used in logical and mathematical 
formulae; and that a check against violation of type constraints 
can be made purely by scanning the text, without any 
knowledge of the value which a particular symbol might 
happen to have. 
 C.A.R. Hoare, Structured Programming 

244
17 Introduction to Derived Types
 inadequate for many purposes. In this chapter we look at the facilities offered by 
Fortran for the construction of our own types and how we manipulate data of these 
new, user deﬁ ned types. 
 With the ability to deﬁ ne our own types we can now construct aggregate data 
types that have components of a variety of base types. These are given a variety of 
names including
 Record in the Pascal family of languages and in many older books on computing 
• 
and data structuring; 
 Structs in C; 
• 
 Classes in C++, Java, C# and Eiffel; 
• 
 Cartesian product is often used in mathematics and this is the terminology 
• 
adopted by Hoare; 
 We will the term user deﬁ ned type and derived types interchangeably. 
 There are two stages in the process of creating and using our own data types: we 
must ﬁ rst deﬁ ne the type, and then create variables of this type. 
 17.2  Example 1: Dates 
 program ch1701  
 implicit none  
 type date 
 integer :: day=1  
 integer :: month=1  
 integer :: year=2000  
 end type date  
 type (date) :: d 
 print *,d%day, d%month, d%year  
 print *, 'type in the date, day, month, year'  
 read *,d%day, d%month, d%year  
 print *,d%day, d%month, d%year  
 end program ch1701  
 This complete program illustrates both the deﬁ nition and use of the type. It also 
shows how you can deﬁ ne initial values within the type deﬁ nition. 
 17.3  Type Deﬁ nition 
 The type  date is deﬁ ned to have three component parts, comprising a  day, a 
 month and a  year, all of integer type. The syntax of a type construction 
comprises:

245
17.4 Variable Deﬁ nition
 type Typename
 data type :: Component_name 
 etc. 
 end type Typename 
 Reference can then be made to this new type by the use of a single word,  date , 
and we have a very powerful example of the use of abstraction. 
 17.4  Variable Deﬁ nition 
 This is done by
 type (Typename) :: Variablename  
and we then deﬁ ne a variable D to be of this new type. The next thing we do is 
have a  read * statement that prompts the user to type in three integer values, and 
the data are then echoed straight back to the user. We use the notation 
 Variablename%Component_Name to refer to each component of the new 
data type. 
 17.4.1  Example 1 Variant Using Modules 
 The following is a variant on the above and achieves the same result with a small 
amount of additional syntax.
 module date_module  
type date  
integer :: day=1  
 integer :: month=1  
 integer :: year=2000  
 end type date  
 end module date_module  
 program ch1702  
 use date_module  
 implicit none  
 type (date) :: d 
 print *,d%day, d%month, d%year  
 print *, 'type in the date, day, month, year'  
 read *,d%day, d%month, d%year  
 print *,d%day, d%month, d%year  
 end program ch1702 
 The key here is that we have embedded the type declaration inside a module, and 
then used the module in the main program. 

246
17 Introduction to Derived Types
 If you are only using the type within one program unit then the ﬁ rst form is sat-
isfactory, but if you are going to use the type in several program units the second is 
the required form. 
 We will use the second form in the examples that follow. 
 17.5  Example 2: Address Lists 
 module address_module  
type address  
character (len=40) :: name  
 character (len=60) :: street  
 character (len=60) :: district  
 character (len=60) :: city  
 character (len=8) :: post_code  
 end type address  
 end module address_module  
 program ch1703  
 use address_module  
 implicit none  
 integer :: n_of_address  
 type (address) , dimension(:), allocatable:: 
addr  
 integer :: I 
 print *, 'input number of addresses'  
 read *,n_of_address  
 allocate(addr(1:n_of_address))  
 open(unit=1,ﬁ le="address.txt")  
 do i=1,n_of_address 
 read(unit=1,fmt='(a40)') addr (i)%name  
 read(unit=1,fmt='(a60)') addr (i)%street  
 read(unit=1,fmt='(a60)') addr (i)%district  
 read(unit=1,fmt='(a60)') addr (i)%city  
 read(unit=1,fmt='(a8)') addr(i)%post_code  
 end do  
 do i=1,n_ of_address 

247
17.6 Example 3: Nested User Deﬁ ned Types
 print *,addr(i)% name  
 print *,addr(i)% street  
 print *,addr(i)% district  
 print *,addr(i)% city  
 print *,addr(i)% post_code  
 end do  
 end program ch1703 
 In this example we deﬁ ne a type Address which has components that one would 
expect for a person’s address. We then deﬁ ne an array Addr of this type. Thus we 
are now creating arrays of our own user deﬁ ned types. We index into the array in the 
way we would expect from our experience with integer, real and character arrays. 
The complete example is rather trivial in a sense in that the program merely reads 
from one ﬁ le and prints the ﬁ le out to the screen. However, it highlights many of the 
important ideas of the deﬁ nition and use of user deﬁ ned types. 
 17.6  Example 3: Nested User Deﬁ ned Types 
 The following example builds on the two data types already introduced. Here we 
construct nested user deﬁ ned data types based on them and construct a new data 
type containing them both plus additional information. 

248
17 Introduction to Derived Types

249
17.8 Bibliography
 Here we have a date of birth data type ( Date_Of_Birth ) based on the  Date 
data type from the ﬁ rst example, plus a slightly modiﬁ ed address data type, incor-
porated into a new data type comprising personal details. Note the way in which we 
reference the component parts of this new, aggregate data type. 
 17.7  Problem 
 1.  Modify the last example to include a more elegant printed name. The current 
example will pad with blanks the ﬁ rst name, other names and surname and span 
80 characters on one line, which looks rather ugly. 
 Add a new variable name which will comprise all three subcomponents and write 
out this new variable, instead of the three subcomponents. 
 17.8  Bibliography 
 Dahl , O.J., Dijkstra, E.W., Hoare, C.A.R.: Structured Programming. Academic 
Press, London (1972)
 This is one of the earliest and best introductions to data structures and structured 
programming. The whole book hangs together very well, and the section on data 
structures is a must for serious programmers. 

250
17 Introduction to Derived Types
 Vowels, R.A.: Algorithms and Data Structures in F and Fortran. Unicomp, 
Tucson (1989)
 One of the few books looking at algorithms and data structures using Fortran. 
 Wirth, N.: Algorithms + Data Structures = Programs. Prentice-Hall, Englewood 
Cliffs (1976) 
 Wirth, N.: Algorithms + Data Structures. Prentice-Hall, Englewood Cliffs 
(1986)
 The ﬁ rst is in Pascal, and the second in Modula 2. 
 Wood, D.: Paradigms and Programming in Pascal. Computer Science Press, 
Rockville (1984)
 contains a number of examples of the use of recursion in problem solving. Also 
provides a number of useful case studies in problem solving. 

251
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_18, © Springer-Verlag London Limited 2012
 Aim 
 The primary aim of the chapter is to introduce some of the key concepts of pointers 
in Fortran. 
 18.1  Introduction 
 All of the data types introduced so far, with the exception of the allocatable array, 
have been static. Even with the allocatable array a size has to be set at some stage 
during program execution. The facilities provided in Fortran by the concept of a 
pointer combined with those offered by a user deﬁ ned type enable us to address a 
completely new problem area, previously extremely difﬁ cult to solve in Fortran. 
There are many problems where one genuinely does not know what requirements 
there are on the size of a data structure. Linked lists allow sparse matrix problems 
to be solved with minimal storage requirements, two-dimensional spatial problems 
can be addressed with quad-trees and three-dimensional spatial problems can be 
addressed with oct-trees. Many problems also have an irregular nature, and pointer 
arrays address this problem. 
 First we need to cover some of the technical aspects of pointers. A pointer is a 
variable that has the pointer attribute. A pointer is associated with a target by alloca-
tion or pointer assignment. A pointer becomes associated as follows:
 The pointer is allocated as the result of the successful execution of an allocate 
• 
statement referencing the pointer
 Chapter 18 
 An Introduction to Pointers  
 Not to put too ﬁ ne a point on it. 
 Charles Dickens, Bleak House. 

252
18 An Introduction to Pointers
or 
 The pointer is pointer-assigned to a target that is associated or is speciﬁ ed with 
• 
the target attribute and, if allocatable, is currently allocated. 
 A pointer shall neither be referenced nor deﬁ ned until it is associated. A pointer 
is disassociated following execution of a deallocate or nullify statement, following 
pointer association with a disassociated pointer, or initially through pointer 
initialisation. 
 A pointer may have a pointer association status of associated, disassociated, or 
undeﬁ ned. Its association status may change during execution of a program. Unless 
a pointer is initialised (explicitly or by default), it has an initial association status of 
undeﬁ ned. A pointer may be initialised to have an association status of 
disassociated. 
 Let us look at some examples to clarify these points. 
 18.2  Some Basic Pointer Concepts 
 With the introduction of pointers as a data type into Fortran we also have the intro-
duction of a new assignment statement – the pointer assignment statement. Consider 
the following example:
 program ch1801  
 implicit none  
 integer , pointer :: a=>null(),b=>null ()  
 integer , target :: c  
 integer :: d 
 c = 1 
 a => c  
 c = 2 
 b => c  
 d = a + b  
 print *,a,b,c,d  
 end program ch1801  
 The following
 integer , pointer :: a=>null(),b=>null()  
is a declaration statement that deﬁ nes  a and  b to be variables, with the pointer attri-
bute. This means we can use  a and  b to refer or point to integer values. We also use 
the  null intrinsic to set the status of the pointers  a and  b to disassociated. Using 
the  null intrinsic means that we can test the status of a pointer variable and avoid 
making a number of common pointer programming errors. Note that in this case no 
space is set aside for the pointer variables  a and  b , i.e.  a  and  b  should not be refer-
enced in this state. 

253
18.3 The associated Intrinsic Function
 The second declaration deﬁ nes  c to be an integer, with the target attribute, i.e., 
we can use pointers to refer or point to the value of the variable  c . 
 The last declaration deﬁ nes  d to be an ordinary integer variable. 
 In the case of the last two declarations space is set aside to hold two integers. 
 Let us now look at the various executable statements in the program, one at a 
time: 
 c =  1 
 This is an example of the normal assignment statement with which we are 
already familiar. We use the variable name  c in our program and whenever 
we use that name we get the value of the variable  c 
 a = >  c 
 This is an example of a pointer assignment statement. This means that both  a 
and  c now refer to the same value, in this case 1.  a becomes associated 
with the target c .  a can now be referenced 
 c = 2 
 Conventional assignment statement, and  c now has the value 2 
 b = > c  
 Second example of pointer assignment.  b now points to the value that  c has, in 
this case 2.  b becomes associated with the target  c .  b can now be 
referenced 
 d = a + b   Simple arithmetic assignment statement. The value that a points to is added to 
the value that  b points to and the result is assigned to  d 
 The last statement prints out the values of  a, b, c and  d . 
 The output is
 2 2 2 4 
 18.3  The associated Intrinsic Function 
 The  associated intrinsic returns the association status of a pointer variable. 
Consider the following example which is a simple variant on the ﬁ rst.
 program ch1802  
 integer , pointer :: a=>null(),b=>null()  
 integer , target :: c  
 integer :: d 
 print *,associated(a)  
 print *,associated(b)  
 c = 1 
 a => c  
 c = 2 
 b => c  
 d = a + b  
 print *,a,b,c,d  
 print *,associated(a)  
 print *,associated(b)  
 end program ch1802  

254
18 An Introduction to Pointers
 The output from running this program is shown below
 F 
 F 
 2 2 2 4  
 T 
 T 
and as you can see we therefore have a mechanism to test pointers to see if they are 
in a valid state before use. 
 18.4  Referencing a and b Before Allocation or Pointer 
Assignment 
 Consider the following example:
 program ch1803  
 integer , pointer :: a=>null(),b=>null()  
 integer , target :: c  
 integer :: d 
 print *,a  
 print *,b  
 c = 1 
 a => c  
 c = 2 
 b => c  
 d = a + b  
 print *,a,b,c,d  
 end program ch1803  
 Here we are actually referencing the pointers  a and  b , even though their status is 
disassociated. Most compilers generate a run time error with this example with the 
default compiler options, and the error message tends to be a little cryptic. It is rec-
ommended that you look at the diagnostic compilation switches for you compiler. 
We include some sample output below from gfortran, Intel and Nag. The error mes-
sages are now much more meaningful. 
 18.4.1  gfortran 
 Switches are
 gfortran -W -Wall -fbounds-check -pedantic-errors  
 -std=f2003 -Wunderﬂ ow -O –fbacktrace  
 -ffpe-trap=zero,overﬂ ow,underﬂ ow -g 

255
18.5 Pointer Allocation and Assignment
 The program runs to completion with no error message. Here is the output.   
 18.4.2  Intel 
 Switches are
 /check:all /traceback  
 Here is the output.   
 18.4.3  Nag 
 Switches are
 -C=all -C=undeﬁ ned -info -g –gline  
 Here is the output.
 Runtime Error: ch1803.f90, line 5: Reference to  
 disassociated POINTER A  
 Program terminated by fatal error  
 ch1803.f90, line 5: Error occurred in CH1803  
 18.5  Pointer Allocation and Assignment 
 Consider the following example:
 program ch1804  
 integer , pointer :: a=>null(),b=>null()  

256
18 An Introduction to Pointers
 integer , target :: c  
 integer :: d 
 allocate(a)  
 a = 1 
 c = 2 
 b => c  
 d = a + b  
 print *,a,b,c,d  
 deallocate(a)  
 end program ch1804  
 In this example we allocate  a and then can do conventional assignment. If we had 
not allocated  a the assignment would be illegal. Try out problem 2 to see what will 
happen with your compiler. 
 Our simple recommendation when using pointers is to nullify them when declar-
ing them and to explicitly allocate them before conventional assignment. 
 18.6  Memory Leak Examples 
 Dynamic memory brings greater versatility but requires greater responsibility. 
Consider the following example:
 program ch1805  
 integer , pointer :: a=>null(),b=>null()  
 integer , target :: c  
 integer :: d 
 allocate(a)  
 allocate(b)  
 a=100 
 b=200 
 print *,a,b  
 c = 1 
 a => c  
 c = 2 
 b => c  
 d = a + b  
 print *,a,b,c,d  
 end program ch1805  
 What has happened to the memory allocated to  a and  b ? 
 Now consider the following example.   

257
18.6 Memory Leak Examples
 Before running the above example we recommend starting up a memory moni-
toring program. 
 Under Microsoft Windows XP Professional holding [CTRL] + [ALT] + [DEL] 
will bring up the Windows Task Manager. Choose the [Performance] tab to get a 
screen which will show CPU usage, PF Usage, CPU Usage History and Page File 
Usage History. You will also get details of Physical and Kernel memory usage. 
 Under Linux type
 top 
in a terminal window. 

258
18 An Introduction to Pointers
 In these examples we also see the recommended form of the allocate statement 
when working with arrays. This enables us to test if the allocation has worked and 
take action accordingly. A positive value indicates an allocation error, zero indicates 
OK. 
 The second program can require a power off on a Windows operating system 
with a compiler that will remain anonymous! 
 18.7  Non-standard Pointer Example 
 Some Fortran compilers provide a non-standard  loc intrinsic. This can be used to 
print out the address of the variable passed as an argument. Here is the program.
 program ch1807  
 integer , pointer :: a=>null(),b=>null()  
 integer , target :: c  
 integer :: d 
 allocate(a)  
 allocate(b)  
 a=100 
 b=200 
 print *,a,b  
 print *,loc(a)  
 print *,loc(b)  
 print *,loc(c)  
 print *,loc(d)  
 c = 1 
 a => c  
 c = 2 
 b => c  
 d = a + b  
 print *,a,b,c,d  
 print *,loc(a)  
 print *,loc(b)  
 print *,loc(c)  
 print *,loc(d)  
 end program ch1807  
 Here is the output from a compiler with  loc support.   

259
18.8 Problems
 This program clearly shows the memory leak. 
 18.8  Problems 
 1.  Compile and run all of the example programs in this chapter with your compiler 
and examine the output. 
 2.  Compile and run example 4 without the  allocate (a) statement. See what 
happens with your compiler. 
 Here is the output from the Nag compiler. The ﬁ rst run is with the default 
options.
 nagfor ch1804p.f90  
 NAG Fortran Compiler: Release 5.2(722)  
 [NAG Fortran Compiler normal termination]  
 a.exe 
 There is no meaningful output. 
 The following adds the -C=all compilation option.
 nagfor ch1804p.f90 -C=all  
 NAG Fortran Compiler: Release 5.2(722)  
 [NAG Fortran Compiler normal termination]  
 a.exe 
 Runtime Error: ch1804p.f90, line 5: Reference to  
 disassociated POINTER A  
 Program terminated by fatal error  
 We now get a meaningful error message. 

261
 Aims 
 The aims of this chapter are:
 To consider some of the reasons for the inclusion of subroutines in a program-
• 
ming language. 
 To introduce with a concrete example some of the concepts and ideas involved 
• 
with the deﬁ nition and use of subroutines.
 Arguments or parameters. 
 –
 The intent attribute for parameters. 
 –
 The call statement. 
 –
 Scope of variables. 
 –
 Local variables and the save attribute. 
 –
 The use of parameters to report on the status of the action carried out in the 
 –
subroutine. 
 Module procedures to provide interfaces. 
• 
 Chapter 19 
 Introduction to Subroutines  
 A man should keep his brain attic stacked with all the furniture 
he is likely to use, and the rest he can put away in the lumber 
room of his library, where he can get at it if he wants. 
 Sir Arthur Conan Doyle, Five Orange Pips 
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_19, © Springer-Verlag London Limited 2012

262
19 Introduction to Subroutines
 19.1  Introduction 
 In the earlier chapter on functions we introduced two types of function
 Intrinsic functions – which are part of the language. 
• 
 User deﬁ ned functions – by which we extend the language. 
• 
 We now introduce subroutines which collectively with functions are given the 
name procedures. 
 Procedures provide a very powerful extension to the language by:
 Providing us with the ability to break problems down into simpler more easily 
• 
solvable subproblems. 
 Allowing us to concentrate on one aspect of a problem at a time. 
• 
 Avoiding duplication of code. 
• 
 Hiding away messy code so that a main program is a sequence of calls to 
• 
procedures. 
  Providing us with the ability to put together collections of procedures that solve 
• 
commonly occurring subproblems, often given the name libraries, and generally 
compiled. 
 Allowing us to call procedures from libraries written, tested and documented by 
• 
experts in a particular ﬁ eld. There is no point in reinventing the wheel! 
 There are a number of concepts required for the successful use of subroutines 
and we met some of them in Chap.  12 when we looked at user deﬁ ned functions. We 
will extend the ideas introduced there of parameters and introduce the additional 
concept of an interface via the use of modules. The ideas are best explained with a 
concrete example. 
 Note that we use the terms parameters and arguments interchangeably. 
 19.2  Example 1 
 This example is one we met earlier that solves a quadratic equation, i.e., solves
 
 
+
+
=
2
0
ax
bx
c
  
 
 The program to do this originally was just one program. In the example below we 
break that problem down into smaller parts and make each part a subroutine. The 
components are:
 Main program or driving routine. 
• 
 Interaction with user to get the coefﬁ cients of the equation. 
• 
 Solution of the quadratic. 
• 

263
19.2 Example 1
 Let us look now at how we do this with the use of subroutines: 

264
19 Introduction to Subroutines
 19.2.1  Deﬁ ning a Subroutine 
 A subroutine is deﬁ ned as
 subroutine subroutine_name (optional list of dummy arguments) 
 implicit none 
 dummy argument type deﬁ nitions with intent 
 … 
 end subroutine subroutine_name 
and from the earlier example we have the subroutine
 subroutine interact(a,b,c,ok)  
 implicit none  
 real , intent(out) :: a  
 real , intent(out) :: b  
 real , intent(out) :: c  

265
19.2 Example 1
 logical , intent(out) :: ok  
 integer :: io_status=0  
 print*,' type in the coefﬁ cients a, b and c'  
 read(unit=*,fmt=*,iostat=io_status)a,b,c  
 if (io_status == 0) then 
 ok=.true.  
 else 
 ok=.false.  
 endif 
 end subroutine interact 
 19.2.2  Referencing a Subroutine 
 To reference a subroutine you use the  call statement:
 call subroutine_name(optional list of actual arguments) 
and from the earlier example the call to subroutine interact was of the form:
 call interact(p,q,r,ok)  
 When a subroutine returns to the calling program unit control is passed to the 
statement following the  call statement. 
 19.2.3  Dummy Arguments or Parameters and Actual Arguments 
 Procedures and their calling program units communicate through their arguments. 
We often use the terms parameter and arguments interchangeably throughout this 
text. The  subroutine statement normally contains a list of dummy arguments, 
separated by commas and enclosed in brackets. The dummy arguments have a type 
associated with them; for example, in subroutine solve x is of type  real , but no 
space is put aside for this in memory. When the subroutine is referenced e.g.,  call 
solve(p,q,r,root1,root2,ifail), then the dummy argument points to the actual argu-
ment p, which is a variable in the calling program unit. The dummy argument and 
the actual argument must be of the same type – in this case  real . 
 19.2.4  Intent 
 It is recommended that dummy arguments have an  intent  attribute. In the earlier 
example subroutine  solve has a dummy argument  e with  intent (in), which 
means that when the subroutine is referenced or called it is expecting  e to have a 
value, but its value cannot be changed inside the subroutine. This acts as an extra 

266
19 Introduction to Subroutines
security measure besides making the program easier to understand. For each param-
eter it may have one of three attributes:
 intent (in)
• 
 , where the parameter already has a value and cannot be altered 
in the called routine. 
 intent (out)
• 
 , where the parameter does not have a value, and is given one 
in the called routine. 
 intent (inout
• 
) , where the parameter already has a value and this is changed 
in the called routine. 
 19.2.5  Local Variables 
 We saw with functions that variables could be essentially local to the function and un 
available elsewhere. The concept of local variables also applies to subroutines. In the 
example above term and a2 are both local variables to the subroutine  solve .  
 19.2.6  Local Variables and the Save Attribute 
 Local variables are usually created when a procedure is called and their value lost 
when execution returns to the calling program unit. To make sure that a local vari-
able retains its values between calls to a subprogram the save attribute can be used 
on a type statement; e.g.,
 integer , save :: I  
 means that when this statement appears in a subprogram the value of the local vari-
able  I is saved between calls. 
 19.2.7  Scope of Variables 
 In most cases variables are only available within the program unit that deﬁ nes them. 
The introduction of argument lists to procedures immediately opens up the possibil-
ity of data within one program unit becoming available in one or more other pro-
gram units. 
 In the main program we declare the variables  p, q, r, root1, root2, 
ifail  and  ok . 
 Subroutine  interact has no variables locally declared. It works on the argu-
ments  a, b, c  and  ok ; which map onto  p, q, r and  ok from the main pro-
gram, i.e., it works with those variables. 
 Subroutine solve has two locally deﬁ ned variables,  term and  a2 . It works with 
the variables  e, f, g, root1, root2 and  ifail , which map onto  p, q, 
r, root1, root2 and  ifail from the main program. 

267
19.3 Why Bother with Subroutines?
 19.2.8  Status of the Action Carried Out in the Subroutine 
 It is also useful to use parameters that carry information regarding the status of the 
action carried out by the subroutine. With the subroutine  interact we use a logi-
cal variable  ok to report on the status of the interaction with the user. In the subrou-
tine  solve we use the status of the integer variable  ifail to report on the status 
of the solution of the equation. 
 19.2.9  Modules ‘containing’ Procedures 
 At the same time as introducing procedures we have ‘contained’ them in a module 
and then the main program ‘uses’ the module in order to make the procedure avail-
able. Procedures ‘contained’ in modules are called module procedures. 
 With the ‘use’ statement the interface to the procedure is available to the com-
piler so that the types and positions of the actual and dummy arguments can be 
checked. This was a major source of errors with Fortran 77. 
 The  use statement must be the ﬁ rst statement in the main program or calling 
unit, also the modules must be compiled before the program or calling unit. 
 We will cover modules in more depth in later chapters. 
 There are times when an interface is mandatory in Fortran so it’s good practice 
to use module procedures from the start. There are other ways of providing explicit 
interfaces and we will cover them later. 
 19.3  Why Bother with Subroutines? 
 Given the increase in the complexity of the overall program to solve a relatively 
straightforward problem, one must ask why bother. The answer lies in our abil-
ity to manage the solution of larger and larger problems. We need all the help 
we can get if we are to succeed in our task of developing large-scale reliable 
programs. 
 We need to be able to break our problems down into manageable subcompo-
nents and solve each in turn. We are now in a very good position to be able to do 
this. Given a problem that requires a main program, one or more functions and 
one or more subroutines we can work on each subcomponent in relative isolation, 
and know that by using features like module procedures we will be able to glue all 
of the components together into a stable structure at the end. We can indepen-
dently compile the main program and the modules containing the functions and 
subroutines and use the linker to generate the overall executable, and then test 
that. 

268
19 Introduction to Subroutines
 Providing we keep our interfaces the same we can alter the actual implementa-
tions of the functions and subroutines and just recompile the changed procedures. 
 19.4  Summary 
 We now have the following concepts for the use of subroutines:
 Module procedures providing interfaces. 
• 
 Intent attribute for parameters. 
• 
 Dummy parameters. 
• 
 The use of the call statement to invoke a subroutine. 
• 
 The concepts of variables that are local to the called routines and are unavailable 
• 
elsewhere in the overall program. 
 Communication between program units via the argument list. 
• 
 The concept of parameters on the call that enable us to report back on the status 
• 
of the called routine. 
 19.5  Problems 
 1.  Type the program and module procedures for example 1 into one ﬁ le. Compile, 
link and run providing data for complex roots to test this part of the code. 
 2.  Split the main program and modules up into three separate ﬁ les. Compile the 
modules and then compile the main program and link the object ﬁ les to create 
one executable. Look at the ﬁ le size of the executable and the individual object 
ﬁ les. What do you notice? 
  
 The development of large programs is eased considerably by the ability to com-
pile small program units and eradicate the compilation errors from one unit at a 
time. The linker obviously also has an important role to play in the development 
process. 
 3.  Write a subroutine to calculate new coordinates (x' , y' ) from (x, y) when the 
axes are rotated counter clockwise through an angle of a radians using: 
 
 
'
'
x
xcos a
ysin a 
y
xsin a
ycos a
=
+
= -
+
  
 
 Hint: 
 The subroutine would look something like subroutine ChangeCoordinate(x, y, a, 
xd, yd) 
 Write a main program to read in values of x, y and a and then call the subroutine 
and print out the new coordinates. Use a module procedure. 

269
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_20, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to extend the ideas in the earlier chapter on subroutines 
and look in more depth at parameter passing, in particular using a variety of ways of 
passing arrays. 
 20.1  More on Parameter Passing 
 So far we have seen scalar parameters of type real, integer and logical. We will now 
look at numeric array parameters and character parameters. We need to introduce 
some technical terminology ﬁ rst. Don’t panic if you don’t fully understand the ter-
minology as the examples should clarify things. 
 20.1.1  Assumed-Shape Array 
 An assumed-shape array is a nonpointer dummy argument array that takes its shape 
from the associated actual argument array. 
 Chapter 20 
 Subroutines : 2  
 It is one thing to show a man he is in error, and another to 
put him in possession of the truth. 
 John Locke 

270
20 Subroutines: 2
 20.1.2  Deferred-Shape Array 
 A deferred-shape array is an allocatable array or an array pointer. An allocatable 
array is an array that has the allocatable attribute and a speciﬁ ed rank, but its bounds, 
and hence shape, are determined by allocation or argument association. 
 20.1.3  Automatic Arrays 
 An automatic array is an explicit-shape array that is a local variable. Automatic 
arrays are only allowed in function and subroutine subprograms, and are declared in 
the speciﬁ cation part of the subprogram. At least one bound of an automatic array 
must be a nonconstant speciﬁ cation expression. The bounds are determined when 
the subprogram is called. 
 20.2  Example 1 – Assumed Shape Parameter Passing 
 We are going to use an example based on a main program and a subroutine that 
calculates the mean and standard deviation of an array of numbers. The subroutine 
has the following parameters:
 x – the array containing the real numbers. 
• 
 n – the number of elements in the array. 
• 
 mean – the mean of the numbers. 
• 
 std_dev – the standard deviation of the numbers. 
• 
 Consider the following program and subroutine.
 module statistics_module  
 implicit none  
 contains 
 subroutine stats(x,n,mean,std_dev)  
 implicit none  
 integer, intent (in) :: n  
 real, intent (in), dimension (:) :: x  
 real, intent (out) :: mean  
 real, intent (out) :: std_dev  
 real :: variance  
 real :: sumxi, sumxi2  
 integer :: I 
 variance = 0.0  
 sumxi = 0.0  
 sumxi2 = 0.0  

271
20.2 Example 1 – Assumed Shape Parameter Passing
 do I=1, n 
 sumxi = sumxi + x(I)  
 sumxi2 = sumxi2 + x(i)*x(I)  
 end do  
 mean = sumxi/n  
 variance = (sumxi2-sumxi*sumxi/n)/(n-1)  
 std_dev = sqrt(variance)  
 end subroutine stats  
 end module statistics_module  
 program ch2001  
 use statistics_module  
 implicit none  
 integer, parameter :: n = 10  
 real, dimension (1:n) :: x  
 real, dimension (-4:5) :: y  
 real, dimension (10) :: z  
 real, allocatable, dimension (:) :: t  
 real : : m, sd  
 integer :: I 
 do I=1, n 
 x(I) = real(I)  
 end do  
 call stats(x,n,m,sd)  
 print *, ' x'  
 print *, ' Mean = ', m  
 print *, ' Standard deviation = ', sd  
 y = x 
 call stats(y,n,m,sd)  
 print *, ' y'  
 print *, ' Mean = ' , m  
 print *, ' Standard deviation = ', sd  
 z = x 
 call stats(z,10,m,sd)  
 print *, ' z '  
  print *, ' Mean = ' ,  
 m print *, ' Standard deviation = ', sd allocate (t(n))  
 t = x 
 call stats(t,10,m,sd)  
 print *, ' t'  
 print *, ' Mean = ' , m  
 print *, ' Standard deviation = ', sd  
 end program ch2001  
 A fundamental rule in modern Fortran is that the shape of an actual array argu-
ment and its associated dummy arguments are the same, i.e., they both must have 
the same rank and the same extents in each dimension. The best way to apply this 

272
20 Subroutines: 2
rule is to use assumed-shape dummy array arguments as shown in the example 
above. 
 In the subroutine we have
 real , intent (in) , dimension (:) :: x 
 where x is an assumed-shape dummy array argument, and it will assume the shape 
of the actual argument when the subroutine is called. 
 In two of the calls we have passed a variable  n as the size of the array and used 
a literal integer constant (10) in the other two cases. Both parameter passing mecha-
nisms work. 
 20.2.1  Notes 
 There are several restrictions when using assumed-shape arrays:
 The rank is equal to the number of colons, in this case 1. 
• 
 The lower bounds of the assumed-shape array are the speciﬁ ed lower bounds, if 
• 
present, and 1 otherwise. In the example above it is 1 because we haven’t speci-
ﬁ ed a lower bound. 
 The upper bounds will be determined on entry to the procedure and will be what-
• 
ever values are needed to make sure that the extents along each dimension of the 
dummy argument are the same as the actual argument. In this case the upper 
bound will be n. 
 An assumed-shape array must not be deﬁ ned with the pointer or allocatable attri-
• 
bute in Fortran. 
 When using an assumed-shape array an interface is mandatory. In this example 
• 
it is provided by the stats subroutine being a contained subroutine in a module, 
and the use of the module in the main program. 
 20.3  Character Arguments and Assumed-Length 
Dummy Arguments 
 The types of parameters considered so far have been  real, integer and  logi-
cal . Character variables are slightly different because they have a length associated 
with them. Consider the following program and subroutine which, given the name 
of a ﬁ le, opens it and reads values into the  real array  x :
 module read_module  
 implicit none  
 contains  
 subroutine readin(name,x,n)  
 implicit none  
 integer , intent(in) :: n  

273
20.4 Rank 2 and Higher Arrays as Parameters
 real,dimension(:),intent(out)::x  
 character (len=*),intent(in)::name  
 integer::I 
 open(unit=10,status='old',ﬁ le=name)  
 do i=1,n 
 read(10,*)x(I)  
 end do  
 close(unit=10)  
 end subroutine reading  
 end module read_module  
 program ch2002  
 use read_module  
 implicit none  
 real , allocatable , dimension(:) :: a  
 integer :: nos,i  
 character(len=20)::ﬁ lename 
 print *,' Type in the name of the data ﬁ le' 
 read ' (a) ' , ﬁ lename  
 print *,' Input the number of items'  
 read * , nos  
 allocate (a(1:nos))  
 call readin(ﬁ lename,a,nos)  
 print * , ' data read in was'  
 do i=1,nos 
 print *, ' ' ,a(I)  
 enddo 
 end program ch2002  
 The main program reads the ﬁ le name from the user and passes it to the subrou-
tine that reads in the data. The dummy argument  name is of type assumed-length, 
and picks up the length from the actual argument  ﬁ lename in the calling routine, 
which is in this case 20 characters. An interface must be provided with assumed-
shape dummy arguments, and this is achieved in this case by the subroutine being 
in a module. 
 20.4  Rank 2 and Higher Arrays as Parameters 
 The following example illustrates the modern way of passing rank 2 and higher 
arrays as parameters. We start with a simple rank 2 example.
 module matrix_module 
 implicit none  
 contains 
 subroutine matrix_bits(a,b,c,a_t,n)  

274
20 Subroutines: 2
 implicit none  
 integer, intent (in) :: n  
 real, dimension (:,:), intent (in) : : a, b 
real, dimension (:,:), intent (out) :: c, 
a_t 
 integer :: I, j , k  
 real :: temp  
 ! matrix multiplication c=ab 
 do I = 1, n 
 do j = 1, n 
 temp = 0.0  
 do k = 1, n 
 temp = temp + a (i, k) *b (k, j )  
 end do  
 c(i,j) = temp  
 end do  
 end do  
 ! calculate a_t transpose of a  
 ! set a_t to be transpose matrix a 
 do I=1, n 
 do j = 1, n 
 a_t(i,j) = a(j,i)  
 end do  
 end do  
 end subroutine matrix bits  
 end module matrix module  
 program ch2003 
 use matrix module  
 implicit none  
 real, allocatable, dimension (:,:) :: & 
 one, two, three, one_t  
 integer :: I, n  
 print *, 'input size of matrices'  
 read *, n  
 allocate (one(1:n,1:n))  
 allocate (two(1:n,1:n))  
 allocate (three(1:n,1:n))  
 allocate (one_t(1:n,1:n))  
  do I=1, n 
 print *, 'input row ', I, ' of one'  
 read *, one(i,1:n)  
 end do  
 do I=1, n 
 print *, 'input row ', I, ' of two'  
 read *, two(i,1:n)  
 end do  

275
20.5 Automatic Arrays and Median Calculation
 call matrix bits(one,two,three,one t,n) 
print *, ' matrix three:'  
 do I=1, n 
 print *, three(i,1:n)  
 end do  
 print *, ' matrix one t:'  
 do I=1, n 
 print *, one t(i,1:n)  
 end do  
 end program ch2003  
 The subroutine is doing a matrix multiplication and transpose. There are intrinsic 
functions in Fortran called  matmul and  transpose that provide the same func-
tionality as the subroutine. One of the problems at the end of the chapter is to replace 
the code in the subroutine with calls to the intrinsic functions. 
 20.4.1  Notes 
 The dummy array and actual array arguments look the same but there is a difference:
 The dummy array arguments  
• 
a, b, c, a_t are all assumed-shape arrays and 
take the shape of the actual array arguments  one, two, three and  one_t , 
respectively. 
 The actual array arguments  
• 
one, two, three and  one_t in the main pro-
gram are allocatable arrays or deferred-shape arrays. An allocatable array is an 
array that has an allocatable attribute. Its bounds and shape are declared when the 
array is allocated, hence deferred-shape. 
 20.5  Automatic Arrays and Median Calculation 
 This example looks at the calculation of the median of a set of numbers and also 
illustrates the use of an automatic array. 
 The median is the middle value of a list, i.e., the smallest number such that at 
least half the numbers in the list are no greater. if the list has an odd number of 
entries, the median is the middle entry in the list after sorting the list into ascending 
order, if the list has an even number of entries, the median is equal to the sum of the 
two middle (after sorting) numbers divided by two. One way to determine the 
median computationally is to sort the numbers and choose the item in the middle. 
 Wirth classiﬁ es sorting into simple and advanced, and his three simple methods 
are as follows:
 Insertion sorting – The items are considered one at a time and each new item is 
• 
inserted into the appropriate position relative to the previously sorted item. If you 
have ever played bridge then you have probably used this method. 

276
20 Subroutines: 2
 Selection sorting – First the smallest (or largest) item is chosen and is set aside 
• 
from the rest. Then the process is repeated for the next smallest item and set aside 
in the next position. This process is repeated until all items are sorted. 
  Exchange sorting – if two items are found to be out of order they are inter-
• 
changed. This process is repeated until no more exchanges take place. 
 Knuth also identiﬁ es the above three sorting methods. For more information on 
sorting the Knuth and Wirth books are good starting places. Knuth is a little old 
(1973) compared to Wirth (1986), but it is still a very good coverage. Knuth uses 
mix assembler to code the examples whilst the Wirth book uses Modula 2, and is 
therefore easier to translate into modern Fortran. 
 In the example below we use an exchange sort:
 module statistics_module 
 implicit none  
 contains 
 subroutine stats(x,n,mean,std_dev,median)
implicit none  
 integer, intent (in) :: n  
 real, intent (in), dimension (:) :: x  
 real,intent (out) :: mean  
 real, intent (out) :: std_dev  
 real, intent (out) :: median  
 real, dimension (1:n) :: y  
 real :: variance  
 real :: sumxi, sumxi2  
 integer :: k  
 sumxi = 0.0  
 sumxi 2 = 0.0  
 variance = 0.0  
 sumxi = sum(x)  
 sumxi2 = sum(x*x)  
 mean = sumxi/n  
 variance = (sumxi2-sumxi*sumxi/n)/(-1)  
 std_dev = sqrt(variance)  
 y = x 
 if (mod(n,2)==0) then 
 median = (ﬁ nd(n/2)+ﬁ nd((n/2)+1))/2  
 else 
 median = ﬁ nd((n/2) +1)  
 end if  
 contains 
 real function ﬁ nd(k) implicit none   
 integer, intent (in) :: k  
 integer :: l, r, I, j  
 real :: t1, t2  
 l = 1 

277
20.5 Automatic Arrays and Median Calculation
 r = n 
 do while (l<r) 
 t1 = y(k)  
 I = l 
 j = r 
 do 
 do while (y(i)<t1) 
 I = I + 1  
 end do  
 do while (t1<y(j)) 
 j = j – 1  
 end do  
 if (i<=j) then 
 t2 = y(I)  
 y(I) = y(j)  
 y(j) = t2  
 I = I + 1  
 j = j - 1  
 end if  
 if (i>j) exit  
 end do  
 if (j<k) then 
 l = I 
 end if  
 if (k<i) then 
 r = j 
 end if  
 end do  
 ﬁ nd = y(k)  
 end function ﬁ nd 
 end subroutine stats  
 end module statistics_module  
 program ch2004 
 use statistics_module  
 implicit none   
 integer :: n  
 integer :: I  
 real, allocatable, dimension (:) :: x  
 real :: m, sd, median  
 integer, dimension (8) :: timing  
 n = 1000000  
 do I = 1, 3 
 print *, ' n = ', n  
 allocate (x(1:n))  
 call random number(x)  
 x = x*1000  

278
20 Subroutines: 2
 call date and time(values=timing)  
 print *, ' initial '  
 print *, timing (6), timing (7), timing (8)  
 call stats(x,n,m,sd,median)  
 print *, ' Mean = ', m  
 print *, ' Standard deviation = ', sd  
 print *, ' Median is = ', median  
 call date and time(values=timing)  
 print *, timing(6), timing(7), timing(8)  
 n = n*10  
 deallocate (x)  
 end do  
 end program ch2004  
 In the subroutine stats the array y is automatic. It will be allocated automatically 
when we call the subroutine. We use this array as a work array to hold the sorted 
data. We then use this sorted array to determine the median. 
 Note the use of the  sum intrinsic in this example:
 sumxi=sum(x) 
 sumxi2=sum(x*x)  
 These statements replace the  do loop from the earlier example. A good optimis-
ing compiler would not make two passes over the data with these two statements. 
 20.5.1  Internal Subroutines and Scope 
 The stats subroutine contains the ﬁ nd subroutine. The stats subroutine has access to 
the following variables
 x,n,mean,std_dev, median — these are made available as they are passed in as 
• 
parameters. 
 y, variance, sumxi, sumxi2 — are local to the subroutine stats. 
• 
 The subroutine ﬁ nd has access to the above as it is contained within subroutine 
stats. It also has the following local variables that are only available within subrou-
tine selection
 i,j,k, minimum 
• 
 This program uses an algorithm developed by Hoare to determine the median. 
The number of computations required to ﬁ nd the median is approximately 2 * n. 
 The limiting factor with this algorithm on these systems is the amount of installed 
memory. The program crashes on both systems with a failure to allocate the auto-
matic array. This is a drawback of automatic arrays in that there is no mechanism to 
handle this failure gracefully. You would then need to use allocatable local work 
arrays. The drawback here is that the programmer is then responsible for the deal-
location of these arrays. Memory leaks are then possible. 

279
20.6 Recursive Subroutines – Quicksort
 20.6  Recursive Subroutines – Quicksort 
 In Chap.  12 we saw an example of recursive functions. This example illustrates the 
use of recursive subroutines. It uses a simple implementation of Hoare’s Quicksort. 
References are given in the bibliography. The overall problem is broken down into:
 A main program that prompts the user for the name of the data ﬁ le and n. The 
• 
allocation of the array is carried out in the main program. 
 A subroutine to read the data. 
• 
 A subroutine to sort the data. This subroutine contains the recursive sub routine 
• 
Quicksort. 
 A subroutine to write the sorted data to a ﬁ le. 
• 
 Below is the complete program:
 module read_data_module 
 implicit none  
 contains 
 subroutine read_data(ﬁ le_name,raw_data,how_ many) 
 implicit none  
 character (len=*), intent (in) :: ﬁ le_ name  
 integer, intent (in) :: how_many  
 real, intent (out), dimension (:) :: raw_ data  
 ! local variables 
 integer : : I  
 open (ﬁ le=ﬁ le _name,unit=1)  
 do I=1, how many 
 read (unit=1,fmt=*) raw_data(I)  
 end do  
 end subroutine read_data  
 end module read_data_module  
 module sort_data_module 
 implicit none  
 contains 
 subroutine sort_data(raw_data,how_many) 
 implicit none  
 integer, intent (in) :: how_many  
 real, intent (inout) , dimension (:) :: raw_data  
 call quicksort(1,how many)  
 contains 
 recursive subroutine quicksort(l,r) 
 implicit none  
 integer, intent (in) :: l, r  
 ! local variables 
 integer :: I, j  

280
20 Subroutines: 2
 real :: v, t  
 I = l 
 j = r 
 v = raw_data(int((l+r)/2))  
 do 
 do while (raw data(i)<v) 
 I = I + 1  
 end do  
 do while (v<raw data(j)) 
 j = j – 1  
 end do  
 if (i<=j) then 
 t = raw data (I)  
 raw_data(I) = raw_data(j)  
 raw_data(j) = t  
 I = I + 1  
 j = j – 1  
 end if  
 if (i>j) exit  
 end do  
 if (l<j) then 
 call quicksort(l,j)  
 end if  
 if (i<r) then 
 call quicksort(i, r)  
 end if  
 end subroutine quicksort  
 end subroutine sort_data  
 end module sort_data_module  
 module print data module 
 implicit none  
 contains 
 subroutine print_data(raw_data,how_many) 
 implicit none  
 integer, intent (in) :: how_many  
 real, intent (in), dimension (:) :: raw_data  
  ! local variables 
 integer :: I  
 open (ﬁ le='sorted.txt',unit=2)  
 do I=1, how many 
 write (unit=2,fmt=*) raw_data(I)  
 end do 
 close (2)  
 end subroutine print_data  
 end module print_data_module  

281
20.6 Recursive Subroutines – Quicksort
 program ch2005 
 use read_data_module  
 use sort_data_module  
 use print_data_module  
 implicit none  
 integer :: how many  
 character (len=20) :: ﬁ le name  
 real, allocatable, dimension (:) :: raw_data  
 integer, dimension (8) :: timing  
 print *, ' how many data items are there?'  
 read *, how_many  
 print *, ' what is the ﬁ le name?'  
 read '(a)', ﬁ le name  
 call date_and_time(values=timing)  
 print *, ' initial'  
 print *, timing (6), timing (7), timing(8)  
 allocate (raw_data(how_many))  
 call date_and_time(values=timing)  
 print *, ' allocate'  
 print *, timing (6), timing (7), timing (8)  
 call read_data(ﬁ le_name,raw_data,how_many)  
 call date_and_time(values=timing)  
 print *, ' read'  
 print *, timing(6), timing (7), timing(8)  
 call sort_data(raw_data,how_many)  
 call date_and_time(values=timing)  
 print *, ' sort'  
 print *, timing (6), timing (7), timing (8)  
 call print_data(raw_data,how_many)  
 call date_and_time(values=timing)  
 print *, ' print'  
  print *, timing (6), timing (7), timing (8)  
 print *,   '  ' 
 print *, ' data written to ﬁ le sorted.txt'  
 end program ch2005  
 20.6.1  Note – Recursive Subroutine 
 The actual sorting is done in the recursive subroutine  QuickSort . The actual 
algorithm is taken from the Wirth book. See the bibliography for a reference. 
 Recursion provides us with a very clean and expressive way of solving many 
problems. There will be instances where it is worthwhile removing the overhead of 
recursion, but the ﬁ rst priority is the production of a program that is correct. It is 
pointless having a very efﬁ cient but incorrect solution. 

282
20 Subroutines: 2
 We will look again at recursion and efﬁ ciency in a later chapter and see under 
what criteria we can replace recursion with iteration. 
 20.6.2  Note – Flexible Design 
 The QuickSort recursive routine can be replaced with another sorting algorithm and 
we can maintain the interface to Sort_data. We can thus decouple the implementa-
tion of the actual sorting routine from the deﬁ ned interface. We would only need to 
recompile the Sort_data routine and we could relink using the already compiled 
main, read data and print data routines. 
 A later chapter looks at a non recursive implementation of quicksort where we 
look at some of the ways of rewriting the above program by replacing the recursive 
quicksort with the non recursive version. 
 20.6.3  Note – Timing Information 
 We call the date_and_time intrinsic subroutine to get timing information. 
 As can be seen it is the I/O that dominates the overall running time of the pro-
gram. In the 10 years since ﬁ rst running this program we have seen the data set size 
increase from tens of thousands to tens and hundreds of millions. 
 20.7  Elemental Subroutines 
 We saw an example in Chap.  12 of elemental functions. Here is an example of an 
elemental subroutine.
 module swap_module  
 implicit none  
 contains 
 elemental subroutine swap(x,y)  
 integer , intent(inout) :: x,y  
 integer :: temp 
 temp=x  
 x=y 
 y=temp  
 end subroutine swap  
 end module swap_module  
 program ch2006  
 use swap_module  
 implicit none  

283
20.9 Problems
 integer , dimension(10) :: a,b  
 integer :: I 
 do I=1, 10 
 a(i)=I  
 b(i)=i*I  
 end do 
 print *,a  
 print *,b  
 call swap(a,b)  
 print *,a  
 print *,b  
 end program ch2006  
 The subroutine is written as if the arguments are scalar, but work with arrays! 
User deﬁ ned elemental procedures came in with Fortran 95. 
 20.8  Summary 
 We now have a lot of the tools to start tackling problems in a structured and modular 
way, breaking problems down into manageable chunks and designing subprograms 
for each of the tasks. 
 20.9  Problems 
 1.  Below is the random number program that was used to generate the data sets for 
the Quicksort example:
 program ch2007  
 implicit none  
 integer :: n  
 integer :: I  
 real , allocatable , dimension (:) :: x 
 print *, ' how many values ?'  
 read *,n  
 allocate(x(1:n))  
 call random_number(x)  
 x=x*1000  
 open(unit=10,ﬁ le='random.txt')  
 do i=1,n 
 write(10, 100)x(I)  
 100 format(f8.3)  
 end do  
 end program ch2007  

284
20 Subroutines: 2
  
 
 Run the Quick_Sort program in this chapter with the data ﬁ le as input. Obtain 
timing details. 
  
 
 What percentage of the time does the program spend in each subroutine? Is it 
worth trying to make the sort much more efﬁ cient given these timings? 
 2.  Find out if there is a subroutine library like the NAG library available. if there is 
replace the Quick_Sort recursive subroutine with a suitable routine from that 
library. What times do you obtain? 
 3.  Try using the operating system SORT command to sort the ﬁ le. What timing 
ﬁ gures do you get now? 
 Was it worth writing a program? 
 4.  Consider the following program:
 program ch2008  
 ! 
 ! program to test array subscript checking  
 ! when the array is passed as an argument.  
 ! 
 implicit none  
 integer , parameter :: array_size=10  
 integer :: I  
 integer , dimension(array_size) :: a 
 do i=1,array_size 
 a(i)=I  
 end do  
 call sub01(a,array size)  
 end program ch2008  
 subroutine sub01(a,array_size)  
 implicit none  
 integer , intent(in) :: array_size  
 integer , intent(in) , dimension(array_size) :: a  
 integer :: I  
 integer :: atotal=0  
 integer :: rtotal=0 
 do i=1,array_size 
 rtotal=rtotal+a(I)  
 end do  
 do i=1,array_size+1 
 atotal=atotal+a(I)  
 end do  
 print *, ' Apparent total is ' , atotal  
 print *,' real total is ' , rtotal  
 end subroutine sub01  
  
 
 The key thing to note is that we haven’t used interface blocks and we have an 
error in the subroutine where we go outside the array. Run this program. What 
answer do you get for the apparent total? 

285
20.11 Commercial Numerical and Statistical Subroutine Libraries
  
 
 Are there any compiler ﬂ ags or switches which will enable you to trap this 
error? 
 5.  Use the intrinsic functions  matmul and  transfer in program ch2003 to 
replace the current Fortran 77 style code. 
 20.10  Bibliography 
 Hoare, C.A.R.: Algorithm 63, partition; algorithm 64, quicksort, p.321; algorithm 
65: FIND. Commun. ACM.  4 , 321–322 (1961) 
 Hoare, C.A.R.: Proof of a program: FIND. Commun. ACM.  13 (1), 39–45 (1970) 
 Hoare, C.A.R.: Proof of a recursive program: quicksort. Comput. J.  14 (4), 391–395 
(1971) 
 Knuth , D.E.: The Art of Computer programming. Sorting and Searching, vol. 3. 
Addison-Wesley, Reading (1973) 
 Wirth, N.: Algorithms and Data Structures. Prentice-Hall, Upper Saddle River 
(1986) 
 20.11  Commercial Numerical and Statistical Subroutine 
Libraries 
 There are two major suppliers of commercial libraries:
 NAG: Numerical Algorithms Group 
• 
 and
 Rogue Wave Software 
• 
 They can be found at:
 
• http://www.nag.co.uk/ 
 and
 
• http://www.roguewave.com/ 
 respectively. Their libraries are written by numerical analysts, and are fully tested 
and well documented. They are under constant development and available for a wide 
range of hardware platforms and compilers. Parallel versions are also available.  

287
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_21, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look at the facilities found in Fortran provided by 
modules, in particular:
 The use of a module to aid in the consistent deﬁ nition of precision throughout a 
• 
program and subprograms. 
 The use of modules for global data. 
• 
 The use of modules for derived data types. 
• 
 Modules containing procedures 
• 
 Public, private and protected attributes 
• 
 The use statement and its extensions 
• 
 21.1  Introduction 
 We have now covered the major executable building blocks in Fortran and they are
 The main program unit 
• 
 Functions 
• 
 Subroutines 
• 
and these provide us with the tools to solve many problems using just a main pro-
gram and one or more external and internal procedures. Both external and internal 
procedures communicate through their argument lists, whilst internal procedures 
have access to data in their host program units. 
 Chapter 21 
 Modules  
 Common sense is the best distributed commodity in the world, 
for every man is convinced that he is well supplied with it. 
 Descartes 

288
21 Modules 
 We have also introduced modules. The ﬁ rst set of examples was in the chapter on 
functions. The second set were in the chapter on derived types and the third set were 
in the subroutine chapters. 
 We will now look at examples of modules for
 Precision deﬁ nition. 
• 
 Global data 
• 
 Modules containing procedures 
• 
 Derived type deﬁ nition. 
• 
 Modules provide  the  code organisational mechanism in Fortran and can be 
thought of as the equivalent of classes in C++, Java and C#. They are one of the 
most important features of modern Fortran. 
 21.2  Basic Module Syntax 
 The form of a module is
 module module_name  
 … 
 end module module_name  
and the speciﬁ cations and deﬁ nitions contained within it is made available in the 
program units that need to access it by
 use module_name 
 The  use statement must be the ﬁ rst statement after the program, function or sub-
routine statement. 
 21.3  Modules for Global Data 
 So far the only way that a program unit can communicate with a procedure is through the 
argument list. Sometimes this is very cumbersome, especially if a number of procedures 
want access to the same data, and it means long argument lists. The problem can be 
solved using modules; e.g., by deﬁ ning the precision to which you wish to work and any 
constants deﬁ ned to that precision which may be needed by a number of procedures.  
 21.4  Modules for Precision Speciﬁ cation and Constant 
Deﬁ nition 
 In the following example we use a module to deﬁ ne a parameter  long to specify 
the precision to which we wish to work, and another for a range of mathematical 
 constants including a value for the parameter  p . Note that the parameter  p is deﬁ ned 

289
21.4 Modules for Precision Speciﬁ cation and Constant Deﬁ nition
to this working precision. We then import the module deﬁ ning these parameters into 
the program units that need them. We also use a module procedure.
 module precision_module 
 implicit none  
 integer, parameter :: &  
 long=selected_real_kind(15,307)  
 end module precision_module  
 module maths_module  
 use precision_module  
 implicit none  
 real (long), parameter :: c = 299792458.0_long  
 ! units ms-1  
 real (long), parameter :: & 
 e = 2.71828182845904523_long  
 real (long), parameter :: g = 9.812420_long  
 ! 9.780 356ms-2 at sea level on the equator  
 ! 9.812 420ms-2 at sea level in london  
 ! 9.832 079ms-2 at sea level at the poles  
 real (long), parameter :: & 
 pi = 3.14159265358979323_long  
 end module maths_module  
 module sub1_module  
 implicit none  
 contains  
 subroutine sub1(radius,area,circum) 
 use precision_module  
 use maths_module  
 implicit none  
 real(long),intent(in)::radius  
 real(long),intent(out)::area,circum  
 area=pi*radius*radius  
 circum=2.0_long*pi*radius  
 end subroutine sub1  
  end module sub1_module  
 program ch2101  
 use precision_module  
 use sub1_module  
 implicit none  
 real(long)::r,a,c  
 integer : :I  
 do I=1,5 
 print*, 'radius?'  
 read*,r  
 call sub1(r,a,c)  

290
21 Modules 
 print *, 'for radius = ', r 
 print *, 'area = ',a 
 print *, 'circumference = ',c 
 end do  
 end program ch2101 
 21.4.1  Note 
 In this example we wish to work with the precision speciﬁ ed by the kind type 
parameter  long in the module  precision_module . In order to do this we use 
the statement
 use precision_module 
inside the program units before any declarations. The kind type parameter  long is 
then used with all the real type declaration e.g.,
 real (long):: r,a,c 
 To make sure that all ﬂ oating point calculations are performed to the working preci-
sion speciﬁ ed by  long any constants such as 2.0 in subroutine  Sub1 are speciﬁ ed 
as  const_long e.g.,
 2.0_long 
 Note also that we deﬁ ne things once and use them on two occasions, i.e., we deﬁ ne 
the precision once and use this deﬁ nition in both the main program and the 
subroutine. 
 21.5  Modules for Sharing Arrays of Data 
 The following example uses a module to deﬁ ne a parameter and two arrays. The 
module also contains three subroutines that have access to the data in the module. 
The main program has the statement
 use data_module 
which interfaces to the three subroutines. 
 Note that in this example the calls to the subroutines have no parameters. They 
work with the data contained in the module.
 module data_module 
 implicit none  
 integer, parameter : : n=12  
 real, dimension(1:n) :: rainfall  
 real, dimension(1:n) :: sorted  

291
21.5 Modules for Sharing Arrays of Data
 contains  
 subroutine readdata  
 implicit none  
 integer :: I  
 character (len=40) :: ﬁ lename 
 print *, 'What is the ﬁ lename ?'  
 read *,ﬁ lename  
 open(unit=100,ﬁ le=ﬁ lename)  
 do i=1,n 
 read (100,*) rainfall(I)  
 end do  
 end subroutine readdata  
 subroutine sortdata  
 implicit none 
 sorted=rainfall  
 call selection  
 contains 
 subroutine selection  
 implicit none  
 integer :: i, j, k  
 real :: minimum  
 do i=1,n-1  
 k=I 
 minimum=sorted(I)  
 do j=i+1,n 
 if (sorted(j) < minimum) then  
 k=j 
 minimum=sorted(k)  
 end if  
 end do  
 sorted(k)=sorted(I)  
  sorted(i)=minimum  
 end do  
 end subroutine selection  
 end subroutine sortdata  
 subroutine printdata  
 implicit none  
 integer :: I 
 print *, 'original data is'  
 do i=1,n 
 print 100,rainfall(I)  
 100 format(1x, f7.1)  
 end do  
 print *, 'Sorted data is'  

292
21 Modules 
 do i=1,n 
 print 100,sorted(I)  
 end do  
 end subroutine printdata  
 end module data_module  
 program ch2102  
 use data_module  
 implicit none 
 call readdata  
 call sortdata  
 call printdata  
 end program ch2102 
 21.6  Modules for Derived Data Types 
 When using derived data types and passing them as arguments to procedures, both 
the actual arguments and dummy arguments must be of the same type, i.e., they 
must be declared with reference to the same type deﬁ nition. The only way this can 
be achieved is by using modules. The user deﬁ ned type is declared in a module and 
each program unit that requires that type uses the module. 
 21.6.1  Person Data Type 
 In this example we have a user deﬁ ned type  person which we wish to use in the 
main program and pass arguments of this type to the subroutines  read_data and 
stats. In order to have the type  person available to two subroutines and the 
main program we have deﬁ ned person in a module  personal_module and 
then made the module available to each program unit with the statement
 use personal_module  
 Note that we have put both subroutines in one module.
 module personal_module 
 implicit none  
 type person 
 real:: weight  
 integer :: age  
 character :: sex  
 end type person  
 end module personal_module  
 module subs_module  

293
21.6 Modules for Derived Data Types
 use personal_module  
 implicit none  
 contains  
 subroutine read_data(data,max_no,no) 
 implicit none  
 type (person), dimension (:), intent(out)::data  
 integer, intent(out):: no  
 integer, intent(in):: max_no  
 integer :: I  
 do 
 print *, 'input number of patients'  
 read *,no  
 if (no  >  0 .and. no < = max_no) exit  
 end do  
 do i=1,no 
 print *, 'for person',I  
 print *, 'weight ?'  
 read*,data(i)%weight  
 print*, 'age ?'  
 read*,data(i)%age  
 print*, 'sex ?'  
 read*,data(i)%sex  
 end do  
 end subroutine read_data  
 subroutine stats(data,no,m_a,f_a)  
 implicit none  
 type(person), dimension(:), intent(in) ::data  
 real, intent(out) :: m_a,f_a  
 integer, intent(in):: no  
 integer :: i,no_f,no_m  
 m_a=0.0; f_a=0.0;no_f=0; no_m =0  
 do i=1,no 
 if (data(i)%sex == 'M' &  
 .or. data(i)%sex == 'm') then 
  m_a=m_a+data(i)%weight  
 no_m=no_m+1  
 elseif(data(i)%sex == 'F' &  
 .or. data(i)%sex == 'f') then  
 f_a=f_a+data(i)%weight  
 no_f=no_f+1  
 endif 
 end do  
 if (no_m  >  0) then 
 m_a = m_a/no_m  

294
21 Modules 
 endif 
 if (no_f  >  0) then 
 f_a = f_a/no_f  
 endif 
 end subroutine stats  
 end module subs_module  
 program ch2103  
 use personal_module  
 use subs_module  
 implicit none  
 integer,parameter:: max _no=100  
 type (person), dimension(1:max_no) :: patient  
 integer :: no_of_patients  
 real :: male_average, female_average  
 ! 
 call read_data(patient,max_no,no_of patients)  
 call stats(patient, no_of_patients, &  
 male_average, female_average)  
 print*, 'average male weight is ',male_average  
 print*, 'average female weight is ',female_average  
 end program ch2103  
 21.7  Private, Public and Protected Attributes 
 With the examples of modules so far every entity in a module has been accessible to 
each program unit that ‘uses’ the module. By default all entities in a module have 
the public attribute, but sometimes it is desirable to limit the access. If entities have 
the private attribute this limits the possibility of inadvertent changes to a variable by 
another program unit. 
 Example of using public and private attributes:
 real, public :: a, b, c  
 integer, private :: I, j, k  
 If a variable in a module is declared to be public, its access can be partially restricted 
by also giving it the protected attribute. This means that the variable can still be seen 
by program units that use the module but its value cannot be changed e.g.
 integer, public, protected:: I  

295
21.10 Formal Syntax
 21.8  The Use Statement 
 In its simplest form the use statement is
 use module_name 
which then makes all the module’s public entities available to the program unit. 
There may be times when only certain entities should be available to a particular 
program unit. In Example 1 subroutine sub1 ‘uses’ maths_module but 
only needs pi and not c, e and g. The use statement could therefore be
 use maths_module, only: pi  
 There are also times when an entity in a module needs to have its name changed 
when used in a program unit. For example variable g in  maths_module needs to 
be called  gravity in subroutine  sub1  so the use statement becomes
 use maths_module, gravity=  >  g 
 21.9  Notes on Module Usage and Compilation 
 If we only have one ﬁ le comprising all of the program units (main program, mod-
ules, functions and subroutines) then there is little to worry about. However, it is 
recommended that larger-scale programs be developed as a collection of ﬁ les with 
related program units in each ﬁ le, or even one program unit per ﬁ le. This is more 
productive in the longer term, but it will lead to problems with modules unless we 
compile each module before we use it in other program units. 
 21.10  Formal Syntax 
 The following is taken from the standard and describes more fully requirements in 
the interface area. 
 21.10.1  Interface 
 The interface of a procedure determines the forms of reference through which it 
may be invoked. The procedure’s interface consists of its name, binding label, 
generic identiﬁ ers, characteristics, and the names of its dummy arguments. The 
characteristics and binding label of a procedure are ﬁ xed, but the remainder of the 
interface may differ in differing contexts. 

296
21 Modules 
 21.10.2  Implicit and Explicit Interfaces 
 Within the scope of a procedure identiﬁ er, the interface of the procedure is either 
explicit or implicit. The interface of an internal procedure, module procedure, or 
intrinsic procedure is always explicit in such a scope. 
 The interface of a subroutine or a function with a separate result name is explicit 
within the subprogram where the name is accessible. 
 21.10.3  Explicit Interface 
 A procedure other than a statement function shall have an explicit interface if it is 
referenced and
 a reference to the procedure appears
• 
 with an argument keyword, or 
 –
 in a context that requires it to be pure, 
 –
 the procedure has a dummy argument that
• 
 has the ALLOCATABLE, OPTIONAL, POINTER, TARGET, VALUE 
 –
attribute, 
 is an assumed-shape array, 
 –
 is a coarray, 
 –
 is polymorphic, 
 –
 the procedure has a result that
• 
 is an array, 
 –
 is a pointer or is allocatable, or 
 –
 has a nonassumed type parameter value that is not a constant expression, 
 –
 the procedure is elemental 
• 
 21.11  Summary 
 We have now introduced the concept of a module, another type of program unit, 
probably one of the most important features of Fortran 90. We have seen in this 
chapter how they can be used:
 Deﬁ ne global data. 
• 
 Deﬁ ne derived data types. 
• 
 Contain explicit procedure interfaces. 
• 
 Package together procedures. 
• 

297
21.12 Problems
 This is a very powerful addition to the language, especially when constructing 
large programs and procedure libraries. 
 21.12  Problems 
 1. Write two functions, one to calculate the volume of a cylinder  p r  2   l where the 
radius is r and the length is l, and the other to calculate the area of the base of the 
cylinder  p  r 2 . Deﬁ ne  p as a parameter in a module which is used by the two func-
tions. Now write a main program which prompts the user for the values of r and 
l, calls the two functions and prints out the results. 
 2. Make all the real variables in the above problem have 15 signiﬁ cant digits and a 
range of 10 −307 to 10 +307 . Use a module. 

299
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_22, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look at several complete examples illustrating data 
structuring in Fortran.
 Singly linked list: reading in an arbitrary amount of text 
• 
 Singly linked list: reading in an arbitrary quantity of numeric data 
• 
 Ragged arrays – lower triangular matrix 
• 
 Ragged arrays – variable sized data sets 
• 
 Perfectly balanced tree 
• 
 Date derived type 
• 
 22.1  Introduction 
 This chapter looks at simple data structuring in Fortran using a range of examples. 
We use modules throughout to deﬁ ne the data structures that we will be working 
with. The chapter starts with a number of pointer examples. 
 Chapter 22 
 Simple Data Structuring in Fortran  
 The good teacher is a guide who helps others to dispense 
with his services. 
 R. S. Peters, Ethics and Education 

300
22 Simple Data Structuring in Fortran
 22.2  Singly Linked List: Reading in an Arbitrary 
Amount of Text 
 Conceptually a singly linked list consists of a sequence of boxes with compartments. 
In the simplest case the ﬁ rst compartment holds a data item and the second contains 
directions to the next box. 
 In the diagram below we have a singly linked list that holds three characters I, a 
and n. Element 1 is at address 100 and holds the letter I and a pointer to the next 
element – at address 104. Element 2 holds the letter a and a pointer to the next element 
– at address 108. Element 3 holds the letter n, and does not point to anything – we 
use the null pointer. 
 I 
 104 
 →  a 
 108 
 →  n 
 null 
 We can construct a data structure in Fortran to work with a singly linked list by 
deﬁ ning a link data type with two components, a character and a pointer to a link 
data type. A complete program to do this is given below:
 module link_module 
 type link 
 character :: c  
 type (link) , pointer :: next => null()  
 end type link  
 end module link_module  
 program ch2201  
 use link_module  
 implicit none  
 type (link) , pointer :: root , current  
 integer :: io_stat_number=0 
 allocate(root)  
 print *,' type in some text'  
 read (unit = *, fmt = '(a)' , advance = 'no' , & 
 iostat = io_stat_number) root%c  
 if (io_stat_number == –1) then 
 nullify(root%next)  
 else 
 allocate(root%next)  
 endif 
 current => root  
 do while (associated(current%next)) 
 current => current%next  
 read (unit=*,fmt='(a)',advance='no', &  
 iostat=io_stat_number) current%c  

301
22.2 Singly Linked List: Reading in an Arbitrary Amount of Text 
 if (io_stat_number == -1) then 
 nullify(current%next)  
 else 
 allocate(current%next)  
 endif 
 end do  
 current => root  
 do while (associated(current%next)) 
 print * , current%c  
 current => current%next  
 end do  
 end program ch2201  
 The behaviour of this program is system speciﬁ c. You will have to look at your 
compiler documentation regarding the IO_Stat_Number. The ﬁ rst thing of interest 
is the type deﬁ nition for the singly linked list. We have
 module link_module 
 type link 
 character :: c  
 type (link) , pointer :: next => null()  
 end type link  
 end module link_module  
and we call the new type  link . It comprises two component parts: the ﬁ rst holds a 
character C, and the second holds a pointer called  next to allow us to refer to 
another instance of type  link . Remember we are interested in joining together 
several boxes or  links . 
 The next item of interest is the variable deﬁ nition. Here we deﬁ ne two variables 
 root and  current to be pointers that point to items of type  link . In Fortran when 
we deﬁ ne a variable to be a pointer we also have to deﬁ ne what it is allowed to point to. 
This is a very useful restriction on pointers, and helps make using them more secure. 
 The ﬁ rst executable statement
 allocate(root)  
requests that the variable  root be allocated memory. At this time the contents of 
the character component is undeﬁ ned and the pointer component is disassociated. 
 The next statement reads a character from the keyboard. We are using a number 
of additional features of the read statement, including
 advance='no'  
 iostat=io_stat_number  
and the two options combine to provide the ability to read an arbitrary amount of 
text from the user per line, and terminate only when end of ﬁ le is encountered as the 

302
22 Simple Data Structuring in Fortran
only input on a line, typically by typing CTRL Z. Note that the numbers returned by 
the iostat option are implementation speciﬁ c. A small program would have to be 
written to test the values returned for each platform. 
 If an end of ﬁ le is reached then the pointer  root%next is nulliﬁ ed using the 
nullify statement. This gives the pointer a status of disassociated, and this is a 
convenient way of saying that it doesn’t point to anything valid. 
 If the end of ﬁ le is not detected then the next link in the chain is created.The 
statement
 Current => Root  
means that both  Current and  Root point to the same physical memory location, 
and this holds a character data item and a pointer. We must do this as we have to 
know where the start of the list is. This is now our responsibility, not the compilers. 
Without this statement we are not able to do anything with the list except ﬁ ll it up 
— hardly very useful. 
 The while loop is then repeated until end of ﬁ le is reached. if the user had typed 
an end of ﬁ le immediately then  Current%Next  would not be associated, and 
the while loop would be skipped. 
 This loop allocates memory and moves down the chain of boxes one character at 
a time ﬁ lling in the links between the boxes as we go. We then have
 Current => Root  
and this now means that we are back at the start of the list, and in a position to traverse 
the list and print out each character in the list. 
 There is thus the concept with the pointer variable current of it providing us 
with a window into memory where the complete linked list is held, and we look at 
one part of the list at a time. 
 Both while loops use the intrinsic function  associated  to check the association 
status of a pointer. 
 It is recommended that this program be typed in, compiled and executed. It is 
surprisingly difﬁ cult to believe that it will actually read in a completely arbitrary 
number of characters from the user. Seeing is believing. 
 22.3  Singly Linked List: Reading in an Arbitrary Quantity 
of Numeric Data 
 In this example we will look at using a singly linked list to read in an arbitrary 
quantity of data and then allocating an array to copy it to for normal numeric 
calculations at run time:
 module link_module 
 type link 
 real :: n  
 type (link) , pointer :: next  

303
22.3 Singly Linked List: Reading in an Arbitrary Quantity of Numeric Data 
 end type link  
 end module link_module  
 program ch2202_1  
 use link_module  
 implicit none  
 type (link) , pointer :: root, current  
 integer :: I=0  
 integer :: error=0  
 integer :: io_stat_number=0  
 integer :: blank_lines=0  
 real , allocatable , dimension (:) :: x 
 allocate(root)  
 print *,' Type in some numbers'  
 read (unit = *, fmt = *, & 
iostat = io_stat_number)   root%n 
 if (io_stat_number > 0) then 
 error=error+1  
 else if (io_stat_number == –1) then 
 nullify(root%next)  
 else if (io_stat_number == -2) then 
 blank_lines=blank_lines+1  
 else 
 i=I+1 
 allocate(root%next)  
 endif 
 current => root  
 do while (associated(current%next)) 
 current => current%next  
 read (unit = * , fmt=*, & iostat = io_stat_number)  
 current%n 
 if (io_stat_number > 0) then  
error=error+1  
 else if (io_stat_number == -1) then 
 nullify(current%next)  
 else if (io_stat_number == -2) then 
 blank_lines=blank_lines+1  
 else 
  i=I+1 
 allocate(current%next)  
 endif 
 end do  
 print *,I,' items read'  
 print *,blank_lines,' blank lines'  
 print *,error,' items in error'  
 allocate(x(1:i))  

304
22 Simple Data Structuring in Fortran
 I=1 
 current => root  
 do while (associated(current%next)) 
 x(i)=current%n  
 i=I+1 
 print * , current%n  
 current => current%next  
 end do  
 print *,x  
 end program ch2202_1  
 Below is a variant on this using the NAG compiler. Note the use of a module 
(f90_iostat) and meaningful names for the status of the read:
 module link_module  
 type link 
 real :: n  
 type (link) , pointer :: next  
 end type link  
 end module link module  
 program ch2202_2  
 use link_module  
 use f90_iostat  
 type (link) , pointer :: root, current  
 integer :: I=0  
 integer :: io_stat_number=0 
 allocate(root)  
 print *,' Type in some numbers'  
 read (unit = *, fmt = *, iostat = io_stat_number) & 
 root%n  
 if (io_stat_number == ioerr_eof) then 
 nullify(root%next)  
 else if(io_stat_number == ioerr_ok) then 
 i=I+1 
 allocate(root%next)  
 endif 
 current => root  
 do while (associated(current%next)) 
 current => current%next  
  read (unit=*,fmt=*, iostat=io_stat_number) & 
 current%n  
 if (io_stat_number == ioerr_eof) then 
 nullify(current%next)  
 else if(io_stat_number == ioerr_ok) then 

305
22.4 Ragged Arrays
 i=I+1 
 allocate(current%next)  
 endif 
 end do  
 print *,I,' items read'  
 current => root  
 do while (associated(current%next)) 
 print * , current%n  
 current => current%next  
 end do  
 end program ch2202_2  
 22.4  Ragged Arrays 
 Arrays in Fortran are rectangular, even when allocatable. However if you wish to 
set up a lower triangular matrix that uses minimal memory Fortran provides a 
number of ways of doing this. The following example achieves it using allocatable 
components.
 module ragged_module  
 implicit none  
 type ragged 
 real , dimension(:) , allocatable :: ragged_row  
 end type ragged  
 end module ragged_module  
 program ch2203  
 use ragged_module  
 implicit none  
 integer :: I  
 integer , parameter :: n=3  
 type (ragged) , dimension(1:n) :: lower_diag 
 do i=1,n 
 allocate(lower_diag(i)%ragged_row(1:i))  
 print *,' type in the values for row ' , I  
 read *,lower_diag(i)%ragged_row(1:i)  
 end do  
 do i=1,n 
 print *,lower_diag(i)%ragged_row(1:i)  
 end do  
 end program ch2203  
 Within the ﬁ rst do loop we allocate a row at a time and each time we go around 
the loop the array allocated increases in size. 

306
22 Simple Data Structuring in Fortran
 22.5  Ragged Arrays and Variable Sized Data Sets 
 The previous example showed how to use allocatable components in a derived type 
to achieve ragged arrays. We extend this simple idea in the example below. In this 
example both the number of stations and the number of data items for each station 
is read in at run time and allocated accordingly. Notice that 0 is valid as the number 
of data items for a station.
 module ragged_module 
 type ragged 
 real, allocatable, dimension (:) :: rainfall  
 end type ragged  
 end module ragged_module  
 program ch2204 
 use ragged_module  
 implicit none  
 integer :: I  
 integer :: nr  
 integer, allocatable, dimension (:) :: nc  
 type (ragged), allocatable, dimension (:) :: station  
 print *,' enter number of stations'  
 read *, nr  
 allocate (station(1:nr))  
 allocate (nc(1:nr))  
 do I = 1, nr 
 print *,' enter the number of data values '  
 print *, 'for station, i 
 read *, nc(I)  
 allocate (station(i)%rainfall(1:nc(I)))  
 if (nc(I)==0) then 
 cycle 
 end if  
 print *,' Type in the values for station ', I  
 read *, station(I) %rainfall(1:nc(I))  
 end do  
 do I = 1, nr 
 print *,' Row ',i, ' Data = ', &   
 station(i)%rainfall(1:nc(i)) 
 end do  
 end program ch2204  

307
22.6 Perfectly Balanced Tree
 22.6  Perfectly Balanced Tree 
 Let us now look at a more complex example that builds a perfectly balanced tree and 
prints it out. A loose deﬁ nition of a perfectly balanced tree is one that has minimum 
depth for n nodes. More accurately a tree is perfectly balanced if for each node the 
number of nodes in its left and right subtrees differ by at most 1:
 module tree_node_module 
 implicit none  
 type tree_node 
 integer :: number  
 type (tree_node), pointer :: left, right  
 end type tree_node  
 end module tree_node_module  
 module tree_module 
 implicit none  
 contains 
 recursive function tree(n) result (answer) 
 use tree_node_module  
 implicit none  
 integer, intent (in) :: n  
 type (tree_node), pointer :: answer  
 type (tree_node), pointer :: new_node  
 integer :: l, r, x  
 if (n==0) then 
 print *,' terminate tree'  
 nullify (answer)  
 else 
 l = n/2  
 r = n - l – 1  
 print *, l, r, n  
 print *,' next item'  
 read *, x  
 allocate (new node)  
 new_node%number = x  
 print *,' left branch'  
 new_node%left => tree(l)  
 print *,' right branch'  
 new_node%right => tree(r)  
 answer => new_node  
 end if  
  print *,' function tree ends'  
 end function tree  
 end module tree_module  

308
22 Simple Data Structuring in Fortran
 module print_tree_module 
 implicit none  
 contains 
 recursive subroutine print_tree(t,h) 
 use tree_node_module  
 implicit none  
 type (tree_node), pointer :: t  
 integer :: I  
 integer :: h  
 if (associated(t)) then 
 call print_tree(t%left,h+1)  
 do I = 1, h 
 write (unit=*,fmt=10,advance='no')  
 10 format (' ')  
 end do  
 print *, t%number  
 call print_tree(t%right,h+1)  
 end if  
 end subroutine print_tree  
 end module print_tree_module  
 program ch2205  
 ! construction of a perfectly balanced tree 
 use tree_node_module  
 use tree_module  
 use print_tree_module  
 implicit none  
 type (tree_node), pointer :: root  
 integer :: n_of_items  
 print *, 'enter number of items'  
 read *, n_of_items  
 root => tree(n_of_items)  
 call print_tree(root,0)  
 end program ch2205  
 There are a number of very important concepts contained in this example and 
they include:
 The use of a module to deﬁ ne a type. For user deﬁ ned data types we must create 
• 
a module to deﬁ ne the data type if we want it to be available in more than one 
program unit. 
 The use of a function that returns a pointer as a result. 
• 
 As the function returns a pointer we must determine the allocation status before 
• 
the function terminates. This means that in the above case we use the 
nullify(result) statement. The other option is to target the pointer. 
 The use of  
• 
associated to determine if the node of the tree is terminated or 
points to another node. 

309
22.7 Date Class
 Type the program in and compile, link and run it. Note that the tree only has the 
minimal depth necessary to store all of the items. Experiment with the number of 
items and watch the tree change its depth to match the number of items. 
 22.7  Date Class 
 The following is a complete manual rewrite of Skip Noble and Alan Millers date 
module. The original worked with the built-in Fortran intrinsic data types. It has 
been rewritten to work with a derived date data type. 
 The ﬁ rst key code segment is
 type, public :: date 
 private  
 integer :: day  
 integer :: month  
 integer :: year  
 end type date  
where the date data type is public but its components are private. This means that 
access to the components must be done via subroutines and functions within the 
date_module module. 
 The next key code segment is
 public :: calendar_to_julian, & 
 date_, &  
 date_stamp, &  
 date_to_day_in_year, &  
 date_to_weekday_number, &  
 get_day, &  
 get_month, &  
 get_year, &  
 julian_to_date, &  
 julian_to_date_and_week_and_day, &  
 ndays, &  
 year_and_day_to_date  
where we explicitly make the listed subroutines and functions public, as the code 
segment from the top of the module,
 ! .. 
 ! .. Default Accessibility .. 
 private 
deﬁ nes everything to be private. 

310
22 Simple Data Structuring in Fortran
 We have to provide a user deﬁ ned constructor when the components of the 
derived type are private. This is given below:   
 This in turn calls the built-in constructor date. As the  date_ function is now an 
executable statement we cannot initialise in a declaration, i.e. the following is not 
allowed.
 type (date) :: date1_(11,2,1952)  
 We also provide three additional procedures to access the components of the 
date class:
 get_day  
 get month  
 get_year 
 This is common programming practice in object oriented and object based 
programming. 
 The program has also been through the Nag tool suite and this has helped to 
systematically lay out the code. 

311
22.7 Date Class

312
22 Simple Data Structuring in Fortran

313
22.7 Date Class

314
22 Simple Data Structuring in Fortran

315
22.7 Date Class

316
22 Simple Data Structuring in Fortran

317
22.7 Date Class

318
22 Simple Data Structuring in Fortran

319
22.7 Date Class

320
22 Simple Data Structuring in Fortran

321
22.7 Date Class

322
22 Simple Data Structuring in Fortran

323
22.7 Date Class

324
22 Simple Data Structuring in Fortran
 There are wrap problems with some of the complex arithmetic expressions. 
The version on the web site is obviously correct. 
 We also have an alternate form of array declaration in this program, which is 
given below. It is common in Fortran 77 style code:
 integer :: val(8)  
 The next major addition to this code would be a date checking routine to test the 
validity of dates. This would be called from within our constructor date_. This 
would mean that we could never have an invalid date when using the date_module. 
This is left as a programming exercise. 
 22.7.1  Notes: DST in the USA 
 The above program is no longer correct. Beginning in 2007, Daylight Saving Time 
was brought forward by 3 or 4 weeks in Spring and extended by 1 week in the Fall. 
Daylight Saving Time begins for most of the United States at 2 a.m. on the second 
Sunday of March. Time reverts to standard time at 2 a.m. on the ﬁ rst Sunday in 
November. 
 22.8  Problems 
 1.  Compile and run the examples in this chapter with your compiler. Do they all 
work with your compiler? You may have problems with the examples that use 
allocatable components. Not all compilers support this feature at this time. 
 2.  Modify the ragged array example that processes a lower triangular matrix to 
work with an upper triangular matrix. 
 3.  Using the balanced tree example as a basis and modify it to work with a character 
array rather than an integer. The routine that prints the tree will also have to be 
modiﬁ ed to reﬂ ect this. 
 4.  Modify the Date program to account for the current DST in the USA. 
 22.9  Bibliography 
 Schneider , G.M., Bruell, S.C.: Advanced Programming and Problem Solving with 
Pascal. Wiley, New York (1981)
 The book is aimed at computer science students and follows the curriculum 
guidelines laid down in Communications of the ACM, August 1985, Course 
CS2. The book is very good for the complete beginner as the examples are very 
clearly laid out and well explained. There is a coverage of data structures, abstract 

325
22.9 Bibliography
data types and their implementation, algorithms for sorting and searching, the 
principles of software development as they relate to the speciﬁ cation, design, 
implementation and veriﬁ cation of programs in an orderly and disciplined fash-
ion – their words. 
 Vowels, R.A.: Algorithms and Data Structures in F and Fortran. Unicomp, Tucson 
(1998)
 The only book currently that uses Fortran 90/95 and F. Visit the Fortran web site 
for more details. They are the publishers. 
 http://www.fortran.com/fortran/market.html 
 Wirth, N.: Algorithms + Data Structures = Programs. Prentice-Hall, Englewood 
Cliffs (1976)
 An early but illuminating book on the subject. Well worth a read. Pascal is 
used. 
 Wirth, N.: Algorithms + Data Structures. Prentice-Hall, Englewood Cliffs (1986)
 This is the Modula 2 version. Closer to Fortran than the Pascal version. 

327
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_23, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look at operator overloading in Fortran. 
 23.1  Introduction 
 In programming operator overloading can be regarded as a way of achieving poly-
morphism in that operators (e.g. +,−,*,/ or =) can have different implementations 
depending on the types of their arguments. 
 In some programming languages overloading is deﬁ ned by the language. In 
Fortran for example, the addition + operator invokes quite different code when used 
with integer, real or complex types. 
 Some languages allow the programmer to implement support for user deﬁ ned 
types. Fortran introduced support for operator and assignment overloading in the 
1990 standard. 
 23.2  Other Languages 
 Operator overloading is not new and several languages offer support for the feature 
including:
 Algol 68 – 1968 
• 
 Ada – Ada 83 
• 
 Chapter 23 
 Operator Overloading 
 All the persons in this book are real and none is ﬁ ctitious even 
in part. 
 Flann O’Brien, The Hard Life 

328
23 Operator Overloading
 C++ – First standard, 1998 
• 
 Eiffel – 1986 
• 
 C# – 2001 
• 
 Java, however does not. 
 23.3  Example 
 The following example overloads the addition operator.
 module T_Position  
 implicit none  
 type Position 
 integer :: X  
 integer :: Y  
 integer :: Z  
 end type Position  
 interface operator (+) 
 module procedure New_Position  
 end interface  
 contains  
 function New_Position(A,B)  
 type (Position) ,intent(in) :: A,B  
 type (Position) :: New_Position 
 New_Position % X = A % X + B % X  
 New_Position % Y = A % Y + B % Y  
 New_Position % Z = A % Z + B % Z  
 end function New_Position  
 end module T_Position  
 program ch2301  
 use T_Position  
 implicit none  
 type (Position) :: A,B,C 
 A%X=10  
 A%Y=10  
 A%Z=10  
 B%X=20  
 B%Y=20  
 B%Z=20  
 C=A+B 
 print *,A  
 print *,B  
 print *,C  
 end program ch2301  

329
23.4 Problem
 We have extended the meaning of the addition operator so that we can write 
simple expressions in Fortran based on it and have our new position calculated 
using a user supplied function that actually implements the calculation of the new 
position. 
 23.4  Problem 
 1.  Compile and run this example. Overload the subtraction operator as well. 

331
 Aims 
 This chapter looks at an example that implements generic programming in 
Fortran. 
 24.1  Introduction 
 Fortran 77 had several generic functions, e.g. the sine function could be called with 
arguments of type real, double precision or complex. Fortran 90 extended the idea 
so that a programmer could write their own generic functions or subroutines. For 
example we can now write a sort routine works with arguments of a variety of types, 
e.g. integer, real etc. 
 24.2  Generic Programming and Other Languages 
 Generic programming has a wider meaning in computer science and effectively is a 
style of computer programming in which an algorithm is written once, but can be 
made to work with a variety of types. 
 Chapter 24 
 Generic Programming  
 General notions are generally wrong. 
 Letter to Mr. Wortley Montegu, 28 th March 1710. 
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_24, © Springer-Verlag London Limited 2012

332
24 Generic Programming
 This style of programming is provided in several programming languages and in 
a variety of ways. 
 Languages that support generics include
 Ada 
• 
 C# 
• 
 Eiffel 
• 
 Java 
• 
 C++ supports the functionality via templates. 
 To quote the generic programming pioneer Alexander Stepanov;
 Generic programming is about abstracting and classifying algorithms and data 
• 
structures. It gets its inspiration from Knuth and not from type theory. Its goal is 
the incremental construction of systematic catalogs of useful, efﬁ cient and 
abstract algorithms and data structures. Such an undertaking is still a dream. 
and quoting Bjarne Stroustrup:
 lift algorithms and data structures from concrete examples to their most general 
• 
and abstract form. 
 It is called parametric polymorphism in the languages ML and Haskell. 
 The term parameterised type is used in the book Design Patterns: Elements of 
Reusable Object-Oriented Software. The authors, sometimes called the Gang of 
Four, or GoF, also state that 
 dynamic, highly parameterized software is harder to understand and build than 
• 
more static software. 
 Ada was one of the ﬁ rst languages to support generic programming, and the paper 
 David R. Musser and Alexander A. Stepanov: A library of generic algorithms in 
• 
Ada. Proceedings of the 1987 Annual ACM SIGAda international conference on 
Ada, pages 216–225. 
 shows how old the ideas are. 
 We'll look at a concrete example in Fortran next. 
 24.3  Generic Example 
 Simplistically, a procedure is generic if it can handle arguments of more than one 
data type. The example we will use is based on the earlier one of sorting. In the 
original example the program worked with real data. In the example below we have 
extended the program to handle both integer and real data. 
 What is not obvious from our use of the internal procedures is that there will be 
speciﬁ c procedures to handle each data type, i.e., if a function can take integer, real 

333
24.3 Generic Example
and complex arguments then there will be one implementation of that function for 
each data type, i.e., three separate functions. 
 In the example below we add the ability to handle integer data. This means that 
where we had:
 read data 
• 
 sort data 
• 
 print data 
• 
and one subroutine to implement the above we now have two subroutines to do each 
of the above, one to handle integers and one to handle reals: 

334
24 Generic Programming

335
24.3 Generic Example

336
24 Generic Programming

337
24.3 Generic Example

338
24 Generic Programming
 The key code is given below for each module:
 interface read data  
 module procedure read integer  
 module procedure read real  
 end interface read data  
 interface sort_data 
 module procedure sort_integer  
 module procedure sort_real  
 end interface sort data  
 interface print_data 
 module procedure print_integer  
 module procedure print_real  
 end interface print_data  

339
24.3 Generic Example
 The interface block name is used in the calling routine and the appropriate 
module procedure will be called, based on a signature match of the actual and 
dummy parameters. 
 This is quite useful, but not as useful as the functionality provided in other lan-
guages. Have a look at the following two examples which show the code for a 
generic quicksort in C++ and C#. 
 24.3.1  Generic Quicksort in C++ 
 template <class Type>  
 void swap(Type array[],int i, int j)  
 { 
 Type tmp=array[i] ;  
 array[i]=array[ j ] ;  
 array[j]=tmp;  
 } 
 template <class Type>  
 void quicksort( Type array[], int l, int r)  
 { 
 int i=l;  
 int j=r;  
 Type v=array[int((l + r) /2) ] ;  
 for (;;)  
 {
 while (array[i] < v) i=i + 1;  
 while (v < array[j]) j =j — 1;  
 if (i<=j) { swap(array, i, j) ; i=i + 1 ; j=j-1; }  
 if (i>j) goto ended ;  
 } 
 ended :  ; 
 if (l<j) quicksort(array,l, j);  
 if (i<r) quicksort(array,i, r) ;  
 } 
 template <class Type>  
 void print(Type array[],int size)  
 { 
 cout << " [ " ;  
 for (int ix=0;ix<size; ++ix)  
 cout << array [ix] << " ";  
 cout << "] \n";  
 } 
 #include <iostream>  
 using namespace std;  
  int main()  

340
24 Generic Programming
 { 
 double da[]={1.9,8.2,3.7,6.4,5.5,1.8,9.2,3.6,7.4,5.5}
; 
 int ia[]={1,10,2,9,3,8,4,7,6,5};  
 int size=sizeof(da)/sizeof(double);  
 cout << " Quicksort of double array is \n";  
 quicksort(da,0,size-1);  
 print(da,size);  
 size=sizeof(ia)/sizeof(int);  
 cout << " Quicksort of integer array is \n";  
 quicksort(ia,0,size-1);  
 print(ia,size);  
 return(0);  
 } 
 24.3.2  Generic Quicksort in C#  

341
24.4 Problem
 24.3.3  Summary 
 Note in both the C++ and C# case we only have one version of the algorithm. 
Fortran still has a way to go! Maybe Fortran 2020? 
 24.4  Problem 
 1.  Write a generic swap routine, that swaps two rank 1 integer arrays and two rank 
1 real arrays. 

342
24 Generic Programming
 24.5  Bibliography 
 This site is a collection of Alex Stepanov’s papers, class notes, and source code, 
covering generic programming and other topics. 
 http://www.stepanovpapers.com/ 
 C++ 
 C++ Templates: The Complete Guide, David Vandevoorde, Nicolai M Josuttis, 
2003 Addison-Wesley. ISBN 0–201–73484–2 
 C# 
 Visit the following site 
 http://msdn.microsoft.com/en-us/library/512aeb7t(v=vs . 80). aspx for a very good 
coverage of generics and C#. 

343
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_25, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look at several mathematical examples in Fortran.
 Using linked lists for sparse matrix problems. 
• 
 The solution of a set of ordinary differential equations using the Runge–Kutta–
• 
Merson method, with the use of a procedure as a parameter, and the use of work 
arrays. 
 Diagonal extraction of a matrix. 
• 
 The solution of linear equations using Gaussian elimination 
• 
 An elemental e**x function 
• 
 25.1 Introduction 
 This chapter looks at a small number of mathematical examples in Fortran. 
 Chapter 25 
 Mathematical Examples  
 You look at science (or at least talk of it) as some sort of 
demoralising invention of man, something apart from real life, 
and which must be cautiously guarded and kept separate from 
everyday existence. But science and everyday life cannot and 
should not be separated. Science, for me, gives a partial 
explanation for life. In so far as it goes, it is based on fact, 
experience and experiment. 
 Rosalind Franklin. 

344
25 Mathematical Examples
 25.2  Using Linked Lists for Sparse Matrix Problems 
 A matrix is said to be sparse if many of its elements are zero. Mathematical models 
in areas such as management science, power systems analysis, circuit theory and 
structural analysis consist of very large sparse systems of linear equations. It is not 
possible to solve these systems with classical methods because the sparsity would 
be lost and the eventual system would become too large to solve. Many of these 
systems consist of tens of thousands, hundreds of thousands and millions of equations. 
As computer systems become ever more powerful with massive amounts of mem-
ory the solution of even larger problems becomes feasible. 
 Direct Methods for Sparse Matrices, by Duff I.S., Erismon A.M. and Reid J.K., 
looks at direct methods for solving sparse systems of linear equations. 
 Sparse matrix techniques lend themselves to the use of dynamic data structures 
in Fortran. Only the nonzero elements of a sparse matrix need be stored, together 
with their positions in the matrix. Other information also needs to be stored so that 
row or column manipulation can be performed without repeated scanning of a 
potentially very large data structure. Sparse methods may involve introducing some 
new nonzero elements, and a way is needed of inserting them into the data structure. 
This is where the Fortran pointer construct can be used. The sparse matrix can be 
implemented using a linked list to which entries can be easily added and from which 
they can be easily deleted. 
 As a simple introduction, consider the storage of sparse vectors. What we learn 
here can easily be applied to sparse matrices, which can be thought of as sets of 
sparse vectors. 
 25.2.1  Inner Product of Two Sparse Vectors 
 Assume that we have two sparse vectors  x and  y , for example:
 
⎡⎤
⎡⎤
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
=
=
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎢⎥
⎣⎦
⎣⎦
3
0
0
1
5
3
0
0
0
2
4
1
x
y
 
and we wish to calculate the inner product  
=
≡∑
1
n
T
i
i
i
x y
x
y   . There are a number 
of approaches to doing this and the one we use in the program below stores 

345
25.2 Using Linked Lists for Sparse Matrix Problems
them as two linked lists. Only the nonzero elements are stored (together with 
their indices): 
 Here is the program.
 program ch2501  
 ! this program reads the non-zero elements of  
 ! two sparse vectors x and y together with their  
 ! indices, and stores them in two linked lists.  
 ! using these linked lists it then calculates  
 ! and prints out the inner product.  
 ! it also prints the values.  
 ! updated 21/3/00 to initialise pointers to  
 ! be disassociated using intrinsic function null  
 ! plus minor updates  
 implicit none  
 character (len=30) :: ﬁ lename  
 type sparse_vector 
 integer :: index  
 real :: value  
 type (sparse_vector), pointer :: next => null()  
 end type sparse_vector  
 type (sparse_vector), pointer :: &  
 root_x, current_x,root_y, current_y  
 real :: inner_prod = 0.0  
 integer :: io_status  
 ! read non-zero elements of vector x together  
 ! with indices into a linked list 
 print *, 'input ﬁ le name for vector x'  
 read '(a)', ﬁ lename  
 open (unit=1, ﬁ le=ﬁ lename &  
 ,status='old',iostat=io_status) 
 if (io_status/=0) then 
 print *, 'error opening ﬁ le ', ﬁ lename  
 stop 
 end if  
 allocate (root_x)  
 read (unit=1,fmt=*,iostat=io_status)&   
 root_x%value, root_x%index 
 if (io_status/=0) then 

346
25 Mathematical Examples
 print *, ' error reading from ﬁ le ', &  
 ﬁ lename, ' or ﬁ le empty'  
 stop 
 end if  
 ! read data for vector x from ﬁ le until eof 
 current_x => root_x  
 allocate (current_x%next)  
 do while (associated(current_x%next)) 
 current_x => current_x%next  
 read (unit=1,fmt=*,iostat=io_status) &  
 current_x%value, current_x%index 
 if (io_status==0) then 
 allocate (current_x%next)  
 cycle 
 else if (io_status>0) then  
 ! error on reading 
 print *, 'error occurred when reading from 
', &
ﬁ lename  
 stop 
 else 
 ! end of ﬁ le 
 nullify (current_x%next)  
 end if  
 end do  
 close (unit=1)  
 ! read non-zero elements of vector y together  
 ! with indices into a linked list 
 print *, 'input ﬁ le name for vector y'  
 read '(a)', ﬁ lename  
 open (unit=1,ﬁ le=ﬁ lename, &  
 status='old',iostat=io_status) 
 if (io_status/=0) then 
 print *, 'error opening ﬁ le ', ﬁ lename  
 stop 
 end if  
 allocate (root_y)  
 read (unit=1,fmt=*,iostat=io_status) &   
 root_y%value,root_y%index 
 if (io_status/=0) then 
 print *, ' error when reading from ', &
ﬁ lename, 'or ﬁ le empty'
 stop 
 end if  
 ! read data for vector y from ﬁ le until eof 

347
25.2 Using Linked Lists for Sparse Matrix Problems
 current_y => root_y  
 allocate (current_y%next)  
 do while (associated(current_y%next)) 
 current_y => current_y%next  
 read (unit=1,fmt=*,iostat=io_status) &  
 current_y%value, current_y%index 
 if (io_status==0) then
 allocate (current_y%next)  
 cycle 
 else if (io_status>0) then  
 ! error on reading 
 print *, 'error occurred when reading from' &
, ﬁ lename  
 stop 
 else 
 ! end of ﬁ le 
 nullify (current_y%next)  
 end if  
 end do  
 ! data has now been read and stored in 2 linked lists  
 ! start at the beginning of x linked list and  
 ! y linked list and compare indices  
 ! in order to perform inner product 
 current_x => root_x  
 current_y => root_y  
 do while (associated(current_x%next)) 
 do while   (associated(current_y%next) &
.and.current_y%index<current_x%index)  
 ! move through 2nd list 
 current_y => current_y%next  
 end do  
 ! at this point current_y%index >= current_x%index  
 ! or 2nd list is exhausted 
 if (current_y%index==current_x%index) then
 inner_prod = inner_prod + &
current_x%value*current_y%value  
 end if   
 current_x' => current_x%next  
 end do  
 ! print out inner product 
 print *, 'inner product of two sparse vectors is :'&
, inner_prod  
 ! print non-zero values of vector x and indices 
 print *, 'non-zero values of vector x and indices:'  
 current_x => root_x  

348
25 Mathematical Examples
 do while (associated(current_x%next)) 
 print *, current_x%value, current_x%index  
 current_x => current_x%next  
 end do  
 ! print non-zero values of vector y and indices 
 print *, 'non-zero values of vector y and indices:'  
 current_y => root_y  
 do while (associated(current_y%next)) 
 print *, current_y%value, current_y%index  
 current_y => current_y%next  
 end do  
 end program ch2501  
 25.3  Solving a System of First-Order Ordinary Differential 
Equations Using Runge–Kutta–Merson 
 Simulation and mathematical modelling of a wide range of physical processes often 
leads to a system of ordinary differential equations to be solved. Such equations also 
occur when approximate techniques are applied to more complex problems. We will 
restrict ourselves to a class of ordinary differential equations called initial value 
problems. These are systems for which all conditions are given at the same value of 
the independent variable. We will further restrict ourselves to ﬁ rst-order initial value 
problems of the form:
 
=
=
…
=
1
1
2
2
( , )
( , )
( , )
n
n
dy
f y t
dt
dy
f
y t
dt
dy
f
y t
dt
 
or
 
 = _
_
_
( , )
y
f y t   
(25.1) 
with initial conditions
 
(0)
y t
y
( 0) =
_
_
 
where

349
25.3 Solving a System of First-Order Ordinary Differential Equations…
 
1
1
1
0
0
0
( )
( )
n
n
n
y
f
y t
y
f
y
y
f
y t
⎛
⎞
⎛
⎞
⎛
⎞
⎜
⎟
⎜
⎟
⎜
⎟
=
=
=
⎜
⎟
⎜
⎟
⎜
⎟
⎜
⎟
⎜
⎟
⎜
⎟
⎝
⎠
⎝
⎠
⎝
⎠



 
if we have a system of ordinary differential equations of higher order then they can 
be reformulated to a system of order one. See the NAG library documentation for 
solving ordinary differential equations. 
 One well-known class of methods for solving initial value ordinary differential 
equations is Runge–Kutta. In this example we have coded the Runge–Kutta–Merson 
algorithm, which is a fourth-order method and solves ( 25.1 ) from a point t  = A to a 
point t  = B. 
 It starts with a step length  h = ( B −  A )/100 and includes a local error control 
strategy such that the solution at t + h is accepted if:
 error estimate
user defined tolerance
<
  
 If this isn’t satisﬁ ed the step length h is halved and the solution attempt is repeated 
until the above is satisﬁ ed or the step length is too small and the problem is left 
unsolved. If the error criterion is satisﬁ ed the algorithm progresses with a suitable 
step length solving the equations at intermediate points until the end point B is 
reached. For a full discussion of the algorithm and the error control mechanism used 
see Numerical Methods in Practice by Tim Hopkins and Chris Phillips: 
 A main program to use this subroutine is of the form:

350
25 Mathematical Examples

351
25.3 Solving a System of First-Order Ordinary Differential Equations…

352
25 Mathematical Examples

353
25.3 Solving a System of First-Order Ordinary Differential Equations…
 program ch2502  
 use precision_module  
 use rkm_module  
 use fun1_module  
 implicit none  
 real(long),dimension(:),allocatable::y  
 real(long)::a,b,tol  
 integer::n,ifail,all_stat  
 ! 
 print *,'input no of equations'  
 read*,n  
 ! 
 ! allocate space for y - checking to see that it  
 ! allocates properly  
 ! 
 allocate(y(1:n),stat=all_stat)  
 if(all_stat /= 0) then 
 print * , ' not enough memory'  
 print * , ' array y is not allocated'  
 stop 
 endif 
 print *,' input start and end of interval over'  
 print *,' which equations to be solved'  
 read *,a,b  
 print *,"input initial conditions"  
 read *,y(1:n)  
 print *,'input tolerance'  
 read *,tol  
 print 100,a  
 100 format('at t= ',f5.2,' initial conditions are :')  
 print 200,y(1:n)  
 200 format(4(f5.2,2x))  
 call runge_kutta_merson(y,fun1,ifail,n,a,b,tol)  
 if(ifail /= 0) then 
 print *,'integration stopped with ifail = ',ifail   
 else 
 print 300,b  
 300 format('at t= ',f5.2,' solution is:')  
 print 200,y(1:n)  
 endif 
 end program ch2502  

354
25 Mathematical Examples
 Consider trying to solve the following system of ﬁ rst-order ordinary differential 
equations:
 
=
−
=
−
= −
1
3
3
2
2
2
3
3
2
2
tan
0.032tan
0.02
cos
0.032



y
y
y
y
y
y
y
y
y
 
over an interval  t = 0.0 to  t = 8.0 with initial conditions
  
=
=
=
1
0
2
0.5
3
 
 
5  
y
y
y
π  
 The user supplied subroutine, packaged as a module procedure, is:
 module fun1_module  
 implicit none  
 contains  
 subroutine fun1(t,y,f,n) 
 use precision_module  
 implicit none  
 real(long),intent(in),dimension(:)::y  
 real(long),intent(out),dimension(:)::f  
 real(long),intent(in)::t  
 integer,intent(in)::n  
 ! 
 f(1)=tan(y(3))  
 f(2)=-0.032_long*f(1)/y(2)-0.02_long*y(2)/cos(y(3))  
 f(3)=-0.032_long/(y(2)*y(2))  
 end subroutine fun1  
 end module fun1_module  
 25.3.1  Note: Alternative Form of the Allocate Statement 
 In the main program Odes we have deﬁ ned Y to be a deferred-shape array, allocating 
it space after the variable N is read in. In order to make sure that enough memory is 
available to allocate space to array Y the allocate statement is used as follows: 
 allocate(Y(1:N),STAT = All_stat) 
 if the allocation is successful variable All_stat returns zero; otherwise it is given a 
processor dependent positive value. We have included code to check for this and 
the program stops if All_stat is not zero. 

355
25.3 Solving a System of First-Order Ordinary Differential Equations…
 25.3.2  Note: Automatic Arrays 
 The subroutine  runge_kutta_merson needs a number of local rank 1 arrays 
S1, S2, S3, S4 and S5 for workspace, their shape and size being the same as the 
dummy argument Y. Fortran supplies automatic arrays for this purpose and can be 
declared as
 real(Long), dimension (1:SIZE(Y)) :: S1, S2, S3, S4, S5  
 The size of automatic arrays can depend on the size of actual arrays: in our 
example they are the same shape and size as the dummy array Y, or some other 
dummy arguments. Automatic arrays are created when the procedure is called 
and destroyed when control passes back to the calling program unit. They may 
have different shapes and sizes with different calls to the procedure, and because of 
this automatic arrays cannot be saved or initialised. 
 A word of warning should be given at this point. If there isn’t enough memory 
available when an automatic array needs to be created problems will occur. Unlike 
allocatable arrays there is no way of testing to see if an automatic array has been 
created successfully. The general feeling is that even though they are nice, automatic 
arrays should be used with care and perhaps shouldn’t be used in production code! 
 25.3.3  Note: Subroutine as a Dummy Procedure Argument 
 In order to make the use of subroutine  runge_kutta_merson  as general as 
possible the user can choose the name of the subroutine in which the actual system 
of equations to be solved is deﬁ ned. In this case we have chosen  fun1 as the name 
of the subroutine, which is then used as an actual argument when calling  runge_
kutta_merson from the main program e.g.
 call runge_kutta_merson(y,fun1,ifail,n,a,b,tol) 
 An explicit interface for subroutine  fun1 is provided by it being contained in a 
module. 
 The equivalent dummy subroutine argument is  fun and this needs an explicit 
interface in the subroutine  runge_kutta_merson . 
 25.3.4  Note: Compilation When Using Modules 
 When compiling this program and the modules they must be done in the correct order:
 precision_module 
• 
 rkm_module 
• 
 fun1_module 
• 
and then
 the main program. 
• 

356
25 Mathematical Examples
 25.4  A Subroutine to Extract the Diagonal Elements 
of a Matrix 
 A common task mathematically is to extract the diagonal elements of a matrix. For 
example if
 
21
6
7
9
3
2
4
1
8
 
 
 
 
 
 
 
 
 
A
⎛
⎞
⎜
⎟
= ⎜
⎟
⎜
⎟
⎝
⎠ 
the diagonal elements are ( 21, 3, 8 ). 
 This can be thought of as extracting an array section, but the intrinsic function 
 pack is needed. In its simplest form  pack (array,vector) packs an array, 
Array, into a rank 1 array, Vector, according to Array’s array element order. 
 Below is a complete program to demonstrate this:
 module md_module  
 implicit none  
 contains  
 subroutine matrix_diagonal(a,diag,n)  
 implicit none  
 real, intent (in), dimension (:,:) :: a  
 real, intent (out), dimension (:) :: diag  
 integer, intent (in) :: n  
 real, dimension(1:size(a,1)*size(a,1)):: temp  
 ! 
 ! subroutine to extract the diagonal  
 ! elements of an n*n matrix A  
 ! 
 temp = pack(a, .true.)  
 diag = temp(1:n*n:n+1)  
 end subroutine matrix_diagonal  
 end module md_module  
 program ch2503  
 ! program reads the n * n matrix from a ﬁ le 
 use md_module  
 implicit none  
 integer :: I, n  
 real, allocatable, dimension (:,:) :: a  
 real, allocatable, dimension (:) :: adiag  
 character (len=20) :: ﬁ lename 
 print *, 'input name of data ﬁ le' 
 read '(a)', ﬁ lename  

357
25.5 The Solution of Linear Equations Using Gaussian Elimination
 open (unit=1,ﬁ le=ﬁ lename)  
 read (1,*) n  
 allocate (a(1:n,1:n),adiag(1:n))  
 do I = 1, n 
 read (1,*) a(i,1:n)  
 end do  
 call matrix_diagonal(a,adiag,n)  
 print *, ' diagonal elements of a are:'  
 print *, adiag  
 end program ch2503  
 25.5  The Solution of Linear Equations Using Gaussian 
Elimination 
 At this stage we have introduced many of the concepts needed to write numerical 
code, and have included a popular algorithm, Gaussian elimination, together with a 
main program which uses it and a module to bring together many of the features 
covered so far. 
 Finding the solution of a system of linear equations is very common in scientiﬁ c 
and engineering problems, either as a direct physical problem or indirectly, for 
example, as the result of using ﬁ nite difference methods to solve a partial differen-
tial equation. We will restrict ourselves to the case where the number of equations 
and the number of unknowns are the same. The problem can be deﬁ ned as:
 
 
+
+…+
=
+
+…+
=
…
…
…
…
= …
+
+…+
=
11
1
12
2
1
1
12
2
22
2
2
2
1
1
2
2
n
n
n
n
n
n
nn
n
n
a x
a x
a x
b
a x
a x
a x
b
a x
a x
a x
b
  
(25.1)  
or
 
11
12
1
1
1
21
22
2
2
2
1
2
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
n
n
n
n
nn
n
n
a
a
a
x
b
a
a
a
x
b
a
a
a
x
b
…
⎛
⎞⎛
⎞
⎛
⎞
⎜
⎟⎜
⎟
⎜
⎟
…
⎜
⎟⎜
⎟
⎜
⎟
=
⎜
⎟⎜
⎟
⎜
⎟
…
…
…
…
…
…
⎜
⎟⎜
⎟
⎜
⎟
⎜
⎟⎜
⎟
⎜
⎟
…
⎝
⎠⎝
⎠
⎝
⎠ 
 which can be written as: 
 
 
=
A x
b   
(25.2)  
where A is the n x n coefﬁ cient matrix, b is the right-hand-side vector and x is the 
vector of unknowns. We will also restrict ourselves to the case where A is a general 
real matrix. 

358
25 Mathematical Examples
 Note that there is a unique solution to ( 25.2 ) if the inverse, A −1 , of the coefﬁ cient 
matrix A, exists. However, the system should never be solved by ﬁ nding A −1 and 
then solving  A −1  b =  x because of the problems of rounding error and the computa-
tional costs. 
 A well-known method for solving ( 25.2 ) is Gaussian elimination, where 
multiples of equations are subtracted from others so that the coefﬁ cients below the 
diagonal become zero, producing a system of the form:
 
*
*
*
*
1
11
12
1
1
*
*
*
2
22
2
2
*
*
0
0
0
0
n
n
n
nn
n
x
a
a
a
b
x
a
a
b
x
a
b
⎛
⎞
⎛
⎞
…
⎛
⎞
⎜
⎟
⎜
⎟
⎜
⎟
…
⎜
⎟
⎜
⎟
⎜
⎟=
⎜
⎟
⎜
⎟
⎜
⎟
…
…
…
…
…
…
⎜
⎟
⎜
⎟
⎜
⎟
⎜
⎟
⎜
⎟
⎜
⎟
⎝
⎠
⎝
⎠
⎝
⎠ 
where A has been transformed into an upper triangular matrix. By a process of 
backward substitution the values of x drop out. 
 The subroutine  gaussian_elimination  implements the Gaussian elimi-
nation algorithm with partial pivoting, which ensure that the multipliers are less 
than 1 in magnitude, by interchanging rows if necessary. This is to try and prevent 
the buildup of errors. 
 This implementation is based on two LINPACK routines SGEFA and SGESL 
and a Fortran 77 subroutine written by Tim Hopkins and Chris Phillips and found in 
their book Numerical Methods in Practice. 
 The matrix A and vector B are passed to the subroutine  Gaussian_
Elimination and on exit both A and B are overwritten. Mathematically Gaussian 
elimination is described as working on rows, and using partial pivoting row inter-
changes may be necessary. Due to Fortran’s row element ordering, to implement 
this algorithm efﬁ ciently it works on columns rather than rows by interchanging 
elements within a column if necessary. 

359
25.5 The Solution of Linear Equations Using Gaussian Elimination

360
25 Mathematical Examples

361
25.5 The Solution of Linear Equations Using Gaussian Elimination
 25.5.1  Notes 
 25.5.1.1 Module for Kind Type 
 A module,  precision_module , has been used to deﬁ ne a kind type parameter, 
 Long , to specify the ﬂ oating point precision to which we wish to work. This 
module is then used by the main program and the subroutine, and the kind type 
parameter  Long is used with all the real type deﬁ nitions and with any constants, e.g.,
 real(Long), parameter :: Eps=1.E-13_Long  

362
25 Mathematical Examples
 25.5.1.2 Deferred-Shape Arrays 
 In the main program matrix A and vectors B and X are declared as deferred-shape 
arrays, by specifying their rank only and using the allocatable attribute. Their 
shape is determined at run time when the variable N is read in and then the 
statement
 allocate(A(1:N,1:N), B(1:N), X(1:N))  
is used. 
 25.5.1.3 Intrinsic Functions  maxval and  maxloc 
 In the context of subroutine  gaussian_elimination we have used:
 maxval ( maxloc (abs ( a ( k:n,k ) ) ) )  +  k – 1 
 Breaking this down,
 maxloc ( abs ( a (k:n,k) ) )  
takes the rank 1 array
 
 
+
…
(|
( ,
) |,|
(
1,
) |,
|
( ,
) |)
A K K
A K
K
A N K
  
(25.3) 
where |  A ( K , K ) |  = ABS(A(K,K)) and of length N− K + 1. It returns the position of 
the largest element as a rank 1 array of size one, e.g., (L) 
 Applying  maxval to this rank 1 array (L) returns L as a scalar, L being the posi-
tion of the largest element of array ( 25.3 ). 
 What we actually want is the position of the largest element of ( 25.3 ), but in the 
Kth column of matrix A. We therefore have to add K-1 to L to give the actual 
position in column K of A. 
 25.6  Allocatable Function Results 
 A function may return an array, and in this example the array allocation takes place 
in the function.   

363
25.6 Allocatable Function Results
 This facility was introduced in Fortran 95. 

364
25 Mathematical Examples
 25.7  Elemental e**x Function 
 The following is an elemental version of the etox function covered in an earlier 
chapter.
 module etox_module  
 implicit none  
 contains 
 elemental real function etox(x)  
 implicit none  
 real , intent(in) :: x  
 real :: term  
 integer :: nterm  
 real , parameter :: tol =1.0e-6 
 etox=1.0  
 term=1.0  
 nterm=0  
 do 
 nterm=nterm+1  
 term=(x/nterm)*term  
 etox=etox+term  
 if (term<=tol) exit  
 end do  
 end function etox  
 end module etox_module  
 program ch2506  
 use etox_module  
 implicit none  
 integer :: I  
 real :: x  
 real , dimension(10) :: y 
 x=1.0 
 do I=1, 10 
 y(i)=I  
 end do  
 print *,y  
 x=etox(x)  
 print *,x  
 y=etox(y)  
  print *,y  
 end program ch2506  
 Elemental functions require the use of explicit interfaces, and we have therefore 
used modules to achieve this. 

365
25.9 Bibliography
 25.8  Problems 
 1.  Compile and run the sparse matrix example with the data provided. 
 2.  Compile and run the Runge Kutta Merson example with the data provided. 
 3.  Compile and run the Gaussian Elimination example with the following data. 
 
33
16
72
24
10
57
8
4
17
359
281
85
A
b
⎛
⎞
⎜
⎟
= −
−
−
⎜
⎟
⎜
⎟
−
−
−
⎝
⎠
−
⎛
⎞
⎜
⎟
= ⎜
⎟
⎜
⎟
⎝
⎠
 
and the solution is
 
1
2
5
x
⎛
⎞
⎜
⎟
= −
⎜
⎟
⎜
⎟
−
⎝
⎠ 
 25.9  Bibliography 
 Duff , I.S., Erismon, A.M., Reid, J.K.: Direct Methods for Sparse Matrices. Oxford 
Science Publications, Oxford (1986)
 Authoritative coverage of this area. Relatively old, but well regarded. Code seg-
• 
ments and examples are a mixture of Fortran 77 and Algol 60 (which of course 
do not support pointers) and therefore the implementation of linked lists is done 
using the existing features of these languages. The onus is on the programmer to 
correctly implement linked lists using ﬁ xed size arrays rather than using the fea-
tures provided by pointers in a language. It is remarkable how elegant these 
solutions are, given the lack of dynamic data structures in these two languages. 
 Hopkins, T., Phillips, C.: Numerical Methods in Practice, Using the NAG Library. 
Addison-Wesley, Wokingham/Reading (1988)
 Good adjunct to the NAG library documentation for the less numerate user. 
• 
 Schneider, G.M., Bruell, S.C.: Advanced Programming and Problem Solving with 
Pascal. Wiley, New York (1981)
 The book is aimed at computer science students and follows the curriculum 
• 
guidelines laid down in Communications of the ACM, August 1985, Course 
CS2. The book is very good for the complete beginner as the examples are very 

366
25 Mathematical Examples
clearly laid out and well explained. There is a coverage of data structures, abstract 
data types and their implementation, algorithms for sorting and searching, the 
principles of software development as they relate to the speciﬁ cation, design, 
implementation and veriﬁ cation of programs in an orderly and disciplined fash-
ion — their words. 
 Vowels, R.A.: Algorithms and Data Structures in F and Fortran. Unicomp, Tucson 
(1998)
 The only book currently that uses Fortran 90/95 and F. Visit the Fortran web site 
• 
for more details. They are the publishers. 
 
• http://www.fortran.com/fortran/market.html 
 Wirth, N.: Algorithms + Data Structures  = Programs. Prentice-Hall, Englewood 
Cliffs (1976)
 An early but illuminating book on the subject. Well worth a read. Pascal is 
• 
used. 
 Wirth, N.: Algorithms + Data Structures. Prentice-Hall, Englewood Cliffs (1986)
 This is the Modula 2 version. Closer to Fortran than the Pascal version. 
• 
 Commercial numerical libraries 
 NAG. Visit their web site for up to date details of their products:
 
• http://www.nag.co.uk/ 
 Rogue Wave Software. Visit their web site for details of their products:
 
• http://www.roguewave.com/ 

367
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_26, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look at object oriented programming in Fortran. 
 26.1  Introduction 
 This chapter looks at object oriented programming in Fortran. The chapter on pro-
gramming languages covers the topic in a broader context. 
 26.2  Brief Review of the History of Object Oriented 
Programming 
 Object oriented programming is not new. One of the ﬁ rst languages to offer support 
was Simula 67, a language designed for discrete event simulation by Ole Johan 
Dahl, Bjorn Myhrhaug and Kristen Nygaard whilst working at the Norwegian 
Computing Centre in Oslo in the 1960s. 
 One of the next major developments was in the 1970s at the Xerox Palo Alto 
Research Centre Learning Research Group who began working on a vision of the 
ways different people might effectively use computing power. One of the outcomes 
of their work was the Smalltalk 80 system. Objects are at the core of the Smalltalk 
80 system. 
 Chapter 26 
 Object Oriented Programming  
 “For Madmen only” 
 Hermann Hesse, Steppenwolf 

368
26 Object Oriented Programming
 The 1980s and 1990s saw a number of object oriented programming languages 
emerge. They include
 Eiffel. Bertrand Meyer, Eiffel Software. 
• 
 C++ from C with classes. Bjarne Stroustrup at Bell Labs. 
• 
 Oberon 2. Niklaus Wirth at ETH in Zurich. 
• 
 Java. James Gosling, originally Sun, now Oracle. 
• 
 C# is a recent Microsoft addition to the list. 
 Object-oriented programming is effectively a programming methodology or 
paradigm using objects (data structures made up of data and methods). We will use 
the concept of a shape class in our explanation and examples. The Simula Begin 
book starts with shapes, and it is often used in introductions to object oriented pro-
gramming in other languages. 
 Some of the key concepts are
 encapsulation or information hiding – the implementation of the data is hidden 
• 
inside an object and clients or users of the data only have access to an abstract 
view of it. Methods are used to access and manipulate the data. For example a 
shape class may have an x and y position, and methods exist to get and set the 
positions and draw and move the shape. 
 data abstraction – if we have an abstract shape data type we can create multiple 
• 
variables of that type. 
 inheritance – an existing abstract data type can be extended. It will inherit the 
• 
data and methods from the base type and add additional data and methods. A key 
to inheritance is that the extended type is compatible with the base type. Anything 
that works with objects or variables of the base type also work with objects of the 
extended type. A circle would have a radius in addition to an x and y position, a 
rectangle would have a width and height. 
 dynamic binding – if we have a base shape class and derive circles and rectangles 
• 
from it dynamic binding ensures that the correct method to calculate the area is 
called at run time. 
 polymorphism- variables can therefore be polymorphic. Using the shape exam-
• 
ple we can therefore create an array of shapes, one may be a shape, one may be 
a circle and another may be a rectangle. 
 Extensible abstract data types with dynamically bound methods are often called 
classes. This is the terminology we will use in what follows. 
 26.3  Background Technical Material 
 We need to look more formally at a number of concepts so that we can actually do 
object oriented programming in Fortran. The following sections cover some of the 
introductory material we need, and are taken from the standard. 

369
26.4 Type Declaration Statements
 26.4  Type Declaration Statements 
 Every data object has a type and rank and may have type parameters and other attri-
butes that determine the uses of the object. Collectively, these properties are the 
attributes of the object. The type of a named data object is normally speciﬁ ed explic-
itly in a type declaration statement. All of its attributes may be included in a type 
declaration statement or may be speciﬁ ed individually in separate speciﬁ cation 
statements. 
 26.4.1  TYPE 
 A TYPE type speciﬁ er is used to declare entities of a derived type. Section 1.3.147 
of the standard deﬁ nes it as follows:
 type: data type – named category of data characterized by a set of values, a syn-
• 
tax for denoting these values, and a set of operations that interpret and manipu-
late the values (4.1) 
 A scalar entity of derived type is a structure. 
 26.4.2  CLASS 
 A polymorphic entity is a data entity that is able to be of differing types during pro-
gram execution. The type of a data entity at a particular point during execution of a 
program is its dynamic type. The declared type of a data entity is the type that it is 
declared to have, either explicitly or implicitly. 
 A CLASS type speciﬁ er is used to declare polymorphic objects. The declared 
type of a polymorphic object is the speciﬁ ed type if the CLASS type speciﬁ er con-
tains a type name. 
 26.4.3  Attributes 
 The additional attributes that may appear in the attribute speciﬁ cation of a type 
declaration statement further specify the nature of the entities being declared or 
specify restrictions on their use in the program. 
 26.4.3.1 Accessibility Attribute 
 The accessibility attribute speciﬁ es the accessibility of an entity via a particular 
identiﬁ er. 

370
26 Object Oriented Programming
 The following is taken from Sect. 5.3.2 of the Fortran 2008 standard.
 access-spec is PUBLIC or PRIVATE 
• 
 An access-spec shall appear only in the speciﬁ cation-part of a module. 
• 
 Identiﬁ ers that are speciﬁ ed in a module or accessible in that module by use associa-
tion have either the PUBLIC or PRIVATE attribute. Identiﬁ ers for which an access-spec 
is not explicitly speciﬁ ed in that module have the default accessibility attribute for that 
module. The default accessibility attribute for a module is PUBLIC unless it has been 
changed by a PRIVATE statement. Only identiﬁ ers that have the PUBLIC attribute in 
that module are available to be accessed from that module by use association.  
 26.4.4  Passed Object Dummy Arguments 
 Section 4.5.4.5 of the Fortran 2008 standard introduces the concept of passed object 
dummy argument. Here is an extract from the standard:
 A passed-object dummy argument is a distinguished dummy argument of a pro-
• 
cedure pointer component or type-bound procedure. It affects procedure overrid-
ing (4.5.7.3) and argument association (12.5.2.2). 
 If NOPASS is speciﬁ ed, the procedure pointer component or type-bound proce-
• 
dure has no passed-object dummy argument. 
 If neither PASS nor NOPASS is speciﬁ ed or PASS is speciﬁ ed without arg-name, 
• 
the ﬁ rst dummy argument of a procedure pointer component or type-bound pro-
cedure is its passed-object dummy argument. 
 If PASS (arg-name) is speciﬁ ed, the dummy argument named arg-name is the 
• 
passed-object dummy argument of the procedure pointer component or named 
type-bound procedure. 
 C456 The passed-object dummy argument shall be a scalar, nonpointer, nonal-
• 
locatable dummy data object with the same declared type as the type being 
deﬁ ned; all of its length type parameters shall be assumed; it shall be polymor-
phic (4.3.1.3) if and only if the type being deﬁ ned is extensible (4.5.7). It shall 
not have the VALUE attribute. 
 NOTE 4.32: If a procedure is bound to several types as a type-bound procedure, 
• 
different dummy arguments might be the passed-object dummy argument in dif-
ferent contexts. 
 The key here is that we are going to use the PASS and NOPASS attributes with 
type bound procedures – a component of object oriented programming in Fortran. 
 26.4.5  Derived Types and Structure Constructors 
 A derived type is a type that is not deﬁ ned by the language but requires a type deﬁ ni-
tion to declare its components. A scalar object of such a derived type is called a 
structure. Assignment of structures is deﬁ ned intrinsically, but there are no intrinsic 

371
26.4 Type Declaration Statements
operations for structures. For each derived type, a structure constructor is available 
to provide values. 
 A derived-type deﬁ nition implicitly deﬁ nes a corresponding structure construc-
tor that allows construction of values of that derived type. 
 26.4.6  Structure Constructors and Generic Names 
 A generic name may be the same as a type name. This can be used to emulate user-
deﬁ ned structure constructors for that type, even if the type has private components. 
The following example is taken from the standard to illustrate this.
 module mytype_module  
 type mytype  
 private  
 complex value  
 logical exact  
 end type  
 interface mytype  
 module procedure int_to_mytype  
 end interface  
 ! Operator deﬁ nitions etc.  
 … 
 contains  
 type(mytype) function int_to_mytype(I)  
 integer,intent(in) :: I  
 int_to_mytype%value = I  
 int_to_mytype%exact = .true.  
 end function  
 ! Procedures to support operators etc.  
 … 
 end 
 26.4.7  Assignment 
 Execution of an assignment statement causes a variable to become deﬁ ned or rede-
ﬁ ned. Simplistically
 variable = expression 
 26.4.8  Intrinsic Assignment Statement 
 An intrinsic assignment statement is an assignment statement that is not a deﬁ ned 
assignment statement. In an intrinsic assignment statement, variable shall not be 
polymorphic. 

372
26 Object Oriented Programming
 26.4.9  Deﬁ ned Assignment Statement 
 A deﬁ ned assignment statement is an assignment statement that is deﬁ ned by a sub-
routine and a generic interface that speciﬁ es ASSIGNMENT (=). 
 26.4.10  Polymorphic Variables 
 Here is the deﬁ nition of polymorphic taken from the standard.
 polymorphic – Able to be of differing types during program execution. An object 
• 
declared with the CLASS keyword is polymorphic. 
 A polymorphic variable must be a pointer or allocatable variable. We will use 
allocatable variables to achieve polymorphism in our examples. 
 26.4.11  Executable Constructs Containing Blocks 
 The following are executable constructs that contain blocks:
 ASSOCIATE construct 
• 
 CASE construct 
• 
 DO construct 
• 
 IF construct 
• 
 SELECT TYPE construct 
• 
 We will look at the ASSOCIATE construct and SELECT TYPE construct next. 
 26.4.12  ASSOCIATE Construct 
 The ASSOCIATE construct associates named entities with expressions or variables 
during the execution of its block. These named construct entities are associating 
entities. The names are associate names. 
 The following example illustrates an association with a derived-type variable.
 ASSOCIATE ( XC => AX%B(I,J)%C )  
 XC%DV = XC%DV + PRODUCT(XC%EV(1:N))  
 end ASSOCIATE  
 26.4.13  Select Type Construct 
 The SELECT TYPE construct selects for execution at most one of its constitu-
ent blocks. The selection is based on the dynamic type of an expression. A name 

373
26.5 Example 1 – The Basic Shape Class
is associated with the expression, in the same way as for the ASSOCIATE 
construct. 
 Quite a lot to take in! Let’s illustrate the use of the above in some actual examples.  
 26.5  Example 1 – The Basic Shape Class 
 The code for the base shape class is given below.
 shape class data: integer variables x and y for the position. 
• 
 shape class methods: get and set for the x and y values, and moveto and draw. 
• 
 We have used an include statement in the examples that follow to reduce code 
duplication. 
 We have used the default accessibility for the data and methods in the shape_
module.
 module shape_module 
 type shape_type  
 integer :: x_ = 0  
 integer :: y_ = 0  
 contains 
 procedure, pass(this) :: getx  
 procedure, pass(this) :: gety  
 procedure, pass(this) :: setx  
 procedure, pass(this) :: sety  
 procedure, pass(this) :: moveto  
 procedure, pass(this) :: draw  
 end type shape_type  
 contains  
 include "shape_module_common_code.f90"  
 end module shape_module  
 Here is the code in the include ﬁ le.
 integer function getx(this) 
 implicit none  
 class (shape_type), intent (in) : : this  
 getx = this%x  
 end function getx  
 integer function gety(this) 
 implicit none  
 class (shape_type), intent (in) : : this  
 gety = this%y_  
 end function gety  
 subroutine setx(this,x) 
 implicit none  

374
26 Object Oriented Programming
 class (shape_type), intent (inout) :: this  
 integer, intent (in) :: x  
 this%x_ = x  
 end subroutine setx  
 subroutine sety(this,y) 
 implicit none  
 class (shape_type), intent (inout) :: this  
 integer, intent (in) :: y  
 this%y_ = y  
 end subroutine sety  
 subroutine moveto(this,newx, newy) 
 implicit none  
 class (shape_type), intent (inout) :: this  
 integer, intent (in) :: newx  
 integer, intent (in) :: newy  
 this%x_ = newx  
 this%y_ = newy  
 end subroutine moveto  
 subroutine draw(this) 
 implicit none  
 class (shape_type), intent (in) :: this  
 print *, ' x = ', this%x_  
 print *, ' y = ', this%y_  
 end subroutine draw  
 26.5.1  Key Points 
 Some of the key concepts are:
 We use a module as the organisational unit for the class. 
• 
 We use type and end type to contain the data and the procedures – called type 
• 
bound procedures in Fortran terminology. 
 The data in the base class is an x and y position. 
• 
 The type bound methods within the class are
• 
 getx and setx 
 –
 gety and sety 
 –
 draw 
 –
 moveto 
 –
 We have used the default accessibility for the data and methods in the type. 
• 
 Let us look at the code in stages.
 module shape_module  

375
26.5 Example 1 – The Basic Shape Class
 The module is called shape_module
 type shape_type  
 The type is called shape_type
 integer :: x_ = 0  
 integer :: y_ = 0  
 The data associated with the shape type are integer variables that are the x and y 
coordinates of the shape. We initialise to zero.
 contains  
 The type also contains procedures or methods.
 procedure, pass(this) :: getx  
 procedure, pass(this) :: gety  
 procedure, pass(this) :: setx  
 procedure, pass(this) :: sety  
 procedure, pass(this) :: moveto  
 procedure, pass(this) :: draw  
 These are called type bound procedures in Fortran terminology. It is common in 
object oriented programming to have get and set methods for each of the data com-
ponents of the type or object. We also have a moveto and draw method. 
 Each of these methods has the pass attribute. When a type bound procedure is called 
or invoked the object through which is invoked is normally passed as a hidden parame-
ter. We have used the pass attribute to explicitly conﬁ rm the default behaviour of passing 
the invoking object as the ﬁ rst parameter. We have also followed the convention in object 
oriented programming of using the word  this to refer to the current object.
 end type shape_type  
 This is the end of the type deﬁ nition.
 contains  
 The module then contains the actual implementation of the type bound proce-
dures. We will look at a couple of these.
 integer function getx(this) 
 implicit none  
 class (shape_type), intent (in) :: this  
 getx = this%x  
 end function getx  
 As we stated earlier it is common in object oriented programming to have get and 
set methods for each data item in an object. This function implements the getx method. 
The ﬁ rst argument is the current object, referred to as this. We then have the type 
declaration for this parameter. We declare the variable using class rather than type as 
we want the variable to be polymorphic. The rest of the function is self explanatory.

376
26 Object Oriented Programming
 subroutine setx(this,x) 
 implicit none  
 class (shape_type), intent (inout) :: this  
 integer, intent (in) :: x  
 this%x_ = x  
 end subroutine setx  
 The setx procedure is a subroutine. It takes two parameters, the current object 
and the new x value. Again we use the class declaration mechanism as we want the 
variable to be polymorphic. 
 Here is a program to test the above class out.
 program test_ch2601 
 use shape_module  
 implicit none  
 type (shape_type) :: s1 = shape_type(10,20)  
 integer :: x1 = 100  
 integer :: y1 = 200  
 print *, ' get '  
 print *, s1%getx(), ' ', s1%gety()  
 print *, ' draw '  
 call s1%draw()  
 print *, ' moveto '  
 call s1%moveto (x1,y1)  
 print *, ' draw '  
 call s1%draw()  
 print *, ' set '  
 call s1%setx(99)  
 call s1%sety(99)  
 print *, ' draw'  
 call s1%draw()  
 end program test_ch2601  
 The ﬁ rst statement of interest is the use statement, where we make available the 
shape_module to the test program. The next statement of interest is
 type (shape_type) :: s1 = shape_type(10,20)  
 We then have a type declaration for the variable s1. We also have the use of what 
Fortran calls a structure constructor  shape_type to provide initial values to the x 
and y positions. The term constructor is used in other object oriented programming 
languages, e.g. C++, Java, C#. It has the same name as the type or class and is cre-
ated automatically for us by the compiler in this example. 
 The
 print *, s1%getx(), ' ', s1%gety()  

377
26.5 Example 1 – The Basic Shape Class
 statement prints out the x and y values for the object s1. We use the standard % nota-
tion that we used in derived types, to separate the components of the derived types. 
If one looks at the implementation of the getx function and examines the ﬁ rst line, 
repeated below
 integer function getx(this)  
 how we refer to the current object, s1, through the syntax s1%getx(). The following 
call:
 call s1%draw() 
 shows how to invoke the draw method for the s1 object, using the s1%draw() syn-
tax. The ﬁ rst line of the draw subroutine
 subroutine draw(this)  
 shows how the current object is passed as the ﬁ rst argument. 
 Here is the output from the Nag compiler.
 d:\document\fortran\newbook\examples\ch26\ex01>nag_
test_ch2601.exe  
get 
 10 20 
 draw 
 x = 10  
 y = 20  
 moveto  
 draw 
 x = 100  
 y = 200  
 set 
 draw 
 x = 99  
 y = 99  
 26.5.2  Notes 
 In this example we have not used the public, private or protected attributes on the 
data or methods, we have just accepted the default Fortran accessibility behaviour. 
This means that we can use the compiler provided structure constructor  shape_
type () as shown below
 type (shape_type) :: s1 = shape_type(10,20)  
 in the type declaration to provide initial values, as they are public by default. 

378
26 Object Oriented Programming
 We have direct access to the data and methods as they are public by default in 
Fortran. This is often not a good idea for the data, as it is possible to makes changes 
to the data anywhere in the program. The next example makes the data private. 
 26.5.3  Example 1 with Private Data 
 Here is the modiﬁ ed base class. This example will now not compile as the default 
compiler provided structure constructor does not have access to the private data.
 module shape_module 
 type shape_type 
 integer, private : : x = C  
 integer, private :: y = C  
 contains 
 procedure, pass(this) :: getx  
 procedure, pass(this) :: gety  
 procedure, pass(this) :: setx  
 procedure, pass(this) :: sety  
 procedure, pass(this) :: moveto  
 procedure, pass(this) :: draw  
 end type shape_type  
 contains  
 include "shape_module_common_code.f90"  
 end module shape_module  
 Here is the same test program as in the ﬁ rst example.
 program test_ch2602  
 use shape_module  
 implicit none  
 type (shape_type) :: s1 = shape_type(10,20)  
 integer :: x1 = 100  
 integer :: y1 = 200  
 print *, ' get '  
 print *, s1%getx(), ' ', s1%gety()  
 print *, ' draw '  
 call s1%draw()  
 print *, ' moveto '  
 call s1%moveto (x1,y1)  
 print *, ' draw '  
 call s1%draw()  
 print *, ' set '  
 call s1%setx(99)  
 call s1%sety(99)  
 print *, ' draw'   
 call s1%draw()  
 end program test ch2602  

379
26.5 Example 1 – The Basic Shape Class
 Here is the output from trying to compile this example.
 d:\document\fortran\newbook\examples\ch26\ex01>nagfor  
 -f2003 ch2602.f90 test_ch2  
 602.f90 -o nag_test_ch2602.exe  
 NAG Fortran Compiler: Release 5.2(722)  
 Evaluation trial version of NAG Fortran Compiler  
 Release 5.2(722)  
 ch2602.f90:  
 [NAG Fortran Compiler normal termination]  
 test_ch2602.f90:  
 Error: test_ch2602.f90, line 5: Constructor for type  
 SHAPE_TYPE which has PRIVATE component X_  
 Errors in declarations, no further processing for 
TEST_CH2602  
 [NAG Fortran Compiler error termination, 1 error]  
 d:\document\fortran\newbook\examples\ch26\ex01>  
 An earlier solution to this type of problem can be found in the date class in 
Chap.  22 , where we provide our own structure constructor  date_() . Most object 
oriented programming languages provide the ability to use the same name as a class 
as a constructor name even if the data is private. Fortran 2003 provides another solu-
tion to this problem. In the example below we will provide our own structure con-
structor inside an interface. 
 26.5.4  Solution 1 with an Interface to Use the Class Name 
for the Structure Constructor 
 Here is the modiﬁ ed base class.
 module shape_module  
 type shape_type  
 integer, private :: x_=0  
 integer, private :: y_=0  
 contains 
 procedure, pass(this) :: getx  
 procedure, pass(this) :: gety  
 procedure, pass(this) :: setx  
 procedure, pass(this) :: sety  
 procedure, pass(this) :: moveto  
 procedure, pass(this) :: draw  
 end type shape_type  
 interface shape_type 
 module procedure shape_type_constructor  
 end interface  

380
26 Object Oriented Programming
 contains 
 type (shape_type) function &   
 shape_type_constructor(x,y) 
 implicit none  
 integer, intent (in) :: x  
 integer, intent (in) :: y  
 shape_type_constructor%x_ = x  
 shape_type_constructor%y_ = y  
 end function shape_type_constructor  
 include "shape_module_common_code.f90"  
 end module shape_module  
 The key statements are
 interface shape_type  
 module procedure shape_type_constructor  
 end interface  
 which enables us to map a call or reference to shape_type (our structure constructor 
name) to our implementation of shape_type_constructor. Here is the implementa-
tion of this structure constructor.
 type (shape_type) function &  
 shape_type_constructor(x, y) 
 implicit none  
 integer, intent (in) :: x  
 integer, intent (in) :: y  
 shape_type_constructor%x_ = x
shape_type_constructor%y_ = y  
 end function shape_type_constructor  
 The function is called shape_type_constructor hence we use this name to initialise 
the components of the type, and the function returns a value of type shape_type. 
 Here is the program to test the above out.
 program ch2603  
 use shape_module  
 implicit none  
 type (shape_type) :: s1  
 integer :: x1 = 100  
 integer :: y1 = 200  
 s1 = shape_type(10,20)  
 print *, ' get '  
 print *, s1%getx(), ' ', s1%gety()  
 print *, ' draw '  
 call s1%draw()  
  print *, ' moveto '  
 call s1%moveto (x1, y1)  

381
26.6 Example 2 – Simple Inheritance
 print *, ' draw '  
 call s1%draw()  
 print *, ' set '  
 call s1%setx(99)  
 call s1%sety(99)  
 print *, ' draw'  
 call s1%draw()  
 end program ch2603  
 Note that in this example we cannot initialise  s1 at deﬁ nition time using our own 
(user deﬁ ned) structure constructor. This must now be done within the execution 
part of the program. This is a Fortran restriction, and makes it consistent with the 
rest of the language. 
 These examples illustrate some of the basics of object oriented programming in 
Fortran. To summarise
 the data in our class is private; 
• 
 access to the data is via get and set methods; 
• 
 the data and methods are within the derived type deﬁ nition – the methods are 
• 
called type bound procedures in Fortran terminology; 
 we can use interfaces to provide user deﬁ ned structure constructors, which have 
• 
the same name as the class – this is a common practice in object oriented 
programming; 
 we have used class to declare the variables within the type bound methods. We 
• 
need to use class when we want to use polymorphic variables in Fortran. 
 26.5.5  Public and Private Accessibility 
 We have only made the internal data in the class private in the above example. There 
will be cases where some of the methods are only used within the class, in which 
case they can be made private. 
 26.6  Example 2 – Simple Inheritance 
 In this example we look at inheritance. We use the same base shape class and derive 
two classes from it – circle and rectangle. 
 A circle has a radius. This is the additional data component of the derived class. 
We also have get and set methods. 
 A rectangle has a width and height. These are the additional data components of 
the derived rectangle class. We also have get and set methods. 

382
26 Object Oriented Programming
 26.6.1  Base Shape Class 
 module shape_module  
 type shape_type  
 integer, private :: x_ = 0  
 integer, private :: y_ = 0  
 contains 
 procedure, pass(this) :: getx  
 procedure, pass(this) :: gety  
 procedure, pass(this) :: setx  
 procedure, pass(this) :: sety  
 procedure, pass(this) :: moveto  
 procedure, pass(this) :: draw  
 end type shape_type  
 interface shape_type 
 module procedure shape_type_constructor  
 end interface  
 contains 
 type (shape_type) function &  
 shape_type_constructor(x,y) 
 implicit none  
 integer, intent (in) :: x  
 integer, intent (in) :: y  
 shape_type_constructor%x_ = x 
shape_type_constructor%y_ = y  
 end function shape_type_constructor  
 include "shape_module_common_code.f90"  
 end module shape_module  
 The include ﬁ le is the same as in the previous example. 
 26.6.2  Circle – Derived Type 1 
 Here is the ﬁ rst derived type.
 module circle_module  
 use shape_module  
 type , extends(shape_type) :: circle_type 
 integer , private :: radius_  
 contains  
 procedure , pass(this) :: getradius  
 procedure , pass(this) :: setradius  
 procedure , pass (this) :: draw => draw_circle  
 end type circle_type 

383
26.6 Example 2 – Simple Inheritance
 interface circle_type  
 module procedure circle_type_constructor  
 end interface  
 contains  
 type (circle_type) function &  
 circle_type_constructor(x,y,radius) 
 implicit none  
 integer, intent (in) :: x  
 integer, intent (in) :: y  
 integer, intent (in) :: radius  
 call circle_type_constructor%setx(x)  
 call circle_type_constructor%sety(y)  
 circle_type_constructor%radius_=radius  
 end function circle_type_constructor  
 integer function getradius(this)  
 implicit none  
 class (circle_type) , intent(in) :: this 
 getradius=this%radius_  
 end function getradius  
 subroutine setradius(this,radius)  
 implicit none  
 class (circle_type) , intent(inout) :: this  
 integer , intent(in) :: radius 
 this%radius_=radius  
 end subroutine setradius  
 subroutine draw_circle(this)  
 implicit none 
 class (circle_type), intent(in) :: this  
 print *,' x =   ' ,  this%getx()  
 print *,' y = ' , this%gety()  
 print *,' radius = ' , this%radius_  
 end subroutine draw_circle  
 end module circle_module  
 Let us look more closely at the statements within this class. Firstly we have
  module circle_module  
which introduces our circle module. 
 We then
 use shape_module  
 within this module to make available the shape class. The next statement
 type , extends(shape_type) :: circle_type  
 is the key statement in inheritance. What this statement says is base our new circle_
type on the base shape_type. It is an extension of the shape_type. We then have the 
additional data in our circle_type

384
26 Object Oriented Programming
 integer , private :: radius_  
 and the following additional type bound procedures.
 procedure , pass(this) :: getradius  
 procedure , pass(this) :: setradius  
 procedure , pass(this) :: draw => draw_circle  
 and we have the simple get and set methods for the radius, and a type speciﬁ c draw 
method for our circle_type. It is this method that will be called when drawing with 
a circle, rather than the draw method in the base shape_type. 
 We then have an interface
 interface circle_type  
 module procedure circle_type_constructor  
 end interface  
to provide us with our own user deﬁ ned structure constructor for our circle_type. 
 As has been stated earlier it is common practice in object oriented programming 
to use the same name as the type for constructors. 
 We then have the implementation of the constructor.
 type (circle_type) function &  
 circle_type_constructor(x,y,radius) 
 implicit none integer, intent (in) :: x  
 integer, intent (in) :: y  
 integer, intent (in) :: radius  
 call circle_type_constructor%setx(x)  
 call circle_type_constructor%sety(y)  
 circle_type_constructor%radius_=radius  
 end function circle_type_constructor  
 Note that we use the setx and sety methods to provide initial values to the x and y 
values. They are private in the base class so we need to use these methods. 
 We can directly initialise the radius as this is a data component of this class, and 
we have access to it. 
 We next have the get and set methods for the radius. 
 Finally we have the implementation for the draw circle method.
 subroutine draw_circle(this)  
 implicit none 
 class (circle_type), intent(in) :: this  
 print *, ' x = ' , this%getx()  
 print *, ' y = ' , this%gety()  
 print *, ' radius = ' , this%radius_  
 end subroutine draw_circle  
 Notice again that we use the getx and gety methods to access the x and y private 
data from the base shape class. 

385
26.6 Example 2 – Simple Inheritance
 26.6.3  Rectangle – Derived Type 2 
 Here is the code for the second derived type.
 module rectangle_module  
 use shape_module  
 type , extends(shape_type) :: rectangle_type 
 integer , private :: width_  
 integer , private :: height_  
 contains  
 procedure , pass(this) :: getwidth  
 procedure , pass(this) :: setwidth  
 procedure , pass(this) :: getheight  
 procedure , pass(this) :: setheight  
 procedure , pass(this) :: draw => draw_rectangle  
 end type rectangle_type 
 interface rectangle_type  
 module procedure rectangle_type_constructor  
 end interface  
 contains 
 type (rectangle_type) function &  
 rectangle_type_constructor(x,y,width, height) 
 implicit none  
 integer, intent (in) :: x  
 integer, intent (in) :: y  
 integer, intent (in) :: width  
 integer, intent (in) :: height  
 call rectangle_type_constructor%setx(x)  
 call rectangle_type_constructor%sety(y)  
 rectangle_type_constructor%width_ = width  
 rectangle_type_constructor%height_ = height  
 end function rectangle_type_constructor  
 integer function getwidth(this)  
 implicit none  
 class (rectangle_type) , intent(in) :: this 
 getwidth=this%width_  
 end function getwidth  
 subroutine setwidth(this,width)  
 implicit none   
 class (rectangle_type) , intent(inout) :: this  
 integer , intent(in) :: width 
 this%width_=width  
 end subroutine setwidth  
 integer function getheight(this)  
 implicit none  

386
26 Object Oriented Programming
 class (rectangle_type) , intent(in) :: this 
 getheight=this%height_  
 end function getheight  
 subroutine setheight(this,height)  
 implicit none  
 class (rectangle_type) , intent(inout) :: this  
 integer , intent(in) :: height 
 this%height_=height  
 end subroutine setheight  
 subroutine draw_rectangle(this)  
 implicit none 
 class (rectangle_type) , intent(in) :: this  
 print *, ' x = ' , this%getx()  
 print *, ' y = ' , this%gety()  
 print *, ' width = ' , this%width_  
 print *, ' height = ' , this%height_  
 end subroutine draw_rectangle  
 end module rectangle_module  
 The code is obviously very similar to that of the ﬁ rst derived type. 
 26.6.4  Simple Inheritance Test Program 
 Here is a test program that illustrates the use of the shape type, circle type and rect-
angle type.
 program ch2604  
 use shape module use circle module use rectangle module  
 implicit none  
 type (shape_type) :: vs type (circle_type) : : vc type 
(rectangle_type) :: vr  
 vs = shape type(10,20)  
 vc = circle_type(100, 200, 300)  
 vr = rectangle_type(1000,2000, 3000, 4000)  
 print *,' get '  
 print *,' circle ', vc%getx(),' ',vc%gety(),&
' radius = ',vc%getradius()
print *,' rectangle ', vr%getx(),' ',vr%gety(),&
' width = ',vr%getwidth(),' height ',vr%getheight()  
 print *,' draw '  
 call vs%draw() call vc%draw() call vr%draw()  
 print *,' set '  
 call vs%setx(19) call vs%sety(19)  

387
26.6 Example 2 – Simple Inheritance
 call vc%setx(199) call vc%sety(199) call 
vc%setradius(199)  
 call vr%setx(1999) call vr%sety(1999) call vr%
setwidth(1999) call vr%setheight(1999)  
 print *,' draw '  
 call vs%draw() call vc%draw() call vr%draw()  
 end program ch2604  
 The ﬁ rst statements of note are
 use shape_module  
 use circle_module  
 use rectangle_module  
 which make available the shape, circle and rectangle types within the program. The 
following statements
 type (shape_type) :: vs  
 type (circle_type) :: vc  
 type (rectangle_type) :: vr  
 declare vs, vc and vr to be of type shape, circle and rectangle respectively. The fol-
lowing three statements
 vs = shape_type(10,20)  
 vc = circle_type(100, 200, 300)  
 vr = rectangle_type(1000,2000, 3000, 4000)  
 call the three user deﬁ ned structure constructor functions. 
 We then use the get functions to print out the values of the private data in each 
object. 
 We then call the draw method for each type.
 call vs%draw()  
 call vc%draw()  
 call vr%draw()  
 and the appropriate draw method is called for each type. 
 We ﬁ nally call the set functions for each variable and repeat the calls to the draw 
methods. 
 The draw methods in the derived types override the draw method in the base 
shape class. 

388
26 Object Oriented Programming
 26.7  Example 3 – Polymorphism and Dynamic Binding 
 An inheritance hierarchy can provide considerable ﬂ exibility in our ability to manip-
ulate objects, whilst still taking advantage of static or compile time type checking. If 
we combine inheritance with polymorphism and dynamic binding we have a very 
powerful programming tool. We will illustrate this with a concrete example. 
 26.7.1  Base Shape Class 
 This is our base class. A polymorphic variable is a variable whose data type may 
vary at run time. It must be a pointer or allocatable variable, and it must be declared 
using the class keyword. Our original base class declared variables using the class 
keyword from the beginning as we always intended to design a class that could be 
polymorphic. 
 We have had to make one change to the previous one. To make the polymor-
phism work we have had to provide our own assignment operator. So we have
 interface assignment (=)  
 module procedure generic_shape_assign  
 end interface  
 which means that our implementation of the procedure generic_shape_assign will 
replace the intrinsic assignment. Here is the actual implementation.
 subroutine generic_shape_assign(lhs,rhs)  
 implicit none  
 class (shape_type), intent (out), allocatable :: lhs  
 class (shape_type), intent (in) : : rhs  
 allocate (lhs,source=rhs)  
 end subroutine generic_shape_assign  
 In an assignment we obviously have
 left_hand_side = right_hand_side  
 and in our code we have variables lhs and rhs to clarify what is happening. We also 
have an enhanced form of allocation statement:
 allocate (lhs,source=rhs)  
 and the key is that the left hand side variable is allocated with the values and type of 
the right hand side variable. Here is the complete code.
 module shape_module  
 type shape_type  
 integer, private :: x_ = 0  
 integer, private :: y_ = 0  
 contains 
 procedure, pass(this) :: getx  

389
26.7 Example 3 – Polymorphism and Dynamic Binding
 procedure, pass(this) :: gety  
 procedure, pass(this) :: setx  
 procedure, pass(this) :: sety  
 procedure, pass(this) :: moveto  
 procedure, pass(this) :: draw  
 end type shape_type  
 interface shape_type 
 module procedure shape_type_constructor  
 end interface  
 interface assignment (=) 
 module procedure generic_shape_assign  
 end interface  
 contains 
 type (shape_type) function &  
 shape_type_constructor(x,y) 
 implicit none  
 integer, intent (in) :: x  
 integer, intent (in) :: y  
 shape_type_constructor%x_ = x  
 shape_type_constructor%y_ = y  
 end function shape_type_constructor  
 integer function getx(this) 
 implicit none  
 class (shape_type), intent (in) :: this  
 getx = this%x_  
 end function getx  
 integer function gety(this) 
 implicit none  
 class (shape_type), intent (in) :: this  
 gety = this%y_  
 end function gety  
 subroutine setx(this,x) 
 implicit none  
 class (shape_type), intent (inout) :: this  
 integer, intent (in) :: x  
 this%x_ = x   
 end subroutine setx  
 subroutine sety(this,y) 
 implicit none  
 class (shape_type), intent (inout) :: this 
integer, intent (in) :: y  
 this%y_ = y  
 end subroutine sety  
 subroutine moveto(this,newx,newy) 
 implicit none  
 class (shape_type), intent (inout) :: this  

390
26 Object Oriented Programming
 integer, intent (in) :: newx  
 integer, intent (in) :: newy  
 this%x_ = newx  
 this%y_ = newy  
 end subroutine moveto  
 subroutine draw(this) 
 implicit none  
 class (shape_type), intent (in):: this  
 print *, ' x = ', this%x_  
 print *, ' y = ', this%y_  
 end subroutine draw  
 subroutine generic_shape_assign(lhs, rhs) 
 implicit none  
 class (shape_type), intent (out), allocatable :: lhs  
 class (shape_type), intent (in) :: rhs  
 allocate (lhs,source=rhs)  
 end subroutine generic_shape_assign  
 end module shape_module  
 26.7.2  Circle – Derived Type 1 
 The circle code is the same as before. 
 26.7.3  Rectangle – Derived Type 2 
 The rectangle code is as before. 
 26.7.4  Shape Wrapper Module 
 As was stated earlier a polymorphic variable must be a pointer or allocatable vari-
able. We have chosen to go the allocatable route. The following is a wrapper routine 
to allow us to have a derived type whose types can be polymorphic.
 module shape_wrapper_module  
 use shape_module  
 use circle_module  
 use rectangle_module  
 type shape_wrapper 
 class (shape_type), allocatable :: x  
 end type shape_wrapper  
 end module shape_wrapper_module  
 So in this case x can be of shape_type or of any type derived from shape_type. 
Don’t panic if this isn’t clear at the moment, the complete program should help out!  

391
26.7 Example 3 – Polymorphism and Dynamic Binding
 26.7.5  Display Subroutine 
 This is the key subroutine in this example. We can pass into this routine an array of 
type shape_wrapper. In the code so far we have variables of type
 shape_type 
• 
 circle_type 
• 
 rectangle_type 
• 
and we are passing in an array of elements and each element can be of any of these 
types, i.e. the shape_array is polymorphic. 
 We next statement of interest is
 call shape_array(i)%x%draw()  
 and at run time the correct draw method will be called. This is called dynamic bind-
ing. Here is the complete code.
 module display_module  
 contains 
 subroutine display(n_shapes,shape_array)  
 use shape_wrapper_module  
 implicit none  
 integer, intent (in) :: n_shapes  
 type (shape_wrapper), &   
 dimension (n_shapes) :: shape_array 
 integer :: I  
 do I = 1, n_shapes  
 call shape_array(I) %x%draw()  
 end do  
 end subroutine display  
 end module display_module  
 26.7.6  Test Program 
 We now have the complete program that illustrates polymorphism and dynamic 
binding in action. 

392
26 Object Oriented Programming

393
26.7 Example 3 – Polymorphism and Dynamic Binding
 Let us look at the key statements in more detail.
 type (shape wrapper), dimension (n) :: s  
 This is the key declaration statement. S will be our polymorphic array. The fol-
lowing six assignment statements
 s(1) %x = shape_type(10, 20)  
 s(2) %x = circle_type(100,200,300)  
 s(3) %x = rectangle_type(1000,2000, 3000, 4000)  
 s(4) %x = s(1)%x  
 s(5) %x = s(2)%x  
 s(6) %x = s(3)%x  
 will call our own assignment subroutine to do the assignment. The allocation is hid-
den in the implementation. We then have
 call display(n,s)  
 which calls the display subroutine. The compiler at run time works out which draw 
method to call depending of the type of the elements in the shape_wrapper array. 
 Imagine now adding another shape type, let us say a triangle. We need to do the 
following
 inherit from the base shape type 
• 
 add the additional data to deﬁ ne a triangle 
• 
 add the appropriate get and set methods 
• 
 add a draw triangle method 
• 
 add a use statement to the shape_wrapper_module 
• 
 add a use statement to the main program 
• 
and we now can work with the new triangle shape type. The display subroutine is 
unchanged! We can repeat the above steps for any additional shape type we 
want. 
 Polymorphism and dynamic binding thus shorten our development and mainte-
nance time, as it reduces the amount of code we need to write and test. 
 We then have an example of the use of the SELECT TYPE statement. The compiler 
determines the type of the elements in the array and then executes the matching block. 

394
26 Object Oriented Programming
 Now imagine adding support for the new triangle type. Anywhere we have select 
type constructs we have to add support for our new triangle shape. There is obvi-
ously more work involved when we use the select type construct in our polymorphic 
code. However some problems will be amenable to polymorphism and dynamic 
binding, others will require the explicit use of select type statements. This example 
illustrates the use of both. 
 26.7.7  Program Output 
 Try running the program. Here is the output from one compiler. 

395
26.8 Summary
 26.8  Summary 
 This chapter has introduced some of the essentials of object oriented programming. 
The ﬁ rst example looked at object oriented programming as an extension of basic 
data structuring. We used type bound procedures to implement our shape class. We 
used methods to access the internal data of the shape object. 
 The second example looked at simple inheritance. We saw in this example how 
we could reuse the methods from the base class and also add new data and methods 
speciﬁ c to the new shapes – circles and rectangles. 
 The third example then looked at how to achieve polymorphism in Fortran. We 
could then create arrays of our base type and dynamically bind the appropriate 
methods at run rime. Dynamic binding is needed when multiple classes contain dif-
ferent implementations of the same method, i.e. to ensure in the following code
 call shape_array(I) %x%draw()  
 that the correct draw method is invoked on the shape object. 

396
26 Object Oriented Programming
 26.9  Problems 
 1.  Compile and run all of the examples in this chapter with your compiler. At the 
time of writing this book not all compilers compiled and ran these examples. 
This situation will improve with time. If your compiler doesn’t complain! 
 2.  Add a triangle type to the simple inheritance example. 
 3.  Add a triangle type to the polymorphic example. 
 26.10  Bibliography 
 Birtwistle , G.M., Dahl, O.J., Myhrhaug, B., Nygaard, K.: SIMULA BEGIN. Chart-
well-Bratt Ltd, Bromley (1979) 
 Goldberg, A., Robson, D.: Smalltalk-80. The Language and Its Implementation. 
Addison Wesley, Reading (1983) 
 ISO/IEC 1539–1:2010 Information technology – Programming languages – Fortran 
– Part 1: Base language 
 Meyer, B.: Object-Oriented Software Construction. Prentice Hall, Upper Saddle 
River (1997) 
 Mossenbeck, H.: Object-Orientated Programming in Oberon-2. Springer-Verlag, 
Berlin/New York (1995) 
 Stroustroup, B.: The C++ Programming Language, 3rd edn. Addison-Wesley, 
Reading (1997) 
 Wiener, R.: Software Development Using Eiffel. Prentice Hall, Englewood Cliffs 
(1995) 

397
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_27, © Springer-Verlag London Limited 2012
 Aim 
 The aims of this chapter is to provide a short introduction to parallel programming. 
 27.1  Introduction 
 Parallel programming involves breaking a program down into parts that can be executed 
concurrently. Here is a simple diagram to illustrate the idea. 
 Chapter 27 
 Introduction to Parallel Programming 
 
 ‘Can you do addition?’ the White Queen asked. ‘What’s one 
and one and one and one and one and one and one and one and 
one and one?’ 
 ‘I don’t know’ said Alice. ‘I lost count.’ 
 ‘She can’t do addition,’ the Red Queen interrupted. 
 Lewis Carroll, Through the Looking Glass and What Alice 
Found There. 

398
27 Introduction to Parallel Programming
 On the left hand side we have a sequential program and this steps through linearly 
from beginning to end. The right hand side has the same program that has been 
partially parallelised. There are two parallel regions and the work here is now shared 
between two processes or threads. At each parallel part of the program we have the 
following 
 The theory is that the overall run time of the program will have been reduced or 
we will have been able to solve a larger problem by parallelising our code. In the 
above example we have divided the work between two processes or threads. Here 
are some details of a range of processors which support multiple cores. 
 Visit the AMD and Intel sites for up to date information. 
 There are several ways of doing parallel programming, and this chapter will look at 
three ways of doing this in Fortran. There are a common set of concepts and terminology 
that are useful to know about, whichever method we use, and we will cover these ﬁ rst. 

399
27.3 Amdahl’s Law
 27.2  Parallel Computing Classiﬁ cation 
 Parallel computing is often classiﬁ ed by the way the hardware supports parallelism. 
Two of the most common are:
 multi-processor and multi-core computers having multiple processing elements 
• 
within a single system 
 clusters or grids with multiple computers connected to work together. Modern 
• 
large systems are increasingly hybrids of the two above. 
 27.3  Amdahl’s Law 
 Amdahl’s law is a simple equation for the speedup of a program when parallelised. 
It assumes that the problem size remains the same when parallelized. 
 In the equation below
 P is the proportion of the program that can be parallelised 
• 
 (1-P) is the serial proportion 
• 
 N is the number of processors
• 
 and we have
 speedup = 1/((1-P) + P/N) 
• 
 We have included a couple of graphs to illustrate the above. We have used the 
dislin graphics library to do the plots. It is available from
 http://www.mps.mpg.de/dislin/  

400
27 Introduction to Parallel Programming
 27.3.1  Amdahl’s Law Graph 1–8 Processors or Cores  
 27.3.2  Amdahl’s Law Graph 2–64 Processors or Cores 

401
27.3 Amdahl’s Law
 Here is the source code for one of the programs. It is for the 8 processor version. 

402
27 Introduction to Parallel Programming

403
27.4 Gustafson’s Law
 We use the dislin graphics library in this example. More information about the 
dislin software can be found in Chap.  33 . 
 27.4  Gustafson’s Law 
 Gustafson’s Law is often seen as a contradiction of Amdahl’s Law. Simplistically it 
states that programmers solve larger problems when parallelising programs. 
 The equation for Gustafson’s Law is given below.
 N is the number of processors 
• 
 Serial is the proportion that remains serial 
• 
and
 Speedup(N) = N – serial * (N – 1 ) 
• 
 We have again included a graph to illustrate the above. 
 27.4.1  Gustafson’s Law Graph 1–64 Processors or Cores 

404
27 Introduction to Parallel Programming
 Here is the source code for the program. This is for the 64 processor version. 

405
27.4 Gustafson’s Law
 The programs are obviously very similar! 

406
27 Introduction to Parallel Programming
 27.5  Memory Access 
 Memory access times fall into two main categories that are of interest in parallel 
computing
 uma – uniform memory access. Each element of main memory can be accessed 
• 
with the same latency and bandwidth. Multi-processor and multi-core computers 
typically have this behaviour. 
 numa – non uniform memory access. Distributed memory systems have non-
• 
uniform memory access. Clusters or grids with multiple computers connected to 
work together have this behaviour. 
 27.6  Cache 
 Modern processors have a memory hierarchy. They typically have two or more 
levels:
 main memory 
• 
 cpu memory  
• 
and there is a speed and cost link. Main memory is cheap and relatively slow in com-
parison to the cpu memory. 
 The cpu memory or cache is used to reduce the effective access time to memory. 
If the information that the program requires is in the cpu cache then the average 
latency of memory accesses will be closer to the cache latency than to the latency of 
main memory. Getting high performance from a computer normally means writing 
cache friendly programs. This means that the data and instructions that the program 
needs are already in the cache and don’t need to be accessed from the much slower 
main memory. 
 In a multi-core and multi-cpu system each core and cpu will have their own 
memory or cache. This introduces the problem of cache coherency – i.e. the consis-
tency of data stored in local caches compared to the data in the common shared 
memory. This problem must obviously be addressed when doing parallel 
programming. 
 27.7  Bandwidth and Latency 
 Bandwidth is the rate at which data can be transferred. Latency is the start up time 
for a data transfer. We normally want a high bandwidth and low latency. Here are 
some ﬁ gures for several interconnects. 

407
27.9 Consistency Models
 27.8  Flynn’s Taxonomy 
 Flynn’s taxonomy is an old, but still widely used, classiﬁ cation scheme for com-
puter architecture.
 Single Instruction, Single Data stream (SISD) A sequential computer which 
• 
exploits no parallelism in either the instruction or data streams. Term rarely 
used. 
 Single Instruction, Multiple Data streams (SIMD) A computer which exploits 
• 
multiple data streams against a single instruction stream to perform operations 
which may be naturally parallelized. For example, an array processor or GPU. 
 Multiple Instruction, Single Data stream (MISD) Multiple instructions operate 
• 
on a single data stream. Term rarely used. 
 Multiple Instruction, Multiple Data streams (MIMD) Multiple autonomous pro-
• 
cessors simultaneously executing different instructions on different data. 
Distributed systems are generally recognized to be MIMD architectures; either 
exploiting a single shared memory space or a distributed memory space. 
Essentially separate computers working together to solve a problem. 
 We also have the term
 Single Program Multiple Data – An identical program executes on a MIMD 
• 
computer system. Conditional statements in the code mean that different parts of 
the program execute on each system. 
 27.9  Consistency Models 
 Parallel programming languages and parallel computers must have a consistency 
model (also known as a memory model). The consistency model deﬁ nes rules for 
how operations on computer memory occur and how results are produced. 

408
27 Introduction to Parallel Programming
 27.10  Threads and Threading 
 In computing a thread of execution is often regarded as the smallest unit of processing 
that can be scheduled by an operating system. The implementation of threads and 
processes generally varies with operating system. 
 27.11  Threads and Processes 
 From a strict computer science point of view threads and processes are different. 
However when looking simply at parallel programming the term can often be used 
interchangeably. In the following we use the term thread. 
 27.12  Data Dependencies 
 A data dependency is when one statement in a program depends on a calculation 
from a previous statement. This will obviously hinder parallelism. 
 27.13  Race Conditions 
 Race conditions can occur in programs when separate threads depend on a shared 
state or variable. 
 27.14  Mutual Exclusion – Mutex 
 A mutex is a programming construct that is used to allow multiple threads to share 
a resource. The sharing is not simultaneous. One thread will acquire the mutex and 
then lock the other threads from accessing it until it has completed. 
 27.15  Monitors 
 In concurrent programming, a monitor is an object or module intended to be used 
safely by more than one thread. The deﬁ ning characteristic of a monitor is that its 
methods are executed with mutual exclusion. That is, at each point in time, at most 
one thread may be executing any of its methods. This mutual exclusion greatly 
simpliﬁ es reasoning about the implementation of monitors compared with code that 
may be executed in parallel. 

409
27.19 Partitioned Global Address Space – PGAS
 27.16  Locks 
 In computing a lock is a synchronization mechanism for enforcing limits on access 
to a resource in an environment where there are many threads of execution. Locks 
are one way of enforcing concurrency control policies. 
 27.17  Synchronization 
 The concept of synchronisation is often split into process and data synchronisation. 
 In process synchronisation several processes or threads come together at a cer-
tain part of a program. 
 Data synchronisation is concerned with keeping data consistent. 
 27.18  Granularity and Types of Parallelism 
 Granularity is a useful concept in parallel programming. A common classiﬁ cation is
 Fine-grained – a lot of small components, larger amounts of communication and 
• 
synchronisation 
 Coarse-grained – a small number of larger components, hence smaller amounts 
• 
of communication and less synchronisation 
 The terms are of course relative. 
 We also have the concept of
 Embarrassingly parallel – very little effort is required to partition the task and 
• 
there is little or no communication and synchronisation. 
 A simple example of this would be a graphics processor processing individual 
pixels. 
 27.19  Partitioned Global Address Space – PGAS 
 PGAS is a parallel programming model. It assumes a global memory address space 
that is logically partitioned and a portion of it is local to each processor. The PGAS 
model is the basis of Uniﬁ ed Parallel C, Coarray Fortran, Titanium, Fortress, Chapel 
and X10. 

410
27 Introduction to Parallel Programming
 27.20  Fortran and Parallel Programming 
 Most Fortran compilers now offer support for parallel programming. We next 
 provide a brief coverage of three methods
 MPI – Message Passing Interface 
• 
 OpenMP – Open Multi-Processing 
• 
 CoArray Fortran 
• 
 Subsequent chapters look at simple examples using each method. 
 27.21  MPI 
 MPI started with a meeting that was held at the Supercomputing 92 conference. The 
attendants agreed to develop and implement a common standard for message pass-
ing. The ﬁ rst MPI standard, called MPI-1 was completed in May 1994. The second 
MPI standard, MPI-2, was completed in 1998. 
 MPI is effectively a library of C and Fortran callable routines. It has become 
widely used and is available on a number of platforms. Some useful web addresses 
are given below. 
 The ﬁ rst is hosted at Argonne National Laboratory.
 http://www.mcs.anl.gov/research/projects/mpi/  
 MPI was designed by a broad group of parallel computer users, vendors, and 
software writers. These included
 Vendors – IBM, Intel, TMC, Meiko, Cray, Convex, Ncube 
• 
 Library writers – PVM, p4, Zipcode, TCGMSG, Chameleon, Express, Linda 
• 
 Companies – ARCO, Convex, Cray Research, IBM, Intel, KAI, Meiko, NAG, 
• 
nCUBE, Parasoft, Shell, TMC 
 Laboratories – ANL, GMD, LANL, LLNL, NOAA, NSF, ORNL, PNL, Sandia, 
• 
SDSC, SRC 
 Universities – UC Santa Barbara, Syracuse University, Michigan State University, 
• 
Oregon Grad Inst, University of New Mexico, Mississippi State University, U of 
Southampton, University of Colorado, Yale University, University of Tennessee, 
University of Maryland, Western Michigan University, University of Edinburgh, 
Cornell University, Rice University, University of San Francisco 
 So whilst MPI is not a formal standard like Fortran, C or C++, its development 
has involved quite a wide range of people. 
 The following site has details of MPI meetings.
  http://meetings.mpi-forum.org/  

411
27.21 MPI
 The steering committee (as of April 2011) and afﬁ liations are given below
 Jack Dongarra – Computer Science Department, University of Tennessee 
• 
 Al Geist – Group Leader, Computer Science Research Group, Oak Ridge 
• 
National Laboratory 
 Richard Graham 
• 
 Bill Gropp – Computer Science Department, University of Illinois Urbana- 
• 
Champaign  
 Andrew Lumsdaine – Computer Science Department, Indianna University 
• 
 Ewing Lusk – Mathematics and Computer Science Division, Argonne National 
• 
Laboratory 
 Rolf Rabenseifner – High Performance Computing Center, Germany 
• 
 The meeting coordinators and associated work areas as of April 2011 are given 
below
 Richard Graham, Convener and Meeting Chair 
• 
 Jeff Squyres, Meeting Secretary 
• 
 Bill Gropp, Ballots 
• 
 Rolf Rabenseifner, MPI 2.1 
• 
 Bill Gropp, MPI 2.2 
• 
 Torsten Hoeﬂ er, Andrew Lumsdaine, MPI 3.0 – Collective Communications 
• 
 Richard Graham, MPI 3.0 – Fault Tolerance 
• 
 Craig Rasmussen, MPI 3.0 – Fortran Bindings 
• 
 Bill Gropp and Rajeev Thakur, MPI 3.0 – Remote Memory Access 
• 
 Martin Schulz and Bronis de Supinski, MPI 3.0 – Tools support 
• 
 Pavan Balaji, MPI 3.0 – Hybrid Programming 
• 
 Anthony Skjellum, MPI 3.0 – Persistence 
• 
  Ron Brightwell – MPI 3.0 – Point-To-Point Communications and this provides 
• 
an idea of the work currently in progress. 
 Another useful site is the Open MPI site.
  http://www.open-mpi.org/  
 The following is taken from their site. 
 The Open MPI Project is an open source MPI-2 implementation that is devel-
oped and maintained by a consortium of academic, research, and industry partners. 
Open MPI is therefore able to combine the expertise, technologies, and resources 
from all across the High Performance Computing community in order to build the 
best MPI library available. Open MPI offers advantages for system and software 
vendors, application developers and computer science researchers. 
 Features implemented or in short-term development for Open MPI include:
 Full MPI-2 standards conformance 
• 
 Thread safety and concurrency 
• 
 Dynamic process spawning 
• 
 Network and process fault tolerance 
• 

412
27 Introduction to Parallel Programming
 Support network heterogeneity 
• 
 Single library supports all networks 
• 
 Run-time instrumentation 
• 
 Many job schedulers supported 
• 
 Many OS’s supported (32 and 64 bit) 
• 
 Production quality software 
• 
 High performance on all platforms 
• 
 Portable and maintainable 
• 
 Tunable by installers and end-users 
• 
 Component-based design, documented APIs 
• 
 Active, responsive mailing list 
• 
 Open source license based on the BSD license 
• 
 Both sites provide free downloadable implementations. 
 Commercial implementations are available from
 Cray 
• 
 IBM 
• 
 Intel 
• 
 Microsoft  
• 
amongst others. 
 MPI is, at the time of writing, the dominant parallel programming method used 
in Fortran. MPI and Fortran currently account for over 80% of the code running on 
the HECToR Service in Edinburgh. HECToR is the UK’s high-end computing 
resource, funded by the UK Research Councils. Visit
  http://www.hector.ac.uk  
for more information. 
 27.22  OpenMP 
 OpenMP (Open Multi-Processing) is an application programming interface that 
supports shared memory multiprocessing programming in three main languages (C, 
C++, and Fortran) on a range of hardware platforms and operating systems. It con-
sists of a set of compiler directives, library routines, and environment variables that 
determine the run time behaviour of a program. 
 The OpenMP Architecture Review Board (ARB) has published several versions
 October 1997 – OpenMP for Fortran 1.0. October the following year they released 
• 
the C/C++ standard. 
 2000 – Fortran version 
• 
 2005 – Fortran 2.5 
• 

413
27.24 Other Parallel Options
 2008 – OpenMP 3.0. Included in the new features in 3.0 is the concept of tasks 
• 
and the task construct. 
 2011-OpenMP 3.1 
• 
 A number of compilers from various vendors or open source communities imple-
ment the OpenMP API, including
 Absoft 
• 
 Cray 
• 
 gnu 
• 
 Hewlett Packard 
• 
 IBM 
• 
 Intel 
• 
 Lahey/Fujitsu 
• 
 Oracle/Sun 
• 
 PGI 
• 
 The main OpenMP web site is:
  http://www.openmp.org/  
 27.23  Coarray Fortran 
 Coarrays became part of Fortran in the 2008 standard. The original ideas came from 
work by Robert Numrich and John Reid in the 1990s. They are based on a single 
program multiple data model. A coarray Fortran program is interpreted as if it were 
duplicated several times and all copies execute asynchronously. Each copy has its 
own set of data objects and is termed an image. The array syntax of Fortran is 
extended with additional trailing subscripts in square brackets to provide a concise 
representation of references to data that is spread across images. 
 The syntax is architecture independent and may be implemented on:
 Distributed memory machines. 
• 
 Shared memory machines. 
• 
 Clustered machines. 
• 
 Work is underway for additional Coarray functionality for the next standard. 
 27.24  Other Parallel Options 
 There are a number of additional parallel methods. They are covered for 
completeness. 

414
27 Introduction to Parallel Programming
 27.24.1  PVM 
 Parallel Virtual Machine consists of a library and a run-time environment which 
allow the distribution of a program over a network of (even heterogeneous) comput-
ers. Visit
 
• http://www.epm.ornl.gov/pvm/ 
 
• http://www.netlib.org/pvm3/ 
for more details. 
 27.24.2  HPF 
 To quote their home page
 
• http://hpff.rice.edu/index.htm 
 ‘The High Performance Fortran Forum (HPFF), a coalition of industry, academic and 
laboratory representatives, works to deﬁ ne a set of extensions to Fortran 90 known col-
lectively as High Performance Fortran (HPF). HPF extensions provide access to high-
performance architecture features while maintaining portability across platforms.’ 
 They also provide details of:
 Surveys of HPF compilers and tools. 
• 
 Currently available commercial HPF compilers. 
• 
 public domain HPF compilation systems. 
• 
 Research prototypes of HPF and HPF-related compilation systems. 
• 
 Mailing list. 
• 
 27.25  Top 500 Supercomputers 
 Have a look at
 
• http://www.top500.org/ 
for a lot of links to supercomputing centres and information on parallel computing 
in general. 
 To see what can be done with all this processing power visit:
 
• http://www.met-ofﬁ ce.gov.uk/ 

415
27.27 Bibliography
 27.26  Summary 
 Fortran has long been one of the main languages used in parallel programming. This 
chapter has provided a brief coverage of some of the background to parallel pro-
gramming in general, and Fortran in particular. 
 In the next three chapters we will look at a small number of programs that 
 introduce some of the basic syntax of parallel programming with MPI, OpenMP and 
Coarray Fortran. We will also look at solving one problem serially and then solve it 
using the parallel features provided by MPI, OpenMP and Coarray Fortran. We 
provide timing details so that we can see the beneﬁ ts that parallel solutions offer. 
 27.27  Bibliography 
 The ideas involved in parallel computing are not new and we’ve included a couple 
of references about computer hardware and operating systems, which provide infor-
mation for the more inquisitive reader. Wikipedia is an on-line source of informa-
tion in this area. 
 27.27.1  Computer Hardware 
 Baer , J.L.: Computer Systems Architecture. Computer Science Press, Rockville 
(1980) 
 The chapters on the memory hierarchy and memory management are old, but 
well written. Up to date hardware information can be found at most hardware ven-
dor sites. A few are given below. 
 27.27.1.1 AMD 
 http://developer.amd.com/pages/default.aspx  
 27.27.1.2 IBM 
  http://www.ibm.com/products/us/en/  
 27.27.2  Intel 
 http://www.intel.com/en  
 UK/products/processor/index.htm  

416
27 Introduction to Parallel Programming
 27.27.3  Computer Operating Systems 
 Deitel, H.M.: Operating Systems. Addison Wesley, Reading (1990) 
 Part two of the book (process management) has chapters on process concepts, 
asynchronous concurrent processes, concurrent programming and deadlock and 
indeﬁ nite postponement. The bibliographies at the end of each chapter are quite 
extensive. 
 27.27.4  Parallel Programming 
 Chandra , R., Dagum, L., Kohr, D., Maydan, D., McDonald, J., Menon, R.: Parallel Programming 
in OpenMP. Morgan Kaufmann, San Francisco 
 Chapman, B., Jost, G., Van Der Pas, R.: Using OpenMP. MIT Press, Cambridge 
 Gropp, W., Lusk, E., Skjellum, A.: Using MPI: Portable Parallel Programming with the Message 
Passing Interface. MIT Press, Cambridge 
 Pacheco, P.: Parallel Programming with MPI. Morgan Kaufmann, San Francisco 

417
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_28, © Springer-Verlag London Limited 2012
 Aim 
 The aims of this chapter is to provide a short introduction to MPI programming in 
Fortran. 
 28.1  Introduction 
 Documents for the MPI standard are available from the MPI Forum. Their web 
address is
 http://www.mpi-forum.org 
 If you are going to do MPI programming we recommend getting hold of the 
document that refers to your implementation. 
 28.2  MPI Programming 
 MPI programming typically requires two components, a compiler and an MPI 
implementation. 
 Chapter 28 
 MPI – Message Passing Interface 
 In almost every computation a great variety of arrangements 
for the succession of the processes is possible, and various 
considerations must inﬂ uence the selections amongst them for 
the purposes of a calculating engine. One essential object is to 
choose that arrangement which shall tend to reduce to a 
minimum the time necessary for completing the calculation. 
 Ada Lovelace 

418
28 MPI – Message Passing Interface
 There are also two ways of doing MPI programming
 a cluster or multiple systems running MPI 
• 
 a single system running MPI 
• 
 In both cases an MPI installation will normally provide an MPI daemon or ser-
vice that can then be called from an MPI program. 
 28.3  Compiler and Implementation Combination 
 A number of commercial companies provide a combined bundle including
 Cray 
• 
 IBM 
• 
 Intel 
• 
 PGI 
• 
 The Cray and IBM offerings will most likely be for a cluster. Intel and PGI 
provide products for both clusters and single systems. You should check their sites 
for up to date information. 
 28.4  Individual Implementation 
 A low cost option is to get hold of an MPI implementation that works with your 
existing compiler, and install it yourself on your own system. 
 The Intel MPI product is available as a free download for evaluation purposes. 
 There are a number of free MPI implementations, and details are given below for 
two of them. 
 28.4.1  MPICH2 
 They are based at Argonne National Laboratory
 http://www.mcs.anl.gov/research/projects/mpich2/ 
 MPICH2 is distributed as source (with an open-source, freely available license). 
It has been tested on several platforms, including Linux (on IA32 and x86–64), Mac 
OS/X (PowerPC and Intel), Solaris (32- and 64-bit), and Windows. 
 28.4.2  Open MPI 
 They can be found at 

419
28.7 Example 1 – Hello World
 http://www.open-mpi.org/ 
 They develop Open MPI on Linux, OS X, Solaris (both 32 and 64 on all plat-
forms) and Windows (Windows XP, Windows HPC Server 2003/2008 and also 
Windows 7 RC). 
 28.5  Compiler and MPI Combinations Used in the Book 
 The examples in this chapter have been tried out with a variety of compilers and 
implementations, including
 Intel compiler + mpich2, Windows 
• 
 Intel compiler + Intel MPI, Windows 
• 
 Gfortran + openmpi, SuSe Linux 11.x 
• 
 Cray compiler, Hector Service 
• 
 PGI compiler, Hector Service 
• 
 IBM compiler, Met Ofﬁ ce Slovakia 
• 
 We haven’t tried out all of the examples with all of the compiler and MPI 
implementations. 
 28.6  The MPI Memory Model 
 MPI is characterised generally by distributed memory and
 All threads/processes have access to their own private memory only 
• 
 Data transfer and most synchronization has to be programmed explicitly 
• 
 All data is private 
• 
 Data is shared explicitly by exchanging buffers in MPI terminology 
• 
but in this chapter we will also show the use of MPI on one system. 
 28.7  Example 1 – Hello World 
 The ﬁ rst example is the classic hello world program. This example has been run on 
the following systems:
 Single system, Intel compiler and mpich2, Windows 
• 
 Single system, Intel compiler and Intel MPI, Windows 
• 
 Single system, gfortran and openmpi, SuSe linux 
• 
 Cray HECToR service, Edinburgh 
• 

420
28 MPI – Message Passing Interface
 Here is the program.
 program ch2801  
 use mpi  
 implicit none  
 integer :: error number  
 integer :: this process number  
 integer :: number_of_processes 
 call MPI_INIT( error_number )  
 call MPI_COMM_SIZE( MPI_COMM_WORLD, &  
 number_of_processes , error_number ) 
 call MPI_COMM_RANK( &
MPI_COMM_WORLD, &  
 this_process_number , &
error_number ) 
 print *, " Hello from process " ,&  
 this_process_number , &
" of ", number_of_processes , &
" processes!" 
 call MPI_Finalize(error_number)  
 end program ch2801  
 Let us look at each statement in turn.
 use mpi  
 With most modern MPI implementations we can make available the MPI setup 
with a use statement. Older implementations required an include ﬁ le option.
 call MPI_INIT( error_number )  
 This must be the ﬁ rst MPI routine called. The Fortran binding only takes one 
argument, an integer variable that is used to return an error number. It sets up the 
MPI environment.
 call MPI_COMM_SIZE( MPI_COMM_WORLD, &
number_of_processes , error_number )  
is typically the second MPI routine called. All MPI communication is associated 
with a so called communicator that describes the communication context and an 
associated set of processes. In this simple example we use the default communicator, 
called MPI_COMM_WORLD. The number of processes available is returned via 
the second argument. This means that the above program is duplicated on each 
process, i.e. number_of_processes determines how many copies are running.
 call MPI_COMM_RANK( MPI_COMM_WORLD, &
this_process_number , error_number )  
 The call above returns the process number for this process or copy of the 
program.

421
28.7 Example 1 – Hello World
 print *, " Hello from process " , &  
 this_process_number , " of ", number_of_processes , &
" processes!" 
 Each copy of the program will print out this message.
 call MPI_Finalize(error_number)  
 The call to MPI_Finalize is the last call to the MPI system we need to make. 
 Here is the output from the Intel compiler and Intel MPI option under Windows 
XP64. 
 Notice that process numbering starts at 0. Note also that there is no particular 
order to the process numbers. 
 Here is the output from gfortran and openmpi on a SuSe 11.2 Linux box. This is 
the same system as the above, as it is dual boot. 

422
28 MPI – Message Passing Interface
 Now the ordering is sequential. 
 Here is the output from the Cray HECToR service. This uses 64 processes. 
The job is submitted as a batch job, via a queueing mechanism. This is a common 
mechanism on larger multi user systems.
 Hello from process 3 of 64 processes!  
 Hello from process 0 of 64 processes!  
 Hello from process 1 of 64 processes!  
 Hello from process 2 of 64 processes!  
 Hello from process 61 of 64 processes!  
 Hello from process 60 of 64 processes!  
 Hello from process 63 of 64 processes!  
 Hello from process 62 of 64 processes!  
 Hello from process 56 of 64 processes!  
 Hello from process 59 of 64 processes!  
 Hello from process 57 of 64 processes!  
 Hello from process 58 of 64 processes!  
 Hello from process 40 of 64 processes!  
 … 
 …lines deleted  
 … 
 Hello from process 33 of 64 processes!  
 Hello from process 46 of 64 processes!  
 Hello from process 45 of 64 processes!  
 Hello from process 47 of 64 processes!  
 Hello from process 44 of 64 processes!  
 Hello from process 4 of 64 processes!  
 Hello from process 7 of 64 processes!  
 Hello from process 5 of 64 processes!  
 Hello from process 6 of 64 processes!  
 The order appears to be pretty random! 
 28.8  Example 2 – Hello World Using Send and Receive 
 The following is a variation of the above. In the ﬁ rst example we had no communi-
cation between processes. Sending and receiving of messages by processes is the 
basic MPI communication mechanism. The basic point-to-point communication 
operations are send and receive. Their use is shown in the example below. These are 
blocking send and receive operations. A blocking send does not return until the 
message data and envelope have been safely stored away so that the sender is free 
to modify the send buffer. The message might be copied directly into the matching 
receive buffer, or it might be copied into a temporary system buffer. 

423
28.8 Example 2 – Hello World Using Send and Receive
 In this example process 0 is the master process and this communicates with every 
other process or program.
 program ch2802  
 use mpi  
 implicit none  
 integer :: error_number  
 integer :: this_process_number  
 integer :: number_of_processes  
 integer :: I  
 integer , dimension(MPI_STATUS_SIZE) :: status 
 call MPI_INIT( error_number )  
 call MPI_COMM_SIZE( MPI_COMM_WORLD, &  
 number_of_processes , error_number ) 
 call MPI_COMM_RANK( MPI_COMM_WORLD, &  
 this_process_number , error_number ) 
 if ( this_process_number == 0 ) then  
 print *, " Hello from process " , &  
 this_process_number , " of ", number_of_processes , &
" processes." 
 do I = 1 , number_of_processes - 1  
 call MPI_RECV(this_process_number , &  
 1 , MPI_INTEGER , I , 1 , MPI_COMM_WORLD , status , & 
error_number) 
 print *, " Hello from process " , &  
 this_process_number , " of ", number_of_processes , &
" processes." 
 end do  
 else 
 call MPI_SEND(this_process_number , 1 , &
MPI_INTEGER , 0 , 1 , MPI_COMM_WORLD , &
error_number)  
 end if  
 call MPI_Finalize(error_number)  
 end program ch2802  
 The calls to MPI_INIT, MPI_COMM_SIZE, MPI_COMM_RANK, MPI_
Finalize are the same as in the ﬁ rst example. We have the additional code
 A test to see if we are process 0. If we are we then print out a message saying that 
• 
we are process 0. We next loop from 1 to number_of_processes −1 and call 
MPI_RECV. 
 If we are not process 0 we make a call to MPI_SEND – remember that the pro-
• 
gram executes on all processes. 
 Let us look at the calls to MPI_RECV and MPI_SEND in more depth. Here is an 
extract from the 2.2 speciﬁ cation describing MPI_RECV

424
28 MPI – Message Passing Interface
 <type> BUF(*), initial address of receive buffer 
• 
 INTEGER COUNT , Number of elements in the receive buffer 
• 
 DATATYPE , data type of each receive buffer element 
• 
 SOURCE , rank of source 
• 
 TAG , message tag 
• 
 COMM , communicator 
• 
 STATUS(MPI_STATUS_SIZE), 
• 
 IERROR 
• 
 The following shows the mapping between MPI data types and Fortran data 
types. 
 MPI datatype 
 Fortran datatype 
 MPI_INTEGER 
 INTEGER 
 MPI_REAL 
 REAL 
 MPI_DOUBLE_PRECISION 
 DOUBLE PRECISION 
 MPI_COMPLEX 
 COMPLEX 
 MPI_LOGICAL 
 LOGICAL 
 MPI_CHARACTER 
 CHARACTER(1) 
 Our arguments to MPI_RECV are
 this_process_number - process 0 is doing the receiving 
• 
 1 item 
• 
 MPI_INTEGER – an MPI_INTEGER variable 
• 
 I – receive from this process 
• 
 1 – tag 
• 
 MPI_COMM_WORLD - the communicator 
• 
 status – an integer array of size MPI_STATUS_SIZE 
• 
 error_number 
• 
 Here is an extract from the 2.2 speciﬁ cation regarding MPI_SEND
 <type> BUF(*) – initial address of send buffer 
• 
 INTEGER COUNT – number of elements in send buffer 
• 
 DATATYPE – data type of each send buffer element 
• 
 DEST – rank of destination 
• 
 TAG – message tag 
• 
 COMM – communicator 
• 
 IERROR – error number 
• 
 The arguments to our MPI_SEND are
 this_process_number – send from this process 
• 
 1 
• 
 MPI_INTEGER 
• 
 0 – send to this process number 
• 

425
28.9 Example 3 – Serial Solution for pi Calculation
 1 
• 
 MPI_COMM_WORLD – the communicator 
• 
 error_number 
• 
and as you can see the sends and receives are in matching pairs. 
 The output from this program will be similar to the previous example. 
 28.9  Example 3 – Serial Solution for pi Calculation 
 We choose numerical integration in this example. The following integral
 
 
+
∫
1
2
0
4
1
dx
x
  
is one way of calculating an approximation to  p , and is a problem that is easy to 
parallelise. The integral can be approximated by
 
 
−
⎛
⎞
+ ⎜
⎟
⎝
⎠
∑
2
1
1
4
0.5
1
n
n
i
n
  
 p to 50 digits is
3.14159265358979323846264338327950288419716939937510
according to Wikipedia 
 Another way of calculating  p is using the formula 4 tan −1 (1), and in Fortran this is
 4.0*atan(1.0).  

426
28 MPI – Message Passing Interface
 Consider the following plot of the above equation. 
 To do the evaluation numerically we divide the interval between 0 and 1 into n 
sub intervals. The higher the value of n the more accurate our value of  p will be, or 
should be. 
 Here is a serial program to do this calculation. The program is in three main 
parts. These are
 precision module – to set the precision throughout the whole code. 
• 
 timing module – a timing module to enable us to time parts of the program. We 
• 
will be using this module throughout the parallel examples to provide informa-
tion about the performance of the algorithms. 
 the program – that actually does the integration. 
• 
 The ﬁ rst two modules are straightforward and we will only cover the integration 
solution in depth. We will be using this integration example in this chapter on MPI 
and the subsequent two on OpenMP and coarray Fortran.
 module precision_module  
 implicit none  
 integer, parameter :: long = &  
 selected_real_kind(15,307)  
 end module precision_module  
 module timing_module 
 implicit none  
 integer, dimension (8), private :: dt  
 real, private :: h, m, s, ms, tt  
 real, private :: last_tt  
 contains 
 subroutine start_timing()
 implicit none  
 call date_and_time(values=dt)  
 print 100, dt(1:3), dt(5:8)  
 100 format &  
 (1x,i4,'/',i2,'/',i2,1x,i2,':',i2,':',i2,1x,i3)  
 h = real(dt(5))  
 m = real(dt(6))  
 s = real(dt(7))  
 ms = real(dt(8))  
 last_tt = 60*(60*h+m) + s + ms/1000.0  
 end subroutine start_timing  
 subroutine print_date_and_time 
 implicit none  

427
28.9 Example 3 – Serial Solution for pi Calculation
 call date_and_time(values=dt)  
 print 100, dt(1:3), dt(5:8)  
 100 format &  
 (1x,i4,'/',i2,'/',i2,1x,i2,':',i2,':',i2,1x,i3)  
 end subroutine print_date_and_time  
 subroutine print_hms 
 implicit none  
 call date_and_time(values=dt)  
 print 100, dt(5:8)  
 100 format (1x,i2,':',i2,':',i2,1x,i3)  
 end subroutine print_hms  
 subroutine print_ms 
 implicit none  
 call date_and_time(values=dt) 
 h = real(dt(5))  
 m = real(dt(6))  
 s = real(dt(7))  
 ms = real(dt(8))  
 tt = 60*(60*h+m) + s + ms/1000.0  
 print 100, tt  
 100 format (1x,f14.3)  
 end subroutine print_ms  
 subroutine print_time_difference 
 implicit none  
 call date_and_time(values=dt)  
 h = real(dt(5))  
 m = real(dt(6))  
 s = real(dt(7))  
 ms = real(dt(8))  
 tt = 60*(60*h+m) + s + ms/1000.0  
 print 100, (tt-last_tt)  
 100 format (1x,f14.3)  
 last_tt = tt  
 end subroutine print_time_difference  
 real function time_difference() 
  implicit none  
 tt = 0.0  
 call date_and_time(values=dt)  
 h = real(dt(5))  
 m = real(dt(6))  
 s = real(dt(7))  

428
28 MPI – Message Passing Interface
 ms = real(dt(8))  
 tt = 60*(60*h+m) + s + ms/1000.0  
 time_difference = tt - last_tt  
 end function time_difference  
 end module timing_module  
 program ch2803 
 use precision_module  
 use timing_module  
 implicit none  
 integer :: I, j  
 integer :: n_intervals  
 real (long) :: interval_width, x, total, pi  
 real (long) :: fortran_internal_pi  
 call start_timing()  
 n_intervals = 10  
 fortran_internal_pi = 4.0_long*atan(1.0_long)  
 print *, ' fortran_internal_pi = ', &  
 fortran_internal_pi  
 print *, ' '  
 do j = 1, 9 
 interval_width = 1.0_long/n_intervals  
 total = 0.0_long  
 do I = 1, n_intervals 
 x = interval_width*(real(i,long)-0.5_long)  
 total = total + f(x)  
 end do  
 pi = interval_width*total  
 print 20, n_intervals, time_difference()  
 20 format (' N intervals = ',i12,' time = ',f8.3)  
 print 30, pi, abs(pi-fortran_internal_pi)  
 30 format (' pi = ',f20.16,/, &  
 ' difference = ',f20.16)  
 n_intervals = n_intervals*10  
 end do  
  contains 
 real (long) function f(x)
 implicit none  
 real (long), intent (in) :: x  
 f = 4.0_long/(1.0_long+x*x)  
 end function f  
 end program ch2803  

429
28.9 Example 3 – Serial Solution for pi Calculation
 The ﬁ rst part of the code has the declarations for the variables we will be using. 
These are
 integer :: n_intervals  
 real (long) :: interval_width, x, total, pi  
 real (long) :: fortran_internal_pi  
 We have an integer variable for the number of intervals we will be using. We 
have made this of default integer type, which will be 32 bit on most platforms, and 
will be up to 2,147,483,647. 
 We then have the following variables
 interval_width 
• 
 x – the variable we will be calculating numerically 
• 
 total – our total for the integration 
• 
 pi – our calculated value of pi 
• 
 fortran_internal_pi – we use a common way of deﬁ ning this using the internal 
• 
atan function. 
 We then call the start_timing routine to print out details of the start time. 
 We next set the number of intervals. We choose 10 as an initial value. We will be 
doing the calculation for a number of interval sizes. 
 We calculate pi using the atan intrinsic and print out its value. We will be using 
this value to determine the accuracy of our calculations. 
 We then have the loop that does the calculations for nine values of the interval 
size from 10 to 1,000,000,000. 
 We calculate the interval width at the start of each loop and reset the total to zero 
at the start of each loop. 
 The following
 do I = 1, n_intervals
 x = interval width*(real(i,long)-0.5_long)  
 total = total + f(x)  
 end do  
is the code that actually does the integration. We calculate x each time round the 
loop and then use this calculated value in our call to our function, summing up as 
we go along. We need to subtract a ½ as we need the midpoint of the interval for our 
value of x. 
 The loop ﬁ nishes and we then calculate the value of pi and print out details of the 
number of intervals, the calculated value of pi and the difference between the inter-
nal value of pi and the calculated value. 

430
28 MPI – Message Passing Interface
 We also print out timing information about this calculation. We then increment 
the number of intervals and repeat the above. 
 We need to know how long the serial version takes and how accurate our calcu-
lated value for pi is. 
 Here is output from this program on a couple of systems and compilers. 

431
28.9 Example 3 – Serial Solution for pi Calculation

432
28 MPI – Message Passing Interface
 The three sample runs provide us with information that we can use as a basis for 
an analysis of our parallel solution. We have information about the accuracy of the 
solution and timing details. 
 28.10  Example 4 – Parallel Solution for pi Calculation 
 This example is a parallel solution to the above problem using mpi. We only show 
the parallel program. The precision and timing modules are the same as in the previ-
ous example. 

433
28.10 Example 4 – Parallel Solution for pi Calculation

434
28 MPI – Message Passing Interface
 The ﬁ rst difference is the
 use mpi  
statement. This makes available the mpi functionality. We next have several vari-
able declarations.
 real (long) :: fortran_internal_pi  
 real (long) :: partial_pi  
 real (long) :: total_pi  
 real (long) :: width  
 real (long) :: partial_sum  
 real (long) :: x  
 integer :: n  
 integer :: this process  
 integer :: n_processes  
 integer :: I  
 integer :: j  
 integer :: error_number  
 The variables partial_pi, total_pi and partial_sum are required by our parallel 
algorithm. The variable n is the number of intervals and we start this at 100,000 
rather than 10 as we have seen from the serial solution that there are quite large dif-
ferences between the internal value of pi and the calculated value below 100,000. 

435
28.10 Example 4 – Parallel Solution for pi Calculation
 The variables this _process, n_processes and error_number are required for the 
mpi solution. 
 The real work is done in the following do loop.
 do I = this_process + 1, n, n_processes  
 x = width*(real(i,long)-0.5 long)  
 partial_sum = partial_sum + f(x)  
 end do  
 The key is to split up the work of the calculation between the processes we have 
available. The following shows how the work will be split up for n = 10 and with the 
number of processes ranging from 1 to 8. 
 The above also shows how the algorithm balances the load of the computation 
across the processes. 
 Each process has its own partial_sum and partial_pi. We then use the call to the 
MPI subroutine mpi_reduce to calculate the total value of pi from the partial values 
of pi. Here is the MPI description of the mpi_reduce routine
 MPI_REDUCE( sendbuf, recvbuf, count, datatype, op, root, comm) 
 IN sendbuf address of send buffer (choice) 
 OUT recvbuf address of receive buffer (choice, signiﬁ cant only at root) 
 IN count number of elements in send buffer (non-negative integer) 
 IN datatype data type of elements of send buffer (handle) 
 IN op reduce operation (handle) 
 IN root rank of root process (integer) 
 IN comm communicator (handle) 
and

436
28 MPI – Message Passing Interface
 partial_pi is our send buffer 
 total_pi is our receive buffer 
 1 – the number of elements 
 mpi_double_precision – the type of the elements 
 mpi_sum – the reduction operation 
 0 – the root process 
 mpi_comm_world – the communicator 
 error_number – the error number 
 We then control the printing from process 0. 
 Here is sample output from the Intel compiler for 1, 4, 8 and 32 processes. Results 
are similar from gfortran. We can control how many processes are available from 
the command line. We will look at the Cray compiler and the Hector service later. 

437
28.10 Example 4 – Parallel Solution for pi Calculation

438
28 MPI – Message Passing Interface
 The system that the above output is from has an Intel Core i7 920 processor. This 
processor has four cores and each core is hyper threaded. We get a nearly linear 
speed up to four processes, which shows how good the parallel solution is. Note that 
the time value is not the total time taken by all processes, but rather the effective 
running time of the program. If we are sat in front of the pc the program would 
complete in about a quarter of the time of the serial version. The numerical results 
are similar to the serial solution. The eight and thirty two process versions have 
similar times to the four process version. 
 Here is the output from the Cray at the Hector service. This is for 64 processes 
running on 16 nodes. Each compute node contains two AMD 2.1 GHz 12 core 
processors. 
 As can be seen this represents a major time reduction over the serial version from 
4.297 to 0.180 s – a factor of approximately 24. 

439
28.11 Example 5 – Work Sharing Between Processes
 Here is the output from 96 processes on 4 nodes. 
 
 Again we have a considerable speed up, a factor of approximately 35. 
 28.11  Example 5 – Work Sharing Between Processes 
 This example looks at one way of splitting work up between processes. We use the 
process number of determine which process does which work.
 program ch2805  
 use mpi  
 implicit none  
 integer :: error_number  
 integer :: this_process_number  
 integer :: number_of_processes  
 integer, dimension (mpi_status_size) :: status  
 integer, allocatable, dimension (:)::x  
 integer :: n  
 integer, parameter :: factor = 5  
 integer :: i, j, k  
 integer :: start  
 integer :: end  
 integer : recv_start 

440
28 MPI – Message Passing Interface
 call mpi_init(error_number)  
 call mpi_comm_size(mpi_comm_world, & 
 number_of_processes,error_number)  
 call mpi_comm_rank(mpi_comm_world,& 
 this_process_number,error_number)  
 n = number_of_processes*factor  
 allocate (x(1:n))  
 x = 0 
 start = (factor*this_process_number) + 1  
 end = factor*(this_process_number+1)  
 print 10,this_process_number, start, end  
 10 format(' Process number = ',i3,' start ', & 
 i3,' end ',i3)  
 do i = start, end 
 x(i) = i*factor  
 end do  
 do i = 1, n 
 print 20 , this_process_number, i, x(i)  
 20 format(1x,i4, ' i ',i4,' x(i) ',i4)  
 end do  
 if (this_process_number==0) then 
 do i = 1, number_of_processes – 1  
 recv_start = (factor*i)+ 1  
 call mpi_recv(x(recv_start),& 
 factor,mpi_integer,i,1,mpi_comm_world, &  
 status ,error_number)  
 end do  
 else 
 call mpi_send(x(start) , factor, &  
 mpi_integer,0,1,mpi_comm_world,error_number)  
 end if  
 if (this_process_number==0) then 
 do i = 1, n  
 print 30, I, factor, x(i)  
 30 format (1x,i4,' * ',i2,' = ',i5)  
 end do  
  end if  
 call mpi_ﬁ nalize(error_number)  
 end program ch2805 
 What we are going to do is allocate an array based on the number of processes 
and then split the (simple) work on the array up between the processes. We will 
calculate array indices from the process numbers.

441
28.11 Example 5 – Work Sharing Between Processes
 n = number_of_processes*factor  
 This statement calculates the array size based on the number of processes and a 
constant factor.
 allocate (x(1:n))  
 This statement allocates the array.
 x = 0 
 This statement initialises the whole array to zero. The following statements 
deﬁ ne the start and end points for the array processing for each process.
 start = (factor*this_process_number) + 1  
 end = factor*(this_process_number+1)  
and partition the work up between the processes. Each process will have its own 
start and end values. The following do loop does the work:
 do I = start, end  
 x(i) = i*factor  
 end do  
and all we are doing as this is ﬁ lling sections of the array up with data based in 
process numbers. 
 The following
 if (this_process_number==0) then 
 do i = 1, number_of_processes – 1 
 recv_start = (factor*i) + 1  
 call mpi_recv(x(recv_start), & 
 factor,mpi_integer,i,1,mpi_comm_world,&  
 status ,error_number)  
 end do  
 else 
 call mpi_send(x(start) , factor, & 
 mpi_integer,0,1,mpi_comm_world,error_number)  
 end if  
uses sends and receives to transfer the updated array sections back to process zero. 
We are using recv_start to specify the starting point for the array transfer, and 
x(start) is the starting point for the transfer from the x array to process zero. 

442
28 MPI – Message Passing Interface

443
28.12 Summary
 Here is sample output from the program when the number of processes is three. 
 So with three processes we have an array of size 15, and the work that each pro-
cess does is
 Process number  
• 
= 0 start 1 end 5 
 Process number = 1 start 6 end 10 
• 
 Process number  
• 
= 2 start 11 end 15 
and each process works on its own section of the array. At the end we use the 
sends and receives to make sure that the x array on process zero now has all of 
the updated values. 
 This code achieves load balancing across the processes. 
 28.12  Summary 
 The programs in this chapter provide an introduction to the use of MPI to achieve 
parallel programs in Fortran. We have also seen some of the timing beneﬁ ts of paral-
lel programming with MPI. 

444
28 MPI – Message Passing Interface
 28.13  Problem 
 1.  Compile and run the programs with your compiler and implementation of MPI. 
You should get similar results.  

445
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_29, © Springer-Verlag London Limited 2012
 Aim 
 The aims of this chapter is to provide a short introduction to OpenMP programming 
in Fortran. 
 29.1  Introduction 
 The main site is
 http://openmp.org/wp/   
and this site has details about the various speciﬁ cations
  http://openmp.org/wp/openmp-speciﬁ cations/  
 We recommend downloading the documentation if you are going to do OpenMP 
programming. You should visit
  http://openmp.org/wp/openmp-compilers/  
to see an up to date list of what compilers support the OpenMP speciﬁ cation, and at 
what level. 
 The OpenMP site has a range of resources available, check out
  http://openmp.org/wp/resources  
for more information. 
 Chapter 29 
 OpenMP 
 The best way to have a good idea is to have a lot of ideas. 
 Linus Pauling 

446
29 OpenMP 
 We’ve run the examples in this chapter with one or more of the following compilers
 Cray 
• 
 Gfortran 
• 
 Intel 
• 
 29.2  OpenMP Memory Model 
 OpenMP is a shared memory programming model. It has several features including
 All threads have access to the same shared memory 
• 
 Data can be shared or private 
• 
 Data transfer is transparent to the programmer 
• 
 Synchronization takes place and is generally implicit 
• 
 We will look at a small number of examples to highlight some of the key fea-
tures. We provide a brief coverage of some of the OpenMP glossary to provide a 
basic background to OpenMP.
 Threading Concepts
• 
 Thread – An execution entity with a stack and associated static memory, 
 –
called threadprivate memory. 
 OpenMP thread – A thread that is managed by the OpenMP runtime system. 
 –
  Thread-safe routine – A routine that performs the intended function even 
 –
when executed concurrently (by more than one thread). 
 OpenMP language terminology
• 
 Structured block – For Fortran, a block of executable statements with a single 
 –
entry at the top and a single exit at the bottom. 
 Loop directive – An OpenMP executable directive whose associated user 
 –
code must be a loop that is a structured block. For Fortran, only the do direc-
tive and the optional end do directive are loop directives. 
 Master thread – The thread that encounters a parallel construct, creates a team, 
 –
generates a set of tasks, then executes one of those tasks as thread number 0. 
  Worksharing construct – A construct that deﬁ nes units of work, each of which is 
 –
executed exactly once by one of the threads in the team executing the construct. 
For Fortran, worksharing constructs are do, sections, single and workshare.  
 Barrier – A point in the execution of a program encountered by a team of 
 –
threads, beyond which no thread in the team may execute until all threads in 
the team have reached the barrier and all explicit tasks generated by the team 
have executed to completion. 
 Data Terminology
• 
 Variable – A named data object, whose value can be deﬁ ned and re deﬁ ned 
 –
during the execution of a program. Only an object that is not part of another 

447
29.3 Example 1 – Hello World
object is considered a variable. For example, array elements, structure compo-
nents, array sections and substrings are not considered variables. 
 Private variable – With respect to a given set of task regions that bind to the 
 –
same parallel region, a variable whose name provides access to a different 
block of storage for each task region. 
 Shared variable – With respect to a given set of task regions that bind to the 
 –
same parallel region, a variable whose name provides access to the same 
block of storage for each task region. 
 Execution Model
• 
 The OpenMP API uses the fork-join model of parallel execution. Multiple 
 –
threads of execution perform tasks deﬁ ned implicitly or explicitly by OpenMP 
directives. OpenMP is intended to support programs that will execute correctly 
both as parallel programs (multiple threads of execution and a full OpenMP 
support library) and as sequential programs (directives ignored and a simple 
OpenMP stubs library). 
 The above coverage should be enough to get started with OpenMP and under-
stand the examples that follow. 
 29.3  Example 1 – Hello World 
 This is the classic hello world program.
 program ch2901  
 use omp_lib  
 implicit none  
 integer :: nthreads  
 integer :: thread_number  
 integer :: I 
 nthreads = omp_get_max_threads()  
 print *, ' Number of threads = ', nthreads 
!$omp parallel do  
 do I=1, nthreads
 print *, ' Hello from thread ',&
 omp_get_thread_num()  
 end do  
 !$omp end parallel do  
 end program ch2901  
 Let us go through the program one statement at a time.
 use omp_lib  
 This use statement makes available the OpenMP environment. OpenMP state-
ments are treated as comments without this statement.

448
29 OpenMP 
 nthreads = omp_get_max_threads()  
 print *, ' Number of threads = ', nthreads  
 The ﬁ rst statement sets the variable nthread to the value returned by the OpenMP 
function omp_get_max_threads(). We then print out this value.
 !$omp parallel do  
 OpenMP directives in Fortran start with the comment character (!), followed by 
a $ symbol and the characters omp. We use this form as it is works with both free 
format and ﬁ xed format Fortran source code. 
 The parallel do words indicate that the code that follows is a parallel region 
construct. In this case a do loop. Here is a small table listing some of the OpenMP 
directives. 
 Parallel region construct 
 !$omp parallel [clause] 
    structured block 
 !$omp end parallel 
 Work sharing constructs 
 !$omp do [clause] … 
    do loop 
 !$omp end parallel 
 !$omp sections [clause] … 
 [!$omp section 
    structured block ] … 
 !$omp end sections [nowait] 
 !$omp single [clause] 
    structured block 
 !$omp end single [nowait] 
 Combined parallel work sharing constructs 
 !$omp parallel do [clause] 
    structured block 
 !$omp end parallel do 
 !$omp parallel sections [clause] … 
 [!$omp section 
    structured block ] … 
 !$omp end parallel sections 
 Synchronisation constructs 
 !$omp master 
    structured block 
 ! $omp end master 
 !$omp critical [(name)] 
    structured block 
 !$omp end critical [(name)] 
 !$omp barrier 
 $omp atomic 

449
29.3 Example 1 – Hello World
    expression list 
 !$omp ﬂ ush 
 !$omp ordered 
    structured block 
 !$omp end ordered 
 Data environment 
 !$omp threadprivate (/c1/,/c2/) 
 We next have the parallel do.
 do I=1, nthreads  
 print *, ' Hello from thread ', &  
 omp_get_thread_num() 
 end do  
 This loop prints out a message from each thread showing the thread number.
 !$omp end parallel do  
 This marks the end of the OpenMP parallel loop. 
 So at the start of the loop the OpenMP run time system does a fork and creates 
multiple threads. At the end of the loop we have a join operation and we are back to 
one thread of execution. 
 Here is the output from the Intel compiler on an Intel i7 system. 
 These Intel systems have four real cores and each core supports hyper threading 
in Intel terminology. So the OpenMP system sees eight threads. 
 Here is the output from the gfortran compiler on the same system. 
 The output is very similar, as one would expect. 

450
29 OpenMP 
 29.4  Example 2 – Hello World Using Default Variable 
Data Scoping 
 This is a simple variation on the ﬁ rst example. At ﬁ rst sight it appears to be identical 
in effect to example one
 program ch2902  
 use omp_lib  
 implicit none  
 integer :: nthreads  
 integer :: thread_number  
 integer :: I 
 nthreads = omp_get_max_threads()  
 print *, ' Number of threads = ', nthreads  
 !$omp parallel do
 do I = 1, nthreads
 thread_number = omp_get_thread_num()  
 print *, ' Hello from thread ', 
thread_number  
 end do  
 !$omp end parallel do  
 end program ch2902  
 However we have introduced a variable thread_number and are using the 
OpenMP default data scoping rules, i.e. we have said nothing. Here is the output 
from the Intel compiler. 
 We appear to have a working program. Here is the output from the gfortran compiler.  

451
29.5 Example 3 – Hello World with Private thread _ number Variable
 Now something appears to be not quite right! The default variable scoping rules 
mean that the variable  thread_number is available to all threads – in OpenMP termi-
nology it is shared. The opposite of shared is private and each thread has their own 
copy. Example 3 corrects this problem. 
 29.5  Example 3 – Hello World with Private  thread_number 
Variable 
 program ch2903  
 use omp_lib  
 implicit none  
 integer :: nthreads  
 integer :: thread_number  
 integer :: I 
 nthreads = omp_get_max_threads()  
 print *, ' Number of threads = ', nthreads  
 !$omp parallel do private(thread_number)
 do I = 1, nthreads
 thread_number = omp_get_thread_num()  
 print *, ' Hello from thread ', 
thread_number  
 end do  
 !$omp end parallel do  
 end program ch2903 
 Here is the output from the gfortran compiler. 
 Care must be taken with variables in OpenMP to ensure they have the correct 
data scoping state. 

452
29 OpenMP 
 29.6  Example 4 – Parallel Solution for pi Calculation 
 This is an OpenMP parallel implementation of the integration problem (example 
three) from the previous chapter. You should compare it with the MPI solution – 
example four in the last chapter.
 program ch2904  
 use precision_module  
 use timing_module  
 use omp_lib  
 implicit none  
 real (long) :: fortran_internal_pi  
 real (long) :: partial_pi  
 real (long) :: openmp_pi  
 real (long) :: width  
 real (long) :: x  
 integer : : nthreads  
 integer : :  
 integer : : j  
 integer : : k  
 integer : : n 
 nthreads = omp_get_max_threads()  
 fortran_internal_pi = 4 . 
0_long*atan(1.0_long)  
 print *, ' Maximum number of threads is ', 
nthreads  
 k=1 
 do 
 call start_timing()  
 n = 100000  
 call omp_set_num_threads(k)  
 print *, ' Number of threads = ', k  
 do j = 1, 5 
 width = 1.0_long/n  
 partial_pi = 0.0_long  
 !$OMP parallel do private(x) 
shared(width)  
 reduction(+:partial_pi) 
 do I = 1, n
 x = width*(real(i,long)-0.5_long)  
 partial_pi = partial_pi + f (x)  
 end do  
  !$omp end parallel do  

453
29.6 Example 4 – Parallel Solution for pi Calculation
 openmp_pi = width*partial_pi  
 print 20, n, time_difference()  
 20 format (' N intervals = ',i12, & 
 ' time =',f8.3)  
 print 30, openmp_pi , & 
 abs(openmp_pi-fortran_internal_pi)  
 30 format (' openmp_pi = ' , & 
 f20.16,/,'difference = ',f20.16)  
 n = n*10  
 end do  
 k=k*2 
 if (k>nthreads) exit  
 end do  
 contains  
 real (long) function f (x)  
 implicit none  
 real (long), intent (in) : : x 
 f = 4.0_long/(1.0_long+x*x)  
 end function f  
 end program ch2904  
 Here is the output from the Intel compiler. 

454
29 OpenMP 

455
29.8 Problem
 We have similar timing improvements to the MPI solutions. 
 29.7  Summary 
 This chapter brieﬂ y introduced the essentials of OpenMP programming. We have 
also seen the timing beneﬁ ts that OpenMP programming can offer in the solution of 
the same problem 
 29.8  Problem 
 1.   Compile and run the examples in this chapter with your compiler and compare 
the results. 

457
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_30, © Springer-Verlag London Limited 2012
 Aim 
 The aims of this chapter is to provide a short introduction to coarray programming 
in Fortran. 
 30.1  Introduction 
 Coarrays were the major component of the Fortran 2008 standard. As stated earlier 
they are based on a single program multiple data model. Coarrays are a simple parallel 
programming extension to Fortran. They are effectively variables that can be shared 
across multiple instances of the same program or images in Fortran terminology. 
 Coarray variables look like conventional Fortran arrays, except that they use [] 
brackets instead of () brackets. In the simple declaration below
 character(len=20) :: name[*]='*****'  
we declare name to be a  character coarray and the * in the [] brackets means that the 
bounds of the coarray are calculated at run time, rather than compile time.
 read *, name  
is a reference to the coarray on the current image. 
 We can then use the following statement
 name [i]  =  name 
to broadcast the value read in to each of the other images. 
 Chapter 30 
 Coarray Fortran  
 Science is a wonderful thing if one does not have to earn one’s 
living at it. 
 Einstein 

458
30 Coarray Fortran
 Note the Fortran coarray syntax here. We use the [] brackets to reference the 
coarray variable on other images and the omission of the [] brackets is a reference 
to the coarray variable on the current image. 
 30.2  Coarray Terminology 
 The following is taken from the standard and covers some of the basic coarray 
terminology.
 CODIMENSION attribute – The CODIMENSION attribute species that an entity 
• 
is a coarray. The coarray-spec speciﬁ es its corank or corank and cobounds. 
 Allocatable coarray – A coarray with the ALLOCATABLE attribute has a speci-
• 
ﬁ ed corank, but its cobounds are determined by allocation or argument 
association. 
 Explicit-coshape coarray – An explicit-coshape coarray is a named coarray that 
• 
has its corank and cobounds declared by an explicit-coshape-spec. 
 Coindexed named objects – A coindexed-named-object is a named scalar coar-
• 
ray variable followed by an image selector. 
 Image selectors – An image selector determines the image index for a coindexed 
• 
object. 
 Image execution control and image control statements – The execution sequence 
• 
on each image is speciﬁ ed in 2.3.5 of the standard. 
 Execution of an image control statement divides the execution sequence on an 
• 
image into segments. Each of the following is an image control statement:
 SYNC ALL statement; 
 –
 SYNC IMAGES statement; 
 –
 SYNC MEMORY statement; 
 –
 ALLOCATE or DEALLOCATE statement that has a coarray allocate-object; 
 –
 CRITICAL or END CRITICAL; 
 –
 LOCK or UNLOCK statement; 
 –
 Any statement that completes execution of a block or procedure and which 
 –
results in the implicit deallocation of a coarray; 
 STOP statement; 
 –
 END statement of a main program. 
 –
 Coarray – A coarray is a data entity that has nonzero corank; it can be directly 
• 
referenced or deﬁ ned by any image. It may be a scalar or an array. 
 Coarray dummy variables – If the dummy argument is a coarray, the correspond-
• 
ing actual argument shall be a coarray and shall have the VOLATILE attribute if 
and only if the dummy argument has the VOLATILE at tribute. 
 Coarray intrinsics
• 
 image_index – convert a cosubscript to an image index 
 –
 lcobound – cobounds of a coarray 
 –

459
30.4 Example 2 – Broadcasting Data
 num_images – the number of images 
 –
 this_image – image index or cosubscripts 
 –
 ucobound – cobounds of a coarray 
 –
 Let us look now at some simple examples. 
 30.3  Example 1 – Hello World 
 The ﬁ rst is the classic Hello world.
 program ch3001  
 implicit none 
 print *,' Hello world from image ', this_image()  
 end program ch3001  
 Here is the output from the Intel compiler. 
 The output is obviously very similar to the corresponding MPI and OpenMP 
versions. 
 30.4  Example 2 – Broadcasting Data 
 Here is a simple program that broadcasts data from one image to the rest. This is a 
common requirement in parallel programming.
 program ch3002  
 implicit none  
 integer :: I  
 character(len=20) :: name[*]='*****' 
 print 10,name,this_image()  
 10 format(1x,' Hello ', a20,' from image ',i3)  
 if (this_image() == 1) then 
 print *,' Type in your name'  

460
30 Coarray Fortran
 read *, name  
 do I = 2, num_images() 
 name [i] = name  
 end do  
 end if  
 sync all  
 print 10,name,this_image()  
 end program ch3002  
 Here is the output from the Intel compiler. 
 Again no particular ordering of the image numbers. 
 30.5  Example 3 – Parallel Solution for Pi Calculation 
 program ch3003  
 use precision_module  
 use timing_module  
 implicit none  
 real (long) :: fortran_internal_pi  
 real (long) :: partial_pi  
 real (long) :: coarray_pi  
 real (long) :: width  

461
30.5 Example 3 – Parallel Solution for Pi Calculation
 real (long) :: total_sum  
 real (long) :: x  
 real (long) , codimension[*] :: partial_sum  
 integer :: n_intervals  
 integer :: I  
 integer :: j  
 integer :: current_image  
 integer :: n_images 
 fortran_internal_pi = 4.0_long*atan(1.0_long)  
 n_images=num_images()  
 current_image=this_image()  
 if (current_image == 1) then 
 print *,' Number of images = ',n_images  
 end if  
 n_intervals=100000  
 do j=1,5 
 if (current_image == 1) then
 call start_timing()  
 end if  
 width = 1.0_long/real(n_intervals, long)  
 total_sum=0.0_long  
 partial_sum= 0.0_long  
 do i=current_image,n_intervals,n_images 
 x = (real(i,long) - 0.5_long)*width  
 partial_sum = partial_sum + f(x)  
 end do  
 partial_sum=partial_sum*width  
 sync all  
 if (current_image==1) then 
 do i=1,n_images
 total_sum=total_sum+partial_sum[i]  
 end do  
 coarray_pi = total_sum  
 print 20, n_intervals, time_difference()  
 20 format (' n intervals = ',i12,' time =',f8.3)  
 print 30, coarray_pi , & 
  abs(coarray_pi-fortran_internal_pi)  
 30 format (' pi = ',f20.16,/, & 
 ' difference = ',f20.16)  
 end if  
 n_intervals=n_intervals*10  
 sync all  
 end do  
 contains  
 real (long) function f(x)  
 implicit none  

462
30 Coarray Fortran
 real (long), intent (in) :: x 
 f = 4.0_long/(1.0_long+x*x)  
 end function f  
 end program ch3003 
 Here is the output from the Intel compiler.
 Number of images = 8  
 2011/ 6/10 13:40:48 479  
 n intervals = 100000 time = 0.004  
 pi = 3.1415926535981260  
 difference = 0.0000000000083329  
 2011/ 6/10 13:40:48 486  
 n intervals = 1000000 time = 0.004  
 pi = 3.1415926535898802  
 difference = 0.0000000000000870  
 2011/ 6/10 13:40:48 490  
 n intervals = 10000000 time = 0.012  
 pi = 3.1415926535897936  
 difference = 0.0000000000000004  
 2011/ 6/10 13:40:48 500  
 n intervals = 100000000 time = 0.105  
 pi = 3.1415926535897749  
 difference = 0.0000000000000182  
 2011/ 6/10 13:40:48 605  
 n intervals = 1000000000 time = 0.992  
 pi = 3.1415926535898455  
 difference = 0.0000000000000524  
 Here is the output from the Cray compiler.
 Number of images = 96  
 2011/ 6/10 13:35: 7 419  
 n intervals = 100000 time = 0.004  
 pi = 3.1415926535981265  
 difference = 0.0000000000083333  
 2011/ 6/10 13:35: 7 421  
 n intervals = 1000000 time = 0.000  
 pi = 3.1415926535898766  
 difference = 0.0000000000000835   
 2011/ 6/10 13:35: 7 422  
 n intervals = 10000000 time = 0.004  
 pi = 3.1415926535897949  
 difference = 0.0000000000000018  

463
30.6 Example 4 – Work Sharing
 2011/ 6/10 13:35: 7 424  
 n intervals = 100000000 time = 0.012  
 pi = 3.1415926535897913  
 difference = 0.0000000000000018  
 2011/ 6/10 13:35: 7 436  
 n intervals = 1000000000 time = 0.105  
 pi = 3.1415926535897949  
 difference = 0.0000000000000018  
 We get the time improvement we have seen with both the MPI and OpenMP 
solutions. 
 30.6  Example 4 – Work Sharing 
 This example looks at one way of splitting work up between images. We use the 
image number to determine which image does which work. It is a coarray version 
of the MPI work sharing example.
 program ch3004  
 implicit none  
 integer:: n, i,j  
 integer:: me, nim, start,end  
 integer, parameter:: factor=5  
 integer, dimension(1:factor), codimension[*]:: x 
 nim = num_images()  
 me = this_image()  
 n = nim*factor  
 x = 0 
 start = factor*(me-1) + 1  
 end = factor*me  
 j = 1 
 do i=start,end 
 x(j) = i*factor  
 print*,'on image ',me, 'j = ',j,' x(j) = ',x(j)  
 j = j + 1  
 end do  
 sync all  
 if (me == 1) then 
 print *,'coarray x on image ',me,' is: ' ,x  
 do i=2,nim 
 print*, 'coarray x on image ',I,' is: ',x(:) [I]  
 end do  
 endif 
 end program ch3004 

464
30 Coarray Fortran
 The following statements deﬁ ne the start and end points for the array processing 
for each image:
 start = factor*(me-1) + 1  
 end = factor*me  
and partitions the work between the images. Each image will have its own start 
and end values. The following do loop does the work:
 do i=start,end  
 x(j) = i*factor  
 print*,'on image ',me, 'j = ',j,' x(j) = ',x(j)  
 j = j + 1  
 end do  
 We need the
 sync all  
to ensure that each image has completed before further processing, and we then 
print out the data from each image on image 1. 
 Here is a subset of the output from the Intel compiler. This example runs on eight 
images. 

465
30.6 Example 4 – Work Sharing

466
30 Coarray Fortran
 Here is a sample of the output from the Cray compiler on the Hector service. 
This example runs on 96 images.
 on image 2 j = 1 x(j) = 30  
 on image 4 j = 1 x(j) = 80  
 on image 2 j = 2 x(j) = 35  
 on image 4 j = 2 x(j) = 85  
 on image 2 j = 3 x(j) = 40  
 on image 4 j = 3 x(j) = 90  
 on image 77 j = 1 x(j) = 1905  
 on image 74 j = 1 x(j) = 1830  
 on image 77 j = 2 x(j) = 1910  
 … 
 … 
 on image 64 j = 2 x(j) = 1585  
 on image 60 j = 2 x(j) = 1485  
 on image 39 j = 5 x(j) = 975  
 on image 30 j = 1 x(j) = 730  
 … 
 … 
 on image 31 j = 1 x(j) = 755  
 on image 42 j = 1 x(j) = 1030  
 on image 31 j = 2 x(j) = 760  
 … 
 … 
 on image 41 j = 1 x(j) = 1005  
 on image 27 j = 3 x(j) = 665  
 … 
 … 
 on image 44 j = 1 x(j) = 1080  
 on image 46 j = 4 x(j) = 1145  
 … 
 … 
 coarray x on image 1 is: 5, 10, 15, 20, 25  
 coarray x on image 2 is: 30, 35, 40, 45, 50  
 coarray x on image 3 is: 55, 60, 65, 70, 75  
 coarray x on image 4 is: 80, 85, 90, 95, 100  
  coarray x on image 5 is: 105, 110, 115, 120, 125  
 coarray x on image 6 is: 130, 135, 140, 145, 150  
 coarray x on image 7 is: 155, 160, 165, 170, 175  
 coarray x on image 8 is: 180, 185, 190, 195, 200  
 … 
 … 
 coarray x on image 88 is: 2180, 2185, 2190, 2195, 2200  
 coarray x on image 89 is: 2205, 2210, 2215, 2220, 2225  

467
30.8 Problem
 coarray x on image 90 is: 2230, 2235, 2240, 2245, 2250  
 coarray x on image 91 is: 2255, 2260, 2265, 2270, 2275  
 coarray x on image 92 is: 2280, 2285, 2290, 2295, 2300  
 coarray x on image 93 is: 2305, 2310, 2315, 2320, 2325  
 coarray x on image 94 is: 2330, 2335, 2340, 2345, 2350  
 coarray x on image 95 is: 2355, 2360, 2365, 2370, 2375  
 coarray x on image 96 is: 2380, 2385, 2390, 2395, 2400  
 30.7  Summary 
 This chapter has looked brieﬂ y at some of the simple syntax of coarrays using a 
small set of examples. We have also seen the timing beneﬁ ts that coarray program-
ming can offer in the solution of the same problem. 
 30.8  Problem 
 1.  Compile and run the examples in this chapter with your compiler. 

469
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_31, © Springer-Verlag London Limited 2012
 Aim 
 This chapter looks brieﬂ y at C interoperability. 
 31.1  Introduction 
 C is a widely used programming languages and there is a considerable amount of 
software written in C. Fortran 2003 introduced a standardised mechanism for inter-
operating with C. 
 In this chapter we provide a brief coverage of some of the technical details 
required for interoperability and then have a look at a couple of examples. 
 31.2  ISO_C_BINDING Module 
 There is an intrinsic module called ISO_C_BINDING that contains named con-
stants, derived types and module procedures to support interoperability. 
 31.3  Named Constants and Derived Types in the Module 
 The entities listed in the second column of Table  31.1 , are named constants of type 
default integer.  
 Chapter 31 
 C Interop  
 We can’t solve problems by using the same kind of thinking we 
used when we created them. 
 Einstein 

470
31 C Interop
 31.4  Character Interoperability 
 The following maps between Fortran and C character types. The semantics of these 
values are explained in 5.2.1 and 5.2.2 of the C International Standard. 
 Names of C characters with special semantics 
 Name 
 C deﬁ nition 
 C_CHAR = −1 C_CHAR/=−1 
 C_NULL_CHAR 
 Null character 
 CHAR(0) 
 '\0' 
 C_ALERT 
 Alert 
 ACHAR(7) 
 '\a' 
 C_BACKSPACE 
 Backspace 
 ACHAR(8) 
 '\b' 
 C_FORM_FEED 
 Form feed 
 ACHAR(12) 
 '\f' 
 C_NEW_LINE 
 New line 
 ACHAR(10) 
 '\n' 
 C_CARRIAGE_RETURN 
 Carriage return 
 ACHAR(13) 
 '\r' 
 C_HORIZONTAL_TAB 
 Horizontal tab 
 ACHAR(9) 
 '\t' 
 C_VERTICAL_TAB 
 Vertical tab 
 ACHAR(11) 
 '\v' 
 Table 31.1    
 Fortran type 
 Named constant from the ISO_C_BINDING 
module (kind type parameter if value is positive) 
 C type 
 INTEGER 
 C_INT 
 Int 
 C_SHORT 
 short int 
 C_LONG 
 long int 
 C_LONG_LONG 
 long long int 
 C_SIGNED_CHAR 
 signed char 
 unsigned char 
 C_SIZE_T 
 size t 
 C_INT8_T 
 int8 t 
 C_INT16_T 
 int16 t 
 C_INT32_T 
 int32 t 
 C_INT64_T 
 int64 t 
 C_INT_LEAST8_T 
 int least8 t 
 C_INT_LEAST16_T 
 int least 16 t 
 C_INT_LEAST32_T 
 int least32 t 
 C_INT_LEAST64_T 
 int least64 t 
 C_INT_FAST8_T 
 int fast8 t 
 C_INT_FAST16_T 
 int fast16 t 
 C_INT_FAST32_T 
 int fast32 t 
 C_INT_FAST64_T 
 int fast64 t 
 C_INTMAX_T 
 intmax t 
 C_INTPTR_T 
 intptr t 
 REAL 
 C_FLOAT 
 Float 
 C_DOUBLE 
 Double 
 C_LONG_DOUBLE 
 long double 
 COMPLEX 
 COMPLEX_C_DOUBLE _COMPLEX 
 Double Complex 
 C_LONG_DOUBLE_COMPLEX 
 long double Complex 
 LOGICAL 
 C_BOOL 
 Bool 
 CHARACTER 
 C_CHAR 
 char 
 The above mentioned C types are deﬁ ned in the C International Standard, clauses 6.2.5, 7.17, and 7.18.1  

471
31.7 Other Aspects of Interoperability
 31.5  Procedures in the Module 
 There are several procedures in this module. In the descriptions below, procedure 
names are generic and not speciﬁ c. 
 A C procedure argument is often deﬁ ned in terms of a C address. The C_LOC 
and C_FUNLOC functions are provided so that Fortran applications can determine 
the appropriate value to use with C facilities. 
 The C_ASSOCIATED function is provided so that Fortran programs can com-
pare C addresses. 
 The C_F_POINTER and C_F_PROCPOINTER subroutines provide a means of 
associating a Fortran pointer with the target of a C pointer. 
 More information can be found in Chap.  15 of the standard. 
 31.6  Interoperability of Intrinsic Types 
 Table  31.1 shows the interoperability between Fortran intrinsic types and C types. 
A Fortran intrinsic type with particular type parameter values is interoperable with 
a C type if the type and kind type parameter value are listed in the table on the same 
row as that C type; if the type is character, interoperability also requires that the 
length type parameter be omitted or be speciﬁ ed by an initialization expression 
whose value is one. A combination of Fortran type and type parameters that is 
interoperable with a C type listed in the table is also interoperable with any unquali-
ﬁ ed C type that is compatible with the listed C type. 
 The second column of the table refers to the named constants made accessible by 
the ISO_C_BINDING intrinsic module. 
 A combination of intrinsic type and type parameters is interoperable if it is 
interoperable with a C type. 
 31.7  Other Aspects of Interoperability 
 There are considerable restrictions on other aspects of interoperability. The follow-
ing provides some brief details of other areas:
 Interoperability with C pointer types
• 
 C_PTR and C_FUNPTR shall be derived types with private components. 
 –
C_PTR is interoperable with any C object pointer type. C_FUNPTR is 
interoperable with any C function pointer type. 
 Interoperability of scalar variables
• 
  A scalar Fortran variable is interoperable if its type and type parameters are 
 –
interoperable and it has neither the pointer nor the allocatable attribute. 
 An interoperable scalar Fortran variable is interoperable with a scalar C entity 
 –
if their types and type parameters are interoperable. 

472
31 C Interop
 Interoperability of array variables
• 
 An array Fortran variable is interoperable if its type and type parameters are 
 –
interoperable and it is of explicit shape or assumed size. 
 Interoperability of procedures and procedure interfaces
• 
 A Fortran procedure is interoperable if it has the BIND attribute, that is, if its 
 –
interface is speciﬁ ed with a proc-language-binding-spec. 
 Interoperation with C global variables
• 
 AC variable with external linkage may interoperate with a common block or 
 –
with a variable declared in the scope of a module. The common block or vari-
able shall be speciﬁ ed to have the BIND attribute. 
 Binding labels for common blocks and variables
• 
 The binding label of a variable or common block is a value of type default 
 –
character that speciﬁ es the name by which the variable or common block is 
known to the companion processor. 
 Interoperation with C functions
• 
 A procedure that is interoperable may be deﬁ ned either by means other than 
 –
Fortran or by means of a Fortran subprogram, but not both. 
 Another useful source can be found in the December 2009 edition of Fortran 
Forum. Details are given at the end of the chapter. 
 31.8  C_LOC Examples 
 We include a small number of examples using the C_LOC function. Here is some of 
the technical information on C_LOC from the standard.
 C_LOC (X)
 Description.
• 
 Returns the C address of the argument. 
 Class.
• 
 Inquiry function. 
 Argument.
• 
 X shall either
 1.  have interoperable type and type parameters and be
 (a)  a variable that has the TARGET attribute and is interoperable, 
 (b)  an allocated allocatable variable that has the TARGET attribute and 
is not an array of zero size, or 
 (c)  an associated scalar pointer, or 

473
31.9 Example 1
 2.  be a nonpolymorphic scalar, have no length type parameters, and be
 (a)  a nonallocatable, nonpointer variable that has the TARGET attribute,  
 (b)  an allocated allocatable variable that has the TARGET attribute, or 
 (c)  an associated pointer. 
 Result Characteristics.
• 
 Scalar of type C_PTR. 
 Result Value. 
• 
 The result value will be described using the result name CPTR.
 1.  If X is a scalar data entity, the result is determined as if C_PTR were a 
derived type containing a scalar pointer component PX of the type and 
type parameters of X and the pointer assignment CPTR%PX => X were 
executed. 
 2.  If X is an array data entity, the result is determined as if C_PTR were a 
derived type containing a scalar pointer component PX of the type and 
type parameters of X and the pointer assignment of CPTR%PX to the 
ﬁ rst element of X were executed. 
 If X is a data entity that is interoperable or has interoperable type and type 
• 
parameters, the result is the value that the C processor returns as the result of 
applying the unary “&” operator (as deﬁ ned in the C International Standard, 
6.5.3.2) to the target of CPTR 
 The result is a value that can be used as an actual CPTR argument in a call to 
• 
C_F_POINTER where FPTR has attributes that would allow the pointer 
assignment FPTR => X. Such a call to C_F_POINTER shall have the effect 
of the pointer assignment FPTR => X. 
 NOTE 15.6 – Where the actual argument is of noninteroperable type or type 
• 
parameters, the result of C_LOC provides an opaque “handle” for it. In an 
actual implementation, this handle may be the C address of the argument; 
however, portable C functions should treat it as a void (generic) C pointer that 
cannot be dereferenced (6.5.3.2 in the C International Standard). 
 The key issues are that we must take care with the argument to the function, the 
return value is of type C_PTR, and that this is an opaque type. Let us now look at 
some examples using this function. 
 31.9  Example 1 
 The arguments x1 and x2 to c_loc are variables with the target attribute. The argu-
ments p_x1 and p_x2 are both pointers. 
 The return values from the c_loc function must be of type c_ptr. In the ﬁ rst call 
to c_loc these pointers are not associated. 
 We can’t print variables of type c_ptr so we use the transfer intrinsic to convert 
to an integer value that we can print. 
 Here is the output from three compilers. 

474
31 C Interop

475
31.9 Example 1
 31.9.1  Gfortran Output 
 
 
 The program prints out 0 for i3 and i4 initially. At this point the pointers c_ptr3 and 
c_ptr4 are not associated, i.e. they do not point to anything. 
 31.9.2  Intel Output 
 
 
 Intel does something similar to gfortran and the program prints out 0 for i3 and i4 
initially. At this point the pointers c_ptr3 and c_ptr4 are not associated, i.e. they do 
not point to anything. 

476
31 C Interop
 31.9.3  Nag Output 
 
 
 The Nag program prints out −1 for i3 and i4 initially. At this point the pointers 
c_ptr3 and c_ptr4 are not associated, i.e. they do not point to anything. 
 The value zero is often used to signify a special memory value in computing and 
this is chosen by the gfortran and Intel compilers. The Nag compiler chooses −1, 
again a special value. 
 31.10  Example 2 
 In this example we use the null () intrinsic to provide initial values for the two 
pointer variables p_x1 and p_x2.
 program ch3102  
 use iso_c_binding  
 implicit none  
 integer , target :: x1 = 20  
 integer , target :: x2 = 30  
 integer , pointer :: p_x1=>null()  
 integer , pointer :: p_x2=>null()  
 type (c_ptr) :: c_ptr1,c_ptr2,c_ptr3,c_ptr4  
 integer :: i1,i2,i3,i4 
 c_ptr1=c_loc (x1)  
 c_ptr2=c_loc(x2)  
 c_ptr3=c_loc(p_x1)  
 c_ptr4=c_loc(p_x2)  
 i1=transfer(c_ptr1,i1)  
 i2=transfer(c_ptr2,i2)  

477
31.10 Example 2
 i3=transfer(c_ptr3,i3)  
 i4=transfer(c_ptr4,i4)  
 print *, ' i1 ' ,i1  
 print *, ' i2 ' ,i2  
 print *, ' i3 ' ,i3  
 print *, ' i4 ' ,i4  
 p_x1 => x1  
 p_x2 => x2  
 c_ptr3=c_loc(p_x1)  
 c_ptr4=c_loc(p_x2)  
 i1=transfer(c_ptr1,i1)  
 i2=transfer(c_ptr2,i2)  
 i3=transfer(c_ptr3,i3)  
 i4=transfer(c_ptr4,i4)  
 print *, ' xl ',x1  
 print *, ' x2 ',x2  
 print *, ' P_x1 ',p_x1  
 print *, ' P_x2 ',p_x2  
 print *, ' il ',il  
 print *, ' i2 ',i2  
 print *, ' i3 ',i3  
 print *, ' i4 ',i4  
 end program ch3102  
 The output for the gfortran and Intel compilers is as before. The Nag output is 
given below.
 
 
 The Nag compiler therefore distinguishes between pointers that are uninitialised 
(−1) and initialised (0) to the null value, i.e. not associated. This kind of bug is quite 
hard to ﬁ nd! 

478
31 C Interop
 31.11  Bibliography 
 Einarsson, B., Hanson, R.J., Hopkins, T.: Standardized mixed language program-
ming for Fortran and C. Fortran Forum,  28 (3), (December 2009) 
 31.12  Problem 
 1.  Compile and run the example programs in this chapter with your compiler and 
examine the output. 

479
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_32, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look in more depth at arithmetic and in particular at the 
support that Fortran provides for the IEEE 754 standard. There is a coverage of:
 Hardware support for arithmetic. 
• 
 Integer formats. 
• 
 Floating point formats: single and double. 
• 
 Special values: denormal, inﬁ nity and not a number – NAN. 
• 
 Exceptions and ﬂ ags: divide by zero, inexact, invalid, overﬂ ow, under ﬂ ow. 
• 
 32.1  Introduction 
 The literature contains details of the IEEE 754 standard and the bibliography contains 
details of a number of printed and on-line sources. 
 Chapter 32 
 ISOTR 15580 IEEE Arithmetic 
 Any effectively generated theory capable of expressing 
elementary arithmetic cannot be both consistent and complete. 
In particular, for any consistent, effectively generated formal 
theory that proves certain basic arithmetic truths, there is an 
arithmetical statement that is true, but not provable in the 
theory. 
 Godel, First incompleteness theorem 

480
32 ISOTR 15580 IEEE Arithmetic
 32.2  History 
 When we use programming languages to do arithmetic two major concerns are the 
ability to develop reliable and portable numerical software. Arithmetic is done in 
hardware and there are a number of things to consider:
 The range of hardware available both now and in the past. 
• 
 The evolution of hardware. 
• 
 There has been a very considerable change in arithmetic units since the ﬁ rst 
computers. The following is a list of hardware and computing systems that the 
authors have used or have heard of. It is not exhaustive or deﬁ nitive, but rather 
reﬂ ects the authors’ age and experience:
 CDC 
• 
 Cray 
• 
 IBM 
• 
 ICL 
• 
 Fujitsu 
• 
 DEC 
• 
 Compaq 
• 
 Gateway 
• 
 Sun 
• 
 Silicon Graphics 
• 
 Hewlett Packard 
• 
 Data General 
• 
 Honeywell 
• 
 Elliot 
• 
 Mostek 
• 
 National Semiconductors 
• 
 Intel 
• 
 Zilog 
• 
 Motorola 
• 
 Signetics 
• 
 Amdahl 
• 
 Texas Instruments 
• 
 Cyrix 
• 
 AMD 
• 
 Some of the operating systems include:
 NOS 
• 
 NOS/BE 
• 
 Kronos 
• 
 UNIX 
• 
 VMS 
• 
 Dos 
• 
 Windows 3.x 
• 

481
32.3 IEEE 754 Speciﬁ cations
 Windows 95 
• 
 Windows 98 
• 
 Windows NT 
• 
 Windows 2000 
• 
 Windows XP 
• 
 Windows Vista 
• 
 MVS 
• 
 VM 
• 
 CP/M 
• 
 Macintosh 
• 
 OS/2 
• 
 Linux, a multitude! 
• 
 Again the list is not exhaustive or deﬁ nitive. The intention is simply to provide 
some idea of the wide range of hardware, computer manufacturers and operating 
systems that have been around in the past 50 years. 
 To cope with the anarchy in this area Doctor Robert Stewart (acting on behalf of 
the IEEE) convened a meeting which led to the birth of IEEE 754. 
 The ﬁ rst draft, which was prepared by William Kahan, Jerome Coonen and Harold 
Stone, was called the KCS draft and eventually adopted as IEEE 754. A fascinating 
account of the development of this standard can be found in An Interview with the Old 
Man of Floating Point, and the bibliography provides a web address for this interview. 
Kahan went on to get the ACM Turing Award in 1989 for his work in this area. 
 This has become a de facto standard amongst arithmetic units in modern hard-
ware. Note that it is not possible to describe precisely the answers a program will 
give, and the authors of the standard knew this. This goal is virtually impossible to 
achieve when one considers ﬂ oating point arithmetic. Reasons for this include:
 The conversions of numbers between decimal and binary formats. 
• 
 The use of elementary library functions. 
• 
 Results of calculations may be in hardware inaccessible to the programmer. 
• 
 Intermediate results in subexpressions or arguments to procedures. 
• 
 The bibliography contains details of a paper that addresses this issue in much 
greater depth – Differences Among IEEE 754 Implementations. 
 Fortran is one of a small number of languages that provides access to IEEE arith-
metic, and it achieves this via TR1880 which is an integral part of Fortran 2003. The 
C standard (C9X) addresses this issue and Java offers limited IEEE arithmetic sup-
port. More information can be found in the references at the end of the chapter. 
 32.3  IEEE 754 Speciﬁ cations 
 The standard speciﬁ es a number of things including:
 Single precision ﬂ oating point format. 
• 
 Double precision ﬂ oating point format. 
• 

482
32 ISOTR 15580 IEEE Arithmetic
 Two classes of extended ﬂ oating point formats. 
• 
 Accuracy requirements on the following ﬂ oating point operations:
• 
 Add. 
 –
 Subtract. 
 –
 Multiply. 
 –
 Divide. 
 –
 Square root. 
 –
 Remainder. 
 –
 Round numbers in ﬂ oating point format to integer values. 
 –
 Convert between different ﬂ oating point formats. 
 –
 Convert between ﬂ oating point and integer format. 
 –
 Compare. 
 –
 Base conversion, i.e., when converting between decimal and binary ﬂ oating point 
• 
formats and vice versa. 
 Exception handling for:
• 
 Divide by zero. 
 –
 Overﬂ ow. 
 –
 Underﬂ ow. 
 –
 Invalid operation. 
 –
 Inexact. 
 –
 Rounding directions. 
• 
 Rounding precisions. 
• 
 We will look brieﬂ y at each of these requirements. 
 32.3.1  Single Precision Floating Point Format 
 This is a 32-bit quantity made up of a sign bit, 8-bit biased exponent and 23-bit mantissa. 
The standard also speciﬁ es that certain of the bit patterns are set aside and do not represent 
normal numbers. This means that valid numbers are in the range 3.40282347E + 38 to 
1.17549435E-38 and the precision is between 6 and 9 digits depending on the numbers. 
 The special bit patterns provide the following:
 +0 
• 
 −0 
• 
 subnormal numbers in the range 1.17549421E-38 to 1.40129846E-45 
• 
 + inﬁ nity 
• 
 − inﬁ nity 
• 
 quiet NaN (Not a Number) 
• 
 signalling NaN 
• 

483
32.3 IEEE 754 Speciﬁ cations
 One of the ﬁ rst systems that the authors worked with that had special bit patterns 
set aside was the CDC 6000 range of computers that had negative indeﬁ nite and 
inﬁ nity. Thus the ideas are not new, as this was in the late 1970s. 
 The support of positive and negative zero means that certain problems can be 
handled correctly including:
 The evaluation of the log function which has a discontinuity at zero. 
• 
 The equation  
• 
 
=
1
1
z
z  can be solved when z = −1. 
 See also the Kahan paper Branch Cuts for complex Elementary Functions, or 
Much Ado About Nothing’s Sign Bit for more details. 
 Subnormals, which permit gradual underﬂ ow, ﬁ ll the gap between 0 and the 
smallest normal number. 
 Simply stated underﬂ ow occurs when the result of an arithmetic operation is so 
small that it is subject to a larger than normal rounding error when stored. The exis-
tence of subnormals means that greater precision is available with these small num-
bers than with normal numbers. The key features of gradual underﬂ ow are:
 When underﬂ ow does occur there should never be a loss of accuracy any greater 
• 
than that from ordinary roundoff. 
 The operations of addition, subtraction, comparison and remainder are always 
• 
exact. 
 Algorithms written to take advantage of subnormal numbers have smaller error 
• 
bounds than other systems. 
 if x and y are within a factor of 2 then x-y is error free, which is used in a number 
• 
of algorithms that increase the precision at critical regions. 
 The combination of positive and negative zero and subnormal numbers means 
that when x and y are small and x-y has been ﬂ ushed to zero the evaluation of
 
•  
−
1(
)
x
y  
can be ﬂ agged and located.
Certain arithmetic operations cause problems including:
 0* 
• 
∞ 
 0/0 
• 
 
•  x  when x < 0 
and the support for NaN handles these cases. 
 The support for positive and negative inﬁ nity allows the handling of
 x/0 when x is nonzero and of either sign 
• 
and the outcome of this means that we write our programs to take the appropriate 
action. In some cases this would mean recalculating using another approach. 
 For more information see the references in the bibliography. 

484
32 ISOTR 15580 IEEE Arithmetic
 32.3.2  Double Precision Floating Point Format 
 This is a 64-bit quantity made up of a sign bit, 11-bit biased exponent and 52-bit 
mantissa. As with single precision the standard speciﬁ es that certain of the bit patterns 
are set aside and do not represent normal numbers. This means we have valid 
 numbers in the range 1.7976931348623157E308 to 2.2250738585072014E-308 
and precision between 15 and 17 digits depending on the numbers. 
 As with single precision there are bit patterns set aside for the same special 
conditions. 
 Note that this does not mean that the hardware has to handle the manipulation of 
this 64-bit quantity in an identical fashion. The Sparc and Intel family handle the 
above as two 32-bit quantities but the order of the two component parts is reversed 
– so-called big endian and little endian. 
 32.3.3  Two Classes of Extended Floating Point Formats 
 These formats are not mandatory. A number of variants of double extended exist 
including:
 Sun – four 32-bit words, one sign bit, 15-bit biased exponent and 112-bit mantissa, 
• 
numbers in the range 3.362E-4932 to 1.189E4932, 33–36 digits of signiﬁ cance.  
 Intel – 10 bytes – one sign bit, 15-bit biased exponent, 63-bit mantissa, numbers 
• 
in the range 3.362E-4932 to 1.189E4932, 18–21 digits of signiﬁ cance. 
 PowerPC – as Sun. 
• 
 32.3.4  Accuracy Requirements 
 Remainder and compare must be exact. The rest should return the exact result if 
possible; if not, there are well-deﬁ ned rounding rules to apply. 
 32.3.5  Base Conversion – Converting Between Decimal and 
Binary Floating Point Formats and Vice Versa 
 These results should be exact if possible; if not the results must differ by tolerances 
that depend on the rounding mode. 

485
32.4 Resumé
 32.3.6  Exception Handling 
 It must be possible to signal to the user the occurrence of the following conditions 
or exceptions:
 Divide by zero. 
• 
 Overﬂ ow. 
• 
 Underﬂ ow. 
• 
 Invalid operation. 
• 
 Inexact. 
• 
 The ability to detect the above is a big step forward in our ability to write robust 
and portable code. These operations do occur in calculations and it is essential to 
have user programmer control over what action to take. 
 32.3.7  Rounding Directions 
 Four rounding directions are available:
 Nearest – the default. 
• 
 Down. 
• 
 Up. 
• 
 Chop. 
• 
 Access to directed rounding can be used to implement interval arithmetic, for 
example. 
 32.3.8  Rounding Precisions 
 The only mandatory part here is that machines that perform computations in extended 
mode let the programmer control the precision via a control word. This means that if 
software is being developed on machines that support extended modes those machines 
can be switched to a mode that would enable the software to run on a system that 
didn’t support extended modes. This area looks like a can of worms. Look at the 
Kahan paper for more information – Lecture Notes on the Status of IEEE 754.  
 32.4  Resumé 
 The above has provided a quick tour of IEEE 754. We’ll now look at what Fortran 
has to offer to support it. 

486
32 ISOTR 15580 IEEE Arithmetic
 32.5  ISO TR 15580 
 Fortran provides access to the facilities via the use statement. The current standard 
does not have the concept of an intrinsic module. TR 15580 introduces this concept. 
Three modules are provided:
 ieee_features 
• 
 ieee_exceptions 
• 
 ieee_arithmetic 
• 
 The ﬁ rst thing to consider is the degree of conformance to the IEEE standard. It 
is possible that not all of the features are supported. Thus the ﬁ rst thing to do is to 
run one or more test programs to determine the degree of support for a particular 
system. 
 32.5.1  IEEE_FEATURES Module 
 This module deﬁ nes a derived type, IEEE_FEATURES_type, and up to 11 con-
stants of that type representing IEEE features:
 IEEE_DATATYPE – whether any IEEE data types are available. 
• 
 IEEE_DENORMAL – whether IEEE denormal values are available. 
• 
 IEEE_DIVIDE – whether division has the accuracy required by IEEE. 
• 
 IEEE_HALTING – whether control of halting is supported. 
• 
 IEEE_INEXACT_FLAG – whether the inexact exception is supported. 
• 
 IEEE_INF – whether IEEE positive and negative inﬁ nities are available. 
• 
 IEEE_INVALID_FLAG – whether the invalid exception is supported. 
• 
 IEEE_NAN – whether IEEE NaNs are available. 
• 
 IEEE_ROUNDING – whether all IEEE rounding modes are available. 
• 
 IEEE_SQRT – whether SQRT conforms to the IEEE standard. 
• 
 IEEE_UNDERFLOW_FLAG – whether underﬂ ow is supported. 
• 
 32.5.2  IEEE_EXCEPTIONS Module 
 This module provides data types, constants and generic procedures for IEEE 
exceptions:
 type IEEE_STATUS_TYPE 
 Variables of this type can hold a ﬂ oating point status value. 
 subroutine IEEE_GET_STATUS(STATUS_VALUE) 
 type(IEEE_STATUS_TYPE),intent(out) :: STATUS_VALUE 

487
32.5 ISO TR 15580
 Stores the current ﬂ oating point status into the STATUS_VALUE argument. 
 subroutine IEEE_SET_STATUS(STATUS_VALUE) 
 type(IEEE_STATUS_TYPE),intent(in) :: STATUS_VALUE 
 Sets the current ﬂ oating point status from the STATUS_VALUE argument. 
 type IEEE_FLAG_TYPE 
 Values of this type specify individual IEEE exception ﬂ ags; constants for these 
are available as follows:
 type(IEEE_FLAG_TYPE),parameter :: IEEE_DIVIDE_BY_ZERO 
 type(IEEE_FLAG_TYPE),parameter :: IEEE_INEXACT 
 type(IEEE_FLAG_TYPE),parameter :: IEEE_INVALID 
 type(IEEE_FLAG_TYPE),parameter :: IEEE_OVERFLOW 
 type(IEEE_FLAG_TYPE),parameter :: IEEE_UNDERFLOW 
 In addition, two array constants are available for indicating common combinations 
of ﬂ ags:
 type(IEEE_FLAG_TYPE),parameter :: & 
IEEE_USUAL(3) = (/& 
IEEE_DIVIDE_BY_ZERO,& 
IEEE_INVALID, & 
IEEE_OVERFLOW /), & 
IEEE_ALL(5)  = ( / & 
IEEE_DIVIDE_BY_ZERO,& 
IEEE_INEXACT, & 
IEEE_INVALID,& 
IEEE_OVERFLOW, & 
IEEE_UNDERFLOW /) 
LOGICAL function IEEE_SUPPORT_FLAG(FLAG,X) 
 type(IEEE_FLAG_TYPE),intent(in) :: FLAG 
 real(kind),intent(in),optional :: X 
 Returns TRUE if detection of the speciﬁ ed IEEE exception is supported for the real 
kind of X (if X is present), or for all real kinds (if X is absent). 
 LOGICAL function IEEE_SUPPORT_HALTING(FLAG) 

488
32 ISOTR 15580 IEEE Arithmetic
type(IEEE_FLAG_TYPE),intent(in) :: FLAG 
 Returns TRUE if IEEE_SET_HALTING_MODE can be used to change whether 
the processor terminates the program on receiving the speciﬁ ed exception. 
 elemental subroutine & 
IEEE_GET_FLAG(FLAG,FLAG_VALUE) 
 type(IEEE_FLAG_TYPE),intent(in) :: FLAG 
LOGICAL,intent(out) :: FLAG_VALUE 
 Sets (each element of) FLAG_VALUE to TRUE if the corresponding exception 
speciﬁ ed by FLAG is signalling, and to FALSE otherwise. 
 elemental subroutine & 
IEEE_GET_HALTING_MODE(FLAG,HALTING) 
 type(IEEE_FLAG_TYPE),intent(in) :: FLAG 
LOGICAL,intent(out) :: HALTING 
  Sets (each element of) HALTING to TRUE if the corresponding exception speciﬁ ed by 
FLAG is signalling, and to FALSE otherwise. 
 elemental subroutine IEEE_SET_FLAG(FLAG,FLAG_VALUE) 
type(IEEE_FLAG_TYPE),intent(out) :: FLAG
LOGICAL,intent(in) :: FLAG_VALUE 
 Sets the exception ﬂ ag speciﬁ ed by (each element of) FLAG to signalling or quiet 
according to the corresponding element of FLAG_VALUE. 
 elemental subroutine & 
IEEE_SET_HALTING_MODE(FLAG,HALTING) 
 type(IEEE_FLAG_TYPE),intent(out) :: FLAG 
 LOGICAL,intent(in) :: HALTING 
 Sets the halting mode for each exception speciﬁ ed by FLAG to the value of the cor-
responding element of HALTING (TRUE  = halt). 
 32.5.3  IEEE_ARITHMETIC Module 
These are given below 
 32.5.3.1 IEEE Data Type Selection 
Integer Function SELECTED_real_KIND(P,R) 
 integer(kind1),optional :: P 

489
32.5 ISO TR 15580
 integer(kind2),optional :: R 
 The same as the SELECTED_real_KIND intrinsic, but only returns information 
about the IEEE kinds of reals. 
 32.5.3.2 General Support Enquiry Functions
LOGICAL Function IEEE_SUPPORT_DATATYPE(X) 
 real(kind),optional :: X 
 Whether IEEE arithmetic is supported for the same kind of real as X (or for all real 
kinds if X is absent).
 LOGICAL function IEEE_SUPPORT_DENORMAL(X) 
real(kind),optional :: X  
 Whether IEEE denormal values are supported for the same kind of real as X (or for 
all real kinds if X is absent). 
 LOGICAL function IEEE_SUPPORT_DIVIDE(X) 
real(kind),optional :: X 
 Whether division is carried out to the accuracy speciﬁ ed by the IEEE standard for 
the same kind of real as X (or for all real kinds if X is absent). 
 LOGICAL function IEEE_SUPPORT_INF(X) 
real(kind),optional :: X 
 Whether IEEE inﬁ nite values are supported for the same kind of real as X (or for all 
real kinds if X is absent). 
 LOGICAL function IEEE_SUPPORT_NAN(X) 
real(kind),optional :: X 
 Whether IEEE NaN (Not-a-Number) values are supported for the same kind of real 
as X (or for all real kinds if X is absent). 
 LOGICAL function IEEE_SUPPORT_SQRT(X) 
real(kind),optional :: X 
 Whether SQRT conforms to the IEEE standard for the same kind of real as X (or for 
all real kinds if X is absent). 
 LOGICAL function IEEE_SUPPORT_STANDARD(X) 
real(kind),optional :: X 
 Whether all the IEEE facilities speciﬁ ed by the TR are supported for the same kind 
of real as X (or for all real kinds if X is absent). 

490
32 ISOTR 15580 IEEE Arithmetic
 32.5.3.3 Rounding Modes 
Type IEEE_ROUND_type 
 Values of this type specify the IEEE rounding mode.
 type (IEEE_ROUND_type) , parameter :: IEEE_DOWN 
 type (IEEE_ROUND_type) , parameter :: IEEE_NEAREST 
 type (IEEE_ROUND_type) , parameter :: IEEE_TO_ZERO 
 type (IEEE_ROUND_type) , parameter :: IEEE_UP 
 LOGICAL function IEEE_SUPPORT_ROUNDING(ROUND_VALUE,X) type
(IEEE_ROUND_type),intent(in) :: ROUND_VALUE 
real(kind),optional :: X 
 Whether the speciﬁ ed IEEE rounding mode is supported for the same kind of 
real as X (or for all real kinds if X is absent). 
 subroutine IEEE_GET_ROUNDING_MODE(ROUND_VALUE) 
 type(IEEE_ROUND_type),intent(out) :: ROUND_VALUE 
 Sets the ROUND_VALUE argument to the current IEEE rounding mode. 
 subroutine IEEE_SET_ROUNDING_MODE(ROUND_VALUE) 
 type (IEEE_ROUND_type) , intent(in) :: ROUND_VALUE 
 Sets the current IEEE rounding mode to that speciﬁ ed by ROUND_VALUE. 
 32.5.3.4 Number Classiﬁ cation 
Type IEEE_CLASS_TYPE 
 Values of this type indicate the IEEE class of a number.
 type (IEEE_CLASS_TYPE) , & 
 parameter :: IEEE_NEGATIVE_DENORMAL 
 type (IEEE_CLASS_TYPE) , parameter:: IEEE_NEGATIVE_INF 
 type (IEEE_CLASS_TYPE) , parameter:: IEEE_NEGATIVE_NORMAL 
 type (IEEE_CLASS_TYPE) , parameter:: IEEE_NEGATIVE_ZERO 
 type (IEEE_CLASS_TYPE) , parameter:: IEEE_POSITIVE_DENORMAL 
 type (IEEE_CLASS_TYPE) , parameter:: IEEE_POSITIVE_INF 
 type (IEEE_CLASS_TYPE) , parameter::IEEE_POSITIVE_NORMAL 

491
32.5 ISO TR 15580
 type (IEEE_CLASS_TYPE) , parameter::IEEE_POSITIVE_ZERO 
 type (IEEE_CLASS_TYPE) , parameter::IEEE_QUIET_NAN 
 type (IEEE_CLASS_TYPE) , parameter::IEEE_signalling_NAN 
 elemental type(IEEE_CLASS_TYPE) function IEEE_class(X) 
real(kind),intent(in) :: X 
 Returns the appropriate value of IEEE_CLASS_TYPE for the number X, which 
may be of any IEEE kind. 
 In addition to ISO/IEC TR 15580:1998(E), the module IEEE_ARITHMETIC 
deﬁ nes the “==“ and “/=“ operators for the IEEE_CLASS_TYPE. These may be 
used to test the return value of the IEEE_class function, e.g.,
 use,intrinsic :: IEEE_ARITHMETIC, only: IEEE_class, & 
IEEE_QUIET_NAN, operator(==) 
 . . . 
 if (IEEE_class(X)== IEEE_QUIET_NAN) then 
 . . . 
 elemental real(kind) function IEEE_VALUE(X,class) 
real(kind),intent(in) :: X 
type(IEEE_CLASS_TYPE),intent(in) :: class 
 Returns a sample value of the speciﬁ ed class for the same kind of real as X, 
which may be of any IEEE kind.
 elemental LOGICAL function IEEE_IS_FINITE(X) 
 real(kind),intent(in) :: X 
 Returns TRUE if X is not inﬁ nite or NaN. 
 elemental LOGICAL function IEEE_IS_NAN(X) 
 real(kind),intent(in) :: X 
 Returns TRUE if X is either a signalling or quiet NaN. 
 elemental LOGICAL function IEEE_IS_NEGATIVE(X) 
 real(kind),intent(in) :: X 
 Returns TRUE if X is negative, including negative zero. 
 elemental LOGICAL function IEEE_IS_NORMAL(X) 
 real(kind),intent(in) :: X 
 Returns TRUE if X is not an inﬁ nity, NaN, or denormal. 

492
32 ISOTR 15580 IEEE Arithmetic
 elemental LOGICAL function IEEE_UNORDERED(X,Y) 
 real(kind),intent(in) :: X,Y 
 Returns TRUE if X is a NaN or if Y is a NaN. 
 32.5.3.5 Arithmetic Operations 
 elemental real(kind) function IEEE_COPY_SIGN(X,Y) 
 real (kind) , intent(in) :: X,Y 
 Returns X with the sign of Y, even for NaNs and inﬁ nities. 
 elemental real (kind) function IEEE_LOGB(X) 
 real (kind) , intent(in) :: X 
 Returns the unbiased exponent as a real value: 
 if X is zero, IEEE_DIVIDE_BY_ZERO signals and the result is –inﬁ nity if IEEE 
inﬁ nities are supported for that kind, and –HUGE(X) if not. 
 if X is inﬁ nite, the result is + inﬁ nity. 
 if X is a NaN, the result is a quiet NaN (the same one if X is a quiet NaN); otherwise 
the result is EXPONENT(X)-1. 
 elemental real (kind) function IEEE_NEXT_AFTER(X,Y) 
 real (kind) , intent(in) :: X,Y 
 The same as NEAREST(X,1.0_kind) for Y > X and NEAREST(X,-1.0_kind) for Y 
< X; if Y==X, the result is X, if either X or Y are NaNs the result is one of these 
 NaNs. 
 elemental real (kind) function IEEE_REM(X,Y) 
real (kind) , intent(in) :: X,Y 
 X-Y*N exactly, where N is the integer nearest to the exact value X/Y. if the result is 
zero, it has the same sign as X. This function is not affected by the rounding mode. 
 elemental real (kind) function IEEE_RINT(X) 
 real (kind) , intent(in) :: X 
 Round to an integer according to the current rounding mode. 
 elemental real (kind) function IEEE_SCALB(X,I) 
 real (kind1) , intent(in) :: X 
 integer (kind2) , intent(in) :: I 
 The same as SCALE(X,I). 

493
32.7 Bibliography
 32.6  Summary 
 Support for the above is relatively limited at the time of writing this book. There is 
always a time lag between the formal publication of a standard and the implementa-
tion in production compilers. As compiler support improves examples will be added 
to our web site. Our home page is:
 
• http://www.fortranplus.co.uk/ 
 32.7  Bibliography 
 Hauser , J.R.: Handling ﬂ oating point exceptions in numeric programs. ACM Trans. 
Program. Lang. Syst.  18 (2), 139–174 (1996)
 The paper looks at a number of techniques for handling ﬂ oating point exceptions 
• 
in numeric code. One of the conclusions is for better structured support for ﬂ oat-
ing point exception handling in new programming languages, or of course better 
standards for existing languages. 
 IEEE, IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Std 754-
2008, Institute of Electrical and Electronic Engineers Inc. 
 The formal deﬁ nition of IEEE 754. This is available for purchase at  http://www.
techstreet.com/standards/ieee/754_2008?product_id=1 745167 as both a pdf and 
printed version. 
 This standard speciﬁ es formats and methods for ﬂ oating-point arithmetic in 
computer systems: standard and extended functions with single, double, extended, 
and extendable precision, and recommends formats for data interchange. Exception 
conditions are deﬁ ned and standard handling of these conditions is speciﬁ ed. 
Keywords: 754-2008,arithmetic,binary,computer,decimal, exponent, ﬂ oating-point,
format,interchange,NaN,number,rounding,signiﬁ cand,subnormal. Product Code(s): 
STDPD95802,STD95802 
 Knuth, D.: Seminumerical Algorithms. Addison-Wesley, Reading (1969)
 There is a coverage of ﬂ oating point arithmetic, multiple precision arithmetic, 
• 
radix conversion and rational arithmetic. 
 Sun: Numerical Computation Guide. SunPro, Mountain View (1995)
 Very good coverage of the numeric formats for IEEE Standard 754 for Binary 
• 
Floating-Point Arithmetic. All SunPro compiler products support the features of 
the IEEE 754 standard. 

494
32 ISOTR 15580 IEEE Arithmetic
 32.7.1  Web-Based Sources 
 http://validgh.com/goldberg/addendum.html 
 Differences Among IEEE 754 Implementations. The material in this paper will 
• 
eventually be included in the Sun Numerical Computation Guide as an adden-
dum to Appendix C, David Goldberg’s What Every Computer Scientist Should 
Know about Floating Point Arithmetic. 
http ://docs. sun.com/
 Follow the links to the Floating Point and common Tools AnswerBook. The 
• 
Numerical Computation Guide can be browsed on-line or down loaded as a pdf 
ﬁ le. The last time we checked it was about 260 pages. Good source of informa-
tion if you have Sun equipment. 
 http ://www.validgh.com/ 
 This web site contains technical and business information relating to the validgh 
• 
professional consulting practice of David G. Hough. Contains links to the 
Goldberg paper and the above addendum by Doug Priest. 
 http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html 
 Brief coverage of IEEE arithmetic with pointers to further sources. There is also 
• 
a coverage of the storage layout and ranges of ﬂ oating point numbers. Computer 
Science 341 is an introduction to the design of a computer’s hardware, particu-
larly the CPU and memory systems. 
 http://www.nag.co.uk/nagware/NP/TR.html 
 NAG provide coverage of TR 15580 and TR 15581. The ﬁ rst is the support 
• 
Fortran has for IEEE arithmetic. 
 http://www.cs.berkeley.edu/~wkahan/ 
 Willam Kahan home page. 
• 
 http://www.cs.berkeley.edu/~wkahan/ieee754status/754story.html 
 An Interview with the Old Man of Floating Point. Reminiscences elicited from 
• 
William Kahan by Charles Severance, which appeared in an issue of IEEE 
Computer – March 1998. 
 http://www.cs.berkeley.edu/~wkahan/ieee754status/ieee754.ps 
 Lecture Notes on the Status of IEEE Standard 754 for Binary Floating-Point 
• 
Arithmetic. Well worth a read. 
 http://www.stewart.cs.sdsu.edu/cs575/labs/l3ﬂ oatpt.html 
 CS 575 Supercomputing – Lab 3: Floating Point Arithmetic. CS 575 is an inter-
• 
disciplinary course to introduce students in the sciences and engineering to 
advanced computing techniques using the supercomputers at the San Diego 
Supercomputer Center (SDSC). 

495
32.7 Bibliography
 http://www.mathcom.com/nafaq/index.html 
 FAQ: Numerical Analysis and Associated Fields Resource Guide. A summary of 
• 
Internet resources for a number of ﬁ elds related to numerical analysis. 
 http://www.math.psu.edu/dna/disasters/ariadne.html 
 The Explosion of the Ariane 5: A 64-bit ﬂ oating point number relating to the 
• 
horizontal velocity of the rocket with respect to the platform was converted to a 
16-bit signed integer. The number was larger than 32,768, the largest integer 
storeable in a 16-bit signed integer, and thus the conversion failed. 
 32.7.2  Hardware Sources 
 Amd 
 Visit 
 http://developer.amd.com/documentation/guides/pages/default.aspx 
for details of the AMD manuals. The following ﬁ ve manuals are available for down-
load as pdf s from the above site.
 AMD64 Architecture Programmer’s Manual Volume 1: Application Programming 
• 
 AMD64 Architecture Programmer’s Manual Volume 2: System Programming 
• 
 AMD64 Architecture Programmer’s Manual Volume 3: General Purpose and 
• 
System Instructions 
 AMD64 Architecture Programmer’s Manual Volume 4: 128-bit and 256 bit 
• 
media instructions 
 AMD64 Architecture Programmer’s Manual Volume 5: 64-Bit Media and x87 
• 
Floating-Point Instructions 
 Intel 
 Visit 
 http://www.intel.com/products/processor/manuals/index.htm 
 for a list of manuals. The following three manuals are available for download as pdf 
s from the above site.
 Intel® 64 and IA-32 Architectures Software Developer’s Manual. Volume 1: 
• 
Basic Architecture 
 Intel® 64 and IA-32 Architectures Software Developer’s Manual. Combined 
• 
Volumes 2A and 2B: Instruction Set Reference, A-Z. 
 Intel® 64 and IA-32 Architectures Software Developer’s Manual. Combined 
• 
Volumes 3A and 3B: System Programming Guide, Parts 1 and 2 

496
32 ISOTR 15580 IEEE Arithmetic
 Osbourne, A., Kane, G.: 4-bit and 8-bit Microprocessor Handbook. Osbourne/
McGraw-Hill, Berkeley (1981)
 Good source of information on 4-bit and 8-bit microprocessors. Osbourne, A., 
• 
Kane, G.: 16-Bit Microprocessor Handbook. Osbourne/McGraw-Hill, Berkely 
(1981) 
 Ditto 16-bit microprocessors. 
• 
 Bhandarkar, D.P.: Alpha Implementations and Architecture: Complete Reference 
and Guide. Digital Press, Boston (1996)
 Looks at some of the trade-offs and design philosophy behind the alpha chip. 
• 
The author worked with VAX, Micro VAX and VAX vectors as well as the Prism. 
Also looks at the GEM compiler technology that DEC/Compaq use. 
 http://www.digital.com/alphaserver/workstations/ 
 Home page for the Compaq/DEC Alpha systems. 
• 
 http://www.sgi.com/ 
 Silicon Graphics home page. 
• 
 http://www.sun.com/ 
 Sun home page. 
• 
http :// www.ibm.com/ 
 IBM home page. 
• 
 32.7.3  Operating Systems 
 Deitel, H.M.: An Introduction to Operating Systems. Addison-Wesley, Reading 
(1990) 
 The revised ﬁ rst edition includes case studies of UNIX, VMS, CP/M, MVS and 
VM. The second edition adds OS/2 and the Macintosh operating systems. There is 
a coverage of hardware, software, ﬁ rmware, process management, process concepts, 
asynchronous concurrent processes, concurrent programming, deadlock and indeﬁ -
nite postponement, storage management, real storage, virtual storage, processor 
management, distributed computing, disk performance optimisation, ﬁ le and data-
base systems, performance, coprocessors, risc, data ﬂ ow, analytic modelling, net-
works, security and it concludes with case studies of the these operating systems. 
The book is well written and an easy read. 

497
32.7 Bibliography
 32.7.4  Java and IEEE 754 
 http://www.cs.berkeley.edu/~darcy/Borneo/ 
 Borneo Language Homepage: Borneo is a dialect of the Java language designed 
• 
to have true support for the IEEE 754 ﬂ oating point standard. The status of arith-
metic in Java is ﬂ uid. At the time of writing this book Sun had withdrawn from 
the formal language standardisation process. Sun have a publication at their web 
site that addresses changes to the Java language speciﬁ cation for JDK Release 
1.2 ﬂ oating point arithmetic. Their home Java page is 
 
• http://www.java.sun.com/ 
 32.7.5  C and IEEE 754 
 http://wwwold.dkuug.dk/JTC1/SC22/WG14/ 
 The ofﬁ cial home of JTC1/SC22/WG14 – C. The C programming language stan-
• 
dard ISO/IEC 9899 was adopted by ISO in 1990. ANSI then replaced their ﬁ rst 
standard X3.159 by the ANSI/ISO 9899 standard identical to ISO/IEC 9899:1990. 

499
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_33, © Springer-Verlag London Limited 2012
 Aims 
 The aims of this chapter are to look at some additional features of Fortran and also 
provide coverage of a small number of other areas including
 keyword and optional arguments 
• 
 Non recursive quicksort 
• 
 Simple graphics programming – dislin 
• 
 33.1  Introduction 
 This chapter looks at a small number of additional examples that don’t really ﬁ t 
anywhere else. We also cover a small number of additional Fortran concepts. 
 33.2  Keyword and Optional Arguments 
 The examples of procedures so far have assumed that the dummy arguments and the 
corresponding arguments are in the same position, i.e., we are using positional argu-
ments. Fortran also provides the ability to supply the actual arguments to a proce-
dure by keyword, and hence in any order. 
 Chapter 33 
 Miscellaneous Features and Examples  
 The Analytical Engine weaves algebraic patterns, just as the 
Jacquard loom weaves ﬂ owers and leaves. 
 Ada Lovelace 

500
33 Miscellaneous Features and Examples
 To do this the name of the dummy argument is referred to as the keyword and is 
speciﬁ ed in the actual argument list in the form
 dummy-argument = actual-argument  
 To illustrate this, let us consider a subroutine to solve ordinary differential equa-
tions. The full subroutine and explanation are given in Chap.  25 :
 subroutine Runge_Kutta_Merson(Y,FUN,IFAIL,N,A,B,TOL) 
where A is the initial point, B is the end point at which the solution is required, TOL 
is the accuracy to which the solution is required and N is the number of equations. 
 The subroutine can be called as follows:
 call Runge_Kutta_Merson ( Y , Fun1 , IFAIL , A=0.0 , & 
B=8.0 , Tol=1.0E-6 , N=3)  
where the dummy arguments A, B, Tol and N are now being used as keywords. The 
use of keyword arguments makes the code easier to read and decreases the need to 
remember their precise position in the argument list. 
 Also with Fortran comes the ability to specify that an argument is optional. This 
is very useful when designing procedures for use by a range of programmers. Inside 
a procedure defaults can be set for the optional arguments providing an easy-to-use 
interface, while at the same time allowing sophisticated users a more comprehen-
sive one. 
 To declare a dummy argument to be optional the optional attribute can be used. 
For example, the last dummy argument Tol for the subroutine Runge_Kutta_Merson 
could be declared to be optional (although internally in the subroutine the code 
would have to be changed to allow for this), e.g.,
 Subroutine 
Runge_Kutta_Merson(Y,FUN,IFAIL,N,A,B,Tol) 
use Precision_module  
real(Long), intent(inout), optional :: Tol  
 and because it is at the end of the dummy argument list, calling the subroutine with 
a positional argument list, Tol can be omitted, e.g.,
 call Runge_Kutta_Merson(Y,Fun1,IFAIL,N,A,B)  
 The code of the subroutine will need to be changed to check to see if the argu-
ment Tol is supplied, the intrinsic function PRESENT being available for this pur-
pose. Sample code is given below:
 subroutine Runge_Kutta_Merson(Y, FUN, IFAIL, N,A,B,Tol) 
use Precision_module  
 ! code left out  
 real(Long),intent(in),optional::Tol  
 real(Long)::Internal_tol = 1.0D-3 
 if(PRESENT(Tol)) then  
Internal_tol=Tol  
 print*, 'Tol = ', Internal_tol,' is    supplied'  

501
33.3 Allocatable Dummy Arrays
 else 
 print*,"Tol isn't supplied, default tolerance = "  
 print *,Internal_tol,' is used'  
 endif  
 ! code left out but all references to tol  
 ! would have to be changed to  
 internal_tol  
 end subroutine Runge_Kutta_Merson 
 A number of points need to be noted when using keyword and optional 
arguments:
 if all the actual arguments use keywords, they may appear in any order. 
• 
 When only some of the actual arguments use keywords, the ﬁ rst part of the list 
• 
must be positional followed by keyword arguments in any order. 
 When using a mixture of positional and keyword arguments, once a keyword 
• 
argument is used all subsequent arguments must be speciﬁ ed by keyword. 
 if an actual argument is omitted the corresponding optional dummy argument 
• 
must not be redeﬁ ned or referenced, except as an argument to the PRESENT 
intrinsic function. 
 if an optional dummy argument is at the end of the argument list then it can just 
• 
be omitted from the actual argument list. 
 Keyword arguments are needed when an optional argument not at the end of an 
• 
argument list is omitted, unless all the remaining arguments are omitted as well. 
 Keyword and optional arguments require explicit procedure interfaces, i.e., the 
• 
procedure must be internal, a module procedure or have an interface block avail-
able in the calling program unit. 
 A number of the intrinsic procedures we have used have optional arguments. 
Consult Appendix C for details. 
 33.3  Allocatable Dummy Arrays 
 In the recursive subroutine example using quicksort in Chap.  20 the allocation took 
place in the main program. In this example the allocation takes place in the read_
data subroutine.
 module read_data_module  
implicit none  
 contains 
 subroutine read_data(ﬁ le_name,raw_data,how_many)  
implicit none  
 character (len=*), intent (in) :: ﬁ le_name  
 integer, intent (in) :: how_many  
 real, intent (out), allocatable, &
dimension (:) :: raw_data  

502
33 Miscellaneous Features and Examples
 ! local variables 
 integer : : I  
 allocate(raw_data(1:how_many))  
 open (ﬁ le=ﬁ le_name,unit=1)  
 do I = 1, how_many 
 read (unit=1,fmt=*) raw_data(I)  
 end do  
 end subroutine read_data  
 end module read_data_module  
 module sort_data_module 
 implicit none  
 contains 
 subroutine sort_data(raw_data,how_many)  
implicit none  
 integer, intent (in) :: how_many  
 real, intent (inout), dimension (:) :: raw_data  
 call quicksort(1,how_many)  
 contains 
 recursive subroutine quicksort(l,r)  
implicit none  
 integer, intent (in) :: l, r  
 ! local variables 
 integer :: I, j  
 real : : v, t  
 I = l  
 j = r  
 v = raw_data(int((l+r)/2))  
 do 
 do while (raw_data(i)<v)
 I = I + 1  
 end do  
 do while (v<raw_data(j) ) 
 j = j – 1  
 end do  
 if (i<=j) then 
  t = raw_data(I)  
 raw_data(I) = raw_data(j)  
 raw_data(j) = t  
 I = I + 1  
 j = j – 1  
 end if  
 if (i>j) exit  
 end do  

503
33.3 Allocatable Dummy Arrays
 if (l<j) then 
 call quicksort(l,j)  
 end if  
 if (i<r) then 
 call quicksort(i, r)  
 end if  
 end subroutine quicksort  
 end subroutine sort_data  
 end module sort_data_module  
 module print_data_module 
 implicit none  
 contains 
 subroutine print_data(raw_data,how_many)  
implicit none  
 integer, intent (in) :: how_many  
 real, intent (in), dimension (:) :: raw_data  
 ! local variables 
 integer : : I  
 open (ﬁ le='sorted.txt',unit=2)  
 do I = 1, how_many 
 write (unit=2,fmt=*) raw_data(I)  
 end do  
 close (2)  
 end subroutine print_data  
 end module print_data_module 
 program ch3301  
use read_data_module  
 use sort_data_module  
 use print_data_module  
 implicit none  
 integer :: how_many  
 character (len=20) :: ﬁ le_name  
 real, allocatable, dimension (:) :: raw_data  
 integer, dimension (8) :: timing  
  print *, ' how many data items are there?'  
 read *, how_many  
 print *, ' what is the ﬁ le name?'  
 read ' (a) ', ﬁ le_name  
 call date_and_time(values=timing)  
 print *, ' initial'  
 print *, timing(6), timing(7), timing(8)  

504
33 Miscellaneous Features and Examples
 call read_data(ﬁ le_name,raw_data,how_many)  
 call date_and_time(values=timing)  
 print *, ' allocate and read'  
 print *, timing(6), timing(7), timing(8)  
 call sort_data(raw_data,how_many)  
 call date_and_time(values=timing)  
 print *, ' sort'  
 print *, timing (6), timing (7), timing (8)  
 call print_data(raw_data,how_many)  
 call date_and_time(values=timing)  
 print *, ' print'  
 print *, timing (6), timing (7), timing (8)  
 print *, ' '  
 print *, ' data written to ﬁ le sorted.txt'  
 end program ch3301 
 We now have a choice of where we do the allocation. This is more ﬂ exible than 
having to do the allocation in the main program, which is effectively a more Fortran 
77 style of programming. 
 33.4  Non Recursive Quicksort 
 The following subroutine is a non recursive Fortran 77 implementation of quicksort. 
It is taken from the Netlib site. Their web address is
 http://www.netlib.org/  
 The following is taken directly from their FAQ.
 What is Netlib? The Netlib repository contains freely available software, documents, and 
databases of interest to the numerical, scientiﬁ c computing, and other communities. The 
repository is maintained by AT&T Bell Laboratories, the University of Tennessee and Oak 
Ridge National Laboratory, and by colleagues world-wide. The collection is replicated at 
several sites around the world, automatically synchronized, to provide reliable and network 
efﬁ cient service to the global community. 
 We located the subroutine by doing a search at the Netlib site on sort. One of the 
entries returned is to the routine dsort.f 
 Here is this subroutine. 

505
33.4 Non Recursive Quicksort

506
33 Miscellaneous Features and Examples

507
33.4 Non Recursive Quicksort

508
33 Miscellaneous Features and Examples

509
33.4 Non Recursive Quicksort

510
33 Miscellaneous Features and Examples

511
33.4 Non Recursive Quicksort

512
33 Miscellaneous Features and Examples

513
33.4 Non Recursive Quicksort
 We will look at the ways that we can replace our call to quicksort in ch2005 with 
a call to dsort. Here is the header for the dsort routine.
 SUBROUTINE DSORT (DX, DY, N, KFLAG)  
 The routine takes 4 parameters and we look at the implementation of the dsort 
routine to ﬁ nd out more details about each parameter. This line 
provides the ﬁ rst clue as to the nature of the parameters. The following provide 
some more. 

514
33 Miscellaneous Features and Examples
 The following lines then complete the information. 
 So we have a type mismatch between the array argument to our  quicksort  
and the netlib  dsort . All we need to do here is a global search and replace of 
 double precision with  real in  dsort .  f in our favourite editor. 
 The second problem is what to do about the second argument the  DY array. One 
solution to this problem is to use the same  raw_data  array and set  KFLAG  to 1. 
This ignores the  DY array. 
 The next problem we have are the calls to the external routines shown below. 
 and 

515
33.4 Non Recursive Quicksort
 The simple solution here is just to comment out the calls to XERMSG as we 
know the errors cannot occur. We also need to comment out the external statement 
referencing XERMSG. 
 The following lines 
provide details about the algorithm and its revision history. This information is 
extremely use when working with the subroutine. 
 We are now going to look at one solution to the problem of how to integrate the 
original program and the  dsort.f routine. We can independently compile the 
dsort.f routine as a Fortran 77 style routine and generate an object ﬁ le. We can then 
compile the program and add the object ﬁ le to the compilation line. 
 Here are solutions using a variety of compilers. 

516
33 Miscellaneous Features and Examples
 33.4.1  Gfortran  
 33.4.2  Intel 

517
33.4 Non Recursive Quicksort
 33.4.3  Nag 
 >nagfor -c dsort.f  
 >nagfor ch2005.f90 dsort.o  
 >a.exe 
 how many data items are there?  
 10000000 
 what is the ﬁ le name?  
 random.txt 
 initial  
 1 4 970 
 allocate  
 1 4 975 
 read  
 1 8 721 
 sort  
 1 11 135 
 print  
 1 20 378 
 data written to ﬁ le sorted.txt 
 33.4.4  Notes – Version Control Systems 
 The original program had the following statement
 *DECK DSORT 
and this statement was one used in version control or revision control software of 
the time. Two that were available on CDC systems from the 1970s to 1980s were 
called update and modify and they used so called  deck names as seen in this exam-
ple. In computer programming, revision control is any practice that tracks and pro-
vides control over changes to source code. Software developers also use revision 
control software to maintain documentation and conﬁ guration ﬁ les as well as source 
code. 
 The use of this kind of software is common for medium to large scale program 
development. 
 Wikipedia provides a comparison of what is currently available. See
 http:/en.wikipedia.org/wiki/Comparison_of_revision_control_
software  
for more information. 

518
33 Miscellaneous Features and Examples
 33.5  Simple Graphics Programming – Dislin 
 We have already used the dislin graphics library in earlier chapters. Our resource 
ﬁ le
  http://www.fortranplus.co.uk/resources/fortran_
resources.pdf  
provides details of some of the graphics libraries available. This is the dislin home 
page.
  http://www.mps.mpg.de/dislin/  
 Here is a description of the software from the above page.
 The software is available for several C, Fortran 77 and Fortran 90/95 compilers 
• 
on the operating systems UNIX, Linux, FreeBSD, Open VMS, Windows, Mac 
OSX and MS-DOS. DISLIN programs are very system-independent, they can be 
ported from one operating system to another with out any changes. 
 The original program on which this is based was written by Ian whilst he was on 
secondment to the United Nations Environment Programme. Section 9 of their 
Environmental Data Reports cover natural disasters and these include
 Earthquakes 
• 
 Volcanoes 
• 
 Tsunamis 
• 
 Floods 
• 
 Landslides 
• 
 Natural dams 
• 
 Droughts 
• 
 Wildﬁ res 
• 
 See the bibliography for more details of these publications. The tsunami data sets 
are from this chapter. 
 The tsunami data ﬁ le can be found at:
  http://www.fortranplus.co.uk/  

519
33.5 Simple Graphics Programming – Dislin
 There are some minor wrap problems with the code: 

520
33 Miscellaneous Features and Examples

521
33.5 Simple Graphics Programming – Dislin

522
33 Miscellaneous Features and Examples

523
33.5 Simple Graphics Programming – Dislin

524
33 Miscellaneous Features and Examples

525
33.5 Simple Graphics Programming – Dislin

526
33 Miscellaneous Features and Examples

527
33.5 Simple Graphics Programming – Dislin

528
33 Miscellaneous Features and Examples
 Here is the plot produced by this program. 

529
33.6 Problem
 As you can see there are a lot of tsunami events in the Paciﬁ c area. A colour A4 
pdf of the plot can be found at the Fortranplus website. 
 It is a common requirement in science and engineering to have to produce graph-
ical output and we have now brieﬂ y covered some of the capability of the dislin 
library. Most graphics libraries will offer similar functionality. 
 33.6  Problem 
 1.  The complete working version of the non recursive version of quicksort has not 
been included. The source ﬁ les (Netlib dsort.f and our ch2005.f90) required are 
available at the Fortranplus website. 
 Download them and make the changes necessary to replace the call to quicksort 
with a call to dsort with your compiler. What timing information do you get? 
 33.6.1  Hint 
 diff is a Unix command that compares text ﬁ les. Here is the diff output from com-
paring the original dsort.f ﬁ le with a working version. 

530
33 Miscellaneous Features and Examples
diff is a very useful utility for comparing different versions of your programs! 
 33.7  Bibliography 
 United Nations Environment Programme: Environmental Data Report: 1989–1990, 
Second Edition, Blackwell Reference, Oxford (1989) 
 United Nations Environment Programme: Environmental Data Report: 1991–1992, 
Third Edition, Blackwell Reference, Oxford (1991) 

531
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9_34, © Springer-Verlag London Limited 2012
 Aim 
 This chapter looks at some of the options available when working with older 
Fortran code. 
 34.1  Introduction 
 This chapter looks at converting Fortran 77 code to a modern Fortran style. 
 The aim is to provide the Fortran 77 programmer (and in particular the person 
with legacy code) with some simple guidelines for conversion. 
 The ﬁ rst thing that one must have is a thorough understanding of the newer, better 
language features of Fortran. It is essential that the material in the earlier chapters 
of this book are covered, and some of the problems attempted. This will provide a 
feel for modern Fortran. 
 The second thing one must have is a thorough understanding of the language 
constructs used in your legacy code. Use should be made of the compiler documen-
tation for whatever Fortran 77 compiler you are using, as this will provide the 
detailed (often system speciﬁ c) information required. The recommendations below 
are therefore brief. 
 Chapter 34 
 Converting from Fortran 77  
 Twas brillig, and the slithy toves 
 did gyre and gimble in the wabe; 
 All mimsy were the borogoves, 
 And the mome raths outgrabe. 
 Lewis Carroll 

532
34 Converting from Fortran 77
 It is possible to move gradually from Fortran 77 to modern Fortran. In many 
cases existing code can be quite simply recompiled by a suitable choice of compiler 
options. This enables us to mix and match old and new in one program. This process 
is likely to highlight nonstandard language features in your old code. There will 
inevitably be some problems here. 
 The standard identiﬁ es two kinds of decremented features; deleted and obso-
lescent. It is extremely unwise to consider the long-term use of these features as 
they are candidates for removal from future standards. 
 34.2  Deleted Features 
 The list of deleted features for Fortran 2008 is empty, i.e., there are none. 
 34.3  Obsolescent Features 
 The obsolescent features are those for which better methods are available. They are 
given below with alternatives. 
 34.3.1  Arithmetic if 
 Use the if statement. 
 34.3.2  Real and Double Precision Do Control Variables 
 Use integer. 
 34.3.3  Shared Do Termination and Non-enddo Termination 
 Use an end do. 
 34.3.4  Alternate Return 
 Use a case statement on return. An error code has to be returned. 

533
34.4 Better Alternatives
 34.3.5  Pause Statement 
 System speciﬁ c. Normally easily replaced with a suitable read statement. 
 34.3.6  Assign and Assigned Goto Statements 
 Fortunately rarely used. 
 34.3.7  Assigned Format Statements 
 Use character arrays, arrays and constants. 
 34.3.8  H Editing 
 Use character edit descriptor. 
 34.4  Better Alternatives 
 Below we are looking at the new features of the Fortran standard, and how we can 
replace our current coding practices with the better facilities that now exist.
 Double precision – use KIND, see Chap.  5 , and examples throughout the book. 
• 
 Fixed format – use free format 
• 
 Implicit typing – use implicit none 
• 
 Block data – use modules 
• 
 Common statement – use modules 
• 
 Equivalence – Invariably the use of this feature requires considerable system 
• 
speciﬁ c knowledge. There will be cases where there have been extremely good 
reasons why this feature has been used, normally efﬁ ciency related. However 
with the rapid changes taking place in the power and speed of hardware these 
reasons are diminishing. 
 Assumed-size/explicit-shape dummy array arguments – if a dummy argument is 
• 
assumed-size or explicit-shape (the only ones available in Fortran 77) then the 
ranks of the actual argument and the associated argument don’t have to be the 
same. With Fortran arrays are now objects instead of a linear sequence of ele-
ments, as was the case with Fortran 77, and now for array arguments the funda-
mental rule is that actual and dummy arguments have the same rank and same 

534
34 Converting from Fortran 77
extents in each dimension, i.e., the same shape, and this is done using assumed-
shape dummy array arguments. An explicit interface is mandatory for assumed-
shape arrays. 
 Entry statement – use module plus use statement. 
• 
 Statement functions – use internal function, see Chap.  12 . 
• 
 Computed goto – use case statement, see Chap.  13 . 
• 
 Alternate return – use error ﬂ ags on calling routine. 
• 
 external statement for dummy procedure arguments – use modules and interface 
• 
blocks. See the Runge-Kutta-Merson example in Chap.  25 . 
 Use explicit interfaces everywhere, i.e. use module procedures. This also pro-
vides argument checking and other beneﬁ ts. 
 34.5  Commercial Conversion Tools 
 At the time of writing there are several options. Have a look at our Fortran 
resource ﬁ le: 
 http://www.fortranplus.co.uk/resources/fortran_resources.pdf 
for up to date information. 
 Here are brief details of the tools currently available. 
 34.5.1  Convert 
 Fortran 77 to Fortran 90 converter by Mike Metcalf. 
 http://www.nag.co.uk/nagware/Examples/convert.f90 
 34.5.2  Forcheck 
 A Fortran analyzer and programming aid. 
 http://www.forcheck.nl/ 
 34.5.3  Forstruct 
 Restructures FORTRAN into Clean, Maintainable Code. 
 http://www.cobalt-blue.com/fs/fsmain.htm 

535
34.6 Example of plusFORT Capability from Polyhedron Software 
 34.5.4  Forstudy 
 Analyzes and Documents your FORTRAN code. 
 http://www.cobalt-blue.com/ 
 34.5.5  Fortran90-Lint 
 For Fortran 90 program analysis 
 http://legacy.cleanscape.net/products/downloads/ftpﬂ int.html 
 34.5.6  Plusfort 
 Fortran 77 to Fortran 90 converter. 
 http://www.polyhedron.com/ 
 34.5.7  VAST/77to90 
 Fortran 77 to Fortran 90 translator 
 http://www.crescentbaysoftware.com/vast_77to90.html 
 34.6  Example of plusFORT Capability 
from Polyhedron Software 
 Below is an example from their site that looks at the same subroutine in Fortran 66, 
77 and 90 styles. 
 34.6.1  Original Fortran 66 
 This subroutine picks off digits from an integer and branches depending on 
their value.

536
34 Converting from Fortran 77
 subroutine OBACT(TODO)  
 integer TODO,DONE,IP,BASE  
 common /EG1/N,L,DONE  
 parameter (BASE=10)  
 13 if(TODO.EQ.0) GO TO 12 
 I=MOD(TODO,BASE)  
 TODO=TODO/BASE  
 GO TO(62,42,43,62,404,45,62,62,62),I  
 GO TO 13  
 42 call COPY 
 GO TO 127  
 43 call MOVE 
 GO TO 144  
 404 N=-N  
 44 call DELETE 
 GO TO 127  
 45 call print 
 GO TO 144  
 62 call BADACT(I) 
 GO TO 12  
 127 L=L+N  
 144 DONE=DONE+1 
 call RESYNC  
 GO TO 13  
 12 return  
 end 
 34.6.2  Fortran 77 Version 
 In addition to restructuring, SPAG has renamed some variables, removed the unused 
variable IP, inserted declarations, and used upper and lower case to distinguish dif-
ferent types of variable:   

537
34.6 Example of plusFORT Capability from Polyhedron Software 
 34.6.3  Fortran 90 Version 
 SPAG has used do while, select case, exit and cycle. No GOTOs or labels remain.   
 This tool suite can also be used in the maintenance of code during 
development. 

538
34 Converting from Fortran 77
 34.7  Summary 
 This chapter has shown some of the options open to you when working with legacy 
code. The emphasis has been on relatively straightforward code restructuring. The 
use of software tools to aid in this is highly recommended as converting manually 
using an editor is obviously going to involve much more work. 

539
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9, © Springer-Verlag London Limited 2012
Glossary 
 Abstract interface   Set of procedure characteristics with dummy argument names 
 Actual argument   A value (variable, expression or procedure) passed from a calling 
program unit to a subprogram unit. 
 Adjustable array   An explicit-shape array that is a dummy argument to a subprogram. 
 Algorithm   Derived from the name of the ninth century Persian mathematician 
Abu Ja’far Mohammed ibn Musa al-Kuwarizmi (father of Ja’far Mohammed, 
son of Moses, native of Kuwarizmi), corrupted through western culture as Al-
Kuwarizmi. Now a sequence of computations. 
 Allocatable   Having the allocatable attribute 
 Allocatable array   An array that has the allocatable attribute. 
 Argument   Exists in two forms; actual argument, which is in the calling routine 
and is one of a variable, expression or procedure, and dummy argument, which 
is in the called routine. 
 Argument association   The process of matching up an actual argument and dum-
my argument during program execution. 
 Array   An array is a data structure where each scalar element has the same type 
and kind. An array may be up to rank 7. It may be referenced by element 
(via subscripts), by section or as a whole. 
 Array constructor   A mechanism used to initialise or give values to a one-
 dimensional array. The RESHAPE function can then be used to handle rank 2 
and above arrays. 
 Array element   A scalar item of an array. An array element is picked out by a 
subscript. 
 Array element ordering    The elements of an array, regardless of rank, form a 
 linear sequence. The sequence is such that the subscripts along the ﬁ rst dimen-
sion vary most rapidly. 
 Array section   A part of an array. The actual set depends on the subscripts. 
 Appendix A

540
Appendix A
 ASCII   American Standard Code for Information Interchange. See Appendix 3. 
 Associate name   Name of construct entity associated with a selector of an associate 
or select type construct 
 Association   The means by which an entity can be referenced by different names in 
one scoping unit, or one or more names in multiple scoping units. 
 Assumed-length dummy argument   A dummy argument that inherits the length 
attribute of the actual argument. 
 Assumed-shape array   A dummy argument that inherits the shape of the associ-
ated argument. 
 Assumed-size array   A dummy array whose size is inherited from the associated 
actual argument. 
 Atomic subroutine   Intrinsic subroutine that performs an action on its atom argu-
ment atomically 
 Attribute   A property of a data type, and speciﬁ ed in a type declaration statement. 
 Automatic array   This is an explicit-shape array that is a local variable in a sub-
program unit. 
 Binding   Type-bound procedure or ﬁ nal subroutine 
 Binding name   Name given to a speciﬁ c or generic type-bound procedure in the 
type deﬁ nition 
 Block   Sequence of executable constructs formed by the syntactic class block and 
which is treated as a unit 
 Bound   The bounds of an array are the upper and lower limits of the index in each 
dimension. 
 Character constant   A constant that is a string of one or more printable ASCII 
characters, enclosed in apostrophes (') or quotation mark ("). 
 Character string   A sequence of one or more characters. These are contiguous. 
 Coarray   Data entity that has nonzero corank 
 Cobound   Bound of a codimension 
 Codimension   Dimension of the pattern formed by a set of corresponding 
 coarrays 
 Collating sequence   The order in which a set of characters is sorted by default. The 
standard does not require that a processor provide the ASCII encoding, but does 
require intrinsic functions that convert between the processor encoding and the 
ASCII encoding. 
 Compilation unit   One or more source ﬁ les that are compiled to form one object 
ﬁ le. 
 Component   Part of a derived type deﬁ nition. 
 Concatenate   Join together two or more character items using the character con-
catenation operator //. 
 Conformable   Two arrays are said to be conformable if they have the same shape. 
 Constant   A constant is a data object whose value cannot be changed. There are 
two kinds in Fortran: one is obtained using the parameter statement; the other is 
a literal constant in an expression; e.g., with the expression 4*ATAN(1) both 4 
and 1 are literal constants. It may be a scalar or an array. 

541
Appendix A
 Contiguous   Normally applied to items that are adjacent in memory, e.g., charac-
ters in a character variable. 
 Corank   Number of codimensions of a coarray 
 Cosubcript   Scalar integer expression 
 Data entity   A data object that has a speciﬁ c type. 
 Data object   A data object is a constant, variable or part of a constant or variable. 
 Data type   For each data type there are the following: 0. a name 1. a set of val-
ues from a domain; 2. a set of valid operations upon these values; 3. a display 
method. There are ﬁ ve predeﬁ ned data types in Fortran and these are integer, 
real, complex, character and logical. 
 For integers the values are drawn from the domain of integer numbers, the 
valid operations are addition, subtraction, multiplication, division and exponen-
tiation, and they are displayed as a sequence of digits. 
 Declaration   A declaration is a nonexecutable statement that speciﬁ es attributes of 
a program element, e.g., specifying the dimension of an array and the type of a 
variable. 
 Default initialization   Mechanism for automatically initializing pointer compo-
nents to have a deﬁ ned pointer association status, and nonpointer components to 
have a particular value. 
 Default kind   The kind type parameter which is used for one of Fortran’s base 
types (integer, real, complex, character or logical) if one is not speciﬁ ed. 
 Deferred-shape array   An allocatable array or an array pointer. The bounds are 
speciﬁ ed with a colon, (:). 
 Deﬁ ned   For a data object having a valid value. 
 Deﬁ ned assignment   Assignment deﬁ ned by a procedure 
 Derived type   A data type that is user deﬁ ned and not one of the ﬁ ve intrinsic 
types. 
 Dimension   An array can be from one to seven dimensioned inclusive. Also called 
the rank. 
 Disassociated   (Pointer association) Pointer association status of not being associ-
ated with any target and not being undeﬁ ned. 
 Dummy argument   A variable name that appears in the bracketed or parenthesised 
list following the procedure name. (e.g., function or subroutine name). Dummy 
arguments take on the actual values of the corresponding arguments in the call-
ing routine. 
 Dynamic type   Type of a data entity at a particular point during execution of a 
program 
 Elemental   An operation that applies independently to each element in an array. 
 Elemental assignment   Assignment that operates elementally. 
 Elemental procedure   Elemental intrinsic procedure or procedure deﬁ ned by an 
elemental subprogram 
 Entity   Rather vague term covering a constant, variable, program unit, etc. 
 Exceptional values   Normally restricted to real numbers and typically one of 
 nonnormalised numbers, inﬁ nity, not-a-number (NaN) values, etc. 

542
Appendix A
 Explicit interface   A mechanism to make information available between the call-
ing routine and the called routine. This information includes the names of the 
procedures, the dummy arguments, the attributes of the arguments, the attributes 
of functions, and the order of the arguments. 
 Explicit-shape array   A named array that has its bounds speciﬁ ed in each 
 dimension. 
 Expression   An expression is a sequence of operands and operators that speciﬁ es 
a computation. 
 Extended type   Type with the extends attribute 
 Extent   The number of elements of one dimension of an array. Also called the size.   
 External subprogram   An external subprogram is one that is global to the whole 
program. 
 Function   One of the two procedure mechanisms available in Fortran along with 
the subroutine. They effectively provide a way of invoking a computation by 
 using the function name, and return a result. There is the concept of type and 
kind for the result. 
 Function reference   A function is invoked by the use of its name in an 
 expression. 
 Function result   The result value(s) from invoking a function. 
 Generic   Simplistically the ability of a procedure to accept arguments of more than 
type. This facility is taken for granted with the intrinsic procedures, and users can 
now create their own generic procedures. 
 Global   An entity that is available throughout the executable program. A global 
entity has global scope. See also scope and local scope. 
 Host association   The mechanism by which a module procedure, internal proce-
dure or derived type deﬁ nition accesses entities of the host. 
 Image   Instance of a Fortran program 
 Image control statement   Statement that affects the execution ordering between 
images 
 Image index   Integer value identifying an image 
 Implicit interface   A procedure interface whose properties are not known within 
the scope of the calling routine. 
 Inherit   (Extended type) acquire entities through type extension from the parent 
type 
 Inheritance association   Association between the inherited components of an 
 extended type and the components of its parent component 
 Inquiry function   A function whose result depends on the properties of the 
 argument. 
 Interface   (Procedure) name, procedure characteristics, dummy argument names, 
binding label, and generic identiﬁ ers 
 Interface block   A sequence of statements starting with an interface statement and 
ending with an end interface statement. 
 Interface body   The sequence of statements in an interface block between either a 
function or subroutine statement and the corresponding end statement. 

543
Appendix A
 Internal procedure   A procedure that is contained within an internal subprogram. 
The program unit containing the internal procedure is called the host. The inter-
nal procedure is local to the host and inherits the host environment through host 
association. 
 Intrinsic procedure   One of the standard supplied procedures. 
 Keyword   Statement keyword, argument keyword, type parameter keyword, or 
component keyword 
 Kind   For each of the ﬁ ve Fortran types (integer, real, complex, logical and char-
acter) there is the concept of kind. For example for integers it is common to ﬁ nd 
8-bit, 16-bit and 32-bit implementations. Each of these has an associated kind 
type. 
 For real and complex types this enables us to choose both the range and preci-
sion of the numbers we work with. 
 For characters we can choose between character sets, which is of considerable 
use for working with different languages. 
 Kind type parameter   An integer value used to identify the kind of one of the ﬁ ve 
base types, see above. 
 Language extension   Most compiler implementations will provide language exten-
sions. These are NOT part of the standard, and make porting code suites between 
different hardware and software platforms difﬁ cult and sometimes impossible. 
 Linker   A program that is normally the ﬁ nal stage in the process of going from 
Fortran source to executable. 
 Local entity   An entity that is only available within the context of a subprogram. 
 Main program   A program unit that contains a program statement. 
 Module   A program unit that contains speciﬁ cations and deﬁ nitions that other pro-
gram units can access and use. 
 Module procedure   A function or subroutine deﬁ ned within a module 
 Name   An entity with a program, e.g., constant, variable, function result, proce-
dure, program unit, dummy argument. 
 Name association   This provides access to the same entity (either data or a proce-
dure) from different scoping units by the same or a different name. 
 Nesting   The placing of one entity within another, e.g., one loop within another or 
one subprogram within another. 
 Nonexecutable statement   A language statement that describes program attributes, 
but does not cause any action when the program is executed. 
 Object ﬁ le   File created after successful compilation. Used by the linker to generate 
an executable. 
 Parameter   Term used to describe two completely different things. 1. a named 
constant—and hence the parameter attribute. 2. more generally equivalent to 
 argument. 
 Parent type   (Extended type) Type named in the extends clause 
 Pointer   A data object that has the pointer attribute. 
 Pointer assignment   Association of a pointer with a target, by execution of a 
 pointer assignment statement or an intrinsic assignment statement for a derived-
type object that has the pointer as a subobject 

544
Appendix A
 Pointer association   The association of a part of memory to a pointer by means of 
a target. 
 Precision   The number of signiﬁ cant digits in a real number. 
 Procedure   A function or subroutine. 
 Procedure interface   The statements that specify the name of a procedure, the char-
acteristics of that procedure, the name of the dummy arguments, the attributes of 
the dummy arguments the generic identiﬁ er (optional) for the procedure. 
 Program   A program is an entity that can be compiled and executed on its own. 
There must be at least a declaration block and execution block. 
 Program unit   A main program or a subprogram. The subprogram can be a func-
tion, subroutine or module. 
 Rank   The rank of an array is the number of dimensions. 
 Recursion   A property of a function or subroutine, and it means that the function or 
subroutine references itself directly or indirectly. 
 Reference   A data object reference is the appearance of a named entity in an 
 executable statement requiring the value of the object. 
 Relational expression   An expression containing one or more of the relational 
 operators and operands of numeric or character type. 
 Scalar   A single data object of any type. A scalar has a rank of zero. 
 Scalar variable   A variable of scalar type. 
 Scope and scoping unit   The part of a program in which a name has a deﬁ ned 
meaning. The name may be a named constant, a variable, a function, a proce-
dure, or dummy argument. The part of the program is one of a program unit or 
subprogram, a derived type deﬁ nition or a procedure interface body. Scoping 
units cannot overlap, but one scoping unit may be contained in another. In the 
latter case we have an example of host association. 
 Shape   The rank and extents of an array. 
 Shape conformance    Generally means that two or more arrays have the same rank 
and extent. 
 Size   The total number of elements in an array—the product of the extents. 
 Source ﬁ le   A ﬁ le known to the operating system that contains the Fortran state-
ments. 
 Statement   An instruction in a programming language, normally classiﬁ ed as ex-
ecutable and nonexecutable. 
 Stride   The increment in a subscript triplet. 
 Structure   Either a scalar data object of derived type or a composite entity contain-
ing one or more subcomponents. 
 Structure component   Component of a structure 
 Structure constructor   Syntax that speciﬁ es a structure value or creates such a 
value 
 Subprogram   A user written or supplied function or subroutine. 
 Subroutine   A user subprogram that is invoked with the call statement. It can return one 
value, many values or no value at all to the calling program through the argu-
ments. 
 Subscript   A scalar integer expression used to select an element of an array 

545
Appendix A
 Subscript triplet   A subscript triplet is a set of three values representing the lower 
bound of the array section, the upper bound of the array section, and the incre-
ment (stride) between them. 
 Substring   A contiguous set of characters in a string. 
 Target   A named data object associated with a pointer. 
 Transformational function   An intrinsic function that is not elemental or inquiry. 
 Truncation   For real numbers the approximation obtained by chopping off the frac-
tional part of the number and working with the integer part. 
 For character variables removing one or more characters from a string. 
 Type-bound procedure   Procedure that is bound to a derived type and referenced 
via an object of that type 
 Type compatible   Compatibility of the type of one entity with respect to another 
for purposes such as argument association, pointer association, and allocation 
 Type declaration   One of the nonexecutable statements in Fortran, and one of inte-
ger, real, complex, character, logical or type. 
 Underﬂ ow   A condition where the result of an arithmetic expression is smaller than 
the minimum value in the range for that data type. 
 Use association   Association between entities in a module and entities in a scoping 
unit or construct that references that module as speciﬁ ed by a USE statement 
 User deﬁ ned type   A data type that is deﬁ ned by the user and not one of the  intrinsic 
types. 
 Variable   A data object that has an associated memory location whose value can be 
changed during program execution. A variable may be a scalar or an array. 

547
 Appendix B
ASCII Character Set 
 0 
 nul 
 32 
 64 
 @ 
 96 
 ' 
 1 
 soh 
 33 
 ! 
 65 
 A 
 97 
 a 
 2 
 stx 
 34 
 " 
 66 
 B 
 98 
 b 
 3 
 etx 
 35 
 # 
 67 
 C 
 99 
 c 
 4 
 eot 
 36 
 $ 
 68 
 D 
 100 
 d 
 5 
 enq 
 37 
 % 
 69 
 E 
 101 
 e 
 6 
 ack 
 38 
 & 
 70 
 F 
 102 
 f 
 7 
 bel 
 39 
 ' 
 71 
 G 
 103 
 g 
 8 
 bs 
 40 
 ( 
 72 
 H 
 104 
 h 
 9 
 ht 
 41 
 ) 
 73 
 I 
 105 
 i 
 10 
 lf 
 42 
 * 
 74 
 J 
 106 
 j 
 11 
 vt 
 43 
 + 
 75 
 K 
 107 
 k 
 12 
 ff 
 44 
 , 
 76 
 L 
 108 
 1 
 13 
 cr 
 45 
 – 
 77 
 M 
 109 
 m 
 14 
 so 
 46. 
 . 
 78 
 N 
 110 
 n 
 15 
 si 
 47 
 / 
 79 
 O 
 111 
 o 
 16 
 dle 
 48 
 0 
 80 
 P 
 112 
 P 
 17 
 dc1 
 49 
 1 
 81 
 Q 
 113 
 q 
 18 
 dc2 
 50 
 2 
 82 
 R 
 114 
 r 
 19 
 dc3 
 51 
 3 
 83 
 S 
 115 
 s 
 20 
 dc4 
 52 
 4 
 84 
 T 
 116 
 t 
 21 
 nak 
 53 
 5 
 85 
 U 
 117 
 u 
 22 
 syn 
 54 
 6 
 86 
 V 
 118 
 v 
 23 
 etb 
 55 
 7 
 87 
 W 
 119 
 w 
 24 
 can 
 56 
 8 
 88 
 X 
 120 
 x 
 25 
 em 
 57 
 9 
 89 
 Y 
 121 
 y 
 26 
 sub 
 58 
 : 
 90 
 Z 
 122 
 z 
 27 
 esc 
 59 
 ; 
 91 
 [ 
 123 
 { 
 28 
 fs 
 60 
 < 
 92 
 \ 
 124 
 | 
 29 
 gs 
 61 
 = 
 93 
 ] 
 125 
 } 
 30 
 rs 
 62 
 > 
 94 
 ^ 
 126 
 ~ 
 31 
 us 
 63 
 ? 
 95 
 _ 
 127 
 del 

549
 Appendix C
Intrinsic Functions and Procedures 
 This appendix has a brief coverage of some of the more commonly used intrinsic 
functions and procedures. Chap.  13 of the standard should be consulted for exhaus-
tive coverage. 
 The following abbreviations and typographic conventions are used in this 
appendix. 
 Argument type and result type: 
 I 
 integer 
 R 
 real 
 C 
 complex 
 N 
 Numeric (any of integer, real, complex) 
 L 
 Logical 
 P 
 pointer 
 P* 
 polymorphic 
 T 
 target 
 DP 
 double precision 
 Char 
 character, length  = 1. 
 S 
 character 
 Boz 
 boz-literal-constant 
 Co 
 coarray or coindexed object 
 Class 
 A 
 indicates that the procedure is an atomic subroutine 
 E 
 indicates that the procedure is an elemental function 
 ES 
 indicates that the procedure is an elemental subroutine 
 I 
 indicates that the procedure is an inquiry function 
 PS 
 indicates that the procedure is a pure subroutine 
 S 
 indicates that the procedure is an impure subroutine 
 T 
 indicates that the procedure in a transformational function 

550
Appendix C
 See Chap.  12 for more information on these classiﬁ cations. 
 Arguments in italics 
 ALL(Mask, Dim ) 
 are optional arguments, i.e., Dim may be omitted in the example above. 
 Double precision 
 Before Fortran 90 if you required real variables to have greater precision than the 
default real then the only option available was to declare them as double precision. 
With the introduction of kind types with Fortran 90 the use of double precision 
declarations is not recommended, and instead real entities with a kind type offering 
more than the default precision should be used. 
 Kind optional argument 
 There are several functions that have an optional argument Kind, e.g., AINT(A, Kind ). 
if Kind is absent the result is the same kind type as the ﬁ rst argument, in this case A. 
if Kind is present the result has the kind type speciﬁ ed by this argument. 
 Result type 
 When the result type is the same as the argument type then the result is not just the 
same type as the argument but also the same kind. 
 Miscellaneous rules 
 When the argument is Back it is of logical type. 
 When the argument is Count_Rate, Count_Max, Dim, Kind, Len, Order, N_Copies, 
Shape, Shift, Values it is of integer type. 
 When the argument is Mask it is of logical type. 
 When the argument is target it is of pointer or target type. 
 Fortran 2008 contained several changes to Fortran 2003 that affects intrinsic procedures.
 The following functions can now have arguments of type complex, ACOS, ASIN, 
ATAN, COSH, SINH, TAN and TANH. 
 The intrinsic function ATAN2 can be referenced by the name ATAN. 
 The intrinsic functions LGE, LGT, LLE and LLT can have arguments of ASCII kind.  
 A BACK= argument has been added to the intrinsic functions MAXLOC and 
MINLOC. 
 A RADIX= argument has been added to the intrinsic function SELECTED_REAL_
KIND. 
 ABS(A) 
 Yields the absolute value unless A is complex; see below. 
 Argument: A 
 Type: N 
 Result: As argument 
 Class: E 
 Note: if A is complex (x,y) then the functions returns  
+
2
2
x
y  
 Example: R1=ABS(A) 
 ACHAR(I) 

551
Appendix C
 Returns character in the ASCII character set. 
 Argument: I 
 Type: I 
 Result: Char 
 Class: E 
 Example: C=ACHAR(I) 
 ACOS(X) 
 Arccosine (inverse cosine). 
 Argument: X 
 Type: R 
 Result: As argument 
 Class: E 
 Note: |  x |  £ 1 
 Example: Y=ACOS(X) 
 ACOSH(X) 
 Inverse hyperbolic cosine function. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Y = ACOSH(X) 
 ADJUSTL(String) 
 Adjust string left, removing leading blanks and inserting trailing blanks. 
 Argument: String 
 Type: S 
 Result: As argument 
 Class: E 
 Example: S=ADJUSTL(S) 
 ADJUSTR(String) 
 Adjust string right, removing trailing blanks and inserting leading blanks. 
 Argument: String 
 Type: S 
 Result: As argument 
 Class: E 
 Example: S=ADJUSTR(S) 
 AIMAG(Z) 
 Imaginary part of complex argument. 
 Argument: Z 
 Type: C 
 Result: As argument 
 Class: E 
 Example: Y=AIMAG(Z) 
 AINT(A, Kind ) 
 Truncation. 
 Argument: A 
 Type: R 
 Result: As A 
 Class: E 
 Argument: Kind 
 Type: I 

552
Appendix C
 Example: Y=AINT(Z) and when Z=0.3 Y=0, when Z=2.73 Y=2.0, when Z=−2.73 
Y=−2.0 
 ALL(Mask, Dim ) 
 Determines whether all values are true in Mask along dimension Dim. 
 Argument: Mask 
 Type: L 
 Result: L 
 Class: T 
 Note: Dim must be a scalar in the range 1  £  Dim  £  n where n is the rank of Mask. 
The result is scalar if Dim is absent or Mask has rank 1. Otherwise it works on the 
dimension Dim of Mask and the result is an array of rank n−1. 
 Example: T=ALL(M) 
 ALLOCATED(Array) 
 Returns true if array is allocated. 
 Argument: Array 
 Type: Any 
 Result: L 
 Class: I 
 Note: Array must be declared with the allocatable attribute. 
 Example: if (ALLOCATED(Array) ) then … 
 ANINT(A, Kind ) 
 Rounds reals, i.e., returns nearest whole number. 
 Argument: A 
 Type: R 
 Result: As A 
 Class: E 
 Example: Z=ANINT(A), if A = 5.63 Z = 6, if A = −5.7 Z = −6.0 
 ANY(Mask, Dim ) 
 Determines whether any value is true in Mask along dimension Dim. 
 Argument: Mask 
 Type: L 
 Result: L 
 Class: T 
 Note: Mask must be an array. The result is a scalar if Dim is absent or if Mask is 
of rank 1. Otherwise it works on the dimension Dim of Mask and the result is an 
array of rank n−1. 
 Example: T=ANY(A) 
 ASIN(X) 
 Arcsine. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Z=ASIN(X) 
 ASINH(X) 

553
Appendix C
 Inverse hyperbolic sine function. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Y=ASINH(X) 
 ASSOCIATED(pointer,  target ) 
 Returns the association status of the pointer. 
 Argument: pointer 
 Type: P 
 Result: L 
 Class: I 
 Note: 
 1.  if target is absent then the result is true if pointer is associated with a target, oth-
erwise false. 
 2.  if target is present and is a target, the result is true if pointer is currently associ-
ated with target and false if it is not. 
 3.  if target is present and is a pointer, the result is true if both pointer and target are 
currently associated with the same target, and is false otherwise. if either pointer 
or target is disassociated the result is false. 
 Example: T=ASSOCIATED(P) 
 ATAN(X) 
 Arctangent. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Z=ATAN(X) 
 ATAN2(Y,X) 
 Arctangent of Y/X. 
 Arguments: Y 
 Type: R 
 Result: As arguments 
 Class: E 
 Example: Z=ATAN2(Y,X) 
 ATANH(X) 
 Inverse hyperbolic tangent function. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Y = ATANH(X) 
 ATOMIC_DEFINE (ATOM, VALUE) 
 Deﬁ ne a variable atomically. 

554
Appendix C
 Arguments: ATOM 
 Type: Co 
 VALUE 
 scalar and same type as ATOM 
 Result: N/A 
 Class: A 
 Note: 
 1.  ATOM shall be a scalar coarray or coindexed object and of type integer with kind 
ATOMIC_INT_KIND or of type logical with kind ATOMIC_LOGICAL_KIND, 
where ATOMIC_INT_KIND and ATOMIC_LOGICAL_KIND are the named 
constants in the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (OUT) 
argument. If its kind is the same as that of VALUE or its type is logical, it becomes 
deﬁ ned with the value of VALUE. Otherwise, it becomes deﬁ ned with the value 
of INT (VALUE, ATOMIC_INT_KIND). 
 2.  VALUE shall be scalar and of the same type as ATOM. It is an INTENT (IN) 
argument. 
 Example: CALL ATOMIC_DEFINE (I[2], 4) causes I on image 2 to become 
deﬁ ned with the value 4. 
 ATOMIC_REF (VALUE, ATOM) 
 Reference a variable atomically. 
 Arguments: VALUE 
 Type: scalar and same type as ATOM 
 ATOM 
 Co 
 Result: N/A 
 Class: A 
 Note: 
 1.  VALUE shall be scalar and of the same type as ATOM. It is an INTENT (OUT) 
argument. If its kind is the same as that of ATOM or its type is logical, it becomes 
deﬁ ned with the value of ATOM. Otherwise, it is deﬁ ned with the value of INT 
(ATOM, KIND (VALUE)). 
 2.  ATOM shall be a scalar coarray or coindexed object and of type integer with kind 
ATOMIC_INT_KIND or of type logical with kind ATOMIC_LOGICAL_KIND, 
where ATOMIC_INT_KIND and ATOMIC_LOGICAL_KIND are the named 
constants in the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (IN) 
argument. 
 BESSEL_J0(X) 
 Bessel function of the 1st kind, order 0. 
 Argument: X 
 Type: R 
 Result: As argument 
 Class: E 
 Example: Y = BESSEL_J0(1.0) has the value 0.765 (approximately) 
 BESSEL_J1(X) 
 Bessel function of the 1st kind, order 1. 

555
Appendix C
 Argument: X 
 Type: R 
 Result: As argument 
 Class: E 
 Example: Y = BESSEL_J1(1.0) has the value 0.440 (approximately). 
 BESSEL_JN (N, X) 
 Bessel functions of the 1st kind. 
 Arguments: N, X 
 Type: N is I, X is R 
 Result: as X 
 Class: E 
 Example: Y = BESSEL_JN (2, 1.0) has the value 0.115 (approximately). 
 BESSEL_JN (N1, N2, X) Bessel functions of the 1st kind. 
 Arguments: N1, N2, X 
 Type: N1, N2 are I, X is R 
 Result: is a real rank-one array with extent MAX(N2-N1+1, 0). 
Element I of the result value is a processor-dependent approxima-
tion to the Bessel function of the 1st kind and order N1+I−1 of X. 
              Class: T 
 BESSEL_Y0(X) 
 Bessel function of the 2nd kind, order 0. 
 Argument: X 
 Type: R 
 Result: As argument 
 Class: E 
 Example: Y = BESSEL_Y0(1.0) has the value 0.088 (approximately). 
 BESSEL_Y1(X) 
 Bessel function of the 2nd kind, order 1. 
 Argument: X 
 Type: R 
 Result: As argument 
 Class: E 
 Example: Y = BESSEL_Y 1(1.0) has the value −0.781 (approximately). 
 BESSEL_YN (N, X) 
 Bessel functions of the 2nd kind. 
 Arguments: N, X 
 Type: N is I, X is R 
 Result: Is same type and kind as X. 
 Class: E 
 Example: Y = BESSEL_YN (2, 1.0) has the value −1.651 (approximately). 
 BESSEL_YN (N1, N2, X) 
 Bessel functions of the 2nd kind. 

556
Appendix C
 Arguments: N1, N2, X 
 Type: N1, N2 are I, X is R 
 Result: is a real rank-one array with extent MAX(N2-N1+1, 0). Element I of the result value 
is a processor-dependent approximation to the Bessel function of the 2nd kind and order 
N1+I−1 of X. 
             Class: T 
 BGE(I, J) 
 Bitwise greater than or equal to. 
 Arguments: I,J 
 Type: I or Boz 
 Result: L 
 Class: E 
 The result is true if the sequence of bits represented by I is greater than or equal 
to the sequence of bits represented by J, according to the method of bit sequence 
comparison in 13.3.2 of Fortran 2008 standard; otherwise the result is false. 
 Example: If BIT SIZE (J) has the value 8, BGE (Z'FF', J) has the value true for 
any value of J. BGE (0,−1) has the value false. 
 BGT (I, J) 
 Bitwise greater than. 
 Arguments: I,J 
 Type: I or Boz 
 Result: L 
 Class: E 
 The result is true if the sequence of bits represented by I is greater than the 
sequence of bits represented by J, according to the method of bit sequence compari-
son in 13.3.2 of Fortran 2008 standard; otherwise the result is false. 
 Example: BGT (Z'FF', Z'FC') has the value true. BGT (0, -1) has the value 
false. 
 BLE (I, J) 
 Bitwise less than or equal to. 
 Arguments: I,J 
 Type: I or Boz 
 Result: L 
 Class: E 
 The result is true if the sequence of bits represented by I is less than or equal to 
the sequence of bits represented by J, according to the method of bit sequence com-
parison in 13.3.2 of Fortran 2008 standard; otherwise the result is false. 
 Example. BLE (0, J) has the value true for any value of J. BLE (−1, 0) has the 
value false. 
 BLT (I, J) 
 Bitwise less than. 
 Arguments: I,J 
 Type: I or Boz 
 Result: L 
 Class: E 

557
Appendix C
 The result is true if the sequence of bits represented by I is less than the sequence 
of bits represented by J, according to the method of bit sequence comparison in 
13.3.2 of Fortran 2008 standard; otherwise the result is false. 
 Example: Example. BLT (0,−1) has the value true. BLT (Z'FF', Z'FC') has the 
value false. 
 BIT_SIZE(I) 
 Returns the number of bits, as deﬁ ned by the numeric model for integer numbers 
in Chap.  5 . 
 Argument: I 
 Type: I 
 Result: As argument 
 Class: I 
 Example: N_Bits=SIZE(I) 
 BTEST(I,Pos) 
 Returns true if the bit is set in the integer argument at the position given by the 
second argument. 
 Argument: I 
 Type: I 
 Result: L 
 Class: E 
 Example: T=BTEST(I,Pos) 
 CEILING(A, Kind ) 
 Returns the smallest integer greater than or equal to the argument. 
 Argument: A 
 Type: R 
 Result: I 
 Class: E 
 Note: 
 if kind is present the result has the kind type parameter Kind. 
 Otherwise the result is of type default integer. 
 Example: I=CEILING(A) if A=12.21 then I=13, if A=−3.16 then I=−3 
 CHAR(I, Kind ) 
 Returns the character in a given position in the processor collating sequence 
associated with the speciﬁ ed kind type parameter. Normally ASCII. 
 Argument: I 
 Type: I 
 Result: CHAR 
 Class: E 
 Example: C=CHAR(65) and for the ASCII character set C='A'. 
 CMPLX(X,Y, Kind ) 
 Converts to complex from integer, real and complex. 
 Argument: X 
 Type: N 
 Result: C 
 Class: E 

558
Appendix C
 Note: 
 1.  if X is complex and Y is absent it is as if Y were present with the value 
AIMAG(X). 
 2.  if X is not complex and Y is absent, it is as if Y were present with the value 0. 
 Example: Z=CMPLX(X,Y) 
 COMMAND_ARGUMENT_COUNT ( ) 
 Number of command arguments. 
 Arguments 
 None 
 Result: I 
 Class: T 
 The result value is equal to the number of command arguments available. If there 
are no command arguments available or if the processor does not support command 
arguments, then the result has the value zero. If the processor has a concept of a 
command name, the command name does not count as one of the command 
arguments. 
 Example: I = COMMAND_ARGUMENT_COUNT ( ) 
 CONJG(Z) 
 Conjugate of a complex argument. 
 Argument: Z 
 Type: C 
 Result: As Z 
 Class: E 
 Example: Z1=CONJG(Z) 
 COS(X) 
 Cosine. 
 Argument: X 
 Type: R, C 
 Result: As argument 
 Class: E 
 Note: The arguments of all trigonometric functions should be in radians, not 
degrees. 
 Example: A=COS(X) 
 COSH(X) 
 Hyperbolic cosine. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Z=COSH(X) 
 COUNT(Mask, Dim ) 
 Returns the number of true elements in Mask along dimension Dim. 
 Argument: Mask 
 Type: L 
 Result: I 
 Class: T 

559
Appendix C
 Note: Dim must be a scalar in the range 1  £  Dim  £ n , where n is the rank of Mask. 
The result is scalar if Dim is absent or Mask has rank 1. Otherwise it works on the 
dimension Dim of Mask and the result is an array of rank n−1. 
 Example: N=COUNT(A) 
 CPU_TIME(Time) 
 Returns the processor time. 
 Argument: Time 
 Type: R 
 Result: N/A 
 Class: S 
 Example: call CPU_TIME(Time) 
 CSHIFT(Array,Shift, Dim ) 
 Circular shift on a rank 1 array or rank 1 sections of higher-rank arrays. 
 Argument: Array 
 Type: Any 
 Result: As Array 
 Class: T 
 Note: Array must be an array, Shift must be a scalar if Array has rank 1, other-
wise it is an array of rank n−1, where n is the rank of Array. Dim must be a scalar 
with a value in the range 1  £  Dim  £ n . 
 Example: Array=CSHIFT(Array,10) 
 DATE_AND_TIME( Date,Time,Zone,Values ) 
 Returns the current date and time (compatible with ISO 8601:1988). 
 Argument: Date 
 Type: S 
 Result: N/A 
 Class: S 
 Time and Zone are of type S. 
 Note: 
 1.  Date is optional and must be scalar and 8 characters long in order to return the 
complete value of the form CCYYMMDD, where CC is the century, YY is the 
year, MM is the month and DD is the day. It is intent(out). 
 2.  Time is optional and must be scalar and 10 characters long in order to return the 
complete value of the form hhmmss.sss where hh is the hour, mm is the minutes 
and ss.sss is the seconds and milliseconds. It is intent(out). 
 3.  Zone is optional and must be scalar and must be 5 characters long in order to 
return the complete value of the form hhmm where hh and mm are the time dif-
ferences with respect to Coordinated Universal Time in hours and minutes. It is 
intent(out). 
 4.  Values is optional and a rank 1 array of size 8. It is intent(out). The values re 
turned are as follows:
 Values(1) = the year 
 Values(2) = the month 
 Values(3) = the day 

560
Appendix C
 Values(4) = the time with respect to Coordinated Universal Time in minutes. 
 Values(5) = the hour (24 hour clock) 
 Values(6) = the minutes 
 Values(7) = the seconds 
 Values(8) = the milliseconds in the range 0–999. 
 Example: call DATE_TIME(D,T,Z,V) 
 DBLE(A) 
 Converts to double precision from integer, real, and complex 
 Argument: A 
 Type: N 
 Result: DP 
 Class: E 
 Example: D=DBLE(A) 
 DIGITS(X) 
 Returns the number of signiﬁ cant digits of the argument as deﬁ ned in the numeric 
models for integer and reals in Chap.  5 . 
 Argument: X 
 Type: I,R 
 Result: I 
 Class: I 
 Example: I=DIGITS(X) 
 DIM(X,Y) 
 Returns ﬁ rst argument minus minimum of the two arguments: X -MIN(X,Y). 
 Argument: X 
 Type: I 
 Result: As arguments 
 Class: E 
 Example: Z=DIM(X,Y) 
 DOT_PRODUCT(Vector_1,Vector_2) 
 Performs the mathematical dot product of two rank 1 arrays. 
 Argument: Vector_1 
 Type: N 
 Result: As arguments 
 Class: T 
 Vector_2 is as Vector_1. 
 Note: 
 1.  if Vector_1 is of type integer or real the result has the value 
 SUM(Vector_1*Vector_2). 
 2.  if Vector_1 is complex the result has the value 
 SUM(CONJG(Vector_1)*Vector_2). 
 3.  if Vector_1 is logical the result has the value ANY(Vector_1 .AND. Vector_2). 

561
Appendix C
 Example: A=DOT_PRODUCT(X,Y) 
 DPROD(X,Y) 
 double precision product of two reals. 
 Argument: X 
 Type: R 
 Result: DP 
 Class: E 
 Example: D=DPROD(X,Y) 
 DSHIFTL (I, J, SHIFT) 
 Combined left shift. 
 Arguments: I,J 
 Type: I or Boz 
   SHIFT 
 Type: I 
 Result: Same as I if I is of type integer; otherwise, same as J. If either I or J is a boz-literal-
constant, it is ﬁ rst converted as if by the intrinsic function INT to type integer with the 
kind type parameter of the other. The rightmost SHIFT bits of the result value are the 
same as the leftmost bits of J, and the remaining bits of the result value are the same as 
the rightmost bits of I. This is equal to IOR (SHIFTL (I, SHIFT), SHIFTR (J, BIT SIZE 
(J)-SHIFT)). The model for the interpretation of an integer value as a sequence of bits is 
in section 13.3 of Fortran 2008 standard. 
             Class: E 
 Examples: DSHIFTL (1, 2**30, 2) has the value 5 if default integer has 32 bits. 
 DSHIFTL (I, I, SHIFT) has the same result value as ISHFTC (I, SHIFT). 
 DSHIFTR (I, J, SHIFT) 
 Combined right shift. 
 Arguments: I,J 
 Type: I or Boz 
 SHIFT 
 Type: I 
 Result: Same as I if I is of type integer; otherwise, same as J. If either I or J is a boz-literal-
constant, it is ﬁ rst converted as if by the intrinsic function INT to type integer with the 
kind type parameter of the other. The leftmost SHIFT bits of the result value are the 
same as the rightmost bits of I, and the remaining bits of the result value are the same 
as the leftmost bits of J. This is equal to IOR (SHIFTL (I, BIT SIZE (I)-SHIFT), 
SHIFTR (J, SHIFT)). The model for the interpretation of an integer value as a sequence 
of bits is in 13.3 of Fortran 2008 standard. 
             Class: E 
 Examples. DSHIFTR (1, 16, 3) has the value 229 +2 if default integer has 32 
bits. 
 DSHIFTR (I, I, SHIFT) has the same result value as ISHFTC (I,-SHIFT). 
 EOSHIFT(Array, Shift,  Boundary, Dim ) 
 End of shift of a rank 1 array or rank 1 section of a higher-rank array. 
 Argument: Array 
 Type: Any 
 Result: As Array 
 Class: T 

562
Appendix C
 Boundary is as Array. 
 Note: Array must be an array, Shift must be a scalar if Array has rank 1, other-
wise it is an array of rank n−1, where n is the rank of Array. Boundary must be 
scalar if Array has rank 1, otherwise it must be either scalar or of rank −1. Dim must 
be a scalar with a value in the range 1  £  Dim  £ n . 
 Example: A=EOSHIFT(A,Shift) 
 EPSILON(X) 
 Smallest difference between two reals of that kind. See Chap.  5 and real numeric 
model. 
 Argument: X 
 Type: R 
 Result: As argument 
 Class: I 
 Example: Tiny=EPSILON(X) 
 ERF (X) 
 Error function. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: Y = ERF(1.0) has the value 0.843 (approximately). 
 ERFC (X) 
 Complementary error function. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: Y = ERFC (1.0) has the value 0.157 (approximately). 
 ERFC_SCALED (X) 
 Scaled complementary error function. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: Y = ERFC_SCALED (20.0) has the value 0.0282 (approximately). 
 EXECUTE_COMMAND_LINE(COMMAND, WAIT,EXITSTAT,CMDSTAT.
CMDMSG ) 
 Execute a command line.
 Argument: COMMAND – shall be a default character scalar. It is an INTENT 
(IN) argument. Its value is the command line to be executed. The interpretation 
is processor dependent. 
 Argument: WAIT – (optional) shall be a default logical scalar. It is an INTENT 
(IN) argument. If WAIT is present with the value false, and the processor sup-
ports asynchronous execution of the command, the command is executed 
 asynchronously; otherwise it is executed synchronously. 

563
Appendix C
 Argument: EXITSTAT – (optional) shall be a default integer scalar. It is an 
INTENT (INOUT) argument. If the command is executed synchronously, it is 
assigned the value of the processor-dependent exit status. Otherwise, the value of 
EXITSTAT is unchanged. 
 Argument: CMDSTAT – (optional) shall be a default integer scalar. It is an 
INTENT (OUT) argument. It is assigned the value −1 if the processor does not 
support command line execution, a processor-dependent positive value if an 
error condition occurs, or the value −2 if no error condition occurs but WAIT is 
present with the value false and the processor does not support asynchronous 
execution. Otherwise it is assigned the value 0. 
 Argument: CMDMSG – (optional) shall be a default character scalar. It is an 
INTENT (INOUT) argument. If an error condition occurs, it is assigned a 
 processor-dependent explanatory message. Otherwise, it is unchanged.
        Class: S 
 Example: CALL EXECUTE_COMMAND_LINE('pwd') will print the full 
pathname of the current directory under Unix and an error message from 
Windows. 
 EXP(X) 
 Exponential, e x . 
 Argument: X 
 Type: R, C 
 Result: As argument 
 Class: E 
 Example: Y=EXP(X) 
 EXPONENT(X) 
 Returns the exponent component of the argument. See Chap.  5 and the real 
numeric model. 
 Argument: X 
 Type: R 
 Result: I 
 Class: E 
 Example: I=EXPONENT(X) 
 EXTENDS_TYPE_OF (A, MOLD) 
 Query dynamic type for extension. 
 Arguments: A, Mold 
 Type: P* 
 Result: L 
 Class: I 
 If MOLD is unlimited polymorphic and is either a disassociated pointer or unal-
located allocatable variable, the result is true; otherwise if A is unlimited polymor-
phic and is either a disassociated pointer or unallocated allocatable variable, the 
result is false; otherwise if the dynamic type of A or MOLD is extensible, the result 
is true if and only if the dynamic type of A is an extension type of the dynamic type 
of MOLD; otherwise the result is processor dependent. 

564
Appendix C
 Example:
 if (extends_type_of(a, mold) then 
 print*,'dynamic type of a is an extension of dynamic type of mold' 
 endif 
 FINDLOC (ARRAY, VALUE,  DIM, MASK, KIND, BACK ) 
 FINDLOC (ARRAY, VALUE,  MASK, KIND, BACK ) 
 Location(s) of a speciﬁ ed value. 
 Argument: ARRAY 
 Type: shall be an array of intrinsic type 
 Argument: VALUE 
 Type: shall be scalar and in type conformance with ARRAY, as 
speciﬁ ed in Table 7.2 for relational intrinsic operations 
7.1.5.5.2). 
 Argument: DIM 
 Type: shall be an integer scalar with a value in the range 1 DIM 
 n , where  n is the rank of ARRAY. The corresponding actual 
argument shall not be an optional dummy argument. 
 Argument: MASK 
 Type: (optional) shall be of type logical and shall be conform-
able with ARRAY. 
 Argument: KIND 
 Type: (optional) shall be a scalar integer constant expression. 
 Argument: BACK 
 Type:(optional) shall be a logical scalar. 
              Class: T 
 FLOOR(A,  Kind ). 
 Returns the greatest integer less than or equal to the argument 
 Argument: A 
 Type: R 
 Result: I 
 Class: E 
 Note: 
 If kind is present the result has the kind type parameter Kind, otherwise the result 
is of type default integer. 
 Example: I=FLOOR(A) and when A=5.2 I has the value 5, when A=−9.7 I has 
the value −10 
 FRACTION(X) 
 Returns the fractional part of the real numeric model of the argument See Chap.  5 
and the real numeric model. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: F=FRACTION(X) 
 GAMMA (X) 
 Gamma function. 

565
Appendix C
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: Y = GAMMA(1.0) has the value 1.000 (approximately). 
 GET_COMMAND ( COMMAND, LENGTH, STATUS ) 
 Query program invocation command. 
 GET_COMMAND_ARGUMENT (NUMBER,  VALUE, LENGTH, STATUS ) 
 Query arguments from program invocation. 
 GET_ENVIRONMENT_VARIABLE (NAME,  VALUE, LENGTH, STATUS, 
TRIM_NAME ) 
 Query environment variable. 
 HUGE(X) 
 Returns the largest number for the kind type of the argument. See Chap.  5 and 
the real and integer numeric models. 
 Argument: X 
 Type: I,R 
 Result: As argument 
 Class: I 
 Example: H=HUGE(X) 
 HYPOT (X, Y) 
 Euclidean distance function. 
 Arguments: X,Y 
 Type: R 
 Result: R 
 Class: E 
 Example: H = HYPOT(3.0, 4.0) has the value 5.0 (approximately). 
 IACHAR(C) 
 Returns the position of the character argument in the ASCII collating sequence. 
 Argument: C 
 Type: Char 
 Result: I 
 Class: E 
 Example: I=IACHAR('A') returns the value 65. 
 IALL (ARRAY,  DIM, MASK ) or IALL (ARRAY,  MASK ) 
 Reduce array with bitwise AND operation. 
 IAND(I,J) 
 Performs a logical AND on the arguments. 
 Argument: I 
 Type: I 
 Result: As arguments 
 Class: E 
 Example: K=IAND(I,J) 
 IANY (ARRAY,  DIM, MASK ) or IANY (ARRAY,  MASK ) 
 Reduce array with bitwise OR operation. 

566
Appendix C
 IBCLR(I,Pos) 
 Clears one bit of the argument to zero. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Note: 0  £  Pos < BIT_SIZE ( I ) 
 Example: I=IBCLR(I,Pos) 
 IBITS(I,Pos,Len) 
 Returns a sequence of bits. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Note: 0  £  Pos and ( Pos + Len )  £  BIT_SIZE ( I ) and  Len  ³ 0. 
 Example: Slice=IBITS(I,Pos,Len) 
 IBSET(I,Pos) 
 Sets one bit of the argument to one. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Note: 0  £  Pos < BIT_SIZE ( I ). 
 Example: I=IBSET(I,Pos) 
 ICHAR(C) 
 Returns the position of a character in the processor collating sequence associated 
with the kind type parameter of the argument. Normally the position in the ASCII 
collating sequence. 
 Argument: C 
 Type: CHAR 
 Result: I 
 Class: E 
 Example: I=ICHAR('A') would return the value 65 for the ASCII character set. 
 IEOR(I,J) 
 Performs an exclusive OR on the arguments. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Example: I=IEOR(I,J) 
 IMAGE_INDEX (COARRAY, SUB) 
 Convert cosubscripts to image index. 
 Argument: COARRAY 
 Type: Co 
 Argument: SUB 
 Rank-one integer array 
 Result: I 
 Class: I 

567
Appendix C
 Example:
 integer, codimension[0:*]:: x 
 integer, dimension(10,15), codimension[3,0:1,−1:*]:: z
 print*, image_index(x,(/0/)); print*, image_index(z,(/2,0,−1/)) 
 would print 1 and 2 respectively. 
 INDEX(String,Substring, Back ) 
 Locates one substring in another, i.e., returns position of Substring in character 
expression String. 
 Argument: String 
 Type: S 
 Result: I 
 Class: E 
 Substring is of type S. 
 Note: 
 1.  if Back is absent or present with the value .FALSE. then the function returns the 
start position of the ﬁ rst occurrence of the substring. if LEN(Substring) = 0 then 
one is returned. 
 2.  if Back is present with the value .TRUE. then the function returns the start posi-
tion of the last occurrence of the substring. if LEN(Substring) = 0 then the value 
(LEN(String) + 1) is returned. 
 3.  if the substring is not found the result is zero. 
 4.  if LEN(String) < LEN(Substring) the result is zero. 
 Example: 
 where=INDEX('Hello world Hello','Hello') 
 The result 2 is returned. 
 where=INDEX('Hello world Hello','Hello',.TRUE.) 
 The result 14 is returned. 
 INT(A, Kind ) 
 Converts to integer from integer, real, and complex. 
 Argument: A 
 Type: N 
 Result: I 
 Class: E 
 Example: I=INT(F) 
 IOR(I,J) 
 Performs an inclusive OR on the arguments. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Example: I=IOR(I,J) 
 IPARITY (ARRAY, DIM,  MASK ) or IPARITY (ARRAY,  MASK ) 
 Reduce array with bitwise exclusive OR operation. 

568
Appendix C
 ISHFT(I, Shift) 
 Performs a logical shift. The bits of I are shifted by Shift positions. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Note: |  Shift |  £ BIT_SIZE ( I ) 
 Example: I=ISHIFT(I,Shift). 
 ISHFTC(I,Shift, Size ) 
 Performs a circular shift of the rightmost bits. The Size rightmost bits of I are 
circularly shifted by Shift positions. 
 Argument: I 
 type: I 
 Result: I 
 Class: E 
 Note: 
 |  Shift | <  Size 
 0  £  Size  £ BIT_SIZE ( I ). 
 if Size is absent it is as if it were present with the value of  BIT_SIZE ( I ). 
 if Shift is positive the shift is to the left. 
 if Shift is negative the shift is to the right. 
 if Shift is zero no shift is performed. 
 Example: I=ISHFTC(I,Shift,Size) 
 IS_CONTIGUOUS (ARRAY) 
 Test contiguity of an array. 
 Argument: ARRAY 
 Type: any 
 Result: L 
 Class: I 
 Example: 
 integer,target, dimension(10)::a 
 integer,pointer,dimension(:) :: p 
  p=> a(1:10:2); print*,is_contiguous(p) 
 would print 'F' 
 IS_IOSTAT_END (I) 
 Test IOSTAT value for end-of-ﬁ le. 
 Argument: I 
 Type: I 
 Result: L 
 Class: E 
 Example: 
 IS_IOSTAT_END(I) returns value true if I is an I/O status value that corresponds 
to an end-of-ﬁ le condition, and false otherwise.

569
Appendix C
 read(unit= 1, fmt=*, iostat=ist)y(I) 
 … 
 if(is_iostat_end(ist)) then
    print*,'end of ﬁ le!' 
 endif 
 IS_IOSTAT_EOR (I) 
 Test IOSTAT value for end-of-record.  
 Argument: I 
 Type: I 
 Result: L 
 Class: E 
 Example: IS_IOSTAT_EOR(I) returns value true if I is an I/O status value that 
corresponds to an end-of-record condition, and false otherwise. 
 KIND(X) 
 Returns the KIND type parameter of the argument. 
 Argument: X 
 Type: Any 
 Result: I 
 Class: I 
 Example: I=KIND(X) 
 LBOUND(Array, Dim ) 
 Returns the lower bounds for each dimension of the array argument or a speciﬁ ed 
lower bound. 
 Argument: Array 
 Type: Any 
 Result: I 
 Class: I 
 Note: 
 1  £  Dim  £ n , where n is the rank of Array. The result is scalar if Dim is present 
otherwise the result is an array of rank 1 and size n. 
 The result is scalar if Dim is present, otherwise a rank 1 array and size n. 
 Example: I=LBOUND(Array) 
 LCOBOUND (COARRAY,  DIM, KIND ) 
 Lower cobound(s) of a coarray. 
 Argument: COARRAY 
 Type: co 
 Argument: DIM (optional) 
 Type: I 
 Argument: KIND (optional) 
 Type: I 
 Result: I 
 Class: I 
 Example:
 INTEGER, CODIMENSION[:,:], ALLOCATABLE::A
 ALLOCATE(A[2:3,7:*]) 
 LCBOUND (A) is [2,7] and LCOBOUND(A,DIM=2) is 7 
 LEADZ (I) 

570
Appendix C
 Number of leading zero bits. 
 Argument: I 
 Type: I 
 Result: I 
 Class: E 
 Example: LEADZ (1) has the value 31 if BIT SIZE (1) has the value 32. 
 LEN(String) 
 Length of a character entity. 
 Argument: String 
 Type: S 
 Result: I 
 Class: I 
 Example: I=LEN(String) 
 LEN_TRIM(String) 
 Length of character argument less the number of trailing blanks. 
 Argument: String 
 Type: S 
 Result: I 
 Class: E 
 Example: I=LEN_TRIM(String) 
 LGE(String_1,String_2) 
 Lexically greater than or equal to and this is based on the ASCII collating 
sequence. 
 Argument: String_1 
 Type: S 
 Result: L 
 Class: E 
 String_2 is of type S. 
 Example: L=LGE(S1,S2) 
 LGT(String_1 ,String_2) 
 Lexically greater than and this is based on the ASCII collating sequence. 
 Argument: String_1 
 Type: S 
 Result: L 
 Class: E 
 Example: L=LGT(S1,S2) 
 LLE(String_1, String_2) 
 Lexically less than or equal to and this is based on the ASCII collating 
sequence. 
 Argument: String_1 
 Type: S 
 Result: L 
 Class: E 
 String_2 is of type S. 
 Example: L=LLE(S1,S2) 
 LLT(String_ 1, String_2) 

571
Appendix C
 Lexically less than and this is based on the ASCII collating sequence. 
 Argument: String_1 
 Type: S 
 Result: L 
 Class: E 
 Example: L=LLT(S1,S2) 
 LOG(X) 
 Natural logarithm, loge x. 
 Argument: X 
 Type: R, C 
 Result: As argument 
 Class: E 
 Example: Y=LOG(X) 
 LOG_GAMMA (X) 
 Logarithm of the absolute value of the gamma function.  
 Argument: X 
 Type: R 
 Result: R 
 Class: E 
 Example: LOG_GAMMA (3.0) has the value 0.693 (approximately) 
 LOG10(X) 
 common logarithm, log 10. 
 Argument: X 
 Type: R 
 Result: As argument 
 Class: E 
 Example: Y=LOG10(X) 
 LOGICAL(L,Kind) 
 Converts between different logical kind types, i.e., performs a type cast. 
 Argument: L 
 Type: L 
 Result: L 
 Class: E 
 Example: L=LOGICAL(K, Kind ) 
 MASKL (I,  KIND ) 
 Left justiﬁ ed mask. 
 Argument: I 
 Type: I 
 Result: I 
 Class: E 
 Example: MASKL (4) has the value SHIFTL (15, BIT_SIZE (0) - 4) 
 MASKR (I,  KIND ) 
 Right justiﬁ ed mask. 

572
Appendix C
 Argument: I 
 Type: I 
 Result: I 
 Class: E 
 Example: MASKR(4) has the value 15. 
 MATMUL(Matrix_1 ,Matrix_2) 
 Performs mathematical matrix multiplication of the array arguments.  
 Argument: Matrix_1 
 Type: N,L 
 Result: As arguments 
 Class: T 
 Matrix_2 is as Matrix_1. 
 Note: 
 1.  Matrix_1 and Matrix_2 must be arrays of rank 1 or 2. if Matrix_1 is of numeric 
type so must Matrix_2. 
 2.  if Matrix_1 has rank 1, Matrix_2 must have rank 2. 
 3.  if Matrix_2 has rank 1, Matrix_1 must have rank 2. 
 4.  The size of the ﬁ rst dimension of Matrix_2 must equal the size of the last dimen-
sion of Matrix_1. 
    5.  if Matrix_1 has shape (n,m) and Matrix_2 has shape (m,k) the result has shape 
(n,k). 
 6.    if Matrix_1 has shape (m) and Matrix_2 has shape (m,k) the result has shape (k). 
7. if Matrix_1 has shape (n,m) and Matrix_2 has shape (m) the result has shape (n).      
 Example: R=MATMUL(M_1,M_2) 
 MAX(A1,A2,A3,…) 
 Returns the largest value. 
 Argument: A1 
 Type: I,R,S 
 Result: As arguments 
 Class: E 
 A2, A3,.. are as A1. 
 Example: A=MAX(A1,A2,A3,A4) 
 MAXEPONENT(X) 
 Returns the maximum exponent. See Chap.  5 and numeric models. 
 Argument: X 
 Type: R 
 Result: I 
 Class: I 
 Example: I=MAXEXPONENT(X) 
 MAXLOC(ARRAY, Dim, Mask, Kind, Back ) 
 Determine the location of the ﬁ rst element of Array having the maximum value 
of the elements identiﬁ ed by Mask if present. 
 Argument: Array 
 Type: I,R 
 Result: I 
 Class: T 

573
Appendix C
 Note: 
 0.  Normally in Fortran if you omit an optional argument you must use keywords for 
the rest. This intrinsic breaks this rule and DIM can be omitted and it is not nec-
essary to use a keyword with Mask. 
 1.  Array must be an array. 
 2.  Mask must be conformable with Array 
 3.  The result is an array of rank 1 and of size equal to the rank of Array. 
 4.  if Dim is present the result is an array of the rank of Array reduced by one and 
with the shape of Array without the dimension Dim. 
 Example: 
 A=(/5,6,7,8/) 
 I=MAXLOC(A) 
 is (4), which is the subscript of the location of the ﬁ rst occurrence of the  maximum 
value in the rank 1 array. 
 if  
⎛
⎞
⎜
⎟
= ⎜
⎟
⎜
⎟
⎝
⎠
1
8
5
9
3
6
4
2
7
A
 
 I = MAXLOC(A,dim=1) 
 is (2,1,3) returning the position of the largest in each column. 
 I = MAXLOC(A,dim=2) 
 is (2,1,3) returning the position of the largest in each row. 
 MAXVAL(Array, Dim,Mask ) 
 Returns the maximum value of the elements of Array along dimension Dim 
 corresponding to the true elements of Mask. 
 Argument: Array 
 Type: I,R,S 
 Result: As argument 
 Class: T 
 Note: 
 1  £  Dim  £ n , where n is the rank of Array. The result is scalar if Dim is absent, or 
Array has rank 1. Otherwise the result is an array of rank −1. 
 if Array has size zero then the result is the largest negative number supported by 
the processor for the corresponding type and kind of Array. 
 Example: 
 MAXVAL((/1,2,3/)) returns the value 3. 
 MAXVAL(C,MASK=C < 0.0) returns the maximum of the negative elements of C. 
 For  
⎛
⎞
= ⎜
⎟
⎝
⎠
1
3
5
2
4
6
B
 

574
Appendix C
 MAXVAL(B,DIM=1) returns (2,4,6) 
 MAXVAL(B,DIM=2) returns (5,6) 
 MERGE(True,False,Mask) 
 Chooses alternative values according to the value of a mask. 
 Argument: True 
 Type: Any 
 Result: As True 
 Class: E 
 Example: for 
 For  
⎛
⎞
= ⎜
⎟
⎝
⎠
2
6
10
4
8
12
True
 ,  
⎛
⎞
= ⎜
⎟
⎝
⎠
1
5
9
3
7
11
False
 and  
⎛
⎞
= ⎜
⎟
⎝
⎠
T
F
T
Mask
F
T
F  
 The result is  ⎛
⎞
⎜
⎟
⎝
⎠
2
5
10
3
8
11  
 MERGE_BITS (I, J, MASK) 
 Merge of bits under mask. 
 Argument: I 
 Type: I or Boz 
 Argument: J 
 I or Boz 
 Argument: MASK 
 I or Boz 
 Result: same as I if Integer, otherwise same as J. 
                     Class: E 
 Example: MERGE_BITS(14,18,22) has the value 6. 
 MIN(A1,A2,A3,…) 
 Chooses the smallest value. 
 Argument: A1 
 Type: I,R,S 
 Result: As arguments 
 Class: E 
 ww
 Example: Y=MIN(X1, X 2,X3,X4,X5) 
 MINEXPONENT(X) 
 Returns the minimum exponent. See Chap.  5 and numeric models. 
 Argument: X 
 Type: R 
 Result: I 
 Class: I 
 Example: I=MINEXPONENT(X) 
 MINLOC(Array, Dim, Mask, Kind, Back ) 
 Determine the location of the ﬁ rst element of Array having the minimum value 
of the elements identiﬁ ed by Mask. 
 Argument: Array 
 Type: I,R 
 Result: I 
 Class: T 

575
Appendix C
 Note: 
 0.  Normally in Fortran if you omit an optional argument you must use keywords for 
the rest. This intrinsic breaks this rule and Dim can be omitted and it is not neces-
sary to use a keyword with Mask. 
 1.  Array must be an array. 
 2.  Mask much be conformable with Array. 
 3.  The result is an array of rank 1 and of size equal to the rank of Array. 
 4.  if DIM is present the result is an array of the rank of Array reduced by one and 
with the shape of Array without the dimension DIM. 
 Example: I=MINLOC(Array) 
 In the above example if Array is a rank 2 array of shape (5,10) and the smallest 
value is in position (2,1) then the result is the rank 1 array I with shape (2) and 
I(1)=2 and I(2)=1. 
 See MAXLOC for further examples. 
 MINVAL(Array, Dim,Mask ) 
 Returns the minimum value of the elements of Array along dimension Dim cor-
responding to the true elements of Mask. 
 Argument: Array 
 Type: I,R,S 
 Result: As Array 
 Class: T 
 Note:l  £  Dim  £ n , where n is the rank of Array. The result is scalar if Dim is 
absent, or Array has rank 1. Otherwise the result is an array of rank n–1. 
 if Array has size zero then the result is the largest negative number supported by 
the processor for the corresponding type and kind of Array. 
 Example: 
 MINAL((/1,2,3/)) returns the value 1. 
 MINVAL(C,MASK=C > 0.0) returns the minimum of the positive elements of C. 
 For  
⎛
⎞
= ⎜
⎟
⎝
⎠
1
3
5
2
4
6
B
 
 MINVAL(B,DIM=1) returns (1,3,5). 
 MINVAL(B,DIM=2) returns (1,2). 
 MOD(A,B) 
 Returns the remainder when ﬁ rst argument divided by second. 
 Argument: A 
 Type: I, R 
 Result: As arguments 
 Class: E 
 Note: if B=0 the result is processor dependent. For B ¹ 0 the result is A - INT
(A/B) * B. 

576
Appendix C
 Example: R=MOD(A,B) 
 if A=8 and B=5 then R=3 
 if A=−8 and B=5 then R=−3 
 if A=8 and B=−5 then R=3 
 if A=−8 and B=−5 then R=−3 
 MODULO(A,B) 
 Returns the modulo of the arguments. 
 Argument: A 
 Type: I,R 
 Result: As A 
 Class: E 
 Note: 
 1.  if B=0 then the result is processor dependent. 
 2.  integer A 
 The result is R where A= Q * B + R and Q is integer 
 for B>0, 0  £ R < B 
 for B < 0, B < R  £ 0 
 3.  real A 
 The result is A - FLOOR(A/B) * B. 
 Example: R=MODULO(A,B) 
 if A=8 and B=5 then R=3 
 if A=−8 and B=5 then R=2 
 if A=8 and B=−5 then R=−2 
 if A=−8 and B=−5 then R=−3 
 MOVE_ALLOC (FROM, TO) 
 Move an allocation. 
 Argument: FROM 
 May be any type and rank. It shall be allocatable. It is 
INTENT(INOUT). 
 Argument: TO 
 Type compatible with FROM and same rank. It shall 
be allocatable. 
 Class: Pure subroutine 
 Example:
 integer, dimension(:), allocatable:: b,c
  allocate(b(1:12)) 
  b(2) = 24 
  call mov_alloc(from=b, to=c) 
 ! b is unallocated 
 ! c is allocated with bounds (1:12) and c(2) == 24 
 MVBITS(From,F_Pos,Len,To,T_Pos) 
 Copies a sequence of bits from one data object to another. 

577
Appendix C
 Argument: From 
 Type: I 
 Result: N/A 
 Class: S 
 All arguments are of integer type. 
 Note: 
 From must be intent(in). 
 F_Pos must be intent(in), F_Pos  ³ 0, F_Pos+Len  £ BIT_SIZE(From). 
 Len must be intent(in), Len  ³ 0. 
 To must be intent(inout). 
 T_Pos must be intent(in), T_Pos  ³ 0, T_Pos + Len  £ BIT_SIZE(To). 
 Example: call MVBITS(F,FP,L,T,TP) 
 NEAREST(X,Next) 
 Returns the nearest different number. See Chap.  5 and the real numeric model. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Next is of type R. 
 Example: N=NEAREST(X,Next) 
 NEW_LINE (A) 
 Returns newline character used for formatted stream output. 
 Argument: A 
 Type: Char 
 Result: Char 
 Class: I 
 Example:
 open(2,ﬁ le='nline.txt', access='stream', form='formatted') 
 write(2,'(a)')'hola'//new_line('a')//'mundo' 
 will write 2 lines to the ﬁ le nline.txt. 
 NINT(A, Kind ) 
 Yields nearest integer. 
 Argument: A 
 Type: RI 
 Result: I 
 Class: E 
 Note: 
 1.  A > 0, the result is INT(A+0.5). 
 2.  A  £ 0, the result is INT(A−0.5). 
 Example: I=NINT(X) 
 NORM2 (X,  DIM ) 
 L2 norm of an array.  

578
Appendix C
 Argument: X 
 Type: R array 
 Argument: DIM 
 Type: DIM (optional) shall be an integer scalar with a value in the 
range 1 <= DIM <= n, where n is the rank of X. The correspond-
ing actual argument shall not be an optional dummy argument. 
 Result: R 
 Class: T 
 Note: 
 Case (i):  The result of NORM2 (X) has a value equal to a processor-dependent 
approximation to the generalized L2 norm of X, which is the square root of the 
sum of the squares of the elements of X. 
 Case (ii): If DIM is present the array is reduced as for SUM(X,DIM) except that 
NORM2 is applied to the reduced vectors. 
 Examples: 
 NORM2([3.0, 4.0]) is 5.0. 
 If X has the value 1.0 2.0 3.0 4.0 
 then NORM2(X,DIM=1) is [3.162, 4.472] and NORM2(X,DIM=2) is [2.236,5.0] 
approximately. 
 NOT(I) 
 Returns the logical complement of the argument. 
 Argument: I 
 Type: I 
 Result: As I 
 Class: E 
 Example: I=NOT(I) 
 NULL(Mold) 
 Returns a disassociated pointer. 
 Argument: Mold 
 Type: P 
 Result: As argument 
 Class: T 
 Note: 
 if the argument Mold is present the result is the same as Mold. 
 Otherwise it is determined by context. 
 Example: real, pointer :: P=>NULL() 
 NUM_IMAGES ( ) 
 Number of images. 
 Argument: None 
 Result: I 
 Class: T 
 Example:
 PRINT*, 'number of images =',NUM_IMAGES( ) 
 PACK(Array,Mask,  Vector ) 
 Packs an array into an array of rank 1, under the control of a mask. 

579
Appendix C
 Argument: Array 
 Type: Any 
 Result: As Array 
 Class: T 
 Note: 
 1.  Array must be an array. 
 2.  Mask be conformable with Array. 
 3.  Vector must have rank 1 and have at least as many elements as there are TRUE 
elements in Mask. 
 4.  if Mask is scalar with the value TRUE. Vector must have at least as many ele-
ments as there are in Array. 
 5.  The result is an array of rank 1. 
 6.  if Vector is present the result size is that of Vector. 
 7.  if Vector is not present the result size is t, the number of TRUE elements in Mask, 
unless Mask is scalar with a value TRUE in which case the result size is the size 
of Array. 
 Example: R=PACK(A,M) 
 PARITY (MASK,  DIM ) 
 Reduce array with .NEQV. operation. 
 Argument: MASK 
 Type: L array 
 Argument: DIM 
 I scalar in the range 1 <= DIM <=n where n is rank of MASK. 
 Example: 
 If T has the value true and F has the value false 
 PARITY([T,T,T,F]) is true. 
 POPCNT (I) 
 Number of one bits in the sequence of bits of I. 
 Argument: I 
 Type: I 
 Result: I 
 Class: E 
 Example: 
 POPCNT ([1, 2, 3, 4, 5, 6, 7]) has the value [1, 1, 2, 1, 2, 2, 3]. 
 POPPAR (I) 
 Returns the parity of the bit count of an integer expressed as 0 or 1. POPPAR (I) 
has the value 1 if POPCNT (I) is odd, and 0 if POPCNT (I) is even. 
 Argument: I 
 Type: I 
 Result: I 
 Type: E 
 Example: 
 POPPAR ([1, 2, 3, 4, 5, 6, 7]) has the value [1, 1, 0, 1, 0, 0, 1]. 
 PRECISION(X) 

580
Appendix C
 Returns the decimal precision of the argument. See Chap.  5 and numeric 
models. 
 Argument: X 
 Type: R, C 
 Result: I 
 Class: I 
 Example: I=PRECISION(X) 
 PRESENT(A) 
 Returns whether an optional argument is present. 
 Argument: A 
 Type: Any 
 Result: L 
 Class: I 
 Note: A must be an optional argument of the procedure in which the PRESENT 
function reference appears. 
 Example: if (PRESENT(X)) then … 
 PRODUCT(Array, Dim,Mask ) 
 The product of all of the elements of Array along the dimension Dim corre-
sponding to the TRUE elements of Mask. 
 Argument: Array 
 Type: N 
 Result: As Array 
 Class: T 
 Note: 
 1.  Array must be an array. 
 2.  1  £ Dim  £ n where n is the rank of Array. 
 3.  Mask must be conformable with Array. 
 4.  result is scalar if Dim is absent, or Array has rank 1, otherwise the result is an 
array of rank n–1. 
 Example:
 1.  PRODUCT((/1,2,3/)) the result is 6. 
 2.  PRODUCT(C,Mask=C > 0.0) forms the product of the positive elements of C. 
 3.  if  
⎛
⎞
= ⎜
⎟
⎝
⎠
1
3
5
2
4
6
B
 
 PRODUCT(B,DIM=1) is (2,12,30) and 
 PRODUCT(B,DIM=2) is (15,48) 
 RADIX(X) 
 Returns the base of the numeric argument. See Chap.  5 and numeric models. 
 Argument: X 
 Type: I,R 
 Result: I 
 Class: I 

581
Appendix C
 Example: Base=RADIX(X) 
 RANDOM_NUMBER(X) 
 Returns one pseudorandom number or an array of pseudorandom numbers from 
the uniform distribution over the range 0  £ x < 1 
 Argument: X 
 Type: R 
 Result: N/A 
 Class: S 
 Note: X is intent(out). 
 Example: call RANDOM_NUMBER(X) 
 RANDOM_SEED( Size,Put,Get ) 
 Restarts (seeds) or queries the pseudorandom generator used by RANDOM_
NUMBER. 
 Argument: Size 
 Type: I 
 Result: N/A 
 Class: S 
 All arguments are of integer type. 
 Note: 
 1.  Size is intent(out). It is set to the number N of integers that the processor uses to 
hold the value of the seed. 
 2.   Put is intent(in). It is an array of rank 1 and size  ³ N. It is used by the processor 
to set the seed value. 
 3.  Get is intent(out). It is an array of rank 1 and size  ³ N. It is set by the processor 
to the current value of the seed. 
 Example: call RANDOM_SEED 
 RANGE(X) 
 Returns the decimal exponent range of the real argument. See Chap.  5 and the 
numeric model representing the argument. 
 Argument: X 
 Type: N 
 Result: I 
 Class: I 
 Example: I=RANGE(N) 
 REAL(A, Kind ) 
 Converts to real from integer, real or complex. 
 Argument: A 
 Type: N 
 Result: R 
 Class: E 
 Example: X=real(A) 
 REPEAT(String,N_Copies) 
 Concatenates several copies of a string. 

582
Appendix C
 Argument: String 
 Type: S 
 Result: S 
 Class: T 
 Example: New_S=REPEAT(S,10) 
 RESHAPE(Source,Shape, Pad,Order ) 
 Constructs an array of a speciﬁ ed shape from the elements of a given array. 
 Argument: Source 
 Type: Any 
 Result: As Source 
 Class: T 
 Note: 
 1.  Source must be an array. if Pad is absent or of size zero the size of Source must 
be  ³ PRODUCT(Shape). 
 2.  Shape must be a rank 1 array and 0  £ size < 8. 
 3.  Pad must be an array. 
 4.  Order must have the same shape as Shape and its value must be a permutation of 
(1,2,… ,n) where n is the size of Shape. if absent it is as if it were present with 
the value (1,2,…,n). 
 5.  The result is an array of shape, Shape. 
 Example: 
 RESHAPE((/1,2,3,4,5,6/),(/2,3/)) has the value  
⎛
⎞
⎜
⎟
⎝
⎠
1
3
5
2
4
6  
 RESHAPE((/1,2,3,4,5,6/) , (/2,4/) , (/0,0/) , (/2,1/)) has the value  ⎛
⎞
⎜
⎟
⎝
⎠
1
2
3
4
5
6
0
0  
 RRSPACING(X) 
 Returns the reciprocal of the relative spacing of model numbers near the argu-
ment value. See Chap.  5 and the real numeric model. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: Z=RRSPACING(X) 
 SAME_TYPE_AS (A, B) 
 Query dynamic types for equality. If the dynamic type of A or B is extensible, the 
result is true if and only if the dynamic type of A is the same as the dynamic type of 
B. If neither A nor B has extensible dynamic type, the result is processor dependent.  
 Argument: A 
 An object of extensible declared type or unlimited polymorphic. If 
it is a pointer, it shall not have an undeﬁ ned association status. 
 Argument: B 
 An object of extensible declared type or unlimited polymorphic. If 
it is a pointer, it shall not have an undeﬁ ned association status. 
 Result: L 
 Type: I 

583
Appendix C
 SCALE(X,I) 
 Returns X * b I where b is the base in the model representation of X. See Chap.  5 
and the real numeric model. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 I is of integer type. 
 Example: Z=SCALE(X,I) 
 SCAN(String,Set, Back ) 
 Scans a string for any one of the characters in a set of characters. 
 Argument: String 
 Type: S 
 Result: I 
 Class: E 
 Note: 
 1.  The default is to scan from the left, and will only be from the right when Back is 
present and has the value TRUE. 
 2.  Zero is returned if the scan fails. 
 Example: W=SCAN(String,Set) 
 SELECTED_CHAR_KIND (NAME) 
 Returns the kind value for the character set whose name is given by the character 
string NAME or −1 if not supported. 
 Argument: NAME 
 Type: Char 
 Result: I 
 Class: T 
 Note: 
 If NAME has the value: 
 DEFAULT: 
 The result is the kind of the default character type. 
 ASCII: 
 The result is the kind of the ASCII character type. 
 ISO_10646: 
 The result is the kind of the ISO/IEC 10646 UCS-4 character type. 
 SELECTED_INT_KIND(R) 
 Returns a value of the kind type parameter of an integer data type that represents 
all integer values n with −10 R < n < 10 R 
 Argument: R 
 Type: I 
 Result: I 
 Class: T 
 Note: 
 R must be scalar. 
 if a kind type parameter is not available then the value −1 is returned. 

584
Appendix C
 Example: I=SELECTED_INT_KIND(2) 
 SELECTED_REAL_KIND( P,R,Radix ) 
 Returns a value of the kind type parameter of a real data type with decimal preci-
sion of at least P digits and a decimal exponent range of at least R. 
 Argument: P and R 
 Type: I 
 Result: I 
 Class: T 
 Note: 
 1.  P and R must be scalar. 
 2.  The value −1 is returned if the precision is not available, the value −2 if the expo-
nent range is not available, and −3 if neither is available. 
 Example: I=SELECTED_REAL_KIND(P,R) 
 SET_EXPONENT(X,I) 
 Returns the model number whose fractional part is the fractional part of the 
model representation of X and whose exponent part is I. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 I is of integer type. 
 Example: Exp_Part=SET_EXPONENT(X,I) 
 SHAPE(Source) 
 Returns the shape of the array argument or scalar. 
 Argument: Source 
 Type: Any 
 Result: I 
 Class: I 
 Note: 
 1.   Source may be array valued or scalar. It must not be a pointer that is disassoci-
ated or an allocatable array that is not allocated. It must not be an assumed-size 
array. 
 2.  The result is an array of rank 1 whose size is equal to the rank of Source. 
 Example: S=SHAPE(A(2:5,-1:1)) yields S=(4,3) 
 SHIFTA (I, SHIFT) 
 The result has the value obtained by shifting the bits of I to the right by SHIFT 
bits and replicating the leftmost bit of I in the left SHIFT bits. 
 Arguments: I 
 Type: I 
 Argument: SHIFT 
 Type: I (non-negative and <= BIT_SIZE(I)). 
 Result: Same as I 
 Class: E 
 Example: SHIFTA (IBSET (0, BIT_SIZE (0) -1), 2) is equal to 
 SHIFTL (7, BIT_SIZE (0) - 3). 

585
Appendix C
 SHIFTL (I, SHIFT) 
 Left shift. Returns the bits of I shifted left. 
 Arguments: I 
 Type: I 
 Argument: SHIFT 
 Type: I (non-negative and <= BIT_SIZE(I)). 
 Result: same as I 
 Class: E 
 Example: SHIFTL (4, 1) is 8 
 SHIFTR (I, SHIFT) 
 Right shift. Returns the bits of I shifted right. 
 Arguments: I 
 Type: I 
 Argument: SHIFT 
 Type: I (non-negative and <= BIT_SIZE(I)). 
 Result: same as I 
 Class: E 
 Example: SHIFTR (4, 1) is 2. 
 SIGN(A,B) 
 Absolute value of A times the sign of B. 
 Argument: A 
 Type: I, R 
 Result: As A 
 Class: E 
 Note: 
 In the special case where B is zero normally the result would have the value 
ABS(A), but if B is one of the real kind types and the processor is able to distinguish 
between plus zero and minus zero then the result is ABS(A) if B is plus zero and the 
result is –ABS(A) if B is minus zero. 
 B is as A. 
 Example: A=SIGN(A,B) 
 SIN(X) 
 Sine. 
 Argument: X 
 Type: R, C 
 Result: As argument 
 Class: E 
 Note: The argument is in radians. 
 Example: Z=SIN(X) 
 SINH(X) 
 Hyperbolic sine. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Z=SINH(X) 
 SIZE(Array, Dim ) 

586
Appendix C
 Returns the extent of an array along a speciﬁ ed dimension or the total number of 
elements in an array. 
 Argument: Array 
 Type: Any 
 Result: I 
 Class: I 
 Note: 
 1.  Array must be an array. It must not be a pointer that is disassociated or an allocat-
able array that is not allocated. if Array is an assumed-size array Dim must be 
present with a value less than the rank of Array. 
 2.  Dim must be scalar and in the range 1  £ Dim  £ n where n is the rank of Array. 
 3.  result is equal to the extent of dimension Dim of Array, or if Dim is absent, the 
total number of elements of Array. 
 Example: A=SIZE(Array) 
 SPACING(X) 
 Returns the absolute spacing of model numbers near the argument value. See 
Chap.  5 and the real numeric model. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: E 
 Example: S=SPACING(X) 
 SPREAD(Source,Dim,N_Copies) 
 Creates an array with an additional dimension, replicating the values in the origi-
nal array. 
 Argument: Source 
 Type: Any 
 Result: As Source 
 Class: T 
 Note: 
 1.  Source may be array valued or scalar, with rank less than 7. 
 2.  Dim must be scalar and in the range 1  £ Dim  £ n+1 where n is the rank of 
Source. 
 3.  N_Copies must be scalar. 
 4.  The result is an array of rank n+1. 
 Example: 
 if A is the array (2,3,4) then SPREAD(A,DIM=1,NCOPIES=3) then the result is 
the array  
2
3
4
2
3
4
2
3
4
⎛
⎞
⎜
⎟
⎜
⎟
⎝
⎠
 

587
Appendix C
 SQRT(X) 
 Square root. 
 Argument: X 
 Type: R, C 
 Result: As argument 
 Class: E 
 Example A=SQRT(B) 
 STORAGE_SIZE (A,  KIND ) 
 Storage size in bits. Returns the size, in bits, that would be taken in memory by 
an array element with the dynamic type of A. 
 Argument: A 
 Type: scalar or array of any type. 
 Argument: KIND (optional) 
 Result: I 
 Class: I 
 Example: STORAGE_SIZE (1.0) has the same value as the named constant 
NUMERIC_STORAGE_SIZE in the intrinsic module ISO_FORTRAN_ENV. 
 SUM(Array, Dim,Mask ) 
 Returns the sum of all elements of Array along the dimension Dim correspond-
ing to the true elements of Mask. 
 Argument: Array 
 Type: N 
 Result: As Array 
 Class: T 
 Note: 
 1.  Array must be an array. 
 2.  1  £ Dim  £ n where n is the rank of Array. 
 3.  Mask must be conformable with Array. 
 4.  result is scalar if Dim is absent, or Array has rank 1, otherwise the result is an 
array of rank n–1. 
 Example:
 1.  SUM((/1,2,3/)) the result is 6. 
 2.  SUM(C,Mask=C > 0.0) forms the arithmetic sum of the positive elements of C. 
 3.  if 
1
3
5
2
4
6
B
⎛
⎞
= ⎜
⎟
⎝
⎠
 
 SUM(B,Dim=1) is (3,7,11) 
 SUM(B,Dim=2) is (9,12) 
 SYSTEM_CLOCK( Count,Count_Rate,Count_Max ) 
 Returns integer data from a real time clock. 
 Argument: Count 
 Type: I 
 Result: N/A 
 Class: S 

588
Appendix C
 Note: 
 1.   Count is intent(out) and is set to a processor dependent value based on the cur-
rent value of the processor clock or to -HUGE(0) if there is no clock. 0  £ Count 
 £ Count_Max. 
 2.  Count_Rate is intent(out) and it is set to the number of processor clock counts 
per second, or zero if there is no clock. 
 3.  Count_max is intent(out) and is set to the maximum value that Count can have or 
to zero if there is no clock. 
 Example: call SYSTEM_CLOCK(C,R,M) 
 TAN(X) 
 Tangent. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Note: X must be in radians. 
 Example: Y=TAN(X) 
 TANH(X) 
 Hyperbolic tangent. 
 Argument: X 
 Type: R,C 
 Result: As argument 
 Class: E 
 Example: Y=TANH(X) 
 THIS_IMAGE () 
 THIS_IMAGE (COARRAY, DIM ) 
 Cosubscript(s) for this image. 
 Argument: COARRAY 
 Shall be a coarray of any type. If it is allocatable it 
shall be allocated. 
 Argument: DIM (optional) 
 Shall be a default integer scalar. Its value shall be in 
the range 1 <=DIM <= n, where n is the corank of 
COARRAY. The corresponding actual argument 
shall not be an optional dummy argument. 
 Class: T 
 Results:
 case (i)  The result of THIS_IMAGE ( ) is a scalar with a value equal to the 
index of the invoking image. 
 case (ii) The result of THIS_IMAGE (COARRAY) is the sequence of cosub-
script values for COARRAY that would specify the invoking image. 
 case (iii) The result of THIS_IMAGE (COARRAY, DIM) is the value of 
cosubscript DIM in the sequence of cosubscript values for COARRAY that 
would specify the invoking image. 

589
Appendix C
 Examples: 
 integer, dimension( 10,20), codimension[2,0:9,0:*] :: A 
 integer, codimension [0:*] 
:: IA 
 for image 5: 
 this_image(IA)  == 4 and this_image(A) = [1, 2, 0] 
 for image 96: 
 this_image(A) == [2, 7, 4] 
 TINY(X) 
 Returns the smallest positive number in the model representing numbers of the 
same type and kind type parameter as the argument. 
 Argument: X 
 Type: R 
 Result: As X 
 Class: I 
 Example: T=TINY(X) 
 TRAILZ (I) 
 Number of trailing zero bits. If all of the bits of I are zero, the result value is 
BIT_SIZE (I). Otherwise, the result value is the position of the rightmost 1 bit in I. 
 Argument: I 
 Type: I 
 Result: I 
 Class: E 
 Example: TRAILZ(4) has the value 2. 
 TRANSFER(Source,Mold,  Size ) 
 Returns a result with a physical representation identical to that of Source, but 
interpreted with the type and type parameters of Mold. 
 Argument: Source 
 Type: Any 
 Result: As Mold 
 Class: T 
 Warning: A thorough understanding of the implementation speciﬁ c internal rep-
resentation of the data types involved is necessary for successful use of this func-
tion. Consult the documentation that accompanies the compiler that you work with 
before using this function. 
 TRANSPOSE(Matrix) 
 Transposes an array of rank 2. 
 Argument: Matrix 
 Type: Any 
 Result: As argument 
 Class: T 
 Note: Matrix must be of rank 2. if its shape is (n,m) then the resultant matrix has 
shape (m,n). 
 Example: For  A =  
1 2 3
4 5 6
7 8 9
⎛
⎞
⎜
⎟
⎜
⎟
⎝
⎠
 TRANSPOSE(A) yields   
1 4 7
2 5 8
3 6 9
⎛
⎞
⎜
⎟
⎜
⎟
⎝
⎠
 

590
Appendix C
 TRIM(String) 
 Returns the argument with trailing blanks removed. 
 Argument: String 
 Type: S 
 Result: As String 
 Class: T 
 Note: String must be a scalar. 
 Example: T_S=TRIM(S) 
 UBOUND(Array, Dim ) 
 Returns all the upper bounds of an array or a speciﬁ ed upper bound. 
 Argument: Array 
 Type: Any 
 Result: I 
 Class: I 
 Note: 
 1  £  Dim  £  n, where n is the rank of Array. The result is scalar if Dim is present 
otherwise the result is an array of rank 1 and size n. 
 the result is a scalar if Dim is present otherwise is an array of rank 1, and size n.  
 Example: Z=UBOUND(A) 
 UCOBOUND (COARRAY,  DIM, KIND ) 
 Upper cobound(s) of a coarray. 
 Argument: COARRAY 
 Type: co 
 Argument: DIM (optional) 
 Type: I 
 Argument: KIND (optional) 
 Type: I 
 Result: I 
 Class: I 
 Example: 
 If NUM_IMAGES() == 24 
 INTEGER, CODIMENSION[:,:], ALLOCATABLE::A 
  ALLOCATE(A[1:10,*]) 
  UCBOUND (A) is [10,3] and UCOBOUND(A,DIM=2) is 3 
 UNPACK(Vector,Mask,Field) 
 Unpacks an array of rank 1 into an array under the control of a mask. 
 Argument: Vector 
 Type: Any 
 Result: As Vector 
 Class: T 
 Note: 
 1.  Vector must have rank 1. Its size must be at least t, where t is the number of true 
elements in Mask. 
 2.  Mask must be array valued. 
 3.  Field must be conformable with Mask. Result is an array with the same shape as 
Mask. 

591
Appendix C
 Example: 
 With  Vector = (1,2,3) and  Mask =  
⎛
⎞
⎜
⎟
⎜
⎟
⎝
⎠
F T F
T F F
F F T
 and  Field =  
1 0 0
0 1 0
0 0 1
⎛
⎞
⎜
⎟
⎜
⎟
⎝
⎠
 
 The result is  
1 2 0
11 0
0 0 3
⎛
⎞
⎜
⎟
⎜
⎟
⎝
⎠
 
 VERIFY(String,Set, Back ) 
 Verify that a set of characters contains all the characters in a string by identifying 
the position of the ﬁ rst character in a string of characters that does not appear in a 
given set of characters. 
 Argument: String 
 Type: S 
 Result: I 
 Class: E 
 Note: 
 1.  The default is to scan from the left, and will only be from the right when Back is 
present and has the value TRUE. 
 2.  The value of the result is zero if each character in String is in Set, or if String has 
zero length. 
 Example: I=VERIFY(String,Set) 

593
 Appendix D 
English and Latin Texts 
 YET IF HE SHOULD GIVE UP WHAT HE HAS BEGUN, AND AGREE TO 
MAKE US OR OUR KINGDOM SUBJECT TO THE KING OF ENGLAND OR 
THE ENGLISH, WE SHOULD EXERT OURSELVES AT ONCE TO DRIVE HIM 
OUT AS OUR ENEMY AND A SUBVERTER OF HIS OWN RIGHTS AND 
OURS, AND MAKE SOME OTHER MAN WHO WAS ABLE TO DEFEND US 
OUR KING; FOR, AS LONG AS BUT A HUNDRED OF US REMAIN ALIVE, 
NEVER WILL WE ON ANY CONDITIONS BE BROUGHT UNDER ENGLISH 
RULE. IT IS IN TRUTH NOT FOR GLORY, NOR RICHES, NOR HONOURS 
THAT WE ARE FIGHTING, BUT FOR FREEDOM - FOR THAT ALONE, 
WHICH NO HONEST MAN GIVES UP BUT WITH LIFE ITSELF. 
 QUEM SI AB INCEPTIS DIESISTERET, REGI ANGLORUM AUT ANGLICIS 
NOS AUT REGNUM NOSTRUM VOLENS SUBICERE, TANQUAM INIMICUM 
NOSTRUM ET SUI NOSTRIQUE JURIS SUBUERSOREM STATIM EXPELLERE 
NITEREMUR ET ALIUM REGEM NOSTRUM QUI AD DEFENSIONEM 
NOSTRAM SUFFICERET FACEREMUS. QUIA QUANDIU CENTUM EX NOBIS 
VIUI REMANSERINT, NUCQUAM ANGLORUM DOMINIO ALIQUATENUS 
VOLUMUS SUBIUGARI. NON ENIM PROPTER GLORIAM, DIUICIAS AUT 
HONORES PUGNAMUS SET PROPTER LIBERATEM SOLUMMODO QUAM 
NEMO BONUS NISI SIMUL CUM VITA AMITTIT. 
 from ‘The Declaration of Arbroath’ c.1320. The English translation is by Sir 
James Fergusson. 

595
 Appendix E 
Coded Text Extract 
 OH YABY NSFOUN, YAN DUBZY LZ DBUYLTUBFAJ BYYBOHNX GPDA 
FNUZNDYOLH YABY YAN SBF LZ B GOHTMN FULWOHDN DLWNUNX YAN 
GFBDN LZ BH NHYOUN DOYJ, BHX YAN SBF LZ YAN NSFOUN OYGNMZ 
BH NHYOUN FULWOHDN. OH YAN DLPUGN LZ YOSN, YANGN NKYNHGOWN 
SBFG VNUN ZLPHX GLSNALV VBHYOHT, BHX GL YAN DLMMNTN LZ 
DBUYLTUBFANUG NWLMWNX B SBF LZ YAN NSFOUN YABY VBG YAN 
GBSN GDBMN BG YAN NSFOUN BHX YABY DLOHDOXNX VOYA OY FLOHY 
ZLU FLOHY. MNGG BYYNHYOWN YL YAN GYPXJ LZ DBUYLTUBFAJ, 
GPDDNNXOHT TNHNUBYOLHG DBSN YL RPXTN B SBF LZ GPDA 
SBTHOYPXN DPSENUGLSN, BHX, HLY VOYALPY OUUNWNUNHDN, YANJ 
BEBHXLHNX OY YL YAN UOTLPUG LZ GPH BHX UBOH. OH YAN VNGYNUH 
XNGNUYG, YBYYNUNX ZUBTSNHYG LZ YAN SBF BUN GYOMM YL EN 
ZLPHX, GANMYNUOHT BH LDDBGOLHBM ENBGY LU ENTTBU; OH YAN 
VALMN HBYOLH, HL LYANU UNMOD OG MNZY LZ YAN XOGDOFMOHN 
LZ TNLTUBFAJ.  

597
 Appendix F 
Formal Syntax 
 Statement ordering 
 format statements may appear anywhere between the use statement and the 
 contains statement. 
 The following table summarises the usage of the various statements within indi-
vidual scoping units. 
 Kind of scoping 
unit 
 Main 
program 
 module 
 external sub 
program 
 module sub 
program 
 Internal sub 
program 
 interface 
body 
 use 
 Y 
 Y 
 Y 
 Y 
 Y 
 Y 
 format 
 Y 
 N 
 Y 
 Y 
 Y 
 N 
 Misc Dec a 
 Y 
 Y 
 Y 
 Y 
 Y 
 Y 
 Derived type 
deﬁ nition 
 Y 
 Y 
 Y 
 Y 
 Y 
 Y 
 interface block 
 Y 
 Y 
 Y 
 Y 
 Y 
 Y 
 Executable 
statement 
 Y 
 N 
 Y 
 Y 
 Y 
 N 
 contains Y 
 Y 
 Y 
 Y 
 Y 
 N 
 a Misc Dec (Miscellaneous declaration) are parameter statements, implicit state-
ments, type declaration statements and speciﬁ cation statements 
 Syntax summary of some frequently used Fortran constructs 
 The following provides simple syntactical deﬁ nitions of some of the more fre-
quently used parts of Fortran. 
 Main program
 program [ program-name ] 
  [ speciﬁ cation-construct ] …  
 [ executable-construct ] …  
 [contains  
 [ internal procedure ] … ]  
 end [ program [ program-name ] ]  

598
Appendix F 
 Subprogram 
 procedure heading 
  [ speciﬁ cation-construct ] …  
  [ executable-construct ] …  
  [contains  
  [ internal procedure ] … ]  
 procedure ending 
 module 
 module name 
  [ speciﬁ cation-construct ] …  
  [contains  
  Subprogram  
  [ subprogram ] … ]  
 end [ module [ module-name ]  
 Internal procedure
 procedure heading 
  [ speciﬁ cation construct ] …  
  [ executable construct ] …  
 procedure ending 
 procedure heading
 [ recursive ] [ type speciﬁ cation ] function  
 function-name & 
  ( [ dummy argument list ] ) [ result ( result name  
 ) ] 
 [ recursive ] subroutine subroutine name & 
  [ ( [ dummy argument list ] ) ] 
 procedure ending
 end [ function [ function name ] ]  
 end [ subroutine [ subroutine name ] ]  
 Speciﬁ cation construct
 derived type deﬁ nition  
 interface block  
 speciﬁ cation statement  
 Derived type deﬁ nition
 type [ [ , access speciﬁ cation ] :: ] type name 
  [ private ]  
  [ sequence ]  
  [ type speciﬁ cation [[ , pointer ] :: ] component  

599
Appendix F 
 speciﬁ cation list ] 
  . . . 
 end type [ type name ] 
 interface block
 interface [ generic speciﬁ cation ] 
  [ procedure heading 
   [ speciﬁ cation construct ] …  
 procedure ending ] …  
  [ module procedure module procedure name list ] …  
 end interface  
 Speciﬁ cation statement
 allocatable [ :: ] allocatable array list  
 dimension array dimension list  
 external external name list  
 format ( [ format speciﬁ cation list ] )  
 implicit implicit speciﬁ cation  
 intent ( intent speciﬁ cation ) :: dummy argument name  
 list 
 intrinsic intrinsic procedure name list  
 optional [ :: ] optional object list  
 parameter ( named constant deﬁ nition list )  
 pointer [ :: ] pointer name list  
 public [ [ :: ] module entity name list ]  
 private[ [ :: ] module entity name list ]  
 save [ [ :: ] saved object list ]  
 target [ :: ] target name list  
 use module name [ , rename list ]  
 use module name , only : [ access list ]  
 type speciﬁ cation [ [ , attribute speciﬁ cation 
] & 
 …::object declaration list 
 type speciﬁ cation
 integer [ ( [ KIND= ] kind parameter ) ]  
 real[ ( [ KIND= ] kind parameter ) ]  
 complex[ ( [ KIND= ] kind parameter ) ]  
 character[ ( [ KIND= ] kind parameter ) ]  
 character[ ( [ KIND= ] kind parameter ) ] & 
  [ LEN= ] length parameter )  
 LOGICAL[ ( [ KIND= ] kind parameter ) ]  
 type ( type name )  

600
Appendix F 
 Attribute speciﬁ cation
 allocatable  
 dimension ( array speciﬁ cation )  
 external  
 intent ( intent speciﬁ cation )  
 intrinsic  
 optional  
 parameter  
 pointer  
 private  
 public  
 save 
 target  
 Executable construct
 action statement  
 case construct  
 do construct  
 if construct  
 where construct  
 Action statement
 allocate ( allocation list ) [ ,STAT= scalar integer 
variable ] )  
 call 
subroutinename 
[ 
( 
[ 
actual 
argument 
speciﬁ cation  
 list] ) ]  
 close ( close speciﬁ cation list )  
 cycle [ do construct name ]  
 deallocate( name list ) [ , STAT= scalar integer vari-
able ] )  
 endﬁ le external ﬁ le unit  
 exit [ do construct name ]  
 goto label  
  if ( scalar logical expression ) action statement  
 inquire ( inquire speciﬁ cation list ) [ output item  
 list ]  
 nullify ( pointer object list )  
 open ( connect speciﬁ cation list )  
 print format [ , output item list ]  
 read (i/o control speciﬁ cation list ) [ input item list 
] 
 read format [ , output item list ]  
 return [ scalar integer expression ]  

601
Appendix F 
 rewind ( position speciﬁ cation list )  
 stop [ access code ]  
 where ( array logical expression ) array assignment  
 expression  
 write ( i/o control speciﬁ cation list ) [ output item 
list ]  
 pointer variable => target expression  
 variable = expression  

603
 Appendix G 
Compiler Options 
 In this appendix we look at some of compiler options we have used during the 
development of the programs in the book. 
 Cray 
 This compiler was available on the Hector Service and several compilers are avail-
able and the default is the Portland Group compiler. To make the Cray compiler 
available one had to use the following commands 
 module swap PrgEnv-pgi PrdEnv-cray 
 and then 
 ftn -h caf compiler options source ﬁ les -o executable 
 gfortran 
 gfortran
 -W 
 -Wall 
 -fbounds-check 
 -pedantic-errors 
 -std=f2003 
 -Wunderﬂ ow -O 
 -fbacktrace 
 -ffpe-trap=zero,overﬂ ow,underﬂ ow 
 -fopenmp 
 -g 

604
Appendix G 
 g95 
 g95
 -Wall 
 -std=f2003 
 -fbounds-check 
 -ftrace 
 IBM 
 (Power 7) 
 xlf
 -qlanglvl=2003pure 
 -qxlf2003=polymorphic 
 Intel 
 ifort 
 /check: all 
 Determines whether several run time conditions are checked. keyword: all, none, 
[no]arg_temp_created, [no]bounds, [no]format, [no]output_conversion 
 /coarray 
 /debug: full 
 Determines the type of debugging information generated by the compiler in the 
object ﬁ le. keyword: minimal, partial, full, none. 
 /exe:% 1intel 
 /[no]ﬂ tconsistency 
 Determines whether improved ﬂ oating point consistency is used. 
 /fpe:0 
 Speciﬁ es ﬂ oating point exception handling at run time for the main program; n  = 0, 
1, or 3. 0 - ﬂ oating underﬂ ow results in zero; all other ﬂ oating point exceptions abort 
execution 
 /gen-interfaces 
 /heap-arrays
 /inline: all 
 /list 
 /[no]map[:name] 
 Determines whether the compiler generates a link map (optionally, named name ). 
 /O 
 /openmp  /Qopenmp 
 /parallel  /Qparallel 

605
Appendix G 
 /Qcoarray 
 /Qfp-stack-check 
 /recursive 
 /stand: f03  /std03 
 /[no]traceback 
 Speciﬁ es whether the compiler should generate extra information in the object ﬁ le 
that allows the display of source ﬁ le traceback information at run time when a severe 
error occurs. 
 /warn: all
 /tcheck 
 /traceback 
 /warn:all,nodec,interfaces 
 Nag 
 nagfor 
 -C=all 
 Compile code with all possible run time checks. all array calls do none present 
pointer 
 -C=undeﬁ ned 
 -f2003 
 -info 
 -g 
 -gline 
 include line number information in run time error messages. 
 -ieee=stop 
 Enables all IEEE arithmetic facilities except for nonstop arithmetic. Execution is 
terminated on ﬂ oating overﬂ ow, divide by zero or invalid operand. 
 sun 
 f95 
 -ansi 
 -w4 
 -xcheck=%all 
 -C 
 -ftrap=common,overﬂ ow,underﬂ ow 

607
I. Chivers and J. Sleightholme, Introduction to Programming with Fortran: 
With Coverage of Fortran 90, 95, 2003, 2008 and 77, 
DOI 10.1007/978-0-85729-233-9, © Springer-Verlag London Limited 2012
 A 
 ABS , 181, 183, 210, 212, 232–234, 362, 428, 
453, 461, 550, 585 
 ACHAR , 227, 470, 550–551 
 ACM.  See Association of Computing 
Machinery (ACM) 
 ACOS , 181, 550–1 
 Actual argument , 265, 269, 272–273, 292, 
355, 458, 473, 499–501, 533, 539–540, 
564, 578, 588, 600 
 Ada , 2, 27–28, 40–41, 43, 327, 332, 417, 499 
 Addition , 3, 58, 60, 62–64, 84, 139, 195, 217, 
239, 297, 324, 327–329, 368, 397, 483 
 Addition operator , 328–329 
 ADJUSTL , 227, 551 
 ADJUSTR , 227, 551 
 Advance= , 227, 300–301, 308 
 A edit descriptor , 139, 219 
 AIMAG , 232–234, 551, 558 
 AINT , 548–550 
 Algol , 2, 22, 197 
 Algorithm(s) , 1, 9, 11–12, 15–17, 45, 58, 
183–184, 190–191, 198–199, 210, 250, 
278, 281–282, 285, 325, 349, 357–358, 
366, 434–435, 483 
 ALL , 4–5, 11, 51–52, 65–6, 69–70, 137, 
141–145, 158–161, 353–354, 411–414, 
419–420, 486–487, 489–490, 501, 
604–605 
 Allocatable 
 allocatable variable , 372, 388, 390 
 arrays , 35, 99–100, 113, 251, 270, 275, 
355, 539, 541, 584, 586 
 attribute , 36, 100–101, 129, 270, 275, 362, 
458, 471, 539, 552 
 coarray , 458 
 dummy arrays , 501, 503 
 function results , 362–363 
 Allocated , 472–473 
 Allocate statement , 101, 129, 258, 354 
 Alternate return , 530, 531 
 ANINT , 550 
 ANY , 552, 560, 593 
 APL , 2, 25, 43 
 Appendix A , 4, 539–545 
 Argument(s) , 190, 194–197, 264–266, 
268–273, 370, 471–473, 500–501, 
539–545, 550–555, 557–558, 562–566, 
569–571, 578, 580–582, 584–590 
 actual , 500–501 
 associated , 533, 540 
 character , 272 
 complex , 332, 551, 558 
 corresponding , 499, 541 
 dummy , 265, 500, 598 
 keyword , 296, 543 
 list , 195, 266, 268, 287–288, 500–501 
 optional , 499 
 Arithmetic assignment statement , 50–51, 58, 
81, 187, 253 
 Arithmetic evaluation , 58 
 Arithmetic expressions , 57–58, 64, 80, 545 
 Arithmetic if , 530 
 Arithmetic operators , 115, 223, 239 
 Array(s) , 87–90, 99–101, 107–111, 113–118, 
120–129, 283–284, 339, 539–542, 
559–562, 564–565, 567–569, 572–575, 
577–582, 584–587, 589–590 
 allocatable , 100 
 associated actual argument , 269 
 bounds , 114 
 character , 221, 247, 324 
 Index 

608
Index
 Array(s) (cont.)
deferred-shape , 129, 270, 275, 354, 362 
 dummy , 275, 540 
 element(s) , 113–115, 118, 122, 128–129, 
147, 182, 221, 356, 447, 539, 573, 575, 
580, 587 
 element order , 114, 122, 129 
 element ordering , 113–114, 118, 128, 
147, 539 
 explicit-shape , 270, 539–540 
 extent , 114 
 functions , 122 
 initialisation , 117, 120 
 initialise , 2, 113 
 manipulating , 95, 99 
 nonpointer dummy argument , 269 
 one-dimensional , 111, 114, 539 
 pointer , 270, 541 
 ragged , 299, 305–306 
 rank , 114 
 representation , 89, 93 
 section , 2, 118–120, 124, 129, 146–147, 
356, 447, 539, 545 
 shape , 114 
 size , 93, 99–100, 114, 284, 441, 579 
 stride , 124 
 two-dimensional , 111, 114 
 Array arguments 
 actual , 271, 275 
 assumed-shape dummy , 272 
 dummy , 275 
 using assumed-shape dummy , 534 
 Array assignment block , 127 
 Array constructor(s) , 36, 116, 120–122, 129 
 using , 113, 120 
 ASCII characters , 174, 540 
 set , 4, 218, 227–228, 547, 551, 
557, 566 
 type , 583 
 ASCII collating sequence , 224, 565–566, 
570–571 
 ASIN , 181, 550, 552 
 Assignment statement , 50–1, 58, 80–1, 83, 89, 
187, 252–3, 371–2, 393, 543 
 deﬁ ned , 371–372 
 intrinsic , 371, 543 
 Associated , 49, 93, 172–174, 238–239, 
251–253, 271–272, 300–305, 308, 
346–348, 420, 446, 471–473, 475–477, 
540–541, 553 
 Association of Computing Machinery (ACM) , 
17, 40, 198, 285, 324, 365 
 Association status , 252–253, 302, 553 
 Assumed length dummy argument , 272 
 Assumed-shape array(s) , 269, 272, 275, 
296, 534 
 using , 272 
 Assumed shape dummy argument , 270 
 Assumed shape parameter passing , 
270–271 
 Assumed-size , 533, 540, 584, 586 
 Assumed-size/explicit-shape dummy array 
arguments , 533 
 ATAN , 64, 181, 197, 233, 425, 428–429, 452, 
461, 540, 550, 553 
 ATAN2 , 553 
 ATOM , 16, 540, 553–554 
 ATOMIC , 448, 540, 549, 553–554 
 ATOMIC DEFINE , 553–554 
 ATOMIC REF , 554 
 Attribute speciﬁ cation , 369, 599 
 Automatic array(s) , 270, 275, 
278, 355 
 B 
 Bandwidth , 406 
 Base class , 374, 384, 388, 395 
 modiﬁ ed , 378–379 
 Base type , 231, 244, 368, 395 
 Basic , 25 
 BESSEL , 554–555 
 Bessel functions , 554–556 
 BESSEL_J0 , 554 
 BESSEL_J1 , 554–555 
 BESSEL_JN , 555 
 BESSEL_Y0 , 553 
 BESSEL_Y1 , 553 
 BESSEL_YN , 555 
 BGE , 556 
 BGT , 556 
 Binary , 20, 57, 70, 72, 77–79, 84, 151, 
172, 174, 197, 481–482, 484, 
493–494 
 BIT , 65–66, 68–71, 73, 78–79, 129–130, 
132–133, 221, 482–484, 495–496, 543, 
556–557, 561, 566, 568, 584–585 
 BIT_SIZE , 557 
 Blanks, nulls and zeros , 161 
 BLE , 556 
 Block if statement , 201–205 
 BLT , 556–557 
 Bounds , 36, 114, 129, 270, 272, 275, 457, 483, 
540–542, 569, 576, 590, 604 
 BTEST , 78–79, 557 
 Buffer , 168–169, 422, 424, 435–436 
 Byte , 33, 44, 68 
 BZ , 161 

609
Index
 C 
 Call statement , 261, 265, 268, 544 
 Case statement , 199, 205–206, 532, 534 
 C BINDING module , 469–470 
 C character types , 470 
 CEILING , 35, 557 
 C function pointer type , 471 
 CHAR , 470, 557, 566, 583 
 Character(s) 
 argument , 565, 570 
 coarray , 457 
 expression , 174–175 
 functions , 222, 227–228 
 input , 49, 218 
 i/o , 219 
 operators , 219 
 scalar, default , 562–563 
 set available , 225 
 sets, complete Fortran , 218 
 single , 139 
 string arguments , 224 
 strings , 78, 139, 161, 170, 197, 218, 220, 
223–224, 227, 540, 583, 591 
 substrings , 221 
 variables , 48, 139, 172, 218–220, 222, 224, 
227, 272, 541, 545 
 C interop , 470, 472, 474, 476, 478 
 C language , 42 
 CLASS keyword , 372, 388 
 Class type , 339 
 CLASS type speciﬁ er , 369 
 Close statement , 172 
 C mask , 573, 575, 580, 587 
 CMPLX , 231–235, 557–558 
 Coarray , 457–467 
 Fortran , 413 
 C object pointer type , 471 
 Cobol , 21 
 Cobound , 540, 569, 590 
 Codimension , 461, 463, 540–541, 567, 569, 
589–590 
 COF , 177 
 Collating sequence , 223–224, 227, 540, 557, 
565–566, 570–571 
 Column information , 157 
 Comments , 32, 38, 40, 48, 51–52, 54, 
204, 447 
 Common block , 472 
 Compilation unit , 538 
 Compiler options , 532, 603 
 COMPLEX , 1–3, 13–14, 26–27, 36, 60–61, 
68, 143–145, 202–203, 214, 218–219, 
231–235, 239–240, 470, 549–551, 
557–558 
 Components , 13, 26, 31, 33–34, 36, 158, 
244–245, 247, 262, 267, 300, 309–310, 
370, 377, 380 
 Computer algorithms , 17 
 Computer programming , 17, 285, 331, 517 
 Computer systems , 9, 15, 28, 31, 70, 128, 171, 
175, 344, 407, 493 
 Concatenate , 220, 228, 540 
 Concurrent processes, asynchronous , 416, 496 
 Conditions, end-of-record , 174, 569 
 Conformable , 114–115, 127, 129, 540, 564, 
573, 575, 579–580, 587, 590 
 CONJG , 232, 234, 558, 560 
 Constants , 57, 64, 69–70, 80, 175, 288, 290, 
361, 486–487, 533, 540–541, 543 
 named , 36, 469–471, 543–544, 554, 587 
 Constructor , 379–380, 382–385, 389 
 Contained , 4, 90, 149, 267, 272, 278, 288, 
290, 308, 355, 543–544, 550 
 Contains statement , 193, 597 
 Continuation character & , 52 
 Control speciﬁ cation list , 600–601 
 Control statements , 26, 212 
 Control structures , 3, 26–27, 35, 47, 88, 95, 
99, 108, 185, 199–200, 202, 204, 206, 
208, 210, 212–214 
 Corank , 458, 588 
 COS , 180–181, 232, 354, 558 
 COSH , 548, 556 
 Count , 141, 223, 229, 397, 424, 435, 550, 
558–559, 579, 587–588 
 C pointer , 471, 473 
 C pointer types , 471 
 C programming language , 37, 41–42, 497 
 CSHIFT , 557 
 C type(s) , 470–471, 565–566 
 Cycle , 176, 209, 212, 306, 346–347, 537, 600 
 and exit , 209, 212 
 statement , 199, 209 
 D 
 Data description statements , 47 
 Data entity , 369, 458, 473, 541 
 Data ﬁ le , 172, 176–177, 273, 279, 
284, 356 
 Data ﬁ les in Fortran , 172 
 Data integer , 281, 293, 503 
 Data items , 48, 51, 281, 300, 306, 375, 
503, 517 
 Data object , 69, 369, 413, 540–541, 543, 
545, 576 
 named , 369, 446, 545 
 Data processing statements , 47, 51 

610
Index
 Data structures , 85–86, 101, 198, 249–251, 
285, 299–300, 324–325, 332, 344, 
365–366, 368, 539 
 Data types , 3, 25–26, 30, 35, 45, 47, 50, 57, 
61, 70–71, 218–219, 231–232, 
244–245, 249, 251–252, 300, 308–309, 
332, 368–369, 424, 540–541, 545 
 DATE_AND_TIME , 281–282, 426–427, 
503–504, 559 
 Daylight Saving Time , 324 
 DBLE , 558 
 Deallocate statement , 252, 256, 278 
 Debugging , 239, 604 
 Decimal point , 51, 53, 56, 131, 134–135, 137, 
158–159 
 Decremented features , 532 
 Default kind , 67 
 Deferred-shape arrays , 275, 362 
 Deﬁ ned functions , 179, 192, 194–195, 
210, 262 
 Deﬁ ned types , 3, 26, 243–244, 247, 251, 292, 
327, 545 
 Deﬁ nition, dummy argument type , 264 
 Deleted features , 532 
 Denormal , 479, 486, 489–491 
 Derived data types , 287, 292–293, 296 
 Derived types , 36–37, 243–244, 246, 248, 250, 
288, 299, 306, 310, 369–371, 377, 387, 
469, 473, 544–545 
 deﬁ nition , 288, 381, 540, 542, 544, 
597–598 
 parameterised , 36 
 DIGITS , 560 
 DIM , 560, 564–565, 567, 569, 573–575, 
577–580, 586, 588, 590 
 Dimension attribute , 2, 88–89, 94, 99, 
106, 109 
 Direct access ﬁ les , 174–175 
 Disassociated pointer , 252, 563, 578 
 Dislin , 518–519, 521, 523, 525, 527 
 Division , 59–64, 80, 84, 204, 217, 239, 486, 
489, 541 
 Do construct , 110, 372, 600 
 do-construct-name , 110 
 Do loop , 2, 88, 90, 95–97, 99, 102–103, 
106–108, 110, 117, 120–121, 123, 147, 
176, 199, 448 
 Do statement , 88, 90, 96, 99, 106, 108–109, 
176, 206–207, 209, 211–212 
 DOT_PRODUCT , 116, 121, 183, 
560–561 
 Double precision , 331, 424, 481, 484, 514, 
532–533, 549–550, 560–561 
 Do while construct , 199 
 DPROD , 559 
 DSHIFTL , 561 
 DSHIFTR , 561 
 Dummy argument(s) , 36, 188, 194, 196, 
264–265, 267, 269, 272–273, 292, 
295–296, 355, 370, 458, 499–501, 533, 
539–544, 564, 578, 598–599 
 assumed length , 272 
 assumed shape , 269–272, 540 
 assumed size , 533 
 character , 272 
 explicit shape , 533 
 name list , 196, 599 
 names , 273, 539, 542 
 optional , 501, 564, 578, 588 
 passed-object , 370 
 procedure , 355 
 Dynamic binding , 368, 388–389, 391, 
393–395 
 Dynamic data structures , 344, 365 
 Dynamic type , 369, 372, 563–564, 582, 587 
 E 
 Easter calculation , 183 
 Edit descriptor , 131–137, 139, 141, 153, 162, 
174, 219 
 Editors , 23, 141 
 E edit descriptor , 137 
 Efﬁ ciency , 22, 26, 32–33, 175, 282, 533 
 E formats , 137, 141, 154, 158–160 
 Eiffel , 32, 244, 328, 332, 368 
 Elemental , 35, 179, 182–183, 194–195, 
282–283, 296, 343, 364, 488, 491–492, 
541, 545, 549 
 assignment , 541 
 function(s) , 182, 194–195, 282, 
364, 549 
 subroutine , 282, 488, 549 
 Else block , 185, 190, 204 
 Else if , 176, 199, 203, 205, 212–213, 293, 
303–304, 346–347 
 Elsewhere block , 127 
 End do , 90–91, 94–95, 100, 102–104, 
106–107, 125, 187, 222, 224, 273 
 End do statement , 176, 206, 209 
 End forall statement , 127 
 End if statement , 202, 205 
 End interface , 328, 338, 371, 379–380, 
382–385, 388–389, 542, 599 
 End-of-ﬁ le , 174, 568 
 End program statement , 49, 52 
 End select statement , 206 
 End subroutine statement , 264 

611
Index
 End type , 244–246, 292, 300–301, 303–307, 
309, 328, 345, 371, 373–375, 378–379, 
382, 385, 389–390, 599 
 End where , 127 
 Enhanced module facilities , 37, 39 
 Entities , 105, 144, 171, 176, 294–295, 369, 
372, 446, 458, 469, 471, 473, 540–545, 
570, 599 
 named , 372, 544 
 Entity oriented declaration , 105 
 Environment variables , 37, 412 
 EOSHIFT , 559, 560 
 Epsilon , 72, 74, 562 
 ERF , 562 
 ERFC , 562 
 ERFC_SCALED , 562 
 Error condition , 174, 563 
 Error message , 64, 173, 240, 254–255, 
259, 563 
 Error number , 420, 424, 436 
 Errors when reading , 168 
 Evaluation and testing , 15 
 Exceptional values , 93, 541 
 Exception handling , 34, 482, 485, 493, 604 
 EXECUTE_COMMAND_LINE , 
562–563 
 Execution sequence , 458 
 Execution time , 113, 129, 191 
 Exit statement , 199, 206, 209, 212 
 EXP , 44, 181, 210–212, 214, 563, 584 
 Explicit interface , 188, 296, 355, 534, 542 
 Explicit-shape array , 270, 539–540, 542 
 EXPONENT , 59, 70–73, 80, 137, 158–159, 
161, 482, 484, 492–493, 563, 572, 574, 
581, 584 
 Exponential format value , 159 
 Exponentiation operator , 58 
 Expressions , 2–3, 36, 57–62, 80, 122, 
127–128, 141, 183, 199, 201–203, 232, 
237, 239, 243, 324 
 equivalent , 60 
 scalar integer , 128, 544, 600 
 Extends , 2–3, 28, 36, 103, 382–383, 385, 
542–543, 563–564 
 EXTENDS_TYPE_OF , 563–564 
 Extents , 36, 60, 114–115, 129, 271–272, 534, 
542, 544, 555–556, 586 
 F 
 Factorial , 189 
 F edit descriptor , 134 
 File= , 142, 150, 164, 166–167, 172–173, 176, 
208, 246, 280, 283, 503, 577 
 File name(s) , 143, 155, 169, 174, 273, 281, 
503, 517 
 arbitrary , 172 
 Files , 2, 6, 21, 96, 104, 141–144, 150–151, 
153–154, 156–157, 164–177, 187, 
246–247, 268, 279–281, 295, 301–302, 
345–347, 501–504, 529 
 formatted , 157, 165, 175 
 internal , 168–169 
 unformatted , 167, 175 
 Finalize , 420–421, 423, 440 
 Final subroutine , 540 
 FINDLOC , 564 
 First-order ordinary differential equations , 
349, 351, 353–355 
 Fixed ﬁ elds on input , 156 
 Floating point arithmetic , 481, 493–494, 497 
 Floating point formats , 479, 482 
 FLOOR , 564 
 fmt , 142–147, 149–150, 159, 162–164, 
172–173, 175–176, 208, 246, 265, 
279–280, 300, 303–304, 308, 345–347, 
502–503 
 fmt= , 142–143, 147, 162–164, 172–173, 
175–176, 208, 246, 265, 279–280, 300, 
303–304, 308, 345–347, 502–503, 569 
 Forall statement , 113, 128 
 form= , 167, 577 
 Format labels , 143, 163 
 Format statement , 131–133, 138, 140, 143, 
145, 149, 153, 157, 162, 170, 597 
 Formatted data , 174 
 Formatted Fortran output , 144 
 Formatting , 148–149, 161, 174 
 Fortran character set , 52 
 Fortran’s array element ordering , 147 
 FRACTION , 564 
 Frequency , 206, 229–230, 232–233 
 Function(s) , 179–183, 185–197, 209–214, 
222–224, 307–308, 380, 382–386, 389, 
427–429, 471–473, 489–492, 541–545, 
549–551, 553–556, 561–562 
 arguments , 195 
 elemental , 182 
 generic , 181, 331 
 header , 188, 190, 196 
 IEEE , 491–492 
 inquiry , 472, 549 
 internal , 192, 195, 534 
 intrinsic , 180 
 name , 185, 187, 195–196, 542, 598 
 pure , 193 
 recursive , 188–189 
 result , 542–543 

612
Index
 Function(s) (cont.)
result clause , 196 
 standard , 214, 235 
 supplied , 195, 329, 544 
 transfer , 79 
 transformational , 182 
 user deﬁ ned , 185 
 G 
 GAMMA , 564–565, 571 
 Gaussian elimination , 357 
 Generating a new line , 149 
 Generic , 3, 34, 179, 181, 185, 194–195, 295, 
331–342, 371–372, 388–390, 471, 473, 
486, 540, 542 
 example , 332–333, 335, 337, 339 
 functions , 181, 185, 331 
 interface , 372 
 name , 371 
 procedure(s) , 486, 542 
 programming , 3, 331–332, 334, 336, 338, 
340, 342 
 Generic type bound procedure , 538 
 Global , 13, 287–288, 296, 409, 472, 504, 
514, 542 
 Good programming guidelines , 54 
 Goto statement , 200, 212, 215 
 Graphics , 29, 31, 399, 403, 409, 480, 496, 
499, 518–519, 521, 523, 525, 527, 529 
 Graphics library , 399, 403, 518 
 H 
 High-level languages , 21, 24–25 
 High Performance Fortran (HPF) , 4, 35, 
128, 414 
 High Performance Fortran Forum (HPFF) , 414 
 Host association , 36, 543–544 
 HPF.  See High Performance Fortran (HPF) 
 HPFF.  See High Performance Fortran 
Forum (HPFF) 
 HUGE , 72–74, 81, 492, 565, 588 
 HYPOT , 565 
 I 
 IACHAR , 227, 565 
 IALL , 565 
 IAND , 565 
 IANY , 565 
 IBCLR , 566 
 IBITS , 566 
 IBSET , 566 
 ICHAR , 224, 566 
 Icon , 2, 30, 40, 42 
 I edit descriptor , 132 
 IEEE , 3, 36, 40, 44, 72, 84, 479–494, 
496–497, 605 
 arithmetic , 479–482, 484, 486, 488–490, 
492, 494, 496 
 arithmetic support in Fortran , 3 
 denormal values , 486, 489 
 IEEE NaNs , 486, 489 
 IEEE Standard , 84, 493–494 
 IEOR , 566 
 IERROR , 424 
 If construct , 202, 372, 600 
 I format , 132, 135, 141, 153, 156 
 If statement , 201, 204, 532 
 Image , 29, 413, 457–464, 466–467, 542, 554, 
566–467, 578, 588–590 
 control statements , 458 
 current , 457–458 
 invoking , 588 
 numbers , 460, 463 
 selectors , 458 
 IMAGE_INDEX , 458, 566–567 
 Implicit interface , 542 
 Implicit none statement , 48, 51–52 
 Implicit typing , 533 
 Implied do loops , 104, 146–147 
 Impure , 549 
 Include , 2, 4, 21–23, 27, 30, 33, 35, 37, 48, 52, 
87, 129, 373, 382, 480–481 
 INDEX , 223–224, 229, 566–567 
 Inﬁ nity , 479, 482–483, 491–492, 541 
 Inheritance , 30, 368, 381, 383, 388 
 Initialisation , 35–36, 117, 120–121, 252 
 Initialisation of components , 35 
 Initialise , 121, 126, 310, 375, 380–381, 
384, 539 
 Initial value problems , 348 
 ﬁ rst-order , 348 
 Initial values , 80, 90, 120, 213, 244, 349, 
376–377, 384, 429, 476 
 given , 51, 120 
 Inout , 191, 266, 279, 282, 374, 376, 383, 
385–386, 389, 500, 502, 563, 576–577 
 Input , 2, 47, 51, 56, 115, 144, 155–157, 
159–165, 168–170, 172, 215, 219, 232, 
240, 353 
 formatted , 163 
 Input and output (I/O) , 174, 187, 194, 219, 
600–601 
 Input-item-list , 52 
 Input/output statements , 49, 143 
 Inquire statement , 598 

613
Index
 Inquiry functions , 73 
 Instructions , 46, 49, 406–407, 544 
 INT , 68–69, 73, 77, 181, 214, 232, 235, 
339–340, 371, 470, 554, 561, 567, 577, 
583–584 
 Integer , 61–73, 102–110, 154–158, 165–168, 
188–194, 252–256, 269–274, 279–284, 
289–294, 303–309, 373–376, 378–380, 
382–386, 423–424, 439–441 
 argument , 79, 197, 224, 557 
 arrays , 340–341, 424 
 data , 81, 157, 168, 332, 587 
 data type , 71, 583 
 declaration , 105, 187 
 default , 469, 557, 561, 564 
 division , 62–63, 80, 204 
 expression , 541, 544, 600 
 ﬁ elds , 156, 177 
 formats , 132, 134, 479, 482 
 kind parameter , 69 
 kind representation , 69 
 kind type numbers , 77 
 kind types , 68, 72, 77, 80 
 literal constant , 272 
 nearest , 214, 577 
 representation , 77, 89 
 signed , 495 
 type declarations , 68 
 type statement , 69 
 variable , 79, 174–175, 253, 267, 420, 
429, 600 
 Integer scalar , 564, 578 
 default , 563, 588 
 Intent , 193–194, 264–266, 270, 272–274, 
276, 279–280, 293, 354, 373–376, 
382–386, 388–391, 486–488, 490–492, 
500–503, 577 
 in , 187, 265–266 
 attribute , 261, 265, 268 
 inout , 191, 265–266, 279, 282, 374, 376, 
383, 385–386, 389, 500, 502, 563, 
576–577 
 out , 264–266 
 Interface , 36–37, 188, 261–262, 267–268, 
272–273, 282, 295–296, 328, 338–339, 
371–372, 379–385, 388–389, 416–418, 
542, 597–599 
 block , 339, 501, 542, 597–599 
 body , 542, 544, 597 
 explicit , 188, 195, 267, 296, 355, 364, 534 
 statement , 542 
 Internal ﬁ le , 168 
 Internal function(s) , 192, 195, 534 
 Internal procedure , 296, 542–543, 597–598 
 Internal subroutine , 270 
 Interoperability , 3, 37–38, 469–472 
 Interoperability with C , 38, 471 
 Intrinsic , 2–4, 35, 67–68, 79, 115–116, 
121–122, 179–183, 194–195, 252–253, 
370–371, 471, 500–501, 540–543, 
549–550, 599–600 
 assignment , 371, 388, 543 
 function(s) , 2, 35, 67–68, 72, 79, 122, 
124–125, 129, 179–183, 185, 194–195, 
232, 253, 262, 275, 285, 302, 345, 356, 
500–501, 545, 549–550, 561 
 module , 469, 471, 486, 554, 587 
 procedure , 116, 121, 296, 541, 543, 599 
 subroutine , 282, 540 
 types , 243, 471, 545, 564 
 I/O.  See Input and output (I/O) 
 IOR , 561, 567 
 Iostat , 173–176, 265, 300–301, 303–304, 
345–347, 568–569 
 Iostat= , 175 
 I/O statements , 48–49, 52 
 I/O status value , 568–569 
 IPARITY , 567 
 IS_CONTIGUOUS , 568 
 ISHFT , 568 
 ISHFTC , 568 
 IS_IOSTAT_END , 568–569 
 IS_IOSTAT_EOR , 569 
 ISO/IEC , 36–37, 39, 53, 396, 497, 583 
 ISO, intrinsic module , 554, 587 
 ISO TR , 479–480, 482, 484, 486, 488, 490, 
492, 494, 496 
 J 
 J3 , 5, 37–38, 40 
 Java , 2–3, 30, 33–34, 41, 244, 288, 328, 332, 
368, 376, 481, 497 
 K 
 Keyword , 28, 143, 173, 175, 296, 372, 388, 
499–501, 543, 573, 575, 604 
 argument , 499 
 and optional argument(s) , 499 
 KIND , 72, 488–489, 533, 550, 554, 564, 569, 
571, 583–584, 587, 590, 599 
 Kind numbers , 67–68, 70 
 Kind type parameter , 68, 70, 290, 361, 
470–471, 541, 543, 557, 561, 564, 566, 
569, 583–584, 589 
 Kind types , 57, 69–70, 72, 80, 181, 183, 234, 
361, 550–551, 565 

614
Index
 L 
 LAPACK , 6 
 LaTeX , 29 
 LBOUND , 569 
 Leap year , 204–205 
 L edit descriptor , 240 
 LEN , 206, 567, 570, 599 
 Length of character argument , 570 
 Length of string , 226–227 
 LEN_TRIM , 169, 223, 227, 570 
 LGE , 224, 227, 550, 570 
 LGT , 224, 228, 550, 570 
 Linked list(s) , 251, 299–303, 344–347, 365 
 LINPACK , 358 
 Linux , 4, 54–56, 418, 481, 518 
 Lisp , 2 
 List directed input , 163 
 List directed i/o , 143, 163 
 List directed output , 143 
 LLE , 224, 227, 550, 570 
 LLT , 224, 228, 550, 570–571 
 Local variables , 188, 194–195, 261, 266, 270, 
278–280, 502–503, 540 
 Local variables and the save attribute , 
261, 266 
 Location , 229, 564, 572–574 
 LOCK , 408–409, 458 
 LOG , 55, 181, 183, 232, 483, 571 
 LOG10 , 571 
 Logical expression(s) , 3, 127–128, 199, 
201–203, 207–208, 213, 237–238, 
600–601 
 Logical operators , 199, 202, 237, 239, 241 
 Logicals , 3, 68, 126–128, 172, 199, 201–203, 
207–208, 213, 237–241, 487–492, 
549–550, 554, 564–565, 571, 599–601 
 Logical variable , 240–241, 267 
 Logic programming , 29, 42 
 LOGO , 229 
 Loop , 2, 90–91, 95–97, 102–104, 107–111, 
120–121, 146–148, 199, 207, 209–211, 
302, 305, 429, 446, 448–449 
 Loop variable , 110, 213 
 Lower bound , 124, 211, 272, 545, 569 
 M 
 Mantissa , 70–71, 73, 80, 482, 484 
 Mask , 126, 128, 550, 552, 558–559, 564–565, 
567, 571–575, 578–580, 587, 590–591 
 Masked array assignment , 126 
 MASKL , 571 
 MASKR , 571–572 
 MATMUL , 116, 275, 285, 572 
 Matrix multiplication , 116, 274–275 
 MAX , 36, 555–556, 572 
 MAXEXPONENT , 572 
 MAXLOC , 35, 362, 550, 572–573, 575 
 MAXVAL , 362, 573–574 
 Memory , 85, 113, 128, 256, 265, 302, 344, 
353–355, 406, 541, 544, 587 
 MERGE , 574 
 MERGE_BITS , 574 
 Message passing interface (MPI) , 3, 410–412, 
415–426, 428, 430, 432, 434–436, 
438–444, 452, 455, 459, 463 
 implementations , 417–419, 444 
 programming , 417–418 
 MIN , 12, 36, 63, 71, 560, 574 
 MINEXPONENT , 574 
 MINLOC , 574 
 MINVAL , 575 
 Mixed mode arithmetic , 62 
 Mixed mode expressions , 232 
 MOD , 181, 183, 185–186, 191, 193, 197, 276, 
536, 575–576 
 Modula , 2 
 Modula 2 , 2 
 Modules , 188–196, 245–246, 267–268, 
270–274, 279–282, 287–290, 292–297, 
299–309, 353–357, 370–371, 373–376, 
378–380, 382–391, 500–503, 597–599 
 containing procedures , 267, 287, 288 
 for derived data types , 287, 292–293 
 for global data , 287–288 
 intrinsic , 469, 471, 486 
 for precision speciﬁ cation and constant 
deﬁ nition , 288–289 
 procedures , 261, 267–268, 289, 296, 328, 
338–339, 354, 371, 469, 501, 534, 
542–543 
 for Sharing arrays of Data , 290–291 
 usage and compilation , 295 
 MODULO , 576 
 Modulus , 183, 232, 234 
 MOLD , 563 
 Mold type , 563, 578 
 MOVE_ALLOC , 576 
 MPI.  See Message passing interface (MPI) 
 Multiple statements , 52 
 MVBITS , 576 
 N 
 NAN , 479, 482–483, 486, 489, 
491–493, 541 
 NEAREST , 490, 492, 577 
 Nested user deﬁ ned types , 247 

615
Index
 Nesting , 102 
 NETLIB , 414, 504, 514, 529 
 NINT , 577 
 Non advancing read , 174 
 Non executable statements , 541, 543, 545 
 NOPASS , 370 
 NORM2 , 577–578 
 NOT , 187, 202, 543, 578, 593 
 Nthreads , 447–453 
 Null , 35, 161–162, 164, 170, 175, 
252–256, 258, 300–301, 345, 470, 
476–477, 578 
 Nullify , 256, 300–301, 303–304, 307–308, 
346–347, 600 
 Nullify statement , 252, 302 
 Numeric models , 57, 557, 560, 565, 572, 574, 
580–581 
 Numeric representation , 57, 72 
 Numeric types , 81, 217, 572 
 NUM_IMAGES , 459–461, 463, 578, 590 
 O 
 Oberon , 2, 31, 43–44, 368, 396 
 Oberon 2 , 2, 31, 368 
 Oberon system , 43 
 Object , 3, 13, 24, 30–31, 33–34, 36–37, 310, 
367–370, 375–377, 381, 387–388, 395, 
446–447, 544–545, 582 
 coindexed , 554 
 current , 375–377 
 derived-type , 35, 543 
 ﬁ le , 268, 515, 540, 543, 604–605 
 polymorphic , 36, 369 
 Object oriented programming , 3, 13, 30–31, 
33, 43, 367–368, 370, 375–376, 379, 
381, 384, 395 
 Obsolescent , 532 
 Obsolescent features , 532 
 Octal , 84 
 ODEs.  See Ordinary differential equations 
(ODEs) 
 Omp parallel , 447–448, 450–452 
 Only , 11–12, 15–16, 43–44, 68–70, 137, 139, 
145, 149–150, 156, 174–176, 196–198, 
218–220, 295, 366–368, 370 
 OpenMP.  See Open multi-processing 
(OpenMP) 
 Openmpi , 419, 421 
 Open multi-processing (OpenMP) , 3, 410, 
412–413, 415–416, 426, 445–455, 459, 
463, 604 
 and coarray Fortran , 3, 415 
 directives in Fortran start , 448 
 programming , 445, 455 
 programming in Fortran , 445 
 Open statement , 141, 164, 169, 
172–173 
 Operating systems , 16, 25, 31, 37, 42, 44, 46, 
54, 56, 65, 141, 408, 415–416, 
480–481, 496 
 Operator and assignment overloading , 327 
 Operator hierarchy , 239 
 Operators , 3, 25, 35–36, 49, 58–60, 115, 199, 
202, 205, 219, 223, 237–239, 241, 
327, 491 
 logical , 199, 202, 237, 239, 241 
 Optional arguments , 499–501, 550, 573, 
575, 580 
 Optional attribute(s) , 500 
 Order of evaluation , 60 
 Order of statements , 52 
 Ordinary differential equations , 343, 348–349, 
351, 353–355, 500 
 system of , 348–349 
 Ordinary differential equations (ODEs) , 343, 
348–355, 498 
 Output , 2, 74–75, 96, 110–112, 132–133, 
136–139, 142–146, 148, 153–154, 
229–230, 239–240, 253–255, 258–259, 
421–422, 449–4451 
 formatted , 150–151 
 Output formats , 138, 154, 169–170 
 Output formatting , 112, 150 
 Output item list , 52, 600–601 
 Overﬂ ow , 66, 133, 136, 141, 254, 479, 482, 
485, 487, 603, 605 
 Overloading , 3, 327–328 
 P 
 Pack , 356, 578–579 
 Parallel , 285, 408–409, 446–452, 604 
 computing , 399, 406, 414–415 
 programming , 3, 397–398, 402, 
404, 406, 408–410, 412, 414–416, 
443, 459 
 solution , 415, 432–433, 435, 437–438, 
452–453 
 Parameter attribute , 57, 64, 94, 543 
 Parameterized derived types , 36 
 Parameters , 57, 63–64, 68–70, 93–95, 
102–105, 143, 153, 164–165, 173, 
187–188, 261–262, 265–273, 288–290, 
369–370, 375–376, 470–473, 487, 
490–491, 513, 543, 599–600 
 passing , 269 
 statement , 64, 80, 153, 540 

616
Index
 Parity , 579 
 Pascal , 2 
 Pass , 90, 370, 373, 375, 378–379, 382, 
384–385, 388–389, 391 
 Pass attribute , 375 
 Pass control , 209 
 Passed Object Dummy arguments , 370 
 PDTs , 36 
 PGAS , 409 
 Pi 
 calculation , 425, 427, 429, 431–433, 435, 
437, 452–453, 460–461 
 internal value of , 429, 434 
 PL/1 , 2, 24 
 Pointer(s) , 35–36, 251–256, 258–259, 296, 
299–304, 307–308, 344–345, 370, 
471–473, 476, 541, 543–545, 549–550, 
553, 598–601 
 allocation and assignment , 255 
 arrays address , 251 
 assignment , 36, 251, 253–254, 473 
 assignment statement , 252–253, 543 
 association , 541, 544–545 
 attribute , 251, 543 
 component , 301, 370, 473 
 disassociation , 252 
 initialisation , 252 
 name list , 599 
 undeﬁ ned , 252 
 variables , 252–253, 302, 476, 601 
 Polymorphic entity , 369 
 Polymorphism , 32, 36, 327, 372, 388, 391, 
393–395 
 Polymorphism and dynamic binding , 388–389, 
391, 393 
 POPCNT , 579 
 POPPAR , 579 
 Positional , 70, 501 
 Positional arguments , 499 
 Positional number systems , 57, 70, 84 
 Positive integers , 70–71, 135, 139, 
174, 189 
 Positive values , 126, 214, 258 
 Postscript , 29, 40 
 Precedence , 52, 59–60, 239, 241 
 Precedence of operators , 59, 239 
 Precision , 65–70, 72, 74, 81, 287–290, 
353–355, 361, 424, 426, 481–485, 493, 
500, 532–533, 549–550, 579–580 
 single , 484 
 working , 289–290 
 Precision speciﬁ cation , 288–289 
 Present , 42, 109, 129, 139, 144, 173–174, 
500–501, 553, 557–558, 562–564, 
567–569, 572–573, 578–580, 582–583, 
590–591 
 Print statement , 49, 51–52, 131–132, 143, 154 
 Private attribute , 294 
 Private statement , 309 
 Procedures 
 bound , 370, 374–375, 381, 384, 395 
 internal , 287, 296, 332, 542–543, 
597–598 
 intrinsic , 115, 185, 296, 501, 
541–543, 550 
 pointer component , 370 
 PRODUCT , 372, 560–1, 580, 582 
 Program execution , 251, 369, 372, 
539, 545 
 Programming languages , 1, 19–20, 22, 24–25, 
28, 30, 33, 39, 42–44, 46, 89, 231, 327, 
332, 367–368 
 Programming style , 226, 227, 229 
 Program statement , 49, 51–52, 543 
 Program unit , 94, 129, 187–188, 246, 
265–266, 287–288, 292, 294–296, 308, 
355, 501, 539, 541, 543–544 
 Prolog , 2, 29 
 Protected , 21, 287, 294, 377 
 Protected attribute , 294 
 PUBLIC attribute , 294, 370 
 Public attribute , 294 
 Public statement , 309 
 Pure functions , 35, 179, 193 
 Pure procedure , 194 
 PVM , 410, 414 
 R 
 Radix , 71–72, 493, 550, 580–581, 584 
 RANDOM_NUMBER , 283, 581 
 RANDOM_SEED 581 
 RANGE , 581 
 Range and precision of numbers , 68 
 Rank , 114–115, 120–126, 129, 270–273, 362, 
423–424, 539, 544, 552, 559–562, 
572–573, 575–576, 578–582, 586–587, 
589–590 
 Rank of array , 559, 562, 569, 573, 575, 580, 
586–587, 590 
 Rank of source , 424, 584, 586 
 Read , 48–52, 93–96, 102–104, 138–141, 
154–177, 204–206, 244–246, 272–274, 
279, 281–283, 291–294, 300–308, 
345–347, 353–354, 500–504 
 advance= , 300 
 fmt= , 172 
 iostat= , 175 

617
Index
 statement , 49, 51, 163, 174–175, 219, 
301, 533 
 unit= , 142 
 Reading , 2–3, 5, 7, 17, 40–44, 83–84, 141, 
155–158, 162–168, 170, 174–176, 240, 
299–303, 346–347, 396 
 Reading formatted ﬁ les , 165 
 Reading in data , 155–170 
 Reading unformatted ﬁ les , 167 
 Real(s) , 34, 50–51, 57, 60–74, 79–83, 
100–104, 106–109, 114–117, 134–135, 
137, 155–158, 170, 210–212, 217, 
231–235, 269–274, 276–277, 289–294, 
332, 353–357, 426–429, 460–462, 
487–492, 560–562, 581–587 
 constant , 69 
 function , 193, 210, 212, 276, 364, 427 
 kind type , 69 
 literal constant , 70 
 operators , 58 
 variable(s) , 62, 107, 141, 170, 297 
 Recursion , 22, 35, 188, 190–191, 198, 250, 
281–282, 544 
 Recursive , 17, 37, 179, 188–190, 196, 198, 
279, 281–282, 284–285, 307–308, 499, 
501–502, 504–505, 507, 598 
 functions , 17, 179, 188–189, 279 
 subroutines , 279 
 Referencing a subroutine , 265 
 Relational expression , 202 
 Relational operator , 202 
 Rename , 36, 599 
 Repeat , 47, 56, 81, 144–145, 154, 170, 197, 
199, 207–209, 212, 221, 228–229, 387, 
393, 581–582 
 Repeat until loop , 207 
 Repetition , 2, 99, 107–108, 110, 143–144, 
153, 208 
 Reshape , 122, 126, 129, 539, 582 
 Result clause , 196 
 Return statement , 195 
 Rewind , 155, 164, 169–170, 601 
 RKM.  See Runga Kutta Merson (RKM) 
 Rounding and truncation , 61–63 
 Rounding mode , 484, 486, 490, 492 
 RRSPACING , 582 
 Runga Kutta Merson (RKM) , 348 
 Runtime error , 255, 259 
 S 
 SAME_TYPE_AS , 582 
 Save attribute , 194, 261, 266 
 Scalar coarray , 554 
 Scalar integer variable , 174, 600 
 Scalar-numeric-expression , 110 
 Scalar variable , 2, 111, 471, 544 
 Scalar-variable-name , 110 
 SCALE , 25, 27, 44, 137, 148, 267, 295, 492, 
517, 583 
 SCAN , 583 
 Scope , 14, 22, 37, 147, 179, 188, 195, 261, 
266, 278, 296, 472, 542, 544 
 Scope of variables , 188, 266 
 Scoping unit , 540, 544–545, 597 
 Select case statement , 205 
 SELECTED_CHAR_KIND , 583 
 SELECTED_INT_KIND , 68–69, 73, 77, 
583–584 
 SELECTED_REAL_KIND , 68–70, 73, 234, 
289, 426, 488–489, 584 
 Select type , 36, 372, 393–394, 540 
 Semicolon , 52–53 
 Separator , 132 
 Sequential programs , 398, 447 
 SET_EXPONENT , 584 
 SHAPE , 379, 584 
 Shape of array , 573, 575 
 SHIFTA , 584 
 SHIFTL , 561, 571, 584–585 
 SHIFTR , 561, 585 
 SHIFT type , 584–585 
 SIGN , 35, 492, 585 
 Signiﬁ cant digits , 65–66, 69, 137, 158–159, 
297, 544, 560 
 Simula , 2 
 SIN , 99, 180–183, 232, 585 
 Sine function , 182, 331 
 Singly linked list , 299–303 
 SINH , 552 
 SIZE , 65–66, 93, 99–100, 113–114, 284, 
339–340, 355–356, 423–424, 439–441, 
556–557, 568–573, 579, 581–582, 
584–587, 589–590 
 Skipping spaces and lines , 162 
 Slash edit descriptor , 149–150 
 Smalltalk , 29, 31 
 Snobol , 23 
 Sorting , 17, 275–276, 285, 325, 
332, 366 
 Source ﬁ le traceback information , 605 
 SPACING , 586 
 Sparse matrix problems , 251, 343–345, 347 
 SPREAD , 29, 413, 586 
 SQL , 2, 27, 29, 41, 93 
 SQRT , 181, 193, 197, 235, 271, 276, 486, 
489, 587 
 Square bracket(s) , 53, 413 

618
Index
 Standardisation , 27, 36, 38, 497 
 Statement functions , 296, 534 
 Status= , 166, 173, 176, 265, 273, 345–347 
 Stepwise reﬁ nement , 13, 15, 17, 26 
 Stop statement , 176, 194, 458 
 STORAGE , 587 
 STORAGE_SIZE , 587 
 Stride , 124, 128, 544–545 
 String , 218–223, 226–229, 540, 545, 551, 567, 
570–571, 581, 583, 590–591 
 character expression , 567 
 Strong typing , 240 
 Structure constructor , 371, 376–381, 384, 
387, 544 
 Structured programming , 3, 17, 26, 199–200, 
215, 243, 249 
 Subcomponents , 249, 267, 544 
 Submodules , 37 
 Subobject , 543 
 Subprogram , 234, 266, 270, 287, 296, 472, 
539–544, 598 
 external , 542 
 Subrange types , 32 
 Subroutine(s) , 180, 194–195, 261–285, 
288–296, 308–309, 331–332, 354–356, 
358, 372–374, 376–377, 383–386, 
388–391, 426–427, 486–488, 500–504, 
540–544, 549, 598 
 actual argument , 265 
 dummy argment , 265 
 elemental , 282–283, 488, 549 
 generic , 331 
 impure , 549 
 internal , 278 
 local variable , 266 
 pure , 549 
 recursive , 281, 284, 308 
 scope of variable , 266 
 Subscripts , 114, 539, 544, 573 
 Substring , 220–221, 227, 447, 545, 567 
 Subtraction , 58, 60, 62–64, 84, 217, 
483, 541 
 Subtraction operator , 329 
 SUM , 560, 578, 587 
 Supplying your own functions , 185–187 
 Sync all , 458, 460–461, 463–464 
 Synchronisation , 409, 448 
 Sync images , 458 
 Sync memory , 458 
 SYSTEM_CLOCK , 587 
 System of ﬁ rst-order ordinary differential 
equations , 348–349, 351, 353, 355 
 Systems analysis , 9, 14, 17 
 Systems analysis and design , 1, 9, 13–15, 17 
 T 
 TAN , 180–181, 354, 425, 550, 588 
 TANH , 588 
 Target , 128, 251–254, 256, 258, 296, 308, 
471–473, 476, 541, 543–545, 549–550, 
553, 568, 599–601 
 attribute , 252–253, 473 
 statement , 543 
 Templates , 332, 339, 342 
 Terminology , 10–11, 113, 169, 187–188, 244, 
269, 368, 374–375, 381, 398, 419, 446, 
449, 451, 457–458 
 TeX , 29 
 Text ﬁ les , 171–172, 529 
 THIS_IMAGE , 459–461, 463, 588–589 
 Threads , 398, 408–409, 446–452 
 Three-dimensional spatial problems , 251 
 Timing , 191, 277–278, 281, 284, 426, 428, 
452, 460–461, 503–504 
 TINY , 72, 562, 589 
 Tolerance , 209–211, 214, 484 
 Tools , 12–13, 17, 177, 190, 224, 283, 287, 
414, 534, 537 
 Top-down , 1, 12, 15–16 
 Trailing blanks , 220, 223, 227–228, 570, 590 
 TRAILZ , 589 
 TRANSFER , 32, 36, 79, 173–174, 285, 406, 
419, 441, 446, 473, 476–477, 589 
 Transformational functions , 182–183, 
545, 549 
 TRANSPOSE , 589 
 Trees , 251 
 TRIM , 565, 570, 590 
 Triplet , 124, 128, 544–545 
 Truncation , 57, 61–62, 80, 220, 545, 551 
 Truth tables , 237–238, 241 
 Type , 47–51, 189–192, 243–247, 300–310, 
368–391, 393–394, 471–473, 486–488, 
490–491, 539–545, 554–557, 563–565, 
569–572, 574–577, 587–590 
 abstract data , 26–27, 366, 368 
 argument , 549–550 
 character data , 3, 218–219 
 complex , 327, 543 
 complex data , 3, 231–232, 234 
 conformance , 564 
 construct , 372, 394 
 conversion , 62, 64 
 declaration statement , 369, 540 
 default character , 53, 583 
 default ﬁ le , 177 
 extensions , 31, 44, 542 
 function return , 188 
 interoperable , 472–473 

619
Index
 logical , 550 
 logical data , 3, 202 
 parent , 542–543 
 pointer , 553 
 speciﬁ cation , 196, 598–599 
 statement , 64, 69, 80, 266, 393–394 
 supplying non-default character , 53 
 transfer functions , 32 
 Type-bound procedure , 36, 370, 540 
 Type declaration , 48, 51–52, 64, 69, 101, 
196, 245, 290, 369, 371, 375–377, 
540, 545, 597 
 real , 69–70, 290 
 Type deﬁ nition , 244, 288, 292, 301, 
370–371, 375, 381, 540, 542, 544, 
597–598 
 derived , 288, 381, 540, 544, 597–598 
 Type is , 3, 30, 36, 71, 188, 292, 309, 368–370, 
375, 383, 471, 550, 554 
 U 
 UBOUND , 590 
 UCOBOUND , 590 
 Undeﬁ ned pointer , 252 
 Underﬂ ow , 66, 136, 141, 254, 482–3, 
485–487, 545, 603–605 
 Unformatted ﬁ les , 151, 167, 175 
 Unit= , 142–143, 147, 150, 162–164, 166–167, 
172–173, 175–176, 208, 246, 265, 273, 
279–280, 283, 345–347, 502–503 
 Unit numbers , 141, 143, 155, 169, 173, 176 
 logical , 172 
 UNIX systems , 25, 96 
 Unlimited polymorphic , 563, 582 
 Unlock statement , 458 
 UNPACK , 590 
 Upper bound , 124, 211, 272, 545, 590 
 Use , 1–5, 9–11, 22–25, 77–81, 172–175, 
185–189, 191–198, 243–247, 267–268, 
270–279, 287–290, 292–295, 302–308, 
376–387, 531–534 
 Use association , 370, 545 
 Use, only , 295 
 User deﬁ ned functions , 179, 192, 
194–195, 262 
 User deﬁ ned types , 3, 243–244, 247, 327 
 nested , 247–248 
 Using modules , 292, 355 
 V 
 Value attribute , 296 
 Variable names , 49–50, 52, 163, 253, 541 
 invalid , 218 
 Variables , 48–52, 80, 168–170, 187–188, 
218–222, 237–239, 251–253, 265–266, 
278–280, 294–295, 371–373, 375–376, 
446–447, 471–473, 543–545 
 declarations , 129, 162, 434 
 derived-type , 372 
 polymorphic , 372, 381, 388, 390 
 Variable types , 231–232 
 complex , 240 
 mixing , 240 
 Variable values, actual , 188 
 Variance , 270–271, 276, 278 
 VERIFY , 190, 228, 591 
 Volatile , 36, 458 
 Volatile attribute , 36, 458 
 W 
 WG5 , 5, 37, 40, 43 
 Where construct , 600 
 Where statement , 113, 126–127 
 While loop , 207, 211, 302 
 Whole array , 113–118, 120, 122, 124–126, 
128, 130, 147, 441 
 Whole array manipulation , 115 
 Write statement , 148, 153, 163 
 X 
 X edit descriptor , 133–134, 138 
 X format , 162 
 X3J3 , 138 
 Z 
 Zero length string , 591 
 Zero sized array , 472, 573, 575 

