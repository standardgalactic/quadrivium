
MATHEMATICS FOR COMPUTER GRAPHICS

John Vince
Mathematics for
Computer Graphics
Second Edition
With 175 Illustrations

John Vince, MTech, PhD, DSc, FBCS, CEng
Media School,
University of Bournemouth, Talbot Campus, Fern Barrow, Poole BH12 5BB, UK
Library of Congress Control Number: 2005928172
ISBN-10: 1-84628-034-6
ISBN-13: 978-1-84628-034-4
ISBN 1-85233-380-4 1st edition
Printed on acid-free paper.
c⃝Springer-Verlag London Limited 2006
Apart from any fair dealing for the purposes of research or private study, or criticism or review, as per-
mitted under the Copyright, Designs and Patents Act 1988, this publication may only be reproduced,
stored or transmitted, in any form or by any means, with the prior permission in writing of the publish-
ers, or in the case of reprographic reproduction in accordance with the terms of licences issued by the
Copyright Licensing Agency. Enquiries concerning reproduction outside those terms should be sent to
the publishers.
The use of registered names, trademarks, etc. in this publication does not imply, even in the absence of
a speciﬁc statement, that such names are exempt from the relevant laws and regulations and therefore
free for general use.
The publisher makes no representation, express or implied, with regard to the accuracy of the infor-
mation contained in this book and cannot accept any legal repsonsibility or liability for any errors or
omissions that may be made.
Printed in the United States of America.
(SPI/MVY)
9 8 7 6 5 4 3 2 1
Springer Science+Business Media
springeronline.com

Dedication
I dedicate this book to my wife Annie, who has had to tolerate a year of me
reading math books in bed, on planes, boats, trains, in hotels, in the garden,
in the bath, on holiday, and probably in my sleep!

Contents
Preface
xiii
1
Mathematics
1
1.1
Is Mathematics Diﬃcult? . . . . . . . . . . . . . . . . . . . . .
2
1.2
Who should Read this Book? . . . . . . . . . . . . . . . . . . .
2
1.3
Aims and Objectives of this Book . . . . . . . . . . . . . . . .
3
1.4
Assumptions Made in this Book . . . . . . . . . . . . . . . . .
3
1.5
How to Use the Book . . . . . . . . . . . . . . . . . . . . . . .
3
2
Numbers
5
2.1
Natural Numbers
. . . . . . . . . . . . . . . . . . . . . . . . .
5
2.2
Prime Numbers . . . . . . . . . . . . . . . . . . . . . . . . . .
6
2.3
Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
2.4
Rational Numbers . . . . . . . . . . . . . . . . . . . . . . . . .
6
2.5
Irrational Numbers
. . . . . . . . . . . . . . . . . . . . . . . .
6
2.6
Real Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
2.7
The Number Line . . . . . . . . . . . . . . . . . . . . . . . . .
7
2.8
Complex Numbers . . . . . . . . . . . . . . . . . . . . . . . . .
7
2.9
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3
Algebra
11
3.1
Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
3.2
Algebraic Laws
. . . . . . . . . . . . . . . . . . . . . . . . . .
12
3.2.1
Associative Law . . . . . . . . . . . . . . . . . . . . . .
12
3.2.2
Commutative Law . . . . . . . . . . . . . . . . . . . . .
13
3.2.3
Distributive Law
. . . . . . . . . . . . . . . . . . . . .
13
3.3
Solving the Roots of a Quadratic Equation . . . . . . . . . . .
14

viii
Mathematics for Computer Graphics
3.4
Indices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
3.4.1
Laws of Indices
. . . . . . . . . . . . . . . . . . . . . .
15
3.4.2
Examples . . . . . . . . . . . . . . . . . . . . . . . . . .
15
3.5
Logarithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
3.6
Further Notation
. . . . . . . . . . . . . . . . . . . . . . . . .
16
3.7
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
4
Trigonometry
17
4.1
The Trigonometric Ratios
. . . . . . . . . . . . . . . . . . . .
18
4.2
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
4.3
Inverse Trigonometric Ratios . . . . . . . . . . . . . . . . . . .
19
4.4
Trigonometric Relationships . . . . . . . . . . . . . . . . . . .
19
4.5
The Sine Rule . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
4.6
The Cosine Rule . . . . . . . . . . . . . . . . . . . . . . . . . .
20
4.7
Compound Angles . . . . . . . . . . . . . . . . . . . . . . . . .
20
4.8
Perimeter Relationships . . . . . . . . . . . . . . . . . . . . . .
21
4.9
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
5
Cartesian Coordinates
23
5.1
The Cartesian xy-plane . . . . . . . . . . . . . . . . . . . . . .
23
5.1.1
Function Graphs
. . . . . . . . . . . . . . . . . . . . .
24
5.1.2
Geometric Shapes . . . . . . . . . . . . . . . . . . . . .
25
5.1.3
Polygonal Shapes . . . . . . . . . . . . . . . . . . . . .
25
5.1.4
Areas of Shapes . . . . . . . . . . . . . . . . . . . . . .
26
5.1.5
Theorem of Pythagoras in 2D . . . . . . . . . . . . . .
27
5.2
3D Coordinates
. . . . . . . . . . . . . . . . . . . . . . . . . .
28
5.2.1
Theorem of Pythagoras in 3D . . . . . . . . . . . . . .
28
5.2.2
3D Polygons . . . . . . . . . . . . . . . . . . . . . . . .
28
5.2.3
Euler’s Rule . . . . . . . . . . . . . . . . . . . . . . . .
29
5.3
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
6
Vectors
31
6.1
2D Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
6.1.1
Vector Notation . . . . . . . . . . . . . . . . . . . . . .
32
6.1.2
Graphical Representation of Vectors . . . . . . . . . . .
32
6.1.3
Magnitude of a Vector
. . . . . . . . . . . . . . . . . .
34
6.2
3D Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
6.2.1
Vector Manipulation
. . . . . . . . . . . . . . . . . . .
35
6.2.2
Multiplying a Vector by a Scalar
. . . . . . . . . . . .
36
6.2.3
Vector Addition and Subtraction
. . . . . . . . . . . .
36
6.2.4
Position Vectors . . . . . . . . . . . . . . . . . . . . . .
37
6.2.5
Unit Vectors . . . . . . . . . . . . . . . . . . . . . . . .
37
6.2.6
Cartesian Vectors . . . . . . . . . . . . . . . . . . . . .
38
6.2.7
Vector Multiplication . . . . . . . . . . . . . . . . . . .
39
6.2.8
Scalar Product . . . . . . . . . . . . . . . . . . . . . . .
40

Contents
ix
6.2.9
Example of the Dot Product
. . . . . . . . . . . . . .
41
6.2.10
The Dot Product in Lighting Calculations . . . . . . .
42
6.2.11
The Dot Product in Back-Face Detection . . . . . . .
43
6.2.12
The Vector Product . . . . . . . . . . . . . . . . . . .
44
6.2.13
The Right-Hand Rule . . . . . . . . . . . . . . . . . .
47
6.3
Deriving a Unit Normal Vector for a Triangle
. . . . . . . . .
47
6.4
Areas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
6.4.1
Calculating 2D Areas
. . . . . . . . . . . . . . . . . .
48
6.5
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
7
Transformation
51
7.1
2D Transformations . . . . . . . . . . . . . . . . . . . . . . . .
51
7.1.1
Translation . . . . . . . . . . . . . . . . . . . . . . . .
51
7.1.2
Scaling
. . . . . . . . . . . . . . . . . . . . . . . . . .
51
7.1.3
Reﬂection . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.2
Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7.2.1
Systems of Notation . . . . . . . . . . . . . . . . . . .
56
7.2.2
The Determinant of a Matrix . . . . . . . . . . . . . .
56
7.3
Homogeneous Coordinates . . . . . . . . . . . . . . . . . . . .
57
7.3.1
2D Translation . . . . . . . . . . . . . . . . . . . . . .
58
7.3.2
2D Scaling
. . . . . . . . . . . . . . . . . . . . . . . .
58
7.3.3
2D Reﬂections . . . . . . . . . . . . . . . . . . . . . .
59
7.3.4
2D Shearing
. . . . . . . . . . . . . . . . . . . . . . .
61
7.3.5
2D Rotation
. . . . . . . . . . . . . . . . . . . . . . .
62
7.3.6
2D Scaling
. . . . . . . . . . . . . . . . . . . . . . . .
64
7.3.7
2D Reﬂections . . . . . . . . . . . . . . . . . . . . . .
65
7.3.8
2D Rotation about an Arbitrary Point . . . . . . . . .
65
7.4
3D Transformations . . . . . . . . . . . . . . . . . . . . . . . .
66
7.4.1
3D Translation . . . . . . . . . . . . . . . . . . . . . .
66
7.4.2
3D Scaling
. . . . . . . . . . . . . . . . . . . . . . . .
66
7.4.3
3D Rotations . . . . . . . . . . . . . . . . . . . . . . .
67
7.4.4
Gimbal Lock . . . . . . . . . . . . . . . . . . . . . . .
70
7.4.5
Rotating about an Axis . . . . . . . . . . . . . . . . .
72
7.4.6
3D Reﬂections . . . . . . . . . . . . . . . . . . . . . .
73
7.5
Change of Axes . . . . . . . . . . . . . . . . . . . . . . . . . .
73
7.5.1
2D Change of Axes
. . . . . . . . . . . . . . . . . . .
74
7.6
Direction Cosines . . . . . . . . . . . . . . . . . . . . . . . . .
75
7.6.1
Positioning the Virtual Camera . . . . . . . . . . . . .
77
7.6.2
Direction Cosines
. . . . . . . . . . . . . . . . . . . .
77
7.6.3
Euler Angles . . . . . . . . . . . . . . . . . . . . . . .
79
7.7
Rotating a Point about an Arbitrary Axis
. . . . . . . . . . .
83
7.7.1
Quaternions
. . . . . . . . . . . . . . . . . . . . . . .
90
7.7.2
Adding and Subtracting Quaternions
. . . . . . . . .
91
7.7.3
Multiplying Quaternions
. . . . . . . . . . . . . . . .
91
7.7.4
The Inverse Quaternion . . . . . . . . . . . . . . . . .
91

x
Mathematics for Computer Graphics
7.7.5
Rotating Points about an Axis
. . . . . . . . . . . .
92
7.7.6
Roll, Pitch and Yaw Quaternions . . . . . . . . . . .
95
7.7.7
Quaternions in Matrix Form . . . . . . . . . . . . . .
96
7.7.8
Frames of Reference
. . . . . . . . . . . . . . . . . .
98
7.8
Transforming Vectors
. . . . . . . . . . . . . . . . . . . . . .
98
7.9
Determinants . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
7.10
Perspective Projection . . . . . . . . . . . . . . . . . . . . . . 103
7.11
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
8
Interpolation
107
8.1
Linear Interpolant . . . . . . . . . . . . . . . . . . . . . . . . 107
8.2
Non-Linear Interpolation
. . . . . . . . . . . . . . . . . . . . 110
8.2.1
Trigonometric Interpolation . . . . . . . . . . . . . . 110
8.2.2
Cubic Interpolation . . . . . . . . . . . . . . . . . . . 111
8.3
Interpolating Vectors
. . . . . . . . . . . . . . . . . . . . . . 116
8.4
Interpolating Quaternions . . . . . . . . . . . . . . . . . . . . 119
8.5
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
9
Curves and Patches
123
9.1
The Circle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
9.2
The Ellipse . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
9.3
B´ezier Curves . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
9.3.1
Bernstein Polynomials . . . . . . . . . . . . . . . . . 125
9.3.2
Quadratic B´ezier Curves . . . . . . . . . . . . . . . . 129
9.3.3
Cubic Bernstein Polynomials
. . . . . . . . . . . . . 130
9.4
A recursive B´ezier Formula . . . . . . . . . . . . . . . . . . . 133
9.5
B´ezier Curves Using Matrices . . . . . . . . . . . . . . . . . . 133
9.5.1
Linear Interpolation
. . . . . . . . . . . . . . . . . . 134
9.6
B-Splines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
9.6.1
Uniform B-Splines
. . . . . . . . . . . . . . . . . . . 137
9.6.2
Continuity . . . . . . . . . . . . . . . . . . . . . . . . 139
9.6.3
Non-Uniform B-Splines . . . . . . . . . . . . . . . . . 140
9.6.4
Non-Uniform Rational B-Splines
. . . . . . . . . . . 141
9.7
Surface Patches . . . . . . . . . . . . . . . . . . . . . . . . . . 141
9.7.1
Planar Surface Patch . . . . . . . . . . . . . . . . . . 141
9.7.2
Quadratic B´ezier Surface Patch . . . . . . . . . . . . 142
9.7.3
Cubic B´ezier Surface Patch
. . . . . . . . . . . . . . 144
9.8
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
10
Analytic Geometry
147
10.1
Review of Geometry . . . . . . . . . . . . . . . . . . . . . . . 147
10.1.1
Angles . . . . . . . . . . . . . . . . . . . . . . . . . . 148
10.1.2
Intercept Theorems . . . . . . . . . . . . . . . . . . . 148
10.1.3
Golden Section . . . . . . . . . . . . . . . . . . . . . 149
10.1.4
Triangles . . . . . . . . . . . . . . . . . . . . . . . . . 149

Contents
xi
10.1.5
Centre of Gravity of a Triangle . . . . . . . . . . . . 150
10.1.6
Isosceles Triangle
. . . . . . . . . . . . . . . . . . . 150
10.1.7
Equilateral Triangle . . . . . . . . . . . . . . . . . . 151
10.1.8
Right Triangle . . . . . . . . . . . . . . . . . . . . . 151
10.1.9
Theorem of Thales . . . . . . . . . . . . . . . . . . . 152
10.1.10
Theorem of Pythagoras . . . . . . . . . . . . . . . . 152
10.1.11
Quadrilaterals . . . . . . . . . . . . . . . . . . . . . 152
10.1.12
Trapezoid . . . . . . . . . . . . . . . . . . . . . . . . 153
10.1.13
Parallelogram
. . . . . . . . . . . . . . . . . . . . . 153
10.1.14
Rhombus . . . . . . . . . . . . . . . . . . . . . . . . 153
10.1.15
Regular Polygon (n-gon) . . . . . . . . . . . . . . . 154
10.1.16
Circle . . . . . . . . . . . . . . . . . . . . . . . . . . 154
10.2
2D Analytical Geometry . . . . . . . . . . . . . . . . . . . . . 156
10.2.1
Equation of a Straight Line . . . . . . . . . . . . . . 156
10.2.2
The Hessian Normal Form
. . . . . . . . . . . . . . 158
10.2.3
Space Partitioning . . . . . . . . . . . . . . . . . . . 159
10.2.4
The Hessian Normal Form from Two Points
. . . . 160
10.3
Intersection Points . . . . . . . . . . . . . . . . . . . . . . . . 161
10.3.1
Intersection Point of Two Straight Lines
. . . . . . 161
10.3.2
Intersection Point of Two Line Segments . . . . . . 161
10.4
Point Inside a Triangle . . . . . . . . . . . . . . . . . . . . . . 164
10.4.1
Area of a Triangle . . . . . . . . . . . . . . . . . . . 164
10.4.2
Hessian Normal Form . . . . . . . . . . . . . . . . . 165
10.5
Intersection of a Circle with a Straight Line . . . . . . . . . . 168
10.6
3D Geometry . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
10.6.1
Equation of a Straight Line . . . . . . . . . . . . . . 170
10.6.2
Point of Intersection of Two Straight Lines . . . . . 171
10.7
Equation of a Plane . . . . . . . . . . . . . . . . . . . . . . . 173
10.7.1
Cartesian Form of the Plane Equation . . . . . . . . 174
10.7.2
General Form of the Plane Equation . . . . . . . . . 176
10.7.3
Parametric Form of the Plane Equation . . . . . . . 176
10.7.4
Converting From the Parametric to the General
Form . . . . . . . . . . . . . . . . . . . . . . . . . . 177
10.7.5
Plane Equation from Three Points . . . . . . . . . . 179
10.8
Intersecting Planes . . . . . . . . . . . . . . . . . . . . . . . . 181
10.8.1
Intersection of Three Planes
. . . . . . . . . . . . . 184
10.8.2
Angle between Two Planes . . . . . . . . . . . . . . 186
10.8.3
Angle between a Line and a Plane . . . . . . . . . . 187
10.8.4
Intersection of a Line with a Plane . . . . . . . . . . 189
10.9
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
11
Barycentric Coordinates
193
11.1
Ceva’s Theorem
. . . . . . . . . . . . . . . . . . . . . . . . . 193
11.2
Ratios and Proportion . . . . . . . . . . . . . . . . . . . . . . 195
11.3
Mass Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196

xii
Mathematics for Computer Graphics
11.4
Linear Interpolation
. . . . . . . . . . . . . . . . . . . . . . 202
11.5
Convex Hull Property
. . . . . . . . . . . . . . . . . . . . . 208
11.6
Areas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
11.7
Volumes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
11.8
B´ezier Curves and Patches . . . . . . . . . . . . . . . . . . . 220
11.9
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
12
Worked Examples
223
12.1
Calculate the Area of Regular Polygon . . . . . . . . . . . . 223
12.2
Calculate the Area of any Polygon
. . . . . . . . . . . . . . 224
12.3
Calculate the Dihedral Angle of a Dodecahedron
. . . . . . 224
12.4
Vector Normal to a Triangle . . . . . . . . . . . . . . . . . . 226
12.5
Area of a Triangle using Vectors . . . . . . . . . . . . . . . . 227
12.6
General Form of the Line Equation from Two Points . . . . 227
12.7
Calculate the Angle between Two Straight Lines
. . . . . . 228
12.8
Test If Three Points Lie on a Straight Line . . . . . . . . . . 229
12.9
Find the Position and Distance of the Nearest Point on a
Line to a Point
. . . . . . . . . . . . . . . . . . . . . . . . . 230
12.10
Position of a Point Reﬂected in a Line . . . . . . . . . . . . 232
12.11
Calculate the Intersection of a Line and a Sphere . . . . . . 234
12.12
Calculate If a Sphere Touches a Plane
. . . . . . . . . . . . 238
12.13
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
13
Conclusion
241
References
243
Index
245

Preface
Mathematics is a beautiful subject. Its symbols, notation and abstract struc-
tures permit us to deﬁne, manipulate and resolve extremely complex problems.
The symbols by themselves, however, are meaningless – they are nothing more
than a calligraphic representation of a mental idea. If one does not understand
such symbols, then the encoded idea remains a secret.
Having spent most of my life using mathematics, I am still conscious of the
fact that I do not understand much of the notation used by mathematicians.
And even when I feel that I understand a type of notation, I still ask myself
“Do I really understand its meaning?”. For instance, I originally studied to
be an electrical engineer and was very familiar with i = √−1, especially when
used to represent out of phase voltages and currents. I can manipulate complex
numbers with some conﬁdence, but I must admit that I do not understand the
meaning of ii. This hole in my knowledge makes me feel uncomfortable, but
I suppose it is reassuring to learn that some of our greatest mathematicians
have had problems understanding some of their own inventions.
Some people working in computer graphics have had a rigorous grounding
in mathematics and can exploit its power to solve their problems. However, in
my experience, the majority of people have had to pick up their mathematical
skills on an ad hoc basis depending on the problem at hand. They probably
had no intention of being mathematicians, nevertheless they still need to learn
about the mathematics and apply it intelligently, which is where this book
comes in.
To begin with, this book is not for mathematicians. They would proba-
bly raise their hands in horror about the lack of mathematical rigour I have
employed, or probably not employed! This book is for people working in
computer graphics who know that they have to use mathematics in their

xiv
Mathematics for Computer Graphics
day-to-day work, and don’t want to get too embroiled in axioms, truths and
Platonic realities.
The book originally appeared as part of Springer’s excellent “Essential”
series, and this new revised edition includes an extended chapter on Analyt-
ical Geometry and extra chapters on Barycentric Coordinates and Worked
Examples. The chapter on Barycentric Coordinates forced me to return to
one of my favourite books A vector Space Approach to Geometry by Melvin
Hausner. This contains a wonderful explanation of balancing masses and how
the results lead to barycentric coordinates. It also illustrates how area and vol-
ume are a natural feature of vectors. The chapter on Worked Examples draws
upon some material from my recent book Geometry for Computer Graphics.
Whilst writing this book I have borne in mind what it was like for me when
I was studying diﬀerent areas of mathematics for the ﬁrst time. In spite of
reading and rereading an explanation several times it could take days before
“the penny dropped” and a concept became apparent. Hopefully, the reader
will ﬁnd the following explanations useful in developing their understanding
of these speciﬁc areas of mathematics.
John Vince
Ringwood

1
Mathematics
When I was taught mathematics at junior school in the late 1950s, there
were no computers or calculators. Calculations, whether they were addition,
subtraction, multiplication, division or square roots, had to be worked out in
one’s head or with pencil and paper. We learnt our ‘times tables’ by reciting
them over and over again until we could give the product of any pair of
numbers up to 12 – numbers higher than 12 were computed long hand.
I was fortunate in having a teacher who appreciated the importance of
mathematics, and without knowing it at the time, I began a journey into a
subject area that would eventually bring my knowledge of mathematics to life
in computer graphics.
Today, students have access to calculators that are virtually miniature
computers. They are programmable and can even display graphs on small LCD
screens. Unfortunately, the policy pursued by some schools has ensured that
generations of children are unable to compute simple arithmetic operations
without the aid of a calculator. I believe that such children have been disadvan-
taged, as they are unable to visualize the various patterns that exist in num-
bers such as odd numbers (1, 3, 5, 7, . . .), even numbers (2, 4, 6, 8, . . .), prime
numbers (2, 3, 5, 7, 11, . . .), squares (1, 4, 9, 16, 25, . . .) and Fibonacci numbers
(0, 1, 1, 2, 3, 5, 8, . . .). They will not know that it is possible to multiply a two-
digit number, such as 17, by 11, simply by adding 1 to 7 and placing the result
in the middle to make 187.
Although I do appreciate the beneﬁts of calculators, I believe that they
are introduced into the curriculum far too early. Children should be given the
opportunity to develop a sense of number, and the possibility of developing a
love for mathematics, before they discover the tempting features of a digital
calculator.

2
Mathematics for Computer Graphics
‘I am no good at mathematics’ is a common response from most people
when asked about their mathematical abilities. Some suggest that their brain
is unable to cope with numbers, some claim that it’s boring, and others put it
down to inadequate teaching. Personally, I am not very good at mathematics,
but I delight in reading books about mathematicians and the history of math-
ematics, and applying mathematics to solve problems in computer graphics.
I am easily baﬄed by pages of abstract mathematical symbols, but readily
understand the application of mathematics in a practical context.
It was only when I started programming computers to produce drawings
and pictures that I really appreciated the usefulness of mathematics. Multi-
plication became synonymous with scaling; division created perspective; sines
and cosines rotated objects; tangents produced shearing, and geometry and
trigonometry provided the analytical tools to solve all sorts of other problems.
Such a toolkit is readily understood and remembered.
1.1 Is Mathematics Difﬁcult?
‘Is mathematics diﬃcult?’ I suppose that there is no real answer to this ques-
tion, because it all depends upon what we mean by ‘mathematics’ and ‘diﬃ-
cult’. But if the question is rephrased slightly: ‘Is the mathematics of computer
graphics diﬃcult?’ then the answer is a deﬁnite no. What’s more, I believe
that the subject of computer graphics can instill in someone a love for math-
ematics. Perhaps ‘love’ is too strong a word, but I am convinced that it is
possible to ‘make friends’ with mathematics.
For me, mathematics should be treated like a foreign language: You only
need to learn an appropriate vocabulary to survive while visiting another
country. If you attempt to memorize an extended vocabulary, and do not
put it into practice, it is highly likely that you will forget it. Mathematics is
the same. I know that if I attempted to memorize some obscure branch of
mathematics, such as vector calculus, I would forget it within days if I did
not put it to some practical use.
Fortunately, the mathematics needed for computer graphics is reasonably
simple and covers only a few branches such as algebra, trigonometry, vectors,
geometry, transforms, interpolation, curves and patches. Although these topics
do have an advanced side to them, in most applications we only need to explore
their intermediate levels.
1.2 Who should Read this Book?
I have written this book as a reference for anyone intending to study topics
such as computer graphics, computer animation, computer games or virtual
reality, especially for people who want to understand the technical aspects.

1 Mathematics
3
Although it is possible to study these topics without requiring the support
of mathematics, increasingly, there are situations and projects that require
animators, programmers and technical directors to resort to mathematics to
resolve unforeseen technical problems. This may be in the form of a script or
an extra piece of program code.
1.3 Aims and Objectives of this Book
One of the aims of this book is to bring together a range of useful mathematical
topics that are relevant to computer graphics. And the real objective is to
provide programmers and animators with an understanding of mathematics
so that they can solve all sorts of problems with conﬁdence.
I have attempted to do this by exploring a range of mathematical top-
ics, without intimidating the reader with mathematical symbols and abstract
ideas. Hopefully, I will be able to explain each topic in a simple and practical
manner, with a variety of practical examples.
This is far from being an exhaustive study of the mathematics associated
with computer graphics. Each chapter introduces the reader to a new topic,
and should leave the reader conﬁdent and capable of studying more advanced
books.
1.4 Assumptions Made in this Book
I suppose that I do expect that readers will have some understanding of arith-
metic and a general knowledge of the principles of mathematics, such as the
ideas of algebra. But, apart from that, each subject will be introduced as
though it were the ﬁrst time it had been discovered.
In the chapter on curves and surfaces I have used a little calculus. Readers
who have not studied this subject should not be concerned about missing
some vital piece of information. I only included it to keep the explanation
complete.
1.5 How to Use the Book
I would advise starting at the beginning and proceeding chapter by chapter.
Where a subject seems familiar, just jump ahead until a challenge is discov-
ered. Once you have read the book, keep it handy so that you can refer to it
when the occasion arises.
Although I have tried to maintain a sequence to the mathematical ideas,
so that one idea leads to another, in some cases this has proved impossible.
For example, determinants are referred to in the chapter on vectors, but they

4
Mathematics for Computer Graphics
are described in detail in the next chapter on transforms. Similarly, the later
chapter on analytic geometry contains some basic ideas of geometry, but its
position was dictated by its use of vectors. Consequently, on some occasions,
the reader will have to move between chapters to read about related topics.

2
Numbers
All sorts of number system have been proposed by previous civilizations, but
our current system is a positional number system using a base 10. The number
1234 really means the sum of one thousand, plus two hundreds, plus three tens,
plus four ones, which can be expressed as 1×1000+2×100+3×10+4×1. It
should be obvious that the base 10 is nothing special, it just so happens that
human beings have evolved with 10 digits, which we use for counting. This
suggests that any number can be used as a base: 2, 3, 4, 5, 6, 7, etc. In fact,
the decimal number system is not very convenient for computer technology,
where electronic circuits switch on and oﬀbillions of times a second using
binary numbers – numbers to a base 2 – with great ease. In this text there is
no real need to explore such numbers. This can be left to programmers who
have to master number systems such as binary (base 2), octal (base 8) and
hexadecimal (base 16).
The only features of numbers we have to revise in this chapter are the
families of numbers that exist, what they are used for, and any problems
that arise when they are stored in a computer. Let’s begin with the natural
numbers.
2.1 Natural Numbers
The natural numbers {0, 1, 2, 3, 4, . . .} are used for counting, ordering and
labelling. Note that negative numbers are not included. We often use natural
numbers to subscript a quantity to distinguish one element from another, e.g.
x1, x2, x3, x4, . . .

6
Mathematics for Computer Graphics
2.2 Prime Numbers
A natural number that can be divided only by 1 and itself, without leaving
a remainder, is called a prime number. Examples are {2, 3, 5, 7, 11, 13, 17}.
There are 25 primes less than 100, 168 primes less than 1000 and 455 052 512
primes less than 10 000 000 000. The fundamental theory of arithmetic states,
‘Any positive integer (other than 1) can be written as the product of prime
numbers in one and only one way.’ For example, 25 = 5 × 5; 26 = 2 × 13; 27 =
3×3×3; 28 = 2×2×7; 29 = 29; 30 = 2×3×5 and 92 365 = 5×7×7×13×29.
In 1742 Christian Goldbach conjectured that every even integer greater
than 2 could be written as the sum of two primes:
4 = 2 + 2
14 = 11 + 3
18 = 11 + 7, etc.
No one has ever found an exception to this conjecture, and no one has ever
proved it.
Although prime numbers are enigmatic and have taxed the brains of
the greatest mathematicians, unfortunately they play no part in computer
graphics!
2.3 Integers
Integers include negative numbers, as follows: {. . .−3, −2, −1, 0, 1, 2, 3, 4, . . .}.
2.4 Rational Numbers
Rational or fractional numbers are numbers that can be represented as a
fraction. For example, 2,
√
16, 0.25 are rational numbers because
2 = 4
2,
√
16 = 4 = 8
2,
0.25 = 1
4
Some rational numbers can be stored accurately inside a computer,
but many others can only be stored approximately. For example, 4/3 =
1.333 333 . . . produces an inﬁnite sequence of threes and has to be truncated
when stored as a binary number.
2.5 Irrational Numbers
Irrational numbers cannot be represented as fractions. Examples are
√
2 =
1.414 213 562 . . . , π = 3.141 592 65 . . . and e = 2.718 281 828 . . . Such numbers

2 Numbers
7
−3
−2
−1
0
1
2
3
Fig. 2.1. The number line.
never terminate and are always subject to a small error when stored within a
computer.
2.6 Real Numbers
Rational and irrational numbers together comprise the real numbers.
2.7 The Number Line
It is convenient to organize numbers in the form of an axis to give them a
spatial signiﬁcance. Figure 2.1 shows such a number line, which forms an axis
as used in graphs and coordinate systems. The number line also helps us
understand complex numbers, which are the ‘king’ of all numbers.
2.8 Complex Numbers
Leonhard Euler (1707–1783) (whose name rhymes with boiler) played a sig-
niﬁcant role in putting complex numbers on the map. His ideas on rotations
are also used in computer graphics to locate objects and virtual cameras in
space, as we shall see later on.
Complex numbers resolve some awkward problems that arise when we
attempt to solve certain types of equations. For example, x2 −4 = 0 has
solutions x = ±2. But x2+4 = 0 has no obvious solutions using real or integer
numbers. However, the number line provides a graphical interpretation for a
new type of number, the complex number. The name is rather misleading: it
is not complex, it is rather simple.
Consider the scenario depicted in Figure 2.2. Any number on the number
line is related to the same number with the opposite sign via an anti-clockwise
rotation of 180◦. For example, if 3 is rotated 180◦about zero it becomes −3,
and if −2 is rotated 180◦about zero it becomes 2.
We can now write −3 = (−1)×3, or 2 = (−1)×−2, where −1 is eﬀectively
a rotation through 180◦. But a rotation of 180◦can be interpreted as two
consecutive rotations of 90◦, and the question now arises: What does a rotation
of 90◦signify? Well, let’s assume that we don’t know what the answer is going
to be – even though some of you do – we can at least give a name to the
operation, and what better name to use than i.

8
Mathematics for Computer Graphics
−4
−1
0
1
2
3
4
−3
−2
Fig. 2.2. Rotating numbers through 180◦reverses their sign.
So the letter i represents an anticlockwise rotation of 90◦. Therefore i2 is
equivalent to lifting 2 out of the number line, rotating it 90◦and leaving it
hanging in limbo. But if we take this ‘imaginary’ number and subject it to a
further 90◦rotation, i.e. ii2, it becomes −2. Therefore, we can write ii2 = −2,
which means that ii = −1. But if this is so, i = √−1!
This gives rise to two types of number: real numbers and complex num-
bers. Real numbers are the everyday numbers we use for counting and so on,
whereas complex numbers have a mixture of real and imaginary components,
and help resolve a wide range of mathematical problems.
Figure 2.3 shows how complex numbers are represented: the horizontal
number line represents the real component, and the vertical number line rep-
resents the imaginary component.
For example, the complex number P(1 + i2) in Figure 2.3 can be rotated
90◦to Q by multiplying it by i. However, we must remember that ii = −1:
i(1 + i2) = i1 + ii2
= i1 −2
= −2 + i1
Q(−2 + i1) can be rotated another 90◦to R by multiplying it by i:
i(−2 + i1) = i(−2) + ii1
= −i2 −1
= −1 −i2
R(−1 −i2) in turn, can be rotated 90◦to S by multiplying it by i:
i(−1 −i2) = i(−1) −ii2
= −i1 + 2
= 2 −i1

2 Numbers
9
imaginary
component
P(1 + i2)
Q(−2 + i1)
S(2− i1)
R(−1 − i2)
−2
−1
1
2
i2
i1
−i1
−i2
real
component
Fig. 2.3. The graphical representation of complex numbers.
Finally, S(2 −i1) can be rotated 90◦to P by multiplying it by i:
i(2 −i1) = i2 −ii1
= i2 + 1
= 1 + i2
Although we rarely use complex numbers in computer graphics, we can
see that they are intimately related to Cartesian coordinates, and that the
ordered pair (x, y) ≡x + iy.
Before concluding this chapter, I cannot fail to include the famous equation
discovered by Euler:
eiπ + 1 = 0
(2.1)
which integrates 0, 1, e, π and i in a simple and beautiful arrangement, and
is on a par with Einstein’s e = mc2.
2.9 Summary
This short chapter made sure that the terminology of numbers was under-
stood, and now provides a good link into the basics of algebra.

3
Algebra
This chapter reviews the basic elements of algebra to prepare the reader for
the algebraic manipulations used in later chapters. Although algebra can be a
very abstract mathematical tool, here we only need to explore those practical
features relevant to its application to computer graphics.
3.1 Notation
The word ‘algebra’ comes from the Arabic al-jabr w’al-muqabal, meaning
‘restoration and reduction’. Today’s algebraic notation has evolved over thou-
sands of years during which diﬀerent civilizations have developed ways of
annotating mathematical and logical problems. In retrospect, it does seem
strange that centuries passed before the ‘equals’ sign (=) was invented and
concepts such as ‘zero’ (ce 876) were introduced, especially as they now seem
so important. But we are not at the end of this evolution, because new forms
of annotation and manipulation will continue to emerge as new mathematical
ideas are invented.
One fundamental concept of algebra is the idea of giving a name to an
unknown quantity. For example, m is often used to represent the slope of a
2D line, and c is the line’s y-coordinate where it intersects the y-axis. Ren´e
Descartes (1596–1650) formalized the idea of using letters from the beginning
of the alphabet (a, b, c, etc.) to represent arbitrary numbers, and letters at the
end of the alphabet (p, q, r, s, t, . . . x, y, z) to identify variables representing
quantities such as pressure (p), temperature (t), and coordinates (x, y, z).
With the aid of the basic arithmetic operators +, −, ×, ÷ we can develop
expressions that describe the behaviour of a physical process or a speciﬁc

12
Mathematics for Computer Graphics
computation. For example, the expression ax+by−d equals zero for a straight
line. The variables x and y are the coordinates of any point on the line and
the values of a, b, d determine the position and orientation of the line. There
is an implied multiplication between ax and by, which would be expressed as
a∗x and b∗y if we were using a programming language.
The = sign permits the line equation to be expressed as a self-evident
statement: 0 = ax + by −d. Such a statement implies that the expressions
on the left- and right-hand sides of the = sign are ‘equal’ or ‘balanced’. So
whatever is done to one side must also be done to the other in order to
maintain equality or balance. For example, if we add d to both sides, the
straight-line equation becomes d = ax + by. Similarly, we could double or
treble both expressions, divide them by 4, or add 6, without disturbing the
underlying relationship.
Algebraic expressions also contain a wide variety of other notation, such as
√x
square root of x
n√x
nth root of x
xn
x to the power n
sin(x)
sine of x
cos(x)
cosine of x
tan(x)
tangent of x
log(x)
logarithm of x
ln(x)
natural logarithm of x
Parentheses are used to isolate part of an expression in order to select
a sub-expression that is manipulated in a particular way. For example, the
parentheses in c(a+b)+d ensure that the variables a and b are added together
before being multiplied by c and ﬁnally added to d.
3.2 Algebraic Laws
There are three basic laws that are fundamental to manipulating algebraic
expressions: associative, commutative and distributive. In the following de-
scriptions, the term binary operation represents the arithmetic operations +, −
or ×, which are always associated with a pair of numbers or variables.
3.2.1 Associative Law
The associative law in algebra states that when three or more elements are
linked together through a binary operation, the result is independent of how
each pair of elements is grouped. The associative law of addition is
a + (b + c) = (a + b) + c
(3.1)
e.g. 1 + (2 + 3) = (1 + 2) + 3

3 Algebra
13
and the associative law of multiplication is
a × (b × c) = (a × b) × c
(3.2)
e.g. 1 × (2 × 3) = (1 × 2) × 3
Note that substraction is not associative:
a −(b −c) ̸= (a −b) −c
(3.3)
e.g. 1 −(2 −3) ̸= (1 −2) −3
3.2.2 Commutative Law
The commutative law in algebra states that when two elements are linked
through some binary operation, the result is independent of the order of the
elements. The commutative law of addition is
a + b = b + a
(3.4)
e.g. 1 + 2 = 2 + 1
and the commutative law of multiplication is
a × b = b × a
(3.5)
e.g. 2 × 3 = 3 × 2
Note that subtraction is not commutative:
a −b ̸= b −a
(3.6)
e.g. 2 −3 ̸= 3 −2
3.2.3 Distributive Law
The distributive law in algebra describes an operation which when performed
on a combination of elements is the same as performing the operation on
the individual elements. The distributive law does not work in all cases of
arithmetic. For example, multiplication over addition holds:
a × (b + c) = ab + ac
(3.7)
e.g. 3 × (4 + 5) = 3 × 4 + 3 × 5
whereas addition over multiplication does not:
a + (b × c) ̸= (a + b) × (a + c)
(3.8)
e.g. 3 + (4 × 5) ̸= (3 + 4) × (3 + 5)
Although most of these laws seem to be natural for numbers, they do
not necessarily apply to all mathematical constructs. For instance, the vector
product, which multiplies two vectors together, is not commutative.

14
Mathematics for Computer Graphics
3.3 Solving the Roots of a Quadratic Equation
To put the above laws and notation into practice, let’s take a simple example
to illustrate the logical steps in solving a problem. The task involves solving
the roots of a quadratic equation, i.e. those values of x that make the equation
equal zero.
Given the quadratic equation where a ̸= 0:
ax2 + bx + c = 0
Step 1: subtract c from both sides:
ax2 + bx = −c
Step 2: divide both sides by a:
x2 + b
ax = −c
a
Step 3: add b2
4a2 to both sides:
x2 + b
ax + b2
4a2 = −c
a + b2
4a2
Step 4: factorize the left side:

x + b
2a
2
= −c
a + b2
4a2
Step 5: make 4a2 the common denominator for the right side:

x + b
2a
2
= −4ac + b2
4a2
Step 6: take the square root of both sides:
x + b
2a = ±
√
b2 −4ac
2a
Step 7: subtract b
2a from both sides:
x = ±
√
b2 −4ac
2a
−b
2a
Step 8: rearrange the right side:
x = −b ±
√
b2 −4ac
2a
(3.9)
This last expression gives the roots for any quadratic equation.

3 Algebra
15
3.4 Indices
A notation for repeated multiplication is with the use of indices. For instance,
in the above example with a quadratic equation x2 is used to represent x × x.
This notation leads to a variety of situations where laws are required to explain
how the result is to be computed.
3.4.1 Laws of Indices
The laws of indices can be expressed as
am × an = am+n
(3.10)
am ÷ an = am−n
(3.11)
(am)n = amn
(3.12)
which are easily veriﬁed using some simple examples.
3.4.2 Examples
1 : 23 × 22 = 8 × 4 = 32 = 25
2 : 24 ÷ 22 = 16 ÷ 4 = 4 = 22
3 : (22)3 = 64 = 26
From the above laws, it is evident that
a0 = 1
(3.13)
a−p = 1
ap
(3.14)
a
p
q =
q√
ap
(3.15)
3.5 Logarithms
Two people are associated with the invention of logarithms: John Napier
(1550–1617) and Joost B¨urgi (1552–1632). Both men were frustrated by the
time they spent multiplying numbers together, and both realized that multi-
plication could be replaced by addition using logarithms. Logarithms exploit
the addition and subtraction of indices shown in (3.10) and (3.11), and are
always associated with a base. For example, if ax = n, then loga n = x, where
a is the base. A concrete example brings the idea to life:
if 102 = 100 then log10 100 = 2
which can be interpreted as ‘10 has to be raised to the power (index) 2 to
equal 100’. The log operation ﬁnds the power of the base for a given number.

16
Mathematics for Computer Graphics
Thus a multiplication can be translated into an addition using logs:
36 × 24 = 864
log10 36 + log10 24 = log10 864
1.55630250077 + 1.38021124171 = 2.93651374248
In general, the two bases used in calculators and computer software are
10 and 2.718281846 . . . . The latter is e, a transcendental number. (A tran-
scendental number is not a root of any algebraic equation. Joseph Liouville
proved the existence of such numbers in 1844. π, the ratio of the circumfer-
ence of a circle to its diameter, is another example.) To distinguish one type
of logarithm from the other, logarithms to the base 10 are written as log, and
logarithms to the base e are written as ln.
From the above notation, it is evident that
log(ab) = log a + log b
(3.16)
log
a
b

= log a −log b
(3.17)
log(an) = n log a
(3.18)
log( n√a) = 1
n log a
(3.19)
The following formula is useful to convert from the base 10 to the base e:
log a = ln a × log e = 0.4343ln a
(3.20)
3.6 Further Notation
Mathematicians use all sorts of symbols to substitute for natural language
expressions. Here are some examples:
< less than
> greater than
≤less than or equal to
≥greater than or equal to
∼= approximately equal to
≡equivalent to
̸= not equal to
For example, 0 ≤t ≤1 can be interpreted as: 0 is less than or equal to t,
which is less than or equal to 1. Basically, this means t varies between 0 and 1.
3.7 Summary
The above description of algebra should be suﬃcient for the reader to under-
stand the remaining chapters. However, one should remember that this is only
the beginning of a very complex subject.

4
Trigonometry
When we split the word ‘trigonometry’ into its constituent parts, ‘tri’ ‘gon’
‘metry’, we see that it is to do with the measurement of three-sided poly-
gons, i.e. triangles. It is a very ancient subject, and one the reader requires
to understand for the analysis and solution of problems in computer
graphics.
Trigonometric functions arise in vectors, transforms, geometry, quater-
nions and interpolation, and in this chapter we will survey some of the basic
features with which the reader should be familiar.
The measurement of angles is at the heart of trigonometry, and two units of
angular measurement have survived into modern usage: degrees and radians.
The degree (or sexagesimal) unit of measure derives from deﬁning one com-
plete rotation as 360◦. Each degree divides into 60 minutes, and each minute
divides into 60 seconds. The number 60 has survived from Mesopotamian days
and is rather incongruous when used alongside today’s decimal system – which
is why the radian has secured a strong foothold in modern mathematics.
The radian of angular measure does not depend on any arbitrary constant.
It is the angle created by a circular arc whose length is equal to the circle’s
radius. And because the perimeter of a circle is 2πr, 2π radians correspond to
one complete rotation. As 360◦correspond to 2π radians, 1 radian corresponds
to 180/π◦, which is approximately 57.3◦.
The reader should try to memorize the following relationships between
radians and degrees:
π
2 = 90◦,
π = 180◦,
3π
2 = 270◦,
2π = 360◦

18
Mathematics for Computer Graphics
adjacent
hypotenuse
opposite
b
Fig. 4.1. Labeling a right-angle triangle for the trigonometric ratios.
4.1 The Trigonometric Ratios
Ancient civilizations knew that triangles, whatever their size, possessed some
inherent properties, especially the ratios of sides and their associated angles.
This meant that if such ratios were known in advance, problems involving
triangles with unknown lengths and angles could be computed using these
ratios.
To give you some idea why we employ the current notation, consider the
history of the word sine. The Hindu word ardhajya meaning ‘half-chord’ was
abbreviated to jya (‘chord’), which was translated by the Arabs into jiba,
and corrupted to jb. Other translators converted this to jaib, meaning ‘cove’,
‘bulge’ or ‘bay’, which in Latin is sinus.
Today, the trigonometric ratios are commonly known by the abbreviations
sin, cos, tan, cosec, sec and cot. Figure 4.1 shows a right-angled triangle where
the trigonometric ratios are given by
sin(β) =
opposite
hypotenuse
cos(β) =
adjacent
hypotenuse
tan(β) = opposite
adjacent
cosec(β) =
1
sin(β)
sec(β) =
1
cos(β)
cot(β) =
1
tan(β)
The sin and cos functions have limits ±1, whereas tan has limits ±∞. The
signs of the functions in the four quadrants are
+
+
−
−
−
+
−
+
−
+
+
−
sin
cos
tan
4.2 Example
Figure 4.2 shows a triangle where the hypotenuse and one angle are known.
The other sides are calculated as follows:
h
10 = sin(50◦)

4 Trigonometry
19
h
b
10
50
Fig. 4.2. h and b are unknown.
h = 10 sin(50◦) = 10 × 0.76601
h = 7.66
b
10 = cos(50◦)
b = 10 cos(50◦) = 10 × 0.64279
b = 6.4279
4.3 Inverse Trigonometric Ratios
As every angle has its associated ratio, functions are required to convert one
into the other. The sin, cos and tan functions convert angles into ratios, and
the inverse functions sin−1, cos−1 and tan−1 convert ratios into angles. For
example, sin(45◦) = 0.707, therefore sin−1(0.707) = 45◦. Although the sin and
cos functions are cyclic functions (i.e. they repeat indeﬁnitely) the inverse
functions return angles over a speciﬁc period.
4.4 Trigonometric Relationships
There is an intimate relationship between the sin and cos deﬁnitions, and the
are formally related by
cos(β) = sin(β + 90◦)
Also, the theorem of Pythagoras can be used to derive other formulae such as
sin(β)
cos(β) = tan(β)
sin2(β) + cos2(β) = 1
1 + tan2(β) = sec2(β)
1 + cot2(β) = cosec2(β)

20
Mathematics for Computer Graphics
A
b
C
a
B
c
Fig. 4.3. An arbitrary triangle.
4.5 The Sine Rule
The sine rule relates angles and side lengths for a triangle. Figure 4.3 shows a
triangle labelled such that side a is opposite angle A, side b is opposite angle
B, etc.
The sine rule states
a
sin A =
b
sin B =
c
sin C
4.6 The Cosine Rule
The cosine rule expresses the sin2(β) + cos2(β) = 1 relationship for the arbi-
trary triangle shown in Figure 4.3. In fact, there are three versions:
a2 = b2 + c2 −2bc cos(A)
b2 = c2 + a2 −2ca cos(B)
c2 = a2 + b2 −2ab cos(C)
Three further relationships also hold:
a = b cos(C) + c cos(B)
b = c cos(A) + a cos(C)
c = a cos(B) + b cos(A)
4.7 Compound Angles
Two sets of compound trigonometric relationships show how to add and sub-
tract two diﬀerent angles and multiples of the same angle. The following are
some of the most common relationships:
sin(A ± B) = sin(A) cos(B) ± cos(A) sin(B)

4 Trigonometry
21
cos(A ± B) = cos(A) cos(B) ∓sin(A) sin(B)
tan(A ± B) = tan(A) ± tan(B)
1 ∓tan(A) tan(B)
sin(2β) = 2 sin(β) cos(β)
cos(2β) = cos2(β) −sin2(β)
cos(2β) = 2 cos2(β) −1
cos(2β) = 1 −2 sin2(β)
sin(3β) = 3 sin(β) −4 sin3(β)
cos(3β) = 4 cos3(β) −3 cos(β)
cos2(β) = 1
2(1 + cos(2β))
sin2(β) = 1
2(1 −cos(2β))
4.8 Perimeter Relationships
Finally, referring back to Figure 4.3, we come to the relationships that inte-
grate angles with the perimeter of a triangle:
S = 1
2(a + b + c)
sin
A
2

=

(s −b)(s −c)
bc
sin
B
2

=

(s −c)(s −a)
ca
sin
C
2

=

(s −a)(s −b)
ab
cos
A
2

=

s(s −a)
bc
cos
B
2

=

s(s −b)
ca
cos
C
2

=

s(s −c)
ab

22
Mathematics for Computer Graphics
sin(A) = 2
bc

s(s −a)(s −b)(s −c)
sin(B) = 2
ca

s(s −a)(s −b)(s −c)
sin(C) = 2
ab

s(s −a)(s −b)(s −c)
4.9 Summary
No derivation has been given for the formulae in this chapter, but the reader
who is really interested will ﬁnd plenty of books that show their origins.
Hopefully, the formulae will be a useful reference when studying the rest
of the book, and perhaps will be of some use when solving problems in the
future.
I should draw the reader’s attention to two maths books that I have found
a source of information and inspiration: Handbook of Mathematics and Com-
putational Science by John Harris and Horst Stocker (1998), and Mathematics
from the Birth of Numbers by Jan Gullberg (1997).

5
Cartesian Coordinates
Ren´e Descartes (1596–1650) is often credited with the invention of the
xy-plane, but Pierre de Fermat (1601–1665) was probably the ﬁrst inventor. In
1636 Fermat was working on a treatise titled Ad locus planos et solidos isagoge,
which outlined what we now call analytic geometry. Unfortunately, Fermat
never published his treatise, although he shared his ideas with other math-
ematicians such as Blaise Pascal (1623–1662). At the same time Descartes
devised his own system of analytic geometry and in 1637 published his results
in the prestigious journal G´eom´etrie. In the eyes of the scientiﬁc world, the
publication date of a technical paper determines when a new idea or invention
is released into the public domain. Consequently, ever since this publication
Descartes has been associated with the xy-plane, which is why it is called the
Cartesian plane. If Fermat had been more eﬃcient in publishing his research
results, the xy-plane would have been called the Fermatian plane! (Boyer and
Merzbach, 1989).
5.1 The Cartesian xy-plane
The Cartesian xy-plane provides a mechanism for translating pairs of related
variables into a graphical format. The variables are normally x and y, as used
to describe a function such as y = 3x+2. Every value of x has a corresponding
value of y, which can be located on intersecting axes as shown in Figure 5.1.
The set of points forms a familiar straight line associated with equations of
the form y = mx+c. By convention, the axis for the independent variable x is
horizontal, and the dependent variable y is vertical. The axes intersect at 90◦
at a point called the origin. As previously mentioned, Descartes suggested
that the letters x and y should be used to represent variables, and letters

24
Mathematics for Computer Graphics
+X
−X
+Y
−Y
Fig. 5.1. The equation y = 3x + 2 using the xy Cartesian plane.
at the other end of the alphabet should substitute numbers. Which is why
equations such as y = ax2 + bx + c are written the way they are.
Measurements to the right and left of the origin are positive and negative
respectively, and measurements above and below the origin share a similar
sign convention. Together, the axes are said to create a left-handed set of
axes, because it is possible, using one’s left hand, to align the thumb with the
x-axis and the ﬁrst ﬁnger with the y-axis. We will say more about left and
right-handed axes in Chapter 6.
The Cartesian plane is such a simple idea that it is strange it took so long
to be discovered. But even though it was invented almost 400 years ago, it
is central to computer graphics. However, although it is true that Descartes
showed how an orthogonal coordinate system could be used for graphs and
coordinate geometry, coordinates had been used by ancient Egyptians, almost
2000 years earlier!
Any point P on the Cartesian plane is identiﬁed by an ordered pair of
numbers (x, y) where x and y are called the Cartesian coordinates of P.
Mathematical functions and geometric shapes can then be represented as lists
of coordinates inside a program.
5.1.1 Function Graphs
A wide variety of functions, such as y = mx + c (linear), y = ax2 + bx + c
(quadratic), y = ax3 + bx2 + cx + d (cubic), y = a sin(x) (trigonometric),
etc. create familiar graphs that readily identify the function’s origins. Linear
functions are straight lines, quadratics are parabolas, cubics have an ‘s’ shape,
and trigonometric functions often have a wave-like trace. Such graphs are used

5 Cartesian Coordinates
25
brightness
2 4 6 8 1012 141618 20 22 24 26 28 3032
frames
Fig. 5.2. A function curve relating brightness to frame number.
in computer animation to control the movement of objects, lights and the
virtual camera. But instead of depicting the relationship between x and y, the
graphs show the relationship between an activity such as movement, rotation,
size, brightness, colour, etc., with time. Figure 5.2 shows an example where
the horizontal axis marks the progress of time in animation frames, and the
vertical axis records the corresponding brightness of a virtual light source.
Such a function forms part of the animator’s user interface, and communicates
in a very intuitive manner the brightness of the light source for every frame
of animation. The animator can then make changes to the function with the
aid of interactive software tools.
5.1.2 Geometric Shapes
Computer graphics requires that 2D shapes and 3D objects have a numerical
description of some sort. Shapes can include polygons, circles, arbitrary curves,
mathematical functions, fractals, etc., and objects can be faceted, smooth,
bumpy, furry, gaseous, etc. For the moment, though, we will only consider 2D
shapes.
5.1.3 Polygonal Shapes
A polygon is constructed from a sequence of vertices (points) as shown in
Figure 5.3. A straight line is assumed to link each pair of neighbouring ver-
tices; intermediate points on the line are not explicitly stored. There is no
convention for starting a chain of vertices, but software will often dictate
whether polygons have a clockwise or anti-clockwise vertex sequence. If the
vertices in Figure 5.3 had been created in an anti-clockwise sequence, they
could be represented in a tabular form as shown, where the starting vertex is
(1, 1), but this is arbitrary.

26
Mathematics for Computer Graphics
1,3
1,1
3,1
3,2
x
y
1
3
3
1
1
1
2
3
X
y
Fig. 5.3. A simple polygon created with four vertices shown in the table.
We can now subject this list of vertex coordinates to a variety of arith-
metic and mathematical operations. For example, if we double the values of
x and y and redraw the vertices, we discover that the form of the shape is
preserved, but its size is doubled with respect to the origin. Similarly, if we
divide the values of x and y by 2, the shape is still preserved, but its size is
halved with respect to the origin. On the other hand, if we add 1 to every
x-coordinate and 2 to every y-coordinate and redraw the vertices, the shape’s
size remains the same but it is displaced 1 unit horizontally and 2 units verti-
cally. This arithmetic manipulation of vertices is the basis of shape and object
transformations and is described in Chapter 7.
5.1.4 Areas of Shapes
The area of a polygonal shape is readily calculated from its chain of coordi-
nates. For example, given the following list of coordinates:
x
y
x0
y0
x1
y1
x2
y2
x3
y3
the area is computed by
1
2[(x0y1 −x1y0) + (x1y2 −x2y1) + (x2y3 −x3y2) + (x3y0 −x0y3)]
(5.1)
If you check to see what is happening, you will notice that the calculation
sums the results of multiplying an x by the next y, minus the next x by the
current y. When the last vertex is selected it is paired with the ﬁrst vertex to
complete the process. The result is then halved to reveal the area.

5 Cartesian Coordinates
27
x1
x2
y1
y2
∆y
∆x
P1
P2
d
Y
X
Fig. 5.4. Calculating the distance between two points.
As a simple test, let’s apply (5.1) to the shape described in Figure 5.3:
1
2[(1 × 1 −3 × 1) + (3 × 2 −3 × 1) + (3 × 3 −1 × 2) + (1 × 1 −1 × 3)]
1
2[−2 + 3 + 7 −2] = 3
which by inspection, is the true area. The beauty of this technique is that it
works with any number of vertices and any arbitrary shape. In Chapter 6 we
will discover how it works.
Another feature of the technique is that if the original set of coordinates
is clockwise, the area is negative. Which means that the calculation computes
vertex sequence as well as area. To illustrate this feature, the original vertices
are reversed to a clockwise sequence as follows:
1
2[(1 × 3 −1 × 1) + (1 × 2 −3 × 3) + (3 × 1 −3 × 2) + (3 × 1 −1 × 1)]
1
2[2 −7 −3 + 2] = −3
The minus sign indicates that the vertices are in a clockwise sequence.
5.1.5 Theorem of Pythagoras in 2D
We can calculate the distance between two points by applying the theorem of
Pythagoras. Figure 5.4 shows two arbitrary points P1(x1, y1) and P2(x2, y2).
The distance ∆x = x2−x1 and ∆y = y2−y1 Therefore, the distance d between
P1 and P2 is given by
d =

∆x2 + ∆y2
(5.2)

28
Mathematics for Computer Graphics
(a)
(b)
X
X
Z
Z
Y
Y
Fig. 5.5. (a) A left-handed system. (b) A right-handed system.
5.2 3D Coordinates
In the 2D Cartesian plane a point is located by its x- and y-coordinates. But
when we move to 3D there are two choices for positioning the third z-axis.
Figure 5.5 shows the two possibilities, which are described as left- and right-
handed axial systems. The left-handed system allows us to align our left hand
with the axes such that the thumb aligns with the x-axis, the ﬁrst ﬁnger aligns
with the y-axis and the middle ﬁnger aligns with the z-axis. The right-handed
system allows the same system of alignment, but using our right hand. The
choice between these axial systems is arbitrary, but one should be aware of
the system employed by commercial computer graphics packages. The main
problem arises when projecting 3D points onto a 2D plane, which, in general,
has a left-handed axial system. This will become obvious when we look at
perspective projections. In this text we will keep to a right-handed system as
shown in Figure 5.6, which also shows a point P with its coordinates.
5.2.1 Theorem of Pythagoras in 3D
The theorem of Pythagoras in 3D is a natural extension of the 2D rule. In fact,
it even works in higher dimensions. Given two arbitrary points P1(x1, y1, z1)
and P2(x2, y2, z2), the distance ∆x = x2 −x1, ∆y = y2 −y1 and ∆z = z2 −z1.
Therefore, the distance d between P1 and P2 is given by
d =

∆x2 + ∆y2 + ∆z2
(5.3)
5.2.2 3D Polygons
The simplest 3D polygon is a triangle, which is always planar, i.e. the three ver-
tices lie on a unique plane. Planarity is very important in computer graphics
because rendering algorithms assume that polygons are planar. For instance,
it is quite easy to deﬁne a quadrilateral in 3D where the vertices are not lo-
cated on one plane. When such a polygon is rendered and animated, spurious
highlights can result, simply because the geometric techniques (which assume
the polygon is planar) give rise to errors.

5 Cartesian Coordinates
29
x
z
X
y
P
Y
Z
Fig. 5.6. A right-handed axial system showing the coordinates of a point P.
5.2.3 Euler’s Rule
In 1619, Descartes discovered quite a nice relationship between vertices, edges
and the faces of a 3D polygonal object:
faces + vertices = edges + 2
(5.4)
As a simple test, consider a cube; it has 12 edges, 6 faces and 8 vertices, which
satisﬁes this equation. This rule can be applied to a geometric database to dis-
cover whether it contains any spurious features. Unfortunately for Descartes,
for some unknown reason, the rule is named after Euler!
5.3 Summary
The Cartesian plane and its associated coordinates are the basis for all math-
ematics used for computer graphics. We will see in following chapters how
shapes can be manipulated using simple functions, and how the plane can be
extended into a 3D Cartesian space that becomes the domain for creating ob-
jects, curves, surfaces, and a virtual environment where they can be animated
and visualized.

6
Vectors
Vectors are a relatively new arrival to the world of mathematics, dating only
from the 19th century. They provide us with some elegant and powerful tech-
niques for computing angles between lines and the orientation of surfaces.
They also provide a coherent framework for computing the behaviour of dy-
namic objects in computer animation and illumination models in rendering.
We often employ a single number to represent quantities that we use in our
daily lives such as, height, age, shoe size, waist and chest measurements. The
magnitude of this number depends on our age and whether we use metric or
imperial units. Such quantities are called scalars. In computer graphics scalar
quantities include colour, height, width, depth, brightness, number of frames,
etc.
On the other hand, there are some things that require more than one
number to represent them: wind, force, weight, velocity and sound are just
a few examples. These cannot be represented accurately by a single number.
For example, any sailor knows that wind has a magnitude and a direction.
The force we use to lift an object also has a value and a direction. Similarly,
the velocity of a moving object is measured in terms of its speed (e.g. miles
per hour) and a direction such as north-west. Sound, too, has intensity and a
direction. These quantities are called vectors. In computer graphics, vectors
are generally made of two or three numbers, and this is the only type we will
consider in this chapter.
Mathematicians such as Caspar Wessel (1745–1818), Jean Argand (1768–
1822) and John Warren (1796–1852) were simultaneously exploring complex
numbers and their graphical representation. In 1837, Sir William Rowan
Hamilton (1788–1856) made his breakthrough with quaternions. In 1853,
Hamilton published his book Lectures on Quaternions in which he described
terms such as vector, transvector and provector. Hamilton’s work was not

32
Mathematics for Computer Graphics
widely accepted until 1881, when the American mathematician Josiah Gibbs
(1839–1903) published his treatise Vector Analysis, describing modern vector
analysis.
6.1 2D Vectors
In computer graphics we employ 2D and 3D vectors. In this chapter we
ﬁrst consider vector notation in a 2D context and then extrapolate the ideas
into 3D.
6.1.1 Vector Notation
A scalar such as x is just a name for a single numeric quantity. However,
because a vector contains two or more numbers, its symbolic name is printed
using a bold font to distinguish it from a scalar variable. Examples are n, i
and Q.
When a scalar variable is assigned a value we employ the standard algebraic
notation
x = 3
However, when a vector is assigned its numeric values, the following notation
is used:
n =

3
4

which is called a column vector. The numbers 3 and 4 are called the compo-
nents of n, and their position within the brackets is signiﬁcant. A row vector
transposes the components horizontally, n = [3 4]T where the superscriptT
reminds us of the transposition.
6.1.2 Graphical Representation of Vectors
Because vectors have to encode direction as well as magnitude, an arrow
could be used to indicate direction and a number to specify magnitude. Such
a scheme is often used in weather maps. Although this is a useful graphical
interpretation for such data, it is not practical for algebraic manipulation.
Cartesian coordinates provide an excellent mechanism for visualizing vec-
tors and allowing them to be incorporated within the classical framework of
mathematics. Figure 6.1 shows a vector represented by a short line segment.
The length of the line represents the vector’s magnitude, and the orienta-
tion deﬁnes its direction. But as you can see from the ﬁgure, the line does
not have a direction. Even if we attach an arrowhead to the line, which is
standard practice for annotating vectors in books and scientiﬁc papers, the
arrowhead has no mathematical reality.

6 Vectors
33
Y
X
Fig. 6.1. A vector represented by a short line segment. However, although the vector
has magnitude, it does not have direction.
r
s
Y3
2
1
1
2
3
X
(x2, y2)
(x3, y3)
(x1, y1)
(x4, y4)
Fig. 6.2. Two vectors r and s have the same magnitude and opposite directions.
The line’s direction can be determined by ﬁrst identifying the vector’s tail
and then measuring its components along the x- and y-axes. For example,
in Figure 6.2 the vector r has its tail deﬁned by (x1, y1) = (1, 2) and its
head by (x2, y2) = (2, 3). Vector s, on the other hand, has its tail deﬁned by
(x3, y3) = (2, 2) and its head by (x4, y4) = (1, 1). The x- and y-components
for r are computed as follows:
xr = (x2 −x1)
yr = (y2 −y1)
xr = 2 −1 = 1
yr = 3 −2 = 1
whereas the components for s are computed as follows:
xs = (x4 −x3)
ys = (y4 −y3)
xs = 1 −2 = −1
ys = 1 −2 = −1
xs = −1
ys = −1
It is the negative values of xs and ys that encode the vector’s direction. In
general, given that the coordinates of a vector’s head and tail are (xh, yh) and

34
Mathematics for Computer Graphics
X
Y
Fig. 6.3. Eight vectors, whose coordinates are shown in Table 6.1.
(xt, yt) respectively, its components ∆x and ∆y are given by
∆x = (xh −xt)
∆y = (yh −yt)
(6.1)
One can readily see from this notation that a vector does not have a unique
position in space. It does not matter where we place a vector: so long as we
preserve its length and orientation, its components will not alter.
6.1.3 Magnitude of a Vector
The magnitude of a vector r is expressed by ∥r∥and is computed by applying
the theorem of Pythagoras to its components:
||r|| =

∆x2 + ∆y2
(6.2)
To illustrate these ideas, consider a vector deﬁned by (xh, yh) = (3, 4) and
(xt, yt) = (1, 1). The x- and y-components are 2 and 3 respectively. Therefore
its magnitude is equal to
√
22 + 32 = 3.606
Figure 6.3 shows various vectors, and their properties are listed in
Table 6.1.
6.2 3D Vectors
The above vector examples are in 2D, but it is extremely simple to extend
this notation to embrace an extra dimension. Figure 6.4 shows a 3D vector r
with its head, tail, components and magnitude annotated. The components
and magnitude are given by
∆x = (xh −xt)
(6.3)

6 Vectors
35
Table 6.1. Values associated with the vectors shown in
Fig. 6.3
xh
yh
xt
yt
∆x
∆y
∥Vector∥
2
0
0
0
2
0
2
0
2
0
0
0
2
2
−2
0
0
0
−2
0
2
0
−2
0
0
0
−2
2
1
1
0
0
1
1
√
2
−1
1
0
0
−1
1
√
2
−1
−1
0
0
−1
−1
√
2
1
−1
0
0
1
−1
√
2
Y
Ph
Pt
Z
X
'z
'x
'y
r
Fig. 6.4. The 3D vector has components ∆x, ∆y, ∆z, which are the diﬀerences be-
tween the head and tail coordinates.
∆y = (yh −yt)
(6.4)
∆z = (zh −zt)
(6.5)
||r|| =

∆x2 + ∆y2 + ∆z2
(6.6)
As 3D vectors play a very important part in computer animation, all future
examples will be three-dimensional.
6.2.1 Vector Manipulation
As vectors are diﬀerent from scalars, a set of rules has been developed to
control how the two mathematical entities interact with one another. For
instance, we need to consider vector addition, subtraction and multiplication,
and how a vector can be modiﬁed by a scalar. Let’s begin with multiplying a
vector by a scalar.

36
Mathematics for Computer Graphics
6.2.2 Multiplying a Vector by a Scalar
Given a vector n, 2n means that the vector’s components are doubled. For
example, if
n =
⎡
⎣
3
4
5
⎤
⎦
then
2n =
⎡
⎣
6
8
10
⎤
⎦
which seems logical. Similarly, if we divide n by 2, its components are halved.
Note that the vector’s direction remains unchanged – only its magnitude
changes.
It is meaningless to consider the addition of a scalar to a vector such as
n+2, for it is not obvious which component of n is to be increased by 2. If all
the components of n have to be increased by 2, then we simply add another
vector whose components equal 2.
6.2.3 Vector Addition and Subtraction
Given vectors r and s, r ± s is deﬁne as
r =
⎡
⎣
xr
yr
zr
⎤
⎦
s =
⎡
⎣
xs
ys
zs
⎤
⎦r ± s =
⎡
⎣
xr ± xs
yr ± ys
zr ± zs
⎤
⎦
(6.7)
Vector addition is commutative:
a + b = b + a
(6.8)
e.g.
⎡
⎣
1
2
3
⎤
⎦+
⎡
⎣
4
5
6
⎤
⎦=
⎡
⎣
4
5
6
⎤
⎦+
⎡
⎣
1
2
3
⎤
⎦=
⎡
⎣
5
7
9
⎤
⎦
However, like scalar subtraction, vector subtraction is not commutative:
a −b ̸= b −a
e.g.
⎡
⎣
4
5
6
⎤
⎦−
⎡
⎣
1
2
3
⎤
⎦̸=
⎡
⎣
1
2
3
⎤
⎦−
⎡
⎣
4
5
6
⎤
⎦
a −b ̸= b −a
(6.9)
Let’s illustrate vector addition and subtraction with two examples. Figure
6.5 shows the graphical interpretation of adding two vectors r and s. Note
that the tail of vector s is attached to the head of vector r. The resultant
vector t = r + s is deﬁned by adding the corresponding components of r and
s together. Figure 6.6 shows a graphical interpretation for r −s. This time the
components of vector s are reversed to produce an equal and opposite vector.
Then it is attached to r and added as described above.

6 Vectors
37
r
s
r + s
Y
Z
X
Fig. 6.5. Vector addition r + s.
Z
r −s
r
s
−s
X
Y
Fig. 6.6. Vector subtraction r −s.
6.2.4 Position Vectors
Given any point P(x, y, z), a position vector p can be created by assuming
that P is the vector’s head and the origin is its tail. Because the tail coor-
dinates are (0, 0, 0) the vector’s components are x, y, z. Consequently, the
vector’s magnitude ||p|| equals

x2 + y2 + z2. For example, the point P(4, 5,
6) creates a position vector p relative to the origin:
p =
⎡
⎣
4
5
6
⎤
⎦
||p|| =

42 + 52 + 62 = 20.88
We will see how position vectors are used in Chapter 8 when we consider
analytical geometry.
6.2.5 Unit Vectors
By deﬁnition, a unit vector has a magnitude of 1. A simple example is i where
i =
⎡
⎣
1
0
0
⎤
⎦
||i|| = 1

38
Mathematics for Computer Graphics
Unit vectors are extremely useful when we come to vector multiplication. As
we shall discover later, multiplication of vectors involves taking their magni-
tude, and if this is unity, the multiplication is greatly simpliﬁed. Furthermore,
in computer graphics applications vectors are used to specify the orientation
of surfaces, the direction of light sources and the virtual camera. Again, if
these vectors have a unit length, the computation time associated with vector
operations can be minimized.
Converting a vector into a unit form is called normalizing and is achieved
by dividing a vector’s components by its magnitude. To formalize this process,
consider a vector r whose components are x, y, z. The magnitude ||r|| =

x2 + y2 + z2 and the unit form of r are given by
ru =
1
||r||
⎡
⎣
x
y
z
⎤
⎦
(6.10)
This process can be conﬁrmed by showing that the magnitude of ru is 1:
||ru|| =
 x
∥r∥
2
+
 y
∥r∥
2
+
 z
∥r∥
2
=
1
||r||

x2 + y2 + z2 = 1
To put this into context, consider the conversion of r into a unit form:
r =
⎡
⎣
1
2
3
⎤
⎦
||r|| =

12 + 22 + 32 =
√
14
ru =
1
√
14
⎡
⎣
1
2
3
⎤
⎦=
⎡
⎣
0.267
0.535
0.802
⎤
⎦
6.2.6 Cartesian Vectors
Now that we have considered the scalar multiplication of vectors, vector ad-
dition and unit vectors, we can combine all three to permit the algebraic
manipulation of vectors. To begin with, we will deﬁne three Cartesian unit
vectors i, j, k that are aligned with the x-, y- and z-axes respectively:
i =
⎡
⎣
1
0
0
⎤
⎦,
j =
⎡
⎣
0
1
0
⎤
⎦,
k =
⎡
⎣
0
0
1
⎤
⎦
(6.11)
Therefore any vector aligned with the x-, y- or z-axes can be deﬁned by a scalar
multiple of the unit vectors i, j and k respectively. For example, a vector 10

6 Vectors
39
units long aligned with the x-axis is simply 10i, and a vector 20 units long
aligned with the z-axis is 20k. By employing the rules of vector addition and
subtraction, we can compose a vector r by adding three Cartesian vectors as
follows:
r = ai + bj + ck
(6.12)
This is equivalent to writing r as
r =
⎡
⎣
a
b
c
⎤
⎦
(6.13)
which means that the magnitude of r is readily computed as
||r|| =

a2 + b2 + c2
(6.14)
Any pair of Cartesian vectors such as r and s can be combined as follows:
r = ai + bj + ck
(6.15)
s = di + ej + fk
(6.16)
r ± s = (a ± d)i + (b ± e)j + (c ± f)k
(6.17)
For example, given
r = 2i + 3j + 4k and s = 5i + 6j + 7k
then r + s = 7i + 9j + 11k
and
||r + s|| =

72 + 92 + 112 =
√
251
= 15.84
6.2.7 Vector Multiplication
Although vector addition and subtraction are useful in resolving various prob-
lems, vector multiplication provides some powerful ways of computing angles
and surface orientations.
The multiplication of two scalars is very familiar: for example, 6×7 or 7×
6 = 42. We often visualize this operation, as a rectangular area where 6 and
7 are the dimensions of a rectangle’s sides, and 42 is the area. However, when
we consider the multiplication of vectors we are basically multiplying two 3D
lines together, which is not an easy operation to visualize.
Mathematicians have discovered that there are two ways to multiply vec-
tors together: one gives rise to a scalar result and the other a vector result.
We will start with the scalar product.

40
Mathematics for Computer Graphics
6.2.8 Scalar Product
We could multiply two vectors r and s by using the product of their magni-
tudes: ||r|| · ||s||. Although this is a valid operation, it does not get us any-
where because it ignores the orientation of the vectors, which is one of their
important features. The concept, however, is readily developed into a useful
operation by including the angle between the vectors.
Figure 6.7 shows two vectors r and s that have been drawn, for conve-
nience, such that their tails touch. Taking s as the reference vector, which is
an arbitrary choice, we compute the projection of r on s, which takes into
account their relative orientation. The length of r on s is ||r|| cos(β). We can
now multiply the magnitude of s by the projected length of r : ||s||·||r|| cos(β).
This scalar product is written
s · r = ||s|| · ||r|| cos(β)
(6.18)
The dot symbol ‘·’ is used to represent scalar multiplication, to distinguish
it from the vector product, which, we will discover, employs a ‘×’ symbol.
Because of this symbol, the scalar product is often referred to as the dot
product.
So far we have only deﬁned what we mean by the dot product. We now
need to ﬁnd out how to compute it. Fortunately, everything is in place to
perform this task. To begin with, we deﬁne two Cartesian vectors r and s,
and proceed to multiply them together using the dot product deﬁnition:
r = ai + bj + ck
(6.19)
s = di + ej + fk
(6.20)
therefore
r · s = (ai + bj + ck) · (di + ej + fk)
= ai · (di + ej + fk) +
bj·(di + ej + fk) +
ck·(di + ej + fk)
r
Y
s
X
Z
b
Fig. 6.7. The projection of r on s creates the basis for the scaler product.

6 Vectors
41
r · s = ad(i · i) + ae(i · j) + af(i · k) +
bd(j · i) + be(j · j) + bf(j · k) +
cd(k · i) + ce(k · j) + cf(k · k)
(6.21)
Before we proceed any further, we can see that we have created various dot
product terms such as (i · i), (j · j), (k · k), etc. These terms can be di-
vided into two groups: those that involve the same unit vector, and those that
reference diﬀerent unit vectors.
Using the deﬁnition of the dot product, terms such as (i · i), (j · j) and
(k · k) = 1, because the angle between i and i, j and j, or k and k is 0◦; and
cos(0◦) = 1. But because the other vector combinations are separated by 90◦,
and cos(90◦) = 0, all remaining terms collapse to zero. Bearing in mind that
the magnitude of a unit vector is 1, we can write
||s|| · ||r|| cos(β) = ad + be + cf
(6.22)
This result conﬁrms that the dot product is indeed a scalar quantity. Now
let’s see how it works in practice.
6.2.9 Example of the Dot Product
To ﬁnd the angle between two vectors r and s,
r =
⎡
⎣
2
−3
4
⎤
⎦
and
s =
⎡
⎣
5
6
10
⎤
⎦
||r|| =

22 + (−3)2 + 42 = 5.385
||s|| =

52 + 62 + 102 = 12.689
Therefore
||s|| · ||r|| cos(β) = 2 × 5 + (−3) × 6 + 4 × 10 = 32
12.689 × 5.385 × cos(β) = 32
cos(β) =
32
12.689 × 5.385 = 0.468
β = cos−1(0.468) = 62.1◦
The angle between the two vectors is 62.1◦.
It is worth pointing out at this stage that the angle returned by the dot
product ranges between 0◦and 180◦. This is because, as the angle between
two vectors increases beyond 180◦, the returned angle β is always the smallest
angle associated with the geometry.

42
Mathematics for Computer Graphics
6.2.10 The Dot Product in Lighting Calculations
Lambert’s law states that the intensity of illumination on a diﬀuse surface is
proportional to the cosine of the angle between the surface normal vector and
the light source direction. This arrangement is shown in Figure 6.8. The light
source is located at (20, 20, 40) and the illuminated point is (0, 10, 0).
In this situation we are interested in calculating cos(β), which when mul-
tiplied by the light source intensity gives the incident light intensity on the
surface. To begin with, we are given the normal vector n to the surface. In
this case n is a unit vector, and its magnitude ∥n∥= 1:
n =
⎡
⎣
0
1
0
⎤
⎦
The direction of the light source from the surface is deﬁned by the vector s:
s =
⎡
⎣
20 −0
20 −10
40 −0
⎤
⎦=
⎡
⎣
20
10
40
⎤
⎦
||s|| =

202 + 102 + 402 = 45.826
||n|| · ||s|| cos(β) = 0 × 20 + 1 × 10 + 0 × 40 = 10
1 × 45.826 × cos(β) = 10
cos(β) =
10
45.826 = 0.218
Therefore the light intensity at the point (0, 10, 0) is 0.218 of the original
light intensity at (20, 20, 40). This does not take into account the attenuation
due to the inverse-square law of light propagation.
n
b
Light
source
s
Fig. 6.8. Lambert’s law states that the intensity of illumination on a diﬀuse surface
is proportional to the cosine of the angle between the surface normal vector and the
light source direction.

6 Vectors
43
6.2.11 The Dot Product in Back-Face Detection
A standard way of identifying back-facing polygons relative to the virtual
camera is to compute the angle between the polygon’s surface normal and the
line of sight between the camera and the polygon. If this angle is less than
90◦the polygon is visible; if it is equal to or greater than 90◦the polygon is
invisible. This geometry is shown in Figure 6.9. Although it is obvious from
Figure 6.9 that the right-hand polygon is invisible to the camera, let’s prove
algebraically that this is so. Let the camera be located at (0,0,0) and the
polygon’s vertex is (10, 10, 40). The normal vector is [5 5 −2]T
n =
⎡
⎣
5
5
−2
⎤
⎦
||n|| =

52 + 52 + (−2)2 = 7.348
The camera vector c is
c =
⎡
⎣
0 −10
0 −10
0 −40
⎤
⎦
=
⎡
⎣
−10
−10
−40
⎤
⎦
||c|| =

(−10)2 + (−10)2 + (−40)2 = 42.426
therefore
||n|| · ||c|| cos(β) = 5 × (−10) + 5 × (−10) + (−2) × (−40)
7.348 × 42.426 × cos(β) = −20
cos(β) =
−20
7.348 × 42.426 = −0.0634
β = cos−1(−0.0634) = 93.635◦
which shows that the polygon is invisible.
< 90
> 90
visible
invisible
camera
Fig. 6.9. The angle between the surface normal and the camera’s line of sight deter-
mines the polygon’s visibility.

44
Mathematics for Computer Graphics
6.2.12 The Vector Product
As mentioned above, there are two ways to obtain the product of two vectors.
The ﬁrst is the scalar product, and the second is the vector product, which is
also called the cross product because of the ‘×’ symbol used in its notation. It
is based on the deﬁnition that two vectors r and s can be multiplied together
to produce a third vector t:
r × s = t
(6.23)
where ||t|| = ||r|| · ||s|| sin(β), and β is the angle between r and s.
We will discover that the vector t is normal (90◦) to the plane containing
the vectors r and s. This makes it an ideal way of computing the surface
normal to a polygon. Once again, let’s deﬁne two vectors and proceed to
multiply them together:
r = ai + bj + ck
(6.24)
s = di + ej + fk
(6.25)
r × s = (ai + bj + ck) × (di + ej + fk)
= ai × (di + ej + fk) + bj × (di + ej + fk) + ck
×(di + ej + fk)
r × s = ad(i × i) + ae(i × j) + af(i × k) + bd(j × i) + be(j × j)
+bf(j × k) + cd(k × i) + ce(k × j) + cf(k × k)
(6.26)
As we found with the dot product, there are two groups of vector terms: those
that reference the same unit vector, and those that reference two diﬀerent unit
vectors.
Using the deﬁnition for the cross product, operations such as (i×i), (j×j)
and (k × k) result in a vector whose magnitude is 0. This is because the
angle between the vectors is 0◦, and sin(0◦) = 0. Consequently these terms
disappear and we are left with
r × s = ae(i × j) + af(i × k) + bd(j × i) + bf(j × k) + cd(k × i) + ce(k × j)
(6.27)
The mathematician Sir William Rowan Hamilton struggled for many years
when working on quaternions to resolve the meaning of the above result. What
did the products mean? He assumed that i×j = k, j×k = i and k×i = j, but
he also thought that j × i = k, k × j = i and i × k = j. But this did not work!
One day in 1843, when he was out walking, thinking about this problem, he
thought the impossible: i × j = k, but j × i = −k, j × k = i, but k × j = −i,
and k×i = j, but i×k = −j. To his surprise, this worked, but it contradicted
the commutative multiplication law of scalars where 6 × 7 = 7 × 6. We now

6 Vectors
45
accept that vectors do not obey all the rules of scalars, which is an interesting
result.
Proceeding, then, with Hamilton’s rules, we reduce the cross product terms
of (6.27) to
r × s = ae(k) + af(−j) + bd(−k) + bf(i) + cd(j) + ce(−i)
= (bf −ce)i + (cd −af)j + (ae −bd)k
(6.28)
We now modify the middle term to create a symmetric result:
r × s = (bf −ce)i −(af −cd)j + (ae −bd)k
(6.29)
If this is written in determinant form we get
r × s =

b
c
e
f
 i −

a
c
d
f
 j +

a
b
d
e
 k
(6.30)
where the determinants provide the scalar for each unit vector. We will dis-
cover later that the determinant of a 2 × 2 matrix is the diﬀerence between
the products of the diagonal terms.
Although it may not be obvious, there is a simple elegance to this result,
which enables the cross product to be calculated very quickly. To derive the
cross product we write the vectors in the correct sequence. Remember that
r × s does not equal s × r. First take r × s:
r = ai + bj + ck
s = di + ej + fk
(6.31)
The scalar multiplier for i is (bf −ec). This is found by ignoring the i com-
ponents and looking at the scalar multipliers of j and k.
The scalar multiplier for −j is (af −dc). This is found by ignoring the j
components and looking at the i and k scalars.
The scalar multiplier for k is (ae −db). This is found by ignoring the k
components and looking at the i and j scalars.
Let’s illustrate this with some examples. First we conﬁrm that the vector
product works with the unit vectors, i, j and k.
Therefore
i × j = (0 × 0 −1 × 0)i −(1 × 0 −0 × 0)j + (1 × 1 −0 × 0)k
= k
j × k = (1 × 1 −0 × 0)i −(0 × 1 −0 × 0)j + (0 × 0 −0 × 1)k
= i
k × i = (0 × 0 −0 × 1)i −(0 × 0 −1 × 1)j + (0 × 0 −1 × 0)k
= j

46
Mathematics for Computer Graphics
Let’s now consider two vectors r and s and compute the normal vector t.
The vectors will be chosen so that we can anticipate approximately the answer.
Figure 6.10 shows the vectors r and s and the normal vector t. Table 6.2
contains the coordinates of the vertices forming the two vectors.
r =
⎡
⎣
x3 −x2
y3 −y2
z3 −z2
⎤
⎦s =
⎡
⎣
x1 −x2
y1 −y2
z1 −z2
⎤
⎦
r = −i + j
s = −i + k
r × s = (1 × 1 −0 × 0)i −(−1 × 1 −(−1) × 0)j
+(−1 × 0 −(−1) × 1)k
= i + j + k
This conﬁrms what we expected from Figure 6.10. Let’s now reverse the vec-
tors to illustrate the importance of vector sequence:
s = −i + k
r = −i + j
r
n3
n2
n1
Y
t
s
Z
X
Fig. 6.10. The vector t is normal to the vectors r and s.
Table 6.2. Coordinates of the vertices used
in Fig. 6.10.
Vertex
x
y
z
v1
0
0
1
v2
1
0
0
v3
0
1
0

6 Vectors
47
s × r = (0 × 0 −1 × 1)i −(−1 × 0 −(−1) × 1)j
+(−1 × 1 −(−1) × 0)k
= −i −j −k
which is in the opposite direction to r × s.
6.2.13 The Right-Hand Rule
The right-hand rule is an aide m´emoire for working out the orientation of
the cross product vector. Given the operation r × s, if the right-hand thumb
is aligned with r, the ﬁrst ﬁnger with s, and the middle ﬁnger points in the
direction of t.
6.3 Deriving a Unit Normal Vector for a Triangle
Figure 6.11 shows a triangle with vertices deﬁned in an anti-clockwise sequence
from its visible side. This is the side we want the surface normal to point
upwards. Using the following information we will compute the surface normal
using the cross product and then convert it to a unit normal vector.
Create vector r between v1 and v3, and vector s between v2 and v3:
r = −i + j
s = −i + 2k
r × s = t = (1 × 2 −0 × 0)i −(−1 × 2 −0 × −1)j
+(−1 × 0 −1 × −1)k
t = 2i + 2j + k
||t|| =

22 + 22 + 12 = 3
tu = 2
3i + 2
3j + 1
3k
The unit vector tu can now be used in illumination calculations, and as it has
unit length, dot product calculations are simpliﬁed.
r
t
s
V1 (0, 2, 2)
V3 (1, 1, 2)
V2 (0, 1, 4)
Y
X
Z
Fig. 6.11. The normal vector t is derived from the cross product r × s.

48
Mathematics for Computer Graphics
X
Y
h
s
r
b
Fig. 6.12. The area of the parallelogram formed by two vectors r and s equals ||r|| ·
||s|| sin β.
6.4 Areas
Before we leave the cross product let’s investigate the physical meaning of
∥r∥· ∥s∥sin(β). Figure 6.12 shows two 2D vectors, r and s. The height h =
∥s∥sin(β), therefore the area of the parallelogram is
||r||h = ||r|| · ||s|| sin(β)
(6.32)
But this is the magnitude of the cross product vector t. Thus when we calcu-
late r×s, the length of the normal vector t equals the area of the parallelogram
formed by r and s. Which means that the triangle formed by halving the par-
allelogram is half the area.
area of parallelogram = ||t||
(6.33)
area of triangle = 1
2||t||
(6.34)
This means that it is a relatively easy exercise to calculate the surface area
of an object constructed from triangles or parallelograms. In the case of a
triangulated surface, we simply sum the magnitudes of the normals and halve
the result.
6.4.1 Calculating 2D Areas
Figure 6.13 shows three vertices of a triangle P0(x0, y0), P1(x1, y1) and P2(x2, y2)
formed in an anti-clockwise sequence. We can imagine that the triangle exists
on the z = 0 plane, therefore the z-coordinates are zero.

6 Vectors
49
Y
X
P0
P1
P2
r
s
Fig. 6.13. The area of the triangle formed by the vectors r and s is half the magnitude
of their cross product.
The vectors r and s are computed as follows:
r =
⎡
⎣
x1 −x0
y1 −y0
0
⎤
⎦
s =
⎡
⎣
x2 −x0
y2 −y0
0
⎤
⎦
(6.35)
r = (x1 −x0)i + (y1 −y0)j
(6.36)
s = (x2 −x0)i + (y2 −y0)j
(6.37)
||r × s|| = (x1 −x0)(y2 −y0) −(x2 −x0)(y1 −y0)
= x1(y2 −y0) −x0(y2 −y0) −x2(y1 −y0) + x0(y1 −y0)
= x1y2 −x1y0 −x0y2 −x0y0 −x2y1 + x2y0 + x0y1 −x0y0
= x1y2 −x1y0 −x0y2 −x2y1 + x2y0 + x0y1
= (x0y1 −x1y0) + (x1y2 −x2y1) + (x2y0 −x0y2)
(6.38)
But the area of the triangle formed by the three vertices is 1
2∥r×s∥. Therefore
area = 1
2[(x0y1 −x1y0) + (x1y2 −x2y1) + (x2y0 −x0y2)]
(6.39)
which is the formula disclosed in Chapter 2!
6.5 Summary
Even if you already knew something about vectors, I hope this chapter has
introduced some new ideas and illustrated the role vectors play in computer
graphics.

7
Transformation
Transformations are used to scale, translate, rotate, reﬂect and shear shapes
and objects. And, as we shall discover shortly, it is possible to eﬀect this by
changing their coordinate values.
Although algebra is the basic notation for transformations, it is also possi-
ble to express them as matrices, which provide certain advantages for viewing
the transformation and for interfacing to various types of computer graphics
hardware. We begin with an algebraic approach and then introduce matrix
notation.
7.1 2D Transformations
7.1.1 Translation
Cartesian coordinates provide a one-to-one relationship between number and
shape, such that when we change a shape’s coordinates, we change its geome-
try. For example, if P(x, y) is a vertex on a shape, when we apply the operation
x′ = x + 3 we create a new point P ′(x′, y) three units to the right. Similarly,
the operation y′ = y + 1 creates a new point P ′(x, y′) displaced one unit ver-
tically. By applying both of these transforms to every vertex to the original
shape, the shape is displaced as shown in Figure 7.1.
7.1.2 Scaling
Shape scaling is achieved by multiplying coordinates as follows:
x′ = 2x
y′ = 1.5y
(7.1)

52
Mathematics for Computer Graphics
Original
Translated
X
Y
Fig. 7.1. The translated shape results by adding 3 to every x-coordinate, and 1 to
every y-coordinate of the original shape.
Fig. 7.2. The scaled shape results by multiplying every x-coordinate by 2 and every
y-coordinate by 1.5.
This transform results in a horizontal scaling of 2 and a vertical scaling of
1.5, as illustrated in Figure 7.2. Note that a point located at the origin does
not change its place, so scaling is relative to the origin.
7.1.3 Reﬂection
To make a reﬂection of a shape relative to the y-axis, we simply reverse the
sign of the x-coordinate, leaving the y-coordinate unchanged
x′ = −x
y′ = y
(7.2)

7 Transformation
53
X
Y
Original
Fig. 7.3. The top right-hand shape can give rise to the three reﬂections simply by
reversing the signs of coordinates.
and to reﬂect a shape relative to the x-axis we reverse the y-coordinates:
x′ = x
y′ = −y
(7.3)
Examples of reﬂections are shown in Figure 7.3.
Before proceeding, we pause to introduce matrix notation so that we can
develop further transformations using algebra and matrices simultaneously.
7.2 Matrices
Matrix notation was investigated by the British mathematician Arthur Cayley
around 1858. Caley formalized matrix algebra, along with the American math-
ematicians Benjamin and Charles Pierce. Also, by the start of the 19th century
Carl Gauss (1777–1855) had proved that transformations were not commuta-
tive, i.e. T1 × T2 ̸= T2 × T1, and Caley’s matrix notation would clarify such
observations. For example, consider the transformation T1:
T1
x′
= ax + by
y′
= cx + dy
(7.4)

54
Mathematics for Computer Graphics
and another transformation T2 that transforms T1:
T2 × T1
x′′ = Ax′ + By′
y′′ = Cx′ + Dy′
(7.5)
If we substitute the full deﬁnition of T1 we get
T2 × T1
x′′ = A(ax + by) + B(cx + dy)
y′′ = C(ax + by) + D(cx + dy)
(7.6)
which simpliﬁes to
T2 × T1
x′′ = (Aa + Bc)x + (Ab + Bd)y
y′′ = (Ca + Dc)x + (Cb + Dd)y
(7.7)
Caley proposed separating the constants from the variables, as follows:
T1

x′
y′

=

a
b
c
d

·

x
y

(7.8)
where the square matrix of constants in the middle determines the trans-
formation. The algebraic form is recreated by taking the top variable x′,
introducing the = sign, and multiplying the top row of constants [a b] in-
dividually by the last column vector containing x and y. We then examine
the second variable y′, introduce the = sign, and multiply the bottom row of
constants [c d] individually by the last column vector containing x and y, to
create
x′ = ax + by
y′ = cx + dy
(7.9)
Using Caley’s notation, the product T2 × T1 is
 x′′
y′′

=
 A
B
C
D

·
 x′
y′

(7.10)
But the notation also intimated that
 x′′
y′′

=
 A
B
C
D

·
 a
b
c
d

·
 x
y

(7.11)
and when we multiply the two inner matrices together they must produce
x′′ = (Aa + Bc)x + (Ab + Bd)y
y′′ = (Ca + Dc)x + (Cb + Dd)y
(7.12)
or in matrix form
 x′′
y′′

=
 Aa + Bc
Ab + Bd
Ca + Dc
Cb + Dd

·
 x
y

(7.13)

7 Transformation
55
otherwise the two systems of notation will be inconsistent. This implies that

Aa + Bc
Ab + Bd
Ca + Dc
Cb + Dd

=

A
B
C
D

·

a
b
c
d

(7.14)
which demonstrates how matrices must be multiplied. Here are the rules for
matrix multiplication:
Aa+Bc
=
•
A      B
a
c
1
The top left-hand corner element Aa + Bc is the product of the top row of
the ﬁrst matrix by the left column of the second matrix.
Ab+Bd
=
•
A      B
b
d
2
The top right-hand element Ab + Bd is the product of the top row of the
ﬁrst matrix by the right column of the second matrix.
Ca+Dc
=
•
C      D
a
c
3
The bottom left-hand element Ca + Dc is the product of the bottom row
of the ﬁrst matrix by the left column of the second matrix.
Cb+Dd
=
•
C      D
b
d
4
The bottom right-hand element Cb + Dd is the product of the bottom row
of the ﬁrst matrix by the right column of the second matrix.
It is now a trivial exercise to conﬁrm Gauss’s observation that T1 × T2 ̸=
T2 × T1, because if we reverse the transforms T2 × T1 to T1 × T2 we get

Aa + Bc
Ab + Bd
Ca + Dc
Cb + Dd

=

a
b
c
d

·

A
B
C
D

(7.15)
which shows conclusively that the product of two transforms is not co-
mmutative.

56
Mathematics for Computer Graphics
One immediate problem with this notation is that there is no apparent
mechanism to add or subtract a constant such as c or f :
x′ = ax + by + c
y′ = dx + ey + f
(7.16)
Mathematicians resolved this in the 19th century, by the use of homoge-
neous coordinates. But before we look at this idea, it must be pointed out that
currently there are two systems of matrix notation in use.
7.2.1 Systems of Notation
Over the years, two systems of matrix notation have evolved: one where the
matrix multiplies a column vector, as described above, and another where a
row vector multiplies the matrix:
[x′
y′] = [x
y].

a
c
b
d

(7.17)
Note how the elements of the matrix are transposed to accommodate the
algebraic correctness of the transformation. There is no preferred system of
notation, and you will ﬁnd technical books and papers supporting both. For
example, Computer Graphics: Principles and Practice (Foley et al., 1990)
employs the column vector notation, whereas the Gems books (Glassner
et al., 1990) employ the row vector notation. The important thing to remem-
ber is that the rows and columns of the matrix are transposed when moving
between the two systems.
7.2.2 The Determinant of a Matrix
The determinant of a 2 × 2 matrix is a scalar quantity computed. Given a
matrix
a
b
c
d

its determinant is ad – cb and is represented by

a
b
c
d

(7.18)
For example, the determinant of
3
2
1
2

is 3 × 2 −1 × 2 = 4
Later, we will discover that the determinant of a 2 × 2 matrix determines
the change in area that occurs when a polygon is transformed by the matrix.
For example, if the determinant is 1, there is no change in area, but if the
determinant is 2, the polygon’s area is doubled.

7 Transformation
57
7.3 Homogeneous Coordinates
Homogeneous coordinates surfaced in the early 19th century, when they were
independently proposed by M¨obius (who also invented a one-sided curled
band, the M¨obius strip), Feuerbach, Bobillier, and Pl¨ucker. M¨obius named
them barycentric coordinates. They have also been called areal coordinates
because of their area-calculating properties.
Basically, homogeneous coordinates deﬁne a point in a plane using three
coordinates instead of two. Initially, Pl¨ucker located a homogeneous point
relative to the sides of a triangle, but later revised his notation to the one
employed in contemporary mathematics and computer graphics. This states
that for a point P with coordinates (x, y) there exists a homogeneous point
(x, y, t) such that X = x/t and Y = y/t. For example, the point (3, 4) has
homogeneous coordinates (6, 8, 2), because 3 = 6/2 and 4 = 8/2. But the
homogeneous point (6, 8, 2) is not unique to (3, 4); (12, 16, 4), (15, 20, 5) and
(300, 400, 100) are all possible homogeneous coordinates for (3, 4).
The reason why this coordinate system is called ‘homogeneous’ is because
it is possible to transform functions such as f (x, y) into the form f (x/t, y/t)
without disturbing the degree of the curve. To the non-mathematician this
may not seem anything to get excited about, but in the ﬁeld of projective
geometry it is a very powerful concept.
For our purposes, we can imagine that a collection of homogeneous points
of the form (x, y, t) exist on an xy-plane where t is the z-coordinate, as
illustrated in Figure 7.4. The ﬁgure shows a triangle on the t = 1 plane,
and a similar triangle, much larger, on a more distant plane. Thus instead
of working in two dimensions, we can work on an arbitrary xy-plane in three
dimensions. The t- or z-coordinate of the plane is immaterial because the
x- and y-coordinates are eventually scaled by t. However, to keep things simple
it seems a good idea to choose t = 1. This means that the point (x, y) has
homogeneous coordinates (x, y, 1), making scaling unnecessary.
If we substitute 3D homogeneous coordinates for traditional 2D Cartesian
coordinates, we must attach a 1 to every (x, y) pair. When a point (x, y, 1)
is transformed, it will emerge as (x′, y′, 1), and we discard the 1. This may
seem a futile exercise, but it resolves the problem of creating a translation
transformation.
Consider the following transformation on the homogeneous point (x, y, 1):
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
a
b
c
d
e
f
0
0
1
⎤
⎦.
⎡
⎣
x
y
1
⎤
⎦
(7.19)
This expands to
x′ = ax + by + c
y′ = dx + ey + f
1 = 1
(7.20)

58
Mathematics for Computer Graphics
Y
X
t
I
Fig. 7.4. 2D homogeneous coordinates can be visualized as a plane in 3D space,
generally where t = 1, for convenience.
which solves the above problem of adding a constant.
Let’s now go on to see how homogeneous coordinates are used in practice.
7.3.1 2D Translation
The algebraic and matrix notation for 2D translation is
x′ = x + tx
y′ = y + ty
(7.21)
or, using matrices,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.22)
7.3.2 2D Scaling
The algebraic and matrix notation for 2D scaling is
x′ = sxx
y′ = syy
(7.23)
or, using matrices,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
sx
0
0
0
sy
0
0
0
1
⎤
⎦.
⎡
⎣
x
y
1
⎤
⎦
(7.24)

7 Transformation
59
The scaling action is relative to the origin, i.e. the point (0,0) remains (0,0)
All other points move away from the origin. To scale relative to another point
(px, py) we ﬁrst subtract (px, py) from (x, y) respectively. This eﬀectively trans-
lates the reference point (px, py) back to the origin. Second, we perform the
scaling operation, and third, add (px, py) back to (x, y) respectively, to com-
pensate for the original subtraction. Algebraically this is
x′ = sx(x −px) + px
y′ = sy(y −py) + py
(7.25)
which simpliﬁes to
x′ = sxx + px(1 −sx)
y′ = syy + py(1 −sy)
(7.26)
or in a homogeneous matrix form
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
sx
0
px(1 −sx)
0
sy
py(1 −sy)
0
0
1
⎤
⎦.
⎡
⎣
x
y
1
⎤
⎦
(7.27)
For example, to scale a shape by 2 relative to the point (1, 1) the
matrix is
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
2
0
−1
0
2
−1
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
7.3.3 2D Reﬂections
The matrix notation for reﬂecting about the y-axis is:
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
−1
0
0
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.28)
or about the x-axis
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
0
0
−1
0
0
0
1
⎤
⎦.
⎡
⎣
x
y
1
⎤
⎦
(7.29)
However, to make a reﬂection about an arbitrary vertical or horizontal
axis we need to introduce some more algebraic deception. For example, to
make a reﬂection about the vertical axis x = 1, we ﬁrst subtract 1 from the
x-coordinate. This eﬀectively makes the x = 1 axis coincident with the major
y-axis. Next we perform the reﬂection by reversing the sign of the modiﬁed

60
Mathematics for Computer Graphics
x-coordinate. And ﬁnally, we add 1 to the reﬂected coordinate to compensate
for the original subtraction. Algebraically, the three steps are
x1 = x −1
x2 = −(x −1)
x′ = −(x −1) + 1
which simpliﬁes to
x′ = −x + 2
y′ = y
(7.30)
or in matrix form,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
−1
0
2
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.31)
Figure 7.5 illustrates this process.
In general, to reﬂect a shape about an arbitrary y-axis, y = ax, the fol-
lowing transform is required:
x′ = −(x −ax) + ax
= −x + 2ax
y′ = y
(7.32)
or, in matrix form,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
−1
0
2ax
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.33)
−2
−1
0
Y
X
1
2
3
4
Fig. 7.5. The shape on the right is reﬂected about the x = 1 axis.

7 Transformation
61
Similarly, this transform is used for reﬂections about an arbitrary x-axis,
y = ay:
x′ = x
y′ = −(y −ay) + ay = −y + 2ay
(7.34)
or, in matrix form,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
0
0
−1
2ay
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.35)
7.3.4 2D Shearing
A shape is sheared by leaning it over at an angle β. Figure 7.6 illustrates
the geometry, and we see that the y-coordinate remains unchanged but the
x-coordinate is a function of y and tan(β).
x′ = x + y tan(β)
y′ = y
(7.36)
or, in matrix form,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
tan(β)
0
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.37)
Sheared
y tan b
X
y
Y
Original
b
Fig. 7.6. The original square shape is sheared to the right by an angle β, and the
horizontal shift is proportional to ytan(β).

62
Mathematics for Computer Graphics
7.3.5 2D Rotation
Figure 7.7 shows a point P(x, y) which is to be rotated by an angle β about
the origin to P ′(x′, y′). It can be seen that
x′ = R cos(θ + β)
y′ = R sin(θ + β)
(7.38)
therefore
x′ = R(cos(θ) cos(β) −sin(θ) sin(β))
y′ = R(sin(θ) cos(β) + cos(θ) sin(β))
x′ = R
 x
R cos(β) −y
R sin(β)

y′ = R
 y
R cos(β) + x
R sin(β)

x′ = x cos(β) −y sin(β)
y′ = x sin(β) + y cos(β)
(7.39)
or, in matrix form,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
−sin(β)
0
sin(β)
cos(β)
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.40)
For example, to rotate a point by 90◦the matrix becomes
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
0
−1
0
1
0
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
b
y
y'
x'
x
X
Y
q
P(x, y)
P'(x', y')
Fig. 7.7. The point P(x, y) is rotated through an angle β to P ′(x′, y′).

7 Transformation
63
Thus the point (1, 0) becomes (0, 1). If we rotate by 360◦the matrix becomes
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
Such a matrix has a null eﬀect and is called an identity matrix.
To rotate a point (x, y) about an arbitrary point (px, py) we ﬁrst subtract
(px, py) from the coordinates (x, y) respectively. This enables us to perform
the rotation about the origin. Second, we perform the rotation, and third, we
add (px, py) to compensate for the original subtraction. Here are the steps:
1
Subtract (px, py):
x1 = (x −px)
y1 = (y −py)
2
Rotate β about the origin:
x2 = (x −px) cos(β) −(y −py) sin(β)
y2 = (x −px) sin(β) + (y −py) cos(β)
3
Add (px, py):
x′ = (x −px) cos(β) −(y −py) sin(β) + px
y′ = (x −px) sin(β) + (y −py) cos(β) + py
Simplifying,
x′ = x cos(β) −y sin(β) + px(1 −cos(β)) + py sin(β)
y′ = x sin(β) + y cos(β) + py(1 −cos(β)) −px sin(β)
(7.41)
and, in matrix form,
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
−sin(β)
px(1 −cos(β)) + py sin(β)
sin(β)
cos(β)
py(1 −cos(β)) −px sin(β)
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.42)
If we now consider rotating a point 90◦about the point (1, 1) the matrix
operation becomes
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
0
−1
2
1
0
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
A simple test is to substitute the point (2, 1) for (x, y): it is transformed
correctly to (1, 2).

64
Mathematics for Computer Graphics
The algebraic approach in deriving the above transforms is relatively easy.
However, it is also possible to use matrices to derive compound transforma-
tions, such as a reﬂection relative to an arbitrary line and scaling and rotation
relative to an arbitrary point. These transformations are called aﬃne, as paral-
lel lines remain parallel after being transformed. One cannot always guarantee
that angles and lengths are preserved, as the scaling transformation can alter
these when diﬀerent x and y scaling factors are used. For completeness, we
will repeat these transformations from a matrix perspective.
7.3.6 2D Scaling
The strategy we used to scale a point (x, y) relative to some arbitrary point
(px, py) was to ﬁrst, translate (−px, −py); second, perform the scaling; and
third, translate (px, py). These three transforms can be represented in matrix
form as follows:
⎡
⎣
x′
y′
1
⎤
⎦= [translate(px, py)] · [scale(sx, sy)] · [translate(−px, −py)] ·
⎡
⎣
x
y
1
⎤
⎦
which expands to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
px
0
1
py
0
0
1
⎤
⎦·
⎡
⎣
sx
0
0
0
sy
0
0
0
1
⎤
⎦·
⎡
⎣
1
0
−px
0
1
−py
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦(7.43)
Note the sequence of the transforms, as this often causes confusion. The ﬁrst
transform acting on the point (x, y, 1) is translate (−px, −py), followed by
scale (sx, sy), followed by translate (px, py). If they are placed in any other
sequence, you will discover, like Gauss, that transforms are not commutative!
We can now concatenate these matrices into a single matrix by multiplying
them together. This can be done in any sequence, so long as we preserve the
original order. Let’s start with scale (sx, sy) and translate (−px, −py). This
produces
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
px
0
1
py
0
0
1
⎤
⎦·
⎡
⎣
sx
0
−sxpx
0
sy
−sypy
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
and ﬁnally
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
sx
0
px(1 −sx)
0
sy
py(1 −sy)
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.44)
which is the same as the previous transform (7.27).

7 Transformation
65
7.3.7 2D Reﬂections
A reﬂection about the y-axis is given by
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
−1
0
0
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.45)
Therefore, using matrices, we can reason that a reﬂection transform about an
arbitrary axis x = ax, parallel with the y-axis, is given by
⎡
⎣
x′
y′
1
⎤
⎦= [translate(ax, 0)] · [reﬂection] · [translate(−ax, 0)] ·
⎡
⎣
x
y
1
⎤
⎦
which expands to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
ax
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
−1
0
0
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
1
0
−ax
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
We can now concatenate these matrices into a single matrix by multiplying
them together. Let’s begin by multiplying the reﬂection and the translate
(−ax, 0) matrices together. This produces
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
ax
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
−1
0
ax
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
and ﬁnally
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
−1
0
2ax
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.46)
which is the same as the previous transform (7.33).
7.3.8 2D Rotation about an Arbitrary Point
A rotation about the origin is given by
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
−sin(β)
0
sin(β)
cos(β)
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.47)
Therefore, using matrices, we can develop a rotation about an arbitrary point
(px, py) as follows:
⎡
⎣
x′
y′
1
⎤
⎦= [translate(px, py)] · [rotate β] · [translate(−px, −py)] ·
⎡
⎣
x
y
1
⎤
⎦

66
Mathematics for Computer Graphics
which expands to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
px
0
1
py
0
0
1
⎤
⎦·
⎡
⎣
cos(β)
−sin(β)
0
sin(β)
cos(β)
0
0
0
1
⎤
⎦·
⎡
⎣
1
0
−px
0
1
−py
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
We can now concatenate these matrices into a single matrix by multiplying
them together. Let’s begin by multiplying the rotate β and the translate
(−px, −py) matrices together. This produces
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
px
0
1
py
0
0
1
⎤
⎦·
⎡
⎣
cos(β) −sin(β) −px cos(β) + py sin(β)
sin(β)
cos(β) −px sin(β) −py cos(β)
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
and ﬁnally
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
−sin(β)
px(1 −cos(β)) + py sin(β)
sin(β)
cos(β)
py(1 −cos(β)) −px sin(β)
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦(7.48)
which is the same as the previous transform (7.42).
I hope it is now is obvious to the reader that one can derive all sorts of
transforms either algebraically, or by using matrices – it is just a question of
convenience.
7.4 3D Transformations
Now we come to transformations in three dimensions, where we apply the
same reasoning as in two dimensions. Scaling and translation are basically
the same, but where in 2D we rotated a shape about a point, in 3D we rotate
an object about an axis.
7.4.1 3D Translation
The algebra is so simple for 3D translation that we can write the homogeneous
matrix directly:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
1
0
0
tx
0
1
0
ty
0
0
1
tz
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.49)
7.4.2 3D Scaling
The algebra for 3D scaling is
x′ = sxx
y′ = syy
z′ = szz
(7.50)

7 Transformation
67
which in matrix form is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
sx
0
0
0
0
sy
0
0
0
0
sz
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.51)
The scaling is relative to the origin, but we can arrange for it to be relative
to an arbitrary point (px, py, pz) with the following algebra:
x′ = sx(x −px) + px
y′ = sy(y −py) + py
z′ = sz(z −pz) + pz
(7.52)
which in matrix form is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
sx
0
0
px(1 −sx)
0
sy
0
py(1 −sy)
0
0
sz
pz(1 −sz)
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.53)
7.4.3 3D Rotations
In two dimensions a shape is rotated about a point, whether it be the origin
or some arbitrary position. In three dimensions an object is rotated about an
axis, whether it be the x-, y- or z-axis, or some arbitrary axis. To begin with,
let’s look at rotating a vertex about one of the three orthogonal axes; such
rotations are called Euler rotations after the Swiss mathematician Leonhard
Euler (1707–1783).
Recall that a general 2D-rotation transform is given by
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
−sin(β)
0
sin(β)
cos(β)
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.54)
which in 3D can be visualized as rotating a point P(x, y, z) on a plane parallel
with the xy-plane as shown in Figure 7.8. In algebraic terms this can be written
as
x′ = x cos(β) −y sin(β)
y′ = x sin(β) + y cos(β)
z′ = z
(7.55)
Therefore, the 3D transform can be written as
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
cos(β)
−sin(β)
0
0
sin(β)
cos(β)
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.56)

68
Mathematics for Computer Graphics
Y
Z
X
b
P′(x′, y′, z′)
P(x, y, z)
Fig. 7.8. Rotating P about the z-axis.
which basically rotates a point about the z-axis.
When rotating about the x-axis, the x-coordinate remains constant while
the y- and z-coordinates are changed. Algebraically, this is
x′ = x
y′ = y cos(β) −z sin(β)
z′ = y sin(β) + z cos(β)
(7.57)
or, in matrix form,
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
1
0
0
0
0
cos(β)
−sin(β)
0
0
sin(β)
cos(β)
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.58)
When rotating about the y-axis, the y-coordinate remains constant while the
x- and z-coordinates are changed. Algebraically, this is
x′ = z sin(β) + x cos(β)
y′ = y
z′ = z cos(β) −x sin(β)
(7.59)
or, in matrix form,
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
cos(β)
0
sin(β)
0
0
1
0
0
−sin(β)
0
cos(β)
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.60)
Note that the matrix terms do not appear to share the symmetry seen in the
previous two matrices. Nothing has really gone wrong, it is just the way the
axes are paired together to rotate the coordinates.

7 Transformation
69
The above rotations are also known as yaw, pitch and roll. Great care
should be taken with these terms when referring to other books and technical
papers. Sometimes a left-handed system of axes is used rather than a right-
handed set, and the vertical axis may be the y-axis or the z-axis.
Consequently, the matrices representing the rotations can vary greatly. In
this text all Cartesian coordinate systems are right-handed, and the vertical
axis is always the y-axis.
The roll, pitch and yaw angles can be deﬁned as follows:
•
roll is the angle of rotation about the z-axis
•
pitch is the angle of rotation about the x-axis
•
yaw is the angle of rotation about the y-axis.
Figure 7.9 illustrates these rotations and the sign convention. The homo-
geneous matrices representing these rotations are as follows:
•
rotate roll about the z-axis:
⎡
⎢⎢⎣
cos(roll)
−sin(roll)
0
0
sin(roll)
cos(roll)
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
(7.61)
•
rotate pitch about the x-axis:
⎡
⎢⎢⎣
1
0
0
0
0
cos(pitch)
−sin(pitch)
0
0
sin(pitch)
cos(pitch)
0
0
0
0
1
⎤
⎥⎥⎦
(7.62)
•
rotate yaw about the y-axis:
⎡
⎢⎢⎣
cos(yaw)
0
sin(yaw)
0
0
1
0
0
−sin(yaw)
0
cos(yaw)
0
0
0
0
1
⎤
⎥⎥⎦
(7.63)
pitch
roll
yaw
Z
X
Y
Fig. 7.9. The convention for roll, pitch and yaw angles.

70
Mathematics for Computer Graphics
A common sequence for applying these rotations is roll, pitch, yaw, as seen
in the following transform:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= [yaw] · [pitch] · [roll] ·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.64)
and if a translation is involved,
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= [translate] · [yaw] · [pitch] · [roll] ·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.65)
When these rotation transforms are applied, the vertex is ﬁrst rotated about
the z-axis (roll), followed by a rotation about the x-axis (pitch), followed by a
rotation about the y-axis (yaw). Euler rotations are relative to the ﬁxed frame
of reference. This is not always easy to visualize, as one’s attention is normally
with the rotating frame of reference. Let’s consider a simple example where
an axial system is subjected to a pitch rotation followed by a yaw rotation
relative to ﬁxed frame of reference.
We begin with two frames of reference XYZ and X′Y ′Z′ mutually aligned.
Figure 7.10 shows the orientation of X′Y ′Z′ after it is subjected to a pitch of
90◦about the x-axis. Figure 7.11 shows the the ﬁnal orientation after X′Y ′Z′
is subjected to a yaw of 90◦about the y-axis.
7.4.4 Gimbal Lock
Let’s take another example starting from the point where the two axial sys-
tems are mutually aligned. Figure 7.12 shows the orientation of X′Y ′Z′ after
it is subjected to a roll of 45◦about the z-axis, and Figure 7.13 shows the
orientation of X′Y ′Z′ after it is subjected to a pitch of 90◦about the x-axis.
Now the interesting thing about this orientation is that if we now performed
Y′
Z ′
X′
X
Z
Y
pitch = 90
Fig. 7.10. The X′Y ′Z′ axial system after a pitch of 90◦.

7 Transformation
71
X′
Y′
Z′
X
Z
Y
yaw = 90
Fig. 7.11. The X′Y ′Z′ axial system after a yaw of 90◦.
X′
Y′
Z′
Y
Z
X
roll = 45
Fig. 7.12. The X′Y ′Z′ axial system after a roll of 45◦.
X′
Z′
Y′
Z
X
Y
pitch = 90
Fig. 7.13. The X′Y ′Z′ axial system after a pitch of 90◦.
a yaw of 45◦about the z-axis, it would rotate the x′-axis towards the x-axis,
counteracting the eﬀect of the original roll. yaw has become a negative roll
rotation, caused by the 90◦pitch. This situation is known as gimbal lock, be-
cause one degree of rotational freedom has been lost. Quite innocently, we
have stumbled across one of the major weaknesses of Euler angles: under cer-
tain conditions it is only possible to rotate an object about two axes. One
way of preventing this is to create a secondary set of axes constructed from
three orthogonal vectors that are also rotated alongside an object or virtual

72
Mathematics for Computer Graphics
camera. But instead of making the rotations relative to the ﬁxed frame of
reference, the roll, pitch and yaw rotations are relative to the rotating frame
of reference. Another method is to use quaternions, which will be investigated
later in this chapter.
7.4.5 Rotating about an Axis
The above rotations were relative to the x-, y- and z-axes. Now let’s consider
rotations about an axis parallel to one of these axes. To begin with, we will
rotate about an axis parallel with the z-axis, as shown in Figure 7.14. The
scenario is very reminiscent of the 2D case for rotating a point about an
arbitrary point, and the general transform is given by
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= [translate(px, py, 0)].[rotateβ].[translate(−px, −py, 0)].
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.66)
and the matrix is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
cos(β)
−sin(β)
0
px(1 −cos(β)) + py sin(β)
sin(β)
cos(β)
0
py(1 −cos(β)) −px sin(β)
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.67)
I hope you can see the similarity between rotating in 3D and 2D: the x- and
y-coordinates are updated while the z-coordinate is held constant. We can
P′ (x′, y′, z′)
P (x, y, z)
X
Z
Y
px
py
b
z′ = z
Fig. 7.14. Rotating a point about an axis parallel with the z-axis.

7 Transformation
73
now state the other two matrices for rotating about an axis parallel with the
x-axis and parallel with the y-axis:
•
rotating about an axis parallel with the x-axis:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
1
0
0
0
0
cos(β)
−sin(β)
py(1 −cos(β)) + pz sin(β)
0
sin(β)
cos(β)
pz(1 −cos(β)) −py sin(β)
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.68)
•
rotating about an axis parallel with the y-axis:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
cos(β)
0
sin(β)
px(1 −cos(β)) −pz sin(β)
0
1
0
0
−sin(β)
0
cos(β)
pz(1 −cos(β)) + px sin(β)
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.69)
7.4.6 3D Reﬂections
Reﬂections in 3D occur with respect to a plane, rather than an axis. The
matrix giving the reﬂection relative to the yz-plane is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
−1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.70)
and the reﬂection relative to a plane parallel to, and ax units from, the yz-
plane is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
−1
0
0
2ax
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.71)
It is left to the reader to develop similar matrices for the other major axial
planes.
7.5 Change of Axes
Points in one coordinate system often have to be referenced in another one.
For example, to view a 3D scene from an arbitrary position, a virtual camera
is positioned in the world space using a series of transformations. An object’s

74
Mathematics for Computer Graphics
coordinates, which are relative to the world frame of reference, are computed
relative to the camera’s axial system, and then used to develop a perspective
projection. Before explaining how this is achieved in 3D, let’s examine the
simple case of changing axial systems in two dimensions.
7.5.1 2D Change of Axes
Figure 7.15 shows a point P(x, y) relative to the XY -axes, but we require to
know the coordinates relative to the X′Y ′-axes. To do this, we need to know
the relationship between the two coordinate systems, and ideally we want to
apply a technique that works in 2D and 3D. If the second coordinate system
is a simple translation (tx, ty) relative to the reference system, as shown in
Figure 7.15, the point P(x, y) has coordinates relative to the translated system
(x −tx, y −ty):
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.72)
If the X′Y ′-axes are rotated β relative to the XY -axes, as shown in Figure 7.16,
a point P(x, y) relative to the XY -axes has coordinates (x′, y′) relative to the
rotated axes given by
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(−β)
−sin(−β)
0
sin(−β)
cos(−β)
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
which simpliﬁes to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
sin(β)
0
−sin(β)
cos(β)
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.73)
X′
Y′
tx
ty
X
Y
P(x, y ) = P′(x′, y′)
Fig. 7.15. The X′Y ′-axes are translated by (tx, ty).

7 Transformation
75
b
y
X
x
x'
Y'
y'
X'
Y
P (x, y)
P' (x', y')
Fig. 7.16. The secondary set of axes are rotated by β.
When a coordinate system is rotated and translated relative to the refer-
ence system, a point P(x, y) has coordinates (x′, y′) relative to the new axes
given by
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
sin(β)
0
−sin(β)
cos(β)
0
0
0
1
⎤
⎦·
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
which simpliﬁes to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(β)
sin(β)
−tx cos(β) −ty sin(β)
−sin(β)
cos(β)
tx sin(β) −ty cos(β)
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
(7.74)
7.6 Direction Cosines
Direction cosines are the cosines of the angles between a vector and the axes,
and for unit vectors they are the vector’s components. Figure 7.17 shows two
unit vectors X′ and Y ′, and by inspection the direction cosines for X′ are
cos(β) and cos(90◦−β), which can be rewritten as cos(β) and sin(β), and the
direction cosines for Y ′ cos(90◦+ β) and cos(β), which can be rewritten as
−sin(β) and cos(β). But these direction cosines cos(β), sin(β), −sin(β) and
cos(β) are the four elements of the rotation matrix used above:

cos(β)
sin(β)
−sin(β)
cos(β)

(7.75)
The top row contains the direction cosines for the X′-axis and the bottom
row contains the direction cosines for the Y ′-axis. This relationship also holds
in 3D.

76
Mathematics for Computer Graphics
b
b
90−b
Y
Y'
X'
X
Fig. 7.17. If the X′- and Y ′-axes are assumed to be unit vectors their direction cosines
form the elements of the rotation matrix.
Before exploring changes of axes in 3D let’s evaluate a simple example in
2D where a set of axes is rotated 45◦as shown in Figure 7.18. The appropriate
transform is
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cos(45◦)
sin(45◦)
0
−sin(45◦)
cos(45◦)
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
=
⎡
⎣
0.707
0.707
0
−0.707
0.707
0
0
0
1
⎤
⎦·
⎡
⎣
x
y
1
⎤
⎦
The four vertices on a unit square become
(0, 0) →(0, 0)
(1, 0) →(0.707, −0.707)
(1, 1) →(1.414, 0)
(0, 1) →(0.707, 0.707)
which inspection of Figure 7.18 shows to be correct.
Y'
Y
(0,1)
X'
X
(0.707, 0.707)'
(1,0)
(0.707, −0.707)'
(1,1)
(1.414, 0)'
Fig. 7.18. The vertices of a unit square relative to the two axial systems.

7 Transformation
77
7.6.1 Positioning the Virtual Camera
Four coordinate systems are used in the computer graphics pipeline: object
space, world space, camera space and image space.
•
The object space is a domain where objects are modelled and assembled.
•
The world space is where objects are positioned and animated through
appropriate transforms. The world space also hosts a virtual camera or
observer.
•
The camera space is a transform of the world space to the camera’s point
of view.
•
Finally, the image space is a projection – normally perspective – of the
camera space onto an image plane.
The transforms considered so far are used to manipulate and position ob-
jects within the world space. What we will consider next is how a virtual
camera or observer is positioned in world space, and the process of convert-
ing world coordinates to camera coordinates. The procedure used generally
depends on the method employed to deﬁne the camera’s frame of reference
within the world space, which may involve the use of direction cosines, Euler
angles or quaternions. We will examine how each of these techniques could be
implemented.
7.6.2 Direction Cosines
A 3D unit vector has three components [x y z]T, which are equal to the cosines
of the angles formed between the vector and the three orthogonal axes. These
angles are known as direction cosines and can be computed taking the dot
product of the vector and the Cartesian unit vectors. Figure 7.19 shows the
direction cosines and the angles. These direction cosines enable any point P(x,
y, z) in one frame of reference to be transformed into P ′(x′, y′, z′) in another
frame of reference as follows:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
r11
r12
r13
0
r21
r22
r23
0
r31
r32
r33
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.76)
where: r11, r12, r13 are the direction cosines of the secondary x-axis
r21, r22, r23 are the direction cosines of the secondary y-axis
r31, r32, r33 are the direction cosines of the secondary z-axis.
To illustrate this operation, consider the situation shown in Figure 7.20
which shows two axial systems mutually aligned. Evaluating the direction
cosines results in the following matrix transformation:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦

78
Mathematics for Computer Graphics
Y
cos b
cos q
cos a
b
q
a
Z
X
Fig. 7.19. The components of a unit vector are equal to the cosines of the angles
between the vector and the axes.
Z
Z'
X'
X
Y
Y'
Fig. 7.20. Two axial systems mutually aligned.
which is the identity matrix and implies that (x′, y′, z′) = (x, y, z).
Figure 7.21 shows another situation, and the associated transform is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
0
1
0
0
−1
0
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
Substituting the (1, 1, 0) for (x, y, z) produces values of (1, −1, 0) for (x′, y′, z′)
in the new frame of reference, which by inspection is correct.
If the virtual camera is oﬀset by (tx, ty, tz) the transform relating points
in world space to camera space can be expressed as a compound operation

7 Transformation
79
Z
Z'
X'
X
Y
X'
Y'
Fig. 7.21. The X′Y ′Z′ axial system after a roll of 90◦.
consisting of a translation back to the origin, followed by a change of axial
systems. This can be expressed as
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
r11
r12
r13
0
r21
r22
r23
0
r31
r32
r33
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.77)
As an example, consider the situation shown in Figure 7.22. The values of
(tx, ty, tz) are (10, 1, 1), and the direction cosines are as shown in the following
matrix operation:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
−1
0
0
0
0
1
0
0
0
0
−1
0
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
1
0
0
−10
0
1
0
−1
0
0
1
−1
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
which concatenates to
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
−1
0
0
10
0
1
0
−1
0
0
−1
1
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
Substituting (0, 0, 0) for (x, y, z) in the above transform produces (10, −1, 1)
for (x′, y′, z′), which can be conﬁrmed from Figure 7.22. Similarly, substituting
(0, 1, 1) for (x, y, z) produces (10,0,0) for (x′, y′, z′), which is also correct.
7.6.3 Euler Angles
Another approach for locating the virtual camera involves Euler angles, but
we must remember that they suﬀer from gimbal lock (see page 70). However, if

80
Mathematics for Computer Graphics
X′
Z′
Y′
Y
Z
10
1
1
X
(0, 1, 1)
Fig. 7.22. The secondary axial system is subject to a yaw of 180◦and an oﬀset of
(10, 1, 1).
the virtual camera is located in world space using Euler angles, the transform
relating world coordinates to camera coordinates can be derived from the
inverse operations. The yaw, pitch, roll matrices described above are called
orthogonal matrices, as the inverse matrix is the transpose of the original rows
and columns. Consequently, to rotate through angles –roll, –pitch and –yaw,
we use
•
rotate –roll about the z-axis:
⎡
⎢⎢⎣
cos(roll)
sin(roll)
0
0
−sin(roll)
cos(roll)
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
(7.78)
•
rotate –pitch about the x-axis:
⎡
⎢⎢⎣
1
0
0
0
0
cos(pitch)
sin(pitch)
0
0
−sin(pitch)
cos(pitch)
0
0
0
0
1
⎤
⎥⎥⎦
(7.79)
•
rotate –yaw about the y-axis:
⎡
⎢⎢⎣
cos(yaw)
0
−sin(yaw)
0
0
1
0
0
sin(yaw)
0
cos(yaw)
0
0
0
0
1
⎤
⎥⎥⎦
(7.80)

7 Transformation
81
The same result is obtained simply by substituting –roll, –pitch, –yaw in the
original matrices. As described above, the virtual camera will normally be
translated from the origin by (tx, ty, tz), which implies that the transform
from the world space to the camera space must be evaluated as follows:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= [−roll]·[−pitch]·[−yaw]·[−translate(−tx, −ty, −tz)·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦(7.81)
which can be represented by a single homogeneous matrix:
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
T11
T12
T13
T14
T21
T22
T23
T24
T31
T32
T33
T34
T41
T42
T43
T44
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.82)
where
T11 = cos(yaw) cos(roll) + sin(yaw) sin(pitch) sin(roll)
T12 = cos(pitch) sin(roll)
T13 = −sin(yaw) cos(roll) + cos(yaw) sin(pitch) sin(roll)
T14 = −(txT11 + tyT12 + tzT13)
T21 = −cos(yaw) sin(roll) + sin(yaw) sin(pitch) cos(roll)
T22 = cos(pitch) cos(roll)
T23 = sin(yaw) sin(roll) + cos(yaw) sin(pitch) cos(roll)
T24 = −(txT21 + tyT22 + tzT23)
T31 = sin(yaw) cos(pitch)
T32 = −sin(pitch)
T33 = cos(yaw) cos(pitch)
T34 = −(txT31 + tyT32 + tzT33)
T41 = 0
T42 = 0
T43 = 0
T44 = 1
(7.83)
This, too, can be veriﬁed by a simple example. For instance, consider the
situation shown in Figure 7.22 where the following conditions prevail:
roll = 0◦
pitch = 0◦
yaw = 180◦
tx = 10

82
Mathematics for Computer Graphics
ty = 1
tz = 1
The transform is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
−1
0
0
10
0
1
0
−1
0
0
−1
1
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
which is identical to the equation used for direction cosines. Another example
is shown in Figure 7.23, where the following conditions exist:
roll = 90◦
pitch = 180◦
yaw = 0◦
tx = 0.5
ty = 0.5
tz = 11
The transform is
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
0
−1
0
0.5
−1
0
0
0.5
0
0
−1
11
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
Substituting (1, 1, 1) for (x, y, z) produces (−0.5, −0.5, 10) for (x′, y′, z′). Sim-
ilarly, substituting (0, 0, 1) for (x, y, z) produces (0.5, 0.5, 10) for (x′, y′, z′),
which can be visually veriﬁed from Figure 7.23.
(1, 1, 1)
Y
X
Z′
Y′
Z
X′
(0.5, 0.5, 11)
Fig. 7.23. The secondary axial system is subjected to a roll of 90◦, a pitch of 180◦,
and a translation of (0.5, 0.5, 11).

7 Transformation
83
7.7 Rotating a Point about an Arbitrary Axis
Let us now consider two ways of developing a matrix for rotating a point
about an arbitrary axis. The ﬁrst approach employs vector analysis and is
quite succinct. The second technique, however, is less analytical and relies on
matrices and trigonometric evaluation and is rather laborious. Fortunately,
they both arrive at the same result!
Figure 7.24 shows three views of the geometry associated with the task
at hand. The left-hand image illustrates the overall scenario; the middle im-
age illustrates a side elevation; whilst the right-hand image illustrates a plan
elevation.
r
r
N
O
O
N
N
P'
P'
P
r
r
p'
P
P
Q
Q
a
a
q
q
p
p
n
n
w
n
n
Fig. 7.24. Three views of the geometry associated with rotating a point about an
arbitrary axis.
The axis of rotation is given by the unit vector ˆv = ai + bj + ck
P(xp, yp, zp) is the point to be rotated by angle α and P ′(x′
p, y′
p, z′
p) is the
rotated point.
O is the origin, whilst p and p′ are position vectors for P and P ′ respec-
tively.
From Figure 7.24
p′ = −−→
ON + −−→
NQ + −−→
QP ′
To ﬁnd −−→
ON
∥n∥= ∥p∥cos θ = ˆn.p
therefore
−−→
ON = n = ˆn(ˆn.p)

84
Mathematics for Computer Graphics
To ﬁnd −−→
NQ
−−→
NQ = NQ
NP r = NQ
NP ′ r = cos α · r
but
p = n + r = ˆn(ˆn.p) + r
therefore
r = p −ˆn(ˆn.p)
and
−−→
NQ = [p −ˆn(ˆn.p)] cos α
To ﬁnd −−→
QP ′
Let
ˆn × p = w
where
∥w∥= ∥ˆn∥· ∥p∥sin θ = ∥p∥sin θ
but
∥r∥= ∥p∥sin θ
therefore
∥w∥= ∥r∥
Now
QP ′
NP ′ = QP ′
∥r∥= QP ′
∥w∥= sin α
therefore
−−→
QP ′ = w sin α = (ˆn × p) sin α
then
p′ = ˆn(ˆn.p) + [p −ˆn(ˆn.p)] cos α + (ˆn × p) sin α
and
p′ = p cos α + ˆn(ˆn.p)(1 −cos α) + (ˆn × p) sin α
Let
K = 1 −cos α
then
p′ = p cos α + ˆn(ˆn.p)K + (ˆn × p) sin α

7 Transformation
85
and
p′ = (xpi + ypj + zpk) cos α + (ai + bj + ck) (axp + byp + czp) K
+ [(bzp −cyp) i + (cxp −azp) j + (ayp −bxp) k] sin α
p′ = [xp cos α + a (axp + byp + czp) K + (bzp −cyp) sin α] i
+ [yp cos α + b (axp + byp + czp) K + (cxp −azp) sin α] j
+ [zp cos α + c (axp + byp + czp) K + (ayp −bxp) sin α] k
p′ =

xp

a2K + cos α

+ yp (abK −c sin α) + zp (acK + b sin α)

i
+

xp (abK + c sin α) + yp

b2K + cos α

+ zp (bcK −a sin α)

j
+

xp (acK −b sin α) + yp (bcK + a sin α) + zp

c2K + cos α

k
and the transformation becomes
⎡
⎣
x′
p
y′
p
z′
p
⎤
⎦=
⎡
⎣
a2K + cos α
abK −c sin α
acK + b sin α
abK + c sin α
b2K + cos α
bcK −a sin α
acK −b sin α
bcK + a sin α
c2K + cos α
⎤
⎦·
⎡
⎣
xp
yp
zp
⎤
⎦
where K = 1 −cos α.
Now let’s approach the problem using transforms and trigonometric identities.
Figure 7.25 shows a point P (x, y, z) to be rotated through an angle α to
P ′(x′, y′, z′) about an axis deﬁned by v = ai + bj + ck where ∥v∥= 1.
The transforms to achieve this operation can be expressed as follows
⎡
⎣
x′
y′
z′
⎤
⎦= T5 × T4 × T3 × T2 × T1 ×
⎡
⎣
x
y
z
⎤
⎦
which aligns the axis of rotation with the x-axis, performs the rotation of Pα
about the x-axis, and returns the axis of rotation to its original position.
P
b
v
a
c
Y
Z
X
a
q
f
P'
Fig. 7.25. The geometry associated with rotating a point about an arbitrary axis.

86
Mathematics for Computer Graphics
Therefore
T1 rotates φ about the y-axis
T2 rotates −θ about the z-axis
T3 rotates α about the x-axis
T4 rotates θ about the z-axis
T5 rotates −φ about the y-axis
where
T1 =
⎡
⎣
cos φ
0
sin φ
0
1
0
−sin φ
0
cos φ
⎤
⎦
T2 =
⎡
⎣
cos θ
sin θ
0
−sin θ
cos θ
0
0
0
1
⎤
⎦
T3 =
⎡
⎣
1
0
0
0
cos α
−sin α
0
sin α
cos α
⎤
⎦
T4 =
⎡
⎣
cos θ
−sin θ
0
sin θ
cos θ
0
0
0
1
⎤
⎦
T5 =
⎡
⎣
cos φ
0
−sin φ
0
1
0
sin φ
0
cos φ
⎤
⎦
Let
T1 × T2 × T3 × T4 × T5 =
⎡
⎣
E1,1
E1,2
E1,3
E2,1
E2,2
E2,3
E3,1
E3,2
E3,3
⎤
⎦
From Figure 7.25
cos θ =

1 −b2 ⇒cos2 θ = 1 −b2
sin θ = b ⇒sin2 θ = b2
cos φ =
a
√
1 −b2 ⇒cos2 φ =
a2
1 −b2
sin φ =
c
√
1 −b2 ⇒sin2 φ =
c2
1 −b2
To ﬁnd E1,1
E1,1 = cos2 φ cos2 θ + cos2 φ sin2 θ cos α + sin2 φ cos α
E1,1 =
a2
1 −b2 ·

1 −b2
+
a2
1 −b2 · b2 cos α +
c2
1 −b2 cos α
E1,1 = a2 + a2b2
1 −b2 cos α +
c2
1 −b2 cos α
E1,1 = a2 +
c2 + a2b2
1 −b2

cos α

7 Transformation
87
but
a2 + b2 + c2 = 1 ⇒c2 = 1 −a2 −b2
substituting c2 in E1,1
E1,1 = a2 +
1 −a2 −b2 + a2b2
1 −b2

cos α
E1,1 = a2 +

1 −a2 
1 −b2
1 −b2
cos α
E1,1 = a2 +

1 −a2
cos α
E1,1 = a2 (1 −cos α) + cos α
Let
K = 1 −cos α
then
E1,1 = a2K + cos α
To ﬁnd E1,2
E1,2 = cos φ cos θ sin θ −cos φ sin θ cos θ cos α −sin φ cos θ sin α
E1,2 =
a
√
1 −b2 ·

1 −b2 · b −
a
√
1 −b2 · b ·

1 −b2 cos α
−
c
√
1 −b2 ·

1 −b2 sin α
E1,2 = ab −ab cos α −c sin α
E1,2 = ab (1 −cos α) −c sin α
E1,2 = abK −c sin α
To ﬁnd E1,3
E1,3 = cos φ sin φ cos2 θ + cos φ sin φ sin2 θ cos α + sin2 φ sin θ sin α
+ cos2 φ sin θ sin α −cos φ sin φ cos α
E1,3 = cos φ sin φ cos2 θ + cos φ sin φ sin2 θ cos α + sin θ sin α

sin2 φ + cos2 φ

−cos φ sin φ cos α
E1,3 = cos φ sin φ cos2 θ + cos φ sin φ sin2 θ cos α + sin θ sin α −cos φ sin φ cos α
E1,3 =
a
√
1 −b2 ·
c
√
1 −b2 ·

1 −b2
+
a
√
1 −b2 ·
c
√
1 −b2 · b2 cos α + b sin α
−
a
√
1 −b2 ·
c
√
1 −b2 cos α

88
Mathematics for Computer Graphics
E1,3 = ac + ac ·
b2
(1 −b2) cos α + b sin α −
ac
(1 −b2) cos α
E1,3 = ac + ac ·

b2 −1

(1 −b2) cos α + b sin α
E1,3 = ac (1 −cos α) + b sin α
E1,3 = acK + b sin α
To ﬁnd E2,1
E2,1 = sin θ cos θ cos φ −cos θ sin θ cos φ cos α + cos θ sin φ sin α
E2,1 = b
√
1 −b ·
a
√
1 −b2 −

1 −b2 · b ·
a
√
1 −b2 cos α
+

1 −b2 ·
c
√
1 −b2 sin α
E2,1 = ab −ab cos α + c sin α
E2,1 = ab(1 −cos α) + c sin α
E2,1 = abK + c sin α
To ﬁnd E2,2
E2,2 = sin2 θ + cos2 θ cos α
E2,2 = b2 +

1 −b2
cos α
E2,2 = b2 + cos α −b2 cos α
E2,2 = b2(1 −cos α) + cos α
E2,2 = b2K + cos α
To ﬁnd E2,3
E2,3 = sin θ cos θ sin φ −cos θ sin θ sin φ cos α −cos θ cos φ sin α
E2,3 = b ·

1 −b2 ·
c
√
1 −b2 −

1 −b2 · b ·
c
√
1 −b2 cos α
−

1 −b2 ·
a
√
1 −b2 sin α
E2,3 = bc −bc cos α −a sin α
E2,3 = bc(1 −cos α) −a sin α
E2,3 = bcK −a sin α
To ﬁnd E3,1
E3,1 = cos φ sin φ cos2 θ + cos φ sin φ sin2 θ cos α −cos2 φ sin θ sin α
−cos φ sin φ cos α
E3,1 =
a
√
1 −b2 ·
c
√
1 −b2 ·

1 −b2
+
a
√
1 −b2 ·
c
√
1 −b2 · b2 cos α
−sin θ sin α

cos2 φ + sin2 φ

−
a
√
1 −b2 ·
c
√
1 −b2 cos α

7 Transformation
89
but
sin2 φ + cos2 φ = 1
E3,1 = ac −
ac
1 −b2

1 −b2
cos α −b sin α
E3,1 = ac −ac cos α −b sin α
E3,1 = ac (1 −cos α) −b sin α
E3,1 = acK −b sin α
To ﬁnd E3,2
E3,2 = sin φ cos θ sin θ −sin φ sin θ cos θ cos α + cos φ cos θ sin α
E3,2 =
c
√
1 −b2 ·

1 −b2 · b −
c
√
1 −b2 · b ·

1 −b2 · cos α
+
a
√
1 −b2 ·

1 −b2 · sin α
E3,2 = bc −bc cos α + a sin α
E3,2 = bc(1 −cos α) + a sin α
E3,2 = bcK + a sin α
To ﬁnd E3,3
E3,3 = sin2 φ cos2 θ + sin2 φ sin2 θ cos α −cos φ sin φ sin θ sin α
+ cos φ sin φ sin θ sin α + cos2 φ cos α
E3,3 =
c2
1 −b2 ·

1 −b2
+
c2
1 −b2 · b2 cos α +
a2
1 −b2 cos α
E3,3 = c2 + b2c2
1 −b2 cos α +
a2
1 −b2 cos α
E3,3 = c2 +
b2c2 + a2
1 −b2

cos α
but
a2 = 1 −b2 −c2
E3,3 = c2 +
b2c2 + 1 −b2 −c2
1 −b2

cos α
E3,3 = c2 +

1 −b2)(1 −c2
1 −b2
cos α
E3,3 = c2 +

1 −c2
cos α
E3,3 = c2 (1 −cos α) + cos α
E3,3 = c2K + cos α

90
Mathematics for Computer Graphics
Therefore the transform is
⎡
⎣
x′
y′
z′
⎤
⎦=
⎡
⎣
a2K + cos α
abK −c sin α
acK + b sin α
abK + c sin α
b2K + cos α
bcK −a sin α
acK −b sin α
bcK + a sin α
c2K + cos α
⎤
⎦·
⎡
⎣
x
y
z
⎤
⎦
where
K = 1 −cos α
Which is identical to the transformation derived from the ﬁrst approach.
Now let’s test the matrix with a simple example that can be easily veriﬁed.
If we rotate the point P (10,5,0), 360◦about an axis deﬁned by v = i + j + k,
it should return to itself producing P ′ (10,5,0).
Therefore
α = 360◦
cos α = 1
sin α = 0
K = 0
and
a = 1
b = 1
c = 1
⎡
⎣
x′
y′
z′
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦·
⎡
⎣
10
5
0
⎤
⎦
As the matrix is an identity matrix P ′ = P.
7.7.1 Quaternions
As mentioned earlier, quaternions were invented by Sir William Rowan Hamil-
ton in the mid 19th century. Sir William was looking for a way to represent
complex numbers in higher dimensions, and it took 15 years of toil before he
stumbled upon the idea of using a 4D notation -hence the name ‘quaternion’.
Since this discovery, mathematicians have shown that quaternions can be
used to rotate points about an arbitrary axis, and hence the orientation of
objects and the virtual camera. In order to develop the equation that performs
this transformation we will have to understand the action of quaternions in
the context of rotations.
A quaternion q is a quadruple of real numbers and is deﬁned as
q = [s, v]
(7.84)
where s is a scalar and is a 3D vector. If we express the vector in terms of its
components, we have in an algebraic form
q = [s + xi + yj + zk]
(7.85)
where s, x, y and z are real numbers.

7 Transformation
91
7.7.2 Adding and Subtracting Quaternions
Given two quaternions q1 and q2,
q1 = [s1, v1] = [s1 + x1i + y1j + z1k]
q2 = [s2, v2] = [s2 + x2i + y2j + z2k]
(7.86)
they are equal if, and only if, their corresponding terms are equal. Further-
more, like vectors, they can be added and subtracted as follows:
q1 ± q2 = [(s1 ± s2) + (x1 ± x2)i + (y1 ± y2)j + (z1 ± z2)k]
(7.87)
7.7.3 Multiplying Quaternions
Hamilton discovered that special rules must be used when multiplying quater-
nions:
i2 = j2 = k2 = ijk = −1
ij = k, jk = i, ki = j
ji = −k, kj = −i, ik = −j
(7.88)
Note that although quaternion addition is commutative, the rules make quater-
nion multiplication non-commutative.
Given two quaternions q1 and q2,
q1 = [s1, v1] = [s1 + x1i + y1j + z1k]
q2 = [s2, v2] = [s2 + x2i + y2j + z2k]
(7.89)
the product q1q2, is given by
q1q2 = [(s1s2 −x1x2 −y1y2 −z1z2) + (s1x2 + s2x1 + y1z2 −y2z1)i
+(s1y2 + s2y1 + z1x2 −z2x1)j + (s1z2 + s2z1 + x1y2 −x2y1)k
(7.90)
which can be rewritten using the dot and cross product notation as
q1q2 = [(s1s2 −v1 · v2), s1v2 + s2v1 + v1 × v2]
(7.91)
7.7.4 The Inverse Quaternion
Given the quaternion
q = [s + xi + yj + zk]
(7.92)
the inverse quaternion q−1 is
q−1 = [s −xi −yj −zk]
|q|2
(7.93)

92
Mathematics for Computer Graphics
where |q| is the magnitude, or modulus, of q, and is equal to
∥q∥=

s2 + x2 + y2 + z2
(7.94)
It can also be shown that
qq−1 = q−1q = 1
(7.95)
7.7.5 Rotating Points about an Axis
Basically, quaternions are associated with vectors rather than individual points.
Therefore, in order to manipulate a single vertex, we must ﬁrst turn it into a
position vector, which has its tail vertex at the origin. A vertex can then be
represented in quaternion form by its equivalent position vector and a zero
scalar term. For example, a point P(x, y, z) is represented in quaternion form
by
p = [0 + xi + yj + zk]
(7.96)
which can then be transformed into another position vector using the process
described below. The coordinates of the rotated point are the components of
the rotated position vector. This may seem an indirect process, but in reality
it turns out to be rather simple. Let’s now consider how this is achieved.
It can be shown that a position vector p can be rotated about an axis by
some angle using the following operation:
p′ = qpq−1
(7.97)
where the axis and angle of rotation are encoded within the unit quaternion
q, whose modulus is 1, and p′ is the rotated vector. For example, to rotate a
point P(x, y, z) through an angle θ about an axis, we use the following steps:
1
Convert the point P(x, y, z) to a quaternion p:
p = [0 + xi + yj + zk]
2
Deﬁne the axis of rotation as a unit vector u:
u = [xui + yuj + zuk]
3
Deﬁne the transforming quaternion q:
q = [cos(θ/2), sin(θ/2)u]
4
Deﬁne the inverse of the transforming quaternion q−1:
q−1 = [cos(θ/2), −sin(θ/2)u]
5
Compute p′:
p′ = qpq−1

7 Transformation
93
6
Unpack (x′, y′, z′)
(x′, y′, z′)
p′ = [0 + x′i + y′j + z′k]
We can verify the action of the above transform with a simple example. Con-
sider the point P(0, 1, 1) in Figure 7.26 which is to be rotated 90◦about the
y-axis. We can see that the rotated point P ′ has the coordinates (1, 1, 0),
which we will conﬁrm algebraically. The point P is represented by a quater-
nion P, and is rotated by evaluating the quaternion P′:
Z
X
Y
P(0, 1, 1)
P′(1, 1,0)
Fig. 7.26. The point P(0, 1, 1) is rotated to P ′(1, 1, 0) using a quaternion coincident
with the y-axis.
P′ = qPq−1
which will store the rotated coordinates. The axis of rotation is [j], therefore
the unit quaternion q is given by
q = [cos(90◦/2), sin(90◦/2)[0, 1, 0]]
= [cos(45◦), [0, sin(45◦), 0]]
The inverse quaternion q−1 is given by
q−1 = [cos(90◦/2), −sin(90◦/2)[0, 1, 0]]
|q|2
but as q is a unit quaternion, the denominator |q|2 equals unity and can be
ignored. Therefore
q−1 = [cos(45◦), [0, −sin(45◦)0]]
Let’s evaluate qPq−1 in two stages: (qP)q−1.
1
qP = [cos(45◦), [0, sin(45◦), 0] ] · [0, [0, 1, 1]]
= [−sin(45◦), [sin(45◦), cos(45◦), cos(45◦)]]

94
Mathematics for Computer Graphics
2
(qP)q−1 = [−sin(45◦), [sin(45◦), cos(45◦), cos(45◦)] ]
·[cos(45◦), [0, −sin(45◦), 0] ]
= [0, [2 sin(45◦) cos(45◦), 1, cos(45◦) cos(45◦) −sin(45◦) sin(45◦] ]
P ′ = [0, [1, 1, 0]]
and the vector component of P ′ conﬁrms that P is indeed rotated to (1, 1, 0).
We will evaluate one more example before continuing. Consider a rotation
about the z-axis as illustrated in Figure 7.27. The original point has coordi-
nates (0, 1, 1) and is rotated −90◦. From the ﬁgure we see that this should
ﬁnish at (1, 0, 1). This time the quaternion q is deﬁned by
q = [cos(−90◦/2), sin(−90◦/2)[0, 0, 1]]
= [cos(45◦), [0, 0, −sin(45◦)]]
with its inverse
q−1 = [cos(45◦), [0, 0, sin(45◦]]
and the point to be rotated in quaternion form is P = [0, [0, 1, 1]]. Evaluating
this in two stages we have
1
qP = [cos(45◦), [0, 0, −sin(45◦)]] · [0, [0, 1, 1]]
= [sin(45◦), [sin(45◦), cos(45◦), cos(45◦)]]
Y
X
P' (1, 0, 1,)
P (0, 1, 1,)
Z
Fig. 7.27. The point P(0, 1, 1) is rotated −90◦to P ′(1, 0, 1) using a quaternion
coincident with the z-axis.

7 Transformation
95
2
(pP)q−1 = [sin(45◦), [sin(45◦), cos(45◦), cos(45◦)]]
·[cos(45◦), [0, 0, sin(45◦)]]
= [0, [sin(90◦), cos(90◦), 1]]
The vector component of P ′ conﬁrms that P is rotated to (1, 0, 1).
7.7.6 Roll, Pitch and Yaw Quaternions
Having already looked at roll, pitch and yaw rotations, we can now deﬁne
them as quaternions:
q roll = [cos(θ/2), sin(θ/2)[0, 0, 1]]
q pitch = [cos(θ/2), sin(θ/2)[1, 0, 0]]
q yaw = [cos(θ/2), sin(θ/2)[0, 1, 0]]
(7.98)
where θ is the angle of rotation.
These quaternions can be multiplied together to create a single quaternion
representing a compound rotation. For example, if the quaternions are deﬁned
as
qroll = [cos(roll/2), sin(roll/2)[0, 0, 1]]
qpitch = [cos(pitch/2), sin(pitch/2)[1, 0, 0]]
qyaw = [cos(yaw/2), sin(yaw/2)[0, 1, 0]]
(7.99)
they can be concatenated to a single quaternion q:
q = qyawqpitchqroll = [s + xi + yj + zk]
(7.100)
where
s = cos
yaw
2

cos
pitch
2

cos
roll
2

+ sin
yaw
2

sin
pitch
2

sin
roll
2

x = cos
yaw
2

sin
pitch
2

cos
roll
2

+ sin
yaw
2

cos
pitch
2

sin
roll
2

y = sin
yaw
2

cos
pitch
2

cos
roll
2

−cos
yaw
2

sin
pitch
2

sin
roll
2

z = cos
yaw
2

cos
pitch
2

sin
roll
2

−sin
yaw
2

sin
pitch
2

cos
roll
2

(7.101)

96
Mathematics for Computer Graphics
Let’s examine this compound quaternion with an example. For instance, given
the following conditions let’s derive a single quaternion q to represent the
compound rotation:
roll = 90◦
pitch = 180◦
yaw = 0◦
The values of s, x, y, z are
s = 0
x = cos(45◦)
y = −sin(45◦)
z = 0
and the quaternion q is
q = [0, [cos(45◦), −sin(45◦), 0]]
If the point P(1, 1, 1) is subjected to this compound rotation, the rotated
point is computed using the standard quaternion transform:
P′ = qPq−1
Let’s evaluate qPq−1 in two stages:
1
qP = [0, [cos(45◦), −sin(45◦), 0] ] · [0, [1, 1, 1]]
= [0, [−sin(45◦), −cos(45◦), sin(45◦) + cos(45◦)]]
2
(qP)q−1 = [0, [−sin(45◦), −cos(45◦), sin(45◦) + cos(45◦)]]
·[0, [−cos(45◦), sin(45◦), 0]]
P′ = [0, [−1, −1, −1]]
Therefore, the coordinates of the rotated point are (−1, −1, −1), which
can be conﬁrmed from Figure 7.28.
7.7.7 Quaternions in Matrix Form
There is a direct relationship between quaternions and matrices. For example,
given the quaternion [s + xi + yj + zk) the equivalent matrix is
⎡
⎣
M11
M12
M13
M21
M22
M23
M31
M32
M33
⎤
⎦

7 Transformation
97
pitch = 180
P′ (−1, −1, −1)
(−1, 1, 1)
P (1, 1, 1)
Y
roll = 90
X
Z
Fig. 7.28. The point P is subject to a compound roll of 90◦and a pitch of 180◦. This
diagram shows the transform in two stages.
where
M11 = 1 −2(y2 + z2)
M12 = 2(xy −sz)
M13 = 2(xz + sy)
M21 = 2(xy + sz)
M22 = 1 −2(x2 + z2)
M23 = 2(yz −sx)
M31 = 2(xz −sy)
M32 = 2(yz + sx)
M33 = 1 −2(x2 + y2)
(7.102)
Substituting the following values of s, x, y, z:
s = 0
x = cos(45◦)
y = −sin(45◦)
z = 0

98
Mathematics for Computer Graphics
the matrix transformation is
⎡
⎢⎣
x′
y′
z′
⎤
⎥⎦=
⎡
⎢⎣
0
−1
0
−1
0
0
0
0
−1
⎤
⎥⎦·
⎡
⎢⎣
x
y
z
⎤
⎥⎦
Substituting (1, 1, 1) for (x, y, z) the rotated point becomes (−1, −1, −1), as
shown in Figure 7.28.
7.7.8 Frames of Reference
A quaternion, or its equivalent matrix, can be used to rotate a vertex or
position a virtual camera. If unit quaternions are used, the associated matrix
is orthogonal, which means that its transpose is equivalent to rotating the
frame of reference in the opposite direction. For example, if the virtual camera
is oriented with a yaw rotation of 180◦, i.e. looking along the negative z-axis,
the orientation quaternion is [0, [0, 1, 0]]. Therefore s = 0, x = 0, y = 1, z = 0.
The equivalent matrix is
⎡
⎣
−1
0
0
0
1
0
0
0
−1
⎤
⎦
which is equal to its transpose. Therefore, a vertex (x, y, z) in world space has
coordinates (x′, y′, z′) in camera space and the transform is deﬁned by
⎡
⎣
x′
y′
z′
⎤
⎦=
⎡
⎣
−1
0
0
0
1
0
0
0
−1
⎤
⎦·
⎡
⎣
x
y
z
⎤
⎦
If the vertex (x, y, z) is (1, 1, 0), (x′, y′, z′) becomes (−1, 1, 0), which is correct.
However, it is unlikely that the virtual camera will only be subjected to a sim-
ple rotation, as it will normally be translated from the origin. Consequently,
a translation matrix will have to be introduced as described above.
7.8 Transforming Vectors
The transforms described in this chapter have been used to transform single
points. However, a geometric database will contain not only pure vertices,
but also vectors, which must also be subject to any prevailing transform.
A generic transform Q of a 3D point can be represented by
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= [Q] ·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
(7.103)

7 Transformation
99
and as a vector is deﬁned by two points we can write
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= [Q] ·
⎡
⎢⎢⎣
x2 −x1
y2 −y1
z2 −z1
1 −1
⎤
⎥⎥⎦
(7.104)
where we see the homogeneous scaling term collapse to zero. This implies that
any vector [x
y
z]T can be transformed using
⎡
⎢⎢⎣
x′
y′
z′
0
⎤
⎥⎥⎦= [Q] ·
⎡
⎢⎢⎣
x
y
z
0
⎤
⎥⎥⎦
(7.105)
Let’s put this to the test by using a transform from an earlier example. The
problem concerned a change of axial system where a virtual camera was sub-
ject to the following:
roll = 180◦
pitch = 90◦
yaw = 90◦
tx = 2
ty = 2
tz = 0
and the transform is⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
0
−1
0
2
0
0
1
0
−1
0
0
2
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
When the point (1, 1, 0) is transformed it becomes (1, 0, 1), as shown in
Figure 7.29. But if we transform the vector
1 1 0T it becomes
−1 0 −1T,
using the following transform
⎡
⎢⎢⎣
−1
0
−1
0
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
0
−1
0
2
0
0
1
0
−1
0
0
2
0
0
0
1
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
1
1
0
0
⎤
⎥⎥⎦
which is correct with reference to Figure 7.29.
7.9 Determinants
Before concluding this chapter I would like to expand upon the role of the
determinant in transforms. Normally, determinants arise in the solution of

100
Mathematics for Computer Graphics
Y
Z
X
Z'
Y'
(1, 1, 0)
(2, 2, 0)
(1, 0, 1)'
X'
Fig. 7.29. Vector [1 1 0]T is transformed to [−1 0 −1]T.
linear equations such as
c1 = a1x + b1y
c2 = a2x + b2y
(7.106)
where values of x and y are deﬁned in terms of the other constants. Without
showing the solution, the values of x and y are given by
x = c1b2 −c2b1
a1b2 −a2b1
y = a1c2 −a2c1
a1b2 −a2b1
(7.107)
provided that the denominator a1b2 −a2b1 ̸= 0.
It is also possible to write the linear equations in matrix form as

c1
c2

=

a1
b1
a2
b2

·

x
y

(7.108)
and we notice that the denominator comes from the matrix terms a1b2 −
a2b1. This is called the determinant, and is valid only for square matrices.
A determinant is deﬁned as follows:

a1
b1
a2
b2
 = a1b2 −a2b1
(7.109)
With this notation it is possible to rewrite the original linear equations as
x

c1
b1
c2
b2

=
y

a1
c1
a2
c2

=
1

a1
b1
a2
b2

(7.110)
With a set of three linear equations:
d1 = a1x + b1y + c1z
d2 = a2x + b2y + c2z
d3 = a3x + b3y + c3z
(7.111)

7 Transformation
101
the value of x is deﬁned as
x = d1b2c3 −d1b3c2 + d2b3c1 −d2b1c3 + d3b1c2 −d3b2c1
a1b2c3 −a1b3c2 + a2b3c1 −a2b1c3 + a3b1c2 −a3b2c1
(7.112)
with similar expressions for y and z. Once more, the denominator comes from
the determinant of the matrix associated with the matrix formulation of the
linear equations:
⎡
⎣
d1
d2
d3
⎤
⎦=
⎡
⎣
a1
b1
c1
a2
b2
c2
a3
b3
c3
⎤
⎦·
⎡
⎣
x
y
z
⎤
⎦
(7.113)
where

a1
b1
c1
a2
b2
c2
a3
b3
c3

= a1b2c3 −a1b3c2 + a2b3c1 −a2b1c3 + a3b1c2 −a3b2c1
which can be written as
a1

b2
c2
b3
c3
 −a2

b1
c1
b3
c3
 + a3

b1
c1
b2
c2

(7.114)
Let’s now see what creates a zero determinant. If we write, for example
10 = 2x + y
(7.115)
there are an inﬁnite number of solutions for x and y, and it is impossible
to solve the equation. However, if we introduce a second equation relating x
and y:
4 = 5x −y
(7.116)
we can solve for x and y using (7.107):
x = 10 × (−1) −4 × 1
2 × (−1) −5 × 1 = −14
−7 = 2
y =
2 × 4 −5 × 10
2 × (−1) −5 × 1 = −42
−7 = 6
(7.117)
therefore x = 2 and y = 6, which is correct.
But say the second equation had been
20 = 4x + 2y
(7.118)
which would have created the pair of simultaneous equations
10 = 2x + y
(7.119)
20 = 4x + 2y
(7.120)

102
Mathematics for Computer Graphics
If we now solve for x and y we get
x = 10 × 2 −20 × 1
2 × 2 −4 × 1
= 0
0 = undeﬁned
y = 2 × 20 −4 × 10
2 × 2 −4 × 1
= 0
0 = undeﬁned
which yields undeﬁned results. The reason for this is that (7.119) is the same
as (7.120) – the second equation is nothing more than twice the ﬁrst equation,
and therefore brings nothing new to the relationship. When this occurs, the
equations are said to be linearly dependent.
Having shown the algebraic origins of the determinant, we can now go on
to investigate its graphical signiﬁcance. Consider the transform

x′
y′

=

a
b
c
d

·

x
y

(7.121)
The determinant of the transform is ad –cb. If we subject the vertices of a
unit-square to this transform, we create the situation shown in Figure 7.30.
The vertices of the unit-square are moved as follows:
(0, 0)
(0, 0)
(1, 0)
(a, c)
(1, 1)
(a + b, c + d)
(0, 1)
(b, d)
(7.122)
From Figure 7.30 it can be seen that the area of the transformed unit-square
A′ is given by
area = (a + b)(c + d) −B −C −D −E −F −G
= ac + ad + cb + bd −1
2bd −cb −1
2ac −1
2bd −cb −1
2ac
= ad −cb
(7.123)
which is the determinant of the transform. But as the area of the original
unit-square was 1, the determinant of the transform controls the scaling factor
applied to the transformed shape.
Let’s examine the determinants of two transforms. The ﬁrst 2D transform
encodes a scaling of 2, and results in an overall area scaling of 4:
 2
0
0
2

and the determinant is

2
0
0
2
 = 4

7 Transformation
103
Y
b
a
C
D
B
(b, d)
(a, c)
A
E
F
G
c
d
X
b
a
(0, 0)
(a + b, c + d)
Fig. 7.30. The inner parallelogram is the transformed unit square.
The second 2D transform encodes a scaling of 3 and a translation of (3, 3),
and results in an overall area scaling of 9:
⎡
⎣
3
0
3
0
3
3
0
0
1
⎤
⎦
and the determinant is
3

3
3
0
1
 −0

0
3
0
1
 + 0

0
3
3
3
 = 9
These two examples demonstrate the extra role played by the elements of a
matrix.
7.10 Perspective Projection
Of all the projections employed in computer graphics, the perspective projec-
tion is the one most widely used. There are two stages to its computation:
the ﬁrst stage involves converting world coordinates to the camera’s frame of
reference, and the second stage transforms camera coordinates to the projec-
tion plane coordinates. We have already looked at the transforms for locating
a camera in world space, and the inverse transform for converting world co-
ordinates to the camera’s frame of reference. Let’s now investigate how these
camera coordinates are transformed into a perspective projection.
We begin by assuming that the camera is directed along the z-axis as
shown in Figure 7.31. Positioned d units along the axis is a projection screen,

104
Mathematics for Computer Graphics
Xc
Xc
XP
Zc
Xp
xP
yP
(xc, yc, zc)
Fig. 7.31. The axial systems used to produce a perspective projection.
which will be used to capture a perspective projection of an object. Figure
7.31 shows that any point (xc, yc, zc) becomes transformed to (xs, ys, d). It
also shows that the screen’s x-axis is pointing in the opposite direction to the
camera’s x-axis, which can be compensated for by reversing the sign of xs
when it is computed.
Figure 7.32 shows plan and side views of the scenario depicted in Fig-
ure 7.31, which enables us to inspect the geometry and make the following
observations:
x
z = −xp
d
xp = −dx
z
xp = −y
z/d
y
z = yp
d
yp = dy
z
yp =
y
z/d
(7.124)
This can be expressed in matrix as
⎡
⎢⎢⎣
xs
ys
zs
W
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
−1
0
0
0
0
1
0
0
0
0
1
0
0
0
1/d
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
At ﬁrst this may seem strange, but if we multiply it out we get
[xp yp zp W]T = [−x y z z/d]T
and if we remember the idea behind homogeneous coordinates, we must divide
the terms xp, yp, zp by W to get the scaled terms, which produces
xp = −x
z/d,
yp =
y
z/d,
zp =
z
z/d = d

7 Transformation
105
Plan view
screen
X
d
z
Z
x
(x, y, z)
(xp, yp)
−xp
Side view
screen
Y
d
z
Z
y
(x, y, z )
(xp, yp)
yp
Fig. 7.32. The plan and side views for computing the perspective projection trans-
form.
which, after all, is rather elegant. Notice that this transform takes into account
the sign change that coours with the x-coordinate. Some books will leave this
sign reversal until the mapping is made to screen coordinates
7.11 Summary
The purpose of this chapter was to introduce transforms and matrices – I hope
this has been achieved. This end of the chapter is not really the end of the
subject, as one can do so much with matrices and quaternions. For example,
it would be interesting to see how a matrix behaves when some of its elements
are changed dynamically, and what happens when we interpolate between a
pair of quaternions. Such topics are addressed in later chapters.

8
Interpolation
Interpolation is not a branch of mathematics but rather a collection of tech-
niques the reader will ﬁnd useful when solving computer graphics problems.
Basically, an interpolant is a way of changing one number into another. For
example, to change 2 into 4 we simply add 2, which is not very useful. The real
function of an interpolant is to change one number into another in, perhaps,
10 equal steps. Thus if we start with 2 and repeatedly add 0.2, this generates
the sequence 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8 and 4. These numbers could
then be used to translate, scale, rotate an object, move a virtual camera, or
change the position, colour or brightness of a virtual light source.
In order to repeat the above interpolant for diﬀerent numbers we require
a formula, which is one of the ﬁrst exercises of this chapter. We also need
to explore ways of controlling the spacing between the interpolated values.
In animation, for example, we often need to move an object very slowly and
gradually increase its speed. Conversely, we may want to bring an object to a
halt, making its speed less and less.
We start with the simplest of all interpolants: the linear interpolant.
8.1 Linear Interpolant
A linear interpolant generates equal spacing between the interpolated values
for equal changes in the interpolating parameter. In the introductory example
the increment 0.2 is calculated by subtracting the ﬁrst number from the second
and dividing the result by 10, i.e. (4 −2)/10 = 0.2. Although this works, it
is not in a very ﬂexible form, so let’s express the problem diﬀerently. Given
two numbers n1 and n2, which represent the start and ﬁnal values of the

108
Mathematics for Computer Graphics
interpolant, we require an interpolated value controlled by a parameter t that
varies between 0 and 1. When t = 0, the result is n1, and when t = 1, the
result is n2. A solution to this problem is given by
n = n1 + t(n2 −n1)
(8.1)
for when n1 = 2, n2 = 4 and t = 0.5
n = 2 + 1
2(4 −2) = 3
which is a halfway point. Furthermore, when t = 0, n = n1, and when t =
1, n = n2, which conﬁrms that we have a sound interpolant. However, it can
be expressed diﬀerently:
n = n1 + t(n2 −n1)
(8.2)
n = n1 + tn2 −tn1
(8.3)
n = n1(1 −t) + n2t
(8.4)
which shows what is really going on, and forms the basis for further
development. Figure 8.1 shows the graphs of (1 −t) and t over the range
0 to 1.
With reference to (8.4), we see that as t changes from 0 to 1, the (1 −t) term
varies from 1 to 0. This eﬀectively attenuates the value of n1 to zero over the
range of t, while the t term scales n2 from zero to its actual value. Figure 8.2
illustrates these two actions with n1 = 1 and n2 = 3. Notice that the terms
(1 −t) and t sum to unity; this is not a coincidence. This type of interpolant
ensures that if it takes a quarter of n1, it balances it with three-quarters of n2,
and vice versa. Obviously we could design an interpolant that takes arbitrary
portions of n1 and n2, but that would lead to arbitrary results. Although
this interpolant is extremely simple, it is widely used in computer graphics
software. Just to put it into context, consider the task of moving an object
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
(1 −t)
t
0
0.2
0.4
0.6
0.8
1
1.2
Fig. 8.1. The graphs of (1 −t) and t over the range 0 to 1.

8 Interpolation
109
0
0.5
1
1.5
n
2
2.5
3
3.5
1(1 −t) + 3t
1(1 −t)
3t
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
Fig. 8.2. The top graph shows the result of linearly interpolating between values 1
and 3.
0
1
2
3
x
4
5
y
0
0.5
1
1.5
2
2.5
3
3.5
Fig. 8.3. Interpolating between the points (1, 1) and (4, 3). Note that linear changes
in t give rise to equal spaces along the line.
between two locations (x1, y1, z1) and (x2, y2, z2). The interpolated position
is given by
x = x1(1 −t) + x2t
y = y1(1 −t) + y2t
z = z1(1 −t) + z2t
(8.5)
for 0 ≤t ≤1 The parameter t could be generated from two frame values
within an animation. What is assured by this interpolant, is that equal steps
in t result in equal steps in x, y and z. Figure 8.3 illustrates this linear spacing
with a 2D example. We can write (8.2) in matrix form as follows:
n = [(1 −t) t] ·
 n1
n2

(8.6)

110
Mathematics for Computer Graphics
or
n = [t 1] ·
 −1
1
1
0

·
 n1
n2

(8.7)
The reader can conﬁrm that this generates identical results to the algebraic
form.
8.2 Non-Linear Interpolation
A linear interpolant ensures that equal steps in the parameter t give rise
to equal steps in the interpolated values; however, it is often required that
equal steps in t give rise to unequal steps in the interpolated values. We
can achieve this using a variety of mathematical techniques. For example, we
could use trigonometric functions or polynomials. To begin with, let’s look at
a trigonometric solution.
8.2.1 Trigonometric Interpolation
In Chapter 4 we noted that sin2(β) + cos2(β) = 1, which satisﬁes one of the
requirements of an interpolant: the terms must sum to 1. If β varies between
0 and π/2, cos2(β) varies between 1 and 0, and sin2(β) varies between 0 and 1,
which can be used to modify the two interpolated values n1 and n2 as follows:
n = n1 cos2(t) + n2 sin2(t)
(8.8)
for 0 ≤t ≤π/2
The interpolation curves are shown in Figure 8.4.
If we make n1 = 1 and n2 = 3 in (8.8), we obtain the curves shown in
Figure 8.5. If we apply this interpolant to two 2D points in space, (1, 1) and
(4, 3), we obtain a straight-line interpolation, but the distribution of points is
0
0
5 10 15 20 25 30 35 40 45
Angle
50 55 60 65 70 75 80 85 90
0.2
0.4
0.6
y
0.8
1
1.2
Fig. 8.4. The curves for cos2(β) and sin2(β).

8 Interpolation
111
0
0.5
1
1.5
n
2
2.5
3
3.5
0
5 10 15 20 25 30 35 40 45
Degrees
50 55 60 65 70 75 80 85 90
Fig. 8.5. Interpolating between 1 and 3 using a trigonometric interpolant.
0
1
2
3
x
4
5
0
0.5
1
1.5
y
2
2.5
3
3.5
Fig. 8.6. Interpolating between two points (1, 1) and (4, 3). Note the non-linear
distribution of points.
non-linear, as shown in Figure 8.6. In other words, equal steps in t give rise
to unequal distances.
The main problem with this approach is that it is impossible to change
the nature of the curve -it is a sinusoid, and its slope is determined by the
interpolated values. One way of gaining control over the interpolated curve is
to use a polynomial, which is the subject of the next section.
8.2.2 Cubic Interpolation
To begin with, let’s develop a cubic blending function that will be similar
to the previous sinusoidal one. This can then be extended to provide extra
ﬂexibility. A cubic polynomial will form the basis of the interpolant
V1 = at3 + bt2 + ct + d
(8.9)
and the ﬁnal interpolant will be of the form
n = [V1 V2] ·
 n1
n2

(8.10)

112
Mathematics for Computer Graphics
The task is to ﬁnd the values of the constants associated with the polynomials
V1 and V2. The requirements are:
1. A cubic function V2 must grow from 0 to 1 for 0 ≤t ≤1.
2. The slope at a point t, must equal the slope at the point (1 −t). This
ensures slope symmetry over the range of the function.
3. The value V2 at any point t must also produce (1 −V2) at (1 −t). This
ensures curve symmetry.
•
To satisfy the ﬁrst requirement:
V2 = at3 + bt2 + ct + d
(8.11)
therefore, t = 0, d = 0 for V2 = 0, and when t = 1, V2 = a + b + c.
•
To satisfy the second requirement, we diﬀerentiate V2 to obtain the slope
dV2
dt = 3at2 + 2bt + c = 3a(1 −t)2 + 2b(1 −t) + c
(8.12)
and equating constants we discover c = 0 and 0 = 3a + 2b
•
To satisfy the third requirement,
at3 + bt2 = 1 −[a(1 −t)3 + b(1 −t)2]
(8.13)
where we discover 1 = a + b. But 0 = 3a + 2b, therefore a = −2 and b = 3.
Therefore
V2 = −2t3 + 3t2
(8.14)
To ﬁnd the curve’s mirror curve, which starts at 1 and collapses to 0 as t
moves from 0 to 1, we subtract (8.14) from 1:
V1 = 2t3 −3t2 + 1
(8.15)
Therefore, the two polynomials are
V2 = −2t3 + 3t2
V1 = 2t3 −3t2 + 1
(8.16)
and are shown in Figure 8.7. They can be used as interpolants as follows:
n = n1V1 + n2V2
(8.17)
which in matrix form is
n =

2t3 −3t2 + 1 −2t3 + 3t2
·

n1
n2

(8.18)
n =
t3
t2
t1
1
·
⎡
⎢⎢⎣
2
−2
−3
3
0
0
1
0
⎤
⎥⎥⎦·
n1
n2

(8.19)

8 Interpolation
113
0
0.2
0.4
0.6
y
0.8
1
1.2
2t 3 − 3t 2 + 1
−2t 3 + 3t 2
0
0.1 0.2 0.3 0.4 0.5
t
0.6 0.7 0.8 0.9
1
Fig. 8.7. Two cubic interpolants.
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
0.5
1
1.5
n
2
2.5
3
3.5
Fig. 8.8. Interpolating between 1 and 3 using a cubic interpolant.
If we let n1 = 1 and n2 = 3 we obtain the curves shown in Figure 8.8.
And if we apply the interpolant to the points (1, 1) and (4, 3) we obtain the
curves shown in Figure 8.9. This interpolant can be used to blend any pair
of numbers together. But say we wished to associate other qualities with the
numbers n1 and n2, such as their tangent vectors s1 and s2. Perhaps we could
interpolate these alongside n1 and n2. In fact this can be done, as we shall
see.
The requirement is to modulate the interpolating curve in Figure 8.8 with
two further cubic curves. One curve blends out the tangent vector s1 associated
with n1, and the other blends in the tangent vector s2 associated with n2. Let’s
begin with a cubic polynomial to blend s1 to zero:
Vout = at3 + bt2 + ct + d
(8.20)
Vout must equal zero when t = 0 and t = 1, otherwise it will disturb the start
and end values. Therefore d = 0, and
a + b + c = 0
(8.21)

114
Mathematics for Computer Graphics
0
0.5
1
1.5
y
2
2.5
3
3.5
0
1
2
3
x
4
5
Fig. 8.9. A cubic interpolant between points (1, 1) and (4, 3).
The rate of change of Vout relative to t (i.e. dVout
dt ) must equal 1 when t = 0,
so it can be used to multiply s1. When t = 1, dVout
dt
must equal 0 to attenuate
any trace of s1:
dVout
dt
= 3at2 + 2bt + c
(8.22)
but dVout
dt
= 1 when t = 0, and dVout
dt
= 0 when t = 1. Therefore c = 1, and
3a + 2b + 1 = 0
(8.23)
But using (8.21) means that b = −2 and a = 1. Therefore, the polynomial
Vout has the form
Vout = t3 −2t2 + t
(8.24)
Using a similar argument, one can prove that the function to blend in s2 equals
Vin = t3 −t2
(8.25)
Graphs of (8.24) and (8.25) are shown alongside graphs of (8.16) in Figure 8.10.
The complete interpolating function looks like
n = [2t3 −3t2 + 1
−2t3 + 3t2
t3 −2t2 + t
t3 −t2] ·
⎡
⎢⎢⎣
n1
n2
s1
s2
⎤
⎥⎥⎦
(8.26)

8 Interpolation
115
−0.4
−0.2
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
0.2
0.4
n
0.6
0.8
1
1.2
Fig. 8.10. The four Hermite interpolating curves.
and, unpacking the constants and polynomial terms, we obtain
n = [t3 t2 t1 1] ·
⎡
⎢⎢⎣
2
−2
1
1
−3
3
−2
−1
0
0
1
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
n1
n2
s1
s2
⎤
⎥⎥⎦
(8.27)
This type of interpolation is called Hermite interpolation, after the French
mathematician Charles Hermite (1822–1901). Hermite also proved in 1873
that e is transcendental (see page 9).
This interpolant can be used as shown above to blend a pair of numerical
values and their tangent vectors, or it can be used to interpolate between
points in space. To demonstrate the latter we will explore a 2D example, and
it is very easy to implement the technique in 3D.
Figure 8.11 illustrates shows how two points (0, 0) and (1, 1) are to be
connected by a cubic curve that responds to the initial and ﬁnal tangent
vectors. At the start point (0, 1) the tangent vector is [−5 0]T, and at the
ﬁnal point (1, 1) the tangent vector is [0 −5]T. The x and y interpolants are
x = [t3 t2 t1 1] ·
⎡
⎢⎢⎣
2
−2
1
1
−3
3
−2
−1
0
0
1
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
0
1
−5
0
⎤
⎥⎥⎦
y = [t3 t2 t1 1] ·
⎡
⎢⎢⎣
2
−2
1
1
−3
3
−2
−1
0
0
1
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
0
1
0
−5
⎤
⎥⎥⎦

116
Mathematics for Computer Graphics
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
y
x
−1
−0.5
0
0.5
1
1.5
[−5 0]
[0 −5]
Fig. 8.11. A Hermite curve between the points (0, 0) and (1, 1) with tangent vectors
(−5, 0) and (0, −5).
which become
x = [t3 t2 t1 1] ·
⎡
⎢⎢⎣
−7
13
−5
0
⎤
⎥⎥⎦= −7t3 + 13t2 −5t
y = [t3 t2 t1 1] ·
⎡
⎢⎢⎣
−7
8
0
0
⎤
⎥⎥⎦= −7t3 + 8t2
When these polynomials are plotted over the range 0 ≤t ≤1, we obtain the
curve shown in Figure 8.11. We have now reached a point where are starting
to discover how parametric polynomials can be used to generate space curves,
which is the subject of the next chapter. So, to conclude this chapter on
interpolants, we will take a look at interpolating vectors.
8.3 Interpolating Vectors
So far we have been interpolating between a pair of numbers. Now the question
arises: can we use the same interpolants for vectors? Perhaps not, because
a vector contains both magnitude and direction, and when we interpolate
between two vectors we must ensure that both quantities are preserved. For
example, if we interpolated the x- and y-components of the vectors [2 3]T and
[4 7]T, the in-between vectors would preserve the change of orientation but
ignore the change in magnitude. To preserve both, we must understand how
the interpolation should operate.
Figure 8.12 shows two unit vectors V1 and V2 separated by an angle θ. The
interpolated vector V can be deﬁned as a proportion of V1 and a proportion

8 Interpolation
117
Y
V2
V1
V
(1−t)q
(1−t)q
n
b
a
m
X
q
tq
q
Fig. 8.12. Vector V is derived from a parts of V1 and b parts of V2.
of V2:
V = aV1 + bV2
(8.28)
Let’s deﬁne the values of a and b such that they are a function of the separating
angle θ. Vector V is tθ from V1 and (1 −t)θ from V2, and it is evident from
Figure 8.12 that using the sine rule
a
sin((1 −t)θ) =
b
sin(tθ)
(8.29)
and furthermore
m = a cos(tθ)
(8.30)
n = b cos( (1 −t)θ)
(8.31)
m + n = 1
(8.32)
From (8.29),
b =
a sin(tθ)
sin((1 −t)θ)
(8.33)
and from (8.32) we get
a cos(tθ) + a sin(tθ) cos((1 −t)θ)
sin((1 −t)θ)
= 1
Solving for a we ﬁnd
a = sin((1 −t)θ)
sin(θ)
and b = sin(tθ)
sin(θ)

118
Mathematics for Computer Graphics
Therefore, the ﬁnal interpolant is
V = sin((1 −t)θ)
sin(θ)
V1 + sin(tθ)
sin(θ) V2
(8.34)
To see how this operates, let’s consider a simple exercise of interpolating
between two unit vectors [1 0]T and

−
1
√
2
1
√
2
T
. The value of θ is the angle
between the two vectors: 135◦. (8.34) is used to interpolate the x-components
and the y-components individually:
Vx = sin((1 −t)135◦)
sin(135◦)
× (1) + sin(t135◦)
sin(135◦) ×

−1
√
2

Vy = sin((1 −t)135◦)
sin(135◦)
× (0) + sin(t135◦)
sin(135◦) ×
 1
√
2

Figure 8.13 shows the interpolating curves and Figure 8.14 shows the positions
of the interpolated vectors, and a trace of the interpolated vectors.
Two observations on (8.34):
•
The angle θ is the angle between the two vectors, which, if not known, can
be computed using the dot product.
•
Secondly, the range of θ is give by 0 ≤θ ≤180◦, because when θ = 180◦
the denominator collapses to zero. To conﬁrm this we will repeat (8.34)
for θ = 179◦. The result is shown in Figure 8.15, which reveals clearly that
the interpolant works normally over this range. One more degree, however,
and it fails!
So far, we have only considered unit vectors. Now let’s see how the inter-
polant responds to vectors of diﬀerent magnitudes. As a test, we can input
the following vectors to (8.34):
V1 =

2
0

and V2 =

0
1

−0.8
−0.6
−0.4
−0.2
0
0.2
n
0.4
0.6
0.8
1
1.8
0
13.5
27
40.5
54
67.5
Angle
81
94.5
108 121.5 135
Fig. 8.13. Curves of the two parts of (8.34).

8 Interpolation
119
1.2
1
0.8
0.6
0.4
0.2
0
−1
−0.5
0
0.5
1
1.5
x
y
Fig. 8.14. A trace of the interpolated vectors between [1 0]T and [−1
√
2
1
√
2
]T.
y
x
1.2
1
0.8
0.6
0.4
0.2
0
−1.5
−1
−0.5
0
0.5
1
1.5
Fig. 8.15. Interpolating between two vectors 179◦apart.
The separating angle θ = 90◦, and the result is shown in Figure 8.16. Note
how the initial length of V1 reduces from 2 to 1 over 90◦. It is left to the reader
to examine other combinations of vectors. But there is one more application
for this interpolant, and that is with quaternions.
8.4 Interpolating Quaternions
It just so happens that the interpolant used for vectors also works with quater-
nions. Which means that, given two quaternions q1 and q2, the interpolated
quaternion q is given by
q = sin((1 −t)θ)
sin(θ)
q1 + sin(tθ)
sin(θ) q2
(8.35)
The interpolant is applied individually to the four terms of the quaternion.

120
Mathematics for Computer Graphics
1.2
1
0.8
0.6
0.4
0.2
0
0
0.5
1
1.5
2
2.5
y
x
Fig. 8.16. Interpolating between the vectors [2 0]T and [0 1]T.
When interpolating vectors, θ is the angle between the two vectors. If this
is not known, it can be derived using the dot product formula:
cos(θ) =
V1 · V2
∥V1∥∥V2∥
(8.36)
cos(θ) = x1x2 + y1y2 + z1z2
∥V1∥∥V2∥
When interpolating quaternions, θ is discovered by taking the 4D dot product
of the two quaternions:
cos(θ) =
q1 · q2
∥q1∥∥q2∥
cos(θ) = s1s2 + x1x2 + y1y2 + z1z2
∥q1∥∥q2∥
If we are using unit quaternions,
cos(θ) = s1s2 + x1x2 + y1y2 + z1z2
(8.37)
We are now in a position to demonstrate how to interpolate between a pair of
quaternions. For example, say we have two quaternions q1 and q2 that rotate
0◦and 90◦about the z-axis respectively:
q1 =

cos
0◦
2

, sin
0◦
2

[0, 0, 1]

q2 =

cos
90◦
2

, sin
90◦
2

[0, 0, 1]

which become
q1 = [1, [0, 0, 0]
q2 = [0.7071, [0, 0, 0.7071]]

8 Interpolation
121
Any interpolated quaternion can be found by the application of (8.35). But
ﬁrst, we need to ﬁnd the value of θ using (8.37):
cos(θ) = 0.7071 + 0 + 0 + 0
θ = 45◦
Now when t = 0.5, the interpolated quaternion is given by
q = sin( 45◦
2 )
sin(45◦)[1, [0, 0, 0]] + sin( 45◦
2 )
sin(45◦)[0.7071, [0, 0, 0.7071]]
q = 0.541196[1, [0, 0, 0]] + 0.541196[0.7071, [0, 0, 0.7071]]
q = [0.541196, [0, 0, 0]] + [0.382683, [0, 0, 0.382683]]
q = [0.923879, [0, 0, 0.382683]]
Although it is not obvious, this interpolated quaternion is a unit quaternion,
because the square root of the sum of the squares is 1. It should rotate a point
about the z-axis, halfway between 0◦and 90◦, i.e. 45◦. We can test that this
works with a simple example.
Take a point (1, 0, 0) and subject it to the standard quaternion operation:
P′ = qPq−1
To keep the arithmetic work to a minimum, we substitute a = 0.923879 and
b = 0.382683. Therefore
q = [a, [0, 0, b]] and q−1 = [a, [0, 0, −b]]
P′ = [a, [0, 0, b]] × [0, [1, 0, 0]] × [a, [0, 0, −b]]
P′ = [0, [a, b, 0]] × [a, [0, 0, −b]]
P′ = [0, [a2 −b2, 2ab, 0]]
P′ = [0, [0.7071, 0.7071, 0]]
Therefore, (1, 0, 0) is rotated to (0.7071, 0.7071, 0), which is correct!
8.5 Summary
This chapter has covered some very interesting, yet simple ideas about chang-
ing one number into another. In the following chapter we will develop these
ideas and see how we design algebraic solutions to curves and surfaces.

9
Curves and Patches
In this chapter we investigate the foundations of curves and surface patches.
This is a very large and complex subject, and it is impossible for us to delve
too deeply. However, we can explore many of the ideas that are essential to
understanding the mathematics behind 2D and 3D curves and how they are
developed to produce surface patches. Once you have understood these ideas
you will be able to read more advanced texts and develop a wider knowledge.
In the previous chapter we saw how polynomials were used as interpolants
and blending functions. We will now see how these can form the basis of
parametric curves and patches. To begin with, let’s start with the humble
circle.
9.1 The Circle
The circle has a very simple equation:
x2 + y2 = R2
(9.1)
where R is the radius. Although this equation has its uses, it is not very
convenient for drawing the curve. What we really want are two functions that
determine the coordinates of any point on the circumference in terms of some
parameter. Figure 9.1 shows a scenario where the x- and y-coordinates are
given by
x = R cos(t)
y = R sin(t) 0 ≤t ≤2π
(9.2)

124
Mathematics for Computer Graphics
R
y
X
t
x
Y
Fig. 9.1. The circle can be drawn by tracing out a series of points on the circumference.
By varying the parameter t over the range 0 to 2π we trace out the curve of
the circumference. In fact, by selecting a suitable range of t we can isolate
any portion of the circle.
9.2 The Ellipse
The equation for an ellipse is
x2
R2
maj
+
y2
R2
min
= 1
(9.3)
but its parametric form is
x = Rmaj cos(t)
y = Rmin sin(t) 0 ≤t ≤2π
(9.4)
where Rmaj and Rmin are the major and minor radii respectively, as shown in
Figure 9.2.
In the previous chapter we saw how a Hermite curve could be developed
using cubic polynomials and tangent slope vectors. Equation (8.27) gave the
x- and y-coordinates for a 2D curve, and there is no reason why it could
not be extended to give the z-coordinate for a 3D curve. The tangent slope
vectors would also have to be modiﬁed to form the end conditions in three
dimensions.
We will now examine a very useful parametric curve called a B´ezier curve,
named after its inventor Pierre B´ezier.

9 Curves and Patches
125
Rmaj
Rmin
X
Y
Fig. 9.2. An ellipse showing the major and minor radii.
9.3 B´ezier Curves
Two people, working for competing French car manufacturers, are associated
with what are now called B´ezier curves: Paul de Casteljau, who worked at
Citro¨en, and Pierre B´ezier, who worked at R´enault. De Casteljau’s work was
slightly ahead of B´ezier, but because of Citro¨en’s policy of secrecy it was
never published, so B´ezier’s name has since been associated with the theory
of polynomial curves and surfaces. Casteljau started his research work in 1959,
but his reports were only discovered in 1975, by which time B´ezier had already
become known for his special curves and surfaces.
9.3.1 Bernstein Polynomials
B´ezier curves employ Bernstein polynomials, which were described by S. Bern-
stein in 1912. They are expressed as follows:
Bn
i (t) =
n
i

ti(1 −t)n−i
(9.5)
where

n
i

is shorthand for the number of selections of i diﬀerent items from
n distinguishable items when the order of selection is ignored, and equals
n!
(n −i)!i!
(9.6)
where, for example, 3! (factorial 3) is shorthand for 3 × 2 × 1.
When (9.6) is evaluated for diﬀerent values of i and n, we discover the
pattern of numbers shown in Table 9.1. This pattern of numbers is known as
Pascal’s triangle. In western countries they are named after a 17th century
French mathematician, even though they had been described in China as early
as 1303 in Precious Mirror of the Four Elements by the Chinese mathemati-
cian Chu Shih-chieh. The pattern represents the coeﬃcients found in binomial
expansions. For example, the expansion of (x + a)n for diﬀerent values of n is

126
Mathematics for Computer Graphics
Table 9.1. Pascal’s triangle
i
n
0
1
2
3
4
5
6
0
1
1
1
1
2
1
2
1
3
1
3
3
1
4
1
4
6
4
1
5
1
5
10
10
5
1
6
1
6
15
20
15
6
1
(x + a)0 = 1
(x + a)1 = 1x + 1a
(x + a)2 = 1x2 + 2ax + 1a2
(x + a)3 = 1x3 + 3ax2 + 3a2x + 1a3
(x + a)4 = 1x4 + 4ax3 + 6a2x2 + 4a3x + 1a4
which reveals Pascal’s triangle as coeﬃcients of the polynomial terms.
Pascal, however, recognized other qualities in the numbers, in that they
described the odds governing combinations. For example, to determine the
probability of any girl–boy combination in a family of 6 children, we sum the
numbers in the 6th row of Pascal’s triangle:
1 + 6 + 15 + 20 + 15 + 6 + 1 = 64.
The number (1) at the start and end of the 6th row represent the chances of
getting 6 boys or 6 girls, i.e. 1 in 64. The next number (6) represents the next
most likely combination: 5 boys and 1 girl, or 5 girls and 1 boy, i.e. 6 in 64.
The centre number (20) applies to 3 boys and 3 girls, for which the chances
are 20 in 64.
Thus the

n
i

term in (9.5) is nothing more than a generator for Pascal’s
triangle. The powers of t and (1 −t) in (9.5) appear as shown in Table 9.2
for diﬀerent values of n and i. When the two sets of results are combined,
we get the complete Bernstein polynomial terms shown in Table 9.3. One
very important property of these terms is that they sum to unity, which is an
important feature of any interpolant.
As the sum of (1 −t) and t is 1,
((1 −t) + t)n = 1
(9.7)
which is why we can use the binomial expansion of (1−t) and t as interpolants.
When n = 2 we obtain the quadratic form
(1 −t)2 2t(1 −t) t2
(9.8)

9 Curves and Patches
127
Table 9.2. Expansion of the terms t and (1 −t)
i
n
0
1
2
3
4
1
t
(1 −t)
2
t2
t(1 −t)
(1 −t)2
3
t3
t2(1 −t)
t(1 −t)2
(1 −t)3
4
t4
t3(1 −t)
t2(1 −t)2
t(1 −t)3
(1 −t)4
Table 9.3. The Bernstein polynomial terms
i
n
0
1
2
3
4
1
1t
1(1 −t)
2
1t2
2t(1 −t)
1(1 −t)2
3
1t3
3t2(1 −t)
3t(1 −t)2
1(1 −t)3
4
1t4
4t3(1 −t)
6t2(1 −t)2
4t(1 −t)3
1(1 −t)4
1.2
1
0.8
0.6
0.4
0.2
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
Fig. 9.3. The graphs of the quadratic Bernstein polynomials.
Figure 9.3 shows the graphs of the three polynomial terms of (9.8). The (1−t)2
graph starts at 1 and decays to zero, whereas the t2 graph starts at zero and
rises to 1. The 2t(1 −t) graph starts at zero, reaches a maximum of 0.5 and
returns to zero. Thus the central polynomial term has no inﬂuence at the
end-points where t = 0 and t = 1.
We can use these three terms to interpolate between a pair of values as
follows:
V = V1(1 −t)2 + 2t(1 −t) + V2t2
(9.9)
If V1 = 1 and V2 = 3 we obtain the curve shown in Figure 9.4. But there
is nothing preventing us from multiplying the middle term 2t(1 −t) by any
arbitrary number Vc:
V = V1(1 −t)2 + Vc2t(1 −t) + V2t2
(9.10)

128
Mathematics for Computer Graphics
3.5
3
2.5
2
1.5
1
0.5
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
Fig. 9.4. Bernstein interpolation between the values 1 and 3.
3.5
3
2.5
2
1.5
1
0.5
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
Fig. 9.5. Bernstein interpolation between values 1 and 3 with Vc = 3.
3.5
3
2.5
2
1.5
1
0.5
0
1
2
3
4
5
6
t
7
8
9
10
11
Fig. 9.6. Bernstein interpolation between values 1 and 3 for diﬀerent values of Vc.
For example, if Vc = 3 we obtain the graph shown in Figure 9.5, which is
totally diﬀerent from Figure 9.4. As B´ezier observed, the value of Vc provides
an excellent mechanism for determining the shape of the curve between two
values. Figure 9.6 shows a variety of graphs for diﬀerent values of Vc. A very
interesting eﬀect occurs when the value of Vc is set midway between V1 and
V2. For example, when V1 = 1 and V2 = 3 and Vc = 2, we obtain linear
interpolation between V1 and V2, as shown in Figure 9.7.

9 Curves and Patches
129
3.5
3
2
2.5
1.5
1
0.5
0
0
0.2
0.4
0.6
t
0.8
1
1.2
Fig. 9.7. Linear interpolation using a quadratic Bernstein interpolant.
9.3.2 Quadratic B´ezier Curves
Quadratic B´ezier curves are formed by using Bernstein polynomials to in-
terpolate between the x-, y- and z-coordinates associated with the start- and
end-points forming the curve. For example, we can draw a 2D quadratic B´ezier
curve between (1, 1) and (4, 3) using the following equations:
x = 1(1 −t)2 + xc2t(1 −t) + 4t2
y = 1(1 −t)2 + yc2t(1 −t) + 3t2
(9.11)
But what should be the values of (xc, yc)? Well, this is entirely up to us.
The position of this control vertex determines how the curve moves between
(1, 1) and (4, 3). A B´ezier curve possesses interpolating and approximating
qualities: the interpolating feature ensures that the curve passes through the
end-points, while the approximating feature shows how the curve passes close
to the control point. To illustrate this, if we make xc = 3 and yc = 4 we
obtain the curve shown in Figure 9.8, which shows how the curve intersects
the end-points, but misses the control point. It also highlights two important
features of B´ezier curves: the convex hull property, and the end slopes of the
curve.
The convex hull property implies that the curve is always contained within
the polygon connecting the end and control points. In this case the curve is
inside the triangle formed by the vertices (1, 1), (3, 4) and (4, 3). The slope of
the curve at (1, 1) is equal to the slope of the line connecting the start point
to the control point (3, 4), and the slope of the curve at (4, 3) is equal to the
slope of the line connecting the control point (3, 4) to the end-point (4, 3).
Naturally, these two qualities of B´ezier curves can be proved mathematically.
Before moving on, there are two further points to note:
•
No restrictions are placed on the position of (xc, yc) – it can be anywhere.
•
Simply including z-coordinates for the start, end and control vertices cre-
ates 3D curves.

130
Mathematics for Computer Graphics
4.5
4
3.5
3
2.5
2
1.5
1
0.5
0
0
1
2
3
4
5
x
y
Fig. 9.8. Quadratic B´ezier curve between (1, 1) and (4, 3), with (3, 4) as the control
vertex.
9.3.3 Cubic Bernstein Polynomials
One of the problems with quadratic curves is that they are so simple. If we
wanted to construct a complex curve with several peaks and valleys, we would
have to join together a large number of such curves. A cubic curve, on the
other hand, naturally supports one peak and one valley, which simpliﬁes the
construction of more complex curves.
When n = 3 in (9.7), we obtain the following terms:
( (1 −t) t)3 = (1 −t)3 + 3t(1 −t)2 + 3t2(1 −t) + t3
(9.12)
which can be used as a cubic interpolant, as
V = V1(1 −t)3 + Vc13t(1 −t)2 + Vc23t2(1 −t) + V2t3
(9.13)
Once more the terms sum to unity, and the convex hull and slope properties
also hold. Figure 9.9 shows the graphs of the four polynomial terms.
This time we have two control values, Vc1 and Vc2. These can be set to any
value, independent of the values chosen for V1 and V2. To illustrate this, let’s
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
0.2
0.4
0.6
0.8
1
1.2
Fig. 9.9. The cubic Bernstein polynomial curves.

9 Curves and Patches
131
3.5
3
2.5
2
1.5
1
0.5
0
0
0.1
0.2
0.3
0.4
0.5
t
0.6
0.7
0.8
0.9
1
Fig. 9.10. The cubic Bernstein polynomial through the values 1, 2.5, −2.5, 3.
consider an example of blending between values 1 and 3, with Vc1 and Vc2 set
to 2.5 and −2.5 respectively. The blending curve is shown in Figure 9.10.
The next step is to associate the blending polynomials with x- and y-
coordinates:
x = x1(1 −t)3 + xc13t(1 −t)2 + xc23t2(1 −t) + x2t3
y = y1(1 −t)3 + yc13t(1 −t)2 + yc23t2(1 −t) + y2t3
(9.14)
Evaluating (9.14) with the following points:
(x1, y1) = (1, 1)
(xc1, yc1) = (2, 3)
(xc2, yc2) = (3, −2) (x2, y2) = (4, 3)
we obtain the cubic B´ezier curve as shown in Figure 9.11, which also shows
the guidelines between the end and control points.
Just to show how consistent Bernstein polynomials are, let’s set the val-
ues to
(x1, y1) = (1, 1)
(xc1, yc1) = (2, 1.666)
(xc2, yc2) = (3, 2.333) (x2, y2) = (4, 3)
−3
−2
−1
0
1
2
3
4
y
1
2
3
4
5
0
x
Fig. 9.11. A cubic B´ezier curve.

132
Mathematics for Computer Graphics
3.5
3
2.5
2
1.5
1
0.5
0
0
1
2
3
x
4
5
y
Fig. 9.12. A cubic B´ezier line.
where (xc1, yc1) and (xc2, yc2) are points one-third and two-thirds between
the start and ﬁnal values. As we found in the quadratic case, where the single
control point was halfway between the start and end values, we obtain linear
interpolation as shown in Figure 9.12.
Mathematicians are always interested in ﬁnding how to express formulae
in compact and precise forms, so they have devised an elegant way of abbrevi-
ating (9.11) and (9.14). Equation (9.11) describes the three polynomial terms
for generating a quadratic B´ezier curve, and (9.14) describes the four poly-
nomial terms for generating a cubic B´ezier curve. To begin with, quadratic
equations are called second-degree equations, and cubics are called third-degree
equations. In the original Bernstein formulation,
Bn
i (t) =

n
i

ti(1 −t)n−i
(9.15)
n represents the degree of the polynomial, and i, which has values between
0 and n, creates the individual polynomial terms. These terms are then used
to multiply the coordinates of the end and control points. If these points are
stored as a vector P, a point p(t) on the curve can be written as
p(t) =

n
i

ti(1 −t)n−iPi for 0 ≤i ≤n
(9.16)
or
p(t) =
n

i=0

n
i

ti(1 −t)n−iPi
(9.17)
or
p(t) =
n

i=0
Bn
i (t)Pi
(9.18)
For example, a point p(t) on a quadratic curve is represented by
p(t) = 1t0(1 −t)2P0 + 2t1(1 −t)1P1 + 1t2(1 −t)0P2
(9.19)

9 Curves and Patches
133
You will discover (9.17) and (9.18) used in more advanced texts to describe
B´ezier curves. Although they may initially appear intimidating, you should
now ﬁnd them relatively easy to understand.
9.4 A recursive B´ezier Formula
Note that (9.17) explicitly describes the polynomial terms needed to construct
the blending terms. With the use of recursive functions (a recursive function
is a function that calls itself), it is possible to arrive at another formulation
that leads towards an understanding of B-splines. To begin, we need to ex-
press

n
i

in terms of lower terms, and because the coeﬃcients of any row
in Pascal’s triangle are the sum of the two coeﬃcients immediately above, we
can write
n
i

=
n −1
i

+
n −1
i −1

(9.20)
Therefore, we can write
Bn
i (t) =
n −1
i

ti(1 −t)n−i +
n −1
i −1

ti(1 −t)n−i
Bn
i (t) = (1 −t)Bn−1
i
(t) + tBn−1
i−1 (t)
(9.21)
As with all recursive functions, some condition must terminate the process: in
this case it is when the degree is zero. Consequently, B0
0(t) ≡1 and Bn
j (t) ≡0
for j < 0.
9.5 B´ezier Curves Using Matrices
As we have already seen, matrices provide a very compact notation for alge-
braic formulae. So let’s see how Bernstein polynomials lend themselves to this
form of notation. Recall (9.11), which deﬁnes the three terms associated with
a quadratic Bernstein polynomial. These can be expanded to
(1 −2t + t2) (2t −2t2)(t2)
(9.22)
and can be written as the product of two matrices:
[t2 t 1] ·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦
(9.23)
This means that (9.13) can be expressed as
V = [t2 t 1] ·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
V1
Vc
V2
⎤
⎦
(9.24)

134
Mathematics for Computer Graphics
and (9.14) as
p(t) = [t2 t 1] ·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
P1
Pc
P2
⎤
⎦
(9.25)
where p(t) is any point on the curve, and P1, Pc and P2 are the start, control
and end-points respectively.
A similar development can be used for a cubic B´ezier curve, which has the
following matrix formulation:
p(t) = [t3 t2 t 1] ·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
P1
Pc1
Pc2
P2
⎤
⎥⎥⎦
(9.26)
There is no doubt that B´ezier curves are very useful, and they ﬁnd their
way into all sorts of applications. Perhaps their one weakness, however, is
that whenever an end or control vertex is repositioned, the entire curve is
modiﬁed. So let’s examine another type of curve that prevents this from hap-
pening: B-splines. But before we consider their cubic form, let’s revisit linear
interpolation between multiple values.
9.5.1 Linear Interpolation
To interpolate linearly between two values V0 and V1, we use the following
interpolant:
V (t) = V0(1 −t) + V1t
for 0 ≤t ≤1
(9.27)
But say we have to interpolate continuously between three values on a lin-
ear basis, i.e. V0, V1, V2, with the possibility of extending the technique to
any number of values. One solution is to use a sequence of parameter values
t1, t2, t3 that are associated with the given values of V, as shown in Figure
9.13. For the sake of symmetry V0 is associated with the parameter range t0
to t2, V1 is associated with the parameter range t1 to t3, and V2 is associ-
ated with the parameter range t2 to t4. This sequence of parameters is called
a knot vector. The only assumption we make about the knot vector is that
t0 ≤t1 ≤t2 ≤, etc.
Now let’s invent a linear blending function B1
i (t) whose subscript i is used
to reference values in the knot vector. We want to use the blending function
to compute the inﬂuence of the three values on any interpolated value V(t)
as follows:
V (t) = B1
0(t)V0 + B1
1(t)V1 + B1
2(t)V2
(9.28)
It’s obvious from this arrangement that V0 will inﬂuence V (t) only when t
is between t0 and t2. Similarly, V1 and V2 will inﬂuence V (t) only when t is
between t1 and t3, and t2 and t4 respectively.

9 Curves and Patches
135
t0
t1
t2
t3
t4
V0
V1
V2
Fig. 9.13. Linearly interpolating between several values.
To understand the action of the blending function let’s concentrate on
one particular value B1
1(t). When t is less than t1 or greater than t3, the
function B1
1(t) must be zero. When t1 ≤t ≤t3, the function must return a
value reﬂecting the proportion of V1 that inﬂuences V (t). During the span
t1 ≤t ≤t2, V1 has to be blended in, and during the span t1 ≤t ≤t3, V1 has
to be blended out. The blending in is eﬀected by the ratio
 t −t1
t2 −t1

(9.29)
and the blending out is eﬀected by the ratio
 t3 −t
t3 −t2

(9.30)
Thus B1
1(t) has to incorporate both ratios, but it must ensure that they only
become active during the appropriate range of t. Let’s remind ourselves of this
requirement by subscripting the ratios accordingly:
B1
1(t) =
 t −t1
t2 −t1

1,2
+
 t3 −t
t3 −t2

2,3
(9.31)
We can now write the other two blending terms B1
0(t) and B1
2(t) as
B1
0(t) =
 t −t0
t1 −t0

0,1
+
 t2 −t
t2 −t1

1,2
(9.32)
B1
2(t) =
 t −t2
t3 −t2

2,3
+
 t4 −t
t4 −t3

3,4
(9.33)
You should be able to see a pattern linking the variables with their subscripts,
and the possibility of writing a general linear blending term B1
i (t) as
B1
i (t) =
 t −ti
ti+1 −ti

i,i+1
+
 ti+2 −t
ti+2 −ti+1

i+1,i+2
(9.34)
This enables us to write (9.28) in a general form as
V (t) =
2

i=0
B1
i (t)Vi
(9.35)

136
Mathematics for Computer Graphics
But there is still a problem concerning the values associated with the knot
vector. Fortunately, there is an easy solution. One simple approach is to keep
the diﬀerences between t1, t2 and t3 whole numbers, e.g. 0, 1 and 2. But
what about the end conditions t0 and t4? To understand the resolution of this
problem, let’s examine the action of the three terms over the range of the
parameter t. The three terms are
 t −t0
t1 −t0

0,1
+
 t2 −t
t2 −t1

1,2

V0
(9.36)
 t −t1
t2 −t1

1,2
+
 t3 −t
t3 −t2

2,3

V1
(9.37)
 t −t2
t3 −t2

2,3
+
 t4 −t
t4 −t3

3,4

V2
(9.38)
and I propose that the knot vector be initialized with the following values:
t0
t1
t2
t3
t4
0
0
1
2
2
•
Remember that the subscripts of the ratios are the subscripts of t, not the
values of t.
•
Over the range t0 ≤t ≤t1, i.e. 0 to 0. Only the ﬁrst ratio in (9.36) is
active and returns 0
0. The algorithm must detect this condition and take
no action.
•
Over the range t1 ≤t ≤t2, i.e. 0 to 1. The ﬁrst ratio of (9.36) is active
again, and over the range of t blends out V0. The ﬁrst ratio of (9.37) is
also active, and over the range of t blends in V1.
•
Over the range t2 ≤t ≤t3, i.e. 1 to 2. The second ratio of (9.37) is active,
and over the range of t blends out V1. The ﬁrst ratio of (9.38) is also active,
and over the range of t blends in V2.
•
Finally, over the range t3 ≤t ≤t4, i.e. 2 to 2. The second ratio of (9.38) is
active and returns 0
0. Once more, the algorithm must detect this condition
and take no action.
This process results in a linear interpolation between V0, V1 and V2. If (9.36),
(9.37) and (9.38) are applied to coordinate values, the result is two straight
lines. This seems like a lot of work just to draw two lines, but the beauty
of the technique is that it will work with any number of points, and can be
developed for quadratic and higher interpolations.
A. Aitken developed the following recursive interpolant:
pr
i(t) = ti+r −t
ti+r −ti
pr−1
i
(t) +
t −ti
ti+r −ti
pr−1
i+1(t);

r
= 1, . . n;
i
= 0, . . n −r;
(9.39)

9 Curves and Patches
137
which interpolates between a series of points using repeated linear interpola-
tion.
9.6 B-Splines
B-splines, like B´ezier curves, use polynomials to generate a curve segment.
But, unlike B´ezier curves, B-splines employ a series of control points that
determine the curve’s local geometry. This feature ensures that only a small
portion of the curve is changed when a control point is moved.
There are two types of B-splines: rational and non-rational splines, which
divide into two further categories: uniform and non-uniform. Rational
B-splines are formed from the ratio of two polynomials such as
x(t) = X(t)
W(t), y(t) = Y (t)
W(t), z(t) = Z(t)
W(t),
Although this appears to introduce an unnecessary complication, the division
by a second polynomial brings certain advantages:
•
They describe perfect circles, ellipses, parabolas and hyperbolas, whereas
non-rational curves can only approximate these curves.
•
They are invariant of their control points when subjected to rotation,
scaling, translation and perspective transformations, whereas non-rational
curves lose this geometric integrity.
•
They allow weights to be used at the control points to push and pull the
curve.
An explanation of uniform and non-uniform types is best left until you
understand the idea of splines. So, without knowing the meaning of uniform,
let’s begin with uniform B-splines.
9.6.1 Uniform B-Splines
A B-spline is constructed from a string of curve segments whose geometry
is determined by a group of local control points. These curves are known
as piecewise polynomials. A curve segment does not have to pass through a
control point, although this may be desirable at the two end-points.
Cubic B-splines are very common, as they provide a geometry that is one
step away from simple quadratics, and possess continuity characteristics that
make the joins between the segments invisible. In order to understand their
construction, consider the scenario in Figure 9.14. Here we see a group of
(m + 1) control points P0, P1, P2, . . . , Pm which determine the shape of a
cubic curve constructed from a series of curve segments S0, S1, S2, . . . , Sm−3.
As the curve is cubic, curve segment Si is inﬂuenced by Pi, Pi+1, Pi+2, Pi+3,
and curve segment Si+1 is inﬂuenced by Pi+1, Pi+2, Pi+3, Pi+4. There are
(m + 1) control points, so there are (m −2) curve segments.

138
Mathematics for Computer Graphics
Pi
Si
Pi+1
Si+1
Si+2
Pi+2
Pi+3
Si+3
Si+4
Pi+4
Pi+6
Pi+8
Si+6
Si+5
Pi+7
Fig. 9.14. The construction of a uniform non-rational B-spline curve.
A single segment Si(t) of a B-spline curve is deﬁned by
Si(t) =
3

r=0
Pi+rBr(t)
for
0 ≤t ≤1
(9.40)
where
B0(t) = −t3 + 3t2 −3t + 1
6
= (1 −t)3
6
(9.41)
B1(t) = 3t3 −6t2 + 4
6
(9.42)
B2(t) = −3t3 + 3t2 + 3t + 1
6
(9.43)
B3(t) = t3
6
(9.44)
These are the B-spline basis functions and are shown in Figure 9.15.
Although it is not apparent, these four curve segments are part of one
curve. The basis function B3 starts at zero and rises to 0.1666 at t = 1. It is
taken over by B2 at t = 0, which rises to 0.666 at t = 1. The next segment
is B1, which takes over at t = 0 and falls to 0.1666 at t = 1. Finally, B0
takes over at 0.1666 and falls to zero at t = 1. Equations (9.28)–(9.31) are
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
B(t)
t
Fig. 9.15. The B-spline basis functions.

9 Curves and Patches
139
represented in matrix form by
Q1(t) = [t3 t2 t 1] · 1
6 ·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
0
3
0
1
4
1
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
Pi
Pi+1
Pi+2
Pi+3
⎤
⎥⎥⎦
(9.45)
Let’s now illustrate how (9.45) works. We ﬁrst identify the control points
Pi, Pi+1, Pi+2, etc. Let these be (0, 1), (1, 3), (2, 0), (4, 1), (4, 3), (2, 2) and
(2, 3). They can be seen in Figure 9.16 connected together by straight lines.
If we take the ﬁrst four control points: (0, 1), (1, 3), (2, 0), (4, 1), and subject
the x- and y-coordinates to the matrix in (9.45) over the range 0 ≤t ≤1,
we obtain the ﬁrst B-spline curve segment shown in Figure 9.16. If we move
along one control point and take the next group of control points (1, 3), (2, 0),
(4, 1), (4, 3), we obtain the second B-spline curve segment. This is repeated
a further two times.
Figure 9.16 shows the four curve segments using two gray scales, and it is
obvious that even though there are four discrete segments, they join together
perfectly. This is no accident. The slopes at the end-points of the basis curves
are designed to match the slopes of their neighbours and ultimately to keep
the geometric curve continuous.
9.6.2 Continuity
Constructing curves from several segments can only succeed if the slopes of
the abutting curves match. As we are dealing with curves whose slopes are
changing everywhere, it is necessary to ensure that even the rate of change of
slopes is matched at the join. This aspect of curve design is called geometric
continuity and is determined by the continuity properties of the basis function.
Let’s explore such features.
The ﬁrst level of curve continuity, C0, ensures that the physical end of
one basis curve corresponds with the following, e.g. Si(1) = Si+1(0). We know
that this occurs by the graphs shown in Figure 9.15. The second level of curve
continuity, C1, ensures that the slope at the end of one basis curve matches
3.5
3
2.5
2
1.5
1
0.5
0
0
1
2
3
x
4
5
y
Fig. 9.16. Four curve segments forming a B-spline curve.

140
Mathematics for Computer Graphics
that of the following curve. This can be conﬁrmed by diﬀerentiating the basis
functions (9.28)–(9.31):
B
′
0(t) = −3t2 + 6t −3
6
(9.46)
B
′
1(t) = 9t2 −12t
6
(9.47)
B
′
2(t) = −9t2 + 6t + 3
6
(9.48)
B
′
3(t) = 3t2
6
(9.49)
Evaluating (9.46)–(9.49) for t = 0 and t = 1, we discover the slopes 0.5, 0,
−0.5, 0 for the joins between B3, B2, B1, B0. The third level of curve continu-
ity, C2, ensures that the rate of change of slope at the end of one basis curve
matches that of the following curve. This can be conﬁrmed by diﬀerentiating
(9.46)–(9.49):
B
′′
0(t) = −t + 1
(9.50)
B
′′
1(t) = 3t −2
(9.51)
B
′′
2(t) = −3t + 1
(9.52)
B
′′
3(t) = t
(9.53)
Evaluating (9.50)–(9.53) for t = 0 and t = 1, we discover the values 1, −2, 1, 0
for the joins between B3, B2, B1, B0. These combined continuity results are
tabulated in Table 9.4.
9.6.3 Non-Uniform B-Splines
Uniform B-splines are constructed from curve segments where the parameter
spacing is at equal intervals. Non-uniform B-splines, with the support of a
knot vector, provide extra shape control and the possibility of drawing periodic
shapes. Unfortunately an explanation of the underlying mathematics would
take us beyond the introductory nature of this text, and readers are advised
to seek out other books dealing in such matters.
Table 9.4. Continuity properties of cubic B-splines
t
t
t
C0
0
1
C1
0
1
C2
0
1
B3(t)
0
1/6
B
′
3(t)
0
0.5
B
′′
3(t)
0
1
B2(t)
1/6
2/3
B
′
2(t)
0.5
0
B
′′
2(t)
1
−2
B1(t)
2/3
1/6
B
′
1(t)
0
−0.5
B
′′
1(t)
−2
1
B0(t)
1/6
0
B
′
0(t)
−0.5
0
B
′′
0(t)
1
0

9 Curves and Patches
141
9.6.4 Non-Uniform Rational B-Splines
Non-uniform rational B-splines (NURBS) combine the advantages of non-
uniform B-splines and rational polynomials: they support periodic shapes such
as circles, and they accurately describe curves associated with the conic sec-
tions. They also play a very important role in describing geometry used in the
modelling of computer animation characters.
NURBS surfaces also have a patch formulation and play a very important
role in surface modelling in computer animation and CAD. However, tempting
though it is to give a description of NURBS surfaces here, they have been
omitted because their inclusion would unbalance the introductory nature of
this text.
9.7 Surface Patches
9.7.1 Planar Surface Patch
The simplest form of surface geometry consists of a patchwork of polygons
or triangles, where three or more vertices provide the basis for describing the
associated planar surface. For example, given four vertices P00, P10, P01, P11,
as shown in Figure 9.17, a point Puv can be deﬁned as follows. To begin with,
a point along the edge P00 −P10 is deﬁned as
Pu1 = (1 −u)P00 + uP10
(9.54)
and a point along the edge P01 −P11 is deﬁned as
Pu2 = (1 −u)P01 + uP11
(9.55)
Therefore, any point Puv is deﬁned as
Puv = (1 −v)Pu1 + vPu2
Puv = (1 −v)[(1 −u)P00 + uP10] + v[(1 −u)P01 + uP11]
Puv = (1 −u)(1 −v)P00 + u(1 −v)P10 + v(1 −u)P01 + uvP11
(9.56)
P11
Puv
P01
P00
P10
u
v
Fig. 9.17. A ﬂat patch deﬁned by u and v parameters.

142
Mathematics for Computer Graphics
This, however, can be written in matrix form as
Puv = [(1 −u) u] ·

P00
P01
P10
P11

·

(1 −v)
v

(9.57)
which expands to
Puv = [u 1] ·

−1
1
1
0

·

P00
P01
P10
P11

·

−1
1
1
0

·

v
1

(9.58)
Let’s illustrate this with an example. Given the following four points: P00 =
(0, 0, 0), P10 = (0, 0, 4) P01 = (2, 2, 1), P11 = (2, 2, 3), we can write the coordi-
nates of any point on the patch as
xuv = [u 1] ·
 −1
1
1
0

·
 0
2
0
2

·
 −1
1
1
0

·
 v
1

yuv = [u 1] ·
 −1
1
1
0

·
 0
2
0
2

·
 −1
1
1
0

·
 v
1

zuv = [u 1] ·

−1
1
1
0

·

0
1
4
3

·

−1
1
1
0

·

v
1

xuv = 2v
yuv = 2v
zuv = u(4 −2v) + v
By substituting values of u and v in (9.47) between the range 0 ≤u, v ≤1
we obtain the coordinates of any point on the surface of the patch.
If we now introduce the ideas of B´ezier control points into a surface patch
deﬁnition, we provide a very powerful way of creating smooth 3D surface
patches.
9.7.2 Quadratic B´ezier Surface Patch
B´ezier proposed a matrix of nine control points to determine the geometry of
a quadratic patch, as shown in Figure 9.18. Any point on the patch is deﬁned
by
Puv = [u2 u 1]·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
P00
P01
P02
P10
P11
P12
P20
P21
P22
⎤
⎦·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
The individual x, y and z-coordinates are obtained by substituting the x, y
and z values for the central P matrix.
Let’s illustrate the process with an example. Given the following points:
P00 = (0, 0, 0)
P01 = (1, 1, 0)
P02 = (2, 0, 0)
P10 = (0, 1, 1)
P11 = (1, 2, 1)
P12 = (2, 1, 1)
P20 = (0, 0, 2)
P21 = (1, 1, 2)
P22 = (2, 0, 2)

9 Curves and Patches
143
P00
P10
P01
P11
P12
P21
P02
P22
P2
Fig. 9.18. A quadratic B´ezier surface patch.
we can write
xuv = [u2 u 1] ·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
0
1
2
0
1
2
0
1
2
⎤
⎦·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
xuv = [u2 u 1] ·
⎡
⎣
0
0
0
0
0
0
0
2
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
xuv = 2v
yuv = [u2 u 1] ·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
0
1
0
1
2
1
0
1
0
⎤
⎦·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
yuv = [u2 u 1] ·
⎡
⎣
0
0
−2
0
0
2
−2
2
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
yuv = 2(u + v −u2 −v2)
zuv = [u2 u 1] ·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
0
0
0
1
1
1
2
2
2
⎤
⎦·
⎡
⎣
1
−2
1
−2
2
0
1
0
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
zuv = [u2 u 1] ·
⎡
⎣
0
0
0
0
0
2
0
0
0
⎤
⎦·
⎡
⎣
v2
v
1
⎤
⎦
zuv = 2u
Therefore, any point on the surface patch has coordinates
xuv = 2v, yuv = 2(u + v −u2 −v2), zuv = 2u

144
Mathematics for Computer Graphics
Table 9.5. The x, y, z coordinates for diﬀerent
values of u and v
V
0
1
2
1
0
(0, 0, 0)

1, 1
2, 0

(2, 0, 0)
u
1
2

0, 1
2, 1


1, 1
2, 1


2, 1
2, 1

1
(0, 0, 2)

1, 1
2, 2

(2, 0, 2)
Table 9.5 shows the coordinate values for diﬀerent values of u and v. In this
example, the y-coordinates provide the surface curvature, which could be
enhanced by modifying the y-coordinates of the control points.
9.7.3 Cubic B´ezier Surface Patch
As we saw earlier in this chapter, cubic B´ezier curves require two end-points,
and two central control points. In the surface patch formulation a 4×4 matrix
is required as follows:
Puv = [u3 u2 u 1] ·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
P00
P01
P02
P03
P10
P11
P12
P13
P20
P21
P22
P23
P30
P31
P32
P33
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
which can be illustrated by an example.
Given the points:
P00 = (0, 0, 0)
P01 = (1, 1, 0)
P02 = (2, 1, 0)
P03 = (3, 0, 0)
P10 = (0, 1, 1)
P11 = (1, 2, 1)
P12 = (2, 2, 1)
P13 = (3, 1, 1)
P20 = (0, 1, 2)
P21 = (1, 2, 2)
P22 = (2, 2, 2)
P23 = (3, 1, 2)
P30 = (0, 0, 3)
P31 = (1, 1, 3)
P32 = (2, 1, 3)
P33 = (3, 0, 3)

9 Curves and Patches
145
we can write the following matrix equations:
xuv = −[u3 u2 u 1] ·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
0
1
2
3
0
1
2
3
0
1
2
3
0
1
2
3
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
xuv = [u3 u2 u 1] ·
⎡
⎢⎢⎣
0
0
0
0
0
0
0
0
0
0
0
0
0
0
3
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
xuv = 3u
yuv = [u3 u2 u 1] ·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
0
1
1
0
1
2
2
1
1
2
2
1
0
1
1
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
yuv = [u3 u2 u 1] ·
⎡
⎢⎢⎣
0
0
0
0
0
0
0
−3
0
0
0
3
0
−3
3
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
yuv = 3(u + v −u2 −v2)
zuv = [u3 u2 u 1] ·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
0
0
0
0
1
1
1
1
2
2
2
2
3
3
3
3
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
−1
3
−3
1
3
−6
3
0
−3
3
0
0
1
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
zuv = [u3 u2 u 1] ·
⎡
⎢⎢⎣
0
0
0
0
0
0
0
0
0
0
0
3
0
0
0
0
⎤
⎥⎥⎦·
⎡
⎢⎢⎣
v3
v2
v
1
⎤
⎥⎥⎦
zuv = 3u

146
Mathematics for Computer Graphics
Table 9.6. The x, y, z coordinates for diﬀerent
values of u and v
v
0
1
2
1
0
(0, 0, 0)

11
2, 3
4, 0

(3, 0, 0)
u
1
2

0, 3
4, 11
2


11
2, 11
2, 11
2


3, 3
4, 11
2

1
(0, 0, 3)

11
2, 3
4, 3

(3, 0, 3)
Therefore, any point on the surface patch has coordinates
xuv = 3v, yuv = 3(u + v −u2 −v2), zuv = 3u
Table 9.6 shows the coordinate values for diﬀerent values of u and v. In this
example, the y-coordinates provide the surface curvature, which could be
enhanced by modifying the y-coordinates of the control points.
Complex 3D surfaces are readily modelled using B´ezier patches. One sim-
ply creates a mesh of patches such that their control points are shared at the
joins. Surface continuity is controlled using the same mechanism for curves.
But where the slopes of trailing and starting control edges apply for curves,
the corresponding slopes of control tiles apply for patches.
9.8 Summary
This chapter has been the most challenging one to write. On the one hand,
the subject is vital to every aspect of computer graphics, but on the other,
the reader is required to wrestle with cubic polynomials and a little calculus.
However, I do hope that I have managed to communicate some essential con-
cepts behind curves and surfaces, and that you will be tempted to implement
some of the mathematics.

10
Analytic Geometry
This chapter explores some basic elements of geometry and analytic geome-
try that are frequently encountered in computer graphics. For completeness,
I have included a short review of important elements of Euclidean geome-
try with which you should be familiar. Perhaps the most important topics
that you should try to understand concern the deﬁnitions of straight lines in
space, 3D planes, and how points of intersection are computed. Another useful
topic is the role of parameters in describing lines and line segments, and their
intersection.
10.1 Review of Geometry
In the 3rd century bce Euclid laid the foundations of geometry that have been
taught in schools for centuries. In the 19th century, mathematicians such as
Bernhard Riemann (1809–1900) and Nicolai Lobachevsky (1793–1856) trans-
formed this traditional Euclidean geometry with ideas such as curved space
and spaces with higher dimensions. Although none of these developments
aﬀect computer graphics, they do place Euclid’s theorems in a speciﬁc con-
text: a set of axioms that apply to ﬂat surfaces. We have probably all been
taught that parallel lines don’t meet, and that the internal angles of a triangle
sum to 180◦, but these things are only true in speciﬁc situations. As soon as
the surface or space becomes curved, such rules break down. So let’s review
some rules and observations that apply to shapes drawn on a ﬂat surface.

148
Mathematics for Computer Graphics
b
b
b
a
a
a
Fig. 10.1. Examples of adjacent/supplementary, opposite and complementary angles.
a
a
b
c
b
c
d
d
Fig. 10.2. 1st intercept theorem.
10.1.1 Angles
By deﬁnition, 360◦or 2π [radians] measure one revolution. The reader should
be familiar with both units of measurement, and how to convert from one to
the other (see page 26). Figure 10.1 shows examples of adjacent/supplementary
angles (sum to 180◦) opposite angles (equal), and complementary angles (sum
to 90◦).
10.1.2 Intercept Theorems
Figures 10.2 and 10.3 show scenarios involving intersecting lines and parallel
lines that give rise to the following observations:
•
First intercept theorem:
a + b
a
= c + d
c
, b
a = d
c
(10.1)
•
Second intercept theorem:
a
b = c
d
(10.2)

10 Analytic Geometry
149
d
a
a
b
b
c
c
d
Fig. 10.3. 2nd intercept theorem.
2.5
1.545
Fig. 10.4. A rectangle with a height to width ratio equal to the Golden Section.
10.1.3 Golden Section
The golden section is widely used in art and architecture to represent an ‘ideal’
ratio for the height and width of an object. Its origins stem from the interac-
tion between a circle and triangle and give rise to the following relationship:
b = a
2
√
5 −1

≈0.618a
(10.3)
The rectangle in Figure 10.4 has the proportions
height = 0.618 × width.
However, it is interesting to note that the most widely observed rectangle -the
television screen-bears no relation to this ratio.
10.1.4 Triangles
The rules associated with interior and exterior angles of a triangle are very
useful in solving all sorts of geometric problems. Figure 10.5 shows two dia-
grams identifying interior and exterior angles. We can see that the sum of the

150
Mathematics for Computer Graphics
a
a
a
q
q
a
a
b
b
b
b
b
q
Fig. 10.5. Relationship between interior and exterior angles.
interior angles is 180◦, and that the exterior angles of a triangle are equal to
the sum of the opposite angles:
α + β + θ = 180◦
(10.4)
α′ = θ + β
(10.5)
β′ = α + θ
(10.6)
θ′ = α + β
(10.7)
10.1.5 Centre of Gravity of a Triangle
A median is a straight line joining a vertex of a triangle to the mid-point
of the opposite side. When all three medians are drawn, they intersect at a
common point, which is also the triangle’s centre of gravity. The centre of
gravity divides all the medians in the ratio 2 : 1. Figure 10.6 illustrates this
arrangement.
10.1.6 Isosceles Triangle
Figure 10.7 shows an isosceles triangle, which has two equal sides of length l
and equal base angles α. The triangle’s altitude and area are
h =

l2 −
 c
2
2
A = 1
2ch
(10.8)

10 Analytic Geometry
151
c
c
a
a
b
b
Fig. 10.6. The three medians of a triangle intersect as its centre of gravity.
l
l
h
a
a
c
2
c
2
Fig. 10.7. An isosceles triangle has two equal sides l and equal base angles α.
10.1.7 Equilateral Triangle
An equilateral triangle has three equal sides of length l and equal angles of
60◦. The triangle’s altitude and area are
h =
√
3
2 l
A =
√
3
4 l2
(10.9)
10.1.8 Right Triangle
Figure 10.8 shows a right triangle with its obligatory right angle. The triangle’s
altitude and area are
h = ab
c
A = 1
2ab
(10.10)

152
Mathematics for Computer Graphics
b
h
a
c
Fig. 10.8. A Right angled triangle.
Fig. 10.9. The Theorem of Thales states that the right angle of a right triangle lies
on the circumcircle over the hypotenuse.
10.1.9 Theorem of Thales
Figure 10.9 illustrates the theorem of Thales, which states that the right angle
of a right triangle lies on the circumcircle over the hypotenuse.
10.1.10 Theorem of Pythagoras
Despite its name, there is substantial evidence to show that this theorem was
known by the Babylonians a millennium before Pythagoras. However, he is
credited with its proof. Figure 10.10 illustrates the well-known relationship
c2 = a2 + b2
(10.11)
from which one can show that
sin2(α) + cos2(α) = 1
(10.12)
10.1.11 Quadrilaterals
Quadrilaterals have four sides. Examples include the square, rectangle, trape-
zoid, parallelogram and rhombus, whose interior angles sum to 360◦. As the
square and rectangle are such familiar shapes, we will only consider the other
three.

10 Analytic Geometry
153
c
a
a
b
b
c
Fig. 10.10. The Theorem of Pythagoras states that c2 = a2 + b2.
10.1.12 Trapezoid
Figure 10.11 shows a trapezoid which has one pair of parallel sides h apart.
The mid-line m and area are given by
m = 1
2(a + b) A = mh
(10.13)
10.1.13 Parallelogram
Figure 10.12 shows a parallelogram. This is formed from two pairs of inter-
secting parallel lines, so it has equal opposite sides and equal opposite angles.
The altitude and diagonal lengths are given by
h = b · sin α
(10.14)
d1,2 =

a2 + b2 ± 2a

b2 −h2
(10.15)
and the area by
A = ah
(10.16)
10.1.14 Rhombus
Figure 10.13 shows a rhombus, which is a parallelogram with four sides of
equal length a. The area is given by
A = a2 sin(α) = d1d2
2
(10.17)

154
Mathematics for Computer Graphics
b
m
a
h
Fig. 10.11. A trapezoid with one pair of parallel sides.
h
b
b
a
a
a
Fig. 10.12. A parallelogram formed by two pairs of parallel lines.
a
a
a
a
a
d2
d1
Fig. 10.13. A rhombus is a parallelogram with four equal sides.
10.1.15 Regular Polygon (n-gon)
Figure 10.14 shows part of a regular n-gon with outer radius Ro, inner radius
Ri and edge length an. Table 10.1 shows the relationship between the area,
an, Ri and Ro for diﬀerent polygons.
10.1.16 Circle
The circumference and area of a circle are given by
C = π d = 2πr
(10.18)

10 Analytic Geometry
155
Table 10.1. The area An, edge length an, internal radius Ri and external radius Ro
for diﬀerent polygons
n
an = 2Ri tan(180◦/n)
Ri = Ro cos(180◦/n)
R2
o = R2
i + 1
4a2
n
n
An = n
4 a2
n cot(180◦/n)
An = n
2 R2
0 sin(360◦/n)
An = nR2
i tan(180◦/n)
5
a5 = 2Ri

5 −2
√
5
Ri = Ro
4
√
5 + 1
Ro = Ri
√
5 −1
5
A5 = a2
5
4

25 + 10
√
5
A5 = 5
8R2
o

10 + 2
√
5
A5 = 5R2
i

5 −2
√
5
6
a6 = 2
3Ri
√
3
Ri = Ro
2
√
3
Ro = 2
3Ri
√
3
6
A6 = 3
2a2
6
√
3
A6 = 3
2R2
o
√
3
A6 = 2R2
i
√
3
8
a8 = 2Ri
√
2 −1
Ri = Ro
2

2 +
√
2
Ro = Ri

4 −2
√
2
8
A8 = 2a2
8
√
2 + 1
A8 = 2R2
o
√
2
A8 = 8R2
i
√
2 −1
10
a10 = 2
5Ri

25 −10
√
5
Ri = Rc
4

10 + 2
√
5
Ro = Ri
5

50 −10
√
5
10
A10 = 5
2a2
10

5 + 2
√
5
A10 = 5
4R2
o

10 −2
√
5
A10 = 2R2
i

25 −10
√
5
Ro
Ri
an
Fig. 10.14. Part of a regular gon showing the internal and outer radii and the edge
length.
A = π r2 = π d2
4
(10.19)
where d = 2r.
An annulus is the area between two concentric circles, as shown in Figure
10.15, and its area is given by
A = π(R2 −r2) = π
4 (D2 −d2)
(10.20)
where D = 2R and d = 2r.

156
Mathematics for Computer Graphics
R
r
Fig. 10.15. An annulus formed from two concentric circles.
r
a
Fig. 10.16. A sector of a circle deﬁned by the angle α.
Figure 10.16 shows a sector of a circle, whose area is given by
A =
α
360◦π r2
(10.21)
Figure 10.17 shows a segment of a circle, whose area is given by
A = r2
2 (α −sin(α))
(α is in radians)
(10.22)
The area of an ellipse with major and minor radii a and b is given by
A = πab
(10.23)
10.2 2D Analytical Geometry
In this section we brieﬂy examine familiar descriptions of geometric elements
and ways of computing intersections.
10.2.1 Equation of a Straight Line
The well-known equation of a line is
y = mx + c
(10.24)

10 Analytic Geometry
157
a
Fig. 10.17. A segment of a circle deﬁned by the angle α.
c
X
m
Y
Fig. 10.18. The normal form of the straight line is y = mx + c.
where m is the slope and c the intersection with the y-axis, as shown in
Figure 10.18. This is called the normal form.
Given two points (x1, y1) and (x2, y2) we can state
y −y1
x −x1
= y2 −y1
x2 −x1
(10.25)
which yields
y = (x −x1) y2 −y1
x2 −x1
+ y1
(10.26)
Although these equations have their uses, the more general form is much more
convenient:
ax + by + c = 0
(10.27)
As we shall see, this equation possesses some interesting qualities.

158
Mathematics for Computer Graphics
10.2.2 The Hessian Normal Form
Figure 10.19 shows a line whose orientation is controlled by a normal unit
vector n = [a b]T. If P(x, y) is any point on the line, then p is a position
vector where p = [x y]T and d is the perpendicular distance from the origin
to the line.
Therefore
d
∥p∥= cos(α)
and
d = ∥p∥cos(α)
(10.28)
But the dot product n · p is given by
n · p = ∥n∥∥p∥cos(α) = ax + by
(10.29)
which implies that
ax + by = d∥n∥
(10.30)
and because ∥n∥= 1 we can write
ax + by −d = 0
(10.31)
where (x, y) is a point on the line, a and b are the components of a unit vector
normal to the line and d is the perpendicular distance from the origin to the
line. The distance d is positive when the normal vector points away from the
origin, otherwise it is negative.
Let’s consider two examples.
•
Example 1. Find the equation of a line whose normal vector is [3 4]T and
the perpendicular distance from the origin to the line is 1.
To begin, we normalize the normal vector to its unit form.
d
a
P(x, y)
n
Y
X
P
Fig. 10.19. The orientation of a line can be controlled by a normal vector n and
distance d.

10 Analytic Geometry
159
Therefore if n = [3 4]T, ∥n∥=
√
32 + 42 = 5
The equation of the line is
3
5x + 4
5y −1 = 0
•
Example 2. Given y = 2x + 1, what is the Hessian normal form?
Rearranging the equation, we get
2x −y + 1 = 0
If we want the normal vector to point away from the origin we multiply by −1:
−2x + y −1 = 0
Normalize the normal vector to a unit form, i.e.
i.e.

(−2)2 + 12 =
√
5
−2
√
5x + 1
√
5y −1
√
5 = 0
Therefore, the perpendicular distance from the origin to the line and the unit
normal vector are respectively
1
√
5 and
−2
√
5
1
√
5
T
The two signs from the square root provide the alternate directions of the
vector, and the sign of d.
As the Hessian normal form involves a unit normal vector, we can incor-
porate the vector’s direction cosines within the equation:
x cos(α) + y sin(α) −d = 0
(10.32)
where α is the angle between the perpendicular and the x-axis.
10.2.3 Space Partitioning
The Hessian normal form provides a very useful way of partitioning space
into two zones: points above the line in the partition that includes the normal
vector, and points in the opposite partition. This is illustrated in Figure 10.20.
Given the equation
ax + by −d = 0
(10.33)
a point (x, y) on the line satisﬁes the equation. But if we substitute another
point (x1, y1) which is in the partition in the direction of the normal vector,
it creates the inequality
ax1 + by1 −d > 0
(10.34)

160
Mathematics for Computer Graphics
Y
X
ax + by - d < 0
ax + by - d = 0
ax + by - d > 0
Fig. 10.20. The Hessian normal form of the line equation partitions space into two
zones.
Conversely, a point (x2, y2) which is in the partition opposite to the direction
of the normal vector creates the inequality
ax2 + by2 −d < 0
(10.35)
This space-partitioning feature of the Hessian normal form is useful in clipping
lines against polygonal windows.
10.2.4 The Hessian Normal Form from Two Points
Given two points (x1, y1) and (x2, y2), we can compute the values of a, b and
d for the Hessian normal form as follows. To begin with, we observe:
y −y1
x −x1
= y2 −y1
x2 −x1
= ∆y
∆x
(10.36)
therefore
(y −y1)∆x = (x −x1)∆y
(10.37)
and
x∆y −y∆x −x1∆y + y1∆x = 0
(10.38)
which is the general equation of a straight line. For the Hessian normal form,

∆x2 + ∆y2 = 1
Therefore, the Hessian normal form is given by
x∆y −y∆x −(x1∆y −y1∆x)

∆x2 + ∆y2
= 0
(10.39)
Let’s test this with an example. Given the following points: (x1, y1) = (0, 1)
and (x2, y2) = (1, 0); ∆x = 1, ∆y = −1.

10 Analytic Geometry
161
Therefore, using (10.38),
x(−1) −y(1) −(0 × −1 −1 × 1) = 0
−x −y + 1 = 0
(10.40)
which is the general equation for the line. We now convert it to the Hessian
normal form:
−x −y + 1

12 + (−1)2 = −x −y + 1
√
2
= 0
−x
√
2 −y
√
2 +
1
√
2 = 0
(10.41)
The choice of sign in the denominator anticipates the two directions for the
normal vector, and the sign of d.
10.3 Intersection Points
10.3.1 Intersection Point of Two Straight Lines
Given two line equations of the form
a1x + b1y + c1 = 0
a2x + b2y + c2 = 0
(10.42)
the intersection point (xi, yi) is given by
xi = b1c2 −b2c1
a1b2 −a2b1
and yi = c1a2 −c2a1
a1b2 −a2b1
(10.43)
If the denominator is zero, the equations are linearly dependent, indicating
that there is no intersection.
10.3.2 Intersection Point of Two Line Segments
We are often concerned with line segments in computer graphics as they rep-
resent the edges of shapes and objects. So let’s investigate how to compute
the intersection of two 2D-line segments.
Figure 10.21 shows two line segments deﬁned by their end-points (P1 −P2)
and (P3 −P4). If we locate position vectors at these points, we can write the
following vector equations to identify the point of intersection:
Pi = P1 + t(P2 −P1)
Pi = P3 + s(P4 −P3)
(10.44)
where parameters s and t vary between 0 and 1. For the point of intersection,
we can write
P1 + t(P2 −P1) = P3 + s(P4 −P3)
(10.45)

162
Mathematics for Computer Graphics
Y
X
P1
P4
P2
P3 Pi
Fig. 10.21. Two line segments with their associated position vectors.
Therefore, the parameters s and t are given by
s = (P1 −P3) + t(P2 −P1)
(P4 −P3)
t = (P3 −P1) + s(P4 −P3)
(P2 −P1)
(10.46)
From (10.46) we can write
t = (x3 −x1) + s(x4 −x3)
(x2 −x1)
t = (y3 −y1) + s(y4 −y3)
(y2 −y1)
(10.47)
which yields
t = x1(y4 −y3) + x3(y1 −y4) + x4(y3 −y1)
(y2 −y1)(x4 −x3) −(x2 −x1)(y4 −y3)
and similarly,
s = x1(y3 −y2) + x2(y3 −y1) + x3(y2 −y1)
(y4 −y3)(x2 −x1) −(x4 −x3)(y2 −y1)
(10.48)
Let’s test (10.48) with two examples to illustrate how this equation can be
used in practice. The ﬁrst example will demonstrate an intersection condition,
and the second demonstrates a touching condition.
•
Example 1. Figure 10.22a shows two line segments intersecting, with an
obvious intersection point of (1.5, 0.0). The coordinates of the line segments
are
(x1, y1) = (1, 0)
(x2, y2) = (2, 0)
(x3, y3) = (1.5, −1.0)
(x4, y4) = (1.5, 1.0)

10 Analytic Geometry
163
1
1
−1
2
Y
X
(a)
1
1
−1
2
Y
X
(b)
Fig. 10.22. (a) Shows two line segments intersecting, and (b) shows two line segments
touching.
therefore
t = 1(1 −(−1)) + 1.5(0 −1) + 1.5(−1 −0)
(0 −0)(1.5 −1.5) −(2 −1)(1 −(−1))
t = 2 −1.5 −1.5
−2
= 0.5
and
s = 1(−1 −0) + 2(0 −(−1)) + 1.5(0 −0)
(1 −(−1))(2 −1) −(1.5 −1.5)(0 −0) = 0.5
Substituting t and s in (10.44) we get (xi, yi) = (1.5, 0.0), as predicted.
•
Example 2. Figure 10.22b shows two line segments touching at (1.5, 0.0).
The coordinates of the line segments are
(x1, y1) = (1, 0)
(x2, y2) = (2, 0)
(x3, y3) = (1.5, 0.0)
(x4, y4) = (1.5, 1.0)
therefore
t = 1(1.0 −0.0) + 1.5(0.0 −1.0) + 1.5(0.0 −0.0)
(0.0 −0.0)(1.5 −1.5) −(2.0 −1.0)(1.0 −0.0)
t = 1.0 −1.5
−1.0
= 0.5
s =
1(0 −0) + 2(0 −0) + 1.5(0 −0)
(1 −0)(2 −1) −(1.5 −1.5)(0 −0)
s = 0
1 = 0
The zero value of s conﬁrms that the lines touch, rather than intersect, and
t = 0.5 conﬁrms that the touching takes place halfway along the line segment.

164
Mathematics for Computer Graphics
10.4 Point Inside a Triangle
We often require to test whether a point is inside, outside or touching a
triangle. Let’s examine two ways of performing this operation. The ﬁrst is
related to ﬁnding the area of a triangle.
10.4.1 Area of a Triangle
Let’s declare a triangle formed by the anti-clockwise points (x1, y1), (x2, y2)
and (x3, y3), as shown in Figure 10.23. The area of the triangle is given by:
A = (x2−x1)(y3−y1)−1
2(x2−x1)(y2−y1)−1
2(x2−x3)(y3−y2)−1
2(x3−x1)(y3−y1)
which simpliﬁes to
A = 1
2[x1(y2 −y3) + x2(y3 −y1) + x3(y1 −y2)]
and this can be further simpliﬁed to
A = 1
2

x1
y1
1
x2
y2
1
x3
y3
1

(10.49)
Figure 10.24 shows two triangles with opposing vertex sequences. If we calcu-
late the area of the top triangle with anti-clockwise vertices, we obtain
A = 1
2[1(2 −4) + 3(4 −2) + 2(2 −2)] = 2
Y
X
P3
P2
P1
Fig. 10.23. The area of the triangle is computed by subtracting the smaller triangles
from the rectangular area.

10 Analytic Geometry
165
Y
X
P3
P1
P2
P3
Fig. 10.24. The top triangle has anti-clockwise vertices, and the bottom triangle
clockwise vertices.
whereas the area of the bottom triangle with clockwise vertices is
A = 1
2[1(2 −0) + 3(0 −2) + 2(2 −2)] = −2
So the technique is sensitive to vertex direction. We can exploit this sensitivity
to test if a point is inside or outside a triangle.
Consider the scenario shown in Figure 10.25, where the point Pt is inside
the triangle (P1, P2, P3).
•
If the area of triangle (P1, P2, Pt) is positive, Pt must be to the left of the
line (P1, P2).
•
If the area of triangle (P2, P3, Pt) is positive, Pt must be to the left of the
line (P2, P3).
•
If the area of triangle (P3, P1, Pt) is positive, Pt must be to the left of the
line (P3, P1).
If all the above tests are positive, Pt is inside the triangle. Furthermore, if one
area is zero and the other areas are positive, the point is on the boundary,
and if two areas are zero and the other positive, the point is on a vertex.
Let’s now investigate how the Hessian normal form provides a similar
function.
10.4.2 Hessian Normal Form
We can determine whether a point is inside, touching or outside a triangle
by representing the triangle’s edges in the Hessian normal form, and testing
which partition the point is located in. If we arrange that the normal vectors
are pointing towards the inside of the triangle, any point inside the triangle

166
Mathematics for Computer Graphics
Y
P
P3
P2
Pt
X
Fig. 10.25. If the point Pt is inside the triangle, it is always to the left as the boundary
is traversed in an anti-clockwise sequence.
will create a positive result when tested against the edge equation. In the
following calculations there is no need to ensure that the normal vector is a
unit vector.
To illustrate this in action, consider the scenario shown in Figure 10.26
where we see a triangle formed by the points (1, 1), (3, 1) and (2, 3). With
reference to (10.38) we compute the three line equations:
1. The line between (1, 1) and (3, 1):
0(x −1) + 2(1 −y) = 0
−2y + 2 = 0
(10.50)
Y
(2, 3)
(3, 1)
(1, 1)
X
Fig. 10.26. The triangle is formed from three line equations expressed in the Hessian
normal form. Any point inside the triangle can be found by evaluating the equations.

10 Analytic Geometry
167
Multiply (10.50) by −1 to reverse the normal vector:
2y −2 = 0
(10.51)
2. The line between (3, 1) and (2, 3):
2(x −3) + (−1)(1 −y) = 0
2x −6 −1 + y = 0
2x + y −7 = 0
(10.52)
Multiply (10.52) by −1 to reverse the normal vector:
−2x −y + 7 = 0
(10.53)
3. The line between (2, 3) and (1, 1):
(−2)(x −2) + (−1)(3 −y) = 0
−2x + 4 −3 + y = 0
−2x + y + 1 = 0
(10.54)
Multiply (10.54) by −1 to reverse the normal vector:
2x −y −1 = 0
Thus the three line equations for the triangle are
2y −2 = 0
−2x −y + 7 = 0
2x −y −1 = 0
(10.55)
We are only interested in the sign of the left-hand expressions:
2y −2
−2x −y + 7
2x −y −1
(10.56)
which can be tested for any arbitrary point (x, y). If they are all positive, the
point is inside the triangle. If one expression is negative, the point is outside.
If one expression is zero, the point is on an edge, and if two expressions are
zero, the point is on a vertex.
Just as a quick test, consider the point (2, 2). The three expressions (10.56)
are positive, which conﬁrms that the point is inside the triangle. The point
(3, 3) is obviously outside the triangle, which is conﬁrmed by two positive
results and one negative. Finally, the point (2, 3), which is a vertex, gives one
positive result and two zero results.

168
Mathematics for Computer Graphics
10.5 Intersection of a Circle with a Straight Line
The equation of a circle has already been given in the previous chapter, so we
will now consider how to compute its intersection with a straight line.
We begin by testing the equation of a circle with the normal form of the
line equation:
x2 + y2 = r2 and y = mx + c
By substituting the line equation in the circle’s equation we discover the two
intersection points:
x1,2 = −mc ±

r2(1 + m2) −c2
1 + m2
y1,2 = c ± m

r2(1 + m2) −c2
1 + m2
(10.57)
Let’s test this result with the scenario shown in Figure 10.27. Using the normal
form of the line equation, we have
y = x + 1 where m = 1 and c = 1
Substituting these values in (10.57) yields
x1,2 = −1, 0 and y1,2 = 0, 1
The actual points of intersection are (−1, 0) and (0,1).
X
Y
1
1
−1
y = x + 1
x −y + 1 = 0
−0.707x + 0.707y − 0.707 = 0
x 2 + y 2 = r 2
Fig. 10.27. The intersection of a circle with a line deﬁned in its normal form, general
form, and the Hessian normal form.

10 Analytic Geometry
169
Testing the equation of the circle with the general equation of the line
ax + by + c = 0 yields intersections given by
x1,2 = −ac ± b

r2(a2 + b2) −c2
a2 + b2
y1,2 = −bc ± a

r2(a2 + b2) −c2
a2 + b2
(10.58)
From Fig. 10.27, the general form of the line equation is
x −y + 1 = 0 where a = 1, b = −1 and c = 1
Substituting these values in (10.58) yields
x1,2 = −1, 0 and y1,2 = 0, 1
which gives the same intersection points found above.
Finally, using the Hessian normal form of the line ax + by −d = 0 yields
intersections given by
x1,2 = ad ± b

r2 −d2
y1,2 = bd ± a

r2 −d2
(10.59)
From Fig. 10.27, the Hessian normal form of the line equation is
−0.707x + 0.707y −0.707 = 0
where a = −0.707, b = 0.707 and d = 0.707. Substituting these values in
(10.59) yields
x1,2 = −1, 0 and y1,2 = 0, 1
which gives the same intersection points found above. One can readily see the
computational beneﬁts of using the Hessian normal form over the other forms
of equations.
10.6 3D Geometry
3D straight lines are best described using vector notation, and it is a good
idea to develop strong skills in vector techniques if you wish to solve problems
in 3D geometry.
Let’s begin this short survey of 3D analytic geometry by describing the
equation of a straight line.

170
Mathematics for Computer Graphics
10.6.1 Equation of a Straight Line
We start by using a vector b to deﬁne the orientation of the line, and a
point a in space through which the vector passes. This scenario is shown in
Figure 10.28. Given another point P on the line we can deﬁne a vector tb
between a and P, where t is some scalar. The position vector p is given by
p = a + tb
(10.60)
from which we can obtain the coordinates of the point p:
xp = xa + txb
yp = ya + tyb
zp = za + tzb
(10.61)
For example, if b = [1 2 3]T and a = (2, 3, 4), then by setting t = 1 we can
identify a second point on the line:
xp = 2 + 1 = 3
yp = 3 + 2 = 5
zp = 4 + 3 = 7
In fact, by using diﬀerent values of t we can slide up and down the line with
ease.
If we already have two points in space P1 and P2, such as the vertices of
an edge, we can represent the line equation using the above vector technique:
p = p1 + t(p2 −p1)
Y
P
X
Z
b
p = a + t b
a
a
tb
Fig. 10.28. The line equation is based upon the point a and the vector b.

10 Analytic Geometry
171
where p1 and p2 are position vectors to their respective points. Once more,
we can write the coordinates of any point P as follows:
xp = x1 + t(x2 −x1)
yp = y1 + t(y2 −y1)
zp = z1 + t(z2 −z1)
(10.62)
10.6.2 Point of Intersection of Two Straight Lines
Given two straight lines we can test for a point of intersection, but must be
prepared for three results:
•
a real intersection point
•
no intersection point
•
an inﬁnite number of intersections (identical lines).
If the line equations are of the form
p = a1 + rb1
p = a2 + sb2
(10.63)
for an intersection we can write
a1 + rb1 = a2 + sb2
(10.64)
which yields
xa1 + rxb1 = xa2 + sxb2
ya1 + ryb1 = ya2 + syb2
za1 + rzb1 = za2 + szb2
(10.65)
We now have three equations in two unknowns, and any value of r and s must
hold for all three equations. We begin by selecting two equations that are
linearly independent (i.e. one equation is not a scalar multiple of the other)
and solve for r and s, which must then satisfy the third equation. If this
ﬁnal substitution fails, then there is no intersection. If all three equations are
linearly dependent, they describe two parallel lines, which can never intersect.
To check for linear dependency we rearrange (10.65) as follows:
rxb1 −sxb2 = xa2 −xa1
ryb1 −syb2 = ya2 −ya1
rzb1 −szb2 = za2 −za1
(10.66)
If the determinant ∆of any pair of these equations is zero, then they are de-
pendent. For example, the ﬁrst two equations of (10.66) form the determinant

172
Mathematics for Computer Graphics
∆=

xb1
−xb2
yb1
−yb2

(10.67)
which, if zero, implies that the two equations can not yield a solution. As it is
impossible to predict which pair of equations from (10.66) will be independent,
let’s express two independent equations as follows:
ra11 −sa12 = b1
ra21 −sa22 = b2
(10.68)
which yields
r = (a22b1 −a12b2)
∆
(10.69)
s = (a21b1 −a11b2)
∆
(10.70)
where
∆=

a11
a12
a21
a22

(10.71)
Solving for r and s we obtain
r = yb2(xa2 −xa1) −xb2(ya2 −ya1)
xb1yb2 −yb1xb2
(10.72)
s = yb1(xa2 −xa1) −xb1(ya2 −ya1)
xb1yb2 −yb1xb2
(10.73)
As a quick test, consider the intersection of the lines encoded by the following
vectors:
a1 =
⎡
⎣
0
1
0
⎤
⎦b1 =
⎡
⎣
3
3
3
⎤
⎦a2 =
⎡
⎢⎣
0
1
2
0
⎤
⎥⎦b2 =
⎡
⎣
2
3
2
⎤
⎦
Substituting the x and y components in (10.72) and (10.73), we discover
r = 1
3 and s = 1
2
but for these to be consistent, they must satisfy the z component of the
original equation:
rzb1 = szb2 = za2 −za1
1
3 × 3 −1
2 × 2 = 0 −0
which is correct. Therefore, the point of intersection is given by either
pi = a1 + rb1 or
pi = a2 + sb2

10 Analytic Geometry
173
Let’s try both, just to prove the point:
xi = 0 + 1
33 = 1
xi = 0 + 1
22 = 1
yi = 1 + 1
33 = 2
yi = 1
2 + 1
23 = 2
zi = 0 + 1
33 = 1
zi = 0 + 1
22 = 1
Therefore, the point of intersection point is (1, 2, 1).
Now let’s take two lines that don’t intersect, and also exhibit some linear
dependency:
a1 =
⎡
⎣
0
1
0
⎤
⎦
b1 =
⎡
⎣
2
2
0
⎤
⎦
a2 =
⎡
⎣
0
2
0
⎤
⎦
b2 =
⎡
⎣
2
2
1
⎤
⎦
Taking the x and y components we discover that the determinant ∆is zero,
which has identiﬁed the linear dependency. Taking the y and z components
the determinant is non-zero, which permits us to computer r and s using
r = zb2(ya2 −ya1) −yb2(za2 −za1)
yb1zb2 −zb1yb2
(10.74)
s = zb1(ya2 −ya1) −yb1(za2 −za1)
yb1zb2 −zb1yb2
(10.75)
r = 1(2 −1) −2(0 −0)
2 × 1 −0 × 2
= 1
2
s = 0(2 −1) −2(0 −0)
2 × 1 −0 × 2
= 0
2 = 0
But these values of r and s must also apply to the x components:
rxb1 −sxb2 = xa2 −xa1
1
2 × 2 −0 × 2 ̸= 0 −0
which they clearly do not, therefore the lines do not intersect.
Now let’s proceed with the equation of a plane, and then look at how to
compute the intersection of a line with a plane using a similar technique.
10.7 Equation of a Plane
We now consider four ways of representing a plane equation: the Cartesian
form, general form, parametric form and a plane from three points.

174
Mathematics for Computer Graphics
10.7.1 Cartesian Form of the Plane Equation
One popular method of representing a plane equation is the Cartesian form,
which employs a vector normal to the plane’s surface and a point on the plane.
The equation is derived as follows.
Let n be a nonzero vector normal to the plane and P0(x0, y0, z0) a point on
the plane. P(x, y, z) is any other point on the plane. Figure 10.29 illustrates
the scenario.
The normal vector is deﬁned as
n = ai + bj + ck
and the position vectors for P0 and P are p0 = x0i + y0j + z0k and p =
xi + yj + zk respectively. From Figure 10.29 we observe that
q = p −p0
and as n is orthogonal to q
n · q = 0
therefore
n · (p −p0) = 0
which expands into
n · p = n · p0
(10.76)
Writing (10.76) in its Cartesian form we obtain
ax + by + cz = ax0 + by0 + cz0
but ax0 + by0 + cz0 is a scalar quantity associated with the plane and can be
replaced by d.
Therefore
ax + by + cz = d
(10.77)
which is the Cartesian form of the plane equation.
P0
P
p
p0
q
n
X
Y
Z
h a
Fig. 10.29. The vector n is normal to the plane, which also contains a point
P0(x0, y0, z0). P(x, y, z) is any other point on the plane.

10 Analytic Geometry
175
The value of d has the following geometric interpretation.
In Figure 10.29 the perpendicular distance from the origin to the plane is
h = ∥p0∥cos(α)
therefore
n · p0 = ∥n∥∥p0∥cos(α) = h∥n∥
therefore the plane equation can be also expressed as
ax + by + cz = h∥n∥
(10.78)
Dividing (10.78) by ∥n∥we obtain
a
∥n∥x +
b
∥n∥y +
c
∥n∥z = h
where
h = ∥n∥=

a2 + b2 + c2
What this means is that when a unit normal vector is used, h is the perpen-
dicular distance from the origin to the plane.
Let’s investigate this equation with an example.
Figure 10.30 shows a plane represented by the normal vector n = j + k
and a point on the plane P0(0, 1, 0)
Using (10.77) we have
0x + 1y + 1z = 0 × 0 + 1 × 1 + 1 × 0 = 1
therefore, the plane equation is
y + z = 1
If we normalize the equation to create a unit normal vector, we have
y
√
2 + z
√
2 =
1
√
2
where the perpendicular distance from the origin to the plane is
1
√
2.
X
Z
Y
O
n
P0
1
1
Fig. 10.30. A plane represented by the normal vector n and a point P0 (0, 1, 0).

176
Mathematics for Computer Graphics
10.7.2 General Form of the Plane Equation
The general form of the equation of a plane is expressed as
Ax + By + Cz + D = 0
which means that the Cartesian form is translated into the general form by
making
A = a,
B = b,
C = c,
D = −d
10.7.3 Parametric Form of the Plane Equation
Another method of representing a plane is to employ two vectors and a point
that lie on the plane. Figure 10.31 illustrates a scenario where vectors a and
b, and the point T (xT, yT, zT) lie on a plane.
We now identify any other point on the plane P(x, y, z) with its associated
position vector p.
The point T also has its associated position vector t.
Using vector addition we can write
c = λa + εb
where λ and ε are two scalars such that c locates the point P.
We can now write
p = t + c
(10.79)
therefore
xP = xT + λxa + εxb
yP = yT + λya + εyb
zP = zT + λza + εzb
which means that the coordinates of any point on the plane are formed from
the coordinates of the known point on the plane, and a linear mixture of the
components of the two vectors.
Y
X
Z
T
t
b
e b
la
a
c
P
p
Fig. 10.31. The plane is deﬁned by the vectors a and b and the point T (xT, yT, zT).

10 Analytic Geometry
177
1
X
Y
Z
T
P
p
l a
e b
t
Fig. 10.32. The plane is deﬁned by the vectors a and b, and the point T (1, 1, 1).
Let’s illustrate this vector approach with an example.
Figure 10.32 shows a plane containing the vectors a = i and b = k, and
the point T(1, 1, 1) with its position vector t = i + j + k.
By inspection, the plane is parallel to the xz-plane and intersects the y-axis
at y = 1.
From (10.79) we can write
p = t + λa + εb
where λ and ε are arbitrary scalars.
For example, if λ = 2 and ε = 1
xP = 1 + 2 × 1 + 1 × 0 = 3
yP = 1 + 2 × 0 + 1 × 0 = 1
zP = 1 + 2 × 0 + 1 × 1 = 2
Therefore, the point (3, 1, 2) is on the plane.
10.7.4 Converting from the Parametric to the General Form
It is possible to convert from the parametric form to the general form of the
plane equation using the following formulae:
λ = (a · b) (b · t) −(a · t) ∥b∥2
∥a∥2∥b∥2 −(a · b)2
ε = (a · b) (a · t) −(b · t) ∥a∥2
∥a∥2∥b∥2 −(a · b)2
The resulting point P(xP, yP, zP) is perpendicular to the origin.
If vectors a and b are unit vectors, λ and ε become
λ = (a · b) (b · t) −a · t
1 −(a · b)2
(10.80)

178
Mathematics for Computer Graphics
ε = (a · b) (a · t) −b · t
1 −(a · b)2
(10.81)
P’s position vector p is also the plane’s normal vector. Then
xP = xT + λxa + εxb
yP = yT + λya + εyb
zP = zT + λza + εzb
The normal vector is
p = xPi + yPj + zPk
and because ∥p∥is the perpendicular distance from the plane to the origin
we can state
xP
∥p∥x + yP
∥p∥y + zP
∥p∥z = ∥p∥
or in the general form of the plane equation:
Ax + By + Cz + D = 0
where
A = xP
∥p∥
B = yP
∥p∥
C = zP
∥p∥
D = −∥p∥
Figure 10.33 illustrates a plane inclined 45◦to the y- and z-axes and parallel
to the x-axis.
The vectors for the parametric equation are
a = j −k
b = i
t = k
1
X
Z
Y
O
1
t
e b
l a
P
p
Fig. 10.33. The vectors a and b are parallel to the plane and the point (0, 0, 1) is on
the plane.

10 Analytic Geometry
179
substituting these components in (10.80) and (10.81) we have
λ = (0)(0) −(−1) × 1
2 × 1 −(0)
= 1
2
ϵ = (0)(−1) −(0) × 2
2 × 1 −(0)
= 0
therefore
xP = 0 + 1
2 × 0 + 0 × 1 = 0
yP = 0 + 1
2 × 1 + 0 × 0 = 1
2
zP = 1 + 1
2(−1) + 0 × 0 = 1
2
The point

0, 1
2, 1
2

has position vector p, where
∥p∥=

02 + 1
2
2
+ 1
2
2
= 1
2
√
2
the plane equation is
0x +
1
2
1
2
√
2
y +
1
2
1
2
√
2
z −1
2
√
2 = 0
which simpliﬁes to
1
2
√
2y + 1
2
√
2z −1
2
√
2 = 0
or
y + z −1 = 0
10.7.5 Plane Equation from Three Points
Very often in computer graphic problems we require to ﬁnd the plane equation
from three known points. To begin with, the three points must be distinct and
not lie on a line. Figure 10.34 shows three points R, S and T, from which we
create two vectors u = −→
RS and v = −→
RT. The vector product u × v then
provides a vector normal to the plane containing the original points. We now
take another point P (x, y, z) and form a vector w = −→
RP. The scalar product
w·(u×v) = 0 if P is in the plane containing the original points. This condition
can be expressed as a determinant and converted into the general equation of
a plane. The three points are assumed to be in a counter-clockwise sequence
viewed from the direction of the surface normal.

180
Mathematics for Computer Graphics
P
S
R
T
u 3 v
w
v
u
Fig. 10.34. The vectors used to determine a plane equation from three points R, S
and T.
We begin with
u × v =

i
j
k
xu
yu
zu
xv
yv
zv

As w is perpendicular to u × v
w · (u × v) =

xw
yw
zw
xu
yu
zu
xv
yv
zv

= 0
Expanding the determinant we obtain
xw

yu
zu
yv
zv
 + yw

zu
xu
zv
xv
 + zw

xu
yu
xv
yv
 = 0
which becomes
(x −xR)

yS −yR
zS −zR
yT −yR
zT −zR
 + (y −yR)

zS −zR
xS −xR
zT −zR
xT −xR
 + (z −zR)
×

xS −xR
yS −yR
xT −xR
yT −yR
 = 0
This can be arranged in the form ax + by + cz + d = 0
where
a =

yS −yR
zS −zR
yT −yR
zT −zR

b =

zS −zR
xS −xR
zT −zR
xT −xR

c =

xS −xR
yS −yR
xT −xR
yT −yR

d = −(axR + byR + czR)
or
a =

1
yR
zR
1
yS
zS
1
yT
zT

b =

xR
1
zR
xS
1
zS
xT
1
zT

c =

xR
yR
1
xS
yS
1
xT
yT
1

d = −(axR + byR + czR)

10 Analytic Geometry
181
As an example, consider the three points R (0,0,1), S (1,0,0), T (0,1,0). There-
fore
a =

1
0
1
1
0
0
1
1
0

= 1
b =

0
1
1
1
1
0
0
1
0

= 1
c =

0
0
1
1
0
1
0
1
1

= 1
d = −(1 × 0 + 1 × 0 + 1 × 1) = −1
and the plane equation is
x + y + z −1 = 0
10.8 Intersecting Planes
When two non-parallel planes intersect they form a straight line at the in-
tersection, which is parallel to both planes. This line can be represented as a
vector, whose direction is revealed by the vector product of the planes’ sur-
face normals. However, we require a point on this line to establish a unique
vector equation; a useful point is chosen as P0, whose position vector p0 is
perpendicular to the line.
Figure 10.35 shows two planes with normal vectors n1 and n2 intersecting
to create a line represented by n3, whilst P0(x0, yo, z0) is a particular point
on n3 and P(x, y, z) is any point on the line.
We start the analysis by deﬁning the surface normals:
n1 = a1i + b1j + c1k
n2 = a2i + b2j + c2k
next we deﬁne p and p0:
p = xi + yj + zk
p0 = x0i + y0j + z0k
X
Y
Z
P
P0
n1
n2
n3
p
p0
Fig. 10.35. Two intersecting planes create a line of intersection.

182
Mathematics for Computer Graphics
Now we state the plane equations in vector form:
n1 · p + d1 = 0
n2 · p + d2 = 0
The geometric signiﬁcance of the scalars d1 and d2 has already been described
above. Let’s now deﬁne the line of intersection as
p = p0 + λn3
where λ is a scalar.
Because the line of intersection must be orthogonal to n1 and n2
n3 = a3i + b3j + c3k = n1 × n2
Now we introduce P0 as this must satisfy both plane equations, therefore
n1 · p0 = −d1
(10.82)
n2 · p0 = −d2
(10.83)
and as P0 is such that p0 is orthogonal to n3
n3 · p0 = 0
(10.84)
Equations (10.82)–(10.84) form three simultaneous equations, which reveal
the point P0. These can be represented in matrix form as
⎡
⎣
−d1
−d2
0
⎤
⎦=
⎡
⎣
a1
b1
c1
a2
b2
c2
a3
b3
c3
⎤
⎦·
⎡
⎣
x0
y0
z0
⎤
⎦
or
⎡
⎣
d1
d2
0
⎤
⎦= −
⎡
⎣
a1
b1
c1
a2
b2
c2
a3
b3
c3
⎤
⎦·
⎡
⎣
x0
y0
z0
⎤
⎦
therefore
x0

d1
b1
c1
d2
b2
c2
0
b3
c3

=
y0

a1
d1
c1
a2
d2
c2
a3
0
c3

=
z0

a1
b1
d1
a2
b2
d2
a3
b3
0

=
−1
DET
which enables us to state
x0 =
d2

b1
c1
b3
c3
 −d1

b2
c2
b3
c3

DET
y0 =
d2

a3
c3
a1
c1
 −d1

a3
c3
a2
c2

DET
z0 =
d2

a1
b1
a3
b3
 −d1

a2
b2
a3
b3

DET

10 Analytic Geometry
183
where
DET =

a1
b1
c1
a2
b2
c2
a3
b3
c3

The line of intersection is then given by
p = p0 + λn3
If DET = 0 the line and plane are parallel.
To illustrate this, let the two intersecting planes be the xy-plane and the
xz-plane, which means that the line of intersection will be the y-axis, as shown
in Figure 10.36.
The plane equations are z = 0 and x = 0 therefore
n1 = k
n2 = i
and d1 = 0 and d2 = 0
We now compute n3, DET, x0, y0, z0:
n3 =

i
j
k
0
0
1
1
0
0

= j
DET =

0
0
1
1
0
0
0
1
0

= 1
x0 =
0

0
1
1
0
 −0

0
0
1
0

1
= 0
y0 =
0

0
0
0
1
 −0

0
0
1
0

1
= 0
X
Y
Z
n1
n2
P0
n3
P
Fig. 10.36. The two intersecting planes create a line of intersection coincident with
the y-axis.

184
Mathematics for Computer Graphics
z0 =
0

0
0
0
1
 −0

1
0
0
1

1
= 0
Therefore the line equation is p = λn3.
where n3 = j, which is the y-axis.
10.8.1 Intersection of Three Planes
Three mutually intersecting planes will intersect at a point as shown in Fig-
ure 10.37, and we can ﬁnd this point by using a similar strategy to the one
used in two intersecting planes by creating three simultaneous plane equations
using determinants.
Figure 10.37 shows three planes intersecting at the point P (x, y, z).
The three planes can be deﬁned by the following equations:
a1x + b1y + c1z + d1 = 0
a2x + b2y + c2z + d2 = 0
a3x + b3y + c3z + d3 = 0
which means that they can be rewritten as
⎡
⎣
−d1
−d2
−d3
⎤
⎦=
⎡
⎣
a1
b1
c1
a2
b2
c2
a3
b3
c3
⎤
⎦·
⎡
⎣
x
y
z
⎤
⎦
or
⎡
⎣
d1
d2
d3
⎤
⎦= −
⎡
⎣
a1
b1
c1
a2
b2
c2
a3
b3
c3
⎤
⎦·
⎡
⎣
x
y
z
⎤
⎦
or in determinant form:
x

d1
b1
c1
d2
b2
c2
d3
b3
c3

=
y

a1
d1
c1
a2
d2
c2
a3
d3
c3

=
z

a1
b1
d1
a2
b2
d2
a3
b3
d3

=
−1
DET
X
Y
Z
P
Fig. 10.37. Three mutually intersecting planes.

10 Analytic Geometry
185
where
DET =

a1
b1
c1
a2
b2
c2
a3
b3
c3

Therefore we can state that
x = −

d1
b1
c1
d2
b2
c2
d3
b3
c3

DET
y = −

a1
d1
c1
a2
d2
c2
a3
d3
c3

DET
z = −

a1
b1
d1
a2
b2
d2
a3
b3
d3

DET
If DET = 0 two of the planes, at least, are parallel.
Let’s test these equations with a simple example. Figure 10.38 shows three
intersecting planes.
The planes shown in Figure 10.38 have the following equations:
x + y + z −2 = 0
z = 0
y −1 = 0
therefore
DET =

1
1
1
0
0
1
0
1
0

= −1
Z
Y
X
2
2
2
k
i + j + k
j
P
Fig. 10.38. Three planes intersecting at point P.

186
Mathematics for Computer Graphics
and
x = −

−2
1
1
0
0
1
−1
1
0

−1
= 1
y = −

1
−2
1
0
0
1
0
−1
0

−1
= 1
z = −

1
1
−2
0
0
0
0
1
−1

−1
= 0
which means that the intersection point is (1, 1, 0), which is correct.
10.8.2 Angle between Two Planes
Calculating the angle between two planes is relatively easy and can be found
by taking the dot product of the planes’ normals. Figure 10.39 shows two
planes with α representing the angle between the two surface normals n1
and n2.
Let the plane equations be
ax1 + by1 + cz1 + d1 = 0
ax2 + by2 + cz2 + d2 = 0
therefore the surface normals are
n1 = a1i + b1j + c1k
n2 = a2i + b2j + c2k
Taking the dot product of n1 and n2:
n1 · n2 = ∥n1∥∥n2∥cos(α)
X
Y
Z
n1
n2
a
Fig. 10.39. The angle between two planes is the angle between their surface normals.

10 Analytic Geometry
187
Z
Y
X
n2
1
1
1
n1
a
Fig. 10.40. α is the angle between the two planes.
and
α = cos−1
 n1 · n2
∥n1∥∥n2∥

Figure 10.40 shows two planes with normal vectors n1 and n2.
The plane equations are
x + y + z −1 = 0
and
z = 0
therefore
n1 = i + j + k
and
n2 = k
therefore
∥n1∥=
√
3 and ∥n2∥= 1
and
α = cos−1
 1
√
3

= 54.74◦
10.8.3 Angle between a Line and a Plane
The angle between a line and a plane is calculated using a similar technique
used for calculating the angle between two planes. If the line equation employs
a direction vector, the angle is determined by taking the dot product of this
vector and the plane’s normal. Figure 10.41 shows such a scenario where n is
the plane’s surface normal and v is the line’s direction vector.
If the plane equation is
ax + by + cz + d = 0

188
Mathematics for Computer Graphics
Z
Y
X
T
t
v
p
n
P
a
Fig. 10.41. α is the angle between the plane’s surface normal and the line’s direction
vector.
then its surface normal is
n = ai + bj + ck
If the line’s direction vector is v and T (xT, yT, zT) is a point on the line, then
any point on the line is given by the position vector p:
p = t + λv
therefore we can write
n · v = ∥n∥∥v∥cos(α)
and
α = cos−1

n · v
∥n∥∥v∥

When the line is parallel to the plane n · v = 0.
As an example, consider the scenario illustrated in Figure 10.42 where the
plane equation is
x + y + z −1 = 0
therefore the surface normal is given by n:
n = i + j + k
Z
Y
X
a
1
1
1
n
Fig. 10.42. The required angle is between a and b.

10 Analytic Geometry
189
and the line’s direction vector is a:
a = i + j
therefore
∥n∥=
√
3 and
∥a∥=
√
2
and
α = cos−1
 2
√
6

= 35.26◦
10.8.4 Intersection of a Line with a Plane
Given a line and a plane, they will either intersect or are parallel. Either way,
both conditions can be found using some simple vector analysis, as shown in
Figure 10.43.
The objective is to identify a point P that is on the line and the plane.
Let the plane equation be
ax + by + cz + d = 0
where
n = ai + bj + ck
P is a point on the plane with position vector
p = xi + yj + zk
therefore
n · p + d = 0
Let the line equation be
p = t + λv
where
t = xTi + yTj + zTk
Z
Y
X
T
t
v
P
p
n
Fig. 10.43. The vectors required to determine whether a line and plane intersect.

190
Mathematics for Computer Graphics
Z
Y
X
v
P(x, y, z)
T
1
1
1
n
Fig. 10.44. P identiﬁes the point where a line intersects a plane.
and
v = xvi + yvj + zvk
therefore, the line and plane will intersect for some λ such that
n · (t + λv) + d = n · t + λn · v + d = 0
therefore
λ = −(n · t + d)
n · v
for the intersection point. The position vector for P is p = t + λv
If n · v = 0 the line and plane are parallel.
Let’s test this result with the scenario shown in Figure 10.44.
Given the plane
x + y + z −1 = 0
n = i + j + k
and the line
p = t + λv
where
t = 0
and
v = i + j
then
λ = −(1 × 0 + 1 × 0 + 1 × 0 −1)
1 × 1 + 1 × 1 + 1 × 0
= 1
2
therefore, the point of intersection is P
1
2, 1
2, 0

.

10 Analytic Geometry
191
10.9 Summary
Mixing vectors with geometry is a powerful analytical tool, and helps us to
solve many problems associated with computer graphics, such as rendering,
modelling, collision detection and physically based animation. Unfortunately,
there has not been space to investigate every topic, but I hope that what
has been covered here will enable you to solve other problems with greater
conﬁdence

11
Barycentric Coordinates
Cartesian coordinates are a fundamental concept in mathematics and are cen-
tral to computer graphics. Such rectangular coordinates are just oﬀsets rela-
tive to some origin. Other coordinate systems also exist such as polar, spherical
and cylindrical coordinates, and they, too, require an origin. Barycentric co-
ordinates, on the other hand, locate points relative to existing points, rather
than to an origin and are known as local coordinates. The German mathe-
matician August M¨obius (1790–1868) is credited with their discovery.
‘barus’ is the Greek entomological root for ‘heavy’, and barycentric coor-
dinates were originally used for identifying the centre of mass of shapes and
objects. It is interesting to note that the preﬁxes ‘bari’, ‘bary’ and ‘baro’ have
also inﬂuenced other words such as baritone, baryon (heavy atomic particle)
and barometer.
Although barycentric coordinates are used in geometry, computer graphics,
relativity and global time systems, they do not appear to be a major topic in
a typical math syllabus. Nevertheless, they are important and I would like to
describe what they are and how they can be used in computer graphics.
The idea behind barycentric coordinates can be approached from diﬀerent
directions, and I have chosen mass points and linear interpolation. But before
we begin this analysis, it will be useful to investigate a rather elegant theorem
known as Ceva’s Theorem, which we will invoke later in this chapter.
11.1 Ceva’s Theorem
Giovanni Ceva (1647–1734) is credited with a theorem associated with the
concurrency of lines in a triangle. It states that: In triangle ∆ABC, the lines
AA′, BB′ and CC′, where A′, B′ and C′ are points on the opposite sides facing

194
Mathematics for Computer Graphics
vertices A, B and C respectively, are concurrent (intersect at a common point)
if, and only if
AC′
C′B · BA′
A′C · CB′
B′A = 1
Figure 11.1 shows such a scenario.
There are various ways of proving this theorem, (see Advanced Euclidean
Geometry by Alfred Posamentier) and perhaps the simplest proof is as follows.
Figure 11.2 shows triangle ∆ABC with line AA′ extended to R and BB′
extended to S, where line SR is parallel to line AB. The resulting geometry
creates a number of similar triangles:
∆ABA′
:
∆RCA′
⇒
A′C
BA′ = CR
AB
(11.1)
∆ABB′
:
∆CSB′
⇒
B′A
CB′ = AB
SC
(11.2)
A
B
C
A¢
B¢
C¢
P
Fig. 11.1. The geometry associated with Ceva’s Theorem.
A
B
C
A¢
B¢
C¢
P
R
S
Fig. 11.2. The geometry for proving Ceva’s Theorem.

11 Barycentric Coordinates
195
∆BPC′
:
∆CSP
⇒
C′B
SC = C′P
PC
(11.3)
∆AC′P
:
∆RCP
⇒
AC′
CR = C′P
PC
(11.4)
From (11.3) and (11.4) we get
C′B
SC = AC′
CR
which can be rewritten as
C′B
AC′ = SC
CR
(11.5)
The product of (11.1), (11.2) and (11.5) is
A′C
BA′ · B′A
CB′ · C′B
AC′ = CR
AB · AB
SC · SC
CR = 1
(11.6)
Rearranging the terms of (11.6) we get
AC′
C′B · BA′
A′C · CB′
B′A = 1
which is rather an elegant relationship.
11.2 Ratios and Proportion
Central to barycentric coordinates are ratios and proportion, so let’s begin by
revising some fundamental formulae used in calculating ratios.
Imagine the problem of dividing £ 100 between two people in the ratio 2:3.
The solution lies in the fact that the money is divided into 5 parts (2 + 3),
where 2 parts go to one person and 3 parts to the other person. In this case,
one person receives £ 40 and the other £ 60. At a formal level, we can describe
this as follows.
A scalar A can be divided into the ratio r : s using the following expres-
sions:
r
r + sA and
s
r + sA.
Note that
r
r + s +
s
r + s = 1
and
1 −
r
r + s =
s
r + s

196
Mathematics for Computer Graphics
Furthermore, the above formulae can be extended to incorporate any number
of ratio divisions. For example, A can be divided into the ratio r : s : t by the
following:
r
r + s + tA,
s
r + s + tA
and
t
r + s + tA
similarly
r
r + s + t +
s
r + s + t +
t
r + s + t = 1
These expressions are very important as they show the emergence of barycen-
tric coordinates. For the moment, though, just remember their structure and
we will investigate some ideas associated with balancing weights.
11.3 Mass Points
We begin by calculating the centre of mass – the centroid – of two masses.
Consider the scenario shown in Figure 11.3 where two masses mA and mB are
placed at the ends of a massless rod.
If mA = mB a state of equilibrium is achieved by placing the fulcrum mid-
way between the masses. If the fulcrum is moved towards mA, mass mB will
have a turning advantage and the rod rotates clockwise.
To calculate a state of equilibrium for a general system of masses, consider
the geometry illustrated in Figure 11.4, where two masses mA and mB, are
positioned xA and xB at A and B respectively. When the system is in balance
we can replace the two masses by a single mass mA + mB at the centroid
deﬁned by ¯x.
A balance condition arises when the LHS turning moment equals the RHS
turning moment. The turning moment being the product of a mass by its
oﬀset from the fulcrum.
Equating turning moments, equilibrium is reached when
mB(xB −¯x) = mA(¯x −xA)
mA
mB
Fig. 11.3. Two masses ﬁxed at the ends of a massless rod.
A
B
mA
xA
xB−x
xB
mB
(mA + mB)
x
x−xA
Fig. 11.4. The geometry used for equating turning moments.

11 Barycentric Coordinates
197
mBxB −mB¯x = mA¯x −mAxA
(mA + mB)¯x = mAxA + mBxB
¯x = mAxA + mBxB
mA + mB
=
mA
mA + mB
xA +
mB
mA + mB
xB
(11.7)
For example, if mA = 6 and mB = 12, and positioned at xA = 0 and xB = 12
respectively, the centroid is located at
¯x = 6
18 × 0 + 12
18 × 12 = 8
Thus we can replace the two masses by a single mass of 18 located at ¯x = 8.
Note that the terms in (11.7) mA/(mA + mB) and mB/(mA + mB) sum to
1 and are identical to those used above for calculating ratios. They are also
called the barycentric coordinates of ¯x relative to the points A and B.
Using the general form of (11.7) any number of masses can be analysed
using
¯x =
n
i=1
mixi
n
i=1
mi
where mi is a mass located at xi. Furthermore, we can compute the
y-component of the centroid ¯y using
¯y =
n
i=1
miyi
n
i=1
mi
and in 3D the z-component of the centroid ¯z is
¯z =
n
i=1
mizi
n
i=1
mi
To recap, (11.7) states that
¯x =
mA
mA + mB
xA +
mB
mA + mB
xB
therefore, we can write
¯y =
mA
mA + mB
yA +
mB
mA + mB
yB
which allows us to state
¯P =
mA
mA + mB
A +
mB
mA + mB
B

198
Mathematics for Computer Graphics
where A and B are the position vectors for the mass locations A and B
respectively, and ¯P is the position vector for the centroid ¯P.
If we extend the number of masses to three: mA, mB and mC, which are
organized as a triangle, then we can write
¯P =
mA
mA + mB + mC
A +
mB
mA + mB + mC
B +
mC
mA + mB + mC
C
(11.8)
The three multipliers of A, B and C are the barycentric coordinates of ¯P
relative to the points A, B and C. Note that the number of coordinates is not
associated with the number of spatial dimensions, but the number of reference
points.
Now consider the scenario shown in Figure 11.5. If mA = mB = mC then
we can determine the location of A′, B′ and C′ as follows:
1. We begin by placing a fulcrum under A and mid-way along BC as shown
in Figure 11.6.
The triangle will balance because mB = mC and A′ is 1
2a from C and 1
2a
from B.
2. Now we place the fulcrum under B and mid-way along CA as shown in
Figure 11.7.
A
B
C
C′
B′
A ′
P
a
b
c
mC
mB
mA
Fig. 11.5. Three masses organized as a triangle.
A
C
B
c
b
1
2 a
1
2 a
A′
mB
mA
mC
Fig. 11.6. Balancing the triangle along AA′.

11 Barycentric Coordinates
199
C
1
2 a
1
2 b
1
2 b
1
2 a
A′
A
B
c
B′
mB
mA
mC
Fig. 11.7. Balancing the triangle along BB′.
A
B
C
A ′
B′
C′
mA + mB
P
mC
mB
mA
1
2 a
1
2 b
1
2 b
1
2 c
1
2 c
1
2 a
Fig. 11.8. ¯P is the centroid of the triangle.
Once more, the triangle will balance, because mC = mA and B′ will be 1
2b
from C and 1
2b from A.
3. Finally, we do the same for C and the edge AB. Figure 11.8 shows the ﬁnal
scenario.
Ceva’s Theorem conﬁrms that the medians AA′, BB′ and CC′ are con-
current at ¯P, because
AC′
C′B · BA′
A′C · CB′
B′A =
1
2c
1
2c ·
1
2a
1
2a ·
1
2b
1
2b = 1
Arbitrarily, we select the median C′C. At C′ we have an eﬀective mass of
mA + mB and mC at C. For a balance condition
(mA + mB) × C′ ¯P = mC × ¯PC
and as the masses are equal, C′ ¯P must be 1
3 along the median C′C.
And if we use (11.8) we obtain
¯P = 1
3A + 1
3B + 1
3C
which locates the coordinates of the centroid correctly.

200
Mathematics for Computer Graphics
A
B
C
1
2
A′
C′
B′
P
3
1
4 b
2
5 b
3
5 a
3
4 b
2
3 c
1
3 c
Fig. 11.9. How the masses determine the positions of A′, B′ and C′.
Now let’s consider another example where mA = 1, mB = 2 and mC = 3,
as shown in Figure 11.9.
For a balance condition A′ must be 3
5a from B and 2
5a from C. Equally,
B′ must be 1
4b from C and 3
4b from A. Similarly, C′ must be 2
3c from A and
1
3c from B.
Ceva’s Theorem conﬁrms that the lines AA′, BB′ and CC′ are concurrent
at ¯P, because
AC′
C′B · BA′
A′C · CB′
B′A =
2
3c
1
3c ·
3
5a
2
5a ·
1
4b
3
4b = 1
Arbitrarily select C′C. At C′ we have an eﬀective mass of 3 (1 + 2) and 3 at C,
which means that for a balance condition ¯P is mid-way along C′C. Similarly,
¯P is 1
6 along A′A and 1
3 along B′B.
Once more, if we use (11.8) in this scenario we obtain
¯P = 1
6A + 1
3B + 1
2C
Note that the multipliers of A, B and C are identical to the proportions of
¯P along A′A, B′B and C′C. Let’s prove why this is so.
Figure 11.10 shows three masses with the triangle’s sides divided into their
various proportions to derive ¯P.
On the line A′A we have mA at A and eﬀectively mB + mC at A′, which
means that ¯P divides A′A in the ratio
mA
mA+mB+mC :
mB+mC
mA+mB+mC .
On the line B′B we have mB at B and eﬀectively mA + mC at B′, which
means that ¯P divides B′B in the ratio
mB
mA+mB+mC :
mA+mC
mA+mB+mC .
Similarly, on the line C′C we have mC at C and eﬀectively mA + mB at
C′, which means that ¯P divides C′C in the ratio
mC
mA+mB+mC :
mA+mB
mA+mB+mC .

11 Barycentric Coordinates
201
A
B
C
C′
A ′
B′
P
mC
mB
mA
mB
mB + mc
mB + mC
a
mA
mA + mc
mA + mc
a
mc
mB + mca
mc
mA + mcb
mB
mA + mB
mA + mB
c
mA
mA + mBc
Fig. 11.10. How the masses determine the positions of A′, B′ and C′.
To summarize, given three masses mA, mB and mC located at A, B and
C, the centroid ¯P is given by
¯P =
mA
mA + mB + mC
A +
mB
mA + mB + mC
B +
mC
mA + mB + mC
C
(11.9)
If we accept that mA,
mB and mC can have any value, including zero, then
the barycentric coordinates of ¯P will be aﬀected by these values. For example,
if mB = mC = 0 and mA = 1, then ¯P will be located at A with barycentric
coordinates (1, 0, 0). Similarly, if mA = mC = 0 and mB = 1, then ¯P will be
located at B with barycentric coordinates (0, 1, 0). And if mA = mB = 0 and
mC = 1, then ¯P will be located at C with barycentric coordinates (0, 0, 1).
Now let’s examine a 3D example as illustrated in Figure 11.11. The ﬁg-
ure shows three masses 4, 8 and 12 and their equivalent mass 24 located at
(¯x, ¯y, ¯z).
The magnitude and coordinates of three masses are shown in the follow-
ing table, together with the barycentric coordinate ti. The column headed ti
12
4
24
x
y
z
X
Y
Z
8
Fig. 11.11. Three masses can be represented by a single mass located at the system’s
centroid.

202
Mathematics for Computer Graphics
expresses the masses as fractions of the total mass, i.e.
ti =
mi
m1 + m2 + m3
And we see that the centroid is located at (5, 5, 3).
mi
ti
xi
yi
zi
tixi
tiyi
tizi
12
1
2
8
6
2
4
3
1
8
1
3
2
3
3
2
3
1
1
4
1
6
2
6
6
1
3
1
1
¯x = 5
¯y = 5
¯z = 3
Having discovered barycentric coordinates in weight balancing, let’s see
how they emerge in linear interpolation.
11.4 Linear Interpolation
Suppose that we wish to ﬁnd a value mid-way between two scalars A and B.
We could proceed as follows:
V = A + 1
2 (B −A) = A + 1
2B −1
2A = 1
2A + 1
2B
which seems rather obvious. Similarly, to ﬁnd a value one-third between A
and B, we could write
V = A + 1
3 (B −A) = A + 1
3B −1
3A = 2
3A + 1
3B
Generalizing, to ﬁnd some fraction t between A and B we can write
V = A + t (B −A) = A + tB −tA = (1 −t) A + tB
(11.10)
For example, to ﬁnd a value 3
4 between 10 and 18 we have
V =

1 −3
4

× 10 + 3
4 × 18 = 2.5 + 13.5 = 16
Although this is a trivial formula, it is very useful when interpolating between
two numerical values. Let’s explore (11.10) in greater detail.
To begin with, it is worth noting that the multipliers of A and B sum to 1:
(1 −t) + t = 1

11 Barycentric Coordinates
203
Rather than using (1−t) as a multiplier, it is convenient to make a substitution
such as s = 1 −t, and we have
V = sA + tB
where
s = 1 −t
and s + t = 1 (11.10) is called a linear interpolant as it linearly interpolates
between A and B using the parameter t. It is also known as a lerp. The terms
s and t are the barycentric coordinates of V as they determine the value of
V relative to A and B.
Now let’s see what happens when we substitute coordinates for scalars.
We start with 2D coordinates A(xA, yA) and B(xB, yB), and position vectors
A, B and V and the following linear interpolant
V = sA + tB
where
s = 1 −t
and
s + t = 1
then
xV = sxA + txB
yV = syA + tyB
Figure 11.12 illustrates what happens when t varies between 0 and 1.
The point V slides along the line connecting A and B. When t = 0, V is
coincident with A, and when t = 1, V is coincident with B. The reader should
not be surprised that the same technique works in 3D.
A
B
V
yB
yV
yA
xA
xV
xB
X
Y
t = 0
t = 1
Fig. 11.12. The position of V slides between A and B as t varies between 0 and 1.

204
Mathematics for Computer Graphics
A
C
B
yC
yB
yA
xA
xB
xC
X
Y
r = 1
t = 1
V
xV
yV
s = 1
Fig. 11.13. The position of V moves between A, B and C depending on the value r,
s and t.
Now let’s extend the number of vertices to three in the form of a triangle
as shown in Figure 11.13. This time we will use r, s and t to control the
interpolation. We would start as follows:
V = rA + sB + tC
where A, B and C are the position vectors for A, B and C respectively, and
V is the position vector for the point V.
Let
r = 1 −s −t
and
r + s + t = 1
Once more, we begin with 2D coordinates A(xA, yA), B(xB, yB) and C(xC, yC)
where
xV = rxA + sxB + txC
yV = ryA + syB + tyC
When
r = 1, V is coincident with A;
s = 1, V is coincident with B;
t = 1, V is coincident with C.
Similarly, when
r = 0, V is located on the edge BC;
s = 0, V is located on the edge CA;
t = 0, V is located on the edge AB.
For all other values of r, s and t, where r + s + t = 1 and 0 ≤r, s, t ≤1,
V is inside triangle ∆ABC, otherwise it is outside the triangle.

11 Barycentric Coordinates
205
The triple (r, s, t) are barycentric coordinates and locate points relative to
A, B and C, rather than an origin. For example, the barycentric coordinates
of A, B and C are (1, 0, 0), (0, 1, 0) and (0, 0, 1) respectively.
All of the above formulae work equally well in three dimensions, so let’s
investigate how barycentric coordinates can locate points inside a 3D trian-
gle. However, before we start, let’s clarify what we mean by inside a tri-
angle. Fortunately, barycentric coordinates can distinguish points within the
triangle’s three sides; points coincident with the sides; and points outside
the triangle’s boundary. The range and value of the barycentric coordinates
provide the mechanism for detecting these three conditions.
Figure 11.14 illustrates a scenario with the points P1(x1, y1, z1), P2(x2, y2, z2)
and P3(x3, y3, z3). Using barycentric coordinates we can state that any point
P0(x0, y0, z0) inside or on the edge of triangle ∆P1P2P3 is deﬁned by
x0 = rx1 + sx2 + tx3
y0 = ry1 + sy2 + ty3
z0 = rz1 + sz2 + tz3
where r + s + t = 1 and 0 ≤r, s, t ≤1
If the triangle’s vertices are P1(0, 2, 0), P2(0, 0, 4) and P3(3, 1, 2) then we
can choose diﬀerent values of r, s and t to locate P0 inside the triangle.
However, I would also like to conﬁrm that P0 lies on the plane containing the
three points. To do this we require the plane equation for the three points,
which can be derived as follows.
Given P1(x1, y1, z1), P2(x2, y2, z2) and P3(x3, y3, z3), and the target plane
equation ax + by + cz + d = 0
then
a =

1
y1
z1
1
y2
z2
1
y3
z3

X
Y
Z
P4
P2
P3
P0
Fig. 11.14. A 3D triangle.

206
Mathematics for Computer Graphics
b =

x1
1
z1
x2
1
z2
x3
1
z3

c =

x1
y1
1
x2
y2
1
x3
y3
1

and d = −(ax1 + by1 + cz1)
thus
a =

1
2
0
1
0
4
1
1
2

= 0
b =

0
1
0
0
1
4
3
1
2

= 12
c =

0
2
1
0
0
1
3
1
1

= 6
d = −(0 × 0 + 12 × 2 + 6 × 0) = −24
therefore, the plane equation is
12y + 6z = 24
(11.11)
If we substitute a point (x0, y0, z0) in the LHS of (11.11) and obtain a value
of 24, then the point is on the plane.
The following table shows various values of r, s and t, and the correspond-
ing position of P0. The table also conﬁrms that P0 is always on the plane
containing the three points.
r
s
t
x0
y0
z0
12y0 + 6z0
1
0
0
0
2
0
24
0
1
0
0
0
4
24
0
0
1
3
1
2
24
1
4
1
4
1
2
1 1
2
1
2
24
0
1
2
1
2
1 1
2
1
2
3
24
1
2
1
2
0
0
1
2
24
1
3
1
3
1
3
1
1
2
24
Now we are in a position to test whether a point is inside, on the boundary
or outside a 3D triangle.

11 Barycentric Coordinates
207
We begin by writing the three simultaneous equations deﬁning P0 in matrix
form
⎡
⎣
x0
y0
z0
⎤
⎦=
⎡
⎣
x1
x2
x3
y1
y2
y3
z1
z2
z3
⎤
⎦·
⎡
⎣
r
s
t
⎤
⎦
therefore
r

x0
x2
x3
y0
y2
y3
z0
z2
z3

=
s

x1
x0
x3
y1
y0
y3
z1
z0
z3

=
t

x1
x2
x0
y1
y2
y0
z1
z2
z0

=
1

x1
x2
x3
y1
y2
y3
z1
z2
z3

and
r =

x0
x2
x3
y0
y2
y3
z0
z2
z3

DET
s =

x1
x0
x3
y1
y0
y3
z1
z0
z3

DET
t =

x1
x2
x0
y1
y2
y0
z1
z2
z0

DET
where
DET =

x1
x2
x3
y1
y2
y3
z1
z2
z3

Using the three points P1(0, 2, 0), P2(0, 0, 4), P3(3, 1, 2) and arbitrary posi-
tions of P0, the values of r, s and t will identify whether P0 is inside or outside
triangle ∆P1P2P3. For example, the point P0(0, 2, 0) is a vertex and is classi-
ﬁed as being on the boundary. To conﬁrm this we calculate r, s and t, and
show that r + s + t = 1:
DET =

0
0
3
2
0
1
0
4
2

= 24
r =

0
0
3
2
0
1
0
4
2

24
= 1

208
Mathematics for Computer Graphics
s =

0
0
3
2
2
1
0
0
2

24
= 0
t =

0
0
0
2
0
2
0
4
0

24
= 0
therefore r+s+t = 1, but both s and t are zero which conﬁrms that the point
(0, 2, 0) is on the boundary. In fact, as both coordinates are zero it conﬁrms
that the point is located on a vertex.
Now let’s deliberately choose a point outside the triangle. For example,
P0 (4, 0, 3) is outside the triangle, which is conﬁrmed by the corresponding
values of r, s and t:
r =

4
0
3
0
0
1
3
4
2

24
= −2
3
s =

0
4
3
2
0
1
0
3
2

24
= 3
4
t =

0
0
4
2
0
0
0
4
3

24
= 11
3
therefore
r + s + t = −2
3 + 3
4 + 4
3 = 1 5
12
which conﬁrms that the point (4,0,3) is outside the triangle. Note that r < 0
and t > 1, which individually conﬁrm that the point is outside the triangle’s
boundary.
11.5 Convex Hull Property
We have already shown that it is possible to determine whether a point is
inside or outside a triangle. But remember that triangles are always convex. So
can we test whether a point is inside or outside any polygon? Well the answer
is no, unless the polygon is convex. The reason for this can be understood by
considering the concave polygon shown in Figure 11.15.

11 Barycentric Coordinates
209
B
C
D
A
Fig. 11.15. A concave polygon.
If we use barycentric coordinates to deﬁne a point P0 as
P0 = rA + sB + tC + uD
where r + s + t + u = 1.
When t = 0, P0 can exist anywhere inside triangle ∆ABD. Thus, if any
vertex creates a concavity, it will be ignored by barycentric coordinates.
11.6 Areas
Barycentric coordinates are also known as areal coordinates due to their area
dividing properties. For example, in Figure 11.16 the areas of the three internal
triangles are in proportion to the barycentric coordinates of the point P
To prove this, let P have barycentric coordinates
P = rA + sB + tC
where
r + s + t = 1
and
0 ≤r, s, t ≤1
A
P
C
B
t∆ABC
r∆ABC
s∆ABC
Fig. 11.16. The areas of the internal triangles are directly proportional to the barycen-
tric coordinates of P.

210
Mathematics for Computer Graphics
If we use the notation area∆ABC to represent the area of the triangle
formed from the vertices A, B and C then area∆ABC equals the sum of the
areas of the smaller triangles:
area∆ABC = area∆ABP + area∆BCP + area∆CAP
But the area of any triangle ∆P1P2P3 equals
area∆P1P2P3 = 1
2

x1
y1
1
x2
y2
1
x3
y3
1

therefore
area∆ABP = 1
2

xA
yA
1
xB
yB
1
xP
yP
1

but
xP = rxA + sxB + txC
and
yP = ryA + syB + tyC
therefore
area∆ABP = 1
2

xA
yA
1
xB
yB
1
rxA + sxB + txC
ryA + syB + tyC
1

which expands to
area∆ABP = 1
2
 xAyB + rxByA + sxByB + txByC + rxAyA + sxByA + txCyA−
rxAyA −sxAyB −txAyC −xByA −rxAyB −sxByB −txCyB

= 1
2 [xAyB −xByA + r (xByA −xAyB) + s (xByA −xAyB)
+t (xByC −xCyB) + t (xCyA −xAyC)]
= 1
2 [xAyB −xByA + (1 −t) (xByA −xAyB) + t (xByC −xCyB)
+t (xCyA −xAyC)]
= 1
2 [−txByA + txAyB + txByC −txCyB + txCyA −txAyC]
and simpliﬁes to
area∆ABP = 1
2t

xA
yA
1
xB
yB
1
xC
yC
1

= t × area∆ABC

11 Barycentric Coordinates
211
therefore
t = area∆ABP
area∆ABC
similarly
area∆BCP = 1
2r

xA
yA
1
xB
yB
1
xC
yC
1

= r × area∆ABC
r = area∆BCP
area∆ABC
and
area∆CAP = 1
2s

xA
yA
1
xB
yB
1
xC
yC
1

= s × area∆ABC
s = area∆CAP
area∆ABC
thus, we see that the areas of the internal triangles are directly proportional
to the barycentric coordinates of P.
This is quite a useful relationship and can be used to resolve various geo-
metric problems. For example, let’s use it to ﬁnd the radius and centre of the
inscribed circle for a triangle. We could approach this problem using classical
Euclidean geometry, but barycentric coordinates provide a powerful analytical
tool for resolving the problem very quickly.
Consider triangle ∆ABC with sides a, b, and c as shown in Figure 11.17.
The point P is the centre of the inscribed circle with radius R. From our
knowledge of barycentric coordinates we know that
P = rA + sB + tC
A
B
C
P
R
c
b
a
Fig. 11.17. The inscribed circle in triangle ∆ABC.

212
Mathematics for Computer Graphics
where
r + s + t = 1
(11.12)
We also know that the area properties of barycentric coordinates permit us
to state that
area∆BCP = r × area∆ABC = 1
2aR
area∆CAP = s × area∆ABC = 1
2bR
area∆ABP = t × area∆ABC = 1
2cR
therefore
r =
aR
2 × area∆ABC s =
bR
2 × area∆ABC t =
cR
2 × area∆ABC
substituting r, s and t in (11.11) we get
R
2 × area∆ABC (a + b + c) = 1
and
R = 2 × area∆ABC
a + b + c
Substituting R in the deﬁnitions of r, s and t we obtain
r =
a
a + b + c s =
b
a + b + c t =
c
a + b + c
and
xP = rxA + sxB + txC
yP = ryA + syB + tyC
To test this solution, consider the right-angled triangle in Figure 11.18, where
a =
√
200, b = 10, c = 10 and area∆ABC = 50. Therefore
R =
2 × 50
10 + 10 +
√
200 = 2.929
and
r =
√
200
34.1421 = 0.4142 s =
10
34.1421 = 0.2929 t =
10
34.1421 = 0.2929
therefore
xP = 0.4142 × 0 + 0.2929 × 10 + 0.2929 × 0 = 2.929
yP = 0.4142 × 0 + 0.2929 × 0 + 0.2929 × 10 = 2.929

11 Barycentric Coordinates
213
X
Y
10
10
200
r
(xP, yP)
Fig. 11.18. The inscribed circle for a triangle.
A
A¢
B
C¢
B¢
C
D
E
F
1
2
1
1
2
2
Fig. 11.19. Triangle ∆ABC with sides divided in the ratio 1:2.
Therefore, the inscribed circle has a radius of 2.929 and a centre with coordi-
nates (2.929, 2.929).
Let’s explore another example where we determine the barycentric coor-
dinates of a point using virtual mass points.
Figure 11.19 shows triangle ∆ABC where A′, B′ and C′ divide BC, CA
and AB respectively, in the ratio 1:2. The objective is to ﬁnd the barycentric
coordinates of D, E and F, and the area of triangle ∆DEF as a proportion
of triangle ∆ABC.
We can approach the problem using mass points. For example, if we assume
D is the centroid, all we have to do is determine the mass points that create
this situation. Then the barycentric coordinates of D are given by (11.8). We
proceed as follows.
The point D is on the intersection of lines CC′ and AA′. Therefore, we
begin by placing a mass of 1 at C. Then, for line BC to balance at A′ a mass
of 2 must be placed at B. Similarly, for line AB to balance at C′ a mass of 4
must be placed at A. This conﬁguration is shown in Figure 11.20.

214
Mathematics for Computer Graphics
A
A¢
B
C¢
C
D
1
2
1
2
1
2
4
Fig. 11.20. The masses assigned to A, B and C to determine D.
The total mass is 7 (1 + 2 + 4), therefore
D = 4
7A + 2
7B + 1
7C
The point E is on the intersection of lines BB′ and AA′. Therefore, we begin
by placing a mass of 1 at A. Then, for line CA to balance at B′ a mass of 2
must be placed at C. Similarly, for line BC to balance at A′ a mass of 4 must
be placed at B. This conﬁguration is shown in Figure 11.21.
The total mass is still 7, therefore
E = 1
7A + 4
7B + 2
7C
From the symmetry of the triangle we can state that
F = 2
7A + 1
7B + 4
7C
A
A¢
B
B¢
C
E
1
2
1
2
1
2
4
Fig. 11.21. The masses assigned to A, B and C to determine E.

11 Barycentric Coordinates
215
Thus we can locate the points D, E and F using the vector equations
D = 4
7A + 2
7B + 1
7C
E = 1
7A + 4
7B + 2
7C
F = 2
7A + 1
7B + 4
7C
(11.13)
The important feature of these equations is that the barycentric coordinates
of D, E and F are independent of A, B and C; they arise from the ratio used
to divide the triangle’s sides.
Although it was not the original intention, we can quickly explore what
the barycentric coordinates of D, E and F would be if the triangle’s sides had
been 1:3 instead of 1:2. Without repeating all of the above steps, we would
proceed as follows.
The point D is on the intersection of lines CC′ and AA′. Therefore, we
begin by placing a mass of 1 at C. Then, for line BC to balance at A′ a mass
of 3 must be placed at B. Similarly, for line AB to balance at C′ a mass of 9
must be placed at A. This conﬁguration is shown in Figure 11.22.
The total mass is 13 (1 + 3 + 9), therefore
D = 9
13A + 3
13B + 1
13C
E = 1
13A + 9
13B + 3
13C
F = 3
13A + 1
13B + 9
13C
We could even develop the general equations for a ratio 1:n. It is left to the
reader to show that
D =
n2
n2 + n + 1A +
n
n2 + n + 1B +
1
n2 + n + 1C
A
A¢
B
C¢
C
D
1
3
1
3
1
3
9
Fig. 11.22. The masses assigned to A, B and C to determine D.

216
Mathematics for Computer Graphics
E =
1
n2 + n + 1A +
n2
n2 + n + 1B +
n
n2 + n + 1C
F =
n
n2 + n + 1A +
1
n2 + n + 1B +
n2
n2 + n + 1C
As a quick test for the above equations, let n = 1, which should make D, E
and F concurrent at the triangle’s centroid:
D = 1
3A + 1
3B + 1
3C
E = 1
3A + 1
3B + 1
3C
F = 1
3A + 1
3B + 1
3C
which is rather reassuring.
Now let’s return to the ﬁnal part of the problem and determine the area of
triangle ∆DEF in terms of ∆ABC. The strategy is to split triangle ∆ABC
into four triangles: ∆BCF, ∆CAD, ∆ABE and ∆DEF as shown in Figure
11.23.
Therefore
area∆ABC = area∆BCF + area∆CAD + area∆ABE + area∆DEF
and
1 = area∆BCF
area∆ABC + area∆CAD
area∆ABC + area∆ABE
area∆ABC + area∆DEF
area∆ABC
(11.14)
But we have just discovered that the barycentric coordinates are intimately
connected with the ratios of triangles. For example, if F has barycentric co-
A
A′
B
C′
B′
C
D
E
F
1
2
1
1
2
2
Fig. 11.23. Triangle ∆ABC divided into four triangles ∆ABE, ∆BCF, ∆CAD and
∆DEF.

11 Barycentric Coordinates
217
ordinates (rF, sF, tF) relative to the points A, B and C respectively, then
rF = area∆BCF
area∆ABC
And if D has barycentric coordinates (rD, sD, tD) relative to the points A,
B and C respectively, then
sD = area∆CAD
area∆ABC
Similarly, if E has barycentric coordinates (rE, sE, tE) relative to the points
A, B and C respectively, then
tE = area∆ABE
area∆ABC
Substituting rF, sE and tD in (11.13) we obtain
1 = rF + sD + tE + area∆DEF
area∆ABC
From (11.12) we see that
rF = 2
7
sD = 2
7
tE = 2
7
therefore
1 = 6
7 + area∆DEF
area∆ABC
and
area∆DEF = 1
7 × area∆ABC
which is rather neat.
But just before we leave this example, let’s state a general expression for
the area∆DEF for a triangle whose sides are divided in the ratio 1:n. Once
again, I’ll leave it to the reader to prove that
area∆DEF = n2 −2n + 1
n2 + n + 1 × area∆ABC
Note that when n = 1, area∆DEF = 0, which is correct.
[Hint: The corresponding values of rF, sD and tE are n/(n2 + n + 1).]
11.7 Volumes
We have now seen that barycentric coordinates can be used to locate a scalar
within a 1D domain, a point within a 2D area, so it seems logical that the
description should extend to 3D volumes, which is the case.

218
Mathematics for Computer Graphics
P1
P2
P3
P4
X
Y
Z
P
p
v2
v3
Fig. 11.24. A tetrahedron.
To demonstrate this, consider the tetrahedron shown in Figure 11.24. Now
the volume of a tetrahedron is given by
V = 1
6

x1
y1
z1
x2
y2
z2
x3
y3
z3

where [x1 y1 z1]T, [x2 y2 z2]T, and [x3 y3 z3]T are the three vectors extending
from the fourth vertex to the other three vertices. However, if we locate the
fourth vertex at the origin, (x1, y1, z1), (x2, y2, z2) and (x3, y3, z3) become
the coordinates of the three vertices.
Let’s locate a point P(xP, yP, zP) inside the tetrahedron with the follow-
ing barycentric deﬁnition
P = rP1 + sP2 + tP3 + uP4
(11.15)
where P, P1, P2, P3 and P4 are the position vectors for P, P1, P2, P3 and
P4 respectively.
The fourth barycentric term uP4 can be omitted as P4 has coordinates
(0,0,0).
Therefore, we can state that the volume of the tetrahedron formed by the
three vectors p, v2 and v3 is given by
V = 1
6

xP
yP
zP
x2
y2
z2
x3
y3
z3

(11.16)
Substituting (11.14) in (11.15) we obtain
V = 1
6

rx1 + sx2 + tx3
ry1 + sy2 + ty3
rz1 + sz2 + tz3
x2
y2
z2
x3
y3
z3

(11.17)
which expands to

11 Barycentric Coordinates
219
V = 1
6
y2z3(rx1 + sx2 + tx3) + x2y3(rz1 + sz2 + tz3) + x3z2(ry1 + sy2 + ty3)
−y3z2(rx1 + sx2 + tx3) −x3y2(rz1 + sz2 + tz3) −x2z3(ry1 + sy2 + ty3)

= 1
6
⎡
⎢⎣
r(x1y2z3 + x2y3z1 + x3y1z2 −x1y3z2 −x3y2z1 −x2y1z3)+
s(x2y2z3 + x2y3z2 + x3y1z2 −x2y3z2 −x3y1z2 −x2y2z3)+
t(x3y2z3 + x2y3z3 + x3y3z2 −x3y3z2 −x3y2z3 −x2y3z3)
⎤
⎥⎦
and simpliﬁes to
V = 1
6r

x1
y1
z1
x2
y2
z2
x3
y3
z3

This states that the volume of the smaller tetrahedron is r times the volume
of the larger tetrahedron VT, where r is the barycentric coordinate modifying
the vertex not included in the volume. By a similar process we can develop
volumes for the other tetrahedra:
V (P, P2, P4, P3) = rVT
V (P, P1, P3, P4) = sVT
V (P, P1, P2, P4) = tVT
V (P, P1, P2, P3) = uVT
where r + s + t + u = 1.
Similarly, the barycentric coordinates of a point inside the volume sum to
unity.
Let’s test the above statements with an example.
Figure 11.25 shows a tetrahedron and a point P
 1
3, 1
3, 1
3

located within
its interior.
The volume of the tetrahedron VT is
VT = 1
6

0
0
1
1
0
0
0
1
0

= 1
6
P1
P2
P3
P4
X
Y
Z
P
1
1
1
Fig. 11.25. A tetrahedron.

220
Mathematics for Computer Graphics
r = V [P, P2, P4, P3]
VT
= 6
6

2
3
−1
3
−1
3
−1
3
−1
3
−1
3
−1
3
2
3
−1
3

= 1
3
s = V [P, P1, P3, P4]
VT
= 6
6

−1
3
−1
3
2
3
−1
3
2
3
−1
3
−1
3
−1
3
−1
3

= 1
3
t = V [P, P1, P2, P4]
VT
= 6
6

−1
3
−1
3
2
3
2
3
−1
3
−1
3
−1
3
−1
3
−1
3

= 1
3
u = V [P, P1, P2, P3]
VT
= 6
6

−1
3
−1
3
2
3
2
3
−1
3
−1
3
−1
3
2
3
−1
3

= 0
The barycentric coordinates (r, s, t, u) conﬁrm that the point is located at
the centre of triangle ∆P1P2P3.
Note that the above determinants will create a negative volume if the
vector sequences are reversed.
11.8 B´ezier Curves and Patches
In Chapter 9 we examined B´ezier curves and surface patches which are based
on Bernstein polynomials:
Bn
i (t) =

n
i

ti(1 −t)n−i
We discovered that these polynomials create the quadratic terms
(1 −t)2
2t(1 −t)
t2
and the cubic terms
(1 −t)3
3t(1 −t)2
3t2(1 −t)
t3

11 Barycentric Coordinates
221
which are used as scalars to multiply sequences of control points to create
a parametric curve. Furthermore, these terms sum to unity, therefore they
are also another form of barycentric coordinates. The only diﬀerence between
these terms and the others described above is that they are controlled by a
common parameter t. Another property of B´ezier curves and patches is that
they are constrained within the convex hull formed by the control points,
which is also a property of barycentric coordinates.
11.9 Summary
To summarize, barycentric coordinates are regularly used to determine:
1. How a value is divided into various ratios. For example, a scalar A is divided
into the ratios r:s:t using
r
r + s + tA,
s
r + s + tA
and
t
r + s + tA
2. The mid-point between two points A and B:
P = 1
2A + 1
2B
3. The centroid of triangle ∆ABC:
¯P = 1
3A + 1
3B + 1
3C
4. A point on a line through two points A and B:
P = (1 −t)A + tB
5. Whether a point is inside or outside triangle ∆ABC:
P = rA + sB + tC
P is inside or on the boundary of triangle ∆ABC when 0 ≤r, s, t ≤1,
otherwise it is outside.
6. Whether a point is inside a tetrahedron P1, P2, P3, P4:
P = rP1 + sP2 + tP3 + uP4
P is inside tetrahedron P1, P2, P3, P4 when 0 ≤r, s, t, u ≤1, otherwise it is
outside.
7. Centres of gravity:
¯x =
n
i=1
mixi
n
i=1
mi
¯y =
n
i=1
miyi
n
i=1
mi
¯z =
n
i=1
mizi
n
i=1
mi
where mi is a mass located at xi.

12
Worked Examples
This chapter examines a variety of problems encountered in computer graphics
and develops mathematical strategies for their solution. Such strategies may
not be the most eﬃcient, however, they will provide the reader with a starting
point, which may be improved upon.
12.1 Calculate the Area of a Regular Polygon
Given a regular polygon with n sides, side length s, and radius r of the cir-
cumscribed circle, its area can be computed by dividing it into n isosceles
triangles and summing their total area.
Figure 12.1 shows one of the isosceles triangles OAB formed by an edge s
and the centre O of the polygon. From Figure 12.1 we observe that
1
2s
h = tan
π
n

therefore
h = 1
2s cot
π
n

area ∆OAB = 1
2sh = 1
4s2 cot
π
n

but there are n such triangles, therefore
area = 1
4ns2 cot
π
n


224
Mathematics for Computer Graphics
B
A
r
h
O
2
s
n
p
2
s
s
Fig. 12.1. One of the isosceles triangles forming a regular polygon.
If we let s = 1 the following table shows the area for the ﬁrst six polygons.
n
Area
3
0.433
4
1
5
1.72
6
2.598
7
3.634
8
4.828
12.2 Calculate the Area of any Polygon
Figure 12.2 shows a polygon with the following vertices in counter-clockwise
sequence.
x
0
2
5
4
2
y
2
0
1
3
3
By inspection, the area is 9.5.
The area of a polygon is given by
area = 1
2
n−1

i=0

xiyi+1(mod n)−yixi+1(mod n)

area = 1
2(0 × 0 + 2 × 1 + 5 × 3 + 4 × 3 + 2 × 2 −2 × 2 −0 × 5 −1 × 4
−3 × 2 −3 × 0)
area = 1
2(33 −14) = 9.5
12.3 Calculate the Dihedral Angle of a Dodecahedron
The dodecahedron is a member of the ﬁve Platonic solids, which are con-
structed from regular polygons. The dihedral angle is the internal angle
between two faces. Figure 12.3 shows a dodecahedron with one of its pen-
tagonal sides.

12 Worked Examples
225
1
2
3
4
5
1
2
3
4
X
Y
Fig. 12.2. A ﬁve-sided irregular polygon.
108
108
72
Fig. 12.3. A dodecahedron with one of its pentagonal sides.
X
Y
Z
P
P′
v2
v1
g
Fig. 12.4. The dihedral angle γ between two pentagonal sides.
Figure 12.4 illustrates the geometry required to fold two pentagonal sides
through the dihedral angle γ.
The point P has coordinates
P(x, y, z) = (sin(72◦), 0, −cos(72◦))

226
Mathematics for Computer Graphics
and for simplicity, we will use a unit vector to represent an edge, therefore
∥v1∥= ∥v2∥= 1
The coordinates of the rotated point P, P ′ are given by the following transform
⎡
⎣
x′
y′
z′
⎤
⎦=
⎡
⎣
cos(γ)
−sin(γ)
0
sin(γ)
cos(γ)
0
0
0
1
⎤
⎦
⎡
⎣
sin(72◦)
0
−cos(72◦)
⎤
⎦
where
x′ = cos(γ) sin(72◦)
y′ = sin(γ) sin(72◦)
z′ = −cos(72◦)
But
v1.v2 = ∥v1∥∥v2∥cos(θ) = xx′ + yy′ + zz′
therefore
cos(θ) = cos(γ) sin2(72◦) + cos2(72◦)
but θ equals 108◦
(internal angle of a regular pentagon)
therefore
cos(γ) = cos(108◦) −cos2(72◦)
sin2(72◦)
=
cos(72◦)
cos(72◦) −1
The dihedral angle γ = 116.56505◦
A similar technique can be used to calculate the dihedral angles of the
other Platonic objects.
12.4 Vector Normal to a Triangle
Very often in computer graphics we have to calculate a vector normal to a
plane containing three points. The most eﬀective tool to achieve this is the
vector product. For example, given three points P1 (5, 0, 0), P2 (0, 0, 5) and
P3 (10, 0, 5), we can create two vectors a and b as follows:
a =
⎡
⎣
x2 −x1
y2 −y1
z2 −z1
⎤
⎦
b =
⎡
⎣
x3 −x1
y3 −y1
z3 −z1
⎤
⎦
therefore
a = −5i + 5k
b = 5i + 5k

12 Worked Examples
227
The normal vector n is given by
n = a × b =

i
j
k
−5
0
5
5
0
5

= 50j
12.5 Area of a Triangle using Vectors
The vector product is also useful in calculating the area of a triangle using
two of its sides as vectors. For example, using the same points and vectors in
the previous example
area = 1
2|a × b| = 1
2



i
j
k
−5
0
5
5
0
5



= 1
2||50j||
area = 25
12.6 General Form of the Line Equation from Two Points
The general form of the line equation is given by
ax + by + c = 0
and it may be required to compute this equation from two known points. For
example, Figure 12.5 shows two points P1(x1, y1) and P2(x2, y2) from which it
is possible to determine P(x, y).
X
Y
P1
P2
P
x1
x2
x
y1
y2
y
Fig. 12.5. A line formed from two points P1 and P2.

228
Mathematics for Computer Graphics
From Figure 12.5
y −y1
x −x1
= y2 −y1
x2 −x1
(x2 −x1)(y −y1) = (y2 −y1)(x −x1)
(y2 −y1)x −(y2 −y1)x1 = (x2 −x1)y −(x2 −x1)y1
(y2 −y1)x + (x1 −x2)y = x1y2 −x2y1
therefore
a = y2 −y1
b = x1 −x2
c = −(x1y1 −x2y1)
If the two points are P1(1, 0) and P2(3, 4) then
(4 −0)x + (1 −3)y −(1 × 4 −3 × 0) = 0
and
4x −2y −4 = 0
or
2x −y −2 = 0
12.7 Calculate the Angle between Two Straight Lines
Given two line equations it is possible to compute the angle between them
using the scalar product. For example, if the line equations are
a1x + b1y + c1 = 0
a2x + b2y + c2 = 0
their normal vectors are n = a1i + b1j and m = a2i + b2j respectively
therefore
n.m = ∥n∥∥m∥cos(α)
and the angle between the lines α is given by
α = cos−1

n.m
∥n∥∥m∥

Figure 12.6 shows two lines represented by
2x + 2y −4 = 0
and
2x + 4y −4 = 0
Therefore
α = cos−1

2 × 2 + 2 × 4
√
22 + 22√
22 + 42

= 18.435◦

12 Worked Examples
229
a
X
Y
Fig. 12.6. Two lines intersecting at an angle α.
Y
X
P1
P2
P3
Fig. 12.7. Three points on a common line.
12.8 Test If Three Points Lie On a Straight Line
Three points either create a triangle or lie on a straight line as shown in
Figure 12.7. To determine when this occurs we compare two vectors formed
from the points.
For example, given P1(x1, y1), P2(x2, y2), P3(x3, y3) and r = −−→
P1P2 and s = −−→
P1P3
the three points lie on a straight line when s = λr where λ is a scalar.
If the points are
P1 (0, −2) P2 (1, −1) P3 (4, 2)
then
r = i + j and s = 4i + 4j
and
s = 4r
therefore, the points lie on a straight line as conﬁrmed by the diagram.

230
Mathematics for Computer Graphics
Another way is to compute

x1
y1
1
x2
y2
1
x3
y3
1

which is twice the area of ∆P1P2P3. If this equals zero, the points must be
collinear.
12.9 Find the Position and Distance of the Nearest Point
on a Line to a Point
Suppose we have a line and some arbitrary point P, and we require to ﬁnd
the nearest point on the line to P. Vector analysis provides a very elegant way
to solve such problems. Figure 12.8 shows the line and the point P and the
nearest point Q on the line. The nature of the geometry is such that the line
connecting P to Q is perpendicular to the reference line, which is exploited
in the analysis.
The objective is to determine the position vector q.
We start with the line equation
ax + by + c = 0
and declare Q(x, y) as the nearest point on the line to P.
The normal to the line must be
n = ai + bj
and the position vector for Q is
q = xi + yj
therefore
n.q = −c
(12.1)
X
Y
P
Q
p
q
r
n
O
Fig. 12.8. Q is the nearest point on the line to P.

12 Worked Examples
231
r is parallel to n, therefore
r = λn
(12.2)
where λ is some scalar.
Taking the scalar product of (12.2)
n.r = λn.n
(12.3)
but as
r = q −p
(12.4)
n.r = n.q −n.p
(12.5)
substituting (12.1) and (12.3) in (12.5) we obtain
λn.n = −c −n.p
(12.6)
therefore
λ = −(n.p + c)
n.n
From (12.4) we get
q = p + r
(12.7)
substituting (12.2) in (12.7) we obtain the position vector for Q
q = p + λn
The distance PQ must be the magnitude of r :
PQ = ∥r∥= ∥λn∥
Let’s test this result with an example where the answer can be predicted.
Figure 12.9 shows a line whose equation is x+y−1 = 0, and the associated
point P(1,1). By inspection, the nearest point is Q( 1
2,
1
2) and the distance
PQ = 0.7071.
From the line equation
a = 1
b = 1
c = −1
therefore
λ = −2 −1
2
= −1
2
therefore
xQ = xP + λxn = 1 −1
2 × 1 = 1
2
yQ = yP + λyn = 1 −1
2 × 1 = 1
2
The nearest point is Q( 1
2,
1
2) and the distance is PQ = ∥λn∥= 1
2 ∥i + j∥=
0.7071

232
Mathematics for Computer Graphics
X
Y
O
Q
P
n
1
1
Fig. 12.9. Q is the nearest point on the line to P.
12.10 Position of a Point Reﬂected in a Line
Suppose that instead of ﬁnding the nearest point on the line we require the
reﬂection Q of P in the line. Once more, we set out to discover the position
vector for Q.
Figure 12.10 shows the vectors used in the analysis. We start with the line
equation
ax + by + c = 0
and declare T(x, y) as the nearest point on the line to O with t = xi + yj as
its position vector.
From the line equation
n = ai + bj
therefore
n.t = −c
(12.8)
X
Y
O
Q
P
T
r + r′
r
t
q
p
n
r′
Fig. 12.10. The vectors required to ﬁnd the reﬂection of P in the line.

12 Worked Examples
233
We note that r + r′ is orthogonal to n therefore
n.(r + r′) = 0
and
n.r + n.r′ = 0
(12.9)
We also note that p −q is parallel to n therefore
p −q = r −r′ = λn
where λ is some scalar therefore
λ = r −r′
n
(12.10)
From the ﬁgure we note that
r = p −t
(12.11)
substituting (12.8) in (12.11)
n.r = n.p −n.t = n.p + c
(12.12)
substituting (12.9) and (12.12) in (12.10)
λ = n.r −n.r′
n.n
= 2n.r
n.n
λ = 2(n.p + c)
n.n
and the position vector is
q = p −λn
Let’s again test this formula with a scenario that can be predicted in advance.
Given the line equation
x + y −1 = 0
and the point P(1, 1) the reﬂection must be the origin, as shown in Figure 12.11.
Let’s conﬁrm this prediction. From the line equation
a = 1
b = 1
c = −1
and
xP = 1
yP = 1
λ = 2 × (2 −1)
2
= 1
therefore
xQ = xP −λxn = 1 −1 × 1 = 0
yQ = yP −λyn = 1 −1 × 1 = 0
and the reﬂection point is Q(0, 0).

234
Mathematics for Computer Graphics
X
Y
O
Q
P
1
1
Fig. 12.11. Q is the reﬂection of P in the line.
X
Y
Z
T
v
t
c
C
r
q
P
p
s
lv
q
Fig. 12.12. The vectors required to locate a possible intersection.
12.11 Calculate the Intersection of a Line and a Sphere
In ray tracing and ray casting it is necessary to detect whether a ray (line)
intersects objects within a scene. Such objects may be polygonal, constructed
from patches, or deﬁned by equations. In this example, we explore the inter-
section between a line and a sphere.
There are three possible scenarios: the line intersects, touches or misses the
sphere. It just so happens, that the cosine rule proves very useful in setting
up a geometric condition that identiﬁes the above scenarios, which are readily
solved using vector analysis.
Figure 12.12 shows a sphere with radius r located at C. The line is rep-
resented parametrically, which lends itself to this analysis. The objective, of
which, is to discover whether there are points in space that satisfy both the
line equation and the sphere equation. If there is a point, a position vector
will locate it.
The position vector for C is
c = xCi + yCj + zCk
and the equation of the line is
p = t + λv

12 Worked Examples
235
where λ is a scalar, and
∥v∥= 1
(12.13)
For an intersection at P
∥q∥= r or ∥q∥2 = r2 or ∥q∥2 −r2 = 0
Using the cosine rule
∥q∥2 = ∥λv∥2 + ∥s∥2 −2∥λv∥∥s∥cos(θ)
(12.14)
∥q∥2 = λ2∥v∥2 + ∥s∥2 −2∥v∥∥s∥λ cos(θ)
substituting (12.13) in (12.14)
∥q∥2 = λ2 + ∥s∥2 −2∥s∥λ cos(θ)
(12.15)
identify cos(θ)
s.v = ∥s∥∥v∥cos(θ)
therefore
cos(θ) = s.v
∥s∥
(12.16)
substituting (12.16) in (12.15)
∥q∥2 = λ2 −2s.vλ + ∥s∥2
therefore
∥q∥2 −r2 = λ2 −2s.vλ + ∥s∥2 −r2 = 0
(12.17)
(12.17) is a quadratic where
λ = s.v ±

(s.v)2 −∥s∥2 + r2
(12.18)
and
s = c −t
the discriminant of (12.18) determines whether the line intersects, touches or
misses the sphere.
The position vector for P is given by
p = t + λv
where
λ = s.v ±

(s.v)2 −∥s∥2 + r2
and
s = c −t

236
Mathematics for Computer Graphics
For a miss condition
(s.v)2 −∥s∥2 + r2 < 0
For a touch condition
(s.v)2 −∥s∥2 + r2 = 0
For an intersect condition
(s.v)2 −∥s∥2 + r2 > 0
To test these formulae we will create all three scenarios and show that the
equations are well behaved.
Figure 12.13 shows a sphere with three lines represented by their direction
vectors λv1, λv2 and λv3.
The sphere has radius r = 1 and is centred at C with position vector
c = i + j
whilst the three lines L1, L2 and L3 miss, touch and intersect the sphere
respectively.
The lines are of the form
p = t + λv
therefore
p1 = t1 + λv1
p2 = t2 + λv2
p3 = t3 + λv3
where
t1 = 2i
v1 =
1
√
2i + 1
√
2j
t2 = 2i
v2 = j
t3 = 2i
v3 = −1
√
2i + 1
√
2j
L1
L2
L3
X
Y
Z
lv2
lv1
lv3
P3¢
P3
P2
C
r
T
t
c
Fig. 12.13. Three lines that miss, touch and intersect the sphere.

12 Worked Examples
237
and
c = i + j
Let’s substitute the lines in the original equations:
L1 : s = −i + j
(s.v)2 −∥s∥2 + r2 = 0 −2 + 1 = −1
the negative discriminant conﬁrms a miss condition.
L2 : s = −i + j
(s.v)2 −∥s∥2 + r2 = 1 −2 + 1 = 0
the zero discriminant conﬁrms a touch condition, therefore λ = 1 the touch
point is P2(2, 1, 0) which is correct.
L3 : s = −i + j
(s.v)2 −∥s∥2 + r2 = 2 −2 + 1 = 1
the positive discriminant conﬁrms an intersect condition, therefore
λ =
2
√
2 ± 1 = 1 +
√
2
or
√
2 −1
The intersection points are given by the two values of λ:
if λ = 1 +
√
2
xP = 2 +

1 +
√
2
 
−1
√
2

= 1 −1
√
2
yP = 0 +

1 +
√
2
 1
√
2 = 1 + 1
√
2
zP = 0
if λ =
√
2 −1
xP = 1 +
√
2 −1
 
−1
√
2

= 1 + 1
√
2
yP = 0 +
√
2 −1
 1
√
2 = 1 −1
√
2
zP = 0
The intersection points are P3′

1 −
1
√
2, 1 +
1
√
2, 0

and P3

1 +
1
√
2, 1 −
1
√
2, 0

which are correct.

238
Mathematics for Computer Graphics
12.12 Calculate if a Sphere Touches a Plane
A sphere will touch a plane if the perpendicular distance from its centre to the
plane equals its radius. The geometry describing this condition is identical to
ﬁnding the position and distance of the nearest point on a plane to a point.
Figure 12.14 shows a sphere located at P with position vector p. A pote-
ntial touch condition occurs at Q, and the objective of the analysis is to
discover its position vector q. Given the following plane equation
ax + by + cz + d = 0
its surface normal is
n = ai + bj + ck
The nearest point Q on the plane to a point P is given by the position vector
q = p + λn
(12.19)
where
λ = −n.p + d
n
.n
the distance
PQ = ∥λn∥
If P is the centre of the sphere with radius r, and position vector p the touch
point is also given by (12.19)
when
PQ = ∥λn∥= r
Let’s test the above equations with a simple example, as shown in Figure 12.15.
Figure 12.15 shows a sphere with radius r = 1 and centred at P(1, 1, 1)
The plane equation is
y −2 = 0
X
Y
Z
P
Q
p
q
n
r
Fig. 12.14. The vectors used to detect when a sphere touches a plane.

12 Worked Examples
239
X
Y
Z
P
Q
n
r
Fig. 12.15. A sphere touching a plane.
therefore
n = j
and
p = i + j + k
therefore
λ = −(1 −2) = 1
which equals the sphere’s radius and therefore the sphere and plane touch.
The touch point is
xQ = 1 + 1 × 0 = 1
yQ = 1 + 1 × 1 = 2
zQ = 1 + 1 × 0 = 1
P(1,2,1) which is correct.
12.13 Summary
Unfortunately, problem solving is not always obvious, and it is possible to
waste hours of analysis simply because the objective of the solution has not
been well formulated. Hopefully, though, the reader has discovered some of
the strategies used in solving the above geometric problems, and will be able
to implement them in other scenarios. At the end of the day, practice makes
perfect.

13
Conclusion
In the previous 12 chapters I have attempted to introduce you to some of the
important elements of mathematics employed in computer graphics. I knew
from the start that this would be a challenge for two reasons: one was knowing
where to start, and the other was knowing where to stop. I assumed that most
readers would already be interested in computer animation, games, virtual
reality, and so on, and knew something about mathematics. So perhaps the
chapters on numbers, algebra and trigonometry provided a common starting
point.
The chapters on Cartesian coordinates, vectors, transforms, interpolation,
curves and patches are the real core of the book, but while revealing these
subjects I was always wondering when to stop. On the one hand, I could have
frustrated readers by stopping short of describing a subject completely, and
on the other hand lost readers by pursuing a subject to a level beyond the
book’s objective. Hopefully, I have managed to keep the right balance.
For many readers, what I have covered will be suﬃcient to enable them to
design programs and solve a wide range of problems. For others, the book will
provide a useful stepping stone to more advanced texts on mathematics. But
what I really hope that I have managed to show is that mathematics is not
that diﬃcult, especially when it can be applied to an exciting subject such as
computer graphics.

References
Boyer, C.B. and Merzbach, U.C. (1989) A History of Mathematics. Wiley,
New York.
Foley et al. (1990) Computer Graphics: Principles and Practice.
Glassner et al. (1990) Gems.
Gullberg, J. (1997) Mathematics: From the Birth of Numbers. W. W. Norton,
New York.
Harris, J.W. and Stocker, H. (1998) Handbook of Mathematics and Compu-
tational Science. Springer-Verlag, New York.

Index
addition
quaternions, 91
vectors, 36
algebra, 11
algebraic laws, 12
matrices, 53
vectors, 31
analytic geometry, 149
angle/angles, 150
adjacent, 148
between a line and a plane, 189
between lines, 228
between planes, 188
between vectors, 40
complementary, 148
compound, 20
Euler, 79
exterior, 149
interior, 149
opposite, 148
pitch, 69
roll, 69
rotation, 69
supplementary, 148
yaw, 69
area/areas, 26, 48, 209
annulus, 155
circle, 154
ellipse, 156
irregular polygon, 223
area/areas (continued)
polygon, 223
sector, 156
segment, 157
triangle, 166, 209
associative law
algebra, 12
back-face detection, 43
barycentric coordinates, 193
basis functions, 138
Bernstein polynomials, 125
cubic, 130
B´ezier curve, 125, 220
matrices, 133
patch, 141
quadratic, 129
recursive, 133
B´ezier patch, 142, 220
cubic, 144
quadratic, 142
B-splines, 137
continuity, 139
non-uniform, 140
non-uniform rational, 141
uniform, 137
Cartesian coordinates, 23
Cartesian vector, 38
centroid, 193

246
Index
Ceva’s theorem, 193
circle/circles, 123, 156
area, 154
area of sector, 156
area of segment, 157
circumference, 154
equation, 123
column vector, 32
commutative law
algebra, 13
complex numbers, 7
compound-angle identities, 20
continuity, 139
control vertex, 129
convex hull, 208
coordinate system/systems, 23
barycentric, 193
Cartesian, 23
homogeneous, 57
cosecant, 18
cosine/cosines, 18
rule, 20
cotangent, 18
cross product, vectors, 44
cubic
B´ezier curve, 130
B´ezier patch, 144
curve/curves, 123
B´ezier, 125, 220
determinant, 45, 56, 99
area properties, 102
dihedral angle, 224
direction cosines, 75
distributive law
algebra, 13
dodecahedron, 224
dihedral angle, 224
dot product, 41
ellipse, 124
equation, 124
parametric equation, 124
equation/equations
circle, 123
ellipse, 124
intersecting lines, 163, 173
plane, 175
quadratic, 14
equation/equations (continued)
second-degree, 132
straight line, 158, 172
third-degree, 132
equilateral triangle, 153
Euler angles, 67, 79
Euler’s rule, 29
Fibonnaci numbers, 1
function graphs, 24
gimbal lock, 70
golden section, 151
Hessian normal form, 160, 162
indices
laws of, 15
examples, 15
identity/identities
Pythagorean, 19
trigonometric, 20
intercept theorems, 150
integers, 6
interpolation, 107
cubic, 111
linear, 107, 134, 202
non-linear, 110
quaternions, 119
trigonometric, 110
vectors, 116
intersecting
line and a circle, 170
line and a plane, 191
line and a sphere, 234
lines, 163, 173
line segments, 163
planes, 183
intersection points, 163, 173
inverse trigonometric ratios, 19
irrational numbers, 6
isosceles triangle, 152
Lambert’s law, 42
lighting calculations, 42
line/lines
angle between, 228
intersecting a sphere, 234

Index
247
line/lines (continued)
three points, 229
two points, 227
linear interpolation, 134, 202
logarithms, 15
natural, 16
magnitude, vectors, 34
mass points, 196
matrix/matrices, 53
determinant, 56
identity in R2, 63
identity in R3, 90
orthogonal, 80
square, 100
median/medians, 150
natural logarithms, 16
natural numbers, 5
numbers, 5
complex, 7
even, 1
Fibonacci, 1
imaginary, 7
integer, 6
irrational, 6
natural, 5
odd, 1
prime, 6
rational, 6
real, 7
normal vector, 47, 226
NURBS, 141
parallelogram, 155
Pascal’s triangle, 125
perimeter relationships, 21
perspective projection, 103
pitch, 69
planar, 28
patch, 141
plane equations, 175
Cartesian, 176
from three points, 181
general form, 178
parametric form, 178
plane/planes, 175
angle between, 188
intersecting, 183
touching a sphere, 238
point/points
reﬂected in a line, 232
point on a line
nearest to a point, 230
point inside a triangle, 166
polygon/polygons, 156
area using angles, 223
area using Cartesian coordinates, 223
regular, 156
position vector, 37
prime numbers, 1, 6
product/products
scalar, 40, 41
vector, 44
Pythagorean
theorem, 27, 28
quadratic B´ezier curve, 129
quadratic B´ezier patch, 142
quadratic equation, 14
quadrilateral, 154
quaternions, 90
addition, 91
deﬁnition, 90
Hamilton’s rules, 91
interpolation, 119
inverse, 91
magnitude, 92
matrix, 96
multiplication, 91
pitch, 95
roll, 95
rotating a vector, 83
subtraction, 91
yaw, 95
radian, 17
rational numbers, 6
ratios and proportion , 195
real numbers, 7
regular
polygon/polygons, 156
right-hand rule, 47
rhomboid, see parallelogram
rhombus/rhombi, 155
roll, 69
scalar product, 40, 41
secant, 18

248
Index
sector
circle, 156
circle, area, 156
segment
circle, 157
circle, area, 157
sine, 18
rule, 20
space
camera, 77
image, 77
object, 77
partitioning, 161
world, 77
sphere touching a plane, 238
straight lines
angle between, 228
equation, 158, 172
from three points, 229
Hessian normal form, 160, 162
subtraction, vectors, 36
surface patch, 141
planar, 141
quadratic, 142
Thales, 154
theorem/theorems
Ceva, 193
intercept, 150
Pythagorean, 27, 28, 154
Thales, 154
transformations, 51, 66
aﬃne, 64
change of axes in R2
homogeneous, 57
reﬂection in R2, 52, 59, 65
reﬂection in R3, 73
rotation in R2, 62
rotation in R3, 67
rotation, axes in R2, 76
scaling in R2, 51, 58, 64
scaling in R3, 66
transformations (continued)
shearing in R2, 61
translation in R2, 51, 58
translation in R3, 66
trapezoid, 155
triangle/triangles, 151
area, 164, 166, 227
area, determinant, 164
centroid, 152
equilateral, 153
isosceles, 152
right-angled, 153
vector normal, 226
trigonometric
ratios, 18
inverse ratios, 19
relationships, 19
trigonometry, 17
unit vector, 37
vector/vectors, 31
addition, 36
Cartesian, 38
column, 32
dot product, 40
interpolation, 116
magnitude, 34
multiplication, 39
normal, 47
notation, 32
position, 37
product, 44
scalar product, 40
scaling, 36
subtraction, 36
tangent, 115
unit, 37
volume, 217
tetrahedron, 217
yaw, 69

