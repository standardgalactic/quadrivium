COBOL
From Micro to Mainframe
RT:elEntT T. [3Ft.AUEnl
AR{f L VnzcpuEz 
VtLL,A,Fl
ATTTHUR R. EIUgs
THIRD EDITIOil

ISBN O-I3_?1DBI7-A
lffifiilflillilililllililtlflll

The following software and supplements are available from Prentice Hall: 
• SOFTWARE—Micro Focus Personal COBOL for Windows 3.1 with object-
orientation and Personal Dialog System. Compatible with Windows95 and 
WindowsNT, Personal COBOL provides all the tools to help y o u learn and 
use COBOL. The software includes an integrated editor, compiler and 
animator for creating, debugging and executing COBOL programs. Prentice 
Hall offers an affordable package of COBOL: From Micro to Mainframe, Third 
Edition with the Micro Focus Personal COBOL Compiler. Please order ISBN 
0-13-975178-5. 
e WEB SITE—Download every COBOL program in the text as well as data files 
for the nearly o n hundred student projects from the COBOL: From Micro to 
Mainframe web site at: 
http://www.prenhall.com/grauer_cobol. 
• Instructor's Resource Manual (ISBN# 0-13-081513-6) 
• Prentice Hall Custom Test. Based o n the powerful testing technology 
developed b y Engineering Software Associates, Inc. (EAS), Prentice Hall 
Custom Test allows the educator to create and tailor the exam to their o w n 
needs. Please order ISBN* 0-13-081515-2 
We are especially grateful to our editors at Prentice Hall, Laura Steele, Alan Apt, and 
Marcia Horton, without w h o m this project would not have b e e n possible. We also 
w a n t to thank the m a n y other individuals w h o helped produce the third edition. 
Irwin Zucker, w h o supervised the production, Kate Kaibni, editorial assistant, w h o 
worked hard to provide us with timely chapter reviews, and Joel Berman, our 
marketing manager at Prentice Hall, w h o developed the innovative campaign to 
make this book a success. 
We also want to acknowledge our reviewers, w h o through their c o m m e n t s and 
constructive criticism, m a d e this a far better book: 
Robert V. Binder, Robert Binder Systems Consulting, Inc. 
D i n o n Boyer, University of Akron 
Georgia Brown, Northern Illinois University 
Jan De Lassen, Brigham Young University 
Ida M. Flynn, University of Pittsburgh 
Frank T. Gergelyi, NJIT 
Ken Goldsmith, University of Miami 
T o m Gorecki, St. Charles C o m m u n i t y College 
Carol C. Grimm, Palm Beach C o m m u n i t y College 
Monica Holmes, Central Michigan University 
Ann W. Houck, Pima C o m m u n i t y College 
David Lee 
James W. Payne, Kellogg C o m m u n i t y College 
Nicholas Ross, University of Illinois at Chicago 
Wendell I. Pope, Utah State University 
Daniel H. Rindfleisch, Computer Specialist with Federal Government 
Daniel R. Rota, Robert Morris College 
Richard H. Saracusa, Northeastern University 
Ron Teemley, DeVry Institute of Technology 
Donat Valcourt, Northeastern University 
Ron Williams, M c L e n n o n C o m m u n i t y College 
Jackie Zucker, University of Miami 

A final word of thanks to you, our readers, for choosing this book. Please feel 
free to contact us with any c o m m e n t s or suggestions via email. 
Robert Grauer 
rgrauer@umiami .miarni. e d u 
Carol Vazquez Villar 
Arthur R. Buss 
bussa@william.jewell.edu 

rreiace 
Mi 
Introduction 
Overview 
2 
The First Problem 
2 
Programming Specifications 3 
Required Logic 
5 
Flowcharts 6 
Pseudocode 8 
A First Look at COBOL 
9 
Identification Division 11 
Environment Division 11 
Data Division 11 
Procedure Division 12 
Test Data 
13 
Elements of COBOL 
13 
Reserved Words 13 
Programmer-Supplied Names 14 
Literals 15 
Symbols 16 
Level Numbers 16 
Picture Clauses 17 
A Second Look at COBOL 
17 
Summary 
19 
Fill-in 20 
True/False 20 
Problems 21 
From Coding Form to Computer 
Errors in Compilation 
Overview 
26 
From Coding Form to Computer 
26 
The COBOL Coding Form 28 
Use of an Editor 28 
The Compile, Link, and Execute Sequence 
Learning by Doing 
32 
Errors in Entering the Program 33 
Errors in Operating System Commands 33 
30 
33 
Errors in Execution 35 
Errors in Data Input 37 
Evolution of COBOL 
38 
There's Always a Reason 
Summary 
41 
Fill-in 41 
True/False 42 
40 
Problems 43 
A Methodology for 
Overview 
48 
The Tuition Billing Problem 
48 
Structured Design 
50 
Evaluating the Hierarchy Chart 
52 
Completeness 53 
Functionality 54 
Span of Control 54 
Structured Programming 
54 
Program Development 
Sufficiency of the Basic Structures 56 
Expressing Logic 
57 
The Traditional Flowchart 57 
Pseudocode 57 
Warnier-Orr Diagrams 59 
Top-Down Testing 
61 
Summary 
66 
Fill-in 67 
True/False 68 
Problems 68 

Contents 
C h a p t e r 4 : T h e I d e n t i f i c a t i o n , 
Overview 
74 
COBOL Notation 
74 
Identification Division 
75 
Environment Division 
76 
CONFIGURATION SECTION 76 
INPUT-OUTPUT SECTION 76 
Data Division 
77 
FILE SECTION 77 
Environment, and Data Divisions 7 3 
WORKING-STORAGE SECTION 82 
The Tuition Billing Program 
84 
Programming Specifications 84 
COBOL Entries 87 
Limitations of COBOL-74 
90 
Summary 
90 
Fill-in 92 
True/False 92 
Problems 93 
5: T h e Procedure Division 
9 7 
Overview 
98 
OPEN 
98 
CLOSE 
99 
READ 
99 
Placement of the READ Statement 100 
WRITE 
100 
STOP RUN 
102 
MOVE 
102 
Restrictions on the Move Statement 103 
Alphanumeric Field to Alphanumeric Field 103 
Numeric Field to Numeric Field 104 
Group Moves 105 
PERFORM 
105 
IF 
106 
The ELSE Clause 106 
Indentation 106 
EVALUATE 
109 
Arithmetic Statements 
109 
The ROUNDED Clause 109 
The SIZE ERROR Clause 110 
COMPUTE 
110 
ADD 
112 
SUBTRACT 112 
MULTIPLY 
114 
DIVIDE 115 
Programming Tip: Use the COMPUTE 
Statement 116 
Assumed Decimal Point 117 
The Tuition Billing Program 
118 
Test Data 126 
Hierarchy Chart 127 
COBOL Program Skeleton 
128 
Limitations of COBOL-74 
128 
Summary 
130 
Fill-in 131 
True/False 132 
Problems 133 
Chapter 6: D e b u g g i n g 
Overview 
140 
Errors in Compilation 
140 
Common Compilation Errors 149 
Errors in Execution 
151 
File Status Codes 156 
Another Run Time Error 158 
Logic Errors 159 
1 3 9 
Tips for Debugging 
160 
DISPLAY Statement 161 
The Structured Walkthrough 
Summary 
163 
Fill-in 164 
True/False 165 
162 
Problems 165 

Contents 
Chapter 7: Editing and Coding 
Overview 
170 
Editing 
170 
The Decimal Point 172 
Zero Suppression 172 
Dollar Signs 174 
Comma 174 
Asterisks for Check Protection 175 
Insertion Characters 175 
Synopsis 175 
Signed Numbers 
176 
CRandDB 176 
Plus and Minus Signs 177 
Standards 
169 
BLANK WHEN ZERO Clause 
177 
The Tuition Billing Program Revisited 
178 
Coding Standards 
179 
Data Division 179 
Programming Tip; Avoid Literals 180 
Procedure Division 181 
Programming Tip: Use Scope Terminators 182 
Both Divisions 183 
A Well-Written Program 
184 
Summary 
189 
Fill-in 190 
True/False 191 
Problems 191 
C h a p t e r Us Data Validation 
Overview 
196 
System Concepts: Data Validation 
196 
The IF Statement 
197 
Relational Condition 198 
Class Test 199 
Sign Test 200 
Condition-Name Test (88-Level Entries) 200 
Compound Test 200 
Hierarchy of Operations 201 
Implied Conditions 203 
Nested IFs 203 
NEXT SENTENCE 205 
195 
ACCEPT Statement 
206 
Calculations Involving Dates 206 
The Stand-Alone Edit Program 
207 
Programming Specifications 208 
Error Messages 211 
Pseudocode 211 
Hierarchy Chart 212 
The Completed Program 212 
Limitations of COBOL-74 
221 
Summary 
223 
Fill-in 224 
True/False 224 
Problems 225 
Cna^ici- 
S * More About the 
Overview 
230 
PERFORM 
231 
TEST BEFORE/TEST AFTER 231 
In-line Perform 232 
Performing Sections 232 
PERFORM THRU 232 
Programming Tip: Perform Paragraphs, Not 
Sections 233 
READ 
234 
False-Condition Branch 234 
READ INTO 235 
WRITE FROM 
236 
INITIALIZE 
236 
String Processing 
237 
INSPECT 237 
edure Division 
229 
STRING 238 
UNSTRING 
240 
Reference Modification 240 
ACCEPT 
242 
Duplicate Data Names 243 
Qualification 244 
MOVE CORRESPONDING 
245 
The Car Billing Program 
246 
Programming Specifications 246 
Program Design 248 
The Completed Program 249 
Limitations of COBOL-74 
258 
Summary 
258 
Fill-in 259 
True/False 260 
Problems 260 

Contents 
w. . 
-i C: Screen l-O 
Overview 
266 
ACCEPT 
266 
Programming Tip: Micro Focus Level 78—The Use 
of COBOL Constants 267 
DISPLAY 
269 
The Tuition Billing Program Revisited 
270 
Programming Specifications 270 
Hierarchy Chart 271 
Pseudocode 271 
The Completed Program 273 
Programming Tip: The Hidden Power of 
the Alt key 274 
265 
Car Validation and Billing Program 
278 
Programming Specifications 279 
The Screen Section 280 
Hierarchy Chart 284 
Pseudocode 284 
The Completed Program 287 
Limitations of COBOL-74 
297 
Summary 
297 
Fill-in 298 
True/False 299 
Problems 299 
... 
i"«» Introduction to Tai 
w v e i v l 6 w 
o u d 
introduction to Tables 
302 
OCCURS Clause 303 
Processing a Table 304 
PERFORM VARYING 
304 
A Second Example 
306 
Problems with the OCCURS Clause 308 
Rules for Subscripts 308 
Relative Subscripting 308 
USAGE Clause 309 
s 
301 
OCCURS DEPENDING ON 310 
The Student Transcript Program 
311 
Programming Specifications 311 
Program Design 313 
The Completed Program 314 
Indexes versus Subscripts 
321 
The SET Statement 322 
Limitations of COBOL-74 
322 
Summary 
325 
Fill-in 326 
True/False 326 
Problems 327 
. 
, 
u Table Lookups 
Overview 
332 
System Concepts 
332 
Types of Codes 333 
Characteristics of Codes 333 
Sequential Table Lookup 334 
Binary Table Lookup 335 
Positional Organization and Direct Lookups 336 
Initializing a Table 
336 
Hard Coding 336 
Input-Loaded Tables 338 
Table Lookups 
339 
PERFORM VARYING Statement 340 
SEARCH Statement 340 
331 
Programming Tip—Restrict Subscripts 
and Switches to a Single Use 
342 
SEARCH ALL Statement 344 
Direct Lookup 344 
Range-Step Tables 345 
A Complete Example 
347 
Programming Specifications 347 
Program Design 349 
The Completed Program 350 
Limitations of COBOL-74 
357 
Summary 
357 
Fill-in 358 
True/False 359 
Problems 360 

Contents 
c:; 
z\n i. \ 
Multilevel Tables 
Overview 
364 
System Concepts 
364 
COBOL Implementation 
366 
One-Level Tables 
366 
PERFORM VARYING 366 
Two-Level Tables 
368 
Errors in Compilation 369 
PERFORM VARYING 370 
A Sample Program 
373 
Programming Specifications 373 
Program Design 375 
The Completed Program 375 
Three-Level Tables 
380 
3 6 3 
PERFORM VARYING 382 
A Sample Program 
384 
Programming Specifications 384 
The Completed Program 386 
Table Lookups 
390 
A Calorie Counter's Delight 
392 
Programming Specifications 392 
Range-Step Tables 392 
The Completed Program 394 
Limitations of COBOL-74 
398 
Summary 
398 
Fill-in 399 
True/False 399 
Problems 400 
.',[ 
k-,. 
: S o r t i n g 
Overview 
404 
System Concepts 
405 
Collating Sequence 
405 
Embedded Sign 406 
COBOL Implementation 
408 
SORT Statement 409 
SD (Sort Description) 410 
RELEASE and RETURN 410 
Programming Specifications 411 
4 0 3 
USING/GIVING Option 
414 
INPUT PROCEDURE/OUTPUT PROCEDURE 
Option 
419 
Comparing Options 
426 
MERGE Statement 
426 
Limitations of COBOL-74 
428 
Summary 
428 
Fill-in 429 
True/False 430 
Problems 431 
KV\ . s.y\:c,i- 
i kic Control Breaks 
Overview 
436 
System Concepts 
436 
Running versus Rolling Totals 440 
One-Level Control Breaks 
443 
Programming Specifications 443 
Hierarchy Chart 444 
Pseudocode 446 
The Completed Program 446 
Two-Level Control Breaks 
451 
Hierarchy Chart 451 
Pseudocode 452 
40 C 
The Completed Program 454 
Three-Level Control Breaks 
460 
Hierarchy Chart 460 
Pseudocode 462 
The Completed Program 463 
Programming Tip: How to Write a Control Break 
Program 470 
Limitations of COBOL-74 
471 
Summary 
471 
Fill-in 472 
True/False 472 
Problems 473 

Contents 
<.- j 
' v.. Subprograms 
Overview 
476 
Subprograms 
477 
Called and Calling Programs 477 
COPY Statement 479 
Calling BY CONTENT and BY REFERENCE 480 
Programming Tip: Use COPY to Pass 
Parameters 481 
INITIAL Clause 
482 
A System for Physical Fitness 
482 
Programming Specifications 482 
Hierarchy Chart 485 
Pseudocode 485 
475 
The Completed Programs 
486 
Main Program (FITNESS) 486 
Input Program (INPUTSUB) 
490 
Weight-Range Program (WGTSUB) 495 
Training Program (TRAINSUB) 
498 
Display Program (DSPLYSUB) 498 
Time Program (TIMESUB) 
503 
The Linkage Editor 
504 
Problems with the Linkage Editor 505 
Limitations of COBOL-74 
506 
Summary 
508 
Fill-in 509 
True/False 509 
Problems 510 
c L ^ . ; r . ! r 
t L '. Sequential File M 
Overview 
516 
System Concepts 
516 
Sequential versus Nonsequential Processing 518 
Periodic Maintenance 518 
Data Validation 
519 
Programming Specifications 520 
Designing the Program 523 
The Completed Program 524 
Sequential File Maintenance 
528 
intenance 
515 
Programming Specifications 528 
The Balance Line Algorithm 529 
Designing the Hierarchy Chart 531 
Top-Down Testing 
535 
The Stubs Program 535 
The Completed Program 540 
Summary 
545 
Fill-in 546 
True/False 546 
Problems 547 
_. 
. . Indexed Files 
Overview 
550 
System Concepts 
550 
COBOL Implementation 
554 
Creating an Indexed File 
556 
Programming Specifications 556 
Pseudocode 557 
The Completed Program 557 
Additional COBOL Elements 
559 
OPEN 559 
READ 560 
WRITE 562 
REWRITE 562 
DELETE 562 
549 
Maintaining an Indexed File 
563 
Programming Specifications 563 
Hierarchy Chart 564 
Pseudocode 566 
The Completed Program 566 
Alternate Record Key 
570 
Programming Specifications 570 
Concatenated Key 
573 
The START Statement 574 
Limitations of COBOL-74 
574 
Summary 
576 
Fill-in 577 
True/False 578 
Problems 578 

Contents 
v J - 
: ^ , 
The Year 2000 Problem 
583 
Overview 
584 
Leap-Year Problem 
594 
The Year 2000 Problem 
584 
Retirement Program Revisited 
594 
Date Arithmetic 
590 
Summary 
599 
COBOL Intrinsic Calendar Functions 591 
Fill-in 600 
True/False 600 
Problems 601 
. i v " ' 
a : Object-Oriented COBOL Programming 
Overview 
604 
The StudentDM Class 621 
The Next Generation of COBOL 
605 
The Development of Structured Programming 606 
Terminology 607 
The Object-Oriented versus Structured Paradigm 608 
Student-Look-UP Program 612 
The Registrar Class 616 
Classes and Inheritance 619 
ProcessRequests Method 619 
603 
The StudentDM Instance Definition 625 
The Student Class 627 
The Person Class 630 
The Student Ul Class 633 
The Student PRT Class 635 
Conclusion 
639 
Summary 
640 
Fill-in 641 
True/False 641 
Problems 642 
Micro Focus Personal COBOL for Windows: Users 
Guide and Tutorial 
643 
Getting Started 
Reserved Words 
u i L
1 l : COBOL-85 Reference Summary 
C^C^BC^IiHa 1997j 19<9C^|$ 1 <999^ ^C^OC^§i 01
s 
Answers to Odd-Numbered Exercises 
697 
709 
711 
737 
745 
Projects 
7 5 3 
893 


Overview 
The First Problem 
Programming Specifications 
Required Logic 
Flowcharts 
Pseudocode 
A First Look at COBOL 
Identification Division 
Environment Division 
Data Division 
Procedure Division 
Test Data 
Elements of COBOL 
Reserved Words 
Programmer-Supplied Names 
Literals 
Symbols 
Level Numbers 
PICTURE Clauses 
A Second Look at COBOL 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
1 — 
Introduction 
This book is about computer programming. In particular, it is about COBOL, a 
widely used commercial programming language. Programming involves the 
translation of an algorithm (a precise means of solving a problem) into a form the 
computer can understand. Programming is necessary because, despite reports 
to the contrary, computers cannot think for themselves. Instead, they do exactly 
what they have been instructed to do, and these instructions take the form of a 
computer program. The advantage of the computer stems from its speed and 
accuracy. It does not do anything that a human being could not do, given 
sufficient time and memory capacity. 
We begin our study of computer programming by describing a simple 
problem and then developing the logic and C O B O L program to solve it. This 
rapid entrance into C O B O L is somewhat different from the approach followed by 
most textbooks, but we believe in learning by doing. There is nothing very 
mysterious about C O B O L programming, so let's get started. 
Our first problem is set in the context of a university, and involves a set of student 
records, o n e record per student. Each record contains the student's name, number 
of c o m p l e t e d credits, and major. Implicit in this statement are the definitions of 
three fundamental terms: field, record, and file. A field 
is a basic fact, s u c h as the 
n a m e , address, major, grade point average, or n u m b e r of c o m p l e t e d credits. A 
record is a set of fields, a n d a file is a set of records. Thus, if there were 1,000 
students, there w o u l d be 1,000 records (one for each student), each consisting of 
five fields, a n d comprising a single student file. 
To clarify this relationship, w e create four hypothetical students for our 
problem: John Adams, Amelia Earhart, Orville Wright, and Georgia O'Keeffe. There 
are m a n y facts about each of our students, but our problem utilizes only three: 
E 
S 
After reading this chapter you will be able to: 
Define the terms: field, record, and file. 
Name two techniques used to express program logic. 
Identify the four divisions of a COBOL program. 
State the six COBOL language elements. 
State the rules for creating a programmer-supplied name; distinguish 
between examples of valid and invalid names. 
State the difference between numeric and nonnumeric literals; recognize 
valid and invalid examples of each. 
Follow the logic of a simple program as expressed in a flowchart or 
pseudocode. 

The First 
Problem 
Fields, Records, and Files 
XI, 
Name 
Credits 
Major 
Name 
Credits. 
Major 
Name 
Credits 
Major 
A 
ji || 
Name 
i* | 
Credits 
i f 
Major: 
(Facts) 
John Adams 
9G 
Political Science 
Amelia Earhart 
120 
Aviation 
Orville Wright 
115 
Engineering 
Qgomi» O
fKeeffe 
125 
Art 
(Set of Fields) 
John Adams f90 [ Political Science 
(Set of Records) 
Amelia Earhart 120 
Aviation 
[J Orville Wright JTlS^Tf" Engineering 
Johi n Adams 
A n i 6 |ia Earhart 
0 r v i«e Wright 
I Georgia O'Keeffel 125 
90 
120 
Political Science 
Aviation 
Engineering 
name, major, and credits completed. Figure 1.1 represents these concepts in pictorial 
fashion. Each fact about each student comprises a single field. The three fields 
collectively make up that student's record. The four records (one for e a c h of our 
students) c o m p o s e the student file. 
The problem is to process the file of student records and produce a list of 
engineering students w h o have completed more than 110 credits. It is a typical 
problem, in that its solution will address the three elements c o m m o n to all computer 
applications: input, processing, and output. As s h o w n in Figure 1.2, the student file, 
just defined, is the input, this file is processed by determining which students are 
engineering majors with more than 110 credits; and consequently, a report is created 
as output, reflecting these students. 
The input to a computer program; that is, the precise arrangement of the 
various fields in each incoming record, has to be specified exactly. Figure 1.3a is a 
c o m m o n way to c o m m u n i c a t e this information, and shows that the student's name 
is contained in positions 1-25, the n u m b e r of credits in positions 26-28, and the 
student's major in positions 29-43. N o t e too, that every record in a given file must 
have the identical record layout. 
In similar fashion, the report produced as output is also precisely designed. 
Figure 1.3c shows a print layout chart, in which descriptive information appears 
o n line one, with the n a m e s of selected students in c o l u m n s 9-33 of subsequent 
lines. Observe also that the location of the n a m e field is different in the input and 
output records (positions 1-25 and 9-33, respectively), and that each input record 
contains three fields, but that each line of output has b e e n designed to contain only 
o n e field. 
It is important that programming specification—that is, the input, processing, and 
o u t p u t r e q u i r e m e n t s — b e p r e s e n t e d in a clear a n d u n a m b i g u o u s 
fashion. 

Chapter 1 — Introduction 
i^/e t "i 
Input, Processing, and Output 
IHPUT 
John «aams 
Atnelii 
l a Earhart 
OrviH, 
6 Wright 
90 
120 
115 
. Aviation 
Engineering 
Engineering major 
with more than 
110 credits 
o 
0 
—-— 
STUDENT NAME 
ORVILLE WRIGHT 
re 1,3 
Engineering Senior (Input and Output) 
STUDENT NAME 
CREDITS 
STUDENT MAJOR 
1 
2 3 4 5 6 7 ! ) 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 
(s) £ >tt ident Recc rd L ayout 
JOHN ADAMS 
AMELIA EARHART 
ORVILLE WRIGHT 
GEORGIA 0'KEEFE 
090P0LITICAL SCI 
120AVIATI0N 
115ENGINEERING 
125ART 
(b) Test Data 
STUDENT NAME 
XXXXXXXXXXXXXXXXXXXXXXXXX 
xxxxxxxxxxxxxxxxxxxxxxxxx 
(c) Print Layout 

Required 
Logic 
Accordingly, the authors have a d o p t e d the format s h o w n below, a n d u s e it 
throughout the text for both illustrative programs and student assignments. The 
programming specifications begin with the program n a m e and a brief narrative, 
followed by a detailed description of the various requirements. Note, too, that the 
specification d o c u m e n t is entirely self-contained, and that if the person preparing 
the specifications has d o n e a c o m p l e t e job, there will b e little n e e d for the 
programmer to seek additional information. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Engineering Senior Program 
Narrative: 
This program processes a file of student records and prints the name of every student 
who is an engineering major with more than 110 credits. 
Input File(s): 
STUDENT-FILE 
Input Record Layout: 
See Figure 1.3a 
Test Data: 
See Figure 13b 
Report Layout: 
See Figure 1,3c 
Processing Requirements: 
1. Print a heading iine. 
2. Read a file of student records. 
3. For every record, determine whether that student has a major of engineering and has 
completed more than 110 credits. 
4. Print the name of every student who satisfies the requirements in item 3 above. Single-
space the output. 
i 
L ^ v „ 
L v . ^ . ^ 
Let us imagine momentarily that the student records are physically in the form of manila 
folders, stored in a filing cabinet, and further that a clerk is available to do our work. Our 
problem is to instruct the clerk on how to go through the folders. We would say something 
to the following effect: 
Repeat steps 1 through 4 until there are n o more folders: 
1. Select a folder. 
2. Examine the folder to see if that student is an engineering major a n d has 
more than 110 credits. 
3. If the student m e e t s b o t h qualifications, write the student's n a m e o n a 
running list. 
4. Return the folder to the file cabinet. 
Stop 
In essence, w e have prepared a series of instructions for the clerk to follow. If 
our instructions are correct and if they are followed exactly, then t h e clerk will 
produce the desired results. 

Chapter 
1 — Introduction 
A computer program is a set of instructions, written according to a precise 
aci e»i iatca, vviix^ii uic ^ciiiipuid iiucipicio ajuu ouuotqucntiy CACtuica. umii^c uic 
clerk, however, the c o m p u t e r always follows our instructions exactly. In other 
words, the computer does what we tell it to do, which is not necessarily what we 
want it to do. A h u m a n clerk, o n the other hand, has a m i n d of his or her o w n 
and c a n q u e s t i o n or alter erroneous instructions. Since t h e c o m p u t e r d o e s 
precisely what it is told, it is imperative that y o u strive to write logically correct 
programs. Accordingly, y o u must expend significant effort prior to actual coding 
to develop a program's logic correctly. Two c o m m o n techniques for expressing 
that logic are flowcharts and pseudocode. 
A flowchart is a pictorial representation of the logic inherent in a program. It is the 
translation of a problem statement into a logical blueprint that is subsequently 
incorporated into the COBOL program. A flowchart to list the engineering students 
with m o r e than 110 credits is s h o w n in Figure 1.4. 
A flowchart uses blocks with specific shapes to indicate the nature of a n 
operation. Using Figure 1.4 as a guide, w e see that a diamond-shaped block indicates 
a decision, a parallelogram depicts input or output, an ellipse shows the beginning 
or end, and a rectangle implies straightforward processing. A rectangle with vertical 
lines implies that the processing within the rectangle will be expanded into a 
flowchart of its o w n . 
To understand the flowchart in Figure 1.4, consider the nature of a READ 
statement. The function of a READ instruction is to obtain a record, but there will 
always b e a point w h e n a READ is attempted and n o record is found, that is, w h e n 
all the records in the file have already b e e n read. Since o n e d o e s n o t k n o w in 
advance h o w m a n y records a file contains, the READ instruction must also test for 
the end-of-file condition. Thus, if a file contains two records, it is actually read three 
times (once for e a c h record, and o n c e to sense the end-of-file condition). 
The flowchart in Figure 1.4 begins with a start block (block 1), and continues 
with various h o u s e k e e p i n g blocks. Housekeeping consists of statements that are 
d o n e o n c e at the start of processing, for example, o p e n i n g files (block 2), reading 
the first record (block 3), and writing a heading at the start of a report (block 4). 
Control then passes through a connector block (block 5) to a decision statement 
(block 6). 
If the end-of-file has not been reached, control goes to the PROCESS-RECORDS 
block, which is e x p a n d e d in the right side of the figure. Each i n c o m i n g record is 
checked in block 9 to determine if it m e e t s both qualifications. If so, that student's 
n a m e is written to the output report in block 10; if not, control goes directly to the 
connector in block 11. (Note that b o t h the true and false branches for the condition 
in block 9 m e e t at a single connector in block 11.) The next record is read in block 
12, and the PROCESS-RECORDS block is finished. Control then m o v e s to the left 
side of the figure, to the connector in block 5 to the end-of-file test in block 6. 
Eventually, w h e n the end-of-file has been reached, control will pass to close files 
(block 7), then to the stop statement in block 8. 
To better understand how the flowchart works, w e can u s e the test data of 
Figure 1.1 and play computer, by running the data through the flowchart. Execution 
begins by o p e n i n g the files, reading the first record (John Adams), and writing the 
heading line. The end-of-file has not been reached, so block 6 directs flow to block 
9, the test for engineering majors with more than 110 credits. John Adams fails the 
test, so control passes to the connector in block 11, to the READ in block 12, 
w h e r e u p o n the data for Amelia Earhart are read into memory. Control flows through 

Required 
Logic 
Flowchart to Select Engineering Seniors 
the connector of block 5, to the end-of-file test in block 6, and then to the qualification 
test in block 9. Amelia Earhart fails the test, again passing control to the connector 
in block 11, to the READ in block 12, at which point Orville Wright is read into 
memory. However, Wright is an engineering major with m o r e than 110 credits, so 
he passes the test and his n a m e is written in block 10. 
The data for Georgia O'Keeffe are read in block 12, and control flows o n c e 
more to the connector in block 5, to the end-of-file test in block 6. Realize, however, 
that even though O'Keeffe is the last record, the end-of-file condition has not yet 
b e e n detected. O'Keeffe fails the qualification test, w h e r e u p o n control flows to the 
READ in block 12. This time the end-of-file is detected so that, w h e n control again 
reaches the end-of-file test in block 6, processing will b e directed t o the CLOSE 
FILES and STOP statements in blocks 7 and 8. 

Chapter 
1 
Introduction 
_' .. i The Flow chart and Test Data 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Start 
Open files 
Initial read 
Write heading 
Connector 
End-of-file test 
Close files 
Stop 
Qualifying test 
Write 
Connector 
Read 
At beginning of program 
At beginning of program 
Reads the first record (Adams) 
At K^ir^;*-,,-, 
^r^r^m 
Entered five times 
Once for each of four records; once to sense 
end-of-file condition 
Once, before execution stops 
Executed once, at program's end 
Once for each student 
Executed for Wright only 
Entered four times 
Reads every record but the first, and detects 
the end-of-file condition 
It is useful to summarize this discussion by tabulating the n u m b e r of times 
each block in Figure 1.4 is executed. This is s h o w n in Table 1.1. 
Pseudocode expresses a program's logic m o r e concisely than a flowchart. One 
definition of p s e u d o c o d e is neat notes to oneself, a n d since programmers do this 
naturally, p s e u d o c o d e has replaced the traditional flowchart in m a n y installations. 
Consider Figure 1.5, w h i c h contains identical logic to the flowchart in Figure 1.4, 
albeit in a m o r e concise fashion. 
As s h o w n in Figure 1.5, the logic of m o s t programs can b e divided into three 
major portions: initialization, processing, and termination. Initialization is done 
o n c e at the start of processing—for example, o p e n i n g files, reading the first record 
in a file, and writing a heading. This is followed by a series of instructions that are 
executed repeatedly, o n c e for each i n c o m i n g record; e.g., e a c h record is evaluated 
for an engineering major with the requisite n u m b e r of credits. If both conditions are 
met, the n a m e will be written o n the registrar's list; if the conditions are n o t met, 
Pseudocode 
Initialization 
Processing 
Termination 
\ 
Open f i l e s 
Read f i r s t 
record 
Write heading 
DO while data remains 
IF engineering major with more than 110 credits 
Write student's name 
ENDIF 
Read next record 
ENDDO 
Close 
f i l e s 
Stop 

A First 
Look 
at 
COBOL 
nothing further is d o n e with the particular record. When all of the records in the file 
have b e e n read, the loop is finished, and a termination routine is entered to print a 
total or simply stop processing. 
Figure 1.5 also contains vertical lines connecting the words IF and ENDIF, and 
DO and ENDDO. This notation indicates two of the basic building blocks {selection 
and iteration) of a discipline known as structured programming 
which is fully 
explained in Chapter 3. 
P s e u d o c o d e uses instructions similar to those of a computer language to 
describe program logic, but is not b o u n d b y precise syntactical rules found in 
formal programming languages. For example, the vertical lines referred to previously 
are the authors' convention and do not necessarily appear in the p s e u d o c o d e of 
others. Nor is p s e u d o c o d e b o u n d by any rules for indentation, which is d o n e strictly 
at the discretion of the person using it. The purpose of p s e u d o c o d e is simply to 
convey program logic in a straightforward and easily followed manner. 
We proceed to the COBOL program in Figure 1.6, which corresponds to the flowchart 
in Figure 1.4 and the p s e u d o c o d e in Figure 1.5. The syntactical rules for COBOL are 
extremely precise, and you are certainly not expected to r e m e m b e r t h e m after a 
brief exposure to Figure 1.6. The authors believe, however, that immediate exposure 
to a real program is extremely beneficial in stripping the mystical aura that too often 
The First COBOL Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
SENIOR. 
AUTHOR. 
ROBERT 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR02\SENI0R.DAT 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
01 STUDENT-IN. 
05 STU-NAME 
PIC 
05 STU-CREDITS 
PIC 
05 STU-MAJ0R 
PIC 
DATA DIVISION. 
FILE SECTION. 
FD STUDENT-FILE 
RECORD CONTAINS 43 CHARACTERS 
DATA RECORD IS STUDENT-IN. 
PIC X(25). 
PIC 9(3). 
PIC X(15). 

Chapter 
1 -
Introduction 
r e 1 . 6 
(continued) 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
01 
PRINT-LINE 
WORKING-STORAGE SECTION. 
01 
DATA-REMAINS-SWITCH 
01 HEADING-LINE. 
05 FILLER 
05 FILLER 
05 FILLER 
PIC X(132). 
PIC X(2) 
PIC X(10) 
PIC X(12) 
PIC X(110) 
VALUE SPACES. 
VALUE SPACES. 
VALUE 'STUDENT NAME' 
VALUE SPACES. 
~~~Da(a Division 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
01 DETAIL-LINE. 
05 FILLER 
05 PRINT-NAME 
05 FILLER 
PIC X(8) 
PIC 1(25). 
PIC X(99) 
VALUE SPACES. 
VALUE SPACES. 
I 
PROCEDURE DIVISION. 
PREPARE-SENIOR-REPORT. 
OPEN INPUT 
STUDENT-FILE 
OUTPUT PRINT-FILE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PERFORM WRITE-HEADING-LINE. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
CLOSE STUDENT-FILE 
PRINT-FILE. 
STOP RUN. 
WRITE-HEADING-LINE. 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE. 
PROCESS-RECORDS. 
IF STU-CREDITS > 110 AND STU-MAJOR = 'ENGINEERING' 
MOVE STU-NAME TO PRINT-NAME 
MOVE DETAIL-LINE TO PRINT-LINE 
WRITE PRINT-LINE 
END-IF. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
Procedure Division 

surrounds programming. Further, Figure 1.6 will b e c o m e easier to understand after 
s o m e brief explanation. 
Every COBOL program consists of four divisions, which must appear in the 
following order: 
IDENTIFICATION DIVISION 
The Identification Division contains the 
program n a m e and author's n a m e . 
ENVIRONMENT DIVISION 
The Environment Division associates the file 
n a m e s referenced in a program to the input and 
output (I/O) devices recognized by the operating 
system. 
DATA DIVISION 
The Data Division describes the record layout of 
the incoming record(s) and the location of data 
in the generated report. 
PROCEDURE DIVISION 
The Procedure Division contains the program 
logic, that is, the instructions the computer is to 
execute in solving the problem. 
Since COBOL is intended to resemble English, y o u m a y be able to get an 
overall sense of what is happening, merely by reading the program. W e provide an 
intuitive explanation and reiterate that, at this time, y o u should in no way be 
concerned with the precise syntax of the language; that is, our present intent is to 
teach COBOL by example, with the short-term objective of achieving a conceptual 
understanding of a COBOL program. 
T h e Identification Division 
.... 
The I D E N T I F I C A T I O N D I V I S I O N (Lines 1-3) appears at the beginning of every 
program. It serves to identify the program (SENIOR) and the author (Robert Grauer). 
There is nothing complicated about this division, and it has n o effect o n the results 
of the program. 
The Environment Division 
The E N V I R O N M E N T D I V I S I O N (lines 5-11) contains the INPUT-OUTPUT SECTION, 
which describes the files used by the program. The engineering senior program 
uses two files, a n input file containing the student records and an output file for the 
report. Both of these files are defined in SELECT statements. 
The n a m e s chosen by the programmer for these files (that is, STUDENT-FILE 
and PRINT-FILE) are assigned to logical devices k n o w n to the operating system, by 
the SELECT statement and associated ASSIGN clause. Line 8, for example, ties the 
incoming STUDENT-FILE to the file SENIOR.DAT; this tells the operating system to 
read the file containing the incoming student records from the file SENIOR.DAT. 
(The format of the file n a m e is installation d e p e n d e n t and varies from computer to 
computer.) The clause ORGANIZATION IS LINE SEQUENTIAL is required to properly 
process sequential files o n personal computers. Mainframe sequential files have a 
different format and do not require this clause. 
T h e Da< ^ &i vision 
.,..„„.., 
The D A T A D I V I S I O N (lines 13-39) describes all data elements used by the program. 
It is divided into two sections, the FILE SECTION (lines 14-26) and the WORKING-
STORAGE SECTION (lines 28-39). 

Chapter 
1 
Introduction 
The FILE SECTION contains file description (FD) entries for files previously 
d e n n e d in SELECT statements. The FD for STUDENT-FILE extends from line 15 to 
line 17 and contains clauses that describe the physical characteristics of the file. The 
FD is followed by a record 
description, 
which defines the various fields within the 
record (lines 18-21). 
The statements within the record description are preceded by level 
numbers, 
in this example, 01 and 05. The level n u m b e r 01 is special and indicates the beginning 
of a record 
description 
entry. The fields within a record are defined through a series 
of PICTURE clauses (PIC is an acceptable abbreviation), w h i c h indicate the 
type 
and size of the field. A picture of 9's indicates a numeric field, whereas a picture of 
X's signifies an alphanumeric field. The n u m b e r in parentheses indicates the size 
of the field; for e x a m p l e , PIC 9(3) indicates a t h r e e - p o s i t i o n n u m e r i c field, 
and PIC X(25) is a 25-position alphanumeric field. The PICTURE clauses in lines 
19-21 of Figure 1.6 are consistent with the record description in the original 
problem statement. 
The WORKING-STORAGE SECTION (lines 28-39) is u s e d to define any data 
n a m e s that do not appear in an input or output file. The programming specifications 
called for two distinct print lines (a heading line and a detail line), each of which 
contains a different format as per the print layout of Figure 1.3. Accordingly, two 
different 01 entries are defined, HEADING-LINE and DETAIL-LINE, each with a 
different layout. The function of DATA-REMAINS-SWITCH will be m a d e clearer 
after an examination of the Procedure Division. 
The PROCEDURE DIVISION (lines 41-67) contains the logic required to solve the 
problem. The Procedure Division is divided into paragraphs, 
with each paragraph 
consisting of o n e or more sentences. 
The first paragraph, PREPARE-SENIOR-REPORT, extends from line 42 to line 
53. It begins by opening the files, then reading the first student record. The PERFORM 
statement in line 48 transfers control to the paragraph WRITE-HEADING-LINE 
(lines 55-57), which prints the heading, then returns control back to line 49 in the 
PREPARE-SENIOR-REPORT paragraph. This too is a PERFORM statement, which 
transfers control to the paragraph PROCESS-RECORDS (lines 5 9 - 6 7 ) , w h i c h 
processes i n c o m i n g student records until the data file is exhausted. 
The IF statement in line 60 determines whether an i n c o m i n g record meets 
both qualifications, that is, whether the student is an engineering major and has 
more than 110 credits. If both conditions are met, that student's n a m e is written to 
the output report. The IF statement extends to the END-IF scope 
terminator 
in line 
64; that is, if the condition in line 60 is met, every statement b e t w e e n the condition 
and the END-IF in line 64 will be executed. Note, too, that three COBOL statements 
are required to produce a detail line; the i n c o m i n g n a m e is m o v e d to the output 
n a m e in line 61, the detail line is m o v e d to the print line in line 62, and the line is 
written in line 63. 
The action of the PERFORM statement is explained with the aid of Figure 1.7. 
T h e PERFORM s t a t e m e n t i n l i n e 49 transfers c o n t r o l t o t h e 
p a r a g r a p h 
PROCESS-RECORDS, until DATA-REMAINS-SWITCH = 'NO', that is, until the data 
file is empty. Accordingly, the last statement of the performed routine is a READ 
statement to read the next record. W h e n the end-of-file is reached, the AT END 
clause of the READ statement will m o v e 'NO' to DATA-REMAINS-SWITCH to 
terminate the PERFORM; the READ statement itself is e n d e d by the END-READ 
scope terminator. Control then returns to the statement under the PERFORM 
statement (to line 51), w h i c h closes the files, and finally to the STOP RUN statement, 
which terminates the program. 

Procedure Division Logic 
PROCEDURE DIVISION 
PREPARE-SENIOR-REPORT. 
OPEN INPUT STUDENT-FILE 
OUTPUT PRINT-FILE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMINS-SWITCH 
END-READ 
PERFORM WRITE-HEADING-LINE. 
PERFORM PROCESS RECORDS 
1 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
PROCESS-RECORDS. 
IF STU-CREDITS > 110 AND STU-MAJOR = 'ENGINEERING' 
MOVE STU-NAME TO PRINT-NAME 
MOVE DETAIL-LINE TO PRINT-LINE 
WRITE PRINT-LINE 
END-IF 
READ STUDENT-FILE 
CLOSE STUDENT-FILE 
pKiNl-FiLE. 
STOP RUN. 
Figure 1.8 contains test data and the associated output produced by the program in 
Figure 1.6. (Five more records have b e e n added to provide additional examples.) 
You should be able to state the reasons w h y individual records were n o t selected for 
the output report; for example, Amelia Earhart and Alex Bell were rejected for the 
wrong major and an insufficient n u m b e r of credits, respectively. (Can y o u identify 
all nine of our famous students?) 
Although you are not yet expected to write a COBOL program, you s h o u l d be able to 
follow simple programs like the o n e in Figure 1.6 intuitively. This section begins a 
formal discussion of COBOL so that y o u will eventually be able to write an entire 
program. 
COBOL consists of six language elements: reserved words, programmer-
supplied names, literals, symbols, level numbers, and pictures. 
Reserved words have special significance to COBOL and are u s e d in a rigidly 
prescribed manner. They must b e spelled correctly, or the compiler will not be able 

Chapter 
1 — Introduction 
Test Data and Associated Output 
JOHN A D A M S 
AMELIA EARHART 
ORVILLE WRIGHT 
GEORGIA O'KEEFE 
MERIWETHER LEWIS 
JOHN KENNEDY 
ALEX BELL 
EMILY DICKINSON 
\ 
JOHN ROEBLING 
090POLTICAL SCI 
120AVIATION I 
115ENGINEERING 
125ART 
115TRAVEL 
115POLITICAL SCI 
090ENGINEERING 
085LITERATURE 
115ENGINEERING 
STUDENT N A M E 
ORVILLE WRIGHT 
JOHN ROEBLING 
to recognize t h e m . The list of reserved words varies from compiler to compiler. A 
comprehensive list of reserved words is given in Appendix C. T h e beginner is urged 
to refer frequently to this appendix for two reasons: (1) to ensure the proper spelling 
of reserved w o r d s u s e d in his or her program; and (2) to avoid t h e inadvertent use of 
reserved words as programmer-supplied n a m e s . 
You, the programmer, supply n a m e s for paragraphs, data e l e m e n t s , and files. A 
paragraph 
name is a tag to which the program refers, for example, PROCESS-
RECORDS or PREPARE-SENIOR-REPORT in Figure 1.6. Data names are the elements 
o n which instructions operate, for example, STU-NAME, STU-CREDITS, and STU-
MAJOR in Figure 1.6. File names are specified in several places throughout a COBOL 
program, but their initial appearance is in the Environment Division, for example, 
STUDENT-FILE a n d PRINT-FILE in Figure 1.6. All programmer-supplied n a m e s are 
c h o s e n according to the following rules: 
1. A programmer-supplied n a m e m a y contain the letters A to Z, the digits 0 to 
9, and the hyphen; n o other characters are permitted, n o t e v e n blanks. 

Elements 
of 
COBOL 
1.2 
Programmer-Supplied Names 
SUM 
SUM-OF-X 
SUM OF X 
SUM-OF-X-
SUM-OF-ALL-THE-XS 
SUM-OF-ALL-THE-XS-IN-ENTIRE-PROGRAM 
GROSS-PAY-IN-$ 
12345 
Invalid—reserved word 
Valid 
Invalid—contains blanks 
invalid—ends with a hyphen 
Valid 
Invalid -more than 30 characters 
Invalid—contains a $ 
V a l i d as a paragraph name but invalid 
as a data name 
A literal 
is an exact value or constant. Literals are of two types, numeric (a number) 
or nonnumeric 
(a character string). Literals of both types appear throughout a 
program and are used to compare the value of a data n a m e to a specified constant. 
Consider line 60 of Figure 1.6: 
IF STU-CREDITS > 110 AND STU-MAJOR = 'ENGINEERING
1 
In the first portion of the statement, STU-CREDITS is compared to 110, a numeric 
literal. Numeric literals adhere to the following rules: 
1. A numeric literal can be up to 18 digits long. 
2. A numeric literal m a y begin with a leading (leftmost) plus or m i n u s sign. 
3. A numeric literal m a y contain a decimal point, but it m a y not e n d with a 
decimal point. 
T h e s e c o n d part of t h e IF s t a t e m e n t c o n t a i n s a n o n n u m e r i c 
literal, 
'ENGINEERING'. N o n n u m e r i c literals adhere to the following rules: 
1. A n o n n u m e r i c literal is enclosed in apostrophes (or quotation marks) as 
specified by the compiler. 
2. A n o n n u m e r i c literal m a y be up to 160 characters in length. 
3. A n o n n u m e r i c literal m a y contain anything, including blanks, numbers, and 
reserved words, but not another apostrophe (or quotation mark). 
Examples of both n u m e r i c a n d n o n n u m e r i c literals are s h o w n Table 1.3. 
2. A programmer-supplied n a m e m a y rcof begin or e n d with a h y p h e n . 
3. A programmer-supplied n a m e m u s t be 30 characters or fewer in length. 
4. A reserved word m a y not be used as a programmer-supplied n a m e . 
5. Data n a m e s m u s t contain at least one letter. 
6. Paragraph n a m e s m a y be all numeric. 
Table 1.2 illustrates examples of the rules associated with programmer-supplied 
n a m e s . 

C h a p t e r 
1 
Introduction 
Numeric and Nonnumeric Literals 
123.4 
Valid numeric literal 
'123.4' 
Valid nonnumeric literal 
+123 
Valid numeric literal 
'IDENTIFICATION DIVISION' 
Valid nonnumeric literal 
i c^. 
:t i v a u v j i i u i i ici ivj nidi a i 
i i l a y 
i u i c i tu w i n i a i j ^ ^ n i ic*i p w n l i 
123- 
Invalid numeric literal—the minus sign must be in the leftmost 
position 
Symbols are of three types—punctuation, arithmetic, and relational, as listed in 
Table 1.4. 
IfelLfr: 1 , 4 
Symbols 
Punctuation 
1 or" 
( ) 
Arithmetic 
+ 
/ 
Relational 
> 
< 
>= 
<= 
Denotes end of COBOL entry 
Delineates clauses 
Sets off nonnumeric literals 
Encloses subscripts or expressions 
Addition 
Subtraction 
Multiplication 
Division 
Exponentiation 
Equal to 
Greater than 
Less than 
Greater than or equal to 
Less than or equal to 
The use of relational and arithmetic symbols is described in detail later in the 
text, beginning in Chapter 4. A period terminates an entry, a n d its omission (in the 
a b s e n c e of a s c o p e terminator) can cause difficulty. A c o m m a , o n the other hand, is 
entirely optional, and its o m i s s i o n (or inclusion) has n o effect whatsoever on the 
program. The use of c o m m a s is discouraged, however, as a c o m m a can be mistaken 
for a period o n older printers, w h i c h tend to blur the output. 
Level numbers 
describe the relationship of items in a record. For example, under 
STUDENT-FILE in Figure 1.6, there w a s a single 01-level entry a n d several 05-level 
entries. In general, the higher (numerically) the level n u m b e r , the less significant 
the entry; thus 05 is less important than 01. Entries with higher numeric values are 
said to belong to the levels above them. Thus, in Figure 1.6 t h e several 05-level 
entries belong to their respective 01-level entries. 

A Second 
Look 
at 
COBOL 
P I C T U R E 
C l a u s e s 
, 
Pictures describe the nature of incoming or outgoing data. A picture of 9's m e a n s 
the entry is numeric; a picture of X's m e a n s the entry is alphanumeric, that is, it can 
contain letters, numbers, and special characters. (Alphabetic pictures, with a picture 
of A, are s e l d o m used; even n a m e s can contain apostrophes or hyphens, w h i c h are 
alphanumeric rather than alphabetic in nature.) Level numbers and pictures are 
discussed more fully in Chapter 4. 
I'iguie 1.9 contains a relabeled version of the Engineering Senior Program and 
represents a s e c o n d look at COBOL. This time our intention is to e m p h a s i z e the 
various COBOL elements as they appear in a complete program. 
The Engineering Senior Program (A Second Look) 
1 
IDENTIFICATION DIVISION. 
| 
2 
PROGRAM-ID. 
SENIOR. 
| 
3 
AUTHOR. 
ROBERT GRAUER. 
| 
4 
[ 
5 
ENVIRONMENT DIVISION. 
I 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT jSTUDENT-FILE LA&IGN_J0_ ' A:\CHAPTR02\SENI0R.DAT'. 
9 
ORGANIZATION IS L I N E SEQUENtYaT." 
j 
10 
SELECT PRINT-FILE 
1 
11 
A S S I G N TO PRINTER. 
| 
12 
! 
13 
DATA DIVISION. 
I 
14 
FILE SECTION. 
j 
15 
FD [ S J U D E r n Z I L l } ' ' ' 
I 
16 
RECORD CONTAINS 4 3 CHARACTERS 
[ 
17 
DATA RECORD IS STUDENT-IN. 
18 
01 STUDENT-IN. 
19 
0 5 S R I - N A M E " 
P I C X(?f>). 
20 
;05 STU-CREDITS 
P I C 9 ( 3 ) . 
j - " " " " " " 
21 
105 STU-MAJOR 
P I C X ( 1 5 ) . 1 
22 
' 
23 
FD P R I N T - F I L E 
24 
RECORD CONTAINS 132 CHARACTERS 
25 
DATA RECORD IS PRINT-LINE. 
26 
01 P R I N T - L I N E 
P I C X ( 1 3 2 ) . 
^ . i ^ : ^ , , ^ , 
1 
2
7 
^ 
, 
~
'
i 
2 8 
j W O R K I N G - S T O R A G E 
SECTION.| 
| 
29 
01 DATA-REMAINS-SWITCH 
P I C X(2) 
VALUE SPACES. 
[ 
30 
I 

Chapter 
1 — 
Introduction 
(continued) 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
01 HEADING-LINE. 
05 FILLER 
05 FILLER 
05 FILLER 
01 DETAIL-LINE. 
05 FILLER 
05 PRINT-NAME 
05 FILLER 
PIC X{10) 
PIC X(12) 
PIC X(110) 
PIC X(8) 
PIC X(25). 
PIC X(99) 
VALUE SPACES. 
VALUE
 
1 STUDENT NAME', 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
| PROCEDURE DIVISION, f 
PREPARE-SENIOR-RFPORT. 
~
 R i 
OPEN INPUT 
STUDENT-FILE 
OUTPUT PRINT-FILE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PERFORM WRITE-HEADING-LINE. 
[PERFORM proces's-reCorB?! 
UNTIL DATA-REMAINS-SWITCH = 'NO'. ~ ~ 
CLOSE STUDENT-FILE 
PRINT-FILE. 
/ 
STOP RUN. 
WRITE-HEADING-LINE. 
/ 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE. 
/ 
>HedL 
/Numeric lite. 
PROCESS-RECORDS. 
/ Nonnumaric liiera! 
IF STU-CREDITS > [110]AND STU-MAJOR 
MOVE STU-NAME TO PRINT-NAME 
MOVE DETAIL-LINE TO PRINT-LINE 
WRITE PRINT-LINE 
END-IF. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
"ENGINEERINGT 
Observe, for example, the definition of a file name, STUDENT-FILE, in the 
SELECT statement of line 8, and its s u b s e q u e n t appearance in t h e I'D of line 15, a n d 
the OPEN, READ, and CLOSE statements of lines 43, 45, 51, a n d 65. Notice the 
definition of the various data names in lines 19-21 (accomplished through level 
n u m b e r s a n d PICTURE clauses) and the s u b s e q u e n t appearances in the Procedure 
Division. N o t e the consistency of the paragraph n a m e in the PERFORM statement 
of line 49 a n d the paragraph header in line 59. Observe that literals appear in the IF 
statement of line 60 and in the AT END clause of the READ statement (lines 46 a n d 
66). Finally, note the a b u n d a n t u s e of COBOL reserved w o r d s (PROCEDURE, 
DIVISION, WORKING-STORAGE, SECTION, and so on) throughout. 

A field is a basic fact, such as the name, address, major, grade point 
average, or number of completed credits, A record is a set of fields, and a 
file is a set of records. 
Every computer application consists of input, processing, and output. 
The computer cannot think for itself but must be told precisely what to do. 
This is done through a series of instructions known as a program. 
The computer does not do anything that a human being could not do if 
given sufficient time. The advantages of a computer stem from its speed 
and accuracy. 
A flowchart and/or pseudocode represent the logic embodied in a computer 
program. 
Every C O B O L program contains four divisions, which appear in the 
sequence: Identification, Environment, Data, 
edure. 
COBOL contains six language elements; reserved words, programmer-
supplied names, literals, symbols, level numbers, and pictures. 
X e y 
m
o
r
a
s 
a
n
c 
Alphabetic data 
Alphanumeric data 
Arithmetic symbol 
End-of-file 
Field 
File 
Flowchart 
Initialization 
Level number 
Nonnumeric literal 
Numeric data 
Numeric literal 
Paragraph 
Processing 
Programmer-supplied name 
Programming specifications 
Pseudocode 
Punctuation symbol 
Record 
Record description 
Relational symbol 
Reserved words 
Scope terminator 
Symbol 
Termination 
Test Data 
C
0
B
G
L 
E
l
e
m
e
n
t
s 
DATA DIVISION 
ENVIRONMENT DIVISION 
FILE SECTION 
IDENTIFICATION DIVISION 
INPUT-OUTPUT SECTION 
PICTURE 
PROCEDURE DIVISION 
WORKING-STORAGE SECTION 

CHAPTER 
1 
Introduction 
1. All computer applications consist of 
, 
. and 
2. The divisions of a COBOL program appear in the order: 
, 
, 
, 
, and 
, 
_. 
3. A 
is a pictorial representation of the logic in a program. 
4. 
may be described as neat notes to oneself. 
5. A diamond-shaped block in a flowchart indicates a 
. 
6. 
have special significance to COBOL and 
must be used in a rigidly prescribed manner and be spelled correctly. 
7. A 
- 
may contain the letters 
A to Z, the digits 0 to 9, and the hyphen. 
8. ** is the COBOL symbol for 
. 
9. =, > , and < are examples of 
symbols in COBOL. 
10. A 
is a set of records. 
11. A record consists of one or more 
. 
12. A 
is a set of instructions to a computer. 
/ R U E / F A L S E 
1. Nonnumeric literals may not contain numbers. 
2. Numeric literals may not contain letters. 
3. A data name may not contain any characters other than letters or numbers. 
4. The rules for forming paragraph names and data names are exactly the same. 
5. A data name may not consist of more than 30 characters. 
6. A nonnumeric literal may not contain more than 30 characters. 
7. A numeric literal may contain up to 18 digits. 
8. There are four divisions in a COBOL program. 
9. The divisions of a COBOL program may appear in any order. 
10. Data description appears in the Identification Division. 
11. A record contains one or more fields. 
12. A file is a set of records. 
13. Computers can think for themselves. 
14. No statement in a computer program may be executed more than once. 
15. A rectangle is the standard flowchart symbol for a decision block. 
16. Reserved words may appear in a nonnumeric literal. 
17. Reserved words may be used as data names. 

Problems 
18. Pseudocode serves the same function as a flowchart. 
19. Pseudocode must be written according to precise syntactical rules. 
20. The COBOL compiler needs to be installed every time a program is executed. 
P 
R O B L E M 
S 
1. Indicate whether the entries below are valid as data names. If any entry is invalid, 
state the reason. 
a. NUMBER-OF-TIMES 
b. CODE 
c. 12345 
d. ONE TWO THREE 
e. IDENTIFICATION-DIVISION 
f. IDENTIFICATION 
g. HOURS 
h. GROSS-PAY 
i. GROSS-PAY-IN-S 
2. Classify the entries below as being valid or invalid literals. For each valid entry, 
indicate whether it is numeric or nonnumeric; for each invalid entry, state why it is 
invalid. 
a. 567 
b. 567. 
c. -567 
d. +567 
e. +567. 
f. '567.' 
g. 'FIVE SIX SEVEN' 
h. '-567' 
i. 567-
j. 567+ 
k. '567+' 
3. a. Which division(s) contain paragraph names? 
b. Which division(s) contain the SELECT statement(s)? 
c. Which division(s) contain level numbers? 
d. Which division(s) contain data names? 
e. Which division(s) contain reserved words? 
f. Which division(s) contain PICTURE clauses? 
g. Which division(s) do not contain file names? 
4. Given the COBOL program in Figure 1.6, indicate what changes would have to be 
made if 
a. We wanted music students rather than engineering students. 
b. We wanted students with 60 or fewer credits. 
c. The student major was contained in columns 60-74 of the incoming record. 
d. We wanted engineering students or students with 110 credits or more. 
Note: Treat parts (a), (b), (c), and (d) independently. 

C
h
a
p
t
e
r 
1 
— 
Introduction 
5. Which division in a COBOL program contains 
a. The File Section? 
b. Statements to open and close files? 
c. The description of incoming data? 
d. The description of outgoing data? 
e. The author's name? 
f. The program's name? 
g. Statements to read information? 
h. Statements to write information? 
6. Your programming supervisor has drawn a flowchart for you to code. He left the 
flowchart on his dining room table at home, and unfortunately his three-year-old 
son, Benjy, cut it up into pieces with a pair of scissors. Your supervisor has 
collected the pieces (shown in Figure 1.10) and has asked you to rearrange them 
properly into a correct flowchart; do so. The flowchart is to read a file with each 
record containing three unequal numbers, A, B, and C. Write out the greater of the 
two sums (A + B) and (B + C) for each record only if A is less than 50. Develop the 
equivalent pseudocode. 
7. World Wide Sales, Inc., wishes to promote one of its employees to head the South 
American Division. The selected employee must speak Spanish, be 40 or younger, 
and hold a college degree. The programming manager has prepared the necessary 
flowchart (see Figure 1.11), but unfortunately Benjy and his scissors got to it first 
(see Problem 6). Your job is to put the flowchart together. Note that there may be 
more than one employee who qualifies for the position. Accordingly, the flowchart 
includes the necessary logic to count and print the number of qualified employees 
and to print the name of every such employee. Develop the equivalent pseudocode. 
8. Figure 1.12 contains a COBOL program to process a file of employee records and 
print the names of programmers under 30. Using Figure 1.6 as a guide, restore the 
missing information so that the program will run as intended. 
Flowchart Blocks for Problem 6 

Flowchart Blocks for Problem 7 
May be used more 
than once 
COBOL Listing for Problem 8 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
FIRSTTRY. 
GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT EMPLOYEE-FILE ASSIGN TO 'A:\CHAPTR02\FIRSTTRY.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
PRINT-FILE 
ASSIGN TO PRINTER. 
FILE SECTION. 
FD 
EMPLOYEE-FILE 
RECORD CONTAINS 44 CHARACTERS 
DATA RECORD IS EMPLOYEE-RECORD. 
01 
EMPLOYEE-RECORD. 
05 EMP-NAME 
PIC X(25). 
05 EMP-TITLE 
PIC X(10). 
05 EMP-AGE 
PIC 99. 
05 FILLER 
PIC XX. 
05 EMP-SALARY 
PIC 9(5). 

Chapter 
1 — 
Introduction 
igure 1.12 
COBOL Listing for Problem 8 
(continued) 
25 
FD 
4 
26 
RECORD CONTAINS 132 CHARACTERS 
27 
DATA RECORD IS PRINT-LINE. 
28 
01 PRINT-LINE. 
29 
05 FILLER 
PIC X. 
30 
05 PRINT-NAME 
5 
31 
05 FILLER 
PIC X(2). 
32 
05 PRINT-AGE 
PIC 99. 
33 
05 FILLER 
PIC X(3). 
34 
05 PRINT-SALARY 
PIC 9(5). 
35 
05 FILLER 
PIC X(94). 
36 
37 
6 
38 
01 END-OF-DATA-FLAG 
PIC X(3) 
7 
39 
PROCEDURE DIVISION. 
40 
MAINLINE. 
41 
8 
INPUT EMPLOYEE-FILE 
42 
OUTPUT PRINT-FILE. 
43 
MOVE SPACES TO PRINT-LINE. 
44 
MOVE 'SALARY REPORT FOR PROGRAMMERS UNDER 30' TO PRINT-LINE. 
45 
WRITE PRINT-LINE 
46 
AFTER ADVANCING 2 LINES. 
47 
READ EMPLOYEE-FILE 
48 
AT END MOVE 'YES' TO END-OF-DATA-FLAG 
49 
END-READ. 
50 
.9 
PROCESS-EMPLOYEE-RECORDS 
51 
UNTIL END-OF-DATA-FLAG = 'YES'. 
52 
CLOSE EMPLOYEE-FILE 
53 
PRINT-FILE. 
54 
STOP RUN. 
55 
56 
PROCESS-EMPLOYEE-RECORDS. 
^ '
?
0 
57 
IF EMP-TITLE =
 1 PROG RAMMER 'JMSTMP-AGE 
< 30 
58 
MOVE SPACES TO PRINTLINE 
59 
MOVE EMP-NAME ,10'PRINT-NAME 
60 
MOVE 
" TO PRINT-AGE 
61 
MOVE EMP-SALARY TO PRINT-SALARY 
62 
WRITE PRINT-LINE 
63 
END-IF. 
64 
READ EMPLOYEE-FILE
 
?' 
65 
AT END MOVE 
"TO END-OF-DATA-FLAG 
66 
END-READ. 

Overview 
From Coding Form to Computer 
The COBOL Coding Form 
Use of an Editor 
The Compile, Link, and Execute Sequence 
Learning by Doing 
Errors in Entering the Program 
Errors in Operating System Commands 
Errors in Compilation 
Errors in Execution 
Errors in Data Input 
Evolution of C O B O L 
There's Always a Reason 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
2 
From 
Coding 
Form 
to 
Computer 
O
B
J
E
C
T
I
V
E
S 
After reading this chapter you will be able to: 
I 
State the rules associated with the COBOL coding sheet, and enter a 
program appropriately. 
Distinguish between compilation and execution; describe the function of a 
link program. 
Describe the environmental differences between a P C and a mainframe as 
they relate to execution of COBOL programs. 
Compile, link, and execute a COBOL program. 
Find and correct simple errors in compilation or execution. 
O
V
E
R
V
I
E
W 
This chapter continues with the engineering senior program of Chapter 1, 
describing how to actually run a COBOL program. We discuss the COBOL 
coding form and its associated rules, the use of an editor (or word processor) to 
create C O B O L programs and/or data files, and the procedure for submission to 
the computer. We describe the compile, link, and execute sequence. We also 
prepare you for the errors you will inevitably make, discuss fundamentals of 
debugging, and alert you to the subtle differences between the two standards in 
use today, COBOL-74 and COBOL-85. 
At the conclusion of the chapter we ask you to run the engineering senior 
program of Chapter 1. Seeing 
is believing 
may be a cliche, but it is only after you 
have seen output from your own program that the material truly begins to make 
sense. Suffice it to say then, that the sooner you are on the computer, the sooner 
you will appreciate the subtleties inherent in programming. 
I* Sf © 6 1 1 C&*disft& 
Chapter 1 ended with presentation of a completed COBOL program, and a discussion 
P&h'm t& 
<>f the elements that make up the COBOL language. The program, however, is not 
yet in a form suitable for execution o n the computer, and m u c h has to be d o n e in 
order for this to b e accomplished. That is the overriding objective of this chapter. 
The 
flowchart in Figure 2.1 depicts the various steps in solving a problem 
through use of a computer. The first step is to obtain a clear statement of the 
problem, containing a complete description of the input a n d desired output. The 
problem statement should also contain detailed processing specifications. It is not 
enough, for example, to say calculate a student's grade point average; instead the 
m e t h o d for calculating the average must b e provided as well. 
Once the input, output, and processing specifications h a v e b e e n enumerated, 
a hierarchy chart (see Chapter 3) is created, then a flowchart or p s e u d o c o d e is 
developed. Careful attention to these steps will simplify the s u b s e q u e n t program 
and increase the likelihood it will b e correct. 
Coding is the translation of the hierarchy chart, flowchart, a n d / o r p s e u d o c o d e 
into COBOL. Coding must be d o n e within the well-defined rules of COBOL regarding 

From 
Coding 
Form 
to 
Co mp 
uter 
START 
OBTAIN 
PROGRAM 
SPECS 
DEVELOP A 
HIERARCHY 
CHART 
DEVELOP A 
FLOWCHART OR 
PSEUDOCODE 
ENTER PROGRAM 
ON CODING 
SHEETS 
ENTER PROGRAM 
USING TEXT 
EDITOR 
ENTER 
TEST DATA 
FALSE 
STOP 
TRUE 
REVISE 
COBOL 
PROGRAM 
TRUE 
REVISE 
COBOL 
PROGRAM 
the placement of various statements in specific areas of the coding form. After 
coding, the program is entered into a file suitable for input to a c o m p u t e r through 
use of an editor. 
The program is then submitted to the computer in conjunction with a set of 
control statements. The latter provide information to the operating s y s t e m as to the 
location of the COBOL program and/or its associated data. The control statements 
vary greatly from installation to installation. 
Next c o m e s compilation in which the COBOL program is translated into 
m a c h i n e language. Initial attempts at compilation are apt to identify several errors, 
due to misspellings, missing periods, misplaced parentheses, etc. Corrections are 
m a d e , a n d the program is recompiled. Only after the c o m p i l a t i o n has b e e n 
successfully c o m p l e t e d can w e proceed to execution. 
During execution the computer d o e s exactly what it was instructed to do, 
which m a y be different from what y o u want it to do. For example, if OR were 
substituted for A N D in line 60 of the engineering senior program, the program 
w o u l d select either engineering majors or seniors. Either way, it w o u l d function 
differently from the original, logically correct version, although the program would 
Figure 2.1 
The Programming Process 

C
h
a
p
t
e
r 
2 — 
From 
Coding 
Form 
to 
Computer 
still compile cleanly. Corrections are made, the program is recompiled, and testing 
continues. 
The presence of the two decision blocks in Figure 2.1 indicates the iterative 
nature of the entire process. Few, if any, programs compile correctly o n the first 
try—hence the n e e d to recode specific statements. Similarly, programs m a y not 
execute properly o n the first attempt, and thus the n e e d to revise the program, 
recompile, reexecute, and so on. 
The COBOL compiler is very particular about the information it receives, and requires 
a program to be written within its well-defined syntax. For example, division and 
section headers are required to begin b e t w e e n c o l u m n s 8 and 11, whereas m o s t 
other s t a t e m e n t s b e g i n in or past c o l u m n 12. There are additional rules for 
continuation (what happens if a statement d o e s not fit o n o n e line), c o m m e n t s , 
optional sequencing of source statements in columns 1-6, and program identification 
in c o l u m n s 73-80. 
The rules of the coding sheet are summarized in Table 2.1, and illustrated in 
Figure 2.2. The latter s h o w s c o m p l e t e d forms for the engineering senior problem of 
Chapter I. Several features in Figure 2.2 bear mention. Note in particular the wavy 
line under various PIC entries to indicate that identical information is to b e entered 
o n subsequent lines. Of greatest import, however, is the conformity b e t w e e n the 
entries in Figure 2.2 and the COBOL requirements of Table 2.1. 
Coding sheets are not mandatory and you can use ordinary paper instead. 
You will find, however, that programming is m u c h easier, if y o u are well organized. 
A g o o d start is to have the program neatly entered in appropriate c o l u m n s before 
sitting d o w n at the computer. 
Once a program has b e e n written o n coding sheets, it is entered through an editor 
(or word processor) into a file for subsequent input to the computer. In all likelihood 
y o u are already familiar with a w o r d processor, and can use that to create and edit 
COBOL programs as well. Accordingly, be sure y o u can do all of the following: 
1. Save the program as an unformatted (ASCII text) file, with a file n a m e of your 
o w n choosing, consistent with the computer o n w h i c h y o u will execute the 
program. 
2. Retrieve the file, then resave it after making additional modifications. 
3. Toggle b e t w e e n the insertion and replacement m o d e s to c h a n g e characters 
within a statement, a n d / o r to insert a n d / o r delete statements within a 
program. 
4. Print a listing of the file. 
You will also find it useful to learn the c o m m a n d s to: 
1. Set tabs to m o v e to designated columns; for example, c o l u m n s 8 and 12 for 
the A and B margins, respectively. 
2. Search a n d / o r replace character strings. 
3. Move to specified places within the program; for example, the beginning or 
end, a particular line, the start of the Procedure Division, a n d so on. 
The availability of an on-line editor facilitates p r o g r a m m i n g to an extent that 
w a s unimaginable to tens of thousands of COBOL programmers of the 1960s and 

From 
Coding 
Form 
to 
Computer 
Rules for the COBOL Coding Form 
1-6 
Optional sequence numbers, If this field is coded, the compiler performs a sequence check on incoming 
COBOL statements by flagging any statements out of order. Although some commercial installations 
encourage this option, we advise against it, especially since you are entering your own programs, and the 
more you type, the more chance for error. 
7 
An asterisk in column 7 indicates a comment, while a hyphen is used for the continuation of nonnumeric 
literals (described further on page 180). Comments may appear anywhere in a program; they are shown on 
the source listing but are otherwise ignored. 
8-11 
Known as the A margin, Division headers, section headers, paragraph names, FD's, and 01 's all begin in the 
A margin. 
12-72 
Known as the B margin, All remaining entries begin in or past column 12. COBOL permits considerable 
flexibility here, but individual installations have their own requirements. We, for example, begin PICTURE 
clauses in the same column, for example, column 37, for better readability. (We shall discuss this further in 
Chapter 7.) 
73-80 
Program identification, a second optional field, which is ignored by the compiler. Different installations have 
different standards regarding use of this field. 
Fhe COBOL Coding Form 
S E N I O R 
.. 
ROBERT 6RAUER 
• .. 9/10/93 
I DENT I F l C A T I ON D I V I 51 ON 
; I 
• R 
: : I 
I 
: I 
I : 
I . 
! 
! I 
{ 
P R O G R A M - I D 
S E N I O R 
f 
AUTHOR. 
. 
R O B E R T G R A U E R 
, 
E N V I R O N M E N T 
D I V I S I O N 
• : I • < I 
, 
I 
I 
I 
I : : 
I
 1 '
 1 M 
I N P U T - O U T P U T 
S E C T I O N " . 
; 
I 
I 
! 
! 
• I • : I I • I : ; I 
: ! I I 
F I L E - C O N T R O L 
S E L E C T 
S T U D E N T - F I L E 
A S S I G N TO 
' A \ C H A P T R O 2 \ S E N I C R D A T ' 
O R G A N I Z A T I O N 
I S L I N E 
S E Q U E N T I A L 
1 S E L E C T 
P R I NTL- PI L|E " " | 
, 
! 
| 
| 
, 
J I 
A S S I G N TO PRJMTEFT.. 
DATA 
D I V I S I O N 
! 
Fl L E S E C T I O N 
FD 
S T U D E N T - F I L E 
RECORD 
C O N T A I N S 
4 3 C H A R A C T E R S 
DATA- RECORD I S S T U D E N T - I N . 
i 
01 
$tu\>zhx-\h 
i 
05 
S T U - NAME 
P I C X U 5 ) 
I 
05 
S T U - C R E D I T S 
P I C 9(3) 
I 
05 
S T U - M A O O R 
P I C X(t 5) 
j 
FD 
P R I N T - F I L E 
I 
RECORD 
C O N T A I N S 
1 n 
C H A R A C T E R S 
1 
DATA 
R E C O R D I S P R I N T - L I N E 
I 
Ci 
P R I N T 
L I N E 
P I C X ( i 32-) 
I 
I 
! 
I 
j 
, 
[ 
1 
; 
1 
! 
I 

Chapter 
2 
From Coding 
Form to 
Computer 
(continued) 
Program S E N I O R 
Requested by 
Page 2 ol 5 
Programmer 
R O B E R T <3RAUER 
Date 9/10/93 
73 
Identification 
ao 
Sequence j | j A 
: q 
COBOL Statement 
t 3 \ A 6|7 j 8 
P 5t 
0 I 6 i 
M ' M
l
l
l
! ' 
' Picj X( I'O) 
1 
V 
X(1,Z) 
, A 
xcio) i 
WORkil NS-SfOR;A<JE S E C T I O N " 
! 
i0! 
DATA.-REMA I N S , - S W I T C H 
, P I C X(2') 
J 
1 i|i 1 
I 1 
' I 1 i 
1 I 
0 1 
HEAD|l NG-'L I NEj 
05 
'FILLER 
:;x, 
io f 
d e t a ' i l - l ' i n e 
1 
05 
F!l LLEIR 
1 
, P I C 
X(fl) 
X 
P;Ri NT - N A M E 
( 
, Y, 
X U 5 ) 
| 
A F i L L E,R 
( 
, A i X £ 9 9) 
' p r o c e d u r e 
D I V I S I O N 
' 
P R E P A R E - . S E N I O R - R ' E P O R T _ , 
OPtN 
i N P U T STUDE.Nl - F! LE 
; 
' O U T P U T PIRINT-Fi L E 
! 
R E A D S T U D E N T - F I L'E 
AT E'ND WOVE ' NO 
e n d - R e a d 
p e r f o r m w r l t e - h e , a d i n s - l i n e 
6B 72 
VALINE SPACES 
j 
1 
. 
i. I 
i 
r 
[ 
VALUE SPjACES' 
V 
1 SfTUDEjNT NAME' 
A 
SPACfeSf 
K ' i 
|VALtjE SPACES 
i V A l U E SP(ACES, 
TO IdATA - REMA i NS - Stw i TcH 
P E R F O R M 
C L O S 
S T O P 
UNT 
E STUDENT-FI 
PRlMT-FI LE 
RUN 
P R O C E S S 
L DA 
R E C O R D S 
T A - R E M A I 
L E 
N S - S W I T C H = 
1 HO' 
fj"" 
It 
early 1970s. COBOL itself is over 30 years old, and for m u c h of its existence the 
p u n c h e d card a n d batch processing (often with turnaround times of several hours 
or more) w a s the w a y in w h i c h programs were submitted. Students today are far 
m o r e fortunate in the available technology, taking for granted t h e ability to execute 
a program m a n y times in a single session, instead of having to wait hours (or days) 
to retrieve a single run, wait hours m o r e for the next run, etc. 
The material o n the c o d i n g sheet and u s e of an editor is straightforward, a n d should 
p o s e little difficulty. The execution of a COBOL program, however, is m o r e complex, 
and is explained in conjunction with Figure 2.3. The figure s h o w s the execution of 
three distinct programs, a compiler, 
linker 
(or linkage-editor o n IBM mainframes), 
and load module, e a c h of w h i c h is necessary to produce the list of engineering 
seniors. Realize, too, that the process described in Figure 2.3 is required for any 
COBOL program, e v e n o n e as simple as the engineering senior example. 

From 
Coding 
Form 
to 
Computer 
(continued) 
Program SENIOR 
Requested by 
Page 3 of 3 
Programme, ROBERT ^RACIER 
Date 9l\ 0/92> 
73 
Identification 
80 
Sequence |njA 
iR 
COBOL Statement 
WRi TE - tttAD i m - 1 I NE 
MOVE, HEAD INS-LINE TO PRINT-LINE 
WRITE 
PRINT-LINE 
PROCESS .RECORDS 
IF STU-CREDITS > I t 0 AND STU-MAJOR = ' ENGINEERING' 
MOVE STU-NAME TO PR I NT-NAME 
WOVE DETAIL-LINE TO PRINT-LINE 
WRITE 
PRINT-LINE 
END-;IF^_ 
READj STUDENT-F I LE 
END-READ ' 
i 
The procedure begins with the COBOL compiler, 
a program that accepts a 
COBOL (source) program as input, and produces a machine-language (object) 
program as output. The result of the compilation, the object program, is input into a 
second program called the linker, that combines the object program with subroutines 
and other object m o d u l e s to produce a load module. Execution of the compiled 
COBOL program takes place in the third step as the load module 
accepts input data 
and produces an output report. 
The execution of the various programs in Figure 2.3 does not h a p p e n through 
wishful thinking, but through specification of c o m m a n d s to the operating system to 
describe these programs and their associated data files. Every operating system has 
its o w n specific c o m m a n d s , but the underlying concept is the s a m e , namely that 
three different programs (a compiler, linker, and load module) are required. It will 
be necessary, therefore, to learn the c o m m a n d s for your particular configuration in 
order to compile, link, and execute a COBOL program.' 
1. Appendices A and B describe the Micro Focus Personal COBOL for Windows that may 
accompany this 
text. 

C
h
a
p
t
e
r 
2 - 
} torn 
Coding 
Form 
to 
Computer 
i n n 
Compile, Link, and Execute Sequence 
One learns by doing. This time-worn axiom is especially true for programming. We 
have covered a lot of material since you first b e g a n reading Chapter 1. N o w it is time 
to put everything together and actually run your first program. Enter the program 
on the coding sheets in Figure 2.2, using the appropriate editor. Prepare the necessary 
control statements for the operating system. Create your o w n test data, or use 
Figure 1.8a. Submit the job and retrieve your output. 
We believe—in fact w e are very sure—that after you receive your first computer 
printout, m a n y things will fall into place. Nevertheless, the first program is in many 
ways the most difficult you will attempt, and y o u should be prepared for problems 
along the way. The difficulty is not in the program's complexity (the engineering 
senior program is logically trivial). Nor is it in the COBOL syntax, in that the program 
uses only a fraction of the COBOL features you will eventually employ. The problems 
arise in interacting with the computer, using the editor, entering the proper 
c o m m a n d s to the operating system, and so on. Murphy's Law is perhaps the most 
eloquent statement of what to expect, and thus you should be prepared for any or 
all of the e n s u i n g errors. 

Learning 
by 
Doing 
The errors that occur as you enter the program are potentially the m o s t damaging, 
especially if you spend hours entering the program and then forget to save it, save it 
incorrectly, or delete it unintentionally. A suggested course of action for your first 
attempt is to enter only the first two lines of the program, save these, log off the 
system, then log o n and retrieve the file. In this way you are sure you k n o w h o w to 
use the editor. Other frequent errors are to enter information in the wrong columns, 
to misuse a tab key, and so on. 
The syntax of operating system c o m m a n d s has to be followed exactly, in order for 
the system to do your bidding. Simple mistakes result in baffling errors; for example, 
Bad command or file name, w h e n you misspell an MS-DOS c o m m a n d , a n d / o r fail 
to indicate the proper subdirectory where the c o m m a n d is located. In similar fashion 
the control statements submitted o n a mainframe must be syntactically correct, or 
everything else will fail. Invalid job streams result in the system being unable to 
execute the job, leaving you with the m o s t frustrating of all messages, Job not run 
due to JCL error. 
A compilation error occurs whenever you violate a rule of COBOL, for example, 
misspelling a reserved word or misplacing a period. The result of the error is that the 
compiler is unable to translate a portion of the COBOL program to machine language, 
and any subsequent attempt at execution will (most likely) b e incorrect. 
Consider, for example, Figure 2.4a, which contains a slightly modified version 
of the Engineering Senior Program of Figure 1.6, in which lines 5 9 - 6 4 have b e e n 
Engineering Senior Program with Compilation Errors 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
SENIORCE. 
3 
AUTHOR. 
ROBERT GRAUER. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT STUDENT-FILE 
ASSIGN TO 'A:\CHAPTER02\SENI0R.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD STUDENT-FILE 
16 
RECORD CONTAINS 43 CHARACTERS 
17 
DATA RECORD IS STUDENT-IN. 
18 
01 STUDENT-IN. 
19 
05 STU-NAME 
PIC X(25). 

C
h
a
p
t
e
r 
2 
From 
Coding 
Form 
to 
Computer 
Fit 
(continued) 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
5JL 
[59 
60 
61 
62 
63 
64 
65 
66 
67 
05 
05 
STU-CREDITS 
STU-MAJOR 
PIC 9(3). 
PIC X(15). 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
01 PRINT-LINE 
PIC X(132). 
WORKING-STORAGE SECTION. 
01 DATA-REMAINS-SWITCH 
PIC X(2) 
01 HEADING-LINE. 
05 FILLER 
P I C X(10) 
05 FILLER 
PIC X(12) 
05 FILLER 
PIC X(110) 
01 DETAIL-LINE. 
05 FILLER 
PIC X(8) 
05 PRINT-NAME 
P I C X(25). 
05 FILLER 
P I C X(99) 
VALUE SPACES. 
VALUE SPACES. 
VALUE 'STUDENT NAME' 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
PROCEDURE DIVISION. 
PREPARE-SENIOR-REPORT. 
OPEN INPUT 
STUDENT-FILE 
OUTPUT PRINT-FILE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PERFORM WRITE-HEADING-LINE. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
CLOSE STUDENT-FILE 
PRINT-FILE. 
STOP RUN. 
WRITE-HEADING-LINE. 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE. 
Period missing after paragraph header 
PROCESS-RECORDSr 
IF STU-CREDITS > 110 AND STU-MAJOR = 'ENGINEERING' 
MOVE STU-NAME TO PRINT-NAME 
MOVE DETAIL-LINE TO PRINT-LINE 
WRTE PRINT-LINE. 
END-IF. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
WRITE is misspelled 
Period does no! belong before END-IF terminator 
(a) COBOL Listing 

Learning 
by 
Doing 
Flgar 
(continued) 
LINE ERR# LVL • 
ERROR TEXT 
0138 W Period assumed before 'IF' 
0787 E Undefined symbol 'WRTE' 
0593 E No corresponding active scope for 'END-IF' 
seniorce has 
1 Warning + 
2 E Level 
messages 
changed to produce compilation errors. Figure 2.4b shows the resulting compiler 
diagnostics. The error message associated with line 60 is caused by the missing 
period (after the paragraph header) in line 59. The diagnostic in line 63 resulted 
from misspelling a reserved word, and the diagnostic in line 64 is produced by the 
superfluous period in line 63. 
Compiler diagnostics are discussed fully in Chapter 6. Corrections are made, 
and the program is recompiled. Only after the compilation has b e e n successfully 
completed should w e proceed to execution. 
Execution errors occur after compilation and are generally due to errors in logic. 
Figure 2.5a contains yet another version of the engineering senior program in 
which the credits test was deliberately omitted in line 60. The program is syntactically 
correct a n d will compile without error; it is, however, logically incorrect and hence 
the associated output in Figure 2.5b is wrong. (Review the original program 
specifications and test data; Alex Bell should not be selected because of an insufficient 
n u m b e r of credits.) 
.5 
Engineering Senior Program with Execution Errors 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
SENI0REE. 
3 
AUTHOR. 
ROBERT GRAUER. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR02\SENIOR.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 

C
h
a
p
t
e
r 
2 
From 
Coding 
Form 
to 
Compute 
Figure 
(continued) 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
FILE SECTION. 
FD STUDENT-FILE 
RECORD CONTAINS 43 CHARACTERS 
DATA RECORD IS STUDENT-IN. 
01 STUDENT-IN. 
05 
05 
05 
STU-NAME 
STU-CREDITS 
STU-MAJOR 
PIC X(25). 
PIC 9(3). 
PIC X(15). 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
01 
PRINT-LINE 
WORKING-STORAGE SECTION. 
01 
DATA-REMAINS-SWITCH 
01 HEADING-LINE. 
05 FILLER 
05 FILLER 
05 FILLER 
01 DETAIL-LINE. 
05 FILLER 
05 PRINT-NAME 
05 FILLER 
PIC X(132), 
PIC X(2) 
PIC X(10) 
PIC X(12) 
PIC X(110) 
PIC X(8) 
PIC X(25). 
PIC X(99) 
VALUE SPACES. 
VALUE SPACES. 
VALUE 'STUDENT NAME' 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
PROCEDURE DIVISION. 
PREPARE-SENIOR-REPORT. 
OPEN INPUT 
STUDENT-FILE 
OUTPUT PRINT-FILE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PERFORM WRITE-HEADING-L1NE. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
CLOSE STUDENT-FILE 
PRINT-FILE. 
STOP RUN. 
WRITE-HEADING-LINE. 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE. 
PROCESS-RECORDS. 
[IF STU-MAJOR = 'ENGINEERING' h 
MOVE STU-NAME TO PRINT-NAME 
MOVE DETAIL-LINE TO PRINT-LINE 
WRITE PRINT-LINE 

Learning 
by 
Doing 
64 
END-IF. 
65 
READ STUDENT-FILE 
66 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
67 
END-READ. 
STUDENT NAME 
ORVILLE WRIGHT 
ALEX BELL}--
JOHN ROEBLING 
It is important to remember, therefore, that a computer does exactly what it is 
instructed to do, which may be different from what you want it to do. In other words 
if you (incorrectly) tell the computer to ignore the credits test, then that is precisely 
what the program will do. 
A program may also produce erroneous output, even if it is logically correct, w h e n 
the data on which the program operates are invalid. If, for example, the erroneous 
data in Figure 2.6 are submitted to the valid program in Figure 2.2, neither Orville 
Wright nor John Roebling will be selected! Wright's major appears in the data as 
ENGINEER, w h e r e a s line 60 in the p r o g r a m is l o o k i n g for ENGINEERING. 
Roebling's credits are entered in the wrong column. In other words, a computer 
operates o n data exactly as it is submitted, with n o regard for its correctness. 
Stated another way, the output produced by a program is only as g o o d as its input, 
or put even more simply, garbage in, garbage out, giving rise to the well k n o w n 
acronym, GIGO. 
Erroneous Input Data 
JOHN ADAMS 
AMELIA EARHART 
ORVILLE WRIGHT 
GEORGIA 0'KEEFFE 
MERIWETHER LEWIS 
JOHN KENNEDY 
ALEX BELL 
EMILY DICKINSON 
JOHN ROEBLING 
090P0LITICAL SCI 
120AVIATI0N 
115gNGINEERj 
125ART 
115TRAVEL 
115P0LITICAL SCI 
090ENGINEERING 
085LITERATURE 
115ENGINEERING 

Chapter 
2 
From 
Coding 
Form 
to 
Computer 
COBOL was introduced in 1959 through the efforts of Captain Grace Murray Hopper 
of the United States Navy. It was designed to be an o p e n e n d e d language, capable of 
accepting change and a m e n d m e n t . It was also intended to b e a highly portable 
language; i.e., a COBOL program written for an IBM mainframe computer should 
run equally well o n any other computer with a COBOL compiler. Over the years the 
n e e d s of an evolving language, and the desire for compatibility a m o n g vendors 
have given rise to several COBOL standards, two of w h i c h are in c o m m o n u s e today, 
COBOL-74 and COBOL-85. 
All of the listings in this text are written to take advantage of features in the 
newest standard, COBOL-85. We think it important to emphasize COBOL-85 (de-
emphasize COBOL-74) because COBOL-85 has been the current standard for several 
years. Industry, however, is slow to change, and even as this book is written in 1993, 
m a n y (perhaps most) of industry's currently running COBOL programs adhere to 
COBOL-74. The reason for the slow conversion is the subtle incompatibilities 
that 
exist between the two compilers. In theory, a program written under the earlier 
compiler is s u p p o s e d to run without modification under the later compiler. In 
practice, however, this is not always the case. 
Consider, for example, the incompatibility brought about by the introduction 
of n e w features and associated n e w reserved words, words such as CONTENT, 
EVALUATE, FALSE, OTHER, TEST, and so on. A programmer writing under COBOL-
74 could logically have used any or all of these words as data n a m e s , which posed n o 
problem under the older compiler, but which produces n u m e r o u s compilation 
errors under COBOL-85. Thus, a blanket conversion by an installation of its hundreds 
(thousands, or tens of thousands) of COBOL programs, would prove disastrous, 
unless each program was manually checked for compatibility with the n e w standard. 
Many installations support both compilers, using COBOL-74 to maintain 
existing programs and COBOL-85 for n e w development. It is important, therefore, 
that y o u b e c o m e aware of the differences b e t w e e n the two standards. Accordingly, 
w e e n d most chapters with a section describing differences b e t w e e n the standards 
as they relate to the program discussed in that chapter. 
Figure 2.7 represents our final look at the engineering senior program as it 
would be i m p l e m e n t e d in COBOL-74. Note the following differences b e t w e e n this 
program and the COBOL-85 implementation of Figure 1.6: 
Engineering Senior Program (COBOL-74 Implementation) 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
SENI0R74. 
AUTHOR. 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
CON FIGURATION"SECTION'.'| 
SOURCE-COMPUTER. 
IBM-PC.' 
OBJECT-COMPUTER. 
IBM-PC. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
jlELECT'stUDlNl-FILEASSIGN f0 Ut-S-SYSIN. 
\ SELECT PRINT-FILE 
L 
ASSIGN TO UJ-S-SYSOUT. 
DATA DIVISION. 

Evolution 
of 
COBOL 
(continued) 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
FILE SECTION. 
FD STUDENT-FILE 
LABEL RECORDS ARE STANDARD 
RECORD CONTAINS 43 CHARACTERS 
DATA RECORD IS STUDENT-IN. 
01 STUDENT-IN. 
05 STU-NAME 
PIC X(25). 
05 STU-CREDITS 
PIC 9(3). 
05 STU-MAJOR 
PIC X(15) V 
FD PRINT-FILE 
1 LABEL RECORDS ARE STANDARD -" 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
01 PRINT-LINE 
PIC X(132). 
WORKING-STORAGE SECTION. 
01 DATA-REMAINS-SWITCH 
PIC X(2) 
01 HEADING-LINE. 
05 FILLER 
PIC X(10) 
05 FILLER 
PIC X(12) 
05 FILLER 
PIC X(110) 
01 DETAIL-LINE. 
05 FILLER 
PIC X(8) 
05 PRINT-NAME 
PIC X(25). 
05 FILLER 
PIC X(99) 
VALUE SPACES. 
VALUE SPACES. 
VALUE
 1 STUDENT NAME
1 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
PROCEDURE DIVISION. 
PREPARE-SENIOR-REPORT. 
OPEN INPUT STUDENT-FILE 
OUTPUT PRINT-FILE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH. 
PERFORM WRITE-HEADING-LINE. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
CLOSE STUDENT-FILE 
PRINT-FILE. 
STOP RUN. 
WRITE-HEADING-LINE. 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE. 
PROCESS-RECORDS. 
_ 
_ 
IFITU-CREDITS > lib AND~STU-MAJOR = 'ENGINEERING
1 
MOVE STU-NAME TO PRINT-NAME 
MOVE DETAIL-LINE TO PRINT-LINE 
WRITE PRINT-LINE. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH. 

C
h
a
p
t
e
r 2 
From 
Coding 
Form 
to 
Computer 
1. CO HO 1.-74 
r e q u i r e s 
a C O N F I G U R A T I O N 
S E C T I O N 
w i t h 
b o t h a 
auuiu^E-VjUiviruiEA anu an U D j E ^ i - ^ u i n r u i c n paiagiapn, LU mutuaie 
t h e c o m p u t e r o n w h i c h t h e p r o g r a m will c o m p i l e a n d e x e c u t e . T h e 
CONFIGURATION SECTION is optional in COBOL-85, and since these entries 
are treated as c o m m e n t s by the compiler, they are omitted in the COBOL-85 
listing. 
2. COBOL-74 requires the LABEL RECORDS clause in a file description to indicate 
whether standard, nonstandard, or n o labels are in effect. (A label contains 
information about a file such as the date it was created and the intended 
expiration date.) The clause is optional in COBOL-85 w h e r e its o m i s s i o n 
defaults to LABEL RECORDS ARE STANDARD. 
3. Scope terminators (END-IF and END-READ) are not permitted in COBOL-74 
and h e n c e d o not appear in Figure 2.7. Scope terminators are optional in 
COBOL-85, but are used throughout the text because of advantages that will 
be clearly explained in Chapter 7. 
Despite these differences the COBOL-74 implementation of the engineering senior 
program is upward compatible with COBOL-85; that is, the program in Figure 2.7 
will run without modification under the n e w compiler. The converse is not true; the 
COBOL-85 listing in Figure 1.6 will not run under the earlier standard. 
X
i
i 
tk\ V liVsi 
We expect that you c o m p l e t e d the chapter with little difficulty and that you were 
A 
"« 
able to successfully run the engineering senior program. There will be times, however, 
w h e n not everything will go as smoothly and s o w e relate a favorite anecdote 
("Mystery of the Month," PC World Magazine, April 1983) that is as relevant today as 
w h e n it was written. As y o u read our tale, r e m e m b e r that a c o m p u t e r does exactly 
what y o u tell it to do, w h i c h is not necessarily what y o u want it to do. It is a source of 
wonderful satisfaction w h e n everything works, but also t h e cause of nearly 
unbelievable frustration w h e n results are not what y o u expect. 
Our story concerns a manager w h o purchased a PC a n d began to use it 
enthusiastically. Unfortunately, the feeling did not rub off on his assistant, w h o w a s 
apprehensive of c o m p u t e r s in general, but w h o finally agreed to try the n e w 
technology. 
As is frequently the case, the assistant's experience with the computer w a s as 
frustrating as the manager's w a s rewarding. Every time the assistant tried using the 
c o m p u t e r a n error m e s s a g e appeared, yet w h e n the m a n a g e r tried the s a m e 
procedure it worked fine. Finally, manager and assistant went through a systematic 
comparison of everything they did: turning the m a c h i n e o n and off, handling disks, 
using the keyboard, etc. They could find no difference in their procedures and could 
not account for the repeated disk errors which plagued the assistant but left the 
manager alone. 
Just as they were about to give up the manager noticed that his assistant 
w a s wearing a charm bracelet. H e looked closely, and sure e n o u g h o n e of the 
charms was a tiny m a g n e t containing just e n o u g h force to interfere with reading 
the disk. The assistant stored the bracelet in a drawer and the m a c h i n e has b e e n 
fine ever since. 
The point of our story is that there is always a logical reason for everything a 
computer d o e s or d o e s not do, although discovering that reason m a y be less than 
obvious. You are about to embark o n a wonderful journey toward the productive 
use of a computer, with a virtually unlimited n u m b e r of potential applications. Be 
patient, b e inquisitive, and enjoy. 

The A margin consists of columns 8-11 whereas the B margin is defined as 
columns 12-72. Division and section headers, paragraph names, FD's, 
and 01-level entries must begin in the A margin; all other entries begin in 
the B margin (that is, in or past column 12). 
The execution of a COBOL program is a three part process, involving three 
distinct programs—a compiler, a linker, and the resultant load module. The 
means of communicating information about these programs (and their 
associated files) is dependent on the operating system. 
A compiler is a computer program that translates a higher-level (problem-
oriented) language such as COBOL into machine language; the input to a 
compiler is referred to as a source program, whereas the output is an 
object program. 
The linker combines the output produced by the compiler, with additional 
object modules (such as subroutines and/or Input/Output modules) to 
produce a load module. 
Execution of the COBOL program occurs when the load module processes 
the input file(s) to produce the required reports. 
COBOL-74 is intended to be upward compatible with COBOL-85 although 
subtle incompatibilities do exist between the two standards. The converse 
is not true, as COBOL-85 programs will not run under the earlier standard.  
A margin 
ASCII file 
B margin 
COBOL-74 
COBOL-85 
Debugging 
Editor 
Execution error 
GIGO 
Incompatibility 
Load module 
Object program 
Operating system 
Source, program 
Test data 
Coding form 
Comments 
Compilation error 
Compiler 
Continuation 
A 
language. 
translates a 
language into an 
2. 
is the most recently approved COBOL standard, but 
is still widely used in industry. 

C
h
a
p
t
e
r 
2 
from 
Coding 
Form 
to 
Computer 
3. The 
is in columns 8 to 11 of the coding sheet. 
4. A comment is indicated by an 
in column 
. 
5. Entries that are not required to begin in the A margin may begin anywhere in 
columns 
to 
__. 
6. Division headers and paragraph names must begin in the 
. 
7. An 
is used to enter programs into the computer. 
8. The compile, link, and execute process requires the execution of 
distinct programs. 
9. 
is the process of finding and correcting errors in a program. 
10. Picture clauses may begin anywhere within the 
margin. 
11. The output of compilation is input to a second program called the 
. 
12. A clean compile (does/does not) guarantee that the resulting program execution 
will be correct. 
13. Different mainframe computers will most likely use (different/identical) COBOL 
compilers. 
14. Misspelling a reserved word wili result in a 
error. 
15. Entering test data in the wrong columns will result in an 
error. 
TRUE/FALSE 
1. A compiler translates a machine-oriented language into a problem-oriented 
language. 
2. A well-written program will always produce correct results, even with bad data. 
3. A compiler is a computer program. 
4. The COBOL compiler for an IBM mainframe is identical to the compiler for a PC. 
5. A COBOL program can run on a variety of computers. 
6. Division headers must begin in the A margin. 
7. Division headers must begin in column 8. 
8. Section headers must begin in column 12. 
9. Paragraph names must begin in column 8. 
10. PICTURE clauses may appear in column 12 or after. 
11. If a program compiles correctly, then it must execute correctly. 
12. Columns 1-6 are never used on the coding sheet. 
13. The use of columns 73-80 is optional. 
14. Column 8 is used as a continuation column. 
15. All editors have identical commands. 
16. All computers use the same operating system. 
17. Successful execution of the COBOL compiler produces a load module. 

Problems 
PROBLEMS 
1. Figure 2.8a contains data for the COBOL program in Figure 2.8b, which will 
process a file of employee records and print the names of all programmers 
under 30. 
"igure 2.8 
COBOL Program and Associated Data for Problems 1 & 2 
WALT BECHTEL 
NELSON KERBEL 
MARGOT HUMMER 
CATHY BENWAY 
JUD MCDONALD 
JACKIE CLARK 
LOUIS NORIEGA 
JEFF SHEESLEY 
PR0GRAMMER34 
PR0GRAMMER23 
PR0GRAMMER30 
DATA BASE 23 
DATA BASE 29 
PR0GRAMMER22 
PROGRAMER 24 
ANALYST 28 
39700 
30000 
45000 
50000 
55000 
47500 
42500 
46400 
(a) Data 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. FIRSTTRY. 
3 
AUTHOR. 
GRAUER. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT EMPLOYEE-FILE ASSIGN TO 'A:\CHAPTR02\FIRSTTRY.DAT 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD EMPLOYEE-FILE 
16 
RECORD CONTAINS 44 CHARACTERS 
17 
DATA RECORD IS EMPLOYEE-RECORD. 
18 
01 EMPLOYEE-RECORD. 
19 
05 EMP-NAME 
PIC X(25). 
20 
05 EMP-TITLE 
PIC X(10). 
21 
05 EMP-AGE 
PIC 99. 
22 
05 FILLER 
PIC XX. 
23 
05 EMP-SALARY 
PIC 9(5). 
24 
25 
FD PRINT-FILE 
26 
RECORD CONTAINS 132 CHARACTERS 
27 
DATA RECORD IS PRINT-LINE. 
28 
01 PRINT-LINE. 

C
h
a
p
t
e
r 
2 
From 
Coding 
Form 
to 
Computer 
Igure 2 , 8 
(continued) 
29 
05 
FILLER 
P I C X. 
30 
05 PRINT-NAME 
P I C X ( 2 5 ) . 
31 
05 
F I L L E R 
P I C X(2). 
32 
05 
P R I N T - A G E 
P I C 99. 
33 
05 
F I L L E R 
P I C X ( 3 ) . 
34 
05 
PRINT-SALARY 
P I C 9(5). 
35 
05 FILLER 
P I C X(94). 
36 
37 
W O R K I N G - S T O R A G E SECTION. 
38 
01 
END-OF-DATA-FLAG 
P I C X(3) 
V A L U E SPACES. 
39 
P R O C E D U R E D I V I S I O N . 
40 
PREPARE-PROGRAMMER-REPORT. 
41 
O P E N INPUT E M P L O Y E E - F I L E 
42 
O U T P U T PRINT-FILE. 
43 
M O V E SPACES T O PRINT-LINE. 
44 
M O V E 'SALARY REPORT F O R PROGRAMMERS U N D E R 30' T O PRINT-LINE. 
45 
W R I T E P R I N T - L I N E 
46 
A F T E R A D V A N C I N G 2 LINES. 
47 
READ E M P L O Y E E - F I L E 
48 
A T END M O V E 'YES' TO END-OF-DATA-FLAG 
49 
END-READ. 
50 
PERFORM 
PROCESS-EMPLOYEE-RECORDS 
51 
U N T I L END-OF-DATA-FLAG = 'YES'. 
52 
C L O S E E M P L O Y E E - F I L E 
53 
PRINT-FILE. 
54 
STOP R U N . 
55 
56 
PROCESS-EMPLOYEE-RECORDS. 
57 
I F EMP-TITLE = 'PROGRAMMER' A N D E M P - A G E < 30 
58 
M O V E S P A C E S T O P R I N T - L I N E 
59 
M O V E EMP-NAME T O P R I N T - N A M E 
60 
M O V E E M P - A G E T O P R I N T - A G E 
61 
M O V E EMP-SALARY T O PRINT-SALARY 
62 
W R I T E P R I N T - L I N E 
63 
END-IF. 
64 
READ E M P L O Y E E - F I L E 
65 
A T END M O V E 'YES' T O END-OF-DATA-FLAG 
66 
END-READ. 
(b) COBOL Program 
a. Compile, link, and execute the COBOL program, using the appropriate commands 
for your system. (The program is on the data disk that accompanies this book.) 
b. Are any potential problems introduced by checking age rather than date of 
birth? 
c. Would processing be simplified if the employee records contained an abbreviated 
title code (for example, 010) rather than an expanded title (for example, 
programmer)? Are there any other advantages to storing codes rather than 
expanded values? 

2. Modify the program in Figure 2.8b to accommodate all of the following. 
a. Employee age is stored in positions 38 and 39 of the incoming record. 
b. The report should list all employees under age 30 who earn at least $30,000, 
regardless of title. 
c. The report should include the title of all selected employees in positions 41-52. 
3. Match each item with its proper description. 
An asterisk in column 7 
First line of any COBOL program 
Often appears in data names 
Columns 12 through 72 
Contains the logic of a program 
Limited to 160 characters, and 
enclosed in quotes or apostrophes 
Where division, section, and 
paragraph headers begin 
Translates COBOL to machine 
language 
Preassigned meaning 
A constant; may be numeric or 
nonnumeric 
4. Indicate the starting column (or columns) for each of the following. 
a. Division headers 
b. Comments 
c. Paragraph names 
d. Statements in the Procedure Division (except paragraph names) 
e. WORKING-STORAGE SECTION 
f. FD 
g. 01 entries 
h. 05 entries 
i. PICTURE clauses 
j. OPEN statement 
k. WRITE statement 
I. SELECT statement 
5. Explain how it is possible for a program) to compile perfectly, be logically correct, 
and still produce invalid results; provide specific examples in conjunction with the 
engineering senior program. 
1. A Margin 
a. 
2. B Margin 
b. 
3. Comment 
c. 
4. IDENTIFICATION DIVISION 
d. 
5. PROCEDURE DIVISION 
e. 
6. Hyphen 
f. 
7. Nonnumeric literal 
g-
8. Reserved word 
h. 
9. Compiler 
i. 
10. Literal 
i 
j-


Overview 
T h e Tuition Billing Problem 
S t r u c t u r e d D e s i g n 
Evaluating t h e Hierarchy Chart 
Completeness 
Functionality 
Span of Control 
S t r u c t u r e d 
Programming 
Sufficiency of the Basic Structures 
E x p r e s s i n g L o g i c 
The Traditional Flowchart 
Pseudocode 
Wamier-Orr Diagrams 
Top-Down T e s t i n g 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
3 — 
A Methodology 
tor 
Program 
Development 
After reading this chapter you will be able to: 
Describe how a hierarchy chart is developed; discuss three criteria for 
evaluating a completed hierarchy chart. 
Define structured programming; describe its three fundamental building 
blocks and an optional extension. 
Explain the one entry point/one exit point philosophy of structured 
programming. 
Differentiate between structured programming and structured design; 
distinguish between a functionally oriented technique and one that is 
procedurally oriented. 
Describe what is meant by top down design and implementation. 
We stated at the outset that programming is best learned by doing, and so our 
objective in the first two chapters was to put you on the computer as quickly as 
possible. Thus, we jumped immediately into COBOL, without giving much thought 
to the underlying logic of the program you developed. While that approach 
works well initially, it is also important for you to learn how to properly design 
programs, so that they will work correctly, and further so that they can be easily 
read and maintained by someone other than yourself. 
Accordingly, this chapter presents a methodology for program development, 
embracing the techniques of structured design, structured programming, and 
top down testing. We stress that structured design is functionally oriented and 
describes what is to be accomplished; structured programming, on the other 
hand, is procedurally oriented and focuses on how the objectives of the program 
will be realized. The discussion includes hierarchy charts, pseudocode, 
flowcharts, and Warnier-Orr diagrams. 
The presentation is of a practical nature, and stresses application rather 
than theory. Accordingly, we introduce a new program at the beginning of the 
chapter, and develop the methodology in the context of that program. We begin 
with presentation of the program specifications. 
This section contains the specifications for a n e w problem, k n o w n simply as the 
tuition billing program. The requirements are straightforward a n d parallel those of 
m a n y other COBOL programs, namely to print a heading line(s) at the start of 
processing, o n e or more detail lines for every record processed, a n d a total line(s) at 
the e n d of processing. As simple as these specifications m a y be, it is critical that you 
avoid the temptation to rash immediately into COBOL, and concentrate instead o n 
designing the program y o u will eventually write. 

The 
Tuition 
Billing 
Problem 
P r o g r a m N a m e : 
N a r r a t i v e : 
Input File(s): 
T e s t D a t a : 
R e p o r t L a y o u t : 
P r o c e s s i n g R e q u i r e m e n t s : 
The approach w e follow begins with a determination of the m o s t general 
smaller pieces, until the requirements of each piece are clearly recognized. Initially 
the design process m a y s e e m superfluous in that you are confident of your ability 
to begin coding immediately. Rest assured, however, that design is productive 
work, and d o e s in fact pay dividends in the long run. A well-designed program is 
far more likely to be correct than o n e written off-the-cuff. Moreover, and this 
may be the argument that m o s t appeals to you, a well-designed program will 
ultimately be c o m p l e t e d in less time than one that is poorly designed or o n e that 
has no design at all. 
R A M M I N G 
S P E C I F I C A T I O N S 
Tuition Billing Program 
This program processes a file of student records, computes and prints the tuition bill for 
each student, and prints the total amounts for all students. 
STUDENT-FILE 
See Figure 3.1a 
SMITH 
JB15Y0000230 
JAMES 
HR15 0500245 
BAKER 
bKuy ubuujsu 
PART-TIMER 
JR03Y0000300 
JONES 
PL15Y0000280 
HEAVYWORKER 
HM18 0000200 
LEE 
BL18 0000335 
CLARK 
JC06 0000310 
GROSSMAN 
SE07 0000215 
FRANKEL 
LF10 0000350 
BENWAY 
CT03 0250395 
KERBEL 
NB04 0000100 
See Figure 3.1b 
1. Print a suitable heading at the beginning of the report. 
2. Read a file of student records. 
3. Process each record read by: 
a. Computing an individual bill, equal to the sum of tuition, union fee, and activity fee, 
minus a scholarship (if any), by: 
i. Calculating the tuition due, at a rate of $200 per credit. 
ii. Billing the student $25 for the union fee, if there is a "Y" in the Union Member 
position. 
iii. Computing the activity fee based on the number of credits taken: 
ACTIVITY FEE 
CREDITS 
$25 
6 or fewer 
$50 
$75 
7 - 12 
more than 12 

C
h
a
p
t
e
r 
3 — 
A 
Methodology 
for 
Program 
Development 
Record Layouts for Tuition Billing Program 
CREDITS 
UNION MEMBER 
INITIALS 
SCHOLARSHIP 
S T U D E N T N A M E 
GPA 
LAST 
GPA 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19 20 21 22 23 24 25
v26 27 
(a) Input Record Layout 
STUDENT 
NAME 
XXXXXXXX 
XXXXXXXX 
C R E D I T S 
T U I T I O N 
UNION 
F E E 
ACT 
F E E 
S C H O L A R S H I P 
TOTAL 
XXXXXXX 
X 
XXXXXXX 
X 
U N I V E R S I T Y 
$$9 
$$9 
$ $ $ , $ $ 9 
(b) Report forma! 
$ , $ 
$,$S9 
$9 
$$ 
B I L L 
,$$9 
,$59 
$ $ $ , $ $ 9 
$ $ $ $ , $ $ 9 
iv. Awarding a scholarship equal to the amount in the incoming record if, and only 
if, the GPA is greater than 2.5. (Observe that in the test data on the previous 
page James does not qualify for the $500 scholarship he would otherwise have 
been awarded.) 
v. Incrementing the university totals for tuition, union fee, activity fee, scholarship, 
and overall total. 
b. Printing a detail line for each record read. 
4. Print a total line at the end of the report. 
Structured 
design 
identifies the tasks a program is to accomplish, then relates those 
tasks to o n e another in a hierarchy chart. 
Figure 3.2 contains a very basic example, 
applicable to a n y COBOL program. The hierarchy chart divides the program into 
its functional c o m p o n e n t s , for example, initialization, processing, and termination, 

Structured 
Design 
and indicates the manager/subordinate relationships b e t w e e n these c o m p o n e n t s . 
In this example all three modules are subordinate to the m o d u l e labeled any 
COBOL program. 
To better appreciate the significance of a hierarchy chart and its role in program 
development, consider Figure 3.3, depicting the hierarchy chart for the tuition 
billing program. The development takes place in stages, beginning at the top and 
working d o w n to the bottom. At every level, the major function(s) are subdivided 
into other functions that are placed on the next lower level in the hierarchy chart. 
Those functions are in turn further subdivided into still other functions, until finally 
the lowest-level functions cannot be further subdivided. 
The specifications for the tuition billing problem suggest a suitable n a m e 
for the highest-level module, PREPARE-TUITION-REPORT. This in turn is divided 
into its basic functions of initialization (consisting of WRITE-HEADING-LINE and 
R E A D - S T U D E N T - F I L E ) , p r o c e s s i n g ( P R O C E S S - S T U D E N T - R E C O R D ) , 
a n d 
termination (WRITE-UNIVERSITY-TOTALS). Levels 1 and 2 of the hierarchy chart 
are s h o w n in Figure 3.3a. 
Of these four modules, only one, PROCESS-STUDENT-RECORD, needs to be 
subdivided. In other words ask yourself which additional lower-level functions 
should be included under PROCESS-STUDENT-RECORD in order to process 
individual student records. The program specifications contain the requirement to 
c o m p u t e the individual's bill, increment the university totals to include the a m o u n t 
just computed, and write a detail line for the particular student. Each of these tasks 
requires its o w n m o d u l e as indicated in Figure 3.3b. 
In addition, PROCESS-
STUDENT-RECORD must also read the next record so that the program can continue. 
(The m o d u l e READ-STUDENT-FILE appears twice in the hierarchy chart; o n level 
two to read the first record and on level three to read all subsequent records. The 
necessity for the dual appearance stems from a limitation in COBOL-74 rather than 
a requirement of structured design). 
The d e v e l o p m e n t of a hierarchy chart continues until its lowest-level modules 
cannot be further subdivided, that is, until the designer believes they can be easily 
translated into programming statements. The decision is subjective in that there is 
n o single correct answer; you could, for example, stop at three levels or continue to 
a fourth level as in Figure 3.3c. We chose to divide COMPUTE-INDIVIDUAL-BILL 
into four additional m o d u l e s : COMPUTE-TUITION, COMPUTE-UNION-FEE, 
COMPUTE-ACTIVITY-FEE, and COMPUTE-SCHOLARSHIP. 
The hierarchy chart is n o w complete and consists of four levels, each of 
which will correspond to a PERFORM statement in the eventual COBOL program; 
Figure 3-2 
Overall COBOL Hierarchy Chart 
ANY COBOL 
PROGRAM 
INITIALIZATION 
PROCESSING 
TERMINATION 

C
h
a
p
t
e
r 
3 — 
A 
Methodology 
for 
Program 
Development 
.3 
Hierarchy Chart for Tuition Billing Program 
1st Level 
2nd Level Processing 
Requirements 
1. Print a heading line 
2. Read student 
3. Process each record 
4. Print a total line 
PREPARE 
TUITION 
REPORT 
WRITE 
HEADING 
LINE 
READ 
STUDENT 
FILE 
PROCESS 
STUDENT 
RECORD 
WRITE 
UNIVERSITY 
TOTALS 
PREPARE 
TUITION 
REPORT 
WRITE 
HEADING 
LINE 
READ 
STUDENT 
FILE 
otu t-evet nuuessifiy 
Requirements 
3a) Compute individual bill 
3a) Increment totals 
3a) Write a detail line 
3a) Read a student record 
PROCESS 
STUDENT 
RECORD 
WRITE 
UNIVERSITY 
TOTALS 
COMPUTE 
INDIVIDUAL BILL 
INCREMENT 
UNIVERSITY 
TOTALS 
WRITE 
DETAIL 
LINE 
w 
r 
READ 
STUDENT 
FILE 
that is, the m o d u l e (paragraph) o n level one will perform the m o d u l e s (paragraphs) 
o n level two, those o n level two will perform the m o d u l e s o n level three, and so 
on. The hierarchy chart d o e s not specify h o w often these paragraphs will be called, 
nor d o e s it indicate the conditions for calling o n e subordinate in lieu of another. 
In other words, the hierarchy chart indicates only w h a t functions are necessary, 
but not w h e n they are executed. It contains n o decision-making logic, nor does it 
imply anything about the order or frequency in w h i c h various paragraphs within 
a program are executed. That, in turn, is specified within the logic of the program, 
developed according to the discipline of structured p r o g r a m m i n g as discussed 
later in the chapter. 
' _<„ 
As w e have already indicated, the decision of h o w m a n y m o d u l e s to include in a 
i * & X 
L, *' G>< > l ^ L L 
hierarchy chart a n d h o w they s h o u l d b e related to o n e another is necessarily 
subjective. Nevertheless, there are certain evaluation criteria that result in selecting 
o n e design over another. A m o n g these are the following: 

Evaluating 
the 
Hierarchy 
Chart 
Figure 3.3 
(continued) 
PREPARE 
TUITION 
REPORT 
WRITE 
HEADING 
LINE 
READ 
STUDENT 
FILE 
PROCESS 
STUDENT 
RECORD 
WRITE 
UNIVERSITY 
TOTALS 
COMPUTE 
INDIVIDUAL 
BILL 
INCREMENT 
UNIVERSITY 
TOTALS 
COMPUTE 
TUITION 
READ 
STUDENT 
FILE 
COMPUTE 
UNION FEE 
COMPUTE 
ACTIVITY 
FEE 
COMPUTE 
SCHOLARSHIP 
4th Level Processing 
Requirements 
3a(1) Compute tuition 
3a(2i Compute union fee 
3a 3 Compute activity tee 
3a(4) Compute scholarship 
(c) Complete Hierarchy Chart (Levels 1-4} 
1. Is the hierarchy chart complete? 
2. Are the m o d u l e s functional? 
3. Is there effective span of control? 
Completeness 
A hierarchy chart must b e complete; that is, it h a s to provide for every function 
required by the program as specified in the programming specifications. You test 
for c o m p l e t e n e s s level by level, starting at the top of the hierarchy chart, a n d 
working your w a y down, o n e level at a time, b y asking the question, "Do the 
subordinate m o d u l e s at the next level completely develop their corresponding 
m o d u l e s at this level?" If the answer is yes, m o v e to the next m o d u l e o n the present 
level, or to the first m o d u l e o n the next level, and repeat the question. If the answer 
is no, add functions as necessary and continue to the next module. 
For example, begin with the completed hierarchy chart of Figure 3.3c and ask 
yourself whether the m o d u l e s o n level two are adequate to expand the single m o d u l e 
of level one; that is, do the four modules o n level two completely expand the 
PREPARE-TU1TION-REPORT module to which they are subordinate? The answer is 
yes, so y o u m o v e to level three and see whether the m o d u l e s o n this level adequately 
expand the PROCESS-STUDENT-RECORD m o d u l e from level two. O n c e again the 
answer is yes, a n d so y o u progress to level four. The process c o n t i n u e s until y o u 
have checked every m o d u l e o n every level a n d are satisfied that all necessary 
functions are included. 

C
h
a
o
t
o
r 
3 
' 
t h o d o l o g y 
tor 
Program 
Development 
Functionality 
, 
Every m o d u l e in a hierarchy chart should be dedicated to a single function, the 
nature of w h i c h should b e clear from examining the module's n a m e . Each of the 
m o d u l e n a m e s in Figure 3.3 consists of a verb, adjective (or two), and an object—for 
example, COMPUTE-INDIVIDUAL-BILL or WRITE-DETAIL-LINE. Indeed, if a 
m o d u l e cannot be n a m e d in this way, its function is probably n o t well defined and 
thought should be given to revising the hierarchy chart. 
Stated another way, y o u should reject (or redesign) any m o d u l e that d o e s not 
appear to b e functional; that is, m o d u l e s w h o s e n a m e s contain: 
1. More than o n e verb—for example, READ-AND-WRITE. 
2. More than o n e object—for example, EI) IT-NAM E-AND-ACCOU NT-DATA. 
3. Nondescriptive or time-related terms—for example, HOUSEKEEPING, 
TERMINATION-ROUTINE, INITIALIZATION, or MAINLINE. 
Another w a y of expressing the need for functional m o d u l e s is to strive for 
m o d u l e independence; that is, the internal workings of o n e m o d u l e should not 
affect those of another. Perhaps y o u have already b e e n associated with a working 
program in which changes were implemented, only to have s o m e other, apparently 
unrelated, portion of the program n o longer work properly. T h e problem m a y b e 
due to paragraphs in the program being unnecessarily dependent o n one another. 
What w e are saying is that in an ideal situation, changes m a d e to one paragraph 
should not affect the results of any other. In a more practical sense, the paragraphs 
have to be somewhat related, otherwise they would not be parts of the same program; 
however, the a m o u n t of interdependence b e t w e e n paragraphs should be minimized 
to the greatest extent possible. With respect to Figure 3.3, for example, a change in 
the procedure for c o m p u t i n g the union fee should not affect h o w the activity fee is 
determined. That is because the m o d u l e s COMPUTE-UNION-FEE and COMPUTE-
ACTIVITY-FEE are functional in their o w n right, and consequently are i n d e p e n d e n t 
of o n e another. 
Span ©f Control 
_ „ 
_ 
The span 
of control 
of a m o d u l e is the n u m b e r of subordinates it contains. In 
Figure 3.3, for example, the span of control of both PREPARE-TUITION-REPORT 
and COMPUTE-INDIVIDUAL-BILL is four. An effective span of control (for hierarchy 
charts associated with COBOL programs) is generally from t w o or three to seven, 
although that m a y vary d e p e n d i n g o n the situation. You should, however, avoid 
extremes in either direction. Programs with ineffective spans of control (too m a n y 
subordinates or too few) are poorly designed and difficult to follow and/or maintain. 
Structured 
Let us pause for a m o m e n t to s e e what has b e e n accomplished. W e have taken the 
Pl»Qgi>gr|irf)Jng 
original problem and divided it into a series of manageable pieces, each of w h i c h 
describes a particular job that n e e d s to be accomplished. In other words, w e have 
said what n e e d s to be d o n e to solve the problem, but have not as yet said h o w w e 
will solve it. That in e s s e n c e is the difference b e t w e e n structured design and 
structured programming. 
A structured program is o n e consisting entirely of three types of logic structures: 
sequence, selection (a decision), and iteration (a loop). The fact that these structures 

Structured 
Programming 
(or basic building blocks) are sufficient to express any desired logic w a s first 
postulated in a now-classic paper by B o h m and Jacopini.
1 
The elementary building blocks of structured programming are s h o w n in 
flowchart form in Figure 3.4. Flowcharts use special symbols to c o m m u n i c a t e 
information. A rectangle indicates a processing statement, a d i a m o n d indicates a 
decision, and a small circle c o n n e c t s portions of the flowchart. All of the flowcharts 
have o n e key feature in c o m m o n , namely, a single entry point and a single exit 
point, that is, there is only o n e w a y to enter each structure and only o n e w a y to 
leave. 
The sequence 
structure in Figure 3.4a specifies that the program statements 
are executed sequentially, in the order in w h i c h they appear. The two blocks, A and 
B, m a y d e n o t e anything from single statements to c o m p l e t e programs, and it is 
clear that there is a single entry point and a single exit point to the structure. 
1 Bohm and Jacopini, "Flow Diagrams, Turing Machines and Languages with Only Two Formation 
Rules," Communications of the ACM (May 1966). 
The Building Blocks of Structured Programming 
(c) Iteration 
(d) Case 

C
h
a
p
t
e
r 
3 — A Methodology 
for 
Program 
Development 
The selection 
(or IF . . . THEN . . . ELSE) structure in Figure 3.4b specifies a 
choice between t w o actions. A condition is tested with o n e of two o u t c o m e s ; if 
the condition is true, block A is executed, while if it is false, block B is executed. 
The condition itself is the single entry point, and both paths m e e t to form a single 
exit point. 
The iteration 
(or D O . . . WHILE) structure in Figure 3.4c specifies repeated 
execution of o n e or m o r e statements while a condition is true. A condition is tested 
and, if it is true, block A is executed after w h i c h the condition is retested. If, however, 
the condition is false, control passes to the next sequential statement after the 
iteration structure. Again, there is a single entry point a n d a single exit point from 
the structure. 
The case structure 
in Figure 3.4d expresses a multibranch situation. Although 
case is actually a special instance of selection, it is convenient to extend the definition 
of structured programming to include this fourth type of building block. The case 
structure evaluates a condition and branches to o n e of several paths, d e p e n d i n g o n 
the value of the condition. As with the other building blocks, there is o n e entry point 
and o n e exit point. 
ffficiency of the Basic Structures 
The theory of structured programming says simply that an appropriate combination 
of the basic building blocks may be derived to solve any problem. This is possible 
b e c a u s e a n entire structure ( s e q u e n c e , selection, iteration, or case) m a y b e 
substituted anywhere block A or B appears. Figure 3.5 s h o w s a c o m b i n a t i o n of the 
basic structures to illustrate this concept. 
Figure 3.5 is essentially a selection structure. However, instead of specifying a 
single statement for the true or false branches, as w a s d o n e in Figure 3.4, a complete 
building block is u s e d instead. Thus, if condition-1 is true, an iteration structure is 
entered, whereas, if it is false, a s e q u e n c e structure is executed. Both the iteration 
and s e q u e n c e structures m e e t at a single exit point w h i c h b e c o m e s the exit point for 
the initial selection structure. 
Figure 3.5 
Sufficiency of the B a s i c Structures 
FALSE 
TRUE 
J 
A 
1 
B 
FALSE 
Sequence Structure 
TRUE 
Iteration Structure 

We n o w turn our attention to ways in w h i c h programmers express logic, to 
themselves and to others. We begin with the traditional flowchart, then m o v e to 
n e w e r t e c h n i q u e s m o r e c l o s e l y a s s o c i a t e d w i t h structured 
p r o g r a m m i n g : 
p s e u d o c o d e a n d Warnier-Orr diagrams. 
Every programmer is familiar with the traditional flowchart's 
described in Chapter 1. 
Although flowcharts have declined in popularity, they remain in widespread use, 
primarily for documentation. Our personal preference is to use pseudocode, but w e 
include Figure 3.6 for completeness. The decision as to which technique to u s e is 
b e t w e e n y o u and your instructor. 
The fact that m o s t programmers write simple notes to themselves prior to coding 
a program gave rise to pseudocode, a technique associated with structured 
programming. As w e indicated in Chapter 1, pseudocode is defined simply as neat 
notes to yourself, and uses statements similar to computer instructions to describe 
logic. Figure 3.7 represents the building blocks of structured programming as they 
would be written in p s e u d o c o d e and corresponds to the 
flowcharts 
s h o w n in 
Figure 3.4. 
Pseudocode c o m e s into play after the design phase of a program has b e e n 
nature a n d indicates what has to b e done, but not necessarily when or how. 
Pseudocode, o n the other hand, is procedural and contains sequence a n d decision­
making logic. In other words, p s e u d o c o d e connects the m o d u l e s i n a hierarchy 
chart through loops and decision making. 
To better appreciate h o w p s e u d o c o d e expresses programming logic, consider 
Figure 3.8, w h i c h contains p s e u d o c o d e for the tuition billing program. T w o versions 
of the p s e u d o c o d e are presented—an initial attempt in Figure 3.8a, a n d a n expanded 
(more detailed) version in Figure 3.8b. Both versions are equally appropriate, with 
the choice b e t w e e n them d e p e n d i n g entirely o n the individual, a n d the level of 
detail he or s h e desires. 
The logic is straightforward a n d begins with the steps for initialization; to 
o p e n files, write a heading line(s), and read the first record. Then, a l o o p (or iteration 
structure) is entered in w h i c h the program c o m p u t e s the student's bill (tuition plus 
union a n d activity fees m i n u s scholarship), increments the university totals to 
include this amount, writes a detail line, and finally reads the next student record. 
The statements in the loop are executed continually until all the records have b e e n 
read, at w h i c h point university totals are written, a n d the program terminates. 
P s e u d o c o d e h a s a distinct block structure that is conducive to structured 
programming. It is not, however, b o u n d by formal syntactical rules (although s o m e 
organizations have i m p l e m e n t e d standards), n o r d o e s it have specific rules of 
indentation, which is d o n e strictly at the programmer's discretion. Its only limitation 
is a restriction to the building blocks of structured programming (sequence, selection, 
iteration, and case). 
With practice, p s e u d o c o d e c a n b e d e v e l o p e d quickly a n d easily. G o o d 
p s e u d o c o d e should b e sufficiently precise to b e a real aid in writing a program, 
while informal e n o u g h to b e understood b y nonprogrammers. The informality of 

C
h
a
p
t
e
r 
3 — 
A 
Methodology 
for 
Program 
Development 
Figure 3.6 
Flowchart for Tuition Billing Program 
START 
1 
< 
OPEN FILES 
> f 
TRUE 
WRITE 
/ 
UNIVERSITY 
TOTALS 
1 
CLOSE 
FILES 
< 
STOP 
^ ) 
PROCESS 
STUDENT 
f 
PROCESS 
"A 
V 
STUDENT 
J 
\ 
COMPUTE 
TUITION 
COMPUTE 
UNION FEE 
COMPUTE 
ACTIVITY 
FEE 
COMPUTE 
SCHOLARSHIP 
INCREMENT 
UNIVERSITY 
TOTALS 
WRITE 
DETAIL 
LINE 
I 
READ 
STUDENT 
RECORD 
C
 stop ) 
(a) Overall Flowchart 
UDENT 
the technique precludes exact rules, but w e urge the use of consistent conventions 
to m a k e it easier to read. Our suggestions: 
1. Indent for readability. 
2. U s e ENDIF, ENDDO, and ENDCASE to indicate the e n d of a logic structure; 
u s e vertical lines to indicate the extent of a block. 

Pseudocode for Building Blocks 
Statement A 
Statement B 
IF condition is true 
Statement A 
ELSE 
Statement; B 
ENDIF 
DO WHILE condition is true 
Statement A 
ENDDO 
DO CASE 
Case 1 is true 
Statement A 
Case ? is true 
Statement B 
ENDCASE 
3. U s e parenthetical expressions to clarify statements associated with the ELSE 
portion of an IF statement. 
4. Minimize or avoid the use of adjectives and adverbs. 
Warnier-Orr diagrams ( n a m e d for their co-developers, Jean D o m i n i q u e Warnier 
and K e n n e t h Orr) c o m b i n e e l e m e n t s of structured d e s i g n a n d structured 
programming. The diagrams use specific symbols to represent the basic building 
blocks of structured programming, then c o m b i n e these elements in hierarchical 
fashion. 
Figure 3.9 shows h o w the basic building blocks of structured programming 
would b e represented in a Warnier-Orr diagram. Sequential statements (Figure 3.9a) 
are listed vertically, o n e under the other, a n d are grouped in braces. A plus sign 
enclosed in a circle indicates selection, a n d is placed b e t w e e n the true and false 
conditions of the selection structure (a bar denotes the false condition). Parentheses 
indicate iteration (Figure 3.9c), with the n u m b e r inside the parentheses indicating 

C
h
a
p
t
e
r 
3 
A Methodology 
for 
Program 
Development 
Figure 3.8 
Pseudocode for Tuition Billing Program 
Open files 
Write heading line(s) 
Read STUDENT-FILE at end indicate no more data 
i 
DO WHILE data remains 
j 
Compute tuition 
Compute union fee 
'. 
Compute activity fee 
{ 
Compute scholarship 
\ 
Compute bill 
Increment university totals 
Write detail line 
j 
Read STUDENT-FILE at end indicate no more data 
' 
ENDDO 
Write university totals 
Close files 
Stop run 
(a) initial attempt 
Open files 
Write heading 1ine(s) 
Read STUDENT-FILE at end indicate no more data 
l 
DO WHILE data remains 
Compute tuition = 200 * credits 
IF union member 
Union fee = $25 
| 
ELSE 
Union fee = 0 
! 
ENDIF 
j 
DO CASE 
| 
CASE credits <= 6 
j 
Activity fee = 25 
j 
CASE credits > 6 and <= 12 
Activity fee = 50 
j 
CASE credits > 12 
j 
Activity fee = 75 
I 
END CASE 
- — IF gpa > 2.5 
Scholarship = Scholarship amount 
ELSE (no scholarship) 
Scholarship = 0 
I 
ENDIF 
Compute Bill = Tuition + Union fee + Activity fee - Scholarship 
Increment university totals 
Write detail line 
Read STUDENT-FILE at end indicate no more data 
ENDDO 
Write university totals 
Close files 
Stop run 
(b) Detailed! pseudocode 

l u r e 3.9 
Warnier-Orr Diagrams for Building Blocks 
Statement A 
Statement B 
fa) The Sequence Structure 
Condition 
{statement A 
Condition 
{Statement B 
(b) The Selection Structure 
(0, End) 
(Statement A 
(c) The Iteration Structure 
h o w often the loop is to be performed. A variable n u m b e r of iterations is implied by 
enclosing two numbers, for example (0, End) to indicate execution until an end-of-
file condition is reached. There is no specific notation for the case construct. 
Figure 3.10 contains a Warnier-Orr diagram for the tuition billing program. 
The diagram depicts the s a m e manager/subordinate relationships as the hierarchy 
chart of Figure 3.3c, but unlike the hierarchy chart, is read from left to right rather 
than from top to bottom. The diagram also contains additional information not 
found in the hierarchy chart, namely the logic to indicate h o w often, and in what 
sequence, subordinate m o d u l e s are executed. 
All programs require extensive testing to ensure that they conform to the original 
specifications. However, the question of w h e n coding ends and testing begins is 
not as straightforward as it m a y appear, and gives rise to the p h i l o s o p h y of 
top-
down testing. 
T o p - d o w n testing suggests that coding and testing are parallel activities, and 
espouses the philosophy that testing begins even before a program is completely 
finished. This is accomplished by initially coding the intermediate- a n d / o r lower-
level paragraphs as stubs, that is, partially coded paragraphs w h o s e purpose is to 
indicate only that the paragraph has b e e n executed. The stub paragraphs do no 
useful work per se, and are used only to test the overall flow of the program. The 
rationale is that the highest (and most difficult) m o d u l e s should b e tested earlier 
and more often than the lower-level routines; the latter contain detailed but often 
trivial logic, and are least important with respect to the overall program flow. 
Figure 3.11 is an example of such a program. It is complete in t h e sense that it 
contains a paragraph for every m o d u l e in the hierarchy chart of Figure 3.3, yet 
incomplete in that m o s t of its paragraphs consist of a single DISPLAY statement. 

C
h
a
p
t
e
r 
3 
A 
Methodology 
for 
Program 
Development 
Figure 3.10 
Warnier-Orr Diagram for Tuition Billing Program 
I 
Tuition-Billing Program 
Open files 
Write-heading-line 
Read-student-file 
(1) 
Process-record 
(0, End) 
Compute-i ndi vidual-bi11 
(1) 
Compute-tuition 
(1) 
Compute-union-fee 
(1) 
Compute-acti vi ty-fee 
(1) 
Compute-scholarship 
(1) 
Increment-uni versi ty-total s 
(1) 
Wri te-detai1-1i ne 
(1) 
Read-student-file 
(1) 
Wri te-uni versi ty-total s 
(1) 
Close f i l e s 
Stop run 
(DISPLAY is o n e of the m o s t useful statements in COBOL as it allows the programmer 
to print a m e s s a g e o n the screen—for example, DISPLAY "COMPUTE-INDIVIDUAL-
BILL paragraph has b e e n entered"—or to print the contents of a data name—for 
example, DISPLAY STUDENT-RECORD—without having to o p e n a file. The DISPLAY 
statement is covered in Chapter 6.) 
The program in Figure 3.11 w a s tested with the data of Figure 3.12a, a n d 
produced the output of Figure 3.12b. You m a y not think that m u c h has b e e n 
accomplished, but closer examination s h o w s that all of t h e paragraphs in the 
program were executed, a n d further that they were executed in t h e correct sequence. 
The testing has demonstrated that the overall program flow is correct. 
Execution began with the paragraph PREPARE-TUITION-REPORT followed 
by the the paragraph WRITE-HEADING-LINE. The record for t h e first student (JB 
Smith) w a s read, and the paragraph PROC ESS - STUD ENT- RECORD w a s entered. 
The paragraph COMPUTE-INDIVIDUAL-BILL w a s executed next, and called its 
four subordinates to c o m p u t e the tuition, union fee, activity fee, and scholarship. 
The paragraphs to increment university totals and to write a detail line were also 
called. The data for the s e c o n d student (HR James) w a s read, and PROCESS-
STUDENT-RECORD (and all its subordinates) were re-executed. Eventually the e n d 
of file w a s reached, the paragraph WRITE-UNIVERSITY-TOTALS w a s executed, and 
the program e n d e d . 
Yes, the program requires additional development, but t h e hardest part is 
over. Any errors that m a y have existed in the highest-level m o d u l e s have already 

Top-Down 
Testing 
, 
. ...» 
Figure 3.11 
Tuition Billing Program with Stubs 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
TUITI0N3. 
3 
AUTHOR. 
CAROL VAZQUEZ VILLAR. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR03\TUITI0N.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
11 
DATA DIVISION. 
12 
FILE SECTION. 
13 
FD STUDENT-FILE 
14 
RECORD CONTAINS 27 CHARACTERS. 
15 
01 STUDENT-RECORD 
PIC X(27). 
16 
17 
WORKING-STORAGE SECTION. 
18 
01 DATA-REMAINS-SWITCH 
PIC X(2) 
VALUE SPACES. 
19 
20 
PROCEDURE DIVISION. 
21 
PREPARE-TUIT ION-REPORT. 
22 
DISPLAY 'PREPARE-TUITION-REPORT paragraph entered'. 
23 
OPEN INPUT STUDENT-FILE. 
24 
PERFORM WRITE-HEADING-LINE. 
25 
PERFORM READ-STUDENT-FILE. 
26 
PERFORM PROCESS-STUDENT-RECORD 
27 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
28 
PERFORM WRITE-UNIVERSITY-TOTALS. 
29 
CLOSE STUDENT-FILE. 
30 
STOP RUN. 
31 
32 
WRITE-HEADING-LINE. 
33 
DISPLAY 'WRITE-HEADING-LINE paragraph entered'. 
34 
35 
READ-STUDENT-FILE. 
36 
READ STUDENT-FILE 
37 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
38 
END-READ. 
39 
40 
PROCESS-STUDENT-RECORD. 
41 
DISPLAY ' '. 
42 
DISPLAY 'PROCESS-STUDENT-RECORD paragraph entered'. 
[ 43 ~ 
DISPLAY 'Student record being processed: ' STUDENT-RECORD.| 
44 
PERFORM COMPUTE-INDIVIDUAL-BILL. 
\ 
45 
PERFORM INCREMENT-UNIVERSITY-TOTALS 
\ 
46 
PERFORM WRITE-DETAIL-LINE. 
\Display statement shows current record 
47 
PERFORM READ-STUDENT-FILE. 
48 

C
h
a
p
t
e
r 
3 
A Methodology 
for 
Program 
Development 
.11 
(continued) 
49 
50 
51 
52 
53 
54 
55 
COMPUTE-INDIVIDUAL-BILL. 
DISPLAY
 1 COMPUTE-INDIVIDUAL-BILL paragraph entered', 
PERFORM COMPUTE-TUITION. 
PERFORM COMPUTE-UNION-FEE. 
PERFORM COMPUTE-ACTIVITY-FEE. 
PERFORM COMPUTE-SCHOLARSHIP. 
COMPUTE-UNION-FEE. 
DISPLAY ' COMPUTE-UNION-FEE paragraph entered'. 
COMPUTE-ACTIVITY-FEE. 
DISPLAY ' COMPUTE-ACTIVITY-FEE paragraph entered'. 
COMPUTE-SCHOLARSHIP. 
DISPLAY ' COMPUTE-SCHOLARSHIP paragraph entered'. 
INCREMENT-UNIVERSITY-TOTALS. 
DISPLAY
 1 INCREMENT-UNIVERSITY-TOTALS paragraph entered'. 
WRITE-DETAIL-LINE. 
DISPLAY ' WRITE-DETAIL-LINE paragraph entered'. 
WRITE-UNIVERSITY-TOTALS. 
DISPLAY ' '. 
DISPLAY 'WRITE-UNIVERSITY-TOTALS paragraph entered'. 
-roqram siuc 
b e e n found, and w e r e easier to correct than had testing b e e n deferred. Of course, 
later versions of the program can still contain bugs, but these errors will occur in 
lower level m o d u l e s where correction is generally easier. The m o r e difficult problems 
will already have b e e n resolved in the initial tests, and that is precisely the goal of 
t o p - d o w n testing. 
W e urge y o u to i m p l e m e n t the t o p - d o w n approach to program testing, and 
offer Figure 3.13 as our last w o r d o n the subject. In the traditional m o d e of 
Figure 3.13a, n o testing is d o n e until the w e e k e n d before the program goes live (or 
your assignment is due). Inevitably last-minute panic sets in, giving rise to overtime 
and chaos, an environment unlikely to produce logically correct programs. By 
contrast, the top d o w n approach of Figure 3.13b provides a m o r e uniform testing 
pattern, beginning almost immediately with the project's i n c e p t i o n and continuing 
throughout its duration. The results are vastly superior. 

Top-Down 
Testing 
Testing the Tuition Billing Program 
SMITH 
JAMES 
BAKER 
GROSSMAN 
FRANKEL 
PART-TIMER 
JONES 
HEAVYWORKER 
LEE 
CLARK 
BENWAY 
KERBEL 
JB15Y0000230 
HR15 0500245 
SR09 0500350 
JR03Y0000300 
PL15Y0000280 
HM18 0000200 
BL18 0000335 
JC06 0000310 
SE07 0000215 
LF10 0000350 
CT03 0250395 
NB04 0000100 
PREPARE-TUITION-REPORT paragraph entered 
WRITE-HEADING-LINE paragraph entered 
PROCESS-STUDENT-RECORD paragraph entered 
Student record being processed: SMITH 
JB15Y0000230 
COMPUTE-INDIVIDUAL-BILL paragraph entered 
COMPUTE-TUITION paragraph entered 
COMPUTE-UNION-FEE paragraph entered 
COMPUTE-ACTIVITY-FEE paragraph entered 
COMPUTE-SCHOLARSHIP paragraph entered 
INCREMENT-UNIVERSITY-TOTALS paragraph entered 
WRITE-DETAIL-LINE paragraph entered 
PROCESS-STUDENT-RECORD paragraph entered 
Student record being processed: JAMES 
HR15 0500245 
COMPUTE-INDIVIDUAL-BILL paragraph entered 
COMPUTE-TUITION paragraph entered 
COMPUTE-UNION-FEE paragraph entered 
COMPUTE-ACTIVITY-FEE paragraph entered 
COMPUTE-SCHOLARSHIP paragraph entered 
INCREMENT-UNIVERSITY-TOTALS paragraph entered 
WRITE-DETAIL-LINE paragraph entered 
PROCESS-STUDENT-RECORD paragraph entered 
Student record being processed: KERBEL 
NB04 0000100 
COMPUTE-INDIVIDUAL-BILL paragraph entered 
COMPUTE-TUITION paragraph entered 
COMPUTE-UN ION-FEE paragraph entered 
COMPUTE-ACTIVITY-FEE paragraph entered 
COMPUTE-SCHOLARSHIP paragraph entered 
INCREMENT-UNIVERSITY-TOTALS paragraph entered 
WRITE-DETAIL-LINE paragraph entered 
WRITE-UNIVERSITY-TOTALS paragraph entered 

C
h
a
p
t
e
r J —- A Methodology 
(or Program 
Development 
F i g u r e 3.13 
Advantages of Top-Down Testing 
Last-minute panic 
o 
E 
< 
c 
o 
A 
Time 
(a) Traditional Mode 
(b) Top-Down Mode 
Time 
SUMMARY 
j
o
i
n
t
s to 
Remember 
Structured design is a functionally oriented technique that Identifies the 
tasks a program is to accomplish, then relates those tasks to one another 
in a hierarchy chart. 
in a COBOL program. A module (paragraph) can be entered only from the 
module immediately above it, and must return control to that module when 
execution is complete. 
A hierarchy chart is evaluated for completeness, functionality, and span of 
control. 
Structured programming is procedural in nature and contains decision­
making logic depicting the sequence in which the program tasks will be 
executed. 
A structured program consists entirely of the basic building blocks of 
sequence, selection, and iteration; a fourth construct, case, is commonly 
included in the definition of structured programming. 
Each of the elementary building blocks in structured programming has one 
entry point and one exit point. 
Flowcharts and/or pseudocode (defined as neat notes to yourself) describe 
the logic in a program. Warnier-Orr diagrams combine elements of structured 
design and structured programming. 
Top down testing begins early in the development process, even before a 
program is completely coded; it is accomplished through the use of 
program stubs. 

Fill-in 
I L L 
Bohm and Jacopini 
Pseudocode 
Case structure 
Selection structure 
Flowchart 
Sequence structure 
Functional technique 
Span of control 
Hierarchy chart 
Structured design 
Iteration structure 
Structured programming 
One entry point/one exit point 
Top-down development 
Procedural technique 
Warnier-Orr diagram 
Program stub 
1. The fundamental building blocks of structured programming are:  
and 
. 
?. The 
construct is a fourth structure, which is convenient for 
expressing multibranch situations. 
3, All of the basic building blocks of structured programming have  
entry point and 
exit point. 
4. In the iteration, or DO WHILE construct, the condition is tested (before/after) the 
procedure is executed. 
5. The primary tool of structured design is the. 
. diagrams combine elements of a hierarchy chart and 
pseudocode. 
7. A hierarchy chart is evaluated according to the criteria of 
, and 
. 
8. Structured design is a 
oriented technique, whereas structured 
programming is 
in nature. 
9. 
, rather than flowcharting, is the most common technique for 
expressing program logic. 
10. Each module in a 
represents a 
in a COBOL program. 
11. 
is the management term for the number of 
subordinate modules. 
12. A well-chosen paragraph name should indicate the function of that paragraph, 
and consist of a 
, 
, and 
. 
13. 
and 
are the individuals credited with first 
postulating the structured theorem. 
14. Structured (programming/design) is intended to produce a 
solution with the same components and relationships as the problem it is 
intended to solve. 
15. A program should be tested from the (top down/bottom up). 

C
h
a
p
t
e
r 
3 
A 
Methodology 
for 
Program 
Development 
T R U E / F A L S E 
1. A structured program is guaranteed not to contain logical errors. 
2. Structured programming can be implemented in a variety of programming languages. 
3. INITIALIZATION and TERMINATION are good module names. 
4. The logic of any program can be expressed as a combination of only three types of 
logic structures. 
5. The one entry/one exit philosophy is essential to structured programming. 
6. Decision making should generally occur in higher-level, rather than lower-level, 
modules. 
7. The case construct is one of the three basic logic structures. 
8. A flowchart is the only way to communicate program logic. 
9. Pseudocode has precise syntactical rules. 
10. A program's hierarchy chart is developed from the bottom up. 
11. A program must be completely coded before testing can begin. 
12. A Warnier-Orr diagram combines elements of structured design and structured 
programming. 
13. READ-WRITE-AND-COMPUTE is a good module name. 
14. A single COBOL paragraph should accomplish many functions for optimal efficiency. 
15. Program testing should be concentrated in the last 25% of the development phase. 
16. A span of control from 15 to 25 COBOL paragraphs is desirable for the highest-
level modules. 
17. The optimal number of modules in a system is equal to the number of programmers 
available for coding. 
18. A module in a hierarchy chart can be called from another module on its own level. 
P R O B L 
EMS 
1. Given the flowchart in Figure 3.14, respond "true" or "false" to the following on the 
basis of the flowchart. 
a. If X > Y and W > Z, then always add 1 to B. 
b. If X < Y, then always add 1 to D. 
c. If Q > T, then always add 1 to B. 
d. If X < Y and W < Z, then always add 1 to D. 
e. There are no conditions under which 1 will be added to both A and B 
simultaneously. 
f. If W > Z and Q < T, then always add 1 to C. 
2. Assume that a robot is sitting on a chair, facing a wall a short distance away. 
Restricting yourself to the basic building blocks of structured programming, develop 
the necessary logic to have the robot walk to the wall and return to its initial position. 
Express your solution in pseudocode. The robot understands the following 
commands: 

sure 3.14 
Flowchart for Problem 1 
ADD 1 TO D 
ADD 1 TO C 
1 
ADO 1 TO B 
ADD 1 TO A 
STAND 
SIT 
TURN (turns right 90 degrees) 
STEP 
In addition, the robot can raise its arms and sense the wall with its fingertips. 
(However, it cannot sense the chair on its return trip, since the chair is below arm 
level.) Accordingly the robot must count the number of steps to the wall or chair by 
using the following commands: 
ADD (increments counter by 1) 
SUBTRACT (decrements counter by 1) 
ZERO COUNTER (sets counter to zero) 
ARMS UP 
ARMS DOWN 
The wall is assumed to be an integer number of steps away. Select a volunteer 
to act as the robot, and see whether the submitted solutions actually accomplish 
the objective. 

3. Identify the elementary building blocks in Figure 3.15. Be sure you get all of them 
(the authors can find eight). 
4. Indicate the output that will be produced by each of the following DISPLAY 
statements. 
a. DISPLAY 'STUDENT RECORD'. 
b. DISPLAY STUDENT-RECORD. 
c. DISPLAY 'STUDENT RECORD IS ' STUDENT-RECORD. 
d. DISPLAY. 
e. DISPLAY STUDENT-NAME, SOC-SEC-NUM. 
5. This non-data-processing problem specifically avoids a business context, and was 
chosen because you are unlikely to have a preexisting bias toward a solution. 

Develop a hierarchy chart to allow a user to play a series of tic-tac-toe games 
interactively against a computer. The following modules were used in the author's 
solution: PLAY-SERIES, PLAY-GAME, CLEAR-BOARD, GET-USER-MOVE, 
VALIDATE-USER-MOVE, CHECK-FOR-WINNER, UPDATE-BOARD, GET-
COMPUTER-MOVE, DISPLAY-BOARD, DISPLAY-MESSAGE. (The last module, 
DISPLAY-MESSAGE, may be called from several places.) The module names 
should in themselves be indicative of the module functions. 
6. Again we have chosen a nonbusiness problem to give you further practice with 
structured design. This time you are asked to develop a hierarchy chart for the 
game of blackjack (also known as "21"). The game is played with a deck of 52 
cards (or more commonly with multiple decks). The player places a bet, and the 
player and dealer are each dealt two cards. Both of the player's cards are face up 
(showing), but one of the dealer's cards is hidden. The player is asked whether he 
or she wishes to draw additional card(s), after which the dealer has the same 
option (provided the player has not gone over 21). The player closest to 21 (without 
going over) wins. The rules of the game require the dealer to draw with 16 or less, 
and stand (not draw) with 17 or more. Your hierarchy chart should contain the 
necessary modules to keep a running total of the player's winnings (or losses) as 
well as the following special situations: 
a. Doubling down—if the player's first two cards total 11, he or she may double the 
bet and receive one additional card. 
b. Purchasing insurance—if the dealer's "up" card is an ace, the player may place 
an additional side bet. If the dealer has "blackjack," the player receives a payout 
of 2 to 1 on the side bet, but loses the initial bet. If the dealer does not have 
blackjack, the side bet is lust and play continues. 
c. Splitting pairs—if the player has a pair, he or she may double the bet and play 
two hands. 


Overview 
C O B O L Notation 
I D E N T I F I C A T I O N D I V I S I O N 
E N V I R O N M E N T D I V I S I O N 
CONFIGURATION SECTION 
INPUT-OUTPUT SECTION 
S H I M uiviaivn 
FILE SECTION 
File Description (FD) 
Record Description 
PICTURE Clause 
Level Numbers 
Assumed Decimal Point 
WORKING-STORAGE SECTION 
VALUE Clause 
T h e Tuition Billing Program 
Programming Specifications 
COBOL Entries 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
4 
i 
'NORI.'ficatiort, 
Environment, 
and 
Data 
Divisions 
The overall approach of this book is to provide a rapid introduction to computer 
programming; thus we presented a complete COBOL program in Chapter 1. 
Our objective at that time was to put you on the computer immediately, without 
too much concern for the syntactical rules, which you must eventually master. 
We move now to a formai study of COBOL, beginning with a notation that 
fully explains the variations permitted within any COBOL statement. The chapter 
focuses on the Identification, Environment, and Data Divisions, and concludes 
with a COBOL listing expanding on this material. 
w w d u l . 
COBOL is an English-like language with inherent flexibility in the way a particular 
Notation 
entry m a y be expressed. In other words, there are a n u m b e r of different, but equally 
acceptable, ways to say the s a m e thing. It is necessary, therefore, to develop a 
standard notation to provide a clear and unambiguous m e a n s of indicating precisely 
what is, and is not, permitted within any given statement. The notation is illustrated 
in Figure 4.1 and adheres to the following conventions: 
1. Lowercase letters signify programmer-supplied information—for example, 
identifier-1 or literal-1. 
2. Uppercase letters indicate reserved words—for example, IF, GREATER, or 
THAN. 
3. Uppercase letters that are underlined are required; uppercase letters that are 
not underlined are optional reserved words. 
4. Brackets [ ] symbolize an optional entry—for example, [ N O T ]. 
5. Braces {} imply that o n e of the enclosed items must be chosen—for example, 
a choice is required b e t w e e n identifier-1, literal-1, and arithmetic 
expression-1. 
6. Three dots . . . m e a n that the last syntactical unit can be repeated an 
arbitrary number of times. 
O B J E C T 
IVES 
After reading this chapter you will be able to: 
Describe the COBOL notation and determine the appropriate syntax for 
any statement. 
Complete the Identification Division of a COBOL program. 
Complete the Environment Division of a COBOL program. 
Code a record description to show hierarchical relationships among fields 
containing numeric and alphanumeric entries. 
Code a Working-Storage Section to define various print lines. 
Explain the use of an assumed decimal point. 
D 
1/ cr p 
1/ / c: 1/1/ 

IDENTIFICATION 
DIVISION 
COBOL Notation 
I f 
\ 
UDtiona; 
entry. 
identlfier-1 
1iteral-1 
arithmetic expression-1 
Optional reserved womisi 
^Reouiivd 
word 
is [NOT] 
GREATER THAN 
LESS THAN 
EQUAL TO 
GREATER THAN OR EQUAL TO 
LESS THAN OR EQUAL TO 
/Programmer supplied 
identifier-2 
literal-2 
arithmetic expression-2 
The example in Figure 4.1 is associated with the condition portion in the IF 
statement. IF is underlined and appears in capital letters, indicating it is a required 
reserved word. It is followed by a set of braces containing three options, o n e of 
which must be chosen. The reserved word IS appears in uppercase letters but is 
not underlined, m e a n i n g its use is optional. The brackets surrounding NOT imply 
that the clause is optional, but if the clause is chosen, NOT is required because it 
is underlined. 
The next set of braces indicates a s e c o n d mandatory choice a m o n g five 
relationships: GREATER THAN, GREATER THAN OR EQUAL TO, LESS THAN, LESS 
THAN OR EQUAL TO, or EQUAL TO. The reserved words THAN a n d TO are not 
underlined and are, therefore, optional. Alternatively, you can choose the appropriate 
symbol: >, >= <, <=, or = instead of spelling out the relationship. The third set of 
braces indicates yet another choice, this time from the entries identifier-2, literal-2, 
and arithmetic expression-2. 
Returning to the engineering senior problem of Chapter 1, i n which STU-
MAJOR is compared to engineering, w e see that all of the following are acceptable 
as the condition portion of the IF statement: 
IF STU-MAJOR IS EQUAL TO 'ENGINEERING' 
IF STU-MAJOR EQUAL 'ENGINEERING' 
IF 'ENGINEERING' IS EQUAL TO STU-MAJOR 
IF STU-MAJOR = 'ENGINEERING' 
< ^C, ' , i , ^ 
The IDENTIFICATION DIVISION is the first of the four divisions i n a COBOL 
Us 
'\#tsl 
11,11 
program. Its function is to provide identifying information about the program, s u c h 
as author, date written, and security. The division consists of a division header and 
u p to six paragraphs: 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
rAUTHOR. 
["INSTALLATION. 
[DATE-WRITTEN. 
rPATE-COMPILED. 
fSECURITY. 
program-name. 
[comment-entry] 
[comment-entry] 
[comment-entry] 
[comment-entry] 
[comment-entry] 

C
h
a
p
t
e
r 
4 
The 
Identification, 
Environment, 
and 
Data 
Divisions 
The division header and PROGRAM-ID paragraph are the only required entries. The 
five remaining paragraphs are optional (as indicated by the COBOL notation), and 
only the DATE-COMPILED paragraph merits special m e n t i o n . If the paragraph is 
specified, the compiler will insert the current date during program compilation. 
(The paragraph is redundant, however, since most compilers automatically print 
the date of compilation o n the top of each page.) A completed Identification Division 
is shown: 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
FIRSTTRY. 
AUTHOR. 
ROBERT T. GRAUER. 
INSTALLATION. 
UNIVERSITY OF MIAMI. 
DATE-WRITTEN. 
MARCH 16, 1993. 
DATE-COMPILED. 
The compiler supplies compilation date. 
SECURITY. 
TOP SECRET-INSTRUCTORS 
ONLY. 
Coding for the Identification Division follows the general rules described in 
Chapter 2. The division header and paragraph n a m e s begin in the A margin, with all 
corresponding entries beginning in or past c o l u m n 12 (B margin). 
The ENVIRONMENT DIVISION contains two sections: 
1. The CONFIGURATION SECTION identifies the computers for compiling and 
executing the program, usually o n e and the same. 
2. 
The INPUT-OUTPUT SECTION associates the files in the COBOL program 
with the files known to the operating system. 
The nature of these functions makes the Environment Division d e p e n d e n t on 
the c o m p u t e r o n which you are working; that is, the Environment Division for a 
program o n a VAX is different from that for a program o n an IBM mainframe. 
/ . 
O L U V U s L.VC 
Jivision 
The CONFIGURATION SECTION is enclosed in brackets within the COBOL notation 
and is therefore optional. An abbreviated format is s h o w n below: 
[CONFIGURATION SECTION.  
fSOURCE-COMPUTER. computer-name.] 
rOBJECT-COMPUTER. computer-name.]] 
The section header and paragraph n a m e s begin in the A margin w h e r e a s the 
computer-name entries begin in or past c o l u m n 12. The CONFIGURATION SECTION 
d o e s little to e n h a n c e (the d o c u m e n t a t i o n of) a COBOL program and is typically 
omitted. 
Input-Output Section 
.,.. 
The INPUT-OUTPUT SECTION associates the files in a COBOL program with files 
k n o w n to the operating system. It contains a FILE-CONTROL paragraph, w h i c h in 
turn contains a SELECT statement for every file in the program. Syntactically it has 
the format: 

riNPUT-OUTPUT SECTION.  
FILE-CONTROL. 
SELECT file-name-1 ASSIGN TO implementor-name.] 
A program m a y be written without any files and h e n c e the INPUT-OUTPUT 
section is optional. (See Chapter 10 o n screen I/O for an example of a program 
written without any files.) 
The section header (INPUT-OUTPUT SECTION) and paragraph n a m e (FILE-
CONTROL) begin in the A margin (columns 8 through 11). The SELECT statements 
for the individual files begin in the B margin (column 12 and beyond). 
The precise format of the implementor-name 
in the SELECT statement varies 
from compiler to compiler, with the example below taken from lines 8 through 11 in 
the engineering senior problem. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT STUDENT-FILE 
ASSIGN TO 'A:\CHAPTR03\TUITI0N.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
The d e p e n d e n c e of the Environment Division o n the individual computer 
installation bears repeating. You should consult either your instructor or your 
computer center for the proper statements to use in your program. 
B e l t * * 
The Data Division describes the data items that appear in a program. It contains 
Division 
several sections, two of which, the FILE SECTION and the WORKING-STORAGE 
SECTION, will b e discussed in this chapter. T w o other sections, the SCREEN 
SECTION and the LINKAGE SECTION, are presented in later chapters. 
File Section 
The FILE SECTION is the first section in the Data Division and contains a file 
description (FD) for every file previously defined in a SELECT statement in the 
Environment Division. (If, however, a program is written without any files, then the 
FILE SECTION will not appear.) The file description is followed by the associated 
record description w h i c h is accomplished through PICTURE clauses and level 
numbers. Each of these elements is discussed in turn. 
File D e s c r i p t i o n (FD) 
The file description (FD) provides information about the 
physical characteristics of a file. It contains four clauses, all of w h i c h are optional, 
and which m a y appear in any order. The final entry, however, must b e terminated 
by a period. An abbreviated format for the file description is as follows: 
FD 
file-name 
[BLQCjK CONTAINS integer-1 RECORDS ] 
[RECORD CONTAINS integer-1 CHARACTERS] 
[RECORDS ARE] [OMITTED 1 
LABEL — 
<^ 
} 
[RECORD IS j [STANDARDj 
[DATA RECORD IS data-name-l]. 
The BLOCK CONTAINS clause is used to speed up i n p u t / o u t p u t operations 
for files o n tape or disk, by reducing the n u m b e r of physical records (blocks) in a file, 

C
h
a
p
t
e
r 
4 
The 
Identification, 
Environment, 
and 
Data 
Divisions 
and thus reducing the n u m b e r of times the input/output device is accessed. In 
other words, it is more efficient to access a disk o n c e and read a block containing 10 
records, than it is to access the disk 10 times and read e a c h record individually. The 
blocking factor is defined as the number of logical records in a physical record. The 
concept is illustrated in Figure 4.2 where the records of Figure 4.2a are unblocked, 
whereas those in Figures 4.2b and 4.2c have blocking factors of 2 and 3, respectively. 
The higher the blocking factor, the fewer the n u m b e r of physical records, and 
the more efficient the processing. Thus, the blocking factor should always be as 
h i g h as p o s s i b l e , w i t h i n the l i m i t a t i o n s of the physical d e v i c e . T h e actual 
determination of the blocking factor n e e d not concern us now; what is important is 
the implementation of blocking in a COBOL program. 
Assume, for example, a blocking factor of 5, with the associated entry, BLOCK 
CONTAINS 5 RECORDS. The initial execution of the READ statement places a block 
of 5 logical records in memory, with only the first record available to the program. 
The s e c o n d (third, fourth, and fifth) execution of the READ statement makes a n e w 
logical record available, without a corresponding physical operation taking place. 
In similar fashion the sixth execution of the READ statement will bring a n e w 
physical record into the I/O area, with n e w logical records m a d e available o n the 
seventh through tenth executions of the READ statement. All of this is automatically 
d o n e for the programmer as long as the BLOCK CONTAINS statement is specified in 
the COBOL FD. 

COBOL programs that are written to run o n an IBM mainframe typically 
contain the entry, BLOCK CONTAINS 0 RECORDS. This entry does not m e a n what 
it says literally, but rather that the block size will be entered at execution time. 
The RECORD CONTAINS clause indicates the number of characters in a record 
and is useful for documentation. The clause also causes the compiler to verify that 
the sizes of the individual data items s u m to the stated value. 
The LABEL RECORDS clause determines whether or not label processing is to 
take place. Label records appear at the beginning and e n d of files stored o n tape or 
disk, and contain information about the file, such as the date created, the logical 
record size a n d the block size. Label records are created automatically whenever a 
file is o p e n e d as output and are checked automatically whenever a file is o p e n e d as 
input. Label processing is necessary to ensure that the proper file is being processed. 
The LABEL RECORDS clause is optional and its omission defaults to standard 
labels. 
The DATA RECORD clause specifies the n a m e of the 01 entry (or entries) 
associated with the particular file. It has limited value in d o c u m e n t a t i o n and has n o 
other function. An example of a completed FD is s h o w n below: 
FD STUDENT-FILE 
BLOCK CONTAINS 10 RECORDS 
RECORD CONTAINS 43 CHARACTERS 
LABEL RECORDS ARE STANDARD 
DATA RECORD IS STUDENT-IN. 
Record Description 
A file description is followed by a n associated record 
description 
that conveys the following information: 
1. The size and type of each field within a record 
2. The order in which the fields appear 
3. The relationship of the fields to o n e another 
through a combination of PICTURE clauses and level numbers. 
PICTURE Clause 
A PICTURE clause describes the size and type of a field. The 
size of a field is equivalent to the number of characters (positions) in the field. The 
type of field is either numeric or alphanumeric, and is denoted b y a 9 or an X, 
respectively, in the associated PICTURE clause. A numeric item c a n contain the 
numbers 0 - 9 , whereas an alphanumeric 
item m a y contain A - Z (alphabetic), 0 - 9 
(numeric), a n d / o r special characters. 
The size of a field is indicated by the n u m b e r of times the 9 or X is repeated. A 
data item with a picture of XXXX or X(4) is a four-position alphanumeric field. In 
similar fashion 999 or 9(3) denotes a three-position numeric field. (Alphabetic data 
items, d e n o t e d by an A in the associated PICTURE clause, are seldom used because 
even a field as simple as a person's n a m e can contain apostrophes or hyphens, 
which are alphanumeric rather than alphabetic in nature.) 
Level Numbers Level numbers describe the relationships that exist between 
fields within a record. Each field is classified as either a group item or a n elementary 
item. A group item is a field that can be further divided—an elementary item can 
not. 
Consider, for example, Figure 4.3, which depicts a student examination record. 
The field STUDENT-NAME is a group item because it is divided into three fields: 
LAST-NAME, FIRST-NAME, a n d INIT. LAST-NAME, FIRST-NAME, and INIT, 
however, are elementary items, since they are not further divided. In similar fashion, 
SS-NUM is a n elementary item. EXAM-SCORES is a group item, as are MATH and 
ENGLISH. ALG, GEO, READ, etc., are elementary items. 

Chapter 
4 — 
The 
identification, 
Environment, 
and 
Data 
Divisions 
^ 
Student Exam Record 
STUDENT-EXAM-RECORD 
STUDENT-NAME 
SS-NUM 
EXAM-SCORES 
LAST 
NAME 
FIRST 
NAME 
INIT 
MATH 
ENGLISH 
LAST 
NAME 
FIRST 
NAME 
INIT 
ALG 
GEO 
READ 
VOC 
LIT 
v15 16 
\ / 
ALPHANUMERIC 
32 
"40 41 45 46 \ 50 5T 
55-56^60"61 
65 
NUMERIC 
Level numbers and PICTURE clauses are used in Figure 4.4 to define a record 
corresponding to the STUDENT-EXAM-RECORD in Figure 4.3. Two equivalent 
sets of COBOL statements (Figures 4.4a and 4.4b) are presented and follow the 
rules below: 
1. The level n u m b e r s within a record description can a s s u m e any value from 01 
to 49 inclusive. 
2. The level n u m b e r 01 d e n o t e s the record as a whole. 
3. Any level n u m b e r from 02 to 49 can b e used for field(s) within the record, so 
long as elementary items have a numerically higher n u m b e r than the group 
item to w h i c h they belong. 
4. An elementary item must have a PICTURE clause—a group item cannot have 
a PICTURE clause. 
In Figure 4.4 STUDENT-EXAM-RECORD has a level n u m b e r of 01 to indicate 
the record as a whole. STUDENT-NAME is a subfield of STUDENT-EXAM-RECORD; 
h e n c e it has a higher level n u m b e r (05). LAST-NAME, FIRST-NAME, a n d MID-
INITIAL are subordinate to STUDENT-NAME and thus have a higher level n u m b e r 
(10). SOC-SEC-NUM and EXAM-SCORES are also subfields of STUDENT-EXAM-
RECORD and have the s a m e level n u m b e r as STUDENT-NAME. EXAM-SCORES is 
subdivided into two group items, MATH and ENGLISH, w h i c h in turn are further 
subdivided into elementary items. 
Every elementary item m u s t have a PICTURE clause, w h e r e a s a group item 
cannot have a PICTURE clause. Thus, LAST-NAME has the entry PICTURE IS X(15) 
to denote a 15-position alphanumeric field; STUDENT-NAME, however, is a group 
item and d o e s not have a PICTURE clause. The parentheses in a PICTURE clause 
imply repetition; that is, the entry 9(5) for ALGEBRA depicts a 5-position numeric 
field. 
There is considerable latitude within COBOL as to the specification of level 
n u m b e r s and PICTURE clauses. You can, for example, c h o o s e any level n u m b e r s 
from 02 to 49 to describe subordinate fields; for example, 04, 08, and 12 are u s e d in 
Figure 4.4b as o p p o s e d to the levels 05,10, a n d 15 in Figure 4.4a. T h e 01 level is u s e d 
in b o t h figures for the record as a whole. 

Data 
Division 
Level Numbers and PICTURE Clauses 
01 
STUDENT-EXAM-RECORD. 
05 STUDENT-NAME. 
10 LAST-NAME 
10 FIRST-NAME 
10 MID-INITIAL 
05 SOC-SEC-NUM 
05 EXAM-SCORES. 
10 
10 
MATH. 
15 ALGEBRA 
15 GEOMETRY 
ENGLISH. 
15 READING 
15 VOCABULARY 
15 LITERATURE 
PICTURE IS X(15). 
PICTURE IS X(15). 
PICTURE IS X. 
PICTURE IS 9(9). 
PICTURE IS 9(5). 
PICTURE IS 9(5). 
PICTURE IS 9(5). 
PICTURE IS 9(5). 
PICTURE IS 9(5). 
01 
STUDENT-EXAM-RECORD. 
04 STUDENT-NAME. 
08 LAST-NAME 
08 FIRST-NAME 
08 MID-INITIAL 
04 SOC-SEC-NUM 
04 EXAM-SCORES. 
08 MATH. 
12 ALGEBRA 
12 GEOMETRY 
08 ENGLISH. 
12 READING 
12 VOCABULARY 
12 LITERATURE 
PIC X(15). 
PIC X(15). 
PIC X. 
PIC 9(9). 
PIC 99999. 
PIC 99999. 
PIC 99999. 
PIC 99999. 
PIC 99999. 
The PICTURE clause itself can a s s u m e any o n e of four forms: PICTURE IS, 
PICTURE, PIC IS, or PIC. Parentheses m a y be used to signal repetition of a picture 
type; that is, X(3) is equivalent to XXX. Figure 4.4b is the exact equivalent of Figure 4.4a 
with emphasis o n the aforementioned flexibility. 
Incoming numeric data may not contain actual decimal 
points. On first reading, that statement m a y be s o m e w h a t hard to accept. How, for 
example, does o n e read a field containing dollars and cents? The answer is an 
a s s u m e d (implied) decimal point as illustrated in the COBOL entry: 
05 HOURLY-RATE 
PICTURE IS 99V99. 
Everything is familiar except the V e m b e d d e d in the PICTURE clause. The V 
m e a n s a n implied decimal point, that is, HOURLY-RATE is a four-digit (there are 

C
h
a
p
t
e
r 
4 
The 
Identification, 
Environment, 
and 
Data 
Divisions 
Assumed Decimal Point 
I 
I 
INCOMING RECORD: 
DATA DiVISt 
01 
INCOMING-DATA-RECORD. 
9 87165 4|3|
V210 
05 FIELD-A 
PIC 9V99. 
- 9 . 8 7 
05 FIELD-B 
PIC 99V9. 
*• 65.4 
05 FIELD-C 
PIC 9. 
—
3 
05 FIELD-D 
PIC V999. 
*- .210 
four 9's) numeric field, with two of the digits c o m i n g after the decimal point. Simply 
stated, the V indicates the position of the decimal point. 
To check your understanding, a s s u m e that 9876543210 is found in positions 
1-10 of an i n c o m i n g record and that the following Data Division entries apply: 
01 
INCOMING-DATA-RECORD. 
05 FIELD-A 
PIC 9V99. 
05 FIELD-B 
PIC 99V9. 
05 FIELD-C 
PIC 9. 
05 FIELD-D 
PIC V999. 
The values of FIELD-A, FIELD-B, FIELD-C, and FIELD-D are 9.87, 65.4, 3, and 
.210, respectively, as s h o w n in Figure 4.5. FIELD-A is contained in the first three 
positions with two of the digits to the right of the decimal point. FIELD-B is contained 
in the next three positions (i.e., 6, 5, and 4) with o n e digit to the right of the decimal 
point. FIELD-C is contained in position 7 with n o decimal places. Finally, FIELD-D 
is contained in positions 8, 9, and 10, with all three to the right of the decimal. 
The WORKING-STORAGE SECTION defines any data n a m e that w a s not previously 
referenced in the FILE SECTION, that is, any data n a m e that d o e s not appear in a 
file. The WORKING-STORAGE SECTION contains data n a m e s to store the results of 
calculations, switches to control the execution of performed paragraphs, a n d / o r 
data n a m e s to hold constants n e e d e d by the program. The WORKING-STORAGE 
SECTION will also define various print lines (a heading, detail, a n d / o r total line) 
required by a program. 
Figure 4.6 contains a WORKING-STORAGE SECTION for a n expanded version 
of the engineering senior program to count the n u m b e r of qualified students. 
There are separate record descriptions for the counters a n d constants n e e d e d 
b y the program, as well as a separate record description (01 entry) for e a c h type 
of print line. 
A FILLER entry defines a field that is not referenced elsewhere in the COBOL 
program. The layout of DETAIL-LINE, for example, begins with eight spaces, followed 
by the value of PRINT-NAME, an additional 10 spaces, the value of PRINT-MAJOR, 
and a final set of 74 spaces to c o m p l e t e the print line. The three fields containing 
spaces are not referenced anywhere else in the program yet n e e d to be a c c o u n t e d 
for—hence the FILLER entry. 
The word FILLER is optional, however, and could b e omitted as s h o w n in the 
definition of TOTAL-LINE. The entries under TOTAL-LINE look strange initially, 
but m a k e perfect s e n s e w h e n your realize that the "missing" FILLER entries are n o t 

Data 
Division 
WORKING-STORAGE SECTION. 
01 COUNTERS-ANO-SWITCHES. 
05 TOTAL-STUDENTS 
PIC 9(3) 
VALUE ZEROS. 
05 
DATA-REMAINS-SWITCH 
PIC X(2) 
VALUE SPACES. 
PROGRAM-CONSTANTS. 
05 REQUIRED-CREDITS 
PIC 999 
VALUE 110. 
05 REQUIRED-MAJOR 
PIC X(10) 
VALUE 'ENGINEERING 
05 REQUIRED-GPA 
PIC 9V99 
VALUE 3.00. 
01 HEADING-LINE. 
05 FILLER 
PIC X(10) 
VALUE SPACES. 
05 FILLER 
PIC X(12) 
VALUE 'STUDENT NAME 
05 FILLER 
PIC X(110) 
VALUE SPACES. 
01 DETAIL-LINE. 
05 FILLER 
05 PRINT-NAME 
05 
FILLER 
05 PRINT-MAJOR 
05 FILLER 
/ 
01 TOTAL-LINE. 
/ 
05 
PIC xT*y 
VALUE SPACES 
05 
PIC X(14) 
VALUE 'TOTAL STUDENTS'. 
05 
PIC X(2) 
VALUE SPACES. 
05 TOT-STUDENTS 
PIC 9(3) 
VALUE ZEROS. 
05 
PIC X(110) VALUE SPACES. 
PIC X(8) 
PIC X(25). 
PIC X(10) 
PIC X(15). 
PIC X(74) 
VALUE SPACES. 
VALUE SPACES, 
VALUE SPACES. 
-FILLER IS OPTIONAL IN COBOL-85 
01 DASHED-LINE 
05 FILLER 
PIC X(132) VALUE ALL 
referenced in the Procedure Division, and h e n c e their omission has n o effect o n the 
remainder of the program. 
VALUE Clause 
The VALUE clause initializes the contents of a data n a m e within 
the WORKING-STORAGE SECTION and has the general form: 
VALUE IS literal 
Literals are of three types—numeric, nonnumeric, and figurative constants. 
Numeric literals—for example, 110 or 3.00—contain a n u m b e r a n d are u s e d in 
calculations. N o n n u m e r i c literals, such as 'ENGINEERING', contain a character 
string and are enclosed in apostrophes or quotations marks. (Additional rules for 
numeric and n o n n u m e r i c literals were presented in Chapter 1.) 
A figurative 
constant 
(ZERO or SPACE) is a COBOL reserved w o r d with a pre-
a s s i g n e d value. T h e singular a n d plural forms of a figurative c o n s t a n t are 
interchangeable; that is, o n e can use SPACE or SPACES, or ZERO, ZEROS, or ZEROES. 
Figure 4.6 
The Working-Storage Section 

C h a p t e r 
4 
— 
T h e 
Identification, 
Environment, 
and 
Data 
Divisions 
Figurative constants are not enclosed in quotation marks. COBOL also permits the 
. 1 ' <1,,, /VI T 
U.Ofc \JL t i l l . 
l l l t l C U tVJ I C U C a i a UIICHCH^LCI OIX111K 
The VALUE clause associated with a particular data n a m e must be consistent 
with the corresponding PICTURE clause; that is, it is incorrect to use a n o n n u m e r i c 
literal with a numeric picture clause or a numeric literal with a n o n n u m e r i c picture. 
Consider: 
REQUIRED-CREDITS 
REQUIRED-MAJOR 
REQUIRED-CREDITS 
REQUIRED-MAJOR 
PIC 999 
VALUE 110. 
(valid) 
PIC X(10) VALUE 'ENGINEERING', 
(valid) 
PIC 999 
VALUE '110'. 
(invalid) 
PIC X(10) VALUE ENGINEERING. 
(invalid) 
REQUIRED-CREDITS is defined as a numeric item and must have a numeric value. 
In similar fashion, REQUIRED-MAJOR is defined as alphanumeric and requires an 
alphanumeric VALUE clause. 
The tuition billing program w a s introduced in Chapter 3 in conjunction with 
structured programming and design. The stubs program did not, however, s h o w 
the detailed output as presented in the programming specifications, because the 
objective at that time w a s only to test the overall flow of the program. It is necessary, 
therefore, to return to the original specifications to develop the Identification, 
Environment, and Data Divisions. We will, however, amplify the development of 
the Data Division by presenting three figures that relate various portions of the 
programming specifications to their associated COBOL entries. 
Figure 4.7a displays the input record layout from the programming specifications; 
Figure 4.7b shows the corresponding FD and record description. STUDENT-RECORD 
corresponds to the record as a w h o l e and thus is assigned the level n u m b e r 01. 
STUDENT-RECORD in turn is divided into the subordinate fields STU-NAME (which 
is further divided into STU-LAST-NAME and STU-INITIALS), STU-CREDITS, STU-
UNION-MEMBER, and STU-SCHOLARSHIP. STUDENT-RECORD and STU-NAME 
are group items and do not have a PICTURE clause; all of the other data n a m e s are 
elementary items and have a PICTURE clause. An implied decimal point appears 
within the PICTURE clause for STU-GPA. 
Figure 4.8a excerpts the processing specifications for the computation of a 
student's bill; Figure 4.8b s h o w s the associated record description as it appears in 
WORKING-STORAGE. The entries in Figure 4.8b are not required by COBOL per se, 
and are included to facilitate d o c u m e n t a t i o n and maintenance. It would b e possible, 
for example, to use the constants 200 and 25 in the Procedure Division rather than 
the corresponding data n a m e s PRICE-PER-CREDIT and UNION-FEE. The data 
n a m e s , however, facilitate program maintenance; that is, a c h a n g e in the value of a 
constant is easier to i m p l e m e n t in the Data Division than (in multiple statements) 
in the Procedure Division. 
Figure 4.9a contains the programming specifications for the heading and 
detail lines; Figure 4.9b s h o w s the associated COBOL entries. N o t e carefully the 
exact correspondence b e t w e e n the COBOL entries and report layout. The print 
layout calls for 10 spaces b e t w e e n the literals STUDENT NAME a n d CREDITS; thus 
there is a 10 position FILLER entry b e t w e e n these literals within the COBOL entries. 

The 
Tuition 
Billing 
Program 
Figure 4.7 
Development ot a COBOL Program (File Section) 
CREDITS 
UNION MEMBER 
INITIALS 
SCHOLARSHIP 
S T U D E N T 
NAME 
21 22 23 24 
GPA 
25
v26 27 
LAST 
18 19 20 21 22 23 24 
GPA 
25
v26 27 
1 
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 
GPA 
25
v26 27 
(a) Program Specification: 
( FD STUDENT-FILE 
RECORD CONTAINS 27 CHARACTERS. 
01 STUDENT-RECORD. 
05 STU-NAME. 
10 STU-LAST-NAME 
PIC X(15). 
10 STU-INITIALS 
PIC XX. 
05 STU-CREDITS 
PIC 9(2). 
05 STU-UNION-MEMBER 
PIC X. 
05 STU-SCHOLARSHIP 
PIC 9(4). 
05 STU-GPA 
PIC 9V99. 
(b) COBOL Entries 
ire 4.6 
Development of a COBOL Program (Constants and Rates) 
1. Calculate tuition due at the rate of $200 per credit. 
2. The union fee is $25. 
3. Compute the activity fee based on the number of credits taken; $25 for 6 
credits or less, $50 for 7 to 12 credits, and $75 for more than 12 credits. 
4. Award a scholarship equal to the amount in the incoming record if, and 
only if, the GPA is greater than 2.5. 
(a) Excerpt from the Program Specifications 
WORKING-STORAGE SECTION. 
01 CONSTANTS-AND-RATES. 
05 PRICE-PER-CREDIT 
05 UNION-FEE 
05 ACTIVITY-FEES. 
10 1ST-ACTIVITY-FEE 
10 1ST-CREDIT-LIMIT 
10 2ND-ACTIVITY-FEE 
10 2ND-CREDIT-LIMIT 
10 3RD-ACTIVITY-FEE 
05 MINIMUM-SCHOLAR-GPA 
PIC 9(3) 
PIC 9(2) 
VALUE 200. 
VALUE 25. 
PIC 99 
VALUE 25. 
PIC 99 
PIC 99 
PIC 99 
PIC 99 
VALUE 6. 
VALUE 50. 
VALUE 12. 
VALUE 75. 
PIC 9V9 
VALUE 2.5. 
(b) COBOL Entries 

Chapter 
4 
—- 
Trie 
Identification, 
Environment, 
and 
Data 
Division 
Figure 4,3 
Development of a COBOL Program (Print Lines) 
S T U D E N T 'NAME 
C R E D I T S 
T U I T I O N 
U N I O N F E L 
A C T F E E 
S C H O L A R S H I P 
T O T A L 
B I L L 
XXXXXXXXXXXXXXX 
9 
XX X X X X X X X XX XX X X 
X 
(a) Report Layout 
01 HEADING-LINE. 
05 FILLER 
PIC X 
VALUE SPACES. 
05 FILLER 
PIC X(12) 
VALUE 'STUDENT NAME 
05 FILLER 
PIC X(10) 
VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE 'CREDITS'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE 'TUITION'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(9) 
VALUE 'UNION FEE'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE 'ACT FEE'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(ll) 
VALUE 'SCHOLARSHIP' 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(10) 
VALUE 'TOTAL BILL'. 
05 FILLER 
PIC X(48) 
VALUE SPACES. 
DETAIL-LINE. 
05 FILLER 
PIC X 
VALUE SPACES. 
05 DET-LAST-NAME 
PIC X(15). 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 DET-INITIALS 
PIC X(2). 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
05 DET-CREDITS 
PIC 9(2). 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
05 DET-TUITI0N 
PIC 9(6). 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
05 DET-UNI0N-FEE 
PIC 9(3). 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
05 DET-ACTIVITY-FEE 
PIC 9(3). 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
05 DET-SCHOLARSHIP 
PIC 9(5). 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
05 DET-IND-BILL 
PIC 9(6). 
05 FILLER 
PIC X(49) 
VALUE SPACES. 
99 
99 
999999 
999999 
999 
999 
999 
99 9 
999)99 
999B9 
99 
99 
9999 
9999 
(b) COBOL Entries 

The 
Tuition 
Billing 
Program 
Figure 4.10 contains the c o m p l e t e d entries for the first three divisions. (The 
completed Procedure Division appears at the e n d of Chapter 5.) The Identification 
Division is unchanged from the stubs program in Chapter 3 and contains only the 
required PROGRAM-ID paragraph a n d an optional AUTHOR paragraph. T h e 
Environment Division has expanded slightly to include an additional SELECT 
statement for the print file (lines 10 and 11). 
The Data Division, however, has grown significantly. The FILE SECTION 
contains the FD for the incoming student record (lines 15 and 16) followed by the 
associated record description in lines 17 through 24. A file description has also b e e n 
a d d e d for PRINT-FILE. Note, too, the c o r r e s p o n d e n c e b e t w e e n t h e SELECT 
statements in the Environment Division a n d the associated FD entries in the Data 
Division. 
The p r o g r a m m i n g specifications call for multiple calculations for e a c h 
student (tuition, union fee, activity fee, scholarship) as well as university totals for 
each item. Each of these calculations requires a separate data n a m e in WORKING-
STORAGE to store the result. Observe, therefore, the definition of the elementary 
items IND-TUITION, IND-ACTIVITY-FEE, a n d so on, which appear together (for 
convenience) under the group item INDIVIDUAL-CALCULATIONS (line 33). In 
similar fashion, the elementary items UNI-TUITION, UNI-ACTIVITY-FEE, and so 
on, appear under the group item UNIVERSITY-TOTALS (line 40). There is also a 
separate 01 entry to hold the constants a n d rates required by the program (lines 
47-56). 
The program requires several different types of print lines—a heading line, a 
/-Jo-froil l i n o 
or-» 
A 'i tr\*o 1 I m o 0ir>K x*rt*-K o 'i iffc^i-tirit 
fr\»-mot 
T h i i c tKoro i r o c o n o r o t a HI 
uwiuu iUiV, unu ct ivy vet j. in i , v/uvn vv mi u um^i ^ni i vy i niui. i i i u j , tuv> j 
ci« 
v.- av>puiui^ vs i 
entries for HEADING-LINE (lines 58-73), DETAIL-LINE (lines 75-92), a n d TOTAL-
LINE in lines 107-121. Note, too, the separate entry for DASH-LINE (lines 94-105), 
which makes use of the ALL literal to establish a row of dashes. Look carefully at the 
use of the FILLER a n d associated VALUE clauses in each of these print lines, to 
create the necessary literal information, a n d the correspondence b e t w e e n these 
entries a n d the COBOL specifications. 
F i g u r e 4 . 1 0 Identification, Environment, and Data Divisions for Tuition Billing Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
TUITI0N5. 
3 
AUTHOR. 
CAROL VAZQUEZ VILLAR. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
/ 
r l LC-tuii i r\ui_. 
8 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR05\TUITI0N.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 

C
h
a
p
t
e
r 
4 — 
The Identification, 
Environment, 
and 
Data 
Divisions 
Figure 4,10 
Identification, Environment, and Data Divisions for Tuition Billing Program 
(continued) 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD STUDENT-FILE 
16 
RECORD CONTAINS 27 CHARACTERS. 
17 
01 STUDENT-RECORD. 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
18 
05 STU-NAME. 
19 
10 STU-LAST-NAME 
PIC X(15). 
20 
10 STU-INITIALS 
PIC XX. 
21 
05 STU-CREDITS 
PIC 9(2). 
22 
05 STU-UNION-MEMBER 
PIC X. 
23 
05 STU-SCHOLARSHIP 
PIC 9(4). 
24 
05 STU-GPA 
PIC 9V99. I 
'SiU-NAME 
is a group item with two elementary item 
s implied decimal point 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS. 
01 PRINT-LINE 
PIC X(132). 
WORKING-STORAGE SECTION. 
01 DATA-REMAINS-SWITCH 
PIC X(2) 
VALUE SPACES. 
01 
INDIVIDUAL-CALCULATIONS. 
05 
IND-TUITI0N 
05 
IND-ACTIVITY-FEE 
05 
IND-UNI0N-FEE 
05 
IND-SCHOLARSHIP 
05 
IND-BILL 
PIC 9(4) VALUE ZEROS. 
PIC 9\2/ 
VALUE ZEROS. 
PIC 9(2) VALUE ZEROS. 
PIC 9(4) VALUE ZEROS. 
PIC 9(6) VALUE ZEROS. 
PIC 9(6) VALUE ZEROS. 
PIC 9(4) VALUE ZEROS. 
PIC 9(4) VALUE ZEROS. 
PIC 9(6) VALUE ZEROS. 
PIC 9(6) VALUE ZEROS. 
PIC 9(3) VALUE 200. 
PIC 9(2) VALUE 25. 
PIC 99 
VALUE 25. 
PIC 99 
VALUE 6. 
PIC 99 
VALUE 50. 
99 
VALUE 12. 
PIC 99 
VALUE 75. 
PIC 9V9 
VALUE 2.5. 
- VALUE clauses initialize data names 
01 UNIVERSITY-TOTALS. 
05 UNI-TUITION 
05 UNI-UNION-FEE 
05 
UNI-ACTIVITY-FEE 
05 
UNI-SCHOLARSHIP 
05 UNI-IND-BILL 
01 
CONSTANTS-AND-RATES. 
05 
PRICE-PER-CREDIT 
05 UNION-FEE 
05 ACTIVITY-FEES. 
10 
1ST-ACTIVITY-FEE 
10 
1ST-CREDIT-LIMI1 
10 2ND-ACTIVITY-FEE 
1U 
CnU-^kWL 
I-LlHi I 
10 3RD-ACTIVITY-FEE 
05 
MINIMUM-SCHOLAR-GPA 
-Separate areas for heading and detail lines 
01 HEADING-LINE. 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
PIC X 
PIC X(12) 
PIC X(10) 
PIC X(7) 
VALUE SPACES. 
VALUE
 1 STUDENT NAME' 
VALUE SPACES. 
VALUE 'CREDITS'. 

The 
Tuition 
Bitting 
Program 
' ^ 
o. 
i J 
(continued) 
63 
05 FILLER 
64 
05 FILLER 
65 
05 FILLER 
66 
05 FILLER 
67 
05 FILLER 
68 
05 FILLER 
69 
05 FILLER 
70 
05 FILLER 
71 
05 FILLER 
72 
05 FILLER 
73 
05 FILLER 
74 
[75. 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
?L 
\W 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 ~ 
109 
110 
111 
112 
PIC X(2) 
PIC X(7) 
PIC X(2) 
PIC X(9) 
PIC X(2) 
PIC X(7) 
PIC X(2) 
PIC X(ll) 
PIC X(2) 
PIC X(10) 
PIC X(48) 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
SPACES. 
'TUITION'. 
SPACES. 
'UNION FEE'. 
SPACES. 
'ACT FEE'. 
SPACES. 
'SCHOLARSHIP'. 
SPACES. 
'TOTAL BILL'. 
SPACES. 
01 DETAIL-LINE. 
01 
05 FILLER 
PIC X 
VALUE SPACES 
05 DET-LAST-NAME 
PIC X(15) 
05 FILLER 
PIC X(2) VALUE SPACES 
05 DET-INITIALS 
PIC X(2). 
05 FILLER 
PIC X(5) VALUE SPACES 
05 DET-CREDITS 
DTP 
QfO\ 
05 FILLER 
PIC X(6) VALUE SPACES 
05 DET-TUITION 
PIC 9(6). 
05 FILLER 
PIC X(7) VALUE SPACES 
05 DET-UNION-FEE 
05 FILLER 
PIC X(6) VALUE SPACES 
05 DET-ACTIVITY-FEE 
PIC 9(3). 
05 FILLER 
PIC X(8) VALUE SPACES 
05 DET-SCHOLARSHIP 
PIC 9(5). 
05 FILLER 
PIC X(6) VALUE SPACES 
05 DET-IND-BILL 
PIC 9(6). 
05 FILLER 
PIC X(49) VALUE SPACES 
areas tor dash and total lines 
01 DASH-LINE. 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 
05 
TOTAL-LINE. 
FILLER 
FILLER 
VALUE 'U 
05 FILLER 
05 TOT-TUITION 
PIC X(31) VALUE SPACES. 
PIC X(8) VALUE ALL '-' 
PIC X(2) VALUE SPACES. 
PIC X(8) VALUE ALL '-' 
PIC X(2) VALUE SPACES. 
PIC X(7) VALUE ALL •-' 
PIC X(6) VALUE SPACES. 
PIC X(7) VALUE ALL '-' 
PIC X(5) VALUE SPACES. 
PIC X(7) VALUE ALL '-' 
PIC X(49) VALUE SPACES. 
PIC X(8) VALUE SPACES. 
PIC X(17) 
TOTALS'. 
PIC X(8) VALUE SPACES. 
PIC 9(6). 

C
h
a
p
t
e
r 
4 
The 
Identification, 
Environment, 
and 
Data 
Divisions 
Figure 4.10 
(continued) 
113 
05 FILLER 
PIC X(6) VALUE SPACES. 
114 
05 TOT-UNION-FEE 
PIC 9(4). 
115 
05 FILLER 
PIC X(5) VALUE SPACES. 
116 
05 TOT-ACTIVITY-FEE 
PIC 9(4). 
117 
05 FILLER 
PIC X(7) VALUE SPACES. 
118 
05 TOT-SCHOLARSHIP 
PIC 9(6). 
119 
05 FILLER 
PIC X(6) VALUE SPACES. 
120 
05 TOT-IND-BILL 
PIC 9(6). 
121 
05 FILLER 
PIC X(49) VALUE SPACES. 
The CONFIGURATION SECTION, SOURCE-COMPUTER, and OBJECT-
COMPUTER entries are optional in COBOL-85 but are required in COBOL-
74. The LABEL RECORDS clause is optional in COBOL-85 but is required in 
COBOL-74. 
The BLOCK CONTAINS clause is optional in both compilers, but its 
omission has different effects. Omitting the clause in COBOL-85 causes the 
system to take the blocking factor from the operating environment (and is 
equivalent to the IBM entry BLOCK CONTAINS 0 RECORDS). Omission of 
the clause in COBOL-74 defaults to the implementor-designated number, 
regardless of what was specified in the control statements to the operating 
system. 
COBOL-85 allows two new relationships, GREATER THAN OR EQUAL 
TO and LESS THAN OR EQUAL TO, in the condition portion of an IF statement. 
These were not allowed in COBOL-74, which used NOT LESS THAN as the 
equivalent of GREATER THAN OR EQUAL TO. 
The word FILLER is optional in COBOL-85, whereas it is required in 
COBOL-74. 
SUMMARY 
Points 
to 
Remember 
I I 
COBOL notation is the standardized form used to express permissible 
COBOL formats. Uppercase letters indicate COBOL reserved words, 
whereas lowercase letters denote programmer-supplied information. 
Brackets [ ] imply an optional entry, whereas braces { } indicate a choice 
between required entries. Any underlined item is required. 
The PROGRAM-ID paragraph is the only required entry in the Identification 
Division; the AUTHOR paragraph is strongly recommended. The 

Environment Division contains the FILE-CONTROL paragraph that defines 
the files used in a program through SELECT statements. 
The FILE SECTION contains a file description for every file previously 
defined in a SELECT statement in the Environment Division. The file 
description is followed by a record description to describe the fields within 
a file. 
The PICTURE clause indicates the size and type of a data name. An 
elementary item always has a PICTURE clause, whereas a group item 
does not. Level numbers assume values from 01 to 49 inclusive, with 01 
assigned to the record as a whole. Level numbers need not be assigned 
consecutive values. 
The WORKING-STORAGE SECTION contains additional record descriptions 
for data names not found in the FILE SECTION. VALUE clauses assign an 
initial value to a data name of a numeric literal, a nonnumeric literal, or a 
figurative constant. 
Key Words 
and 
Concepts 
Alphanumeric item 
Assumed (implied) decimal point 
Blocking factor 
Braces 
Brackets 
COBOL notation 
Detail line 
Elementary item 
Figurative constant 
File description 
Group item 
Heading line 
Level numbers 
Logical record 
Numeric item 
Physical record 
Record description 
Size 
Total line 
Type 
COBOL 
Elements 
ALL 
ASSIGN 
AUTHOR 
BLOCK CONTAINS 
DATA RECORD IS 
DATE-COMPILED 
DATE-WRITTEN 
FD 
FILE SECTION 
FILE-CONTROL 
FILLER 
INPUT-OUTPUT SECTION 
INSTALLATION 
LABEL RECORDS 
PICTURE 
PROGRAM-ID 
RECORD CONTAINS 
SECURITY 
SELECT 
SPACES 
VALUE 
WORKING-STORAGE SECTION 
ZEROS 

C
h
a
p
t
e
r 
4 
The 
Identification, 
Environment, 
and 
Data 
Divisions 
F I L L - I N 
1. The 
Division is the first division in a COBOL program. 
2. The 
paragraph is the only required entry in the Identification 
Division. 
3. In the COBOL notation, 
indicate that one of the enclosed elements 
must be included. 
4. Required reserved words are written in 
letters and are 
5. Lowercase letters indicate 
information. 
6. The Environment Division contains 
sections. 
7. The 
statement ties a programmer-chosen file name to a system 
name. 
8. A 
item is divided into one or more elementary items. 
9. An elementary item always has a 
clause. 
10. Level numbers appearing under a 01 record may range from 
to 
11. The Data Division contains the 
and 
sections. 
12. The presence of a V in a numeric picture indicates an 
, 
decimal 
point. 
13. Incoming numeric fields (may/may not) contain an actual decimal point. 
14. 
denotes a field that is not referenced by name. 
15. The 
specifies the number of 
records in one 
record. 
TRUE/FALSE 
1. The Identification Division may contain up to six paragraphs. 
2. The PROGRAM-ID paragraph is the only required paragraph in the Identification 
Division. 
3. Square brackets indicate a required entry. 
4. Braces imply that one of the enclosed entries must be chosen. 
5. A COBOL program that runs successfully on a PC would also run successfully on a 
mainframe with no modification whatever. 
6. A level number may assume any value from 01 to 49. 
7. A 01-level entry cannot have a PICTURE clause. 
8. All elementary items have a PICTURE clause. 
9. A group item may have a PICTURE clause. 
10. 01-level entries may appear in both the File and Working-Storage Sections of the 
L j a i a 
[ _ J I V I O I V _ M 
r. 

PROBLEMS 
11. A data name at the 10 level will always be an elementary item. 
12. A data name at the 05 level may or may not have a PICTURE clause. 
13. PICTURE, PICTURE IS, PIC, and PIC IS are all acceptable forms of the PICTURE 
clause. 
14. PICTURE IS 9(3) and PICTURE IS 999 are equivalent entries. 
15. The File Section is required in every C O B O L program. 
16. An incoming numeric field may contain an actual decimal point. 
17. The R E C O R D C O N T A I N S clause is required in an FD. 
1. Consider the accompanying time card. Show an appropriate record description for 
this information in C O B O L ; use any PICTURE clauses you think appropriate. 
Time-Record 
Name 
Number 
Date 
Hours 
First 
Middle 
Last 
Number 
MO 
DA 
f 
YR 
Hours 
2. In which division(s) do you find the 
a. P R O G R A M - I D paragraph? 
b. FILE-CONTROL paragraph? 
c. C O N F I G U R A T I O N SECTION? 
d. W O R K I N G - S T O R A G E SECTION? 
e. FILE SECTION? 
f. FD's? 
g. A U T H O R paragraph? 
h. DATE-COMPILED paragraph? 
i. INPUT-OUTPUT SECTION? 
j. File names? 
k. Level numbers? 
I. SELECT statements? 
m. V A L U E clauses? 
n. PICTURE clauses? 
3. Given the following record layout: 
01 EMPLOYEE-RECORD. 
05 SOC-SEC-NUMBER 
PIC 9(9). 
05 EMPLOYEE-NAME. 
10 LAST-NAME 
PIC X(12). 
10 FIRST-NAME 
PIC X(10). 
10 MIDDLE-INIT 
PIC X. 
05 FILLER 
PIC X. 
05 BIRTH-DATE. 
10 BIRTH-MONTH 
PIC 99. 
10 BIRTH-DAY 
PIC 99. 
10 BIRTH-YEAR 
PIC 99. 
05 FILLER 
PIC X(3). 

C
h
a
p
t
e
r 
4 
The 
Identification, 
Environment, 
and 
Data 
Divisions 
05 
EMPLOYEE-ADDRESS. 
1 A 
mi tUDcn_ AMrv„CTDircT 
15 HOUSE-NUMBER 
15 
STREET-NAME 
PIC X(6). 
PIC X(10). 
10 
CITY-STATE-ZIP. 
05 
FILLER 
15 CITY 
15 
STATE 
15 ZIP 
PIC X(10). 
PIC X(4). 
PIC 9(5). 
PIC X(3). 
a. List all group items. 
b. List all elementary items. 
c. State the record positions in which the following fields are found: 
• SOC-SEC-NUMBER 
« EMPLOYEE-NAME 
• 
LAST-NAME 
• 
FIRST-NAME 
« MIDDLE-INIT 
» 
BIRTH-DATE 
• BIRTH-MONTH 
• 
BIRTH-DAY 
• 
BIRTH-YEAR 
• EMPLOYEE-ADDRESS 
s 
NUMBER-AND-STREET 
• 
HOUSE-NUMBER 
• 
STREET-NAME 
K 
CITY-STATE-ZIP 
s CITY 
« STATE 
. 
Z|p 
4. Given the following record layout (assume that FIELD-I is the last entry under 
FIELD-A), 
01 
FIELD-A 
05 
FIELD-B 
10 FIELD-C 
10 
FIELD-D 
05 
FIELD-E 
05 
FIELD-F 
10 FIELD-G 
10 FIELD-H 
10 
FIELD-I 
answer true or false. 
a. FIELD-C is an elementary item. 
b. FIELD-E is an elementary item. 
c. FIELD-E should have a picture. 
d. FIELD-F should have a picture. 
e. FIELD-B must be larger than FIELD-C. 
f. FIELD-C must be larger than FIELD-D. 
g. FIELD-C must be larger than FIELD-H. 

h. FIELD-B and FIELD-D end in the same column. 
i. FIELD-A and FIELD-i end in the same column, 
j. FIELD-E could be larger than FIELD-F. 
k. FIELD-D could be larger than FIELD-E. 
I. FIELD-F and FIELD-G start in the same column. 
5. Use the C O B O L notation introduced at the beginning of the chapter and the 
general format of the FD entry to determine whether the following are valid FD 
entries. 
a. FD EMPLOYEE-FILE. 
b. FD EMPLOYEE-FILE 
BLOCK CONTAINS 10 RECORDS 
RECORD CONTAINS 100 CHARACTERS 
LABEL RECORDS ARE STANDARD 
DATA RECORD IS EMPLOYEE-RECORD. 
C. FD EMPLOYEE-FILE 
BLOCK 10 RECORDS 
RECORD 100 CHARACTERS 
LABEL RECORDS STANDARD 
DATA RECORD EMPLOYEE-RECORD. 
6. indicate whether each of the following entries is speiied correctly and whether it is 
syntactically valid. 
a. E N V I R O N M E N T DIVISION 
b. W O R K I N G - S T O R A G E - S E C T I O N 
c. IDENTIFICATION-DIVISION 
d. WRITTEN-BY 
e. DATA-DIVISION 
f. FILE SECTION 
g. P R O G R A M ID 
h. DATE-WRITTEN 
i. DATE-EXECUTED 
j. INPUT-OUTPUT SECTION 
k. FILE-CONTROL SECTION 
I. D A T E DIVISION 
m. C O M M E N T S 


Overview 
©PE&§ 
C L O S E 
READ 
Placement of the READ Statement 
WRITE 
STOP R U N 
M O V E 
Restrictions on the MOVE Statement 
Alphanumeric Field to 
Alphanumeric Field 
Numeric Field to Numeric Field 
Group Moves 
P E R F O R M 
IF 
The ELSE Clause 
Indentation 
E V A L U A T E 
Arithmetic S t a t e m e n t s 
The ROUNDED Clause 
The SIZE ERROR Clause 
COMPUTE 
ADD 
SUBTRACT 
MULTIPLY 
DIVIDE 
Programming Tip: Use the 
COMPUTE Statement 
Assumed Decimal Point 
T h e Tuition Billing P r o g r a m 
Test Data 
Hierarchy Chart 
C O B O L P r o g r a m S k e l e t o n 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
S 
The 
Procedure 
Division 
OBJECTIVES 
After reading this chapter you will be able to: 
M 
Write the OPEN, CLOSE, READ, and WRITE statements necessary for 
sequential file processing. 
I§ 
Describe the purpose of the priming (initial) READ statement, and place it 
correctly in the Procedure Division. 
• 
Discuss the rules of the MOVE statement as they apply to numeric and 
alphanumeric fields. 
M 
Describe the PERFORM statement; show how this statement is used to 
process a file until all of its records have been read. 
i£ 
Describe the IF statement and how it is used with and without an ELSE 
clause; explain the significance of the END-IF scope terminator. 
* 
Use the EVALUATE statement to implement a case (multibranch) construct. 
H 
State the hierarchy of operations for a COMPUTE statement; describe the 
individual arithmetic statements, ADD, SUBTRACT, MULTIPLY, and DIVIDE. 
M 
Describe the ROUNDED and SIZE ERROR options as they apply to any of 
the arithmetic statements. 
B 
Explain the relationship between a Procedure Division and its associated 
hierarchy chart. 
OVERVIEW 
This is a long chapter—the longest in the text. It focuses on the Procedure 
Division, which is the portion of a COBOL program that contains the logic. The 
chapter is long because it presents the many statements needed to write a basic 
program such as the tuition billing program introduced in Chapter 3. 
We begin with the COBOL statements used for I/O (input/output) operations; 
OPEN, CLOSE, READ, and WRITE, and continue with the STOP RUN statement 
to terminate program execution. We learn about the PERFORM statement to 
implement a loop, the IF statement to implement the selection structure, and the 
EVALUATE statement to implement a case structure. We study the MOVE 
statement to copy data from one location to another and end with the arithmetic 
statements: COMPUTE, ADD, SUBTRACT, MULTIPLY, and DIVIDE. 
The chapter concludes with the completed COBOL listing for the tuition 
billing program of Chapter 3. 
OPEN 
The OPEN statement initiates processing for a file. It indicates the nature of the file 
(input or output) and ensures that a specific device is available for the I/O operations. 
The OPEN statement also performs validation functions in conjunction with the LABEL 

RECORDS clause of the FD; for example, if label records are specified for an input file, 
the OPEN" statement checks the header label of that file to ensure that the proper file is 
available for processing. An abbreviated format of t h e OPEN s t a t e m e n t is: 
If INPUT 1 
OPEN \\ 
} file-name-1 . . 
(OUTPUT] 
The syntax of the OPEN statement indicates a mandatory selection for the 
type of file—INPUT is u s e d for a file that is read, whereas OUTPUT is u s e d for a file 
that is written to. The brackets and ellipsis associated with file-name-2 imply that 
multiple files can be o p e n e d in the s a m e statement as was d o n e in lines 43 and 44 of 
the engineering senior program in Figure 1.6: 
OPEN INPUT STUDENT-FILE 
OUTPUT PRINT-FILE. 
Each file referenced in an OPEN statement m u s t have b e e n previously defined in a 
SELECT statement in the Environment Division, and in a corresponding FD in the 
Data Division. All files m u s t b e o p e n e d before they can b e accessed; the operating 
system will terminate execution of a COBOL program that attempts to read (or 
write) an u n o p e n e d file. 
C L O S E 
The CLOSE statement is executed when access to a file is no longer necessary, such as 
when all records have been read from an input file or when all records have been written 
to an output file. The CLOSE statement releases the I/O devices associated with the file; 
it also writes trailer labels at the end of files on disk or tape in conjunction with the 
LABEL RECORDS clause of the FD. All open files should be closed before processing 
terminates. The format of the CLOSE is simply: 
CLOSE file-name-1 [, file-name-2 . . . ] 
The brackets and ellipsis associated with file-name-2 indicate that multiple 
files can be closed in the s a m e statement. The type of file, INPUT or OUTPUT, is not 
specified w h e n the file is closed because the distinction b e t w e e n input and output 
is n o longer important. Lines 51 and 52 in the engineering senior program provide 
an example: 
CLOSE STUDENT-FILE 
PRINT-FILE. 
A CLOSE statement can appear anywhere within a program but typically appears 
immediately before the program terminates, that is, immediately before the STOP 
RUN statement. 
READ 
The READ statement transfers data from an open file into memory, provided a record is 
available. If, however, no record is present—that is, the end-of-file condition has been 
reached—control passes to the statement(s) following the AT END clause. An abbreviated 
format of the READ statement is shown below: 
nmu i i i e-nanie 
AT END statement 
[END-READl 

C
h
a
p
t
e
r 
5 
The 
Procedure 
Division 
The END-READ scope terminator is optional but strongly r e c o m m e n d e d . The READ 
statement is illustrated in lines 45-47 of the engineering senior program. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
Placement ©f the R E A D Statement 
The e n g i n e e r i n g senior program in Figure 1.6 c o n t a i n e d t w o distinct READ 
statements. There was an initial, or priming, READ in lines 4 5 - 4 7 and a s e c o n d 
READ statement as the last instruction of the performed paragraph (lines 65-67). 
The necessity for both statements is explained b y considering Figure 5.1, which 
s h o w s correct and incorrect ways to process a file of transactions. 
Figure 5.1a, the incorrect implementation, causes the last record of INPUT-
FILE to be processed twice. To see h o w this happens, consider a file with only two 
records, A and B, realizing that such a file is read three t i m e s — o n c e for e a c h record 
and once to sense the e n d of file. Realize, too, that the PERFORM statement evaluates 
the UNTIL condition before branching (a detailed description of the PERFORM 
statement is found in an u p c o m i n g section). 
In Figure 5.1a, record A is read the first time PROCESS-RECORDS is performed, 
with execution continuing through the remainder of the PROCESS-RECORDS 
paragraph, at which point DATA-REMAINS-SWITCH is still set to 'YES'. Hence, 
PROCESS-RECORDS is executed a s e c o n d time, during which time it reads a n d 
processes record B. Since DATA-REMAINS-SWITCH is still set to 'YES', PROCESS-
RECORDS is executed a third time, during w h i c h the end-of-file condition is sensed 
immediately. Execution continues, however, to the e n d of the paragraph, causing 
the last record (record B) to b e processed twice. 
In the correct implementation of Figure 5.1b, an initial (priming) READ is 
executed before performing the paragraph PROCESS-RECORDS, which also contains 
a READ statement. The first time PROCESS-RECORDS is performed, it processes 
record A, and its last statement reads record B. Since DATA-REMAINS-SWITCH is 
still set to 'YES', PROCESS-RECORDS is executed a s e c o n d time to process record B, 
with the ending READ statement sensing the end-of-file condition. DATA-REMAINS-
SWITCH is set to 'NO', w h i c h in turn terminates the PERFORM statement. 
WRITE 
The WRITE statement transfers data from memory to the printer (or other open output 
device). Consider: 
WRITE record-name 
AFTER 
[BEFOREj 
ADVANCING integer 
PAGE 
LINE 
LINES 
The ADVANCING o p t i o n controls the line spacing o n a printer; for example, 
specification of AFTER ADVANCING 3 LINES produces triple spacing (the printer 
skips t w o lines a n d writes o n the third). Conversely, specification of the BEFORE 
option first writes the line, then skips the designated a m o u n t . Specification of 

WRITE 
PREPARE-TUITION-REPORT. 
MOVE 'YES' TO DATA-REMAINS-SWITCH. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
PROCESS-RECORDS. 
/ Hrst statement or performed paragraph is the REAU 
READ INPUT-FILE 
| , 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH Y 
END-READ. 
(a) Incorrect Implementation 
PREPARE-TUITION-REPORT. 
MOVE 'YES' TO DATA-REMAINS-SWITCH. 
irnmi READ is mmciAeci once and only once 
READ INPUT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
PROCESS-RECORDS. 
, Last statement o' performed paragraph is another READ 
READ INPUT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
(b) Correct If 
F i » u . * 6 « 
Placement of the READ Statement 

Chapter 
5 
The 
Procedure 
Division 
PAGE, in lieu of LINES, will cause output to begin o n top of a n e w page. Omission of 
the ADVANCING option defaults to single spacing. The examples below 
WRITE PRINT-LINE. 
WRITE PRINT-LINE 
AFTER ADVANCING 2 LINES. 
WRITE PRINT-LINE 
AFTER ADVANCING PAGE. 
will single space, double space, and advance to the top of a n e w page, respectively. 
The WRITE statement contains a record name, whereas the READ statement 
contains a file n a m e . The record n a m e in the WRITE statement will appear as a 01 
entry in the File Section of the Data Division. The file in w h i c h it is contained will 
appear in SELECT, FD, OPEN, and CLOSE statements. 
The format of the STOP RUN statement is simply: 
STOP RUN 
The STOP RUN statement terminates execution of a COBOL program and returns 
control to the operating system. [STOP RUN need not be (and typically is not) the 
last physical statement in the program.] All files should be closed prior to executing 
the STOP RUN statement. 
The MOVE statement copies data from o n e location to another; for example, the 
statement MOVE A TO B copies the value in location A to location B. The value of A 
is in two places after the m o v e has taken place, while the initial value of B is gone 
(having b e e n replaced by the value of A). The syntax of the MOVE statement is: 
[ i d e n t i f i e r - ll 
r 
, 
MOVE { 
)• TO identifier-2 
i d e n t i f i e r - 3 . . .  
[literal-1 
j ~
 
L 
J 
Consider the following examples: 
1. MOVE200 TO PRICE-PER-CREDIT. 
2. MOVE 'ABC UNIVERSITY' TO SCHOOL-NAME. 
3. MOVE STU-NAME TO PRINT-NAME. 
4. MOVE ZEROS TO TOTAL-NUMBER. 
5. MOVE SPACES TO PRINT-LINE. 
Example o n e m o v e s a numeric literal, 200, to the data n a m e PRICE-PER-
CREDIT. Example two m o v e s a n o n n u m e r i c literal, 'ABC UNIVERSITY', to SCHOOL-
NAME. Example three c o p i e s data from an input area to an output area for 
subsequent printing. Examples four and five use the figurative constants, ZEROS 
and SPACES, to initialize a counter and print line, respectively. 
The brackets and ellipsis associated with identifier-3 in the COBOL syntax 
indicate the s a m e item can b e m o v e d to multiple data n a m e s . Thus the single 
statement: 
MOVE 10 TO FIELD-A FIELD-B FIELD-C. 

is equivalent to the three individual statements: 
MOVE 10 TO FIELD-A. 
MOVE 10 TO FIELD-B. 
MOVE 10 TO FIELD-C. 
The results of a MOVE statement d e p e n d o n the type of data in the sending a n d / o r 
receiving field. We concentrate initially o n MOVE statements involving only 
elementary items, since these statements are by far the m o s t c o m m o n . Recall (from 
Chapter 4) that elementary data items may be of four types: 
Numeric 
Numeric data items, numeric literals, and the figurative 
constants, ZERO, ZEROS, or ZEROES. 
Alphabetic 
Alphabetic data items and the figurative constants, 
SPACE and SPACES 
Alphanumeric 
Alphanumeric data items, nonnumeric literals and the 
figurative constants, SPACE and SPACES 
Numeric Edited 
Numeric edited data items (to be discussed in Chapter 7) 
In theory a MOVE statement could involve any combination of these four 
types; in actuality, however, certain types of m o v e s are not permitted as indicated 
by Table 5.1. (You do not have to c o m m i t the table to memory; simply be aware that 
certain restrictions exist, and k n o w where to turn should questions arise later.) 
i 
Rules of the MOVE Statement (Elementary Data Items) 
A l p h a b e t i c 
Valid 
Valid 
Invalid 
Invalid 
A l p h a n u m e r i c 
Invalid 
Valid 
Invalid 
Invalid 
N u m e r i c 
Invalid 
Integers only 
Valid 
Valid 
N u m e r i c E d i t e d 
Invalid 
Valid 
Valid 
Invalid 
At first glance Table 5.1 s e e m s overwhelming, but a second look shows it to 
make intuitive sense. You cannot, for example, m o v e an alphanumeric field to an 
alphabetic field (because the alphanumeric field m a y contain n u m b e r s , which are 
invalid in an alphabetic field). You can, however, do the m o v e in the opposite 
direction; that is, y o u can m o v e an alphabetic field to an alphanumeric field. 
Even Table 5.1 d o e s not tell us everything w e n e e d to k n o w about the MOVE 
statement. What happens, for example, w h e n m o v e s with like fields (an alphanumeric 
sending field to an alphanumeric receiving field) involve PICTURE clauses of different 
lengths? Additional explanation is required as explained in the next t w o sections. 
Data moved from an alphanumeric field to an alphanumeric field are moved one 
character at a time from left to right. If the receiving field is larger than the sending 
field, it is padded o n the right with blanks; if the receiving field is smaller than the 
sending field, the rightmost characters are truncated. 
Alphanumeric m o v e s are illustrated in Table 5.2. Example (a) is trivial, in that 
the sending a n d receiving fields have the s a m e picture clause. In e x a m p l e (b) the 
sending field is o n e character longer than the receiving field; h e n c e the rightmost 

Chapter 
5 
The 
Procedure 
Division 
character is truncated. Data are m o v e d from left to right o n e character at a time; 
thus A, B, C, and D are m o v e d in that order, and E is dropped. In example (c), 
however, the receiving field is o n e character longer than the sending field. A, B, C, 
D, and E are m o v e d in that order, and a blank is a d d e d at the right. 
T A B L E 
5 , 2 
Illustration of the MOVE Statement: Alphanumeric Sending Field to 
Alphanumeric Receiving Field 
M C T O T R E 
(a) 
X(5) 
C O N T E N T S 
(b) 
(c) 
X(5) 
X(5) 
A B 
C [ D j E 
A B I C 
D E 
A B C 
• I C T I J H E 
X(5) 
X(4) 
X(6) 
f E M T S 
A B C | D E 
A j B C D 
A B C D E 
All moves involving numeric fields maintain decimal alignment. If the integer portion 
of the receiving field is larger than that of the sending field, high-order (insignificant) 
zeros are added to the receiving field. If, however, the integer portion of the receiving 
field is smaller than that of the sending field, the high-order (significant) digits of 
the sending field are truncated. 
In similar fashion if the decimal portion of the receiving field is larger than 
that of the sending field, low-order zeros are added. And finally, if the decimal 
portion of the receiving field is smaller than that of the s e n d i n g field, the extra 
positions are truncated. These points are clarified in Table 5.3. 
Illustration of the MOVE Statement: Numeric Sending Field to 
Numeric Receiving Field 
P I C T U R E 
c 
-
i. 
(a) 
9(5) 
1 2 3 4 5 
9(5) 
1 2 3 4 5 
(b) 
9(5) 
1 2 3 4 5 
9(4) 
2 3 4 5 
(c) 
9(5) 
2 3 4 5 
9(6) 
0 1 2 3 4 5 
V 
(d) 9(3)V99 
1 2 3 4 1 5 
9(3) 
1 2 3 
— v — 
(e) 9(3)V99 
1 
1 2 3 4 5 
9V99 
3 4 5 
V 
(f) 
9(3) 
1 2 3 
9(3)V99 
1 2 3 0 0 
Example (a) is trivial. Example (b) attempts to m o v e a 
five-position 
field 
to a 
four-position field. Since decimal alignment is always maintained, the leftmost 
digit (i.e., the most significant digit) is truncated. Example (c) m o v e s a 
five-position 
sending field to a six-position receiving field, causing the addition of a leading 
(nonsignificant) zero. The s e n d i n g field in example (d) has t w o digits after the 
decimal point, but the receiving field has n o n e . H e n c e the 4 a n d 5 d o not appear in 
the receiving field. Example (e) truncates the m o s t significant digits. Example (f) 
adds two nonsignificant zeros to the receiving field. 

The preceding discussion concerned M O V E statements in which the receiving field 
was an elementary item. T h e results are very different if a group item is involved, 
because if the receiving field is a group item, the move takes place as though the 
receiving field were an alphanumeric item, with padding or truncation on the right 
as necessary. M O V E statements involving group items often produce unexpected 
results a n d should be avoided. 
The P E R F O R M statement transfers control to a procedure (paragraph) elsewhere in the 
program, allowing the program to be divided into functional modules. A n abbreviated 
format of the PERFORM statement is: 
PERFORM procedure-name 
[UNTIL condition] 
Consider first the statement without 
an UNTIL clause as illustrated below: 
COMPUTE TUITION = CREDITS * CHARGE-PER-CREDIT. 
r 
- PERFORM WRITE DETAIL-LINE. 
WRITE-DETAIL-LINE. 
j 
MOVE STUDENT-NAME TO PRINT-NAME. 
I 
MOVE TUITION TO PRINT-TUITION. 
\ 
WRITE PRINT-LINE AFTER ADVANCING 2 L I N E S . —
J 
WRITE-TOTAL-LINE. 
The statement P E R F O R M WRITE-DETAIL-LINE transfers control to the first 
statement in the paragraph WRITE-DETAIL-LINE. W h e n every statement in W R I T E -
D E T A I L - L I N E has b e e n executed (i.e., w h e n the next paragraph n a m e is 
encountered), control returns to the statement immediately after the original 
P E R F O R M , in this case, to the A D D statement. 
A loop (iteration) is implemented through inclusion of an U N T I L clause. The 
condition in the U N T I L clause is tested before the paragraph is executed, and if the 
condition is not met, control is transferred to the designated paragraph. W h e n the 
paragraph has completed execution, the condition is retested, and if it (the condition) 
is still not met, the paragraph is executed a second time. The process continues 
until the condition is finally satisfied. Consider: 
PERFORM PROCESS-RECORDS 
ADD 1 TO NUMBER-OF-STUDENTS. 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
PROCESS-RECORDS. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 

C
h
a
p
t
e
r 
5 
-
The 
Procedure 
Division 
T h e paragraph P R O C E S S - R E C O R D S is executed repeatedly until D A T A -
REIvLAJNS-SWITCH equals 'NO', that is, until there are no m o r e incoming records. 
The last statement of the performed paragraph is a R E A D statement, so that w h e n 
the e n d of file is reached, D A T A - R E M A I N S - S W I T C H will be set to 'NO'. This causes 
the next test of the U N T I L condition to be successful a n d prevents further execution 
of the P R O C E S S - R E C O R D S paragraph. 
IF 
The IF statement is one of the most powerful statements in C O B O L . Our present concern, 
however, is with only a few of the available options, with additional consideration 
deferred to Chapter 8. A n abbreviated format of the IF statement is 
J_F condition THEN 
statement-1 
[ELSE 
statement-2 ] 
[END-IFl 
The IF statement is terminated by the optional (but highly recommended) E N D - I F 
scope terminator and/or a period. Consider: 
IF STU-CREDITS > 110 AND STU-MAJOR = 'ENGINEERING' 
MOVE STU-NAME TO PRINT-NAME 
MOVE STU-CREDITS TO PRINT-CREDITS 
MOVE STU-GPA TO PRINT-GPA 
WRITE PRINT-LINE 
END-IF. 
If the condition is true, then every statement between the IF (condition) and 
the END-IF (and/or period) will be executed. Hence, w h e n an engineering senior is 
processed, three M O V E statements a n d one W R I T E statement are executed. If, 
however, the condition is false, then all four statements—three M O V E s and a 
W R I T E — a r e bypassed. 
As indicated, the IF statement is terminated by the E N D - I F scope terminator 
and / or a period, a n d the inclusion of both appears redundant. (Many programmers 
do, however, use both entries.) END-IF, despite the fact that it is a n optional entry, 
has distinct advantages (as will be explained in Chapter 7) a n d should be used in 
every instance. 
The E L S E Clause 
The ELSE clause is optional as implied by the square brackets in its syntax. Figure 5.2a 
contains an E L S E clause, whereas it is omitted in Figure 5.2b. If the condition in 
Figure 5.2a is true, statement-1 is executed; whereas if it is false, statement-2 is 
executed—in either case execution continues with statement-3. Figure 5.2b, however, 
omits the E L S E clause so that if the condition is false, the IF statement is terminated 
immediately. 
Indentation 
Indentation in an IF statement is extremely important to emphasize a programmer's 
understanding of a statement's intended effect. Consider Figure 5.3, which contains 
a flowchart a n d corresponding C O B O L code. 

Figure 5.2 The IF Statement 
STATEMENT, 
STATEMENT 
STATEMENT, 
fa) With E L S E Option 
STATEMENT, 
STATEMENT, 
(a) Without E L S E Option 
The flowchart in Figure 5.3a indicates that if the condition A - B is true, the 
statements M O V E I T O C and M O V E 1 T O I) are to be executed. If, however, the 
condition is false, then the statements M O V E Z E R O T O C and M O V E Z E R O T O D are 
to be executed instead. In either case—that is, whether the condition is true or 
false—we are to write a detail line. T h e latter is indicated by the IF and E L S E 
branches meeting in a c o m m o n exit point, which leads to the final W R I T E statement. 
The C O B O L code in Figure 5.3b is carefully aligned to reflect this interpretation. 
Recall that the rules of C O B O L require only that an IF statement appear in the B 
margin, that is, in columns 12-72. Hence the indentation in Figure 5.3b is done 
solely for the purpose of making a program easier to read, rather than to satisfy a 

C
h
a
p
t
e
r 
5 
The 
Procedure 
Division 
;ig.5ta S.J 
The ELSE Clause/ll 
FALSE 
1 
> 
MOVE ZERO 
TOC 
• • 
MOVE ZERO 
TOD 
TRUE 
f 
MOVE 1 
TOC 
> f 
MOVE 1 
TOD 
X 
WRITE 
DETAIL-LINE 
MOVE 1 TO C 
MOVE 1 TO D 
ELSE 
MOVE ZERO TO C 
MOVE ZERO TO D 
END-IF. 
WRITE DETAIL-LINE. 
b ) COBOL Code 
rule of C O B O L . Nevertheless, proper indentation is essential a n d goes a long w a y to 
improve the quality of your work. Accordingly, w e suggest the following guidelines: 
1. Begin the IF statement in column 12. 
2. Put the w o r d ELSE o n a line by itself a n d directly under the IF. 
3. Indent detail lines associated with either the IF or ELSE four columns. 
4. Put 1-ND-IF o n a line by itself directly under the IF statement. 

1 he EVALUATE statement implements the case (rnultibranch) construct of 
structured programming. It has what first appears to be a rather complicated syntax, 
but in actuality is quite easy to use. Consider: 
identi fier-1 
EVALUATE expression-
TRUE 
FALSE 
WHEN 
condition-1 
TRUE 
FALSE 
imperati ve-statement - 1 
[WHEN OTHER imperative-statement.-2] 
[END-EVALUATE] 
A n example of the E V A L U A T E statement is s h o w n below in conjunction with the 
tuition billing program presented in Chapter 3. The specifications for the program 
indicate that activity fee is dependent o n the n u m b e r of credits ($25 for 6 credits or 
fewer, $50 for 7 to 12 credits, and $75 for 13 credits or more). Consider: 
EVALUATE TRUE 
WHEN STU-CREDITS <= 6 
MOVE 25 TO IND-ACTIVITY-FFF 
WHEN STU-CREDITS > 6 AND STU-CREDITS <= 12 
MOVE 50 TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 12 
MOVE 75 TO IND-ACTIVITY-FEE 
END-EVALUATE. 
The different conditions (i.e., the ranges for the n u m b e r of student credits) are 
presented in the various W H E N clauses. T h e E N D - E V A L U A T E scope terminator is a 
required entry. 
C O B O L does arithmetic in one of two ways. It has individual statements for the 
basic arithmetic operations (addition, subtraction, multiplication, a n d division), 
and a C O M P U T E statement that combines multiple operations into one statement. 
As you shall see, the C O M P U T E statement is generally easier to use, a n d so w e begin 
with it. Note, too, that all of these statements have optional R O U N D E D and SIZE 
E R R O R clauses, which are discussed prior to the individual statements. 
Th© Rt Li.vl'-j-cJ/ C.~.se 
The R O U N D E D clause (in any arithmetic statement) causes C O B O L to carry a 
calculation to one m o r e decimal place than is specified in the result field. If the 
value of the extra decimal place is 5 or larger, the answer is rounded up; if it is 4 
or less, the answer is unchanged. If the R O U N D E D clause is omitted, C O B O L 
truncates any extra decimal positions regardless of their value. Table 5.4 shows 
the effect of the R O U N D E D option in which the values of A and B are added to 
produce a value for C. 

C
h
a
p
t
e
r 
5 
The 
Procedure 
Division 
The ROUNDED Clause 
Value before execution 
123 
Value after execution of 
ADD A B GIVING C 
123 
ADD A B GIVING C ROUNDED 
123 
Both of the examples in Table 5.4 add the same numbers (1.23 a n d 4.56) to produce 
a s u m of 5.79. Both examples also specify the s a m e P I C T U R E clause for the sum, 
which contains only a single decimal place. T h e first statement, however, does not 
contain the R O U N D E D clause, a n d hence the .09 is truncated, leaving 5.7 as the 
final answer. The second example contains the R O U N D E D clause, producing a 
m o r e accurate 5.8. 
The SIZE E R R O R clause is available for all arithmetic statements and produces a 
warning w h e n the result of calculation is too large for the designated field. Consider: 
05 HOURLY-RATE 
PIC 99. 
05 HOURS-WORKED 
PIC 99. 
05 GROSS-PAY 
PIC 999. 
COMPUTE GROSS-PAY = HOURLY-RATE * HOURS-WORKED. 
Let us assume that H O U R L Y - R A T E and H O U R S - W O R K E D are 25 a n d 40, 
respectively. The result of the multiplication should be 1,000. GROSS-PAY, however, 
is defined as a three-position numeric field a n d is too small to hold the result. 
Hence its value is truncated a n d only the three rightmost digits are retained; in 
other words, G R O S S - P A Y becomes 000. 
The situation is prevented by the inclusion of the SIZE E R R O R clause: 
COMPUTE GROSS-PAY = HOURLY-RATE * HOURS-WORKED 
ON SIZE ERROR PERFORM ERROR-ROUTINE 
END-COMPUTE. 
This time, if the results of the computation are too large a n d exceed the size 
allotted in the P I C T U R E clause, control passes to the statement(s) following the 
SIZE E R R O R clause. The latter contains a n error routine to display an error message 
or take other corrective action. 
The C O M P U T E statement combines multiple arithmetic operations into a single 
statement of the form: 
COMPUTE {identifier-1 [RQtJNDED]} • • • = expression-1 
[ON SIZE ERROR imperative-statement-1] 
fEND-COMPUTEl 
The C O M P U T E statement first calculates the value of the expression o n the right 
side of the equal sign, then stores that value in the data n a m e o n the left. T h e 
#99 
456 
(immaterial) 
456 
57 
456 
58 

Arithmetic 
Statements 
expression within the C O M P U T E statement consists of data names, numeric literals, 
arithmetic symbols, and parentheses. Spaces should precede and follow arithmetic 
symbols. A space is also required before a left parenthesis a n d after a right 
parenthesis. 
Parentheses are used to clarify, a n d in s o m e cases, alter the sequence of, 
operations within a n expression, but anything contained within parentheses must 
also be a valid expression. Expressions are evaluated according to the following 
rules: 
1. Anything contained in parentheses is evaluated first as a separate 
expression. 
2. The symbols +, -, *, /, and ** denote addition, subtraction, multiplication, 
division, and exponentiation, respectively. Exponentiation is done first, then 
multiplication or division, then addition or subtraction. 
3. If rule 2 results in a tie (e.g., if both multiplication and division are present), 
then evaluation proceeds from left to right. 
Table 5.5 contains examples to illustrate the formation a n d evaluation of 
expressions in a C O M P U T E statement. 
TAI1LE S.M The COMPUTE instruction 
Value before execution 
2 
Value after execution of 
COMPUTE C = A + B. 
2 
COMPUTE C = A + B * 2. 
2 
COMPUTE C = (A + B) * 2. 
2 
COMPUTE C = A** B. 
2 
COMPUTE C = B " A. 
2 
10 
Initial Values 
Simple addition 
Multiplication before addition 
Parenthesis evaluated first 
Algebraically, c = a
0 
Draically, c = b
a 
Table 5.6 should further clarify the use of this all-important statement. This 
table contains several algebraic expressions a n d the corresponding C O M P U T E 
statements to accomplish the intended logic. 
- , 
„ . . 
The COMPUTE Instruction 
(continued) 
x = a + b 
a + b 
x = -
(a + £>)c 
2 
a + b 
2c 
x = Va 
COMPUTE X = A + B. 
COMPUTE X = (A + B) / 2 . 
COMPUTE X = ( A + B ) * C / 2 . 
COMPUTE X = (A + B) / (2 * C ) . 
COMPUTE X = A * * . 5 . 
COMPUTE X = (A * * 2 + 
2) / C 

Chapter 
S ----- 
The 
Procedure 
Division 
A Di •D 
The A D D statement has two basic formats: 
[ i d e n t i f i e r - l j 
^ 
] i d e n t i f i e r - 2 ] 
[ l i t e r a l - 1 
J 
[ l i t e r a l - 2 
J 
GIVING j i d e n t i f i e r - 3 [ROUNDED]! . . . 
[ON SIZE ERROR imperative- statement - l] 
[END-ADD] 
In the first format the value of identifier-2 is replaced by the result of the 
addition; in the second format the value of identifier-2 is unchanged, because the 
result is stored in identifier-3 (and beyond). T h e word T O is required in the first 
format, but optional in the second. The three dots in either format indicate that 
identifier-1 or literal-1 can be repeated as m a n y times as necessary (so that multiple 
items can be added together.) 
Examples 5.1 and 5.2 illustrate the A D D statement. The first instruction adds 
the values of A a n d B (5 a n d 10) to the value of C (20), a n d puts the s u m of 35 back 
into C. Example 5.2, however, does not include the initial value of C in the calculation; 
it adds the values of A a n d B (5 a n d 10), a n d places the s u m of 15 in C. 
Example 5.1 
A D D A B T O C 
B 
C 
After 
execution: 
B e f or & 6 x ecutio 11: 
Example 5.2 
A D D A T O B G I V I N G C 
A 
B 
C 
After 
execution: 
Before 
execution: 
Table 5.7 contains additional examples of the A D D statement, with all examples 
operating o n the initial values of A, B, a n d C (5, 10, a n d 30, respectively). T h e last 
example changes the values of both B a n d C. 

Arithmetic 
Statements 
L _ ft,V The ADD Instruction 
Value before execution 
5 
10 
30 
Value after execution of 
ADD A TO C. 
5 
10 
35 
ADD A B TO C. 
5 
10 
45 
ADD A TO B GIVING C 
5 
10 
15 
ADD A 18 B GIVING C. 
5 
10 
33 
ADD A 18 B T O C . 
5 
10 
63 
ADD 1 TO B C. 
5 
11 
31 
The SUBTRACT statement has two formats: 
fidentifier-l] 
r 
r 
yi 
SUBTRACT { 
) . . . FROM ndentifier-2 
IROUNDED\>  
[literal-1 
J 
1
 
1 
Ji 
[ON S I Z E ERROR imperative - statement -1] 
[END-SUBTRACT] 
fidentifier-l] 
fidenti fier-2 
S U B T R A C T \ 
\ . . . FROM 
literal-1 
j 
(literal-2 
G I V I N G {identifier-3 [ROUNDED]] . . . 
[ON S I Z E ERROR imperative-statement-l] 
[END-SUBTRACT] 
In the first format the initial value of identifier-2 is replaced by the result of the 
subtraction. In the second format the initial value of either identifier-2 or literal-2 is 
unchanged, as the result is stored in identifier-3 (and beyond). 
Examples 5.3 a n d 5.4 illustrate the S U B T R A C T statement. In Example 5.3 the 
S U B T R A C T statement causes the value of A (5) to be subtracted from the initial 
value of B (15) and the result (10) to be stored in B. Only the value of B w a s changed. 
In the F R O M ... G I V I N G format of Example 5.4 the value of A (5) is subtracted 
from the value of B (15), a n d the result (10) is placed in C. The values of A and B are 
unchanged, a n d the initial value of C (100) is replaced by 10. Table 5.8 contains 
additional examples. 
Example 5.3 
S U B T R A C T A 
FROM B 
A 

C
h
a
p
t
e
r 
5 
— 
The 
Procedure 
Division 
Example 5.4 
SUBTRACT A 
FROM B 
B e f o r e 
e x e c u t i o n : 
A f t e r 
e x e c u t i o n : 
G I V I N G C 
A 
B 
T A B L E 5.8 The SUBTRACT Instruction 
[15] 
100 
10 
Value before execution 
5 
Value after execution of 
SUBTRACT A FROM C. 
5 
SUBTRACT A B FROM C. 
5 
SUBTRACT A B FROM C GIVING D. 
5 
SUBTRACT 10 FROM C D . 
5 
10 
10 
10 
10 
10 
30 
25 
15 
30 
20 
100 
100 
100 
15 
90 
M U L T I P L Y 
T h e MULTIPLY statement has two formats: 
[identi f i e r - 1 ! 
r 
,- 
v, 
M U L T I P L Y { 
\ BY {identifier-2 
ROUNDEDU . . . 
[literal-1 
J - l
 
1 
JJ 
[ON S I Z E ERROR 
imperative-statement-l] 
[END-MULTIPLY] 
[identifier- l| 
[identifier-2| 
M U L T I P L Y { 
} BY { 
} 
[literal-1 
J " [literal-2 
J 
G I V I N G | i d e n t i f i e r - 3 [RQUNDEP][ . . . 
[ON S I Z E E R R O R imperative-statement-l] 
[END-MULTIPLY] 
If GIVING is used, then the result of the multiplication is stored in identifier-3 
(and beyond). If GIVING is omitted, then the result is stored in identifier-2 (and 
beyond). 
Example 5.5 
M U L T I P L Y A BY B 
A 
B 
B e f o r e 
e x e c u t i o n : 

Example 5.6 
MULTIPLY A BY B GIVING C 
A n 
jlOj 
j 10) 
|20j 
|20i 
345 
2001 
Table 5.9 contains additional examples of the M U L T I P L Y statement. As in the 
previous examples, the instructions operate o n the initial values of A, B, a n d C. 
TABLE 5..S The MULTIPLY Instruction 
Value before execution 
Value after execution of 
MULTIPLY B BY A GIVING C. 
MULTIPLY A BY B GIVING C. 
MULTIPLY A BY B. 
MULTIPLY B BY A. 
MULTIPLY A BY 3 GIVING B C 
5 
10 
30 
5 
10 
50 
5 
10 
50 
5 
50 
30 
50 
10 
30 
5 
15 
15 
The DIVIDE statement has two formats. In the second format, the primary distinction 
is between the words B Y and INTO, which determine whether identifier-2 is the 
divisor or the dividend. As with the other arithmetic statements, the G I V I N G option 
implies that the result is stored in identifier-3 so that the initial value of identifier-2 
or literal-2 is unchanged. Only the second format makes explicit provision for 
storing the remainder. 
[identifier-1] 
r 
, 
ii 
DIVIDE \ 
\ INTO identifier-2 ROUNDED . . . 
— 
[literal-1 
J 
I
 
1 
JJ 
[ON SIZE ERROR imperati ve - statement - lj 
[END-DIVIDEl 
fidentifier-ll [INTO] [identifier-2] 
r 
r 
o 
DIVIDE i 
\ I 
[ <^ 
\ GIVING identifier-3 [ROUNDED . . . 
" 
[literal-1 
j [BY j [literal-2 
J 
1
 
1 
JJ 
[REMAINDER identifier-4] 
[ON SIZE ERROR imperati ve - statement -1] 
[END-DIVIDE] 
In Example 5.7 the value of B (50) is divided by the value of A (10), and the 
quotient (5) replaces the initial value of B. In Example 5.8, which uses the GIVING 
option, the quotient goes into C, the remainder into D, and the values of A a n d B are 

C
h
a
p
t
e
r 
5 
The 
Procedure 
Divisio 
The COMPUTE statement should always be used when multiple arithmetic operators are involved. 
Consider two sets of equivalent code: 
MULTIPLY B BY B GIVING B-SQUARED. 
MULTIPLY 4 BY A GIVING FOUR-A. 
MULTIPLY FOUR-A BY C GIVING FOUR-A-C. 
SUBTRACT FOUR-A-C FROM B-SQUARED GIVING RESULT-1. 
COMPUTE RESULT-2 = RESULT-1 ** .5. 
SUBTRACT B FROM RESULT-2 GIVING NUMERATOR. 
MULTIPLY 2 BY A GIVING DENOMINATOR. 
DIVIDE NUMERATOR BY DENOMINATOR GIVING X. 
COMPUTE X = (-B + (B ** 2 - (4 * A * C)) ** .5) / (2 * A). 
Both sets of code apply to the quadratic formula, 
•B + 4¥~-4AC 
It is fairly easy to determine what is happening from the single COMPUTE statement, but next to 
impossible to realize the cumulative effect of the eight arithmetic statements. Interpretation of the unacceptable 
code is further clouded by the mandatory definition of data names for intermediate results, RESULT-1, 
RESULT-2, etc. 
Parentheses are often required in COMPUTE statements to alter the normal hierarchy of operations; for 
example, parentheses are required around 2 * A in the denominator. If they had been omitted, the numerator 
would have been divided by 2 and then the quotient would have been multiplied by A. Sometimes the 
parentheses are optional to the compiler but should be used to clarify things for the programmer. The 
parentheses around 4 * A * C do not alter the normal order of operations and hence are optional. 
Individual arithmetic statements are preferable to the COMPUTE statement when only a single operation 
is required. Hence, ADD 1 TO COUNTER is easier to read than COMPUTE COUNTER = COUNTER + 1. 
P R O G R A M M 
I N C 
T I P 

unaffected. Example 5.9 parallels 5.8 except that B Y replaces INTO, resulting in a 
quotient of zero and a remainder of 10. Table 5.10 contains additional examples of 
the DIVIDE statement. 
Example 5.7 
DIVIDE A INTO B. 
10| 
[501 
I 5 I 
Example 5.8 
DIVIDE A INTO B GIVING C REMAINDER D. 
|10| 
|51| 
|10! [51I 
} 13 j 
5 I 
Example 5.9 
DIVIDE A BY B GIVING C REMAINDER D. 
,10, 
The DIVIDE Instruction 
\Sl\ 
Value before execution 
Value after execution of 
DIVIDE 2 INTO B. 
DIVIDE 2 INTO B GIVING C. 
DIVIDES BY 5 GIVING A. 
DIVIDE A INTO B C. 
DIVIDE A INTO B GIVING C. 
DIVIDE 3 INTO A GIVING B REMAINDER C. 
10 
5 
10 
10 
2 
10 
1 
30 
30 
5 
30 
6 
2 
2 
Arithmetic is performed o n decimal as well as integer fields. Y o u must be aware of 
the decimal point, and in particular, be sure to define the field holding the result with 
a sufficient number of decimal places. Consider Example 5.10, in which A and B have 
pictures of 99 a n d 99V9, respectively. 
Example 5.10 ADD A TO B. 

C
h
a
p
t
e
r 
S 
The 
Procedure 
Division 
In the example, field B is stored with an implied decimal point. The compiler 
generates instructions to add an integer n u m b e r (12) to a n u m b e r with one decimal 
place (34V5). It maintains decimal alignment, obtains 46V5 as a n answer, a n d stores 
the result in field B. 
N o w consider what happens if the operation is reversed, that is, A D D B T O A. 
The result of the addition is still 46V5; however, the field that stores the s u m , A, is 
denned without a decimal point; hence, the .5 will be truncated. It is critical, therefore, 
to define the receiving field with a sufficient number of decimal places. Table 5.11 
contains additional examples. In each instance the instruction is assumed to operate 
o n the initial values of A, B, and C. 
? A&L.E 5 . 1 1 Arithmetic on Fields with Assumed Decimal Points 
P I C T U R E 
9 9 
99V9 
S 3 V S I 
Value before execution 
12 
345 
4712 
Value after execution of 
ADD B TO A. 
46 
345 
4712 
ADD A TO B. 
12 
465 
4712 
ADD B TO C. 
12 
345 
8162 
ADD C TO B. 
12 
816 
4712 
ADD C TO A. 
59 
345 
4712 
ADD A TO C. 
12 
345 
5912 
Tlte YiJiti©tl 
The tuition billing program w a s first presented in Chapter 3, where w e produced 
Biliii/ijj Pf €t jjsffiBtfi
 
m
e hierarchy chart, pseudocode, and stubs program. W e continued the development 
of the program in Chapter 4, with specifics of the Identification, Environment, a n d 
Data divisions. N o w w e are able to write the Procedure Division and complete the 
program. 
W e emphasize, however, that the Procedure Division is not written from 
scratch, but is developed from work already done in Chapters 3 and 4. Consider, 
therefore, Figure 5.4, which contains the hierarchy chart and detailed pseudocode, 
and most importantly the already working stubs program. T h e stubs program is 
complete in the sense that it contains all of the paragraphs needed for the eventual 
program; it is incomplete because m a n y of its paragraphs exist as one sentence 
DISPLAY statements that need to be expanded to perform the indicated task. T h e 
most difficult work has already been done, however, because the testing in Chapter 3 
demonstrated that the overall program flow is correct. 
Thus, it is relatively simple to expand the various stub paragraphs in favor of 
m o r e detailed Procedure Division statements presented in this chapter. T h e 
paragraphs can be implemented one (or several) at a time; for example, begin with 
the paragraph to write a heading line, expand it, then lest it to be sure it executes 
correctly. Develop the paragraph to write a detailed line, then expand the paragraphs 
to compute the individual amounts (tuition, union fee, activity fee, and scholarship), 
testing each paragraph to be sure it works properly. Finally, a d d the paragraphs to 
increment the university totals and write the s u m m a r y line at the end of the report. 
T h e completed p r o g r a m is s h o w n in Figure 5.5. T h e Identification, 
Environment, and Data divisions were developed at the end of Chapter 4 and are 

The 
Tuition 
Billing 
Program 
PREPARE 
TUITION 
REPORT 
WRITE 
HEADING 
LINE 
READ 
STUDENT 
FILE 
PROCESS 
STUDENT 
RECORD 
WRITE 
UNIVERSITY 
TOTALS 
COMPUTE 
INDIVIDUAL 
BILL 
INCREMENT 
UNIVERSITY 
TOTALS 
WRITE 
DETAIL 
LINE 
W 
~ 
READ 
STUDENT 
FILE 
COMPUTE 
TUITION 
m y pr itf 
UNION FEE 
COMPUTE 
ACTiVITY 
FEE 
COMPUTE 
SCHOLARSHIP 
(a) Hierarchy Chart 
Open files 
Write heading 1ine(s) 
Read STUDENT-FILE at end indicate no more data 
DO WHILE data remains 
Compute tuition = 200 * credits 
IF union member 
Union fee = $25 
ELSE 
| 
Union fee = 0 
I 
ENDIF 
DO CASE 
CASE credits <= 6 
Activity fee = 25 
CASE credits > 6 and <= 12 
Activity fee = 50 
CASE credits > 12 
Activity fee = 75 
END CASE 
IF gpa > 2.5 
[ 
Scholarship = Scholarship amount 
j 
ELSE (no scholarship) 
I 
Scholarship = 0 
| 
ENDIF 
f 
Compute Bill = Tuition + Union fee + Activity fee - Scholarship 
j 
Increment university totals 
j 
Write detail line 
[ 
Read STUDENT-FILE at end indicate no more data 
1 
ENDDO 
Write university totals 
) 
Close files 
[ 
Stop run 
(b) Detailed Pseudocode 
Developing the Procedure Division 

Chapter 
5 
The 
Procedure 
Division 
(continued) 
PROCEDURE DIVISION. 
PREPARE-TUITION-REPORT. 
DISPLAY 'PREPARE-TUITION-REPORT paragraph entered'. 
OPEN INPUT STUDENT-FILE. 
PERFORM WRITE-HEADING-LINE. 
PERFORM READ-STUDENT-FILE. 
PERFORM PROCESS-STUDENT-RECORD 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
PERFORM WRITE-UNIVERSITY-TOTALS. 
CLOSE STUDENT-FILE. 
STOP RUN. 
WRITE-HEADING-LINE. 
DISPLAY 'WRITE-HEADING-LINE paragraph entered'. 
READ-STUDENT-FILE. 
READ STUDENT-FILE 
AT END MOVE
 
1 NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PROCESS-STUDENT-RECORD. 
DISPLAY
 1 '. 
DISPLAY 'PROCESS-STUDENT-RECORD paragraph entered'. 
DISPLAY 'Student record being processed: ' STUDENT-RECORD. 
PERFORM COMPUTE-INDIVIDUAL-BILL. 
PERFORM INCREMENT-UNIVERSITY-TOTALS 
PERFORM WRITE-DETAIL-LINE. 
PERFORM READ-STUDENT-FILE. 
COMPUTE-INDIVIDUAL-BILL. 
DISPLAY ' COMPUTE-INDIVIDUAL-BILL paragraph entered'. 
PERFORM COMPUTE-TUITION. 
PERFORM COMPUTE-UNION-FEE. 
PERFORM COMPUTE-ACTIVITY-FEE. 
PERFORM COMPUTE-SCHOLARSHIP. 
COMPUTE-TUITION. 
DISPLAY ' COMPUTE-TUITION paragraph entered'. 
COMPUTE-UNION-FEE. 
DISPLAY ' COMPUTE-UNION-FEE paragraph entered'. 
COMPUTE-ACTIVITY-FEE. 
DISPLAY ' COMPUTE-ACTIVITY-FEE paragraph entered'. 
COMPUTE-SCHOLARSHIP. 
DISPLAY
 1 COMPUTE-SCHOLARSHIP paragraph entered
1. 
INCREMENT-UNIVERSITY-TOTALS. 
DISPLAY ' INCREMENT-UNIVERSITY-TOTALS paragraph entered'. 
WRITE-DETAIL-LINE. 
DISPLAY ' WRITE-DETAIL-LINE paragraph entered'. 
WRITE-UNIVERSITY-TOTALS. 
f i i r r n 
A v 
i 
i 
u i o r l_M t 
. 
DISPLAY 'WRITE-UNIVERSITY-TOTALS paragraph entered'. 
(c) Stubs Program 

The 
Tuition 
Billing 
Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
TUITI0N5. 
AUTHOR. 
CAROL VAZQUEZ VILLAR. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR05\TUITI0N.DAT
1 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
DATA DIVISION. 
FILE SECTION. 
FD STUDENT-FILE 
RECORD CONTAINS 27 CHARACTERS. 
01 
STUDENT-RECORD. 
05 STU-NAME. 
10 STU-LAST-NAME 
PIC X(15). 
10 STU-INITIALS 
PIC XX. 
05 STU-CREDITS 
PIC 9(2). 
05 STU-UNION-MEMBER 
PIC X. 
05 STU-SCHOLARSHIP 
PIC 9(4). 
05 STU-GPA 
PIC 9V99. 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS. 
01 PRINT-LINE 
PIC X(132). 
WORKING-STORAGE SECTION. 
01 
DATA-REMAINS-SWITCH 
01 
INDIVIDUAL-CALCULATIONS. 
PIC X(2) VALUE SPACES. 
34 
05 IND-TUITION 
PIC 9(4) VALUE ZEROS 
35 
05 IND-ACTIVITY-FEE 
PIC 9(2) VALUE ZEROS 
36 
05 IND-UNION-FEE 
PIC 9(2) VALUE ZEROS 
37 
05 IND-SCHOLARSHIP 
PIC 9(4) VALUE ZEROS 
38 
05 IND-BILL 
PIC 9(6) VALUE ZEROS 
39 
40 
01 UNIVERSITY-TOTALS. 
41 
05 UNI-TUITION 
PIC 9(6) VALUE ZEROS 
42 
05 UNI-UNION-FEE 
PIC 9(4) VALUE ZEROS 
43 
05 UNI-ACTIVITY-FEE 
PIC 9(4) VALUE ZEROS 
44 
05 UNI-SCHOLARSHIP 
PIC 9(6) VALUE ZEROS 
45 
05 UNI-IND-BILL 
PIC 9(6) VALUE ZEROS 
46 
47 
01 CONSTANTS-AND-RATES. 
48 
05 PRICE-PER-CREDIT 
PIC 9(3) VALUE 200. 
49 
05 UNION-FEE 
PIC 9(2) VALUE 25. 
50 
05 ACTIVITY-FEES. 
The Tuition Billing Program 

Chapter 
S — 
The 
Procedure 
Division 
51 
10 1ST-ACTIVITY -FEE PIC 99 
VALUE 25. 
52 
10 1ST-CREDIT-LIMIT PIC 99 
VALUE 6. 
53 
10 2ND-ACTIVITY -FEE PIC 99 
VALUE 50. 
54 
10 2ND-CREDIT-LIMIT PIC 99 
VALUE 12. 
55 
10 3RD-ACTIVITY -FEE PIC 99 
VALUE 75. 
56 
05 MINIMUM-SCHOLAR-GPA PIC 9V9 VALUE 2.5. 
57 
58 
01 HEADING-LINE. 
59 
05 FILLER 
PIC X 
VALUE SPACES. 
60 
05 FILLER 
PIC X(12) VALUE 'STUDENT NAME 
61 
05 FILLER 
PIC X(10) VALUE SPACES. 
62 
05 FILLER 
PIC X(7) VALUE 'CREDITS'. 
63 
05 FILLER 
PIC X(2) VALUE SPACES. 
64 
05 FILLER 
PIC X(7) VALUE 'TUITION'. 
65 
05 FILLER 
PIC X(2) VALUE SPACES. 
66 
05 FILLER 
PIC X(9) VALUE
 1 UNION FEE
1. 
67 
05 FILLER 
PIC X(2) VALUE SPACES. 
68 
05 FILLER 
PIC X(7) VALUE 'ACT FEE'. 
69 
05 FILLER 
PIC X(2) VALUE SPACES. 
70 
05 FILLER 
PIC X(ll) VALUE 'SCHOLARSHIP' 
71 
05 FILLER 
PIC X(2) VALUE SPACES. 
72 
05 FILLER 
PIC X(10) VALUE 'TOTAL BILL'. 
73 
05 FILLER 
PIC X(48) VALUE SPACES. 
74 
75 
01 DETAIL-LINE. 
76 
05 FILLER 
PIC X 
VALUE SPACES. 
77 
05 DET-LAST-NAME 
PIC X(15) 
78 
05 FILLER 
PIC X(2) VALUE SPACES. 
79 
05 DET-INITIALS 
PIC X(2). 
80 
05 FILLER 
PIC X(5) VALUE SPACES. 
81 
05 DET-CREDITS 
PIC 9(2). 
82 
05 FILLER 
PIC X(6) VALUE SPACES. 
83 
05 DET-TUITION 
PIC 9(6). 
84 
05 FILLER 
PIC X(7) VALUE SPACES. 
85 
05 DET-UNION-FEE 
PIC 9(3). 
86 
05 FILLER 
PIC X(6) VALUE SPACES. 
87 
05 DET-ACTIVITY-FEE 
PIC 9(3). 
88 
05 FILLER 
PIC X(8) VALUE SPACES. 
89 
05 DET-SCHOLARSHIP 
PIC 9(5). 
90 
05 FILLER 
PIC X(6) VALUE SPACES. 
91 
05 DET-IND-BILL 
PIC 9(6). 
92 
05 FILLER 
PIC X(49) VALUE SPACES. 
93 
94 
01 DASH-LINE. 
95 
05 FILLER 
PIC X(31) VALUE SPACES. 
96 
05 FILLER 
PIC X(8) VALUE ALL 
97 
05 FILLER 
PIC X(2) VALUE SPACES. 
98 
05 FILLER 
PIC X(8) VALUE ALL 
99 
05 FILLER 
PIC X(2) VALUE SPACES. 
100 
05 FILLER 
PIC X(7) VALUE ALL '-'. 
I 
(continued) 

The 
Tuition 
Billing 
Program 
^ f 
(continued) 
101 
05 FILLER 
PIC X(6) VALUE SPACES 
102 
05 FILLER 
PIC X(7) VALUE ALL '-
103 
05 FILLER 
PIC X(5) VALUE SPACES 
104 
05 FILLER 
PIC X(7) VALUE ALL '-
105 
05 FILLER 
PIC X(49) VALUE SPACES 
106 
107 
01 TOTAL-LINE. 
108 
05 FILLER 
PIC X(8) VALUE SPACES 
109 
05 FILLER 
PIC X(17) 
110 
VALUE 'UNIVERSITY TOTALS'. 
111 
05 FILLER 
PIC X(8) VALUE SPACES 
112 
05 TOT-TUITION 
PIC 9(6). 
113 
05 FILLER 
PIC X(6) VALUE SPACES 
114 
05 TOT-UNION-FEE 
PIC 9(4). 
115 
05 FILLER 
PIC X(5) VALUE SPACES 
116 
05 TOT-ACTIVITY-FEE 
PIC 9(4). 
117 
05 FILLER 
PIC X(7) VALUE SPACES 
118 
05 TOT-SCHOLARSHIP 
PIC 9(6). 
119 
05 FILLER 
PIC X(6) VALUE SPACES 
120 
05 TOT-IND-BILL 
PIC 9(6). 
121 
05 FILLER 
PIC X(49) VALUE SPACES 
122 
123 
PROCEDURE DIVISION. 
124 
PREPARE-TUITION-REPORT. 
125 
OPEN INPUT STUDENT-FILE 
126 
OUTPUT PRINT-FILE. 
127 
PERFORM WRITE-HEADING-LINE. ... 
[1283'^^ 
129 
PERFORM PROCESS-STUDENT-RECORD 
130 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
131 
PERFORM WRITE-UNIVERSITY-TOTALS. 
132 
CLOSE STUDENT-FILE 
133 
PRINT-FILE. 
134 
STOP RUN. 
135 
136 
WRITE-HEADING-LINE. 
137 
MOVE HEADING-LINE TO PRINT-LINE. 
138 
WRITE PRINT-LINE 
139 
AFTER ADVANCING PAGE. 
140 
MOVE SPACES TO PRINT-LINE. 
141 
WRITE PRINT-LINE. 
142 
143 
READ-STUDENT-FILE. 
144 
READ STUDENT-FILE 
145 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
146 
END-READ. 
147 
148 
PROCESS-STUDENT-RECORD. 
149 
PERFORM COMPUTE-INDIVIDUAL-BILL. 
150 
PERFORM INCREMENT-UNIVERSITY-TOTALS 
151 
PERFORM WRITE-DETAIL-LINE. 

C
h
a
p
t
e
r 
(continued) 
PERFORM READ-STUDENT-FILE. >• 
COMPUTE-INDIVIDUAL-BILL. 
PERFORM COMPUTE-TUITION. 
PERFORM COMPUTE-UNION-FEE. 
PERFORM COMPUTE-ACTIVITY-FEE. 
PERFORM COMPUTE-SCHOLARSHIP. 
COMPUTE IND-BILL = IND-TUITION + IND-UNION-FEE + 
IND-ACTIVITY-FEE - IND-SCHOLARSHIP. 
COMPUTE-TUITION. 
COMPUTE IND-TUITION = PRICE-PER-CREDIT * STU-CREDITS. 
COMPUTE-UNION-FEE. 
IF STU-UNION-MEMBER = 'V 
MOVE UNION-FEE TO IND-UNION-FEE 
ELSE 
MOVE ZERO TO IND-UNION-FEE 
END-IF. 
COMPU T E - AC TIVITY- FEE. 
EVALUATE TRUE 
WHEN STU-CREDITS <= 1ST-CREDIT-LIMIT 
MOVE 1ST-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 1ST-CREDIT-LIMIT 
AND STU-CREDITS <= 2ND-CREDIT-LIMIT 
MOVE 2ND-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 2ND-CREDIT-LIMIT 
MOVE 3RD-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN OTHER 
DISPLAY 'INVALID CREDITS FOR: ' STU-NAME 
END-EVALUATE. 
COMPUTE-SCHOLARSHIP. 
3 J F S T U ^ A ^ ^ M I N l S j M ^ 
j""'" 
MOVE STU-SCHOLARSHIP TO IND-SCHOLARSHIP 
ELSE 
MOVE ZERO TO IND-SCHOLARSHIP 
END-IF. 
INCREMENT-UNIVERSITY-TOTALS. 
ADD IND-TUITION 
TO UNI-TUITION, 
ADD IND-UNION-FEE 
TO UNI-UNION-FEE. 
ADD IND-ACTIVITY-FEE TO UNI-ACTIVITY-FEE. 
ADD IND-SCHOLARSHIP TO UNI-SCHOLARSHIP. 
ADD IND-BILL 
TO UNI-IND-BILL. 
MOVE STU-LAST-NAME TO DET-LAST-NAME. 
MOVE STU-INITIALS TO DET-INITIALS. 
MOVE STU-CREDITS TO DET-CREDITS. 

The 
Tuition 
Billing 
Program 
rigijf© 5.5 
(continued) 
I 
2 0 3 
M O V E IND-TUITION TO DET-TUITION. 
J 
204 
M O V E I N D - U N I O N - F E E TO DET-UNION-FEE. 
1 
2 0 5 
MOVE IND-ACTIVITY-FEE T O DET-ACTIVITY-FEE. 
| 
206 
M O V E IND-SCHOLARSHIP TO DET-SCHOLARSHIP. 
I 
207 
M O V E IND-BILL TO DET-IND-BILL. 
[ 
2 0 8 
M O V E D E T A I L - L I N E TO PRINT-LINE. 
| 
2 0 9 
W R I T E P R I N T - L I N E 
j 
210 
A F T E R ADVANCING 1 LINE. 
| 
211 
| 
212 
W R I T E - U N I V E R S I T Y - T O T A L S . 
| 
2 1 3 
M O V E D A S H - L I N E TO PRINT-LINE. 
j 
214 
_ _ 
WRIJF:_PRJ[NJ-LIN_E. 
| 
'215 
" 
MOVE'UNI-TUITIOITTO T O T - T U T T I O N T " " ! 
1 
216 
M O V E U N I - U N I O N - F E E TO TOT-UNION-FEE. 
I 
217 
M O V E U N I - A C T I V I T Y - F E E T O T O T - A C T I V I T Y - F E E . f 
( 
218 
MOVE U N I - S C H O L A R S H I P TO TOT-SCHOLARSHIP. 
! 
| 
219 
M O V E U N I - I N D - B I L L TO TOT-IND-BILL. 
j 
• l
2?p_ _ 
M O V E T O T A L - L I N E TO PRINT-LINE. __ 
_ j 
j 
""l21 
~ ~ " " " W R I T E PRINT-LINE 
I 
222 
A F T E R A D V A N C I N G 1 LINE. 
L 
copied directly from Figure 4.10. T h e completed program appears s o m e w h a t 
formidable the first time you see it, but it has been developed over the last three 
chapters, and you should have no difficulty in following. W e suggest y o u take it in 
pieces and review sections of the text as you need them with respect to the following: 
1. The Identification Division in lines 1-3 contains only the P R O G R A M - I D and 
A U T H O R paragraphs. 
2. The Environment Division in lines 5-11 contains the S E L E C T statements for 
the two required files. 
3. The ID's in lines 15-16 and 26-28 correspond to the S E L E C T statements in 
the Environment Division. 
4. The description for the incoming data in lines 17-24 matches the program 
specifications of Chapter 3. 
5. Separate 01 entries are defined for individual and total calculations (lines 33-
38 and 40-45); also data n a m e s for the constants and rates are established in 
lines 47-56. 
6. Heading, detail, dashed, and total lines are described separately in 
W O R K I N G - S T O R A G E (lines 58-73, 75-92, 94-105, and 107-121, respectively); 
note the use of V A L U E clauses to initialize the various print lines. 
7. The paragraphs in the Procedure Division correspond one to o n e with the 
blocks in the hierarchy chart of Figure 5.4a. 
8. A n initial R E A D statement in line 128 is followed by the P E R F O R M statement 
in lines 129 and 130 to execute P R O C E S S - S T U D E N T - R E C O R D (lines 148-
152) until there are no more records. The last statement of the performed 
paragraph is a second R E A D statement. The combination of these 
statements implements the overall logic in the pseudocode of Figure 5.4b. 

C
h
a
p
t
e
r 
S 
The 
Procedure 
Division 
9. An EVALUATE statement in lines 173-183 c o m p u t e s the activity fee 
according to the n u m b e r of credits taken. 
10. 
Separate paragraphs in the Procedure Division c o m p u t e an individual bill 
(lines 154-160), increment university totals (lines 192-197), and write a detail 
line (lines 199-210). 
11. 
Multiple MOVE statements are required within the paragraph to write a 
detailed line (lines 199-210), with each statement m o v i n g a c o m p u t e d value 
(such as IND-TUITION) to the corresponding entry in the print line (DET-
TUITION). The need for both data n a m e s will be m o r e apparent after the 
material o n editing in Chapter 7. The paragraph to write university totals 
requires similar treatment. 
12. 
Multiple A D D statements are n e e d e d within the paragraph to increment 
university totals (lines 193-197). Each total is stored in a separate field and 
thus must be incremented separately. 
Figure 5.6 
Test Data and Output 
SMITH 
JB15Y0000230 
JAMES 
HR15 0500245 
BAKER 
SR09 0500350 
PART-TIMER 
JR03Y0000300 
JONES 
PL15Y0000280 
HEAVYWORKER 
HM18 0000200 
LEE 
BL18 0000335 
CLARK 
JC06 0000310 
GROSSMAN 
SE07 0000215 
FRANKEL 
LF10 0000350 
BENWAY 
CT03 0250395 
KERBEL 
NB04 0000100 
(a) Test Data 
STUDENT NAME 
CREDITS TUITION UNION FEE ACT FEE SCHOLARSHIP TOTAL BILL 
SMITH 
JB 
15 
003000 
025 
075 
00000 
003100 
JAMES 
HR 
15 
003000 
000 
075 
00000 
003075 
BAKER 
SR 
09 
001800 
000 
050 
00500 
001350 
PART-TIMER 
JR 
03 
000600 
025 
025 
00000 
000650 
JONES 
PL 
15 
003000 
025 
075 
00000 
003100 
HEAVYWORKER 
HM 
18 
003600 
000 
075 
00000 
003675 
LEE 
BL 
18 
003600 
000 
075 
00000 
003675 
CLARK 
JC 
06 
001200 
000 
025 
00000 
001225 
GROSSMAN 
SE 
07 
001400 
000 
050 
00000 
001450 
FRANKEL 
LF 
10 
002000 
000 
050 
00000 
002050 
BENWAY 
CT 
03 
000600 
000 
025 
00250 
000375 
KERBEL 
NB 
04 
000800 
000 
025 
00000 
000825 
UNIVERSITY TOTALS 
024600 
0075 
0625 
000750 
024550 
(b) Output 

The 
Tuition 
Billing 
Program 
Yii-st Data 
The test data and associated output are s h o w n in Figures 5.6a and 5.6b, respectively. 
The test data are identical to those used in the original stubs program; the output, 
however, is different and reflects the expanded Procedure Division of Figure 5.5. 
Note, too, the correspondence between individual records in the input data file a n d 
the associated lines in the printed report. 
Observe, for example, that JB Smith, JR Part-Timer, and PL Jones each have a Y 
in c o l u m n 20 of their input records, and that these are the only individuals w h o are 
charged a U n i o n Fee. In similar fashion, James, Baker, and Benway are the only 
students with potential scholarships in the incoming data; James, however, d o e s 
not have the requisite average and so h e does not receive a scholarship. The student 
file has 12 records, and h e n c e 12 students appear in the printed report. 
In retrospect, the output produced isn't very pretty as it is unformatted a n d 
contains extraneous zeros throughout. (Editing is presented in Chapter 7 together 
with a final version of the program.) 
Hierarchy Chart 
, 
The hierarchy chart was introduced initially as a design, aid and developed before 
the program was written; it is also used as a documentation technique after coding 
is completed to better understand the overall program structure. The hierarchy 
chart depicts the functions inherent in a program, and is closely tied to the 
paragraphs in the Procedure Division. Observe therefore, the properties of the 
hierarchy chart in Figure 5.4a as they relate to the COBOL program in Figure 5.5. 
1. Every box (module) in the hierarchy chart corresponds to a paragraph in the 
COBOL program. There are twelve different modules (the READ appears 
twice) in the hierarchy chart, and twelve paragraphs in the program. 
2. Each paragraph in the COBOL program contains as m a n y PERFORM 
statements as there are m o d u l e s in the next lower level of the hierarchy 
chart. Thus the paragraph at the highest level, PREPARE-TUITION-REPORT, 
contains four PERFORM statements, o n e for each subordinate paragraph. 
3. A paragraph can b e entered only from the paragraph directly a b o v e it and 
must eventually return control to that paragraph. Hence, PROCESS-
STUDENT-RECORDS is entered via a PERFORM statement in PREPARE-
TUITION-REPORT. PROCESS-STUDENT-RECORDS in turn invokes four 
lower level paragraphs, each of which returns control to PROCESS-
STUDENT-RECORDS, which eventually returns control to PREPARE-
TUITION-REPORT. 
4. Every m o d u l e in a hierarchy chart (paragraph within a program) should b e 
dedicated to a single function. The nature of that function s h o u l d b e 
apparent from the module's n a m e and should consist of a verb, o n e or two 
adjectives, and an object. 
Remember, too, that a hierarchy chart is very different from 
flowcharts or 
p s e u d o c o d e . A hierarchy chart shows what has to b e done, but not w h e n ; it contains 
no decision-making logic. Flowcharts and pseudocode, o n the other hand, specify 
w h e n a n d if a given block of code is executed. We say that hierarchy charts are 
functional 
i n nature; t h e y c o n t a i n t h e tasks n e c e s s a r y to a c c o m p l i s h t h e 
specifications but do not indicate an order for execution. Pseudocode a n d flowcharts 
are procedural and specify logic. 

Chapter 
S —•• 
The 
Procedure 
Division 
Our objective is for you to write meaningful C O B O L programs, not to memorize 
u hat must appear to be an endless list of rules. Y o u must eventually r e m e m b e r 
certain things, but w e have found the best approach is to pattern your first few 
C O B O L programs after existing examples such as the tuition billing program. 
Everything you need to get started is contained in that program (Figure 5.5) if you 
will look at it carefully. As a further aid, Figure 5.7 contains a skeleton outline of a 
C O B O L program and s o m e helpful hints. Consider: 
1. The four divisions must appear in the order: Identification, Environment, 
Data, and Procedure. Division headers begin in the A margin and always 
appear o n a line by themselves. 
2. The Environment and Data Divisions contain sections with fixed names. The 
Identification Division does not contain any sections. (The Procedure 
Division m a y contain programmer-defined sections; however, this is usually 
not done in beginning programs.) 
3. The Data Division is the only division without paragraph names. In the 
Identification and Environment Divisions, the paragraph names are fixed. In 
the Procedure Division they are determined by the programmer. Paragraph 
names begin in the A margin. 
4. A n y entry not required to begin in the A margin begins in the B margin—that 
is, in or past column 12. 
5. The program executes instructions sequentially, as they appear in the 
Procedure Division, unless a transfer-of-control statement such as 
P E R F O R M is encountered. 
6. Every file must be opened and closed. A file n a m e will appear in at least four 
statements: SELECT, FD, O P E N , and C L O S E . The R E A D statement also 
contains the file n a m e of an input file, whereas the W R I T E statement 
contains the record n a m e of an output file. 
Scope terminators (e.g., END-IF, and END-READ) did not exist in COBOL 74; 
hence all scope terminators in Figure 5.5 must be removed for the program to 
compile under COBOL-74. The advantage of including scope terminators is 
explained further in Chapter 7. 
j 
The EVALUATE statement is also new to COBOL-85 and hence an 
j 
alternative way to compute the activity fee (e.g., multiple IF statements) is 
J 
required to develop the program under the older compiler. 
j 
The word TO is permitted as an optional reserved word in the GIVING 
| 
form of the ADD statement in COBOL-85; it was not allowed in COBOL-74. 
\ 
x 
THEN is an optional reserved word in the IF statement in COBOL-85 but was 
j 
not allowed in COBOL-74. 
I 

COBOL 
Program 
Skeleton 
Skeleton Outline of a COBOL Program 
IDENTIFICATION DIVISION. 
ENVIRONMENT D I V I S I O N . 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
fSELECT Y N P U T - F I L E " A S S I G N T O 'A:\CHAPTR05\TUITI0N.DAT' 
O R G A N I Z A T I O N IS LINE SEQUENTIAL. 
| SELECT P R I N T - F I L E 
A S S I G N T O PRINTER. 
DATA D I V I S I O N . 
FILE SECTION. 
FD 
INPUT-FILE 
R E C O R D C O N T A I N S 8 0 CHARACTERS. 
01 
INPUT-RECORD 
P I C X ( 8 0 ) . 
FD 
P R I N T - F I L E 
RECORD C O N T A I N S 132 CHARACTERS. 
01 
P R I N T - L I N E 
P I C X ( 1 3 2 ) . 
W O R K I N G - S T O R A G E SECTION 
01 
D A T A - R E M A I N S - S W I T C H 
P I C X(2) 
V A L U E SPACES. 
oi "HEADING-LINE! 
"""""""" ~ " 
01 
D E T A I L - L I N E . 
01 
T O T A L - L I N E . 
PROCEDURE D I V I S I O N . 
M A I N L I N E . 
j O P E N INPUT INPUT-FILE 
O U T P U T PRINT-FILE. 
READ INPUT-FILE 
AT E N D M O V E 'NO' T O DATA-REMAINS-SWITCH 
END-READ. 
PERFORM PROCESS-RECORDS 
U N T I L DATA-REMAINS-SWITCH = 'NO'. 
C L O S E INPUT-FILE"j 
PRINT-FILE. 
STOP R U N . 
I 
r 
PROGRAM-ID. 
AUTHOR. 
PROGNAME. 
J O H N D O E . 
PROCESS-RECORDS. 
[READ"" INPUT-FILE 
" 
"
" 
AT END M O V E 'NO' T O D A T A - R E M A I N S - S W I T C H 
END-READ. 

C
h
a
p
t
e
r 
5 
The 
Procedure 
Division 
SUMMARY 
:-o-».jit« f© 
Remember 
The READ statement typically appears twice in a COBOL program; as an 
initial (priming) read, and as the last statement of a performed paragraph 
to process a file until its records are exhausted. 
The PERFORM statement may be used with or without an UNTIL clause; 
the latter is used to implement a loop. 
The IF statement may be used with or without an ELSE clause; indentation 
is optional, but strongly suggested, in order to clarify intent. 
The EVALUATE statement implements the case structure and is used 
instead of multiple IF statements. 
The MOVE statement has several precisely defined rules, which govern the 
use of sending and receiving fieids of different lengths and/or data types. 
Arithmetic is done in one of two ways: either through individual statements 
such as ADD, SUBTRACT, MULTIPLY, and DIVIDE, or through a COMPUTE 
statement which combines multiple operations. 
Il 
Parentheses may clarify and/or alter the normal sequence of operations; 
exponentiation, multiplication or division, addition or subtraction (and from 
left to right, if a tie). 
The hierarchy chart can be used as a design aid before a program is 
written, and as a documentation technique afterward. 
Key 
Words 
and 
Concepts 
Assumed (implied) decimal point 
Hierarchy of operations 
Decimal alignment 
Indentation 
Design aid 
Priming (initial) read 
Documentation 
Pseudocode 
Exponentiation 
Receiving (destination) field 
Group move 
Scope terminator 
Hierarchy chart 
Source (sending) field 
ADO 
ADVANCING 
CLOSE 
COMPUTE 
DIVIDE 
ELSE 
END-ADD 
tNu-COMKUlt 
END-DIVIDE 
END-EVALUATE 
END-IF 
EVALUATE 
GIVING 
IF 
READ 
ROUNDED 
SIZE ERROR 
STOP RUN 
SUBTRACT 
UNTIL 
WRITE 
MOVE 
END-MULTIPLY 
END-READ 
MULTIPLY 
OPEN 
END-SUBTRACT 
PERFORM 

1. The 
statement permits multiple arithmetic operations in a single 
statement. 
2. Most arithmetic statements have 
distinct formats. 
3. Specification of the 
clause causes a calculation to be carried to 
one more place than is specified in the result field. 
4. Exponentiation is indicated by 
. 
5. In the absence of parentheses exponentiation comes (before/after) multiplication. 
6. If both multiplication and division are present, computation proceeds from 
to 
. 
7. The IF statement fdoes/does not) require an ELSE clause. 
8. The effect of an IF statement is terminated by the presence of a 
or the presence of an 
clause. 
9. 
is normally the last statement that is executed in any COBOL 
program. 
10. A typical COBOL program usually has 
distinct READ statements. 
11. A file containing N records is generally read 
times. 
12. In COBOL, one reads a 
and writes a 
. 
13. Specification of 
in a WRITE 
statement causes the next line of output to begin on top of a new page. 
14. The type of file—that is, INPUT or OUTPUT^appears in an 
but 
not in a 
statement. 
15. When an alphanumeric field is moved to an alphanumeric field, data are moved  
character at a time, from 
to 
. 
16. If a five position alphanumeric field is moved to a four position alphanumeric field, 
the low order character is 
. 
17. A numeric move always maintains 
. 
18. A PERFORM UNTIL statement always tests the condition (before/after) performing 
the designated paragraph. 
19. A numeric field (may/may not) be moved to an alphabetic field. 
20. If a numeric field with PIC 999 is moved to a numeric field with PIC 99, the 
(most/least) significant digit will be truncated. 
21. The 
option is available for all arithmetic 
statements, and indicates when the result of a computation is larger than its 
designated PICTURE clause. 
22. The 
statement has been introduced to express a multibranch 
situation. 

C
h
a
p
t
e
r 
5 
— 
The 
Procedure 
Division 
1. One ADD instruction can change the value of more than one data name. 
2. Both GIVING and TO may be present in the same ADD instruction. 
3. A valid ADD instruction may contain neither GIVING nor TO. 
4. Both FROM and GIVING may appear in the same SUBTRACT instruction. 
5. The use of GIVING is optional in the MULTIPLY statement. 
6. The reserved word INTO must appear in a DIVIDE statement. 
7. In the DIVIDE statement, the dividend is always identifier-1. 
8. Multiplication and division can be performed in the same MULTIPLY statement. 
9. Multiplication and addition can be performed in the same COMPUTE statement. 
10. In a COMPUTE statement with no parentheses, multiplication is always done before 
subtraction. 
11. in a COMPUTE statement with no parentheses, multiplication is always done before 
division. 
12. Parentheses are sometimes required in a COMPUTE statement. 
13. The COMPUTE statement changes the value of only one data name. 
14. The IF statement must always contain the ELSE option. 
15. The PERFORM statement transfers control to a paragraph elsewhere in the program. 
16. A program may contain more than one STOP RUN statement. 
17. STOP RUN must be the last statement in the Procedure Division. 
18. The ADVANCING option is mandatory in the WRITE statement. 
19. The READ statement contains a record name. 
20. The WRITE statement contains a record name. 
21. The OPEN and CLOSE statements are optional. 
22. The END-IF scope terminator has little effect in an IF statement. 
23. An IF statement can cause the execution of several other statements. 
24. If the ELSE clause is satisfied in an IF statement, it can cause execution of several 
statements. 
25. The ROUNDED clause is required in the COMPUTE statement. 
26. The SIZE ERROR option is allowed only in the COMPUTE statement. 
27. The SIZE ERROR option is required in the COMPUTE statement. 
28. The EVALUATE statement facilitates implementation of the case construct. 

1. Some of the following arithmetic statements are invalid. Identify those, and state 
why they are unacceptable. 
a. ADD A B C . 
b. SUBTRACT 10 FROM A B. 
c. SUBTRACT A FROM 10. 
d. ADD A TO B GIVING C. 
e. SUBTRACT A POUNDED FROM B ROUNDED GIVING C. 
f. MULTIPLY A BY 10. 
g. MULTIPLY 10 BY A ROUNDED. 
h. MULTIPLY A BY 10 GIVING B C. 
i. DIVIDE A BY B. 
j. DIVIDE A INTO B. 
k. DIVIDE A INTO B GIVING C. 
I. DIVIDE B BY A GiVING C. 
m. COMPUTE X ROUNDED = A + B. 
n. COMPUTE X = 2{A + B). 
o. COMPUTE V = 20/A-C. 
2. Complete the table below. In each instance, refer to the initial values of A, B, C, 
and D. 
Value before execution 
4 
8 
12 
2 
Value after execution of 
a. ADD 1 TO D B. 
b. ADD A B C GIVING D. 
c. ADD A B C TO D. 
d. SUBTRACT A B FROM C. 
e. SUBTRACT A B FROM C GIVING D. 
f. MULTIPLY A BY B C. 
g. MULTIPLY B BY A. 
h. DIVIDE A INTO C. 
i. DIVIDE C BY B GIVING D REMAINDER A. 
j. COMPUTE D = A + B / 2 * D. 
k. COMPUTE D = (A + B) / (2 * D). 
i. COMPUTE D = A + B / (2 * D). 
m. COMPUTE D = (A + B) / 2 * D. 
n. COMPUTE D = A + (B / 2) * D. 

Chapter 
5 — 
The 
Procedure 
Division 
Indicate the logical errors inherent in the following COBOL fragment: 
FILE SECTION. 
FD EMPLOYEE-FILE 
FD PRINT-FILE 
WORKING-STORAGE SECTION. 
01 END-OF-FILE-SWITCH 
PIC X(3) 
VALUE 'YES'. 
PROCEDURE DIVISION. 
PREPARE-EMPLOYEE-REPORT. 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE 
AFTER ADVANCING PAGE. 
OPEN INPUT EMPLOYEE-FILE 
OUTPUT PRINT-FILE. 
PERFORM PROCESS-RECORDS 
UNTIL END-OF-FILE-SWITCH - 'YES'. 
CLOSE EMPLOYEE-FILE. 
STOP RUN. 
PROCESS-RECORDS. 
READ EMPLOYEE-FILE 
AT END MOVE 'YES' TO END-OF-FILE-SWITCH 
END-READ. 
Some of the following statements are invalid. Indicate those, and state why they are 
invalid. (Assume FILE-ONE and FILE-TWO are file names and RECORD-ONE is a 
record name.) 
a. OPEN INPUT RECORD-ONE. 
b. OPEN INPUT FILE-ONE OUTPUT FILE-TWO. 
c. OPEN INPUT FILE-ONE. 
d. CLOSE OUTPUT FILE-ONE. 
e. READ FILE-ONE. 
f. READ FILE-ONE AT END PERFORM END-OF-JOB-ROUTINE. 
g. READ RECORD-ONE AT END PERFORM END-OF-JOB. 
h. WRITE RECORD-ONE. 
i. WRITE RECORD-ONE AFTER ADVANCING TWO LINES. 
j. WRITE RECORD-ONE BEFORE ADVANCING TWO LINES, 
k. CLOSE FILE-ONE FILE-TWO. 
I. WRITE FILE-ONE. 
m. WRITE RECORD-ONE AFTER ADVANCING PAGE. 

5. Write COBOL COMPUTE statements to accomplish the intended logic: 
a. x = a + b + c 
a + bc 
b. x = 
2 
c. x = a
2 + b
2 + c
2 
a + b 
d. x = - — - - c 
2 
e. x = a + b 
[a
2 + b
2 
f. x = J- 
— 
V 2c 
g. f = 
p(Uif 
h. f = - 
; 
/ 
(a + bf 
I. X = 
- r -
(d + e) 
6. Given the following Procedure Division: 
reugcuunc 
uivj.oj.un. 
FIRST-PARAGRAPH. 
MOVE ZEROS TO FIELD-A FIELD-B. 
PERFORM SECOND-PARAGRAPH. 
PERFORM THIRD-PARAGRAPH. 
PERFORM SECOND-PARAGRAPH. 
STOP RUN. 
SECOND-PARAGRAPH. 
ADD 10 TO FIELD-A. 
ADD 20 TO FIELD-B. 
THIRD-PARAGRAPH. 
MULTIPLY FIELD-A BY FIELD-B GIVING FIELD-C. 
DIVIDE FIELD-A INTO FIELD-B GIVING FIELD-D. 
a. What are the final values for FIELD-A, FIELD-B, FIELD-C, and FIELD-D? 
b. How many times is each paragraph executed? 

Chapter 
5 — 
The 
Procedure 
Division 
7. Complete the following table, showing the contents of the receiving field. 
SENDING) FIELD 
PICTURE 
CONTENTS 
RECEIVINGS FiELO 
PICTURE 
CONTENTS 
a. 
b. 
c. 
d. 
e. 
f. 
g-
h. 
X(4) 
X(4) 
X(4) 
X(4) 
9(4) 
9(4) 
9(4) 
999V9 
999V9 
999V9 
999V9 
H 0 
0 ! P I E 
H i 0 
PIE 
6 17 
L j 
8 9 
6 j 7 
7 8 19 1 
i i 
111} 
7 | 8 i 9 
X(4) 
9(4) 
X(3) 
X(5) 
X(4) 
9(3) 
9(5) 
9(4) 
9(4)V9 
9(3)V99 
99V99 
8. Supply Procedure Division statements as indicated: 
a. Code two equivalent statements, an ADD and a COMPUTE, to add 1 to the 
counter NUMBER-QUALIFIED-EMPLOYEES. 
b. Code a COBOL statement to add the contents of five fields, MONDAY-SALES, 
TUESDAY-SALES, WEDNESDAY-SALES, THURSDAY-SALES, and FRIDAY-
SALES, storing the result in WEEKLY-SALES. 
c. Code a COBOL statement to subtract the fields FED-TAX, STATE-TAX, 
FICA, and VOLUNTARY-DEDUCTIONS, from GROSS-PAY, and put the result 
in NET-PAY. 
d. Code a single COBOL statement to calculate NET-AMOUNT-DUE, which is 
equal to the GROSS-SALE minus a 2% discount. 
e. Recode part (d), using two statements (a MULTIPLY and a SUBTRACT). 
f. Code a COBOL statement to compute GROSS-PAY, which is equal to HOURS-
WORKED times HOURLY-RATE. 
g. Code a single COBOL statement to compute GROSS-PAY, which is equal to 
REG-HOURS-WORKED times HOURLY-RATE plus OVERTIME-HOURS times 
HOURLY-RATE times 1.5. 
h. Code a COBOL statement to determine AVERAGE-SALARY by dividing TOTAL-
SALARY by NUMBER-OF-EMPLOYEES. 
i. Code a COBOL Compute statement equivalent to the algebraic formula. 
(a + b)c 
x = 
-
— 
de 
j. Code a COBOL Compute statement equivalent to the algebraic formula. 
x = 
-b + jb
2 
-4ac 
2a 
9. Write Procedure Division code for the flowchart in Figure 5.8. 

Problems 
F = F - 1 
FALSE 
X = A + B 
y 
N = N + 1 
F = F - 1 
FALSE 
X = A + B 
N = N + 1 
Flowcharts for Problem 9 


Overview 
Errors in Compilation 
Common Compilation Errors 
Errors in Execution 
File Status Codes 
Tips for Debugging 
Cross-Reference Listing 
DISPLAY Statement 
Interactive Debugger 
The Structured Walkthrough 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
6 
Debugging 
After reading this chapter you will be able to: 
Distinguish between errors in compilation and execution; correct typical 
compilation errors. 
Use the DISPLAY statement as a debugging tool. 
Explain how an interactive debugger can be used to find and correct 
execution errors. 
Describe the use of file status codes in correcting data management 
errors. 
Explain what is meant by a structured walkthrough; be able to participate 
as reviewer, reviewee, moderator, or secretary. 
1/ v 
Very few computer programs run successfully on the first attempt. Indeed, the 
programmer is realistically expected to make errors, and an important test of a 
good programmer is not whether he or she makes mistakes, but how quickly he 
or she is able to detect and correct the errors. Since this process is such an 
integral part of programming, an entire chapter is devoted to debugging. We 
consider errors in both compilation and execution. 
Compilation errors occur during the translation of COBOL to machine 
language and are caused by a mistake in COBOL syntax, for example, a 
missing period or an entry in a wrong column. Execution errors result after the 
program has been translated to machine language and produce results that are 
different from what the programmer expected or intended. 
Compilation errors are easy to find because the compiler produces an 
explicit error message. Execution errors are more difficult to detect and may 
require the use of additional debugging tools, such as the insertion of DISPLAY 
statements into a program and/or the use of an interactive debugger. The 
chapter also considers the structured walkthrough as a means of reducing 
errors before they occur. 
A 
U. 
Compilation is the process of translating a source (COBOL) program into machine 
language. Any mistake in COBOL syntax causes the compiler to m a k e an assumption 
in the interpretation of the statement in w h i c h the error occurs, or, worse yet, 
m a k e s it impossible for the compiler to interpret the statement at all. Either way a 
compilation error results. 

Errors 
in 
Compilation 
S o m e errors are less severe than others; for example, the compiler is generally 
able to guess the programmer's intent w h e n periods are omitted in die Data Division, 
whereas it is unable to decipher a misspelled reserved word. Accordingly, most 
compilers provide different levels of compiler diagnostics (error messages) according 
to the severity of the error. Micro Focus Personal C O B O L for Windows, for example, 
produces five types of error messages, which are listed in order of increasing severity. 
Other compilers have similar classifications. Consider: 
I 
Informational Diagnostics 
Indicates a coding inefficiency or other 
condition (for example, an incompatibility 
with the A N S standard). The program will 
compile correctly. 
W 
Warning Diagnostics 
The statement is syntactically correct, but 
the source of a potential problem. A 
program can compile and execute with 
several Wdevel diagnostics present; 
however, ignoring these messages could 
lead to errors in execution. 
E 
Error Diagnostics 
The statement is incorrect as written, and 
requires the compiler to make an 
assumption in order to complete the 
compilation. You m a y wish to correct the 
program in case the compiler's assumption 
is not what you intended. 
S 
Severe Diagnostics 
A severe error in that the compiler cannot 
m a k e corrections and therefore cannot 
generate object instructions. A n y 
statement flagged as an Sdevei error is 
ignored and treated as if it were not 
present in the program. 
U 
Unrecoverable Diagnostics 
A n error of such severity that the compiler 
does not k n o w what to do and cannot 
continue. IJ level diagnostics are extremely 
rare, and you practically have to submit a 
Visual BASIC program to the C O B O L 
compiler to cause a Udevel message. 
The C O B O L compiler tends to rub salt in a w o u n d in the sense that an error in 
one statement can cause error messages in other statements that appear correct. 
For example, should you have an S-level error in a S E L E C T statement, the compiler 
will flag the error, ignore the S E L E C T statement, and then flag any other statements 
that reference that file even though those other statements are correct. 
Often simple mistakes such as omitting a line or misspelling a reserved w o r d 
can lead to a long a n d sometimes confusing set of error messages. T h e only 
consolation is that compiler errors can disappear as quickly as they occurred. 
Correction of the misspelled w o r d or insertion of the missing statement will often 
eliminate several errors at once. 
Proficiency in debugging comes from experience—the m o r e programs you 
write, the better you become. You m a y correct the errors in the order they appear 

Chapter 
6 
Debugging 
(our preference), or in the order of severity (from Unrecoverable, Severe, Error, 
Wanting, io Informational), or even haphazardly as y o u find t h e m . Whichever w a y 
y o u choose, try to find the mistakes as quickly as possible and without wasting time. 
Moreover, don't s p e n d too m u c h time o n any single error; instead, if you are stuck, 
skip the error temporarily and continue to the next, eliminating as m a n y errors as 
y o u can before y o u recompile. 
Tuition Billing Program with Compilation Errors 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
TUIT6C0M. 
AUTHOR. 
CAROL VAZQUEZ VILLAR. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT STUDENT-FILE 
ASSIGN TO 'A:\CHAPTR06\TUITI0N.DAT' 
ORGANIZTION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
DATA DIVISION. 
FILE SECTION. 
FD STUDENT-FILE 
RECORD CONTAINS 27 CHARACTERS. 
01 
STUDENT-RECORD. 
05 STU-NAME. 
10 STU-LAST-NAME 
PIC X(15). 
10 STU-INITIALS 
PIC XX. 
05 STU-CREDITS 
PIC 9(2). 
05 STU-UNION-MEMBER 
PIC X. 
05 STU-SCHOLARSHIP 
PIC 9(4). 
05 STU-GPA 
PIC 9V99. 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS. 
01 
PRINT-LINE 
WORKING-STORAGE SECTION. 
01 
DATA-REMAINS-SWITCH 
PIC X(132). 
PIC X(2) VALUE SPACES. 
33 
01 INDIVIDUAL-CALCULATIONS 
34 
05 
IND-TUITION 
PIC 9(4) VALUE ZEROS 
35 
05 
IND-ACTIVITY-FEE 
PIC 9(2) VALUE ZEROS 
36 
05 
IND-UNI0N-FEE 
PIC 9(2) VALUE ZEROS 
37 
05 
IND-SCHOLARSHIP 
PIC 9(3) VALUE ZEROS 
38 
OQ 
05 
IND-BILL 
PIC 9(6) VALUE ZEROS 
J 5 
40 
01 UNIVERSITY-TOTALS. 
" " " " 
41 
05 UNI-TUITI0N 
^J€^9T6) VALUE ZEROS 
42 
05 [UNI UNION FEE 
DTP 
Q(A\ 
. * v 
^ 
VALUE ZEROS 

Errors 
in 
Compilation 
(continued) 
43 
05 UNI-ACTIVITY-FEE 
PIC 9(4) VALUE ZERQS-- 
" 
44 
05 i UNJ-SCHOLARSHIP 
""JlC X(6) ; VALUE ZEROS. 
45 
05 U N I - I N D - B I L L P I C 9(6) VALUE ZEROS. 
46 
47 
01 CONSTANTS-AND-RATES. 
48 
05 PRICE-PER-CREDIT 
PIC 9(3) VALUE 200. 
49 
05 UNION-FEE 
PIC 9(2) VALUE 25. 
50 
05 ACTIVITY-FEES. 
51 
10 1ST-ACTIVITY-FEE PIC 99 
VALUE 25. 
52 
10 1ST-CREDIT-LIMIT PIC 99 
VALUE 6. 
53 
10 2ND-ACTIVITY-FEE PIC 99 
VALUE 50. 
54 
10 2ND-CREDIT-LIMIT PIC 99 
VALUE 12. 
55 
10 3RD-ACTIVITY-FEE PIC 99 
VALUE 75. 
56 
05 MINIMUM-SCHOLAR-GPA PIC 9V9 
VALUE 2.5. 
57 
58 
01 HEADING-LINE. 
59 
05 FILLER 
PIC X 
VALUE SPACES. 
60 
05 FILLER 
PIC X(12) VALUE 'STUDENT NAME 
61 
05 FILLER 
PIC X(10) VALUE SPACES7] 
^ 
62 
05 FILLER 
PIC X(7) VALUE 'CREDITS'. 
63 
05 FILLER 
PIC X(2) VALUE SPACES. 
64 
05 FILLER 
PIC X(7) VALUE 'TUITION'. 
65 
05 FILLER 
PIC X(2) VALUE SPACES. 
66 
05 FILLER 
PIC X(9) VALUE 'UNION FEE'. 
67 
05 FILLER 
PIC X(2) VALUE SPACES. 
68 
05 FILLER 
PIC X(7) VALUE 'ACT FEE'. 
69 
05 FILLER 
PIC X(2) VALUE SPACES. 
70 
05 FILLER 
PIC X(ll) VALUE 'SCHOLARSHIP' 
71 
05 FILLER 
PIC X(2) VALUE SPACES. 
72 
05 FILLER 
PIC X(10) VALUE 'TOTAL BILL'. 
73 
05 FILLER 
PIC X(48) VALUE SPACES. 
74 
75 
01 DETAIL-LINE. 
76 
05 FILLER 
PIC X 
VALUE SPACES. 
77 
05 DET-LAST-NAME 
PIC X(15). 
78 
05 FILLER 
PIC X(2) VALUE SPACES. 
79 
05 DET-INITIALS 
PIC X(2). 
80 
05 FILLER 
PIC XfS)"VALUE SPACES. 
81 
05 [ STU-CREDITS \~~ 
" PIC 9(2). 
82 
05 FILLER 
PIC X(6) VALUE SPACES. 
83 
05 DET-TUITION 
PIC 9(6). 
84 
05 FILLER 
PIC X(7) VALUE SPACES. 
85 
05 DET-UNION-FEE 
PIC 9(3). 
86 
05 FILLER 
PIC X(6) VALUE SPACES. 
87 
05 DET-ACTIVITY-FEE 
PIC 9(3). 
88 
05 FILLER 
PIC X(8) VALUE SPACES. 
89 
05 DET-SCHOLARSHIP 
PIC 9(5). 
90 
05 FILLER 
PIC X(6) VALUE SPACES. 
91 
05 DET-IND-BILL 
PIC 9(6). 
92 
05 FILLER 
PIC X(49) VALUE SPACES. 

Chapter 
6 — 
Debugging 
93 
94 
01 DASH-LINE. 
95 
05 FILLER 
PIC X(31) VALUE SPACES. 
96 
05 FILLER 
PIC X(8) VALUE ALL 
97 
05 FILLER 
PIC X(2) VALUE SPACES. 
98 
05 FILLER 
PIC X(8) VALUE ALL 
99 
05 FILLER 
PIC X(2) VALUE SPACES. 
100 
05 FILLER 
PIC X(7) VALUE ALL '-'. 
101 
05 FILLER 
PIC X(6) VALUE SPACES. 
102 
05 FILLER 
PIC X(7) VALUE ALL 
103 
05 FILLER 
PIC X(5) VALUE SPACES. 
104 
05 FILLER 
PIC X(7) VALUE ALL '-'. 
105 
05 FILLER 
PIC X(49) VALUE SPACES. 
106 
107 
01 TOTAL-LINE. 
108 
05 FILLER 
PIC X(8) VALUE SPACES. 
109 
05 FILLER 
PIC X(17) 
110 
VALUE 'UNIVERSITY TOTALS'. 
111 
05 FILLER 
ntf' y /Q\ 
Tit 
A\Oj 
VALUE SPACES. 
112 
05 TOT-TUITION 
PIC 9(6). 
113 
05 FILLER 
PIC X(6) VALUE SPACES. 
114 
05 TOT-UNION-FEE 
PIC 9(4). 
115 
05 riLLcn 
PIC X(5) VALUE SPACES. 
116 
05 TOT-ACTIVITY-FEE 
PIC 9(4). 
117 
05 FILLER 
PIC X(7) VALUE SPACES. 
118 
05 TOT-SCHOLARSHIP 
PIC 9(6). 
119 
05 FILLER 
PIC X(6) VALUE SPACES. 
120 
05 TOT-IND-BILL 
PIC 9(6). 
121 
05 FILLER 
PIC X(49) VALUE SPACES. 
122 
123 
124 
PROCEDURE DIVISION. 
START. "
" 
Reserved •;•> vd use 
f- J i 
125 
OPEN INPUT STUDENT-FILE 
126 
OUTPUT PRINT-FILE. 
127 
PERFORM WRITE-HEADING-LINE. 
128 
PERFORM READ-STUDENT-FILE. 
129 
PERFORM PROCESS-STUDENT-RECORD 
130 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
131 
PERFORM WRITE-UNIVERSITY-TOTALS. 
132 
CLOSE STUDENT-FILE 
133 
PRINT-FILE. 
i i n 
STOP 
m ifti 
135 
136 
WRITE-HEADING-LINE. 
137 
MOVE HEADING-LINE TO PRINT -LINE. 
138 
WRITE PRINT-LINE 
139 
AFTER ADVANCING PAGE. 
140 
MOVE SPACES TO PRINT-LINE. 
141 
WRITE PRINT-LINE. 
142 
i 
•"igure s„1 
(continued) 

Errors 
in 
Compilation 
(continued) 
j 
143 
READ-STUDENT-FILE. 
.
V
l , . , , • 
S T L 
144 
READ STUDNET-FILE j 
! 
145 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
146 
END-READ. 
147 
148 
PROCESS-STUDENT-RECORD. 
( 
149 
PERFORM COMPUTE-INDIVIDUAL-BILL. 
150 
PERFORM INCREMENT-UNIVERSITY-TOTALS 
151 
PERFORM WRITE-DETAIL-LINE. 
152 
PERFORM READ-STUDENT-FILE. 
153 
154 
COMPUTE-INDIVIDUAL-BILL. 
155 
PERFORM COMPUTE-TUITION. 
! 
156 
PERFORM COMPUTE-UNION-FEE. 
,;T.. 
157 
PERFORM COMPUTE-ACTIVITY-FEE. 
s 
158 
PERFORM COMPUTE-SCHOLARSHIP. 
I 
159 
COMPUTE IND-BILL « IND-TUITION + IND-UNION-FEE + IND-ACTIVITY 
j 
160 
- IND-SCHOLARSHIP. 
\ 161 
J 
162 
COMPUTE-TUITION. 
| 
163 
COMPUTE IND-TUITION pPRICE-PER-CREDIT * STU-CREDITS. 
( 164 
I 
165 
COMPUTE-UNION-FEE. 
1 
166 
IF STU-UNION-MEMBER =
 1 Y
1 
. 
| 
167 
MOVE UNION-FEE TO IND-UNION-FEE 
| 
168 
ELSE 
I 
169 
MOVE ZERO TO IND-UNION-FEE 
170 
END-IF. 
171 
172 
COMPUTE-ACTIVITY-FEE. 
I 
173 
EVALUATE TRUE 
,v 
j 
174 
WHEN STU-CRLD1TS <~ 1SJ-CREDIT-LIMIT 
j 
175 
MOVE 1ST-ACTIVITY-FE£ TO IND-ACTIVITY-FEE 
I
 
1 7 6 
WHEN jSTU-CREDfTS[> 1SJ-CREDIT-LIMIT 
| 
177 
AND STU-CREDITS/= 2ND-CREDIT-LIMIT 
[ 
178 
MOVE 2ND-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
179 
WHEN STU-CREDITS > 2ND-CREDIT-LIMIT 
180 
MOVE 3RD-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
j 
181 
WHEN OTHER 
j 
182 
DISPLAY 'INVALID CREDITS FOR: ' STU-NAME 
j 
183 
END-EVALUATE. 
184 
185 
COMPUTE-SCHOLARSHIP. 
186 
IF_STU-GPA > MINIMUM-SCHOLAR-GPA 
187 
[MOVE STU-SCHOLARSHIP 10 IND^CH^RSHJP^k.^ 
) 
188 
ELSE 
1 
189 
MOVE ZERO TO IND-SCHOLARSHIP 
^v: -wi* 
190 
END-IF. 
191 
192 
INCREMENT-UNIVERSITY-TOTALS. 

Chapter 
6 
Debugging 
(continued) 
193 
ADD IND-TUITION 
TO UNI-TUITION. 
194 
ADD IND-UNION-FEE 
TO [UNI-UNION-FEE. 
195 
ADD INO-ACTIVITY-FEE TO UNI-ACTIVITY-FEE. 
196 
ADD IND-SCHOLARSHIP 
TOtUNI-SCHOLARSHIP. 
197 
ADD IND-BILL 
TO UNI-IND-BILL. 
198 
199 
WRITE-DETAIL-LINE. 
200 
MOVE STU-LAST-NAME T0 DET-LAST-NAME. 
201 
MOVE STU-INITIALS^O DET-INITIALS. 
^ ' 
202 
MOVE STlJ-CREblTS}TOfblT-CREDITSr 
203 
MOVE IND-TUITION TO DET-TUITION'. 
204 
MOVE IND-UNION-FEE TO DET-UNION-FEE. 
205 
MOVE IND-ACTIVITY-FEE TO DET-ACTIVITY-FEE. 
206 
MOVE IND-SCHOLARSHIP TO DET-SCHOLARSHIP. 
207 
MOVE IND-BILL TO DET-IND-BILL. 
208 
MOVE DETAIL-LINE TO PRINT-LINE. 
209 
WRITE j PRINT^FTLEj 
210 
AFTER ADVANCING 1 LINE. 
211 
212 
WRITE-UNIVERSITY-TOTALS. 
213 
MOVE DASH-LINE TO PRINT-LINE. 
214 
WRITE PRINT-LINE. 
.,„....--•'"' 
215 
MOVE UNI-TUITION TO TOT-TUITION. 
216 
MO V E[UN I-UNTON- FEE]TO TOT-U NION-F E E,-
217 
MOVE UNI-ACTIVITY-FEE TO TOT-ACtIVITY-FEE. 
218 
MOVE:UNI-SCHOLARSHIP]TO'TOT-SCHOLARSHIP. 
219 
MOVE UNI-IND-BILL TO TOT-IND-BILL. 
220 
MOVE TOTAL-LINE TO PRINT-LINE. 
221 
WRITE PRINT-LINE 
222 
AFTER ADVANCING 1 LINE. 
definition line 42 
| 
To give y o u a better feel of what to expect from your programs, we have taken 
the Tuition Billing program from Chapter 5 and deliberately c h a n g e d several of the 
statements to cause compilation errors as s h o w n in Figures 6.1 a n d 6.2. The Personal 
COBOL Animator highlights each error line in the original c o d e a n d coordinates the 
error line with the error m e s s a g e s listed in the Syntax Errors w i n d o w s h o w n in 
Figure 6.2. The error m e s s a g e s include the assigned n u m b e r of the error and the 
error level. For example, 233-S m e a n s that this is error m e s s a g e 233 and its error 
level is Severe. The statement is ignored but the program c a n n o t b e compiled. The 
error message also contains a brief explanation of the error. S o m e of the errors will 
be immediately obvious; others m a y require you to look up the m e s s a g e n u m b e r in 
Syntax Check Error Messages in Animator Help. This help feature is included in the 
Standard COBOL Reference entry in the Help m e n u . Still other errors m a y require 
you to seek help. As y o u progress through this book and gain practical experience, 
you will b e c o m e increasingly self-sufficient. 

Errors 
in C o m pi I at i o n 
Igure 6.2 
Compilation Errors 
131*1 f Period alssing. Period assumed.
 
: 
\ 
13-S 
Bser-naise required 
I 
\ 
12 S Operand STB0NET-FIIE is not declared 
! 
56*!-S ft seope-deliaiter did not haoe a Batching uerb and ua-> discarded- ; 
! 
12-S 
Operand 1MB OctIUIIV is not declared 
5-S User-nasse 
not ssaique 
i 
5~S Ilser-nana* STu-CR£MT5 not unique 
j 
^ 
5-S User naw> STu-CRtDITS not unique 
) 
\ 
5-S User-name Stll cm.0! 
IS not unique 
| 
! 
j 
Operand UNI IMS ON II! is not declared 
I 
I 
3* S Operand BHI SCHOtftBSmP should tie numeric 
[ 
j 
j 
S-S User-napte STu-EBEGITS not unique 
x 
X 
\ 336's Hot a record nane 
\ 
12 S Operand UNI UNION m i» net d»r.;ared 
i 
[ 
Let us examine the errors: 
This error results from the first omitted hyphen in the definition of UNI 
UNION F E E in line 42; that is, the compiler does not know how to handle what it 
thinks are two data names in a row (UNI and UNION) and hence the error. In this 
case, the compiler has found a S-level error and ignores the rest of the statement. 
The compiler does not detect the missing hyphen between UNION and FEE. If only 
the first hyphen is inserted, o n the next recompilation, the compiler will then 
discover the second hyphen is missing. Sometimes, one syntax error hides others 
so that the compiler is not able to detect them. 
Correction: Insert hyphens to read U N I - U N I O N - F E E . 
1014 E Period missing. Period assumed 
A level n u m b e r must follow a completed statement, but the period ending line 
61 has been removed. In this instance, the compiler assumes that the period is 
present, so no h a r m is done, but it is poor programming to permit such E-level 
diagnostics to remain. Moreover, there are situations in which a missing period can 
be very damaging. 
Correction: Insert a period at the end of line 61. 
This error in line 124 is a subtle one that typically sends the beginner for help. 
S T A R T is intended as a paragraph n a m e , and paragraph n a m e s must begin in theA-
margin, so what's the problem? The difficulty is that S T A R T is a reserved word and 
cannot be used as a paragraph n a m e . 
Correction: Choose another n a m e — f o r example, S T A R T - T H E - P R O G R A M . 
12-S Operand STUDNET-FILE is not declared 
The compiler w a s expecting a valid file n a m e but didn't find one because line 
144 references S T U D WET-FILE rather than STUDENT-FILE. Y o u k n o w they are the 
same, but the compiler does not and hence the error. 
Correction: Change the file n a m e to S T U D E N T - F I L E in statement 144. 

C
h
a
p
t
e
r 6 — 
Debugging 
Correction: Change line 209 to W R I T E PRINT-LINE instead of W R I T E PRINT-FILE. 
564-S A scope-delimiter did not have a matching verb and was discarded. 
This error in line 146 will disappear with the correction to the previous R E A D 
statement. 
Correction: N o n e required beyond the correction to line 144. 
12-S Operand 1ND-ACTIVITY is not declared 
The error is subtle because the program file contains IND-ACTIVITY-FEE in 
line 35, yet the data n a m e IND-ACTIVITY appears on the listing and is flagged as an 
error. The problem is that the C O M P U T E statement in line 159 extends beyond 
column 72, into columns 73-76, which are not interpreted by the compiler; that is, 
the compiler reads IND-ACTIVITY rather than IND-ACTIVITY-FEE. 
Correction: Reformat the C O M P U T E statement so that IND-ACTIVITY-FEE appears 
o n the next line. 
5-S User-name STU-CREDITS not unique 
This message appears four times in a row and is associated with lines 163,174, 
176, and 179. This error message implies that two or m o r e data n a m e s are the same; 
in this instance S T U - C R E D I T S is defined in line 21 and again in line 81 (the latter 
should be DET-CREDITS), and the compiler does not k n o w which is which. 
Correction: Restore uniqueness to the data n a m e in line 81, by changing STU-
C R E D I T S to D E T - C R E D I T S . 
12-S Operand UNI-UNTOR-fEE is not declared 
The error message references U N I - U N I O N - F E E as an undefined symbol and 
is another example of h o w one error can cause several others. Hyphens were 
omitted in the definition of U N I - U N I O N - F E E in line 42, and thus (as far as the 
compiler is concerned) the data n a m e U N I - U N I O N - F E E does not exist. 
Correction: This diagnostic will disappear with the correction to line 42. 
34-S Operand UNI-SCHOLARSHIP should be numeric 
Arithmetic is permitted only o n numeric data names. U N I - S C H O L A R S H I P , 
however, w a s defined in line 44 as an alphanumeric rather than a numeric data 
n a m e , and hence the error. 
Correction: Change the P I C T U R E clause in line 44 from X(6) to 9(6). 
5-S User-name STU-CREDITS not unique 
This error is identical to the earlier non-unique message from lines 163, 174, 
175, 177, and 179. This error disguises another error. D E T - C R E D I T S has not been 
defined and should be flagged. In this case, the same correction fixes both problems. 
Correction: This error will disappear after changing S T U - C R E D I T S to D E T - C R E D I T S 
inline 81. 
330-S Not a record name 
A W R I T E statement, such as the one in line 209, requires a record n a m e rather 
than a file n a m e . 

Errors 
in 
Compilation 
This error is identical to the one in line 194 and is due to the omitted hyphens 
in the definition of U N I - U N I O N - F E E . 
Correction: N o n e required beyond the previous correction to line 42. 
These are all of the compilation errors detected by the Animator. This example 
was prepared for an earlier edition of the book and a different compiler. In making 
the conversion to Personal C O B O L w e found two errors that the Animator did not 
flag. The first was in line 163, where there is no space between the "=" and PRICE-
PER-CREDIT. C O B O L requires spaces before and after arithmetic operators, but 
evidently the Animator tolerates this error. Y o u should always m a k e it a habit to put 
spaces before and after arithmetic operators. Other compilers will not be as forgiving. 
The second error the Animator did not flag was in line 187. T h e M O V E 
statement moves the value of S T U - S C H O L A R S H I P (a four-position numeric field) 
to I N D - S C H O L A R S H I P (a three-position numeric field). The problem is that the 
sending field is larger than the receiving field, and thus the leftmost (most significant) 
digit m a y be truncated. This error could cause problems and should have had an I-
level or possibly W-level message.  
Compilation errors are a fact of life. Don't be discouraged if you have m a n y 
compilation errors in your first few attempts, and don't be surprised if you have 
several pages of diagnostics. R e m e m b e r that a single error in a C O B O L program can 
result in m a n y error messages, and that several errors often can be m a d e to disappear 
with one correction. Before leaving the subject, it is worthwhile to review a list of 
c o m m o n errors and suggested ways to avoid them: 
Nonuniquedata 
names. This error occurs because the s a m e data n a m e is defined in 
two different records or twice within the s a m e record. For example, C R E D I T S might 
be specified as an input field in S T U D E N T - F I L E and again as output in a detail line. 
Y o u can avoid the problem by prefixing every data n a m e within a record by a 
unique prefix as s h o w n below: 
01 STUDENT-RECORD 
05 STU-NAME 
10 STU-LAST-NAME 
10 STU-INITIALS 
05 STU-CREDITS 
05 STU-UNION-MEMBER 
05 STU-SCHOLARSHIP 
05 STU-GPA 
Omitted (or extra) periods. Every C O B O L sentence should have a period. Omission 
in the first three divisions often results in the compiler's assumption of a period 
where one belongs, and such errors are generally harmless. The effect is far m o r e 
serious in the Procedure Division, where missing and/or extra periods affect the 
generated logic. 

C
h
a
p
t
e
r 
6 
— 
Debugging 
Omitted space before or after an arithmetic operator. The arithmetic operators, **, *, 
/, +, and - ail require a space before and after (a typical error for BASIC programmers, 
since the space is not required in that language). 
Invalid picture clause for numeric entry. All data n a m e s used in arithmetic statements 
must have numeric picture clauses consisting of 9's, an implied decimal point, and 
an optional sign. 
Conflicting picture and value clause. Numeric pictures must have numeric values 
(no quotes); nonnumeric pictures must have nonnumeric values (enclosed in 
quotes). Both entries below are invalid. 
05 TOTAL 
PIC 9(3) VALUE '123'. 
05 TITLE 
PIC X(3) VALUE 123. 
Inadvertent use of COBOL reserved words. C O B O L has a list of s o m e 300 reserved 
words that can be used only in their designated sense; any other use results in 
one or several diagnostics. S o m e reserved words are obvious, for example, 
W O R K I N G - S T O R A G E , I D E N T I F I C A T I O N , E N V I R O N M E N T , D A T A , a n d 
P R O C E D U R E . Others—such as C O D E , D A T E , S T A R T , a n d R E P O R T — a r e less 
obvious. Instead of memorizing the list or continually referring to it, w e suggest 
this simple rule of thumb: Always use a hyphen in every data name you create. 
This will work m o r e than 9 9 % of the time. 
Conflicting RECORD CONTAINS clause and FD record description. This is a c o m m o n 
error, even for established programmers. It can stem from careless addition in that 
the s u m of the pictures in the F D does not equal the n u m b e r of characters in the 
R E C O R D C O N T A I N S clause. It can also result from other errors within the Data 
Division, for example, w h e n a n entry containing a P I C T U R E clause is flagged. 
( R e m e m b e r that if an E-level diagnostic occurs, that entry will be ignored, and the 
count is thrown off.) 
Receivingfield too small to accommodate sending field. This is an extremely c o m m o n 
error, often associated with edited pictures (editing is discussed in Chapter 7). 
Consider the entries: 
05 PRINT-TOTAL-PAY 
PIC $$,$$$. 
05 WS-T0TAL-PAY 
PIC 9(5). 
MOVE WS-T0TAL-PAY TO PRINT-TOTAL-PAY. 
The M O V E statement would generate the warning that the receiving field m a y be 
too small to a c c o m m o d a t e the sending field. The greatest possible value for W S -
T O T A L - P A Y is 99,999; the largest possible value that could be printed by PRINT-
T O T A L - P A Y is $9,999. Even though the picture for the print field contains five $'s, 
one $ must always be printed along with the numeric characters, hence the warning. 
Omitted (or extra) hyphens in a data name. This is a careless error, but one that 
occurs too often. If, for example, w e define PR I N T -T( )TAL- P A Y i n the Data Division 
and then reference P R I N T T O T A L - P A Y in the Procedure Division, the compiler 
catches the inconsistency. It doesn't state that a hyphen w a s omitted, but indicates 
that P R I N T and T O T A L - P A Y are undefined. 
A related error is the insertion of extra hyphens where they don't belong, for 
example, W O R K I N G - S T O R A G E S E C T I O N or DATA-DIVISION. 

Errors 
in 
Execution 
Misspelled data names or reserved words. T o o m a n y C O B O L students are poor 
spellers. S o u n d strange? H o w do you spell environment
1. O n e or m a n y errors can 
result, depending o n which w o r d was spelled incorrectly. 
Reading a record name or writing a file name. The C O B O L rule is very simple—read 
a file and write a record—but m a n y people get it confused. Consider: 
FD STUDENT-FILE 
DATA RECORD IS STUDENT-RECORD. 
FD PRINT-FILE 
DATA RECORD IS PRINT-RECORD. 
Correct 
entries: 
READ STUDENT-FILE . . . 
WRITE PRINT-RECORD . . . 
READ STUDENT-RECORD . . . 
WRITE PRINT-FILE . . . 
Going past column 72. This error can cause any of the preceding errors as well as a 
host of others. A C O B O L statement must end in column 72 or before; columns 73-
80 are left blank or used for program identification. (The 72-column restriction does 
not apply to data.) 
After a program has been successfully compiled, it can proceed to execution, and 
therein lies the strength and weakness of the computer. The primary attractiveness 
of the machine is its ability to perform its task quickly; its weakness stems from the 
fact that it does exactly what it has been instructed to do. The machine cannot think 
for itself; the programmer must think for the machine. If you were to inadvertently 
instruct the computer to compute tuition by charging $20 instead of $200 per credit, 
then that is what it would do. 
T o give you a n idea of what can happen, w e have deliberately altered the 
original tuition billing program of Chapter 5 and created a n e w program, s h o w n in 
Figure 6.3. Incorporated into this program are two types of errors: run time errors 
a n d logic errors. R u n time errors prevent the program from carrying out its task 
even though the program compiled properly. Logic errors do not stop the program, 
but they cause invalid output from the program. 
Tuition Billing Program with Execution Errors 
2 
3 
4 
5 
6 
7 
8 
9 
10 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
TUIT6EXE. 
AUTHOR. 
CAROL VAZ 
CAROL VAZQUEZ VILLAR. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR06\TUITII0N.DAT  
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 

C
h
a
p
t
e
r 6 — 
Debugging 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD STUDENT-FILE 
16 
RECORD CONTAINS 27 CHARACTERS. 
17 
01 STUDENT-RECORD. 
18 
05 STU-NAME. 
19 
10 STU-LAST-NAME 
PIC X(15) 
20 
10 STU-INITIALS 
PIC XX. 
21 
05 
STU-CREDITS 
PIC 9(2). 
22 
05 
STU-UNION-MEMBER 
PIC X. 
23 
05 
STU-SCHOLARSHIP 
PIC 9(4). 
24 
05 STU-GPA 
- - 
— 
_ 
_ 
25 
26 
FD PRINT-FILE 
27 
RECORD CONTAINS 132 CHARACTERS. 
28 
on 
01 PRINT-LINE 
PIC X(132). 
30 
WORKING-STORAGE SECTION. 
31 
01 DATA-REMAINS-SWITCH 
PIC X(2) VALUE SPACES 
32 
33 
01 INDIVIDUAL-CALCULATIONS. 
34 
05 
IND-TUITION 
PIC 9(4) VALUE ZEROS. 
35 
05 
IND-ACTIVITY-FEE 
PIC 9(2) VALUE ZEROS. 
36 
05 
IND-UNION-FEE 
PIC 9(2) VALUE ZEROS. 
37 
05 
IND-SCHOLARSHIP 
PIC 9(4) VALUE ZEROS. 
38 
05 
IND-BILL 
PIC 9(6) VALUE ZEROS. 
39 
40 
01 UNIVERSITY-TOTALS. 
41 
05 UNI-TUITION 
PIC 9(6) VALUE ZEROS. 
42 
05 UNI-UNION-FEE 
PIC 9(4) VALUE ZEROS. 
43 
05 
UNI-ACTIVITY-FEE 
PIC 9(4) VALUE ZEROS. 
44 
05 
UNI-SCHOLARSHIP 
PIC 9(6) VALUE ZEROS. 
45 
05 UNI-IND-BILL 
PIC 9(6) VALUE ZEROS. 
46 
47 
01 CONSTANTS-AND-RATES. 
48 
05 
PRICE-PER-CREDIT 
PIC 9(3) VALUE 200. 
49 
05 UNION-FEE 
PIC 9(2) VALUE 25. 
50 
05 ACTIVITY-FEES. 
51 
10 
1ST-ACTIVITY-FEE PIC 99 
VALUE 25. 
52 
10 
IST-CREDIT-LIMIT PIC 99 
VALUE 6. 
53 
10 2ND-ACTIVITY-FEE PIC 99 
VALUE 50. 
54 
10 
2ND-CREDIT-LIMIT PIC 99 
VALUE 12. 
55 
10 
3RD-ACTIVITY-FEE PIC 99 
VALUE 75. 
(continued) 

Errors 
in 
Execution 
(continued) 
56 
05 MINIMUM-SCHOLAR-GPA PIC 9V9 
VALUE 2.5. 
57 
58 
01 HEADING-LINE. 
59 
05 FILLER 
PIC X 
VALUE SPACES. 
60 
05 FILLER 
PIC X(12) VALUE 'STUDENT NAME 
61 
05 FILLER 
PIC X(10) VALUE SPACES. 
62 
05 FILLER 
PIC X(7) VALUE 'CREDITS'. 
63 
05 FILLER 
PIC X(2) VALUE SPACES. 
64 
05 FILLER 
PIC X(7) VALUE 'TUITION'. 
65 
05 FILLER 
PIC X(2) VALUE SPACES. 
66 
05 FILLER 
PIC X(9) VALUE 'UNION FEE'. 
67 
05 FILLER 
PIC X(2) VALUE SPACES. 
68 
05 FILLER 
PIC X(7) VALUE 'ACT FEE'. 
69 
05 FILLER 
PIC X(2) VALUE SPACES. 
70 
05 FILLER 
PIC X(ll) VALUE 'SCHOLARSHIP' 
71 
05 FILLER 
PIC X(2) VALUE SPACES. 
72 
05 FILLER 
PIC X{10) VALUE 'TOTAL BILL'. 
73 
7 A 
05 FILLER 
PIC X(48) VALUE SPACES. 
/4 
75 
01 DETAIL-LINE. 
76 
05 FILLER 
PIC X 
VALUE SPACES. 
77 
05 DET-LAST-NAME 
PIC X(15) 
78 
05 FILLER 
PIC X(2) VALUE SPACES. 
79 
05 DET-INITIALS 
PIC X(2). 
80 
05 FILLER 
PIC X(5) VALUE SPACES. 
81 
05 DET-CREDITS 
PIC 9(2). 
82 
05 FILLER 
PIC X(6) VALUE SPACES. 
83 
05 DET-TUITION 
PIC 9(6). 
84 
05 FILLER 
PIC X(7) VALUE SPACES. 
85 
05 DET-UNION-FEE 
PIC 9(3). 
86 
05 FILLER 
PIC X(6) VALUE SPACES. 
87 
05 DET-ACTIVITY-FEE 
PIC 9(3). 
88 
05 FILLER 
PIC X(8) VALUE SPACES. 
89 
05 DET-SCHOLARSHIP 
PIC 9(5). 
90 
05 FILLER 
PIC X(6) VALUE SPACES. 
91 
05 DET-IND-BILL 
PIC 9(6). 
92 
05 FILLER 
PIC X(49) VALUE SPACES. 
93 
94 
01 DASH-LINE. 
95 
05 FILLER 
PIC X(31) VALUE SPACES. 
96 
05 FILLER 
PIC X(8) VALUE ALL'-'. 
97 
05 FILLER 
PIC X(2) VALUE SPACES. 
98 
05 FILLER 
PIC X(8) VALUE ALL'-'. 
99 
05 FILLER 
PIC X(2) VALUE SPACES. 
100 
05 FILLER 
PIC X(7) VALUE ALL '-'. 

Chapter 
S — 
Debugging 
101 
05 FILLER 
PIC X(6) VALUE SPACES 
102 
05 FILLER 
PIC X(7) VALUE ALL '-
103 
05 FILLER 
PIC X(5) VALUE SPACES 
104 
05 FILLER 
PIC X(7) VALUE ALL '-
105 
05 FILLER 
PIC X(49) VALUE SPACES 
106 
107 
01 TOTAL-LINE. 
108 
05 FILLER 
PIC X(8) VALUE SPACES 
109 
05 FILLER 
PIC X(17) 
110 
VALUE 'UNIVERSITY TOTALS'. 
111 
05 FILLER 
PIC X(8) VALUE SPACES 
112 
05 TOT-TUITION 
PIC 9(6). 
113 
05 FILLER 
PIC X(6) VALUE SPACES 
114 
05 TOT-UNION-FEE 
PIC 9(4). 
115 
05 FILLER 
PIC X(5) VALUE SPACES 
116 
05 TOT-ACTIVITY-FEE 
PIC 9(4). 
117 
05 FILLER 
PIC X(7) VALUE SPACES 
118 
05 TOT-SCHOLARSHIP 
PIC 9(6). 
119 
05 FILLER 
PIC X(6) VALUE SPACES 
120 
05 TOT-IND-BILL 
PIC 9(6). 
121 
05 FILLER 
PIC X(49) VALUE SPACES 
122 
123 
PROCEDURE DIVISION. 
124 
PREPARE-TUIT ION-REPORT. 
125 
OPEN INPUT STUDENT-FILE 
126 
OUTPUT PRINT-FILE. 
127 
PERFORM WRITE-HEADING-LINE. 
128 
PERFORM READ-STUDENT-FILE. 
129 
PERFORM PROCESS-STUDENT-RECORD 
130 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
131 
PERFORM WRITE-UNIVERSITY-TOTALS. 
132 
CLOSE STUDENT-FILE 
133 
PRINT-FILE. 
134 
STOP RUN. 
135 
136 
WRITE-HEADING-LINE. 
137 
MOVE HEADING-LINE TO PRINT-LINE. 
138 
WRITE PRINT-LINE 
139 
AFTER ADVANCING PAGE. 
140 
MOVE SPACES TO PRINT-LINE. 
141 
WRITE PRINT-LINE. 
142 
143 
READ-STUDENT-FILE. 
144 
READ STUDENT-FILE 
145 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
(continued) 

Errors 
in 
Execution 
iguu& £.3 
(continued) 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
END-READ. 
PROCJiS^-^TUDENT-REXJORD. 
j PERFORM READ-STUDENT-FILET j - " " " " 
PERFORM COMPUTE-INDIVIDUAL-BILL. 
PERFORM INCREMENT-UNIVERSITY-TOTALS 
PERFORM WRITE-DETAIL-LINE. 
COMPUTE-INDIVIDUAL-BILL. 
PERFORM COMPUTE-TUITION. 
PERFORM COMPUTE-UNION-FEE. 
PERFORM COMPUTE-ACTIVITY-FEE. 
PERFORM COMPUTE-SCHOLARSHIP. 
COMPUTE IND-BILL = IND-TUITION + IND-UNION-FEE + 
IND-ACTIVITY-FEE - IND-SCHOLARSHIP. 
STU-CREDITS. 
COMPUTE-TUITION. 
COMPUTE IND-TUITION = PRICE-PER-CREDIT 
COMPUTE-]JN ION^FEE^ _ _ 
ITsTU-UNION-MEMBER = 'Y' 
MOVE ZERO TO IND-UNION-FEE 
! 
ELSE 
r~~" 
MOVE UNION-FEE TO IND-UNION-FEE j 
END-IF. 
j 
COMPUTE-ACTIVITY-FEE. 
EVALUATE TRUE 
WHEN STU-CREDITS <= 1ST-CREDIT-LIMIT 
MOVE 1ST-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 1ST-CREDIT-LIMIT 
AND STU-CREDITS <= 2ND-CREDIT-LIMIT 
MOVE 2ND-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 2ND-CREDIT-LIMIT 
MOVE 3RD-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN OTHER 
DISPLAY 'INVALID CREDITS FOR: ' STU-NAME 
END-EVALUATE. 
COMPUTE-SCHOLARSHIP. 
IF STU-GPA > MINIMUM-SCHOLAR-GPA 
MOVE STU-SCHOLARSHIP TO IND-SCHOLARSHIP 
ELSE 
MOVE ZERO TO IND-SCHOLARSHIP 

C
h
a
p
t
e
r 
6 
Debugging 
(continued) 
END-IF. 
INCREMENT-UNIVERSITY-TOTALS. 
ADD IND-TUITION 
TO UNI-TUITION. 
ADD IND-ACTIVITY-FEE TO UNI-ACTIVITY-FEE. I....---
ADD IND-SCHOLARSHIP TO UNI-SCHOLARSHIP.
 1 
I ADD I N D - B I L L _ 
TO UNI-IND-BILL. 
WRITE-DETAIL-LINE. 
MOVE STU-LAST-NAME TO DET-LAST-NAME. 
MOVE STU-INITIALS TO DET-INITIALS. 
MOVE STU-CREDITS TO DET-CREDITS. 
MOVE IND-TUITION TO DET-TUITION. 
MOVE IND-UNION-FEE TO DET-UNION-FEE. 
MOVE IND-ACTIVITY-FEE TO DET-ACTIVITY-FEE. 
MOVE IND-SCHOLARSHIP TO DET-SCHOLARSHIP. 
MOVE IND-BILL TO DET-IND-BILL. 
MOVE DETAIL-LINE TO PRINT-LINE. 
WRITE PRINT-LINE 
AFTER ADVANCING 1 LINE. 
WRITE-UNIVERS ITY-TOTALS. 
MOVE DASH-LINE TO PRINT-LINE. 
WRITE PRINT-LINE. 
MOVE UNI-TUITION TO TOT-TUITION. 
MOVE UNI-UNION-FEE TO TOT-UNION-FEE. 
MOVE UNI-ACTIVITY-FEE TO TOT-ACTIVITY-FEE. 
MOVE UNI]:-SCHOLARSHIP TO TOT-SCHOLARSHIP. 
. MOVE IND-BILL TO TOT-1ND-BILL. j \ 
MOVE TOTAL-LINE TO PRINT-LINE. 
WRITE PRINT-LINE 
AFTER ADVANCING 1 LINE. 
Input/Output operations occur throughout the execution of a COBOL program and 
consequently are a source of frequent run-time errors. 
The w i n d o w s h o w n in 
Figure 6.4a represents o n e of the m o s t c o m m o n types of errors—attempting to read 
from a file that doesn't exist. 
After w e click o n OK, the Animator s h o w s us the line w h e r e the error w a s 
detected, as in Figure 6.4b. The OPEN statement relates to the SELECT ... ASSIGN 
statements in the Environment Division. The COBOL SELECT statement ties a 
programmer-chosen file n a m e to an implementor n a m e . In W i n d o w s - b a s e d COBOL 
compilers the ASSIGN clause allows the definition of a file n a m e . The combination 
of SELECT and ASSIGN associates a COBOL file, such as STUDENT-FILE, with a file 
o n disk such as TUITION.DOT in Figure 6.4c, line 8. 
The p r o b l e m is that TUITION.DOT d o e s n o t exist; look carefully at the 
properties of TUITION in Figure 6.4d. The file extension is D/17Tather than DOT. In 
other words, the COBOL program is attempting to read from a file that isn't there, 
an impossible situation for the program that leads to an execution or run 
time 
system 
(RTS) error. 

Errors 
in 
Execution 
File Status Errors 
JJS 
ms 
12* 
tn 
ui 
: •» 
i - l 
1 
(35 
I.M 
135 
1 1 1 
iil 
in 
139 
Me 
J i l y « . « * , l w . i 
f * 
f ' 
»s 
t 
-
'TUinOH.DOT' 
The Animator is very picky about file names. For example, even if you spell 
the name correctly but do not correctly specify the path, the Animator may not be 
able to find the file. If the program specifies only the name and extension, but the 
actual file is in a working directory other than that expected by the Animator, the 
program will not be able to find the file. Appendix B shows you how to make sure 
that the Animator knows where to look for files. 

C
h
a
p
t
e
r 
6 — 
Debugging 
lie 
After correcting the file name, w e recompiled the program a n d ran it again, this 
time with the results in Figure 6.5. Figure 6.5a s h o w s another c o m m o n RTS error, 
"Illegal Character in Numeric Field." This error almost always c o m e s from having 
spaces in a numeric field. One cause of those spaces is w h e n the program reads a 
data file that actually has spaces in the field. In other words, if the field has a 
PICTURE of 9(5) and the actual contents are " 123", the program will fail if it tries to 
use this field in a computation. 
This problem is a data problem rather than a 
program problem. W h e n y o u create test data, b e sure to type in leading zeros for 
any numeric fields. In this case the field should have b e e n "00123". 
A s e c o n d reason for spaces in a numeric field is w h e n the program attempts to 
read b e y o n d the e n d of a file. The incorrect placement of the READ in line 149 of 
Figure 6.3 causes this condition. Figure 6.5b s h o w s the line where the error was 
detected. 
W e clicked o n each data n a m e in the statement, a n d the Animator 
s h o w e d us the current contents of the field. STU-CREDITS contains only spaces 
and caused the error. In this case, w h e n the program read b e y o n d the e n d of the 
file, COBOL inserted spaces into STUDENT-RECORD (line 17), including STU-
CREDITS. To correct the problem w e restored the READ to the e n d of PROCESS-
STUDENT-RECORD, recompiled the program, and reran it. This action corrects 
the run-time errors, but there are still logic errors to deal with. 
fare 6.5 
Illegal Character Run Time Error 
Illegal character in numeric field (Error 163) 
) OK j 
in time error messaoe 
162 
ffi3 
>(,< 
ICS 
1S>6 
16? 
1&« 
16} 
m 
J72 
l?« 
!V4 
iVT. 
i n 
COHJ'UII. rt>i f ! U N . 
COHP-JIL UNION F i t . 
Si' STl) UNI ON- MF 
HOBE ZERO 10 
ELSE 
MOUf UNION-F 
EHD-IF. 
court) r* ficnuitv-pe 
EUALUAIE TRUE 
—
—
2 
j|A»piyi A(Ml*l!tii Man llorj !i:jst! 
mi-H SIU-CREDITS <-- 1ST CREDIT-LIMIT 
rtOUi: iST-BCTIUIIi-FEE TO IND OCTIUI 
WHEN STU-CREDITS > 1ST CRKDIT I.IfllT 
J 

There are several subtle errors in Figure 6.6: 
1. The university total for union fees is zero rather than a computed amount. 
2. The s u m of the individual fills in the total line appears as 850 (the a m o u n t for 
the last record), rather than a running total of 24550. 
3. The union fees are reversed for each student. For example, lames and Baker 
are charged $25 w h e n they should be charged nothing; conversely, Part-
Timer a n d Jones are charged nothing w h e n their fee is $25. 
4. James was erroneously awarded a scholarship of $500; James, however, does 
not qualify because his average is below 2.5. 
W e emphasize that these logic errors are not contrived but are typical of 
students and beginning programmers. Even the accomplished practitioner can be 
guilty of similar errors w h e n rushed or careless. Realize also that logic errors occur 
without fanfare. There are no compiler diagnostics or RTS error messages to warn 
of impending trouble. The program has compiled cleanly and runs smoothly to the 
end; there is nothing to indicate a problem. 
The errors in Figure 6.3 are errors in execution, rather than in compilation. 
The program compiled cleanly because it is syntactically correct, but it executed 
improperly because it is logically incorrect. Nevertheless, the program did precisely 
what it was instructed to do, which, unfortunately, is not what the programmer 
wanted it to do. It is necessary, therefore, to find the source of each logic error, as 
discussed below. 
1. The totals for the university are computed in the paragraph I N C R E M E N T -
U N I V E R S I T Y - T O T A L S (lines 192-196), in which the individual amounts for 
the student being processed are added to the running university totals. Note, 
however, that the A D D statement for U N I - U N I O N - F E E is conspicuously 
absent, a n d hence the value of U N I - U N I O N - F E E remains unchanged 
throughout the program. 
2. UNI-IND-BILL is defined in line 45 a n d correctly incremented for each 
record in line 196; so far, so good. Flowever, w h e n the total line is built in line 
218, IND-BILL rather than UNI-IND-BILL is m o v e d to TOT-IND-BILL, 
causing the individual last bill (for Kerbel) to be printed as the total. 
3. I N D - U N I O N - F E E is calculated in a simple IF statement in lines 166-170, in 
which the IF a n d ELSE clauses are reversed; that is, the union fee is $25 for 
students w h o belong to the union as indicated by a Y in the appropriate 
incoming field. 
4. The definition S T U - G P A in line 24 incorrectly omits the implied decimal 
point in the P I C T U R E clause. Hence all incoming averages will be 
interpreted as ten times their true value (i.e., 2.5 will be stored as 25). Thus, 
all students will have an average greater than 2.5, and hence all students with 
potential scholarships will receive the award. 

Chapter 
6 — 
D 
ebugging 
Tuition Billing Report Comparisons—Invalid and Valid 
STUDENT NAME 
CREDITS TUITION UNION FEE/ACT FEE SCHOLARSHIP TOTAL BILL 
SMITH 
JB 
15 
003000 
000 
075 
00000 
003075 
JAMES 
HR 
15 
003000 
025 j 
075 
00500 
002600 
BAKER 
SR 
09 
001800 
025 1 
050 
00500 
001375 
PART-TIMER 
JR 
03 
000600 
000 j 
025 
00000 
000625 
JONES 
PL 
15 
003000 
000 | 
075 
00000 
003075 
HEAVYWORKER 
HM 
18 
003600 
025 1 
075 
00000 
003700 
LEE 
BL 
18 
003600 
025 I 
075 
00000 
003700 
CLARK 
JC 
06 
001200 
025 | 
025 
00000 
001250 
GROSSMAN 
SE 
07 
001400 
025 | 
050 
00000 
001475 
FRANKEL 
LF 
10 
002000 
025 | 
050 
00000 
002075 
BENWAY 
CT 
03 
000600 
025 I 
025 
00250 
000400 
KERBEL 
NB 
04 
000800 
025 | 
025 
00000 
000850 
UNIVERSITY TOTALS 
024600 
f "0000 ]-... 0625 
001250 
I 000850] 
STUDENT NAME 
CREDITS TUITION UNION FEE ACT FEE SCHOLARSHIP TOTAL BILL 
SMITH 
JB 
15 
003000 
025 
075 
00000 
003100 
JAMES 
HR 
15 
003000 
000 
075 
00000 
003075 
BAKER 
SR 
09 
001800 
000 
050 
00500 
001350 
PART-TIMER 
JR 
03 
000600 
025 
025 
00000 
000650 
JONES 
PL 
15 
003000 
025 
075 
00000 
003100 
HEAVYWORKER 
HM 
18 
003600 
000 
075 
00000 
003675 
LEE 
BL 
18 
003600 
000 
075 
00000 
003675 
CLARK 
JC 
06 
001200 
000 
025 
00000 
001225 
GROSSMAN 
SE 
07 
001400 
000 
050 
00000 
001450 
FRANKEL 
LF 
10 
002000 
000 
050 
00000 
002050 
BENWAY 
CT 
03 
000600 
000 
025 
00250 
000375 
KERBEL 
NB 
04 
000800 
000 
025 
00000 
000825 
UNIVERSITY TOTALS 
024600 
0075 
0625 
000750 
024550 
(b) Valid Output { from Cha oter 5} 
' S „ ',, 
X >Sl r 
It was easy to find the execution errors just discussed because we created them in 
j \ , - j|Cjf|jflt| 
the first place, and hence we knew exactly where to look. In practice, however, it is not so 
~ 
**' 
easy. Fortunately, the Personal C O B O L Animator provides some powerful tools to help 

with debugging programs. Appendix A gives an extended discussion of the Animator 
arid even has a short debugging tutorial. However, w e can provide a few tips here as 
well. 
1. Step through the program using the Watch Button. This button shows the 
contents of each field in the current statement. 
2. Use breakpoints to stop the program at critical junctures in the program. By 
using breakpoints, you can run the program at full speed until the 
breakpoint is encountered and then step through the questionable code. 
3. T o save paper, write your output to the screen rather than the printer. W h e n 
you are actually ready to print the report, a simple change to the A S S I G N will 
accomplish the task. For example: 
To print to screen: S E L E C T PRINT-FILE A S S I G N T O P R I N T E R 'CON'. 
T o print to printer: S E L E C T PRINT-FILE A S S I G N T O PRINTER. 
4. Double-clicking o n any data n a m e will bring up the current value of the field, 
whether it is in the current execution line or not. 
5. Using the Find option in the Edit M e n u will highlight all occurrences of a 
data n a m e in the program. 
There are m a n y other features in the Animator to help with debugging, and as 
you gain proficiency in programming you will see h o w to use them. 
It is often helpful to display intermediate results of a program as the program is 
being executed. O n e w a y to accomplish this is through the insertion of D I S P L A Y 
statements at strategic points in the program. The statement enables you to print 
the value of one or m o r e data n a m e s and/or one or m o r e literals without having to 
format a record description. Consider: 
identifier- 1 
DISPLAY 
1iteral-1 
identifier-2 
literal-2 
The DISPLAY statement produces the contents of each item listed in the order 
shown. For example, 
1. DISPLAY S T U D E N T - R E C O R D . 
2. DISPLAY 'Record being processed: ' S T U D E N T - R E C O R D . 
3. DISPLAY ' C O M P U T E - T U I T I O N paragraph is entered' 
4. DISPLAY'Student d a t a : ' S T U - N A M E STU-CREDITS. 
Examples one and two both display the value of the data n a m e S T U D E N T -
R E C O R D ; the second example, however, precedes the data n a m e with a literal to 
facilitate interpretation of the output. Example three displays just a literal but 
could be used (in conjunction with similar D I S P L A Y statements in other 
paragraphs) to s h o w the flow of program execution. Example four displays a literal 
and two data names. 

Chapter 
6 
Debugging 
Although it is reasonable to expect errors, the p r o g r a m m e r is also expected 
(reasonably) to find and correct them. Until recently, error detection and correction 
was a lonely activity. A programmer was encouraged to desk check—that 
is, read 
and reread the c o d e — i n an attempt to discern logical errors before they occurred. 
Desk checking is still a n important activity, but it is frequently supplemented by a 
newer technique, the structured 
walkthrough. 
The walkthrough brings the evaluation into the open. It requires a programmer 
to have his or her work reviewed formally and periodically by a peer group. T h e 
theory is simple—a programmer is too close to his or her work to see potential 
problems adequately a n d evaluate them objectively. The purpose of the walkthrough 
is to ensure that all specifications are met, a n d that the logic and its C O B O L 
implementation are correct. 
The earlier an error is found, the easier it is to correct and thus the single most 
important objective of a walkthrough is early error detection. Walkthroughs occur at 
several stages during a project, beginning in the analysis phase, where the purpose 
is to ensure that the systems analyst has understood the user's requirements. 
Walkthroughs occur again during the design phase, after the programmer has 
developed a hierarchy chart and/or associated pseudocode. Finally, walkthroughs 
occur during the implementation phase, during which the programmer presents 
actual code prior to testing. 
Walkthroughs are scheduled by the person being reviewed, w h o also selects 
the reviewers. T h e programmer distributes copies of the work (for example, a 
hierarchy chart, pseudocode, or a C O B O L program) prior to the session. Reviewers 
are supposed to study the material in advance so that they can discuss it intelligently. 
At the walkthrough itself, the p r o g r a m m e r presents the material objectively, 
concisely, a n d dispassionately. H e or she should encourage discussion a n d be 
genuinely glad w h e n errors are discovered. 
O n e of the reviewers should function as a moderator 
to keep the discussion 
o n track. Another should act as a secretary 
and maintain an action 
list of problems 
uncovered during the session. At the end of the walkthrough the action list is given 
to the programmer, w h o in turn is expected to correct the errors a n d notify attendees 
accordingly. T h e objective of the walkthrough is to find errors, not to correct them. 
The latter is accomplished by the programmer u p o n receipt of the action list. 
The preceding discussion m a y read well in theory, hut programmers often 
dislike the walkthrough concept. T h e probable reason is that they dislike having 
their work reviewed a n d regard criticism of code as a personal affront, intended or 
otherwise. This attitude is natural a n d stems from years of working as individuals. 
In addition, walkthroughs can and have b e c o m e unpleasant and ego-deflating 
experiences. "Structured walkover" a n d "stomp through" are terms that have been 
applied to less-than-successful sessions. Only if the atmosphere is kept o p e n and 
nondefensive, only if the discussion is restricted to major problems rather than 
trivial errors, a n d only if personality clashes are avoided can the walkthrough be an 
effective technique. T o have any chance of success, programmers w h o function as 
both reviewer a n d reviewee must adhere to the following guidelines: 
1. The program, and not the programmer, is reviewed. Structured walkthroughs 
are intended to find p r o g r a m m i n g problems; they will not be used by 
m a n a g e m e n t as a n evaluation tool. N o one should keep count of h o w m a n y 

The 
Structured 
Walkthrough 
errors are found in an individual's work or h o w m a n y errors one finds in 
someone else's. It is quite logical, therefore, to exclude the project m a n a g e r — 
that is, the individual in charge of salaries and promotions—from review 
sessions. 
2. Emphasis 
is on error detection, 
not correction. 
It is assumed that the individual 
being reviewed will take the necessary corrective action. Reviewers should not 
harp on errors by discussing how to correct them; indeed, no corrections 
whatever are m a d e during a walkthrough. 
3. Everyone, 
from 
senior 
analyst 
to trainee, 
has his or her work 
reviewed. 
This 
avoids singling out an individual and further removes any stigma from having 
one's work reviewed. It also promotes the give-and-take atmosphere that is so 
vital to making the concept work. 
4. A list of well-defined 
objectives 
for each session 
should be specified 
in 
advance. 
Adherence to this guideline keeps the discussion on track and helps to 
guarantee productive discussions. Another guideline is to impose a 
predetermined time limit, from half an hour to two hours. Walkthroughs will 
eventually cease to be productive and degenerate into a discussion of last 
night's ball game, the n e w manager, the latest rumor, or some other "hot" 
topic. The situation should be anticipated and avoided, perhaps by scheduling 
walkthroughs an hour before lunch. If all of the walkthrough's objectives have 
not been m e t w h e n the deadline is reached, schedule a second session. 
5. Participation 
must 
be encouraged 
and demanded 
from 
the reviewers. 
A 
walkthrough will indeed b e c o m e a waste of time if no one has anything to say. 
Let it be k n o w n in advance that each reviewer will be expected to m a k e at least 
two comments, one positive and one negative. Alternatively, require each 
reviewer to c o m e to the session with a list of at least three questions. 
S U M M A R Y 
'omts 
i
o 
Remember 
Compilation errors occur in the translation of COBOL to machine language 
and result from a violation of COBOL syntax—for example, a misspelled 
data name or an entry in the wrong column. 
Run time and execution errors develop after compilation has taken place, 
and are caused by improper logic and/or improper COBOL implementation 
of valid logic. 
A program may compile cleanly and be logically correct, yet still fail to 
execute if there are problems with the associated data files. Run time 
errors will occur and generate RTS error messages to help determine the 
cause of such data management errors. 
Sometimes data file problems are not the fault of the program, but are from 
the data file itself. The most common problem occurs when a numeric field 
includes spaces rather than zeroes. 

Chapter 
6 — 
Debugging 
The Animator provides many tools for debugging and can be quite helpful 
in tracking both syntax and logic errors. 
A structured walkthrough is an open evaluation of an individual's work by a 
group of his or her peers, with the primary objective of detecting errors as 
soon as possible in the development cycle. 
Key 
Words 
and 
Concepts 
Action list 
Compilation error 
Compiler option 
Cross-reference listing 
Debugging 
Desk checking 
Early error detection 
COBOL 
Element 
D1S P LAY 
F I L L - I N 
Execution error 
File status codes 
Interactive debugger 
Moderator 
Run Time System 
Secretary 
Structured walkthrough 
1. 
errors occur in the translation of COBOL to machine language. 
2. 
errors occur after a program has been successfully translated to 
machine language. 
3. Incorrect translation of valid pseudocode into COBOL will most likely produce  
errors. 
4. Misspelling a reserved word will most likely produce a 
error. 
5. If a program 
cleanly, it means only that the program has been 
successfully translated into machine language. 
6. 
errors are accompanied by some type of error message, whereas 
errors are frequently undetected by the computer. 
7. The process of peer review is known as a 
. 
8. The errors that are detected during a 
are 
entered on an 
, which is maintained by the 
secretary. 
9. The emphasis in a structured walkthrough is on error 
, not error 
10. One suggestion for conducting successful walkthroughs is to remember that the  
and not the 
is reviewed. 

i 1. 
cause a program to stop 
processing even though it is syntactically correct. 
12. 
are helpful in detecting 
errors in execution that pertain to data management. 
1. If a program compiles with no diagnostics, it must execute correctly. 
2. if a program compiles with warning diagnostics, execution will be suppressed. 
3. If a program contains logical errors but not syntactical errors, the compiler will print 
appropriate warnings. 
4. A COBOL program is considered data by the COBOL compiler. 
5. An error in one COBOL statement can cause errors in several other, apparently 
unrelated, statements. 
6. There are several different levels (of severity) of compilation errors. 
7. Paragraph names begin in the A margin. 
8. Spaces are required before and after arithmetic symbols. 
9. Spaces are required before and after punctuation symbols. 
10 A data name that appears in a COMPUTE statement can be defined with a picture 
of X's. 
11. Data names may contain blanks. 
12. The contents of columns 73-80 are ignored by the compiler. 
13. In a COBOL program one reads a record name and writes a file name. 
14. The emphasis in a structured walkthrough is on error detection rather than error 
correction. 
15. Walkthroughs should be held for trainees only, as these are the individuals most 
likely to make mistakes. 
16. Managers typically do not attend walkthroughs. 
17. A walkthrough generally takes a minimum of two hours. 
18. Walkthroughs should be restricted to the coding phase of a project. 
1. Has your work ever been the subject of a structured walkthrough? Was the 
experience helpful or a waste of time, or worse? Are you looking forward to your 
next walkthrough? 
2. Do you agree with banning managers from walkthroughs? Is it possible that the role 
of moderator in a walkthrough might best be filled by the project manager? 

C
h
a
p
t
e
r 
6 
Debugging 
3. Do you agree with the authors' suggestions for successful walkthroughs? Are there 
any guidelines you wish to add to the list? To remove from the iist? 
4. Identify the syntactical errors in the COBOL fragment in Figure 6.8. 
5. Identify the logical errors in the COBOL fragment in Figure 6.9. (Assume there are 
no other READ statements in the program.) 
6. The COBOL fragment in Figure 6.10a is taken from a program that compiled 
cleanly but failed to execute. The error message is in Figure 6.10b. Explain 
the problem. 
COBOL Fragment for Problem 4 
IDENTIFICATION DIVISION. 
PROGRAM ID. ERRORS. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
SELECT EMPLOYEE-FILE 
ASSIGN TO 'A:\CHAPTR06\EMP.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
DATA DIVISION. 
FILE SECTION. 
FD EMPLOYEE-FILE 
RECORD CONTAINS 50 CHARACTERS 
DATA RECORD IS EMPLOYEE-RECORD. 
EMPLOYEE-RECORD. 
05 EMP-NAME 
PIC X(20). 
05 EMP-NUMBER 
PIC X(9). 
05 FILLER 
PIC X(20). 
WORKING STORAGE SECTION. 
10 END-OF-FILE-SWITCH 
PIC X(3) 
VALUE BLANKS. 
m m 6.8 
COBOL Fragment for Problem 5 
WORKING-STORAGE SECTION. 
01 END-OF-FILE-SWITCH 
PIC X(3) 
VALUE 'YES'. 
PROCEDURE DIVISION. 
MAINLINE. 
PERFORM PROCESS-RECORDS 
UNTIL END-OF-FILE-SWITCH = 'YES' 
PROCESS-RECORDS. 
READ EMPLOYEE-FILE 
AT END MOVE 'YES' TO END-OF-FILE-SWITCH 
END-READ. 

Problems 
COBOL Fragment for Problem 6 
SELECT STUDENT-FILE 
ASSIGN TO 'A:\CHAPTR06\TUITI0N.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
PROCEDURE DIVISION. 
PREPARE-SENIOR-REPORT. 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
OPEN INPUT STUDENT-FILE 
OUTPUT PRINT-FILE. 
PERFORM WRITE-HEADING-LINE. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
CLOSE STUDENT-FILE 
PRINT-FILE. 
STOP RUN. 
Wrong open mode or access m o d e for read/start (Error 147) 
M -«-H 


Overview 
Editing 
The Decimal Point 
Zero Suppression 
Dollar Signs 
Commas 
Asterisks for Check Protection 
Insertion Characters 
Synopsis 
S i g n e d N u m b e r s 
CR and DB 
Plus and Minus Signs 
B L A N K W H E N Z E R O C l a u s e 
T h e Tuition Billing P r o g r a m R e v i s i t e d 
Coding S t a n d a r d s 
Data Division 
Procedure Division 
Both Divisions 
Programming Tip: Avoid Literals 
Programming Tip: Use Scope Terminators 
A Well-Written Program 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
7 
— 
Editing 
and 
Coding 
Standards 
OBJECTIVES  
After reading this chapter you will be able to: 
List the complete set of COBOL editing characters. 
Differentiate between a numeric field and a numeric-edited field; predict 
the results when a numeric field is moved to a numeric-edited field. 
Understand the difference between an implied decimal point and an actual 
decimal point; state the role of each in editing. 
Describe the rules for signed numbers and the editing characters +, 
CR, 
and DB. 
Describe the rationale for coding standards that go beyond the syntactical 
requirements of COBOL. 
OVERVIEW 
The chapter introduces editing—the ability to dress up printed reports by inserting 
dollar signs, decimal points, and so on, into numeric fields prior to printing. The 
chapter also introduces the concept of signed numbers and the use of CR and 
DB, or a plus and minus sign, to indicate positive or negative results. All ot this 
material is incorporated into the tuition billing program from Chapter 5. 
The second half of the chapter develops the rationale for coding standards, 
or requirements imposed by an installation to increase the readability (and 
maintainability) of COBOL programs. We present a series of typical standards 
and show how they are incorporated into existing programs. 
Editing 
The importance of editing is best demonstrated by comparing outputs from two 
programs. Figure 7.1a contains the original (unedited) output produced by the 
tuition billing program of Chapter 5. Figure 7.1b contains edited output, produced 
by a modified version of the program, which is presented later in the chapter. The 
last line of Figure 7.1b displays a n e w student, Lucky One, w h o s e scholarship grant 
exceeds the total a m o u n t of his bill, producing a credit of $150. (Lucky O n e is not 
s h o w n in Figure 7.1a as the original program did not address signed numbers.) The 
superiority of the edited output speaks for itself. 
The editing characters of Table 7.1 enable the kind of output s h o w n in 
Figure 7.1b. Editing is achieved by incorporating these characters into the various 
P I C T U R E clauses within a C O B O L program. 
The editing characters are not associated with the numeric fields used in 
computations, as these fields m a y contain only digits, an implied decimal point, 
and an optional sign. Additional data names, k n o w n as numeric-edited fields, are 
necessary within the program, a n d it is the picture clauses for the latter that contain 
editing characters from Table 7.1. In other words, arithmetic is performed o n numeric 
fields, whose computed values are subsequently m o v e d to numeric-edited fields, 
and the latter are printed. 

Editing 
Figure 7,1 
Comparison of Outputs 
i 
SMITH 
JB 
15 
003000 
025 
075 
00000 
003100 
JAMES 
HR 
15 
003000 
000 
075 
00000 
003075 
BAKER 
SR 
09 
001800 
000 
050 
00500 
001350 
PART-TIMER 
JR 
03 
000600 
025 
025 
00000 
000650 
JONES 
PL 
15 
003000 
025 
075 
00000 
003100 
HEAVYWORKER 
HM 
18 
003600 
000 
075 
00000 
003675 
LEE 
BL 
18 
003600 
000 
075 
00000 
003675 
CLARK 
JC 
06 
001200 
000 
025 
00000 
001225 
GROSSMAN 
SE 
07 
001400 
000 
050 
00000 
001450 
FRANKEL 
LF 
10 
002000 
000 
050 
00000 
002050 
BENWAY 
CT 
03 
000600 
000 
025 
00250 
000375 
KERBEL 
NB 
04 
000800 
000 
025 
00000 
000825 
UNIVERSITY TOTALS 
024600 
0075 
0625 
000750 
024550 
(a) Without Editing 
STUDENT NAME 
CREDITS TUITION UNION FEE ACT FEE SCHOLARSHIP TOTAL BILL 
SMITH 
JB 
15 
$3,000 
$25 
$75 
$3,100 
JAMES 
HR 
15 
$3,000 
$75 
$3,075 
BAKER 
SR 
9 
$1,800 
$50 
$500 
$1,350 
PART-TIMER 
JR 
3 
$600 
$25 
$25 
$650 
JONES 
PL 
15 
$3,000 
$25 
$75 
$3,100 
HEAVYWORKER 
HM 
18 
$3,600 
$75 
$3,675 
LEE 
BL 
18 
$3,600 
$75 
$3,675 
CLARK 
JC 
6 
$1,200 
$25 
$1,225 
GROSSMAN 
SE 
7 
$1,400 
$50 
$1,450 
FRANKEL 
LF 
10 
$2,000 
$50 
$2,050 
BENWAY 
CT 
3 
$600 
$25 
$250 
$375 
KERBEL 
NB 
4 
$800 
$25 
$825 
LUCKY ONE 
FR 
9 
$1,800 
$50 
$2000 
S150CR : 
UNIVERSITY TOTALS 
$26,400 / 
$75 
$675 
$2,750 
$24,400 
Student has been added to the original data ^ 
(a) With Editing 
;  
T A b L E 7.i 
Editing Characters 
Actual decimal point 
Zero suppression 
Dollar sign 
Comma 
Check protection 
Zero 
/ 
CR 
DB 
+ 
Blank 
Slash 
Credit character 
Debit character 
Plus sign 
Minus sign 
STUDENT NAME 
CREDITS TUITION UNION FEE ACT FEE SCHOLARSHIP TOTAL BILL 

C
h
a
p
t
e
r 
7 — 
Editing 
and 
Coding 
Standards 
The relationship between numeric fields and numeric-edited fields is illustrated 
in Figure 7.2, which depicts the calculation of tuition as credits times the rate ($200 
per credit). The incoming student record contains the field STU-CREDITS, with the 
calculated result defined in Working-Storage as IND-TUITION. The two fields are 
numeric, a n d do not contain any editing characters. 
O n the other hand, DETAIL-LINE contains two numeric-edited fields (I)ET-
C R E D I T S and DET-TUITION), each of which holds one or m o r e editing characters 
from Table 7.1. It is not necessary for you to k n o w the precise function of the various 
editing characters at this time; y o u need only perceive the difference between 
numeric a n d numeric-edited fields. 
The calculations within Figure 7.2 are done with the numeric fields (IND-
T U I T I O N and STU-CREDITS). Then, just prior to printing, the values in the numeric 
fields are m o v e d to the corresponding numeric-edited fields, which are printed. 
Let us consider the various editing characters from Table 7.1, in turn. 
- h e Decimal Point 
T h e actual 
decimal 
point is the most basic editing character. In reviewing this and 
other examples, it is essential that you r e m e m b e r that any move of a numeric field to 
a numeric-edited field maintains decimal alignment. Consider: 
05 FIELD-A 
P I C 9V99. 
05 FIELD-A-EDITED 
PIC 9.99. 
FIELD-A is a numeric field, with two digits after an implied decimal point. 
FIELD-A-EDITED is a numeric-edited field containing a n actual decimal point. All 
calculations are done using FIELD-A, which is m o v e d to FIELD-A-EDITED prior to 
printing by m e a n s of the statement M O V E FIELD-A T O FIELD-A-EDITED. Thus: 
Before 
move: 
After 
e x e c u t i o n 
The decimal point requires a position in FIELD-A-EDITED, but not in FIELD-A; that 
is, FIELD-A-EDITED is a/our-position field, whereas FIELD-A requires only three 
positions. 
H E L B - J t 
9 i . 9 9 
8 3 
Zevo Suppression 
..„. . 
O n e of the simplest editing requirements is to eliminate high-order (insignificant) 
zeros. For example, consider a numeric field defined with a P I C T U R E clause of 9(5), 
but whose value is 00120; in other words the two high-order positions contain 
insignificant zeros. It is likely that y o u would prefer the printed output to appear as 
120, rather than 00120, which is accomplished by the statement M O V E FIELD-B T O 
FIELD-B-EDITED as shown: 
05 FIELD-B 
PIC 9(5). 
05 FIELD-B-EDITED 
PIC 11219 
F I E L C m 
Be 
A 
ft 
Of(3 
n i o v s : 
0 j 0 
1 
£ 0 
Be 
A 
ft 
Be 
A 
ft & ? 
SX'3 
c u t i o 
n ' 
0 | 0 
1 2 0 
, 0 - B » E D I T E E 
Z Z I Z Z 9 

Editi n g 
"•iejars 7 , 2 
Numeric and Numeric-Edited Fields 
FD STUDENT FILE 
01 STUDENT-RECORD. 
| 05 STU-CREDITS 
PIC 99. 
WORKING-STORAGE SECTION. 
05 
IND-TUITION 
PIC 9(4). 
/ 
0 1 
CON S TANT-AND-RAT E S. _ 
05 PRICE-PER-CREDlf 
PIC~9(3) JIIMMIMO 
01 DETAIL-LINE. 
PROCEDURE DIVISION. 
COMPUTE IND-TUITION = PRICE-PER-CREDIT * STU-CREDITS 
SIZE ERROR DISPLAY 'Tuition exceeds expected maximum' 
END-COMPUTE. 
MOVE STU-CREDITS TO DET-CREDITS. { 
MOVE IND-TUITION TO DET-TUITION. I 
05 DET-CREDITS 
05 FILLER 
05 DET-TUITION 
PIC Z9. 
PIC X(5) I 
PIC~$$$$7$$9. 
VALUE SPACES, 

Chapter 
7 — 
Editing 
and 
Coding 
Standards 
The editing character Z indicates zero suppression, 
a n d prevents the printing of 
leading zeros. However, as soon as the first significant digit is reached (the 1 in this 
example), all subsequent digits are printed. Note, too, that the picture for FIELD-B-
E D I T E D has a 9 as the low-order character, to print a zero, rather than blank out the 
field entirely, in the event of a zero value. 
T h e dollar sign is used as an editing character in one of two ways, either in a fixed or 
/Zoatingposition. A single dollar sign in the numeric-edited picture will always print 
the dollar sign in the s a m e (fixed) position. Consider the following data n a m e s with 
the statement M O V E FIELD-C T O FIELD-C-EDITED: 
05 FIELD-C 
05 
FIELD-C-EDITED 
PIC 9(4). 
PIC $ZZZ9. 
Before 
0 0 14 3 
$ Z 
0 0 14 
A floating dollar sign is obtained by using multiple dollar signs in the edited 
field. Consider the following data n a m e s in conjunction with the statement M O V E 
FIELD-D T O FIELD-D-EDITED: 
05 FIELD-D 
05 
FIELD-D-EDITED 
PIC 9(4). 
PIC $$$$9. 
before move 
After e>, 
0 0 2 13 
$ $ ! $ ! $ 
0 0 
A single (floating) dollar sign is printed before the first significant digit in the 
edited field, with the leading zero digits, if any, replaced by blanks. In other words, 
the floating dollar sign has the s a m e effect as zero suppression. Note, too, that the 
receiving field m u s t be at least one character longer than the sending field to 
a c c o m m o d a t e the dollar sign; otherwise, a compiler warning results. 
A comma 
used as a n editing character causes a c o m m a to be printed, provided a 
significant digit appears to the left of the c o m m a . T h e c o m m a will be suppressed, 
however, if it is preceded by leading zeros. Consider the following data n a m e s in 
conjunction with the statement M O V E FIELD-E T O FIELD-E-EDITED: 
05 FIELD-E 
05 
FIELD-E-EDITED 
PIC 9(4). 
PIC $$,$$9. 
Arter 
I E L B - E 
F I E I 
,-iSIMTEB 
8 7 6 
$ 
$ 
$ 
$ 9 
T 8 , | 7 |6 5 
The c o m m a is printed in the indicated position. Suppc 
contents of the sending field are less than 1,000, a n d that the statement M O V E 
FIELD-F T O FIELD-F-EDITED is executed in conjunction with the fields: 

05 
FIELD-F 
PIC 9 ( 4 ) . 
05 
FIELD-F-EDITED 
PIC $$,$$9. 
0 | 0 
c o j 
7 I 
) $ ' $ ; . 
0 | 0 j 8 
i 
7 1 
j 
! j 
i 
i ! 
$|8|7 
The c o m m a is suppressed because it was not preceded by a significant digit. 
Observe also h o w the c o m m a is used in conjunction with a floating dollar sign. 
The asterisk 
is used as a fill character to avoid blanks between a fixed dollar sign and 
the first significant digit as in $****B7. Consider the following fields in conjunction 
with the statement M O V E FIELD-G T O FIELD-G-EDITED: 
05 
FIELD-G 
05 
FIELD-G-EDITED 
PIC 9 ( 5 ) . 
PIC $ * * , * * 9 . 
j 0 [ 0 | 0 
0 I 0 0 I 8 7 1 
* 
* i * 
The dollar sign will print in its fixed position, with asterisks replacing leading 
zeros. The use of the asterisk as a fill character is c o m m o n l y referred to as check 
protection. 
The slash, blank, and zero ( /, B, and 0, respectively) are insertion 
characters, 
meaning that they are printed exactly where they appear in an edited field. Consider 
the following fields together with the statement M O V E FIELD-H T O FIELD-H-
EDITED: 
05 
05 
FIELD-H 
FIELD-H-EDITED 
PIC 9 ( 6 ) . 
PIC 99/99/99. 
0 
3 1 6 1 8 
9 
o 
3 
1 6 | 8 | 9 
9 9 ; / 
9 | 9 / 
9 9 
0 
3 / 
1 | 6 / 
8 
9 
FIELD-H-EDITED is an eight-position field and is typical of h o w a date field m a y be 
edited. Blanks and zeros m a y be inserted in .similar fashion. Note, however, that the 
hyphen is not an insertion character and cannot, be used to place hyphens within a 
social security number. 
Table 7.2 provides an effective review of the editing characters covered so far. Each 
entry in the table shows the result of a M O V E statement of a numeric source field to 
a numeric-edited receiving field. All of the examples maintain decimal alignment as 
required. (The p which appears in several examples indicates a space.) 

Chapter 
7 — 
Fditmg 
and 
Coding 
Standards 
Review of Editing Characters 
PICTURE 
VALUE 
a. 9(4) 
0678 
b. 9(4) 
0678 
c. 9(4) 
0678 
d. 9(4)V99 
123456 
e 
9(4)V99 
123456 
r. 
9(4)V99 
123456 
3 9(4) 
0008 
h. 9(4)V9 
12345 
i. 9(4)V9 
12345 
i 9(5) 
00045 
k 9(9) 
123456789 
'•• 9(4) 
1234 
•v.. 9(6) 
080594 
n. 9(6) 
080594 
PICTURE 
EBfTED RESU 
Z(4) 
^678 
$9(4) 
$0678 
$Z(4) 
$^678 
9(4).99 
1234.56 
$9(4).99 
$1234.56 
$9,999.99 
<£ •£ <t £ <£ Q 
$1,234.56 
b( y, y, \k y& q 
9(4) 
ppppp$o 
1234 
9(4).99 
1234.50 
$***45 
999B99B9999 
123^45^6789 
$$,$$9.00 
$1,234.00 
99/99/99 
08/05/94 
Z9/99/99 
^8/05/94 
Thus far w e have considered only positive numbers, a rather unrealistic limitation. 
Numeric fields with negative values require an S in their P I C T U R E clause to indicate 
a signed field, that is, a field that m a y contain either positive or negative values. If 
the sign (the S in the P I C T U R E clause) is omitted, the value of the data n a m e will 
always be converted to a positive number, regardless of the result of the computation. 
Consider: 
05 FIELD-A 
PIC S99 
VALUE -20. 
05 FIELD-B 
PIC 99 
VALUE 15. 
05 FIELD-C 
PIC S99 
VALUE -20. 
05 FIELD-D 
PIC 99 
VALUE 15. 
ADD FIELD-B TO FIELD-A. 
ADD FIELD-C TO FIELD-D. 
Numerically, the s u m of -20 and +15 is -5, and there is n o problem w h e n the 
result is stored in FIELD-A as in the first c o m m a n d . In the second c o m m a n d , 
however, the s u m is stored in FIELD-D (an unsigned field), a n d thus it will assume a 
value of+5. Accordingly m a n y programmers adopt the habit of always using signed 
fields to avoid any difficulty. Signed numbers require additional editing characters. 
Financial statements use either the credit (CR) or debit (1)1$) character to indicate a 
negative number. In other words, the representation of a negative n u m b e r can be 
either C R or D B , a n d depends entirely o n the accounting system in use; s o m e 
systems use CR, whereas others will use D B . 
Table 7.3 contains four examples that should clarify the matter. In each 
instance, C R or D B appears only w h e n the sending field is negative [examples (b) 

use 
and (d)j. If the source field is positive or zero, C R and/or D B are replaced by blanks. 
T h e essential point is that C O B O L treats C R a n d D B identically, a n d the 
determination of which negative indicator to use depends o n the accounting system. 
'. • . 
.-• J= C R a n d D B Editing Characters 
P I C T U R E 
V A L U E 
PICTURE 
eaiX&Z 
R E S U L T 
a 
S9(5) 
98765 
$$$,999CR 
$98,765 
b. S9(5) 
-98765 
$$$,999CR 
$98,765CR 
c 
S9(5) 
98765 , 
$$$,999DB 
$98,765 
ci. S9(5) 
-98765 
$$$,999DB 
S98.765DB 
P i u s a n d M i i i i i s S i g n s 
. 
. 
. . . 
. . 
Table 7.4 illustrates the use of plus and minus signs. The repetition of a (plus or 
minus) sign within the edited P I C T U R E clause denotes a floating (plus or minus) 
sign, which will appear in the printed field immediately to the left of the first 
significant digit. A single (plus or minus) sign, however, indicates a fixed (plus or 
minus) sign, which prints in the indicated position. 
Specification of a (fixed or floating) plus sign displays the sign of the edited 
field if the n u m b e r is positive, negative, or zero [examples (a), (b), a n d (c)J. 
Specification of a minus sign, however, displays the sign only w h e n the edited 
result is negative. T h e receiving field must be at least one character longer than 
the sending field to accommodate the sign; otherwise, a compiler warning results. 
kBLE 7*4 
Floating Plus and Minus Sign 
S9(4) 
S9(4) 
S9(4) 
S9(4) 
S9(4) 
S9(4) 
S9(4) 
S9(4) 
VALUE 
PICTURE 
EDITED R E S U L 
1234 
++,+++ 
+1,234 
0123 
++,+++ 
00+123 
-1234 
++,+++ 
-1,234 
1234 
- - , 
,234 
0123 
—, 
000123 
-1234 
- - , 
-1,234 
1234 
11,119+ 
01,234+ 
-1234 
11,119+ 
01,234-
The B L A N K W H E N Z E R O clause produces a blank field w h e n the associated numeric 
value is zero. Although the s a m e effect can be achieved with certain editing strings, 
such as Z Z Z Z Z or $$$$$, there are times w h e n the clause is essential. A field with 
dollars and cents—for example, $$$9.99, formatted to print a digit immediately to 
the left of the decimal point—will print $0.00. In similar fashion it might be desirable 
to blank out a date field with PIC Z9/Z9/Z9 if the values are unavailable. T h e 
inclusion of B L A N K W H E N Z E R O at the e n d of the P I C T U R E clause in all three 
instances will accomplish the desired result. 

C
h
a
p
t
e
r 
7 
Editing 
and 
Coding 
Standards 
Xh© Tuition 
W e return once m o r e to Figure 7.1, the example with which w e began the chapter. 
Billing Program 
T h e
 
e a r "
e r version of the tuition billing program in Chapter 5 did not include 
D A u i c i t a f i 
editing characters, a n d so produced the output in Figure 7.1a. N o w w e incorporate 
n t ? V i s i l e ? U 
. 
^ . , . 
. 
, . . 
, 
. 
r 
. 
, 
the material just presented into a revised version of the program to produce the 
edited output of Figure 7.1b. 
The necessary changes are highlighted in Figure 7.3, which compares edited 
and unedited P I C T U R E clauses. The changes affect only the detail (7.3a) a n d total 
Figure 7.3 
Edited versus Unedited PICTURE Clauses 
E D I T E D F I E L D S 
U N E D I T E D F I E L D S 
01 DETAIL-LINE. 
05 FILLER 
PIC X 
VALUE SPACES. 
PIC X 
VALUE SPACES 
05 DET-LAST-NAME 
PIC X(15). 
PIC X(15) 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
PIC X(2) VALUE SPACES 
05 DET-INITIALS 
PIC X(2). 
PIC X(2). 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
PIC X(5) VALUE SPACES 
05 DET-CREDITS 
PIC Z9. 
PIC 9(2). 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
PIC X(6) VALUE SPACES 
05 DET-TUITI0N 
PIC $$$$,$ 19. 
PIC 9(6). 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
PIC X(7) VALUE SPACES 
05 DET-UNION-FEE 
PIC $$$9 
BLANK WHEN ZERO. 
PIC 9(3). 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
PIC X(6) VALUE SPACES 
05 DET-ACTIVITY-FEE 
PIC $$$9 
BLANK WHEN ZERO. 
PIC 9(3). 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
PIC X(8) VALUE SPACES 
05 DET-SCHOLARSHIP 
PIC $$.$$$' ) BLANK WHEN ZERO 
PIC 9(5). 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
PIC X(6) VALUE SPACES 
05 DET-IND-BILL 
PIC $$$$,$$9CR. 
PIC 9(6). 
05 FILLER 
PIC X(47) 
VALUE SPACES. 
PIC X(49) VALUE SPACES 
!a) Detail Line 
01 TOTAL-LINE. 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
PIC X(8) VALUE SPACES 
05 FILLER 
PIC X(17) 
PIC X(17) 
VALUE 'UNIVERSITY TOTALS'. 
VALUE 'UNIVERSITY 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
PIC X(8) VALUE SPACES 
05 TOT-TUITION 
PIC $$$$,$$9. 
PIC 9(6). 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
PIC X(6) VALUE SPACES 
05 TOT-UNION-FEE 
PIC $$$$,$$9. 
PIC 9(4). 
05 FILLER 
PIC X 
VALUE SPACES. 
PIC X(5) VALUE SPACES 
05 TOT-ACTIVITY-FEE 
PIC $$$$, f$9. 
PIC 9(4). 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
PIC X(7) VALUE SPACES 
05 TOT-SCHOLARSHIP 
PIC $$$$,, 
m
. 
PIC 9(6). 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
PIC X(6) VALUE SPACES 
05 T0T-IND-BILL 
PIC $$$$,< E$9CR. 
PIC 9(6). 
05 FILLER 
PIC X(47) 
VALUE SPACES. 
PIC X(49) VALUE SPACES 
(b) Total Lirv 

(7.3b) lines. Computations are m a d e within the program using the unedited 
P I C T U R E clauses found in I N D I V I D U A L - C A L C U L A T I O N S a n d UNIVERSITY-
TOTALS, then m o v e d to edited P I C T U R E clauses found in DETAIL-LINE a n d 
TOTAL-LINE, respectively. 
All of the calculations and editing are accomplished as illustrated earlier in 
Figure 7.2. The computed value of tuition, for example, is stored in the data n a m e 
I N D - T U I T I O N with PIC 9(6), then m o v e d to the edited field D E T - T U I T I O N with a 
PIC $$$$,$$9 prior to printing. 
Observe the presence of a C R within the P I C T U R E clauses for both DET-IND-
BILL and TOT-IND-BILL in Figures 7.3a and 7.3b, respectively. The C R is blanked 
out w h e n students o w e m o n e y to the university, but appears w h e n the student is 
due a credit (Lucky O n e in Figure 7.1b). Note, too, the various B L A N K W H E N Z E R O 
clauses throughout Figure 7.3, which produce the m o r e appealing edited output of 
Figure 7.1b contrasted to the zeros in Figure 7.1a. 
A good program is easily read and maintained by someone other than the author. 
Indeed, continuing success in a commercial installation depends on s o m e o n e other 
than the author being able to maintain a program. Most installations impose a set 
of coding standards, 
such as those described here, which go b e y o n d the 
requirements of the C O B O L compiler. These standards are optional for the student, 
but typical of what is required in the real world. 
The next several pages suggest a series of coding standards for you to use. 
However, there are no absolute truths—no right or wrong—insofar as programming 
style is concerned. Different programmers develop slightly or even radically different 
styles that are consistent with the rules of C O B O L and with the programmer's 
objective. The discussion that follows reflects the viewpoint of the authors and is 
necessarily subjective. 
W e begin with suggestions for the Data Division. 
Choose meaningful 
names. Avoid taking the easy w a y out with two- or three-
character data names. It is impossible for the maintenance programmer, or even 
the original author, to determine the meaning of abbreviated data names. T h e 
usual student response is that this adds unnecessarily to the burden of writer's 
cramp. Initial coding, however, takes only 5-10% of the total time associated with a 
program (maintenance, testing, and debugging take the vast majority), and the 
modest increase in coding time is m o r e than compensated by improvements in the 
latter activities. 
Prefix all data names within the same FD or 01 with two or three characters unique to 
the FD; for example, O M - L A S T - N A M E , OM-BIRTH-DATE. T h e utility of this 
guideline becomes apparent in the Procedure Division if it is necessary to refer back 
to the definition of a data n a m e . 
Begin all PICTURE clauses in the same column. Usually in columns 36-48, but the 
choice is arbitrary. D o not be unduly disturbed if one or two entries stray from the 
designated column, because of long data names and/or indentation of level numbers. 
Choose one form of the PICTURE clause. Choose PIC, PIC IS, P I C T U R E , or 
P I C T U R E IS and follow it consistently. PIC is the shortest and is as g o o d as any. 

C
h
a
p
t
e
r 
7 — 
Editing 
and 
Coding 
Standar 
P
R
O
G
R
A
M
M
I
N
G 
T I P 
The constant (literal) portion of a print line should be defined in Working-Storage, rather than moved to the print 
line in the Procedure Division. Consider the following: 
MOVE 'STUDENT NAME 
SOC SEC NUM CREDITS TUITION 
- j_J SCHOLARSHIP FEES' TO PRINT-LINE. 
WRITE PRINT-LINE. 
^
n
e
n 
r?4ui.>ea » continue nonnumenc 
u-ei s; 
01 
HEADING-LINE. 
05 
PIC X(12) 
VALUE 'STUDENT NAME' 
05 
PIC X(10) 
VALUE SPACES. 
05 
PIC X(ll) 
VALUE 'SOC SEC NUM'. 
05 
PIC X(2) 
VALUE SPACES. 
05 
PIC X(7) 
VALUE 'CREDITS' . 
05 
PIC X(2) 
VALUE SPACES. 
05 
PIC X(7) 
VALUE 'TUITION'. 
05 
PIC X(3) 
VALUE SPACES. 
05 
PIC X(ll) 
VALUE 'SCHOLARSHIP'. 
05 
PIC X(2) 
VALUE SPACES. 
05 
PIC X(4) 
VALUE 'FEES'. 
WRITE PRINT-LINE FROM HEADING-LINE. 
The poor code illustrates continuation of a nonnumeric literal. The first line begins with an apostrophe 
before STUDENT NAME and ends without a closing apostrophe in column 72. The continued line contains a 
hyphen in column 7, and both a beginning and ending apostrophe. 
The improved code may appear unnecessarily long in contrast to the poor code. However, it is an 
unwritten law that users will change column headings, and/or spacing at least twice before being satisfied. 
Such changes are easily accommodated in the improved code but often tedious in the original solution. 
Assume, for example, that four spaces are required between CREDITS and TUITION, rather than the two that 
are there now. Modification of the poor code requires that both lines in the MOVE statement be completely 
rewritten, whereas only a PICTURE clause changes in the improved version. Note, too, that the improved code 
can be rewritten to reduce the number of FILLER entries, and also to eliminate the word FILLER, as 
shown below. 
01 
HEADING-LINE. 
05 
PIC X(22) 
VALUE 'STUDENT NAME'. 
05 
PIC X(13) 
VALUE 'SOC SEC NUM'. 
05 
PIC X(9) 
VALUE 'CREDITS'. 
05 
PIC X(10) 
VALUE 'TUITION'. 
05 
PIC X(13) 
VALUE 'SCHOLARSHIP'. 
05 
PIC X(4) 
VALUE 'FEES'. 
In this example each VALUE clause contains fewer characters than the associated PICTURE clause. 
Accordingly, alignment is from left to right, with the extra (low-order) positions padded with blanks. 

Indent 
successive 
level numbers 
under 
a 01 consistently. 
For example, two or four 
columns. Leave gaps between adjacent levels (for example, 01, 05, 10, 15 or 01, 04, 
08, 12) instead of using consecutive numbers; that is, avoid 01, 02, 03 (as discussed 
in Chapter 4). Use the same level numbers from F D to FD to maintain consistency 
within a program. 
Avoid 77-level entries. 
77-Ievel entries have not been mentioned in the text, because 
current programming practice argues for their elimination. Nevertheless, they are 
apt to be found in existing programs and are discussed now for that reason. 
A 77-level entry was originally defined as an independent data name with no 
relationship to any other data name in a program. (77-level entries are coded as 
elementary items in Working-Storage.) However, few if any data n a m e s are truly 
independent, and 77-level entries should be avoided for that reason. The authors, 
for example, have gotten along quite nicely by grouping related entries under a 
common 01 description. Consider the following: 
77 
TUITION 
PIC 9(4)V99 
VALUE ZEROS. 
77 ACTIVITY-FEE 
PIC 9(2) 
VALUE ZEROS. 
77 
U N I O N - F E E 
PIC 9(2) 
VALUE ZEROS. 
01 
INDIVIDUAL-CALCULATIONS. 
05 
IND-TUITION 
P I C 9 ( 4 ) V 9 9 
VALUE ZEROS. 
05 
IND-ACTIVITY-FEE 
PIC 9(2) 
VALUE ZEROS. 
05 
IND-UNION-FEE 
PIC 9(2) 
VALUE ZEROS. 
The improved code also uses a common prefix, which reflects the similarities 
among the related items. There is simply no reason to use the older approach of 
independent data items. 
Procedure I M v i s i o i i 
Develop 
functional 
paragraphs. 
Every.' statement in a paragraph should be related 
to the overall function of that paragraph, which in m m should be reflected in the 
paragraph name. A well-chosen n a m e will consist of a verb, one or two adjectives, 
and an object; for example, R E A D - S T U D E N T - F I L E , WRITE-HEADING-LINE, and 
so on. If a paragraph cannot be named in this manner, it is probably not functional, 
and consideration should be given to redesigning the program and/or paragraph. 
Sequence 
paragraph 
names. 
Programmers and managers alike accept the utility of 
this guideline to locate paragraphs in the Procedure Division quickly. However, 
there is considerable disagreement on just what sequencing scheme to use: all 
numbers, a single letter followed by numbers, and so on. We make no strong 
argument for one scheme over another, other than to insist that a consistent 
sequencing rule be followed. S o m e examples are A 0 1 0 - W R I T E - N E W - M A S T E R -
R E C O R D a n d 1 0 0 - P R O D U C E - E R R O R - R E P O R T . 
Avoid 
commas. 
T h e compiler treats a c o m m a as noise; it has no effect o n the 
generated object code. M a n y programmers have acquired the habit of inserting 
c o m m a s to increase readability. T h o u g h this works rather well with prose, it can 
have just the opposite effect in C O B O L , because of blurred print chains, which 
make it difficult to distinguish a c o m m a from a period. The best solution is to try to 
avoid c o m m a s altogether. 
Use scope terminators. 
E N D - I F (see programming tip on page 182) is one of several 
scope terminators included in C O B O L - 8 5 that should be used whenever possible to 

Chapter 
7 — 
Editing 
and 
Coding 
Standards 
P R O G R A M M I N G 
T I P 
Scope terminators are one of the most powerful enhancements in COBOL-85, and in the opinion of the 
authors, justify in and of themselves, conversion to the new standard. In its simplest role a scope terminator is 
used in place of a period to end a conditional statement—for example, END-IF to terminate an IF statement. 
(A scope terminator and a period should not appear together unless the period also ends the sentence.) 
One of the most important reasons for using scope terminators is that they eliminate the very subtle 
column 73problem which has always existed, and which is depicted below. The intended logic is straightforward, 
and is supposed to apply a discount of two percent on an order of $2,000 or more. The amount due (NET) is 
equal to the amount ordered less the discount (if any). 
IF AMOUNT-ORDERED-Til ISWEEK < 2000 
MOVE ZEROS TO CUSI0MER-DISC0UNT 
ELSE 
COMPUTE CUSTOMER-DISCOUNT = AMOUNT-ORDERED-THISWEEK * .02,].. 
I COMPUTEJET = ATOUNT-ORDERED-THISWEEK - CUSTOMER-DISCOUNT.\ 
Amount ordered 
Discount 
Net 
3000 
60 
2940 
4000 
80 
3920 
1000 
0 
3920 
5000 
100 
4900 
1500 
0 
[ 49oo ] 
The COBOL statements appear correct, yet the output is wrong! In particular, the net amounts are 
wrong for any order less than $2,000 (but valid for orders of $2,000 or more). The net amount for orders less 
than $2,000 equals the net for the previous order (that is, the net for an order of $1,000 is incorrectly printed as 
$3,920, which was the correct net for the preceding order of $4,000). The net amount for an order of $1,500 
was printed as $4,900, and so on. Why? 
The only possible explanation is that the COMPUTE NET statement is not executed for net amounts less 
than $2,000. The only way that can happen is if the COMPUTE NET statement is taken as part of the ELSE 
clause, and that can happen only if the ELSE is not terminated by a period. The period is present, however, so 
we are back at ground zero—or are we? 
The period is present, but in column 73, which is ignored by the 
compiler. Hence the visual code does not match the compiler interpretation, and the resulting output is 
incorrect. Replacing the period by the END-IF delimiter will eliminate this and similar errors in the future. 
(Remember, a period may appear af the end of the sentence after the END-IF terminator.) 

Coding 
Standards 
Space attractively. The adoption of various spacing conventions can go a long w a y 
toward improving the appearance of a program. The authors believe very strongly 
in the insertion of blank lines throughout a program to highlight important 
statements. Specific suggestions include a blank line before all paragraphs, FDs, 
and 01 entries. 
You can also force various portions of a listing to begin o n a n e w page, by 
putting a slash in column 7 of a separate statement. 
Avoid constants. A significant portion of maintenance programming (and headaches) 
could be avoided if a program is written with an eye toward change. Consider: 
COMPUTE IND-TUITION = 200 * STU-CREDITS. 
WORKING-STORAGE SECTION. 
01 CONSTANTS-AND-RATES. 
05 PRICE-PER-CREDIT 
PIC 9(4) 
VALUE 200. 
PROCEDURE DIVISION. 
COMPUTE IND-TUITION = PRICE-PER-CREDIT * STU-CREDITS. 
The improved code is easy to modify w h e n (not if) the tuition rate changes as the 
only required modification is to the V A L U E clause in Working Storage. The poor 
terminate a conditional statement. The E N D - R E A D terminator should be used in 
similar fashion to end the conditional A T E N D clause in the R E A D statement. 
Indent. Virtually all programmers indent successive level numbers in the Data 
Division, yet m a n y of these same individuals do not apply a similar principle in the 
Procedure Division. T h e readability of a program is enhanced significantly by 
indenting subservient clauses under the main statements. S o m e examples: 
READ STUDENT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH 
END-READ. 
PERFORM 0020-PROCESS-A-RECORD 
UNTIL DATA-REMAINS-SWITCH 
= 'NO'. 
IF STU-UNION-MEMBER =
 1Y' 
MOVE UNION-FEE TO IND-UNION-FEE 
ELSE 
MOVE ZERO TO IND-UNION-FEE 
END-IF. 
COMPUTE IND-TUITION = PRICE-PER-CREDIT * STU-CREDITS 
SIZE ERROR DISPLAY 'Size error for individual tuition' 
END-COMPUTE. 

C
h
a
p
t
e
r 
7 
Editing 
and 
Coding 
Standards 
code requires changes to the appropriate Procedure Division statement(s), and if 
the constant 200 appears more than once in the Procedure Division, it is very easy 
to miss s o m e of the statements in which the change is required. There is less 
possibility for error in the improved code. 
Don't overcomment. Contrary to popular belief, the mere presence of c o m m e n t s 
does not ensure a well-documented program, and poor c o m m e n t s are sometimes 
worse than no c o m m e n t s at all. The most c o m m o n fault is redundancy with the 
source code. Consider: 
* 
CALCULATE NET PAY 
COMPUTE NET-PAY = GROSS-PAY - FED-TAX - VOL-DEDUCT. 
The c o m m e n t detracts from the readability of the statement because it breaks the 
logical flow as you read the Procedure Division. Worse than redundant, c o m m e n t s 
m a y be obsolete or inconsistent with the associated code, as is the case w h e n 
program statements are changed during maintenance, and the c o m m e n t s are not 
correspondingly altered. 
T h e authors certainly d o not advocate the elimination of c o m m e n t s 
altogether, but argue simply that care, m o r e than is c o m m o n l y exercised, should 
be applied to developing them. O n e guideline is to provide a c o m m e n t whenever 
the purpose of a program statement is not immediately obvious. Imagine, for 
example, that you are turning the program over to s o m e o n e else for maintenance, 
and insert a c o m m e n t whenever you would explain a statement to the other 
person. C o m m e n t s should be used only to show why you are doing something, 
rather than what you are doing. A s s u m e that the maintenance programmer is as 
competent in C O B O L as you are; avoid using c o m m e n t s to explain h o w a particular 
C O B O L statement works. 
Figure 7.4 is our final pass at the tuition hilling program, with attention drawn to the 
application of the coding standards just developed. All data n a m e s within a 01 entry 
are given a c o m m o n prefix: S T U for entries in S T U D E N T - R E C O R D (lines 17-24), 
I N D for data n a m e s under I N D I V I D U A L - C A L C U L A T I O N S (lines 34-38), and so 
on. This guideline applies equally well to record descriptions in both the File and 
Working-Storage Sections. 
Blank lines highlight 01 entries in the Data Division and paragraph headers in 
the Procedure Division. All P I C T U R E clauses are vertically aligned. Indentation is 
stressed in the Procedure Division with subservient clauses four columns under the 
associated statements. 
Paragraph headers are sequenced and functional in nature. All statements 
within a paragraph pertain to the function of that paragraph, as indicated by its 
n a m e . W e have chosen a three-digit numerical sequencing scheme, in which the 
first digit reflects the hierarchy chart level and the remaining two digits reflect the 
order in which the paragraphs are performed. 

A 
Well-Written 
Program 
A Well-Written COBOL Program 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
TUITI0N7. 
AUTHOR. 
CAROL VAZQUEZ VILLAR. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR07\TUITI0N.DAT 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
DATA DIVISION. 
FILE SECTION. 
FD STUDENT-FILE 
RECORD CONTAINS 27 CHARACTERS. 
STUDENT-RECORD. 
01 
05 STU -NAME. 
10 STU-lAST-NAME 
PIC X(15) 
10 STU-INITIALS 
PIC XX. 
05 STU -CREDITS 
PIC 9(2). 
05 STU--UNION-MEMBER 
PIC X. 
05 STU--SCHOLARSHIP 
r* T r> n 1 * \ 
05 STU--GPA 
PIC 9V99. 
FD 
01 
PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS. 
PRINT-LINE 
PIC X(132). 
WORKING-STORAGE SECTION. 
01 
DATA-REMAINS-SWITCH 
34 
05 IND-TUITION 
PIC 9(4) 
35 
05 IND-ACTIVITY-FEE 
PIC 9(2) 
36 
05 IND-UNION-FEE 
PIC 9(2) 
37 
05 IND-SCHOLARSHIP 
PIC 9(4) 
38 
05 IND-BILL 
PIC S9(6) 
39 
j 
40 
01 UNIVERSITY-TOTALS. 
41 
05 UNI-TUITION 
PIC 9(6) 
42 
05 UNI-UNION-FEE 
PIC 9(4) 
43 
05 UNI-ACTIVITY-FEE 
PIC 9(4) 
44 
05 UNI-SCHOLARSHIP 
PIC 9(6) 
45 
05 UNI-IND-BILL 
PIC S9(6) 
46 
I 
47 
01 "CONSTANTS-AND-RATES. 
48 
05 PRICE-PER-CREDIT 
PIC 9(3) 
49 
05 UNION-FEE 
PIC 9(2) 
50 
05 
Ml, ! I ¥ i I i - r c t j . 
PIC X(2) 
VALUE SPACES. 
VALUE ZEROS. 
VALUExZEROS. 
VALUE ZEROS. 
VALUE ZERuS\ 
VALUE ZEROS. 
VALUE ZERjBS. 
VALUEXZEROS. 
VAj_UE ZEROS. 
/VALUE ZEROS. 
VALUE 200. 
VALUE 25. 

Chapter 
7 — 
Editing 
and 
Coding 
Standard 
10 1ST-ACTIVITY-FEE PIC 99 
VALUE 25. 
10 IST-CREDIT-LIMIT PIC 99 
VALUE 6. 
10 2ND-ACTIVITY-FEE PIC 99 
VALUE 50. 
10 2ND-CREDIT-LIMIT PIC 99 
VALUE 12. 
10 3RD-ACTIVITY-FEE PIC 99 
VALUE 75. 
05 MINIMUM-SCHOLAR-GPA PIC 9V9 
VALUE 2.5. 
HEADING-LINE. 
05 FILLER 
PIC X 
VALUE SPACES. 
05 FILLER 
PIC X(12) VALUE 'STUDENT NAME' 
05 FILLER 
PIC X(10) VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE 'CREDITS'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE 'TUITION' . 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 
FILLER 
PIC X(9) 
VALUE 'UNION FEE'. 
05 
FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE 'ACT FEE'. 
05 
FILLER 
PIC X{2) 
VALUE SPACES. 
05 FILLER 
PIC X(ll) VALUE 'SCHOLARSHIP'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(10) VALUE 'TOTAL BILL'. 
05 FILLER 
PIC X(48) VALUE SPACES. 
01 DETAIL-LINE. 
05 FILLER 
PIC X 
VALUE SPACES. 
05 DET-LAST-NAME 
PIC X(15). 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 DET-INITIALS 
PIC X(2). 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
05 DET-CREDITS 
PIC Z9. 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
05 DET-TUITION 
PIC $$$$,$$9. 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
05 DET-UNION-FEE 
PIC $$$9 
BLANK WHEN ZERO 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
05 DET-ACTIVITY-FEE 
PIC $$$9 
BLANK WHEN ZERO 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
05 DET-SCHOLARSHIP 
PIC $$,$$$9 BLANK WHEN ZERO 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
05 DET-IND-BILL 
PIC $$$$,$$9CR. 
05 
r- r I t r rj 
r i L L Q K 
PIC X(47) VALUE SPACES. 
DASH-LINE. 
05 FILLER 
PIC X(31) VALUE SPACES. 
05 FILLER 
PIC X(8) 
VALUE ALL '-'. 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(8) 
VALUE ALL 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
05 FILLER 
PIC X(7) 
VALUE ALL '-'. 
(continued) 

A 
Well-Written 
Program 
(continued) 
101 
05 FILLER 
PIC X(6) VALUE SPACES. 
102 
05 FILLER 
PIC X(7) VALUE ALL '-' 
103 
05 FILLER 
PIC X(5) VALUE SPACES. 
104 
05 FILLER 
PIC X(7) VALUE ALL '-' 
105 
05 FILLER 
PIC X(49) VALUE SPACES. 
106 
107 
01 TOTAL-LINE. 
108 
05 FILLER 
PIC X(8) VALUE SPACES. 
109 
05 FILLER 
PIC X(17) 
110 
VALUE 'UNIVERSITY TOTALS'. 
111 
05 FILLER 
PIC X(6) VALUE SPACES. 
112 
05 iTOT-TUITIONj _^ 
PIC $$$$,$ E9. 
113 
05 FILLER 
" P I C X(2) VALUE SPACES. 
114 
05 "TOT-UNION-FEE 
PIC $$$$,$ t9. 
115 
05 FILLER 
PIC X 
VALUE SPACES. 
116 
05 TOT-ACTIVITY-FEC" - PIC $$iS,$ 
19. 
117 
05 FILLER 
PIC X(5) VALUE SPACES-
118 
05 iTOT-SCHOLARSHIP
 ! 
PIC $$$$",$ 59. 
119 
05 FILLER 
PIC X{4) VALUE SPACES. 
120 
05 TOT-1ND-BiLI 
PIC $$$$,$$9CR. 
121 
05 FILLER 
PIC X(47) VALUE SPACES. 
122 
123 
PROCEDURE DIVISION. 
124 
100 -PREPARE-TUITION-REPORT. 
125 
OPEN INPUT STUDENT-FILE 
126 
OUTPUT PRINT-FILE. 
127 
PERFORM 210-WRITE-HEADING-LINE. 
128 
PERFORM 230-READ-STUDENT-FILE. 
129 
PERFORM 260-PROCESS-STUDENT-RECORD 
130 
UNTIL DATA-REMAINS-SWITCH = 'NO 
131 
PERFORM 290-WRITE-UNIVERSITY-TOTALS. 
132 
CLOSE STUDENT-FILE 
133 
PRINT-FILE. 
134 
STOP RUN. 
135 
136 
210--WRITE-HEADING-LINE. 
137 
MOVE HEADING-LINE TO PRINT-LINE. 
138 
WRITE PRINT-LINE 
139 
AFTER ADVANCING PAGE. 
140 
MOVE SPACES TO PRINT-LINE. 
141 
WRITE PRINT-LINE. 
142 
143 
230- READ-STUDENT-FILE. 
144 
READ STUDENT-FILE 
145 
AT END MOVE 'NO' TO DATA-REMAINS- SWITCH 
146 
END-READ. 
147 
148 
260- PROCESS-STUDENT-RECORD. 
149 
PERFORM 310-COMPUTE-INDIVIDUAL-BILL. 
150 
PERFORM 330-INCREMENT-UN IVER-TOTALS 

Chapter 
7 — 
Editing 
and 
Coding 
Standard 
}ure 7.4 
(continued) 
151 
PERFORM 360-WRITE-DETAIL-LINE. 
152 
PERFORM 230-READ-STUDENT-FILE. 
153 
154 
[29£^rfE^i|vppfprOTLs7} 
155 
" 
MO V E D AS H - L IN E TO P RI NT - LINE. 
_ 
156 
WRITE PRINT-LINE. 
157 
MOVE UNI-TUITION TO TOT-TUITION. 
158 
MOVE UNI-UNION-FEE TO TOT-UNION-FEE. 
159 
MOVE UNI-ACTIVITY-FEE TO TOT-ACTIVITY-FEE. 
160 
MOVE UNI-SCHOLARSHIP TO TOT-SCHOLARSHIP. 
161 
MOVE UNI-IND-BILL TO TOT-IND-BILL. 
162 
MOVE TOTAL-LINE TO PRINT-LINE. 
163 
WRITE PRINT-LINE 
164 
AFTER ADVANCING 1 LINE. 
165 
166 
310-COMPUTE-INDIVIDUAL-BILL. 
167 
PERFORM 410-C0MPUTE-TUITI0N. 
168 
PERFORM 430-C0MPUTE-UNI0N-FEE. 
169 
PERFORM 460-COMPUTE-ACTIVITY-FEE. 
170 
PERFORM 490-C0MPUTE-SCH0LARSHIP. 
_ 
^-Continued 
Ima is indented 
171 
' 
~ ~ " " " " " 
172 
173 
174 
j 330-INCREMENT-UN IVER-TOTALS. 
175 
ADD IND-TUITION 
TO UNI-TUITION. 
176 
ADD IND-UNION-FEE 
TO UNI-UNION-FEE. 
177 
ADD IND-ACTIVITY-FEE TO UNI-ACTIVITY-FEE. 
178 
ADD IND-SCHOLARSHIP TO UNI-SCHOLARSHIP. 
179 
ADD IND-BILL 
TO UNI-IND^-MllTf 
180 
_ 
_____ 
181 
" 360 - W RITE-D ETA I L-LINE\ 
1 " " " " 
COMPUTE IND-BILL - IND-TUITION + IND-UNION-FEE + 
IND-ACTIVITY-FEE - IND-SCHOLARSHIP. 
182 
MOVE STU-LAST-NAME TO DET-LAST-NAME. 
183 
MOVE STU-INITIALS TO DET-INITIALS. 
184 
MOVE STU-CREDITS TO DET-CREDITS. 
185 
MOVE IND-TUITION TO DET-TUITION. 
186 
MOVE IND-UNION-FEE TO DET-UNION-FEE. 
187 
MOVE IND-ACTIVITY-FEE TO DET-ACTIVITY-FEE. 
188 
MOVE IND-SCHOLARSHIP TO DET-SCHOLARSHIP. 
189 
MOVE IND-BILL TO DET-IND-BILL. 
190 
MOVE DETAIL-LINE TO PRINT-LINE. 
191 
WRITE PRINT-LINE 
192 
AFTER ADVANCING 1 LINE. 
193 
194 
410-COMPUTE-TUITION. 
195 
COMPUTE IND-TUITION - PRICE-PER-CREDIT * STU-CREDITS. 
196 
197 
430-COMPUTE-UNION-FEE. 
198 
199 
200 
IF STU-UNION-MEMBER = 'Y 
Mi 
ELSE 
MOVE UNION-FEE TO IND-UNION-FEE )
—
"
"
" " 

(continued) 
MOVE ZERO TO IND-UNION-FEE 
END-IF. 
460-COMPUTE-ACTIVITY-FEE. 
EVALUATE TRUE 
WHEN STU-CREDITS <= 1ST-CREDIT-LIMIT 
MOVE 1ST-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 1ST-CREDIT-LIMIT 
AND STU-CREDITS <= 2ND-CREDIT-LIMIT 
MOVE 2ND-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 2ND-CREDIT-LIMIT 
MOVE 3RD-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN OTHER 
DISPLAY 'INVALID CREDITS FOR: ' STU-NAME 
END-EVALUATE. 
490-COMPUTE-SCHOLARSHIP. 
IF STU-GPA > MINIMUM-SCHOLAR-GPA 
MOVE STU-SCHOLARSHIP TO IND-SCHOLARSHIP 
ELSE 
MOVE ZERO TO IND-SCHOLARSHIP 
END-IF. 
A 
A numeric field contains digits, an (optional) implied decimal point, and/or 
an optional sign. A numeric-edited field may contain any editing character. 
All calculations in a COBOL program are done on numeric fields, whose 
computed values are moved to numeric-edited fields prior to printing. 
Any move involving a numeric field and a numeric-edited field maintains 
decimal alignment. 
Only a signed numeric field can hold a negative value; that is, a numeric 
field cannot retain a negative value unless it has been defined with an S in 
its PICTURE clause. 
Coding standards are intended to improve the readability and maintainability 
of COBOL programs. They are imposed by individual installations and go 
beyond the requirements of COBOL. 

Chapter 
7 — 
Editing 
and 
Coding 
Standards 
Key 
Words 
and 
Concepts 
Actual decimal point 
Check protection 
Coding standards 
CR 
DB 
Decimal alignment 
Editing 
Editing characters 
Fixed dollar sign 
Floating dollar sign 
Floating minus sign 
Floating plus sign 
Functional paragraph 
Implied decimal point 
Indentation 
Insertion characters 
Maintainability 
Numeric field 
Numeric-edited field 
Prefixing data names 
Readability 
Receiving field 
Sequencing paragraph names 
Signed numbers 
Source (sending) field 
Zero suppression 
BLANK WHEN ZERO 
1. 
are a set of rules unique to each installation, 
which go beyond the rules of COBOL, to improve the readability of a COBOL 
program. 
2. The editing characters, 
and 
, will appear if and 
only if the sending field is 
and are suppressed otherwise. 
3. The presence of multiple dollar signs in the PICTURE clause of an edited field 
indicates a 
dollar sign, whereas a single dollar sign indicates a 
dollar sign. 
4. The 
, 
is the character used for check protection. 
5. The PICTURE clause of a numeric field may consist of 9's, a 
to 
indicate an implied decimal point, and the letter 
to indicate a 
signed field. 
6. Continuation of a 
literal requires a 
in column 
7. A well-chosen paragraph name consists of a 
, 
, 
and 
to indicate the function of that paragraph. 
8. All data names within the same 01 record should begin with a common 
9. 
of COBOL statements within the B margin does not affect compiler 
interpretation but goes a long way toward improving the readability of a program. 
10. 
, 
may be left before 01 records and paragraph 
names to enhance readability. 

11. If a numeric field is defined without an S in its PICTURE clause, the field will never 
assume a 
value. 
12. All calculations in a COBOL program are performed on (numeric/numeric-edited) 
fields. 
1. Indentation within the B margin affects compiler interpretation. 
2. Blank lines are not permitted within a COBOL program. 
3. The COBOL coding standards for AT&T and IBM are apt to be identical. 
4. COBOL requires that paragraph names be sequenced. 
5. Data names should be as short as possible to cut down on the coding effort. 
6. Indentation in COBOL is a waste of time. 
7. A well-commented COBOL program should contain half as many comment lines as 
Procedure Division statements. 
8. All continued statements require a hyphen in column 7. 
9. COMPUTE-AND-WRITE is a good paragraph name. 
10. Heading, detail, and total lines may be established as separate 01 entries in 
Working-Storage. 
11. Every PICTURE clause requires a corresponding VALUE clause. 
12. Arithmetic may be done on numeric-edited fields. 
13. A positive field should always be defined with a CR in its PICTURE clause, whereas 
a negative field requires DB. 
14. A single numeric-edited field may contain a dollar sign, comma, decimal point, 
asterisk, and the character string CR in its PICTURE clause. 
15. The same numeric-edited field may contain both CR and DB in its PICTURE clause. 
16. Hyphens may be used as insertion characters in a social security number. 
17. Slashes may be used as insertion characters in a date. 
18. The presence of CR or DB in a numeric-edited field implies that the sending field is 
signed. 
19. Zero is a valid insertion character. 
1. Supply PICTURE clauses for the receiving fields needed to accomplish the following: 
a. A floating dollar sign, omission of cents, printing (or suppression) of commas as 
appropriate, and a maximum value of $9,999,999. 
b. A fixed dollar sign, asterisk fill for insignificant leading zeros, printing (or 
suppression) of commas as appropriate, a maximum value of $9,999, and a 
trailing DB if the sending field is negative. 

Chapter 
7 -
Editing 
and 
Coding 
Standards 
A fixed dollar sign, zero suppression or insignificant leading zeros, omission of 
d. A floating dollar sign, printing (or suppression) of commas as appropriate, a 
maximum value of $9,999.00, and a trailing CR if the sending field is negative. 
2. Show the value of the edited result for each of the following entries: 
S O U R C E FIELD
 
1 O - n 
v* 
a. 
9(6) 
123456 
9(6) 
b. 
9(6) 
123456 
9(8) 
c. 
9(6) 
123456 
9(6).99 
d. 
9(4)V99 
123456 
9(6) 
e. 
9(4)V99 
123456 
9(4) 
T. 
9(4)V99 
123456 
$$$$$9.99 
g 
9(4)V99 
123456 
$$$,$$9.99 
h. 
9(6) 
123456 
$$$$,$$9.99 
i. 
9(6) 
123456 
Z(8) 
j-
9(4)¥99 
123456 
$ZZZ,ZZZ.99 
Show the edited 'esuits for each er itry: 
SOURCE SME1.B 
BECEi 
l^llSTIIIIE 
V A L U E 
P I C T U R E 
a. 
S9(4)V99 
45600 
$$$$$.99CR 
b. 
S9(4)V99 
45600 
$$,$$$.99DB 
c. 
S9(4) 
4567 
$$,$$$.00 
d. 
S9(6) 
122577 
99B99B99 
e. 
S9(6) 
123456 
++++,+++ 
f. 
S9(6) 
-123456 
++++,+++ 
g. 
S9(6) 
123456 
, — 
h. 
S9(6) 
-123456 
, — 
9(4)V99 
567890 
$$$$,$$$.99 
i-
9(4)V99 
567890 
$ZZZ,ZZZ.99 
k. 
9(4)V99 
567890 
E B 1 T E O RESULT 
4. What, if anything, is wrong (either syntactically or logically) with the following 
PICTURE clauses? 
a. $,$$$,$$9.99 
b. 999999999 
c. $$$$,$$$,$$$ 
d. $ZZZ.ZZ 
e. $999V99 
f. $999,999,999.99 
g. $$$$$,$$9.99 

5. Do you agree with all of the coding standards suggested by the authors? Can you 
suggest any others? Do you think the imposition of coding standards within an 
installation impinges on the creativity of individual programmers? Are coding 
standards worth the extra time and trouble they require? 
6. Consider the following code: 
01 AMOUNT-REMAINING 
PIC 9(3} 
VALUE 100. 
01 WS-INPUT-AREA. 
05 QUANTITY-SHIPPED 
PIC 99. 
05 REST-0F-A-REC0RD 
PIC X(50). 
READ TRANSACTION-FILE INTO WS-INPUT-AREA 
AT END MOVE 'YES' TO E0F-SWITCH 
END-READ. 
PERFORM PROCESS-TRANSACTIONS 
UNTIL EOF-SWITCH = 'YES'. 
PROCESS-TRANSACTIONS. 
SUBTRACT QUANTITY-SHIPPED FROM AMOUNT-REMAINING. 
READ TRANSACTION-FILE INTO WS-INPUT-AREA 
AT END MOVE 'YES' TO EOF-SWITCH 
END-READ. 
a. Why will AMOUNT-REMAINING never be less than zero? 
b. What will be the final value of AMOUNT-REMAINING, given successive values 
of 30, 50, 25, and 15 for QUANTITY-SHIPPED? 


Overview 
System Concepts: Data Validation 
The IF Statement 
Relational Condition 
Class Test 
Sign Test 
Condition-Name Test (88-Level Entries) 
Compound Test 
Hierarchy of Operations 
Implied Conditions 
Nested IFs 
NEXT SENTENCE 
ACCEPT Statement 
Calculations Involving Dates 
Stand-Alone Edit Program 
Programming Specifications 
Error Messages 
Pseudocode 
Hierarchy Chart 
The Completed Program 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
8 
— 
Data 
Validation 
U 8 J t 
u 
I i 
y c: 
D 
After reading this chapter you will be able to: 
Describe the importance of data validation and its implementation in a 
stand-alone edit program. 
Define the following validity tests: numeric test, alphabetic test, consistency 
check, sequence check, completeness check, date check, and subscript 
check. 
Describe the various types of conditions in an IF statement. 
Define a nested IF; indicate guidelines for proper indentation in coding 
such statements. 
Describe the advantages of the END-IF scope terminator; show how the 
scope terminator eliminates the need for the NEXT SENTENCE clause. 
Obtain the date (calendar and Julian) and time of execution; implement 
date checking in a program to ensure that the day and month are consistent. 
This chapter introduces the concept of data validation, the process of ensuring 
that data entered into a system is as error-free as possible. It begins by 
describing various types of error checking, then focuses on the IF statement, the 
means by which data validation is implemented in COBOL. 
We cover the 
different types of conditions that exist within an IF statement (relation, class, 
sign, and condition name), the concept of a nested IF, and the importance of the 
END-IF scope terminator. 
The second half of the chapter develops a stand-alone edit program to 
illustrate the implementation of data validation. The program is designed to 
process a file of incoming transactions, reject invalid transactions with appropriate 
error messages, and write valid transactions to an output file. The latter is then 
input to a reporting (or other) program. 
A well-written program is not limited to merely computing answers, but must also 
validate the data o n which those answers are based. Failure to do so results in 
programs that produce meaningless or inaccurate information, a situation described 
by the cliche G I G O (Garbage In, Garbage Out). It is the job of the programmer or 
analyst to ensure that a system remains as error-free as possible and that the 
"garbage" does not enter the system in the first place. 
Incoming data m a y be validated within the program in which it is used or in a 
separate stand-alone edit program. The essential point is that incoming data must 

be checked; when and how this is done is of secondary importance. The following 
are typical types of data validation: 
Numeric 
test. Ensures that a numeric field contains numeric data. Commas, dollar 
signs, decimal points, blanks, or other alphabetic characters are not numeric, and 
will cause problems in execution. 
Alphabetic 
test. Analogous to a numeric test, except that alphabetic fields should 
contain only alphabetic data. Any errors detected here are typically less serious 
than for numeric fields. 
Reasonableness 
(limit or range) 
check. Ensures that a number is within expected 
limits; that is, that a value does not exceed a designated upper or lower extreme. 
Consistency 
check. Verifies that the values in two or more fields are consistent, for 
example, salary and job title. Other examples of consistency checks are an individual's 
credit rating and the amount of credit a bank is willing to extend, or (as used by the 
Internal Revenue Service) an individual's reported income and the zip code. 
Existing code check. One of the most important tests, the omission of which produces 
countless errors. Consider: 
IF SEX = 'M' 
ADD 1 TO NUMBER-OF-MEN 
ELSE 
ADD 1 TO NUMBER-OF-WOMEN 
END-IF. 
It is decidedly poor practice to assume that an incoming record is female if it is 
not male. Both codes should be explicitly checked, and if neither occurs, a suitable 
error should be printed. 
Sequence 
check. 
Ensures that incoming records are in proper order. It can also be 
used when one record is continued over several lines to ensure that the lines within 
a record are in proper sequence. 
Completeness 
check. Verifies that data in all required fields are present; this check is 
normally used when new records are added to a file. 
Date check. Ensures that an incoming date is acceptable—for example, that the day 
is from 1 to 31, the month from 1 to 12, and the year within a designated period, 
often just the current year. A further check is that the month and day are consistent 
with one another—for example, a date of April 31 is invalid. 
Subscript 
check. Validates that a subscript or index is within a table's original 
definition. (Table processing is discussed fully in Chapter 11.) 
Diligent application of data validation (sometimes referred to as defensive 
programming) minimizes the need for subsequent debugging. It assumes that errors 
will occur and takes steps to make them apparent to the programmer and/or user 
before a program terminates, is it worth the extra time? Emphatically yes, especially 
if you have ever been called at two in the morning to hear that your program 
"bombed" because of invalid data. 
The importance of the IF statement is obvious, yet the large number of options 
make it one of the more difficult statements to master. Essential to any IF statement, 
however, is the condition, the portion of the statement that is evaluated as either 

C
h
a
p
t
e
r 
8 
Data 
Validation 
true or false. Four types of conditions are possible: relational, class, sign, a n d 
condition-name, each of which is discussed m a separate section. 
The relational 
condition 
is the most c o m m o n type of condition and has appeared 
throughout the book. As you already k n o w there is considerable variation in the w a y 
the relational operator m a y be expressed. In all instances, however, the condition 
compares the quantities o n either side of the relational operator to determine 
whether (or not) the condition is true. 
The data type of the quantities being compared must be the same; for example, 
a numeric data item must be compared to a numeric literal a n d a nonnumeric data 
item to a nonnumeric literal. Failure to do so produces a syntax error during 
compilation. The relational condition is illustrated in Figure 8.1. 
The Relational Condition 
identifier-l 
expression-1 
IS NOT GREATER THAN 
IS NOT > 
IS ;NOT LESS THAN 
IS NOT 
< 
IS [NOT EQUAL TO 
IS NOTj = 
IS NOT GREATER THAN OR EQUAL TO 
IS NOT >= 
IS NOT LESS THAN OR EQUAL TO 
IS NOT 
<= 
identifier-2 
1 i teral-2 
expression-2 
05 NUMERIC-FIELD 
PIC 9(5). 
05 ALPHANUMERIC-FIELD 
PIC X(5). 
IF NUMERIC-FIELD = 10 . . . 
(valid entry) 
IF NUMERIC-FIELD = '10' . . . 
(invalid entry) 
IF ALPHANUMERIC-FIELD = IO . . . 
(invalid entry) 
IF ALPHANUMERIC-FIELD = '10' . . . (valid entry) 

The clans test ensures that a field contains numeric or alphabetic data in accordance 
with its P I C T U R E clause. A valid numeric field will contain only the digits 0 to 9 (a 
sign is optional); blanks, decimal points, c o m m a s , and other editing characters are 
not valid as numeric characters. A valid alphabetic field will contain the letters A to 
Z (upper or lower case) and/or blanks. A n alphanumeric field m a y contain any 
character; letters, numbers, and/or special characters. 
The class test cannot be used indiscriminately; that is, a numeric test cannot 
be used for data n a m e s defined as alphabetic, nor can an alphabetic test be used for 
numeric data names. Either test, however, m a y be performed o n alphanumeric 
items. The class test is illustrated in Figure 8.2 
The Class Test 
IF identifier IS [NOT] 
NUMERIC 
A L P H A B E T I C 
A L P H A B E T I C - U P P E R 
ALPHABETIC-LOWER 
(a) Syntax 
05 NUMERIC-FIELD 
PIC 9(5). 
05 ALPHABETIC-FIELD 
PIC A(5). 
1 
IF NUMERIC-FIELD IS NUMERIC 
f 
j 
PERFORM DO-ARITHMETIC-CALCULATIONS 
j 
j 
END-IF. 
| 
I 
I 
1 
IF NUMERIC-FIELD IS NOT NUMERIC 
\ 
| 
DISPLAY
 
1 ERROR - NUMERIC FIELD CONTAINS INVALID DATA' 
| 
I 
END-IF. 
| 
IF ALPHABETIC-FIELD IS ALPHABETIC 
j 
DISPLAY 'ALPHABETIC FIELD CONTAINS UPPER AND/OR LOWER CASE LETTERS' j 
END-IF. 
1 
IF ALPHABETIC-FIELD IS NOT ALPHABETIC 
J 
DISPLAY 'ALPHABETIC FIELD CONTAINS NON-ALPHABETIC DATA' 
| 
END-IF. 
I 

C
h
a
p
t
e
r 
8 
Data 
Validation 
F 
•e 8,3 The Sign Test 
IF {: arithmetic expression 
identi fier 
POSITIVE 
is [NOT] JNEGATIVE -
ZERO 
(a) Syntax 
IF NET-PAY IS NOT POSITIVE 
PERFORM TOO-MUCH-TAXES 
END-IF. 
IF CHECK-BALANCE IS NEGATIVE 
PERFORM OVERDRAWN 
The sign test determines whether a numeric field is positive, negative, or zero. The 
test is of limited value and could in fact be replaced with the equivalent relational 
condition. Nevertheless, the sign test is illustrated in Figure 8.3. 
Condition-Name Test 
. 
... 
A condition 
name (88-level entry) is a special w a y of writing a relational condition 
that makes it (the condition) easier to read. Condition n a m e s are defined in the 
Data Division, then referenced in the Procedure Division as s h o w n in Figure 8.4. 
Condition n a m e s are used for elementary items only. 
The definition of a condition n a m e in the Data Division simplifies subsequent 
coding in the Procedure Division; for example, IF F R E S H M A N is equivalent to 
IF Y E A R - C O D E = 1. 88-level entries provide improved documentation in that 
IF F R E S H M A N is inherently clearer than IF Y E A R - C O D E = I. 
The use of a n 88-level entry also allows multiple codes to be grouped under a 
single data n a m e ; for example, V A L I D - C O D E S is defined as any value from 1 to 8. 
This in turn makes it possible to test for an invalid code with a simple IF statement 
as s h o w n in Figure 8.4b. Note, too, that condition n a m e s permit a given value to 
appear under m o r e than one classification; for example, records containing a 3 
belong to J U N I O R , U P P E R - C L A S S M A N , a n d V A L I D - C O D E S . 
C o m p o u n d 
A n y two simple tests m a y be combined to form a compound test through the logical 
operators A N D a n d O R . A N D implies that both conditions must be satisfied for the 
IF to be considered true, whereas O R requires that only one of the conditions be 
satisfied. A flowchart is s h o w n in Figure 8.5a depicting the A N D condition. It requires 
that both A be greater than B and C be greater than I) in order to proceed to T R U E . If 
either of these tests fails, the c o m p o u n d condition is judged false. T h e general 
format is: 
END-IF. 
(b) Examples 

Condition Names (88-level entries) 
88 data-name jVALUE IS 
[VALUES ARE 
literal-1 (THROUGH! 
< 
> literal-2 
[THRU J 
fa) Syntax 
05 YEAR-CODE 
PIC 9. 
88 FRESHMAN 
VALUE 1. 
88 SOPHOMORE 
VALUE 2. 
88 JUNIOR 
VALUE 3. 
88 SENIOR 
VALUE 4. 
88 GRAD-STUDENT 
VALUES ARE 5 THRU 8. 
88 UNDER-CLASSMAN 
VALUES ARE 1, 2. 
88 UPPER-CLASSMAN 
VALUES ARE 3, 4. 
88 VALID-CODES 
VALUES ARE 1 THRU 8. 
IF FRESHMAN 
[ 
PERFORM WELCOME-NEW-STUDENTS 
I 
END-IF. 
I 
IF VALID-CODES 
| 
PERFORM PROCESS-STUDENT-RECORD 
j 
ELSE 
| 
DISPLAY 'INCOMING YEAR CODE IS IN ERROR' 
1 
END-IF. 
j 
t 
I 
(b) Examples 
\ 
Figure 8.5b contains a flowchart 
for a c o m p o u n d O R in which only one of two 
conditions needs to be m e t for the condition to be considered true. Thus, if either A 
is greater than B or C is greater than D, processing is directed to T R U E . 
IF statements containing c o m p o u n d conditions can b e c o m e difficult to interpret; 
for example, in the statement, 
IF X > Y OR X - Z AND X < W ... 
which takes precedence, A N D or O R ? T o provide an unequivocal evaluation of 
c o m p o u n d conditions, the following hierarchy for evaluation is established: 
1. Arithmetic expressions 
2. Relational operators 
3. N O T condition 
4. A N D (from left to right if m o r e than one) 
5. O R (from left to right if m o r e than one) 

C
h
a
p
t
e
r 
8 
Data 
Validation 
Thus, for the preceding statement to be true, either 
X > Y 
or 
X = Z and X < W 
Parentheses can (and should) be used to clarify the programmer's intent and 
the preceding statement is m a d e clearer if it is rewritten as 
IF X > Y OR (X = Z AND X < W) . . . 
Parentheses can also alter the outcome in that the expression in parentheses is 
evaluated first. T h e following statement is logically different from the original 
statement: 
IF (X > Y OR X = Z) AND X < W . . . 
In this example the condition in parentheses (X> Y O R X = Z) is evaluated first, after 
which X is compared to W. Both conditions (the one in parentheses and X < W) must 
be true for the c o m p o u n d condition to be considered true. 

The simple conditions within a c o m p o u n d condition often have the same subject as 
in the statement: 
IF SALARY > 30000 AND SALARY < 40000 
A more concise w a y of expressing this logic is with an implied condition, which 
requires only the first occurrence of the subject; that is, 
IF SALARY > 30000 AND < 40000 
is equivalent to the earlier entry. If both the subject and relational operator are the 
same, then only the first occurrence of both needs to be written; that is, 
IF DEPARTMENT = 10 OR 20 
is equivalent to 
IF DEPARTMENT = 10 OR DEPARTMENT = 20 
Implied conditions are often confusing and the following are provided as additional 
examples: 
IF X = Y OR Z 
is equivalent to IF X = Y OR X = Z 
IF A = B OR C O R D 
is equivalent to IF A = B O R A = C OR A = D 
IF A = B AND C 
is equivalent to IF A = B AND A = C 
The general format of the IF statement is: 
IF condition-1 THEN statement-1.., 
NEXT SENTENCE 
statement-2... [END-IF] 
NEXT SENTENCE 
A nested 
IF results w h e n either statement-1 or statement-2 is itself another IF 
statement, that is, w h e n there are two or m o r e IFs in one sentence. For example, 
consider 
IF A > B 
IF C > D 
MOVE S TO W 
MOVE X TO Y 
ELSE 
ADD 1 TO Z 
END-IF 
END-IF. 
The ELSE clause is associated with the closest previous IF that is not already paired 
with another ELSE. Hence, in this example, Z is incremented by 1 if A is greater than 
B, but C is not greater than D. If, however, A is not greater than B, control passes to 
the statement immediately following the period with no further action being taken. 
(The END-IF scope terminator is optional in both instances, but is included as per 
our coding standard of Chapter 7 of always specifying the scope terminator.) 
Figure 8.6 shows a flowchart and corresponding C O B O L code to determine 
the largest of three quantities A, B, and C. (They are assumed to be unequal numbers.) 
Observe h o w the true a n d false branches of each decision block meet in a single exit 
point and h o w this corresponds to the C O B O L code. Notice also h o w the indentation 

IF A > B 
IF A > C 
MOVE A TO BIG 
ELSE 
MOVE C TO BIG 
END-IF 
ELSE 
IF C > B 
MOVE C TO BIG 
ELSE 
MOVE B TO BIG 
END-IF 
END-IF 
(b> COBOL Statements 
in the COBOL statement facilitates interpretation of the statement. (The compiler 
pays no attention to the indentation, which is done strictly for p r o g r a m m e r 
convenience.) 
W e advocate careful attention to indentation a n d r e c o m m e n d the following 
guidelines: 
1. Each nested IF should be indented four columns from the previous IF. 
2. ELSE should appear o n a line by itself directly under its associated IF. 
3. Detail lines should be indented four columns under both IF and ELSE. 

The 
IF 
Statement 
4. The END-IF scope terminator should always be used and appear o n a line by 
itself directly under its associated IF. 
These guidelines were used in Figure 8.6. 
The N E X T S E N T E N C E clause directs control to the statement following the period 
in an IF statement. It was an essential clause in C O B O L - 7 4 to implement certain 
types of nested IF statements, but is no longer needed due to the the END-IF scope 
terminator in COBOL-85. The use of N E X T S E N T E N C E is compared to the scope 
terminator in Figure 8.7. 
Figure 3,7 Nested IF Statements/11 
FALSE 
TRUE 
ADD 1 
TOY 
ADD 1 
TOX 
IF A > B 
IF A > B 
IF C > D 
ADD 1 TO X 
ELSE 
NEXT SENTENCE 
IF C > D 
ADD 1 TO X 
END-IF 
ELSE 
ELSE 
ADD 1 TO Y 
ADD 1 TO Y. 
END-IF. 
(b) NEXT SENTENCE 
(COBOL-74) 
(c) Scope Terminators 
(COBOL-85) 

C
h
a
p
t
e
r 
8 
Data 
Validation 
The intended logic is to add 1 to X if A is greater than B a n d C is greater than D; 
if, however, A is greater than B, but C is not greater than D, no further action is to be 
taken. T h e N E X T S E N T E N C E clause in Figure 8.7b terminates the IF statement if the 
second condition (C > D) is not met. The identical effect is achieved by the END-IF 
scope terminator in Figure 8.7c. 
The A C C E P T statement is used to obtain the day of the week, date, and/or time of 
program execution. Consider: 
ACCEPT identifier-1 FROM -
DAY-OF-WEEK 
DATE 
DAY 
TIME 
Identifier-1 is a programmer-defined work area that holds the information 
being accepted such as the DAY-OF-WEEK, D A T E , DAY, or T I M E . The DAY-OF-
W E E K is returned as a single digit, from one to seven inclusive, corresponding to 
Monday through Sunday. (See Figure 9,8 in the next chapter.) DATE and DAY both 
reflect the current date, but in different formats. Specification of D A T E places a six-
digit numeric field into identifier-1 in the form yymmdd; the first two digits contain 
year; the next two, month; and the last two, the day of the m o n t h ; for example, 
930316, denotes March 16, 1993. 
Specification of D A Y , rather than D A T E , returns a five-digit numeric field to 
the work area. The first two digits represent year a n d the last three the day of the 
year, n u m b e r e d from 1 to 365 (366 in a leap year). M a r c h 16, 1993, would be 
represented as 93075, but M a r c h 16,1992, as 92076, since 1992 is a leap year. (A date 
written in this format is k n o w n as a Julian 
date.) 
T I M E returns an eight-digit numeric field, hhmmsshh, in a 24-hour system. It 
contains the n u m b e r of elapsed hours, minutes, seconds, a n d hundredths of seconds 
after midnight, in that order, from left to right. 10:15 A.M. w o u l d return as 10150000, 
10:15 P.M. as 22150000. 
Calculations Involving Dates 
O n c e the date of execution is obtained, it can be used for various types of date 
validation such as checking that a n employee's hire date is within the current year. 
It can also be used in various calculations, for example, to compute an employee's 
age, or to determine which accounts haven't been paid in 30 days. Figure 8.8 
illustrates h o w a n employee's age m a y be calculated from the date of execution a n d 
the employee's birth date. 
Y o u should verify that the COMPUTE statement in Figure 8.8 works as intended, 
and further that it works for all combinations of data. This is best accomplished by 
"playing computer" a n d plugging in numbers. Accordingly, consider two examples: 
Example 8.1 
Date of birth: 3/73 
Date of execution: 6/93 
Expected age: 20 1/4 
Calculation: 93 - 73 + (6 - 3)/12 = 20 + 3/12 = 20.25 

The 
Stand-Alone 
Edit 
Program 
The ACCEPT Statement 
WORKING-STORAGE SECTION. 
01 EMPLOYEE-RECORD. 
05 EMP-DATE-OF-BIRTH. 
10 EMP-BIRTH-MONTH 
10 EMP-BIRTH-YEAR 
PIC 99. 
PIC 99. 
01 EMPLOYEE-AGE 
PIC 99V99. 
01 DATE-WORK-AREA. 
05 TODAYS-YEAR 
05 TODAYS-MONTH 
05 TODAYS-DAY 
PIC 99. 
PIC 99. 
PIC 99. 
PROCEDURE DIVISION. 
ACCEPT DATE-WORK-AREA FROM DATE. 
COMPUTE EMPLOYEE-AGE = TODAYS-YEAR - EMP-BIRTH-YEAR 
+ (TODAYS-MONTH - EMP-BIRTH-MONTH) / 12. 
Example 8.2 
Date of birth: 9/73 
Date of execution: 6/93 
Expected age: 19 3/4 
Calculation: 93 - 73 + (6 - 9)/12 = 20 + -3/12 = 19.75 
The calculations are correct, a n d they work for both combinations of data; it 
doesn't matter whether the m o n t h of execution is before or after the birth month. 
(For simplicity only m o n t h and year were used in the calculation of age.) 
The validation of incoming data is often done in a stand-alone edit program as 
opposed to the reporting program that processes the data. The sequence is s h o w n 
in Figure 8.9. A transaction file is input to the edit program, which checks each 
incoming record for validity. Invalid transactions are rejected with a n appropriate 
error message(s), whereas valid transactions are written to an output file. The valid 
transaction file (i.e., the output file from the edit program) is then input to a 
reporting program. 

Chapter 
8 — 
Data 
Validation 
T h e flowchart in Figure 8.9 serves as an effective blueprint for the combina­
tion of programs that are developed in this chapter and the next. The programs 
are related to one another in that the output of the edit program in this chapter 
will be input to the reporting program in Chapter 9. Specifications for the edit 
program are given below, whereas the requirements of the reporting program are 
presented in Chapter 9. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Car Rental Validation 
N a r r a t i v e : 
The specifications describe a stand-alone edit program for car rental transactions, each 
of which is subject to multiple validity checks. Invalid transactions are to be rejected with 
appropriate error message(s), whereas valid transactions are to be written in their entirety 
to an output file; the latter will be input to a reporting program developed in the next 
chapter. 
Input File(s): 
RENTAL-RECORD-FILE 
Input R e c o r d L a y o u t : 01 RENTAL-RECORD-IN. 
05 REN-CONTRACT-NO 
PIC 9(6). 
REN-NAME. 
10 REN-LAST-NAME 
PIC X(15). 
10 REN-FIRST-NAME 
PIC X(10). 
10 REN-INITIAL 
PIC X. 
REN-RETURNED-DATE. 
10 REN-RETURNED-YEAR 
PIC 9(2). 
10 REN-RETURNED-MONTH 
PIC 9(2). 
10 REN-RETURNED-DAY 
PIC 9(2). 
REN-CAR-TYPE 
PIC X. 
REN-DAYS-RENTED 
PIC 99. 
REN-MILEAGE. 
10 REN-MILES-IN 
PIC 9(6). 
10 REN-MILES-OUT 
PIC 9(6). 
10 REN-MILEAGE-RATE 
PIC 99. 
05 REN-INSURANCE 
PIC X. 
05 
05 
05 
05 
05 
Figure 8.9 
The Stand-Alone Edit Program 
I 
i 

The 
Stand-Alone 
Edit 
Program 
T e s t D a t a ; 
See Figure 8.10a (Four errors are identified.) 
R e p o r t L a y o u t : 
See Figure 8.10b 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of car rental records. 
2. Validate each input record for all of the following: 
a. A numeric contract number; print the message Nonnumeric 
Contract 
Number for 
any nonnumeric contract. 
b. The presence of both a first and last name; print the message Missing last name or 
Missing 
first name for a record missing either field. A middle initial is not required, 
but if present, the initial must be alphabetic; print the message Nonalphabetic 
initial 
as appropriate. 
c. A valid car type where the code is one of five values; E, C, M, F, or L. Print the 
message Car type must be: E, C, M, F, or L for any record with an invalid car type. 
d. Valid dates: 
(1) A valid month; that is, a month must be from 1 to 12; print the message Month 
must be between 
1 and 12 for any invalid month. 
(2) A valid day; that is, the day cannot exceed the maximum days in the 
corresponding month; print the message Invalid Dayfor any date that is inconsistent 
with the month—for example, April 31. 
(3) A valid date; that is, a date that is less than or equal to the system date; print 
the message Date has not yet occurred for any date in the future. 
e. A valid number of days rented where the number of days is numeric, is greater than 
zero, and iess than or equal to 35. Print appropriate error messages for any 
condition that is not met; e.g., Days rented must be numeric, 
Days rented must be 
> zero, or Refer to Long-Term 
Leasing. 
Transaction Files and Error Reports 
123459BAKER 
987651BR0WN 
999999J0NES 
PETER 
TOM 
PAULA 
TERRY 
DAN 
PAUL 
ROBERT 
G93J04311F0500670000664025X 
G930112M1000353000352000N 
J931309E35|)645000Tj466q05Y 
886222V0GEL 
008632TOWER 
233432BEINH0RN 
556564HUMMER 
677844MCD0NALD 
X93477BUTLER 
354679KERBEL 
264805CLARK 
846440 
987655BR0WNING 
999777ELSIN0R 
655443FITZPATRICK 
987654SMITH 
PINNOCK 
JOHN 
NORMAN 
JANE 
SAM 
CATHY 
MARGO 
JAMES 
JANICE 
DARREN 
J93102400700240000252500Y 
R921126F0500168000159005N 
T930532L0701000000987000C 
G921213M0300510000500502Y 
1931012F1000342450l31OO0N 
H930631C0000423000419075N 
X930331E100O34000032430OY 
S921101F0700561500551200N 
92123 If §1500182 300169802 N 
B921122M0200123400113402Y 
R920815C0800234500123403Y 
930123C0500423500402300N 
D930518F1200634500612302Y 
R930429L0900700200689300N 

Chapter 
8 
Data 
Validation 
(continued) 
CONTRACT # LAST NAME 
123459 
123459 
987651 
999999 
999999 
999999 
987655 
987655 
987655 
655443 
655443 
X93477 
X93477 
X93477 
X93477 
BAKER 
BAKER 
BROWN 
JONES 
JONES 
JONES 
BROWNING 
BROWNING 
BROWNING 
FITZPATRICK 
FITZPATRICK 
PINNOCK 
PINNOCK 
PINNOCK 
PINNOCK 
PINNOCK 
BUTLER 
BUTLER 
BUTLER 
BUTLER 
ERROR REPORT AS OF 07/03/93 
ERROR MESSAGE & FIELD 
INVALID DAY 
INSURANCE CODE MUST BE Y OR N 
MILES DRIVEN UNREASONABLY LOW 
MONTH MUST BE BETWEEN 1 AND 12 
MILEAGE IN LESS THAN MILEAGE OUT 
NON-NUMERIC MILEAGE RATE 
CAR TYPE MUST BE: E, C, M, F, 
DATE HAS NOT YET OCCURRED 
NON-NUMERIC MILES IN 
INVALID DAY 
INSURANCE CODE MUST BE Y OR N 
NON-NUMERIC CONTRACT NUMBER 
MISSING FIRST NAME 
NON ALPHABETIC INITIAL 
DATE HAS NOT YET OCCURRED 
NON-NUMERIC MILES OUT 
NON-NUMERIC CONTRACT NUMBER 
INVALID DAY 
DAYS RENTED MUST BE > ZERO 
MILEAGE RATE OUT OF RANGE 
OR L 
CONTENTS 
DAYS: 10 MILES: 000010 
13 
IN: 004500 OUT: 004600] 
0 5 " 
0 
10/24/93 
002400 
05/32 
C 
10/12/93 
003310 
X93477 
06/31 
00 
75 
846440 
846440 
846440 
846440 
846440 
NON-NUMERIC CONTRACT NUMBER 
MISSING LAST NAME 
CAR TYPE MUST BE: E, C, M, F, OR L 
DAYS RENTED MUST BE NUMERIC 
MILES DRIVEN UNREASONABLY LOW 
846440 
[X! 
15 
DAYS: 15 MILES: 000125 
999777ELSINOR 
TERRY 
R921126F0500168000159005N 
987654SMITH 
PAUL 
G921213M0300510000500502Y 
354679KERBEL 
NORMAN 
X930331E1000340000324300Y 
264805CLARK 
JANE 
S921101F0700561500551200N 
233432BEINH0RN 
CATHY 
B921122M0200123400113402Y 
556564HUMMER 
MARGO 
R920815C0800234500123403Y 
677844MCD0NALD 
JAMES 
930123C0500423500402300N 
886222V0GEL 
JANICE 
D930518F1200634500612302Y 
008632T0WER 
DARREN 
R930429L0900700200689300N 
I 

The 
Stand-Alone 
Edit 
Program 
f. Valid values for the mileage in and out: 
(1) The values for both miles in and miles oul must be numeric; print the message 
Nonnumeric 
miles in or nonnumeric 
miles out, respectively. 
(2) The mileage reported when the car is turned in cannot be less than the 
mileage when the car was taken out; print the message Mileage 
in less 
than 
mileage out as appropriate. 
(3) The number of miles driven must pass a reasonableness test of 10 miles or 
more per day; Display the message, Miles driven unreasonably 
low as appropriate. 
g. The mileage rate must be numeric and less than or equal to 50 cents per day; print 
the message Mileage rate out of range for an invalid rate. 
h. The value of the insurance field must be either Y or N; print the message 
Insurance 
code must be Y or Nfor an invalid value. 
3. Any record that fails any validity test is to be rejected and omitted from the valid record 
file. It is quite possible that a given record may contain more than one error, and all 
errors are to be printed except where noted. 
4. Valid records are to be written to a file. 
Eff©f 
life'Ssajfi&s 
The utility of a data validation program is determined by the number of potential 
errors that it can detect as well as the clarity of the resulting error messages. A truly 
useful program must check for a variety of errors and explain to the user the nature 
of any errors that are detected. These concepts are illustrated in Figure 8.10. The 
incoming transaction file is s h o w n in Figure 8.10a, the associated error messages (in 
conjunction with the programming specifications) in Figure 8.10b, a n d the valid 
transaction file in Figure 8.10c. 
The n u m b e r e d callouts in Figure 8.10 highlight s o m e of the erroneous 
transactions a n d the corresponding error message; for example, the date of April 
31 is highlighted in the first transaction of Figure 8.10a as is the corresponding 
error message in Figure 8.10b. Three other erroneous transactions are similarly 
highlighted. 
The individual error messages are fully descriptive and list both the contract 
n u m b e r and last n a m e of the associated transaction. In addition, the contents of the 
erroneous field(s) are s h o w n to the right of the error message, making it even easier 
to correct the invalid transaction. Note, too, that the program can also detect multiple 
errors for the s a m e transaction; for example, three errors are identified in the single 
transaction for Jones. 
u d t a s o d e 
....... 
The pseudocode in Figure 8.11 begins with statements to obtain the date of execution, 
write the heading for the error report, a n d read the first record. The m a i n loop of the 
program is executed next and does the following: 
1. T h e incoming transaction is assumed to be valid by moving 'YES' to a valid-
record-switch. 
2. The incoming transaction is subject to all of the individual validity checks, any 
one of which can set the valid-record-switch to 'NO'. Note, too, that since 
each transaction record is subject to every validity check, multiple errors can 
be detected for a single transaction. 
3. T h e valid-record-switch is checked to see if the record is still valid, and if so, 
the transaction is 'written to the valid record file. If, o n the other hand, the 
record is n o longer valid, a blank line is written to the error report, which 
double spaces between the error messages for one transaction a n d the next. 

C
h
a
p
t
e
r 
8 
Data 
Validation 
Open f i l e s 
Get today's date 
Write error headings 
Read rental 
f i l e 
DO WHILE data remains 
Move ' Y E S ' to v a l i d record switch 
Validate contract number 
Validate l a s t name, f i r s t name, and i n i t i a l 
Validate car type 
Validate month, day, and non-future date 
Validate days rented 
Validate mileage i n , mileage out, and computed miles 
Validate mileage rate 
Validate insurance code 
— - 
I F v a l i d record switch = ' Y E S ' 
ENDIF 
Read next record 
—• ENDDO 
Close f i l e s 
Stop run 
4. The next record is read and the loop continues until the transaction file is 
exhausted. 
The p s e u d o c o d e is concise in that the specific nature of e a c h error check is not 
shown; nevertheless it (the p s e u d o c o d e ) is an effective aid in writing the program. 
The hierarchy chart for the data validation program is s h o w n in Figure 8.12. The 
m o d u l e CREATE-VALID-FILE sits at the top of the hierarchy chart a n d invokes four 
subordinates, o n e of which is PROCESS-RENTAL-RECORDS, w h i c h i m p l e m e n t s 
the m a i n loop of the program. 
PROCESS-RENTAL-RECORDS in turn has three subordinates, VALIDATE-
RENTAL-RECORD to perform the individual error checks, WRITE-VA1.1D-RECORD 
to write valid transactions to the output file, and READ-RENTAL-RECORD to read 
the next transaction. Each of the required validity checks is i m p l e m e n t e d in its o w n 
m o d u l e , and all of these m o d u l e s call a c o m m o n routine to write an error message. 
Write v a l i d record 
ELSE 
Write blank 1ine in error report 
l_. 
The c o m p l e t e d program is s h o w n in Figure 8.13. It is considerably longer than the 
tuition billing program of the previous chapters, but n o n e t h e l e s s straightforward 

The 
Stand-Alone 
Edit 
Program 
Hierarchy Chart for Validation Program 
CREATE 
VALID FILE 
GET 
TODAYS 
DATE 
WRITE 
ERROR 
HEADINGS 
VALIDATE 
RENTAL 
RECORD 
VALIDATE 
CONTRACT 
NUMBER 
VALIDATE 
NAME 
READ 
RENTAL 
RECORD 
WRITE 
VALID 
RECORD 
PROCESS 
RENTAL 
RECORDS 
READ 
RENTAL 
RECORD 
VALIDATE 
CAR 
TYPE 
VALIDATE 
DATE 
RETURNED 
WRITE 
ERROR LINE 
WRITE 
ERROR LINE 
WRITE 
ERROR LINE 
VALIDATE 
DAYS 
RENTED 
WRITE 
ERROR LINE 
VALIDATE 
MILES 
DRIVEN 
VALIDATE 
MILEAGE 
RATE 
VALIDATE 
INSURANCE 
WRITE 
ERROR LINE 
WRITE 
ERROR LINE 
WRITE 
ERROR LINE 
V 
WRITE 
ERROR LINE 
Data Validation Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
VALCARS8. 
3 
AUTHOR. 
CVV. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT RENTAL-FILE 
ASSIGN TO 'A:\CHAPTR08\VALCARS.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT VALID-RENTAL-FILE 
ASSIGN TO 'A:\CHAPTR08\VALRENT.DAT 
11 
ORGANIZATION IS LINE SEQUENTIAL. 
12 
SELECT ERROR-FILE 
13 
ASSIGN TO PRINTER. 
14 
15 
DATA DIVISION. 
16 
FILE SECTION. 
17 
FD RENTAL-FILE 
18 
RECORD CONTAINS 56 CHARACTERS. 
19 
01 RENTAL-RECORD. 
20 
05 REN-CONTRACT-NO 
PIC 9(6). 
21 
05 REN-NAME. 
22 
10 REN-LAST-NAME 
PIC X(15). 
23 
10 REN-FIRST-NAME 
PIC X(10). 

.13 
(continued) 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
10 REN-INITIAL 
05 REN-RETURNED-DATE. 
10 REN-RETURNED-YEAR 
10 REN-RETURNED-MONTH 
88 VALID-MONTHS 
88 FEBRUARY 
88 30-DAY-MONTH 
88 31-DAY-MONTH 
10 REN-RETURNED-DAY 
05 REN-CAR-TYPE 
88 VALID-CAR-TYPES 
05 REN-DAYS-RENTED 
PIC X. 
PIC 9(2). 
PIC 9(2). 
VALUES 1 THRU 12. 
VALUE 2. 
VALUES 4 6 9 11. 
VALUES 1 3 5 7 8 10 12. 
PIC 9(2). 
PIC X. 
VALUES 'E' 'C 'M' 'F'
 1L'. 
PIC 99. 
88 ZERO-DAYS-RENTED 
88 VALID-DAYS-RENTED 
VALUE 0. 
VALUES 1 THRU 35. 
05 REN-MILEAGE. 
10 REN-MILES-IN 
10 REN-MILES-OUT 
10 REN-MILEAGE-RATE 
PIC 9(6). 
PIC 9(6). 
PIC 99. 
88 VALID-MILEAGE-RATES 
VALUES 00 THRU 50. 
05 REN-INSURANCE 
PIC X. 
88 VALID-INSURANCE 
VALUES 'Y' 'N' 
FD VALID-RENTAL-FILE 
RECORD CONTAINS 56 CHARACTERS. 
01 VALID-RENTAL-RECORD 
PIC X(56). 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
FD ERROR-FILE 
RECORD CONTAINS 132 CHARACTERS. 
01 ERROR-RECORD 
WORKING-STORAGE SECTION. 
01 PROGRAM-SWITCHES. 
05 NO-DATA-REMAINS-SWITCH 
88 NO-DATA-REMAINS 
05 VALID-RECORD-SWITCH 
88 VALID-RECORD 
PIC X(132). 
PIC XXX VALUE SPACES. 
VALUE 'NO'. 
PIC X(3). 
VALUE 'YES
1. 
01 VALIDATION-CONSTANTS-AND-CALCS. 
05 MILES-PER-DAY-FACTOR 
PIC 99 VALUE 10. 
05 EXPECTED-MILES 
PIC 9(6). 
05 ACTUAL-MILES 
PIC 9(6). 
01 ERROR-REASONS. 
05 NON-NUMERIC-CONTRACT-MSG PIC X(40) 
VALUE 'NON-NUMERIC CONTRACT NUMBER' 
05 LAST-NAME-MSG 
PIC X(40) 
VALUE 'MISSING LAST NAME'. 
05 FIRST-NAME-MSG 
PIC X(40) 
VALUE 'MISSING FIRST NAME'. 
05 INITIAL-MSG 
PIC X(40) 

The 
Stand-Alone 
Edit 
Program 
(continued) 
74 
VALUE 'NON ALPHABETIC INITIAL'. 
75 
05 CAR-TYPE-MSG 
PIC X(40) 
76 
VALUE 'CAR TYPE MUST BE: E, C, M, F, OR L'. 
77 
| 
05 MONTH-MSG 
PIC X(40) 
j 
78 
VALUE 'MONTH MUST BE BETWEEN 1 AND 12'. 
I 
79 
| 
05 DAY-MSG 
PIC X(40) 
| 
80 
j 
VALUE 'INVALID DAY'. 
\ 
81 
1 
05 FUTURE-DATE-MSG 
PIC X(40) 
j 
82 
| 
VALUE 'DATE HAS NOT YET OCCURRED
1. 
83 
| 
05 NON-NUM-DAYS-RENTED-MSG 
PIC X(40) 
84 
! 
VALUE 'DAYS RENTED MUST BE NUMERIC. 
j 
85 
j 
05 ZERO-DAYS-MSG 
PIC X(40) 
I 
86 
j 
VALUE 'DAYS RENTED MUST BE > ZERO'. 
j 
87 
05 LEASING-MSG 
PIC X(40) 
88 
VALUE 'REFER TO LONG-TERM LEASING'. 
\— 
89 
i 
05 NON-NUM-MILES-IN-MSG 
PIC X(40) 
! 
90 
I 
VALUE 'NON-NUMERIC MILES IN'. 
91 
| 
05 NON-NUM-MILES-OUT-MSG 
PIC X(40) 
92 
VALUE 'NON-NUMERIC MILES OUT'. 
93 
! 
05 LESS-THAN-MILES-MSG 
PIC X(40) 
94 
| 
VALUE 'MILEAGE IN LESS THAN MILEAGE OUT' . 
95 
: 
05 INVALID-MILES-MSG 
PIC X(40) 
96 
! 
VALUE 'MILES DRIVEN UNREASONABLY LOW
1. 
97 
j 
05 NON-NUM-RATE-MSG 
PIC X(40) 
98 
VALUE 'NON-NUMERIC MILEAGE RATE
1. 
99 
05 MILEAGE-RATE-MSG 
PIC X(40) 
100 
i 
VALUE 'MILEAGE RATE OUT OF RANGE
1. 
101 
| 
05 INSURANCE-MSG 
PIC X(40) 
| 
102 
!_ __ 
VALUE 'INSURANCE CODE MUST BE Y OR N'. 
j 
103 
"
_
~
~ 
~ " 
- - 
— 
104 
01 TODAYS-DATE. 
105 
05 TODAYS-YEAR 
PIC 99. 
106 
05 TODAYS-MONTH 
PIC 99. 
107 
05 TODAYS-DAY 
PIC 99. 
108 
109 
01 HEADING-ERROR-LINE-ONE. 
110 
05 FILLER 
PIC X(26) VALUE SPACES. 
111 
05 FILLER 
PIC X(19) 
112 
VALUE 'ERROR REPORT AS OF '. 
113 
05 HDG-DATE. 
114 
10 HDG-MONTH 
PIC 99/. 
1.15 
10 HDG-DAY 
PIC 99/. 
116 
10 HDG-YEAR 
PIC 99. 
117 
05 FILLER 
PIC X(79) VALUE SPACES. 
118 
119 
01 HEADING-ERROR-LINE-TWO. 
120 
05 FILLER 
PIC X(10) VALUE 'CONTRACT # 
121 
05 FILLER 
PIC XX 
VALUE SPACES. 
122 
05 FILLER 
PIC X(9) VALUE 'LAST NAME' 
123 
05 FILLER 
PIC X(8) VALUE SPACES. 

P c. ^-e s . 
L(continued) 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
i yi A 
1 H U 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
05 FILLER 
PIC X(21) 
VALUE 'ERROR MESSAGE & FIELD'. 
05 FILLER 
05 FILLER 
05 FILLER 
01 ERROR-LINE. 
05 FILLER 
05 
ERR-CONTRACT-NO 
05 FILLER 
05 
ERR-LAST-NAME 
05 FILLER 
05 ERR-MESSAGE 
05 FILLER 
05 
ERR-CONTENTS 
05 FILLER 
01 
PIC X(21) VALUE SPACES. 
PIC X(8) VALUE 'CONTENTS' 
PIC X(46) VALUE SPACES. 
PIC XX 
VALUE SPACES. 
PIC 9(6). 
PIC X(4) VALUE SPACES. 
PIC X(15). 
PIC XX 
VALUE SPACES. 
PIC X(40). 
PIC XX 
VALUE SPACES. 
PIC X(23). 
PIC X(38) VALUE SPACES. 
ERROR-DETAILS. 
05 
ERR-MILES-IN-OUT. 
10 FILLER 
10 ERR-MILES-IN 
10 FILLER 
10 
ERR-MILES-OUT 
05 
ERR-RETURNED-DATE. 
10 
ERR-RETURNED-MONTH-DAY 
15 
ERR-RETURNED-MONTH 
15 
ERR-RETURNED-DAY 
10 
ERR-RETURNED-YEAR 
ERR-EXPECTED-MILES. 
10 FILLER 
10 
ERR-DAYS-RENTED 
10 FILLER 
10 
ERR-MILES 
PROCEDURE DIVISION. 
OOO-CREATE-VALID-RENTAL-FILE. 
05 
PIC X(4) VALUE 
PIC 9(6). 
PIC X(6) VALUE 
PIC 9(6). 
PIC 99. 
PIC /99. 
PIC /99. 
PIC X(6) VALUE 
PIC 99. 
PIC X(9) VALUE 
PIC 9(6). 
'IN: 
OUT: 
DAYS: 
MILES: 
OPEN INPUT 
RENTAL-FILE 
OUTPUT VALID-RENTAL-FILE 
ERROR-FILE. 
PERFORM 100-GET-TODAYS-DATE. 
PERFORM 200-WRITE-ERROR-HEADINGS. 
PERFORM 300-READ-RENTAL-RECORD. 
PERFORM 400-PR0CESS-RENTAL-REC0RDS 
UNTIL NO-DATA-REMAINS. 
CLOSE RENTAL-FILE 
VALID-RENTAL-FILE 
ERROR-FILE. 
STOP RUN. 
100-GET-TODAYS-DATE. 

The 
Stand-Alone 
Edit 
Program 
1 
(continued) 
174 
[ A C T E P J ~ ^ 
} 
175 
MOVETODAYS-MONTH'TO' HOG-MONTH. 
176 
M O V E TODAYS-DAY T O HDG-DAY. 
177 
M O V E TODAYS-YEAR T O HDG-YEAR. 
178 
179 
200-WRITE-ERROR-HEADINGS. 
180 
M O V E H E A D I N G - E R R O R - L I N E - O N E TO ERROR-RECORD. 
181 
W R I T E ERROR-RECORD 
182 
A F T E R A D V A N C I N G PAGE. 
183 
M O V E HEADING-ERROR-LINE-TWO T O ERROR-RECORD 
184 
W R I T E ERROR-RECORD 
185 
A F T E R A D V A N C I N G 2 LINES. 
186 
M O V E S P A C E S T O ERROR-RECORD. 
187 
W R I T E ERROR-RECORD. 
188 
189 
300-READ-RENTAL-RECORD. 
190 
READ R E N T A L - F I L E 
191 
AT END MOVE 'NO' TO NO-DATA-REMAINS-SWITCH 
192 
END-READ. 
193 
194 
4 0 0 - P R 0 C E S S - R E N T A L - R E C 0 R D S . 
195 
[ MOVj_' Y E V ~ T0~ VAJLID-RECORD-SWITCH. , -
196 
PERFORM 500-VALIDATE-RENTAL-RECORD. 
197 
PERFORM 600-WRITE-VALID-RECORD. 
198 
PERFORM 300-READ-RENTAL-RECORD. 
199 
200 
500-VALIDATE-RENTAL-RECORD. 
201 
PERFORM 
510-VALIDATE-CONTRACT-NO. 
202 
PERFORM 5 2 0 - V A L I D A T E - N A M E . 
203 
PERFORM 5 3 0 - V A L I D A T E - C A R - T Y P E . 
204 
PERFORM 
540-VALIDATE-DATE-RETURNED. 
205 
PERFORM 550-VALIDATE-DAYS-RENTED. 
206 
PERFORM 5 6 0 - V A L I D A T E - M I L E S - D R I V E N 
207 
PERFORM 5 7 0 - V A L I D A T E - M I L E A G E - R A T E . 
2 0 8 
PERFORM 5 8 0 - V A L I D A T E - I N S U R A N C E . 
209 
210 
510-VALIDATE-CONTRACT-NO. 
211 
IILM^NJMI^^ 
212 
M O V E N O N - N U M E R I C - C O N T R A C T - M S G T O ERR-MESSAGE 
213 
M O V E R E N - C O N T R A C T - N O T O ERR-CONTENTS 
214 
PERFORM 5 9 9 - W R I T E - E R R O R - L I N E 
215 
END-IF. 
216 
217 
520-VALIDATE-NAME. 
218 
I F REN-LAST-NAME = S P A C E S 
219 
M O V E LAST-NAME-MSG T O E R R - M E S S A G E 
220 
M O V E SPACES T O ERR-CONTENTS 
221 
PERFORM 5 9 9 - W R I T E - E R R O R - L I N E 
222 
END-IF. 
223 
I F REN-FIRST-NAME = S P A C E S 

C
h
a
p
t
e
r 
its 
(continued) 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
O/l/l 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
MOVE FIRST-NAME-MSG TO ERR-MESSAGE 
MOVE SPACES TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF. 
II
F R E!HM
T I A L N 0IJ*
L P H A B E T ILT' 
" 
~MOVE INITIAL-MSG TO ERR-MESSAGE 
MOVE REN-INITIAL TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF. 
530-VALIDATE-CAR-TYPE. 
IF NOT VALID-CAR-TYPES 
MOVE CAR-TYPE-MSG TO ERR-MESSAGE 
MOVE REN-CAR-TYPE TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF. 
540-VA LIDAT E\-DATE-RETURNED. 
!IF VALID-MONTHS 
IF 30-DAY-MONTH AND REN-RETURNED-DAY <= 30 OR 
31-DAY-MONTH AND REN-RETURNED-DAY <= 31 OR 
FEBRUARY AND REN-RETURNED-DAY <= 29 
IF REN-RETURNED-DATE > TODAYS-DATE 
MOVE FUTURE-DATE-MSG TO ERR-MESSAGE 
MOVE REN-RETURNED-MONTH TO ERR-RETURNED-MONTH 
MOVE REN-RETURNED-DAY TO ERR-RETURNED-DAY 
MOVE REN-RETURNED-YEAR TO ERR-RETURNED-YEAR 
MOVE ERR-RETURNED-DATE TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF 
ELSE 
MOVE DAY-MSG TO ERR-MESSAGE 
MOVE REN-RETURNED-MONTH TO ERR-RETURNED-MONTH 
MOVE REN-RETURNED-DAY TO ERR-RETURNED-DAY 
MOVE ERR-RETURNED-MONTH-DAY TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF 
ELSE 
MOVE MONTH-MSG TO ERR-MESSAGE 
MOVE REN-RETURNED-MONTH TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF. 
550-VALIDATE-DAYS-RENTED. 
IF REN-DAYS-RENTED NOT NUMERIC 
MOVE NON-NUM-DAYS-RENTED-MSG TO ERR-MESSAGE 
MOVE REN-DAYS-RENTED TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
ELSE 
IF ZERO-DAYS-RENTED 

The 
Stand-Alone 
Edit 
Program 
(continued) 
274 
M O V E ZERO-DAYS-MSG T O ERR-MESSAGE 
275 
M O V E REN-DAYS-RENTED T O ERR-CONTENTS 
276 
PERFORM 599-WRITE-ERROR-LINE 
277 
ELSE 
2 7 8 
I F N O T VALID-DAYS-RENTED 
279 
M O V E LEASING-MSG T O ERR-MESSAGE 
280 
M O V E REN-DAYS-RENTED TO ERR-CONTENTS 
281 
PERFORM 599-WRITE-ERROR-LINE 
282 
E N D - I F 
283 
E N D - I F 
284 
E N D - I F . 
285 
286 
560-VALIDATE-MILES-DRIVEN. 
287 
I F REN-MILES-IN NOT NUMERIC 
288 
M O V E NON-NUM-MILES-IN-MSG TO ERR-MESSAGE 
289 
M O V E REN-MILES-IN T O ERR-CONTENTS 
290 
PERFORM 5 9 9 - W R I T E - E R R O R - L I N E 
291 
E L S E 
292 
I F REN-MILES-OUT NOT N U M E R I C 
293 
M O V E NON-NUM-MILES-OUT-MSG T O ERR-MESSAGE 
294 
M O V E REN-MILES-OUT T O ERR-CONTENTS 
295 
PERFORM 5 9 9 - W R I T E - E R R O R - L I N E 
296 
ELSE 
297 
I F R E N - M I L E S - I N < REN-MILES-OUT 
298 
MOVE LESS-THAN-MILES-MSG TO ERR-MESSAGE 
299 
M O V E R E N - M I L E S - I N T O ERR-MILES-IN 
300 
MOVE REN-MILES-OUT TO ERR-MILES-OUT 
301 
MOVE ERR-MILES-IN-OUT TO ERR-CONTENTS 
302 
PERFORM 5 9 9 - W R I T E - E R R O R - L I N E 
303 
E L S E 
304 
C O M P U T E EXPECTED-MILES = 
305 
M I L E S - P E R - D A Y - F A C T O R / R E N - D A Y S - R E N T E D 
306 
"sizFERROfi! DISPLAY" 'SIZE ERROR EXPECT M I L E S 
307 
END-COMPUTE 
308 
C O M P U T E A C T U A L - M I L E S = 
309 
J R E N - M R J S - I N - RjEN_-MILES-OUT_ 
310 
I S I Z E ERROR DISPLAY 'SIZE J R J R O F A C T U A L _ MTL.ES 
311 
END-COMPUTE 
312 
I F A C T U A L - M I L E S < EXPECTED-MILES 
313 
M O V E INVALID-MILES-MSG T O E R R - M E S S A G E 
314 
M O V E R E N - D A Y S - R E N T E D T O ERR-DAYS-RENTED 
315 
M O V E A C T U A L - M I L E S TO E R R - M I L E S 
316 
M O V E E R R - E X P E C T E D - M I L E S TO ERR-CONTENTS 
317 
PERFORM 5 9 9 - W R I T E - E R R O R - L I N E 
318 
E N D - I F 
319 
E N D - I F 
320 
E N D - I F 
321 
END-IF. 
322 
323 
5 7 0 - V A L I D A T E - M I L E A G E - R A T E . 

Chapter 
8 
Data 
Validation 
13 
(continued) 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
IF REN-MILEAGE-RATE NOT NUMERIC 
MOVE NON-NUM-RATE-MSG TO ERR-MESSAGE 
MOVE REN-MILEAGE-RATE TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
ELSE 
IF NOT VALID-MILEAGE-RATES 
MOVE MILEAGE-RATE-MSG TO ERR-MESSAGE 
MOVE REN-MILEAGE-RATE TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
END-IF 
END-IF. 
580-VALIDATE-INSURANCE. 
IF NOT VALID-INSURANCE 
MOVE INSURANCE-MSG TO ERR-MESSAGE 
MOVE REN-INSURANCE TO ERR-CONTENTS 
PERFORM 599-WRITE-ERROR-LINE 
rrjrj_ TC 
599-WRITE-ERROR-LINE. 
MOVE 'NO ' TO VALID-RECORD-SWITCH. 
MOVE REN-CONTRACT-NO TO ERR-CONTRACT-NO. 
MOVE REN-LAST-NAME TO ERR-LAST-NAME. 
MOVE ERROR-LINE TO ERROR-RECORD. 
WRITE ERROR-RECORD. 
600-WRITE-VALID-RECORD. 
|IF VALID-RECORD 
| 
MOVE RENTAL-RECORD TO VALID-RENTAL-RECORD 
j 
WRITE VALID-RENTAL-RECORD 
' ELSE 
MOVE SPACES TO ERROR-RECORD 
WRITE ERROR-RECORD 
END-IF. 
and easy to follow. The logic in the program parallels that of t h e p s e u d o c o d e just 
developed, whereas the paragraphs in the Procedure Division correspond o n e to 
o n e with the m o d u l e s in the hierarchy chart. The program c o m p l i e s completely 
with the processing requirements and also illustrates the various COBOL features 
presented earlier. Consider: 
1. The use of condition n a m e s within the FD for RENTAL-RECORD (e.g., lines 
28-31, 34, 36-37, etc.) to define valid values for the various input fields. 
2. A table of error m e s s a g e s in lines 66-102; grouping t h e error m e s s a g e s 
in this w a y m a k e s it e a s y to d e t e r m i n e p r e c i s e l y w h i c h error c h e c k s 
are i m p l e m e n t e d . It also facilitates uniform f o r m a t t i n g of t h e various 
error messages. 

The 
Stand'Alone 
Edit 
Program 
3. The A C C E P T statement in line 174 to obtain the system date; also the definition 
of T O D A Y S - D A T E in WORKING-STORAGE to hold the date after it is read. 
4. The M O V E statement to initialize V A L I D - R E C O R D - S W I T C H to 'YES' for each 
incoming transaction record (line 195). A second M O V E statement in the 
W R I T E - E R R O R - L I N E paragraph (line 344) to reset the switch to 'NO' if the 
current transaction fails any one of the validity tests. 
5. Various class tests for numeric and alphabetic data as in lines 211 and 228. 
6. A nested IF statement in lines 242-265 to implement the various types of date 
validation. A second nested IF statement in lines 287 through 321 performs 
the various checks on the incoming, outgoing, and computed mileage. 
7. SIZE E R R O R clauses within the C O M P U T E statements, lines 306 and 310, in 
anticipation of unexpectedly large fields. 
8. The IF statement in lines 351-357 that determines whether the transaction is 
written to the valid file. Note, too, the ELSE clause within this IF statement, 
which writes a blank line for every invalid record, which in turn puts a blank 
line before each group of invalid transactions in the error report. 
COBOL-85 introduced two additional relational conditions into the IF statement, 
GREATER THAN OR EQUAL TO and LESS THAN OR EQUAL TO; these 
conditions were not allowed in COBOL-74, which used NOT LESS THAN as 
the equivalent of GREATER THAN OR EQUAL TO and NOT GREATER THAN 
for LESS THAN OR EQUAL TO. 
COBOL-85 enables the testing of upper- and/or lowercase letters 
through expansion of the alphabetic class test. In COBOL-85 the ALPHABETIC 
test is true for uppercase letters, lowercase letters, and the space character; 
the ALPHABETIC-UPPER test is true for uppercase letters and the space 
character; and the ALPHABETIC-LOWER test is true for lowercase letters 
and the space character. There were no UPPER/LOWER tests in COBOL-74 
and the ALPHABETIC test was true only for uppercase letters and space 
characters. 
The most significant change, however, is the introduction of the END-IF 
scope terminator, which did not exist in COBOL-74. We have already seen 
how the scope terminator eliminates the column-73 problem in conjunction 
with a "missing period" (page 182) and how it eliminates the need for the 
NEXT SENTENCE clause (Figure 8.7). The scope terminator also facilitates 
the nesting of conditional statements as shown in Figure 8.14. 
Consider, for example, the flowchart of Figure 8.14a, and the contrasting 
implementations in COBOL-85 and COBOL-74 in Figures 8.14b and 8.14c, 
respectively. The END-IF terminator transforms a conditional statement to an 
imperative (complete) statement, making it possible to express the required 
logic as a single IF statement in COBOL-85. By contrast, the COBOL-74 
implementation requires an additional PERFORM statement and is more 
difficult to follow. 

Chapter 
8 
Data 
Validation 
4 
Limitations of COBOL-74 
ADD 1 TO 
MALE-COUNTER 
;hart 
IF VALID-RECORD-SW =
 1Y' 
IF SEX = 'M' 
ADD 1 TO MALE-COUNTER 
END-IF 
IF INCOME > 50000 
ADD 1 TO HIGH-INCOME-CTR 
END-IF 
END-IF. 
(b) COBOL-85 
IF VALID-RECORD-SW = 'Y' 
PERFORM DO-MORE-TESTS. 
DO-MORE-TESTS. 
IF SEX = 'M' 
ADD 1 TO MALE-COUNTER. 
IF INCOME > 50000 
ADD 1 TO HIGH-INCOME-CTR. 

Data validation is a critical portion of any system, as the output produced 
by any program is only as good as its input. 
Data validation is often done in a stand-alone edit program as opposed to 
the reporting program that processes the data; that is, the valid transaction 
file produced as output by the edit program becomes the input file to the 
reporting program. 
The ACCEPT statement is used to obtain the date of execution for use in 
implementing various types of date checks. 
There are four types of conditions in the IF statement: relation, class, sign, 
and condition name (88-level entries). 
Any two simple conditions may be combined to form a compound condition 
using the logical operators AND and OR. An IF statement may also use 
implied conditions, in which the subject and/or operation is understood. 
A nested IF statement contains two or more IF statements within a sentence. 
The scope of the condition in the IF statement is terminated by the ELSE 
clause, the END-IF scope terminator, and/or a period. The scope terminator 
is optional but strongly recommended in all instances. 
Indentation within an IF statement is not required by the compiler but 
recommended to facilitate the programmer's interpretation. 
The NEXT SENTENCE clause directs control to the statement immediately 
following the period and is required (in COBOL-74) to implement certain 
types of nested conditional statements. The END-IF scope terminator, 
introduced in COBOL-85, eliminates the need for the NEXT SENTENCE 
clause in all instances. 
88-level entry 
Alphabetic test 
Class test 
Completeness check 
Compound test 
Condition name 
Consistency check 
Data validation 
Date check 
Edit program 
Existing code check 
Implied condition 
Limit check 
Nested IF 
Numeric test 
Range check 
Reasonableness check 
Scope terminator 
Sequence check 
Sign test 
Subscript check 

Chapter 
8 -
Data 
Validation 
L 
- 
/ N 
Bl&ments 
ACCEPT 
AND 
DATE 
DAY 
DAY-OF-WEEK 
END-IF 
IF 
NEXT SENTENCE 
NOT 
OR 
TIME 
1. Incoming data should be 
prior to being used in computations. 
2. The valid transaction file produced as output by an edit program is 
to a reporting program. 
3. A 
test ensures that numeric fields do in fact contain numeric 
data. 
4. A 
check tests that a value does not exceed a designated upper 
or lower bound. 
5. A 
check verifies that all required fields are present. 
6. In evaluating a compound condition, AND comes (before/after) OR. 
7. A condition name is also known as an 
-level entry. 
8. The 
clause directs control to the statement 
immediately following the period. 
9. The 
scope terminator eliminates the need for the NEXT SENTENCE 
clause. 
10. 
The statement, ACCEPT DATE-WORK-AREA FROM DATE requires specification of 
a user-defined work area in the form, 
. 
T R U E / F A L S E 
1. Output from a reporting program is typically input to an edit program. 
2. The numeric class test can be applied to alphanumeric data. 
3. The alphabetic class test can be applied to alphanumeric data. 
4. The numeric class test can be applied to alphabetic data. 
5. The alphabetic class test can be applied to numeric data. 
6. A nested IF statement contains two or more IF statements within a single sentence. 
7. The NEXT SENTENCE clause may be associated with either an IF or an ELSE. 
8. The END-IF scope terminator eliminates the need for a NEXT SENTENCE clause. 
9. The ACCEPT statement is used to obtain the date of execution. 
10. DATE is a COBOL reserved word, containing the date of execution in the form 
yymmdd. 
11. DAY and DATE produce the same results. 
12. TIME returns a six-digit numeric field, indicating the time of program execution. 

1. Recode the following statements to include scope terminators and proper indentation 
with the ELSE clause indented under the relevant IF. 
a. IF A > B, IF C > D, M O V E E T O F, 
ELSE M O V E G T O H. 
b. IF A > B, IF C > D, M O V E E T O F, 
ELSE M O V E G T O H, ELSE M O V E X T O Y. 
c. IF A > B, IF C > D, M O V E E T O F, 
A D D 1 T O E, ELSE M O V E G T O H, 
A D D 1 T O G. 
d. IF A > B, M O V E X T O Y, M O V E Z T O W , 
ELSE IF C > D M O V E 1 T O N, 
ELSE M O V E 2 T O Y, A D D 3 T O Z. 
2. Given the nested IF statement: 
IF SEX =
 1M' 
PERFORM PROCESS-MALE-RECORD 
ELSE 
IF SEX = 'F' 
PERFORM PROCESS-FEMALE-RECORD 
ELSE 
PERFORM WRITE-ERROR-MESSAGE 
END-IF 
END-IF. 
and the logically equivalent code: 
IF SEX = 'M' 
PERFORM PROCESS-MALE-RECORD 
END-IF. 
IF SEX = 'F' 
PERFORM PROCESS-FEMALE-RECORD 
END-IF. 
IF SEX NOT = 'M' AND SEX NOT = 'F' 
PERFORM WRITE-ERROR-MESSAGE 
END-IF. 
a. Discuss the relative efficiency of the two alternatives. 
b. What would be the effect of changing A N D to O R in the third IF of the second set 
of statements? 
c. What would be the effect of removing the word ELSE wherever it occurs in the 
first set of IF statements? 
3. Are the two IF statements logically equivalent? 
Statement 1: 
IF A > B 
IF C > D 
ADD 1 TO X 
ELSE 
ADD 1 TO Y 
END-IF 
END-IF. 

C
h
a
p
t
e
r 
8 
Data 
Validation 
Statement 2: 
IF A > B AND C > D 
ADD 1 TO X 
ELSE 
ADD 1 TO Y 
END-IF. 
I ry the following sets of values to aid in answering the question: 
a. A = 5,B = 1,C= 10, D= 15. 
b. A=1,B = 5, C = 10, D = 15. 
4. Company XYZ has four corporate functions: manufacturing, marketing, financial, 
and administrative. Each function in turn has several departments, as shown: 
F U N C T I O N 
D E P A R T M E N T S 
MANUFACTURING 
10, 12, 16-30, 41, 56 
MARkETING 
6-9,15,31-33 
FINANCIAL 
60-62, 75 
ADMINISTRATIVE 
1-4, 78 
Establish condition-name entries so that, given a value of EMPLOYEE-DEPARTMENT, 
you can determine the function. Include an 88-ievel entry, VALID-CODES, to verify 
that the incoming department is indeed a valid department (any department 
number not shown is invalid). 
5. Given the following COBOL definitions: 
05 LOCATION-CODE 
PIC 99. 
88 NEW-YORK 
VALUE 10. 
88 BOSTON 
VALUE 20. 
88 CHICAGO 
VALUE 30. 
88 DETROIT 
VALUE 40. 
88 NORTH-EAST 
VALUES 10 20. 
Are the following entries valid as the condition portion of an IF statement? 
a. IF LOCATION-CODE = '10' 
b. IF LOCATION-CODE = 40 
c. IF NEW-YORK 
d. IF LOCATION-CODE = 10 OR 20 OR 30 
e. IF NEW-YORK OR BOSTON OR CHICAGO 
f. IF DETROIT = 40 
Would the following be valid examples of MOVE statements? 
g. MOVE 20 TO BOSTON. 
h. MOVE 20 TO LOCATION-CODE. 
i. MOVE '20' TO LOCATION-CODE. 
6. Given the following pairs of IF statements, indicate whether the statements in each 
pair have the same effect: 
a. IF A > B OR C > D AND E = F 
IF A > B OR (C > D AND E = F) 
b. IF A > B OR C > D AND E = F 
IF (A > B OR C > D) AND E = F 
c. IF A > B OR A > C OR A > D 
IF A> B OR C OR D 
d. IF A > B 
IF A NOT < B OR A NOT = B 

Problems 
7. Consider the following code, intended to calculate an individual's age from a 
stored birth date and the date of execution. 
01 EMPLOYEE-RECORD. 
05 EMP-BIRTH-DATE. 
10 BIRTH-MONTH 
PIC 99. 
10 BIRTH-YEAR 
PIC 99. 
01 DATE-WORK-AREA. 
05 TODAYS-MONTH 
PIC 99. 
05 TODAYS-DAY 
PIC 99. 
05 TODAYS-YEAR 
PIC 99. 
PROCEDURE DIVISION. 
ACCEPT DATE-WORK-AREA FROM DATE. 
COMPUTE EMPLOYEE-AGE = TODAYS-YEAR - BIRTH-YEAR 
I here are two distinct reasons why the code will not work as intended. Find and 
correct the errors. 
8. Implement the logic in Figure 8.15 with and without scope terminators, corresponding 
to the implementations in COBOL-74 and COBOL-85. Do you see any distinct 
advantages to the latter compiler? 
Figuufe ii.iS 
Flowcharts for Problem 8 
+ TODAYS-MONTH - BIRTH-MONTH. 
statement^ 
statement,, 
statement, 


I"
 
1 
1 
I 
Overview 
P E R F O R M 
TEST BEFORE/TEST AFTER 
In-line Perform 
Performing Sections 
PERFORM THRU 
P r o n r a m m i n n Tin- Perform PptranrpnhQ Mot Sections 
R E A D 
False-Condition Branch 
READ INTO 
W R I T E FROM 
I N I T I A L I Z E 
S t r i n g 
P r o c e s s i n g 
INSPECT 
STRING 
UNSTRING 
Reference Modification 
A C C E P T 
D u p l i c a t e 
D a t a 
N a m e s 
Qualification 
MOVE CORRESPONDING 
T h e C a r Billing P r o g r a m 
Programming Specifications 
Program Design 
The Completed Program 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
9 
More 
About 
the 
Procedure 
Division 
O B J E C T 
IVES 
After reading this chapter you will be able to: 
Differentiate between the DO WHILE and DO UNTIL structures; describe 
how each is implemented in conjunction with a PERFORM statement. 
> 
Define an in-line perform and a false-condition branch; explain how the 
combination of these features eliminates the need for a priming read 
statement. 
Differentiate between a paragraph and a section. 
Code the READ INTO and WRITE FROM statements in the Procedure 
Division. 
Use the INITIALIZE statement. 
Perform basic string processing operations through use of the INSPECT, 
STRING, and UNSTRING statements. 
Define a duplicate data name and use qualification to eliminate ambiguity; 
describe the use of the MOVE CORRESPONDING statement. 
O V E R 
VIEW 
This chapter completes the two-program sequence begun in Chapter 8 by 
developing the reporting program for the valid transaction file. The program is 
also intended to illustrate a series of advanced Procedure Division statements 
that are presented in the chapter. Many of the statements are new to COBOL-85 
and were not available in COBOL-74. 
We begin with the PERFORM statement and include material on the TEST 
BEFORE and TEST AFTER clauses which correspond to the DO WHILE and DO 
UNTIL constructs of structured programming. The in-line perform is presented, 
as is the THROUGH clause, to perform multiple paragraphs; the use of sections 
in lieu of paragraphs is also covered. The READ INTO and WRITE FROM 
clauses are introduced to combine the effects of a MOVE statement with the 
indicated I/O operation. The ACCEPT statement is expanded to include the 
DAY-OF-WEEK clause, and the INITIALIZE statement establishes values for 
multiple data names in a single statement. The INSPECT, STRING, and UNSTRING 
statements are introduced to implement string processing operations. Duplicate 
data names, qualification, and the MOVE CORRESPONDING statement are 
introduced as well. 

The program at the end of the chapter is designed very differently from the 
programs presented thus far as it uses an in-line perform and a false-condition 
branch to eliminate the priming read used in earlier programs. The program also 
makes extensive use of scope terminators throughout the Procedure Division. 
A simple form of the P E R F O R M statement has been used throughout the text to 
implement the iteration construct of structured programming: 
PERFORM procedure-name UNTIL condition 
The condition in the U N T I L clause is tested before the procedure is executed, and if 
the condition is not met, control is transferred to the designated procedure. W h e n 
the procedure has completed execution, the condition is retested, a n d if it (the 
condition) is still not met, the procedure is executed a second time. The process 
continues indefinitely until the condition is finally satisfied. 
In actuality the P E R F O R M statement is considerably m o r e complex with m a n y 
additional options. Consider: 
PERFORM procedure-name - 1 
JTHRQUGH] 
'THRU 
procedure - name - 2 
WITH TEST [BEFORE 
UNTIL condition-1 
[imperati ve-statement-1 END-PERFORM] 
The optional T E S T B E F O R E / T E S T A F T E R clause is explained in conjunction with 
Figure 9.1. Figure 9.1a depicts the D O W H I L E structure that has been used 
The Iteration Structure 
(a) BO WHILE Construct 
(b) DO UNTIL Construct 

Chapter 
9 
More 
About 
the 
Procedure 
Division 
throughout the book, while Figure 9.1b illustrates the slightly different D O U N T I L 
structure. The difference between the two (aside from the semantics of switching 
the true and false branches) pertains to the sequence in which the condition a n d 
statement are executed. 
The D O W H I L E structure of Figure 9.1a tests the condition before executing 
Block A; the D O U N T I L structure in Figure 9.1b tests the condition after executing 
Block A. T h e D O W H I L E structure does not execute Block A if the condition is 
initially false, whereas D O UNTIL guarantees that Block A is executed at least once. 
The P E R F O R M statement includes the T E S T B E F O R E and T E S T A F T E R phrases, 
corresponding to a D O W H I L E and D O U N T I L , respectively. Specification of T E S T 
B E F O R E tests the condition before performing the procedure, a n d corresponds to 
the D O W H I L E . Specification of T E S T A F T E R performs the procedure and then tests 
the condition, a n d corresponds to a D O U N T I L . Omission of both T E S T B E F O R E 
and T E S T A F T E R (as has been done throughout the text) defaults to T E S T B E F O R E . 
The procedure-name is enclosed within brackets within the syntax of the P E R F O R M 
statement a n d thus is an optional 
entry. Omission of the procedure n a m e produces 
an in-line perform, where the statements to be executed appear immediately below 
the P E R F O R M statement itself, as opposed to the out-of-line execution of a 
designated procedure elsewhere in the program. For example: 
PERFORM 
Statement 1 
Statement 2 
END-PERFORM 
A n in-line perform functions just as a regular P E R F O R M , except that the 
statements to be executed are contained entirely within the statement—that is, 
between P E R F O R M and E N D - P E R F O R M . Omission of the procedure n a m e (that is, 
specification of a n in-line perform) requires the E N D - P E R F O R M delimiter; 
conversely, the E N D - P E R F O R M m a y nothe specified in conjunction with performing 
a paragraph.  
The procedure n a m e in the P E R F O R M statement can be either a paragraph or a 
section. A paragraph consists of one or m o r e sentences, whereas a section is m a d e 
up of one or m o r e paragraphs. Paragraph headers are required to begin in the A-
margin (columns 8-11), whereas sentences begin in the B-margin (columns 12-72). 
The compiler recognizes the e n d of one paragraph w h e n it senses the beginning of 
the next paragraph—that is, w h e n it finds the next entry in the A-margin. Section 
headers also begin in the A margin and are distinguished from paragraph headers 
by the reserved w o r d S E C T I O N . 
W h e n a paragraph is performed, control is transferred to the first sentence in 
that paragraph a n d remains in that paragraph until the next paragraph is reached. 
In similar fashion, if the procedure n a m e in a P E R F O R M statement refers to a 
section (rather than a paragraph), control is transferred to the first paragraph in 
that section a n d remains in that section until the next section is reached. 
The authors suggest that you avoid sections altogether (see tip o n page 233); 
the material is included here because sections appear in m a n y older C O B O L 
programs. 
Other statements to be executed 

PERFORM 
P R O G R A M M I N G . 
T I P 
The motivation behind this guideline is best demonstrated by example. Given the following Procedure 
Division, what will be the final value of X? 
PROCEDURE DIVISION. 
MAINLINE SECTION. 
MOVE ZERO TO X. 
PERFORM A. 
PERFORM B. 
PERFORM C. 
PERFORM D. 
STOP RUN. 
A SECTION. 
ADD 1 TO X. 
B. 
ADD I TO X. 
C. 
ADD 1 TO X. 
D. 
ADD 1 TO X. 
The correct answer is 7, not 4. A common error made by many programmers is a misinterpretation of the 
statement PERFORM A. Since A is a section and not a paragraph, 
the statement PERFORM A invokes every 
paragraph in that section, namely, paragraphs B, C, and D, in addition to the unnamed paragraph immediately 
after the section header. 
A PERFORM statement specifies a procedure, 
which is either a section or a paragraph, yet there is no 
way of telling the nature of the procedure from the PERFORM statement itself. Consequently, when a section 
is specified as a procedure, the unfortunate result is too often execution of unintended code. Can't happen? 
Did you correctly compute the value of X? 
T h e T H R O U G H (THRU) clause executes all statements between the specified 
procedure names. The procedures m a y be paragraphs or sections, but procedure-
name-1 must be physically before procedure-name-2 within the C O B O L program. 
A c o m m o n practice is to m a k e procedure-name-2 a single-sentence paragraph 
consisting of the w o r d EXIT. The EXIT statement causes no action to be taken; its 
function is to delineate the e n d of the P E R F O R M . Consider: 
PERFORM PROCESS-RECORDS THRU PROCESS-RECORDS-EXIT. 
PROCESS-RECORDS. 

C h a p t e r 
9 
More 
About 
the 
Procedure 
Division 
PROCESS-RECORDS-EXIT. 
EXIT. 
The only practical reason to use a P E R F O R M T H R U statement with an EXIT 
paragraph is to enable downward branching to the EXIT statement depending o n a 
condition within the paragraph. Although a n argument could be m a d e for this 
usage in limited instances, the need for such statements as G O T O P R O C E S S -
R E C O R D S - E X I T should generally be avoided. 
The R E A D statement includes two important clauses—INTO and N O T A T E N D — t h a t 
were not previously presented. Consider: 
READ file-name RECORD [ JJfJO identifier ] 
[AT END imperative-statement-1] 
[NOT AT END imperative-statement-2] 
[END-READ] 
•igure 9.2 
Structure of a COBOL Prograrr 
READ INPUT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH. 
PERFORM PROCESS-RECORDS 
UNTIL DATA-REMAINS-SWITCH = 'NO'. 
PROCESS-RECORDS. 
READ INPUT-FILE 
AT END MOVE 'NO' TO DATA-REMAINS-SWITCH. 
(a) Priming Read 
j 
l 
PERFORM UNTIL DATA-REMAINS-SWITCH = 'NO' 
j 
READ INPUT-FILE 
[ 
AT END 
j 
MOVE 'NO' TO DATA-REMAINS-SWITCH 
j 
NOT AT END 
j 
F'v-^t'rp 
D'v'sr-n 
- - ' ^ o ^ . ^ >n n,-^.^ 
~ , „ , *
n
t
r
c
r ,
y , 
{ 
I 
| 
END-READ 
j 
END-PERFORM. 
I 
(b) False Condition Branch with In-iine Perioral 

READ 
The NOT AT END clause specifies an action for the false branch of a conditional 
statement; it is c o m m o n l y used is in conjunction with a scope terminator and an in­
line perform to eliminate the priming read, as s h o w n in Figure 9.2. 
The choice between the priming read in Figure 9.2a and the equivalent logic 
in Figure 9.2b is one of personal preference. T h e earlier listings (e.g., the tuition 
billing program in Chapter 5) used the priming read because it w a s required in 
COBOL-74 as the earlier compiler had neither the false-condition branch nor the 
in-line perform. M a n y programmers are, in fact, so accustomed to the priming read 
that they continue to use it even though it is n o longer necessary. W e prefer the in­
line perform and false-condition branch, but both techniques are equally acceptable. 
The READ INTO phrase causes the input record to be stored in two places: in the 
I/O area of the designated file and in the identifier name specified in the I N T O 
phrase in Working-Storage. The statement is illustrated in Figure 9.3, where the 
input data are available in both E M P L O Y E E - R E C O R D and W S - E M P L O Y E E - R E C O R D . 
READ INTO is equivalent to the combination of a READ statement and a MOVE 
statement as shown: 
READ EMPLOYEE-FILE 
AT END 
MOVE 'NO' TO DATA-REMAINS-SWITCH 
NOT AT END 
.3 
The READ INTO Statement 
FD EMPLOYEE-FILE 
DATA RECORD IS EMPLOYEE-RECORD. 
01 EMPLOYEE-RECORD 
PIC X(60). 
WORKING-STORAGE SECTION. 
01 FILLER 
PIC X(14) 
VALUE 'WS BEGINS HERE' 
01 WS-EMPLOYEE-RECORD. 
05 EMP-NAME 
PIC X(25). 
PROCEDURE DIVISION. 
READ EMPLOYEE-FILE INTO WS-EMPLOYEE-RECORD 
AT END 
MOVE 'NO' TO DATA-REMAINS-SWITCH 
NOT AT END 
PERFORM PROCESS-THIS-RECORD 
END-READ. 

C
h
a
p
t
e
r 
9 
More 
About 
the 
Procedure 
Division 
PERFORM PROCESS-THIS-RECORD 
r u n n r- A n 
MOVE EMPLOYEE-RECORD TO WS-EMPLOYEE-RECORD. 
The advantage of the R E A D I N T O statement is in debugging. If a program 
ends prematurely, the first task is to identify the record being processed at the 
instant the problem occurred. T h e F D area is difficult to find, a n d identification of 
the specific logical record is further complicated by considerations of blocking. 
Working-Storage, however, is easy to find because of the literal W S B E G I N S H E R E . 
T h e technique is not sophisticated, but it does work. O n c e Working-Storage is 
found, you can identify the record in question as well as the values of all other data 
n a m e s defined in Working-Storage. 
The WRITE FROM statement is analogous to R E A D I N T O in that it combines the 
effects of a M O V E and a W R I T E into a single statement. The general format of the 
W R I T E statement is: 
WRITE record-name [FROM i d e n t i f i e r - ll 
[BEFORE] 
, 
, a
d
v
a
n
c
i
n
g 4 
[AFTER J 
[identifier-2 
[integer 
[mnemonic-name) 
Ipaqf 
I 
LINE 
LINES 
A single W R I T E F R O M statement, for example, 
WRITE PRINT-LINE FROM HEADING-LINE 
AFTER ADVANCING PAGE. 
is equivalent to the combination of a M O V E a n d a W R I T E statement: 
MOVE HEADING-LINE TO PRINT-LINE. 
WRITE PRINT-LINE 
AFTER ADVANCING PAGE. 
W R I T E F R O M can be used throughout a program to write heading, detail, and total 
lines. 
The I N I T I A L I Z E statement sets multiple data n a m e s to initial values in a single 
statement. Consider: 
INITIALIZE [identifier-l] 
ALPHABETIC 
REPLACING 
ALPHANUMERIC 
NUMERIC 
ALPHANUMERIC-EDITED 
NUMERIC-EDITED 
DATA BY identifier-2 
1iteral- 1 

The brackets indicate that all parameters are optional; that is, INITIALIZE in a n d of 
itself is a valid statement that initializes all numeric items in a program to zeros, and 
all nonnumeric items to spaces. Y o u can also restrict the INITIALIZE statement to 
one (data n a m e or more,) initialize only specific categories of data names, and/or 
initialize to values other than zeros or spaces. Thus given the C O B O L fragment: 
01 
GROUP-ITEM. 
05 
NUMERIC-FIELD-1 
PIC 9 ( 4 ) . 
05 
NUMERIC-FIELD-2 
PIC 9 ( 4 ) . 
05 
ALPHANUMERIC-FIELD-1 
PIC X ( 1 5 ) . 
05 
ALPHANUMERIC-FIELD-2 
PIC X ( 2 0 ) . 
The statement INITIALIZE G R O U P - I T E M is equivalent to: 
MOVE ZEROS TO NUMERIC-FIELD-1. 
MOVE ZEROS TO NUMERIC-FIELD-2. 
MOVE SPACES TO ALPHANUMERIC-FIELD-1. 
MOVE SPACES TO ALPHANUMERIC-FIELD-2. 
In similar fashion, INITIALIZE G R O U P - I T E M R E P L A C I N G N U M E R I C B Y Z E R O is 
equivalent to: 
MOVE ZEROS TO NUMERIC-FIELD-1. 
MOVE ZEROS TO NUMERIC-FIELD-2. 
A n d finally, INITIALIZE G R O U P - I T E M R E P L A C I N G A L P H A N U M E R I C B Y S P A C E S is 
equivalent to: 
MOVE SPACES TO ALPHANUMERIC-FIELD-1. 
MOVE SPACES TO ALPHANUMERIC-FIELD-2. 
It is often necessary to operate o n individual characters within a field, w h e n the 
field is alphanumeric. Operations of this type are called string processing operations, 
and are accomplished with the INSPECT, STRING, and U N S T R I N G statements in 
C O B O L . Each of these statements is discussed in detail. 
The I N S P E C T statement is a convenient w a y to replace one character (or character 
string) with another. Consider: 
INSPECT i d e n t i f i e r - 1 REPLACING 
CHARACTERS BY 
i d e n t i f i e r - 2 
ALL 
LEADING 
FIRST 
1 i teral-1 
j i d e n t i f i e r - 4 
i1i teral- 3 
BY 
[BEFORE 
i d e n t i f i e r - 3 
} INITIAL [ 
AFTER 
literal-2 
i d e n t i f i e r - 5 
1 i t e r a l - 4 
BEFORE 
i d e n t i f i e r - 6 
\ 
\ INITIAL 
[AFTER J 
[ l i t e r a l - 5 
The I N S P E C T statement can be used with the editing characters of Chapter 7 
as illustrated in Figure 9.4. Assume, for example, that social security n u m b e r is 
stored as a nine-position field (with no hyphens) in the input record, but is to 
appear with hyphens in the printed report. T h e M O V E statement transfers the 
incoming social security n u m b e r to a n 11-position field containing two blanks 

Chapter 
9 — 
More 
About 
the 
Procedure 
Division 
(denoted by B in the P I C T U R E clause). T h e I N S P E C T statement replaces every 
occurrence of a blank in S O C - S E C - N U M - O U T by the desired hyphen. 
Another frequent use of the I N S P E C T statement is the elimination of leading 
blanks in numeric fields. (Numeric fields in C O B O L should not contain anything 
other than the digits 0 to 9 a n d a sign over the rightmost (low-order) position.) 
Leading blanks can be replaced with zeros as follows: 
INSPECT FIELD-WITH-BLANKS REPLACING LEADING ' ' BY '0'. 
The S T R I N G statement joins (concatenates) one or m o r e fields and/or one or more 
literals into a single field. Thus a S T R I N G statement has the s a m e effect as a series of 
M O V E statements, except that the destination fields are one a n d the same. A n 
abbreviated form of the C O B O L notation for the S T R I N G follows: 
STRING 
identi fier-1 
literal-1 
identifier-2 
literal-2 
DELIMITED BY 
identifier-3 
1iteral-3 
SIZE 
INTO identifier-4 [WITH POINTER identifier-5] 
[END-STRING] 
The above notation can be simplified, for our discussion, in the following manner: 
STRING sending item INTO receiving field 
A sending item m a y be either an identifier or a literal. Each sending item must be 
accompanied by a delimiting clause, which indicates w h e n to stop moving characters 
from the sending field. The delimiter can take one of three forms: 
1. A n identifier n a m e that contains the delimiting character(s), 
2. A figurative literal or constant whose value is the delimiting character(s), or 
3. SIZE, which transfers the entire contents of the sending item. 
figure 9.4 
The INSPECT Statement 
01 RECORD-IN. 
j 
05 SOC-SEC-NUM 
PIC 9(9). 
j 
01 PRINT-LINE. 
05 S0C-SEC-NUM-0UT 
PIC 999B99B9999. 
i 
| 
PROCEDURE DIVISION. 
| 
I 
[ 
MOVE SOC-SEC-NUM TO SOC-SEC-NUM-OUT. 
j 
I 
INSPECT SOC-SEC-NUM-OUT REPLACING ALL '
 1 BY 
| 

tring 
Processing 
The delimiting character(s) itself is not transferred. Figure 9.5 contains an 
example of the S T R I N G statement in which the components of an individual's 
n a m e are stored separately, then put together to form a single character string. The 
application is not unusual in that a program often requires a person's n a m e in two 
formats. It is easy, for example, to visualize the n a m e (John H. Smith) as a single 
entity as it might appear o n an address label. Y o u would not, however, want to store 
the n a m e as a single field as that would preclude the ability to obtain a n alphabetical 
Figure 9,S 
The STRING Statement 
~
~
—
—
—
—
—
—
— 
- 
— 
— 
05 NAME-IN-PIECES. 
1 
10 LAST-NAME 
PIC X(16) 
[ 
10 FIRST-NAME 
PIC X(10) 
j 
10 MIDOLE-INTITIAL 
PIC X. 
05 ENTIRE-NAME 
PIC X(29) 
(a) Working-Storage holding Areas 
MOVE SPACES TO ENTIRE-NAME. 
STRING FIRST-NAME DELIMITED BY SPACE 
'
 1 DELIMITED BY SIZE 
MIDDLE-INITIAL DELIMITED BY SPACE 
' ' DELIMITED BY SIZE 
LAST-NAME DELIMITED BY SPACE 
INTO ENTIRE-NAME 
(b) STRING Statement 
LAST-NAME 
S I M 
I I T I H 
MIDDLE-INITIAL 
j H 
FIRST-NAME 
ENTIRE-NAME 
Ni 
(1) ENTIRE-NAME j j 
(2) ENTIRE-NAME 
(3) ENTIRE-NAME 
(4) ENTIRE-NAME 
(5) ENTIRE-NAME 
N I B 
OIH 
H I N Bf i H 
(c) Sequence of Transfer 

Chapter 
9 — 
More 
A bout 
the 
Pi oc edure 
Division 
list o n last n a m e ; that is you must have access to last n a m e as a separate entity, in 
order to alphabetize a list. (See problem 3.) 
The Data Division entries in Figure 9.5a define N A M E - I N - P I E C E S to hold the 
individual fields, and E N T I R E - N A M E to hold the concatenated result. Five distinct 
steps are required to string the individual fields together to form a single n a m e : 
1. M o v e F I R S T - N A M E to E N T I R E - N A M E . 
2. M o v e a space to E N T I R E - N A M E after the first n a m e . 
3. M o v e MIDDLE-INITIAL to E N T I R E - N A M E after the space. 
4. M o v e a space to E N T I R E - N A M E after the initial. 
5. M o v e L A S T - N A M E to E N T I R E - N A M E after the second space. 
The S T R I N G statement in Figure 9.5b accomplishes all five tasks and is illustrated in 
Figure 9.5c. T h e S T R I N G statement executes as follows: 
1. T h e characters in the F I R S T - N A M E field are m o v e d (from left to right) to 
E N T I R E - N A M E until a space is encountered (the delimiter), or the entire 
contents of F I R S T - N A M E are transferred. 
2. The literal ' ' (delimiter is SIZE) is m o v e d to the position following the last 
character of F I R S T - N A M E . 
3. T h e MIDDLE-INITIAL is m o v e d . 
4. T h e literal ' ' (delimiter is SIZE) is m o v e d to the position following the 
MIDDLE-INITIAL. 
5. Finally, each character in L A S T - N A M E is m o v e d until either a space is 
encountered (the delimiter), or the entire field is transferred. 
The U N S T R I N G statement breaks a concatenated field into its components and is 
the opposite of the S T R I N G statement. A n abbreviated form of the C O B O L notation 
for the U N S T R I N G follows: 
identi fier- 3l 
literal-2 
J 
INTO identifier-4 
[END-UNSTRING] 
W e reverse the previous example and divide E N T I R E - N A M E into its three 
components, F I R S T - N A M E , MIDDLE-INITIAL, a n d L A S T - N A M E , as s h o w n in 
Figure 9.6. T h e U N S T R I N G statement operates from left to right o n E N T I R E - N A M E , 
moving characters into F I R S T - N A M E until a space is encountered, then into 
MIDDLE-INITIAL, a n d finally into L A S T - N A M E . 
identifier-2 
UNSTRING identifier-1 |DELIMITED BY 
1iteral-1 
Reference modification 
enables you to address a character string that w a s not 
explicitly defined—that is, a character string within an existing data n a m e . This is 
done by specifying the leftmost (starting) position of the string within the data 
n a m e and the length of the string, separating the parameters by a colon. T h e format 
for reference modification is s h o w n below and is illustrated in Figure 9.7. 

String 
Processing 
The UNSTRING Statement 
05 NAME-IN-PIECES. 
10 LAST-NAME 
PIC X(16). 
10 FIRST-NAME 
PIC X(10). 
10 MIDDLE-INTITIAL 
PIC X. 
05 ENTIRE-NAME 
PIC X(31). 
MOVE SPACES TO NAME-IN-PIECES. 
UNSTRING ENTIRE-NAME DELIMITED BY ' ' 
INTO FIRST-NAME MIDDLE-INITIAL LAST-NAME. 
FIRST-NAME 
MIDDLE-INITIAL 
LAST-NAME 
(1) ENTIRE NAME 
J 
0 H N » H B 
S M 
1 T H 
J 
0 H N 16 H » 
S M 
1 T H 
(1) ENTIRE NAME 
J 0 H|N 
H 
s 
M I T H 
fC-r-r-r-, 
J 
H 
J O H N 
H 
S M I |T 
I 
H 
FIRST-NAME 
MIDDLE-NAME 
LAST-NAME 
data-name (leftmost position: [length]) 
In Figure 9.7 TELEPHONE-NUMBER is defined as a 10 position field within an 
incoming record. Portions of this field are then m o v e d to EDITED- PH O N E-N UM B ER 
through reference modification; for example, TELEPHONE-NUMBER (4:3) refers to 
positions 4, 5, and 6 within TELEPHONE-NUMBER. The specification of length is 
optional, and its o m i s s i o n defaults to the e n d of the data name; i.e., TELEPHONE-
NUMBER (7:4) and TELEPHONE-NUMBER (7:) are equivalent. 

Gfcspter 
S — 
More About 
the 
Procedure 
Division 
:iam& 
$.7 
Reference Modification 
01 
INCOMING-RECORD. 
05 TELEPHONE-NUMBER 
PIC X(10), 
01 
EDITED-PHONE-NUMBER. 
05 FILLER 
05 AREA-CODE 
05 FILLER 
05 
EXCHANGE 
05 FILLER 
05 DIGITS 
PIC X 
VALUE '(', 
PIC X(3). 
PIC X 
VALUE ')', 
PIC X(3). 
PIC X 
VALUE 
PIC X(4). 
MOVE TELEPHONE-NUMBER (1:3) TO AREA-CODE. 
MOVE TELEPHONE-NUMBER (4:3) TO EXCHANGE. 
MOVE TELEPHONE-NUMBER (7:4) TO DIGITS. 
The ACCEPT statement w a s introduced in Chapter 8 to obtain t h e date of execution 
and i m p l e m e n t various forms of date validation. The statement is expanded in this 
chapter to include the day of the w e e k as well as the date. Consider: 
ACCEPT identifier-1 FROM < 
f DAY-OF-WEEK" 
DATE  
DAY  
TIME 
The DAY-OF-WEEK clause returns a n integer from 1 to 7 representing the day 
according to the following table: 
I N T E G E R 
D A Y 
1 
Monday 
2 
Tuesday 
3 
Wednesday 
4 
Thursday 
5 
Friday 
6 
Saturday 
7 
Sunday 
The ACCEPT statement is illustrated in Figure 9.8. T h e user defines a data n a m e in 
Working-Storage—for example, DAY-CODE-VALUE in Figure 9.8a—then accepts 

The ACCEPT Statement 
01 DAY-CODE-VALUE 
PIC 9. 
01 TODAYS-DATE. 
05 TODAYS-YEAR 
05 TODAYS-MONTH 
05 TODAYS-DAY 
PIC 99. 
PIC 99. 
PIC 99. 
01 HDG-LINE. 
05 HDG-DAY-OF-WEEK 
05 FILLER 
05 HDG-DATE 
PIC X(9). 
PIC XX 
PIC X(8). 
VALUE 
ACCEPT DAY-CODE-VALUE FROM DAY-OF-WEEK. 
EVALUATE DAY-CODE-VALUE 
WHEN 1 MOVE ' 
Monday' TO HDG- DAY -OF -WEEK 
WHEN 2 MOVE ' Tuesday' TO HDG- DAY -OF--WEEK 
WHEN 3 MOVE 'Wednesday' TO HDG- DAY -OF--WEEK 
WHEN 4 MOVE ' Thursday' TO HDG- DAY -OF--WEEK 
WHEN 5 MOVE ' 
Friday' TO HDG- DAY -OF--WEEK 
WHEN 6 MOVE ' Saturday' TO HDG- DAY -OF- WEEK 
WHEN 7 MOVE ' 
Sunday
1 TO HDG- DAY -OF- WEEK 
END-EVALUATE. 
ACCEPT TODAYS-DATE FROM DATE. 
STRING TODAYS-MONTH '/' TODAYS-DAY '/' TODAYS-YEAR 
DELIMITED BY SIZE INTO HDG-DATE 
END-STRING. 
the value from D A Y - O F - W E E K into that tlata n a m e . T h e subsequent E V A L U A T E 
statement expands the one-position code to a literal day. 
The D A T E and D A Y clauses were described in Chapter 8 and represent the 
date (in the form y y m m d d ) a n d Julian date (in the form yyddd), respectively. T h e 
D A T E clause is illustrated in Figure 9.8c for purposes of review. 
Most programs require that the output contain s o m e of the input, for example, 
n a m e and social security number. C O B O L permits the definition of duplicate 
data 
names in the Data Division, provided all Procedure Division references to duplicate 
n a m e s use the appropriate qualification. W e prefer not to use duplicate n a m e s 
because they violate the prefix coding standard discussed in Chapter 7, but they are 
used in older programs, and are covered here for completeness. 

Chapter 
9 -
More 
About 
the 
Procedure 
Division 
The Data Division entries in Figure 9.9a contain several data n a m e s that appear in 
both S T U D E N T - R E C O R D a n d PRINT-LINE—for example, C R E D I T S — a n d any 
Procedure Division reference to C R E D I T S will produce a compiler error indicating a 
nonunique 
data name. This is because the compiler cannot determine which 
C R E D I T S (in S T U D E N T - R E C O R D or PRINT-LINE) is referenced. O n e solution is 
Figure 9.9 
Duplicate Data Names 
01 
STUDENT-RECORD. 
05 STUDENT-NAME 
PIC X(20). 
05 SOCIAL-SECURITY-NUM 
PIC 9(9). 
05 STUDENT-ADDRESS. 
10 STREET 
PIC X(15). 
10 CITY-STATE 
PIC X(15). 
05 ZIP-CODE 
PIC X(5). 
05 CREDITS 
PIC 9(3). 
05 MAJOR 
PIC X(10). 
05 FILLER 
PIC X(3). 
PRINT-LINE. 
10 STUDENT-NAME 
PIC X(20). 
10 FILLER 
PIC XX. 
10 CREDITS 
PIC ZZ9. 
10 FILLER 
PIC XX. 
10 TUITION 
PIC $$,$$9.99. 
10 FILLER 
PIC XX. 
10 STUDENT-ADDRESS. 
15 STREET 
PIC X(15). 
15 CITY-STATE 
PIC X(15). 
15 ZIP-CODE 
PIC X(5). 
10 FILLER 
PIC XX. 
10 SOCIAL-SECURITY-NUM 
PIC 999B99B9999 
10 FILLER 
PIC X(47). 
| 
(a) Duplicate Data Marries 
f 
I 
MOVE CORRESPONDING STUDENT-RECORD TO PRINT-LINE. 
MOVE STUDENT-NAME OF STUDENT-RECORD 
TO STUDENT-NAME OF PRINT-LINE. 
MOVE SOCIAL-SECURITY-NUM OF STUDENT-RECORD 
TO SOCIAL-SECURITY-NUM OF PRINT-LINE. 
| 
MOVE STREET OF STUDENT-RECORD 
I 
TO STREET OF PRINT-LINE. 
MOVE CITY-STATE OF STUDENT-RECORD 
TO CITY-STATE OF PRINT-LINE. 
MOVE CREDITS OF STUDENT-RECORD 
TO CREDITS OF PRINT-LINE. 

to qualify the data n a m e , using O F or IN, and refer to C R E D I T S O F S T U D E N T -
IIEUJUIJ Ul CftDUlia ii\ 3 1 
U 1 J D I N 
1 -ftEUUttU. 
Qualification is sometimes necessary over several levels. For example, the use 
of S T R E E T O F S T U D E N T - A D D R E S S in the statement below is still ambiguous. 
MOVE S T R E E T O F STUDENT-ADDRESS TO OUTPUT-AREA. 
The qualifier S T U D E N T - A D D R E S S appears in both 01 records and thus the ambiguity 
was not resolved. T w o levels of qualification are necessary to m a k e the intent clear: 
MOVE S T R E E T O F STUDENT-ADDRESS O F STUDENT-RECORD TO OUTPUT-AREA. 
Alternatively, you could skip the intermediate level and rewrite the statement as: 
MOVE STREET IN STUDENT-RECORD TO OUTPUT-AREA. 
O F and IN can be used interchangeably. Duplicate data n a m e s offer the 
advantage of not having to invent different n a m e s for the same item—for example, 
an employee n a m e appearing in both an input record and output report. They also 
permit use of the M O W C O R R E S P O N D I N G statement which is nor r e c o m m e n d e d 
by the authors, but which is covered for completeness. 
The M O V E C O R R E S P O N D I N G statement in Figure 9.9b is the equivalent of 
the individual M O V E statements in Figure 9.9c; that is, the single M O V E 
C O R R E S P O N D I N G statement has the same effect as the five individual M O V E 
statements. The C O R R E S P O N D I N G option searches every data n a m e in S T U D E N T -
R E C O R D for a matching (duplicate) data n a m e in PRINT-LINE, then generates an 
individual M O V E statement whenever a match is found. It is very convenient because 
you have to code only the single M O V E C O R R E S P O N D I N G statement. 
The level numbers of the duplicate data n a m e s in Figure 9.9a do not have to 
match for a m o v e to be generated—only the data n a m e s must be the same. The 
order of the data n a m e s in the 01 records is also immaterial; for example, SOC1AL-
S E C U R I T Y - N U M is the second field in S T U D E N T - R E C O R D , and the next to last in 
PRINT-LINE. T w o other conditions must be satisfied, however, in order for a m o v e 
to be generated: 
1. At least one item in each pair of C O R R E S P O N D I N G items m u s t be an 
elementary item; that is, S T U D E N T - A D D R E S S of S T U D E N T - R E C O R D is not 
m o v e d to S T U D E N T - A D D R E S S of PRINT-LINE. (The elementary items S T R E E T 
and CITY-STATE are m o v e d instead.) 
2. Corresponding elementary items are m o v e d only if they have the same n a m e 
and qualification, up to but not including identifier-1 and identifier-2. ZIP-
C O D E , for example, belongs directly to S T U D E N T - R E C O R D , but has an 
intermediate qualifier ( S T U D E N T - A D D R E S S ) in PRINT-LINE, a n d thus ZIP-
C O D E is not m o v e d . 

Chapter 
9 -
More 
About 
the 
Procedure 
Division 
Ios v'.-cv t 
Our fundamental approach throughout the text is to learn by doing. To that e n d w e 
111 i t Q> I r ' -Q £2 ;.-a |f| 
have developed a complete C O B O L program that incorporates the various statements 
presented in the chapter. Specifications follow in the usual format. 
P
R
O
G
R
A
M
M
I
N
G 
S P E C I F I C A T I O N S 
P r o g r a m 
N a m e : 
Car Billing Program 
Narrative: 
This program processes the file of valid car rental records that was created in the 
validation program of Chapter 8 to produce a report reflecting the amounts owed by 
individual customers. 
Input F i l e ( s ) : 
RENTAL-FILE 
01 RENTAL-RECORD-IN. 
05 REN-CONTRACT-NO 
PIC 9(6). 
05 REN-NAME. 
10 REN-LAST-NAME 
PIC X(15). 
10 REN-FIRST-NAME 
PIC X(10). 
10 REN-INITIAL 
PIC X. 
05 REN-RETURNED-DATE. 
10 REN-RETURNED-YEAR 
PIC 9(2). 
10 REN-RETURNED-MONTH 
PIC 9(2). 
10 REN-RETuRNED-DAY 
PIC 9(2). 
05 REN-CAR-TYPE 
PIC X. 
05 REN-DAYS-RENTED 
PIC 99. 
05 REN-MILEAGE. 
10 REN-MILES-IN 
PIC 9(6). 
10 REN-MILES-OUT 
PIC 9(6). 
10 REN-MILEAGE-RATE 
PIC V99. 
05 REN-INSURANCE 
PIC X. 
T e s t D a t a : 
The input file used by this program was created by the data validation program of 
Chapter 8 and was shown earlier as Figure 8.10c. The data are repeated below for 
convenience: 
999777ELSINOR 
TERRY 
R921126F0500168000159005N 
987654SMITH 
PAUL 
G921213M0300510000500502Y 
354679KERBEL 
NORMAN 
X930331E1000340000324300Y 
264805CLARK 
JANE 
S921101F0700561500551200N 
233432BEINH0RN 
CATHY 
B921122M0200123400113402Y 
556564HUMMER 
MARG0 
R920815C0800234500123403Y 
677844MCD0NALD 
JAMES 
930123C0500423500402300N 
886222V0GEL 
JANICE 
D930518F1200634500612302Y 
008632T0WER 
DARREN 
R930429L0900700200689300N 
R e p o r t 
L a y o u t : 
P r o c e s s i n g 
R e q u i r e m e n t s : 
See Figure 9.10. 
1. Read the file of valid car rental records that was produced by the editing program of 
Chapter 8. No further validation is required in this program. 

The 
Car 
Billing 
Program 
2. Calculate the amount due for each incoming record as a function of car type, days 
rented, miles driven, mileage rate, and insurance. 
a. The mileage rate is different for each customer and appears as a field in 
the incoming record; the mileage total is the mileage rate times the number of 
miles driven. 
b. The daily rate is a function of the type of car rented. Economy cars cost $15 a 
day, compact cars $20 a day, mid-size cars $24 a day, full-size cars $28 a day, 
and luxury cars $35 a day. The daily total is the daily rate times the number of 
days rented. 
c. Insurance is optional and is indicated by a T in the appropriate position in the 
incoming record. Insurance is $10.50 a day (for customers who choose it), regardless 
of the type of car rented. 
d. A customer's total bill consists of the mileage total, daily total, and insurance total 
as described in parts (a), (b), and (c). 
3. A heading is required at the top of every page, as shown in Figure 9.10. Detail lines 
are to be double-spaced and limited to five per page. 
4. A total line for all computed fields is required at the end of the report. 
Car Rental Report 
Mavis Car Rental Report 
Contract 
Number 
Name 
5-565-64 
HUMMER, MARGO R. 
6-778-44 
MCDONALD, JAMES 
8-862-22 
VOGEL, JANICE D. 
Saturday - 07/03/93 
Date 
Car Days 
Rental 
Miles Mileage Mileage Insurance 
Total 
Returned Type Rented 
Total 
Driven 
Rate 
Total 
08/15/92 
C 
8 
01/23/93 
C 
5 
05/18/93 
E 
12 
160.00 
1,111 
.03 
100.00 
212 
.00 
336.00 
222 
.02 
Mavis Car Rental Report 
Saturday - 07/03/93 
Contract 
Number 
Name 
9-997-77 
ELSIN0R, TERRY R. 
9-876-54 
SMITH, PAUL G. 
3-546-79 
KERBEL, NORMAN X. 
2-648-05 
CLARK, JANE S. 
2-334-32 
BEINH0RN, CATHY B. 
Date 
Car Days 
Returned Type Rented 
11/26/92 
F 
5 
12/13/92 
M 
3 
03/31/93 
E 
10 
11/01/92 
F 
7 
11/22/92 
M 
2 
Rental 
Miles Mileage Mileage Insurance 
Total 
Driven 
Rate 
Total 
Total 
140.00 
72.00 
90 
.05 
95 
.02 
150.00 
157 
.00 
196.00 
48.00 
103 
.00 
100 
.02 
4.50 
1.90 
31.50 
0.00 
105.00 
0.00 
2.00 
21.00 
33.33 
0.00 
4.44 
126.G 
Page 1 
Amount 
Due 
144.50 
105.40 
255.00 
196.00 
71.00 
.00 
Page 2 
Amount 
Due 
277.33 
100.00 
466.44 
315.00 
$1,930.67 

Chapter 
9 
More 
About 
the 
Procedure 
Division 
Program Design 
.. 
The car billing program has two objectives: to complete the two-program sequence 
begun in Chapter 8 and to illustrate the Procedure Division statements presented in 
this chapter. Both objectives impact the design of the pseudocode a n d associated 
hierarchy chart. 
T h e hierarchy chart in Figure 9.11 is written without the priming read of 
earlier programs. The highest-level module, PREPARE-RENTAL-REPORT, has three 
subordinates: G E T - T O D A Y S - D A T E , P R O C E S S - R E N T A L - R E C O R D S , a n d W R I T E -
R E N T A L - T O T A L S . P R O C E S S - R E N T A L - R E C O R D S in turn is the driving module of 
the program a n d performs four lower-level paragraphs: C O M P U T E - I N D T v T D U A L -
BILL, W R I T E - H E A D I N G - L I N E S , WRITE-DETAIL-LINE, and I N C R E M E N T - R E N T A L -
T O T A L S . C O M P U T E - I N D I V I D U A L - B I L L has three subordinate modules, C O M P U T E -
M I L E A G E - T O T A L , C O M P U T E - D A I L Y - T O T A L , a n d C O M P U T E - I N S U R A N C E - T O T A L 
to compute the components of a customer's bill. 
The paragraph W R I T E - H E A D I N G - L I N E S is subordinate to P R O C E S S - R E N T A L -
R E C O R D S , which differs from an earlier hierarchy chart (page 119) that placed the 
heading routine o n a higher level. T h e earlier structure, however, produced only a 
single heading at the start of processing, whereas the current requirement is to 
produce a heading at the top of every page; hence the heading routine will be 
executed several times a n d is subordinate to processing a record. 
T h e pseudocode in Figure 9.12 takes advantage of the in-line perforin a n d 
false-condition branch to eliminate the priming read used in earlier examples. The 
pseudocode also implements the required page heading routine by initializing the 
line counter to six a n d testing its value prior to writing each detail line. The heading 
9.11 
Hierarchy Chart 
PREPARE 
RENTAL 
REPORT 
GET 
TODAYS 
DATE 
PROCESS 
RENTAL 
RECORDS 
WRITE 
RENTAL 
TOTALS 
COMPUTE 
INDIVIDUAL 
BILL 
WRITE 
HEADING 
LINES 
WRITE 
DETAIL 
LINE 
INCREMENT 
RENTAL 
TOTALS 
COMPUTE 
MILEAGE 
TOTAL 
COMPUTE 
DAILY 
TOTAL 
COMPUTE 
INSURANCE 
TOTAL 

The 
Car 
Billing 
Program 
\. i 
Pseudocode 
i 
Open Files 
I 
| 
Get today's date 
[ 
— DO WHILE data remains 
I 
| 
| 
Read Rental File 
| 
| 
AT END 
I 
j 
Indicate no more data 
| 
I 
NOT AT END 
; 
| 
i 
Initialize individual calculations 
j 
1 
j 
Compute miles driven = miles in - miles out 
j 
j 
I 
r
D
O CASE 
I 
Car Type E - Move economy rate to mileage rate 
[ 
Car Type C - Move compact rate to mileage rate 
| 
| 
! 
Car Type M - Move midsize to mileage rate 
! 
| 
Car Type F - Move full size rate to mileage rate 
! 
j 
Car Type L - Move luxury rate to mileage rate 
j 
I
 
1 
- END CASE 
I 
j 
j 
| 
Compute mileage total = miles driven * mileage rate 
j 
j 
Compute daily total = days rented * daily rate 
5 
i 
r~~ 
IF insurance taken 
|
| 
| 
j 
Compute insurance = insurance rate * days rented 
* 
| 
| 
L - E N D - I F 
] 
Compute total bill = mileage amount + daily amount + insurance 
j 
- IF line count greater than 5 
j 
Initialize line count to 1 
| 
Increment page count 
Write heading 1ines 
> 
END-IF 
Write detail line 
Add 1 to line count 
i 
Increment rental totals 
END READ 
L - E N D D O 
j 
Write rental totals 
I 
Close files 
j 
I 
Stop run 
j 
I 
I 
I 
_ _ 
„ 
__ _ 
,, 
,,..J 
will be written prior to the first detail record because it (the line counter) is greater 
than five (the desired n u m b e r of lines per page). The line counter is then reset to 
one so that the heading will be produced for every fifth record. 
The completed program in Figure 9.13 illustrates m a n y of the statements presented 
in the chapter. T h e logic of the program is straightforward a n d parallels the 
pseudocode just discussed. Several features of the program merit attention: 
1. T h e combination of the in-line perform and false-condition branch (lines 
209-216) to eliminate the priming read used in all previous programs. 

Chapter 
9 
More 
About 
the 
Procedure 
Division 
Figure 9.13 
The Completed Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
CARSRPT. 
3 
A 
AUTHOR. 
CVV. 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT RENTAL-FILE 
ASSIGN TO 'A:\CHAPTR09\VALCARS. 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD RENTAL-FILE 
16 
RECORD CONTAINS 56 CHARACTERS. 
17 
01 
RENTAL-RECORD 
PIC X(56). 
18 
i n 
x y 
FD PRINT-FILE 
20 
RECORD CONTAINS 132 CHARACTERS. 
21 
00 
01 PRINT-LINE 
PIC X(132). 
LL 
23 
WORKING-STORAGE SECTION. 
24 
01 FILLER 
PIC X(14) 
25 
VALUE 'WS BEGINS HERE'. 
26 
27 
01 
RENTAL-RECORD-IN. 
28 
05 
REN-CONTRACT-NO 
PIC 9(6). 
29 
05 REN-NAME. 
30 
10 REN-LAST-NAME 
PIC X(15). 
31 
10 REN-FIRST-NAME 
PIC X(10). 
32 
10 REN-INITIAL 
PIC X. 
33 
05 REN-RETURNED-DATE. 
34 
10 REN-RETURNED-YEAR 
PIC 9(2). 
35 
10 REN-RETURNED-MONTH 
PIC 9(2). 
36 
10 
REN-RETURNED-DAY 
PIC 9(2). 
37 
05 REN-CAR-TYPE 
PIC X. 
38 
05 
REN-DAYS-RENTED 
PIC 99. 
39 
05 REN-MILEAGE. 
40 
10 REN-MILES-IN 
PIC 9(6). 
41 
10 
REN-MILES-OUT 
PIC 9(6). 
42 
10 
REN-MILEAGE-RATE 
PIC V99. 
43 
05 
REN-INSURANCE 
PIC X. 
44 
45 
01 
PROGRAM-SWITCHES. 
46 
05 
DATA-REMAINS-SWITCH 
PIC XX VALUE SPACES. 
47 
05 NAME-POINTER 
PIC 999 VALUE 1. 
48 
49 
01 
PAGE-AND-LINE-COUNTERS. 
50 
i 
05 LINE-COUNT 
PIC 9(2) 
VALUE 6. 

The 
Car 
Billing 
Program 
(continued) 
51 
05 PAGE-COUNT 
PIC 9(2) 
VALUE ZEROS. 
52 
05 LINES-PER-PAGE 
PIC 9(2) 
VALUE 5. 
53 
54 
01 DAILY-RATES. 
.J 
05 
PIC 9(3)V99 VALUE 15. 
56 
05 COMPACT-RATE 
PIC 9(3)V99 VALUE 20. 
57 
05 MID-RATE 
PIC 9(3)V99 VALUE 24. 
58 
05 FULL-RATE 
PIC 9(3)V99 VALUE 28. 
59 
05 LUXURY-RATE 
PIC 9(3)V99 VALUE 35. 
60 
05 INSURANCE-RATE 
PIC 99V99 
VALUE 10.50. 
61 
62 
01 IND -BILL-INFORMATION. 
63 
05 IND-MILES-DRIVEN 
PIC 9(5). 
64 
05 IND-DAILY-RATE 
PIC 9(3)V99. 
65 
05 IND-DAILY-TOTAL 
PIC 9(4)V99. 
66 
05 IND-MILEAGE-TOTAL 
PIC 9(3}V99. 
67 
05 IND-INSURANCE-TOTAL 
PIC 9(3)V99. 
68 
05 IND-AMOUNT-DUE 
PIC 9(4)V99. 
69 
70 
01 TOTALS-FOR-REPORT. 
71 
05 TOTAL-DAYS-RENTED 
PIC 9(4) 
VALUE ZEROES. 
72 
05 TOTAL-DAILY-RENTAL 
PIC 9(6)V99 VALUE ZEROES. 
73 
05 TOTAL-MILES-DRIVEN 
PIC 9(6) 
VALUE ZEROES. 
74 
05 TOTAL-MILEAGE 
PIC 9(4)V99 VALUE ZEROES. 
75 
05 TOTAL-INSURANCE 
PIC 9(4)V99 VALUE ZEROES. 
76 
05 TOTAL-AMOUNT-DUE 
PIC 9(6)V99 VALUE ZEROES. 
77 
78 
01 TODAYS-DATE-AREA. 
79 
05 TODAYS-YEAR 
PIC 99. 
80 
05 TODAYS-MONTH 
PIC 99. 
81 
05 TODAYS-DAY 
PIC 99. 
82 
83 
01 DAY--CODE-VALUE 
PIC 9. 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
01 HEADING-LINE-ONE. 
05 FILLER 
05 FILLER 
VALUE 
05 FILLER 
05 HDG-DAY 
Q5 FILLER 
05 HDG-DATE 
05 FILLER 
05 FILLER 
05 HDG-PAGE-NUMBER 
05 FILLER 
PIC X(20) 
PIC X(25) 
Mavis Car Rental Report' 
PIC X(16) 
PIC X(9). 
PIC X(3) 
PIC X(8). 
PIC X(41) 
PIC X(5) 
PIC Z9. 
PIC X(3) 
VALUE SPACES. 
VALUE SPACES. 
VALUE ' - '. 
VALUE SPACES. 
VALUE 'Page '. 
VALUE SPACES. 
01 
HEADING-LINE-TWO. 
05 FILLER 
05 FILLER 
PIC X(8) VALUE 'Contract' 
PIC X(38) VALUE SPACES. 

Chapter 
9 — 
More 
About 
the 
Procedure 
Division 
'igur® @„13 
(continued) 
101 
05 FILLER 
PIC X(4) VALUE 'Date'. 
102 
05 FILLER 
PIC X(5) VALUE SPACES. 
103 
05 FILLER 
PIC X(3) VALUE 'Car'. 
104 
05 FILLER 
PIC X(3) VALUE SPACES. 
105 
05 FILLER 
PIC X(4) VALUE 'Days'. 
106 
05 FILLER 
PIC X(6) VALUE SPACES. 
107 
05 FILLER 
PIC X(6) VALUE 'Rental'. 
108 
05 FILLER 
PIC X(4) VALUE SPACES. 
109 
05 FILLER 
PIC X(5) VALUE 'Miles'. 
110 
05 FILLER 
PIC X(2) VALUE SPACES. 
111 
05 FILLER 
PIC X(7) VALUE 'Mileage'. 
112 
05 FILLER 
PIC X(2) VALUE SPACES. 
113 
05 FILLER 
PIC X(7) VALUE 'Mileage'. 
114 
05 FILLER 
PIC X(2) VALUE SPACES. 
115 
05 FILLER 
PIC X(9) VALUE 'Insurance'. 
116 
05 FILLER 
PIC X(6) VALUE SPACES. 
117 
05 FILLER 
PIC X(6) VALUE 'Amount'. 
118 
05 FILLER 
PIC X(5) VALUE SPACES. 
119 
120 
01 HEADING-LINE-THREE. 
121 
05 FILLER 
PIC X 
VALUE SPACES. 
122 
05 FILLER 
PIC X(6) VALUE ' Number 
123 
05 FILLER 
PIC X(4) VALUE SPACES. 
124 
05 FILLER 
PIC X(4) VALUE 'Name'. 
125 
05 FILLER 
PIC X(29) VALUE SPACES 
126 
05 FILLER 
PIC X(8) VALUE 'Return 
127 
05 FILLER 
PIC X(2) VALUE SPACES. 
128 
05 FILLER 
PIC X(4) VALUE 'Type'. 
129 
05 FILLER 
PIC X(2) VALUE SPACES. 
130 
05 FILLER 
PIC X(6) VALUE 'Rented 
131 
05 FILLER 
PIC X(6) VALUE SPACES. 
132 
05 FILLER 
PIC X(5) VALUE 'Total' 
133 
05 FILLER 
PIC X(3) VALUE SPACES. 
134 
05 FILLER 
PIC X(6) VALUE 'Driven 
135 
05 FILLER 
PIC X(4) VALUE SPACES. 
136 
05 FILLER 
PIC X(4) VALUE 'Rate'. 
137 
05 FILLER 
PIC X(4) VALUE SPACES. 
138 
05 FILLER 
PIC X(5) VALUE 'Total' 
139 
05 FILLER 
PIC X(6) VALUE SPACES. 
140 
05 FILLER 
PIC X(5) VALUE 'Total' 
141 
05 FILLER 
PIC X(9) VALUE SPACES. 
142 
05 FILLER 
PIC X(3) VALUE 'Due'. 
143 
05 FILLER 
PIC X(6) VALUE SPACES. 
144 
145 
01 DETAIL-LINE. 
le INSPtCT 
146 
[~05 P E T - C O N T R A C T - N O P i £ " 9 B 9 9 9 B 9 9 . \ 
147 
05 FILLER " 
" " " 
~ PIC X(3)" VALUE SPACES. 
148 
05 DET-NAME 
PIC X(30). 
149 
05 FILLER 
PIC X(3) VALUE SPACES. 
150 
05 DET-RETURN-DATE 
PIC X(8). 

The 
Car 
Billing 
Program 
m
m 
(continued) 
151 
05 FILLER 
PIC X(4) VALUE SPACES. 
152 
05 DET-CAR-TYPE 
PIC X. 
153 
05 FILLER 
PIC X(5) VALUE SPACES. 
154 
05 DET-DAYS-RENTED 
PIC Z9. 
155 
05 FILLER 
PIC X(5) VALUE SPACES. 
156 
05 DET-DAILY-TOTAL 
PIC Z,ZZ9. 99. 
157 
05 FILLER 
PIC X(3) VALUE SPACES. 
158 
05 DET-MILES-DRIVEN 
PIC 12,119. 
159 
05 FILLER 
PIC X(5) VALUE SPACES. 
160 
05 DET-MILEAGE-RATE 
PIC .99. 
161 
05 FILLER 
PIC X(5) VALUE SPACES. 
162 
05 DET-MILEAGE-TOTAL 
PIC ZZ9.99. 
163 
05 FILLER 
PIC X(4) VALUE SPACES. 
164 
05 DET-INSURANCE-TOTAL 
PIC ZZ9.99 BLANK WHEN ZERO 
165 
05 FILLER 
PIC X(4) VALUE SPACES. 
166 
05 DET-AMOUNT-DUE 
PIC Z.ZZ9.99. 
167 
05 FILLER 
PIC X(5) VALUE SPACES. 
168 
169 
01 TOTAL-DASH-LINE. 
170 
05 FILLER 
PIC X(59) VALUE SPACES. 
171 
05 FILLER 
PIC X(5) 
VALUE ALL 
172 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
173 
05 FILLER 
PIC X{10) VALUE ALL 
174 
05 FILLER 
PIC XX 
VALUE SPACES. 
175 
05 FILLER 
PIC X(7) 
VALUE ALL 
176 
05 FILLER 
PIC X(ll) VALUE SPACES. 
177 
05 FILLER 
PIC X(8) 
VALUE ALL 
178 
05 FILLER 
PIC XX 
VALUE SPACES. 
179 
05 FILLER 
PIC X(8) 
VALUE ALL 
180 
05 FILLER 
PIC XX 
VALUE SPACES. 
181 
05 FILLER 
PIC X(10) VALUE ALL 
182 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
183 
184 
01 TOTAL-LINE. 
185 
05 FILLER 
PIC XX 
VALUE SPACES. 
186 
05 FILLER 
PIC X(6) 
VALUE 'Totals'. 
187 
05 FILLER 
PIC X(51) VALUE SPACES. 
188 
05 TOT-DAYS-RENTED 
PIC 1,119. 
189 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
190 
05 TOT-DAILY-RENTAL 
PIC $$$$,$ $9.99. 
191 
05 FILLER 
PIC XX 
VALUE SPACES. 
192 
05 TOT-MILES-DRIVEN 
PIC 111,119. 
193 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
194 
05 TOT-MILEAGE 
PIC $$$,$$ 9.99. 
195 
05 FILLER 
PIC X 
VALUE SPACES. 
196 
05 TOT-INSURANCE 
PIC $$,$$9 .99. 
197 
05 FILLER 
PIC X 
VALUE SPACES. 
198 
05 TOT-AMOUNT-DUE 
PIC *t *t *t $ $ 
-4> 4> 4) 4) 9 .p $9.99. 
199 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
200 

Chapter 
9 
More 
About 
the 
Procedure 
Division 
13 
(continued) 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
01 FILLER 
VALUE 'WS ENDS HERE'. 
PROCEDURE DIVISION. 
000-PREPARE-RENTAL-REPORT. 
OPEN INPUT 
RENTAL-FILE 
OUTPUT PRINT-FILE. 
PERFORM 100-GET-TODAYS-DATE. 
PIC X(12) 
PERFORM UNTIL DATA-REMAINS-SWITCH = 'NO' 
j 
READ RENTAL-FILE INTO RENTAL-RECORD-IN 
AT END 
| 
MOVE 'NO' TO DATA-REMAINS-SWITCH I -
NOT AT END 
PERFORM 200-PR0CESS-RENTAL-REC0RDS j 
END-READ 
, END-PERFORM. 
j 
PERFORM 700-WRITE-RENTAL-TOTALS. 
CLOSE RENIAL-FILE 
PRINT-FILE. 
STOP RUN. 
,.- ACCEPT 
100-GET-TODAYS-DATE. 
_ 
j ACTEPT TODAYS -DATE-AREA FROM DATE. 
STRTNG TODAYS-MONTH '/' TODAYS-DAY '/' TODAYS-YEAR 
DELIMITED BY SIZE INTO HDG-DATE 
'END-STRING . 1 
"ACCEPT DAY-CODE-VALUE FROM DAY-OF-WEEK. 
EVALUATE DAY-CODE-VALtiE. 
WHEN 1 MOVE 
WHEN 2 MOVE 
Monda>Vro HDG-DAY 
Tuesday' TO"HOG-DAY 
WHEN 3 MOVE 'Wednesday' TO HDG-TJAY^ 
WHEN 4 MOVE ' Thursday' TO HDG-DAY 
WHEN 5 MOVE ' 
Friday' TO HDG-DAY 
Saturday
1 TO HDG-DAY 
Sunday' TO HDG-DAY 
WHEN 
WHEN 
6 MOVE 
_ 
7 MOVE 
END-EVALIJATET]---
200-PROCESS-RENTAL-RECORDS. 
PERFORM 300-COMPUTE-IND-BIji^-
IF LINE-COUNT > LINES-PER-PAGE 
PERFORM 400-WRITE-HEADING-LINES 
jjEND-IFTk'^ 
PERFORM 500-WRITE-DETAIL-LINE. 
PERFORM 600-INCREMENT-TOTALS. 
300-COMPUTE-IND-BILL. 
INITIALIZE IND-BILL-INFORMATION. 
PERFORM 320-COMPUTE-MILEAGE-TOTAL. 
PERFORM 340-COMPUTE-DAILY-TOTAL. 
PERFORM 360-COMPUTE-INSURANCE-TOTAL. 

The 
Car 
Billing 
Program 
(continued) 
251 
C O M P U T E IND-AMOUNT-DUE R O U N D E D 
2 5 2 
= IND-MILEAGE-TOTAL + IND-DAILY-TOTAL 
253 
+ IND-INSURANCE-TOTAL 
254 
S I Z E ERROR DISPLAY 'SIZE ERROR O N AMOUNT DUE FOR ' 
255 
[ 
REN-CONTRACT-NO 
 
256 
E N D - C O M P U T E . " 
~ 
257 
258 
320-COMPUTE-MILEAGE-TOTAL. 
259 
C O M P U T E IND-MILES-DRIVEN 
260 
= R E N - M I L E S - I N - REN-MILES-OUT 
261 
END-COMPUTE. 
262 
C O M P U T E IND-MILEAGE-TOTAL R O U N D E D 
263 
= IND-MILES-DRIVEN * REN-MILEAGE-RATE 
264 
S I Z E ERROR 
265 
DISPLAY 'COMPUTED B I L L EXCESSIVELY LARGE' 
266 
END-COMPUTE. 
267 
268 
340-COMPUTE-DAILY-TOTAL. 
269 
! EVA1^AT¥TE¥^CAR
:TYPE 
270 
' 
W H E N 'E' MOVE ECONOMY-RATE T O IND-DAILY-RATE 
j 
271 
! 
W H E N ' C MOVE COMPACT-RATE T O IND-DAILY-RATE 
j 
272 
i 
W H E N 'M' M O V E M I D - R A T E T O IND-DAILY-RATE 
273 
W H E N 'F' M O V E FULL-RATE T O IND-DAILY-RATE 
\'~ 
274 
W H E N 'L' MOVE LUXURY-RATE T O IND-DAILY-RATE 
2 7 5 
W H E N O T H E R MOVE ZEROES T O IND-DAILY-RATE 
276 
j E N D - E V A L U A T E . 
_ 
277 
^ M U L T I P L Y I N D - D A I L Y - R A T E BY REN-DAY S-R EN T E D 
278 
GIVING IND-DAILY-TOTAL 
279 
S I Z E ERROR DISPLAY 'SIZE ERROR O N RENTAL TOTAL' 
280 
END-MULTIPLY. 
281 
282 
360-C0MPUTE-INSURANCE-TOTAL. _ 
_ 
_ 
283 
nF ~REN-INSURANCE = ' Y' 
~
" 
284 
i 
MULTIPLY INSURANCE-RATE BY R E N - D A Y S - R E N T E D 
2 8 5 
1 
G I V I N G 
IND-INSURANCE-TOTAL 
286 
S I Z E ERROR DISPLAY 'SIZE ERROR O N INSURANCE TOTAL' 
287 
j 
END-MULTIPLY 
288 
\ END-IF\ 
289 
" 
290 
4 0 0 - W R I T E - H E A D I N G - L I N E S . 
291 
M O V E 1 TO LINE-COUNT. 
292 
A D D 1 T O PAGE-COUNT. 
293 
M O V E PAGE-COUNT TO HDG-PAGE-NUMBER. 
294 
W R I T E P R I N T - L I N E FROM H E A D I N G - L I N E - O N E 
295 
A F T E R A D V A N C I N G PAGE. 
296 
W R I T E P R I N T - L I N E FROM HEADING-LINE-TWO 
297 
A F T E R A D V A N C I N G 2 LINES. 
298 
W R I T E P R I N T - L I N E FROM H E A D I N G - L I N E - T H R E E . 
299 
300 
5 0 0 - W R I T E - D E T A I L - L I N E . 

Chapter 
9 
Moie 
About 
the 
Procedure 
Division 
gyre 9.13 
(continued) 
—
_
_ 
_
_
_
_
_
_
_
_
_
_
_ 
_
„
_
.
„
„
„
.
.
.
_
™
_
_
„
_
_
.
_
_
_
—
_
—
_
—
j 
301 
MOVE REN-CONTRACT-NO TO DET-CONTRACT-NO. 
302 
INSPECT DET-CONTRACT-NO REPLACING ALL
 
1 ' BY 
303 
MOVE 1 TO NAME-POINTER. 
304 
JWVEJSPACES TO PET-NAME. 
| 
305 
STRING r<EN-LAST-NAME DELIMITED BY
 
1 R] 
1 
306 
', ' DELIMITED BY SIZE 
| 
307 
REN-FIRST-NAME DELIMITED BY
 
1 1 
'
I 
308 
INTO DET-NAME POINTER NAME-POINTER 
309 
END-STRING. 
310 
IFRE¥-INITIAL NOT^ s"PACES 
311 
STRING
 
1 1 REN-INITIAL '.' DELIMITED BY SIZE 
312 
INTO DET-NAME POINTER NAME-POINTER 
313 
END-STRING 
314 
END-IF. 
315 
STRING REN-RETURNED-MONTH '/' REN-RETURNED-DAY '/" 
I 316 
REN-RETURNED-YEAR DELIMITED BY SIZE 
[ 317 
INTO DET-RETURN-DATE 
; 318 
END-STRING. 
j 319 
MOVE REN-CAR-TYPE TO DET-CAR-TYPE. 
j 320 
MOVE REN-DAYS-RENTED TO DET-DAYS-RENTED. 
I 321 
MOVE IND-DAILY-TOTAL TO DET-DAILY-TOTAL. 
i 322 
MOVE IND-MILES-DRIVEN TO DET-MILES-DRIVEN. 
j 323 
MOVE REN-MILEAGE-RATE TO DET-MILEAGE-RATE. 
! 
324 
MOVE IND-MILEAGE-TOTAL TO DET-MILEAGE-TOTAL. 
| 325 
MOVE IND-INSURANCE-TOTAL TO DET-INSURANCE-TOTAL. 
326 
MOVE IND-MILEAGE-TOTAL TO DET-MILEAGE-TOTAL. 
327 
MOVE IND-AMOUNT-DUE TO DET-AMOUNT-DUE. 
328 
WRITE PRINT-LINE FROM DETAIL-LINE 
329 
AFTER ADVANCING 2 LINES. 
3 3 0 
;^D"ITonTjE-^Mi^."r 
 
331 
- 
• 
- - 
- - 
Line couner :s incremented 
332 
600-INCREMENT-TOTALS. 
333 
ADD REN-DAYS-RENTED TO TOTAL-DAYS-RENTED 
334 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL DAYS RENTED' 
335 
END-ADD. 
336 
ADD IND-DAILY-TOTAL TO TOTAL-DAILY-RENTAL 
337 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL RENTAL' 
338 
END-ADD. 
339 
ADD IND-MILES-DRIVEN TO TOTAL-MILES-DRIVEN 
340 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL MILES DRIVEN' 
341 
END-ADD. 
342 
ADD IND-MILEAGE-TOTAL TO TOTAL-MILEAGE 
343 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL MILEAGE' 
[ 344 
END-ADD. 
345 
ADD IND-INSURANCE-TOTAL TO TOTAL-INSURANCE 
346 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL INSURANCE' 
347 
END-ADD. 
348 
ADD IND-AMOUNT-DUE TO TOTAL-AMOUNT-DUE 
349 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL AMOUNT DUE' 
350 
END-ADD. 
351 

The 
Car 
Billing 
Program 
(continued) 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
700-WRITE-RENTAL-T0TALS. 
WRITE PRINT-LINE FROM TOTAL-OASH-LINE 
AFTER ADVANCING 2 LINES. 
! ^ ,. 
MOVE TOTAL-DAYS-RENTED TO TOT-DAYS-RENTED. 
MOVE TOTAL-DAILY-RENTAL TO TOT-DAILY-RENTAL. 
MOVE TOTAL-MILES-DRIVEN TO TOT-MILES-DRIVEN. 
MOVE TOTAL-MILEAGE TO TOT-MILEAGE. 
MOVE TOTAL-INSURANCE TO TOT-INSURANCE. 
MOVE TOTAL-AMOUNT-DUE TO TOT-AMOUNT-DUE.. 
WRITE PRINT-LINE FROM TOTAL-LINE. 
(A period m a y not be present after the E N D - R E A D scope terminator because 
it is nested within the in-line perform statement. See problem 2 at the end of 
the chapter.) 
2. The use of scope terminators throughout the Procedure Division—for example, 
E N D - R E A D in line 215, E N D - C O M P U T E in lines 256 and 266, and E N D II in 
lines 242, 288, and 314. 
3. The establishment of a heading routine (lines 290-298) and the associated 
in lines 50 and 51. L I N E - C O U N T is tested prior to writing a detail line (lines 
240-242). Since it was initialized to six (a value greater than the desired n u m b e r 
of detail lines per page), a heading is written prior to the first detail record. The 
heading routine resets the line counter (line 291), which is subsequently 
incremented after every detail line is written (line 330). The page counter is 
also incremented in the heading routine (line 292), so that the page n u m b e r 
can appear o n the top of every page in the report. 
4. The A C C E P T statement (line 223) to obtain the date of execution and again to 
accept the corresponding day of the w e e k (line 227). The E V A L U A T E statement 
of lines 228-236 converts the numeric D A Y - O F - W E E K code to its literal 
equivalent. 
5. The INITIALIZE statement in line 247 to initialize the six data n a m e s defined 
under I N D - B I L L - I N F O R M A T I O N . 
6. The R E A D I N T O statement in line 210 and the associated W S B E G I N S H E R E 
literal at the start of Working-Storage (lines 24-25) to facilitate debugging. The 
W R I T E F R O M statement is used throughout the Procedure Division with 
various print lines. 
7. The indentation of subservient clauses throughout the Procedure Division to 
enhance the readability of the program. A T E N D and N O T A T E N D are indented 
under R E A D , A F T E R A D V A N C I N G is indented under W R I T E , a n d so on. Blank 
lines are used throughout the program a n d appear before 01 entries in the 
Data Division and before paragraph headers in the Procedure Division. 
8. The S T R I N G statements in lines 305-309 and 311-313; the latter statements 
use the P O I N T E R phrase to place the middle initial (if one is present) after the 
first n a m e . 
u t i i m t i u i i ui v. u u i n ^ i j i n 
LINE C O U N T and P A G E C O U N T 

Chapter 
9 
-
More 
About 
the 
Procedure 
Division 
The chapter focused on advanced statements in the Procedure Division, 
many of which were not available in COBOL-74. The most significant 
enhancements include scope terminators, the in-line perform, and false-
condition branch, all of which are new to COBOL-85. The TEST BEFORE and 
TEST AFTER clauses are also new, as are the INITIALIZE statement and 
DAY-OF-WEEK clause. 
The statements for string processing (INSPECT, STRING, and 
UNSTRING) were previously available in COBOL-74; reference modification, 
however, is new to COBOL-85. Duplicate data names, qualification, and the 
MOVE CORRESPONDING statement are unchanged from the earlier compiler. 
The PERFORM statement contains the optional TEST BEFORE and TEST 
AFTER clauses, corresponding to the DO WHILE and DO UNTIL iteration 
structures. 
The combination of an in-line PERFORM and false-condition branch within 
the READ statement eliminates the need for a priming read. 
The procedure-name in a PERFORM statement may be either a paragraph 
or a section. The THRU clause enables the execution of multiple procedures, 
which typically include an EXIT paragraph. 
READ INTO and WRITE FROM combine the effects of a MOVE statement 
with the indicated I/O operation. READ INTO is also used in conjunction 
with the literal WS BEGINS HERE to facilitate debugging. 
String processing is accomplished through the INSPECT, STRING, and 
UNSTRING statements, which provide flexibility in character manipulation. 
The ACCEPT statement includes the DAY and DAY-OF-WEEK clauses to 
obtain the date and corresponding day of the week on which a program 
executes. 
The INITIALIZE statement sets multiple data names to initial values in a 
single statement. 
Duplicate data names may be defined (but are not recommended) provided 
all Procedure Division references to the duplicate names use appropriate 
qualification. The MOVE CORRESPONDING statement is the equivalent of 
several individual MOVE statements. 

DO UNTIL structure 
Procedure name 
DO WHILE structure 
Qualification 
Duplicate (nonunique) datanames 
Reference modification 
False-condition branch 
Section 
In-line perform 
String processing 
ACCEPT 
DAY 
DAY-OF-WEEK 
EXIT 
IN 
INITIALIZE 
INSPECT 
MOVE CORRESPONDING 
NOT AT END 
OF 
PERFORM THRU 
PERFORM UNTIL 
READ INTO 
STRING 
TEST AFTER 
TEST BEFORE 
UNSTRING 
WRITE FROM 
1. The R E A D INTO statement causes each incoming record to be moved to  
areas. 
2. The WRITE F R O M statement is the equivalent of two statements, a 
and a 
, 
. 
3. A 
consists of one or more paragraphs. 
4. The 
statement causes no action to be taken and is often used to 
delineate the end of a P E R F O R M T H R U statement. 
5. Nonunique data names within a C O B O L program may be 
using 
the reserved words 
or 
. 
6. The 
statement is a convenient way to replace leading blanks in a 
field with zeros. 
7. String processing operations are accomplished through the 
, 
, and 
statements. 
8. The R E A D statement includes an optional false-condition branch implemented by 
the 
clause. 
9. The D O W H I L E and D O UNTIL constructs of structured programming are 
implemented with the TEST 
and TEST 
clauses 
in the P E R F O R M statement. 
10. 
makes it possible to address a string of 
characters contained within another string. 

Chapter 
9 --• 
More 
About 
the 
Procedure 
Division 
11. Omission of the procedure n a m e in a P E R F O R M statement creates an  
perform. 
12. The 
statement enables the initialization of multiple data types in 
a single statement. 
1. The INSPECT statement facilitates the elimination of leading blanks. 
2. A paragraph consists of one or more sections. 
3. A P E R F O R M statement must include a procedure (paragraph or section) name. 
4. Qualification over a single level will always remove ambiguity of duplicate data 
names. 
5. The C O R R E S P O N D I N G option is required if duplicate data names are used. 
6. The STRING statement is used to combine several fields together. 
7. For the C O R R E S P O N D I N G option to work, both duplicate names must be at the 
same level. 
8. The U N S T R I N G statement is used to separate a field into a maximum of three 
distinct fields. 
9. The EXIT statement is required to delineate the end of a performed routine. 
10. A P E R F O R M statement must specify either TEST B E F O R E or TEST AFTER. 
11. The R E A D statement m a y include both an A T E N D and a N O T A T E N D clause. 
12. The R E A D statement must be terminated by an E N D - R E A D scope terminator. 
R O B L E M S 
1. Given the code: 
PROCEDURE DIVISION. 
MAINLINE SECTION. 
FIRST-PARAGRAPH. 
PERFORM SEC-A. 
PERFORM PAR-C THRU PAR-E. 
MOVE 1 TO N. 
PERFORM PAR-G 
WITH TEST AFTER 
UNTIL N > 2. 
STOP RUN. 
SEC-A SECTION. 
ADD 1 TO X. 
ADD 1 TO Y. 
ADD 1 TO Z. 
PAR-B. 
ADD 2 TO X. 
PAR-C. 
ADD 10 TO X. 

PAR-D. 
ADD 10 TO Y 
ADD 20 TO Z. 
PAR-E. 
EXIT. 
PAR-F. 
MOVE 2 TO N. 
PAR-G. 
ADD 1 TO N 
ADD 5 TO X. 
a. How many times is each paragraph executed? 
b. What are the final values of X, Y, and Z? (Assume they were all initialized to 0.) 
c. What would happen if the statement ADD 1 TO N were removed from PAR-G? 
2- Figure 9.14a contains a slightly modified version of the first paragraph in the car 
reporting program in which two periods have been added to produce the indicated 
compilation errors. Indicate the erroneous periods and explain why they produce 
the error messages. 
Figure 9,14 
COBOL Listing for Problem 2 
204 
PROCEDURE DIVISION. 
205 
000-PREPARE-RENTAL-REPORT. 
206 
OPEN INPUT RENTAL-FILE 
207 
OUTPUT PRINT-FILE. 
208 
PERFORM 100-GET-T0DAYS-DATE. 
209 
PERFORM UNTIL DATA-REMAINS-SWITCH = 'NO' 
210 
READ RENTAL-FILE INTO RENTAL-RECORD-IN 
211 
AT END 
212 
MOVE 'NO' TO DATA-REMAINS-SWITCH. 
213 
NOT AT END 
214 
PERFORM 200-PR0CESS-RENTAL-REC0RDS. 
215 
END-READ. 
216 
END-PERFORM. 
217 
PERFORM 700-WRITE-RENTAL-T0TALS. 
218 
CLOSE RENTAL-FILE 
219 
PRINT-FILE. 
220 
STOP RUN. 
(a) Modified Procedure Division 
209 W Explicit scope terminator END- 'PERFORM' assumed present 
213 E AT END exception only valid for READ or SEARCH verbs 
215 E No corresponding active scope for 'END-READ
1 
216 E No corresponding active scope for 'END-PERFORM' 
(b) Error Messages 

Chapter 
9 
More 
About 
the 
Procedure 
Division 
3. Is the following list of names in alphabetical order? 
Joel Stutz 
Maryann Barber 
Shelly Parker 
Your answer depends on the record layout, that is, whether Name is a single field or 
whether Last Name, First Name, and Middle Initial are defined as individual fields. 
Can you see the need to define separate fields for these items? Can you appreciate 
the utility of the STRING statement to concatenate the fields together when 
necessary? 
4. Given the following Data Division entries: 
01 EMPLOYEE-RECORD. 
05 EMP-NAME. 
10 EMP-LAST-NAME 
PIC X(16). 
10 EMP-FIRST-NAME 
PIC X(10). 
10 EMP-MIDDLE-INITIAL 
PIC X. 
05 ADDRESS. 
10 EMP-STREET-ADDRESS 
PIC X(20). 
10 EMP-CITY 
PIC X(20). 
10 EMP-STATE 
PIC XX. 
10 EMP-ZIP 
PIC X(5). 
Write the necessary STRING statements to create a mailing label with the format: 
First-Name Middle-Initial Last-Name 
Street-Address 
City, State Zip 
5. Given the following COBOL fragment: 
01 DATE-W0RK-AREA-1. 
05 YEAR-1 
PIC 99. 
05 MONTH-1 
PIC 99. 
05 DAY-1 
PIC 99. 
01 
DATE-WORK-AREA-2. 
05 YEAR-2 
PIC 99. 
05 DAY-2 
PIC 999. 
01 
DATE-W0RK-AREA-3. 
05 DAY-3 
PIC 9. 
ACCEPT DATE-WORK-AREA-1 FROM DATE. 
ACCEPT DATE-WORK-AREA-2 FROM DAY. 
ACCEPT DATE-WORK-AREA-3 FROM DAY-OF-WEEK. 
Indicate the stored values of each of the elementary items in the program. Assume 
a date of execution of March 16, 1993 (a Tuesday). 

Problems 
6. Given the following C O B O L fragment: 
01 
01 
DATE-WORK-AREA 
EDITED-DATE. 
05 EDIT-MONTH 
PIC X(6). 
05 FILLER 
05 EDIT-DAY 
05 FILLER 
05 EDIT-YEAR 
PIC XX. 
PIC X 
PIC XX. 
PIC X 
PIC XX. 
VALUE '/'. 
VALUE '/ 
ACCEPT DATE-WORK-AREA FROM DATE. 
MOVE DATE-WORK-AREA (3:2) TO EDIT-MONTH. 
MOVE DATE-WORK-AREA (5:2) TO EDIT-DAY. 
MOVE DATE-WORK-AREA (1:2) TO EDIT-YEAR. 
indicate the stored values of EDIT-MONTH, EDIT-DAY, and EDIT-YEAR. (Assume 
the same date as in the previous problem.) 
7. Given the following C O B O L definition: 
01 GROUP-ITEM 
05 NUMERIC-FIELD-1 
PIC 9(4). 
05 NUMERIC-FIELD-2 
PIC 9(4). 
05 ALPHANUMERIC-FI ELD-1 
PIC X(15). 
05 ALPHANUMERIC-FIELD-2 
PIC X(20). 
What difference (if any) is there between the following statements? 
a. INITIALIZE, 
and 
INITIALIZE GROUP-ITEM. 
b. INITIALIZE GROUP-ITEM, 
and 
INITIALIZE GROUP-ITEM 
REPLACING NUMERIC DATA BY ZERO 
ALPHANUMERIC DATA BY SPACES. 
c. INITIALIZE GROUP-ITEM, 
and 
MOVE ZEROS TO NUMERIC-FIELD-1 NUMERIC-FIELD-2. 
MOVE SPACES TO ALPHANUMERIC-FIELD-1 ALPHANUMERIC-FIELD-2. 


jj J-U 
Overview 
ACCEPT 
Programming Tip: The Use of COBOL Constants 
DISPLAY 
The Tuition Billing Program Revisited 
Programming Specifications 
Hierarchy Chart 
Pseudocode 
The Completed Program 
Programming Tip: The Hidden Power of the Alt Key 
Car Validation and Billing Program 
Programming Specifications 
The Screen Section 
Hierarchy Chart 
Pseudocode 
The Completed Program 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
10 — 
Screen 
1-0 
U 
After reading this chapter you will be able to: 
Discuss the concept of screen 1-0 versus the file-oriented approach of 
earlier chapters. 
Describe the ACCEPT and DISPLAY statements; discuss at least three 
optional clauses for each statement. 
Describe the SCREEN SECTION and indicate why its use may be preferable 
to individual ACCEPT and DISPLAY statements. 
Differentiate between the background and foreground colors; implement a 
color scheme using ACCEPT and DISPLAY statements and/or the Screen 
Describe how interactive data validation is implemented in a screen 1-0 
program; contrast this technique to the batch-oriented procedure in 
Chapter 8. 
c 
n 
v 
i 
cz 
vv 
The proliferation of the PC has increased the importance of screen 1-0, whereby 
input to a program is received from the keyboard and output is displayed on the 
monitor. The specific options (color, highlighting, positioning, and so on) vary 
according to the particular keyboard or monitor (display terminal) and are nor 
part of the COBOL-85 standard. Virtually all compilers, however, include these 
capabilities as an extension to the 85 standard, and hence we do our best to 
describe them in general fashion. The syntax is that of Micro Focus Personal 
COBOL that accompanies this text. (Personal COBOL conforms to the X-Open 
standard, developed by of a consortium of software vendors including Microsoft, 
and has been proposed as an official extension to the 2000 standard.) 
The chapter begins with the ACCEPT and DISPLAY statements that are 
used for low-volume input and output and that reference specific line and 
column positions. Both statements contain an abundance of optional clauses 
that are illustrated in a final version of the tuition-billing program that first 
appeared in Chapter 5. 
The second half of the chapter focuses on the Screen Section to define an 
entire screen as opposed to individual lines. We combine the data validation 
and reporting programs of Chapters 8 and 9 to produce an interactive program 
that validates data as it is entered, and produces an on-screen result. 
T h e A C C E P T statement enables data to be entered in specific positions according 
to a precise format. The statement contains a required identifier—that is, a data 

ACCEPT 
n a m e to hold the input data, followed by optional clauses that can be entered in 
any order. 
As indicated, the specific implementation lor screen 1-0 is not defined in the 
C O B O L - 8 5 standard, but has been proposed as an extension to that standard. O u r 
examples follow the syntax of Personal C O B O L that accompanies this text. 
Consider: 
ACCEPT i d e n t i f i e r [ATJ 
LINE NUMBER 
identifier-1 
i n t e g e r - 1 
WITH IAUTOI [BACKGROUND- COLOR IS integer-3 
COLUMN 
i d e n t i f i e r - 2 
NUMBER \ 
COL 
integer-2 
j BELL[ 
[BEEPJ 
BLINK 
FOREGROUND - COLOR I S inteqer-4j [HIGHLIGHT] [SECURE] [REVERSE - VIDEO 
CONTROL I S { i d e n t i f i e r - 3 } ] 
[LEFT-JUSTIFY ] 
[SPACE-FILLi 
r 
, 
r 
ir 
l 
\ 
{ 
} TRAILING SIGN 
UNDERLINE 
UPDATE 
[RIGHT-JUSTIFY 
[ZERO-FILL
 
1 '
 
1 
1 
1 
The LINE and C O L U M N clauses provide the location for the data. (The typical 
screen displays 25 lines of 80 columns.) Both clauses are optional with default 
actions as follows. Omission of the LINE clause defaults to line one if a previous 
screen element has not been defined, or to the existing line otherwise. Omission of 
the C O L U M N clause defaults to column one if the LINE clause is also specified, a n d 
to the next column (after the last screen element) if the LINE clause is also omitted. 
The B A C K G R O U N D - C O L O R and F O R E G R O U N D - C O L O R clauses specify the 
background a n d foreground colors, respectively, with the available colors listed in 
Table 10.1. A n y of the sixteen listed colors m a y be specified for the foreground, but 
only the first eight (numbered from zero to seven) m a y be specified as the 
background. T h e default colors for the background a n d foreground are black a n d 
white, respectively, corresponding to white text o n a black background. In Personal 
C O B O L the integer or a constant representing that integer must be used. A data 
n a m e does nor work. See Programming Tip o n Micro Focus constants. 
P R O G R A M M I N G 
T I P 
In Micro Focus's version of the Screen Section, the ACCEPT and DISPLAY verbs require the use of an integer 
to specify BACKGROUND-COLOR and FOREGROUND-COLOR. Specifying colors by number rather than 
name can be confusing. Fortunately, there is a way to meet the requirements of using an integer while 
maintaining the clarity of a color name. Micro Focus provides for a new level number - 78-level. The 78-level is 
a way of defining and naming a constant value. The syntax for a 78-level is similar to that of the 88-level, but 
only one literal can be specified. 

Chapter 
10 — 
Screen 
l-O 
7 8 
D A T A - N A M E 
V A L U E 
L I T E R A L . 
The 78-level does not need a PIC clause since the compiler will allocate space on the basis of the data 
format of the literal. Examples: 
78 MAGENTA 
VALUE 5. 
78 YES 
VALUE 'Y\ 
78 ERROR-1 
VALUE 'Entry must be Y or N'. 
Wherever each of these entries are referenced the constant values are used. Constants are particularly 
useful when a literal must be used. The BACKGROUND-COLOR and FOREGROUND-COLOR clauses for 
defining ACCEPT and DISPLAY statements are the prime examples. 
Level-78s are standalone data-items and the compiler does not treat them as subordinate to any group 
item. Therefore, if you wish to group the items as in line 16-34 of Figure 10-4, the 01-level must have a PIC 
clause. The PIC has no effect on the following level-78s. Without the PIC, COBOL thinks that the 01-level has 
no length. 
You should remember that level-78s are not standard COBOL entries. We have introduced them simply 
to make the screen l-O programs more readable. 
x**si...,i. -„<•)/: 
Foreground and Background Colors 
0 
Black 
1 
Blue 
2 
Green 
3 
Cyan 
4 
Red 
5 
Magenta 
6 
Brown 
7 
White 
8 
Bright black (gray) 
9 
Bright blue 
10 
Bright green 
11 
Bright cyan 
12 
Bright red 
13 
Bright magenta 
14 
Bright brown (yellow) 
15 
Bright white 
The AUTO clause terminates the A C C E P T statement w h e n the last character 
in the data item has been entered; the user does not have to press the return key for 
processing to continue. If, however, multiple data n a m e s are entered into the s a m e 
A C C E P T statement, the A U T O clause m o v e s the cursor to the first character of the 
next item. 
The HIGHLIGHT, R E V E R S E - V I D E O , BLINK, a n d U N D E R L I N E clauses are 
used for emphasis, a n d their intended effects are apparent: B L I N K causes characters 
to blink o n a n d off, U N D E R L I N E underlines each character as it is displayed o n the 
screen, a n d H I G H L I G H T displays a field at its highest intensity. The R E V E R S E -
V I D E O clause displays light characters o n a dark background; that is, the characters 
are dark a n d the area surrounding the characters is light. The synonymous B E L L 
and B E E P clauses sound the system's audio tone w h e n the referenced data item is 
processed during execution of the A C C E P T statement. 

The CONTROL option allows any of the other clauses to be specified in an 
identifier. The identifier can be changed by the program allowing flexibility in 
appearance of the entry. 
The ZERO-FILL option displays a numeric item with high-order zeros, whereas 
the (default) SPACE-FILL clause displays data with zero suppression. T h e RIGHT-
JUSTIFY clause makes operator-keyed characters align in the rightmost character 
position of the field and is for elementary items only. LEFT-JUSTIFY (the default) is 
for documentation only and has no effect. The SPACE-FILL, ZERO-FILL, LEFT-
JUSTIFY, and RIGHT-JUSTIFY clauses are allowed only for elementary items. 
The UPDATE option displays the initial value of the data item before the 
operator is prompted for n e w input, and if no n e w data are entered, the initial data 
are treated as though they were operator keyed. U P D A T E is not allowed for a 
numeric-edited item. 
The SECURE clause prevents the accepted data item from appearing on the 
screen and is useful in implementing password protection and/or other security 
considerations. 
The D I S P L A Y statement was introduced in Chapter 3 in conjunction with top-down 
testing and referenced again in Chapter 6 for use in debugging. In both instances 
the simplest form of the statement w a s used at strategic points in a program, to 
display messages and/or intermediate results to help monitor program execution. 
The DISPLAY statement also has m a n y additional options to enhance its output. 
DISPLAY 
identi fier- 1 
1i teral-1 
AT LINE N U M B E R 
identifier-2 
integer- 1 
COLUMN N U M B E R 
WITH [ B A C K G R O U N D - C O L O R IS integer-3] 
JBELL 
IBEEP 
identifier-3 
integer-2 
[BLINK] 
F O R E G R O U N D - C O L O R IS integer-4 | |HIGHLIGHT| [REVERSE-VIDE0[ 
identifier-4] 
C O N T R O L IS 
U N D E R L I N E 
iteral 
B L A N K 
[SCREEN] 
[LINE J 
M a n y of the clauses in the DISPLAY statement have been explained in 
conjunction with the A C C E P T statement; for example, you can use the LINE and 
C O L U M N clauses to control the specific position where the displayed output is to 
appear. Y o u can also emphasize the displayed message by blinking, beeping, 
underlining, or reverse video. Y o u can (on a color monitor) implement a variety of 
color schemes for both the foreground (text) and background. 
The DISPLAY statement also enables y o u to clear all or a portion of the screen 
prior to displaying a data element. The B L A N K S C R E E N clause clears the entire 
screen and leaves the cursor positioned in line 1, column 1. T h e B L A N K LINE clause 
blanks the associated line beginning in c o l u m n 1 unless a c o l u m n is specified. 
Specification of either entry, B L A N K S C R E E N or B L A N K LINE, also reactivates the 
default background a n d foreground colors. 

Chapter 
10 — Screen 
I-O 
The tuition-billing program has appeared several times throughout the text. It was 
first presented in Chapter 3 in conjunction with structured methodology, used in 
Chapters 4 a n d 5 to introduce basic C O B O L statements, a n d expanded in Chapter 7 
to include editing characters. W e continue n o w with one final version to illustrate 
screen I-O, whereby student data are accepted for one student at a time, after which 
the c o m p u t e d bill (for that student) is displayed o n the monitor. 
The programming specifications parallel the original problem statement o n 
page 49 with minor modifications to reflect the interactive nature of screen I-O. 
Thus, unlike the original file-based program, which processed students until the 
input file w a s exhausted, the screen-based program accepts data for one student at 
a time, then asks the user whether data for another student are to be entered. T h e 
screen I-O program also imposes the requirement for a valid password prior to 
processing the first student, a n d it eliminates the calculation of university totals. 
The formal specifications follow in the usual format. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Tuition Billing Program (Screen Version) 
Narrative: 
Screen Layouts: 
This program modifies the specifications for the original tuition billing program to 
accommodate screen I-O. Incoming records are to be entered one at a time via the 
keyboard with computed results for each student displayed as they are calculated. 
The password is to be masked and entered as per the screen in Figure 10.1a, student 
data are to be entered according to the screen in Figure 10.1b, and the computed results 
displayed as in Figure 10.1c. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Develop an interactive program to accept student data, then compute and display 
the student's bill. The program is to execute continually until it receives a response 
indicating that no more students are to be processed. 
2. The program is to check for a valid password prior to accepting data for the first 
student. (The password is C O B O L in either all upper- or all lowercase letters) The user 
is allowed a maximum of two tries to enter the password correctly, after which the 
program is to terminate with an appropriate error message. 
3. The specifications for computing an individual student's bill are the same as in the 
original program: 
a. Compute the individual bill as the sum of tuition, union fee, and activity fee, minus a 
scholarship (if any). 
b. The tuition is $200 per credit. 
c. The union fee is $25. 
d. The activity fee is based on the number of credits taken: 
ACTIVITY FEE 
C R E D I T S 
$25 
6 or less 
$50 
7-12 
$75 
m o r e than 12 
e. Award a scholarship equal to the amount in the incoming record if the G P A is 
greater than 2.5. 
4. The requirement to compute university totals has been deleted. 

The 
Tuition 
Billing 
Program 
Revisited 
Tuition: 
3,600 
Activity Fee: 
75 
Union Fee: 
25 
Less Scholarship: -4,000 
Amount Due: 
$ 
300CR 
Enter another student? (Y/N): 
The hierarchy chart for the screen version of the tuition billing program is s h o w n in 
Figure 10.2. T h e highest-level module, P R O C E S S - S T U D E N T - D A T A , has four 
subordinates: P R O C E S S - P A S S W O R D , I N P U T - S T U D E N T - I N F O , C O M P U T E -
INDIVIDUAL-BILL, and DISPLAY-STUDENT-BILL. C O M P U T E - S T U D E N T - B I L L has 
four subordinates of its o w n : C O M P U T E - T U I T I O N , C O M P U T E - U N I O N - F E E , 
C O M P U T E - A C T I V I T Y - F E E , and C O M P U T E - S C H O L A R S H I P , all of which appeared 
in the original hierarchy chart. 
The requirement to compute university totals has been dropped from the 
programming specifications, and thus the modules associated with this function 
that appeared in the original hierarchy chart (Figure 3.3) have been dropped from 
the current version. 
The pseudocode in Figure 10.3 contains two iterative structures, a D O U N T I L 
associated with obtaining the password, and a D O W H I L E to process student data. 
The difference between the two is significant a n d was explained previously in 
Chapter 9 (see Figure 9.1). Recall, therefore, that the D O U N T I L structure tests the 
condition after executing the indicated statements and thus ensures that those 
statements are executed at least once. A D O W H I L E , however, tests the condition 
before executing the statements, and hence the indicated statements need not be 
executed at all. 
'1.. , v ,('.. Tuition Billing Program (Screen l-O) 
ENTER PASSWORD: ***** 
j 
Enter the following information: 
| 
Last Name: Zobrist 
Initials: W 
j 
Credits: 18 
Union Member (Y/N): Y 
j 
GPA: 3.20 
Scholarship Amount: 4000 

Chapter 
10 — 
Screen 
1-0 
Hierarchy Chart for Tuition Billing Program (Screen Version) 
PROCESS 
STUDENT 
DATA 
PROCESS 
PASSWORD 
COMPUTE 
TUITION 
COMPUTE 
INDIVIDUAL 
BILL 
DISPLAY 
STUDENT 
BILL 
COMPUTE 
UNION 
FEE 
COMPUTE 
ACTIVITY 
FEE 
COMPUTE 
SCHOLARSHIP 
m 10.3 
Pseudocode for Tuition Billing Program (Screen Version) 
DO UNTIL password-valid OR too-many-tries 
ACCEPT and validate password 
Increment number of tries 
ENDDO 
IF too-many-tries 
Set continue-processing-switch to 'N' 
Display 'SORRY, you tried too many times' 
END-IF 
DO WHILE continue-processing-switch not equal to 'N' 
Compute tuition 
Compute union fee 
Compute activity fee 
Compute scholarship 
Compute bill 
DISPLAY computed results 
ACCEPT continue-processing-switch 
ENDDO 
Stop run 
or n 

The 
Tuition 
Billing 
Program 
Revisited 
The user must be given at least one try to enter the password and hence the 
D O U N T I L structure is used to accept and validate (reject) the user's entry, if the 
user fails to enter the correct password within the allocated n u m b e r of tries, the 
continue-processing-switch will be set to 'N', which prevents the execution of 
statements within the D O W H I L E loop; that is, the program terminates without 
processing a student record. 
The completed program is s h o w n in Figure 10.4 and reflects the hierarchy chart and 
pseudocode just discussed. It is different from all previous programs in that input is 
received from the keyboard and output is displayed o n the monitor. Thus, there are 
no files in this program, and hence no need for an Environment Division (and the 
associated S E L E C T statements), nor for the File Section in the Data Division. The 
absence of all files also m e a n s that the Procedure Division does not contain the 
familiar O P E N , C L O S E , R E A D , and W R I T E statements that were present in all 
previous programs. 
All 1-0 is screen based a n d accomplished through A C C E P T a n d DISPIAY 
statements with LINE and C O L U M N clauses to control the location of the displayed 
fields. Different colors are used for different areas of the screen as implemented 
through the C O L O R clauses that appear throughout the program; the available 
colors are defined as data n a m e s in lines 16-34, then referenced as necessary in the 
various A C C E P T and DISPIAY statements. 
The imposition of a password is accomplished through the in-line P E R F O R M 
statement in lines 80-89, which uses the T E S T A F T E R clause to give the user two 
chances to enter the password correctly. T h e S E C U R E clause, in the A C C E P T 
statement of lines 87 and 88, prevents the user's response from appearing o n the 
screen, and the A U T O clause saves the user from having to press the return key. The 
B L A N K S C R E E N clause in line 84 clears the screen before requesting the password. 
The program accepts either C O B O L or cobol as a valid password according to the 
88-level entry in line 38; it will not, however, recognize a combination of upper- and 
lowercase letters. 
Once a valid password has been entered, the program processes students one 
at a time through the in-line P E R F O R M statement in lines 72-76, which invokes 
three lower-level paragraphs for each student: 200-INPUT-STUDENT-lNFO, 310-
C O M P U T E - I N D I V I D U A L - B 1 L L , a n d 500-DISPIAY-STUDENT-BILL. T h e latter 
paragraph ends by obtaining the user response regarding another student (lines 
189-191). Note, too, the provision for both upper- and lowercase data entry as the 
C O N T I N U E - P R O C E S S I N G - S W I T C H in line 72 is compared to both 'N' and V . 
O n e last c o m m e n t concerns the double line that appeared around the user's 
input in the screen of Figure 10.1b. This was accomplished by including the necessary 
ASCII (graphics) characters in the DISPLAY statements of lines 99 through 117. (See 
programming tip o n the Alt key a n d numeric keypad.) 

Chapter 
10 — 
Screen 
1-0 
P R O G R A M M I N G 
T I P 
Newcomers to the computer recognize the Alt key as the middle key in the Ctrl, Alt, and Del sequence to 
reboot the computer. It has many more uses, however, one of which is to reproduce any character within the 
256 ASCII character set shown in the table below. 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
00 
© 
• 
• 
* 
s 
• 
0 
01 
Si 
cf 
9 
•« 
t 
II 
02 
f 
§ 
_ 
i 
t 
4-
>-
•+ 
03 
A 
• 
i 
II 
# 
$ 
% 
& 
1 
04 
( 
) 
* 
+ 
-
. 
/ 
0 
1 
05 
2 
3 
4 
5 
6 
7 
8 
9 
: 
f 
06 
< 
= 
> 
2 
§ 
A 
B 
C 
D 
E 
07 
F 
G 
H 
I 
J 
K 
L 
M 
N 
O 
08 
P 
Q 
R 
S 
T 
u 
V 
W 
X 
Y 
09 
Z 
[ 
\ 
] 
a 
b 
c 
10 
d 
e 
f 
g 
h 
i 
i 
k 
1 
m 
11 
n 
o 
P 
q 
r 
s 
t 
u 
V 
w 
12 
X 
y 
z 
{ 
i i 
} 
C 
i i 
13 
e 
a 
a 
a 
a 
9 
e 
c 
© 
•» 
JL 
14 
i 
i 
A 
A 
E 
ae 
6 
6 
6 
15 
u 
u 
1J 
6 
U 
C 
£ 
¥ 
I? 
16 
a 
i 
6 
u 
n 
N 
s 
c 
17 
— 
i 
i 
i 
« 
» 
1 
18 
\ 
w 
n 
1 
I'll"}-
% 
+ 
i 
19 
J 
L 
j _ 
T 
r 
_ 
% 
+ 
r 1 
20 
It 
If 
JL 
|L 
I 
_L 
JL 
20 
It 
If 
Tf 
lr 
j — 
ir 
JL 
T 1 
21 
¥ 
IL 
L-
F 
IT 
f 
+ 
J 
r 
T 1 
22 
• 
I 
I 
• 
a 
6 
r 
7T 
s 
a 
23 
T 
e 
n 
6 
00 
<P 
e 
n 
24 
= 
± 
> 
< 
R J 
"I" 
o 
• 
25 
y 
n 
2 
• 
The double vertical line, for example, is found in row 18, column 6 of the table, and thus, is ASCII 
character 186; it is entered into a program file by holding the Alt key down, and typing 1, 8, and 6, from 
the numeric 
keyboard. In similar fashion, a double horizontal line is found in row 20, column 5, and thus 
is ASCII character number 205. Four other characters, corresponding to the four corners, are required to 
complete the box. 
The printer, however, is a limiting factor, because while all of the 256 symbols will appear on an ordinary 
| 
monitor, they are not necessarily supported on every printer. 
I 
I 
I ... 

The 
Tuition 
Billing 
Program 
Revisited 
. = t..' t t 
Screen version of Tuition billing Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
IDENTIFICATION DIVISION. 
PROGRAM-ID. SCRNTUIT. 
AUTHOR. 
CAROL VAZQUEZ VILLAR. 
DATA DIVISION. 
WORKING-STORAGE SECTION. 
01 STUDENT-DATA. 
05 STU-NAME. 
10 STU-LAST-NAME 
10 STU-INITIALS 
05 STU-CREDITS 
05 STU-UNION-MEMBER 
05 STU-SCHOLARSHIP 
05 STU-GPA 
01 SCREEN-COLORS 
PIC X(15). 
PIC XX. 
PIC 9(2). 
PIC X. 
PIC 9(4). 
PIC 9V99. 
PIC S9(4) COM'P-5. 
01 
LORS FOR FOREGROUND AND BACKGROUND 
78~ BLACK 
VALUE 0. 
78 j BLUE 
VALUE 1. 
78 > GREEN 
VALUE 2. 
78 CYAN 
VALUE 3. 
78 RED 
~ 
VALUE 4. 
78 MAGENTA 
VALUE 5. 
/8 BROWN 
VALUE 6. 
78 j WHITE 
VALUE 7. 
DITIONAL COLORS FOR FOREGROUND ONLY 
78 j BRIGHT-BLACK 
VALUE 8. -
78 [ BRIGHT-BLUE 
VALUE 9. 
78 | BRIGHT-GREEN....---
VALUE 10. 
78 j BRIGHT-CYAN 
VALUE 11. 
78 j BRIGHT-RED 
VALUE 12. 
78 1 BRIGHT-MAGENTA 
VALUE 13. 
78 | BRIGHT-BROWN 
VALUE 14. 
78 I BRIGHT-WHITE 
VALUE 15. 
PASSWORD-VARIABLES. 
05 PASSWORD-ENTERED 
PIC X(5) 
88 VALID-PASSWORD 
VALUE 'COBOL' 
05 TRIES-COUNTER 
PIC 9. 
88 TOO-MANY-TRIES 
VALUE 3. 
CONTINUE-PROCESSING-SWITCH PIC X 
VALUE ' Y' . 
INDIVIDUAL-CALCULATIONS. 
05 IND-TUITION 
PIC 9(4) VALUE ZEROS. 
05 IND-ACTIVITY-FEE 
PIC 9(2) VALUE ZEROS. 
05 IND-UNION-FEE 
PIC 9(2) VALUE ZEROS. 
05 IND-SCHOLARSHIP 
PIC 9(4) VALUE ZEROS. 
05 IND-BILL 
PIC S9(6) VALUE ZEROS. 
01 DISPLAY-CALCULATIONS. 

(continued) 
05 
05 
05 
05 
05 
DIS-TUITION 
DIS-ACTIVITY-FEE 
DIS-UNION-FEE 
DIS-SCHOLARSHIP 
DIS-BILL 
PIC 
PIC 
PIC 
PIC 
PIC 
Z.ZZ9. 
19. 
19. 
1,119. 
$ZZZ,ZZ9CR. 
01 CONSTANTS-AND-RATES. 
05 
PRICE-PER-CREDIT 
05 UNION-FEE 
PIC 
PIC 
9(3) 
9(2) 
VALUE 200. 
VALUE 25. 
05 ACTIVITY-FEES. 
10 1ST-ACTIVITY-FEE 
PIC 99 
VALUE 25. 
10 1ST-CREDIT-LIMIT 
PIC 99 
VALUE 6. 
10 2ND-ACTIVITY-FEE 
PIC 99 
VALUE 50. 
10 2ND-CREDIT-LIMIT 
PIC 99 
VALUE 12. 
10 3RD-ACTIVITY-FEE 
PIC 99 
VALUE 75. 
MINIMUM-SCHOLAR-GPA 
PIC 9V9 
VALUE 2.5 
PROCEDURE DIVISION. 
j n 
000-PROCESS-STUDENT-DATA. 
/ " 
PERFORM 100-PROCESS-PASSWORD. 
/ _ 
PERFORM UNTIL COmNUE-PROCESSING-SWITCH =
 1N' OR 'n 
i 
PERFORM 200-INPUT-STUDENT-INFO 
| 
PERFORM 310-COMPUTE-INDIVIDUAL-BILL 
j 
PERFORM 500-D1SPLAY-STUDENT-BILL 
j END-PERFORM. 
STOP RUN. 
100-PROCESS-PASSWORD^ / _ 
_ 
PERFORM WITH TEST 
A
F
T
E
R
~ 
VARYING TRIES-COUNTER FROM 1 BY 1 
UNTIL VALID-PASSWORD OR TOO-MANY-TRIES 
DISPLAY 'ENTER PASSWORD:
 1 LINE 12 COLUMN 30 
ACCEPT PASSWORD-ENTERED LINE 12 COLUMN 46 
WITH REVERSE-VIDEO AUTO SECURE 
ENJJ-PERFORM_ 
_ 
IF TOO-MANY-TRIES 
MOVE 'N' TO CONTINUE-PROCESSING-SWITCH 
DISPLAY 'SORRY, You tried too many times' 
LINE 24 COLUMN 22 WITH BLINK 
FOREGROUND-COLOR WHITE"1 
BACKGROUND-COLOR RED f"'\ 
200-INPUT-STUDENT-INFO. 
DISPLAY ' 
— » - - " — " » 
AT LINE 2 COLUMN 5 WITH BLANK SCREEN 
FOREGROUND-COLOR BRIGHT-BROWN 
BACKGROUND-COLOR BLUE. 
TESTA 
WITH BLANK SCREEN 
FOREGROUND-COLOR BRIGHT-GREEN 
BACKGROUND-COLOR MAGENTA 

The 
Tuition 
Billing 
Program 
Revisited 
• u -3 
(continued) 
103 
DISPLAY '" Enter the following information: 
"' 
104 
AT LINE 3 COLUMN 5. 
105 
DISPLAY '" 
106 
AT LINE 4 COLUMN 5. 
107 
DISPLAY '" Last Name: 
Initials: 
108 
AT LINE 5 COLUMN 5. 
109 
DISPLAY '" 
110 
AT LINE 6 COLUMN 5. 
111 
DISPLAY '" Credits: 
Union Member (Y/N): 
112 
AT LINE 7 COLUMN 5. 
113 
DISPLAY '" 
114 
AT LINE 8 COLUMN 5. 
115 
DISPLAY '" 
GPA: 
Scholarship Amount: 
116 
AT LINE 9 COLUMN 5. 
117 
DISPLAY ' " " " " " " " " " 
118 
AT LINE 10 COLUMN 5. 
119 
ACCEPT STU-LAST-NAME AT LINE 5 COLUMN 18. 
120 
ACCEPT STU-INITIALS AT LINE 5 COLUMN 45. 
121 
ACCEPT STU-CREDITS AT LINE 7 COLUMN 16. 
122 
ACCEPT STU-UNION-MEMBER AT LINE 7 COLUMN 45 WITH AUTO. 
123 
ACCEPT STU-GPA AT LINE 9 COLUMN 16 WITH AUTO. 
124 
ACCEPT STU-SCHOLARSHIP AT LINE 9 COLUMN 45. 
125 
126 
310-COMPUTE-INDIVIDUAL-BILL. 
127 
PERFORM 410-C0MPUTE-TUITI0N. 
128 
PERFORM 430-C0MPUTE-UNI0N-FEE. 
129 
PERFORM 460-COMPUTE-ACTIVITY-FEE. 
130 
PERFORM 490-COMPUTE-SCHOLARSHIP. 
131 
COMPUTE IND-BILL = IND-TUITION + IND-UNION-FEE + 
132 
IND-ACTIVITY-FEE - IND-SCHOLARSHIP 
133 
SIZE ERROR DISPLAY 'SIZE ERROR FOR INDIVIDUAL BILL' 
134 
END-COMPUTE. 
135 
136 
410-C0MPUTE-TUITI0N. 
137 
COMPUTE IND-TUITION = PRICE-PER-CREDIT * STU-CREDITS 
138 
SIZE ERROR DISPLAY 'SIZE ERROR FOR INDIVIDUAL TUITION 
139 
END-COMPUTE. 
140 
141 
430-COMPUTE-UNIQN-FEE. 
142 
[iF STU-UNION-MEMBER = 'Y' or 'y'K, 
143 
MOVE UNION-FEE TO IND-UNION-FEE \ / f statement 
c . k c . 
144 
ELSE 
145 
MOVE ZERO TO IND-UNION-FEE 
146 
END-IF. 
147 
148 
460-COMPUTE-ACTIVITY-FEE. 
149 
EVALUATE TRUE 
150 
WHEN STU-CREDITS <= 1ST-CREDIT-LIMIT 
151 
MOVE 1ST-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
152 
WHEN STU-CREDITS > 1ST-CREDIT-LIMIT 
153 
AND STU-CREDITS <= 2ND-CREDIT-LIMIT 

Chapter 
10 - 
Screen 
1-0 
Figure 10.4 
(continued) 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
MOVE 2ND-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN STU-CREDITS > 2ND-CREDIT-LIMIT 
MOVE 3RD-ACTIVITY-FEE TO IND-ACTIVITY-FEE 
WHEN OTHER 
DISPLAY 'INVALID CREDITS FOR:
 1 STU-NAME 
END-EVALUATE. 
490-COMPUTE-SCHOLARSHIP. 
IF STU-GPA > MINIMUM-SCHOLAR-GPA 
MOVE STU-SCHOLARSHIP TO IND-SCHOLARSHIP 
ELSE 
MOVE ZERO TO IND-SCHOLARSHIP 
END-IF, 
500-DISPLAY-STUDENT-BILL. 
MOVE TO-TUITION TO DIS-TUITI0_N. 
[1)1 SPLAY' 'Tuition:' AT LINE 12 COLUMN 10. 1 
i DISPLAY DIS-TUITION AT LINE 12 COLUMN 29. 
MOVE IND-ACTIVITY-FEE TO DIS-ACTIVITY-FEE. 
"DISPLAY 'Activity Fee:' AT LINE 13 COLUMN 107 
DISPLAY DIS-ACTIVITY-FEE AT LINE 13 COLUMN 32. 
MOVE IND-UNION-FEE TO DIS-UNION-FEE. 
DISPLAY 'Union Fee:' AT LINE 14 COLUMN 10. 
DISPLAY DIS-UNION-FEE AT LINE 14 COLUMN 32. 
MOVE IND-SCHOLARSHIP TO DIS-SCHOLARSHIP. 
DISPLAY 'Less Scholarship: -' AT LINE 15 COLUMN 10. 
DISPLAY DIS-SCHOLARSHIP AT LINE 15 COLUMN 29. 
DISPLAY ' 
' AT LINE 16 COLUMN 27. 
MOVE IND-BILL TO DIS-BILL. 
DISPLAY 'Amount Due:' AT LINE 17 COLUMN 9. 
DISPLAY DIS-BILL AT LINE 17 COLUMN 26. 
DISPLAY 'Enter another student? (Y/N):' 
AT LINE 20 COLUMN 7. 
ACCEPT CONTINUE-PROCESSING-SWITCH AT LINE 20 COLUMN 37. 
v " 
«/ 
.. ' . t l t i i ^t&GiJI; 
The concept of data validation w a s introduced in Chapter 8 in the form of a stand-
•> L l t i jt.JIifl€| 
alone edit program that processed a file of incoming transactions, rejected invalid 
0* '
r "i * ' IH 
transactions with appropriate error message (s), a n d wrote valid transactions to a 
1 ' ''~'~
L 
" 
n e w file; the latter w a s then input to a reporting program that w a s developed in 
Chapter 9. This chapter combines the data validation a n d reporting programs into 
a single program to validate data as they are entered a n d produce a n on-screen 
result. 
The biggest difference between this program and its predecessor(s) is that the 
data are validated interactively as they are entered, as opposed to the batch-oriented 
approach in Chapter 8. The advantage of the interactive program is that the user is 

Car 
Validation 
and 
Billing 
Program 
given the opportunity to correct the invalid transaction at the time the error is 
detected, as opposed to receiving a report listing the errors. Realize, however, that 
interactive (screen-based) programs are restricted to low-volume applications a n d 
that their execution is far m o r e time consuming than programs that are file-driven. 
Specifications follow in the usual format. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Car Validation and Billing Program (Screen Version) 
Narrative: 
This program combines the specifications for data validation and reporting as presented 
earlier in Chapters 8 and 9. The fields in each incoming transaction are accepted and 
validated one at time, after which the bill is computed and displayed on the screen. Valid 
transactions are alscfwritten to an output file. 
Screen Layout: 
See Figure 10.5 (page 280). 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Develop an Interactive program to accept and validate car rental data, then compute 
and display the associated bill. The program is to execute continually until it receives a 
response indicating that no more records are to be processed. 
2. Each incoming field is to be validated as it is entered; that is, the user cannot move to 
the next field until valid data have been entered in the current field. The requirements 
for validation were presented in Chapter 8 and are summarized below. Each transaction 
is tn he> rhprkfid 
fnr thfl fnllnwinn-
._ 
— 
— 
. 
a. A numeric contract number. 
b. The presence of both a first and last name; a middle initial is not required, but if 
present, the initial must be alphabetic. 
c. A valid car type where the code is one of five values; E, C, M, F, or L. 
d. A valid date in which the month is between 1 and 12, the day is consistent with the 
month (e.g., April 31 should be rejected), and the date is less than or equal to the 
system date. 
e. A valid number of days rented that is greater than zero and less than or equal to 35. 
f. Numeric values for the mileage in and out; and further, that the mileage reported 
when the car is turned in is greater than the mileage when the car was taken out. 
The number of miles driven must also pass a reasonableness test of 10 miles or 
more per day 
g. A numeric mileage rate less than or equal to 50 cents per day. 
h. An insurance field of either Y or N. 
3. Write the validated transaction to a file as per the original program in Chapter 8. 
4. Calculate the customer's bill after all fields have been validated. The amount due is a 
function of car type, days rented, miles driven, mileage rate, and insurance. 
a. The mileage rate is different for each customer and appears as a field in the 
incoming transaction; the mileage total is the mileage rate times the number of 
miles driven. 
b. The daily rate is a function of the type of car rented. Economy cars cost $15 a day, 
compact cars $20 a day, mid-size cars $24 a day, full-size cars $28 a day, and 
luxury cars $35 a day. The daily total is the daily rate times the number of days 
rented. 
c. Insurance is optional at $10.50, regardless of the type of car rented. 

Chapter 
10 
Screen 
1-0 
d. A customer's total bill consists of the mileage total, daily total, and insurance total as 
riot-to /o\ 
/K\ 
5. Display the computed bill on the screen as per the screen layout of Figure 10.5. 
6. The requirement to compute totals has been deleted. 
m 
The tuition billing program illustrated the use of A C C E P T and DISPLAY statements 
within the Procedure Division. This approach is useful to display individual lines 
and/or to accept a limited n u m b e r of fields as input, but a w k w a r d w h e n you need to 
fill an entire screen. A second limitation of individual A C C E P T and DISPLAY 
statements is that they are scattered throughout the Procedure Division, making it 
difficult to reproduce consistent screens from program to program within a system. 
The Screen Section specifies the characteristics of an entire screen in the Data 
Division, then accepts or displays that screen in a single statement in the Procedure 
Division. The Screen Section is physically the last section in the Data Division, a n d 
its structure is similar to that of the File and/or Working-Storage Sections. Consider: 
level-number screen-name| 
FILLER 
BLANK SCREEN 
LINE 
BELL 
BEEP BLINK 
[HIGHLIGHT] [REVERSE-VIDEO] [UNDERLINE] 
BACKGROUND COLOR IS 
integer - 1 
data-name-1 
FOREGROUND - COLOR IS 
integer 
data-
ei 
- L 
name-2| 
LINE NUMBER 
identifier-1 
COLUMN NUMBER 
integer-3 
[VALUE IS literal-l] 
[PICTURE] JFROM identifier-4 TO identifier-5| 
[PIC J [USING identifier-6 
j 
identifier-2 
integer-4 
CONTROL IS 
[l i teral -1 
I i denti fi er-7 
[AUTO] [SECURE] 
A n appreciation for the Screen Section can best be gained by viewing sample 
screens and the associated C O B O L entries. Consider n o w Figure 10.5, which displays 
three screens from the car validation and billing program to be developed later in 
the chapter. Figure 10.5a displays the opening screen, consisting entirely of prompts 
for the various fields. Figure 15.5b displays a completed screen for Janice Vogel with 
valid entries in all fields, and Figure 10.5c displays the c o m p u t e d results. 
The screens are produced in the sequence shown; that is, the system displays 
the opening screen of Figure 10.5a and the user enters the fields one at a time. Each 
field is validated as it is entered; the user cannot m o v e to the next field until he or she 
has entered a valid value for the current field. O n c e all fields have been entered the 
system computes the bill and displays the results. 
A n abbreviated Screen Section, extracted from the completed program at the 
end of the chapter, is s h o w n in Figure 10.6. The entries in the Screen Section are 
similar to those in the File or Working-Storage Section; that is, they consist of group 
items divided into elementary items. The entry at the 01 level m u s t specify a screen­
n a m e — f o r example, O P E N I N G - S C R E E N and U P D A T E - S C R E E N in Figure 10.6. The 

The 
Screen 
Section 
Screen Layouts 
Mavis Car Rental Company 
07/03/98 
Contract No: 
Customer Information: 
Last Name 
First 
Initial 
Car Information 
Type Code 
Date Returned 
Days Rented 
Mileage: 
Miles In: 
Miles Out: 
Insurance: 
(Compact, Economy, Midsize, Fullsize, Luxury) 
Mi 1eage Rate: 
(Y/N) 
Above information correct? 
(Y - Yes, N - No) 
Mavis Car Rental Company 
Contract No: 886222 
07/03/98 
Customer Information: 
Last Name 
First 
Initial 
VOGEL 
JANICE 
D 
Car Information 
Type Code 
Date Returned 
Days Rented 
Mileage: 
Miles In: 
6,345 
Miles Out: 6,123 
Insurance: Y (Y/N) 
F (Compact, Economy, Midsize, Fullsize, Luxury) 
05/18/93 
12 
Mileage Rate: 
.02 
Above information correct? Y 
(Y - Yes, N - No) 
(b) Validated Record 

Chapter 
10 
Screen 
1-0 
(continued) 
Mavis Car Rental Company 
07/03/98 
Contract No: 886222 
Customer Information: 
Last Name 
First 
Initial 
VOfiEL 
JANICE 
D 
Car Information: 
Type Code: F (Compact, Economy, Midsize, Fullsize, Luxury) 
Date Returned: 05/18/93 
Totals 
j 
j 
Days Rented: 12 
Rental Rate: $28.00 
$336.00 
| 
j 
Mileage: 
j 
| 
Miles In: 
6,345 
Miles Driven: 
222 
j 
j 
Miles Out: 
6,123 
Mileage Rate: 
.02 
$4.44 
| 
J 
Insurance: Y (Y/N) 
Insurance Rate: $10.50 
$126.00 
f 
j 
Amount Due: 
$466.44 
Enter another record? N 
(Y - Yes, N - No) 
Abbreviated Screen Section 
I 
SCREEN SECTION. 
[ 
01 OPENING-SCREEN. 
05 BLANK SCREEN 
| 
BACKGROUND-COLOR BLUE FOREGROUND-COLOR WHITE. 
05 SCREEN-PROMPTS. 
10 LINE 3 COLUMN 7 VALUE 'Contract No:'. 
10 LINE 5 COLUMN 7 VALUE 'Customer Information 
10 LINE 6 COLUMN 9 VALUE 'Last Name'. 
10 
COLUMN 25 VALUE 'Fi rst'. 
10 
COLUMN 36 VALUE 'Initial'. 
10 LINE 9 COLUMN 6 VALUE 'Car Information:'. 
10 LINE 10 COLUMN 12 VALUE 'Type Code:'. 
05 SCREEN-INPUTS. 
10 
SCR-CONTRACT-NO 
LINE 3 COLUMN 20 
PIC 9(6) USING REN-CONTRACT-NO 
REVERSE-VIDEO. 

The 
Tuition 
Billing 
Program 
Revisited 
(continued) 
10 SCR-LAST-NAME 
LINE 7 COLUMN 9 
10 SCR-FIRST-NAME 
LINE 7 COLUMN 25 
10 SCR-INITIAL 
LINE 7 COLUMN 36 
10 SCR-CAR-TYPE 
LINE 10 COLUMN 23 
PIC X(15) USING REN-LAST-NAME 
REVERSE-VIDEO. 
PIC X(10) USING REN-FIRST-NAME 
REVERSE-VIDEO. 
PIC X 
USING REN-INITIAL 
REVERSE-VIDEO. 
PIC X 
USING REN-CAR-TYPE 
REVERSE-VIDEO AUTO. 
01 UPDATE-SCREEN. 
05 LINE 11 COLUMN 67 
LINE 12 COLUMN 38 
UPD-DAILY-RATE 
LINE 12 COLUMN 50 
UPD-DAILY-TOTAL 
COLUMN 63 
LINE 14 COLUMN 37 
UPD-MILES-DRIVEN 
COLUMN 50 
UPD-MILEAGE-TOTAL 
05 
05 
05 
05 
05 
05 
05 
05 
05 
05 
05 
05 
LINE 15 COLUMN 64 
LINE 16 COLUMN 35 
UPD-INSURANCE-RATE 
LINE 16 COLUMN 51 
UPD-INSURANCE-TOTAL 
COLUMN 64 
LINE 17 COLUMN 63 
LINE 18 COLUMN 48 
UPD-AMOUNT-DUE 
COLUMN 62 
VALUE 'Totals' HIGHLIGHT. 
VALUE 'Rental Rate:' HIGHLIGHT. 
PIC $$$9.99 FROM IND-DAILY-RATE 
HIGHLIGHT. 
PIC $$$,$$9.99 FROM IND-DAILY-TOTAL 
HIGHLIGHT. 
VALUE 'Miles Driven:
1 HIGHLIGHT. 
PIC 111,129 FROM IND-MILES-DRIVEN 
HIGHLIGHT. 
PIC $$,$$9.99 
FROM IND-MILEAGE-TOTAL 
HIGHLIGHT. 
VALUE 'Insurance Rate:' HIGHLIGHT. 
PIC $$9.99 FROM INSURANCE-RATE 
HIGHLIGHT. 
PIC $$,$$9.99 
FROM IND-INSURANCE-TOTAL 
HIGHLIGHT. 
VALUE ' 
' HIGHLIGHT. 
VALUE 'Amount Due: ' HIGHLIGHT. 
PIC $$$$,$$9.99 FROM IND-AMOUNT-DUE 
HIGHLIGHT. 
screen (data) n a m e is optional at any other level; for example, the first 05-level entry 
in Figure 10.6 omits the screen (data) n a m e a n d specifies a blank screen with a blue 
background and white foreground. The next 05-level entry includes a data n a m e , 
S C R E E N - P R O M P T S , which is divided into multiple elementary items, each of which 
omits the data n a m e . 
If a screen (data) n a m e or FILLER is specified, then it must be the first w o r d 
following the level n a m e . The remaining clauses can appear in any order, but each 
elementary item must contain at least one of the following clauses: BELL, B L A N K 
LINE, B L A N K S C R E E N , C O L U M N , LINE, P I C T U R E , or V A L U E . (The V A L U E 
and P I C T U R E clauses are mutually exclusive in the Screen Section.) A n y clause 
that appears o n a group item applies to all elementary items within the group where 
it is allowed. If the s a m e clause is specified at multiple levels in the hierarchy, the 
lowest level takes effect. The various optional clauses are illustrated in Figure 10.6 
and function as explained previously in conjunction with the A C C E P T a n d 
DISPLAY statements. 

Chapter 
10 
Screen 
1-0 
Note, too, the correspondence between the line a n d c o l u m n positioning within 
S C R E E N - P R O M P T S and S C R E E N - I N P U T ; for example, a prompt for 'Contract No:' 
appears o n line 3 a n d extends from column 7 to 18; the data n a m e S C R - C O N T R A C T -
N O is subsequendy accepted in column 20 o n the s a m e line. T h e action of the LINE 
a n d C O L U M N clauses is the s a m e as with individual A C C E P T a n d D I S P L A Y 
statements: omission of the LINE clause defaults to the s a m e line as the previously 
specified element. Thus the prompt for last n a m e is displayed o n line 6, column 9 
followed by the prompt for first n a m e in column 25 of the s a m e line, followed by the 
initial in c o l u m n 36 of the s a m e line. 
The Screen Section makes possible the definition of multiple screens within 
the s a m e program as implied by the screen in Figure 10.5c, in which the c o m p u t e d 
results are displayed o n the s a m e (expanded) screen as the original inputs. Thus the 
Screen Section in Figure 10.6 contains a second 01 entry, U P D A T E - S C R E E N , with 
multiple entries that display both text a n d computed information; the latter is 
displayed after all data have been entered a n d the bill has been computed. 
The TO clause in a screen description entry indicates a n input field; the FROM 
clause indicates an output field. T h e USING clause—for example, U S I N G REN-
C O N T R A C T - N O — i s equivalent to the combination of F R O M a n d T O clauses each 
specifying the s a m e data n a m e . In this instance the screen input in line 3, c o l u m n 
20 is accepted from and/or m o v e d to the data n a m e SCR-CONTRACT-NO, which is 
defined elsewhere in the Data Division. 
Unlike the A C C E P T a n d D I S P L A Y statements, S C R E E N 
S E C T I O N 
F O R E G R O U N D - C O L O R a n d B A C K G R O U N D - C O L O R can use identifiers as well as 
integers. Level-78 can be used as well. However, the B R I G H T colors are not 
acceptable. Using values 0-7 a n d H I G H L I G H T is the equivalent of 8-15. 
Hierarchy Chart 
The hierarchy chart in Figure 10.7 combines the functions of the data validation 
and reporting programs of Chapters 8 and 9. T h e second-level module, P R O C E S S -
R E N T A L - R E C O R D S , effectively drives the program a n d contains subordinates to 
VALIDAI E-REN'I A L - R E C O R D , C O M P U T E - I N D - B I L L , W R I T E - V A L 1 D - R E C O R D , and 
I N P U T - S C R E E N - C O N F I R M . 
The validation module, VALI D A T E - R E N T A L - R E C O R D , contains a lower-level 
module for every validity check (identical to those in Chapter 8), each of which calls 
a c o m m o n routine that displays the indicated error message or clears the error line. 
The computation module, C O M P U T E - I N D - B I L L , has three subordinates of its o w n : 
C O M P U T E - M I L E A G E - T O T A L , C O M P U T E - D A I L Y - T O T A L , a n d C O M P U T E -
I N S U R A N C E - T O T A L . T h e remaining modules under P R O C E S S - R E N T A L - R E C O R D S 
write the validated record, then determine whether another record is to be processed. 
Pseudocode 
T h e pseudocode in Figure 10.8 is driven by a n overall loop to process transactions 
until the user elects to quit. Each n e w transaction begins with validation of individual 
fields, which continues until the user indicates that the entire screen is accurate; 
that is, the user is given the opportunity to change any field that has been previously 
validated. Within this loop, each field is validated interactively; that is, the user 
cannot enter the next field until the current field has been accepted as valid. 
O n c e all fields have been entered a n d validated, the program m o v e s to the 
computation of the bill according to the specifications presented earlier. T h e 
computed bill is displayed o n the screen, the validated record is written to a valid 
record file, a n d the user is given the opportunity to process another transaction. 

The 
Tuition 
Billing 
Program 
Revisited 
Hierarchy Chart 
VALIDATE 
CONTRACT 
NUMBER 
w 
DISPLAY 
ERROR 
MESSAGE 
VALIDATE 
RENTAL 
RECORD 
INPUT 
SCREEN 
CONFIRM 
PRODUCE 
CUSTOMER 
BILLS 
CLEAR 
ERRORS 
PROCESS 
RENTAL 
RECORDS 
COMPUTE 
IND 
BILL 
COMPUTE 
MILEAGE 
TOTAL 
WRITE 
VALID 
RECORD 
COMPUTE 
DAILY 
TOTAL 
DISPLAY 
ERROR 
MESSAGE 
INPUT 
SCREEN 
CONFIRM 
COMPUTE 
INSURANCE 
TOTAL 
CLEAR 
ERRORS 
Pseudocode for Car Validation and Billing Program (Screen Version) 
Open valid-rental-file 
j 
Get today's date 
| 
DO WHILE another record is desired 
• DO UNTIL information correct 
r-- DO UNTIL valid-field-switch = spaces 
Accept contract number 
r - IF contract number = zeros 
! 
Display 'Contract number must not be zero' 
'. 
Move 'NO' to valid-field-switch 
! 
ELSE 
| 
Move spaces to valid-field-switch 
j 
^ - ENDIF 
| 
ENDDO 
\ 
I 1 

Chapter 
10 — 
Screen 
I-
(coniinued) 
i 
] 
DO UNTIL valid-field-switch = spaces 
| 
Accept last-name 
| 
J {— IF last-name = spaces 
j 
| 
Display 'Error - Missing last name' 
| 
j 
Move 'NO' to valid-field-switch 
j 
I 
ELSE 
S I 
Move spaces to valid-field-switch 
j | — ENDIF 
I 
ENDDO 
I 
. . . Validation checks for remaining fields 
| 
Display information correct message 
I 
p- DO UNTIL valid confirmation ("Y", "y", "N", or "n") 
j 
Accept confirm-switch 
I 
'— IF valid confirmation 
Clear previous error message 
ELSE 
I 
Display 'Must be "Y" or "N"' 
| 
L . ENDIF 
! | — ENDDO 
l- ENDDO 
Compute miles driven = miles in - miles out 
r - DO CASE 
| 
Car Type E - Move economy rate to mileage rate 
Car lype C - Move compact rate to mileage rate 
Car Type M - Move midsize to mileage rate 
Car Type F - Move full size rate to mileage rate 
Car Type L - Move luxury rate to mileage rate 
L - END CASE 
Compute mileage total = miles driven * mileage rate 
Compute daily total = days rented * daily rate 
— IF insurance taken 
Compute insurance = insurance rate * days rented 
—• END-IF 
Compute total bill = mileage amount + daily amount + insurance 
Display computed bill 
Write valid record to valid record file 
Display Another record message 
— DO UNTIL valid confirmation ("Y", " y " , "N", or "n") 
Accept confirm-switch 
— IF valid confirmation 
Clear previous error message 
f 
ELSE 
| 
Display 'Must be "Y" or "N"' 
I 
— ENDIF 
I— ENDDO 
- ENDDO 
Close valid-rental-file 
Stop run 

The 
Tuition
1 
Billing 
Program 
Revisited 
The completed program is s h o w n in Figure 10.9 and includes m a n y statements 
from the earlier programs in Chapters 8 and 9. T h e most significant difference 
is that 1-0 is screen based, with transactions entered via the keyboard a n d 
computed results displayed o n the monitor, as provided through the extended 
Screen Section (lines 135-244). The program also creates a VALID-RENTAL-FILE 
as output, illustrating that the same program can contain both a File Section and 
a Screen Section 
Car Validation and Billing Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
SCRNCARS. 
AUTHOR. 
CVV. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT VALID-RENTAL-FILE 
ORGANIZATION IS LINE 
DATA DIVISION. 
ASSIGN TO 'A:\CHAPTR10\VALRENT.DAT' 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
FD VALID-RENTAL-FILE. 
01 VALID-RENTAL-RECORD 
WORKING-STORAGE SECTION. 
01 RENTAL-RECORD-IN. 
05 REN-CONTRACT-NO 
05 REN-NAME. 
10 REN-LAST-NAME 
10 REN-FIRST-NAME 
10 REN-INITIAL 
05 REN-RETURNED-DATE. 
10 REN-RETURNED-YEAR 
10 REN-RETURNED-MONTH 
88 VALID-MONTHS 
88 FEBRUARY 
88 30-DAY-M0NTH 
88 31-DAY-M0NTH 
10 REN-RETURNED-DAY 
05 REN-CAR-TYPE 
88 VALID-CAR-TYPES 
05 REN-DAYS-RENTED 
88 ZERO-DAYS-RENTED 
88 VALID-DAYS-RENTED 
05 REN-MILEAGE. 
10 REN-MILES-IN 
10 REN-MILES-OUT 
PIC X(57). 
PIC 9(6). 
PIC X(15). 
PIC X(10). 
PIC X. 
PIC 9(2). 
PIC 9(2). 
VALUES 1 
VALUE 2. 
VALUES 4 
THRU 12. 
VALUES 
PIC 9(2). 
PIC X. 
VALUES 
PIC 99. 
VALUE 
VALUES 
PIC 9(6). 
PIC 9(6). 
1 3 
9 11. 
5 7 8 10 12. 
'E' 'C 'M' 'F' 
THRU 35. 

Chapter 
10 — 
Screen 
l-O 
(continued) 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
01 
01 
10 REN-MILEAGE-RATE 
PIC V99. 
88 VALID-MILEAGE-RATES 
VALUES 00 THRU .50. 
05 REN-INSURANCE 
PIC X. 
88 VALID-INSURANCE 
VALUE 'Y' 'y' 'N' 
88 INSURANCE 
VALUE 'Y' 'y'. 
01 
PROGRAM-SWITCHES-AND-CONSTANTS. 
05 
05 
MILES-PER-DAY-FACTOR 
VALID-FIELD-SWITCH 
88 VALID-FIELD 
05 CONFIRM-SWITCH 
I N F 0 _ C 0 R R E C T 
NO-MORE-RECORDS 
VALID-CONFIRMED 
PIC 99 
PIC XX. 
PIC X 
VALUE 10. 
VALUE SPACES. 
VALUE SPACES. 
VALUE 'Y' 'y' 
VALUE 'N' V 
VALUE 'N' 'n' 
TODAYS-DATE-INFORMATION. 
05 TODAYS-DATE. 
10 TODAYS-YEAR 
10 TODAYS-MONTH 
10 TODAYS-DAY 
05 SCREEN-DATE 
PIC 99. 
PIC 99. 
PIC 99. 
PIC X(8). 
CONFIRM-MESSAGES. 
05 CONHRM-MESSAGE 
PIC X(27). 
05 INFO-CORRECT-MESSAGE 
PIC X(27) 
VALUE 'Above information correct? 
05 ANOTHER-RECORD-MESSAGE PIC X(27) 
VALUE ' 
Enter Another Record? 
01 
ERROR-MESSAGES. 
05 ERROR-MESSAGE 
PIC X(40). 
05 ZERO-CONTRACT-NO-MSG 
PIC X(40) 
VALUE ' 
CONTRACT NUMBER MUST NOT BE ZERO'. 
05 LAST-NAME-MSG 
PIC X(40) 
VALUE ' 
MISSING LAST NAME'. 
05 FIRST-NAME-MSG 
PIC X(40) 
VALUE ' 
MISSING FIRST NAME'. 
05 INITIAL-MSG 
PIC X(40) 
VALUE ' 
NON ALPHABETIC INITIAL'. 
05 CAR-TYPE-MSG 
PIC X(40) 
VALUE
 1 CAR TYPE MUST BE: E, C, M, F, OR L'. 
05 MONTH-MSG 
PIC X(40) 
VALUE ' 
MONTH MUST BE BETWEEN 1 AND 12'. 
05 DAY-MSG 
PIC X(40) 
VALUE ' 
INVALID DAY'. 
05 FUTURE-DATE-MSG 
PIC X(40) 
VALUE ' 
DATE HAS NOT YET OCCURRED'. 
05 NON-NUM-DAYS-RENTED-MSG PIC X(40) 
VALUE ' 
DAYS RENTED MUST BE NUMERIC. 
05 ZERO-DAYS-MSG 
PIC X(40) 

The 
Tuition 
Billing 
Program 
Revisited 
, i < i 
(continued) 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
01 
01 
01 
VALUE
 1 
DAYS RENTED MUST BE > ZERO'. 
05 LEASING-MSG 
PIC X(40) 
VALUE ' 
REFER TO LONG-TERM LEASING'. 
05 NON-NUM-MILES-IN-MSG 
PIC X(40) 
VALUE ' 
NON-NUMERIC MILES IN'. 
05 NON-NUM-MILES-OUT-MSG PIC X(40) 
VALUE
 1 
NON-NUMERIC MILES OUT'. 
05 LESS-THAN-MILES-MSG 
PIC X(40) 
VALUE
 1 
MILEAGE IN LESS THAN MILEAGE OUT' 
05 INVALID-MILES-MSG 
PIC X(40) 
VALUE
 1 
MILES DRIVEN UNREASONABLY L O W . 
05 NON-NUM-RATE-MSG 
PIC X(40) 
VALUE ' 
NON-NUMERIC MILEAGE RATE'. 
05 MILEAGE-RATE-MSG 
PIC X(40) 
VALUE ' 
MILEAGE RATE OUT OF RANGE'. 
05 INSURANCE-MSG 
PIC X(40) 
VALUE ' 
INSURANCE CODE MUST BE Y OR N'. 
05 YES-NO-MSG 
PIC X(40) 
VALUE ' 
MUST BE "Y" OR 
"N"'. 
DAI LY-RATES. 
05 ECONOMY-RATE 
PIC 9(3)V99 VALUE 15. 
05 COMPACT-RATE 
PIC 9(3)V99 VALUE 20. 
05 MID-RATE 
PIC 9(3)V99 VALUE 24. 
05 FULL-RATE 
PIC 9(3)V99 VALUE 28. 
05 LUXURY-RATE 
PIC 9(3)V99 VALUE 35. 
05 INSURANCE-RATE 
PIC 99V99 
VALUE 10.50 
IND -BILL-INFORMATION. 
05 IND-MILES-DRIVEN 
PIC 9(6). 
05 IND-DAILY-RATE 
PIC 9(3)V99. 
05 IND-DAILY-TOTAL 
PIC 9(5)V99. 
05 IND-MILEAGE-TOTAL 
PIC 9(4)V99. 
05 IND-INSURANCE-TOTAL 
PIC 9(4)V99. 
05 IND-AMOUNT-DUE 
PIC 9(6)V99. 
SCREEN-COLORS. 
05 BLUE 
05 CYAN 
05 RED 
05 MAGENTA 
05 WHITE 
05 BRIGHT-GREEN 
05 BRIGHT-MAGENTA 
05 BRIGHT-WHITE 
PIC S9(4) 
PIC S9(4) 
PIC S9(4) 
PIC S9(4) 
PIC S9(4) 
PIC S9(4) 
PIC S9(4) 
PIC S9(4) 
COMP-5 VALUE 1. 
COMP-5 VALUE 3. 
COMP-5 VALUE 4. 
COMP-5 VALUE 5. 
COMP-5 VALUE 7. 
COMP-5 VALUE 10. 
COMP-5 VALUE 13. 
COMP-5 VALUE 15. 
iSCREEN SECTION. 
01 OPENING-SCREEN. 
05 BLANK SCREEN 
BACKGROUND-COLOR BLUE FOREGROUND-COLOR WHITE. 

Chapter 
10 — 
Screen 
l-O 
c 
(continued) 
139 
05 SCREEN-PROMPTS. 
140 
10 LINE 1 BLANK LINE BACKGROUND-COLOR MAGENTA. 
[ 
141 
10 
COLUMN 20 VALUE 'Mavis Car Rental Company' 
, 
142 
BACKGROUND -COLOR MAGENTA 
143 
FOREGROUND -COLOR BRIGHT-GREEN. 
144 
10 SCR-DATE 
PIC X(8) FROM SCREEN-DATE 
145 
COLUMN 55 BACKGROUND-COLOR MAGENTA 
146 
FOREGROUND-COLOR BRIGHT-GREEN. 
147 
10 LINE 3 COLUMN 7 VALUE 'Contract No:'. 
148 
J0_ LINE 5 COLUMN 7 VALUE 'Customer Information:
1. 
149 
! 10 LINE 6 COLUMN 9 VALUE 'Last Name
1. ; 
150 
! 10 
COLUMN 25 VALUE 'First'. 
' 
151 
10 
COLUMN 36 VALUE 'Initial'. 
152 
10 LINE 9 COLUMN 6 VALUE 'Car Information:'. 
153 
10 LINE 10 COLUMN 12 VALUE 'Type Code:'. 
154 
10 
COLUMN 25 
155 
VALUE '(Compact, Economy, Midsize, Fullsize, Luxury)' 
156 
FOREGROUND -COLOR CYAN. 
157 
10 
COLUMN 26 VALUE 'C HIGHLIGHT. 
158 
10 
COLUMN 35 VALUE ' E' HIGHLIGHT. 
159 
10 
COLUMN 44 VALUE 'M' HIGHLIGHT. 
160 
10 
COLUMN 53 VALUE 'F' HIGHLIGHT. 
161 
10 
COLUMN 63 VALUE 'L' HIGHLIGHT. 
162 
10 LINE 11 COLUMN 8 VALUE 'Date Returned:'. 
163 
10 
COLUMN 23 VALUE 'mm/dd/yy' 
164 
FOREGROUND -COLOR BRIGHT-WHITE. 
165 
10 LINE 12 COLUMN 10 VALUE 'Days Rented:'. 
166 
10 LINE 13 COLUMN 10 VALUE 'Mileage:'. 
167 
10 LINE 14 COLUMN 13 VALUE 'Miles In:'. 
168 
10 LINE 15 COLUMN 12 VALUE 'Miles Out:'. 
169 
10 
COLUMN 37 VALUE 'Mileage Rate:'. 
170 
10 LINE 16 COLUMN 12 VALUE ' Insurance:'. 
171 
10 
COLUMN 25 VALUE '(Y/N)' 
172 
FOREGROUND--COLOR CYAN. 
173 
174 
05 SCREEN-INPUTS. 
175 
10 SCR-CONTRACT-NO 
PIC 9(6) USING REN-CONTRACT-NO 
176 
LINE 3 COLUMN 20 REVERSE-VIDEO. 
177 
10 SCR-LAST-NAME 
PIC X(15) USING REN-LAST-NAME 
178 
LINE 7 COLUMN 9 REVERSE-VIDEO. 
179 
10 SCR-FIRST-NAME 
PIC X( 10) USING REN-FIRST-NAME 
180 
LINE 7 COLUMN 25 REVERSE-VIDEO. 
181 
10 SCR-INITIAL 
PIC X 
USING REN-INITIAL 
'< 
182 
LINE 7 COLUMN 36 REVERSE-VIDEO. 
183 
10 SCR-CAR-TYPE 
PIC X 
USING REN-CAR-TYPE 
184 
LINE 10 COLUMN 23 REVERSE-VIDEO AUTO. 
185 
10 SCR-RETURNED-MONTH PIC 99 USING REN-RETURNED-MONTH 
186 
LINE 11 COLUMN 23 REVERSE-VIDEO AUTO. 
t 
187 
10 SCR-RETURNED-DAY 
PIC 99 
USING REN-RETURNED-DAY 
> 
188 
LINE 11 COLUMN 26 REVERSE-VIDEO AUTO. 

The 
Tuition 
Billing 
Program 
Revisited 
(continued) 
189 
10 SCR-RETURNED-YEAR PIC 99 USING REN-RETURNED-YEAR 
190 
LINE 11 COLUMN 29 REVERSE-VIDEO AUTO. 
191 
10 
SCR-DAYS-RENTED 
PIC 99 
USING REN-DAYS-RENTED 
192 
LINE 12 COLUMN 23 REVERSE-VIDEO AUTO. 
193 
10 SCR-MILES-IN 
PIC 111,119 
USING REN-MILES-IN 
194 
LINE 14 COLUMN 23 REVERSE-VIDEO. 
195 
10 SCR-MILES-OUT 
PIC 111,119 
USING REN-MILES-OUT 
196 
LINE 15 COLUMN 23 REVERSE-VIDEO. 
197 
10 
SCR-MILEAGE-RATE 
PIC .99 USING REN-MILEAGE-RATE 
198 
LINE 15 COLUMN 54 REVERSE-VIDEO. 
199 
10 SCR-INSURANCE 
PIC X 
USING REN-INSURANCE 
200 
LINE 16 COLUMN 23 REVERSE-VIDEO AUTO. 
201 
05 LINE 24 BLANK LINE. 
202 
05 
LINE 25 BLANK LINE. 
203 
' ' "
/
; -
d
,
7
t
e
,
b
£ " ^ " ' ' ; '
c
;
; ' ^ 
'•<•'•-••'•< 
204 
!01 
UPDATE-SCREEN.i' 
205 
05 
LINE 11 COLUMN 67 
VALUE 'Totals' HIGHLIGHT. 
206 
05 LINE 12 COLUMN 38 
VALUE 'Rental Rate:' HIGHLIGHT. 
207 
05 UPD-DAILY-RATE 
PIC $$$9.99 FROM IND-DAILY-RATE 
208 
LINE 12 COLUMN 50 
HIGHLIGHT. 
209 
05 UPD-DAILY-TOTAL 
PIC $$$,$$9.99 FROM IND-DAILY-TOTAL 
210 
COLUMN 63 
HIGHLIGHT. 
91 
1 
CXI 
n c 
i tuc 1/1 rni i imm m 
i-itii. j.-r vui-urm *t i 
Vlfll IIC 
l l l i ] ^ nvi'.mn.l UTCUI ICUT 
¥ nuuL. riiiwj u I i «cu. 
iiiuml^uii I . 
111 
05 UPD-MILES-DRIVEN 
PIC 111,119 
FROM IND-MILES-DRIVEN 
213 
COLUMN 50 
HIGHLIGHT. 
214 
05 UPD-MILEAGE-TOTAL 
PIC $$,$$9.99 
215 
FROM IND-MILEAGE-TOTAL 
216 
LINE 15 COLUMN 64 
HIGHLIGHT. 
217 
05 LINE 16 COLUMN 35 
VALUE 'Insurance Rate:' HIGHLIGHT. 
218 
05 UPD-INSURANCE-RATE 
PIC $$9.99 FROM INSURANCE-RATE 
219 
LINE 16 COLUMN 51 
HIGHLIGHT. 
220 
05 UPD-INSURANCE-TOTAL 
PIC $$,$$9.99 
221 
FROM IND-INSURANCE-TOTAL 
222 
COLUMN 64 
HIGHLIGHT. 
223 
05 LINE 17 COLUMN 63 
VALUE ' 
' HIGHLIGHT. 
224 
05 LINE 18 COLUMN 48 
VALUE 'Amount Due: ' HIGHLIGHT. 
225 
05 UPD-AMOUNT-DUE 
PIC $$$$,$$9.99 FROM IND-AMOUNT-DUE 
226 
COLUMN 62 
HIGHLIGHT. 
227 
228 
01 ERROR-LINE. 
229 
05 LINE 25 BLANK LINE BACKGROUND-COLOR RED. 
230 
05 
PIC X(40) FROM ERROR-MESSAGE 
231 
COLUMN 20 
HIGHLIGHT BLINK BEEP 
232 
FOREGROUND-COLOR BRIGHT-WHITE BACKGROUND-COLOR RED. 
233 
234 
01 CONFIRM-SCREEN. 
235 
05 LINE 24 BLANK LINE 
BACKGROUND-COLOR MAGENTA. 
236 
05 
PIC X(27) FROM CONFIRM-MESSAGE 
237 
LINE 24 COLUMN 25 
238 
BACKGROUND-COLOR MAGENTA FOREGROUND-COLOR BRIGHT-GREEN. 

Chapter 
10 — 
Screen 
l-O 
'{ 
" 
(continued) 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
05 
05 
05 
PIC X USING CONFIRM-SWITCH 
LINE 24 COLUMN 52 
BLINK AUTO 
BACKGROUND-COLOR MAGENTA FOREGROUND-COLOR BRIGHT-GREEN. 
LINE 25_BLAI^LINEJBACraROU(W-COLOR MAGENTA^ 
LINE 25 COLUMN 32 
VALUE '(V - Yes, N~- No)
1 
BACKGROUND-COLOR MAGENTA FOREGROUND-COLOR BRIGHT-GREEN. 
PROCEDURE DIVISION. 
^Cc-rnmna'ion cv crs-: 
000-CREATE-VALID-RENTAL-FILE. 
OPEN OUTPUT VALID-RENTAL-FILE. 
PERFORM 100-GET-TODAYS-DATE. 
PERFORM 200-INPUT-RENTAL-RECORDS 
UNTIL NO-MORE-RECORDS. 
CLOSE VALID-RENTAL-FILE. 
STOP RUN. 
100-GET-TODAYS-DATE. 
ACCEPT TODAYS-DATE FROM DATE. 
STRING TODAYS-MONTH '/' TODAYS-DAY '/' TODAYS-YEAR 
DELIMITED BY SIZE INTO SCREEN-DATE. 
200-INPUT-RENTAL-RECORDS. 
INITIALIZE RENTA1-RFCORD-IN. 
PERFORM 400-VALIDATE-RENTAL-RECORD WITH TEST AFTER 
UNTIL INFO-CORRECT. 
PERFORM 500-COMPUTE-IND-BILL. 
DISPLAY UPDATE-SCREEN. 
PERFORM 600-WRITE-VALID-RECORD. 
MOVE ANOTHER-RECORD-MESSAGE TO CONFIRM-MESSAGE. 
PERFORM 700-INPUT-SCREEN-CONFIRM. 
400-VALI DATE-RENTAL-RECORD. 
-DISPL A Y 
•i^m^v 
DI SPLAY OPEN ING-SCRFEN.- ' ' 
PERFORM 410-VALIDATE-C0NTRACT-N0. 
PERFORM 420-VALIDATE-NAME. 
PERFORM 430-VALIDATE-CAR-TYPE. 
PERFORM 440-VALIDATE-DATE-RETURNED 
WITH TEST AFTER UNTIL VALID-FIELD. 
PERFORM 450-VALIDATE-DAYS-RENTED. 
PERFORM 460-VALIDATE-MILES-DRIVEN. 
PERFORM 470-VALIDATE-MILEAGE-RATE. 
PERFORM 480-VALIDATE-INSURANCE. 
MOVE INFO-CORRECT-MESSAGE TO CONFIRM-MESSAGE. 
PERFORM 700-INPUT-SCREEN-CONFIRM. 
410-VALIDATE-C0NTRACT-N0. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-CONTRACT-NO 
IF REN-CONTRACT-NO = ZEROES 
MOVE ZERO-CONTRACT-NO-MSG TO ERROR-MESSAGE 

The 
Tuition 
Billing 
Program 
Revisited 
(continued) 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
in/1 
305 
306 
307 
308 
309 
310 
n i l 
o n 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
3 3 8 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
ELSE 
PERFORM 498-CLEAR-ERRORS 
E N D - I F 
END-PERFORM. 
4 2 0 - V A L I D A T E - N A M E . 
PERFORM WITH TEST A F T E R U N T I L VALID-FIELD 
ACCEPT SCR-LAST-NAME 
IF REN-LAST-NAME = SPACES 
M O V E LAST-NAME-MSG TO ERROR-MESSAGE 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
ELSE 
PERFORM 498-CLEAR-ERRORS 
E N D - I F 
END-PERFORM. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-FIRST-NAME 
IF REN-FIRST-NAME = SPACES 
M O V E FIRST-NAME-MSG TO ERROR-MESSAGE 
PERFORM 4 9 9 - D I S P L A Y - E R R O R - M E S S A G E 
ELSE 
n c n c n n M 
nno 
ri 
c a d rnnnnc 
r Li\rui\n tju"ULLni\-Li\i\uiw 
E N D - I F 
END-PERFORM. 
PERFORM WITH TEST A F T E R U N T I L VALID-FIELD 
ACCEPT SCR-INITIAL 
IF REN-INITIAL N O T A L P H A B E T I C 
M O V E INITIAL-MSG T O ERROR-MESSAGE 
PERFORM 4 9 9 - D I S P L A Y - E R R O R - M E S S A G E 
E L S E 
PERFORM 498-CLEAR-ERRORS 
E N D - I F 
END-PERFORM. 
4 3 0 - V A L I D A T E - C A R - T Y P E . 
PERFORM WITH TEST A F T E R U N T I L V A L I D - F I E L D 
A C C E P T S C R - C A R - T Y P E 
I F N O T V A L I D - C A R - T Y P E S 
M O V E C A R - T Y P E - M S G TO E R R O R - M E S S A G E 
PERFORM 4 9 9 - D I S P L A Y - E R R O R - M E S S A G E 
ELSE 
PERFORM 4 9 8 - C L E A R - E R R O R S 
E N D - I F 
END-PERFORM. 
440-VALIDATE-DATE-RETURNED. 
PERFORM WITH TEST A F T E R U N T I L V A L I D - F I E L D 
A C C E P T S C R - R E T U R N E D - M O N T H 
IF VALID-MONTHS 

Chapter 
10 
Screen 
1-0 
re iQM 
(continued) 
339 
PERFORM 498-CLEAR-ERRORS 
340 
ELSE 
341 
MOVE MONTH-MSG TO ERROR-MESSAGE 
342 
PERFORM 499-0ISPLAY-ERR0R-MESSAGE 
343 
END-IF 
344 
END-PERFORM. 
345 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
346 
ACCEPT SCR-RETURNED-DAY 
347 
IF 30-DAY-MONTH AND REN-RETURNED-DAY > 0 AND <= 30 OR 
348 
31-DAY-MONTH AND REN-RETURNED-DAY > 0 AND <= 31 OR 
349 
FEBRUARY AND REN-RETURNED-DAY > 0 AND <= 29 
350 
PERFORM 498-CLEAR-ERRORS 
351 
ELSE 
352 
MOVE DAY-MSG TO ERROR-MESSAGE 
353 
PERFORM 499-DI SPLAY-ERROR-MESSAGE 
354 
END-IF 
355 
END-PERFORM. 
356 
| PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
357 
I 
ACCEPT SCR-RETURNED-YEAR 
358 
IF REN-RETURNED-DATE > TODAYS-DATE 
359 
MOVE FUTURE-DATE-MSG TO ERROR-MESSAGE 
360 
PERFORM 499-DI SPLAY-ERROR-MESSAGE 
361 
ELSE 
362 
| 
PERFORM 498-CLEAR-ERRORS 
363 
; 
END-IF 
364 
j END-PERFORM. 
365 
1 
366 
450-VALIDATE-DAYS-RENTED. 
j 
367 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
j 
368 
ACCEPT SCR-DAYS-RENTED 
j 
369 
IF ZERO-DAYS-RENTED 
j 
370 
MOVE ZERO-DAYS-MSG TO ERROR-MESSAGE 
j 
371 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
I 
372 
ELSE 
f 
373 
IF NOT VALID-DAYS-RENTED 
j 
374 
MOVE LEASING-MSG TO ERROR-MESSAGE 
I 
375 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
376 
ELSE 
j 
377 
PERFORM 498-CLEAR-ERRORS 
i 
378 
END-IF 
\ 
379 
END-IF 
1 
380 
END-PERFORM. 
j 
381 
I 
382 
460-VALIDATE-MILES-DRIVEN. 
| 
383 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
j 
384 
ACCEPT SCR-MILES-IN 
I 
385 
ACCEPT SCR-MILES-OUT 
[ 
386 
IF REN-MILES-IN < REN-MILES-OUT 
[ 
387 
MOVE LESS-THAN-MILES-MSG TO ERROR-MESSAGE 
| 
388 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
\ 

The 
Tuition 
Billing 
Program 
Revisited 
(continued) 
j 
389 
ELSE 
390 
IF REN-MILES-IN - REN-MILES-OUT < 
391 
MILES-PER-DAY-FACTOR * REN-DAYS-RENTED 
j 
392 
MOVE INVALID-MILES-MSG TO ERROR-MESSAGE 
j 
393 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
j 
394 
ELSE 
| 
395 
PERFORM 498-CLEAR-ERRORS 
j 
396 
END-IF 
j 
397 
END-IF 
{ 
398 
END-PERFORM. 
| 399 
j 
400 
470-VALIDATE-MILEAGE-RATE. 
_ 
_ 
I 
401 
(PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
" j 
j 
402 
j 
ACCEPT SCR-MILEAGE-RATE 
) 
403 
IF NOT VALID-MILEAGE-RATES 
| 
| 
404 
MOVE MILEAGE-RATE-MSG TO ERROR-MESSAGE I 
I 
405 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
i 
[ 
406 
| 
ELSE 
; 
j 
407 
| 
PERFORM 498-CLEAR-ERRORS 
I 
408 
| 
END-IF 
I 
409 
j END-PERFORM. 
| 410 
( 
411 
480-VALIDATE-INSURANCE. 
j 
412 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
) 
413 
ACCEPT SCR-INSURANCE 
| 
414 
IF NOT VALID-INSURANCE 
j 
415 
MOVE INSURANCE-MSG TO ERROR-MESSAGE 
I 
416 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
j 
417 
ELSE 
| 
418 
PERFORM 498-CLEAR-ERRORS 
j 
419 
END-IF 
1 
420 
END-PERFORM. 
j 421 
j 
422 
498-CLEAR-ERRORS. 
j 
423 
INITIALIZE VALID-FIELD-SWITCH. 
j 
424 
DISPLAY
 1 1 LINE 25 WITH BLANK LINE. 
| 425 
j 
426 
499-DISPLAY-ERROR-MESSAGE. 
j 
427 
MOVE 'NO' TO VALID-FIELD-SWITCH. 
I 
428 
DISPLAY ERROR-LINE. 
I
 
4 2 9 
j 
430 
500-COMPUTE-IND-BILL. 
J 431 
PERFORM 520-COMPUTE-MILEAGE-TOTAL. 
| 
432 
PERFORM 540-C0MPUTE-DAILY-T0TAL. 
I 
433 
PERFORM 560-COMPUTE-INSURANCE-TOTAL. 
I 
434 
COMPUTE IND-AMOUNT-DUE ROUNDED 
j 
435 
= IND-MILEAGE-TOTAL + IND-DAILY-TOTAL 
I 
436 
+ IND-INSURANCE-TOTAL 
437 
SIZE ERROR DISPLAY 'SIZE ERROR ON AMOUNT DUE FOR ' 
438 
REN-CONTRACT-NO 
439 
END-COMPUTE. 

Chapter 
10 — 
Screen 
I-O 
j 
440 
j 
441 
520-COMPUTE-MILEAGE-TOTAL. 
j 
442 
COMPUTE IND-MILES-DRIVEN 
443 
= REN-MILES-IN - REN-MILES-OUT 
444 
END-COMPUTE. 
445 
COMPUTE IND-MILEAGE-TOTAL ROUNDED 
j 
446 
= IND-MILES-DRIVEN * REN-MILEAGE-RATE 
I 
447 
SIZE ERROR 
t 
448 
DISPLAY 'COMPUTED BILL EXCESSIVELY LARGE' 
\ 
449 
END-COMPUTE. 
i 450 
! 
451 
540-C0MPUTE-DAILY-T0TAL. 
[ 
452 
[EVALUATE REN-CAR-TYPE 
I 
453 
| 
WHEN 'E' MOVE ECONOMY-RATE TO IND-DAILY-RATE 
| 
454 
WHEN 'C MOVE COMPACT-RATE TO IND-DAILY-RATE 
[ 
455 
! 
WHEN 'M' MOVE MID-RATE TO IND-DAILY-RATE 
j 
456 
WHEN 'F' MOVE FULL-RATE TO IND-DAILY-RATE 
j 
457 
, 
WHEN 'L' MOVE LUXURY-RATE TO IND-DAILY-RATE 
| 
458 
WHEN OTHER MOVE ZEROES TO IND-DAILY-RATE 
j 
459 
;END-EVALUATE. 
\ 
460 
MULTIPLY IND-DAILY-RATE BY REN-DAYS-RENTED 
j 
461 
GIVING IND-DAILY-TOTAL 
j 
462 
SIZE ERROR DISPLAY 'SIZE ERROR ON RENTAL TOTAL' 
j 
463 
END-MULTIPLY. 
464 
465 
560-COMPUTE-INSURANCE-JOTAL._ 
466 
[IF 
I
N
S
U
R
A
N
C
E
"
" 
I 
467 
i 
MULTIPLY INSURANCE-RATE BY REN-DAYS-RENTED 
| 
468 
j 
GIVING IND-INSURANCE-TOTAL 
I 
469 
[ 
SIZE ERROR DISPLAY 'SIZE ERROR ON INSURANCE TOTAL 
5 
470 
END-MULTIPLY 
[ 
471 
: ELSE 
| 
472 
MOVE ZEROES TO IND-INSURANCE-TOTAL 
| 
473 
END-IF. 
1 474 
"
~
"
"
" 
[ 
475 
600-WRITE-VALID-RECORD. 
j 
476 
WRITE VALID-RENTAL-RECORD FROM RENTAL-RECORD-IN. 
J 477 
I 
478 
700-INPUT-SCREEN-CONFIRM. 
I 
479 
DISPLAY CONFIRM-SCREEN. 
I 
480 
PERFORM WITH TEST AFTER UNTIL VALID-CONFIRMED 
[ 
481 
ACCEPT CONFIRM-SCREEN 
482 
IF VALID-CONFIRMED 
483 
PERFORM 498-CLEAR-ERRORS 
( 
484 
ELSE 
485 
MOVE YES-NO-MSG TO ERROR-MESSAGE 
486 
PERFORM 499-DISPLAY-ERROR-MESSAGE 
487 
END-IF 
488 
END-PERFORM. 
K^.r'c i 
(continued) 

Summary 
The requirements for the validation of individual fields parallel those in 
Chapter 8, and thus the table of error messages (lines 68-107) is repeated from the 
validation program. The validation process is different, however, as each field is 
checked interactively, so that the user cannot m o v e to the next field until a valid 
value has been entered for the current field. 
Consider, for example, the validation of car type in lines 324-333. The T E S T 
A F T E R clause guarantees that the performed statements are executed at least once; 
that is, the car type is accepted into SCR-CAR-TYPE (defined in lines 183-184), then 
tested by the IF statement in lines 327-332. A valid car type will reset VALID-FTELD-
S W I T C H to 'NO', which in turn satisfies the condition in the P E R F O R M statement 
in line 325. A n invalid response, however, displays the appropriate error message, 
then requests a n e w response from the user. A similar process is followed for the 
other fields in each transaction. A n appreciation for the interactive nature of the 
program can best be gained by executing the program as it exists o n the 
accompanying data disk. 
The remainder of the Procedure Division is straightforward with applicable 
paragraphs copied from the earlier programs—for example, C O M P U T E - M I L E A G E -
T O T A L , C O M P U T E - D A I L Y - T O T A L , and C O M P U T E - I N S U R A N C E - T O T A L . 
The Screen Section and extended options of the ACCEPT and DISPLAY 
statements are nor included in either the COBOL-74 or COBOL-85 standard, 
and thus there are no limitations per se in the earlier compiler In other words, 
any differences that do exist are due to vendor-specific extensions, which 
vary significantly from compiler to compiler. 
The extended screen handling capabilities in the Screen Section and the 
ACCEPT and DISPLAY statements are not part of the COBOL-85 standard. 
The examples in this chapter follow the syntax of the Classroom COBOL 
compiler that accompanies the text, which conforms to the X-Open standard. 
The ACCEPT and DISPLAY statements display individual lines and/or 
accept a limited number of fields as input. Both statements contain an 
abundance of optional clauses, the functions of which are generally apparent 
from the clause itself: BLINK, BEEP, 
BACKGROUND-COLOR, 
FOREGROUND-COLOR, and so forth. 
The Screen Section facilitates the production of uniform screens within a 
system as an entire screen may be easily copied from one program to the 
next. This is in contrast to individual ACCEPT and DISPLAY statements that 
are scattered throughout the Procedure Division. 

Chapter 
10 — 
Screen 
l-O 
The format of the Screen Section parallels that of the File and Working-
Storage sections in the Data Division; that is, it consists of 01-level entries 
that are further divided into group and elementary items. The Screen 
Section must be the last section in the Data Division. 
Data validation may be implemented interactively through an in-line perform 
and through TEST AFTER clauses, which accept a data name, perform the 
indicated validation, then repeat the process until a valid field has been 
entered. 
f Words 
and 
Concepts 
Alt key 
ASCII characters 
Background color 
Batch-oriented program 
Data validation 
Foreground color 
Interactive program 
Password protection 
Prompt 
Reversed video 
Screen attribute 
Screen-name 
ACCEPT 
AUTO 
BACKGROUND-COLOR 
COLUMN 
DISPLAY 
FOREGROUND-COLOR 
FROM 
HIGHLIGHT 
LINE 
REVERSE-VIDEO 
SCREEN SECTION 
SECURE 
TO 
USING 
/ N 
1. The Screen Section ( 
) part of the COBOL-85 standard. 
2. The typical screen displays 
lines of 
columns 
each. 
3. The 
clause in the ACCEPT statement prevents the user's response 
from being displayed on the monitor. 
4. The LINE and COLUMN clauses ( 
) required in the ACCEPT and/or 
DISPLAY statements 
5. The Screen Section is the ( 
) section in the Data Division. 
6. The 
key, in conjunction with the numeric keyboard, can be used 
to enter any of the 256 
characters into a program. 
7. In general, the foreground and background colors ( 
) be the 
same. 

Problems 
8. The ( 
) statement is often used in conjunction with top-down 
testing and/or debugging. 
9. An in-line PERFORM statement, coupled with the ( 
) 
clause, is used to implement interactive data validation. 
10. The 
facilitates the production of uniform screens 
within a system in that its entries can be easily copied from program to program. 
11. Screen l-O makes possible the implementation of ( 
) 
programs. 
12. An in-line perform, in conjunction with the TEST AFTER clause, can be used to  
a field as it is entered. 
1. The same COBOL program cannot contain a Screen Section and a File Section. 
2. The File Section is required in every program. 
3. The LINE and/or COLUMN clauses are required in the DISPLAY statement. 
4. The Screen Section is required in all programs that display output on the monitor. 
5. The ACCEPT and DISPLAY statements are used for low-volume output. 
6. The options and syntax for screen l-O are unlikely to change from one compiler to 
the next. 
7. Text is typically displayed on screens in which the foreground and background 
colors are the same. 
8. COBOL-85 makes little provision for screen l-O, and thus its implementation varies 
greatly from compiler to compiler. 
9. The optional clauses in the ACCEPT statement can appear in any order. 
10. Interactive data validation cannot be implemented in programs with extensive 
screen l-O. 
1. Which clause is used to implement the following in an ACCEPT and/or DISPLAY 
statement? 
a. Invert the specified or default background and foreground colors 
b. Prevent the referenced field from being displayed on the screen 
c. Require that at least one character is entered in the referenced field 
d. Automatically position the cursor to the first character of the next field after the 
last character of the current field has been entered 
e. Clear the screen before accepting (displaying) a data element 
f. Emphasize the displayed field (multiple clauses are acceptable) 

Chapter 
10 — 
Screen 
l-O 
2. Indicate the exact effect of each of the following DISPLAY statements. Note, 
however, that some of the statements are invalid syntactically, in which case you 
should indicate the nature of the error. Other statements are valid syntactically, but 
most probably do not do what the programmer intended. 
a. DISPLAY 
b. DISPLAY 'COMPUTE-TUITION paragraph is entered' 
c. DISPLAY TUITION = IND-TUITION' 
d. DISPLAY TUITION = ', IND-TUITION 
e. DISPLAY'Initials: AT LINE 5 COLUMN 5' 
f. DISPLAY initials:' AT LINE 5 COLUMN 5 
g. The two statements, DISPLAY 'Less Scholarship' AT LINE 15 COLUMN 10 
followed by DISPLAY 'Amount due' AT LINE 15 COLUMN 16 
3. Modify the tuition billing program to accommodate the following: 
a. A new password, RTG, which should be accepted as valid in all uppercase, all 
lowercase, or any combination of upper- and lowercase letters. 
b. Data validation as you see fit; the program as presently written does no validation 
whatsoever. Suggest and implement validation checks for at least three fields. 
c. Display a total screen at the conclusion of processing that contains the number 
of students processed and the corresponding totals for total tuition, total activity 
fee, total union fee, total scholarship awarded, and the total amount due. 
d. Create a valid record file as output—that is, a file containing the valid student 
records that could be input into the edited version of the tuition billing program in 
Chapter 7. 
4. Answer the following with respect to the car validation and billing program: 
a. Is the program case-sensitive; that is, is there any difference between entering 
an upper- or lowercase C to denote a compact car? 
b. What changes (if any) have to be made to VALUE clauses in the Data Division to 
make the program case-insensitive for car type? 
c. What changes (if any) have to be made in the Procedure Division to support 
those made in the Data Division in part (b)? 
d. What other changes (if any) are needed to make the program case-insensitive to 
other data names? 
5. The car validation and billing program makes extensive use of the in-line PERFORM 
statement to validate data as it is entered. 
a. What is the minimum number of times the statements within an in-line perform 
(e.g., lines 305-313) will be executed? 
b. Do the PERFORM statements (e.g., lines 305-313) implement a DO WHILE or a 
DO UNTIL structure? 
c. What is the effect (if any) of substituting TEST BEFORE for TEST AFTER in line 
305? 
d. What is the effect (if any) of removing the TEST clause in line 305? 

Overview 
Introduction t o T a b l e s 
OCCURS Clause 
Processing a Table 
PERFORM VARYING 
A S e c o n d E x a m p l e 
Problems with the OCCURS Clause 
Rules for Subscripts 
Relative Subscripting 
USAGE Clause 
OCCURS DEPENDING ON 
T h e Student T r a n s c r i p t Program 
Programming Specifications 
Program Design 
The Completed Program 
I n d e x e s v e r s u s S u b s c r i p t s 
The SET Statement 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

• 
Chapter 
11 — 
Introduction 
to 
Tables 
O B J E C T I V E S 
After reading this chapter you will be able to: 
Define a table and describe its use in programming. 
j 
Use the OCCURS (at either the group or elementary level) to implement a 
table in COBOL. 
Use the PERFORM VARYING statement to process a table. 
Distinguish between fixed and variable length records; use the OCCURS 
DEPENDING ON clause to implement a variable length table. 
State the purpose of the USAGE clause. 
Differentiate between a subscript and an index. 
OVERVIEW 
This is the first of three chapters that deal exclusively with tables, a topic of major 
importance in any programming language. A table is a grouping of similar data 
whose values are stored in consecutive storage locations and assigned a single 
data name. Any reference to an individual element within a table is accomplished 
by a subscript or an index. 
The present chapter introduces the basic statements for table processing. 
We begin with the OCCURS clause to define a table and show how it can be 
used at both the group and elementary levels. We discuss the DEPENDING ON 
phrase to specify a variable-length table and the concept of relative subscripting. 
We cover the PERFORM VARYING statement to process the elements in a table 
by repeatedly executing a paragraph or a series of in-line statements. We also 
differentiate between an index that is specified in an INDEXED BY clause and a 
subscript defined in Working-Storage. All of this material is summarized by the 
illustrative program at the end of the chapter. 
The motivation for using a table comes from examination of Figure 11.1. Let us 
assume that a c o m p a n y tabulates its sales o n a monthly basis a n d that the sales of 
each m o n t h are to be referenced within a C O B O L program. Without tables, as in the 
brute force approach of Figure 11.1a, 12 different data n a m e s are required: JAN-
SALES, FEB-SALES, and so on. A table, however, enables you to define a single data 
n a m e such as SALES, then subsequently refer to individual months by an appropriate 
subscript. SALES (2), for example, refers to the sales for the second month, February. 

Introduction 
to 
Tables 
The Table Concept 
01 ANNUAL-SALES-DATA. 
05 JAN-SALES 
PIC 9(6). 
05 FEB-SALES 
PIC 9(6). 
05 MAR-SALES 
PIC 9(6). 
05 APR-SALES 
PIC 9(6). 
05 MAY-SALES 
PIC 9(6). 
05 JUN-SALES 
PIC 9(6). 
05 JUL-SALES 
PIC 9(6). 
05 AUG-SALES 
PIC 9(6). 
05 SEP-SALES 
PIC 9(6). 
05 OCT-SALES 
PIC 9(6). 
05 NOV-SALES 
PIC 9(6). 
05 DEC-SALES 
PIC 9(6). 
01 ANNUAL-SALES-DATA. 
05 SALES OCCURS 12 TIMES 
PIC 9(6). 
SALES (1) 
ANNU> 
SALES (2) 
\L-SALES-DATA 
SALES (3) 
. . . 
The OCCURS clause defines the n u m b e r of entries in a table and is covered in 
detail later in the chapter. For the time being, however, w e consider only its 
simplest form: 
OCCURS integer TIMES 
The O C C U R S clause is illustrated in Figure 11.1b to define a table of 12 elements, 
with each element in the table having the identical format; that is, each element is a 
six-position numeric field. T h e entire table takes a total of 72 positions (12 entries x 
6 positions per entry), as s h o w n in the schematic of Figure 11.1c. A s indicated, 
individual entries in the table are referenced by the table n a m e , SALES, a n d an 
appropriate subscript—for example, SALES (1) to refer to the first element (January 
sales), SALES (2) to refer to the second element (February sales), a n d so on. 
The O C C U R S clause is not permitted at the 01 level and thus the sales table 
was defined under the entry A N N U A L - S A L E S - D A T A in Figure 11.1b. T h e 12 elements 
m a y be referenced collectively by the data n a m e A N N U A L - S A L E S - D A T A although 
such a reference is unlikely to be used. 

Chapter 
11 — 
introduction 
to 
Tables 
IPttieessLtc, 
V JL& 
After a table has been defined, w e shall want to s u m the 12 monthly totals to 
produce an annual total. There are several approaches, the first of which is brute 
force: 
COMPUTE ANNUAL-TOTAL 
= SALES (1) + SALES (2) + SALES (3) 
+ SALES (4) + SALES (5) + SALES (6) 
+ SALES (7) + SALES (8) + SALES (9) 
+ SALES (10) + SALES (11) + SALES (12) 
END-COMPUTE. 
This technique is c u m b e r s o m e to code, and defeats the purpose of defining the 
table in the first place, but it does explicitly illustrate the concept of table 
processing. Fortunately, however, there is a better w a y through the P E R F O R M 
V A R Y I N G statement. 
The P E R F O R M V A R Y I N G statement causes repeated execution of a designated 
procedure or series of in-line statements a n d is the most c o m m o n m e a n s of 
processing a table. Consider: 
PERFORM [procedure - name - ij 
[BEFORE] 
WITH TEST [AFTER j 
literal-1 
literal-2 
VARYING identifier-1 FROM \ 
\ BY \ 
identifier-2 
identifier-3 
UNTIL condition- 1 
[imperative-statement-1 END-PERFORM] 
The T E S T B E F O R E / T E S T A F T E R clause is n e w to C O B O L - 8 5 and was explained 
in Chapter 9. T h e clause is optional a n d typically omitted; the default is T E S T 
B E F O R E and corresponds to the C O B O L - 7 4 implementation. 
The P E R F O R M V A R Y I N G statement (with test before) initializes a variable, 
tests a condition, a n d if the condition is not satisfied, enters a loop to execute a 
procedure, increment a variable, a n d retestthe condition (condition-1). The loop is 
executed repeatedly until the condition is finally satisfied, at which point the 
P E R F O R M V A R Y I N G statement ends, a n d control passes to the next sequential 
statement in the program. T h e sequence just described is illustrated in Figure 11.2 
and is restated below: 
1. Identifier-1 is initialized to the value in the F R O M clause 
2. Condition-1 is evaluated and is either true or false: 
a. If the condition is true, the P E R F O R M V A R Y I N G is terminated a n d control 
passes to the next sequential statement. 
b. If the condition is false, procedure-name-1 or imperative-statement-1 is 
executed, after which identifier-1 is incremented with the value in the B Y 
clause. Condition-1 is reevaluated as either true or false with subsequent 
action as just described. 

Introduction 
to 
Tables 
Figure 11.2 
PERFORM VARYING (with TEST BEFORE) 
Initialize 
identifier-1 
to FROM value 
Increment 
identifier-1 
with BY value 
The condition in the P E R F O R M V A R Y I N G statement typically includes a greater 
than sign, rather than a n equal sign, to execute the designated procedure an integer 
n u m b e r of times; for example, the statement 
PERFORM COMPUTE-PAYMENT 
VARYING SUBSCRIPT FROM 1 BY 1 
UNTIL SUBSCRIPT > 3 
executes the procedure C O M P U T E - P A Y M E N T three times. T h e sequence is 
explained as follows: 
1. S U B S C R I P T is initially set to 1 and the condition S U B S C R I P T > 3 is evaluated. 
The condition is not true, so the designated procedure, C O M P U T E - P A Y M E N T , 
is executed the first time. 
2. S U B S C R I P T is incremented to 2 and the condition is retested. T h e condition is 
still not satisfied, so C O M P U T E - P A Y M E N T is executed a second time. 
3. S U B S C R I P T is incremented to 3, but the condition is still false—3 is not greater 
than 3—and hence C O M P U T E - P A Y M E N T is executed a third (and final) time. 
4. S U B S C R I P T is incremented to 4, satisfying the condition in the U N T I L clause 
and terminating the P E R F O R M statement. (Note that, had the condition been 
specified as S U B S C R I P T = 3, C O M P U T E - P A Y M E N T would have been executed 
only twice.) 

Chapter 
11 — 
introduction 
to 
Tables 
Extending this reasoning to the general case of executing a procedure N times 
requires a statement of the form: 
PERFORM PARAGRAPH 
VARYING SUBSCRIPT FROM 1 BY 1 
UNTIL SUBSCRIPT > N. 
The data n a m e used to monitor execution—for example, S U B S C R I P T — m u s t be 
explicitly defined in Working-Storage. 
The P E R F O R M V A R Y I N G statement is illustrated a final time in Figure 11.3. 
The choice between performing a paragraph as in Figure 11.3a, or using an in-line 
perform as in Figure 11.3b, is one of personal preference. Both techniques are 
equally acceptable and achieve identical results. 
Figure 11.3 Processing a Table 
MOVE ZERO TO ANNUAL-TOTAL. 
PERFORM 
VARYING SALES-SUB FROM 1 BY 1 
UNTIL SALES-SUB > 12 
ADD SALES (SALES-SUB) TO ANNUAL-TOTAL 
END-PERFORM. 
Let us consider a second example in which three sets of salary data are kept for each 
employee; that is, each employee record contains the employee's present salary 
and date o n which it b e c a m e effective, the previous salary and date, and the second 
previous salary and date. (Not all employees have all three salaries.) 
It is, of course, possible to develop unique data n a m e s for each occurrence of 
salary information, for example, 
05 SALARY-DATA. 
MOVE ZERO TO ANNUAL-TOTAL. 
PERFORM INCREMENT-ANNUAL-TOTAL 
VARYING SALES-SUB FROM 1 BY 1 
UNTIL SALES-SUB > 12. 
INCREMENT-ANNUAL-TOTAL. 
ADD SALES (SALES-SUB) TO ANNUAL-TOTAL. 
(a) Performing a Paragraph 
(b) In-line Perform 
10 PRESENT-SALARY 
10 PRESENT-SALARY-DATE 
10 PREVIOUS-SALARY 
10 PREVIOUS-SALARY-DATE 
10 SECOND-PREVIOUS-SALARY 
10 SECOND-PREVIOUS-SALARY-DATE 
PIC 9(6). 
PIC 9(4). 
PIC 9(6). 
PIC 9(4). 
PIC 9(6). 
PIC 9(4). 

A Second 
E 
xampIe 
Figure 11 -4 
OCCURS Clause at the Group Level 
05 SALARY-DATA OCCURS 3 TIMES. 
10 SALARY 
PIC 9(6). 
10 SAL-DATE 
PIC 9(4). 
(a) COBOL Statements 
S A L A R Y - D A T A ( t ) 
SALARY-DATA (2) 
SALARY-DATA (3) 
S A L A R Y (1) 
SAL-DATE(1) 
S A L A R Y (2) 
SAL-DATE(2) 
S A L A R Y (3) 
SAL-DATE(3) 
(b) Storage Schematic 
Figure i 1.5 
OCCURS Clause at the Elementary Level 
05 SALARY-DATA. 
10 SALARY 
OCCURS 3 TIMES 
PIC 9(6). 
10 SAL-DATE 
OCCURS 3 TIMES 
PIC 9(4). 
(a) COBOL Siaternenis 
SALARY-DATA 
S A L A R Y (1) 
S A L A R Y (2) 
S A L A R Y (3) 
SAL-DATE(1) 
SAL-DATE(2) 
S A L - D A T E ( 3 ) 
(b) Storage Schematic 
W h a t if, however, it were suddenly decided that four, five, or even ten levels of 
historical data were required? T h e situation is neatly circumvented b y establishing 
a table that enables the programmer to define logically similar elements under a 
c o m m o n n a m e , a n d to reference the desired entry subsequently by a n appropriate 
subscript. Hence S A L A R Y (1) denotes the present salary, S A L A R Y (2) the previous 
salary, S A L A R Y (3) the second previous salary, a n d so on. Figure 11.4 shows the 
C O B O L statements and corresponding storage allocation for such a scheme. 
Figure 11.4 depicts a total of 30 storage positions for the table S A L A R Y - D A T A , 
with the O C C U R S clause at the group level. Positions 1-6 refer to S A L A R Y (1), 
positions 7-10 refer to S A L - D A T E (1), and positions 1-10 collectively to SALARY-
D A T A (1). In similar fashion, positions 11-16 refer to S A I A R Y (2), positions 17-20 
refer to S A L - D A T E (2), a n d positions 11-20 collectively to S A I A R Y - D A T A (2). 
Whenever a subscript is used, it is enclosed in parentheses. 
Figure 11.5 contains a n alternate implementation with two O C C U R S clauses 
at the elementary level. A total of 30 storage positions are still assigned to the table, 
but the storage allocation is different; i.e., positions 1-6 contain S A L A R Y (1), positions 
7-12 contain S A L A R Y (2), a n d positions 13-18 contain S A I A R Y (3). In similar fashion, 

Chapter 
11 
Introduction 
to 
Tables 
positions 19-22 correspond to S A L - D A T E (1), positions 23-26 to S A L - D A T E (2), and 
T - 7 
O n 
O A T H A ^Yl 
T7:*l 
~. 
T~?i ~ 
I T A 
T^l 
, . 
1 1 IT '. • 
p u s i u o i i b i i - o u LU o n L - L i n i c (Oj. c i u i c i a i i a i i g c i i i c i i i , r i g u i e x i . t ui n g u i c I J U J , i s 
appropriate; the choice is u p to the programmer. 
Problems with the OCCURS Clause 
... 
The most c o m m o n error associated with tables is the omission of a subscript where 
one is required, or the inclusion of a subscript where it is not needed. T h e rule is 
very simple. Any data 
name 
that has been defined 
with an OCCURS 
clause, or any 
data 
name subservient 
to a group 
item containing 
an OCCURS 
clause, 
must 
always 
be referenced 
with a subscript. 
Failure to do so results in a compilation error. Thus 
all of the following are valid references with respect to the table definition of 
Figure 11.4: S A L A R Y - D A T A (2), S A L A R Y (2), a n d S A L - D A T E (2). 
In the table definition of Figure 11.5, however, the O C C U R S clause exists at 
the elementary, rather than the group, level. S A L A R Y - D A T A is referenced without 
a 
subscript a n d refers collectively to the 30 bytes in the table. S A L A R Y and S A L - D A T E 
are both defined with O C C U R S clauses a n d require subscripts: S A L A R Y (2) a n d SAL-
D A T E (2), for example. 
The compiler checks only for the existence of a subscript, but not its value; for 
example, the entry S A L A R Y (20) is syntactically correct in that a subscript is present, 
but logically incorrect as the O C C U R S clause defines only three elements. The error 
would not be detected during compilation; it would pose a problem during execution 
as it references a n invalid storage location with unpredictable results. S o m e 
compilers offer the option of including a subscript 
check whereby an error message 
will be produced during execution if an invalid subscript is referenced. 
Rules for Subscripts 
C O B O L subscripts m a y be either variable or constant, but in either case m u s t 
adhere to the following: 
1. At least one space is required between the data n a m e a n d the left 
parenthesis. 
SALES (2) 
SALES(SUB) 
SALES(2) 
2. A space m a y not follow the left parenthesis nor precede the right 
parenthesis. 
Valid: 
SALES (SUB) 
! / ' ' " ' 
SALES (2) 
SALES( 2) 
SALES(2 ) 
3. A subscript can be a data n a m e or a numeric literal with a n integer value. 
Relative subscripting—that is, a data n a m e plus or minus an integer—is also 
permitted. 
Valid' 
SALES 
(SUB + 1) 
Invalid: 
SALES 
(1.2) 
Relative Subscripting 
Relative 
subscripting—that 
is, the ability to a d d or subtract an integer from a 
subscript—is a tremendous convenience in certain situations. T h e report in Figure 

Relative Subscripting 
CURRENT SALARY 
EFFECTIVE DATE 
PERCENT INCREASE 
$46,000 
09/93 
15.0% 
$40,000 
09/92 
11.1% 
$36,000 
09/91 
12.5% 
$32,000 
09/90 
(a) Salary History 
PERFORM VARYING SUB FROM 1 BY 1 
UNTIL SUB > 3 OR SALARY (SUB + 1) = 0 
COMPUTE PCT-SALARY-INC (SUB) 
= 100 * ((SALARY (SUB) - SALARY (SUB + 1)) 
/ SALARY (SUB + 1) 
END-COMPUTE 
END-PERFORM. 
(b) Computation of Percent Salary Increase 
11.6a displays four levels of salary, the date o n which each salary b e c a m e effective, 
and the associated percent increase for each pair of salaries. (The percent increase 
is not calculated for the last salary.) Percent increase is computed according to the 
general formula: 
A _ , 
T 
New Salary - Old Salary 
A
n
n 
Percent Salary Increase = 
x 100 
Old Salary 
The current salary of $46,000 in Figure 11.6a reflects a 15 percent increase over the 
previous salary of $40,000 a n d was computed as follows: 
D 
*c i 
, 
46,000-40,000 
, n n 
. c 
Percent Salary increase = 
x 100 = .15 
40,000 
The percent salary increase is a repetitive calculation that is required for each pair 
of salaries stored within the salary table. O n e (tedious) approach is to use a different 
formula for each pair of salaries—that is, one formula to reference S A L A R Y (1) and 
S A L A R Y (2), a second formula to reference S A L A R Y (2) a n d S A L A R Y (3), a n d so on. A 
m o r e elegant solution is to develop a general formula that references S A L A R Y (SUB) 
and S A L A R Y (SUB + 1) as s h o w n in Figure 11.6b. 
The C O M P U T E statement is executed three times if all four salaries are present. 
N e w e r employees will not have a complete salary history, however, a n d hence the 
second condition in the U N T I L clause will cease execution if an earlier salary is not 
present; that is, the latter condition prevents a division by zero w h e n a n earlier 
salary is not available. 
The U S A G E clause is intended to m a k e a program m o r e efficient. T h e clause is 
entirely optional as the presence (or absence) of a U S A G E clause does not alter the 
logic of a program, but affects only the generated object code. A true understanding, 
therefore, requires a knowledge of assembler fundamentals which is beyond the 

Chapter 
11 
Introduction 
to 
Tables 
present discussion. Suffice it to say that subscripts are best defined with a U S A G E 
clause in one of four equivalent formats as follows: 
05 SUBSCRIPT-1 
05 SUBSCRIPT-2 
05 SUBSCRIPT-3 
05 SUBSCRIPT-4 
PIC S9(4) 
USAGE IS COMPUTATIONAL. 
PIC S9(4) 
COMPUTATIONAL. 
PIC S9(4) 
USAGE IS COMP. 
PIC S9(4) 
COMP. 
OCCURS DEPEM>.'..^ JH 
W e began the chapter with the simplest form of the O C C U R S clause to define a 
table. The clause has several additional options, however, as s h o w n below: 
OCCURS 
nteger-1 JO i n t e g e r - 2 TIMES [DEPENDING ON data - name-l]j 
i n t e g e r - 2 TIMES 
jASCENDING 1 
[DESCENDING] 
KEY IS data-name-2 [data-name-3] 
[INDEXED BY index-name-1 [i ndex - name-2j . . . J 
The D E P E N D I N G O N clause defines a variable-length 
table. This in turn 
produces a variable-length 
record, which is reflected in the R E C O R D C O N T A I N S 
clause of the F D as s h o w n in Figure 11.7. 
The records in S T U D E N T - T R A N S C R I P T - F I L E will vary in length from 42 to 
1,131 characters, depending o n the n u m b e r of courses a student has completed. 
T h e m i n i m u m record length is 42 characters; 30 for n a m e , 10 for major, and 2 for 
the n u m b e r of courses. The records for incoming freshmen will contain the m i n i m u m 
42 characters, whereas the records for upperclassmen contain an additional 11 
bytes for every completed course. A n arbitrary m a x i m u m of 99 courses is permitted 
in a record. 
The advantage of variable-length 
records is that they allocate only as m u c h 
space as necessary in the storage m e d i u m . Fixed-length 
records, o n the other hand, 
assign the s a m e ( m a x i m u m ) a m o u n t of disk space to every record in the file. 
jure 1 1 . 1 Variable-length Records 
FD STUDENT-TRANSCRIPT-FILE 
RECORD CONTAINS 42 TO 1131 CHARACTERS 
DATA RECORD IS STUDENT-RECORD. 
01 STUDENT-RECORD. 
05 ST-NAME 
PIC X(30). 
05 ST-MAJ0R 
PIC X(10). 
05 ST-C0URSES-C0MPLETED 
PIC 99. 
05 ST-COURSE-GRADE OCCURS 0 TO 99 TIMES 
DEPENDING ON ST-C0URSES-C0MPLETED. 
10 ST-COURSE-NUMBER 
PIC 9 ( 6 ) . 
10 ST-GRADE 
PIC X. 
10 ST-C0URSE-DATE 
PIC 9 ( 4 ) . 

The 
Student 
Transcript 
Program 
What, then, is the m a x i m u m n u m b e r of courses? Is it five per semester, times 8 
semesters, or 40 courses? W h a t about the student w h o fails a course or the one with 
two majors, or the one w h o remains in the university to pursue a master's or 
doctoral degree? Perhaps w e should allocate space for 100 courses, just to be safe. If 
w e do, every student record will require 1,100 bytes (11 bytes per course times 100 
courses). But at any given time the average student probably has completed twenty 
or fewer courses (that is, there are freshmen, sophomores, juniors, and seniors in 
the file), and hence most records would require only 220 (20 x 11) or fewer characters. 
In other words, approximately 900 bytes per record would be wasted in the storage 
m e d i u m . Multiply this by the n u m b e r of students in the university, and you can 
quickly see the inefficiency of fixed-length records in certain applications. 
Variable-length records, o n the other hand, allow only as m u c h space in each 
record as is actually required. Each variable-length record contains a specific field 
from which the length of the record can be calculated—for example, the n u m b e r of 
completed courses, which becomes the data n a m e specified in the O C C U R S 
D E P E N D I N G O N clause. 
The I N D E X E D B Y clause is covered later in this chapter (on page 321). The 
A S C E N D I N G / D E S C E N D I N G K E Y clause is presented in Chapter 12 in conjunction 
with table lookups. 
W e are ready to incorporate the basic material o n table processing into a n 
illustrative program. Specifications follow in the usual format. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Student Transcript Program 
N a r r a t i v e : 
This program processes a file of student records to produce a set of student transcripts. 
Each incoming record contains a variable-length table with the student's grades from the 
preceding semester. The program computes the grade point average for every student, 
prints individual transcripts for each student, and produces a table of students on the 
dean's list at the end of processing. 
Input File(s): 
STUDENT-FILE 
Input R e c o r d L a y o u t : 
01 STUDENT-RECORD. 
05 ST-NAME 
05 ST-NUMBER-0F-C0URSES 
05 ST-C0URSE-INF0 OCCURS 1 TO 8 TIMES 
DEPENDING ON ST-NUMBER-0F-C0URSES. 
10 ST-COURSE-NUMBER 
10 ST-COURSE-GRADE 
10 ST-COURSE-CREDITS 
PIC X(19). 
PIC 99. 
PIC X(3). 
PIC X. 
PIC 9. 
Test Data: 
See Figure 11.8a. 
Report Layout: 
See Figure 11.8b and 11.8c. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of student records. 

Chapter 
11 — 
Introduction 
to 
Tables 
Figure 11.8 
Test Data and Required Output 
BENJAMIN, L 
05111A3222A2333A3444A3555B3 
BORROW, J 
04666B3777B3888B3999B4 
MILGROM, M 
06123C4456C4789C4012C4345C3678C4 
(a) Test Data 
NAME:BENJAMIN, L 
OFFICIAL TRANSCRIPT 
COURSE # CREDITS GRADE 
111 
3 
A 
222 
2 
A 
333 
3 
A 
444 
3 
A 
555 
3 
B 
AVERAGE: 3.79 
*DEANS LIST* 
NAME:BORROW, J 
OFFICIAL TRANSCRIPT 
COURSE # CREDITS GRADE 
666 
3 
B 
777 
3 
B 
888 
3 
B 
999 
4 
B 
AVERAGE: 3.00 
NAME:MILGROM, M 
OFFICIAL TRANSCRIPT 
COURSE # CREDITS GRADE 
123 
4 
C 
456 
4 
C 
789 
4 
C 
012 
4 
C 
345 
3 
C 
678 
4 
C 
AVERAGE: 2.00 
(b) individual Transcripts 
STUDENTS ON THE DEANS LIST 
TOTAL 
TOTAL 
QUALITY 
NAME 
COURSES 
CREDITS 
POINTS 
GPA 
BENJAMIN, L 
5 
14 
53 
3.79 
(c) The Dean's List 

The 
Student 
Transcript 
Program 
COURSE 
COURSE GRADE 
COURSE CREDITS 
Course Number 1 
A 
2 
Course Number 2 
B 
4 
ides 
SUB GRADE(SUB) CREDITS(SUB) 
MULTIPLIER TOTAL-QUALITY-POINTS 
TOTAL-CREDITS 
1 
A 
2 
4 
8 (0 + 2*4) 
2 
2 
B 
4 
3 
20 (8 + 4*3) 
6 
(b) Incrementing Counters 
GRADE-POINT-AVERAGE = TOTAL-QUALITY-POINTS / TOTAL-CREDITS = 20 / 6 = 3.33 
(c) Calculation of Grade Point Average 
2. For every record read, 
a. Calculate the grade point average (GPA) according to a four-point scale with 
grades of A, B, C, D, and F, worth 4, 3, 2, 1, and 0, respectively. Courses are 
weighted according to their credit value in computing the GPA. The number of 
quality points for a given course is equal to the number of credits for that course 
times the numeric value of that grade. The GPA is equal to the total number of 
quality points (for all courses) divided by the total number of credits. The computation 
of the GPA is further illustrated in Figure 11.9. 
b. Print the student's name, list of courses with associated grades, and computed 
grade point average according to the format in Figure 11.8b. Every transcript is to 
begin on a new page. 
c. Determine whether the student qualifies for the dean's list, which requires a GPA of 
3.5 or higher; if so, print the dean's list designation on the last line of the transcript. 
3. Print a list of all students on the dean's list at the end of processing as shown in 
Figure 11.8c. 
- 
. 
. 
. U L 
1 
The development of this (or any other) program begins with a hierarchy chart that 
includes all necessary functions to implement the processing requirements. The 
output in Figure 11.8 shows individual transcripts and a composite dean's list, both 
of which represent major tasks to be fully expanded; thus the highest-level module 
in the hierarchy chart will have two subordinates, C R E A T E - T R A N S C R I P T and W R I T E -
DEANS-LIST, corresponding to the major functions. Each of these is expanded 
further as s h o w n in the hierarchy chart of Figure 11.10. 
The C R E A T E - T R A N S C R I P T module has four subordinates: W R I T E - T R A N S -
HFADING, P R O C E S S - C O U R S E S , WRITE GPA, a n d A D D - T O - D E A N S - L I S T . 
P R O C E S S - C O U R S E S , in turn, has two subordinates: I N C R E M E N T - C O U N T E R S and 
WRITE-DETAIL-LINE. WRITE-DEANS-LIST also has two subordinates: W R I T E -
DEANS-LIST-i (LADING and WRITE-DEANS-LIST-DETAILS. The hierarchy chart is 
straightforward a n d easy to follow with the functions of all modules readily apparent 
from the module names. 
Calculation of Grade Point Average 

Chapter 
11 
Introduction 
to 
Tables 
-iqurc -> 
(l 
Hierarchy Chart for Transcript Program 
PROCESS 
STUDENT 
RECORDS 
INCREMENT 
COUNTERS 
WRITE 
DETAIL 
LINE 
The pseudocode in Figure 11.11 uses an in-line perform to eliminate the 
priming read used in earlier programs. The false-condition branch in the read 
statement drives the program a n d contains the logic to c o m p u t e an individual's 
grade point average, produce the transcript, a n d determine whether the individual 
qualifies for the dean's list. 
The processing of each incoming record focuses o n the production of a 
transcript, a process that begins with the initialization of two counters, for total 
quality points a n d total credits, respectively. Next, a n inner loop is executed for 
every course in the current record, to determine the appropriate multiplier for the 
course (4 for an A, 3 for a B, a n d so on), to increment the counters for quality points 
a n d credits, a n d to write the detail line. This loop terminates after all courses (for 
one student) have been processed, after which the grade point average is c o m p u t e d 
by dividing the total quality points by the total n u m b e r of credits. 
The pseudocode next determines whether the student qualifies for the dean's 
list, a n d if so, increments the n u m b e r of students o n the dean's list, then m o v e s the 
student's data to the appropriate place in a dean's list table. T h e table containing 
the students o n the dean's list is written at the e n d of processing. 
The Completed Program 
T h e completed program is s h o w n in Figure 11.12. The paragraphs in the Procedure 
Division correspond one to one with the modules in the hierarchy chart, a n d its 
logic in the program parallels that of the pseudocode just developed. The program 
complies with the processing requirements a n d also illustrates the various C O B O L 
features presented earlier. Note the following: 

The 
Student 
Transcript 
Program 
i 
Pseudocode for Transcript Program 
Open files 
; 
DO WHILE data remains 
| 
READ Student file 
j , 
AT END 
! 
; 
Indicate no more data 
| 
NOT AT END 
i 
Write transcript heading 
Move zero to quality-point and credit counters 
j 
! 
; 
DO for each course 
j 
Determine multiplier for this course 
i 
Increment total quality points 
I 
Increment total credit counter 
i 
| 
Write detail line for this course 
! 
— E N D D O 
! 
| 
COMPUTE grade-point-average 
= total quality points/ total credits 
j 
Write grade-point-average 
i 
, 
IF dean's list 
i 
| 
I 
| 
IF students on dean's list > 100 
Display appropriate error message 
I 
; 
ELSE 
I 
Increment students on dean's list 
I 
\ 
| 
Move this student to dean's list table 
|
 
! 
END-IF 
1 
END-IF 
1 
ENDREAD 
- — ENDDO 
Write heading for dean's list 
i 
DO for every student on dean's list 
Write student data 
- — ENDDO 
Close files 
Stop run 
1. The O C C U R S D E P E N D I N G O N clause in lines 21 and 22 defines a variable-
length table for the n u m b e r of courses, which in turn produces a variable-
length record in lines 15-17 of the F D for S T U D E N T - F I L E . 
2. T h e definition of two subscripts in Working-Storage—COURSE-SUB and 
D E A N - S U B — b o t h ofwhich contain the ( U S A G E IS) C O M P clause for efficiency. 
3. The in-line P E R F O R M statement of lines 133-140, coupled with the false-
condition branch in the R E A D statement, drives the program by performing 
the paragraph 2 0 0 - C R E A T E - T R A N S C R I P T (lines 146-159) for every record 
in the file. This critical paragraph computes the grade point average, 
produces the transcript, and determines whether the student qualifies for 
the dean's list. 

Chapter 
11 
Introduction 
to 
Table 
Figure 11.12 
The Student Transcript Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
TRANSCRP. 
3 
AUTHOR. 
ROBERT GRAUER. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT STUDENT-FILE ASSIGN TO 'A:\CHAPTR11\STUDENT.DAT
1 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD STUDENT-FILE 
16 
RECORD CONTAINS 26 TO 61 CHARACTERS 
17 
DATA RECORD IS STUDENT-RECORD. 
18 
01 STUDENT-RECORD. 
19 
05 ST-NAME 
PIC X(19). 
20 
05 ST-NUMBER-OF-COURSES 
PIC 99. 
21 
(^^sT-TSu^SE-rNroTccORS"T 
T O n T T T M E S H 
22 
| 
DEPENDING ON ST-NUMBER-OF-COURSES. ["""""--r 
23 
^ 
10 ST-COURSE-NUMBER 
PIC X(3). 
;-,/-;^^ 
24 
10 ST-COURSE-GRADE 
PIC X. 
25 
10 ST-COURSE-CREDITS 
PIC 9. 
26 
27 
FD PRINT-FILE 
28 
RECORD CONTAINS 132 CHARACTERS 
29 
DATA RECORD IS PRINT-LINE. 
30 
01 PRINT-LINE 
PIC X(132). 
31 
32 
WORKING-STORAGE SECTION. 
33 
01 SUBSCRIPTS. 
34 
05 COURSE-SUB 
PIC S9(4) 
COMP. 
35 
05 DEAN-SUB 
PIC 9(3) 
VALUE ZERO |COMI\ 
36 
\ 
37 
01 SWITCHES-AND-COUNTERS. 
38 
05 END-OF-FILE-SWITCH 
PIC X(3) 
V A L U E ' N O
1 . 
39 
05 STUDENTS-ON-DEANS-LIST 
PIC 9(3) 
VALUE ZERO. 
40 
41 
01 INDIVIDUAL-GPA-VARIABLES. 
42 
05 IND-TOTAL-CREDITS 
PIC 999. 
43 
05 IND-TOTAL-QUAL-POINTS 
PIC 999. 
44 
05 IND-MULTIPLIER 
PIC 9. 
45 
05 IND-GRADE-POINT-AVERAGE PIC S9V99. 
46 
88 DEANS-LIST 
VALUES 3.5 THRU 4. 
47 
48 
01 DEANS-LIST-TABLE. 
49 
05 DEANS-LIST-INFO OCCURS 100 TIMES. 
50 
10 DL-NAME 
PIC X(19). 

The 
Student 
Transcript 
Program 
Figure 1 1 . 1 2 
(continued) 
I 
51 
10 DL-COURSES 
PIC 99. 
52 
10 DL-CREDITS 
PIC 999. 
53 
10 DL-QUAL-POINTS 
PIC 999. 
54 
10 DL-GPA 
PIC S9V99. 
55 
56 
01 TRANS-HEADING-LINE -ONE. 
57 
05 FILLER 
PIC X(6) 
VALUE ' NAME:'. 
58 
05 HDG-NAME 
PIC X(15). 
59 
05 FILLER 
PIC X(10) VALUE SPACES. 
60 
05 FILLER 
PIC X(19) 
61 
VALUE 'OFFICIAL TRANSCRIPT 
62 
05 FILLER 
PIC X(82) VALUE SPACES. 
63 
64 
01 TRANS-HEADING-LINE- TWO. 
65 
05 FILLER 
PIC X(10) VALUE SPACES. 
66 
05 FILLER 
PIC X{9) 
VALUE 'COURSE # 
67 
05 FILLER 
PIC X{9) 
VALUE 'CREDITS 
68 
05 FILLER 
PIC X(5) 
VALUE 'GRADE'. 
69 
05 FILLER 
PIC X(99) VALUE SPACES. 
70 
71 
01 DETAIL-LINE. 
72 
05 FILLER 
PIC X(13) VALUE SPACES. 
73 
05 DET-COURSE 
PIC X(3). 
74 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
75 
05 DET-CREDITS 
PIC 9. 
76 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
77 
05 DET-GRADE 
PIC X. 
78 
05 FILLER 
PIC X(100) VALUE SPACES. 
79 
80 
01 LAST-LINE. 
81 
05 FILLER 
PIC X(16) VALUE SPACES. 
82 
05 FILLER 
PIC X(9) 
VALUE 'AVERAGE: 
83 
05 LAST-GPA 
PIC 9.99. 
84 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
85 
05 LAST-DEANS-LIST 
PIC X(12) VALUE SPACES. 
86 
05 FILLER 
PIC X(87) VALUE SPACES. 
87 
88 
01 DEANS-LIST-HEADING-LINE--ONE. 
89 
05 FILLER 
PIC X(20) VALUE SPACES. 
90 
05 FILLER 
PIC X(26) 
91 
VALUE 'STUDENTS ON THE DEANS LIST'. 
92 
05 FILLER 
PIC X(86) VALUE SPACES. 
93 
94 
01 DEANS-LIST-HEADING-LINE- TWO. 
95 
05 FILLER 
PIC X(25) 
VALUE SPACES. 
96 
05 FILLER 
PIC X(5) 
VALUE 'TOTAL
1. 
97 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
98 
05 FILLER 
PIC X(5) 
VALUE 'TOTAL'. 
99 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
100 
05 FILLER 
PIC X(7) 
VALUE 'QUALITY 

Chapter 
11— 
Introduction 
to 
Tables 
(continued) 
101 
05 FILLER 
PIC X(81) 
VALUE SPACES. 
102 
103 
01 DEANS-LIST-HEADING-LINE-THREE. 
104 
05 FILLER 
PIC X 
VALUE SPACES. 
105 
05 FILLER 
PIC X(4) 
VALUE 
1 NAME
1. 
106 
05 FILLER 
PIC X(19) 
VALUE SPACES. 
107 
05 FILLER 
PIC X(7) 
VALUE 'COURSES 
108 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
109 
05 FILLER 
PIC X(7) 
VALUE 'CREDITS 
110 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
111 
05 FILLER 
PIC X(6) 
VALUE 'POINTS' 
112 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
113 
05 FILLER 
PIC X(3) 
VALUE 'GPA'. 
114 
05 FILLER 
PIC X(73) 
VALUE SPACES. 
115 
116 
01 DEANS-LIST-DETAIL-LINE. 
117 
05 FILLER 
PIC X 
VALUE SPACES. 
118 
05 DL-DET-NAME 
PIC X(19). 
119 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
120 
05 
DL-DET-TOT-COURSES 
PIC Z9. 
121 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
122 
05 
DL-DET-TOT-CREDITS 
PIC ZZ9. 
123 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
124 
05 
DL-DET-TOT-QUAL-POINTS 
PIC ZZ9. 
125 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
126 
05 DL-DET-GPA 
PIC 9.99. 
127 
05 FILLER 
PIC X(72) 
VALUE SPACES. 
128 
129 
PROCEDURE DIVISION. 
130 
100 -PROCESS-STUDENT-RECORDS. 
131 
OPEN INPUT STUDENT-FILE 
132 
OUTPUT PRINT-FILE. 
133 
PERFORM UNTIL END-OF-FILE-SWITCH = 'YES' 
134 
READ STUDENT-FILE 
135 
AT END 
136 
MOVE 'YES' TO END 
-OF- FILE-SWITCH I / " ' 
137 
NOT AT END 
138 
PERFORM 200-CREATE-TRANSCRIPT 
139 
END-READ 
140 
END-PERFORM. 
141 
PERFORM 300-WRITE-DEANS-LIST. 
142 
CLOSE STUDENT-FILE 
143 
PRINT-FILE. 
144 
STOP RUN. 
145 
146 
200 -CREATE-TRANSCRIPT. 
147 
PERFORM 210-WRITE-TRANS-HEADING. 
148 
MOVE ZERO TO IND-TOTAL-QUAL-POINTS IND-TOTAL-CREDITS. 
149 
PERFORM 220-PROCESS-COURSES 
1 
150 
VARYING COURSE-SUB FROM 1 BY 1 
151 
UNTIL COURSE-SUB > ST -NUMBER-OF-COURSES 

The 
Student 
Transcript 
Program 
(continued) 
152 
COMPUTE IND-GRADE-POINT-AVERAGE ROUNDED 
153 
= IND-TOTAL-QUAL-POINTS / IND-TOTAL-CREDITS 
154 
SIZE ERROR DISPLAY 'SIZE ERROR ON GPA' 
155 
END-COMPUTE. 
155 
PERFORM 250-WRITE-GPA. 
157 
IF DEANS-LIST 
158 
PERFORM 260-ADD-TO-DEANS-LIST 
159 
END-IF. 
160 
161 
210-WRITE-TRANS-HEADING. 
162 
MOVE ST-NAME TO HDG-NAME. 
163 
WRITE PRINT-LINE FROM TRANS-HEADING-LINE-ONE 
164 
AFTER ADVANCING PAGE. 
165 
WRITE PRINT-LINE FROM TRANS-HEADING-LINE-TWO 
166 
AFTER ADVANCING 2 LINES. 
167 
168 
220-PROCESS-COURSES. 
169 
PERFORM 230-INCREMENT-COUNTERS. 
170 
PERFORM 240-WRITE-DETAIL-LINE. 
171 
172 
230-INCREMENT-COUNTERS. 
173 
EVALUATE ST-COURSE-GRADE (COURSE-SUB) 
174 
WHEN 'A' 
175 
MOVE 4 TO IND-MULTIPLIER 
176 
WHEN 'B' 
177 
MOVE 3 TO IND-MULTIPLIER 
178 
WHEN 'C 
179 
MOVE 2 TO IND-MULTIPLIER 
180 
WHEN 'D' 
181 
MOVE 1 TO IND-MULTIPLIER 
182 
WHEN OTHER 
183 
MOVE 0 TO IND-MULTIPLIER 
184 
DISPLAY 'INVALID COURSE GRADE' 
185 
END-EVALUATE. 
186 
COMPUTE IND-TOTAL-QUAL-POINTS = IND-TOTAL-QUAL-POINTS 
187 
+ ST-COURSE-CREDITS (COURSE-SUB) * IND-MULTIPLIER 
188 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL QUALITY POINTS' 
189 
END-COMPUTE. 
190 
ADD ST-COURSE-CREDITS (COURSE-SUB) TO IND-TOTAL-CREDITS 
191 
SIZE ERROR DISPLAY 'SIZE ERROR ON TOTAL CREDITS' 
192 
END-ADD. 
193 
_ 
_ 
194 
; 240-WRITE-DETATL-LINE". 
" ~ " ~ 
195 
MOVE ST-COURSE-NUMBER (COURSE-SUB) TO DET-COURSE. 
196 
MOVE ST-COURSE-CREDITS (COURSE-SUB) TO DET-CREDITS.^ 
197 
MOVE ST-COURSE-GRADE (COURSE-SUB) TO DET-GRADE. 
198 
WRITE PRINT-LINE FROM DETAIL-LINE. 
199 
200 
250-WRITE-GPA. 
201 
MOVE IND-GRADE-POINT-AVERAGE TO LAST-GPA. 

Chapter 
11 
Introduction 
to 
Tables 
i 2 
(continued) 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
IF DEANS-LIST 
MOVE '*DEANS LIST*' TO LAST-DEANS-LIST 
ELSE 
MOVE SPACES TO LAST-DEANS-LIST 
END-IF. 
WRITE PRINT-LINE FROM LAST-LINE 
AFTER ADVANCING 2 LINES. 
260-ADD-TO-DEANS-LIST. 
IF STUDENTS-ON-DEANS-LIST > 100 
DISPLAY 'DEAN LIST TABLE EXCEEDED' 
ELSE 
ADD 1 TQ l5TUDENTS-0N-DEANS-LIST>" 
ADD 1 TO DEAN-SUB 
MOVE ST-NAME TO DL-NAME (DEAN-SUB) 
MOVE ST-NUMBER-OF-COURSES TO DL-COURSES (DEAN-SUB) 
MOVE IND-TOTAL-CREDITS TO DL-CREDITS (DEAN-SUB) 
MOVE IND-TOTAL-QUAL-POINTS TO DL-QUAL-POINTS (DEAN-SUE 
MOVE IND-GRADE-POINT-AVERAGE TO DL-GPA (DEAN-SUB) 
END-IF. 
300-WRITE-DEANS-LIST. 
PERFORM 310-WRITE-DEANS-LIST-HEADINGS. 
PERFORM 320-WRITE-DEANS-LIST-DETAILS 
VARYING DEAN-SUB FROM 1 BY 1 
UNTIL DEAN-SUB > STUDENTS-ON-DEANS-LIST. 
ie aean s iisi 
310-WRITE-DEANS-LIST-HEADINGS. 
WRITE PRINT-LINE FROM DEANS-LIST-HEADING-LINE-ONE 
AFTER ADVANCING PAGE. 
WRITE PRINT-LINE FROM DEANS-LIST-HEADING-LINE-TWO 
AFTER ADVANCING 2 LINES. 
WRITE PRINT-LINE FROM DEANS-LIST-HEADING-LINE-THREE. 
MOVE SPACES TO PRINT-LINE. 
WRITE PRINT-LINE. 
320-WRITE-DEANS-LIST-DETAILS. 
MOVE DL-NAME (DEAN-SUB) TO DL-DET-NAME. 
MOVE DL-COURSES (DEAN-SUB) TO DL-DET-TOT-COURSES. 
MOVE DL-CREDITS (DEAN-SUB) TO DL-DET-TOT-CREDITS. 
MOVE DL-QUAL-POINTS (DEAN-SUB) TO DL-DET-TOT-QUAL-POINTS. 
MOVE DL-GPA (DEAN-SUB) TO DL-DET-GPA. 
WRITE PRINT-LINE FROM DEANS-LIST-DETAIL-LINE. 

4. The computation of the grade point average is described as follows: 
a. The counters IND-TOTAL-QUALITY-POINTS and I N D - T O T A L - C R E D I T S 
are set to zero by the M O V E Z E R O statement in line 148. 
b. The P E R F O R M V A R Y I N G statement in lines 149-151 executes the paragraph 
2 2 0 - P R O C E S S - C O U R S E S , w h i c h in turn performs two lower-level 
paragraphs for every course in the current record, one course at a time. 
c. Each time the paragraph 2 3 0 - I N C R E M E N T - C O U N T E R S is executed, the 
course multiplier is determined (4 for an A, 3 for a B, and so on), after which 
the cumulative values of the quality points and credits are updated. 
d. The P E R F O R M V A R Y I N G terminates, after which the G P A is determined in 
lines 152-155. 
5. The definition of a counter S T U D E N T S - O N - D E A N S - L I S T (line 39) and the 
definition of the associated DEANS-LIST-TABLE in lines 48-54 to hold data for 
qualifying students. The IF statement in lines 157-159 determines whether 
the current student qualifies for the dean's list, then executes paragraph 260-
ADD-TO-DFANS-I.IST (lines 210-221) to increment the counter a n d m o v e the 
student's values to the appropriate place in the table. 
6. The P E R F O R M V A R Y I N G statement in lines 225-227 to produce the dean's list 
based o n the n u m b e r of students (i.e., the final value of S T U D E N T S - O N -
DEANS-LIST) a n d the entries in the table. 
The transcript program just completed illustrates the basics of table processing, 
and as such goes a long w a y toward increasing your proficiency in C O B O L . There is, 
however, a good deal m o r e to learn about tables, and so w e return to the syntax of 
the O C C U R S clause s h o w n earlier in the chapter. 
The O C C U R S clause includes an optional I N D E X E D B Y entry to define a n 
index for use with a particular table. A n index is conceptually the s a m e as a subscript 
in that both reference an entry in a table. Indexes, however, produce m o r e efficient 
object code and are preferred (by s o m e programmers) for that reason. T h e difference 
is subtle; an index represents a displacement 
(the n u m b e r of positions into a table), 
whereas a subscript indicates an occurrence. Consider: 
05 ST-COURSE-INFO OCCURS 10 TIMES 
The C O B O L statements establish a table with 10 entries which occupy a total 
of 60 positions in m e m o r y . Valid subscripts for S T - C O U R S E - I N F O are 1, 2,3,... 10, 
because the table entries occur 10 times. T h e first occurrence of S T - C O U R S E - I N F O 
is at the start of the table (displacement zero), the second occurrence begins 6 bytes 
into the table, the third occurrence 12 bytes into the table, a n d so on. T h e value of 
the index is the value of the displacement, that is, the n u m b e r of positions into a 
table to the entry in question; hence valid displacements for S T - C O U R S E - I N F O are 
0, 6,12,... 54. 
Fortunately, y o u need not be concerned with the actual value (displacement) 
of an index, and can regard it conceptually as a subscript. In other words, y o u will 
INDEXED BY COURSE-INDEX. 
10 ST-COURSE-NUMBER 
10 ST-COURSE-GRADE 
10 ST-COURSE-CREDITS 
PIC X(3). 
PIC X. 
PIC 99. 

Chapter 
11 — 
Introduction 
to 
Tables 
indicate index values of 1,2,3, a n d so on, which will be converted by the compiler to 
internal displacements of 0,6,12, and so on. Indexes can not, however, be initialized 
with a M O V E statement, nor can they be incremented with an A D D statement. The 
SET statement is used instead. 
The SET Statement 
The SET statement has two formats and is used only with indexes. 
Format 1 
SET 
Format 2 
jidentifier-1 [, identifier-2] . , 
index-name-1 [, index-name-2] . 
TO 
identifier- 3 
index-name-3 
i nteger-1 
SET index-name-4 [, index-name-5] 
JUP BY I jidentifier-4) 
[DOWN BYj {integer-2 
j 
Figures 11.13 and 11.14 compare indexes and subscripts. Figure 11.13a depicts the 
definition of a table without a n index, which in turn requires the definition of a 
subscript elsewhere in the Data Division. Figure 11.13b uses a P E R F O R M V A R Y I N G 
statement to manipulate this table (in conjunction with C O U R S E - S U B S C R I P T ) , 
while Figure 11.13c shows the P E R F O R M T I M E S statement to accomplish the same 
objective. The latter is yet another form of the P E R F O R M statement and performs 
the designated procedure (or in-line statement) the indicated n u m b e r of times. It is 
less convenient than a comparable P E R F O R M V A R Y I N G statement as the 
programmer has to vary the subscript (index) explicitly. 
Figure 11.14 contains parallel code, except that the table is defined in 
Figure 11.14a with an index (so there is no need to define a subscript). Figure 11.14b 
is virtually identical to its predecessor in that the P E R F O R M V A R Y I N G statement 
can manipulate either subscripts or indexes. Finally, Figure 11.14c shows the 
alternate (less desirable) w a y to process the table. Observe, therefore, the use of SET 
statements to initialize and increment the index (as opposed to the M O V E a n d A D D 
statements in Figure 11.13c. 
Indexing is not required in C O B O L , a n d thus y o u can choose between 
subscripts and indexes in any given application. Indeed, you m a y wonder w h y 
bother with indexes at all, if they provide the same capability as subscripts. The 
answer is twofold: 
1. Indexes provide m o r e efficient object code than subscripts. 
2. Indexes are required for S E A R C H a n d S E A R C H ALL, two powerful statements 
that are presented in Chapter 12. 
Differences between indexes and subscripts are summarized in Table 11.1. 
Table 11.1 
Indexes versus Subscripts 
Defined with a specific table; can be used 
only with the table with which they are 
defined 
Initialized and incremented via the SET 
statement; can also be manipulated in 
PERFORM statements 
Provide more efficient object code than 
subscripts 
Defined in Working-Storage; the same subscript 
can be used with multiple tables although this is 
not recommended 
May not be used with SET statements (MOVE 
and ADD are used instead); can also be 
manipulated in PERFORM statements 
USAGE IS COMPUTATIONAL makes subscripts 
more efficient, although indexes are still faster 

Indexes 
versus 
Subscripts 
Indexes versus Subscripts (Subscripts) 
05 
05 
ST-NUMBER-OF-COURSES 
PIC 99 
ST-COURSE-INFO OCCURS 1 TO 8 TIMES 
DEPENDING ON ST-NUMBER-OF-COURSES. 
10 ST-COURSE-NUMBER 
PIC X(3). 
10 ST-COURSE-GRADE 
PIC X. 
10 ST-COURSE-CREDITS 
PIC 99 
^-Subscript 
de--'' 
scga:e'i:••</ ,n 
Working-Sioi 
05 COURSE-SUBSCRIPT 
PIC S9(4) COMP. r 
(a) Table Definition 
PERFORM WRITE-COURSE-DATA 
VARYING COURSE-SUBSCRIPT FROM 1 BY 1 
UNTIL COURSE-SUBSCRIPT > ST-NUMBER-OF-COURSES. 
WRITE-COURSE-DATA. 
MOVE ST-COURSE-NUMBER (COURSE-SUBSCRIPT) TO PL-NUMBER. 
MOVE ST-COURSE-GRADE (COURSE-SUBSCRIPT) TO PL-GRADE. 
WRITE PRINT-LINE FROM PRINT-LINE-ONE 
AFTER ADVANCING 1 LINE. 
PERFORM WRITE-COURSE-DATA ST-NUMBER-OF-COURSES TIMES. 
WRITE-COURSE-DATA. 
MOVE ST-COURSE-NUMBER (COURSE-SUBSCRIPT) TO PL-NUMBER. 
MOVE ST-COURSE-GRADE (COURSE-SUBSCRIPT) TO PL-GRADE. 
WRITE PRINT-LINE FROM PRINT-LINE-ONE 
AFTER ADVANCING 1 LINE. 
ADD 1 TO COURSE-SUBSCRIPT. 
fb) PERFORM VARYING 
MOVE 1 TO COURSE-SUBSCRIPT. 
(c) P E R F O R M TIMES 

Chapter 
11 
Introduction 
to 
Tables 
Indexes versus Subscripts (Indexes) 
05 
05 
ST-NUMBER-OF-COURSES 
PIC 99. 
ST-C0URSE-INF0 OCCURS 1 TO 8 TIMES 
DEPENDING ON ST-NUMBER-OF-COURSES 
INDEXED BY COURSE-INDEX.3'""""" 
ToST-COURSE-NUMBER"PIC X(3). 
10 ST-COURSE-GRADE 
PIC X. 
10 ST-COURSE-CREDITS 
PIC 99. 
PERFORM WRITE-COURSE-DATA 
VARYING COURSE-INDEX FROM 1 BY 1 
UNTIL COURSE-INDEX > ST-NUMBER-OF-COURSES. 
WRITE-COURSE-DATA. 
MOVE ST-COURSE-NUMBER (COURSE-INDEX) TO PL-NUMBER. 
MOVE ST-COURSE-GRADE (COURSE-INDEX) TO PL-GRADE. 
WRITE PRINT-LINE FROM PRINT-LINE-ONE 
AFTER ADVANCING 1 LINE. 
SET COURSE-INDEX TO 1.] 
" " 
PERFORM WRITE-COURSE-DATA ST-NUMBER-OF-COURSES TIMES. 
WRITE-COURSE-DATA. 
MOVE ST-COURSE-NUMBER (COURSE-INDEX) TO PL-NUMBER. 
MOVE ST-COURSE-GRADE (COURSE-INDEX) TO PL-GRADE. 
WRITE PRINT-LINE FROM PRINT-LINE-ONE 
AFTER ADVANCING 1 LINE. 
SET COURSE-INDEX UP BY 1. 
(b) P E R F O R M VARYING 
Index 
initialized by a 
SETeta:eniei-i 
(c) P E R F O R M TIMES 

COBOL-85 introduced several minor changes in conjunction with table 
processing. The new compiler allows seven levels of subscripting as opposed 
to the earlier limit of three, but given that the typical programmer seldom uses 
three-level tables, this extension is of little practical benefit. (Multiple-level 
tables are covered in Chapter 13.) The OCCURS DEPENDING ON clause 
may specify a value of zero, whereas at least one occurrence was required in 
COBOL-74. 
A more significant change is the introduction of relative subscripting 
(as explained in Figure 11.6), enabling the reference DATA-NAME 
(SUBSCRIPT + integer). Relative subscripting was not permitted in COBOL-
74 (although relative indexing was). 
A table is a grouping of similar data whose values are stored in contiguous 
storage locations and assigned a single name. Tables are implemented in 
COBOL through the OCCURS clause with subscripts or indexes used to 
reference individual items in a table. The OCCURS DEPENDING ON clause 
implements a variable-length table. 
An index is conceptually the same as a subscript but provides more 
efficient object code. Indexes are manipulated with the SET statement, 
whereas subscripts are initialized with a MOVE statement and incremented 
with an ADD statement. 
The PERFORM VARYING statement manipulates an index or a subscript to 
execute a procedure or series of in-line statements. Omission of the TEST 
BEFORE and TEST AFTER clauses defaults to TEST BEFORE and 
corresponds to the COBOL-74 implementation. 
The PERFORM TIMES statement also provides for repeated execution of a 
procedure or in-line statement, but requires the programmer to explicitly 
vary the value of the subscript or index. 
The optional USAGE IS COMPUTATIONAL clause is used to improve 
the efficiency of a program's generated object code, but does not affect 
its logic. 

Chapter 
11 — 
Introduction 
to 
Tables 
PERFORM VARYING 
SET 
TEST AFTER 
TEST BEFORE 
UNTIL 
USAGE IS COMPUTATIONAL 
1. A table is defined throuah the 
clause. 
2. Entries in a table may be referenced bv either a 
or an 
3. 
4. 
A 
lenath table is defined by the 
clause. 
The USAGE clause is a (required/optional) entrv for a subscript. 
5. A table (must/may) be defined with an index. 
6. (Subscripts/indexes) are manipulated with a SET statement. 
7. 
8. 
Arithmetic (is/is not) permitted for subscripts and indexes. 
levels of subscriptina are permitted in COBOL-85. 
9. The TEST BEFORE clause (changes/does not change) the effect of a PERFORM 
VARYING statement. 
J f. ? U E / F /-
10. 
\ L S E 
The OCCURS DEPENDING ON, ASCENDING/DESCENDING KEY, and INDEXED 
BY clauses are (optional/required) entries in an OCCURS clause. 
1. Tables are established by a DIMENSION statement. 
2. The same entry may not contain both an OCCURS clause and a PICTURE clause. 
3. When using subscripts, a space is required between a data name and the left 
parenthesis. 
4. The USAGE clause is required when defining a subscript in Working-Storage. 
5. The entry, DATA-NAME (0) would not cause a compilation error, provided that an 
OCCURS clause had been used in the associated definition. 
Displacement 
Fixed-length record 
Index 
Relative indexing 
Relative subscripting 
BY 
FROM 
INDEXED BY 
OCCURS 
OCCURS DEPENDING ON 
PERFORM TIMES 
Key 
Words 
and 
Concepts 
Subscript 
Table 
Variable-length record 
Variable-length table 

Problems 
6. The same subscript can be used to reference different tables. 
7. The same index can be used to reference different tables 
8. A subscript may be a constant or a variable. 
9. All records in the same file must be the same length. 
10. The SET statement is used to manipulate subscripts or indexes. 
11. An index may be modified by either an ADD or a MOVE statement. 
12. The PERFORM VARYING statement may manipulate both subscripts and indexes. 
1. Indicate which entries are incorrectly subscripted. Assume that SUB1 has been set 
to 5, and that the following entry applies: 
05 SALES-TABLE OCCURS 12 TIMES PIC 9(5). 
a. SALES-TABLE (1) 
b. SALES-TABLE (15) 
c. SALES-TABLE (0) 
d. SALES-TABLE (SUB1) 
e. SALES-TABLE(SUBI) 
f. SALES-TABLE (5) 
« 
C
M 
E C 
T A D I 
ET /Ql t C M 
C t I O Q \ 
y . 
o / ~ \ L _ i _ o ~ i h
u
l
l 
\ O u u 
i 
t 
o u u n ; 
h. SALES-TABLE (3) 
i. SALES-TABLE ( 3) 
j. SALES-TABLE (SUB1 + 1) 
2. How many times will PARAGRAPH-A be executed by each of the following PERFORM 
statements? 
a. PERFORM PARAGRAPH-A 
VARYING SUBSCRIPT FROM 1 BY 1 
UNTIL SUBSCRIPT > 5. 
b. PERFORM PARAGRAPH-A 
VARYING SUBSCRIPT FROM 1 BY 1 
WITH TEST BEFORE 
UNTIL SUBSCRIPT > 5. 
c. PERFORM PARAGRAPH-A 
VARYING SUBSCRIPT FROM 1 BY 1 
WITH TEST AFTER 
UNTIL SUBSCRIPT > 5. 
d. PERFORM PARAGRAPH-A 
VARYING SUBSCRIPT FROM 1 BY 1 
UNTIL SUBSCRIPT = 5. 
e. PERFORM PARAGRAPH-A 
VARYING SUBSCRIPT FROM 1 BY 1 
WITH TEST BEFORE 
UNTIL SUBSCRIPT = 5. 

Chapter 
11 
Introduction 
to 
Tables 
f. PERFORM PARAGRAPH-A 
VARYING SUBSCRIPT FROM 1 BY 1 
WITH TEST AFTER 
UNTIL SUBSCRIPT = 5. 
3. Given the following Working-Storage entries: 
01 SAMPLE-TABLES. 
05 FIRST-TABLE OCCURS 10 TIMES 
INDEXED BY FIRST-INDEX. 
10 FIRST-TABLE-ENTRY 
PIC X(5). 
05 SECOND-TABLE OCCURS 10 TIMES 
INDEXED BY SECOND-INDEX. 
10 SECOND-TABLE-ENTRY 
PIC X(5). 
01 SUBSCRIPT-ENTRIES. 
05 FIRST-SUBSCRIPT 
PIC 9(4). 
05 SECOND-SUBSCRIPT 
PIC 9(4). 
Indicate whether the following table references are valid syntactically. 
a. FIRST-TABLE-ENTRY (FIRST-INDEX) 
b. FIRST-TABLE-ENTRY (FIRST-SUBSCRIPT) 
c. SECOND-TABLE-ENTRY (FIRST-INDEX) 
d. SECOND-TABLE-ENTRY (SECOND-INDEX) 
e. SECOND-TABLE-ENTRY (FIRST-SUBSCRIPT) 
f. SECOND-TABLE-ENTRY (SECOND-SUBSCRIPT) 
g. FIRST-TABLE-ENTRY (FIRST-INDEX + 1) 
h. FIRST-TABLE-ENTRY (FIRST-SUBSCRIPT + 1) 
Indicate whether the following Procedure Division statements are valid. 
i. MOVE 1 TO FIRST-SUBSCRIPT 
j. SET FIRST-SUBSCRIPT TO 1 
k. MOVE 1 TO FIRST-INDEX 
I. SET FIRST-INDEX TO 1 
m. SET FIRST-INDEX UP BY 1 
n. ADD 1 TO FIRST-INDEX 
4. Use the general format of the OCCURS clause to determine whether the following 
are valid entries (the level number has been omitted in each instance): 
a. TABLE-ENTRY OCCURS 4 TIMES. 
b. TABLE-ENTRY OCCURS 4. 
C. TABLE-ENTRY OCCURS 3 TO 30 TIMES 
DEPENDING ON NUMBER-OF-TRANS. 
d. TABLE-ENTRY OCCURS 5 TIMES 
INDEXED BY TABLE-INDEX. 
e. TABLE-ENTRY OCCURS 5 TIMES 
SUBSCRIPTED BY TABLE-SUBSCRIPT. 

f. TABLE-ENTRY OCCURS 5 TO 50 TIMES 
DEPENDING ON NUMBER-OF-TRANSACTIONS 
INDEXED BY TABLE-INDEX. 
g. TABLE-ENTRY OCCURS 6 TIMES 
ASCENDING KEY TABLE-CODE 
INDEXED TABLE-INDEX. 
h. TABLE-ENTRY OCCURS 6 TIMES 
ASCENDING KEY TABLE-CODE-1 
DESCENDING KEY TABLE-CODE-2 INDEXED BY TABLE-INDEX. 
5. How many storage positions are allocated for each of the following table definitions? 
Show an appropriate schematic indicating storage assignment for each table. 
a. 01 STATE-TABLE. 
05 STATE-NAME OCCURS 50 TIMES 
PIC X(15). 
05 STATE-POPULATION OCCURS 50 TIMES 
PIC 9(8). 
b. 01 STATE-TABLE. 
05 NAME-POPULATION OCCURS 50 TIMES. 
6. Show Procedure Division statements to determine the largest and smallest 
population in POPULATION-TABLE. (Assume the table has been initialized 
elsewhere.) Move these values to BIGGEST and SMALLEST, respectively. Move 
the state names to BIG-STATE and SMALL-STATE, respectively. POPULATION-
TABLE is defined as follows: 
01 POPULATION-TABLE. 
10 STATE-NAME 
10 STATE-POPULATION 
PIC X(15). 
PIC 9(8). 
05 P0PULATI0N-AND-NAME OCCURS 50 TIMES 
INDEXED BY POP-INDEX. 
10 POPULATION 
PIC 9(8). 
10 STATE-NAME 
PIC X(15). 


Overview 
Systonn C o n c e p t s 
Types of Codes 
Characteristics of Codes 
Sequential Table Lookup 
Binary Table Lookup 
Positional Organization and Direct Lookups 
initializing a T a b l e 
Hard Coding 
Input-loaded Tables 
Programming Tip—Restrict Subscripts and Switches to a Single Use 
T a b l e Lookups 
PERFORM VARYING Statement 
SEARCH Statement 
SEARCH ALL Statement 
Direct Lookup 
Range-Step Tables 
A C o m p l e t e E x a m p l e 
Programming Specifications 
Program Design 
The Completed Program 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
12 — 
Table 
Lookups 
OBJECTIVES 
After reading this chapter you will be able to: 
Define a table lookup and describe why it is used. 
Distinguish between a numeric, alphabetic, and alphanumeric code; 
describe severai attributes of a good coding system. 
Distinguish between a sequential table lookup, a binary table lookup, and 
direct access to table entries. 
Distinguish between a table that is hard coded versus one that is input 
loaded. 
State the purpose of the VALUE, OCCURS, and REDEFINES clauses as 
they pertain to table definition and initialization. 
Define a range-step table. 
Code SEARCH and SEARCH ALL statements to implement table lookups. 
O V E R V I E W 
One-level tables, subscripts, and indexes were introduced in Chapter 11. This 
chapter extends that information to include table lookups—the conversion of 
incoming data from a concise, coded format to a descriptive and more 
meaningful result. 
The System Concepts section begins with a discussion of codes, then 
proceeds to techniques for table organization, table initialization, and table 
lookups. The body of the chapter covers the COBOL implementation of the 
conceptual material, and includes the REDEFINES, VALUE, and OCCURS 
clauses, and the SEARCH and SEARCH ALL statements. All of this material is 
effectively summarized in a COBOL program at the end of the chapter. 
Figure 12.1 depicts a table of student major codes and the associated descriptions. 
Records in the storage m e d i u m contain a two-position code, whereas printed reports 
display the descriptive (expanded) value. The conversion is accomplished through 
a table lookup, with the obvious advantage that less space is required to store codes 
rather than descriptive values. (Consider the implications for large files with 
thousands, perhaps millions of records.) 
A second, perhaps m o r e important, reason for using codes is to assign records 
to consistent classes. It is a simple matter for a data-entry clerk to look u p a unique 
code for a Computer Information Systems major (e.g., 24 in Figure 12.1), and different 
clerks will always obtain the s a m e code for the s a m e major. It is far less likely that 
different clerks will always use identical spellings for a given major; even the same 
individual is apt to use different spellings at different times, especially w h e n one 
begins to abbreviate. B y assigning a code, rather than a descriptive value, individuals 

figure 12.1 
Table of Major Codes 
02 
ART HISTORY 
04 
BIOLOGY 
19 
CHEMISTRY 
21 
CIVIL ENGINEERING 
24 
COMP INF SYS 
32 
ECONOMICS 
39 
FINANCE 
43 
MANAGEMENT 
49 
MARKETING 
54 
STATISTICS 
with the same major will have a c o m m o n identifying characteristic that can be 
subsequently processed by a program. 
Types of Codes 
. 
The codes in a table m a y be numeric, alphabetic, or alphanumeric. A numeric code 
consists entirely of digits; for example, the zip code is a numeric code familiar to all 
Americans. A three-digit numeric code has 1.000 possible values (from 0 through 
999). In similar fashion, four- a n d five-digit numeric codes have 10,000 and 100,000 
values, respectively. 
Alphabetic codes contain only letters—for example, state abbreviations. A 
two-position alphabetic code has 676 possible values. (Each character can assume 
one of 26 values, A through Z. Thus, a two-position alphabetic code has 26 x 26 = 26
2 
= 676 possible values. In similar fashion, a three-position alphabetic code has 26' = 
17,576 possible values.) 
Alphanumeric codes contain both letters a n d numbers—for example, license 
plates. Alphanumeric codes offer the advantage of providing a greater number of 
combinations than either pure numeric or pure alphabetic codes. A three-digit 
numeric code has 1,000 (10') variations, a three-digit alphabetic code has 17,576 
(26
:l) possibilities, but a three-position alphanumeric code (in which each character 
can be either a letter or number) has 46,656 (36') choices. Table 12.1 summarizes 
the various types of codes. 
12.1 
Types of Table Codes 
CODE TYPE 
USED 
1 POSITION 
2 POSITIONS 
n POSITIONS 
Numeric 
0-9 
10
1 = 10 
10
2 = 100 
10
n 
Alphabetic 
A Z 
26
1 = 26 
2 6
2 = 676 
26
n 
Alphanumeric 
A Z, 0-9 
36
1 = 36 
3 6
2 = 1,296 
36
n 
Characteristics of Codes 
. . 
... 
A good coding system is precise, mnemonic, and expandable. A precise code is 
unique; that is, it should not be possible to select alternative choices from a table of 
codes for a given entry. Indeed, codes are often assigned because the original 

Chapter 
12 
Table 
Lookups 
attribute is not unique. Universities, for example, assign student numbers because 
different students m a y have the s a m e n a m e . 
G o o d codes are m n e m o n i c , that is, easy to remember. State abbreviations are 
alphabetic rather than numeric for this reason. Thus N Y a n d T X are inherently 
easier to learn as abbreviations for N e w York a n d Texas than r a n d o m two-digit 
numbers. 
A coding system should also be expandable so that future additions can be 
easily handled. It is poor design, for example, to allocate only two positions in a 
record for a numeric branch office code, if 98 unique branch offices already exist. 
Sequent!*. C&t.le Lookup 
A table lookup occurs w h e n an incoming code is compared to entries in a table in 
order to convert the code to an expanded value. In a sequential table lookup the 
entries in the table are checked in order, as s h o w n in Figure 12.2. 
.2 
Sequential Table Lookup 
1st try 
6th try 
7th try 
2nd try 
3rd try 
5th try 
02 
ART HISTORY 
04 
BIOLOGY 
19 
CHEMISTRY 
21 
CIVIL ENGINEERING 
24 
COMPINFSYS 
32 
ECONOMICS 
39 
I FINANCE 
h 
43 
MANAGEMENT 
49 
MARKETING 
54 
STATISTICS 
Match 
Assume, for example, a n incoming code of 39. A sequential lookup begins 
with the first entry, then the second entry, a n d so o n until a m a t c h is found or the 
table is exhausted. In this instance, 7 tries are required. O n the average, a sequential 
table lookup requires N/2 tries (where N is the n u m b e r of entries in the table) to 
find a match, assuming that each entry is equally likely. 
The codes in Figure 12.2 were arranged sequentially. A n alternative form of 
table organization, by frequency of occurrence, is sometimes used to reduce the 
n u m b e r of trials needed to find a match in a sequential lookup. Assume, for example, 
that C o m p u t e r Information Systems is the m o s t c o m m o n major, followed b y 
M a n a g e m e n t . It is reasonable, therefore, to list these majors first a n d second in the 
table. In other words, majors are listed according to the likelihood of finding a 
match, rather than b y a strict numeric sequence. T h e codes in the table are still 
examined in order, but the table itself has been rearranged. 
M a n y tables follow a so-called 80/20 rule; that is, 8 0 % of the matches c o m e 
from 2 0 % of the entries. (For example, 8 0 % of the questions raised in class m a y 
c o m e from 2 0 % of the students; 8 0 % of the United States population lives in 2 0 % of 
the states, a n d so on. T h e n u m b e r s 80 a n d 20 are approximate, but the concept is 
valid over a surprising n u m b e r of applications.) 

Organization b y frequency of occurrence requires a k n o w l e d g e of 
code probabilities that is often unavailable. Sequential organization is therefore 
more c o m m o n . 
A binary lookup makes the n u m b e r of comparisons relatively independent of where 
in the table the match occurs, but requires that the entries in the table be in 
sequence (either ascending or descending). T h e action of a binary lookup is 
illustrated in Figure 12.3. 
Binary Lookup 
1st try 
3rd try 
2nd try 
02 
ART HISTORY 
04 
BIOLOGY 
19 
CHEMISTRY 
21 
CIVIL ENGINEERING 
24 
COMP INF SYS 
32 
ECONOMICS 
39 '[FINANCE 
P 
43 
MANAGEMENT 
49 
MARKETING 
54 
STATISTICS 
Match 
A binary search begins in the middle of the table, for example, at the fifth entry 
in Figure 12.3, and eliminates half the table with every comparison. T h e search then 
proceeds as follows: 
1. Is the value of the incoming entry (the code you want to find) greater than the 
middle entry in the table? The answer is yes in this example in that 39 (the 
incoming code) is greater than 24 (the value of the middle entry). The search 
algorithm therefore eliminates table entries one through five. 
2. There are five remaining entries (positions 6-10) that could yet contain a 
value equal to the incoming code. T h e middle (eighth) entry is selected and 
the comparison is m a d e again; that is, is the value of incoming code 39 greater 
than the value of the eighth (middle) entry of 43? It isn't, which eliminates 
table entries eight through 10. 
3. There are two remaining entries (positions 6-7). The middle (seventh) entry is 
selected, and its value of 39 matches that of the incoming code. T h e search is 
terminated. 
A total of three comparisons was required to match the incoming code, 39. (If 
32 had been the incoming entry, four comparisons would have b e e n needed, but 
this is the maximum n u m b e r that would ever be required for a 10-position table.) A 
sequential lookup, o n the other hand, required seven comparisons until a match 
was found o n 39. 

Chapter 
12 -
Table 
Lookups 
If all 10 entries in a table have a n equal chance of occurring, the average 
n u m b e r of comparisons for a sequential search o n a table of 10 entries is five. This is 
greater than the maximum 
n u m b e r for a binary search. Indeed, as table size 
increases, the advantage of the binary search increases dramatically. Table 12.2 
shows the m a x i m u m n u m b e r of comparisons for tables with 8 to 4,095 entries. 
T . A ^ L . k - • 
Required Number of Comparisons for Binary Search 
8-15 
(less than 2
4) 
4 
16-31 
(less than 2
5) 
5 
32-63 
(less than 2
B) 
6 
64-127 
(less than 2
7) 
7 
128-255 
(less than 2
3) 
8 
256-511 
(less than 2'<) 
9 
512-1023 
(less than 2
1 0) 
10 
1024-2047 
(less than 2
1 " 
11 
2048-4095 
(less than 2
U >) 
12 
A positional table is a sequential table with a consecutive set of numeric codes. It 
permits immediate retrieval of a table value at the expense of unused storage space. 
Figure 12.4 depicts positional organization and the associated direct 
lookup. 
The table in Figure 12.4 is considerably larger than the sequential table in 
Figures 12.2 and 12.3. Fifty-four entries are present in Figure 12.4, as opposed to 10 
in the earlier tables. Observe also that codes are not stored in a positional table; that 
is, the value of the associated code is the position of the descriptive value within the 
table. Hence, A R T H I S T O R Y is stored in the second position a n d has an associated 
code of 2; B I O L O G Y is stored in the fourth position with an associated code of 4; and 
so forth. As can be seen, this arrangement results in considerable empty (wasted) 
space, as only 10 of the 54 table entries contain descriptive values. 
The advantage of a positional table is that a match is found immediately; for 
example, to obtain the descriptive value for an incoming code of 39, you go directly 
to the 39th entry in the table. (Prudent practice dictates that the programmer 
ensure the incoming code is valid, that is, within the table's range, before attempting 
a direct lookup.) 
A table is initialized in one of two ways, by hard coding it into a program, or by 
reading its values from a file. (A table m a y also be initialized through the C O P Y 
statement, which is presented in Chapter 16.) Both techniques are discussed in 
detail. 
A table m a y be hard-coded directly in a program as s h o w n in Figure 12.5. This is 
accomplished through a combination of the V A L U E , O C C U R S , a n d R E D E F I N E S 
clauses, which are explained below: 
V A L U E 
Assigns a n initial value to a specified area in m e m o r y . 
R E D E F I N E S Assigns another n a m e to previously allocated m e m o r y locations. 

Initializing 
a 
Table 
Positional Organization and Direct Lookup 
39 
(02) 
(04) 
(19) 
(21) 
(24) 
(32) 
1st try * - 
(39) 
(43) 
(49) 
ART HISTORY 
BIOLOGY 
CHEMISTRY 
CIVIL ENGINEERING 
COMP INF SYS 
ECONOMICS 
FINANCE 
MANAGEMENT 
MARKETING 
(54)| STATISTICS 
Match 
Initialization via Hard Coding 
01 MAJOR-VALUE. 
05 FILLER 
PIC X(14) 
VALUE ' 02ART HISTORY'. 
05 FILLER 
PIC X(14) 
VALUE '04BI0L0GY'. 
05 FILLER 
PIC X(14) 
VALUE '19CHEMISTRY'. 
05 FILLER 
PIC X(14) 
VALUE •21CIVIL ENG' . 
05 FILLER 
PIC X(14) 
VALUE '24C0MP INF SYS' 
05 FILLER 
PIC X(14) 
VALUE '32EC0N0MICS'. 
05 FILLER 
PIC X(14) 
VALUE '39FINANCE'. 
05 FILLER 
PIC X(14) 
VALUE '43MANAGEMENT' . 
05 FILLER 
PIC X(14) 
VALUE '49MARKETING'. 
05 FILLER 
PIC X(14) 
VALUE '54STATISTICS' . 
01 MAJOR-TABLE REDEFINES MAJOR-VALUE. 
05 MAJORS OCCURS 10 TIMES. 
10 MAJOR-CODE 
PIC 9(2). 
10 EXP-MAJOR 
PIC X(12). 

Chapter 
12 
Table 
Lookups 
i.u 
Table Initialization (Storage Schematic) 
o 
o 
CD(1) 
E X P - M A J O R (1) CD(2) 
E X P - M A J O R (2) 
CD(10) 
E X P - M A J O R (10)  
i 
i 
ABLE 
O C C U R S 
Establishes a table, that is, permits different locations to be 
referenced by the s a m e data n a m e , but with different subscripts. 
The need for the V A L U E a n d O C C U R S clauses is s o m e w h a t intuitive, whereas 
the R E D E F I N E S clause is m o r e obscure. The 01 entry M A J O R - V A L U E contains 10 
successive FILLER entries, each with a different V A L U E clause, which collectively 
initialize 140 consecutive positions with the indicated values. T h e first two positions 
under M A J O R - V A L U E contain 02, positions 3-14 contain A R T HISTORY, positions 
15 a n d 16 contain 04, positions 17-28 contain B I O L O G Y , a n d so on. 
The R E D E F I N E S clause assigns a different n a m e (MAJOR-TABLE) to these 
s a m e 140 positions, a n d the subsequent O C C U R S clause creates a table with 10 
occurrences. The first two positions in the table are designated M A J O R - C O D E (1) 
and contain 02, the first major code. Positions 3-14 are k n o w n as E X P - M A J O R (1) 
and contain A R T HISTORY, a n d so on. The conceptual view of these storage locations 
is s h o w n in Figure 12.6. 
Input-loaded Tables 
Initialization of a table through hard coding is a c o m m o n l y used technique, but one 
that presents problems in program maintenance w h e n the table changes. A n y 
change to a hard-coded table requires a corresponding change in the program, 
which in turn requires that the program be recompiled and retested. Moreover, if 
the s a m e table is used in multiple programs, then the s a m e change has to be m a d e 
in every program that uses the table, a time-consuming a n d error-prone procedure. 
A better technique is to initialize the table dynamically, by reading values 
from a file w h e n the program is executed. This is k n o w n as a n input-loaded 
table 
and is illustrated in Figure 12.7. The Data Division entries in Figure 12.7a establish 
space for the variable-length major table without assigning values; the latter is 
accomplished at execution time by the Procedure Division entries in Figure 12.7b. 
(The statements in Figure 12.7b use the in-line P E R F O R M statement a n d 
false-condition branch of the R E A D statement to process a file until its records 
are exhausted.) 
The process is further illustrated by Figure 12.8, in which records from the 
external file (containing the table codes a n d descriptive values) are read one at a 
time a n d m o v e d to the appropriate table entries. The first record in M A J O R - C O D E -
FILE contains the first code and descriptive value, 02 and A R T HISTORY, respectively, 
which are m o v e d into M A J O R - C O D E (1) a n d E X P - M A J O R (1). Subsequent table 
values are m o v e d in similar fashion. 
The advantage of a n input-loaded table (over one that is hard coded) is that 
any change to the table is a c c o m m o d a t e d by modifying the file that contains the 
table values. The program (or programs) that access that table are unaffected. 

Input-Loaded Table 
FD MAJOR-CODE-FILE 
RECORD CONTAINS 14 CHARACTERS 
DATA RECORD IS MAJOR-CODE-RECORD. 
01 MAJOR-CODE-RECORD. 
05 INCOMING-FILE-CODE 
PIC 9(2). 
05 INCOMING-FILE-NAME 
PIC X(12). 
WORKING-STORAGE SECTION. 
01 MAJOR-TABLE. 
05 MAJORS OCCURS 1 TO 10 TIMES 
DEPENDING ON NUMBER-OF-MAJORS 
INDEXED BY MAJOR-INDEX. 
10 MAJOR-CODE 
PIC 9(2). 
10 EXP-MAJOR 
PIC X(12). 
01 NUMBER-OF-MAJORS 
PIC 99 
VALUE ZERO. 
OPEN INPUT MAJOR-CODE-FILE. 
PERFORM VARYING MAJOR-INDEX FROM 1 BY 1 
UNTIL MAJOR-INDEX > 10 
OR END-OF-MAJOR-FILE = 'YES' 
READ MAJOR-CODE-FILE 
AT END 
MOVE 'YES' TO END-OF-MAJOR-FILE 
NOT AT END 
ADD 1 TO NUMBER-OF-MAJORS 
MOVE INCOMING-FILE-CODE TO MAJOR-CODE (MAJOR-INDEX) 
MOVE INCOMING-FILE-NAME TO EXP-MAJOR (MAJOR-INDEX) 
END-READ 
END-PERFORM. 
IF MAJOR-INDEX > 10 
DISPLAY 'MAJOR TABLE TOO SMALL' 
END-IF. 
CLOSE MAJOR-CODE-FILE. 
(b) In-line Perform 
Once a table has been established, the table lookup procedure is coded in the 
Procedure Division. W e illustrate four alternative COBOL techniques: PERFORM 
VARYING, S E A R C H , SEARCH ALL, a n d Direct Access to table entries. 

Chapter 
12 — 
Table 
Lookups 
Input-Loaded Tables 
19CHEMISTRY 
04BI0L0GY 
02ART HISTORY I 
02 
ART HISTORY 
04 
BIOLOGY 
19 
CHEMISTRY 
EXP-MAJOR(I) 
MAJOR-CODE(I) 
EXP-MAJ0R(2) 
MAJ0R-CODE(2) 
A 
A 
EXP-MAJOR(3) 
MAJOR-CODE(3) 
Figure 12.9 contains the C O B O L statements to implement the sequential table 
lookup of Figure 12.2. Entries in the table are compared sequentially to the incoming 
code SI - M A J O R - C O D E with one of two outcomes. Either a m a t c h is found, in which 
case the corresponding descriptive value is m o v e d to the output area, or the incoming 
code is not in the major table, which produces a n appropriate error message. 
The check for an invalid code is accomplished by comparing the value of the 
subscript W S - M A J O R - S U B , to the n u m b e r of entries in the table. This type of error 
checking is extremely important a n d is o n e w a y of distinguishing between 
professional work a n d sloppy coding. (What would h a p p e n if the check were 
not included a n d a n u n k n o w n code did appear?) Observe also the need to 
initialize both switches prior to the lookup, a n d h o w the switches are reset w h e n the 
search is terminated. 
The S E A R C H statement implements a sequential table lookup a n d is easier to 
use than the corresponding P E R F O R M V A R Y I N G statement. S E A R C H has the 
following syntax: 
SEARCH identifier-1 VARYING 
index-name-1 
identifier 
AT END imperative-statement-lj 
jimperati ve- statement - 2 
WHEN condition- 1 
WHEN condition-2 
NEXT SENTENCE 
imperative-statement- 3 
NEXT SENTENCE 
[END-SEARCH] 

Table 
Lookups 
?lS«re i 2.d 
Sequential Lookup with PERFORM VARYING 
WORKING-STORAGE SECTION. 
01 
TABLE-PROCESSING-ELEMENTS. 
01 
05 WS-MAJ0R-SUB 
PIC S9(4) 
USAGE IS COMP. 
05 WS-FOUNO-MAJOR-SWITCH 
PIC X(3) 
VALUE 'NO' 
05 WS-END-OF-TABLE-SWITCH 
PIC X(3) 
VALUE 'NO'. 
MAJOR-VALUE. 
05 FILLER 
PIC X(14) 
VALUE '02ART HISTORY' 
05 FILLER 
PIC X(14) 
VALUE '04BIOLOGY'. 
05 FILLER 
PIC X(14) 
VALUE ' 19CHEMISTRY'. 
05 FILLER 
PIC X(14) 
VALUE '21CIVIL ENG'. 
05 FILLER 
PIC X(14) 
VALUE 
124COMP INF SYS 
05 FILLER 
PIC X(14) 
VALUE ' 32ECONOMICS'. 
05 FILLER 
PIC X(14) 
VALUE '39FINANCE'. 
05 FILLER 
PIC X(14) 
VALUE '43MANAGEMENT'. 
05 FILLER 
PIC X(14) 
VALUE '49MARKETING'. 
05 FILLER 
PIC X(14) 
VALUE ' 54STATISTICS'. 
01 MAJOR-TABLE REDEFINES MAJOR-VALUE. 
05 MAJORS OCCURS 10 TIMES. 
10 MAJOR-CODE 
PIC 9(2). 
10 EXP-MAJOR 
PIC X(12). 
PROCEDURE DIVISION. 
MOVE 'NO' TO WS-FOUND-MAJOR-SWITCH 
WS-END-OF-TABLE-SWITCH. 
PERFORM FIND-MAJOR 
VARYING WS-MAJOR-SUB FROM 1 BY 1 
UNTIL WS-END-OF-TABLE-SWITCH = 'YES' 
OR WS-FOUND-MAJOR-SWITCH = 'YES
1. 
| 
FIND-MAJOR. 
1 
IF WS-MAJOR-SUB > 10 
| 
MOVE 'YES' TO WS-END-OF-TABLE-SWITCH 
j 
MOVE 'UNKNOWN' TO HDG-MAJOR 
| 
ELSE 
I 
IF ST-MAJOR-CODE = MAJOR-CODE (WS-MAJOR-SUB) 
| 
MOVE 'YES' TO WS-FOUND-MAJOR-SWITCH 
) 
MOVE EXP-MAJOR (WS-MAJOR-SUB) TO HDG-MAJOR 
j 
END-IF 
j 
END-IF. 

Chapter 
12 — 
Table 
Lookup 
P R O G R A M M I N G 
T I P 
Data names defined as switches and/or subscripts should be restricted to a single use. Consider: 
Poor 
Code 
01 
SUBSCRIPT 
PIC S9(4) 
COMP. 
01 
EOF-SWITCH 
PIC X(3) 
VALUE SPACES. 
PERFORM INITIALIZE-TITLE-FILE 
UNTIL EOF-SWITCH = 'YES'. 
MOVE SPACES TO EOF-SWITCH. 
PERFORM PROCESS-EMPLOYEE-RECORDS 
UNTIL EOF-SWITCH = 'YES
1. 
PERFORM COMPUTE-SALARY-HISTORY 
VARYING SUBSCRIPT FROM 1 BY 1 
UNTIL SUBSCRIPT > 3. 
PERFORM FIND-MATCH-TITLE 
VARYING SUBSCRIPT FROM 1 BY 1 
UNTIL SUBSCRIPT > 100. 
improved 
ooae 
01 
PROGRAM-SUBSCRIPTS. 
05 TITLE-SUBSCRIPT 
PIC S9(4) 
COMP. 
05 SALARY-SUBSCRIPT 
PIC S9(4) 
COMP. 
01 
END-OF-FILE-SWITCHES. 
05 END-OF-TITLE-FILE-SWITCH 
PIC X(3) 
VALUE SPACES. 
05 END-OF-EMPLOYEE-FILE-SWITCH PIC X(3) 
VALUE SPACES. 
PERFORM INITIALIZE-TITLE-FILE 
UNTIL END-OF-TITLE-FILE-SWITCH = 'YES'. 
PERFORM PROCESS-EMPLOYEE-RECORDS 
UNTIL END-OF-EMPLOYEE-FILE-SWITCH = 'YES'. 
PERFORM COMPUTE-SALARY-HISTORY 
VARYING SALARY-SUBSCRIPT FROM 1 BY 1 
UNTIL SALARY-SUBSCRIPT > 3. 
PERFORM FIND-MATCHING-TITLE 
VARYING TITLE-SUBSCRIPT FROM 1 BY 1 
UNTIL TITLE-SUBSCRIPT > 100. 
At the very least, the improved code offers superior documentation. By restricting data names to a single 
use, one automatically avoids such nondescript entries as EOF-SWITCH or SUBSCRIPT. Of greater impact, 
the improved code is more apt to be correct in that a given data name is modified or tested in fewer places 
within a program. Finally, if bugs do occur, the final values of the unique data names (TITLE-SUBSCRIPT and 
SALARY-SUBSCRIPT) will be of much greater use than the single value of SUBSCRIPT. 

Identifier-1 in the S E A R C H statement designates a table that contains both 
the O C C U R S a n d I N D E X E D B Y clauses. A T E N D is optional, but strongly 
recommended, to detect invalid or u n k n o w n codes. The W H E N clause specifies 
both a condition a n d an imperative sentence; the latter is executed w h e n the 
condition is satisfied (that is, w h e n a match is found.) Control passes to the statement 
immediately following the S E A R C H statement after the W H E N condition is satisfied 
or the A T E N D clause is reached. (The V A R Y I N G option is covered in Chapter 13.) 
The S E A R C H statement is illustrated in Figure 12.10 (which implements the 
identical logic of Figure 12.9). T h e table definition includes the I N D E X E D B Y 
clause, which is required by the S E A R C H statement, and establishes values through 
hard coding. 
The S E A R C H statement compares, in sequence, entries in the M A J O R S table 
to S T - M A J O R - C O D E . If n o match is found (that is, if the A T E N D condition is 
igure 12,18 
SEARCH Statement (Sequential Lookup) 
01 MAJOR-VALUE. 
05 FILLER 
PIC X(14) 
VALUE '02ART HISTORY'. 
05 FILLER 
PIC X(14) 
VALUE '04BI0LOGY'. 
05 FILLER 
PIC X(14) 
VALUE '19CHEMISTRY'. 
05 FILLER 
PIC X(14) 
VALUE '21CIVIL ENG'. 
05 FILLER 
PIC X(14) 
VALUE '24C0MP INF SYS' 
05 FILLER 
PIC X(14) 
VALUE ' 32ECONOMICS'. 
05 FILLER 
PIC X(14) 
VALUE ' 39FINANCE'. 
05 FILLER 
PIC X(14) 
VALUE '43MANAGEMENT'. 
05 FILLER 
PIC X(14) 
VALUE '49MARKETING'. 
05 FILLER 
PIC X(14) 
VALUE '54STATISTICS
1. 
01 MAJOR-TABLE REDEFINES MAJOR-VALUE. 
05 MAJORS OCCURS 10 TIMES 
[INDEXED BY MAJOR-INDEX. , . 
10 MAJOR-CODE 
PIC 9(2). 
10 EXP-MAJOR 
PIC X(12). 
PROCEDURE DIVISION. 
[SET'MAJOR^TNDEX f0 iTj——... 
SEARCH MAJORS 
AT END 
MOVE 'UNKNOWN' TO HDG-MAJ0R 
WHEN ST-MAJOR-CODE = MAJOR-CODE (MAJOR-INDEX) 
MOVE EXP-MAJOR (MAJOR-INDEX) TO HDG-MAJ0R 
END-SEARCH. 

Chapter 
12 -
Table 
Lookups 
reached), then U N K N O W N is m o v e d to H D G - M A J O R . However, if a match does 
occur, [that is, if S T - M A J G R - C Q D E = M A J O R - C O D E ( M A J O R - I N D E X ) ] , the 
appropriate major is m o v e d to H D G - M A J O R . T h e search is terminated, a n d control 
passes to the statement following the S E A R C H . 
T h e statement SET M A J O R - I N D E X T O 1 is necessary to indicate the point in 
the table where the search is to begin, and appears before the S E A R C H statement. 
Recall also that the SET statement must be used to modify a n index; that is, it is 
incorrect to say M O V E 1 T O M A J O R - I N D E X . 
S E A R C , 
Statement 
The S E A R C H A L L statement implements a binary lookup, a n d is presented below: 
SEARCH ALL identifier-1 
[END SEARCH] 
As with a sequential search statement, S E A R C H A L L requires the associated table be 
defined with an index. In addition, the codes in the table must be in sequence (either 
ascending or descending). 
The implementation of a binary search is s h o w n in Figure 12.11, and is very 
similar in appearance to Figure 12.10. Observe, however, the K E Y clause in the table 
definition to indicate the sequence in which codes appear. (In the event that codes 
in the table are out of sequence, C O B O L will not indicate a n explicit error, but the 
results of the search will be incorrect.) Note too that since S E A R C H A L L determines 
its o w n starting position in the table, a SET statement is not used in conjunction 
with a binary lookup. T h e differences between S E A R C H a n d S E A R C H A L L are 
summarized in Table 12.3. 
[AT END imperative-statement -1] 
I impei 
WHEN condition-1 {  
[NEXT 
12.3 
SEARCH versus SEARCH ALL 
Implements a sequential lookup 
Implements a binary lookup 
Requires a SET statement prior to 
SEARCH, to establish the initial 
position in the table 
Does not require an initial SET 
statement (calculates its own 
starting position) 
Does not require codes in the 
table to be in any special 
sequence 
Requires codes to be in 
(ascending or descending) 
sequence on the associated KEY 
clause in the table definition 
Contains an optional VARYING 
clause (See Figure 13.18) 
Does not contain a VARYING clause 
May specify more than one 
WHEN clause 
Restricted to a single WHEN clause 
A positional table results in wasted space but permits a far faster table lookup in 
that y o u go directly to the appropriate table entry. Implementation of a direct 
lookup is s h o w n in Figure 12.12. 

SEARCH ALL Statement (Binary Lookup) 
01 MAJOR-VALUE 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
PIC X(14) 
VALUE '02ART HISTORY' 
VALUE '04BI0L0GY'. 
VALUE '19CHEMISTRY'. 
VALUE '21CIVIL ENG
1. 
VALUE '24C0MP INF SYS 
VALUE '32EC0N0MICS'. 
VALUE '39FINANCE'. 
VALUE '43MANAGEMENT'. 
VALUE '49MARKETING'. 
VALUE '54STATISTICS'. 
01 MAJOR-TABLE REDEFINES MAJOR-VALUE. 
05 MAJORS OCCURS 10 TIMES 
ASCENDING KEY IS MAJOR-CODE 
INDEXED BY MAJOR-INDEX. 
10 MAJOR-CODE 
PIC 9(2). 
10 EXP-MAJOR 
PIC X(12). 
PROCEDURE DIVISION. 
SEARCH ALL MAJORS 
AT END 
MOVE 'UNKNOWN' TO HDG-MAJOR 
WHEN MAJOR-CODE (MAJOR-INDEX) = ST-MAJOR-CODE 
MOVE EXP-MAJOR (MAJOR-INDEX) TO HDG-MAJOR 
END-SEARCH. 
The codes themselves are not stored in the table of descriptive values as the 
position of an entry within the table corresponds to its associated code. The direct 
lookup is in essence a single M O V E statement in which the descriptive value in the 
indicated table position is chosen. T h e associated IF statement ensures that the 
incoming code lies within the range of the table. 
A range-step table is used w h e n the s a m e table value is applicable to multiple 
search arguments—that is, w h e n there is n o longer a one-to-one correspondence 
between a table value and the search argument. The computation of federal income 
tax is a well-known example as the s a m e tax rate is applied to an entire tax bracket; 
that is, there is one tax rate for all incomes less than $20,000, a different rate for 
incomes between $20,000 a n d $40,000, a n d so on. 
The scholarship table in Figure 12.13a is another example of a range-step 
table in which the a m o u n t of financial aid depends o n a student's grade point 

Chapter 
12 — 
Table 
Lookups 
12 
Direct Access to Table Entries 
01 MAJOR-VALUE. 
05 FILLER 
PIC X(12) 
VALUE 'UNKNOWN'. 
05 FILLER 
PIC X(12) 
VALUE 'ACCOUNTING' 
05 FILLER 
PIC X(12) 
VALUE 'UNKNOWN'. 
05 FILLER 
PIC X(12) 
VALUE 'BIOLOGY'. 
05 FILLER 
PIC X(12) 
VALUE 'STATISTICS' 
01 MAJOR-TABLE REDEFINES MAJOR-VALUE. 
05 MAJORS OCCURS 54 TIMES 
PIC X(12). 
PROCEDURE DIVISION. 
jIF ST-MAJOR-CODE > 0 AND ST-MAJOR-CODE < 55 
MOVE MAJORS (ST-MAJOR-CODE) TO HDG-MAJOR 
ELSE 
MOVE 'UNKNOWN' TO HDG-MAJOR 
END-IF. 
Figure 12.13 
Range-step Table 
Grade Point 
Scholarship 
Average 
Percentage 
3.75 - 4 00 
100 
3.50 - 3 74 
75 
3.25 - 3 49 
50 
3.00 - 3 24 
33 
2.75 - 2 99 
25 
2.50 - 2 74 
15 
average. Students with a G P A between 2.50 and 2.74 receive a scholarship of 15%, 
students with a G P A between 2.75 a n d 2.99 an award of 2 5 % , a n d so on. 
T h e C O B O L implementation is s h o w n in Figure 12.13b. T h e scholarship table 
is hard coded a n d parallels the earlier example in Figure 12.5. T h e G P A table includes 
the m i n i m u m grade point average a n d corresponding scholarship a m o u n t for each 
of the six table entries. (There is no need to include the corresponding m a x i m u m 
grade point average). 

A 
Complete 
Example 
(continued) 
01 
SCHOLARSHIP-TABLE. 
05 
GPA-SCHOLARSHIP-PERCENTAGES. 
10 
FILLER 
P I C X(6) 
10 
FILLER 
P I C X(6) 
10 
FILLER 
P I C X(6) 
10 
FILLER 
P I C X(6) 
10 
FILLER 
P I C X(6) 
10 
FILLER 
P I C X(6) 
VALUE '375100' . 
VALUE '350075'. 
V A L U E '325050'. 
VALUE '300033'. 
VALUE '275025'. 
VALUE '250015'. 
PERCENTAGES 
05 
G P A - T A B L E REDEFINES G P A - S C H O L A R S H I P 
OCCURS 6 TIMES 
INDEXED BY GPA-INDEX. 
10 
GPA-MINIMUM 
P I C 9V99. 
10 
SCHOLARSHIP-PCT 
P I C 9 9 9 . 
SET GPA-INDEX TO 1. 
SEARCH G P A - T A B L E 
AT END 
M O V E ZERO TO SCHOLARSHIP-AWARD 
| W H E N ITUDENT-GPA > = G P A - M J N I M U M J G P A - I N D E X ) j 
M O V E SCHOLARSHIP-PCT (GPA-INDEX) T O SCHOLARSHIP-AWARD 
END-SEARCH. 
The S E A R C H statement implements a sequential search similar to the earlier 
example in Figure 12.10. Note, however, that the W H E N condition uses a greater 
than or equal condition in accordance with the definition of the range-step table. 
W e are ready n o w to incorporate the material o n table lookups a n d initialization 
procedures into a complete example. Specifications are as follows: 
P R O G R A M M I N G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
Program Name: 
Tables 
Narrative: 
This program fully illustrates table processing. Two distinct means for initialization (hard 
coding and input loaded tables) are shown, as are three techniques for table lookups 
(sequential, binary, and direct access to table entries). 
Input File(s): 
EMPLOYEE-FILE 
TITLE-FILE 

Chapter 
12 ----- 
Table 
Lookups 
Employee Record: 
Title Record: 
COLUMNS 
FIELD 
PICTURE 
1-20 
Name 
X(20) 
21-24 
Title Code 
X(4) 
25-27 
Location Code 
X(3) 
28 
Education Code 
9 
29-34 
Employee Salary 
9(6) 
C O L U M N S 
F I E L D 
PICTURE 
1-4 
Title Code 
X(4) 
5-19 
Descriptive Value 
X(15) 
Test Data: 
See Figure 12.14a for TITLE-FILE. See Figure 12.14b for EMPLOYEE-FILE. 
Report Layout: 
See Figure 12.14c. 
Processing Requirements: 
1. Process an employee file, with each record containing the employee's salary as well 
as coded data on an employee's location, education, and title. 
2. The table of location codes is to be hard-coded into the program and expanded via a 
sequential search. Location codes and their descriptive values are shown below: 
CODE 
CITY 
ATL 
Atlanta 
BOS 
Boston 
CHI 
Chicago 
DET 
Detroit 
KC 
Kansas City 
LA 
Los Angeles 
MIN 
Minneapolis 
NY 
New York 
PHI 
Philadelphia 
SF 
San Francisco 
3. The education codes are to be stored in a positional table and expanded via a direct 
lookup. Education codes and their descriptive values are shown below: 
CODE 
EDUCATION 
1 
Some high school 
2 
High school diploma 
3 
Two-year degree 
4 
Four-year degree 
5 
Some graduate work 
6 
Master's degree 
7 
Doctorate degree 
8 
Other 
4. The table of title codes is to be read from a file and expanded via a binary search. The 
title codes and their descriptive values were shown earlier in Figure 12.14a. 
5. The amount of life insurance is determined by the employee's salary according to the 
following range-step table: 

A Complete 
Example 
Test Data and Report 
1000PROGRAMMER 
1500DATA BASE 
20000PERATOR 
2999SYSTEMS ANALYST 
3499DATA DICTIONARY 
JACKIE CLARK 
2999CHI4025000 
MARGOT HUMMER 
1000LA 6080000 
PERCY GARCIA 
2999IND3015000 
CATHY BENWAY 
3499ATL5110000 
LOUIS NORIEGA 
0100NC 9035000 
JUD MCDONALD 
1500ATL3065000 
NELSON KERBEL 
1000PHI3038000 
Employee P i e 
EMPLOYEE 
LOCATION 
TITLE 
EDUCATION 
SALARY 
LIFE INS 
JACKIE CLARK 
CHICAGO 
SYSTEMS ANALYST 4YR DEGREE 
$25,000 
$80,000 
MARGOT HUMMER 
LOS ANGELES 
PROGRAMMER 
MASTERS 
$80,000 $250,000 
PERCY GARCIA 
UNKNOWN 
SYSTEMS ANALYST 2YR DEGREE 
$15,000 
$40,000 
CATHY BENWAY 
ATLANTA 
DATA DICTIONARY SOME GRAD 
$110,000 $500,000 
LOUIS NORIEGA 
UNKNOWN 
UNKNOWN 
UNKNOWN 
$35,000 
$80,000 
JUD MCDONALD 
ATLANTA 
DATA BASE 
2YR DEGREE 
$65,000 $175,000 
NELSON KERBEL 
PHILADELPHIA 
PROGRAMMER 
2YR DEGREE 
$38,000 
$80,000 
SALARY R A N G E 
LIFE INSURANCE 
<=$ 20,000 
$40,000 
$20,001-$ 40,000 
$80,000 
$ 40,001-$ 75,000 
$ 175,000 
$ 75,001-$ 100,000 
$ 250,000 
$ 100,001-$ 200,000 
$ 500,000 
6. Print a detail line for each employee with descriptive information for location, education, 
title, and life insurance. Single-space this report. 
The hierarchy chart for the table lookup is s h o w n in Figure 12.15. T h e highest-level 
module, P R O D U C E - E M P L O Y E E - R E P O R T , contains three subordinates to initialize 
the title table (the specifications called for an input-loaded table), write a heading 

Chapter 
12 
Table 
Lookups 
1„> i? 
Hierarchy Chart for I able-Lookup Program 
INITIALIZE 
TITLE 
TABLE 
PRODUCE 
EMPLOYEE 
REPORT 
WRITE 
HEADING 
LINE 
PROCESS 
EMPLOYEE 
RECORDS 
EXPAND 
TITLE 
CODE 
EXPAND 
LOCATION 
CODE 
EXPAND 
EDUCATION 
CODE 
DETERMINE 
INSURANCE 
AMOUNT 
WRITE 
DETAIL 
LINE 
line, and process employee records; the latter includes four lower modules for the 
four table lookups. 
The associated pseudocode is shown in Figure 12.16 a n d uses the in-line 
perform a n d false-condition branch first to process both the title and employee 
files. The title file is processed first a n d includes a check to ensure that the size of the 
title table is not exceeded. After the last record from the title file has been read, the 
employee file is opened a n d processed in its entirety. Each incoming employee 
record has its title, location, a n d education codes expanded, the a m o u n t of insurance 
determined, a n d a detail line written. 
The Completed Program 
„._ 
.„ 
The completed program is s h o w n in Figure 12.17. T h e paragraphs in the Procedure 
Division correspond one to one with the modules in the hierarchy chart, and its 
logic in the program parallels that of the pseudocode just developed. T h e program 
complies with the processing requirements a n d also illustrates the various C O B O L 
features presented earlier. Note the following: 
1. The use of three S E L E C T statements for E M P L O Y E E - F I L E , PRINT-FILE, a n d 
TITLE-FILE; the latter is used to dynamically load the title table. 
2. Omission of all optional clauses in the F D entries in the Data Division; that 
is, the F D contains only the file n a m e . T h e optional reserved w o r d FILLER 
is also omitted throughout the Data Division (see Limitations of C O B O L - 7 4 
o n page 357). 
3. The use of R E A D I N T O a n d W R I T E F R O M throughout the Procedure Division; 
this is not a requirement of table processing per se, but a coding style used 
throughout the text. 
4. T h e definition of the location table in lines 43-59 through combination 
of the V A L U E S , O C C U R S , a n d R E D E F I N E S clauses. T h e location table 
includes the I N D E X E D B Y clause as required b y the S E A R C H statement in 
lines 190-196. 

A Complete 
Example 
Pseudocode for Table-Lookup Program 
Open title file 
DO WHILE title data remains or title table not exceeded 
READ title file 
AT END 
Indicate no more title data 
NOT AT END 
Increment number of titles in table 
Move incoming title to current position in table 
1 
ENDREAD 
ENDDO 
IF title table exceeded 
Display error message 
ENDIF 
Close title file 
Open employee file and print file 
DO WHILE employee data remains 
— 
READ employee file 
| 
AT END 
j 
Indicate no more data 
NOT AT END 
Expand title code 
Expand location code 
Expand education code 
Determine insurance amount 
: 
Write detail line 
ENDREAD 
ENDDO 
Close employee file and print file 
Stop run 
Table-Lookup Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
TABLES. 
3 
AUTHOR. 
ROBERT GRAUER 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT EMPLOYEE-FILE 
ASSIGN TO 'A:\CHAPTR12\TABLES.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
14 
15 
DATA DIVISION. 
SELECT TITLE-FILE 
ASSIGN TO 'A:\CHAPTR12\TITLES.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 

Chapter 
12 
Table 
Lookups 
A 7 
(continued) 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
F I L E SECTION. 
FD 
T I T L E - F I L E . 
01 
T I T L E - I N 
FD 
E M P L O Y E E - F I L E . 
01 
EMPLOYEE-RECORD 
FD 
P R I N T - F I L E . 
01 
P R I N T - L I N E 
PIC X ( 1 9 ) . 
PIC X ( 3 4 ) . 
PIC X ( 1 3 2 ) . 
W O R K I N G - S T O R A G E SECTION. 
01 
P I C X(14) 
V A L U E 'WS BEGINS HERE'. 
01 
P R O G R A M - S W I T C H E S - A N D - C O U N T E R S . 
•^S
-"END^-flTLl^FiLE 
PTC"X{3) 
05 
E N D - O F - E M P - F I L E 
P I C X(3) 
05 
N U M B E R - O F - T I T L E S 
V A L U E 'NO 
'NO 
PIC 9 9 9 
V A L U E ZEROS. 
01 
T I T L E - T A B L E . 
05 
T I T L E S O C C U R S 1 T O 9 9 9 T I M E S 
D E P E N D I N G O N N U M B E R - O F - T I T L E S 
r A S C E N D JTWHCEYIS
- TTTLI: - cobT~l ^ 
39 
INDEXED BY TITLE-INDEX. 
SCtNUING 
KEYciauSx 
r 
40 
10 
T I T L E - C O D E 
PIC X ( 4 ) . 
41 
10 
T I T L E - N A M E 
P I C X(15) 
42 
43 
01 
L O C A T I O N - V A L U E . 
44 
05 
PIC X(16) V A L U E 'ATLATLANTA'. 
45 
05 
PIC X(16) V A L U E 'BOSBOSTON'. 
46 
05 
PIC X(16) V A L U E 'CHICHICAGO'. 
47 
05 
PIC X(16) V A L U E 'DETDETROIT'. 
48 
05 
PIC X(16) V A L U E 
1 K C KANSAS CITY'. 
49 
05 
PIC X(16) V A L U E 'LA LOS ANGELES'. 
50 
05 
PIC X(16) V A L U E 'MINMINNEAPOLIS'. 
51 
05 
PIC X(16) V A L U E 'NY N E W YORK'. 
52 
05 
PIC X(16) V A L U E ' PHIPHILADELPHIA'. 
53 
05 
PIC X(16) V A L U E 'SF SAN FRANCISCO'. 
54 
55 
01 
L O C A T I O N - T A B L E REDEFINES LOCATION- VALUE. 
56 
05 
LOCATIONS OCCURS 10 T I M E S 
57 
INDEXED BY LOCATION- INDEX. 
5 8 
10 
LOCATION-CODE 
PIC X ( 3 ) . 
59 
10 
LOCATION-NAME 
PIC X(13) 
60 
61 
01 
E D U C A T I O N - T A B L E . 
X. 
62 
05 
E D U C A T I O N - V A L U E S . 
63 
10 
PIC X(10) 
V A L U E 'SOME HS'. 
64 
10 
PIC X(10) 
V A L U E 'HS DIPLOMA'. 

A Complete 
Example 
(continued) 
65 
10 
PIC X(10) 
VALUE '2YR DEGREE
1. 
66 
10 
PIC X(10) 
VALUE '4YR DEGREE'. 
67 
10 
PIC X(10) 
VALUE 'SOME GRAD'. 
68 
10 
PIC X(10) 
VALUE 'MASTERS'. 
69 
10 
PIC X(10) 
VALUE 'PH. D.'. 
70 
10 
PIC X(10) 
VALUE 'OTHER'. 
71 
05 EDU-NAME REDEFINES EDUCATION-VALUES 
72 
OCCURS 8 TIMES 
PIC X(10). 
73 
74 
01 SALARY-INSURANCE-TABLE 
75 
05 
INSURANCE-VALUES. 
76 
10 
PIC X(12) 
VALUE '020000040000'. 
77 
10 
PIC X(12) 
VALUE '040000080000'. 
78 
10 
PIC X(12) 
VALUE '075000175000'. 
79 
10 
PIC X(12) 
VALUE '100000250000'. 
80 
10 
PIC X(12) 
VALUE '200000500000'. 
81 
05 INSURANCE-TABLE REDEFINES INSURANCE-VALUES 
82 
OCCURS 5 TIMES 
83 
INDEXED BY INSURANCE-INDEX. 
84 
10 SALARY-MAXIMUM 
PIC 9(6). 
85 
10 INSURANCE-AMOUNT PIC 9(6). 
86 
87 
01 HEADING-LINE. 
88 
05 
PIC X(2) 
VALUE SPACES. 
89 
05 
PIC X(10) 
VALUE 'EMPLOYEE'. 
90 
05 
PIC X(10) 
VALUE SPACES. 
91 
05 
PIC X(8) 
VALUE 'LOCATION'. 
92 
05 
PIC X(7) 
VALUE SPACES. 
93 
05 
PIC X(5) 
VALUE 'TITLE'. 
94 
05 
PIC X(12) 
VALUE SPACES. 
95 
05 
PIC X(10) 
VALUE 'EDUCATION'. 
96 
05 
PIC X(4) 
VALUE SPACES. 
97 
05 
PIC X(6) 
VALUE 'SALARY'. 
98 
05 
PIC X(3) 
VALUE SPACES. 
99 
05 
PIC X(8) 
VALUE 'LIFE INS'. 
100 
05 
PIC X(47) 
VALUE SPACES. 
101 
102 
01 DASHED-LINE. 
103 
05 
PIC X(85) 
VALUE ALL '-'. 
104 
05 
PIC X(47) 
VALUE SPACES. 
105 
106 
01 DETAIL-LINE. 
107 
05 DET-NAME 
PIC X(20). 
108 
05 
PIC XX 
VALUE SPACES. 
109 
05 DET-LOCATION 
PIC X(13). 
110 
05 
PIC XX 
VALUE SPACES. 
111 
05 DET-TITLE 
PIC X(15). 
112 
05 
PIC XX 
VALUE SPACES. 
113 
05 DET-EDUCATION 
PIC X(10). 
114 
05 
PIC XXX 
VALUE SPACES. 

Chapter 
12 — 
Table 
Lookups 
^i"' 
(continued) 
115 
05 DET-SALARY 
PIC $$$$,$$$. 
116 
05 
PIC XX 
VALUE SPACES. 
117 
05 DET-INSURANCE 
PIC $$$$,$$$. 
118 
05 
PIC X(47) 
VALUE SPACES. 
119 
120 
01 WS-EMPLOYEE-RECORD. 
121 
05 EMP-NAME 
PIC X(20). 
122 
05 EMP-TITLE-CODE 
PIC X(4). 
123 
05 EMP-LOC-CODE 
PIC X(3). 
124 
05 EMP-EDUC-CODE 
PIC 9. 
125 
05 EMP-SALARY 
PIC 9(6). 
126 
127 
01 WS-TITLE-RECORD. 
128 
05 TITLE-IN-CODE 
PIC X(4). 
129 
05 TITLE-IN-NAME 
PIC X(15). 
130 
131 
PROCEDURE DIVISION. 
132 
100 -PRODUCE-EMPLOYEE-REPORT. 
1 ?i 
"PERFORM 200- IN ITIALIZE -TIT LE - TAB LE 7h 
134 
OPEN INPUT EMPLOYEE-FILE 
135 
OUTPUT PRINT-FILE. 
136 
PERFORM 300-WRITE-HEADING-LINES. 
137 
PERFORM UNTIL END-OF-EMP-FILE = 'YES' 
138 
READ EMPLOYEE-FILE INTO WS-EMPLOYEE-RECORD 
139 
AT END 
140 
MOVE 'YES' TO END-OF-EMP-FILE 
141 
NOT AT END 
142 
PERFORM 400-PROCESS-EMPLOYEE-RECORDS 
143 
END-READ 
144 
END-PERFORM. 
145 
CLOSE EMPLOYEE-FILE 
146 
PRINT-FILE. 
147 
STOP RUN. 
148 
149 
200 -INITIALIZE-TITLE-TABLE. 
150 
OPEN INPUT TITLE-FILE. 
151 
PERFORM VARYING TITLE-INDEX FROM 1 BY 1 
152 
UNTIL END-OF-TITLE-FILE = 'YES' 
-Checks tlx 
153 
[OR TITLE-INDEX > 999i 
154 
READ TITLE-FILE INTO WS-TITLE-RECORD 
155 
AT END 
156 
MOVE 'YES' TO END-OF-TITLE-FILE 
157 
NOT AT END 
158 
ADD 1 TO NUMBER-OF-TITLES 
159 
MOVE TITLE-IN-CODE TO TITLE-CODE (TITLE-INDEX) 
160 
MOVE TITLE-IN-NAME TO TITLE-NAME (TITLE-INDEX) 
161 
END-READ 
162 
END-PERFORM. 
163 
IF TITLE-INDEX > 999 
164 
DISPLAY 'SIZE OF TITLE TABLE IS EXCEEDED' 

A Complete 
Example 
(continued) 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
1 0 7 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
END-IF. 
CLOSE TITLE-FILE. 
300-WRITE-HEADING-LINES. 
WRITE PRINT-LINE FROM HEADING-LINE 
AFTER ADVANCING PAGE. 
WRITE PRINT-LINE FROM DASHED-LINE 
AFTER ADVANCING 1 LINE. 
400-PR0CESS-EMPL0YEE-REC0RDS. 
PERFORM 420-EXPAND-TITLE-CODE. 
PERFORM 430-EXPAND-L0CATI0N-C0DE. 
PERFORM 440-EXPAND-EDUCATI0N-C0DE. 
PERFORM 450-DETERMINE-INSURANCE-AMOUNT. 
PERFORM 470-WRITE-DETAIL-LINE. 
420-EXPAND-TITLE-CODE. 
_ 
! SEARCH ALL TITLES 
AT END 
MOVE 'UNKNOWN' TO DET-TITLE 
WHEN TITLE-CODE (TITLE-INDEX) = EMP-TITLE-CODE 
MOVE TITLE-NAME (TITLE-INDEX) TO DET-TITLE 
430-EXPAND-LOCATION-CODE^ 
; SET LOCATION-INDEX TO 1. 
! SEARCH LOCATIONS 
AT END 
MOVE 'UNKNOWN' TO DET-LOCATION 
WHEN EMP-LOC-CODE = LOCATION-CODE (LOCATION-INDEX) 
MOVE LOCATION-NAME (LOCATION-INDEX) TO DET-LOCATION 
END-SEARCH. 
440-EXPAND-EDJJ^ATI0N-C0DE. 
IF EMP-EDUC-CODE < 1 OR > 8 
MOVE 'UNKNOWN' TO DET-EDUCATION 
ELSE 
MOVE EDU-NAME (EMP-EDUC-CODE) TO DET-EDUCATION 
END-IF.' 
450-DETERMINE-INSURANCE-AMOUNT. 
IF EMP-SALARY IS NUMERIC 
SET INSURANCE-INDEX TO 1 
SEARCH INSURANCE-TABLE 
AT END 
MOVE ZERO TO DJ^T-INSURANCE 
I WHEN EMP-SALARY <= SALARY-MAXIMUM (INSURANCE-INDEX) 
MOVE INSURANCE-AMOUNT (INSURANCE-INDEX) 
TO DET-INSURANCE 
END-SEARCH 

Chapter 
12 — 
Table 
Lookups 
(continued) 
215 
216 
217 
218 
ELSE 
DISPLAY 'INCOMING SALARY NOT NUMERIC' 
MOVE ZERO TO DET-INSURANCE 
END-IF. 
220 
221 
222 
223 
224 
225 
470-WRITE-DETAIL-LINE. 
MOVE SPACES TO PRINT-LINE. 
MOVE EMP-NAME TO DET-NAME. 
MOVE EMP-SALARY TO DET-SALARY. 
WRITE PRINT-LINE FROM DETAIL-LINE 
AFTER ADVANCING 1 LINE. 
5. The definition of the education table (lines 61-72) as a positional tabie; that is, 
the education codes themselves (1, 2, ... ,8) are not entered in the table, a n d 
the incoming employee education code is expanded via direct access to a 
table entry in the M O V E statement of line 202. (The IF statement in line 199 is 
executed prior to the M O V E to ensure a valid education code.) 
6. The definition of the insurance table (lines 74-85), which includes an I N D E X E D 
W H E N clause in line 211 includes a less than or equal condition consistent 
with the implementation of a range-step table. 
7. T h e definition of the title table as input loaded in lines 35-41; that is, the 
O C C U R S clause merely allocates spaces for the table but does not assign 
values to it; the latter is done dynamically in lines 150-166 of the Procedure 
Division. Note, too, the inclusion of the I N D E X E D B Y a n d A S C E N D I N G K E Y 
clauses that are required by the S E A R C H A L L statement in lines 182-187. 
The flow in the Procedure Division is straightforward a n d easy to follow. T h e 
P E R F O R M statement in line 133 initializes the title table, after which the employee 
and print files are opened a n d a heading line is written. The combination of the in­
line perform and false-condition branch in lines 137 through 144 processes employee 
records until the file is exhausted. 

Summary 
The optional END-SEARCH scope terminator is new to COBOL-85 and 
terminates the conditional portion of the SEARCH and SEARCH ALL 
statements. 
The word FILLER is optional, making possible Data Division entries of 
the form: 
01 MAJOR-VALUE. 
05 
PIC X(14) 
VALUE '02ART HISTORY'. 
05 
PIC X(14) 
VALUE '04BI0L0GY'. 
05 
PIC X(14) 
VALUE ' 19CHEMISTRY'. 
The entries look strange initially, but make perfect sense when you realize 
that data names defined as FILLER are not referenced in the Procedure 
Division; that is, omission of the word FILLER has no effect on the remainder 
of a program. 
ics i s K e m e m o e r 
Codes may be alphabetic, numeric, or alphanumeric. A good coding 
system will be precise, mnemonic, and expandable. 
The VALUE, OCCURS, and REDEFINES clauses are used in combination 
to define and initialize a table within a COBOL program. 
A table lookup may be implemented sequentially, in binary fashion, or 
through direct access to table entries. 
A range-step table occurs when there is no one-to-one correspondence 
between a table value and the search argument. 
Tables may be initialized through hard coding or dynamically loaded at 
execution time. 
A SEARCH statement is used to implement a sequential lookup. The 
statement requires the INDEXED BY clause in the table definition. 
A SEARCH ALL statement is used to implement a binary lookup. The 
statement requires the INDEXED BY and KEY clauses in the table 
definition, and requires the keys in the table to be in either ascending or 
descending sequence. 

Chapter 
12 
Table 
Lookups 
«3B€f 
Alphabetic code 
Alphanumeric code 
Binary table lookup 
Direct access to table entries 
Hard coding 
Index 
Input-loaded table 
Mnemonic code 
Numeric code 
Positional organization 
Precise code 
Range-step table 
Sequential table lookup 
Subscript 
Table lookup 
ASCENDING KEY 
AT END 
DESCENDING KEY 
END-SEARCH 
INDEXED BY 
OCCURS 
PERFORM VARYING 
REDEFINES 
SEARCH 
SEARCH ALL 
SET 
VALUE 
WHEN 
1. A two-position numeric code has 
combinations; a two-position 
alphabetic code has 
; and a two-position alphanumeric code 
has 
. 
2. A 
table lookup does not require its entries to be in any special 
order, whereas a binary table lookup requires that the entries be in either  
or 
sequence. 
3. If a table is 
then the program in which it is 
found must be recompiled in order to change the table. 
4. An 
table makes it possible to change entries 
in the table without recompiling the program. 
5. Direct access to table entries is possible only if the table has 
organization. 
6. A sequential table lookup in a table of 500 elements could require as many as 
tries, whereas a binary lookup for the same table would take no 
more than 
tries. 
7. The 
clause gives another name to previously allocated space. 
8. A sequential table lookup is implemented by the 
statement, 
whereas a binary lookup is implemented by 
. 
9. The ASCENDING/DESCENDING 
clause is required in the table 
definition if a binary table lookup is to be implemented. 
10. The 
statement appears before a sequential search, but is not 
used prior to a binary search. 
11. The 
clause is required in a table's definition if either a sequential 
or binary search is used. 

12. The REDEFINES clause (must/may) be used when initializing a table. 
13. If the wrong number of subscripts are used with a particular data name, a 
(compilation/execution) e r r o r 
wj|| result. 
14. A SET statement (is/is not) U Sed before a SEARCH ALL statement, as the binary 
algorithm calculates its own starting position. 
15. A 
table occurs when there is no longer a one-
to-one correspondence between a table value and the search argument. 
1. A binary search over a table of 500 elements requires 9 or fewer comparisons. 
2. A sequential search over a table of 500 elements could require 500 comparisons. 
3. Direct access to table entries requires no comparisons. 
4. The SEARCH statement requires an index. 
5. SEARCH ALL denotes a binary search, 
6. There are no additional requirements of table organization In order to implement a 
binary rather than a sequential search. 
7. An index (that is, displacement) of zero refers to the first element in a table. 
8. A subscript of zero refers to the first element in a table. 
9. An index cannot be manipulated by a MOVE statement. 
10. PERFORM VARYING can manipulate both indexes and subscripts. 
11. A SEARCH statement can contain only a single WHEN clause. 
12. The ASCENDING (DESCENDING) KEY clause is required whenever the SEARCH 
statement is applied to a table. 
13. The INDEXED BY clause is required whenever the SEARCH statement is applied to 
a table, 
14. The same index can be applied to many tables. 
15. The same subscript can be applied to many tables. 
16. An index and a subscript can be applied to the same table. 
17. The REDEFINES clause provides another name for previously allocated space. 
18. The REDEFINES clause must be used in initializing a table. 
19. A binary search could be applied to a table if its elements were arranged in 
descending (rather than ascending) sequence. 
20. A numeric code of four digits provides a greater number of possibilities than a 
three-digit alphabetic code. 
21. Codes are used for reasons other than to conserve space. 
22. Alphabetic codes are more likely to be mnemonic than numeric codes. 
23. Numeric codes, such as Social Security numbers, should not be unique to 
accommodate individuals with the same last name. 
24. Positionally organized tables require the first code to begin at 1. 

Chapter 
12 — 
Table 
Lookups 
25. Positionally organized tables require numeric codes. 
26. Positionally organized tables often result in large amounts of wasted space. 
27. A range-step table requires a one-to-one correspondence between the table value 
and search argument. 
28. The federal income tax table is an example of a range-step table. 
1. How many unique codes can be developed from a four-position numeric code? 
From a four-position alphabetic code? From a four-position alphanumeric code? 
2. Ask a friend to pick a number from 1 to 2,000. What is the maximum number of 
guesses required to find the number if 
a. a binary search is used? 
b. a sequential search is used? 
Answer parts (a) and (b), if the selected number is between 1 and 4,000. 
3. What, if anything, is wrong with the following table definition? 
01 MONTH-TABLE. 
05 MONTH OCCURS 12 TIMES 
PIC X(4). 
05 MONTH-VALUES REDEFINES MONTH 
PIC X(36) 
VALUE 'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC
1. 
4. The DAY-OF-WEEK phrase was introduced in Chapter 9 (page 242) to obtain a 
one-position code corresponding to the day of the week. An alternate way of 
expanding the code (as opposed to the EVALUATE statement in Chapter 9) is to 
use a positional table and direct lookup. 
a. Use the data names in Figure 12.18 to write the appropriate ACCEPT statement. 
b. Write the necessary statements to implement a direct lookup on the table of 
Figure 12.18. 
_ 
>' 
DAY-OF-WEEK Table 
DAY -CODE-VALUE 
PIC 9. 
DAY -HEADING. 
05 FILLER 
PIC X(9) 
VALUE 'TODAY IS 
05 TODAYS-DAY 
PIC X(9). 
DAY -0F-WEEK-VALUE. 
05 FILLER 
PIC X(9) 
VALUE 'MONDAY'. 
05 FILLER 
PIC X(9) 
VALUE 'TUESDAY'. 
05 FILLER 
PIC X(9) 
VALUE 'WEDNESDAY 
05 FILLER 
PIC X(9) 
VALUE 'THURSDAY' 
05 FILLER 
PIC X(9) 
VALUE 'FRIDAY'. 
05 FILLER 
PIC X(9) 
VALUE 'SATURDAY' 
05 FILLER 
PIC X(9) 
VALUE 'SUNDAY'. 
01 DAY-OF-WEEK-TABLE REDEFINES MAJOR-VALUE. 
05 DAY OCCURS 7 TIMES 
PIC X(9). 

5. Given the following table definition: 
01 LOCATION-VALUE. 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
05 FILLER 
PIC 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
PIC X(16) 
VALUE '010ATLANTA'. 
VALUE '020B0ST0N'. 
VALUE '030CHICAG0'. 
VALUE '040DETR0IT'. 
VALUE '050KANSAS CITY'. 
VALUE '060L0S ANGELES'. 
VALUE '070NEW YORK
1. 
VALUE '080PHILADELPHIA' 
VALUE '090SAN FRANCISCO 
VALUE '045DENVER'. 
01 LOCATION-TABLE REDEFINES LOCATION-VALUE. 
05 LOCATION OCCURS 10 TIMES 
ASCENDING KEY IS LOCATION-CODE 
INDEXED BY LOCATION-INDEX. 
10 LOCATION-CODE 
PIC X(3). 
10 LOCATION-NAME 
PIC X(13). 
and the following Procedure Division code: 
SET LOCATION-INDEX TO 1. 
SEARCH LOCATION 
AT END 
DISPLAY '*ERROR IN SEQUENTIAL SEARCH FOR DENVER' 
WHEN LOCATION-CODE (LOCATION-INDEX) = '045' 
DISPLAY 'SEQUENTIAL SEARCH OK FOR DENVER' 
END-SEARCH. 
SEARCH LOCATION 
DISPLAY
 
1*ERROR IN SEQUENTIAL SEARCH FOR NEW YORK' 
WHEN LOCATION-CODE (LOCATION-INDEX) = '070' 
DISPLAY 'SEQUENTIAL SEARCH OK FOR NEW YORK' 
END-SEARCH. 
a. Indicate the output that will be produced. 
b. Code a binary search statement to expand code 045 for Denver. Do you expect 
any trouble in the execution of that statement? 
AT END 


Overview 
System C o n c e p t s 
COBOL Implementation 
One-Level T a b l e s 
PERFORM VARYING 
T w o - L e v e l T a b l e s 
Errors In Compilation 
PERFORM VARYING 
A Sample Program 
Programming Specifications 
Program Design 
The Completed Program 
T h r e e - L e v e l T a b l e s 
PERFORM VARYING 
A Sample Program 
Programming Specifications 
The Completed Program 
Table L o o k u p s 
A C a l o r i e Counter's Delight 
Programming Specifications 
Range-Step Tables 
The Completed Program 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
1 3 
Multilevel 
Tables 
O 8 J E 
After reading this chapter you will be able to: 
Describe a conceptual (user's) view of one-, two-, and three-level tables; 
implement (that is, define and initialize) one-, two-, and three-level tables in 
COBOL. 
Differentiate between the VALUE, OCCURS, and REDEFINES clauses as 
they relate to table definition and initialization. 
Distinguish between errors in compilation versus errors in execution; give 
an example of each as it pertains to multilevel table processing. 
Explain the operation of a PERFORM VARYING statement; develop suitable 
examples to process tables in one, two, and three dimensions. 
Use the VARYING option of the S E A R C H statement; nest S E A R C H 
statements 'within one another for multilevel-table lookups. 
V E Fi V I E W 
COBOL-85 allows multilevel tables of up to seven dimensions as opposed to the 
earlier limit of three in COBOL-74. Most applications do not require anything 
beyond a three-level table, and thus our coverage is limited to two- and three-
level tables. The underlying concepts are identical regardless of a table's 
complexity, and hence our approach to multilevel tables will be a simple extension 
of the single-level problem. 
We begin with a one-level example and develop it completely. This material 
reviews some discussion from the previous chapter, but is included nonetheless, 
in order to build the parallel between one-, two-, and three-level examples. Our 
presentation reexamines the OCCURS, VALUE, and REDEFINES clauses in the 
Data Division, and the PERFORM VARYING statement in the Procedure Division. 
We then extend the discussion to two and three dimensions and present complete 
programs to illustrate all statements. 
The chapter concludes with a third program to implement table lookups in 
a multilevel table. The example introduces the VARYING option of the S E A R C H 
statement and also nests S E A R C H statements within one another. 
Figure 13.1a depicts the user's view of a table of starting salaries within a company. 
In this example, a n employee starts at o n e of 10 salaries, depending o n the 
responsibility level for his or her job. A junior account executive, for example, m a y 
be designated as having a responsibility level of 1, whereas a divisional manager 
m a y be assigned level 10. T h e 10 salaries together comprise a salary table, with 
individual values designated b y a subscript. T h e starting salary at responsibility 
level four, for example, is $30,000. 

System 
Multilevel Tables 
1 
26,000 
2 
27,000 
3 
28,000 
4 
[ . i s m ; -
5 
32,000 
Responsibly 
6 
34,000 
Responsibly 
7 
36,000 
8 
39,000 
9 
42.000 
10 
46,000 
Experience 
1 
2 
3 
4 
.-• " 
5 
1 
26,000 
27,000 
28,000 
29.000_ 
30,000 
2 
27,000 
28,000 
29,000 
30.000 
31,000 
3 
28,000 
29,000 
30,000 _ .ai.-oeo-
4 
1 ~3Q5DO'— Hzpof 
34,000 
36,000 
38,000 
Responsibility 
5 
32,000 
34,000 
36,000 
38,000 
40,000 
Responsibility 
6 
34,000 
36,000 
38,000 
40,000 
42,000 
7 
36.000 
39,000 
42,000 
45.000 
48,000 
8 
39,000 
42,000 
45,000 
48,000 
51,000 
9 
42,000 
45,000 
48,000 
51,000 
54,000 
10 
46,000 
50,000 
54,000 
58,000 
62,000 
Region 1 
Region 2 
Experience 
1 
2 
3 
4 
5 
1 
28,000 
29,000 
30,000 
21.000 
32,000 
2 
29,000 
30,000 
31,000 
32,000 
33,000 
3 
30,000 
31,000 
32,000 
33,000 
34,000 
Responsibility 
4 
a.ooo 
—34,000.... 
36,000 
38,000 
40,000 
Experience 
1 
2 
3 
4 
5 — -
42.Q00 
1 
26,000 
27,000 
28,000 
. 29.000 • .30,000 
44,000 
2 
27,000 
23,000 
29,000 
~lib\0i0cP 3iT56o~J 50,000 
3 
28,000 
29,000 
30,000 
31,000 
32,000 
53,000 
4 I annonK -.32,000 
34,000 
36,000 
38,000 
56,000 
Responsibility 
5 
32,000 
3 4 , 0 0 0 ' '•36,0.00 
38,000 
40,000 
64,000 
6 
34,000 
36,000 
38,000 
"40,800., 
42,000 
7 
36,000 
39,000 
42,000 
45,000 
48,000- -
8 
39,000 
42,000 
45,000 
48,000 
51,000 
9 
42,000 
45,000 
48,000 
51,000 
54,000 
10 
46,000 
50,000 
54,000 
58,000 
62,000 
Figure 13.1b extends the user's view to two dimensions, in which salary is a 
function of two variables, responsibility and experience. The additional variable 
enables individuals with the s a m e responsibility to be assigned different salaries, 
depending o n experience. A n individual at responsibility level four, for example, 
earns one of five salaries ($30,000, $32,000, $34,000, $36,000, or $38,000), depending 

Chapter 
13 — 
Multilevel 
Tables 
on his or her experience level (which varies from one to five, respectively.) T w o 
subscripts are necessary to designate a specific value in a two-level table; it should 
be apparent that the order of the subscripts is important; that is, the entry in row 4, 
column 1 ($30,000) is different from the entry in row 1, c o l u m n 4 ($29,000). 
Figure 13.1c extends the user's view to a third dimension, region, in which 
salary is a function of three variables; region (based o n cost of living), responsibility, 
and experience. A n y reference to a specific entry in a three-level table requires three 
subscripts, and again the order is important. Look again at Figure 13.1c and verify 
that the salary for region 1, responsibility 4, and experience 1 is $30,000, while the 
entry in region 2, responsibility 4, and experience 1 is $32,000. 
A table is initialized either by hard-coding it in a program or by dynamically loading 
( l 
it at execution time. Once initialized, the entries in a table can be accessed through 
a P E R F O R M V A R Y I N G or S E A R C H statement, and these statements are applicable 
to tables in one, two, or three dimensions. W e have, however, for the sake of 
simplicity, chosen to focus o n hard-coding and the P E R F O R M V A R Y I N G statement. 
As previously indicated, our approach will be to develop the material for the simplest 
application (one-level tables), a n d then extend the concepts to two a n d three 
dimensions. 
Figure 13.2 depicts three different views of the one-level table s h o w n earlier in 
Figure 13.1. Figure 13.2a repeats the user's view in which salary is a function of 
responsibility, Figure 13.2b contains the C O B O L statements to define and initialize 
the table in C O B O L , and Figure 13.2c shows the resulting storage allocation. 
Figure 13.2b creates the 01 entry S A L A R Y - V A L U E S with 10 successive V A L U E 
clauses that initialize 50 consecutive locations in m e m o r y . T h e first five locations 
contain 26000, the next five contain 27000, and so on. 
The R E D E F I N E S clause assigns another n a m e , SALARY-TABLE, to these s a m e 
50 locations, a n d the subsequent O C C U R S clause establishes the table. (The O C C U R S 
clause cannot appear o n the 01 level and hence S A L A R Y is defined under SALARY-
TABLE.) The first five positions in S A L A R Y - V A L U E S are r e n a m e d S A L A R Y (1) and 
contain 26000, the starting salary for responsibility level one. T h e next five positions 
are renamed S A I A R Y (2) and contain 27000, a n d so on. The conceptual view of the 
storage allocation is s h o w n in Figure 13.2c. 
PERFORM WARYIf§6 
The P E R F O R M V A R Y I N G statement (explained previously in Chapter 11) processes 
the elements in a table. For example, the statement 
PERFORM WRITE-STARTING-SALARY 
VARYING RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL RESPONSIBILITY-SUB > 10 
executes the procedure W R I T E - S T A R T I N G - S A L A R Y 10 times, changing the value of 
R E S P O N S I B I L I T Y - S U B each time the procedure is executed. T h e P E R F O R M 
V A R Y I N G statement initializes (increments) a subscript (index), tests a condition, 
then performs the designated procedure, depending o n whether the condition is 
true. In the example, RESPONSIBILITY-SUB is initialized to 1, and the condition 

One-Level 
One-level Table 
1 
26,000 
2 
27,000 
3 
28,000 
4 
_30j00JT 
Responsibilty 
5 
32,000 
Responsibilty 
6 
34,000 
7 
36,000 
8 
39,000 
9 
42,000 
10 
46,000 
fetj lJS0f S ¥ l @ W 
01 SALARY-VALUES. 
05 FILLER 
PIC X(5) 
VALUE '26000 
05 FILLER 
PIC X(5) 
VALUE '27000 
05 FILLER 
PIC X(5) 
VALUE 
128000 
05 FILLER 
PIC X(5) 
VALUE 
130000 
05 FILLER 
PIC X(5) 
VALUE '32000 
05 FILLER 
PIC X(5) 
VALUE '34000 
05 FILLER 
PIC X(5) 
VALUE '36000 
05 FILLER 
PIC X(5) 
VALUE '39000 
05 FILLER 
PIC X(5) 
VALUE '42000 
05 FILLER 
PIC X(5) 
VALUE '46000 
01 SALARY-TABLE REDEFINES SALARY-VALUES. 
05 SALARY OCCURS 10 TIMES 
PIC 9(5). 
SALARY-TABLE 
SALARY (1) 
SALARY (2) 
SALARY (3) 
SALARY (4) 
SALARY (5) 
SALARY (6) 
SALARY (7) 
SALARY (8) 
SALARY (9) 
SALARY (10) 
2 6 0 0 0 2 7 0 0 0 2 8 0 0 0 3 0 0 0 0 3 2 0 0 0 3 4 0 0 0 3 6 0 0 0 3 9 0 0 0 4 2 0 0 0 4 6 0 0 0 
SALARY-VALUES 
(c) Storage Schematic 
RESPONSIBILITY-SUB > 10 is evaluated. T h e condition is not satisfied, so the 
designated procedure, WRITE-STARTING-S/ALARY, is executed for the first time. 
RESPONSIBILITY-SUB is incremented to 2, and the condition is retested. T h e 
condition is still false, so W R I T E - S T A R T I N G - S A L A R Y is executed a second time. T h e 
loop (testing, executing, and incrementing) continues for values of RESPONSIBILITY-
S U B of 3, 4, 5, and so on, until RESPONSIBILITY-SUB reaches 10. Even then the 
condition is still not satisfied, because 10 is not greater than 10, a n d so W R I T E -
S T A R T I N G - S A L A R Y is executed a tenth (and last) time. RESPONSIBILITY-SUB is 
incremented to 11, the condition is finally satisfied (11 > 10), and the P E R F O R M 
V A R Y I N G is terminated. 

Chapter 
13 — Multilevel 
Tables 
All of this material is easily extended to two levels as s h o w n in Figure 13.3. Figure 13.3a 
_ ^ ^ - 
repeats the user's view of the table in which salary is a function of both responsibility 
and experience, Figure 13.3b shows the C O B O L definition a n d initialization, a n d 
Figure 13.3c depicts the storage allocation. 
-'igure 13.3 
Two-level Tables 
Experience 
1 
2 
3 
4 
5 
1 
26,000 
27,000 
28,000 
29.000 . - 30,000 
2 
27,000 
28,000 
29,000 
30,000 
31,000""' 
3 
28,000 
29,000 
30,000 
31,000 
32,000 
4 
30.000 
32.000 
34,000 
36,000 
38,000 
Responsibility 
5 
32,000 
34,000 
"-36fl00 
38,000 
40,000 
Responsibility 
6 
34,000 
36,000 
38,000 
•HltitW , 42.000 
7 
36,000 
39,000 
42,000 
45,000 
48,QUff 
8 
39,000 
42,000 
45,000 
48,000 
51,000 
9 
42,000 
45,000 
48,000 
51,000 
54.000 
10 
46,000 
50,000 
54,000 
58,000 
62,000 
(a) User's View 
01 SALARY-VALUES. 
05 FILLER 
PIC X(25) 
VALUE '2600027000280002900030000 
05 FILLER 
PIC X(25) 
VALUE '2700028000290003000031000 
05 FILLER 
PIC X(25) 
VALUE '2800029000300003100032000 
05 FILLER 
PIC X(25) 
VALUE '3000032000340003600038000 
05 FILLER 
PIC X(25) 
VALUE '3200034000360003800040000 
05 FILLER 
PIC X(25) 
VALUE '3400036000380004000042000 
05 FILLER 
PIC X(25) 
VALUE '3600039000420004500048000 
05 FILLER 
PIC X(25) 
VALUE '3900042000450004800051000 
05 FILLER 
PIC X(25) 
VALUE '4200045000480005100054000 
05 FILLER 
PIC X(25) 
VALUE '4600050000540005800062000 
01 SALARY-TABLE REDEFINES SALARY-VALUES. 
j 
05 RESPONSIBILITY OCCURS 10 TIMES. 
j 
10 EXPERIENCE OCCURS 5 TIMES. 
[ 
15 SALARY 
PIC 9(5). 
j 
(b) initialization via the REDEFINES and VALUES Clauses 
| 
( 
SALARY-TABLE 
RESPONSIBILITY (1) 
RESPONSIBILITY (10) 
Exp(1) 
Exp(2) 
Exp (3) 
Exp (4) 
Exp (5) 
Exp(1) 
Exp (2) 
Exp (3) 
Exp (4) 
Exp (5) 
2 6 0 0 0 2 7 0 0 0 2 8 0 0 0 2 9 0 0 0 3 0 0 0 0 
4 6 0 0 0 5 0 0 0 0 5 4 0 0 0 5 8 0 0 0 6 2 0 0 0 
SALARY-VALU ES 

Establishment of a two-level table requires two O C C U R S clauses, each at a 
different level, in the table definition as shown: 
01 SALARY-TABLE. 
05 RESPONSIBILITY OCCURS 10 TIMES. 
10 EXPERIENCE OCCURS 5 TIMES. 
15 SALARY 
PIC 9(5). 
The above entries establish a 50-element table (10 rows and 5 columns) with each 
element assigned five m e m o r y locations (according to the P I C T U R E clause). There 
are a total of 250 m e m o r y locations (10 x 5 x 5) allocated to the table as shown in 
Figure 13.3c. The first 25 locations contain the salaries for the five experience levels 
at the first responsibility level. Locations 1-5 contain the salary at responsibility 
level I, experience level 1; locations 6-10 contain the salary at responsibility level I, 
experience level 2; and so on. In similar fashion, locations 26-50 refer to the salaries 
for the five experience levels at responsibility level 2; locations 51-75 to the salaries 
at the five experience levels for responsibility level 3; and so on. 
As in the one-level example, the table is initialized through combination of 
the O C C U R S , V A L U E , and R E D E F I N E S clauses. This time, however, each V A L U E 
clause fills an entire row (consisting of five experience levels or 25 positions in all). 
The first V A L U E clause fills the first 25 locations (corresponding to the five experience 
levels for responsibility one), the second V A L U E clause fills locations 26-50 (the five 
experience levels for responsibility two), and so on. The order of the VALUE clauses 
is critical and coincides with Figure 13.3a. The resulting storage allocation is shown 
in Figure 13.3c and further clarifies the discussion. 
N e w c o m e r s to multilevel tables find it all too easy to use the wrong n u m b e r of 
subscripts, specify subscripts in improper sequence, and/or supply an invalid 
subscript value (that is, a value beyond the definition in the O C C U R S clause.) T h e 
rule is very simple, namely that the n u m b e r of subscripts is equal to the n u m b e r of 
O C C U R S clauses used to define the entry and further, that the order of subscripts 
corresponds to the order of the OCCURS clauses. 
Consider again the table definition in Figure 13.3b, observing that S A 1 A R Y is 
subordinate to E X P E R I E N C E , that E X P E R I E N C E is subordinate to RESPONSIBILITY, 
and that both RESPONSIBILITY and E X P E R I E N C E were defined with an O C C U R S 
clause. In other words an O C C U R S clause appears in both group items prior to the 
definition of SALARY, a n d thus two subscripts will be required for all Procedure 
Division references to SALARY. A n y reference to S A L A R Y that does not include two 
subscripts will be flagged during compilation. S A L A R Y (1,4) is a valid reference to 
indicate the element in row 1, column 4 of the two-level table; S A L A R Y (1) is invalid 
and will be flagged accordingly. 
The compiler, however, is concerned only with syntax (namely that the proper 
n u m b e r of subscripts is supplied), and not with the values of those subscripts. In 
other words, a reference to S A L A R Y (20, 20) would not produce a compilation error, 
because it contains two subscripts a n d is syntactically valid. It would, however, 
cause problems during execution as the subscript values are inconsistent with the 
table definition. (The execution results are unpredictable.) 
C O B O L also allows reference to data n a m e s at different hierarchical levels of 
a table (although such reference m a y not m a k e sense logically). Thus the definition 
of a two-dimensional table automatically allows reference to other one-dimensional 
tables. Refer again to the storage schematic of Figure 13.3c and/or the examples 
below to clarify the issue. 

Chapter 
1 3 — 
Multilevel 
Tables 
S A L A R Y (6, 5) 
S A L A R Y (5, 6) 
S A L A R Y - T A B L E 
RESPONSIBILITY (1) 
E X P E R I E N C E (6, 5) 
A valid entry in all respects, w h i c h refers to salary 
responsibility level 6, experience level 5. The data n a m e 
S A L A R Y must always be referenced with two subscripts. 
Syntactically correct in that S A L A R Y has two subscripts. 
The entry will compile cleanly but will cause problems in 
execution because it refers to responsibility and experience 
levels of 5 and 6, respectively, which are inconsistent with 
the table definition. 
Refers to the entire table of 50 elements (250 locations). 
SALARY-TABLE is referenced without any subscripts. 
Refers collectively to the five experience levels for the first 
level of salary responsibility; R E S P O N S I B I L I T Y is 
referenced with a single subscript. 
A valid entry equivalent to S A L A R Y (6,5); the entries are 
equivalent because S A L A R Y is the only elementary item 
defined under the group item E X P E R I E N C E . 
The P E R F O R M V A R Y I N G statement was introduced in Chapter 11 in conjunction 
with processing a one-level table. Its syntax is easily extended to process a two-level 
table as s h o w n below. Consider: 
PERFORM [procedure-name-l] WITH TEST 
[BEFORE^ 
[AFTER 
identifier-1 , 
VARYING { 
} FROM 
index-name - 1 
identifier-2 
index-name-2 
1iteral-1 
BY literal-2 
[ 
identifier- 31 
UNTIL condition-1 
identifier-4 
AFTER I 
} FROM 
I iteral-3 
UNTIL condition-2 
identifier-5 
index-name - 3 
literal-4 
BY identifier-6[ 
literal-5 
[imperative-statement-1 END PERFORM] 
T h e P E R F O R M V A R Y I N G statement a c c o m m o d a t e s a two-level table through 
inclusion of the AFTER clause that varies two subscripts (indexes) simultaneously. 
As in the case of a one-level table, the T E S T B E F O R E / T E S T A F T E R clause is optional 
and is typically omitted; the default is T E S T B E F O R E a n d corresponds to the C O B O L -
74 implementation. 
The P E R F O R M V A R Y I N G statement executes a designated procedure as in 
Figure 13.4a, or the statements in an in-line perform as in Figure 13.4b. Either w a y 
two subscripts are used as s h o w n in Figure 13.4c. RESPONSIBILITY-SUB is varied 
from 1 to 10, in conjunction with E X P E R I E N C E - S U B changing from 1 to 5, so that 
the performed statements are executed 50 times in all. 
The bottom subscript (EXPERIENCE-SUB in this example) is varied first. Thus 
RESPONSIBILITY-SUB is initially set to 1 while E X P E R I E N C E - S U B is varied from 
1 to 5. RESPONSIBILITY-SUB is then incremented to 2, while E X P E R I E N C E - S U B 

Two-Level 
Tables 
figure 13-4 
PERFORM VARYING with Two Subscripts 
PERFORM INITIALIZE-SALARIES 
VARYING RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL RESPONSIBILITY-SUB > 10 
AFTER EXPERIENCE-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 5, 
INITIALIZE-SALARIES. 
MOVE ZERO TO SALARY (RESPONSIBILITY-SUB, EXPERIENCE-SUB). 
(a) Performing a Paragraph 
PERFORM 
VARYING RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL RESPONSIBILITY-SUB > 10 
AFTER EXPERIENCF-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 5 
MOVE ZERO TO SALARY (RESPONSIBILITY-SUB, EXPERIENCE-SUB) 
END-PERFORM. 
(b) In-Une Perform 
Responsibility 
Subscript 
Experience 
Subscript 
RESPONSIBILITY-SUB is set to 1 whil 
EXPERIENCE-SUB varies from 1 to 5 
RESPONSIBILITY-SUB is set to 2 whil 
EXPERIENCE-SUB varies from 1 to 5 
10 
1 
10 
2 
10 
3 
10 
4 
10 
5 
RESPONSIBILITY-SUB reaches 10 and 
EXPERIENCE-SUB varies from 1 to 5 
(c) Variation of Subscripts 

C
h
a
p
t
e
r 
1 3 
Multilevel 
Tables 
•igure 13»S 
Varying Column and/or Row Subscripts 
Question: 
What is the average salary for responsibility level three? 
Answer: 
Sum the five salaries in row three of the salary table, then divide that total by five. 
MOVE ZERO TO TOTAL-SALARY. 
PERFORM 
VARYING EXPERIENCE-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 5 
ADD SALARY (3, EXPERIENCE-SUB) TO TOTAL-SALARY 
END-PERFORM. 
COMPUTE AVERAGE-SALARY = TOTAL-SALARY / 5. 
Question: 
What is the average salary for experience level four? 
Answer: 
Sum the 10 salaries in column four of the salary table, then divide that total by 10. 
MOVE ZERO TO TOTAL-SALARY. 
PERFORM 
VARYING RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 10 
ADD SALARY (RESPONSIBILITY-SUB, 4) TO TOTAL-SALARY 
END-PERFORM. 
COMPUTE AVERAGE-SALARY = TOTAL-SALARY / 10. 
Question: 
What is the average salary over all responsibility and experience levels? 
Answer: 
Sum all 50 salaries in the table, then divide that total by 50. 
MOVE ZERO TO TOTAL-SALARY. 
PERFORM 
VARYING RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL RESPONSIBILITY-SUB > 10 
AFTER EXPERIENCE-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 5 
ADD SALARY (RESPONSIBILITY-SUB, EXPERIENCE-SUB) TO TOTAL-SALARY 
END-PERFORM. 
COMPUTE AVERAGE-SALARY = TOTAL-SALARY / 50. 
is again varied from 1 to 5. T h e process continues until all 50 combinations have 
been reached. 
It is not necessary to always vary both subscripts in a two-level table; that is, 
you can hold the row constant a n d vary the column, or keep the column constant 
and vary the row. Indeed, different types of information are obtained according to 

Sam 
pie 
Progra 
m 
the subscript that is used. Figure 13.5a, for example, varies the c o l u m n subscript 
(EXPERIENCE-SUB) while keeping the row constant, to obtain the average starting 
salary at the third responsibility level. In similar fashion, Figure 13.5b varies the row 
subscript (RESPONSIBILITY-SUB) while keeping the column constant, to obtain 
the average starting salary for the fourth experience level. Figure 13.5c varies both 
subscripts to compute the average salary over all 50 row-column combinations. 
LSI 
_ t Ci 
W e incorporate the material o n two-level tables into a C O B O L program. 
- ^ 
-Kt 
Specifications follow in the usual format. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
Two-Level Tables 
Narrative: 
This program illustrates the definition, initialization, and processing of two-level tables, 
building directly on the examples just presented. The specifications call for the processing 
of an employee file and the printing of each individual's salary, based on his or her 
responsibility and experience. In addition, the number of employees in each responsibility/ 
experience combination is to be computed. 
I n c u t F i l e t s ) : 
EMPLOYEE-FILE 
Input R e c o r d Layout: 01 EMPLOYEE-RECORD. 
05 EMP-NAME 
05 
EMP-SALARY-DETERMINANTS. 
10 EMP-RESP 
10 FILLER 
10 EMP-EXP 
10 FILLER 
05 FILLER 
PIC X(15). 
PIC 99. 
PIC X. 
PIC 99. 
PIC X(3). 
PIC X(5). 
Test Data: 
ADAMS 
04 01 
BAKER 
01 04 
BROWN 
08 02 
CHARLES 
09 02 
DAVIDSON 
09 04 
DAVIS 
10 04 
EPSTEIN 
04 05 
FRANKEL 
03 03 
GOODMAN 
03 03 
GULFMAN 
03 05 
HATHAWAY 
07 02 
INGLES 
03 01 
JACKSON 
06 03 
JORDAN 
06 03 
KING 
07 02 
LIPMAN 
07 01 
LOWELL 
01 04 

C
h
a
p
t
e
r 
1 3 
— 
Multilevel 
Tables 
Report Layout: 
See Figure 13.6. 
Processing Requirements: 
1. Read a file of employee records, and for each record: 
a. Determine the employee's starting salary as a function of responsibility and 
experience. 
b. Print a detail line for this employee showing his or her name and starting salary. 
2. Compute the number of employees for each responsibility-experience combination. 
This requires creation of a 10-by-5 table to store the number of individuals in each 
responsibility-experience combination, and implies that as each employee record is 
Figure 13.6 
Output of Two-Levei Program 
STARTING SALARIES OF ALL NEW EMPLOYEES 
I 
jj 
ADAMS 
$30,000 
BAKER 
$29,000 
BROWN 
$42,000 
CHARLES 
$45,000 
DAVIDSON 
$51,000 
DAVIS 
$58,000 
EPSTEIN 
$38,000 
FRANKEL 
$30,000 
GOODMAN 
$30,000 
GULFMAN 
$32,000 
HATHAWAY 
$39,000 
INGLES 
$28,000 
JACKSON 
$38,000 
JORDAN 
$38,000 
KING 
$39,000 
LIPMAN 
$36,000 
LOWELL 
$29,000 
(a) Detail Report 
I 
STARTING SALARY SUMMARY REPORT 
EXPERIENCE 
RESPONSIBILITY 
1 
2 
3 
4 
5 
1 
0 
0 
0 
2 
0 
2 
0 
0 
0 
0 
0 
3 
1 
0 
2 
0 
1 
4 
1 
0 
0 
0 
1 
5 
0 
0 
0 
0 
0 
6 
0 
0 
2 
0 
0 
7 
1 
2 
0 
0 
0 
8 
0 
1 
0 
0 
0 
9 
0 
1 
0 
1 
0 
10 
0 
0 
0 
1 
0 

read, the corresponding table entry (the particular responsibility-experience 
combination) has to be incremented by one. 
3. When all employees have been processed, print the table containing the number of 
employees in each category as shown in Figure 13.6b. 
Program Design 
The report layout in Figure 13.6 requires both a detail report containing a line for 
every employee, as well as a summary 
report displaying the total n u m b e r of 
employees in each of the 50 responsibility-experience combinations. T h e program 
will evaluate each incoming record to determine in which of the 50 categories the 
employee fits, then increment the appropriate counter. At the conclusion of 
processing—after all employee records have been read—the table of 50 totals will 
be printed as the s u m m a r y report. 
The functions needed in the eventual program are s h o w n in the expanded 
hierarchy chart of Figure 13.7. The purpose of the individual modules should be 
apparent from the module n a m e and/or the eventual C O B O L program (shown later 
in the chapter). 
The pseudocode in Figure 13.8 is succinct and is restricted to the basic building 
blocks of structured programming. The initial statements open the files and write 
an appropriate heading. The program is driven by a "loop that determines the 
appropriate responsibility/experience combination for each employee record, writes 
the detail line, and increments the appropriate counter. The s u m m a r y report is 
written after this loop has ended (when all employee records have been processed). 
The Completed fV-oram 
M u c h of the completed program in Figure 13.9 is already familiar as it repeats the 
C O B O L statements used in the explanation of two-level tables. T h e C O B O L 
statements to define the salary table (lines 42-57), appeared earlier in Figure 13.3b 
and were discussed fully at that time. A second two-level table, for the n u m b e r of 
employees in each category, is defined in lines 59-62; the definition uses the O C C U R S 
:»gure 13.7 
Hierarchy Chart for Two-Level Program 
PREPARE 
SALARY 
REPORT 
WRITE 
DETAIL 
HEADING 
PROCESS 
EMPLOYESS 
WRITE 
SUMMARY 
REPORT 
WRITE 
SUMMARY 
HEADING 
WRITE 
RESPONSIBILITY 
LINE 

C
h
a
p
t
e
r 
1 3 — 
Multilevel 
Tables 
Figure i 3.8 
Pseudocode for Two-Level Program 
Open files 
Write heading lines 
r~- DO WHILE data remains 
:— READ employee file 
i 
AT END 
I 
Indicate no more data 
j 
NOT AT END 
Determine responsibility/experience combination 
| 
Increment number of employees in that combination 
j 
Write detail line 
END-READ 
- ENDDO 
Write summary report 
Close files 
Stop run 
13,3 
Two-Level Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
2LVTABLE. 
3 
AUTHOR. 
ROBERT T. GRAUER. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT EMPLOYEE-FILE 
ASSIGN TO 'A:\CHAPTR13\TABLES.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
13 
DATA DIVISION. 
14 
FILE SECTION. 
15 
FD EMPLOYEE-FILE 
16 
DATA RECORD IS EMPLOYEE-RECORD. 
17 
01 EMPLOYEE-RECORD 
PIC X(23). 
18 
19 
FD PRINT-FILE 
20 
DATA RECORD IS PRINT-LINE. 
21 
01 PRINT-LINE 
PIC X(132). 
22 
23 
WORKING-STORAGE SECTION. 
24 
01 FILLER 
PIC X(14) 
25 
VALUE 'WS BEGINS HERE'. 
26 
27 
01 WS-EMPLOYEE-RECORD. 
28 
05 EMP-NAME 
PIC X(15). 

A Sample 
Program 
(continued) 
29 
_ 
05 EMP-SALARY-DETERMINANTS. 
3 0 1 " _ 7 " ~ 1 0 
EMP-RESP~"2""""" 
[ P I C 99."k-
3 1 " ' 1 _ 
J
 
1 0 1 FILLER' _ '_ 
' _PIC 
J ' > 0 ' s e ' O 3 5 
[
3
2
1 
10 EMP-LXP 
_ 
PIC 99. — 
3
3
"
1
0 
FILLER 
"
"
~
~ 
PIC X(3). 
34 
35 
01 PROGRAM-SUBSCRIPTS. 
36 
05 RESP-SUB 
PIC S9(4) COMP. 
37 
05 EXP-SUB 
PIC S9(4) COMP. 
38 
39 
01 WS-END-OF-DATA-SWITCH 
PIC X(3) 
VALUE SPACES. 
40 
88 END-OF-DATA 
VALUE 'YES
1. 
41 
_ _ _ 
_ 
_ 
_ 
_ _ _ _ 
42 
01 SALARY-VALUES. 
; 43 
05 FILLER PIC X(25) 
VALUE '2600027000280002900030000' 
! 44 
05 FILLER PIC X(25) 
VALUE ' 2700028000290003000031000' 
| 45 
05 FILLER PIC X(25) 
VALUE '2800029000300003100032000' 
I 46 
05 FILLER PIC X(25) VALUE '3000032000340003600038000' 
!
4
7 
05 FILLER PIC X(25) 
VALUE '3200034000360003800040000' 
' 48 
05 FILLER PIC X(25) 
VALUE '3400036000380004000042000' 
49 
05 FILLER PIC X(25) 
VALUE '3600039000420004500048000' 
! 50 
05 FILLER PIC X(25) VALUE '3900042000450004800051000' 
; 51 
05 FILLER PIC X(25) VALUE '4200045000480005100054000' 
52 
05 FILLER PIC X(25) VALUE '4600050000540005800062000' 
I 
; 53 
| 
i 54 
01 SALARY-TABLE REDEFINES SALARY-VALUES. 
| 
i 55 
05 RESPONSIBILITY OCCURS 10 TIMES. 
1 
| 56 
10 EXPERIENCE OCCURS 5 TIMES. 
j 
| 57 
_ 
15 SALARY 
_ 
PIC 9(5). 
i 
'MUZ. 11111.111 '.111' 
.111111111111 
["1.1" 
.
_ 1 
59 
01 NUMBER-OF-EMPLOYEES-TABLE. 
60 
05 NUMBER-RESPONSIBILITY OCCURS 10 TIMES. 
[ | 6 1 
10 NUMBER-EXPERIENCE OCCURS 5 TIMES. 
62 
_ 
15 NUMB-EMf 
PIC 99 
VALUE ZERfJ^. 
j "63 
| 
64 
01 DETAIL-REPORT-HEADING-LINE. 
I 
65 
05 FILLER 
PIC X(9) 
VALUE SPACES, 
j 
66 
05 FILLER 
PIC X(39) 
j 
67 
VALUE 'STARTING SALARIES OF ALL NEW EMPLOYEES'. 
| 
68 
05 FILLER 
PIC X(82) VALUE SPACES. 
| 
69 
j 
70 
01 DETAIL-LINE-1. 
1 
71 
05 FILLER 
PIC X(12) VALUE SPACES. 
j 
72 
05 DET-EMP-NAME 
PIC X(15). 
I 
73 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
J 
74 
05 DET-SALARY 
PIC $99,999. 
j 
75 
05 FILLER 
PIC X(94) VALUE SPACES. 
j 
76 
77 
01 SUMMARY-REPORT-HEADING-LINE-l. 
78 
05 FILLER 
PIC X(24) 
VALUE SPACES. 

C
h
a
p
t
e
r 
1 3 — 
Multilevel 
Table 
79 
05 FILLER 
PIC X(39) 
80 
VALUE 'STARTING SALARY SUMMARY REPORT'. 
81 
05 FILLER 
PIC X(69) VALUE SPACES. 
82 
83 
01 SUMMARY-REPORT-HEADING-LINE-2. 
84 
05 FILLER 
PIC X(36) VALUE SPACES. 
85 
05 FILLER 
PIC X(10) VALUE 'EXPERIENCE'. 
86 
05 FILLER 
PIC X(86) VALUE SPACES. 
87 
88 
01 SUMMARY-REPORT-HEADING-LINE-3. 
89 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
90 
05 FILLER 
PIC X(14) VALUE 'RESPONSIBILITY' 
91 
05 FILLER 
PIC X(48) 
92 
VALUE ' 
1 
2 
3 
4 
5'. 
93 
05 FILLER 
PIC X(65) VALUE SPACES. 
94 
95 
01 SUMMARY-LINE-1. 
96 
05 FILLER 
PIC X(9). 
97 
05 SUMMARY-RESPONSIBILITY PIC Z(4). 
98 
05 FILLER 
PIC X(4) 
VALUE SPACES. 
99 
05 
SUMMARY-TOTAL-VALUES OCCURS 5 TIMES. 
100 
10 FILLER 
PIC X(4). 
101 
10 SUMMARY-NUMBER 
PIC Z(4)9. 
102 
05 FILLER 
PIC X(70). 
103 
104 
PROCEDURE DIVISION. 
105 
100 -PREPARE-SALARY-REPORT. 
106 
OPEN INPUT EMPLOYEE-FILE 
107 
OUTPUT PRINT-FILE. 
108 
PERFORM 200-WRITE-DETAIL -REPORT-HDG. 
p
F
R
|
Q
R
M U
N
T
U 
END-OF-DATA 
READ EMPLOYEE-FILE INTO WS-EMPLOYEE-RECORD 
AT END 
MOVE 'YES' TO WS-END-OF-DATA-SWITCH 
NOT AT END 
PERFORM 300-PROCESS-EMPLOYEES 
END-PERFORM. 
PERFORM 400-WRITE-SUMMARY-REPORT. 
CLOSE EMPLOYEE-FILE 
PRINT-FILE. 
STOP RUN. 
200-WRITE-DETAIL-REPORT-HDG. 
WRITE PRINT-LINE FROM DETAIL-REPORT-HEADING-LINE 
AFTER ADVANCING PAGE. 
MOVE SPACES TO PRINT-LINE. 
WRITE PRINT-LINE. 
300j^OCESS-_EMPL0YJES. _ 
~ 
A D D " ' T J O J ^ M B ~ - ^ M P ~ U ' I ^ R | S ^ EMPJEXP) ."} 
f f 
| ! 109 
! 
! n o 
! 
| i n 
I 
1
1
1
2 
[ 
113 
j 
114 
I 
115 
| 
116 
j 
117 
! 
118 
i 
119 
120 
121 
122 
123 
i 
124 
[ 
125 
i 
126 
| 
127 
| 
128 
Figure 13.9 
(continued) 

A 
Sample 
Program 
(continued) 
j 
129 
M O V E EMP-NAME T O D E T - E M P - N A M E . 
[ 
I 
130 
M O V E SALARY (EMP-RESP, EMP-EXP) TO DET-SALARY. 
I 
| 131 I\T1JWVFTEJ^ 
I 
I 
132 
^--^ 
Pyti ,.,..,..-„-,,,•,,., 
, . o W . . „ , „ . , 
j 
i 
133 
4 0 0 - W R I T E - S U M M A R Y - R E P O R T . 
' " ' "
Z ! ' " '
J "
J y M 
j 
j 
134 
P E R F O R M 500-WRITE-SUMMARY-HEADING. 
[ 
j 
135 
P E R F O R M 520-WRITE-RESPONSIBILITY-LINE 
) 
136 
VARYING RESP-SUB FROM 1 BY 1 
I 
j 
137 
U N T I L RESP-SUB > 10. 
I 
| 
138 
| 
139 
5 0 0 - W R I T E - S U M M A R Y - H E A D I N G . 
| 
•140 
" W R I T E 
PR I NT -I INE 
FROM SUMMARY-REPORT-H EADING-LINE-I ! 
I 
1141 
A F T E R A D V A N C I N G PAGE. 
| 
1142 
W R I T E P R I N T - L I N E FROM SUMMARY-REPORT-HEADING-LINE-2 
| 
! 
| 
|143 
A F T E R A D V A N C I N G 2 LINES. 
| 
j 
!144 
W R I T E P R I N T - L I N E FROM SUMMARY-REPORT-HEADING-LINE-3. 
( 
;145 
MOVE S P A C E S TO P R I N T - L I N E . 
I 
j 146 
W R I T E P R I N T - L I N E . 
_ 
_ 
^ _ 
j 
j 
1
4
7
"
"
~ 
"
' 
""""""^ . 
[ 
[ 
148 
5 2 0 - W R I T E - R E S P O N S I B I L I T Y - L I N E . 
J 
j 
149 
M O V E SPACES TO SUMMARY-LINt-1. 
I 
i 
150 " " P E R F O M " V A R Y I N G " E X P - S U B " F M M T B Y I "
"
~ 
" 
" 
j 
j 
t 
^151 
U N T I L EXP-SUB > 5 
! 
\ 
1 
f 1 5 2 
M O V E NUMB-EMP (RESP-SUB, EXP-SUB) 
| 
j 
J 
;153 
TO S U M M A R Y - N U M B E R (EXP-SUB) 
I 
| 
1 
[154 
_ 
END-PERFORM. 
I 
I 
155 
M O V E RESP-SUB T O SUMMARY-RESPONSIBILITY. 
j 
I 
156 
W R I T E P R I N T - L I N E FROM S U M M A R Y - L I N E - 1 . 
I 
clauses to allocate space for the table, but omits the R E D E F I N E S clause, because 
(unlike the salary table) the n u m b e r of employees is computed during processing. 
The 50 elements in the table are initialized to zero by the V A L U E Z E R O clause in line 
62. (See limitations of C O B O L - 7 4 at the end of the chapter.) 
The Procedure Division follows both the hierarchy chart a n d pseudocode. 
The key to the program is the A D D statement in line 128, which increments the 
n u m b e r of employees for the particular responsibility-experience combination. 
The subscript values in this statement are taken directly from the incoming employee 
record, which defines E M P - R E S P and E M P - E X P in lines 30 and 32, respectively. T h e 
detail line for the individual employee is written in lines 129-131. 
The s u m m a r y report is produced after the end of file has been reached by the 
P E R F O R M W R I T E - S U M M A R Y R E P O R T statement of line 116. T h e heading lines 
are written in lines 140-146, after which the paragraph WRITE-RESPONSIBILITY-
LINE is executed 10 times (once for each responsibility level) in lines 148-156. T h e 
latter paragraph contains its o w n P E R F O R M V A R Y I N G statement to write each of 
the five experience totals for each of the 10 responsibility levels. 

Chapter 
13 
Multilevel 
Tables 
The material o n two-level tables is easily extended to a third dimension. W e continue 
therefore with our two-level example, in which salary is a function of responsibility 
and experience, but this time add a third determinant, region (due to different costs 
of living in different areas of the country). Figure 13.10a depicts the user's view 
showing salary as a function of three variables (region, responsibility, a n d 
experience), Figure 13.10b contains the C O B O L definition, and Figure 13.10c shows 
the storage allocation. 
Establishment of a three-level table requires three O C C U R S clauses in the 
table definition: 
01 SALARY-TABLE. 
05 REGION OCCURS 2 TIMES. 
10 RESPONSIBILITY OCCURS 10 TIMES. 
15 EXPERIENCE OCCURS 5 TIMES. 
20 SALARY 
PIC 9(5). 
These entries establish a 100-element table (2 x 10 x 5) with each element assigned 
five m e m o r y locations (according to the P I C T U R E clause). Thus there are a total of 
500 m e m o r y locations allocated to the table as indicated In Figure 13.10c. The first 
25 locations refer to the five experience levels at the first responsibility level in the 
first region; the next 25 locations to the five experience levels at the second 
responsibility level in the first region, and so on. 
As in the two-level example, the table is initialized through combinations of 
the O C C U R S , V A L U E , and R E D E F I N E S clauses. Each VALUE clause fills a n entire 
r n w ( r r m c i c t i n a n f five* 
f»Yn**ri£»ni"£» <4£»m«=>ntc n r 9 ^ n n c i H n n c in qIH wif-H 9 0 o n r h 
v 
.
.
.
„
. 
. — * 
j , „ „ » „ ^ . x ^ 
o u v ^ . i 
statements needed to initialize ail 500 storage locations. The first V A L U E clause fills 
the first 25 locations (corresponding to the five experience levels for responsibility 
one in region one), the second V A L U E clause fills locations 26-50 (the five experience 
levels for responsibility two in region one), and so on. T h e order of the V A L U E 
clauses is critical and coincides with Figure 13.10a. T h e resulting storage allocation 
is s h o w n in Figure 13.10c and further clarifies the discussion. 
Once again you must be careful to use the correct n u m b e r of subscripts, as 
well as specify the subscripts in the proper order. The rule is the same as for two-
level tables, namely that the n u m b e r of subscripts is equal to the n u m b e r of O C C U R S 
clauses used to define the entry, a n d further, that the order of the subscripts 
corresponds to the order of the O C C U R S clauses. 
Return to the table definition of Figure 13.10b, observing that three O C C U R S 
clauses are associated with SALARY, and hence three subscripts are necessary; that 
is, S A L A R Y is subordinate to R E G I O N , RESPONSIBILITY, and E X P E R I E N C E , each of 
which was defined with its o w n O C C U R S clause. Hence any Procedure Division 
reference to S A L A R Y must include three subscripts—for example, S A L A R Y (2, 4, 1) 
to indicate the salary for region 2, responsibility 4, and experience 1. 
As is the case with one- and two-level tables, the compiler is concerned only 
with syntax (that the proper n u m b e r of subscripts is supplied), and not with the 
values of those subscripts. A reference to S A L A R Y (3, 1, 1) w o u l d not produce a 
compilation error because it is syntactically valid. It would, however, cause problems 
during execution because the subscript value for region 3 is inconsistent with the 
table definition. T h e execution results are unpredictable. 
C O B O L also permits reference at different hierarchical levels, so that the 
definition of a three-level table automatically allows reference to other one- and 
two-dimensional tables (although such references m a y not m a k e sense logically). 
Refer again to the storage schematic in Figure 13.10c and/or the examples below to 
further clarify this discussion. 

ree-Level 
Tables 
• i, Three-level Tables 
Region 1 
Region 2 
Experience 
1 
2 
3 
4 
5 
1 
28,000 
29,000 
30,000 
L3l,fl0flJ-
-32,000 
2 
29,000 
30,000 
31,000 
32,000 
33,000 
3 
30,000 
31,000 
32,000 
33,000 
34,000 
Responsibility 
4 
1.32,000 J -34,000..... 36,000 
38,000 
40,000 
Experience 
1 
2 
3 
4 
' 
5
-
•42.000 
1 
26,000 
27,000 
28,000 
L29J)ffiLh ,30,000 
44,000 
2 
27,000 
28,000 
29,000 
30,000 
31.000 
50,000 
3 
28,000 
29,000 
30,000 
31,000 
32,000 
53,00fr . 
4 
imooo f •42,000 
34,000 
36,000 
38,000 
56,000 
Responsibility 
5 
32,000 
34,000 ~~ ~-36,Onp^ 
38,000 
40,000 
64,000 
6 
34,000 
36,000 
38,000 
~~4o;m... 
42,000 
7 
36,000 
39,000 
42,000 
45,000 
48,000-
8 
39,000 
42,000 
45,000 
48,000 
51,000 
9 
42,000 
45,000 
48,000 
51,000 
54,000 
10 
46,000 
50,000 
54,000 
58,000 
62,000 
(a) User's View 
01 SALARY-VALUES. 
05 REGION-ONE. 
10 
FILLER 
PIC X(25) 
VALUE 
12600027000280002900030000
1 
10 
FILLER 
PIC X(25) 
VALUE '2700028000290003000031000' 
10 
FILLER 
PIC X(25) 
VALUE '2800029000300003100032000' 
10 
FILLER 
PIC X(25) 
VALUE '3000032000340003600038000
1 
10 
FILLER 
PIC X(25) 
VALUE '3200034000360003800040000
1 
10 
FILLER 
PIC X(25) 
VALUE '3400036000380004000042000' 
10 
FILLER 
PIC X(25) 
VALUE '3600039000420004500048000' 
10 
FILLER 
PIC X(25) 
VALUE '3900042000450004800051000
1 
10 
FILLER 
PIC X(25) 
VALUE 
14200045000480005100054000' 
10 
FILLER 
PIC X(25) 
VALUE 
14600050000540005800062000' 
05 REGION-TWO. 
10 
FILLER 
PIC X(25) 
VALUE 
12800029000300003100032000' 
10 
FILLER 
PIC X(25) 
VALUE '2900030000310003200033000' 
10 
FILLER 
PIC X(25) 
VALUE '3000031000320003300034000
1 
10 
FILLER 
PIC X(25) 
VALUE '3200034000360003800040000' 
10 
FILLER 
PIC X(25) 
VALUE '3400036000380004000042000' 
10 
FILLER 
PIC X(25) 
VALUE '3600038000400004200044000' 
10 
FILLER 
PIC X(25) 
VALUE '3800041000440004700050000
1 
10 
FILLER 
PIC X(25) 
VALUE '4100044000470005000053000' 
10 
FILLER 
PIC X(25) 
VALUE 
14400047000500005300056000' 
10 
FILLER 
PIC X(25) 
VALUE '4800052000560006000064000' 
01 SALARY-TABLE REDEFINES SALARY-VALUES. 
05 REGION OCCURS 2 TIMES. 
10 RESPONSIBILITY OCCURS 10 TIMES. 
15 EXPERIENCE OCCURS 5 TIMES. 
20 SALARY 
PIC 9(5). 
(b) initialization via the REDEFINES and V A L U E S Clauses 
« 1 » ™.
S 
R SPGHSIBILHY 1) 
1 
m i j l „ . 
1 
| 
- , 1 j w, j - 
1 
SPOHaShiLITY 10) 
fxj>1 
Exp 2 
,|,|.|.|. 
M'H-
SA ARY-VAL E5 
±1* •Itl'l' im MM-

Chapter 
13 — 
Multilevel 
Tables 
S A L A R Y (1, 2, 3) 
S A L A R Y (2, 12, 7} 
S A L A R Y - T A B L E 
R E G I O N (1) 
RESPONSIBILITY (1, 2) 
E X P E R I E N C E (1, 2, 3) 
A valid reference in all respects, which refers to the salary 
for region 1, responsibility 2, a n d experience 3. S A L A R Y 
must always be referenced with three subscripts. 
Syntactically correct in that S A L A R Y has three subscripts. 
The entry compiles cleanly but will cause problems in 
execution, because it refers to responsibility a n d 
experience levels of 12 a n d 7, respectively, which are 
inconsistent with the table definition. 
Refers to the entire table of 100 elements (500 m e m o r y 
locations in all). S A L A R Y - T A B L E is referenced without any 
subscripts. 
Refers collectively to the 10 responsibility levels, each 
containing five experience levels associated with the first 
region; R E G I O N is referenced with a single subscript. 
Refers collectively to the five experience levels for 
responsibility level 2 for region 1; RESPONSIBILITY is 
referenced with two subscripts. 
A valid entry equivalent to S A L A R Y (1, 2,3); the entries are 
equivalent because S A L A R Y is the only elementary item 
defined under the group item E X P E R I E N C E . 
P E R F O R M V A R Y I N G 
The syntax of the P E R F O R M V A R Y I N G statement shows the A F T E R clause enclosed 
in brackets a n d followed by three dots to indicate the clause can be repeated. 
Accordingly, three-level tables are processed with a P E R F O R M V A R Y I N G statement 
that includes two A F T E R clauses as s h o w n in Figure 13.11. T h e statement m a y 
execute either a designated procedure as in Figure 13.11a, or a series of in-line 
statements as in Figure 13.1 lb. 
As in the two-level example, all possible combinations of the three subscripts 
are executed, causing the designated statements to be executed a total of 100 
Figure 13.11 
PERFORM VARYING with Three Subscripts 
: 
— 
— 
— 
— — — — 
" 
" 
— 
• 
— 
j 
PERFORM INITIALIZE-SALARIES 
| 
VARYING REGION-SUB FROM 1 BY 1 
UNTIL REGION-SUB > 2 
AFTER RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL RESPONSIBILITY-SUB > 10 
AFTER EXPERIENCE-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 5. 
] 
INITIALIZE-SALARIES. 
MOVE ZERO TO SALARY (REGION-SUB, RESPONSIBILITY-SUB, EXPERIENCE-SUB). 
(a) Performing a Paragraph 

Three-Level 
Tables 
(continued) 
PERFORM 
VARYING REGION-SUB FROM 1 BY 1 
UNTIL REGION-SUB > 2 
AFTER RESPONSIBILITY-SUB FROM 1 BY 1 
UNTIL RESPONSIBILITY-SUB > 10 
AFTER EXPERIENCE-SUB FROM 1 BY 1 
UNTIL EXPERIENCE-SUB > 5 
MOVE ZERO TO SALARY (REGION-SUB, RESPONSIBILITY-SUB, EXPERIENCE-SUB) 
END-PERFORM. 
(b) in-Line Perform 
Region 
Responsibility 
Experience 
Subscript 
Subscript 
Subscript 
1 
1 
1 
1 
1 
2 
1 
1 
3 
1 
1 
4 
1 
1 
5 
REGION-SUB and RESPONSIBILITY-SUB 
are both set to 1 while 
E X P E R I E N C E - S U B 
varies from 1 to 5 
REGION S U B remains at 1 while 
RESPONSIBILITY-SUB is incremented 
* ~ o 
c v d c d i c 
varied from 1 to 5 
10 
10 
10 
10 
10 
2 
1 
1 
2 
1 
2 
2 
1 
3 
2 
1 
4 
2 
1 
5 
At the 50th iteration, REGION-SUB is still set to 1, 
but RESPONSIBILITY-SUB has reached 10 
REGION-SUB is incremented to 2, 
RESPONSIBILITY-SUB is reset to 1 while 
E X P E R I E N C E - S U B varies from 1 to 5 
2 
10 
1 
2 
10 
2 
2 
10 
3 
2 
10 
4 
2 
10 
5 
At the 100th iteration, REGION-SUB reaches 2, 
RESPONSIBILITY-SUB reaches 10 and 
E X P E R I E N C E - S U B reaches 5 
inaiion of 
jscrspts 

Chapter 
13 — 
Multilevel 
Tables 
(2 x 10 x 5) times. T h e bottom subscript (EXPERIENCE-SUB in the example) is 
varied first, then the middle subscript (RESPONSIBILITY-SUB), and finally the top 
subscript (REGION-SUB). T h e sequence in which the 100 combinations are 
executed is s h o w n in Figure 13.11. 
W e incorporate the material o n three-level tables into our previous sample C O B O L 
program on two-level tables. The specifications have been updated and are presented 
in their entirety. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
rhree-Level Tables 
N a r r a t i v e : 
This program extends the example on two-level tables to a third dimension in that salary 
is now a function of three variables (region, responsibility, and experience). As in the 
earlier program, a detail report is required showing the salary of each employee. In 
addition a summary report containing the number of employees in each region/ 
responsibility/experience combination is to be produced. 
Input F i l e ( s ) : 
EMPLOYEE-FILE 
Input R e c o r d L a y o u t : 01 EMPLOYEE-RECORD. 
05 EMP-NAME 
05 
EMP-SALARY-DETERMINANTS. 
10 EMP-RESP 
10 FILLER 
10 EMP-EXP 
10 FILLER 
10 
EMP-REGI0N 
05 FILLER 
PIC X(15). 
PIC 99. 
PIC X. 
PIC 99. 
PIC X(3). 
PIC 99. 
PIC X(5). 
T e s t D a t a : 
ADAMS 
04 01 01 
BAKER 
01 04 01 
BROWN 
08 02 02 
CHARLES 
09 02 02 
DAVIDSON 
09 04 02 
DAVIS 
10 04 01 
EPSTEIN 
04 05 02 
FRANKEL 
03 03 01 
GOODMAN 
03 03 01 
GULFMAN 
03 05 01 
HATHAWAY 
07 02 01 
INGLES 
03 01 01 
JACKSON 
06 03 01 
JORDAN 
06 03 01 
KING 
07 02 01 
LIPMAN 
07 01 01 
LOWELL 
01 04 02 
R e p o r t L a y o u t : 
See Figure 13.12. 

A Sample 
Program 
Output of Three-Level Program 
STARTING SALARIES OF ALL NEW EMPLOYEES 
ADAMS 
$30 000 
BAKER 
$29 000 
BROWN 
$44 000 
CHARLES 
$47 000 
DAVIDSON 
$53 000 
DAVIS 
$58 000 
EPSTEIN 
$40 000 
FRANKEL 
$30 000 
GOODMAN 
$30 000 
GULFMAN 
$32 000 
HATHAWAY 
$39 000 
INGLES 
$28 000 
JACKSON 
$38 000 
JORDAN 
$38 000 
KING 
$39 000 
LIPMAN 
$36 000 
LOWELL 
$31 000 
STARTING SALARY SUMMAR Y REPORT - REGION 
1 
EXPERIENCE 
RESPONSIBILITY 
1 
2 
3 
4 
5 
1 
0 
0 
0 
1 
0 
2 
0 
0 
0 
0 
0 
3 
1 
0 
2 
0 
1 
4 
1 
0 
0 
0 
0 
5 
0 
0 
0 
0 
0 
6 
0 
0 
2 
0 
0 
7 
1 
2 
0 
0 
0 
8 
0 
0 
0 
0 
0 
9 
0 
0 
0 
0 
0 
10 
0 
0 
0 
1 
0 
STARTING SALARY SUMMARY REPORT - REGION 
2 
EXPERIENCE 
RESPONSIBILITY 
1 
2 
3 
4 
5 
1 
0 
0 
0 
1 
0 
2 
0 
0 
0 
0 
0 
3 
0 
0 
0 
0 
0 
4 
0 
0 
0 
0 
1 
5 
0 
0 
0 
0 
0 
6 
0 
0 
0 
0 
0 
7 
0 
0 
0 
0 
0 
8 
0 
1 
0 
0 
0 
9 
0 
1 
0 
1 
0 
10 
0 
0 
0 
0 
0 

C
h
a
p
t
e
r 
1 3 — 
Multilevel 
Tables 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of employee records, and for each record: 
a. Determine the employee's starting saiary as a function of region, responsibility, and 
experience. 
b. Print a detail line for this employee showing his or her name and starting salary. 
2. Compute the number of employees for each 
region-responsibility-experience 
combination. This requires creation of a 2 x 10 x 5 table to store the number of 
individuals in each region-responsibility-experience combination, and implies that as 
each employee record is read, the corresponding table entry is incremented by one. 
3. When all employees have been processed, print the table containing the number of 
employees in each category as shown in Figure 13.12b. 
The extension of the original program from two to three dimensions is so direct 
that the hierarchy chart and pseudocode are virtually unchanged. The completed 
program is s h o w n in Figure 13.13, and should already appear familiar, as it repeats 
the C O B O L statements used in the explanation of three-level tables. The C O B O L 
statements to define the salary table (lines 44-73), appeared earlier in Figure 13.10b 
and were discussed fully at that time. Observe also the definition of a second 
Figure 13.13 Three-Level Program 
I 
1 
IDENTIFICATION DIVISION. 
j 
2 
PROGRAM-ID. 
3LVTABLE. 
| 
3 
AUTHOR. 
ROBERT T. GRAUER. 
j 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT EMPLOYEE-FILE 
ASSIGN TO 'A:\CHAPTR13\TABLES.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
I 
10 
SELECT PRINT-FILE 
j 
11 
ASSIGN TO PRINTER. 
\ 
12 
[ 
13 
DATA DIVISION. 
j 
14 
FILE SECTION. 
j 
15 
FD EMPLOYEE-FILE 
16 
DATA RECORD IS EMPLOYEE-RECORD. 
17 
01 EMPLOYEE-RECORD 
PIC X(23). 
\ 
18 
19 
FD PRINT-FILE 
I 
20 
DATA RECORD IS PRINT-LINE. 
j 
21 
01 PRINT-LINE 
PIC X(132). 
j 
22 
\ 
23 
WORKING-STORAGE SECTION. 
j 
24 
01 FILLER 
PIC X(14) 
| 
25 
VALUE 'WS BEGINS HERE'. 
I 
26 
| 
27 
01 WS-EMPLOYEE-RECORD. 
I 

A Sample 
Program 
Figure 13.13 
(continued) 
28 
05 EMP-NAME 
PIC X(15). 
29 
05 EMP-SALARY-DETERMJINANTS^ 
30 
10 E M P - R E S P ~ ~ ~ PIC 99. 
31 
10 FILLER 
PIC X. 
32 
10 EMP-EXP 
PIC 99. 
- 1\ 
33 
10 FILLER 
PIC X. 
' 
34 
10 EMP~-REG 
PIC 99. 
35 
36 
01 PROGRAM-SUBSCRIPTS. 
37 
05 RESP-SUB 
PIC S9(4) COMP. 
38 
05 EXP-SUB 
PIC S9(4) COMP. 
39 
05 REG-SUB 
PIC S9(4) COMP. 
40 
41 
01 WS-END-OF-DATA-SWITCH 
PIC X(3) 
VALUE SPACES. 
42 
88 END-OF-DATA 
VALUE 'YES'. 
43 
_ 
_ 
44 
; 01 SALARY-VALUES. 
45 
05 REGION-ONE. 
46 
10 FILLER PIC X(25) VALUE '2600027000280002900030000' 
47 
10 FILLER PIC X(25) VALUE '2700028000290003000031000' 
48 
10 FILLER PIC X(25) VALUE '2800029000300003100032000' 
49 
10 FILLER PIC X(25) VALUE '3000032000340003600038000' 
50 
10 FILLER PIC X(25) VALUE '3200034000360003800040000' 
51 
10 FILLER PIC X(25) VALUE '3400036000380004000042000' 
52 
10 FILLER PIC X(25) VALUE '3600039000420004500048000' 
53 
10 FILLER PIC X(25) VALUE '3900042000450004800051000' 
54 
10 FILLER PIC X(25) VALUE '4200045000480005100054000' 
55 
10 FILLER PIC X(25) VALUE '4600050000540005800062000' 
3D 
57 
05 REGION-TWO. 
58 
10 FILLER PIC X(25) VALUE '2800029000300003100032000' 
59 
10 FILLER PIC X(25) VALUE '2900030000310003200033000' 
60 
10 FILLER PIC X(25) VALUE '3000031000320003300034000' 
61 
10 FILLER PIC X(25) VALUE '3200034000360003800040000' 
62 
10 FILLER PIC X(25) VALUE '3400036000380004000042000' 
63 
10 FILLER PIC X(25) VALUE '3600038000400004200044000' 
64 
10 FILLER PIC X(25) VALUE '3800041000440004700050000' 
65 
10 FILLER PIC X(25) VALUE '4100044000470005000053000' 
66 
10 FILLER PIC X(25) VALUE '4400047000500005300056000' 
67 
10 FILLER PIC X(25) VALUE '4800052000560006000064000' 
68 
69 
01 SALARY-TABLE REDEFINES SALARY-VALUES. 
70 
05 REGION OCCURS 2 TIMES. 
71 
10 RESPONSIBILITY OCCURS 10 TIMES. 
72 
15 EXPERIENCE OCCURS 5 TIMES. 
73 
20 SALARY 
PIC 9(5). 
75 
01 NUMBER-OF-EMPLOYEES-TABLE. 
76 
05 NUMBER-REGION OCCURS 2 TIMES. 
77 
10 NUMBER-RESPONSIBILITY OCCURS 10 TIMES. 
L 

Chapter 
13 — 
Multilevel 
Tables 
(continued) 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
15 NUMBER-EXPERIENCE OCCURS 5 TIMES. 
20 NUMB-EMP 
PIC 99 
VALUE ZERO. 
01 
DETAIL-REPORT-HEADING-LINE. 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
05 FILLER 
PIC X(39) 
VALUE 'STARTING SALARIES OF ALL NEW EMPLOYEES'. 
05 FILLER 
PIC X(82) VALUE SPACES. 
01 DETAIL-LINE-1. 
05 FILLER 
05 DET-EMP-NAME 
05 FILLER 
05 
DET-SALARY 
05 FILLER 
PIC X(12) VALUE SPACES. 
PIC X(15). 
PIC X(4) 
VALUE SPACES. 
PIC $99,999. 
PIC X(94) VALUE SPACES. 
01 
SUMMARY-REPORT-HEADING-LINE-1. 
05 FILLER 
PIC X(24) VALUE SPACES. 
05 FILLER 
PIC X(39) 
VALUE 'STARTING SALARY SUMMARY REPORT - REGION'. 
05 SUM-REGION-NUMBER 
PIC ZZZ9. 
05 FILLER 
PIC X(65) VALUE SPACES. 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
01 
SUMMARY-REPORT-HEADING-LINE-2. 
05 FILLER 
PIC X(36) 
05 FILLER 
PIC X(10) 
05 FILLER 
PIC X(86) 
01 
SUMMARY-REPORT-HEADING-LINE-3. 
01 
05 FILLER 
05 FILLER 
05 FILLER 
VALUE 
05 FILLER 
PIC X(5) 
PIC X(14) 
PIC X(48) 
2 
PIC X(65) 
05 
05 
05 
VALUE SPACES. 
VALUE 'EXPERIENCE'. 
VALUE SPACES. 
VALUE SPACES. 
VALUE 'RESPONSIBILITY' 
3 
4 
VALUE SPACES. 
5'. 
SUMMARY-LINE-1. 
05 FILLER 
PIC X(9). 
SUMMARY-RESPONSIBILITY PIC Z(4). 
FILLER 
PIC X(4) 
SUMMARY-TOTAL-VALUES OCCURS 5 TIMES 
10 FILLER 
PIC X(4). 
10 SUMMARY-NUMBER 
PIC Z(4)9. 
05 FILLER 
PIC X(70). 
PROCEDURE DIVISION. 
100-PREPARE-SALARY-REPORT. 
OPEN INPUT EMPLOYEE-FILE 
OUTPUT PRINT-FILE. 
PERFORM 200-WRITE-DETAIL-REPORT-HDG. 
VALUE SPACES. 

A Sample 
Program 
3 
(continued) 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
PERFORM U N T I L EN0-0F-DATA 
READ EMPLOYEE-FILE INTO WS-EMPLOYEE-RECORD 
AT END 
MOVE 'YES' TO WS-END-OF-DATA-SWITCH 
NOT AT END 
PERFORM 300-PROCESS-EMPLOYEES 
END-PERFORM. 
PERFORM 400-WRITE-SUMMARY-REPORT 
VARYING REG-SUB FROM 1 BY 1 
U N T I L REG-SUB > 2. 
C L O S E EMPLOYEE-FILE 
PRINT-FILE. 
STOP R U N . 
200-WRITE-DETAIL-REPORT-HDG. 
W R I T E P R I N T - L I N E FROM DETAIL-REPORT-HEADING-LINE 
A F T E R A D V A N C I N G PAGE. 
M O V E SPACES TO PRINT-LINE. 
W R I T E PRINT-LINE. 
300-PROCESS-EMPLOYEES. 
]ADD 1 TO NUMB-EMP (EMP-REG, EMP-RESP, E M P - E X P ) . 
MOVE EMP-NAME TO DET-EMP-NAME. 
MOVE SALARY (EMP-REG, EMP-RESP, EMP-EXP) TO DET-SALARY 
[WRLTE^RIiTf 
. ' 
400-WRITE-SUMMARY-REPORT .J-
MOVE REG-SUB TO SUM-REGION-NUMBER. 
" 
PERFORM 5 0 0 - W R I T E - S U M M A R Y - H E A D I N G . 
PERFORM 
5 2 0 - W R I T E - R E S P O N S I B I L I T Y - L I N E 
VARYING RESP-SUB FROM 1 BY 1 
U N T I L RESP-SUB > 10. 
500-WRITE-SUMMARY-HEADING. 
W R I T E P R I N T - L I N E FROM SUMMARY-REPORT-HEAD ING-LINE-1 
A F T E R A D V A N C I N G PAGE. 
W R I T E PRINT-LINE FROM SUMMARY-REPORT-HEADING-LINE-2 
A F T E R A D V A N C I N G 2 LINES. 
W R I T E P R I N T - L I N E FROM S U M M A R Y - R E P O R T - H E A D I N G - L I N E - 3 . 
M O V E SPACES TO PRINT-LINE. 
W R I T E PRINT-LINE. 
5 2 0 - W R I T E - R E S P O N S I B I L I T Y - L I N E . 
MOVE S P A C E S T O S U M M A R Y - L I N E - 1 . 
" PERFORM "VARYING EXP-SUB* 
1 Y I 
U N T I L EXP-SUB > 5 
M O V E NUMB-EMP (REG-SUB, R E S P - S U B , EXP-SUB) 
TO S U M M A R Y - N U M B E R (EXP-SUB) 
END-PERFORM. 
MOVE RESP-SUB TO S U M M A R Y - R E S P O N S I B I L I T Y . 
W R I T E P R I N T - L I N E FROM S U M M A R Y - L I N E - 1 . 

C
h
a
p
t
e
r 
1 3 
~~ 
Multilevel 
Tables 
three-level table, for the n u m b e r of employees in each category in lines 75-79; 
tlic c i c i i n i L i u i i u o c a 
L i l t w t j i j u i i o u a u a t o 
i u cxiiu^ciit. opcii^o ivi 
ixi<^ ictuic;, i»ift ^iiiiio 
the R E D E F I N E S clause, because (unlike the salary table) the n u m b e r of employees 
is computed during processing. T h e 100 elements in the table are initialized to 
zero by the V A L U E Z E R O clause in line 79. (See limitations of C O B O L - 7 4 at the 
end of the chapter.) 
The Procedure Division of Figure 13.13 follows both the hierarchy chart a n d 
pseudocode. T h e key to the program is the A D D statement of line 148, which 
increments the n u m b e r of employees for the particular region/responsibility/ 
experience combination. The subscript values in this statement are taken directly 
from the incoming employee record, which define E M P - R E G , E M P - R E S P , a n d E M P -
EXP. The detail line for the individual employee is created in lines 149-151. 
The s u m m a r y report is produced after the e n d of file has been reached by the 
P E R F O R M statement of lines 134-136, which executes the paragraph W R I T E -
S U M M A R Y - R E P O R T twice, once for each region. T h e heading lines are written 
(statements 160-167), after which the paragraph WRITE-RESPONSIBILLTY-LINE is 
executed 10 times (once for each responsibility level) in lines 171-175. The latter 
paragraph contains its o w n P E R F O R M V A R Y I N G statement to write the five 
experience totals for each responsibility level. 
T h e examples thus far took advantage of a direct lookup in which the table elements 
were referenced directly by the value of the subscript; that is, the examples used 
numeric subscripts for responsibility a n d experience that corresponded directly to 
the row and column of the table. This is not always true as indicated by the example 
in Figure 13.14. 
The table in Figure 13.14a depicts a user's view in which quarterly sales are 
recorded for every branch within the corporation. The C O B O L implementation in 
Figure 13.14b establishes B R A N C H as a one-level table with 25 rows; it also establishes 
Q U A R T E R L Y - S A L E S as a two-level table consisting of 25 rows a n d 4 columns. A n y 
reference to B R A N C H - N A M E requires a single subscript (index)— for example, 
B R A N C H - N A M E (2) to obtain the branch-name in the second row. A n y reference to 
Q U A R T E R L Y - S A I . E S requires two subscripts (indexes) to indicate the branch a n d 
quarter—for example, Q U A R T E R L Y - S A L E S (2, 1), Q U A R T E R L Y - S A L E S (2, 2), 
Q U A R T E R L Y - S A L E S (2,3), a n d Q U A R T E R L Y - S A L E S (2,4) to reference the four sales 
figures for the branch in r o w two. Figure 13.14c shows the corresponding storage 
schematic. 
A s s u m e n o w that w e want to obtain the annual sales for a specific branch, for 
example, Boston. A n individual could tell at a glance that the data for Boston are in 
the second row of the table a n d would k n o w automatically to s u m the figures in row 
two to obtain the annual sales. T h e computer, however, has to first search the table 
of branch n a m e s to locate the proper row before s u m m i n g the quarterly sales. The 
process is illustrated in Figure 13.4d, which contains the Procedure Division 
statements necessary to obtain the annual sales for Boston. 
The SET statement is required prior to a sequential search in order to begin 
the search in row one of the B R A N C H table. The S E A R C H statement varies B R A N C H -
I N D E X until a m a t c h is found o n branch n a m e ; the W H E N clause includes a 
P E R F O R M V A R Y I N G statement that varies Q U A R T E R L Y - I N D E X from one to four in 
the appropriate ( B R A N C H - I N D E X ) row in order to obtain the annual total. Note, 
too, the use of scope terminators ( E N D - A D D , E N D - P E R F O R M , a n d E N D - S E A R C H ) 
a n d h o w the various statements are nested within one another. 

Table 
Lookups 
Two-Level Table Lookup 
Branch Name 
1st Quarter 2nd Quarter 3rd Quarter 
4th Quarter 
Atlanta 
$100,000 
$200,000 
$300,000 
$400,000 
Boston 
$50,000 
$150,000 
$250,000 
$350,000 
Chicago 
$150,000 
$165,000 
$400,000 
$275,000 
San Diego 
$25,000 
$50,000 
$75,000 
$100,000 
(a) User's View 
01 SALES-TABLE REDEFINES SALES-DATA. 
05 BRANCH OCCURS 25 TIMES 
INDEXED BY BRANCH-INDEX. 
10 BRANCH-NAME 
PIC X(12). 
10 QUARTERLY-SALES 
OCCURS 4 TIMES 
INDEXED BY QUARTERLY-INDEX 
PIC 9(6). 
(b) Table Definition 
SALES-TAB LE 
BRANCH (1) 
BRANCH (25) 
BRANCH 
QUARTERLY 
QUARTERLY 
BRANCH 
QUARTERLY 
QUARTERLY 
NAME (1) 
SALES (1,1) 
SALES (1,4) 
NAME (25) 
SALES (25,1) 
SALES (25,4) 
PIC X(12) 
PIC 9(6) 
PIC 9(6) 
PIC X(12) 
PIC 9(6) 
PIC 9(6) 
(c) Storage Schematic 
MOVE ZEROS TO ANNUAL-TOTAL. 
SET BRANCH-INDEX TO 1. 
SEARCH BRANCH 
AT END 
DISPLAY 'Boston not in table' 
WHEN BRANCH-NAME (BRANCH-INDEX) = 'Boston' 
PERFORM VARYING QUARTERLY-INDEX FROM 1 BY 1 
UNTIL QUARTERLY-INDEX > 4 
ADD QUARTERLY-SALES (BRANCH-INDEX, QUARTERLY-INDEX) 
TO ANNUAL-TOTAL 
SIZE ERROR 
DISPLAY 'ANNUAL TOTAL TOO LARGE' 
END-ADD 
END-PERFORM 
END-SEARCH. 
(d) S E A R C H Statement 

C
h
a
p
t
e
r 
1 3 — 
Multilevel 
Tables 
W e c o m e n o w to our final example, which ties together material from several 
previous 
chapters. The specifications call for an interactive program that accepts information 
from the console a n d displays the results o n the monitor. Specifications follow in 
the usual format. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
A Calorie Counter's Delight 
Narrative: 
Develop a program that will prompt the operator for an age and weight, then display the 
number of calories needed to maintain that weight. The table of daily maintenance 
calories is given in the second processing requirement. 
Input File(s): 
None; input will be accepted from the console. 
R e p o r t L a y o u t : 
None; output will be displayed on the monitor. 
1. Prompt the user for age and weight; validate the parameters immediately as they are 
input and prompt the user continually until valid values are received. Age must be 
between 18 and 75 years, inclusive; weight between 90 and 165 pounds, inclusive. 
2. Display the calories required to maintain the indicated weight according to the 
table below. 
90 
99 
1,700 
1,500 
1,300 
100 
110 
1,850 
1,650 
1,400 
111 
121 
2,000 
1,750 
1,550 
122 
128 
2,100 
1,900 
1,600 
129 
132 
2,150 
1,950 
1,650 
133 
143 
2,300 
2,050 
1,800 
144 
154 
2,400 
2,150 
1,850 
155 
165 
2,550 
2,300 
1,950 
3. Ask the user whether s/he wishes to input another set of parameters; if yes, repeat 
steps one and two above; if not, terminate the program. 
The concept of a range-step table w a s introduced in the previous chapter and is 
essential to the solution of the present problem. A range-step table occurs w h e n the 
s a m e table value—for example, 1,700 calories—is applicable to m a n y search 
arguments—for example, any weight between 90 a n d 99 pounds coupled with any 
age between 18 a n d 35. W e need to recognize, therefore, that two range-step tables, 
for weight and age, are necessary in addition to the calorie maintenance table. 

Calorie 
Ranqe-step Tables 
99 
110 
121 
128 
132 
143 
154 
165 
35 
55 
75 
1,700 
1,500 
1,300 
1,850 
1,650 
1,400 
2,000 
1,750 
1,550 
2,100 
1,900 
1,600 
2,150 
1,950 
1,650 
2,300 
2,050 
1,800 
2,400 
2,150 
1,850 
2,550 
2,300 
1,950 
01 
01 
CALORIE-VALUES. 
05 FILLER 
FILLER 
FILLER 
FILLER 
FILLER 
FILLER 
FILLER 
FILLER 
05 
05 
05 
05 
05 
05 
05 
PIC X(12) 
PIC X(12) 
PIC X(12) 
PIC X(12) 
PIC X(12) 
PIC X(12) 
D T T 
Y(10\ 
PIC X(12) 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
VALUE 
'170015001300' 
'185016501400' 
'200017501550' 
'210019001600' 
'215019501650' 
'230020501800' 
'240021501850' 
'255023001950' 
CALORIE-TABLE REDEFINES CALORIE-VALUES. 
05 CALORIE-WEIGHTS OCCURS 8 TIMES 
INDEXED BY CAL-WGT-INDEX. 
10 CALORIE-AGES OCCURS 3 TIMES 
INDEXED BY CAL-AGE-INDEX. 
PIC 9(4). 
15 CALORIES 
01 WEIGHT-LIMIT-VALUES. 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
01 WEIGHT-TABLE REDEFINES WEIGHT-LIMIT-VALUES. 
05 WEIGHT-LIMIT OCCURS 8 TIMES 
INDEXED BY WEIGHT-INDEX 
PIC 9(3). 
PIC X(3) 
VALUE '099' 
PIC X(3) 
VALUE '110' 
PIC X(3) 
VALUE '121' 
PIC X(3) 
VALUE '128' 
PIC X(3) 
VALUE '132' 
PIC X(3) 
VALUE '143' 
PIC X(3) 
VALUE '154' 
PIC X(3) 
VALUE '165' 
01 AGE-LIMIT-VALUES. 
05 FILLER 
05 FILLER 
05 FILLER 
PIC XX 
VALUE '35', 
PIC XX 
VALUE '55', 
PIC XX 
VALUE '75' , 
01 AGE-TABLE REDEFINES AGE-LIMIT-VALUES. 
05 AGE-LIMIT OCCURS 3 TIMES 
INDEXED BY AGE-INDEX 
PIC 99. 
:atiofi 

Chapter 
13 — 
Multilevel 
Tables 
ia 
Hierarchy Chart 
PROCESS 
CALORIES 
INQUIRY 
FIND 
CALORIES 
DISPLAY 
RESULTS 
GO AGAIN 
O u r solution is s h o w n in Figure 13.15. The user's view of the three tables is 
s h o w n in Figure 13.15a a n d the C O B O L implementation in Figure 13.15b. T h e 
definition of the C A L O R I E - T A B L E is straightforward a n d uses the O C C U R S , V A L U E , 
and R E D E F I N E S clauses as explained earlier. T h e W E I G H T - L I M I T table stores only 
the upper limit for each weight class because the ranges overlap from one class to 
the next—that is, 90-99 pounds, 100 110 pounds, 111-121 pounds, and so on. In 
similar fashion the age-limit table stores only the upper limit for each age class. 
The hierarchy chart in Figure 13.16 contains the modules to get the user's age 
and weight, determine the n u m b e r of calories, display the results, then determine 
whether the entire process is to be repeated. T h e pseudocode in Figure 13.17 
continually prompts the user until a valid age is received, then prompts the user for 
a valid weight. T h e nested search statement mimics the process a person would 
follow to determine the n u m b e r of calories based o n weight a n d age—that is, to 
search the weight limits in the various rows, then go across the appropriate row to 
search the age limits for that weight. Note, too, the less than or equal condition in 
the search argument, which checks only the upper limit in each weight (age) class. 
The completed program is s h o w n in Figure 13.18 and parallels the pseudocode and 
hierarchy chart just discussed. Several features of the program merit attention. 
1. The definition of C A L O R I E - T A B L E in lines 17-32 as a two-level 8 x 3 table; the 
indexes C A L - W G T - I N D E X a n d C A L - A G E - I N D E X are defined with the table to 
reference the row a n d column, respectively. 
2. The definition of two range-step tables for weight a n d age limits in lines 34-46 
a n d lines 48-55, a n d referenced by W E I G H T - I N D E X a n d A G E - I N D E X , 
respectively. 
3. T h e nested SEARCH statements in lines 82-94, w h i c h identify the row 
containing the weight limit (from the one-level weight-limit table), the column 
containing the age limit (from the one-level age-limit table), then reference 
the corresponding r o w a n d c o l u m n in the calorie table to display the answer. 
4. The S E T statement in line 81 that initializes W E I G H T - I N D E X (from the weight-
limit table) and C A L - W G T - I N D E X (from the two-level calorie table); the 

A Calorie 
Counter's 
Delight 
Figure 13,17 
Pseudocode 
I 
DO WHILE user wants to inquire 
I 
Initialize age & weight 
j 
DO WHILE invalid age 
! 
Display age prompt 
Accept age from user 
1 — ENDDO 
j r 
DO WHILE invalid weight 
| 
Display weight prompt 
Accept weight from user  
ENDDO 
r 
SEARCH weight-limit-table 
AT END 
| 
Display invalid weight 
WHEN user's weight <= table value 
: 
r - 
SEARCH age-limit table 
i 
AT END 
| 
| 
Display invalid age 
| 
| 
WHEN user's age <= table value 
! 
MOVE c a l o r i e s (wgt-1imt, a g e - l i m i t ) 
to output 
|
 
L- 
END-SEARCH 
1 — 
END-SEARCH 
Display required calories 
Display prompt to go again 
Accept user's response 
ENDDO 
Stop Run 
Calories Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
CALORIE. 
3 
AUTHOR. 
CVV. 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
DATA DIVISION. 
WORKING-STORAGE SECTION. 
01 
INDIVIDUAL-DATA. 
05 IND-AGE 
88 VALID-AGE 
05 IND-WEIGHT 
88 VALID-WEIGHT 
01 PROGRAM-VARIABLES. 
05 CALORIES-NEEDED 
05 GO-AGAIN-SWITCH 
01 CALORIE-VALUES. 
05 FILLER 
PIC 99. 
PIC 9(3). 
VALUE 18 THRU 75. 
VALUE 90 THRU 165. 
PIC 2,119 VALUE ZEROS. 
PIC X. 
PIC X(12) VALUE '170015001300' 

C
h
a
p
t
e
r 
B 
(continued) 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
05 FILLER 
PIC X(12) VALUE 
PIC X(12) VALUE 
PIC X(12) VALUE 
PIC X(12) VALUE 
PIC X(12) VALUE 
PIC X(12) VALUE 
PIC X(12) VALUE 
'185016501400', 
'200017501550'. 
'210019001600', 
'215019501650'. 
'230020501800', 
'240021501850'. 
'255023001950', 
01 CALORIE-TABLE REDEFINES CALORIE-VALUES. 
05 CALORY-WEIGHTS OCCURS 8 TIMES 
INDEXED BY CAL-WGT-INDEX. 
10 CALORY-AGES OCCURS 3 TIMES 
INDEXED BY CAL-AGE-INDEX. 
15 CALORIES 
01 
WEIGHT-LIMIT-VALUES. 
PIC 9(4). 
05 FILLER 
PIC X(3) 
VALUE '099 
05 FILLER 
PIC X(3) 
VALUE '110 
05 FILLER 
PIC X(3) 
VALUE '121 
05 FILLER 
PIC X(3) 
VALUE '128 
05 FILLER 
PIC X(3) 
VALUE '132 
05 FILLER 
PIC X(3) 
VALUE '143 
05 FILLER 
PIC X(3) 
VALUE '154 
05 FILLER 
PIC X(3) 
VALUE '165 
01 WEIGHT-TABLE REDEFINES WEIGHT-LIMIT-VALUES. 
05 WEIGHT-LIMIT OCCURS 8 TIMES 
INDEXED BY WEIGHT-INDEX 
PIC 9(3). 
01 AGE-LIMIT-VALUES. 
05 FILLER 
05 FILLER 
05 FILLER 
PIC XX 
VALUE '35' 
PIC XX 
VALUE '55' 
PIC XX 
VALUE '75' 
01 AGE-TABLE REDEFINES AGE-LIMIT-VALUES. 
05 AGE-LIMIT OCCURS 3 TIMES 
INDEXED BY AGE-INDEX 
PIC 99. 
PROCEDURE DIVISION. 
PROCESS-CALORIE-INQUIRY. 
PERFORM UNTIL GO-AGAIN-SWITCH = 'n' OR 
MOVE ZEROS TO IND-AGE IND-WEIGHT 
' PERFORM GET-AGE 
UNTIL VALID-AGE 
PERFORM GET-WEIGHT 
UNTIL VALID-WEIGHT 
PERFORM FIND-CALORIES 
PERFORM DISPLAY-RESULTS 
PERFORM GO-AGAIN 
END-PERFORM. 
DISPLAY 'May all your calories be non-fat' 

A 
Calorie 
Counter's 
Deiigirt 
(continued) 
70 
STOP RUN. 
71 
72 
GET-AGE. 
73 
DISPLAY 'Enter Age (18-75):
 1 NO ADVANCING. 
74 
ACCEPT IND-AGE. 
75 
76 
GET-WEIGHT. 
77 
DISPLAY 'Enter Weight (90-165): ' NO ADVANCING. 
78 
ACCEPT IND-WEIGHT. 
79 
80 
FIND-CALORIES. 
81 
SET WEIGHT-INDEX CAL-WGT-INDEX TO 1. 
82 
\ SEARCH WEIGHT-LIMIT VARYING CAL-WGT-INDEX 
83 
AT END 
84 
DISPLAY 'Weight not found in table' 
85 
; 
W H E N IND-WEIGHT < = W E I G H T - L I M I T (WEIGHT-INDEX) 
86 
; 
S E T AGE-INDEX C A L - A G E - I N D E X T O 1 
87 
SEARCH AGE-LIMIT VARYING CAL-AGE-INDEX 
88 
! 
A T END 
89 
DISPLAY 'Age not found in table' 
90 
WHEN IND-AGE <= AGE-LIMIT (AGE-INDEX) 
91 
MOVE CALORIES (CAL-WGT-INDEX, CAL-AGE-INDEX) 
92 
i 
TO CALORIES-NEEDED 
93
 
1 
END-SEARCH 
94 
! ENp-SEARCH_. 
95 
96 
DISPLAY-RESULTS. 
97 
DISPLAY ' «. 
98 
DISPLAY CALORIES-NEEDED ' calories/day will maintain ' 
99 
'a weight of ' IND-WEIGHT ' pounds at age ' IND-AGE. 
100 
DISPLAY '
 
1. 
101 
102 
GO-AGAIN. 
103 
DISPLAY 'Go again? (Y/N) ' NO ADVANCING. 
104 
ACCEPT GO-AGAIN-SWITCH. 
SEARCH VARYING statement in line 82 manipulates these indexes in 
conjunction with one another so that w h e n the weight limit is found in the 
first table, the corresponding row is set in the second table. T h e S E T statement 
in line 86 a n d the S E A R C H V A R Y I N G statement in line 87 function in similar 
fashion for the age limit a n d corresponding column in the calorie table. 
5. The M O V E statement in line 91 is a direct lookup that uses values of C A L -
W G T - I N D E X a n d C A L - A G E - I N D E X established by the nested S E A R C H 
statements. 
6. The various A C C E P T a n d DISPLAY statements throughout the program that 
utilize screen I-O. 

C
h
a
p
t
e
r 
1 3 
Multilevel 
Tables 
Seven levels of subscripting are permitted in COBOL-85 as opposed to the 
earlier limit of three; most applications, however, do not require even three-
level tables. 
COBOL-85 facilitates the initialization of a table in which all elements 
have the same value by allowing the VALUE clause to be specified In 
the same entry as an OCCURS clause. (The technique was illustrated in 
lines 61-62 of Figure 13.9.) This was not permitted in COBOL-74, which 
required a PERFORM VARYING statement or REDEFINES clause to achieve 
the same result. 
The optional END-SEARCH scope terminator is new to COBOL-85 and 
terminates the conditional portion of the SEARCH and SEARCH ALL 
statements; the scope terminator makes it possible to nest SEARCH 
statements. 
.Q u 
H Y 
Multilevel tables of up to seven leveis are possible in COBOL-85 although 
most applications use tables of only one, two, or three dimensions. 
The entries in multiple-level tables may be referenced in different hierarchical 
levels. The number of subscripts (indexes) needed is equal to the number 
of OCCURS clauses in the entry definition. 
Tables at any level may be initialized through a combination of the OCCURS, 
VALUES, and REDEFINES clauses. The OCCURS clause allocates space 
for the table, the VALUE clause places data in these locations, and the 
REDEFINES clause assigns another name to previously allocated space. 
Multilevel tables can be manipulated by using the PERFORM VARYING 
statement with the addition of the appropriate AFTER clause(s). The bottom 
subscript (index) is always manipulated first. 
The SEARCH VARYING statement manipulates the indexes in two tables in 
conjunction with one another; the technique is often used with range-step 
tables, in which the table arguments are stored in a separate table. 
Compilation error 
Detail report 
Execution error 
Hierarchical level 
Nested search statement 
Range-step table 
Summary report 
Three-level table 
Two-level table 
User view 

True/False 
P I I 
I 
. i l\S 
AFTER 
REDEFINES 
BY 
SEARCH VARYING 
END-SEARCH 
UNTIL 
OCCURS 
VALUE 
PERFORM VARYING 
1. A two-level table requires two 
clauses in its definition. 
2. In a PERFORM VARYING statement with two subscripts, the (bottom/top) subscript 
is varied first. 
3. COBOL-85 permits a maximum of 
subscripts. 
4. If a Procedure Division reference is made to FIELD-ONE (SUB1, SUB2), SUB1 
refers to the 
level OCCURS clause, whereas SUB2 refers to the 
level OCCURS clause. 
5. In COBOL-74 a VALUE clause (may/may not) be used in conjunction with an 
clause to initialize a table, and so a 
clause is 
used as weil. 
6. The statement: 
PERFORM PARAGRAPH-A 
VARYING SUB1 FROM 1 BY 1 UNTIL SUB1 > 5 
AFTER SUB2 FROM 1 BY 1 UNTIL SUB2 > 6. 
will perform PARAGRAPH-A a total of 
times. 
7. The PERFORM statement of question 6 begins execution by setting SUB1 to 1, and 
varying SUB2 from 
to 
, after which SUB1 will 
be incremented to 
, and SUB2 will again vary from 
to 
. 
8. Given the COBOL definition: 
01 CORPORATION. 
05 REGION OCCURS 4 TIMES. 
10 STATE OCCURS 5 TIMES. 
15 CITY OCCURS 6 TIMES PIC 9(6). 
A total of 
elements are present in the table. 
9. Answer with respect to the table of question 8. Any reference to REGION requires 
subscript(s), a reference to STATE requires 
subscript(s), and a reference to CITY requires 
subscript(s). 
J E / F A L o r. 
1. 
2. 
3. 
A maximum of seven OCCURS clauses in a given table is permitted in COBOL-85. 
A given entry may contain both an OCCURS clause and a PICTURE clause. 
A given entry may contain both an OCCURS clause and a VALUE clause. 

Chapter 
13 -
Multilevel 
Tables 
4. The REDEFINES clause is required whenever a table is initialized. 
5. A PERFORM VARYING statement may vary indexes as well as subscripts. 
6. Referencing a data name with two subscripts, when only a single OCCURS clause 
appears in the table definition, produces a compilation error. 
7. Referencing a data name with a subscript value of 50, when the OCCURS clause 
indicates only 10 entries, produces a compilation error. 
8. SEARCH statements may be nested. 
9. The VARYING, FROM, BY, and AFTER clauses are mandatory in a PERFORM 
statement. 
10. A PERFORM VARYING statement will always execute the designated procedure at 
least once. 
1. Write out the 12 pairs of values that will be assumed by SUB-1 and SUB-2 as a 
result of the statement: 
PERFORM 10-PROCESS-TABLE 
VARYING SUB-1 FROM 1 BY 1 
UNTIL SUB-1 > 4 
AFTER SUB-2 FROM 1 BY 1 
UNTIL SUB-2 > 3. 
2. Indicate the 24 sets of values that will be assumed by SUB-1, SUB-2, and SUB-3 
as a result of the following statement. Remember that the bottom subscript is 
varied first. 
PERFORM 10-PROCESS-TABLE 
VARYING SUB-1 FROM 1 BY 1 
UNTIL SUB-1 > 3 
AFTER SUB-2 FROM 1 BY 1 
UNTIL SUB-2 > 2 
AFTER SUB-3 FROM 1 BY 1 
UNTIL SUB-3 > 4. 
3. Given the following table definition: 
01 
CORPORATE-DATA. 
05 COMPANY OCCURS 10 TIMES. 
10 DIVISION-NAME 
PIC X(15). 
10 YEARLY-FINANCIAL-DATA OCCURS 4 TIMES. 
15 REVENUE 
PIC 9(7) 
15 NET-INCOME 
PIC 9(7). 
a. Indicate an appropriate storage schematic. 
b. State whether the following are valid or invalid references, and if invalid, indicate 
whether the problem occurs during compilation or execution: 
CORPORATE-DATA 
COMPANY 
in. COMPANY (8) 
iv. DIVISION-NAME (8) 
v. DIVISION-NAME (12) 

vi. YEARLY-FINANCIAL-DATA (4) 
vii. REVENUE (10, 4) 
viii. NET-INCOME (10,4) 
ix. REVENUE (4, 10) 
4. A corporation monitors monthly sales for its six branch offices according to the 
following table definition: 
01 CORPORATE-SALES-TABLE. 
05 BRANCH-OFFICE OCCURS 6 TIMES. 
10 BRANCH-NAME 
PIC X(10). 
10 MONTHS OCCURS 12 TIMES. 
15 SALES-AMOUNT 
PIC 9(6). 
a. Indicate the appropriate storage schematic. 
b. Write a PERFORM VARYING statement to determine the annual sales for the 
third branch office. 
c. Write a PERFORM VARYING statement to determine the corporate sales for 
May. 
d. Write a PERFORM VARYING statement to determine the corporate sales for the 
entire year. 
e. Develop an FD, corresponding record description, and associated Procedure 
Division statements, to read the data for CORPORATE-SALES-TABLE from a file 
of six records; that is, each incoming record has the 12 monthly sales for a 
particular branch office. 
f. Develop an FD, corresponding record description, and associated Procedure 
Division statements, to read the data for CORPORATE-SALES-TABLE from a file 
of 12 records; that is, each incoming record has the six branch office amounts 
for a particular month. 
5. Your professor has two sections of COBOL. Each section has 40 students. Each 
student is expected to submit six projects and take three examinations. Develop a 
file structure suitable to all of this data in a single table. 
6. The following table was suggested to tabulate enrollments for the various colleges 
within a university. Each college, such as the College of Engineering, has multiple 
majors: Mechanical Engineering, Electrical Engineering, and so on. 
01 ENROLLMENT-DATA. 
05 COLLEGE OCCURS 3 TIMES. 
10 MAJOR OCCURS 50 TIMES. 
15 YEAR OCCURS 4 TIMES. 
20 NUMBER-OF-STUDENTS 
PIC 9(4). 
a. Indicate an appropriate storage schematic. 
b. State whether the following are valid or invalid references, and if invalid, indicate 
whether the problem occurs during compilation or execution: 
i. 
ENROLLMENT-DATA 
ii. COLLEGE (1) 
iii. MAJOR (1) 
iv. YEAR (1) 
v. NUMBER-OF-STUDENTS (1) 
vi. NUMBER-OF-STUDENTS (1, 2, 3) 
vii. NUMBER-OF-STUDENTS (4, 5, 6) 

C
h
a
p
t
e
r 
1 3 
-
Multilevel 
Tables 
Write PERFORM VARYING statements to determine: 
The total number of students in the university. 
The total number of seniors in the first college. 
The total number of students in the first major of the first college. 
The total number of freshmen (year 1) in the first college. 
The total number of freshmen in the university. 

Overview 
S y s t e m C o n c e p t s 
Collating S e q u e n c e 
Embedded Sign 
C O B O L implementation 
SORT Statement 
SD (Sort Description) 
RELEASE and RETURN 
Programming Specifications 
U S I N G / G I V I N G Option 
I N P U T P R O C E D U R E / O U T P U T P R O C E D U R E Option 
C o m p a r i n g 
Options 
M E R G E S t a t e m e n t 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
1 4 
— 
Sorting 
O B J E C T 
IVES 
After reading this chapter you will be able to: 
Distinguish between an internal sort, a utility sort, and the COBOL SORT 
statement. 
Differentiate between an ascending and a descending sort; between major, 
intermediate, and minor keys; and between primary, secondary, and tertiary 
keys. 
Define collating sequence; discuss the most significant differences between 
EBCDIC and ASCII and how the collating sequence affects fields with an 
embedded sign. 
Explain the syntax of the COBOL SORT statement, and the supporting 
RELEASE, RFTURN, and SD statements. 
Explain the use of INPUT PROCEDURE to sort on a calculated field, and/or 
to selectively pass records to the sort work file. 
Distinguish, between a merge and a sort. 
D 
1/ F 
n 
1/ 
/ 
F 
w 
Sorting (the rearrangement of data) is one of the most frequent operations in 
data processing, making it possible to present data in a variety of sequences 
according to the analysis required. Transactions may be listed alphabetically, 
alphabetically by location, in ascending or descending sequence by account 
balance, and so on. The sorting procedure itself is accomplished in one of 
three ways: 
1. An internal sort, in which the programmer develops his or her own logic 
within the application program. (This approach is typically not used by the 
COBOL programmer.) 
2. A utility sort, in which an independent sort program is executed outside of 
the application program as a separate step. 
3. The COBOL SORT statement, in which control is passed to the independent 
sort program from within the COBOL program. 
(Our discussion deals 
exclusively with this approach.) 
We begin the chapter by developing the general concepts associated with 
sorting, then present the necessary statements to implement sorting within a 
COBOL program. We develop two parallel programs to illustrate variations 
within the SORT statement and conclude with a brief discussion of merging, 
which is a special case of sorting. 

Collating 
Sequence 
i> 
^
e
M 
A sort key is a field within a record that determines h o w the file is to be arranged. 
C l- « © p t S 
Several keys m a y be specified in a single sort, as in the case of a departmental 
census in which employees are to appear alphabetically within department. In 
other words, the file is to be rearranged (that is, sorted) so that all employees in the 
same department appear together, a n d further, so that employees in the s a m e 
department appear alphabetically. Department is a more important key than 
employee n a m e ; thus department is considered the major key and employee n a m e 
the minor key. (Other, equally correct, terminology refers to department as the 
primary key and n a m e as the secondary key.) 
Sorting is done in one of two sequences: ascending (low to high) or descending 
(high to low). Listing employees in increasing order of salary is an example of an 
ascending sort, whereas listing them in decreasing order (that is, with the highest 
salary first) represents a descending sort. Any sort on an alphabetic field, (employee 
name, for example) is always perceived as an ascending sort. (An ascending sort is 
assumed if the sequence is not specified.) 
To be absolutely sure of this terminology, consider Figure 14.1. Figure 14.1a 
lists unsorted data for 12 students. Figure 14.1b displays these records after they 
have been sorted by name only. 
Figure 14.1c shows a primary sort on year 
(descending) a n d a secondary sort on n a m e . Thus, all students in year four are 
listed first (in alphabetical order), then all students in year three, and so on. Finally, 
Figure 14.Id illustrates primary, secondary, and tertiary sorts. All business majors 
are listed first, then all engineering majors, and finally all liberal arts majors. Within 
each major, students are listed by year in descending order a n d are also listed 
alphabetically within year. 
I he sequencing of numeric items is done strictly according to their algebraic values; 
j>-1_-£ ^(/T 
for example, -10 is less than +5, which is less than +10. The length of a numeric field 
does not enter into the comparison; for example, a four-digit integer field equal to 
0099 is less than a three-digit field equal to 100. 
The sequencing of alphabetic and/or alphanumeric fields is m o r e subtle with 
fields of different length—for example, G R E E N a n d G R E E N F I E L D . T h e sorting 
algorithm compares the two n a m e s one character at a time, from left to right a n d 
determines that the first five letters, G, R, E, E, a n d N , are the s a m e in both names. 
The shorter field ( G R E E N in the example) is then extended with blanks so that 
comparison m a y continue. A blank, however, is always considered smaller than 
any other letter, so that G R E E N will be placed ahead of G R E E N F I E L D . 
The sorting of alphanumeric fields is further complicated w h e n the sort key 
contains letters and numbers. Comparison still proceeds from left to right, but 
which alphanumeric key should c o m e first, 111 or AAA? Surprisingly, either answer 
could be correct, depending o n the collating sequence in effect. Collating sequence 
is defined, as the ordered list (from low to high) of all valid characters and is a 
function of manufacturer; I B M mainframes use E B C D I C , whereas almost every 
other computer, including the PC, uses ASCII. Both sequences are s h o w n in 
Figure 14.2 for selected characters. 
As can be seen from Figure 14.2, the n u m b e r one I comes after the letter A in 
E B C D I C , but before the letter A in ASCII. In other words, in an alphanumeric sort a 
key of 111 will precede a key of A A A under the ASCII collating sequence, but follow it 
under E B C D I C . It is imperative, therefore, that you be aware of the collating sequence 
in effect w h e n alphanumeric keys are specified. This is especially true in a 

Chapter 
14 — Sorting 
Sorting Vocabulary 
Primary Key: Name (Ascending) 
NAME 
YEAR 
MAJOR 
NAME 
YEAR 
MAJOR 
Smith 
1 
Liberal arts 
Adams 
3 
Business 
Jones 
4 
Engineering 
Benjamin 
4 
Business 
Adams 
3 
Business 
Crawford 
2 
Engineering 
Howe 
2 
Liberal arts 
Deutsch 
4 
Business 
Frank 
1 
Engineering 
Epstei n 
2 
Engineering 
Epstein 
2 
Engineering 
Frank 
1 
Engineering 
Zev 
4 
Busi ness 
Grauer 
3 
Liberal arts 
Benjami n 4 
Business 
Howe 
2 
Liberal arts 
Grauer 
3 
Liberal arts 
Jones 
4 
Engineering 
Crawford 
2 
Engineering 
Makoske 
1 
Business 
Deutsch 
4 
Business 
Smith 
1 
Liberal arts 
Makoske 
1 
Business 
Zev 
4 
Business 
(a) Unsorted Data 
(b) Sorted Date J. Oris K©y 
Primary Key: Major (Ascending) 
Primary Key: Year (Descending) 
Secondary Key: Year (Descendi ng) 
Secondary Key : Name (Ascending) 
Tertiary Key: Name (Ascending) 
NAME 
YEAR 
MAJOR 
NAME 
YEAR 
MAJOR 
Benjami n 
4 
Business 
Benjamin 
4 
Business 
Deutsch 
4 
Business 
Deutsch 
4 
Business 
Jones 
4 
Engineering 
Zev 
4 
Business 
Zev 
4 
Business 
Adams 
3 
Business 
Adams 
3 
Business 
Makoske 
1 
Business 
Grauer 
3 
Liberal arts 
Jones 
4 
Engineering 
Crawford 
2 
Engineering 
Crawford 
2 
Engineering 
Epstein 
2 
Engineering 
Epstei n 
2 
Engineering 
Howe 
2 
Liberal arts 
Frank 
1 
Engineering 
Frank 
1 
Engi neeri ng 
Grauer 
3 
Liberal arts 
Makoske 
1 
Business 
Howe 
2 
Liberal arts 
Smith 
1 
Liberal arts 
Smith 
1 
Liberal arts 
(c) Sorted D ata, Two Keys 
(d) Sorted £ 
Three Keys 
multivendor environment, as w h e n on-site mini- or microcomputers offload to an 
IBM mainframe. 
Embedded Sign 
.. 
The collating sequence has yet a n additional consequence with signed numeric 
fields. Arithmetic operations require positive and negative numbers, and hence, 
w h e n w e do arithmetic with pencil and paper, w e precede the numbers with plus 

Collating 
Sequence 
EBCDIC 
ASCil 
(space) 
(space) 
(period) 
(quotation mark) 
(less than) 
$ 
(currency symbol) 
(left parenthesis) 
(apostrophe) 
(plus symbol) 
( 
(left parenthesis) 
(currency symbol) 
) 
(right parenthesis) 
(asterisk) 
* 
(asterisk) 
(right parenthesis) 
+ 
(plus symbol) 
(semicolon) 
(comma) 
(hyphen, minus symbol) 
-
(hyphen, minus symbol) 
(slash) 
(period, decimal point) 
(comma) 
/' 
(slash) 
(greater than) 
0 through 9 
(apostrophe) 
; 
(semicolon) 
(equal sign) 
< 
(less than) 
(quotation mark) 
= 
(equal sign) 
a through z (lower case) 
> 
(greater than) 
A through Z (upper case) 
A through Z (upper case 
0 through 9 
a through z (lower case) 
PSgiitfe 1 4 . 3 . Embedded Signs (ASCII versus EBCDIC) 
; h a r a c e e r 
C h a r a c t e r 
Dim 
C h a r a c t e r 
Digit 
+1 
1 
-1 
q 
+ 1 
A 
-1 
J 
+2 
2 
-2 
r 
+2 
B 
-2 
K 
+3 
3 
-3 
s 
+3 
C 
-3 
L 
+4 
4 
-4 
t 
+4 
D 
-4 
M 
+5 
5 
-5 
u 
+5 
E 
-5 
N 
+6 
6 
-6 
V 
+6 
F 
-6 
O 
+7 
7 
-7 
w 
+7 
G 
-7 
P 
+8 
8 
-8 
X 
+8 
H 
-8 
Q 
+9 
9 
-9 
y 
+9 
I 
-9 
R 
+0 
0 
-0 
p 
+0 
{ 
-0 
} 
and minus signs. T h e computer, however, embeds the sign within the low-order 
digit of the n u m b e r according to the table in Figure 14.3. The advantage of an 
embedded sign is that a position is saved in the storage m e d i u m ; for example, only 
one position is needed for a single-digit numeric field versus two (one for the digit 
and one for the sign) if the sign were stored separately. 
Figure 14,2 
EBCDIC and ASCII Collating Sequences 

Chapter 
14 — 
Sorting 
Igure 14.4 
Embedded Signs (ASCII versus EBCDIC)/II 
Name 
Account Balance 
John Doe 
$1,005 
Mary Smith 
$1,005CR 
Frank Coulter 
$2,000 
Erik Parker 
$2,000CR 
(a) Report 
John Doe 
1005 
Mary Smith 
lOOu 
Frank Coulter 
2000 
Erik Parker 
200z 
(b) Data (ASCII) 
John Doe 
100E 
Mary Smith 
100N 
Frank Coulter 
200( 
Erik Parker 
200} 
(c) Data (EBCDIC) 
The effect ofthe collating sequence is seen in Figure 14.4. Figure 14.4a contains 
a simple report in which John D o e and Mary Smith have positive and negative 
balances of $1,005. T h e data that produce the report are s h o w n in Figure 14.4b for 
ASCII a n d in Figure 14.4c for E B C D I C . T h e record for M a r y Smith contains a 
percent sign in the lower-order digit under ASCII according to the character for -5 in 
Figure 14.3a, but an upper case N under E B C D I C as indicated in Figure 14.3b. 
The optional SIGN clause (entered after the P I C T U R E clause) makes it possible 
to e m b e d the sign as the leading rather than the trailing character, and/or to establish 
a separate position for the sign. Consider: 
r 
i [LEADING ) r 
, 
SIGN IS 
{ 
\ S E P A R A T E CHARACTER 
[TRAILINGj
 
L 
J 
The vast majority of applications, however, e m b e d the sign as the trailing character 
(the default action taken by C O B O L ) as w a s illustrated in Figure 14.4. 
O O 
l i C 
L ~ 
T h e C O B O L requirements for implementing a sort center o n the S O R T statement. 
jSCr'f»i\* 
JVl!.vLli«Ati ~>n
 
m addition, you must be familiar with an SI) (sort description) and with the R E L E A S E 
and R E T U R N statements. 

COBOL 
Implementation 
The syntax for the S O R T statement is as follows: 
SORT file-name-1 
[WITH DUPLICATES IN ORDER] 
[COLLATING SEQUENCE IS alphabet-name] 
DESCENDING 
, 
, 
j 
[ASCENDING J
 
1 
J 
J 
[WITH DUPLICATES IN ORDER] 
INPUT PROCEDURE IS procedure - name - 1 JTHRU  
USING {fine-name-2J 
{THROUGH j 
procedure-name-2 
OUTPUT PROCEDURE IS procedure-name-3 
GIVING (file-name-3} 
THROUGH 
THRU 
procedure-name - 4 I 
Multiple sort keys are listed in the order of importance, with the major (primary) 
key listed first. Thus, the statement: 
SORT STUDENT-FILE 
ASCENDING KEY STUDENT-MAJOR 
DESCENDING KEY YEAR-IN-SCHOOL 
ASCENDING KEY STUDENT-NAME 
corresponds to the order of the keys in Figure 14.Id. ( S T U D E N T - M A J O R is the 
primary key, Y E A R - I N - S C H O O L is the secondary key, and S T U D E N T - N A M E is the 
tertiary key.) As can be seen from the general syntax, K E Y is an optional reserved 
word, so that the preceding statement could have been written as: 
SORT STUDENT-FILE 
ASCENDING STUDENT-MAJOR 
DESCENDING YEAR-IN-SCHOOL 
ASCENDING STUDENT-NAME 
W h e n consecutive keys have the s a m e sequence (both ascending or both 
descending), A S C E N D I N G (or D E S C E N D I N G ) need not be repeated. Hence, if it 
were necessary to obtain a master list of students in ascending order by year in 
school, a n d alphabetically within year, you could code: 
SORT STUDENT-FILE 
ASCENDING YEAR-IN-SCHOOL 
STUDENT-NAME 
The W I T H D U P L I C A T E S IN O R D E R phrase in the S O R T statement ensures 
that the sequence of records with duplicate keys in the output file will be identical 
to the sequence of the records in the input file. The phrase is illustrated in Figure 14.9, 
which appears later in the chapter. 
T h e C O L L A T I N G S E Q U E N C E clause allows y o u to change the collating 
sequence; that is, you can specify ASCII o n an I B M mainframe or E B C D I C o n a PC. 
(Implementation of an alternate collating sequence is less than straightforward, 
and you should consult an appropriate vendor manual if you wish to use one.) 

C
h
a
p
t
e
r 
1 4 
— 
Sorting 
The S O R T statement requires a choice between I N P U T P R O C E D U R E a n d 
USING, a n d between O U T P U T P R O C E D U R E a n d GIVING, resulting in four possible 
combinations: U S I N G / G I V I N G , U S I N G / O U T P U T P R O C E D U R E , I N P U T 
P R O C E D U R E / G I V I N G , a n d I N P U T P R O C E D U R E / O U T P U T P R O C E D U R E . T h e 
choice between the different options depends o n the specific application. (The 
chapter contains two listings for U S I N G / G I V I N G and I N P U T P R O C E D U R E / O U T P U T 
P R O C E D U R E . ) 
The difference between U S I N G a n d I N P U T P R O C E D U R E is that I N P U T 
P R O C E D U R E requires the programmer to do the I/O to a n d from the sort utility, 
whereas the U S I N G option does the I/O automatically. I N P U T P R O C E D U R E is thus 
a m o r e general technique in that it permits sorting o n a calculated field, a field not 
contained in the input record. Assume, for example, that a n employee record 
contains the present a n d previous salary, but not the percent of salary increase. 
The U S I N G option can sort o n either salary, but not o n the salary increase because 
the latter is a calculated field that it is not present in the input record. 
The I N P U T P R O C E D U R E also allows you to selectively pass records to the sort 
utility, a desirable practice in instances where only s o m e of the records in an input 
file are to appear in a subsequent report. Sorting is time consuming and thus, it is 
highly inefficient to sort an entire file only to eliminate records after sorting. It is far 
better to select the records prior to the sort by using the I N P U T P R O C E D U R E . 
The difference between O U T P U T P R O C E D U R E and G I V I N G is the status of 
the sorted file. T h e O U T P U T P R O C E D U R E uses a temporary work file, which 
disappears after the program ends so that the results of the sort are lost. T h e 
G I V I N G option creates a permanent file containing the sorted results that remains 
after the program has ended. 
SB i i i o s t t-i scription) 
The first file in the S O R T statement references the sort work file that was previously 
defined in an SD (Sort Description) statement in the Data Division. T h e S D is 
analogous to an F D except that it refers to a sort work file, rather than an ordinary 
file used for I/O. The S D has the general syntax: 
SD file-name-1 
[RECORD CONTAINS [integer-1 TO] integer-2 CHARACTERS] 
RELEAl- L 
RETURN 
The RELEASE and RETURN statements are required in the I N P U T a n d O U T P U T 
P R O C E D U R E , respectively. T h e R E L E A S E statement is analogous to a W R I T E 
statement a n d writes a record to the sort work file (the file defined in the SD). 
RELEASE record-name [FROM identifier] 
The R E L E A S E statement appears in the I N P U T P R O C E D U R E . T h e R E T U R N 
statement, o n the other hand, is analogous to a R E A D statement a n d appears in the 
O U T P U T ' P R O C E D U R E . It has the format: 

COBOL 
Implementation 
RETURN file-name [INTO identifier] 
[AT END imperative-statement-1] 
1N0T AT END imperative-statement-2] 
[END-RETURN] 
The R E T U R N statement reads a record from the sort work file (the file defined in the 
SD) for subsequent processing in the program. 
The S O R T statement and its related statements can be integrated into any 
C O B O L program. W e proceed to develop a typical application, with specifications 
in the usual format. In actuality w e present two separate programs, to illustrate 
both the I N P U T P R O C E D U R E / O U T P U T P R O C E D U R E and U S I N G / G I V I N G options 
of the S O R T statement. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
Sort Programs 
N a r r a t i v e : 
The specifications call for two programs to illustrate the USING/GIVING and INPUT 
PROCEDURE/OUTPUT PROCEDURE options of the SORT statement. The programs use 
the same data file but produce different reports. 
I n p u t F i l e ( s ) : 
SALES-FILE 
I n p u t R e c o r d L a y o u t : 
01 SALES-RECORD-IN. 
05 
SR-ACCOUNT-NUMBER 
PIC 9(6). 
05 
FILLER 
PIC X. 
05 
SR-NAME 
PIC X(15) 
05 
SR-SALES 
PIC S9(4) 
05 
FILLER 
PIC XX. 
05 
SR-C0MMISSI0N-PERCENT 
PIC V99. 
05 
FILLER 
PIC XX. 
05 
SR-L0CATI0N 
PIC X(15) 
05 
SR-REGI0N 
PIC X(ll) 
T e s t D a t a : 
See Figure 14.5. 
R e p o r t L a y o u t : 
See Figure 14.6a and 14.6b. The report layout—the heading, detail, and total lines—is 
the same for both programs, but the contents of the reports—the specific records as well 
as the sequence of those records—are different. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Develop two parallel programs, each of which processes a file of sales records and 
computes the commission due for each incoming transaction. The amount of the 
commission is equal to the sales amount times the commission percentage. 
2. The first program is to use the USING/GIVING option to produce a master list of all 
incoming records. The records are to be in sequence by region, location, and name 
as shown in Figure 14.6a. 
3. The second program is to use the INPUT PROCEDURE/OUTPUT PROCEDURE option 
and list only the transactions with a commission greater than $100. The records are to 
appear in decreasing order of commission as shown in Figure 14.6b. 

C
h
a
p
t
e
r 
1 4 
Sorting 
igare 14.5 
Test Data (ASCII Format) 
000069 BENWAY 
023q 10 CHICAGO 
MIDWEST 
000100 HUMMER 
OlOw 05 CHICAGO 
MIDWEST 
000101 CLARK 
1500 10 TRENTON 
NORTHEAST 
000104 CLARK 
0500 03 TRENTON 
NORTHEAST 
100000 JOHNSON 
030s 06 ST. PETERSBURG SOUTHEAST 
130101 CLARK 
3200 20 TRENTON 
NORTHEAST 
203000 HAAS 
8900 05 ST. LOUIS 
MIDWEST 
248545 JOHNSON 
0345 14 ST. PETERSBURG SOUTHEAST 
277333 HAAS 
009x 08 ST. LOUIS 
MIDWEST 
400000 JOHNSON 
070y 08 ST. PETERSBURG SOUTHEAST 
444333 ADAMS 
lOOv 01 NEW YORK 
NORTHEAST 
444444 FEGEN 
0100 02 ST. PETERSBURG SOUTHEAST 
475365 HAAS 
0333 05 ST. LOUIS 
MIDWEST 
476236 FEGEN 
037v 03 ST. PETERSBURG SOUTHEAST 
476530 BENWAY 
023u 05 CHICAGO 
MIDWEST 
555555 FEGEN 
0304 05 ST. PETERSBURG SOUTHEAST 
555666 ADAMS 
2003 
i r; 
C\) NEW YORK 
NORTHEAST 
576235 CLARK 
0100 03 TRENTON 
NORTHEAST 
583645 KARLSTROM 
0145 04 BALTIMORE 
NORTHEAST 
649356 HUMMER 
0345 05 CHICAGO 
MIDWEST 
694446 HUMMER 
0904 10 CHICAGO 
MIDWEST 
700039 MARCUS 
0932 10 BALTIMORE 
NORTHEAST 
750020 MARCUS 
0305 05 BALTIMORE 
NORTHEAST 
800396 KARLSTROM 
3030 09 BALTIMORE 
NORTHEAST 
878787 JOHNSON 
1235 12 ST. PETERSBURG SOUTHEAST 
987654 ADAMS 
2005 10 NEW YORK 
NORTHEAST 
988888 BENWAY 
0450 01 CHICAGO 
MIDWEST 
999340 BENWAY 
0334 30 CHICAGO 
MIDWEST 
Fi£-*-'& i 
Sorted Reports 
SALES ACTIVITY REPORT 
04/21/93 
PAGE 1 
REGION 
LOCATION 
NAME 
ACCOUNT i f 
SALES 
COMMISSION 
MIDWEST 
CHICAGO 
BENWAY 
000069 
$ 231-
$ 23-
MIDWEST 
CHICAGO 
BENWAY 
476530 
$ 235-
$ 12-
MIDWEST 
CHICAGO 
BENWAY 
988888 
$ 450 
$ 
5 
MIDWEST 
CHICAGO 
BENWAY 
999340 
$ 334 
$ 100 
MIDWEST 
CHICAGO 
HUMMER 
000100 
$ 107-
$ 
5-
MIDWEST 
CHICAGO 
HUMMER 
649356 
$ 345 
$ 17 
MIDWEST 
CHICAGO 
HUMMER 
694446 
$ 904 
$ 90 
MIDWEST 
ST. LOUIS 
HAAS 
203000 
$8,900 
$ 445 
MIDWEST 
ST. LOUIS 
HAAS 
277333 
$ 98-
$ 
8-
MIDWEST 
ST. LOUIS 
HAAS 
475365 
$ 333 
$ 17 
(a) By Region, Location, and Name (Ml Records) 

BOL 
I triple m 
entatian 
pur© 14.6 
(continued) 
SALES ACTIVITY REPORT 
04/21/93 
PAGE 3 
REGION 
LOCATION 
NAME 
ACCOUNT # 
SALES 
COMMISSION 
NORTHEAST 
TRENTON 
CLARK 
576235 
$ 100 
$ 
3 
SOUTHEAST 
ST. PETERSBURG 
FEGEN 
444444 
$ 100 
$ 
2 
SOUTHEAST 
ST. PETERSBURG 
FEGEN 
476236 
$ 376-
$ 11-
SOUTHEAST 
ST. PETERSBURG 
FEGEN 
555555 
$ 304 
$ 15 
SOUTHEAST 
ST. PETERSBURG 
JOHNSON 
100000 
$ 303-
$ 18-
SOUTHEAST 
ST. PETERSBURG 
JOHNSON 
248545 
$ 345 
$ 48 
SALES ACTIVITY REPORT 
04/21/93 
PAGE 2 
REGION 
LOCATION 
NAME 
ACCOUNT t t 
SALES 
COMMISSION 
NORTHEAST 
BALTIMORE 
KARLSTROM 
583645 
$ 145 
$ 
6 
NORTHEAST 
BALTIMORE 
KARLSTROM 
800396 
$3,030 
$ 273 
NORTHEAST 
BALTIMORE 
MARCUS 
700039 
$ 932 
$ 93 
NORTHEAST 
BALTIMORE 
MARCUS 
750020 
$ 305 
$ 15 
NORTHEAST 
NEW YORK 
ADAMS 
444333 
$1,005-
$ 10-
NORTHEAST 
NEW YORK 
ADAMS 
555666 
$2,003 
$ 401 
NORTHEAST 
NEW YORK 
ADAMS 
987654 
$2,005 
$ 201 
NORTHEAST 
TRENTON 
CLARK 
000101 
$1,500 
$ 150 
NORTHEAST 
TRENTON 
CLARK 
000104 
$ 500 
$ 15 
NORTHEAST 
TRENTON 
CLARK 
130101 
$3,200 
$ 640 
(a) By Region, Location, and Name (Aft Records) 
SALES ACTIVITY REPORT 
04/21/93 
PAGE 1 
REGION 
LOCATION 
NAME 
ACCOUNT # 
SALES 
COMMISSION 
NORTHEAST 
TRENTON 
CLARK 
130101 
$3,200 
$ 640 
MIDWEST 
ST. LOUIS 
HAAS 
203000 
$8,900 
$ 445 
NORTHEAST 
NEW YORK 
ADAMS 
555666 
$2,003 
$ 401 
NORTHEAST 
BALTIMORE 
KARLSTROM 
800396 
$3,030 
$ 273 
NORTHEAST 
NEW YORK 
ADAMS 
987654 
$2,005 
$ 201 
NORTHEAST 
TRENTON 
CLARK 
000101 
$1,500 
$ 150 
SOUTHEAST 
ST. PETERSBURG 
JOHNSON 
878787 
$1,235 
$ 148 
*** COMPANY TOTAL = 
$ 21,873 
$ 2,258 
>) By Decreasing Commisfon (Commission > $100} 

Chapter 
14 
Sorting 
v v , W t , ^ t t v vl 
T h e specifications are similar to those of any other reporting program that requires 
O 
a combination of heading, detail, a n d total lines. T h e hierarchy chart a n d 
pseudocode for the U S I N G / G I V I N G option are s h o w n in Figures 14.7 a n d 14.8, 
respectively. T h e hierarchy chart contains m a n y of the modules found in earlier 
programs—for example, G E T - T O D A Y S - D A T E , WRITE-HEADING-1.1 N F S , a n d 
WRITE-DETAIL-LINE. In addition, it contains the module SORT-SALES-FILE to 
sequence records in the sales file. 
Figure 14.7 
Hierarchy Chart (USING/GIVING) 
PREPARE 
COMMISION 
REPORT 
GET 
TODAYS 
DATE 
PROCESS 
SORTED 
RECORDS 
WRITE 
COMPANY 
TOTAL 
CALCULATE 
COMMISSION 
igure 14.8 
Pseudocode (USING/GIVING) 
Sort Sales File 
i 
Open Sorted Sales File, Print File 
[ 
Get today's date 
DO WHILE sorted data remains 
, — READ Sorted Sales File 
AT END 
Indicate no more data 
| 
NOT AT END 
| 
Calculate commission 
j 
— IF line count greater than lines per page 
I 
Initialize line count to 1 
j 
Increment page count 
j 
i 
Write heading lines 
j 
| 
END-IF 
j 
1 
Write detail line 
[ 
i 
i 
I 
Increment company total 
J 
1 
END READ 
j 
ENDDO 
( 
Write company total 
j 
Close files 
I 
Stop run 
J 

USING/GIVING 
Option 
The pseudocode in Figure 14.8 contains a sort statement prior to the m a i n 
1 U U | J , 
W l l l l . l l 
U U l l i a i l l S 
L l l C 
i l l - l l l l C : 
p C l l U l l l l 
C111CI 
1 C U 3 U - I . U I I U J 1 1 U 1 I 
L t l L l l l l . i l 
U j L U 
1 1 1 t i l l 
other programs. The sales commission is calculated for each incoming record, a 
detail line is written, a n d the c o m p a n y total is incremented. T h e pseudocode 
also contains the logic to implement a page heading routine as explained 
previously in Chapter 9. 
The U S I N G / G I V I N G format is illustrated in Figure 14.9. The S O R T statement 
in lines 149-155 references three files—SORT-WQRK-FTLE, SALES-FILE, and, 
SORTED-SALES-FILE—each of which has the identical record layout. The S O R T 
statement implicitly opens SALES-FILE and reads every record in that file, releasing 
each record as it is read to the sort work file. It then sequences the sort work file 
according to designated keys and writes the newly ordered file to S O R T E D - S A L E S -
FILE. The programmer does not open or close S O R T - W O R K - F I L E or SALES-FILE as 
this is done by the S O R T statement. 
SORT Program (USING/GIVING) 
1 
2 
i 
-» 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
S0RT1. 
AUTHOR. 
CVV. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT SALES-FILE 
ASSIGN TO 'A:\CHAPTR14\S0RTIN.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
S o f„ 
ASSIGN TO PRINTER. 
/ 
' 
SELECT SORT-WORK-FILE 
ASSIGN TO 'A:\CHAPTR14\S0RWK.DAT' 
SELECT SORTED-SALES-FILE 
ASSIGN TO 'A:\CHAPTR14\S0RT0UT.DAT'  
ORGANIZATION IS LINE SEQUENTIAL. 
DATA DIVISION. 
FILE SECTION. 
FD SALES-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SALES-RECORD. 
01 SALES-RECORD 
PIC X(58). 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
01 PRINT-LINE 
PIC X(132). 
SD SORT-WORK-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SORT-RECORD. 
01 S0r£-REC0RJj\. 
05 SORT-ACCOUNT-NUMBER 
PIC 9(6), 

.9 
(continued) 
05 FILLER 
PIC X. 
05 SORT-NAME 
PIC X(15).( 
05 FILLER 
PIC X(10). 
05 SORT-LOCATION 
PIC X(15). 
05 SORT-REGION 
PIC Xfllh 
FD SORTED-SALES-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SORTED-SALES-RECORD. 
01 SORTED-SALES-RECORD 
PIC X(58). 
WORKING-STORAGE SECTION. 
01 FILLER 
PIC X(14) 
VALUE 'WS BEGINS HERE
1. 
01 SALES-RECORD-IN. 
05 SR-ACCOUNT-NUMBER 
PIC 9(6). 
05 FILLER 
PIC X. 
05 SR-NAME 
PIC X(15) 
05 SR-SALES 
PIC S9(4) 
05 FILLER 
PIC XX. 
05 SR-COMMISSION-PERCENT 
PIC V99. 
05 FILLER 
PIC XX. 
05 SR-LOCATION 
PIC X(15) 
05 SR-REGION 
PIC X(ll) 
01 TODAYS-DATE-AREA. 
05 TODAYS-YEAR 
PIC 99. 
05 TODAYS-MONTH 
PIC 99. 
05 TODAYS-DAY 
PIC 99. 
01 PROGRAM-SWITCHES. 
05 DATA-REMAINS-SWITCH 
PIC X(3) 
VALUE 'YES' 
88 NO-DATA-REMAINS 
VALUE 'NO'. 
01 PAGE-AND-LINE-COUNTERS. 
05 LINE-COUNT 
PIC 9(2) 
VALUE 11. 
05 PAGE-COUNT 
PIC 9(2) 
VALUE ZEROS. 
05 LINES-PER-PAGE 
PIC 9(2) 
VALUE 10. 
01 INDIVIDUAL-CALCULATIONS. 
05 IND-COMMISSION 
PIC S9(4). 
01 COMPANY-TOTALS. 
05 COMPANY-SALES-TOT 
05 COMPANY-COMM-TOT 
PIC S9(6) 
PIC S9(6) 
VALUE ZEROES 
VALUE ZEROES 
01 HDG-LINE-ONE. 
05 FILLER 
05 FILLER 
PIC X(25) 
PIC X(21) 
VALUE SPACES 

USING/GIVING 
Option 
(continued) 
84 
VALUE 'SALES ACTIVITY REPORT'. 
85 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
86 
05 HDG-DATE 
PIC X(8). 
87 
05 FILLER 
PIC X(10) 
VALUE SPACES. 
88 
05 FILLER 
PIC X(5) 
VALUE 'PAGE '. 
89 
05 HDG-PAGE 
PIC 29. 
90 
05 FILLER 
PIC X(53) 
VALUE SPACES. 
91 
92 
01 HDG -LINE-TWO. 
93 
05 FILLER 
PIC X(7) 
VALUE ' REGION'. 
94 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
95 
05 FILLER 
PIC X(8) 
VALUE 'LOCATION'. 
96 
05 FILLER 
PIC X(ll) 
VALUE SPACES. 
97 
05 FILLER 
PIC X(4) 
VALUE 'NAME'. 
98 
05 FILLER 
PIC X(10) 
VALUE SPACES. 
99 
05 FILLER 
PIC X{11) 
VALUE 'ACCOUNT t 
100 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
101 
05 FILLER 
PIC X(5) 
VALUE 'SALES'. 
102 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
103 
05 FILLER 
PIC X(10) 
VALUE 'COMMISSION 
104 
05 FILLER 
PIC X(53) 
VALUE SPACES. 
105 
i r\c 
1 U U 
A1 
r\CTATI 
i 
TMC 
\JX 
U L I H i L - L i t l L . 
107 
05 DET-REGION 
PIC X(ll). 
108 
05 FILLER 
PIC X 
VALUE SPACES. 
109 
05 DET-LOCATION 
PIC X(15). 
110 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
111 
05 DET-NAME 
PIC X(15). 
112 
05 FILLER 
PIC X(2) 
VALUE SPACES. 
113 
05 DET-ACCOUNT-NUMBER 
PIC 9(6). 
114 
05 FILLER 
PIC X(5) 
VALUE SPACES. 
115 
05 DET-SALES 
PIC $Z,ZZ9-
116 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
117 
05 DET-COMMISSION 
PIC $Z,ZZ9-
118 
05 FILLER 
PIC X(50) 
VALUE SPACES. 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
[132] 
01 COMPANY-TOTAL-LINE. 
05 FILLER 
FILLER 
05 
05 
05 
05 
05 
PIC X(31) 
PIC X(25) 
VALUE SPACES. 
VALUE '*** COMPANY TOTAL = '. 
COMPANY-SALES-TOTAL 
PIC $Z(3),ZZ9-. 
FILLER 
PIC X(5) 
VALUE SPACES. 
COMPANY-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
FILLER 
PIC X(51) 
VALUE SPACES. 
PROCEDURE DIVISION. 
100-PREPARE-COMMISSION-REPORT. 
PERFORM 210-SORT-SALES-RECORDS. 
OPEN INPUT SORTED-SALES-FILE 
-wfpw>MNT-Ffnn 

Chapter 
14 — 
Sorting 
l 
134 
PERFORM 230-GET-T0DAYS-DATE. 
j 
135 
PERFORM UNTIL NO-DATA-REMAINS 
I 
136 
READ SORTED-SALES-FILE INTO SALES-RECORD-IN 
i 
137 
AT END 
I 
138 
MOVE 'NO' TO DATA-REMAINS-SWITCH 
I 
139 
NOT AT END 
I 
140 
PERFORM 250-PROCESS-SORTED-RECORDS 
141 
END-READ 
| 
142 
END-PERFORM. 
j 
143 
PERFORM 290-WRITE-COMPANY-TOTAL. 
I 
144 
CLOSE SORTED-SALES-FILE 
j 
145 
PRINT-FILE. 
146 
STOP RUN. 
147 
148 
210-S0RT-SALES-REC0RDS. 
149 
; SORT SORT - WORK - FIL E 
150 
! 
ASCENDING KEY SORT-REGION 
151 
| 
SORT-LOCATION ! 
152 
\ 
SORT-NAME 
; 
[ 
153 
j 
WITH DUPLICATES IN ORDER 
j 
154 
| 
USING SALES-FILE 
j 
155 
| 
GmNG SORTED-SALES-FILE^ 
j 
i 
156 
1 
157 
230-GET-TODAYS-DATE. 
| 
158 
ACCEPT TODAYS-DATE-AREA FROM DATE. 
159 
STRING TODAYS-MONTH '/' TODAYS-DAY '/' TODAYS-YEAR 
160 
DELIMITED BY SIZE INTO HDG-DATE. 
161 
j 
162 
250-PROCESS-SORTED-RECORDS. 
I 
163 
PERFORM 310-CALCULATE-COMMISSION. 
j 
164 
IF LINE-COUNT > LINES-PER-PAGE 
[ 
165 
PERFORM 330-WRITE-HEADING-LINES 
i 
166 
END-IF. 
| 
167 
PERFORM 350-WRITE-DETAIL-LINE. 
168 
PERFORM 370-INCREMENT-COMPANY-TOTAL. 
169 
170 
290-WRITE-COMPANY-TOTAL. 
171 
MOVE COMPANY-SALES-TOT TO COMPANY-SALES-TOTAL. 
172 
MOVE COMPANY-COMM-TOT TO COMPANY-COMM-TOTAL. 
173 
WRITE PRINT-LINE FROM COMPANY-TOTAL-LINE 
174 
AFTER ADVANCING 2 LINES. 
I 175 
I 
176 
310-CALCULATE-COMMISSION. 
177 
COMPUTE IND-COMMISSION ROUNDED = 
178 
SR-SALES * SR-COMMISSION-PERCENT 
179 
SIZE ERROR DISPLAY 'SIZE ERROR ON COMMISSION FOR 
| 
180 
SR-NAME 
[ 
181 
END-COMPUTE. 
| 182 
( 
183 
330-WRITE-HEADING-LINES. 
Figure i 4 . 8 
(continued) 

INPUT 
PROCEDURE/OUTPUT 
PROCEDURE 
Option 
(continued) 
184 
MOVE 1 TO LINE-COUNT. 
185 
ADD 1 TO PAGE-COUNT. 
186 
MOVE PAGE-COUNT TO HDG-PAGE. 
187 
WRITE PRINT-LINE FROM HDG-LINE-ONE 
188 
AFTER ADVANCING PAGE. 
189 
WRITE PRINT-LINE FROM HDG-LINE-TWO 
190 
AFTER ADVANCING 2 LINES. 
191 
192 
350-WRITE-DETAIL-LINE. 
193 
MOVE SR-REGION TO DET-REGION. 
194 
MOVE SR-LOCATION TO DET-LOCATION. 
195 
MOVE SR-NAME TO DET-NAME. 
196 
MOVE SR-ACCOUNT-NUMBER TO DET-ACCOUNT-NUMBER. 
197 
MOVE SR-SALES TO DET-SALES. 
198 
MOVE IND-COMMISSION TO DET-COMMISSION. 
199 
WRITE PRINT-LINE FROM DETAIL-LINE. 
200 
ADD 1 TO LINE-COUNT. 
201 
202 
370-INCREMENT-COMPANY-TOTAL. 
203 
ADD SR-SALES TO COMPANY-SALES-TOT. 
204 
ADD IND-COMMISSION TO COMPANY-COMM-TOT. 
Three keys—SORT-REGION, SORT-LOCATION, a n d SORT-NAME—are 
specified in lines 150-152 as the primary, secondary, and tertiary key, respectively. 
The WITH DUPLICATES IN ORDER phrase keeps records with duplicate keys in the 
same s e q u e n c e as the input file. Note, therefore, that since the input file in Figure 
14.5 is already in sequence by account number, records with the s a m e region, 
location, and n a m e will b e in sequence by account number as well. 
After the file has b e e n sorted, control returns to the OPEN statement in line 
132, which o p e n s SORTED-SALES-FILE as input and PRINT-FILE as output. The 
remainder of the Procedure Division reads records from the sorted file in order to 
produce the report of Figure 14.6a. Its logic parallels that of any other reporting 
program that produces a combination of heading, detail, and total lines. 
I h e hierarchy chart to i m p l e m e n t the INPUT PROCEDURE/OUTPUT PROCEDURE 
option is s h o w n in Figure 14.10. It contains the identical m o d u l e s as its predecessor 
for the USING/GIVING option, but the placement of the modules (the subordinate 
relationships and associated span of control) is significantly different. 
The m o s t obvious change is the sort m o d u l e itself, w h i c h sits atop the hierarchy 
chart in Figure 14.10, but which is subordinate to PREPARE-COMMISSION-REPORT 
in Figure 14.7. This is because the SORT statement effectively drives the INPUT 
PROCEDURE/OUTPUT PROCEDURE option as it calls the respective procedures. A 
s e c o n d major change is the placement of CALCULATE-COMMISSION, which is 
subordinate to the sort m o d u l e in Figure 14.10, because the c o m m i s s i o n is calculated 

C
h
a
p
t
e
r 
14 — 
Sort 
in ( 
jure 14.10 
Hierarchy Chart (INPUT PROCEDURE/OUTPUT PROCEDURE) 
SORT 
SALES 
RECORDS 
CALCULATE 
COMMISSION 
GET 
TODAYS 
DATE 
PREPARE 
COMMISSION 
REPORT 
PROCESS 
SORTED 
RECORDS 
WRITE 
DETAIL 
LINE 
WRITE 
COMPANY 
TOTAL 
INCREMENT 
COMPANY 
TOTAL 
prior to sorting, and only those records with sufficient commission are written to 
the sort work file. In the earlier hierarchy chart, however, every record in the 
incoming file appears in the report; the commission is calculated after sorting so 
that C A L C U L A T E - C O M M I S S I O N is subordinate to P R O C E S S - S O R T E D - R E C O R D S . 
The pseudocode in Figure 14.11 contains two loops, whereas its predecessor 
in Figure 14.8 contained only one. This is because the U S I N G / G I V I N G option does 
the I/O for the programmer a n d thus is transparent to the programmer. However, 
I N P U T P R O C E D U R E / O U T P U T P R O C E D U R E requires the programmer to do the 
I/O a n d this is reflected in the pseudocode. T h e initial loop opens the (unsorted) 
sales file, calculates the commission for each incoming record, then selectively 
releases records to the sort work file. The second loop (which corresponds to the 
only loop in Figure 14.8) reads records from the sorted file and prepares the report. 
The program containing the I N P U T P R O C E D U R E / O U T P U T P R O C E D U R E 
format is illustrated in Figure 14.12. Explanation begins with the S O R T statement 
itself, lines 125-128, which references a sort work file defined in a n SI) in lines 27-37 
of the Data Division. S O R T - W O R K - F I L E is to be sorted o n S O R T - C O M M I S S I O N , a 
calculated field that is not contained in the incoming sales record. 
The I N P U T P R O C E D U R E / O U T P U T P R O C E D U R E involves several implicit 
transfers of control as follows: 
1. Control passes from the S O R T statement to the I N P U T P R O C E D U R E , which 
reads records from an input file and builds the sort work file. 
2. W h e n the I N P U T P R O C E D U R E is finished, control passes to the sort utility, 
which sorts the work file created by the I N P U T P R O C E D U R E . 

INPUT 
PROCEDURE/OUTPUT 
PROCEDURE 
Option 
Figure 14.11 
Pseudocode (INPUT PROCEDURE/OUTPUT PROCEDURE) 
I 
' 
" 
— — 
— 
- - - -
Input Procedure 
) 
Open Input Sales File 
| 
,— DO WHILE data remains 
I 
,— READ Sales File 
| 
AT END 
I 
Indicate no more data 
I 
NOT AT END 
Calculate commission 
— 
IF commission greater than 100 
RELEASE sort record 
END-IF 
- 
END-READ 
...... ENDDO 
Sort utility takes control 
Output Procedure 
Open Output Print File 
Get today's date 
— DO WHILE sorted data remains 
1 
r - RETURN Sorted Sales File 
| 
| 
AT END 
[ 
Indicate no more data 
| 
NOT AT END 
i 
i — IF line count greater than lines per page 
Initialize line count to 1 
j 
Increment page count 
i 
Write heading lines 
I 
— 
END-IF 
| 
Write detai1 line 
| 
Increment company total 
I 
!—- END RETURN 
I
 
1 — ENDDO 
j 
Write company total 
| 
Close files 
[ 
Stop run 
1 
L _ 
_.. 
_ 
. 
i 
3. After the sort has taken place, control passes to the O U T P U T P R O C E D U R E , 
which reads records from the sorted file in order to produce the required 
report. 
4. W h e n the O U T P U T P R O C E D U R E is finished, control returns to the 
statement directly (physically) following the actual S O R T statement. 
The I N P U T P R O C E D U R E is the paragraph 1 0 0 - C A L C U I A T E - C O M M I S S I O N 
and extends from lines 131 to 148. It begins by opening SALES-FILE, after which the 
combination of the in-line P E R F O R M a n d false condition branch processes records 
until the file is empty. The commission is calculated for each incoming record, a n d 

C
h
a
p
t
e
r 
1 4 
— 
Sorting 
Figu 
RT Program (INPUT PROCEDURE/OUTPUT PROCEDURE) 
I I 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
S0RT2. 
3 
/i 
AUTHOR. 
CVV. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT SALES-FILE 
ASSIGN TO 'A:\CHAPTR14\S0RTIN 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
SELECT SORT-WORK-FILE 
13 
ASSIGN TO 'A:\CHAPTR14\S0RTWK.DAT'. 
14 
15 
DATA DIVISION. 
16 
FILE SECTION. 
17 
FD SALES-FILE 
18 
RECORD CONTAINS 57 CHARACTERS 
19 
DATA RECORD IS SALES-RECORD. 
20 
01 SALES-RECORD 
PIC X(57). 
21 
22 
FD PRINT-FILE 
O Q 
L, _> 
Demon, rnMTATwe n o ruADAncnc 
24 
DATA RECORD IS PRINT-LINE. 
25 
01 PRINT-LINE 
PIC X(132). 
26 
27 
SD SORT-WORK-FILE 
i 
28 
RECORD CONTAINS 62 CHARACTERS 
29 
L_ 
DATA RECORD IS SORT-RECORD. 
30 
01 SORT-RECORD. 
31 
05 
SORT-ACCOUNT-NUMBER 
PIC 9(6). 
32 
05 FILLER 
PIC X. 
33 
05 SORT-NAME 
PIC X(15). 
34 
05 FILLER 
PIC X(10). 
35 
05 SORT-LOCATION 
PIC X(15). 
36 
05 SORT-REGION 
PIC X(ll). 
37 
105 
SORT-COMMISSION 
PIC S 9 ( 4 ) . f \ 
38 
C 
39 
WORKING-STORAGE SECTION. 
40 
01 FILLER 
PIC X(14) 
41 
VALUE 'WS BEGINS HERE'. 
42 
43 
01 SALES-RECORD-IN. 
44 
05 SR-ACCOUNT-NUMBER 
PIC 9(6). 
45 
05 FILLER 
PIC X. 
46 
05 SR-NAME 
PIC X(15). 
47 
05 SR-SALES 
PIC S9(4). 
48 
05 FILLER 
PIC XX. 
49 
05 
SR-COMMISSION-PERCENT 
PIC V99. 
50 
05 FILLER 
PIC XX. 
51 
05 SR-LOCATION 
PIC X(15). 

INPUT 
PROCEDURE/OUTPUT 
PROCEDURE 
Option 
(continued) 
52 
05 SR-REGION 
PIC X(ll). 
53 
05 SR-C0MMISSI0N 
PIC S9{4). 
54 
55 
01 TODAYS-DATE-AREA. 
56 
05 TODAYS-YEAR 
PIC 99. 
57 
05 TODAYS-MONTH 
PIC 99. 
58 
05 TODAYS-DAY 
PIC 99. 
59 
60 
01 PROGRAM-SWITCHES. 
61 
05 
DATA-REMAINS-SWITCH 
PIC X(3) 
VALUE 
62 
88 
NO-DATA-REMAINS 
VALUE 
63 
05 
SORTED-DATA-REMAINS-SW 
PIC X(3) 
VALUE 
64 
88 
NO-SORTED-DATA-REMAINS 
VALUE 
65 
66 
01 PAGE-AND-LINE-COUNTERS. 
67 
05 
LINE-COUNT 
PIC 9(2) 
VALUE 
68 
05 PAGE-COUNT 
PIC 9(2) 
VALUE 
69 
05 
LINES-PER-PAGE 
PIC 9(2) 
VALUE 
70 
71 
01 COMPANY-TOTALS. 
72 
05 
COMPANY-SALES-TOT 
PIC S9(6) VALUE 
73 
05 
COMPANY-COMM-TOT 
PIC S9(6) VALUE 
74 
75 
01 HDG-LINE-ONE. 
76 
05 FILLER 
PIC X(25) VALUE 
77 
05 FILLER 
PIC X(21) 
78 
VALUE 'SALES ACTIVITY REPORT'. 
79 
05 FILLER 
PIC X(8) 
VALUE 
80 
05 HDG-DATE 
PIC X(8). 
81 
05 FILLER 
PIC X(10) VALUE 
82 
05 FILLER 
PIC X(5) 
VALUE 
83 
05 HDG-PAGE 
PIC Z9. 
84 
05 FILLER 
PIC X(53) VALUE 
85 
86 
01 HDG-LINE-TWO. 
87 
05 FILLER 
PIC X(7) 
VALUE 
88 
05 FILLER 
PIC X(5) 
VALUE 
89 
05 FILLER 
PIC X(8) 
VALUE 
90 
05 FILLER 
PIC X(ll) VALUE 
91 
05 FILLER 
PIC X(4) 
VALUE 
92 
05 FILLER 
PIC X(10) VALUE 
93 
05 FILLER 
PIC X(ll) VALUE 
94 
05 FILLER 
PIC X(5) 
VALUE 
95 
05 FILLER 
PIC X(5) 
VALUE 
96 
05 FILLER 
PIC X(3) 
VALUE 
97 
05 FILLER 
PIC X(10) VALUE 
98 
05 FILLER 
PIC X(53) VALUE 
99 
100 
01 DETAIL-LINE. 
101 
05 DET-REGION 
PIC X(ll). 
102 
05 FILLER 
PIC X 
VALUE 
PAGE 
' REGION
1. 
SPACES. 
'LOCATION'. 
SPACES. 
'NAME'. 
SPACES. 
'ACCOUNT #' 
SPACES. 
'SALES'. 
SPACES. 
'COMMISSION 
SPACES. 

C
h
a
p
t
e
r 
1 4 
Sortinc 
(continued) 
05 DET-L0CATI0N 
05 FILLER 
05 DET-NAME 
05 FILLER 
05 
DET-ACCOUNT-NUMBER 
05 FILLER 
05 DET-SALES 
05 FILLER 
05 
DET-COMMISSION 
05 FILLER 
PIC X(15). 
PIC X(3) 
VALUE SPACES. 
PIC X(15). 
PIC X(2) 
VALUE SPACES. 
PIC 9(6). 
PIC X(5) 
VALUE SPACES. 
PIC $Z,ZZ9-. 
PIC X(7) 
VALUE SPACES. 
PIC $Z,ZZ9-. 
PIC X(50) 
VALUE SPACES. 
01 COMPANY-TOTAL-LINE. 
05 FILLER 
05 FILLER 
05 
05 
05 
05 
PIC X(31) 
PIC X(25) 
VALUE 
COMPANY TOTAL 
VALUE SPACES. 
COMPANY-SALES-TOTAL 
FILLER 
COMPANY-COMM-TOTAL 
FILLER 
PIC $Z(3),ZZ9-. 
PIC X(5) 
VALUE SPACES. 
PIC $Z(3),ZZ9-. 
PIC X(51) 
VALUE SPACES. 
PROCEDURE DIVISION. 
0000-SORT-SALES-RECORDS. 
DESCENDING KEY SORT-COMMISSION 
INPUT PROCEDURE 100-CALCULATE-COMMISSION 
OUTPUT PROCEDURE 200-PREPARE-COMMISSION-REPORT. 
STOPRUN. 
INPUT 
zDUF 
|100-CALCULATE-COMMISSION. 
' 
OPlN^NPUrSALES^FILE^ 
PERFORM UNTIL NO-DATA-REMAINS 
READ SALES-FILE INTO SALES-RECORD-IN 
AT END 
MOVE 'NO' TO DATA-REMAINS-SWITCH 
NOT AT END 
COMPUTE SR-COMMISSION ROUNDED = 
SR-SALES * SR-COMMISSION-PERCENT 
SIZE ERROR DISPLAY 'ERROR ON COMMISSION FOR 
SR-NAME 
END-COMPUTE 
/' 
I IF SR-COMMISSION > 100 
RELEASE SORT-RECORD FROM SALES-RECORD-IN 
END-IF 
END-READ 
END-PERFORM. 
CLOSE SALES-FILE. 
! 200-PREPARE-COMMISSION-REPORT. 
OPEN OUTPUT PRINT-FILE. 
PERFORM 230-GET-TODAYS-DATE. 
::EDUR 

INPUT 
PROCEDURE/OUTPUT 
PROCEDURE 
Option 
(continued) 
j 
153 
PERFORM UNTIL NO-SORTJiD-DATA-REMAINS 
154 
S RETURN "SORT-WORK-TTLE TNTO SALES - RECORD - IN ~ j 
I 
155 
i 
AT END 
I 
156 
1 
MOVE 'NO' TO SORTED-DATA-REMAINS-SW |^ 
1 
157 
j 
NOT AT END 
f 
| 
158 
PERFORM 250-PROCESS-SORTED-RECORDS j 
| 
159 
| END-RETURN^ 
J 
| 
160 
END-PERFORM~ 
i 
161 
PERFORM 290-WRITE-C0MPANY-T0TAL. 
[ 
162 
CLOSE PRINT-FILE. 
1
 
1 6 3 
I 
164 
230-GET-TODAYS-DATE. 
| 
165 
ACCEPT TODAYS-DATE-AREA FROM DATE. 
166 
STRING TODAYS-MONTH '/' TODAYS-DAY '/' TODAYS-YEAR 
167 
DELIMITED BY SIZE INTO HDG-DATE. 
j 
168 
j 
169 
250-PROCESS-SORTED-RECORDS. 
1 
170 
IF LINE-COUNT > LINES-PER-PAGE 
j 
171 
PERFORM 330-WRITE-HEADING-LINES 
| 
172 
END-IF. 
I 
173 
PERFORM 350-WRITE-DETAIL-LINE. 
| 
174 
PERFORM 370-INCREMENT-COMPANY-TOTAL. 
I
 
1 7 5 
j 
176 
290-WRITE-COMPANY-TOTAL. 
177 
MOVE COMPANY-SALES-TOT TO COMPANY-SALES-TOTAL, 
j 
178 
MOVE COMPANY-COMM-TOT TO COMPANY-COMM-TOTAL. 
179 
WRITE PRINT-LINE FROM COMPANY-TOTAL-LINE 
180 
AFTER ADVANCING 2 LINES. 
181 
j 
182 
330-WRITE-HEADING-LINES. 
| 
183 
MOVE 1 TO LINE-COUNT. 
| 
184 
ADD 1 TO PAGE-COUNT. 
| 
185 
MOVE PAGE-COUNT TO HDG-PAGE. 
! 
186 
WRITE PRINT-LINE FROM HDG-LINE-ONE 
j 
187 
AFTER ADVANCING PAGE. 
j 
188 
WRITE PRINT-LINE FROM HDG-LINE-TWO 
! 
189 
AFTER ADVANCING 2 LINES. 
| 
190 
j 
191 
350-WRITE-DETAIL-LINE. 
j 
192 
MOVE SR-REGION TO DET-REGION. 
j 
193 
MOVE SR-LOCATION TO DET-LOCATION. 
' 
194 
MOVE SR-NAME TO DET-NAME. 
195 
MOVE SR-ACCOUNT-NUMBER TO DET-ACCOUNT-NUMBER. 
196 
MOVE SR-SALES TO DET-SALES. 
197 
MOVE SR-COMMISSION TO DET-COMMISSION. 
198 
WRITE PRINT-LINE FROM DETAIL-LINE. 
199 
ADD 1 TO LINE-COUNT. 
200 
201 
370-INCREMENT-COMPANY-TOTAL. 
202 
ADD SR-SALES TO COMPANY-SALES-TOT. 
203 
ADD SR-COMMISSION TO COMPANY-COMM-TOT. 

Chapter 
14 — 
Sorting 
only those records with a commission greater than $100 are written (released) to the 
sort work file. The I N P U T P R O C E D U R E ends by closing SALES-FILE, after which 
control passes to the sort utility. The sort work file is neither opened nor closed 
explicitly by the programmer as that is done by the sort utility. 
The O U T P U T P R O C E D U R E is the paragraph 2 0 0 - P R E P A R E - C O M M I S S I O N -
R E P O R T a n d extends from lines 150 to 162. It begins by opening PRINT-FILE, after 
which the combination of the in-line P E R F O R M a n d false-condition branch 
processes records until the sort work file is empty. T h e report is produced by using 
m a n y of the identical paragraphs from the earlier program. T h e O U T P U T 
P R O C E D U R E ends by closing PRINT-FILE after which control passes to the S T O P 
R U N statement in line 129 immediately under the S O R T statement. 
The differences between the two C O B O L programs is highlighted by comparing the 
generated reports in Figure 14.6. Figure 14.6a was produced by the USING/GIVING 
option and lists all records in sequence by region, location, and name. Figure 14.6b lists 
a subset of selected 
records in decreasing order of commission, a calculated field. The 
following are other differences between the two programs: 
1. Figure 14.9 sorts o n three fields, S O R T - R E G I O N , S O R T - L O C A T I O N , and S O R T -
N A M E , each of which is contained in the incoming record. Figure 14.12 sorts 
on S O R T - C O M M I S S I O N , a calculated field not found in the incoming record. 
2. T h e U S I N G option in Figure 14.9 does the I/O for the programmer; that is, it 
opens SALES-FILE, reads and writes every record from this file to the sort 
work file, then closes SALES-FILE w h e n the sort work file has been created. 
3. The I N P U T P R O C E D U R E in Figure 14.12 requires the programmer to do the 
I/O; that is, the programmer has to open SALES-FILE, read records from the 
input file a n d write (release) t h e m to the sort work file, then close the input 
file. 
4. The G I V I N G option in Figure 14.9 creates a permanent file, SORTED-SALES-
FILE, that contains the results of the sort; the O U T P U T P R O C E D U R E in Figure 
14.12 creates a temporary work file that disappears w h e n the program 
terminates. T h e G I V I N G option uses an extra file; that is, four files are present 
in Figure 14.9 versus three in Figure 14.12. 
5. The O U T P U T P R O C E D U R E uses a R E T U R N statement in lines 154-159 because 
the sorted records are read from the sort work file. This is in contrast to the 
R E A D statement in lines 136-141 of Figure 14.9, which reads records from 
SORTED-SALES-FILE, an ordinary file defined in an F D . 
6. T h e record lengths in Figure 14.9 of SORT-FILE, SALES-FILE, and S O R T E D -
SALES-FILE, must be the s a m e (58 characters). T h e record lengths of S O R T -
FILE a n d SALES-FILE in Figure 14.12 are different. 
Merging files is a special case of sorting. T h e MERGE statement takes several input 
files, which have identical record formats and which have been sorted in the same 
sequence, a n d combines t h e m into a single output file (device type and blocking 
m a y differ for the various files). A merge achieves the s a m e results as sorting, but 

m o r e efficiently; 
that is, the several input files to a m e r g e c o u l d also be 
concatenated as a single input file to a sort. The advantage of the merge over a 
sort is in execution speed; a merge will execute faster because its logic realizes 
that the several input files are already in order. 
The format of the MERGE statement is as follows: 
MERGE file-name-1 
ON 
DESCENDING 
r 
ASCENDING
 
1 
J 
COLLATING SEQUENCE IS alphabet- name 
USING file-name-2 [file-name-3] . . 
OUTPUT PROCEDURE IS procedure-name - 1 
GIVING {file-name-4} . . . 
)THRU 
j 
I THROUGH I 
procedure-name-2 
F i l e - n a m e - 1 
m u s t b e s p e c i f i e d 
in an SD. 
R u l e s for 
A S C E N D I N G 
(DESCENDING) KEY, COLLATING SEQUENCE, USING/GIVING, and OUTPUT 
PROCEDURE are identical to those of the SORT statement. 
Unlike the SORT statement, however, there is no INPUT PROCEDURE option. 
In other words you must specify USING, and list all files from which incoming 
records will be chosen. 
Hence every record in every file specified in USING will 
appear in the merged file. However, y o u do have a choice b e t w e e n GIVING and 
OUTPUT PROCEDURE. 
N o n e of the files specified in a MERGE statement can be o p e n when the 
statement is executed, as the merge operation implicitly o p e n s t h e m . In similar 
fashion, the files will be automatically closed by the MERGE. 
An example of a MERGE statement is s h o w n below: 
MERGE WORK-FILE 
ON ASCENDING CUSTOMER-ACCOUNT-NUMBER 
DESCENDING AMOUNT-OF-SALE 
USING 
MONDAY-SALES-FILE 
TUESDAY-SALES-FILE 
WEDNESDAY-SALES-FILE 
THURSDAY-SALES-FILE 
FRIDAY-SALES-FILE 
GIVING 
WEEKLY-SALES-FILE. 
WORK-FILE is defined in a COBOL SD. 
WEEKLY-SALES-FILE, MONDAY-
SALES-FILE, TUESDAY-SALES-FILE, and so on are each specified in both FD and 
SELECT statements. 
These files must be in s e q u e n c e and are b o t h o p e n e d and 
closed by the merge operation. 
The primary key is CUSTOMER-ACCOUNT-NUMBER (ascending), and the 
secondary key is AMOUNT-OF-SALE (descending). 
All records with the s a m e 
account n u m b e r will be grouped together with the highest sale for e a c h account 
n u m b e r listed first. Records with identical keys in o n e or more input files will be 
listed in the order in which the files appear in the MERGE statement itself. Hence, 
in the event of a tie on both account n u m b e r and a m o u n t of sale, Monday's 
transactions will appear before Tuesday's, and so on. 

Chapter 
14 
Sorting 
The SORT statement in COBOL-74 is signiticantly more restrictive than its 
| 
counterpart in COBOL-85. In particular: 
| 
1. The INPUT (OUTPUT) PROCEDURE in COBOL-74 was required to be a 
j 
section rather than a paragraph, which necessitated that other paragraphs 
| 
In the program be organized into sections as well. 
j 
2. The INPUT (OUTPUT) PROCEDURE in COBOL-74 could not transfer 
j 
control to points outside the designated procedure, requiring the use of a 
| 
GO TO statement within the procedure. The GO TO statement was 
j 
directed to an EXIT paragraph at the end of the section. 
\ 
Both of these restrictions have been removed from COBOL-85 as 
j 
illustrated in the INPUT PROCEDURE/OUTPUT PROCEDURE example in 
\ 
Figure 14.12. An additional change in COBOL-85 is the introduction of the 
[ 
WITH DUPLICATES IN ORDER phrase, which was not present in the earlier 
j 
compiler. 
| 
S
U
M
M
A
R
Y 
Points to 
Remember 
A 
Sorting is done in one of two sequences, ascending or descending. 
Multiple sort keys are listed in order of importance— primary, secondary, 
and tertiary; or major, intermediate, and minor. 
Two collating sequences are in common use, EBCDIC (on IBM mainframes) 
and ASCII (on the PC and other mainframes). The difference is significant 
when an alphanumeric key is used and/or with an embedded sign in a 
numeric field. 
The SORT statement has four combinations: INPUT PROCEDURE/OUTPUT 
PROCEDURE, USING/GIVING, USING/OUTPUT PROCEDURE, and INPUT 
PROCEDURE/GIVING. 
The INPUT PROCEDURE requires the programmer to do the I/O associated 
with the sort work file, whereas the USING option does the I/O automatically. 
The advantage of the INPUT PROCEDURE is the ability to sort on a 
calculated field and/or to selectively pass records to the sort work file. 
a 
The INPUT PROCEDURE contains a RELEASE statement to transfer (write) 
records to the sort work file; the OUTPUT PROCEDURE contains a RETURN 
statement to read the sorted data. 
The GIVING option specifies a permanent file that remains after the program 
has ended and that contains the sorted results; the OUTPUT PROCEDURE 
uses a temporary work file, which is deleted after the program has ended. 

Fill-in 
Regardless of which option is chosen, file-name-1 of the SORT statement 
must be described in an SD. Further, each key (that is, data name) 
appearing in the SORT statement must be described in the sort record. 
If the USING / GIVING option is used, file-name-2 and file-name-3 each 
require an FD. The record sizes of file names 1, 2, and 3 must all be the 
same. 
Minor key 
Primary key 
Secondary key 
Sort key 
Sort work file 
Temporary work file 
Tertiary key 
Utility sort program 
RELEASE 
RETURN 
SD 
SIGN IS LEADING SEPARATE CHARACTER 
SIGN IS TRAILING SEPARATE CHARACTER 
SORT 
USING 
F I L L - I N 
1. A sort 
is a field within a record that determines how the file is to 
be arranged. 
2. The most important key is known as the 
or 
key. 
3. 
and 
are widely used collating sequences. 
4. If records in a file have been sorted by salary so that the employee with the highest 
salary appears first, the records are in 
sequence by salary. 
5. If a file has been sorted by state, city within state, and employee within city, then 
state, city, and name are the 
, 
, and 
keys, respectively. 
6. In a sort on an alphanumeric part number, AAA would precede 111 using the  
collating sequence, but follow it under 
. 
7. The USING option may be used with either 
or 
ASCII 
Ascending sort 
Calculated field 
Collating sequence 
Descending sort 
EBCDIC 
Embedded sign 
Intermediate key 
Major key 
ASCENDING KEY 
DESCENDING KEY 
DUPLICATES IN ORDER 
GIVING 
INPUT PROCEDURE 
MERGE 
OUTPUT PROCEDURE 

C
h
a
p
t
e
r 
14 
— 
Sorting 
8. The 
statement is analogous to WRITE and appears in the 
9. A sort work file must be defined in a 
statement in the Environment 
Division and in an 
in the Data Division. 
10. An embedded sign (requires/does not require) an extra position within a signed 
field. 
11. The default placement of a sign is as the (leading/trailing) character in a(n) 
(embedded/separate) position. 
12. The 
, 
may be used to sort on a 
field, and also to 
pass records to the sort work file to increase 
efficiency. 
13. The MERGE statement requires that its input files have 
record 
layouts. 
14. The MERGE statement (does/does not) permit the INPUT PROCEDURE option. 
TRUE/FALSE 
1. The SORT statement cannot be used on a calculated field. 
2. If USING is specified in the SORT statement, then GIVING must also be specified. 
3. If INPUT PROCEDURE Is specified in the SORT statement, then OUTPUT 
PROCEDURE is also required. 
4. Only one ascending and one descending key are permitted in the SORT statement. 
5. Major key and primary key are synonymous. 
6. Minor key and secondary key are synonymous. 
7. RELEASE and RETURN are associated with the USING/GIVING option. 
8. RELEASE is present in the INPUT PROCEDURE. 
9. RETURN is specified in the OUTPUT PROCEDURE. 
10. If a record is released, it is written to the sort file. 
11. If a record is returned, it is read from the sort file. 
12. If USING/GIVING is used, the sorted file must contain every record in the input file. 
13. If INPUT PROCEDURE/OUTPUT PROCEDURE is used, the sorted file must contain 
every record in the input file. 
14. XYZ will always come before 123 in an alphanumeric sort. 
15. ADAMS will always appear before ADAMSON, regardless of collating sequence. 
16. The file specified immediately after the word MERGE must be defined in an MD 
rather than an SD. 
17. The MERGE statement can specify INPUT PROCEDURE/OUTPUT PROCEDURE. 
18. The MERGE statement can specify USING/GIVING. 
19. The MERGE statement can be applied to input files with different record layouts. 
20. The sort work file (the file defined in the SD) is a temporary file and does not exist 
after the COBOL program has finished execution. 

Given the following data: 
Name 
Location 
Department 
Milgrom 
New York 
1000 
Samuel 
Boston 
2000 
Isaac 
Boston 
2000 
Chandler 
Chicago 
2000 
Lavor 
Los Angeles 
1000 
El si nor 
Chicago 
1000 
Tater 
New York 
2000 
Craig 
New York 
2000 
Bo row 
Boston 
2000 
Kenneth 
Boston 
2000 
Renaldi 
Boston 
1000 
Gulfman 
Chicago 
iOOO 
Rearrange the data according to the following sorts: 
a. Major field: department (descending); minor field, name (ascending). 
b. Primary field: department (ascending); secondary field: location (ascending); 
tertiary field, name (ascending). 
Given the statement 
SORT SORT-FILE 
ASCENDING KEY STUDENT-MAJOR DESCENDING YEAR-IN-SCH00L 
ASCENDING STUDENT-NAME 
USING FILE-ONE 
GIVING FILE-TWO. 
a. What is the major key? 
b. What is the minor key? 
c. Which file will be specified in an SD? 
d. Which file will contain the sorted output? 
e. Which file(s) will be specified in a SELECT? 
f. Which file contains the input data? 
g. Which file must contain the data names S T U D E N T - N A M E , YEAR-IN-SCHOOL, 
and S T U D E N T - M A J O R ? 
The following code is intended to sort a file of employee records in order of age, 
listing the oldest first: 
FD EMPLOYEE-FILE 
01 EMPLOYEE-RECORD. 
05 EMP-NAME 
05 EMP-BIRTH-DATE. 
10 EMP-BIRTH-MONTH 
10 EMP-BIRTH-YEAR 
05 FILLER 
PIC X(25). 
PIC 99. 
PIC 99. 
PIC X(51). 

C
h
a
p
t
e
r 
1 4 — 
Sorting 
SD SORT-FILE 
01 SORT-RECORD. 
05 FILLER 
PIC X(20). 
05 SORT-BIRTH-DATE. 
10 SORT-BIRTH-MONTH PIC 99. 
10 SORT-BIRTH-YEAR 
PIC 99. 
05 FILLER 
PIC X(55). 
PROCEDURE DIVISION. 
SORT SORT-FILE 
DESCENDING KEY SORT-BIRTH-MONTH SORT-BIRTH-YEAR 
USING EMPLOYEE-FILE 
GIVING ORDERED-FILE. 
There are three distinct reasons why the intended code will not work. Find and 
correct the errors. 
4. The registrar has asked for a simple report listing students by year, and 
alphabetically within year. Thus all freshmen are to appear first, followed by all 
sophomores, juniors, seniors, and graduate students. The incoming record has 
the following layout: 
01 
STUDENT-RECORD. 
05 ST-CREDITS 
PIC 99. 
05 ST-COLLEGE 
PIC X(10). 
The ST-YEAR field uses the codes, FR, SO, JR, SR, and GR for freshman, sophomore, 
junior, senior, and graduate student, respectively. Develop the Procedure Division 
code to accomplish the desired sort. (It is not as easy as it looks.) 
5. Indicate the form of the SORT statement (USING, INPUT PROCEDURE, GIVING, 
OUTPUT PROCEDURE) that would most likely be used for the following applications: 
a. Conversion of an incoming inventory file that has its part numbers in ASCII 
sequence to a new file, having its numbers in EBCDIC sequence. 
b. Preparation of a report to select all graduating seniors (those with completed 
credits totaling 90 or more), listed in order of decreasing grade point average. 
c. A data-validation program that reads unedited transactions, rejects those with 
invalid data, and prepares a sorted transaction file containing only valid records. 
d. A program to prepare mailing labels in zip code order from a customer list. 
6. Given the statement: 
MERGE WORK-FILE 
ASCENDING ACCOUNT-NUMBER 
DESCENDING AMOUNT-OF-SALE 
USING 
JANUARY-SALES 
FEBRUARY-SALES 
MARCH-SALES 
GIVING 
FIRST-QUARTER-SALES. 
05 ST-NAME 
05 ST-MAJ0R 
05 ST-YEAR 
PIC X(15). 
PIC X(15). 
PIC XX. 

a. Which file(s) are specified in an SD? 
b. Which file(s) are specified in an FD? 
c. Which file(s) contain the key A C C O U N T - N U M B E R ? 
d. What is the primary key? 
e. What is the secondary key? 
f. If a record on the JANUARY-SALES file has the identical A C C O U N T - N U M B E R 
as a record on the FEBRUARY-SALES file, which record would c o m e first on the 
merged file? 
g. If a record on the JANUARY-SALES file has the identical A M O U N T - O F - S A L E as 
a record on the FEBRUARY-SALES file, which record would c o m e first on the 
merged file? 
h. If a record on the JANUARY-SALES file has the identical A M O U N T - O F - S A L E 
and A C C O U N T - N U M B E R as a record on the FEBRUARY-SALES file, which 
record would come first on the merged file? 
7. Given the following C O B O L definition: 
05 TRANSACTION-DATE. 
10 TRANS-MONTH 
PIC 99. 
10 TRANS-DAY 
PIC 99. 
10 TRANS-YEAR 
PIC 99. 
Write a portion of the S O R T statement necessary to put transactions in sequence, 
with the earliest transaction listed first. Are there any problems in your solution 
when the century changes? Should you be concerned about those problems now? 
8. The registrar requires an alphabetical list of graduating seniors. The report will be 
generated from the student master file, which contains every student in the school, 
in social security number sequence. 
Two approaches have been suggested. The first uses the USING/GIVING 
option to sort the file alphabetically, after which the desired records are selected for 
inclusion in the report. The second selects the desired records in the INPUT 
P R O C E D U R E , after which the file is sorted and the report prepared in the O U T P U T 
P R O C E D U R E . 
Both approaches will produce a correct report. Is there any reason to choose 
one over the other? 


Overview 
S y s t e m 
C o n c e p t s 
Running versus Roiiing Totals 
O n e - L e v e l C o n t r o l Breaks 
Programming Specifications 
Hierarchy Chart 
Pseudocode 
The Completed Program 
T w o - L e v e l Control B r e a k s 
Hierarchy Chart 
Pseudocode 
The Completed Program 
T h r e e - L e v e l Control B r e a k s 
Hierarchy Chart 
Pseudocode 
The Completed Program 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
1 5 
Control 
Breaks 
OBJECTIVES 
After reading this chapter you will be able to: 
Define control break; distinguish between a single control break and a 
multilevel control break. 
Explain the relationship between sorting and control breaks. 
Design a hierarchy chart and pseudocode to implement any number of 
control breaks; evaluate the hierarchy chart with respect to completeness, 
functionality, and span of control. 
Use a general purpose algorithm to write a COBOL program for any 
number of control breaks. 
Develop COBOL programs for one-, two-, and three-level control breaks. 
Distinguish between rolling and running totals. 
O
V
E
R 
V 
I 
E 
W 
This chapter does not introduce any new COBOL per se, but uses the COBOL 
you already know to present one of the most important applications in data 
processing, that of control breaks. A control break is defined as a change in a 
designated field, which in turn requires that the incoming file be in sequence by 
the designated field. There is, therefore, a close relationship between sorting 
and control breaks, a relationship that will be stressed throughout the chapter. 
The logic associated with control breaks is more complex than many of the 
examples presented earlier in the text. The difficulty, if any, stems from a rush 
into coding a program, without giving suitable thought to its design. Accordingly, 
we emphasize the importance of proper design, and the use of hierarchy charts 
and pseudocode, to simplify the eventual coding. 
Control breaks may be implemented at several levels, just as a file may be 
sorted on multiple keys. The system concepts section distinguishes between 
one-, 
two-, and three-level control breaks, each of which is developed in a 
separate program. 
This chapter continues the example of Chapter 14, beginning with a review of the 
file in Figure 15.1 (shown previously as Figure 14.5). Six fields are present in every 
record: account number, salesperson, sales amount, commission percentage, 
location, and region. The sales a m o u n t contains an e m b e d d e d sign to reflect negative 
numbers (i.e., returns rather than sales) as previously discussed. Recall, too, that 
the commission a m o u n t is determined by multiplying the commission percentage 
(contained in the record) by the sales amount. 

Figure 15.1 
Transaction File ( The sales amount shows ASCII rather than 
EBCDIC characters.) 
Acct 
Salesperson 
Sales 
Coram Location 
Region 
Num 
Amount Pet 
000069 BENWAY 
023q 10 CHICAGO 
MIDWEST 
000100 HUMMER 
OlOw 05 CHICAGO 
MIDWEST 
000101 CLARK 
1500 10 TRENTON 
NORTHEAST 
000104 CLARK 
0500 03 TRENTON 
NORTHEAST 
100000 JOHNSON 
030s 06 ST. PETERSBURG SOUTHEAST 
130101 CLARK 
3200 20 TRENTON 
NORTHEAST 
203000 HAAS 
8900 05 ST. LOUIS 
MIDWEST 
248545 JOHNSON 
0345 14 ST. PETERSBURG SOUTHEAST 
277333 HAAS 
009x 08 ST. LOUIS 
MIDWEST 
n nnr\nr\ 
4 U U U U U JOHNSON 
070y 08 ST. PETERSBURG JUU 
1M 
Lnj1 
444333 ADAMS 
lOOv 01 NEW YORK 
NORTHEAST 
444444 FEGEN 
0100 02 ST. PETERSBURG SOUTHEAST 
475365 HAAS 
0333 05 ST. LOUIS 
MIDWEST 
476236 FEGEN 
037v 03 ST. PETERSBURG SOUTHEAST 
476530 D riULIA V 
023u 05 CHICAGO 
MIDWEST 
555555 FEGEN 
0304 05 ST. PETERSBURG SOUTHEAST 
555666 ADAMS 
2003 20 NEW YORK 
NORTHEAST 
576235 CLARK 
0100 03 TRENTON 
NORTHEAST 
583645 KARLSTROM 
0145 04 BALTIMORE 
NORTHEAST 
649356 HUMMER 
0345 05 CHICAGO 
MIDWEST 
694446 HUMMER 
0904 10 CHICAGO 
MIDWEST 
700039 MARCUS 
0932 10 BALTIMORE 
NORTHEAST 
750020 MARCUS 
0305 05 BALTIMORE 
NORTHEAST 
800396 KARLSTROM 
3030 09 BALTIMORE 
NORTHEAST 
878787 JOHNSON 
1235 12 ST. PETERSBURG SOUTHEAST 
987654 ADAMS 
2005 10 NEW YORK 
NORTHEAST 
988888 BENWAY 
0450 01 CHICAGO 
MIDWEST 
999340 BENWAY 
0334 30 CHICAGO 
MIDWEST 
The records in Figure 15.1 are in sequence by account n u m b e r , so that the 
transactions associated with any particular salesperson are scattered throughout 
the file. W h a t if, however, w e wanted to k n o w the total sales and/or commission 
a m o u n t for a particular salesperson or for every salesperson? The easiest w a y to 
produce such a report would be to sort the file by salesperson so that all of the 
transactions for each salesperson appear together. It would then be a simple matter 
to look at all the transactions for A d a m s in order to compute his total sales a n d 
commission, then look at the transactions for Benway, then for Clark, etc. This is 
precisely what is meant by control break processing. 
The records in Figure 15.2a have been sorted by salesperson in order to produce 
the report of Figure 15.2b. A control break, defined as a change in a control field 
(salesperson in the example), occurs w h e n the value of the control field changes 
from record to record—for example, w h e n w e go from the last transaction for 
A d a m s to the first transaction for Benway, a n d again from the last transaction for 
B e n w a y to the first transaction for Clark. The detection of a control break signals the 
creation of one or m o r e control totals, which in this example would be the sales a n d 
commissions for a given salesperson. 

Chapter 
15 — 
Control 
Break 
Figure 15.2 
One-Level Control Break 
444333 ADAMS 
lOOv 01 
555666 ADAMS 
2003 20 
987654 ADAMS 
2005 10 
000069 BENWAY 
023q 10 
476530 BENWAY 
023u 05 
988888 BENWAY 
0450 01 
999340 BENWAY 
0334 30 
000101 CLARK 
1500 10 
000104 CLARK 
0500 03 
130101 CLARK 
3200 20 
576235 CLARK 
0100 03 
444444 FEGEN 
0100 02 
476236 FEGEN 
037v 03 
555555 FEGEN 
0304 05 
HAAS 
8900 05 
277333 HAAS 
009x 08 
475365 HAAS 
0333 05 
000100 HUMMER 
OlOw 05 
649356 HUMMER 
0345 05 
694446 HUMMER 
0904 10 
100000 JOHNSON 
030s 06 
248545 JOHNSON 
0345 14 
400000 JOHNSON 
070y 08 
878787 JOHNSON 
1235 12 
583645 KARLSTR0M 
0145 04 
800396 KARLSTR0M 
3030 09 
700039 MARCUS 
0932 10 
750020 MARCUS 
0305 05 
(a) Sorted Data (b 
SALES ACTIVITY REPORT 
PAGE 3 
SALESPERSON: CLARK 
ACCOUNT # 
SALES 
COMMISSION 
SALES ACTIVITY REPORT 
PAGE 2 
SALESPERSON: BENWAY 
ACCOUNT # 
SALES 
COMMISSION 
SALES ACTIVITY REPORT 
PAGE 1 
SALESPERSON: ADAMS 
ACCOUNT # 
444333 
555666 
987654 
SALES 
1,005-
2,003 
2,005 
COMMISSION 
10-
401 
201 
** SALESPERSON TOTAL 
$ 3,003 
592 
(b) Partial Output 

System 
Concep(s 
A two-level control break is illustrated in Figure 15.3. The data in Figure 15.3a 
have been sorted by location, and by salesperson within location, in order to produce 
the report in Figure 15.3b. All salespersons in the same location appear together, as 
do all transactions for the same salesperson. A one-level control break occurs from 
Karlstrom to Marcus as salesperson changes, but location does not. A two-level 
control break occurs from Marcus to Benway, w h e n the values of two control fields, 
salesperson a n d location, change simultaneously. T h e two-level control break 
produces two sets of control totals: the sales and commission totals for Marcus, as 
well as the sales and commission totals for all salespersons in Baltimore. 
A three-level control break is s h o w n in Figure 15.4. The data in Figure 15.4a 
have been sorted by region, location within region, and salesperson within location, 
in order to produce the report of Figure 15.4b. A one-level control break occurs from 
B e n w a y to H u m m e r as salesperson changes, but location and region do not. A two-
level control break occurs from H u m m e r to Haas w h e n salesperson and location 
change simultaneously but regions remains constant, a n d a three-level control 
break occurs from Haas to Karlstrom as all three fields change together. 
There is no theoretical limit to the n u m b e r of control breaks that can be 
computed; there is a practical limit, however, in that most people lose track after 
three (or at most four) levels. Regardless of the n u m b e r of control breaks in effect, 
the file used to create the control totals must be in sequence according to the 
designated control fields. 
Two-Level Control Break 
583645 KARLSTROM 
80039 6JCAR LSJROM 
700039 MARCUS 
750020 MARCUS 
0145 04 BALTIMORE 
3030_0?_ BALTIMORE 
0932 10 BALTIMORE 
0305_05_ BALTIMORE 
023q 10 (JUS'AGO 
023u 05 CHICAGO 
0450 01 CHICAGO 
0334 30 CHICAGO 
OlOw 05 CHICAGO 
0345 05 CHICAGO 
0904 10 CHICAGO 
lOOv 01 NEW YORK 
2003 20 NEW YORK 
2005 10 NEW YORK 
8900 05 ST. LOUIS 
009x 08 ST. LOUIS 
0333 05 ST. LOUIS 
0100 02 ST. PETER! 
037v 03 ST. PETER! 
000069 BENWAY 
476530 BENWAY 
988888 BENWAY 
999340 BENWAY 
000100 HUMMER 
649356 HUMMER 
694446 HUMMER 
444333 ADAMS 
555666 ADAMS 
987654 ADAMS 
203000 HAAS 
277333 HAAS 
475365 HAAS 
444444 FEGEN 
476236 FEGEN 
555555 FEGEN 
100000 JOHNSON 
248545 JOHNSON 
400000 JOHNSON 
878787 JOHNSON 
000101 CLARK 
000104 CLARK 
130101 CLARK 
576235 CLARK 
1500 10 TRENTON 
0500 03 TRENTON 
3200 20 TRENTON 
0100 03 TRENTON 
0304 05 ST. 
030s 06 ST. 
0345 14 ST. 
070y 08 ST. 
1235 12 ST. 
PETERSBURG 
PETERSBURG 
PETERSBURG 
PETERSBURG 
PETERSBURG 
PETERSBURG 
PETERSBURG 

Chapter 
15 
Control 
Breaks 
Figure 15.3 
(continued) 
[ 
— — — — — . 
— 
— — — ^ 
SALES ACTIVITY REPORT 
PAGE 3 
LOCATION: NEW YORK 
SALESPERSON: ADAMS 
SALES ACTIVITY REPORT 
PAGE 2 
LOCATION: CHICAGO 
SALESPERSON: BENWAY 
SALES ACTIVITY REPORT 
PAGE 1 
LOCATION: BALTIMORE 
SALESPERSON: KARLSTROM 
ACCOUNT # 
SALES 
COMMISSION 
583645 
145 
6 
800396 
273 
** SALESPERSON TOTAL 
J 
3,175 
$ 279 
SALESPERSON: MARCUS 
ACCOUNT # 
SALES 
COMMISSION 
700039 
932 
93 
750020 
305 
15 
** SALESPERSON TOTAL 
$ 1,237 
$ 108 
**** LOCATION TOTAL 
$ 4,412 
$ 387 
ION 
ON 
(b) Partial Output 
Running versus Rolling Totals 
, 
Each of the reports in Figures 15.2 through 15.4 computes totals at one or m o r e 
levels (at salesperson, location, region, a n d company), according to the n u m b e r of 
control breaks. T h e c o m p a n y totals are printed at the end of processing and appear 
o n the last page of each report, but are not visible in the individual figures. (The 
total sales for the c o m p a n y a n d corresponding commission are $23,906 and $2,540, 
respectively.) 
Consider for a m o m e n t h o w the computations might be accomplished in the 
one-level report of Figure 15.2b. There is only one w a y to compute the total for 
individual salespersons—by initializing the total for each n e w salesperson to zero, 
then adding the a m o u n t o n every transaction for that salesperson to his or her total. 
There are, however, two ways to compute the c o m p a n y total—by adding the value 
for every transaction to a running company total, or b y waiting for a break o n 

salesperson a n d then adding, or rolling, the salesperson total to the c o m p a n y total. 
The latter is m o r e efficient in that fewer additions are performed. 
Similar reasoning applies to the two-level report of Figure 15.3b, in which the 
location total can be computed two different w a y s — b y adding the value of each 
incoming transaction to a running location total, or by waiting for a control break 
o n salesperson, then rolling the salesperson total to the location total. In similar 
fashion, the c o m p a n y total m a y be obtained in three ways. First, by adding the 
value of every incoming transaction to a running c o m p a n y total. Second, by rolling 
the salesperson total into the c o m p a n y total after a one-level break o n salesperson. 
Or third, by rolling the location total into the c o m p a n y total after a two-level break 
o n location. The third approach is the most efficient. 
Y o u should be able to extend this logic to the three-level report of Figure 15.4b, 
which maintains a running total for each salesperson, then roils the salesperson 
total into the location total (after a break o n salesperson), rolls the location total 
into the region total (after a break o n location), a n d finally rolls the region total into 
the c o m p a n y total (after a break o n region). 
Three-Level Control Break 
000069 BENWAY 
476530 BENWAY 
988888 BENWAY 
999340 BENWAY 
023q 10 CHICAGO 
MIDWEST 
023u 05 CHICAGO 
MIDWEST 
0450 01 CHICAGO 
MIDWEST 
0334 30 CHICAGO 
MIDWEST 
000100 HUMMER 
649356 HUMMER 
694446 HUMMER 
OlOw 05 CHICAGO 
MIDWEST 
0345 05 CHICAGO 
MIDWEST 
0904 10 CHI C A M 
MIDWEST 
8900 05 ST. LOUIS 
" MIDWEST 
009x 08 ST. LOUIS 
MIDWEST 
0333 05 ST. LOUIS 
MIDWEST 
203000 HAAS 
277333 HAAS 
475365 HAAS 
583645 KARLSTROM 
800396 KARLSTROM 
0145 04 BALTIMORE 
NORTHEAST 
3030 09 BALTIMORE 
NORTHEAST 
0932 10 BALTIMORE 
NORTHEAST 
0305 05 BALTIMORE 
NORTHEAST 
lOOv 01 NEW YORK 
NORTHEAST 
2003 20 NEW YORK 
NORTHEAST 
2005 10 NEW YORK 
NORTHEAST 
1500 10 TRENTON 
NORTHEAST 
0500 03 TRENTON 
NORTHEAST 
3200 20 TRENTON 
NORTHEAST 
0100 03 TRENTON 
NORTHEAST 
0100 02 ST. PETERSBURG SOUTHEAST 
037v 03 ST. PETERSBURG SOUTHEAST 
0304 05 ST. PETERSBURG SOUTHEAST 
030s 06 ST. PETERSBURG SOUTHEAST 
0345 14 ST. PETERSBURG SOUTHEAST 
070y 08 ST. PETERSBURG SOUTHEAST 
1235 12 ST. PETERSBURG SOUTHEAST 
break 
700039 MARCUS 
750020 MARCUS 
444333 ADAMS 
555666 ADAMS 
987654 ADAMS 
000101 CLARK 
000104 CLARK 
130101 CLARK 
576235 CLARK 
444444 FEGEN 
476236 FEGEN 
555555 FEGEN 
100000 JOHNSON 
248545 JOHNSON 
400000 JOHNSON 
878787 JOHNSON 

C
h
a
p
t
e
r 
1 5 
— 
Control 
Breaks 
(continued) 
SALES ACTIVITY REPORT 
PAGE 3 
REGION: SOUTHEAST 
LOCATION: ST. PETERSBURG 
SALES ACTIVITY REPORT 
PAGE 2 
REGION: NORTHEAST 
LOCATION: BALTIMORE 
SALES ACTIVITY REPORT 
PAGE 1 
REGION: MIDWEST 
LOCATION: CHICAGO 
SALESPERSON: BENWAY 
ACCOUNT t 
U U U U U 3 
476530 
988888 
999340 
SALES 
231-
235-
450 
334 
COMMISSION 
23-
12-
5 
100 
** SALESPERSON TOTAL 
$ 
318 
$ 
70 
SALESPERSON: HUMMER 
ACCOUNT # 
000100 
649356 
694446 
SALES 
107-
345 
904 
COMMISSION 
5-
17 
90 
** SALESPERSON TOTAL 
$ 
1,142 
$ 
102 
**** LOCATION TOTAL 
$ 
1,460 
$ 
172 
LOCATION: ST. LOUIS 
SALESPERSON: HAAS 
ACCOUNT # 
203000 
277333 
475365 
SALES 
8,900 
98-
333 
COMMISSION 
445 
8-
17 
** SALESPERSON TOTAL 
$ 
9,135 
$ 
454 
**** LOCATION TOTAL 
$ 
9,135 
$ 
454 
****** REGION TOTAL 
$ 10,595 
$ 
626 
i: 

One-Level 
Control 
Breaks 
The development of the one- (two- and three-) level programs is not difficult given a 
clear understanding of the requirements and the distinction between running and 
rolling totals. W e begin with the specifications for the one-level program. 
P
R
O
G
R
A
M
M
I
N
G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
One-Level Control Break 
Narrative: 
The specifications are for the one-level control break program. Changes to the 
specifications to accommodate two- and three-level control breaks are provided later in 
the chapter. 
I n p u t F i l e ( s ) : 
SALES-FILE 
I n p u t R e c o r d L a y o u t : 
01 SALES-RECORD-IN. 
05 SR-ACCOUNT-NUMBER 
PIC 9(6). 
05 FILLER 
PIC X. 
05 SR-NAME 
PIC X(15) 
05 SR-SALES 
PIC S9(4) 
05 FILLER 
PIC XX. 
05 SR-COMMISSION-PERCENT 
PIC V99. 
05 FILLER 
PIC XX. 
05 SR-LOCATION 
PIC X(15) 
05 SR-REGION 
PIC X(ll) 
T e s t D a t a : 
See Figure 15.1. 
R e p o r t L a y o u t : 
See Figure 15.2b. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Sort the incoming transaction file by salesperson; use the WITH DUPLICATES IN 
O R D E R phrase of the S O R T statement to keep the sorted file in sequence by transaction 
number within salesperson. 
2. Process transactions until a control break is encountered on salesperson, then for 
each new salesperson: 
a. Initialize the total sales and commission for that salesperson to zero. 
b. Print a heading for this salesperson on a new page. 
3. Process all transactions for each salesperson as follows: 
a. Compute the commission for each transaction by multiplying the amount of the sale 
by the commission percentage. 
b. Print a detail line for each transaction containing the account number, sales 
amount, and computed commission. 
c. Increment the total sales and commissions for that salesperson by the corresponding 
amounts for this transaction. 
4. Print a total line for each salesperson whenever salesperson changes. Print dashes as 
indicated between the last detail line and the total line. 
5. Increment the company totals with the salesperson's accumulated totals as salesperson 
changes. 
6. Print the company totals after all records have been processed. 

Chapter 
15 — 
Conti 
ol 
Breaks 
Hierarchy Chart 
The report in Figure 15.2b contains a heading line prior to the first transaction for 
each salesperson, detail lines containing the sales a n d commission for the individual 
transactions, and a total line after all transactions for each salesperson. The c o m p a n y 
total appears at the e n d of the report (but is not visible in Figure 15.2b). 
All of these functions are recognized in the hierarchy chart of Figure 15.5a, 
which was developed in stages, beginning at the top a n d working d o w n to the 
bottom. T h e functions at every level in the hierarchy chart are divided into 
component functions that appear on the next lower-level. The lower-level functions 
are further subdivided into other functions o n a still lower-level, until finally the 
lowest-level functions cannot be further subdivided. 
T h e module at the top (or first level) of the hierarchy chart, PREPARE-SALES-
R E P O R T , depicts the overall program function. It is divided into four subordinate 
functions, each of which was taken directly from the programming specifications. 
These modules are placed o n the second level of the hierarchy chart: 
1. S O R T - T R A N S A C T I O N - F I L E to sort the transaction file (as indicated in item 1 
of the processing requirements) 
2. R E A D - S O R T E D - SALES - FILE to read a record from the sorted file 
3. P R O C E S S - O N E - S A L E S P E R S O N to process each salesperson (from items 2 
through 5 of the processing requirements) 
4. W R I T E - C O M P A N Y - T O T A L to write the c o m p a n y total (from item 6 of the 
processing requirements) 
Each of these modules is considered for further subdivision, but only P R O C E S S -
O N E - S A L E S P E R S O N is divided into component functions for the next level. O n c e 
again, w e use the processing requirements as a guide to determine the subordinate 
functions for the third level: 
1. INITIALIZE-SALESPERSON to initialize the sales a n d commission amounts 
for this salesperson (item 2a of the processing requirements) 
2. W R I T E - S A L E S P E R S O N - H E A D I N G to write a heading for each salesperson 
(item 2b of the processing requirements) 
3. P R O C E S S - O N E - T R A N S A C T I O N to process the transaction (item 3 of the 
processing requirements) 
4. W R I T t S A L E S P E R S O N - T O T A L to print the salesperson total (item 4 of the 
processing requirements) 
5. I N C R E M E N T - C O M P A N Y - T O T A L to increment the c o m p a n y total (item 5 of 
the processing requirements) 
Each function is evaluated for further subdivision, but only P R O C E S S - O N E -
T R A N S A C T I O N is developed further. Repeating the earlier procedure, a n d again 
using the processing requirements, w e obtain the modules for the fourth a n d 
final level: 
1. C A L C U L A T E - C O M M I S S I O N to calculate the commission for the transaction 
(item 3a of the processing requirements) 
2. WRITE-DETAIL-LINE to write a detail line for each transaction (item 3b of 
the processing requirements) 
3. I N C R E M E N T - S A L E S P E R S O N - T O T A L to increment the salesperson's total 
(item 3c of the processing requirements) 
4. READ-SORTED-SALES-FILE to read the next record and avoid an endless loop 

One-Level 
Control 
Breaks 
•Sgpj. v* \ £>.& One-Level Algorithm 
SORT 
TRANSACTION 
FILE 
INITIALIZE 
SALESPERSON 
CALCULATE 
COMMISSION 
PREPARE 
SALES 
REPORT 
READ 
SORTED 
SALES-FILE 
WRITE 
SALESPERSON 
HEADING 
WRITE 
DETAIL LINE 
PROCESS ONE 
SALESPERSON 
PROCESS ONE 
TRANSACTION 
INCREMENT 
SALESPERSON 
TOTAL 
WRITE 
COMPANY 
TOTAL 
WRITE 
SALESPERSON 
TOTAL 
INCREMENT 
COMPANY 
TOTAL 
READ 
SORTED 
SALES-FILE 
(a) Hierarchy Chart 
Sort transaction file on salesperson 
Open sorted-file, print-file 
Read first record 
PERFORM UNTIL no more data 
Initialize salesperson totals 
Move SR-NAME to PREVIOUS-NAME 
Write salesperson headings 
- PERFORM UNTIL SR-NAME NOT = PREVIOUS-NAME 
or no more data 
Calculate commission 
Write detail line 
Increment salesperson totals 
Read next record 
- ENDPERFORM 
Write salesperson totals 
Increment company totals by salesperson totals 
ENDPERFORM 
Write company totals 
Close files 
Stop run 
(b)Pseudocode 

C
h
a
p
t
e
r 
1 5 
— 
Control 
Breaks 
The completed hierarchy chart is evaluated according to the criteria presented 
in Chapter 3—completeness, functionality, a n d span of control. The hierarchy chart 
is complete because it contains a m o d u l e corresponding to every processing 
requirement. Its modules are functional (i.e., each module accomplishes a single 
task) as can be implied from the module n a m e s that consist of a verb, an adjective 
or two, and an object—for example, I N C R E M E N T - S A L E S P E R S O N - T O T A L or W R I T E -
DETAIL-LINE. 
Finally, the span of control (number of subordinate modules) is reasonably 
set at three or four throughout the hierarchy chart, a n d the relationship of the 
modules to one another appears to be correct. Observe, for example, that W R I T E -
DETAIL-LINE, I N C R E M E N T - S A L E S P E R S O N - T O T A L , a n d R E A D - S O R T E D - SALES -
FILE are subordinate to P R O C E S S - O N E - T R A N S A C T I O N , which in turn is subordinate 
to P R O C E S S - O N E - S A L E S P E R S O N , which is subordinate to P R E P A R E - S A L E S -
R E P O R T . There is no other reasonable w a y to relate these functions, all of which are 
required to maintain completeness. 
Pseudocode 
The pseudocode in Figure 15.5b introduces specific C O B O L data names, such as 
S R - N A M E and P R E V I O U S - N A M E , that enable the program to detect a control 
break. In other words, a C O B O L statement cannot simply process records until a 
control break occurs, but must specify precisely h o w to determine w h e n the value 
of salesperson changes. Thus in order to detect a control break, the program 
compares the n a m e o n the record just read to the n a m e o n the previous record; 
that is, it compares S R - N A M E to P R E V I O U S - N A M E , a n d detects a break w h e n the 
values are different. 
The pseudocode sorts the transaction file according to salesperson, reads the 
first transaction record, then executes the statements in the outer loop for every 
salesperson until the entire file has been processed. T h e (sales a n d commission) 
totals for each n e w salesperson are initialized, then an inner loop is executed until a 
control break is detected. The inner loop processes all transactions for the current 
salesperson b y calculating the commission amount, writing a detail line, a n d 
incrementing the running salesperson totals. The inner loop is terminated by the 
control break—that is, w h e n S R - N A M E is not equal to P R E V I O U S - N A M E — a f t e r 
which the sales a n d commission totals for the salesperson are written and rolled 
into the corresponding c o m p a n y totals. 
It is n o w a simple matter to write the required program. 
The j"cirv
vv*ted Program 
The completed program in Figure 15.6 is straightforward and easy to follow, especially 
after the preceding discussion o n hierarchy charts a n d pseudocode. Note especially 
the relationship of the hierarchy chart in Figure 15.5a to the paragraphs in the 
Procedure Division. The modules in the hierarchy chart correspond one to one with 
the paragraphs in the program. Observe also that each level in the hierarchy chart 
corresponds to a C O B O L P E R F O R M statement. 
The Working-Storage Section contains multiple 01 entries for the various 
print lines required by the program. There are multiple heading lines, a detail line, 
and two total lines. Working-Storage also contains separate counters for the 
salesperson a n d c o m p a n y totals, as well as a switch, P R E V I O U S - N A M E , to detect 
the control break o n salesperson. 
T h e S O R T statement (lines 151-156) specifies S O R T - N A M E as the primary key 
in accordance with the requirements of the control break o n salesperson. T h e 

One-Level 
Control 
Breaks 
W I T H D U P L I C A T E S IN O R D E R phrase keeps the transactions for a given salesperson 
in sequence by account n u m b e r because the input file (Figure 15 1) w a s already in 
sequence by this field. 
One-Level Control Break Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
ONELEVEL. 
3 
AUTHOR. 
CVV. 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT SALES-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RTIN.DAT' 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE 
11 
ASSIGN TO PRINTER. 
12 
SELECT SORT-WORK-FILE 
13 
ASSIGN TO 'A:\CHAPTR15\S0RTWK.DAT'. 
14 
SELECT SORTED-SALES-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RT0UT.DAT' 
15 
ORGANIZATION IS LINE SEQUENTIAL. 
16 
17 
DATA DIVISION. 
18 
FILE SECTION. 
19 
FD SALES-FILE 
20 
RECORD CONTAINS 58 CHARACTERS 
21 
DATA RECORD IS SALES-RECORD. 
22 
01 SALES-RECORD 
PIC X(58). 
23 
24 
FD PRINT-FILE 
25 
RECORD CONTAINS 132 CHARACTERS 
26 
DATA RECORD IS PRINT-LINE. 
27 
01 PRINT-LINE 
PIC X(132). 
28 
29 
SD SORT-WORK-FILE 
30 
RECORD CONTAINS 58 CHARACTERS 
31 
DATA RECORD IS SORT-RECORD. 
32 
01 SORT-RECORD. 
33 
05 SORT-ACCOUNT-NUMBER 
PIC 9(6). 
34 
05 FILLER 
PIC X. 
35 
05 SORT-NAME 
PIC X(15). 
36 
05 FILLER 
PIC X(10). 
37 
05 SORT-LOCATION 
PIC X(15). 
38 
05 SORT-REGION 
PIC X(ll). 
39 
40 
FD SORTED-SALES-FILE 
41 
RECORD CONTAINS 58 CHARACTERS 
42 
DATA RECORD IS SORTED-SALES-RECORD. 
43 
01 SORTED-SALES-RECORD 
PIC X(58). 

Chapter 
15 — 
Control 
Break 
mt& "iS.S 
(continued) 
44 
45 
WORKING -STORAGE SECTION. 
46 
01 
FILLER 
PIC X(14) 
47 
VALUE 'WS BEGINS HERE'. 
48 
49 
01 
SALES-RECORD-IN. 
50 
05 
SR-ACCOUNT-NUMBER 
PIC 9(6). 
51 
05 
FILLER 
PIC X. 
52 
05 
SR-NAME 
PIC X(15). 
53 
05 
SR-SALES 
PIC S9(4). 
54 
05 
FILLER 
PIC XX. 
55 
05 
SR-COMMISSION-PERCENT 
PIC V99. 
ETC 
uu 
05 
FILLER 
PIC XX. 
57 
05 
SR-LOCATION 
PIC X(15). 
58 
05 
SR-REGION 
PIC X(ll). 
59 
60 
01 
PROGRAM-SWITCHES-AND-COUNTERS 
si 
V X 
\j ~> DATA-REMAINS-SW 
PIC X(3) 
U A I i ir 
K t t L U t 'YES'. 
62 
88 NO-DATA-REMAINS 
VALUE 'NO' . 
63 
05 
PREVIOUS-NAME 
PIC X(15) 
VALUE SPACES. 
64 
05 
PAGE-COUNT 
PIC 99 
VALUE ZEROES. 
65 
66 
01 
CONTROL-BREAK-TOTALS. 
67 
05 
INDIVIDUAL-TOTALS. 
68 
10 IND-COMMISSION 
PIC S9(4). 
69 
05 
SALESPERSON-TOTALS. 
70 
10 SALESPERSON-SALES-TOT PIC S9(6). 
71 
10 SALESPERSON-COMM-TOT 
PIC S9(6). 
72 
05 
COMPANY-TOTALS. 
73 
10 COMPANY-SALES-TOT 
PIC S9(6) 
VALUE ZEROS. 
74 
10 COMPANY-COMM-TOT 
PIC S9(6) 
VALUE ZEROS. 
75 
76 
01 
REPORT-HEADING-LINE. 
77 
05 
FILLER 
PIC X(25) 
VALUE SPACES. 
78 
05 
FILLER 
PIC X(21) 
79 
VALUE 'SALES ACTIVITY REPORT'. 
80 
05 
FILLER 
PIC X(19) 
VALUE SPACES. 
81 
05 
FILLER 
PIC X(5) 
VALUE 'PAGE ' 
82 
05 
HDG-PAGE 
PIC Z9. 
83 
05 
FILLER 
PIC X(60) 
VALUE SPACES. 
84 
85 
01 
SALESPERSON-HEADING-LINE-ONE. 
86 
05 
FILLER 
PIC X(15) 
VALUE SPACES. 
87 
88 
05 
FILLER 
VALUE 'SALESPERSON: '. 
PIC X(13) 
89 
05 HDG-NAME 
PIC X(15). 
90 
05 
FILLER 
PIC X(89) 
VALUE SPACES. 
91 
92 
01 
SALESPERSON-HEADING-LINE-TWO. 
93 
05 
FILLER 
PIC X(23) 
VALUE SPACES. 

One-Level 
Control 
Breaks 
(continued) 
94 
05 FILLER 
PIC X(ll) VALUE 'ACCOUNT 
95 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
96 
05 FILLER 
PIC X(5) 
VALUE 'SALES'. 
97 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
98 
05 FILLER 
PIC X(10) VALUE 'COMMISS 
99 
05 FILLER 
PIC X(66) VALUE SPACES. 
100 
101 
01 DETAIL-LINE. 
102 
05 FILLER 
PIC X(25) VALUE SPACES. 
103 
05 
DET-ACCOUNT-NUMBER 
PIC 9(6). 
104 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
105 
| 05 DET-SALES 
PIC Z(3), 7/9-.'} 
106 
05 FILLER 
PIC X(7J 
VALUE SPACES. 
107 
I 
05 DET-COMMISSION 
PIC Z(3), ZZ9- .']-
108 
05 FILLER 
PIC X(69) 
VALUE SPACES. 
109 
110 
01 DASHED-LINE. 
111 
X X X 
05 FILLER 
PIC X(40) 
VALUE SPACES. 
112 
05 FILLER 
PIC X(8) 
VALUE ALL '-'. 
113 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
114 
05 FILLER 
PIC X(8) 
VALUE ALL '-'. 
115 
1 1 C 
05 FILLER 
PIC X(69) 
VALUE SPACES. 
1 J . U 
117 
01 SALESPERSON-TOTAL-LINE. 
118 
05 FILLER 
PIC X(15) 
VALUE SPACES. 
119 
05 FILLER 
PIC X(21) 
120 
VALUE '** SALESPERSON TOTAL'. 
121 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
122 
05 
SALESPERSON-SALES-TOTAL 
PIC $Z(3) ,119-. 
123 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
124 
05 
SALESPERSON-COMM-TOTAL 
PIC $Z(3) ,119-. 
125 
05 FILLER 
PIC X(69) 
VALUE SPACES. 
126 
127 
01 COMPANY-TOTAL-LINE. 
128 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
129 
05 FILLER 
PIC X(22) 
130 
VALUE ********* COMPANY TOTAL'. 
131 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
132 
05 COMPANY-SALES-TOTAL 
PIC $Z(3) ,ZZ9-. 
133 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
134 
05 COMPANY-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
135 
05 FILLER 
PIC X(69) 
VALUE SPACES. 
136 
137 
PROCEDURE DIVISION. 
138 
100 -PREPARE-SALES-REPORT. f -
139 
PERFORM 200-SORT-TRANSACTION-FILE. 
140 
OPEN INPUT SORTED-SALES- FILE 
141 
OUTPUT PRINT-FILE. 
142 
PERFORM 220-READ-SORTED- SALES -FILE. 
143 
PERFORM 240-PR0CESS-0NE- SALESPERSON 

Chapter 
15 — 
Control 
Break 
(continued) 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
UNTIL NO-DATA-REMAINS. 
PERFORM 260-WRITE-COMPANY-TOTAL. 
CLOSE SORTED-SALES-FILE 
PRINT-FILE. 
STOP RUN. 
200-SORT-TRANSACTION-FILE. 
SORT SORT-WORK-FILE 
ASCENDING KEY 
SORT-NAME 
WITH DUPLICATES IN ORDER 
USING SALES-FILE 
GIVING SORTED-SALES-FILE. 
220-READ-SORTED-SALES-FILE. 
READ SORTED-SALES-FILE INTO SALES-RECORD-IN 
AT END MOVE 'NO' TO DATA-REMAINS-SW 
END-READ. 
240-PROCESS-ONE-SALESPERSON. 
PERFORM 300-INITIAL 12E-SALESPERS0N. 
PERFORM 320-WRITE-SALESPERSON-HEADING. 
PER FORM J4p-T
3R0CESS:0N E-TRANSACT I ON 
_ 
UNTIL SR-NAME NOT EQUAL PREVIOUS-NAME 
OR NO-DATA-REMAINS. 
[PERFORM 360-WRITE-SALESPERSON-TOTAL. 
PERFORM 380-1NCREMENT-COMPANY-TOTAL. 
260-WRITE-COMPANY-TOTAL. 
MOVE COMPANY-SALES-TOT TO COMPANY-SALES-TOTAL. 
MOVE COMPANY-COMM-TOT TO COMPANY-COMM-TOTAL. 
WRITE PRINT-LINE FROM COMPANY-TOTAL-LINE 
AFTER ADVANCING 2 LINES. 
300-INITIALIZE-SALESPERSON. 
MOVE SR-NAME TO PREVIOUS-NAME. 
INITIALIZE SALESPERSON-TOTALS. 
320-WRITE-SALESPERSON-HEADING. 
ADD 1 TO PAGE-COUNT. 
MOVE PAGE-COUNT TO HDG-PAGE. 
WRITE PRINT-LINE FROM REPORT-HEADING-LINE 
AFTER ADVANCING PAGE. 
MOVE SR-NAME TO HDG-NAME. 
WRITE PRINT-LINE FROM SALESPERSON-HEADING-LINE-ONE 
AFTER ADVANCING 2 LINES. 
WRITE PRINT-LINE FROM SALESPERSON-HEADING-LINE-TWO 
AFTER ADVANCING 1 LINE. 
340-PROCESS-ONE-TRANSACTION. 
PERFORM 400-CALCULATE-C0MMISSI0N. 

Two-Level 
Control 
Breaks 
*igur» iS.6 
(continued) 
j 
195 
PERFORM 420-WRITE-DETAIL-LINE. 
I 
196 
PERFORM 440-INCRMENT-SALESPERS0N-T0TAL. 
j 
197 
PERFORM 220-READ-SORTED-SALES-FILE. 
| 198 
| 
199 
360-WRITE-SALESPERSON-TOTAL. 
| 
200 
WRITE PRINT-LINE FROM DASHED-LINE 
I 
201 
AFTER ADVANCING 1 LINE. 
| 
202 
MOVE SALESPERSON-SALES-TOT TO SALESPERSON-SALES-TOTAL. 
I 
203 
MOVE SALESPERSON-COMM-TOT TO SALESPERSON-COMM-TOTAL. 
j 
204 
WRITE PRINT-LINE FROM SALESPERSON-TOTAL-LINE 
( 
205 
AFTER ADVANCING 1 LINE, 
j 
206 
MOVE SPACES TO PRINT-LINE. 
207 
WRITE PRINT-LINE 
208 
AFTER ADVANCING 1 LINE. 
209 
210 
380-INCREMENT-COMPANY-TOTAL. 
| 
211 
ADD SALESPERSON-SALES-TOT TO COMPANY-SALES-TOT. /-""^ 
111 
ADD SALESPERSON-COMM-TOT TO COMPANY-COMM-TOT. 
j 
213 
214 
400-CALCULATE-COMMISSION. 
215 
COMPUTE IND-COMMISSION ROUNDED = 
216 
SR-SALES * SR-COMMISSION-PERCENT 
217 
SIZE ERROR DISPLAY 'SIZE ERROR ON COMMISSION FOR ' 
218 
SR-NAME 
219 
END-COMPUTE. 
220 
j 
221 
420-WRITE-DETAIL-LINE. 
[ 
222 
MOVE SR-ACCOUNT-NUMBER TO DET-ACCOUNT-NUMBER. 
I 
223 
MOVE SR-SALES TO DET-SALES. 
| 
224 
MOVE IND-COMMISSION TO DET-COMMISSION. 
| 
225 
WRITE PRINT-LINE FROM DETAIL-LINE. 
| 226 
| 
227 
440-1NCRMENT-SALESPERSON-TOTAL. 
1 
228 
ADD SR-SALES TO SALESPERSON-SALES-TOT. 
229 
, ADD IND-COMMISSION TO SALESPERSON-COMM-TOT. 
I he reports in Figures 15.2, 15.3, a n d 15.4 presented a logical progression of one, 
U L CCCx i 
two, and three control breaks—for salesperson; location and salesperson; and region, 
location, a n d salesperson, respectively. This section extends the hierarchy chart, 
pseudocode, a n d C O B O L program for the one-level application to include a second 
control break. 
The development of the two-level hierarchy chart is best accomplished as a n 
extension of its existing one-level counterpart. O n e easy w a y to anticipate the 
changes is to compare the one- a n d two-level reports in Figures 15.2b a n d 15.3b, 

Chapter 
15 — 
Control 
Breaks 
then consider the following questions with respect to the hierarchy chart of 
Figure 15.5a: 
1. W h a t additional (i.e., new) modules are necessary? 
2. W h i c h existing modules (if any) have to be modified? 
3. W h i c h existing modules (if any) have to be deleted? 
Every module that appeared in the one-level hierarchy chart will also appear in its 
two-level counterpart; that is, no modules will be deleted because every function in 
the one-level application is also required in the two-level example. In addition, 
several n e w functions have to be added to a c c o m m o d a t e the control break o n 
location. These include: 
1. P R O C E S S - O N E - L O C A T I O N to process all salespersons in one location 
2. INITIALIZE-LOCATION to initialize the sales and commission amounts for 
this location 
3. W R I T E - L O C A T I O N - H E A D I N G to print a location heading prior to each n e w 
location 
4. I N C R E M E N T - L O C A T I O N - T O T A L to increment the sales and commission 
totals for each location 
5. W R I T E - L O C A T I O N - T O T A L to print the location totals after a control break 
o n location 
Changes will also be required in the logic of s o m e existing modules; for example, 
the module S O R T - T R A N S A C T I O N - F I L E must n o w reflect a sort o n location and 
salesperson within location. A m o r e subtle change is in W R I T E - S A L E S P E R S O N -
H E A D I N G , which previously began the report for each salesperson o n a n e w page, 
but which n o w lists all salespersons in one location o n the s a m e page. 
The computation of the c o m p a n y total changes as well. T h e one-level example 
waited for a control break o n salesperson, then rolled the salesperson total into the 
c o m p a n y total. Although the s a m e approach could be used in the two-level example, 
it is m o r e efficient to wait for a control break o n location, then roll the location total 
into the c o m p a n y total. 
The hierarchy chart for the two-level problem is s h o w n in Figure 15.7a, with 
the additional and/or modified modules shaded for emphasis. The placement of 
the n e w modules is important, a n d you should notice that the module P R O C E S S -
O N E - L O C A T I O N appears o n the second level of the hierarchy chart; this in turn 
forces the existing m o d u l e P R O C E S S - O N E - S A L E S P E R S O N , a n d all of its 
subordinates, d o w n a level. 
Figure 15.7b is subject to the s a m e design considerations as its predecessor, 
namely, completeness, functionality, a n d span of control. All design criteria appear 
satisfactory and the hierarchy chart is finished. 
Pseudocode 
„ 
The pseudocode for the one-level control example is expanded to its two-level 
counterpart in Figure 15.7b. N e w and/or modified statements are highlighted to be 
consistent with the associated hierarchy chart. 
The sort statement includes location as an additional key as previously 
indicated. T h e major change, however, is the modification of the outer loop to 
include a series of repetitive statements for each n e w location that initialize the 
location totals, write the location heading, a n d process all salespersons in that 
location. The detection of a control break on location occurs w h e n S R - L O C A T I O N 
is unequal to P R E V I O U S - L O C A T I O N , and produces the location total, which is then 
rolled into the c o m p a n y total. 

Two-Level 
Control 
Breaks 
igure 15,7 
Two-Level Algorithm 
SORT 
TRANSACTION 
FILE 
IWllAUZE 
tOCATIOtJ 
INITIALIZE 
SALESPERSON 
CALCULATE 
COMMISSION 
PREPARE 
SALES 
REPORT 
READ 
SORTED 
SALES-FILE 
ftWE 
1 OCATfOfc 
HtADilfc 
WRITE 
SALESPERSON 
HEADIMS 
WRITE 
DETAIL LINE 
PROCESS ONE 
LOCATION 
WRITE 
COMPANY 
TOTAL 
PROCESS ONE 
SALESPERSON 
iWRi E 
lOCAWA 
T01Al 
PROCESS ONE 
TRANSACTION 
WRITE 
SALESPERSON 
TOTAL 
INCREMENT 
SALESPERSON 
TOTAL 
READ 
SORTED 
SALES-FILE 
INCREMENT 
COMPANY 
TOTAL 
INCREMENT 
LOCATION 
TOTAL 
Sort transaition file on location, salespeison 
Open sorted-file, print-file 
Read first record 
PERFORM UNTIL no more data 
Initialize location totals 
MOVE SR-LOCATION to PREVIOUS-LOCATION 
Write location headings 
• 
PERFORM UNTIL SR-LOCATION NOT EQUAL PREVIOUS-LOCATION 
or no more data 
Initialize salesperson totals 
MOVE SR-NAME to PREVIOUS-NAME 
Write salesperson headings 
PERFORM UNTIL SR-NAME NOT EQUAL PREVIOUS-NAME 
or SR-LOCATION NOT EQUAL PREVIOUS-LOCATION 
or no more data 
Calculate commission 
Write detail line (if any) 
Increment salesperson totals 
Read next record 
ENDPERFORM 
Write salesperson totals 
Increment location totals 
- ENDPERFORM 
Write location totals 
Increment company totals by location totals 
ENDPERFORM 
Write company totals 
Close files 
Stop run 

C
h
a
p
t
e
r 
1 5 
Control 
Breaks 
Within each location, there is a second loop (carried over from the one-level 
compound 
c o n d i t i o n in the test for a control break o n salesperson that n o w includes 
both salesperson and location. This dual test is necessary in the unusual instance 
where the last salesperson in the current location a n d the first salesperson in the 
next location have the s a m e n a m e . (A general rule for the detection of a control 
break requires a c o m p o u n d condition, which includes a check for the level you are 
on, as well as any levels above the current level.) 
The completed program is s h o w n in Figure 15.8 a n d reflects all of the indicated 
changes. Once again, w e call your attention to the relationship between the hierarchy 
chart in Figure 15.7a and the paragraphs in the Procedure Division. The modules in 
the hierarchy chart correspond one to one with the paragraphs in the program. 
Observe also that each level in the hierarchy chart can be matched with a C O B O L 
P E R F O R M statement. 
Figure 15.8 
Two-Level Control Break k Prograi 11 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
TWOLEVEL. 
AUTHOR. 
CVV. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT SALES-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RTIN.DAT'  
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
SELECT SORT-WORK-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RTWK.DAT'. 
SELECT SORTED-SALES-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RTWK.DAT  
ORGANIZATION IS LINE SEQUENTIAL. 
DATA DIVISION. 
FILE SECTION. 
FD SALES-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SALES-RECORD. 
01 SALES-RECORD 
PIC X(58). 
01 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
PRINT-LINE 
PIC X(132). 
SD SORT-WORK-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SORT-RECORD. 

Two-L 
e veI 
Control 
Breaks 
(continued) 
32 
01 SORT-RECORD. 
33 
05 SORT-ACCOUNT-NUMBER 
PIC 9(6). 
34 
05 FILLER 
PIC X. 
35 
05 SORT-NAME 
PIC X(15). 
36 
05 FILLER 
PIC X(10). 
37 
05 SORT-LOCATION 
PIC X(15). 
38 
05 SORT-REGION 
PIC X(ll). 
39 
40 
FD SORTED-SALES-FILE 
41 
RECORD CONTAINS 58 CHARACTERS 
42 
DATA RECORD IS SORTED-SALES-RECORD. 
43 
01 SORTED-SALES-RECORD 
PIC X(58). 
44 
45 
WORKING-STORAGE SECTION. 
46 
01 FILLER 
PIC X(14) 
47 
A Q 
VALUE 'WS BEGINS HERE
1. 
4o 
49 
01 SALES-RECORD-IN. 
50 
05 SR-ACCOUNT-NUMBER 
PIC 9(6). 
51 
05 FILLER 
PIC X. 
52 
05 SR-NAME 
PIC X(15). 
53 
05 SR-SALES 
PIC S9(4). 
54 
05 FILLER 
PIC XX. 
55 
05 SR-COMMISSION-PERCENT 
PIC V99. 
56 
05 FILLER 
PIC XX. 
57 
05 SR-LOCATION 
PIC X(15). 
58 
05 SR-REGION 
PIC X(ll). 
59 
60 
01 PROGRAM-SWITCHES-AND-COUNTERS 
61 
05 DATA-REMAINS-SW 
PIC X(3) 
VALUE 'YES'. 
62 
88 NO-DATA-REMAINS 
VALUE 'NO'. 
63 
05 PREVIOUS-NAME 
PIC X(15) VALUE SPACES 
64 
05 PREVIOUS-LOCATION 
PIC X(15) VALUS SPACES 
65 
05 PAGE-COUNT 
PIC 99 
VALUE ZEROES 
66 
67 
01 CONTROL-BREAK-TOTALS. 
68 
05 INDIVIDUAL-TOTALS. 
69 
10 IND-COMMISSION 
PIC S9(4). 
70 
05 SALESPERSON-TOTALS. 
71 
10 SALESPERSON-SALES-TOT PIC S9(6). 
72 
10 SALESPERSON-COMM-TOT PIC S9(6). 
73 
05 LOCATION-TOTALS. 
j 
74 
10 LOCATION-SALES-TOT 
PIC S9(6). Y 
75 
10 LOCATION-COMM-TOT 
PIC S9(6). 
76 
05 COMPANY-TOTALS. 
77 
10 COMPANY-SALES-TOT 
PIC S9(6) VALUE ZEROS. 
78 
10 COMPANY-COMM-TOT 
PIC S9(6) VALUE ZEROS. 
79 
80 
01 REPORT-HEADING-LINE. 
81 
05 FILLER 
PIC X(25) VALUE SPACES 

Chapter 
15 -
Control 
Brea 
gyre 15.8 
(continued) 
82 
83 
84 
85 
86 
87 
05 FILLER 
PIC X(21) 
VALUE 'SALES ACTIVITY REPORT'. 
05 FILLER 
PIC X(19) 
VALUE SPACES. 
05 FILLER 
PIC X(5) 
VALUE 'PAGE ' 
05 HDG-PAGE 
PIC 19. 
05 FILLER 
PIC X(60) 
VALUE SPACES. 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
01 
LOCATION-HEADING-LINE. 
05 FILLER 
05 FILLER 
VALUE 'LOCATION: 
05 HDG-LOCATION 
05 FILLER 
01 
01 
01 
PIC X(8) 
PIC X(10) 
PIC X(19) 
PIC X(95) 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
01 
SALESPERSON-HEADING-LINE-ONE. 
05 FILLER 
PIC X(15) VALUE SPACES. 
05 FILLER 
PIC X(13) 
VALUE 'SALESPERSON: '. 
05 HDG-NAME 
PIC X(15). 
05 FILLER 
PIC X(89) VALUE SPACES. 
SALESPERSON-HEADING-LINE-TWO. 
05 FILLER 
PIC X(23) VALUE SPACES. 
05 FILLER 
PIC X(ll) VALUE 'ACCOUNT # 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
05 FILLER 
PIC X(5) 
VALUE 'SALES'. 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
05 FILLER 
PIC X(10) VALUE 'COMMISSION 
05 FILLER 
PIC X(66) VALUE SPACES. 
DETAIL-LINE. 
05 FILLER 
PIC X(25) VALUE SPACES. 
05 
DET-ACCOUNT-NUMBER 
PIC 9(6). 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
05 DET-SALES 
PIC Z(3),ZZ9-. 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
05 DET-COMMISSION 
PIC Z(3),ZZ9-. 
05 FILLER 
PIC X(69) VALUE SPACES. 
DASHED-LINE. 
05 FILLER 
PIC X(40) VALUE SPACES. 
05 FILLER 
PIC X(8) 
VALUE ALL '-'. 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
05 FILLER 
PIC X(8) 
VALUE ALL '-'. 
05 FILLER 
PIC X(69) VALUE SPACES. 
SALESPERSON-TOTAL-LINE. 
05 FILLER 
PIC X(15) 
05 FILLER 
PIC X(21) 
VALUE SPACES. 
ioGCs 
VALUE 
SALESPERSON TOTAL'. 

Two-Level 
Control 
Break 
s 
M 
(continued) 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
132 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
133 
05 SALESPERSON-SALES-TOTAL 
PIC $Z(3),ZZ9-. 
134 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
135 
05 SALESPERS0N-C0MM-T0TAL 
PIC $Z(3),ZZ9-. 
136 
05 FILLER 
PIC X(69) VALUE SPACES. 
137 
138 
01 LOCATION-TOTAL-LINE. 
139 
05 FILLER 
PIC X(13) VALUE SPACES. 
140 
05 FILLER 
PIC X(19) 
141 
VALUE '**** LOCATION TOTAL'. 
142 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
143 
05 LOCATION-SALES-TOTAL 
PIC $Z(3) 
.ZZ9-. 
144 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
145 
05 LOCATION-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
146 
05 FILLER 
PIC X(69) 
VALUE SPACES. 
147 
148 
01 COMPANY-TOTAL-LINE. 
149 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
150 
05 FILLER 
PIC X(22) 
151 
VALUE '******** COMPANY TOTAL' . 
152 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
153 
05 COMPANY-SALES-TOTAL 
PIC $Z(3),ZZ9-. 
154 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
155 
05 COMPANY-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
156 
05 FILLER 
PIC X(69) VALUE SPACES. 
PROCEDURE DIVISION. 
100-PREPARE-SALES-REPORT. 
PERFORM 200-S0RT-TRANSACTI0N-FILE. 
OPEN INPUT SORTED-SALES-FILE 
OUTPUT PRINT-FILE. 
PERFORM 220-READ-SORTED-SALES-FILE. 
PERFORM 240-PR0CESS-0NE-L0CATI0N 
UNTIL NO-DATA-REMAINS. 
PERFORM 260-WRITE-C0MPANY-T0TAL. 
CLOSE SORTED-SALES-FILE 
PRINT-FILE. 
STOP RUN. 
200-SORT-TRANSACTION-FILE. 
SORT SORT-WORK-FILE 
ASCENDING KEY 
SORT-LOCATION 
SORT-NAME 
WITH DUPLICATES IN ORDER 
USING SALES-FILE 
GIVING SORTED-SALES-FILE. 
220-READ-SORTED-SALES-FILE. 
READ SORTED-SALES-FILE INTO SALES-RECORD-IN 

Chapter 
15 
Control 
Breaks 
~i^uj& 
(continued) 
182 
AT END MOVE 'NO' TO DATA-REMAINS-SW 
183 
END-READ. 
184 
185 
240-PR0CESS-0NE-L0CATI0N. 
186 
J^ERFOJW_30j)-JN^ 
/ ' 
187 
[PJRFORM 320^-WRITE-LOCAJ[IOtj-HE]\DIJ^ K 
188 
PERFORM 340-PROCESS-ONE-SALESPERSON 
189 
UNTIL SR-LOCATION NOT EQUAL PREVIOUS-LOCATION 
190 
OR NO-DATA-REMAINS. 
1 9 1 
f ^ ™? ^
3 ^ ^
1 ^ ^ 
192 
PERFORM 380-1NCREMENT-COMPANY-TOTAL. 
193 
194 
260-WRITE-COMPANY-TOTAL. 
195 
MOVE COMPANY-SALES-TOT TO COMPANY-SALES-TOTAL. 
196 
MOVE COMPANY-COMM-TOT TO COMPANY-COMM-TOTAL. 
197 
WRITE PRINT-LINE FROM COMPANY-TOTAL-LINE 
198 
AFTER ADVANCING 2 LINES. 
199 
200 
300-INITIALIZE-LOCATION. 
201 
MOVE SR-LOCATION TO PREVIOUS-LOCATION. 
202 
INITIALIZE LOCATION-TOTALS. 
203 
204 
320-WRITE-L0CATION-HEADING. 
205 
ADD 1 TO PAGE-COUNT. 
206 
MOVE PAGE-COUNT TO HDG-PAGE. 
207 
WRITE PRINT-LINE FROM REPORT-HEADING-LINE 
208 
AFTER ADVANCING PAGE. 
209 
MOVE SR-LOCATION TO HDG-LOCATION. 
210 
WRITE PRINT-LINE FROM LOCATION-HEADING-LINE 
211 
AFTER ADVANCING 2 LINES. 
212 
213 
340-PROCESS-ONE-SALESPERSON. 
214 
PERFORM 400-INITIALIZE-SALESPERSON. 
215 
PERFORM 420-WRITE-SALESPERSON-HEADING. 
216 
PERFORM 440-PR0CESS-0NE-TRANSACTI0N 
217 
UNTIL SR-NAME NOT EQUAL PREVIOUS-NAME 
218 
! OR SR-LOCATION NOT EQUAL PREVIOUS-LOCATION ! 
219 
OR NO-DATA-REMAINS. 
220 
PERFORM 460-WRITE-SALESPERSON-TOTAL. 
221 
PERFORM 480-INCREMENT-LOCATION-TOTAL. 
222 
223 
360-WRITE-LOCATION-TOTAL. 
224 
MOVE LOCATION-SALES-TOT TO LOCATION-SALES-TOTAL. 
225 
MOVE LOCATION-COMM-TOT TO LOCATION-COMM-TOTAL. 
226 
WRITE PRINT-LINE FROM LOCATION-TOTAL-LINE 
227 
AFTER ADVANCING 1 LINE. 
228 
MOVE SPACES TO PRINT-LINE. 
229 
WRITE PRINT-LINE 
230 
AFTER ADVANCING 1 LINE. 
231 
232 
380-INCREMENT-COMPANY-TOTAL. 

Two-Level 
Control 
Breaks 
(continued) 
233 
) ADD LOCATION-SALES-TOT TO COMPANY-SALES-TOT. | Lu 
234 
j ADD L0CATI0N-C0MM-T0T TO j;0MPANY-C0MM-T0T. J 
235 
" ~
~
" " " ~ " " 
" 
236 
400-INITIALIZE-SALESPERSON. 
237 
MOVE SR-NAME TO PREVIOUS-NAME. 
238 
INITIALIZE SALESPERSON-TOTALS. 
239 
240 
420-WRITE-SALESPERSON-HEADING. 
241 
MOVE SR-NAME TO HDG-NAME. 
242 
WRITE PRINT-LINE FROM SALESPERSON-HEADING-LINE-ONE 
243 
AFTER ADVANCING 1 LINE. 
244 
WRITE PRINT-LINE FROM SALESPERSON-HEADING-LINE-TWO 
245 
AFTER ADVANCING 1 LINE. 
246 
247 
440-PR0CESS-0NE-TRANSACTI0N. 
248 
PERFORM 500-CALCULATE-C0MMISSI0N. 
249 
PERFORM 520-WRITE-DETAIL-LINE. 
250 
PERFORM 540-INCRMENT-SALESPERS0N-T0TAL. 
251 
PERFORM 220-READ-SORTED-SALES-FILE. 
252 
253 
460-WRITE-SALESPERS0N-T0TAL. 
254 
WRITE PRINT-LINE FROM DASHED-LINE 
255 
AFTER ADVANCING 1 LINE. 
256 
MOVE SALESPERSON-SALES-TOT TO SALESPERSON-SALES-TOTAL 
257 
MOVE SALESPERSON-COMM-TOT TO SALESPERSON-COMM-TOTAL. 
258 
WRITE PRINT-LINE FROM SALESPERSON-TOTAL-LINE 
259 
AFTER ADVANCING 1 LINE. 
260 
MOVE SPACES TO PRINT-LINE. 
261 
WRITE PRINT-LINE 
262 
AFTER ADVANCING 1 LINE. 
263 
264 
480-INCREMENT-LOCATION-TOTAL. 
265 
["ADD 
S T L I S ^ 
266 
j ADD SALESPERSON-COMM-TOT TO LOCATION-COMM-TOT. i 
267 
268 
500-CALCULATE-COMMISSION. 
269 
COMPUTE IND-COMMISSION ROUNDED = 
270 
SR-SALES * SR-COMMISSION-PERCENT 
271 
SIZE ERROR DISPLAY 'SIZE ERROR ON COMMISSION FOR 
272 
SR-NAME 
273 
END-COMPUTE. 
274 
275 
520-WRITE-DETAIL-LINE. 
276 
MOVE SR-ACCOUNT-NUMBER TO DET-ACCOUNT-NUMBER. 
277 
MOVE SR-SALES TO DET-SALES. 
278 
MOVE IND-COMMISSION TO DET-COMMISSION. 
279 
WRITE PRINT-LINE FROM DETAIL-LINE. 
280 
281 
540-INCRMENT-SALESPERSON-TOTAL. 
282 
ADD SR-SALES TO SALESPERSON-SALES-TOT. 
283 
ADD IND-COMMISSION TO SALESPERSON-COMM-TOT. 

Chapter 
15 
— 
Control 
Breaks 
The Working-Storage Section contains every statement from the previous 
program plus additional entries to accommodate the second control break. T h e 
location heading and total lines are defined in lines 89-94 and 138-146, respectively. 
There are n e w counters for the location totals, L O C A T I O N - S A L E S - T O T , a n d 
L O C A T I O N - C O M M - T O T , and a n e w data n a m e , P R E V I O U S - L O C A T I O N , to detect 
the control break o n location. The n e w entries are shaded in the listing for emphasis. 
The S O R T statement (lines 172-178) specifies two keys, S O R T - L O C A T I O N and 
S O R T - N A M E , to sort the transaction file by location and salesperson within location. 
The W I T H D U P L I C A T E S IN O R D E R phrase keeps the transactions for a given 
salesperson in sequence by account n u m b e r since the input file (Figure 15.1) w a s 
already in sequence by account number. 
The remaining statements in the Procedure Division are straightforward and 
easy to follow, given the earlier discussion of the hierarchy chart and associated 
pseudocode. Observe, for example, the paragraph to increment the c o m p a n y totals 
(lines 232-234), in which location totals are rolled into the c o m p a n y totals. Note, 
too, the c o m p o u n d condition in the P E R F O R M statement of lines 216-219 to detect 
a control break o n salesperson. 
W e return to the reports of Figures 15.2, 15.3, a n d 15.4, which s h o w e d 
the progression of one-, two-, and three-level control breaks. This time, w e will 
expand the hierarchy chart, pseudocode, and C O B O L program from two to three 
levels. 
Hierarchy Chart 
The three-level hierarchy chart will be developed as an extension of the existing 
two-level hierarchy chart. Accordingly, w e will compare the two- and three-level 
reports in Figures 15.3b a n d 15.4b, then consider the following questions with 
respect to the existing chart: 
1. W h a t additional (i.e., new) modules are necessary? 
2. W h i c h existing modules (if any) have to be modified? 
3. W h i c h existing modules (if any) have to be deleted? 
Every module that appeared in the two-level hierarchy chart will also appear in the 
three-level version; n o modules will be deleted because every function from the 
two-level example is also required in the three-level example. Several n e w functions 
are necessary to a c c o m m o d a t e the control break o n region. These include: 
1. P R O C E S S - O N E - R E G I O N to process all locations in one region 
2. INITIALIZE-REGION to initialize the sales and commission totals for this 
region 
3. W R I T E - R E G I O N - H H A D I N G to print a region heading for each n e w region 
4. I N C R E M E N T - R E G I O N - T O T A L to increment the sales a n d commission totals 
for each region 
5. W R I T E - R E G I O N - T O T A L to print region totals after a break o n region 
Changes will also be required in the logic of s o m e existing modules—for 
example, a change in S O R T - T R A N S A C T I O N - F I L E to reflect a sort o n region, 
location within region, and salesperson within location. It will also be necessary 
to change W R I T E - L O C A T I O N - H E A D I N G , which previously began the report for 
ontrol Breaks 

Three-Level 
Control 
Breaks 
each location o n a n e w page, but which n o w lists all locations in the same region 
o n the same page. 
The computation of the c o m p a n y totals also changes. The two-level example 
waited for a control break on location, then rolled the location total into the c o m p a n y 
total. T h e same approach could be used in the three-level example, but it is m o r e 
efficient to wait for a control break o n region, then roll the region total into the 
c o m p a n y total. 
The hierarchy chart for the three-level problem is s h o w n in Figure 15.9a, with 
the additional and/or modified modules shaded for emphasis. T h e placement of 
the n e w modules is important, and you should notice that the module P R O C E S S -
O N E - R E G I O N appears o n the second level of the hierarchy chart, which in turn 
forces the existing module P R O C E S S - O N E - L O C A T I O N , and all of its subordinates, 
d o w n a level. 
Figure 15.9b is subject to the same design considerations as its predecessor, 
namely, completeness, functionality, and span of control. All design criteria appear 
satisfactory and the hierarchy chart is finished. 
Three-Level Algorithm 
SORT 
TRANSACTION 
FILE 
INITIALIZE 
LOCATION 
INITIALIZE 
SALESPERSON 
CALCULATE 
COMMISSION 
PREPARE 
SALES 
REPORT 
READ 
SORTED 
SALES-FILE 
WRITE 
REGION 
HEADING 
WRITE 
LOCATION 
HEADING 
WRITE 
SALESPERSON 
HEADING 
PROCESS 
ONE 
REGION 
PROCESS 
ONE 
LOCATION 
PROCESS ONE 
SALESPERSON 
PROCESS ONE 
TRANSACTION 
INCREMENT 
SALESPERSON 
TOTAL 
WRITE 
COMPANY 
TOTAL 
WRITE 
REGION 
TOTAL 
WRITE 
LOCATION 
TOTAL 
WRITE 
SALESPERSON 
TOTAL 
V 
READ 
SORTED 
SALES-FILE 
(a) Hierarchy Chart 
INCREMENT 
COMPANY 
TOTAL 
INCREMENT 
REGION 
TOTAL 
INCREMENT 
LOCATION 
TOTAL 

Chapter 
15 
Control 
Breaks 
(continued) 
Sort transaction file on region, location, and salesperson 
Open sorted-file, print-file 
Read first record 
— PERFORM UNTIL no more data 
Initialize region totals 
MOVE SR-REGION to PREVIOUS-REGION 
Write region heading 
PERFORM UNTIL REGION NOT EQUAL PREVIOUS-REGION 
or no more data 
Initialize location totals 
MOVE SR-LOCATION to PREVIOUS-LOCATION 
Write location heading 
:- PERFORM UNTIL SR-LOCATION NOT EQUAL PREVIOUS-LOCATION 
or SR-REGION NOT EQUAL PREVIOUS-REGION 
or no more data 
Initialize salesperson totals 
MOVE SR-NAME to PREVIOUS-NAME 
Write salesperson heading 
I 
PERFORM UNTIL SR-NAME NOT EQUAL PREVIOUS-NAME 
or SR-LOCATION NOT EQUAL PREVIOUS-LOCATION 
or SR-REGION NOT EQUAL PREVIOUS-REGION 
or no more data 
Calculate commission 
Write detail line 
Increment salesperson totals 
Read next record 
- ENDPERFORM 
Write salesperson totals 
Increment location totals 
- ENDPERFORM 
Write location totals 
Increment region totals 
ENDPERFORM 
Write region totals 
Increment company totals by region totals 
-ENDPERFORM 
Write company totals 
Close files 
Stop run 
The pseudocode for the two-level control break is expanded to its three-level 
counterpart in Figure 15.9b. N e w and/or modified statements are highlighted to be 
consistent with the associated hierarchy chart. 

Three-Level 
Control 
Breaks 
The sort statement includes region as an additional key as previously indicated. 
The major change, however, is the modification of the outer loop to include a series 
of repetitive statements for each n e w region that initialize the region totals, write 
the region heading, and process all locations in that region. T h e detection of a 
control break o n region occurs w h e n S R - R E G I O N is unequal to P R E V I O U S - R E G I O N , 
and produces the region total, which is then rolled into the c o m p a n y total. 
Within each region, there is a second loop (carried over from the two-level 
application) to process all locations in that region. A c o m p o u n d condition, that 
includes location and region, is necessary to detect a control break o n location in 
the unusual instance where the last location in the current region a n d the first 
location in the next region have the same n a m e . (This is in accordance with the 
general rule to detect a control break, which includes a c o m p o u n d condition that 
checks the level you are on, as well as any levels above the current level. Note, 
therefore, the c o m p o u n d condition associated with a control break o n salesperson 
that includes salesperson, location, and region.) 
The completed program is s h o w n in Figure 15.10 and reflects all of the indicated 
changes. Once again, w e call your attention to the relationship between the hierarchy 
chart in Figure 15.9a and the paragraphs in the Procedure Division. T h e modules in 
the hierarchy chart correspond one to one with the paragraphs in the program. 
Observe also that each level in the hierarchy chart can be matched with a C O B O L 
P E R F O R M statement. 
The Working-Storage Section contains every statement from the previous 
program plus additional entries to accommodate the second control break. T h e 
region heading and total lines are defined in lines 93-96 and 157-165, respectively. 
There are n e w counters for the region totals, REGION-SALES-TOT, a n d R E G I O N -
C O M M - T O T , a n d a n e w data n a m e , P R E V I O U S - R E G I O N , to detect the control 
break o n region. The n e w entries are shaded in the listing for emphasis. 
The S O R T statement (lines 191-198) specifies three k e y s — S O R T - R E G I O N , 
S O R T - L O C A T I O N , and S O R T - N A M E — t o sort the transaction file by region, location 
within region, a n d salesperson within location. The W I T H D U P L I C A T E S IN O R D E R 
phrase keeps the transactions for a given salesperson in sequence by account n u m b e r 
since the input file (Figure 15.1) was already in sequence by account number. 
The remaining statements in the Procedure Division are straightforward and 
easy to follow given the earlier discussion of the hierarchy chart a n d associated 
pseudocode. Observe, for example, the paragraph to increment the c o m p a n y totals 
(lines 249-251), in which region totals are rolled into the c o m p a n y totals. Note, too, 
the c o m p o u n d condition in the P E R F O R M statement of lines 236-239 to detect a 
control break on salesperson. 
Three-Level Control Break Program 
l 
2 
3 
4 
5 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
THRLEVEL. 
AUTHOR. 
CVV. 
ENVIRONMENT DIVISION. 

Chapter 
CI 
(continued) 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT SALES-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RTIN.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE 
ASSIGN TO PRINTER. 
SELECT SORT-WORK-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RTWK.DAT'. 
SELECT SORTED-SALES-FILE 
ASSIGN TO 'A:\CHAPTR15\S0RT0UT.DAT 
ORGANIZATION IS LINE SEQUENTIAL. 
DATA DIVISION. 
FILE SECTION. 
FD SALES-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SALES-RECORD. 
01 SALES-RECORD 
PIC X(58). 
FD PRINT-FILE 
RECORD CONTAINS 132 CHARACTERS 
DATA RECORD IS PRINT-LINE. 
01 PRINT-LINE 
PIC X(132). 
SD SORT-WORK-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SORT-RECORD. 
01 SORT-RECORD. 
05 SORT-ACCOUNT-NUMBER 
PIC 9(6). 
05 FILLER 
PIC X. 
05 SORT-NAME 
PIC X(15). 
05 FILLER 
PIC X(10). 
05 SORT-LOCATION 
PIC X(15). 
05 SORT-REGION 
PIC X(ll). 
FD SORTED-SALES-FILE 
RECORD CONTAINS 58 CHARACTERS 
DATA RECORD IS SORTED-SALES-RECORD. 
01 SORTED-SALES-RECORD 
PIC X(58). 
WORKING-STORAGE SECTION. 
01 FILLER 
PIC X(14) 
VALUE "WS BEGINS HERE'. 
01 SALES-RECORD-IN. 
05 SR-ACCOUNT-NUMBER 
PIC 9(6). 
05 FILLER 
PIC X. 
05 SR-NAME 
PIC X(15). 

Three-Level 
Control 
Breaks 
(continued) 
53 
05 SR-SALES 
PIC S9(4). 
54 
05 FILLER 
PIC XX. 
55 
05 SR-COMMISSION-PERCENT 
PIC V99. 
56 
05 FILLER 
PIC XX. 
57 
05 SR-LOCATION 
PIC X(15). 
—- Region is 
control fit 
58 
! 05 SR-REGION 
PIC X(ll). k 
' 
—- Region is 
control fit 
59 
60 
01 PROGRAM-SWITCHES-AND-COUNTERS 
61 
05 DATA-REMAINS-SW 
PIC X(3) 
VALUE 'YES'. 
62 
88 
NO-DATA-REMAINS 
VALUE 'NO'. 
63 
05 PREVIOUS-NAME 
PIC X(15) 
VALUE SPACES. 
64 
05 PREVIOUS-LOCATION 
PIC X(15) 
VALUE SPACES. 
65 
1 05 PREVIOUS-REGION 
PIC X(ll) 
VALUE SPACES. '<r 
66 
05 PAGE-COUNT 
PIC 99 
VALUE ZEROES. 
67 
68 
01 CONTROL-BREAK-TOTALS. 
69 
05 INDIVIDUAL-TOTALS. 
70 
10 
IND-COMMISSION 
PIC S9{4). 
71 
05 SALESPERSON-TOTALS. 
72 
10 
SALESPERSON-SALES-TOT PIC S9(6). 
73 
10 
SALESPERSON-COMM-TOT PIC S9{6). 
74 
05 LOCATION-TOTALS. 
7
E 
/ 
J 
10 
LOCATION-SALES-TOT 
PIC S9(6). 
76 
10 
LOCATION-COMM-TOT 
PIC S9(6). 
Region to 
three-leve 
77 
05 REGION-TOTALS. 
Region to 
three-leve 
78 
10 
REGION-SALES-TOT 
PIC S9(6). 
79 
10 
REGION-COMM-TOT 
PIC S9(6). 
80 
05 COMPANY-TOTALS. 
81 
10 
COMPANY-SALES-TOT 
PIC S9(6) 
VALUE ZEROS. 
82 
10 
COMPANY-COMM-TOT 
PIC S9(6) 
VALUE ZEROS. 
83 
84 
01 REPORT-HEADING-LINE. 
85 
05 FILLER 
PIC X(25) 
VALUE SPACES. 
86 
05 FILLER 
PIC X(21) 
87 
VALUE 'SALES ACTIVITY REPORT'. 
88 
05 FILLER 
PIC X(19) 
VALUE SPACES. 
89 
05 FILLER 
PIC X(5) 
VALUE 'PAGE '. 
90 
05 HDG-PAGE 
PIC Z9. 
91 
05 FILLER 
PIC X(60) 
VALUE SPACES. 
92 
93 
01 REGION-HEADING-LINE. 
94 
05 FILLER 
PIC X(8) 
VALUE 'REGION: '. 
95 
05 HDG-REGION 
PIC X(ll) 
VALUE SPACES. 
96 
05 FILLER 
PIC X(113) VALUE SPACES. 
97 
98 
01 LOCATION-HEADING-LINE. 
99 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
jlais ate added to 
' ptogram 
Region heading 
added to three-it 
prog rain 

C
h
a
p
t
e
r 
1 5 
— 
Control 
Breaks 
F i g u r e 15.10 
(continued) 
100 
05 FILLER 
PIC X(10) 
101 
VALUE 'LOCATION: 
102 
05 HDG-LOCATION 
PIC X(19) VALUE SPACES. 
103 
05 FILLER 
PIC X(95) VALUE SPACES. 
104 
105 
01 SALESPERSON-HEADING-LINE-ONE. 
106 
05 FILLER 
PIC X(15) 
VALUE SPACES. 
107 
05 FILLER 
PIC X(13) 
108 
VALUE 'SALESPERSON: '. 
109 
05 HDG-NAME 
PIC X(15). 
110 
05 FILLER 
PIC X(89) VALUE SPACES. 
111 
112 
01 SALESPERSON-HEADING-LINE-TWO. 
113 
05 FILLER 
PIC X(23) VALUE SPACES. 
114 
05 FILLER 
PIC X(ll) VALUE 'ACCOUNT 
115 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
116 
05 FILLER 
PIC X(5) 
VALUE 'SALES'. 
117 
05 FILLER 
PIC X(8) 
VALUE SPACES. 
118 
05 FILLER 
PIC X(10) VALUE MMISSION 
119 
05 FILLER 
PIC X(66) VALUE SPACES. 
120 
121 
01 DETAIL-LINE. 
122 
05 FILLER 
PIC X(25) VALUE SPACES. 
123 
05 DET-ACCOUNT-NUMBER 
PIC 9(6). 
124 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
125 
05 DET-SALES 
PIC Z(3),ZZ9-. 
126 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
127 
05 DET-COMMISSION 
PIC Z(3),ZZ9-. 
128 
05 FILLER 
PIC X(69) VALUE SPACES. 
129 
130 
01 DASHED-LINE. 
131 
05 FILLER 
PIC X(40) VALUE SPACES. 
132 
05 FILLER 
PIC X(8) 
VALUE ALL 
133 
05 FILLER 
PIC X(7) 
VALUE SPACES. 
134 
05 FILLER 
PIC X(8) 
VALUE ALL '-'. 
135 
05 FILLER 
PIC X(69) VALUE SPACES. 
136 
137 
01 SALESPERSON-TOTAL-LINE. 
138 
05 FILLER 
PIC X(15) VALUE SPACES. 
139 
05 FILLER 
PIC X(21) 
140 
VALUE '** SALESPERSON TOTAL'. 
141 
05 FILLER 
PIC X(3) 
VALUE SPACES. 
142 
05 SALESPERSON-SALES-TOTAL 
PIC $Z(3),ZZ9-. 
143 
05 FILLER 
PIC X(6) 
VALUE SPACES. 
144 
05 SALESPERSON-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
145 
05 FILLER 
PIC X(69) VALUE SPACES. 
146 

Three-Level 
Control 
Breaks 
re 15,10 
(continued) 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
01 
LOCATION-TOTAL-LINE. 
01 
01 
05 FILLER 
PIC X(13) VALUE SPACES 
05 FILLER 
PIC X(19) 
VALUE '**** LOCATION TOTAL'. 
05 FILLER 
PIC X(7) 
VALUE SPACES 
05 LOCATION-SALES-TOTAL 
PIC $Z(3) 
,ZZ9-. 
05 FILLER 
PIC X(6) 
VALUE SPACES 
05 LOCATION-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
05 FILLER 
PIC X(69) 
VALUE SPACES 
REGION-TOTAL-LINE. 
05 FILLER 
PIC X(ll) VALUE SPACES 
05 FILLER 
PIC X(19) 
VALUE '****** REGION TOTAL
1. 
05 FILLER 
PIC X(9) 
VALUE SPACES. 
05 REGION-SALES-TOTAL 
prr $7ni ,779-. 
05 FILLER 
PIC X(6) 
VALUE SPACES 
05 REGION-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
05 FILLER 
PIC X(69) VALUE SPACES 
COMPANY-TOTAL-LINE. 
05 FILLER 
PIC X(9) 
VALUE SPACES 
05 FILLER 
PIC X(22) 
VALUE ********* COMPANY TOTAL
1. 
05 FILLER 
PIC X(8) 
VALUE SPACES 
05 COMPANY-SALES-TOTAL 
PIC $Z(3) 
.ZZ9-. 
05 FILLER 
PIC X(6) 
VALUE SPACES 
05 COMPANY-COMM-TOTAL 
PIC $Z(3),ZZ9-. 
05 FILLER 
PIC X(69) VALUE SPACES 
PROCEDURE DIVISION. 
100-PREPARE-SALES-REPORT. 
PERFORM 200-SORT-TRANSACTION-FIL.E. 
OPEN INPUT SORTED-SALES-FILE 
OUTPUT PRINT-FILE. 
PERFORM 220-READ-SORTED-SALES-FILE. 
PERFORM 240-PR0CESS-0NE-REGI0N 
UNTIL NO-DATA-REMAINS. 
PERFORM 260-WRITE-COMPANY-TOTAL. 
CLOSE SORTED-SALES-FILE 
PRINT-FILE. 
STOP RUN. 
200-S0RT-TRANSACTI0N-FILE. 
SORT SORT-WORK-FILE 
ASCENDING KEY 
SORT-REGION 

C
h
a
p
t
e
r 
1 5 
Control 
Breaks 
lure I S . t O 
(continued) 
194 
! 
SORT-LOCATION 
195 
SORT-NAME 
196 
W I T H D U P L I C A T E S IN O R D E R 
197 
U S I N G S A L E S - F I L E 
198 
G I V I N G S O R T E D - S A L E S - F I L E . 
199 
200 
2 2 0 - R E A D - S O R T E D - S A L E S - F I L E . 
201 
READ S O R T E D - S A L E S - F I L E INTO S A L E S - R E C O R D - I N 
202 
A T E N D M O V E 'NO' T O DATA-REMAINS-SW 
203 
END-READ. 
204 
205 
2 4 0 - P R 0 C E S S - 0 N E - R E G I 0 N . 
^-Region 
heading written for each new region 
206 
PERFORM 3 0 0 - I N I T I A L I Z E - R E G I 0 N . 
207 
[PERFORM 3 2 0 - W R I T E - R E G I O N - H E A D I N G T ] ^ 
2 0 8 
PERFORM 3 4 0 - P R 0 C E S S - 0 N E - L 0 C A T I 0 N 
209 
U N T I L SR-REGION N O T EQUAL PREVIOUS-REGION 
210 
_ 
O R N O - D A T A - R E M A I N S . 
211 
| PERFORM 360-I^ITE-RW0N-T0TAL71 
212 
PERFORM 3 8 0 - I N C R E M E N T - C O M P A N Y - T O T A L . 
Region total written alter cont'd break ctetec 
213 
214 
2 6 0 - W R I T E - C 0 M P A N Y - T 0 T A L . 
215 
MOVE C O M P A N Y - S A L E S - T O T T O C O M P A N Y - S A L E S - T O T A L . 
216 
MOVE C O M P A N Y - C O M M - T O T T O C O M P A N Y - C O M M - T O T A L . 
217 
W R I T E P R I N T - L I N E FROM C O M P A N Y - T O T A L - L I N E 
218 
A F T E R A D V A N C I N G 2 LINES. 
2 1 9 
220 
3 0 0 - I N I T I A L I Z E - R E G I O N . 
221 
M O V E S R - R E G I O N T O PREVIOUS-REGION. 
222 
INITIALIZE R E G I O N - T O T A L S . 
223 
224 
3 2 0 - W R I T E - R E G I O N - H E A D I N G . 
2 2 5 
A D D 1 TO PAGE-COUNT. 
226 
M O V E P A G E - C O U N T T O H D G - P A G E . 
227 
W R I T E P R I N T - L I N E FROM R E P O R T - H E A D I N G - L I N E 
2 2 8 
A F T E R A D V A N C I N G P A G E . 
229 
MOVE S R - R E G I O N T O H D G - R E G I O N . 
2 3 0 
WRITE P R I N T - L I N E FROM R E G I O N - H E A D I N G - L I N E 
231 
A F T E R A D V A N C I N G 2 LINES. 
2 3 2 
233 
3 4 0 - P R O C E S S - O N E - L O C A T I O N . 
234 
PERFORM 4 0 0 - I N I T I A L I Z E - L O C A T I O N . 
2 3 5 
PERFORM 4 2 0 - W R I T E - L 0 C A T I 0 N - H E A D I N G . 
236 
PERFORM 4 4 0 - P R 0 C E S S - 0 N E - S A L E S P E R S 0 N 
237 
U N T I L S R - L O C A T I O N N O T EQUAL P R E V I O U S - L O C A T I O N 
2 3 8 
O R SR-REGION N O T EQUAL P R E V I O U S - R E G I O N 
2 3 9 
O R N O - D A T A - R E M A I N S . 
240 
PERFORM 4 6 0 - W R I T E - L 0 C A T I 0 N - T 0 T A L . 
Keys in SORT statement match control breaks 

Three-Level 
Control 
Breaks 
1© 
(continued) 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
2 5 8 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
PERFORM 480-INCREMENT-REGION-TOTAL. 
360-WRITE-REGI0N-T0TAL. 
M O V E REGION-SALES-TOT T O REGION-SALES-TOTAL. 
M O V E REGION-COMM-TOT T O REGION-COMM-TOTAL. 
W R I T E PRINT-LINE FROM REGION-TOTAL-LINE 
A F T E R A D V A N C I N G 1 LINE. 
380-INCREMENT-COMPANY-TOTAL. 
ADD REGION-SALES-TOT TO COMPANY-SALES-TOT. 
ADD REGION-COMM-TOT TO COMPANY-COMM-TOT. 
400-INITIALIZE-L0CATI0N. 
M O V E SR-LOCATION T O PREVIOUS-LOCATION. 
INITIALIZE LOCATION-TOTALS. 
420-WRITE-LOCATION-HEADING. 
MOVE SR-LOCATION TO HDG-LOCATION. 
W R I T E PRINT-LINE FROM LOCATION-HEADING-LINE 
A F T E R A D V A N C I N G 1 LINE. 
4 4 0 - P R 0 C E S S - 0 N E - S A L E S P E R S 0 N . 
PERFORM 500-INITIALIZE-SALESPERSON. 
PERFORM 
520-WRITE-SALESPERSON-HEADING. 
PERFORM 540-PR0CESS-0NE-TRANSACTI0N 
U N T I L SR-NAME NOT EQUAL PREVIOUS-NAME 
O R SR-LOCATION NOT EQUAL PREVIOUS-LOCATION 
OR SR-REGION N O T EQUAL PREVIOUS-REGION 
OR NO-DATA-REMAINS. 
PERFORM 560-WRITE-SALESPERSON-TOTAL. 
PERFORM 580-INCREMENT-LOCATION-TOTAL. 
4 6 0 - W R I T E - L 0 C A T I 0 N - T 0 T A L . 
M O V E LOCATION-SALES-TOT T O LOCATION-SALES-TOTAL. 
M O V E LOCATION-COMM-TOT T O LOCATION-COMM-TOTAL. 
W R I T E P R I N T - L I N E FROM LOCATION-TOTAL-LINE 
A F T E R A D V A N C I N G 1 LINE. 
M O V E SPACES T O P R I N T - L I N E . 
W R I T E PRINT-LINE 
A F T E R A D V A N C I N G 1 LINE. 
4 8 0 - I N C R E M E N T - R E G I O N - T O T A L . 
j A D D LOCATION-SALES-TOT T O RIGION-SALES-TOTVI 
[ADD LOCATION-COMM-TOT TO REGION-COMM-TOT. [ 
5 0 0 - I N I T I A L I Z E - S A L E S P E R S O N . 
M O V E SR-NAME T O P R E V I O U S - N A M E . 

C
h
a
p
t
e
r 
1 5 
— 
Control 
Breaks 
Figure 15.10 
(continued) 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
INITIALIZE SALESPERSON-TOTALS. 
520-WRITE-SALESPERSON-HEADING. 
MOVE SR-NAME TO HDG-NAME. 
WRITE PRINT-LINE FROM SALESPERSON-HEADING-LINE-ONE 
AFTER ADVANCING 1 LINE. 
WRITE PRINT-LINE FROM SALESPERSON-HEADING-LINE-TWO 
AFTER ADVANCING 1 LINE. 
540-PR0CESS-0NE-TRANSACTI0N. 
PERFORM 600-CALCULATE-COMMISSION. 
PERFORM 620-WRITE-DETAIL-LINE. 
PERFORM 640-INCREMENT-SALESPERSON-TOTAL. 
PERFORM 220-READ-SORTED-SALES-FILE. 
560-WRITE-SALESPERSON-TOTAL. 
WRITE PRINT-LINE FROM DASHED-LINE 
AFTER ADVANCING 1 LINE. 
MOVE SALESPERSON-SALES-TOT TO SALESPERSON-SALES-TOTAL. 
MOVE SALESPERSON-COMM-TOT TO SALESPERSON-COMM-TOTAL. 
WRITE PRINT-LINE FROM SALESPERSON-TOTAL-LINE 
AFTER ADVANCING 1 LINE. 
MOVE SPACES TO PRINT-LINE. 
WRITE PRINT-LINE 
AFTER ADVANCING 1 LINE. 
580-INCREMENT-LOCATION-TOTAL. 
ADD SALESPERSON-SALES-TOT TO LOCATION-SALES-TOT. 
ADD SALESPERSON-COMM-TOT TO LOCATION-COMM-TOT. 
Sales pe 
into loci 
600-CALCULATE-COMMISSION. 
COMPUTE IND-COMMISSION ROUNDED = 
SR-SALES * SR-COMMISSION-PERCENT 
SIZE ERROR DISPLAY 'SIZE ERROR ON COMMISSION FOR 
SR-NAME 
END-COMPUTE. 
620-WRITE-DETAIL-LINE. 
MOVE SR-ACCOUNT-NUMBER TO DET-ACCOUNT-NUMBER. 
MOVE SR-SALES TO DET-SALES. 
MOVE IND-COMMISSION TO DET-COMMISSION. 
WRITE PRINT-LINE FROM DETAIL-LINE. 
640-INCRMENT-SALESPERS0N-T0TAL. 
ADD SR-SALES TO SALESPERSON-SALES-TOT. 
ADD IND-COMMISSION TO SALESPERSON-COMM-TOT. 

mmary 
P R O G R A M M I N G 
T I P 
The algorithm for one-, two-, and three-level control breaks follows a general pattern that can be adopted for 
any control break application and/or any number of levels. We suggest, therefore, that you review the 
hierarchy chart, pseudocode, and/or COBOL programs that were developed in this chapter and see how 
those examples fit a general pattern. 
Start by determining the number of levels in the application, their relative importance (sort order), and 
corresponding field names. Identify the field names that will be used to detect a control break at each level— 
for example, SR-REGION, SR-LOCATION, and SR-NAME in the three-level example used in the text. 
Modify the hierarchy chart, pseudocode, and COBOL listings from the chapter to accommodate your 
specific application. Begin with the highest (most important) level and do the following for every level: 
1. Initialize the control totals for this level 
2. Initialize the field name to detect a control break at this level with the previous value 
3. Write the heading for this level (if any) 
4. Process this level until the field name at this level is not equal to the previous value 
OR the field name at a higher level is not equal to the previous value 
OR no data remains 
5. Write this level's total (if required) 
6. Increment the next higher level's total (rolling total) 
At the lowest (transaction) level: 
1. Perform the necessary calculations (if any) 
2. Write a detail line (if any) 
3. Increment the lowest level's total (running total) 
4. Read the next record 
There are no specific enhancements in COBOL-85 intended to facilitate the 
processing of control breaks. Accordingly, all of the listings in this chapter 
could be made to run under COBOL-74 with only minor modification, such as 
the removal of the END-READ scope terminator, and the WITH DUPLICATES 
clause in the sort statement; the latter would require an additional sort key on 
account number. 

Chapter 
15 — 
Control 
Breaks 
U M M A R Y 
Points to 
Remember 
A control break is a change in a designated (control) field; any file used to 
process control breaks must be in sequence according to the control field. 
Control breaks may occur at multiple levels; for example, a two-level 
control break occurs when two control fields change simultaneously; in 
similar fashion a three-level control break occurs when three control fields 
change simultaneously. 
» 
There is no theoretical limit to the number of control breaks; there is a 
practical limit, however, in that most people lose track after three (or at 
most four) levels. 
Programs for one-, two-, and three-level control breaks are developed 
according to a genera! algorithm; the importance of a hierarchy chart and 
pseudocode in the design process cannot be over-emphasized. 
A running total is incremented by the value of the corresponding fieid in 
every transaction; a rolling total is incremented by a lower-level-control 
total only after a control break has occurred; rolling totals are more efficient 
than running totals. 
ICejf Words and 
Concepts 
Compound condition 
Pseudocode 
Control field 
Rolling total 
Control total 
Running total 
Control break 
Three-level control break 
Hierarchy chart 
Two-level control break 
One-level control break 
/ 
A / 
1. A 
in a designated field is known as a 
2. Any file used to process control breaks must be in 
according to 
the control fields. 
3. it (is/is not) possible for data in a given record to produce a control break on more 
than one field. 
4. Control break processing (is/is not) limited to one level. 
5. A program's hierarchy chart is best developed (before/after) the program is written. 
6. The more significant field in a two-level control break application is known as the 
field, whereas the less significant field is the 
field. 

7. (Pseudocode/hierarchy charts) depict a program's logic and decision-making 
sequence. 
8. A COBOL program to process control breaks (requires/does not require) the file to 
be in sequence. 
9. Running totals are (more/less) efficient than rolling totals. 
10. A 
total increments the value of a counter after every record. 
11. A 
total increments the value of a counter after a control break. 
T R U t f F A L S E 
1. Control break processing is restricted to a single level. 
2. Input to a control break program need not be in any special order. 
3. Modules in a hierarchy chart and paragraphs in a COBOL program correspond 
one to one. 
4. A hierarchy chart depicts decision-making logic. 
5. Each level In a hierarchy chart corresponds to a COBOL PERFORM statement. 
6. A two-level control break occurs when two control fields change simultaneously. 
7. A three-level control break implies the occurrence of one- and two-level control 
breaks as well. 
8. A three-level control breaks requires that three control totals be computed at each 
level. 
9. Rolling totals is a more efficient means of computation than running totals 
10. A rolling total increments a counter for every transaction. 
PROBLEMS 
1. Return once more to the two-level program in Figure 15.8 and note that the 
PERFORM statement to detect a break in salesperson (lines 188-190) includes the 
clause SR-LOCATION NOT EQUAL PREVIOUS-LOCATION. Why? (What would 
happen if this clause were not present and the last salesperson in one location had 
the same name as the first salesperson in the next location?) State a generalized 
rule for the compound condition in PERFORM statements that is needed to detect 
control breaks. 
2. What would be the consequences of omitting the SORT statement in the one-level 
control break program of Figure 15.6; that is, describe the appearance of the 
resulting report if the unsorted transaction file of Figure 15.1 were used in lieu of the 
sorted file in Figure 15.2a. Explain in general terms the consequences of omitting 
the SORT statement in any of the programs contained in the chapter. 
3. The one-level program of Figure 15.6 uses the data names SALESPERSON-SALES-
TOT and COMPANY-SALES-TOT to accumulate totals. 
a. Which data name(s) are computed as a running total? When, and by what 
amount, is the total incremented? 
b. Which data name(s) are computed as a rolling total? When, and by what 
amount, is the total incremented? 

C
h
a
p
t
e
r 
1 5 
— 
Control 
Breaks 
c. Repeat parts (a) and (b) for the two-level program of Figure 15.8. Answer for the 
data names SALESPERSON-SALES-TOT, LOCATION-SALES-TOT, and 
COMPANY-SALES-TOT. 
d. Repeat parts (a) and (b) for the three-level program of Figure 15.10. Answer for 
the data names SALESPERSON-SALES-TOT, LOCATION-SALES-TOT, REGION-
SALES-TOT, and COMPANY-SALES-TOT. 
4. The hypothetical Continental University is composed of multiple colleges, with 
each college divided into multiple departments. The central administration wants to 
know the total number of students in a variety of categories and uses a university-
wide ENROLLMENT-FILE to compute the desired totals. The following fields are 
present in each enrollment record: COLLEGE, DEPARTMENT, YEAR, NUMBER-
OF-STUDENTS. Identify the control fields and sorting sequence to produce each of 
the following reports. (Each report is to be treated independently.) 
a. The number of students in each year 
b. The number of students in each department 
c. The number of students in each college 
d. The number of students in each college and within college, the number of 
students in each department 
e. The number of students in each college and within college, the number of 
students In each year 

Overview 
S u b p r o g r a m s 
Called and Calling Programs 
COPY Statement 
Calling BY CONTENT and BY REFERENCE 
INITIAL C l a u s e 
A S y s t e m for P h y s i c a l F i t n e s s 
Programming Specifications 
Hierarchy Chart 
Pseudocode 
T h e C o m p l e t e d P r o g r a m s 
Main Program (FITNESS) 
Input Program (INPUTSUB) 
Weight-Range Program (WGTSUB) 
Training Program (TRAINSUB) 
Display Program (DSPLYSUB) 
Time Program (TIMESUB) 
T h e L i n k a g e Editor 
Problems with the Linkage Editor 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
16 
Subprograms 
OBJECTIVES 
After reading this chapter you will be able to: 
I 
Define a subprogram and describe its implementation in COBOL. 
I 
Distinguish between a called and calling program; describe the use of a 
hierarchy chart to show the relationship of programs within a system. 
State the purpose of the COPY statement; indicate where it may be used 
within a program and how it can be used to pass a parameter list. 
Distinguish between the BY CONTENT and BY REFERENCE clauses as 
they relate to subprograms. 
Explain the function of the INITIAL phrase in the PROGRAM-ID paragraph. 
Describe the purpose of the linkage-editor; explain the meaning of an 
unresolved external reference. 
O V E R V I E W 
This chapter introduces the concept of subprograms in order to develop a 
system of programs associated with physical fitness. Each program is compiled 
as a separate entity, after which the individual object programs are linked 
together to produce a single load module. The chapter includes material on all 
necessary COBOL elements as well as a conceptual discussion on the role of 
the link program (linkage-editor). 
The COBOL presentation begins with the CALL statement and associated 
parameter list in the calling program, then presents the relationship with data 
names defined in the LINKAGE SECTION of the called program. It describes the 
different ways of passing parameters, either BY REFERENCE or BY CONTENT, 
and introduces the COPY statement as a means of simplifying program 
development. 
The chapter also serves as an effective review of earlier material in that the 
various subprograms utilize many features from previous chapters. Thus, we 
once again emphasize the importance of data validation from Chapter 8, illustrate 
advanced statements from the Procedure Division as covered in Chapter 9, 
review the screen I/O capabilities presented in Chapter 10, and incorporate 
material on both one- and two-level tables from Chapters 11 through 13. 

The P E R F O R M statement has been used throughout the text to divide a program 
into functional paragraphs, each of which is executed as necessary from elsewhere 
within the program. T h e individual paragraphs are developed in stages a n d 
implemented in hierarchical fashion through top-down testing. T h e individual 
paragraphs are, in effect, subroutines that are written, compiled, a n d executed 
within the m a i n program. 
Alternatively, the performed routines m a y be developed as independent 
entities, k n o w n as subprograms, 
that are written and compiled separately from the 
main 
(calling) 
program. 
The subprograms within the same system m a y even be 
written by different programmers, but they are always executed under control of 
the main program. Subprograms bring to a system all the advantages of modularity 
that functional paragraphs bring to a program; for example, a change in one 
subprogram should not affect the internal workings of another subprogram nor the 
overall flow of the system. And, like the paragraphs in a program, the subprograms 
in a system m a y be developed and tested in top-down fashion. 
A subprogram contains the four divisions of a regular program, a n d in addition, 
a L I N K A G E S E C T I O N in its Data Division to hold the data passed to a n d from the 
calling program. Figure 16.1 contains statements extracted from the listings at the 
end of the chapter to illustrate the use of subprograms. In this example, the calling 
program contains the logic to accept persona! data from a user regarding the 
individual's height, age, a n d sex. It passes control to the sub (called) program 
W G T S U B , which determines the ideal range for the person's weight based o n the 
data received. The C A L L statement in the calling program matches the entry in the 
P R O G R A M - I D paragraph of the called program ( W G T S U B ) . 
The C A L L statement transfers control to the first executable statement in the 
called program. The C A L L statement contains a U S I N G clause, which specifies the 
data o n which the called program is to operate. The called program in turn contains 
a U S I N G clause in its Procedure Division header, indicating which data it is to 
receive from the calling program. T h e data n a m e s in either U S I N G clause are 
k n o w n collectively as the parameter 
or argument 
list. 
The data n a m e s in the two parameter lists can (but need not) be the same, but 
the order and structure of data n a m e s within the list is critical. T h e first item in the 
parameter list of the calling program is F I T N E S S - R E C O R D , and corresponds to the 
first item in the parameter list of the called program, which is also called ITTNESS-
R E C O R D . In similar fashion, the second and third items in the calling program 
( W E I G H T - F R O M a n d W E I G H T - T O ) correspond to the second and third items in 
the subroutine ( L S - W E I G H T - F R O M and LS-WEIGHT-TO). The picture clauses of 
the individual parameters (arguments) are the same, but the data n a m e s are different. 
The arguments in the calling program are defined either in the File Section or 
in Working-Storage, whereas the arguments in the called program m u s t be defined 
in the Linkage 
Section. T h e parameters in either program must be defined as 01 or 
elementary items; that is, group items (other than 01 entries) cannot be passed to a 
subprogram. 
Execution of the C A L L statement in the m a i n program transfers control to the 
first executable statement of the subprogram, which executes exactly as a regular 
C O B O L program; the latter is terminated by an EXIT P R O G R A M statement that 
returns control to the calling program at the statement immediately after the CALL. 
The example in Figure 16.1 included only two programs, one calling program arid 
one called program. M o r e complex arrangements are also possible, for example: 

Chapter 
16 — 
Subprograms 
p r e 1(6.1 
COBOL Statements for a Subprogram 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
FITNESS. 
DATA DIVISION. 
FILE SECTION. 
FD 
FITNESS-FILE 
DATA RECORD IS FITNESS-RECORD. 
01 
FITNESS-RECORD. 
05 FULL-NAME 
PIC X(19). 
05 HEIGHT 
PIC 99. 
05 SEX 
PIC X. 
05 AGE 
PIC 99. 
WORKING-STORAGE SECTION. 
05 WEIGHT-FROM 
PIC 9(3). 
05 WEIGHT-TO 
PIC 9(3). 
PROCEDURE DIVISION. 
CALL WGTSUB 
USING FITNESS-RECORD, WEIGHT-FROM, WEIGHT-TO 
END-CALL. 
(Z) Mam program 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
WGTSUB. 
iLINKAGE SECTION. 
01 LS-WEIGHT-FROM 
PIC 9(3). 
01 LS-WEIGHT-TO 
PIC 9(3). 
01 
FITNESS-RECORD. 
05 FULL-NAME 
PIC X(19). 
05 HEIGHT 
PIC 99. 
05 SEX 
PIC X. 
05 AGE 
PIC 99. 
PROCEDURE DIVISION 
USING FITNESS-RECORD, LS-WEIGHT-FROM, LS-WEIGHT-TO. 
i EXIT PROGRAM. \ 
(b) Subprogram 
1. O n e program can call multiple subprograms; for example, program A can 
call programs B, C, D, and E. 
2. O n e program c a n be called from different programs; for example, program F 
can be called from programs B and C. 

3. The s a m e program can be both a called and calling program; for example, 
program A calls program B, which in turn calls program F. (Program E is 
both a called and calling program.) 
A hierarchy chart depicts the relationship of various programs to one another 
within a system, just as it shows the relationship of paragraphs within a program. 
The hierarchy chart in Figure 16.2, for example, illustrates the relationships just 
expressed. Thus, program A sits at the top of the hierarchy chart and calls programs 
B, C, D, and E. Program F is s h o w n twice in the hierarchy chart, indicating that it 
(program F) is called from programs B and C. Programs B and C function as both 
called a n d calling programs; they are called from program A a n d in turn call 
program F. 
Called and Calling Programs 
PROGRAM 
A 
PROGRAM 
PROGRAM 
C 
PROGRAM 
F 
PROGRAM 
D 
PROGRAM 
E 
PROGRAM 
F 
T h e 
C O P Y Statement 
The data n a m e s used within different programs of the s a m e system are often 
interrelated because the s a m e file is apt to be referenced by several programs. The 
C O P Y statement facilitates the development of such programs by allowing the 
programmer to code a one-line C O P Y statement, which brings the associated entries 
into the C O B O L program. 
Figure 16.3 contains a C O P Y statement in which the programmer coded the 
line C O P Y T R A I N C P Y in line 27. The C O B O L compiler locates the file T R A I N C P Y , 
and brings in lines 28-34 as though the programmer had coded t h e m explicitly. The 
compiler inserts a C after the statement n u m b e r in the source listing to indicate a 
copied statement. 
A C O P Y statement m a y be used anywhere within a C O B O L program, except 
that the text being copied cannot contain another COPY. The syntax of the C O P Y 
statement is simply: 
COPY text-name 

Chapter 
16 
Subprograms 
F i g u . ^ 1&..3 The COPY Statement 
27 
28C 
29C 
30C 
31C 
32C 
33C 
34C 
COPY TRAINCPY. 
01 TRAINING-ARGUMENTS. 
05 TRAINING-INPUTS. 
10 TRAIN-AGE 
10 TRAIN-FITNESS-LEVEL 
PIC 99. 
PIC X. 
05 TRAINING-RANGES. 
10 TRAIN-OVERALL-RANGE 
10 TRAIN-FITNESS-RANGE 
PIC X(5). 
PIC X(5). 
where text-name is the n a m e of a file (member, or element) that exists independently 
of the C O B O L program. A C O P Y statement is not restricted to subprograms; it can 
be used with any C O B O L program. C O P Y statements offer the following advantages: 
1. Individual programmers need not code the extensive Data Division entries 
that can m a k e C O B O L so tedious; a programmer can code a one-line C O P Y 
statement, a n d the compiler will bring the proper entries into the program. 
2. A n y change that affects multiple programs is m a d e only once, in the library 
version of the C O P Y element. Subsequent compilations of all programs 
containing a C O P Y statement for that element will automatically bring in the 
updated version. 
3. Programming errors are reduced through standardization a n d c o m m o n 
definition of data elements. All fields within a record description (or other 
copied element) in one program will always be correct a n d consistent with the 
definition in other programs using the s a m e copied element. 
O n e of the most important principles of structured design is program independence, 
which minimizes (eliminates) the effect one program has o n another. The optional 
USING BY CONTENT phrase prevents the values of parameters created in the 
calling program from being changed by the called program. Consider: 
[END-CALL] 
and an example: 
CALL 'SUBRIN' USING FIELD-A 
BY CONTENT FIELD-B FIELD-C 
BY REFERENCE FIELD-D. 
The C A L L statement passes four arguments, FIELD-A, FIELD-B, FIELD-C, a n d 
FIELD-D, to a subprogram that manipulates any or all of these parameters (referring 
to them by its o w n data n a m e s as defined in its L I N K A G E SECTION). However, the 
U S I N G B Y C O N T E N T phrase will restore the values of FIELD-B and FIELD-C to 
their initial values w h e n control is returned to the calling program, despite any 
changes m a d e to the corresponding parameters by the called program. 
CALL program 

ubprog 
rams 
P R O G R A M M I N G 
T I P 
The order of arguments in the CALL USING and P R O C E D U R E DIVISION USING clauses of the calling and 
called programs is critical. You can reduce the chance for error by using a C O P Y clause to pass parameters 
as shown. Consider: 
Poor 
Code: 
CALL 'WGTSUB' 
USING HEIGHT, SEX, AGE, WEIGHT-FROM, WEIGHT-TO 
END-CALL. 
PROCEDURE DIVISION 
USING LS-HEIGHT, LS-SEX, LS-AGE, LS-WGT-FROM, LS-WGT-TO. 
improved 
Code: 
COPY WGTLST. 
01 WEIGHT-TABLE-ARGUMENTS. 
05 WT-HEIGHT 
PIC 99. 
05 WT-SEX 
PIC X. 
05 WT-AGE 
PIC 99. 
05 WT-FR0M 
PIC 9(3). 
05 WT-T0 
PIC 9(3) 
CALL 'WGTSUB' 
USING WEIGHT-TABLE-ARGUMENTS 
END-CALL. 
LINKAGE SECTION. 
COPY WGTLST. 
01 WEIGHT-TABLE-ARGUMENTS. 
05 WT-HEIGHT 
PIC 99. 
05 WT-SEX 
PIC X. 
05 WT-AGE 
PIC 99. 
05 WT-FR0M 
PIC 9(3). 
05 WT-T0 
PIC 9(3). 
PROCEDURE DIVISION 
USING WEIGHT-TABLE-ARGUMENTS. 
Use of the single 01 parameter facilitates coding in the USING clauses and also makes them immune to 
change. Use of the same C O P Y member in both programs eliminates any problem with listing arguments in 
the wrong order or inconsistent definition through different pictures. 
N o such restriction is placed o n the value of FIELD-A, which will retain any 
value computed in the called program. The value of FIELD-D will also reflect changes 
m a d e b y the called program, as it (FIELD-D) w a s specified in a U S I N G B Y 
REFERENCE phrase; that is, U S I N G B Y R E F E R E N C E is equivalent to a C A L L 
statement with neither phrase. 

Chapter 
16 
Subprograms 
•A\ 
\ * ~ t C A s t w i ^ f e 
The INITIAL clause in the PROGRAM-ID paragraph restores a program to its initial 
state each time it is called; that is, all data n a m e s in Working-Storage are reset to 
their original values via any V A L U E clauses that are present. Consider: 
PROGRAM-ID. program-name [IS INITIAL PROGRAM]. 
The INITIAL clause makes it possible to start with an original (unmodified) copy of 
a called program every time it is executed. Alternatively, omission of the phrase 
causes every execution of a called program to begin with the values established in 
the latest (previous) execution. 
- 
x - vr l „ . C
3
T
h
e 
material o n subprograms will be incorporated into a system for physical fitness 
- 2 
m a t obtains input from a user, determines various aspects of the individual's fitness, 
t /, ^ ^ 
then displays the results at the e n d of processing. T h e individual programs illustrate 
"" 
~ 
the transfer of control a n d passing of parameters between a called a n d calling 
program, a n d also review C O B O L material from earlier chapters as described in the 
chapter overview. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
Physical Fitness System 
Narrative: 
The specifications call for a series of programs that constitute a system for physical 
fitness. A screen I/O program will accept and verify various inputs from a user, such as 
age, sex, and height, then pass control to a series of subprograms to compute the 
desired weight and target heart range at different levels of fitness. 
Input Files: 
There are no input or output files as all data are entered and displayed interactively via 
screen I/O. Figure 16.4 contains a sample screen for a hypothetical individual named 
Mr. Fit. The inputs provided by Mr. Fit are highlighted in the top half of the screen. The 
diagnostic messages produced by the system show Mr. Fit's weight of 185 to be within 
the desired range for his age, sex, and height. The system also suggests a target (10-
second) heart rate (after exercise) between 27 and 30 in accordance with his advanced 
fitness level. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Develop a series of programs that constitute a system for physical fitness as described 
below: 
a. A main program to govern the overall system and pass control to various 
subprograms as appropriate 
b. A subprogram to accept and validate an individual's personal data 
c. A subprogram to compute a goal weight based on an individual's sex, height, and 
age. 
d. A subprogram to compute a target heart rate (after sustained cardiovascular 
exercise) based on age and fitness level 
e. A subprogram to display the computed results for weight and target heart rate 
2. The main program is to control the overall system by passing (receiving) control from 
the various subprograms. The system is to execute continually—that is, for multiple 
individuals—until it receives a response that no one else wishes to use the system. 

A 
System 
tor 
Physical 
Fitness 
3. The input program is to accept the following fields as indicated in Figure 16.4: Name, 
Age, Sex, Weight, Height, and Fitness level. Validation checks are required as follows: 
a. A name must be entered 
b. Age must be 18 or higher 
c. Sex must be male or female; the system should accept both upper- and lowercase 
letters as valid characters, 
d. Height is to be entered in inches and must be consistent with the tables available to 
the system; valid male heights are between 60 and 76 inches; valid female heights 
must be between 54 and 74 inches. 
e. The fitness level should be entered as a single letter, B, I, or A, corresponding to 
Beginner, Intermediate, or Advanced. The system should accept both upper- and 
lowercase letters as valid characters. 
The input program is to display appropriate prompts and error messages for each of 
these fields. In addition, it should also display the current time as shown in the upper 
right portion of Figure 16.4. 
4. The goal weight is determined from a person's sex, height, and age as shown in the 
tables of Figure 16.5. 
5. The minimum and maximum target (training) heart ranges, expressed for a 10-second 
period after exercise, are determined from an individual's age according to the 
formulas: 
Minimum target (10 seconds) = .60 * (220 - AGE) / 6 
Maximum target (10 seconds) = .90 * (220 - AGE) / 6 
The target range can also be adjusted according to the individual's fitness level and 
the range between the maximum and minimum values; that is, those at a beginner's 
level of fitness should aim for a target heart range in the lower third of the interval, 
those with intermediate fitness in the middle third, and those at an advanced level in 
the upper third. 
Figure 16.4 Fitness Screen 
) 
Personal Fitness Evaluation 
j 
Full Name: Mr. Fit 
I 
Age: 22 
Weight: 185 
| 
Sex (M/F): M 
Height: 74 
11:53:10 
j 
I 
I 
i 
I 
Fi tness Level: A 
} 
B - Beginner 
j 
I - Intermediate 
j 
A - Advanced 
\ 
Your Goal Weight Range: 163-196 
CONGRATULATIONS! You are within the range 
Training Heart Rate Range Information (10 Second) 
Overall Heart Rate Range: 20-30 
Adjusted for Fitness Level: 27-30 
Another Person (Y/N): 

C
h
a
p
t
e
r 
16 — 
Subprograms 
Height 
(in inches) 
Age (in years) 
Height 
(in inches) 
18 
19-20 
21-22 
23-24 
25 & Over 
54 
83-99 
84-101 
85-103 
86-104 
88-106 
55 
84-100 
85-102 
86-104 
88-105 
90-107 
56 
86-101 
87-103 
88-105 
90-106 
92-108 
57 
89-102 
90-104 
91-106 
92-108 
94-110 
58 
91-105 
92-106 
93-109 
94-111 
96-113 
59 
93-109 
94-111 
95-113 
96-114 
99-116 
60 
96-112 
97-113 
98-115 
100-117 
102-119 
61 
100-116 
101-117 
102-119 
103-121 
105-122 
62 
104-119 
105-121 
106-123 
107-125 
108-126 
63 
106-125 
107-126 
108-127 
109-129 
111-130 
64 
109-130 
110-131 
111-132 
112-134 
114-135 
65 
112-133 
113-134 
114-136 
116-138 
118-139 
66 
116-137 
117-138 
118-140 
120-142 
122-143 
67 
121-140 
122-142 
123-144 
124-146 
126-147 
68 
123-144 
124-146 
126-148 
128-150 
130-150 
69 
130-148 
131-150 
132-152 
133-154 
134-155 
70 
134-151 
135-154 
136-156 
137-158 
138-159 
71 
138-155 
139-158 
140-160 
141-162 
142-163 
72 
142-160 
143-162 
144-164 
145-166 
146-167 
73 
146-164 
147-166 
148-168 
149-170 
150-171 
74 
150-168 
151-170 
152-172 
153-174 
154-175 
(a) Goal Weights for Women 
Height 
(in inches) 
Age (in years) 
Height 
(in inches) 
18 
19-20 
21-22 
23-24 
25 & Over 
60 
109-122 
110-133 
112-135 
114-137 
115-138 
61 
112-126 
113-136 
115-138 
117-140 
118-141 
62 
115-130 
116-139 
118-140 
120-142 
121-144 
63 
118-135 
119-143 
121-145 
123-147 
124-148 
64 
120-145 
122-147 
124-149 
126-151 
127-152 
65 
124-149 
125-151 
127-153 
129-155 
130-156 
66 
128-154 
129-156 
131-158 
133-160 
134-161 
67 
132-159 
133-161 
134-158 
136-165 
138-166 
68 
135-163 
136-165 
138-167 
140-169 
142-170 
69 
140-163 
141-169 
142-171 
144-173 
146-174 
70 
143-170 
144-173 
146-175 
148-178 
150-179 
71 
147-177 
148-179 
150-181 
152-183 
154-184 
72 
151-180 
152-184 
154-186 
156-188 
158-189 
73 
155-187 
156-189 
158-190 
160-193 
162-194 
74 
160-192 
161-194 
163-196 
165-198 
167-199 
75 
165-198 
166-199 
168-201 
170-203 
172-204 
76 
170-202 
171-204 
173-206 
175-208 
177-209 
(b) Goal Weights for Men 
Figure 16.5 
Table of Goal Weights 

A System 
for 
Physical 
Fitness 
The hierarchy chart has been used throughout the text to indicate the required 
functions within a COBOL program. It can also be used to indicate the relationship 
of programs within a system as s h o w n in Figure 16.6. 
Figure 16.6 Hierarchy Chart of the Overall System 
FITNESS 
EVALUATION 
(FITNESS) 
INPUT 
PERSONAL 
DATA 
(INPUTSUB) 
DETERMINE 
GOAL WEIGHT 
(WGTSUB) 
DETERMINE 
TRAINING 
RANGE 
(TRAINSUB) 
DISPLAY 
EVALUATION 
RESULTS 
(DSPLYSUB) 
w 
DISPLAY 
UPDATED 
TIME 
(TIMESUB) 
DISPLAY 
UPDATED 
TIME 
(TIMESUB) 
The module at the top of the hierarchy chart, F I T N E S S - E V A L U A T I O N , is the 
main program for the overall system; it has four subordinates (subprograms) in 
accordance with the processing specifications: INPUT-PERSONAL-DATA, 
DETERMINE-GOAL-WEIGHT, DETERMINE-TRAINING-RANGE, a n d DISPLAY-
EVALUATION-RESULTS. (The entries in parentheses correspond to the n a m e of 
the program as it appears in the PROGRAM-ID paragraph.) A sixth program, 
DISPLAY-UPDATED-TIME, is subordinate to the programs to accept and display 
the data. 
The logic for the overall system (main program) is contained in the pseudocode of 
Figure 16.7. T h e main program is driven by a single loop to process multiple 
individuals (as per the second processing specification) until a negative response is 
received regarding continuation. This is consistent with the corresponding prompt 
at the bottom of Figure 16.4, which asks whether there is another user. 
The logic within the loop is straightforward a n d passes control from one 
subprogram to the next in sequential fashion. Note, however, the requirement to 
establish a parameter list prior to calling each subprogram, a n d further, h o w the 
parameter lists for the different subprograms contain different variables. Observe 
also that the parameter list for the last program references 
another-person-switch, 
which determines whether execution is to continue. 

C
h
a
p
t
e
r 
16 
Subprograms 
Pseudocode 
I 
j 
DO WHILE user wants to continue 
j 
CALL INPUTSUB subprogram to get personal information 
| 
Establish parameter list (height, age, sex, weight-from, weight-to) 
' 
for WGTSUB program 
I 
Call WGTSUB program to determine weight goals 
j 
Establish parameter list (age, fitness-level, overall-range, 
j 
fitness-range) for TRAINSUB program 
j 
Call TRAINSUB program to determine training ranges 
j 
Establish parameter list (training ranges, weight-goals, 
j 
another-person-swi tch) for DSPLYSUB program 
| 
Call DSPLYSUB program to display results and request continuation 
1 
•— ENDDO 
i 
Stop run 
| 
i . j , c\ v..-*., 
The next several pages contain listings for the completed programs according to the 
description in Table 16.1. W e have, however, in the interest of space, omitted the 
pseudocode a n d hierarchy chart for the individual programs. 
Main Program ( F I T N E S S ) 
.. 
The m a i n program in Figure 16.8 contains neither an Environment Division nor a 
File Section as all input/output operations are accomplished via the screen. T h e 
Working-Storage Section consists largely of four C O P Y statements corresponding 
to the parameter lists for each of the four called programs. The programmer codes a 
single statement, such as C O P Y I N P U T R E C in line 10. T h e compiler locates the file 
I N P U T R E C and brings in lines 11 through 26 as though the programmer h a d coded 
them explicitly. 
The mainline paragraph in lines 69-76 corresponds exactly to the pseudocode 
in Figure 16.7. The INITIALIZE statement in line 79 clears the parameters passed to 
the input program a n d is necessary so that the input values from one user are not 
carried over to the next user. T h e C A L L statement in lines 80-82 transfers control to 
the input subprogram, using a single parameter, I N P U T - I N F O R M A T I O N , which is 
copied into both programs. 
A different parameter list is created immediately prior to calling each of the 
remaining subprograms; for example, lines 85-87 m o v e the data n a m e s for age, 
height, a n d sex—obtained from the input subprogram—to the corresponding data 
n a m e s in the parameter list for the weight program. Observe also h o w the C A L L 
statement uses a single 01 entry, W E I G H T - A R G U M E N T S , as the parameter list and 
further, h o w the entry is copied into the program (line 40). T h e s a m e technique is 
used prior to the C A L L statement for the training program in lines 95-97, and prior 
to the C A L L statement for the final display program in lines 105-107. 

The 
Completed 
Programs 
Physical Fitness System 
FITNESS 
INPUTSUB 
TRA1NSUE 
Calls INPUTSUB, WGTSUB, 
Figure 16.1 
TRAINSUB, and DSPLYSUB 
Called from FITNESS; calls 
TIMESUB 
Caiied from FITNESS 
Called from FITNESS 
Figure 16.10 
Figure 16.11 
The mam program governs the overall system; it 
passes control to the input subprogram, which 
accepts input from the user, passes control to the 
weight and training programs, then passes control 
to the display subprogram that displays the 
calculated results. The main program executes 
continually until the user elects to exit. 
Figure 16.9 
The input subprogram obtains all required inputs 
from the user (name, age, sex, height, and fitness 
level), validating each field as it is entered. The 
program reviews the screen section that was first 
presented in Chapter 10. 
The weight subprogram accepts an individual's 
sex, height, and age, then determines a range for 
the person's desired weigh!. The program reviews 
two-level tables as presented in Chapter 12. 
The training subprogram determines an individual's 
target heart rate according to age and fitness level. 
The program reviews various Procedure Division 
statements and scope terminators from earlier 
chapters. 
DSPLYSUB 
Called from Fl TNESS; calls 
Figure 16.12 
The display subprogram updates the original 
TIMESUB 
screen created by the input program, using various 
options for the ACCEPT and DISPLAY statements, 
thus reviewing additional material from Chapter 10. 
TIMESUB 
Called from INPUTSUB and 
Figure 16.13 
The time subprogram is included to show that a 
DSPLYSUB 
subprogram need not contain a Linkage Section, 
and further that it can be called from multiple 
calling programs. It also illustrates the means of 
obtaining the current time from the system and 
reference modification. 
Fitness Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
FITNESS. 
3 
AUTHOR. 
CVV. 
4 
5 
DATA DIVISION. 
6 
WORKING-STORAGE SECTION. 
7 
01 FILLER 
PIC X(36) 
8 
VALUE 'WS BEGINS HERE FOR FITNESS PROGRAM'. 

C
h
a
p
t
e
r 
1 6 — 
Subprogram 
ire 16.8 
(continued) 
10 
COPY INPUTREC. 
! STCPY> 
12 
I 
13 
1 
14 
! 
15 
! 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
E0CPY> 
27 
28 
STCPY> 
30 
31 
32 
33 
34 
35 
36 
37 
EDCPY> 
39 
40 
STCPY> 
42 
43 
44 
45 
46 
47 
48 
49 
EDCPY> 
01 INPUT-INFORMATION. 
05 INP-FULL-NAME 
88 MISSING-NAME 
INP-AGE 
88 INVALID-AGES 
INP-SEX 
88 VALID-SEX 
88 MALE 
88 FEMALE 
INP-HEIGHT 
INP-WEIGHT 
88 INVALID-WEIGHTS 
VALUES 0 THRU 70 500 THRU 999. 
INP-FITNESS-LEVEL 
PIC X. 
88 VALID-FITNESS-LEVELS 
VALUES 'B' 'I' 'A' 'b' 'i' ' a ' 
05 
05 
05 
05 
05 
PIC X(30). 
VALUE SPACES. 
PIC 99. 
VALUES 0 THRU 17. 
PIC X. 
VALUES 
VALUES 
VALUES 
m 
V 
'f 
PIC 99. 
PIC 9(3). 
01 
COPY TRAINCPY. 
TRAINING-ARGUMENTS. 
05 TRAINING-INPUTS. 
10 TRAIN-AGE 
TRAIN-FITNESS-LEVEL 
10 
PIC 99. 
PIC X. 
88 
88 
88 
BEGINNER 
INTERMEDIATE 
ADVANCED 
VALUE 'B' 'b' 
VALUE '1
1 'i
1 
VALUE 'A' 'a' 
05 TRAINING-RANGES. 
10 TRAIN-OVERALL-RANGE 
PIC X(5). 
10 TRAIN-FITNESS-RANGE 
PIC X(5). 
"•Lowercase responses are accepted 
COPY WGTCOPY. 
01 WEIGHT-ARGUMENTS. 
05 WEIGHT-TABLE-INPUTS. 
10 WGT-HEIGHT 
10 WGT-AGE 
10 WGT-SEX 
88 MALE 
88 FEMALE 
05 WEIGHT-GOALS. 
10 GOAL-WGT-FROM 
-Startof COPY AREA 
PIC 99. 
PIC 99. 
PIC X. 
VALUE 'M' 'm'. 
VALUE ' F' 'f . 
10 GOAL-WGT-TO K 
PIC 999. 
PIC 999. 
€OOPYAREA 
51 
52 
COPY DISPCPY. 
STCPY> 
01 DISPLAY-ARGUMENTS. 
54 
05 DISP-TRAINING-RANGES. 
55 
10 DISP-TRAIN-OVERALL-RANGE 
PICX(5). 
56 
10 DISP-TRAIN-FITNESS-RANGE 
PIC X(5). 
57 
05 DISP-WEIGHT-GOALS. 
58 
10 DISP-GOAL-WGT-FROM 
PIC ZZ9. 
59 
10 DISP-GOAL-WGT-TO 
PIC ZZ9. 

The 
Completed 
Programs 
(continued) 
60 
61 
62 
EDCPY> 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
8 2 
83 
84 
8 5 
8 6 
87 
8 8 
8 9 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
05 
DISP-INPUT-WEIGHT 
05 
A N O T H E R - P E R S O N - S W I T C H 
8 8 
NO-MORE-PERSONS 
8 8 
V A L I D - A N O T H E R 
PIC 9 ( 3 ) . 
PIC X V A L U E SPACES. 
VALUE 'N' V . 
VALUE 'N' V 
' Y' 
01 
F I L L E R 
PIC X(32) 
V A L U E 'WS ENDS HERE FOR FITNESS PROGRAM' 
P R O C E D U R E DIVISION. 
000-FITNESS-EVALUATION. 
PERFORM U N T I L NO-MORE-PERSONS 
PERFORM 
100-INPUT-PERSONAL-DATA 
PERFORM 2 0 0 - G O A L - W E I G H T - R A N G E 
PERFORM 300-TRAIN-RATE-RANGE 
PERFORM 400-DISPLAY-RESULTS 
END-PERFORM. 
STOP RUN. 
100-INPUT-PERSONAL-DATA. 
INITIALIZE IJNPUT-INFORMATION, 
f 
C A L L ' I N P U T S U B ' " ~ H 
; 
U S I N G INPUT-INFORMATION^ 
j 
I END-CALL. 
H 
2 0 0 - G O A L - W E I G H T - R A N G E . 
MOVE INP-AGE TO W G T - A G E . 
MOVE INP-HEIGHT T O WGT-HEIGHT. 
_ M O V E INP-SEX TO WGJ-SEX. 
' CALL^'WGfsUB' ~~ 
/ ( 
USING WEIGHT-ARGUMENTS-'^ 
END-CALL. 
3 0 0 - T R A I N - R A T E - R A N G E . 
MOVE INP-AGE T O T R A I N - A G E . 
M O V E I N P - F I T N E S S - L E V E L TO T R A I N - F I T N E S S - L E V E L . 
C A L L 'TRAINSUB
1 
U S I N G TRAINING-ARGUMENTS 
END-CALL. 
4 0 0 - D I S P L A Y - R E S U L T S . 
MOVE T R A I N - O V E R A L L - R A N G E T O D I S P - T R A I N - O V E R A L L - R A N G E . 
M O V E T R A I N - F I T N E S S - R A N G E TO D I S P - T R A I N - F I T N E S S - R A N G E . 
M O V E GOAL-WGT-FROM TO DISP-GOAL-WGT-FROM. 
MOVE GOAL-WGT-TO T O DISP-GOAL-WGT-TO. 
MOVE INP-WEIGHT TO DISP-INPUT-WEIGHT. 
CALL 'DSPLYSUB' 
U S I N G DISPLAY-ARGUMENTS 
END-CALL. 

C
h
a
p
t
e
r 
1 6 
— 
Subprograms 
Input Program fiMPtJTSOlI) 
The input program in Figure 16.9 reviews data validation and screen I/O as presented 
in Chapter 10. It also functions as a subprogram, and hence the Linkage Section in 
lines 53-70 which defines the data n a m e s passed from the calling (fitness) program. 
Note the relationship between the C A L L statement in the calling program (lines 
80-82 in Figure 16.8) a n d the Procedure Division header in line 120 of this program, 
both of which contain the 01 entry, I N P U T - I N F O R M A T I O N . T h e latter is copied 
into both programs in accordance with the programming tip o n page 481. 
The input program also contains a second C O P Y statement, C O P Y C O L O R C P Y , 
to define the various colors available with screen I/O. The Screen Section defines a n 
input screen consistent with the display s h o w n earlier in Figure 16.4; it also utilizes 
various features of screen I/O (line and column positioning, reverse video, a n d 
underlining) as presented in Chapter 10. 
The Procedure Division accepts a n d validates the input parameters, one at a 
time, in accordance with the table of error messages defined in lines 37-48. Each 
parameter is processed in a separate paragraph, which utilizes the D O U N T I L 
(TEST AFTER) construct described earlier in Chapters 9 a n d 10. 
Figure 16.9 
Input Subprogram 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM- ID. 
INPUTSUB. 
_ 
3 
AUTHOR. 
CVV. 
4 
5 
DATA DIVISION. 
6 
WORKING-STORAGE SECTION. 
7 
01 FILLER 
PIC X(38) 
8 
VALUE 'WS BEGINS HERE FOR SUBPROGRAM INPUTSUB'. 
9 
10 
01 PROGRAM-SWITCHES. 
11 
05 VALID-FIELD-SWITCH 
PIC XX. 
12 
88 VALID-FIELD 
VALUE SPACES. 
13 
05 CONFIRM-SWITCH 
PIC X. 
14 
88 ALL-DATA-VALID 
VALUE 'Y' 'y'. 
15 
16 
COPY COLORCPY. 
STCPY> 
01 SCREEN-COLORS. 
PIC S9(4) C0MP-5. 
18 
* COLORS FOR FOREGROUND AND BACKGROUND 
19 
78 BLACK 
VALUE 0. 
20 
78 BLUE 
VALUE 1. 
21 
78 GREEN 
VALUE 2. 
22 
78 CYAN 
VALUE 3. 
23 
78 RED 
4. 
24 
78 MAGENTA 
5. 
25 
78 BROWN 
6. 
26 
78 WHITE 
7. 
27 
* ADDITIONAL COLORS FOR FOREGROUND ONLY 
28 
78 BRIGHT-BLACK 
8. 
29 
78 BRIGHT-BLUE 
9. 
30 
78 BRIGHT-GREEN 
10. 
31 
78 BRIGHT-CYAN 
11. 

The 
Completed 
Programs 
(continued) 
32 
33 
34 
EDCPY> 
36 
37 
38 
47 
48 
49 
50 
51 
52 
53 
54 
STCPY> 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
EDCPY> 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
78 BRIGHT-RED 
12. 
78 BRIGHT-MAGENTA 
13. 
78 BRIGHT-BROWN 
14. 
78 BRIGHT-WHITE 
15. 
01 ERROR-VALUES-TABLE. 
05 ERROR-MESSAGE-VALUES. 
39 
10 PIC X(30) VALUE ' 
Name must be Entered 
40 
10 PIC X(30) VALUE ' 
Age must be over 17 
41 
10 PIC X(30) VALUE ' 
Sex must be M or F' 
42 
10 PIC X(30) VALUE ' Weight must be > 70 & < 
500' 
43 
10 PIC X(30) VALUE ' Male Height must be 60"-
-76"' 
44 
10 PIC X(30) VALUE 
1 Female Height must be 54 
-74" 
45 
10 PIC X(30) VALUE 'Fitness Level must be B I or A 
46 
05 ERROR-MESSAGE -TABLE REDEFINES ERROR-MESSAGE-VALUES. 
01 
10 ERROR-MESSAGE OCCURS 7 TIMES 
INDEXED BY ERROR-INDEX PIC X(30). 
FILLER 
PIC X(36) 
VALUE 'WS ENDS HERE FOR SUBPROGRAM INPUTSUB' 
|LINKAGE SECTION. 
COPY INPuTREC. 
01 INPUT-INFORMATION. 
05 INP-FULL-NAME 
88 MISSING-NAME 
INP-AGE 
88 INVALID-AGES 
INP-SEX 
88 VALID-SEX 
88 MALE 
88 FEMALE 
INP-HEIGHT 
INP-WEIGHT 
88 INVALID-WEIGHTS 
VALUES 0 THRU 70 500 THRU 999 
INP-FITNESS-LEVEL 
PIC X. 
88 VALID-FITNESS-LEVELS 
VALUES 'B' 'I' 'A' 'b' 'i' 'a 
05 
05 
05 
05 
05 
PIC X(30). 
VALUE SPACES. 
PIC 99. 
VALUES 0 THRU 17. 
PIC X. 
VALUES 'M' 'm' ' 
VALUES 'M' 'm'. 
VALUES 'F' 'f'. 
PIC 99. 
PIC 9(3). 
F' 
'f 
j SCREEN SECTION, j 
01 INPUT-SCREEN. 
05 BLANK SCREEN FOREGROUND-COLOR WHITE 
BACKGROUND-COLOR BLUE. 
05 SCREEN-PROMPTS. 
10 LINE 1 COLUMN 9 
VALUE 'Personal Fitness Evaluation'. 
10 LINE 3 COLUMN 4 VALUE 'Full Name:'. 
10 LINE 5 COLUMN 4 VALUE 'Age: '. 
10 LINE 5 COLUMN 22 VALUE 'Weight:'. 

Chapter 
16 
Subprograms 
Figure 18.9 
(continued) 
82 
10 LINE 5 COLUMN 44 VALUE 'Fitness Level:'. 
83 
10 LINE 6 COLUMN 4 VALUE 'Sex (M/F):'. 
84 
10 LINE 6 COLUMN 22 VALUE 'Height:'. 
85 
10 LINE 6 COLUMN 45 VALUE 'B - Beginner 
86 
FOREGROUND-COLOR BLACK BACKGROUND-COLOR CYAN. 
87 
88 
10 LINE 7 COLUMN 45 VALUE 'I - Intermediate' 
FOREGROUND-COLOR BLACK BACKGROUND-COLOR CYAN. 
89 
10 LINE 8 COLUMN 45 VALUE 'A - Advanced 
90 
FOREGROUND-COLOR BLACK BACKGROUND-COLOR CYAN. 
91 
92 
05 SCREEN-INPUTS. 
93 
10 SCR-FULL-NAME 
LINE 3 COLUMN 15 PIC X(30) 
94 
USING INP-FULL-NAME REVERSE-VIDEO. 
95 
10 SCR-AGE 
LINE 5 COLUMN 9 PIC 99 
96 
USING INP-AGE REVERSE-VIDEO REQUIRED AUTO. 
97 
10 SCR-WEIGHT 
LINE 5 COLUMN 30 PIC 999 
98 
USING INP-WEIGHT REVERSE-VIDEO REQUIRED AUTO. 
99 
10 SCR-FITNESS-LEVEL LINE 5 COLUMN 59 PIC X 
100 
USING INP-FITNESS-LEVEL REVERSE-VIDEO AUTO. 
101 
10 SCR-SEX 
LINE 6 COLUMN 15 PIC X 
102 
USING INP-SEX 
REVERSE-VIDEO AUTO. 
103 
10 SCR-HEIGHT 
LINE 6 COLUMN 30 PIC 99 
104 
USING INP-HEIGHT REVERSE-VIDEO REQUIRED AUTO. 
105 
106 
01 CONFIRM-SCREEN HIGHLIGHT. 
107 
05 LINE 23 COLUMN 13 UNDERLINE 
108 
FOREGROUND-COLOR GREEN 
109 
BACKGROUND-COLOR MAGENTA 
110 
VALUE 'Is the above information correct? '. 
111 
05 LINE 24 COLUMN 21 
112 
FOREGROUND-COLOR GREEN 
113 
BACKGROUND-COLOR MAGENTA 
114 
VALUE ' (Y - Yes, N - No) '. 
115 
05 SCR-CONFIRM 
LINE 23 COLUMN 49 PIC X 
116 
FOREGROUND-COLOR MAGENTA 
117 
BACKGROUND-COLOR GREEN 
118 
USING CONFIRM-SWITCH. 
119 
120 
PROCEDURE DIVISION USING INPUT-INFORMATION. 
121 
000 -INPUT-PERSONAL-DATA. 
122 
INITIALIZE PROGRAM-SWITCHES. | 
. „,,..,,, 
123 
PERFORM UNTIL ALL-DATA-VALID 
"'~
t 
124 
DISPLAY INPUT-SCREEN 
125 
CALL 'TIMESUB' 
126 
PERFORM 200-VALIDATE-DATA 
127 
PERFORM 300-CONFIRM-INPUT-SCREEN 
128 
END-PERFORM. 
129 
EXIT PROGRAM. | 
_ ^ 
, 
130 
,„.-\/y h HULr-'nAivi 
itiiuHlS 
CL'-lli0! 
iQ 
131 
200 -VALIDATE-DATA. 

The 
Completed 
Programs 
(continued) 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
PERFORM 210-VALIDATE-NAME. 
PERFORM 220-VALIDATE-AGE. 
PERFORM 230-VALIDATE-SEX. 
PERFORM 240-VALIDATE-WEIGHT. 
PERFORM 250-VALIDATE-HEIGHT. 
PERFORM 260-VALIDATE-FITNESS-LEVEL. 
210-VALIDATE-NAME. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-FULL-NAME 
IF MISSING-NAME 
SET ERROR-INDEX TO 1 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
ELSE 
PERFORM 288-CLEAR-ERRORS 
END-IF 
END-PERFORM. 
220-VALIDATE-AGE. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-AGE 
IF INVALID-AGES 
SET ERROR-INDEX TO 2 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
ELSE 
PERFORM 288-CLEAR-ERRORS 
END-IF 
END-PERFORM. 
230-VALIDATE-SEX. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-SEX 
IF VALID-SEX 
PERFORM 288-CLEAR-ERRORS 
ELSE 
SET ERROR-INDEX TO 3 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
END-IF 
END-PERFORM. 
240-VALIDATE-WEIGHT. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-WEIGHT 
IF INVALID-WEIGHTS 
SET ERROR-INDEX TO 4 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
ELSE 
PERFORM 288-CLEAR-ERRORS 
END-IF 
END-PERFORM. 

Chapter 
1 6 — 
Subprograms 
~i%m-ii -;-6J* 
(continued) 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
250-VALIDATE-HEIGHT. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-HEIGHT 
EVALUATE TRUE ALSO INP-HEIGHT 
WHEN MALE ALSO NOT 60 THRU 76 
SET ERROR-INDEX TO 5 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
WHEN FEMALE ALSO NOT 54 THRU 74 
SET ERROR-INDEX TO 6 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
WHEN OTHER 
PERFORM 288-CLEAR-ERRORS 
END-EVALUATE 
END-PERFORM. 
260-VALIDATE-FITNESS-LEVEL. 
PERFORM WITH TEST AFTER UNTIL VALID-FIELD 
ACCEPT SCR-FITNESS-LEVEL 
IF VALID-FITNESS-LEVELS 
PERFORM 288-CLEAR-ERRORS 
ELSE 
SET ERROR-INDEX TO 7 
PERFORM 299-DISPLAY-ERROR-MESSAGE 
END-IF 
END-PERFORM. 
288-CLEAR-ERRORS. 
INITIALIZE VALID-FIELD-SWITCH. 
DISPLAY ' ' LINE 24 WITH BLANK LINE. 
299-DISPLAY-ERROR-MESSAGE. 
CALL 'TIMESUB'. 
MOVE 'NO' TO VALID-FIELD-SWITCH. 
DISPLAY ERROR-MESSAGE (ERROR-INDEX) 
LINE 24 COLUMN 25 WITH HIGHLIGHT BLINK BEEP 
FOREGROUND-COLOR BRIGHT-WHITE 
BACKGROUND-COLOR RED. 
300-CONFIRM-INPUT-SCREEN. 
DISPLAY CONFIRM-SCREEN. 
ACCEPT SCR-CONFIRM. 
T h e weight-range program in Figure 16.10 reviews material o n multilevel programs 
as presented in Chapter 13. T h e Working-Storage Section defines two tables, for 

The 
Completed 
Programs 
m e n and w o m e n ' s weights, in accordance with the user's view as presented in 
Figure 16.5. Subsequent statements in the Procedure Division determine the 
suggested range for an individual's weight, based on sex, height, and age. 
T h e sex, height, a n d age are contained within the 01 entry W E I G H T -
A R G U M E N T S that is passed as an argument to the subprogram by the C A L L 
statement in lines 88-90 of the fitness (main) program in Figure 16.8, and which 
coincides with the Procedure Division header in line 101 of this program. The 
parameter list consists of a single 01 entry, which is copied into both the calling and 
called program. Note the C O P Y statement in the Linkage Section of this program 
(lines 89-99,) and the corresponding C O P Y statement in the fitness program (lines 
40-50 in Figure 16.8). Note, too, the use of C O P Y statements to initialize and define 
the tables for male and female weights, in lines 10 and 38, respectively. 
Weight Subprogram 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
AUTHOR. 
WGTSUB. 
cvv. 
DATA DIVISION. 
WORKING-STORAGE SECTION. 
01 
FILLER 
PIC X(36) 
VALUE 'WS BEGINS HERE FOR SUBPROGRAM WGTSUB 
10 
STCPY> 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
EDCPY> 
COPY MALEWGT. 
01 
MALE-WEIGHT-VALUES. 
01 
05 
PIC X(30) VALUE 
'109122110133112135114137115138' 
05 
PIC X(30) VALUE 
'112126113136115138117140118141' 
05 
PIC X(30) VALUE 
'115130116139118140120142121144' 
05 
PIC X(30) VALUE 
'118135119143121145123147124148' 
05 
PIC X(30) VALUE 
'120145122147124149126151127152' 
05 
PIC X(30) VALUE 
'124149125151127153129155130156' 
05 
PIC X(30) VALUE 
'128154129156131158133160134161' 
05 
PIC X(30) VALUE 
'132159133161134158136165138166' 
05 
PIC X(30) VALUE 
'135163136165138167140169142170' 
05 
PIC X(30) VALUE 
'140163141169142171144173146174' 
05 
PIC X(30) VALUE 
'143170144173146175148178150179' 
05 
PIC X(30) VALUE 
'147177148179150181152183154184' 
05 
PIC X(30) VALUE 
'151180152184154186156188158189' 
05 
PIC X(30) VALUE 
'155187156189158190160193162194' 
05 
PIC X(30) VALUE 
'160192161194163196165198167199' 
05 
PIC X(30) VALUE 
'165198166199168201170203172204' 
05 
PIC X(30) VALUE 
'170202171204173206175208177209' 
MALE-WEIGHT-TABLE REDEFINES MALE-WEIGHT-VALUES. 
05 MALE-HEIGHTS OCCURS 17 TIMES 
INDEXED BY MALE-HGT-INDEX. 
10 MALE-AGES OCCURS 5 TIMES 
INDEXED BY MALE-AGE-INDEX. 
15 MALE-WGT-FR0M 
PIC 9(3). 
15 MALE-WGT-T0 
PIC 9(3). 

Chapter 
16 
Subprograms 
<a 
(continued) 
37 
38 
STCPY> 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
EDCPY> 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
COPY FEMWGT. 
01 
FEMALE-WEIGHT-VALUES. 
01 
05 
PIC X(30) VALUE 
1083099084101085103086104088106
1 
05 
PIC X(30) VALUE 
1084100085102086104088105090107' 
05 
PIC X(30) VALUE 
'086101087103088105090106092108' 
05 
PIC X(30) VALUE 
'089102090104091106092108094110' 
05 
PIC X(30) VALUE 
'091105092106093109094111096113' 
05 
PIC X(30) VALUE 
'093109094111095113096114099116' 
05 
PIC X(30) VALUE 
'096112097113098115100117102119' 
05 
PIC X(30) VALUE 
'100116101117102119103121105122' 
05 
PIC X(30) VALUE 
'104119105121106123107125108126' 
05 
. PIC 
X(30) VALUE 
'106125107126108127109129111130' 
05 
PIC X(30) VALUE 
'109130110131111132112134114135' 
05 
PIC X(30) VALUE 
'112133113134114136116138118139' 
05 
PIC X(30) VALUE 
'116137117138118140120142122143' 
05 
PIC X{30) VALUE 
'121140122142123144124146126147' 
05 
PIC X(30) VALUE 
'123144124146126148128150130150' 
05 
PIC X(30) VALUE 
'130148131150132152133154134155' 
05 
PIC X(30) VALUE 
'134151135154136156137158138159' 
05 
PIC X(30) VALUE 
'138155139158140160141162142163' 
05 
PIC X(30) VALUE 
'142160143162144164145166146167' 
05 
PIC X(30) VALUE 
'146164147166148168149170150171' 
05 
PIC X(30) VALUE 
'150168151170152172153174154175' 
FEMALE-WEIGHT-TABLE REDEFINES FEMALE-WEIGHT-VALUES. 
05 FEMALE-HEIGHTS OCCURS 21 TIMES 
INDEXED BY FEMALE-HGT-INDEX. 
10 FEMALE-AGES OCCURS 5 TIMES 
INDEXED BY FEMALE-AGE-INDEX. 
15 FEMALE-WGT-FROM PIC 9(3). 
15 FEMALE-WGT-TO 
PIC 9(3). 
01 AGE-LIMIT-VALUES. 
05 
05 
05 
05 
05 
PIC 99 
PIC 99 
PIC 99 
PIC 99 
PIC 99 
VALUE 18. 
VALUE 20. 
VALUE 22. 
VALUE 24. 
VALUE 99. 
01 
01 
01 
AGE-TABLE REDEFINES AGE-LIMIT-VALUES. 
05 AGE-LIMIT OCCURS 5 TIMES 
INDEXED BY AGE-INDEX 
PIC 99. 
CONSTANTS-AND-VARIABLES. 
05 MALE-HGT-ADJUST-CONSTANT 
PIC 99 
VALUE 59. 
05 FEMALE-HGT-ADJUST-CONSTANT PIC 99 
VALUE 53. 
05 ADJUSTED-HEIGHT 
PIC 99. 
FILLER 
PIC X(34) 
VALUE 'WS ENDS HERE FOR SUBPROGRAM WGTSUB'. 

The 
Completed 
Programs 
figure 16.16 
(continued) 
8 8 
pJNKAGE SECTION. \ 
. 
89 
COPY WGTCOPY. 
STCPY> 
01 WEIGHT-ARGUMENTS. 
91 
05 WEIGHT-TABLE-INPUTS. 
92 
10 WGT-HEIGHT 
PIC 99. 
93 
10 WGT-AGE 
PIC 99. 
94 
10 WGT-SEX 
PIC X. 
95 
88 MALE 
VALUE 'M
1 V . 
96 
88 FEMALE 
VALUE 'F' ' f . 
97 
05 WEIGHT-GOALS. 
98 
10 GOAL-WGT-FROM 
PIC 999. 
EDCPY> 
10 GOAL-WGT-TO 
PIC 999. 
100 
101 
PROCEDURE DIVISION USING WEIGHT-ARGUMENTS. 
102 
FIND-GOAL-WEIGHT. 
103 
EVALUATE TRUE 
104 
WHEN MALE 
105 
PERFORM FIND-MALE-WEIGHT-RANGE 
106 
WHEN FEMALE 
107 
PERFORM FIND-FEMALE-WEIGHT-RANGE 
108 
WHEN OTHER 
109 
DISPLAY 'INVALID SEX ENTERED' 
110 
INITIALIZE WEIGHT-GOALS 
111 
END-EVALUATE. 
112 
[ EXIT PROGRAM.} 
c 
113 
114 
FIND-MALE-WEIGHT-RANGE. 
115 
COMPUTE ADJUSTED-HEIGHT = 
116 
WGT-HEIGHT - MALE-HGT-ADJUST-CONSTANT 
117 
SIZE ERROR DISPLAY 'SIZE ERROR ADJUSTED HEIGHT' 
118 
END-COMPUTE. 
119 
SET MALE-AGE-INDEX AGE-INDEX TO 1. 
120 
SET MALE-HGT-INDEX TO ADJUSTED-HEIGHT. 
121 
SEARCH AGE-LIMIT VARYING MALE-AGE-INDEX 
122 
AT END DISPLAY 'MALE AGE NOT FOUND' 
123 
INITIALIZE WEIGHT-GOALS 
124 
WHEN 
125 
WGT-AGE <= AGE-LIMIT (AGE-INDEX) 
126 
SET MALE-AGE-INDEX TO AGE-INDEX 
127 
MOVE MALE-WGT-FROM (MALE-HGT-INDEX, MALE-AGE-INDEX) 
128 
TO GOAL-WGT-FROM 
129 
MOVE MALE-WGT-TO (MALE-HGT-INDEX, MALE-AGE-INDEX) 
130 
TO GOAL-WGT-TO 
131 
END-SEARCH. 
132 
133 
FIND-FEMALE-WEIGHT-RANGE. 
134 
COMPUTE ADJUSTED-HEIGHT = 
135 
WGT-HEIGHT - FEMALE-HGT-ADJUST-CONSTANT 
136 
SIZE ERROR DISPLAY 'SIZE ERROR ADJUSTED HEIGHT' 

C
h
a
p
t
e
r 
1 6 
— 
Subprograms 
a 
(continued) 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
END-COMPUTE. 
SET FEMALE-AGE-INDEX AGE-INDEX TO 1. 
SET FEMALE-HGT-INDEX TO ADJUSTED-HEIGHT. _ 
SEARCH AG E - LIMIT VARYING"' FEMALE-AGE-INDEX 
AT END DISPLAY 'FEMALE AGE NOT FOUND' 
INITIALIZE WEIGHT-GOALS 
WHEN 
WGT-AGE <= AGE-LIMIT (AGE-INDEX) 
SET FEMALE-AGE-INDEX TO AGE-INDEX 
MOVE FEMALE-WGT-FROM 
(FEMALE-HGT-INDEX, FEMALE-AGE-INDEX) 
TO GOAL-WGT-FROM 
MOVE FEMALE-WGT-TO 
(FEMALE-HGT-INDEX, FEMALE-AGE-INDEX) 
TO GOAL-WGT-TO 
END-SEARCH. 
G uct 
The training program in Figure 16.11 calculates an individual's target heart rate 
(after exercise) according to the formulas given in the programming specifications. 
The program uses the SIZE E R R O R phrase and associated E N D - C O M P U T E scope 
terminator in several places in the Procedure Division. It also uses the E V A L U A T E 
statement to determine the specific training range according to the user's fitness 
level. 
The m e a n s for passing parameters between this program a n d the fitness 
program, which calls it, parallels the procedure for the other subprograms. Thus, 
the Linkage Section contains a C O P Y statement (line 29) to define the 01 
parameters that constitute the parameter list; note, too, the correspondence 
between the Procedure Division header in this program a n d the C A L L statement 
in the fitness program. 
Display Program | I I S P L ¥ S I J B | 
.. ........... 
The display program in Figure 16.12 uses DISPLAY statements rather than a Screen 
Section to control the displayed output in accordance with earlier material from 
Chapter 10. The m e a n s for passing parameters between this program and the fitness 
program parallel the procedure for the other subprograms. T h e Linkage Section 
contains a C O P Y statement (line 57) to define the single 01 parameter, which 
constitutes the parameter list in the Procedure Division header of lines 70-71. 
Observe also the presence of the identical C O P Y statement found in the input 
program (line 21) to obtain the definition of foreground a n d background colors. 

The 
Completed 
Programs 
Training Subprogram 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
STCPY> 
31 
32 
33 
34 
35 
36 
37 
38 
EDCPY> 
40 
41 
42 
43 
44 
45 
46 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
TRAINSUB. 
AUTHOR. 
CVV. 
DATA DIVISION. 
WORKING-STORAGE SECTION. 
01 
FILLER 
PIC X(38) 
VALUE 'WS BEGINS HERE FOR SUBPROGRAM TRAINSUB' 
01 
RATES-AND-CONSTANTS. 
05 
TRAIN-CONSTANT 
05 LOW-RATE 
05 HIGH-RATE 
01 
RANGE-CALCULATIONS. 
05 OVERALL-RANGES. 
10 OVERALL-HIGH 
10 OVERALL-LOW 
05 FITNESS-RANGES. 
10 FITNESS-HIGH 
10 FITNESS-LOW 
(\ti 
QANfiF-TNTFRVfll 
PIC 999 VALUE 220. 
PIC V9 
VALUE .6. 
PIC V9 
VALUE .9. 
PIC 99. 
PIC 99. 
PIC 99. 
PIC 99. 
PIT 0 
01 FILLER 
PIC X(36) 
VALUE 'WS ENDS HERE FOR SUBPROGRAM TRAINSUB'. 
LINKAGE SECTION. 
COPY TRAINCPY. 
01 TRAINING-ARGUMENTS. 
05 TRAINING-INPUTS. 
10 TRAIN-AGE 
10 
TRAIN-FITNESS-LEVEL 
88 BEGINNER 
88 
INTERMEDIATE 
88 ADVANCED 
TRAINING-RANGES. 
10 
TRAIN-OVERALL-RANGE 
10 
TRAIN-FITNESS-RANGE 
PIC 99. 
PIC X. 
VALUE 'B' 'b 
VALUE T 'i 
VALUE 'A' 'a 
05 
PIC X(5). 
PIC X(5). 
PROCEDURE DIVISION 
USING TRAINING-ARGUMENTS. 
FIND-TRAIN-RANGE. 
PERFORM COMPUTE-OVERALL-RANGES. 
PERFORM COMPUTE-FITNESS-RANGES. 
EXIT PROGRAM. 

C
h
a
p
t
e
r 
1 6 
Subprograms 
Figure 1 6 . 1 1 
(continued) 
47 
48 
COMPUTE-OVERALL-RANGES. 
49 
COMPUTE OVERALL-LOW ROUNDED = 
50 
(TRAIN-CONSTANT - TRAIN-AGE) * LOW-RATE / 6 
51 
SIZE ERROR. DISPLAY 'SIZE ERROR ON. LOW RANGE' 
52 
END-COMPUTE. 
53 
COMPUTE OVERALL-HIGH ROUNDED = 
54 
(TRAIN-CONSTANT - TRAIN-AGE) * HIGH-RATE / 6 
55 
SIZE ERROR DISPLAY 'SIZE ERROR ON HIGH RANGE' 
56 
END-COMPUTE. 
57 
STRING OVERALL-LOW '-' OVERALL-HIGH DELIMITED BY SIZE 
58 
INTO TRAIN-OVERALL-RANGE 
59 
END-STRING. 
60 
61 
COMPUTE-FITNESS-RANGES. 
62 
COMPUTE RANGE-INTERVAL = 
63 
(OVERALL-HIGH - OVERALL-LOW) / 3 
64 
SIZE ERROR DISPLAY 'SIZE ERROR ON RANGE INTERVAL' 
65 
END-COMPUTE. 
66 
EVALUATE TRUE 
67 
WHEN BEGINNER 
68 
MOVE OVERALL-LOW TO FITNESS-LOW 
69 
COMPUTE FITNESS-HIGH ROUNDED = 
70 
OVERALL-LOW + RANGE-INTERVAL 
71 
SIZE ERROR DISPLAY 'SIZE ERROR HIGH FITNESS' 
72 
END-COMPUTE 
73 
WHEN INTERMEDIATE 
74 
COMPUTE FITNESS-LOW ROUNDED = 
75 
OVERALL-LOW + RANGE-INTERVAL 
76 
SIZE ERROR DISPLAY 'SIZE ERROR LOW FITNESS' 
77 
END-COMPUTE 
78 
COMPUTE FITNESS-HIGH ROUNDED = 
79 
OVERALL-HIGH - RANGE-INTERVAL 
80 
SIZE ERROR 
81 
DISPLAY 'SIZE ERROR HIGH FITNESS' 
82 
END-COMPUTE 
83 
WHEN ADVANCED 
84 
COMPUTE FITNESS-LOW ROUNDED = 
85 
OVERALL-HIGH - RANGE-INTERVAL 
86 
SIZE ERROR DISPLAY 'SIZE ERROR LOW FITNESS' 
87 
END-COMPUTE 
88 
MOVE OVERALL-HIGH TO FITNESS-HIGH 
89 
WHEN OTHER 
90 
DISPLAY 'INVALID FITNESS LEVEL SEE VALIDATION' 
91 
END-EVALUATE. 
92 
STRING FITNESS-LOW '-' FITNESS-HIGH DELIMITED BY SIZE 
93 
INTO TRAIN-FITNESS-RANGE 
94 
END-STRING. 

The 
Completed 
Programs 
Display Subprogram 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
STCPY> 
41 
42 
43 
44 
45 
46 
47 
48 
49 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
DSPLYSUB. 
AUTHOR. 
CVV. 
DATA DIVISION. 
WORKING-STORAGE SECTION. 
01 
FILLER 
PIC X(38) 
VALUE 'WS BEGINS HERE FOR SUBPROGRAM UPDTESUB'. 
01 DISPLAY-MESSAGES. 
05 OVER-WEIGHT-COMMENT 
PIC X(41) 
VALUE ' OH! NO! Your weight exceeds the range'. 
05 UNDER-WEIGHT-COMMENT 
PIC X(41) 
VALUE ' EAT UP! Your weight is below the range'. 
05 IN-WEIGHT-COMMENT 
PIC X(41) 
VALUE 'CONGRATULATIONS! You are within the range' 
05 WEIGHT-COMMENT 
PIC X(41). 
05 ANOTHER-MESSAGE 
PIC X(14) 
VALUE 'Must be Y or N'. 
COPY COLORCPY. 
of Tc^ElN^raLORsT"
- -
* m i noc. f a d rnpFCPniiwri 
PIC S9(4) COMP-5. 
awn 
RiricnDOiiMn 
24 
78 BLACK 
VALUE 0. 
25 
78 BLUE 
VALUE 1. 
26 
78 GREEN 
VALUE 2. 
27 
78 CYAN 
VALUE 3. 
28 
78 RED 
VALUE 4. 
29 
78 MAGENTA 
VALUE 5. 
30 
78 BROWN 
VALUE 6. 
31 
78 WHITE 
VALUE 7. 
32 
* ADDITIONAL COLORS FOR FOREGROUND ONLY 
33 
78 BRIGHT-BLACK 
VALUE 8. 
34 
78 BRIGHT-BLUE 
VALUE 9. 
35 
78 BRIGHT-GREEN 
VALUE 10 
36 
78 BRIGHT-CYAN 
VALUE 11 
37 
78 BRIGHT-RED 
VALUE 12 
38 
78 BRIGHT-MAGENTA 
VALUE 13 
39 
78 BRIGHT-BROWN 
VALUE 14 
EDCPY> 
78 BRIGHT-WHITE 
VALUE 15 
01 MESSAGE-COLORS. 
05 COLOR-CONTROL 
05 MAGENTA-BLACK 
VALUE 'BACKGROUND-COLOR 
05 RED-BLACK 
VALUE 'BACKGROUND-COLOR 
05 GREEN-BLACK 
VALUE 'BACKGROUND-COLOR 
PIC X(50). 
PIC X(50). 
FOREGROUND-COLOR 0'. 
PIC X(50). 
FOREGROUND-COLOR 0', 
PIC X(50). 
FOREGROUND-COLOR 0'. 

C
h
a
p
t
e
r 
1 6 
-- 
Subprogram 
Figure 1 6 . 1 2 
(continued) 
50 
51 
01 GOAL-WEIGHT-RANGE 
PIC X(7). 
52 
53 
01 FILLER 
54 
VALUE 'WS ENDS HERE FOR SUBPROGRAM UPDTESUB'. 
55 
56 
LINKAGE SECTION. 
57 
COPY DISPCPY. 
STCPY> 
01 DISPLAY-ARGUMENTS. 
59 
05 DISP-TRAINING-RANGES. 
60 
10 DISP-TRAIN-OVERALL-RANGE 
PIC X(5). 
61 
10 DISP-TRAIN-FITNESS-RANGE 
PIC X(5). 
62 
05 DISP-WEIGHT-GOALS. 
63 
10 DISP-GOAL-WGT-FROM 
PIC ZZ9. 
64 
10 DISP-GOAL-WGT-TO 
PIC ZZ9. 
65 
05 DISP-INPUT-WEIGHT 
PIC 9(3). 
66 
05 ANOTHER-PERSON-SWITCH 
PIC X VALUE SPACES. 
67 
88 NO-MORE-PERSONS 
VALUE 'N' 'n'. 
EDCPY> 
88 VALID-ANOTHER 
VALUE 'N' 'rr
 !Y' 'y'. 
69 
70 
PROCEDURE DIVISION 
71 
USING DISPLAY-ARGUMENTS. 
72 
000-UPDATE-PERSONAL-DATA. 
73 
PERFORM 100-DETERMINE-WEIGHT-COMMENf. 
74 
PERFORM 200-UPDATE-SCREEN. 
75 
rHuTMriMESUB'. 
j
 
C
a
l
i 
l o 
a
n
o
!
n
e
r subprogram 
76 
PERFORM 300-INPUT-ANOTHER-PERSON. 
77 
EXIT PROGRAM. 
78 
79 
100-DETERMINE-WEIGHT-COMMENT. 
80 
EVALUATE TRUE 
81 
WHEN DISP-INPUT-WEIGHT < DISP-GOAL-WGT-FROM 
82 
MOVE UNDER-WEIGHT-COMMENT TO WEIGHT-COMMENT 
83 
| 
MOVE MAGENTA-BLACK TO COLOR-CONTROL "" 
^ \ 
84 
' WHEN DISP-INPUT-WEIGHT > DISP-GOAL-WGT-TO " "~ 
1 
85 
MOVE OVER-WEIGHT-COMMENT TO WEIGHT-COMMENT 
/ / 
86 
[" 
MOVE RED-BLACK TO"COLOR^CONTROL 
f 
/ 
87 
WHEN OTHER 
" 
/ 
88 
MOVE IN-WEIGHT-COMMENT TO WEIGHT-COMMENT 
/ 
89 
| 
MOVE GREENBACK TO COlOR^CONTROL 
f 
90 
END-EVALUATE. 
91 
92 
200-UPDATE-SCREEN. 
93 
STRING DISP-GOAL-WGT-FROM '-' DISP-GOAL-WGT-TO 
94 
DELIMITED BY SIZE 
95 
INTO GOAL-WEIGHT-RANGE 
96 
END-STRING. 
97 
DISPLAY 
98 
'Your Goal Weight Range: ' LINE 11 COLUMN 4 
99 
GOAL-WEIGHT-RANGE LINE 11 COLUMN 28 WITH HIGHLIGHT. 

The 
Completed 
Programs 
Figure 16,12 
Display Subprogram 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
DISPLAY 
WEIGHT-COMMENT LINE 12 COLUMN 6 WITH BLINK 
I CONTROL IS COLOR-CONTROL, j 
^ 
DISPLAY 
o o . ^ c 
'Training Heart Rate Range Information (10 Second)' 
LINE 14 COLUMN 4. 
DISPLAY 
'Overall Heart Rate Range: ' 
LINE 15 COLUMN 6 
DISP-TRAIN-OVERALL-RANGE COLUMN 32 WITH HIGHLIGHT 
'Adjusted for Fitness Level: ' LINE 16 COLUMN 6 
DISP-TRAIN-FITNESS-RANGE COLUMN 34 WITH HIGHLIGHT. 
HIGHLIGHT 
DISPLAY ' ' LINE 23 COLUMN 1 WITH BLANK LINE. 
DISPLAY ' ' LINE 24 COLUMN 1 WITH BLANK LINE. 
300-INPUT-ANOTHER-PERSON. 
DISPLAY 'Another Person? (Y/N): ' LINE 24 COLUMN 10 
WITH FOREGROUND-COLOR BRIGHT-GREEN 
BACKGROUND-COLOR MAGENTA. 
PERFORM WITH TEST AFTER UNTIL VALID-ANOTHER 
ACCEPT ANOTHER-PERSON-SWITCH LINE 24 COLUMN 33 
WITH FOREGROUND-COLOR BRIGHT-GREEN 
BACKGROUND-COLOR MAGENTA 
IF VALID-ANOTHER 
DISPLAY ' ' LINE 24 WITH BLANK LINE 
ELSE 
DISPLAY ANOTHER-MESSAGE 
LINE 24 COLUMN 38 WITH HIGHLIGHT BLINK 
FOREGROUND-COLOR BRIGHT-WHITE 
BACKGROUND-COLOR RED 
END-IF 
END-PERFORM. 
T i m e P r o g r a m fTHHSESUBI 
. 
The program to update the displayed time (Figure 16.13) uses the A C C E P T statement 
to obtain the current time containing hours, minutes, seconds, and hundredths of a 
second as per the discussion in Chapter 8. Reference modification is used in 
conjunction with an I N S P E C T statement to truncate hundredths of a second in the 
displayed time. 
The program is called from two other programs as per the system hierarchy 
chart in Figure 16.6. This program is different from the other subprograms in that it 
does not contain any parameters; the program is completely self-contained as it 
obtains the current time from the system, a n d then displays the results directly o n 
the monitor. 

1 
C
h
a
p
t
e
r 
16 
Subprograms 
.13 
Time Subprogram 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
TIMESUB. 
3 
AUTHOR. 
CVV. 
4 
5 
DATA DIVISION. 
6 
WORKING-STORAGE SECTION. 
7 
01 FILLER 
PIC X(37) 
8 
VALUE 'WS BEGINS HERE FOR SUBPROGRAM TIMESUB' 
9 
10 
01 TIME-VARIABLES. 
11 
05 THE-TIME 
PIC 9(8). 
12 
05 HH-MM-SS 
PIC 99B99B99. 
13 
14 
01 FILLER 
PIC X(35) 
15 
VALUE 'WS ENDS HERE FOR SUBPROGRAM TIMESUB'. 
16 
17 
PROCEDURE DIVISION. 
18 
000-UPDATE-TIME. 
19 
ACCEPT THE-TIME FROM TIME. 
20 
fliJvTTHE^ME" (1:6) "TO~HH-MM-SS.~ 
21 
INSPECT HH-MM-SS REPLACING ALL ' ' BY 
22 
DISPLAY HH-MM-SS LINE 1 COLUMN 60. 
23 
EXIT PROGRAM. 
fc^LCkSCcSCjo; 
Beginning C O B O L programmers often take the link program (or linkage editor as 
iiC^'.Ce* 
it is called o n I B M mainframes) for granted, because it functions transparently as 
the middle step in the compile, link, a n d execute sequence. Knowledge of the link 
program assumes greater importance, however, in systems of multiple programs as 
in the fitness example just presented. Accordingly, w e review the compile, link, a n d 
execute sequence that w a s first presented in Chapter 2. 
Three distinct programs are associated with the execution of a single C O B O L 
program, a relationship that was s h o w n earlier in Figure 2.3. T h e C O B O L compiler 
translates a source program into an object (machine language) program; the link 
program combines the object program with object modules from other C O B O L 
programs and/or vendor-supplied I/O routines to create an executable load module; 
and finally, the load module accepts the input data a n d produces the desired results. 
Consider n o w a slightly different scenario in which a system of three C O B O L 
programs (a main program and two subprograms) is to be developed. This time, a 
total of five steps is required in order to execute the m a i n program: 
1. Compile the m a i n program 
2. Compile the first subprogram 
3. Compile the second subprogram 
4. Link the three object programs to produce a load module 
5. Execute the load m o d u l e 

It is not necessary, however, to repeat the entire five-step sequence every time 
the system undergoes additional testing. W h a t if, tor example, the subprograms 
have been successfully debugged, a n d only the main program is being changed? 
C a n you see that it is inherently wasteful to continually recompile the subprograms 
if they remain the same? In other words, if only the main program changes, couldn't 
w e just compile the main program (step 1), then link the object program to the 
existing object programs for the subprograms (step 4), and then execute the resulting 
load module (step 5)? 
Other variations are also possible; for example, if the first subprogram changes 
but the other two remain the same, the run stream would consist of steps two, four, 
and five as only the first subprogram would have to be recompiled. Another variation 
would consist solely of step five, to execute the load module (without recompilation 
or linking) w h e n all testing has been completed. 
Figure 16.14 illustrates the compile, link, and execute sequence for the fitness 
system developed earlier in the chapter. Figure 16.14a displays the file n a m e s of the 
six programs in the system (as they might appear o n a PC); the C O B extension 
indicates a C O B O L source program. 
Figure 16.14b depicts a conceptual view of the associated run stream. Each of 
the six programs is compiled separately in steps 1 through 6, the individual object 
modules are linked together in step 7, and the resulting load module is executed in 
step 8. Figure 16.14c indicates the presence of the six object modules (extension 
OBJ) that are produced as a result of the individual compilations. 
Figure 16.14d shows the two additional files produced by the link program. 
FITNESS.MAP contains the descriptive information produced by the link program 
and is analogous to a C O B O L listing produced by the compiler. FITNESS.EXE is the 
resulting load module that is eventually executed. 
Students are often frustrated in their attempt to produce a load module with multiple 
subprograms. Consider, for example, Figure 16.15, which contains—in outline 
f o r m — a C O B O L m a i n (calling) program and two sub (called) programs. Observe, 
however, that there is a n inconsistency between the C A L L statement of the m a i n 
program a n d the P R O G R A M - I D paragraph of the first subprogram; that is, the m a i n 
program is calling SIJB1, whereas the P R O G R A M - I D paragraph refers to S U B R T N 1 . 
This in turn produces the error message in Figure 16.15d. 
The exact wording of the error message will vary from system to system; for 
example, the linkage editor o n an I B M mainframe will cite an unresolved 
external 
reference, whereas the link program o n a P C m a y reference an undefined 
symbol. 
Regardless of the system, however, the link program will not execute cleanly, despite 
the fact that all three programs compiled without error. 
The reason for the problem becomes apparent w h e n w e again consider the 
functions of the C O B O L compiler and the link program. The compiler translates 
C O B O L source statements to machine language, and thus, must accept statements 
that call other (external) programs—for example, C A L L S U B ] . The compiler cannot 
access S U B ! directly, and trusts in the link program to locate the appropriate object 
module a n d produce an executable load module. The unresolved external reference 
detected by the link program m e a n s there w a s a call for a program n a m e d SL1B1, 
but that the object module for S U B 1 could not be found. 
Return to the original C O B O L listing of Figure 16.15a and observe once again 
the inconsistency between the C A L L statement in the m a i n program (CALL SUB1) 
and the P R O G R A M - I D paragraph in the subprogram (SUBRTN1). M a k e the entries 
consistent (i.e., change S U B 1 to S U B R T N 1 ) a n d the problem is solved. 

C
h
a
p
t
e
r 
1 6 — 
Subprograms 
Figure 18.14 
The Compile, Link, and Execute Sequence 
DSPLYSUB CBL 
FITNESS CBL 
INPUTSUB CBL 
TIMESUB CBL 
WGTCOPY CBL 
WGTSUB CBL 
(a) Directory before Compilation 
Step 1: Compile fitness program (FITNESS.CBL) 
Step 2: Compile input program (INPUTSUB.CBL) 
Step 3: Compile weight goals program (WGTSUB.CBL) 
Step 4: Compile training program (TRAINSUB.CBL) 
Step 5: Compile format time program (TIMESUB.CBL) 
Step 6: Compile final display program (DSPLYSUB.CBL) 
Step 7: Link the object programs 
Step 8: Execute the load module 
(b) The Hun Stream (Conceputal View) 
DSPLYSUB CBL 
FITNESS CBL 
INPUTSUB CBL 
TIMESUB CBL 
WGTCOPY CBL 
WGTSUB CBL 
DSPLYSUB INT 
FITNESS INT 
INPUTSUB INT 
TIMESUB INT 
TRAINSUB INT 
WGTSUB 
INT 
(c) Directory after Compilation 
The optional BY R E F E R E N C E and BY C O N T E N T phrases were not present in 
COBOL-74. The omission of both phrases defaults to C A L L I N G BY 
R E F E R E N C E and is the equivalent of the C A L L statement in COBOL-74. The 
INITIAL phrase in the P R O G R A M - I D paragraph is also new to COBOL-85. 
The optional scope terminator, END-CALL, is also new. 
Two other minor changes do not add any additional capability per se, but 
simplify the use of subprograms. These are: 
1. EXIT P R O G R A M (to return control to the calling program) need not be the 
only statement in a paragraph, as was required in COBOL-74. 
2. An elementary item m a y appear in the parameter list as opposed to the 
COBOL-74 restriction to 01- or 77-level entries. 

The 
Linkage 
Editor 
Figure 16,15 Problems with the Linkage Editor 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
MAINPROG. 
| 
I 
PROCEDURE DIVISION. 
• 
rCALL~SU^l~USlNG~PTRAMlfEi-iTK 
CALL 'SUBRTN2' USING PARAMETER-2. 
(a) Main Program 
IDENTIFICATION DIVISION, 
j 
PROGRAM-ID. 
SUBRTN1. 
PROCEDURE DIVISION 
USING PARAMETER-1. 
EXIT PROGRAM. 
(b) First Subroutine; 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
SUBRTN2. 
PROCEDURE DIVISION 
USING PARAMETER-2. 
EXIT PROGRAM. 
(c) Second Subroutine 
ERROR - SUB1 IS AN UNRESOLVED EXTERNAL REFERENCE 
(d) Error Message 

C
h
a
p
t
e
r 
1 6 
Subprograms 
SUMMARY 
A sub (called) program is a program that is written and compiled 
independently of other programs but which is executed under the control 
of a main (calling) program. 
i 
A hierarchy chart shows the relationship of paragraphs within a COBOL 
program or programs within a system. The subprograms that comprise a 
system are developed in stages and tested in top-down fashion just as the 
paragraphs within a program. 
The CALL statement in a calling program transfers control to the first 
executable statement in the called program. The EXIT PROGRAM statement 
returns control from the called program to the calling program. 
The argument list is specified in the CALL USING statement of the calling 
program and in the Procedure Division header of the called program. The 
data names in the parameter lists can be, but do not have to be, the same. 
The COPY statement inserts statements into a COBOL program (from a 
copy library) during compilation, as though the statements had been 
coded directly in the program itself. A COPY statement may appear 
anywhere within a program except within another COPY statement. 
CALLING BY CONTENT prevents the value of a passed parameter modified 
in the calling program from being changed in the called program; CALLING 
BY REFERENCE, however, will change the variable in the calling program. 
The INITIAL phrase in the PROGRAM-ID paragraph restores a program to 
its initial state each time it is called; that is, all data names are reset to their 
original values via any VALUE clauses that are present. 
The linkage editor (link program) combines the object modules produced 
by compilation of one or more programs with vendor-supplied I/O routines 
to produce a load module. 
Argument list 
Called program 
Calling program 
Linkage editor (link program) 
Load module 
Main program 
Parameter list 
Subprogram 
Undefined symbol 
Unresolved external reference 
COmOL 
ktements 
BY CONTENT 
EXIT PROGRAM 
BY REFERENCE 
INITIAL 
CALL USING 
LINKAGE SECTION 
COPY 
PROCEDURE DIVISION USING 
END-CALL 

1. A called program returns control to its calling program via an 
statement. 
2. The LINKAGE SECTION appears in the (calling/called) program, and indicates that 
space for these data names has already been allocated in the (calling/called) 
program. 
3. The order of arguments in the USING clauses of the called and calling programs 
(is/is not) important. 
4. If program A calls program B, then program A is the main or 
program and program B is the sub or 
program. 
5. If program A calls program B and program B calls program C, then program B is 
(both/neither) a called and a calling program. 
6. A COBOL program (may/may not) call multiple subprograms. 
7. A 
statement is used to bring in text from a file on disk into a 
COBOL, program. 
8. Specification of the (BY CONTENT/BY REFERENCE) phrase ensures that the original 
values will be restored when control is returned to the calling program. 
9. Specification of the (BY CONTENT/BY REFERENCE) phrase does not restore the 
values and thus functions identically to the COBOL-74 implementation. 
10. The 
phrase in the PROGRAM-ID paragraph restores the data 
names in a called program to their initial values. 
11. The PERFORM statement is to a paragraph as the 
statement is 
to a subprogram. 
T R U E / r A L S E 
1. The COPY clause is permitted only in the Data Division. 
2. The Linkage Section appears in the calling program. 
3. Data names in CALI 
USING and PROCEDURE DIVISION USING . . . must be 
the same. 
4. A called program contains only the Data and Procedure Divisions. 
5. The COPY statement can be used on an FD only. 
6. A COPY statement takes effect during the linking phase of the compile, link, and 
execution sequence. 
7. A program can contain only one CALL statement. 
8. The same program can function as both a called and a calling program. 
9. The parameter list may contain group items at other than a 01 level. 
10. A hierarchy chart can be used to show the relationship of paragraphs in a program 
or programs in a system. 
11. A CALL statement must include either the BY REFERENCE or BY CONTENT 
phrase. 
12. A CALL statement must contain at least one parameter. 

C
h
a
p
t
e
r 
1 6 
-
Subprograms 
P R O B L E M S 
1. Answer the following questions with respect to the hierarchy chart in Figure 16.16: 
a. Which programs are calling programs? 
b. Which programs are called programs? 
c. Which programs are both called and calling programs? 
d. Which programs contain a CALL statement? 
e. Which programs contain a Linkage Section? 
f. Which programs might contain a COPY statement? 
g. Which programs might contain an INITIAL clause? 
Figure 16.16 
Hierarchy Chart for Problem 1 
PROGRAM 
A 
PROGRAM 
PROGRAM 
C 
PROGRAM 
D 
PROGRAM 
E 
PROGRAM 
F 
PROGRAM 
G 
2. Figure 16.17 shows a partial listing of a called and calling program in which the first 
three Procedure Division statements of the subprogram initialize various counters 
and switches. 
a. Are these statements redundant with the existing VALUE clauses; that is, what 
would be the effect (if any) of removing the MOVE statements from the 
subprogram? 
b. What would be the effect (if any) of removing the MOVE ZERO statements, 
replacing them with VALUE ZERO clauses in the Data Division, and including 
the INITIAL phrase in the PROGRAM-ID header of the called program? 
c. Which Procedure Division statement could be substituted for the MOVE ZERO 
statements with no other changes to the program? 

IMF© 
T 
Skeleton Programs for Problem 2 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
MAINPROG. 
PROCEDURE DIVISION. 
CALL 'SUB1' USING PARAMETER-LIST. 
(a) Main Program 
IDENTIFICATION DIVISION. 
PROGRAM-ID. SUB1. 
WORKING-STORAGE SECTION. 
01 
SUB-COUNTERS-AND-SWITCHES. 
05 FIRST-COUNTER 
PIC 9(3) 
VALUE ZERO. 
05 SECOND-COUNTER 
PIC 9(3) 
VALUE ZERO. 
05 TABLE-LOOKUP-SWITCH 
PIC X(3) 
VALUE SPACES. 
PROCEDURE DIVISION 
USING PARAMTER-LIST. 
RESET-DATA-ITEMS. 
MOVE ZEROS TO FIRST-COUNTER. 
MOVE ZEROS TO SECOND-COUNTER. 
MOVE SPACES TO TABLE-LOOKUP-SWITCH. 
(b) Subprogram 
3. Answer the following with respect to the COBOL fragment of Figure 16.18. 
a. What are the ending values for each of the six data names (that is, for A, B, C, D, 
E, and F)? 
b. What is the effect, if any, of removing the BY CONTENT phrase in the CALL 
statement? 
c. What is the effect, if any, of removing the BY REFERENCE phrase in the CALL 
statement? 

Chapter 
16 
Subprograms 
Igure 16.16 
COBOL Skeleton for Problem 3 
MOVE ZEROS TO A, B, C. 
j 
CALL SUBRTN 
\ 
USING A 
BY CONTENT B 
BY REFERENCE C 
END-CALL. 
1 
I 
(a) Calling Program 
1 
| 
PROGRAM-ID. 
SUBRTN. 
| 
PROCEDURE DIVISION 
| 
USING D, E, F. 
) 
I 
| 
MOVE 10 TO D, E, F 
I 
EXIT PROGRAM. 
(b) Called Program 
4. Answer the following with respect to the COBOL skeleton in Figure 16.19. 
a. Indicate the necessary steps in a conceptual run stream to compile, link, and 
execute all three programs. 
b. Which steps would have to be repeated in the run stream of part (a), given that 
the subprograms were working perfectly, but that the main program needs 
modification? 
c. Which steps would have to be repeated in the run stream of part (a), given that 
the only change was in the copy member INPUTREC? 
d. What problems, if any, would arise in connection with the CALL statement for 
PROGA? In which step (compilation, linking, or execution) would the problem 
arise (be detected)? 
e. What problems, if any, would arise in connection with the CALL statement for 
PROGB? In which step (compilation, linking, or execution) would the problem 
arise (be detected)? 
5. Explain how the concept of top-down testing can be applied to the fitness system 
as depicted by the hierarchy chart of Figure 16.6. 

i r e 16,13 
COBOL Programs for Problem 4 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
MAINPROG. 
WORKING-STORAGE SECTION. 
COPY INPUTREC 
01 
INPUT-DATA. 
05 
INPUT-NAME 
01 
PASSED-PARAMETERS 
05 PARM-A 
05 PARM-B 
PROCEDURE DIVISION. 
CALL 'PROGA' USING PARM-A, PARM-B, INPUT-DATA. 
CALL 'PROGB' USING PARM-A. 
(a) Main Program 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
PROGA 
LINKAGE SECTION. 
COPY INPUTREC 
01 
INPUT-DATA. 
05 
INPUT-NAME 
01 NEW-DATA-NAMES. 
05 
NEW-NAME-A 
05 NEW-NAME-B 
PROCEDURE DIVISION 
USING NEW-NAME-A, NEW-NAME-B, INPUT-DATA. 
(b) First Subroutine 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
PROG-B. 
LINKAGE SECTION. 
01 PASSED-PARAMETERS. 
05 PARM-A 
PIC 9(4). 
PROCEDURE DIVISION 
USING PARM-A. 
(b) Second Subroutine 
PIC X(15). 
PIC 9(4). 
PIC XX. 
PIC X(15). 
PIC XX. 
PIC 9(4). 


Overview 
S y s t e m C o n c e p t s 
Sequential versus Nonsequential Processing 
Periodic Maintenance 
D a t a Validation 
Programming Specifications 
D o Q i n n i n n t h e P r n n r a m 
» " '~ ' 
The Completed Program 
S e q u e n t i a l File M a i n t e n a n c e 
Programming Specifications 
The Balance Line Algorithm 
Designing the Hierarchy Chart 
Top-Down T e s t i n g 
The Stubs Program 
The Completed Program 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
1 7 —-
Sequential 
File 
Maintenance 
After reading this chapter you will be able to: 
Describe the file maintenance operation; distinguish between the old master, 
transaction, and new master files. 
Describe the three transaction types associated with file maintenance. 
Differentiate between sequential and nonsequential file maintenance. 
Describe at least three types of errors that can be detected in a stand­
alone edit program; list two errors that cannot be detected in such a 
program. 
Discuss the balance line algorithm. 
Define top-down testing; explain how a program may be tested before it is 
completely coded. 
A large proportion of data-processing activity is devoted to file maintenance. 
Although printed reports are the more visible result of data processing, all files 
must be maintained to reflect the changing nature of the physical environment. 
In every system new records can be added, while existing records can be 
changed or deleted. 
The chapter begins with a discussion of system concepts, emphasizing 
the importance of data validation in the maintenance process. It continues with 
coverage of the balance line algorithm, a completely general procedure for 
sequential file maintenance. The resulting program is implemented in stages 
through top-down testing. The initial version of the program contains several 
program stubs and validates the interaction among the higher-level paragraphs 
in the hierarchy chart. The second, and completed, version fulfills the requirements 
of the case study. 
In its simplest form, file maintenance implies the existence of three files, an old 
master file, a transaction file, a n d a new master file, which is produced as a 
consequence of processing the first two files with one another. The situation is 
depicted in Figure 17.1, which contains a system flowchart for the traditional 
sequential 
update. 
Figure 17.2 is a n expanded version of Figure 17.1 with hypothetical data 
included. The old master a n d transaction files are both in sequence according to 
the s a m e field (key), in this example, by social security number. The transaction file 
contains information on h o w the old master file is to be changed—that is, whether 
n e w records are to be added, or existing records changed or deleted. During the 
update process, every record in the old master file will be copied intact to the n e w 
master file, unless the update program detects a transaction for that record. The 
output produced by the program consists of the n e w master file and various error 
messages if problems are encountered. 

System 
Concepts 
Pigsure 17-2 Sequential Update with Data Files 
OLD MASTER F I L E : 
111111111ADAMS 
015000 NEW YORK 
222222222BAKER 
025000 NEW YORK 
333333333ZIDR0W 
008000 NEW YORK 
444444444MILGR0M 
040000 BOSTON 
555555555BENJAMIN 
100000 CHICAGO 
666666666SHERRY 
007500 CHICAGO 
777777777BOROW 
050000 BOSTON 
888888888JAMES 
017500 NEW YORK 
999999999RENAZEV 
030000 NEW YORK 
NEW MASTER F I L E : 
111111111ADAMS 
015000 NEW YORK 
222222222BAKER 
028000 BOSTON 
333333333ZIDROW 
008000 NEW YORK 
400000000NEW EMPLOYEE 
016000 BOSTON 
444444444MILGR0M 
040000 BOSTON 
555555555BENJAMIN 
100000 CHICAGO 
610000000NEW 
EMPLOYEE I I 
018000 NEW YORK 
777777777BOROW 
055000 BOSTON 
888888888JAMES 
017500 NEW YORK 
999999999RENAZEV 
030000 NEW YORK 
SEQUENTIAL 
UPDATE 
TRANSACTION 
F I L E : 
222222222 
222222222 
400000000NEW EMPLOYEE 
500000000 
610000000NEW 
EMPLOYEE I I 
610000000 
666666666SHERRY 
777777777 
888888888JAMES 
028000 
BOSTON 
016000 BOSTON 
020000 
018000 CHICAGO 
NEW YORK 
055000 
017500 NEW YORK 
ERROR MESSAGES: 
NO MATCH 
500000000 
DUPLICATE ADDITION 
888888888 
i 

C
h
a
p
t
e
r 
1 7 
— 
Sequential 
File 
Maintenance 
Every record in the old master file contains four fields: social security number, 
n a m t i 
cctictrxr 
q o H ]r\ratir\n 
T K p rar*r\rrlc i n tlio r%ir\ r r i Q e t o r a r e ir» c a n n o n r o Kir crv^iol 
i x u * * * v . , 
u u . u * j , m i v i 
i v _ < » _ . u . i v . i i . 
A i i w 
i ^
w
i V. . J 1 1 1 l i a w u x u u i L U J t v l 
... • v.. t i l J l . ^ u v i l l . v 
U Jf 
J U W U l 
security number, the value of which must be unique for every record in the file. 
Records in the transaction file are also in sequence by social security number, and 
three types of transactions (additions, changes, a n d deletions) are present. T h e 
update procedure must be general enough to a c c o m m o d a t e multiple transactions 
for the s a m e record; for example, employee 222222222 has two records in the 
transaction file, both of which are corrections. 
Records with a transaction type of A are to be added to the n e w master file in 
their entirety. (Thus, N e w Employee, with social security n u m b e r 400000000, does 
not appear o n the old master but has been added to the n e w master.) Records with a 
transaction type of D are to be deleted. (Hence, Sherry, with social security n u m b e r 
666666666, appears in the old master but not the n e w master.) Records with a 
transaction code of C indicate a change in the value of a specific field(s) and contain 
only the social security n u m b e r a n d field (s) to be changed. (Accordingly, Baker, 
with social security n u m b e r 222222222, has h a d his salary a n d location changed to 
$28,000 a n d Boston, respectively.) 
Note, too, that in addition to the records for which there is activity, the old 
master contains several records for which there is no corresponding transaction; for 
example, there are no transactions for records with social security numbers of 
333333333 a n d 999999999. Such records are simply copied intact to the n e w master. 
All of these illustrations assume that the transaction file is valid in and of itself 
by virtue of a previously executed stand-alone 
edit program. In other words, the 
validation of the incoming transaction file has already been accomplished in an 
earlier program. This enables simplified logic in the maintenance program, as it can 
assume that all transactions contain a valid code OA C or D^ that the transactions 
are in sequence by social security number, that additions contain all necessary 
fields, and so on. (Data validation w a s first introduced in Chapter 8.) 
There are, however, two types of errors that cannot be detected in the stand­
alone edit, a n d which must be checked in the update program itself. These are the 
attempted correction or deletion of a nonexistent old master record (a no 
match), 
and the addition of a n e w record that is already in the old master file (a 
duplicate 
addition). 
The transaction file in Figure 17.2 illustrates both errors (with transactions 
500000000 a n d 888888888, respectively). 
Sequential versus Nonsequential Processing 
This chapter is concerned entirely with a sequential 
update whereby every record 
in the old master is copied to the n e w master regardless of whether or not it 
changes. This technique is perfectly adequate w h e n there is substantial activity in 
the old master file (that is, w h e n m a n y records change), but inefficient if only a few 
changes are m a d e to the existing master file. 
By contrast, a nonsequential 
update uses a single master file, which functions 
as both the old and n e w master. T h e records in the transaction file are processed 
one at a time, in no particular sequence, a n d matched against the existing master 
file. Nonsequential processing works best with low-activity files because unchanged 
records are left alone; that is, only those master records with a matching transaction 
record are written (rewritten) in the master file. Nonsequential processing is 
discussed in Chapter 18. 
All file maintenance is done periodically, with the frequency depending o n the 
application. A file of student transcripts is updated only a few times a year; a bank's 
checking transactions are updated daily, with other types of systems being updated 

weekly or monthly. (Real-time applications, which process transactions as they 
occur, are covered in conjunction with nonsequential processing in the next chapter.) 
A monthly cycle is depicted in Figure 17.3, beginning with a master file o n 
January 1. Transactions are collected (batched) during the m o n t h of January. Then, 
o n February 1, the master file of January 1 (now the old master) is processed with 
the transactions accrued during January, to produce a n e w master as of February 1. 
The process continues from m o n t h to month. Transactions are collected during 
February. O n M a r c h 1, w e use the file created February 1 as the old master, run it 
against the February transactions, and produce a n e w master as of M a r c h 1. The 
process continues indefinitely. 
Figure 17.3 also serves as a basis for discussion of h o w backup procedures 
axe 
implemented. Consider, for example, the situation o n M a r c h 1 after the update has 
been run. The installation n o w has three generations of the master file; the file just 
produced (current master), the file produced o n February 1st (previous master), 
a n d the original master file of January 1st (second previous master). 
The availability of previous generations of the master file enables re-creation 
of the update process, should the need arise. Thus, an installation could rerun the 
update of M a r c h 1st, provided it retained the February master a n d associated 
transaction file. It could also go back a generation and recreate the February master, 
given that it retained the original January master and its associated transaction file. 
The n u m b e r of generations that are retained depends o n the individual installation, 
but will seldom be fewer than three. This type of backup is referred to as a 
grandfather-father-son 
strategy (with apologies to w o m e n ) . 
The need for data validation is paramount, regardless of whether processing is 
done sequentially or nonsequentially, or h o w m a n y generations of backup are 
retained. The example in Figure 17.2 simply assumed a valid transaction file, a n 
assumption that is far too unrealistic in practice. Accordingly w e introduce concepts 
of data validation within the basis of a C O B O L case study. 
Figure 17.4 expands the sequential update of Figure 17.1 to include a separate 
step for data validation, in which the transaction file is first input to a stand-alone 

Chapter 
17 — 
Sequential 
File 
Maintenance 
Sequential Update with Data Validation 
OLD MASTER 
edit program. This program checks transactions for several errors (invalid transaction 
codes, incomplete additions, a n d so on), a n d only those transactions that pass all 
validity checks will be written to the output (valid) transaction file. The latter is then 
input to the sequential update. 
In effect, Figure 17.4 is a blueprint for the remainder of the chapter. W e begin 
with specifications for the edit program, develop the program completely, present a 
second set of specifications for the file maintenance (update) program, a n d develop 
that program in the second half of the chapter. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
Data Validation 
Narrative: 
This program illustrates typical types of data validation, which are implemented in a 
stand-alone edit program. 
I n p u t F i l e ( s ) : 
TRANSACTION-FILE 
Input Record Layout: 
01 TRANSACTION-RECORD. 
05 TR-SOC-SEC-NUMBER 
05 TR-NAME. 
10 TR-LAST-NAME 
10 TR-INITIALS 
05 TR-L0CATI0N-C0DE 
05 TR-C0MMISSI0N-RATE 
05 TR-SALES-AMOUNT 
05 TR-TRANSACTI0N-C0DE 
88 ADDITION 
VALUE 
88 CORRECTION 
VALUE 
88 DELETION 
VALUE 
'A' . 
' C . 
'D'. 
PIC X(9). 
PIC X(15) 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(5). 
PIC X. 
T e s t 
D a t a : 
See Figure 17.5a. 

Data 
Validation 
O u t p u t F i l e s : 
VALID-TRANSACTION-FILE 
ERROR-FILE 
O u t p u t R e c o r d L a y o u t : 
Identical to the input record layout. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Process a file of incoming transactions, rejecting any (and all) invalid transactions with 
an, appropriate error message. Each transaction Is to be checked for the following: 
a. Sequence—The transactions are supposed to be in ascending sequence according 
to social security number by virtue of a previous program. (Multiple transactions 
with the same social security number are allowed). Accordingly, this program is not 
to sort the transaction file but to implement logic to ensure that the transactions are 
in fact in order. (Sorting is time consuming and should not be repeated if the 
transactions are already in order.) 
b. Valid transaction code—Only three types of transaction codes are permitted: A, C, 
or D, denoting additions, corrections, and deletions, respectively. Any other 
transaction code (including a blank) is to be rejected, 
c. Completeness—Additions are to contain the employee's name and initials, location, 
and commission rate. All fields are to be checked with individual messages written 
for any missing fleld(s). Corrections must contain a value for the sales amount. 
d. Data types—TR-COMMISSION-RATE (required for an addition) and TR-SALES-
AMOUNT (required for a correction) must be numeric fields. A violation of either 
condition requires a specific error message. 
e. Valid location code Additions are to contain a valid location code—that is, a 
location code of ATL, BOS, NYC, PHI, or SF (corresponding to the entries in a 
location codes table to be embedded within the program). 
2. All valid transactions are to be written to a VALID-TRANSACTION-FILE, which will be 
created as an output file by the program. Invalid transactions may be discarded after 
the appropriate error message has been printed. 
The function of the edit program is best understood by examining Figure 17.5, 
which contains the input transaction file, associated error messages, a n d the output 
(valid) transaction file. Fourteen transactions were input to the edit program (Figure 
17.5a), but only eight of these passed all validity checks and thus m a d e it to the 
output file (Figure 17.5c). Y o u m a y find it useful to review each of the rejected 
transactions in conjunction with the associated error message in Figure 17.5b. 
Valid Transaction File 
000000OO0BOR0W 
JSATL07 
A 
000O00O00BOROW 
JS 
10000C 
000000000B0R0W 
JS 
20000C 
100000000GRABER 
P 
30000 
222222222NEW GUY 
RT 
A 
333333333ESMAN 
TNNY 09 
A 
400000000MOLDOF 
BLATL15 
A 
444444444RICHARDS 
IM 
05000C 
555555555J0RDAN 
BOS07 
A 
700000000MILGROM 
A 
D 
666666666J0HNS0N 
M NYC12 
A 
800000000VAZQUEZ 
C 
55000C 

C
h
a
p
t
e
r 
17 
— 
Sequential 
File 
Maintenance 
'igure 17.S 
(continued) 
800000000VILLAR 
C 
999999999GILLENS0N 
MANYC10 
(a) Transaction File 
100000000GRABER 
P 
30000 
222222222NEW GUY 
RT 
A 
222222222NEW GUY 
RT 
A 
333333333ESMAN 
TNNY 09 
A 
555555555J0RDAN 
B0S07 
A 
666666666J0HNS0N 
M NYC12 
A 
800000000VILLAR 
C 
C 
(b) Error Messages 
O0O00OOOOBOROW 
JSATL07 
A 
O0OO0OO0OBOROW 
JS 
10000C 
O000OO0OOBOROW 
JS 
20000C 
400000000MOLDOF 
BLATL15 
A 
444444444RICHARDS 
IM 
05000C 
700000000MILGROM 
A 
D 
800000000VAZQUEZ 
C 
55000C 
999999999GILLENS0N 
MANYC10 
A 
(c) Valid Transaction file 
i! 
I 
c 
A 
! 
INVALID TRANSACTION CODE 
MISSING LOCATION CODE 
MISSING OR NON-NUMERIC COMMISSION RATE 
INVALID LOCATION CODE 
MISSING NAME OR INITIALS 
SOCIAL SECURITY NUMBER OUT OF SEQUENCE 
MISSING OR NON-NUMERIC SALES AMOUNT 
Figure 17.6 
Hierarchy Chart for Data Validation Program 
EDIT 
TRANSACTION 
FILE 
PROCESS 
TRANSACTIONS 
DO SEQUENCE 
CHECK 
DO VALID 
CODE 
CHECK 
DO 
ADDITION 
CHECKS 
DO 
CORRECTION 
CHECKS 
DO WRITE 
VALID 
TRANSACTION 
WRITE ERROR 
MESSAGE 
WRITE ERROR 
MESSAGE 
WRITE ERROR 
MESSAGE 
WRITE ERROR 
MESSAGE 
WRITE ERROR 
MESSAGE 

at a 
Validation 
The edit program is developed along the same lines as any other program, first by 
designing a hierarchy chart to include the functions required by the program, and 
then by developing pseudocode to embrace sequence and decision-making logic. 
The hierarchy chart in Figure 17.6 is straightforward and should not present 
any difficulty. Note, however, that the module W R I T E - E R R O R - M E S S A G E is called 
from several places in the program because the function is subservient to each of 
the error-checking modules. W e have decided, therefore, to place these statements 
in a separate routine, rather than repeat the identical code in multiple places 
throughout the program. 
The pseudocode for the data validation program is s h o w n in Figure 17.7. Each 
incoming transaction is assumed to be valid initially, so that 'YES' is m o v e d to 
Pseudocode for Data Validation Program 
Open fi1es 
- 00 while data remains 
[ R E A D transaction file 
j 
AT END 
\ 
Indicate no more data 
! 
NOT AT END 
Move 'YES
! to valid-record-switch 
\ 
......... 
j p t r a n c - c n r i A1 - Q p r n H f w < n r p v i m i s ~<:nr i A1 - <;pr isri t v 
. 
-. 
. 
..... 
r. *.. • ~ ~~ — ...... 
Move 'NO' to valid-record-switch 
Write error message 
- ENDIF 
| 
Move trans-social-security to previous-social-security 
— IF transaction-code is not valid 
Move 'NO' to valid-record-switch 
| 
Write error message 
END IF 
— IF addition 
:— IF transaction fails addition-check(s) 
Move 'NO' to valid-record-switch 
j 
Write error message(s) 
I 
- ENDIF 
I 
ELSE 
I 
— IF correction 
| 
j — IF sales-amount not numeric 
| 
I 
Move 'NO' to valid-record-switch 
j 
j 
Write error message 
j
 
l—- ENDIF 
j 
j 
- ENDIF 
[ 
i-_ ENDIF 
I 
| - IF valid-record-switch = 'YES' 
j 
Write valid-transaction-record 
L- ENDIF 
— 
ENDREAD 
- ENDDO 
Close files 
Stop run 

Chapter 
17 
Sequential 
File 
Maintenance 
V A L I D - R E C O R D - S W I T C H . The transaction is then subjected to the various editing 
requirements, any one of which could cause V A L I D - R E C O R D - S W I T C H to be set to 
'NO'. Only if the transaction passes all of the individual checks (that is, if VALID-
R E C O R D - S W I T C H is still set to 'YES') is it written to the valid record file at the end of 
the loop. 
T h e C o m p l e t e d Program 
The completed program is s h o w n in Figure 17.8. O n e technique worthy of special 
mention is the establishment of a table for the error messages (lines 47 through 64) 
and the subsequent printing of an error message in the paragraph 400-WRITE-
E R R O R - M E S S A G E (lines 167-172). 
The Edit Program 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
EDIT. 
AUTHOR. 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT TRANSACTION-FILE 
ASSIGN TO 'A:\CHAPTR17\TRANS.DAT'  
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT VALID-TRANSACTION-FILE ASSIGN~T0'A:\CHAPTR17\VALTRANS.DAT' I 
ORGANIZATION IS LINE SEQUENTIAL. 
_ 
| \ 
' SELECT ERROR-FILE 
ASSIGN TO 'A:\CHAPTR17\ERR0R.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
DATA DIVISION. 
FILE SECTION. 
FD TRANSACTION-FILE 
DATA RECORD IS TRANSACTION-RECORD. 
01 TRANSACTION-RECORD 
PIC X(37). 
FD VALID-TRANSACTION-FILE 
DATA RECORD IS VALID-TRANSACTION-RECORD. 
01 VALID-TRANSACTION-RECORD 
PIC X(37). 
FD ERROR-FILE 
DATA RECORD IS ERROR-RECORD. 
01 ERROR-RECORD 
PIC X(132). 
WORKING-STORAGE SECTION. 
01 FILLER 
PIC X(14) 
VALUE 'WS BEGINS HERE'. 
01 WS-TRANSACTION-RECORD. 
05 TR-SOC-SEC-NUMBER 
05 TR-NAME. 
PIC X(9). 

Data 
Validation 
ire 17.8 
(continued) 
36 
37 
38 
39 
/in 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
05 
05 
AC 
UJ 
05 
10 TR-LAST-NAME 
10 TR-INITIALS 
TR-LOCATION-CODE 
TR-COMMISSI0N-RATE 
TR-SALES-AMOUNT 
TR-TRANSACTI0N-C0DE 
88 ADDITION 
VALUE 'A
1. 
88 CORRECTION 
VALUE ' C . 
88 DELETION 
VALUE 'D'. 
88 VALID-CODES 
VALUES 'A', 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(5). 
PIC X. 
' C , 'D'. 
01 
ERROR-VALUES-TABLE. 
05 ERROR-VALUES. 
10 FILLER 
PIC X(40) 
VALUE 'SOCIAL SECURITY NUMBER OUT OF SEQUENCE'. 
10 FILLER 
PIC X(40) 
VALUE 'INVALID TRANSACTION CODE'. 
10 FILLER 
PIC X(40) 
VALUE 'MISSING NAME OR INITIALS'. 
10 FILLER 
PIC X(40) 
VALUE 'MISSING LOCATION CODE'. 
10 FILLER 
PIC X(40) 
VALUE 'INVALID LOCATION CODE'. 
10 FILLER 
PIC X(40) 
VALUE 'MISSING OR NON-NUMERIC COMMISSION RATE'. 
10 FILLER 
PIC X(40) 
VALUE 'MISSING OR NON-NUMERIC SALES AMOUNT'. 
05 ERROR-TABLE REDEFINES ERROR-VALUES. 
10 ERROR-MESSAGE OCCURS 7 TIMES PIC X(40). 
01 
LOCATION-VALUES-TABLE. 
05 
LOCATION-VALUES. 
10 FILLER 
10 FILLER 
10 FILLER 
10 FILLER 
10 FILLER 
05 LOCATION-TABLE REDEFINES LOCATION-VALUES. 
10 LOCATION OCCURS 5 TIMES 
INDEXED BY LOCATION-INDEX 
PIC X(3). 
PIC X(3) VALUE 'ATL' 
PIC X(3) VALUE 'BOS' 
PIC X(3) VALUE 'NYC 
PIC X(3) VALUE 'PHI' 
PIC X(3) VALUE 'SF ' 
01 WS-ERROR-LINE. 
05 FILLER 
05 EL-REASON 
05 EL-TRANSACTION 
05 FILLER 
01 
WS-SWITCHES-AND-DATANAMES. 
05 WS-EOF-SWITCH 
05 
WS-VALID-RECORD-SWITCH 
PIC X(2). 
PIC X(40). 
PIC X(37). 
PIC X(54). 
PIC X(3) 
PIC X(3) 
VALUE 'NO '. 
VALUE SPACES. 

Chapter 
17 
Sequential 
File 
Maintenance 
jure 17.8 
(continued) 
86 
87 
05 WS-PREVIOUS-SOC-SEC-NUMBER 
PIC X(9) 
05 WS-ERR0R-C0DE 
PIC 99. 
VALUE SPACES. 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
PROCEDURE DIVISION. 
100-EDIT-TRANSACTION-FILE. 
OPEN INPUT TRANSACTION-FILE 
OUTPUT VALID-TRANSACTION-FILE 
ERROR-FILE. 
PERFORM UNTIL WS-EOF-SWITCH = 'YES' 
READ TRANSACTION-FILE INTO WS-TRANSACTION-RECORD 
AT END 
MOVE 'YES' TO WS-EOF-SWITCH 
NOT AT END 
PERFORM 210-PR0CESS-TRANSACTI0NS 
END-READ 
END-PERFORM. 
CLOSE TRANSACTION-FILE 
VALID-TRANSACTION-FILE 
ERROR-FILE. 
STOP RUN. 
210-PR0CESS-TRANSACTI0NS. 
MOVE 'YES' TO WS-VALID-RECORD-SWITCH. 
PERFORM 300-DO-SEQUENCE-CHECK. 
PERFORM 310-DO-VALID-CODE-CHECK. 
IF ADDITION 
PERFORM 320-DO-ADDITION-CHECKS 
ELSE 
IF CORRECTION 
PERFORM 330-D0-C0RRECTI0N-CHECKS 
END-IF 
END-IF. 
IF WS-VALID-RECORD-SWITCH = 'YES' 
PERFORM 340-WRITE-VALID-TRANSACTION 
END-IF. 
to output file 
300-DO-SEQUENCE-CHECK. 
IF TR-SOC-SEC-NUMBER < WS-PREVIOUS-SOC-SEC-NUMBER 
MOVE 1 TO WS-ERROR-CODE 
PERFORM 400-WRITE-ERR0R-MESSAGE~^-~^_^ 
END-IF. 
MOVE TR-SOC-SEC-NUMBER TO WS-PREVIOUS-SOC-SEC-NUMBER. 
310-DO-VALID-CODE-CHECK. 
IF NOT VALID-CODES 
• ' 
IMOVE 2 TO WS-ERROR-CODE 
PERFORM 400-WRITE-ERROR-MESSAGE 
END-IF. 
320-DO-ADDITION-CHECKS. 

at ion 
(continued) 
IF TR-LAST-NAME = SPACES OR TR-INITIALS = SPACES 
MOVE 3 TO WS-ERROR-CODE 
PERFORM 400-WRITE-ERROR-MESSA6E 
END-IF. 
IF TR-LOCATION-CODE = SPACES 
MOVE 4 TO WS-ERROR-CODE 
PERFORM 400-WRITE-ERROR-MESSAGE 
ELSE 
SET LOCATION-INDEX TO I 
! SEARCH LOCATION " "
" 
" " " 
~ " 
; 
AT END 
MOVE 5 TO WS-ERROR-CODE
 
1 
PERFORM 400-WRITE-ERROR-MESSAGE 
WHEN TR-LOCATION-CODE = LOCATION (LOCATION-INDEX) 
NEXT SENTENCE 
END-SEARCH 
_ 
j 
END-IF. 
IF TR-COMMISSION-RATE NOT NUMERIC 
MOVE 6 TO WS-ERROR-CODE 
PERFORM 400-WRITE-ERROR-MESSAGE 
END-IF. 
35n nn rnDDcrnnw rurri/e 
IF TR-SALES-AMOUNT NOT NUMERIC 
MOVE 7 TO WS-ERROR-CODE 
PERFORM 400-WRITE-ERROR-MESSAGE 
END-IF. 
340-WRITE-VALID-TRANSACTION. 
WRITE VALID-TRANSACTION-RECORD FROM WS-TRANSACTION-RECORD. 
400-WRITE-ERROR-MESSAGE. 
j 
MOVE 'NO ' TO WS-VALID-RECORD-SWITCH.
 
! 
MOVE SPACES TO WS-ERROR-LINE. 
\ 
MOVE ERROR-MESSAGE (WS-ERROR-CODE) TO EL-REASON, f 
MOVE WS-TRANSACTION-RECORD TO EL-TRANSACTION. 
j 
WRITE ERROR-RECORD FROM WS-ERROR-LINE. 
1 
The use of an error message table enables the programmer to see at a glance 
all of the errors checked by the program, a n d further to format those messages in 
identical fashion. It also facilitates the use of a c o m m o n routine to display the 
individual messages, rather than having to duplicate code throughout the program. 
Observe, therefore, that each error routine m o v e s an appropriate subscript value to 
WS-ERROR-CODE u p o n detection of an error, which is then used b y 400-WRITE-
ERROR-MESSAGE to display the appropriate error. 
Is data validation worth the extra time and trouble? A n y programmer w h o has 
ever been called at two in the morning will answer strongly in the affirmative. Put 
another way, diligent application of data validation (sometimes k n o w n as defensive 
programming) 
minimizes the need for subsequent debugging. All debugging 

C
h
a
p
t
e
r 
1 7 
-
Sequential 
File 
Maintenance 
techniques, no matter h o w sophisticated, suffer from the fact that they are applied 
after a problem has occurred. T h e inclusion of data validation within a system 
attempts to detect the (inevitable) errors that will occur before they produce a 
problem. 
W e are n o w ready to proceed with the main objective of the chapter, the development 
of a program for sequential file maintenance. Specifications follow in the usual 
format. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
Program Name: 
Sequential Update 
Narrative: 
This program implements the traditional sequential update via the balance line algorithm. 
Input Files: 
TRANSACTION-FILE 
OLD-MASTER-FILE 
Input R e c o r d L a y o u t : 
01 TRANSACTION-RECORD. 
05 TR-SOC-SFC-NUMBFR 
TR-NAME. 
10 TR-LAST-NAME 
10 TR-INITIALS 
TR-L0CATI0N-C0DE 
TR-COMMISSION-RATE 
TR-SALES-AMOUNT 
TR-TRANSACTION-CODE 
88 ADDITION 
VALUE 'A'. 
88 CORRECTION 
VALUE ' C . 
88 DELETION 
VALUE 'D
1. 
05 
05 
05 
05 
05 
01 OLD-MASTER-RECORD. 
05 
0M-S0C-SEC-NUMBER 
0M-NAME. 
10 0M-LAST-NAME 
10 0M-INITIALS 
0M-L0CATI0N-C0DE 
0M-C0MMISSI0N-RATE 
0M-YEAR-T0-DATE-SALES 
05 
05 
05 
05 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(5). 
PIC X. 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(8). 
O u t p u t File: 
NEW-MASTER-FILE 
O u t p u t Record L a y o u t : 
Identical to old master record. 
T e s t D a t a : 
P r o c e s s i n g R e q u i r e m e n t s : 
See Figure 17.9a (Old Master File) and Figure 17.9b (Valid Transaction File). 
1. Develop a sequential update program to process an incoming transaction file and the 
associated old master file to produce a new master file. 
2. The transaction file is assumed to be valid in and of itself by virtue of a stand-alone edit 
program. Hence, each transaction has a valid transaction code (A, C, or D), numeric 

Sequential 
File 
Maintenance 
Test Data 
100000000GRABER 
200000000RUBIN 
300000000ANDERSON 
400000000MOLDOF 
500000000GLASSMAN 
600000000GRAUER 
700000000MILGROM 
800000000VAZQUEZ 
900000000CLARK 
P ATL1500000000 
MAB0S0800020000 
IRBOS1000113000 
BLATL1500000000 
JSNYC1000045000 
RTNYC0800087500 
A SF 0900120000 
C ATL1200060000 
E NYC0700002500 
000000000BOROW 
O00000000BOROW 
OOOOOOOOOBOROW 
400000000MOLOOF 
444444444RICHARDS 
700000000MILGR0M 
800000000VAZQUEZ 
IM 
A 
JSATL07 
JS 
JS 
BLATL15 
A 
10000C 
20000C 
A 
05000C 
D 
55000C 
999999999GILLENS0N 
MANYC10 
A 
fields are numeric, and so on. Nevertheless, the update program must check (and 
flag) two kinds of errors that could not be detected in the stand-alone edit, as they 
require interaction with the old master file. These are: 
a. Duplicate additions, in which the social security number of a transaction coded as 
an addition already exists in the old master, 
b. No matches, in which the social security number of a transaction coded as either a 
deletion or a correction, does not exist in the old master. 
3. Transactions coded as additions are to be added to the new master file in their 
entirety, and will contain a value for every field in the transaction record (except for TR-
SALES-AMOUNT). The value of YEAR-TO-DATE-SALES in the new master record is to 
be initialized to zero. 
4. Transactions coded as deletions are to be removed from the master file. These 
transactions contain only the social security number and transaction code. 
5. Transactions coded as corrections contain only the social security number, name, and 
the transaction sales amount (TR-SALES-AMOUNT). The value of TR-SALES-AMOUNT 
on the incoming transaction is to be added to the value in the YEAR-TO-DATE-SALES 
field in the master record. 
6. Any old master record for which there is no corresponding transaction is to be copied 
intact to the new master. 
Every C O B O L book has confronted the problem of a sequential update. Barry Dwyer
1 
details a general a n d elegant solution to the problem k n o w n as the balance line 
1. B. Dwyer, "One More Time—How to Update a Master File," Communications of the ACM, vol. 24, 
no.l (lanuary 1981). 

C
h
a
p
t
e
r 
1 
7 
Sequential 
File 
Maintenance 
algorithm. 
To understand this solution, realize that the logic in a sequential update 
it. 
mr**-r. 
Al¥£lr.,A+ 
+ U « « 
I, ,..- U ~ ~ ~ ~ ~ ~ ~ 
+ 
A : — ~ . 
^ 
~ L 
* 
1 
iS u i u j c 
c m i i c u i L 
m a n 
v v n a i n a a 
u c c n 
c i i n j i i m c i c u 
111 p i c v i u u s 
cildpic;i?> 
u e c a u s t ; 
there are multiple input files. T h e essence of the problem, then, is to determine 
whether to read from the old master file, the transaction file, or both. The solution is 
handled neatly in the balance line algorithm by the concept of a n active key. 
The active 
key is the smaller of the old master key and transaction key currently 
being processed. Thus, if the transaction key is less than the old master key, the 
active key is equal to the transaction key; if the transaction a n d old master keys are 
equal, the active key is equal to either; finally, if the old master key is less than the 
transaction key, the active key is the old master. (Note h o w easily the technique can 
be extended to multiple transaction files; the active key is always defined as the 
smallest value of all keys currently processed.) 
The active key determines which records are admitted to the update process, 
and is illustrated with respect to the data in Figure 17.9. At the start of execution, the 
initial social security numbers for the old master a n d transaction records are 
100000000 a n d 000000000, respectively, yielding an active key of 000000000. Thus, 
only the transaction record is considered for processing, while the old master record 
is held in abeyance. T h e algorithm processes this transaction, then reads another 
record from the transaction file, again with social security n u m b e r 000000000. The 
keys are compared and again the transaction key is less than the master key, leaving 
the active key unchanged. After this transaction is processed, a third transaction is 
read, also with social security n u m b e r 000000000, with the s a m e results. 
T h e fourth transaction with social security n u m b e r 400000000 is read and 
produces a n e w active key of 100000000, which is the lesser of the old master 
(100000000) a n d transaction (400000000) social security numbers. The old master 
record is admitted to the update process, while the transaction record is he'd. The 
process continues in this fashion until eventually both files are out of data. 
The balance line algorithm is expressed in pseudocode in Figure 17.10. T h e 
initial records are read from each file, a n d the first active key is determined. Next 
the major loop is executed until both the old master a n d transaction files are out of 
data. (HIGH-VALUES is a C O B O L figurative literal a n d denotes the largest possible 
value. It is a convenient w a y of forcing end-of-file 
conditions, as will be seen w h e n 
test data are examined later in the chapter.) 
Within the outer loop, the key of the old master record is compared to the 
active key. If these values are equal, the old master record is m o v e d (but not written) 
to the n e w master file, and another record is read from the old master file. W e are 
not, however, finished with the original master record as it must be determined if 
any transactions exist for that record. Accordingly a n inner loop is executed, which 
processes all transactions whose key is equal to the active key. (The transaction file 
is read repeatedly in the inner loop after each transaction is processed.) W h e n the 
transaction key no longer equals the active key, a check is m a d e to see if a deletion 
w a s processed, a n d if not, the n e w master record is written. T h e next active key is 
chosen, a n d the outer loop continues. 
Figure 17.10 does not include the logic to a c c o m m o d a t e error processing; that 
is, although the transaction file is assumed to be valid in a n d of itself, there are 
additional errors that c o m e to light only in the actual updating process. Specifically, 
the update program must reject transactions that attempt to add records that already 
exist in the old master (duplicate additions), a n d m u s t also reject transactions that 
attempt to change or delete records that do not exist (a no match). 
The easiest w a y to accomplish this error processing is through the assignment 
of an allocation 
status to every value of the active key; that is, the value of the key is 
either allocated or it is not. If the allocation status is on, the record belongs in the 
file; if the allocation status is off, the record does not belong. Deletion of an existing 
record changes the status from o n to off, whereas addition of a n e w record alters the 

Sequential 
File 
Maintenance 
Figure 17.10 Balance Line Algorithm 
I 
Open files 
| 
Read transaction-file, at end move high-values to transaction-key 
| 
Read old-master-file, at end move high-values to old-master-key 
j 
Choose first active-key 
----- DO WHILE active-key not equal high-values 
I — IF old-master-key = active-key 
Move old-master-record to new-master-record 
Read old-master-file, at end move high-values to old-master-key 
ENDIF 
— DO WHILE transaction-key equal active-key 
Apply transaction to new-master-record 
Read transaction-file, at end move high-values to transaction-key 
j 
— ENDDO 
I 
i 
i— IF no deletion was processed 
j 
Write new-master-record 
— ENDIF 
| 
Choose next active-key 
j 
^- ENDDO 
! 
Close files 
j 
Stop run 
I 
status from off to on. A n y attempt to a d d a record whose status is already o n 
signifies a duplicate addition. In similar fashion, attempting to change or delete a 
record whose allocation status is off also signifies an error, as the transaction key is 
not present in the old master. 
Figure 17.11 expands the pseudocode of Figure 17.10 to include R E C O R D -
K E Y - A L L O C A T E D - S W I T C H to accommodate this discussion. A record is written to 
the n e w master file only w h e n R E C O R D - K E Y - A L L O C A T E D - S W I T C H is set to YES. In 
other words, deletions are accomplished simply by setting the switch to N O and not 
writing the record. 
Y o u should be convinced of the total generality of Figure 17.11 and, further, 
that multiple transactions for the s a m e key m a y be presented in any order. For 
example, if an addition a n d correction are input in that order, the record will be 
added and corrected in the same run. However, if the correction precedes the 
addition, then the correction will be flagged as a n o match, and only the addition 
will take effect. T w o additions for the s a m e key will result in adding the first a n d 
flagging the second as a duplicate add. A n addition, correction, and deletion m a y be 
processed in that order for the s a m e transaction. A deletion followed by an addition 
m a y also be processed but will produce an error message, indicating a n attempt to 
delete a record that is not in the old master. 
Designing the Hierarchy Chart 
, 
Recall that pseudocode a n d a hierarchy chart depict different things. Pseudocode 
indicates sequence a n d decision-making logic, whereas a hierarchy chart depicts 
function, indicating what has to be done, but not necessarily w h e n . Accordingly, w e 

Chapter 
17 
Sequential 
File 
Maintenance 
Figure 1 7 . * 1 
Expanded Balance Line Algorithm 
Open files 
Read transaction-file, at end move high-values to transaction-key 
Read old-master-file, at end move high-values to old-master-key 
Choose first active-key 
— D O WHILE active-key not equal high-values 
!— IF old-master-key = active-key 
Move 'yes' to record-key-allocated-switch 
Move old-master-record to new-master-record 
Read old-master-file, at end move high-values to old-master-key 
ELSE (active-key is not in old-master-file) 
Move 'no' to record-key-allocated switch 
'— ENDIF 
r— DO WHILE transaction-key equal active-key 
— DO CASE transaction-code 
CASE addition 
— IF record-key-allocated-switch = 'yes' 
Write 'error - duplicate addition' 
ELSE (active-key is not in old-master-file) 
Move transaction-record to new-master-record 
Move 'yes' to record-key-allocated-switch 
— ENDIF 
CASE correction 
— IF record-key-allocated-switch = 'yes' 
Process correction 
, 
i 
ELSE (active-key is not in old-master-file) 
| 
Write 'error - no matching record' 
— ENDIF 
CASE deletion 
r— IF record-key-allocated-switch = 'yes' 
Move 'no' to record-key-allocated-switch 
ELSE (active-key is not in old-master-file) 
j 
Write 'error - no matching record' 
| 
I— ENDIF 
! 
— END CASE 
I 
1 
Read transaction-file, at end move high-values to transaction-key 
— END DO 
i — IF record-key-allocated-switch = 'yes' 
write new-master-record 
I— ENDIF 
Choose next active-key 
— END DO 
| 
Close files 
I 
Stop run 
[ 

Sequential 
File 
Maintenance 
begin by listing the functional modules necessary to accomplish a sequential update 
using the balance line algorithm: 
Overall Program Function 
UPDATE-MASTER-FILE 
Functional Modules 
READ-TRANSACTION-FILE 
READ-OLD-MASTER-FILE 
CHOOSE-ACIIVE-KEY 
PROCESS-ACTIVE-KEY 
BUILD-NEW-MASTER 
WRITE-NEW-MASTER 
APPLY-TRANSACTIONS-TO-MASTER 
ADD-NEW-RECORD 
CORRECT-OLD-RECORD 
DELETE-OLD-RECORD 
The hierarchy chart in Figure 17.12 is d e v e l o p e d in t o p - d o w n 
fashion, 
b e g i n n i n g 
w i t h t h e overall 
p r o g r a m 
f u n c t i o n , 
U P D A T E - M A S T E R - F I L E . 
D e v e l o p m e n t of a hierarchy chart requires explicit specification of t h e function of 
each module, which should be apparent from the module name, consisting of a 
verb, o n e or t w o adjectives, and an object. Nevertheless, the m o d u l e functions 
are described in depth: 
UPDATE-MASTER-FILE 
T h e m a i n l i n e r o u t i n e that drives the entire 
program. It o p e n s the program files, invokes 
Hierarchy Chart for Sequential Update 
UPDATE 
MASTER 
FILE 
READ 
TRANSACTION 
FILE 
READ 
OLD-MASTER 
FILE 
CHOOSE 
ACTIVE KEY 
PROCESS 
ACTIVE KEY 
BUILD NEW 
MASTER 
APPLY TRANS 
TO MASTER 
CHOOSE 
ACTIVE KEY 
WRITE NEW 
MASTER 
READ 
OLD-MASTER 
FILE 
ADD NEW 
RECORD 
CORRECT 
EXISTING 
RECORD 
DELETE 
EXISTING 
RECORD 
READ 
TRANSACTION 
FILE 

C
h
a
p
t
e
r 
17 
— 
Sequential 
File 
Maintenance 
R E A D - T R A N S A C T I O N - F I L E 
R E A D - O L D - M A S T E R - F I L E 
C H O O S E - A C T I V E - K E Y 
PROCESS-ACTIVE-KEY 
B U I L D - N E W - M A S T E R 
W R I T E - N E W - M A S T E R 
A P P L Y - T R A N S - T O - M A S T E R 
ADL) N E W - R E C O R D 
C O R R E C T - O L D - R E C O R D 
D E L E I E - O L D - R E C O R D 
subordinate routines to do a n initial read from 
each input file, a n d determines the first active 
key. It invokes PROCESS-ACTIVE-KEY until all files 
are out of data, closes the files, and terminates 
the run. 
Reads a record from the transaction file and moves 
H I G H - V A L U E S to the transaction key w h e n the 
file is empty. This module is performed from more 
than one place in the program as indicated by the 
shading in the upper left-hand corner. 
Reads a record from the old master file and moves 
H I G H - V A L U E S to the old master key w h e n the 
file is empty. This module is performed from more 
than one place in the program as indicated by the 
shading in the upper left-hand corner. 
Determines the active key for the balance line 
algorithm from the current values of the old 
master and transaction records. This module is 
also performed from m o r e than one place. 
Performs u p to four subordinates according to 
the value of active key. All four subordinates are 
invoked w h e n the keys o n the old master a n d 
transaction files equal the active key, a n d n o 
deletions were processed. 
M o v e s the current old master record to a 
corresponding n e w master record. This module 
is mandated by the nature of a sequential update, 
which requires that every record in the old master 
file be copied to the n e w master file, regardless of 
whether the record changes. 
Writes a n e w master record, a n d is performed 
only after all transactions for that record have 
been processed. 
Performs one of three subordinates to add, correct, 
or delete a record according to the current 
transaction code. Regardless of the transaction 
type, the m o d u l e invokes R E A D - T R A N S A C T I O N -
FILE to obtain the next transaction and executes 
repeatedly as long as the transaction key equals 
the active key. 
Lowest-level module to add a n e w record, which 
will set R E C O R D - K E Y - A L L O C A T E D - S W I T C H to 
YES. 
Lowest-level module to update (correct) the year-
to-date sales total in an existing master record. 
Lowest-level module to delete a record, which will 
set R E C O R D - K E Y - A L L O C A T E D - S W I T C H to N O . 

T o p - d o w n testing implies that the highest (most difficult) modules in a hierarchy 
chart be tested earlier, and more often, than the lower-level (and often trivial) 
routines. It requires that testing begin as soon as possible, and well before the 
program is finished. Testing a program before it is completed is accomplished by 
coding lower-level modules as program stubs, that is, abbreviated versions of 
completed modules. 
The major advantage in this approach is that testing begins sooner in the 
development cycle. Errors that do exist are found earlier and consequently are 
easier to correct. Later versions can still contain bugs, but the more difficult problems 
will already have been resolved in the initial tests. 
Figure 17.9 (shown previously) contains sufficient data to adequately test the 
update program. All transaction types are present with multiple transactions present 
for the s a m e transaction record (000000000). There is a duplicate addition 
(400000000) that should be flagged as an error, as well as an attempted correction 
on a nonexisting social security n u m b e r (444444444). 
It is highly desirable that a person other than the programmer, preferably the 
user, supply the test data. The latter individual does not k n o w h o w the program 
actually works, and thus is in a better position to m a k e u p objective data. In addition, 
the user knows the original specification and is not subject to distortions from the 
analysis phase. The programmer, o n the other hand, is biased, either consciously or 
subconsciously, and will generate data to accommodate his or her program or 
interpretation of the specifications. W e should also mention that anticipated results 
are best computed before testing begins. Otherwise, it is too easy to assume the 
program works, because the output "looks right." Indeed, trainees are often so 
overjoyed merely to get output that they conclude the testing phase u p o n receiving 
their first printout. 
The Stubs Program 
,,. 
. . 
Figure 17.13 contains the stubs program for a sequential update implemented 
according to the balance line algorithm. It is complete in that it contains a 
paragraph for every module in the hierarchy chart of Figure 17.12, yet incomplete 
because several of the lower-level modules exist only as program stubs, that is, 
abbreviated paragraphs. 
Figure 17.13 uses only two files, the old master and transaction, with record 
descriptions corresponding to the programming specifications. The n e w master file 
is not referenced explicitly in the program; instead, the paragraphs 0060-BUILD-
N E W - M A S T E R and 0 0 8 0 - W R I T E - N E W - M A S T E R contain DISPLAY statements to 
indicate that they have been executed. Indeed, the program contains m a n y such 
DISPLAY statements to facilitate testing by indicating program flow. 
Consider the test data in Figure 17.9, in conjunction with the program in 
Figure 17.13 and its associated output (Figure 17.14). The program begins by reading 
the first record from each file, social security numbers 000000000 and 100000000 for 
the transaction and old master, respectively. The active key is the smaller of the two, 
social security n u m b e r 000000000, and corresponds to the transaction value. The 
paragraph 0 0 7 0 - A P P L Y - T R A N S - T O - M A S T E R is entered for the first transaction, 
after which the lower-level paragraph 0 0 9 0 - A D D - N E W - R E C O R D is invoked. The 
second and third transactions also have a social security n u m b e r of 000000000, so 
that 0 0 7 0 - A P P L Y - T R A N S - T O - M A S T E R is executed twice more, each time followed 
by 0100-CORRECT-EXISTING-RECORD. Finally, w h e n the transaction key no longer 

C
h
a
p
t
e
r 
1 7 
Sequential 
File 
Maintenanc 
fare 17.13 
Stubs Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
SEQSTUB. 
AUTHOR. 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT TRANSACTION-FILE 
ASSIGN TO 'A:\CHAPTR17\VALTRANS.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT OLD-MASTER-FILE 
ASSIGN TO 'A:\CHAPTR17\OLDMAST.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
DATA DIVISION. 
FILE SECTION. 
FD TRANSACTION-FILE 
DATA RECORD IS TRANSACTION-RECORD. 
01 
TRANSACTION-RECORD 
FD OLD-MASTER-FILE 
DATA RECORD IS OLD-MAST-RECORD. 
01 
OLD-MAST-RECORD 
WORKING-STORAGE SECTION. 
01 FILLER 
VALUE 'WS BEGINS HERE
1. 
01 WS-TRANS-RECORD. 
05 
TR-SOC-SEC-NUMBER 
TR-NAME. 
10 TR-LAST-NAME 
10 TR-INITIALS 
TR-LOCATION-CODE 
TR-COMMISSION-RATE 
TR-SALES-AMOUNT 
05 
05 
05 
05 
05 
TR-TRANSACTION-CODE 
88 ADDITION 
VALUE 'A'. 
88 CORRECTION 
VALUE ' C . 
88 DELETION 
VALUE 'D'. 
01 WS-OLD-MAST-RECORD. 
05 OM-SOC-SEC-NUMBER 
OM-NAME. 
10 OM-LAST-NAME 
10 OM-INITIALS 
OM-LOCATION-CODE 
OM-COMMISSION-RATE 
0M-YEAR-TO-DATE-SALES 
05 
05 
05 
05 
01 WS-BALANCE-LINE-SWITCHES. 
05 
WS-ACTIVE-KEY 
05 
WS-RECORD-KEY-ALLOCATED-SWITCH 
PIC X(37). 
PIC X(39). 
PIC X(14) 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(5). 
PIC X. 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(8). 
PIC X(9). 
PIC X(3). 
squired 
-non types 
sided 

Top-Down 
Testing 
(continued) 
52 
53 
PROCEDURE DIVISION. 
54 
0010-UPDATE-MASTER-FILE. 
55 
OPEN INPUT TRANSACTION-FILE 
56 
OLD-MASTER-FILE. 
57 
[PERFORM 0020-READ-TRANSACTION-FILE.
 
1 
58 
i PERFORM 0030-READ-OLD-MASTER-FILE. , 
59 
PERFORM 0040-CHOOSE-ACTIVE-KEY. 
60 
PERFORM 0050-PROCESS-ACTIVE-KEY 
61 
UNTIL WS-ACTIVE-KEY = HIGH-VALUES. 
62 
CLOSE TRANSACTION-FILE 
63 
OLD-MASTER-FILE. 
64 
STOP RUN. 
65 
66 
0020-READ-TRANSACTION-FILE. 
67 
READ TRANSACTION-FILE INTO WS-TRANS-RECORD 
68 
AT END MOVE HIGH-VALUES TO TR-SOC-SEC-NUMBER 
69 
END-READ. 
70 
71 
0030-READ-OLD-MASTER-FILE. 
72 
READ OLD-MASTER-FILE INTO WS-OLD-MAST-RECORD 
73 
AT END MOVE HIGH-VALUE TO OM-SOC-SEC-NUMBER 
74 
END-READ. 
75 
76 
0040-CHOOSE-ACTIVE-KEY. 
77 
IF TR-SOC-SEC-NUMBER LESS THAN OM-SOC-SEC-NUMBER j 
78 
MOVE TR-SOC-SEC-NUMBER TO WS-ACTIVE-KEY 
79 
! ELSE 
80 
MOVE OM-SOC-SEC-NUMBER TO WS-ACTIVE-KEY 
81 
! END-IF. 
82 
"
" 
~
_
"
" 
83 
0050-PROCESS-ACTIVE-KEY. 
84 
[ DISPLAY ' 
"
"
"
~ 
85 
\ DISPLAY ' 
86 
! DISPLAY 'RECORDS BEING PROCESSED'. 
87 
j DISPLAY ' TRANSACTION SOC SEC #: ' TR-SOC-SEC-NUMBER 
88 
| DISPLAY ' OLD MASTER SOC SEC #: ' OM-SOC-SEC-NUMBER 
89 
| DISPLAY ' ACTIVE KEY: 
' WS-ACTIVE-KEY. 
90 
i DISPLAY ' 
_ 
_ 
_ 
91 
" " ~ 
~
"
"
"
~
~ 
92 
IF OM-SOC-SEC-NUMBER = WS-ACTIVE-KEY 
93 
MOVE 'YES' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
94 
PERFORM 0060-BUILD-NEW-MASTER 
95 
ELSE 
96 
MOVE 'NO' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
97 
END-IF. 
98 
99 
PERFORM 0070-APPLY-TRANS-TO-MASTER 
100 
UNTIL WS-ACTIVE-KEY NOT EQUAL TR-SOC-SEC-NUMBER. 
101 
102 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 

C
h
a
p
t
e
r 
17 
Sequential 
File 
Maintenance 
Figure 17.13 
(continued) 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
PERFORM 0080-WRITE-NEW-MASTER 
END-IF. 
PERFORM 0040-CH00SE-ACTIVE-KEY. 
0060-BUILD-NEW-MASTER. 
DISPLAY '0060-BUILD-NEW-MASTER ENTERED'. 
PERFORM 0030-READ-0LD-MASTER-FILE. 
- DISPLA Y statement indicates 
paragraph has bean called 
0070-APPLY-TRANS-TO-MASTER. 
DISPLAY '0070-APPLY-TRANS-TO-MASTER ENTERED' 
TRANSACTION CODE: ' TR-TRANSACTI0N-C0DE. 
EVALUATE TRUE 
WHEN ADDITION 
PERFORM 0090-ADD-NEW-RECORD 
WHEN CORRECTION 
PERFORM 0100-CORRECT-EXISTING-RECORD 
WHEN DELETION 
PERFORM 0110-DELETE-EXISTING-RECORD 
WHEN OTHER 
DISPLAY 'INVALID TRANSACTION CODE' 
END-EVALUATE. 
module to execute 
PERFORM 0020-READ-TRANSACTION-FILE. 
0080-WRITE-NEW-MASTER.}-
DISPLAY '0080-WRITE-NEW-MASTER ENTERED'. 
0090-ADD-NEW-RECORD. 
j — " 
DISPLAY '0090-ADD-NEW-RECORD ENTERED'. 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
DISPLAY ' ERROR-DUPLICATE ADDITIO!^' TR-SOC-SEC-NUMBER 
ELSE 
MOVE 'YES' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
END-IF. 
Partially coded 
paragraphs 
0100-CORRECT-EXISTING-RECORD. 
DISPLAY '0100-CORRECT-EXISTING-RECORD ENTERED.' 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
NEXT SENTENCE 
ELSE 
DISPLAY ' ERROR-NO MATCHING RECORD: ' TR-SOC-SEC-NUMBER 
END-IF. 
0110-DELETE-EXISTING-RECORD. 
DISPLAY '0110-DELETE-EXISTING-RECORD ENTERED' 
, RECORD-KEY-ALLOCA 
TED-SWITCH 
controls deletion 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES 
MOVE 'NO' TO WS-RECORD-KEY-ALLOCATED- SWITCH 
ELSE 
DISPLAY ' ERROR-NO MATCHING RECORD: ' TR-SOC-SEC-NUMBER 
END-IF. 

Figure 17.14 
Truncated Output of Stubs Program 
RECORDS BEING PROCESSED 
TRANSACTION SOC SEC #: 000000000 
OLD MASTER SOC SEC #: 
100000000 
ACTIVE KEY: 
000000000 
0070-APPLY-TRANS-TO-MASTER ENTERED 
TRANSACTION CODE: A 
0090-ADD-NEW-RECORD ENTERED 
0070-APPLY-TRANS-TO-MASTER ENTERED 
TRANSACTION CODE: C 
0100-C0RRECT-EXISTING-REC0RD ENTERED. 
0070-APPLY-TRANS-TO-MASTER ENTERED 
TRANSACTION CODE: C 
0100-CORRECT-EXISTING-RECORD ENTERED. 
0080-WRITE-NEW-MASTER ENTERED 
RECORDS BEING PROCESSED 
TRANSACTION SOC SEC #: 400000000 
OLD MASTER SOC SEC #: 
lOOOpOOOO 
ACTIVE KEY: 
100000000 
0060-BUILD-NEW-MASTER ENTERED 
0080-WRITE-NEW-MASTER ENTERED 
RECORDS BEING PROCESSED 
TRANSACTION SOC SEC #: 400000000 
OLD MASTER SOC SEC #: 
200000000 
ACTIVE KEY: 
200000000 
0060-BUILD-NEW-MASTER ENTERED 
0080-WRITE-NEW-MASTER ENTERED 
RECORDS BEING PROCESSED 
TRANSACTION SOC SEC #: 400000000 
OLD MASTER SOC SEC #: 300000000 
ACTIVE KEY: 
300000000 
0060-BUILD-NEW-MASTER ENTERED 
0080-WRITE-NEW-MASTER ENTERED 
RECORDS BEING PROCESSED 
TRANSACTION SOC SEC #: 400000000 
OLD MASTER SOC SEC #: 
400000000 
ACTIVE KEY: 
400000000 
0060-BUILD-NEW-MASTER ENTERED 
0070-APPLY-TRANS-TO-MASTER ENTERED 
TRANSACTION CODE: A 
0090-ADD-NEW-RECORD ENTERED 
ERROR-DUPLICATE ADDITION: 400000000 
0080-WRITE-NEW-MASTER ENTERED 
RECORDS BEING PROCESSED 
TRANSACTION SOC SEC #: 999999999 
OLD MASTER SOC SEC #: 
ACTIVE KEY: 
999999999 
0070-APPLY-TRANS-TO-MASTER ENTERED 
TRANSACTION CODE: A 
0090-ADD-NEW-RECORD ENTERED 
0080-WRITE-NEW-MASTER ENTERED 
1 

C
h
a
p
t
e
r 
1 
7 
Sequential 
File 
Maintenance 
equals the active key, that is, w h e n the fourth transaction (Moldof, with social 
security n u m b e r 400000000) is read, the paragraph 0080-VvRITE-NEvV-lviASTER is 
executed to write the n e w (and corrected) record to the n e w master file. 
T h e next determination of the active key compares the transaction just read 
(social security n u m b e r 400000000) to the current old master social record (social 
security n u m b e r 100000000), producing an active key of 100000000. The program 
decides there are no transactions for this old master record and copies it immediately 
to the n e w master file, as implied by the paragraphs 0 0 6 0 - B U I L D - N E W - M A S T E R 
and 0 0 8 0 - W R I T E - N E W - M A S T E R . The next two determinations of the active key (for 
old master records 200000000 and 300000000) produce a similar result. The fifth 
determination of the active key finds the s a m e social security n u m b e r in both files 
in conjunction with an attempted addition in the transaction file, producing an 
error message for a duplicate addition. 
By n o w you should be gaining confidence that the program is working correctly, 
because the paragraphs are executing in proper sequence for the test data. W e can 
say therefore that the initial testing has concluded successfully and m o v e o n to 
developing the completed program. 
O n c e the stubs program has been tested and debugged, it is relatively easy to 
complete the program because the most difficult portion has already been written. 
W e k n o w that the interaction between modules works correctly; that the program 
will correctly read from the old master, transaction file, or both; that it will apply 
multiple transactions to the s a m e master record; and that it will properly perform 
the appropriate lower-level m o d u l e to add, correct, or delete a record. 
Figure 17.15 contains the expanded update program, which defines an 
additional F D for the N E W - M A S T E R - F I L E as well as completed paragraphs for the 
addition and correction routines. T h e DISPLAY statements associated with the 
testing procedure have also been deleted. 
The files associated with the completed program are s h o w n in Figure 17.16. 
Figures 17.16a and 17.16b repeat the original test data (for convenience), whereas 
Figures 17.16c a n d 17.16d contain the actual output. Y o u should take a m o m e n t to 
verify the results to satisfy yourself that the program is working correctly. Observe in 
particular h o w multiple transactions were applied to a single old record (Borow), 
h o w B o r o w and Gillenson were successfully added to the n e w master, a n d h o w 
Milgrom w a s deleted. T h e two error messages correctly reflect both errors, an 
attempted duplicate addition a n d a non matching social security number. 
Figure 17,15 
Completed Sequential Update 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
SEQUPDT. 
AUTHOR. 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT TRANSACTION-FILE 
ASSIGN 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT OLD-MASTER-FILE 
ASSIGN 
ORGANIZATION IS LINE SEQUENTIAL. 
ASSIGN TO 'A:\CHAPTR17\VALTRANS.DAT 
ASSIGN TO 'A:\CHAPTR17\0LDMAST.DAT 

Top-Down 
Testing 
i i 
.c 
<" 
. 
(continued) 
12 
13 
[SELECT NEW-MASTER-FILE 
ASSIGN 
i 
ORGANIZATION IS LINE SEQUENTIAL 
TO 'A:\CHAPTR17\NEWMAST. 
14 
-
15 
DATA DIVISION. 
16 
FILE SECTION. 
17 
FD TRANSACTION-FILE 
18 
DATA RECORD IS TRANSACTION-RECORD. 
19 
01 TRANSACTION-RECORD 
PIC X(37). 
20 
21 
FD OLD-MASTER-FILE 
22 
DATA RECORD IS OLD-MAST-RECORD. 
23 
01 OLD-MAST-RECORD 
PIC X(39). 
24 
25 
FD NEW -MASTER-FILE 
26 
DATA RECORD IS NEW-MAST-RECORD. 
27 
01 NEW-MAST-RECORD 
PIC X(39). 
28 
29 
WORKING -STORAGE SECTION. 
30 
01 FIL LER 
PIC X(14) 
31 
VALUE 'WS BEGINS HERE' . 
32 
33 
01 WS-TRANS-RECORD. 
34 
05 TR-SOC-SEC-NUMBER 
PIC X(9). 
35 
05 TR-NAME. 
36 
10 TR-LAST-NAME 
PIC X(15). 
37 
10 TR-INITIALS 
PIC XX. 
38 
05 TR-LOCATION-CODE 
PIC X(3). 
39 
05 TR-COMMISSION-RATE 
PIC 99. 
40 
05 TR-SALES-AMOUNT 
PIC 9(5). 
41 
05 TR-TRANSACTION-CODE 
PIC X. 
42 
88 ADDITION 
VALUE 'A', j 
43 
88 CORRECTION 
VALUE 'C . r 
44 
88 DELETION 
VALUE 'D'. | 
45 
46 
01 WS-OLD-MAST-RECORD.l, 
47 
05 OM-SOC-SEC-NUMBER\ 
PIC X(9). 
48 
05 OM-NAME. 
\ 
49 
10 OM-LAST-NAME \ 
PIC X(15). 
50 
10 OM-INITIALS 
\ 
PIC XX. 
51 
05 OM-LOCATION-CODE 
\ 
PIC X(3). 
52 
05 OM-COMMISSION-RATE 
\ 
PIC 99. 
53 
05 OM-YEAR-TO-DATE-SALES 
\ PIC 9(8). 
54 
3 Record layout* are icieniica! 
55 
(01 WS-NEW-MAST-RECORDTI 
56 
(01 
05 NM-SOC-SEC-NUMBER 
PIC X(9). 
57 
05 NM-NAME. 
58 
10 NM-LAST-NAME 
PIC X(15). 
59 
10 NM-INITIALS 
PIC XX. 
60 
05 NM-LOCATION-CODE 
PIC X(3). 
61 
05 NM-COMMISSION-RATE 
PIC 99. 

Chapter 
17 
Sequential 
File 
Maintenance 
i g u r e 17.15 
(continued) 
62 
05 NM-YEAR-TO-DATE-SALES 
PIC 9(8). 
63 
64 
01 WS-BALANCE-LINE-SWITCHES. 
65 
05 WS-ACTIVE-KEY 
PIC X(9). 
66 
05 WS-RECORD-KEY-ALLOCATED-SWITCH 
PIC X(3). 
67 
68 
PROCEDURE DIVISION. 
69 
0010-UPDATE-MASTER-FILE. 
70 
OPEN INPUT TRANSACTION-FILE 
71 
OLD-MASTER-FILE 
72 
OUTPUT NEW-MASTER-FILE. 
73 
PERFORM 0020-READ-TRANSACTION-FILE. 
74 
PERFORM 0030-READ-OLD-MASTER-FILE. 
75 
PERFORM 0040-CH00SE-ACTIVE-KEY. 
76 
PERFORM 0050-PROCESS-ACTIVE-KEY 
" 
" 
77 
UNTIL WS-ACTIVE-KEY = HIGH-VALUES. 
78 
CLOSE TRANSACTION-FILE 
79 
OLD-MASTER-FILE 
80 
NEW-MASTER-FILE. 
81 
STOP RUN. 
82 
83 
0020-READ-TRANSACTION-FILE. 
84 
READ TRANSACTION-FILE INTO WS-TRANS-RECORD 
85 
AT END MOVE HIGH-VALUES TO TR-SOC-SEC-NUMBER 
86 
END-READ. 
87 
88 
0030-READ-OLD-MASTER-FILE. 
89 
READ OLD-MASTER-FILE INTO WS-OLD-MAST-RECORD 
90 
AT END MOVE HIGH-VALUE TO OM-SOC-SEC-NUMBER 
91 
END-READ. 
92 
93 
0040-CHOOSE-ACTIVE-KEY. 
94 
IF TR-SOC-SEC-NUMBER LESS THAN OM-SOC-SEC-NUMBER 
95 
MOVE TR-SOC-SEC-NUMBER TO WS-ACTIVE-KEY 
96 
ELSE 
97 
MOVE OM-SOC-SEC-NUMBER TO WS-ACTIVE-KEY 
98 
END-IF. 
99 
100 
0050-PROCESS-ACTIVE-KEY. 
101 
IF OM-SOC-SEC-NUMBER = WS-ACTIVE-KEY 
102 
MOVE 'YES' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
103 
PERFORM 0060-BUILD-NEW-MASTER 
104 
ELSE 
105 
MOVE 'NO' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
106 
END-IF. 
107 
108 
I PERFORM 0070^APPLY-TRANS-T0-MASTER 
109 
UNTIL WS-ACTIVE-KEY NOT EQUAL TR-SOC-SEC-NUMBER. 
110 
111 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
112 
PERFORM 0080-WRITE-NEW-MASTER 

Top-Down 
Testing 
(continued) 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
1.46 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
END-IF. 
PERFORM 0040-CH00SE-ACTIVE-KEY. 
0060-BUILD-NEW-MASTER. 
MOVE WS-OLD-MAST-RECORD TO WS-NEW-MAST-RECORD. 
PERFORM 0030-READ-OLD-MASTER-FILE. 
0070-APPLY-TRANS-TO-MASTER. 
EVALUATE TRUE 
WHEN ADDITION 
PERFORM 0090-ADD-NEW-RECORD 
WHEN CORRECTION 
PERFORM 0100-CORRECT-EXISTING-RECORD 
WHEN DELETION 
PERFORM 0110-DELETE-EXISTING-RECORD 
WHEN OTHER 
DISPLAY 'INVALID TRANSACTION CODE' 
END-EVALUATE. 
PERFORM 0020-READ-TRANSACTION-FILE. 
0080-WRITE-NEW-MASTER. 
WRITE NEW-MAST-RECORD FROM WS-NEW-MAST-RECORD. 
txpanaea trom program stuo 
0090-ADD-NEW-RECORD. 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
DISPLAY ' ERROR-DUPLICATE ADDITION: ' TR-SOC-SEC-NUMBER 
ELSE 
MOVE 'YES' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
MOVE SPACES TO WS-NEW-MAST-RECORD 
MOVE TR-SOC-SEC-NUMBER TO NM-SOC-SEC-NUMBER 
MOVE TR-NAME TO NM-NAME 
MOVE TR-LOCATION-CODE TO NM-LOCATION-CODE 
MOVE TR-COMMISSION-RATE TO NM-COMMISSION-RATE 
MOVE ZEROS TO NM-YEAR-TO-DATE-SALES 
END-IF. 
0100-CORRECT-EXISTING-RECORD. 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
ADD TR-SALES-AMOUNT TO NM-YEAR-TO-DATE-SALES 
ELSE 
DISPLAY ' ERROR-NO MATCHING RECORD: ' TR-SOC-SEC-NUMBER 
END-IF. 
0110-DELETE-EXISTING-RECORD. 
IF WS-RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
MOVE 'NO' TO WS-RECORD-KEY-ALLOCATED-SWITCH 
master record 
ELSE 
DISPLAY 
END-IF. 
ERROR-NO MATCHING RECORD: ' TR-SOC-SEC-NUMBER 

Chapter 
17 
Sequential 
File 
Maintenance 
Figure 17 
Output of the Sequential Update 
I 
I 
| 
100000000GRABER 
j 
200000000RUBIN 
I 
300000000ANDERSON 
j 
400000000MOLDOF 
j 
500000000GL.ASSMAN 
j 
600000000GRAUER 
700000000MILGR0M 
800000000VAZQUEZ 
900000000CLARK 
0OO0000OOBOROW 
| 
O0O0OOOO0B0ROW 
j 
OOOOOOOOOBOROW 
j 
400000000MOLDOF 
| 
444444444RICHARDS 
j 
700000000MILGR0M 
1 
800000000VAZQUEZ 
j 
999999999GILLENS0N 
1 
1 
OOOOOOOOOBOROW 
! 
100000000GRABER 
200000000RUBIN 
300000000ANDERSON 
400000000MOLDOF 
500000000GLASSMAN 
600000000GRAUER 
800000000VAZQUEZ 
900000000CLARK 
999999999GILLENS0N 
P ATL1500000000 
MABOS0800020000 
IRBOS1000113000 
BLATL1500000000 
JSNYC1000045000 
RTNYC0800087500 
A SF 0900120000 
C ATL1200060000 
E NYC07000O250O 
(a) Old Master 
JSATL07 
A 
JS 
10000C 
JS 
20000C 
BLATL15 
A 
IM 
050O0C 
A 
D 
C 
55000C 
MANYC10 
A 
(b) Valid Transaction File 
JSATL0700030000 
P ATLI500000000 
MAB0S0800020000 
IRBOS1000113000 
BLATL1500000000 
JSNYC1000045000 
RTNYC0800087500 
C ATL1200115000 
E NYC0700002500 
MANYC1000000000 
(c) New Master File 
i 
ERROR-DUPLICATE ADDITION: 400000000 
ERROR-NO MATCHING RECORD: 444444444 
(d) Error Messages 

SUMMARY 
iPM/tis to 
Remember 
File maintenance is a necessity of every system and enables three types of 
transactions. New records may be added, while existing records may be 
changed or deleted. 
A sequential update copies every record from the old master file to the new 
master, regardless of whether it changes. By contrast, a nonsequential 
update uses a single file as both the old and new master. Sequential 
processing is best when the master file is active and has substantial 
activity; nonsequential processing is more efficient for inactive files with 
less activity. 
Data validation is an essential component of file maintenance. The 
transaction file is typically run through a stand-alone edit prior to the 
maintenance program to check for valid codes, complete records, and so 
on. The update program must still check for duplicate additions and/or no 
matches (that is, transactions entered as corrections or deletions for records 
that are not present in the master file). 
The balance iine algorithm is a general approach to sequential file 
maintenance. The algorithm allows multiple transactions from one or more 
transaction files, to reference a single master record. 
Top-down testing was demonstrated through use of a stub program. Early 
testing ensures that modules are performed in proper sequence and 
facilitates the correction of any errors detected. 
Key Words 
and 
Concepts 
Active key 
Addition 
Allocation status 
Backup 
Balance line algorithm 
Correction 
Data validation 
Defensive programming 
Deletion 
Duplicate addition 
End-of-file condition 
Error message table 
Grandfather-father-son 
Hierarchy chart 
New master file 
No match 
Nonsequential update 
Old master file 
Periodic file maintenance 
Program stub 
Record-key allocated switch 
Sequential update 
Stand-alone edit program 
Stub program 
Test data 
Top-down testing and implementation 
Transaction file 
COBOL 
Element 
HIGH-VALUES 

C
h
a
p
t
e
r 
1 7 — 
Sequential 
File 
Maintenance 
h I L L - I N 
In a sequential update, 
record in the old master (except those 
slated for deletion) is copied (rewritten) to the new master, regardless of whether it 
2. Incoming transactions to a sequential update have generally been validated in. a 
3. The balance line algorithm (does/does not) require every record in the old master 
file to have a unique key. 
4. The balance line algorithm (does/does not) require every record in the transaction 
file to have a unique key. 
5. In general, the three transaction types that are input to a sequential update are  
and 
. 
6. The RECORD-KEY-ALLOCATED-SWITCH is used in checking for two types of 
errors: 
additions, and/or 
. 
7. An incomplete addition (can/can not) be detected in a stand-alone edit program. 
8. An invalid transaction code (can/can not) be detected in a stand-alone edit program. 
9. An incorrectly entered social security number on an otherwise valid transaction 
(can/can not) be detected in a stand-alone edit program. 
10. Top-down testing requires that the 
levels in a hierarchy chart be 
tested 
and more often than the lower-level routines. 
11. In order to implement top-down testing, a 
program is developed, 
which contains several one-line paragraphs consisting of 
statements. 
12. The grandfather-father-son backup scheme implies that at least 
generations of files are kept. 
13. 
is a figurative literal used to force the end-of-
file condition. 
1. The balance line algorithm requires a unique key for every record in the old master 
file. 
2. Transactions to the balance line algorithm must be presented in the following order: 
additions, changes, deletions. 
3. The balance line algorithm permits multiple transactions for the same master 
record and can be generalized to any number of transaction files. 
4. A program must be completely coded before any testing can begin. 
5. The high-level modules in a hierarchy chart should be tested first. 
6. One can logically assume that input to a maintenance program will be valid. 
changes. 
program. 
TRUE/FALSE 

Problems 
7. One need not check for duplicate additions if the transaction file has been run 
through a stand-alone edit program. 
8. A module in a hierarchy chart can be performed from more than one place. 
9. Pseudocode and hierarchy charts depict the same thing. 
10. A program stub may consist of a one-line DISPLAY paragraph. 
11. Test data are best designed by the programmer writing the program. 
12. Top-down testing can begin before a program is completely finished. 
13. The balance line algorithm is restricted to a single transaction file. 
14. A hierarchy chart contains decision-making logic. 
P 
R 
O 
B 
L 
E M 
S 
1. The transaction file in Figure 17.9b has both name and initials entered on correction 
transactions In addition to the social security number, is this necessary according 
to the specifications and subsequent C O B O L implementation (Figure 17.15)? 
Describe both an advantage and a disadvantage of entering the name and initials. 
2. The specifications of the update program do not discuss how to change (i.e., 
correct) the social security number of an existing record. With respect to Figure 
17.9a, for example, how could the social security number of Sugrue, 'who already 
exists in the old master file, be changed to 100000001? Discuss two different 
approaches, with an advantage and a disadvantage for each. 
3. What problems, if any, do you see with each of the following? (Assume no data 
validation has been done.) 
a. IF SEX = 'M' 
ADD 1 TO NUMBER-OF-MEN 
ELSE 
ADD 1 TO NUMBER-OF-WOMEN 
END-IF. 
b. SEARCH LOCATION-TABLE 
WHEN INCOMING-LOCATION-CODE = LOCATION (LOC-INDEX) 
MOVE EXPANDED-LOCATION (LOC-INDEX) TO PRINT-LOCATION 
END-SEARCH. 


Overview 
S y s t e m C o n c e p t s 
C O B O L Implementation 
Creating a n I n d e x e d File 
Programming Specifications 
Pseudocode 
The Completed Program 
Additional C O B O L E l e m e n t s 
OPEN 
READ 
WRITE 
REWRITE 
DELETE 
Maintaining a n Indexed File 
Programming Specifications 
Hierarchy Chart 
Pseudocode 
The Completed Program 
Alternate R e c o r d K e y 
Programming Specifications 
C o n c a t e n a t e d K e y 
The START Statement 
Limitations of COBOL-74 
Summary 
Fill-in 
True/False 
Problems 

Chapter 
18 — 
Indexed 
Files 
After reading this chapter you will be able to: 
Describe how an index file enables both sequential and/or nonsequential 
retrieval of individual records. 
Define the specific terms associated with IBM's VSAM implementation of 
indexed files. 
Discuss the clauses in the SELECT statement for an indexed file; indicate 
which clauses are optional and which are required. 
Define file status bytes; state how they may be used to verify the success 
of an I/O operation. 
Differentiate between the READ statements for sequential and nonsequential 
access of an indexed file. 
Differentiate between the WRITE, REWRITE, and DELETE statements as 
they apply to file maintenance of an indexed file. 
Describe the syntax of the START statement and give a reason for its use. 
Distinguish between the primary and alternate keys of an indexed file, and 
the requirements for each. 
OVERVIEW 
This chapter covers all major aspects of indexed files, a type of file organization 
that permits both sequential and nonsequential access to individual records. It 
begins with a general discussion of how indexed files work, with particular 
reference to IBM's VSAM implementation. Different vendors use different 
terminology, but the underlying concepts are the same, namely, a series of 
indexes that access individual records on a sequential or random basis. More 
importantly, the COBOL syntax is identical for all vendors who adhere to the ANS 
85 standard. 
The chapter includes three programs that illustrate all of the COBOL 
elements associated with this type of file organization. The first shows how to 
create an indexed file, the second continues with the file maintenance example 
of the previous chapter, and the last illustrates how individual records may be 
accessed by multiple keys—for example, name and social security number. 
Although different vendors have different physical implementations of indexed 
files, and consequently different terminology, the principles are the same; namely, 
a series of indexes that allow individual records to be accessed either sequentially or 
IVES 

System 
Concepts 
nonsequentially. This section provides an intuitive discussion of h o w an indexed 
file actually works. 
In reality, the physical implementation of an indexed file is of little or no 
concern to the programmer. The operating system establishes a n d maintains the 
indexes, a n d the programmer is concerned primarily with accessing the file through 
the appropriate C O B O L elements. Nevertheless, a conceptual understanding is of 
benefit in developing a m o r e competent and better-rounded individual. Accordingly, 
w e consider IBM's V S A M implementation. 
A V S A M file or data set is divided into control areas and control intervals. A 
control interval is a continuous area of auxiliary storage. A control area contains 
one or m o r e control intervals. A control interval is independent of the physical 
device o n which it resides; that is, a control interval that takes exactly one track of a 
given direct access device might require m o r e or less than one track if the file were 
m o v e d to another type of device). 
A V S A M file is defined with an index so that individual records m a y be located 
o n a r a n d o m basis, with entries in the index k n o w n as index records. The lowest-
level index is called the sequence set. Records in all higher levels are collectively 
called the index set. 
An entry in a sequence set contains the highest key in a control interval and a 
vertical pointer to that interval. An entry in an index set contains the highest key in 
the index record at the next lower level and a vertical pointer to the sequence set. 
These concepts are m a d e clearer by examination of Figure 18.1. 
Figure 18.1 shows 28 records hypothetically distributed in a V S A M data set. 
The entire file consists of three control areas; each area in turn contains three 
control intervals. The shaded areas s h o w n at the end of each control interval contain 
information required by V S A M . The index set has only one level of indexing. There 
are three entries in the index set, one for each control area. Each entry in the index 
Initial VSAM Data Set 
Index set 
377 
Vert, 
Pntr. 
619 
Vert. 
Pntr. 
800 
Vert, 
Pntr, 
Sequence Set 
Horiz. 
Pntr. 
Sequence Set 
Horiz, 
Pntr. 
• Vertical Pointer 
Sequence Set 
280 
Vert. 327 
Vert. 377 
Vert. t 
469 
Vert, 619 
Vert, 
t > 
700 
Vert. 800 
Vert. 
280 
Pntr, 
327 
Pntr. 
377 
Pntr, 
469 
Pntr, 
619 
Pntr, 
700 
Pntr, 
800 
Pntr. 
7
7
7 
251 
312 
345 
269 
318 
346 
280 
327 
377 
FREE 
FREE 
FREE 
Control 
Interval 
Control 
Interval 
Control 
Interval 
7
7 
394 
500 
400 
502 
449 
598 
469 
617 
FREE 
619 
FREE 
Z 7 
627 
642 
658 
675 
700 
717 
722 
746 
748 
800 
FREE 
Control Area 
Control Area 
Control Area 

C
h
a
p
t
e
r 
1 8 
-
Indexed 
Files 
set contains the highest key in the corresponding control area; thus 377, 619, a n d 
800 are the highest keys in the first, second, a n d third control areas, respectively. 
Each control area has its o w n sequence set. The entries in the first sequence set 
s h o w the highest keys of the control intervals in the first control area to be 280, 327, 
a n d 377, respectively. Note that the highest entry in the third control interval, 377, 
corresponds to the highest entry in the first control area of the index set. 
Figure 18.1 illustrates two kinds of pointers, vertical a n d horizontal. Vertical 
pointers are used for direct access to an individual record. For example, assume 
that the record with a key of 449 is to be retrieved. V S A M begins at the highest level 
of index (that is, at the index set). It concludes that record key 449, if it is present, is 
in the second control area (377 is the highest key in the first area, whereas 619 is the 
highest key in the second control area). V S A M follows the vertical pointer to the 
sequence set for the second control area a n d draws its final conclusion: record key 
449, if it exists, will be in the first control interval of the second control area. 
Horizontal pointers are used for sequential access only. In this instance, V S A M 
begins at the first sequence set and uses the horizontal pointer to get from that 
sequence set record to the one containing the next highest key. Put another way, the 
vertical pointer in a sequence set points to data; the horizontal pointer indicates the 
sequence set containing the next highest record. 
Figure 18.1 contains several allocations of free space, which are distributed in 
one of two ways: as free space within a control interval or as a free control interval 
within a control area. In other words, as V S A M loads a file, empty space is deliberately 
left throughout the file. This is done to facilitate subsequent insertion of n e w records. 
Figure 18.2 shows the changes brought about by the addition of two n e w 
records, with keys of 410 a n d 730, to the file of Figure 18.1. Addition of the first 
record, key 410, poses no problem, as free space is available in the control interval 
Control Interval Split 
Index set 
377 Vert. 
Pntr. 619 
Vert. 
Pntr. 800 
Vert. 
Pntr. 
Sequence Set 
Horiz. 
Pntr. 
W 
Sequence Set 
Horiz. 
Pntr. 
Sequence Set 
280 
Vert. 327 
Vert. 377 
Vert. 
469 
Vert. 619 
Vert. 
700 
Vert. 
Vert. 
800 Vert. 
280 
Pntr. 327 
Pntr. 377 
Pntr. 
469 
Pntr. 619 
Pntr. 
700 
Pntr. 
Pntr. 
800 
Pntr. 
7 7 7 
7 7 
7 7 7 
251 
312 
345 
394 
500 
627 
717 
746 
269 
318 
346 
400 
502 
642 
722 
748 
280 
327 
377 
410 
598 
FREE 
658 
730 
800 
FREE 
FREE 
FREE 
449 
617 
FREE 
675 
FREE 
FREE 
FREE 
FREE 
FREE 
469 
619 
700 
FREE 
FREE 
Control Interval 
Split 
Control Area 
Control Area 
Control Area 

System 
Concepts 
where the record belongs. Record 410 is inserted into its proper place a n d the other 
records in that control interval are m o v e d d o w n . 
The addition of record key 730 requires different action. The control interval 
that should contain this record is full in Figure 18.1. Consequently V S A M causes a 
control interval split, in which s o m e of the records in the previously filled control 
interval are m o v e d to an empty control interval in the s a m e control area. Entries in 
the sequence set for the third control area will change, as s h o w n in Figure 18.2. This 
makes considerable sense w h e n w e realize that each record in a sequence set 
contains the key of the highest record in the corresponding control interval. Thus 
the records in the sequence set must reflect the control interval split. Note that after 
a control interval split, subsequent additions are facilitated, as free space is again 
readily available. 
Figure 18.3 shows the results of including three additional records, with keys 
of 316, 618, and 680. Record 316 is inserted into free space in the second control 
interval of the first control area, with the other records initially in this interval 
shifted d o w n . Record 618 causes a control interval split in the second control area. 
Record 680 also requires a control interval split except that there are no longer 
any free control intervals in the third control area. Accordingly, a control area split 
is initiated, in which s o m e of the records in the old control area are m o v e d into a 
n e w control area at the end of the data set. Both the old and the n e w control areas 
will have free control intervals as a result of the split. In addition, the index set has a 
fourth entry, indicating the presence of a n e w control area. The sequence set is also 
expanded to accommodate the fourth control area. 
Control Area Split 
Index set 
377 
Vert. 
Pntr, 619 
Vert, 
Pntr. 700 Vert. 
Pntr, 800 
Vert. 
Pntr, 
Sequence Set 
Horiz 
Pntr. 
• 
Sequence Set 
Horiz. 
Pntr. f 
Sequence Set 
Horiz 
Pntr. 
t 
Sequence Set 
280 
Vert. 
Pntr. 327 
Vert. 
Pntr. 377 
Vert. 
Pntr. 
469 
Vert. 
Pntr. 593 Vert. 
Pntr. 619 
Vert, 
Pntr. 
/ 
/ 
/ 
/ 
/ 
/ 
251 
312 
345 
394 
500 
617 
269 
346 
400 
502 
3:3 
280 
318 
377 
410 
598 
619 
FREE 
327 
FREE 
449 
FREE 
FREE 
FREE 
FREE 
FREE 
469 
FREE 
FREE 
Vert. 700 Vert. Vert. 
Pntr, 700 
Pntr, Pntr, 
627 
642 
658 
FREE 
675 
700 
FREE 
FREE 
730 Vert. 
Pntr, 800 Vert. 
Pntr. 
Vert. 
Pntr. 
717 
722 
730 
FREE 
746 
748 
800 
FREE 
FREE 
Control Interval 
Split 
Control Interval 
Split 
Control Area 
Control Area 
Control Area 
Control Area 
Control Area Split 

Chapter 
IS 
Indexed 
Files 
i r n p i e m e n t a t t o i 
The C O B O L implementation of an indexed file centers o n the S E L E C T statement in 
the Environment Division. Consider: 
SELECT file-name 
ACCTPM 
T A jimplementor-name- l| 
{literal-1 
RESERVE integer-1 
AREA 
AREAS 
ORGANIZATION IS INDEXED 
ACCESS MODE IS 
SEQUENTIAL 
RANDOM 
DYNAMIC 
RECORD KEY IS data-name-i 
ALTERNATE RECORD KEY IS data-name-2 WITH DUPLICATES 
[FILE STATUS IS data-name-3] 
Three clauses are required: ASSIGN, O R G A N I Z A T I O N IS I N D E X E D , a n d 
R E C O R D KEY. T h e function of the ASSIGN clause is the s a m e as with a sequential 
file—to tie a programmer-chosen file n a m e to a system n a m e . T h e O R G A N I Z A T I O N 
IS INDEXED clause indicates an indexed file and needs no further explanation. 
The RECORD KEY clause references a field defined in the F D for the indexed 
record whose value must be unique for each record in the file. The value of the 
record key is used by the operating system to establish the necessary indexes for the 
file, which in turn enables the r a n d o m retrieval of individual records. 
T h e remaining entries—RESERVE integer A R E A S , A C C E S S 
M O D E , 
A L T E R N A T E R E C O R D KEY, and FILE S T A T U S — a r e optional. T h e RESERVE integer 
AREAS clause functions identically as with a sequential file, to increase processing 
efficiency by allocating alternate I/O areas (or buffers) for the file. If the clause is 
omitted, the n u m b e r of alternate areas defaults to the vendor's implementation, 
which is adequate in most instances. Specification of R E S E R V E Z E R O A R E A S 
will slow processing but will save a n a m o u n t of storage equal to the buffer size. 
This is generally done only o n smaller systems w h e n the a m o u n t of m a i n m e m o r y 
is limited. 
The meaning of ACCESS MODE is apparent w h e n either sequential or r a n d o m 
(nonsequential) access is specified. A C C E S S IS D Y N A M I C allows a file to be read 
both sequentially a n d nonsequentially in the same program a n d is illustrated in 
Figure 18.12 later in the chapter. 
ALTERNATE RECORD KEY provides a second path for r a n d o m access. Unlike 
the record key, which must be unique for every record, the alternate key m a y 
contain duplicate values. This capability is extremely powerful and gives C O B O L 
s o m e limited facility for data base m a n a g e m e n t . Y o u could, for example, specify a n 
account n u m b e r as the record key a n d a person's n a m e as the alternate key. Realize, 
however, that while the alternate key is powerful, it is expensive in terms of overhead, 
in that a second set of indexes m u s t be maintained by the operating system and 
thus, the feature should not be used indiscriminately. T h e A L T E R N A T E R E C O R D 
K E Y clause is illustrated in Figure 18.12 at the e n d of the chapter. 

COBOL 
Implementation 
The FILE S T A T U S clause is available for any type of file organization a n d 
allows the programmer to distinguish between the m a n y different types of I/O 
error conditions. The concept was first introduced in Chapter 6 in connection 
with debugging (see page 158). The operating system automatically returns a two-
position field k n o w n as the I/O status (or file status bytes) to the data n a m e 
designated in the FILE S T A T U S clause. The value of the file status bytes m a y be 
interrogated by the programmer, w h o is thus able to more closely monitor the 
results of any I/O operation. 
Table 18.1 lists the various file status codes and their meaning. T h e use of file 
status codes is illustrated in the ensuing program to create an indexed file. 
M e 18.1 
File Status Codes 
0 0 
A successful input/output operation is performed with no further information available. 
0 2 
A successful creation of a record with duplicate alternate key value 
0 4 
A READ is successful, but the length of the record being processed does not conform to the fixed file attributes for that file. 
0 5 
An OPEN is successful, but the referenced optional file is not present at open time. 
0 7 
An input/output statement is successful; however, for a CLOSE with NO REWIND, REEL/UNIT, or FOR REMOVAL or for an 
OPEN with NO REWIND the referenced file is on a nonreel/unit medium 
10 
A sequential READ is attempted and no next logical record exists because (1) the end of file has boon reached; or (2) an 
optional input file is not present. 
14 
A sequential READ is attempted and the number of significant digits in the record number is larger than the size of the key 
data item described for the file. 
15 
A sequential READ statement is attempted for the first time on an optional file that is not present 
21 
A sequence error exists for a sequentially accessed indexed file. 
2 2 
An attempt is made to write or rewrite a record that would create a duplicate prime record key or duplicate alternate record 
key without the DUPLICATES phrase. 
23 
An attempt is made to randomly access a record that does not exist in the file, or a START or random READ is attempted on 
an optional input file that is not present. 
24 
An attempt is made to write beyond the externally defined boundaries. 
25 
A START statement or a random READ statement has been attempted on an optional file that is not present. 
3 0 
A permanent error exists and no further information is available concerning the input/output operation. 
34 
A permanent error exists because of a boundary violation; an attempt is made to write beyond the externally defined 
boundaries, 
3 5 
A permanent error exists because an OPEN with the INPUT, I/O, or EXTEND phrase is attempted on a nonoptional file that is 
not present. 
3 7 
A permanent error exists because an OPEN is attempted on a file and that file will not support the open mode specified: (1) 
EXTEND or OUTPUT phrase specified but not supported by the file; (2) I/O phrase is specified, but input and output 
operations are not supported by the file; or (3) INPUT phrase is specified, but the file will not support READ operations, 
3 8 
A permanent error exists because an OPEN is attempted on a file previously closed with a lock, 
3 9 
The OPEN is unsuccessful because a conflict has been detected between the fixed file attributes and the ones specified for 
that file in the program. 
41 
An OPEN statement is attempted for a file in the open mode. 
4 2 
A CLOSE statement is attempted for a file not in the open mode. 
4 3 
In the sequential access mode, the last input/output statement executed for the file prior to the execution of a DELETE or 
REWRITE statement was not a successfully executed READ statement, 
4 4 
A boundary violation exists because of an attempt to: (1) write or rewrite a record that is larger than the largest or smaller 
than the smallest record allowed by the RECORD IS VARYING clause of the associated file-name, or (2) rewrite a record 
and the record is not the same size as the record being replaced. 
4 6 
A sequential READ is attempted on a file open in the input or I/O mode and no valid next record has been established 
because the preceding: (1) START was unsuccessful, (2) READ was unsuccessful but did not cause an at-end condition, or 
(3) READ caused an at-end condition. 
4 7 
The execution of a READ or START is attempted on a file not open in the input or I/O mode. 
4 8 
The execution of a WRITE is attempted on a file not open in the I/O, output, or extend mode. 
4 9 
The execution of a DELETE or REWRITE statement is attempted on a file not open in the I/O mode. 

C
h
a
p
t
e
r 
18 ~~ 
Indexed 
Files 
<&• \~ ..<: ~ . x f g 
Our first program creates an indexed file from sequential data, and in so doing, 
IF C v-i<_ h'*, e-ll© 
illustrates both the S E L E C T statement in the Environment Division and the use of 
the FILE S T A T U S bytes in the Procedure Division. It is important to realize that 
unlike sequential files, which can be created (or displayed) with an ordinary text 
editor or w o r d processor, indexed files require a special procedure to create the 
associated indexes, and hence the need for this program. T h e C O B O L program is 
not difficult a n d serves as a good introduction to indexed files. Specifications follow 
in the usual format. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Narrative: 
Input Fiie(s): 
Input Record Layout: 
Creating an Indexed File 
This program copies the data from an incoming sequential file to an output indexed file. 
The logic is trivial in nature as the program is intended primarily to illustrate the SELECT 
statement for indexed files and the use of FILE STATUS bytes. 
SEQUENTIAL-FILE 
01 SEQUENTIAL-RECORD. 
05 SEQ-SOC-SEC-NUMBER 
05 SEQ-REST-OF-RECORD 
PIC X(9). 
PIC X(30). 
Output File: 
Output Record Layout: 
INDEXED-FILE 
01 INDEXED-RECORD. 
05 IND-SOC-SEC-NUMBER 
05 IND-REST-0F-REC0RD 
PIC X(9). 
PIC X(30). 
100000000GRABER 
200000000RUBIN 
300000000ANDERSON 
222222222PANZER 
400000000MOLDOF 
500000000GLASSMAN 
600000000GRAUER 
700000000MILGROM 
800000000VAZQUEZ 
900000000CLARK 
P ATL1500000000 
MABOS0800020000 
IRB0S1000113000 
S NYC0600000000 
BLATL1500000000 
JSNYC1000045000 
RTNYC0800087500 
A SF 0900120000 
C ATL1200060000 
E NYC0700002500 
Processing Requirements: 
1. Copy the records in an incoming sequential file to an equivalent indexed file. The 
record layouts in both files are the same, with the first nine positions serving as the 
record key. 
2. Display the FILE STATUS bytes after every I/O operation associated with the indexed 
file (OPEN, CLOSE, and WRITE). 
3. Verify that the newly created indexed file has its records in sequence, and further, that 
every record contains a unique value for the record key. Note, for example, that the 
record for Panzer in the test data is out of sequence and should be flagged accordingly. 

Creating 
an 
Indexed 
File 
The logic for this program is simple indeed as indicated in the programming 
specifications. In essence all w e do is read a record from the sequential file, write it 
to the indexed file, and repeat the loop until the sequential file is out of data. W e do 
not have to concern ourselves with building the indexes per se, as this is done 
automatically through the appropriate C O B O L statements. The logic for the program 
is depicted in the pseudocode of Figure 18.4. 
i 
4 
Pseudocode for Creating Indexed File 
,— 
Open files 
! 
DO WHILE data remains 
I 
i 
READ record from sequential file 
| 
AT END 
| 
Indicate no more data 
j 
NOT AT END 
Move sequential record to indexed record 
I 
Write indexed record 
i 
} 
r- IF sequence error 
Display error - records out of sequence 
\
 
L—- ENDIF 
j 
; 
IF duplicate record 
! 
i 
Display error - record already exists 
L - ENDIF 
ENDREAD 
L 
ENDDO 
Close files 
Stop run 
Figure 18.5 displays the completed program and contains little that is n e w in the 
w a y of C O B O L other than the S E L E C T statement of lines 10 through 15. As indicated 
in the previous discussion, the ASSIGN, O R G A N I Z A T I O N IS I N D E X E D , and R E C O R D 
K E Y clauses are required, while the A C C E S S IS S E Q U E N T I A L a n d FILE S T A T U S 
clauses are optional (and included here for purposes of illustration). 
The R E C O R D K E Y clause designates a field within the indexed record (IND-
S O C - S E C - N U M ) that will be used by the operating system to build the necessary 
indexes. Observe, therefore, that I N D - S O C - S E C - N U M is referenced in two places, 
in the R E C O R D K E Y clause of line 14 and in the F D for the indexed file in line 30. 
The optional FILE S T A T U S clause of line 15 designates a two-position data 
n a m e , INDEXED-STATUS-BYTES, which in turn is defined in Working-Storage (line 
35). The operating system automatically updates the file status bytes after every I/O 
operation, making the result available to the program via the data n a m e I N D E X E D -
STATUS-BYTES. This, in turn, makes it possible to closely monitor the success (or 
failure) of various statements within the program. 
To illustrate the utility of the file status bytes, return to the test data in the 
programming specifications, noting 
that 
the record for Panzer 
is out of 
sequence. 
The logic in the Procedure Division reads a record from the sequential file a n d 

Chapter 
18 — 
Indexed 
Files 
Figure 18.5 
Program to Create an Indexed File 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
CREATE. 
AUTHOR. 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT SEQUENTIAL-FILE 
ASSIGN TO 'A:\CHAPTR18\SEQUENCE.DAT' 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT INDEXED-FILE 
ASSIGN TO 'A:\CHAPTR18\INDMAST.DAT' 
ORGANIZATION IS INDEXED 
ACCESS IS SEQUENTIAL 
RECORD KEY IS IND-SOC-SEC-NUM 
FILE STATUS IS INDEXED-STATUS-BYTES. 
DATA DIVISION. 
FILE SECTION. 
FD SEQUENTIAL-FILE 
RECORD CONTAINS 39 CHARACTERS 
DATA RECORD IS SEQUENTIAL-RECORD. 
SEQUENTIAL-RECORD. 
05 SEQ-SOC-SEC-NUM 
PIC X(9). 
05 SEQ-REST-OF-RECORD 
PIC X(30). 
01 
FD 
01 
INDEXED-FILE 
RECORD CONTAINS 39 CHARACTERS 
DATA RECORD IS INDEXED-RECORD. 
INDEXED-RECORD. 
05 IND-SOC-SEC-NUM  
"05"
_IND-REST-OF-RECORD 
WORKING-STORAGE SECTION. 
01 END-OF-FILE-SWITCH 
PIC X(9)_. 
PIC X(30). 
PIC X(3) 
VALUE 'NO'. 
01 
INDEXED-STATUS-BYTES 
PIC XX. 
PROCEDURE DIVISION. 
0010-UPDATE-MASTER-FILE. 
OPEN INPUT SEQUENTIAL-FILE 
OUTPUT INDEXED-FILE. 
DISPLAY 'OPEN STATEMENT EXECUTED'. 
DISPLAY ' 
FILE STATUS BYTES = ', 
DISPLAY ' '. 
INDEXED-STATUS-BYTES. 
PERFORM UNTIL END-OF-FILE-SWITCH = 'YES' 
READ SEQUENTIAL-FILE 
AT END 
MOVE 'YES' TO END-OF-FILE-SWITCH 
NOT AT END 
MOVE SEQ-SOC-SEC-NUM TO IND-SOC-SEC-NUM 
MOVE SEQ-REST-OF-RECORD TO IND-REST-OF-RECORD 
WRITE INDEXED-RECORD 
INVALID KEY PERFORM 0020-EXPLAIN-WRITE-ERROR 
END-WRITE 
DISPLAY 'WRITE STATEMENT EXECUTED FOR ' 
SEQUENTIAL-RECORD 

Additional 
COBOL 
Elements 
iCtlf 
Program to Create an Indexed File 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
DISPLAY ' 
FILE STATUS BYTES =
 1 
INDEXED-STATUS-BYTES 
DISPLAY ' ' 
END-READ 
END-PERFORM. 
CLOSE SEQUENTIAL-FILE 
INDEXED-FILE. 
DISPLAY 'CLOSE STATEMENT EXECUTED'. 
DISPLAY ' 
FILE STATUS BYTES = ', INDEXED-STATUS-BYTES. 
DISPLAY ' '. 
STOP RUN. 
' SEQUENTIAL-RECORD 
0020-EXPLAIN-WRITE-ERROR. 
IF INDEXED-STATUS-BYTES = '21' 
DISPLAY 'ERROR (SEQUENCE) FOR 
END-IF. 
IF INDEXED-STATUS-BYTES = '22' 
DISPLAY 'ERROR (DUPLICATE KEY) FOR ' SEQUENTIAL-RECORD 
END-IF. 
copies it to the indexed file, repeating the loop until the sequential file is e m
n t
v . A 
problem will result, however, because the indexed file requires its records to be in 
sequence, which is not true in this example. Accordingly it is good technique to 
include an INVALID KEY clause in the W R I T E statement of lines 51 through 53, 
which is executed if, a n d only if, an error is detected. The paragraph performed as a 
consequence of the error, 0020-EXPLAIN-WRITE-ERROR (lines 68-74), interrogates 
the file status bytes to reveal the exact cause of the problem. 
Output of the program is s h o w n in Figure 18.6 and consists entirely of display 
output produced at various points in the program. The first and last lines show the 
results of the O P E N and C L O S E statements, respectively; both operations executed 
successfully as evidenced by file status bytes of 00. Note, too, h o w file status bytes 
of 00 are displayed for every successful write operation, but that a value of 21, 
corresponding to an out-of-sequence record, is displayed for Panzer. 
_a 
t L H - „ s i i 
Several statements in the Procedure Division are uniquely associated with indexed 
w ~ V 
files or have extended formats for indexed files. These include O P E N , R E A D , W R I T E , 
- 
7 r . 
, 
R E W R I T E , a n d D E L E T E . W e will discuss each of these statements in isolation, then 
~~
 
y" 
" 
include them in the illustrative programs that follow. 
The 1-0 clause of the O P E N statement, O P E N I-O, is required w h e n updating indexed 
files. Consider: 
OPEN 
INPUT 
OUPUT 
1-0 
f i l e - n a m e 

Chapter 
18 — 
Indexed 
Files 
Display Output of Create Program 
OPEN STATEMENT EXECUTED 
FILE STATUS BYTES = 00 
WRITE STATEMENT EXECUTED FOR 100000000GRABER 
FILE STATUS BYTES = 00 
P ATL1500000000 
WRITE STATEMENT EXECUTED FOR 200000000RUBIN 
FILE STATUS BYTES = 00 
MABOS0800020000 
WRITE STATEMENT EXECUTED FOR 300000000ANDERS0N 
FILE STATUS BYTES = 00 
IRBOS1000113000 
ERROR (SEQUENCE) FOR 
222222222PANZER 
WRITE STATEMENT EXECUTED FOR 222222222PANZER 
FILE STATUS BYTES = 21 
S NYC0600000000 
S NYC0600000000 
WRITE STATEMENT EXECUTED FOR 400000000MOLDOF 
FILE STATUS BYTES = 00 
BLATL1500000000 
WRITE STATEMENT EXECUTED FOR 500000000GLASSMAN 
FILE STATUS BYTES = 00 
JSNYC1000045000 
WRITE STATEMENT EXECUTED FOR 600000000GRAUER 
FILE STATUS BYTES = 00 
RTNYC0800087500 
WRITE STATEMENT EXECUTED FOR 700000000MILGR0M 
FILE STATUS BYTES = 00 
A SF 0900120000 
WRITE STATEMENT EXECUTED FOR 800000000VAZQUEZ 
FILE STATUS BYTES = 00 
C ATL1200060000 
WRITE STATEMENT EXECUTED FOR 900000000CLARK 
FILE STATUS BYTES = 00 
E NYC0700002500 
CLOSE STATEMENT EXECUTED 
FILE STATUS BYTES = 00 
I N P U T a n d O U T P U T are used w h e n an indexed file is accessed or created. In 
nonsequential maintenance, however, the same indexed file functions as both the 
old and n e w master files, a n d hence is both an input and an output file. T h e file is 
opened as an l-O file—for example, O P E N l-O I N D E X E D - F I L E — t o enable it to 
serve both functions in the s a m e program; that is, you m a y read records from the 
file (input), as well as write records to the file (output). 
The R E A D statement has two distinct formats, for sequential and nonsequential 
access, respectively. These are: 

Additional 
COBOL 
Elements 
Format 1 (Sequential Access) 
READ file-name [NEXJj RECORD fINTO identifier-1] 
[AT EJD imperati ve-statement-1] 
[NOT AT END imperative-statement-2] 
[END-READ! 
Format 2 (Nonsequential Access) 
READ file-name RECORD [INTO identifier-1] 
[KEY IS data-name-1] 
[INVALID KEY imperative-statement-1] 
[NOT INVALID KEY imperative-statement-2] 
[jEND-READ] 
The first format, for sequential access, has been used throughout the text and 
should present no difficulty. (The N E X T phrase is discussed in conjunction with the 
A C C E S S IS D Y N A M I C clause of the S E L E C T statement, and is illustrated in Figure 
18.12 toward the end of the chapter.) 
The second format, for nonsequential access, must be preceded by a MOVE 
statement, in which the key of the desired record is moved to the data name designated 
as the RECORD KEY in the SELECT statement. Consider: 
SELECT INDEXED-FILE 
ASSIGN TO 'A:\CHAPTR18\INDMAST.DAT'  
ORGANIZATION IS INDEXED 
ACCESS IS RANDOM 
; RECORD KEY'IS I J ^ O C ^ S E C - N U M . k 
MOVE 888888888 TO IM^S0C-SEC-NUM71 
READ INDEXED-FILE INTO WS-INPUT-AREA 
INVALID KEY 
DISPLAY 'Record 888888888 is not in the indexed file' 
NOT INVALID KEY 
END-READ. 
The R E A D statement accesses the indexed file nonsequentially in a n attempt to 
retrieve the record whose key is 888888888. If the record is in the file, it will be read 
and m a d e available in W S - I N P U T - A R E A (as well as in the record area within the F D 
for INDEXED-FILE). If, however, the record does not exist, the INVALID K E Y 
condition is raised and the indicated error message is displayed. 
The KEY I S clause is necessary if multiple keys are specified in the S E L E C T 
statement (that is, if A L T E R N A T E R E C O R D K E Y is included). Consider: 
SELECT INDEXED-FILE 
ASSIGN TO 'A:\CHAPTR18\INDMAST.DAT'  
ORGANIZATION IS INDEXED 
RECORD KEY IS IND-SOC-SEC-NUM 
ACCESS IS RANDOM 
ALTERNATE RECORD KEY IS IND-NAME WITH DUPLICATES. 
[MOVE ^ i B
r T 0 T i ^ A M i : > 
"READ INDEXED-FILE INT0~ WS-WORK-AREA 
KEY IS IND-NAME 

C
h
a
p
t
e
r 
1 8 — 
Indexed 
Files 
INVALID KEY 
m e m 
A V 
ui jr i_rv i 
NOT INVALID KEY 
END-READ. 
As in the case of a single key, the READ statement is preceded b y a MOVE statement 
in w h i c h the desired value is m o v e d to the appropriate key field. The file is then 
searched nonsequentially for the value specified (Smith in the example). The 
INVALID KEY condition is activated if the record cannot b e found. 
W R I T E 
. 
„ 
_ 
The WRITE statement also has an optional INVALID KEY clause, as y o u already 
k n o w from the COBOL program to create an indexed file (Figure 18.5). Consider: 
WRITE record-name [FROM identifier-1] 
[INVALID KEY imperative statement-1] 
(NOT INVALID KEY imperative-statement-2] 
TEND-WRITEl 
Specification of ACCESS IS SEQUENTIAL (in the SELECT statement) to create the 
indexed file requires that incoming records be in sequential order, and further, each 
record is required to have a unique key. The INVALID KEY condition is raised if 
either of these requirements is violated. 
R E W R I T E 
^
^
^
^
^
^
^
.
^ 
___________________ 
The REWRITE statement replaces existing records w h e n a file has been o p e n e d as 
an I/O file, as in the case of nonsequential maintenance. Its syntax is similar to that 
of the WRITE statement: 
REWRITE record-name fFROM identifier-1] 
[INVALID KEY imperative statement-1] 
fNOT INVALID KEY imperative-statement-2] 
fEND-REWRITEl 
The INVALID KEY condition is raised if the record key of the last record read does 
not match the key of the record to b e replaced. 
D E L E T E 
_ _ _ _ _ _ _ 
^
—
^
^
^
^
^
^
-
-
^ 
The DELETE statement removes a record from an indexed file. Consider: 
DELETE file-name RECORD 
riNVALID KEY imperative statement-1] 
[NOT INVALID KEY imperative-statement-2] 
fENO-DE LETE1 
The DELETE statement is appropriate only for files o p e n e d in t h e I/O m o d e . 

Maintaining 
an 
indexed 
File 
u " "*"v'x"'f"f*"€j all 
T h e distinction between sequential a n d nonsequential 
file maintenance w a s 
— 
*i
 
1 © 
presented in the previous chapter, but is repeated here for emphasis. A sequential 
update uses two distinct master files, an old and a n e w master, with every record in 
the old master rewritten to the n e w master regardless of whether it changes. A 
nonsequential update uses a single master file that functions as both the old a n d 
n e w master, a n d only the records that change are rewritten. A sequential update is 
driven by the relationship between the old master a n d transaction files, whereas a 
nonsequential update is driven solely by the transaction file; that is, transactions 
are processed until the transaction file is empty. Finally, a sequential update requires 
the transaction file to be in sequence, whereas the transactions for a nonsequential 
update can be in any order. 
The sequential update was developed in Chapter 17 through implementation 
of the balance line algorithm. W e continue n o w with a parallel problem for 
nonsequential processing. 
P R O 
Program Name: 
Narrative: 
i n p u t File: 
Input R e c o r d L a y o u t : 
G R A M M ! N G 
Nonsequential Update 
S 
B 
B * » I F ! C A T I O N S 
This program parallels the update program of Chapter 17 except that the master file is 
accessed nonsequentially, and thus the transaction file need not be in sequence. In 
addition, the balance line algorithm does not apply. 
TRANSACTION-FILE 
01 TRANSACTION-RECORD. 
05 TR-SOC-SEC-NUMBER 
TR-NAME. 
10 TR-LAST-NAME 
10 TR-INITIALS 
TR-LOCATI0N-CODE 
TR-COMMISSION-RATE 
TR-SALES-AMOUNT 
TR-TRANSACTION-CODE 
88 ADDITION 
VALUE 
88 CORRECTION 
VALUE 
88 DELETION 
VALUE 
05 
05 
05 
05 
05 
'A', 
'C , 
! D \ 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(5). 
PIC X. 
I n p u t / O u t p u t File: 
Input R e c o r d L a y o u t : 
INDEXED-FILE 
01 IND-MASTER-RECORD. 
05 IND-SOC-SEC-NUMBER 
IND-NAME. 
10 IND-LAST-NAME 
10 IND-INITIALS 
IND-L0CATI0N-C0DE 
IND-C0MMISSI0N-RATE 
IND-YEAR-TO-DATE-SALES 
05 
05 
05 
05 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(8). 
Test Data: 
See Figure 18.7a and 18.7b. 

C
h
a
p
t
e
r 
1 8 
— 
Indexed 
Files 
Figure 18.7 
Test Data for Nonsequential Update 
100000000GRABER 
200000000RUBIN 
300000000ANDERS0N 
400000000MOLDOF 
500000000GLASSMAN 
600000000GRAUER 
700000000MILGROM 
800000000VAZQUEZ 
900000000CLARK 
P ATL1500000000 
MABOS0800020000 
IRBOS1000113000 
BLATL1500000000 
JSNYC1000045000 
RTNYC0800087500 
A SF 0900120000 
C ATL1200060000 
E NYC0700002500 
(a) Indexed File (before Update) 
444444444RICHARDS 
IM 
05000C 
700000000MILGROM 
A 
D 
000O0000OBOROW 
JSATL07 
A 
OO00OO0OOBOROW 
JS 
10000C 
00000OOO0BOROW 
JS 
20000C 
400000000MOLDOF 
BLATL15 
A 
800000000VAZQUEZ 
C 
55000C 
999999999GILLENS0N 
MANYC10 
A 
* Transactions are not in sequential order 
(b) Transaction File 
OOOOOOOOOBOROW 
100000000GRABER 
200000000RUBIN 
300000000ANDERSON 
400000000MOLDOF 
500000000GLASSMAN 
600000000GRAUER 
800000000VAZQUEZ 
900000000CLARK 
999999999GILLENS0N 
JSATL0700030000 
P ATL1500000000 
MABOS0800020000 
IRB0S1000113000 
BLATL1500000000 
JSNYC1000045000 
RTNYC0800087500 
C ATL1200115000 
E NYC0700002500 
MANYC1000000000 
(c) Indexed File (after Update) 
ERROR-NO MATCHING RECORD: 444444444 
ERROR-DUPLICATE ADDITION: 400000000 
(d) Error Messages 

Maintaining 
an Indexed 
File 
Processing Requirements: 
1. Develop a nonsequential update program to process an incoming transaction file and 
update the associated indexed fiie. The processing requirements paraiiei those of the 
sequential update program of Chapter 17 with the following changes: 
a. There is only a single master file (the indexed file), which functions as both the old 
and new master files. 
b. The transaction file need not be in sequential order. 
c. The balance line algorithm does not apply. 
2. The transaction file is assumed to be valid in and of itself by virtue of a stand-alone edit 
program. Hence, each transaction has a valid transaction code (A, C, or D), numeric 
fields are numeric, and so on. Nevertheless, the update program must check (and 
flag) two kinds of errors that could not be detected in the stand-alone edit, as they 
require interaction with the old master file. These are: 
a. Duplicate additions, in which the social security number of a transaction coded as 
an addition already exists in the old master, 
b. No matches, in which the social security number of a transaction coded as either a 
deletion or a correction does not exist in the old master. 
3. Transactions coded as additions are to be added to the new master file In their 
entirety, and will contain a value for every field in the transaction record (except for TR-
SALES-AMOUNT). The value of IND-YEAR-TO-DATE-SALES in the new master record 
is to be initialized to zero. 
4. Transactions coded as deletions are to be removed from the master file. These 
transactions contain only the social security number and transaction code. 
C 
Trnnri^tiAno 
O I - V W A H 
O C - r*/~\rrr\/^+\r\r\o 
/ ^ n n f o l n 
/ ~ i n l w fha or\/^iol O Q / ~ M iritx/ ni i m h o r n o m a a n H 
vJ. 
t i at iOCi-OliVJi t o o u u u u 
n o 
o u i i O U L I U I 
I O o v / r i tcj.it i w i n y 
u 
I V J o u v i u i 
o v v u i 
i L y 
i l u m u o i 
ji I U I I 
i i j , 
u i 
I M 
the transaction sales amount (TR-SALES-AMOUNT). The value of TR-SALES-AMOUNT 
on the incoming transaction is to be added to the value in the IND-YEAR-TO-DATE-
SALES field in the master record. 
Figure 18.7 contains the indexed and transaction files before the update, the indexed 
file after the update has been run, and the associated error messages (for duplicate 
additions a n d no matches). The data parallel the example in Chapter 17 except that 
the transaction file is no longer in sequence. Nevertheless, the updated indexed file 
is the s a m e in both examples; that is, B o r o w and Gillenson have been added, 
Milgrom has been deleted, a n d Vazquez has had her record changed. Note, however, 
that the error messages in Figure 18.7d are reversed (from those in Chapter 17) to 
match the order in which the transactions were processed. 
H i e r a r c h y C h a r t 
The hierarchy chart of Figure 18.8 is simpler than its counterpart for sequential 
processing; it also contains four modules that were present in the hierarchy chart 
of Chapter 17. In other words, regardless of whether the master file is accessed 
sequentially or nonsequentially, it is still necessary to apply transactions to the 
master file, to add records to the indexed file, and to correct and/or delete existing 
records. 
Conspicuous by its absence, however, is the module to C H O O S E - A C T I V E -
KEY, because the nonsequential update is driven entirely by the transaction file. 
The program processes the transaction file until there are n o m o r e transactions; 
that is, there is no need for a n active key to determine whether the record from the 
transaction file or the old master file will be admitted to the update process because 
the balance line algorithm does not apply. (See problem 7.) 

C
h
a
p
t
e
r 
1 8 — 
Indexed 
Files 
Figure 18.8 
Hierarchy Chart for Nonsequential Update Program 
PROCESS 
TRANSACTION 
FILE 
APPLY 
TRANS TO 
MASTER 
ADD NEW 
RECORD 
CORRECT 
EXISTING 
RECORD 
DELETE EXISTING 
RECORD 
READ 
INDEXED FILE 
Pseudocode 
The pseudocode for the nonsequential update is driven entirely by the transaction 
file, which reads a transaction, determines whether or not the corresponding social 
security n u m b e r is in the indexed file, then processes the transaction as 
appropriate. T h e logic is simpler than that of the balance line algorithm, which 
had to determine whether the next record w a s to be read from the transaction 
file, the old master file, or both. 
The pseudocode reads a record from the transaction file and immediately 
does a r a n d o m read o n the indexed file. T h e social security n u m b e r from the 
transaction file is, or is not, present in the indexed file, which determines the value 
of the record-key-allocated-switch. T h e transaction is then processed according to 
the transaction code (addition, deletion, or correction) a n d the value of the record-
key-allocated-switch. The process continues until the transaction file is exhausted. 
The Completed Program 
. 
The completed program is s h o w n in Figure 18.10. T h e S E L E C T statement for the 
I N D E X E D - F I L E (lines 10-14) contains the required O R G A N I Z A T I O N IS I N D E X E D 
a n d R E C O R D K E Y clauses, a n d specifies A C C E S S IS R A N D O M . I N D E X E D - F I L E is 
opened as an I/O file in line 63 because it serves as both the old a n d n e w master file; 
that is, it is read from a n d written to. 
The R E A D statement for the indexed file (lines 79-84) is preceded by a M O V E 
statement, in which the key of the transaction record is m o v e d to 1ND-SOC-SEC-
N U M , the field defined as the R E C O R D KEY. T h e indexed file is read in an attempt 
to find this record, a n d the INVALID K E Y condition is triggered if the value is not 
in the file. 
The contents of the lowest-level modules, A D D - N E W - R E C O R D , C O R R E C T -
E X I S T I N G - R E C O R D and D E L E T E - E X I S T I N G - R E C O R D , have been modified slightly 
(from their counterparts in the sequential update) to include the appropriate I/O 
statements a n d contain W R I T E , R E W R I T E , a n d D E L E T E statements, respectively. 

Maintaining 
an 
indexed 
File 
Pseudocode for Nonsequential Update Program 
Open files 
DO WHILE data remains  
READ transaction file 
AT END 
Indicate no more data 
NOT AT END 
Move transaction social security number to record key 
READ INDEXED-FILE 
INVALID KEY 
Move 'NO' TO record-key-allocated-switch 
NOT INVALID KEY 
Move 'YES' TO record-key-allocated-switch 
END-READ 
EVALUATE transaction-code 
WHEN addition 
IF record-key-allocated-switch = 'yes' 
Write 'error - duplicate addition' 
ELSE (transaction is not in indexed file) 
Move transaction-record to new-master-record 
Wri te i ndexed record 
- ENDIF 
WHEN correction 
IF record-key-allocated-switch = 'yes' 
Process correction 
Rewrite indexed record 
ELSE (transaction is not in indexed file) 
Write 'error - no matching record' 
' 
ENDIF 
WHEN deletion 
: 
IF record-key-allocated-switch = 'yes' 
I 
i 
Delete indexed record 
i 
ELSE (transaction is not in indexed file) 
I 
Write 'error - no matching record' 
1 
ENDIF 
WHEN other 
Write 'error - invalid transaction code 
1 
END EVALUATE 
-- END READ 
END DO 
Close files 
Stop run 

C
h
a
p
t
e
r 
18 
Indexed 
Files 
,10 
Nonsequential Update Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
N0NSEQUP. 
AUTHOR. 
ROBERT GRAUER. 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT TRANSACTION-FILE 
ASSIGN TO 
ORGANIZATION IS LINE SEQUENTIAL. 
1 A: \CHAPTR18WALTRANS. DAT
1 
SELECT INDEXED-FILE 
ASSIGN TO 'A:\CHAPTR18\INDMAST.DAT' 
ORGANIZATION IS INDEXED 
ACCESS IS RANDOM 
RECORD KEY IS IND-SOC-SEC-NUM. 
DATA DIVISION. 
FILE SECTION. 
FD TRANSACTION-FILE 
RECORD CONTAINS 37 CHARACTERS 
DATA RECORD IS TRANSACTION-RECORD. 
01 TRANSACTION-RECORD 
FD INDEXED-FILE 
RECORD CONTAINS 39 CHARACTERS 
DATA RECORD IS INDEXED-RECORD. 
01 INDEXED-RECORD. 
05 IND-SOC-SEC-NUM 
05 IND-REST-OF-RECORD 
WORKING-STORAGE SECTION. 
01 FILLER 
VALUE 'WS BEGINS HERE'. 
01 WS-TRANS-RECORD. 
05 TR-SOC-SEC-NUMBER 
TR-NAME. 
10 TR-LAST-NAME 
10 TR-INITIALS 
TR-LOCATION-CODE 
TR-COMMISSION-RATE 
TR-SALES-AMOUNT 
TR-TRANSACTION-CODE 
88 ADDITION 
VALUE 'A'. 
88 CORRECTION 
VALUE ' C . 
88 DELETION 
VALUE 'D'. 
01 WS-MASTER-RECORD. 
05 MA-SOC-SEC-NUMBER 
05 MA-NAME. 
10 MA-LAST-NAME 
05 
05 
05 
05 
05 
PIC X(37). 
PIC X(9). 
PIC X(30). 
PIC X(14) 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC X(3). 
PIC 99. 
PIC 9(5). 
PIC X. 
•tatermnt lor 
INDEXED-FILE 
PIC X(9). 
PIC X(15). 

Maintaining 
an 
Indexed 
File 
(continued) 
51 
10 MA-INITIALS 
PIC XX. 
52 
05 MA-LOCATION-CODE 
PIC X(3). 
53 
05 MA-COMMISSION-RATE 
PIC 99. 
54 
05 MA-YEAR-TO-DATE-SALES 
PIC 9(8). 
55 
56 
01 PROGRAM-SWITCHES. 
57 
05 END-OF-FILE-SWITCH 
PIC X(3) 
VALUE 'NO '. 
58 
05 RECORD-KEY-ALLOCATED-SWITCH 
PIC X(3) 
VALUE 'NO'. 
59 
60 
PROCEDURE DIVISION. 
61 
0010-PROCESS-TRANSACTION-FILE. 
62 
OPEN INPUT TRANSACTION-FILE 
63 
1-0 INDEXED-FILE. 
64 
: PERFORM UNTIL END-OF-FILE-SWITCH = ' Y E S ' " j 
65 
READ TRANSACTION-FILE INTO WS-TRANS-RECORD \ 
66 
AT END 
67 
MOVE 'YES' TO END-OF-FILE-SWITCH 
68 
NOT AT END 
69 
PERFORM 0020-READ-INDEXED-FILE 
70 
PERFORM 0030-APPLY-TRANS-TO-MASTER ; 
71 
END-READ 
72 
END-PERFORM. 
73 
CLOSE TRANSACTION-FILE 
74 
INDEXED-FILE. 
75 
STOP RUN. 
76 
77 
0020-READ-INDEXED-FILE. 
/ ' 
78 
MOVE TR-SOC-SEC-NUMBER TO IND-SOC-SEC-NUM. 
79 
READ INDEXED-FILE INTO W S - M A S T E R - R E C O R D " " 
H 
80 
INVALID KEY 
81 
MOVE 'NO ' TO RECORD-KEY-ALLOCATED-SWITCH 
82 
NOT INVALID KEY 
83 
MOVE 'YES' TO RECORD-KEY-ALLOCATED-SWITCH 
84 
END-READ. 
85 
" 
" 
86 
0030-APPLY-TRANS-TO-MASTER. 
87 
F EVALUATE T
R
U
E
"
~
~
~ 
""'] 
88 
WHEN ADDITION 
89 
PERFORM 0090-ADD-NEW-RECORD 
90 
WHEN CORRECTION 
91 
PERFORM 0100-CORRECT-EXISTING-RECORD 
92 
WHEN DELETION 
' 
93 
PERFORM 0110-DELETE-EX I STING-RECORD 
94 
WHEN OTHER 
95 
DISPLAY 'INVALID TRANSACTION CODE
1 
96 
, END-EVALUATE. 
_j 
97 
~ ~ " 
98 
0090-ADD-NEW-RECORD. 
99 
IF RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
100 
DISPLAY ' ERROR-DUPLICATE ADDITION: ' TR-SOC-SEC-NUMBER 

C
h
a
p
t
e
r 
1 8 — 
Indexed 
Files 
i g u r e 1 8 . 1 0 
(continued) 
j 
101 
ELSE 
| 
102 
MOVE SPACES TO WS-MASTER-RECORD 
103 
MOVE TR-SOC-SEC-NUMBER TO MA-SOC-SEC-NUMBER 
104 
MOVE TR-NAME TO MA-NAME 
105 
MOVE TR-LOCATION-CODE TO MA-LOCATION-CODE 
106 
MOVE TR-COMMISSION-RATE TO MA-COMMISSION-RATE 
107 
MOVE ZEROS TO MA-YEAR-TO-DATE-SALES 
108 
WRITE INDEXED-RECORD FROM WS-MASTER-RECORD 
109 
END-IF. 
110 
| 
111 
0100-CORRECT-EXISTING-RECORD. 
112 
IF RECORD-KEY-ALLOCATED-SWITCH = 'YES' 
113 
ADD TR-SALES-AMOUNT TO MA-YEAR-TO-DATE-SALES 
j 
114 
[j^JIf INDEXED-RECORD"FROM WS-MASTER-RECORD\ 
| 
115 
ELSE" 
" 
' ~ \ 
j 116 
DISPLAY ' ERROR-NO MATCHING RECORD: ' TR-SOC-S^C-NUMBER 
| 
117 
END-IF. 
\ 
118 
\ 
119 
0110-DELETE-EXISTING-RECORD. 
_ 
—
— 
120 
IF RECORD-KEY-ALLOCATED-SWITCH^j^LYiy ~~ 
| 
121 
[DELETEINDEXED-FILE \ 
122 
ELSE~ 
' 
123 
DISPLAY
 1 ERROR-NO MATCHING RECORD:
 1 TR-SOC-SEC-NUMBER 
124 
END-IF. 
> ti. - 
O u r earlier discussion of the S E L E C T statement included the 7ALTERNATE RECORD 
iri^-^iv^j Zf L\.v_ • 
KEY phrase to enable a second path for retrieving records from an indexed file. 
Unlike the record key, which must be unique, the alternate key m a y contain duplicate 
values. This capability is illustrated in the third a n d final program of the chapter, the 
specifications of which follow in the usual format. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
Alternate Indexes 
N a r r a t i v e : 
This program illustrates primary and alternate indexes, as well as nonsequential retrieval 
on either type of key. It does no useful processing per se, other than to illustrate COBOL 
syntax 
I n p u t F i l e : 
INDEXED-FILE 
I n p u t R e c o r d L a y o u t : 
01 INDEXED-RECORD. 
05 IND-SOC-SEC-NUMBER 
PIC X(9). 
05 IND-NAME 
PIC X(15). 
05 IND-REST-0F-REC0RD 
PIC X(16). 

Alternate 
Record 
Key 
Figure 18.11 Alternate Keys 
100000000GRAUER 
100000001GRAUER 
100000002GRAUER 
300000000MILGROM 
300000001MILGR0M 
300000002MIL6R0M 
400000000GRAUER 
500000000J0NES 
600000000SMITH 
700000000MILGR0M 
fa) The Indexed File 
PRIMARY KEY OK - 300000001 
ALTERNATE KEY - MILGROM 
300000000 
ALTERNATE KEY - MILGROM 
300000001 
ALTERNATE KEY - MILGROM 
300000002 
ALTERNATE KEY - MILGROM 
700000000 
(0) Displayed 
jcptit 
Test Data: 
See Figure 18.11a. 
Report Layout: 
There is no formal report produced by this program; instead DISPLAY statements are 
used to indicate the results as in Figure 18.11b. 
Processing Requirements: 
1. The social security and name fields are designated as the primary and secondary 
keys, respectively. The value of the social security number is unique, whereas the 
value of name is not. 
2. Execute a random read for the record whose social security number is 300000001, 
displaying an appropriate message to indicate whether or not the record was found. 
3. Execute a random read to find the first record whose name is Milgrom, then read 
sequentially to display all other records with this value in the secondary key. 
Figure 18.12 contains the completed program corresponding to these specifications. 
The S E L E C T statement in lines 8-13 designates I N D - S O C - S E C - N U M and I N D -
N A M E as the primary (record) a n d alternate key, respectively. T h e record key is 
(and must always be) unique, but the alternate key need not be; hence the W I T H 
D U P L I C A T E S phrase is included in the S E L E C T statement. Both fields are defined 
within the F D for I N D E X E D - F I L E in lines 21 and 22, respectively. T h e A C C E S S IS 
D Y N A M I C phrase (line 11) indicates both r a n d o m a n d sequential retrieval within 
the s a m e program. 

C
h
a
p
t
e
r 
1 8 
— 
Indexed 
Files 
Alternate Index Program 
9 
10 
ll 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
2 5 
26 
27 
2 8 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
ALTINDEX. 
A U T H O R . 
ROBERT GRAUER. 
ENVIRONMENT D I V I S I O N . 
INPUT-OUTPUT S E C T I O N . 
F I L E - C O N T R O L . 
S E L E C T INDEXED-FILE 
A S S I G N T O 'A:\CHAPTR18\ALTINDEX.DAT' 
O R G A N I Z A T I O N IS I N D E X E D 
_ 
j A C C E S S ISJDYNAMIC , " """ 
RECORD KEY IS IND-SOC-SEC-NUM 
UETERNATE RECORD KEY IS IND-NAME W I T H DUPLICATES. 
DATA D I V I S I O N . 
F I L E S E C T I O N . 
FD 
INDEXED-FILE 
RECORD CONTAINS 40 CHARACTERS 
DATA RECORD IS INDEXED-RECORD. 
INDEXED-RECORD. 
01 
05 
IND-SOC-SEC-NUM 
05 
IND-NAME 
PIC X ( 9 ) . 
PIC X(15). 
0 5 
IND-REST-OF-RECORD 
W O R K I N G - S T O R A G E SECTION. 
01 
END-OF-FILE-SWITCH 
PIC X(16). 
PIC X(3) 
V A L U E S P A C E S . 
PROCEDURE D I V I S I O N . 
0 0 1 0 - D I S P L A Y - I N D E X E D - R E C O R D S . 
O P E N INPUT INDEXED-FILE. 
PERFORM 
0 0 2 0 - R E T R I E V E - B Y - P R I M A R Y - K E Y . 
PERFORM 
0 0 3 0 - R E T R I E V E - B Y - S E C O N D A R Y - K E Y . 
C L O S E I N D E X E D - F I L E . 
STOP R U N . 
0020-RETRIEVE-BY-PRIMARY-KEY. 
MOVE '300000001' TO IND-SOC-SEC-NUM. 
READ I N D E X E D - F I L E 
INVALID K E Y 
DISPLAY 'RECORD N O T FOUND - 3 0 0 0 0 0 0 0 1 
NOT I N V A L I D KEY 
DISPLAY 'PRIMARY K E Y O K -
END-READ. 
DISPLAY '
 1. 
I N D - S O C - S E C - N U M 
0030-RETRIEVE-BY-SECONDARY-KEY. 
MOVE 'MILGROM' T O IND-NAME. _ 
" READ I N D E X E D - F I L E "KEY ISTND-NAME 
INVALID KEY 
DISPLAY 'RECORD N O T FOUND - M I L G R O M ' 

ed 
Ke y 
(continued) 
NOT INVALID KEY 
PERFORM 0040-RETRIEVE-DUPLICATES 
" ] 
UNTIL IND-NAME NOT EQUAL 'MILGROM'| 
OR END-OF-FILE-SWITCH = 'YES' 
K 
^ 
END-READ, 
0040-RETRIEVE-DUPLICATES. 
DISPLAY 'ALTERNATE KEY -
 1 IND-NAME, IND-SOC-SEC-NUM. 
READ INDEXED-FILE NEXT RECORD 
AT END 
MOVE 'YES' TO END-OF-FILE-SWITCH 
END-READ. 
The Procedure Division illustrates the retrieval of records on either field. Lines 
36-44 contain the logic for the primary key and have already been covered in the 
program for a nonsequential update. The R E A D statement of lines 38-43 is preceded 
by a M O V E statement in which the key of the desired record (300000001 in the 
example) is m o v e d to the data n a m e designated as the R E C O R D KEY in the S E L E C T 
statement. If the record is in the file, it will be read into the data n a m e I N D E X E D -
R E C O R D ; a n d the false-condition branch, N O T INVALID KEY, will indicate the 
primary key was found. If the record is not in the file, the INVALID K E Y condition 
will be activated to display an appropriate error message. 
Lines 46-55 contain a parallel procedure based o n the alternate key, but with 
three important differences: 
1. The key value ( M I L G R O M ) is m o v e d to the A L T E R N A T E R E C O R D K E Y (IND-
N A M E rather than I N D - S O C - S E C - N U M ) . 
2. The K E Y IS phrase is used to indicate the retrieval is o n the alternate rather 
than the primary key. 
3. Successful retrieval causes the execution of 0040-RETRIEVE-DUPLICATES, 
which retrieves all records for M I L G R O M . The N E X T R E C O R D phrase (line 
59) in the R E A D statement indicates sequential retrieval. 
The DISPLAY output produced by the program is s h o w n in Figure 18.11b. The 
first message indicates the successful retrieval based o n the primary key (produced 
by the paragraph 0020-RETRIEVE-BY-PRIMARY-KEY). The second set of messages 
reflects all records for Milgrom. 
- t. * 
The record key in an indexed file m a y be specified as a group item rather than an 
elementary item, producing what is k n o w n as a concatenated key, that is, a key consisting 
of two (or more) keys strung together to form a single value. Consider, for example, a 
system for bank loans with a concatenated key defined as follows: 
05 CUSTOMER-LOAN-NUMBER. 
10 CUSTOMER-NUMBER 
10 LOAN-NUMBER 
PIC 9(6). 
PIC 9(3). 

C
h
a
p
t
e
r 
1 8 
-
Indexed 
Files 
In this example CUSTOMER-LOAN-NUMBER is a group item a n d consists of the 
. 
: * 
/ * ' ! I f ' I V MV * 1 ' !> 
\ ! I I \ « 1 1 1 * I I 
I I / U 
\ ' 
X I I I \ .1 1 1 1 * l > 
I 
1 - . - 
i ' . I 
ciciiicniaiy nciiis, i j u j 1 u i v i m \ - i i u i v i D m d i m n / m \ - , \ u i v u n 
c v e i y v a l u e ui m e 
record key (CUSTOMER-LOAN-NUMBER) must b e unique, but there can b e several 
loans for the s a m e customer, with each loan assigned a n e w loan number. Customer 
111111, for example, m a y have two outstanding loans, with record keys of 111111001 
and 111111004, respectively. (Loans 002 a n d 003 m a y have b e e n previously paid 
off.) T h e problem is to retrieve all loans for a given customer, which leads to a 
discussion of the START statement. 
Ttw 
S t a t e m e n t 
The START statement m o v e s nonsequentially (randomly) into a n indexed file to 
the first record w h o s e value is equal to, greater than, or n o t less than the value 
contained in the identifier. The INVALID KEY condition is raised if the file does 
not contain a record m e e t i n g the specified criterion. Syntactically, the START 
statement h a s the form: 
START file- name KEY 
IS EQUAL TO 
IS = 
IS GREATER THAN 
IS > 
IS NOT LESS THAN 
IS NOT < 
IS GREATER THAN OR EQUAL TO 
IS >= 
identifier 
[INVALID KEY imperative-statement-l] 
[NOT INVALID KEY imperative-statement-2] 
[END-START] 
The START statement can b e used in conjunction with a concatenated key as 
s h o w n in Figure 18.13. Note, 
however, 
that 
START only 
moves 
to the 
designated 
record, but does not read the record. In other words, a READ statement is required 
immediately following START. T h e s u b s e q u e n t PERFORM statement will then 
retrieve all loans for the customer in question. 
The READ, DELETE, WRITE, REWRITE, and START statements contain both 
an optional scope terminator and a false-condition branch. As indicated 
throughout the text, these elements are new to COBOL-85 and were not 
available in COBOL-74. 
Sixteen I/O status codes (i.e., the majority of the entries in Table 
18.1) are new to COBOL-85. The new codes (02, 04, 05, 07, 15, 24, 25, 
34, 35, 37, 38, 39, 41, 42, 43, 46, and 49) were added to eliminate the 
need for vendor-specific file status codes that treated the same error 
condition in different ways. 

on catenated 
Key 
The START Statement 
SELECT LOAN-FILE 
ASSIGN TO 'A:\CHAPTR18\L0AN.DAT' 
ORGANIZATION IS INDEXED 
ACCESS MODE IS DYNAMIC 
RECORD KEY IS CUSTOMER-LOAN-NUMBER. 
FD LOAN-FILE 
RECORD CONTAINS 120 CHARACTERS 
DATA RECORD IS LOAN-RECORD. 
01 LOAN-RECORD. 
05 CUSTOMER-LOAN-NUMBER. 
10 CUSTOMER-NUMBER 
PIC 9(6). 
10 LOAN-NUMBER 
PIC 9(3). 
PROCEDURE DIVISION. 
MOVE 333333000 TO CUSTOMER-LOAN-NUMBER. 
STAR! LOAN-FILE 
KEY IS GREATER THAN CUSTOMER-LOAN-NUMBER 
INVALID KEY DISPLAY 'CUSTOMER 333333 NOT IN FILE 
| END-START. _^ 
READ LOAN-FILE NEXT RECORD 
AT END 
MOVE 'YES' TO END-OF-FILE-SWITCH 
END-READ. 
PERFORM UNTIL CUSTOMER-NUMBER NOT EQUAL 333333 
j 
OR END-OF-FILE-SWITCH = 'YES' 
DISPLAY LOAN-RECORD 
j 
READ LOAN-FILE NEXT RECORD 
AT END 
MOVE 'YES' TO END-OF-FILE-SWITCH 
END-READ 
END-PERFORM. 

Chapter 
18 
Indexed 
Files 
S U M M A R Y 
Points 
to 
ter 
Indexed files permit sequential and/or nonsequential access to records 
within a file. Different vendors have different physical implementations, but 
the COBOL syntax to access an indexed file is the same for all compilers 
adhering to the ANS 85 standard. VSAM (Virtual Storage Access Method) 
is IBM's implementation for indexed files. 
The SELECT statement for an indexed file has seven clauses: three clauses 
(ASSIGN, ORGANIZATION IS INDEXED, and RECORD KEY) are required, 
and the other four (RESERVE AREAS, ACCESS MODE, ALTERNATE 
RECORD KEY, and FILE STATUS) are optional. 
The RECORD KEY clause in the SELECT statement specifies a field (defined 
within the FD of the indexed record) whose value must be unique; the value 
of the optional alternate record key can contain duplicate values. 
The Procedure Division has several statements uniquely associated with 
indexed files, and/or extends the formats of other statements to 
accommodate indexed files. These include OPEN l-O, READ . . . INVALID 
KEY, WRITE . . . INVALID KEY, and DELETE. 
The transaction file does not have to be in sequence when updating an 
indexed file as the latter can be accessed nonsequentially. The INVALID 
KEY clause will be activated if the transaction record is not found. 
The updated indexed file cannot be used as the old master to retest the 
update program with the same input as previously; you must retain (create) 
a copy of the original indexed file for repeated testing. 
A concatenated key consists of two or more fields strung together. 
Concatenated keys are frequently used in conjunction with the START 
statement, which moves nonsequentially to the first record satisfying a 
specified condition. 
Key 
Words 
and 
Concepts 
Concatenated key 
Control area 
Control area split 
Control interval 
Control interval split 
False-condition branch 
Free space 
Index set 
Indexed file 
I/O status 
Multiple keys 
Nonsequential access 
Scope terminator 
Sequence set 
Sequential access 
VSAM organization 

lemenis 
ACCESS IS DYNAMIC 
ACCESS IS RANDOM 
ACCESS IS SEQUENTIAL 
ACCESS MODE 
ALTERNATE RECORD KEY 
DELETE 
END-DELETE 
END-READ 
END-START 
END-REWRITE 
END-WRITE 
FILE STATUS 
INVALID KEY 
NOT INVALID KEY 
OPEN 1-0 
ORGANIZATION IS INDEXED 
RECORD KEY 
RESERVE AREAS 
REWRITE 
START 
WITH DUPLICATES 
WRITE . . . INVALID KEY 
N 
1. 
files make it possible to retrieve records sequentially and/or 
nonsequentially. 
2. An active file is best updated sequentially, whereas . 
should be used for inactive files. 
processing 
3. 
. is the IBM specific implementation of COBOL's. 
file organization. 
4. In IBM's VSAM implementation, a 
one or more 
contains 
5. In IBM's VSAM implementation, each entry in a sequence set contains the  
key for the associated control interval. 
6. The SELECT statement for indexed files requires three clauses: 
, and 
. 
7. An indexed file requires the primary key to be 
values for its 
key. 
8. Records are added to an indexed file through the 
existing records are changed through 
statement. 
but allows 
statement; 
and removed by the 
9. The FILE STATUS clause is (optional/required) and requires that a. 
byte area be defined in 
. 
10. FILE STATUS bytes of 
whereas 
indicates an end-of-file condition 
ndicate a successful I/O operation, 
11. The. 
. statement allows one to enter an indexed file randomly and 
read sequentially from that point on. 
12. A random (nonsequential) READ statement is preceded by a MOVE statement in 
which the desired key is moved to the field defined as the 
13. Specification of ACCESS IS 
permits both sequential and 
nonsequential access of an indexed file in the same program. 
14. When a file is open in the. 
to. 
. mode, it may be read from and written 

• 
Chapter 
18 — 
Indexed 
Files 
T R U E / F A L S E 
1. ALTERNATE RECORD KEY should always be specified for indexed files to allow for 
future expansion. 
2. The FILE STATUS clause is permitted only for indexed files. 
3. A READ statement must contain either the AT END or INVALID KEY clause. 
4. Inclusion of the INTO clause in a READ statement is not recommended, as it 
requires additional storage space. 
5. RESERVE 0 AREAS is recommended to speed up processing of an indexed file 
that is processed sequentially. 
6. The value of RECORD KEY must be unique for every record in an indexed file. 
7. The value of ALTERNATE RECORD KEY must be unique for every record in an 
indexed file. 
8. The FILE STATUS clause is a mandatory entry in the SELECT statement for an 
indexed file. 
9. An indexed file can be accessed sequentially and nonsequentially in the same 
program. 
10. The first byte of an indexed record should contain either LOW- or HIGH-VALUES. 
11. WRITE and REWRITE can be used interchangeably. 
12. Records in an indexed file are deleted by moving HIGH-VALUES to the first byte. 
13. The COBOL syntax for IBM VSAM files conforms to the ANS 85 standard. 
14. Active files are best updated nonsequentially. 
PROBLEMS 
1. Describe the changes to Figure 18.3 if record keys 401, 723, 724, and 725 were 
added. What would happen if record keys 502 and 619 were deleted? 
2. Assume that record key 289 is to be inserted in the first control area of the VSAM 
data set in Figure 18.3. Logically, it could be added as the last record in the first 
control interval or the first record in the second control interval. Is there a preference? 
In similar fashion, should record 620 be inserted as the last record in the third 
interval of the second area or as the first record in the first interval of the third area? 
Finally, will record 900 be inserted as the last record in the fourth control area, or 
will it require creation of a fifth control area? Can you describe in general terms how 
VSAM adds records at the end of control areas and/or control intervals? 
3. Indicate whether each of the following SELECT statements is valid syntactically and 
logically. (Some of the statements have more than one error.) 
a. SELECT INDEXED-FILE 
ASSIGN 'A:\CHAPTR18\INDMAST.DAT'  
ORGANIZATION INDEXED 
RECORD IND-S0C-SEC-NUM. 

b. SELECT INDEXED-FILE 
ASSIGN TO 'A:\CHAPTR18\INDMAST.DAT' 
RECORD KEY IS IND-SOC-SEC-NUM WITH NO DUPLICATES 
ALTERNATE KEY IS IND-NAME WITH DUPLICATES. 
C. SELECT INDEXED-FILE 
ASSIGN 'A:\CHAPTR18\INDMAST.DAT'  
RESERVE 5 AREAS 
ORGANIZATION IS INDEXED 
ACCESS IS SEQUENTIAL 
RECORD KEY IS IND-SOC-SEC-NUM WITH DUPLICATES 
ALTERNATE RECORD KEY IS IND-NAME 
FILE STATUS IS FILE-STATUS-BYTES. 
d. SELECT INDEXED-FILE 
ASSIGN TO 'A:\CHAPTR18\INDMAST.DAT' 
ORGANIZATION IS INDEXED 
ACCESS MODE RANDOM 
RECORD KEY IS IND-SOC-SEC-NUM. IND-NAME. 
4. Given the C O B O L definition: 
05 
FILE-STATUS-BYTES 
PIC 99. 
What is wrong with the following entries? 
a. IF FILE-STATUS-BYTES EQUAL '10" 
DISPLAY 'END OF FILE HAS BEEN REACHED' 
END-IF 
b. IF FILE STATUS-BYTES EQUAL 10 
DISPLAY 'ERROR - DUPLICATE KEY' 
END-IF 
C. 
IF FILE-STATUS-BYTE EQUAL 1 
DISPLAY 'END OF FILE HAS BEEN REACHED' 
END-IF 
d. IF FILE STATUS BYTES EQUAL 10 
DISPLAY 'END OF FILE HAS BEEN REACHED
1 
END-IF 
5. Indicate whether each of the following entries is valid syntactically and logically. 
(Assume INDEXED-FILE and INDEXED-RECORD are valid as a file name and a 
record name, respectively.) 
a. OPEN INPUT INDEXED-FILE 
OUTPUT INDEXED-FILE. 
b.. READ INDEXED-FILE. 
c. READ INDEXED-FILE 
AT END MOVE 'YES' TO END-OF-FILE-SWITCH. 
END-READ. 

C
h
a
p
t
e
r 
1 8 
Indexed 
Files 
d. READ INDEXED-FILE 
AT END 
MOVE 'YES' TO END-OF-FILE-SWITCH 
NOT AT END 
PERFORM PROCESS-RECORD 
END-READ. 
e. READ INDEXED-FILE 
AT END MOVE 21 TO FILE-STATUS-BYTES. 
f. READ INDEXED-FILE 
INVALID KEY 
DISPLAY 'RECORD IS IN FILE' 
NOT INVALID KEY 
DISPLAY 'RECORD IS NOT IN FILE' 
END-READ. 
g. WRITE INDEXED-RECORD. 
h. WRITE INDEXED-RECORD 
INVALID KEY 
DISPLAY 'INVALID KEY' 
NOT INVALID KEY 
PERFORM CONTINUE-PROCESSING 
END-WRITE. 
i. REWRITE INDEXED-RECORD 
i M U A f 
i n 
i / r u 
jmvttL.iu ivc 
i 
DISPLAY 'INVALID KEY' 
PERFORM ERROR-PROCESSING 
END-REWRITE. 
j. REWRITE INDEXED-FILE. 
k. DELETE INDEXED-RECORD. 
I. DELETE INDEXED-FILE. 
6. Figure 18.14a contains a slightly modified paragraph from the nonsequential update 
program of Figure 18.10, which produces the compiler diagnostics in Figure 
18.14b. W h y do the errors occur? 
7. The balance line algorithm was not used for the nonsequential update program 
(Figure 18.10) developed in the chapter. The resulting program worked correctly, 
but it can be m a d e more efficient by changing its logic to include the concept of the 
active key. 
a. What are the advantages of including the additional logic and using the balance 
line algorithm? 
b. What are the disadvantages to this approach? 
c. Modify the hierarchy chart and pseudocode of Figures 18.8 and 18.9 to 
accommodate the algorithm. 

Problems 
60 
PROCEDURE DIVISION. 
61 
0010-UPDATE-MASTER-FILE. 
62 
OPEN INPUT TRANSACTION-FILE 
63 
I-O INDEXED-FILE. 
64 
PERFORM UNTIL END-OF-FILE-SWITCH = 'YES' 
65 
READ TRANSACTION-FILE INTO WS-TRANS-RECORD 
66 
AT END 
67 
MOVE 'YES' TO END-OF-FILE-SWITCH 
68 
NOT AT END 
69 
PERFORM 0020-READ-INDEXED-FILE 
70 
PERFORM 0030-APPLY-TRANS-TO-MASTER. 
71 
END-READ 
72 
END-PERFORM 
(a) Modified Procedure Division 
64 W Explicit scope terminator END- 'PERFORM' assumed present 
71 E No corresponding active scope for 'END-READ' 
72 E No corresponding active scope for 'END-PERFORM' 
(b) Error M e s s a g e s 
L 
j 
Figure 18.14 Debugging Exercise 


Overview 
T h e Y e a r 2 0 0 0 Problem 
D a t e Arithmetic 
COBOL intrinsic Calendar Functions 
Leap-Year Problem 
R e t i r e m e n t P r o g r a m R e v i s i t e d 
Summary 
Fill-in 
True/False 
Problems 
For Further Study 

C
h
a
p
t
e
r 
18 
— 
The 
"rear 
2000 
Problem 
OBJECTIVES 
After reading this chapter, you will be able to: 
Describe the implications of the Year 2000 problem. 
State the causes of the problem. 
Identify the types of routines that may cause the problem. 
Discuss several types of date arithmetic. 
Use COBOL intrinsic calendar function to do date conversions. 
This chapter discusses a major information system issue at the end of the 
twentieth century. This problem is known by several titles such as "the Year 2000 
problem," "Millennium 2K," or simply "Y2K." Whatever the name, the problem is 
one the industry has brought upon itself—threatening the well-being of many 
companies and governmental organizations. The purpose of this chapter is to 
define what the problem is, show how it came about, and suggest some ways to 
deal with it. 
The first section of the chapter discusses the nature of the problem by 
examining a program typical of those written in the 1960s, 1970s, and 1980s. 
The next section deals with the issues of date arithmetic. The discussion involves 
the two date formats introduced in Chapter 8: DATE format (YYMMDD) and DAY 
(YYDDD). The discussion shows how the DAY format can be used in calculating 
the number of days between two dates. This section of the chapter then looks at 
the COBOL intrinsic calendar functions to see how they can further simplify date 
arithmetic. 
Leap year processing compounds the Year 2000 problem. The last portion 
of the chapter looks at this aspect of the problem and presents a Year 2000 
compliant version of the original program. For further research on the Year 2000 
problem, the section contains a listing of World Wide Web sites dedicated to the 
problem and its solution. 
L C (3 f *.
 : i r 
Ix)ok at the retirement program listed in Figure 19.1. This program reads an employee 
y{< ^ 
(«, \jj 
file and computes the employee's age, years of service to the company, and the date 
of retirement. The program then prints a report showing tire results of its calculations. 
D o you see any problems with this program? First, notice the output format 
for the retirement date. In line 85, just before DET-RET-YR, the programmer has 
coded in a value of " /19." As a result, the output report will print the retirement year 
as "19 FY" no matter w h e n the employee is due to retire. Obviously, in the late 1990s, 
most employees will retire after 1999 and the report format needs to reflect a 

The 
Year 
2000 
Problem 
retirement year where the first two digits can be 19, 20, or even 21. The report 
should not state that the retirement date is 1904 w h e n the year actually should be 
2004. 
This program is a simple example of the Year 2000 problem. W h e n programs 
like this one were written, programmers assumed that all dates used would be in the 
twentieth century' and that "19" was the valid prefix for all years. 
This type of thinking meant that m a n y computer systems incorporated only 
two digits for representing a year instead of the four digits normally used. As a 
result, w h e n these systems encounter the year 2000, they act as if the year is 1900. 
This apparently simple oversight m e a n s that w h e n January 1, 2000 comes, m a n y 
systems will fail entirely or will produce massive amounts of erroneous information. 
The remedy will not be cheap. S o m e authorities estimate the cost to fix the problem 
at $300 billion to $600 billion worldwide.
2 The Year 2000 problem is one that will 
not go away, and the deadline cannot be delayed. 
Retirement Program, a Year 2000 Problem Example 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. Y2K01. 
3 
AUTHOR. 
ARTHUR R. BUSS 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
FILE-CONTROL. 
8 
SELECT EMPLOYEE-FILE ASSIGN TO
 1EMPSERV.DAT
1 
9 
ORGANIZATION IS LINE SEQUENTIAL. 
10 
SELECT PRINT-FILE ASSIGN TO PRINTER. 
11 
12 
DATA DIVISION. 
13 
FILE SECTION. 
14 
FD EMPLOYEE-FILE 
15 
RECORD CONTAINS 34 CHARACTERS. 
16 
01 EMPLOYEE-RECORD 
PIC X(34). 
17 
18 
FD PRINT-FILE 
19 
RECORD CONTAINS 80 CHARACTERS. 
20 
01 PRINT-LINE 
PIC X(80). 
21 
22 
WORKING-STORAGE SECTION. 
23 
01 EMPLOYEE-DATA. 
24 
05 EMP-NUM 
PIC X(05). 
25 
05 EMP-NAME. 
26 
10 EMP-LAST 
PIC X(15). 
27 
10 EMP-INIT 
PIC X(02). 
28 
05 EMP-BIRTHDATE. 
29 
10 EMP-BIRTH-YR 
PIC 9(02). 
30 
10 EMP-BIRTH-M0 
PIC 9(02). 
31 
10 EMP-BIRTH-DA 
PIC 9(02). 
32 
05 EMP-SERVICE-DATE. 
33 
10 EMP-SERVICE-YR 
PIC 9(02). 
34 
10 EMP-SERVICE-MO 
PIC 9(02). 

C
h
a
p
t
e
r 
1 9 
(continued) 
10 EMP-SEfiVICE-DA 
PIC 9(02). 
01 OATA-REMAINS-SW 
PIC X(02). 
88 NO-DATA-REMAINS 
VALUE 'NO
1. 
01 
INDIVIDUAL-FIELDS. 
05 IND-AGE 
PIC 9(02). 
05 IND-SERV-YEARS 
PIC 9(02). 
05 IND-RET-DATE. 
10 IND-RET-YR 
PIC 9(02). 
10 IND-RET-MO 
PIC 9(02). 
10 IND-RET-DA 
PIC 9(02). 
01 TODAYS-DATE. 
05 TODAYS-YR 
PIC 9(02). 
05 TODAYS-MO 
PIC 9(02). 
05 TODAYS-DA 
PIC 9(02). 
01 CONSTANTS. 
05 RETIRE-AGE 
PIC 9(02) 
VALUE 65. 
01 HEADING-LINE-1. 
05 
PIC X(05) 
VALUE SPACES. 
05 
PIC X(10) 
VALUE 'EMPLOYEE'. 
05 
PIC X(17) 
VALUE SPACES. 
05 
PIC X(09) 
VALUE 'SERVICE'. 
05 
PIC X(10) 
VALUE 'RETIREMENT'. 
01 HEADING-LINE-2. 
05 
PIC X(07) 
VALUE SPACES. 
05 
PIC X(14) 
VALUE 'NAME'. 
05 
PIC X(07) 
VALUE ' INIT'. 
05 
PIC X(06) 
VALUE 'AGE'. 
05 
PIC X(08) 
VALUE 'YEARS'. 
05 
PIC X(10) 
VALUE 'DATE'. 
01 DETAIL-LINE. 
05 
05 DET-LAST 
05 
05 DET-INIT 
05 
05 DET-AGE 
05 
05 
DET-SERV-YEARS 
05 
05 DET-RET-DATE. 
10 DET-RET-MO 
10 
10 DET-RET-DA 
10 
10 DET-RET-YR 
PIC X(05) 
PIC X(15). 
PIC X(02) 
PIC X(02). 
PIC X(05) 
PIC 9(02). 
PIC X(05) 
PIC 9(02). 
PIC X(02) 
PIC Z9. 
PIC X 
PIC Z9. 
PIC X(03) 
PIC 9(02). 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
VALUE SPACES. 
VALUE '/'. 
VALUE '/19
1. 

The 
Year 
2000 
Problem 
F i g u r e 1 9 . 1 
(continued) 
| 
87 
88 
PROCEDURE DIVISION. 
89 
100-PREPARE-RETIREMENT-REPORT. 
90 
OPEN INPUT EMPLOYEE-FILE 
91 
OUTPUT PRINT-FILE 
92 
PERFORM 210-GET-TODAYS-DATE 
93 
PERFORM 230-WRITE-HEADERS 
94 
PERFORM UNTIL NO-DATA-REMAINS 
95 
READ EMPLOYEE-FILE INTO EMPLOYEE-DATA 
96 
AT END 
97 
SET NO-DATA-REMAINS TO TRUE 
98 
NOT AT END 
I 
99 
PERFORM 260-PROCESS-DETAIL 
| 
100 
END-READ 
j 
101 
END-PERFORM 
102 
CLOSE EMPLOYEE-FILE 
103 
PRINT-FILE 
104 
STOP RUN 
105 
jTj 
— 
"
"
" 
106
 
[ 
1 
107 
210-GET-TODAYS-DATE. 
108 
ACCEPT TODAYS-DATE FROM DATE 
109 
|* 
MOVE '000101
1 TO TODAYS-DATE ! 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
360-CALCULATE-IND-RET-DATE. 
ADD RETIRE-AGE 
TO 
330-CALCULATE-EMP-SERVICE. 
310-CALCULATE-EMP-A6E. 
260-PROCESS-DETAIL. 
PERFORM 310-CALCULATE-EMP-AGE 
PERFORM 330-CALCULATE-EMP-SERVICE 
PERFORM 360-CALCULATE-IND-RET-DATE 
PERFORM 390-WRITE-DETAIL-LINE 
230-WRITE-HEADERS. 
WRITE PRINT-LINE FROM HEADING-LINE-1 
COMPUTE IND-SERV-YEARS = TODAYS-YR - EMP-SERVICE-YR 
+ (TODAYS-MO - EMP-SERVICE-MO) / 12 
COMPUTE IND-AGE = TODAYS-YR - EMP-BIRTH-YR 
+ (TODAYS-MO - EMP-BIRTH-MO) / 12 
AFTER ADVANCING PAGE 
WRITE PRINT-LINE FROM HEADING-LINE-2 
INITIALIZE PRINT-LINE 
WRITE PRINT-LINE 
TO EMP-BIRTH-YR GIVING IND-RET-YR 

C
h
a
p
t
e
r 
1 9 
The 
Year 
2000 
Problem 
(continued) 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
MOVE EMP-BIRTH-MO 
MOVE EMP-BIRTH-DA 
TO IND-RET-MO 
TO IND-RET-DA 
390-WRITE-DETAIL-LINE. 
MOVE EMP-LAST 
MOVE EMP-INIT 
MOVE IND-AGE 
MOVE IND-SERV-YEARS 
MOVE IND-RET-MO 
MOVE IND-RET-DA 
MOVE IND-RET-YR 
WRITE PRINT-LINE 
TO DET-LAST 
TO DET-INIT 
TO DET-AGE 
TO DET-SERV-YEARS 
TO DET-RET-MO 
TO DET-RET-DA 
TO DET-RET-YR 
FROM DETAIL-LINE 
At this point, you m a y think that the case is overstated. Certainly a simple 
remedy exists for the problem described above. B y expanding the D E T - R E T - Y R field 
size to four positions a n d eliminating the "19" from the preceding filler field, the 
program can print either 19YY or 20YY. However, having m a d e the change, the 
question becomes, " H o w do I k n o w which lead digits to use, 19 or 20?" It would be 
to assume that the dates should c o m e before 2000. A w a y must be found to determine 
the appropriate digits. 
Y o u can n o w begin to see the essence of the Year 2000 problem. W h e n there 
are only two digits to work with, h o w would the program determine the right 
century? Should it treat "88" as 1888,1988, or 2088? Before answering the question, 
you m a y want to k n o w h o w this problem c a m e about in the first place. 
F r o m the 1960s through the 1980s, m a n y organizations developed systems 
containing programs, and, m o r e importantly, files that used only the last two digits 
of the year whenever a date was required. This practice worked well for a long time 
and did not s e e m to cause any particular problems. O n e exception was w h e n a 
program h a d to look far into the future, as in calculating retirement dates. Y o u m a y 
still wonder w h y the system developers did not anticipate the problem and just use 
four-digit years as a standard practice. 
O n e answer is in the hardware used at the time. Mainframes were the primary 
computer of the era, a n d they ran most systems. O n these machines, disk storage 
and primary m e m o r y were extremely expensive. Thus, programmers h a d to use 
storage economically, a n d eliminating two "unnecessary" digits was one w a y to do 
it. The decision w a s a conscious one m a d e to save money.
3 
A second answer is in the C O B O L compilers. Using the s a m e type of logic in 
the previous answer, the "ACCEPT...FROM D A T E " c o m m a n d returned the system 
date in Y Y M M D D format. This date format is the default even in the newer C O B O L 
standards.
4 In order to maintain four-digit years, a programmer would have to 
deliberately a d d the extra digits to the year field wherever it w a s created. F r o m a 
programming perspective, the course of least resistance w a s to use just two digits. 
A third answer is that m o s t system developers could not envision these 
programs being around long e n o u g h for the problem to matter. They expected that 
the programs would be replaced long before 2000, and that the n e w systems would 
deal with the problem. However, s o m e 20 a n d even 30 years later, these "legacy" 
systems are still running, a n d the problem faces industry now. 

Look at the program in Figure 19.1 again.'' In paragraph 210-GET-TODAYS-
D A T E (line 107), the A C X E P T statement brings in the current system date and stores 
it in the T O D A Y S - D A T E group item. Paragraph 3 1 0 - C A L C U L A T E - E M P L O Y E E - A G E , 
in line 127, uses the system date information to compute the employee's age by 
using the age calculation introduced in Chapter 8. The code segment below shows 
the date items and the calculations. 
01 EMPLOYEE-DATA. 
05 EMP-NUM 
05 EMP-NAME. 
10 EMP-LAST 
10 EMP-INIT 
05 EMP-BIRTHDATE. 
10 EMP-BIRTH-YR 
10 EMP-BIRTH-M0 
10 EMP-BIRTH-DA 
05 EMP-SERVICE-DATE. 
10 EMP-SERVICE-YR 
10 EMP-SERVICE-MO 
10 EMP-SERVICE-DA 
01 DATA-REMAINS-SW 
88 NO-DATA-REMAINS 
01 INDIVIDUAL-FIELDS. 
05 IND-AGE 
05 IND-SERV-YEARS 
05 IND-RET-DATE. 
10 IND-RET-YR 
10 IND-RET-M0 
10 IND-RET-DA 
01 TODAYS-DATE. 
05 TODAYS-YR 
05 T0DAYS-M0 
05 TODAYS-DA 
310-CALCULATE-EMP-AGE. 
COMPUTE IND-AGE = TODAYS-YR - EMP-BIRTH-YR 
+ (T0DAYS-M0 - EMP-BIRTH-MO) / 12 
As an example, suppose that an employee w a s born on January 1, 1970. O n 
January 1, 2000, this employee will be 30 years old. Following the logic of the 
program, y o u should find that it will calculate that the employee is 70 years old and 
overdue for retirement. (Note: If the I N D - A G E field were defined as signed, the 
employee would be -70.) To test this for yourself, remove the asterisk in line 109 
and put an asterisk in column 7 of line 108. This change overrides setting T O D A Y S -
D A T E from the system date a n d forces it to be January 1,2000. Compile the program 
and check the results. 
In the s a m e way, the program has a problem determining h o w long an 
employee has worked. Notice paragraph 3 3 0 - C A L C U L A T E - E M P - S E R V I C E (line 132). 
This paragraph uses the s a m e type of logic to compute the employee's time in 
service. However, if our employee started work o n January 1, 1990, the algorithm 
PIC X(05). 
PIC X(15). 
PIC X(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC X(02). 
VALUE 'NO'. 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 
PIC 9(02). 

C
h
a
p
t
e
r 
1 9 
— 
The 
Year 
2000 
Problem 
will compute the service years as 90. This result is particularly interesting, since the 
program claims that the employee is only 70 years old. 
The question then becomes, " H o w does one fix the problem?" The answer, in 
one sense, is quite simple. The programmer must change all of the date fields in the 
program to incorporate four digits for the year portion of the date. Each task is very 
simple if there are not too m a n y date fields and they have clearly identified names. 
However, even in this simple program, you can get a feel for the problem. T h e 
programmer must find and change five fields representing years and also correct 
the print format line. In a larger program, the programmer m a y easily miss s o m e 
necessary changes 
The problem becomes m o r e complex because there is m o r e to change than 
just the program. The input records also contain two-digit year fields. Thus, the file 
definition must be modified to m a k e sure that all date group items contain four-
digit years. In addition to changing the file definition, the data in the files must be 
changed as well. Thus, s o m e program has to convert the data to the n e w format. 
While this process is going on, s o m e o n e must convert all other associated programs 
to accept the data in its n e w format, even if those programs do not use the date 
fields directly. Coordination of all this effort is critical to ensure that nothing "drops 
through the cracks." While each change is simple by itself, the implications and 
volume can be overwhelming. 
S o m e companies have thousands of programs affected by the Year 2000 
problem. M a n y organizations m a y have 50 million lines of code to inspect and 
change along with all of the associated files, screens, and reports. Such changes are 
going to be expensive.
6 
Another aspect of the problem occurs w h e n a program has to calculate days and not 
years. M a n y applications need to determine h o w m a n y days have occurred between 
two dates. T o accomplish this task, C O B O L provides a different type of date structure. 
The D A Y format ( Y Y D D D ) describes the sequential n u m b e r of a date within a given 
year. In this structure, the Y Y refers to the years and the D D D refers to the day of the 
year. D e c e m b e r 31 would be 365 in normal years and 366 in leap years. The use of 
the D A Y format m a k e s date arithmetic quite simple as long as the dates involved are 
within the s a m e calendar year. 
01 TWO-DATES. 
05 FIRST-DATE. 
10 FIRST-YEAR 
10 FIRST-DAY 
05 SECOND-DATE 
10 SEC-YEAR 
10 SEC-DAY 
01 DAYS-DIFFERENCE 
MOVE 97234 TO FIRST-DATE. 
MOVE 97100 TO SECOND-DATE. 
SUBTRACT SEC-DAY FROM FIRST-DAY GIVING DAYS-DIFFERENCE. 
In the code fragment above, you can see h o w the D A Y format easily provides 
the n u m b e r of days between two events as long as both dates are in the s a m e year. 
The trick is to determine what to do if the two dates span the year boundary. T h e YY 
portion of the D A Y format does not help m u c h . 
Date AiitfiiYietiC; 
PIC 99. 
PIC 999. 
PIC 99. 
PIC 999. 
PIC 999. 

Date 
Arithmetic 
Since there are not 1,000 days in a year, simple subtraction would leave a gap 
of 636 days between December 31, 1997 (97365) and January 1, 1998 (98001), for 
example. Date calculations crossing the year boundary must take the gap into 
account. The following code shows one w a y of handling the problem. 
MOVE 98030 TO FIRST-DATE. 
MOVE 97300 TO SECOND-DATE. 
IF FIRST-YEAR > SEC-YEAR 
ADD 365 TO FIRST-DAY 
END-IF. 
SUBTRACT SEC-DAY FROM FIRST-DAY GIVING DAYS-DIFFERENCE. 
This code treats the date in the n e w year as a continuation of the old year and 
acts as if 98030 were actually 97395. This technique allows the program to compute 
the difference of 95 days. 
Y o u can see what m a y happen w h e n the millennium changes. If FIRST-YEAR 
is 00 and SEC-YEAR is 99, the IF condition is false and D A Y S - D I F F E R E N C E would be 
270 rather than 95. 
Fortunately, the 1989 extensions to C O B O L provide a better w a y to do date 
arithmetic. These extensions include a n u m b e r of intrinsic functions that do the 
kinds of standard operations available in m a n y other languages and in spreadsheet 
programs. Appendix E, o n C O B O L 2000, covers the 1989 intrinsic functions as well 
as the additional functions proposed for the n e w standard. In the next section, you 
will see h o w to use the calendar functions to perform date arithmetic and correct 
the Year 2000 problem. 
If you have worked with an electronic spreadsheet, you m a y k n o w that the 
spreadsheet does not maintain dates Y Y Y Y M M D D format. Rather, the spreadsheet 
maintains a count of the n u m b e r of days from s o m e arbitrary starting point. In 
EXCEL, for example, the starting point is January 1, 1900. In other words, E X C E L 
treats January 1, 1900, as "Day 1." Each day since January 1,1900 is a consecutively 
n u m b e r e d integer. Date arithmetic is simply a matter of adding to or subtracting 
from these integers. A n y date before the defined starting date is invalid. 
The intrinsic functions of C O B O L allow programmers to use the s a m e type of 
integer date functions as in a spreadsheet. With C O B O L , however, the arbitrary 
starting point is January 1, 1601. This early date allows consideration of more dates 
than E X C E L can handle and should be sufficient for most date applications. O n the 
other hand, the early starting date m e a n s that the integer values of current dates are 
quite large. As an example, January 1, 2000 has an integer value of 145732. This 
m e a n s that programs must allow at least six digits for integer date fields. 
While integer format dates ease the problem of date calculations, h u m a n s 
have trouble reading dates in this format. Therefore, C O B O L has provided functions 
that convert dates from standard formats to integer a n d back. The 1989 extension to 
C O B O L provides six intrinsic calendar functions for programmer use. 
• C U R R E N T - D A T E — R e t u r n s the current system date in Y Y Y Y M M D D format. 
• W H E N - C O M P I L E D — R e t u r n s the compile date in Y Y Y Y M M D D format. 
• INTEGER-OF-DATE—Converts Y Y Y Y M M D D to an integer. 
• INTEGER-OF-DAY—Converts Y Y Y Y D D D to an integer. 

C
h
a
p
t
e
r 
19 
The 
Year 
2000 
Problem 
* DATE-OF-INTEGER—Converts an integer date to Y Y Y Y M M D D format. 
- DAY-OF-INTEGER—Converts an integer date to Y Y Y Y D D D format. 
The syntax for these functions is: 
F U N C T I O N function-name [(argument-1 [, argument-2] ...)] 
The first two functions do not require an argument since they return specific values. 
The last four functions are the routines that allow C O B O L to convert dates to 
integers and vice versa. These functions work similarly. By reviewing h o w the D A T E -
T O - I N T E G E R function works, you can easily see h o w to use the remaining functions. 
The program s h o w n in Figure 19.2 uses I N T E G E R - O F - D A T E . Y o u m a y want to 
compile and test the program (Y2K02.CBL) for yourself. The program interactively 
takes the year, month, and day from the user and returns the integer value of the 
date. Test the program with your birthdate, February 29, 1900, February 29, 2000, 
and any other date you wish. T h e program will return zeros for invalid dates. 
Looking at the program, you should note several points. In line 6, the integer 
field has a length of 6. As stated above, six digits are necessary to hold the integer 
value of current dates. In line 11, D A T E - R D F redefines D A T E - I N P U T because the 
function I N T E G E R - O F - D A T E requires an elementary item as the input parameter. 
In line 21 notice that the keyword " F U N C T I O N " tells C O B O L that "INTEGER-OF-
D A T E " is an intrinsic function and not an identifier. 
The syntax is: 
FUNCTION INTEGER-OF-DATE 
faraument-1) 
The argument is an elementary item in the format Y Y Y Y M M D D , a n d the 
function returns a six-digit number. 
Y o u m a y want to rewrite this program to accept D A Y values from the user and 
use the I N T E G E R - O F - D A Y function to convert the value to an integer. Y o u can also 
write programs to convert an integer to its corresponding D A T E or D A Y by using the 
D A T E - O F I N T E G E R or D A Y - O F - I N T E G E R functions. These problems are included 
in the exercises at the end of the chapter. 
Date arithmetic using the intrinsic functions can be quite straightforward. 
For example: 
COMPUTE NO-OF-DAYS = FUNCTION INTEGER-OF-DATE (DATE-1) 
- FUNCTION INTEGER-OF-DATE (DATE-2). 
This statement converts DATE-1 and DATE-2 to integers a n d subtracts D A T E -
2 from DATE-1 storing the result in N O - O F - D A Y S . 
As another exercise, try modifying the program to accept two days and to 
calculate the difference between them. Y o u m a y also want to write another program 
that accepts a date a n d a n u m b e r of days from the user. The program then would 
calculate and return a n e w date by adding the n u m b e r of days to the integer of the 
original date. 
O n e advantage to using the intrinsic calendar functions is that leap-year 
problems m a y be avoided or at least minimized. 

Date 
Arithmetic 
_ Example of the Integer-of-Date Function 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. 
Y2K02. 
3 
DATA DIVISION. 
4 
WORKING-STORAGE SECTION. 
5 
01 DAT E-DATA. 
6 
05 DATE-INTEGER 
j PIC 9(06). 
7 
05 DATE-INPUT. 
~
~
" 
8 
10 DATE-YEAR 
PIC 9(04). 
9 
10 DATE-MONTH 
PIC 9(02). 
10 
10 DATE-DAY 
PIC 9(02). 
11 
05 DATE-RDF REDEFINES DATE-INPUT 
12 
PIC 9(08). 
13 
05 LAST-DATE-SW 
PIC X. 
14 
88 LAST-DATE 
VALUE 'N' V . 
15 
16 
PROCEDURE DIVISION. 
17 
CONVERT-DATE. 
18 
MOVE 'Y' TO LAST-DATE-SW 
19 
PERFORM GET-DATE 
20 
PERFORM UNTIL LAST-DATE 
.._ 
21 
COMPUTE DATE-INTEGER A FUNCTION 
22 
j INTEGER-OF-DATE (DATE-RDF) 
23 
DISPLAY DATE-INTEGER
 
1
"
" 
24 
DISPLAY 'DO YOU WISH TO CONTINUE (Y OR N)?' 
25 
WITH NO ADVANCING 
26 
ACCEPT LAST-DATE-SW 
27 
IF NOT LAST-DATE 
28 
PERFORM GET-DATE 
29 
END-IF 
30 
END-PERFORM 
31 
STOP RUN 
32 
33 
34 
GET-DATE. 
35 
DISPLAY 'ENTER YEAR IN "YYYY" FORMAT
 1 
36 
WITH NO ADVANCING 
37 
ACCEPT DATE-YEAR 
38 
DISPLAY 'ENTER MONTH IN "MM" FORMAT ' 
39 
WITH NO ADVANCING 
40 
ACCEPT DATE-MONTH 
41 
DISPLAY
 
1 ENTER DAY IN "DD" FORMAT ' 
42 
WITH NO ADVANCING 
43 
ACCEPT DATE-DAY 

Chapter 
19 
The 
Year 
2000 
Problem 
JL&£ip
,*YC3f 
A programmer working o n the Year 2000 problem and looking at date handling in 
G b l e i T t 
COBOL programs w o u l d encounter special routines written to deal with leap years. 
Leap years p o s e special problems, and programs m u s t a c c o u n t for t h e m properly. 
For example, look again at the program in Figure 19.1 a n d e x a m i n e the logic to 
c o m p u t e the employee's retirement date (360-CALCULATE-IND-RET-DATE). Notice 
that the logic assumes that the retirement m o n t h and day will b e the s a m e as the 
birth m o n t h and day. 
MOVE EMP-BIRTH-MO TO IND-RET-MO. 
MOVE EMP-BIRTH-DA TO IND-RET-DA. 
In m o s t cases this a s s u m p t i o n is valid. However, if an e m p l o y e e w a s born o n 
February 29, b y definition h e or she was born in a leap year. A problem occurs 
b e c a u s e February 29 is invalid for the retirement date 65 years later. For example, a 
person born o n February 2 9 , 1 9 4 0 would expect to retire in the year 2005. However, 
2005 is not a leap year, a n d February 29 is invalid. In this case, the e m p l o y e e should 
retire o n M a r c h 1,2005. C o d e must be added to the program to detect the situation 
and m a k e the adjustment. 
Unfortunately, the rules for determining leap years are confusing. Most people 
k n o w that leap years occur w h e n the year value is equally divisible by four. M a n y 
people d o n o t k n o w that years ending in 00 are not leap years. There was n o 
February 29 in 1900; yet, s o m e versions of Microsoft's EXCEL will accept February 
29 as a valid date for 1900. 
Just to m a k e things m o r e difficult, every 400 years February 29 does occur in 
the year ending in 00. So, 1600, 2000, and 2400 are leap years. Consequently, a 
simple leap year routine that simply divides by 4 often works o u t better for the year 
2000 than a m o r e sophisticated routine that makes adjustments for the century 
years. 
COBOL's intrinsic function INTEGER-OF-DATE m a n a g e s leap years properly 
and will return a value of zero w h e n it detects a n invalid date. Therefore, the 
function also provides a w a y to validate dates. By testing for a zero value, the 
program can detect w h e n it has encountered an invalid date. Appropriate routines 
can t h e n be written to deal with the problem. 
H o w c a n these t e c h n i q u e s improve the original program? 
Retif*©II1©rtl 
Figure 19.3 presents a revision
7 of the original retirement program. This revision 
Progi 
Revis 
eliminates the Year 2000 p r o b l e m s and properly deals with leap years. This n e w 
program takes advantage of the 1989 COBOL intrinsic functions and also utilizes a 
date conversion utility program YEAR-TO-YYYY
8 s h o w n in Figure 19.4. This utility 
program simulates the COBOL 2000 intrinsic function of the s a m e n a m e . (Note: In 
order to keep things simple, this version of the program uses the same input file as 
the original.) 
As introduced in the previous section, the CURRENT-DATE intrinsic function 
returns the system date in YYYYMMDD format and can replace the ACCEPT... FROM 
DATE statement. Line 119 u s e s CURRENT-DATE to get the s y s t e m date. More about 
CURRENT-DATE can b e f o u n d in the appendix o n COBOL 2000. 
Line 120 h a s b e e n " c o m m e n t e d out." This line sets the system date to January 
1, 2000. You m a y test the program to see h o w it w o u l d work in the year 2000, by 

Retirement 
Program 
Revisited 
deleting the "*" and recompiling. Be sure to change line 26 of the utility program 
In line 140, the program CALLs the utility program YEAR-TO-YYYY
9 using the 
data group item D A T E - C O N V E R S I O N - D A T A s h o w n beginning in line 44. The utility 
program takes the value of the first argument "CNV-YY," a two-digit year, a n d 
returns "CNV-YEAR," a four-digit year. (Similar CALLs occur in lines 147 and 154.) 
Because the program needs to determine the proper century, a "window" is 
necessary. The w i n d o w is a range of 100 years. The C N V - W I N D O W field serves to 
specify the highest year of the range. YEAR-TO-YYYY adds C N V - W I N D O W to the 
current year determining the latest year the program can return. Thus, if the current 
year is 2000 and C N V - W I N D O W is 15, YEAR-TO-YYYY can return 4 four-digit years 
from 1916 to 2015. With a current year of 2000 and a W I N D O W - M A X set to -15, the 
utility returns four-digit years from 1886 to 1985. 
If years are likely to be equally from the past or the future, the w i n d o w value 
should be set at 50. If all of the years to be converted are expected to be less than the 
current year, the w i n d o w value should be zero. If all dates will reflect the current 
and future years only, the w i n d o w value should be +99. 
In the revised program, lines 159 and following m a n a g e the retirement-date 
problem for the employees born o n February 29. As explained above, an employee 
born o n this date could not retire on February' 29,65 years later. The program takes 
advantage of intrinsic function INTEGER-OF-DATES's ability to validate dates. If 
the function returns a zero, the date proposed is invalid and the program changes 
the date to March 1. This technique is appropriate only if the source data (i.e., the 
birthdate) has been previously validated. 
Revised Retirement Program 
l 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
IDENTIFICATION DIVISION. 
PROGRAM-ID. Y2K03. 
AUTHOR. 
ARTHUR R. BUSS 
ENVIRONMENT DIVISION. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT EMPLOYEE-FILE ASSIGN TO DISK 'EMPSERV.DAT 
ORGANIZATION IS LINE SEQUENTIAL. 
SELECT PRINT-FILE ASSIGN TO PRINTER. 
DATA DIVISION. 
FILE SECTION. 
FD EMPLOYEE-FILE 
RECORD CONTAINS 34 CHARACTERS. 
01 EMPLOYEE-RECORD 
PI 
PIC X(34). 
FD PRINT-FILE 
RECORD CONTAINS 80 CHARACTERS. 
01 PRINT-LINE 
PI 
PIC X(80). 
WORKING-STORAGE SECTION 
01 EMPLOYEE-DATA. 
05 EMP-NUM 
05 EMP-NAME. 
PIC X(05). 

C
h
a
p
t
e
r 
1 9 
The 
Year 
2000 
Problem 
Figure 19.3 
(continued) 
26 
10 EMP-LAST 
PIC X(15). 
27 
10 EMP-INIT 
PIC X(02). 
28 
05 EMP-BIRTHDATE. 
29 
10 EMP-BIRTH-YR 
PIC 9(02). 
30 
10 EMP-BIRTH-MO 
PIC 9(02). 
31 
10 EMP-BIRTH-DA 
PIC 9(02). 
32 
05 EMP-SERVICE-DATE. 
33 
10 EMP-SERVICE-YR 
PIC 9(02). 
34 
10 EMP-SERVICE-MO 
PIC 9(02). 
35 
10 EMP-SERVICE-DA 
PIC 9(02). 
36 
37 
01 DATA-REMAINS-SW 
PICX(02). 
38 
88 NO-DATA-REMAINS 
VALUE 'NO'. 
39 
40 
01 CONSTANTS. 
41 
05 RETIRE-AGE 
PIC 9(02) 
VALUE 65. 
42 
05 YEAR-TO-YYYY 
PIC X(07) 
VALUE 'Y2K04'. 
43 
44 
01 DATE-CONVERSION-DATA. 
45 
05 CNV-YY 
PIC 9(02). 
46 
[_05 CNV-WINDOW 
_PIC S9(02| VALUE ZERO. | ~--
47 
05 CNV-YEAR 
"" ~ 
P K T ( 0 4 ) 
48 
49 
01 INDIVIDUAL-FIELDS. 
50 
05 IND-AGE 
PIC 9(02). 
51 
05 IND-SERV-YEARS 
PIC 9(02). 
52 
05 IND-RET-DATE. 
53 
10 IND-RET-YR 
PIC 9(04). 
54 
10 IND-RET-MO 
PIC 9(02). 
55 
10 IND-RET-DA 
PIC 9(02). 
56 
05 IND-RET-DATE-RDF REDEFINES 
57 
IND-RET-DATE 
PIC 9(08). 
58 
05 IND-RET-INT-OATE 
PIC 9(06). 
59 
60 
01 TODAYS-DATE. 
61 
05 TODAYS-YR 
PIC 9(04). 
62 
05 TODAYS-MO 
PIC 9(02). 
63 
05 TODAYS-DA 
PIC 9(02). 
64 
65 
01 HEADING-LINE-1. 
66 
05 
PIC X(05) 
VALUE SPACES. 
67 
05 
PIC X(10) 
VALUE 
68 
'EMPLOYEE'. 
69 
05 
PIC X(07) 
VALUE SPACES. 
70 
05 
PIC X(10) 
VALUE SPACES. 
71 
05 
PIC X(09) 
VALUE 'SERVICE'. 
72 
05 
PIC X(10) 
VALUE 'RETIREMENT'. 
73 
74 
01 HEADING-LINE-2. 
75 
05 
PIC X(07) 
VALUE SPACES. 
76 
05 
PIC X(14) 
VALUE 'NAME'. 

Retirement 
Program 
Revisited 
(continued) 
11 
05 
PIC X(07) 
VALUE 'INIT'. 
78 
05 
PIC X(06) 
VALUE 'AGE'. 
79 
05 
PIC X(08) 
VALUE 'YEARS'. 
80 
05 
PIC X(10) 
VALUE 'DATE'. 
81 
82 
01 DETAIL-LINE. 
83 
05 
PIC X(05) 
VALUE SPACES. 
84 
05 DET-LAST 
PIC X(15). 
85 
05 
PIC X(02) 
VALUE SPACES. 
86 
05 DET-INIT 
PIC X(02). 
87 
88 
05 
05 DET-AGE 
PIC 
PIC 
X(05) 
9(02). 
VALUE SPACES. 
89 
05 
PIC X(05) 
VALUE SPACES. 
90 
05 DET-SERV-YEARS 
PIC 9(02). 
91 
05 
PIC X(02) 
VALUE SPACES. 
92 
05 DET-RET-DATE. 
93 
10 DET-RET-MO 
n t r 
r i t Z9. 
94 
10 
PIC X 
VALUE • / • • 
95 
10 DET-RET-DA 
PIC Z9. 
96 
10 
PIC X 
VALUE ' / ' • 
97 
j 10 DET-RET-YR 
PIC 9(04). ~~——_ — YYYY Fi 
98 
— YYYY Fi 
99 
PROCEDURE DIVISION. 
100 
100 -PREPARE-RETIREMENT- REPORT. 
101 
OPEN INPUT EMPLOYEE -FILE 
102 
OUTPUT PRINT-FILE 
103 
PERFORM 210-GET-TODAYS-DATE 
104 
PERFORM 230-WRITE-HEADERS 
105 
PERFORM UNTIL NO-DATA-REMAINS 
106 
READ EMPLOYEE-FILE INTO EMPLOYEE-DATA 
107 
AT END 
108 
SET NO-DATA-REMAINS TO TRUE 
109 
NOT AT END 
110 
PERFORM 260-PROCESS-DETAIL 
111 
END-READ 
112 
END-PERFORM 
113 
CLOSE EMPLOYEE-FILE 
114 
PRINT-FILE 
115 
STOP RUN 
116 
117 
118 
210--GET-TODAYS-DATE. 
119 
MOVE FUNCTION CURRENT-DATE TO TODAYS-DATE 
120 
MOVE '20000101' TO TODAYS-DATE | 
121 
122 
123 
230- WRITE-HEADERS. 
124 
WRITE PRINT-LINE FROM HEADING-LINE-1 
125 
AFTER ADVANCING PAGE 
126 
WRITE PRINT-LINE FROM HEADING-LINE-2 
127 
INITIALIZE PRINT-LINE 

C
h
a
p
t
e
r 
1 9 
The 
Year 
2000 
Problem 
me 13,3 
(continued) 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
WRITE PRINT-LINE 
260-PROCESS-DETAIL. 
PERFORM 310-CALCULATE-EMP-AGE 
PERFORM 330-CALCULATE-EMP-SERVICE 
PERFORM 360-CALCULATE-IND-RET-DATE 
PERFORM 390-WRITE-DETAIL-LINE 
310-CALCULATE-EMP-AGE. 
MOVE EMP-BIRTH-YR TO CNV-YY 
CALL YEAR-TO-YYYY USING DATE-CONVERSION-DATA 
COMPUTE IND-AGE = TODAYS-YR - CNV-YEAR 
+ (TODAYS-MO - EMP-BIRTH-MO) / 12 
330-CALCULATE-EMP-SERVICE. 
MOVE EMP-SERVICE-YR TO CNV-YY 
CALL YEAR-TO-YYYY USING DATE-CONVERSION-DATA 
COMPUTE IND-SERV-YEARS = TODAYS-YR - CNV-YEAR 
+ (TODAYS-MO - EMP-SERVICE-MO) / 12 
360-CALCULATE-IND-RET-DATE. 
MOVE EMP-BIRTH-YR TO CNV-YY 
CALL YEAR-TO-YYYY USING DATE-CONVERSION-DATA 
ADD RETIRE-AGE 
TO CNV-YEAR GIVING IND-RET-YR 
MOVE EMP-BIRTH-MO 
TO IND-RET-MO 
MOVE EMP-BIRTH-DA 
TO IND-RET-DA 
* TEST FOR INVALID FEBRUARY 29 RETIREMENT DATE 
COMPUTE IND-RET-INT-DATE = FUNCTION INTEGER-OF-DATE 
(IND-RET-DATE-RDF) 
* WHEN FOUND, SET DATE TO MARCH 1. 
IF IND-RET-INT-DATE = ZERO 
ADD 1 TO IND-RET-MO 
MOVE 1 TO IND-RET-DA 
END-IF 
* WHEN FOUND, SET DATE TO MARCH 1. 
IF IND-RET-INT-DATE = ZERO 
ADD 1 TO IND-RET-MO 
MOVE 1 TO IND-RET-DA 
END-IF 
390-WRITE-DETAIL-LINE. 
MOVE EMP-LAST 
TO 
MOVE EMP-INIT 
TO 
MOVE IND-AGE 
TO 
MOVE IND-SERV-YEARS TO 
MOVE IND-RET-MO 
TO 
MOVE IND-RET-DA 
TO 
MOVE IND-RET-YR 
TO 
WRITE PRINT-LINE 
DET-LAST 
DET-INIT 
DET-AGE 
DET-SERV-YEARS 
DET-RET-MO 
DET-RET-DA 
DET-RET-YR 
FROM DETAIL-LINE 

Summary 
Year Conversion Utility Program 
! 
1 
IDENTIFICATION DIVISION. 
! 
2 
PROGRAM-ID. YEAR-TO-YYYY. 
3 
AUTHOR. 
ARTHUR R. BUSS 
I
 
4 
| 
5 
ENVIRONMENT DIVISION. 
I
 
6 
j 
7 
DATA DIVISION, 
i 
8 
WORKING-STORAGE SECTION. 
! 
9 
01 TEMPORARY-DATA. 
) 
10 
05 WORK-YEAR. 
j 
11 
10 WORK-HIGH-YY 
PIC 9(02). 
J 
12 
10 WORK-LOW-YY 
PIC 9(02). 
I 
13 
05 WORK-YYYY REDEFINES WORK-YEAR 
j 
14 
PIC 9(04). 
! 
15 
LINKAGE SECTION. 
I 
16 
01 LS-CONVERSION-DATA. 
1 
17 
05 LS-YY 
_ PIC 9(02). 
| 
1 8 
I 05 LS-WIND 
PIC S 9 ( 0 2 ) . \ 
I 
19 
^ " S ^ Y Y Y Y T " " ~ ~ " 
j 
20 
10 LS-HIGH-YY 
PIC 9(02). 
| 
21 
10 LS-LOW-YY 
PIC 9(02). 
j 
22 
o i 
nnnrcniioc niuicrnm 
IICTNC I C rnnn/rDCTrvw n AT A 
I
 
2 4 
j 
25 
_M0VEFUNCTION CURRENT-DATE TO WORK-YEAR. 
| 
26 
f*~ 
MOVE 2000 TO WORK-YYYY 
_] 
I 
27 
" 
A D D T S - W I N D " TO WORK-YYYY. "~ 
| 
28 
MOVE WORK-HIGH-YY TO LS-HIGH-YY 
I 
29 
MOVE LS-YY TO LS-LOW-YY 
I 
30 
IF LS-YY > WORK-LOW-YY 
! 
31 
SUBTRACT 1 FROM LS-HIGH-YY 
32 
END-IF 
j 
33 
EXIT PROGRAM 
I 
34 
S I I ^4 M A R Y 
The Year 2000 problem has been known for many years, but has drawn 
attention only recently. As January 1, 2000 gets nearer, interest and alarm 
are also growing. This problem will not go away, and the deadline cannot 
be postponed. 
Making the program corrections is not difficult in itself. The difficulty comes 
because so many programs and files must be changed and tested. 

C
h
a
p
t
e
r 
1 9 
The 
Year 
2000 
Problem 
Information Technology departments must find every occurrence of a date 
and convert each date to YYYY format. 
Two kinds of date formats are involved: the DATE format (YYYYMMDD) and 
the DAY format (YYYYDDD). Both types of dates must be corrected. 
The 1989 COBOL extensions to COBOL 85 provide several intrinsic functions 
that can help in the conversion process. These include CURRENT-DATE, 
INTEGER-OF-DATE, INTEGER-OF-DAY, DATE-OF-INTEGER, and DAY-OF-
INTEGER. COBOL 2000 includes other intrinsic functions, but they may not 
be available in time. 
The Year 2000 is a leap year. All date routines that accommodate leap 
years must be checked to assure that 2000 is handled properly. 
Key 
Words 
and 
Concepts 
Y2K 
Millennium Problem 
Date Arithmetic 
intrinsic Function 
COBOL 
Elements 
FUNCTION 
CURRENT-DATE 
INTEGER-OF-DATE 
INTEGER-OF-DAY 
DATE-OF-INTEGER 
DAY-OF-INTEGER 
F I L L - I 
1. The year 2000 problem resulted from a desire to save on 
and 
2. The correction of the problem (can/cannot) be delayed beyond January 1, 2000. 
3. Businesses have (been/not been) quick to recognize and to solve the problem. 
4. The 1989 extensions to C O B O L 85 have provided n e w capabilities called 
5. INTEGER-TO-DATE converts a(n) . 
format. 
6. DAY-TO-INTEGER converts a(n) 
.to a. 
in 
format to a(n) 
7. The year 2000 (is/is not) a leap year. 
7 R U E 
F A L S tz 
1. The Year 2000 problem has been known for a number of years. 

For 
Further 
Study 
1 
2. With the Year 2000 problem, finding the changes to make is more difficult than the 
actual correction. 
3. Intrinsic functions were a part of the original C O B O L 85 standards. 
4. The decision to eliminate the first two positions of the year in dates was a conscious 
one. 
5. INTEGER-TO-DATE and INTEGER-TO-DAY return the same date format. 
6. The C O B O L statement A C C E P T F R O M D A T E works the same under the 1985 
standards as it will in the 2000 standards. 
7. Business, in general, has been slow to recognize the Year 2000 problem and has to 
scramble to catch up. 
8. Even if companies cannot make all date routine changes by December 31, 1999, 
they should have at least a year before problems show up. 
1. Write a program that accepts the year and day of the year and displays the integer 
value of that year and day. Test the program with year 1600 day 365, year 1601 day 
1, year 1999 day 365, year 2000 day 1, year 2000 day 366, and any other year and 
day number. Invalid dates should return a 0 integer value. 
2. Write a program that accepts a date and a number of days. The program should 
^^rJ ir^r. W^v/r. 
;^^< 
,t rirttr* 
r,r,rl 
rr.li 
trr. f rs ^ ^ . . / rl^ 
+ r. Tt.^ 
r ~ r. r r. rr* 
~ l~ ~ , . i rl ...~~f. 
ctvjci Li ic uayo IKJ u to 
tt iput uaic ai tu i clui i t u tc t tow uaic. t t to 
pi uyt at 11 of iuuiu wui t\ 
with negative numbers for the input number of days. Test the program to make sure 
that it works for dates after January 1, 2000. 
3. Accounts Receivable systems need to be able to detect when an invoice is 
overdue. Write a procedure or a subprogram that calculates the date 90 days prior 
to the current date and compares an invoice date to see whether or not it is 
overdue. Use the commenting technique demonstrated in Y2K01 and Y2K02 to test 
to see how the program would work in the year 2000. 
4. Life insurance rates are partially based on the age of the policyholder. Write a 
procedure that will compute a person's age in years based on their birthdate and 
the current date. Test the program to see whether it will work in the year 2000. 
f C ti 
h I U LJ Y 
This chapter has included Year 2000 problem topics primarily involving C O B O L , 
but the Year 2000 problem has ramifications in other contexts, as well. For example, 
m a n y personal computers will fail w h e n the system clock changes to January 1, 
2000. D O S systems do not recognize dates before January 1, 1980, a n d w h e n 2000 
occurs, m a n y of these systems will assume that 00 must m e a n that the current year 
is 1980. 
The Year 2000 problem is getting increasing press recognition; interest is 
likely to grow as 2000 gets nearer. A n u m b e r of World Wide W e b sites address the 
topic a n d offer s o m e places to use as starting points for further research. 
http://www.yahoo.com/text/Computers_and_Internet/Year__2000_Problem/  
http: //www.wa.gov/di s/2000/y2000.htm 
http: //www.year2000.com/y2 kli nks.html 
http://www.ttuhsc.edu/pages/year2000/y2k_bib.htm 

Chapter 
19 — 
The 
Year 
2000 
Problem 
' The authors recognize that the year 2000 is technically part of the twentieth century, but the problem 
nonetheless is one that begins on January 1,2000. 
2 According to the Gartner Group, quoted in Leon A. Kappelman and James J. Cappel, "A Problem of 
Rational Origin That Requires a Rational Solution," Journal of Systems Management 47, 4 (July-August 
1996): 6, 8. 
3 Kappelman and Cappel contend that the saving in disk space and memory space over the years actually 
compensates for the conversion costs that are now necessary. 
4 COBOL 2000 can return the year in either YY or YYYY form. The format "ACCEPT identifier FROM DATE 
YYYYMMDD" must be used to get four digits. For compatibility's sake, YYMMDD is the default 
format. 
5 You may have noticed the period standing alone at the end of each paragraph. Some programmers use 
this technique to avoid logic errors resulting from misplaced punctuation. The authors have chosen to 
use introduce this practice here. Scope terminators can replace most uses of the period, as explained 
in the Programming Tip Use Scope Terminators in Chapter 7. The ANS standard requires only a period 
at the end of a paragraph. 
" The Gartner Group has estimated that fixing the problem will cost about $1 for each line of code in the 
organization. Many companies have 50 million or more lines of code. Quoted in Kappelman and 
Cappel. 
7Y2K03.CBL. 
«Y2K04.CBL. 
9 In this case "YEAR-TO-YYYY" is the name of an identifier (line 44). The identifier contains the file name 
"y2k04" for the actual program YEAR-TO-YYYY. See Chapter 16, "Subprograms," for further 
information. 

Overview 
The Next Generation of C O B O L 
The Development of Structured Programming 
Terminology 
The Object-Oriented versus Structured Paradigm 
The Student-Look-Up System 
Student*Look-Up Program 
The Registrar Class 
Classes and Inheritance 
ProcessRequests Method 
The StudentDM Class 
StudentDM Instance Definition 
The Student Class 
The Person Class 
The StudentUI Class 
The StudentPRT Class 
Conclusion 
Summary 
Fill-in 
True/False 
Problems 

C
h
a
p
t
e
r 
2 0 
- • 
Object-Oriented 
COBOL 
Programming 
OBJECTIVES 
After reading this chapter you will be able to: 
Discuss the concept of Object-Oriented programming as compared to 
structured programming. 
t 
Describe the structure of classes including the class definition as well as 
the Factory and instance definition. 
I 
Be able to define some major OO concepts including: encapsulation, 
inheritance, persistence, and polymorphism. 
Describe the similarities and differences between the use of Objects and 
the use of subroutines. 
Describe the advantages OO programming has over Structured 
Programming. 
State why OO programming does not invalidate all of the principles of 
Structured Programming. 
O
V
E
R
V
I
E
W 
Objcct-OnentatiOii (OO) has b e c o m e an important n e w way to develop information 
systems. This technique allows for faster d e v e l o p m e n t of systems, reuse of program 
code, and better m a n a g e m e n t of data. OO is n o w available for u s e with COBOL and 
promises to give additional life to this well-established programming language. The 
COBOL 2000 standards define Object-Oriented COBOL, but this standard has not 
b e e n c o m p l e t e d and accepted as yet. However, several vendors including Micro 
Focus have developed their o w n version of OO COBOL and have tried to make their 
versions as close as possible to the proposed standards. We use Micro Focus Personal 
COBOL for W i n d o w s in developing the example system in this chapter. Differences 
in the c o d e presented here and c o d e that m a t c h e s the official standard should be 
minimal. 
The chapter begins with an introduction to the concepts a n d reasons for OO 
COBOL. Next, w e review the strengths and weaknesses of structured programming 
and then make comparisons b e t w e e n the two programming approaches. 
The remaining portion of the chapter s h o w s an OO s y s t e m implementation of 
the Engineering Senior program developed in Figure 1.6. What w a s in o n e program 
b e c o m e s several classes. Each class serves to demonstrate o n e or more OO concepts. 
As w e present each portion of the system, w e attempt to demonstrate the structure 
of OO classes and m e t h o d s to s h o w h o w OO can m a k e system d e v e l o p m e n t and 
m a i n t e n a n c e simple. 
This chapter b y itself is not e n o u g h to train y o u in OO COBOL. You will n e e d 
further study to b e c o m e proficient. W e have included the n a m e s of several n e w 
texts of OO COBOL at the e n d of the chapter. The intent of this chapter is to w h e t 
your appetite to learn m o r e about this exciting and challenging n e w programming 
technique. 

The 
Next 
Generation 
of 
COBOL 
O n e of the m o s t exciting n e w features of the C O B O L 2000 Standard is its 
incorporation of Object-Orientation 
(00) into the language. Even though the 
standard will not b e c o m e official for several years, 0 0 C O B O L is available n o w and 
offered by several vendors including IBM, Hitachi, and Micro Focus. 0 0 C O B O L 
provides the advantages of object-orientation to the business community without 
having to train programmers in n e w languages. In addition, there is no need to 
worry about making these languages work with critical legacy systems. C O B O L , the 
dominant business language, n o w has object-orientated capabilities while retaining 
COBOL's traditional strengths: readability, easy maintenance, powerful file handling, 
and good reporting. 
Previously, 0 0 was limited to such languages as Smalltalk and C++. These 
languages were designed for highly technical applications and for small, rapidly 
developed systems. While there is m u c h to c o m m e n d in these O O languages, they 
do not have the business orientation that is the trademark of C O B O L . For example, 
these languages do not have the powerful file-handling capabilities of C O B O L , nor 
do their data structures work well with the files created by C O B O L legacy systems. 
The syntax of those languages also tends to be rather abstract and hard to read, 
making systems developed in these languages difficult to maintain. 0 0 C O B O L , o n 
the other hand, maintains and even improves C O B O L ' s traditional readability and 
maintainability. 
Other languages, such as Visual BASIC and Delphi, provide a form of 0 0 and 
are relatively easy to use. They also provide a w a y for end users to develop their o w n 
business systems. Yet these languages are not necessarily efficient; nor are systems 
developed in these languages always effective for large applications. In addition, 
systems developed in Visual BASIC or Delphi are not easily maintained by users 
other than the developers. 
Systems developed in 0 0 C O B O L are maintainable and able to interface with 
the programs and files of traditional C O B O L systems. O n the other hand, the C O B O L 
2000 standard provides for the Boolean, integer, and floating-point data types used 
by other c o m m o n languages. Thus, the n e w C O B O L can work with systems developed 
in all computer languages. 
The concept of object-orientation m a y be somewhat threatening to someone 
w h o has devoted m u c h time and effort to learning structured C O B O L . Students, for 
example, m a y be concerned that they have spent m u c h effort learning h o w to write 
structured programs only to have this skill m a d e obsolete by object-orientation. 
These students m a y wonder, " W h y not just learn 0 0 a n d forget 
structured 
programming entirely?" 
In answer to these concerns, w e believe that structured C O B O L will not go 
away soon. Yet O O is coming, and the individual w h o can "speak" both dialects of 
C O B O L will b e c o m e a valuable asset to employers. As businesses begin to adopt 0 0 
C O B O L , they will be seeking out people w h o can help them m a k e the transition. In 
the meantime, structured C O B O L is the predominant dialect and will continue to 
be so for m a n y years. The change m a y be inevitable, but it will be slow. As evidence, 
even today s o m e legacy systems are still in pre-structured programming code. 
A second answer is that object-orientation does not eliminate what is good 
about structured programming. O O promotes a n d even improves u p o n the best 
features of structured programming. Therefore, even though there is m u c h n e w 
about O O C O B O L , a programmer will not be starting from scratch w h e n learning it. 
At this point, m a n y texts attempt to define object-orientation with a series of 
n e w terms and potentially confusing terms such as encapsulation, inheritance, a n d 
polymorphism. This discussion delays the introduction and definition of these a n d 
other terms until they can be demonstrated and defined within the context of a 
functioning system. It is difficult to define object-orientation in a few sentences or 

C
h
a
p
t
e
r 
2 0 
O b j act-011 
ante d C O BOL 
Programming 
by simply introducing and explaining the n e w terms. This entire chapter is, in a 
programming, just as the structured programming was a n e w w a y of thinking about 
programming in its time. 
The Development of Structured Programming 
W h e n computers were n e w and people were still learning h o w to program them, 
there were few guidelines as to what constituted a "good" program. Programming 
was m o r e an art form than a disciplined craft. As a result, the quality of programs 
varied widely. Programming projects were difficult to estimate a n d m a n a g e because 
no one could be sure h o w long a program would take to build. Information systems 
were difficult to build and, w h e n completed, were usually late a n d over budget. In 
m a n y cases, the systems were not completed at all. 
Structured p r o g r a m m i n g w a s developed as a response to this systems 
development crisis. T h e structured approach introduced a philosophy of program 
development and specified "rules" for writing programs. S o m e of these rules were 
as follows: 
• Break programs into short sections of code called modules. Modules were 
usually implemented as C O B O L paragraphs. 
» Build cohesive modules, where each m o d u l e performs a single task. 
• Build loosely coupled modules, where each module is as independent as 
possible from the other modules. 
4 Ensure that each module has a single entry a n d a single exit poini. 
• Avoid the use of G O T O statements. 
The structured techniques brought a n e w degree of order a n d discipline into 
the programming process. A s a result, the quality of programs improved a n d 
programming projects b e c a m e m o r e manageable. Structured programming was a 
great step forward in the evolution of programming. 
Unfortunately, the structured paradigm also introduced n e w problems. 
Structured programs tend to be c u m b e r s o m e because the structuring process 
requires a n elaborate hierarchy of operations a n d control structures. These 
hierarchies a n d structures define the operation of a program, but they also m e a n 
that there is duplication of effort in developing programs. T h e higher levels of 
structured programs tend to follow the s a m e patterns, but must be coded into every 
program. Elaborate structures also tend to m a k e programs rigid and difficult to 
change quickly enough to meet n e w processing requirements. For example, review 
the Tuition Billing program developed in Chapters 4-7 and s h o w n in Figure 7.4. 
Paragraph 100-PREPARE-TUITION-REPORT in line 124 maintains overall 
control of the program's process. This paragraph opens and closes files, and performs 
four other paragraphs. O n e of those paragraphs, 2 6 0 - P R O C E S S - S T U D E N T - R E C O R D , 
does the m a i n processing loop in the program (lines 129 a n d 130). This paragraph, 
in lines 148-152, performs four additional paragraphs. Of these paragraphs, 310-
C O M P U T E - I N D I V T D U A L - B I L L in lines 166-172, performs four m o r e paragraphs 
and makes a computation. Thus, out of the twelve paragraphs in the program, three 
paragraphs are primarily dedicated to controlling the process a n d do little actual 
work. For a simple program, a large part of the code is devoted just to control. 
Figure 3.3 shows the entire hierarchy chart for the program. 
Most structured programs spend a similar proportion of code just controlling 
the process. Unfortunately, these control paragraphs cannot be simply copied from 
one program to another; each program must have its o w n set of control paragraphs. 

The 
Next 
Generation 
of 
COBOL, 
The problems inherent in structured programming are not limited to the 
report. Only three of the twelve paragraphs actually use those lines. Nevertheless, 
any paragraph in the program can access those items and every other data item. 
Structured C O B O L provides no w a y to isolate data items so that only the authorized 
paragraphs can use t h e m or change their values. Thus, if the structured rules are not 
followed, code can be inserted in any paragraph to modify data items. Under these 
circumstances, errors m a y be introduced to the program, and these errors m a y be 
difficult to find. 
The Tuition program is a very good structured program. It just reflects the 
conditions inherent in any structured program. Object-orientation can avoid m a n y 
of these problems. 
Structured programming was a n e w w a y of thinking about programming. This 
n e w paradigm was far superior to the w a y people thought about programs before. 
The superiority of this approach led virtually every c o m p a n y to adopt structured 
programming as the standard. In the process of change, programmers w h o had 
learned to program under the old rules (or lack thereof) had a difficult time making 
the transition to structured programming. They had to learn a n e w w a y to think 
about programming. In the same way, the transition to object-orientation will be 
difficult but worthwhile. 
The object-orientation approach is not a complete negation of the structured 
principles. In fact the most important contributions of structured programming are 
maintained a n d enhanced. For example, O O programs still incorporate the three 
basic control structures—sequence, selection, and iteration—discussed in Chapter 
3. T h e principles of cohesiveness and loose coupling mentioned above are actually 
ctrprifrt-hpnprt i n O O n r n a r a m m i n o O O r p n r f » C A r i t c n " n a r a r i i c r m Q h i f t " i n itQ 
flnnrnarh 
lo the overall design issues, but does not contradict the principles of good 
programming that have been proved in structured programming. 
In order to c o m p a r e the object-oriented a n d structured paradigms, s o m e 
terminology needs to be defined. In learning from a book like this, you should have 
developed a good idea of what a program is. As defined in Chapter 1, a program is a 
translation of an algorithm into a form the computer can understand. Usually that 
algorithm requires the program to input data, process it, and output information. 
In working through problems and assignments, you have h a d to focus o n 
writing individual programs a n d m a y have formed the impression that programs 
are self-sufficient units. Y o u m a y not have thought about where the input files c a m e 
from or where the output goes. In "real-world" applications, a program is usually 
just one part of a system. Systems are collections of software and data units designed 
to work together to perform an application. 
In structured systems, the software units are programs and the data units are 
files. Generally, one program runs at a time, processing input files and data to 
create output files and reports. Each program runs to completion before the next 
program begins. Files provide the link from one program to another a n d allow the 
system to function as a whole. 
Object-oriented systems consist not of files and programs, but rather of objects. 
The proposed C O B O L 2000 standard defines an object as "an entity that has a 
unique identity, specific data values, and specific behaviors or program code." In 
other words, objects combine the features of files and programs. Objects not only 
store data, but process it as well. Within an O O system, objects pass data directly 
and interactively to each other without the use of files. Unlike programs that run 

C
h
a
p
t
e
r 
2 0 
Object 
- Orient 
e d 
C O B O L 
Programming 
one at a time, m a n y objects m a y be active at the same time. Objects are linked by 
The messages are requests for the receiving object to perform s o m e action 
a n d often to return the results of that action. T h e messages request the objects to 
perform a method. 
T h e C O B O L 2000 standard defines a m e t h o d as "procedural 
code that defines a specific function... A m e t h o d m a y be thought of as a module or 
subroutine." Objects can contain m a n y methods, with each m e t h o d designed to 
accomplish a particular function. W h e n one object requests (sends a message to) 
another object to perform a function, the process is called invoking 
a method. 
In summary, systems are m a d e u p of numerous units that carry out the 
purposes of the system. In structured systems, these units are programs a n d files. In 
0 0 systems, these units are objects. Objects contain both data and methods. M a n y 
objects m a y be active at one time, a n d they communicate with each other through 
messages. Messages are requests for other objects to perform a method. 
The Object-Oriented versus Structured Paradigm 
W h e n developing an O O system, the designer tries to identify and represent the 
nouns of the system. T h e nouns c o m e from the n a m e s of entities necessary to 
accomplish the system's purpose such as Student, Employee, or Invoice. These 
entities b e c o m e candidates for classes in the system. In O O terminology, a class is 
the generic definition of an object. T h e term instance is used to refer to a specific 
occurrence of an object. Most authors use "instance" and "object" interchangeably. 
F r o m this point o n w e use the term "class" to refer to the generic model a n d 
"instance" or "object" to refer to a specific example. 
\ „ r\r\ 
A—4 — „— 
l 
; „ 
; J „ _ i ; t . — A —
c 
*t 
1 „ „ 
.u . 
: c * u _ 
na yjyj ucaigiicia ucgm tu luciitny emu icmic inc uaasca, uicy aucuny uic types 
of data belonging to a n d the behaviors associated with the class. As additional 
requirements b e c o m e apparent, additional data items a n d methods m a y be added. 
By looking at the nouns, the O O designer can determine h o w a class should behave 
in general without regard to any specific system. Thus, these general class behaviors 
or methods can be used by m a n y systems. W h e n system-specific requirements 
dictate the need for additional methods or data items, they can be added to the 
class without affecting the previously defined data items a n d methods in the class. 
B y contrast, the structured approach focuses o n the verbs of the system. Verbs 
identify the things a system must do. As each activity of the system is identified, the 
designer specifies a program or programs to carry it out. These programs are custom 
designed for their specific system. 
O O systems are m o r e flexible than structured systems. By placing procedures 
in methods contained in classes rather than programs, O O allows c o m m o n routines 
to be written just once. A n y system that uses the class can use any of its methods. 
Methods are developed just once, but used in a variety of situations. T h e need for 
duplicate coding is reduced a n d additional functionality can be added to systems 
with m i n i m u m effort. 
Methods, once developed a n d tested, can be reused with confidence and a 
m i n i m u m of testing. In addition, if s o m e change is necessary in the method, the 
change only has to be m a d e only once in the class. Every system using that class 
then automatically uses the revised method. 
After a class is developed, it becomes a building block available for use in 
future systems. W h e n the developers of a n e w system determine the need for a 
class, they can investigate to see if it is already available. If the n e w system requires 
n e w functionality from a class, n e w methods can be added to the class without 
affecting any of the old methods. As a result, classes b e c o m e more useful a n d 
powerful as n e w functions are defined a n d implemented as methods. T h e s a m e 
cannot be said for structured systems a n d programs. 

The 
Next 
Generation 
of 
COBOL 
Structured systems consist of custom-designed programs. Even w h e n c o m m o n 
routines occur, they cannot easily be copied into other programs, nor can other 
systems just use part of a structured program. As a result, each n e w program is built 
from scratch with little use of previously developed routines. Even if the routines 
can be copied into n e w programs, it is almost impossible to update all of the copies 
should s o m e change need to be made. 
As an example, suppose that there is a need for a Student Enrollment system. 
A structured analysis would look at the verbs and might determine that the system 
needs to: 
* Generate a course schedule. 
* Enroll students. 
* Prepare course rosters. 
» Prepare student schedules. 
The structured approach would then design one or more programs to perform 
each of these activities. Files would be developed to link the processes together so 
that the system could perform as a whole. Even though preparing course rosters 
and preparing student schedules are very similar processes, it is unlikely that any of 
the programs would be reused or that routines would be copied from one program 
to another. 
The OO approach to a Student Enrollment system would focus o n the entities 
w h o participate in the system. The analysis then might c o m e up with classes such as: 
» Student 
* Advisor 
* Registrar 
* Course 
F r o m this analysis, the O O designer would determine the functions and the 
data that each of these should handle. In producing the actual Course Rosters and 
the Student Schedules, the system would use methods from both the Student class 
and the Course class. S o m e of the same methods could be used in performing each 
function. In addition, most of these classes developed for Student Enrollment might 
be used in other systems such as Tuition Billing, Advising, or Grade Reporting. 
Therefore, these classes are not useful just for the Student Enrollment system, but 
could be building blocks for other systems as well. 
Another difference between O O and structured systems is in h o w they actually 
operate. Programs run in a standalone m o d e with one program operating at a time. 
Linkages between programs are maintained by passing files. B y contrast, m a n y 
objects m a y be functioning interactively and linkages are maintained through 
messages. Objects, unlike programs, are aware of other objects. Since messages, 
rather than files, provide the linkage between objects, files per se are not necessary 
in an OO system except to store data while the system is not running. 
Objects exist in the m e m o r y of the computer only while the system is operating. 
If there were no w a y to store the objects, data would be lost w h e n the system shut 
d o w n . Therefore, O O systems store object data in files until the system starts again. 
These files provide persistence between system runs. A n O O system requires special 
classes called data managers to ensure that the data "persists" from one run of the 
system to another. 

C
h
a
p
t
e
r 
2 0 
Object-Oriented 
COBOL 
Programming 
To illustrate the concepts of Object-Oriented COBOL a n d t h e differences from 
structured programming, this chapter uses a 0 0 version of the Engineering Senior 
program presented in Chapter 2.
1 The design of the system is s h o w n in Figure 20.1. 
While the original program worked only for Engineering Students with more than 
100 credit hours, this version has added functionality, allowing the user to specify a 
m i n i m u m n u m b e r of credit hours required (rather than 100) and any major, not 
just engineering. For the purpose of this chapter the OO version is called the Student-
Look-Up system. 
P R O G R A M M I N G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
System Name: 
Student-Look-Up system (Object Version of Engineering Senior program) 
Narrative: 
This system is an Object-Oriented Enhancement of the Engineering Senior program 
presented in Chapter 1. The system allows the user to interactively enter a major course 
of study and a minimum number of credits earned. The system then produces a report 
listing all students meeting both the major and minimum credit-hours qualifications. 
Input File(s): 
STUDENT-FILE 
Input Record Layout: 
See Figure 1.3a. 
Test Data: 
See Figure 1.3b. 
Report Layout: 
Screen Layout: 
See Figure 1.3c. 
See Figure 20.8. 
Processing Requirements: 1. Print a heading line. 
2. Prompt the user for a major. 
3. Prompt the user for the minimum number of credit hours. 
4. Read a file of student records. 
5. For every record, determine whether that student has the major specified in step 2 and 
has completed more than the number of hours specified in step 3. 
6. Print the name of every student who satisfies the requirements in item 5. Single-space 
the output. 
7. At the end of the Report, print a line that says "* * * End of Report * * *." 
Look at the design of the Student Look-Up system in Figure 20.1. A system of 
six classes replaces the original program. The figure does not s h o w a driver program 
u s e d to initiate the system. Viewing the diagram, you m a y feel that creating six 
classes and a driver program h a s to be m o r e c o m p l e x than developing just o n e 
program. To perform this very simple application, y o u m a y b e right. However, if 
you look at the classes as potential building blocks for other systems, y o u can s e e 
that s o m e extra effort here could m e a n less effort over the long run. The Engineering 
Senior program can d o o n e function and o n e function only. 
The trick to developing OO systems is not in implementing the classes, but in 
knowing h o w to partition out the data and procedures to the various classes. One 
accomplishes this task through Object-Oriented Analysis and Design. A M I discussion of 
that topic is beyond the scope of this chapter, but it does need to be mentioned briefly. 

The 
Student• 
Look•Up 
System 
Person 
Name 
GetNa 
Popu!« 
me 
iteName 
Registrar 
ProcessRequests 
1-n 
Student 
StudentMajor 
HoursCompleted 
Pnniiiatogti ids«t 
StudentUI 
GetParameters 
DispiayHoursRequest 
DisplayMajorRequest 
StudentPRT 
OpenPrinter 
WriteHeader 
WriteDetail 
FinalizeReport 
StudentDM 
GetStudent 
CreateStudent 
ReadRecord 
As stated before, O O analysis and design focuses o n the nouns used to describe 
the systems. These nouns often can identify the system classes. For example, in the 
Student Look-Up system, Registrar and Student are obvious classes. 
After identifying the class, the analyst asks three questions about each class:
2 
* W h a t does it know? W h a t data does it o w n ? 
* W h o m does it k n o w ? W h a t other classes are necessary for it to accomplish 
its work? 
* W h a t does it do? W h a t functions does it need to perform? 
After answering these questions, the analyst can develop a model of the system 
such as seen in Figure 20.1. The double boxes with rounded corners represent 
classes. Each class symbol is divided into three sections. T h e top section contains 
the class n a m e . T h e middle section contains the n a m e s for data items o w n e d by the 
class a n d the bottom section contains the n a m e s of the methods the class can 
perform. T h e lines represent the routes messages can take within the system a n d 
show the answer to the question, " W h o m does it know?" The indicators at either 
end of the line s h o w h o w m a n y instances of another class an instance can k n o w at 
one time. For example, a Student can k n o w only one Registrar object, while the 
Registrar object can k n o w from 1 to n instances of Student. 
Special relationships between classes are s h o w n by symbols o n the connecting 
lines. T h e half-circle between Person and Student m e a n s that Student inherits from 
Person. W e will discuss the concept of inheritance later. The triangle between 
Registrar and Student m e a n s that Student is contained in Registrar. That is, the 
Registrar is responsible for managing the Student class. This concept is not important 
to understanding h o w this system works. 
--. -~ 
' . Student-Look-Up System Design 

Chapter 
20 
Object-Oriented 
COBOL 
Programming 
S o m e of the classes represent the problem 
domain 
of the system—the purpose 
of the system. These classes do the primary work of the system. However, just as the 
functional workers in an office cannot operate efficiently without support a n d 
administrative workers such as secretaries, mailroom staff, file clerks, a n d the like, 
support classes are needed as well. S o m e of the support classes include: 
* User Interface 
Classes. Classes that handle the interactive screens a n d 
windows allowing the users to interact with the system. User interfaces also 
involve the printing of reports for the user a n d production of external 
documents such as invoices a n d purchase orders. 
• System Interaction 
Classes. These classes manage the interfaces to other systems. 
These other systems m a y be object-oriented or traditional legacy systems. System 
Interaction classes would handle files passed between the systems, access to 
centralized data bases or telecommunications between systems. 
* Data Management 
Classes. These classes administer the storage a n d 
retrieval of data used by Problem D o m a i n instances. Data M a n a g e m e n t 
classes are necessary to maintain the persistence of objects. 
• Drivers. These programs are not classes at all. They are programs developed 
to initiate a n d test objects. Driver programs often are temporary in nature 
and allow the system developer to see h o w a class will behave before 
incorporating it into the system. Most O O systems include a driver program 
to start the system. 
Table 20.1 shows the classes of the Student-Look-Up system, the types of class 
they are and c o m m e n t s about the functions performed. 
The starting point for the system is the Student-Look-Up program. Even though 
Student-Look-Up is the driver program for the system a n d not a class, it introduces 
s o m e of the elements of object-orientation. 
S t u d e n t - L o o k - U p P r o g r a m 
Student-Look-Up is the program s h o w n in Figure 20.2 a n d m a y be one of the 
shortest C O B O L programs you have ever seen. The program cannot really be called 
structured because it has only three statements in lines 19-21 of the Procedure Division. 
There are several other features in this program that m a y s e e m strange. T h e most 
obvious difference is the use of uppercase and lowercase in the source code. C O B O L 85 
has always allowed this practice, but acceptance of this practice has been slow. W e have 
used mixed-cases code to symbolize a n e w age of C O B O L .
3 T h e Programming Tip 
shows all of the coding conventions w e use in this chapter. 
in'C 
, Student-Look-Up System Driver and Classes 
StudentPRT 
StudentUI 
Person 
StudentDM 
Student 
Student-
Registrar 
User interface 
User Interface 
Data Management 
Problem Domain 
Problem Domain 
Problem Domain 
Driver 
Initiates the system and creates Ihe Registrar object 
Maintains overall control of the system, creates the utility objects: 
StudentUI, StudentDM, and StudentPRT. Interacts with Student to get 
the student name. 
Maintains the Student data. Can produce the student's name, credit 
hours taken and major. 
Parent Class to Student. Maintains the student name information. 
Controls the processing of the Student File and creates Student 
Instances based on requested parameters. 
Controls the production of the report. 
Controls the interactive dialog with the user of the system. 

The 
Student-Look 
Up 
System 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
P r o g r a m N a m e : 
Student-Look-Up 
Narrative: 
This program is the primary driver program for the system. The program creates the 
Registrar object and initiates the system to process a request for a listing of students 
based on user input specifications. 
Objects Created: 
Registrar 
Objects Referenced: 
Registrar 
P r o c e s s i n g R e q u i r e m e n t s : 1. Create Registrar object. 
2. Invoke Registrar method ProcessRequest. 
10.2 Student Look-Up Program 
Jset mfoo 
Identification Division. 
Program-id. Student-Look-Up. 
Author. 
Arthur R. Buss. 
Environment Division. 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
jObject Section. 
JC1ass-control. 
Registrar is Class 'Register' 
Data Division. 
Working-storage Section. 
Hand!es 
01 
object reference. 
05 theRegHandle. 
Procedure Division. 
— -
j invokejRegistrar 'New' returning theRegHandle 
invoke theRegHandle 'ProcessRequest' 
STOP RUN 

C
h
a
p
t
e
r 
2 0 
— 
Object-Oriented 
COBOL 
Programming 
P R O G R A M M I N G 
T I P 
OO COBOL is so new that there are not well-established ways for coding classes. The following are the 
conventions for this book. 
* 
Division and section names are capitalized. For example, Procedure Division and Working-storage 
Section. 
® 
Data item name words are capitalized and separated by hyphens. For example, Student-Name. 
t : 
Linkage-storage data names are prefixed by 1 s-. 
Method name words are capitalized, but not separated by hyphens. For example, ProcessRequests. 
* 
Handle names do not have an initial capital letter, but each succeeding word is capitalized. The 
words are not separated. For example: theRegHandle. 
« 
COBOL reserved words other than division and section titles are lowercase. 
* 
For visibility purposes, FACTORY, OBJECT, and STOP RUN are uppercase. 
« 
End statements for methods, objects, and classes are capitalized. For example, End Method, End 
Object, and End Class. 
* 
Division titles are omitted, except where necessary or for clarity. In this system, Student-Look-Up 
includes all four division titles. Identification Division is not included in any class definition. 
Environment Division and Data Division are included only in the classes that handle file processing. 
Procedure Division is included in all classes. 
« 
Within classes, all methods are separated by a blank line. 
* 
To ensure that method names are seen as being part of the method, Method-id statements are not 
separated from the next line. 
When a method Procedure Division has using or returning clauses, each clause is separated 
onto a separate line and indented. For example: 
Procedure Division 
using 
1s-Stu-Parameters 
returning ls-theStuHandle. 
« 
Procedure Division code is separated from the division title by one line. 
« 
In Procedure Division code, only one period is allowed. The period must be after the last line of 
code and alone on a line. End scope terminators are always used. 
Line 1, starting in c o l u m n 7, contains the compiler directive: $set mfoo. This 
compiler directive tells C O B O L that the program is involved in a n O O system and 
allows the program to use several O O reserved words. 
Object 
Section in line 8 is n e w to the Environment Division and is similar in 
purpose to the Input-Output Section of traditional C O B O L . T h e Object Section 
defines the interface to classes used in the system. 
Class-control 
is the m a i n paragraph within the Object Section a n d relates 
each class to a template file for that class. Template files contain class definitions. 
W h e n the program or class is compiled, these definitions are linked to the program. 
For example, "Register.cbl" is the template for the Registrar class. W h e n Student-
Look-Up is compiled, the definition of Registrar becomes part of the executable 
code. Whenever the program uses the identifier "Registrar," C O B O L refers to that 
class definition. 
The program contains no Input-Output section. Since the classes do all of the 
file processing, the section is not needed a n d is omitted. 
The Working-Storage Section contains two n e w features. 
1. A n e w data type, object 
reference. 
2. Data type usage specified at the group item level. 

The 
Student- 
Loo k • U p S y s tern 
O O C O B O L uses object reference data as pointers to system objects. In O O 
C O B O L , object pointers are generally called handles. T h e 05 level item 
"theRegHandle," in line 16, is the handle to the Registrar object. 
C O B O L 2000 allows the data usage to be established at the group item level. 
All elementary items assume the data usage of the group item. In line 15, the 01 level 
item Handles has object reference usage and therefore so does theRegHandle. 
The Procedure Division of the Student Look-Up Driver program has only two 
statements other than STOP RUN. Both statements use a n e w C O B O L verb i nvoke. 
Invoke is similar to a C A L L in that it addresses programs outside of the current 
program and turns control over to that procedure. The invoke verb also can pass 
parameters or arguments to and from the invoked procedure. However, a C A L L 
turns over control to an entire C O B O L program while invoke only references a 
m e t h o d within an object. 
Syntax of Invoke 
INVOKE object-name { literal-1 | data-name-1 } 
[USING {data-name-2}... 
[RETURNING data-name-3 ] ] 
Figure 20.3 shows the syntax of the i nvoke verb. The object n a m e specifies the 
object containing the desired method. Literal-1 or data-name-1 is the message 
(name of the method) to be passed to the object. Any data items to be passed to the 
object are preceded by using. The data item to be returned must be preceded by 
returni ng. Note that multiple data items can be passed to the method but returni ng 
allows only one data item. The invoke verb requires that the n a m e d data items be at 
the 01 level, but entire data groups can be passed by using a 01 level group item. If 
more than one parameter must be returned, all of the parameters should be 
elementary items under a single 01 level group item. Arrays can be passed in either 
direction as long as they are contained within a 01 level group item. 
The first invoke addresses the Registrar class and passes the message "New." 
New is a generic message required to create a n e w instance or occurrence of a class. 
This process is called instantiation. Hence, to instantiate a class m e a n s to create a 
n e w instance of the class. For example, in the Student Look-Up system, only one 
Registrar instance is required. Universities only have one Registrar office, and this 
instance needs to emulate the functions of that office. However, m a n y students 
attend the university and one would expect the system to instantiate numerous 
instances of the Student class. 
W h e n instantiating a class, the object n a m e in the i nvoke statement is the 
n a m e of the class. The New m e t h o d instantiates the instance returns its handle. In 
this case, the handle is called "theRegHandle." 
Look again at Figure 20.2 and line 20. The second i nvoke uses theRegHandle 
to request the instance m e t h o d , "ProcessRequest." T h e statement invokes 
theRegHandle instead of Registrar because it points to the instance of the class and 
its methods are n o w available. ProcessRequest requires no parameters to be passed. 
U p o n completion, ProcessRequest returns control to the driver program. The driver 
then stops the run. 
After STOP RUN there is a period on a line by itself. A n e w standard is emerging in 
C O B O L programming to minimize use of the period. M a n y programmers will use only 
one period at the end of paragraph and place the period on a separate line for the sake 
of clarity. End statements replace periods whenever possible. Since C O B O L requires 
that each paragraph end with a period, it is placed on a separate line for visibility. 
In examining the driver program, you have encountered several important 
O O topics without even looking at a class. These topics include Object Section and 

C
h
a
p
t
e
r 
2 0 
Object-Oriented 
COBOL 
Programming 
Class Name: 
Class Type: 
Narrative: 
Objects Created: 
Objects Referenced: 
Factory Methods: 
Instance Methods: 
Narrative: 
Processing: 
Class-control, the Object Reference data type, handles, instantiation, methods, 
messages, a n d the Invoke verb. N o w , w e will look at the Registrar class to see h o w 
these and other concepts are used in a class. 
Along with the discussion of each class, you will find the programming specifications 
of that class. Since classes are different from programs, y o u will notice several n e w 
entries. First, w e use Class N a m e rather than Program N a m e a n d have a n e w entry 
to s h o w what type of class this is. Next, w e describe the purpose of the class in the 
Narrative. T h e Narrative is followed by the objects created a n d referenced. W e 
specify objects rather than classes because these are actual instances of classes that 
are created or referenced. Finally, w e specify the methods included in the class. 
These methods include both factory methods a n d instance methods. 
R A M M I N G 
S P E C I F I C A T I O N S 
Registrar 
Problem Domain Object 
This object represents the role of a registrar department. 
StudentDBI 
StudentPRT 
StudentUI 
StudentDBI 
StudentPRT 
StudentUI 
Student 
None 
ProcessRequests 
This method controls the main processing of the system. 
1. Create the StudentUI objects. 
2. Get student requirements from StudentUI. 
3. Create the StudentDBI and StudentPRT objects. 
4. Get an instance of a Student from StudentDBI that meets the requirements in step 2. 
5. Get the student name from Student. 
6. Send the Student name to StudentPRT to be printed. 
7. Destroy the current Student instance. 
T h e Registrar object contains the attributes a n d behaviors that are needed to 
represent the university registrar's role in the Student-Look-Up Billing System. The 
registrar k n o w s about student data a n d provides this data o n request. T h e Registrar 
object, therefore, manages students a n d can provide data about them. 

The 
Student 
- Look 
Up 
Sys t e m 
Class Definition of Registrar 
1 
$set mfoo 
2 
i Class-id.,- Registrar 
3 
inherits from Base , i 
5 
Author. 
Arthur R. Buss 
\_ 
6 
7 
Object Section. 
! 
8 
Class-control. 
9 
Base is Class 'base' 
i 
10 
Registrar is Class 'register' 
11 
StudentDM is Class 'senDBI' 
12 
StudentPRT is Class 'senPrt' 
13 
StudentUI is Class 'senui' 
14 
15 
16 
OBJECT.
 1 
17 
18 
; Object-storage Section. 
19 
I 01 Handles 
object reference. 
20
 
1 
0 5 theDMHandle. 
21 
05 thePRTHandle. j . . .. 
22 
0 5 theUIHandle. 
23 
05 theStuHandle. 
24 
._ 
. 
' 
i
_
'
y
~
p
_
"
Z 
25 
: Method-id. 'ProcessRequest'. 
26
 
1 Local-storage Section. 
27
 
; 01 Student-Parameters. 
28 
05 Stu-Min-Hours 
pic 9(03) 
29 
05 Stu-Major 
pic X(20) 
30 
31 
01 Student-Data. 
32 
05 Stu-Name 
pic X(25) 
33 
i 
34 
: Procedure Division. 
35 
36 
invoke StudentUI 'New' 
37 
returning theUIHandle 
38 
[ 
invoke theUIHandle 'GetParameters' 
39 
[ 
returning Student-Parameters 
40 
invoke StudentPRT 'New' 
41 
' 
returning thePRTHandle 
42 
invoke StudentDM 'New' 
43 
returning theDMHandle 
44 
invoke theDMHandle 'GetStudent' ~ 
45 
using Student-Parameters 
46 
returning theStuHandle 
47 
perform until theStuHandle = Null--
48 
invoke theStuHandle 'GetName' 
49 
returning Stu-Name 
50 
invoke thePRTHandle 'WriteDetaiT 
51 
using Stu-Name 
52 
invoke theStuHandle 'Finalize' 

Chapter 
20 
Object-Oriented 
COBOL 
Programming 
(continued) 
returning theStuHandle 
| 
invoke theDMHandie 'GetStudent' 
using Student-Parameters 
[ 
returning theStuHandle 
f 
end-perform 
| 
invoke thePRTHandle 'FinalizeReport'-X 
j 
i 
[JEnd Method 'ProcessRequest'. 
J 
End Object. 
End Class Registrar. 
The class definition can be m a d e u p of three parts: 
• Class identification area that defines the class n a m e and the linkages of the 
class definition files for the other classes associated with this one. 
• The Factory area. The Factory is a special instance of the class that contains 
methods and data used for managing all other instances of the class. 
I™
1"!"* <c* 
lr\ i o«"»irtr I n p t ' i n i ^ o o»-*io T V - n o »\ 'i t-i /-v-f 
o ir» r» t\ 
* i t s \ »-» ri / A ^ * v » - 1 , , > 4-1-» ,\ 
V i * j v i KJI n i o t a i i ^ ^ tutv^ti. l i n o j ^ t i i l KJi 
V / i u a o u ^ i u i i u u n 
L i l t 
data formats and methods available to each instance. 
Y o u should notice several differences between the class identification area 
and the start of a traditional program. This example contains no Identification 
Division statement a n d n o Program-id statement. T h e Identification Division 
statement has been left out since it is not required by C O B O L 2000. The statement 
Class-id is the equivalent of the Program-id statement but includes a clause that 
says "inherits from Base." This clause defines the "inheritance" of the class. The 
Registrar class is a "child" of Base. 
As in the Student-Look-Up program, the class identification area contains an 
Object Section and Class-control. O n e of the questions that m u s t be answered for a 
class is, " W h o m does it know?" T h e Class-control paragraph defines part of the 
answer. Since Registrar is the key class for this system, it needs to k n o w about and 
create several other classes. Registrar needs to k n o w about Base because it is the 
parent class, it needs to k n o w about itself, and, since it instantiates StudentDBI, 
StudentPRT, and StudentUI, all of these are defined in the Class-control paragraph. 
Registrar also needs to k n o w Student, but this class does not have to be defined here 
since Registrar does not instantiate it. 
The Factory definition area follows the Class-control section. This area starts 
with the keyword F A C T O R Y . T h e Factory is a special instance of the class a n d 
contains generic data and methods needed to m a n a g e the regular instances. Registrar 
requires no special data or methods, and therefore Factory does not have to be 
specified. 
The definition of the instance in Figure 20.4 begins with the keyword OBJECT in 
line 16. As mentioned before, in defining a class the designer needs to ask: 
• W h a t does it know? 
• W h o m does it know? 
W h a t does it do? 

The 
Student-Look-Up 
System 
To answer the first question, in the Student-Look-Up system the Registrar 
does not have to have any special knowledge. If the class were to be used with s o m e 
other system it is likely that s o m e d a t a items would have to be defined and stored in 
the Object-storage Section in lines 18-23. 
The Object-storage Section is similar to the Working-storage Section in a 
traditional program and contains data available to any instance method. Y o u will 
see later that methods can o w n their o w n data as well. N o other program, object, or 
even the Factory of the current object can use data in the Object-storage Section 
except through the use of an instance method. 
The Object-storage Section also contains a partial answer to the question, 
" W h o m does it know?" The group item Handles in lines 19-23 contains the pointers 
to the objects the Registrar needs to know. 
The answer to "What does it do?" is defined by the methods. For Registrar, 
there is only one method, ProcessRequests. This method is discussed below. 
Look again at the Class-id paragraph in lines 2-3. Inheritance is an important O O 
concept. By stating that Registrar inherits from Base, the clause is saying that Base is 
the parent class and all of the methods in Base are available to Registrar. Base is a 
special class provided by Micro Focus as part of the O O C O B O L system. The Base 
class serves as a template for all other classes and has specialized methods for the 
m a n a g e m e n t of all classes. 
For an example of h o w inheritance works, consider the m e t h o d New. New is 
invoked before an instance exists. New also addresses the Class-id rather than an 
instance handle. The Factory contains specialized methods that allow m a n a g e m e n t 
of the instances. The m e t h o d New creates the instance, and therefore it cannot be 
contained in an instance. New is therefore a factory 
method. 
Y o u should notice that the Registrar Class definition in Figure 20.4 does not 
specify a Factory or its methods. T h e n where is the m e t h o d New? New is a factory 
m e t h o d in Base. Whenever a class is instantiated, the parent class is also instantiated 
and is available to the child class. Because Registrar inherits from Base, Registrar 
can perform New as if it were its o w n method. Thus, w h e n Student-Look-Up invokes 
New, Registrar receives the message and passes it o n to Base. Base then creates the 
instance of Registrar. T h e invoking program did not need to k n o w anything about 
Base, but just asks the Registrar class to create an instance of Registrar. By taking 
advantage of inheritance, the object programmer does not have to write a method 
to create an instance for every class. This example is just one w a y inheritance works 
to reuse code; other ways are discussed below. 
There is one more point to m a k e about factory methods and instance methods. 
Even though the Factory and instances are parts of the same class, methods belong 
to either the Factoiy or the instances. If the Factory needs to invoke an instance 
method, the i nvoke must specify the instance handle. Instance methods must use 
the class n a m e (for example, Registrar) to invoke a Factory method. O O C O B O L 
maintains a strict separation between the two types of methods. 
The ProcessRequest m e t h o d begins with the Method-id paragraph in line 25. Every 
m e t h o d begins with a Method-id and ends with an End Method. These statements 
provide the method's boundaries. A m e t h o d m a y have its o w n Data Division and 
Procedure Division. The Data Division is optional, and, w h e n used, words "Data 
Division," do not have to be specified. Data Division entries contain data used only 
by that method. They are stored in one of three sections. 

C
h
a
p
t
e
r 
2 0 
Object-Oriented 
COBOL 
Programming 
a Working-storage Section—Working storage data are static. That is, these 
data remain from one invocation of the m e t h o d to the next. A n y data that 
need to be available w h e n the m e t h o d is invoked a n d to be available each 
time the m e t h o d is invoked should be in the Working-storage Section. Data 
requiring a val ue clause must be defined in working storage. 
» Local-storage Section—Local storage contains data for the m e t h o d a n d is re­
initialized each time the m e t h o d is invoked. If val ue clauses are specified, 
they are ignored and treated as comments. Local storage data is available 
only for the current invocation of the method. 
* Linkage Section—The linkage section works in connection with the 
method's Procedure Division and passes data to a n d from the method. 
ProcessRequest uses only the Local-Storage Section starting in line 26. The 
m e t h o d keeps the m i n i m u m n u m b e r of credit hours a n d the major for the request. 
T h e Local-Storage Section also contains the student n a m e once it is determined. 
Not all methods require their o w n Data Division. Often, methods will use the 
Object-storage Section defined at the instance level. In this case, with only one 
method, ProcessRequest could have used either the Object-storage Section for the 
entire instance or the method's Local-Storage Section. Regardless of where the data 
are stored, all methods need to have a Procedure Division. 
The Procedure Division in line 34 begins by creating the StudentUI object and 
requesting it to get the parameters necessary to process the system. T h e n 
ProcessRequest creates the StudentDM and Student PRT objects. The next i nvoke 
goes to t h e D M H a n d l e to "getStudent." This i nvoke passes the parameters received 
from StudentUI a n d asks that the StudentDM provide the handle of a Student 
object matching the requested parameters. Notice that the i nvoke does not request 
the StudentDM to get the student n a m e directly. 
For StudentDM to provide the n a m e directly would violate the O O principle of 
encapsulation. This principle requires that only the Student object can manipulate 
Student data. T h e StudentDM does not have die authorization to deal with Student 
data direcdy. StudentDM can only process tiles and use the control fields to generate 
a Student instance. That instance can then manipulate the data. 
The concept of encapsulation or data hiding, as it is sometimes known, m e a n s 
that data are kept in a "capsule" called an instance. T h e data is the property of the 
instance a n d can be accessed only through one of the instance methods. Other 
objects m u s t send messages to the instance in order to use any of its data. 
Encapsulation allows the instance to maintain the data's integrity since there can 
be no unauthorized changes by other programs or objects. 
C o m p a r e encapsulation to the w a y data is treated in programs. In a program, 
all data are available to every paragraph in the program. A n y paragraph could 
potentially alter any data item in the Data Division. In poorly designed programs or 
ones that have been hastily modified, logic errors can cause data to be improperly 
changed and as a result cause unexpected effects. T h e source of these errors m a y 
not be easy to detect since any paragraph could have caused the problem. By 
restricting all manipulation to a n object a n d its methods, logic errors in methods 
are m u c h easier to detect and fix. 
Returning to ProcessRequests, in line 47 the m e t h o d begins the m a i n 
processing loop of the system. T h e control variable for the loop is theStudentHandle. 
W h e n the variable becomes "null" the loop stops. Nul 1 is a predefined address used 
by C O B O L to indicate that an object does not exist. If for s o m e reason StudentDM 
cannot create an instance of Student, getStudent returns null in theStudentHandle. 

The 
Student-Loak-Up 
System 
Using a valid Student handle, the first statement requests the Student n a m e 
from the Student object a n d then passes that data to StudentPRT for printing. 
ProcessRequest then "finalizes" the Student object a n d requests a n e w Student 
object. 
P
R
O
G
R
A
M
M
I
N
G 
T I P 
One problem in object-oriented systems is called memory leakage Memory leakage occurs when 
the system generates a new instance of a class and uses the same handle name as the previous instance. 00 
COBOL will place the new address into the handle overwriting the previous address. The original instance 
remains in the computer's memory, but since the pointer is gone there is no way to access it. The old instance 
has become an orphan and the memory assigned to it cannot be used for any other purpose. 
As orphans accumulate, the memory available is reduced and the performance of the system degrades. 
Some 00 systems provide a service called "garbage collection" where the system looks for and 
removes orphaned instances. The COBOL 2000 standard requires garbage collection but Personal COBOL 
does not provide it. 
In any case, it is a good practice to destroy unneeded instances. The Base method Finalize removes the 
current instance of an object from memory The format or this method is: 
INVOKE identifier-1 'Finalize' RETURNING identifier-1 
Identifier-1 is the handle of the instance. After processing, identifier-1 is returned as null. 
The Registrar object and its method ProcessRequests has served as an introduction 
to the concept of inheritance a n d demonstrated h o w an object interacts with other 
objects to accomplish a task. This discussion has also included the concept of 
encapsulation a n d the need to remove objects from m e m o r y w h e n they are no 
longer necessary. 
Objects exist only in the m e m o r y of a computer while a system is running. However, 
a system that cannot maintain data from one run to another has little practical use. 
0 0 systems therefore must provide a w a y to store a n d recall data whenever 
necessary. The 0 0 term for this requirement is Persistence. O n e m e t h o d of handling 
persistence in a system is to have a data m a n a g e m e n t class for each problem 
domain class. StudentDM is the data manager for the Student class. 
The three questions apply here as well. 
• StudentDM needs to k n o w the file specifications for the Student persistence 
file. 
* The object needs to k n o w the Student object. 
« StudentDM must be able to do all of the file handling to create Student 
instances. 

C
h
a
p
t
e
r 
2 0 
— 
Object-Oriented 
COBOL 
Programming 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
C l a s s Name: 
StudentDM 
Class Type: 
Data Management Object 
Narrative: 
This object performs ali tile processing for the Student file. The object opens, closes, and 
reads records from the file. StudentDM also creates Student instances from the data in 
the file. 
Objects Created: 
Student 
Objects Referenced: 
Student 
Factory Methods: 
New 
Narrative: 
Overrides the Base New in order to open the file when the object is created. 
Processing: 
1. Invoke New from Base. 
2. Open the Student File. 
Instance Method: 
GetStudent 
Narrative: 
This method controls the process of finding a student record that meets the user's 
specification. 
Processing: 
1. Set the Student handle to null in case a record cannot be found. 
2. Read the Student data file. 
3. For every record, determine whether it meets the minimum credit hours required and is 
in the required major. 
4. When a matching record is found, create and populate a Student object. Return the 
handle for the Student object. 
Instance Method: 
ReadRecord 
Narrative: 
This is a private method to read Student Records. 
Processing: 
1. Read records from the Student file. 
2. At end of file, set an end of file switch and close the file. 
Instance Method: 
CreateStudent 
Narrative: 
This private method creates an instance of Student and populates it with the values from 
the current Student Record. 
Processing: 
1. Invoke a new instance of Student. 
2. Populate the instance. 

e 
Student-Look• 
Up 
System 
Class Definition of StudentDM 
i 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
$set mfoo 
Class-id. StudentDM 
inherits from Base 
Author. 
Arthur R. Buss 
Environment Division. 
Input-Output Section. 
Fi le-Control. 
Select Student-File Assign to 'Student.Dat' 
Organization is Line Sequential. 
Object section. 
Class-control. 
Base is class 'Base' 
StudentDM is class 'sendbi' 
Student is class 'senstu' 
Data Division. 
File Section. 
fd Student-File. 
01 Student-In. 
05 Stu-Name 
05 Stu-Credits 
05 Stu-Major 
pic X(25). 
pic 9(03). 
pic X(20). 
object reference. 
object reference. 
FACTORY. 
Object-storage Section. 
01 Handles 
05 theDBIHandle. 
Method-id. 'New', 
iLinkage Section. 
101 Is-theDBIHandle 
Procedure Division 
! 
returning 1s-theDBIHandle. 
invoke super I'New' returning Is-theDBIHandle 
open input Student-file 
— 
End Method 'New'. 
End Factory. 
OBJECT. 
Method-id. 'ReadRecord'. 
Linkage Section. 
01 
1s-Data-Remai ns-Swi tch 
pic X(03). 

C
h
a
p
t
e
r 
2 0 
Object-Oriented 
COBOL 
Programming 
,5 
(continued) 
Procedure 
Division 
' returni ngUs^Data-Remai ns-Swi t c h . 
Move ' Y E S ' to Is-Data-Remains-Switch 
Read S t u d e n t - F i l e 
at end 
jiiove _|N0|_ to Is-Data-Remains-Switch 
i close S t u d e n t - F i l e | 
end-Read 
End Method 
'ReadRecord', 
• Wei 
-cord Reed 
Method-id. 
'GetStudent'. 
Local-storage S e c t i o n . 
01 
Data-Remains-Switch 
pic X(03). 
Linkage Section. 
01 
ls-Stu-Parameters. 
05 
l s - S t u - C r e d i t s 
05 
Is-Stu-Major 
pic 9(03). 
pic X ( 2 0 ) . 
01 
Is-theStuHandle 
object 
reference. 
Procedure 
Division 
'using 
1 s-Stu-Parameters 
returning Is-theStuHandle. 
set Is-theStuHandle to null 
i nvoke jsel f j_JJJeadjtecord' 
returning Data-Remains-Switch 
perform until Data-Remains-Switch 
Is-theStuHandle Not 
'voke Method i 
'NO' 
or 
null 
evaluate Stu-Credits 
also Stu-Major 
when 
>= l s - S t u - C r e d i t s also = Is-Stu-Major 
invoke s e l f 
'CreateStudent' 
returning Is-theStuHandle 
when other 
invoke s e l f 
'ReadRecord' 
returning Data-Remains-Switch 
end-evaluate 
end-perform 
Two Condition Evaluate 
Statement 
(See 
Programming Tip) 
End Method 
'GetStudent' 
Method-id. 
'CreateStudent'. 
Linkage S e c t i o n . 
01 Is-theStudentHandle 
object 
reference. 
Procedure 
Division 
returning 
Is-theStudentHandle. 
invoke Student 'New 

The 
Student-Look-Up 
System 
(continued) 
105 
106 
107 
108 
109 
110 
111 
112 
113 
returning 1s-theStudentHandle 
invoke 1s-theStudentHandle 'PopulateStudent 
using Student-In 
End Method 'CreateStudent 
End Object. 
End Class StudentDM. 
The class definition for StudentDM in Figure 20.5 looks more like a traditional 
C O B O L program than did Registrar. The Environment Division includes the Input-
Output Section with the standard File-Control paragraph. The Data Division also 
includes a File Section. Object-orientation uses standard file processing. 
All of the components of the Class definition should be familiar by now. 
However, for the first time, Factoiy is defined a n d has the factory m e t h o d New. The 
New m e t h o d has been discussed before as an example of inheritance. Normally Base 
performs the New method. However, there are occasions w h e n s o m e specialized 
processing is needed at the time an instance is created. For a data manager object, 
opening files seems to be that type of process. New, as defined in Base, cannot open 
tiles. Therefore, w e have elected to override the New procedure in Base and to build 
our o w n through a technique called 
polymorphism. 
Polymorphism is a Greek term meaning m a n y shapes. In O O programming, 
polymorphism m e a n s that a message m a y produce different results based o n the 
object it is sent to. Polymorphism is usually achieved by having a m e t h o d override 
another, inherited method. Polymorphism can be a powerful tool, a n d this example 
is quite simple. A full treatment of the topic is beyond the scope of this chapter. 
By defining a Factory m e t h o d called New within StudentDM, the inherited 
m e t h o d New in the Base m e t h o d is overridden. W h e n StudentDM or any object 
receives a message it checks to see whether that m e t h o d is available. If the m e t h o d 
exists within the object, it is executed. If not, the message is passed to the parent 
object. Therefore, since the Factory m e t h o d New is defined in StudentDM, the local 
m e t h o d overrides the inherited method. 
Overriding inheritance must be done with caution since the local m e t h o d 
must be able to handle all of the processing expected of the inherited method. For 
example, New must be able to create an instance of StudentDM. T h e local m e t h o d 
New accomplishes this task through the statement Invoke super 'New' returning 
1 s-theDMHandl e in line 40. T h e message invokes the parent or super class to do its 
m e t h o d New. By invoking the parent class, Base instantiates StudentDM a n d returns 
its handle. T h e handle can then in turn be passed o n to the original invoking 
procedure. Having n o w carried out the primary function of New, the local m e t h o d 
can go o n to o p e n the file as well. 
StudentDM Instance Definition 
T h e Instance Definition of StudentDM is straightforward. T o answer the three 
questions: 

C h a p t e r 
20 
— 
Object-Oriented 
COBOL 
Programming 
«• The Instance does not have special data other than that n e e d e d to m a n a g e 
L l l C 
l l l C 
» The only object that it is knows is Student. 
« What it does is to read records from the file, test to see whether they m e e t the 
specifications, and create Student instances containing the Student data. 
Of the three m e t h o d s defined for the instance, only o n e GetStudent is invoked 
from outside. The other two m e t h o d s are "private" m e t h o d s to be used only by 
other m e t h o d s in the StudentDM. 
Beginning at line 65, GetStudent maintains a Local-storage Section to hold a n 
end-of-file switch and a Linkage Section to receive the invoking parameters and to 
pass back the handle for the Student instance. 
The Procedure Division has both using a n d returning clauses to allow use of 
the items in the Linkage Section. The algorithm of the m e t h o d is to initialize the 
Student handle to null and then invoke the ReadRecord m e t h o d . The invoke 
statement uses the keyword sel f. Sel f refers to the pointer of the current instance. 
An instance always knows its o w n m e m o r y location a n d can reference that location 
by using sel f. 
Once the record is read, GetStudent evaluates the credit hours against the 
m i n i m u m and the major against the required major. If the test is successful, the 
routine invokes the CreateStudent method, and uses the result to return the Student 
Handle and to stop the loop. If the test w a s not successful, the routine invokes 
ReadRecord m e t h o d to get the next record. W h e n ReadRecord runs out of records, 
it returns "NO" to the Data-Remains-Switch. The loop stops, and because n o instance 
of Student has b e e n created the m e t h o d returns a null handle to the invoking 
procedure. 
P R O G R A M M I N G 
T I P 
The C O B O L Evaluate statement is much more powerful than C A S E statements in other languages. In most 
languages, the C A S E statement can test a condition for only one variable at a time. The Evaluate statement, 
however, allows testing of several conditions at once. Consider the Eval uate statement in the GetStudent 
method of StudentDM. 
evaluate Stu-Credits 
also Stu-Major 
when >= ls-Stu-Credits 
also = Is-Stu-Major 
invoke self 'CreateStudent' 
returning ls-theStuHandle 
when other 
invoke self 'ReadRecord' 
returning 
Data-Remains-Switch 
end-evaluate 
Notice that the Eval uate statement tests conditions for Stu-Credits but also for Stu-Major. Al so is the 
keyword that tells the Eval uate to test both variables in an A N D relationship. The first When clause compares the 
respective variables to ls-Stu-Credits and Is-Stu-Major. The use of the keyword Al so makes sure that proper 
testing occurs. 
This test will allow only records that have Stu-Credits greater than or equal to ls-Stu-Credits A N D Stu-
Major equal to Is-Stu-Major. 
The Evaluate statement can virtually eliminate the need for nested IFs when used properly. 

The 
Student-Look-Up 
System 
The remaining two methods are easily understood. ReadRecord is a simple 
i c a u 
h j u i i i i c ; 
i i i c i l 
i i i i g u t 
l * c 
i u u i i u 
m 
a n y 
j i u c i a i n . 
notable feature is that the routine closes the file w h e n AT END is reached. CreateStudent 
is also simple. It invokes the New m e t h o d to create an instance of Student and then 
invokes the PopulateStudent m e t h o d to m o v e data from the input file into the 
instance just created. 
In a real system, StudentDM would have more instance methods, such as 
ones which could add, modify, or delete student records. Students acquainted with 
indexed files, direct files, or databases are well aware that the use of a sequential file 
as has been done here, would not be efficient for handling m a n y student records. 
Y o u should be able to see that if StudentDM were rewritten to use another file 
organization, Registrar a n d Student w o u l d never k n o w the difference. B y 
encapsulating the file processing in StudentDM, major file changes are invisible to 
the rest of the system. Polymorphism and encapsulation m a k e system modifications 
simple. 
The StudentDM class serves as an example of h o w an object can process files 
and interact with other objects. Y o u have also seen an example of polymorphism 
and h o w inherited methods can be overridden. 
P R 
Class Name: 
Class Type: 
Narrative: 
Objects Created: 
Objects Referenced: 
Factory Methods: 
Instance Method: 
Narrative: 
Processing: 
O G R A M M I N G 
S P E C I F I C A T I O N S 
Student 
Problem Domain Object 
This class represents the data and behaviors of students in the system. An instance of 
the class may return the student's major and the number of credit-hours earned. 
None 
Person (Parent) 
None 
PopulateStudent 
This method moves the data from the linkage section of the method into the Object-
storage Section, where the data are available to every method of the instance. 
1. Format and store the Student name. 
2. Store the rest of the Student data. 
Instance Method: 
Narrative: 
GetCreditHours 
Returns the Student credit hours. 
Processing: 
1. Move Credit Hours to linkage section. 

C
h
a
p
t
e
r 
2 0 
Object-Oriented 
COBOL 
Programming 
Instance Method: 
GetMajor 
Narrative: 
Returns the Student major. 
Processing: 
1. Move Major to linkage section. 
Student Class Definition 
1 
$set mfoo 
2 
Class-id. Student 
3 
linherits From iPerson ; 
4 
5 
6 
Object Section. 
7 
Class-control. 
8 
Person is Class 'person' 
9 
Student is Class 'senstu' 
10 
11 
12 
OBJECT. 
13 
14 
Object-storage Section. 
15 
01 Student-In. 
16 
05 Stu-Data. 
17 
10 Stu-Credits 
pic 9(03). 
18 
10 Stu-Major 
pic X(20). 
19 
20 
Method-id. 'PopulateStudent'. 
21 
Linkage Section. 
22 
01 Is-Student-In. 
23 
05 Is-Stu-Name 
pic X(25). 
24 
05 ls-Stu-Data. 
25 
10 Is-Stu-Credits 
pic 9(03). 
26 
10 Is-Stu-Major 
pic X(20). 
27 
28 
Procedure Division 
29 
using ls-Student-In. 
30 
TnvoReYeTf
rPt^uTaieHame
vS 
31 
using Is-Stu-Name 
32 
move ls-Stu-Data to Stu-Data 
33 
34 
End Method 'PopulateStudent'. 
35 
36 
Method-id. 'GetCreditHours'. 
37 
Linkage Section. 
38 
01 ls-Credit-Hours 
pic 9(03). 
39 
40 
Procedure Division 
41 
returning ls-Credit-Hours. 
42 
43 
move Stu-Credits to 1 s-Credit-Hours 
44 

The 
Student-Look-up 
System 
Figure 20-6 
(continued) 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
End Method 'GetCreditHours 
Method-id. 'GetMajor
1. 
Linkage Section. 
01 Is-Stu-Major 
pic X(20). 
Procedure Division 
returning 1s-Stu-Major. 
move Stu-Major to 1s-Stu-Major 
End Method 'GetMajor'. 
End Object. 
End Class Student. 
The Student class manages the data for students. Figure 20.6 contains the 
definition of Student. Notice that that this object does not inherit from Base (line 8). 
Student inherits from another class, Person. W e explain the reason for using 
inheritance under the discussion for the class Person. 
The Student object represents a simple application of h o w inheritance can 
work. Student contains three instance methods. Only one, PopulateStudent, is 
actually used by this system. PopulateStudent stores the data in the Object-storage 
section after an instance has been created. GetMajor and GetCreditHours are simple 
methods to s h o w h o w other applications can retrieve those data items. 
PopulateStudent, in line 24, invokes a m e t h o d called PopulateName. T h e 
i nvoke statement references sel f. However, Student does not have a m e t h o d called 
PopulateName. That m e t h o d is actually in Person. 
By referencing sel f, Student looks for a m e t h o d by the n a m e PopulateName 
within itself. The Student cannot find the method; it will pass the message to its 
parent—Person. In a case like this, the programmer m a y want to reference super 
rather than self. Yet there m a y be s o m e instances where self is actually safer. 
Should PopulateName be added to Student to a c c o m m o d a t e s o m e need for 
polymorphism, using super would bypass the local method. Using sel f assures that 
the proper m e t h o d is invoked. 
Because Student inherits from Person, an instantiation of Student m e a n s that 
Person is instantiated as well. Both Person and Student exist at the s a m e time, but 
Student does not have to maintain a pointer to Person. The inheritance mechanism 
handles these relationships. 
O n e other example of inheritance should also be noted. In Figure 20.4, line 54, 
the ProcessRequest m e t h o d invokes theStudentHandle with the m e t h o d GetName. 
G e t N a m e is not defined in the Student object. Student will receive the message a n d 
send it o n to Person to be performed. Registrar neither knows nor cares that the 
work is actually done by Person instead of Student. 
The Student class is an example of inheritance and of h o w O O programmers 
can take advantage of this technique to reuse code in a variety of ways. The Person 
class gives an example of what a parent class could look like. 

Chapter 
2 0 
Object-Oriented 
COBOL 
Programming 
The Person Class 
P R 
Class Name: 
Class Type: 
Narrative: 
Objects Created: 
Objects Referenced: 
Factory Methods: 
Instance Method: 
Narrative: 
Instance Method: 
Narrative: 
Processing: 
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
Person 
Problem Domain Object 
This class represents the data and behaviors of persons of any type in the system. 
None 
None 
None 
PopulateName 
This method moves the formatted name data from the linkage section of the method into 
the Object-storage Section where the data are available to every method of the instance. 
The Object-storage Section holds name data in a generalized format and the input name 
is broken up into its parts. 
1. Find and store the first-name portion of the name and store it in the Object—storage 
Section. 
2. Find the last-name portion of the name and store it in the Object-storage Section. 
GetName 
Produces the Name in a formatted form. 
1. Concatenate the first name and last name and move to linkage section. 
M a n y types of people are involved in the operation of a university. Besides 
students, there are faculty, administration, clerical staff, a n d facilities staff, to n a m e 
a few. Each of these roles has its o w n specialized functions and data. Yet, if one were 
to ask either a faculty m e m b e r or a facilities person what their n a m e was, the 
questioner would expect that either one could respond. Therefore, if the system 
required a Faculty class or a Staff class in addition to a Student class, each of these 
classes should be able to respond to a message "GetName." 
O n e w a y to accomplish this goal would be to code a " G e t N a m e " m e t h o d into 
each of these classes. However, any change to the m e t h o d would have to be m a d e in 
every class using that method. Structured programs often face this problem. 
A better approach to meeting the requirement is to take advantage of 
inheritance. Students, faculty, administration, clerical staff, a n d facilities staff are 
all persons. B y defining a generic class called Person, all of the c o m m o n data 
attributes a n d associated methods could be placed in Person a n d every class 
inheriting from Person could use the methods a n d access the data. 
S o m e c o m m o n attributes might be: 

The 
Student-Look-Up 
System 
• N a m e 
• Address 
• Telephone 
• Age 
By coding these and other attributes into Person, they have to be coded only 
once, but they are available to any class inheriting from Person. A n y changes to the 
data or the methods is automatically available to the subclasses by making changes 
only in Person. 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
' Person Class Definition 
$set mfoo 
Class-id. Person 
inherits from Base 
Object section. 
Class-control. 
Base is Class 'base' 
Person is Class 'person' 
OBJECT. 
Object-storage Section. 
01 Person-Name. 
05 Per-Last-Name 
05 Per-First-Name 
05 Per-Middle-Name 
01 Counters. 
05 First-Name-Len 
05 Last-Name-Len 
Method-id. 'PopulateName'. 
Linkage Section. 
01 Is-Person-Name 
Procedure Division 
using 1s-Person-Name. 
pic X(20). 
pic X(20). 
pic X(20). 
pic 9(02). 
pic 9(02). 
pic X(60). 
initialize Counters 
inspect 1s-Person-Name 
tallying First-Name-Len 
for characters before initial space 
inspect 1s-Person-Name (First-Name-Len + 2:) 
tallying Last-Name-Len 
for characters before initial space 
move 1s-Person-Name (1:First-Name-Len) 
to Per-First-Name 
move 1s-Person-Name (First-Name-Len + 2 : Last-Name-Len) 
to Per-Last-Name 

Chapter 
20 
Object-Oriented 
COBOL 
Programming 
ire 20.7 
(continued) 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
End Method 'PopulateName'. 
Method-id. 'GetName'. 
Working-storage Section. 
01 Blank-Char 
Linkage Section. 
01 ls-Name 
Procedure Division 
returning ls-Name. 
initialize ls-name 
pic X 
value space. 
pic X(25), 
string Per-First-Name delimited by space 
Blank-Char 
delimited by size 
Per-Last-Name delimited by space 
into ls-Name 
End Method 'GetName'. 
End Object. 
End Class Person. 
The Person class, s h o w n in Figure 20.7, looks m u c h like any other class. For 
example, Person inherits from Base. Note that because Student inherits from Person 
it also inherits from Base, though indirectly. There m a y be multiple levels of 
inheritance defined with lower-level classes inheriting methods a n d data from 
grandparent as well as parent classes. Y o u should also note that Person does not 
have to k n o w what classes inherit from it. 
Because Student inherits from Person, any instantiation of Student creates an 
instantiation of Person as well. O O C O B O L then allows Student to access the methods 
in Person without creating a special handle. Person and Student are attached to 
each other. However, even though Student k n o w s about Person, Person does not 
need to k n o w about Student. 
T h e Object-storage Section in lines 14-17 defines h o w the N a m e is stored. The 
format specified here is quite different from that actually stored in the Student file 
and printed o n the output report. The designers of the class wanted to be able to 
output the n a m e in a variety of formats. Therefore, a m o r e general n a m e format has 
been specified in the Object-storage Section. 
Therefore, PopulateName has to be able to convert a single n a m e field into 
the three attribute fields. T h e routine uses the i nspect statement to break d o w n the 
n a m e a n d to store the results in the proper fields. 
G e t N a m e reformats the N a m e into the full-name format and returns the 
n a m e as a single data item. 
T h e Person class shows h o w a super class a n d its methods might be used in an 
O O system. The class definition shows h o w objects can input a n d output data in 
formats different from the w a y the class stores them. 

The 
Student-Look-Up 
System 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Class Name: 
StudentUI 
Class Type: 
User Interface 
Screen Layout: 
See Figure 20.8a. 
Narrative: 
This class controls the interface to the user. The class gathers the requested minimum 
number of credit hours and the name of the desired major. 
Objects Created: 
None 
Objects Referenced: 
None 
Factory Methods: 
None 
Instance Method: GetParameters 
Narrative: 
This method controls the display of requests to the system user and accepts the 
responses. 
Processing: 
1. Invoke DisplayHoursRequest and store the result in the linkage section. 
2. Invoke DisplayMajorRequest and store the result in the linkage section. 
Instance Method: 
DisplayHoursRequest 
Narrative: 
This is a private method that displays a user prompt for the minimum number of credit 
hours desired and accepts the response. 
Processing: 
1. Display Prompt. 
2. Accept response into the linkage section. 
Instance Method: 
DisplayMajorRequest 
Narrative: 
This is a private method that displays a user prompt for the desired major and accepts 
the response. 
Processing: 
1. Display Prompt. 
2. Accept response into the linkage section. 

C
h
a
p
t
e
r 
2 0 
— 
Object-Oriented 
COBOL 
Programming 
-Igure 20.8 Screen Sample 
Enter Minimum Hours: 100 
Enter Student Major: 
Engineering 
(a) Display Parameter Prompts 
STUDENT NAME 
ORVILLE WRIGHT 
JOHN ROEBLING 
* * * 
End of Report * * * 
(b) 
Report Sample 
Fiqure 20.9 StudentUI Class Definition 
1 
$set mfoo 
2 
C l a s s - i d . 
StudentUI 
3 
inherits from Base 
4 
5 
Author. 
Arthur R. Buss 
6 
7 
Object Section. 
8 
C l a s s - c o n t r o l . 
9 
Base i s Class 'base' 
10 
StudentUI i s Class ' s e n u i ' 
13 
OBJECT. 
14 
15 
Method-id. 
'GetParameters'. 
16 
Linkage Section. 
17 
01 
Is-Student-Parameters. 
18 
05 
ls-Stu-Hours 
pic 
9 ( 0 3 ) . 
19 
05 
Is-Stu-Major 
pic X ( 2 0 ) . 
20 
21 
Procedure 
Division 
22 
returning ls-Student-Parameters. 
23 
24 
invoke s e l f iMlisplayHoursRequest^j— 
25 
returning ls-Stu-Hours 
~~~~~~^r^-.P(ivaie Methods 
26 
invoke s e l f I'DisplayMajorRequest'l 
27 
returning Is-Stu-Major 
28 
29 
End Method 'GetParameters'. 
30 
31 
Method-id. 
'DisplayHoursRequest'. 
32 
Linkage Section. 
33 
01 
ls-Stu-Hours 
pic 
9 ( 0 3 ) . 
34 
35 
Procedure Division 

The 
Student 
-Look-up 
System 
-syu«e 
1.9 
(continued) 
36 
returning 1s-Stu-Hours. 
37 
38 
display 'Enter Minimum Hours: ' 
with no advancing 
39 
accept Is-Stu-Hours 
40 
41 
End Method 
'DisplayHoursRequest'. 
42 
43 
Method-id. 
'DisplayMajorRequest'. 
44 
Linkage Section. 
45 
01 
ls-Stu-Major 
pic X ( 2 0 ) . 
46 
47 
Procedure Division 
48 
returning 
ls-Stu-Major. 
49 
50 
display 'Enter Student Major: 
' 
with no advancing 
51 
accept 
ls-Stu-Major 
52 
move function Upper-Case ( l s - S t u - M a j o r ) to 
ls-Stu-Major 
53 
54 
End 55Method 
'DisplayMajorRequest'. 
55 
56 
End Object. 
57 
End Class StudentUI. 
Figure 20.9 shows the class definition for the StudentUI object. This object 
controls the user interface to the system. There are no O O techniques that have not 
been addressed elsewhere. 
StudentUI has been kept very simple for instructional purposes, but m o r e 
elaborate user interfaces could be developed even to the point of using W i n d o w s 
screens without affecting the rest of the system. These more elaborate objects 
would simply replace StudentUI. O O allows "plug compatibility." W h e n an object 
needs enhancement, the changes can be m a d e and tested outside of the production 
system. W h e n ready, the old version of the object can simply be replaced by the n e w 
version. 
The instance m e t h o d GetParameters controls the process a n d uses the private 
methods DisplayHoursRequest and DisplayMajorRequest to get the user's input. 
The StudentPRT Class 
. 
The final class in the system is a print manager, a form of user interface class. This 
class manages the printing of the report and has been slightly enhanced from the 
Engineering Senior program in Figure 1.6. 

Chapter 
20 
Object-Oriented 
COBOL 
Programming 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Class Name: 
StudentPRT 
Class Type: 
User Interface 
Narrative: 
This class controls the printing of the selected student report. 
Report Format: 
Figure 20.8b 
Objects Created: 
None 
Objects Referenced: 
None 
Factory Methods: 
New 
Narrative: 
Causes the print file to open. 
Processing: 
1. Invoke OpenPrinter. 
insts!*!c© ft^l©tl*iocl * OpsnPrintsr 
Narrative: 
Opens the printer and causes the report headers to be printed. 
Processing: 
1. Open Print File. 
2. Invoke WriteHeader. 
Instance Method: WriteHeader 
Narrative: 
This is a private method that Writes the Report Header. 
Processing: 
1. Write Header Line. 
2. Write Blank Line. 
Instance Method: 
WriteDetail 
Narrative: 
This is a private method that prints the Detail Line containing a student name. 
Processing: 
1. Move name to Print Line. 
2. Write Print Line. 
Instance Method: 
FinalizeReport 
Narrative: 
Prints the final report line and closes the print file. 
Processing: 
1. Move End of Report Line to Print Line. 
2. Write the Print Line. 
3. Close the Print File. 

The 
Student-Look 
Up 
System 
1 
$set mfoo 
2 
Class-id. StudentPRT 
3 
inherits from Base 
4 
5 
Author. 
Arthur R. Buss 
6 
7 
Environment Division. 
8 
Input-output Section. 
9 
File-control. 
10 
Select PrintFile 
11 
Assign to printer 
12 
13 
14 
Object Section. 
15 
CI ass-control. 
16 
Base is Class 'base' 
17 
StudentPRT is Class 'senprt' 
18 
19 
20 
Data Division. 
21 
File Section. 
22 
fd PrintFile. 
23 
01 Print-Line 
pic X(45). 
24 
25 
FACTORY. 
26 
Object-storage Section. 
27 
01 thePRTHandle 
object reference. 
28 
29 
Method-id. 'New'. 
30 
Linkage Section. 
31 
01 1s-thePRTHandle 
object reference. 
32 
33 
Procedure Division 
34 
returning 1s-thePRTHandle. 
35 
36 
invoke super 'New' returning thePRTHandle 
37 
set Is-thePRTHandle to thePRTHandle 
38 
invoke thePRTHandle 'OpenPrinter' 
39 
" 
40 
End Method 'New'. 
41 
End Factory. 
42 
43 
OBJECT. 
44 
45 
Method-id. 'OpenPrinter'. 
46 
Procedure Division. 
47 
48 
open output PrintFile. 
49 
invoke self 'WriteHeader' 
50 
51 
End Method 'OpenPrinter'. 
52 
Figure 20.10 StudentPRT Class Definition 

C
h
a
p
t
e
r 
2 0 
••-
Object-Oriented 
COBOL 
Programming 
:igute 20.10 
(continued) 
53 
Method-id. 'WriteHeader'. 
54 
Working-storage Section. 
55 
01 Heading-Line. 
56 
05 
pic X(10) 
value Spaces. 
57 
05 Head-1 
pic X(12) 
value 'STUDENT NAME
1. 
58 
05 
pic X(58) 
value Spaces. 
59 
60 
Procedure Division. 
61 
62 
move Heading-Line to Print-Line 
63 
write Print-Line after advancing Page 
64 
move Spaces to Print-Line 
65 
write Print-Line after advancing 1 
66 
67 
End Method 'WriteHeader'. 
68 
69 
Method-id. 'WriteDetail'. 
70 
Working-storage Section. 
71 
01 Detail-Line. 
72 
05 
pic X(10) 
value Spaces. 
73 
05 Print-Name 
pic X(25). 
74 
05 
pic X(45) 
value Spaces. 
75 
76 
Linkage Section. 
77 
01 ls-Stu-Name 
pic X(25). 
78 
79 
Procedure Division 
80 
using ls-Stu-Name. 
81 
82 
move ls-Stu-Name to Print-Name 
83 
move Detail-Line to Print-Line 
84 
write Print-Line after advancing 1 
85 
86 
End Method 'WriteDetail'. 
87 
88 
Method-id. 'FinalizeReport'. 
89 
Procedure Division. 
90 
91 
invoke self 'WriteDetail' using ' ' 
92 
invoke self 'WriteDetail' using 
93 
'* * * End of Report * * *' 
94 
close PrintFile 
95 
96 
End Method 'FinalizeReport'. 
97 
98 
End Object. 
99 
End Class StudentPRT. 

Like StudentDM, Student PET, s h o w n in Figure 20.10, has to m a n a g e a file, in 
this case a print file. Again like StudentDM, the Factory method New overrides the 
Base m e t h o d in order to open the file. The New m e t h o d does not o p e n the printer 
directly, but rather invokes the instance m e t h o d OpenPrinter. Notice that 
thePRTHandle is used to invoke the method. T h e keyword Sel f would not work 
since it would refer to the Factory and not the instance of the class. Instances a n d 
Factories, though related, are independent and can be addressed only through the 
proper handles. 
OpenPrinter takes on the responsibility to write out the first report header by 
invoking the WriteHeader method. 
StudentPRT, unlike StudentDM, cannot tell w h e n the file should be closed. 
Only Registrar can tell w h e n all of the records have been processed. Therefore, 
Registrar has to invoke the m e t h o d FinalizeReport. FinalizeReport can print an E n d 
of Report line a n d then close the file. 
StudentPRT shows h o w a report can be produced by an object-oriented system. 
The only n e w O O concept is in showing h o w a Factory m e t h o d can invoke an 
instance m e t h o d within the s a m e class. 
hi summary, why use object-orientation for COBOL programs instead of structured 
programming? Object-Orientation allows systems to use: 
• Shorter code elements 
» Reusable code 
• Simpler control structures 
• W a y s to have better control over data 
Object-Orientation does not invalidate the concept of structured programming. 
OO simply is the next step in providing the capabilities that structured programming 
claimed to supply. 
O n e might observe that O O C O B O L m a y have advantages for n e w development, 
but might question h o w it would work with the massive a m o u n t of C O B O L code 
developed with the traditional methods. The answer is that O O does not have to be 
"either-or." Traditional programs can invoke objects. W e saw that the driver program 
for the Student-Look-Up system is a traditional program. O n the other hand, objects 
can call traditional programs as well. 
A n organization can examine its legacy systems a n d develop a plan to evolve 
their systems to O O by determining the objects present in the system. Each object 
can then evolve as c o m m o n procedures in the traditional programs are converted 
to methods. The traditional programs can then initially invoke the methods from 
objects. As the organization develops its O O skills a n d understanding, the legacy 
programs can be slowly eliminated. This process can become part of the regular 
maintenance process a n d does not have to be overly expensive if g o o d O O analysis 
and design has been done. 

C
h
a
p
t
e
r 
2 0 
Object-Oriented 
COBOL 
Programming 
S U M 
MARY 
Fuji ' 5 to R&iiitit.cer 
is 
Even though the COBOL 2000 standard has not been adopted yet, OO 
COBOL compilers are available and can be used to learn this new "dialect." 
The emphasis in OO programming is on the development of systems, not 
just programs. Objects are developed to serve as building blocks for many 
systems. 
The structure of methods is similar to that of programs, but methods are 
simpler and do not need elaborate control structures. 
Programmers who know both structured and OO COBOL will have an 
advantage as companies begin to migrate their legacy systems toward 
object-orientation. 
Structured systems will not disappear soon, and the migration to OO will be 
evolutionary rather than revolutionary. 
Key Words and Concepts 
C j i a s s 
Instance 
Factory 
M e t h o d 
Message 
Encapsulation 
Polymorphism 
Inheritance 
Paradigm 
Structured Programming 
Object-oriented Programming 
system 
Persistence 
User Interface Class 
System Interface Class 
Data Manager Class 
Problem D o m a i n Class 
Driver 
Pointer 
Handle 
Data Hiding 
Static 
COBOL 
Elements 
Invoke 
Class-id 
Class Control 
OBJECT 
FACTORY 
Object-storage Section 
Method-id 
Local-storage Section 
Object Reference 

Conclusion 
1. Object-oriented C O B O L (is/is not) part of the C O B O L 2000 standard. 
2. 
is the C O B O L verb for running methods in classes. 
3. A(n) 
is the definition of an object; a(n) 
is a specific 
occurrence of an object. 
4. The special instance that allows manipulation of all other instances is called the 
5. 
is the feature of O O that allows one class to act as if it 
contained the data and methods of another class. 
6. The O O feature that protects the data contained in an object from access by other 
objects except through methods is called 
. 
7. 
is a special class and contains methods that are inherited by all other 
classes. 
8. The change to O O represents a 
shift because it represents a new 
way of thinking about programming. 
9. Sometimes, one class overrides a method in a parent class to provide some new 
capability. This O O feature is called 
. 
1. Object-Orientation reverses all of the principles of structured programming. 
2. The Identification Division does not have to be specified in class definitions. 
3. The Procedure Division does not have to be specified in a method. 
4. C O B O L is the first language to have O O capability. 
5. It is not likely that O O C O B O L will completely replace structured C O B O L in the 
near future. 
6. W h e n developing the specifications for a class, the designer should ask: 
What does it know? 
W h o m does it know? 
What does it do? 
7. Classes that specifically deal with processing of the application are said to belong 
to the Problem Domain. 
8. O O systems have no need of files. 
9. Files provide the links between programs in structured systems. 
10. O O systems use files to provide persistence between runs of the system. 

C h a p t e r 
20 
Object-Oriented 
COBOL 
Programming 
P ROB 
L t E M S 
1. W h y is the class n a m e used to invoke a Factory method and a handle to invoke an 
instance method? 
2. H o w does object-orientation promote the reuse of program code? 
3. Write a method for the Person class that would format a n a m e starting with the last 
n a m e followed by ", " and followed by the first name. 
4. Which class should contain a campus phone number if it should be needed by the 
system? 
5. Differentiate between system, program, and class. 
Several texts are n o w available for learning OO COBOL. These include: 
Arranga, E., and Coyle, F. Object-Oriented 
COBOL. SIGS Publications, 1996. 
Chapin, N. Standard 
Object-Oriented 
COBOL. John Wiley & Sons, 1997. 
Doke, E. R., and Hardgrave, B. C. An Introduction 
to Object 
COBOL. John Wiley & 
Sons, 1998. 
Obin, R. Object-Orientation: 
An Introduction 
for COBOL 
Programmers. 
2 n d ed., 
i v . i i : . — n . . u u
0 u : 
tone 
i v i i ^ i u i u u u a r u u i i a i i i i l g , 
i 3 J J . 
Price, W. Elements 
of Object-Oriented 
COBOL. Object-Z Publishing, 1997. 
1 This system can downloaded from http://www.prenhal 1 .com/grauer_cobol. 
2 This discussion is an oversimplification of the analysis and design process. For students interested in 
the OO Analysis and Design process, many books are available. This discussion is based on Peter 
Coad's book Object Models: Strategies, Patterns, and Applications, 2nd ed., Yourdan Press. 
3 COBOL 2000 goes a step beyond and allows free formatting of COBOL programs. This chapter does not 
show this technique because of the awkward way that the Animator handles free format. Future 
versions of the compiler should improve in that respect. Students interested in trying free format 
should place $ set source-format "free" starting in column 7 before the first line of the source code. In 
free format the comment indicator becomes "*>" and can be placed anywhere in a line. All entries to 
the right of the comment indicator are ignored. 
F O R 
F U R T Pi E R 
Y 

O v e r v i e w : This appendix describes the use of the Animator portion of Micro 
Focus's Personal COBOL for Windows. Personal COBOL is a powerful package 
of development tools offering two source-code editors and a Windows user 
interfaces generator. The Animator is a version of Micro Focus's professional 
COBOL editor that is restricted in its capabilities. The personal version contains 
all of the features necessary to develop programs for use with this text and most 
GIO! I IUI ILCtl y Q l I^J II ILOI I I l<3(_IICUO U
U
U
U
L 
O U U I O C D , U l iiy CL I O W ClUJVCll IOC7VJ UQjjaUIIIUCO 
are eliminated. The student should know that Personal COBOL cannot create a 
fully executable program file. Instead, Personal COBOL develops an intermediate 
file executable by the system. As a result, programs using an intermediate file 
have slightly slower performance than a fully executable program. The Animator's 
limitations are not serious for educational purposes. Any program developed in 
the personal version can be recompiled in the professional version to produce 
fully executable programs. 
The second type of editor available with Personal COBOL is the Browser, 
which is a particularly useful tool for developing object-oriented systems. This 
chapter does not cover the Browser, but you may want to look at it in connection 
with Chapter 20, which discusses object oriented COBOL. 
The third tool provided by Personal COBOL is the Personal Dialog System 
(PDS). This tool aids in developing Windows-based user interfaces for COBOL. 
PDS allows the programmer to design the forms for the system and then to link 
those forms to the COBOL programs beneath. PDS is an advanced tool, and this 
chapter does deal with it. 
The student is encouraged to read this appendix while sitting at a computer 
with the Animator program loaded. Most of the examples use the program 
"helloO.cbl" or "helloO.int," which can be found in the normal default directory 
c:\PCOBWIN\SAMPLES. The reader may want to follow along as the material is 
presented, and duplicate the process. 

Appendix A ' 
> 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
ntroduction to the Animator 
The Animator is a reduced version of Micro Focus's Professional Animator. T h e 
most useful features of the professional version are available, and the beginning 
programmer should find t h e m to be very powerful. For example, the Animator color 
codes the different types of words used in writing the language after the program 
has been checked (compiled) once. Typically, all of the C O B O L reserved words are 
in green, all of the variables are in maroon, a n d text items are in black. This color 
coding allows the programmer to see whether the compiler recognizes the code 
being entered as the type of item expected. T h e wrong color would indicate a 
misspelling of the item. 
The Animator has m a n y debugging tools, extended help screens, a n d the 
s a m e user interface as the Professional version. The student n e w to the Animator 
m a y find the tool to be overwhelming, rather than finding it limiting. This appendix 
presents most of the Animator's capabilities and is designed to serve as a resource 
for using them. 
Installing the Animator 
Consult your Getting Started book, page 10, for installing Personal C O B O L for 
Windows. The instructions are for installation in W i n d o w s 3.1; however, the software 
works in W i n d o w s 9 5 or W i n d o w s N T as well. \A7indow
rs95 users can sirn
rih
r install 
the software by using the R u n function from the Start m e n u . Appendix B contains 
full instructions for installing Personal C O B O L in Windows95. 
Learning to Use the Animator 
The Getting Started booklet generally is too advanced for the beginning C O B O L 
student, and provides only a minimal introduction to the Animator. Most of the 
book focuses o n the Personal Dialog System a n d Object Oriented C O B O L . T h e 
beginning student probably should read only the material in Lesson 1. Even in 
Lesson 1, students should not be concerned about understanding the sample 
program given there. 
Starting the Animator 
O n c e Personal C O B O L has been installed, one can start the Animator from the 
program group in which it is installed, as s h o w n in Figure A.l. (All figures appear in 
W i n d o w s 9 5 format.) Figure A.2 shows the default icon for the Animator, a picture of 
a w i n d o w with the title Personal C O B O L . This icon starts the Animator in the default 
directory established during installation. Usually this directory will he something 
like C : \ P C 0 B W 1 N \ S A M P L E S . Students wishing to store their programs in a different 
directory should add another icon to the group window. This icon should start the 
Animator using the executable file "{default directoryl\Anim2wg.exe" as the 
executable file. The working directory should point to the location of the desired 
files, as s h o w n in Figure A.3. In the W i n d o w s 3.1 environment the program groups 
can be modified using the File m e n u in the Program Manager. In Windows95, the 
Settings entry controls the creation of n e w m e n u entries. Appendix B contains 
further instructions for setting u p one's o w n "shortcuts." 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Persona! 
t mh)t 
'e. 
\,V;r>c,im': 
ih-ets 
Guide- 
J 
1,101:41 
O S 
- -~ 
Starting the Animator 
Figure A . 3 Properties Window for Personal COBOL Shortcut 
flgyre A.I Windows95 Startup Menu 

A
p
p
e
n
d
i
x 
A 
M 
m 
Focus 
Personal 
COBOL 
for 
Windows; 
Users 
Guide 
and 
Tutorial 
In this section, w e look at the m a i n features and the tools of the Animator. O n e 
feature of the Animator is the ability to modify the user interface. This feature is 
addressed at the appropriate point. For sake of clarity, however, the section relates 
only to the standard interface, as s h o w n in Figure A.4. 
Figure A.4 Personal COBOL User Interface 
i 
Main Mei 
HE 
-end of 
t e s r t -
Main Menu 
T h e M a i n M e n u of the Animator has eight pulldown m e n u entries, s h o w n in Figure 
A.5. S o m e of these entries are familiar to any W i n d o w s user, but s o m e are specific to 
the Animator. Each pulldown m e n u has several subsections arranged by function. 
W e will look at each m e n u item separately. M a n y of the m e n u operations can also 
be performed by using shortcut keys. Experienced users often take advantage of 
these keys to ease the editing process. The shortcut keys are s h o w n in parentheses 
in the m e n u s and the first time the option is mentioned in the text. 
A.5 Animator File Menu 
> Menu 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
COBOI 
tor 
Windows 
linen 
Guide 
and 
Tutorial 
File: The File pulldown m e n u in the Animator has four sections, and is s h o w n in 
Figure A.5. The first section included has the s u b c o m m a n d s New and Close, which 
allow the user to create a n e w file and to close the current file without stopping the 
Animator. This section has two types of O p e n instead of one as in m a n y W i n d o w s 
applications. The Animator can open files for Editing Only or for Edit and Execution. 
If Open for edit is chosen, the Animator looks for C O B O L source files with the 
extension "cbl." Figure A.6 shows the w i n d o w with the file selection. These files m a y 
be edited and checked (compiled), but cannot be run as programs. The edit m o d e is 
useful for initially writing programs a n d checking the syntax for errors. To test 
program logic, the program must be run in Edit and Execution M o d e . A n y n u m b e r 
of edit windows can be open at the s a m e time. 
Open for Edit Window 
. bwJt* is 1 >M 
F-^ILIM Is-' i hi 
»i -- - - '. Ii" 
The Open for execution m o d e , s h o w n in Figure A.7, expands the s a m e capability 
of the edit m o d e to allow program execution. W h e n selecting a file for the execution 
window, the Animator looks for "int" files. The "int" extension stands for intermediate 
file. T h e distinction is that intermediate files can be executed or run as well as 
edited. Intermediate files are created whenever a program is "checked." Checking is 
Micro Focus's term for compiling. Even w h e n a program is checked in an Edit 
window, an intermediate file is created. However, this file has to be loaded into the 
Execute w i n d o w to be run. 
Open for Execution Window 
iheJfeaQ;** ' 
patriot. «F$ 
$ zmm&m tri 
•i mmmwiu ml 
• \ 
1 
J 
i 
; -• 
•j 

A
p
p
e
n
d
i
x 
A 
M i c r o 
Focus 
Personal 
COBOL 
for 
Windows 
Useis 
Guide 
and 
Tutorial 
Referring again to Figure A.5, the second section of the File m e n u contains 
s o m e standard W i n d o w s options: Save (Ctrl + F2), Save As, and Save All. Save stores 
a copy of the current program onto disk. This action can also be accomplished by 
using the shortcut keys "Ctrl + F2." Save As makes a n e w copy of the current 
programs and allows the user to change the n a m e or location. Since Animator 
allows several program windows to be open at the same time, Save All simply saves 
the code and data in all open windows. 
T h e third section of the File m e n u provides tools for managing the current 
window. The Insert File option allows the user to insert code from another program 
file into the current program at the cursor location. The second option, Show/Hide 
copy file (Alt + F2), allows the user to determine whether C o p y files are expanded in 
the program or not. C o p y files are library files that allow C O B O L to use the same 
code in m a n y programs. See Chapter 16 for a further description. The Show/Hide 
feature allows the programmer to decide whether or not the contents of the C o p y 
file should be seen. In either case the program uses the C o p y files in the checking 
process. 
T h e last two sections of the File m e n u are Print and Exit (Alt + Q). Prim sends 
the program listing to a printer. Exit closes the program, and if any files have not 
been saved, the Message Box s h o w n in Figure A.8 appears. 
Exit Unsaved File Message Box 
, — — | 
| 
I . 
: 
| 
Edit Menu 
[3 
Edit: Figure A.9 shows the Edit m e n u . This m e n u provides useful tools for managing 
the entry and revision of source code. Entries in the first section of the m e n u allow 
the user to m a n a g e the changes to code. T h e first entry, Undo (Altl + Bspace), 

Appendix 
A Micro 
Focus 
Personal 
COBOL, 
for 
Windows 
Uieis 
Guioe 
an it 
Tutorial 
reverses the last change m a d e to the code during the current session. U p to 100 
changes m a y be undone, but only one action at a time and in reverse order. The 
Redo (Alt + Shift + Bspace) entry restores the change eliminated by the most recent 
Undo. 
The next two sections of the Edit m e n u allow the manipulation of text. These 
functions are contained in almost all W i n d o w s applications: Cut (Shift + Del), Copy 
(Ctrl + Ins), Paste (Shift + Ins), a n d Delete (Del). Cut removes highlighted text from 
the program a n d places it in the W i n d o w s clipboard. Text in the clipboard m a y then 
be placed into another section of the program, another program altogether, or 
s o m e other type of document. Copy places a copy of highlighted text into the 
W i n d o w s clipboard but does not remove the text. Paste takes text currently in the 
clipboard and inserts it into the program where the cursor is currently located. 
Delete removes the highlighted text, but does not place it into the clipboard. Once 
something is deleted, it can be retrieved only by using the Undo c o m m a n d . 
The next c o m m a n d , Mouse 
Column 
Marking, 
is a toggle c o m m a n d . If the 
entry is not checked, dragging the m o u s e highlights entire lines of code no matter 
where the cursor is located within the line. W h e n the c o m m a n d is checked, dragging 
the m o u s e operates to highlight only the columns within the line covered by the 
mouse. Figure A.lOa shows normal highlighting and Figure A.lOb shows C o l u m n 
marking. C o l u m n marking is similar to using a w o r d processor, but you must be 
careful about h o w m a n y lines are marked. 
Animator Highlighting 
. » » ( • 
[ I . 
H e l l o . 
1 **»W.ll f__S Hells. 
•aaJUl-., 
In the fourth section of the Edit m e n u are six tools for managing lines of text: 
Insert line (F3), Delete 
line (F4), Repeat 
line (F5), Restore 
line (F6), Split 
line (Ctrl + 
F5), and Join line (Ctrl + F6). 
These c o m m a n d s are largely self-explanatory. 
Insert line allows for a n e w line. 
* Delete line eliminates the current line. 
* Repeat 
line m a k e s a copy of the current line. 
' Restore line replaces the most recent deleted line. 

A
p
p
e
n
d
i
x 
A 
ro Focus 
Persona! 
COBOL 
for Windows: 
Users 
Guide 
and 
Tutorial 
* Split line breaks the current line at the current cursor location and creates 
two lines. 
• Join line combines the current line with the following line. T h e second line is 
m o v e d to the end of the first line. 
Each c o m m a n d has a shortcut key, and you m a y find using the shortcut keys 
to be faster than trying to do the same operations with the m o u s e or menus. 
T h e next section of Edit m e n u , Command 
(Ctrl + Fl 1), allows the user to use 
the C o m m a n d - p r o m p t editor tool. The C o m m a n d - p r o m p t editor is the list box 
(Figure A. 11) at the right side of the screen o n the s a m e line as the tool bar. This 
editor allows the user to enter editing c o m m a n d s . There are too m a n y c o m m a n d 
options to discuss here, but they are all available in the Animator Help system 
under the entry. A simple example of the c o m m a n d line use w o u l d be to enter "goto 
10" in the c o m m a n d prompt. T h e w i n d o w m o v e s a n d displays the tenth line of 
code. 
figure A . 1 1 Command Prompt Editor 
•stf .• 
v * : ^ ' . 
1*133 
lit 
lb 
€<st 96 P*K ami 
i|uin • i] 
INUiKOHTOHJ ktdZICM. 
Wl» fcltflSIOK. 
WUMMG 
TuKk'.i S I C M O N . 
T h e next section of the Edit m e n u contains two c o m m a n d s : Find/Replace 
(F2) 
a n d Clear finds. 
Find/Replace 
allows two different types of finds: C O B O L item 
information is s h o w n in Figure A. 12, and Text is s h o w n in Figure A. 15. In the C O B O L 
Item Information m o d e , the user can enter the n a m e of a data item or a paragraph 
n a m e . T h e Find operation locates and highlights all occurrences of that data item or 
paragraph including the definition of the item. T h e usage of the data item within a 
line is described in columns 1 to 6. Such messages might include "Defn," "Mod," or 
"Use." 
FI 
Find Window 
COBOL Hem informs 
Ltttfff a COBOL procedure- or data 
Hem 
to rind ilcUHed 
[ntomialtoft on its 
uu*. 
Hnil: sflttttatlnn 

Appendix 
A Micro 
Focus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
The C O B O L item information find w i n d o w contains a pulldown list of the last 
several items that have been found, and several buttons: 
OK processes the request and brings up a monitor screen, as in Figure A. 13, 
that displays statistics of the item.
1 Also note that a line has been marked 
with the "Defn" message. 
« Options brings u p a screen that allows changes to the types of entries found 
in Figure A.51. 
• Suggest produces a list of data items, such as those s h o w n in Figure A. 14, that 
might also be of interest. This option works only if at least one entry has been 
m a d e in list box. 
» Cancel stops the Find process. 
» Help brings u p a Help screen explaining the Find Dialog Box. 
: 
COBOL Item Found 
m 
•I* 
: y 
B ti%g—s t® pan* kfl /~rt~~ leue 
s i z n 
r e f s 
' J I . H N R S ' A N O N 
* m i : : i o t t . 
P V » . M * 
I B . H o l l o . 
U K 
M ! H . \m. 
«oa*i«', ifosaci 
•vxia*. 
i !••» j 
I • - • i l - 
iiriii^ 
l i i i i ' 
<j|,1lim 
, 
H r l p 
Find Window With Suggestions 
tEZ',.,?*Z.~ » j:, .ri^iii^WatiiwiW!^*.! rtWiit'rW»ifmiliii , nj..:.f 
£ * 
I ^ ^ W - ' V * 
W**53*>-
sransmono 
.end 
of 
t e x t . 
Type: ^ C O B O L Item taformstiun r Jcxf 
[ nSer a C O B O L p r o c e d u r e or d a t a 
Hem is find d e t a i l e d 
i n f u r i n a t i o n on fts use. 
M u d : 
salutation 
The second type of Find/Replace is the m o r e traditional find a n d replace 
c o m m a n d s h o w n in Figure A. 15. Find/Replace allows the user to search for any type 
of text in the code, both forward a n d backward, and to view one entry at a time. T h e 
user m a y also replace the selected text with n e w text. 

A
p
p
e
n
d
i
x 
A 
M 
-o Focus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
Find Window For I ext 
The Text m o d e finds occurrences even in c o m m e n t lines. O n e unique feature 
of the Text find m o d e is the ability to "Find All" occurrences of the text. This option 
works similarly to the Find C O B O L Item m o d e in that it highlights all occurrences of 
the text. However, the message in columns 1 to 6 is simply F I N D . 
The Clear finds c o m m a n d removes the markings placed by either the Find 
C O B O L Item or Find All. 
The last item in the Edit m e n u is the Edit lock C o m m a n d . W h e n Edit lock is on, 
the W o r d "EditLock" shows o n the Status Bar, as in Figure A. 16. Edit locking prevents 
the user from changing the source code by mistake. The user m a y want to use this 
feature w h e n examining code that should not be changed. 
View: Figure A. 17 shows the View m e n u . View allows the user to m o v e about within 
the program code. C O B O L programs tend to be long and sometimes difficult to 
maintain o n the screen. T h e tools in the view m e n u allow users to m o v e easily 
around the program and to keep track of their work. Y o u m a y notice that the last 
entries in the m e n u are unavailable. They b e c o m e available only w h e n checking 
determines that there are syntax errors. Figure A. 19 shows the m e n u w h e n a syntax 
error has been found. 
Interface with Editing Locked 
ESS 

A
p
p
e
n
d
i
x 
A 
Micro 
focus 
Personal 
COBOL 
for Wm,tow$ 
i ' s t i s 
Qun1& 
a no 
iuior 
st€tfjtfe 11.17 View Menu 
The Align (Ctrl + A) command adjusts the entries on the screen so that the 
current line moves to the third line of the screen. 
The Where 
(CAT) + W) command is available only in Execute mode. When a 
user is debugging a program and looks at another portion of the program, 
Where 
allows the user to get back to the current program execution line. 
The Last edit position 
command is similar to Where, but allows the user to go 
back to the point where the last program change was m a d e . 
Collapse 
copy files is similar to the Show/Hide 
copy files in the File m e n u . If the 
copy files are in expanded m o d e , the user can use this c o m m a n d to reduce them to 
nic single y^yjt i suueiiieui. 
The next section of the View m e n u deals with placing and removing Tags. 
Tags are simply markers the user can place in the source code to save time moving 
from place to place. T h e Set Tag (Ctrl + T) c o m m a n d marks the current line with a 
tag, as s h o w n in Figure A. 18. T h e Unset Tag c o m m a n d removes the Tag from the 
current line a n d Clear All Tags removes all of the Tags in the program. 
The final section of the View m e n u allows the user to m o v e quickly through 
the program. T h e first two c o m m a n d s , Go to Next Tag and Go to Previous 
Tag, 
control m o v e m e n t to tags set by the user. 
The last three c o m m a n d s of the View m e n u are available only during the 
checking process if there are syntax errors. Figure A. 19 shows the m e n u with these 
options available. Notice also that the lines in error are marked. T h e c o m m a n d s 
allow the user to Go to Next Error, Go to Previous 
Error, a n d Go to Current 
Error. T h e 
last c o m m a n d is useful w h e n the user has m o v e d to s o m e other location in the code 
trying to determine the nature of the problem and wants to return to the current 
error. 

Appendix 
A Vn.o 
i
:ocus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
figure 
A . 1 9 View Menu when Syntax Errors Exist 
pss^*^^- d^-s Qp&&r& Hmd^ g**^ 
#1: tfttyj.yj?! 
ESQ* 
Compile/Run: T h e Compile/Run M e n u , s h o w n in Figure A.20, provides s o m e 
powerful tools for checking a n d debugging of programs. T h e first entry is simply 
Compile 
Program. 
Compile 
Program 
checks the syntax of the current program for 
errors. If the w i n d o w is in Edit m o d e , Compile 
Program a n d Compiler 
Directives 
are 
the only options available. Figure A.21 shows a compile in process with an error 
message. Figure A.22 shows the results of the compile with lines containing errors 
highlighted and a separate w i n d o w showing the error messages. If the current line 
is a n error line, the information area at the bottom of the screen also shows the error 
m i 
i i . ' m i , 
Figure A.20 Compile/Run Menu 
iflllflttllfi 
:j'::|||fif|
; 
1^§|l§t| 
m 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
n>t 
Windows 
Users 
Guide 
and 
Tutor,al 
Compile Processing Windows 
1 
i/ i OFIER^Ld Aht 
dri.ldif.si 
I ONTiNUI f'HlCHN! ,«G'.IUM '' 
f».. H'l!> 
* ' Curieiltt!!> 
hILlQbClit 
',i 1., 
'. m i ' 
ill 
1* . 1 . . 
iK,r 
i 
\ 
*',e*CTt 
. I 
» Col.»«-tslit <C> )»••,-!»« Micro V... «.. Ltd. 
noee "Rello wop id." ta an ttrtlutat 
Mm 
Results of Compile with Error 
. i t 
ri • 
2 4 
2S> 
: 
» r f l , 
i l l 
.end s»f e e « 
r/ ^ Em*T.«fsf£ AN i-. on* rtri 1 •»«•!*«) 
The next section of the Compile/Run M e n u allows the programmer to run the 
program o n a step-by-step basis. Step (Ctrl + S) allows the programmer to execute 
the program one step at a time. Step Over (Ctrl + Z) skips the current line and allow 
execution at the next line. However, if the current execution point is a P E R F O R M , 
Step Over executes the perform at full speed a n d stops on the statement following 
the P E R F O R M . 

A
p
p
e
n
d
i
x 
A 
'
;s> Focus. 
Personal 
tJOBOl 
lor 
Windows: 
Users 
Guide 
and 
Tutorial 
Step All runs the entire program at reduced speed. W h e n Step All is selected, 
Animator displays the dialog w i n d o w in Figure A.23, allowing the user to select the 
speed of display, to stop the execution, or to run at full speed. T h e speed of execution 
m a y be modified by clicking o n the scroll arrows. The slowest speed is 1 and the 
fastest speed is 6. 
Step All Control Window 
H*m 
Mel*,. 
i 
— 
Coivrols 
nessing 
The final option in this section of the Compile/Run M e n u is Watch. Watch acts in 
the s a m e w a y as Step except that, as each line is executed, the value of the data items 
for that line are displayed in monitor windows, as in Figure A.24. This option allows 
the programmer to examine the processing as it occurs. 
A . 2 4 
Stepping Through Program using Watch Option 
. J 
'11.11. UOl-llI" 
The third section of the Compile/Run m e n u allows ways for the user to run a 
program portion or the entire program at full speed. T h e capability allows the 
programmer to execute tested portions of code without having to step through each 
line. The first option is Run Return. Use this option w h e n the current execution point 
is within a Perform. Run Return executes the rest of the Perform at full speed and 
stops at the first statement after the end of the Perform. A c o m m o n error is to use this 
c o m m a n d w h e n the program is not in a Perform. As a result, Animator returns an 
error message box as s h o w n in Figure A.25. The message m e a n s that the execution 
point is not within a Perform and therefore the c o m m a n d cannot be processed. 
Message Indicating Run Return Cannot be Processed 
I 

Appendix 
A 
Micro 
Focus 
Personal 
COtiOt 
tor 
Windows 
User 
A m o r e general and more useful c o m m a n d is Run to Cursor (Ctrl + KJ. Run to 
Cursor allows the user to position the cursor at s o m e point ahead of the current 
execution point and then run the program at full speed u p to the line where the 
cursor is located. 
The final c o m m a n d in this section is Run (Ctrl + F12). This c o m m a n d runs the 
program until the end. 
T h e next section of the Compile/Run m e n u involves Skip c o m m a n d s . 
Programmers should use Skip c o m m a n d s with caution. Skips allow the programmer 
to avoid executing s o m e lines of code. The danger in doing this is that key actions 
m a y not be executed or that key data m a y not be changed; the results m a y be 
unpredictable. 
The Skip c o m m a n d s are straightforward. Skip Statement 
means that the current 
statement is not executed and control moves to the next line of code. Skip 
Return 
a n d Skip to Cursor (Ctrl + H) are similar to Run Return a n d Run to Cursor, but no 
code is executed. T h e final Skip c o m m a n d , Skip to Start, repositions the execution 
point at the first line of the program. However, no values are reset a n d no files are 
closed. If the programmer wishes to start the program from the beginning, Restart 
Application 
is m o r e useful. 
Restart 
Application 
is the fifth section of the Compile/Run M e n u . This 
c o m m a n d resets all of the values in the program, closes the files, a n d resets the 
execution point to the first line of the procedure division. 
The final section of the Compile/Run M e n u includes Compiler 
Directives and 
Application 
Command 
Line. Compiler directives are c o m m a n d s that dictate h o w 
the compiler works with the source code. Since the use of directives is an advanced 
topic, this chapter does not deal with them. Students should ask their instructor for 
any compiler directives to be used. 
Application 
Command 
Line brings up the Input box s h o w n in Figure A.26. The 
user can then enter data for the program to use. T h e program accesses the 
information by using the A C C E P T . . . F R O M C O M M A N D - L I N E statement in a 
program. In the example, the statement "accept salutation from command-line" 
places the words " D e m o Data" into the data item "salutation." As a result, the 
output of the program is " D e m o Data" rather than "Hello World." This option 
allows the programmer to have the program get data from outside without having 
the operator enter it. W h e n the program encounters a n A C C E P T . . . F R O M 
C O M M A N D - L I N E statement, the program reads the data placed in the Input Box 
into the variable specified by the A C C E P T statement. 
Entry of Command Line Data 
' 
t 
. s i ii .'t iiS.i 
S 3 K E 8 
i a t e * n e w a p p i £ t 8 & a » mmm$m4 Uttts 
.OK | Cornel; Hrly $ 
4 
Program uses this 
line to access data 
| 
entered in input box 

A
p
p
e
n
d
i
x 
A A'M 'O focus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
Debug: Along with the tools in the Compile /Run m e n u , the Animator provides 
another set of tools, s h o w n in Figure A.27, for debugging programs. Breakpoints are 
major tools for debugging. A simple breakpoint, like that in Figure A.28, marks a line 
of code in m u c h the s a m e w a y as a Tag. However, w h e n a program is executing and 
encounters a breakpoint, the program stops. Tags do not stop execution. A 
programmer can set a breakpoint at the beginning of a problem area in code. T h e 
p r o g r a m m e r can then run the program at full speed until it encounters the 
breakpoint. T h e program stops a n d the programmer can then step through the 
problem area to try to detect the nature of the problem. 
,27 
Debug Menu 
£13 
E 71 j 
•Jj 
llli I 
ilif I 
-'igure A.28 Setting Breakpoints 
•1 
.• tat it int. 
Breakpoint mark • 
While the simple breakpoint is a useful tool, the Animator also provides a set 
of breakpoints with advanced features. T h e first section of the m e n u deals with 
setting and removing breakpoints. T h e Set Breakpoint (Ctrl + B) c o m m a n d sets a 
simple breakpoint at the cursor location. Unset Breakpoint removes the breakpoint 
at the cursor location. A breakpoint can also be set by double-clicking o n the 
C O B O L verb in the statement. Double clicking the verb again unsets the breakpoint. 
Set Advanced displays the dialog w i n d o w s h o w n in Figure A.29 a n d provides 
several options for breakpoints. 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
tor 
Windows 
Useis 
0moe 
and 
Tutorial 
<& 
& & & & 
T 
C
^
T
R
.
M
«
^
T 
D . . ^ ~ L , . ^ ~ ; ^ 4 - ~ 
r Bytirt: M . X » 
u
s
e 
u i 
o i m c i n c i i i 
u i c a r \ | _ > u n 
1 1 0 
Statement button , 
checked 
Staiament breakpoint 
f 
C o n d i t i o n 
tS^y} t»<Mr. 
U«>«'< C««w«! ttefrj 
J2szi2iiki 
• Standard—The 
normal breakpoint m o d e as described above. 
• Statement—Allows 
the programmer to enter a C O B O L statement into the 
Parameter field to be executed w h e n the program reaches the breakpoint 
location. This feature allows the programmer to try out a statement without 
recompiling the program. The execution does not stop at the breakpoint, nor 
does the entered statement replace the breakpoint statement. T h e 
temporary statement executes before the breakpoint statement. In Figure 
A.29, the parameter box statement m o v e " D e m o Data" to salutation is the 
breakpoint statement. " D e m o Data" replaces "Hello World" in the data item 
"salutation." As a result, " D e m o Data" is displayed as in Figure A.30 rather 
than "Hello World." 
• Data Change—Allows 
the programmer to specify a data item in the 
parameter field to be watched by the program. Figure A.31 shows the data 
item "salutation" in the Parameter box. Whenever the data changes in 
Salutation the program halts at the next executable line. This feature is a help 
to find h o w data items acquire unexpected values. Only one Data 
Change 
breakpoint m a y be specified per program. 
• Program—Performs 
a break w h e n the specified program is entered. This 
feature is useful w h e n the system uses subprograms, or in an Object 
Oriented system that invokes other objects. Only one Program 
Breakpoint 
m a y be specified at a time. 
• Condition—Stops 
execution of the program at the breakpoint line only if 
s o m e specified condition is met. The condition is specified in the Parameter 
box and cannot be specified in the form of a C O B O L statement. In other 
words, use "salutation = 'Hello world'" rather than "IF S A L U T A T I O N IS 
E Q U A L T O 'Hello world.'" Figure A.32 shows the correct specification. 
• Until—Similar 
to Condition, 
but tests the condition o n every line of code and 
not just a breakpoint line. Until shows exactly where the condition has been 
m e t but slows d o w n the execution of the program, because each line must be 
tested. 

A o p e n t t i * 
A 
' 
ocus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
Figure A . 3 0 Output of Statement Breakpoint 
Output message——— 
BHHH|HjHHHH ] 
Figure A.31 Setting a Breakpoint on a Change in Date 
Data change selected 
Type: <~ Standard 
Parameter: 
* fi»t» disogr 
C CsmMlaa 
c Until 
Tested data item 
Figure A.32 
Setting a Breakpoint for Meeting a uondition 
Breakpoint message 
Condition selected 
M r e W / 
display talut«tl»n 
Every; 
fypt-: •'S'amfsi'ii 
HxKiflcr: isalaUrtfon » "Hello w w W 
r Srstegjent 
r JJata ctmrtge 
r~ gregtam 
~ 
- » Condition 
UfltH 
' Set] Date! I C»«url i H<lf 
Condition being tested 
| 
The Advanced dialog box also includes two text boxes—the Parameter box 
and the "Every" box. The Parameter box allows entry of values for all breakpoint 
types except Standard. The Every field allows a periodic use of the breakpoint. If the 
program is in a loop a n d the programmer wants to execute the breakpoint every 
other time, 002 should be entered in the field. 
The second section of the D e b u g m e n u allows m o v e m e n t from one breakpoint 
to another. Show 
Next 
Breakpoint 
m o v e s forward through the code from one 
breakpoint to the next. Show Previous 
Breakpoint 
m o v e s backward to the previous 
breakpoint. 
T h e third section of D e b u g is the single statement Clear All Breakpoints. 
This 
c o m m a n d allows removal of the all breakpoints with a single c o m m a n d . 

p
p
e
n
d
l
x 
A 
Micro 
Focus 
Personal 
COBOL 
for 
Windows 
Users 
CUnae 
and 
futensil 
The final section of Debug provides s o m e other debugging tools. 
Examine 
Data 
( F l l ) allows the user to view the contents of a Data item. This c o m m a n d 
brings up the Examine dialog box as in Figure A.33. The dialog box works similarly 
to the Find COBOL Data Item box. OK displays the value of the c h o s e n value and 
allows actions to b e taken on the data. Cursor 
m e a n s that the item currently located 
by the cursor is to b e displayed. Suggest 
presents a list of user defined n a m e s and 
allows the user to c h o o s e one. Cancel 
and Help allow the user to quit the process or 
to seek further help from the system. 
Examine Window and Suggested Item List 
inti 
__HOTB 
Once an item h a s been c h o s e n a n d provided that it is a valid data item, a 
monitor w i n d o w o p e n s showing the current value of the item. Figure A.34 shows an 
example of the window. The w i n d o w allows the user to see the contents of the 
w i n d o w and to change the value. As a result, the user can "fix" the data item if 
necessary. 
4 
Examine Monitor Window 
current venie 01 aata item - — — - — . — — — 
mrii 
SALUTATION 
*v*>vj m
*
. Jj*—"^ "*"•_] 
The Do Statement 
c o m m a n d also helps the user to temporarily fix a problem 
without recompiling a n d restarting the process. Selecting Do Statement 
brings u p 
an input w i n d o w as in Figure A.35. The programmer can enter a single COBOL 
statement and have it executed. The function is similar to a Statement 
Breakpoint, 
but here the COBOL statement is executed immediately and does n o t require a 
breakpoint. 

A
p
p
e
n
d
i
x 
A 
'..>. 
•,• • 
ens 
Personal 
COBOL 
li.i 
Windov,-s 
Users 
Guide 
and 
Tutorial 
Figure A.35 Use of Do Statement 
The final option in the D e b u g m e n u is Backtrack. Backtrack allows the user to 
step backward and forward from the current execution point. For this option to be 
available, the user must specify the Backtrack on option from Execute options under 
the Options M e n u . 
-satire. 
Ontions Menu 
*» y . * 
tf 
-22 
H D O F 
KVXt. 
Options Menu: T h e Options M e n u , s h o w n in Figure A.36, provides a n u m b e r of 
advanced capabilities for the Animator users. This m e n u manages the user interface 
and allows each user to individualize the Animator to his or her o w n taste. The lull 
customization capability for most items is beyond the scope of this chapter, but 
s o m e features m a y be appropriate for the student programmer. 
The first option of the Options m e n u is Configure Interface. This option provides 
a selection of five dialog screens: 
• Toolbar—Allows configuration of the Toolbar options including the position 
of the toolbar and the buttons contained in the toolbar. 
• Buttonbar—Manages 
a bar that has similar functions to the tool bar but uses 
words instead of icons to s h o w the c o m m a n d . The button bar is not a default 
configuration, but s o m e users m a y find it to be useful. 

Appendix 
A Micro 
Focus 
Personal 
COBOL 
tor 
Windows 
Ui-ei s isiitde 
and 
Tutorial 
® Keys—Allows the user to examine a n d define special key combinations for 
executing c o m m a n d s or running macros. 
« Macros—Allows writing and editing of routines for performing a series of 
steps with one step. Macros are n a m e d a n d can be assigned to key 
combinations. 
* General— Manages the general appearance of the Animator Screen. 
The Toolbar dialog screen in Figure A.37 controls whether or not the toolbar is 
visible. The default is visible a n d positioned at the top. The visible toolbar can be 
top, bottom left, right, or as a free-floating bar. T h e user can also add, delete, or 
m o v e various functions to the tool bar. T o m a k e the changes to the current toolbar, 
the user needs to click o n one of the icons in the Current toolbar window. This 
action sets the focus in the w i n d o w a n d activates the buttons at the bottom of the 
window. Students should not m a k e changes to the toolbar unless directed by the 
instructor. 
Configure Toolbar Options 
r* bar vtsibfc 
S** Mian 
*
s Jttp r Bottom 
" Left r Right 
* Detach 
r mu nt toolbar 
Copy 
£ 
Undo 
\
f l»tep 
%\ 
WiXrh 
Av<ui<sb«- {un< torn 
:0|.c 
PageDown 
Pane-Op 
iPara&ttwn 
i'A U 
Pa*!rC!tp3 
(**^iel tip* 
PastrCJipb 
P««.trOip7 
Gprnc an existing file 
1 
* 
"I 
_4 
'1 
*| of program 
The Button Bar option, as s h o w n in Figure A.38, allows the user to have a 
similar function to the toolbar, but instead of showing icons the buttons use words. 
The default for the button bar is visibility off. The student m a y want to turn visibility 
o n since s o m e m a y find the button bar to be useful. T h e standard button bar is 
s h o w n at the bottom of Figure A.39. This discussion does not deal with it further. 

A
p
p
e
n
d
i
x 
A 
A 
us 
Personal 
COBOi 
lot 
Windows: 
Users 
Guide 
and 
Tutorial 
Figure 
Configure Button Bar Options 
^nec'K 
io 
rnaKe 
DUiion 
bar visible 
Configure button bar 
\ OttfQn 
Cmtt$i& buittm fear 
Run retarst 
Hun 
•find... 
'•••end-
Available functions 
:-
: C o m m a n d s 
~ Maemn 
"Align 
<% 
Arraagc-fctonltors 
^ 
sedate 
Axttofix 
Mat* ( f k 
-flJgPatfeOfj 
Bottom 
Center 
thangefrir 
.•Check 
Dc<?nip(uin 
igure A.39 Interface with Button Bar Visible 
:||||tili§^ 
S S 3 
ynmand prompt 
J 
til :.*>l;ii *>r l«n 
Standard button bar 
The A'cy.s- option in Figure A.40 is for users w h o prefer to use special keys for 
most functions rather than using the toolbar or m e n u s . T h e option allows the user 
to specify the key combinations to be used. Specifying additional special keys should 
be d o n e with caution until the user understands the Animator C o m m a n d s 
thoroughly. 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
COBOL 
for 
Windows 
User 
"ICS&0 
Configure Special Keys 
Keys 
P T C B S the hey required: 
Alt»R !« mapped to the command RunRtn. I 
A 
I 
• L U I R 
S I T - 
U R L P 
Available ftmctfaiis 
^ Comirtaiifis n Miu-ns 
HunThru 
Save 
SavcAii 
SsveAs 
SaveConfig 
rSaveProgram 
ScfoHBars 
SetectAH 
SetAdvOri; 
iSetBik 
SrtCiiinr 
OeutTiptiuit 
. J T 
I xecule* remaining 
statements irt persurm 
rsege/call 
The Macros option should also be used with caution. This option, s h o w n in 
Figure A.41, allows the user to run a series of c o m m a n d s at one time. A macro is a 
simple program that executes c o m m a n d s in sequence. Once a macro has been 
developed, it can be saved for further use, a n d a key combination can be defined in 
the key option a n d used to execute the macro. 
The General option in Figure A.42 is the last of five interface options. This 
screen controls three elements of the Animator text editor: 
8 Information 
Line 
• Status 
Line 
Command 
Prompt 
In addition, General controls the "Hinting" capability. The information line 
and hinting go together. T h e Information 
Line defaults are Visible a n d Bottom, 
meaning that the line is present at the bottom of the screen. Several of the screen 
pictures s h o w the information line. In Figure A.36, for example, the Information 
Line says "Executes all statements at full speed (shortcut key is Ctrl + F12)." If you 
m o v e the m o u s e over the tool bar or the button bar, you see a definition of the 
button in the Information Line. This process is called Hinting. O n c e y o u b e c o m e 
familiar with the Animator, you m a y choose to turn the hinting function off. 
The Status Line is found under the toolbar at the top of the screen, as s h o w n in 
Figure A.39. This line tells h o w m a n y lines are in the program, the current line 
number, the column within the line, a n d the perforin level of the current line. (A 
perform level greater than one m e a n s that the current line is part of one or m o r e 
Perform statements.) T h e Status Line should be kept visible. 
The C o m m a n d Prompt, also s h o w n in Fig ure A.39, should remain o n the 
toolbar rather than being detached. If the C o m m a n d Prompt is detached, it is not 
visible unless requested by using Command 
in the Edit m e n u or Ctrl + FIT. 

A
p
p
e
n
d
i
x 
A V»;< - a Focus 
Persona! 
COBOL 
tor 
Windows: 
Users 
Guide 
and 
Tutorial 
figure A.41 
Configure Macros 
'onngurt 
Macros, 
Macro dlr : <carre«t dlrsctoty> 
I'ntttrtera 
PcrlMrf 
bSHeip 
P O U M p 
Olillirlp 
tiCOfiHelp 
CI iBHeto 
linpfill 
I'.ditteirt 
tinier maau te^ffunettons itere*' 
£svc Assise 
ftl£,t,J £«m^f j Bi«4,,„ j 
j 
ties** i*«v«| Help | 
A v i K n b i e t u n c t l o n e 
5 Cotrnnaods
 r v . 
ItonRbi 
fluorhnt 
sSitve 
S a v e All 
: S a v c A * 
Savr CG«ft§ 
3 s v r Program 
S a a l t U a r i i 
ScqNo& 
SetAdvHrJe 
;SetBrfc 
:&etC»Inr 
LJ 
Description 
"3 
Configure General Options 
Lonngure general 
options 
Information Line 
I 
* Bottom 
_ . t Status line 
• -
.S&jj; PVI.il.lc 
S T o p 
JBtHm". 
r Bottom 
I ( Command prompt 
C Detach 
Htatory ["to"] 
. 
On toolbar 
I 
Hinting 
P Enabled 
W h e n mouse over Item 
C W h e n H e m selected 
01 
The next section of the Options W i n d o w deals with the Font a n d the Color 
schemes used in the screen. Figure A.43 shows h o w the Font section allows the user 
to change the default font type. In addition, the font can m a d e bold, italic, or both. 
Font also allows the user to m a k e the character size larger or smaller. T h e Script box 
is for advanced applications b e y o n d the scope of this discussion. 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
for 
Windows 
Users 
Quiae 
and 
Tutorial 
Font Selection Window 
f 
* ******** 
{ T Com**)! H*i» 
|lt<I&i. 
jfa 
1 I llllfid ' »fi. M 
il(MU ! . K. 
1 -
iii r: H i »i- n-ji i 
ON 
Co/or allows the user to change the color scheme of the source code. This 
color coding is very useful in identifying the purpose of various words in the code. 
Students should look through the default color scheme carefully to learn what the 
colors m e a n . There are two sets of colors. T h e General set s h o w n in Figure A.44 
refers to the color schemes for marking lines, margins, and other items. The Syntax 
set, in Figure A.45, manages the color scheme for verbs, data items, reserved words, 
a n d other types of text. 
A.44 Configure General Color Scheme Window 
Vtortifjw* T;»IJITF. 
I (to 
.mrt 
A/HIM 4* I» S 
okm 
"Tad 
C Execution line 
r BacMracfc line 
r Breakpoint Knee 
*" Syntax error Imrs, 
i urcgraund 
•' Block marks 
" Tag lines 
C (tod line:. 
R' Margins 
tSarJegrosma' 
BUCK 
WIIIU 
The Animator provides several default color schemes. The color schemes can 
be altered by clicking o n the Default Schemes button in either the General or the 
Syntax window. T h e button brings u p the list box s h o w n in Figure A.46. Students 
w h o work primarily o n a m o n o c h r o m e monitor should investigate Plasma Bright or 
Plasma Powersaver. Other students m a y want to consider using Preprocessed color 
s c h e m e rather than the Default. In the Default color s c h e m e the colors for 
unidentified items are white o n magenta. This combination of colors can be 
annoying. In the Preprocessed color scheme, the unidentified words are black o n 
white. 

A
p
p
e
n
d
i
x 
A 
ii 
Focus 
Personal 
COBOL 
for Windows: 
Users 
Guide 
and 
Tutorial 
Syntax 
color 
schemes 
\ 
Press for 
additional 
Color 
Schemes 
^Comments 
rvcrbk 
C Reserved Words 
r Procedures 
r Identifiers 
r Undefined tttrm 
| 
S» Colorize syntax r Colorize CICS r Colorize SOL 
i cfcgmund 
BackgreimrJ 
'BLACK 
jf JWHITE 
J 
i 
mm ooctiotq TO QBcDt'rc 
1 
Figure A.46 Alternate Color Scheme List Box 
jMonochrome 
sPtasms Bright 
Piasmi Powersaver 
iPreproceeosed 
U 
: 
.... 
The next section of the Options M e n u deals with configuring the interaction 
with the Animator. Generally the n e w programmer should not deal with these items 
until experienced with the Animator. The first option, Edit options, has three dialog 
screens: 
• Profile—Controls 
the format of the Animator Source Entry window. The 
student programmer might want to make o n e change to t h e profile. If the 
instructor requires programs to be written in U p p e r Case, t h e Force capitals 
option could be useful. Figure A.47 s h o w s the Configure Profile window. 
• Global— The w i n d o w s h o w n in Figure A.48 controls behavior of the 
Animator i n using external sources to the process. The clipboard used, 
external files, a n d typing controls can b e modified in this w i n d o w . The 
student programmer generally should leave these options alone unless 
required by the instructor. However, the backup files o n saving and warn o n 
loading read only files options could prove to b e useful options. Note that 
automatically backing u p files uses additional disk space. 
• Autofix—Figure 
A.49 s h o w s the Autofix option that allows t h e programmer 
to enter c o m m o n l y misspelled words and to have the Animator 
automatically correct t h e m . To add words to the defaults given, click o n the 
Add button. 
,.45 Configure Syntax Color Scheme Window 

Appendix 
A Micro 
Focus 
personal 
COBOL 
rot 
Windows 
Users 
Gmue 
and 
tutorial 
• i g u r e A.47 
Configure Edit Profiles Window 
CutrrdS pinMe t, i OiK>L 
Available pralite® 
"J ^ I ile , m COBOL : ixmr 
Tab (K>»Mi>t»: ;<* 
j 
*•*" 
F Cantprr.KS spaces ta txb tftacmVrrt 
P W a n t wrap P Autn-lntlcfll r"r orce nstpilals 
Hk-t 
" L)e*eti ASCII cr*4 at t.l« 
Assouan? proSte wi* exanciant: -CSt C P t COB INT (SPACE! 
Scare* lot C O W extemfawi: 
gVCTO 
I*, tmp 
4 8 
Configure Global Settings Window 
i»y*stem 
" t CiLiil 
T Miibiwrt/delete cm itjrmrr: right-hand roarqm 
R Ralmu( replace previous character with space 
P Wrap lines, an ruboui 
r W r a p lines on rtefctt 
r NewtJne esn %rx»re light-hand margin 
P Cut can tsjKoic right hand margin 
P W a r n K block nasties right hand margin 
" Backup Blew when saving ——-
" W a r n on loading read outy files 
P Wmn oa loading shared file; 
J 
f~ Rea# onSy^iecked lifer. ts» he edited 
P I.eeSc evened sinrnx (Hes 
r Pr&Sed; ospy flies against edStinjj 
The Execute Options of the Options m e n u brings u p the dialog box in Figure 
A.50.The five check options include: 
• Hide on Run—The 
default m o d e that hides the Animator Text w h e n the 
program is running at full speed. 
• Backtrack on—Causes 
Animator to maintain a history of the steps taken in 
running the program. Is used with the Backtrack option of the D e b u g m e n u . 
• Set Threshold level— W h e n turned on, tells Animator not to s h o w the actions 
taken at a level below the current level. In other words, the steps in a perform 
or a call can be hidden. 

A
p
p
e
n
d
i
x 
A 
>•*, 
r-ocus 
Personal 
COBOL 
ioi 
Windows- 
Users 
Guide 
and 
Tutorial 
Analyze—This function is not available in Personal C O B O L . 
Edit lock on execute—is option keeps the user from making changes to the 
program while it is in the execution phase. The function is intended to 
prevent accidental changes to the program. This is the s a m e function as Edit 
lock in the Edit m e n u . 
Configure Autofix Words 
Aiilftl i* rfMrie-, 
H&mtm m y typing 
If H 
Ui»nge it fa thin: 
the" 
Find options is the third option available in this section. Again, Find options is 
generally best left alone by the student programmer. Figure A.51 shows the C O B O L 
data item finds. O n c e programmers have b e c o m e experienced in debugging 
programs, they m a y want to explore s o m e of the options here. 
»0 Execute Options Window 
P Hide sn Hun 
"~ F}aiilfat k >»« 
r &st threshold levcJ 
f* finely ;?e 
r l do \ock oft execute 
0fe I 
Hrfe 

Appendix 
A 
Micro 
Focus 
Personal 
COBOl 
t,.u 
IVi/suou s 
Uian 
Ouicin 
a n i l
 
Tu;or,a! 
Configure Options for Find 
I tint i apUoi 
" COBOl Eracedure finds 
> C00OI 
item tm®$ 
COB'4 J. 
rt. .n 
r Oiiofity related d»t* 
^ Oiii^Uay sft^ftiefs M 
tern 
tmms ts height 
•'»' Display 
Sines 
ORV disfssay wb?rs tisfa is. M*»«*<t«*d 
C Onty ditpiay wtirie data is ijefcnrd 
P Dtspiay nrQtffdufK^ usimj ?r,e rlata stem 
The final section of the Options M e n u contains toggles for turning o n or off 
some of the screen tools. The first option is Scroll bars. The scroll bars are the arrows 
on the right side a n d bottom of the window. T h e use of the scroll bars allows rapid 
m o v e m e n t to portions of the source code not currently visible on the screen. There 
is probably no need to turn off the Scroll Bars, but if the Scroll Bars are off, the user 
can still m o v e within the source code by using the arrow keys and by using Tags and 
Breakpoints as discussed in the View a n d D e b u g M e n u s . 
Tills option sliows or hides t h v 
numbers in columns I to 6 of the source lines. T h e default is off, but at times these 
numbers m a y be useful particularly if the status line is not visible. Figure A.52 shows 
a program with sequence numbers. 
User Interface Showing Sequence Numbers 
Ml IP II, 
LFTI?iiiirrnlm'IJJ 
The final option is Tag markers. Again, this is a toggle. Tag markers are messages 
in columns 1 to 6 as in Figure A.53a. If Tag Markers is off, the messages are not 
shown, but the tagged lines are still highlighted as s h o w n in Figure A.53b. T h e 
tagged lines m a y be Tags, Breakpoints, or F o u n d lines. If both Sequence Nos. a n d 
Tag Markers are on, the Tag Marker overrides the line number. 

A
p
p
e
n
d
i
x 
A 
\h. 
i 
i-ocus 
Personal 
COBOl 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
Fi< 
A.53 Tag Marking 
lag Markers 
2bi 
, « N T L 
S F 
T E X T 
. . . . . . 
„j^j< 
l a r k e r s 
1X1 
nr. «tf «' ' . K W » W ! H \ " . A M > " T T 
(1 TILL INt ( I V F C K . ML 
t W O * 
' ' ' ' i i i t i s a 
I:I 
S « L ^ T « « I » N 
P I E 
X < 2 8 > . 
V T E P 
R U N 
» J 
YRT*<rJ»*^j. 
(b) Tags will 
W i n d o w M e n u : Figure A.54 shows the W i n d o w m e n u . This m e n u is useful w h e n the 
programmer is working with m o r e than one program at the s a m e time a n d while 
debugging programs. R e m e m b e r that while only one program can be in execute 
m o d e , any n u m b e r of programs can be in edit m o d e . T h e first option of the W i n d o w 
m e n u is Tile. This option allows the programmer to view two or more programs at 
the s a m e time. Only one program has the focus at one time. This program is s h o w n 
o n top a n d with the full width of the window. A n y other program windows are 
s h o w n across the bottom. Figure A.55 shows three programs in tile m o d e . U p to 
three programs can be s h o w n across the bottom at one time, even though the 
programmer m a y be working o n m o r e programs. 
Clicking o n one of the w i n d o w s will shift the focus to that window, and the 
programmer m a y change code in the window. Shifting the focus to one of the 
windows o n the bottom of the screen does not m o v e that program to the top. In 
order to m o v e this program to the top half of the screen the user must again select 
Tile. If the user double-clicks o n the title bar of a window, that w i n d o w is expanded 
to full screen. Double-clicking again on the title bar will return the w i n d o w to its 
original size and location. 

Appendix 
A Micro 
Focus 
Personal 
COROL 
tot 
Windows 
U s e r s 
Guide 
and 
1 
ulortal 
•mm 
.54 Window Menu 
— ,4cf/i/e Proorams 
: i g u r e A . 5 5 Three Tiled Programs 
/ me bar 
Program with focus 
| Partial code shown 
I 
„ 1, M 
•, 
pit 1 
*r
; :<h>c ^*0&iwMtc*MllfrWb 
kMt 
H t V B ' 
?IKP;^J1 ji>. (telle. 
_ l 
sc.:H 
ui '.am. 
If. 
- I - . I TIT. TON 
j**.; 
X < 2 8 > -
. J . 
•J 
_ A L . 
iUiSLsi 
• F 
S Army 
"ofHUtiEICEOEES;" 
; ^ •• 
C A L E N D E R - T U T I N 
< 
. 
* 
rt ~-i fin* iuit -rfa£K-««ni|»ulafcli 
1 
v < alrndvr sl r«ttn 
;V GI»RIERI*DT.OL I T I F T LUN 
'OF I 
-J 
¥•& stoma 
in it 
tz-n^fi I I M L - S T I O N . 
D * V 
fID- 
H I 
• 
lllillll 
W h e n showing multiple programs, the Animator shows only partial lines of 
code. Using the scroll bars, the user can view the remaining code to the right.
2 
The next option Arrange Monitors is available only to a program in Execute 
m o d e . Monitors are the small windows that display the value of data items. If there 
are a n u m b e r of monitors being used and if the user m o v e s them around, not all of 
the monitors m a y be visible. Arrange Monitors organizes the monitors along the 
right-hand side of the w i n d o w for better visibility. Figure A.56a shows the monitors 
before alignment, a n d Figure A.56b shows the monitors after alignment. As can be 
seen in the figures, the alignment m a y not impose visibility m u c h . T h e user can 
always drag the monitors to where they will be m o r e visible. 

A
p
p
e
n
d
i
x 
A 
W-- 
id
 
,:ocus 
Personal 
COBOL 
tor 
Windows: 
Users 
Guide 
and 
Tutorial 
.56 Arranging Monitor Windows 
£fe %•& %*m £J&$&°£<.<J& 
^ra*** |i^J> 
"Bella wsrlci" fca saltstation 
:::r 
24 
.end ei? fce&fc. 
H^ndow hidden 
(a) Monitor Window 
. 
. . 
^lljltlllltttii 
•t 
.... .. 
. , . 
.- 
- 
.•rVt.-.-^iS-r.^.m 
21 ?ROCfcB*Ifck Insli^EfeW. 
^ ^ " B c l l o world'* t** !. tllit.tt ioo 
.ef.rt of te* 
' 
i '•'*'
,:'
 
| , = J r • 
Windows moved 
to right 
ridow partially 
lidden 
(b) Monitor Windows After A r r a n g e m e n t 
The final section of the W i n d o w M e n u in Figure A. 54 shows the n a m e of each 
program currently being used by the Animator. T h e user can click o n any of the 
n a m e s and m a k e it the current program. T h e listing also shows the m o d e of the 
programs. 
Help Menu: The Help M e n u s h o w n in Figure A.57 contains a n u m b e r of items that 
can help the user while in the process of working with the Animator. Several words 
of caution are necessary, however. Personal C O B O L for W i n d o w s emphasizes Object-
Oriented C O B O L . While a student m a y want to explore this topic in m o r e detail, the 
chapter o n O O C O B O L should be reviewed before getting too involved with the 
tutorials and the use of the browser. Also, the help files were originally developed 
for other Micro Focus products a n d in s o m e cases referenced topics have not been 
included. Attempting to access t h e m produces a n error message. Finally, in s o m e 
cases the references for "hot words" are actually o n the s a m e page as the hot word, 
a n d clicking o n the hot w o r d returns the screen to the top of the page, in this case, 
the user should scroll d o w n to the point where the topic is discussed. 

Appendix 
A Micro 
Focus, 
Personal 
COftOt 
lot 
Windows 
• Useis 
Gu:Ov 
and 
fulonai 
Figure A.5? 
Help Menu 
^i^^f^fe A ' ^4 ~~ 
. . . 
. . 
. . .«•!!!{ Ot ! t 
Since the Help process is meant to be self-explanatory, this discussion is 
limited to brief descriptions of the more useful topics. Explore the Help m e n u 
options for yourself. 
The first set of topics under the Help m e n u are Animator Help a n d Keys Help. 
The Animator 
Help should be useful in learning h o w to use the Animator. M u c h of 
the material in this discussion has been based on the Animator Heln, 
Keys Help provides the user with a table of the key combinat ions used m 
editing programs in Animator. This table can be a good source for programmers 
w h o prefer to use keystrokes rather than the mouse. The student m a y want to print 
this screen for further reference. 
The second section of the Help M e n u contains tutorials and advanced topics 
options. Start Here actually is an introduction to object-oriented programming, a n d 
probably is not the best place to start in connection with this book. T h e student 
should hold off o n this section unless otherwise instructed by the teacher. In the 
section On-line 
Tutorials 
and Reference, the beginning programmer should look at 
the Animator Tutorials and leave the Browser and O O C O B O L tutorials for later. In 
regard to References, the most useful section for the beginning programmer is the 
System Messages section. This section provides a point for looking up error message 
to see what has gone wrong with a program. Those messages take two forms, 
compiler messages—messages w h e n trying to write the p r o g r a m — a n d run time 
messages—messages w h e n trying to test the program. The other reference topics 
are advanced in nature. 
The Resources 
section of the Online 
Tutorials 
and Reference has s o m e items 
that m a y be useful. The most useful resource is the Glossary, which is a dictionary of 
terms. 
Standard 
COBOL Reference is the most useful option for the purposes of this 
book. Students should review the topics presented, but should not b e concerned if 
they do not understand a lot of the information presented. COBOL Source 
Syntax 
m a y be the most useful section for the student. However, the same type of help is 
available m o r e directly. B y moving the cursor to a C O B O L verb in the source a n d 
pressing Alt+Fl, the Animator brings u p the help screen for that verb. Figure A.58 is 
the help screen for the IF statement. In m a n y cases, the Animator Help has m o r e 
than one screen relating to the topic and it displays a list of options. The option 

A p p e n d i x 
A 
Micro 
Focus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
n a m e s in this list are not always helpful. T h e student should just pick one. If the 
wrong option is chosen, most help screens have hot words, a n d the user can usually 
find the needed information quickly. 
Stl 
Example of Syntax Help Window 
IF 
;»>*—Ifr condi t ion-
•i 
1—r~s t a f eraen l -1 
j 
* 
**THEM* «—fi£XT SEMTEHCE*-* 
MJTrCRWI SE-J L*EXT SEKTEHCE-
t atcnent 2 -
Re.«ted Topics: 
_ 
J 
Object COBOL Reference a n d Q'ass Library 
Reference deal with O O C O B O L a n d 
are probably best left until the programmer is ready to deal with O O topics. 
About Animator 
displays a n information screen about the version of Animator 
and current resource statistics. 
T h e Toolbar, s h o w n in Figure A.59, is the set of 16 icons displayed below the m e n u 
line along with the C o m m a n d Prompt box. T h e icons are a quick w a y to perform a 
limited set of the m e n u operations. C o m m a n d prompt allows direct entry of 
Animator c o m m a n d s . 
* 
Animator Toolbar 
The Toolbar groups the icons by their functions. T h e first set of icons deals 
with file handling, the second with editing source code. T h e third set is a single item 
to u n d o changes. T h e fourth set is for debugging while the fifth set handles 
breakpoints a n d tags. T h e final set allows compiling programs a n d the help. 
Set 1: T h e first two items: 
» Load, a folder with an arrow, allows the user to load a file for editing (not 
execution). Clicking o n the Load icon brings u p the O p e n dialog box which 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
(
\
W
i
n
o
n
w
z 
ih*ei 
$ HiUJe 
Bn-d 
9. 
displays the "cbl" files in the current directory. The user must use the m e n u 
tf\ 
F V R I ri ( T I N O F I L O fVi.r O R L I ^ - O N H 
£±-v£j.r*ntir\Tr\ 
\ V/ u t l i j . ^ i i i «_* 1 . 1 1 V 1 T J 1 . 
I, U I . 1 U I j A l j ^ C i L H J
1 ! ! . 
Y
I 
* Saive, a diskette, saves the file in its current form to the disk. Saving files 
regularly is always a good idea. 
Set 2: This set of icons consists of: 
> , 
• Cut, a pair of scissors, removes highlighted text and places it into the 
W i n d o w s Clipboard. 
* Copy, two pages, places a copy of the highlighted text into the W i n d o w s 
Clipboard. 
! 
• Paste, clipboard with a page, copies the current contents of the Clipboard to 
the current location in the code. 
S o m e words about the Clipboard. Only one item can be placed into the 
clipboard at a time. Therefore, if something is already in the clipboard and the user 
cuts or copies a n e w item, the original item is overwritten. The clipboard is not 
limited to just the current window. The clipboard makes it easy to cut or copy code 
from one program and place it in another program in a second window. The 
clipboard can also be used with another W i n d o w s product so that code from a 
program could be copied into a word processor, for example. 
Set 3: 
/j 
» Undo, a curved error pointing to the left and d o w n , restores the text to the 
previous state. The icon is active only w h e n s o m e change has been m a d e to 
thif* 
n m u r a n i 
/ fnrln 
rt*Qtt\r&c 
t i n 11\ 1 O O 
r h y n a p c 
^ 
» . . _ j j . „
0 
. . 
„ 
»„c 
. . . J J 
— . . 
Set 4: This set of buttons is available only in the Edit + Execute window. These 
buttons allow the user to control the process of reviewing code as it runs. 
\ 
• Step, a footprint, allows the user to "step" through the program one line at a 
time. 
v i j 
* Watch, a footprint and a magnifying glass, works in the same w a y as Step but 
also displays monitors of the data values for items in the current line of code. 
Examples of a monitor are s h o w n in Figures A.56a and b. Watch is 
particularly useful in debugging code. 
X ] 
« Run, a figure "running," executes the program at full speed. 
~ «J 
* Examine, a magnifying glass, allows the user to look at the contents of any 
data item whether or not it is part of the current execution line. This icon 
represents the s a m e function as "Examine Data" under the D e b u g m e n u . 
Clicking Examine brings up the s a m e dialog w i n d o w s h o w n in Figure A.33. 
jg
 
8 Find, binoculars and lines of code, brings up the Find dialog w i n d o w from 
the Edit m e n u and s h o w n in Figure A. 12. Find allows the user to search for a 
C O B O L item or specific text. 
Set 5: Set 5 consists of 3 buttons that are active only w h e n the user has set 
Breakpoints, Tags, or Finds in the code. If more than one type of marking is being 
used, clicking on any of the buttons will bring up a m e n u to select the desired type. 
• ToggleCompress— arrowheads pointing toward the center of the b u t t o n — 
causes only the highlighted code lines to be visible. W h e n the code has been 
compressed, the arrows change to point to the top and bottom. Clicking 
again expands the code to its original state. Figures A.60a shows an 

A p p e n d i x 
A Micro 
Focus 
Peisonal 
COBOl 
tot 
Windows: 
Users 
Guide 
and 
Tutorial 
uncompressed portion of a program. After compression the same code looks 
like Figure A.60b. 
• Previous—short lines and an arrow going from bottom to t o p — m o v e s the 
current location to the previous marked line. 
• Afexr— short lines a n d an arrow going from top to b o t t o m — m o v e s the 
current location to the next marked line. 
Section 6: T h e last section of the tool bar contains two buttons. 
• Check—a check mark—compiles the current program. Micro Focus uses the 
term Check for compile. 
!1J 
Help—a question mark—brings u p the Help Screen. 
re A . 6 0 Example of Expand and Compress 
i <« rtr.fottm an (
M
M 
emi 
2i7<* 
31* 
HI 
? » 
m 
as 
Ti
4 
Hi 
I K 
2 1 * ' 
. 
, 
I 
• ' i l l i i 
fa! E j 
m 
m 
tUjt ttf H&*t. . . .. . 
PBtFOSl Lo*4-ReearA 
fiwam 
Stunt- Record 
<ssirf Kr *<**t 
-a 
i| Program Compressea; 
%»i:wUw 
C^v, 
This w i n d o w allows the user to enter Animator c o m m a n d s directly instead of using 
the m e n u or the toolbar. T h e C o m m a n d Prompt box maintains a history of the last 
10 c o m m a n d s entered so that a previously entered c o m m a n d m a y he reused. Figure 
A.61 s h o w the C o m m a n d Prompt with a list of c o m m a n d s . 
The Animator c o m m a n d s are available in Animator Help under the topic 
C o m m a n d Reference. 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
i : i ) B O i 
/ • > / Windows 
Users 
Guide 
and 
T u t o r i a l 
Command Prompt Box with Recent Commands 
-
d 
2 4 
a.: 
Highlighting: W h e n code is highlighted in the Animator, the entireline is highlighted. 
This feature is unlike a standard w o r d processor where highlighting is independent 
of the lines. This factor can be disconcerting w h e n the user just wants to change one 
word. However, the developers of the Animator felt that in most cases program 
code is m o v e d or changed a full line at a time. Thus, highlighting the full line was a 
better default. 
To highlight only a portion of a line, use Mouse Column Marking in the 
Edit m e n u . 
M o u s e Buttons: Clicking the right m o u s e button in the source code displays a list of 
options that can be performed. The options depend on the context, a n d a typical list 
is s h o w n in Figure A.62. 
Shortcut Keys: Programmers should take s o m e effort to learn s o m e of the shortcut 
keys to facilitate their entry a n d maintenance of code. S o m e of the m o r e important 
keys include: 
F l --Help 
F 2 --Find 
F 3 - -Insert Line 
F 4 - -Delete Line 
F 5 - -Repeat Line 
F<>--Restore Line 
111 — E x a m i n e Data 
Ctrl + B — S e t Breakpoint 
Ctrl + R — R u n to Cursor 
Ctrl + S—Step 

A
p
p
e
n
d
i
x 
A 
Micro 
f-ocus 
Peisonal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
Options List after Right Click on "Display" 
Si%1ilmt$hWi:Bs 
Loading Errors: In working with Animator in Windows95, occasionally a load error 
occurs. S o m e compatibility problems seem to exist between W i n d o w s 9 5 and the 
Animator, but usually these are resolved by restarting the Animator. 
The Animator uses several file types w h e n compiling programs. T h e user should be 
careful about deleting files through the operating system. S o m e of the more c o m m o n 
fife types include: 
• cbl— standard file for containing C O B O L code. These files are text tiles and 
can be edited by any text processor. 
» cpy—files containing portions of C O B O L code. These files are called by the 
C O P Y c o m m a n d in a C O B O L program. 
• int—intermediate files. These files contain the object code needed to run 
and edit a C O B O L program. T h e checking process creates int files. 
* idy—utility files. These files allow Animator to s h o w the source code while a 
program is being executed. 
* osv —autosave files. These files contain a copy of the work in process a n d 
m a y be used to recover programs if there has been s o m e problem. 
Execute Window: T h e Edit a n d Execute w i n d o w is most generally useful w h e n 
developing a single program. Only one Execute w i n d o w can be o p e n at a time. In 
this w i n d o w the program can be edited, run, and debugged. 
Edit W i n d o w : Edit w i n d o w s can be used for writing a n d changing programs and 
checking syntax. They cannot be used for running the program. However, as m a n y 
edit windows as necessary m a y be opened. This feature is particularly useful w h e n 
the m a i n program (in the Execute window) calls subprograms. B y having the 
subprograms in Edit w i n d o w s the programmer can quickly m a k e changes in the 
subprograms, check t h e m immediately, and then run them from the m a i n program. 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
io> 
Windows 
Lrseis 
Guide 
and 
Tutorial 
The purpose of this tutorial is to guide the student through a session with the 
Animator. At the end of the exercise the student should be able to: 
» Start the Animator. 
^ Enter data. 
* Edit and change text. 
" D e b u g and test a program. 
Y o u can start the Animator by selecting the Personal C O B O L button either in 
the Personal C O B O L w i n d o w in W i n d o w s 3.1 or in the Personal C O B O L section of 
the Start M e n u in Windows95. After showing a title screen, the Animator will b e c o m e 
active and will look something like Figure A.63. W i n d o w s 9 5 was used in preparing 
these exercises and your screen m a y look slightly different. Y o u m a y want to increase 
the screen to full size by clicking o n the appropriate icon in the upper left corner. 
Animator Interface 
1 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Check Register Program 
Narrative: 
This program processes any hours worked by employees file, calculates the gross pay, 
and prints the results on a report. 
Input File(s): 
H O U R S - W O R K E D 
Input Record Layout: 
See Figure A.64a 
Test Data: 
00001TANNER, J 
2050400 
00002SOLIGO, K 
1875350 
00003LIGHTF00T, J 2575450 
00004SCHLESSER, J 1500400 
00005WINDS0R, C 
1250415 

A
p
p
e
n
d
i
x 
A 
Mn m 
Focus 
Personal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
Report Layout: 
See Figure A.64b 
Processing Requirements: 
1. Print a heading at the beginning of the report. 
2. Read a file of employee hours worked records. 
3. Process each record by: 
a. Computing gross pay by multiplying pay rate by hours worked. 
b. Printing a detail line for each record read. 
Figure A. 64 
Record Layout for Check Register Program 
ID# 
: 
N A M E 
P A Y R A T E 
; 
HOURS 
j 1 2 3 4 5 i 6 7 8 9 1 0 1 1 1 2 1 3 
14 15 16 17 ^ 18 19^20 ! 21 22 23 24 25 i 25 26 27 
JCHECK REGIjSTER 
j 
I 
999919 XXXXXXXXJXXXXXXXX99J.9 9 9 . 9 9 9(999 . 99 
9999^9 X X X X X X X X|X X X X X X X X 9 9I. 9 9 9 . 9 9 
9 9 9 9 . 9 9 
Please enter the program s h o w n in Figure A.65 into the Animator. Type the 
program exactly as it is written. Be careful to start each line in c o l u m n 8 a n d to type 
the periods where they are placed. There are s o m e deliberate errors in the program, 
but do not correct t h e m yet. 
Figure A . 6 5 Tutorial Program 
1 
IDENTIFICATION DIVISION. 
2 
PROGRAM-ID. CHECK-REGISTER. 
3 
AUTHOR. 
YOUR NAME 
4 
5 
ENVIRONMENT DIVISION. 
6 
INPUT-OUTPUT SECTION. 
7 
SELECT WEEKLY-HOUR ASSIGN TO 'H0URS.DAT 
8 
ORGANIZATION IS LINE SEQUENTIAL. 
9 
SELECT REPORT-FILE ASSIGN TO 'CON' 
10 
11 
DATA DIVISION. 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
for 
Windows 
Users 
Guide 
and 
Tutorial 
, . - - > . 
Continued 
12 
FILE SECTION. 
13 
FD WEEKLY-HOURS. 
14 
01 HOURS-RECORD. 
15 
05 HOURS-ID 
PIC 9(04). 
16 
05 HOURS-NAME 
PIC X(15). 
17 
05 H0URS-PAYRATE 
PIC 99V99. 
18 
05 HOURS-WORKED 
PIC 99V9. 
19 
20 
FD REPORT-FILE. 
21 
01 PRINT-LINE 
PIC X(80). 
22 
23 
WORKING-STORAGE SECTION. 
24 
01 HEADER-LINE-1. 
25 
05 
PIC X(10) VALUE SPACES. 
26 
05 
PIC X(18) 
27 
VALUE 'CHECK REGISTER
1. 
28 
05 
PIC X(10) VALUE SPACES. 
29 
30 
01 DETAIL-LINE. 
31 
05 
PIC X(05) VALUE SPACES. 
32 
05 DET-ID 
PIC 9(05). 
33 
05 
PIC X(01) VALUE SPACES. 
34 
05 DET-NAME 
PIC X(15). 
35 
05 DET-HOURS 
PIC 99.9. 
36 
05 
PIC X VALUE SPACES. 
37 
05 DET-PAYRATE 
PIC 99.99. 
38 
05 
PIC X VALUE SPACES. 
39 
05 DET-GROSS-PAY 
PIC 9999.99. 
40 
41 
01 EOF-SWITCH 
PIC (03) VALUE 'NO '. 
42 
43 
PROCEDURE DIVISION. 
44 
0000-MAIN-LINE. 
45 
PERFORM 1000-INITIALIZATION 
46 
PERFORM 5000-PROCESS-CHECK 
47 
UNTIL EOF-SWITCH = 'YES' 
48 
PERFORM 9000-FINALIZE 
49 
STOP RUN. 
50 
51 
1000-INITIALIZATION. 
52 
OPEN INPUT WEEKLY-HOURS 
53 
OUTPUT REPORT-FILE 
54 
PERFORM 1100-WRITE-HEADER 
55 
PERFORM 1200-READ-RECORD. 
56 
57 
1100-WRITE-HEADER. 
58 
WRITE PRINT-LINE FROM HEADER-LINE-1 
59 
AFTER ADVANCING PAGE. 
60 
61 
1200-READ-RECORD. 
62 
READ WEEKLY-HOURS 
63 
AT END MOVE 'NO ' TO EOF-SWITCH 

A
p
p
e
n
d
i
x 
A M- m• Focus 
Peisonal 
COBOL 
for 
Windows: 
Users 
Guide 
and 
Tutorial 
lliure A.65 
Continued 
64 
END-READ. 
65 
66 
5000-PROCESS-CHECK. 
67 
MOVE HOURS-ID TO DET-ID 
68 
MOVE HOURS-NAME TO DET-NAME 
69 
MOVE HOURS-PAYRATE TO DET-PAYRATE 
70 
MOVE HOURS-WORKED TO DET-HOURS 
71 
MULTIPLY HOURS-PAYRATE 
72 
BY HOURS-WORKED 
73 
GIVING DET-GROSS-PAY 
74 
END-MULTIPLY 
75 
PERFORM 5100-PRINT-DETAIL 
76 
PERFORM 1200-READ-REC0RD. 
77 
78 
5100-PRINT-DETAIL. 
79 
WRITE PRINT-LINE FROM DETAIL-LINE. 
80 
AFTER ADVANCING 1 
81 
END-WRITE. 
82 
83 
9000-FINALIZE. 
84 
CLOSE WEEKLY-HOURS 
85 
REPORT-FILE. 
W h e n you have finished entering the program, check the program by clicking 
o n the Check M a r k in the tool bar. The Animator will p r o m p t you to save the 
program. Save it as Chkreg.cbl. 
The Animator then begins to check the program a n d soon finds an error. Y o u 
should see message boxes similar to those in Figure A.66. The message boxes in the 
figure have been m o v e d to m a k e t h e m m o r e visible. 
-igur< 
.66 
Compile Error Windows 
MNNMNNNMfiiHiii 
mi 
BUCIIFLRL- 
I I ) . 
C H E C K - B E G I 
V O U B 
HTLFTT 
L W I S ' J K M - N ) 
U I U I S L O * . 
I N P L ' I 
« H , \ S F 
S E C T I O N . 
5 L L C O T 
W E E K I S - M O U R 
B S S J C N 
waNisatfioN u uttm I 
S L U C F 
R E P O R T - F I L E 
S S E I S M 
M I L L 
T L U ! , 
! 3 K . 
(urrcnt Ule 
Lines checked ; 
Errors 
: 
Severe 
CHKUtG.CBl 
OGQGflfl 
1 
Warnings 
6 
Informational : 0 
W E E X I V 
H O U R S . 
8 1 
H O U R S - R E C O R D . 
8 5 
H O U R S - I D 
8 5 
H O U R S - N O M E 
8 5 
H O U H S - P F L V B O T E 
8 5 
H O U R S - W O R K E D 
F B 
R E P O R T - P I L E . 
8 1 
P R 1 N I 
L I N E 
8 1 
H E R D E R - L I N E 
1 . 
as 
S» C O P Y R I G H T 
- X > 1 9 8 5 - 1 9 9 6 
H I C I - O 
P O C U S L T D . 
I 
S E L E C T 
U E E K L V 
H U U R 
A S S I G N 
T O 
' H O U S 
I 1 8 8 4 - E 
C O N T I N U A T I O N 
C H A R A C T E R 
E X P E C T E D . 
E N D 
CARTEci I 
l 1004-E Continuation character expected. End of literal assumed. 
1 CONTINUE CHECKING P R O G R A M ? 
ho 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
COBOL 
for Windows 
i
'
s
«
s 
Guide 
and 
Tutorial 
The Checking message w i n d o w has four buttons: 
» Z o o m — c a u s e s Animator to check the rest of the program without stopping 
until it is through. 
• Y e s — h a s Animator continue to check the program and stop at the next error. 
» N o — s t o p s checking the rest of the program. 
* Help—Brings u p a help screen that attempts to explain the error. 
Y o u should click o n the Z o o m button to check the rest of the program. 
At the end of the checking process, you should see something like the screen 
in Figure A.67. T w o windows can be seen, but tend to obscure each other. Y o u m a y 
want to m o v e one of the windows so that the screen looks like Figure A.67. The first 
w i n d o w shows the program source with all error lines marked and highlighted. The 
information line at the bottom of the w i n d o w shows the error message for the 
current error line. The second w i n d o w contains a list of all the error messages and is 
called the syntax error window. D o not be surprised at the n u m b e r of errors found 
during the first check of a C O B O L program. A large n u m b e r of errors is c o m m o n 
w h e n a program is checked the first time. In m a n y cases, one syntax error m a y 
cause a n u m b e r of error messages. 
? Results after Syntax Checking 
; ; t a I l l I i S 
* 
» 
H UI 
1 
i * 
0,4 T, , ,< / y 
S, ,.,J.E,. 
US HCAIRS- IV 
***** 
I-
X<(.5>. 
wot. 
2<T~£ 
I? \ 
HII % 
23»-S 
?«« 
1J-S 
12-$ 
33»-S 
12-S 
* * W » T L 
LITERAL fvpt'< t,M 
»P«-,»O!T » I Kl *R HIHBTI, is TINT declared 
t l i * . . . i f „ i FIR i'. 
,1 TILE n&tw 
p i e n i s . 1 .trtr°Q H.J. , llpqat PRI?E<?DT*NT:S* OR IL.LEN.AI CHARACTER 
id mi, tnij mr iIII- iK.tn.i-mm 
©NERANO t m i w i f t j s H NOT d e i L.UV,; 
Doer Mid UEIKIV H8URS IS Hot DECLARED 
Hot .] record n^Me 
ILPER.MD WCEKIV-HOUB!. IS NOT ILMLARED 
Operdnrl 111! SMltCB IS BAT 
taliiH 
ft -IEEPP-DOL IMTI*R DID NOT tuvr * (STERLING OERB JND »<*'* DISCARDED. 
HOT 4 RECORD NANC 
t i e r , COGNISED UERFE 
8PER.MIL WE MI V l i o u a s I& NOT DECLARED 
«f 
„ Sl*l«a* i i*«Ul« 
There are several ways of moving around to see the errors. O n e w a y is to 
double-click o n a message in the syntax error window. The Animator will m o v e the 
cursor in the source code w i n d o w to the appropriate error line. This action associates 
the messages with the actual lines. Within the source code w i n d o w y o u can m o v e 

pendix 
A 
M 
Petsanai 
COtfOi. 
fot 
Windows 
Users 
Guide 
and 
Tutorial 
from one error line to the other by clicking the Find Next or Find Previous buttons. 
As you change from one error to another, the Information Line will contain the 
error message for the current error line. 
Y o u m a y also want to see the error lines by themselves. T o do this, press F9 or 
click the Compress Button, s h o w n in Figure A.67, to s h o w just the error messages, 
as in Figure A.68. Y o u m a y need to expand the size of the w i n d o w to see all of the 
messages. 
Look at the first error line. The message is "Continuation character expected. 
E n d of literal assumed." The problem here is that H O U R S . D A T has a quote at the 
beginning and not at the end. Data file n a m e s need to be expressed as alphanumeric 
literals a n d enclosed in quotes. T o correct this problem, insert a quote after the 
w o r d D A T . 
M o v e to the next error. Here the error message, "Numeric literal expected," 
does not help in detecting the problem. The compressed m o d e also tends to confuse 
the issue. Expand to the full source code by pressing F9 again or clicking o n the 
Expand key s h o w n in Figure A.68. 
Compressed List of Error Messages 
{iii 
wtj» at ip 
Jrr»r>- if 
tktGfit fl.'.t . 
Mrni-' *l 
for-nil! a. 
J",f»S-.fr> 
LOP t>*ilCU - iri^" 
%'mr> 
MM* MW>n < «<»iir. 
The problem is actually in line 9. S E L E C T statements m u s t end with a period. 
Since the period is missing, C O B O L attempts to include the D A T A DIVISION 
statement as part of the S E L E C T S T A T E M E N T . C O B O L detects that there is an error, 
but unfortunately does not give a helpful message. Place a period at the end of line 9 
to correct the problem. 
This particular error demonstrates several rules of t h u m b in debugging C O B O L 
programs. 
1. Periods are c o m m o n sources of error because they are often misplaced or 
omitted. 
2. The compiler m a y not be able to determine that an error has occurred until 
checking the following line. 
3. All error messages should be examined, but sometimes they are misleading. 
Use the Find Next and Find Previous buttons s h o w n in Figure A.68 to m o v e 
through the rest of the errors a n d notice the messages in the Information Line. Try 
to understand w h a t C O B O L is saying about each error. 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
COBOL 
:•),< 
i-Vm.foiv.s 
t/s^« » Guide 
.*/>!/ 
!«;•••;«; 
Notice the message " W E E K L Y - H O U R S not declared" in line 13. The problem 
results from the spelling of " W E E K L Y - H O U R " in the S E L E C T statement in line 7. 
Incorrect spelling of user defined n a m e s are also a major cause of syntax errors. The 
spelling needs to be changed in the S E L E C T statement. 
M a k e sure that the W E E K L Y - H O U R S is spelled correctly, the quote is inserted 
at the end of line 6, and a period at the end of line 9. Insert a period a n d the end of 
line and recheck the program. After checking the program, compress the source to 
just show the error lines again as in Figure A.69. 
Errors after Second Compile 
The first error is because the PIC clause does not specify the data type. Correct 
this line by inserting an "X" before the "(03)" so that the line reads: 
01 EOF-SWITCH 
PIC X(03) VALUE 'NO '. 
This correction will clear up the problems with the next two errors. Since E O F -
S W I T C H was not valid, any references to it are invalid as well. Correcting the one 
error will fix the other two as well. 
M o v e to the last line that says "AFTER A D V A N C I N G 1" and expand the source 
using F9. Figure A.70 shows the result. Using the rules of t h u m b from above, you 
should notice that there is a period at the end of line 79. In this case, the period 
should not be there because A F T E R A D V A N C I N G 1 is part of the W R I T E statement. 
Delete the period and recheck the program. 
This time the program should compile without errors. If your program still 
does not compile, you have m a d e other typing errors. Reexamine the code in Figure 
A.65, m a k e the necessary corrections, and recompile. 
Figure A.71 shows the fully compiled program. Note that the buttons allowing 
testing of the program are n o w active. If the buttons are not active, y o u probably are 
working in an Edit window. If so, close the w i n d o w by using the File m e n u . Save the 
file if necessary. N o w , in the File m e n u , select O p e n for Execution and select the file 
Chkreg.int. This action loads the file to the Execute W i n d o w , where it can be run 
and tested. 

A
p
p
e
n
d
i
x 
A 
-Micro 
fo^us 
Personal 
COBOt. 
tor 
Windows 
Users 
Guide 
and 
Tutorial 
Figure A.73 Invalid Period Error 
**» 
rmf 
l l h f 
- M l S . ' i 
UHS . 
8 « 
>.'.(•'... 
-•fid o f t »jtt. 
invalid period 
:I|}iire JL71 
Compiled Program—Ready to Run 
iflltflf|fli^lfe!siiiflsl|f^^ 
tf. 
f £ 
:i;iiiilii*i£tj 
At this point, you are ready to test the program, but need data. Click o n the file 
m e n u and select N e w . This action opens a n e w Edit w i n d o w where you can create 
data for the input file. However, the Animator thinks that you have opened the file 
to enter C O B O L source code and the cursor is positioned in column 8. T o m a k e 
things easier for entering data, select the Options m e n u and select Edit options. In 
the profile screen, select D O C U M E N T S from the Profiles list box. As a result, you 
should see the specifications as in Figure A.72. Click on the Set as Current Profile 
Button and then Click o n the O K button. Y o u will n o w be able to enter data. 
Enter the data s h o w n in Figure A.73 exactly as shown. T h e numbers begin in 
column 21. If you wish, you m a y a d d s o m e other records to the file. After you have 
entered the data, select Save As from the File m e n u . Save the file as H O U R S . D A T . Be 
sure that the file is saved in the s a m e directory as your program. 
N o w return to your Program. R u n the program by clicking on the R u n Button. If 
Animator gives a "File Not F o u n d Message," either the file is not in the same 
directory as the program or the file n a m e has been misspelled. Y o u can correct the 

Appendix 
A Micro 
Focus 
Personal 
COBOL 
for Windows 
Usei s Guide 
and 
Tutorial 
»-i>^ - .A. 
Configure Profile for Entering Data 
C u n m t pioftii. is. COBOl 
Avtttiitrie (Mrohieu 
^, 
~~ U',r tins, pfitfiic for pr .-lues; 
'SYSTEM 
IC0B01 
"*' 
ruifijuii 
Margins: UK tiOO m^,, (ibi 
Sr(hi«i WMIM, i 
• L . 
Tab poatajarrs: 
r Compress space-, to tab chatacters 
P Word-wtap 
Auto-indent T rorca capitals 
Hies 
f Delect ASCII end al-filr 
As-.odaie pratiie wdo extensions: pOC 1XT 
ta< rol'/rxarmUons. 
i 
Create Data File 
«M8l tUHMl-R. J 
»BH82SOI,IG0, K 
utwaiuoirpoor. J 
•aMHSCHLEMHi. J 
w>M5uiimo». c 
2S784SB 
.«nd of text:. 
—^RRRR^R-»N-RFW™T™r«' 
— ~ 
S« 
I'tVOIJ1 ' . • 
. >• • . 
H 
l i w o a h • •-. . 
H 
urn it m t m - u m 
, » ' . * 
H U M 
« 
L I K I 
H T IB HUJUmlk, 
r»_: _ 
I K 
« 
« . ' 
if
1 
problem by correctly spelling the file n a m e and using by the full path to the file in its 
S E L E C T statement (line 6). Recheck the program and try again. 
The program should halt with a message "Illegal character in numeric field 
(Error 163)." This type of error is very c o m m o n and usually results because the 
program file specifications do not match the actual fields in the file. Click on the O K 
button. Your program is redisplayed, as in Figure A.74, with the line in error 
highlighted and the error message redisplayed. Click on the O K button again to 
clear the message box. 

A
p
p
e
n
d
i
x 
A 
.'. 
Personal 
COBOL 
tor 
Windows 
Users 
Guide 
and 
Tutorial 
Figure A . 7 4 Error Detected 
jjjjjjjl 
1 
62 
S3 
h ^ R S U O R K L D ^ 0 DEI 110 
.' ' " 
HOURS P a V R R U 
BV 
HOURS-tJORKED 
.;j ,\" DEI CROSS-PR* 
iv ; ft,,. > Ji> J 
'. t 1 '"V 
• I 1-1 
U.'IU I'RIN, I.IHl 
int.? jti»*; 
Ji«< 
" I T . " ! - . 
B11B!§~ 
zrror message 
Line 69 should read " M O V E H O U R S - P A Y R A T E T O DET-PAYRATE." Click o n 
the word H O U R S - P A Y R A T E . Clicking o n a Data N a m e brings u p a monitor window, 
as in Figure A.75. The monitor w i n d o w presents the data in two forms: 
• The left side shows the ASCII values for the field. In this case, "20" is the 
ASCII value for a space. 
• The left side shows the text values for the field. The first character is in fact a 
space. 
Since, spaces cannot be part of a numeric field, the error message w a s correct. 
The problem is to determine h o w the space got there. O n e w a y to find out is to 
"correct" the data item and then step through the program. T h e cursor should be 
blinking o n the first 2 of ASCII values field. Change the 2 to 3. This converts the 
character to a zero. Look at the text values to confirm that the change has been 
m a d e . N o w , click o n the Apply button. Y o u have n o w fixed the error so that the 
program can continue. 
Using the W a t c h Button, step through the program. As y o u go through the 
program, notice the monitor windows. Y o u should see that the values s e e m to be 
low. Finally, you should c o m e to the Detail-Line monitor box, as s h o w n in Figure 
A.76 . Notice that the n a m e field begins with a " 1." S o m e h o w part of the ID n u m b e r 
has gotten into the N a m e field. 
Figure A . 7 5 Monitor Window of HOURS-PAYRATE Field 
H.dX'i _ _ 
«8 
rt'l MOH „ ' 
6S
: 
VI 
™— tWJ i. N U U 
s 
msynpi.^! 
. T . . 
IHt j Hontiut ] 
11 
I« 
1 
• • 
IHt j Hontiut ] 
'/I 
STLY 
• 1 
7*J 
'•• 
U 
I N 
•17 
?* 
O
-,..\T 
print him 
I >- DETDIL-LINE 
S * 
1. ,< ,<u&f.N0.eV 1 
81: 
i< . . si • . 
' 
•.: 
81 
St* 
c T 
r«"
 
{> ... 
• ASCII 
code for 
space 
change 
to 30 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
tor 
Windows. 
Users 
Guide 
and 
Tutorta 
Examine the H O U R S . D A T file that you entered. The first 5 characters are the 
ID number. N o w look at your file specification in line 15 of Figure A.65. H O U R S - I D 
is only four characters long. Consequently, every field in the record is off by one 
character. G o to the proper line in your program and correct the PIC to "X(05)." 
Recheck the program. 
Rerun the program and the same error message "Illegal character in numeric 
field" appears. However, w h e n you click on O K , the message refers to line 67. 
Double-click on H O U R S - I D and you will see that the field is totally blank, as s h o w n 
in Figure A.77a. This result does not seem to reflect the s a m e problem as before, but 
you need more information. Select the Examine M e n u in the monitor w i n d o w and 
click o n Ascend level. By selecting Ascend level, you are asking the Animator to 
display the group item that contains H O U R S - I D . Therefore, the Animator will display 
H O U R S - R E C O R D , as s h o w n in Figure A.77b. The entire record is filled with spaces. 
In this case, there m a y be a blank record or s o m e type of improper read of the 
record. Y o u will need to investigate further. 
Figure A.76 Alignment Error 
Since the program assigned the print file to " C O N " in line 9 of Figure A.65, the 
Animator directs the output to a w i n d o w called "Animator V2 Text Window." O p e n 
the w i n d o w if it is hot already visible. The results should look like Figure A.78. 
Y o u should notice two things about this figure. 
1. The words C H E C K REGISTER are printed twice. The Animator does not clear 
out the w i n d o w between program tests. The first line is left over from the first 
test of the program. There m a y be additional lines of output at the top if you 
have run the program several times. 
2. The female symbol at the beginning of the first two lines is the ASCII 
character for a page break. If the output had gone to the printer, each line 
would be the start of a n e w page. 
Examining the output in m o r e detail, you should see that all of the input 
records have been processed. Therefore, something seems to be wrong with the end 
of file processing. 
To test the end of file processing, you will need to rerun the program, but 
stepping through all of the records becomes very tediousr Y o u will w a n t to see only 
what happens after the last record is processed. 

A
p
p
e
n
d
i
x 
A 
M . . so Focus 
Petsonal 
COBOL 
for 
Windows; 
Users 
Guide 
and 
Tutorial 
Fiaure A.77 
End of File Error 
w 
7? 
f.r PBlHr-LIHl 
» M i a n . M M 
HHHHHHHMHHEi 
H 
- B J«| 
H 
M 
H 
H 
. « 
;t 28 t» »« s« 2 a 
' 
W 
'IL J«| 
H 
M 
H 
H 
. « 
;t 28 t» »« s« 2 a 
' 
S« T « 3* » 28 :>«! • 
1 1 
.
.
. 
Jb) Monitor Window for Entire Record 
M a k e sure that line 67 is highlighted. Select "Set advanced" from the D e b u g 
m e n u , as s h o w n in Figure A.79. This action brings u p the Advanced breakpoint 
screen. Click o n the Condition radio button a n d enter the statement " H O U R S - I D = 
5" into the Parameter box. Your w i n d o w should look like Figure A.80. This advanced 
breakpoint will test the H O U R S - I D field each time the breakpoint line is reached to 
see whether it is equal to 5, the ID n u m b e r for the last record. Click o n the Set button 
and the Animator returns to the Execute screen. The breakpoint line has the message 
"Bcond" as s h o w n in Figure A.81. 
Fifyre A.?8 
Screen Output 

Appendix 
A 
Micro 
Focus 
Personal 
COBOL 
tor 
Windows: 
Users 
Guide 
and 
Tutorial 
Set Breakpoint to Find Last Record 
Mot"! UOUK 
MIL >.!-•« 
v^Wsj* 
3 
H PRIHl-UHL If* 
MlMh-lim 
Set Condition for Last Record 
^ « w « « 
parameter: 
Statement 
C gaia change 
r Program 
ffEontlHton 
ruri* 
•1 ( M;i-.ri 
1 
j-i • H<-I;i' 
tvtty: (101 
The purpose of this breakpoint is to allow the program to run until the last 
record is reached. W h e n Animator reaches the breakpoint line and the H O U R S - I D 
field equals 5, you k n o w that the program is n o w processing the last record. 
Use the Compile/Run m e n u to Restart the program, and rerun it. The program 
runs until it finds the last record and displays the R u n message s h o w n in Figure 
A.82. Click on the O K button and use the watch button to step through the program 
until the R E A D statement occurs. A s the highlighting shows in Figure A.83, the 
program has reached the end of the file and m o v e s " N O " to the E O F - S W I T C H . This 
statement is the problem. In lines 47 and 48, the 5 0 0 0 - P R O C E S S - C H E C K paragraph 
is performed until E O F - S W I T C H is equal to "YES." The A T E N D conditional statement 
should read MOVE "YES" TO E O F - S W I T C H . 
Since the wrong value was sent to the switch, the loop continued o n and tried 
to process a nonexistent record. Reading beyond the end of file is another c o m m o n 
error in programming. 
Correct the A T E N D clause, clear the breakpoint and recheck the program. 
W h e n you rerun the program, it should run to completion and produce the proper 
output. 
This tutorial has attempted to s h o w s o m e of the debugging features of the 
Animator and h o w they can assist in the development of programs. Students should 

A
p
p
e
n
d
i
x 
A 
Micro 
Focus 
Personal 
COBOL 
tot 
Windows: 
Users 
Guide 
and 
Tutorial 
experiment with the various features to find for themselves the features that will 
m a k e their work easier. 
Condition Breakpoint Set in Program 
L » 
1.1 
'I 
•n 
•n 
•n • 
n 
f 
tl 
I W T 
e - i t t f j - : ! 
••! n i l 
i l . 
•»•« boobs mm 
••. 
mm 
IT-- 
IKWK: K
!
W 
I)rT-."OykliSi 
f t * IIOtjRi-tfORJil 8 
. 
MS aasHs 
BifI.IW.i 
HOtfiS PXVRflll 
BV 
HOURS WOMtt* 
I..- .1.4 
err ok»s:. k«y 
^ r 
!'! ,i;-T..d! 
; . 
a i l ! - 
ntlHI-LlMT. t'K«f DU«11.-1.INI. 
re A.82 
Breakpoint Encountered Message 
v 
i 
Uu.lpu.r.l CIM uuniifri li 
HOUHS ID • i 
j 
0>>j C e M t d w c 
| 
jre A . 8 3 End of File Logic Error 
•houid be 'YES'-
... W 
- 1 
BODE HOUHS IB 
IO Si I ID 
T"t~"~"" 1 
t , 
i 
— I 
r o w hours-nahf. 
U I W M R 
!f>»ii«a| 
i BdM.l 
hour, wmn 
s i r 
rttrwm 
- i - m ' " ^ - • • —
> f — » - * — -
rv ' DTT CHBKTSV-
t< K l f ' ' « 
' 
• 
1 ! H M » 
A 

Appendix 
A Micro 
Focus 
Personal 
COBOL 
tot 
Windows 
Useis 
Guide 
ana 
Tutonat 
M l 
Micro Focus has provided students with a powerful tool for learning the C O B O L 
language. The Animator has m a n y features, a n d this discussion has addressed only 
the ones that beginning programmers are likely to use. This tool can serve student 
programmers well because it provides an economical w a y to learn C O B O L a n d it is 
not restricted in any significant way. The programs developed through the use of 
the Animator can be taken to full function compilers, a n d they can be compiled to 
be production programs. 
W e hope that this discussion of the Animator will m a k e the task of learning 
h o w to use it easier. 
1 The monitor box has several buttons. The Find and Locate defn buttons do not seem to do anything. 
The cursor is located on the definition of the data item, and pressing either button does not move the 
cursor. Print produces a report of the data item statistics and Help brings up the Find Report Window 
help screen. 
2 Note that if the user then moves the program to the top window using the Tile option or expands the 
window to full screen, the program code is still in the same position relative to the left margin. 
Sometimes the left arrow on the scroll bar is not active and does not allow moving the screen to the 
left. If this occurs, click on the right scroll arrow and then the left arrow should become functional. 
3The Animator does not show a "redo" icon on the tool bar. Redo allows the user to "undo" the most 
recent "undo." In other words, if the user has undone a change by mistake, redo allows the change to 
be restored. Redo can be activated by typing the word "redo" in the command window or pressing 
"Ait +Shift + Backspace." 
If the user wants to modify the toolbar to include a button for redo, the toolbar can be changed by using 
the Configure Interface option of the Options Menu. The toolbar page allows addition of buttons. The 
redo command has its own icon and can be easily inserted before the space after the undo button. 


This appendix consists of four sections that provide instructions for 
installing and making use of Personal COBOL, 
Section 1: Installation 
Section 2: Creating Shortcuts for the Animator 
Section 3; Downloading Data and Source Files from the Web 
Section 4: Printing from COBOL programs with the Animator 
The installation procedure for the Micro Focus Personal C O B O L 
Animator is largely self-explanatory and similar to the installation for almost any 
other W i n d o w s software. This section steps y o u through the process and shows you 
the windows a n d messages you can expect to see as you install the software. W e 
r e c o m m e n d that you adopt all of the defaults unless you have the knowledge a n d 
need to configure the system differently. 
The installation as s h o w n here is done from the C D - R O M in Windows!).
1"). The 
installation process is very similar w h e n using diskettes a n d w h e n under W i n d o w s 
3.1 or W i n d o w s N T . These alternative installation m o d e s should not cause any serious 
differences. 
Installation of the Animator performs the following tasks. 
1. Create a subdirectory o n the computer's hard disk called P C O B W I N . 
P C O B W I N , in turn, has two additional subdirectories called CLASSLIB a n d 
S A M P L E S . P C O B W I N contains all of the executable files necessary to run the 
Animator. CLASSLIB contains special files for Object-Oriented C O B O L . 
S A M P L E S contains a n u m b e r of C O B O L source files supplied by Micro 
Focus. These files demonstrate a n u m b e r of C O B O L concepts a n d 
demonstration programs for traditional a n d Object-Oriented C O B O L . 
2. C o p y files into the appropriate directories. 
3. Build a W i n d o w s Program Manager Group containing icons to run the 
Animator. 
4. Modify the system environmental variables to allow the Animator to run 
properly. 
5. Reboot the system to allow the n e w variables to take effect. 

Appendix 
B 
Getting 
Started 
Open the Windows95 Start Menu 
O p e n the W i n d o w s 9 5 Start M e n u by clicking o n the mm4 c o m m a n d button o n the 
task bar or the keyboard Start key. 
Select the Run Option and Start the Setup Process 
Click o n the R u n option from the Start M e n u s h o w n in Figure B.la. This action 
brings u p the W i n d o w s h o w n in Figure B.lb. In this example, "D:" refers to the C D -
R O M drive. O n your machine the C D - R O M m a y have s o m e other letter. If you are 
installing from diskettes, you probably would use A: instead off):. "Setup.exe" is the 
n a m e of the program to install Personal C O B O L . Click o n the O K button a n d the 
W e l c o m e message box s h o w n in Figure B.lc appears. (Tick o n O K again. 
Starting Animator Installation 
ZD-Rom dn 
jP 
0 m* 
If** n*on*.tm • Ad <r.n«tl CtruTi.jf l.ffHUI lot 
yaw tjm&iHm 
I ' I F I ! IFW ILK !RL«LI(N IFF I'LHIH ULF INTT^LWJFFT 
FM.TTL' 
Y O U I TTF» P I R T I »HT* I .HL< « J I H A I I U I I ) 
•/(HI ILL *K»T W4HI !TI iftdJflB THIS S N F L V I W 
nvm 
M I L N M ^ITLUJI ••ITM •! F I U M F H 

p
p
e
n
d
i
x 
B 
-
Getting 
Started 
itep 3s 
Enter License Registration Information 
Micro Focus wants you to register your copy of the software a n d requests that you 
give your n a m e and affiliation information. Figure B.2 shows the License Registration 
process. Enter your n a m e and college or business into the License Registration 
Input w i n d o w in Figure B.2 a and click o n O K . This action will bring u p the License 
Registration Confirmation W i n d o w , as in Figure B.2b. If the information is correct, 
click o n the Yes button a n d the process continues. If you see s o m e error, click o n 
the N o button and the Input w i n d o w reappears for correction. 
License Registration 
\ti ON it* .II-WI II • xM-i-f,; 
| a | Enter Harme arid Affiliation 
j 
i 
• IF I I I • I K . » II 
I.V. RIRTL 
FTITM. 
II 
( 1 , 1 , 1 
I 
Establish the Configuration 
The next step is to establish h o w Personal C O B O L will run. T h e setup process 
requests that you identify the subdirectory to contain the programs, determine the 
programs to install, a n d to give a n a m e to the Start M e n u Program entry. T h e 
w i n d o w in Figure B.3a suggests that Personal C O B O L should reside in C: \ P C O B W I N . 
Unless you need to change the drive or directory for s o m e reason, click o n the O K 
button. 
The setup program next allows you to select the programs y o u will actually 
install. Figure B.3a shows the C o m p o n e n t Installation window. B e sure that you 
have sufficient hard disk space to install the system and that "Personal C O B O L for 
W i n d o w s " is selected. Y o u m a y choose not to install the Personal Dialog System(PDS) 
since it requires 4 megabytes of hard disk space a n d is not discussed in this book. 
Click o n the O K button to continue o n in the installation. 
The w i n d o w in Figure B.3c allows you to specify where to find the start icons 
for the Animator. T h e default entry is Personal C O B O L . Y o u have the option of 
including the icons in another program group or creating an entirely n e w group. 
Click o n the O K button w h e n you are ready. 

A
p
p
e
n
d
i
x 
B — Getting 
Started 
Establishing Installation Preferences 
t *row i m a pittopprnt ywi m m w mcnw 
^ • M l Dutog S^ftwn i«q*ROI IVavnai ( OiQL ID V 
Ins Sbmbv H b b m m n ^ 
f" |-»iimrf l>HflU Hjilca 
aoMU> 
n>M« ctt™«« « m Wmctmn l'iagi*a 
M a m a * Steua » h u m itm im« 
PiHninflrt pi my mi K W H 
You „<in < h » w mi nathne *<»«> tola 
* far) « flCW (MM 
H*fw 
..lAccessoriet 
|CoMpaq Mua.ateetta 
3 Compaq Utilities 
JHdaak PRO 
| U o L M hx Windows 3S 
a Mania 
JMkiniolt Miinup 
JMitiotiWl WihIit 4 li 
I' "w 
! 
( . M M 
Step Si Establish Environment Variables 
Personal C O B O L uses the environmental variables to link together the various 
programs needed by the system a n d to assure that the operating system allocates 

Appendix 
B — Getting 
Started 
enough resources to those programs. T h e w i n d o w in Figure B . 4 explains 
environmental variables and the changes that will be made. Y o u should normally 
click o n the Modify button to use the default parameters. If you use s o m e other 
Micro Focus product such as the C O B O L W o r k b e n c h or NetExpress, you m a y 
encounter s o m e environmental variable conflicts. 
Once you leave this screen, the setup program will begin to copy the files. 
I Setting Environment Variables 
i 
1 
Plrn'ir rtriidr il IIELUJJ ahuiftd muilily yvut iu)r.JIRJ(e-i 
It) >.rt thn enviinmnrnl fin fferaot'*) C U H O L 
tVi-nt-ial t i l M i l 
I M I mjivumnt unf Tumifjltii' ttj lirwt tynrmm pmui mv 
T*Mj nwmwupaoC v a i u H t i 
t-AAhp i r l i^-ij-m*n>fltty n h e n ' i * * M W M U H *l«Hi 
•)• Ihay i wn tw i r t »«nu.tKp il yuu ha*«t M u o 
I m i l 
r • v> 4l IMIIV h 
i ' • 
JIMI 
i *F<* i i M i i N i r a i in 
JUA* • *•>)• n"'* i r 4 * » K
b 
l 
phi r hung* iiii i imttmnr* *fi tMei firfi m i * WMi thM it |NJV w«nl to wir f . W M WutLb*fM.h 
* o f i.H'i I •..i)irtwn*ni ioi intuitu* t tifcitl' m H I < « M « I
f w a m * laimnam 
:-m-j« nh*,*t 4 ir*** <i (Mich M P f Nrt.QftVflHVI'i.UfttNV M ( 16 *«( U V MvwvMae/*) lot P a n and 
<!MHJl 4«i W.qJ.M. V<., rAH .Ji l * U ) » i HV &4.J M u t e ,4H> 
Wffld*p.» 
I * i«4 I h e w 
I IK*UVI> »»«* 
w w w f i w l V i vim thouhl' hoot* iwi ostium iuiys '.,*tu» mouuv vow O V I O R W I bof 
i 
M.<: torina .y. Uk-t lb* the I'njonot Cfl&ui tut W.nacM* env*i<>'il"wi? Whtjn you 
. J 
.'TIT YIA* COthpUtd TL Mil «* HtO SFLVLT^WW**! till tfVKSAvltlJfl^t |lt J O U Y**nl to 
tun M u m I ,M m I Ijvi.l it/wklMMfJI tMtH tnmt^tMHttiMi^ttwmwanawnt 
VAI.oWi'i yi).iil**l I 
(Injun; « « L lUiKwi k YI , | dn nut IMyh TO I tumor ouut ouhM-IF* lwu Mvl I unliu ( » • 
IEI«M I hit wR Mi ,m ti-.WL you Mill nlMdt/c tun 1*1 littt t#V HA I tir'uir yr« slivt 
WmittWI tffum phi M A N W « M yifflUIMI CDOIJI > IK* dOTtrKrt IUI I N I ayah 
Step 6: 
Copy Files 
The setup program n o w copies the files to the hard disk. T h e w i n d o w s h o w n 
in Figure B.5a keeps track of the progress. Normally you should allow the installation 
to continue, but it is possible to stop the process by clicking o n the Cancel button. If 
you cancel the process you will need to restart the entire installation process. W h e n 
copying is complete, you will receive the message box s h o w n in Figure B.5b. 
Step 7: 
Review README file 
The installation process directs y o u to the R E A D M E file. This document, 
s h o w n in Figure B.6, contains on-line information that w a s not included in the 
printed documentation. Take note of the topics presented in this file. Y o u m a y find 
t h e m helpful if you are having problems with the Animator. Y o u can also get to the 
file by using the "Readme" icon in the Start M e n u entry. 

Appendix 
B 
Getting 
Started 
Actual Installation 
I. M". LLTLWIHVILL K LIT 1-
sanation b t a t u s 
AF| "FIR TIFOI TARWA T*VRN • U-JURIL LU 
|WHH 
I'NIST O F IN tPi-trf RH-H NT ^ D H « }|B> \ DM i NN 
IT-«D ILN* MR « Q « N TETTT <#Y • FETING N V 
(b) All Files C o p i e d 
README File 
Contents 
Welcome to Personal COBOL for Windows 
VERSION 1 1 
THIS R E A D M E FILE COR.t3.NS EXTRA INFORMATION THAT IS NOT IRVCLUDED IN THE P E R S O N A ! C O B O L DOCUMENTATION. 
Y O U CAN READ IT AGAIN LATER FAY 
CLICKING ON THE ' R E A D M E " ICON. 
IF YOU DO NOT READ THIS FILE NOW, PLEASE R E M E M B E R THESE TOPICS ARE AVAILABLE: 
For Heip on Help. Press F 1 
Step 8s 
Reboot the System 
After reviewing the R E A D M E file, you will see the w i n d o w s s h o w n in Figure 
B.7. These w i n d o w s explain that Personal C O B O L will not be functional until the 
system has been restarted a n d the n e w environment variables set. Reboot the 
system if you plan to use Personal C O B O L immediately. 

Appendix 
B — Getting 
Started 
L 
.. 
Request to Restart 
inmpuix « t<i »trt* v»U HM t'&CttWKrf MlfMH 
fl 
$*«N »«»»<.>> t O B W jrf>*"is *JMH"{^ «««rfonstvfcnt 
Restart 
W i n d o w s allows the creation of "shortcuts" or icons that will start various 
applications. W h e n you installed Personal C O B O L , the installation process set up 
several shortcuts in the Start M e n u entry "Personal C O B O L . " O n e of those shortcuts 
is called Personal C O B O L and starts the Animator. W h e n the Animator begins to 
process, it has a default working directory of C : \ P C O B W I N \ S A M P L E S . However, it 
is likely that you will want to use s o m e other directory or a floppy disk to store your 
programs. Therefore, you m a y want to create one or m o r e n e w shortcuts to m a k e 
things easier. 
By selecting Taskbar within the Start M e n u option Settings, as s h o w n in Figure 
B.8, you can create your o w n shortcuts. This option brings up the Taskbar Properties 
window, as in Figure B.9. M a k e sure that the "Start M e n u Programs" tab is o n top. 
Click o n the A d d button to create a n e w short cut. The A d d button starts a wizard to 
help you create a short cut. Figures B. 10 through B. 12 s h o w the w i n d o w s the wizard 
presents and the options w e chose to build a shortcut for using C O B O L programs 
o n the A drive. 
The shortcut is not complete after the wizard has finished. F r o m the Taskbar 
Properties w i n d o w s h o w n in Figure B.9, select the Advanced option. A w i n d o w 
similar to that s h o w n in Figure B. 13 appears. Y o u will probably have to double-click 
o n Programs to show all of the subentries. Click on Personal C O B O L to show its 
contents. Next, select your entry and then click o n the file m e n u . At this point you 
should see something like Figure B. 14. By selecting Properties, you will open the 
w i n d o w s h o w n in Figure B. 15. M a k e sure that the Shortcut tab is showing, then enter 
the directory you wish to use into the "Start in:" text box. Click o n the O K button and 
you will be able to run the Animator using the directory containing your files. 
W e r e c o m m e n d the use of shortcuts because they help m a k e sure that your 
programs will find the correct input files. 

Appendix 
B — Getting 
Started 
figure B.8 
Preparing to Create a Shortcut 
.JW«*0S»0«uww 
Settings option 
a* »t<t'f« 
1 
* • • 
Figure 8.9 Taskbar Properties 
Start menu Sab • 
,4dd button -
Advanced 
button 

A
p
p
e
n
d
i
x 
B 
Getting 
Started 
Set Program Group for Shortcut 
H 'An .ojofi Money 
;k f roe to; Windows 
/- Establish Name for Shortcut 
III 
Expanded List of Folders 
^ Compdq Utiles 
HtJaask PRO 
_apL,riS ta W w , f 
^ Mass? 
M<c ^ rucu '•.ef-i.-fpfe 
MKucvjysi Monev 
M M . Oil «/ *. 4 0 
^ 
'
 e T ' ' ^ 
_yr| Ftej^jfourrd 
sAL
rA iO) IV Ds ktop 
Sfatibp 
J H-fsoras,: COBOL 
i a COBOL Piogom 
Ji 

A
p
p
e
n
d
i
x 
B 
— Getting 
Started 
r.hannfi ProoertiftR nf Shnrtr.i it 
File rnenu -
Properties option • 
H a t * ^ i 
UP. ii 
He® 
-] - t -
J
 1" 
Lf'JICr: I IT* 'CI W ElOOWi. 
SALSA fof she Desktop 
3/ Readme 
J • .idCOBGLPiogiar 
j jT" 
iliiiiiiiH 
1 5 Change the Default Program Directory 
Shortcut lab • 
Directory for programs 
itiil 
j Normal nnndiw.i 
£r*J 
I ghdnpe SCAT. 

Appendix 
B — Getting 
Started 
D o w n l o a d i n g D a t a and S o u r c e Files from the Wefc* 
All of the programs s h o w n in this book and the associated data files are available to 
you. They can be downloaded from the World Wide W e b . Y o u m a y find the entries 
under: www.prenhall.com\grauer_cobol. The process for downloading the files is 
self-explanatory. 
Printing from COBOL Programs with the Animator 
As discussed in Chapter 4, the SELECT a n d A S S I G N statements define external files 
to the C O B O L program. In mainframe applications, the specific printer is established 
outside the program through the use of Job Control Language (JCL). Hence, in a 
mainframe C O B O L program you might see a statement such as S E L E C T PRINT-
FILE A S S I G N T O UT-S-SYSOUT. U T - S - S Y S O U T is a generic n a m e for an output 
device, and a programmer could write a JCL control statement to direct the data to a 
specific printer. 
C O B O L o n personal computers works a little differently. Personal computers 
have output ports that can be directed to various peripheral devices. The most 
c o m m o n of these ports is "LPT1:". LPT1 is generally used for the printer directly 
attached to a PC. In s o m e cases, m o r e than one printer can be attached to a PC, and 
in other cases the P C m a y be part of a network and print to a network printer. 
Printing to a n A t t a c h e d Printer 
In printing to an attached printer, there are several methods for defining a printer. 
The simplest m e t h o d is to say A S S I G N T O PRINTER. The C O B O L compiler directs 
the output to LPT1 as the default system printer. Another w a y of doing the same 
thing is to say A S S I G N T O T.PT1:'. This statement specifically directs the file to the 
printer. In the s a m e way, the programmer can direct a report to a second attached 
printer by coding A S S I G N T O 'LPT2:'. 
Printing t o the Screen or Data Files 
Printed output can also be directed to output devices other than printers. For 
example, you m a y not always want to print your report w h e n debugging the program. 
Instead, you m a y find it m o r e convenient to view the results on the screen. This 
process is quicker than printing and can save paper. T o print to the screen, simply 
code A S S I G N T O 'CON'. C O N stands for "console" or display device. Once you 
decide to print a hard copy of the report, change the A S S I G N statement to LP IT and 
recompile. 
The printed output can also be directed to a file capable of being printed 
through the use the Notepad W i n d o w s accessory. Again, this is done through the 
A S S I G N statement. This time m a k e the destination something like "REPORT.TXT". 
The output of the program goes to a file instead of the printer. T o print the file, open 
it in Notepad a n d print from this accessory. However, you m a y want to edit the file 
before printing. 
If you have coded a statement such as: 
WRITE PRINT-LINE AFTER ADVANCING PAGE. 

Appendix 
B — Getting 
Started 
C O B O L will insert a control character into the line telling the printer to start at the 
top of the next page. Notepad does not use this character a n d you will want to 
remove it. 
Printing to a Network Printer 
Personal C O B O L does not utilize the W i n d o w s 9 5 or W i n d o w s N T spooling 
capabilities, a n d printing to a network printer can be difficult. Even if a network 
printer is the default printer, A S S I G N T O P R I N T E R causes C O B O L to print to the 
attached printer. The W i n d o w s printer assignments are ignored. 
In order to print directly to a network printer, you will need to consult with 
your instructor or network administrator as to the proper procedure. A beginning 
place is to use the M S - D O S c o m m a n d " N E T U S E " to assign a port n a m e to the 
network printer. The format for this c o m m a n d is: 
net use l p t 3 : \ \ s e r v e r \ p r i n t e r 
In this case, "lpt3:" is the printer n a m e to be used in the program. "Server" is 
the n a m e of the server supporting the printer, a n d "printer" is the network n a m e for 
the printer. 
j
>*:;.ting O v e r s i z e P**ges 
In the mainframe environment line printers usually have 132 characters per line. 
However, most standard P C printers print 80 characters per line. If the report line is 
longer than 80 characters, most P C printers will "wrap" the print line. That is, the 
printer prints as 80 characters o n the first line and the rest o n a second line. As a 
result, the output is distorted a n d hard to read. 
There are several solutions to the problem. T h e first is to see whether the 
printer has s o m e sort of switch or combination of buttons to print in "compressed" 
m o d e . Consult your user's manual to see h o w to accomplish this adjustment. 
A second alternative is to print in "landscape" m o d e . Portrait m o d e , where the 
page is taller than it is wide, is the standard w a y of printing. However, most inkjet 
a n d laser printers are also capable of printing the page "sideways" so that the 
resulting page is wider than it is tall. This m o d e is called landscape. Again, consult 
your user's manual to see h o w this m a y be accomplished. 
A final alternative is to code your program so that it causes the printer to 
operate in compressed or landscape m o d e . In the subdirectory C : \ P C O B W I N \ 
S A M P L E S , Micro Focus has provided a n example program for sending control 
characters directly to the printer. Since m a n y printers use different control 
characters, this process can be confusing, a n d you will need to find the proper 
characters from your user's manual. 

ACCEPT 
CLASS 
DEBUG-SUB-1 
END-RETURN 
ACCESS 
CLOCK-UNITS 
DEBUG-SUB-2 
END-REWRITE 
ADD 
CLOSE 
DEBUG-SUB-3 
END-SEARCH 
ADVANCING 
COBOL 
DEBUGGING 
END-START 
AFTER 
CODE 
DECIMAL-POINT 
END-STRING 
ALL 
CODE-SET 
DECLARATIVES 
END-SUBTRACT 
ALPHABET 
COLLATING 
DELETE 
END-UNSTRING 
ALPHABETIC 
COLUMN 
DELIMITED 
END-WRITE 
ALPHABETIC-LOWER 
COMMA 
DELIMITER 
ENTER 
ALPHABETIC-UPPER 
COMMON 
DEPENDING 
ENVIRONMENT 
ALPHANUMERIC 
COMMUNICATION 
DESCENDING 
EOP 
ALPHANUMERIC-EDI TED 
COMP 
DESTINATION 
EQUAL 
ALSO 
COMPUTATIONAL 
DETAIL 
ERROR 
ALTER 
COMPUTE 
DISABLE 
ESI 
ALTERNATE 
CONFIGURATION 
DISPLAY 
EVALUATE 
AND 
CONTAINS 
DIVIDE 
EVERY 
ANY 
CONTENT 
DIVISION 
EXCEPTION 
ARE 
CONTINUE 
DOWN 
EXIT 
AREA 
CONTROL 
DUPLICATES 
EXTEND 
AREAS 
CONTROLS 
DYNAMIC 
EXTERNAL 
ASCENDING 
CONVERTING 
ASSIGN 
COPY 
EG I 
FALSE 
AT 
CORR 
ELSE 
FD 
AUTHOR 
CORRESPONDING 
EMI 
FILE 
BEFORE 
BINARY 
BLANK 
BLOCK 
BOTTOM 
BY 
COUNT 
CURRENCY 
ENABLE 
END 
END-ADD 
FILE-CONTROL 
FILLER 
FINAL 
BEFORE 
BINARY 
BLANK 
BLOCK 
BOTTOM 
BY 
DATA 
END-CALL 
FIRST 
BEFORE 
BINARY 
BLANK 
BLOCK 
BOTTOM 
BY 
DATE 
END-COMPUTE 
FOOTING 
BEFORE 
BINARY 
BLANK 
BLOCK 
BOTTOM 
BY 
DATE-COMPILED 
END-DELETE 
FOR 
BEFORE 
BINARY 
BLANK 
BLOCK 
BOTTOM 
BY 
DATE-WRITTEN 
END-DIVIDE 
FROM 
CALL 
DAY 
END-EVALUATE 
CANCEL 
DAY-OF-WEEK 
END-IF 
GENERATE 
CD 
DE 
END-MULTIPLY 
GIVING 
CF 
DEBUG-CONTENTS 
END-OF-PAGE 
GLOBAL 
CH 
DEBUG-ITEM 
END-PERFORM 
GO 
CHARACTER 
DEBUG-LINE 
END-READ 
GREATER 
CHARACTERS 
DEBUG-NAME 
END-RECEIVE 
GROUP 

A
p
p
e
n
d
i
x 
C 
Reserved 
Words 
HEADING 
HIGH-VALUE 
HIGH-VALUES 
1-0 
I-O-CONTROL 
IDENTIFICATION 
IF 
IN 
INDEX 
INDEXED 
INDICATE 
INITIAL 
INITIALIZE 
INITIATE 
INPUT 
INPUT-OUTPUT 
INSPECT 
INSTALLATION 
INTO 
INVALID 
IS 
JUST 
JUSTIFIED 
KEY 
LABEL 
LAST 
LEADING 
LEFT 
LENGTH 
LESS 
LIMIT 
LIMITS 
LINAGE 
LINAGE-COUNTER 
LINE 
LINE-COUNTER 
LINES 
LINKAGE 
LOCK 
LOW-VALUE 
LOW-VALUES 
MEMORY 
MERGE 
MESSAGE 
MODE 
MODULES 
MOVE 
MULTIPLE 
MULTIPLY 
NATIVE 
NEGATIVE 
NEXT 
NO 
NOT 
NUMBER 
NUMERIC 
NUMERIC-EDITED 
OBJECT-COMPUTER 
OCCURS 
OF 
OFF 
OMITTED 
ON 
OPEN 
OPTIONAL 
OR 
ORDER 
ORGANIZATION 
OTHER 
OUTPUT 
OVERFLOW 
PACKED-DECIMAL 
PADDING 
PAGE 
PAGE-COUNTER 
PERFORM 
PF 
PH 
PIC 
PICTURE 
PLUS 
POINTER 
POSITION 
POSITIVE 
PRINTING 
PROCEDURE 
PROCEDURES 
PROCEED 
PROGRAM 
PROGRAM-ID 
PURGE 
QUEUE 
QUOTE 
QUOTES 
RANDOM 
RD 
READ 
RECEIVE 
RECORD 
RECORDS 
REDEFINES 
REEL 
REFERENCE 
REFERENCES 
RELATIVE 
RELEASE 
REMAINDER 
REMOVAL 
RENAMES 
REPLACE 
REPLACING 
REPORT 
REPORTING 
REPORTS 
RERUN 
RESERVE 
RESET 
RETURN 
REVERSED 
REWIND 
REWRITE 
RF 
RH 
RIGHT 
ROUNDED 
RUN 
SAME 
SO 
SEARCH 
SECTION 
SECURITY 
SEGMENT 
SEGMENT-LIMIT 
SELECT 
SEND 
SENTENCE 
SEPARATE 
SEQUENCE 
SEQUENTIAL 
SET 
SIGN 
SIZE 
SORT 
SORT-MERGE 
SOURCE 
SOURCE-COMPUTER 
SPACE 
SPACES 
SPECIAL-NAMES 
STANDARD 
STANDARD-1 
STANDARD-2 
START 
STATUS 
STOP 
STRING 
SUB-QUEUE-1 
SUB-QUEUE-2 
SUB-QUEUE-3 
SUBTRACT 
SUM 
SUPPRESS 
SYMBOLIC 
SYNC 
SYNCHRONIZED 
TABLE 
TALLYING 
TAPE 
TERMINAL 
TERMINATE 
TEST 
TEXT 
THAN 
THEN 
THROUGH 
THRU 
TIME 
TIMES 
TO 
TOP 
TRAILING 
TRUE 
TYPE 
UNIT 
UNSTRING 
UNTIL 
UP 
UPON 
USAGE 
USE 
USING 
VALUE 
VALUES 
VARYING 
WHEN 
WITH 
WORDS 
WORKING-STORAGE 
WRITE 
ZERO 
ZEROES 
ZEROS 
/ 

14 
imr* 
^Ssmm 
« s J I 
This appendix contains the composite language skeleton of the revised version of 
the American National Standard COBOL. It is intended to display complete a n d 
syntactically correct formats. 
The leftmost margin on pages 710 through 718 is equivalent to margin A in a 
C O B O L source program. T h e first indentation after the leftmost margin is equivalent 
to margin B in a COBOL source program. 
O n pages 719 through 729 the leftmost margin indicates the beginning of the 
format for a n e w COBOL verb. T h e first indentation after the leftmost margin 
indicates continuation of the format of the COBOL verb. The appearance of the 
italic letter S, R, I, or Wto the left of the format for the verbs CLOSE, OPEN, READ, 
and W R I T E indicates the Sequential I-O module, Relative 1-0 module, Indexed I-O 
module, or Report Writer module in which that general format is used. The following 
formats are presented: 
Identification Division 
712 
Environment Division 
712 
File Control Entry 
713 
Data Division 
714 
File Description Entry 
715 
Data Description Entry 
716 
Communication Description Entry 
717 
Report Description Entry 
718 
Report Group Description Entry 
718 
Procedure Division 
719 
C O B O L Verbs 
720 
C O P Y and R E P L A C E Statements 
731 
Conditions 
732 
Qualification 
733 
Miscellaneous Formats 
733 
Nested Source Programs 
734 
A Series of Source Programs 
735 

A
p
p
e
n
d
i
x 
D 
COBOL-85 
Reference 
Summary 
IDENTIFICATION 
DIVISION-
PROGRAM- ID. 
p rog ram - name 
IS 
COMMON 
INITIAL 
PROGRAM 
[AUTHOR, 
[comment-entry] 
. . . ] 
[INSTALLATION, 
[comment - entry] 
. . . ] 
[DATE-WRITTEN, 
[comment - entry] 
. . . ] 
[DATE-COMPILED, 
[comment- entry] 
. . . ] 
[SECURITY, 
[comment-entry] 
. . . ] 
[ENVIRONMENT 
DIVISION. 
[CONFIGURATION 
SECTION. 
[SOURCE-COMPUTER, 
[computer-name 
[WITH DEBUGGING MODE] . ] ] 
[PROGRAM COLLATING 
SEQUENCE 
I S alphabet - name - 1] 
[SEGMENT-LIMIT 
IS 
segment - number] . ] ] 
[SPECIAL-NAMES. 
[ [implementor-name-1 
IS mnemonic-name-1 
[ON STATUS I S condition-name-1 
[OFF STATUS I S condition-name-2] 
] 
IS mnemonic-name-2 
[Off STATUS I S 
condition-name-Z 
[ON STATUS I S condi t i on-name - 1] ] 
[ON STATUS IS condi t i on-name-1 
[OFF STATUS IS 
condition-name-2] 
] 
[OFF STATUS I S condition-name-2 
[ON STATUS IS 
condition-name-1] ] 
[ALPHABET 
alphabet - name-1 I S 
STANDARD-1 
STANDARD-2 
NATIVE 
implementor-name-2 
| [THROUGH] 
l i t e r a l - 1 
l i t e r a l - 2 
[THRU 
j 
(ALSO 
l i t e r a l - 3 
SYMBOLIC 
CHARACTERS 
\ \ {symbol i c - character- 1 
] • 
I S 
ARE 
{ i n t e g e r - l j 
. [IN alphabet-name-2] 
CLASS 
class-name 
IS 
- H i t e r a l - 4 
[through] 
[thru 
J 
1 i t e r a l - 5 
[CURRENCY 
SIGN 
I S 
l i t e r a l - 6 ] 
[DECIMAL-POINT 
I S 
COMMA], ] ] ] 
[INPUT-OUTPUT 
SECTION-
F I L E - CONTROL. 
{ f i l e - c o n t r o l - e n t r y } 
. . . 

File 
Control 
hntry 
(continued) 
[I - 0 - CONTROL. 
RERUN ON Jfi 1 e-name - 1 
[implementor- name-1 
EVERY 
[END OF] \
~
\ 
OF f i l e - n a m e - 2 
j
L—
 
J [unit] 
[integer-1 RECORDS 
i n t e g e r - 2 CLOCK - UNITS 
condition-name- 1 
SAME 
RECORD  
SORT 
SORT-MERGE 
AREA FOR f i 1 e - name - 1 
{ f i l e - n a m e - 2 } 
MULTIPLE FILE TAPE CONTAINS 
{ f i l e - n a m e - 3 
[POSITION IS integer-1] } . . 
SEQUENTIAL FILE 
SELECT [OPTIONAL] 
f i l e - n a m e - 1 
implementor-name - 1 
l i t e r a l - 1 
ASSIGN TO 
RESERVE 
i n t e g e r - 1 
[ [ORGANIZATION IS] [LINE]SEQUENTIAL] 
I data - name - 1 
"area " 
AREAS 
PADDING CHARACTER IS 
RECORD DELIMITER IS 
[ l i t e r a l - 2 
STANDARD - 1 
[implementor - name - 2 
[ACCESS MODE IS SEQUENTIAL] 
[FILE STATUS IS d a t a - n a m e - 2 ] 
RELATIVE FILE 
SELECT [OPTIONAL] f i l e - name - 1 
[implementor-name - 1 
[literal -1 
1 
"area " 
AREAS 
ASSIGN TO 
RESERVE 
i n t e g e r - 1 
[ORGANIZATION IS] RELATIVE 
SEQUENTIAL [RELATIVE KEY IS data - name - 1 ] ' 
ACCESS MODE IS [ [RANDOM [ 
[DYNAMICj RELATIVE KEY IS 
data-name-1 
[FILE STATUS IS d a t a - n a m e - 2 ] 

A
p
p
e
n
d
i
x 
D 
— COBOL-85 
Reference 
Summary 
cvCi'! i t - .iy-. 
(continued) 
INDEXED FILE 
SELECT 
[OPTIONAL] 
f i l e - n a m e - 1 
fimplementor- name- 1 
1 i t e r a l - 1 
ASSIGN TO 
RESERVE 
i n t e g e r - 1 
[ORGANIZATION 
I S ] 
INDEXED 
SEQUENTIAL] 
1 
~AREA ' 
AREAS 
ACCESS MODE I S 
RANDOM 
DYNAMIC 
RECORD KEY I S data-name-1 
[ALTERNATE 
RECORD KEY I S d a t a - n a m e - 2 
[WITH 
DUPLICATES] 
SORT OR MERGE FILE 
SELECT 
f i l e - n a m e - 1 
ASSIGN TO 
implementor- name - 1 
l i t e r a l - 1 
[DATA DIVISION, 
[FILE SECTION. 
[fi l e - description - entry 
{ r e c o r d - d e s c r i p t i o n - e n t r y ) . . . ] . 
[sort - merge - f i 1 e - descri pti on - entry 
{ r e c o r d - d e s c r i p t i o n - e n t r y } 
. . . ] . 
[report - fi l e - d e s c r i p t i o n - e n t r y ] 
. . 
[WORKING - STORAGE SECTION. 
7 7 - l e v e l - d e s c r i p t i o n - e n t r y 
r e c o r d - d e s c r i p t i o n - e n t r y 
[LINKAGE 
SECTION. 
7 7 - 1 e v e l - d e s c r i p t i o n - e n t r y 
r e c o r d - d e s c r i p t i o n - e n t r y 
] 
[COMMUNICATION SECTION. 
[communi cati on-descri p t i o n - e n t r y 
[ r e c o r d - d e s c r i p t i o n - e n t r y ] 
. . . ] . . . ] 
[REPORT SECTION. 
[report - description- entry 
{ r e c o r d - g r o u p - d e s c r i p t i o n - e n t r y ) 
. . . ] . . . ] ] 

File 
Description 
Entry 
S E Q U E N T I A L F I L E 
FD 
f i l e - n a m e - 1 
[IS 
EXTERNAL] 
[IS 
GLOBAL! 
BLOCK 
CONTAINS 
[i nteger-1 
TO] 
integer-2 
(RECORDS 
1 
CHARACTERS| 
RECORD 
CONTAINS 
i n t e g e r - 3 
CHARACTERS 
IS 
VARYING 
IN SIZE 
[ [FROM 
i n t e g e r - 4 ] 
[TO integer-5] 
CHARACTERS] 
[DEPENDING 
ON data - name-1] 
CONTAINS 
integer-6 
TO integer-7 
CHARACTERS 
[RECORD 
IS 
] 
[standard] 
LABEL 
\ 
\ 
[RECORDS 
AREJ 
OMITTED j 
VALUE OF [ implementor-name-
1 
t
c 
[data-name-2[ 
| 
1 iteral-1 
DATA 
I RECORD 
I S 
j 
[RECORDS 
ARE j 
(data-name-3} . . . 
[data-name-4, 
LINAGE 
I S 
i 
\ 
LINES 
[ i n t e g e r - 8 
LINES 
AT TOP 
data-name - 6 
integer-10 
[CODE-SET 
I S 
alphabet-name-1] . 
, data-name-5 
WITH 
FOOTING 
AT i, 
i n t e g e r - 9 
LINES 
AT 
BOTTOM l^-"
3"
1 6-
7 
[integer-11 
R E L A T I V E F I L E 
FD 
f i 1 e - name - 1 
[IS 
EXTERNAL] 
[IS 
GLOBAL] 
BLOCK 
CONTAINS 
[i nteger-1 
TO] 
integer-2 
[records 
1 
i c h a r a c t e r s [ 
RECORD 
CONTAINS 
i n t e g e r - 3 
CHARACTERS 
IS 
VARYING 
IN SIZE 
[ [FROM 
i n t e g e r - 4 ] 
[TO 
i n t e g e r - 5 ] 
CHARACTERS] 
[DEPENDING 
ON data-name-1] 
CONTAINS 
integer-6 
TO integer-7 
CHARACTERS 
LABEL 
[RECORD 
I S 
) 
[STANDARD] 
[RECORDS 
AREJ 
[OMITTED j 
VALUE OF \ implementor-name- 1 
I S 
data-name-2 
l i t e r a l - 1 
DATA 
JRECORD 
I S 
| 
[RECORDS ARE] 
(data-name- 3} 

A
p
p
e
n
d
i
x 
D 
COBOL-85 
Reference 
Summary 
ascription Entry (continued) 
SORT-MERGE FILE 
SO 
f i l e - n a m e - 1 
RECORD 
CONTAINS 
i n t e g e r - 1 
CHARACTERS 
I S 
VARYING 
IN SIZE 
[ [FROM 
integer-2] 
[TO integer-3] 
CHARACTERS] 
[DEPENDING 
ON data-name-1] 
CONTAINS 
i n t e g e r - 4 
TO integer-5 
CHARACTERS 
DATA 
/RECORD IS 
[RECORDS ARE 
{data-name-2) 
. . 
REPORT FILE 
FD 
f i 1 e - name -1 
[IS 
EXTERNAL] 
[IS 
GLOBAL] 
BLOCK 
CONTAINS 
[integer-1 
TO] 
integer-2 
[RECORDS 
] 
I CHARACTERS 
RECORD 
CONTAINS 
i n t e g e r - 3 
CHARACTERS 
IS 
VARYING 
IN SIZE 
[ [FROM 
integer-4] 
[TO integer-5] 
CHARACTERS] 
[DEPENDING 
ON data-name-1] 
CONTAINS 
integer-6 
TO i n t e g e r - 7 
CHARACTERS 
LABEL 
[RECORD 
I S 
[ 
[STANDARDl 
[RECORDS 
ARE[ [OMITTED J 
VALUE OF [ implemented-name-1 I S 
[CODE-SET 
I S alphabet-name-1] 
[REPORT 
I S 
[REPORTS ARE 
{report-name-1} . . 
data-name-2 
l i t e r a l - 1 
INDEXED FILE 
FD 
f i l e - n a m e - 1 
[IS 
EXTERNAL] 
[IS 
GLOBAL] 
BLOCK 
CONTAINS 
[integer-1 
TO] 
i n t e g e r - 2 
RECORDS 
| 
CHARACTERS/ 
RECORD 
CONTAINS 
i n t e g e r - 3 
CHARACTERS 
I S 
VARYING 
IN SIZE 
[ [FROM 
i n t e g e r - 4 ] 
[TO i n t e g e r - 5 ] 
CHARACTERS] 
[DEPENDING 
ON data-name-1] 
CONTAINS 
i n t e g e r - 6 
TO i n t e g e r - 7 
CHARACTERS 
LABEL 
[RECORD IS ] [STANDARD] 
[RECORDS 
AREj 
[OMITTED J 
VALUE OF i implementor-name- 1 
I S 
data-name-2 
l i t e r a l - 1 
DATA 
/RECORD 
I S 
I RECORDS ARE 
{data-name-3} . . 

Data 
Description 
Entry 
i lilli
1 
FORMAT 1 
level-number 
data - name - 1 
FILLER 
[REDEFINES data-name-2] 
[IS 
EXTERNAL] 
[IS 
GLOBAL] 
(PICTURE^ 
m 
J 
[USAGE IS] 
[SIGN IS] 
IS 
c h a r a c t e r - s t r i n g 
BINARY 
COMPUTATIONAL 
COMP 
DISPLAY 
INDEX 
PACKED - DECIMAL 
I LEADING ) 
TRAILING] 
OCCURS integer-2 
TIMES 
[SEPARATE CHARACTER] 
[ASCENDING 1 
1 
} KEY IS 
data-name-3} 
I DESCENDING I 
[INDEXED BY {index-name-1} . . . ] 
OCCURS i n t e g e r - 1 
JO integer-2 
TIMES DEPENDING 
data-name-4 
[ASCENDING ] 
KEY IS 
{data-name-3} 
. . . 
[DESCENDING I 
[INDEXED 
BY 
{index - name - 1} . . . ] 
fSYNCHRONIZED 
"left " 
RIGHT 
RIGHT 
[SYNC 
[justified 
[JUST 
[BLANK 
WHEN ZERO] 
[VALUE IS 
l i t e r a l - 1 ] 
FORMAT 0 
66 
data-name-1 
RENAMES data-name-2 
[THROUGH] 
[THRU 
j 
data-name-3 
FORMAT 3 
condi tion-name - 1 
[VALUE IS 
[VALUES ARE 
1 i t e r a l - 1 
[THROUGH 1 
[THRU 
j 
l i t e r a l - 2 

Appendix 
O 
COBOL-85 
Reference 
Summary 
IS, ft' 
FORMAT 1 
CD 
cd-name-1 
FOR 
[INITIAL] 
INPUT 
[ 
[SYMBOLIC 
QUEUE 
IS 
data-name-1] 
[SYMBOLIC 
SUB-QUEUE-1 
I S 
data-name-2] 
[SYMBOLIC 
SUB-QUEUE-2 
I S 
data-name-3] 
[SYMBOLIC 
SUB-QUEUE-3 
I S 
data-name-4] 
[MESSAGE DATE 
I S 
data-name-5] 
[MESSAGE TIME 
I S 
data-name-6] 
[SYMBOLIC 
SOURCE 
I S 
data-name-7] 
[TEXT LENGTH 
I S 
data-name-8] 
[END KEY I S 
data-name-9] 
[STATUS KEY I S 
data - name - 10] 
[MESSAGE COUNT 
I S 
data - name - 11] 
] 
[data-name-1, data-name-2, data-name-3, 
data-name-4, data-name-5, data-name-6, 
data-name-7, data-name-8, data-name-9, 
data -name -10, 
data-name-11] 
FORMAT 2 
CD 
cd-name-1 
FOR OUTPUT 
[DESTINATION COUNT 
I S 
data-name-1] 
[TEXT LENGTH 
I S 
data-name-2] 
[STATUS KEY I S 
data-name-3] 
[DESTINATION 
TABLE OCCURS 
i n t e g e r - 1 
TIMES 
[INDEXED 
BY 
{i ndex - name -1} 
. . . ] ] 
[ERROR KEY I S 
data-name-4] 
[SYMBOLIC 
DESTINATION 
I S 
data-name-5] 
. 
FORMAT 3 
CO 
cd-name-1 
FOR 
[INITIAL] IzO 
[ 
[MESSAGE DATE 
I S 
data-name-1] 
[MESSAGE TIME 
I S 
data-name-2] 
[SYMBOLIC 
TERMINAL 
I S 
data-name-3] 
[TEXT LENGTH 
I S 
data-name-4] 
[END KEY IS 
data-name-5] 
[STATUS KEY I S 
data-name-6] ] 
[data-name-1, data-name-2, d a t a - n a m e - 3 , 
data-name-4, data-name-5, data-name-6] 

Report 
Group 
Description 
Entry 
RD report-name-1 
[IS GLOBAL] 
[CODE literal-1] 
[CONTROL IS } J{data-name-1} . . . 
[CONTROLS ARE j [FINAL [data - name - 1] . . . 
[PAGE LIMIT IS 
LIMITS ARE integer-1 LINE 
LINES [HEADING integer-2] 
[FIRST DETAIL integer-3] [LAST DETAIL integer-4] 
[FOOTING integer-5] ] . 
FORMAT 1 
01 [data - name -1] 
LINE NUMBER IS 
integer-! [ON NEXT PAGE] 
PLUS integer-2 
integer-3 
NEXT GROUP IS \ PLUS integer-4 
NEXT PAGE 
[REPORT HEADING] 
TYPE IS 
[Eti 
PAGE HEADING] 
PH 
j 
[CONTROL HEADING] Jdata-name-2 
I CH 
J [FINAL 
[detail] 
l5i 
[ 
[CONTROL FOOTING! [ d a t a - n a m e - 3 
IQE 
J [final 
PAGE FOOTING' 
EE 
(REPORT FOOTING 
[BE 
[ [USAGE IS] DISPLAY] . 
FORMAT Z 
level-number [data - name -1] 
[integer-1 [ON NEXT PAGE]] 
LINE NUMBER IS [PLUS integer-2 
[ [USAGE IS] DISPLAY] 

A
p
p
e
n
d
i
x 
D 
•-- COBOL-85 
Reference 
Summary 
mm 
(continued) 
FORMAT 3 
level-number 
[data-name-1] 
fPICTURE] 
I 
1 
I
S 
c h a r a c t e r - s t r i n g 
jpjc 
j 
[ 
[USAGE I S ] DISPLAY] 
, 
[LEADING , 
[SIGN 
I S ] \ 
} 
SEPARATE 
CHARACTER 
TRAILING 
RIGHT 
[justified 
[JUST 
[BLANK 
WHEN 
ZERO] 
LINE 
NUMBER I S 
integer-1 
[ON NEXT PAGE]| 
PLUS 
i n t e g e r - 2 
[COLUMN 
NUMBER I S i n t e g e r - 3 ] 
SOURCE I S i d e n t i f i e r - i 
VALUE 
I S 
I i t e r a l - 1 
(SUM 
{ i d e n t i f i e r - 2 } . . . 
[UPON 
(data-name-2) 
[data-name-3] 
. ] i 
RESET ON 
FINAL 
[GROUP 
INDICATE] 
FORMAT 1 
[PROCEDURE DIVISION 
[USING 
(data-name-1} . . . ] . 
[DECLARATIVES. 
(section-name 
SECTION 
[segment - number] . 
USE statement, 
[paragraph-name. 
[sentence] 
.
.
.
]
.
.
.
}
.
.
. 
END DECLARATIVES.] 
(section-name 
SECTION 
[segment - number] . 
[paragraph-name. 
[sentence] 
.
.
.
]
.
.
.
}
.
.
.
] 
FORMAT 2 
[PROCEDURE DIVISION 
[USING 
(data-name-1) . . . ] . 
[paragraph-name. 
[sentence] 
.
.
.
}
.
.
.
] 

COBOL 
Verbs 
ACCEPT identifier-1 
[FROM mnemonic-name-1] 
ACCEPT identifier-2 
FROM 
DATE 
DAY 
DAY-OF-WEEK 
TIME 
ACCEPT cd-name-1 
MESSAGE COUNT 
ADD 
identifier-1 
, . 
TO {identifier-2 
[ROUNDED] 
[literal-1 
[ON 
SIZE ERROR imperative-statement -1] 
[NOT ON SIZE ERROR imperati ve-statement - 2] 
[END - ADD] 
ADD 
identifier-1 
TO 
identifier-2 
literal-1 
J 
[literal-2 
GIVING {identifier-3} 
[ROUNDED] } . . . 
[ON 
SIZE ERROR imperative-statement - 1] 
[NOT ON SIZE ERROR imperative-statement - 2] 
[END-ADD] 
[CORRESPONDING 
ADD [ 
[ identifier-1 
TO identifier-2 
[ROUNDED] 
ICQRR 
j 
[ON 
SIZE ERROR imperative- statement - 1] 
[NOT ON SIZE ERROR imperative- statement - 2] 
[END-ADD] 
ALTER {procedure-name-1 TO [PROCEED TO] procedure-name-2} . 
CALL 
identifier-1 
literal-1 
USING 
[BY REFERENCE] 
{identifier-2} . 
BY CONTENT {identifier-2} . . . 
[ON 
OVERFLOW 
imperati ve-statement - 1] 
[END-CALL] 
CALL 
identifier-1 
1iteral-1 
USING 
[BY REFERENCE] 
{identifier-2} 
BY CONTENT {identifier-2} . . 
[ON 
EXCEPTION imperative-statement-1] 
[NOT ON EXCEPTION 
imperati ve-statement-2] 
[END-CALL] 

i 
A
p
p
e
n
d
i
x 
0— 
COBOL-85 
Reference 
Summary 
C O B O L Verbs (continued) 
CANCEL 
identi f i e r - 1 
l i t e r a l - 1 
CLOSE 
f i le-name - 1 
[REEL 
{UNIT 
WITH 
[FOR REMOVAL] 
NO REWIND] 
LOCK 
I 
CLOSE {file-name-1} 
[WITH LOCK] } . . . 
COMPUTE { i d e n t i f i e r - 1 
[ROUNDED] } . . . 
= 
arithmetic-expression-1 
[Of 
SIZE ERROR 
imperative-statement-1] 
[NOT ON 
SIZE ERROR 
imperative - statement - 2] 
[END-COMPUTE] 
CONTINUE 
nri_ETE fi]e-name-l 
RECORD 
[INVALID 
KEY imperative-statement-1] 
[NOT INVALID 
KEY imperative-statement-2] 
[END- DELETE] 
[INPUT 
[TERMINAL] j 
DISABLE 
• I-O TERMINAL 
OUTPUT 
cd-name-1 
WITH KEY 
i d e n t i f i e r - 1 
l i t e r a l - 1 
DISPLAY 
identi f i e r - 1 
1 i t e r a l - 1 
[UPON 
mnemonic-name-1] 
[WITH 
NO ADVANCING! 
DIVIDE 
i d e n t i f i e r - 1 
l i t e r a l - 1 
INTO 
{ i d e n t i f i e r - 2 
[ROUNDED] } 
[ON 
SIZE ERROR 
imperative-statement - 1] 
[NOT ON 
SIZE ERROR 
imperati ve-statement - 2] 
[END- DIVIDE] 
identi f i e r - 1 
DIVIDE 
\ 
\ INTO 
[ l i t e r a l - 1 
identi f i e r - 2 
l i t e r a l - 2 
GIVING 
{ i d e n t i f i e r - 3 
[ROUNDED] } . . . 
[ON 
SIZE ERROR 
imperative- statement - 1] 
[NOT ON 
SIZE ERROR 
imperati ve-statement - 2] 
[END-DIVIDE] 

COBOL 
Verbs 
C O B O L Verbs 
(continued) 
DIVIDE 
{"ent1f1er.il 
B
y 
| i d e n t l f i e r - 2 1 
 
[ l i t e r a l - 1 
j ~ 
[ l i t e r a l - 2 
J 
GIVING 
{ i d e n t i f i e r - 3 
[ROUNDED! } . . . 
[ON 
SIZE ERROR 
imperative-statement -1] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END- DIVIDE] 
j i dent i fi er- 1 
j i dent i f i er -~ 2) 
DIVIDE 
C . 
, , 
INTO 
, 
\ 
GIVING 
i d e n t i f i e r - 3 
[ROUNDED] 
[literal-1 
J 
[ l i t e r a l - 2 
j 
REMAINDER 
i d e n t i f i e r - 4 
[ON 
SIZE ERROR 
imperative- statement - 1] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-DIVIDE] 
„,.,,„,- 
[ i d e n t i f i e r - 1 ] 
[ i d e n t i f i e r - 2 l 
DIVIDE 
, , 
[ B Y 
GIVING 
i d e n t i f i e r - 3 
[ROUNDED] 
[ l i t e r a l - 1 
j " 
[ l i t e r a l - 2 
j 
REMAINDER 
i d e n t i f i e r - 4 
[ON 
SIZE ERROR 
imperative-statement-1] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-DIVIDE] 
[INPUT [TERMINAL]] 
ENABLE il-0 TERMINAL 
cd-name-1 
OUTPUT 
WITH KEY 
i d e n t i f i e r - 1 
l i t e r a l - 1 
EVALUATE 
i d e n t i f i e r - 1 
1 i t e r a l - 1 
expression-1 
TRUE 
FALSE 
ALSO 
(WHEN 
[NOJJ 
i d e n t i f i e r - 2 
l i t e r a l - 2 
expression-2 
TRUE 
FALSE 
ANY 
condition-1 
TRUE 
FALSE 
i d e n t i f i e r - 3 
] 
l i t e r a l - 3 
arithmetic-expression -1 
[THROUGH] 
[THRU 
J 
identi t i e r - 4 
l i t e r a l - 4 
arithmetic-expression-

Appendix 
D - 
COBOL-85 
Reference 
Summary 
(continued) 
ALSO 
ANY 
condition-2 
TRUE 
FALSE 
i d e n t i f i e r - 5 
I 
l i t e r a l - 5 
arithmetic-expression-3 
[NOT] 
identi f i e r - 6 
THROUGH 
, , 
\ 
\ 
l l i t e r a l - 6 
THRU 
^ 
' 
a n thmetic-expression-4 
imperative-statement-1} 
. . . 
[WHEN OTHER 
imperative-statement - 2] 
[END-EVALUATE] 
EXIT 
EXIT PROGRAM 
GENERATE 
fdata-name-1 
[report-name-1 
cn 
T O 
l"n 
. n 
GO TO {procedure-name-1} 
DEPENDING 
ON 
i d e n t i f i e r - 1 
I F 
c o n d i t i o n - 1 
THEN 
[{statement - 1 } . . 
[NEXT SENTENCE 
ELSE {statement-2} 
ELSE NEXT SENTENCE 
. . 
[END-IF] 
END-IF 
INITIALIZE 
{ i d e n t i f e r - 1 } . . 
REPLACING 
ALPHABETIC 
ALPHANUMERIC 
NUMERIC 
ALPHANUMERIC - EDITED 
NUMERIC-EDITED 
DATA BY 
i d e n t i f i e r - 2 
1 i t e r a l - 1 
INITIATE 
{report-name-1} . . . 
INSPECT 
i d e n t i f i e r - 1 
TALLYING 
i d e n t i f i e r - 2 FOR 
CHARACTERS 
fBEFORE 
[ i d e n t i f i e r - 4 
[ 
[ INITIAL [ 
[AFTER j 
[ l i t e r a l - 2 
ALL 
[ J 1 i d e n t i f i e r - 3 
LEADING} 
] [ l i t e r a l - 1 
[BEFORE] 
[ i d e n t i f i e r -
[ 
\ INITIAL [ 
[AFTER [ 
[ l i t e r a l - 2 

COBOL 
Verbs 
BOL Verbs 
(continued) 
INSPECT 
i d e n t i f i e r - 1 
REPLACING 
CHARACTERS BY 
i d e n t i f i e r - 5 
1 i t e r a l - 3 
CALL 
1 r 
'LEADING I 
FIRST 
j 
identi f i e r - 3 
l i t e r a l - 1 
BY 
[BEFORE) 
{AFTER j INITIAL 
i d e n t i f i e r - 4 
l i t e r a l - 2 
i d e n t i f i e r - 5 
l i t e r a l - 3 
I BEFORE i 
{AFTER j 
INITIAL 
i d e n t i f i e r - 4 ! 
l i t e r a l - 2 
INSPECT 
i d e n t i f i e r - 1 
TALLYING 
i d e n t i f i e r - 2 FOR 
REPLACING 
CHARACTERS BY 
[ALL 
LEADING 
CHARACTERS 
I AFT; 
[ALL 
I [ [ i d e n t i f i e r - 3 
{LEADING/ 1 [ l i t e r a l - 1 
[BEFORE] 
f i d e n t i f i e r - 4 
} INITIAL i 
AFTER [ 
[ l i t e r a l - 2 
1
^
1 
INITIAL 
I
i
d
e
n
t
i
f
1
e
r -
4 ) 
[AFTER j 
[ l i t e r a l - 2 
j 
i d e n t i f i e r - 5 | 
l i t e r a l - 3 
J 
[BEFORE] , „
t
t „ , 
[ i d e n t i f i e r - 4 
1 
1 INITIAL > 
FIRST 
j i d e n t i f i e r - 3 ] 
, m c 
{ l i t e r a l - 1 
J ~ { l i t 
[AFTER J 
^ i d e n t i f i e r - 5 
e r a l - 3 
j 
[ l i t e r a l - 2 
[BEFORE] „ , „ „ , fidentifier-4] 
i 
\ INITIAL { 
} 
[AFTER j 
[ l i t e r a l - 2 
j 
INSPECT 
i d e n t i f i e r - 1 
CONVERTING 
H ^ n t i f i e r - e 
T
Q 
i d e n t i f i e r - 7 
[ l i t e r a l - 4 
|
 
_ 
| l i t e r a l - 5 
[BEFORE] 
m „ , 
[ i d e n t i f i e r - 4 
INITIAL 
[AFTER j 
[ l i t e r a l - 2 
[ASCENDING 
MERGE 
file-name-1 [ON [ 
[ KEY {data-name-1} 
1 
[DESCENDING] 
[COLLATING 
SEQUENCE IS alphabet-name-1] 
USING 
file-name-2 
( f i l e - n a m e - 3 } . . . 
"[THROUGH] 
{THRU 
J 
OUTPUT PROCEDURE IS procedure - name - 1 
GIVING { f i l e - n a m e - 4 } . . . 
i d e n t i f i e r - 1 
MOVE 
I 
[ TO { i d e n t i f i e r - 2 } . .  
l i t e r a l - 1 
' —
 
1 
[CORRESPONDING] 
MOVE ] 
\ 
i d e n t i f i e r - 1 TO i d e n t i f i e r - 2 
[CORR 
j 
— 
[ i d e n t i f i e r - 1 
MULTIPLY [ 
[ BY { i d e n t i f i e r - 2 
[ROUNDED] 
[ l i t e r a l - 1 
j 
[ON 
SIZE ERROR imperative-statement-1] 
[NOT ON SIZE ERROR imperative-statement-2] 
[END-MULTIPLY] 
procedure-name-2 

A
p
p
e
n
d
i
x 
D - 
- COBOL-85 
Reference 
Summary 
COBOL Verbs (continued) 
MULTIPLY 
l i t e r a l - 1 
BY 
{identi t i e r - 2 
[ROUNDED] 
[ON 
SIZE ERROR 
imperati ve-statement - 1 ] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-MULTIPLY] 
MULTIPLY 
i d e n t i f i e r - 1 
l i t e r a l - 1 
BY 
i d e n t i f i e r - 2 
l i t e r a l - 2 
GIVING 
{ i d e n t i f i e r - 3 
[ROUNDED] } . . . 
[ON 
SIZE ERROR 
imperative-statement -1] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-MULTIPLY] 
OPEN 
INPUT { f i l e - n a m e - 1 
[WITH NO REWIND] } 
OUTPUT { f i l e - n a m e - 2 
[WITH NO REWIND] ) 
I - 0 
{ f i l e - n a m e - 3} . . . 
EXTEND 
( f i l e - n a m e - 4 ) . . . 
ft I 
OPEN 
INPUT {file-name-1} 
. 
OUTPUT {file-name-2} 
1-0 
{file-name-3} 
. 
EXTEND 
{file-name-4} 
W 
OPEN 
J OUTPUT { f i l e - n a m e - 1 
[WITH NO REWIND] } 
[EXTEND 
{file-name-2} . . . 
PERFORM 
procedure-name - 1 
jTHROUGH| 
[THRU 
J 
procedure-name-2 
[imperative-statement-1 
END-PERFORM] 
PERFORM 
procedure-name - 1 
fTHROUGH] 
{ 
> procedure-name-2 
[THRU 
j 
identi f i e r - 1 
i n t e g e r - 1 
TIMES 
[imperative-statement-1 
END - PERFORM] 
PERFORM 
procedure - name -1 
[BEFORE] 
fTHROUGH] 
< 
~ > procedure-name-2 
[THRU 
[ 
WITH 
TEST 
[AFTER J 
UNTIL c o n d i t i o n - 1 
[imperati ve-statement - 1 
END-PERFORM] 
[ i d e n t i f i e r - 1 

COBOL 
Verbs 
I'L v,: o r b s (continued) 
PERFORM 
procedure-name-1 
[BEFORE] 
[THROUGH] 
[THRU 
j 
procedure-name-2 
WITH 
TEST 
I AFTER I 
, 
, 
i d e n t i f i e r - 3 
i d e n t i f i e r - 2 
VARYING \ 
\ FROM 
[ i ndex - name - 2 
i ndex-name-1 
1 
' 
l i t e r a l - 1 
identi f i e r - 4 
BY \ 
\ UNTIL 
condition-1 
— 
l i t e r a l - 2 
i d e n t i f i e r - 6 
, identi f i e r - 5 
AFTER { 
\ FROM 
i i ndex - name- 4 \ 
' l i t e r a l - 3 
[ 
| 
l i t e r a l - 3 
f i d e n t i f i e r - 7 ] 
BY 
1 
> UNiIL 
condition-2 
— 
[ l i t e r a l - 4 
] 
[imperat ive-statement - 1 
END-PERFORM] 
PURGE 
cd-name-1 
READ 
f i l e - n a m e - 1 
[NEXT] RECORD 
[INTO 
i d e n t i f i e r - 1 ] 
[AT END 
imperative-statement-1] 
[NOT AT END 
imperative-statement-2] 
[END-READ] 
READ 
f i l e - n a m e - 1 
RECORD 
[INTO 
i d e n t i f i e r - 1 ] 
[INVALID KEY 
imperative-statement - 3] 
[NOT INVALID KEY 
imperative- statement - 4] 
[END-READ] 
READ 
f i l e - n a m e - 1 
RECORD 
[INTO 
i d e n t i f i e r - 1 ] 
[KEY IS data-name-1] 
[INVALID KEY 
imperative- statement - 3] 
[NOT INVALID KEY 
imperative-statement - 4] 
[END-READ] 
[MESSAGE] 
RECEIVE 
cd-name-1 
\ 
} 
INTO 
i d e n t i f i e r - 1 
[SEGMENT] 
— 
[NO DATA 
imperati ve-statement - 1 ] 
[WITH DATA 
imperati v e - s t a t e m e n t - 2 ] 
[END-RECEIVE] 
RELEASE 
record-name-1 
[FROM i d e n t i f i e r - 1 ] 

A
p
p
e
n
d
i
x 
D 
COBOL-85 
Reference 
Summary 
COBOL Verbs (continued) 
RETURN 
f i l e - n a m e - 1 
RECORD 
[INTO 
i d e n t i f i e r - 1 ] 
AT END imperative-statement-1 
[NOT AT END 
imperative-statement-2] 
[END-RETURN] 
REWRITE 
record-name-I 
[FROM i d e n t i f i e r - 1 ] 
REWRITE 
record-name-1 
[FROM i d e n t i f i e r - 1 ] 
[INVALID 
KEY imperative-statement-1] 
[NOT INVALID 
KEY imperative-statement-2] 
[END-REWRITE] 
SEARCH 
i d e n t i f i e r - 1 
VARYING 
j
i
d
e
n
t
1
f
i
e
r -
2 
i ndex - name - 2 
[AT 
END 
imperative-statement-1] 
L,.,r., 
, 
(imperative-statement-2 
^WHEN 
c o n d i t i o n - 1 
i 
( 
I NEXT - SENTENCE 
TEND - SEARCH] 
SEARCH ALL 
i d e n t i f i e r - 1 
[AT 
END imperative-statement-1] 
flS 
EQUAL TO 
WHEN 
AND 
data-name-1 
IS 
condition-name-2 
data-name-2 
IS 
EQUAL TO 
I S 
-
condition-name-2 
i mperati ve - statement - 2 
NEXT SENTENCE 
i d e n t i f i e r - 3 
l i t e r a l - 1 
1 
a r i t h m e t i c - e x p r e s s i o n - l j 
i d e n t i f i e r - 4 
J 
l i t e r a l - 2 
a r i t h m e t i c - e x p r e s s i o n - 2 
[END - SEARCH] 
SEND 
cd-name-1 FROM 
i d e n t i f i e r - 1 
SEND 
cd-name-1 
[FROM 
i d e n t i f i e r - 1 ] 
[BEFORE} 
[AFTER J 
ADVANCING 
WITH 
i d e n t i f i e r - 2 
WITH E S I 
WITH EMI 
WITH EGI 
identifier-3 
integer-1 
Jmnemonic-name-1 
[PAGE 
LINE 
LINES 
[REPLACING 
LINE] 

COBOL 
Verbs 
IL Verbs (continued) 
SET 
index-name-1 
i d e n t i f i e r - 1 
i ndex - name - 2 
TO 
\ i d e n t i f i e r - 2 
i n t e g e r - 1 
SET 
(index-name-3) . 
UP BY 
J i d e n t i f i e r - 3 
DOWN BY j 
j i n t e g e r - 2 
SET 
|(mnemonic-name-1} . . . 
TO 
ON 
OFF 
SET 
(condition-name-1} 
. . . TO TRUE 
fASCENDING ] 
SORT 
f i l e - n a m e - 1 
-JON I 
} 
KEY (data-name-1} . 
DESCENDING 
[WITH 
DUPLICATES 
IN ORDER] 
[COLLATING 
SEQUENCE 
I S 
alphabet - name-1] 
INPUT PROCEDURE 
I S 
procedure - name - 1 
USING 
[ f i l e - n a m e - 2 ] 
. . . 
f THROUGH 1 
( 
> procedure-name-2 
[THRU 
j 
OUTPUT PROCEDURE 
I S 
procedure-name - 3 
GIVING 
[file-name-3] . . . 
jTHROUGH] 
[THRU 
J 
procedure-name-4 
START 
f i l e - n a m e - 1 
KEY 
I S 
EQUAL TO 
IS 
' 
IS GREATER THAN 
I S 
> 
IS NOT LESS THAN 
IS NOT < 
I S GREATER THAN OR EQUAL TO 
I S 
>= 
[INVALID 
KEY 
imperative-statement-1] 
[NOT INVALID 
KEY 
imperative-statement-2] 
[END-START] 
data - name -1 
STOP 
RUN 
1 i t e r a l - 1 

A
p
p
e
n
d
i
x 
D 
— COBOL-85 
Reference 
Summary 
STRING 
is (continued) 
identi t i e r - 1 
l i t e r a l - 1 
i d e n t i f i e r - 2 
DELIMITED 
BY j l i t e r a l - 2 
SIZE 
INTO 
i d e n t i f i e r - 3 
[WITH POINTER 
i d e n t i f i e r - 4 ] 
[ON 
OVERFLOW 
imperative-statement - 1 ] 
[NOT 
ON 
OVERFLOW 
imperative-statement-2] 
[END - STRING1 
SUBTRACT 
identi f i e r - 1 
l i t e r a l - 1 
FROM 
{ i d e n t i f i e r 
[ROUNDED] 
[ON 
SIZE ERROR 
imperative- statement - 1 ] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-SUBTRACT] 
SUBTRACT 
identi f i e r - 1 
l i t e r a l - 1 
FROM 
I i d e n t i f i e r - 2 
l i t e r a l - 2 
GIVING 
( i d e n t i f i e r - 3 } 
[ROUNDED] 
} . . . 
[ON 
SIZE ERROR 
i m p e r a t i v e - s t a t e m e n t - l j 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-SUBTRACT] 
fCORRESPONDING 1 
SUBTRACT 
{ — 
\ i d e n t i f i e r - 1 
FROM 
i d e n t i f i e r - 2 
[ROUNDED] 
[CORR 
[ON 
SIZE ERROR 
imperative- statement - 1] 
[NOT ON 
SIZE ERROR 
imperative-statement-2] 
[END-SUBTRACT] 
SUPPRESS 
PRINTING 
TERMINATE 
{report - name-1} . . . 
UNSTRING 
i d e n t i f i e r - 1 
DELIMITED 
BY [ALL] 
i d e n t i f i e r - 2 
l i t e r a l - 1 
OR 
[ALU 
i d e n t i f i e r - 3 
l i t e r a l - 2 
INTO 
{ i d e n t i f i e r - 4 
[DELIMITER 
IN 
i d e n t i f i e r - 5 ] 
[COUNT 
IN 
identi f i e r - 6 ] } 
[WITH 
POINTER 
identi f i e r - 7 ] 
[TALLYING 
IN 
i d e n t i f i e r - 8 ] 
[ON 
OVERFLOW imperative-statement-1] 
[NOT 
ON 
OVERFLOW imperative-statement-2] 
[END-UNSTRING] 

COPY 
and 
REPLACE 
Statements 
(continued) 
USE 
[GLOBAL] 
AFTER STANDARD 
fEXCEPTION { 
[ERROR 
J 
PROCEDURE ON 
{file-name -1} 
INPUT 
OUTPUT 
NO 
EXTEND 
USE 
[GLOBAL] 
BEFORE REPORTING 
identifier-1 
USE FOR DEBUGGING ON 
cd-name-1 
[ALL 
REFERENCES OF] identifier-1 
file-name - 1 
procedure-name - 1 
ALL PROCEDURES 
WRITE record-name-1 
[FROM 
identifier-1] 
fBEFORE} 
[AFTER j ADVANCING 
J identifier-2 | 
LINE 
[integer-1 
j [LINES 
fmnemonic-name - l | 
[PAGE 
j 
, END-OF-PAGE, 
AT 
i 
} imperative-statement-1 
EOP 
' 
, END-OF-PAGE, 
NOT AT {
~ 
} imperati ve-statement-2 
EOP 
TEND-WRITE] 
WRITE record-name-1 
[FROM 
identifier-1] 
[INVALID KEY imperative-statement-1] 
[NOT INVALID KEY imperative-statement - 2] 
[END-WRITE] 
COPY text-name-1 
library-name - 1 
REPLACING 
= = pseudo-text-1 
identi f i e r - 1 
1iteral-1 
word - 1 
BY 
= = pseudo-text-2 
identifier-2 
literal-2 
word-2 
REPLACE {== pseudo-text-1 == 
BY == pseudo-text-2 
= = ) . . . 
REPLACE OFF 

A
p
p
e
n
d
i
x 
D — COBOL 
-85 
Reference 
Summary 
RELATION CONDITION 
identifier-1 
literal-1 
arithmetic-expression-1 
i ndex - name -1 
IS [NOT] GREATER THAN 
IS [NOT] > 
IS [NOT] LESS THAN 
IS [NOT] < 
IS [NOT] EQUAL TO 
IS [NOT] -
IS GREATER THAN OR EQUAL TO 
IS >• 
IS LESS THAN OR EQUAL TO 
IS <= 
identifier-2 
literal-2 
arithmetic-expression-2 
i ndex - name - 2 
CLASS CONDITION 
i d e n t i f i e r - 1 
IS [NOT] 
NUMERIC 
ALPHABETIC 
ALPHABETIC-LOWER 
ALPHABETIC-UPPER 
class-name 
C O N D i T i O N - N A M E C O N D I T I O N 
condition-name-1 
SWITCH-STATUS CONDITION 
condition-name-1 
sign condition 
[positive! 
arithmetic-expression-1 IS [NOT] [NEGATIVE 
ZERO 
NEGATED CONDITION 
NOT conditional 
COMBINED CONDITION 
,fAND] 
condition-1 << 
> condition-2 
I OR 
ABBREVIATED COMBINED RELATION CONDITION 
relation- condition [j^j 
[NOT] [relational- operator] 
object \ . . . 

Qualification 
F O R M A T 1 
[data-name-1 
1 
[condition-name] 
IN) 
[ f i l e - n a m e 
OF I 
]cd-name 
J l N j 
| f i l e - n a m e [ 
[ O f ] 
[cd-name 
| 
F O R M A T 2 
IN 
paragraph-name j 
> section-name 
F O R M A T 3 
IN 
text-name I~ \ 
library-name 
OF 
F O R M A T 4 
IN 
LINAGE-COUNTER [ - [ 
report-name 
F O R M A T 5 
[page-counter] [in 
LINE-COUNTER 
OF 
report - name 
F O R M A T 6 
data-name-3 
— y data-name - 4 
Off 
report - name 
report - name 

Appendix 
D 
COBOL-85 
Reference 
Summary 
S U B S C R I P T I N G 
j c o n d i t i o n - n a m e - 1 
[ d a t a - n a m e - 1 
i n t e g e r - 1 
data-name-2 
[ {±j 
i n t e g e r - 2 ] 
index-name-1 
t (±) 
i n t e g e r - 3 ] 
R E F E R E N C E M O D I F I C A T I O N 
data-name-1 
( l e f t m o s t - c h a r a c t e r - p o s i t i o n : 
[length]) 
IDENTIFIER 
data-name-1 
data-name-2 
cd-name 
f i l e - n a m e 
report-name I 
[ ( {subscript} 
. . . ) ] 
[ ( l e f t m o s t - c h a r a c t e r - p o s i t i o n : 
[length] 
) 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
program-name-1 
[IS 
INITIAL 
PROGRAM] . 
[ENVIRONMENT DIVISION, envi ronment- di vi si on - content] 
[DATA DIVISION, data - d i v i sion-content ] 
[PROCEDURE DIVISION, 
p r o c e d u r e - d i v i s i o n - c o n t e n t ] 
[ [nested-source-program] . . . 
END PROGRAM program-name-1.] 
N E S T E D - S O U R C E - P R O Q R A M 
IDENTIFICATION DIVISION. 
PROGRAM-ID. 
program-name-2 » 1 
COMMON 
name-2 » 1 1 
INITIAL 
PROGRAM 
[ENVIRONMENT DIVISION, envi ronment- di vi si on- content] 
[DATA DIVISION, data - d i v i sion-content] 
[PROCEDURE DIVISION, procedure-di vi s i o n - c o n t e n t ] 
[nested-source-program] . . . 
END PROGRAM 
program-name-2. 

A Series 
of 
Source 
Programs 
{IDENTIFICATION DIVISION. 
PROGRAM - ID. 
program-name-3 
[IS INITIAL PROGRAM] 
[ENVIRONMENT DIVISION, envi ronment - division- content] 
[DATA DIVISION, data - di vi si on-content ] 
[PROCEDURE DIVISION, procedure-di vi sion-content] 
[nested-source-program] . . . 
END PROGRAM program - name - 3.} . . . 
IDENTIFICATION DIVISION-
PROGRAM -ID. 
program-name-4 
[IS INITIAL PROGRAM] 
[ENVIRONMENT DIVISION, envi ronment - divi sion-content] 
[DATA DIVISION, data - di vi sion-content ] 
[PROCEDURE DIVISION, procedure-di vi si on-content] 
[ [nested-source-program] . . . 
END PROGRAM program - name - 4. ] 


The COBOL language Is overdue for its next major revision. Since 
its origination in 1958, COBOL has had several major revisions reflecting the 
changing needs of business information systems. Each revision has added to 
the power and capability of the language, and now perhaps the most sweeping 
revision is waiting in the wings. 
COBOL was originally designed to be as English-like as possible. Even 
m a t h o m a t i r - a l o v n r o c c i n n q u/oro t n h o c t a t p H in F n n l i c h T h i ic H O R O l 
h a c \ / o r h c 
like ADD, SUBTRACT, MULTIPLY, and DIVIDE. Every effort was made to make 
the language readable, so that even a non-programmer could read it. Eventually, 
it became apparent that this idealistic approach was too limiting. Programmers 
found that specifying complex expressions only through the use of ADD, 
SUBTRACT, MULTIPLY, and DIVIDE verbs was too restrictive. COBOL needed a 
way to make writing mathematical expressions easy in a way similar to FORTRAN 
and other languages. The 1964 revision made COBOL more flexible with the 
addition of the COMPUTE verb and other changes. 
By 1974 a new revision was needed. Business applications needed to 
manipulate character data as well as numbers. Thus, new string operations were 
added and the INSPECT verb was improved. However, by the 1980s, structured 
programming had become the standard way to write programs, and COBOL 
needed to change in order to take advantage of this new technique. 
After much discussion in the COBOL community and after the delay of 
several years, COBOL 1985 was finally released. COBOL 1985 had many new 
and important features. For the first time, in-line PERFORM statements meant 
that loops were available directly in the code without having to set up separate 
paragraphs. Statement terminators such as END-IF and END-READ meant that 
logic errors caused by the careless placement of the period could be reduced. 
COBOL 1985 provided a powerful new Case statement, EVALUATE, reducing 
the programmer's reliance on nested IFs. Another major development in COBOL 
1985 was the use of subprograms and new ways of structuring programs. 
COBOL 1985 was a major step forward in the development of the language. The 
new COBOL was less English-like, but still maintained its readability, business 
orientation, and compatibility with previous versions. 

Appendix 
E — COBOL 
1997, 
1998, 
1999, 
2000. 
or 
...? 
In 1989, an enhanced version of the 1985 standard was released. The 
major change in this version was the introduction of intrinsic functions that were 
common in other programs but had been neglected in COBOL. Now COBOL 
programs could use statistical functions such as Average and Standard Deviation 
as well as business functions such as Present Value and Annuity. 
Now, a new COBOL standard is being prepared. Just as the paradigm shift 
to Structured programming meant a revision to the COBOL standards, the new 
paradigm shift to object-oriented programming means that COBOL must again 
be revised. The major addition to the new COBOL is object-orientation, and 
Chapter 20 deals extensively with those changes. However, there are a number 
of less dramatic changes in the next version of COBOL that programmers 
should know about even if they do not use OO COBOL. 
That is the good news; the bad news is that the wheels of standardization 
grind very slowly. The new standards were scheduled to be approved and 
become official in 1997. However, for a variety of reasons the final approval 
appears to be delayed until the year 2000. This delay is extremely unfortunate 
and does not help the cause of the COBOL language. 
In spite of this setback, some compiler vendors who have made good faith 
efforts to begin implementing some of the new language features. The COBOL 
community should push for a quick adoption of the new standards and ask their 
language vendors how they are supporting the new standards. 
The purpose of this appendix is to describe the enhancements to COBOL 
that were included in the 1989 revisions and the projected enhancements for 
COBOL 2000. The appendix does not describe these changes in detail; our aim 
is intended to provide a summary of the major improvements and their impact. 
The major change in the 1989 revision was the addition of intrinsic functions. 
This appendix includes a section on intrinsic functions that presents: 
• 
The concept of functions. 
• 
The format of the FUNCTION statement. 
• 
Classification of the functions by type. 
• 
Brief descriptions of key functions. 
• 
An introduction to the proposed additions to the functions. 
• 
A discussion of user-defined functions. 
The second section of the appendix discusses new data types including 
Boolean and the operators allowed by the new standards. 
Finally, we discuss some of the changes that improve the language, but 
are difficult to classify. 
M o s t computer languages provide a set of predefined functions that save 
p r o g r a m m i n g effort. These functions d o standard a n d well-understood 
mathematical, business, and statistical operations. C O B O L has been slow to adopt 
this capability, but at last, there w a s a general recognition that the language had 
m o v e d beyond being just a specialized business language. Therefore, in 1989 an 

Intrinsic 
Functions 
enhancement to the 1985 standards defined 42 "intrinsic" functions. Intrinsic m e a n s 
"inherent" or "part of." Thus, these functions are n o w p a n of the language. 
A function performs an operation and returns a result. Generally functions are 
used within assignment statements and can be used instead of a variable or literal. 
Within C O B O L the assignment verbs are M O V E and C O M P U T E . For example would 
be: 
M O V E F U N C T I O N U P P E R C A S E ("abcdef') T O D A T A - S T R I N G 
The function-identifier specifies the function as U P P E R C A S E , a n d the single 
argument s h o w n in the parentheses is "abcdef." The U P P E R C A S E functions converts 
alphanumeric data to upper case, and as a result D A T A - S T R I N G contains the value 
" A B C D E F " after the M O V E statement has been performed. 
A n example of a numeric function-identifier would be: 
C O M P U T E N U M E R I C - I T E M = F U N C T I O N SIN(IO) 
The C O M P U T E statement calculates the sine of 10 a n d return the value to 
N U M E R I C - I T E M so that the final value of N U M E R I C - I T E M is 0.544. SIN is the 
function identifier and 10 is the argument. 
The format of a function-identifier is as follows: 
F U N C T I O N function-name-1 [({argument-1}...)] 
Numeric functions must be used with C O M P U T E cannot be used with A D D , 
S U B T R A C T , M U L T I P L Y , or DIVIDE. 
Function Types 
The various types of intrinsic functions are s h o w n in the following tables. W e have 
categorized t h e m according to their purpose. 
T w o business functions are n o w provided to m a k e the computation of 
annuities a n d the value of investments easier. 
T&.&ki hs\ Business Functions 
ANNUITY 
Interest rate for 
Number of Periods 
The ratio of an annuity paid for an initial 
period 
investment of $1.00 
PRESENT-VALUE 
Discount Rate 
A series of Future 
The present value of the Future Payments based 
Payments 
on the Discount Rate 
Date functions are based primarily o n a starting date of January 1, 1601. This 
arbitrary date is established to assure accuracy for date arithmetic under virtually 
all circumstances. All dates are based o n the Gregorian calendar. Dates supplied to 
a date function must be valid calendar dates after December 31, 1600. 
Table £-2 
Date Functions 
CURRENT-DATE 
DATE-OF-INTEGER 
DAY-OF-INTEGER 
INTEGER-OF DATE 
INTEGER OF DAY 
None 
None 
Number of Days 
succeeding December 
31, 1600 
Number of Days 
succeeding December 
31, 1600 
Date in YYYYMMDD 
format 
Date in YYYYDDD 
format 
Returns the current system date and time 
in YYYYMMDDHHMMSShh format 
Returns the date in YYYYMMDD format 
Returns the date in YYYYDDD format 
Returns an integer for the number of days 
succeeding December 31, 1600 
Returns an integer for the number of days 
succeeding December 31, 1600 

A
p
p
e
n
d
i
x 
g — COBOL 
1997, 
1998, 
1999, 
2000, 
or 
There are a n u m b e r of mathematical functions available as intrinsic functions. 
All except the S u m function have a single argument. The S u m function can have as 
m a n y arguments as required, since it adds up a series of numbers. 
Table E.3 M a t h e m a t i c a l F u n c t i o n s 
ACOS 
Number 
None 
Returns the Arcosine of the number 
ASIN 
Number 
None 
Returns the Arcsine of the number 
ATAN 
Number 
None 
Returns the Arctangent of the number 
COS 
Number 
None 
Returns the Cosine of the number 
FACTORIAL 
Number 
None 
Returns the Factorial of the number 
LOG 
Number 
None 
Returns the natural Logarithm of the 
number 
LOG 10 
Number 
None 
Returns the Logarithm to base 10 of the 
number 
SIN 
Number 
None 
Returns the Sine of the number 
SUM 
Number 
Number 
Returns the total of ail values specified 
(as many as needed) 
SORT 
Number 
None 
Returns the Square Root of the number 
TAN 
Number 
None 
Returns the Tangent of the number 
The intrinsic functions also include a n u m b e r of statistical functions. Statistical 
functions work o n a series of numbers. The n u m b e r series can be specified by using 
one argument for each value. W h e n tables are involved, there is an easier method. 
Statistical functions can specify A L L for the subscript in the argument, as in the 
following example: 
01 TEST-ARRAY. 
05 TEST-RESULT 
PIC 9(03). 
05 TEST-ITEMS 
OCCURS 5 TIMES PIC 9(02). 
COMPUTE TEST-RESULT = FUNCTION SUM (TEST-ITEMS (ALL)). 
This statement adds all of the values in the table T E S T - I T E M S and stores the 
results in TEST-RESULT. T h e S U M function can be considered as a mathematical 
or statistical function. 
'able E.4 Statistical Functions 
MAX 
MEAN 
MEDIAN 
MiDRANGE 
RANDOM 
RANGE 
STANDARD-DEVIATION 
SUM 
VARIANCE 
Number series 
Number series 
Number series 
Number series 
Number 
(not required) 
Number series 
Number series 
Number series 
Number series 
As needed 
As needed 
As needed 
As needed 
None 
As needed 
As needed 
As needed 
As needed 
Returns the value of the highest number in the 
series 
Returns the arithmetic average of the series 
Returns the middle value of the series where 
there are as many values above as below 
Returns the average of the maximum argument 
and the minimum argument 
Returns a random number between 0 and 1. 
If argument-1 is specified, it must be zero or a 
positive integer and is used as a seed value 
Returns a value that is equal to the value of the 
maximum argument minus the value of the 
minimum argument 
Returns the standard deviation of the series 
Returns the sum of the number series 
Returns the variance of the number series 

Intrinsic 
Functions 
Another set of functions deals with the use of alphanumeric data a n d 
conversion between alphanumeric and numeric data. 
T;-:.iJfc- i:..S Alphanumeric and Conversion Functions 
CHAR 
LENGTH 
LOWER-CASE 
NUMVAL 
NUMVAL-C 
ORD 
ORD-MAX 
ORD-MIN 
REVERSE 
UPPER-CASE 
Integer 
None 
Alphanumeric string 
None 
Alphanumeric string 
None 
Edited numeric string None 
Edited numeric string Symbol used as 
with currency symbol 
currency symbol 
Alphanumeric 
character 
Alphanumeric or 
numeric series 
Alphanumeric or 
numeric series 
None 
None 
None 
Alphanumeric string 
None 
Alphanumeric string 
None 
The alphanumeric character corresponding to 
ordinal position in the collating sequence 
Returns the number of characters in the string 
Converts all alphabetic characters to lower case 
Returns the numeric value ot the edited string. 
Cannot be used with currency symbol 
Returns the numeric value of the edited string. 
Uses argument-2 to determine the currency 
symbol 
Returns the ordinal position number of the 
alphanumeric character 
Returns the ordinal position number within the 
series of the element having the highest 
collating value 
Returns the ordinal position number within the 
series of the element having the lowest collating 
value 
Returns an alphanumeric string the same length 
as argument-1 with the characters in reverse 
order 
Converts all alphabetic characters to upper 
case 
Finally, a set of miscellaneous functions that are not easily categorized into 
one of the above tables is provided 
Yak;** iLo Miscellaneous Functions 
INTEGER 
INTEGER-PART 
MOD 
REM 
WHEN-COMPILED 
Numeric value 
Numeric value 
Integer 
Numeric value 
None 
returned 
Integer 
Numeric value 
None 
Largest Integer not greater than Argument-1. If 
Argument-1 is +2.3, +2 is returned. If 
Argument-1 is -2.3, the value returned is -3 
Integer portion of Argument-1. If Argument-1 is 
+2.3, +2 is returned. If Argument-1 is -2.3, -2 is 
Returns the value of the remainder when 
Argument-1 is divided by Argument-2. The 
result is an integer value 
Same as MOD but can use and return non-
integer values. 
Returns the compile date and time in 
YYYYMMDDHHMMDD format 
C O B O L 2000 adds a n u m b e r of functions to the 1989 extensions. Several of these 
functions deal with manipulation of national characters—symbols that are not part 
of the English language, but are used in other languages. There are also functions 
that handle special collating sequences in other languages. The following table 
includes only the n e w functions that are of m o r e general interest. Other functions 
m a y be added or changed before the n e w standards are adopted. 

A
p
p
e
n
d
i
x 
E 
- 
COBOL 
1997, 
1998, 
1999, 
2000, 
or 
...? 
Tfe.a« £.7 COBOL 2000 Functions 
ABS 
Numeric value 
ALLOCATED- OCCURRENCES 
Dynamic Table 
BOOLEAN-OF 
DATE-TO-YYYYMMDD 
DAY-TO-YYYYDDD 
E 
EXP 
EXP 10 
FRACTION-PART 
NUMVAL-B 
NUMVAL-F 
PI 
YEAR-TO-YYYY 
Positive Integer 
Positive Integer 
Positive Integer 
None 
Numeric Item 
Numeric Item 
Numeric Item 
Boolean Value 
Numeric value 
specified as 
floating point 
None 
Positive Integer 
Positive Integer 
Integer 
Integer 
None 
Integer 
Returns the absolute value of Argument-1 
Returns an integer value for the number of 
occurrences allocated in the table 
Returns the binary value of Argument-1 in a 
binary field with Argument-2 number of bits 
Converts YYMMDD date format to YYYYMMDD 
format. Argument-2 allows adjustment to the 
century range Argument-2 defines the ending 
year as a displacement from the current system 
year. If Argument-2 is omitted, the default is 50 
Converts YYDDD date to format to YYYYDDD 
format. Argument-2 allows adjustment to 
century range 
Returns the value of e, the natural logarithm 
base 
Returns the value of e raised to the Argument-1 
power 
Returns the value of 10 raised to the Argument-1 
power 
Returns the fractional part of ArgumenM 
eliminating the integer portion 
Returns the decimal equivalent of the Binary 
value of ArgumenM, Function may use the 
SIGNED keyword following ArgumenM to 
indicate that ArgumenM is a signed value 
Returns the decimal equivalent of 
ArgumenM 
Returns the value of PI up to 31 decimal places 
Converts YY to YYYY. Argument-2 specifies a 
window for candidate dates. 
In addition to the n e w intrinsic functions defined above, C O B O L 2000 also 
allows the creation a n d use of user defined functions. 
The C O B O L 2000 standards allow for several n e w data types that have been available 
to other languages. These data types include n e w fixed length B I N A R Y data fields, 
Floating-Point data types, a n d n e w pointer types. These data types can be specified 
by the U S A G E clause of data items within the D A T A DIVISION. 
C O B O L 1985 allowed the B I N A R Y data type. This data type has a variable 
length dependent u p o n places specified in the picture clause. The binary options 
have been expanded to a Boolean data type a n d several fixed length B I N A R Y data 
types. 
• BIT—this data type is a Boolean Data type used for Boolean Operations. The 
size of the field is specified by the Picture clause. 
• B I N A R Y - C H A R — a binary field using 1 byte for representation. 
• B I N A R Y - S H O R T — a binary file 2 bytes in length. 
• B I N A R Y - L O N G — a binary field 4 bytes in length. 

New 
Data 
Types 
• B I N A R Y - D O U B L E — a binary field 8 bytes in length. 
C O M P ( U T A T I O N A L ) usage is left u p to the compiler implementers, but is 
generally the equivalent of BINARY. 
Floating point numbers are specified as F L O A T - S H O R T or F L O A T - L O N G . The 
size of the fields is dependent o n the implementor. Generally, the F L O A T - S H O R T 
will use 2 bytes of storage and F L O A T - L O N G uses 4 bytes. In other languages, these 
data types m a y be called "Single" or "Double." 
These n e w data types will m a k e the linking of C O B O L programs with programs 
developed in other languages m u c h easier. C O B O L will be able to receive and pass 
data directly to programs written in other languages. This n e w compatibility is also 
enhanced by an n e w I N T E G E R data type. This data type accepts Integer data in the 
format of other languages. The use of I N T E G E R is limited to use in the L I N K A G E 
S E C T I O N of programs and must be associated with a B Y V A L U E reference. 
In connection with object-oriented C O B O L , the 2000 standard provides a n e w 
pointer type to specify the pointers for Objects. This U S A G E is O B J E C T R E F E R E N C E . 
The pointer type follows the conventions of other pointer and index data types. The 
SET verb must be used to update these fields. 
Free F o r m Source Code: In the n e w C O B O L standards, the C O B O L programmer is 
freed from the confines of the 80-column card. The n e w standards allow source 
code lines to be from 0 to 255 characters in length, and the code can be placed 
anywhere in the line. In order to achieve this n e w freedom, the standards committee 
has decided to change the c o m m e n t indicator from a "*" in column 7 to the characters 
"*>" placed anywhere in the source code line. A n y characters to the right of the 
c o m m e n t indicator are treated as comments. The c o m m e n t stops at the end of a 
line. Therefore, if a c o m m e n t needs to go onto two or lines, each c o m m e n t line or 
area must begin with "*>". There is no symbol to stop the c o m m e n t . 
The free format also provides n e w capability in continuing literals from one 
line to another. The partial literal o n the first line should be ended by a "- or'-. The 
second line of the can start anywhere o n the second line, but must begin with a " or 
'. The literal must conclude with a " or'. 
The n e w free format provides n e w flexibility in writing code a n d in program 
documentation. 
Fewer Required Entries: Another change in the coding of programs is a loosening of 
the rules for required entries in a program. For example, the Division headers do 
not have to be specified at all. Section headers are still needed, but only for the 
sections actually used. O n e exception to the n e w rule about Division headers is 
w h e n the Procedure Division needs a Linkage Section. T h e Procedure Division 
header has to specify the use of the Linkage Section. Therefore, the Procedure 
Division header to define Linkage Section entries. 
C O B O L 2000 is part of the language's gradual evolution. While the introduction of 
object-orientation is the primary n e w language feature, the addition of n e w intrinsic 
functions, the n e w data types, and the n e w freedom for coding programs will all 
m a k e the C O B O L programmer's life easier. 


H I 
••IT JThJli 
1. Input, processing, output 
3. Flowchart 
5, Decision 
7, Programmer-supplied-name 
9. Relational 
11. Fields 
1. False. 
Nonnumeric literals may contain numbers, 
letters, or special characters. 
3. False. A dataname may contain hyphens. 
5. True. 
7. True. 
9. False. They must appear in order: IDENTIFICATION, 
ENVIRONMENT, DATA, and PROCEDURE. 
11. True. 
13. False. They must be told exactly what to do, and the 
instructions take the form of a computer program. 
15. False. A diamond indicates a decision; a rectangle 
implies straight forward processing. 
17. False. Reserved words are restricted to a preassigned 
use. 
19. False. The rules for pseudocode are at the discretion 
of the programmer. 
1. Compiler, source, object (machine) 
3. A margin 
5. 12, 72 
7. Editor (word processor) 
9. 
11. 
13. 
15. 
Debugging 
Linker 
Different 
Execution 
1. False. 
A compiler translates a problem-oriented 
language into a machine oriented language. 
3. True. 
5. True. 
7. False. Division headers may begin anywhere in the A 
margin (columns 8 to 11), although many people 
begin them in column 8. 
9. False. Paragraph names begin in the A margin. 

Appendix 
F — Answers 
to 
Odd-Numbered 
Exercises 
11. False. A clean compile means only that the program 
has been translated into machine language; it says 
nothing about whether the logic of the program is 
correct. 
13. True. 
15. False. Each text editor has its own unique commands. 
17. False. The compiler produces an object module which 
is input to the linker, which in turn produces the load 
module. 
1. Sequence, selection, and iteration 
3. One, one 
5. Hierarchy chart 
7. Completeness, functionality, and span of control 
9. Pseudocode 
11. Span of control 
13. Bohm, Jacopini 
15, Top down 
'me/fmse 
1. False. It may still contain logic errors, but presumably 
fewer than non-structured code. 
3. False, Initialization and termination are too vague 
and do not follow the verb, adjective, object convention 
for naming paragraphs. 
5. True. 
7. False. It is an extension to sequence, selection, and 
iteration. 
9. False. The rules of pseudocode are at the discretion 
of the programmer, although individual shops may 
impose standards. 
11. False. Testing should begin as soon as possible with 
the aid of program stubs. 
13. False. The name implies that the paragraph is doing 
three distinct things, as opposed to having a single 
function. 
15. False. Program testing should be ongoing throughout 
the life of the project. 
17. False. The optimal number of modules is a function of 
the program's design. 
1. Identification 
3. Braces 
5. Programmer supplied 
7. SELECT 
9. PICTURE 
11. FILE, WORKING-STORAGE 
13. may not 
15. BLOCK CONTAINS, logical, physical 
1. True. 
3. False. Square brackets indicate the entry is optional. 
5. False. Some modification, generally in the Environment 
Division is required. 
7. False, It will have a picture clause if it is an elementary 
item. 
9. False. A group item never has a picture clause. 
11. False. The determination of whether a data item is a 
group or elementary item depends on the definition of 
subordinate data items. 
13. True. 
15. False. Technically, a program may be written without 
a File Section, although this is unusual. 
17. False. It is optional as indicated by the brackets in 
the COBOL notation. 

Appendix 
F - 
Answers 
to 
Odd-Numbered 
Exert 
;.%<?•> 
1. COMPUTE 
3. ROUNDED 
5. Before 
7. Does not 
9. STOP RUN 
N + 1 
13. AFTER ADVANCING PAGE 
15. One, left, right 
17. Decimal alignment 
19. May not 
21. SIZE ERROR 
11 
1. 
3. 
5. 
7. 
9. 
11. 
13. 
15. 
True. 
False. An ADD statement must contain one word or 
the other. 
True. 
False. The use of BY or INTO determines which 
operand is the dividend, and which one is the divisor. 
True. 
False. If multiplication and division are both present, 
the order of operations is from left to right. 
True. 
True. 
17. 
19. 
21. 
23. 
25. 
27. 
False. STOP RUN is the last statement executed, but 
it need not be (and usually isn't) the last physical 
statement in the program. 
False. The READ statement specifies a file name. 
False. They are required whenever a file Is present. 
(Strictly speaking, if a program did not reference any 
files, then the statements would not be used). 
True. 
False. 
ROUNDED Is an optional clause in all the 
arithmetic statements. 
False. It is an optional clause. 
1. Compilation 
3. Execution 
5. Compiles 
7. Structured walkthrough 
9. Detection, correction 
11. Run Time Errors 
False. A clean compile means only that the program 
9. 
has been successfully translated into machine 
language. 
11. 
False. The compiler checks for syntax only and has 
no way of determining the validity of a program's 
13. 
logic. 
15. 
True. 
17. 
True. 
False. Spaces are generally required after punctuation 
symbols, but not before. 
False. A data name may contain hyphens, letters, or 
digits only. 
False. One reads a file and writes a record. 
False. Walkthroughs should be held for everyone. 
False. A walkthrough should take a maximum of two 
hours. 
1. Coding standards 
3. Floating, fixed 
5. V, S 
7. Verb, adjective, object 
9. Indentation 
11. Negative 

Appendix 
F 
- Answers 
to 
Odd-Numbered 
Exercises 
1. False. Indentation is used to improve the readability 
of a program. 
3. False. 
Coding standards are a function of the 
individual shop. 
5. False. Data names should be meaningful to simplify 
program maintenance, an activity which takes far more 
time than initial coding and data entry. 
7. False. Comments should be used with caution, and 
always for a specific purpose; a common fault of 
beginners is to over comment. 
9. False. 
The name implies that the paragraph is 
performing two functions. 
11. False. A VALUE clause is used only to assign an 
initial value; for example for heading lines in 
Working-Storage. (VALUE clauses are not permitted 
in the FILE SECTION.) 
13. False. The assignment of CR and/or DB depends on 
the accounting system In use. 
15. False. One or the other should be selected, depending 
on the accounting system. 
17. True. 
19. True. 
1. Validated (checked) 
7. 88 
3. Numeric 
9. END-IF 
5. Completeness 
False. The output of the edit program is input to the 
reporting program. 
True. 
False. The alphabetic class test can be applied to 
only alphabetic or alphanumeric data. 
7. True. 
9. True. 
11. False. DAY and DATE imply the Julian and calendar 
dates, respectively. 
1. Two 
7. STRING, UNSTRING, and INSPECT 
3. Section 
9. BEFORE, AFTER 
5. Qualified, OF, IN 
11. In-line 
1. True. 
9. False. It is an optional statement which is not favored 
3. False. An in-line perform does not specify a procedure. 
by the authors. 
5. False. CORRESPONDING is always optional. 
11. True. 
7. False. The CORRESPONDING option has several 
fine points, but level number is not one of them. 

Appendix 
F 
Answers 
to 
Odd-Numbered 
Exercises 
1. Is not 
3. SECURE 
5. Last 
7. Should not 
9. TEST BEFORE 
11. Interactive 
me 
1. False. Both sections may appear in the same program. 
3. False. The clauses are optional. 
5. True. 
7. False. The text would be illegible; i.e., it would blend 
into the background. 
9. True. 
t-m-tn 
1. OCCURS 
3. Variable, OCCURS DEPENDING ON 
5. May 
7. Is 
9. Does not change 
1. False. Tables are established through an OCCURS 
7, 
clause. 
3. True. 
9. 
5. True. However if a subscript does assume a zero 
value, it would indicate a logic error in the program. 
11. 
False. An index can be used only with the table for 
which it was defined. 
False. Variable length records means that records in 
a file are of different lengths. 
False. An index is modified by a SET or PERFORM 
statement. 
i»- L 
*M4M 
1. 100, 676, 1296 
3. Hard-coded 
5. Positional 
7. REDEFINES 
9. KEY 
11. INDEXED BY 
13. Compilation 
15. Range step 
•mm 
1. True. 
3. True. 
5. True. 
7. True. 
9. True. 
me 
11. False. Examination of the COBOL syntax shows an 
additional WHEN clause enclosed in brackets. 
13. True. 
15. True. Good practice however, dictates that a separate 
subscript be used for every table. 

Appendix 
F —- Answers 
to 
Odd-Numbered 
Exercises 
17. True. 
19. True. 
21. True. 
23. False. All codes should be unique. 
25. True. 
27. False. A range step table occurs when a one-to-one 
correspondence no longer exists. 
3 
Fllhln 
1. OCCURS 
3. Seven 
5. May not, OCCURS, REDEFINES 
7. 1, 6, 2, 1, 6 
9. 1,2,3 
1. True. 
3. True in COBOL-85, but not in COBOL-74. 
5. True. 
7. False. 
The program would compile cleanly, but 
produce problems during execution. 
9. False. The clauses are all optional 
Fill-in 
1. Key 
3. EBCDIC, ASCII 
5. Primary (major), secondary (intermediate), tertiary 
(minor) 
Yme/faise 
,,,, 
1. False. It can be used on a calculated field if INPUT 
PROCEDURE is specified. 
3. False. INPUT PROCEDURE may also be specified 
with GIVING. 
5. True. 
7. False. They are associated with INPUT PROCEDURE 
and OUTPUT PROCEDURE, respectively. 
9. True. 
11. True. 
7. GIVING, OUTPUT PROCEDURE 
9. SELECT, SD 
11. Trailing, embedded 
13. Identical 
13. 
15. 
17. 
19. 
False. The INPUT PROCEDURE is used if you want to 
selectively pass records to the sort work file; for 
example, to increase efficiency by sorting on fewer 
records. 
True. 
False. 
INPUT PROCEDURE is not used with the 
MERGE statement. 
False. The MERGE statement requires that all input 
files have identical record layouts and appear in the 
same sequence. 
Chapter 13 
1. Change, control break 
3. Is 
5. Before 
7. Pseudocode 
9. Less 
11. Rolling 

ppendix 
F 
Answers 
to 
Odd-Numbered 
f 
xeiases 
1. False. Control breaks can theoretically extend to any 
5. True. 
number of levels, although they lose meaning after 
7. True. 
three or four 
9. True. 
3. True. 
1. EXIT PROGRAM 
3. Is 
5. Both 
7. COPY 
9. BY REFERENCE 
11. CALL 
1. False. The COPY statement is permitted anywhere 
except within another COPY. 
3. False. They can be the same, but there is no COBOL 
requirement stating they must be the same. 
5. False. The COPY statement is permitted anywhere 
except within another COPY. 
11. 
False. A program may call several subprograms. 
False. All parameters must be elementary items except 
for those passed at the 01 level. 
False. Both are optional; omission of both phrases 
defaults to calling BY REFERENCE which is equivalent 
to a CALL statement in COBOL-74. 
1. Every 
3. Does 
5. Additions, changes (corrections), deletions 
7. Can 
9. Can not 
11. Stubs, DISPLAY 
13. HIGH-VALUES 
1. True. 
11. 
3. True. 
5. True. 
7. False. 
Duplicate additions can only be checked 
against the master file; i.e., during the actual update. 
9. False. 
Pseudocode is procedural in nature and 
13. 
indicates sequence and decision making. Hierarchy 
charts are functional and indicate what has to be 
done, not necessarily when or if. 
False. The programmer is biased (either consciously 
or unconsciously), as he or she wrote the program 
and knows what it does or doesn't do. Ideally test 
data should be designed by the user, but this is often 
difficult to achieve. 
False. The balance line algorithm may be used with 
multiple transaction files (as was done in the chapter). 

A
p
p
e
n
d
i
x 
F 
Answers 
to 
Odd-Numbered 
Exercises 
1. Indexed 
3. VSAM, indexed 
5. Highest 
7. Unique, duplicate, alternate (secondary) 
9. Optional, two, WORKING-STORAGE 
11. START 
13. DYNAMIC 
False. Specification of ALTERNATE RECORD KEY 
will require substantial amounts of overhead in 
retrieving records from an indexed file; it should not 
be used indiscriminately. 
False. The COBOL notation places both clauses in 
brackets to indicate optional entries. Logically however 
one of the two conditions must pertain, and 
consequently either clause should be specified. (The 
authors find these clauses easier to follow than testing 
the equivalent FILE STATUS entries.) 
5. False. Specification of zero alternate areas will slow 
processing. 
7. False. The ALTERNATE RECORD KEY need not be 
unique, as per the WITH DUPLICATES clause. 
9. True. 
11. False. They have different functions; to enter a new 
record and to change an existing record. 
13. True. 
1. storage, memory 
3. not been 
5. integer, date, YYYYMMDD 
7. is 
1. True 
3. False, they were added in 1989 
5. 
False, INTEGER-TO-DATE returns YYYYMMDD and 
INTEGER-TO-DAY returns YYYYDDD 
7. True 
1. is 
3. class, instance 
5. Inheritance 
7. Base 
9.polymorphism 
fros/itassi 
1. False, many of the basic concepts remain. 
3. False, the Procedure Division is necessary to specify the 
use of the Linkage Section. 
5. True 
True 
True 

P R O G R A M M I N G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
Program Name: 
Price Break Report 
N a r r a t i v e : 
Write a program to determine whether a customer receives a price break based on 
quantity ordered. 
Input File: 
OHUER-TRANSACTION-FILE 
Input Record Layout 
Order Record 
Customer Number 
Quantity Ordered 
Item Number 
1 
... 
8 
9 
10 
... 
12 
13 
... 
17 
T e s t D a t a : 
R e p o r t L a y o u t : 
5 1 3 4 7 9 3 5 0 0 0 5 1 1 1 1 1 
4 2 3 0 9 8 4 7 0 1 0 0 2 1 2 2 2 
3 8 9 0 1 9 7 4 0 1 2 5 3 2 3 3 3 
2 1 5 6 4 8 2 3 0 5 0 0 4 3 4 4 4 
1 0 0 2 4 5 6 7 0 9 0 0 5 4 5 5 5 
X X X X X X X X 
XXXXX 999 
99 
Customer 
Item 
Qty 
Discount 
Number 
Number Ordered 
Percent 
Processing Requirements: 1. Read a file of order records. 
For every record read, determine the discount the customer will receive. The discounting 
of an item is based on the Item Series and Quantity Ordered. Item Series is indicated 
by the first byte of the Item Number. For example, Item Number 12345 is Item Series 1 
because it starts with a 1. The eligibility of discounting is determined as follows. 

A
p
p
e
n
d
i
x 
G 
Projects 
Quantity 
Discount 
Ordered 
Percent 
Item Series 1 & 2 
1-100 
0% 
101-500 
10% 
501-999 
20% 
Item Series 3, 4, & 5 
1-50 
0% 
51-100 
15% 
101-500 
20% 
501-999 
25% 
3. Print the Customer Number, Item Number, Quantity Ordered, and Discount Percent 
allowed for each customer record. Single-space the output. 
Program Name: 
Inter-City Piano Program 
Narrative: 
Write a program for the Inter-City Piano Company. The program is to process a file of 
customer records and produce a list of people eligible for a discount in buying a piano. 
Input File: 
CUSTOMER-LESSON-FILE 
Input Record Layout: 
Customer Lesson Record 
Last Name 
First Name 
# of Lesson 
Purchase Indicator 
1 
... 
15 
16 
... 
25 
26 
... 
28 
29 
30 
Test Data: 
C R A W F O R D ; 
S H E R i R Y 
0 1 1 
JN 
;K A R V A Z Y 
K A R E N 
0 1 7 
^Y 
M O R S E 
KENNETH 
0 1 4 ;N 
P L U M E T R E E * 
M I C H T L E 
0 2 7 JN 
S L Y 
MATTHEW 
0 1 9 
N 
P O W E R S 
N A N C Y 
0 2 4 ;Y 
B L A K E L Y 
K R I S T EN 
0 0 8 
Report Layout: 
xxxxxxxxfxx xxxxx;XXxxxxxxXX 
;;;; 
szjzzr 
first 
name 
last 
name 
999 
nil 
lesson 
Processing Requirements: 
1. Read a file of customer records. 
2. For every record read, determine whether that person is eligible for a discount to buy a 
piano. Individuals who have taken 15 or more lessons and have not yet purchased a 
piano qualify. Do not consider as eligible anyone with a "Y" in position 30 of the input 
record which indicates that a piano has already been purchased. 
3. Print the names of all qualified individuals according to item 2 above. Single-space the 
output. (Do not print the names of individuals who are not eligible.) 

Project 
2-4 
Program Name: 
Delinquent Accounts 
Narrative: 
Write a program to process a corporation's account file to select a list of problem 
accounts. The generated list will then be brought to the attention of the comptroller. 
I n p u t File: 
Input R e c o r d Layout: 
CUSTOMER-ACCOUNT-FILE 
Customer Account Record 
Name 
Account No. 
Account Owed 
Days Overdue 
1 
... 
15 
16 
17 
... 
22 
23 
24 
... 
28 
29 
30 
... 
32 
ACME 
E N T E R P R I S E 
B A K E R 
B R O T H E R S 
BENJAMIN £ 0 
F R A N K E L CORP 
iCLARK PROGRESS 
M A R S H A K 
B O O K S 
i K A R L S T R O M i I N C 
M I LGROM 
T H E A T R E 
S P R I N G S 
W W T E R 
11 i 1 1 1 0 1 0 0 0 
0 1 0 
222:222 
2 0 0 0 0 
0 3 0 
3 3 3 3 3 3 
0 0 5 0 0 
fj 1 5 
4 4 4 4 4 4 
2 7 5 0 0 
1045 
55 5:5 55 
3 2 0 0 0 
10 0 5 
6&6!6 6& 
0 3 5 0 0 
:0 60 
7 7 7 7 7 7 
0 0 1 0 0 
0 4 b 
888;888 
1 5 0 0 0 to 1 4 
9 9 9=999 
2 0 0 0 0 
0 0 7 
Report Layout: 
Design your own report layout. 
Processing Requirements: 
1. Read a file of customer account records. 
2. Determine if the record is a problem account. An account is considered a problem if 
the amount owed is over 20,000 or the account is more than 30 days overdue. 
3. Print the name and associated information (account number, amount owed, and days 
overdue) of all problem accounts. Space this information reasonably over a print line. 
Double-space the report. 
Program Name: 
Shoe Inventory Program 
Narrative: 
Write a program to process a file of shoe inventory records and produce a list of shoes 
that need reordering. 
Input File: SHOE-INVENTORY-FILE 

Appendix 
G — 
Projects 
Shoe inventory Kecord 
Vendor Name 
Style No. 
Quantity on Hand 
Reorder Quantity 
1 
... 
12 
13 
... 
18 
19 
... 
22 
23 
... 
26 
T e s t D a t a : 
I B A S S 
12 12 1 2 0 ( 4 5 0 0 3 0 0 
' B R U N O 
MAGjLI 
2 3 2 3 2 3 0 ( 5 0 0 0 5 0 0 
K E D S 
3 4 3 4 3 4 0(7 0 0 0 7 5 0 
( J O A N 
& D A ( V I D 4 5 4 5 4 5 0 | 0 5 0 0 0 2 5 
LA 
G E A R 
! 
5 6 5 6 5 6 0 ( 5 0 0 0 5 5 0 
F L 0 R S H E I M 
6 7 6 7 6 7 0 ( 1 0 0 0 0 7 5 
( N I K E 
! 
7 8 7 8 7 8 0 J 3 0 0 0 2 0 0 
I R E E B 0 K 
8 9 8 9 8 9 0 7 0 0 0 8 0 0 
Report Layout: 
xxxxxxxxxxxx 
xxxxxx 
I 
I 
vendor 
name 
style 
# 
l l l s i l l l l - l l l S i 
9 9 9 9 
9 9 9 9 
I 
I 
QOH 
Reorder 
P r o c e s s i n g R e q u i r e m e n t s ; 
1. Read a file of shoe inventory records. 
2. For each record read, determine whether a particular shoe style should be reordered. 
Shoes should be reordered when the quantity on hand falls below the reorder quantity. 
3. Print the vendor name, style number, quantity on hand, and reorder quantity for only 
the shoes that should be reordered. 
•A it 
P r o g r a m N a m e : 
Mailing List Program 
N a r r a t i v e : 
Write a program to process a file of mailing list records and produce a mailing list. 
Input F i l e : 
MAILING-LIST-FILE 
Input Record L a y o u t : 
Mailing List Record 
Name 
Street Address 
City and State 
Zip 
1 
20 
21 
45 
46 
63 
64 
68 

Project 
2-6 
Test Data: 
R O B E R T 
T . 
G R A D E R 
J A N E 
DOE 
iJOHN 
S M I T H 
;D E B R A L . 
t i l l 
:MEGAN 
J . 
;ALV0RD 
G E O R G E 
B E R E N S 
GARY 
F E I N 
60 
P A C I F I i C 
COAST HWY 
123 
S O U T H 
S T R E E T 
2 1 J U M P 
S T R E E T 
59 
BROADWAY 
9 
SOUTH 
SiHORE 
D R I V E 
73 
W E S T 
F L A G L E R 
45 
M A I N 
S T R E E T W 
CAROL 
VAZ:QUEZ 
V I L A R 
9 
ROAD 
TO HANA 
SANTA 
B A R B A R A , 
CA 
9 3 1 0 1 
C H A R L O T T E , 
N C : 
2 8 2 0 3 
A U S T I N , 
TX 
7 8 7 0 1 
NEW 
Y O R K , 
NY 
1 0 0 0 6 
B E V E R L Y 
H I L L S ,; CA 
90.210 
M I A M I , 
F L 
33:130 
C H I C A G O , 
I L 
6 0 6 4 8 
M A U I : , 
H I 
96 7 1 3 
Report Layout: 
X X X X X X X X X X X X X X X X X X X X 
- name 
X X X X X X X X X X X X X X X X X X X X X X X X X 
-street 
address 
X X X X X X X X X X X X X X X X X X 
X X X X X 
city 
& state 
zip 
Processing Requirements: 
1. Read a file of mailing list records. 
2. For each record read, create a mailing label. Double-space between each record. 
Program Name: 
Church Building Fund Report 
Narrative: 
Write a program to print a Church Building Fund Report containing all church members 
who are behind on their contributions. 
Input File: 
CHURCH-BLD-FUND-MSTR-FILE 
Input Record Layout: 
Church Building Fund Master Record 
Member Name 
Pledged Amount 
Member Number 
Amount Given 
1 
... 
15 
16 ... 20 21 
... 
25 26 ... 30 
31 
... 
34 
35 
... 
39 
Test Data: 
J O H N 
S M I T H 
ANN 
L O V I N G 
MARY 
BROWN 
TOM 
S A W Y E R 
J A C K 
C A P P S 
J I L L 
J A C O B S 
S U S A N 
C L U B 
M I K E 
C L O U D 
0 0 1 0 0 0 0 0 T 0 0 0 0 1 0 0 0 5 0 
0 0 2 0 0 0 0 S 0 0 0 0 0 2 0 0 0 2 5 
0 O 5 0 O 0 0 C 0 A O 0 0 3 O 0 5 0 O 
0 0 0 7 5 0 0 F G 0 0 0 0 4 0 0 0 0 0 
0 3 4 0 0 3 4 0 0 0 0 0 0 5 0 3 4 0 0 
4 0 0 0 0 1 2 3 4 5 0 0 0 6 0 3 5 0 0 
0 2 0 0 0 X A B C J D 0 0 0 7 0 2 0 0 0 
0 0 3 0 0 0 F C 0 O 0 0 0 8 0 0 1 5 0 : 

A
p
p
e
n
d
i
x 
G — 
Projects 
Report Layout: 
XXXXXXXX'XXXXXXX 
99999 
I 
I 
MEMBER 
AMOUNT 
NAME 
PLEDGED 
99999 
AMOUNT 
TO 
DATE 
99999 
I 
G I V E N 
AMOUNT 
OWED 
Processing R e q u i r e m e n t s : 
1. Read a fiie of church member building fund master records. 
2. For every record read: 
a. Calculate the AMOUNT OWED = AMOUNT PLEDGED - AMOUNT GIVEN 
b. Print the church member name, the amount pledged, the amount paid to date, and 
the amount owed for each church member who owes money to the church. Single-
space each line. 
Program Name: 
Telephone Long Distance Carrier Program 
Narrative: 
Write a program to process a file of telephone records to produce a report list of 
customers who are not using ET&T as a long distance carrier. 
input Fiie: 
I ELEPFiuNE-HLt 
Input Record Layout: 
Telephone Record 
Name 
Area Code 
Phone No, 
Long Distance Carrier 
1 
... 
18 
19 
... 
21 
22 
... 
28 
29 
... 
35 
iMARYANN 
B A R B E R 
' J O E L 
S T U T Z 
i R O B E R T 
P L A N T 
: G R E G G 
E L O F S O N 
S A R A 
R U S H I N E K 
M A R K 
G I L L E N S O N 
O A V 1 0 
H E R T Z 
J O H N 
S T E W A R T 
3 0 5 5 5 5 7 6 3 4 A T & T 
4 0 7 6 3 4 1 2 3 4 E T & T 
3 1 2 4 3 7 4 9 6 2 S P R I N T 
2 0 3 2 4 6 9 3 6 8 H C I 
2 1 2 6 6 6 2 9 1 6 E T & T 
3 1 6 3 9 6 9 4 7 6 T E L T E C 
6 1 3 2 4 6 3 6 1 8 M C I 
8 1 3 3 2 4 6 8 4 6 T E L T E C 
R e p o r t L a y o u t : 
X X X X X X X X X X X X X X X X X X 
( X X X : ) 
X X X - X X X X: 
X X X X X X X 
area 
code 
phone 
#: 
long 
distance 
carrier 

Project 
3-1 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of telephone records. 
2. For each record read, determine whether the long distance carrier is ET&T or not. 
3. Print the name, complete phone number, and the current long distance carrier of the 
records that are not using ET&T. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
Program Name: 
Insurance Policy Holder Report 
Narrative: 
Develop a hierarchy chart and either flowchart, pseudocode, or Warnier-Orr diagram for 
a program to determine which customers have group life insurance policies. 
I n p u t F i l e : 
CUSTOMER -INSURANCE-FILE 
Input R e c o r d L a y o u t : 
Customer Insurance Record 
Customer Number 
First Insurance Policy Held 
Effective Date 
Expiration Date 
1 
... 
8 
9 
10 
... 
11 
12 
... 
19 
20 
... 
27 
Second Insurance Policy Held 
Effective Date 
Expiration Date 
28 
... 
29 
30 
... 
37 
38 
... 
45 
Third Insurance Policy Held 
Effective Date 
Expiration Date 
46 
. 
47 
48 
... 
55 
56 
... 
63 
First Insurance Policy Rate 
First Insurance Policy Ivletnod of Payment 
64 
68 
69 
Second Insurance Policy Rate 
Second Insurance Policy Method of Payment 
70 
... 
74 
75 
Third Insurance Policy Rate 
Third Insurance Policy Method of Payment 
76 
... 
80 
81 
T e s t Data: 
,> 
, „ 
K 
513479359GLO910199709101998ULO8O1199608011998HE05151997O5151999015O0A0040OQ00O25K 
423098479SA0428199604281998HE 11081 996 1108 1997 
00010 MO0300Q 
389019749UL0613199706131998GL0101 199801012000 
00400 AO0500M 
215648239AS05031996O5031998XL121O199712102000GL01041997O1O419990003OMOO15OQO5OOOA 
100245679HE0404199604041998 
00500H 
Report L a y o u t : 
} C U S T O M E R 
' 
N U M B E R 
i 
x x x x x x x x " ' ' 
USA I N S U R A N C E 
C O M P A N Y 
G R O U P L I F E P O L I C Y 
R E P O R T 
E F F E C T I V E 
E X P I R A T I O N 
" ' D A T E " " " " D A T E 
x""x7 x" "x / x x x" x
X 
"X / X X / X X X x" 
P O L I C Y 
P R E M I U M ' 
9 9 9 9 9 9 9 
T 0 T A L G R O U P P 0 L I C Y? P R EMI U M S
9 9 9 9 9 9 9 9 

A
p
p
e
n
d
i
x 
G 
Projects 
Processing Requirements: 
1. Read a file of customer records. 
2. For every record read: 
a. Determine whether the customer has a group life insurance policy. Each customer 
can have as many as three different insurance policies. Check all three policies to 
determine whether they are group life. A group life insurance policy is indicated 
with the code 'GL'. 
b. Calculate the POLICY PREMIUM for each group life insurance policy by checking 
the METHOD OF PAYMENT field. If the METHOD OF PAYMENT field contains an 
"M," multiply the rate times 12 (months). If the METHOD OF PAYMENT field 
contains a "Q," multiply the rate times 4 (quarterly). If the METHOD OF PAYMENT 
field contains an "A," the rate is the POLICY PREMIUM (annual). 
c. Accumulate the POLICY PREMIUMS, giving the TOTAL GROUP POLICY PREMIUMS. 
d. Print the customer number, effective date, expiration date, rate, and policy premium 
for each customer who has a group life insurance policy. Single-space the output. 
3. After all records have been read, print the total group life policy premiums. 
rujfi I caiil 
n a m e * 
Narrative: 
This project builds on Project 2-1. Develop the hierarchy chart and either flowchart, 
pseudocode, or Warnier-Orr diagram to determine whether a customer receives a price 
break based on quantity ordered, and calculate the unit price and extended price. 
Input file: 
ORDER-TRANSACTION-FILE 
Input Record Layout: 
Order Record 
Customer Name 
Quantity Ordered 
Item Number 
Unit Price 
1 
... 
8 
9 
10 
... 
12 
13 
... 17 
18 
19 
... 
21 
Test Data: 
5 1 3 4 7 9 3 5 0 0 0 5 1 1 1 1 1 9 1 0 5 
4 2 3 0 9 8 4 7 0 1 0 0 2 1 2 2 2 8 0 2 0 
3 8 9 0 1 9 7 4 0 1 2 5 3 2 3 3 3 7 3 0 0 
2 1 5 6 4 8 2 3 0 5 0 0 4 3 4 4 4 6 3 4 0 
1 0 0 2 4 5 6 7 0 9 0 0 5 4 5 5 5 5 0 6 5 

Project 
3-3 
R e p o r t L a y o u t : 
mm 
AUSTIN
 
; 
RETAIL 
COMPANY 
:UST0MER 
ITEM 
QTY 
UNIT 
EXTENDED 
TOTAL 
TOTAL 
NUMBER 
NUMBER" 
ORDERED 
PRICE 
PRICE 
QUANTITY: 
SALES 
<XXXXXXX : " 
XXXXX 
999 
999 
: 
999999 
ORDERED 999999999 
. 
" 
' 
• 
999999 
P r o c e s s i n g R e q u i r e m e n t s : 1. Read a file of order records. 
For every record read: 
a. Determine whether the customer will receive a discount based on the specifications 
in Project 2-1. 
b. Calculate the Unit Price by applying the appropriate discount as determined in 2a. 
c. Calculate the Extended Price by multiplying the Quantity Ordered by the Unit Price. 
d. Accumulate the Total Quantity Ordered by adding the Quantity Ordered. Accumulate 
the Total Sales by adding the Extended Price. 
e. Print the customer number, item number, quantity ordered, unit price (calculated), 
and extended price for each customer record. Single-space the output. 
After all records have been read, print the total quantity ordered and the total sales. 
P r o g r a m N a m e : 
Barcoded Price List 
N a r r a t i v e : 
Develop the hierarchy chart and either flowchart, pseudocode, or Warnier-Orr diagram 
for a program to create and print a barcoded price list. 
I n p u t F i l e : 
ITEM-PRICE-FILE 
I n p u t R e c o r d L a y o u t : 
Item Price Record 
Item Number 
Quantity on Hand 
Unit Price 
1 
... 5 
6 
... 
9 
10 
... 
14 

A
p
p
e
n
d
i
x 
G 
Projects 
Test Data: 
R e p o r t L a y o u t : 
T1080105(M)0100 
12400120001400 
13050001000200 
;144500200O1350 
(230 10010000200 
(3 1054100000050 
;05 1000060002 13 
(02 187090600045 
956780020(00300 
T0234001000024 
C O M P A N Y A B C B A R C O D E D P R I C E LIST 
B AR C
O
D
E
D
B 
A R C 0 D ED" 
I T E
M
U
N 
I T 
I T E M N U M B E R " 
UNIT P
R
I
C
E
'
N
U
M
'
B
E
R
P
R I CE 
< 9 9 9 9 9 9 9 > 
< 9 9 9 9 9 9 9 > 
999 99 
9 9 9 9 9 
T O T A L I T E M S : 
9 9 9 9 9 9 9 
Processing Requirements: 1. Read a file of price records. 
2. For every record read: 
a. Determine the check digits for the barcoded item number and unit price as follows: 
Add each number in the field together and divide by the number of digits being 
added, then multiply the result by 3. 
Place the check digits to the right of the field for 2 positions and place a < to the left 
of the first digit and > to the right of the last digit. 
When the price list prints, a barcode font should be used to cause the appropriate 
fields to be barcoded (this cannot be done in the lab environment, the fields will just 
print normal). 
For example: ITEM NUMBER = 12345 
check digit =1+2 + 3 + 4 + 5=15 
15/5 = 3 
3*3 = 9 
check digit = 09 
BARCODED ITEM NUMBER = <1234509> 
< indicates the beginning of a barcode field and > indicates the end of a barcode 
field. 
Check digits are used to ensure that proper transmission has occurred. The 
program that uses the data after transmission uses the above algorithm to determine 
whether the proper data has been sent. If the answer derived does not match the 
check digits, something was not transmitted properly. 
b. Increment an accumulator for number of items. 
c. Print the barcoded item number, barcoded unit price, item number, and unit price. 
3. After all records have been read, print the total items. 

Project 
3-4 
Program Name: 
Savings Dividends 
N a r r a t i v e : 
Develop the hierarchy chart and either flowchart, pseudocode, or Warnier-Orr diagram 
for a program to process a file of savings account records and compute and print a 
dividend report for each account and a total. The Identification, Environment, and Data 
Divisions for this project can be developed after Chapter 4. Completion of the project 
requires you to finish Chapter 5 in order to do the Procedure Division. 
Input File: 
SAVINGS-FILE 
Input R e c o r d L a y o u t : 
Savings Record 
Account No. 
Name 
Amount 
Term 
1 
... 
8 
9 
24 
25 
... 
31 
32 
33 
T e s t D a t a : 
'1 1 0 0 0 - O l M i I L G R O M 
0 0 4 5 : 5 6 0 1 8 
, ' 2 3 0 0 0 - 0 5 P ! E T E R S 
0 0 3 0 6 7 0 1 6 
3 1 0 0 1 - 0 2 S M I T H 
0 0 2 5 : 8 9 0 1 2 
4 3 0 4 5 - 0 3 J O N E S 
0 0 6 9 : 8 8 0 2 4 
"5 1 0 0 5 - 0 1 vil L L A R 
0 0 0 4 5 5 0 0 6 
: 3 5 0 1 0 - 0 2 H A N S E N 
0 1 0 9 : 3 6 0 3 6 
R e p o r t L a y o u t : 
A C C O U N T 
N U M B E R 
X X X X X X X X 
NAME 
X X X X X X X X X X X X X X X X 
S A V I N G S 
D I V I D E N D 
T O T A L 
AMOUNT 
P A I D 
S A V I N G S 
9 9 9 9 9 9 9 
9 9 9 9 9 9 9 
9 9 9 9 9 9 9 9 
T O T A L S 
9 9 9 9 9 9 9 9 
9 9 9 9 9 9 9 9 
9 9 9 9 9 9 9 9 9: 
Processing Requirements: 
1. Print a heading at the beginning of the report. 
2. Read a file of savings account records. 
3. Process each record read by: 
a. Determining the interest rate as follows: 
(1) 6% interest on terms of 6 months or less. 
(2) 7% interest on terms of more than 6 months but less than 12. 
(3) 8% interest on terms of more than 12 months but less than 18. 

Appendix 
G 
Projects 
(4) 9% interest on terms of more than 18 months but less than 24. 
(5) 10% interest on terms of more than 24 months but less than 30. 
(6) 12% interest on terms of more than 30 months. 
b. Calculating the dividend to be paid by multiplying the amount by the interest rate. 
c. Calculating the total savings by adding the interest to be paid to the account 
amount. 
d. Incrementing savings totals tor savings amount, dividend paid, and total savings. 
e. Printing a detail line for each record read. 
4. Print a total line at the end of the report. 
Project 
3-5 
Program Name: 
Narrative: 
Input File: 
Input Record Layout: 
Evaluation of Student Curriculum Records 
Develop the hierarchy chart and either flowchart, pseudocode, or Warnier-Orr diagram 
for a program to evaluate a student's curriculum record and determine the percentage of 
courses a student has left in order to to graduate, the percentage of courses a student 
has transferred, the percentage of courses for which a student has been awarded 
proficiency credit, and the percentage of courses a student has completed. 
STUDENT-CURRICULUM-FILE 
Student Curriculum Record 
Student Id Number 
Course Number 1 
Grade 1 
1 
... 5 
6 
... 12 
13 
Course Number 2 
Grade 2 
Course Number 3 
Grade 3 
14 ... 20 
21 
22 ... 28 
29 
Course Number 4 
Grade 4 
Course Number 5 
Grade 5 
30 ... 36 
37 
38 ... 44 
45 
Course Number 6 
Course Grade 6 
Number 7 
Grade 7 
46 ... 52 
53 
54 ... 60 
61 
Course Number 8 
Course Grade 8 
Number 9 
Grade 9 
62 ... 68 
69 
70 ... 76 
77 
Course Number 10 
Grade 10 
78 ... 84 
85 
Test Data: 
•I 
1 2 345C0MPI110AENG L 11J0 HAT H 1 48 KjMAT H 1 68 PC IjS 1 50 FCIS230 
P S Y C 1 0S5 BB U S N 1 10 A;H UMN4 1 0 PHUlMN 4 2 0 A 
;34567ENGlJl 1OCENGL12J0 MATH048CJMATH2 1 ODC lis 1 50 PCIS230 ACIS330: 
78921BUSN;110 BUSN120 ENG L 11 OAJENG L 1 20PMA.TH048KMATH 1 68BMATH22:0 
i346 78PSYCJ105APSYC305 ENGL 11 0AJENG L 1 20 E CON 2 10 AHUMN 41 0 KH UMN 42:0 P HUM N 4 3 0 AJAC C T2 1 3 AA CC T 3 4 7 
47830SPCH275AENGI 110 ACC T 20 5 A;AC C T2 10 P ACJCT3 47 K 
I 

Project 
3-6 
Report Layout: 
U N I V E R S I T Y O F N O W H E R E 
S T U D E N T 
C U R R I C U L U M 
E V A L U A T I O N 
i T U D E N T ID 
P E R C E N T A G E O F C O U R S E S 
N U M B E R 
C O M P L E T E D 
R E M A I N I N G 
T R A N S F E R R E D 
P-RO F I C I E N C Y 
XXXXX 
999 
999 
999 
999 
Processing Requirements: 
1. Read a file of student curriculum records. 
2. For every record read: 
a. Add the total number of courses (course name, not spaces) for each student (a 
maximum of 10). 
b. Add the total number of courses where the student was awarded a grade (A, B, C, 
or D), proficiency (P), or transfer credit (K). 
c. Add the total number of courses where the student was awarded transfer credit (K). 
d. Add the total number of courses where the student was awarded proficiency credit (P). 
e. Determine the percentages of courses left in order to graduate, courses completed, 
courses transferred, and courses awarded proficiency credit. 
f. Print student id number and the percentages of courses left in order to graduate, 
courses completed, courses transferred, and courses awarded proficiency credit. 
Program Name: 
Inventory Parts List 
Narrative: 
Develop the hierarchy chart and either flowchart, pseudocode, or Warnier-Orr diagram 
for a program to produce an inventory report. The Identification, Environment, and Data 
Divisions for this project can be developed after Chapter 4. Completion of the project 
requires you to finish Chapter 5 in order to do the Procedure Division. 
Input File: 
Input Record Layout: 
INVENTORY-FILE 
Inventory Record 
Part Name 
Quantity on Hand 
Amount Received 
Amount Shipped 
Unit Price 
1 
... 
20 
21 
... 
23 
24 
... 
26 
27 
... 
29 
30 
... 
33 

A
p
p
e
n
d
i
x 
G 
Projects 
Test Data: 
M I D G E T S , 
S I Z E 
S 
W I D G E T S , 
S I Z E 
M 
: W I D G E T S , 
S I Z E 
L 
J W H O S I W H A T S I S 
G I Z M O S , 
T Y P E 
A 
G I Z M O S , 
T Y P E 
B 
G A D G E T S , 
S I Z E 
S 
G A D G E T S , 
S I Z E 
L 
1 5 0 0 5 0 0 9 6 0 0 7 0 
2 0 0 0 7 5 0 7 6 0 0 8 0 
0 0 0 5 0 0 4 0 0 0 0 9 0 
3 5 0 1 1 0 0 4 6 0 1 0 0 
2 5 0 0 8 0 0 3 6 0 2 0 0 
0 0 0 0 5 0 0 2 5 0 3 0 0 
0 2 5 0 1 8 0 2 6 : 0 0 1 5 
0 9 0 0 2 8 0 3 5 0 0 2 5 
R e p o r t Layout: 
P A R T 
NAME 
X X X X X X X X X X X X X X X 
• • * 
I N V E N T O R Y 
R E P O R T 
* * * 
B E G I N N I N G 
R E C E I V E D 
S H I P P E D 
E N D I N G 
U N I T 
ON 
HAND 
ON HAND 
P R I C E 
T O T A L 
V A L U E 
999 
999 
999 
y y y 
9999 
9 9 9 9 9 9 9 
T O T A L 
V A L U E 
OF A L L 
I N V E N T O R Y 
9 9 9999 99! 
Processing Requirements: 
1. Read a file of inventory records, and for every record read: 
a. Determine the quantity on hand at the end of the period. This is equal to the 
quantity on hand at the start of the period (contained in the input record), plus the 
amount received, minus the amount shipped. 
b. Determine the value of the inventory on hand at the end of the period. This is equal 
to the unit price (contained in the input record) multiplied by the quantity on hand at 
the end of the period [computed in part a.]. 
c. Print a detail line for every part containing the part name, quantity on hand at the 
beginning of the period, the amount shipped, the amount received, the quantity on 
hand at the end of the period, the unit price, and the value of the inventory at the 
end of the period. Double-space detail lines. 
2. When all records have been read, print the total value of all inventory on hand at the 
end of the period. 
Program Name: 
Money Changer 
Narrative: 
The ACME Widget Corporation has decided to pay its employees in cash rather than by 
check. Develop the hierarchy chart and either flowchart, pseudocode, or Warnier-Orr 
diagram for a program to read a file of payroll amounts and determine the required 
number of bills in each denomination. The Identification, Environment, and Data Divisions 
for this project can be developed after Chapter 4. Completion of the project requires you 
to finish Chapter 5 in order to do the Procedure Division. 

Project 
3-7 
Input File; 
PAYROLL-FILE 
Input Record Layout: 
Payroll Record 
Employee Name 
Soc Sec No. 
Gross Pay 
1 
18 
19 
27 
28 
... 
30 
Test Data: 
JOHN 
SMITH 
i J E S S I C A 
GRAUER 
CHANDLER 
LAVOR 
J E F F R Y 
BtJROW 
;M AR I 0 N MI LGROM 
LYNN 
FRANKEL 
KARL 
KARLSTROM 
'K AT H Y MARS IIAK 
RHODA HAftS 
J I M 
F E G E N ! 
MARIO 
V I L L A R 
1:23456789350 
33 3 444 5 554 
75 
9:8765432 1 1 7 S 
7776688882 19 
9:99887 7 7 7 341 
492 336 78949|2 
3332 288883 1:4 
2 4 5 3 4 7 8 7 8 3 6:8 
1111111113 05 
222222222 5212 
3:3 3 3 3 3 3 3 3 3 7i8 
Report Layout: 
E M P L O Y E E N A M E 
$100< 
$50 $20 
X X X X X X X X X X X X X X X X X X 
X X X - X X - X X X X * 
9 
9 
19 
X X X X X X X X X X X X X X X X X X 
X X X - X X - X X X X 
9 
9
9 
T O T A L S 
9 9 
10 
$5 
$1 PAY: 
9 
9 
9 999 
~9 
9 
" 9 9 9 9 
99 
9 9 
99 
9:9 
9 9 9 99 
Processing Requirements: 
1. Read a file of employee pay records. 
2. For each record read: 
a. Determine the number of bills of each denomination required to pay the employee 
in cash, rather than by check. (Do not include cents in your computation.) 
b. Use denominations of $100, $50, $20, $10, $5, and $1. Pay employees in the 
highest denominations possible; e.g., an employee with a gross pay of $300 should 
be paid with three $100 bills rather than six $50 bills. 
c. Maintain a running total of the total payroll as well as the number of bills in each 
denomination for the company as a whole. 
d. Print a detail line for each employee according to the report format. Double-space 
detail lines. 
3. When all records have been read, print a total line for the company according to 
specification 2c. above. 

Appendix 
G — 
Projects 
Program Name: 
Real Estate Sales 
Narrative: 
Develop the hierarchy chart and either flowchart, pseudocode, or Warnier-Orr diagram 
for a program to process a file of real estate records and produce a monthly report based 
on transaction types, commissions paid, and summary. The Identification, Environment, 
and Data Divisions for this project can be developed after Chapter 4. Completion of the 
project requires you to finish Chapter 5 in order to do the Procedure Division. 
The sales commission on any real estate sale is 6 percent of the total sale and is divided 
equally between the listing and selling agencies. This produces three possible sales 
types, which in turn determine the commissions paid to the company and its agents. 
1. The company 
both sells and lists the property (CO-CO). The agent who listed the 
property receives 25 percent of the total (6 percent) commission, and the remaining 
75 percent of the commission is divided equally (50 percent each) between the agent 
who sold the property and the company. 
2. The company sells the property listed by an outside agency (CO-OUT). The agent who 
sells the property listed by an outside agency receives 70 percent of the commission 
due to the company (the commission due to the company is 3 percent of the total 
sales price, or one half of the total 6 percent commission). The company retains the 
remaining 30 percent of the 3 percent commission to the selling agency. 
3. An outside agency sells the property that was listed by the company (OUT-CO). The 
company receives 50 percent of the sales commission (3 percent of the total price), 
which is split equally between the company and the listing agent. 
Input File: 
REAL-ESTATE-FILE 
Input Record Layout: 
Real Estate Record 
Salesperson 
Date 
CO-CO 
CO-OUT 
OUT-CO 
Salesperson 
Month 
Day 
Year 
Amount 
Status 
Amount 
Status 
Amount 
Status 
1 
... 12 13 
14 15 16 17 
18 19 ... 24 
• 25 
26 ... 31 
32 
33 ... 38 
39 
Test Data: 
iVILLAR 
0 30593 2(1 5500C130 3I00C234000C 
( V A Z Q U E Z 
( 
01 30593 3(4 5500C123 0JOOC273400C 
( G A R C I A 
I 
Of 30893 1(3 4500K145 0:00C295600C 
i G R A U E R 
Oi 31093 23 4000C395 0i0 0C124400K 
IALVORD ( Oi 31293 0|0 000002300:00C234000K 
(VAZQUEZ ( 
Oi 31593 1:3 8500K234 0(OOKOOOOOOO 
:G A RC IA 
Oi 31793 24 5000C123 0J00C3984O0K 
( V I L L A R 
i 
Oi 31894 314 5000C00O0j0 0O27840OC 
(GRAUER j 
Oi S2193 23 4500C145 5 00K2 25000C 
( G A R C I A 
Oi 52293 24 5500V1780JOOC298600K 
JGRAUER j 
01 33093 2J6 3500C0000000169600C 
IALVORD i 
Oi 33193 4(2 3000C130 0(00 K2 47000C 

Project 
3-8 
Report Layout: 
111 
ml 
L O T S A 
H O U S E S 
R E A L T Y 
COMPANY 
ifpifllpl^pl 
A T E 
S A L E S P E R S O N 
M/DD 
X ; X X X X X X " X X X X X 
P R O P E R T Y 
S O L D 
CO 
L I S T I N G 
999999 
T O T A L 
S A L E S : 
9999999 
G R O S S 
TO 
L O T S A : 9 9 9 9 9 9 9 
C O M M I S S I O N S 
P A I D : " 
9999999 
NET 
TO 
L O T S A : 
"9999999 
M O N T H L Y 
S U M M A R Y 
T O T A L " S A L E S : 
" 
9999999 
C O M M I S S I O N S 
P A I D : 
9999999 
N E T 
TO 
L O T S A : 
9999999 
P R O P E R T Y
1 
S O L D 
O U T S I D E 
L I S T I N G 
999999 
99 999 9 9 
9999999 
9999999 
99 99 999 
O U T S I D E 
S A L E 
CO 
L I S T I N G 
9 999 9 9 
9 9 9 9 9 9 9 
9 9 9 9 9 9 9 
9 9 9 9 9 9 9 
9 9 9 9 9 9 9 
Processing Requirements: 1. Print the appropriate report headings as shown in the report layout. 
2. Read a file of real estate records and process each record read by: 
a. Incrementing each of the three sales type totals with closed sales only. A closed 
sale is denoted by a "C" in the appropriate STATUS field. 
b. Printing a detail line of the closed sales for each sales type. 
3. For all three sales types: 
a. Process the total sales by: 
(1) Printing the total sales for each of the three types of sale. 
b. Process the gross commission to the company by: 
(1) Calculating the gross commissions to the company for each of the three sales 
types as described in the program narrative. 
(2) Printing the calculated gross commissions for each sales type. 
c. Process the commissions paid by: 
(1) Calculating the commissions paid for each of the three sales types as described 
in the program narrative. 
(2) Printing the calculated commissions paid for each sales type. 
d. Process the net commissions to the company by: 
(1) Calculating the net commissions to the company for each of the three sales 
types as described in the program narrative. 
(2) Printing the calculated net commissions for each sales type. 
4. Process the monthly summary by: 
a. Printing the total sales for the month. 
b. Printing the total commission paid for the month. 
c. Printing the total net commission to the company for the month. 

A
p
p
e
n
d
i
x 
G 
Projects 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Insurance Policy Holder Report, Price Break Report, Barcoded Price List, Savings 
Dividends, Evaluation of Student Curriculum Records, Inventory Parts List, Money Changer, 
and Real Estate Sales 
N a r r a t i v e : 
The specifications for these projects were introduced in Chapter 3, at which time you 
were to attempt the hierarchy charts, pseudocode, flowcharts, and/or Warnier-Orr 
diagrams. Now we ask you to develop the Identification, Environment, and Data Divisions, 
but completion of the projects requires you to finish Chapter 5 in order to do the 
Procedure Division. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Insurance Policy Holder Report, Price Break Report, Barcoded Price List, Savings 
Dividends, Evaluation of Student Curriculum Records, Inventory Parts Lists, Money 
Changer, and Real Estate Sales 
N a r r a t i v e : 
The specifications for these projects were introduced in Chapter 3, at which time you 
were to attempt the hierarchy charts, pseudocode, flowcharts, and/or Warnier-Orr 
diagrams. Completion of Chapter 4 enabled you to code the first three COBOL divisions. 
Now you are expected to develop the Procedure Division and complete the projects. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Insurance Policy Holder Report 
N a r r a t i v e : 
The specifications for this project were introduced in Chapter 3. Change the input record 
to include two decimal places in the policy premium. Use COBOL's editing facility to 
dress up the reports produced by these changes. Redo the report layout, using any 
editing features you deem appropriate. 
I n p u t F i l e : 
CUSTOMER-INSURANCE-FILE 
I n p u t R e c o r d L a y o u t : 
Use the record layout from Chapter 3. 
T e s t D a t a : 
Use the test data from Chapter 3. 

Project 
7-2 
Original Report Layout: 
Use the Report Layout from Project 3-1 and modify it to look good, using the editing 
facility ($, commas, decimal points, etc.). 
U S A 
I N S U R A N C E 
C O M P A N Y 
G R O U P 
L I F E P O L I C Y 
R E P O R T 
C U S T O M E R 
N U M B E R 
X X X X X X X X 
E F F E C T I V E 
D A T E 
X X / X X / X X X X 
E X P I R A T I O N 
D A T E 
X X / X X / X X X X 
P O L I C Y 
P R E M I U M 
9999999 
T O T A L G R O U P 
P O L I C Y 
P R E M I U M S 
99999999 
Program Name: 
Price Break Report 
Narrative: 
The specifications for this project were introduced in Chapter 3, The input record and 
data file have been updated to Include two decimal places in the unit price, which 
requires that the extended price be extended to two decimal places as well. Use 
COBOL's editing facility to dress up the reports produced by these changes. Redo the 
report layout, using any editing features you deem appropriate. 
Input File: 
Input Record Layout: 
ORDER-TRANSACTION-FILE 
Order Record 
Customer Number 
Quantity Ordered 
Item Number 
Unit Price 
1 
... 
8 
9 
10 
... 
12 
13 
... 
17 
18 
19(2 decimals) 23 
Test Data: 
1 0 0 0 0 0 0 1 
J 2 0 0 0 0 0 0 2 0 1 0 0 2 1 2 2 2 8 0 2 0 5 6 
, 3 0 0 0 0 0 0 3 0 1 2 5 3 2 3 3 3 7 3 0 0 4 5 
{4 0 0 0 0 0 0 4 0 5 0 0 4 3 4 4 4 6 3 4 0 2 1 
|5 0 0 0 0 0 0 5 0'9 0 0 5 4 5 5 5 5 5 6 5 7 8 
1 1 0 0 0 0 0 0 1 0 0 1 5 1 3 4 5 6 9 1 3 5 3 4 
! 2 0 0 0 0 0 0 2 0 0 1 0 2 1 2 3 4 8 0 1 0 5 6 
13 0 0 0 0 0 0 3 0 1 0 0 3 4 3 2 1 7 3 3 0 4 5 
4 0 0 0 0 0 0 4 0 4 0 0 4 4 3 2 4 6 3 7 0 2 1 
15 0 0 0 0 0 0 5 0 7 0 0 4 2 4 5 6 5 5 6 5 7 8 
; 1 0 0 0 0 0 0 1 0 0 6 0 4 1 1 1 1 9 1 5 5 3 4 
,2 0 0 0 0 0 0 2 0 0 2 5 5 6 6 2 2 8 0 4 0 5 6 
3 0 0 0 0 0 0 3 0 3 1 5 3 1 1 3 3 7 3 3 0 4 5 
[4 0 0 0 0 0 0 4 04 0 0 2 4 2 1 4 6 3 2 0 2 1 
15 0 0 0 0 0 0 5 0 7 8 0 1 6 4 5 5 5 5 1 5 7 8 
Report Layout: 
Use the Report Layout from Project 3-2 and modify it to look good, using the editing 
facility ($, commas, decimal points, etc.). 

Appendix 
G 
Projects 
Program Name: 
Payroll Program 
Narrative: 
Write a program to process a file of employee records, compute and print individual 
payroll calculations, and compute and print the company totals. The processing 
specifications are straightforward, but you will have to think about the logic for computing 
the gross pay and withholding tax. We suggest, therefore, that you begin with pseudocode 
and a hierarchy chart. 
input File: 
Input Record Layout: 
EMPLOYEE-FILE 
Employee Record 
Soc Sec No. 
Name 
Hourly Rate 
Hours Worked 
Soc Sec No. 
Last 
Initials 
Hourly Rate 
Hours Worked 
1 
... 
9 
10 
... 
22 
23 
24 
25 (2 decimals) 
30 (2 decimals) 33 
Test Data: 
a 11 1 1 1 1 1 liG RAU E R 
:2 2 2 2 2 2 2 2 2 : J 0 N E S 
3 3 3 3 3 3 3 3 3IMILGR0M 
4 4 4 4 4 4 4 4 4 J R I C H A R D S 
;5 5 5 S 5 5 5 5 5 j J E F F R I E S 
:6 6 6 6 6 6 6 6 6jS T E V E N S 
7 7 7 7 7 7 7 7 7T3ROWN 
i 8 8 8 8 8 8 8 8 8 ; B A K E R 
9 9 9 9 9 9 9 9 9 S l i G R I . i t  
0 0 0 0 0 0 0 0 0 J V A Z Q U E Z 
RT0 1025J3 550 
J J 0 1 5 0 0 4 0 7 5 
E A 0 0 5 7 5 4 5 5 Q 
5 0 0 0 
3 0 2 5 
I M 0 1 1 0 0 
J B 0 5 5 5 0 
S S 0 0 7 8 0 J 3 500 
B B 0 8 0 2 5 J 2 550 
E D 0 2 5 4 5 J 3 0 7 5 
P K 0 1 5 3 512 500 
C 
0 4 0 5 0 | 5 0 2 5 
Report Layout: 
Design any suitable report layout that includes one or more heading lines, a detail line for 
each employee, and a total line at the end of the report. Use editing characters as 
appropriate. 
AdditionalRequirements: 
1. Print a suitable heading line at the beginning of the report. 
2. Read a file of employee pay records. 
3. For^yer^record read, 
a. Calculate the gross pay as follows: 
Straight time for the first 40 hours 
Time and a half for the next 8 hours (more than 40 and up to 48 hours) 
Double time for anything over 48 hours 
b. Calculate federal withholding tax as follows: 
18% on first $200 of gross 
20% on amounts between $200 and less than $240 
22% on amounts between $240 and less than $280 
24% on amounts over $280 
c. Calculate net pay as gross pay minus federal tax. 

Project 
7-4 
. 
i u r n u 
u v _ * i u n H I H J i^t 
u a o i 
i o n i f j i u y o \ . , 
w i n i o u i t a u i c 
o u m i 
i y n i a n 
n c i u o . 
u u u u i c
_ C i | j a o c 
detail lines. 
e. Increment company totals for gross pay, federal withholding, and net pay. 
4. When all records have been read, print the company totals for all items in part 3e. 
Program Name: 
Extended Savings Dividends 
Narrative: 
The specifications for this project were introduced in Chapter 3. The input record and 
data file have been updated to include two decimal places in the amount field, mandating 
a similar change in the fields for the dividend and total savings. Use COBOL's editing 
facility to appropriately dress up the reports produced by these changes. Redo the report 
layout, using any editing features you deem appropriate. 
Input File: 
SAVINGS-FILE 
Input Record L a y o u t : 
Savings Record 
Account No. 
Name 
Amount 
Term 
1 
... 
8 
9 
25 
26 (2 decimals) 
34 
35 
36 
Test D a t a : 
:1 1 0 0 0 - 0 I M S LG ROM 
J 2 3 O 0 0 - 0 5 P E T E R S 
3 100 1 - 0 2 S M I T H 
4 3 0 4 5 - 0 3 J O N E S 
|5 1 0 0 5 - 0 1 V I L L A R 
3 5 0 1 0 - 0 2 H A N S I H 
0 0 4 5 0 0 0 0 5 1 8 
0 0 3 0 0 0 0 0 0 1 6 
0 0 2 5 8 0 0 5 7 1 2 
0 0 6 9 8 0 0 9 0 2 4 
0 0 0 4 5 0 0 3 9 0 6 
0 1 0 9 0 0 0 2 9 3 6 
Report L a y o u t : 
A d d i t i o n a l R e q u i r e m e n t s : 
Use the Report Layout from Project 3-4 and modify it to look good, using the editing 
facility ($, commas, decimal points, etc.). Don't forget to show the calculated average 
from additional processing requirement two. 
1. As an aid in maintainability, define the six interest rates in Working-Storage and use 
these data names in your calculations instead of the raw percentage rates. For 
example, for a six month or less account term, change the computation 
Ch 
C O M P U T E 
I N D - D I V I D E N D - P A I D 
= 
S A V - A M 0 U N T 
C O M P U T E 
I N D - D I V I D E N D - P A I D 
R A T E 
S A V - A M 0 U N T 
. 0 6 
U P T 0 - 6 M 0 -
where UPTO-6MO-RATE is defined in Working-Storage with a value of .06. 

Appendix 
G — Projects 
2. Calculate and print the average savings amount for all savings accounts processed. 
3. The savings amount has been extended to two decimal places; extend all other 
calculated amounts to two decimal places as well. 
Update the program and verify your results, then make the following changes. (Hint: You 
should need to change each rate in only one place in the program.) 
(It 
7% interest on 6 months or less 
(2) 8% interest on more than 6 months but up to 12. 
(3) 9% interest on more than 12 months but up to 18. 
(4) 10% interest on more than 18 months but up to 24. 
(5) 11 % interest on more than 24 months but up to 30. 
(6) 14% interest on more than 30 months. 
Program Name: 
Church Building Fund Report 
Narrative: 
The specifications for this project were introduced in Project 2-6. The input record and 
data file have been updated to include two decimal places in the unit price field, 
mandating a similar extension in the total value. Use COBOL's editing facility to dress up 
the report. Redo the report layout, using any editing features you deem appropriate. Add 
total amount pledged, given, and owed. Print all church members, not just those owing 
money. 
Input File: 
input Record Layout: 
CHURCH-BLD-FUND-MSTR-FILE 
Church Building Fund Master Record 
Master Name 
Pledged Amount 
Member Number 
Amount Given 
1 
... 15 
16 ... 20 
21 
... 27 
28 ... 30 
31 
... 34 
35 
... 41 
Test Data: 
J O H N 
S M I T H 
ANN 
L O V I N G 
MARY 
BROWN 
TOM 
S A W Y E R 
J A C K 
C A P P S 
J I L L 
J A C O B S 
S U S A N 
C L U B 
M I K E 
C L O U D 
00100550T000010005000 
0 0 2 O 0 5 0 S 0 . O 0 0 0 2 0 O 0 2 5 S 0 
0 0 5 0 0 0 0 C 0 A 0 O O 3 O 0 5 O O O 0 
O 0 0 7 5 0 0 F G O 0 0 O 4 0 O O 0 0 O O 
034003400000050340034 
400001234500060350000 
0 2 0 0 0 2 5 B C D 0 0 0 7 0 2 0 0 0 2 5 
0030030C0000080015000 

oject 
7-7 
Program Name: 
Inventory Parts List 
Narrative: 
The specifications for this project were introduced in Chapter 3. The input record and 
data file have been updated to include two decimal places in the unit price field, 
mandating a similar extension in the total value. Use COBOL's editing facility to dress up 
the reports produced by these changes. Redo the report layout, using any editing 
features you deem appropriate. 
Input File: 
INVENTORY-FILE 
Input Record Layout: 
Inventory Record 
Part Name 
Quantity on Hand Amount Received Amount Shipped 
Unit Price 
1 
... 
20 
21 
... 
23 
24 
26 
27 
... 
29 
30 (2 decimals) 35 
W I D G E T S , 
S I Z E 
S 
W I D G E T S , 
S I Z E 
M 
W I D G E T S , 
S I Z E 
L 
j W H O S I W H A T S I S 
J G I Z M O S , 
I VIM 
A 
G I Z M O S , 
T Y P E 
B 
i G A D G E T S , 
S I Z E 
S 
I G A D G E T S , 
S I Z E 
L 
1 5 0 0 5 0 0 9 6 0 0 7 0 5 0 
200075076008075 
0 0 0 5 0 0 4 0 0 : 0 0 9 0 3 4 
3 5 0 1 1 0 0 4 6 0 1 0000 
2 5 0 0 8 0 0 3 6 0 2 0 0 5 5 
0 0 0 0 5 0 0 2 5 0 3 0 0 8 7 
0 2 5 0 1 8 0 2 6 ; 0 0 1 5 9 9 
0 9 0 0 2 8 0 3 5 : 0 0 2 5 6 5 
Program Name: 
Money Changer 
Narrative: 
The specifications for this project were introduced in Chapter 3. The input record and 
data file have been updated to include 2 decimal places in the gross pay field; accordingly 
extend the pay to 2 decimal places. Use COBOL's editing facility to appropriately dress 
up the reports produced by these changes. Accordingly redo the report layout, using any 
editing features you deem appropriate. 
Input File: 
Input R e c o r d L a y o u t : 
PAYROLL-FILE 
Payroll Record 
Employee Name 
Soc Sec No. 
Gross Pay 
1 
... 
18 
19 
... 
27 
28 (2 decimals) 32 

Appendix 
G — Projects 
Test Data: 
123 
AU E R 
3 3 3 
A V O R 
987 
OW 
777 
G ROM 
99 9 
E L 
4 9 2 
TROM 
3 3 3 
HAK 
2 4 5 
1 1 1 
2 2 2 
AR 
3 3 3 
4 5 6 7 8 9 3 5 0 5 0 
4 4 4 5 5 5 4 7 5 7 7 
6 5 4 3 2 1 1 7 8 5 5 
6 6 8 8 8 8 2 1 9 8 3 
8 8 7 7 7 7 3 4 1 2 2 
3 3 6 7 8 9 4 9 2 3 7 
2 2 8 8 8 8 3 1 4 4 4 
3 4 7 8 7 8 3 6 8 2 8 
1 1 1 1 1 1 3 0 5 9 8 
2 2 2 2 2 2 5 2 2 4 4 
3 3 3 3 3 3 3 7 8 6 9 
P r o c e s s i n g R e q u i r e m e n t s : 
Extend the calculations to determine the proper number of coins with which to pay the 
individual. Use quarters, dimes, nickels, and pennies in your computations. 
Program Name: 
Extended Real Estate Sales 
N a r r a t i v e : 
Input File: 
Input R e c o r d L a y o u t : 
R e p o r t L a y o u t : 
P r o c e s s i n g R e q u i r e m e n t s : 
The specifications for this project were introduced in Chapter 3. Use COBOL's editing 
facility to dress up the reports produced by these changes. Redo the report layout, using 
any editing features you deem appropriate. 
REAL-ESTATE-FILE 
Same as project 3-8 
Use the Report Layout from Project 3-8 and modify it to look good, using the editing 
facility ($, commas, decimal points, etc.). 
1. As an aid in maintainability, define the gross and commission rate for all three sales 
types in Working-Storage and use these data names in your calculations. For example, 
change the gross to company 
Change: 
C O M P U T E 
T O T - G R O S S - C O - C O = 
T O T - S A L E S - C O - C O * 
. 0 6 
To: 
C O M P U T E 
T O T - G R O S S - C O - CO 
= 
T O T - S A L E S - C O - C O 
* 
G R O S S - C O - C O - R A T E 
where GROSS-CO-CO-RATE is defined in Working-Storage with a value of .06. 
2. Print the gross percent to the company for each of the three sales types as shown on 
the report layout. 
3. Print the commission percent paid out for each of the three sales types as shown on 
the report layout. 
Update the program and verify your results, then make the following changes. (Hint: You 
should need to change each rate in only one place in the program.) 
J O H N 
S M I T H 
J E S S I C A 
GR 
C H A N D L E R 
L 
J E F F R Y 
B OR 
M A R I O N 
M I L 
L Y N N 
F R A N K 
KARL 
K A R L S 
K A T H Y 
M A R S 
:RH0DA 
HAAS 
J I M 
F E G E N ; 
M A R I O 
V I L L 

The sales commission on any real estate sale is 8 percent of the total sale and is divided 
equally between the listing and selling agencies. This produces three possible sales 
types, which in return determine the commissions paid to the company and its agents. 
1 . The company 
both sells and lists the property 
(CO-CO). 
The agent who listed the 
property receives 35 percent of the total (8 percent) commission, and the remaining 
65 percent of the commission is divided equally (50 percent each) between the agent 
who sold the property and the company. 
2. The company 
sells the property 
listed by an outside agency 
(CO-OUT). The agent who 
sells the property listed by an outside agency receives 60 percent of the commission 
due to the company (the commission due to the company is 4 percent of the total 
sales price, or one half of the total 8 percent commission). The company retains the 
remaining 40 percent of the 4 percent commission to the selling agency. 
3. An outside 
agency 
sells the property 
that was listed by the company 
(OUT-CO). The 
company receives 50 percent of the sales commission (4 percent of the total price), 
which is split equally between the company and the listing agent. 
Program Name: 
Car Sales Program 
Narrative: 
Develop the hierarchy chart and either flowchart or pseudocode ior a program to process 
a file of car sales records to produce a commission report. 
Input File: 
CAR-SALES-FILE 
Input Record Layout: 
Car Sales Record 
Invoice No. 
Type information 
Sales Information 
Invoice No. 
Year 
Make 
Model 
Asking Price 
Sold Price 
Salesperson 
1 
... 
5 6 
7 8 
... 18 19 ... 31 
32 
... 
37 
38 ... 43 
44 
... 
50 
T e s t D a t a : 
.78 1 7 5 9 2 N I S S A N 
1 4 8 5 1 9 0 A C U R A 
5 7 4 7 6 9 3 C H T V R 0 L E T 
5 8 6 8 1 9 2 B M W 
8 5 6 4 4 9 3 L 0 T U S 
8 7 4 6 5 8 8 F E R R A R I 
2 5 4 8 9 9 1 N I S S A N 
2 5 5 4 4 9 3 R A N G E R 0 V E R 
7 2 4 6 2 9 3 M E R C E D E S 
5 6 8 4 3 9 3 C A D I L L A C 
P A T H F I N D E R 
L E G E N D 
C O U P E 
C O R V E T T E Z R 1 
53 5 1 
E S P R I T 
T E S T A R 0 S S A 
3 0 0 Z X 
4 
DOOR 
5 6 0 S E C 
F L E E T W O O D 
1 5 7 4 6 8 8 R 0 L L S 
R 0 Y C E C 0 R N I C H E 
1 4 8 4 2 8 4 F E R R A R I 
2 5 5 8 5 9 3 J A G U A R 
4 7 9 1 4 9 I A L F A 
ROMEO 
2 8 5 3 2 9 3 L E X U S 
1 6 5 4 1 9 0 P O R S C H E 
3 0 8 G T B 
X J S 
C0NV 
S P Y D E R 
L S 4 00 
9 1 1 
C A B R I O L E T 
0 1 2 9 9 6 0 1 1 9 9 9 W I L L C 0 X 
0 1 5 9 9 0 0 1 4 5 6 7 S C H U L Z 
0 4 4 9 8 8 0 4 0 1 0 0 M O R I N 
0 2 7 9 9 0 0 2 6 2 0 0 T O R R E S 
0 7 3 5 0 0 0 7 3 2 5 0 W E N D E L 
1 0 5 0 0 0 0 9 7 5 0 0 F I X L E R 
0 0 9 6 8 2 0 0 8 7 1 4 J 0 N E S 
0 2 9 7 7 5 0 2 7 8 6 0 M 0 R I N 
0 6 8 9 0 0 0 6 6 9 0 0 C U L V E R 
0 1 9 9 8 8 0 1 8 9 9 9 T 0 R R E S 
0 7 9 5 0 0 0 7 0 5 9 9 W I L L C 0 X 
0 4 8 5 0 0 0 4 6 2 9 9 F I X L E R 
0 4 0 0 0 0 0 3 5 6 5 0 C U L V E R 
0 1 2 0 0 0 0 1 1 2 9 8 W E N D E L 
0 3 8 9 8 8 0 3 7 9 8 8 S C H U L Z 
0 3 7 9 8 8 0 3 5 9 8 8 J 0 N E S 

Appendix 
G 
Projects 
R e p o r t L a y o u t : 
VERY VERY NICE CARS INC. 
COMMISSION REPORT 
INVOICE 
11119 
CAR 
SALESPERSON 
YEAR 
CAR 
MAKER 
CAR 
MODEL 
ASKING 
PRICE 
PRICE 
SCLD 
>, OF 
ASKING 
99 
XXXXXXXXXXX 
XXXXXXXXXXXXX 111,119 
111,119 
COMM 
PAID 
11,119 
NET TO 
DEALER 
111,119 
$2,111 
, 
Mil,m 
$1,111,119 
Processing Requirements: 
1. Print a heading at the beginning of the report. 
2. Read a file of Car Sales records. 
3. For each record read: 
a. Calculate the percent of the asking price at which the car was sold. For example, a 
$10,000 car which sold for $9,500, soid for 95% of the asking price. Note: Aiiow for 
decimal places in your calculations, but do not print them in your report as shown in 
the report layout. 
b. Calculate the commission paid to the salesperson as follows: 
(1) For any car sold above 95 percent of the asking price the salesperson 
receives a 5% commission rate. In addition, the salesperson is paid a bonus 
equal to 40% of the amount in excess of 95% For example, a $10,000 car 
selling at $9,800 yields a commission of $610.00 ($490.00 + $120.00). 
(2) 
For any car sold between 90 and 95 percent of the asking price the salesperson's 
5% commission is reduced by 10% for every percentage point below 95%. For 
example, a $10,000 car selling at $9,400 results in 94% of the asking price and 
a 4.5% commission rate; therefore the commission paid is $423.00. 
(3) For any car sold below 90 percent of the asking price the amount below 90% 
comes straight out of the salesperson's remaining commission at the 90% level 
as calculated in paragraph (2)—that is, 2.5% of the asking price is all that's left 
to play with. For example, a $10,000 car selling at $8,900 yields a commission 
of only $122.50 ($222.50 - $100.00). 
c. Calculate the Net to the Dealer, assuming the dealer's markup is 25%—that is, the 
asking price is the dealer's cost plus 25%. For example, a $10,000 car selling at 
$9,400 yields a net of $977.00 since the cost to the dealer was $8000.00. 
d. Print a detail line for each record. Double-space all detail lines. 
e. Increment appropriate totals as shown on the report layout. 
4. As an aid in maintainability, define the 5% commission rate, the 40% bonus rate, 95% 
upper level, 90% lower level, the 10% reduction per percentage point below the lower 
level, and the 25% markup as constants in Working-Storage. Use the corresponding 
data names in your calculations instead of the actual values. For example: 
To: 
COMPUTE IND-BONUS ROUNDED = BONUS-RATE * CAR-ASKING= 
PRICE * (IND-PERCENT-ASKING - U P P E R - L E V E L ) 
COMPUTE IND-COMM-PAID ROUNDED = CAR-PR I CE-SOLD 
* COMM-RATE + IND-BONUS 

Project 
8 1 
5. The Final Challenge! Once you have verified that your program works with the 
original rates, determine what effect a 6% commission rate, a 50% bonus, a 15% 
reduction for every percentage point below the upper level, and a 30% markup would 
have on the net to the dealer as well as commissions paid by making the appropriate 
changes in Working-Storage and rerunning the program. Make sure you hand in both 
reports (.RPT). If this was your dealership, which rates would you choose? 
6, Print the totals when all records have been processed. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Order Transaction File Validation 
N a r r a t i v e : 
Write a data validation program that will validate an order transaction file. 
I n p u t F i l e : 
ORDER-TRANSACTION-FILE 
I n p u t R e c o r d L a y o u t : 
01 
01 
01 
ORDER-ENTRY-TYPE-1-RFC. 
REC-TYPE-1 
CUST0MER-N0-1. 
10 
10 
PURCH-ORDER-N.0-1 
PURCHASE-DATE. 
10 
10 
10 
PARTIAL-SHIP-IND 
TAXABLE-IND 
HOLD-DELIVERY-DATE. 
10 
10 
10 
ORDER-ENTRY-TYPE-2-REC. 
05 
05 
05 
05 
05 
05 
05 
REC-TYPE-2 
CUST0MER-N0-2. 
10 
10 
PURCH-0RDER-N0-2 
CUSTOMER-NAME 
CUSTOMER-ADDRESS 
CUSTOMER-ZIP 
CREDIT-LIMIT 
BALANCE-DUE 
PHONE-NUMBER 
ORDER-ENTRY-TYPE-3-REC. 
05 
REC-TYPE-3 
05 
CUST0MER-N0-3. 
10 
10 
05 
05 
05 
05 
05 
05 
05 
05 
05 
REGI0N-1 
REST-CUST-N0-1 
PURCHASE-MM 
PURCHASE-DD 
PURCHASE-YYYY 
H0LD-DEL-MM 
H0LD-DEL-DD 
HOLD-DEL-YYYY 
REGION-2 
REST-CUST-NO-2 
REGI0N-3 
REST-CUST-NO-3 
PIC X. 
PIC X. 
PIC X(5). 
PIC 99. 
PIC 99. 
PIC 9999. 
PIC X. 
PIC X. 
PIC 99. 
PIC 99. 
PIC 9999. 
PIC X. 
PIC X. 
PIC X(5). 
PIC X(5). 
PIC X(15). 
PIC X(15). 
PIC 9(5). 
PIC 9. 
PIC 9(5)V99. 
PIC X(12). 
PIC X. 
PIC X. 
PIC X(5). 

Appendix 
G 
Projects 
05 
05 
05 
05 
05 
05 
PURCH-0RDER-N0-3 
ORDER-ITEM-NOI. 
10 
10 
10 
0RDER-ITEM-N02. 
10 
10 
10 
0RDER-ITEM-N03. 
10 
10 
10 
0RDER-ITEM-N04. 
10 
10 
10 
0RDER-ITEM-N05. 
10 
10 
10 
ITEM-NUM1 
ITEM1-QUANTITY 
ITEM1-UNIT-PRICE 
ITEM-NUM2 
ITEM2-QUANTITY 
ITEM2-UNIT-PRICE 
ITEM-NUM3 
ITEM3-QUANTITY 
ITEM3-UNIT-PRICE 
ITEM-NUM4 
ITEM4-QUANTITY 
ITEM4-UNIT-PRICE 
ITEM-NUM5 
ITEMS-QUANTITY 
ITEM5-UNIT-PRICE 
PIC X(5). 
PIC 9(5). 
PIC X. 
PIC 9(4)V99. 
PIC 9(5). 
PIC X. 
PIC 9(4)V99. 
PIC 9(5). 
PIC X. 
PIC 9(4)V99. 
PIC 9 ( 5 ) . 
PIC X . 
PIC 
9(4)V99. 
PIC 9 ( 5 ) . 
PIC X . 
PIC 
9(4)V99. 
Test D a t a : 
1 0 0 4 1 0 0 A A 1 0 2 0 8 0 5 1 9 9 2 N Y 1 0 2 0 1 9 9 2 
3 0 0 4 1 0 0 A A 1 0 2 C 1 2 4 5 L 0 0 1 0 0 0 
3 0 0 4 1 0 0 A A 1 0 2 4 4 0 1 1 A 0 2 5 0 0 0 
3 1 0 8 0 0 0 A M 1 1 1 7 2 9 5 0 P 0 1 5 0 0 0 
17 7 3 1 0 0 A 1 0 0 3 0 9 0 2 
1 9 9 2 Y N 0 1 1 5 1 9 9 3 
2 7 7 3 1 O O A 1 O 0 3 B I Z 
S M A R T 
2 1 0 
F I R S T 
S T . 
I R V I N G 
7 5 0 3 8 5 0 0 0 2 0 0 0 8 1 7 - 9 4 9 - 8 2 7 5 
3 7 7 3 1 0 0 A 1 0 0 3 9 0 6 0 0 I 0 0 2 0 0 0 
3 1 4 3 0 0 0 A 3 B 3 3 3 3 3 3 3 C 0 0 8 0 0 0 
10 1 6 0 4 0 B R 5 4 9 0 2 2 8 1 9 9 2 N N 12 16 1 9 9 2 
3 0 1 6 0 4 0 B R 5 4 9 5 8 6 G 3 C 0 4 0 0 5 0 
1 9 9 8 1 0 0 B 4 D 2 2 0 9 0 1 9 2 Y Y 0 1 3 0 9 3 
2 9 9 8 1 0 0 B 4 D 2 2 R Y X 
C O R P 
5 5 5 1 2 
N O E L 
DR 
D A L L A S 
7 5 5 2 2 9 2 2 2 2 2 2 2 2 1 4 - 7 4 1 - 9 9 9 9 
3 9 9 8 1 0 0 B 4 D 2 2 7 2 6 0 0 J 0 9 0 0 0 
3 9 9 8 1 0 0 B 4 D 2 2 3 3 3 3 3 K 0 0 0 5 0 0 
13 6 0 5 0 0 C D 8 8 8 0 8 2 8 1 9 9 2 Y N 1 1 02 1 9 9 2 
2 3 6 0 5 0 0 C D 8 8 8 A B C 
C O R P 
9 5 5 9 
KNOB 
H I L L 
S A N D I E A G O 
8 6 5 0 0 5 0 0 1 0 0 0 0 8 0 5 - 7 4 4 - 9 8 8 9 
3 3 6 0 5 0 0 C D 8 8 8 1 6 7 8 9 A 0 9 9 9 0 0 
33 60 5 0 0 C D 8 8 8 3 2 6 0 0 E 0 0 8 8 0 0 
1 9 9 9 9 9 0 C L 9 9 9 0 2 2 9 1 9 9 2 N Y 1 1 0 1 1 9 9 2 
3 9 9 9 9 9 0 C L 9 9 9 6 6 6 6 6 G 0 2 2 0 0 0 
3 9 9 9 9 9 0 C L 9 9 9 1 2 3 4 5 H 0 0 2 2 0 0 
3 9 9 9 9 9 0 C L 9 9 9 5 5 5 5 5 I 0 0 1 0 5 0 
3 9 9 9 9 9 0 C L 9 9 9 7 2 6 0 0 D 0 1 5 0 5 0 
2 3 5 0 2 0 0 D B 8 9 5 T H E 
MONEY 
P I T 
10 
DOWNTOWN 
A V E D A L L A S 
7 5 0 5 2 2 0 1 0 0 0 0 0 2 1 4 - 8 4 5 - 9 6 7 6 
1 1 0 5 1 0 5 D 5 M 0 0 1 0 1 0 1 9 9 2 N N 1 102 1 9 9 2 
2 1 0 5 1 0 5 D 5 M 0 0 C A N D Y 
I N C . 
6 6 6 
W Y L I E 
L A N E 
H U M B U G 
9 9 9 
8 8 3 0 0 1 0 0 0 0 7 1 7 - 6 6 6 - 6 6 5 6 
3 105 1 0 5 D 5 M 0 0 2 6 6 6 6 A 0 0 5 0 0 0 
1 0 2 5 0 0 0 K M 6 6 6 1 0 1 0 1 9 9 2 Y N 1 1 0 2 1 9 9 2 
2 0 2 5 0 0 0 K M 6 6 6 W I D G E T 
C O R P 
9 9 9 5 A B C 
S T R E E T C A R R O L L T 0 N 7 5 2 0 1 7 9 0 0 0 0 0 0 8 1 8 - 6 6 6 - 9 0 0 0 
3 0 2 5 0 0 0 K M 6 6 6 3 7 7 7 7 F 0 2 5 0 0 0 
1 2 0 0 1 0 0 K T 9 5 
5 0 9 2 8 1 9 9 2 N N 1 2 1 2 1 9 9 2 
3 2 0 0 1 0 0 K T 9 5 5 3 3 3 3 3 BOO 1 0 0 0 
3 2 0 0 1 0 0 K T 9 5 5 5 5 5 5 5 C 0 0 0 1 5 0 

Project 
8-1 
2 0 0 0 1 0 0 N B 4 5 6 A B C 
COMPANY 
N . 
123 
S T R E E T 
7 2 5 O Q Q O 0 5 0 0 0 2 1 5 - 6 2 6 - 4 1 53 
1 6 3 1 6 0 0 N N 2 0 0 0 7 3 0 1 9 9 2 N N 1 1 1 9 1 9 9 2 
3 6 3 1 6 0 0 N N 2 0 0 7 2 6 0 0 A 0 3 0 0 0 0 
1 1 4 3 0 0 0 R T 3 3 3 0 3 3 1 1 9 9 2 Y Y 1 2 0 5 1 9 9 2 
3 1 4 3 0 0 0 R T 3 3 3 5 9 5 X X R 0.4 0 0 0 0 
3 1 4 3 0 0 0 R T 3 3 3 X 2 X 0 0 5 0 0 5 0 0 0 
1 3 1 2 0 0 0 X X X 3 J 0 4 2 7 1 9 9 2 B N 0 6 0 1 1 9 9 2 
3 3 1 2 0 0 0 X X X 3 J 5 5 5 5 2 1 0 9 0 0 0 0 
177 1 6 0 0 X X 2 0 0 0 7 3 0 1 9 9 2 N N 1 102 1 9 9 2 
2 7 7 1 6 0 0 X X 2 0 0 S M I T H 
I N D U S T R Y 
N . 
3 3 3 
H A V E N 
C O P P E L L 
7 5 0 1 6 3 0 0 1 0 0 0 0 2 1 4 - 1 2 3 - 6 6 1 3 
3 7 7 1 6 0 0 X X 2 0 0 3 2 6 0 0 A 0 3 0 0 0 0 
3 7 7 1 6 0 0 X X 2 0 0 1 2 3 4 5 E 0 0 3 0 0 0 
1 8 8 1 6 0 0 Z Z 2 0 0 0 7 3 0 1 9 9 2 N N 1 102 1 9 9 2 
3 8 8 1 6 0 0 Z Z 2 0 0 3 2 6 0 0 6 0 3 0 0 0 0 9 2 
3 8 8 1 6 0 0 Z Z 2 0 0 12 3 4 5 E 0 0 2 0 0 0 
3 8 8 1 6 0 0 Z Z 2 0 0 3 4 5 6 7 K 0 0 3 0 0 0 
3 8 8 1 6 0 0 Z Z 2 0 0 4 5 6 7 8 F O O 1 5 00 
3 8 8 1 6 0 0 Z Z 2 0 0 1 6 7 8 9 A 0 0 0 100 
1 1 0 1 0 0 0 3 3 0 4 1 
9 2 8 1 9 9 2 X N 1 1 0 1 1 9 9 2 
R e p o r t L a y o u t : 
Develop your own report layout in compliance with the processing requirements. Be sure 
to give enough detail on the error report for the user to make the appropriate corrections. 
Processing Requirements: 1. Read a file of order transaction records. 
2. The current run date is typically accepted from a file, but for this lab set up a literal in 
working storage with the run date as November 2, 1992. 
3. Validate each input record field for all of the following: 
All numeric fields should be validated for numeric values and should be greater than 
zero. 
On the type 1 record, the PARTIAL SHIP and TAXABLE fields should contain either a 
"Y" or an "N." 
The HOLD DELIVERY DATE should be a future date. 
The PURCHASE DATE should be the current date or prior to the current date. 
On the type 2 record, all fields should contain data. 
The quantity field on the type 3 record is a 1-byte alphanumeric field. This is a code 
that translates as follows: 
A= 1 
E = 300 
I = 700 
B = 10 
F = 400 
J = 800 
C = 100 
G = 500 
K = 900 
D = 200 
H = 600 
The quantity field should be validated for a valid code. 
4. Any record that fails any validity test is to be written to an error file, and an appropriate 
error message should appear on the error report. It is possible that a record may 
contain more than one error, and all errors are to be flagged. 
5. Valid records are to be written to a valid transaction file. The valid transaction file 
should be the same format as the input Order Transaction file with the exception that 
the quantity code on the Type 3 record should be converted to the quantity amount, 
causing the unit price to be moved to the right two bytes. 

Appendix 
G — 
Projects 
Program Name: 
Stock Transactions Validation Program 
Narrative: 
This project will validate a stock transaction file and produce both a valid stock file and an 
o r r n r r o port. 
Input File: 
STOCK-TRANSACTION-FILE 
Input Record Layout: 01 STOCK-RECORD. 
05 ST-TRANSACTION-INFORMATION. 
10 ST-TRANSACTION-SHARES 
PIC 9(3). 
10 ST-TRANSACTION-STOCK 
PIC X(14). 
05 ST-PURCHASE-INFORMATION. 
10 ST-PURCHASE-PRICE 
PIC 9(5)V99. 
10 ST-PURCHASE-DATE. 
15 ST-PURCHASE-YEAR 
PIC 99. 
15 ST-PURCHASE-MONTH 
PIC 99. 
15 ST-PURCHASE-DAY 
PIC 99. 
05 ST-SALE-INFORMATION. 
10 ST-SALE-PRICE 
PIC 9(5)V99. 
10 ST-SALE-DATE. 
15 ST-SALE-YEAR 
PIC 99. 
15 ST-SALE-M0NTH 
PIC 99. 
15 ST-SALE-DAY 
PIC 99. 
Test Data: 
100XYZ CORP 
2000000920 1 15300000093:0103 
200ABC CORP 
120000093030:52200000920305 
1 00ACME WJ.DGETS 
1 1 5 000092 1 10:9500000093033 1 
100BOR0W ASSOC 
00500009202290000048 
3001. EE ENTERPRISE45:000009313229000000930422 
200N AT I. GADGET 
0100AO09205 1:5 1 1 0000092063 1 
100NATI. G;ISM0 
10000009306181200000930606 
400AMFR WTDGETS 
0 9 0 000093070:70800000930906 
350MILGR0M POWER 100000090040:5250000093043 1 
200PARKER INC 
00 30000920731010000A930428 
100SHEI !.Y CO 
003000090043:10000200 
J200STEVENls INC 
2 00 0 000 9 3 08 312 2 0 0 00 0 9 309 2 2 
Report Layout: 
Design your own report layout. Be sure to comply with all the processing requirements. 
Processing Requirements: 
1. Read a file of stock records. 
2. Validate each input record for all of the following: 
a. The month, day, and year of both the purchase and sale date must be numeric. 
b. The month must be a valid value, that is, between 1 and 12, inclusive. 
c. The day cannot exceed the maximum days in the corresponding month. 
d. The date of sale cannot be earlier than the date of purchase. 
e. The dollar amount of both purchase and sale must be numeric. 
3. Design an appropriate report layout. Invalid transactions are to be displayed with an 
appropriate error message. If a given transaction contains more than one invalid field, 

Project 
8-3 
multiple error messages are required. No further processing is required for invalid 
transactions. 
4. Each valid transaction is to be written to a file to be used in Project 9-2. 
Program Name: 
Payroll Validation Program 
Narrative: 
Develop a program to validate a payroll file and produce both a valid payroll file and an 
error report. 
Input File: PAYROLL-FILE 
Input Record Layout: 01 PAYROLL-RECORD. 
PAY -SOC-SEC-NUM 
PIC 9(9). 
PAY -NAME. 
10 PAY-LAST 
PIC X(14). 
10 PAY-FIRST 
PIC X(12). 
10 PAY-INITIAL 
PIC X. 
PAY -INFO. 
10 PAY-HOURLY-RATE 
PIC 9(3)V99 
10 PAY-HOURS-WORKED 
PIC 9(3)V99 
10 PAY-SALARY-TYPE 
PIC X. 
10 PAY-DEPENDENTS 
PIC 99. 
10 PAY-TAX-STATUS 
PIC 9. 
10 PAY-INSURANCE 
PIC X. 
PAY-•YTD-INF0. 
10 PAY-YTD-EARNINGS 
PIC 9(6)V99 
10 PAY-YTD-TAXES 
PIC 9(5)V99 
10 PAY-YTD-FICA 
PIC 9(4)V99 
10 PAY-YTD-INSURANCE 
PIC 9(4)V99 
Test Data: 
S 1 0 0 0 0 0 0 0 0 
'111111111B0YER 
2 0 0 0 0 0 0 0 0 M E R A 
2 2 2 2 2 2 2 2 2 D A V E R S A 
; 3 0 0 0 0 0 0 0 0 M E N E N D E Z 
3 3 3 3 3 3 3 3 3 F R E N C H 
4 0 0 0 0 0 0 0 0 B A R B E R 
4 4 4 4 4 4 4 4 4 G E H L E 
! 5 0 0 0 0 0 0 0 0 G R A U E R 
5 5 5 5 5 5 5 5 5 R I C 0 
6 0 0 0 0 0 0 0 0 
:666666666R0WE 
7 0 0 0 0 0 0 0 0 H E M M E R D E 
7 7 7 7 7 7 7 7 7 S H I M 
8 0 0 0 0 0 0 0 0 S T U T Z 
8 8 8 8 8 8 8 8 8 V A S Q U E Z 
9 0 0 0 0 0 0 0 0 P L A N T 
9 9 9 9 9 9 9 9 9 V A Z Q U E Z 
WARD 
SASHA 
NICK 
L 0 U R D E S 
M I C H E L L E 
MARY ANN 
SHELLY 
R O B E R T 
C H E R Y L 
C A N D A C E 
C L A R K R I C H A R D 
ANNA 
JOEL 
DONNA 
R O B E R T 
VI L L A R C A R 0 L 
0 1 0 0 0 4000H 
3D023 1 5 0 2 2 0 1 143401 345 12050000: 
E 0 1 5 0 0 0 4 0 0 0 S 0 1 3 B 0 2 7 0 0 0 0 0 0 5 4 8 5 2 4 2 0 2 7 7 0 0 4 5 0 0 0 
X 0 1 4 0 0 0 4 5 0 0 S 0 4 5 B 
A 0 0 5 5 0 0 4 0 0 0 S 0 1 4 A 0 0 9 9 0 0 0 0 0 1 4 8 5 0 0 0 7 4 3 4 9 0 6 3 0 0 0 
Y 0 2 3 5 0 0 4 0 0 0 X 1 5 2 C 0 4 5 2 9 8 2 2 0 8 9 1 3 0 0 0 2 5 0 5 3 0 5 7 5 0 0 
P 0 6 5 0 0 0 3 5 0 0 H 0 8 2 B 1 1 7 0 0 0 0 0 2 6 7 1 1 3 9 8 7 8 6 7 0 1 0 8 0 0 0 
A 1 8 0 0 0 4 0 0 L H 0 6 
A A 8 5 9 2 7 4 0 0 7 1 9 2 6 2 1 4 3 2 9 0 9 0 0 0 0 0 
T01 5 7 5 0 4 3 5 0 H 0 0 2 Z 0 2 8 3 5 0 0 0 0 4 4 4 0 5 5 2 1 2 9 0 9 0 0 0 0 0 0! 
T 1 5 0 0 4 6 0 0 0 0 5 2 Z 0 2 9 1 0 4 0 5 0 5 1 3 9 5 0 2 1 4 8 9 0 0 0 0 0 0 0 
S 0 0 7 4 5 0 5 2 0 0 H 0 1 3 C 0 1 3 4 1 0 0 0 0 2 0 1 1 5 0 1 0 0 7 0 9 0 4 5 0 0 Q 
0 4 0 0 0 S 1 0 A B 0 0 9 9 0 0 0 0 0 1 3 7 6 5 0 0 7 3 4 3 6 0 6 0 0 0 0: 
M 0 3 0 0 0 0 4 2 0 0 S 0 3 1 A 0 5 4 0 0 0 0 0 1 2 3 2 4 3 8 0 4 0 5 5 4 0 9 0 0 0 0 
0 6 5 0 0 
H008Z 1 1 6 0 0 0 0 0 2 5 7 1 1 4 3 8 5 4 3 2 0 0 0 0 0 0 0 
M 0 0 8 0 0 0 4 8 0 0 H 0 4 4 C 0 1 4 4 0 0 0 0 0 2 2 9 1 0 6 1 0 8 1 4 4 0 9 0 0 0 0 
0 0 5 5 0 0 5 0 0 H 0 L 1 1 099 1500 
0 7 5 6 0 7 
A 0 2 3 7 5 0 4 0 0 0 M 0 2 2 C 0 4 2 7 5 0 0 0 0 8 4 8 8 1 332 1053058500; 
0 0 7 5 0 0 5 3 0 0 S 0 1 3 0 0 1 4 4 1 0 0 0 0 2 1 0 0 5 0 1 0 0 0 9 0 0 4 5 0 0 0
1 
0 1 8 0 0 0 4 0 0 0 M 0 5 3 B 0 3 2 4 0 0 0 0 0 6 9 9 7 2 4 2 4 3 3 2 4 1 0 8 0 0 O 

A
p
p
e
n
d
i
x 
G 
— Projects 
Report Layout: 
Design your report layout based on the requirements below. 
Processing Requirements: 
1. Read a file of sales payroll records. 
2. Validate each input record for all of the following: 
a. The incoming record must contain data for the following fields: social security 
number, name, hourly rate, hours worked, salary type, number of dependents, tax 
status, and insurance. If any field is missing, display the message "INCOMING 
RECORD MISSING DATA" and the input record. 
b. The incoming fields of hourly rate, hours worked, number of dependents, tax 
status, ytd earnings, taxes, fica, and insurance must be numeric. If not, display an 
appropriate error message that contains the entire input record. 
c. The salary type must be either hourly or salaried (H or S). If it is not, display an 
appropriate error message, such as "INVALID SALARY TYPE FOR", the social 
security number, name, and salary type. (Hint: Use a condition name test.) 
d. Salaried employees are not paid overtime; therefore hours worked for salaried 
employees cannot be over 40 hours. Use the message "NO OVERTIME FOR 
SALARIED EMPLOYEES", the social security number, name, and hours worked. 
e. The tax status must be valid (1 through 4). Use the message "INVALID TAX 
STATUS FOR", the social security number, name, and tax status. (Hint: Use a 
condition name test.) 
f. The insurance type must be valid (A, B, C, or Z). Use the message "INVALID 
INSURANCE FOR", the social security number, name, and insurance type. (Hint: 
Use a condition name test.) 
g. A reasonable number of dependents; flag any record where the number of 
dependents is over 10. (Hint: Use a condition name test.) 
3. Any record that fails any validity test is to be rejected with no further processing, other 
than displaying the appropriate error message(s). It is possible that a record may 
contain more than one error (flag all errors). Valid records are to be written to a new file 
to be used in Projects 9-3 and 16-3. 
Program Name: 
Car Sales Commissions Validation Program 
Narrative: 
This project will validate a file of car sales records and produce both a valid car file and 
an error report. 
Input File: 
CAR-SALES-FILE 
Input Record Layout 
F I E L D N A M E 
P O S I T I O N S 
F I E L D T Y P E 
Location 
1 - 11 
Alphanumeric 
Branch 
12 - 15 
Numeric 
Salesperson 
16 -25 
Alphanumeric 
Customer Name 
26 -35 
Alphanumeric 
Sale Date 
36 -41 
Numeric 
Sale Amount 
42 -47 
Numeric 
Commission Rate 
48 -50 
Numeric 
Car Model 
51 -63 
Alphanumeric 
Car Year 
64 -67 
Numeric 

Project 
8-4 
T e s t Data: 
(BROWARD 
i 1 2 3 4 S H I Mi 
R E I M A N 
M O N R O E 
: 
4 5 2 8 V A S Q U E Z 
HAFEZ 
JDADE 
! 
4 6 7 9 D A V E R S A 
jBROWARD 
1 2 3 4 S H I M 
PORTO 
M O N R O E 
4 5 2 8 B 0 Y E R 
B R O W A R D 
; 
1 2 3 4 G E H L E 
LARSH 
D A D E 
9 8 7 9 F R E N C H 
B R O W A R D 
1 2 3 4 G E H L E 
H O L M E 
D A D E 
' 
9879FREN;CH 
D E G G S 
B R O W A R D 
1 2 3 4 G E H L E 
M O R E N O 
D A D E 
0 1 2 4 R I C O 
G O R M A N 
M O N R O E 
! 
4 5 2 8 V A S Q U E Z 
HWANG 
B R O W A R D 
! 
4 5 6 7 R 0 W E 
T O C K W A N 
D A D E 
0 1 2 4 R I C Oi 
C H u A; 
DADE 
9 8 7 9 F R E N C H 
SPEA;RS 
M O N R O E 
4528B0YE;R 
A U G U S M A 
DADE 
4 6 7 9 D A V E R S A 
R E N E S C A 
B R O W A R D 
4 5 6 7 R O W E 
V I ERA 
M O N R O E 
4528B0YE;R 
LOUIS 
B R O W A R D 
, 4 56 7 ROW E: 
P I N E D A 
D A D E 
01 ? 4 R IC 0: 
DI 1 FG0 
1 3 1292 1 8 7 2 5 0 0 2 S A A B 900 
19 9 2; 
1013:92 3 2 8 7 5 0 0 3 J A G U A R XJS 1 9 9 1 
1 1 14920 305 54005 I NFI NIT I Q45 199 1 
1 0 3 2 9 3 0 2 5 5 7 5 0 0 4 M B 
300E 
1 9 1 6 
0 6 3 3 9 3 
8 1 2 5 0 0 4 M A Z D A 626 
1 9 9 1 
1 1 1 2 9 3 0 2 0 4 7 5 0 0 3 PEUGOT 
505GLS1991; 
0 9 2 8 9 2 0 2 2 7 5 0 0 0 3 B M W 
3 2 5 i X 
1991; 
9 3 1 9 2 0 1 4 7 0 0 0 0 2 P R E L U D E SI 
199 2 
0 1 3 1 9 3 0 1 3 0 2 5 0 0 4 N I S S 
M A X I M A 1992 
101293 17125 
5T0Y SUPRA 
1991: 
1 0 3 1 9 2 0 3 5 5 0 0 1 8 4 L E X U S 
LS400 1992 
123 192 25000 
4 L E G E N D C LS 1990! 
0 1 0 4 9 1053 1 5 0 0 0 6 B M W 750 1 L 
19 9 2' 
8 1 5 9 3 0 1 4 7 0 0 0 0 4 T 0 Y 
CAMRY DE 1 9 9 L 
1 0 1 6 9 3 0 2 3 9 7 5 0 0 1 N I S S A N 
300Z 
19 92 
0 4 1 0 9 3 0 6 9 7 9 9 0 0 2 M B 500 SL 
1 9 9 1 
1 0 4 2 9 2 0 0 4 9 5 0 0 0 2 H Y U N 
E X C E L G 1991 
1 1 5 9 2 0 1 0 3 0 0 0 0 2 S T E R L G 
8 2 5 S L 1 9 9 0! 
102 992 1 2 1 7 5 1 0 4 M A Z RX7 G X L 19 9 1 
1 2 2 4 9 3 0 1 6 1 0 0 
3AUDI Q U A T T R O 19 9 0: 
1 126930 1 2 8 0 0 0 0 4 M A Z D A 
M I ATA 
19 91 
R e p o r t L a y o u t : 
Design your own report layout, subject to the processing requirements. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of car sales records. 
2. Validate each input record for all of the following: 
a. The incoming record must contain data for the following fields: location, branch, 
salesperson, customer, sale amount, commission rate, and model year. If any field 
is missing, display a single message "INCOMING RECORD MISSING DATA", 
followed by the input record. 
b. The incoming fields of branch, sale date, sale amount, and commission rate must 
be numeric. If not, display an appropriate error message that contains the entire 
input record. 
c. Valid dates (sale date): month must be between 1 and 12, inclusive; day should be 
in conjunction with the month; and year must be the current year or the year before. 
Display a suitable message "INVALID MONTH", "INVALID DAY", and/or "INVALID 
YEAR", followed by the input record. 
d. A reasonable commission rate: flag any record where the rate is not between 0% 
and 100%. Use the message "INVALID COMMISSION RATE", followed by the input 
record. 
e. A reasonable car year: flag any record where the car year is not between 1930 and 
1995, inclusive. Use the message "INVALID CAR YEAR", followed by the input 
record. 
3. Any record that fails any validity test is to be rejected with no further processing, other 
than displaying the appropriate error message(s). It is possible that a record may 
contain more than one error (all errors are to be flagged). 
4. Valid records are to be written to a file to be used in Project 9-4. 

A
p
p
e
n
d
i
x 
G 
Projects 
Program Name: 
Invoice Validation Program 
Input Record Layout: 01 INVOICE-RECORD-IN. 
05 INV-INV0ICE-N0 
PIC X(4). 
05 INV-DATE. 
10 INV-MONTH 
PIC 9(2). 
10 INV-DAY 
PIC 9(2). 
10 INV-YEAR 
PIC 9(2). 
05 INV-CUST0MER-INF0. 
10 INV-CUST-NAME 
PIC X(10). 
10 INV-CUST-ADDRESS 
PIC X(10). 
10 INV-CUST-CITY 
PIC X(10). 
10 INV-CUST-STATE 
PIC XX. 
10 INV-CUST-ZIP 
PIC X(5). 
Test Data: 
•2467 1 0 0 4 9 . 3 S c u l l y 
20 
M a i n 
S t C h i c a g o 
, 
I L 6 0 6 6 6 
3 8 4 5 1 3 12 
M i n n i e 
; D i s n e y
 
1 TZ 
; 1 5 7 8 0 8 1 2 9 3 S c h u l 
t z 
4 5 
5 t h 
S t 
L o s 
A n g e l i e C A 9 0 0 2 4 
; 3 4 4 6 1 2 3 1 9 3 G o o f y 
M a i n 
S t 
O r l a n d o 
F X 3 9 5 7 5 
0 3 4 2 0 9 1 0 9 3 C u l v e r 
1 
S u n n y 
L n S e a t t l e 
W A 9 8 0 0 8 
4 790 1 1 1 2 9 3 P e r e z 
4 
L o n g 
D r 
New 
0 r 1 e a n L A 7 9 3 4 5 
09 
93 
N o N a m e 
S t 
S ome w h e r ei 
4 9 5 7 6 
6 8 3 6 0 7 0 4 9 3 F i x l e r 
3 
4 2 n d 
S t ; New 
Y o r k 
N Y 1 0 0 2 0 
2 3 4 G 
3 2 9 3 P l u t o 
2 
Dog 
D r 
D o g v i l l e 
: P R 6 7 4 5 3 
4 8 0 7 0 3 1 8 9 3 M o r i n 
9 
7 t h 
A v e : N e w a r k 
: N J 0 7 6 3 2 
0 4 9 8 0 6 3 0 9 3 M u n r o e 
10 
L o n g 
S t T u l s a 
| 0 K 5 9 3 4 5 
6 2 3 4 
M i c k e y 
D i s n e y 
S t ; 
: 
F L 3 3 4 8 0 
Report Layout: 
Develop your own report layout in compliance with the processing requirements. 
Processing Requirements: 1. Read a file of invoice records. 
2. Validate each input record field for all of the following: 
a. Invoice No: 
(1) If the invoice number is missing, print an appropriate error message: 
Record missing data in INVOICE NO field for: Smith 
(2) If the invoice number is not missing, verify that the value is numeric; if not, 
display an error message: 
Nonnumeric INVOICE NO for: Smith 
Invoice No: ABC4 
b. Date: 
(1) If the invoice date (i.e., Month, Day, or Year) is missing, print an appropriate 
error message: 
Record missing data in INVOICE DATE field for: Smith 
Narrative: 
Write a data validation program that will validate an invoice tile and produce both a valid 
invoice file and an error report. 
input File: 
INVOICE-FILE 

(2) If the invoice date is not missing, verify that the month is valid (i.e., 1 thru 12); 
error message: 
Invalid MONTH for: Smith 
Invoice No: 1234 Month: 20 
(Hint: Use a condition name test for valid months.) 
(3) Verify that the day is valid (i.e., cannot exceed the maximum days in the 
corresponding month); error message: 
Invalid DAY for: Smith 
Invoice No: 1234 Month: 12 Day: 35 
(Hint: Yes, use another condition name test for valid days.) 
(4) Verify that the year is valid; the year must be either the current or previous year; 
error message: 
Invalid YEAR for: Smith 
Invoice No: 1234 Year: 95 
(5) If the date is valid, then verify the complete date against today's date; error 
message: 
Invalid DATE for: Smith Invoice No: 1234 Month: 12 Day: 31 Year: 95 
c. Name: If the name is missing, print an appropriate error message: 
Record missing data in NAME field for Invoice No: 1234 
d. Address: If the city is missing, print an appropriate error message: 
Record missing data in ADDRESS field for: Smith Invoice No: 1234 
e. City: If the address is missing, print an appropriate error message: 
Record missing data in CITY field for: Smith Invoice No: 1234 
f. State: 
(1) If the state is missing, print an appropriate error message: 
Record missing data in STATE field for: Smith Invoice No: 1234 
(2) If the state is not missing, then verify that it is a valid state. Valid States are AK, 
AL, AR, AZ, CA, CO, CT, DC, DE, FL, GA, HI, IA, ID, IL, IN, KS, KY, LA, MA, 
MD, ME, Ml, MN, MO, MS, MT, NC, ND, NE, NH, NJ, NM, NV, NY, OH, OK, OR, 
PA, Rl, SO SD, TN, TX, UT, VA, VT, WA, Wl, WV, and WY; error message: 
Invalid STATE for: Smith 
Invoice No: 1234 State: AT 
(Hint: Another condition name test for valid states.) 
g Zip: 
(1) If the zip is missing, print an appropriate error message: 
Record missing data in ZIP field for: Smith 
Invoice No: 1234 
(2) If the zip is not missing, verify that the value is numeric; if not, display an error 
message: 
Nonnumeric ZIP for: Smith 
Invoice No: 1234 Zip: 08307 
3. Any record that fails any validity test is to be rejected with no further processing, other 
than displaying or printing the error message(s). It is possible that a record may 
contain more than one error (flag all errors except where noted). 
4. Valid records are to be written to a new file to be used in Project 9-5. 

A
p
p
e
n
d
i
x 
G — 
Projects 
Program Name: 
Narrative: 
Student Record Validation Program 
Write a data validation program that will validate a student file and produce both a valid 
student file and an error report. 
I n p u t F i l e : 
STUDENT-FILE 
I n p u t R e c o r d L a y o u t : 
01 STUDENT-RECORD. 
05 STU -ID 
PIC X(9). 
05 STU -NAME 
PIC X(16) 
05 STU -SCHOOL-INFORMATION. 
10 STU-SCH0OL-CODE 
PIC X(3). 
10 STU-MAJ0R-C00E 
PIC X(3). 
10 STU-AID-TYPE 
PIC X. 
10 STU-GPA 
PIC 9V999 
10 STU-CREDIT-HOURS 
PIC 99. 
T e s t 
D a t a : 
l i i i l l P i l i l ^ 
|235980890jKostner, Kjevin 
J29376563'5JRoberts , j!u 1 i a 
J32857 6407JMurphy, Edjdie 
| 
Smith, John 
J37857560OJBaldwin, Alec 
J397 57 5906jHawn , Goldjie 
[4 2749679 4jRussel 1 , KJurt 
J43-4562734JTweety Birjd 
459797G01Stallone, Sly 
(470876493(Gabl e , Cla'rk 
475673723B1rd, Big j 
4927 2947 5|Freeman, Miorgan 
524956063|Newman , Paul 
54039406 5JRedford, Robert 
(S84784755; 
j 
|586432980;Runner, Road 
|593639456JDavi s , Geena 
j63596869OiSarandon, (Susan 
|6 5829458 5(Douglas, Mjichea 
J693764956!Hi tchcock,! Al 
J732947566(Mouse , Micjkey 
J740685676(Bunny , Bugjs 
j753546833lDuck, Donajld 
J769048304(Streep, Melrril 
J779309498(Gol dberg , 'Woopi 
J794784830sGrant, Carjy 
(816274855(Crystal , B(i 11 y 
!826495896(Letterman ,< Davi 
(834858653JC1 ark , Dicik 
[8430 2 037 5JW i 1 1 i ants , (Robin 
(924649576TT 
|967707888|Hal 1 , Arselni o 
BUSM-KTS 349908 
C0MM(KTG3657 10 
C0MPJHYS2499 12 
MDDECOZ000003 
MUSEEGS 
0G 
MEDBJIOG3450 15 
ARTCJI SG369018 
BUSFJINS387 103 
C0MP(HYL2 10500 
EMGBJIOL250L 
LAWSJTAS300509 
MUSCJISG379012 
MEDSJTAS332 101 
ARTACCL267510 
ENGSTTL310520 
C0MAJCCL250006 
BUSFJINS29991 1 
ENGSJTAG349909 
1 BUSMiKTS300004 
MISAJCCL3 55 500 
MUSCISS400016 
MEDPJHYS350002 
LAYM(KTL2499 
ARTFJINS397002 
LAWMIKTG289918 
MESEJEGL2399 G 
COMBJI0L300105 
dC0MC(ISS3001 16 
BUSFJINS37 9817 
ENGE;NGS2 7 6910 
EE.GE|NGZ4001 12 
C0
;MMiKTG398017 
R e p o r t 
L a y o u t : 
Develop your own report layout in compliance with the processing requirements. 

Project 
8-6 
Processing Requirements: 
1. Read a file of student records. 
2. Validate each input record field for all of the following: 
a. Name: If the name is missing, print an appropriate error message: 
Record missing data in NAME field for Student ID: 123456789 
b. Student ID: 
(1) If the student ID is missing, print an appropriate error message: 
Record missing data in STUDENT ID field for: Smith, AB 
(2) Verify that the value is numeric; if not, display an error message: 
Nonnumeric STUDENT ID for: Smith, AB Student ID: 123456789 
c 
G P A : 
(1) If the G P A is missing, print an appropriate error message: 
Record missing data in GPA field for: Smith, AB Student ID: 123456789 
(2) If the GPA is not missing, verify that the value is numeric; if not, display an error 
message: 
Nonnumeric GPA for: Smith, AB Student ID: 123456789 GPA: ABCD 
(3) If the GPA is numeric, 
then verify that the G P A is between 2.5 and 4.0, 
inclusively (students with a G P A below 2.5 are ineligible for any kind of aid); if 
not, display an error message: 
GPA out of limits for: Smith, AB Student ID: 123456789 GPA: 5000 
d 
Credit Hours: 
(1) if the credit hours are missing, print an appropriate error message: 
Record missing data in CREDIT HOURS field for: Smith, AB Student ID: 
123456789 
(2) If the credit 
hours are not missing, 
verify that the value is numeric; if not, 
display an error message: 
Nonnumeric CREDIT HOURS for: Smith, AB Student ID: 123456789 Credit 
Hours: AB 
(3) If the credit hours are numeric, then verify that the hours are between 1 and 18, 
inclusively; if not, display an error message: 
CREDIT HOURS out of limits for: Smith, AB Student ID: 123456789 
Credit Hours: 22 
e. Codes: 
(1) Valid school codes are ART, BUS, C O M , E N G , LAW, M E D , and M U S ; error 
message: 
Invalid SCHOOL for: Smith, AB Student ID: 123456789 Major: ABC 
(2) Valid major codes are A C C , BIO, E C O , E N G , FIN, CIS, MKT, PHY, and STA; 
error message: 
Invalid MAJOR for: Smith, AB Student ID: 123456789 MAJOR: ABC 
(3) Valid aid types are S, G, and L; error message: 
Invalid AID TYPE for: Smith, AB 
Student ID: 123456789 Aid Type: Z 
3. Any record that fails any validity test is to be rejected with no further processing, other 
than displaying or printing the appropriate error message(s). It is possible that a 
record m a y contain more than one error (all errors are to be flagged except where 
noted). 
4. Valid records are to be written to a new file, which will be used in Projects 9-6 and 16-2. 

Appendix 
G 
Projects 
Program Name: 
Salary Report Validation Program 
Input Record Layout: 
01 SALARY-RECORD. 
05 SAL-S0C-SEC-N0 
PIC X(9). 
05 SAL-NAME-AND-INITIALS 
PIC X(15). 
05 SAL-BIRTH-DATE. 
10 SAL-BIRTH-MONTH 
PIC 9(2). 
10 SAL-BIRTH-YEAR 
PIC 9(2). 
05 SAL-LOCATION-CODE 
PIC X(3). 
05 SAL-E0UCATI0N-C0DE 
PIC 9. 
05 SAL-TITLE-DATA. 
10 SAL-TITLE-CODE 
PIC 9(3). 
10 SAL-TITLE-DATE. 
15 SAL-TITLE-MONTH 
PIC 9(2). 
15 SAL-TITLE-YEAR 
PIC 9(2). 
05 SAL-RATING 
PIC 9. 
OR SA.l-SALARY 
PIT Qffil. 
Test Data: 
; 1 2 5 8 9 6 7 9 0 : B e c k e l e s , 
GG 
] 2 3 5 9 8 0 8 9 0 , B e n n e t t , 
JA 
J29376563 K B 1 a n e y , WC 
!3 1 2 4 5 8 6 9 7 ; C h a t a n i , 
D'H 
;3 2 8 5 7 6 4 0 7C h e n , 
E I 
i 
C r u m i t y , 
T R 
j 3 7 8 5 7 5 6 0 0 ' 0 a i 1 e y , 
T P 
i397 57 5 9 0 6 F e u e r , 
D 
14 2 7 4 9 6 7 9 4 G a r c i a , 
A 
J 4 5 9 7 9 7 8 0 8 : G o n z a l e z , 
I. 
4 7 0 8 7 6 4 9 3 G u t i e r r e z , 
CM 
:492 7 2 9 4 7 5 : J a c k s o n , 
NL 
J 5 2 4 9 5 6 0 6 3 L a r g e s s e , 
CL 
J 5 4 0 3 9 4 0 6 5 L e v y , MS 
S 8 4 7 8 4 7 5 5 
J 5 9 3 6 3 9 4 5 6 ' M o s c a t e l 1 i ' , 
E J 
; 6 3 5 9 6 8 6 9 0 M u r a t a , 
Y 
|6 5 8 2 9 4 5 8 5JN i 1 s s o n , 
P 
J 6 9 3 7 6 4 9 5 6 P a u n c e f o r t , 
C 
: 7 3 2 9 4 7 5 6 6 R a f f 1 e , 
AG 
• 7 4 0 6 8 5 G 7 G R o b i n s o n , 
P J 
| 7 6 9 0 4 8 3 0 4 R o d r i g u e z ,i AM 
: 7 7 9 3 0 9 4 9 8 S a n c h e z , 
MC 
| 7 9 4 7 8 4 8 3 0 ; S c h a n d , 
M I 
; 8 1 6 2 7 4 8 5 5 : S h i n a w a t r a , 
R 
i 8 2 6 4 9 5 8 9 6 T o z z i 
, 
GA 
183485 8653 V i 1 1 a r , CV 
:8 4 3 0 2 0 3 7 5 ^ W i l c o x o n , 
B 
: 9 2 4 6 4 9 5 7 f r Y a d a v , 
S 
; 9 6 7 7 0 7 8 8 8 l Y a u , 
S C 
0 3 5 7 M I A 4 0 4 0 0 3 9 0 2 0 5 4 0 0 0 
1 6 6 7 L;A 4 0 6 0 0 3 4 4 4 0 4 6 7 0 0 
0 4 6 7 D H I 5 0 4 0 0 4 8 8 5 0 7 8 0 2 7 
0 6 5 4 N Y 
6 0 5 0 0 6 9 0 : 4 
1 2 3 0 0 0 
0 9 5 9 M ; i A 2 0 4 0 0 2 9 1 1 0 4 5 9 9 9 
1 6 6 3 A T 
407 
1 0 6 9 1 5 0 8 3 0 7 8 
0 5 6 6 A T L 5 0 8 0 0 7 8 4 2 0 6 7 2 0 0 
0 5 7 1 C H I 3 0 9 0 0 6 8 4 4 0 9 0 6 8 0 
0 6 6 8 L A 
6 0 7 0 0 2 8 7 2 0 1 8 0 5 0 
0 2 7 4 N Y 
3 0 9 0 0 8 8 5 , 5 0 3 0 4 8 0 
0 3 6 7 A T L 2 1 0 0 0 1 9 0 4 0 2 7 0 9 0 
0 4 6 6 M I A 3 0 4 0 0 3 9 0 4 1 4 0 9 8 0 
0 2 5 9 C H 
1 4 0 5 0 1 1 8 7 3 0 3 0 8 5 6 
0 5 6 0 L A 
2 0 3 0 1 2 8 9 1 0 3 7 4 5 2 
0 2 6 5 A T L 0 1 5 0 1 4 9 2 3 3 5 0 0 0 1 
03 67 A T L 2 0 7 0 1 2 8 5 5 0 5 0 120 
0 6 7 0 M : I 
A 5 0 2 0 0 2 8 9 4 0 3 8 5 4 6 
0 I 7 5 C : H I 2 0 6 0 0 3 9 1 5 0 3 6 4 5 6 
0 5 7 1 L A 
5 0 7 0 0 2 7 4 2 0 6 3 7 4 0 
0 6 6 8 L A 
2 0 5 0 0 7 7 9 5 0 4 6 5 8 9 
1 2 7 7 N Y C 5 0 7 0 0 7 9 5 0 
1 1 6 7 M I A 5 0 3 0 0 3 7 9 1 0 2 8 3 4 5 
0 7 5 9 N Y 
2 0 8 0 0 7 9 0 4 0 4 7 2 4 2 
0 4 7 2 L A X 7 0 9 0 0 6 9 1 7 
0 6 4 9 0 
0 3 5 6 C
! H I 
4 1 0 0 0 7 8 9 3 0 3 6 4 7 8 
0 3 5 1 A T L 4 0 8 0 0 7 8 2 5 1 9 2 3 7 5 
0 8 3 8 M I A 5 0 1 0 0 2 5 5 : 5 3 5 0 0 0 0 
0 4 5 7 A T L 5 0 7 0 0 4 8 7 4 0 4 7 5 6 6 
0 4 6 1 M T A 2 0 9 0 1 2 9 0 1 0 3 7 8 5 6 
0 3 6 7 C H I 3 1 0 0 0 3 8 9 2 2 3 8 7 4 5 
Narrative: 
Write a data validation program that will validate a salary file and produce a valid salary 
file. 
Input File: 
SALARY-FILE 

Project 
8-7 
Report Layout: 
Develop your own report layout in compliance with the processing requirements. 
Processing Requirements: 
1. Read a file of salary records. 
2. Validate each input record field for all of the following: 
a. Name: If the name is missing, print an appropriate error message: 
Record missing data in NAME field for Soc Sec No: 123456789 
b. Soc Sec No: 
(1) If the social security number is missing, print an appropriate error message: 
Record missing data in SOC SEC NO field for: Smith, AB 
(2) If the social security 
number 
is not missing, verify that the value is numeric; if 
not, display an error message: 
Nonnumeric SOC SEC NO for: Smith, AB 
Soc Sec No: ABCD6789 
c. Salary: 
(1) If the salary is missing, print an appropriate error message: 
Record missing data in SALARY field for: Smith, AB 
Soc Sec No: 123456789 
(2) If the salary is not missing, verify that the value is numeric; if not, display an 
error message: 
Nonnumeric SALARY for: Smith, AB 
Soc Sec No: 123456789 Salary: 083078 
(3) If the salary is numeric, then verify that salary is over $10,000 and under 
$350,000; if not, display an error message: 
SALARY out of limits (under $010000 or over $350000} for: Smith, AB 
Soc Sec No: 123456789 Salary: 350001 
d. Codes: 
(1) Valid location codes are MIA, CHI, LA, NY, and ATL; error message: 
Invalid LOCATION for: Smith, AB 
Soc Sec No: 123456789 Location: AT 
(2) Valid education codes are 1 through 6; error message: 
Invalid EDUCATION for: Smith, AB 
Soc Sec No: 123456789 Education: 0 
(3) Valid title codes are 010, 020, 030, 040, 050, 060, 070, 080, 090, and 100; error 
message: 
Invalid TITLE for: Smith, AB 
Soc Sec No: 123456789 Title: 150 
(4) Valid ratings are 1 through 5; error message: 
Invalid RATING for: Smith, AB 
Soc Sec No: 123456789 Rating: 0 
e. Birth Date and Age: 
(1) Verify that the values in the birth date are valid; error message: 
Invalid BIRTH MONTH for: Smith, AB Soc Sec No: 123456789 
Birth Month: 16 
(2) Verify the employee is not under 16 years of age; error message: 
AGE under 16 for: Smith, AB 
Soc Sec No: 123456789 Age: 13 
f Title Date: 
(1) Verify that the title month is valid; error message: 
Invalid TITLE MONTH for: Smith, AB Soc Sec No: 123456789 
Title Month: 20 
(2) Verify that the title year is valid; the company was established in 1955; therefore 
no employee should have had a title before that year; error message: 
TITLE YEAR before 1955 for: Smith, AB 
Soc Sec No: 123456789 
Title Year: 44 

Appendix 
G — 
Projects 
(3) Verify that the title year is valid; therefore no employee should have had a title 
year beyond the current year; error message: 
TITLE YEAR beyond 1993 for: Smith, AB 
Soc Sec No: 123456789 Title 
Year: 95 
(4) If the title year is valid, then verify the complete title date against today's date; 
error message: 
Invalid TITLE DATE for: Smith, AB Soc Sec No: 123456789 Month: 06 Year: 
91 
3. Any record that fails any validity test is to be rejected with no further processing, other 
than displaying or printing the appropriate error message(s). It is possible that a record 
may contain more than one error (all errors are to be flagged except where noted). 
4. Valid records are to be written to a new file to be used in Projects 9-7 and 16-3. 
Program Name: 
Stock Validation Program 
Narrative: 
Write a data validation program that will validate a stock file and produce both a valid 
stock file and an error report. 
Input File: 
STOCK-FILE 
Input Record Layout: 
01 STOCK-RECORD-IN. 
05 STOCK-INFO. 
10 STOCK-NAME 
PIC X(8). 
10 STOCK-EXCHANGE-CODE 
PIC 9. 
10 STOCK-INDUSTRY-CODE 
PIC X(3). 
05 STOCK-CURRENT-INFO. 
10 STOCK-PRICE 
PIC 9(3)V9(3), 
10 ST0CK-PE 
PIC 9(3). 
10 STOCK-DIVIDEND 
PIC 9V99. 
05 STOCK-PROJECTION-INFO. 
10 STOCK-RISK-CODE 
PIC 9. 
10 STOCK-GROWTH-RATE 
PIC 9V9(4). 
10 ST0CK-SHARES-T0-BUY 
PIC 9(4). 
Test Data: 
H h h h h h h 0 B E E 0 0 1 0 0 0 9 9 9 5 5 5 6 0 0 1 0 0 
A a a a a a a 
1 B A N 0 1 2 3 4 0 0 1 2 2 2 2 0 0 5 4 3 2 0 0 0 0 
A n h e u s 
1 B E E 5 2 7 5 0 0 4 6 1 1 2 3 0 0 5 0 0 0 0 1 5 
A T & T 
1 T E L 0 4 2 1 2 5 0 < 8 8 1 3 2 4 0 2 5 5 0 0 1 0 0 
B e l 1 S o 
1 T E L 0 4 7 7 5 0 0 1 5 2 7 6 4 0 2 9 7 5 0 0 6 5 
C h e v r o n 
1 0 I L 0 7 2 7 5 0 0 2 4 3 3 0 4 0 0 9 5 0 0 0 5 0 
C h r y s l r 
1 A U T 0 2 0 0 0 0 0 1 5 0 6 0 2 0 0 3 0 0 0 0 2 5 
Corapq 
1 C M P 0 2 8 7 5 0 0 3 8 2 3 0 3 0 1 5 5 0 0 0 2 5 
E e e e e e e 
1 E L L 1 5 0 0 0 0 0 1 1 8 9 0 0 0 0 0 0 0 0 1 6 8 
E x x o n 
1 0 1 L 0 6 2 7 5 0 0 1 4 2 8 8 3 0 0 7 0 0 0 0 3 5 
F f f f f f f 
1 F & L 
0 1 0 2 5 0 0 1 0 0 0 1 0 0 0 0 
K e l l o g g 
1 F 0 0 0 5 8 3 7 5 0 2 2 1 1 2 3 0 2 4 5 5 0 0 1 0 
K m a r t 
I R E T 0 4 6 0 0 0 0T 1 1 7 6 3 0 0 5 0.0 0 0 0 5 

Project 
8-8 
(Gen E l 
L E L E 0 7 7 5000:1 5 2 2 0 3 0 0 9 5:000 50 
[ G n M o t r 
1JAUT044 12 5Oil 53 3 120067^500 10 
[ I B M 
1|CMP09 0 3 7 50:1 3 4 8 4 3 0 1 10(00050 
H a r r i o t 
1 F & L 0 1 8 0 0 0 0 2 3 0 2 8 3 0 0 5 0 0 0 0 2 0 
M c D o n l d 
1 ( F & L 0 4 6 5 0 0 0 ; 1 9 0 4 0 4 0 1 3 5J00010 
N o r w s t 
1 A I R 0 3 7 7 5 0 0 
12 1 0 0 2 0 0 4 5 0 0 0 1 5 
R e e b o k 
1 R E T 0 2 3 5 0 0 0 0 9 0 3 0 2 0 0 7 7 5 0 0 7 5 
S e a r s 
IIRETO4 2 5O00(1 5 2 0 0 3 0 1 1 5j0 0 0 5 0 
S w B e l l 
1 J T E L 0 6 0 3 7 5 o|l 2 2 9 2 3 0 0 7 OJO 0 0 3 0 
U p j o h n 
1IDRU0 3 2 6 2 50(1 1 13 6 400801000 2 5 
U S W s t 
l ' A I R0356250)122 12 10045J00025 
W e n d y s 
S F & L 0 1 2 0 0 0 0 2 2 0 2 4 4 0 2 9 5 0 0 0 5 0 
B a n k r s 
2 B A N 0 0 2 2 7 5 0 0 8 0 5 8 1 0 0 3 2 0 0 0 3 0 
I o m e g a 
2 E L E 0 0 6 5 0 0 0 0 9 0 5 0 3 0 0 6 7 5 0 0 4 0 
M a x w e l 
2 F 0 0 0 1 3 0 0 0 0 1 3 0 4 0 4 0 0 7 0 0 0 0 1 0 
O r a c l e 
2:CMP0 1 5 5000i5 5 2 2 5 30 12 0J00010 
P o l kAu 
2 ' E L E 0 0 6 2 5 0 0 J 3 5 0 7 5 2 0 0 5 5 J 0 0 0 2 5 
S e a g a t e 
2 J E L E O 1 7 1 2 5 3 4 3 1 3 0 3 0 0 8 9 ^ 0 0 4 5 
3;TEL 1 2 5 0 000(3 4 5 5 0 0 0 4 5 4:502 0 0 
C c c c c c c 
3 J B E N 0 1 2 5 5 0 0 i l 2 0 1 5 3 0 1 2 3 4 0 2 5 0 
C m c e B k 
3iB A N 0 1 5 5 0 0 010 5 0 1 5 2 0 0 4 0;0 00 19 
J L d m k B 
3 J B A N 0 0 0 0 6 3 0JO 7 0 1 0 1 0 0 3 2 5 0 5 0 0 
j D d d d d d d 
4 ; d r u 0 0 0 0 0 0 0 J 2 0 4 5 5 1 0 2 3 OJO 0 7 5 0 
( E x c e l 
4 C M P 0 1 17 5 00(2 8 0 2 4 4 0 3 50:000 7 5 
J G g g g g g g 
4a i rO 1 0 0 0 0 0 ( 2 2 7 5 0 0 0 0 0 2 ( 5 0 1 00 
[Li 1 V e r n 
4(RE TO 1 4 0 0 00(14 00 52 00 6 51000 5 0 
L u r i a 
4 J R E T 0 0 7 1 2 5 0 : 2 9 0 9 5 2 0 0 7 
5 J 0 0 0 2 5 
i M e t r b k 
4!BAN0112500sO 9 0 6 0 3 0 0 4 OJO 0 0 5 0 
( S k y w s t 
4(A I R 0 Q 7 7 5 0 0 ( 2 0 0 0 5 3 0 0 5 0 : 0 0 0 3 5 
j S o n e s t a 
4 F & L 0 0 5 5 000J0 2 100 3 0089J0 00 5 0 
( T r u s t c o 
4(BAN02 7 0 0 0 0 ( 1 2 0 6 0 2 0 0 4 0 ( 0 0 0 1 0 
J T y s o n 
4 F O O 0 1 8 6 2 50(1 7 0 0 4 3 0 0 5 5(0002 5 
I B b b b b b b 
5 S D 
0 0 1 3 4 5 0 ! l 2 0 7 5 1 1 25o!o 1 5 0 0 
Report Layout: 
Develop your own report layout in compliance with the processing requirements. 
Processing Requirements: 1. Read a file of stock records. 
2. Validate each input record field for all of the following: 
a. Stock Name: If the name is missing, print an appropriate error message: 
Record missing data in NAME field Industry Code: XXX 
b. Exchange Code: 
(1) Verify that the value is numeric; if not, display an error message: 
Nonnumeric EXCHANGE CODE for Stock: XXXXXXXX 
(2) If the exchange code is numeric, verify that the code is valid. Valid exchanges 
are 1 through 4. 
Error message: Invalid EXCHANGE for Stock: XXXXXXXX Exchange: X 
(Hint: Use condition name test for valid exchanges.) 
c. Industry Code: Verify that the industry code is valid. Valid industry codes are: AIR, 
AUT, BAN, BEE, CMP, DRU, ELE, F&L, FOO, OIL, RET, S&L, and TEL. 
Error message: Invalid INDUSTRY CODE for Stock: XXXXXXXX Industry: XXX 
(Hint: Use condition name test for valid types.) 

Appendix 
G — 
Projects 
d. PE and Dividend: Verify that these values are numeric; if not, display the appropriate 
error message: 
Nonnumeric PE for Stock: XXXXXXXX 
PE: 999 
Nonnumeric DIVIDEND for Stock: XXXXXXXX Dividend: 9.99 
e. Price and Shares to Buy 
(1) Verify that these values are numeric; if not, display the appropriate error 
message: 
Nonnumeric PRICE for Stock: XXXXXXXX Price: 999.999 
Nonnumeric SHARES TO BUY for Stock: XXXXXXXX Shares to Buy: 9999 
(2) Verify that both are not zero; if either is zero, display an error message: 
Zero Price and/or Shares to Buy for Stock: XXXXXXXX Price: 999.999 Shares: 
9999 
(3) Finally, when both the price and shares to buy are numeric 
and not 
zero, 
verify that the potential stock purchase is not over the limit of $25,000. That is, 
if the product of the stock price and the shares to buy exceeds $25,000, the 
record should be rejected. Display the following error message: 
Total Purchase exceeds limit for Stock: XXXXXXXX Limit: 9999999 
f. Risk Code and Growth Rate: 
(1) Verify that the value is numeric; if not, display the appropriate error message: 
Nonnumeric RISK CODE for Stock: XXXXXXXX Risk Code: X 
Nonnumeric GROWTH RATE for Stock: XXXXXXXX Growth Rate: XXXXX 
(2) If the risk code or growth rate is numeric, verify that the codes are valid. Valid 
risk codes are 1 through 5. Valid growth rates are .01% through 100%. 
Appropriate error messages are: 
Invalid RISK CODE for Stock: XXXXXXXX Risk Code: X 
Invalid GROWTH RATE for Stock: XXXXXXXX Growth Rate: 9.9999 
(Hint: Use a condition name test for valid risks and growth rates.) 
3. Any record that fails any validity test is to be rejected with no further processing, 
other than displaying or printing the appropriate error message(s). It is possible 
that a record may contain more than one error (all errors are to be flagged except 
where noted). 
4. Valid records are to be written to a file to be used in Projects 9-8, 16-4, and 17-6. 
Program Name: 
Electricity Bill Validation Program 
Narrative: 
Write a data validation program that will validate an electric file and produce a valid 
electric file. 
Input File: 
ELECTRIC-FILE 

Project 
8-9 
Input R e c o r d Layout: 01 ELECTRIC-RECORD-IN. 
05 
EL-ACC0UNT-N0 
05 EL-ACCOUNT-TYPE. 
PIC X(6). 
10 EL-TYPE-CODE 
PIC X. 
PIC XX. 
PIC X. 
PIC X. 
10 EL-CATEGORY-CODE 
10 EL-DEMAND-CODE 
10 EL-TIME-OF-USE-CODE 
05 EL-METER-INFO. 
10 EL-KW-DEMAND-LEVEL 
PIC 9(4). 
10 EL-SERVICE-USED-FROM-DATE 
15 EL-FROM-YEAR 
15 EL-FROM-MONTH 
15 EL-FROM-DAY 
PIC 99. 
PIC 99. 
PIC 99. 
10 EL-SERVICE-USED-TO-DATE. 
15 EL-TO-YEAR 
15 EL-TO-MONTH 
15 EL-TO-DAY 
PIC 99. 
PIC 99. 
PIC 99. 
10 EL-METER-READ-INFO. 
15 EL-CURRENT-READING 
PIC 9(5). 
15 EL-PREVIOUS-READING 
PIC 9(5). 
3 4 2 5 4 5 R R S N 1 0 0 0 0 9 2 0 1 2 3 9 2 0 2 2 2 3 5 7 4 8 3 4 9 5 3 
:2 3 8 9 4 5 C C S X 1 3 46 7 92 0 2 2 1 9 2 0 3 2 2 3 9i08 1 3 4 5 7 6 
6 8 9 3 5 3 R R S N 2 0 0 0 0 9 2 0 1 2 7 9 2 0 2 2 9 0 0 ; 2 3 4 0 1 0 0 2 
4 6 6 5 6 7 C G S S 1 0 0 4 5 9 2 0 2 2 5 9 2 0 3 2 6 4 0 2 4 2 3 2 9 3 4 
U O O O O O C C S I 
1 2 1 9 9 9 2 0 3 1 5 9 2 0 1 1 0 0 2 3 5 7 0 3 4 6 5 
4 6 5 7 5 8 C C S L 2 3 4 5 6 9 1 1 1 3 1 9 1 1 2 1 4 0 0 4 5 6 0 2 3 4 5 
7 6 3 6 4 5 C G S N 1 0 0 0 0 9 2 0 1 2 4 9 2 0 2 1 5 8 3 4 9 3 7 2 4 5 2 
l l l i n R R S N 1 0 1 2 3 9 2 0 2 2 7 9 2 0 2 2 6 0 6 6 7 8 0 5 6 7 8 
4 5 7 6 8 6 C G S M 1 0 5 1 2 9 2 0 2 0 1 9 2 0 3 0 3 3 6 1 3 3 3 5 6 8 8 
4 8 7 6 5 3 C G S N 2 0 0 0 0 9 2 0 2 2 3 9 2 0 3 2 8 0 0 3 8 7 3 7 8 4 6 
2 
2 2 2 2 2 C C S M 2 2 1 9 5 9 6 1 4 3 3 9 2 0 5 3 0 5 6 7 5 4 0 2 4 6 6 
3 3 3 3 3 3 C G S S 1 0 5 5 0 9 1 0 6 2 9 9 1 1 1 1 1 1 2 3 4 4 5 7 57 5 
3 4 9 7 6 6 C G S S 2 0 4 9 9 9 2 0 1 2 2 9 2 0 2 1 6 0 0 3 4 6 6 2 7 4 5 
4 5 6 9 7 7 C G S I 
2 5 5 5 3 9 2 0 3 0 7 9 2 0 3 1 5 0 0 6 4 3 0 3 2 4 5 
4 4 4 4 4 4 C C S S 2 0 0 2 5 9 2 0 1 1 8 9 2 1 4 1 2 3 7 7 4 2 7 5 6 3 8 
,9 4 5 7 6 6 C C S I 1 2 1 4 5 9 2 0 2 2 1 9 2 0 3 2 2 5 
5 4 5 5 4 4 5 4 4 
4 5 7 8 9 7 C G S M 2 0 9 3 7 9 2 0 2 2 5 9 2 0 3 2 2 0 0 4 2 5 0 2 1 4 5 
5 5 5 5 5 5 C C S X 
1 1 5 9 0 9 1 0 8 3 2 9 2 0 6 1 5 1 2 4 2 5 4 7 4 2 6 
4 6 0 6 7 4 C G S M 1 0 7 5 0 9 2 0 1 2 0 9 2 0 2 1 9 3 4 2 3 4 2 1 2 1 2 
I9 0 6 6 5 4 R R S N 2 0 0 0 0 9 2 0 1 1 5 9 2 0 2 
1 4 0 0 3 3 5 0 0 8 5 6 
:5 4 8 6 4 5 C C S L 2 2 1 0 0 9 2 0 3 0 9 9 2 0 3 2 9 0 0 3 6 4 0 4 7 4 2 
i6 6 6 6 6 6 C G S S 1 0 0 0 0 9 2 0 5 3 0 9 1 0 6 3 2 1 2 4 2 4 2 4 2 4 4 
4 8 6 4 6 7 R R S N 1 0 0 0 0 9 1 1 2 3 1 9 2 0 1 3 1 4 5:8 6 7 2 3 7 4 5 
8 5 9 7 3 4 C G S M 2 0 5 0 0 9 2 0 2 
1 8 9 2 0 3 2 0 0 1 3 6 4 0 9 7 3 6 
1 4 6 5 5 7 C G S L 1 2 3 4 5 9 2 0 1 1 8 9 2 0 2 2 2 9 7 2 1 9 9 5 9 8 4 
3 8 7 6 4 3 C C S M 1 1 9 9 9 9 2 0 1 1 7 9 2 0 2 1 0 6 4 5 3 3 4 2 3 4 5 
7 7 7 7 7 7 X X X X 1 2 3 4 5 9 2 1 3 2 8 9 4 1 2 1 2 0 5 3 2 5 0 6 6 4 3 
; 9 8 4 5 4 5 C G S N 1 
9 1 0 9 0 3 9 1 1 0 0 4 9 0 3 0 2 8 9 7 3 4 
:89 5 0 9 8 C G S L 1 2 0 0 0 9 2 0 1 1 6 9 2 0 2 1 9 9 4 2 7 4 8 3 4 2 3 
;5 6 7 4 5 5 C G S X 1 4 2 4 3 9 2 0 1 0 6 9 2 0 2 0 8 4 9 3 2 8 4 5 8 3 4 
3 8 7 4 6 4 C C S M 1 0 5 0 0 9 2 0 2 0 
2 9 2 0 3 0 3 5 8 4 5 3 3 3 8 4 5 
3 4 5 4 5 6 C G S S 1 0 0 3 0 9 1 1 2 0 8 9 2 0 1 0 8 7 3 4 8 7 7 3 4 6 4 

A
p
p
e
n
d
i
x 
G 
— Projects 
463454CGS;L22382920 3(0 192032709)34 7 103 74 
888888CCSJM2031 1910 9)3 592081108(6463643 1 
4 363 5 5CCS|M2 182 19 20 ill 492030108(638 18346 
234557RRSJN 100009202:2 792032517)2 7417234 
CGSJL 25678920 5J3 092052912(34202345 
4 89753CGS|X 12 00 0920 1(1 39202105 3(94739843 
487635CCSJL12001911 1)129201119 4(7 5384653 
7 84567CGSJX 25689910 3J149203310 2J38409549 
84 5 54 3CGS(N200009202il 392032 500)8950 345 3 
3 87 4 5 4CCSiL2 2 003920 111 7 9 2 02 150 1189 3 107 6 3 
999999CGSS1 1 13 09 202139 1 123135215352 18 
223456CCSJM 114569202(2 39203237 8(44673523 
3 4 87 5 6 C C SJX 12 1 5 0 9 1 1 1 1 191 121 17 8164265987 
345464RRSJN2000092013092032200(4580497 5 
6467 5 7CCSJM2 123492030 19 2 03 2 7 0 0i03 002 98 5 
7 58346CGSJX22 1239202(029203 15 10)38400384 
457 46 6CCSJX 23123911 2(129201230 2)7 8818236 
ZZZZZZCGSJN200009602I1 59602 1636(42 6866 3 7 
545465CGSJS 20050910 5(1991062000:02300384 
;3 46768CCSJL143569202J17 9203174 5J98545643 
S59567CC SIX 25574910 720 9108200 4(5 3400454 
R e p o r t L a y o u t : 
Develop your own report layout in compliance with the processing requirements. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of electric records. 
2. Validate each input record field for all of the following: 
a. Account No: 
(1) If the account number is missing, print an appropriate error message: 
Record missing data in ACCOUNT NO field Account Type: RRSN1 
(2) 
If the account number is not missing, then verify that the value is numeric; if 
not, display an error message: 
Nonnumeric ACCOUNT NO for Account No: 123456 
b. Account Type: Verify that the account type is a valid account type. Valid account 
types are RRSN1, RRSN2, CGSN1, CGSN2, CGSS1, CGSS2, CGSM1, CGSM2, 
CGSL1, CGSL2, CGSX1, CGSX2, CCSM1, CCSM2, CCSL1, CGCL2, CGCX1, 
CCSX2; 
Error message: Invalid ACCOUNT TYPE for Account: 123456 Type: XXXXX 
(Hint: Use a condition name test for valid types.) 
c. KW Demand Level: 
(1) Verify that the value is numeric; if not, display an error message: 
Nonnumeric KW DEMAND LEVEL for Account No: 123456 
(2) 
If the k w demand level is numeric, then verify that the value is consistent with 
the demand code in the account type as shown below: 
Demand Code 
KW Demand Level Range 
N 
n/a (0) 
S 
21-499 
M 
500-1999 
L 
2000-9999 
X 
2000-9999 

Project 
9-1 
Error Message: 
Inconsistent DEMAND CODE & DEMAND LEVEL for Account No: 123456 
Demand Code: S Demand Level: 545 
d. Service Used From and To Dates: 
(1) Verify that the from or to month is valid (i.e., 1 thru 12); error message: 
Invalid FROM MONTH for Account No: 123456 Month: 20 
or Invalid TO MONTH for Account No: 123456 Month: 20 
(2) Verify that the from or to day is valid (i.e., cannot exceed the maximum days in 
the corresponding month); error message: 
Invalid FROM DAY for Account No: 123456 Month: 12 Day: 35 
or Invalid TO DAY for Account No: 123456 Month: 12 Day: 35 
(Hint: Use a condition name test for valid months and days.) 
(3) Verify that the from or to year is valid; the year must be either the current or 
previous year; error message: 
Invalid FROM YEAR for Account No: 123456 Year: 95 
or Invalid TO YEAR for Account No: 123456 Year: 95 
(4) If the from or to date is valid, then verify the complete date (year, month, and 
day) against today's date; error message: 
Invalid FROM DATE for Account No: 123456 Mon: 05 Day: 31 Yr: 95 
or Invalid TO DATE for Account No: 123456 Mon: 05 Day: 31 Yr: 95 
(5) Verify that the from date is prior to the to date; error message: 
FROM DATE is not prior to TO DATE for Account No: 123456 
Current Date: 920325 Previous Date: 920220 
e. Current and Previous Readings: Verify that the value is numeric; if not, display an 
error message: 
Nonnumeric CURRENT READING for Account No: 123456 Current Reading: 
346C4 
or Nonnumeric PREVIOUS READING for Account No: 123456 Previous Reading: 
346C4 
3. Any record that fails any validity test is to be rejected with no further processing, other 
than displaying or printing the appropriate error message(s). It is possible that a 
record may contain more than one error (all errors are to be flagged except where 
noted). 
4. Valid records are to be written to a file to be used in Projects 9-9, 16-5, and 17-7. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Doctor Visits Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-1 as input and produces 
a report as output. 
Input File: 
VALID-ORDER-TRANSACTION-FILE 
Input Record Layout: 
Identical to the output record of Project 8-1. 

Appendix 
G 
Projects 
Test Data: 
Use the output file of valid records created in Project 8-1 as input. 
Report Layout: 
Design your own report layout, subject to the processing requirements. 
Processing Requirements: 
1. Read a file of valid order records. 
2. Write an appropriate heading at the top of each page showing the date the report was 
run and page number. 
3. Write a detail line for each order showing all of the information in the input record. 
Print 5 records per page. 
4. Write a total line to print the total number of records. 
Program Name: 
Stock Transactions Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-2 as input and produces 
a report as output. 
Input File: 
STOCK-TRANSACTION-FILE 
i n p u t nevuru i ^ i y u u K i 
f u c n u c a i tu u to UUIJJUI tccui u ui n u j o u i o-<i. 
Test Data: 
Use the output file of valid records created in Project 8-2 as input. 
Report Layout: 
We Make U Money, Inc. 
Stock Activity Report as of MM/DD/YY 
Page Z9 
Purchase Info 
Sell Info 
Profit 
/ Loss 
Stock 
Shares 
Date 
Price/Share 
Total 
Date 
Price/Share 
Total 
Profit 
/ Loss 
XXXXXXXXXXXXXX 
ZZ9 
MM/DD/YY ZZ.ZZ9.99 
ZZZ.ZZ9.99 MM/DD/YY ZZ.ZZ9.99 ZZZ.ZZZ9.99 
— ,--9.99 
Totals 
1,7.19 
Z.ZZZ.ZZ9.99 
Z.ZZZ.ZZ9.99 -, — .-9.99 
Processing Requirements: 
1. Read a file of valid stock records. 
2. Write the appropriate headings showing the date and page number. 
3. For each record read: 
a. Calculate the 
(1) total purchase by multiplying the number of shares by the purchase price 
per share. 

Project 
9-3 
(2) total sale by multiplying the shares by the selling price per share. 
(3) profit/loss by subtracting the total purchase from the total sale. 
b. String the record's purchase and sale date into a month, day, and year format. 
c. Write a detail line for every transaction; print 4 transactions per page. 
4. Write totals as shown in the report layout after all records are processed. 
Program Name: 
Payroll Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-3 as input and produces 
a report as output. 
Input File: 
PAYROLL-FILE 
Input Record Layout: 
Identical to the output record of Project 8-3. 
Test Data: 
Use the output file of valid records created in Project 8-3 as input. 
Report Layout: 
HardWorkers of America as of mm/dd/yy 
Page 19 
Name 
Gross Pay 
Taxes Insurance 
Net Pay 
last 
name, first 
name 
$$$,$$9.99 
$$$9.99 
$$$9.99 
$$$,$$9.99 
• 
$$$$,$$9.99 $1 
^,$$9.99 $$,$$9.99 $ $$$,$$9.99 
Processing Requirements: 
1. Read a file of valid payroll records. 
2. Write the appropriate headings showing the date and page number. 
3. For each input record read: 
a. Calculate the gross pay as: 
(1) Straight time for the first 40 hours worked 
(2) Time and a half for hours worked over 40 
Note: Salaried workers DO NOT get overtime. 
b. Calculate the deductions: 
(1) Federal withholding tax is based on the gross pay. 
(a) 18% on the first $400 
(b) 23% on amounts over $400 and up to $600, inclusive 
(c) 25% on amounts over $600 
(2) 
FICA is 6.2% of the gross pay. 

Appendix 
G — 
Projects 
(3) 
Insurance as indicated below depending on the Plan Type. 
Plan 
Amount Deducted 
A 
$5 
B 
$8 
C 
$10 
Z 
$0 (no insurance) 
c. Calculate net pay by subtracting all of the deductions (tax, FICA, and insurance) 
from the gross pay. 
d. Write a detail line for each employee. String the name as shown in the report layout. 
Print only 5 employees per page. 
4. Write totals as shown on the report layout after ten records have been processed. 
Program Name: 
Car Sales Commissions Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-4 as input and produces 
a report as output. 
Input File: 
CAR-SALES-FILE 
Input Record Layout: 
Identical to the output record of Project 8-4. 
Test Data: 
Use the output file of valid records created in Project 8-4 as input. 
Report Layout: 
Very Very Nice Cars, Inc. 
Page Z9 
Commission Report MM/DD/YY 
Salesperson 
Date 
Car 
Sale 
Commi ssion 
Net 
XXXXXXXXXX 
MM/DD/YY
 
1YY XXXXXXXXXXXX 
111,119 
111,119 
111,119 
1,111,11% 1,111,119 1,111,119 
Processing Requirements: 
1. Read a file of valid car sales records. 
2. Write the appropriate headings showing the current date and page. 
3. For each record read: 
a. Calculate the commission paid to the salesperson by multiplying the commission 
rate by the sale amount. 

Project 
9-6 
b. Calculate the net to the company by subtracting the commission paid from the 
sale amount. 
c. Write a detail line, printing 8 sales per page. Use reference modification to show 
only the last two digits in the car year on the report line. 
4. Write totals as shown on the report layout after all the records have been processed. 
P r o g r a m N a m e : 
Invoice Mailing Labels Program 
N a r r a t i v e : 
This program accepts the valid output file produced by Project 8-5 as input and produces 
a mailing label as output. 
I n p u t F i l e : 
INVOICE-FILE 
I n p u t R e c o r d L a y o u t : 
Identical to the output record of Project 8-5. 
T e s t D a t a : 
Use the output file of valid records created in Project 8-5 as input. 
R e p o r t L a y o u t : 
Scully 
Schultz 
20 Main St 
45 5th St 
Chicago, IL 60666 
Los Angeles, CA 90024 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of valid invoice records. 
2. For each input record read create a mailing label. 
a. String the city, state, and zip as shown in the report layout. 
b. Print the labels in two columns as shown in the report layout. 
P r o g r a m N a m e : 
Student Record Report Program 
N a r r a t i v e : 
This program accepts the valid output file produced by Project 8-6 as input and produces 
a report as output. 
I n p u t F i l e : 
STUDENT-FILE 
I n p u t R e c o r d L a y o u t : 
Identical to the output record of Project 8-6. 
T e s t D a t a : 
Use the output file of valid records created in Project 8-6 as input. 

Appendix 
6 
Projects 
Report L a y o u t : 
Smart U 
Student Aid Report 99/99/99 
Page Z9 
StudentID 
Credit 
Total 
Name 
School 
Aid Hours Tuition 
Total 
Aid 
Tuition 
Due 
999999999 XXXXXXXXXXXXXXX 
XXX 
X 
Z9 
111,219 
111,119 
111,119 
119 1,111,119 1,111,119 2,111,119 
P r o c e s s i n g Requirements: 
1. Read a file of valid student records. 
2. Write appropriate headings showing the current date and page number. 
3. For each input record read: 
a. Calculate total tuition based on $300 per credit. 
b. Calculate total aid based on the GPA as follows: 
G P A 
% Aid 
2.5 to 3.0 
60% 
3.1 to 3.5 
70% 
3.6 to 4.0 
80% 
c. Calculate the tuition due by subtracting the total aid from the total tuition. 
d. Write a detail line with the information shown on the report layout, printing 10 
students per page. 
4. Write the totals shown on the report layout after all the records have been processed. 
Program Name: 
Salary Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-7 as input and produces 
a report as output. 
Input File: 
SALARY-FILE 
Input Record Layout: 
Identical to the output record of Project 8-7. 

Project 
9-8 
Test Data: 
Use the output file of valid records created in Project 8-7 as input. 
Report Layout: 
Develop your own report layout in compliance with the processing requirements. 
Processing Requirements: 
1. Read a file of valid salary records. 
2. Write an appropriate heading showing the current date and page number. 
3. For each input record read write a detail line showing all of the information in the 
record. Print 10 employees per page. 
4. Write a total for the salary amounts after all records have been processed. 
Program Name: 
Stock Purchases Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-8 as input and produces 
a report as output. 
Input File: 
STOCK-FILE 
Input Record Layout: 
Identical to the output record of Project 8-8. 
Test Data: 
Use the output file of valid records created in Project 8-8 as input. 
Report Layout: 
Stock Purchases 
day of Week MM/DD/YY 
Page Z9 
Name 
Exchange 
Shares 
Price 
XXXXXXXX 
XXX 
1,119 
$ZZ9.999 
Total 
$ZZ,ZZ9.99 
ZZ.ZZ9 
$ZZZ,ZZ9.99 
Processing Requirements: 
1. Read a file of valid stock records. 
2. Write an appropriate heading, showing the page, day of week, and current date. 
3. For each input record read: 
a. Calculate the total by multiplying the shares to buy by the stock price. 
b. Write a detail line showing all of the information on the report layout, printing 10 
stocks per page. 
4. When all the records are processed, print totals as shown on the report layout. 

A
p
p
e
n
d
i
x 
G — 
Projects 
Program N a m e : 
Electricity Bill Report Program 
Narrative: 
This program accepts the valid output file produced by Project 8-9 as input and produces 
a report as output. 
I n p u t F i l e : 
ELECTRIC-FILE 
I n p u t R e c o r d L a y o u t : 
Identical to the output record of Project 8-9. 
T e s t D a t a : 
Use the output file of valid records created in Project 8-9 as input. 
R e p o r t 
L a y o u t : 
BRIGHT POWER & LIGHT 
RESIDENTIAL KILOWATT USAGE 
PAGE Z9 
ACCOUNT INFO 
SERVICE USED 
METER READINGS 
TOTAL 
ESTIMATED 
KILOWATT 
BILL 
NUMBER 
TYPE 
FROM 
TO 
PREVIOUS 
CURRENT 
HRS USED 
999999 
XXXXX 
MM/DD MM/DD 
11,119 
11,119 
11,119 
1,119.99 
111,119 
ZZ.ZZ9.99 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of valid electric records. 
2. Write an appropriate heading showing the page number. 
3. For each input record read: 
a. If the account category is residential: 
(1) Calculate the total kilowatt hours used by subtracting the previous reading 
from the current reading. 
(2) Calculate an estimated bill: 
The first 750 kw hours used will be charged at 3.9220 per kw hour. 
Additional kw hours used will be charged at 4.9220. 
b. Print a detail line showing the information in the report layout. 
4. Write the totals shown on the report layout after all records have been processed. 
P
R
O
G
R
A
M
M
I
N
G 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
ORDER TRANSACTIONS, STOCK TRANSACTIONS, PAYROLL, CAR SALES COMMISSIONS, INVOICE MAILING 
LABELS, STUDENT RECORD, SALARY, STOCK PURCHASES, AND ELECTRICITY BILL 

Project 
11-1 
Narrative: 
These projects combine the requirements of projects 8-1 through 8-9 and 9-1 through 
9-9 as presented earlier in Chapters 8 and 9. The fields in each incoming record 
transaction are accepted and validated one at a time, after which the necessary 
computations are done and the report is displayed on the screen. 
Test Data: 
Screen Layout: 
Processing Requirements: 
Use one or more records from the original data in Chapter 8. 
Design your own input and output screen layout (based on the record layout in projects 
8-1 through 8-9 and report layout in projects 9-1 through 9-9). 
1. Display a screen to input and validate a record, repeating the appropriate validations 
in the corresponding projects in Chapter 8. 
2. Display the calculated information from the corresponding projects in Chapter 9 on 
the screen. 
3. Optional: write the validated input records to a file after displaying it on the screen. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Employee Profiles 
organizations, which compare individuals with similar skills to one another. (The project is 
expanded to include material on table lookups in Project 12-1 at the end of the next 
chapter.) 
Input File: 
EMPLOYEE-FILE 
Input Record Layout: 
05 
05 
05 
05 
05 
01 
EMPLOYEE-RECORD. 
05 EMP-SOC-SEC-NUMBER 
PIC X(9). 
EMP-NAME-AND-INITIALS 
PIC X(16). 
EMP-DATE-OF-BIRTH. 
10 EMP-BIRTH-MONTH 
PIC 99. 
10 EMP-BIRTH-YEAR 
PIC 99. 
EMP-DATE-OF-HIRE. 
10 EMP-HIRE-MONTH 
PIC 99. 
10 EMP-HIRE-YEAR 
PIC 99. 
EMP-SEX 
PIC X. 
EMP-SALARY-DATA OCCURS 3 TIMES. 
10 EMP-SALARY 
PIC 9(5). 
EMP-SALARY-TYPE 
PIC X. 
EMP-SALARY-DATE. 
15 EMP-SALARY-MONTH 
PIC 99. 
15 EMP-SALARY-YEAR 
PIC 99. 
EMP-SALARY-GRADE 
PIC 9. 
05 
EMP-TITLE-DATA. 
10 EMP-TITLE-C0DE 
PIC XX. 
10 EMP-TITLE-DATE. 
15 EMP-TITLE-MONTH 
PIC 99. 
15 EMP-TITLE-YEAR 
PIC 99. 
05 EMP-L0CATI0N-C0DE 
PIC 99. 
05 EMP-EDUCATI0N-C0DE 
PIC 9. 
10 
10 
10 

T e s t D a t a : 
Appendix 
G — 
Projects 
1 0 0 0 0 0 0 0 0 D 0 E 
2 0 0 0 0 O 0 0 O W I L C O X 
4 0 0 0 0 0 0 0 0 L E V I N E 
5 0 0 0 0 0 0 0 O S M I T H E R S 
6 0 0 0 0 0 0 0 Q S U P E R P R O G 
7 0 0 0 0 0 0 0 0 - L E E 
8 0 0 0 0 0 0 0 0 P E R S N I C K E T Y 
9 0 0 0 0 0 0 0 O i M I L G R O M 
J 
1 2 4 4 0 9 9 1 M 3 3 0 0 0 M 0 9 9 2 3 3 1 5 0 0 H 0 9 9 1 3 
3 5 0 9 9 1 104; 
P A 1 0 5 8 1 1 9 1 M 2 9 0 0 0 M 1 1 9 2 2 2 7 5 O 0 H 1 1 9 1 2 
3 5 1 1 9 1 1 0 4 ; 
S 
0 1 5 0 0 8 9 0 F 3 1 0 0 0 M 0 8 9 2 2 2 9 0 0 0 M 0 8 9 1 2 2 8 0 0 0 M 0 2 9 1 2 3 2 0 8 9 0 1 0 4 J 
M 
0 3 5 0 0 1 7 2 M 4 8 0 0 0 M 0 8 9 2 7 4 5 5 0 0 M 0 8 9 1 7 4 0 0 0 0 M 0 8 8 9 4 2 8 0 5 8 8 2 0 4 
S 
0 4 5 7 1 0 9 1 F 5 9 0 O O H 1 O 9 1 6 
5 0 1 0 9 1 1 0 6 
B 
1 0 5 3 0 2 7 7 F 4 0 0 0 O P 0 5 9 2 8 3 7 5 O 0 M 0 2 9 1 8 3 5 O 0 O M 0 2 9 0 7 4 0 ; 0 5 8 9 4 0 5 
P 
0 8 5 5 0 3 9 2 M 2 5 6 0 O H 0 3 9 2 3 
5 0 0 3 9 2 3 0 6 : 
M B I 15 50 9 8 9 F 3 2 0 0 0 M 1 19 2 3 2 9 0 00M0 5 9 1 2 2 7 5 0 0 M 0 5 8 9 13 2 1 1 8 9 1 0 3 ; 
R e p o r t L a y o u t : 
The report below shows required information and illustrative calculations for A. B. Jones. 
Print your report according to these general specifications, but do not be concerned 
about exact line and column positions on a page. (See item 2b in the processing 
requirements for additional guidelines.) 
PERSONNEL PROFILE 
NAME: JONES A.B. 
S0C-SEC-N0 
AGE: 
21.4 YEARS 
HIRE DATE: 
: 123-45-6789 
1/91 
SALARY 
DATE TYPE % INC. MBI RSI 
GRADE 
MIDPOINT % MIDPOINT 
$24,200 7/94 
P 
10.0 
6 20.0% 
4 
$28,000 
86.4 
$22,000 1/94 
M 
10.0 
12 10.0% 
3 
$21,000 
104.7 
$20,000 1/93 H 
3 
$21,000 
95.2 
Processing Requirements: 
1. Read a file of employee records. 
2. For every record read: 
a. Compute and print the employee's age, using the date of birth and date of 
execution. (The age calculation will be approximate, as the input birth date contains 
only the month and year.) 
b. Print all indicated fields with appropriate editing. Print three employees per page; 
leave six blank lines between employees. 
c. Print all associated salary information as described in items 3-6. 
3. Each employee has a salary history with 1, 2, or 3 levels of salary data, denoting 
present, previous, and second previous salary, respectively. Not every employee will 
have all three salaries indicated, but every employee must have a present salary. 
4. Associated with every salary is a salary grade, indicative of the level of responsibility in 
the company (for example, the janitor and president might have grade levels of 1 and 
9, respectively). Each grade has an associated average salary, or midpoint. The 
salary midpoint is computed by multiplying the grade by $7,000. The percent of grade 
midpoint is found by dividing the salary by the grade midpoint and multiplying by 100. 
5. Associated with every pair of salaries are three fields: percent salary increase, months 
between increase (MBI), and annual rate of salary increase (RSI). 

Project 
11-2 
Program Name: 
Input File: 
Input Record Layout: 
Test Data: 
Report Layout: 
a. Percent salary increase is found by subtracting the old salary from the new salary, 
dividing by the old salary, and multiplying by 100. For example, new and old 
salaries of $22,000 and $20,000 yield a percent increase of 10%. 
b. Months between increase (MBI) is simply the number of months between the two 
salary dates. 
c. Annual rate of salary increase (RSI) is computed by converting the percent salary 
increase to a 12-month basis; for example, 10% after 6 months is equivalent to an 
annual rate of 20%; 10% after 2 years is an annual rate of 5%. 
6. Calculate percent salary increase, MBI, and RSI for each pair of salaries as appropriate. 
Realize, however, that not every employee will have all three salary levels, and hence 
the calculations cannot be made in every instance. Use an OCCURS clause, subscripts, 
and a PERFORM VARYING statement to do the calculations. Be sure to include a 
suitable test to avoid the computation if historical data are not present. 
Benefit Statement 
their annual salaries. Accordingly, benefit statements are often prepared to remind 
employees how well (their employer thinks) they are being treated. Develop a program to 
read a file of confidential employee data and to compute and print the fringe benefits for 
each employee. 
EMPLOYEE-FILE 
Use the same record layout as for Project 11-1. 
Use the same test data as for Project 11-1. 
Retirement Benefit 
COMPANY CONTRIBUTES: $$$,$$9 INTEREST RATE: .99 AMT AT AGE 65: $$,$$$,$$9  
Life Insurance = $$$$,$$9 
Employee Benefit Statement 
NAME: XXXXXXXXXXXXXXX 
ANNUAL SALARY: $$$,$$9 
BIRTH DATE: 99/99 
HIRE DATE: 99/99 
WEEKS AT FULL PAY: Z9 
Sick Pay Benefit 
WEEKS AT HALF PAY: Z9 
Processing Requirements: 
1. Read a file of employee records, preparing an individual benefit statement for every 
record. Each individual statement is to appear on a separate page. 

Appendix 
G 
Projects 
2. For every record read: 
a. Calculate the retirement benefit based on an annual company contribution for each 
employee. The contribution is equal to 5% of the first $15,000 of salary plus 3% on 
any salary in excess of $15,000. Hence the company would contribute $840 
annually for an employee earning $18,000 (5% of 15,000 = 750, plus 3% of 3,000 = 
90). The money is invested for the employees and assumed to earn 8% annually. 
Use the following formula: 
Amount at age 65 = 
-
i 
where / = interest rate (for example, .08) and n = years until age 65 (specify the 
ROUNDED option of any arithmetic statement used in computing n). 
b. Calculate the life insurance benefit as twice an employee's annual salary if the 
employee earns $23,000 or less; it is three times the annual salary for those earning 
more than $23,000. 
c. Calculate the amount of sick pay, which is dependent on the individual's length of 
service. An employee is entitled to one week of full pay and an additional two 
weeks of half pay, for every year (or fraction thereof) of employment. The maximum 
benefit, however, is 10 weeks of full salary and 20 of half salary, which is reached 
after 10 years. (An employee with two years' service, for example, is entitled to two 
weeks full pay and an additional four weeks of half pay.) 
d. Use the individual's present salary, EMP-SALARY (1), in all benefit calculations. 
Program Name: 
Evaluation of Student Curriculum Records 
Narrative: 
This project builds on Project 3-5. Write a program using table handling to evaluate a 
student's curriculum record and determine the percentage of courses a student has left 
in order to graduate, the percentage of courses a student has transferred, the percentage 
of courses for which a student has been awarded proficiency credit, and the percentage 
of courses a student has completed. Print the names of students who are close to 
graduation and the courses they have left to complete. Project 3-5 limits a student to 10 
courses in their curriculum. This project allows for as many courses as needed. 
Input File: 
STUDENT-CURRICULUM-FILE 
Input Record Layout: 
Student Curriculum Record 
Student Id Number 
Course Number 
Grade 
1 ... 5 
6 
... 12 
13 

Project 
1 1 -3 
Test Data: 
Report Layout: 
Use the same report layout as in Project 3-5. Add editing where appropriate. Add the 
remaining courses to complete for a student who is near graduation (see specifications) 
using an appropriate format. 
Processing Requirements: 1. Read a file of student curriculum records. 
2. Dynamically load a table containing all the student curriculum records for one student. 
3. Once all records for one student are loaded into the table: 
a. Add the total number of courses (course name, not spaces) for each student. 
b. Add the total number of courses where the student was awarded a grade (A, B, C, 
or D), proficiency credit (P), or transfer credit (K). 
c. Add the total number of courses where the student was awarded transfer credit (K). 
d. Add the total number of courses where the student was awarded proficiency credit 
(P). 
e. Determine the percentages of courses left in order to graduate, courses completed, 
courses transferred, and courses awarded proficiency credit. 
f. Print student id number and the percentages of courses left to graduate, courses 
completed, courses transferred, and courses awarded proficiency credit. 
g. If the student has less than 20% of courses left in order to graduate, print the 
courses the student has not completed. 
1 2 3 4 5 C 0 M P 1 1 0 A 
1 2 3 4 5 E N G L 1 10 
1 2 3 4 5 M A T H 1 4 8 K 
1 2 3 4 5 M A T H 1 6 8 P 
1 2 3 4 5 C I S 1 5 0 
F 
1 2 3 4 5 C I S 2 3 0 
1 2 3 4 5 P S Y C 1 0 5 B 
12 3 4 5 B U S N 1 10A 
1 2 3 4 5 H U M N 4 1 0 P 
1 2 3 4 5 H U M N 4 2 0 A 
3 4 5 6 7 E N G L 1 I O C 
3 4 5 6 7 E N G L 1 2 0 
3 4 5 6 7 M A T H 0 4 8 C 
3 4 5 6 7 MATH2 10D 
3 4 5 6 7 C I S 2 3 0 A 
3 4 5 6 7 C I S 3 3 0 
7 8 9 2 1 B U S N 1 1 0 
7 8 9 2 1 B U S N 1 2 0 
7 8 9 2 1 E N G L 1 10A 
7 8 9 2 1 E N G L 1 2 0 P 
7 8 9 2 1 M A T H 0 4 8 K 
7 8 9 2 1 M A T H 1 6 8 B 
7 8 9 2 1 M A T H 2 2 0 
4 7 8 3 0 S P C H 2 7 5 A 
4 7 8 3 0 E N G L 1 1 0 
.4 7 8 3 0 A C C T 2 0 5 A 
4 7 8 3 0 A C C T 2 1 0 P 
4 7 8 3 0 A C C T 3 4 7 K 

Appendix 
G 
Projects 
P r o g r a m N a m e : 
Computer Status Report 
Narrative: 
This program will create an individual status report for each record in the file. When all the 
records have been processed, print a summary report showing totals for each status. 
(The project is expanded to include material on table lookups in Project 12-4 in the next 
chapter.) 
I n p u t F i l e : 
COMPUTER-FILE 
I n p u t R e c o r d L a y o u t : 
01 COMPUTER-RECORD. 
05 COM -INVOICE-NO 
PIC 9(5). 
05 C0M--CUSTOMER-NAME 
PIC X(18) 
05 C0M--PAYMENT-METHOD 
PIC XX. 
05 C0M- SHIP-INFO. 
10 COM-SHIP-STATUS 
PIC X. 
10 COM-SHIP-CHARGE 
PIC 99V99 
05 C0M- COMPONENT-INFO. 
10 C0M-NO-COMP0NENTS 
PIC 9. 
10 C0M-C0MP0NENTS OCCURS 1 TO 4 TIMES 
DEPENDING ON C0M-N0- COMPONENTS. 
15 C0M-C0MP0NENT 
PIC X(12) 
15 C0M-C0ST 
PIC 9(4). 
T e s t 
D a t a : 
1 2 8 3 4 B 1 a n c o , 
E r i ck 
7 9 8 4 5 C a s a l i , 
J o s e p h 
5 9 7 8 9 D a v i s , 
K e v i n 
8 5 7 7 8 D e m l e r , 
L i n d a 
4 7 5 9 7 E C h a v a r r i a , 
F e l i p e C K 2 6 5 0 0 2 4 8 6 
5 8 6 8 4 F 1 e m m i n g , 
S h a r o n 
M C 1 4 5 0 0 2 4 2 5 
4 8 5 7 7 G o n z a l e z , 
M a r i a 
5 6 7 4 9 K a t a n , 
M a h a r a n 
9 5 8 7 7 P a r m e n t e r , 
D o n i t a 
3 8 4 7 6 P i n k w a s s e r , 
R a n d i 
3 7 5 8 6 S t e w . a r t , 
R o b e r t o 
A M 1 4 5 5 0 2 4 8 6 
33MHz 
A M 3 7 5 0 0 2 3 8 6 
33MHz 
V I 1 6 5 5 0 2 4 8 6 
33MHz 
C 0 3 8 0 2 5 4 3 8 6 
33MHz 
33MHz 
2 3 7 9 T a p e 
BU 
250 
N o t e b o o k 2 3 9 5 D o - t 
M a t r i x 
V I 1 3 5 0 0 3 4 8 6 D X 2 
5 0 M H z 2 2 9 5 M o d e m / F A X 
C K 2 4 5 0 0 1 3 2 5 
N o t e b o o k l 8 9 5 
C 0 3 3 5 0 0 2 4 8 6 
25MHz 
1 9 9 5 C D / R 0 M 
V I 3890:044860X2 
66MHz 299 5 9 6 0 0 
Modem 
CK250 0 0 2386 
2 5MHz 
1 2 9 5 F A X 
1 9 9 5 2 4 0 0 
Modem 
0099 
1 5 9 5 L a s e r 
P r i n t r l 3 9 9 T a p e 
BU 120 
0189 
2 0 9 5 L a . s e r 
P r i t n r l 3 9 9 
2 0 4 9 0 o t 
M a t r i x 
0 1 6 9 C o p r o c e s s o r 
0 0 9 9 M o d e m / F A X 
02 50 
0169 
0 1 1 9 S o u n d 
B l s t r 
0139 
0119 
0 3 4 5 
0 2 9 9 D o t 
1279 
M a t r i x 
0 1 6 9 ' S o u n d 
B l s t r 
0 1 3 9 

Project 
114 
Report Layout: 
FLY BY NITE COMPUTERS, INC. 
STATUS REPORT 
INVOICE #: XXXXX 
STATUS: X 
CUSTOMER NAME: XXXXXXXXXXXXXXXX 
PAYMENT METHOD: XX 
COMPONENT 
COST 
XXXXXXXXXXXX 
$$,$$9.99 
SUBTOTAL 
$$$,$$9.99 
SHIPPING CHARGES 
$$$9.99 
TOTAL 
$$$,$$9.99 
FLY BY NITE COMPUTERS, INC. 
SUMMARY BY STATUS 
STATUS 
ITEMS 
SHIP CHARGES 
COST 
1 
Z9 
$$,$$9.99 
$$,$$9.99 
2 
Z9 
$$,$$9.99 
$$,$$9.99 
3 
Z9 
$$,$$9.99 
$$,$$9.99 
TOTAL 
ZZ9 
$$,$$9.99 
$ $$,$$9.99 
Processing Requirements: 
1. Read a file of customer records. 
2. For each record read: 
a. Print the report for each customer on a separate page; print headings as shown on 
the report layout. 
b. Process each component ordered by 
(1) Printing a detail line as shown on the report layout. 
(2) Incrementing the cost totals for that customer. 
c. When all items for one customer have been processed: 
(1) Calculate the customer total by adding the shipping charges to the cost totals. 
(2) Print the customer total lines as shown in the report layout. 
d. Increment the appropriate status in the summary table with the above information. 
3. After all records have been read, print the a summary table showing totals for each 
status (as shown on the report layout). 

Appendix 
G — 
Projects 
Program Name: 
Credit Report 
Narrative: 
This program produces a credit report for store accounts. The store offers three types of 
accounts: 20, 40, or 60; a customer may have one of each. The report will show detail 
lines for each type of account for each customer. The last page is a summary of 
payments, purchases, interest charged, and current balance by account type. 
Input File: 
CREDIT-FILE 
Input Record Layout: 01 CREDIT-RECORD. 
05 CR-ACC0UNT-N0 
PIC 9(7). 
05 CR-NAME-AND-INITIALS 
PIC X(18). 
05 CR-N0-0F-ACC0UNTS 
PIC 9. 
05 CR-TRANSACTIONS OCCURS 1 TO 3 TIMES 
DEPENDING ON CR-N0-0F-ACC0UNTS. 
10 CR-TYPE 
PIC 99. 
10 CR-BALANCE 
PIC 9(4)V99. 
10 CR-PAYMENT 
PIC 9(4)V99. 
10 CR-PURCHASES 
PIC 9(4)V99. 
Test Data: 
1 2 3 4 5 2 0 S T U T Z , 
J D 
1 9 5 7 6 2 0 F R 0 S T , 
RD 
2 9 4 7 6 6 0 B A R B E R , 
MM 
3 8 5 6 7 4 0 G O L D S M I T H , 
KN 
4 2 0 9 5 4 0 G R A U E R , 
RG 
4 9 0 8 5 6 0 P L A N T , 
R K 
57 4 8 9 2 0 E L 0 F S 0 N , G S 
6 8 4 7 6 6 0 S T E W A R T , J B 
7 4 5 7 6 2 0 G I L L E N S 0 N , 
ML 
8 4 6 6 7 4 0 R U S H I N E K , 
S F 
9 4 3 6 5 6 0 V A Z Q U E Z 
V I L L A R , 
1 2 0 0 5 8 6 0 0 0 3 4 3 0 0 0 4 5 4 4 4 
• 
. 
! 
1 4 0 0 4 5 3 4 5 0 5 0 0 0 0 0 0 5 0 5 5 
j 
3 2 0 0 2 3 3 9 0 0 1 0 0 0 0 0 0 9 5 4 5 4 0 0 4 7 5 3 4 0 3 1 5 0 0 0 3 4 2 1 2 6 0 2,3 34 1 2 2 3 3 4 1:2 0 4 3 3 3 2: 
2 4 0 0 2 3 4 3 4 0 1 2 3 3 4 0 3 4 3 2 3 6 0 3 4 2 3 3 0 3 6 2 3 3 0 0 0 5 4 4 3 
3 2 0 0 3 4 2 2 2 0 2 3 4 2 2 1 8 5 3 4 4 4 0 0 6 3 4 4 4 0 3 0 0 0 0 0 3 4 3 3 2 6 0 5:5 6 4 1 2 0 3 4 2 12 0 6 4 5 2 3J 
2 2 0 0 3 4 3 0 0 0 3 4 3 0 0 0 2 2 3 2 3 6 0 0 4 3 4 0 0 0 5 0 0 0 0 0 0 0 0 0 0 
j 
2 4 0 0 8 6 4 0 0 0 5 6 4 0 0 0 3 4 2 2 3 6 0 6 7 5 4 0 0 3 7 5 4 0 0 0 4 5 3 3 4 
I 
1 6 0 0 5 5 6 0 0 0 0 5 6 0 0 1 6 4 5 4 3 
1 4 0 0 6 5 5 1 3 0 0 5 5 1 3 0 3 5 4 3 4 
• 
2 2 0 0 4 5 3 3 4 0 0 5 0 0 0 1 2 3 4 3 4 6 0 0 7 4 5 5 4 0 8 4 5 5 4 0 4 5 3 3 4 
| 
C 
3 2 0 0 4 5 3 4 5 0 5 0 0 0 0 0 0 3 4 4 5 4 0 0 : 6 5 6 6 6 0 6 5 0 0 0 0 0 4 5 5 0 6 0 0 : 5 4 6 5 6 0 4 4 6 5 6 0 4 3 5 3 4 1 
Report Layout: 
NEEDLESS MARKUP STORES ACCOUNT CREDIT REPORT 
ACCOUNT # 9999999 
NAME: XXXXXXXXXXXXXXXXXX 
TYPE 
PREVIOUS 
BALANCE 
INTEREST 
PAYMENT PURCHASES 
CHARGE 
99 
Z.ZZ9.99 
99 
Z.ZZ9.99 
99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
ZZ9.99 
ZZ9.99 
ZZ9.99 
CURRENT 
BALANCE 
Z.ZZ9.99CR 
Z.ZZ9.99CR 
Z.ZZ9.99CR 
PAGE Z9 
CREDIT AVAILABLE 
LIMIT 
CREDIT 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
Z.ZZ9.99 
TOTALS 
ZZ.ZZ9.99 ZZ.ZZ9.99 Z.ZZ9.99 ZZ.ZZ9.99CR 

Project 
11-5 
NEEDLESS MARKUP STORES ACCOUNT TYPE SUMMARY 
TYPE 
INTEREST 
CURRENT 
PAYMENT 
PURCHASES 
CHARGE 
BALANCE 
20 
Z.ZZ9.99 
Z.ZZ9.99 
ZZ9.99 
Z.ZZ9.99CR 
40 
Z.ZZ9.99 
Z.ZZ9.99 
ZZ9.99 
Z.ZZ9.99CR 
60 
Z,ZZ9.99 
Z.ZZ9.99 
ZZ9.99 
Z.ZZ9.99CR 
TOTALS 
ZZ.ZZ9.99 
ZZ.ZZ9.99 Z.ZZ9.99 
ZZ.ZZ9.99CR 
Processing Requirements: 
1. Read a file of credit records. 
2. Develop a page heading routine which prints 5 accounts on every page. 
3. For each record read: 
a. Print the appropriate account headings. 
b. Process each account type by 
(1) Calculating the monthly interest charge on the account based on the account 
balance after the payment has been applied. ( To make life a lot easier, use 
simple interest and a rate of 18.5%.) 
(2) Calculating the current balance by adding the interest charge and purchases 
and subtracting the payment. (Note: a customer could overpay the account, 
therefore you should remember to make the field signed and display it as such 
on the report as shown in the report layout or as desired.) 
(3) Determining the credit limit for each account as follows: 
Type 
Credit Limit 
20 
$1,500 
40 
$3,500 
60 
$5,000 
(4) Calculating the available credit on the account by subtracting the current 
balance from the credit limit determined in (3). 
(5) Printing a detail line as shown on the report layout. 
(6) Incrementing the appropriate totals. 
c. When all accounts for one customer have been processed, print the total lines as 
shown in the report layout. 
d. Increment the appropriate account type in the summary table with the above 
information. 
4. After ail records have been read, print a summary table showing totals for each 
account type (as shown on the report layout). 

A
p
p
e
n
d
i
x 
G — 
Projects 
Program Name: 
Software Cost Analysis 
Narrative: 
The program will determine the following: 
1. The break-even units and revenue for each software product. 
2. The break-even units and revenue for each software product if a $50,000 profit is 
desired. 
3. The break-even units and revenue for each software product if the selling price is 
reduced by 25%. 
Input File: 
SOFTWARE-FIL 
Input Record Layout: 01 SOFTWARE-RECORD. 
05 SOFT-PROGRAM-INFO. 
10 SOFT-PRODUCT-LINE 
10 SOFT-PRODUCT-NO 
10 SOFT-PROGRAM-NAME 
05 SOFT-VARIABLE-COSTS. 
10 S0FT-PREP-C0STS. 
15 S0FT-L0ADING-PF.R-DISK 
15 SOFT-NO-DISKS-USED 
10 SOFT-MANUAL-PRINTING 
10 SOFT-SHIPPING-N-HANDLING 
05 SOFT-SELL-PRICE 
05 SOFT-FIXED-COST 
PIC X. 
PIC 9(4). 
PIC X(18), 
PIC 9V99. 
PIC 99. 
PIC 99V99. 
PIC 99V99. 
PIC 999V99. 
PIC 9(5). 
Test Data: 
G46 9 5 F 1 i g h t 
S 
B 3 7 6 4 W o r c f P e r f 
;G 1 6 3 4 L e i s u r e 
! u 3 4 7 6 F a s t b a c k 
! G 6 4 2 4 C h e S : S M a s 
B 4 6 7 6 W o r d 
2 . 0 
!M97 7 5 A u t o m a p 
; G 2 5 5 5 P o l i c e Q 
D 4 9 5 4 P o w e : r P o i 
U 7 5 5 8 P R 0 C 0 M M 
B 2 1 S 4 E x c e ; l 
4 . 
E 5 7 7 5Mi c k e y s 
B7 5 8 4 1 - 2 - 3 
3 . 
D 2 5 8 5 H a r v a r d 
E 6 5 5 5 K i d P i x 
B 4 9 5 4 Q u a t t r o 
U 7 5 8 8 T h e 
^ N o r t 
1 m u 1 a 
e c t 
5 
S u i t 
P l u s 
t e r 
2 . 0 
u e s t 
n t 
2 . 
P l u s 
0 
A B C s 
1 
P I u 
G r a p h 
t j o r 
1 5 0 0 1 1 : 0 0 0 0 3 2 5 0 3 9 1 5 0 2 5 0 0 0 
. 1 
2 2 5 1 1 3 5 5 0 1 0 2 5 2 6 9 0 0 2 3 0 0 0 
L a r r y 1 0 0 0 2 TO 8 5 0 2 0 00 3 9
j 9 5 2 0 0 0 0 
1 7 5 0 1 
1 : 5 0 0 0 3 5 0 1 19:502 1 0 0 0 
0 5 0 0 10:7 5 0 0 5 5 0 0 3 5 M 1 8 0 0 0 
2 5 0 0 8 5 : 5 5 0 0 8 5 0 2 9 9 : 7 53 0 0 0 0 
0 7 6 0 1 0 8 2 5 0 2 5 0 0 4 9 0 0 1 8 0 0 0 
0 7 5 0 2 0 4 5 5 0 4 4 5 0 4 5 5 5 0 5 0 0 0 
0 
2 2 5 1 0 3 : 5 0 0 0 9 5 0 2 9 9 : 0 0 0 8 0 0 0 
2 . 0 1 
0 7 5 0 1 L 0 5 0 0 5 2 5 0 6 9 0 0 0 7 5 0 0 
2 6 5 0 7 2 ; 5 7 5 1 0 2 5 2 9 9 ; 7 5 2 8 7 5 0 
0 8 0 0 1 0 3 5 0 0 2 2 5 0 2 9 0 0 0 3 0 0 0 
s; 
2 4 5 0 8 4 5 5 0 0 5 5 5 3 9 9 ; 0 0 3 5 8 0 0 
1 c s 
2 1 5 0 5 2 : 5 2 5 0 7 2 5 3 9 9 9 5 3 4 5 0 0 
0 2 5 0 1 0 J 5 4 0 0 2 5 0 0 3 5 J 0 0 0 3 6 5 0 
.0 
1 . 9 5 0 6 4 1 5 0 0 1 2 5 0 3 1 9 5 0 3 5 9 5 0 
P r o 
4 . 
on 
D e s i k t o p l 0 0 0 2 1 ; 8 5 0 0 7 5 0 1 1 5 ! 0 0 2 7 0 0 0 

Project 
11-6 
Report Layout: 
Nexus Software Inc. 
Product Cost Analysis as of 99/99/99 
based on Total Fixed Costs: $ZZ,ZZ9 
Product Line: X 
Product Name: XXXXXXXXXXXXXXXXXX 
Sell Price: ZZ9.99 
Total Variable Cost: ZZ9.99 
Units 
Revenue 
Breakeven 
Z.ZZ9 ZZZ.ZZ9.99 
Profit: $$$,$$9.99 
Z.ZZ9 ZZZ.ZZ9.99 
Price Decline: Z9% 
Z.ZZ9 ZZZ.ZZ9.99 
Nexus Software Inc. 
Product Cost Analysis 
Summary Report by Product Line as of 99/99/99 
Product 
Breakeven 
Profit: 
Price 
Line 
$ZZ,ZZ9 
Decline: Z9% 
X 
$$$$.$$9 
$$$$,$$9 
$$$$,$$9 
Totals $$,$$$,$$9 
$$,$$$,$$9 
$$,$$$.$$9 
Processing Requirements: 
1. Read a file of software records. 
2. For each record read: 
a. Calculate the total variable costs for each product using the data in each record; 
include an additional cost of $1.00 for the disk itself. The software preparation costs 
will be the loading cost per disk multiplied by the number of disks used; don't forget 
to add the cost of the blank disk(s) by multiplying the cost of a blank disk by the 
number of disks used. 
b. Create a three-item table containing units and revenues. This table should hold 
break-even units and revenue calculated as described below: 
(1) Calculate the break-even point and revenue for each product. 
(2) Calculate the required number of units and associated revenue to yield a 
$50,000 profit for each product. 
(3) Calculate the price decline break-even units and revenue if the selling price is 
reduced by 25%. 
c. Print a detail line for each record as shown on the report layout. Design your detail 
line with a table that mimics the information calculated in item b. above. 
d. Increment the appropriate revenue totals in your summary table. 
3. After all records have been read, print the summary report and totals on a separate 
page as shown on the report layout. This will require you to create a table to hold all 
the product lines and revenue information. 

A
p
p
e
n
d
i
x 
G 
Projects 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Narrative: 
Input File: 
Input Record Layout: 
Test Data: 
Report Layout: 
Processing Requirements: 
Employee Profiles 
This project continues the employee profile program of Project 11-1 by introducing 
additional material on table lookups. 
EMPLOYEE-FILE and TITLE-FILE (see processing requirement 3) 
Use the same record layout as Project 11-1. 
Use the same test data as Project 11-1. 
Expand the report layout of the earlier project to include space for the various table 
lookups. You m a y display the information anywhere you deem appropriate. 
1. The education table is to be initialized through hard-coding and expanded through a 
direct lookup according to the following table: 
Code 
Description 
Code 
Description 
1 
Some High School 
5 
Some Grad School 
2 
High School Diploma 
6 
Master's Degree 
3 
Two Year Degree 
7 
Ph. D. 
4 
Four Year Degree 
8 
Other Graduate Degree 
2. The location table is to be initialized through hard-coding and expanded with a 
sequential search according to the following table: 
Code 
Description 
Code 
Description 
05 
Atlanta 
30 
Los Angeles 
10 
Boston 
35 
Minneapolis 
15 
Chicago 
40 
New York 
20 
Detroit 
45 
Philadelphia 
25 
Kansas City 

Project 
12-2 
3. The title table is to be input loaded and expanded with a binary search according to 
the following table: 
Code 
Title 
15 
Accountant 
18 
Senior Accountant 
30 
Jr. Programmer 
32 
Senior Programmer 
40 
Analyst 
45 
Senior Analyst 
50 
Programming Manager 
P r o g r a m N a m e : 
Student Profile Program 
Narrative: 
Develop a program to print a set of student profiles, showing detailed information on each 
student. A m o n g other functions, the program is to convert an incoming set of codes for 
each student to an expanded, and more readable, format. 
Input File: 
STUDENT-FILE and COURSE-FILE (see processing requirement 12) 
Input Record Layout: 01 STUDENT-RECORD-IN. 
05 STU-SOC-SEC-NUMBER 
PIC 9(9). 
05 STU-NAME-AND-INITIALS. 
10 STU-LAST-NAME 
PIC X(18). 
10 STU-INITIALS 
PIC XX. 
STU-DATE-OF-BIRTH. 
10 STU-BIRTH-MONTH 
PIC 99. 
10 STU-BIRTH-YEAR 
PIC 99. 
STU-SEX 
PIC X. 
STU-MAJ0R-C0DE 
PIC X(3). 
STU-SCH00L-C0DE 
PIC 9. 
STU-CUMULATIVE-CREDITS 
PIC 999. 
STU-CUMULATIVE-POINTS 
PIC 999. 
STU-UNION-MEMBER-CODE 
PIC X. 
STU-SCHOLARSHIP 
PIC 999. 
STU-DATE-0F-ENROLLMENT 
PIC 9(4). 
STU-COURSES-THIS-SEMESTER OCCURS 7 TIMES. 
10 STU-COURSE-NUMBER 
PIC XXX. 
10 STU-COURSE-CREDITS 
PIC 9. 
05 
05 
05 
05 
05 
05 
05 
05 
05 
05 

Appendix 
G — Projects 
Test Data: 
1 0 0 0 0 0 0 0 0 A L B E R T 
2 0 0 0 0 0 0 0 0 B R 0 W N 
3 0 0 0 0 0 0 0 0 C H A R L E S 
4 0 0 0 0 0 0 0 0 S M I T H 
5 0 0 0 0 0 0 0 0 B A K E R 
6 0 0 0 0 0 0 0 0 G U L F M A N 
7 0 0 0 0 0 0 0 0 B 0 R 0 W 
8 0 0 0 0 0 0 0 0 M I L G R O M 
9 0 0 0 0 0 0 0 0 M I L L E R 
•9 9 9 9 19 9 9 9,W A Y N E 
A 
0 1 7 4 M S T A 1 0 5 9 1 1 8 Y 0 1 5 0 9 9 2 1 0 0 2 2 0 0 3 3 0 0 4 4 0 0 4 5 0 1 3 6 0 0 2 6 0 1 1 
B 
0 2 7 5 F S T A 1 0 8 9 2 7 5 N 0 2 5 O 9 9 2 1 0 0 2 2 0 0 3 3 0 0 4 4 0 0 4 ; 
G G 0 6 7 5 M H I S 2 1 0 9 2 8 6 Y 1 0 0 0 9 9 3 5 0 1 3 5 0 3 3 5 0 4 3 5 0 5 3 5 0 6 3 
D 0 
7 7 6 F X X X 2 0 9 0 2 6 9 N 0 1 0 0 9 9 2 1 0 0 2 2 0 0 3 3 0 0 4 4 1 9 4 
E F 1 0 7 4 M G E N 3 0 3 2 0 4 9 Y O O O 0 9 9 4 2 2 2 3 3 3 3 3 4 4 4 3 
S F 1 1 7 3 F E L E 4 0 2 9 0 5 9 N 0 0 0 0 9 9 3 2 0 0 3 3 3 3
:3 4 4 4 3 5 5 5 3 6 6 6 3 6 7 5 2 7 0 0 1 
J S 1 2 7 5 M I E N 3 O 3 0 0 9 0 Y 0 0 0 O 9 9 2 2 2 2 3 
M B 0 3 7 6 F 
5 O 1 5 0 4 5 Y O 0 0 O 9 9 3 1 1 1 3 1 3 8 3 1 5 0 3 1 6 0 3 
K 
O 1 7 4 M F R L 2 0 1 5 O 5 4 Y 0 0 0 0 9 9 3 1 1 1 3 1 4 0 3 1 5 0 3 
; 
; 
N 
0 4 7 3 F H I S 2 0 9 0 2 7 0 Y 0 0 0 O 9 9 4 5 0 1 3 5 0 3 3 5 0 4 3 5 0 5 3 ! 
Report Layout: 
S T U D E N T 
P R O F I L E S 
Page Z9 
**************************************** 
NAME: XXXXXXXXXXXXXXXXXX XX 
AGE: Z9.9 
SOC SEC NO: 999-99-9999 
MAJOR: XXXXXXXXXXXXXXX 
ENROLLED: 99/99 SCHOOL: XXXXXXXXXXXX 
YEAR IN SCHOOL: XXXXXXXXX STATUS: XXXXXXXXX 
SEX: XXXXXX GPA: 9.99 
COURSES THIS SEMESTER: 
COURSE 
CREDITS 
XXXXXXXXXXXXXX 
Z9 
TOTAL CREDITS 
Z9 
Processing Requirements: 
1. Process a file of student records, printing a complete student profile for each record. 
2. Two students are to appear on each page, with eight blank lines after the last line 
of the first profile on each page. The page number and literal heading S T U D E N T 
P R O F I L E S are to appear only before the first profile on each page. 
3. The detailed layout for each profile can be seen from the report layout. Additional 
specifications are given in items 4-11. 
4. Student age is to be calculated from date of birth and date of program execution. 
5. The social security number requires the insertion of hyphens; accomplish this by 
defining an output picture containing blanks in appropriate positions and then replace 
the blanks through the INSPECT verb. 
6. The status of the student is either part-time or full-time. Part-time students take fewer 
than 12 credits per semester. 
7. GPA is defined as the cumulative points divided by the cumulative credits and does 
not include credits taken this semester. Calculate this field to two decimal places. 
8. Year in school is a function of cumulative credits and again does not include credits 
taken this semester. Freshmen have completed fewer than 30; sophomores between 
30 and 59, inclusive; juniors between 60 and 89, inclusive; and seniors 90 or more. 

9. The incoming STU-SCHOOL-CQDE is to be expanded via a direct lookup. Hard-code 
the ioiiowing table in your program: 
CODE 
SCHOOL 
CODE 
SCHOOL 
1 
BUSINESS 
3 
ENGINEERING 
2 
LIBERAL ARTS 
4 
EDUCATION 
10. The incoming STU-MAJOR-CODE is to be expanded via a sequential search. Hard-
code the following major table: 
CODE 
MAJOR 
CODE 
MAJOR 
STA 
STATISTICS 
ECO 
ECONOMICS 
FIN 
FINANCE 
FRL 
FOREIGN LANG 
MKT 
MARKETING 
EEN 
ELECTRICAL ENG 
MAN 
MANAGEMENT 
MEN 
MECHANICAL ENG 
EDP 
DATA PROCESSING 
CEN 
CHEMICAL ENG 
PHY 
PHYSICS 
IEN 
INDUSTRIAL ENG 
ENG 
ENGLISH 
ELE 
ELEMENTARY EDUC 
BIO 
BIOLOGY 
SEE 
SECONDARY EDUC 
SECONDARY EDUC 
HIS 
HISTORY 
SPE 
SECONDARY EDUC 
SECONDARY EDUC 
11. Expand each value of STU-COURSE-NUMBER to an expanded course name using a 
binary search. An incoming record contains up to seven courses; blanks (that is, 
spaces) appear in an incoming record with fewer than seven courses. 
12. The table of course codes is to be established by reading values from a separate 
COURSE-FILE, with the following format: course code in positions 1-3 and course 
name in positions 4-18. The maximum table length is 100 courses, and the table of 
course codes appears below: 
CODE 
COURSE 
CODE 
COURSE 
100 
ENGLISH I 
503 
EUR HISTORY 
111 
COMPUTER SCI 
504 
ECONOMICS 
140 
SPANISH I 
505 
POL SCIENCE 
150 
MUSIC 
506 
CREATIVE WRIT 
160 
ART APPREC 
555 
EDUC THEORY 
200 
BIOLOGY 
601 
COBOL 
222 
CHEMISTRY 
666 
PSYCHOLOGY 
300 
CALCULUS 
675 
SPECIAL EDUC 
333 
ELECT ENG 1 
700 
THESIS 
501 
AM HISTORY 

A
p
p
e
n
d
i
x 
G — 
Projects 
P r o g r a m Name: 
Furniture Shipments 
N a r r a t i v e : 
This program takes Project 11-3 and adds table lookups for warehouse and item 
information. 
I n p u t F i l e : 
FURNITURE-FILE and ITEM-FILE (see processing requirement 1a) 
I n p u t R e c o r d L a y o u t : 
01 
FURNITURE-RECORD. 
05 
FURN-INVOICE-NO 
PIC 9(5). 
FURN-CUSTOMER-NAME-N-INITIALS 
PIC X(18). 
FURN-DELIVERY-INFO. 
10 
FURN-DELIVERY-WAREHOUSE 
PIC X. 
10 
FURN-DELIVERY-DATE 
PIC 9(6). 
FURN-0RDER-INFO. 
10 
FURN-DEP0SIT-PERCENT 
PIC 9V99. 
10 
FURN-N0-ITEMS-ORDERED 
PIC 9. 
10 
FURN-ITEMS-ORDERED OCCURS 1 TO 3 TIMES 
DEPENDING ON FURN-N0-ITEMS-ORDERED. 
15 FURN-ITEM-NO 
PIC 9(4). 
05 
05 
05 
T e s t 
D a t a : •HI 
I j| jt |:| |l i
:
 « f I f || |: |l |j pi || SI ||?^ :| jl ll ;|: li B 8 fa |S« 
j| j| ;| 
M 
2 3485EDE L,S TE I N , 
jl 2 8 3 4 A L I A(S , Y 
7 984 5 RAH IjM , S 
59 789KELLJY , C 
85778WI LSJON , D 
47597GUDAT, G 
58684HYMo|wiTZ, A I 
4857 7 BOOZi, B 
56749HENNJESSY, L 
95877M0HDI-RAZALLI 
38476TH0M|PS0N , J 
48565JAC0JMIN0, R ; 
67566DESCJHPELLES , M 
0 9 7 7 7 S A N CJH E Z - C A R R 10JN , 
48576WENN;EMAN , M 
\ 
4533 7AL-DJAKHIL, A 
47567HARDING , J 
j 
A06109i20052 1345l|386 
B072492004217871798 
A0927920073230023502375 
B082492003236093650 
C07 129J20 123457 54J5904598 
A062892008213451397 
C10289200912350 j 
C12129|2028345993J6093650 
A09099200415500 \ 
B01 12930781 1345
 1 
A09239|2009 1 1397 1j399 
A092392010213971345 
B07049J20092 1787 1J798 
VC081292002223504599 
B08169200412300 [ 
A0 7 229J2005 15500 ; 
C 0 8 2 2 9J2 0 0 2 2 13 4 5 13 9 7 
R e p o r t L a y o u t : 
Use the same report layout as Project 11-3, but expand the warehouse from the table 
lookups in both the detail and summary reports. Include the item number in the detail 
report. 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Follow the same processing requirements as Project 11-3 with the following changes. 
a. Note that the item description, item cost, and item weight have been replaced in 
the input record layout by a single item number. Determine the description, cost, 
and weight via a binary lookup. Initialize the following table by reading values from 
a separate ITEM-FILE and input-load it: 

Project 
12-4 
item 
# 
Description 
Cost 
Weight 
item # 
Description 
Cost 
Weight 
1345 
72" Sofa 
$2,300.00 
100 
2375 
Nightstand 
$300.00 
45 
1386 
Love Seat 
$1,300.00 
80 
3609 
Desk 
$450.00 
98 
1397 
Chair 
$545.00 
50 
3650 
Desk Chair 
$395.50 
45 
1399 
Ottoman 
$350.00 
40 
4575 
Dining Table 
$3,575.50 
135 
1787 
Sofa Table 
$600.00 
50 
4590 
6 Dining Chairs 
$1,278.00 
200 
1798 
End Table 
$545.50 
35 
4598 
Console 
$2,225.50 
115 
2300 
Dresser 
$4,300.00 
95 
4599 
Credenza 
$1,235.00 
250 
2350 
Armoire 
$5,500.00 
100 
5500 
Pool Table 
$2,300.00 
250 
b. The warehouse code is to be expanded via a sequential lookup. Hard-code the 
following table in your program: 
Warehouse Code 
Description 
A 
Miami 
B 
N. Carolina 
C 
New York 
Program Name: 
Computer Status Report 
Narrative: 
This program takes Project 11-4 and adds table lookups for payment method, status, and 
component information. 
input File: 
COMPUTER-FILE and COMPONENT-FILE (see processing requirement 1a) 
Input Record Layout: 01 COMPUTER-RECORD. 
05 C0M-INV0ICE-N0 
PIC 9(5). 
05 C0M-CUST0MER-NAME 
PIC X(18). 
05 C0M-PAYMENT-METH0D 
PIC XX. 
05 COM-SHIP-INFO. 
10 COM-SHIP-STATUS 
PIC X. 
10 C0M-SHIP-CHARGE 
PIC 99V99. 
05 C0M-C0MP0NENT-INF0. 
10 C0M-N0-C0MP0NENTS 
PIC 9. 
10 C0M-C0MP0NENTS OCCURS 1 TO 4 TIMES 
DEPENDING ON C0M-N0-C0MP0NENTS. 
15 C0M-C0MP0NENT-N0 
PIC 9(4). 

Appendix 
G — 
Projects 
Test Data: 
1 2 8 3 4 B 1 a n c o , 
E r i c k i 
A M 1 4 5 5-0 2 4 3 3 0 6 2 5 o! 
j 7 9 8 4 5 C a s a : l i , 
J o s e p h ! 
A M 3 7 5 0 0 2 3 3 0 5 0 0 0 8 1 2 0 
5 9 7 8 9 D a v i s , 
K e v i n 
V i 16 5 5 0 2 4 3 3 0 5 0 0 0 
8 6 7 7 8 D e m l e r , 
L i n d a ! 
C 0 3 8 0 2 5 4 3 3 0 0 5 5 0 0 9 2 0 1 6 7 5 0 
[4 7 5 9 7 E c h a ! v a r r i a , 
Fe:l i peCK265ok) 2 4 3 3 0 8 2 5 oi 
1 5 8 6 8 4 F 1 emjmi ng , 
S h a r o n 
MC 1 4 5 0 ; 0 2 4 5 0 0 5 5 0 0 : 
| 4 8 5 7 7 G o n z | a l e z , 
M a r i a 
V 1 1 3 5 0(0 3 4 5 0 0 6 7 5 0:9 3 0 0 
J 5 6 7 4 9 K a t a j n , 
M a h a r a n ! 
C K 2 4 5 0 : 0 1 3 2 5 0 
J 9 5 8 7 7 P a r m j e n t e r , 
D o n l i t a 
C 0 3 3 6 0 0 2 4 2 5 0 9 0 0 1 
j 3 8 4 7 6 P i n k ! w a s s e r , 
R a i n d i 
V I 3 89 00 4 4 6 6 06 5 0 05 5 0 0 9 3 0 0 
|37586Stewjart, 
R o b e r t o 
CK2500J0232507000J 
Report Layout: 
Use the same report layout as Project 11-4, but expand the status and payment method 
from the table lookups in both the detail and summary reports. Include the component 
number in the detail line. 
Processing Requirements: 
1. Follow the same processing requirements as Project 11-4 with the following changes. 
a. Note that the component description and cost have been replaced in the input 
record layout by a single component number. Determine the description and cost 
via a binary lookup for the detail report. Initialize the following table by reading 
values from a separate COMPONENT-FILE and input-load it: 
Component 
Description 
Cost 
Component 
Description 
Cost 
3250 
386 25MHz 
$1,295.00 
6250 
2400 BAUD Modem 
$99.00 
3330 
386 33MHz 
$1,595.00 
6500 
9600 BAUD Modem 
$299.00 
3400 
386 DX40 
$2,049.00 
6750 
Modem/FAX Card 
$119.00 
4250 
425 Notebook 
$1,995.00 
7000 
FAX 
$1,279.00 
4330 
486 33MHz 
$1,995.00 
8120 
Tape Backup Unit 120 
$189.00 
4500 
486 DX2 50MHz 
$2,295.00 
8250 
Tape Backup Unit 250 
$250.00 
4660 
486 DX2 66MHz 
$1,895.00 
9001 
CD/ROM 
$345.00 
5000 
Laser Printer 
$1,399.00 
9201 
Coprocessor 
$99.00 
5500 
Dot Matrix Printer 
$169.00 
9300 
Sound Blaster 
$139.00 
b. The status code (printed in both the detail and summary reports) is to be expanded 
via a binary lookup. Hard-code the following table in your program: 
Status 
Description 
1 
Assembly 
2 
Packing 
3 
Testing 

Project 
12-6 
c. The payment method code is to be expanded via a sequential lookup. Hard-code 
the following table in your program: 
Payment Code 
Method of Payment 
AM 
American Express 
MC 
MasterCard 
VI 
Visa 
CO 
COD 
CK 
Check 
Program Name: 
Credit Report 
Narrative: 
This program takes Project 11-5 and adds table lookups 
the 
and account type. 
Input File: 
CREDIT-FILE 
Input Record Layout: 
Use the same record layout as Project 11-5. 
Test Data: 
Use the same test data as Project 11-5. 
Report Layout: 
Use the same report layout as Project 11-5, but expand the account type with the 
appropriate description. 
Processing Requirements: 
1. Follow the same processing requirement as Project 11-5 with the following changes. 
a. Determine the description, credit limit, and interest rate via a sequential lookup. 
Hard-code the following table: 
Type 
Description 
Credit Limit 
interest Rate 
20 
Regular 
$1,500 
18.5% 
40 
3Pay 
$3,500 
0% 
60 
Household 
$5,500 
17.5% 
Program Name: 
Software Cost Analysis 
Narrative: 
This program takes Project 11-6 and adds table lookups for product line description. 
Input File: 
SOFTWARE-FILE 
Input Record Layout: 
Use the same record layout as Project 11-6. 

Appendix 
G — 
Projects 
Test Data: 
Use the same test data as Project 11-6. 
Report Layout: 
Use the same report layout as Project 11-6, but expand the product line with the 
appropriate description. 
Processing Requirements: 
1. Use the processing requirements from Project 11-6 and add the following: 
a. The product line code should be expanded in the summary report using the 
following code definitions: 
Code 
Product Line 
Code 
Product Line 
G 
Games 
D 
Drawing/Graphics 
B 
Business Applications 
E 
Educational 
U 
Utility Applications 
M 
Miscellaneous 
b. Today's date is to be printed as shown on the report layout. The current month is to 
be expanded via a direct lookup. Hard-code the following table in your program: 
Month 
Expanded Month 
Month 
Expanded Month 
i 
January 
7 
July 
2 
February 
8 
August 
3 
March 
9 
September 
A ^^;f 
i n 
I U 
5 
May 
11 
November 
6 
June 
12 
December 
Program Name: 
Catalog Orders Program 
Narrative: 
Develop a program to calculate the total orders and the total handling charges for the 
Regal Catalog Company's monthly orders. The order file has been sorted by date. 
Input File: 
CATALOG-ORDER-FILE and HANDLING-CLASS-FILE (see processing requirement 7) 
Input Record Layout: 
01 CATALOG-ORDER-RECORD. 
05 CAT-ITEM-NO 
05 CAT-DATE. 
10 CAT-MONTH 
10 CAT-DAY 
10 CAT-YEAR 
05 CAT-QUANTITY 
05 CAT-PRICE 
05 CAT-HANDLING-CLASS 
PIC 9(4). 
PIC 99. 
PIC 99. 
PIC 99. 
PIC 9(3). 
PIC 9(3)99. 
PIC X. 

Project 
12-7 
Test Data: 
'** 
»>*$ 
r.?'* 
- 
. , 
, . U & i J L u t 
-
4 41401048;901011545A| 
177801208J901047995G! 
3 13101298I904004995EJ 
1 183013 18J901008995D 
476502058902008925F 
599202148901007945C 
518602 188901043500F; 
347 502228J902008995E 
B34402288J901005495B! 
R e p o r t Layout: 
Design your own report layout in accordance with the processing specifications. 
Processing Requirements: 
1. Process a file of catalog orders to determine the monthly total for orders and handling 
charges. 
2. Print the month's orders with five blank lines between each month. Print an appropriate 
heading at the beginning of each new month. 
3. The detailed layout can be determined from the report layout. Additional specifications 
are given in items 4-7. 
4. The incoming CAT-MONTH is to be expanded via a direct lookup. Hard-code the 
following table in your program: 
Month 
Expanded Month 
Month 
Expanded Month 
1 
January 
7 
July 
2 
February 
8 
August 
3 
March 
9 
September 
4 
April 
10 
October 
5 
May 
11 
November 
6 
June 
12 
December 
5. The incoming CAT-ITEM-NO is to be expanded via a binary search. Input-load the 
following item table: 
Item No. 
Item Description 
Item No. 
Item Description 
1183 
Portable Phone 
4414 
Chess Set 
1778 
20" Television 
4765 
Table Lamp 
2686 
Coffee Maker 
5186 
35mm Camera 
3131 
Ceiling Fan 
5992 
Tennis Racquet 
3475 
Bedspread 
8344 
Vase 
6. Total price is calculated by multiplying the quantity by the price per item. 

Appendix 
G — Projects 
7. The incoming CAT-HANDLING-CLASS is to be expanded via a sequential search. The 
table for handling classes is to be established by reading values from a separate 
HANDLING-CLASS-FILE, with the following format: handling class code in position 1 
and handling charges in positions 2-5. The maximum table length is 26. The table of 
class codes is shown: 
Code 
Handling Charges 
A 
6.25 
B 
12.00 
C 
14.25 
b 
16.50 
E 
18.50 
F 
21.25 
G 
25.50 
Q H Q Q U Dogi2jQ,
r 
Narrative: 
The dollar amount of any check is written out in words, in addition to appearing as a 
number. This project is intended to accomplish that conversion. 
Input File: 
CHECKING-ACCOUNT-FILE 
Input Record Layout: 01 CHECKING-RECORD. 
05 CHECK-NUMBER 
05 CHECK-AMOUNT 
PIC 9(4). 
PIC 9(5). 
Test Data: 
J111101234 
(2 2224500 0; 
333345200 
;444445986 
666645906 
777700689 
J888800089 
J999900008 
JIOOOOIOOO 
200000100 
300023000
; 
Report Layout: 
The resulting report need not be elaborate. All that is required is a single detail line for 
each input record, containing the dollar amount and associated conversion. 

Project 
13- 1 
Processing Requirements: 
1. Read a file of checking account records. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Price Break Report 
Narrative: 
This project builds on Projects 2-1 and 7-2. Write a program to determine whether a 
customer receives a price break based on quantity ordered, and calculate the unit price 
and extended price. Create a report that prints each customer's order, as well as the 
Total Quantity Ordered and Total Sales for the company. 
Input File: 
ORDER-TRANSACTION-FILE 
Input Record Layout: 
Order Record 
Customer Number 
Quantity Ordered 
Item Number 
Unit Price 
1 ... 8 
9 
10 ... 12 
13 ... 17 
18 
19(2 decimals) 23 
Test Data: 
Use same test data as in Project 7-2. 
Report Layout: 
Use the same layout designed in Project 7-2. 
Processing Requirements: 1. Read a file of order records. 
2. For every record read: 
a. Determine whether the customer will receive a discount. The discounting of an item 
is based on specifications presented in Project 2-1; only 5-item series are included 
in this exercise, but the program should support up to 100-item series. Because of 
this additional criterion, utilize a two-dimensional table to determine the discount 
percent based on the item series and quantity ordered. 
b. Calculate the unit price by applying the appropriate discount as determined in 2a. 
c. Calculate the extended price by multiplying the quantity ordered by the unit price. 
d. Accumulate the customer's and the company's order totals. 
3. Print the customer number, item number, quantity ordered, unit price (calculated), and 
extended price for each customer record. Single-space the output. 
4. Print the total quantity ordered and the total sales. Double-space the totals. 
2. For each record read: 
a. Convert the dollar amount to a written amount, with the word "dollars" appended at 
the end; for example, 234 should be converted to TWO HUNDRED THIRTY-FOUR 
DOLLARS. 
b. Cents are not included; that is, all incoming amounts are integer amounts. The 
maximum dollar amount to be converted is 99,999. 
c. The report is to contain one line for each record, with the amount expressed in both 
numbers and words. 

Appendix 
G 
Projects 
Program Name: 
Movies 
Narrative: 
Develop a program to compute the amount due the hundreds of movie extras who 
participated in the latest Hollywood extravaganza. 
Input File: 
MOVIE-EXTRA-FILE 
Input Record Layout: 
POSITIONS 
FIELS 
1-9 
SOC-SEC-NUMBER 
9(9) 
10-27 
NAME 
X(18) 
28-29 
MOVIE-EXPERIENCE 
99 
30 
TYPE-ROLE 
X 
31-34 
HOURS-WORKED 
999V9 
35-36 
EXPANDED-ROLE 
XX 
Test Data: 
o o o o o o o o r 
000000002 
000000003 
000000004 
J O N E S , J . 
J O N E S , R O Y 
W I L L I A M S . JJ0HN 
F O S T E R , RAIYMOND 
OOOOOOOOSHIGH, LUCY 
000000006JHARDING, H 
000000007JZHE, KEVIN 
000000008JJENNINGS, 
000000009JROOSEVELT, 
00 0000010!T RUE LOVE , 
0WARD 
VIVIAN DO 
TIMOTHY07 
BILL 
0 9 
OOiGOSOOGN 
02F0450FA 
0l!E0450EA 
11B0425BN 
08A0450AR 
04JA0450AV 
0 5iD04500N 
2 00 DA 
E023 0XX 
G0450EN 
Report Layout: 
HOLLYWOOD EXTRAVAGANZA. INC. 
PAGE 19 
SOC SEC NO 
MOVIE EXTRA 
EXP 
ROLE 
HOURLY-RATE REG-HOURS EXTRA-HOURS 
PAY 
999-99-9999 XXXXXXXXXXXXXXXXXXXX 
99 
X 
$Z9.99 
ZZ9.9 
Z9 
$$,$$9.99 
Processing Requirements: 
1. Process a file of pay records for movie extras, to determine the pay owed to each 
individual. 
2. An hourly pay scale is used, with the individual's hourly rate a function of the type of 
role and his or her experience in previous movies. The following table contains the pay 
scale and is to be hard-coded in your program: 

Role 
Previous experience (number of movies) 
Role 
0 
1 
2 
3 
4 
5-7 
8 and Up 
A 
20.00 
25.00 
30.00 
32,00 
34.00 
38.00 
40,00 
B 
14.00 
17.00 
18.00 
19.00 
21.00 
23.00 
24.00 
C 
7,00 
7.00 
7.50 
8.00 
8.50 
8.50 
9.00 
D 
4.00 
4.00 
5.00 
5.50 
5.50 
6.00 
6.00 
E 
3.75 
4.50 
5.00 
5,25 
5.25 
5.50 
5.50 
F 
3.50 
3.50 
3,50 
3.75 
3.75 
3,75 
4.00 
The number of previous movies for an individual must be converted into a number 
from 1 to 7, so that it can be used as a subscript for access into the table. 
3. Incoming pay records are to be checked for valid data; specifically: 
a. Verify that the value in MOVE-EXPERIENCE is numeric; if not, display an error 
message and do no further processing for that record. 
b. Verify that the value in TYPE-ROLE is valid (i.e., A, B, C, D, E, or F); if not, display an 
error message and do no further processing for that record. 
4. Each employee is to receive, as a bonus, a number of extra hours (not appearing on 
the employee's pay record), for which the employee will be paid at his or her regular 
I IUUI iy IQtC. MIC MUIIIUCI UI C A U O IIUUIO IO O IUIIULIUII 
the incoming record as shown in the following table: 
Expanded Role 
Extra Hours 
Expanded Role 
Extra Hours 
AA 
01 
DN 
08 
AV 
01 
DR 
09 
BA 
03 
EA 
14 
BN 
05 
EN 
03 
CA 
05 
ER 
03 
CN 
04 
FA 
01 
DA 
08 
FN 
06 
5. The bonus table for extra hours is in ascending sequence by the expanded role field. 
Use a binary search to determine the number of extra hours an individual will receive; 
that is, if a match is found, take the hours shown in the table and add it to the hours in 
the incoming record to determine pay. If no match is found, do not add any extra 
hours. An individual with no extra hours will be paid just for the number of hours on his 
or her incoming record. 
6. The printed report should print no more than four valid records per page. (The 
employees with invalid data should be displayed in a separate error report.) Double-
space between detail lines. 

A
p
p
e
n
d
i
x 
G 
Projects 
Program Name: 
Two-level Tables 
Narrative: 
This program illustrates two-level tables and PERFORM VARYING in two dimensions. 
Incoming employee records are checked for one of three locations and one of two 
performance levels, producing six location-performance combinations. The average 
salary for each of these six combinations is computed. 
input File: 
EMPLOYEE-FILE 
Input Record Layout: 01 
10 
10 
EMPLOYEE-RECORD-IN. 
05 
EMP-PERSONAL-INFO. 
10 EMP-S0C-SEC-NUM 
EMP-NAME-AND-INITIALS 
EMP-OATE-OF-BIRTH. 
15 EMP-BIRTH-MONTH 
15 EMP-BIRTH-YEAR 
05 
EMP-C0MPANY-INF0. 
10 EMP-DATE-OF-HIRE. 
15 EMP-HIRE-M0NTH 
15 EMP-HIRE-YEAR 
EMP-L0CATI0N-C0DE 
EMP-EDUCATI0N-C0DE 
EMP-TITLE-DATA. 
15 EMP-TITLE-C0DE 
15 EMP-TITLE-DATE 
EMP-PERFORMANCE 
EMP-SALARY 
10 
10 
10 
10 
10 
PIC X(9). 
PIC X(16). 
PIC 9(2). 
PIC 9(2). 
PIC 9(2). 
PIC 9(2). 
PIC 9(2). 
PIC 9. 
PIC 9(3). 
PIC 9(4). 
PIC 9. 
PIC 9(5). 
Test Data: 
[354679876JKERBEL, NX: 
264480529JCLARK, JS \ 
223340090JHUMMER, MR; 
556667856JBENWAY , CX 
667893343FIfZPATRICK, 
j433556767JN0RI EGA, L;A 
455399829V0GEI. , VD j 
6887 734 23BE I NII0RN , |CB 
100334234GARCIA, PJ 
899843328T0WER, DR ' 
J776338380;MCD0NALD, ij 
075 9;0 190802564-0683 11 5500: 
1 16 0:0 7 9 13 0 3 9 9 9|0 18 4 12 5 3 0 0' 
075202928067340683143980 
095 91 19260599 9)0 18413255 4; 
045 7:069 3803878:018422 1550: 
116 0j0 49160245 3:0 683218500] 
0 3 600693 80 3233068312482 5 
0980:089230445 51068312985 0: 
075 9:019060256 410 683212000; 
056007903039990184119000 
0 7 5 31 190806 7 34)0683 1 54380! 
Report Layout: 
LOCATION/PERFORMANCE AVERAGE SALARY REPORT 
LOCATION 
HIGH PERFORMANCE 
LOW PERFORMANCE 
MIAMI 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
LOS ANGELES 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
NEW YORK 
ZZ.ZZ9.99 
ZZ.ZZ9.99 

Project 
13-4 
Processing Requirements: 
1. Read a file of employee records. 
Program Name: 
Three-level Tables 
Narrative: 
This program extends the previous project to illustrate three-level tables and PERFORM 
VARYING in three dimensions. Incoming employee records are checked for one of three 
locations, one of six education codes, and one of two performance levels, producing 36 
location-education-performance combinations. The average salary for each of these 36 
combinations is computed. 
Input File: 
EMPLOYEE-FILE 
Input Record Layout: 
Same as Project 13-3 
Test Data: 
Same as Project 13-3 
Report Layout: 
AVERAGE SALARY REPORT FOR LOCATION: MIAMI 
EDUCATION LEVEL 
HIGH PERFORMANCE 
LOW PERFORMANCE 
GRADE SCHOOL 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
HIGH SCHOOL 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
ASSOCIATE 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
BACHELOR 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
MASTER 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
DOCTORATE 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
2. For each record read, determine if the employee is in Miami (code 30), Los Angeles 
(code 60), or New York (code 80) and has a performance rating of 1 (high performance) 
or 2 (low performance). Any employee meeting both requirements—that is, an employee 
with a valid location and performance rating—is a qualified employee. No further 
processing is necessary for nonqualified employees. 
3. Establish a 3-by-2 table to compute salary statistics for the 6 location-performance 
combinations. Rows 1, 2, and 3 are for Miami, Los Angeles, and New York. Columns 1 
and 2 designate high and low performance, respectively. 
4. For each qualified employee: 
a. Determine the appropriate row-column (i.e., location-performance) combination. 
b. Increment the total of all employee salaries for that row-column combination by this 
employee's salary. 
c. Increment the number of employees in that row-column combination by 1. 
5. When all employees have been processed, divide the total salaries for each combination 
by the number of employees in that combination, producing the average salary for that 
combination. Produce the required report shown in the report layout, showing the six 
values of average salary. 

Appendix 
G 
Projects 
AVERAGE SALARY REPORT FOR LOCATION: LOS ANGELES 
EDUCATION LEVEL 
HIGH PERFORMANCE 
LOW PERFORMANCE 
GRADE SCHOOL 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
HIGH SCHOOL 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
ASSOCIATE 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
BACHELOR 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
MASTER 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
DOCTORATE 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
AVERAGE SALARY REPORT FOR LOCATION: NEW YORK 
EDUCATION LEVEL 
HIGH PERFORMANCE 
LOW PERFORMANCE 
GRADE SCHOOL 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
HIGH SCHOOL 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
ASSOCIATE 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
BACHELOR 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
MASTER 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
DOCTORATE 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
Processing Requirements: 
1. Read a file of employee records. 
2. For each record read, determine if the employee is in Miami, Los Angeles, or New 
York; has an education code of 1 through 6 for Grade School, High School, Associate, 
Bachelor, Master, and Doctorate; and has a performance rating of 1 (high performance) 
or 2 (low performance). Any employee meeting all three requirements—that is, an 
employee with a valid location, education, and performance rating—is a qualified 
employee. No further processing is necessary for nonqualified employees. 
3. Establish a 3-by-6-by-2 table to compute salary statistics for the 36 location-education-
performance combinations. Each location contains rows 1 through 6 for Grade School, 
High School, Associate, Bachelor, Master, and Doctorate; and columns 1 and 2 
designate high and low performance, respectively. 
4. For each qualified employee: 
a. Determine the appropriate row-column (i.e., education-performance) combination 
for each location. 
b. Increment the total of all employee salaries for that row-column combination for 
each location by this employee's salary. 
c. Increment the number of employees in that row-column combination for that location 
by 1. 
5. When all employees have been processed, divide the total salaries for each combination 
by the number of employees in that combination, producing the average salary for that 
combination. Produce the required report shown in the report layout, showing the 36 
values of average salary, printing every location on a separate page. 

Project 
13-5 
Program Name: 
Payroll Program 
Narrative: 
Develop a program to print complete paycheck (including a check stub) and a payroll 
journal reflecting all checks printed. 
Input File: 
Input Record Layout: 
PAYROLL-FILE 
01 PAYROLL -RECORD-IN. 
05 PAY -S0C-SEC-NUM 
PIC 9(9). 
05 PAY -NAME. 
10 PAY-LAST 
PIC X(14). 
10 PAY-FIRST 
PIC X(12). 
10 PAY-INITIAL 
PIC X. 
05 PAY -INFO. 
10 PAY-HOURLY-RATE 
PIC 9(3)V99 
10 PAY-HOURS-WORKED 
PIC 9(3)V99 
10 PAY-SALARY-TYPE 
PIC X. 
10 PAY-DEPENDENTS 
PIC 99. 
10 PAY-TAX-STATUS 
PIC 9. 
10 PAY-INSURANCE 
PIC X. 
05 PAY--YTD-INFO. 
10 
D A V VTrv CADUtMCC 
i rv i - i I v- 
i _ r m n x n u j 
nrr 
1 
n(a\unn 
10 PAY-YTD-TAXES 
PIC 9(5)V99 
10 PAY-YTD-FICA 
PIC 9(4)V99 
10 PAY-YTD-INSURANCE 
PIC 9(3)V99 
Test Data: 
Use the validated payroll file from Project 8-3. 
Report Layout: 
ANDREW INC. 
PAYROLL JOURNAL AS OF 99/99/99 
PAGE Z9 
DEDUCTIONS 
SOC SEC NO 
999-99-9999 
NAME 
XXXXXXXXXXXXXX, XXXXXXXXXXXX X. 
GROSS 
EARNINGS 
ZZ.ZZ9.99 
TAXES 
FICA 
INSURANCE 
NET PAY 
Z.ZZ9.99 Z.ZZ9.99 
Z9.99 
ZZ.ZZ9.99 
ZZZ.ZZ9.99 ZZ.ZZ9.99 ZZ.ZZ9.99 
ZZ9.99 
ZZZ.ZZ9.99 

Appendix 
G — 
Projects 
Processing Requirements: 
1. Read a file of payroll records. 
Head of Household 
Yearly salary 
over - 
but not over 
The tax is: 
of the amount over -
0 
24,850 
$0 
+ 15% 
$0 
24,850 
64,200 
$3,727.50 
+ 28% 
24,850 
64,200 
128,810 
14,745.50 
+ 33% 
64,200 
Married Filing Jointly 
Yearly salary 
over - 
but not over 
The tax is: 
of the amount over -
0 
30,950 
$0 
+ 15% 
$0 
30,950 
74,800 
$4,642.50 
+ 28% 
30,950 
74,800 
128,810 
16,934.50 
+33% 
74,800 
Single 
Yearly salary 
over - 
but not over 
The tax is: 
of the amount over -
0 
18,500 
$0 
+ 15% 
$0 
18,500 
44,900 
$2,782.50 
+ 28% 
18,500 
44,900 
93,130 
10,160.50 
+33% 
44,900 
Married Filing Separately 
Yearly salary 
over - 
but not over 
The tax is: 
of the amount over -
0 
15,475 
$0 
+ 15% 
$0 
15,475 
37,425 
$2,321.50 
+28% 
15,475 
37,425 
117,895 
8,467.50 
+ 33% 
37,425 
2. For each record read calculate: 
a. Gross earnings, which is dependent on salary type (salaried or hourly) and can be 
calculated in one of two ways: 
(1) Salaried employees are not paid overtime. Gross pay for salaried employees is 
rate of pay multiplied by the standard 40 hours. If hours exceed 40, place an 
asterisk (*) next to the hours worked in the detail line of the payroll journal and 
calculate the gross earnings using 40 hours. 
(2) Hourly employees are paid overtime at a rate of time and a half for hours 
beyond 40 through 48 and double time for hours beyond 48. 
b. The yearly taxes, which are dependent on two factors: tax status and yearly salary. 
This amount is divided by 52 to obtain the weekly tax deduction. 
(1) The tax status is used to determine the proper tax table. Establish a two-level 
table with the following information to determine the taxes deducted (you may 
pick the type of initialization and lookup technique): 

Project 
13-6 
(2) Yearly salary for both salaried and hourly employees is estimated based on a 
40-hour week and a 52-week year. 
c. FICA deduction, which is calculated as 7.51% of gross pay for the first $56,000. 
After year-to-date earnings reach $56,000, no FICA will be deducted. 
d. Insurance deducted, which is also determined by the type of insurance plan and 
number of dependents. Determine the insurance deducted via a table lookup in the 
following two-level table: 
Number of Dependents 
Health Plan 
Number of Dependents 
Blue Cross 
AvMed 
H u m a n a 
1 
14.00 
10.00 
10.00 
2 
15.00 
12.00 
12.00 
3 
20.00 
15.00 
15.00 
4 
23.00 
18.00 
18 00 
5 
25.00 
24.00 
24.00 
Note; Beyond 5 dependents the cost of the plan remains the same. Therefore, an employee with 8 
dependents pays the 5-dependent rate No insurance is deducted for those with a Z (NO-INSURANCE). 
e. Net earnings, which is calculated as gross earnings minus deductions (taxes, FICA 
[if any], and insurance [if any]). 
3. Print a payroll journal detail line as shown in the report layout. Use the STRING 
statement to print the employee name in the following format: 
lastname, 
firstname 
initial 
4. Print a heading on top of each new page. Each page is to contain 10 employees. The 
date of execution should appear on the heading as indicated. 
5. When all records have been read, print totals for hours worked, gross pay, all 
deductions (taxes deducted, FICA deducted, insurance deducted), and net pay. 
Program Name: 
Narrative: 
Extended Student Profile Program 
This program continues the student profile program of Project 12-2 by adding a summary 
report. The summary report will utilize a three-dimensional table to accumulate totals for 
each school, major within school, and year in school within major. 
Input File: 
STUDENT-FILE and COURSE-FILE from Project 12-2 
Input Record Layout: 
Use the same record layout as Project 12-2. 
Test Data: 
Use the same test data as Project 12-2. 

Appendix 
6 — Projects 
Report Layout: 
s U D t N I P K 0 r I L t S 
Page Z9 
Summary Report for School of XXXXXXXXXX as of 99/99/99 
*********************************************** 
Major: XXXXXXXXXXXXXXX 
Number of 
Total 
Average 
Year in School 
Students 
Credits 
Credits 
Freshman 
229 
11,119 
Z.ZZ9 
Sophomore 
Junior 
. 
Senior 
• 
• 
Totals 
1,119 
111,119 
11,219 
******************************************************************** 
Major: XXXXXXXXXXXXXXX 
Number of 
Total 
Average 
Year in School 
Students 
Credits 
Credits 
School of XXXXXXXXXX 
11,119 
1,111,119 
111,119 
Processing Requirements: 
1. The following are additional processing requirements to Project 12-2 for the summary 
report: 
a. Create a 4 x 18 x 4 (3-dimensional) table to accumulate number of students and 
total credits for the appropriate school-major-year (in school) combination. 
b. When all records have been processed, print the summary as shown in the report 
layout. Each school should begin on a new page. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Price Break Report 
Narrative: 
This project builds on Project 13-1. Write a program to determine whether a customer 
receives a price break based on quantity ordered and calculate the unit price and 
extended price. Create a report that prints each customer's order, as well as the total 
ordered for each customer and a grand total for the company. 
Input File: 
ORDER-TRANSACTION-FILE 
Input Record Layout: 
Customer Order Record 
Customer Number 
Quantity Ordered 
Item Number 
Unit Price 
Salesrep Number 
1 
... 8 
9 
10 
... 12 
13 
... 17 
18 
19 (2 decimals) 23 
24 
... 27 

Project 
14-1 
T e s t Data: 
Report Layout: 
Modify the report designed in Project 7-2, adding salesrep number and region area 
name. 
Requirements: 1. Sort the incoming order file by customer number and within customer number by 
salesrep number. 
2. Read the sorted file of order records. 
3. For every record read: 
a. Determine whether the customer will receive a discount. The discounting is 
determined based on the specifications of Project 13-1. 
b. Calculate the unit price by applying the appropriate discount as determined in 3a. 
c. Calculate the extended price by multiplying the quantity ordered by the unit price. 
d. Determine the region a salesrep is assigned to based on the first byte of the 
salesrep number and utilizing the following table. 
Region Code 
Region Area Name 
A 
Arlington 
B 
Bridgeport 
C 
Coppell 
D 
Dallas 
E 
Euless 
4. Print the customer number, item number, quantity ordered, unit price (calculated), and 
extended price for each customer record. Single-space the output. 
5. Print the total quantity ordered and the total sales. Double-space the totals. 
1 0 0 0 0 0 0 1 0 0 0 5 1 1 1 1 19 105 3 4 A 1 0 0 
12 0000002 010021222802 056B200 
|3 0 0 0 0 0 0 3 0 1 2 5 3 2 3 3 3 7 3 0 0 4 5 A 1 0 0 
4 0 0 0 0 0 0 4 0 5 0 0 4 3 4 4 4 6 3 4 0 2 1 B 2 0 2 
|5 0 0 0 0 0 0 5 0;9 0 0 5 4 5 5 5 5 56 5 7 8 C 3 0 0 
jl 0 0 0 0 0 0 1 0 0 1 5 1 3 4 5 6 9 1 3 5 3 4 A 1 0 1 
J2 0 0 0 0 0 0 2 0 0 102 1 2 3 4 8 0 1 0 5 6 B 2 0 2 
|3 0 0 0 0 0 0 3 0 1 0 0 3 4 3 2 1 7 3 3 0 4 5 C 3 0 0 
4 0 0 0 0 0 0 4 0 4 0 0 4 4 3 2 4 6 3 7 0 2 1 A 1 0 0 
J5 0 0 0 0 0 0 5 0:7 0 0 4 2 4 5 6 5 5 6 5 7 8 B 2 0 2 
( 1 0 0 0 0 0 0 1 0 0 6 0 4 1 1 1 1 9 1 5 5 3 4 A 1 0 0 
j2 0000002 0.0 2 5 5 6 6 2 2 8 0 4 0 5 6 B 2 0 0 
13 0 0 0 0 0 0 3 0 3 1 53 1 1 3 3 7 3 3 0 4 5 C 3 0 0 
4 0 0 0 0 0 0 4 0 4 0 0 2 4 2 1 4 6 3 2 0 2 1 B 2 0 0 
J5 0000005 0'
:7 8 0 1 6 4 5 5 5 5 1 5 7 8 B 2 0 0 

Appendix 
G — Projects 
Program Name: 
Order Transaction File Validation 
Narrative: 
This project builds on Project 8-1, utilizing more advanced programming techniques 
such as table handling, redefines, internal sort, and control break logic. Write a data 
validation program that will validate an order transaction file. 
Input File: 
ORDER-TRANSACTION-FILE, same as Project 8-1. 
Test Data: 
Same as Project 8-1. 
Report Layout: 
Same as Project 8-1. 
Processing Requirements: 1. Read a file of order transaction records. 
2. Sort the order transaction records so that all records for one order can be processed 
together and so that the record types 1, 2, and 3 are in the appropriate order. 
3. The current run date is typically accepted from a file, but for this lab set up a literal in 
working storage with the run date as November 2, 1992. 
4. Validate each input record field for all of the following: 
All validations from Project 8-1. 
Change the Quantity Code conversion to Quantity Amount logic in Project 8-1 to utilize 
a hard coded table containing the Quantity Code and the appropriate Quantity 
Amount. 
5. Any record that fails any validity test is to be written to an error file, and an appropriate 
error message should appear on the error report. It is possible that a record may 
contain more than one error, and all errors are to be flagged. 
6. Valid records are to be written to a valid transaction file. The valid transaction file 
should be the same format as the input Order Transaction file, with the exception that 
the quantity code on the Type 3 record should be converted to the quantity amount, 
causing the unit price to be moved to the right two bytes. 
Program Name: 
Sorted Car Sales Program 
Narrative: 
Develop a program to process a sales file in order to determine the amount earned by 
each salesperson. 
Input File: 
SALES-FILE 

Project 
14-3 
Input Record Layout: 
01 SALES-RECORD-IN. 
05 SA-DEALER 
PIC X(8). 
05 SA-BRANCH 
PIC 9(3). 
05 SA-SALESPERSON 
PIC X(10). 
05 SA-SALES-INFO. 
05 SA-CUST0MER 
PIC X(10). 
05 SA-SALE-PRICE 
PIC 9(6). 
05 SA-COMMISSION-RATE PIC 9V99. 
05 SA-CAR-INFO. 
10 SA-CAR-MAKE 
PIC X(8). 
10 SA-CAR-MODEL 
PIC X(8). 
10 SA-CAR-YEAR 
PIC 9(4). 
Test Data: 
;BROWARD 
0 1 0 G E H L E 
MORENO 
0 1 6 1 2 5 0 0 5 T O Y O T A 
S U P R A 
19 90 
JDADE 
1 1 0 D A V E R S A 
R E N E S C A 
0 0 4 9 5 0 0 0 2 H Y U N D A I 
EjXCEL G 1990 
JBROWARD 
0 2 0 R O W E 
V I E R A 
0 1 4 3 0 0 0 0 2 S T E R L I N G 8 J 2 5 S L 
1 9 8 9 
iDADE 
l i O O R I CO 
GORMAN 
0 3 8 5 0 0 0 0 4 L E X U S 
40 0 
L S 
19 9*2 
JBROWARD 
0 1 0 S H I M 
P O R T O 
0 2 5 5 7 5 0 Q 4 M 
B E N Z 
3;0 0 E 
1 9 8 8 
TJADE 
1 1 0 F R E N C H 
D EGG S 
0 0 9 0 2 5 0 0 4 N I S S A N 
M A X I M A 
19 88 
MONROE 
2 1 0 B 0 Y E R 
P I R E S 
0 0 6 1 2 5 0 0 4 M A Z D A 
62 6 
19 88 
|DADE 
1 0 0 R I C 0 
CHUA 
0 1 0 7 0 0 0 0 : 4 T 0 Y O T A 
CiAMRY 
DE 19 9JQ 
(BROWARD 
0i20R0WE 
P I N E D A 
0 0 9 2 0 0 0 0 : 3 A U D I 
5,000 
198{8 
[DADE 
L l O D A V E R S A 
MCDONALD 
0 4 0 0 0 0 0 0 5 I N F I N I T I Q:4 5 
19 9:2 
B R O W A R D 
0 1 0 G E H L E 
L A R S H 
O 1 2 4 7 5 0 0 3 P U E G O T 
5 : 0 5 G L S 
19 9:0 
D A D E 
1 1 0 F R E N C H 
S P E A R S 
0 1 0 9 7 5 0 0 1 N I S S A N 
3 0 0 Z 
1 9 8 8 
B R O W A R D 
0 2 0 R 0 W E 
TOCKMAN 
0 2 7 1 5 0 0 0 6 B M W 
&3 5 
C S I 
19 88 
MONROE 
2 1 0 B 0 Y E R 
A U G U S M A 
0 3 9 7 9 9 0 O 2 M 
B E N Z 
56 0 SL 19 8:8 
B R O W A R D 
0 1 0 G E H L E 
HOLME 
9 0 1 3 7 0 0 0 0 2 H O N D A 
P R E L U D E 
1990 
•MONROE 
2 1 0 B 0 Y E R 
L O U I S 
0 1 0 1 7 5 0 0 4 M A Z D A 
RX7 
G X L 
1990 
iBROWARD 
0 1 0 S H I M 
R E I N M A N 
0 0 9 7 2 5 0 O 2 S A A B 
900 
19 88 
DADE 
1 0 0 R I C O 
DIL EGO 
0 1 5 8 0 0 0 0 4 M A Z D A 
M I AT A 
19 92 
M O N R O E 
2 1 0 V A S Q U E Z 
H A F E Z 
0 3 2 8 7 5 0 0 3 J A G U A R 
X J 6 
19 90 
jDAD E 
1 1 0 F R E N C H 
G R A H E 
0 1 4 7 5 0 0 0 3 B M W 
3 2 5 ES 1 9 8 8 
jMONROE 
2 1 0 V A S Q U E Z 
HWANG 
0 2 3 0 0 0 0 0 4 L E G E N D 
C O U P E 
1 S 1988 
Report Layout: 
VERY VERY NICE CARS INC. 
PAGE Z9 
CAR INFORMATION 
COMMISSION 
NET TO 
DEALER 
SALESPERSON YEAR 
MAKE 
MODEL CUSTOMER 
PRICE 
PAID 
DEALER 
XXXXXXXX XXXXXXXXXX 
9999 XXXXXXXX XXXXXXXX XXXXXXXXXX 112,119 
ZZ.ZZ9.99 
ZZZ.ZZ9.99 
VERY VERY NICE CARS TOTALS 
$Z,ZZZ,ZZ9 $ZZZ.ZZ9.99 SZ.ZZZ.ZZ9.99 

A
p
p
e
n
d
i
x 
G — 
Projects 
Processing Requirements: 
1. Sort the incoming sales file by dealer, within dealer by salesperson, and within year by 
car make. 
2. Read the file of sorted sales records, and for each record read: 
a. Calculate the commission paid to the salesperson by multiplying the sale amount 
by the commission rate. 
b. Calculate the net to the dealer by subtracting the commission from the sale 
amount. 
c. Print a detail line for each sale. 
d. Increment the totals as shown on the report layout. 
3. After all records have been read, print Very Very Nice Cars totals. Skip three lines prior 
to printing the company total. 
Program Name: 
Sorted Bonus Program 
Narrative: 
Write a program to process a bonus file to determine which employees are eligible for a 
bonus and the bonus amount. 
Input File: 
BONUS-FILE 
Input Record Layout: 01 BONUS-RECORD-IN. 
05 B0-MANU-PLANT 
PIC XX. 
05 B0- DEPARTMENT 
PIC X(8). 
05 B0- EMPLOYEE 
PIC X(15) 
05 B0-MANAGER 
PIC X(10) 
05 B0- SALARY 
PIC 99999 
05 B0- PERCENTAGE 
PIC 9V99. 
05 B0- ELIGIBILTY 
PIC X. 
Test Data: 
T N I n t e r i o r K n o w l e s , 
CD 
G A R C I A 
3 0 1 0 0 0 0 8 Y 
; K Y F e n d e r s 
P r i c e , 
MD 
V I L L A R 
2 4 0 0 0 0 0 0 N 
0 H T r i m 
I nn i s s , 
ML 
S P E N C E R 
3 2 0 0 0 0 1 2 Y 
: K Y F e n d e r s 
K a n n i ng , 
OS 
V I L L A R 
2 8 0 0 0 0 0 8 Y 
O H P a i n t 
P r a t e s , 
L S 
A L V 0 R D 
2 9 0 0 0 0 1 5 Y 
K Y I n t e r i o r S a n g a s t i a n o , 
L A F E I N 
3 2 0 0 0 0 1 1Y 
i T N T r i m 
G i b b s , 
G J 
J O N E S 
2 6 0 0 0 0 0 6 Y 
K Y F e n d e r s ; 
B a r n a b a s , 
SJ 
G R A U E R 
3 0 0 0 0 0 1 0 Y 
I T N I n t e r i o x D a v i s , 
J L 
G A R C I A 
3 1 0 0 0 0 0 7 Y 
O H I ' a i nt 
M o n t e s , 
J 
A L V 0 R D 
2 7 0 0:0 0 12 Y 
KY F e n d e r s : L a m a n i a , 
NC 
G R A U E R 
3 2 0 0 0 0 0 5 Y 
T N T r i m 
R o m e r o , 
CM 
W I L L I A M S 
3 2 0 0 0 0 1 8 Y 
i O H P a i n t 
S i m o n t o n , 
DM 
A L V 0 R D 
2 5 0 0-0 0 0 0 N 
J N T r i m 
W i l s o n , 
R J 
J O N E S 
2 4 0 0 0 0 0 0 N 
O H P a i n t 
K e i 1 e r , 
M 
S M I T H 
2 8 0 0 0 0 0 6 Y 
• T N I n t e r i o . r T w i n n , 
S A 
J A M E S 
2 2 0 0:0 0 0 4 Y 
; 0 H P a i n t 
C h u a , 
C E
 
; 
S M I T H 
3 1 0 o;o 0 0 7 Y 
K Y I n t e r i o r A l - A s k a r , 
E K 
B A R B E R 
3 0 1 0 0 0 0 9 Y 
0 H T r i m 
C a r d o n e , 
J 
F R A N K 
3 2 0 0:0 0 0 8 Y 

Project 
14-5 
R e p o r t Layout; 
K Y I n t e r i o r W i n t e r , 
EK 
F E I N 
2 2 0 0 0 0 0 0 N 
f N f r i in 
H e s s , 
AM 
W I L L I A M S 
3 6 0 0 0 0 1 4 Y 
l O H T r i m 
B o b e r g , 
DM 
F R A N K 
3 6 0 0 0 0 1 2 Y 
i K Y I n t e r i o r B e h r e n d , 
TR 
B A R B E R 
3 1 0 0 0 0 0 5 Y 
:0 H T r i m 
S m i t h , 
GM 
F R A N K 
2 6 0 0 0 0 0 0 N 
K Y F e n d e r s 
G i b e r s o n , 
C J 
G R A U E R 
3 4 0 0 0 0 1 5 Y 
T N T r i m 
C l a s e n , cc 
J O N E S 
3 2 0 0 0 0 1 0 Y 
O H T r i m 
A1 - K h u w i t e r , 
ft 
c n r M ' r- r n 
« 
j r criiLrt 
2 4 0 0 0 0 1 1 Y 
i T N I n t e r i o - r A l b e r n i 
, 
W J 
J A M E S 
3 2 0 0 0 0 1 0 Y 
K Y I n t e r i o r C h i 1 d e r s , 
R L 
B A R B E R 
3 5 0 0 0 0 1 2 Y 
T N I n t e r i o r W a r r e n , 
A;E 
J A M E S 
3 5 0 0 0 0 1 1 Y 
FASSSTCARS MANUFACTURERS 
PAGE Z9 
PLANT DEPT 
MANAGER 
SOC SEC NO SALARY BONUS 
TOTAL 
XX XXXXXXXX XXXXXXXXXX 999-99-9999 
11,119 
1,119 111,119 
FASSSTCARS TOTALS 
1,111,119 11,119 1,111,119 
Processing Requirements: 
1. Sort the incoming bonus file by plant, within plant by department, and within department 
by manager. Sort only the employees that are eligible for a bonus, that is, those that 
contain a "Y" in the eligibility field. 
2. Read the file of sorted bonus records, and for each record read: 
a. Calculate the bonus amount by multiplying the salary by the bonus percentage. 
b. Calculate the total compensation by adding the salary and the bonus. 
c. Print a detail line as shown on the report layout. 
d. Increment the appropriate totals as shown on the report layout. 
3. After all records have been read, print totals for Fassstcars. 
Program Name: 
Narrative: 
Sorted Store Sales Commissions Program 
Develop a program to process sales records for the Needless Markup company. The 
report is to show sales, commissions paid, and net sales for each transaction. 
Input File: 
SALES-FILE 
Input R e c o r d Layout; 
01 SALES-RECORD. 
05 SAL-PERSON-NAME 
05 SAL-DATE. 
10 SAL-MONTH 
10 SAL-DAY 
10 SAL-YEAR 
PIC X(10). 
PIC 9(2). 
PIC 9(2). 
PIC 9(2). 

Appendix 
G — Projects 
PIC 9(5)V99 
PIC V99. 
PIC 9(2). 
PIC X(12). 
T e s t D a t a : 
05 SAL-AMOUNT 
05 SAL-COMMISSION-RATE 
05 SAL-STORE-NUMBER 
05 SAL-DEPARTMENT-NAME 
A D A M S 
0 4 2 2 9 0 0 2 1 4 0 0 0 0 6 0 3 D E S I G N E R 
H I L L 
0 4 3 1 9 0 0 0 0.9 8 0 0 0 5 0 1 S P 0 R T S W E A R 
S M I T H 
0 4 2 8 9 0 0 0 0 8 0 0 0 0 5 0 2 L I N G E R I E 
H A R R I S O N 
0 4 2 3 9 0 0 0 0 2 6 0 0 0 5 0 4 S P O R T S W E A R 
H I L L 
0 4 0 9 9 0 0 0 3 6 9 0 0 0 4 0 1 S H 0 E S 
& B A G S : 
H A R R I S O N 
0 4 1 8 9 0 0 0 1 2 5 5 0 0 5 0 4 S P 0 R T S W E A R 
H I L L 
0 4 1 5 9 0 0 0 2 6 3 0 0 0 4 0 1 S H 0 E S 
& 
B A G S 
C L A R K 
0 4 2 4 9 0 0 0 0 0 4 5 5 0 5 0 4 L I N G E R I E 
T U R N E R 
04 1 8 9 0 0 0 0 7 5 0 0 0 3 0 2 A C C E S S O R I E S 
J O N E S 
0 4 2 5 9 0 0 0 2 5 6 0 0 0 5 0 1 S P O R T S W E A R 
A D A M S 
0 4 1 6 9 0 0 8 3 9 6 0 0 0 6 0 3 0 E S I G N E R 
C L A R K 
0 4 1 5 9 0 0 0 4 7 8 0 0 0 5 0 4 S P O R T S W E A R 
S M I T H 
0 4 2 5 9 Q 0 0 1 5 5 0 0 0 5 0 2 L I N G E R I E 
J O N E S 
0 4 3 0 9 0 0 0 1 5 7 9 9 0 5 0 1 S P O R T S W E A R 
J O N E S 
0 4 0 3 9 0 0 0 2 3 0 9 9 0 4 0 1 S H O E S 
& 
B A G S 
ADAMS 
0 4 0 8 9 0 0 0 3 1 5 0 0 0 5 0 3 S P O R T S W E A R 
L U D L U M 
0 4 2 6 9 0 0 6 1 2 0 9 9 0 6 0 3 D E S I G N E R 
ADAMS 
0 4 0 5 9 0 0 0 8 3 6 0 0 0 5 0 3 S P 0 R T S W E A R 
S M I T H 
0 4 1 2 9 0 0 0 0 4 5 2 5 0 3 0 2 A C C E S S 0 R I E S 
V A N B E R G E R 
0 4 2 9 9 0 0 0 0 5 5 0 0 0 5 0 2 L I N G E R I E 
C L A R K 
0 4 0 9 9 0 0 0 2 3 7 9 9 0 5 0 4 S P 0 R T S W E A R 
H A R R I S O N 
0 4 2 9 9 0 0 0 2 2 5 0 0 0 5 0 4 L I N G E R I E 
H A R R I S O N 
0 4 3 0 9 0 0 2 4 9 8 2 5 0 6 0 4 D E S I G N E R 
R e p o r t L a y o u t : 
NEEDLESS MARKUP 
99/99/99 
PAGE Z9 
STORE 
DEPARTMENT 
SALESPERSON 
DATE 
SALES 
COMMISSION NET SALES 
XXXXXXXXXXXX XXXXXXXXXXXX XXXXXXXXXX 99/99/99 ZZ.ZZ9.99 
Z.ZZ9.99 ZZ.ZZ9.99 
NEEDLESS MARKUP TOTALS 
ZZZ.ZZ9.99 ZZ.ZZ9.99 ZZZ.ZZ9.99 
Processing Requirements: 
1. Sort the incoming sales file by store, within store by department, and within department 
by salesperson. 
2. Read the file of sorted sales records, and for each record read: 
a. Calculate the commission by multiplying the sales amount by the commission rate. 
b. Calculate the net sales by subtracting the commission from the sale amount. 
c. Expand the store code via a direct lookup: 

Project 
14-6 
LOCATION CODE 
LOCATION NAME 
1 
Bal Harbor 
2 
Dadeland 
3 
The Galleria 
A 
Worth Avenue 
d. Print a detail line for each record. 
e. Increment the totals for sale amount, commission paid, and net sales. 
3. Print the totals at the end of the report. 
Hi 
Program Name: 
Sorted Zoo Program 
Narrative: 
Write a program to process a zoo's inventory file 
Input File: 
ZOO-FILE 
Input Record Layout: 01 ZOO-RECORD. 
05 ZOO-SPECIES 
PIC X(8). 
05 Z00-TYPE 
PIC X(ll). 
05 Z00-GR0UP 
PIC X(7). 
05 Z00-SEX 
PIC X. 
05 ZOO-QUANTITY 
PIC 99. 
05 ZOO-ACQUISITION-LEVEL 
PIC 99. 
05 ZOO-SPECIE-VALUE 
PIC 9(6)V99 
Test Data: 
W h a 1 e 
H u m p b a c k 
Mamma 1 
F 0 1 0 0 1 2 5 0 9 0 0 1 
T i g e r 
W h i t e 
Mamma 1 
F 0 5 0 1 6 6 0 0 8 5 0 8 
P a r r o t 
M a c a w 
B i r d 
M 0 5 0 0 0 6 6 0 0 0 0 5 
T i g e r 
W h i t e 
Mamma 1 
M 0 7 0 1 5 6 0 0 8 5 0 5 
P a r r o t 
M a c a w 
B i r d 
F 1 2 0 0 0 7 5 0 9 9 1 5 
B e a r 
B l a c k 
B e a r 
Mammal 
M 0 0 0 1 0 2 3 3 0 5 0 2 
R a y 
M a n t a 
F i s h 
F 0 4 0 0 0 4 0 0 4 0 0 2 
W h a l e 
K i l l e r 
Mammal 
F 0 2 0 0 4 5 0 0 5 0 0 2 
R a y 
M a n t a 
F i s h 
M 0 2 0 0 0 4 5 0 0 5 0 4 
W h a l e 
K i l l e r 
Mammal 
M 0 1 0 0 4 2 0 0 5 0 0 1 
S h a r k 
G r e a t 
W h i t e F i s h 
F 0 1 0 1 2 0 1 2 0 0 0 4 
T i g e r 
B e n g a l 
Mamma 1 
M 0 2 0 0 4 0 2 0 9 0 0 2 
S h a r k 
Ma ko 
F i s h 
F 0 2 0 0 0 8 9 9 0 0 0 2 
W h a l e 
H u m p b a c k 
Mammal 
M 0 0 0 0 1 7 5 0 9 0 0 1 
B e a r 
G r i z z l y 
Mamma 1 
F 0 3 0 0 9 0 0 0 0 0 0 2 
S h a r k 
Ma ko 
F i s h 
M 0 6 0 0 0 9 5 0 0 5 0 8 
B e a r 
B l a c k 
B e a r 
Mamma 1 
F 0 3 0 1 0 2 3 3 0 5 0 3 
P a r r o t 
C o c k a t o o 
B i r d 
F 4 5 0 0 0 3 0 5 0 4 3 0 
B e a r 
G r i z z l y 
Mamma 1 
M 0 4 0 0 9 1 0 1 0 0 0 3 
S h a r k 
G r e a t 
W h i t e;F i s h 
M 0 4 0 1 1 3 0 0 0 0 0 4 
T i g e r 
B e n g a l 
Mamma 1 
F 1 0 0 0 2 0 5 0 8 0 0 8 

Appendix 
G 
Projects 
Report Layout: 
Wild Kingdom Zoo Inventory Report 99/99/99 
Group 
Species 
XXXXXXX XXXXXXXX 
Type 
Sex 
Value Quantity 
XXXXXXXXXXX X ZZZ.ZZ9.99 Z9 
Page Z9 
No. to 
Total 
Acquire 
ZZZ.ZZ9.99 
Z9 
Total for Wild Kingdom 
ZZ9 
Z.ZZZ.ZZ9.99 ZZ9 
Processing Requirements: 
1. Sort the incoming animal file by group, within group by species, and within species 
by type. 
2. Read the file of sorted animal records, and for each record read: 
a. Calculate the value of each animal (quantity times value). 
b. Determine whether acquisition of addition animals is justified; the zoo should 
acquire more animals if the acquisition level is below the quantity level. 
c. Print animal information in that record and calculated values on a detail line. 
d. Accumulate the animal quantity totals, total values, and acquisition totals. 
3. After all records have been read, print totals for Wild Kingdom. 
Program Name: 
Sorted PC Software Program 
Narrative: 
Write a program to process a PC software file to determine totals for PC software totals. 
Input File: 
PC-SOFTWARE-FILE 
Input Record Layout: 01 PC-SOFTWARE-RECORD-IN. 
05 PC-ORDER-INFO. 
10 PC-ORDER-NO 
10 PC-ORDER-TYPE 
10 PC-CUSTOMER-NAME 
05 PC-PURCHASE-INFO. 
10 PC-QUANTITY 
10 PC-PRICE 
10 PC-DATE 
05 PC-PROGRAM-INFO. 
10 PC-PROGRAM-ID. 
15 PC-PROGRAM-NO 
15 PC-PLATFORM-CODE 
10 PC-PROGRAM-NAME 
10 PC-VENDOR 
PIC 9(5). 
PIC X. 
PIC X(16). 
PIC 999. 
PIC 9(3)V99. 
PIC 9(6). 
PIC 9(4). 
PIC X. 
PIC X(16). 
PIC X(16). 

Test D a t a : 
0 2 6 3 4 P Z e u q z a v - R a l l i v 
0 1 5 0 2 8 9 9 0 2 0 3 9 3 5 5 1 4 W E n t e r t a i n m n t 
P a c M i c r o s o f t 
7 9 4 5 6 P R a c a l 
D a t a c o m m 
0 0 3 3 3 4 9 5 0 2 0 1 9 3 56 53D 1 - 2 - 3 2 . 4 
L o t u s 
7 4 5 2 3 P A m e r i c a n 
E x p r e s s 0 0 8 0 1 9 0 0 1 2 2 2 9 2 3 3 3 8 W M o n e y 
2 . 0 
M i c r o s o f t 
1 347 3 P R a c a l 
D a t a c o m m 
0 3 5 0 8 4 9 5 0 9 2 4 9 2 3 1 4 6 D N o r t o n 
A n t i - V i r u S y m a n t e c 
3 4 3 4 2 R N e i m a n 
M a r c u s 
0 2 5 3 2 8 9 5 0 9 2 5 9 2 8 0 0 0 W P e r s u a s i o n 
2 . 1 
A l d u s 
: 6 3 4 5 2 P A m e r i c a n 
E x p r e s s 0 1 0 0 9 9 0 0 0 1 1 6 9 3 3 4 2 4 W 1 - 2 - 3 U p g r a d e 
L o t u s 
5 3 6 2 3 P R a c a l 
D a t a c o m m 
0 3 5 2 4 9 0 0 0 1 3 0 9 3 5 7 9 9 W A m i P r o 
3 . 0 
L o t u s 
4 3 6 4 6 P N e i m a n 
M a r c u s 
0 1 8 3 2 5 0 0 0 1 0 3 9 3 9 6 9 5 D B o r 1 a n d 
C + + 3 . 1 
B o r l a n d 
I n t ' l 
43 62 3 P R a c a l 
D a t a c o m m 
0 3 0 0 9 9 0 0 0 2 2 2 9 3 3 4 2 4 W 1 - 2 - 3 U p g r a d e 
L o t u s 
2 7 3 4 5 R N e i m a n 
M a r c u s 
0 0 3 1 3 9 0 0 1 0 1 5 9 2 6 2 2 3 W G a 1 1 e r y E f f e c t s 
A l d u s 
5 8 4 2 4 R A m e r i c a n 
E x p r e s S 0 0 5 3 3 4 9 5 0 1 1 6 9 3 5 6 5 3 D 1 - 2 - 3 
2 . 4 
L o t u s 
6 4 5 6 4 P N e i m a n 
M a r c u s 
0 1 5 4 9 8 9 5 0 9 2 5 9 2 1 3 3 2 W P a g e m a k e r 
5 . 0 
A l d u s 
4 7 6 3 5 P Z e u q z a v - R a l l i v 
0 1 5 0 3 8 9 5 0 2 0 3 9 3 2 8 5 8 D F 1 i g h t 
S i m u l a t o rM i c r o s 0 f t 
4 6 3 5 3 P R a c a l 
D a t a c o m m 
07 5 0 9 9 9 9 122 1 9 2 2 3 5 9 W N o r t o n 
D e s k t o p 
S y m a n t e c 
6 3 4 5 4 P Z e u q z a v - R a l 1 i v 
0 1 5 2 9 9 0 0 0 2 0 3 9 3 2 8 5 6 W E x c e l 
4 . 0 
M i c r o s 0 f t 
8 4 5 6 3 R R a c a l 
D a t a c o m m 
0 8 5 0 9 9 9 9 1 2 2 1 9 2 3 7 8 4 W N o r t o n 
B a c kk up 
S y m a n t e c 
4 5 3 6 4 P Z e u q z a v - R a l 1 i v 
0 1 5 2 9 9 0 0 0 2 0 3 9 3 7 3 8 7 W P o w e r P o 
i n t 
3 . 0 
M i c r o s 0 f t 
;4453 5 P R a c a l 
D a t a c o m m 
0 5 5 3 4 8 9 5 1 2 2 3 9 2 3 5 2 3 W F r e e l a n 
c e 
2 . 0 
L o t u s 
34 59 3 P Z e u q z a v - R a l 1 i v 
0 1 5 2 9 9 0 0 0 2 0 3 9 3 6 1 9 5 W W o r d 
2 . 0 
M i c r o s 0 f t 
7 4 3 8 7 P N e i m a n 
M a r c u s 
0 1 8 3 1 8 5 0 1 0 0 7 9 2 6 2 4 2 D Q u a t t r o 
P r 0 4 . 0 B o r 1 a nd 
I n t 
2 4 2 5 6 P R a c a l 
D a t a c o m m 
0 0 5 3 9 9 0 0 O 2 0 1 9 3 5 4 1 7 D 1 - 2 - 3 
3 . 1 P I u s 
L o t u s 
7 5 3 5 7 R N e i m a n 
M a r c u s 
0 1 5 5 2 9 9 5 1 1 2 5 9 2 1 5 1 4 D P a r a d o x 
4 . 0 
B o r 1 a nd 
I n t 
2 4 2 4 6 R A m e r i c a n 
E x p r e s S 0 1 0 3 9 9 0 0 0 1 2 0 9 3 5 4 1 7 D 1 - 2 - 3 
3 . 1 P I u s 
L o t u s 
M53iRP\3Cu! 
DutacoiTim 
0 2 0 3 3 5 0 0 1 0 1 4 9 2 2 7 5 5 W 1 - 2 - 3 
L o t u s 
2 3 3 3 3 P A m e r i c a n 
E x p r e s S 0 5 0 3 3 5 0 0 0 1 1 6 9 3 2 7 5 5 W 1 - 2 - 3 
L o t u s 
3 2 4 5 3 P R a c a l 
D a t a c o m m 
1 2 5 0 8 9 00 02 1 5 9 3 7 0 l O W W i n d o w s 
3 . 1 
M i c r o s 0 f t 
7 4 3 8 7 P N e i m a n 
M a r c u s 
0 0 5 1 9 9 0 0 12 1 7 9 2 7 5 4 0 W I n t e l 1 i D r a w 
1 . 0 A 1 d u s 
8 5 6 3 4 R A m e r i c a n 
E x p r e s s 0 1 5 3 4 8 9 5 0 2 2 6 9 3 3 5 2 3 W F r e e l a n 
c e 
2 . 0 
L o t u s 
4 3 2 4 4 P A m e r i c a n 
E x p r e s s 0 2 0 1 2 9 0 0 1 1 2 0 9 2 2 7 3 5 W W o r k s 
2 . 0 
M i c r o s 0 f t 
4 9 7 8 5 P Z e u q z a v - R a l l i v 
0 5 5 0 2 3 0 0 0 1 1 3 9 3 1 1 6 2 D M i c k e y & F r i e n d s 
W a l t 
D i s n e y 
4 3 3 5 2 P R a c a l 
D a t a c o m m 
0 2 5 4 4 5 9 5 1 1 1 4 9 2 7 3 8 8 W P r o j e c t 
.3 • 0 
M i c r o S 0 f t 
4 7 6 3 3 P Z e u q z a v - R a l l i v 
0 1 5 0 2 9 0 
0 0 1 1 3 9 3 2 6 2 9 D M i c k e y ' s 
1 23 ' s 
W a l t 
D i s n e y 
5 6 3 5 2 P N e i m a n 
M a r c u s 
0 2 5 0 8 9 0 0 1 0 1 6 9 2 1 6 2 4 W V i s u a l 
B a s i c 
2 . 0M i c r o S 0 f t 
4 6 5 2 3 P Z e u q z a v - R a l l i v 
0 1 5 0 3 2 0 0 0 2 0 3 9 3 8 7 3 1 W D a s h b o a r d 
1 . 0 
H e w 1 e t t - P a c 
4 3 2 7 4 P R a c a l 
D a t a c o m m 
0 9 0 4 7 9 0 0 1 2 
1 4 9 2 6 1 8 8 D F o x P r o 
2 . 0 
M i c r o S 0 f t 
2 6 3 4 2 P Z e u q z a v - R a l 1 i v 
0 1 5 0 2 9 0 0 0 1 1 39 3 2 6 2 4 D M i c k e y
 
1 s 
A B C ' s 
W a l t 
D i s n e y 
Comp. 
2 6 4 3 7 P N e i m a n 
M a r c u s 
0 9 5 0 5 9 0 0 1 22 6 9 2 1 6 2 0 D M S - D 0 S 6 
U p g r a d e M i c r o s o f t 
3 7 4 6 6 P A m e r i c a n 
E x p r e s s 1 2 5 0 5 9 0 0 1 0 1 6 9 2 1 6 2 0 DMS - DOS 6 
U p g r a d eM i c r o s o f t 
4 7 3 2 4 R N e i m a n 
M a r c u s 
0 4 5 0 9 5 0 0 1 1 1 4 9 2 2 9 0 4 D W o r k s 
2 . 0 
M i c r o s o f t 
2 6 4 3 7 P R a c a l 
D a t a c o m m 
0 4 5 0 5 9 0 0 10 1 6 9 2 1 6 2 0 D M S - D 0 S 6 
U p g r a d e M i c r o s o f t 
2 4 3 6 4 P Z e u q z a v - R a l 1 i v 
0 1 5 1 0 9 0 0 0 2 0 3 9 3 8 1 0 1 W N e w W a v e 
4 . 0 
H e w l e t t - P a c k a r d 
6 3 4 5 4 P N e i m a n 
M a r c u s 
0 3 5 2 9 9 0 0 0 2 1 7 9 3 2 8 5 6 W E x c e 1 
4 . 0 
M i c r o s o f t 
9 4 5 3 4 P Z e u q z a v - R a l 1 i v 
0 1 50 3 4 0 0 0 2 0 3 9 3 664.9 WS t a r 
T r e k : S c r e e n B e . r k e l e y 
S y s t e m s : 
4 8 5 3 6 P N e i m a n 
M a r c u s 
0 5 5 2 9 9 0 0 0 2 1 7 9 3 7 3 8 7 W P o w e r P o i n t 
3 . 0 
M i c r o s o f t 
7 3 6 2 3 P R a c a l 
D a t a c o m m 
0 1 02 69 0.0 1 2 2 2 9 2 38 0 4 DWo r d P e r f,e c t 
5 . 1 
Wo r d P e r f e c t 
C o r p 

A
p
p
e
n
d
i
x 
G 
— Projects 
Report Layout: 
Software R Us, Inc. 99/99/99 
PAGE Z9 
Customer 
Vendor 
Platform 
Program 
XXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXX 
XXXXXXX 
XXXXXXXXXXXXXXXX 
Quantity 
ZZ9 
Price 
ZZ9.99 
Total 
ZZ9.99 
Total for Software R Us 
1,119 
Z.ZZ9.99 
Processing Requirements: 
1. Sort the incoming PC software file by customer, within customer by vendor, and within 
vendor by platform. 
2. Read the file of sorted PC software records, and for each record read: 
a. Calculate the total for each program by multiplying the quantity by the price. 
b. Determine whether the order is either a purchase (P) or a return (R) by examining 
the order type field. If the order is a return, then the quantity and total calculated 
should be negated. Make sure your report will show this (use CR, DB, +, or -
editing symbols). 
c. Print information in that record and total on a detail line. Expand the platform code 
as follows: "D" for "DOS", and "W" for "Windows". Print the platform name only for 
the first detail line. 
d. Accumulate totals for quantity and total. 
3. After all the records have been read, print company totals for Software R Us. 
Program Name: 
Video Program 
Narrative: 
Write a program to process a video file to determine totals for video rental and sales 
revenue. 
Input File: 
VIDEO-FILE 
Input Record Layout: 01 VIDEO-RECORD-IN. 
05 VID -TITLE-INF0. 
10 VID-TITLE 
PIC X(19). 
10 VID-CATEG0RY 
PIC X(ll). 
10 VID-RATING 
PIC X(5). 
05 VID--RENTAL-INFO. 
10 VID-RENTAL-FEE 
PIC 99V99. 
10 VID-RENTED 
PIC 9(3). 
05 VID--SELL-INFO. 
10 VID-SELL-PRICE 
PIC 9(3)V99 
10 VID-S0LD 
PIC 9(3). 
10 VID-RETURNED 
PIC 9(3). 
05 VID- STORE 
PIC X(10). 

Project 
14-8 
T e s t Data: 
R o c k y 
H o r r o r 
D r a m a 
P G - 1 3 0 2 0 0 4 0 0 0 5 9 9 5 1 0 1 0 5 0 C o C O 
G r o v e 
D i r t y 
H a r r y 
A c t i o n 
R 
0 1 7 5 0 1 0 0 2 0 0 0 0 2 5 0 0 2 M i am i 
B a s i c 
I n s t i n c t 
New 
R e l e a s e R 
0 3 0 0 2 0 0 0 3 9 9 5 0 9 9 0 0 2 H i a l 
e a h 
My 
G i r l 
D r a m a 
PG 
0 2 0 0 0 7 0 0 2 0 0 0 0 6 0 0 0 5 M i am i 
B c h 
C u t t i n g 
E d g e 
D r a m a 
P G - 1 3 0 2 5 0 1 0 0 0 2 0 0 0 0 3 5 0 0 8 C O c 0 G r o v e 
L e t h a l 
W e a p o n 
I I I 
A c t 
i on 
R 
0 3 0 0 1 5 0 0 2 9 9 5 1 0 3 0 0 0 M 1 am i 
C a n d y 
M a n 
New 
R e l e a s e R 
0 3 0 0 2 0 0 0 5 9 9 5 1 0 5 0 4 0 H i a l e a h 
C a p e 
F e a r 
D r a m a 
R 
0 2 0 0 0 8 0 0 1 9 9 5 0 2 0 0 0 2 M i am i 
B c h 
N i g h m a r e 
on 
E l m 
S t 
H o r r o r 
R 
0 2 5 0 0 6 0 0 1 9 9 5 0 0 6 0 0 6 F t 
L a u d 
ET 
C h i 1 d r e n s 
G 
0 1 5 0 0 6 0 0 1 9 9 5 0 4 5 0 1 2 H i a l e a h 
i C a d d y 
S h a c k 
C o m e d y 
PG 
0 1 0 O 0 4 5 0 1 0 9 5 0 2 3 0 0 5 M i am i 
C a d d y 
S h a c k 
C o m e d y 
PG 
0 1 0 0 0 4 5 0 1 0 9 5 0 2 3 0 0 5 C O c 0 G r o 
v e 
F i n a l 
A n a l y s i s 
S u s p e n s e 
R 
0 3 0 0 1 2 0 0 2 9 9 5 0 7 6 0 0 3 M i ami 
B e h 
,D r . 
G i g g l e s 
New 
R e l e a s e R 
0 3 0 0 ' 3 0 0 0 7 7 9 5 0 9 2 0 3 0 H i a l 
e a h 
S t a r 
W a r s 
I I 
A c t i o n 
G 
0 1 7 5 0 5 0 0 1 9 9 5 0 5 0 0 2 0 M i am i 
W a y n e ' s 
W o r l d 
C o m e d y 
PG 
0 3 0 0 0 5 0 0 1 5 9 5 0 4 5 0 5 5 M 1 am i 
C a r e 
B e a r s 
C h i 1 d r e n s 
G 
0 1 O O O 7 5 O O 9 9 5 0 3 5 0 O 3 H i a l e a h 
iHa 1 1 owe e n 
H o r r o r 
PG- 1 3 0 2 5 0'0 4 0 0 1 9 9 5 0 9 0 0 9 5 F t 
L a u d 
D a n c e s 
w i t h 
W o l v e s 
D r a m a 
R 
0 3 0 0 1 0 0 0 4 9 9 5 0 1 0 0 0 0 C O c 0 G r o v e 
T h e 
B l u e s 
B r o t h e r s 
C o m e d y 
PG 
0 2 0 0 0 100 1 0 9 5 0 1 5 0 0 5 C O C 0 G r o 
v e 
:0ne 
F l e w 
O v e r 
D r a m a 
R 
0 1 7 50250 1 09 5009OOOCo 
C 0 
G r o v e 
T h e 
B i r d s 
H o r r o r 
P G -
1 3 0 1 5 
0:0 1 0 0 1 4 9 5 0 1 0 0 0 0 F t 
L a u d 
T h e 
F l y 
S u s p e n s e 
R 
0 2 0 0 0 7 5 0 2 9 9 5 0 6 5 0 0 5 M i a m i 
B e h 
;P i n n o c h i o 
C h i 1 d r e n s 
G 
0 1 0 0 0 3 5 0 1 4 9 5 0 8 0 0 0 3 H i a l 
e a h 
T h e 
L i t t l e 
Me r m a i d 
Ch i 1 d r e n s 
G 
0 2 5 0 2 0 0 0 1 9 9 5 0 9 8 0 0 3 H i a l e a h 
To 
K i l l 
a Mo c k i ti y . 
D i d 
III d 
P G 
0 i 0 0 0 1 0 0 0 9 9 5 0 0 2 0 0 1 n i 
am i 
B e h 
S n e a k e r s 
New 
R e 1 e a s e R 
0 3 0 0 4 0 0 0 7 5 0 0 1 2 5 0 0 0 H i a l 
e a h 
IT h e 
S h i n i n g 
S u s p e n s e 
R 
0 1 5 0 0 1 5 0 1 5 0 0 0 1 0 0 0 4 F t 
L a u d 
T2 
- 
J u d g e m e n t 
D a y 
New 
R e l e a s e R 
0 3 0 0 3 5 0 0 3 9 9 5 1 3 5 0 0 1 H 1 a l e a h 
H e l l 
R a i s e r 
I I 
H o r r o r 
R 
0 1 50,0 7 70 1 0 9 5 0 7 5 0 8 0 f t 
L a u d 
:W a y n e ' s 
W o r l d 
C o m e d y 
PG 
0 3 0 0 0 5 0 0 1 5 9 5 0 4 5 0 5 5 C O c 0 G r o 
v e 
S t a r 
W a r s 
A c t i o n 
G 
0 1 7 5 0 5 0 0 1 4 9 5 0 3 0 0 1 0 M i am i 
B e a u t y 
& 
t h e 
B e a s t 
C h i 1 d r e n s 
G 
0 3 0 0 2 0 0 0 1 9 9 5 2 0 0 0 0 0 H i a l 
e a h 
Report Layout: 
BlokBuzter Monthly Video Rentals & Sales 99/99/99 
PAGE Z9 
Rental Information 
Sell Information 
Category 
Rating Movie Title 
Fee # Rented 
Revenue 
Price 
Net 
Revenue 
XXXXXXXXXXX XXXXX 
XXXXXXXXXXXXXXXXXXX Z9.99 
ZZ9 
ZZ9.99 
ZZ9.99 
ZZ9 
ZZ9.99 
Total for BlokBuzter 
Z.ZZ9 
Z.ZZ9.99 
Z.ZZ9 
Z.ZZ9.99 
Processing Requirements: 
1. Sort the incoming video file by store, within each store by rating, and within each rating 
by movie title. 
2. Read the file of sorted video records, and for each record read: 
a. Calculate the rental revenue by multiplying the rental fee by the number of 
times rented. 

A
p
p
e
n
d
i
x 
G 
Projects 
b. Calculate the net sales by subtracting the videos returned from the videos sold. 
Returns are accepted from other stores so your net could be negative! Make sure 
your report will show this (use CR, DB, +, or - editing symbols). 
c. Calculate the sales revenue for each movie by multiplying the selling price by the 
net sales. 
d. Print a detail line. 
e. Accumulate totals as Indicated on the report layout. 
3. After all the records have been read, print totals for BlokBuzter. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Program Name: 
Price Break Report (Continuation of Project 14-1) 
Narrative: 
Write a control break program to determine whether a customer receives a price break 
based on quantity ordered, and calculate the unit price and extended price. Create a 
report which prints each customer's order as well as the total ordered for each customer 
and a grand total for the company. 
Input File: 
Order Transaction File 
Input Record Layout: 
Order Record 
Customer Number 
Quantity Ordered 
Item Number 
Unit Price 
Salesrep Number 
1 ... 8 
9 
10 
... 12 
13 ... 17 
18 
19 (2 decimals) 23 
24 
... 27 
Test Data: 
Use the same test data as Project 14-1. 
Report Layout: 
You may continue to use the report layout you designed in Project 7-2, or utilize the 
following specifications. 
Two-Level Report Layout: 
AUSTIN RETAIL COMPANY 
SALESREP 
XXXX 
REGION AREA: XXXXXXXXXXXXXXX 
CUSTOMER NUMBER: 
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$$.99 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$$.99 
CUSTOMER TOTAL SALES: 
$$,$$$ ,$$$,$$$.99 

Project 
15-1 
Three-level Report Layout: 
CUSTOMER NUMBER-
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$1 5.99 
XXXXX 
ZZ9 
$$$$.99 
$$, $$$, $$! 5.99 
CUSTOMER TOTAL SALES : 
$$,$$$,$$$,$$$. 99 
SALESREP TOTAL SALES 
$$,$$5 ,$$$,$$$.99 
SALESREP: 
XXXX 
REGION AREA: XXXXXXXXXXXXXXX 
CUSTOMER NUMBER: 
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
i t , j>4> $ , J J J 5.99 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$! 5.99 
CUSTOMER TOTAL SALES 
$$,$$3 ,$$$,$$$.99 
CUSTOMER NUMBER: 
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$* 5.99 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$ 5.99 
CUSTOMER TOTAL SALES 
$$,$$5 ,$$$,$$$.99 
SALESREP TOTAL SALES 
$$,$$$ ,$$$,$$$.99 
TOTAL SALES FOR COMPANY: 
$$,$$$ ,$$$,$$$.99 
AUSTIN RETAIL COMPANY 
REGION AREA: 
XXXXXXXXXXXXXXX 
SALESREP: 
XXXX 
CUSTOMER NUMBER: 
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$' 5.99 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$! 1.99 
CUSTOMER TOTAL SALES: 
$$,$$$ ,$$$,$$$.99 
CUSTOMER NUMBER: 
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$$.99 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$: 5.99 
CUSTOMER TOTAL SALES: 
$$,$$$ ,$$$,$$$.99 
SALESREP TOTAL SALES: 
$$,$$$ ,$$$,$$$.99 
REGION TOTAL SALES: 
$ $ > $ $ $ ,$$$,$$$.99 
TOTAL NUMBER OF SALESREP IN REGION: 
ZZZ9 
REGION AREA: 
XXXXXXXXXXXXXXX 
SALESREP: 
XXXX 
CUSTOMER NUMBER: 
XXXXXXXX 
ITEM 
QUANTITY 
UNIT 
EXTENDED 
NUMBER 
ORDERED 
PRICE 
PRICE 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$ 5.99 
XXXXX 
ZZ9 
$$$$.99 
$$,$$$,$$ 1.99 
CUSTOMER TOTAL SALES: 
$$,$$$,$$$,$$$ .99 
SALESREP TOTAL SALES: 
$$ s$$$-$$$ s$$$ 99 
REGION TOTAL SALES: 
$$>$$$>$$$»$$$ 99 
TOTAL NUMBER OF SALESREP IN REGION: 
ZZZ9 
TOTAL SALES FOR COMPANY: 
$$,$$$,$$$,$$$ 99 

Appendix 
G 
Projects 
T w o - l e v e l 
program Name: 
Narrative: 
Input File: 
Test Data: 
Order Transaction File Validation 
This project builds on Project 14-2, utilizing more advanced programming techniques 
such as table handling, redefines, and control break logic. Write a data validation 
program that will validate an order transaction file. 
ORDER-TRANSACTION-FILE, same as Project 14-2. 
Same as Project 14-2. 
Report Layout: 
Same as Project 14-2. 
Processing Requirements: 1. Read a file of order transaction records. 
2. Sort the order transaction records so that all records for one order can be processed 
together, and so that the record types 1, 2, and 3 are in the appropriate order. 
3. The current run date is typically accepted from a file, but for this lab set up a literal in 
working storage with the run date as November 2, 1992. 
4. Validate each input record field for all of the following: 
All validations from Project 8-1, Project 15-2. 
Each order must have a type 1 record and cannot have more than 1 type 1 record. 
Each order must have a type 2 record and cannot have more than 1 type 2 record. 
Each order must have at least 1 type 3 record and can have up to 5 type 3 records. 
p r o c e s s i n g Requirements: 1. Perform an internal sort on the fiie of customer records so that the report will break on 
customer number within salesrep number. 
2. Read the sorted file of order records. 
3. For every record read: 
a. Determine whether the customer will receive a discount. The discounting of an item 
is based on specifications in Project 13-1. 
b. Calculate the unit price by applying the appropriate discount as determined in 2a. 
c. Calculate the extended price by multiplying the quantity ordered by the unit price. 
d. Accumulate the customer's and the company's order total. 
4. Print the customer number, item number, quantity ordered, unit price (calculated), and 
extended price for each customer record. Single-space the output. Use group indication 
when printing the salesrep number and customer number, only print the salesrep 
number and customer number when the customer number changes. Print the totals 
when appropriate. Double-space between headings and totals. 
T h r e e - l e v e l Extension: 
Extend the report to Include a third (higher-level) control break on region as shown in the 
report format. Begin each region on a new page (expand the region area In the heading) 
and include multiple salesreps in a region on the same page. Be sure to modify the 
format of the heading and detail lines, to change the SORT statement to include the extra 
level control break, and to modify the program to increment totals as necessary. 

Project 
15-3 
(Hint: in order to process the order in its entirety, you will need to process the order 
using control bieak logic, and you will need io hold onto ali the records for the order in 
a table until ready to process,) 
5. If an error occurs in any part of the order, write the entire order, including all type 1, 2, 
and 3 records, to an error file. An order may contain more than one error, and all errors 
are to be flagged. 
6. Valid records are to be written to either a Valid Transaction File or a Future/'Back-order 
File. Both files should be the same format as the input Order Transaction file, with the 
exception that the quantity code on the Type 3 record should be converted to the 
Quantity Amount, as in Project 14-2. 
7. If the hold delivery date is greater than the current run date of November 2, 1992, then 
write the entire order, including the type 1, 2, and 3 records, to the Future/Back-order 
Transaction File; otherwise write the order to the new Order Transaction File, assuming 
that the order passed the validation. 
Program Name: 
Narrative: 
Input File: 
Input Record Layout: 
Test Data: 
Two-level Report Layout: 
Car Sales Control Break (Continuation of Project 14-3) 
Develop a control break program to process a sales file in order to determine totals by 
year, salesperson, and dealer, the choice between a two- or three-level report is 
between you and your instructor. 
SALES-FILE 
Use the same record layout as Project 14-3. 
Use the same test data as Project 14-3. 
VERY VERY NICE CARS INC. 
salesperson name COMMISSION REPORT AS OF 99/99/99 
YEAR: 9999 
CAR INFORMATION 
MAKE 
MODEL 
XXXXXXXX XXXXXXXX 
CUSTOMER 
PRICE 
XXXXXXXXXX 111,119 
COMMISSION 
PAID 
ZZ.ZZ9.99 
PAGE Z9 
NET TO 
DEALER 
ZZZ.ZZ9.99 
** TOTAL FOR year 
$Z.ZZZ,ZZ9 $ZZZ,ZZ9.99 $Z,ZZZ,ZZ9.99 
* 
TOTAL FOR salesperson name $Z,ZZZ,ZZ9 $ZZZ,ZZ9.99 $Z.ZZZ,ZZ9.99 
VERY VERY NICE CARS TOTALS 
$Z,ZZZ,ZZ9 $ZZZ,ZZ9.99 $Z,ZZZ,ZZ9.99 

Appendix 
G — Projects 
Three-level 
Report Layout: 
VtKI VtKT 
! i l C C 
C M I O 
dealer name COMMISSION REPORT AS OF 99/99/99 
SALESPERSON: XXXXXXXXXX 
CAR INFORMATION 
CUSTOMER 
YEAR MAKE 
MODEL 
COMMISSION 
PAID 
PRICE 
9999 XXXXXXXX XXXXXXXX XXXXXXXXXX 
111,119 
ZZ.ZZ9.99 
NET TO 
DEALER 
ZZZ.ZZ9.99 
*** TOTAL FOR year 
$1,111,119 $121,119.99 $1,111,219.99 
** TOTAL FOR salesperson name $1,111,119 $111,119.99 $1,111,119.99 
* 
TOTAL FOR dealer name 
$1,111,119 $111,119.99 $1,111,119.99 
VERY VERY NICE CARS TOTALS 
$1,112,119 $122,129.99 $Z,ZZZ,ZZ9.99 
Two-level 
Processing Requirements: 
Three-level Extension: 
1. Sort the incoming sales file by salesperson, and within salesperson by year. 
2. Read the file of sorted sales records and for each record read: 
a. Print a detail line as shown in the report layout using the processing requirements 
for Project 14-3. 
b. Increment the year, salesperson, and company totals as appropriate. 
c. Begin every salesperson on a new page with an appropriate heading containing 
the salesperson name, current date, and page number of the report. 
d. Print year and salesperson headings whenever the fields change. 
e. Print year and salesperson totals whenever the fields change. 
3. Print the Very Very Nice Cars totals on a separate page at the conclusion of the report. 
Extend the report to include a third (higher-level) control break on dealer as shown in the 
report format. Begin each dealer on a new page and include multiple salespersons in the 
same dealer on the same page. Be sure to modify the format of the heading and detail 
lines, to change the SORT statement to include the extra level control break, and to 
modify the program to increment all totals as necessary. 
Program Name: 
Bonus Control Break Program (Continuation of Project 14-4) 
Narrative: 
Write a control break program to process a bonus file to determine bonus totals by 
manager, department, and plant. The choice between a two- or three-level report is 
between you and your instructor. 
Input File: 
BONUS-FILE 

Project 
15-
Input Record Layout: 
Use the same record layout as Project 14-4 
Test Data: 
Use the same test data as Project 14-4. 
Two-level Report Layout: 
FASSSTCARS MANUFACTURERS 
BONUS REPORT FOR DEPARTMENT: XXXXXXXX 
PAGE 19 
MANAGER: XXXXXXXXXX 
SOC SEC NO 
EMPLOYEE 
999-99-9999 
XXXXXXXXXXXXXXX 
SALARY 
11,119 
BONUS 
TOTAL 
1,119 111,119 
** TOTAL FOR manager name 
1,111,119 11,119 1,111,119 
*** TOTAL FOR department name 
1,111,119 11,119 1,111,119 
TOTAL FOR FASSSTCARS 
1,111,119 22 Z19 1 111 119 
Three-level 
Report Layout: 
FASSSTCARS MANUFACTURERS 
BONUS REPORT FOR PLANT: XX 
PAGE 19 
DEPARTMENT: XXXXXXXX 
MANAGER 
SOC SEC NO 
EMPLOYEE 
SALARY 
BONUS 
TOTAL 
XXXXXXXXXX 999-99-9999 
XXXXXXXXXXXXXXX 
11,119 
1,119 111,119 
* TOTAL FOR manager name 
** TOTAL FOR department name 
*** TOTAL FOR plant name 
TOTAL FOR FASSSTCARS 
1,111,119 11,119 1,111,119 
1,111,119 11,119 1,111,119 
1,111,119 11,119 1,111,119 
1,111,119 11,119 1,111,119 
Two-level 
Processing Requirements: 
1. Sort the incoming bonus file, sorting only the employees that are eligible for a bonus 
(i.e., those that contain a "Y" in the eligibility field) by department, and within department 
by manager. 
2. Read the file of sorted bonus records and for each record read: 
a. Print a detail line as shown in the report layout using the processing requirements 
for Project 14-4. 
b. Increment the manager, department, and company totals as appropriate. 
c. Begin every department on. a new page with an appropriate heading containing the 
department name and page number of the report. 

Appendix 
G — Projects 
d. Print manager and department headings whenever the fields change. 
e. Print manager and department totals whenever the fields change. 
3. Print the FassstCars Manufacturers totals at the conclusion of the report. 
Three-level Extension: 
Extend the report to include a third (higher-level) control break on plant as shown in the 
report format. Begin each plant on a new page and include multiple departments in the 
same plant on the same page. Be sure to modify the format of the heading and detail 
lines, to change the SORT statement to include the extra level control break, and to 
modify the program to increment all totals as necessary. 
Program Name: 
Narrative: 
Input File: 
Input Record Layout: 
Test Data: 
Two-level Report Layout: 
Store Sales Commissions Program (Continuation of Project 14-5) 
Write a control break program to process sales records for Needless Markup to produce 
totals by salesperson, department, and store. The choice between a two- or three-level 
report is between you and your instructor. 
SALES-FILE 
Use the same record layout as Project 14-5. 
Use the same test data as Project 14-5. 
NEEDLESS MARKUP INC 
99/99/99 
PAGE 19 
COMMISSION REPORT FOR DEPARTMENT: XXXXXXXXXXXX 
SALESPERSON: XXXXXXXXXX 
DATE 
SALES 
COMMISSION 
NET SALES 
99/99/99 
ZZ.ZZ9.99 
Z.ZZ9.99 
ZZ.ZZ9.99 
TOTAL FOR salesperson 
ZZZ.ZZ9.99 
ZZ.ZZ9.99 
ZZZ.ZZ9.99 
TOTAL FOR department 
ZZZ.ZZ9.99 
ZZ.ZZ9.99 
ZZZ.ZZ9.99 
TOTAL FOR NEEDLESS MARKUP ZZZ.ZZ9.99 
ZZ.ZZ9.99 
ZZZ.ZZ9.99 

Project 
15-6 
Three-level 
R e p o r t L a y o u t : 
NEEDLESS MARKUP INC 
99/99/99 
COMMISSION REPORT FOR STORE: XXXXXXXXXXXX 
DEPARTMENT: XXXXXXXXXXXX 
SALESPERSON 
DATE 
SALES 
XXXXXXXXXX 
99/99/99 
ZZ.ZZ9.99 
TOTAL FOR salesperson 
ZZZ.ZZ9.99 
TOTAL FOR department name ZZZ.ZZ9.99 
TOTAL FOR store name 
ZZZ.ZZ9.99 
TOTAL FOR NEEDLESS MARKUP ZZZ.ZZ9.99 
COMMISSION 
Z.ZZ9.99 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
ZZ.ZZ9.99 
PAGE Z9 
NET SALES 
ZZ.ZZ9.99 
ZZZ.ZZ9.99 
ZZZ.ZZ9.99 
ZZZ.ZZ9.99 
ZZZ.ZZ9.99 
Two-level 
P r o c e s s i n g R e q u i r e m e n t s : 
T h r e e - l e v e l 
E x t e n s i o n : 
1. Sort the incoming sales file by department, and within department by salesperson. 
2. Read the file of sorted bonus records, and for each record read: 
a. Print a detail line as shown in the report layout using the processing requirements 
for Project 14-5, 
b. Increment the salesperson, department, and company totals as appropriate. 
c. Begin every department on a new page with an appropriate heading containing the 
department name, current date, and page number of the report. 
d. Print salesperson and department headings whenever the fields change. 
e. Print salesperson and department totals whenever the fields change. 
3. Print the Needless Markup total at the conclusion of the report. 
Extend the report to include a third (higher-level) control break on store as shown in 
the report format. Begin each store on a new page (expand the store code in the 
store heading) and include multiple departments in the same store on the same page. 
Be sure to modify the format of the heading and detail lines, to change the SORT 
statement to include the extra level control break, and to modify the program to 
increment all totals as necessary. 
Program Name: 
Zoo Control Break Program (Continuation of Project 14-6) 
Narrative: 
Write a control break program to process a zoo's inventory animal file to determine totals 
by group, species, and type of animal. The choice between a two- or three-level report is 
between you and your instructor. 
Input File: 
ZOO-FILE 

A
p
p
e
n
d
i
x 
G 
Projects 
Input R e c o r d Layout: 
T e s t D a t a : 
Two-level 
R e p o r t Layout: 
Three-level 
Report Layout: 
Two-level 
P r o c e s s i n g R e q u i r e m e n t s : 
Use the same record layout as Project 14-6. 
Use the same test data as Project 14-6. 
WILD KINGDOM ZOO 
INVENTORY REPORT -
99/99/99 
species name 
PAGE Z9 
TYPE: XXXXXXXXXXX 
SEX 
VALUE 
F 
ZZZ.ZZ9.99 
M 
ZZZ.ZZ9.99 
QUANTITY 
Z9 
Z9 
TOTAL 
ZZZ.ZZ9.99 
ZZZ.ZZ9.99 
NO. TO 
ACQUIRE 
Z9 
Z9 
** TOTAL FOR type name 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
* TOTAL FOR species name 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
TOTAL FOR WILD KINGDOM 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
WILD KINGDOM ZOC 
99/99/99 
PAGE Z9 
INVENTORY REPORT - group name 
SPECIE: XXXXXXXX 
NO. TO 
TYPE 
SEX 
VALUE 
QUANTITY 
TOTAL 
ACQUIRE 
xxxxxxxxxxxx 
F 
ZZZ.ZZ9.99 
Z9 
ZZZ.ZZ9.99 
Z9 
M 
ZZZ.ZZ9.99 
Z9 
ZZZ.ZZ9.99 
Z9 
*** TOTAL FOR type 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
** TOTAL FOR species name 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
* TOTAL FOR group name 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
TOTAL FOR WILD KINGDOM 
ZZ9 
Z.ZZZ.ZZ9.99 
ZZ9 
1. Sort the incoming zoo file by species, and within species by type. 
2. Read a file of sorted zoo records and for each record read: 
a. Print a detail line as shown in the report layout using the processing requirements 
for Project 14-6. 
b. Increment the type, species, and Wild Kingdom totals as appropriate. 
c. Begin every species on a new page with an appropriate heading containing the 
species name, current date, and page number of the report. 

Project 
15-7 
d. Print type and species headings whenever the fields change. 
e. Print type and species totals whenever the fields change. 
3. Print the Wild Kingdom totals at the conclusion of the report. 
Three-level Extension: 
Extend the report to include a third (higher-level) control break on group as shown in the 
report format. Begin each group on a new page and include multiple species in the same 
group on the same page. Be sure to modify the format of the heading and detail lines, to 
change the SORT statement to include the extra level control break, and to modify the 
program to increment all totals as necessary. 
Program Name: 
PC Software Control Break Program (Continuation of Project 14-7) 
Narrative: 
Write a control break program to process a PC software file to determine totals by 
customer, vendor, and platform. The choice between a two- or three-level report is 
between you and your instructor. 
Input File: 
PC-SOFTWARE-FILE 
Input Record Layout: 
Use the same record layout as Project 14-7. 
Test Data: 
Use the same test data as Project 14-7. 
Two-level 
Report Layout: 
SOFTWARE R US, INC 
99/99/99 
SALES REPORT FOR vendor name 
PLATFORM: XXXXXXX 
CUSTOMER 
PROGRAM NAME 
DATE 
QUANTITY 
PRICE 
XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX 99/99/99 
ZZ9 ZZ9.99 
PAGE Z9 
TOTAL 
ZZ9.99 
TOTAL FOR platform 
TOTAL FOR vendor name 
SOFTWARE R US TOTAL 
Z,ZZ9 
ZZZ.ZZ9.99 
Z.ZZ9 
ZZZ.ZZ9.99 
Z.ZZ9 
ZZZ.ZZ9.99 

A
p
p
e
n
d
i
x 
G 
Projects 
Three-level 
Report Layouts 
iuriwHKt 
K us, lml 
yy/yy/yy 
SALES REPORT FOR customer name 
m a t 
i.y 
VENDOR: XXXXXXXXXXXXXXXX 
PLATFORM 
PROGRAM NAME 
DATE 
QUANTITY 
PRICE 
TOTAL 
XXXXXXX 
XXXXXXXXXXXXXXXX 
99/99/99 
ZZ9 119.99 
ZZ9.99 
TOTAL FOR platform 
TOTAL FOR vendor name 
TOTAL FOR customr name 
SOFTWARE R US TOTAL 
Z.ZZ9 
ZZZ.ZZ9.99 
Z.ZZ9 
ZZZ.ZZ9.99 
1,119 
ZZZ.ZZ9.99 
Z.ZZ9 
ZZZ.ZZ9.99 
Two-level 
P r o c e s s i n g Requirements: 
1. Sort the incoming PC software file by vendor, and within vendor by platform. 
2. Read the file of sorted PC software records and for each record read: 
a. Print a detail line as shown in the report layout using the processing requirements 
for Project 14-7. 
b. Increment the platform, vendor, and company totals as appropriate. 
c. Begin every vendor on a new page with an appropriate heading containing the 
vendor name, current date, and page number of the report. 
d. Print platform and vendor headings whenever the fields change. 
e. Print platform and vendor totals whenever the fields change. 
3. Print the Software R Us totals at the conclusion of the report. 
T h r e e - l e v e l Extension: 
Extend the report to include a third (higher-level) control break on customer as shown in 
the report format. Begin each customer on a new page and include multiple vendors for 
the same customer on the same page. Be sure to modify the format of the heading and 
detail lines, to change the SORT statement to include the extra level control break, and to 
modify the program to increment all totals as necessary. 
'•Jt*. 
Program Name: 
Video Control Break Program (Continuation of Project 14-8) 
Narrative: 
Write a control break program to process a video file to determine totals by each store, 
category, and rating. The choice between a two- or three-level report is between you and 
your instructor. 
Input File: 
VIDEO-FILE 
Input Record Layout: 
Use the same record layout as Project 14-8. 

Project 
15-8 
Test Data: 
Use the same test data as Project 14-8. 
Two-level 
Report Layout: 
Three-level 
Report Layout: 
Blokbuzter Video 
MONTHLY VIDEO RENTALS & SALES FOR 
99/99/99 
category name 
Page Z9 
RATING: XXXXXXX 
Rental Information 
Sell Information 
MOVIE TITLE 
FEE #RENTED REVENUE 
XXXXXXXXXXXXXXXXXXX Z9.99 
ZZ9 
ZZ9.99 
PRICE 
NET 
ZZ9.99 
ZZ9 
REVENUE 
ZZ9.99 
** TOTAL FOR rating 
1,119 1,119.99 
Z.ZZ9 
Z.ZZ9.99 
* TOTAL FOR category name 1,119 1,119.99 
Z,ZZ9 
Z,ZZ9.99 
TOTAL FOR. BLOKBUZTER 
Z.ZZ9 Z.ZZ9.99 
Z,ZZ9 
Z,ZZ9.99 
Blokbuzter Video 
MONTHLY VIDEO RENTALS & SALES FOR 
99/99/99 
store name 
PageZ9 
CATEGORY: XXXXXXXXXXX 
RATING: XXXXXXX 
Rental Information 
Sell Information 
MOVIE TITLE 
FEE #RENTED REVENUE 
XXXXXXXXXXXXXXXXXXX Z9.99 
ZZ9 
ZZ9.99 
PRICE 
NET 
ZZ9.99 
ZZ9 
REVENUE 
ZZ9.99 
*** TOTAL FOR rating 
1,119 1,119.99 
Z.ZZ9 
Z.ZZ9.99 
** TOTAL FOR category name Z.ZZ9 Z.ZZ9.99 
Z.ZZ9 
Z.ZZ9.99 
* TOTAL FOR store name 
1,119 1,119.99 
Z,ZZ9 
Z.ZZ9.99 
TOTAL FOR BLOKBUZTER 
1,119 1,119.99 
Z,ZZ9 
Z.ZZ9.99 
Two-level 
Processing Requirements: 
1. Sort the incoming video file by category, and within category by rating. 
2. Read the file of sorted video records and for each record read: 
a. Print a detail line as shown in the report layout using the processing requirements 
for Project 14-8. 
b. Increment the rating, category, and Blokbuzter totals as appropriate. 

A
p
p
e
n
d
i
x 
G — 
Projects 
c. Begin every category on a new page with an appropriate heading containing the 
category name, current date, and page number ot the report. 
d. Print rating and category headings whenever the fields change. 
e. Print rating and category totals whenever the fields change. 
3. Print the BlokBuzter totals on a separate page at the conclusion of the report. 
T h r e e - l e v e l E x t e n s i o n : 
Extend the report to include a third (higher-level) control break on store as shown in the 
report format. Begin each store on a new page and include multiple categories in the 
same store on the same page. Be sure to modify the format of the heading and detail 
lines, to change the SORT statement to include the extra level control break, and to 
modify the program to increment all totals as necessary. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
Wm • 
. 
P r o g r a m N a m e : 
Invoice Program with Subprogram 
Narrative: 
input File: 
Input Record Layout: 
Write a program to produce an invoice for each record in a validated invoice file. 
INVOICE-FILE 
STATE-FILE 
01 
01 
05 
05 
INVOICE-RECORD-IN. 
05 INV-INV0ICE-N0 
PIC X(4). 
INV-DATE. 
10 INV-M0NTH 
PIC 9(2). 
10 INV-DAY 
PIC 9(2). 
10 INV-YEAR 
PIC 9(2). 
INV-CUST0MER-INF0. 
10 INV-CUST-NAME 
PIC X(10). 
INV-CUST-ADDRESS 
PIC X(10). 
INV-CUST-CITY 
PIC X(10). 
INV-CUST-STATE 
PIC XX. 
INV-CUST-ZIP 
PIC X(5). 
INV-N0-0F-ITEMS 
PIC 9. 
INV-ITEMS-ORDERED OCCURS 1 TO 4 TIMES 
10 
10 
10 
10 
05 
05 
10 
10 
DEPENDING ON 
INV-ITEM-N0 
INV-QUANTITY 
INV-
STATE-REC0RD. 
05 ST-STATE 
05 ST-Z0NE 
N0-0F-ITEMS. 
PIC 9(4). 
PIC 9. 
PIC XX. 
PIC 9. 
T e s t Data: 
2 4 6 7 1 0 0 4 f t l S c u l l y 
1 5 7 8 0 8 1 2 9 i l S c h u l t z 
0 3 4 2 0 9 1 0 9 ; l C u l v e r 
4 7 9 0 1 1 1 2 9 J 0 P e r e z 
6 8 3 6 0 7 0 4 9 i l F i x l e r 
J480703 1 8 9 j l M o r i n 
J 0 4 9 8 0 6 3 0 9 i l M u n r o e 
20 
M a i n 
S ;t 
. 
5 3 12 5 0 2 1 1 0 0 1 1 5 5 0 1 
45 
5 t h 
S t j L o s 
A n g e l : e C A 5 6 7 8 6 2 4 5 0 0 2 3 2 0 0 1 i 
1 
S u n n y 
U n S e a t t l e 
; W A S 5 9 8 6 1 9 0 0 0 3 
i 
4 
L o n g 
Dr; New 0 r 1 e a n L A 7 9 3 4 5 2 6 8 0 0 2 4 5 0 0 1 : 
3 
4 2 n d 
S t ; New Y o r k j N Y 2 0 0 0 1 2 12 5 0 1 1 5 5 0 3 
: 
9 
7 t h 
A v e ; N e w a r k 
; N J 3 069 743-200 1 9 0 0 0 3 lil 0 0 2 3 0 0 0 2 : 
10 
L o n g 
S t T u l s a 
: 0 K 5 9 3 4 5 1 9 0 0 0 5 

Project 
16-1 
Report Layout: 
Date 99/99/99 
Doninoe Catalog Orders 
Invoice Number 
9999 
Ship To: 
Name 
Invoice Order Date 99/99/99 
XXXXXXXXXX 
Address 
XXXXXXXXXX 
City 
State Zip 
XXXXXXXXXX 
XX 
XXXXX 
Item No. 
Description 
Qty 
Price Each 
Total Price 
Tot Ship Wt 
XXXX 
XXXXXXXXXXXXXXX 
9 
Z.ZZ9.99 
ZZ.ZZ9.99 
ZZ9.99 
XXXX 
XXXXXXXXXXXXXXX 
9 
Z.ZZ9.99 
ZZ.ZZ9.99 
ZZ9.99 
Totals 
$ZZZ.ZZ9.99 
Z.ZZ9.99 
Total delivery charge 
ZZ9.99 
Handling charge 
1.50 
Total amount 
$ZZZ.ZZ9.99 
Questions? Call Toll Free 1-800-DOMINOE 
Processing Requirements: 
1. Create an invoice, one per page, for each record read. 
a. Write appropriate invoice headings. 
b. For each item ordered: 
(1) The incoming item number is to be used to find the description, price, and 
shipping weight via a sequential lookup. Hard-code the following table in the 
program: 
Item Information 
ltem# 
Item Description 
Price (each) 
Ship Wt (each) 
1100 
Handwoven Rug 
129.00 
9.50 
1550 
Crystal Frame 
39.40 
3.00 
1250 
Floor Lamp 
99.00 
20.30 
3000 
Ceiling Fan 
299.00 
50.01 
4500 
Wicker Basket 
25.00 
2.00 
6800 
Wall Clock 
169.00 
19.30 
3200 
Ceramic Figure 
39.90 
10.00 
9000 
Wood Wall Shelf 
14.90 
1.00 
(2) Compute the total price and total shipping weight. 
(3) Write a detail line for the item. 

Appendix 
G — 
Projects 
(4) Increment appropriate invoice totals, 
c. After all the items ordered in the record have been processed, calculate the total 
delivery charge and the total invoice amount as follows: 
(1) The total delivery charge should be calculated in a subprogram. There are two 
steps in obtaining the total delivery charge: 
(a) You must first determine the appropriate zone. The incoming state is to be 
used via a binary lookup to determine the appropriate zone (there are 
three zones in total). Input-load this state/zone table (only once per 
execution of the program). The state file (16-1STAT.DAT) can be found on 
the data disk. 
(b) The total delivery charge is based on the zone and total shipping weight. 
Once the correct zone has been found, it is to be used in combination with 
the sum of the total shipping weight as follows: 
Delivery Rates 
Total Ship Wgt Range (in lbs) 
Zone Number 
From 
To (inclusive) 
Zone 1 
Zone 2 
Zone 3 
0 
2 
$4.00 
$4.25 
$4.50 
2 
4 
$5,75 
$6.25 
$6.75 
4 
9 
$7.75 
$8.50 
$9.25 
9 
2 0 
$10.75 
$12.00 
$14.75 
2 0 
3 0 
$14.00 
$15.50 
$18.25 
on 
5 0 
<M Q OE 
ct-ntz or. 
50 
7 0 
$21.25 
$25.00 
$30.50 
70 
999 
$25.50 
$29.00 
$35.00 
Develop a two-dimensional table to hold the above information and perform a table-
lookup to determine the correct charge. Establish this table via a COPY statement. 
Use a direct lookup for zone dimension. 
(2) The final total amount is calculated by adding the total price, the total delivery 
charge, and the handling charge. The current handling charge is $1.50; code 
this in your program so in the event this charge changes, it can be easily 
updated. 
d. Print appropriate totals (total price, total delivery charge, handling charge, and total 
amount) as shown on the layout. 
e. Increment the totals for price, shipping weight, total delivery charge, handling 
charge, and amount for the Summary Report (see #3). 
2. When all records have been processed, write the Summary Report, on a separate 
page, of all the totals accumulated in e. (Design your summary report.) 
Program 
N a m e : 
Narrative: 
Input File: 
Student Aid Report Program with Subprogram 
Write the program to print a detailed student aid report for all validated students and a 
summary page depicting totals for each school. 
STUDENT-FILE 
SCHOOL-FILE (See requirement 1b.) 

Project 
16-2 
Input Record Layout: 
Use the same record layout as Project 8-6. 
Smart U 
Student Aid Report 
Page 1 
99/99/99 
Student ID 
Name 
School 
Type of Aid 
Credi t 
Hours 
Total 
Tuf tion 
Total 
Aid 
Tuition 
Due 
999999999 
XXXXXXXXXXXXXXX 
XXXXXXXXXX 
XXXXXXXXXXX 
99 
$ZZZ,ZZ9 
$ZZZ,ZZ9 
$ZZZ,ZZ9 
Summary Report of Total Aid per School: 
Smart U 
Page n 
Summary Report of Total Aid per School 
99/99/99 
Total 
Total 
Tuition 
School 
Tuition 
Aid 
Due 
Art 
$ZZ,ZZZ,ZZ9 
$ZZ,ZZZ,ZZ9 
$ZZ,ZZZ,ZZ9 
University Totals 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
Processing Requirements: 
1 . For each valid record read: 
a. The incoming aid type is to be expanded via a sequential lookup. The table-lookup 
procedure should be coded in a separate subprogram. Hard-code the following 
table: 
Aid Type & Expanded Aid Types 
Aid Type 
Expanded Aid Type 
S 
Scholarship 
G 
Grant 
L 
Loan 
b. The incoming school code is to be expanded via a binary lookup. The lookup 
procedure should be coded in a separate subprogram. Use the following table and 
input-load it in the subprogram (only once per execution of the program). 
Test Data: 
Use the validated student file from Project 8-6. 
R e p o r t Layout: 
Detailed S t u d e n t Aid Report: 

Appendix 
G — 
Projects 
School Codes & Expanded Schools 
School 
Code 
Expanded 
School 
School 
Code 
Expanded 
School 
ART 
Arts & Sciences 
LAW 
Law 
BUS 
Business 
MED 
Medicine 
COM 
Communications 
MUS 
Music 
ENG 
Engineering 
c. Calculate total tuition based on $300 per credit hour. 
d. Calculate total aid based on the percent of total tuition. This percent is determined 
by a combination of credit hours and GPA as follows: 
Credit Hours 
GPA 
from 
to 
from 
2.5 
to 
3 
from 
>3 
to 
3.5 
from 
>3.5 
to 
4.0 
1 
3 
30% 
40% 
50% 
>3 
6 
44% 
52% 
63% 
>6 
9 
53% 
64% 
72% 
>9 
12 
62% 
75% 
84% 
>12 
15 
70% 
80% 
92% 
>15 
18 
75% 
88% 
100% 
Develop a two-dimensional table to hold the above information and perform 
a table-lookup to determine the percent to be used. Establish this table via a 
COPY statement. 
e. Calculate tuition due by subtracting the total aid from the total tuition. 
f. Write a detail line with the information shown on the Detailed Student Aid Report, 
printing ten students per page. 
g. Increment the school's totals for total tuition, total aid, and total due. (Establish a 
table to compute the aid statistics for each school that will print at the conclusion of 
processing, remembering that the number of schools is variable.) 
3. When all records have been processed, write the Summary Report of Total Aid per 
School from the table established in (g). 
Program Name: 
Salary Report Program 
Narrative: 
Write a program to print a detailed salary report and average salary summary per location 
for all employees in a validated salary file. 
Input File: 
SALARY-FILE 
LOCATION-FILE (See requirement 2b.) 

Project 
16-3 
Input Record Layout: 
Use the same record layout as Project 8-7. 
Test Data: 
Use the validated salary file from Project 8-7. 
Report Layout: 
Detailed Salary Report: 
Big Bucks, Inc. 
Page 1 
Detailed Salary Report for 99/99/99 
Soc Sec No. 
Name 
Title 
Location 
Education 
Rating 
Salary 
XXXXXXXXX 
XXXXXXXXXXXXXXX 
XXXXXXXX 
XXXXXXXXXXXX 
XXXXXXXXXXXX 
9 
$ZZZ,ZZ9 
Summary R e p o r t of Average Salaries per Location: 
Education 
Level 
Big Bucks, Inc. 
Average Salary Summary - XXXXXXXXXXXX Location for 99/99/99 
Rating 
1
2 
3 
4 
Page n 
Grade School 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
Doctorate 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
$ZZZ,ZZZ,ZZ9 
Processing Requirements: 
1. Read a file of salary records. 
2. For each record read: 
a. The incoming title code is to be expanded via a sequential lookup. The table-
lookup procedure should be coded in a separate subprogram. Establish the 
following table via the COPY statement: 
Title Codes & Expanded Titles 
Title 
Code 
Expanded 
Title 
Title 
Code 
Expanded 
Title 
010 
President 
060 
DP VP 
020 
Vice Pres 
070 
DP Mgr 
030 
Mkt VP 
080 
DP Prog 
040 
Mkt Mgr 
090 
Clerk 
050 
Mkt 
Rep 
100 
Adm Asst 
b. The incoming location code is to be expanded via a binary lookup from the 
following table which is to be input-loaded. Code the lookup and initialization in a 
subprogram (only once per execution of the program). 

A
p
p
e
n
d
i
x 
G 
Projects 
Location 
Code 
Expanded 
Location 
Location 
Code 
Expanded 
Location 
MIA 
Miami 
NY 
New York 
CHI 
Chicago 
ATL 
Atlanta 
LA 
Los Angeles 
c. The incoming education code is to be expanded via a direct lookup from the 
following table, which is to be hard-coded in your program. 
Education 
Code 
Expanded 
Education 
Education 
Code 
Expanded 
Education 
i 
Grade School 
4 
Bachelors 
2 
High School 
5 
Masters 
3 
Associates 
6 
Doctorate 
d. Write a detail line with the information shown on the Detailed Salary Report, printing 
ten employees per page. 
e. Establish a three-dimensional (5 by 6 by 5) table to compute the salary statistics for 
the 150 location-education-rating combinations. 
(1) Determine the appropriate row-column (i.e., education-rating) combination for 
each location. 
(2) Increment the employee salary total for that row-column combination for each 
location by the employee's salary. 
(3) Increment the number of employees in that row-column combination for that 
location by 1. 
3. When all employees have been processed, write the Summary Report of Average 
Salaries per Location. Obtain the average salary by dividing the salary total for each 
combination by the number of employees in that combination. Print all 150 values of 
average salaries with every location on a separate page (i.e., 30 education-rating 
combinations per page). 
Program Name; 
Stock Program 
Narrative: 
Write a program to produce a stock report for each record in a validated stock file. 
Input File: 
STOCK-FILE 
INDUSTRY-FILE (See requirement 1b.) 
Input Record Layout: 
Use the same record layout as Project 8-8. 
Test Data: 
Use the validated stock file from Project 8-8. 

Project 
16-4 
Report Layout: 
Stock Evaluation Report as of 99/99/99 
Page Z9 
Market 
Dividend 
Est. Est. Ind 
Exchange Stock 
Industry 
Price 
EPS 
Yield 
PE 
Growth 
PE 
PE Comments 
XXXXXX 
XXXXXXXX XXXXXXXXXXXXXXX ZZ9.999 Z9.9 
ZZ9.99 
ZZ9 ZZ9.99% ZZ9 
Z9 XXXXXXXXXXXXX 
Summary of Stocks to Buy as of 99/99/99 
Market 
No. of 
Exchange 
Stock 
Price 
Shares 
Total 
XXXXXX 
XXXXXXXX 
ZZ9.99 
1,119 
ZZZ.ZZ9.99 
Total 
• 
11,119 
$Z.ZZZ,ZZ9.99 
Processing Requirements: 
1. Read a file of stock records, and for each record read: 
a. Expand the exchange code, from the incoming record, to the appropriate exchange 
name as shown below. To determine the exchange name, hard-code the table in 
your program and implement a direct (positional) table lookup. 
Exchange Code 
Exchange Name 
1 
NYSE 
2 
NASDAQ 
3 
OTC 
4 
AMEX 
b. Determine the industry description and industry PE. The industry code is to be used 
to find the description and PE via a binary lookup. Input-load this table (only once 
per execution of the program). 

Appendix 
G — 
Projects 
Industry 
Code 
Industry 
Description 
Industry PE 
Range 
AIR 
Airline 
12 
AUT 
Automobile 
7 
BAN 
Bank 
7 
BEE 
Beer 
9 
CMP 
Computers 
30 
DRU 
Drugs 
15 
ELE 
Electronics 
25 
F&L 
Food & Lodging 
10 
FOO 
Food Products 
8 
OIL 
Oil 
12 
RET 
Retail 
9 
S&L 
Savings & Loan 
7 
TEL 
Telephone 
8 
c. Calculate earnings per share (EPS) by dividing the PE into the stock price, 
d. Calculate the dividend yield by dividing the stock price into the dividend. 
e. Determine the estimated annual rate ot growth in EPS (Est. Growth) over the next 
3-5 years by multiplying the annual growth rate by the risk factor. To determine the 
risk factor, hard-code the table in your program and implement a direct (positional) 
table lookup. 
Risk Code 
Risk Factor 
1 
.7 
2 
.8 
3 
.95 
4 
1.1 
5 
1.3 
f. Calculate the estimated price-to-earnings ratio (Est. PE) based on the estimated 
annual rate of growth in EPS and the current interest rate. 
(1) The current interest rate should be obtained at execution. Use appropriate 
DISPLAY/ACCEPT statements to prompt for the interest rate and to enter it. 
The current interest rate limits are from .5% to 15%. (Remember data validation.) 
(2) Develop a subprogram to determine the estimated PE. Create a two-dimensional 
table to hold the information below and perform a table lookup to determine the 
appropriate PE. Establish this table via a COPY statement in your subprogram. 

Project 
16-5 
E s t i m a t e d A n n u a l R a t e u i 
G r o w t h in E P S 
Current Interest Rate 
from 
to 
. 5 % - 7.9% 
8 % - 1 0 . 9 % 
11 - 1 5 % 
.01% 
5% 
18 
9 
6 
5.01% 
10% 
20 
15 
8 
10.01 % 
15% 
25 
20 
11 
15.01% 
20% 
30 
21 
14 
20.01% 
25% 
40 
30 
18 
25.01% 
30% 
45 
35 
21 
30.01% 
35% 
50 
40 
24 
35.01% 
130% 
65 
55 
31 
g. Determine the comments by comparing the PE in the record, estimated PE, and the 
industry PE. 
(1) Print "BUY NOW" in the comments column when the PE is less than both the 
estimated PE and the industry PE. 
(2) Print "Consider" in the comments column when the PE is less than estimated 
PE. 
(3) Print "Potential" in the comments column when the PE is less than the industry 
PE. 
h. Print a detail line for the record in the file, as shown on the layout. Detail lines are to 
be double spaced with 10 records per page. Print appropriate headings (and page 
numbers) on the top of every page in the report. 
i. Create a summary table to hold the stocks deemed to be bought. This table should 
contain the exchange, stock name, market price, and shares to purchase. 
2. When all records have been processed, create the Summary Report showing all the 
"BUY NOW" stocks and appropriate investment totals in the headings. 
Program Name: 
Electric Program 
Narrative: 
Write a program to produce an electric report for each record in a validated electric file. 
Input File: 
ELECTRIC-FILE 
TYPE-FILE (See requirement 1a.) 
Input Record Layout: 
Use the same record layout as Project 8-9. 
Test Data: 
Use the validated electric file from project 8-9. 

Appendix 
G — 
Projects 
Report Layout: 
Bright Power & Light 
Billing Report as of XXX Z9, 1999 
Page Z9 
Account 
Number 
Rate Schedule/Class of Service 
Service Used 
Meter Readings 
From 
To 
Previous 
Current 
Kilowatt Hours 
On-Peak 
Off-Peak 
Total 
Amount 
Billed 
999999 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXX Z9 XXX Z9 
11,119 11,119 
11,119 
11,119 11,119 
ZZZ.ZZ9.99 
TOTALS 
111,119 111,119 111,119 
EZ.ZZZ.ZZ9.99 
P r o c e s s i n g R e q u i r e m e n t s : 
1. Read a file of electric records; for each record read: 
a. In a subprogram, determine the corresponding description, customer charge, and 
minimum charge. The incoming account type is to be used to find the description, 
customer, and minimum charges via a binary lookup. Input-load this table (only 
once per execution of the program). 
Account 
Type 
Description 
Type, Category, Demand, Time of Use 
Customer 
Charge 
Minimum 
Charge 
CCSL1 
Comm, Curt Svc, 2000+ 
170.00 
12,670.00 
CCSL2 
Comm, Curt Svc, 2000+, ToU 
175.00 
12,699.00 
CCSM1 
Comm, Curt Svc, 500-1999 
110.00 
3,235.00 
CCSM2 
Comm, Curt Svc, 500-1999, ToU 
120.00 
3,150.99 
CCSX1 
Comm, Curt Svc, 2000+(TV) 
400.00 
13,000.00 
CCSX2 
Comm, Curt Svc, 2000+(TV), ToU 
410.00 
12,900.00 
CGSL1 
Comm, Gen Svc, 2000+ 
170.00 
12,670.00 
CGSL2 
Comm, Gen Svc, 2000+, ToU 
180.00 
12,550.00 
CGSM1 
Comm, Gen Svc, 500-1999 
41.00 
3,166.00 
CGSM2 
Comm, Gen Svc, 500-1999, ToU 
55.00 
3,100.00 
CGSN1 
Comm, Gen Svc, non-demand 
9.00 
9.00 
CGSN2 
Comm, Gen Svc, non-demand, ToU 
12.30 
12.30 
CGSS1 
Comm, Gen Svc, 21-499 
35.00 
166.25 
CGSS2 
Comm, Gen Svc, 21-499, ToU 
41.50 
1,365.00 
CGSX1 
Comm, Gen Svc, 2000+(TV) 
400.00 
12,500.00 
CGSX2 
Comm, Gen Svc, 2000+(TV), ToU 
425.00 
12,900.00 
RRSN1 
Res, Residential Svc 
5.65 
5.65 
RRSN2 
Res, Residential Svc, ToU 
8.95 
8.95 

Project 
16-5 
Demand 
Type 
Commercial Account Category 
Demand 
Type 
General Service (GS) 
Curtailable Services (CS) 
Demand 
Type 
Energy Rate 
Energy Rate 
N 
4.5640 
S 
1.8840 
M 
1.5760 
1.4730 
L 
1.5730 
1.3730 
X 
1.0140 
0.9450 
Time of Use 
Develop another subprogram to determine the appropriate energy and fuel 
rates. Create a two-dimensional table to hold the information below and perform 
a table-lookup to determine the appropriate energy and fuel rates. Establish 
this table via a COPY statement in your subprogram. The energy charge is the 
on-peak rate multiplied by the on-peak kw hours used plus the off-peak rate 
multiplied by the off-peak kw hours used. (Remember total kw hours used is 
the on-peak kw hours plus the off-peak kw hours.) This subprogram is almost 
identical to the other; debug the first before going on to this one. 
b. The energy charge is determined differently for residential and commercial accounts 
and whether the account is or is not Time of Use: 
(1) Residential Accounts 
Non Time of Use 
The first 750 kw hours used will be charged at 3.9220 per kw hour. 
Additional kw hours used will be charged at 4.9220 per kw hour. 
(Remember total kw hours used is the current reading minus the previous 
reading.) 
Time of Use 
The On-Peak kw hours used will be charged at 7.9620 per kw hour. 
The Off-Peak kw hours used will be charged at 2.7290 per kw hour. 
(Remember total kw hours used is the on-peak kw hours plus the off-peak 
kw hours.) 
(2) Commercial Accounts 
Non Time of Use 
Develop a subprogram to determine the appropriate energy charge. Create a 
two-dimensionai table to hold the information below and perform a table-
lookup to determine the appropriate energy rates. Establish this table via a 
COPY statement in your subprogram. The energy charge is energy rate 
multiplied by the kw hours used. (Remember the kw hours used is the current 
readinn minus the previous reading ) 

Appendix 
G — Projects 
Demand 
Type 
Commercial Account Category 
Demand 
Type 
General Service (GS) 
Curtailable Services (CS) 
Demand 
Type 
On-Peak 
Off-Peak 
On-Peak 
Off-Peak 
N 
8.5250 
2.7520 
S 
3.8460 
1.3550 
M 
2.7150 
1.1110 
2.6150 
1.1020 
L 
1.5730. 
1.0660 
2.7330 
1.0460 
X 
1.0820 
0.9490 
1.0620 
0.9390 
c. The fuel charge is based on the demand code in the following table. Hard-code this 
table into the program and reference it via a sequential lookup. 
Demand Code 
Fuel Rate 
N 
1.8240 
S 
1.8240 
M 
1.8230 
L 
1.8160 
X 
1.7690 
d. The demand charge is calculated by multiplying the kw demand level by the 
demand charge. The current demand charge is $6.25. Note: Residential accounts 
do not have a demand charge. 
e. Calculate the amount billed, which is the customer charge plus the energy charge 
plus the fuel charge plus the demand charge (if any). Verify the amount against the 
minimum charge; if amount calculated is less than the minimum charge, then use 
the minimum charge as the amount billed. 
f. Use a hard-coded table and a direct lookup to translate the numerical From- and 
To- month in the record to a 3-character abbreviation (using the first 3 letters of the 
month) to be printed on the detail line. 
g. Print a detail line for the record in the file, as shown on the layout. Detail lines are to 
be double spaced with 10 records per page. Print appropriate headings (and page 
numbers) on the top of every page in the report. Use the table in 1f. to create the 
format of the date as shown on the layout. 
h. Increment all totals shown in the report layout. 
2. When all records have been processed, write the totals accumulated in 1h. 
lasic Definitions for Account Codes and T y p e s : 
Type Code: 
C for Commercial Accounts 
R 
for Residential Accounts 
Category Code: 
RS for Residential Service 
GS for General Service (Commercial) 
CS for Curtailable Service (Commercial) 

Project 
16-6 
Demand C o d e : 
Demand is the kw to the nearest whole kw, as determined from the metering equipment 
for the 30-rninute period of the customer's greatest use. 
N 
for non demand 
S 
for 21 -499 kw demand 
M for 500-1999 kw demand 
L 
for 2000+ kw demand 
X 
for 2000+ Transmission Voltage kw demand 
Time of Use: 
The energy rate is determined by the time in which the electricity is used, either On-Peak 
or Off-Peak. Usually the Off-Peak rate is less than the On-Peak rate. 
On-Peak Hours are: 
from Nov 1-Mar 31, Monday-Friday, 6am-10am & 6pm-10pm 
excluding Thanksgiving, Christmas, and New Year Days 
from Apr 1 Oct 31, Monday Friday, 12noon-9pm 
excluding Memorial, Independence, and Labor Days 
1 
for non Time of Use 
2 
for Time of Use 
(EL-CURRENT-READING contains On-Peak kw hours used and EL-PREVIOUS-READING 
contains Off-Peak kw hours used.) 
Program Name: 
Extended Movies Program with Subprograms 
Narrative: 
This program extends Project 13-2 to contain two subprograms. 
Input File: 
MOVIE-EXTRA-FILE 
Input Record Layout: 
Use the same record layout as Project 13-2. 
Test Data: 
Use the same test data as Project 13-2. 
Report Layout: 
Use the same report layout as Project 13-2. 
Processing Requirements: 
Make the following changes to Project 13-2: the table-lookups for pay scale (processing 
requirement #2) and bonus (processing requirement #4) are to be implemented in a 
subprogram. 

Appendix 
G 
Projects 
Program Name: 
Narrative: 
Input File: 
Input Record Layout: 
Test Data: 
R e p o r t Layout: 
Processing Requirements: 
Extended Payroll Program with Subprogram 
This program extends Project 13-5 to contain subprograms. 
PAYROLL-FILE 
Use the same record layout as Project 13-5. 
Use the same test data as Project 13-5. 
Use the same report layout as Project 13-5. 
Make the following changes to Project 13-5: the table-lookups for taxes (processing 
requirement #2b) and insurance deduction (processing requirement #2d) are to be 
implemented in a subprogram. 
P R O G R A M M I N G 
S P E C I F I C A T I O N S 
iiiii§i!i»iiiiiMfiiiiiiiii 
Program Name: 
Extended Program Maintenance 
Narrative: 
This project deals with program maintenance, in that some ot the specifications for the 
data validation and sequential update programs presented in the chapter, have been 
changed as indicated below. Implement the changes in whatever program you deem 
appropriate. 
Input File: 
As indicated in the chapter. 
Input Record Layout: 
As indicated in the chapter. 
Output File: 
NEW-MASTER-FILE 
Output Record Layout: 
As indicated in the chapter. 
Test Data: 
Use the existing files of Figure 17.5a and 17.9a for the unedited transaction and old 
master files, respectively. 
Report Layout: 
Processing Requirements: 
There is no new report other than the indicated error messages. 
1. Change the stand-alone edit and/or sequential update program (as you deem 
appropriate) to implement all of the following: 
a. SORT the valid transaction file (at the end of the edit program or the beginning 
of the update program). This change also implies that out-of-sequence 
transactions (which are input to the edit program) are no longer invalid (assuming 
that is the only error). 
b. Replace lines 33-45 in the edit program, which describe the transaction file, with a 
COPY statement; use the same COPY statement in the sequential update program. 

Project 
17-2 
c. Deleted records are to be written to a new file, DELETED-RECORD-FILE, for 
possible recall at a future date. 
d. Enable the OM-LASTNAME, OM-INITIALS, OM-LOCATION-CODE, and/or OM-
COMMISSION-RATE fields in the old master to be changed if necessary. The 
change is accomplished by coding any (all) of these fields as a correction in the 
transaction file; that is, the update program is to check if a value is present in the 
transaction file, and if so, it will replace the value in the master file with the value in 
the transaction file. 
e. The change involved in item d, above implies it is permissible for a correction not to 
contain a value in the TR-SALES-AMOUNT field. For example, the transaction, 
800000000VILLAR 
C 
C 
is now valid and implies a name change for the record in question. (The transaction 
was previously rejected for not containing a sales amount.) 
f. The value in the commission field (on both additions and corrections) is to be 
between 5 and 10 inclusive; any other value is to be rejected with an appropriate 
error message. 
2. Create additional test data (if necessary) so that all of the program modifications can 
be tested. Rerun both programs with the modified test data. 
Program Name: 
Customer Master Sequential File Update 
Narrative: 
This project processes output from Project 15-2. Write a program that takes the Valid 
Order Transaction File created in Project 15-2 and update the Customer Master Sequential 
File. 
Input File: 
VALID-ORDER-TRANSACTION-FILE, created in Project 15-2. 
SEQ-CUSTOMER-MSTR. 
input Record Layout: 
Sequential Customer Master Record 
01 
SEQ-CUSTOMER-MSTR-REC, 
05 
CUSTOMER-NUMBER 
PIC X(6). 
05 
CUSTOMER-NAME 
PIC X(15). 
05 
CUSTOMER-ADDRESS 
PIC X(15). 
05 
CUSTOMER-CITY 
PIC X(10). 
05 
CUSTOMER-ZIP 
PIC 9(5). 
05 
CUSTOMER-CREDIT-LIMIT 
PIC 9. 
05 
DATE-OF-LAST-REV 
PIC 9(8). 
05 
BALANCE-DUE 
PIC 9(5)V99. 
05 
CUSTOMER-PHONE-NUM 
PIC X(12). 
05 
FILLER 
PIC X. 

Appendix 
G 
Projects 
Test Data: 
VALID-ORDER-TRANSACTION-FILE: Created in Project 15-2 
S E Q - C U S T O M E R - M S J R : 
I 
105 105 TAJRGETWORLD 
123 THIS IS IT IR 
661400 MIJLLERS OUTLAW 999 W. BELTLINE I 
771600 C0JMPANY 123 
S. 440 
795300 S0|UND STUDIO 
26 AIRPORT FRWYIR 
1852300 PE|T WORLD 
210 N. LION DR.FT 
881600 GRAND CHICKEN 
'900000 CHRISTMAS, IJNC.100 SNOW DR. 
902900 PAjRTY'S UNLlJMTDSOO NEW; YR'S AVEV 
998000 E-iz CATERING! 
250 N ,| MACARTHUR 
VING 
RVING 
CIRCLE 
DALLAS 
VING 
WORTH 
5600 LU;NCH AVE.ANJYTOWN 
771233 0-5 1019)9 200012342J1 4-123-45 6|7 
7 74303052419)92 00 7 642 1 2jl 4-84 7 -00OJO 
7 501630207 19J9200100383:85-999-444|4 
7 5O3241 12 7 19J92023 50OO&;17-295-43 2}7 
732842120319l920029959 7|7 7-398-384J3 
7 930 5 1 102 6 19|92 00 7 800 0 9J1 5- 3 50-4O8J8 
NOJRTH POLE0000 16 122 5 1 9j92 0 00 00008>00 - 0 10-7 2 5(2 
ERYWHERE999994010119|9 205000009ll5-295-685J9 
IRVING 
73027 10920 19|9200 152 7 0211 4-69 5- 543:2 
Report Layout: 
Create a Customer Master Audit Report showing the data before and after the change, as 
well as the appropriate message indicating the action taken. Create a Customer Master 
report showing all data on the Customer Master. 
Processing Requirements: 1. Sort the order transaction records by record type, keeping only the type 2 records, 
and by customer number. 
2. Process a file of sorted transactions to accomplish both of the following: 
a. A d d a new customer (if the customer does not exist on the current customer master 
file)—enter all information from the transaction record to the new master record, 
b. Change (correct) information on a customer (customer master number equals valid 
order transaction customer number)—transactions to correct will contain all of the 
information, even if it does not change. 
3. All error messages are to appear in one report. 
4. The FD's and record descriptions for both the master and transaction files are to be 
copied into the program. This requires that you establish the necessary C O P Y members 
as separate files, and bring them in at compile time. 
Project 
17-3 
Program Name: 
Inventory Master Sequential File Update 
Narrative: 
This project processes output from Project 15-2. Write a program that takes the Valid 
Order Transaction File created in Project 15-2, and update the Inventory Master Sequential 
File. 
Input File: 
VALID-ORDER-TRANSACTION-FILE, created in Project 15-2. 
SEQ-INVENTORY-MSTR. 
Output File: 
Input Record Layout: 
SHIP-BACKORDER-TRANS-FILE 
Sequential Inventory Master Record 
01 
05 
05 
05 
05 
SEQ-INVENTORY-MSTR-REC. 
INV-ITEM-NUMBER 
PIC 9(5). 
INV-DESCRIPTION 
PIC X(20). 
INV-QTY-0N-HAND 
PIC 9(4). 
INV-L0CATI0N 
PIC X(5). 

Project 
17-3 
Test Data: 
VALID-ORDER-TRANSACTION-FILE: Created in Project 15-2. 
SEQ-INVENTORY-MSTR: 
12345ITEM 0 
0000L0C09 
15555ITEM 5 
0000L0C12 
16789ITEM 6 
0049LOC32 
18633ITEM 1 
0700LOC10 
26666ITEM 7 
0099LOC14 
32600ITEM 8 
0189L0C14 
32950ITEM 9 
0100LOC14 
32966ITEM 10 
0500L0C13 
33333ITEM 2 
1499L0C11 
34567ITEM 3 
0100LOC12 
37777ITEM 11 
0000LOCI3 
456781TEM 4 
1600LOC12 
49880ITEM 12 
0010LOC14 
Output Record Layout: 
Same as VALID-ORDER-TRANSACTION-FILE, with a ship/back-order indicator 
alphanumeric field added to the last byte of the record. 
Report Layout: 
Create an Inventory Master Audit Report showing the data before and after the change, 
as well as the appropriate message indicating the action taken. Create an Inventory 
Master report showing aii data on the inventory Master. 
Processing Requirements: 1. Sort the order transaction records by order number and record type, keeping only the 
type 1 and 3 records. 
2. Process a file of sorted transactions to accomplish the following: 
a. If a type 1 record, hold onto the partial ship indicator and write the entire record to 
the SHIP-BACKORDER-TRANS-FILE. 
b. If the item ordered is found on the inventory master file (inventory item number 
equals valid order transaction item number on type 3 record), determine whether 
there is enough quantity on hand to ship. 
If there is enough quantity on hand to ship: 
* Update the appropriate inventory master record quantity on hand. 
* Create a ship transaction indicating the quantity shipped, placing an's' in the 
ship/back-order indicator. 
If there is not enough quantity on hand to ship, and a partial ship is okay (check the 
partial ship indicator on the type 1 record): 
* Update the appropriate inventory master record quantity on hand to zero. 
* Create a ship transaction indicating the quantity shipped, placing an's' in the 
ship/back-order indicator. 
* Create a back-order transaction indicating the quantity not shipped, placing 
a 'b' in the ship/back-order indicator. 
If there is not enough quantity on hand to ship, and a partial ship is not okay (check 
the partial ship indicator on the type 1 record): 
* Create a back-order transaction indicating the entire quantity ordered not 
shipped, placing a 'b' in the ship/back-order indicator. 

Appendix 
G — 
Projects 
c. If an item is not on the inventory master file, create a back-order transaction for the 
entire quantity and indicate that an error has occurred with an appropriate error 
message on the report. 
3. All error messages are to appear in one report. 
4. The FD's and record descriptions for both the master and the transaction files are to 
be copied into the program. This requires that you establish the necessary COPY 
members as separate files, and bring them in at compile time. 
Program Name: 
Employee Sequential File Update 
Narrative: 
This project and the next are more complex applications of the balance line algorithm. 
Input Files: 
OLD-MASTER-FILE 
TRANSACTION-FILE 
Input Record Layouts: 01 
01 
OLD-MASTER-RECORD. 
05 OLD-SOC-SEC-NUMBER 
05 OLD-NAME. 
in 
n i n 
i A C T 
UAMC 
A \J 
V/LL*- LOJ I "lini'lL 
10 OLD-INITIALS 
05 0LD-DATE-0F-BIRTH. 
10 OLD-BIRTH-MONTH 
10 OLD-BIRTH-YEAR 
05 0LD-DATE-0F-HIRE. 
10 OLD-HIRE-MONTH 
10 OLD-HIRE-YEAR 
05 OLD-LOCATION-CODE 
05 OLD-PERFORMANCE-CODE 
05 OLD-EDUCATION-CODE 
05 OLD-TITLE-DATA OCCURS I 
10 OLD-TITLE-CODE 
10 OLD-TITLE-DATE 
05 OLD-SALARY-DATA OCCURS 
10 OLD-SALARY 
10 OLD-SALARY-DATE 
TRANSACTION-RECORD. 
05 TR-SOC-SEC-NUMBER 
05 TR-NAME. 
10 TR-LAST-NAME 
10 TR-INITIALS 
05 TR-DATE-OF-BIRTH. 
PIC X(9). 
DTP v / n \ 
PIC XX. 
PIC 99. 
PIC 99. 
PIC 99. 
PIC 99. 
PIC X(3). 
PIC X. 
PIC X. 
: TIMES. 
PIC 9(3). 
PIC 9(4). 
3 TIMES. 
PIC 9(6). 
PIC 9(4). 
PIC X(9). 
PIC X(12). 
PIC XX. 

Project 
17-4 
10 TR-BIRTH-MONTH 
PIC 99. 
10 TR-BIRTH-YEAR 
PIC 99. 
05 TR­ DATE-OF-HIRE. 
IO TR-HIRE-MONTH 
PIC 99. 
10 TR-HIRE-YEAR 
PIC 99. 
05 TR- LOCATION-CODE 
PIC X(3). 
05 TR- PERFORMANCE-CODE 
PIC X. 
05 TR- EDUCATION-CODE 
PIC X. 
05 TR-TITLE-DATA. 
10 TR-TITLE-CODE 
PIC 9(3). 
10 TR-TITLE-DATE 
PIC 9(4). 
05 TR­ SALARY-DATA. 
IO TR-SALARY 
PIC 9(6). 
10 TR-SALARY-DATE 
PIC 9(4). 
05 TR-TRANSACTION-CODE 
PIC X. 
88 ADDITION 
VALUE 
'A 
88 CORRECTION 
VALUE 
!C 
88 DELETION 
VALUE 
'D 
O u t p u t File: NEW-MASTER-FILE 
O u t p u t R e c o r d L a y o u t : 
Identical to the old master record. 
T e s t D a t a : 
Old M a s t e r File: 
1 0 0 Q 0 0 0 0 0 S U G R U E 
2 0 0 0 0 0 0 0 O C R A W F O R D 
3 0 0 0 0 0 0 0 O M I L 6 R 0 M 
4 0 0 0 0 0 0 0 0 L E E 
5 0 0 0 0 0 0 0 0 T A T E R 
6 0 0 0 0 0 0 0 0 G R A U E R 
7 0 0 0 0 0 0 0 0 J O N E S 
8 0 0 0 0 0 0 0 0 S M I T H 
900000000:BAKER 
P K 1 2 4 5 0 8 8 8 B O S E 8 1 0 0 0 8 8 8 
M A 0 8 4 3 0 9 7 3 W A S E 2 2 0 O 0 5 8 9 1 5 0 0 5 8 5 
MB 
1 0 7 4 1 1 8 9 N Y C G 4 4 4 1 1 9 3 
C R 1 2 8 2 0 5 5 0 C H I P 3 3 3 1 1 8 7 2 2 2 118 5 
J E 1 1 8 8 0 3 6 8 W A S G 3 3 3 1 1 9 3 
J J 1 1 8 6 0 6 6 9 B 0 S G 8 9 2 1 1 8 7 8 9 1 1 1 8 6 
118604.48WASG333 IT 8 7 4 4 4 1 186 
E D 1 1 7 8 0 6 5 2 M I A G 3 2 11187 1 2 3 1 1 8 6 
8 0 0 0 0 0 9 9 2 
7 0 0 0 0 0 8 9 1 
7 5 0 0 0 1 0 9 2 
7 0 0 0 0 1 0 9 1 
3 4 0 0 0 1 1 9 2 
2 9 0 0 0 1 0 9 2 
2 8 0 0 0 1 0 9 1 
6 9 0 0 0 1 1 9 1 
3 2 0 0 0 1 0 9 1 
3 0 0 0 0 1 0 9 0 
2 9 0 0 0 1 0 9 1 
2 6 0 0 0 1 0 9 0 
6 8 0 0 0 1 0 9 1 
64000109:0 
6 5 000 1090: 
2 7 0 0 0 1090; 
2 8 0 0 0 1089
! 
240001089; 
6 0 0 0 0 1 0 8 9 
T r a n s a c t i o n File: 
l O O O O O O O O R U B I N 
iOOOOOOOOOjRUBIN 
! 2 0 0 0 0 0 0 0 0 X R A W F O R D 
4 0 0 0 0 0 0 0 0 L E E 
4 0 0 0 0 0 0 0 0 L E E 
4 0 0 0 0 0 0 0 0 L E E 
4 0 0 0 0 0 0 0 1 L E E 
5 0 0 0 0 0 0 0 T A T E R 
5 5 5 5 5 5 5 5 N E W 
E M P L O Y E E 
J 
1 0 7 0 1 2 8 9 M I A 
5 0 1 0 1 2 9 2 
J 
X 
M A 0 8 4 3 0 9 7 3 W A S E 2 2 0 0 0 5 9 2 
B L 
1 0 7 3 
1 2 8 9 
M I A 
CR 
XX 
5 5 5 5 5 5 5 5 N E W 
E M P L O Y E E 
N E 0 9 54 1 2 8 9 W A S E 2 2 0 0 1 2 9 2 
5 5 5 5 5 5 5 5 N ; E W 
E M P L O Y E E 
NE 
NYC 
7 0 0 0 0 0 0 0 J 0 N E S 
A 
8 0 0 0 0 0 0 0 S ; M I T H 
S S 
3 0 0 
2 5 0 0 0 1 2 9 2 A 
7 77 4 
C 
7 5 0 0 0 1 0 92 A 
C 
C 
C 
C 
D 
C 
7 5 0 0 0 1 2 9 2 A 
C 
3 4 0 0 0 1 2 9 2 C 

Appendix 
G — 
Projects 
R e p o r t L a y o u t : 
Processing Requirements: 
Program Name: 
Narrative: 
Input File: 
Input Record Layout: 
There is no report produced by this program, other than the error messages indicated in 
the processing requirements. The latter may be produced using DISPLAY statements 
with programmer discretion as to the precise layout. 
1. Develop a sequential update program to process an incoming transaction file and the 
associated old master file to produce a new master file. 
2. Three transaction codes are permitted: A, C, and D, denoting additions, corrections, 
and deletions, respectively. 
3. The transaction file is assumed to be valid in itself because it has been processed by 
a stand-alone edit program. Hence each transaction has a valid transaction code (A, 
C, or D), numeric fields are numeric, and so on. Nevertheless, the update program 
must check (and flag) two kinds of errors that could not be detected in the stand-alone 
edit, as they require interaction with the old master file. These are: 
a. Duplicate additions, in which the social security number of a transaction coded as 
an addition already exists in the old master. 
b. No matches, in which the social security number of a transaction coded as either a 
deletion or a correction, does not exist in the old master. 
4. Transactions coded as additions are added to the new master file in their entirety. 
These transactions require all fields in the transaction record to be present. 
5. Transactions coded as deletions are removed from the master file. These transactions 
need contain only the social security number and transaction code. 
6. Transactions coded as corrections contain only the social security number and the 
corrected value of any field(s) to be changed and are handled on a parameter-by-
parameter basis. For example, if birth date and location are to be corrected, the 
incoming transaction will contain only the social security number and corrected values 
of birth date and location code in the designated positions on the transaction record. 
7. Any old master record for which there is no corresponding transaction is to be copied 
intact to the new master. 
Extended Employee Sequential File Update 
This program shows the generality of the balance line algorithm by expanding the 
specifications in the previous project to include a second transaction file. You will find 
that even though a new input file has been added, there are no additional modules 
required for the algorithm per se. It will, however, be necessary to change the logic of 
CHOOSE-ACTIVE-KEY in that the active key is now the smallest of three values. 
PROMOTION-FILE 
01 PROMOTION-RECORD. 
05 PR-SOC-SEC-NUMBER 
05 PR-NAME. 
PIC X(9). 
10 PR-LAST-NAME 
10 PR-INITIALS 
PIC X(12). 
PIC XX. 
05 PR-SALARY-DATA. 
10 PR-SALARY 
PIC 9(6). 

Project 
17-6 
10 PR-SALARY-DATE 
05 PR-TITLE-DATA. 
10 PR-TITLE-CODE 
10 PR-TITLE-DATE 
05 
PR-PROMOTION-CODE 
88 SALARY-RAISE 
88 PROMOTION 
PIC 9(4). 
T e s t Data: 
j l O O O O O O O O S U G R U E 
PK 9 0 0 0 0 ; 0 9 9 3 
R 
l O Q O O O O O O S U G R U t 
PK 
i 
9 9 9 0 9 9 3 P 
4 0 0 0 0 0 0 0 0 L E E 
B L 
5 0 0 0 0 : 1 193 
; R 
J666666666:GLASSMAN 
C 
4 5 0 0 0 : 1 0 9 3 
; R 
8 0 0 0 0 0 0 0 0 S M I T H 
S S 7 5000=1093 
; R 
Report Layout: 
Identical to the previous project. 
Processing Requirements: 
Modify the specifications of Project 17-4 to accommodate all of the following: 
1. Inclusion of a second transaction (i.e., a promotion) file to accommodate promotions 
and/or salary increases. 
2. Salary increases are to be handled in the following manner: the transaction salary 
becomes the present salary in the new master, causing the present salary in the old 
master to become the previous salary in the new master. In similar fashion, the 
previous salary in the old master becomes the second previous salary in the new 
master. (The record layout of the master file in the programming specifications allowed 
three salary levels.) 
Each occurrence of salary is accompanied by a salary date in both the old master 
and promotion record layouts. Accordingly, the salary dates and the salaries are to be 
adjusted simultaneously. 
3. Promotions (i.e., title changes in the new file) are to be handled in a manner analogous 
to salary increases. Hence the transaction title, PR-TITLE-CODE, becomes the present 
title in the new master, causing the present title in the old master to become the 
previous title in the new master. The associated dates are to be adjusted simultaneously. 
4. Deletions (in the original transaction file) are to be written in their entirety to a new file, 
DELETED-RECORD-FILE, for possible recall at a future date. 
5. All error messages are to be expanded to print the entire transaction that is in error. 
Program Name: 
Stock Sequential File Update 
Narrative: 
Develop a sequential update program to process an incoming transaction file and the 
associated master stock file to produce a new master stock file. 
Input File: 
MASTER-STOCK-FILE 
TRANSACTION-FILE 
PIC 9(3). 
PIC 9(4). 
PIC X. 
VALUE 'R' 
VALUE 'P'. 

Appendix 
Q — Projects 
Input Record Layout: 
Use the record layout in Project 8-8 for the MASTER-STOCK-FILE. 
01 TRANSACTION-FILE. 
05 TR­ INFO. 
IO TR-NAME 
PIC X(8). 
10 TR-EXCHANGE-CODE 
PIC 9. 
10 TR-INDUSTRY-CODE 
PIC X(3). 
05 TR­CURRENT-INFO. 
IO TR-PRICE 
PIC 9(3)V9(3) 
10 TR-PE 
PIC 9(3). 
10 TR-DIVIDEND 
PIC 9V99. 
05 TR­ PROJECTION-INFO. 
IO TR-RISK-C0DE 
PIC 9. 
10 TR-GR0WTH-RATE 
PIC 9V9(4). 
10 TR-SHARES-TO-BUY 
PIC 9(4). 
05 TRANS-CODE 
PIC X. 
88 ADDITION 
88 CORRECTION 
88 DELETION 
VALUE 'A'. 
VALUE ' C . 
VALUE 'DC 
Output File: 
NEW-MASTER-STOCK-FILE 
Output Record Layout: 
S a m e as master stock file. 
Test Data: 
Use the validated stock file from Project 8-8 as the MASTER-STOCK-FILE. 
Transaction File: 
Anheu 
Ci ti c 
Chevr 
Compq 
GenEl 
GnMot 
HBO 
Hi I to 
IBM 
Kmart 
M a r r i 
Pol kA 
Reebo 
OBri e 
Seaga 
Skyws 
Trus^ 
Wendy 
orpl|BAN0262500;l 
on 101 L072 7 5002 
j 0 3 0 5 5 0 0i3 
n 
RET02300002 
F&L0497750I2 
2 
90002 
43304 
2 285 
90302 
21223 
383 
j 
01550001 
i 
00525002 
j 
00 
4RET00487501 
30143 
0 
4 
7 
3 
50000 
ELE01 7 1253i43 1303 
00550 
0 2 5 5:0 
0095i0 
0 6 5 0(0 
05500 
o i o o b 
4023|0 
00890 
! 06 5 3 
F&L0T20O00i2202440295|0 
C 
0123A 
0050A 
C 
0100C 
D 
0075A 
0025A 
C 
D 
C 
C 
005 5C 
0110A 
0045A 
D 
C 
00 50 A 
Report Layout: 
There is no output report other than the error messages; use whatever form you d e e m 
appropriate. 
Processing Requirements: 
1. Sort the master file by stock name. 
2. Three transaction codes are permitted: A, C, and D, denoting additions, corrections, 
and deletions, respectively: 
3. The transaction file is assumed to be valid in itself because it has been processed by 
a stand-alone edit program. Hence each transaction has a valid transaction code (A, 

Project 
17-7 
C, or D), numeric fields are numeric, and so on. Nevertheless, the update program 
must check (and flag) two kinds of errors that could not be detected in the stand-alone 
edit, as they require interaction with the master file. These are: 
a. Duplicate additions, in which the stock name of a transaction coded as an addition 
already exists in the master. 
b. No matches, in which the stock name of a transaction coded as either a deletion or 
a correction, does not exist In the master. 
4. Transactions coded as additions are added to the new master file in their entirety. 
These transactions require all fields in the transaction record to be present. 
5. Transactions coded as deletions are removed from the master file. These transactions 
need contain only the stock name and transaction code. 
6. Transactions coded as corrections contain only the stock name and the corrected 
value of any field(s) to be changed and are handled on a parameter-by-parameter 
basis. For example, if price and PE are to be corrected, the incoming transaction will 
contain only the stock name and corrected values of price and PE in the designated 
positions on the transaction record. 
7. Any master stock record for which there is no corresponding transaction is to be 
copied intact to the new master. 
Program Name: 
Church Building Fund Sequential File Maintenance 
Narrative: 
Write a program to update the church members' balance based on their contributions to 
the church building fund. 
Input File: 
CHURCH-BLD-FUND-MSTR-FILE 
CHURCH-BLD-FUND-TRAN-FILE 
Church Building Fund Master Record 
Member Name 
Pledge Amount 
Member Number 
Amount Given 
1 
... 
15 
16 
... 
25 
19(2 decimals) 27 
28-32 
33 (2 decimals) 41 
42 
... 
43 
Church Building Fund Master Record 
Member Name 
Amount Given 
Date Given 
1 
... 
15 
16 
... 
24 
25 
... 
32 
Output File: 
NEW-CHURCH-BLD-FUND-MSTR 
ERROR-TRANS-FILE 
Output Record Layout: 
NEW-CHURCH-BLD-FUND-MSTR: same as Church Member Master Record. 
ERROR-TRANS-FILE: same as Church Member Transaction File. 

A
p
p
e
n
d
i
x 
G 
— 
Projects 
T e s t D a t a : 
[ M a s t e r 
F i ;1 e : 
J O H N 
S M I T H 
[ANN 
L 0 V I N ; G 
JMARY 
BROWjN 
JTOM 
S A W Y E R 
J A C K 
C A P P S 
T r a n s a c t i o n 
F i l e : 
| 0 0 0 0 2 
100003 
0 0 0 0 1 
0 0 0 0 1 
0 0 0 0 2 
0 0 0 0 4 
0 0 0 0 1 
0 0 0 0 4 
0 0 0 0 3 
00003 
0 0 0 0 2 
0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 X X 
0 0 2 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 X X 
O'0 0O500OOOGJ0 03OO0003OJ0 0XX 
0:00 7 5 0 0 0 0 0 0 : 0 0 4 0 0 0 0 0 4 0:00 XX 
0^3 4 00 0 00 0 0 0 0 0 5 0 0 0 0 0 5 OiOO XX 
0 0 0 0 3 0 0 0 0 1 0 0 2 1 9 9 7 
0 0 0 0 5 J 0 0 0 0 0 8 0 5 19:97 
0 0 0 0 2 0 0 0 0 0 6 0 1 1 9 9 7 
0 0 0 0 0 1 0 0 0 0 3 0 2 1 9 : 9 7 
0 0 0 0 1 : 0 0 0 0 0 2 1 0 1 9 9 7 
0 0 0 1 0 0 1 0 1 0 1 1 0 1 9 9 7 
0 0 5 0 0 | 0 4 0 4 0 2 0 2 19:97 
0 0 0 2 0 ( 0 5 0 6 0 3 0 3 19:9 7 
0 0 1 0 0 | 0 2 0 2 0 4 0 4 1 9 : 9 7 
0 1 0 0 0 : 1 0 1 0 0 5 0 5 1 9 : 9 7 
1 5 0 0 0 | 0 3 0 2 0 6 0 6 1 9 : 9 7 
R e p o r t L a y o u t : 
xx/xx/x;xxx 
Itli^iillFif 
IDATE : 
A B C C H U R C H M E M B E R B U I L D I N G FUND R E P O R T 
M E M B E R 
N A M E 
A M O U N T 
P L E D G E D 
X X X X X X X X X X X X X X X 
$•$,$$$,$$$ .;99 
P A G E : ZZZ! 
A M O U N T G I V E N 
TO D A T E 
$$,$!$$,$$$. 99 
A M O U N T 
O W E D ! 
$$;$,$$$. 99 
T O T A L 
S •¥ ~¥ -V » 
,$•$$1.99 
$$$:.$$$,$$$,$:$$. 99 
$$!$,$$$ ,$$$'.|99 
Error Report: 
Design any report you deem appropriate in conjunction with the processing specifications. 
Processing Requirements: 1. Read a file of church member building fund transaction records. 
2. Perform an internal sort, sorting the transaction records by church member number. 

Project 
17-8 
3. For every record read, accumulate the total amount a church member has given. After 
all transaction records have been read for a church member: 
a. Read the sequential church member building fund master record until the church 
member numbers on the transaction file match the church member numbers on the 
master file. 
Make sure that the master records are coming in sorted by church member number 
by doing a data validation check. 
b. Calculate the AMOUNT OWED = AMOUNT PLEDGED - AMOUNT GIVEN. 
c. Update the master record with the new amount given. 
d. If transaction records exist for a church member who does not have a master 
record, put this on the error report and keep the transactions on an error file. The 
Error File should have the same layout of the Transaction File. The error report 
should contain all the information on the transaction file with an appropriate error 
message. 
e. Accumulate the total amount given, the total amount pledged, and the total amount 
owed by all church members. 
f. Print the CHURCH MEMBER NAME, the AMOUNT PLEDGED, the AMOUNT PAID 
TO DATE, and the AMOUNT OWED for each church member. Single-space each 
line. 
4. Print the TOTAL AMOUNT PLEDGED, AMOUNT PAID, and AMOUNT OWED at the 
end of the report. 
Program Name: 
Two-file Merge 
Narrative: 
This project merges two sequential files to produce a third file; all three files have different 
record layouts. 
Input Files: 
EMPLOYEE-MASTER-FILE 
SALARY-FILE 
Input Record Layout: 
01 
01 
EMPLOYEE-MASTER-RECORD. 
05 
EMP-SOC-SEC-NUMBER 
EMP-NAME. 
10 EMP-LAST-NAME 
10 EMP-INITIALS 
EMP-BIRTH-DATE 
EMP-HIRE-DATE 
EMP-L0C-C0DE 
EMP-TITLE-C0DE 
05 
05 
05 
05 
05 
SALARY-RECORD. 
05 
SAL-SOC-SEC-NUMBER 
05 
SAL-ANNUAL-SALARY 
PIC X(9). 
PIC X(15), 
PIC XX. 
PIC 9(4). 
PIC 9(4). 
PIC X(3). 
PIC 9(3). 
PIC X(9). 
PIC 9(6). 

A
p
p
e
n
d
i
x 
G — 
Projects 
Test Data: 
Employee Master File: 
1 1 1 1 1 1 1 1 1 ADAMS 
2 2 2 2 2 2 2 2 2 M 0 L D 0 F 
3 3 3 3 3 3 3 3 3 F R A N K E L 
5 5 5 5 5 5 5 5 5 B 0 R 0 W 
6 6 6 6 6 6 6 6 6 M I L G R O M 
888888888.J0NES 
J 0 1 0 5 2 1 0 8 2 A T L 1 1 1 
M L 1 0 5 9 0 4 8 4 F L A 2 2 2 
L Y 0 6 5 6 0 5 8 9 N J 
1 1 1 
J E 0 1 4 3 0 6 8 Q N Y 
2 2 2 
I R 0 3 4 8 0 1 8 7 N Y 
2 2 2 
J J 0 9 6 0 0 6 8 4 N Y 
2 2 2 
Salary File: 
1 1 1 1 1 1 1 1 1 0 5 0 0 0 0 
2 2 2 2 2 2 2 2 2 1 0 0 0 0 0 
4 4 4 4 4 4 4 4 4 0 7 5 0 0 0 
5 5 5 5 5 5 5 5 5 0 4 0 0 0 0 
7 7 7 7 7 7 7 7 7 0 4 3 5 0 0 
8 8 8 8 8 8 8 8 8 0 3 5 0 0 0 
9 9 9 9 9 9 9 9 9 0 4 2 0 0 0 
Input Files: 
MERGED-FILE 
O u t p u t R e c o r d L a y o u t : 
01 MERGED-DATA-RECORD. 
05 MGD-SOC-SEC-NUMBER 
05 MGD-NAME. 
10 MGD-LAST-NAME 
10 MGD-INITIALS 
05 MGD-BIRTH-0ATE 
05 MGD-HIRE-DATE 
05 MGD-L0C-C0DE 
05 MGD-TITLE-C0DE 
05 MGD-ANNUAL-SALARY 
PIC X(9). 
PIC X(15). 
PIC XX. 
PIC 9(4). 
PIC 9(4). 
PIC X(3). 
PIC 9(3). 
PIC 9(6). 
R e p o r t L a y o u t : 
P r o c e s s i n g R e q u i r e m e n t s : 
There is no report produced by this program, other than the error messages indicated in 
the processing requirements. The latter may be produced using DISPLAY statements 
with programmer discretion as to the precise layout. 
1. Write a program to merge two input files, each in sequence by social security number, 
to produce a third file as output. 
2. In order to produce an output record with a given key, that key must be present on 
both input files. With respect to the test data, for example, records 111111111 and 
222222222 should both appear on the merged file. A record is written to the MERGED-
FILE by combining fields on the two input records as per the record layouts. 
3. If a key appears on only one input file, that record key is not to appear in the MERGED-
FILE. With respect to the test data, for example, record 333333333 should not appear 
in the MERGED-FILE, as it is not present in the SALARY-FILE. Nor should record key 
444444444, as it is not present in the EMPLOYEE-MASTER-FILE. 
4. Any key appearing in only one file should be flagged with an appropriate error 
message, for example: 
ERROR - RECORD 333333333 NOT IN SALARY-FILE 
ERROR - RECORD 444444444 NOT IN EMPLOYEE-MASTER-FILE 

Project 
18-7 
P
R
O
G
R
A
M
M
I
N
G
; 
S
P
E
C
I
F
I
C
A
T
I
O
N
S 
P r o g r a m N a m e : 
Extended Program Maintenance 
N a r r a t i v e : 
Change the nonsequential update program of Figure 18.10 to accommodate the various 
changes in specifications listed below. 
I n p u t F i l e : 
As indicated in the chapter. 
I n p u t R e c o r d L a y o u t : 
As indicated in the chapter. 
T e s t D a t a : 
Use the existing files of Figure 18.7a and 18.7b for the transaction and indexed files, 
respectively. 
R e p o r t L a y o u t : 
There is no new report other than the indicated error messages. 
Processing Requirements: 
1. Change the existing program to accommodate all of the following: 
a. Replace the record descriptions in Working-Storage, (lines 34-45 and 47-54 for 
the transaction and master files, respectively) with a COPY statement. This in turn 
requires you to create the necessary copy members. 
b. Deleted records are to be written to a new file, DELETED-RECORD-FILE, for 
possible recall at a future date. 
c. Enable the MA-LAST-NAME, MA-INITIALS, MA-LOCATION-CODE, and/or MA-
COMMISSION-RATE fields in the indexed file to be changed if necessary. The 
change is accomplished by coding any (all) of these fields as a correction in the 
transaction file; that is, the update program is to check if a value is present in the 
transaction file, and if so, it will replace the value in the master file with the value in 
the transaction file. 
d. The change involved in item c. above implies it is permissible for a correction not to 
contain a value in the TR-SALES-AMOUNT field. For example, the transaction, 
800000000VILLAR 
C 
C 
is now valid and implies a name change for the record in question. (The transaction 
was previously rejected for not containing a sales amount.) 
2. Create additional test data so that all of the program modifications can be tested. 
Rerun the program with the modified test data. 
P r o g r a m N a m e : 
Nonsequential File Update 
N a r r a t i v e : 
Implement the programming specifications for Projects 17-2 through 17-7 as a 
nonsequential (rather than a sequential) update. The file descriptions, test data, and 
programming specifications given with the sequential program apply here as well, except 
that the indexed file in this example functions as both the old and new master files in the 
sequential version. 

Appendix 
G — Projects 
Program Name: 
Catalog Orders 
Narrative: 
Develop an interactive program that will process additions, changes, deletions, and 
inquiries to an indexed file of catalog orders. 
input File: 
ORDER-FILE 
Input Record Layout: 
01 ORDER-RECORD-IN. 
05 ORD-NUMBER 
PIC 9(6). 
05 0RD-INF0. 
10 ORD-NAME 
PIC X(10). 
10 0RD-TELEPH0NE 
PIC 9(10). 
05 0RD-ITEMS-ORDERED OCCURS 3 TIMES. 
10 ORD-ITEM-NUMBER 
PIC 9(4). 
10 0RD-QUANTITY-0RDERED PIC 9. 
Test Data: 
,2 1 2467 Scully 
;5 6 1 5 7 8 S c h u 1 tz 
036442Culver 
j479350Perez 
683 7 36 Fi xler 
488907Morin 
;043498Munroe 
3052331234125021100115501 
20134715354500232001 
401345234790003 
30 59 7674566800245001 
20136218231250115503 
4 1 3743 5343 320.0 1 90003 1 10;02 
305331485490005 
Screen Layouts: 
Screen A 
Catalog Orders 
Order #: 
Transaction Types: 
Add 
Change 
Delete 
Inquiry 
Enter transaction type: 

Project 
18-8 
Screen B 
Catalog Orders - trans type 
Order #: 
Name: 
Tel #: ( ) -
Item Description 
Quantity Price 
Total 
XXXXXXXXXXXXXXX 
ZZ9.99 1,119. 99 
XXXXXXXXXXXXXXX 
ZZ9.99 1,119. 99 
XXXXXXXXXXXXXXX 
ZZ9.99 1,119. 99 
Total 
11,119. 99 
Processing Requirements: 
1, Display Screen A to accept an order # and transaction type (vaiid transaction types 
are A, C, D, or I). 
2. Depending on the transaction type, display an appropriate screen using Screen B as 
a model, and processing the transaction as follows: 
a. Additions: 
(1) Accept and validate the order # (don't forget to check for duplicate additions), 
name, telephone number (numeric), item number (valid item numbers are 
found in the item table, see requirement #3), and quantity (numeric). 
(2) For each valid item, look up the price and description from the item table, 
calculate the total (quantity multiplied by price), and display the item detail 
line. 
(3) When all items are entered, display a total for all ordered items. 
(4) Prompt the user for confirmation and write the record to the indexed file, 
b. Changes: 
(1) Display Screen B showing the information found in the order file. 
(2) For each item, look up and display the price and description from the item 
table along with the calculated total. 
(3) Allow modification to the name, telephone, item number, and quantity fields. 
(4) Validate each item changed against the item table, and for each valid item 
display the description and price and calculate the total. 
(5) Prompt the user for confirmation and replace the modified record in the 
indexed file. 
c. Deletions: 
(1) Display Screen B showing the information found in the order file, the 
corresponding information from the item table for each item, and all totals. 
(2) Prompt the user for confirmation to delete, and delete the record. 
d. Inquiries: Display Screen B showing the information found in the order file, the 
corresponding information from the item table for each item, and all totals. 

A
p
p
e
n
d
i
x 
G 
— 
Projects 
3. Hard-code the following item table in the program and use a sequential lookup: 
Item Information 
ltem# 
Item Description 
Price (each) 
1100 
Handwoven Rug 
129.00 
1550 
Crystal Frame 
39.40 
1250 
Floor Lamp 
99.00 
3000 
Ceiling Fan 
299.00 
4500 
Wicker Basket 
25.00 
6800 
Wall Clock 
169.00 
3200 
Ceramic Figure 
39.90 
9000 
Wood Wall Shelf 
14.90 
4. Ail error messages are to be displayed on the bottom of the screen and will allow the 
user to reenter the desired information. 
Program Name: 
Create Customer Bills 
N a r r a t i v e : 
This project processes output from Projects 17-2 and 17-3. Write a program that takes the 
Ship/Back-order Transaction File and the VSAM Customer Master file updated in Project 
18-2, and create a bill for each customer. 
Input File: 
SHIP-BACK-ORDER-TRANS-FILE, created in Project 17-3/Project 18-3. 
VSAM-CUSTOMER-MASTER, updated in Project 18-2. 
Input Record Layout: 
Ship/back-order transaction record: same as Project 17-3. 
VSAM customer master record: same as Project 18-2. 
Test Data: 
Ship/back-order transaction record: created in Project 17-3. 
VSAM customer master record: updated in Project 18-2. 

Project 
18-9 
Report Layout: 
Create a Customer Bill 
BILL DATE: XX/XX/XXXX 
CUSTOMER NAME: XXXXXXXXXXXXXXX 
CUSTOMER NUMBER: 
XXXXXX 
CUSTOMER ADDRESS: XXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXX 
XXXXX 
ORDER NUMBER: XXXXX 
PURCHASE DATE: XX/XX/XXXX 
ITEM NUMBER 
99999 
99999 
QUANTITY 
ZZZ 
ZZZ 
UNIT PRICE 
$ZZ,ZZZ.99 
$ZZSZZZ.99 
EXTENDED PRICE 
$ZZ,ZZZ,ZZZ.99 
$ZZ,ZZZ,ZZZ.99 
SUBTOTAL: 
TAX: 
TOTAL AMT DUE: 
$ZZZ,ZZZ,ZZZ.99 
$ZZZ,ZZZ.99 
$Z,ZZZ,ZZZ,ZZZ.99 
ITEMS BACKORDERED: 
ITEM NUMBER 
QUANTITY 
XXXXX 
XXXXX 
ZZZ 
ZZZ 
TOTAL ITEMS BACKORDERED 
ZZZ,ZZZ,ZZZ 
TOTAL ITEMS SHIPPED 
ZZZ,ZZZ,ZZZ 
Processing Requirements: 1. Sort the order transaction records by order number, record type, and ship/back-order 
indicator 
2. Process a file of sorted transactions to create a customer bill. 
a. The customer number comes from the transaction file and is used to access the 
customer name and address from the VSAM CUSTOMER MASTER file. 
b. The order number and purchase date come from the type 1 record on the new 
transaction file. 
c. Item number and quantity come from the transaction file. 
d. Unit price and extended price are calculated based on the item number and 
quantity as follows: 
Check the first byte of the item number and then check the quantity to determine 
the percent of markup on the item. Take the unit cost from the transaction file and 
use the percent markup to determine the unit price. 

Appendix 
G 
Projects 
UNIT-PRICE = UNIT-COST * 1.PERCENT MARKUP 
EXTENDED PRICE = UNIT-PRICE * QUANTITY 
PERCENT MARKUP 
FIRST BYTE 
of ITEM NUMBER 
QTY 
<50 
QTY 
50-99 
QTY 
100-199 
QTY 
200-300 
QTY 
>300 
1 
2 
3 
4 
30% 
25% 
35% 
40% 
25% 
20% 
30% 
35% 
20% 
15% 
25% 
30% 
15% 
10% 
20% 
25% 
10% 
5% 
15% 
20% 
e. The subtotal is the extended price for each item accumulated per order. 
f. The amount of tax is zero if the taxable item indicator on the type 1 transaction 
record contains an "N." If the taxable item indicator on the type 1 transaction is a 
"Y," compute the amount of tax = subtotal * 8.25%. The total amount due is 
calculated by adding the subtotal plus tax. 
g. If an item is backordered, a B will exist in the ship/back-order indicator field on the 
type 3 record of the new Transaction file. 
h. The total items back-ordered is an accumulation of the quantity for each item back-
ordered, and the total items shipped is an accumulation of the quantity for each 
item shipped. 

77-level entry, 181 
88-level entry, 200,201 
A in P I C T U R E clause, 17, 79 
A margin, 29 
A C C E P T statement, 206-207, 
242-243 
with screen l-O, 266-268 
A C C E S S I S D Y N A M I C clause, 
554 
A C C E S S I S R A N D O M clause, 
566 
A C C E S S I S S E Q U E N T I A L 
clause, 562 
A C C E S S M O D E clause, 554 
Action list, 163 
Active key, 530-531,537 
Actual decimal point, 172 
A D D statement, 112-113 
A D V A N C I N G clause. See 
W R I T E 
A F T E R clause. See P E R F O R M 
V A R Y I N G 
A L L literal, 84, 89 
Allocation status, 530-531 
A L P H A B E T I C clause, 199 
Alphabetic code, 333 
A L P H A B E T I C - L O W E R clause, 
221 
Alphabetic test, 197,199 
A L P H A B E T I C - U P P E R clause, 
221 
A l p h a n u m e r i c code, 333 
A l p h a n u m e r i c item, 79 
A L T E R N A T E R E C O R D K E Y 
clause, 554, 561-562, 
570-573 
Alt key, hidden p o w e r of, 274 
A N D operator, 201 
Animator, 643-695 
C o m m a n d P r o m p t , 678-679 
C o m p i l e / R u n M e n u , 
654-658 
creating shortcuts for, 
703-706 
D e b u g M e n u , 658-662 
d o w n l o a d i n g data/source 
files from the W e b , 707 
Edit M e n u , 648-652 
editing in, 679-680 
File M e n u , 646-648 
H e l p M e n u , 674-676 
highlighting, 649 
installing, 644, 697-703 
learning to use, 644 
M a i n M e n u , 646-676 
Options M e n u , 662-672 
printing from C O B O L 
programs with, 707-708 
starting, 644-645 
Toolbar, 676-678 
tutorial, 681-694 
V i e w M e n u , 652-655 
W i n d o w M e n u 672-674 
w i n d o w s , 680 
A r g u m e n t list, 477 
Arithmetic symbol, 16 
A S C E N D I N G K E Y clause 
in O C C U R S clause, 311, 344, 
345 
in S O R T statement, 409 
Ascending sort, 405 
A S C I I 
character set, 273 
collating sequence, 405-407, 
586 
A S S I G N clause. See S E L E C T 
statement 
A s s u m e d decimal point, 81-82, 
117-118 
Asterisk 
as editing character, 175 
as multiplication s y m b o l , 
111 
A T E N D clause 
i n R E A D statement, 99 
i n S E A R C H statement, 340, 
343 
A U T H O R paragraph, 75 
A U T O clause, 268 
B as insertion character, 175, 
237-238 
B margin, 29 
B A C K G R O U N D - C O L O R 
clause, 267, 274, 275 
B a c k u p , 519 
B a l a n c e line algorithm, 529-
534 
B a t c h file, 585, 592-593 
Binary table lookup, 335-336 
B L A N K W H E N Z E R O clause, 
177 
B L I N K clause, 268 
B L O C K C O N T A I N S clause, 78-
79 
Blocking factor, 78 
B o h m , C , 55 
Braces, 74 
Brackets, 75 
B Y C O N T E N T clause, 480-481, 
506 
B Y R E F E R E N C E clause, 480-
481,506 
Calculated field (as sort key), 
410 
C A L L statement, 477-479 
Called program, 477-479 
Calling program, 477-479 
Car Validation a n d billing 
program, 278-297 
completed program, 
287-297 
hierarchy chart, 284 
p r o g r a m m i n g 
specifications, 279-280 
pseudocode, 284-286 
screen section, 280-284 
Case structure, 56 
C h e c k protection, 175 
Class test, 199 
C L O S E statement, 99 
C O B O L 
evolution of, 38 
notation, 74-75 
C O B O L revision, 737-743 
C O B O L - 7 4 , 38 
versus C O B O L - 8 5 , 38 
limitations of, 90, 221, 258, 
325, 357, 398, 428, 506, 
574 
C O B O L - 8 5 , 38 
C O B O L - 8 5 reference 
s u m m a r y , 711-736 
C O B O L verbs, 721-731 
c o m m u n i c a t i o n description 
entry, 718 
conditions, 732 
C O P Y a n d R E P L A C E 
statements, 731 
data description entry, 717 
data division, 714 
environment division, 
712-713 
file control entry, 713-714 
file description entry, 
715-716 
identification division, 712 
miscellaneous formats, 734 
nested source programs, 734 
procedure division, 720 
qualification, 733 
report description entry, 719 
report group description 
entry, 719-720 
series of source programs, 
735 
C O B O L 2000 
intrinsic functions, 738-742 
miscellaneous n e w features, 
743 
n e w data types, 742-743 
Codes, 332-334 
Coding form, 28 
C o d i n g standards, 179-189 
Collating sequence, 405-408 
effect o n signed n u m b e r s , 
406-408 
C O L L A T I N G S E Q U E N C E 
clause, 409 
C O L U M N clause, 267 
C o m m a 
avoidance of, 181 
as editing character, 174-175 
C o m m e n t s , 29 
limitation of, 184 
C o m p i l a t i o n error, 33-35, 140-
151 
Compiler, 31 
Compiler option (in Classroom 
C O B O L ) , 586 

Index 
Completeness check, 197 
Compound test, 200-202 
COMPUTE statement, 110-111 
versus arithmetic 
statements, 116 
Concatenated key, 573-575 
Condition name. See88-level 
entry 
CONFIGURATION SECTION, 
40, 76-77 
Consistency check, 197 
Constant 
avoidance of, 183 
See also Literal 
Continuation, of nonnumeric 
literal, 29 
Control area, 551 
Control break, 435-471 
Control field, 437 
Control interval, 551 
Control total, 437 
COPY statement, 479-480 
with subprograms, 481 
CR editing character, 176-177 
Cross reference listing, 159-
161 
uata disk, a84, 586-567 
DATA DIVISION, 11-12, 77-84 
Data name 
choice of, 179 
rules for, 14-15 
Data validation, 195-221, 519-
528 
in interactive program, 277 
Date check, 197,218 
DATE clause, 206-207 
DATE-COMPILED paragraph, 
75 
DATE-WRITTEN paragraph, 75 
DAY clause, 206 
DAY-OF-WEEK clause, 242-
243 
DB editing character, 176-177 
Debugging, 139-164 
compilation errors, 140-151 
execution errors, 151-158 
interactive debugging, 161-
162 
tips for, 160-161 
Decimal alignment (in MOVE 
statement), 104 
Defensive programming, 197, 
527 
DELETE statement, 562 
DESCENDING KEY clause 
in OCCURS clause, 311,344 
in SORT statement, 409 
Descending sort, 405 
Desk checking, 162 
Detail line, 48 
Detaii report, 375 
Direct access to table entries, 
344,345 
Displacement. See Index 
DISPLAY statement 
in debugging, 161 
in top-down testing, 61, 63-
64 
DIVIDE statement, 115-116 
DO UNTIL structure, 231-232 
with data validation, 271, 
275 
DO WHILE structure, 231-232, 
271 
Duplicate addition (error 
condition), 518 
Duplicate (nonunique) data 
names, 243-245 
DUPLICATES IN ORDER 
clause, 409, 443 
Early error detection. See 
Structured walkthrough 
EBCDIC, 405-407, 586 
Edit program. See Stand-alone 
edit 
Editing, 169-179 
Editing characters, 171 
Editor, 28,30 
Elementary item, 79 
ELSE clause, 106 
Embedded sign, 406-408 
END-IF terminator, 12, 182 
End-of-file condition, 6 
END-PERFORM terminator, 
232 
END-READ terminator, 100 
END-SEARCH terminator, 398 
ENVIRONMENT DIVISION, 11 
Error message table, 214, 215, 
220, 525, 527 
EVALUATE statement, 109, 243 
Execution error, 35-37, 151-
158 
Existing code check, 197 
EXIT PROGRAM statement, 
477, 478 
EXIT statement, 233-234 
Expandable code, 333, 334 
Exponentiation, 111 
False condition branch. See 
NOTATEND 
FD. See File description 
Field, 2 
Figurative constant, 83-84 
File, 2 
File description, 77-79 
File maintenance 
nonsequential, 563-570 
sequential, 515-544 
FILE-CONTROL paragraph, 77 
FILE SECTION, 12, 77-82 
FILE STATUS clause, 555, 557-
560 
File status codes 
additions in COBOL-85, 574 
in debugging, 156-157 
list of, 555 
FILLER clause, 82-83 
optional use of, 83, 180, 357 
Fixed dollar sign, 174 
Fixed-length record, 310 
Floating dollar sign, 174 
Floating minus sign, 177 
Floating plus sign, 177 
Flowchart, 6-8, 57,58 
FOREGROUND-COLOR 
clause, 267, 274, 275 
Free space, 552 
Functional paragraph, 54 
GIGO, 37 
GIVING clause 
in arithmetic statements, 
112, 113, 114, 115 
in SORT statement, 410, 
414-419 
Grandfather-father-son 
backup, 519 
Group item, 79 
Group move, 105 
Heading line, 48 
Hierarchy chart, 50-54, 444-
446, 451-453,460-461 
with subprograms, 479, 485 
Hierarchy of operations 
arithmetic, 111 
logical, 201 
HIGH-VALUES, 530 
HIGHLIGHT clause, 268 
Hopper, Grace Murray, 38 
I-O status. See File status codes 
IDENTIFICATION DIVISION, 
11, 75-76 
IF statement, 106-108 
class test, 199 
compound test, 200-202 
condition name, 200, 201 
implied condition, 203 
indentation in, 106-108 
nested, 203-205 
NEXT SENTENCE, 205-206 
relational condition, 198 
scope terminator, 182, 205 
sign test, 200 
Implied decimal point. See 
Assumed decimal point 
IN qualifier, 245 
Indentation, 106-108, 183 
Index, 321-324 
Index set, 551 
INDEXED BY clause, 321-322, 
343 
Indexed file, 549-575 
creation of, 556-559 
maintenance of, 563-570 
utility for, 606-608 
INITIAL clause, 482 
INITIALIZE statement, 236-
237, 486 
In-line perform. See PERFORM 
statement 
Input-loaded table, 338-339 
INPUT-OUTPUT SECTION, 
76-77 
INPUT PROCEDURE, 410, 419-
426 
Insertion characters, 175 
INSPECT statement, 237-238 
INSTALLATION paragraph, 75 
Interactive ^ro^ram, 265-296, 
487-504 
Intrinsic functions, 738-742 
added in COBOL 2000, 
741-742 
miscellaneous new features, 
743 
new data types, 742-743 
Iteration structure, 56 
lacopini, G., 55 
LABEL RECORDS CLAUSE, 40, 
79, 99 
Level numbers, 12,16, 79-81 
Limit check, 197 
LINE CLAUSE, 267 
LINKAGE SECTION, 477-478 
Linker (linkage-editor), 31, 
504-506, 583, 594 
Literal, 15-16 
continuation of, 180 
Load module, 31 
Logic errors, 159-160 
Logical record, 78 
Main program. See Calling 
program 
Major key, 405 
MERGE statement, 426-427 

Index 
Micro Focus Personal COBOL 
for Windows, 643-695 
Minor key, 405 
Mnemonic code, 333, 334 
MOVE CORRESPONDING 
statement, 245 
MOW statement, 102-105 
MULTIPLY statement, 114-115 
Nested IF statement, 203-205 
Nested SEARCH statement, 
394, 397 
NEXT SENTENCE clause, 205-
206 
No match (error condition), 
518 
Nonnumeric iiterai 
(continuation of), 15-16, 
180 
Nonsequential file 
maintenance, 563-570 
versus sequential 
maintenance, 518 
NOT operator, 201 
NOT AT END clause, 234-235 
Numeric code, 333 
Numeric-edited field, 170 
Numeric field, 79, 172-173 
Numeric item, 79 
Numeric literal, 15-16 
Numeric test, 197-199 
OBJECT-COMPUTER 
paragraph, 40, 76 
Object-oriented (OO) COBOL 
programming, 603-642 
classes and inheritance, 619 
next-generation of COBOL, 
605-609 
object orientation, 
defined, 604 
object-oriented vs. 
structured paradigm, 
608-609 
ProcessRequest method, 
619-621 
Registrar class, 616-619 
structured programming, 
development of, 606-607 
Student class, 627-629 
Student-Look-Up program, 
612-616 
Student-Look-Up system, 
610-639 
StudentDM class, 621-625 
StudentDM instance 
definition, 625-627 
StudentPRT class, 635-639 
StudentUI class, 633-635 
terminology, 607-608 
Object program, 31 
OCCURS clause, 303, 307 
problems with, 308 
OCCURS DEPENDING ON 
clause, 310-311,315 
OF qualifier, 245 
One-level control break, 443-
451 
OPEN statement, 98-99 
1-0 clause, 559-560 
Operating system, 31 
OR operator, 201 
ORGANIZATION IS INDEXED 
clause, 554 
OUTPUT PROCEDURE, 410, 
419-426 
Page heading routine, 248, 257 
Paragraph, 12 
Paragraph name 
rules for, 14-15 
standards in, 181 
Parameter list, 477 
Password protection, 268 
PERFORM statement, 105-106 
in-line perform, 232 
sections, 232-233 
TEST BEFORE/AFTER, 231-
232 
TIMES clause, 322 
THRU clause, 232-234 
UNTIL clause, 231 
PERFORM VARYING 
statement 
with one-level table, 304-
306, 340, 366-367 
with two-level table, 370-
373 
with three-level table, 382-
384 
Personal COBOL for Windows, 
643-695 
Physical record, 78 
PICTURE clause, 17, 79 
standards for, 179 
Positional table, 336 
Precedence. See Hierarchy of 
operations 
Primary key, 405 
Priming (initial) read, 100 
elimination of, 234-235, 254 
error in, 157-158 
PROCEDURE DIVISION, 12, 
97-130 
USING clause, 477-478 
Procedure name, 232 
Program specifications, 3-5 
Program stub. See Stub 
program 
PROGRAM-ID paragraph, 76 
in called program, 477 
INITIAL clause, 482 
Programmer-supplied-name, 
14-15 
Projects, 753-892 
Pseudocode, 8-9, 57-59 
Punctuation symbol, 16 
Qualification, 244-245 
Range check, 197 
Range-step table, 345-347 
in two dimensions, 392-394 
READ statement, 99-100 
false condition branch, 234-
235 
INTO clause, 235-236 
INVALID KEY clause, 561 -
562 
NEXT clause, 561 
priming read, 100, 157-158 
Readability. See Coding 
standards 
Reasonableness check, 197 
Record, 2 
RECORD CONTAINS clause, 
79 
Record description, 12, 79 
RECORD KEY clause, 554 
REDEFINES clause, 336, 338 
Reference modification, 240-
242, 504 
Registrar class, 616-619 
programming specifications, 
630 
Relational symbol, 16 
Relative subscripting, 308-309 
RELEASE statement, 410 
RESERVE AREAS clause, 554 
Reserved words, 13-14, 709-
710 
RETURN statement, 410-411 
REVERSE-VIDEO clause, 268 
REWRITE statement, 562 
Rolling total, 440-441 
ROUNDED clause, 109-110 
Running total, 440-441 
S in PICTURE clause, 176-177 
Scope terminator, 182 
Screen I/O 
ACCEPT statement, 266-269 
car validation and billing 
program, 278-297 
DISPLAY statement, 269-278 
SCREEN SECTION, 279-283, 
288-291, 491-492 
SD statement, 410 
SEARCH statement, 340, 343 
nested, 397, 398 
with two-level table, 391, 
498 
VARYING clause, 397, 398, 
498 
SEARCH ALL statement, 344-
345 
Secondary key, 405 
Section, 232 
SECURE clause, 268 
SECURITY paragraph, 75 
SELECT statement, 76 
for indexed file, 554-555, 
558, 561 
Selection structure, 55-56 
Sequence check, 197 
Sequence numbers, 29 
Sequence set, 551 
Sequence structure, 55 
Sequential file maintenance, 
515-544 
versus nonsequential, 518 
Sequential table lookup. 334-
335 
SET statement, 322, 344, 390 
SIGN clause, 408 
Sign test, 200 
Signed numbers, 176-177 
effect of collating sequence, 
406-408 
SIZE ERROR clause, 110 
Slash 
in arithmetic, 111 
to begin a page, 183 
as insertion character, 175 
Sort key, 405 
SORT statement, 409-410 
Sort work file, 410 
Sorting, 404-428 
SOURCE-COMPUTER 
paragraph, 40, 76 
Source program, 31 
SPACE-FILL clause, 268 
SPACES clause, 83 
Span of control, 54 
Stand-alone edit program, 
207-221 
START statement, 574-575 
STOP RUN statement, 102 
String processing, 237-242 
STRING statement, 238-240 
Structured design, 50-54 
Structured programming, 54-
56 
development of, 606-607 
Structured walkthrough, 162-
163 
Stub program, 61, 535 
Student class, 627-629 
programming specification, 
630 
Student-Look-Up program, 
612-616 

programming specifications, 
613 
Student-Look-Up system, 
610-639 
programming specifications, 
610 
Student PRT class, 635-639 
programming 
specifications, 636 
Subprogram, 475-507 
execution of, 585 
Subscript 
versus index, 321-324 
relative, 308-309 
rules for, 308 
Subscript check, 197 
SUBTRACT statement, 113-114 
Summary report, 375 
Symbol, 16 
Table, 302-305 
initialization of, 336-339 
one-level, 366-367, 369 
two-ievel, 368-379 
three-level, 380-390 
Table lookup 
binary, 335-336 
A;~~,~+ 
. 
-yna 
uucti aLbcas, J J U 
sequential, 334-335 
with two-level table, 390-
391 
TEST AFTER clause, 231-232 
TEST BEFORE clause, 231-232 
Test data (generation of), 535 
Three-level control break, 460-
470 
Three-level table, 380-390 
TIME clause, 206,503-504 
Top-down testing, 61-66, 535-
540 
Total line, 48 
Transaction file, 516 
Two-level control break, 451-
460 
Two-level table, 368-380 
Utility sort program, 404 
V in PICTURE clause. See 
Assumed decimal point 
VALUE clause, 83-84 
with OCCURS clause, 379, 
398 
Variable-length record, 310-
311 
Variable-length table, 310-311, 
316 
VSAM organization, 551-553 
Warnier-Orr diagram, 59,61, 
62 
WHEN clause. See SEARCH 
and SEARCH ALL 
WORKING-STORAGE 
SECTION, 12,82-84 
WRITE statement, 100-101 
FROM clause, 236 
INVALID KEY clause, 562 
WS BEGINS HERE, 236 
Xin PICTURE clause, 79 
Year 2000 program, 583-602 
COBOL intrinsic calendar 
functions, 591-593 
date arithmetic, 590-593 
leap-year problem, 594 
leap-year processing, 584 
problem description, 
584-590 
retirement program, 
594-599 
ZERO FILL clause, 268 
Zero suppression, 172, 174 
ZEROS clause, 83 
Undefined symbol, 505 
UNDERLINE clause, 268 
Unique code, 333 
Unresolved external reference, 
505 
UNSTRING statement, 240, 
241 
UPDATE clause, 268 
USAGE clause, 309-310 
USING 
in SORT statement, 410, 
414-419 
in subprogram, 471-478 

