
Requirements Engineering

Jeremy Dick · Elizabeth Hull
Ken Jackson
Requirements Engineering

Jeremy Dick, BSc (Eng), ACGI, DPhil, DIC, MA
Costain Group PLC
Maidenhead
UK
Elizabeth Hull
Professor Emerita of Computing Science
Ulster University
Newtownabbey, Co Antrim
UK
Ken Jackson, BSc, MSc, MBCS
Retired
Alton
UK
ISBN 978-3-319-61072-6
ISBN 978-3-319-61073-3 (eBook)
DOI 10.1007/978-3-319-61073-3
Library of Congress Control Number: 2017952348
© Springer International Publishing Switzerland 2017
Originally published in the series “Practitioner Series”
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recita-
tion, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or infor-
mation storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar
methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publica-
tion does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the
relevant protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this
book are believed to be true and accurate at the date of publication. Neither the publisher nor the
authors or the editors give a warranty, express or implied, with respect to the material contained herein
or for any errors or omissions that may have been made. The publisher remains neutral with regard to
jurisdictional claims in published maps and institutional afﬁliations.
Printed on acid-free paper
This Springer imprint is published by Springer Nature
The registered company is Springer International Publishing AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

We would like to dedicate this book as follows:
To my wife Yvonne,
to my children Sebastian, Timothy, Angus,
Robin and Felicity,
and to my grandchildren Henry, Ethan,
Teddy, Tristan and Imogen.
Jeremy Dick
To my late parents John and Edna Hull.
Elizabeth Hull
To my wife Chris,
to my children and their spouses Kate, Stef,
Andy, Amy and Pete,
and to my grandchildren Lizzie, Alice, Emily,
Annabel and Sophie.
Ken Jackson

Preface to the Fourth Edition
We are grateful to the many students and practitioners who have purchased our
book, and helped it survive through to this, the fourth edition.
Two of us, Elizabeth Hull and Ken Jackson, are now enjoying retirement, leav-
ing Jeremy Dick to continue gaining experience in practical, tool-supported
requirements engineering.
This fourth edition is driven by new insights gained from this ongoing experi-
ence, and also by the evolution of the tools referenced in the book.
In particular, we have:
• Strengthened the discussion about the problem and solution spaces by introducing
the concept of “design agnosticism.”
• Added information about SysML, the systems engineering modelling exten-
sions to UML.
• Reworked most of the diagrams that are models of some kind using Enterprise
Architect from Sparx Systems.
• Provided new material on traceability in Chap. 7 gleaned from practical
application.
• Rewritten the chapter on DOORS to base it on IBM Rational DOORS Next
Generation.
• Swapped the order of Chaps. 8 and 9 so that the book ends with the manage-
ment section.
• Added a “ﬁnal word” to the new Chap. 9 about cultural change as the key to
success.
We hope that readers will, as a result, ﬁnd the content fresh for meeting today’s
Systems Engineering changes.
May 2017
Jeremy Dick
Elizabeth Hull
Ken Jackson
vii

Preface to the Third Edition
In our desire to keep the material in this book current, the main driver in creating
a new edition has been to keep up with the latest release of DOORS. Since the
publication of Edition 2, Telelogic—the developers of DOORS—has been
acquired by IBM, and the tool has become part of the IBM/Rational stable. While
the basic functions of the tool remain unchanged, the look-and-feel has advanced
considerably. Therefore, Chap. 9 has been updated for DOORS version 9.2.
At the same time, we felt the need to provide a more explicit deﬁnition of
requirements engineering. In searching the literature, we could not ﬁnd a satisfac-
tory deﬁnition, and we have addressed this in Chap. 1.
Apart from this, there is an expanded description of Product Family
Management in Chap. 8, and a variety of small corrections throughout.
We hope our readers—students and practitioners—continue to ﬁnd this to be a
valuable book in advancing their understanding of the topic.
April 2010
Elizabeth Hull
Ken Jackson
Jeremy Dick
viii

Preface to the Second Edition
This second edition follows quickly on the ﬁrst edition and is an indication of
how fast the subject is changing and developing. In the past 2 years there have
been signiﬁcant advances and these are reﬂected in this new edition.
Essentially, this is an update that places more emphasis on modelling by
describing a greater range of approaches to system modelling. It introduces the
UML2, which is the recent standard approved by the OMG. There is also an
enhanced discussion on the relationship between requirements management and
modelling, which relates well to the concept of rich traceability.
The chapter on the requirements management tool DOORS has been revised to
use version 7 of the tool and this is complemented with examples taken from the
DOORS/Analyst tool which demonstrates how the concepts of modelling can be
captured and created within DOORS.
The text is still aimed at students and practitioners of systems engineering who
are keen to gain knowledge of using requirements engineering for system
development.
As before, a website supporting additional material is available at:
http://www.requirementsengineering.info
June 2004
Elizabeth Hull
Ken Jackson
Jeremy Dick
ix

Preface to the First Edition
Requirements engineering is common sense, but it is perceived to be difﬁcult and
is not well understood. For these reasons it is generally not very well done. The
ever-increasing pressures on an organisation are often given as the main reasons
for not introducing a more disciplined approach to requirements engineering, but
its aim will be to do the job properly, so the task of the requirements engineer is
to work out how best to help the organisation achieve its goal.
Systems engineering is critical in today’s industry and requirements engineering
is an important stage of that overall process. A good process is a key to requirements
engineering—it determines how efﬁciently and rapidly products can be generated.
This is particularly important in a global competitive market where the “time to
market” and meeting stakeholder requirements are the key success factors.
Requirements engineering is also about management and hence issues in rela-
tion to requirements and management blend to show how requirements can be
used to manage systems development.
The book is concerned with engineering requirements and how systems engi-
neers may be helped to create better requirements. A generic process is presented
which assists the reader in gaining a good understanding of the essence of require-
ments engineering. The process is then instantiated for the problem and solution
domains of development. This book also addresses the concept of system modelling
and presents various techniques and methods which are widely used. An important
feature of the book is the presentation of approaches to traceability, the way in
which it is captured and discusses metrics which can be derived from traceability.
Finally, the book presents an overview of DOORS which is a tool for requirements
management. A case study is used to illustrate the process presented in the book
and the features of the tool.
This book should be read by those systems engineers (requirements engineers) in
industry, who, being practitioners are keen to gain knowledge of using requirements
engineering for system development. The book will also be of interest to ﬁnal year
undergraduate students in Computer Science, Software Engineering and Systems
Engineering studying a course in Requirements Engineering and also to postgraduate
research students in Computer Science or more generally in Engineering.
x

The approach taken in this book is based on current research in requirements
engineering, however, it has not only taken the academic view but has also built sub-
stantially on current experience of working in industry to enable system engineers to
manage requirements (and projects) more successfully. It provides a snapshot, in this
rapidly evolving subject, of what we see as best practice in requirements engineering
today.
May 2002
Elizabeth Hull
Ken Jackson
Jeremy Dick
xi
Preface to the First Edition

Acknowledgements
Thanks are due to a number of individuals and organisations who helped in
various ways:
Richard Stevens, who inspired us with his work on requirements management
and who laid the foundation for the work in this book. He was the founder of
Requirements Engineering Limited (later Quality Systems and Software Limited)
which developed the DOORS tool.
Les Oliver (who worked for Astrium at the time) for his assistance in the devel-
opment of statecharts for agreement, qualiﬁcation and satisfaction.
Praxis Critical Systems (now Altran Praxis) for their initial concept of design
justiﬁcation which become Rich Traceability.
Keith Collyer, Jill Burnett and other colleagues of Telelogic Limited for their
contributions to ideas presented in this book and for reviews, comments, sugges-
tions and encouragement.
Our various employers such as the University of Ulster, Telelogic Limited,
IBM, Integrate Systems Engineering Limited and SyntheSys Systems Engineers
Limited and our customers over 20 years who have given us, explicitly and impli-
citly, the latitude and opportunity to develop the ideas, materials and examples of
this book.
xiii

Contents
1
Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Introduction to Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Introduction to Systems Engineering. . . . . . . . . . . . . . . . . . . . . .
4
1.3
Deﬁning Requirements Engineering . . . . . . . . . . . . . . . . . . . . . .
7
1.3.1
Deﬁnition of a Requirement. . . . . . . . . . . . . . . . . . . . . . .
7
1.3.2
Deﬁnition of a Stakeholder . . . . . . . . . . . . . . . . . . . . . . .
8
1.3.3
Deﬁnition of Requirements Engineering. . . . . . . . . . . . . .
9
1.4
Requirements and Quality. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
1.5
Requirements and the Lifecycle . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.6
Requirements Tracing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.7
Requirements and Modelling . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.8
Requirements and Testing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
1.9
Requirements in the Problem
and Solution Domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
1.10 Requirements and Design Agnosticism . . . . . . . . . . . . . . . . . . . .
23
1.11 Requirements and Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
1.12 How to Read this Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
2
A Generic Process for Requirements Engineering . . . . . . . . . . . . . .
33
2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
2.2
Developing Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
2.3
Generic Process Context. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
2.3.1
Input Requirements and Derived Requirements . . . . . . . .
38
2.3.2
Acceptance Criteria and Qualiﬁcation Strategy. . . . . . . . .
38
2.4
Generic Process Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.4.1
Ideal Development. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.4.2
Development in the Context of Change . . . . . . . . . . . . . .
41
2.5
Generic Process Information Model . . . . . . . . . . . . . . . . . . . . . .
43
2.5.1
Information Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
2.5.2
Agreement State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.5.3
Qualiﬁcation State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
xv

2.5.4
Satisfaction State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
2.5.5
Information Model Constraints. . . . . . . . . . . . . . . . . . . . .
48
2.6
Generic Process Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
2.6.1
Agree Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
2.6.2
Analyse and Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.6.3
Derive Requirements and Qualiﬁcation Strategy. . . . . . . .
52
2.7
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
3
System Modelling for Requirements Engineering . . . . . . . . . . . . . .
57
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.2
Representations for Requirements Engineering . . . . . . . . . . . . . .
58
3.2.1
Data Flow Diagrams . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
3.2.2
Entity-Relationship Diagrams. . . . . . . . . . . . . . . . . . . . . .
64
3.2.3
Statecharts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
3.2.4
Object-Oriented Approaches . . . . . . . . . . . . . . . . . . . . . .
66
3.3
Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
3.3.1
Viewpoint Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
3.3.2
Object-Oriented Methods. . . . . . . . . . . . . . . . . . . . . . . . .
78
3.3.3
The UML Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
3.3.4
SysML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
3.3.5
Formal Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
3.4
Model-Based Systems Engineering . . . . . . . . . . . . . . . . . . . . . . .
91
3.5
Modelling and Qualiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
3.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
4
Writing and Reviewing Requirements . . . . . . . . . . . . . . . . . . . . . . .
93
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
4.2
Requirements for Requirements . . . . . . . . . . . . . . . . . . . . . . . . .
94
4.3
Structuring Requirements Documents . . . . . . . . . . . . . . . . . . . . .
94
4.4
Key Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
96
4.5
Using Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
4.5.1
Deﬁnition of a Requirement Expression . . . . . . . . . . . . . .
97
4.6
Ensuring Consistency Across Requirements . . . . . . . . . . . . . . . .
99
4.7
Value of a Requirement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
4.8
The Language of Requirements. . . . . . . . . . . . . . . . . . . . . . . . . .
101
4.9
Requirement Boilerplates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
103
4.10 Granularity of Requirements. . . . . . . . . . . . . . . . . . . . . . . . . . . .
105
4.11 Requirements and Modelling . . . . . . . . . . . . . . . . . . . . . . . . . . .
107
4.12 Criteria for Writing Requirements Statements . . . . . . . . . . . . . . .
107
4.13 Guide to Writing Requirements. . . . . . . . . . . . . . . . . . . . . . . . . .
109
4.14 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
111
5
Requirements Engineering in the Problem Domain . . . . . . . . . . . . .
113
5.1
What is the Problem Domain? . . . . . . . . . . . . . . . . . . . . . . . . . .
113
5.2
Instantiating the Generic Process. . . . . . . . . . . . . . . . . . . . . . . . .
114
5.3
Agree Requirements with Customer . . . . . . . . . . . . . . . . . . . . . .
116
xvi
Contents

5.4
Analyse & Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
5.4.1
Identify Stakeholders . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
5.4.2
Create Usage Model . . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
5.4.3
Scoping the System . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
5.5
Derive Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
5.5.1
Deﬁne Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
5.5.2
Capture Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . .
126
5.5.3
Deﬁne Acceptance Criteria. . . . . . . . . . . . . . . . . . . . . . . .
133
5.5.4
Deﬁne Qualiﬁcation Strategy . . . . . . . . . . . . . . . . . . . . . .
133
5.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
134
6
Requirements Engineering in the Solution Domain . . . . . . . . . . . . .
135
6.1
What is the Solution Domain . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
6.2
Engineering Requirements From Stakeholder Requirements
to System Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
6.2.1
Producing the System Model . . . . . . . . . . . . . . . . . . . . . .
137
6.2.2
Creating System Models to Derive System Requirements .
139
6.2.3
Banking Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
6.2.4
Car Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
147
6.2.5
Deriving Requirements From a System Model . . . . . . . . .
152
6.2.6
Agreeing the System Requirements with the Design Team
153
6.3
Engineering Requirements From System Requirements
to Subsystems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
154
6.3.1
Creating a System Architecture Model . . . . . . . . . . . . . . .
154
6.3.2
Deriving Requirements From an Architectural
Design Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
6.4
Other Transformations Using a Design Architecture . . . . . . . . . .
156
6.5
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
157
7
Advanced Traceability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
7.2
Elementary Traceability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
160
7.3
Rationale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
162
7.4
Satisfaction Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
162
7.5
Rich Traceability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
163
7.6
Supporting Information and Evidence . . . . . . . . . . . . . . . . . . . . .
167
7.7
Sufﬁciency and Necessity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
169
7.8
Reviewing Traceability. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
170
7.9
The Language of Satisfaction Statements . . . . . . . . . . . . . . . . . .
170
7.10 Rich Traceability Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
170
7.11 Requirements Flow-down . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
172
7.12 Rich Traceability for Qualiﬁcation . . . . . . . . . . . . . . . . . . . . . . .
173
7.13 Implementing Rich Traceability . . . . . . . . . . . . . . . . . . . . . . . . .
174
7.13.1 Single-layer Rich Traceability . . . . . . . . . . . . . . . . . . . . .
174
7.13.2 Multi-layer Rich Traceability . . . . . . . . . . . . . . . . . . . . . .
174
7.14 Design Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
175
xvii
Contents

7.15 Metrics for Traceability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
179
7.15.1 Breadth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
180
7.15.2 Depth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
181
7.15.3 Growth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
181
7.15.4 Balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
182
7.15.5 Latent Change . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
183
7.16 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
185
8
DOORS: A Tool to Manage Requirements. . . . . . . . . . . . . . . . . . . .
187
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
187
8.2
The Case for Requirements Management . . . . . . . . . . . . . . . . . .
188
8.3
DOORS Information Model . . . . . . . . . . . . . . . . . . . . . . . . . . . .
188
8.4
The Project Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
189
8.5
Modules as Documents. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
191
8.6
Artifacts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
192
8.7
Traceability Links. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
194
8.8
Views. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
196
8.8.1
Rows in Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
197
8.8.2
Columns in Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
199
8.9
Artifact Types and Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . .
201
8.10 Import and Export . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
205
8.11 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
206
9
Management Aspects of Requirements Engineering . . . . . . . . . . . .
207
9.1
Introduction to Management . . . . . . . . . . . . . . . . . . . . . . . . . . . .
207
9.2
Requirements Management Problems . . . . . . . . . . . . . . . . . . . . .
208
9.2.1
Summary of Requirement Management Problems. . . . . . .
210
9.3
Managing Requirements in an Acquisition Organisation . . . . . . .
210
9.3.1
Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
210
9.3.2
Monitoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
213
9.3.3
Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
213
9.4
Supplier Organisations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
215
9.4.1
Bid Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
215
9.4.2
Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
219
9.5
Product Organisations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
221
9.5.1
Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
221
9.5.2
Monitoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
225
9.5.3
Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
226
9.6
Agile Development. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
227
9.7
Organisational Culture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
228
9.8
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
229
9.8.1
Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
229
9.8.2
Monitoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
9.8.3
Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
9.8.4
Organisational Culture . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
231
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
235
xviii
Contents

Chapter 1
Introduction
There is no fair wind for one who knows not whither
he is bound.
(Lucius Annaeus Seneca, philosopher, 3 - 65 AD)
1.1
Introduction to Requirements
If ever systems development projects needed a “fair wind,” they certainly do so
today. Fast-changing technology and increased competition are placing ever-
increasing pressure on the development process. Effective requirements engineer-
ing lies at the heart of an organisation’s ability to guide the ship and to keep pace
with the rising tide of complexity.
Software is currently the dominant force of change of new products. The trend
is driven by three key factors:
Arbitrary complexity. The most complex systems tend to be those with software,
often integrated deep inside the system’s components. The complexity of such
products is limited only by the imagination of those who conceive them.
Instant distribution. Today a company can think of a new product, implement it in
software, and rapidly distribute it around the world. For example, a car manu-
facturer can improve the software in its diagnostic system, and then transmit it
electronically around the world to tens of thousands of car showrooms in a day.
Off-the-shelf components. Systems are now constructed from bought-in technology
and ready-made components with a corresponding reduction in the product
development cycle.
The net impact of these trends is a sudden intensity of competition, and the
ability to monopolise the rewards from the new technology without needing large
factories. The result is pressure to reduce the development cycle and the time to
1
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_1

deploy technology. But “time to market” is not sufﬁcient. The real goal is “time to
market with the right product.” Establishing the requirements enables us to agree
on and visualise the “right product.” A vital part of the systems engineering pro-
cess, requirements engineering ﬁrst deﬁnes the problem scope and then links all
subsequent development information to it. Only in this way can one expect to con-
trol and direct project activity; managing the development of a solution that is
both appropriate and cost-effective.
Requirements are the basis for every project, deﬁning what the stakeholders—
users, customers, suppliers, developers, businesses—in a potential new system
need from it, and also what the system must do in order to satisfy that need. To be
well understood by everybody they are generally expressed in natural language
and herein lies the challenge: to capture the need or problem completely and
unambiguously without resorting to specialist jargon or conventions. Once com-
municated and agreed, requirements drive the project activity. However the needs
of the stakeholders may be many and varied, and may indeed conﬂict. These needs
may not be clearly deﬁned at the start, may be constrained by factors outside their
control or may be inﬂuenced by other goals which themselves change in the
course of time. Without a relatively stable requirements base a development pro-
ject can only ﬂounder. It is like setting off on a sea journey without any idea of
the destination and with no navigation chart. Requirements provide both the “navi-
gation chart” and the means of steering towards the selected destination.
Agreed requirements provide the basis for planning the development of a
system and accepting it on completion. They are essential when sensible and
informed trade-offs have to be made and they are also vital when, as inevitably
happens, changes are called for during the development process. How can the
impact of a change be assessed without an adequately detailed model of the prior
system? Otherwise what is there to revert to if the change needs to be unwound?
Even as the problem to be solved and potential solutions are deﬁned one must
assess the risks of failing to provide a satisfactory solution. Few sponsors or stake-
holders will support product or systems development without a convincing risk
management strategy. Requirements enable the management of risks from the ear-
liest possible point in development. Risks raised against requirements can be
tracked, their impact assessed, and the effects of mitigation and fall-back plans
understood, long before substantial development costs have been incurred.
Requirements therefore form the basis for:
• Project planning;
• Risk management;
• Trade off;
• Acceptance testing;
• Change control.
The most common reasons for project failure are not technical. The Standish
Group have been producing their CHAOS report in project success and failure
since 1994. Table 1.1 shows the 1995 ﬁgures identifying the main reasons why
projects fail. It shows the percentage of projects that stated various reasons for
2
1
Introduction

project failure. Those marked with a double asterisk are directly related to require-
ments, and those with a single asterisk are somewhat related.
The problems fall into three main categories:
Requirements—either poorly organised, poorly expressed, weakly related to stake-
holders, changing too rapidly, or unnecessary; unrealistic expectations;
Management problems of resources—failure to have enough money, and lack of
support, or failure to impose proper discipline and planning, many of these
arise from poor requirements control;
Politics—which contributes to the ﬁrst two problems.
All these factors can be addressed at fairly low cost.
Project success factors from the same period are not quite the inverse of the
failure factors, but as can be seen in Table 1.2. Management support and proper
planning are clearly seen as important here—the larger the project, and the longer
its schedule, the higher the chance of failure (Scientiﬁc American, Sept 1994).
Over the years, the way in which Standish correlate their data has evolved a lit-
tle, but the underlying factors remain relatively unchanged. Table 1.3 shows the
data for project success criteria from 2015.
Table 1.1 Reasons for project failure (Standish Group (1995))
**
Incomplete requirements
13.1%
**
Lack of user involvement
12.4%
Lack of resources
10.6%
*
Unrealistic expectations
9.9%
Lack of executive support
9.3%
**
Changing requirements/speciﬁcations
8.7%
Lack of planning
8.1%
**
Didn’t need it any longer
7.5%
Table 1.2 Project success factors (Standish Group (1995))
**
User involvement
15.9%
Management support
13.9%
**
Clear statement of requirements
13.0%
Proper planning
9.6%
*
Realistic expectations
8.2%
Smaller milestones
7.7%
Competent staff
7.2%
*
Ownership
5.3%
3
1.1
Introduction to Requirements

This book considers an engineering approach to requirements in general and
requirements management in particular. It explains the differences between stake-
holder requirements and system requirements and indicates how requirements can
be used to manage system development. It also shows how traceability from stake-
holder requirements through system requirements to design can be used to mea-
sure progress, manage change and assess risks. It exposes the reader to those
qualities of requirements that make them suitable for validating and verifying
designs and solutions, and stresses the need to produce designs that can be inte-
grated and tested easily.
Requirements management has important interfaces to project management,
which is recognised in the book through the presence of Chap. 9, “Management
Aspects of Requirements Engineering.”
1.2
Introduction to Systems Engineering
This book is not just about requirements for software. The principles and practice
of requirements engineering apply to complete systems in which software may
only play a small part.
For example, consider a railway system such as the UK’s West Coast Mainline
from London to Glasgow. A high-level requirement on the system may be to
achieve a journey time from Euston Station in London to Glasgow in Scotland in
less than 250 minutes. Satisfaction of this single requirement arises from the coor-
dinated interaction of every major component of the system:
• The trains, and their speed;
• The tracks, and their ability to support high-speed trains;
• The stations and station staff, and the waiting time they impose on the trains;
• The drivers, and their ability to control the trains;
• The signalling subsystems;
Table 1.3 Project success factors (Standish Group (2015).)
*
Executive management support
20%
**
User involvement
15%
Optimization
15%
Skilled resources
13%
Project management expertise
12%
*
Agile process
10%
**
Clear business objectives
6%
*
Emotional maturity
5%
Execution
3%
Tools and infrastructure
1%
4
1
Introduction

• The train control and detection subsystems;
• The power delivery subsystems.
While the software in the signalling and control subsystems plays a vital part in
achieving this requirement, it cannot deliver alone. The complete solution involves
the whole system. In fact, most requirements are satisﬁed by the properties that
emerge from the way the system as a whole behaves.
What then is meant by a “system”?
System: a collection of components—machine, software and human—
which co-operate in an organised way to achieve some desired result—the
requirements.
Thus systems include people. In the West Coast Mainline, the drivers and sta-
tion staff—the training they receive and the procedures they use—are just as
important as the software and machine components.
Since components must co-operate, interfaces between components are a vital
consideration in system (and requirements) engineering—interfaces between peo-
ple and machine components, between machine components, and between
software components. An example of a machine-to-machine interface in a railway
system is the way train wheels interface with the track. Apart from the physical
arrangements (which are designed to allow the train to be guided along the track
without sliding off), electrical currents across the rails may be used to detect the
presence of the train as part of the train control subsystem.
At the heart of the concept of a “system,” lies the idea of “emergent proper-
ties.” This refers to the fact that the usefulness of a system does not depend on
any particular part of the system, but emerges from the way in which its compo-
nents interact. Emergent properties may be desirable, in that they have been antici-
pated and designed into the system so as to make the system useful; or they may
be undesirable, in other words unanticipated side effects, such as harm to the
environment. The trick in system design is to be able to harness desirable emer-
gent properties, and avoid the undesirable ones.
Some emergent properties are so intrinsic to a system that they are often not
expressed as requirements; for instance, the ability of an aircraft to ﬂy, which abil-
ity emerges from the complex interaction of all major components of the system.
However, there may be good reasons for stating the obvious requirement, The air-
craft shall be capable of ﬂight, since some aspects of the aircraft design are crucial
to maintaining this ability, such as the distribution of mass giving rise to the cor-
rect centre of gravity. An analogous example is the ability of a ship to ﬂoat, which
emerges from the overall weight of the ship, the shape of its hull, and its centre of
gravity. Typically a target displacement tonnage of the ship is established as a
requirement, which is then tracked during design as a Key Performance Indicator.
Another important concept is that of “systems of systems.” Every system can
be construed as being part of a larger, enclosing system. For example, the West
5
1.2
Introduction to Systems Engineering

Coast Mainline is part of a wider railway system, and intersects with other major
and minor routes. The entire railway system is part of the wider transport system,
and interacts in all kinds of ways with the road and air transport networks. The
transport system itself provides essential infrastructure for the transport of goods
and people as part of the economy of the country. And the country is part of the
wider world, and so forth.
To understand the requirements of a system properly is to understand its
enclosing system. Often the correct functioning of a system depends on provisions
of the enclosing system. For example, the ability of a helicopter to ﬂy depends on
the environment provided by the earth, its gravitation ﬁeld and atmosphere.
Take another, very simple, example: a cup. It is evident that it has components:
a handle and a bowl-shaped container. What purpose do these components serve?
The bowl is for containing liquid, and the handle is to allow the bowl to be held
by someone without getting burnt. One may deduce that the purpose of—or
requirement for—the cup is to allow a human being to transfer hot liquid into the
mouth without spilling it or getting burnt.
The cup is rich in interfaces. It can be placed on a ﬂat surface for stability; it
can be held in a human hand; it can be ﬁlled with ﬂuid and emptied; it must inter-
face with the ﬂuid for sustained containment; and it must deliver ﬂuid to the
human mouth (Fig. 1.1).
But there are other observations to be made:
• The cup is no good on its own. It depends on the motor-movement of the
human arm to achieve its purpose;
• The bowl part of the cup depends crucially on the presence of gravity for its
correct functioning. It also has to be used correctly: holding the cup upside
down would cause spilling, and may cause scalding.
At the end of the day, the ability of this simple cup to fulﬁl its purpose
depends on:
• The properties that emerge from the interaction of its components;
• Appropriate interfaces to external components;
Interface: for filling
Component: handle
Component: bowl
Interface : to liquid
Interface: to mouth
Environment: gravity
Interface: to table
Interface: to hand
Fig. 1.1 A cup as a very simple system
6
1
Introduction

• Its correct embedding in the enclosing system—being held in the human hand
and lifted by the arm;
• The presence of the proper environment—another solution would be necessary
in weightless conditions.
In summary, the engineering of requirements must take the nature of systems
into account. Essential considerations are emergent properties, the constraints and
provisions of the external environment, and the interfaces with surrounding
systems.
1.3
Deﬁning Requirements Engineering
Because of the inter-connectedness of requirements with other aspects of systems
engineering and project management, it is quite challenging to ﬁnd a satisfactory
scope for a deﬁnition of requirements engineering.
1.3.1
Deﬁnition of a Requirement
First of all, what is meant by a requirement? Here is a typical deﬁnition drawn
from IEEE-STD-1220-1998 (IEEE 1998):
Requirement: a statement that identiﬁes a product or process operational,
functional, or design characteristic or constraint, which is unambiguous,
testable or measurable, and necessary for product or process acceptability
(by consumers or internal quality assurance guidelines).
This deﬁnition draws out a number of facets of a requirement that are brieﬂy
discussed here, and in greater detail later:
• Statement. That a requirement should be a statement is perhaps biased towards
textual expression, whereas they can also be captured in tabular form, such as
in Tom Gilb’s Planguage (Gilb 2005), in diagrammatic form in notations
such as UML (OMG 2003), in formal notations, such as Z (Spivey 1989),
VDM (Jones 1986), LOTOS (Bjorner 1987) and the B-Method (Abrial 1996),
or in domain-speciﬁc notations, e.g. (Chaochen et al. 1991). The important
concept, though, is to have a set of traceable, manageable elements identiﬁed
as requirements.
• Product or process. Complete solutions contain varying mixtures of product
(things that are built in response to requirements) and process (procedures
for using the things that are built). Requirements may therefore deﬁne
7
1.3
Deﬁning Requirements Engineering

process as well as product. In addition to this, there may be requirements
that stipulate how the product should be developed, usually for quality con-
trol purposes.
• Operational, functional, or design characteristic or constraint. There are many
different kinds of requirement, giving rise to different kinds of language, analy-
sis, modelling, process and solution. Note that this deﬁnition has carefully
avoided the term “non-functional,” since there is heated debate about what this
actually means. Design characteristics cover performance, usability, safety,
maintainability and a host of other qualities.
• Unambiguous. A statement of requirement has desirable qualities that will be
addressed in detail later. In brief, a requirement should lend itself to a clear,
single understanding, common to all parties involved.
• Testable or measurable. Requirements are used to test that the design or solu-
tion is acceptable. For this to be possible, the requirement should be quantiﬁed,
thus providing a means of “measuring” the solution against it.
• Necessary for product or process acceptability. This highlights the multi-
dimensional role that requirements play: they serve to deﬁne what should be
designed and developed, and also deﬁne how the solution should be tested and
accepted. They have an inﬂuence in the earliest stages of the development pro-
cess as well as in the latest stages during acceptance.
• By consumers or internal quality assurance guidelines. Requirements come
from many sources, including but not limited to customers, regulatory bodies,
users and internal quality procedures.
Some other synonyms for requirements are: aims, aspirations, capabilities, cri-
teria, constraints, directives, doctrines, duties, expectations, features, functions,
goals, missions, needs, obligations, objectives, orders, regulations, rules, etc.
1.3.2
Deﬁnition of a Stakeholder
The term “stakeholder” has already been used without giving a deﬁnition:
Stakeholder: An individual, group of people, organisation or other entity
that has a direct or indirect interest (or stake) in a system.
A stakeholder’s interest in a system may arise from using the system, beneﬁting
from the system (in terms of revenue or other advantage), being disadvantaged by
the system (in terms, for instance, of cost or potential harm), being responsible for
the system, or otherwise being affected by it.
Stakeholders are legitimate sources of requirements.
8
1
Introduction

1.3.3
Deﬁnition of Requirements Engineering
The term “requirements engineering” is often too narrowly equated with require-
ments analysis, which is just one of the activities within the wider discipline. The
emphasis on engineering is useful for two main reasons:
1. Dealing with requirements is an essential part of every engineering endeavour.
Indeed, requirements engineering is a subset of systems engineering in general,
not just software engineering;
2. The term subsumes the wide variety of other titles given to activities relating to
requirements, such as requirements analysis and the two terms used for key
process areas in CMMI® (CarnegieMellon 2006): requirements management
and requirements development.
The following, broader deﬁnition is one of the most long-standing, and comes
from a DoD software strategy document dated 1991:
Requirements engineering “involves all life-cycle activities devoted to identiﬁcation of
user requirements, analysis of the requirements to derive additional requirements, docu-
mentation of the requirements as a speciﬁcation, and validation of the documented require-
ments against user needs, as well as processes that support these activities.” (DoD 1991)
While this deﬁnition covers the identiﬁcation, analysis, development and valida-
tion of requirements, it omits to mention the vital role that requirements play in
accepting and verifying the solution (usually called veriﬁcation rather than valida-
tion.) A more recent deﬁnition, given in the context of software engineering, suffers
the same defect, but emphasizes the goal-oriented (or purpose-oriented) nature of
requirements engineering, and hints at the importance of understanding and docu-
menting the relationships between requirements and other development artefacts:
Requirements engineering is the branch of software engineering concerned with the real-
world goals for, functions of, and constraints on software systems. It is also concerned
with the relationship of these factors to precise speciﬁcations of software behavior, and to
their evolution over time and across software families. (Zave 1997)
For the purposes of this book, the following deﬁnition will be used:
Requirements engineering: the subset of systems engineering concerned
with discovering, developing, tracing, analyzing, qualifying, communicating
and managing requirements that deﬁne the system at successive levels of
abstraction.
This deﬁnition lists carefully selected key activities that are considered proper
to requirements engineering. There are some activities closely related to require-
ments that are considered to be part of some other discipline. An example of this
is system testing or veriﬁcation; while requirements should have the qualities
9
1.3
Deﬁning Requirements Engineering

necessary to allow the solution to be veriﬁed, the veriﬁcation activity itself is
another discipline. It also references the concept of requirements existing at multi-
ple levels of development.
Here are some notes on the deﬁnition:
• Discovering. This covers a number of terms often used, such as requirements
elicitation and capture.
• Tracing. Tracing of requirements to other artefacts, including requirements at
other layers, provides a means of validating requirements against real-world
needs, of capturing rationale for the design, and of verifying the design against
requirements.
• Qualifying. This refers to all kinds of testing activity, covering testing of the
design and solution, including unit, component, integration, system, acceptance
testing. There is considerable disagreement over the meaning of the terms “ver-
iﬁcation” and “validation.” The term “qualifying” is preferred, because it is
about ensuring that the solution has the required “qualities.” In so much as the
terms are used in this book, to validate requirements is to check a formal
expression of requirements against informal needs as understood in the minds
of stakeholders, and to verify requirements is to check their internal consistency
within layers and between layers of abstraction.
• Communicating. Requirements are the means of communication through which
customers, suppliers, developers, users and regulators can agree on what is to
be achieved.
• Levels of abstraction. This makes reference to the practice of organizing
requirements into layers and of tracing the satisfaction relationship between
those layers. The requirements of the top layer deﬁne the system in terms of
the problems to be solved as agreed by the stakeholders and validated against
their real needs; requirements at subsequent layers deﬁne the whole or part of
the system in terms of an implementable solution as veriﬁed against the
requirements at the layer above; requirements at every layer provide a precise
means of qualifying the solution. The satisfaction relation between require-
ments is induced by recording satisfaction between layers as a many-to-many
relationship.
1.4
Requirements and Quality
The consequences of having no requirements are many and varied. There is ample
evidence around us of systems that failed because requirements were not properly
organised. However well the system may appear to work at ﬁrst, if it is not the
system that users want or need then it will be useless—or user-less.
It is interesting to consider the relationship between requirements and quality.
The term “quality” may be understood in a variety of ways. When asked about
10
1
Introduction

quality cars, one might mention Rolls Royce, Mercedes or Jaguar. This inherent
confusion between “quality” and “luxury” is exposed if consideration is given to
choosing the best car for the annual RAC rally. Neither Rolls Royce, Mercedes
nor Jaguar is chosen, since none of them exhibit the right weight/power ratio,
ground clearance and robustness properties. Recent history shows that the best
quality car in its class is a Skoda—not a luxury car, but the right quality of car for
the job.
Quality, then, is “ﬁtness for purpose” or conformance to requirements—it is
providing something that satisﬁes the customer and in doing so ensures that the
needs of all the stakeholders are taken into account.
As is seen in Chap. 9, requirements engineering acts as a compliment to other
management considerations, such as cost and schedule, by providing a vital focus
on the delivery of quality. Every management decision is a compromise between
cost, schedule and quality, three inter-related axes.
Since requirements engineering is a discipline that applies from the start of the
development lifecycle, the leverage on quality that can be exercised by proper
requirements management is proportionately greater. Relatively little effort
expended in early stages of development can reap dividends in the later stages.
The adage “Quality is Free” (the title of a book by Phil Crosby) holds true, in that
getting it right at the outset can save huge amounts of effort that would have been
necessary to put things right later. Improving requirements means improving the
quality of the product.
1.5
Requirements and the Lifecycle
There is a common misconception that requirements engineering is just a single
phase that is carried out and completed at the outset of product development. The
purpose of this section is to demonstrate that requirements engineering has a vital
role to play at every stage of development.
As an initial approach, consider one of the very last activities in the develop-
ment process: acceptance testing. What is a system accepted against? The stake-
holder requirements. So it can be seen straight away that requirements developed
at the outset are still in use in the ﬁnal stages of development.
The classic V-Model, which is used to portray the various stages of develop-
ment, has its basis in this relationship between testing and requirements.
Figure 1.2 shows this relationship at every stage of development.
The V-Model also views development in terms of layers, each layer addressing
the concerns proper to the corresponding stage of development. Although slightly
different processes may be used at each layer, the basic pattern of requirements
use is the same—a point reinforced through the introduction of a generic process
in Chap. 2. Fig. 1.3 shows the main concern of requirements engineering at each
layer.
11
1.5
Requirements and the Lifecycle

Another role that requirements can play in an organisation is to act as a means
of communicating between projects. This is a good idea, because many organisa-
tions wish to:
• Maximise reuse of artefacts across projects;
• Manage families of similar products;
• Use programme management to coordinate activities;
• Optimise process by learning from the experiences of other projects.
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test
Integration 
test
Component 
test
Acceptance 
test
Testing is with
respect to
requirements 
Fig. 1.2 Requirements in the V-Model
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test
Integration 
test
Component 
test
Acceptance 
test
defining results for stakeholders,
validating the product
defining what the system must do,
verifying the system
optimising the cost-benefits,
qualifying the requirements
allocating requirements,
qualifying components
Fig. 1.3 Requirements engineering in layers
12
1
Introduction

A good set of stakeholder requirements can provide a concise non-technical
description of what is being developed at a level that is accessible to senior man-
agement. Similarly, the system requirements can form an excellent technical sum-
mary of a development project. These descriptions can serve as a basis for
comparison with other activities. This is illustrated in Fig. 1.4.
If requirements are to play such a central role in systems development, they
need to be maintained. To change the design of a product without having also
updated the requirements to reﬂect that change, is to store up huge problems for
later stages of development. Hence requirements engineering connects strongly
with change management.
Whether change originates from within a project—e.g. technical issues arising
from details of the design—or from without—e.g. evolving stakeholder needs—
the impact of that change on quality, cost and schedule needs to be assessed. This
assessment forms the basis on which to:
• Accept or reject the change (where that is a choice);
• Negotiate the cost of the change with the customer/suppliers;
• Organise the redevelopment work.
The key concept that enables this kind of impact analysis is requirements tra-
cing, a topic treated in greater detail in Sect. 1.6, and in Chaps. 2 and 7. Sufﬁce to
say that change management is an integral part of the requirements engineering
process. This role is illustrated in Fig. 1.5.
Quite apart from change management, a manager’s ability to control a project
is considerably enhanced by good requirements engineering. Without require-
ments, project managers have no means of gauging how well the project is going,
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test
Integration 
test
Component 
test
Acceptance 
test
informing the
enterprise
learning from
the enterprise
Fig. 1.4 Enterprise requirements engineering
13
1.5
Requirements and the Lifecycle

or even if it is going in the right direction. When it comes to changes there is noth-
ing against which change can be judged. What is more, when they do come to
intervene, their only approach is at a technical level, which is inappropriate to their
role, and which interferes with the technical role properly played by the engineers.
Requirements well expressed at the appropriate level give managers just the right
view of the project to be able to perform their role.
In summary, requirements are essential to the health of every system develop-
ment. They inﬂuence the whole development from beginning to end and from top
to bottom. Without effective requirements engineering, development projects are
like ships drifting rudderless in a storm! Above all else, with good requirements
management, hearing the voice of the users and customers ceases to be a game of
Chinese whispers, and becomes a matter of clear lines of communication through-
out the development process.
1.6
Requirements Tracing
In the requirements engineering context, tracing is about understanding how high-
level requirements—objectives, goals, aims, aspirations, expectations, needs—are
transformed into low-level requirements. It is therefore primarily concerned with
the relationships between layers of information.
In a business context, one may be interested in how
• Business vision is interpreted as
• Business objectives are implemented as
• Business organisation and processes.
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test
Integration 
test
Component 
test
Acceptance 
test
using traceability 
and impact analysis
to manage change
Fig. 1.5 Role of tracebility in change management
14
1
Introduction

In an engineering context, the interest may focus on how
• Stakeholder requirements are met by
• System requirements are allocated to
• Subsystems are implemented as
• Components.
Tracing can contribute to the following beneﬁts:
Greater conﬁdence in meeting objectives. Establishing and formalising relation-
ships engenders greater reﬂection on how objectives are satisﬁed.
Ability to assess the impact of change. Various forms of impact analysis become
possible in the presence of tracing.
Improved accountability of subordinate organisations. Greater clarity in how sup-
pliers contribute to the whole.
Ability to track progress. It is notoriously difﬁcult to measure progress when all
that you are doing is creating and revising documents. Processes surrounding
tracing allow precise measures of progress in the early stages.
Ability to balance cost against beneﬁt. Relating product components to the
requirements allows beneﬁt to be assessed against cost.
Traceability relationships are usually many-to-many—for instance, in the
satisfaction relationship, one lower-level requirement may be linked to several
higher-level ones, and vice versa. People sometimes talk about the satisfaction
relationship in term of a “requirements hierarchy,” but the many-to-many mature
of the relationship belies this. Although the requirements are in layers, each
requirement may have multiple parents as well as multiple children.
The simplest way to implement tracing is to link requirements statements in
one layer with statements in another. Requirements management tools typically
allow such linking by drag-and-drop between paragraphs of documents. The links
are rather like hyperlinks in web pages, but should ideally be traversable in either
direction. Figure 1.6 shows tracing downwards through the layers of requirements,
and across to the test information.
The direction of the arrows follows a particular convention: information traces
back to the information it responds to. There are a number of reasons for this
convention:
• It usually corresponds to the chronological order in which information is cre-
ated: always link back to the older information;
• It usually corresponds to access rights due to ownership: one owns the out-
going links from a document, someone else owns the incoming links.
Various forms of traceability analysis can be used to support requirements engi-
neering processes, presented in Table 1.4.
When performing coverage analysis, it is important to realise that counting
links tells only a small part of the story. The presence of one or more links gives
no indication that the coverage provides correct or complete satisfaction, which
must remain an engineering judgement. It will be seen later that two aspects
15
1.6
Requirements Tracing

have to be considered when assessing the quality of tracing: sufﬁciency and
necessity.
Impact analysis is used to determine what other artefacts in the development
might be affected if a selected artefact changes. This is illustrated in Fig. 1.7. The
impact is potential; creative analysis has to be carried out by an engineer to deter-
mine the exact nature of the impact, if any.
Derivation analysis works in the opposite direction to impact analysis. A low
level artefact—such as a requirement, design element or test—is selected, and the
tracing is used to determine what higher-level requirements have given rise to it.
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test plan
Integration 
test plan
Component
test plan
Acceptance 
test Plan
Fig. 1.6 Requirements tracing
Table 1.4 Types of traceability analysis
Type of
analysis
Description
Processes
supported
Impact
analysis
Following incoming links, in answer to the question: “What if
this was to change?”
Change
management
Derivation
analysis
Following outgoing links, in answer to the question: “Why is
this here?”
Cost/beneﬁt
analysis
Coverage
analysis
Counting statements that have links, in answer to the
question: “Have I covered everything?”
General
engineering
(May be used as an approximate measure of progress, but not
of sufﬁciency—see below)
Management
reporting
16
1
Introduction

Elements in the design that do not so trace back are potentially adding cost with-
out beneﬁt.
Finally, coverage analysis can be used to determine that all requirements do
trace downwards to lower layers, and across to tests. The absence of such a trace
is a fairly certain indication that the requirement will not be met or tested. The pre-
sence of a link does not, of course, ensure that the requirement will be met—that
again requires creative engineering judgement.
Coverage can also be used as a measure of progress: how far have the systems
engineers got in responding to the stakeholder requirements? Suppose the task of
writing systems requirements in response to stakeholder requirements is given to
an engineer. As she writes system requirements, she links them back to the stake-
holder requirements she is responding to. (By doing it as she goes along, the inser-
tion of tracing is very little extra overhead—it is much more difﬁcult to establish
tracing after both documents have been written!)
At any stage of the task, the engineers’ progress can be measured in terms of
the percentage of stakeholder requirements that have been covered so far. This is a
very useful management tool during the early stages of development.
The same principle can be used to measure progress in planning tests. What
percentage of the requirements have tests deﬁned so far? These two dimensions of
coverage are summarized in Fig. 1.8.
Because of the kinds of analysis that can be carried out, tracing is a simple con-
cept that lies at the heart of the requirements engineering process. More advanced
forms of tracing are discussed in detail in Chap. 7.
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test plan
Integration 
test plan
Component
test plan
Acceptance 
test Plan
Impact analysis
Derivation analysis
Derivation analysis
Impact analysis
Fig. 1.7 Impact and derivation analysis
17
1.6
Requirements Tracing

1.7
Requirements and Modelling
Requirements management is not the only development activity that is taking
place in a project: the system being developed also has to be designed.
It is important to understand the relationship between requirements manage-
ment and system design. They are mutually supportive activities that should not
be equated. Figure 1.9 compares the relationship to a sandwich. In this analogy,
requirements management is the “bread and butter” of the development cycle. The
“ﬁlling” provided by system design explains and exposes the analysis and model-
ling that has led to subsequent layers of requirements.
When formalised, system design becomes system modelling. Model-Based
Systems Engineering (MBSE)—the discipline of using an integrated system model
through the development life cycle—is a hot topic at present. Modelling will be
discussed at greater length in Chap. 3.
Some people talk about requirements modelling. This is a misnomer. You
model systems design, not requirements. In the requirements elicitation stages,
you may model the enclosing systems of the system you are developing, so as to
understand the context and the external interfaces and constraints. This may give
rise to operational scenarios and use cases that inform the requirements.
Later on, modelling supports the design activity, and is where most of the crea-
tive design work takes place. Sufﬁcient modelling should take place at each stage
to assist the engineer in understanding enough of the system to decompose the
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System 
test plan
Integration 
test plan
Component
test plan
Acceptance 
test Plan
Are all 
requirements
covered by the 
layer below?
Are all 
requirements
covered by tests?
Fig. 1.8 Coverage analysis
18
1
Introduction

requirements at the current level into the next level down. The requirements them-
selves are a complete snapshot of what is required at each level in increasing
levels of detail.
Figure 1.10 portrays the inter-related roles that requirements and system model-
ling play. Models assist the requirements engineer in analysing the requirements at
a particular level so as to:
• Communicate with the customer, and improve mutual understanding of the sys-
tem to be developed;
• Analyse the system to ascertain the presence of desired emergent properties
(and the absence of undesirable ones);
• Determine how to satisfy the requirements by deriving new requirements at the
layer below.
Requirements layer
Design layer
Requirements layer
Design layer
Requirements layer
Design layer
Requirements layer
Usage modelling
Functional
modelling
Stakeholder
requirements
Sub-system
requirements
System
requirements
Statement
of need
Performance
modelling
Fig. 1.10 Requirements and modeling
Requirements layer
Design layer
Requirements layer
Design layer
Requirements layer
Design layer
Requirements layer
Fig. 1.9 The systems engineering sandwich
19
1.7
Requirements and Modelling

The nature of the models used will vary from layer to layer. At the top layer,
usage models such as “stakeholder scenarios” are used to derive the ﬁrst state-
ment of stakeholder requirements. Following this, various kinds of functional
model may be used to derive system requirements from the stakeholder require-
ments. For software, such models could include UML class diagrams, message
sequence charts and state charts. (See Chap. 3 for more details on these modelling
techniques.)
Moving from system requirements to architecture, the concerns become
focused on various aspects of performance. Multiple models may be used to give
conﬁdence that the selected architecture can deliver against non-functional as well
as functional requirements. Here, models may include queuing theory used to
assess performance, wind tunnels for assessing aerodynamics, timetable modelling
to assess viability of journey times.
As is evident from these examples, the nature of the models also varies from
application to application. The modelling of timetables may be appropriate for the
design of railway systems, but not for aircraft design, where the modelling of aero-
dynamics is rather more appropriate. (Aerodynamics may also be important to
high-speed trains, of course.) Message sequence charts may be used in communi-
cations systems, but data-rich applications will ﬁnd data-focused modelling such
as entity-relationship diagramming more appropriate.
Whereas the models may vary, the principles of requirements management
remain generic across applications. Since this book is about requirements engi-
neering, it also covers the closely associated subject of modelling and methods.
1.8
Requirements and Testing
As has been discussed above, testing is closely related to requirements at every
level. In its broadest sense, testing is any activity that allows defects in the system
to be detected or prevented, where a defect is a departure from requirements. So
testing activities include reviews, inspections, analysis through modelling as well
as the classical tests of components, subsystem and systems that are carried out.
Because of the diversity of testing activities, the term qualiﬁcation is used in
this book to refer to all such activities.
The classic software testing mantra is “test early, test often.” In the same vein,
qualiﬁcation should begin as early as possible, since waiting until the system is
almost complete before carrying out any kind of testing can lead to very expensive
design changes and rebuilds. The earliest kinds of qualiﬁcation action take place
during the design of the system, and include requirements reviews, design inspec-
tions, and various forms of analysis carried out on system models.
Likewise, qualiﬁcation should occur often, in the sense that the same system
function may be addressed in multiple stages, such as early analysis, design
reviews, system tests and qualiﬁcation tests.
20
1
Introduction

Figure 1.11 portrays the qualiﬁcation strategy along a time-line above the
V-Model. Early qualiﬁcation actions relate to the left-hand side of the V-Model,
later ones to the test stages on the right-hand side.
A single stakeholder requirement will typically give rise to a multitude of quali-
ﬁcation activities at various stages of development. Where a requirement is satis-
ﬁed through useful emergent properties, qualiﬁcation of components alone is
insufﬁcient; tests have to be carried out at the level where emergent properties are
manifest.
1.9
Requirements in the Problem and Solution Domains
Systems engineering is concerned with developing and managing effective solu-
tions to problems. As has been discussed, it is a staged process vital for businesses
in enabling them to produce the right product within acceptable time-scales and
costs.
Early in the process, the deﬁnition of the requirements for the product to be built
is of prime importance. From a management and engineering point of view, a
clear distinction should be made between the “problem domain” and the “solution
domain.” Those stages of development associated with the highest levels of system
description—statement of need, usage modelling and stakeholder requirements—
should be ﬁrmly rooted in the problem domain, whereas subsequent layers, starting
with system requirements, operate in the solution domain.
Stakeholder
Requirements
System
Requirements
Subsystem
Requirements
Component
Requirements
System
test
Integration 
test
Component 
test
Acceptance
test
Reviews / Design inspections / Analysis / Prototypes / Component tests / Rig tests / System tests / Trials
Qualification Strategy / Programme
time
Fig. 1.11 Qualiﬁcation strategy and the V-Model
21
1.9
Requirements in the Problem and Solution Domains

Table 1.5 portrays the ideal boundary between the problem and solution
domains, and the roles that the top requirements layers play.
There is an important principle of abstraction at play here. The initial statement
of capability should state no more than is necessary to deﬁne the problem, and
avoid any reference to particular solutions. This allows freedom to the system
engineers to carry out their role, which is to devise the best solution without pre-
conceived ideas.
Modelling assists in the derivation of the next layer of requirements, and tends
to consider possible solutions, even at a high level. To avoid inappropriate solu-
tion bias, rather than focus on the system in question, early modelling should
focus on the immediately enclosing system. For instance, if a radio system is
being developed for a sailing boat, then early modelling should focus on the vessel
and not so much on the radio. This leads to a statement of the problem to be
solved in the context of the enclosing solution.
The same principle applies to the systems engineers: they should allow the
designers the freedom to perform their role, that of designing against an abstract
solution. The elements of solution introduced through functional modelling remain
at a high-level, leaving the detail to be deﬁned in subsequent stages.
For example, in a trafﬁc control system:
The stakeholders may express the problem in terms of maximising trafﬁc ﬂow
while minimising the risk of accidents at a trafﬁc junction and minimising cost
of maintenance;
The systems engineers may consider a variety of solutions, such as bridges,
trafﬁc-lights or roundabouts, and a bridge as the approach that best solves the
problem within constraints of development and maintenance costs;
The designers then set to work designing the bridge within the physical constraints
presented by the physical environment.
It is frequently the case that the stakeholders will express the problem in terms
of a preconceived solution. It then becomes the requirements engineers’ job to
determine whether there is a good reason for mandating a particular solution, or
whether it is an unnecessary constraint. For example, the customer starts by trying
Table 1.5 Problem and solution spaces
Requirements
layer
Domain
View
Role
Stakeholder
requirements
Problem
domain
Stakeholder’s
view
State what the stakeholders want to achieve
through use of the system. Avoid reference to
any particular solution
System
requirements
Solution
domain
Analyst’s
view
State abstractly what the system will do to meet
the stakeholder requirements. Avoid reference to
any particular design
Architectural
design
Solution
domain
Designer’s
view
State how the speciﬁc design will meet the
system requirements
22
1
Introduction

to procure trafﬁc lights; the supplier asks questions that lead to an understanding
of the underlying objectives—maximise trafﬁc ﬂow and minimise risk for drivers
and pedestrians—leading to a solution-independent expression of the problem; the
reasons for the choice of solution are now better understood, and perhaps con-
ﬁrmed through appropriate modelling, leading to a precise and well-informed spe-
ciﬁcation of the abstract solution.
When it comes to procuring systems, a judgement needs to be made as to
whether to procure against the problem domain (stakeholder requirements) or
against the abstract solution domain (system requirements). Often the nature of the
solution is known in advance, and it makes sense to procure against system
requirements framed in terms of that solution. However, even if procuring against
a particular solution, the discipline of capturing a statement of the pure problem
prior to a solution still offers important advantages.
Without a clear distinction between problem and solution, the following may
result:
• Lack of understanding of the real problem;
• Inability to scope the system, and understand which functions to include;
• Domination of debate about the system by the developers and suppliers,
because the only descriptions of the system are expressed in terms of solutions;
• Inability to ﬁnd optimal solutions due to lack of design freedom.
For these reasons, the book makes the distinction between stakeholder and sys-
tem requirements, in terms of how requirements are captured, modelled and
expressed.
1.10
Requirements and Design Agnosticism
The principle of avoiding solution detail that is inappropriate to the stage of devel-
opment is sometimes known as being design agnostic: purposely choosing not to
delve into the details of the solution too early. This principle applies at every level
of abstraction, not just between the problem and solution domains.
A guide to this principle is to think in terms of “black boxes.” When you are
considering the system as a whole, think of it as a black box. You are allowed to
talk about:
• External interfaces, including inputs and outputs;
• Externally observable behaviour of the system expressed in terms of inputs and
outputs.
Ask an engineer how a television works, and you will no doubt get an answer
expressed in terms of what goes inside the box: signal processing, liquid crystal
displays, power units, etc.
23
1.10
Requirements and Design Agnosticism

Ask a ﬁve-year-old how a television works, and you will be told where the
power switch is, how to select channels, and how to adjust the volume—all the
externally visible behaviour.
This idea of the black box that hides internal workings applies to all levels of
abstraction. Figure 1.12 portrays a whole system as a black box. At the system
level, the Waste Processing Plant should be described only in terms of its exter-
nally observable behaviour. A typical requirement may be expressed as
The Waste Processing Plant shall receive unpackaged waste in road transporters
of type ABC at a rate of 12 tonnes once per week.
The Waste Processing Plant shall extract treatable waste from the unprocessed
waste.
The Waste Processing Plant shall package treatable waste in packages of type
RST.
The Waste Processing Plant shall dispatch packaged treatable waste on road
transporters of type DEF.
The Waste Processing Plant shall dispatch untreatable waste on road transporters
of type GHI.
By not opening the black box and not using vocabulary relating to the inside of
the system, the requirements remain design agnostic. The requirements are applic-
able to many possible solutions.
As the design processes, the system will, of course, be decomposed into parts.
The system black box is opened to reveal a number of smaller black boxes represent-
ing internal subsystems. Figure 1.13 shows this new layer of design. The system is
now a transparent box, revealing a high-level architecture consisting of subsystems.
Nothing is lost in this decomposition: all the external interfaces are still present,
and taken into account by subsystems. Crucial to the additional design detail are
the internal interfaces between the subsystems.
WASTE PROCESSING
PLANT
waste
via road
transporters
services
packaging
consumables
packaged
waste
via road
transporters
untreatable
waste
via road
transporters
plant
control
Fig. 1.12 System as a black box
24
1
Introduction

Each black box is an opportunity to write a set of requirements. Whereas the
subject of the system requirements are the Waste Processing Plant, the subject
now becomes the name of each sub-system.
Detail can now be added to how the system requirements are satisﬁed in terms
of subsystems. For instance, the system requirement is partly satisﬁed by the
following subsystem requirements:
The Waste Processing Plant shall extract treatable waste from the unprocessed waste.
The Waste Receipt Unit shall interface with road transporters of type ABC to
receive unprocessed waste at a rate of up to 12 tonnes once per week.
The Waste Receipt Unit shall be capable of storing unprocessed waste up to a
quantity of 12 tonnes.
The Waste Receipt Unit shall interface with the Waste Sorting Unit to transfer
unprocessed waste to the Waste Sorting Unit at a rate of up to 2 tonnes per day.
The Waste Sorting Unit shall provide a means of separating treatable waste from
untreatable waste at a rate of up to 2 tonnes per day.
The Waste Sorting Unit shall interface with the Waste Packaging Unit to transfer
treatable waste to the Waste Packaging Unit at a rate of up to 2 tonnes per day.
The Waste Packaging Unit shall place treatable waste into packages of type RST
at a rate of 2 tonnes per day.
The Waste Packaging Unit shall interface with the Package Dispatch Unit to
transfer packages of treatable waste to the Package Dispatch Unit at a rate of
30 packages per day.
WASTE PROCESSING PLANT
waste 
via road 
transporters
services
packaging
consumables
packaged
waste
via road
transporters
untreatable
waste
via road
transporters
WASTE
RECEIPT 
UNIT
WASTE
STORAGE
UNIT
WASTE
PACKAGING
UNIT
PACKAGE
DISPATCH
UNIT
WASTE
SORTING
UNIT
PLANT CONTROL SYSTEM
plant
control
SERVICES DISTRIBUTION 
SYSTEM
Fig. 1.13 Subsystems as black boxes
25
1.10
Requirements and Design Agnosticism

The Package Dispatch Unit shall interface with road transporters of type DEF
to transfer packaged treatable waste to the road transporters at a rate of up to
30 packages per day.
This decomposition shows how the subsystems work together to satisfy the
system requirements. There is a decomposition of function as well as of
performance.
Once subsystems are identiﬁed, they in turn can be decomposed into sub-
subsystems, or components. Figure 1.14 shows the decomposition of the Waste
Packaging Unit into components. Further internal interfaces appear at this level.
The systematic decomposition of a system into subsystems and components
through the design process determines the Product Breakdown Structure (PBS).
In turn the PBS determines structure of the requirements database and the way
requirements ﬂow through it.
Figure 1.15 summarises the PBS down the right-hand side, and the corres-
ponding requirements breakdown structure down the left-hand side. Systems, sub-
systems and components are shown as rectangles, and interfaces are shown as
hexagons. The satisfaction relationship (and hence the allowable requirements
ﬂow-down) is governed by the PBS. In most systems, the PBS is strictly hierarchi-
cal. That is, a component is normally only expected to satisfy the requirements of
a single enclosing system. There may be exceptions to this, especially in software.
The principle of being design agnostic has been discussed when it comes to
writing requirements. An equivalent principle applies to writing qualiﬁcation
actions.
packaging
consumables
WASTE PACKAGING UNIT
packaged
waste
sorted 
waste
PLANT 
CONTROL 
SYSTEM
SERVICES 
DISTRIBUTION 
SYSTEM
PACKAGE
STAND
WASTE SHOOT
SEALING
MACHINE
PACKAGE
STORAGE
AREA
Fig. 1.14 Components as black boxes
26
1
Introduction

Figure 1.11 showed how the qualiﬁcation strategy sits right across the life
cycle, and how it relates to the V-model. The main reason for the V-model being
drawn as a “V” is to portray levels of abstraction. The rule for remaining design
agnostic when planning the qualiﬁcation strategy against a particular level of
requirements is as follows: only consider actions that relate to the following two
stages of the life cycle:
• The current life cycle stage on the left-hand side of the V-model.
• The corresponding life cycle stage on the right-hand side of the V-model.
Figure 1.16 shows four levels of requirements and corresponding stages of qua-
liﬁcation strategy. When planning qualiﬁcation actions against Stakeholder
Requirements, appropriate actions are early analysis and design reviews, and late
commissioning and operational tests. At this stage, there is insufﬁcient detail to
consider factory tests or system tests, because systems have not been identiﬁed,
Fig. 1.15 Product breakdown structure
27
1.10
Requirements and Design Agnosticism

Fig. 1.16 Abstraction in the qualiﬁcation strategy
28
1
Introduction

and their requirements not yet deﬁned. So Stakeholder Requirements do not give
rise to qualiﬁcation actions in the “middle” parts of the qualiﬁcation plan.
As the design moves down the left-hand side of the V-model, however, more
detail is added, and further qualiﬁcation actions can be added, eventually complet-
ing actions at all stages of the life cycle.
This leads to the strange phenomenon that the qualiﬁcation plan ﬁlls up from
the outside inwards during development, because of the way the abstraction layers
in the V-model interact with the life cycle.
1.11
Requirements and Interfaces
When viewing the whole system as a black box, the only interfaces of interest are
external. However, as soon as the system is decomposed into subsystems, internal
interfaces are revealed as part of the design. The interfaces are as important to the
design as the components, and should have equal citizenship, as it were, in the set
of design artefacts—hence their appearance in Fig. 1.15.
Because interfaces, by deﬁnition, connect more than one component, their
requirements are in a sense shared across components. Ownership therefore has to
be agreed. Who deﬁnes the interface? Is it one of the connected components, or
some independent entity? A component that doesn’t own one if its interfaces may
have to accept that interface’s requirements as constraints.
Requirements should be collected for interfaces as well as components. Such
requirement sets are often called Interface Requirements Documents (IRD). IRDs
are not to be confused with Interface Control Documents (ICD), which are more
concerned with the design of the interface than with its requirements.
As design progresses, the system is decomposed into subsystems, and subsystems
into components. One of two things may happen to an interface during this process:
• An interface that was attached to a system (or subsystem) may get allocated to
a subsystem (or component).
• An interface may be decomposed, because it is implemented as a subsystem or
component.
Figure 1.17 shows an example of an interface (“ﬂow of waste to pkg stand”)
that is implemented using a component (“Conveyor belt”), inducing two new
interfaces (“ﬂow of waste from shoot” and “ﬂow of waste to pkg stand”).
Maintaining the traceability if this design intent is important. Asking the ques-
tion, “what is the purpose of the conveyor belt?” leads to the realisation that it
serves as an interface between the Waste Shoot and the Package Stand. If that
interface did not exist, then the need for the Conveyor Belt would also be absent.
A useful tool for a project is the Interface Register. This is a catalogue of every
interface, internal and external, recording which components are connected
through them, who owns each interface, and where its requirements can be found.
29
1.11
Requirements and Interfaces

A well-structured Interface Register can serve as a cross-check on complete-
ness. These are two things that can be checked:
• Do the components at both ends of the interface actually reference the
interface?
• Can complete paths through the system be identiﬁed for each type of ﬂow?
As an example of the second point, in the Waste Processing Plant of Fig. 1.13,
the interface register can be used to follow the complete journey of the waste,
from transport lorries, through the Waste Receipt Unit, into the Waste Sorting
Unit, and onwards. This serves as a check that the complete set of interfaces is
present.
1.12
How to Read this Book
This book is concerned with engineering requirements and how this process may
help those system engineers and software engineers to create better requirements.
Chap. 1 has discussed the importance of requirements and has investigated the
role of requirements engineering in all parts of the development lifecycle.
Because of multiple dependencies between chapters, the ordering of material
has been carefully chosen to reduce the number of forward references. While it is
best to read the chapters in the sequence presented, some guidelines are given here
to assist readers with particular objectives to make efﬁcient use of the book.
Waste
Packaging
Unit Reqs
Waste
Shoot Reqs
flow of
waste to
pkg stand
Package
Stand Reqs
flow of
waste to
pkg stand
Conveyor
belt reqs
flow of
waste from
shoot
...
...
Fig. 1.17 Interface decomposition
30
1
Introduction

Chapter 2, “A Generic Process for Requirements Engineering,” presents
requirements engineering in a generic form that is applicable to all layers of
development. While this approach assists the reader in gaining a good understand-
ing of the essence of requirements engineering, it remains, of necessity, quite
abstract. The generic process is, however, made more concrete in Chaps. 5 and 6,
where it is adapted to the stakeholder and system layers of development using
numerous examples.
Chapter 3, “System Modelling for Requirements Engineering,” talks about sys-
tem modelling, covering various techniques and methods in wide use. This is
again in preparation for Chaps. 5 and 6, where particular modelling techniques are
placed in the context of stakeholder and system requirements.
Chapter 4, “Writing and Reviewing Requirements,” addresses the structuring
of requirements documents, and the expression of requirements statements. Here
the language of different kinds of requirement is discussed.
Chapter 5, “Requirements Engineering in the Problem Domain,” instantiates
the generic process to address the problem domain, in which stakeholder require-
ments are the primary focus.
Chapter 6, “Requirements Engineering in the Solution Domain,” then does the
same for requirements in the solution domain, from system requirements down-
wards through subsystems and components.
Chapter 1 - Introduction
Chapter 2 – A Generic Process for Requirements Engineering
Chapter 3 – System modelling and methods for Requirements Engineering
Chapter 5 – Requirements Engineering in the Problem Domain
Chapter 6 – Requirements Engineering in the Solution Domain
Chapter 4 – Writing and Reviewing Requirements
Chapter 7 – Advanced Traceability
Chapter 8 – DOORS: a Tool to Manage Requirements
Chapter 9 – Management Aspects of Requirements Engineering
Fig. 1.18 Chapter dependencies
31
1.12
How to Read this Book

Chapter 7, “Advanced Traceability,” presents further approaches to traceability,
aimed at improving the way in which rationale for traceability is captured, and
discusses metrics that can be derived from traceability.
Chapter 8, “DOORS: A Tool to Manage Requirements” provides an overview
of IBM DOORS Next Generation as an example of a software tool which serves
as an enabler of a requirements management process. A case study is used to illus-
trate the processes presented in the book, and features of the tool.
Finally, Chapter 9, “Management Aspects of Requirements Engineering,”
addresses project management in a requirements management context, covering a
variety of organisation types.
Figure 1.18 depicts the chapter dependencies.
32
1
Introduction

Chapter 2
A Generic Process for Requirements
Engineering
If you can’t describe what you are doing as a process,
you don’t know what you’re doing.
William Edwards Deming,
management consultant, 1900–1993 AD
2.1
Introduction
This chapter introduces the concept of a process for the development of systems.
It starts by examining the way in which systems are developed. This leads to the
identiﬁcation of a development pattern that can be used in many different contexts.
This development pattern is expressed as a generic process and is explained in
some detail. Subsequent chapters indicate how the generic process can be instan-
tiated for speciﬁc purposes. The relationship between process models and informa-
tion models is also explored and an information model for the generic process is
developed.
2.2
Developing Systems
Before any system can be developed it is essential to establish the need for the
system. If the purpose of a system is not known, it is unclear what sort of system
will be developed, and it is impossible to determine whether the system, when
developed, will satisfy the needs of its users. Forest Gump summed it up quite
nicely when he said:
If you don’t know where you are going, you are unlikely to end up there.
33
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_2

The rigour with which the need is expressed will depend upon the nature of the
individual responsible for stating the need and his/her role within the organisation
in which they work. The need may be expressed in fairly vague terms initially,
e.g. “I would like a system that improves the efﬁciency of my department.”
Clearly, such a “speciﬁcation” is not appropriate to be used as the basis for going
out to buy a system. However, it could be the basis for a study to determine
exactly what the person really wants. Such a study would have to determine where
the department is currently inefﬁcient and to postulate how the capabilities to be
provided by the proposed system would be used to improve the efﬁciency. These
activities, which transform a vague statement of need into a set of requirements
that can be used as the basis for purchasing a system, constitute the process of
developing the Stakeholder Requirements. Stakeholders include people, who will
directly interact with the system, but also other people and organisations that have
other interests in its existence. The topic of creating Stakeholder requirements is
dealt with in detail in Chap. 5.
Figure 2.1 illustrates the development process expressed as a Data Flow
Diagram (See Chap. 3) in which circles (or ovals) represent processes and rectan-
gles represent data or information that is read or produced. The arrows indicate
whether data is read or written. Thus, Fig. 2.1 states that the Develop Stakeholder
Requirements process takes the Statement of Needs and produces the Stakeholder
Requirements. It also creates and reads a Usage Model.
Once a sound set of Stakeholder Requirements exist that deﬁne what the stake-
holders want to be able to do with the proposed system, it is possible to begin to
think about potential solutions. Rather than jumping straight to a design, it is good
practice to ﬁrst determine what characteristics the system must have irrespective
of the ﬁnal detailed design. This process is known as establishing the System
Requirements. It is recommended that an abstract model of the proposed system
be produced. This model provides a basis for discussion within the development
team and hence provides a means of establishing a common understanding of the
proposed solution, albeit at an abstract level. The model can also be used to
explain the solution concepts to those Stakeholders who wish to be assured that
the developers are moving along the right lines. Finally, the model provides a
structure for presenting the system requirements in a document form. Each ele-
ment in the model can form a section in the document. This places each require-
ment in a relevant context and is an indispensable aid to reviewing the complete
requirements set from a consistency and completeness point of view.
From the system requirements it is possible to consider alternative design archi-
tectures. A design architecture is expressed as a set of interacting components that
collectively exhibit the desired properties. These properties are known as the emer-
gent properties of the system and should exactly match the desired characteristics
of the system as expressed in the system requirements. The design architecture
deﬁnes what each system component must do and how the system components
interact with each other to produce the overall effects speciﬁed in the system
requirements. In other words, the design architecture deﬁnes the requirements for
each system component (see Fig. 2.1) in terms of their functionality and
34
2
A Generic Process for Requirements Engineering

interaction obligations. The design architecture and hence the system component
requirements must also stipulate any other required properties such as physical
size, performance, reliability, maintainability, etc.
For all but the smallest of systems, the components in the design architecture
will be too complex to be implemented directly. Components at this level are
frequently known as “subsystems” because they are complex enough to be
Statement of
Needs
Stakeholder
Requirements
Develop
System
Requirements
Develop
Stakeholder
Requirements
Develop
System Design
Develop
Subsystem /
Component
Requirements
Subsystem /
Component
Requirements
Subsystem Design
Architecture
System Design
Architecture
Abstract Model
Repeate for each Subsystem / Component
System
Requirements
Solution Domain
Usage Model
Problem Domain
Fig. 2.1 System development process
35
2.2
Developing Systems

considered as systems in their own right, but yet they are still only part of the
higher-level system for which they are designed.
The process of establishing the design architecture for each subsystem and then
using this to derive component requirements is similar to that described for the
overall system. Eventually a subsystem design architecture and subsystem compo-
nent requirements will be produced for each subsystem as indicated in Fig. 2.1.
This description of the development process has indicated that development of
systems takes place at several levels and that different activities take place at each
level. Figure 2.1 also indicates that each activity is supported by a model (e.g. Use
model, Abstract Model, Design Architecture), although the nature of the models
differs quite signiﬁcantly. This is an example of a common aspect: each level of
development uses a model. In the following sections of this chapter, these similari-
ties are further explored in order to deﬁne the properties of a generic process.
It is essential to realise that there are requirements at each of the levels:
• Needs statement
• Stakeholder Requirements
• System Requirements
• System component requirements
• Subsystem component requirements
Consequently, requirements engineering is not something that is done once and
then forgotten. It happens at each level, and often work is undertaken concurrently
at different levels. At all levels from the system components downward, there is
multiple concurrent work on requirements at each level. (The grey background of
the relevant symbols in Fig. 2.1 indicates this.)
2.3
Generic Process Context
An alternative way of considering the development process is shown in Fig. 2.2.
This
diagram
suggests
that
the
same
development
process,
“Engineer
Requirements,” is used at each level, although the explanation given above indi-
cates that the work involved is different at each level.
This apparently strange way of describing the process is used to introduce the
fact that there is, in fact, a signiﬁcant degree of commonality in the work done at
each level. The purpose of this chapter is to explore these common aspects and to
present a generic process that not only addresses the common aspects but also
enables the different aspects to be accommodated.
It is important to stress that in a multi-level development, each level of devel-
opment demands relevant expertise. At the higher levels, domain knowledge in
the problem domain is vital. At the system level, it is important that a system-
wide view is taken to avoid too narrow an interpretation of the Stakeholder
Requirements. At this level there will inevitably be a solution bias introduced.
People or organisations with a proven track record in the development of similar
36
2
A Generic Process for Requirements Engineering

systems are necessary. Similarly, the subsystem developers will bring their own
domain experience for the particular specialist area of their subsystem.
Thus, it is unlikely that the same people will undertake development at every
level. Even when the same organisation is working on several levels, it is likely
that different people will be involved, often from different departments. Therefore,
Statement of
Needs
Stakeholder
Requirements
Subsystem /
Component
Requirements
Subsystem Design
Architecture
System Design
Architecture
Engineer
Requirements
Engineer
Requirements
Engineer
Requirements
Abstract Model
Repeate for each Subsystem / Component
System
Requirements
Solution Domain
Usage Model
Engineer
Requirements
Problem Domain
Fig. 2.2 Different levels of requirements engineering
37
2.3
Generic Process Context

it is useful to introduce the idea that each level of development is done in response
to a “customer” at the level above, and will involve “suppliers” at the level below.
2.3.1
Input Requirements and Derived Requirements
Figure 2.3 shows an alternative view of Fig. 2.3 in which the individual processes
have been separated. This emphasises that the requirements derived by one pro-
cess become the Input Requirements of another process and leads naturally to the
idea that the generic Engineer Requirements process takes in Input Requirements
and generates Derived Requirements (also as shown in Fig. 2.3).
2.3.2
Acceptance Criteria and Qualiﬁcation Strategy
Before moving on to explain the internal details of the Engineer Requirements
process, it is necessary to consider another class of information that is both an
Statement of
Needs
Engineer
Requirements
Stakeholder
Requirements
Stakeholder
Requirements
Engineer
Requirements
System
Requirements
System
Requirerments
Engineer
Requirements
Engineer
Requirements
Generic Process
Derived
Requirements
Subsytem /
Component
Requirements
DERIVED
REQUIREMENTS
INPUT
REQUIREMENTS
Input
Requirements
Fig. 2.3 Identifying Input and Derived Requirements of the generic process
38
2
A Generic Process for Requirements Engineering

input to the process and derived by the process. This is information concerning
the qualiﬁcation strategy for the requirements.
To fully understand the signiﬁcance of requirements and come to a satisfactory
agreement that the requirements form a good basis for development, it is necessary
to consider how the requirements will be demonstrated when the system (or com-
ponent) has been implemented. This is partly achieved by determining, for each
requirement, the criteria that will be used to establish whether or not the system
that claims to implement the requirement is acceptable to the customer.
It is also necessary to determine the circumstances under which the criteria will
be examined. In Chap. 1 the notion of test plans at each level was introduced.
Testing is just one type of qualiﬁcation strategy. Others include trials, certiﬁcation
and inspections. The type of qualiﬁcation strategy to be used will depend on the
nature of the system; for example, systems that have safety critical aspects will
have to be checked much more carefully than, say, a management information sys-
tem. The full context of the Engineer Requirements generic process is therefore as
shown in Fig. 2.4.
The Qualiﬁcation Strategy often introduces new requirements for test equip-
ment, the use of existing facilities (e.g. wind tunnels, anechoic chambers etc.) and
special diagnostic functions or monitor points. In some circumstances a whole
new project may evolve to develop the test equipment and other facilities required.
For example, in avionics development it is necessary (for cost and safety reasons)
to perform as much testing as possible before the equipment is installed in an air-
craft. Even when it is installed, it will also be necessary to run with simulations
prior to ﬂight trials. Clearly the test pilot must be assured that the avionics will
perform to a known standard prior to ﬁrst ﬂight.
At lower levels in the hierarchy where items are to be manufactured, the quali-
ﬁcation strategy may consider issues such as whether the supplier or the customer
Engineer
Requirements
Derived
Requirements
Qualification
Strategy for Input
Requirements
Input
Requirements
Qualification
Strategy for
Derived
Requirements
Fig. 2.4 Qualiﬁcation strat-
egy is essential
39
2.3
Generic Process Context

is responsible for the testing of each item supplied. Possible strategies include full
testing of every item prior to delivery, batch testing by the supplier and possible
random checks by the customer.
2.4
Generic Process Introduction
Having established the context for the generic process it is now possible to look
inside the Engineer Requirements process. The process is introduced ﬁrstly in an
ideal world in which nothing ever changes and then with modiﬁcations to accom-
modate changes.
2.4.1
Ideal Development
The Engineer Requirements process for the ideal world is shown in Fig. 2.5.
The process commences with the need to agree the input information for the pro-
ject with the customer at the level above. The second activity in the process is to
Input
Requirements
Agree
Requirements
ENGINEER
REQUIREMENTS
Analyse and
Model
Analysis
Results
Model
Derive
Requirements
and Qualification
Strategy
Agree
Requirements
Qualification Strategy
for Derived
Requirements
Derived
Requirements
Qualification Strategy
for Input Requirements
Fig. 2.5 Engineer Requirements process for an ideal world
40
2
A Generic Process for Requirements Engineering

analyse the input information and consider how to develop the outputs required.
This activity, which often goes on in parallel with agreeing the requirements,
almost always involves the creation of one or more models and leads to analysis
reports that together provide a basis for the derivation of requirements and qualiﬁ-
cation strategy for the lower level supplier(s). These requirements must, when
they are sufﬁciently mature, be agreed with the suppliers to form the basis for a
contract for the lower level development.
Not shown in Fig. 2.5 is the fact that there may be several sets of derived
requirements generated, one for each subsystem or component, reﬂecting the
Product Breakdown Structure of the system. Each set must be agreed with the
relevant supplier and some suppliers may be responsible for more than one
component.
2.4.2
Development in the Context of Change
Unfortunately the world hardly ever stands still. This is especially true in the arena
of system development. It seems that everybody is constantly changing his or her
mind or ﬁnding that what was previously agreed is no longer possible. Therefore
the generic process has to be modiﬁed, as indicated in Fig. 2.6 to reﬂect this
necessary evil.
The formality with which change is managed will depend upon the nature and
state of the project. During the early stages, changes can and must be made with
ease so that progress can be made. However, there comes a time at which a com-
mitment must be made and formal agreement struck. From this time, it is usual to
have a more formal arrangement in which changes are not just inserted at the
whim of anyone on the project. Instead a process is used in which changes are ﬁrst
requested or proposed and then they are decided upon in the context of their
impact on the project. The decision process will usually involve a person such as
the project manager, who has the authority to make the decision supported as
necessary by a group of people who constitute a change control board. Again the
degree of formality with which these people operate will depend on the nature
of the project. The topic of change management is addressed in more depth in
Chap. 9 in the context of project management.
In Fig. 2.6 it can be seen that almost any activity can lead to the creation
of a change and that these changes usually ﬂow upwards. This does not mean
that customers never change their minds or that the only problems discovered
are lower level detail problems that ﬂow from a top-down strategy. The situa-
tion is that the downward path is already accounted for in the normal ﬂows,
but the return path has to be explicitly catered for. One typical situation in
which a change request might arise is, for example, that a limitation in a
model or an anomaly in analysis results may well be discovered whilst
attempting to generate a derived requirement or the qualiﬁcation strategy for a
41
2.4
Generic Process Introduction

derived requirement. A change request will recommend a modiﬁcation to the
model(s) and/or additional analysis work to investigate the problem. Similarly
a problem with in input requirement may be identiﬁed during the analysis and
modelling process leading to the creation of a change request for the Agree
Requirements process.
Change Request
Agree
Requirements
Change Request
ENGINEER
REQUIREMENTS
Analyse and
Model
Model
Change
Request
Change Request
Change Request
Agree
Requirements
Derived
Requirements
Qualification Strategy
for Derived
Requirements
Qualification Strategy
for Input Requirements
Derive
Requirements
and Qualification
Strategy
Input
Requirements
Analysis
Results
Fig. 2.6 Engineer Requirements process in context of changes
42
2
A Generic Process for Requirements Engineering

2.5
Generic Process Information Model
Before considering the sub-processes within the generic Engineer Requirements pro-
cess, it is useful to introduce a generic information model that supports the process.
The diagrams used to represent the generic process contain both process sym-
bols and data or information symbols. The diagrams indicate, via the arrows,
which information is being generated and used by each process.
The purpose of an information model is to indicate what types of information
exist and whether relationships can or should exist between the items of informa-
tion. It is also useful to introduce state transition diagrams to indicate how the state
of each type of information can be changed as time proceeds. Consequently these
state transition diagrams can give a visual indication of when and how processes
interact with each other via the information.
2.5.1
Information Classes
Below are the information types involved in the generic process. Those in italic
font are abstract types; i.e. there are two types of Information: Requirement and
Qualiﬁcation Strategy, and in turn, two types of Requirement: Input and Derived:
• Information
• Requirement
• Input Requirement
• Derived Requirement
• Qualiﬁcation Strategy
• Qualiﬁcation Strategy for Input Requirements
• Qualiﬁcation Strategy for Derived Requirements
• Change Request
Figure 2.7 shows these types of information expressed as a Uniﬁed Modelling
Language (UML) class diagram (see Chap. 3). The name of the class is always
shown in the uppermost section (or only section) of the class symbol. The middle
section (if present) indicates the names of attributes that the class can have. The
bottom section (if present) contains any operations (often called “methods”) that
can operate on the class.
There are two types of line connecting the class symbols: the thicker lines with
triangles show the type hierarchy, and the thinner lines show relationships between
classes, known as Associations in the UML. Thus an Input Requirement can be
related to a Derived Requirement by a “Satisﬁed by” relationship. Similarly the
Derived Requirement can be related to an Input Requirement by the inverse
“Satisﬁes” relationship. (These labels are known as “roles” in the UML.) The
asterisk indicates that zero or more instances of the class can be involved in the
association. Asterisks at both ends indicate that the association can be many to
43
2.5
Generic Process Information Model

Change Request
+Impacted by
+
+
+
+
+
+
+
+
+
+ –
–
–
+Impacts
+Qualifies
+Qualifies
+Qualified by
+Qualified by
+Imposed by
+Satisfies
+Satisfied by
+Imposed on
Derived
Requirement
Qualification
Strategy for
Derived
Requirements
Qualification
Strategy for
Input
Requirements
Qualification Strategy
Artefact
Requirement
Agreement State
Input
Requirement
Qualification State
Statisfaction State
Fig. 2.7 Information model for the generic process
44
2
A Generic Process for Requirements Engineering

many. Thus in the model of Fig. 2.7 zero or more Input Requirements can be
satisﬁed by a Derived Requirement and an Input Requirement can be satisﬁed by
zero or more Derived Requirements.
Some readers may question the zero lower limit, because it suggests that it is
not necessary to have any association. However, if the lower limit were set to 1,
this would mean that an Input Requirement could not exist unless it was asso-
ciated with at least one Derived Requirement. Clearly this is an impossible situa-
tion. It is essential that Input Requirements can exist prior to Derived
Requirements being generated. Consequently this is a reasonable model, because
there may be times during a project when there will be no links between input
requirements and derived requirements—for example, early in the development
before the links have been established. However, a project manager would expect
that there were links established as soon as possible. This would then indicate that
progress had been made and that all derived requirements were justiﬁed by being
there to satisfy an input requirement, and conversely that all input requirements
had been satisﬁed.
The Qualiﬁcation strategy classes can each qualify the appropriate type of
requirement. As mentioned earlier, it is also possible that a qualiﬁcation strategy
may lead to the creation of special test rigs. This would be an example of the
imposed on relationship between the qualiﬁcation strategy for an input requirement
and one or more derived requirements. Further examples of this relationship occur
when, in order to be able to check a component, it is necessary to provide a moni-
tor point. Such monitor points are often essential to be able to check the perfor-
mance (speed, response, throughput etc.) of a system under operational conditions.
A Change Request can apply to any Information item. This association is inher-
ited by all the other sub-classes of Information.
The middle section of the class symbols is used to deﬁne attributes that the
class will have, and these are inherited through the class type structure. Thus all
Information items have an Agreement State. In addition to this, all Requirements
have the two attributes:
• Qualiﬁcation state
• Satisfaction state
These are deﬁned in the following sections by means of state chart diagrams.
The agreement state is assumed to have the values: Agreed or Not Agreed.
2.5.2
Agreement State
The state chart for the Agreement state is shown in Fig. 2.8. In this type of dia-
gram each (rounded) rectangle represents the state of a single requirement at some
point in its history. The rectangle labelled Being Assessed is known as a “super-
state” because it contains other states within it. The lines connecting one state to
another indicate transitions that cause the state to change.
45
2.5
Generic Process Information Model

The requirement state starts off in the Proposed state. When the customer is con-
tent that the requirement is sufﬁciently well formulated to be sent to the supplier, he
sends it. The agreement state then enters the Being assessed super-state. During this
state, the customer and supplier negotiate until an agreed requirement emerges.
Once in the Agreed state, the requirement will stay there until either the Customer
or the Supplier creates a Change Request. When this happens the requirement’s state
re-enters the Being Assessed state until a new agreed requirement emerges.
Within the Being Assessed state, the customer and supplier take turns to suggest
alternative forms of the requirement until an agreement is reached. The agreement
state will therefore be in one of the two states shown depending on which party is
currently making the assessment.
2.5.3
Qualiﬁcation State
The qualiﬁcation state of a requirement is shown in the state chart of Fig. 2.9. The
initial state is that there is No Qualiﬁcation Strategy decided. When the
Proposed
Being Assessed
Change Proposal
from supplier
Change Proposal
from customer
Customer assessing
requirement from
supplier
Change Request
from supplier
Requirement
acceptable
Agreed
Change Request
from customer
Requirement
proposed to supplier
Supplier assessing
requirement from
customer
Fig. 2.8 Statechart for agreement state
46
2
A Generic Process for Requirements Engineering

qualiﬁcation strategy has been agreed, the state can proceed to the state
Qualiﬁcation Strategy decided. This state can then remain until a change request
is received. The change may be directed either at the requirement itself or at the
qualiﬁcation strategy associated with it. When a change is requested, the state
becomes Qualiﬁcation Strategy suspect until the impact of the change has been
assessed. This assessment determines whether the existing qualiﬁcation strategy
can stand, and the state can return to Qualiﬁcation Strategy decided, or whether an
alternative strategy must be decided, in which case the state becomes No
Qualiﬁcation Strategy decided.
2.5.4
Satisfaction State
The state chart for the Satisfaction state is shown in Fig. 2.10. The logic of this
state is very similar to the qualiﬁcation states. The starting point is the Not satis-
ﬁed state indicating that no Derived Requirements have been related to this
requirement. When the input requirement has been satisﬁed by one or more
Derived Requirements, the lower level supplier agrees the requirement and the
Change
proposed
Change impress
qualification strategy
Change does not impoact
qualification strategy
Verification
criteria agreed
Qualification Strategy
Suspect
Qualification Strategy
Decided
No Qualification
Strategy Decided
Fig. 2.9 Qualiﬁcation state
47
2.5
Generic Process Information Model

higher level (customer) agrees that the Derived Requirements will, indeed, satisfy
the Input Requirement, the state can be moved to the Satisﬁed state. It should be
noted that there might be many Derived Requirements that have to be agreed
before each single Input Requirement can achieve the Satisﬁed state.
When a change is proposed, the Satisfaction state immediately becomes
Satisfaction suspect irrespective of whether the proposed change is directed at the
higher or lower level requirements. This suspect state is retained until the impact
of the proposed change has been assessed and the satisfaction state can then
become Not satisﬁed or Satisﬁed.
2.5.5
Information Model Constraints
Change requests bind together the Agreement, Qualiﬁcation and the Satisfaction
state. Registering a change request immediately changes all three states and
requires additional work, ﬁrstly to determine whether there is any impact, and sec-
ondly to address the consequences, if any, of the impact. Note that the Satisfaction
state can ripple up and down the requirements that are the subject of the
Satisfaction relationship. This ripple effect establishes the potential extent of any
consequential change, i.e. the “impact” of the change.
Not Satisfied
Requirement Satisfied
Satisfied
Change proposed
Satisfaction Suspect
Change impacts
Satisfaction
Change does not
impact 
satisfaction
Fig. 2.10 Satisfaction states
48
2
A Generic Process for Requirements Engineering

The Agreement state of Derived Requirements must be consistent with the
Satisfaction state of Input Requirements, since an Input Requirement cannot
achieve its Satisﬁed state until the lower level supplier has agreed all of the
Derived Requirements that satisfy it.
2.6
Generic Process Details
2.6.1
Agree Requirements
The agreement process is always a concurrent activity between a supplier at one
level and the customer at the level above, and sits on the boundary between two
Engineer Requirements processes. The Derived Requirements from the layer
above are viewed as Input Requirements at the layer below, as indicated in
Fig. 2.11.
Before any derivation work can commence, it is necessary to assess the Input
requirements to ascertain whether they form an adequate basis for the development
to proceed.
The assessment must answer the questions:
• Is the requirement complete?
• Is the requirement clear?
• Is the requirement implementable?
• Is the qualiﬁcation plan clear and acceptable?
Potential answers to these questions lead naturally to the following reasons
why a requirement may be rejected:
Missing information—e.g. placeholders such as “TBA” (To be agreed), “TBC”
(To be completed) or “TBD” (To be decided) may be used.
Lack of clarity—ambiguity, contradiction, confusion etc.
Impossible to implement—no known solution.
Unacceptable qualiﬁcation plan.
Following the review, if a requirement and its qualiﬁcation plan are acceptable
the status can be set to Agreed.
If the requirement is not acceptable then an alternative form is sent to the custo-
mer and the onus passes to the customer, and the Agreement state (see Fig. 2.8)
becomes “Customer assessing requirement from Supplier.” If the customer is con-
tent with the alternative wording, then he can set the state to “Agreed.” If not,
then he proposes a further alternative and sends it to the supplier.
The Agreement state becomes “Supplier assessing requirement from Supplier,”
and the onus returns to the supplier.
This process of proposal and counter proposal continues until an agreement is
reached. Of course it is possible that agreement may never be reached and a dis-
pute emerges.
49
2.6
Generic Process Details

When either party proposes a change the “Being assessed” super-state is
entered with the onus on the party receiving the change. Negotiation follows as
described earlier until a new agreed form can be reached.
During the agreement process, Change Requests may be generated by the cus-
tomer side to request that the derived requirement is modiﬁed. These will pass to
the Derive Requirements and Qualiﬁcation strategy process so that the effect of
the change can be assessed and, where necessary, adjustments made to one or
more of the derived requirements. Of course it can happen that the change cannot
be handled completely at this level and the change may have to be escalated to the
Modelling and Analysis process. This need to escalate the decision process up
ENGINEER REQUIREMENTS
Derive
Requirements
and Qualification
Strategy
Agree Derived
Requirements and
Qualification Strategy
Change
Request
AGREE
REQUIREMENTS
Supplier
Change
Proposal
Customer
Change
Proposal
Agree Input
Requirements and
Qualification Strategy
Qualification Strategy
for Input
Requirements
Qualification Strategy
for Derived
Requirements
Input
Requirements
Derived
Requirements
ENGINEER REQUIREMENTS
Change
Request
Analyse and
Model
Fig. 2.11 The Agree Requirements process
50
2
A Generic Process for Requirements Engineering

through the levels makes it imperative that people are working at each level. In
other words it is necessary to work concurrently on several levels simultaneously.
This need completely destroys the notion of the “waterfall” lifecycle in which a
sequence of activities takes place in a strict top-down order. Instead of a sequence
of activities, development takes place as a concurrent set of negotiations and deci-
sion taking.
In many projects the acceptance criteria and qualiﬁcation plans are only
decided quite late. This can be well after the requirements themselves have been
agreed and, in some cases, agreement is only reached just prior to the commence-
ment of testing. This is very bad practice and usually leads to delays caused by
late changes in requirements to make them testable!
2.6.2
Analyse and Model
The analysis part of this process is primarily concerned with understanding the
nature and scope of the input requirements to assess the likely risks involved in
satisfying them. Analysis work can range from feasibility studies to explore poten-
tial implementation options to the building of prototypes of some vital or high-risk
components. It is often necessary to build performance models to investigate
potential throughput and response ﬁgures.
The other uses of models in this process are to understand the nature of and
provide a structure for the derived requirements. The most common models for
understanding and structuring Stakeholder Requirements are use cases or User
Scenarios. These help to understand how people will use the intended system.
The most common models for structuring solutions in the solution domain are
design architectures. These identify elements of the solution and indicate how they
interact.
In a lot of cases the model is used to establish the design architecture of the
proposed solution. These models are frequently quite obvious for well-established
development domains (e.g. automobiles, telecommunications, aircraft etc.) where
a de facto architecture exists. However, for innovative developments where there
is no established architecture the model may be more abstract to allow for poten-
tial alternatives.
In general, the models used will depend entirely on the nature of the develop-
ment that is being undertaken. As indicated earlier the types of models used are
very much domain speciﬁc. In software systems it is increasingly the case that
object models are used. Table 2.1 indicates different sorts of models used in three
industrial domains.
The point of developing the models is to understand the input requirements
together with the proposed qualiﬁcation strategy and experiment with alternative
solution options prior to deciding how to proceed with the creation of derived
requirements. This work will also consider possible qualiﬁcation strategies for the
derived requirements and this, in turn, may lead to the creation of requirements for
51
2.6
Generic Process Details

test equipment and/or software. It can also lead to the identiﬁcation of qualiﬁca-
tion requirements for the derived requirements.
The Analyse and Model process can be undertaken in parallel with the Agree
process since it is likely to generate deeper insight into the nature of the require-
ments (Fig. 2.12).
In Chap. 3 some widely used modelling techniques are reviewed especially
considering those used in the software industry. Chap. 5 explains how to use User
Scenario models to aid the understanding of Stakeholder requirements, while
Chap. 6 considers function-oriented models that help to provide a framework for
system requirements.
During the analysis and modelling process, it is quite likely that further ques-
tions will arise concerning the meaning and formulation of input requirements.
This gives rise to change requests, which cause the Agree Requirements process
to be re-entered (Fig. 2.13).
2.6.3
Derive Requirements and Qualiﬁcation Strategy
2.6.3.1
Deriving Requirements
The way in which the models are used for this purpose varies, but the simplest
one to consider initially is the derivation of component requirements based on a
design architecture. Here it is possible to determine the speciﬁc requirements that
must be satisﬁed by each component. Some of these requirements may be identical
to one or more input requirements; others may have been derived from input
requirements in order to partition them amongst the components. A further set of
requirements consists of constraints imposed either by the component architecture
or input requirements. These constraints include interface constraints and possible
physical constraints such as mass, volume, power usage and heat dissipation etc.
In practice, some work on the allocation or derivation of requirements for com-
ponents may proceed in advance of ﬁnal agreements on the input requirements
Table 2.1 Examples of
modeling techniques
• Aircraft Industry
• Aerodynamic model
• 3-dimensional spatial model
• Weight distribution model
• Flight simulator
• Rail industry
• Timetable simulation
• Safety, reliability and maintainability models
• Car industry
• Styling model
• Dashboard model
• Aerodynamic model
52
2
A Generic Process for Requirements Engineering

and their qualiﬁcation strategy. However, it is not possible to complete this activity
prior to ﬁnal agreement.
In addition to establishing the component requirements, it is also necessary to
establish the satisfaction relationship between the input requirements and the
derived requirements. This relationship indicates which input requirements are
satisﬁed by which derived requirements and can be used to establish that:
• All input requirements are satisﬁed
• All derived requirements are necessary (i.e. they directly or indirectly satisfy
one or more input requirements)
Agree Input
Requirements
and
Qualification
Strategy
Change
Request
Analysis Results
Qualification
Strategy for Input
Requirements
Analyse and
Model
Model
Input
Requirements
Change
Request
Derive
Requirements
and
Qualification
Strategy
Fig. 2.12 Analyse and model process
53
2.6
Generic Process Details

It is not sufﬁcient just to assert that a satisfaction link exists, as for example in
a cross-reference matrix. The justiﬁcation for each link should also be stated.
These justiﬁcation statements constitute a satisfaction argument.
During the process of generating requirements from the models, it may become
clear that there is a defect or an omission in one or more of the models. This
causes a change request to be issued back to the modelling team who will then
either modify the model directly or ask for further clariﬁcation or change to input
requirements. Thus the change escalation process continues.
2.6.3.2
Deriving the Qualiﬁcation Strategy
As discussed above, the satisfaction relationship is about generating derived
requirements from input requirements—how the system is designed. In contrast,
the qualiﬁcation strategy plans how each requirement will be tested at each level.
Analyse and
Model
Analysis Results
Qualification
Strategy for
Derived
Requirements
Derive
Requirements
and
Qualification
Strategy
Model
Derived
Requirements
Change
Request
Agree
Requirements
Change
Request
Fig. 2.13 Derive Requirements and Qualiﬁcation Strategy process
54
2
A Generic Process for Requirements Engineering

The qualiﬁcation strategy consists of a set of qualiﬁcation actions, each one a
particular kind of trial, test or inspection. There may be several qualiﬁcation
actions deﬁned against each requirement.
Each qualiﬁcation action should take into account the following aspects:
• The kind of action that would be appropriate for the requirement;
• The stage at which each action could take place, the earlier the better;
• Any special equipment that would be needed for the action;
• What would constitute a successful outcome?
The qualiﬁcation plan may be structured either according to the stage or
according to the type of action.
The qualiﬁcation actions deﬁned should be appropriate to the level of require-
ments. In other words, stakeholder requirements give rise to acceptance trials,
whereas system requirements give rise to system tests, i.e. prior to delivery to the
customer. It is not necessary to deﬁne system tests against stakeholder require-
ments, since those system requirements derived from the stakeholder requirement
will have their own system tests.
Take, for instance, the example shown in Fig. 2.14 in which a system require-
ment for a ship is decomposed into two requirements on different sub-systems, the
hull and the propulsion system. Two qualiﬁcation tests are planned against the
system-level requirement, and two more against the sub-system requirements.
Thus, for a full understanding of how a requirement will be tested, both the satis-
faction relationship and the qualiﬁcation strategy are necessary. To understand the
Fig. 2.14 Qualiﬁcation information
55
2.6
Generic Process Details

qualiﬁcation status of a high-level requirement, the results of qualiﬁcation actions
against requirements that ﬂow down from it at all levels have to be taken into
account, by making use of the satisfaction as well as the qualiﬁcation relationship.
2.7
Summary
A generic process that can be simultaneously applied at each level in a system
development has been presented. The beneﬁt of this generic process is that it iden-
tiﬁes common actions that are relevant at every level:
• Agreeing input requirements with customer
• Analysis of input requirements to determine the risks and potential pitfalls in
satisfying the requirements
• Creating one or more models to investigate possible strategies for deriving
requirements
• Generating requirements derived from the input requirements via the analysis
and modelling information
• Generating a qualiﬁcation strategy from the input requirements via the analysis
and modelling information
• Agreeing the derived requirements with the team(s) that will be responsible for
implementing them
• Establishing the satisfaction relationship between Input Requirements and
derived requirements
• Establishing the qualiﬁcation relationship between derived requirements and
the relevant qualiﬁcation strategy
These actions lead to the establishment of information according to the infor-
mation model presented. The current state of the information can be used to mea-
sure progress, to assess the impact of proposed changes and to deﬁne metrics on
how a project is performing. For example, the state of a requirement can be cap-
tured by its three attributes:
• Agreement
• Satisfaction
• Qualiﬁcation
The ideal state for any requirement in any system development is that it should be:
• Agreed between customer and supplier
• Have a qualiﬁcation strategy agreed for it
• Be satisﬁed by lower level requirements (or design)
The extent to which a project’s requirements deviate from this ideal state repre-
sents the degree of risk to which the project is exposed from the requirements
management point of view and also indicates the extent of the work necessary to
get the requirements into the ideal state.
56
2
A Generic Process for Requirements Engineering

Chapter 3
System Modelling for
Requirements Engineering
Art and science have their meeting point in method.
Edward Bulwer-Lytton, poet, 1803–1873 AD
3.1
Introduction
System modelling supports the analysis and design process by introducing a
degree of formality into the way systems are deﬁned. During system development
it is often the case that pictures are used to help visualize some aspects of the
development. Modelling provides a way of formalising these representations,
through diagrams, by not only deﬁning a standard syntax, but also providing a
medium for understanding and communicating the ideas associated with system
development.
The art of modelling is arguably the most creative aspect of the work of the
systems engineer. There is no “right” solution and models will evolve through
various stages of system development. Models are most often represented
visually and the information is therefore represented through connected dia-
grams. New methods such as object-orientation have advanced the concept of
modelling, however most approaches are also based on the principles used and
tested over time.
A model is an abstraction of a system that deliberately focuses on some aspects
of a system to the exclusion of others. Abstraction is, in this sense, avoidance of
distraction—ignoring those details that, although important, are not relevant to a
particular model. The advantage of this is that smaller amounts of related informa-
tion can be collected, processed, organised and analysed, applying various speciﬁc
techniques pertinent to the aspects under study.
Where a large amount of complex information has to be managed, modelling
provides a means of zooming in, collecting together subsets of the data for a
57
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_3

particular purpose, and zooming out once more to appreciate the whole. It aids
in maintaining a system-wide grasp through focussing on small amounts of
information at a time.
There are many kinds of model that focus on different system aspects; for
instance, functional modelling, performance modelling, state modelling, and infor-
mation modelling. Some modelling may be discipline based, such as ﬂuid
dynamics, structural analysis, and thermodynamic modelling.
It is important to note, though, that any particular model never covers every-
thing there is to say about a system—if it did, it would not be a model: it would
be the system itself! For this reason, several different, possibly inter-related, kinds
of model are often used to cover a variety of different aspects. Even then, some
features of the system will remain un-modelled.
A good model is one which is easily communicated. Models need to be used
for communication within a development team, and also to an organisation as a
whole, including the stakeholders. The uses of a model can be diverse and cover a
wide spectrum. It might be to model the activities of an entire organisation or to
model a speciﬁc functional requirement of a system.
Modelling has the following beneﬁts:
• Encourages the use of a precisely deﬁned vocabulary consistent across the
system.
• Allows system speciﬁcation and design to be visualized in diagrams.
• Allows consideration of multiple interacting aspects and views of a system.
• Supports the analysis of systems through a deﬁned discipline.
• Allows validation of some aspects of the system design through animation.
• Allows progressive reﬁnement towards detailed design, permitting test case
generation and code generation.
• Encourages communication between different organizations by using common
standard notations.
Much of the creativity and art of the systems engineer is expressed in the use
of modelling techniques. This chapter considers a number of these representations
and also some methods for Requirements Engineering that use them.
3.2
Representations for Requirements Engineering
3.2.1
Data Flow Diagrams
Data ﬂow diagrams (DFDs) are the basis of most traditional modelling methods.
They are the minimalist graphical representation of the system structure and inter-
faces and although initially produced for use in data representation and ﬂow, the
diagrams can in fact be used to show any type of ﬂow, whether a computer-based
system or not. The one aspect which DFDs do not show is that of control ﬂow.
58
3
System Modelling for Requirements Engineering

The elements in a data ﬂow diagram consist of:
• Data ﬂows (labelled arrows)
• Data transformations (circles or “bubbles”)
• Data stores (horizontal parallel lines)
• External entities (rectangles)
The simple example in Fig. 3.1 shows the use of a data ﬂow diagram in its tra-
ditional, information systems context.
Flows represent the information or material exchanged between two transfor-
mations. In real-world systems, this may be continuous, on demand, asynchronous
etc. When using the notation, diagrams must be supported by textual descriptions
of each process, data store and ﬂow.
A data dictionary is used to deﬁne all the ﬂows and data stores. Each leaf node
bubble deﬁnes the basic functionality provided by the system components. These
are described in terms of a P-spec or mini-spec. This is a textual description often
written in a pseudo-code form.
The context diagram is the top-level diagram of a DFD and shows the external
systems interacting with the proposed system, as in Fig. 3.2.
Bubbles can be decomposed another layer down. Each bubble is exploded into
a diagram which itself may contain bubbles and data stores. This is represented in
Fig. 3.3.
To illustrate the use of a DFD, consider an example of a context diagram for an
Ambulance Command and Control system (Fig. 3.4). This is the starting point for
a data-ﬂow analysis of the system.
The primary external entities are the callers, who make the emergency calls,
and the ambulances, which will be controlled by the system. Note that records are
an important output of the system (in fact a legal requirement) and a very impor-
tant means of measuring “performance.”
Process
transaction
Print receipt
Check details
Transactions
Accounts system
Printer
Credit card holder
Fig. 3.1 Data ﬂow diagram
59
3.2
Representations for Requirements Engineering

Credit card holder
Printer
Accounts system
ATM
system
Fig. 3.2 Context diagram
Context
diagram
Level 1
Level 2
Level 3
0
1
4
2
3
3.3
3.2
3.4
3.5
3.1
3.5.2
3.5.3
3.5.1
Fig. 3.3 Functional decomposition
Caller
Records
Ambulance
Context
Fire brigade
Police
Other
ambulance
C&C
systems
Civil defence
Other potential
external
entities
Fig. 3.4 Context diagram for Ambulance C&C system
60
3
System Modelling for Requirements Engineering

Other potential external entities that would be required for a real system are
shown in the diagram, but for simplicity they shall be ignored.
The next step is to identify the internal functionality of the system. Usually
starting by drawing a function for each external entity as the minimal decomposi-
tion and then drawing the basic data that must ﬂow between these top-level
functions—see Fig. 3.5.
Following this, decomposition of the top-level functions takes place thus
including more detail, as shown in Fig. 3.6.
The functional hierarchy in a set of data ﬂow diagrams can be used as a frame-
work for deriving and structuring system requirements. Figure 3.7 shows the func-
tional structure for the Ambulance Command & Control example derived from
Fig. 3.6.
Figure 3.7 also indicates some examples of requirements derived from this
structure.
The hierarchical breakdown and interfaces give a good view of the component
model, but they give a poor view of the “transactions” across the system i.e. from
input to output (or to complete some system action) as can be seen in Fig. 3.8.
It is therefore necessary to observe these transactions across the system in terms
of the path(s) they follow, the time they take and the resources they absorb.
Animating the stakeholder requirements and being able to see which functions are
operating, will illustrate major transactions, but an alternative way of showing the
system transactions is to mark them on to a data ﬂow diagram as shown in
Fig. 3.9, using the thick arrows.
Caller
Records
Ambulance
Current incidents
Ambulance states
Handle callers
Handle ambulances
Keep records
Fig. 3.5 Model for Ambulance C&C system
61
3.2
Representations for Requirements Engineering

DFDs are good at presenting structures but they are not very precise. DFDs are
less precise than text for developing a complete deﬁnition of a system—interface
lines can mean anything, and single words can summarize anything. They cannot
handle constraints properly.
Caller
Monitor
incidents
Allocate
ambulance
Provide
statistics
Monitor
ambulance
states
Records
Ambulance
Current incidents
Ambulance states
Communicate
with
caller
Analyze
incident
Provide
on-line
advice
Obtain
incident
details
Communicate
with
ambulances
Handle
callers
Handle
ambulances
Keep
records
Fig. 3.6 Detailed model for Ambulance C&C system
Fig. 3.7 Functional structure for Ambulance Command & Control System
62
3
System Modelling for Requirements Engineering

Fig. 3.8 System transactions
Fig. 3.9 System transactions for Ambulance Command & Control System
63
3.2
Representations for Requirements Engineering

A DFD clearly shows functions and interfaces. It can be used to identify
end-to-end transactions, but does not directly show them. Ideally the diagrams
would be viewed using an “expand in place” approach so that it is possible to
view the context in which each level of decomposition is intended to work. Few
CASE tools provide this level of facility.
Figure 3.6 actually breaks the conventions for drawing DFDs, because it shows
a decomposition of the overall system into several processes and it also shows
external agencies with which the system must interact. The authors advocate a
pragmatic use of DFDs, rather than strict adherence to a conceptually pure ideal.
To follow precisely the rules for drawing DFDs, the external agencies should
appear only in the context diagram, and hence should not be visible at this level.
However, the diagram would be far less meaningful if the external agencies were
not shown and the ﬂows to them left dangling (which is the deﬁned convention
for them).
In summary, DFDs:
• Show overall functional structure and ﬂows
• Identify functions, ﬂows and data stores
• Identify interfaces between functions
• Provide a framework for deriving system requirements
• Tools are available
• Widely used in software development
• Applicable to systems in general
3.2.2
Entity-Relationship Diagrams
Modelling the retained information in a system, for example ﬂight plans, system
knowledge and data base records, is often important. Entity relationship diagrams
(ERDs) provide a means of modelling the entities of interest and the relationships
that exist between them. Chen (1976) initially developed ERDs. There is now a
very wide set of alternative ERD notations.
An entity is an object that can be distinctly identiﬁed such as: customer, sup-
plier, part, or product. A property (or attribute) is information that describes the
entity. A relationship has cardinality, which expresses the nature of the associa-
tion (one-to-one, one-to-many, many-to-many) between entities. A subtype is a
subset of another entity, i.e. a type X is a sub-type of Y if every member of X
belongs to Y.
ERDs deﬁne a partial model of the system by identifying the entities within
the system and the relationships between them. It is a model that is independent
of the processing which is required to generate or use the information. It is there-
fore an ideal tool to use for the abstract modelling work required within the
system requirements phase. Consider the example Ambulance C&C system in
Fig. 3.10.
64
3
System Modelling for Requirements Engineering

3.2.3
Statecharts
Functionality and data ﬂows are not enough for requirements deﬁnition. It is also
necessary to be able to represent the behaviour of the system and in some circum-
stances consider the system as having a ﬁnite number of possible “states,” with
external events acting as triggers that lead to transitions between the states.
To represent these aspects it is necessary to examine what states the system can
be in and how it responds to events in these states. One of the most common ways
of doing this is to use Harel’s Statecharts (Harel 1987).
Statecharts are concerned with providing a behavioural description of a system.
They capture hierarchy within a single diagram form and also enable concurrency
to be depicted and therefore they can be effective in practical situations where par-
allelism is prevalent. A labelled box with rounded corners denotes a state.
Hierarchy is represented by encapsulation, and directed arcs, labelled with a
description of the event, are used to denote a transition between states.
The descriptions of state, event and transition make statecharts suitable for
modelling complete systems.
Figure 3.11 presents a statechart for an aircraft ﬂight. The two top-level states
are “Airborne” and “On Ground,” with deﬁned transitions between them. Inside
the “Airborne” state, there are three independent sets of states, while within the
“On Ground” state there are states for “Able to Taxi” and “On Runway.” Inside
the “On Ground” state, there are further states for “taxiing” and “on stand.”
The “Airborne” state is entered when the aircraft wheels leave the ground
and the “On Ground” state is entered when the wheels touch down. Each of these
states can now be further reﬁned in a hierarchical way.
is a
involves
consists of
is staffed by
has resource
is allocated
1..1
0..1
1..N
0..N
0..N
0..N
1..1
0..1
0..N
0..1
0..1
0..1
is allocated
0..1
0..N
Ambulance
Crew
Allocation
Incident
Crew member
Person
Hospital
Fig. 3.10 ERD for Ambulance C&C system
65
3.2
Representations for Requirements Engineering

Statecharts introduce one further useful notion, that of history. When a state
with the (H) annotation is re-entered, then the sub-state that was exited is also
re-entered.
3.2.4
Object-Oriented Approaches
Object-orientation provides a rather different approach from that of the structured
analysis approach. Objects describe stable (and hopefully) re-usable components.
Object-orientation tries to maximize this re-usability by asking the systems
engineer to pick persistent objects i.e. those that can be used in system require-
ments and design.
So the goals of object-orientation are to:
• Encapsulate behaviour (states and events), information (data) and actions
within the same objects.
• Try to deﬁne persistent objects, which can be used within both requirements
and design phases.
• Add information by deﬁning the objects in more detail.
• Create new objects by specialisation of existing objects, not creation of new
objects.
On Stand
Taxing
H
Taxi-in
Taxi-out
•
On Runway
Ready for
take-off
Taking off
Take-off
aborted
Landed
Ascending
Cruising
Descending
Airborne
Aircraft
Cleared for takeoff
Abort
Touchdown
Land
Wheels off
In flight
Cleared
to land
Abort
Abort
Able to taxi
On Ground
Fig. 3.11 Statechart for aircraft ﬂight
66
3
System Modelling for Requirements Engineering

Object-orientation focuses on the behaviour of objects, and their inter-
relationships. A ﬂat organization of objects is sometimes assumed, but this is not
necessary, or even desirable. The analyst looks for entities that are long-lived, and
models the behaviour of the system around them. This approach gives a coherent
behavioural deﬁnition of the system. System elements should be re-usable because
the elements (if not their behaviour) can be incrementally enhanced.
Some methodologists insist that design (and even implementation) is reﬁne-
ment of the analysis models. This can be a tall order for non-trivial systems.
However, the progression from analysis, design to implementation is often far
clearer in object-orientation than in other approaches. More analysis elements end
up being represented in the implementation than is common in structured analysis
and design. This is a tremendous aid to traceability and maintainability.
3.2.4.1
Class Diagrams
The class diagram is the basic diagramming notation from object-oriented analysis
and design. Object-orientation arose out of computer-based simulation. The basic
principle is that the contents of a software system should model the real world.
The natural way to handle this is to have objects in the software that represent
entities in the real world, both in terms of information and actions.
For example, in a banking system, instead of having an accounts ﬁle and sepa-
rate accounts programs, there are accounts objects that have information such as
balance and overdraft limit and relationships to other objects such as account
owner. These objects have operations (also called methods) to handle the actions
that are performed on accounts, like check balance, deposit, withdraw, etc.
The original reasoning behind this approach was that it made software develop-
ment far more akin to modelling, and therefore more natural. As with many good
ideas, practicalities intervene, and few object-oriented software systems can be
seen as pure representations of the real world. Nevertheless, there is still consider-
able merit in the method.
A class (or object) diagram is shown in Fig. 3.12.
Class diagrams express information about classes of objects and their relation-
ships. In many ways, they are similar to entity-relationship diagrams. Like them,
they show how objects of a certain class relate to other objects of the same or dif-
ferent classes. The principal additional pieces of information are:
• Operations (or methods). Ways of manipulating the class.
• The concept of generalization. For instance, in Fig. 3.12, a “Current Account”
is a kind of “Account,” and inherits the attributes and operations from the
Account Class.
• Attributes within the Classes. Information that deﬁnes instances of the class.
3.2.4.2
Use Cases
Use cases deﬁne the interaction that takes place between a user of a system (an
actor) and the system itself. They are represented as process bubbles in a DFD
67
3.2
Representations for Requirements Engineering

type of context diagram. The use case diagram contains the actors and the use
cases and shows the relationship between them. Each use case deﬁnes functional
requirements for the system. Actors do not need to be human, even though they
are represented as stick ﬁgures, but in fact represent roles. Each of the actors will
have an association with at least one use case.
The system boundary is also deﬁned on the use case diagram by a rectangle,
with the name of the system being given within the box. Normally signiﬁcant, and
useful, textual information is associated with each use case diagram.
Figure 3.13 presents a use case diagram for a banking system.
3.3
Methods
A method is a degree more prescriptive than a modelling approach—it tells us
what to do to and in what order to do it. Methods use various representations ran-
ging from natural language, through diagrammatic forms to formal mathematics.
Methods indicate when and where to use such representations. Those methods that
use diagrammatic representations are usually referred to as “structural methods”;
those that use object-orientation are referred to as “object-oriented methods” and
those that use mathematics are referred to as “formal methods.”
The purpose of the representations used in a method is to capture information.
The information capture is aided by deﬁning the set of concepts that a diagram
represents, and the syntactic rules that govern the drawing of diagrams.
Account
Current Account
Issued Cheque
Owner
–
Balance
–
OverdraftLimit
+
payCheck()
–
name
+
checkBalance()
+
1
0..•
amount
+
number
+
deposit()
+
withdraw()
attribute
class
generalisation
association
operation
Fig. 3.12 Class diagram
68
3
System Modelling for Requirements Engineering

As has been seen in the earlier sections of this chapter, there are a variety of
different representations used for system modelling. Most methods—Yourdon
(1990), DeMarco (1978), Shlaer and Mellor (1998), Rumbaugh et al. (1991), to
name but a few, are a reorganization of these concepts, varying the choice and the
order in which they are done, often with minor enhancements. Interestingly, simi-
larities between these methods are far more striking than their differences.
3.3.1
Viewpoint Methods
A viewpoint-based approach to Requirements Engineering recognises that require-
ments should not be considered from a single perspective. It is built on the pre-
mise that requirements should be collected and indeed organised from a number
of different viewpoints. Basically two different kinds of viewpoint have been
proposed:
• Viewpoints associated with stakeholders
• Viewpoints associated with organisational and domain knowledge
The role of the stakeholder is well understood in Requirements Engineering,
however viewpoints associated with organisation and domain knowledge may be
those associated with some aspect of security, marketing, database system, regula-
tion, standard etc. Such viewpoints are not associated with a particular stake-
holder, but will include information from a range of sources.
The following sections consider three different methods based on viewpoints.
Open Account
Check Balance
Deposit
Customer
Set Overdraft
Limit
Setup Account
Manager
Banking System
Withdraw
Fig. 3.13 Use case diagram for banking system
69
3.3
Methods

3.3.1.1
Controlled Requirements Expression (CORE)
CORE was originally developed following work on requirements analysis carried
out for the UK Ministry of Defence. A key ﬁnding of this work was that methods
often started by deﬁning the context of a solution to a problem, rather than
attempting to deﬁne the problem itself, before beginning to assess possible solu-
tions. CORE was speciﬁcally designed to address the latter approach. Figure 3.14
indicates the concepts and representations used in CORE.
The central concept of CORE is the viewpoint and the associated representation
known as the viewpoint hierarchy. A viewpoint can be a person, role or organisa-
tion that has a view about an intended system. (This concept has been used as the
basis of user viewpoint analysis by (Darke & Shanks (1997))). When used for sys-
tem requirements the viewpoints can also represent the intended system, its
subsystems and systems that exist within the environment of the system that may
Viewpoint
Tabular
Collection
Form
(TCF)
Single
Viewpoint
Model
(SVM)
Viewpoint
Hierarchy
Function
Data Store
Can
change
Inter-Viewpoint
Flow
Internal
Flow
Flow
Can
control
Can
trigger
Structures
System
Transaction
Standard CORE
Representations
Standard CORE
Concepts
Can be
produced
by
Can be
used by
Fig. 3.14 Representations and concepts in CORE
70
3
System Modelling for Requirements Engineering

inﬂuence what the system must do. The viewpoints are organised in a hierarchy to
provide a scope and also to guide the analysis process.
Consider as an example, an aircraft brake and control system (ABCS).
Figure 3.15 shows a possible list of initial viewpoints arrived at by means of
brainstorming.
Having produced a list of potential viewpoints, they are organised into a hierar-
chy by grouping related candidates. Boundaries are drawn around related sets and
this is repeated until all candidates have been enclosed and a hierarchy is
produced.
Figure 3.16 shows a partial hierarchy for the aircraft braking control system.
In CORE the actions that each viewpoint must perform are determined. Each
action may use or produce information or other items (e.g. commodities) relevant
to the system in question. The information generated by the analysis is recorded in
a Tabular Collection Form (TCF) as indicated in Table 3.1.
Lines are drawn between adjacent columns to indicate the ﬂows that take place.
Once each viewpoint has been analysed in this way, the TCFs at each level in
the viewpoint hierarchy are checked as a group to ensure that the inputs which
each viewpoint expects are generated by the source viewpoint and that the outputs
which each action generates are expected by the viewpoint(s) indicated as the des-
tination(s) for them.
Returning to the example aircraft braking control system, part of the TCF for
the system is shown in Table 3.2.
Further analysis consists of developing a more detailed data ﬂow model for each
viewpoint in turn. The starting point for these Single Viewpoint Models (SVMs)
Pilots
Aircraft
Braking system x 2
Steering system
Maintenance
engineer
Environment
Cockpit
System
recording
Brake pedals
Sensors
Fig. 3.15 Initial viewpoints for ABCS
71
3.3
Methods

is the information recorded in the TCFs. SVMs add ﬂows that are entirely within a
viewpoint and data stores. The SVMs also deﬁne how actions are controlled and
triggered by ﬂows from other actions.
Thus the analysis is driven top-down by analysing each stratum in the view-
point hierarchy. With top-down analysis, it can be difﬁcult to know when to stop
and to predict where the analysis will lead. The approach of ﬁrst identifying the
viewpoints and then using them to control the subsequent analysis provides a con-
trolled way of doing analysis in a top-down manner. This overcomes a major pro-
blem associated with data ﬂow based analysis. This element of control is alluded
to in Controlled Requirements Expression, the full name of CORE.
The other main concept of CORE is the system transaction. This is a path
through the system from one or more inputs, data ﬂows or events to one or more
speciﬁc output ﬂows or events. The system transactions address how a system is
Table 3.1 Tabular collection form
Source
Input
Action
Output
Destination
The viewpoint
from which the
input comes
The name
of the
input item
The action performed
on one or more inputs
to generate required
outputs
The name(s) of
any outputs
generated by the
action
The viewpoint
to which the
output is sent
System
Aircraft
Maintenance
Cockpit
Sensors
Braking
System
Recording
system
Pilots
Brake
controls
Steering
controls
Fig. 3.16 Hierarchy example
72
3
System Modelling for Requirements Engineering

intended to operate. They provide a view orthogonal to the top-down analysis.
System transactions provide a sound basis for discussing the non-functional
requirements.
3.3.1.2
Structured Analysis and Design Technique (SADT)
SADT is a method of structured analysis, based on the work undertaken by Ross
on Structured Analysis (SA) in the 1970s (Ross 1977). It is graphically oriented
and adopts a purely hierarchical approach to the problem with a succession of
blueprints both modularising and reﬁning it until a solution is achieved. The basic
element of SADT is the box, which represents an activity (in activity diagrams)
or data (in data diagrams). The boxes are joined by arrows representing either the
Table 3.2 TCF example
Source
Input
Action
Output
Destination
Channel 1,2
Power on of 
channel 1,2
Self test ok
Channel 1,2
Self test fail
Cockpit
Power up
Power up
self test
Channel fault
NWS isolator
valve fault
Autobrake 
fault
System
recording
Shutoff valve 
fault
Towing state
Other
sensors/
actuators 
Towing
controlled
Monitor
towing 
Towing
control on 
     Aircraft
Towing
control off 
Channel 1,2 
Operational
of channel 1,2
Wheel speed
Wheel speeds
Monitor
wheel speeds
Speed > 70
knots
Cockpit
73
3.3
Methods

data needed or provided by the activity represented by the box (in activity dia-
grams), or the process providing or using the data (in data diagrams).
There are four basic arrows associated with a box, as shown in Fig. 3.17. The
type of arrow is implied by its point of connection to the box:
• Input arrows enter the box from the left side, and represent data that is available
to the activity represented by the box.
• Output arrows exit the box from the right side, and represent data that is pro-
duced by the activity represented by the box i.e. the input data has been trans-
formed by the activity represented by the box to produce this output.
• Control arrows enter the box from the top, and govern the way in which the
transformation takes place.
• Mechanism arrows enter the box from below and control the way the activity
may use outside mechanisms e.g. a speciﬁc algorithm or resources.
An SADT diagram is made up of a number of boxes with the associated set of
arrows. A problem is reﬁned by decomposing each box and generating a hierarchi-
cal diagram, as shown in Fig. 3.18.
Figure 3.19 shows an example activity diagram for an ABCS. This decomposi-
tion proceeds until there is sufﬁcient detail for the design to proceed.
3.3.1.3
Viewpoint-Oriented Requirements Deﬁnition (VORD)
VORD (Kotonya and Sommerville 1996) is a method based on viewpoints. The
model used is a service-oriented one, where the viewpoints are considered to be
clients, if one was to think of it as a client-server system.
A viewpoint in VORD receives services from the system and in turn passes
control information to the system. The service-oriented approach makes VORD
suited for specifying interactive systems.
Control
Output
Input
Activity
Mechanism
Fig. 3.17 SADT box and
arrows
74
3
System Modelling for Requirements Engineering

System
Computer
system
Cockpit
Warning
System
Steering
System
Braking
System
A-0
A0-4
A0-5
A0-3
A0-2
A0-1
Flight crew info
ABCS info
Commands
Info
ABCS reset
B&S commands
Systems actions
Sensors
Speed
sensors
Valve currents
Valve
energisation
Braking valve
currents
Shut-off valve
energisation
Remote
steering
commands
Fig. 3.19 SADT example
More
general
More
detailed
System Top
Level
2nd
Level
3rd
Level
Fig. 3.18 Decomposition using SADT diagrams
75
3.3
Methods

There are two types of viewpoint in VORD—direct and indirect:
• Direct viewpoints receive services from the system and send control informa-
tion and data to the system.
• Indirect viewpoints do not interact directly with the system but rather have an
“interest” in some or all of the services delivered by the system.
There can be a large variation of indirect viewpoints. Examples include engi-
neering viewpoints concerned with aspects to be undertaken by the systems engi-
neer; external viewpoints which may be concerned with aspects of the system’s
environment; organisation viewpoints which may be concerned with aspects of
safety etc.
There are three main iterative steps in VORD:
1. Viewpoint identiﬁcation and structuring
2. Viewpoint documentation
3. Viewpoint requirements analysis and speciﬁcation
The graphical notation for a viewpoint is shown in Fig. 3.20. A viewpoint is
represented by a rectangle, which contains an identiﬁer, label and type. Viewpoint
attributes are represented by labels attached to a vertical line dropping down from
the left-hand side of the rectangle.
The VORD method guides the systems engineer in identifying viewpoints. It
provides a number of abstract viewpoints which act as a starting point for identiﬁ-
cation. See Fig. 3.21. (Following the convention for VORD diagrams, direct view-
points are unﬁlled rectangles and indirect viewpoints are in greyscale). This class
hierarchy is then pruned to eliminate viewpoint classes which are not relevant to a
particular problem. The system stakeholders, the viewpoints representing other
systems and the system operators are then identiﬁed. Finally, for each indirect
viewpoint that has been identiﬁed consideration is given to who might be asso-
ciated with it.
Based on this approach, Fig. 3.22 gives the viewpoints for a Pay & Display
Car Park System.
n
Type
Label
[m | attribute]
n.1
n.2
Viewpoint identifer
Attribute identifer
Fig. 3.20 Viewpoint notation
76
3
System Modelling for Requirements Engineering

“Cash User” and “Credit Card User” viewpoints are specialisations of the “Car
Park Customer” viewpoint. “Cash Collector” and “Car Park Manager” are specia-
lisations of “Car Park Staff.” The “Ticket Issuing” viewpoint represents the data-
base of the organisation responsible for issuing the pay & display tickets. The
1
2
Operator/customer
Operator/customer
Operator/staff
Operator/staff
Car Park Customer
Car Park Staff
Cash User
Credit Card User
Cash Collector
Car Park Manager
System
Credit Card D/B
System
Ticket Issuing System
Organisation
Parking Company
Operator
Operator
1.1
1.2
2.1
2.2
Fig. 3.22 Pay-and-Display machine viewpoints
Engineering
Maintenance
Regulatory
Organisation
Indirect
Standards
Policy
Training
Environment
Customer
Viewpoint
Direct
System
Operator
Fig. 3.21 Viewpoint classes
77
3.3
Methods

“Credit Card Database” is external and holds details of the customer’s credit card
details.
The next step in VORD is to document each of the viewpoint requirements. An
example of how this is achieved is given in Table 3.3 which shows the initial
viewpoint requirements for the “Car Park Customer” viewpoint. The requirement
type refers to a service (sv) or to a non-functional requirement (nf).
VORD also allows for attributes of viewpoints to be provided which character-
ise the viewpoint in the problem domain. These are important as they provide the
data on which the system operates. As stated previously, these are represented on
the viewpoint diagram by labels attached to a vertical line dropping down from
the left-hand side of the rectangle as shown in Fig. 3.23.
System behaviour is modelled using event scenarios. These describe how the
system interacts with the environment and provide a way of describing the com-
plex interactions between the various viewpoints and the system.
The ﬁnal stage of VORD is to translate the results of the requirements analysis
process into a requirements document, based on an industry standard.
3.3.2
Object-Oriented Methods
During the late 1980s and early 1990s numerous object-oriented methods emerged
proposing different approaches to object-oriented (O-O) analysis and design. The
earliest uses of O-O methods were those companies where time to market and resis-
tance to change were paramount. They included telecommunications, ﬁnancial orga-
nisations and later aerospace, health care, banking, insurance, transportation etc.
The main players were Object-Oriented Analysis (OOA), Object Modelling
Technique (OMT), Booch, and Objectory. Shlaer-Mellor was also there, but
would not have been regarded as a truly O-O method. However it did play an
important role in assisting in the identiﬁcation of objects.
Table 3.3 Requirements from the car park customer viewpoint
Viewpoint
Requirement
Identiﬁer
Label
Description
Type
1
Customer
1.1
Provide facility for ticket based on suitable payment
and length of stay
sv
1.1
Credit Card
User
1.1.1
Provide facility based on valid credit card
sv
1.1.2
Provide ticket issuing service for customer
sv
1.1.3
Ticket issuing service should be available 99/100
requests
nf
1.1.4
Ticket issuing service should have a response time of
no more than 30 secs
nf
1.2
Cash User
78
3
System Modelling for Requirements Engineering

3.3.2.1
OOA
Object-oriented analysis (OOA) was developed by Coad and Yourdon (1991a).
OOA is spread across three layers, as they are called. The ﬁrst layer is the subject
layer, which is concerned with object identiﬁcation. Here the users are able to sim-
ply represent their understanding of the problem domain by identifying relevant
problem domain objects. The second layer, called the attributes layer, is concerned
with identifying attributes (data elements) associated with problem domain
objects. The third and ﬁnal layer is the services layer. This speciﬁes the services
(or operations) performed by each object.
In effect, OOA helps the systems engineer in identifying the requirements of a
system, rather than how the software should be structured or implemented. It
therefore describes the existing system, its operation and how the software system
should interact with it.
3.3.2.2
OMT
The OMT method was developed by Rumbaugh. It aims to construct a series of
object models that reﬁne the system design until the ﬁnal model is suitable for
implementation. The approach is achieved in three phases. The analysis phase pro-
duces models of the problem domain. Three types of model are produced—the
object model, the dynamic model and the functional model. The object model is
1
2
Operator/customer
Operator/customer
Operator/staff
Operator/staff
Car Park Customer
Car Park Staff
Cash User
Credit Card User
Cash Collector
Car Park Manager
System
Credit Card D/B
System
Ticket Issuing System
Organisation
Parking Company
Operator
Operator
1.1
1.2
2.1
2.2
[1 | staff-PIN]
[1 | ticket-information]
[1 | customer-details]
[1 | card]
[1 | cash]
[1 | float]
[2 | pager]
Fig. 3.23 Representation of viewpoint attributes
79
3.3
Methods

the ﬁrst one to be built. It uses notation similar to that used in OOA, which is based
on the concept of ER modelling which describes the objects, their classes and the
relationships between the objects. The dynamic model represents the behaviour of
the system and uses an extension of Harel’s statecharts. The functional model
describes how the system functions are performed through the use of DFDs.
These models are arrived at by using an iterative approach. The design phase
then structures the model and the implementation phase takes into account the
appropriate target language constructs. In this way OMT covers not only the require-
ments capturing phase but also helps to inform the architectural design process.
3.3.2.3
Booch
The Booch method is one of the earliest O-O methods proposed. Although the
method does consider analysis, its strength lies in the contribution it makes to the
design of an object-oriented system. The approach is both incremental and itera-
tive and the designer is encouraged to develop the system by looking at both logi-
cal and physical views of the system.
The method involves analysing the problem domain to identify the set of classes
and objects and their relationships in the system. These are represented using a dia-
grammatical notation. The notation is extended further when considering the imple-
mentation of classes and objects and the services they provide. The use of state
transition diagrams and timing diagrams are also an important part of this method.
3.3.2.4
Objectory
Jacobson proposed the Objectory method. Many of its ideas are similar to other
O-O methods, but the fundamental aspect of this method is the scenario or use
case, as described earlier in this chapter. The system’s functionality should there-
fore be able to be described based on the set of use cases for a system—the use
case model.
This model is then used to generate a domain object model, which can become
an analysis model by classifying the domain objects into three types: interface
objects, entity objects and control objects. This analysis model is then converted
to a design model, which is expressed in terms of blocks, from which the system
is implemented.
3.3.2.5
The UML
The Uniﬁed Modelling Language (UML) (OMG 2003) was an attempt to bring
together three of the O-O approaches which had gained greatest acceptance—
Booch, OMT and Objectory. In the mid-1990s Booch, Rumbaugh and Jacobson
joined Rational to produce a single, common and widely usable modelling
80
3
System Modelling for Requirements Engineering

language. The emphasis was very much on the production of a notation rather
than a method or process.
Since its inception the UML has undergone extensive development and change
with various versions being launched. UML 1.0 became a standard in 1997 fol-
lowing acceptance by the Object Management Group (OMG). Version 1.3 was
released in 1999 and in 2003 the UML 2.0 was released, which is the version used
in this book. A discussion of the UML is provided in the following section.
3.3.3
The UML Notation
The UML is made up of a number of models, which together describe the system
under development. Each model represents distinct phases of development and
each will have a separate purpose. Each model is comprised of one or more of the
following diagrams, which are classiﬁed as follows:
• Structure diagrams
• Behaviour diagrams
• Interaction diagrams
The 13 diagrams of UML2 are shown in Fig. 3.24 and represent all the dia-
grams which are available to the systems engineer. In reality many will not be
Structure Diagrams
Class Diagram
Activity
Diagram
Use Case
Diagram
State Machine
Diagram
Interaction
Diagram
Sequence
Diagram
Communication
Diagram
Timing Diagram
Interaction
Overview
Diagram
Component
Diagram
Composite
Structure
Diagram
Object Diagram
Deployment
 Diagram
Package
 Diagram
Behaviour Diagrams
Interaction Diagrams
Fig. 3.24 UML diagrams
81
3.3
Methods

used and often only a small subset of the diagrams will be necessary to model a
system. Class diagrams, use case diagrams and sequence diagrams are probably
the most frequently used. If dynamic modelling is required then activity diagrams
and state machine diagrams should be used.
It is how the UML diagrams contribute to modelling which is of interest to us.
The purpose of this section is not so much to provide an overview of UML2, but
rather to show how models can be used in various aspects of Requirements
Engineering.
Consider the banking example used earlier in this chapter. The class is the basic
modelling diagram of the UML. Figure 3.25 presents a UML class diagram
extending the set of classes to include “Account,” “Owner,” “Current Account”
and “Issued Cheque”—used to model the system. As shown, each class has an
associated set of attributes and operations, i.e. the relationships (in this case, gen-
eralisation and association) which exist between one or more classes.
Figure 3.26 gives a different example, that of a Baggage Handling System.
This considers the stakeholder requirements which are ﬁrmly within the problem
domain. When modelling, it is often the case that there are external systems, or
perhaps, devices that the system will use. These can be represented by classes. For
the Baggage Handling System, classes are identiﬁed such as “Passenger,” “Clerk,”
“Conveyor,” etc., and also two embedded systems—BaggageCheckInSystem and
WeighingSystem. The associations between the systems and other classes serve
to deﬁne aspects of the system context.
Turning to the solution domain, it becomes necessary to reason about function
and behaviour. The class diagram therefore needs to be elaborated in order to
Account
Current Account
Owner
Issued Cheque
balance: int
class
class name
attributes
operations
generalisation
association
–
overdraftLimit: int
1
0..*
–
amount: int
–
number: int
–
payCheque(): void
+
name
–
checkBalance(): void
+
deposit(): void
+
withdraw(): void
+
Fig. 3.25 Extended UML class diagram
82
3
System Modelling for Requirements Engineering

show these attributes which will be necessary for modelling the system require-
ments. This is shown in Fig. 3.27.
Use case modelling is used to describe the functional requirements of systems.
For an example, consider two use case diagrams—one for the Baggage Handling
System and one for the Baggage Check-in System. Figure 3.28 shows the ﬁrst of
these portrayed as the top-level system. Figure 3.29 is the use case diagram for the
Baggage Check-in System. Both diagrams identify their respective system bound-
aries (marked by a rectangle) and identify the various stakeholders or actors which
CheckedBaggageItem
CheckinClerk
Passenger
talks
WeighingSystem
puts baggage
Conveyor
BaggageCheckinSystem
manages
+belongs to
Baggageltem
1
Person
Printer
prints
controls
positioned on
1
0..1
controls
Fig. 3.26 Class diagram for Baggage Handling System
PassportID: int
talks
-
controls
prints
Printer
printLabel(): void
+
Clerk
Passenger
belongsTo
Conveyor
CheckedBaggageItem
-   BaggageID: int
-   Weight: int
BaggageItem
putsBaggage
1
WeighingSystem
positionedOn
BaggageCheckinSystem
Person
manages
controls
checkTicket(): void
+
weigh(): void
0..1
1
+
0..
Fig. 3.27 Elaborated class diagram
83
3.3
Methods

CheckInBaggage
includes
CheckinClerk
Passenger
BaggageHandlingSystem
ChecklnPassenger
BaggageHandler
LoadBaggage
UnloadBaggage
Fig. 3.28 Use case diagram for Baggage Handling System
checkInBaggage
includes
includes
CheckinClerk
Passenger
labelBaggage
weighBaggage
BaggageCheckinSystem
Fig. 3.29 Use case diagram for Baggage Check-in System
84
3
System Modelling for Requirements Engineering

lie outside the system boundary. It should be noted that the highest level goals of
the stakeholders are represented by the use cases. The «include» relationship
shows that a use case is included in another use case, indicating the start of hier-
archical decomposition.
The UML also provides diagrams to allow the systems engineer to model func-
tionality and behaviour. A sequence diagram shows the interaction and collabora-
tion which exists between objects and thus can model complex behaviour. It is
depicted by messages which ﬂow between objects over time. Figure 3.30 shows a
sample sequence diagram. The objects are represented by rectangles at the top of
the diagram and each is attached to a vertical timeline. Messages are ordered by
their sequence and are represented by arrows between the timelines. Also included
is the feature of an interaction frame and the boxes labelled “seq” has been used
to indicate a reference to an interaction deﬁned in another Sequence diagram, in
this case WeighBaggage and LabelBaggage. These frames have been included to
cover the lifelines involved in the interaction.
baggagePlease()
passTicket()
yourTicketPlease()
Passenger
BaggageCheckinSystem
CheckinClerk
placeBaggage()
transportBaggage()
passBoardingCard()
seq weighBaggage
seq labelBaggage
Fig. 3.30 Example sequence diagram
85
3.3
Methods

3.3.4
SysML
SysML is a variant of the UML adapted to the modelling of systems rather than
software. It takes a subset of the UML diagrams, modiﬁes some of them, and adds
two others: Requirement Diagrams and Parametric Diagrams.
The Object Management Group (OMG), responsible for deﬁning SysML,
describe SysML as having four “pillars”:
1. Diagrams that deﬁne structure: Block Deﬁnition Diagrams and Internal Block
Diagrams.
2. Diagrams that deﬁne behaviour: Sequence Diagrams, State Machine Diagrams,
Activity Diagrams.
3. Diagrams that deﬁne requirements: Requirement diagram.
4. Diagrams that deﬁne parametrics: Parametric Diagrams.
Parametric Diagrams allow a structured approach to deﬁning the mathematical
relationships and constraints on a system, with the aim being to support perfor-
mance analysis and prototyping. Only some of the diagrams will be covered in
this book.
To adapt UML to the systems engineering world, SysML drops the term
“class” in favour of “block,” appealing to the block diagrams frequently used by
engineers to describe the system breakdown structure: a block is a part of a sys-
tem: a subsystem, piece of equipment or component.
The starting point for the systems engineer in SysML is to establish the vocabu-
lary of the domain. A Block Deﬁnition Diagram is used for this, and is akin to a
UML Class diagram. An example is shown in Fig. 3.31.
The next step is to create a Context Diagram that shows the external interfaces
of the system of interest. This is another Block Deﬁnition Diagram, as shown in
Fig. 3.32. In this block diagram, the Baggage Handling System is treated as a
black box, and only external entities are of interest. Note that some of the ﬂow
arrows invoke the vocabulary established earlier.
The next step is to look inside the black box, and establish the ﬁrst layer of
decomposition. For this purpose, SysML retains the UML concept of aggregation
to allow decomposition of blocks. Figure 3.33 shows this. It simply shows that the
Baggage Handling system is made up of four subsystems.
Now all the elements are ready to draw the internal interfaces. The SysML
Internal Block Diagram is used for this. The aggregation shown in Fig. 3.33 above
is portray in the Internal Block Diagram as nested boxes, allowing interfaces
between the subsystems to be added. This is shown in Fig. 3.34. Note that some
of the details from other diagrams are show in this diagram for convenience.
As the design proceeds, the internal blocks in this diagram will each be further
decomposed in their own Internal Block Diagrams, and the system breakdown
structure in Fig. 3.33 will expand downwards.
Another type diagram of interest in the context of this book is the Requirement
Diagram. A “requirement” in SysML is an entity that carries some text
86
3
System Modelling for Requirements Engineering

Passport
BaggageHandler
Person
BaggageItem
CheckedBaggageItem
weight
+
+belongs to
1
Passenger
CheckinClerk
+has
+belongs to 1
+
Name
Number
+
0..1
Fig. 3.31 Block Deﬁnition Diagram to establish domain vocabulary
BaggageItem
Passenger
Passport
CheckinClerk
controls
BaggageHandler
BaggageHandlingSystem
CheckedBaggageItem
Fig. 3.32 Block Deﬁnition Diagram for system context
87
3.3
Methods

(the requirement statement), and which can be associated with any other entity in
the various diagrams. A typical association would be <<implements>>, to indi-
cate that a requirement is, in part, implemented by the presence of a number of
other modelling entities.
Requirement diagrams quite simply show associations between requirements,
and between requirements and other artefacts. Figure 3.35 shows the decomposi-
tion of a single Stakeholder requirement into four system requirements, as por-
trayed by the <<satisfy>> association. In addition, there is a test case associated
with the requirement, using <<verify>>, and an annotation on the requirement
providing rationale for the decomposition.
BaggageHandlingSystem::
Printer
BaggageHandlingSystem:
WeighingSystem
BaggageHandlingSystem::
Conveyor
BaggageHandlingSystem
BaggageHandlingSystem::
BaggageCheckinSystem
Fig. 3.33 Block Deﬁnition Diagram for system breakdown
+belongs to
controls
BaggageHandlingSystem::
BaggageCheckinSystem
controls
CheckinClerk
BaggageHandlingSystem::
Printer
BaggageHandlingSystem::
WeighingSystem
controls
BaggageHandlingSystem
print command
positioned on
BaggageHandlingSystem::
Conveyor
CheckedBaggageItem
+
weight
0..1
1
Passport
Passenger
1
BaggageItem
BaggageItem
Fig. 3.34 Internal Block Diagram showing internal interfaces
88
3
System Modelling for Requirements Engineering

Clearly this diagram represents a considerable overlap between the worlds of
modelling and requirements engineering, since this makes requirements part of the
underlying system model. Chapter 4 will brieﬂy discuss an even more integrated
approach to representing requirements in the system model, where the syntax of
the requirement text itself can reference model artefacts.
3.3.5
Formal Methods
Formal methods provide a more rigorous representation based on mathematics,
and can be used to conduct mathematical proofs of consistency of speciﬁcation
and correctness of implementation. Rigorous checking is possible, which can
eliminate some kinds of errors. This may be necessary in certain types of systems,
e.g. nuclear power stations, weapons, and aircraft control systems.
Z (Spivey JM, 1989), VDM (Bjørner D, Jones CB (1978)), (Bolognesi T,
Brinksma E, (1987)) and the B-Method (Abrial J-R (1996)) are the most com-
mon formal methods for formal deﬁnition of functionality. LOTOS (Language
of Temporal Ordering Speciﬁcation), VDM (the Vienna Deﬁnition Language)
and Z are formal methods standardized by ISO. B and LOTOS models are
executable, and B models can be reﬁned into code.
Formal methods are particularly suitable for critical systems i.e. ones in which
potential ﬁnancial or human loss would be catastrophic, and the cost of applying
mathematically rigorous methods can be justiﬁed.
Formal methods are slowly becoming more important. If their scope can be
broadened to address wider system issues, they will become more useful.
Satisfaction statement:
Garages already have equipment
that interfaces with the EMS for
diagnostic purposes.
This requirement satisfied by
distributing EMS software on CDs
that can be read by the existing
diagnostic equipment, and loaded
into the EMS.
«requirement»
EMS software shall
be published to after-
sales support
organisations in a CD
format.
«requirement»
The EMS diagnostic
equipment shall be
fitted with a CD
reader.
«requirement»
The EMS diagnostic equipment shall
be able to download a selected EMS
software version onto the EMS via the
diagnostic interface.
«testCase»
Conduct operational
scenario that includes the
upgrading of the EMS
version·
«requirement»
The EMS shall be able to
receive a selected EMS
software version via the
diagnostic intertace.
EMS Diagnostic Equipment 
«satisfy»
«satisfy»
«satisfy»
Stakeholder Requirements
«requirement»
The support engineer
shall be able to update
the EMS software.
«satisfy»
Enfine Management Sysmte (EMS)
«verify»
Fig. 3.35 Example requirement diagram
89
3.3
Methods

3.3.5.1
Z—A Model-Based Formal Method
Z is a formal speciﬁcation notation based on ﬁrst order predicate logic and set the-
ory. The notation allows data to be represented as sets, mappings, tuples, relations,
sequences and Cartesian products. There are also functions and operation symbols
for manipulating data of these types.
Z speciﬁcations are presented in a small, easy to read boxed notation called a
“schema.” Schemas take the form of a signature part and a predicate part. The sig-
nature part is a list of variable declarations and the predicate part consists of a sin-
gle predicate. Naming a schema introduces a syntactic equivalence between the
name and the schema. See Fig. 3.36.
Speciﬁcations in Z are presented as a collection of schemas where a schema
introduces some speciﬁcation entities and sets out the relationships between them.
They provide a framework within which a speciﬁcation can be developed and pre-
sented incrementally.
Figure 3.37 shows a Z speciﬁcation for the “issue” operation for a library,
where the general behaviour of the overall library system would be speciﬁed in a
schema named “library.” The notation ΔLibrary is called a delta schema and indi-
cates that the “Issue” operation causes a state change to occur in the Library.
The schema in Fig. 3.37 distinguishes between inputs and outputs, and before
states and after states. These operations are denoted as follows:
“?” denotes the variable as an input to the operation;
“!” denotes the variable as an output of the operation.
SchemaName
Variable declarations
Predicates
Fig. 3.36 Z schema
Issue
Δ Library
b? : Book
r? : Reader
b? ∈shelved; r? ∈  readers 
issued′ = issued ⊕ {b? - r?}
shelved′ = shelved\{b?}
stock′ = stock: readers′ = readers 
P
P
P
P
Library = = [shelved:P Book:readers:P Reader: 
stock:P Book: issued:P Book] 
Fig. 3.37 Example schema
90
3
System Modelling for Requirements Engineering

A state after the operation is decorated with the “’” symbol e.g. stock’ to distin-
guish it from the state before the operation.
3.4
Model-Based Systems Engineering
Many people see systematic modelling as bringing more rigour to the whole sys-
tem development life cycle, and the term
“Model-based System Engineering”
(MBSE) has been coined to encompass this initiative.
The International Council On Systems Engineering (INCOSE) deﬁnes it thus:
“Model-based systems engineering (MBSE) is the formalized application of modelling to
support system requirements, design, analysis, veriﬁcation and validation activities begin-
ning in the conceptual design phase and continuing throughout development and later life
cycle phases.” (INCOSE 2007)
At the heart of the concept of MBSE lies the integrated system model. This
“system model” is an integrated information base that draws together all the var-
ious models that in combination describe the system. The system model underlies
all the individual models, and captures their inter-relatedness through the artefacts
they have in common.
In this approach, individual models become particular projections or visualisa-
tions of the same underlying system model. These visualisations sometimes take
the form of datasets—such as tables of performance ﬁgures—and sometimes of
diagrams—such as “state transition diagrams” and “entity relationship diagrams.”
When fully implemented, the integrated system model allows a single design
artefact to appear in multiple diagrams or datasets. For instance, a “user” may
appear as an “actor” in a Use Case Diagram, as a “swim-lane” in a Sequence
Diagram, or as an “external” entity in a Data Flow Diagram. All these visualisa-
tions draw the “user” from the same underlying system model.
Likewise, a function may appear as a transition in a state transition diagram, a
message in the sequence diagram, or an operation in Z speciﬁcation.
Not many toolsets exist at present that provide integration across all kinds of
models and across all stages of the life cycle. However, the vision is admirable,
and there are current initiatives to advance the deﬁnition of an all-encompassing
system model.
3.5
Modelling and Qualiﬁcation
It would be a mistake to suppose that modelling is purely an aid in the develop-
ment of the design of a system. Models can also be used for formalise the qualiﬁ-
cation of a system.
Those used to the discipline of software testing will be familiar with the con-
cept of code coverage: every branch of the code should be covered by at least one
91
3.5
Modelling and Qualiﬁcation

test. Because code is a formal structure, it lends itself to coverage analysis and
measurement.
As with code, models are formal structures, and therefore notions of coverage
can also be applied. For instance, given a Data-Flow Diagram, a set of system
tests, say, could be derived that covered every “path” through the model. Indeed,
the right tool could even suggest the test scenarios for you, based purely on the
model. (Dick and Faivre 1993)
Such an approach allows the qualiﬁcation process to be formalised at every
stage where a model is presented. Indeed, there are examples of where the model-
ling is used purely for informing qualiﬁcation, See for example, (SyntheSys
2014), where a UML model of a complex interoperability model is used to gener-
ate test cases for conformance testing.
3.6
Summary
This chapter has addressed the issues of system modelling, particularly with
respect to the solution domain. A range of techniques and methods have been pre-
sented ranging from those which have stood the test of time to those which have
been developed more recently. All have been widely used in industry. The con-
tents of the chapter provide a basis for the discussion on modelling stakeholder
and system requirements in subsequent chapters.
92
3
System Modelling for Requirements Engineering

Chapter 4
Writing and Reviewing Requirements
To write simply is as difﬁcult as to be good.
William Somerset Maugham, author, 1874–1965 AD
4.1
Introduction
Requirements engineering is a technical process. Writing requirements is therefore
not like other kinds of writing. It is certainly not like writing a novel, or a book
like this; it is not even like the kind of “technical writing” seen in instruction man-
uals and user guides.
The purpose of this chapter is to present those aspects of writing requirements
that are common to every development layer. Wherever the generic process is
instantiated, certain principles and techniques are constant in their application to
the expression and structuring of requirements.
In writing a requirements document, two aspects have to be carefully balanced:
1. The need to make the requirements document readable.
2. The need to make the set of requirements processable.
The ﬁrst of these concerns the structure of the document, how it is organised
and how the ﬂow of it helps the reviewer to place individual requirement state-
ments into context. The second focuses on the qualities of individual statements of
requirement, the language used to promote clarity and precision, and how they are
divided into single traceable items.
The experienced requirements engineer comes to realise that a word processor
alone is not sufﬁcient to manage a set of requirements, for the individual state-
ments need to be identiﬁed, classiﬁed and traced. A classic problem, for instance,
is the use of paragraph numbers to identify requirements: insert a new one in the
middle, and suddenly all the subsequent requirement identiﬁers have changed.
93
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_4

Equally, those who have tried simply to manage their requirements in a data-
base quickly realise that tables full of individual statements are unmanageable.
Despite having the ability to identify, classify and sort requirements, vital contex-
tual information provided by the document has been lost; single statements lose
meaning when separated from their place in the whole.
So both aspects—document and individuality—need to be maintained.
The writing and the reviewing of requirements (or any other kind of document,
for that matter) should go hand-in-hand, in that the criteria for writing a good
requirement are exactly those criteria against which the requirement should be
reviewed. Hence the subjects are treated together in this chapter.
4.2
Requirements for Requirements
Before discussing how requirements documents and statements should be written,
it is best to review some of the objectives and purpose for the writing of require-
ments in the ﬁrst place. This will help in understanding why certain principles are
suggested.
The starting place is the identiﬁcation of stakeholders, which is shown in
Table 4.1.
Table 4.2 lists capabilities required by the various stakeholders that relate to
how requirements documents and statements are written. These are the basic
things that one needs to be able to do to—and with—requirements, including iden-
tiﬁcation, classiﬁcation, elaboration, tracking status, tracing, placing in context
and retrieving. How requirements are expressed and organised has a great inﬂu-
ence on how “useable” the sets of requires becomes.
4.3
Structuring Requirements Documents
Requirements documentation can be very large. On paper, the complete subsystem
requirements for an aircraft carrier, for instance, may ﬁll many ﬁling cabinets. It is
not unknown for supplier responses to large systems to be delivered in lorries.
Table 4.1 Stakeholders for requirements
Stakeholder
Role
Author
Creates the requirements and incorporates changes.
Publisher
Issues and archives the requirements document.
Reviewer
Reviews the requirements and suggests changes.
Implementer
Analyses the requirements and negotiates changes.
94
4
Writing and Reviewing Requirements

In such situations, having a well-understood, clearly documented structure for the
whole requirements set is essential to the effective management of complexity.
Organising requirements into the right structure can help:
• Minimize the number of requirements;
• Understand large amounts of information;
• Find sets of requirements relating to particular topics;
• Detect omissions and duplications;
• Eliminate conﬂicts between requirements;
• Manage iteration (e.g. delayed requirements);
• Reject poor requirements;
• Evaluate requirements;
• Reuse requirements across projects.
Documents are typically hierarchical, with sections and subsections to multiple
levels. Hierarchies are useful structures for classiﬁcation, and one way of structur-
ing a requirements document is to use the section heading structure to categorise
the requirements statements. In such a regime, the position a requirement state-
ment has in the document represents its primary classiﬁcation. (Secondary classiﬁ-
cations can be given through links to other sections, or by using attributes.)
Table 4.2 Abilities required for requirements
Ability
Ability uniquely to identify every statement of requirement.
Ability to classify every statement of requirement in multiple ways, such as:
• By importance;
• By type (e.g. functional, performance, constraint, safety);
• By urgency (when it has to be provided).
Ability to track the status of every statement of requirement, in support of multiple processes,
such as:
• Review status;
• Satisfaction status;
• Qualiﬁcation status.
Ability to elaborate a requirement in multiple ways, such as by providing:
• Performance information;
• Quantiﬁcation;
• Test criteria;
• Rationale;
• Comments.
Ability to view a statement of requirement in the document context, i.e. alongside its
surrounding statements.
Ability to navigate through a requirements document to ﬁnd requirements according to a
particular classiﬁcation or context.
Ability to trace to any individual statement of requirement.
95
4.3
Structuring Requirements Documents

Chap. 3 describes how system models frequently use hierarchies in the analysis
of a system. Examples are:
Goal or capability decomposition as in stakeholder scenarios;
Functional decomposition as in data-ﬂow diagrams;
State decomposition as in state charts.
Where requirements are derived from such models, one of the resulting hierar-
chies can be used as part of the heading structure for the requirements document.
In addition to requirements statements themselves, requirements documents
may contain a variety of technical and non-technical text, which support the
understanding of the requirements. These may be such things as:
• Background information that places the requirements in context;
• External context describing the enclosing system, often called “domain
knowledge”;
• Deﬁnition of the scope of the requirements (what’s in and what’s out);
• Deﬁnitions of terms used in the requirement statements;
• Descriptive text which bridges different sections of the document;
• Stakeholder descriptions;
• Summary of models used in deriving the requirements;
• References to other documents.
4.4
Key Requirements
Many organisations use the concept of “key requirements,” particularly at the sta-
keholder level. Often referred to as KURs (“Key User Requirements”) or KPIs
(“Key Performance Indicators”), these requirements are a small subset abstracted
from the whole that capture the essence of the system.
The guiding philosophy when selecting key requirements is similar to that used
by Jerome K. Jerome’s “Three Men in a Boat,” who, when planning for the trip,
realised that
The upper reaches of the Thames would not allow the navigation of a boat sufﬁciently
large to take the things [they] had set down as indispensable. …
George said, “We must not think of the things we could do with, but only the things that
we cannot do without.”
Every key requirement should solicit a negative response to the question:
If the solution didn’t provide me with this capability, would I still buy it?
or, if at the system level,
If the system didn’t do this, would I still want it?
In this way, the key requirements become those that are absolutely mandatory.
(Of course, everything is negotiable, but trading key requirements would always
engender very careful consideration.)
96
4
Writing and Reviewing Requirements

Where appropriate, each key requirement should be quantiﬁed with perfor-
mance attributes. Doing this allows them to be used as KPIs, used to assess alter-
native proposals against the requirements, or used as a summary of vital statistics
on project progress.
4.5
Using Attributes
It is clear from the discussions of process in previous chapters, and from the list of
abilities in Table 4.2, that a simple textual statement is not sufﬁcient fully to deﬁne
a requirement; there is other classiﬁcation and status information that each require-
ment carries.
Rather than clutter the text of a requirement, additional information should be
placed in “attributes” attached to the requirement. Attributes allow the informa-
tion associated with a single requirement to be structured for ease of processing,
ﬁltering, sorting, etc. Attributes can be used to support many of the abilities in
Table 4.2, enabling the requirements to be sorted or selected for further action,
and enabling the requirements development process itself to be controlled.
Figure 4.1 shows an example of a requirement with a number of attributes.
The particular attributes used will depend on the exact processes that need to
be supported. Some attributes are entirely automatic—e.g. dates, numbers—some
come from users—e.g. priority—other attributes are ﬂags, which are set after ana-
lysis work—e.g. checkability.
In a recent paper entitled “On Using Attributes to Manage Requirements”
(Wheatcroft et al. (2016)), the following deﬁnition is used to capture the distinc-
tion between statements and attributes:
4.5.1
Deﬁnition of a Requirement Expression
A requirement expression includes a requirement statement with a set of associated
attributes.
[SH234] The ambulance control system shall be able to handle up to 100 
simultaneous emergency calls.
Source:
R. Thomas
Priority:
Mandatory
Release:
1
Review status: Accepted
Verifiable:
Yes
Verification:
By simulation, then by system test.
Fig. 4.1 Requirements attributes
97
4.5
Using Attributes

From this deﬁnition of a requirement expression, a requirement is more than just
a well-formed requirement statement. The full expression of a requirement includes
associated attributes that aid in the management of the requirement. That is:
Requirement Expression = Requirement Statement + Attributes
The paper goes on to list 44 examples of potential requirements attributes, clas-
siﬁed into the following uses:
• Attributes to help deﬁne the requirement and its intent.
• Attributes associated with the system of interest and requirement veriﬁcation.
• Attributes to help maintain the requirements.
• Attributes to show applicability and allow reuse.
The following suggestions for attribute categories are drawn in part from some
work carried out by a requirements working group in the UK chapter of INCOSE
(see Table 4.3).
Table 4.3 Categories of attributes
Category
Example values
Identiﬁcation
• Identiﬁer
Unique reference
• Name
Unique name summarising the subject of the requirement
Intrinsic characteristics
• Basic type
Functional, performance, quality factor, environment, interface,
constraint, non-requirement
• Quality factor sub-
type
Availability, ﬂexibility, integrity, maintainability, portability,
reliability, safety, security, supportability, sustainability, usability,
workmanship
• Product/process type
Product, process, data, service
• Quantitative/
qualitative type
Quantitative, qualitative
• Life-cycle phase
Pre-concept, concept, development, manufacturing, integration/test,
deployment/delivery/installation, operation, support, disposal
Priority and importance
• Priority (compliance
level)
Key, mandatory, optional, desirable
or
Must, should, could, wish (MoSCoW)
• Importance
1 to 10
Source and ownership
• Derivation type
Allocation, decomposition
• Source (origin)
Name of document or stakeholder
(continued)
98
4
Writing and Reviewing Requirements

4.6
Ensuring Consistency Across Requirements
A frequent concern in managing large sets of requirements is being able to identify
conﬂicting requirements. The difﬁculty is in spotting that two statements many
pages apart are in conﬂict. What techniques can be applied to assist in identifying
these potential inconsistencies?
Table 4.3 (continued)
Category
Example values
• Owner
Name of stakeholder
• Approval authority
Name or person
Context
• Requirements set/
document
(Best handled through positioning the requirement in a structured
document)
• Subject
• Scope
Veriﬁcation and validation
• V&V method
Analysis, inspection, system test, component test
• V&V stage
(See life-cycle phase)
• V&V status
Pending, pass, failed, inconclusive
• Satisfaction
argument
Rationale for choice of decomposition
• Validation argument
Rationale for choice of V&V methods
Process support
• Agreement status
Proposed, being assessed, agreed
• Qualiﬁcation status
Not qualiﬁed, qualiﬁed, suspect
• Satisfaction status
Not satisﬁed, satisﬁed, suspect
• Review status
To be reviewed, accepted, rejected
Elaboration
• Rationale
Textual statement about why the requirement is present
• Comments
Textual comments of clariﬁcation
• Questions
Questions to be posed for clariﬁcation
• Responses
Responses received for clariﬁcation
Miscellaneous
• Maturity (stability)
Number of changes/time
• Risk level
High, medium, low
• Estimated cost
• Actual cost
• Product release
Version(s) of product meeting the requirement
99
4.6
Ensuring Consistency Across Requirements

One answer lies in classifying requirements in several ways, and using ﬁltering
and sorting techniques to draw together small numbers of statements that address
the same topic. Many requirements will touch on several aspects of a system. For
instance, a requirement primarily about engine performance may also contain a
safety element. Such a statement should therefore be viewed in both an engine
performance context as well as in a safety context.
To facilitate this, requirements can be given primary and secondary classiﬁca-
tions, as discussed in Sect. 1.3. Typically, each has a single primary classiﬁcation
(perhaps by virtue of its position in the document), and multiple secondary classi-
ﬁcations, perhaps using links or attributes.
A thorough review process can now include the systematic ﬁltering of state-
ments by keywords used in primary and secondary classiﬁcations. For example,
ﬁltering on all requirements to do with safety will draw together statements whose
primary classiﬁcations may be quite diverse. These can then be reviewed in proxi-
mity for potential conﬂicts.
4.7
Value of a Requirement
Some requirements are non-negotiable. If they are not met, the product is of
no use.
Other requirements are negotiable. For instance, if a system is required to sup-
port at least 100 simultaneous users, but the delivered solution only supports 99,
then it is most likely still of some value to the customer.
Capturing the value of a requirement can be a challenge. A way needs to be
found of expressing the idea that, while the target may be 100 simultaneous users,
75 would be acceptable, but anything less than 50 is not acceptable; and maybe
200 would be even better.
One approach to this is to provide several performance values. Here is an
example of a three-valued approach:
M: the mandatory lower (or upper) limit;
D: the desired value;
B: and the best value.
These three values can be held in separate attributes, or represented within the
text in a labelled form, such as “The system shall support [M:50, D:100, B:200]
simultaneous users.”
Another approach is to represent the value of a requirement by supplying a
function that maps performance to some representation of value, usually a ﬁgure
between 1 and 100. Figure 4.2 shows four examples of different shapes of value
function. Function (a) shows the example above, where the number of simulta-
neous users should be maximised, but more than a minimum number is manda-
tory. Function (b) is the binary case: either the performance of 100 is exceeded or
not. A performance of 200 does not add extra value. Function (c) shows a
100
4
Writing and Reviewing Requirements

performance that is to be minimised (weight, for instance), whereas (d) shows one
that is to be optimised (engine revs, for example).
This is a very visual way of presenting value. One glance at the shape of the
value curve indicates the nature of the requirement: minimise, maximise, optimise,
etc. It also allows the engineers to understand the degrees of freedom they have in
designing solutions that deliver the best overall value, by trading-off performance
between requirements. This is why this approach is frequently used as part of the
tender assessment process, to judge between the relative values of alternative
proposals.
An attribute can be used to represent a value function as a set of performance/
value pairs.
4.8
The Language of Requirements
The use of consistent language makes it easier to identify different kinds of
requirements. A simple example of this is the use of “shall” as a key word to indi-
cate the presence of a requirement in the text. Some approaches go so far as to use
“shall,” “should” and “may” to indicate different priorities of requirement.
The language used will vary depending on the level of requirement being
expressed. The principle difference is between stakeholder requirements that lie in
the problem domain and system requirements that lie in the solution domain (see
Chap. 1, Sect. 1.9).
50    100    200 users
performance
value
0
100
maximise
5      10      20kg
performance
value
0
100
minimise
3       7       10  Krpm
performance
value
0
100
optimise
50    100    200 users
performance
value
0
100
exceed
a
b
c
d
Fig. 4.2 Typical value functions
101
4.8
The Language of Requirements

As is emphasised in Sect. 1.9, stakeholder requirements are primarily con-
cerned with capability and constraints on capability. A capability statement should
express a (single) capability required by one or more identiﬁed stakeholder types
(or user groups). The types of stakeholder should be stated in the requirement text.
A typical capability requirement takes the following form:
The <stakeholder type> shall be able to <capability>.
Where there are some aspects of performance or constraint associated solely with
the requirement, they may also be stated in the text, for instance giving the form:
The <stakeholder type> shall be able to <capability>
within <performance> of <event>
while <operational condition>.
For example, the following capability requirement has a performance and con-
straint attached:
The weapons operator shall be able to ﬁre a missile
within 3 seconds of radar sighting
while in severe sea conditions.
Less commonly, a single performance attribute is associated with several
capabilities. For example, several capabilities may need to be provided with a set
time. In practice these capabilities are usually sub-divisions of a high-level
capability, to which the performance attribute should be attached.
It frequently occurs, however, that constraints have to be expressed separately
from the capabilities, either because they apply to the whole system, or because
they apply to diverse capabilities. Generally, constraints in stakeholder require-
ments are based either on minimum acceptable performance or are derived from
the need to interact with external systems (including legal and social systems).
A typical constraint requirement takes the following form:
The <stakeholder> shall not be placed
in breach of <applicable law>.
E.g. The ambulance driver shall not be placed
in breach of national road regulations.
Since they lie in the solution domain, the language of systems requirements is a
little different. Here the focus is on function and constraints on the system. The
language depends on the kinds of constraint or performance associated with the
requirement. Here is an example of a function with a capacity performance:
The <system> shall <function>
not less than <quantity> <object>
while <operational condition>.
E.g. The communications system shall sustain telephone contact
with not less than 10 callers
while in the absence of external power.
102
4
Writing and Reviewing Requirements

Here is another that expresses a periodicity constraint:
The <system> shall <function> <object>
every <performance> <units>.
E.g. The coffee machine shall produce a hot drink
every 10 seconds.
Further discussion of this topic can be found in the following section.
4.9
Requirement Boilerplates
The language of requirements in Sect. 4.8 was expressed in terms of boilerplates.
This section extends this concept, and applies it to the collection and expression
of constraint requirements.
Using boilerplates such as the examples in Sect. 4.8 is a good way of standar-
dising the language used for requirements. A palette of boilerplates can be col-
lected and classiﬁed as different ways of expressing certain kinds of requirement.
As an organisation gains experience, the palette can be expanded and reused from
project to project.
In the light of this approach, the deﬁnition of a Requirements Expression can
be modiﬁed as follows:
Requirement Expression = Boilerplate + Placeholder values
Expressing a requirement through a boilerplate now becomes a process of:
• Selecting the most appropriate boilerplate from the palette;
• Providing data to complete the placeholders.
The requirement can refer to a single document-wide instance of the boiler-
plate, and placeholders can actually be collected separately as attributes of the
requirement. This is illustrated in Fig. 4.3.
From this information, the textual form of the requirement can be generated
when needed. Separating the template has the following advantages:
Global changes in style can be effected: To change the ways certain requirements
are expressed, only the centrally-held boilerplate needs to be edited;
System information can be processed more easily: Collecting, for instance, all the
“<operational condition>” placeholders into a separate attribute allows for easy
sorting and ﬁltering on operational conditions;
Conﬁdential information can be protected: In contexts where requirements contain
classiﬁed or secret information, boilerplates can be used to separate out just
those parts of each statement that need to be protected.
This last point merits some elaboration. In military or commercially sensitive
projects, there is a need to restrict the availability of some information, but not all.
103
4.9
Requirement Boilerplates

Quite often, a single statement of requirement will contain a mixture of informa-
tion classiﬁed at various levels. For instance, it is obvious that the ship is going to
ﬁre missiles; what is classiﬁed is the performance associated with that capability:
the state of readiness, the frequency, and the range, etc. Rather than having to hide
the whole statement because some of the elements are conﬁdential, boilerplates
permit the statement to be visible without some of its more sensitive attributes.
Indeed, different readers may be able to see different sets of attributes.
Since there are such a wide variety of constraints, these tend to be the most dif-
ﬁcult to express, and this is where boilerplates can help the most. Here is an
approach to capturing constraint requirements:
1. Collect all capability requirements ﬁrst;
2. Construct a list of all the different kinds of constraint that may need to be
expressed. If this list is based on past experience of the same kind of system,
then boilerplates should exist for each kind. Otherwise suitable boiler-plates
may have to be deﬁned;
3. For each capability, consider each kind of constraint, and determine whether a
constraint needs to be captured. A large table could be used for this; in each
cell, indicate where constraints exist by entering the appropriate sub-ordinate
clauses to the requirement; where no constraint is necessary, enter “N/A” in the
appropriate cell.
4. Select the boilerplate that best matches the constraint to be expressed, and
instantiate it.
5. The process is ﬁnished when every “cell” has been considered.
The <system> shall <function> <object>
every <performance> <units>.
Template 34
Requirement 347 = Template 34 +
<system> = coffee machine
<function> = produce
<object> = a hot drink
<performance> = 10
<units> = seconds
Requirement 348 = Template 34 +
<system> = coffee machine
<function> = produce
<object> = a cold drink
<performance> = 5
<units> = seconds
Fig. 4.3 Global templates
104
4
Writing and Reviewing Requirements

This process answers two frequently asked questions:
• How do I express constraint requirements? (Use boilerplates.)
• How do I know when all constraints have been collected? (Use this systematic
coverage approach.)
Table 4.4 shows some examples of boilerplates classiﬁed by type of constraint.
Note that there may be several ways of expressing similarly classiﬁed constraints,
and that constraints may have a compound classiﬁcation. Only those parts of the
boilerplate that are in bold font are actually relevant to the constraint.
The following paper is a useful summary of the boilerplate approach: Dick and
Llorens (2012).
4.10
Granularity of Requirements
The use of requirements boilerplates encourages the practice of placing some con-
straints and performance statements as sub-clauses of capability or functional
requirements. In some cases, it may be desirable to create traceability to and from
just those sub-clauses.
This raises the question of granularity of information. How far do we “split the
atom” in requirements management?
Statements of requirements can be decomposed into sub-clauses, as long as
tool support ensures that clauses are always visible in context. One scheme is to
Table 4.4 Example boilerplates for constraint requirements
Type of constraint
Boiler-plate
Performance/
capability
The <system> shall be able to <function> <object> not less than
<performance> times per <units>.
Performance/
capability
The <system> shall be able to <function> <object> of type
<qualiﬁcation> within <performance> <units>.
Performance/
capacity
The <system> shall be able to <function> not less than <quantity>
<object>.
Performance/
timeliness
The <system> shall be able to <function> <object> within
<performance> <units> from <event>.
Performance/
periodicity
The <system> shall be able to <function> not less than <quantity>
<object> within <performance> <units>.
Interoperability/
capacity
The <system> shall be able to <function> <object> composed of not
less than <performance> <units> with <external entity>.
Sustainability/
periodicity
The <system> shall be able to <function> <object> for
<performance> <units> every <performance> <units>.
Environmental/
operability
The <system> shall be able to <function> <object> while
<operational condition>.
105
4.10
Granularity of Requirements

extend the requirements hierarchy to make the sub-clauses children of the main
requirement, as shown in Fig. 4.4. Whereas the main requirement is readable (and
traceable) on its own, the sub-clauses, albeit separately referenceable for tracing
purposes, make sense only in the context of their “parent” statement.
Traceability can now reference a speciﬁc sub-clause, but the clause should only
ever be cited with the context of its ancestor statements. For instance, the traceable
statements that can be cited from Fig. 4.4, with context in italics, are:
The communications system shall sustain telephone contact.
• The communications system shall sustain telephone contact with not less than
10 callers.
• The communications system shall sustain telephone contact while in the
absence of external power.
There may be several ways of organising the hierarchy of clauses. Suppose, for
instance, that there are multiple capabilities required “in the absence of external
power.” Then the arrangement may be as in Fig. 4.5.
Now the traceable statements that can be cited are:
• While in the absence of external power, the communications system shall sus-
tain telephone contact.
• While in the absence of external power, the communications system shall
sustain telephone contact with not less than 10 callers.
• While in the absence of external power, the communications system shall
sustain radio contact with not less than 15 ambulance drivers.
Indeed, as a general principle, requirements could be organised in such a way
that the set of ancestor objects provide the complete context for each statement,
including section and sub-section headings.
The communications system shall sustain telephone contact
with not less than 10 callers
while in the absence of external power.
Fig. 4.4 Performance and constraints as sub-clauses
While in the absence of external power,
the communications system shall sustain telephone contact
with not less than 10 callers.
the communications system shall sustain radio contact
with not less than 15 ambulance drivers.
Fig. 4.5 Alternative arrangement of sub-clauses
106
4
Writing and Reviewing Requirements

4.11
Requirements and Modelling
Chap. 3 presented the UML Requirements Diagram. In these diagrams, require-
ments appear simply as text items, and no attempt is made to process the internal
structure of the text.
The concept of requirements boilerplates in Sects. 4.8 and 4.9 has allowed us
to get inside the syntactical and grammatical structures of requirement statements.
Some of the placeholders will correspond to entities in system models, such as
functions, states, actors, events, modes and conditions. Explicitly recognising this
correspondence may allow us to integrate textual requirements with the underlying
system model.
Some modelling approaches, such as CORE (Faulk et al. (1992)), use a sys-
tematic trawl of requirements statements to identify functions from verbs and enti-
ties from nouns as the starting point for building a system model. This assumes
that the requirements come ﬁrst, and the modelling afterwards.
The opportunities that the boilerplate approach offers include:
1. The development of the system model as the requirements are captured.
2. The generation of textual requirements from the system model.
In the ﬁrst case, particular placeholders can be aligned with concepts in the sys-
tem model, and, if boilerplates are selected that contain such placeholders, then
the requirement author can be directed to select entities that exist already in the
system model, or to create new entities registered in the system model for ongoing
use. This would not only promote consistent use of vocabulary across the require-
ment set, but turn requirements elicitation into part of the modelling process rather
than separate.
In the second case, textual requirements (or at least a subset of them) could be
generated as a new projection or visualisation of the system model. The language
would of necessity be highly stylised, but then that is exactly the aim of using boi-
lerplates in the ﬁrst place.
The authors know of no tool support for such an approach at the time of
writing.
4.12
Criteria for Writing Requirements Statements
Apart from the language aspects, there are certain criteria that every statement of
requirement should meet. These are summarised as follows:
Singular: each statement carries a single traceable element;
Unique: each statement can be uniquely identiﬁed;
Feasible: technically possible within cost and schedule;
Legal: legally possible;
Clear: each statement is clearly understandable;
107
4.12
Criteria for Writing Requirements Statements

Precise: each statement is precise and concise;
Veriﬁable: each statement is veriﬁable, and it is known how;
Abstract: does not impose a solution of design speciﬁc to the layer below.
In addition, there are other criteria that apply to the set of requirements as a
whole:
Complete: all requirements are present;
Consistent: no two requirements are in conﬂict;
Non-redundant: each requirement is expressed once;
Modular: requirements statements that belong together are close to one another;
Structured: there is a clear structure to the requirements document;
Satisﬁed: the appropriate degree of traceability coverage has been achieved;
Qualiﬁed: the appropriate degree of traceability coverage has been achieved.
Two “nightmare” examples of actual requirements are given below.
1. The system shall perform at the maximum rating at all times except that in
emergencies it shall be capable of providing up to 125% rating unless the
emergency condition continues for more than 15 minutes in which case the
rating shall be reduced to 105% but in the event that only 95% can be achieved
then the system shall activate a reduced rating exception and shall maintain the
rating within 10% of the stated values for a minimum of 30 minutes.
2. The system shall provide general word processing facilities which shall be easy
to use by untrained staff and shall run on a thin Ethernet Local Area Network
wired into the overhead ducting with integrated interface cards housed in each
system together with additional memory if that should be necessary.
Some classic problems are present in these examples. The following pitfalls
should be avoided:
• Avoid rambling: conciseness is a virtue; it doesn’t have to read like a novel;
• Avoid let-out clauses: such as “if that should be necessary”; they render the
requirements useless;
• Avoid putting more than more requirement in a paragraph: often indicated by
the presence of the word “and”;
• Avoid speculation;
• Avoid vague words: usually, generally, often, normally, typically;
• Avoid vague terms: user friendly, versatile, ﬂexible
• Avoid wishful thinking: 100% reliable, please all users, safe, run on all plat-
forms, never fail, handle all unexpected failures, upgradeable to all future
situations.
An analysis of the ﬁrst example above admits that there could be 12 require-
ments present. A better approach would be to identify clearly the four different
operational modes of the aircraft: normal, emergency, emergency more than
15 minutes, and reduced rating exception, and express a separate requirement
for each.
108
4
Writing and Reviewing Requirements

Note the let-out clause in the second example. It is not clear what the scope of
the clause is. One interpretation is “The system shall provide general word proces-
sing facilities … if that should be necessary.” Well is it required, or not?
4.13
Guide to Writing Requirements
The INCOSE “Guide to Writing Requirements” (INCOSE (2017)) is probably the
most extensive repository of rules for writing requirements expressions. It draws a
useful distinction between the desirable characteristics of a requirement statement
(14 in number), and the rules that may be followed to achieve that characteristic
(44 in number). It also traces the (coincidentally) 44 potential attributes (see
Sect. 4.5) to the characteristics and rules.
Figure 4.6 shows an example from the guide. It contains a deﬁnition of the
characteristic called “Singular,” along with rationale and guidance. It then lists
references to the nine rules that, if followed, help establish the characteristic.
The deﬁnitions of two of the rules are shown in Fig. 4.7.
The requirement should state a single capability, characteristic, constraint, or quality factor.
The formal transformation is a one-to-one or a many-to-one transformatin, so the resultant
requirement statement must represent a single thought. The effectiveness of several proceses
associated with requirements, such as decomposition, derivation, allocation, tracing, and
verification, depends on being able to identify singular statements. For instance, the verifcation
information defined for a requirement can be far more precise when that requirement addresses a
single capability, characteristic, constraint, or quality factor. A requirement with multiple thoughts
is difficult to allocate and to trace to a parent or source.
R10 - /Precision/NoOpenEnded
R19 - /Singularity/SingleSentence
R20 - /Singularity/AvoidCombinators
R21 - /Singularity/AvoidCombinators/ExceptlnConditions
R22 - /Singularity/AvoidPurpose
R23 - /Singularity/AvoidParentheses
R24 - /Singularity/Enumeration
R25 - /Singularity/Context
R41 - /UniformLanguage/StyleGuide
Keep the requirement limited to one quality, characteristic, capability, function, or constraint.
Understand how the statements fit into the traceability philosophy for the project.
Use the project standard template for writing the requirements.
Although a single requirement should consist of a single function, quality or constraint, it may
have multiple conditins under which the rquirement is to be met.
Avoid the use of the word “and’ when it ties together multiple thoughts (pharses in the sentence),
each of which may be allocated and verfied differently. The presence of the conjunction ”and” in
a requirement statement should always prompt the writer to consider whether or not the
statement is singular.
2.5 C5 - SINGULAR
Definition:
Rationale:
Guidance:
Rules that help establish this characteristic:
Fig. 4.6 Example characteristic from the INCOSE guide to writing requirements
109
4.13
Guide to Writing Requirements

This relationship between characteristics and rules is essentially an application
of the principle of traceability. The characteristics are like the stakeholder require-
ments, which are satisﬁed by combinations of rules, like system requirements.
You can look at the rules, and see the contribution they are making to the higher
level.
Avoid open-ended clauses.
Open-ended clauses say that there is more required without stating exactly whta. Avoid non-
specific phrases such as “including but not limited to,”etc.” and “and so on.”
Open-ended clauses can lead to ambiguous, unverifiable requirements that do not reflect
accurately the stakeholder expectations. Use of open-ended clauses also violates the one
thought rule and singular characterisitc. If more cases are required, then include additional
requirements that explicitly state those cases.
The ATM shall display the Customer Account_Number.
The ATM shall display the Customer Account_Balance.
The ATM shall display the Customer Account_Type.
The ATM shall display the Customer Account_Overdraft_limit.
The ATM shall display the customer ......
C3 - Unambiguous
C4 - Complete
C5 - Singular
Unacceptable: The ATM shall display the Customer Account_Number, Account_Balance and so
on. (This is unacceptable becuase it contains an opened list of what is to be displayed.)
Acceptable: {Spilt into as many requirements as necessary to be complete. Note that the
customer information to be displayed needs to be defined in the glossary.}:
Elaboration:
Examples:
Examples:
Characteristics that are established by this rule:
Characteristics that are established by this rule:
Elaboration:
4.1.10 R10 - /PRECISION/NOOPENENDED
4.4.4 R2 - /SINGULARITY/AVOIDPURPOSE
C7 - Verifiable
Avoid phrases that indicate the purpose of the requirement.
C5 - Singular
The text of a requirement does not have to carry around extra baggage such as the purpose for
its existence. Expressions of purpose are often indicated by the presence of phrases such as “in
order to,” ”so that.” ”thus allowing.”
THis extra information should be included in the requirement attribute A1-Rationale.
Unacceptable: The Database shall store Account_Balance information until it is at least 10 years
old in order to satisfy the demands of the auditors. {This is uncacceptable because the text
following “in order to” is rationale.}
Acceptable: The Audit_System shall store Account_Balance information relating to greater than
the last 10 years. [”In order to ...” should be included in the rationale statement.]
Fig. 4.7 Example rules from the INCOSE guide to writing requirements
110
4
Writing and Reviewing Requirements

4.14
Summary
One of the hardest things to do in requirements is to get started. It is important to
have an approach, but above all it is important to start writing down the require-
ments from day one and show them to others for comment. The following list is
intended as a safe way to proceed:
• Deﬁne an outline structure at the outset, preferably hierarchical, and improve it
as you go;
• Write down requirements as soon as possible, even if they are imperfect;
• Determine in advance what attributes will be used to classify and elaborate the
textual statement;
• Produce an initial version rapidly to stimulate immediate feedback;
• Perfect the requirements as you go, removing repetition, unwarranted design,
inconsistency;
• Brainstorm and hold informal reviews continually, with rapid turn-around of
versions;
• Exposure to users is much better than analysis by “experts.”
The rules to follow when writing requirements are as follows:
• Use simple direct language;
• Write testable requirements;
• Use deﬁned and agreed terminology;
• Write one requirement at a time.
111
4.14
Summary

Chapter 5
Requirements Engineering
in the Problem Domain
It isn’t that they can’t see the solution. It is that they
can’t see the problem.
Gilbert Keith Chesterton, author, 1874–1936 AD
5.1
What is the Problem Domain?
The problem domain is the domain in which a system is going to be used.
Therefore it is important to look at requirements from an operational point of
view. A system or any other product enables somebody or some equipment to do
something. It is this enabling aspect that is at the heart of requirements engineering
in the problem domain. Faced with the challenge of eliciting requirements from
potential users one might therefore be tempted to ask a user the question:
What do you want the system to do?
Some users will have little or no idea of what they want the system to do.
Those who have an existing system will usually have ideas about how to improve
the system, but when there is no existing system this source of inspiration is not
available. Answers may be forthcoming from those with insight into what is possi-
ble, but they are most likely to come up with a solution because the question is
focussing on the functionality to be provided by the intended system.
To avoid this premature jump into the solution domain, it is necessary to ask
the question:
What is the purpose of the system you want?
When considering the purpose of a system, people immediately think about what
they want to be able to do with the system, rather than how they will do it. What peo-
ple want to achieve can be stated without any implementation or solution bias and this
leaves the solution space open to the systems engineers and architects.
113
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_5

It can be argued that even mentioning “the system” in the question could be
misleading and the question reduces to:
What do you want to be able to do?
The answers to this question should be of the form:
I want to be able to …
This is known as a capability requirement and is one of the key forms of
requirement in the problem domain.
Having established that requirements engineering in the problem domain is pri-
marily about eliciting capabilities, the next question is
Who should be asked?
This leads to the identiﬁcation of stakeholders. Recall from the deﬁnition in Chap. 1
that a stakeholder is an individual, group of people, organisation or other entity that
has a direct or indirect interest (or stake) in the intended system. (See Sect. 1.3.1.)
Finally, the sorts of models that are relevant to the problem domain are exam-
ined. Clearly any models that are used must be understandable to the stakeholders,
because they are going to be responsible for validating them. Since the stake-
holders have been chosen for their specialist knowledge in the problem, they are
generally unwilling or unable to comprehend any model that is the slightest bit
technical. For example, if you were to go into a car show room and examine the
cars on display, you would be very unlikely to be interested in a state transition
diagram of the engine management system. You are more likely to be concerned
about the performance of the car in terms of its acceleration, fuel efﬁciency, its
comfort level and the in-car entertainment facilities. In other words, you are con-
sidering what the car might be like to drive on a long journey. In your mind’s eye
you are thinking about an imaginary journey in the car and considering all the
aspects of the car that would be useful or beneﬁcial during that journey. This is an
example of a use scenario.
It has been found that use scenarios are a very good way of modelling what
people do or want to be able to do. They are directly related to the way they think
about their job or their problems. The scenario can be constructed with the stake-
holders and then used as a basis for discussing the capabilities that are required.
The ﬁnal aspect of requirements engineering in the problem domain, is that
there may be some overriding constraints. In the example of buying a car, you
may have a limited budget, or you may require the car to be delivered within a
given period of time. You may want the running costs to be below a given level.
It is now possible to consider how to instantiate the generic process for the
creation of Stakeholder Requirements.
5.2
Instantiating the Generic Process
Figure 5.1 contains an instantiation of the generic process for the elicitation of sta-
keholder requirements. The starting point is the Statement of need. This may be
quite a small item, e.g. it could be an email from the Chief Executive Ofﬁcer
114
5
Requirements Engineering in the Problem Domain

(CEO) to the Chief Technical Ofﬁcer (CTO) stating that a new product is required
to get one step ahead of the competition. Alternatively, there may already have
been a study performed to look at possible options and a concept of operations
document produced that identiﬁes some use scenarios.
Figure 5.1 indicates that the Analyse and Model process creates a Usage Model
and a Stakeholder List. The Usage Model typically consists of Use Scenarios,
discussed at length in Sect. 5.4.2. The derived requirements will be Stakeholder
Requirements.
The details of the Analyse & Model and Derive Stakeholder Requirements and
Qualiﬁcation Strategy processes are introduced in the following sections.
Statement of
Needs
Agree
Requirements
Analyse and
Model
Change Request
Change
Request
Useage
Model
Stakeholder
List
STAKEHOLDER
REQUIREMENTS
PROCESS
Derive Stakeholder
Requirements and
Qualification
Strategy
Change Request
Change Request
Stakeholder
Requirements
Agree
Requirements
Qualification
Strategy for 
Stakeholder
Requirements
Qualification
Strategy for Needs
Fig. 5.1 Stakeholder requirements process
115
5.2
Instantiating the Generic Process

5.3
Agree Requirements with Customer
The agreement process at the start of the Stakeholder Requirements process is
usually very informal. It is quite likely that the Statement of Needs is a simple
document that has not been engineered from a requirements point of view. In other
words it is likely to contain woolly expressions of need mixed with descriptive
information. It will not contain atomic requirements that can be the target of satis-
faction relationships. In this respect the Stakeholder Requirements process is
different to other requirements processes because it starts from this rather vague
position. One of the key elements in eliciting stakeholder requirements is to estab-
lish the scope of the intended system. This is usually done once a set of Usage
Model has been established.
5.4
Analyse & Model
The Analyse & Model process is instantiated for the problem domain as shown in
Fig. 5.2. The ﬁrst activity is to identify stakeholders and then the Usage Model
can be created in consultation with them.
Change
Request
Change
Request
Create Models
Stakeholder
List
Useage
Model
Statement of
Needs
ANALYSE AND MODEL
Identify
Stakeholders
Qualification
Strategy for Needs
Fig. 5.2 Analyse & model process for stakeholder requirements
116
5
Requirements Engineering in the Problem Domain

5.4.1
Identify Stakeholders
As indicated earlier, a stakeholder can be any person or organisation that has an
opinion, a responsibility for, or who may be inﬂuenced or affected by the
proposed system. The types of stakeholders vary according to the nature of the
system; e.g. on whether the system is a consumer product, or a public service such
as air trafﬁc control or a railway.
People who have an opinion about the proposed system include those people
who will use the system directly. Note that this can include the general public
who may be passengers on aircraft or trains, or may be affected by a crash when
they were otherwise not involved in travelling. People with responsibility for a
system may be managers in charge of operating the system, or safety authorities.
The following list contains possible stakeholder categories that can be used as
the basis for establishing whether a complete list of stakeholders has been identi-
ﬁed. The list does not claim to be complete, but provides guidance to help when
brainstorming to create the list:
Managers: People who have a responsibility for either the development budget or
operating budget of the proposed system. It is also a good plan to involve
senior policy makers who will take a view on whether the proposed develop-
ment conforms to the aims and philosophy of the company or organisation.
Investors: People who either have made or are being invited to make a contribu-
tion to the funding of the proposed system, or the organisations responsible for
developing or operating the system.
System users: Clearly this is a very important group of stakeholders. They have a
direct interest in the capabilities provided by the new system or service. Note
that there may also be users who do not interact directly with the system. For
example, the users of the Hubble telescope are astronomers. They ask for
photographs to be taken in speciﬁc directions, and they receive the information
when it arrives, but they do not directly control the telescope itself. Users of an
existing system are also valuable sources of knowledge of problems with that
system. They can give invaluable insight into how they would like to see the
system improved.
Maintenance and service staff: Although their prime responsibility is to keep the
system running once it has been delivered, they do have important require-
ments that the system must address in order to help them do their job.
Product disposers: This is an increasingly important role as environmental pro-
tection legislation develops. Requirements from this source can have a massive
impact on design especially with respect to the materials employed.
Training personnel: Like the maintenance staff, these people have a vested interest
in making the system easy to use and consequently easy to train people to use.
These people may also require the system to be able to work simultaneously in a
mode where live data and training data can be mixed without interfering with the
safe operation of the system.
117
5.4
Analyse & Model

System buyers: For public services and other large systems, the person who buys
the system may not be involved directly with its development or operation.
They will, though, have an important role to play in scoping the system from
the point of view of cost versus perceived beneﬁt. For product-based develop-
ments, the buyer may be the actual user, e.g. mobile phone user, car driver etc.
Sales and marketing: These people have a vital role to play in formulating the
capabilities for new systems, especially for product-based developments,
because, for mass produced consumer products, it is not possible to have access
to all potential users.
Usability and efﬁciency experts: These people have a view on how the system
can be optimised to make it efﬁcient in use. These factors include ergonomics,
ease of learning and, where relevant, ability to be used reliably under pressure
(e.g. in air trafﬁc control).
Operational environment experts: Usually a new system is not created to work
in a “green ﬁelds” situation; it will have to inter-operate with existing systems.
There may also be other environmental aspects such as emission control where
the system must not pollute the environment, and conversely, aspects where the
system must be able to tolerate the environment in which it is placed (e.g. in
extreme weather conditions, submersed in water etc.)
Government: Rules, regulations and laws determine and inﬂuence what a system
may or may not do.
Standards bodies: Existing and future standards can affect the goals of a pro-
posed system. These may be international such as the GSM mobile phone stan-
dards, national standards or internal company standards.
Public opinion and opinion leaders: Different regions of the world have different
attitudes. These factors must be recognised where a product is to be marketed
in a wide range of countries.
Regulatory authorities: These organisations may require that certain evidence be col-
lected as part of a certiﬁcation or authorisation process. Examples include the Rail
Regulator in the UK and the Food and Drug Administration (FDA) in the USA.
Having arrived at a list of potential stakeholder types, it is necessary to deter-
mine which types are relevant and how each stakeholder type can be accessed. In
some cases, e.g. system users, it may be possible to have direct access to them. In
other cases, e.g. general public, it is not possible. It is necessary to decide, for those
that are accessible, who will be nominated as the stakeholder(s); and for those not
accessible, who will take on the “role” of that stakeholder and speak on their
behalf. This list then constitutes the output Stakeholders from this process (see
Fig. 5.2).
5.4.2
Create Usage Model
Most conversations are built around a set of assumptions on which the speakers
agree. These assumptions can be interpreted to be a model of their mutual
118
5
Requirements Engineering in the Problem Domain

understanding. Attempting to discuss requirements in the absence of any agreed
ground rules would be unproductive.
One basic structuring mechanism for discussing capability requirements is the
operational or use scenario. This produces a structure that is organised hierarchi-
cally by time. Stakeholder requirements use the notion of a scenario as a means of
establishing a framework in which meaningful dialogue can take place.
The scenario encourages the stakeholders to think about the job that they are
doing and how they would like to do it. In effect, they are rehearsing the way they
would like to do their job. Once the scenario is agreed, individual requirements
can be generated to deﬁne precisely what it is the stakeholders would like to be
able to do at each point in the scenario.
Scenarios provide an excellent method for exploring requirements with stake-
holders. They are inherently about what the stakeholders want to achieve. A scenario
is the sequence of results produced (or states achieved) through time for the stake-
holders. As shown in Fig. 5.3 a use scenario may be represented as a hierarchy of
goals and represents the capabilities provided by the system to the stakeholders–
without saying how to provide them. In other words the use scenario is a capability
hierarchy.
The time-orientation allows a rehearsal of what the system will provide and the
stakeholders can step through and see missing and overlapping elements. This
structure therefore avoids over-commitment to solutions while deﬁning the pro-
blem well.
There is a clearly deﬁned approach to follow when creating use scenarios. The
basic question to ask the stakeholder is “what do you want to achieve?” or “what
state do you want to be in?” The approach is then to start with the ﬁnal state and
then expand that, by asking what states, or intermediate steps, need to be attained
Final
goal
Operational sequence
Steps leading
to end goals
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Sub-goal
Fig. 5.3 Use scenario as a hierarchy of goals
119
5.4
Analyse & Model

on the way. The states are then explored as a tree or hierarchy. So the following
procedure emerges:
• Start with the end goal
• Derive the necessary capabilities to get to that point
• Break large steps into smaller steps
• Keep the set hierarchical
• Review informally at each stage
• Be wary of deﬁning solutions
If the stakeholder ﬁnds it difﬁcult to deﬁne the intermediate stages, the stake-
holder can be asked to describe a typical situation–it is important to know what
the stakeholder would do in a situation such as this. If the system is completely
new, they may need to use their imagination. They can postulate what they want
or expect to happen or achieve at each step. It is important at this point also to
identify if any stages are optional, or if there are any repetitions. Would different
conditions lead to different sequences?
The stakeholder also needs to identify the order of the capabilities and whether
this is ﬁxed or variable, and if it is variable, under what circumstances does it
vary. For example, before you can paint a picture you must have paper (or canvas
etc.), paints and brushes, but it does not matter which is ready ﬁrst. This gives the
opportunity to change sequencing or do things in parallel.
It is important, as in all forms of requirements capture, to accept everything
that the stakeholders say. It can always be reﬁned later. Frequently it will be
necessary to ask the stakeholders to expand on what they mean.
Scenarios represent the capabilities to be provided by the system (in problem
domain terms) organised into a hierarchy–without saying how to provide them.
They are seen to be beneﬁcial for the following reasons:
Enables stakeholders to step through operational use
Missing steps can be found
Different stakeholders can have different scenarios
Time constructs can be identiﬁed
5.4.2.1
Characteristics of Use Scenarios
Figure 5.4 contains an example scenario based on a day out with a sailing boat,
which can be transported on a car. It covers all the aspects of the trip starting with
loading the boat on to the car, getting ready to sail, sailing and returning home.
The scenario also illustrates some other points:
• Generally, it follows a time sequence
• Its nodes are high level capabilities
• It shows alternatives
• It shows periodic repeated behaviour
• It shows where sequence is not important (parallel branches)
• It shows exceptions
120
5
Requirements Engineering in the Problem Domain

The use of a time sequence is important. Not only does it provide a simple fra-
mework for the stakeholder to understand, but it also helps to place stakeholder
requirements into a context.
It is important that all the nodes are expressed as capabilities at the appropriate
level. Using the phrase “able to …” in the names of these nodes helps to avoid the
tendency to think of the capabilities as functions (and hence to move towards
implementation detail).
Scenarios provide a very powerful method of exploring exceptions. In many
systems, the functionality to handle exceptions is more complex than that needed
to provide the main stakeholder capabilities. The stakeholder can be prompted for
exceptions by asking questions such as “what can go wrong in this state?” or
“what can go wrong in reaching this state?” Recovery actions can be explored by
asking what should be done (or happen) if something does go wrong.
In the example of Fig. 5.4, it can be seen that the scenario includes the need to
communicate when the boat is capsized. In the absence of a scenario this require-
ment may not be spotted.
The example also illustrates how scenarios can make it easy to spot missing areas
of requirements. In this case the capabilities of being able to transport the loaded
boat (to the place where it will be sailed) and being able to launch are missing.
Boat lifted
Boat on car
Able to rig mast
parallel
Able to
manoeuvre
periodic
Able to
load boat
Able to
unload
boat
Able to
rig boat
sequential
Able to
survive
capsize
Able to 
go ashore
exception
alternate
alternate
Able to
get ready
to sail
Able to
sail
Able to
return
home
Able to right
capsize
Able to contact
Coast Guard
Able to rig rudder
Able to rig centre-plate
Able
to go
sailing
Able to gibe
Able to tack
Able to cruise
Able to
sail
normally
Fig. 5.4 Example use scenario
121
5.4
Analyse & Model

The purpose of creating a scenario is to promote understanding and communi-
cation. A scenario is not itself a requirement; it is rather a structure for elicitation
of requirements. It is an aid to ﬁnding a complete set of requirements, by covering
every aspect of operational use. Any one modelling technique does not attempt to
represent all possible concepts. There is no single correct way of modelling a
given operation. Different people come up with different models.
5.4.3
Scoping the System
When preparing the scenarios it is best to set the boundary a bit wider than the
anticipated system boundary. This ensures that the view taken is not “blinkered”
and serves to set the system in its context. At some point it is essential to deter-
mine where the boundary of the system is to be placed and hence to set its scope.
Once the complete set of scenarios has been assembled, the scope of the system
can be ﬁnalised. This decision may have to be changed, once the cost of developing
the system has been estimated. Such estimation can be made by people with experi-
ence of system development for the domain of the proposed system. Estimates
based purely on scenarios are very coarse and consequently must have a high degree
of uncertainty associated with them. Nevertheless making such an estimate can
serve to give an initial idea of whether the proposed budget is in the right ballpark.
5.5
Derive Requirements
The Derive Requirements & Qualiﬁcation strategy process has been split into two.
These two parts are handled in this section and the next.
The derive Requirements process is instantiated for the problem domain as
shown in Fig. 5.5. The key activities are to capture requirements and deﬁne a
structure into which to place them. Once the structure and the candidate require-
ments have been decided, it is possible to place the candidate requirements into
the structure. In practice the two activities go on in parallel and the structure
evolves as experience of using it develops. Therefore, instead of having a separate
activity to take the candidates and place them into the structure, Fig. 5.5 indicates
that both activities feed into the Reﬁne Requirements activity.
When the structure has been completed, the requirements and the structure can
be reviewed and reﬁned.
5.5.1
Deﬁne Structure
Structure is critical for handling all complex elements in the whole life cycle.
Stakeholder requirements are usually captured one by one, cleaned up and then
attached into the structure.
122
5
Requirements Engineering in the Problem Domain

Some approaches assume that:
Stakeholder requirements are inherently unstructured
Traceability to design is enough
A complete requirements model is never seen–requirements need be viewed only
one at a time
These approaches have nothing to do with quality, but are merely in the short-
term interests of the developer.
Requirements need to be organised, and there needs to be a good structure to
manage the individual requirements as they emerge. The arguments about struc-
ture and the need for it are the same for requirements engineering in both the
problem domain and the solution domain. Therefore they have been put together
in Chap. 4. In this chapter it is assumed that providing an understandable structure
is vitally important. It remains therefore to indicate how to derive a structure for
stakeholder requirements.
The main structuring concept for stakeholder requirements is the use scenario.
However, there can be many such scenarios, depending on the nature of the sys-
tem. It is recommended that time and effort is expended to try and merge scenarios
Statement of
Needs
Change
Request
DERIVE
REQUIREMENTS
Stakeholder
Requirements
Stakeholder
List
Useage
Model
Refine
Requirements
Change
Request
Candidate
Requirements
Capture
Requirements
Define
Structure
Structure
Fig. 5.5 Derive output requirements for problem domain
123
5.5
Derive Requirements

together to make, if possible, a single overall scenario. Obviously this will not
always be possible, but it is a good idea to attempt to do it. Apart from any other
results, it really makes people aware of the overall extent of the system and
frequently exposes many issues.
To explain the way in which scenarios can sometime be merged, an example
of running a restaurant will be taken. Three scenarios can be used to describe the
restaurant as follows:
• The overall life of the restaurant–Owner’s scenario
• A day in the life of the restaurant–Manager’s scenario
• A meal at the restaurant–Customer’s scenario
These are shown in Figs. 5.6–5.8.
The ﬁrst goal in the restaurant life scenario is that the owner acquires the
restaurant. This is followed by a period of operating the restaurant and ﬁnally the
restaurant is sold.
The restaurant day scenario considers the states that the restaurant is in during
the day. The ﬁrst goal is to replenish the stocks of food and drink. These aspects
of the scenario indicate that there will be several suppliers, but it does not matter
which order their deliveries arrive. It could be argued that the completion of
replenishment is not necessary before the restaurant is opened, but for the sake of
creating a reasonable example it has been decided that no deliveries will be
accepted whilst the restaurant is open to customers. The day scenario then has a
1 Acquired
2 Operating
3 Sold
Restaurant Life
Fig. 5.6 Restaurant life
scenario
1 Replenished
1.1 Food delivered
1.1.1 Meat delivered
1.1.2 Fish delivered
1.1.3 Vegetables delivered
1.1.4 Bread delivered
1.2 Drinks delivered
2 Open
3 Closed
4.1 Tables cleared
4.2 Washing-up complete
4.3 Waste bins ready
4.4 Replenishments listed
Restaurant Day
Fig. 5.7 Restaurant day scenario
124
5
Requirements Engineering in the Problem Domain

period of being open and ends the day closed with everything tidied up and the
replenishment needs recorded ready for the following day.
The customer meal scenario is a straightforward sequence of states.
Putting these scenarios together, it can be seen that:
• The restaurant day scenario can be a repeating scenario in the Operating state
of the restaurant life scenario, and
• The meal scenario can be a parallel repeating scenario in the Open state of the
restaurant day scenario.
Thus an overall structure for these three different stakeholder scenarios is
shown in Fig. 5.9.
This can then become the structure for the headings of the capabilities in the
requirements document.
Customer Meal
1 Table booked
3 Food served
2 Arrived and seated
4 Food eaten
5 Bill received
6 Bill paid
Fig. 5.8 Customer meal
scenario
2.1.1 Replenished
2.1.1.1 Food
delivered
2.1.1.1.1 Meat delivered
2.1.1.1.2 Fish delivered
2.1.1.1.3 Vegetables 
         delivered
2.1.1.1.4 Bread delivered
2.1.1.2 Drinks 
delivered
2.1.2
Open
2.1.3 Closed
2.1.3.1 Tables cleared
2.1.3.2 Washing-up complete
2.1.3.3 Waste bins ready
2.1.3.4 Replenishments listed
2.1 Restaurant
      Day
1 Acquired
2 Operating
3 Sold
Restaurant
Life
2.1.2.1 Customer
Meal
2.1.2.1.1 Table booked
2.1.2.1.3 Food served
2.1.2.1.2 Arrived and seated
2.1.2.1.4 Food eaten
2.1.2.1.5 Bill received
2.1.2.1.6 Bill paid
Fig. 5.9 Overall scenario and structure for restaurant capabilities
125
5.5
Derive Requirements

There are, of course circumstances when it is just not possible to ﬁt scenarios
together. There is no easy answer here. If all else fails then all the separate scenar-
ios can be used one after the other. Thus the structure of the Stakeholder require-
ments document will be a sequence of scenarios, each with their own requirements
embedded. Essentially the structure is driven from the list of stakeholders. Even in
this approach attempts should be made to nest one scenario inside another.
However, care must be exercised to ensure that there is no duplication. Where
there is duplication the duplicated parts must occur once. Two approaches can
be used. The ﬁrst entails cutting out the common items and putting them in a sepa-
rate section of their own. Then each occurrence must reference the separated section
at the appropriate point. The other approach is to place the duplicate section in the
ﬁrst scenario in the document and then reference this from all the other occurrences.
5.5.2
Capture Requirements
5.5.2.1
Sources of Stakeholder Requirements
Stakeholder requirements can come from a variety of sources as illustrated by the
following list:
• Interviews with stakeholders;
• Scenario exploration (generally through stakeholder interviews);
• Descriptive documentation (perhaps from studies or market research);
• Existing systems which are being upgraded;
• Problems and change suggestions from existing systems;
• Analogous systems;
• Prototyping, either partial systems, mock-ups, or even simple sketches, of the
product or the requirements themselves;
• Opportunities from new technology (approved by stakeholders);
• Studies;
• Questionnaires;
• Anthropomorphic studies or analysis of videos.
5.5.2.2
Stakeholder Interviews
To undertake this task, the requirements engineer must be a good communicator,
able to dig out real requirements from stakeholder interviews. It is an intense psycho-
logical task, with little in common with the technical or operational side of system
development. It is important to remember that extracting stakeholder requirements is
a human, not a technical problem and therefore preparing in advance is important so
that the world of the stakeholder is understood.
It is important to talk the stakeholder’s language about the stakeholder’s world,
not about the ﬁnal product or any technical issues. During the interview the
126
5
Requirements Engineering in the Problem Domain

stakeholder should be asked to step through the process of his/her work. A com-
prehensive set of notes should be taken, which later can be organised into a
structured set of requirements and returned to the stakeholder. Interviews are an
interactive process, it is important that the requirements engineer should not be
judgmental, but should repeatedly ask the question “Why?” There are several
ways of asking this question including: “What is the purpose of this …” or “Can
you give me more background on this …” Clearly the requirements engineer is not
expected to be an expert in the stakeholder’s domain and therefore will need clariﬁ-
cation at various points. Don’t worry about asking (apparently) stupid questions.
The only stupid question is the one that it not asked! It is important, however, that
ﬁnally the stakeholder will take the responsibility for the requirements.
Discuss scenarios with the people interviewed!
The following provides a set of tips for stakeholder interviews:
• Interview every type of stakeholder;
• Take them seriously;
• Document the interviews and invite stakeholders to sign the record of the interview
• Identify which scenarios are relevant to the stakeholder(s) being interviewed
and talk them through it (them) inviting the interviewee(s) to state what they
want to be able to do in each state of the scenario;
• If necessary create new scenarios as the discussion proceeds and then develop
requirements from them;
• Attempt to discover the relative importance to the stakeholder of each requirement;
• If the stakeholder is vague about any requirement ask ﬁrstly what is the pur-
pose of the requirement and secondly ask how the proposed requirement could
be demonstrated;
• Enquire about any constraints the stakeholder is aware of;
• Make stakeholders aware that their requirements will shape the system;
• Stimulate and provoke the stakeholders to respond;
• Don’t be judgmental about stakeholder requirements;
• Process the notes into single requirements quickly, and then iterate.
Generally, the questioning will proceed from the general to the speciﬁc. It is
important to be sure to cover all the ground, deﬁning which areas are irrelevant.
Experience in interviewing dictates the form of questioning that takes place,
depending on the stakeholder and the situation.
5.5.2.3
Extracting Requirements From Informal Documents
Informal documents such as letters, studies, action lists and other types of descrip-
tive material may all contain requirements hidden in the documentation. Such user
requirements should not remain hidden, but should be brought out into the open.
But in doing so it is important to record where the stakeholder requirements have
come from; in other words the source must be recorded. Further, requirements
extracted in this way must be “substantiated” by one of the stakeholders.
127
5.5
Derive Requirements

5.5.2.4
Identifying Capability Requirements From Scenarios
When an outline scenario has been developed, it is possible to postulate capability
requirements directly from them. Sometimes, a simple paraphrase of the state is
all that is required. For example, the state ready to sail can be paraphrased as the
capability the user shall be able to make the sailing boat ready to sail. In other
cases, more work is required. Figure 5.10 shows some examples, although not
very well formulated. Consider the requirement:
Two people shall be able to lift the boat onto the roof of the average saloon car
This raises the questions:
1. How strong are the people?
2. What is an “average saloon car”?
These questions must eventually be answered. However, the important thing
when gathering requirements is to write them down. It doesn’t matter if they are
not well formulated at ﬁrst–they can always be improved. The critical issue is not
to lose the idea! Misquoting a well-known proverb sums up this approach:
“A job worth doing is a job worth doing badly!”
More information on how to formulate requirements properly can be found in
Chap. 4.
Boat lifted
Boat on car
Able to rig mast
parallel
Able to
manoeuvre
periodic
Able to
load boat
Able to
unload
boat
Able to
rig boat
sequential
Able to
survive
capsize
Able to 
go ashore
exception
alternate
alternate
Able to
get ready
to sail
Able to
sail
Able to
return
home
Able to right
capsize
Able to contact
Coast Guard
Able to rig rudder
Able to rig centre-plate
Able
to go
sailing
Able to gibe
Able to tack
Able to cruise
Able to
sail
normally
Two people shall be able to
lift the boat into the roof of
the average saloon car
The sailor shall be able
to perform a gibe
The sailor shall be able
to contact the coastguard
Stakeholder
Requirements
Fig. 5.10 Deriving capabilities from scenarios
128
5
Requirements Engineering in the Problem Domain

5.5.2.5
Requirements Workshops
An alternative way of collecting stakeholder requirements is to hold requirements
workshops. This can be an excellent way of rapidly eliciting and capturing
requirements. It is important from the outset that the stakeholders are gathered in
an environment that is conducive, and that they realise that capturing requirements
is not hard and need not take a long time. There should be a structure to the work-
shop, but it should also be iterative. As shown in the Activity Diagram in
Fig. 5.11, stakeholders should be educated to understand what is expected of
them. For example, they need to understand the concepts of:
• Stakeholder
• Use scenarios
• Capability requirements
Present Stakeholders with a
requirements document or
Usage Model
Gather Stakeholders in a
conducive environment 
Conduct Requirements Workshop
Structure the meeting and
teach the subject
Encourage Stakeholders to
challenge the requirements in
an interactive fashion
Produce a new version of the
requirements and Usage Model
Rapidly process the
amendments
Requirements
Collected
Fig. 5.11 Workshops for requirements capture
129
5.5
Derive Requirements

Depending upon the starting point of the workshop, there may be an existing
set of requirements already in draft form. Alternatively, start by splitting the atten-
dees into teams and get them to create scenarios for the intended system. Then
review the set of scenarios generated with the full group. Make any required
changes to the scenarios and then move on to extracting requirements based
on them.
As soon as possible present the draft requirements to the full group and encou-
rage criticism and discussion. The possibility of interactions between the different
stakeholder groups adds signiﬁcant value to the requirements. Often this can be
the ﬁrst time that such a group has ever been together. It is always interesting and
satisfying when the interactions between the groups leads to the creation of
requirements that give a greater insight into what each group wants to be able to
do and how these capabilities ﬁt in with those of other groups.
These days with video projectors, the whole group can be involved with editing
the requirements online, but it can be more productive to split into smaller groups
to work on subsets for a period and then review the whole set together. In this
way, for a typical project, a set of requirements can be produced in 3–4 days.
The key element of a workshop is ﬁrstly to establish momentum and then to
keep it up. Running a workshop can be very demanding, but the results can be
very rewarding for all concerned.
It is vital that all stakeholder groups are represented and that they are empow-
ered to make decisions.
5.5.2.6
Requirements Learnt From Experience
Problems reported by real users of a system are gold dust–yet this information is
often thrown away. There is somehow a negative attitude to such information
because it is associated with a problem, but it can be of real value. Obviously the
earlier the problem is detected the less the cost of change, and allowing changes to
be made too easily kills a project. However in an iterative development, it is often
possible to postpone changes until the next pass through the system.
5.5.2.7
Requirements From Prototypes
Prototypes can be invaluable when creating unprecedented systems. They can be
used to give stakeholders an idea of what may be possible. They are also very
important in the development of software-based systems where the user interface
is difﬁcult to imagine. The problem with prototypes can be that the developers get
carried away and spend too much time and effort. Prototype development should
therefore always be treated as a small sub-project with its own stakeholder require-
ments. The objective of the prototype should always be clearly indicated and will
usually be to provide greater insight so that stakeholder requirements can be more
easily and accurately formulated.
130
5
Requirements Engineering in the Problem Domain

There are three problems with prototyping:
1. The developers get carried away and go into far too much detail
2. The prototype tends to cause stakeholders to stray into implementation
3. The stakeholders may be so impressed with the prototype that they want to use
it operationally.
The ﬁrst two problems can be countered by properly formulating the require-
ments for the prototype. To counter the third problem it is always important to
ensure that stakeholders are fully aware of the illusory nature of a prototype, since
a prototype can be a partial system, a mock-up, or even a set of simple sketches.
5.5.2.8
Constraints in the Stakeholder Requirements
A constraint is a type of requirement that does not add any capability to a system.
Instead it controls the way in which one or more capabilities are to be delivered.
For example, consider the following:
A customer shall be served within 15 minutes of placing the order.
This does not make the system different per se–it just quantiﬁes the service to
be provided.
Nevertheless, a word of caution is required here. A mass of constraints, each
one reasonable, can make a development impossible, therefore they have to be
analysed as a system as well as individually.
When the design is known, each constraint should be analysed for its cost/
beneﬁt value or impact upon the system. A constraint may bring a function into
existence, for example, a caution and warning system or a backup. The cost of a
constraint can only be guessed before the design is known. This unfortunately
depends on the design choice, but some minimum assumptions can be made–too
many unnecessary constraints can ruin a system.
By default, a constraint applies to the top capability and all its child capabilities
inherit it. The applicability should be pushed down the capability hierarchy as
much as possible (see Fig. 5.12) to limit its applicability and hence its cost impact.
Safety
Comfort
Availability
Ease-of-use
Running costs
Constraints
Capabilities
Applicability link
Fig. 5.12 Capabilities and constraints
131
5.5
Derive Requirements

When a constraint applies to just one capability, that constraint can be written as
part of the capability.
It is interesting to note the difference between stakeholder constraints and
system requirements constraints. Stakeholder constraints refer to the results that
the stakeholders want. System constraints are “professional” or engineering con-
straints that affect the quality of the product. All of the stakeholder constraints
must be addressed in the system requirements. Sometimes they must be reformu-
lated; sometimes they can be passed on without change.
5.5.2.9
Reﬁne Requirements
Review each requirement in its context and ensure that
1. It belongs in the place it is in.
2. It conforms to the criteria for well-written requirements as explained in Chap. 4.
5.5.2.10
Derive Qualiﬁcation Strategy
There are two sub-processes used to derive the qualiﬁcation strategy as shown in
Fig. 5.13. These are described in the following sub-sections.
Statement of
Needs
Change
Request
DERIVE
QUALIFICATION
STRATEGY
Stakeholder
Requirements
Stakeholder
List
Useage
Model
Change
Request
Define
Acceptance
Criteria
Define
Qualification
Strategy
Qualification
Strategy for
Stakeholder
Requirements
Fig. 5.13 Processes to derive the qualiﬁcation strategy
132
5
Requirements Engineering in the Problem Domain

5.5.3
Deﬁne Acceptance Criteria
Understanding the criteria that will satisfy the stakeholders that a requirement has
been met is an essential and vital part of gathering requirements. Asking the
question:
What will convince you that this requirement has been satisﬁed?
can often lead to a clearer and more focussed formulation of a requirement. This
question is therefore often used during stakeholder interviews. The question can
be answered in two ways:
1. Stakeholders may deﬁne an operational situation in which the requirement can
be demonstrated and/or
2. Stakeholders may deﬁne a numerical value for a level of achievement that
must be demonstrated.
The ﬁrst type of answer feeds directly into the process of creating a set of tests,
trials or demonstrations that must be part of the qualiﬁcation strategy. The second
type of answer indicates the “pass mark” for a trial test or demonstration, i.e. it
indicates the acceptance criterion for the requirement.
Acceptance criteria deﬁne, for each requirement, what would be a successful
outcome from the qualiﬁcation approach adopted. Acceptance criteria are usually
recorded in an attribute associated with the requirement. In other words there is
usually a one-to-one relationship between a requirement and its acceptance criter-
ion. In the example of the restaurant, the acceptance criterion for the running of
the restaurant may be that it is “successful.” Success can be measured in a number
of ways e.g.:
1. Proﬁtability
2. Return on investment
3. Reputation as indicated in guidebooks, newspaper articles etc.
4. Forward load in terms of how far ahead is the restaurant fully booked
Different stakeholders may well have differing ideas about success, for exam-
ple, the owner’s bank manager will be more interested in the ﬁrst two, but the
chef will certainly be more interested in the last two.
Thus it is important to determine the acceptance criteria for any requirement
from all the stakeholders who may have an opinion.
5.5.4
Deﬁne Qualiﬁcation Strategy
The way in which acceptability is demonstrated depends to a very large extent on
the nature of the system and the way in which it has been acquired. For large one-
off systems such as air trafﬁc control, it will be necessary to make sure that all the
functionality has been properly provided and that the controllers are happy that
133
5.5
Derive Requirements

the system can used easily and quickly when they are busy. This will require a
mixture of tests and trials. Firstly the capability of the system under light loading
must be demonstrated. If this capability is not acceptable then there is no point in
progressing to tests that involve much more investment such as live trials at a
busy time of day.
The cost of the qualiﬁcation strategy must also be borne in mind. Mounting
extensive trials is a very costly business and so there must always be a gradual
build-up. For example, most ships will undergo harbour trials before sea trials.
The overall cost must also be taken into consideration, but this must be set
against the risk of failing to discover a signiﬁcant ﬂaw in the system during opera-
tional use. Thus, where there is a large safety, environmental or ﬁnancial risk, the
qualiﬁcation strategy must be very carefully engineered to ensure a gradual but
steady build-up of conﬁdence in the system. On the other hand, where the conse-
quences of malfunction are quite light, a less expensive approach can be underta-
ken. The bottom line is that a requirement that cannot be demonstrated (in some
way) is not a requirement. Properly engineered requirements are requirements that
are easy to understand and demonstrate.
5.6
Summary
Stakeholder requirements must be kept as small as possible and easy to under-
stand. The stakeholder requirements must be non-technical and at the same time
realistic. There must be a focus on roles and responsibilities, and it is important to
properly distinguish between stakeholder groups.
The common problems that can occur, when deriving stakeholder requirements,
are:
• Over-emphasis on solutions;
• Under-emphasis on deﬁning the real problems to be solved;
• Failure to understand that stakeholders must own and approve these requirements.
Stakeholder requirements should be built as quickly as possible, they deﬁne the
capabilities that the stakeholders require, expressed in terms with which they are
comfortable and familiar. There should therefore be a concentration on the stake-
holder domain, not on system solutions. They should be structured and traceable
to the source of the information. Stakeholder requirements are owned by stake-
holders, scoped by the budget holder and often written by requirement engineering
specialists
134
5
Requirements Engineering in the Problem Domain

Chapter 6
Requirements Engineering in the Solution
Domain
Never tell people how to do things. Tell them
what to do, and they will surprise you with their ingenuity.
George Smith Patton, general, 1885–1945 AD
6.1
What is the Solution Domain
The solution domain is the domain in which engineers use their ingenuity to solve
problems. The primary characteristic that differentiates the solution domain from
the problem domain is that, invariably requirements engineering in the solution
domain starts with a given set of requirements. In the problem domain require-
ments engineering starts with a vague objective or wish list. The extent to which
the input requirements for the solution domain are “well formed” depends upon
the quality of the people within the customer organisation that developed them. In
an ideal world, all the requirements would be clearly articulated, individual test
able requirements.
As indicated in Chap. 2, the solution is very rarely arrived it in a single step
(see Fig. 6.1).
At each level there is modelling and analysis done to ﬁrstly understand the
input requirements and secondly to provide a sound basis for deriving the require-
ments for the next level down. The number of levels of design is dictated by the
nature of the application domain and the degree of innovation involved in the
development. No matter how many levels are necessary it is always vital to under-
stand how many solution details—the “how”—should be introduced at each step.
At every level in the solution domain, engineers must make decisions that
move towards the ﬁnal solution. Each of these decisions, by their very nature
reduces the available design space, i.e. they preclude certain design options, but it
is impossible to make progress in the absence of decisions. Engineers are always
135
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_6

very strongly tempted to go into too much detail too soon. This temptation must
be avoided, in order to allow creativity and ingenuity to work together to produce
innovative solutions that could never be achieved in the presence of the constraints
imposed by premature design decisions.
Typically the ﬁrst level of system development in the solution domain is to
transform the stakeholder requirements into a set of system requirements. These
must deﬁne what the system must do in order to solve the problems posed by the
stakeholder requirements. This ﬁrst level is illustrated by the top instantiation of
the generic process in Fig. 6.1.
The issue of premature design detail is especially problematic at the ﬁrst step.
It is here that the discipline of remaining design agnostic comes into play. One
should try to treat the system as a “black box” (see Chap. 1), and talk initially
about its externally observable behaviour.
The System Model indicated in Fig. 6.1 must be created at a level of abstrac-
tion that enables the functionality of the system to be deﬁned without going into
unnecessary detail.
The next step on from deﬁning the system requirements is to create an architec-
tural design as indicated by the second instantiation of the generic process in
Fig. 6.1. This must be expressed in terms of a set of components that interact to
generate the emergent properties identiﬁed by the system requirements. The
derived requirements from the architectural design process (Fig. 6.1) deﬁne the
requirements that the component suppliers must satisfy for each component. At
each stage, the architectural design permits the black box to be opened up reveal
the subsystems as black boxes inside.
Stakeholder
Define System
Requirements
Create
Architectural
Design
Create
Subsystem
Architecture
Requirements
System
Requirements
Engineer
Requirements
Engineer
Requirements
Repeat for each Subsystem/Component
Subsystem Design
Architecture
Subsystem
Architecture
Model
&
Analysis Results
System Architecture
Model
&
Analysis Results
Subsystem/
Component
Requirements
Engineer
Requirements
Solution Domain
Abstract Model
System Model
&
Analysis Results
System Design
Architecture
Fig. 6.1 Possible instantiations of the generic process
136
6
Requirements Engineering in the Solution Domain

Development proceeds by further levels of design that move further towards
implementation detail.
This chapter concentrates on the transformation from stakeholder requirements
to system requirements because it is the most problematic in most developments,
because typically too much detail is added too soon.
6.2
Engineering Requirements From Stakeholder
Requirements to System Requirements
The full instantiation of the generic model for this transformation is shown in
Fig. 6.2.
As with all instantiations, the process commences by agreeing the input
requirements, which, in this case, are the stakeholder requirements. The agreement
process must not assume that the input requirements have been produced accord-
ing to the guidelines given earlier in this book. Instead, it is necessary to consider
the requirements and the associated qualiﬁcation strategy on their merits and apply
the review criteria for stakeholder requirements with rigour and thoroughness.
6.2.1
Producing the System Model
To avoid the tendency to go into too much detail, engineers should always work
in the context of a model (see Fig. 6.1) that is sufﬁciently detailed for the purpose
of deﬁning requirements in terms of what should be done rather than how. The
level of detail that should be provided in derived requirements depends upon the
level of development at which requirements engineering is being done, but the
maxim is always “do not add more detail than is necessary.”
The temptation to go into detail is always greatest at the top level where
Stakeholder requirements expressed in problem domain terms are being translated
into high level system requirements that indicate what the system must do to solve
the problems posed by the Stakeholders. The difﬁculty arises because of the need
to work at an abstract level. The creation of an abstract system model, which will
provide the framework for the system requirements, always causes problems. At
the whole system level, the system should still be treated as a block box.
Subsystems will only appear once the system architecture is deﬁned.
At all levels below this, development work progresses in the context of a
design architecture. Engineers are much more comfortable with this level of detail,
because they can get involved with determining how the system will work. Even
at these levels, care must be exercised to ensure that the amount of detail imposed
is appropriate. Consequently, the architecture models should be expressed in terms
of components that work together, but care should be taken to ensure that compo-
nents are deﬁned in terms of what they are required to do rather than how they
137
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

should achieve it. In other words components should be speciﬁed as “black boxes”
whose internal details are of no concern provided that they achieve their overall
purpose as deﬁned in the requirements.
The next sections of this chapter concentrate on the preparation of system mod-
els for the derivation of system requirements. Following this, the ways in which
the same approach is applied at more detailed levels is explained.
Change Request
Change 
Request
Stakeholder
Requirements
Qualification
Strategy for
Stakeholder
Requirements
Qualification
Strategy for System
Requirements
Change Request
Derive
Requirements
and Qualification
Strategy
Agree
Requirements
System
Requirements
Change
Request
Change
Request
System
Models
Analysis
Results
Analyse and
Model
Agree
Requirements
SYSTEM
REQUIREMENTS
PROCESS
Fig. 6.2 Instantiation of generic process to create system requirements
138
6
Requirements Engineering in the Solution Domain

6.2.2
Creating System Models to Derive System Requirements
The system model must be created at an appropriate level of abstraction such that
it encompasses:
• Internal functionality that the system must exhibit; this must concentrate on
what the system must do rather than on how it should be done to avoid pre-
empting the design;
• Functionality necessary to enable the system to interact with other systems in
its environment;
• Functionality necessary to enable people to successfully interact with it;
• Functionality to prevent the system from malfunctioning due to the presence of
other systems (threats) in its environment. (Note that some of these systems
may not be deliberately threatening, e.g. electromagnetic emissions from neigh-
bouring equipment.)
This “safeguard” functionality must also prevent the system from interfering in
an adverse way with the environment.
The way in which these types of functionality interact with each other and with
elements in the system’s environment is expressed diagrammatically in Fig. 6.3.
It is clear that the context of the system within its environment must be deﬁned
with respect to:
• the existing systems with which the new system is required to co-operate,
• the types of people who are intended to interact with the system,
• the threats that the system must defend against and
• the adverse effects that must be prevented.
The functionality can be represented in a number of ways, for example,
• Operations or methods on classes in class diagrams
• Message sequence charts
• State transition diagrams
• Function Flow Block Diagrams
• Processes in data ﬂow diagrams
External
Co-operating
Systems
Interface
Functionality
External
Threatening
Systems
Internal
Functionality
Human
Interaction
Functionality
Safeguard
Functionality
People
Fig. 6.3 System context and types of functionality
139
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

In practice it will be necessary to use several models in order to cover the
many different aspects required. Each model contains information of a deﬁned set
of types and each modelling technique carries its own semantics. The information
for some models may be quite separate from information in other models. On the
other hand the same information may appear in more than one model. In the latter
case it is essential that, when information is changed, the change is reﬂected in all
other models in which that information occurs. Ideally this would be achieved
automatically by linking the modelling tools. If this is not the case then extreme
care should be exercised to ensure that any change is applied identically in all rele-
vant models. The Venn diagram in Fig. 6.4 indicates that some models represent
islands of information whereas others may have common information presented in
different forms. Figure 6.4 also indicates that there may be some system informa-
tion that is not present in any model.
6.2.2.1
Internal Functionality
This is the primary element of the creation of the system requirements, because it
is the main focus of deﬁning what the system will do. It is necessary to create a
structure or model that can be the basis for creating the system requirements. This
model must have the capability to express some form of decomposition of the sys-
tem into modules or high-level components such as subsystems. The use of terms
such as “module” or “component” tends to make developers think more in terms
of implementation rather than speciﬁcation. This is generally considered to be bad
practice, especially in software-based systems. In general systems, the need to
move to a more physical model is not considered to be particularly problematic,
since the application domain will generally be of a more physical nature.
As an alternative to terminology that may induce premature implementation,
there is an increasing tendency (some would say “fashion”) to use the term
“object” as the decomposition element, especially for software-based systems,
since objects can refer to items in the problem domain. This discipline helps to
prevent the premature descent into solution terms. Functionality can then be intro-
duced as methods or operations on objects and as interactions between objects.
Model A
Model E
Model D
Model C
Model B
System
information
domain
Fig. 6.4 Scope of system models
140
6
Requirements Engineering in the Solution Domain

The use of this object-oriented approach can also make the creation of trace-
ability from the system requirements to the stakeholder requirements an easier
task, because the same objects tend to be visible in both the problem domain and
the solution domain.
In addition to stating what the system must do, the system model may also be
required to indicate the intended behaviour of the system. There are a number of
ways in which to represent this type of information. Models in this area usually
represent the fact there are a number of concurrently active “actors” that interact
in some way. Examples of this sort of notation are message sequence charts and
behaviour diagrams. Message sequence charts have long been used in the telecom-
munications industry. Behaviour diagrams originated in the US ballistic missile
early warning system (BMEWS) in the 1970s and have been implemented in tools
such as RDD-100 from Ascent Logic Corporation and CORE from Vitech
Corporation.
Behaviour can also be modelled using state transition diagrams or state charts.
State transition diagrams have the limitation that they can only model a sequence
of states and the item being modelled can only be in one of these states at any one
time. State transition diagrams cannot represent hierarchical states directly.
Separate diagrams must be used for each level in the hierarchy and, in some cases
this means that there may be a set of active diagrams at certain times. Such sets of
diagrams can be difﬁcult to understand. To avoid this complexity it is better to use
state charts because they have been developed to directly handle state hierarchies.
They also address parallel states.
In any system it is necessary to consider whether there is information to be
handled. Some systems, e.g. insurance company systems, require that information
must be gathered and retained for use over a number of years. In other systems,
e.g. radar data processing systems for air trafﬁc control, there is some information
that has a long lifetime, e.g. ﬂight plans, whereas the current position of an aircraft
in ﬂight, by its very nature, soon gets out of date. Thus the information require-
ments must be examined to ascertain:
• The longevity of the information—i.e. for how long is the information relevant,
and for how long must it be retained?
• The freshness of the information—i.e. how up to date must it be (seconds, min-
utes or hours)?
It is also very relevant to know the amount of information that may be
involved. This can have a profound effect on the design of the system.
6.2.2.2
Interface Functionality
It is necessary to deﬁne the nature of the interactions required with any other sys-
tem. Interactions may involve the movement of information, or material between
the systems. The movement may be in one direction or both, and there may be
limits on the capability that can be transferred. It may be necessary to provide
141
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

temporary storage (e.g. data buffer or warehouse) for items that are held up. There
may be time response requirements on the speed with which either system must
react to a stimulus from the other.
The nature of interfaces varies signiﬁcantly. However, there must always be a
baseline reference that indicates what each party undertakes to do or provide as
part of the interface. These obligations are frequently documented in an Interface
Control Document (ICD). Where the interactions are controlled by national or
international standards, the standard becomes the interface control document to
which all relevant parties can work. Where the interface is less well deﬁned, the
obligations (i.e. interface requirements) must still be written down and agreed.
Control of these requirements is notoriously difﬁcult because there is often no
organisation with a clear mandate to control the interface. Consequently each party
to the interface tends to have its own version of the document and, worse, each
party tends to have its own interpretation of it.
It is usual for interface documents to be controlled by the organisation that has
responsibility for the system that encompasses the two (or more) systems that
interact. Such an organisation is quite difﬁcult to deﬁne when a new system is
being developed. Often the existing system(s) will have been developed earlier
and the interfaces may not be properly documented. Further, the development
organisation may well no longer have any responsibility for that system, having
handed it over to a higher-level customer or other operating authority.
Care must be exercised to ensure that all interface obligations are accurately
reﬂected in derived requirements at the appropriate level and, so far as is possible,
the interface control authority is clearly deﬁned.
6.2.2.3
Human Interaction Functionality
The crucial issue for human interactions with a system is to know what interac-
tions are going to be required. The context in which the users will work is also
important. This can have an impact on the way they can work. For example, users
working in a standard ofﬁce environment will be warm and able to work conveni-
ently without gloves. Other users may have to operate the system in harsh environ-
ments such as extreme cold weather, or hazardous situations where protective
clothing will be necessary. In these circumstances the design of the displays and
keyboards must take note of these aspects.
6.2.2.4
Safeguard Functionality
The environment in which a system must operate will also have a signiﬁcant inﬂu-
ence especially with respect to safety and security. For example, in a banking sys-
tem it is necessary to provide assurance that information and money will not be
given to unauthorised people. In a car (system) it is necessary to be assured that
the car will stop when the brake pedal is operated.
142
6
Requirements Engineering in the Solution Domain

There may also be other systems operating in the environment of the system
that may be competing with the system being developed. This competition could
be commercial competition as in online banking for example. Here the need for
any system to be evolved rapidly can be of prime importance.
Other “competing” systems include those that could interfere with the correct
operation of a system by, for example, making radio transmissions that confuse
the system or overload sensitive receivers. An example of this is the worry that
the use of mobile telephones on board aircraft in ﬂight could interfere with the air-
craft’s navigation systems.
6.2.2.5
System Transactions
It is worthwhile re-visiting the use scenarios that were developed for the system
from the stakeholders, or if none exist to create a set of relevant scenarios. These
can be applied to the system model(s) to make sure that they are possible within
the system being speciﬁed (see Fig. 6.5). Working through these “system transac-
tions” provides reassurance that elements of system functionality have not been
lost by a blinkered approach to object modelling or functional decomposition.
(Note that this use of the term “system transaction” is different to the use of the
term within the CORE method described in Chap. 3.)
The system transactions shown in Fig. 6.5 as User System Transactions are
those derived from the use scenarios. Figure 6.5 also indicates that there can be
other transaction derived from the way in which the system being developed must
interact with external systems.
System transactions encourage system engineers to stand back and take a “hol-
istic” view of the system. It is all too easy to concentrate on the detail and forget
External
Co-operating
Systems
Interface
Functionality
External
Threatening
Systems
Internal
Functionality
Human
Interaction
Functionality
Safeguard
Functionality
External
System
Transactions
User
System
Transactions
People
Fig. 6.5 System transactions
143
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

the big picture i.e. how do the detailed parts work together to achieve the overall
aim?
6.2.2.6
Modes of Operation
Different functionality may be required in some circumstances. A typical example
for information-based systems is the need to be able to provide training for staff
without compromising the integrity of the data held in the system. Other examples
include fall-back modes of operation following a failure or, in military systems,
different modes depending on the current state of alertness. These may be related
to the use scenarios in the stakeholder requirements.
6.2.2.7
Additional Constraints
In addition to the constraints already mentioned, there are additional aspects that
should be considered. Perhaps the most important are those concerned with safety
and certiﬁability. In these areas additional requirements can be introduced and
these will certainly have a strong inﬂuence on the means adopted for qualiﬁcation.
The relevant authorities will have to be convinced that a system is safe to use or
to be deployed, or, in the case of an aircraft, that it can be given a certiﬁcate of
airworthiness.
A further set of additional constraints are introduced by the need to manufac-
ture the system. It may be necessary to use an existing facility or the design may
have to be changed in order to reduce the cost of manufacturing.
6.2.3
Banking Example
In this example of a management information system, the primary concern will be
to model the information that must be handled, but it is quite clear that there are
many other areas that should be addressed. Several system models are therefore
likely to be used, one focussing on the information, others focussing on the ﬂow
and security of information.
Figure 6.6 shows a model that provides an alternative abstraction for the bank
example. It identiﬁes the types of locations where equipment might be sited and
thus from where transactions may be initiated.
6.2.3.1
Internal Functionality
The primary internal functionality is concerned with supporting the services pro-
vided by the bank such as current accounts, deposit accounts, loans and
144
6
Requirements Engineering in the Solution Domain

investment portfolios. To support these services the system must be able to collect,
update and retain information. Of vital importance here are the types (or classes)
of information (e.g. accounts, customers etc.), the relationships that exist between
them (e.g. how many accounts is a customer allowed to have?) and the longevity,
freshness and volume of each type.
It is important to determine how information is collected, disseminated and
manipulated.
A further important aspect of a banking system is the number and location of
sources of information and/or transactions. These will include branches, automatic
teller machines and credit card point of sale machines.
From a performance point of view it is important to understand the likely load-
ing that the system must be able to cope with, such as the number and mix of
transaction types. This will clearly vary from day to day and from hour to hour
within each day. There may be constraints imposed by existing infrastructure such
as landlines or other communication mechanisms.
6.2.3.2
Interface Functionality
The primary interfaces for this type of system are to other banks for funds trans-
fers and use of their teller machines.
Manage
Accounts
Manage
Investments
Manage
Loans
Services
Provided
Teller
Machines
PCs/Terminals
Branch Office
Teller
Machines
Other Banks
Teller
Machines
Credit Card
Point of Sale
Machines
Retail Outlets
Teller
Machines
Inter-bank
services
Cheque
clearing
Fig. 6.6 An abstract model for the bank example
145
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

Banks also have existing systems for clearing cheques, etc. that are jointly cre-
ated amongst several banks.
It is highly likely that a banking system will make use of telecommunications
services from external providers.
6.2.3.3
Human Interaction Functionality
Information systems generally have to cope with a wide variety of user types. For
a bank the following list covers many of them:
General public—must be able to use automatic teller machines and, increasingly,
online facilities via the web without any prior training—i.e. the user interfaces
must be intuitive.
Counter staff—must be able to use the system quickly in order to provide a fast
and efﬁcient service to customers queuing up. These counter staff will require
training and the most important aspect of this type of interface is that it should
be “slick” when the staff have been trained.
Managers at various levels—some managers may not be quite as computer lit-
erate as the counter staff (although, of course, some may have been promoted
after becoming proﬁcient as counter clerks). The facilities to be provided for
the managers may include some of the counter staff facilities, but will include
more summary types of information derived from looking at a wider set of
information than a single account. These may include statement summaries,
branch or area business summaries etc. Note that these types of information
demand that information is retained over a period of time so that trends and
other historical information can be deduced and/or presented.
Policy makers and marketing staff—require quite different capabilities, perhaps
introducing the capability to start new business products.
System maintainers—must be able to update system facilities. Ideally they should
be able to do this while the system is fully operational, but in practice they may
take down all or part of the system (usually for a brief period in the middle of
the night) in order to guarantee integrity of data.
6.2.3.4
Safeguard Functionality
Security in banking systems is of paramount importance. The key element is the
need to protect the integrity of the information that is at the heart of the business.
Obvious mechanisms used include the personal identiﬁcation numbers (PINs)
on credit or debit cards and encryption for transfers between branches, teller
machines etc.
Other areas that must be considered are the need to keep the systems working
in the presence of computer faults, power failures or communication failures.
These categories of functionality are related to the perception of risk. The degree
146
6
Requirements Engineering in the Solution Domain

of protection that can be afforded to mitigate the risks depends critically on the
exposure that is perceived.
Finally and most importantly, it is necessary to consider threats from hackers,
embezzlers or others with fraudulent intent. The software must provide adequate
protection to safeguard the bank and its customers from these threats.
6.2.3.5
System Transactions
Each type of user is likely to be a Stakeholder in this category of system.
Therefore it is likely that there will be a set of use scenarios for each type of user.
For the bank customers these include regularly used facilities such as withdrawals,
deposits and transfers whether made in person or done automatically as direct deb-
its, salary payments etc. There will also be other transactions used less frequently
such as negotiating a personal loan or a mortgage.
For each type of user it is worthwhile considering the load that will be
imposed, so that the response time can be estimated. Of course this will not be a
ﬁxed time, but will depend upon the current loading and this, in turn, will depend
upon the time of day and day of the week.
Increasing use of web based facilities must add a further dimension to load
prediction.
6.2.3.6
Modes of Operation
The predominant mode of operation will be the normal mode. However, there
may be additional modes to cover training, backup and recovery operations and
system evolution.
6.2.4
Car Example
The second example addresses a more physical type of system, but it is interesting
to see that the same categories of information are still present, although in an
entirely different form.
The big issue in this example is whether the system model is a physical model
and to what extent it can become abstract. It is unlikely that a new car is going to
be radically different in architecture from previous models—it will still have a
wheel at each corner, an engine, a gearbox, suspension, a windscreen, etc. For this
reason, the system model for a car may well make reference directly to the physi-
cal objects of the architecture as indicated in Fig. 6.7. The arrows on this diagram
indicate some inﬂuence, as labelled, in the direction of the arrow. The driver
presses the brake pedal and the brake pedal activates the brakes. The connections
between the body and the parts fastened to it are shown as UML constituent
147
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

association (black diamond), to indicate that there is a dependency in both direc-
tions, e.g. the engine is fastened to the body and the body has mountings to take
the engine.
However, where aspects of the new car are likely to be rather different—such
as in an electronic vehicle control system—remaining more abstract will present
advantages in determining the best solution. To the extent that the functionality of
a car is quite well understood, what is required is to quantify the functionality. For
example, it is clear that a car must be able to move people and their luggage or
other items from one place to another. The key questions that should have been
addressed in the Stakeholder Requirements are:
• How many people?
• How much luggage?
• How comfortable will the car be?
• How fast will the car travel?
• How quickly will the car accelerate?
• How much will it cost?
• What information will be provided to the driver?
• What in-car entertainment facilities will be provided?
«block»
Accelerator
«block»
Engine
Passenger
«block»
Alarm System
«block»
Gearbox
«block»
Transmission
locks
«block»
Body
«block»
Wheels
«block»
Entertainment
System
«block»
Seat
«block»
Suspension
mounted on
mounted on
mounted on
occupies
Occupant
operates
«block»
Brakes
«block»
Door
enters
through
powers
powers
slow
«block»
Gear Lever
presses
presses
Driver
informs
activates
selects gear
«block»
Brake Pedal
powers
adjusts throttle
deactivates
«block»
Driver Information
System
Fig. 6.7 An abstract model for a car based on physical objects
148
6
Requirements Engineering in the Solution Domain

• What safety features will be necessary?
• Where will the car be used?
6.2.4.1
Internal Functionality
The key requirements that must be addressed at the functional level include:
The acceleration rate of the car. This requires a balance between the engine
power, the overall weight of the car, the wind resistance of the body and the
drag induced by the wheels.
The range of the car. This requires a balance between the fuel efﬁciency of the
engine, the fuel capacity, whether a manual or automatic gearbox is used, and
the way in which the car is driven.
The comfort level of the car. This will inﬂuence cost and weight of the car plus
people of different stature may perceive the end-result differently.
Note that these key aspects are not independent. This is typical in a systems
engineering situation. It is these interactions that tend to move the model to a
more abstract level. For example, the above factors will be quite different depend-
ing upon the type of engine and fuel used. Fuel types include: petroleum, diesel
and liquid propane gas (LPG). The fuel efﬁciency and weight of engine, fuel and
fuel tank are quite different in all three cases. Consequently it is necessary to
determine:
• Whether to make a selection at all at this point, or
• Whether to keep all options open, or
• Whether to provide a customer selectable option for one, two or three of these
types.
The nature of the design will be signiﬁcantly affected by the decision(s) that
are taken. It may be that multiple options are evaluated, each more detailed than
the overall model. Alternatively some options, for example LPG fuel, could be
eliminated right at the start.
6.2.4.2
Interface Functionality
One might expect that a car is going to be isolated in terms of its need to interface
with other systems. Increasingly this is not the case. One trivial example is that a
car will usually have a radio receiver and this entails conforming to certain stan-
dards of demodulation in order to decode the transmitted signals.
As sophistication increases so there are wider sets of standards that must be
conformed to. For example cars that have GPS navigation must understand how to
receive and decode the satellite signals on which this system depends. Cars that
can provide trafﬁc information to drivers must be able to interface with the
149
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

relevant information providers. In future, it is possible to envisage that the naviga-
tion system may well be inﬂuenced by the trafﬁc information and hence a further
(internal) interface will be introduced.
For modern cars, the way in which they are serviced is an important considera-
tion. Frequently cars are required to retain information about events during their
operational use so that the service technician can access it to aid in diagnosing
problems or to guide him to check or change relevant items that are either faulty
or nearing the end of their useful life. This is an example of a test system that is
partly installed in the operational system (i.e. the car) and partly installed in the
garage where the maintenance operations are undertaken.
6.2.4.3
Human Interaction Functionality
Many aspects of the “user interface” of the car are set by conventions that have
evolved over the years. For example, the relative positions of the foot pedals
(accelerator on the right, brake to the left and, if present, clutch to the left of that)
are identical all over the world.
Other aspects such as left-hand or right-hand drive and position of indicators
and windscreen wipers have local conventions in different geographical areas.
On the other hand for entertainment systems, navigation systems and other less
common systems there is, as yet, no agreed conventions and therefore the
designers are free to provide an interface of their choice. As with most electronic
systems, there is a need to make the interface easy to use (or even possible to use)
for anybody who needs to use it. This is quite a challenge, because the only expla-
nation that can be provided is a user guide. It is not possible to send drivers and
passengers on training courses and it is not appropriate to make any assumptions
about the educational level or experience of those who may need to use it.
6.2.4.4
Safeguard Functionality
The primary safeguard functionality in cars is to ensure the safety of the car and
its occupants. A further, increasingly important area of functionality is the preven-
tion of theft.
Safety functionality starts with the braking system. It is essential that effective
braking is available to the driver at all times. Dual circuit hydraulic brakes that
provide redundancy such that braking is still provided after any single hydraulic
failure is one way of providing this. The system model could include the imple-
mentation directly; alternatively the model could just include the need for braking.
In the latter case, the fact that braking must still be available in the event of a sin-
gle hydraulic failure must be added outside of the model.
Note that this discussion has tacitly assumed that braking will be effected using
hydraulics! Some aspects of detailed design can be included especially where there
is a well-established precedent, or the decision can be taken in response to a
150
6
Requirements Engineering in the Solution Domain

business objective introduced into the input requirements by the developer
organisation.
Other areas of safety include ABS braking and the provision of air bags to
cushion the impact of a collision. Again these can either be explicitly included in
the model, or the designer can be given freedom to invent alternative solutions.
The starting point for security is the provision of locks on doors. This can be
enhanced by the provision of an alarm system and engine immobiliser. The limit-
ing factor here is the cost of introducing the extra functionality and the amount
that a customer is prepared to pay for it. However, there are other factors such as
the facilities provided by competing cars and the attitude of insurance companies.
Both have a strong inﬂuence not only on the functionality that must be provided,
but also on the way its inclusion is justiﬁed.
6.2.4.5
System Transactions
There are many possible transactions for a car. All are based on journeys but with
speciﬁc objectives or characteristics, for example:
• Driver, shopping trip in town—leave parking bay, travel, park, secure vehicle,
unlock vehicle, load vehicle, leave parking bay, travel, park, unload, secure
vehicle.
• Driver, motorway trip.
• Driver, airport trip (with luggage).
• Driver, trip with accident.
• Passenger—get in, ﬁt belt, travel, undo belt, get out.
• Garage technician—repeatedly service, with major/minor intervals.
• Owner—buy, depreciate, sell/dispose.
• Salesman—repeatedly attempt to sell, ended by selling, warranty period.
Each of these may add new requirements such as luggage capacity or mainte-
nance facilities.
Therefore it is important to consider them all and understand how the implied
requirements of each are addressed. Of course this does not mean that all of them
will be satisﬁed. It may be that some are rejected because they are too expensive
or are not considered to be relevant for the market being considered. Alternatively
the transactions may cause different models to be created for different markets.
6.2.4.6
Modes of Operation
One could imagine a car in which the prevailing terrain could inﬂuence the way in
which the car operates. For example in mountainous terrain, the gearbox could
automatically select lower ratios and the engine management system would take
into account the amount of oxygen in the air and consequently alter the mixture of
151
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

petrol and air to take account of this. Alternatively, these could be options that
could be selected either at the time of purchase or when driving.
A further important mode of operation is the maintenance mode, in which the
engine management system is downloading the collected information for analysis
by the maintenance system and technician.
A more extreme mode could be to join a motorway “train” composed of a set
of cars all travelling at the same speed with minimal spacing. The cars would then
be controlled as a group and local driving facilities would be disabled.
6.2.5
Deriving Requirements From a System Model
6.2.5.1
Create a Document Structure for the Requirements
As indicated earlier, the system model may be composed of many independent
and potentially overlapping models. It is possible to start deriving requirements
from any of these models as has already been alluded to in the previous sections
covering the banking and car examples. However, the challenge is to ﬁnd a struc-
ture into which all of these derived requirements can be placed such that every
requirement has an obvious place in that structure and that any empty sections are
empty by design rather than by accident. The structure is referred to as a “docu-
ment structure” in Chap. 4.
It is recommended that one of the models be chosen as the primary source for
generating the document structure. The model selected should be the one with the
widest scope, since the system requirements must cover the complete system and
not one small area. In practice the decision is usually obvious. For data oriented
systems such as the banking example, the data model is often the best focus, since
every function is concerned, to some extent, with establishing, disseminating,
updating or safeguarding the data. For more physical systems such as the car
example, it is often best to use a model derived from the physical structure of the
system (assuming one exists), because most of the requirements refer to one or
more of these elements.
6.2.5.2
Derive or Allocate Requirements
Once the structure has been agreed it is possible to collect all the requirements
that have been derived and to place them in the structure. It may be possible to
allocate some input requirements directly to the document structure. Where this is
the case, it frequently means that the input requirements are too detailed i.e. too
close to the implementation.
All the rules for writing good requirements outlined in Chap. 4 should be
observed when formulating requirements. Remember that the golden rule is to
write each requirement as a single testable statement. As each requirement is
152
6
Requirements Engineering in the Solution Domain

formulated it is necessary to establish traceability back to the one or more input
requirements that the newly derived requirement satisﬁes wholly or partially.
When considering testability it may be worthwhile thinking about the criteria
that will determine whether a test is considered successful or not. These accep-
tance criteria should be documented with each requirement. Sometimes the criteria
can be embodied as a performance clause within the text of the requirement. An
alternative is to write the criteria in a separate attribute alongside the requirement.
As testability and performance are being considered, it is a vital to consider
how the testing, or other demonstration of successful implementation, will be
organised. This leads naturally into the issue of qualiﬁcation strategy and the iden-
tiﬁcation, in outline, of the set of trials tests and inspections that will be necessary.
In this context it is also essential to consider the test harnesses or special test
equipment that will be required. These may require separate development and, in
some cases, can become separate projects in their own right. A further considera-
tion in this area is the notion of built-in tests and the provision of monitor points.
Built-in tests are increasingly important, especially in safety related area. For
example, in the car example, most electronic systems will have a built-in test that
is performed when the car engine is started up. Monitor points are places where
signiﬁcant information can be made available that would otherwise not be visible.
A simple example of this is an oil pressure gauge on cars. An information example
for the banking system could be a display screen showing the current transaction
rates across the whole of the banking network.
The ﬁnal set of requirements that should be considered is the set of constraints.
These add no additional functionality, but control the way in which the functional-
ity is delivered. At the systems requirements level, there may be some constraints
that come straight from the stakeholder requirements. For example the space that a
system can occupy may be limited or the stakeholders may have insisted that a
pre-existing system is used as a subsystem in the new system.
Some other sources of constraint are:
Design decisions—e.g. the decision to have dual hydraulically operated braking
system.
The application itself—e.g. that the equipment must be able to cope with the
vibration generated by the car when it is in motion.
Safety—e.g. how can the developers convince the authorities that the car will not
constitute a hazard to other road users?
Manufacturing—e.g. can the car be manufactured using the existing facilities at
a reasonable cost?
6.2.6
Agreeing the System Requirements with the Design Team
The ﬁnal step in the creation of the system requirements is to agree the requirements
with the team who will be responsible for developing the design. This uses the agree-
ment process described in Chap. 2 and therefore no further explanation is necessary.
153
6.2
Engineering Requirements From Stakeholder Requirements to System Requirements

6.3
Engineering Requirements From System Requirements to
Subsystems
The logical next step on from the creation of the system requirements is to pro-
duce a design architecture whose components are the major subsystems of the pro-
posed system as shown in Fig. 6.8. As usual the process starts off by agreeing the
input requirements with the customer. The review criteria for system requirements
must be used as the basis for the agreement process together with the general cri-
teria presented in Chaps. 2 and 4. The requirements should be free from imple-
mentation bias unless there is a speciﬁc need to constrain the design. In the latter
case the requirement must be explicitly stated as a constraint. All too frequently
constraints are assumed because “that is what the customer asked for.” It is always
good practice to challenge any design constraint, especially if the constraint is
implied rather than explicit. Sometimes requirements are expressed in design
terms due to laziness and because engineers have a tendency to go into too much
detail too soon.
The analysis work necessary to support the agreement process helps to educate
the designers about what is intended and starts them thinking about possible
solutions.
6.3.1
Creating a System Architecture Model
An architecture model identiﬁes the components of the system and the way in
which they interact. The designer must understand how the components work
together to develop the emergent properties of the system, i.e. to indicate how
they satisfy the input requirements. The designers must also be able to predict
whether there are any emergent properties that are deﬁnitely not required, such as
catastrophic failures or other safety or environmental hazards. There may, how-
ever, be emergent properties that a given design generates that, although not actu-
ally requested by the customer, may be perfectly acceptable. These additional
capabilities must be discussed with the customer. They may give rise to changes
in the input requirements to request them, or the customer may request that they
are inhibited. Finally the designers may ﬁnd that it is impossible to satisfy the
requirements at all or at reasonable cost.
It is only when a design architecture has been generated and explored that these
possibilities come to light. Once a design exists it is possible to predict the cost
and development time for a system with much greater accuracy than earlier. Thus
it is possible to enter a round of negotiation with the customer to hone the input
requirements by the customer making concessions where problems or cost dictate
the need.
In many circumstances it is worthwhile considering two or more alternative
designs and then investigating the relative merits of each. Again this can lead to
154
6
Requirements Engineering in the Solution Domain

further negotiation (trade-off) with the customer to determine the most appropriate
options in terms of cost versus beneﬁt.
When an agreed architecture has been established, each component must be
described in terms of its internal functions and its interaction obligations with
other components and with external systems.
Change
Request
Change 
Request
System
Requirements
Qualification
Strategy for System
Requirements
Qualification
Strategy for 
Subsystem/
Components
Requirements
 Subsystem/
Components
Requirements
Change
Request
Derive
Subsystem/
Component
Requirements
Agree
Requirements
Change
Request
Change
Request
System
Architecture
Model
Analysis
Results
Analyse and
Model
Agree
Requirements
SUBSYSTEM
REQUIREMENTS
PROCESS
Fig. 6.8 Instantiation of generic process to create subsystem requirements from system
requirements
155
6.3
Engineering Requirements From System Requirements to Subsystems

6.3.2
Deriving Requirements From an Architectural Design
Model
From the descriptions of the components, requirements can be derived. The
requirements must address the functionality that the component must provide, the
interfaces that it must use or provide and any constraints to which the component
must conform. These constraints may come directly from the overall system con-
straints (e.g. a particular electronic technology must be used for all components),
or they may be derived from them (e.g. the overall weight limit for the system has
been divided amongst the components). The component (i.e. subsystem) require-
ments are essentially the system requirements for that component when it is
viewed as a system in its own right.
As each requirement is derived, so it should be traced back to one or more of
the input requirements that it partially or fully satisﬁes.
The strategy for testing each component must also be determined. This will not
be the ﬁrst occasion that testability has been considered. Testability is one of the
most important aspects of the design and must be considered as the design is being
created.
6.4
Other Transformations Using a Design Architecture
As the development proceeds from one level down to lower levels, so each level
introduces its own architectural design model (see Fig. 6.1). At each level the pro-
cess followed is as described in the previous section. Thus the next level down
from the creation of subsystems is to create the components of each subsystem
and so on.
There is one special case in which an architectural model is used that is an
exception to this rule. This is indicated in Fig. 6.9, which shows that a design
architecture and subsequently subsystem requirements are created directly from
the stakeholder requirements. This is only possible where the system architecture
model is known in advance. Examples of this include some of the physical sys-
tems already considered, e.g. cars and aeroplanes. Another important group of
applications are those in the telecommunications industry. Here the overall design
architecture is mandated in the telecommunications standards that govern the
application domains. It is a moot point whether the input requirements to such a
process which are often taken directly from the standard are really stakeholder
requirements or are, in fact, system requirements. Whatever interpretation is
placed upon these requirements, during the transformation it is usual to make quite
direct allocations from the input requirements to the subsystem requirements.
Again this suggests that such standards are providing requirements at quite a
detailed level.
156
6
Requirements Engineering in the Solution Domain

6.5
Summary
In this chapter, the nature of the solution domain has been described, the way in
which requirement engineering is applied to transform stakeholder requirements to
system requirements and thence to subsystem requirements and components
requirements has been explained.
Change
Request
Change 
Request
Stakeholder
Requirements
Qualification
Strategy for System
Requirements
Qualification
Strategy for 
Subsystem/
Components
Requirements
 Subsystem/
Components
Requirements
Change
Request
Derive
Subsystem/
Component
Requirements
Agree
Requirements
Change
Request
Change
Request
System
Architecture
Model
Analysis
Results
Analyse and
Model
Agree
Requirements
SUBSYSTEM
REQUIREMENTS
PROCESS
Fig. 6.9 Transforming stakeholder requirements directly to subsystems
157
6.5
Summary

Two quite different examples have been used to explore the types of functional-
ity that must be used to deﬁne requirements in the solution domain. It has been
shown that, in addition to the required internal functionality, additional functional-
ity must be added to cope with external cooperating systems, human interactions,
to safeguard the system from external threatening systems make the system safe to
use. The latter aspect may also involve additional constraints on the means of qua-
liﬁcation in order to convince the relevant authorities.
158
6
Requirements Engineering in the Solution Domain

Chapter 7
Advanced Traceability
For starters I’ll have “Who?”, “What?”, “When?”,
“Where?”, and then “Wither?”, “Whence?” and
“Wherefore?” to follow, and one big side order of “Why?”
Zaphod Beeblebrox in The Hitch-Hiker’s Guide to the
Galaxy Douglas Noel Adams, writer, 1952–2001 AD
7.1
Introduction
So often, the real rationale for a particular design, and the deeper understanding of
how the components of a system work together to achieve an end result, remain in
the minds of the engineers. Months or years later, when the original designers have
long since moved on, or their memory has dimmed, the loss of that understanding
may seriously impede the ability to evolve, maintain or reuse the system.
This chapter is about capturing, managing and maintaining design intent and
rationale. It turns out that design intent is more associated with the relationships
between layers of requirements than within the layers themselves. So this chapter
is also about traceability.
It ﬁrst talks about traceability in general and its implementation.
It then presents a classic approach to the collection of rationale for requirements,
and then moves on to discuss the rationale associated with the relationships between
problem, solution and design. Christened “rich traceability,”
the approach builds
on the basic concepts of “elementary traceability” presented in Chap. 1 and applied
in subsequent chapters.
Then the chapter addresses the broader topic of requirements ﬂow-down, and
attempts to classify the typical patterns that occur: allocation, decomposition, ﬂow-
through and others.
While rich traceability and requirements ﬂow-down may represent one big side
order of “Why?,” the “Wither?,” “Whence?” and “Wherefore?” of traceability are
159
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_7

perhaps addressed through another subject of this chapter: metrics in relation to
traceability.
7.2
Elementary Traceability
There are many ways of representing many-to-many relationships. One consultant
visited a defence contractor just prior to a customer traceability audit to ﬁnd the ofﬁce
all laid out ready. Along the length of the ﬂoor on one side was spread out the require-
ments document, and on the other side the code listing. Traceability was shown by
pieces of string taped between the documents. This approach was space-consuming,
time-consuming, non-maintainable, and non-transportable, but it did some of the job.
Many engineers will have seen traceability represented in matrix form as an
appendix to relevant documents. The two dimensions identify, for instance, user
requirements on one axis and system requirements on the other, with marks in
those cells where a relationship exists.
There are a number of disadvantages to this approach:
• Where there are a large number of statements to index on both axes, the paper
or screen is too small to show enough information.
• Traceability relationships tend to be sparse, resulting in most of the cells in the
matrix being empty, which is a waste of space.
• It is very hard working your way through multiple layers of traceability pre-
sented in a number of separate matrices.
• Information about traceability is separated from the details of the requirements
themselves.
Another method is to use hyper-linked documents, where statements can be
highlighted, linked to other statements, and traversed at will—in either direction if
you are clever. Now the traceability information is visible in the text of the state-
ment, but there are still problems:
• To carry out analysis you may have physically to traverse the link before the
text at the other end is visible.
• It is hard to spot when the item at the other end of a hyperlink has been deleted,
leaving a dangling link, making traceability difﬁcult to maintain.
Whatever approach you use, unless supported by a tool, traceability will be
very hard to manage.
The simplest form of traceability is achieved by linking statements together
using some kind of database support. It is helpful if linking information is held
separately from the documents. It is essential that statements are independently and
uniquely identiﬁable.
With analysis in mind, the essential capabilities for the implementation of trace-
ability are:
• Ability to create links between statements, thus forming permitted relationships.
• Ability to delete links between statements in a controlled manner.
160
7
Advanced Traceability

• Ability to view simultaneously the text (or other attributes) of statements at
both ends of a selected relationship.
• Ability to carry out coverage analysis to show those statements covered or not
covered by a selected relationship.
• Ability to carry out single-level and multi-level impact analysis to show sets of
impacted statements.
• Ability to carry out single-level and multi-level derivation analysis to show sets
of originating statements.
• Ability to carry out upwards and downwards coverage analysis to show sets of
statements covered and not covered by selected relationships.
Figure 7.1 shows an example of elementary traceability. A user requirement
traces down to three responding system requirements. In this presentation, the text
of the user requirement is visible together with the set of system requirements that
respond to it. Having this information together allows the traceability to be
reviewed easily. Figure 7.2 shows a second example.
UR21: The driver shall be able
to deploy the vehicle over
terrain type 4A.  
SR15: The vehicle shall transmit
power to all wheels. 
SR32: The vehicle shall have
ground clearance of not less
than 25 cms.  
SR32: The vehicle shall weigh
not more than 1.5 tonnes. 
satisfies
Fig. 7.1 Elementary traceability example: military vehicle
UR21: The user shall be able to
boil 10 litres of water in a flat
bottomed pan from room
temperature in 4 mins.   
SR15: The cooker shall have an
electric plate 15 cms in diameter
capable of delivering 3 kilowatts.    
SR32: The cooker shall have a gas
ring 10 cms in diameter. 
SR32: The cooker shall be supplied
with gas pressured at not less than
25 psi.
satisfies
Fig. 7.2 Elementary traceability example: cooker
161
7.2
Elementary Traceability

Implementation of elementary traceability as discussed in Sect. 7.2 represents a
major step forward for many organisations. Indeed, changing the culture of an
organisation to embrace even this simple approach may be a big enough leap in
itself. However, there is, as always, more that can be done.
7.3
Rationale
One of the roles that traceability plays is to show why requirements exist. SR15 in
Fig. 7.2 serves to partially satisfy UR21.
In the absence of traceability to higher-level requirements (for example, when
already in the top level of requirements), many practitioners advocate that every
requirement expression should contain an attribute called “Rationale,” which is
used to explain the need for the requirement.
For example, consider the requirement The boiler shall be able to provide a sup-
ply of water at temperatures between 90°C and 98°C at a rate of 20 litres per hour.
The question “Why is this requirement needed?” may lead us to capture the fol-
lowing rationale: This requirement is necessary to allow the Baristas to make a
sufﬁcient quantity of hot drinks.
In the presence of traceability, however, part of this rationale is captured by tra-
cing the requirement to the corresponding stakeholder requirement, as per Fig. 7.3.
The importance of capturing a rationale statement increases when the traceabil-
ity is more complex. Consider Fig. 7.4. Now there are two needs being ﬁlled by
the system requirement, and a rationale statement supplements the traceability to
capture more of the design intent. It is not just the need for the requirement that is
addressed, but also the origin of the quantiﬁcation.
Note that the rationale statement concerns the set of satisfaction links, not just
one of them. The statement justiﬁes the existence of the requirement, or addresses
its necessity. Indeed, it is sometimes called a “Justiﬁcation Statement” or
“Justiﬁcation Argument.”
7.4
Satisfaction Statements
While the rationale attribute addresses necessity, there is the symmetrical concept
of sufﬁciency.
The intention in the example of Fig. 7.1 is that the three system requirements
are somehow sufﬁcient to satisfy the user requirement. It is difﬁcult, however, for
SHR02: The Barista shall be able to
make hot drinks at the rate of 50 per
hour.   
SR15: The boiler shall be able to
provide a supply of water at
temperatures between 90°C and
98°C at a rate of 20 litres per hour.   
satisfies
Fig. 7.3 Elementary traceability example: Barrista
162
7
Advanced Traceability

a non-expert to assess the validity of this assertion, because the reasoning has not
been presented.
What is better is to provide a “satisfaction statement”—sometimes called a
“satisfaction argument” or “satisfaction rationale”—for each user requirement.
With the elementary traceability of Fig. 7.1, the only information provided is that
the three system requirements play some kind of role in the satisfaction argument,
but there is nothing to indicate exactly what that role is.
In a fashion analogous to the Rationale attribute discussed in Sect. 7.3, the
Satisfaction Statement can be captured as an attribute of the high-level require-
ment, as illustrated in Fig. 7.5.
As with Rationale, note again that the Satisfaction Statement concerns the set of
satisfaction links, not just one of them. The statement should address the sufﬁciency
of the set of linked requirements in terms of satisfying the high-level requirement.
Some approaches advocate placing a rationale statement on every link explain-
ing its presence. This, however, misses a signiﬁcant point: it is the set of linked
low-level requirements that together serve to satisfy the high-level requirement.
7.5
Rich Traceability
So far the Satisfaction Statement has been expressed textually. It is also possible
to give an indication about the way in which the system requirements combine to
achieve satisfaction, using a propositional operator:
• By conjunction (&) indicating that the contribution of all the system require-
ments is necessary for the user requirement satisfaction argument to hold;
• By disjunction (or) indicating that the contribution of any one of the system
requirements is necessary for the user requirement satisfaction argument to hold.
SHR02: The Barista shall be able to
make hot drinks at the rate of up to
50 per hour.   
satisfies
satisfies
SR15: The boiler shall be able to
provide a supply of water at
temperatures between 90°C and
98°C at a rate of 20 litres per hour.   
SHR45: The Kitchen Assistant shall
be able to clean up to 10 stainless
steel jugs every 10 minutes.
Rationale: The boiler has
to provide hot water for
both coffee making (8
litres per hour) and for
washing up (12 litres per
hour.)
Fig. 7.4 Elementary traceability example: Barrista, continued
163
7.5
Rich Traceability

An example of conjunction is given in Fig. 7.6. Here it seems more natural to
link the three system requirements through the Satisfaction Statement, for reasons
that will become clear in a moment.
An example of disjunction is given in Fig. 7.7, where satisfaction is achieved
through provision of either an electric ring or a gas ring or both. Note the two-
level propositional structure of the argument.
Now much more information is provided about how the user requirements
are being satisﬁed. Even one who is not a domain expert may feel capable of
satisfies
UR21: The driver shall be able
to deploy the vehicle over
terrain type 4A.
SR15: The vehicle shall transmit
power to all wheels.
SR32: The vehicle shall have
ground clearance of not less
than 25 cms.
SR32: The vehicle shall weigh
not more than 1.5 tonnes.
Satisfaction Rationale:
Terrain type 4A specifies
soft wet mud, requiring
constraints on weight,
clearance and power
delivery.
Fig. 7.5 Rich traceability example: vehicle
satisfies
UR21: The driver shall be able
to deploy the vehicle over
terrain type 4A.
Terrain type 4A specifies
soft wet mud, requiring
constraints on weight,
clearance and power
delivery.
&
SR15: The vehicle shall transmit
power to all wheels.
SR32: The vehicle shall have
ground clearance of not less
than 25 cms.
SR32: The vehicle shall weigh
not more than 1.5 tonnes.
Fig. 7.6 Rich traceability conjunction
164
7
Advanced Traceability

assessing important aspects of the argument. The text helps in assessing the logic
of the argument for sufﬁciency and necessity. The operator makes the structure of
the argument more precise.
Notice in particular, it is not at all clear in Fig. 7.2 that the set of system
requirements represent alternative solutions, whereas in Fig. 7.7 the fact is made
absolutely speciﬁc. If an electric ring cannot be supplied, the requirement can still
be satisﬁed through a gas ring.
Rich traceability can of course be used through multiple layers of requirements
or objectives. Figure 7.8 depicts three layers and the traceability between them.
The satisfaction argument is often trivial, amounting perhaps only to the allo-
cation of an identical requirement to one or more subsystems or components.
This is sometimes referred to as requirements “allocation” or “ﬂow-down” (see
Sect. 7.11).
Where this pure ﬂow-down of requirements is used, the change process may be
simpliﬁed. Changes to high-level requirements may be automatically ﬂowed-down
to lower levels.
The simple addition of the “identity” symbol allows such cases to be captured.
Figure 7.9 shows an example of this. The symbol “=” is used to indicate identity.
This approach to rationale capture has been christened “Rich traceability.” The
authors ﬁrst came across the concept in the Network Rail (then Railtrack) West
Coast Route Modernisation project in the UK, where a team from Praxis Critical
Systems had devised a requirements management process and data model that
used “design justiﬁcations.” The same concept can be identiﬁed in a variety of
similar approaches in which satisfaction statements are called variously “require-
ments elaboration,” “traceability rationale,” “strategy,” etc.
satisfies
UR21: The user shall be able to
boil 10 litres  of water in a flat
bottomed pan from room
temperature in 4 mins.
SR15: The cooker shall
have an electric plate 15
cms in diameter capable
of delivering 3 kilo watts.
SR32: The cooker shall
have a gas ring 10 cms in
diameter.
SR32: The cooker shall
be supplied with gas
pressured at not less than
25 psi.
Two kinds of flat
plate can achieve
this performance. or
A large gas ring with
medium pressure
supply
&
Fig. 7.7 Rich traceability disjunction
165
7.5
Rich Traceability

X xxxxx xxx xxxx,
xxxx xxxx xx xxxx
xxxxxxx xxx xxxxxx.
Xxx xxxx xxx x xxxx
xxxx xxxx x xxxxxx: 
or
X xxxxx xxx xxxx,
xxxx xxxx xx xxxx
xxxxxxx xxx xxxxxx.
&
Xxxx xx xxxx
xxxxxxx xxx xxxx
xxxx x xxxxxx.
Xxxx xx xxxx
xxxxxxx xxx xxxx
xxxx x xxxxxx.
SHR 3
SR 37
SR 31
SR 41
DR 131
&
DR 42
DR 132
or
DR 24
DR 14
DR 73
&
Stakeholder requirements
System requirements
Design requirements
Fig. 7.8 Multiple layers of rich traceability
X xxxxx xxx xxxx,
xxxx xxxx xx xxxx
xxxxxxx xxx xxxxxx.
Xxx xxxx xxx x xxxx 
xxxx xxxx x xxxxxx: or
X xxxxx xxx xxxx,
xxxx xxxx xx xxxx
xxxxxxx xxx xxxxxx.&
Xxxx xx xxxx
xxxxxxx xxx xxxx
xxxx x xxxxxx.
Xxxx xx xxxx
xxxxxxx xxx xxxx
xxxx x xxxxxx.
SHR 3
SR 37
SR 31
SR 41
SS2-131
&
SS1-42
SS1-132
or
SS1-24
SS2-14
SS2-84
=
Requirement flowed down to 2 subsystems
SS1-73
Fig. 7.9 Flow-down of requirements using “identity”
166
7
Advanced Traceability

7.6
Supporting Information and Evidence
Satisfaction statements may depend for their validity on things other than lower-
level requirements. Figure 7.10 shows an example using “domain knowledge” to
support the argument. Domain knowledge is a fact or assumption about the real
world, and not something that constrains the solution in and of itself. In this case,
the statement of domain knowledge is an essential part of the satisfaction argu-
ment, shown in a slanted box.
Capturing such assumptions is important, not least because the world, and the
assumptions you can make about it, has a habit of changing. Once captured, deri-
vation analysis can be used to understand the impact of changing assumptions on
the ability of the system to meet its requirements.
An example of this comes from the New York underground. A series of acci-
dents in the 1970s were due to a false assumption concerning the stopping dis-
tance of trains. Initially valid, the assumption was invalidated as trains got heavier
over the years, and the stopping distance increased. Whilst the performance of the
signalling software was originally correct, and it did not evolve, the changing
assumptions meant that it ceased to meet requirements from a certain time.
The ability to document and trace the role of such assumptions is possible
through effective traceability.
Another example of non-requirements information playing a role in satisfaction
statements comes from modelling activities. Satisfaction statements are often
derived from complex models, the complete details of which are too detailed to be
captured in rich traceability.
Figure 7.11 shows an example abstracted from a railway project in which a
Satisfaction Statement depends on the results of a complex timetable modelling
UR 21: The driver shall be able
to deploy the vehicle over
terrain type 4A.
SR 35: The vehicle shall
have 3 axles.
SR 15: The vehicle shall transmit
power to all wheels.
SR 32: The vehicle shall have
ground clearance of not less
than 25 cms.
SR 53: The vehicle shall weigh not
more than 1.5 tonnes.
DK 5: Terrain type 4A can support
          0.5 tonnes per axle.
A wheeled vehicle
requiring constraints
on weight, clearance
and power delivery.
satisfies
&
supports
Fig. 7.10 The role of domain knowledge
167
7.6
Supporting Information and Evidence

BR14: The journey time
between Euston and
Glasgow shall be not more
than 250 minutes.
VT 15: Vision model no V54a.
SR 32: Linespeed
            requirements
SR 32: Stations dwell-time
            requirements
VISION time-tabling
model shows feasability
of journey times for
given line speeds and
dwell times.
This requirement is satisfied by:
  -  ensuring sufficient running
          in each line segment,
  -  ensuring minimum non-running
          time
  -  ensuring feasibility of overall
          timetable.
&
&
Fig. 7.11 The role of modelling in traceability
168
7
Advanced Traceability

activity using specialised software. A set of assumptions and subsystem requirements
are derived from the modelling tool, and these are documented in the rich traceability
structure. The modelling reference is shown in a box with rounded ends.
In this case, the modelling activities that need revisiting become apparent under
impact analysis.
7.7
Sufﬁciency and Necessity
In the richest of rich traceability approaches, Rationale and Satisfaction Statements
can be combined. Figure 7.12 shows an example. Here the Rationale is used to
address necessity, and the Satisfaction Statements are used to address sufﬁciency.
In terms of the order in which information is collected, one possible process is this:
1. The high-level requirements are captured by stakeholders and reviewed.
2. The system owners then respond by writing system requirements, tracing them
back to stakeholder requirements, and capturing Rationale to justify the exis-
tence of each system requirement.
3. In turn, the stakeholders conduct a review by taking each stakeholder require-
ment, considering the set of traced system requirements with their Rationale, and
writing a Satisfaction Statement in summary of how the requirement is satisﬁed.
UR21: The
drive shall be
able to deploy
the vehicle over
terrain type 4A.
UR22: The
drive shall be
able to deploy
the vehicle over
terrain type 4B.
Satisfaction:
Terrain type 4A
specifies soft
wet mud,
requiring
constraints on
weight,
clearance and
power delivery.
Satisfaction:
Terrain type 4B
specifies severe
gradients,
requiring
constraints on
power delivery.
Rationale:
All-wheel drive
enables the
vehicle to
traverse several
of the more
changing
terrains ...
SR15: The vehicle
shall transmit power
to all wheels.
SR15: The vehicle
shall have ground
clearance of not less
than 25 cms.
SR53: The vehicle
shall weigh not more
that 1.5 tonnes.
Rationale:
All-wheel drive
enables the
vehicle to
traverse several
of the more
changing
terrains ...
Rationale:
Weight of the
vehicle is
constrained by
terrain and
airborne
transport.
Fig. 7.12 Multiple layers of rich traceability
169
7.7
Sufﬁciency and Necessity

This process admits that stakeholders own the Satisfaction Statement, and that
the supplier owns the Rationale. It is the supplier that determines the best solution
to requirements, and who justify the solution. It also provides a systematic way for
the stakeholder to review the solution, considering the sufﬁciency of the response.
In so doing, stakeholders may observe instances where there are omissions in the
solution, leading into a process of agreement between customer and supplier.
In practice, not many organisations go to these lengths to capture rationale, pre-
ferring to stick with a single Satisfaction Statement for each requirement, and
using that statement to address both sufﬁciency and necessity.
7.8
Reviewing Traceability
Every time a requirement is reviewed, it should be reviewed along with its satis-
faction statement. Based on rich traceability, a review process can be established
that focuses on one requirement at a time, together with its satisfaction argument,
and the requirements that ﬂow from it.
Figure 7.13 shows a screen shot of a tool used in a defence project to review
requirements and satisfaction statements. On the screen is just the right parcel of
information to assess a requirement and how it is satisﬁed.
The dark triangles are for navigating downwards through the layers of trace-
ability, or across to the next requirement at the same level.
7.9
The Language of Satisfaction Statements
As with requirements, it helps to have a uniform approach to expressing satisfac-
tion statements. The key guideline is to start the sentence with This requirement
will be satisﬁed by …, This is achieved by …, or something similar, which focuses
the mind on the kind of statement being made.
While requirements should be strictly atomic (see Chap. 4), a Satisfaction
Statement need not be so limited—rationale is a form of narrative. However, if
statements become too complex, a structured argument should be used instead.
Repeated patterns of satisfaction statements may be identiﬁable, in which case
a palette of boilerplate statements could be used to good effect.
7.10
Rich Traceability Analysis
The presence of satisfaction statements in rich traceability does not preclude the
ability to carry out elementary impact and derivation analysis as described in
Chap. 1. Indeed, the statements add important clues as to the nature of the impact
by capturing understanding, or raison-d’être.
170
7
Advanced Traceability

The propositional structure (and’s and or’s) of the satisfaction statements offers
opportunities for other kinds of analysis. For instance, the structures can be analysed
to show the number of degrees of freedom that exist for meeting a particular objective.
Take the example of Fig. 7.7. The proposition structure for UR3 can be cap-
tured in the expression SR37 or (SR31 and SR41). Using the laws of propositional
logic, this can be converted to a special disjunctive form in which each disjunction
shows one way of meeting the requirement:
[SR37 and (not SR31) and (not SR41)]
or [SR37 and SR31 and (not SR41)]
or [SR37 and (not SR31) and SR41]
or [SR37 and SR31 and SR41]
or [(not SR37) and SR31 and SR41]
In simple cases, this analysis may not seem that useful, but imagine more complex
scenarios where there are hundreds of requirements in several layers with complex
interactions. One may want to know whether there is any way of meeting the require-
ments, and if there is no way, then what the cause is—where the conﬂict exists.
Fig. 7.13 Reviewing tool for satisfaction statements
171
7.10
Rich Traceability Analysis

7.11
Requirements Flow-down
This chapter, in essence, has been taking about requirements ﬂow-down—the
transformations that a requirement goes through as the design proceeds.
The kinds of transformation can be classiﬁed as follows:
• Functional Allocation. A functional requirement is ﬂowed-down, more or less
unchanged, from the system to the subsystem responsible for achieving it. Here
is an example of this: The Ambulance Controller shall be able to communicate
incident details to the Ambulance Driver. This function is allocated to a parti-
cular subsystem: The Communications System shall allow the Ambulance
Controller to communicate incident details to the Ambulance Driver. Note that
the subsystem (The Communications System) becomes the subject of the sen-
tence, but the essence of the requirement is the same.
• Functional Decomposition. This occurs when a top-level function can only be
achieved by low-level functions in combination. For example: The Electro-
Chlorination Unit shall generate hypochlorite solution from seawater to a con-
centration of between 1000 and 1200 mg per litre. To achieve this, the system
uses electrolysis of seawater to create a mixture of hypochlorite and hydrogen,
feeds this into a degassing tank, and then dilutes the hypochlorite solution to
the required concentration. So: The Electrolysis Unit shall convert seawater
into hypochlorite solution at a concentration of at least 1200 mg per litre.;
The Degassing Tank shall extract hydrogen gas into the atmosphere at a dilu-
tion of no more than 1% v/v.; The Dilution Unit shall reduce hypochlorite
solution to between 1000 and 1200 mg per litre. Along with this, of course,
come all the various interfaces between those subsystems. This kind of func-
tional decomposition is what is modelled by multi-layered Data Flow
Diagrams (see Sect. 3.2.1).
• Non-Functional Allocation. A requirement is ﬂowed-down from the system to
one or more subsystems more or less unchanged. Here is an example of this:
The vehicle shall be constructed from non-ferrous materials. This is quite simply
allocated to the components: The Wheels shall be constructed from non-ferrous
materials, The Drive Shaft shall be constructed from non-ferrous materials, etc.
Note that the subject of the requirement changes, but not its essence.
• Non-Functional Decomposition. This occurs where, for instance, an overall
performance target can only be achieved by subsystems working in combina-
tion. For example, The journey time between Euston and Glasgow shall be not
more than 250 minutes. This performance can only be achieved if trains can
achieve a certain average line-speed, that dwell times in stations are below a
certain level, and that the time-tabling permits it.
• No Further Decomposition. There are times when a choice is made not to
ﬂow a requirement down to any further levels. This may occur when a require-
ment is judged as not being relevant, or when a requirement is achieved as an
emergent property of the overall design. Emergent properties are often hard to
trace downwards, because they are not attributable to any particular part of the
design.
172
7
Advanced Traceability

It is useful to capture the type of transformation as an attribute alongside the
Satisfaction Statement. This is sometimes called “Satisfaction Intent”, and takes
one of the ﬁve values listed above. Its purpose is to declare the intended type of
ﬂow-down, and serves to inform Coverage Analysis (see Chap. 1, Sect. 1.6). In
particular, satisfaction links are expected to be in place in all cases except “No
Further Decomposition,” where none are expected.
In the case of “No Further Decomposition,” it is, of course, vital to collect the
Satisfaction Statement to explain the reason for no ﬂow-down.
Non-Function Decomposition is often associated with some kind of arithmetic,
or other, calculation, and may need to be supported by fairly extensive modelling.
An example of this is availability. Overall availability may ﬁrst of all be decom-
posed into targets for reliability and Mean-Time-To-Repair, and subsequently the
reliability gets decomposed across the system components in a non-trivial, but
nevertheless calculable, fashion.
There are some kinds of non-functional decomposition that cannot be deter-
mined upfront, and involve negotiation during design. An example of this is mass:
the overall mass of a system emerges, of course, from the combined masses of
subcomponents and their arrangement. However, it may not be known during
early design what mass targets are achievable for individual components.
A typical process for managing this situation is as follows:
1. The overall mass budget is allocated as initial mass targets for each subsystem,
providing a margin for contingency.
2. Subsystems design to their allocated mass budget. If they over-achieve, they
can report back to the system level that spare mass capacity is available to
other subsystems. If they under-achieve, then they negotiate with the system
owners for a larger allocation of the mass budget.
3. The overall mass is constantly monitored as a Key Process Indicator during the
course of design, and corrective action taken if mass exceeds the target.
This kind of process demonstrates that, in some situations, requirements
ﬂow-down structures are used for ﬂow-up as well as ﬂow-down. In effect, the
traced requirements are connected by an arithmetic calculation that can be worked
in either direction.
A Model-Based Systems Engineering approach could be used to formalise such
situations, and semi-automate the ﬂow-down of budgets and ﬂow-up of actuals.
7.12
Rich Traceability for Qualiﬁcation
Rich traceability can be used in any traceability relationship. The discussion so far
has been based on the satisfaction relationship, but it is also applicable to qualiﬁ-
cation. In this case, the “Satisfaction Statement” may be referred to as the
“Qualiﬁcation Statement,” “Qualiﬁcation Argument” or “qualiﬁcation rationale.”
All the same advantages of using satisfaction statements apply to the qualiﬁca-
tion statement. A simpler form of the Satisfaction Intent can also be used, called
173
7.12
Rich Traceability for Qualiﬁcation

the “Qualiﬁcation Intent,” which typically takes one of two values: “Qualiﬁcation
Required at this Level” or “No Qualiﬁcation Required at this Level,” with the
Qualiﬁcation Statement explaining why.
7.13
Implementing Rich Traceability
We describe here two approaches to the implementation of rich traceability:
single-layer and multi-layer.
7.13.1
Single-layer Rich Traceability
In this approach, illustrated in Fig. 7.14, each high-level requirement has a single
statement of satisfaction or strategy as an attribute, and multiple low-level require-
ments may ﬂow from it in a many-to-many satisfaction relationship. Another attri-
bute (not shown in the diagram) is used to type the argument as either a
conjunction or a disjunction.
A characteristic of this approach is that there is a one-to-one relationship between
the satisfaction argument and the high-level requirement. Thus, if the same argument
addresses several high-level requirements, it has to be repeated on each requirement.
7.13.2
Multi-layer Rich Traceability
In this approach, the satisfaction statements are a separate intermediate entity.
Two relationships are involved, characterised here as “established” and “contri-
butes.” This has a number of advantages:
1. The satisfaction statements can have structure, rather than being a simple statement.
2. A single satisfaction statement can address multiple high-level requirements.
3. The set of satisfaction statements provide a focus for the publication of a sepa-
rate document from the requirements themselves: a design justiﬁcation docu-
ment, or compliance statement.
4. Separate ownership can be applied to the requirements and satisfaction statements.
Here satisfaction statements can be structured into multiple layers: a main argu-
ment attached (as an attribute or linked in an “establishes” relationship) to the
requirement to be established, and a hierarchy of sub-statements hang off of the
main argument. Low-level requirements are linked to the sub-statements in a “con-
tributes to” relationship. This is shown in Fig. 7.15.
Some implementations limit the depth of the statement hierarchy to two, using
a main statement—the satisfaction statement—and a single layer of sub-statements
that explains the role played by the contributing requirements.
174
7
Advanced Traceability

7.14
Design Documents
Astute readers will have noticed that the layer of rationale introduced by satis-
faction statements is very like the “ﬁlling” in the systems engineering sandwich
presented in Fig. 1.9. Indeed, the satisfaction statements can be gathered into a
document, which may be best characterised as an “analysis and design” docu-
ment. It is this design document which is the focal point of the integration
between requirements and modelling. The role of the design document is to
summarize—textually and visually—those parts of the modelling activity that
explain why one layer of requirements is sufﬁcient and necessary to satisfy the
layer above. The document references data from the modelling process as evi-
dence for the rationale. Traceability between layers of requirement passes
through the design document. In this way, the results of modelling appear in the
traceability chain, and can engage in impact analysis.
Figure 7.16 portrays this approach. Layers of requirements are ﬁlled by design
documents appropriate to the level of abstraction. The modelling activities at each
level give rise to data that is referenced by the design document. The thin arrows
represent the ﬂow of information; the thick arrows represent traceability.
High-level
Requirements
Low-level
requirements
satisfaction
argument
requirmt
requirmt
requirmt
satisfies (n:n)
Fig. 7.14 Single-layer rich traceability
High-level 
Requirements
Low-level 
Requirements
Satisfaction 
Statements
sub
statement
sub
statement
main
statement
requirmt
establishes (n:n)
contributes to (n:n)
requirmt
requirmt
requirmt
requirmt
Fig. 7.15 Multi-layer rich traceability
175
7.14
Design Documents

We now show an example of the kind of information that may be collected into
a design document. A sequence of ﬁgures shows extracts from an “Analysis of
Need” document that models a Baggage Check-in System at the problem domain
level. The model sits between the “Statement of Need” and the “Stakeholder
Requirements” documents, and uses UML2 to portray the analysis in visual form.
The following kinds of information are typical:
• Concepts. A UML class diagram is used to identify the domain concepts and
the relationships between them. Each concept is a UML class, and each rela-
tionship is a UML association. Both appear as entries in the design document
where a textual description of the concept or relationship is supplied.
Figure 7.17 shows an example for the Baggage Check-in System. The symbols
to the left of each paragraph indicate that that part of the document corresponds
to a UML entity in the model.
• Stakeholders. This section lists the stakeholders that have been identiﬁed dur-
ing analysis, and includes a class diagram showing relationships. In the exam-
ple shown in Fig. 7.18, there are two stakeholders with a single relationship.
• Static Context. The purpose of this section is to identify the context in which
the Baggage Check-in System exists. The Baggage Check-in System itself is
modeled as a class in a class diagram, along with classes representing all the
surrounding and enclosing systems. Relationships between these systems are
modeled using aggregations and associations. Again, each class and association
appears in the design document with a textual description. This section is
shown in Fig. 7.19.
• Usage. This section describes the top level use cases for the system. This is
presented as a series of use case diagrams, each with one or more sequence
Requirements layer
Modeling layer
Requirements layer
Modeling layer
Requirements layer
Modeling layer
Requirements layer
e.g. Goal/Usage 
modeling
e.g. Functional
modeling
Stakeholder
requirements
Sub-System
requirements
System
requirements
Statement
of need
e.g. Performance
modeling
Analysis 
of Need
Functional
Design
Architectural
Design
Modeling 
data
Modeling 
data
Modeling 
data
Fig. 7.16 Analysis and design documents
176
7
Advanced Traceability

diagrams. Figure 7.20 shows just one of the use cases and its sequence diagram
showing the normal course of action for the scenario. The sequence diagram
shows the interactions between the stakeholders (some of which are external
subsystems) and the system in question (the Baggage Check-in System), and
thus helps to deﬁne the scope, process context and external interfaces.
1 Concepts
1.1 Baggage ltem
1.2 Trackable Baggage ltem
1.3  Baggage Receipt
1.4 Concept Relationships
1.3.1 identifies
This section will contain textual descriptions of the following modelling entities. Each one
will correspond to a “Class” in the UML model.
The term 'Baggage Item' refers to a single item of luggage.
Each passenger may have 0 or more items of luggage.
The term 'Trackable Baggage' refers to a Baggage Item that can be identified with a
particular passenger.
The term 'Baggage Receipt' refers to a means of allowing a passenger to assert ownership of
an item of baggage.
A Baggage Receipt serves to uniquely identify a Baggage Item.
‘Baggage Receipt’
identifies
‘Trackable Baggage Item’
‘Baggage Item’
1..1
1..1
Fig. 7.17 Concepts section of design document
3 Stakeholders
3.1 Passenger
3.2 Family
3.3 Stakeholder Relationships
This section will contain textual descriptions of each kind of 
stakeholder. Each one should correspond to an "Actor" in the UML
model.
A passenger is any person wishing to travel on a flight.
A family is a group of passengers travelling together. They may share
luggage, and wish to sit together.
Optional class diagram showing sub-type relationships between
stakeholders, if any.
Family
<<actor>>
'belongs to'
Passenger
0..n
<<actor>>
Fig. 7.18 Stakeholders section of design document
177
7.14
Design Documents

• Design rationale. This section summarizes the analysis and modeling activity by
giving an explanation of how the need is going to be satisﬁed by the capabilities
of the system. This information is presented in the Satisfaction Statement for
each requirement in the input requirements document. It is here that the traceabil-
ity to high-level requirements and from low-level requirements is established.
The Satisfaction Statement, in effect, explains how the statement of need has
been decomposed into statements of capability. This is illustrated in Fig. 7.21.
In this ﬁgure, the ﬁrst column shows the text of the Statement of Need that is
addressed by the rationale, the middle column contains the Satisfaction Statement, and
the right-hand column shows evidence for the rationale in the model and requirements
that are derived from it. This tabular presentation is, in effect, the sandwich on its side:
two layers of requirement with the design rationale in between. With effective tool
3 Context
3.1 Baggage Check-in System
3.2 Baggage Handling System
3.3 Baggage Transport System
3.4 Passenger Transport System
3.5 Baggage  Reclaim System
3.6 Baggage  Holding System
3.7 Relationships with surrounding systems
Start with a class diagram that shows the significant context of the system to be
developed.
This section identifies and introduces the system to be developed. 
 
This is the enclosing system. (Concept of system-of-systems.)
It must be a class, so that an architexture diagram can be drawn for it, but we
stereotype it as an actor.
This is a peer system, so we make it a class, but stereotype it as an actor.
This is a peer system, so we make it a class, but stereotype it as an actor.
This is a peer system, so we make it a class, but stereotype it as an actor.
This is a peer system, so we make it a class, but stereotype it as an actor. 
‘Baggage Check-in System’
‘Baggage Transport System’
‘Baggage Reclaim System’
‘Baggage Holding System’
‘Baggage Handling System’
<<actor>>
<<actor>>
<<actor>>
<<actor>>
<<actor>>
SendsBaggageList
SendsBaggage
Fig. 7.19 Context section of design document
178
7
Advanced Traceability

support, this view of the project data can be generated from the presence of tracing
between the layers.
7.15
Metrics for Traceability
Since the concept of traceability is so central to requirements engineering, it is
interesting to consider what process measurements may be useful in relation to the
ﬂow-down of requirements.
Fig. 7.20 Usage section of design document
179
7.15
Metrics for Traceability

Focussing on the satisfaction relationship, and moving down through the layers
of requirements, there are three dimensions of traceability that may interest us:
Breadth: how well does the relationship cover the layer, upwards and downwards?
Depth: how far down (or up) the layers does the relationship extend?
Growth: how much does the relationship expand down through the layers?
To help in determining which aspects of these dimensions are useful in terms
of measuring the requirements engineering process, it is necessary to distinguish
between two types of metrics:
Phase metrics: measurements relating to a single stage of development, e.g. just
to the systems requirements layer;
Global metrics: measurements spanning several stages of development.
The three dimensions, along with a discussion about balance, are now addressed.
7.15.1
Breadth
Breadth relates to coverage, and as such is a phase metric. As discussed in Chap. 1,
coverage can be used to measure progress of processes that create traceability at a
1 Design Rationale
1.1 Reduce check-in time
1.2 lncrease security standards
[PA-233] UML Sequence diagram Travel
with Baggage: Normal Course of Events
[SHR-3]  At the port of departure, the
passenger shall be able to check-in an
item of baggage within 25 seconds of 
placing it on the conveyor.
Baggage Item
Trackable Baggage Item
identifies
[PA-263]  A Baggage Receipt serves to
uniquely identify a Baggage Item.
[PA-233] UML Sequence diagram
Travel with Baggage: Normal Course of
Events
[PA-3]  The term ‘Baggage Item’ refers to 
a single item of luggage.
[PA-6] The term ‘'Trackable Baggage’
refers to a Baggage Item that can be
identified with a particular passenger. 
[SHR-5]  At the port of arrival, the
passenger shall be able to collect baggage
he/she checked-in on departure.
[SoN-9] Passengers
will be able to 
check-in baggage on
average twice as
fast as the current
average for given
number of items.
The current
average is 80 secs
per item.
[SoN-8] Passengers
will only be allowed
to collect baggage
that they
themselves
checked-in on
departure.
This objective will be met by ensuring that
the Baggage Check-in System has sufficient
performance at the point of check-in. A
separation will be made between the check.
in of the passenger and the check-in of that
passenger’s baggage. The target check-in for
each item of baggage is 25 seconds. This
strategy is reflected in the following ways:
passenger check-in and baggage item
check-in are separate events in the modeled
scenarios;
a performance requirement is imposed on
the baggage check-in capability.
This objective will be met by issuing unique
receipts to passengers for baggage check-in
on departure, allowing trackable baggage to
be matched with those receipts, and obliging
passengers to present those receipts to the
Baggage Collection System on arrival. This
strategy is reflected in the following ways:
a distinction is made between baggage and
trackable baggage;
every item of trackable baggage has a
unique receipt;
presentation of receipts by passengers
occurs at baggage collection.
Fig. 7.21 Rationale section of design document
180
7
Advanced Traceability

single stage. It focuses on a single layer, and measures the extent to which require-
ments are covered by the adjacent level above or below (or “beside” when looking
at qualiﬁcation.)
7.15.2
Depth
Depth looks at the number of layers that traceability extends upwards or down-
wards from a given layer, making it a global metric. One application may relate to
determining the origins of requirements of the lowest level. How many component
requirements have actually ﬂowed down all the way from the stakeholder require-
ments, and how many have their origin somewhere in the design?
7.15.3
Growth
Growth is more interesting. It is related to potential change impact. How many
requirements at lower levels are related to a single requirement at the top level?
Consider Fig. 7.22, in which four situations are contrasted.
In case (a), a single requirement is satisﬁed by a single requirement at the next
level down. The growth factor is 1. In (b) the single requirement is met by six,
giving a growth factor of six. What does this say about the differences between
the two requirements? Possibilities are:
Requirement (b) may be poorly expressed, and needs decomposing into several;
Requirement (b) may be inherently more complex than (a), and therefore may
need special attention;
Changing requirement (b) will have more impact than changing (a), and therefore
needs special attention.
a
b
c
d
Fig. 7.22 Traceability growth
181
7.15
Metrics for Traceability

Of course, an apparent imbalance at one level may be addressed at the next
level down. This is illustrated by cases (c) and (d), where the growth factor two
levels down is identical. What could be deduced from this? Possibilities are:
• The top requirement in (c) was at a level too high;
• The middle requirements in (d) were at a level too low.
Only after considerable experience in a particular organisation developing parti-
cular kinds of systems could one begin to ascertain what growth factor of require-
ments between layers is to be expected. More readily useful, however, would be
to examine the balance of growth between requirements, as a means of identifying
potential rogue requirements, or imbalances in the application of process.
Further insights into the complexity of requirements ﬂow-down structures, see
(Dick J, Jones B, (2012))
7.15.4
Balance
One idea for a metric is to look at the distribution of growth factors for individual
requirements between two given layers, and examine those that lie in the outer
quartiles of the distribution. The goal is to identify requirements that have an
abnormally high or low growth factor, and subject them to special scrutiny.
Figure 7.23 shows what a typical growth distribution may look like. The graph
plots the growth rate against the number of requirements that possess that growth
rate. Most lie between two and six, whereas a few have only one or more than six.
It is these latter requirements that should be identiﬁed and given special attention.
Growth at next level
No. of requirements
Focus on reviewing requirements
in upper and lower quartiles
0
1
2
3
4
5
6
7
8
9
10
11
12
Fig. 7.23 Frequency distribution of requirement growth
182
7
Advanced Traceability

The discussion above was about downwards growth—examining the number
of requirements that ﬂow out of another. What about the opposite direction: the
number of requirements that ﬂow into another?
Bearing in mind that traceability is a many-to-many relationship, consider
Fig. 7.24. Two requirements at the lower level have more than one requirement
ﬂowing into them. What can we say about these requirements? They are perhaps
more critical than others, since they satisfy multiple requirements, and should
therefore be given special attention.
The distribution of upward traceability can be used to single out these require-
ments. Figure 7.25 shows the typical shape of such a distribution.
7.15.5
Latent Change
Change management is perhaps the most complex requirements engineering pro-
cess. The processes and information model detailed in Chap. 2 take advantage of
traceability to determine the potential impact of change. When a change request is
2
3
Fig. 7.24 Criticality of requirements
Growth from previous level
No. of requirements
Focus on reviewing requirements
in upper quartile
0
1
2
3
4
5
6
7
8
9
10
11
12
Fig. 7.25 Frequency distribution of requirement criticality
183
7.15
Metrics for Traceability

raised against one requirement, all those tracing to it move to a suspect status until
the engineers ascertain the true impact.
The raising of a single change request, therefore, can suddenly introduce a cas-
cade of potential latent change into the system. In such circumstances, it would be
highly desirable to track progress and estimate the consequential work.
Figure 7.26 illustrates the complexity of change impact. A change request is
raised on one of the highest-level requirements. Part (a) shows the potential impact
using downwards traceability. Those boxes marked with a white circle are subject
to change assessment.
Part (b) then shows potential change using upwards impact. This occurs
because of a low-level requirement that ﬂows down from two higher requirements.
It is necessary to access upwards impact from these changes, because changes in a
low-level requirement may cause renegotiation at a higher level. Suddenly every-
thing in this example is potentially subject to change!
Of course, as engineers assess the real impact, it may be found that in fact
some of these requirements are not subject to change after all, and the cascade of
potential changes can thankfully be pruned, sometimes quite substantially.
The status of change can simply be measured in terms of the number of
requirements still in a suspect state. When a change request is raised, all other
requirements traceable downwards and upwards are marked as suspect. Then the
number of suspect requirements will steadily decrease as assessments are made of
each, their state is reset, possibly resulting in a cascade of others being reset as
well. The amount of residual change in a system will thus peak every time a new
change is introduced, and tail-off, as illustrated in Fig. 7.27.
A change proposal is
rasied here.
These need reviewing
for impact.
Maybe so do these
(upwards impact)
... and therefore these.
(downwards impact)
a
b
Fig. 7.26 Potential change resulting from a change request
184
7
Advanced Traceability

The above discussion of the change process supposes that change is propagated
from requirement to requirement purely through the existing set of links.
However, a change in a requirement may necessitate the addition or removal of
traceability links. Changes in links should propagate change to the connected
requirements at both ends.
7.16
Summary
Of all the advantages in the use of traceability cited in Chap. 1, Sect. 1.6, it is the
increase in conﬁdence in meeting requirements that is so clearly addressed through
rich traceability. The discipline of capturing the rationale associated with traceabil-
ity builds that conﬁdence.
There is no doubt that there is considerable effort involved in the creation of
complete satisfaction statements, especially in complex systems with hundreds of
requirements.
In the Network Rail project, there are some 500 satisfaction statements that
serve to decompose the high-level requirements through to subsystem require-
ments. A team of between two and ﬁve requirements engineers was dedicated to
the maintenance of this information over about 3 years.
Experience suggests, however, that the cost is amply repaid in the increased
conﬁdence that comes from the greater reﬂection required. The ability for the
Network Rail sponsor organisation to take a high-level objective, and demonstrate
in detail through the layers of rich traceability exactly how that objective is going
to be met, was a major selling point for the concept.
In a major project in the civil nuclear industry, after investing in the creation of
traceability from Programme Requirements to Project Function Requirements
No. of suspect requirements
time
Peaks indicate introduction
of change requests
Fig. 7.27 Progress in processing change
185
7.16
Summary

(system level) to Design Requirements (sub-system level), the main beneﬁt was
cited as coming from having captured design intent through the use of Satisfaction
Statements, something that had never been achieved before.
The idea of design intent is interesting. Without an explicit process for record-
ing the intentions of the designer, that intention has to be reverse-engineered every
time the design is revisited. Rich traceability—and the whole discipline of require-
ments engineering, for that matter—could therefore be characterised as supporting
intentional design. Traced requirements are a record of the purpose or intention
of the design.
It is clear, also, that traceability is a rich source of metrics for process measure-
ment. It is the formalisation of relationships through traceability and associated
processes that make such measurement possible.
186
7
Advanced Traceability

Chapter 8
DOORS: A Tool to Manage Requirements
There’s nothing remarkable about it. All one has to do
is hit the right keys at the right time and the instrument
plays itself.
Johann Sebastian Bach, composer, 1685–1750 AD
8.1
Introduction
Systems engineers and managers need the right instruments to assist them with the
requirements process. A variety of tools currently exist. This chapter presents an
overview of one of these tools—IBM Rational® DOORS® Next Generation
(Version 6.0.3) — “DOORS NG” for short.
DOORS (Dynamic Object Oriented Requirements System) is a leading require-
ments management tool used, in all its versions, by tens of thousands of engineers
around the world. The tool was originally created by QSS Ltd, Oxford and is now
developed and marketed by IBM. DOORS NG is the latest version, and is part of
a wider web-based collaborative life cycle management platform.
DOORS is a multi-platform, enterprise-wide requirements management tool
designed to capture, link, trace, analyse and manage a wide range of information to
ensure a project’s compliance to speciﬁed requirements and standards. DOORS
provides for the communication of business needs, allows cross-functional teams to
collaborate on development projects to meet these needs, and enables them to vali-
date that the right system is being built, and is being built right. The views provided
by DOORS on the screen provide a powerful familiar navigation mechanism.
Throughout this chapter reference will be made to a case study for a family
sailing boat.
The presentation of DOORS found here is not meant to be in any way exhaus-
tive. The full tool is too extensive to hope to cover in the context of this book.
187
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_8

The intention is to give enough information for the reader to appreciate what a
requirements management tool should do.
8.2
The Case for Requirements Management
Today, systems engineers require effective requirements management in order to
provide solutions. Requirements management is the process that captures, traces
and manages stakeholder needs and the changes that occur throughout a project’s
lifecycle. Products, too, are becoming more complex to the point where no indivi-
dual has the ability to comprehend the whole, nor understand all of its constituent
parts. Structuring is by far the best way of organising requirements, thus making
them more manageable in terms of omissions or duplicate information. Hence
requirements management is also about communication. For that reason it is
important that requirements are communicated correctly, thus ensuring that team
collaboration is enhanced, project risk is reduced and the project meets its business
objectives. If requirements are well managed, the right product will get to market
on time, on budget and to speciﬁcation.
8.3
DOORS Information Model
For the development of any system, the requirements and related information can
be stored in a central database in DOORS. This database can be accessed in a vari-
ety of ways and exists throughout the lifetime of the application.
Figure 8.1 shows the DOORS NG information model as a SysML Class
Diagram (see Chap. 3, Sect. 3.2.4.1.) Here is an explanation of the diagram:
• Everything in the database centres on artifacts. (Note that DOORS uses the
American spelling, which will now be used in this chapter.) Each artifact repre-
sents a piece of information, such as a requirement, a test case, a task, etc.
• Each artifact has an artifact type (for example, Stakeholder Requirement,
Veriﬁcation Method, etc.)
• Each artifact type may have a number of attributes.
• Each artifact type may have a number of link types.
• Artifact types and attributes are deﬁned per project, and so belong to a project
area. New artifact types and attributes can be deﬁned by the project owner.
• A project area also contains a hierarchical folder structure. Every artifact lives
in a folder or sub-folder. The folder structure is also under the control of the
project owner. A folder may contain a mixture of different kinds of artifact, as
well as sub-folders.
• There is a special kind of artifact called a collection, which can contain other
artifacts (including other collections.) While artifacts live physically in a folder,
188
8
DOORS: A Tool to Manage Requirements

they may also be assigned to belong to one or more collections—for instance,
the set of stakeholder requirements that are to do with safety; or the set of test
cases assigned to a particular team. Collections have no structure; they are an
unordered set of mixed types of artifact.
• In turn, there is a special kind of collection called a module—a name inherited
from previous versions of DOORS. Modules are intended to represent docu-
ments, and so can have a hierarchical heading structure with an arrangement of
various types of artifacts under the headings. So a module does not just contain
an artifact: it contains it in a particular sequence. Some of the artifacts in a
module can be designated as headings, and are displayed in a way that looks
like a document.
8.4
The Project Area
Figure 8.2 shows a project area in DOORS NG positioned in the “Artifacts” tab.
The project is called “Family Sailboat”. The left-hand panel shows the folders in
the project, and the right-hand panel shows the contents of the selected folder—
Windows explorer style.
Project Area
Name
+
Attribute
Artifact
Type
Artifact
Collection
Module
Module
position
Link Type
Name
+
Name
+
ID
+
Content
+
Heading?
+
Data Type
+
Name
+has artefact
+has artefact
+has artefact
+has type
+assign to
+assigned to
+has
attribute
+has sub-
folder
0..1
1
+
+
+
+
+
+
+
+
+
+
+
1
+has link type
+contained in
+
Labels
+
Folder
Name
+
Fig. 8.1 DOORS NG information model
189
8.4
The Project Area

Notice the folders are being used to represent the layers of requirements. In the
selected folder called “01—Stakeholder Requirements,” there is only one artifact:
“Stakeholder Requirements,” of type “Requirements Speciﬁcation.” This artifact is
in fact a module, and opening it shows the contents, as per Fig. 8.3.
Fig. 8.2 Project area window
Fig. 8.3 Module window
190
8
DOORS: A Tool to Manage Requirements

8.5
Modules as Documents
A module is displayed like a document. It has a mixture of different types of arti-
fact. Some are of type “Heading,” and so are displayed as such, and provide the
hierarchical heading structure of the document.
There are also several columns in the view, including an “ID” column, showing
a unique number assigned to the artifact by the tool, “Contents” (the primary text
of the artifact), and “Artifact Type.”
In Fig. 8.3, only the ﬁrst few artifacts of the modules are displayed, and they
are all of type Heading or Information. Figure 8.4 shows details from the module
further down, where we can see a diagram inserted as “Information” and some
requirements, whose artifact type is “Stakeholder Requirement.”
Fig. 8.4 Module detail
191
8.5
Modules as Documents

8.6
Artifacts
An artifact can be selected using the checkbox in the left-hand column. When
selected, the artifact is highlighted in pale orange. This is shown in Fig. 8.5, but in
grey-scale.
When selected, a pencil icon appears on the artifact. Activating this gives a
menu of options for arifacts, as shown in Fig. 8.6.
The menu item selected in Fig. 8.6 is “Insert New Artifact/After.” This creates
a new artifact of the same type after the selected one at the same level. Note the
other creation options: Before and Below, the latter meaning at one level below
the selected artifact.
An artifact can be edited by double-clicking the appropriate column.
Near the right-hand side of the window is a vertical “Show Sidebar” strip (see
Fig. 8.7), which, when clicked, opens an artifact properties panel, as shown in
Fig. 8.8.
The properties panel can be hidden by clicking on the vertical “Hide Sidebar”
strip, the darker coloured strip shown in Fig. 8.8 (highlighted in pale orange in the
actual tool).
Fig. 8.5 Selected artifact
192
8
DOORS: A Tool to Manage Requirements

Fig. 8.6 Artifact menu
Fig. 8.7 Show sidebar
193
8.6
Artifacts

At the top of the properties panel, there are two tabs, which allow the user to
view either the properties of the module that contains the selected artifact, or the
properties of the selected artifact itself. The latter is selected in Fig. 8.8.
The top half of the properties panel shows the attributes of the artefact and their
values. To edit these attributes, click the Edit button.
8.7
Traceability Links
Under the attributes section are a number of horizontal dividers that can be
expanded to show the “Artifact Comments” (not expanded in Fig. 8.8), “Artifact
Links” (expanded), and “Where Artifact Used” (not expanded).
Under “Artifact Links” can be seen three links of type “Satisﬁed By,” showing
the text of the linked artifacts. These other artifacts are in fact shown as links.
Moving the mouse over one of them pops up a window showing more details.
This feature is known as “rich hover,” and is shown in Fig. 8.9. It is available
wherever a linked artifact is displayed.
By clicking once on the linked artifact, the window will move to that artifact,
as shown in Fig. 8.10. In the properties panel on this artifact—which can be seen
Fig. 8.8 Artifact properties
194
8
DOORS: A Tool to Manage Requirements

Fig. 8.9 Rich hover
Fig. 8.10 Linked artifact
195
8.7
Traceability Links

to be a System Requirement—the reverse link is visible. Note that the “Satisﬁed
by” link is now shown as “Satisﬁes”; link relationships always have two names,
one for each direction: e.g. “Satisﬁed by/Satisﬁes,” “Veriﬁed by/Veriﬁes.”
Traceability can also be viewed in graphical form. In the “Links” section, there
is an icon that looks like this:
Clicking on this icon opens a window called “Diagram view of related links,”
as shown in Fig. 8.11.
This window shows the system requirement on the left, and the stakeholder require-
ments it satisﬁes on the right. The “Satisﬁes” arrow is to be read from left to right.
On the right-hand of the stakeholder requirement box in Fig. 8.11 can be seen
the “Expand links” tag. Clicking on this tag shows further relationships by
expanding the diagram, as shown in Fig. 8.12.
Clicking on the text of the requirement in any one of the boxes in the diagram
navigates to the linked artifact. The boxes also have the rich hover feature.
8.8
Views
DOORS NG supports the concepts of views in folders, collections and modules.
A view is deﬁned by selecting a set of columns and rows to display.
Fig. 8.11 Diagram view of related links
196
8
DOORS: A Tool to Manage Requirements

Columns are selected from a list of available attributes and link relationships,
and can be of three types:
• System attributes that are not editable, such as ID and Artifact Type.
• Editable attributes such as Content, and user-deﬁned attributes.
• Traceability columns that display information about linked attributes.
Rows are selected by applying ﬁlters; for instance, display only the artifacts of type
System Requirement (hiding other types of artifact, such as headings and Information.)
Figure 8.13 shows the Views control panel, which is an expandable panel on
the left-hand side of the window. It shows a list of the views available, three in
number in the example ﬁgure: Contribution, Default and Satisfaction.
If there are a large number of views, the user can search for a view by name
using the “Search Views” ﬁeld.
The highlighted view is the currently selected one—in this case “Satisfaction.”
Figure 8.14 shows the details of this view. It has columns as follows:
• ID, a system attribute;
• Contents, an editable attribute;
• Artifact Type, a system attribute;
• Satisfaction Statement, a user-deﬁned editable attribute;
• Satisﬁed by, a traceability column.
The purpose of the Satisfaction view is to show how requirements at this level
are satisﬁed by requirements at lower levels. It looks down the requirement layers,
capturing rationale for the ﬂow-down in the Satisfaction Statement column (see
Rich Traceability in Chap. 7, Sect. 7.5).
8.8.1
Rows in Views
Only certain artifacts are shown in the rows of this view, because the view
includes a ﬁlter. In the bottom left-hand side of the screen in Fig. 8.14 is the text
“Showing 76 of 86 artifacts”; this indicates that there is a ﬁlter applied.
Fig. 8.12 Expanded diagram view of related links
197
8.8
Views

Fig. 8.13 Views panel
Fig. 8.14 View columns
198
8
DOORS: A Tool to Manage Requirements

To see the ﬁlter, the user clicks on the “Expand ﬁlters” icon that looks like this:
The ﬁlter is then displayed as shown in Fig. 8.15, interpreted as: show any arti-
fact whose “Artifact Type is any of Heading, Stakeholder Requirement, System
Requirement.”
So this ﬁlter leaves out the information artifacts, as they are not of interest in
the Satisfaction view.
Filters can be edited, removed and added using the three controls shown:
8.8.2
Columns in Views
The choice of columns to display in a view is made by clicking on the following
icon:
This shows the menu captured in Fig. 8.16, which offers a quick selection
menu, and a more functional means of arranging column by selecting “Conﬁgure
Columns to Display.”
In the quick selection menu, some of the columns are for attributes, and others
for link relationships. A link relationship column displays linked artifacts under
the named relationship.
For example, in the middle of Fig. 8.14 is an artifact numbered 395. This is a
stakeholder requirement that traces down to four systems requirements. The details
are shown in Fig. 8.17.
Note that the “Satisﬁed By” column shows linked attributes in the usual fash-
ion, with rich hover and navigation by clicking.
Fig. 8.15 Filter example
199
8.8
Views

Editable attributes can be modiﬁed directly in the column by hovering over the
cell, and clicking on the pencil icon that appears:
Fig. 8.16 Selecting columns
Fig. 8.17 Rich traceability example
200
8
DOORS: A Tool to Manage Requirements

Note that, because the attribute displayed in a column may only apply to some
of the artifact types, some of the cells are quite rightly not editable. For instance,
Satisfaction Statement does not apply to artifacts of type Information.
The traceability columns that display linked artifacts are also editable, in that
the pencil icon allows links to be created and deleted (Fig. 8.18).
The “Add Link” option displays the window shown in Fig. 8.19. Here the
right-hand panel serves to ﬁlter the possible destination artifacts. In the example
shown, the list of possible destination artifacts is ﬁltered to show only those of
type System Requirement.
The link is created by selecting the appropriate artifact on the left-hand side. It
will then appear in the tracebility column in the module view.
8.9
Artifact Types and Attributes
Artifact types and their attributes are deﬁned and managed at the Project level. To
access them, use the menu attached to the settings icon:
The full menu is shown in Fig. 8.20, and the item in question is “Manage
Project Properties.”
Figure 8.21 shows the Project Properties window. Near the top is a series of
tabs marked “Artifact Types,” “Artifact Attributes,” “Attribute Data Types,” etc.
The window is positioned on the Artifact Types tab.
Fig. 8.18 Editing a
traceability column
201
8.9
Artifact Types and Attributes

Fig. 8.20 Settings menu
Fig. 8.19 Adding a link
202
8
DOORS: A Tool to Manage Requirements

The existing artifact types are listed down the left-hand side, and the details of
the selected type (Stakeholder Requirement) are in the right-hand panel. A new
artifact type can be created by clicking on “New Type,” and by ﬁlling out the
properties form.
Half way down the properties panel is a ﬁeld called “Preferred link types.”
This ﬁeld is used to select the relationships that the artifact is allowed to engage
in. The list of available link types is managed on the “Link Types” tab.
At the bottom of the properties panel can be seen the list of attributes assigned
to this artifact type. For instance, “Satisfaction Statement” appears at the top of
the list. Attributes can be added at will by clicking on “Add attribute.”
Figure 8.22 shows the Attributes tab of the Project Properties window. Down
the left-hand are listed the available attributes, and the properties of the selected
attribute on the right-hand.
New attributes are created by clicking on “New Attribute.”
Attributes have a “Data type” drawn from a list of those available. New data
types can be deﬁned on the “Attribute Data Types” tab.
Fig. 8.21 Project properties—artifact types
203
8.9
Artifact Types and Attributes

Fig. 8.22 Project properties—artifact attributes
Fig. 8.23 Report window
204
8
DOORS: A Tool to Manage Requirements

Not all the project property tabs are explained here—just those necessary to
give an understanding of the concepts.
8.10
Import and Export
A tool like DOORS makes possible a data-centric approach to requirements engi-
neering. A vital aspect of such an approach is the ability to generate documents
and reports from the database.
On Fig. 8.13, in the menu bar near the top of the window, is a menu called
“Reports”. Clicking on this shows the window shown in Fig. 8.23. Clicking on
“Generate a report” starts a wizard that allows the user to select from a number of
pre-deﬁned reports that produce PDF or Word documents.
Figure 8.24 shows an example export.
User-deﬁned reports can be created through use of another IBM tool called
“Rational Publishing Engine.”
Fig. 8.24 Example report
205
8.10
Import and Export

8.11
Summary
A brief overview of a requirements management tool, DOORS, has been given in
this chapter. The example used shows the application of some of the principles
used in the book, e.g. instantiations of the generic process in layers, rich traceabil-
ity, etc.
The same principles can be applied and implemented in other requirements
management tools. Even if one is just using a word processor, the disciplines
described within the covers of this book will be beneﬁcial.
206
8
DOORS: A Tool to Manage Requirements

Chapter 9
Management Aspects of Requirements
Engineering
In theory there is no difference between theory and
practice. In practice there is.
Yogi Berra, baseball player, 1925–2015 AD
9.1
Introduction to Management
The management of the requirements engineering process is similar to the manage-
ment of any other endeavour. Before starting out it is necessary to understand what
needs to be done. We need to know the sorts of activities that must be undertaken.
We need to know whether there are any dependencies between the activities, e.g.
whether one activity can only commence when another one has been completed.
We need to know what kinds of skills are required to perform the activities.
It is good practice when preparing a plan to concentrate on the outputs that will
be generated by each activity. Outputs can be seen and provide tangible evidence
that work has been or is being done.
From all of this information we can generate a plan in which we have identiﬁed
the activities to be undertaken, the people who will perform the activities and the
time it will take them to complete the activities. We can then start work following
the plan and the manager can monitor work against the plan. In an ideal world the
plan will be followed to the letter. Nothing will go wrong and we shall arrive at
the completion date of the plan with all the work done.
Reality can be quite different. Firstly, estimating the time and effort required to
complete a task is very difﬁcult unless the manager has extensive experience of
tackling similar jobs in the past. Secondly, there may be difﬁculties discovered as
work progresses that could not have been foreseen. For example, the plan may
have relied on the availability of a key person at a speciﬁc time and, for any num-
ber of reasons, that person is not able to be there.
207
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3_9

These events cause deviations from the plan and lead to the need to change it.
Once a new plan has been put in place, the whole process is repeated. A frequent
consequence of changing the plan is that, almost inevitably, the cost will increase
and/or the time to completion will be later than previously estimated. An alternative
approach is to keep the costs and completion time constant and reduce the amount
of work to be done. This can be a viable strategy in some circumstances; for exam-
ple, it may be imperative that a company has a new product out in the market place
at a given time (to address the competition) and within a given budget (because that
is all the company can afford) irrespective of how capable the product is (although
at least a threshold level is usually necessary to avoid triviality). This situation is
typical of the way in which commercial pressures can drive a project.
It is important to recognise that any project is constrained by the three factors:
• Product capability;
• Cost;
• Timescale.
These three factors are related as indicated in the diagram of Fig. 9.1. Any
change to one of these factors will have a consequential change to at least one of
the others. Figure 9.1 also indicates that projects make progress by taking deci-
sions. Every decision positions the project with respect to these three fundamental
factors. It is the pipe dream of every project manager that each decision will
improve the product capability whilst simultaneously reducing cost and shortening
development time. In spite of its improbability, this dream is widely held.
9.2
Requirements Management Problems
This section introduces the speciﬁc problems that make the management of require-
ments more difﬁcult than some other management activities. The ﬁrst problem is
that very few people have had signiﬁcant experience of managing requirements.
Product
Capability
Decisions
Cost
Time
Better
Cheaper
Faster
Fig. 9.1 Capability, cost and
time are interrelated
208
9
Management Aspects of Requirements Engineering

This is mainly because very few organisations have a deﬁned requirements manage-
ment process that is followed across the organisation. As a result people faced with
a project that must address requirements, have very little experience to draw on.
This makes estimation very difﬁcult, because one of the main ingredients to the pro-
duction of good estimates is extensive relevant experience. Thus the starting point
is not good and one is reminded of the joke in which one person asks another the
way to a speciﬁc place and receives the reply “I wouldn’t start from here”!
A corollary of this problem is more fundamental. If people have had little
experience of requirements management, they may not even know what activities
are necessary to develop requirements. Earlier chapters of this book have
addressed this issue and give direct guidance on the sorts of activities necessary to
develop requirements of various types and in several contexts.
The second problem is that many people do not properly distinguish between user
or stakeholder requirements and system requirements. Further they often do not dis-
tinguish between system requirements and design speciﬁcations. In other words they
go straight for a solution rather than deﬁning a solution-independent set of require-
ments. Again this topic has been dealt with in the preceding chapters of this book.
The third main problem is that the way in which requirements are managed
will depend upon the type of organisation in which the work is being done. In the
preceding chapters we have discussed the different types of requirements and indi-
cated how they are related. However, the way in which these processes are applied
will depend upon the type of organisation applying them. There are three main
types of organisation:
• Acquisition organisations that purchase systems and then use them to provide
an operational capability. These organisations are mainly concerned with creat-
ing and managing Stakeholder requirements, which subsequently are used as
the basis for acceptance of the delivered system.
• Supplier organisations that respond to acquisition requests from Acquisition
organisations or higher level Supplier organisations. These organisations
receive Input Requirements and develop system requirements (and subse-
quently a design that is manufactured) in response to them. (Suppliers may also
be acquirers of lower level subsystems or components, but this is a quite differ-
ent form of acquisition because it is based on a design architecture.)
• Product companies that develop and sell products. These organisations collect
Stakeholder requirements but from their market place rather than from individuals
or from operations organisations. The marketing department usually performs the
collection of requirements. Product companies develop products in response to
the stakeholder (marketing) requirements and sell the developed products. In a
sense these types of organisations encompass both acquisition and supply, but
they tend to have a different relationship between the parts of the company that
perform these roles compared to the standard acquisition and supplier relationship.
We will return to these types of organisation later in this chapter.
The fourth problem that makes the management of requirements more difﬁcult
than some other management activities is that it is quite difﬁcult to monitor
209
9.2
Requirements Management Problems

progress when requirements are being generated. One difﬁcult issue is to know
whether the requirements set is complete—in order to decide whether the activity
should stop. Even worse is the problem of determining how much progress has
been made when the activity is nowhere near completion. This problem is further
exacerbated by the need to assess the quality of the requirements generated. A
long list of requirements may have been generated, but how does the manager
assess whether each requirement is well expressed? How can he tell whether each
requirement is unique and whether they are all necessary?
The ﬁnal problem is the perennial problem of changes. Requirements manage-
ment should be the primary focus for change management. Any proposed change
will usually relate to one or more requirements. The impact or knock-on effects of
proposed changes are quite often difﬁcult to assess, yet without this knowledge it
is impossible to estimate the cost and time impact of introducing a change.
9.2.1
Summary of Requirement Management Problems
Speciﬁc management issues for requirements development arise in connection with:
• Planning;
• Monitoring progress;
• Controlling changes.
The problems are subtly different depending on the organisation involved.
Therefore, in the rest of this chapter we consider each of these activities in the
context of the three types of organisations introduced earlier. Finally we draw
together some common approaches in a concluding section.
9.3
Managing Requirements in an Acquisition Organisation
9.3.1
Planning
The starting point for a project in an Acquisition Organisation will be some form of
concept description. In its most basic form this will be just an idea, but usually it will
be more concrete and well founded. The reason for this is simple: projects must be
authorised by the organisation and the authorisation process will require some docu-
mented evidence to support the case for spending time and money (resources). The
evidence usually contains a brief description of what the users want to be able to do
(the concept) and a supporting argument to indicate the beneﬁts that will ensue to
the operating organisation from the provision of such a capability.
The information in the concept deﬁnition enables the project manager to begin
planning. Since the concept deﬁnition contains a description of what the users
want to be able to do we immediately have an initial set of Stakeholders (users)
for the system and an outline of one or more Scenarios (ability to do something).
210
9
Management Aspects of Requirements Engineering

The ﬁrst step in constructing a plan consists of identifying a fuller set of
Stakeholder types and a more complete set of Scenarios that cover the complete range
of expected operation of the system including, where useful, different modes of opera-
tion. Once the number of stakeholder types is known it is possible to plan in detail
how to set about eliciting requirements. Actions that may be instantiated in the plan
include:
a. Plan to interview one or more candidates of each stakeholder type. The
requirements manager is responsible for ensuring that authorisation to conduct
the interviews is obtained from the candidates’ managers. Authorisation may
depend upon appropriate job codes and budgets being agreed (so that the can-
didates interviewed can book their time to the new project and consequently
their managers are not penalised for their staff’s absence whilst being inter-
viewed). The requirements manager should also ensure that access to key
operations staff is provided. Often the candidates’ managers will be unwilling
to release their most competent (useful and well informed) staff for an activity
that is not in their short-term interests. It is up to the requirements manager to
convince them of the value of doing so.
b. Allocate time to write up the interviews as interview reports and agree them
with candidates interviewed.
c. Decide the interview strategy and communicate to the interviewers (who may
be involved in the decision process anyway). The interview strategy will deter-
mine how each interview is conducted, for example, whether candidates
should be prompted to express scenarios themselves, or be presented with a
suggested scenario that they can criticise etc.
d. Prior to the interviews it can be useful (but not necessarily easy) to get all the
candidates together and explain the purpose of the interviews. If such a meet-
ing can be arranged, it provides an excellent forum in which to discuss/
develop user scenarios and to seek conﬁrmation that all stakeholder types have
been identiﬁed.
e. Agree and document the set of user scenarios that best reﬂect the purpose and
operation of the system in its context. It is essential to ensure that the scenarios
are not too blinkered in their scope.
f. Following the interviews, suggested stakeholder requirements can be extracted
from the interview reports and agreed with the interview candidates.
g. Decide on a structure into which each of the stakeholder requirements can be
entered.
h. Place each identiﬁed stakeholder requirement within the agreed structure and
modify the structure as necessary.
i. Identify and record any constraints. Some constraints are product requirements
such as physical size. Others are plan constraints such as budgeted cost and
completion time. The product constraints should be entered into the set of
Stakeholder Requirements. The planning constraints (such as budget, schedule,
resource or quality) belong in the management plan and will have an inﬂuence
on the planning activity.
211
9.3
Managing Requirements in an Acquisition Organisation

j. Decide whether additional attributes are required to support the text of the
requirements. Many organisations have standard sets of attributes that may be
required or are merely advisory. Examples are: Priority, Urgency, Status,
Validation method, Acceptance criterion.
k. Agree the criteria for the review of each individual requirement and for the
requirement set as a whole. These criteria are best presented as a checklist for
the reviewers. Ideally the review criteria should be created as early as possible
and distributed to the people writing the requirements. This enables them to
appreciate what is required of them before they start to write.
l. Deﬁne the review process and relate this to the status of the individual require-
ments. This process can be summarised as a state transition diagram as shown
in Fig. 9.2. This shows that the initial state of a stakeholder requirement is
“Proposed.” When the requirements management team has reviewed it, it can
move to the Reviewed status. Reviewed requirements can then be subjected to
a further review by the Sponsor’s team and, when successful, will achieve
Endorsed status. Note that, at any time, an Active requirement can be rejected.
Review criteria must be determined for each review.
m. Perform reviews as required by the review procedure deﬁned.
Active
Proposed
Requirements Management
Team Review
Sponsors’ Team Review
Reviewed
Endorsed
Rejected
Fig. 9.2 Example state tran-
sition diagram for stakeholder
requirement status
212
9
Management Aspects of Requirements Engineering

This list of activities implies the need for several decisions to be taken. This is
the requirements manager’s responsibility in collaboration with other interested
parties such as the interview candidates, their managers and the overall sponsor
for the system.
Care should be taken to assess any planning constraints to ensure that they are
feasible and sensible. Stakeholders may demand that the system is put in service
in a very short period of time and at low cost, but this may not be possible. A
prime example of an unrealistic time constraint comes from the London
Ambulance System developed to control ambulances in London in the early 90’s.
The managers wanted to have the system in place so that they could supply the
government with the performance statistics they were demanding. This very short
development period and early in-service date were placed on the project as overall
constraints, but were absolutely impossible to meet. Many contractors tried to per-
suade the ambulance service that it was impossible to meet these constraints and
asked for the in-service date to be put back. These requests were refused and so
many contractors did not bid. This left less experienced contractors to attempt to
meet the impossible constraint. History shows that they completely failed to meet
the demanded deadline and in the process caused serious harm to many people.
Realism in planning is essential for professional integrity.
9.3.2
Monitoring
Monitoring can start once the plan is in place. Obvious monitoring points are the
completion of each activity in the plan. In the early stages the activities will
mainly revolve around preparing for the interviews, conducting them and report-
ing on them. These are quite easy to assess.
Three major milestones help to deﬁne the monitoring for the rest of the process:
1. The deﬁnition of the structure for the requirements document;
2. The deﬁnition of the attributes required for each requirement; and
3. The deﬁnition of the review process(es) with associated checklists.
Once the structure is in place it is possible to determine whether there are any
areas where there should be requirements but none exist. These “holes” can be
addressed by speciﬁc actions.
Once the attributes have been decided, progress in ﬁlling them can be monitored.
Finally, the progress against satisfying the review checklist criteria can be
checked by measuring the number of requirements that have a speciﬁc status.
9.3.3
Changes
During the development of stakeholder requirements there will be a period of rapid
and intense change. At this stage it is not sensible to have a formal change control
process in place, because the situation is too dynamic and would just get in the
213
9.3
Managing Requirements in an Acquisition Organisation

way. However, at some point stability will begin to emerge and the requirements
manager can determine when the requirements are sufﬁciently stable to subject
further changes to a more formal process. Often this stage only occurs once all the
requirements have been reviewed and reach the Endorsed state (see Fig. 9.2).
Managing change is a vital activity in requirements development. The formality
with which the process must be applied depends upon the development state of
the project. Important stages include the following:
• Stakeholder Requirements used as the basis for a competitive bidding process
• Contract in place for the development of a system
• Design complete and manufacturing about to start
• Acceptance trials are being undertaken
• The system is in service
This list deﬁnes a set of points in a sequence of increasing commitment. Hence
the further down this list a project is, the more formality is required in the change
control process and the higher the likely cost impact of any change.
Whatever stage a project is at, the following steps are required in a change con-
trol process:
1. Record the suggested change
2. Identify the impact of the suggested change
3. Decide whether to accept the change
4. Decide when to implement the change
The suggested change should indicate the reason for the change and identify
the stakeholder requirements that must be changed, added or deleted. The person
or organisation requesting the change must also be recorded.
At step 2 the impact will depend upon the stage at which the change is sug-
gested and this will require information about how the impacted requirements will
inﬂuence the downstream information such as system requirements, design, manu-
facturing and in-service operations.
A Change Control Board will take step 3. The constitution of this board will
depend upon the organisation, the scale of the system, and the stage of develop-
ment or operational use of the system. If a change is accepted, then Step 4 is
required. It may be that the change must be incorporated immediately irrespective
of cost. Alternatively the change may be deferred until a later release of the sys-
tem. Any number of intermediate points may be appropriate and this clearly
depends on circumstances.
It is always useful to have a set of states for a change and to represent this
using a state transition diagram or statechart. Figure 9.3 contains an example.
It is also important to decide whether the status of requirements that are the sub-
ject of a change proposal should be changed to indicate this. There are at least two
schools of thought on this point. One group takes the view that the dependency
between the change and the requirements is held in the change proposal and hence
it is not necessary to modify the requirement’s status. Another group takes the view
that when it has been decided that a change proposal will be incorporated, this
means that the requirement is subject to change and this indicates that its review
214
9
Management Aspects of Requirements Engineering

status has changed. (This is the view taken in Chap. 2.) Whatever position is
adopted, it is necessary to decide on the status values for change proposals and
whether these have any impact on the review status of the affected requirements.
In summary, Acquisition organisations are mainly concerned with the creation
of stakeholder requirements. This is a creative process that is difﬁcult to scope
initially. However, as the work progresses and the numbers of stakeholders and
scenarios are agreed, it is possible to plan more accurately.
Change control starts off with little formality, but this evolves as the project
matures through development, manufacture and in-service operation.
9.4
Supplier Organisations
Supplier organisations respond to requests from customers to build systems or
components for systems. Prior to obtaining a contract to build a system, they must
prepare a proposal to indicate how they intend to go about the job and containing
estimates of cost and time to complete the work. Often proposals are requested
from a number of supplier organisations that compete to get the business. It is
therefore useful to consider supplier organisations from two points of view: bid-
ding for work and executing a contract once the work has been won.
9.4.1
Bid Management
This section looks at the management aspects of the process to create a proposal
in response to a customer’s set of requirements.
Proposed
Rejected
Deferred
Agreed
Planned
Incorporated
Fig. 9.3 State transition dia-
gram for change control
215
9.4
Supplier Organisations

9.4.1.1
Planning
Often the starting point for requirements management within a supplier organisa-
tion will be the receipt of an Invitation to Tender (ITT), also known as a Request
for Proposal (RFP). Such an invitation or request will contain a set of require-
ments that must be satisﬁed by the system to be delivered.
The nature of the requirements received will depend upon the organisation type
of the customer (i.e. the organisation that issued the invitation). If the customer is
an acquisition organisation it is likely that the requirements may be stakeholder
requirements. Alternatively, the customer may be another supplier organisation
that is planning to sub-contract one or more subsystems in a higher level system.
In this case the requirements are likely to be system requirements with imposed
design constraints. To make the narrative clearer we shall refer to the requirements
received by a supplier as Input Requirements irrespective of what they really are.
Whatever the nature of the input requirements received, the ﬁrst task is to
assess them to determine whether they are:
• Clearly identiﬁed and distinguished from purely descriptive information
• Unambiguous
• Consistent
• Free from undue design constraints
In short, it is to determine whether they form a sound basis upon which to bid.
From a planning point of view, it is important to identify the number of
requirements that must be satisﬁed. This provides a metric that can be used to get
an idea of the scope of the work to be done.
During the review of the input requirements, any problems must be highlighted by
identifying speciﬁc problems and proposing a potential solution for them. Such solu-
tions may involve suggesting alternative wording for the requirements, or even alter-
native requirements that can be satisﬁed—perhaps with off-the-shelf components.
Once the review has been undertaken, the problems it identiﬁes must be
addressed. This will usually involve entering a dialogue with the customer to
obtain clariﬁcation or authorisation for a proposed change. The extent of this dia-
logue will depend upon the conditions attached to the invitation. If the invitation
is to a single supplier the dialogue can be entered into immediately.
However, if the invitation comes as part of a competitive bid it may be necessary
to be more circumspect. The reason for this is that, usually the competition rules
insist that any queries from one potential supplier are copied (together with the cus-
tomer’s response) to all the other potential suppliers. Hence, it is possible that, by
asking questions, one supplier can give information to the other competing suppli-
ers. In this situation, it may be more appropriate to ﬂag the problems and observa-
tions, but rather than going back to the customer with them, discuss them internally
and decide how to handle them. Possible options for each problem include:
• Ignore it
• Make an assumption and document it
• Decide that it is essential to ask the customer whatever the consequences.
216
9
Management Aspects of Requirements Engineering

The last action may lead to a further action to formulate the request to the cus-
tomer in such a way that the competitors are helped least.
In parallel with sorting out the Input Requirements, work must proceed on creat-
ing a proposed solution. Obviously the primary output from this work is the propo-
sal ready to be submitted to the customer. There are many different approaches to
the creation of a proposal, but they all involve ensuring that each input requirement
is properly addressed. The bid manager must allocate each requirement to an indi-
vidual or team who will be responsible for creating a response.
It is vital that all these responses be coherent, otherwise the proposal could end up
proposing a random and disconnected set of bits and pieces. The best way of achiev-
ing this is to create a model that can form the basis for the solution. Depending on the
nature of the proposal, this could be either an abstract model that can form the basis
for building a set of system requirements, or it can be an outline design architecture.
Each response to an input requirement can then be related to the model. This provides
traceability from the input requirements and it provides the coherence so that incon-
sistencies can be identiﬁed. The problem is always that the people working on the
solution must work with incomplete information based on documented assumptions
and potentially best guesses at what the customer really meant. However, this is life!
At the end of the bid phase, when the proposal has been submitted, it is impor-
tant that the bid team record all the information they have accumulated during the
bid preparation. The bid team will quite often be under extreme pressure to ﬁnalise
and submit the bid by the required submission date. Often, they will be ready to
take a break and may forget to properly record all the information in a form that
can be used by the development team later. For large proposals the amount of
information can be signiﬁcant and also the delay between submitting the proposal
and starting development can be long (e.g. 6–8 months). In these circumstances it
is even more important that information is recorded, because the development
team may not have any people who were involved in the bid preparation, and
even if it does, after a signiﬁcant period of time, they are likely to have forgotten
some of the key assumptions and rationales.
A further important activity during the bid phase is the setting up of agreements
with suppliers. These will usually be made conditional on the bid being successful,
but they will have an impact on the level of detail to which the solution is developed.
The basis of an agreement between a supplier organisation and its suppliers must be
founded on a set of requirements for the components to be supplied. The level of
detail that is required during the bid phase will be set by agreement between the
organisations involved. This will depend upon the nature of the working relationship
that exists between the organisations and the degree of experience and trust that
exists. (See Agreement Process in the Generic Process introduced in Chap. 2.)
9.4.1.2
Monitoring
Measuring progress during the creation of a proposal is vital, because timescales
are usually quite constrained and the submission date is not negotiable. The end
217
9.4
Supplier Organisations

point must be that the proposal clearly indicates how each input requirement will
be met. However, merely asserting how a requirement will be met is not sufﬁcient.
It is also necessary to check that all the assertions are valid. This is an aspect of
the review process, but an indication of progress can be obtained by comparing
the percentage of input requirements that have been traced to the solution model
(and hence to either system requirements or design components).
A measure of the amount of outstanding work to be done can be obtained by
assessing the number of input requirements that still have outstanding problems
logged against them together with the number of input requirements that still have
no proposed solution.
Another important milestone in the development of a solution is the creation of
a model that the team are content with. Ensuring that such a model is produced
quickly and that there is “buy in” is a crucial task for the manager.
In addition to all of these monitoring devices, a measure of the quality of the
system requirements must also be made. This can be done in a similar manner to
that described above for acquisition organisations monitoring the creation of stake-
holder requirements, by deﬁning states and linking the progression through those
states to review criteria.
9.4.1.3
Changes
During the preparation of a proposal there are three potential sources of change:
• Customer
• Suppliers
• Internal
One might think that there would be no customer changes during the prepara-
tion of a proposal, and ideally this would be true. However, it is safest not to
assume this. Typically the probability of change is roughly proportional to the size
of the system (or component) to be developed. For very large systems, suppliers
often commence their bidding activities with an early draft of an RFP in order to
get the bid team running and thinking along the right lines. Later versions are
issued at intervals and may contain signiﬁcant changes.
The ﬁrst task on receipt of a new version of the RFP (or its requirements) is to
determine the nature and extent of the changes. Depending on the customer and the
medium used to issue the RFP, the location of the changes may be highlighted or
completely unknown. Once found, the changes must be related to the work already
done and an assessment made of the new work and rework that is now necessary.
Changes from customers can also come via responses to queries from bidders.
These are usually well focussed and can be assessed quite readily.
Changes instigated by suppliers are more likely. These may be in response to
an initial request for a proposal to indicate that they cannot meet the requirements
as deﬁned, or the changes may come later in the process when the supplier dis-
covers that what was originally thought to be possible turns out not to be.
218
9
Management Aspects of Requirements Engineering

Internal changes arise for much the same reasons as the suppliers’ changes.
Initial assumptions turn out to be invalid and therefore an alternative approach
must be taken.
Whatever the source of the change, it is essential that the various requirements
baselines are kept up-to-date, i.e.:
• Input requirements
• Requirements placed on suppliers
• Assumptions and interpretations made within the bid team
9.4.2
Development
9.4.2.1
Planning
The development stage of a project commences with an agreed contract based on
the proposal submitted to the customer and modiﬁed during contract negotiations.
In addition to this there will be other information generated during the bidding
process, but not necessarily incorporated into the proposal. This may include
detailed requirements, assumptions, outline or detailed design information and an
initial assessment of the risks involved in undertaking the development. This infor-
mation will have been used to arrive at the estimated time and cost of the work.
The activities involved in the development stage have to be more considered
and in much more detail than those at the proposal preparation or bidding stage.
One important difference is that instead of producing a proposal, the proposal pre-
viously submitted may now be part of the input requirements.
The information generated during development activities will depend upon the
nature of the development but will inevitably include the creation of a solution
model. This may be done in two stages, ﬁrstly producing an abstract model and sec-
ondly producing one or more potential design solutions. If more than one solution
is created, then it will be necessary to deﬁne the criteria for making a comparative
assessment of the solutions and then deciding which one to take forward. This com-
parative assessment leads to the creation of options and the possibility of trading off
some requirements against others. This trade off may be done entirely internal to
the supplier organisation or it may involve the customer and/or the suppliers.
Activities are necessary to ensure that all the input requirements in the contrac-
tual speciﬁcation are addressed, that the proposed solution embodied in the system
requirements and design is adequate. The level of detail will usually have to be
improved to ensure that, at the most detailed level, nothing is left to chance.
During the development stage it is important to ensure that the means of testing
(or otherwise demonstrating the satisfaction of) each requirement is understood
and documented.
The ﬁrst step is to undertake an audit of the available information to determine
its extent and quality. Ideally all the information created by the bid team should
have been collected together and archived ready for use in the development
219
9.4
Supplier Organisations

process. All too frequently this is not the case and signiﬁcant information can be
lost. This can cause a major discontinuity between the intentions of the bid team
and what is actually done by the development team. This, in turn, can put the
organisation’s business at risk.
Following the audit the project manager must determine, by comparing the pro-
posal submitted with the contract, what has changed since the proposal was sub-
mitted. The next step is to determine what the impact of these changes will be and
to plan activities to make any consequential changes to the system requirements,
design and component speciﬁcations.
Any outstanding assumptions and comments must be referred back to the cus-
tomer, although ideally these will have been addressed during the negotiation of
the contract.
A further issue that often arises when planning a development is whether the
system will be delivered with full functionality at once, or whether there will be a
series of releases with increasing functionality culminating with the ﬁnal complete
release. Supplying a series of releases provides the customer with an initial cap-
ability early. This approach is very popular in software development where there
may be some doubts about the usability of the system.
From a requirements management point of view, releases must be planned on
the basis of the set of requirements that will be implemented in each release.
These decisions can be recorded by adding a release attribute to each requirement.
Such attributes can either be enumerated lists or Boolean. A set of possible values
for an enumeration list would be:
{TBD, Release 1, Release 2, Release 3}
(Where TBD stands for “To Be Decided” and will usually be the default value).
When using Boolean attributes each has the value True or False and one is cre-
ated for each release.
9.4.2.2
Monitoring
Monitoring progress during the development should be focussed on assessing the
current extent and quality of the output information to be generated. It is also vital
to know how much time and effort has been consumed. From this knowledge it is
possible to estimate whether the outputs will be complete within the effort and
time allowed in the plan. This estimate must take into account the manager’s
knowledge of when or at what rate the information outputs are expected to be
achieved.
If the manager discovers that progress is lagging behind the plan, then appropriate
corrective actions can be taken. These will inevitably lead to a change in the plan,
such as adjusting the duration or resources of existing activities, or adding extra
activities.
The monitoring activities must ensure that project information is up-to-date. It
is especially important that input requirements and supplier requirements are
220
9
Management Aspects of Requirements Engineering

modiﬁed in line with agreed changes and that traceability links exist from input
requirements through to supplier requirements via the proposed solution.
9.4.2.3
Changes
The same three sources of changes arise in the development as already identiﬁed in
the bidding stage. The extent of customer changes is likely to be far less during
development than during bidding. Internal and supplier changes are just as likely.
The procedure for identifying the nature and consequence of any change is just the
same. However, the consequence of a change at this point is far more serious. Small
changes can be accommodated within the customer contract or supplier agreement.
However, more serious changes may require a change to the terms and conditions of
either. Changes introduced during development will usually have an impact on both
the time scale (schedule) of the development and the cost. Once the consequences
have been determined, it is then a commercial decision whether to absorb any cost
and time penalties or whether to negotiate with the customer and/or suppliers.
When a change is proposed for a development with several releases, it is a function
of change management to decide which release the change will be implemented in.
In summary, Supplier organisations respond to customer requests by preparing
a proposal and if successful they go on to develop a system. Making sure that the
requirements issued by the customer are a sound basis for the development is of
prime importance. Keeping the input requirements up-to-date as changes are intro-
duced ensures that the project is soundly based. Traceability from the input
requirements to the proposed solution, to their suppliers’ requirements and to test-
ing information ensures that the impact of change can be assessed and that the
organisation at all times knows the status of the development.
9.5
Product Organisations
Product organisations deﬁne stakeholder requirements and develop a product to
satisfy them. Thus they have many of the characteristics of Acquisition and
Supplier organisations. The main difference is that the customer-supplier agree-
ment at the top level of the supply chain is within the overall organisation,
although different departments usually undertake the roles of deﬁning stakeholder
requirements and developing products to satisfy them.
9.5.1
Planning
9.5.1.1
Single Product Version
Planning for a single version of a single product involves the same activities as for
the acquisition and the supplier organisations. The difference between the bidding
and the development stages may still be there. For example, when starting a new
221
9.5
Product Organisations

product, the company may want to have an initial idea of what is involved in
building it. To achieve this it is necessary to elicit the stakeholder requirements
and to produce an outline solution.
Producing the stakeholder requirements is very similar to the way in which
acquisition organisations do it. There is a need to identify stakeholders and user sce-
narios. However, rather than interviewing real stakeholders, what usually happens
is that people volunteer (or are volunteered) to act as “surrogate” stakeholders. This
means that they adopt the role of a deﬁned stakeholder and deﬁne, from that point
of view, what the stakeholder requirements are. From a planning point of view there
is little difference. People must still be identiﬁed and interviewed. Requirements
must be extracted, properly formulated and embodied in an agreed structure. Finally
the requirements must be reviewed and their quality established.
Producing an outline solution is very similar to the work done when creating a
proposal. The main difference is that there is direct access to the people who are
formulating the requirements and hence there is the possibility of a much more
interactive development where the stakeholder requirements can be modiﬁed to
make implementation easier, to reduce time to market and to reduce cost. It is even
possible that the capability of a proposed product can be enhanced within the given
budget by feeding back technical possibilities to the owners of the stakeholder
requirements. It is clearly much easier to gain clariﬁcation where requirements are
vague or confusing etc. This may sound very informal, and in some cases, it can
be. However, the degree of formality must be agreed prior to starting the work.
When an agreed set of stakeholder requirements and an outline solution have
been produced and reviewed by the product organisation, it may decide not to pro-
ceed with the development or it may decide to invest further funds and go to a
more detailed design or even to produce an early prototype. Thus it can be seen
that a product can proceed by means of a set of stages where each stage builds
upon previous work. Each stage has a given budget and a set of objectives. At the
end of each stage there is a review at which progress against the budget and the
objectives is assessed. This procedure can be described using the stage gate con-
cept as indicated in Fig. 9.4.
At the initial gate (Stage Gate 0), a set of objectives, budget and timescale are
deﬁned. These feed into a planning process which determines the information
which must be generated in order to achieve the stage’s objectives and a work
plan which will achieve the required state within the budget. The initial objective
may be merely an exploration of the concept and some preliminary estimation of
market size etc. At the end of the stage the work done is reviewed against the
objectives to determine whether the project should continue or whether it should
stop. This review should also take into account the current business objectives,
which may have changed or evolved during the stage.
If the project is allowed to continue then a further budget, timescale and objec-
tives will be agreed. For the second stage it may be decided to go for a costed pro-
posal as discussed above and a more detailed exploration of market conditions.
The stage gate review will then check whether the estimated cost is in line with
the expected revenue that can be earned. This leads naturally into a decision to
222
9
Management Aspects of Requirements Engineering

cancel or commit further funds. If the latter, then a decision has to be taken about
how far the development should be taken, e.g.
• Do more investigation into the development and production costs;
• Develop a prototype;
• Produce a small batch and try them out with real customers;
• Go into full production;
• Etc.
Thus the stage gate process can continue one stage at a time with gradual com-
mitment of funds and resources. This enables the organisation to control its invest-
ment strategy and keep an eye on its likely return on investment.
9.5.1.2
Multiple Products and Versions
Product organisations may have several versions of the same product at different
stages in their evolution. Typically they will have some product versions in use by
people who have purchased them, some in development and some being deﬁned.
From a planning point of view, each version can be treated as a separate “project”
going through its own set of stages and gates. However, there is an additional
need to plan for the different versions of the products in the pipeline. It is impor-
tant to plan when each version in current use will be phased out and replaced by a
later model. These aspects can also be brought under the stage gate process, so
Initial Gate
Enterprise Goals
Stage 1
Objectives
Stage 1
Planning
Stage 1
Information
State
Required
Stage
1
Work
Stage 2
Objectives
Stage 2
Planning
Stage 2
Information
State
Required
Stage
2
Work
Stage 3
Objectives
Stage 3
Planning
Stage 3
Information
State
Required
Stage
3
Work
Stage Gate 1
Stage Gate 2
Project Information Base
Stage Gate 3
Fig. 9.4 Stage gates and project work
223
9.5
Product Organisations

that a set of stage gate reviews can be held at the same time to determine the best
investment strategy to keep or increase market share.
A further factor in this area is that there may well be different versions for dif-
ferent markets. For example, it may be necessary to have user interfaces that sup-
port different natural languages for sale in different countries.
To cope with this type of difference we introduce the notion of a “Variant”
meaning “differing in form or details from the main one.” Thus we can have the
“main one” (perhaps better expressed as the “core product”) being a product with
the user interface in English and variants for the French, German and Spanish
markets. Each variant can have its own versions such that each version is an
improvement over the previous one.
Figure 9.5 indicates how there can be parallel versions and variants of a single
product each at a different stage of its evolution. The letters S, D and U indicate
whether a product is being speciﬁed, being developed or being used. Each of these
states corresponds to one or more stages in the stage gate lifecycle.
From a requirements management point of view, each variant will have many
requirements in common with the core product, but it will have some requirements
that are speciﬁc to that variant and therefore differentiate it from other variants.
On the other hand, there may be no different requirements for each version of a
U
S
D
v1
U
S
D
v2
U
S
D
v3
U
S
D
v4
Main
U
S
D
v1
U
S
D
v2
U
S
D
v3
U
S
D
v4
Variant A
U
S
D
v1
U
S
D
v2
U
S
D
v3
U
S
D
v4
Variant B
Fig. 9.5 Versions and variants
224
9
Management Aspects of Requirements Engineering

variant, because each version is an attempt to satisfy the same set of requirements
(hopefully improving as the sequence goes on).
In the previous section we used the term “release” and readers may be confused
between a release and a version. The difference is that a release is a version that is
delivered to the customer, whereas not all versions will be.
Planning the evolution of the variants and their versions for each product is a
further organisational task that can also be controlled using the stage gate mechan-
ism. The development for these may overlap in time and there will be a need to
support at least one version of each variant whilst it is in operational use.
The activities involved in doing the speciﬁcation and development are very
similar to those introduced earlier for the acquisition and supplier organisations.
The major difference is that, where different versions and variants of the same pro-
duct exist, there is common information being used in several contexts. This com-
plicates the management of the requirements and makes it essential to understand
how the requirements baselines for each version and variant overlap.
There are two approaches commonly used. In the ﬁrst, requirements are marked
using an attribute, to indicate whether the requirement is a common requirement
or only valid for one or more variants. In the second approach a copy of all the
requirements is made and changes made to the copy for a speciﬁc product variant.
An alternative approach that is gaining popularity in some organisations is to
introduce an additional layer of abstraction referred to as a Feature Variability
Model. Features can be used in several products and tend to be quite stable.
Requirements are marked as either common or related to one or more speciﬁc fea-
tures. The advantage of this approach is that, once a new feature has had its
requirements introduced and marked, that feature can be used in any number of
new products. Thus development effort is only required when a new feature is
added to the product set, rather than work being necessary for every new product.
From a planning and organisational point of view, the introduction of a feature
variability model provides a level of abstraction that product planners and market-
ing people can relate to. This helps focus the organisation’s senior management and
make them more aware of the extent and capabilities of their product portfolio.
Whichever approach is adopted, the fact that there are common requirements
and variant requirements leads to extra complications in the management of
change (see below).
9.5.2
Monitoring
Monitoring progress in a product organisation uses exactly the same mechanisms
as for the other organisations. When stage gates are used as the basis for organisa-
tional decisions, the process of planning will involve the identiﬁcation of the data
state that must exist at the end of the stage. Progress can then be measured based
on the extent to which the desired state has been reached. As a general rule such
states can be measured in the following terms:
225
9.5
Product Organisations

• Whether new objects exist that will become targets for traceability links (e.g.
solution objects in response to stakeholder requirements, or design objects in
response to system requirements)
• Whether attribute values exist
• Whether the required review status exists
• Whether traceability links exist from one data set to others (e.g. from stake-
holder requirements to system requirements, from system requirements to
design and from all of these to testing strategies and possibly test results)
Measures expressed as a percentage of required data quality currently achieved
provide useful metrics for both quality of data and progress within a stage.
9.5.3
Changes
As mentioned earlier the major additional factor for change management in a pro-
duct organisation is where several variants of a product have common require-
ments, and a change proposal is raised against one or more of them. The questions
that must be answered are:
• Will all the variants want to incorporate the change?
• When will they want to incorporate it?
Quite often the answer will be that all variants will want to incorporate the
change, but not at the same time! This introduces an extra state into the change
handling state transition diagram (see Fig. 9.6) because each variant must incorpo-
rate the change before the change can be completed.
Figure 9.6 also indicates that it is necessary that there are Planned, Deferred
and Incorporated states for each variant. The change can only achieve the status of
complete when all the variants have reached their individual “Incorporated” state.
Proposed
Rejected
Agreed
Planned
Deferred
Variant change control
Incorporated
Fig. 9.6 Modiﬁed STD for
change management with
variants
226
9
Management Aspects of Requirements Engineering

In summary, Product organisations perform similar tasks to both Acquisition
and Supplier organisations. In addition they must take care to control their product
portfolio so that an appropriate degree of commitment is made and the overall
commercial exposure is acceptable.
9.6
Agile Development
“Agile” is an approach to development that has grown out of a particular culture
in the world of software. The “values” drawn from the “agile manifesto” (see
http://agilemanifesto.org) give an indication of that culture:
We value:
• Individuals and interactions over processes and tools.
• Working software over comprehensive documentation.
• Customer collaboration over contract negotiation.
• Responding to change over following a plan.
At ﬁrst sight, these statements seem to ﬂy in the face of many of the things that
requirements engineering stands for, particularly the need for systematic documen-
tation of requirements, in layers, traced from top to bottom.
In practical process terms, however, what agile means is incremental develop-
ment. A subset of requirements are prioritised for early development, and a work-
ing prototype is produced. Feedback is obtained from stakeholders about that
prototype, and requirements are adjusted. Then more requirements are selected for
another round of development, a more complete prototype is created, and feedback
obtained. This is repeated until the requirements are stable and a system exists that
meets them.
Agile suits a context in which requirements are poorly understood at the outset,
perhaps because it is a novel application, and it is hard for stakeholders to envi-
sage the extent of what is possible. The sequence of working prototypes makes
abstract ideas more concrete, and helps stakeholders develop clearer requirements
as development proceeds.
Agile works well for software, but how well can it be applied to systems engi-
neering? The barrier would seem to be the idea of a rapid working prototype with
partial functionality—hard to imagine if what you are doing is designing an aircraft!
Prototyping is used in many industries. Aircraft engine manufacturers, for
instance, will plan a series of engine builds, laying out the sequence of features
that each build will exhibit, so that early veriﬁcation of certain design concepts
can be carried out. This is incremental development, but perhaps not very agile.
Automobile manufacturers construct a series of vehicle models, starting in
CAD, and moving to scale models of increasing sizes. This approach is taken
because the need to establish the desired aesthetics for the vehicle, because how
the vehicle looks is crucial to its success. The early models are accurate enough to
be photographed as if real, and paraded to stakeholders capable of judging the
image achieved.
227
9.6
Agile Development

Where agile can be applied in systems engineering is in the design phases,
before physical entities are built. Some requirements are selected, perhaps because
of risk factors or novelty, and design aspects developed for just these require-
ments. Once it is established if and how those requirements can be met by the
design, then the set can be enlarged, and the design expanded to cover them.
Using ideas from (Woodcock and Chard (2013)), in the systems context “work-
ing software” becomes “actual or modelled functionality” or “demonstrable cap-
ability” during the design phases.
All these examples have incremental development in common. This contrasts
with what is often called the “waterfall” approach, where a project waits until all
the requirements at a particular level have been established before then progres-
sing the design for the complete set simultaneously.
The processes and information models describe in this book apply equally to
both agile and waterfall approaches. The difference between the two is simply
about the order in which things are done. At the end of the day, the two
approaches result in the same set of information being collected: layers of traced
requirements, perhaps developed “all at once,” or perhaps incrementally.
The generic processes of Chaps. 2, 5 and 6 have no bias towards waterfall or
incremental. All activities can—and should—occur in parallel, leaving freedom to
dive deep with a few requirements in the initial stages, and catch up with the
others later on. And the change process, which is threaded through the layers,
admits the evolution of requirements from lessons learned in those early forays
into the design.
9.7
Organisational Culture
The greatest challenge facing most organisations as they implement Systems
Engineering, Requirements Engineering, or any other similar endeavour, concerns
cultural change.
It is not just about process; it is not just about tools; it is primarily about peo-
ple. To be successful, the mind-set of the engineers needs to change.
While it may only take months to deﬁne processes, and weeks to install the tools,
it will take years to instil habits in those who work the process and use the tools.
Those who focus on process and tools, but neglect the people aspects fail to
realise the full range of beneﬁts of Requirements Engineering. Their experience is
typically as follows:
• We have always done things this way, and never had any problems.
But now you are having to develop far more complex things, more quickly,
and with less money.
• You want us to do all this additional work? There’s just no room in the sche-
dule for it!
And then comes all the additional, expensive rework later in the project.
Where’s the time in the schedule for that?
228
9
Management Aspects of Requirements Engineering

• He’s our requirements man, over there. He knows how to work the tool, and so
we just pass everything to him.
And that man is a single point of failure, usually becomes stressed and de-
motivated, and leaves.
• These tools are far more difﬁcult to use than Word and Excel! Why can’t I just
write my documents how I always have done?
And then someone asks you about using traceability to assess impact of
change, and you discover all your cross-references have got out of alignment.
These are all symptoms of tools and processes being imposed on unwilling
people, because they have not been properly prepared, educated, trained, mentored
and motivated.
Larry Kennedy makes the following observations (Kennedy 2005):
From the beginning of time, the basic transaction between people has been the promise to
exchange value for value. These promises are the foundation for all business and personal
relationships and the cornerstone of commerce. Since then, the only things that have chan-
ged are the technologies we have developed to fulﬁll our promises. The invention of money,
cash registers, credit cards, computers, railroads, trucks, airplanes, ocean-going ships and
educational technologies such as Quality Management are the result of competition to dis-
cover more effective methods for keeping our promises. As each generation of business lea-
ders emerge, we have also learned new and better ways to teach, train, coach, mentor and
manage ourselves and others, all for the purpose of keeping the promises we have made.
An agreed requirement is akin to a promise, and requirements management is
about keeping those promises—keeping them as individuals as well as organisations.
Part of the culture change needed is for every member of the team to take own-
ership of the requirements process, to be responsible for making it work, and to be
the beneﬁciary of the resulting improvements—for each individual to accept their
personal share of “keeping the promise” made to the customer.
9.8
Summary
The summary is grouped under the headings of planning, monitoring and changes
in line with the presentation of the main body of the text.
9.8.1
Planning
Planning should be driven by the outputs that must be created. Activities to create
the required outputs can then be introduced. Outputs can be categorised as follows:
• Types of information objects (e.g. stakeholders, stakeholder requirements, sys-
tem requirements, design or solution objects etc.);
• Attributes associated with an information object;
• Links between information objects to establish traceability, testing strategy etc.;
229
9.8
Summary

• Review criteria to determine the required quality of information and associated
attributes;
• Achievement of a particular state possibly via progression through a series of
states (e.g. by reviews)
Before any work can be started, the work must be authorised by the organisation
in which it will be undertaken. A mechanism such as stage gates is appropriate for
Acquisition and Product organisations to control the level of commitment and con-
sequent ﬁnancial and/or commercial exposure they are willing to tolerate. In
Supplier organisations there must be an authorisation to prepare a proposal and this
is usually accompanied by an allowed budget. Permission to progress to develop-
ment will usually be embodied in the signing of a contract with the customer.
Evolutionary development should be considered to be the norm especially for
unprecedented systems. This leads naturally into the concepts of releases, versions
and variants.
9.8.2
Monitoring
It is vital that progress is measured by investigating the current state of the
required outputs. Progress measured in this way together with the amount of effort
and time used compared to the plan enables the viability of the plan to be estab-
lished. Ignoring the outputs and just measuring time and effort consumed gives a
distorted view that is not realistic.
9.8.3
Changes
The most critical aspect of a change is the impact that it will have on the system
to be developed and hence on the development plan. Understanding the impact
can only be achieved provided that the current states of the (project) outputs are
available and up-to-date. Of particular importance here are the links that exist to
provide traceability from input information to derived information.
Deciding when a change can or should be incorporated will usually impact the
plan and may cause serious re-planning—depending on the scope of the change.
Changes can also lead to the introduction of additional releases, version or variants.
9.8.4
Organisational Culture
It is not just about process; it is not just about tools; it is primarily about people.
To be successful, the mind-set of the engineers needs to change.
The woods are lovely, dark and deep,
But I have promises to keep,
And miles to go before I sleep,
And miles to go before I sleep.
Robert Frost, poet, 1874–1963
230
9
Management Aspects of Requirements Engineering

Bibliography
Abrial J-R (1996) The B-book: assigning programs to meanings. Cambridge University Press,
New, NY
Alderson A, Hull MEC, Jackson K, Grifﬁths LE (1998) Method engineering for industrial
real-time and embedded systems. Inf Softw Tech 40:443–454
Andriole SJ (1996) Managing systems requirements: methods, tools and cases. McGraw-Hill,
New York
Babich W (1986) Software conﬁguration management – coordination for team productivity.
Addison-Wesley Longman Publishing Co., Inc. Boston, MA, USA
Bernstein P (1996) Against the gods – the remarkable story of risk. John Wiley & Sons Inc.,
Somerset, New Jersey, U.S.A
Bjorner D, Jones CB (1978) The Vienna Development Method: The Meta-Language, Lecture
Notes in Computer Science, Springer Verlag, Berlin, p 61
Boehm B (1981) Software engineering economics, Prentice Hall PTR, Upper Saddle River, NJ,
U.S.A
Bolognesi T, Brinksma E (1987) Introduction to the ISO speciﬁcation language LOTOS.
Computer Networks and ISDN Systems 14(1):25–59
Booch G (1994) Object-oriented design with applications. Benjamin Cummins, Redwood City
Brown AW, Earl AN et al (1992) Software engineering environments. McGraw-Hill, London
Budgen D (1994) Software design. Addison-Wesley.
CarnegieMellon (2006) CMMI® for development, version 1.2. Software Engineering Institute,
CMMI-DEV, Pitsburg., p 15213–3890
Chaochen Z, Hoare CAR, Ravn AP (1991) A calculus of durations. Inf Process Lett 40(5):269–276
Chen P (1976) The entity-relationship model–toward a uniﬁed view of data. In: ACM transac-
tions on database systems 1/1/1976, ACM-Press. ISSN 0362-5915, S. 9–36.
Clark KB, Fujimoto T (1991) Product development performance. Harvard Business School
Press, Boston, MA
Coad P, Yourdon E (1991a) Object-oriented analysis. Yourdon Press, Englewood
Coad P, Yourdon E (1991b) Object-oriented design. Yourdon Press, Englewood
Cooper RG (1993) Winning at new products. Addison-Wesley, Reading, MA
Crosby PB (1979) Quality is free. McGraw-Hill, New York
Crosby PB (1984) Quality without tears. New American Library, New York.
Darke P, Shanks GG (1997) User viewpoint modelling: understanding and representing user
viewpoints during requirements deﬁnition. Inf Syst J 7(3):213–240
Davis AM (1993) Software requirements: objects, functions and states. Prentice-Hall, Englewood
Cliffs
231
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3

DeGrace P (1993) The Olduvai Imperative: CASE and the state of software engineering practice.
Yourdon Press, Englewood Cliffs, NY
DeMarco T (1978) Structured analysis and system speciﬁcation. Yourdon Press, Englewood
Cliffs, NJ
DeMarco T (1982) Controlling software projects. Yourdon Press, Englewood Cliffs, NJ
DeMarco T, Lister T (1987) Peopleware – Productive projects and teams. Dorset House
Publishing, New York
Dick J, Faivre A (1993) Automating the generation and sequencing of test cases from model-
based speciﬁcations. In: Conf. Proc. FME ‘93, Odense, Denmark, April 1993.
Dick J, Jones B, (2012) On the Complexity of Requirements Flow-down Structures. INCOSE
International Symposium 22 (1):1197–1206
Dick J, Llorens J (2012) Using statement-level templates to improve the quality of requirements.
In: Proc. 24th Int. Conf. on software & systems engineering and their applications, Paris,
October 2012.
Easterbrook S, Nuseibeh B (1996) Using viewpoints for inconsistency management. Softw Eng J
11(1):31–43
Faulk S, Brackett J, Ward P, Kirby J (1992) The core method for real-time requirements. IEEE
Softw 9(5):22–33
Finkelstein A, Kramer J, Nuseibeh B, Goedicke M (1992) Viewpoints: a framework for inte-
grating multiple perspectives in systems development. Int J Softw Eng Knowl Eng 2(10):
31–58
Fowler M, Scott K (1997) UML distilled: applying the standard object modeling language.
Addison-Wesley, Reading
Gilb T (1988) Principles of software engineering management. Addison-Wesley, Reading, MA
Gilb T (2005) Competitive engineering: a handbook for systems engineering, requirements engi-
neering and software engineering management using planguage. Elsevier Butterworth-
Heinemann, Oxford
Gorchels L (1997) The product manager’s handbook. NTC Business Books, Chicago, IL
Gotel OCZ, Finkelstein ACW (1995) Contribution structures. Proceedings RE’95. IEEE Press,
York, UK
Harel D (1987) Statecharts: a visual formalism for complex systems. Sci Comput Program
8:231–274
Hull MEC, Taylor PS, Hanna JRP, Millar RJ (2002) Software development processes – an
assessment. Inf Softw Tech 44(1):1–12
Humphrey WM (1989) Managing the software process. Addison-Wesley, NY
IEEE STD 1220-1998 (1998) Standard for application and management of the systems engineering
process. IEEE, New York
INCOSE (2007) INCOSE SE Vision 2020, INCOSE-TP-2004-004-02. In: International council
on systems engineering (INCOSE) 7670 opportunity road, Suite 220, San Diego, California
92111-2222 USA.
INCOSE (2017) Guide for writing requirements, INCOSE-TP-2010-006-02, version 2.1, 2017,
prepared by requirements working group. In: International council on systems engineering
(INCOSE) 7670 opportunity road, Suite 220, San Diego, California 92111-2222 USA.
Jackson M (1995) Software requirements & speciﬁcations: a lexicon of practice, principles and
prejudices. Addison-Wesley, Wokingham, UK
Jacobsen I, Christerson M et al (1993) Object-oriented software engineering. Addison-Wesley,
Wokingham, UK
Kennedy L (2005) Keeping the promise: a work ethic for doing things right. Reliable Man
Books, Orlando, FL
Kotonya G, Sommerville I (1996) Requirements engineering with viewpoints. Softw Eng J
11(1):5–11
Kotonya G, Sommerville I (1998) Requirements engineering: processes and techniques. John
Wiley & Sons, Chichester
232
Bibliography

Leite JCP, Freeman PA (1991) Requirements validation through viewpoint resolution. Trans
Softw Eng 12(2):1253–1269
Loucopoulos P, Karakostas V (1995) Systems requirements engineering. McGraw-Hill, London
Mazza C et al (1994) ESA – Software engineering standards. Prentice-Hall, New Jersey
Monroe RT, Kompanek A, Metlon R, Garlan D (1997) Architectural styles, design patterns, and
objects. IEEE Software 14(1):43–52. Jan.
Mumford E (1989) User participation in a changing environment – Why we need it. In: Knight
K Ed Participation in systems development. Kogan Page, London
Nuseibeh B, Kramer J, Finkelstein A (1994) A framework for expressing the relationships
between multiple views in requirements speciﬁcation. Trans Softw Eng 20(10):760–773
Oliver DW, Kelliher TP, Keegan JG (1997) Engineering complex systems with models and
objects. McGraw-Hill, New York
OMG (2003) The uniﬁed modelling language version 2, www.omg.org.
Page-Jones M (1980) The practical guide to structured systems. Yourdon Press, NY
Perrow C (1984) Normal accidents. Basic Books, NY
Petroski H (1982) To engineer is human – the role of failure in successful design. Vintage
Books, NY
Petroski H (1996) Invention by design: how engineers get from thought to thing. Harvard
University Press, Cambridge, MA
Poots C, Takahashi K et al (1994) Inquiry-based requirements analysis. IEEE Softw 11(2):21–32
Pressman RS (1997) Software engineering: a practitioner’s approach. McGraw-Hill, London
Ross DT (1977) Structured analysis (SA): a language for communicating ideas. IEEE Trans
Softw Eng 3(1):16–34
Ross DT (1985) Applications and extensions of SADT. IEEE Comput 18(4):25–34
Ross DT, Schoman KE (1977) Structured analysis for requirements deﬁnition. IEEE Trans Softw
Eng 3(1):6–15
Rumbaugh J, Blaha M, Premerlani W, Eddy F, Lorenzen W (1991) Object-oriented modeling
and design. Prentice-Hall, NY
Shlaer S, Mellor SJ (1991) Object life cycles – modeling the world in states. Yourdon Press, NY
Shlaer S, Mellor SJ (1998) Object-oriented systems analysis. Prentice-Hall, Englewood Cliffs
Software Engineering Institute (Carnegie-Mellon) (1991) Capability maturity model for software.
In: Tech. report CMU/SEI-91-TR-24.
Sommervile I (1996) Software engineering. Addison-Wesley, Wokingham
Sommervile I, Sawyer P (1997) Requirements engineering: a good practice guide. John Wiley
and Sons, Chichester
Spivey JM (1989) The Z notation: a reference manual. Prentice Hall International Series in
Computer Science, Hemel Hempstead, Hertfordshire, UK
Standish Group (1995), The CHAOS Report 1995, Standish Group International. Inc., Boston MA
Standish Group (2015), The CHAOS Report 2015, Standish Group International. Inc., Boston MA
Stevens R, Brook P, Jackson K, Arnold S (1998) Systems engineering: coping with complexity.
Prentice-Hall, Europe
SyntheSys (2014) SPIRIT – UML modelling, white paper, http://www.synthesys.co.uk/brochures_
new/5.4SPIRIT%20Modelling%20Tech%20Sheet.pdf.
Wheatcroft L, Ryan M, Dick J (2016) On the use of attribute to manage requirements. Syst Eng
J Pub. Wiley 19(5):448–458
Woodcock H, Chard J (2013) A proposed Agile systems engineering manifesto. In: INCOSE UK
ASEC 2013. https://www.slideshare.net/hazel-woodcock/a-proposed-agile-systems-engineering-
manifesto-noteless.
Yourdon EN (1990) Modern structured analysis. Prentice-Hall, Englewood Cliffs, NY
Zave P (1997) Classiﬁcation of research efforts in requirements engineering. ACM Comput Surv
29(4):315–321
233
Bibliography

Index
A
Abstract model, 64
Abstraction, 22, 57, 96, 108
Acceptance criteria, 38–40, 133
Acquisition, 3, 4–9
Agile development, 21–22
Agnostic design, 23
Allocation
functional, 20, 102, 172
non-functional, 20, 172
Analysis
coverage, 17, 161
derivation, 16, 52–54, 139–144, 152–153,
156, 161, 167
impact, 16, 161, 181, 183
rich traceability, 170–171
Assessment, 97, 101
Assumptions. See domain knowledge
Atomicity, 108, 111
Attribute, 97, 97–98
categories, 98
rationale, 162, 165
B
Background information, 96
Bid management, 9–13
Black box, 23
B-Method, 89
Boilerplates, 103, 103–105, 104, 105
Brainstorming, 71, 111, 117
Business objectives, 14
C
Capability, 102
Capacity, 102, 105
Change
complexity, 184
estimation, 184
impact, 16, 161, 181, 183
latent, 183, 184
management, 1–2, 13, 14, 183
request, 184
Clarity, 107
Class Diagram, 67, 82
Classiﬁcation
primary, 95, 100
secondary, 95, 100
Communication, 12, 19
Completeness, 108
Complexity, 1
Compliance statement, 174
Conﬁdential information, 103
Conﬂicts, 99–100
Consistency, 99–100, 108
Constraints, 102, 104, 144
Context diagram, 86
Contextual information, 94
COTS, 1
Coverage analysis, 17, 161
Cultural change, 22
Cup, 6
D
data dictionary, 59
Data ﬂow, 43, 58–64, 59
Data ﬂow diagram, 58, 96
data store, 59
data transformation, 59
Decomposition
functional, 20, 102, 172
235
© Springer International Publishing Switzerland 2017
J. Dick et al., Requirements Engineering, DOI 10.1007/978-3-319-61073-3

Decomposition (cont.)
non-functional, 20, 172
not necessary, 172
DeMarco, 69
Derivation analysis, 161, 167
Design agnosticism, 23
Design freedom, 22, 101
Design intent, 159, 186
Design justiﬁcations. See also satisfaction
statement, 165, 174
Development
change, 41–42
ideal, 40–41
process, 35, 59
systems, 33–36, 102
Diagram
activity, 73
block deﬁnition, 86
class, 67
context, 86
data ﬂow, 58
entity-relationship, 64
ERD, 64
parametric, 86
requirements, 86, 170
sequence, 85
state transition, 65
statecharts, 65
Domain knowledge, 96, 167
DOORS, 187
architecture, 188–189
export, 205
import, 205
E
Elementary traceability, 161, 162
Emergent properties, 5, 6, 19, 172
Entity-relationship diagram, 64
Environment, 7
ERD, 64
Estimation, 1
Example, 167
aircraft engine, 108
banking, 144–147
barrista, 162, 163
car, 147–152
cooker, 161
cup, 6
electro-chlorination unit, 172
military vehicle, 161
New York underground, 167
nightmare, 108
RAC rally, 11
sailing boat, 121, 188
timetables, 168
vehicle, 164
external entity, 59
F
Feasibility, 107
Feedback, 111
Filtering, 103
Formal method, 89
Functional allocation, 172
Functional decomposition, 172
Functional requirements, 102
Functionality
human interaction, 142, 146, 150
interface, 141–142, 145–146, 149–150
internal, 140–141, 144–145, 149
safeguard, 142–143, 146–147, 150–151
G
Generic process, 49–56
instantiation, 114–115, 136, 154
H
Hierarchies, 95, 96
Human interaction, 142–143, 142, 146
I
Impact analysis, 13, 16, 161, 181
Impact assessment, 184
INCOSE, 98
Incremental development, 21
Information model, 43–49
Intentional design, 186
Interface register, 29, 30
Interfaces, 5, 6, 24, 29
decomposition, 29
Invitation To Tender, 10
J
Justiﬁcation, 162
K
Key requirements, 96–97
L
Language, 101, 101–103
Legality, 107
Let-out clauses, 108
Lifecycle, 11–14
LOTOS, 89
236
Index

M
Management, 1–2
experience, 2, 3
of change, 4, 7–9, 12–13, 15, 20–21, 24
or bids, 9–13
planning, 4–7, 10–11, 13–14, 15–19,
23–24
problems, 2–4
MBSE, 91
Method, 68
Metrics, 179–185, 186
global, 180
imbalance, 182, 182–183
phase, 180
Model-based System Engineering, 91
Modelling
and qualiﬁcation, 91
class diagram, 82
data ﬂow diagram, 58
parametric diagram, 86
requirement diagram, 86
sequence diagram, 85
SysML, 86
use case diagram, 83
Models
abstract, 64
system, 23, 69, 101
Modes of operation, 144, 147, 151–152
Modularity, 108
Monitoring progress, 4, 7, 11–12, 14–15,
19–20, 24, 179–185
N
Necessity, 169
Non-functional allocation, 172
Non-functional decomposition, 172
O
Object Management Group, 86
Operability, 105
Operational modes, 108
Organisations
acquisition, 3, 4–9
product developers, 3, 15–21
suppliers, 3, 9–15
types, 3
P
Paragraph numbers, 93
Parametric diagram, 86
Patterns
ﬂow-down, 159, 165, 170, 172
PBS, 26
Performance, 20, 102
Performance attribute, 102
Periodicity, 103, 105
Praxis Critical Systems, 165
Precision, 108
Problem
versus solution, 3, 21–23
Problem domain, 21, 22, 101, 113–114
Process
analysis, 15, 51–52, 170–171
derivation, 16, 52–54, 139–144, 152–153,
156, 161, 167
generic, 36–40, 43–49, 49–56
modelling, 51–52
qualiﬁcation, 54–56, 46–47, 108
requirements agreement, 49–51
Process speciﬁcation, 59
Product breakdown structure, 26
Product developers, 3, 15–21
Product distribution, 1
Product families, 12, 17–19, 18, 20
Programme management, 12
Progress measurement, 17
Project
decision factors, 2
plan, 1
Project failure, 2
Project success, 3
Propositional logic, 171
Prototypes
requirements from, 130–131
Q
Qualiﬁcation, 20, 108
strategy, 132, 133–134
Qualiﬁcation argument. See qualiﬁcation
statement
Qualiﬁcation rationale. See qualiﬁcation
statement
Qualiﬁcation statement, 173
Qualiﬁcation strategy, 21, 38–40
Quality, 11, 10–11
factors, 98
R
Reality, 1
Redundancy, 108
Request For Proposals, 10
Requirement
deﬁnition, 7–8
requirement diagram, 86
237
Index

Requirements
abstraction, 108
agreement, 45–46, 49–51, 116, 153
allocation, 152–153, 165
atomicity, 108, 111
attributes, 97, 97–98, 98
boilerplates, 103, 103–105, 104, 105
capabilities, 104
capture, 126–132
clarity, 107
classiﬁcation, 95
completeness, 108
conﬂicting, 95, 99–100
consistency, 99–100, 108
constraints, 105, 131–132
criticality, 183
decomposition, 181, 185
derivation, 16, 52–54, 139–144, 152–153,
156, 161, 167
derived, 38
documents, 94–96
elaboration. See satisfaction statement
expressing, 103
feasibility, 107
ﬂow-down, 159, 165, 170, 172
functional, 20, 102, 172
identiﬁcation, 117–118, 128
identifying, 93, 101
identity, 165, 166
imbalance, 182, 182–183
input, 38
language, 101, 101–103, 102, 103,
107–109, 170
legality, 107
management, 1–2, 13, 14, 183
modularity, 108
nightmare, 108
non-functional, 20, 172
performance, 102
precision, 108
qualiﬁcation, 46–47, 54–56, 108
redundancy, 108
reﬁnement, 132
reuse, 95
reviewing, 94
satisfaction, 47–48, 108
singular, 107
stakeholder, 23, 101, 102
stakeholder v. system, 23
structure, 94–96, 108, 111, 152
structuring, 95, 122–126
system, 23, 33–36, 69, 101, 102
trade-off, 101
uniqueness, 107
value of, 100, 100–101, 101
veriﬁability, 108
workshops, 129–130
writing, 94
Requirements engineering
deﬁnition, 5, 8, 9–10
Requirements expression, 97, 103
Requirements ﬂow-down, 159
Requirements statement, 97
Reuse, 12, 103
Review process
criteria, 94
requirements, 86, 170
traceability, 170
Rich traceability, 159, 165, 167, 197, 200
analysis, 15, 51–52, 170–171
implementation, 174
multi-layer, 166, 169, 174
single-layer, 174
Risk management, 2
Rumbaugh, 69
S
Satisfaction, 108
Satisfaction argument, 163, 165, 167, 170
language, 101, 101–103, 102, 103,
107–109, 170
Satisfaction intent, 173
Satisfaction rationale, 163
Satisfaction statement, 162–163, 163, 167, 185
disjunction, 164
Scenarios, 20, 96
Sequence diagram, 85
Shlaer Mellor, 69
Singularity, 107
Software, 1
Solution
versus problem, 3, 21–23
Solution domain, 21, 22, 101, 102, 135–137
Sorting, 103
Speciﬁcation
process, 35, 59
Speculation, 108
Stage gate, 16
Stakeholder, 102
constraints, 105, 131–132
deﬁnition, 5, 8, 9–10
Stakeholder requirements, 23, 101, 102
Stakeholders, 94
identiﬁcation, 117–118, 128
interviewing, 126–127
238
Index

State charts, 96
State transition diagram, 65
Statechart, 20, 65
Strategy. See satisfaction statement
Structure, 108
Subsystems, 154–156
Sufﬁciency, 169
Suppliers, 3, 9–15
SysML, 86
System
deﬁnition, 5, 8, 9–10
scope, 122
System architecture, 154–156
System model, 137–138
System modelling, 18–20, 19, 20, 69, 96, 167
System requirements, 23, 101
System transaction, 143, 147, 151
Systems development, 33–36
Systems engineering, 4–7
Systems of systems, 5
Systems requirements, 102
T
Tender assessment. See assessment
Test planning, 17
Time to market, 2
Timeliness, 105
Traceability, 13, 14–17, 17
analysis, 15, 51–52, 170–171
beneﬁts, 185, 186
breadth, 180, 180–181
depth, 180, 181
downwards, 183
effort, 185
elementary, 160–162, 161, 162
growth, 180, 181–182
imbalance, 182, 182–183
matrix, 160
metrics, 179–185
multi-layer, 166, 169, 174
overhead, 17
rationale. See satisfaction statement
rich, 159, 165, 167
upwards, 183
U
UML, 81
class diagrams, 20
message sequence charts, 20
Uniﬁed Modelling Language, 81
Uniqueness, 107
Use case diagram, 83
Use scenarios
characteristics, 120–122
creation, 118–122
V
Value function, 100, 101
Variants, 17–19, 18, 20
VDM, 89
Veriﬁability, 108
Versions, 17–19, 18, 20
VISION, 169
V-Model, 11
W
Waterfall development, 22
West Coast Mainline, 4, 165
Word processor, 93
Y
Yourdon, 69
Z
Z, 89
239
Index

