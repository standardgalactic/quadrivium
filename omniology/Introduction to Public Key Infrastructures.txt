Johannes A. Buchmann · 
Evangelos Karatsiolis
Alexander Wiesmaier
Introduction 
to Public Key 
Infrastructures
Johannes A. Buchmann 
Evangelos Karatsiolis
Alexander Wiesmaier
Introduction 
to Public Key 
Infrastructures

Introduction to Public Key Infrastructures


Johannes A. Buchmann • Evangelos Karatsiolis
Alexander Wiesmaier
Introduction to Public Key
Infrastructures
123

Johannes A. Buchmann
FB Informatik
TU Darmstadt
Darmstadt
Germany
Evangelos Karatsiolis
FlexSecure GmbH
Darmstadt
Germany
Alexander Wiesmaier
AGT International
Darmstadt
Germany
ISBN 978-3-642-40656-0
ISBN 978-3-642-40657-7 (eBook)
DOI 10.1007/978-3-642-40657-7
Springer Heidelberg New York Dordrecht London
Library of Congress Control Number: 2013954524
© Springer-Verlag Berlin Heidelberg 2013
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology
now known or hereafter developed. Exempted from this legal reservation are brief excerpts in connection
with reviews or scholarly analysis or material supplied speciﬁcally for the purpose of being entered
and executed on a computer system, for exclusive use by the purchaser of the work. Duplication of
this publication or parts thereof is permitted only under the provisions of the Copyright Law of the
Publisher’s location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center. Violations
are liable to prosecution under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of
publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for
any errors or omissions that may be made. The publisher makes no warranty, express or implied, with
respect to the material contained herein.
Printed on acid-free paper
Springer is part of Springer Science+Business Media (www.springer.com)

Preface
More than 30 years ago, when the Internet was emerging, public key cryptography
was invented. Traditionally, cryptography relied on the exchange of secret keys prior
to any secure communication, which made the application of cryptography in open
networks such as the Internet very difﬁcult. In contrast, public key cryptography
allows for secure communication of entities that had no prior contact. Today, as the
Internet has over two billion participants, this is extremely important. In addition,
public key cryptography enables techniques that have no analogue in traditional
cryptography, most importantly digital signatures. In fact, security on the Internet
could not be achieved without digital signatures as they are, for example, required
to authenticate software downloads and updates. We are convinced that today and
in the future, there is and will be no IT security without public key cryptography.
Although public key cryptography does not rely on the exchange of secret keys,
proper key management is still of vital importance to its security. In public key
cryptography, pairs of private and public keys are used. The ﬁrst task of such key
management is to keep private keys private. This is easier than protecting keys in
traditional secret key cryptography as there is no need to exchange private keys over
insecure channels. But it is still an important challenge since there are billions of
computing devices with private keys stored on them. The second task is to guarantee
the authenticity of public keys, which is as important as maintaining the secrecy
of private keys. For example, if the public signature veriﬁcation key of a software
vendor could be replaced by the public key of an adversary, the software signatures
would be of no use since the adversary would be able to sign software in the name
of the software vendor.
In order to fully understand public key cryptography, we therefore consider
it necessary to study the infrastructures that manage key pairs in public key
cryptography, the so-called public key infrastructures (PKIs). It is not sufﬁcient to
understand the ingenious mathematical mechanisms that underlie public key cryp-
tography. This book grew out of a PKI course at Technische Universität Darmstadt,
Germany, which we have been teaching for several years and which complements
the introductory course on cryptography. It is our goal to cover the important
concepts underlying PKI and to discuss relevant standards, implementations, and
v

vi
Preface
applications. We have included several exercises in each chapter that help deepen
the understanding of its content. The book can thus be used as the basis for a course
on PKI and as a self-study book for students and others interested in PKI. Only basic
computer science knowledge is required. By giving numerous references that point
to the relevant standards and implementation guidelines, we hope to make the book
useful for those who are involved in PKI projects.
While writing this book and working on PKI projects, it became clear to us
that PKI is still a very important research and development area. While public
key cryptography applications that do not require user interaction are widely used
(e.g., code signing), security solutions that require users to be actively involved
are not so widespread (e.g., email signature and encryption). Many say that this
is because current PKI concepts are still too complicated. Also, in the recent past,
several incidents have shown that PKI does not always deliver the required security.
Therefore, PKI concepts are required that overcome these deﬁciencies. We also
intend this book to aid researchers and developers in doing so.
We would not have been able to write this book without the help of many people,
in particular the students who attended the PKI course that the book is based on.
Johannes Braun, Martin A. Gagliotti Vigil, Patrick Schmidt, Marcus Lippert, and
Ciaran Mullan helped develop the exercises and made many important comments.
We also thank Ronan Nugent and Alfred Hofmann of Springer for their support.
Darmstadt, Germany
Johannes A. Buchmann
July 2013
Evangelos Karatsiolis
Alexander Wiesmaier

Contents
1
The Purpose of PKI ........................................................
1
1.1
The Internet...........................................................
1
1.2
Security Goals ........................................................
2
1.2.1
Conﬁdentiality ..............................................
2
1.2.2
Integrity .....................................................
3
1.2.3
Entity Authentication .......................................
3
1.2.4
Data Authenticity ...........................................
4
1.2.5
Non-repudiation ............................................
5
1.2.6
Other Security Goals .......................................
5
1.3
Cryptography .........................................................
5
1.3.1
Secret Key Encryption......................................
5
1.3.2
Public Key Encryption .....................................
7
1.3.3
The RSA Public Key Cryptosystem .......................
8
1.3.4
Other Public Key Cryptosystems ..........................
9
1.3.5
Hybrid Encryption ..........................................
10
1.3.6
Cryptographic Hash Functions and Message
Authentication Codes.......................................
11
1.3.7
Digital Signatures...........................................
12
1.3.8
The RSA Signature Scheme................................
13
1.3.9
Other Digital Signature Schemes ..........................
14
1.4
Why Public Key Infrastructure? .....................................
15
1.5
Identity-Based Public Key Cryptography ...........................
16
1.6
Object Identiﬁers .....................................................
17
1.7
Exercises ..............................................................
17
References....................................................................
18
2
Certiﬁcates ..................................................................
21
2.1
The Concept of a Certiﬁcate .........................................
21
2.2
X.509 Certiﬁcates ....................................................
22
2.2.1
Structure.....................................................
22
2.2.2
tbsCertiﬁcate ................................................
24
vii

viii
Contents
2.2.3
signatureAlgorithm .........................................
27
2.2.4
signatureValue ..............................................
27
2.3
X.509 Certiﬁcate Extensions ........................................
27
2.4
Attribute Certiﬁcates .................................................
31
2.5
CV Certiﬁcates .......................................................
31
2.6
PGP Certiﬁcates ......................................................
33
2.7
Other Certiﬁcates.....................................................
33
2.7.1
WAP Certiﬁcates............................................
34
2.7.2
SPKI Certiﬁcates ...........................................
34
2.7.3
Traceable Anonymous Certiﬁcate .........................
35
2.8
Exercises ..............................................................
35
References....................................................................
37
3
Trust Models ................................................................
39
3.1
Direct Trust ...........................................................
39
3.2
Web of Trust ..........................................................
42
3.2.1
Key Ring ....................................................
44
3.2.2
Trust Signatures.............................................
47
3.2.3
Probabilistic Trust Model for GnuPG .....................
48
3.3
Hierarchical Trust ....................................................
48
3.3.1
Basic Constraints ...........................................
50
3.4
Combining Trust Hierarchies ........................................
51
3.4.1
Trusted Lists ................................................
52
3.4.2
Common Root ..............................................
53
3.4.3
Cross-Certiﬁcation..........................................
56
3.4.4
Bridge .......................................................
56
3.5
Exercises ..............................................................
58
References....................................................................
60
4
Private Keys .................................................................
61
4.1
Private Key Life Cycle ...............................................
61
4.2
Personal Security Environments .....................................
62
4.3
Software PSEs ........................................................
63
4.3.1
PKCS#12....................................................
63
4.3.2
PKCS#8 .....................................................
64
4.3.3
Java KeyStore ...............................................
65
4.3.4
Application-Speciﬁc Formats ..............................
65
4.4
Hardware PSEs .......................................................
68
4.4.1
Smart Cards .................................................
68
4.4.2
Smart Card Readers ........................................
69
4.4.3
Smart Card Communication Interfaces ....................
70
4.4.4
Hardware Security Module.................................
72
4.5
Exercises ..............................................................
73
References....................................................................
73

Contents
ix
5
Revocation ...................................................................
75
5.1
Requirements .........................................................
75
5.2
Certiﬁcate Revocation Lists..........................................
76
5.2.1
Basic Fields .................................................
76
5.2.2
CRL Extensions ............................................
79
5.2.3
Issuing Time of a CRL .....................................
81
5.2.4
Delta CRLs .................................................
82
5.2.5
Authority Revocation List..................................
83
5.2.6
Indirect CRLs ...............................................
83
5.3
Certiﬁcate Extensions Related to Revocation .......................
83
5.3.1
CRL Distribution Points....................................
83
5.4
OCSP .................................................................
84
5.4.1
Functionality ................................................
84
5.4.2
Extensions ..................................................
86
5.4.3
Lightweight OCSP .........................................
89
5.4.4
Design of an OCSP Server .................................
89
5.5
Other Revocation Mechanisms ......................................
89
5.5.1
Novomodo ..................................................
89
5.5.2
Short-Lived Certiﬁcates ....................................
90
5.6
Revocation in PGP ...................................................
90
5.7
Exercises ..............................................................
91
References....................................................................
94
6
Validity Models .............................................................
95
6.1
The Shell Model......................................................
95
6.2
The Chain Model .....................................................
97
6.3
The Modiﬁed Shell Model ...........................................
98
6.4
Exercises .............................................................. 100
References.................................................................... 101
7
Certiﬁcation Service Provider............................................. 103
7.1
Certiﬁcate Life Cycle ................................................ 103
7.1.1
Certiﬁcate Generation Phase ............................... 103
7.1.2
Certiﬁcate Validity Phase................................... 104
7.1.3
Certiﬁcate Invalidity Phase................................. 104
7.2
Registration Authority ............................................... 105
7.3
Certiﬁcation Authority ............................................... 107
7.4
Other Components ................................................... 108
7.5
Communication Within CSPs........................................ 108
7.5.1
Cryptographic Protection of Messages .................... 108
7.5.2
Certiﬁcate Requests ........................................ 109
7.5.3
Complex Message Formats and Protocols................. 112
7.6
Exercises .............................................................. 115
References.................................................................... 115

x
Contents
8
Certiﬁcate Policies .......................................................... 117
8.1
Structure of Certiﬁcate Policies...................................... 117
8.1.1
Certiﬁcation Practice Statement ........................... 119
8.2
Relevant Certiﬁcate Extensions...................................... 119
8.2.1
Certiﬁcate Policies.......................................... 119
8.2.2
Policy Mappings ............................................ 119
8.2.3
Policy Constraints .......................................... 121
8.2.4
Inhibit anyPolicy............................................ 121
8.3
Extended Validation Certiﬁcates..................................... 122
8.4
Exercises .............................................................. 122
References.................................................................... 123
9
Certiﬁcation Paths: Retrieval and Validation ........................... 125
9.1
LDAP ................................................................. 125
9.1.1
Storing Certiﬁcates ......................................... 126
9.1.2
Certiﬁcate Search ........................................... 129
9.1.3
Storing CRLs ............................................... 130
9.1.4
Security ..................................................... 131
9.2
Other Certiﬁcate Retrieval Methods................................. 131
9.2.1
DNS ......................................................... 131
9.2.2
HTTP........................................................ 132
9.2.3
Web Servers and FTP Servers.............................. 132
9.2.4
WebDAV .................................................... 132
9.3
Certiﬁcation Path Building........................................... 132
9.4
Certiﬁcation Path Validation ......................................... 134
9.4.1
Validation Algorithm ....................................... 135
9.5
Server-Based Certiﬁcate Validation Protocol (SCVP).............. 137
9.6
Relevant Certiﬁcate Extensions...................................... 138
9.6.1
Authority Information Access ............................. 138
9.6.2
Subject Information Access ................................ 139
9.7
Exercises .............................................................. 140
References.................................................................... 141
10
PKI in Practice.............................................................. 143
10.1
Internet................................................................ 143
10.2
Email.................................................................. 144
10.2.1
S/MIME ..................................................... 145
10.2.2
PGP.......................................................... 147
10.3
Code Signing ......................................................... 152
10.4
VPN ................................................................... 154
10.5
Legally Binding Electronic Signatures .............................. 156
10.6
E-Government ........................................................ 159
10.7
Exercises .............................................................. 162
References.................................................................... 163

Contents
xi
A
Basic Path Validation Algorithm.......................................... 165
Solutions to the Exercises ....................................................... 173
Index ............................................................................... 187


Acronyms
AA
Attribute Authority
ACL
Access Control List
AES
Advanced Encryption Standard
APDU
Application Protocol Data Unit
API
Application Programming Interface
ARL
Authority Revocation List
ASN
Abstract Syntax Notation
AKI
Authority Key Identiﬁer
BER
Basic Encoding Rules
CA
Certiﬁcation Authority
CC
Common Criteria
CD
Compact Disc
CER
Canonical Encoding Rules
CMC
Certiﬁcate Management Messages over CMS
CMP
Certiﬁcate Management Protocol
CMS
Cryptographic Message Syntax
CPS
Certiﬁcation Practice Statement
CRL
Certiﬁcate Revocation List
CRMF
Certiﬁcate Request Message Format
CSP
Certiﬁcation Service Provider
CSP
Cryptographic Service Provider
CT-API
Card Terminal Application Programming Interface
CVC
Card Veriﬁable Certiﬁcate
DER
Distinguished Encoding Rules
DES
Data Encryption Standard
DIT
Directory Information Tree
DN
Distinguished Name
DNS
Domain Name System
DSA
Digital Signature Algorithm
DVD
Digital Video Disc
EBCA
European Bridge CA
xiii

xiv
Acronyms
ECB
Electronic Code Book
ECDSA
Elliptic Curve Digital Signature Algorithm
EEPROM
Electrically Erasable Programmable Read Only Memory
EFS
Encrypting File System
EV
Extended Validation
FINREAD
Financial Transactional IC Card Reader
FIPS
Federal Information Processing Standard
FTP
File Transfer Protocol
GNU
GNU’s Not Unix
GPG
Gnu Privacy Guard
GSM
Global System for Mobile Communications
HSM
Hardware Security Module
HTTP
Hypertext Transfer Protocol
IBE
Identity-Based Encryption
ICC
Integrated Circuit Card
ICT
Information and Communication Technology
IETF
Internet Engineering Task Force
IP
Internet Protocol
ISP
Internet Service Provider
ITSEC
Information Technology Security Evaluation Criteria
ITU
International Telecommunication Union
JCRE
Java Card Runtime Environment
JCA
Java Cryptography Architecture
JCE
Java Cryptography Extension
JCEKS
Java Cryptography Extension KeyStore
JKS
Java KeyStore
LAN
Local Area Network
LDAP
Lightweight Directory Access Protocol
LRA
Local Registration Authority
MAC
Message Authentication Code
MIME
Multipurpose Internet Mail Extensions
OC
Object Class
OCF
Open Card Framework
OCSP
Online Certiﬁcate Status Protocol
OID
Object Identiﬁer
OS
Operating System
PAM
Pluggable Authentication Module
PCI
Peripheral Component Interconnect
PC
Personal Computer
PC/SC
Personal Computer/Smart Card
PEM
Privacy Enhanced Mail
PER
Packed Encoding Rules
PGP
Pretty Good Privacy
PIN
Personal Identiﬁcation Number
PKCS
Public Key Cryptography Standards

Acronyms
xv
PKI
Public Key Infrastructure
PKC
Public Key Cryptography
PMI
Privilege Management Infrastructure
PoP
Proof of Possession
PSE
Personal Security Environment
PRNG
Pseudorandom Number Generator
PUK
Personal Unblocking Key
RA
Registration Authority
RDN
Relative Distinguished Name
RFC
Request for Comments
ROM
Read Only Memory
SASL
Simple Authentication and Security Layer
SCVP
Server-Based Certiﬁcate Validation Protocol
SHA
Secure Hash Algorithm
SIM
Subscriber Information Module
SKI
Subject Key Identiﬁer
SMTP
Simple Mail Transfer Protocol
SPKI
Simple Public Key Infrastructure
SSH
Secure Shell
SSL
Secure Socket Layer
TBS
To Be Signed
TCP
Transmission Control Protocol
TCP/IP
Transmission Control Protocol/Internet Protocol
TSA
Time-Stamping Authority
TSL
Trust-Service Status List
TSP
Time-Stamp Protocol
TLS
Transport Layer Security
TOE
Target of Evaluation
URI
Uniform Resource Identiﬁer
USB
Universal Serial Bus
UML
Uniﬁed Modeling Language
VPN
Virtual Private Network
W3C
World Wide Web Consortium
WAP
Wireless Application Protocol
WebDAV
Web-Based Distributed Authoring and Versioning
WLAN
Wireless Local Area Network
XER
XML Encoding Rules
X-KISS
XML Key Information Service Speciﬁcation
XKMS
XML Key Management Speciﬁcation
X-KRSS
XML Key Registration Service Speciﬁcation
XML
Extensible Markup Language

Chapter 1
The Purpose of PKI
Public key cryptography helps make information and communication technology
(ICT) systems more secure. Public key infrastructures (PKIs) enable the use of
public key cryptography in open computer networks, in particular on the Internet.
In this chapter, we use characteristic examples of Internet applications to illustrate
potential threats against ICT and describe important security goals that can be
achieved using public key cryptography and PKI. We discuss the basics of public
key cryptography and explain how this technology supports the security goals
explained in this chapter. Finally, we present the challenges that lead to the need
for PKI. For more details on public key cryptography see [4].
1.1
The Internet
The Internet is the most important application domain of public key cryptography
and public key infrastructures. It is an open “network of networks”, i.e. a worldwide,
publicly accessible network of interconnected computer networks that consists
of millions of smaller domestic, academic, business, and government networks.
It carries information and services, such as electronic mail, ﬁle transfer, social
networks and all kinds of other Web services. Nowadays, everything from health
care to business, production, and recreation activities depends on computers. Most
of these computers have access to the Internet. Thus, potentially anyone in the world
can access them. As of June 2012, 2.41 billion people in the world used the Internet
[8]. This is 34.3 % of the world population and a growth of 566.4 % since 2000.
An important Internet application is electronic commerce which is also called
e-commerce for short. E-commerce refers to any type of business on the Internet.
This covers a broad range: from Internet-based retail sites, through auction and
music sites, to exchanges of trading goods and services between corporations.
E-commerce allows consumers to electronically exchange goods and services
without barriers of time or distance. E-commerce has expanded rapidly recently.
The boundaries between “conventional” and “electronic” commerce have become
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__1, © Springer-Verlag Berlin Heidelberg 2013
1

2
1
The Purpose of PKI
increasingly blurred as more and more businesses move their operations to the
Internet.
Another Internet application is e-health. E-health encompasses services such
as maintenance of electronic medical records that enable easy communication
of patient data between different health care professionals, organizations, and
businesses. Another example of e-health is telemedicine, which includes all types of
physical and psychological measurements that do not require a patient to travel to
a specialist. Also, e-health enables virtual health care teams which consist of health
care professionals who collaborate and share information on patients through digital
equipment for transmural care.
Electronic government or shortly e-government, our third example, refers to
governmental use of the Internet to exchange information and services with citizens,
businesses, and other arms of government. E-government is applied by many
governmental units such as legislature, judiciary, or administration, in order to
improve internal efﬁciency and the delivery, accessibility, and convenience of public
services, or processes of democratic governance.
1.2
Security Goals
Many of the Internet services mentioned in Sect. 1.1 are highly security-sensitive.
This was emphasized in a white paper of the US Clinton administration from 1998
[20]. “The United States possesses both the world’s strongest military and its largest
national economy.... Because of our military strength, future enemies, whether
nations, groups or individuals, may seek to harm us in nontraditional ways....
Our economy is increasingly reliant upon interdependent and cyber-supported
infrastructures and nontraditional attacks on our infrastructures and information
systems may be capable of signiﬁcantly harming both our military power and our
economy.” As a consequence, the Internet must be protected from malicious attacks.
In this chapter we describe in more detail the protection goals conﬁdentiality,
integrity, entity authentication, data authenticity, and non-repudiation that can be
achieved using public key cryptography.
1.2.1
Conﬁdentiality
A very important security goal is conﬁdentiality. It refers to the property that data or
information is not made available or disclosed to unauthorized persons or processes.
Conﬁdentiality is closely related to privacy. Privacy is the ability of an individual or
group to keep information about itself conﬁdential and to control the access to and
use of such information.
We present a few examples where conﬁdentiality is an important protection goal.
As early as 1977 Martin Gardner wrote [7]: “Government agencies and large
businesses will presumably be the ﬁrst to make extensive use of electronic mail,

1.2
Security Goals
3
followed by small businesses and private individuals. When this starts to happen,
it will become increasingly desirable to have fast, efﬁcient ciphers to safeguard
information from electronic eavesdroppers.” Today, email is widely used for private,
business, and government communication. In many cases, emails contain conﬁden-
tial information. But most email messages can be easily intercepted. They travel
through an indeterminate set of systems and network devices, each of which offers
a point of interception. These systems are operated, for example, by companies,
universities, governments, or telecommunication providers. In such environments
adversaries may easily gain access to email messages.
Conﬁdentiality and privacy is also of great importance in the context of e-health.
Unauthorized persons and processes must be prevented from seeing patient data
that is communicated between different health care professionals, organizations, and
businesses. Likewise, virtual health care teams that share information on patients
must keep this information conﬁdential.
Maintaining conﬁdentiality is also a serious issue in e-government. On 21
November 2007, The New York Times reported: “The British government struggled
Wednesday to explain its loss of computer disks containing detailed personal
information on 25 million Britons, including an unknown number of bank account
identiﬁers, in what analysts described as potentially the most signiﬁcant privacy
breach of the digital era” [15].
1.2.2
Integrity
Integrity refers to the property that data has not been modiﬁed. There are many
contexts in which being able to check the integrity is very important. For example,
the integrity of software running in a security-sensitive context such as e-health,
e-commerce, or e-government must be protected in order to prevent malicious
changes. Such changes may for example cause the systems to transmit conﬁdential
information to unauthorized entities. Since integrity is such an important protection
goal, common criteria (CC) evaluations require evaluated software, the so-called
target of evaluation (TOE), to provide “controls to ensure that unauthorized
modiﬁcations are not made to the TOE” [5]. Examples of devices that are required
to be CC-evaluated are the device that connects a medical practice in Germany to the
Internet, the so-called Konnektor, and the microprocessors that are used in European
electronic passports.
1.2.3
Entity Authentication
Entity authentication is a process by which a veriﬁer is assured of the identity of
a prover whose identity is to be established. Instead of entity authentication we
also use the term identiﬁcation. Both the veriﬁer and the prover can be persons,

4
1
The Purpose of PKI
Fig. 1.1 The login process of TU Darmstadt
IT components, IT processes, and so on. Entity authentication is different from
data authenticity, which is described in Sect. 1.2.4. Entity authentication is required
by many applications, for example, in the online authentication system of TU
Darmstadt, which is shown in Fig. 1.1. First, users register with TU Darmstadt by
providing their name and selecting a secret password. When users want to log in
later to their TU Darmstadt account they submit this user name and password.
Identiﬁcation with user name and password is quite common in e-commerce,
e-government, and e-health applications. However, there are rather effective attacks
against this identiﬁcation method. An example is that of phishing attacks. In such
an attack, the adversary attempts to fraudulently acquire sensitive information, such
as user names, passwords and credit card details, by masquerading as a trustworthy
entity in an electronic communication. As we will see in Sect. 1.3.7, PKI provides
stronger entity authentication mechanisms.
1.2.4
Data Authenticity
Authenticity of data includes integrity and additionally requires that the origin of the
data can be determined.
Authenticity of data is required in many contexts and applications. For example,
banks must be certain that electronic ﬁnancial transactions are authentic. Likewise,
security-sensitive emails must be authentic. Another example is software updates.
Such updates become necessary when software errors, in particular security holes

1.3
Cryptography
5
in operating systems and application software, are discovered or newer versions
with more functionality become available. Updating computers must authenticate
all updates. Otherwise, an adversary may be able to supply updates that cause
severe damage. For example, a fraudulent operating system update may erase the
computer’s hard disc, thereby destroying all data of all users of that computer.
Remote updates are also used for smart phones and many other devices.
1.2.5
Non-repudiation
Non-repudiation is a property of data or processes which prevents an entity from
denying having performed a particular action, for example having sent an email or
having initiated a money transfer.
As an example, consider electronic contracts. In many countries they are as
binding as paper contracts. The parties involved in such a contract must not be able
to repudiate this contract later. Also, physicians who issue electronic prescriptions
must not be able to repudiate the prescription later. Likewise, electronic tax
declarations must not be repudiable at a later point in time.
1.2.6
Other Security Goals
There are many more security goals in which PKI plays an important role. An
example is anonymity. It is a condition in which an individual’s true identity is
unknown. For example, anonymity is important in electronic elections where the
voters have to remain anonymous. Another security goal which is relevant in the
context of electronic elections is uncoercibility. Coercibility means that an adversary
can force a voter to cast a certain vote.
1.3
Cryptography
In the previous section we have described important security goals that arise in the
electronic world. In this section, we review basic mechanisms from cryptography
and speciﬁcally from public key cryptography. We explain how these techniques
help achieving the described security goals.
1.3.1
Secret Key Encryption
Traditionally, conﬁdentiality of data is provided by secret key cryptosystems.
Examples of such cryptosystems are the Data Encryption Standard (DES) [11],

6
1
The Purpose of PKI

	
plaintext
	

	

	
	
plaintext
decrypt
encrypt
secret
secret
secret
secret
=
symmetric
Alice
Bob
Fig. 1.2 The process of secret key encryption
Table 1.1 Performance of
symmetric cryptosystems
AES
Twoﬁsh
RC6
Serpent
DES-ede
35 ms
31 ms
20 ms
58 ms
141 ms
which was selected as an ofﬁcial Federal Information Processing Standard (FIPS)
for the United States in 1976 and published in 1977, and its successor, the Advanced
Encryption Standard (AES) [14]. AES became effective as a standard in 2002. DES
in its original form is no longer secure. However, there are still secure variants of
DES such as DES-ede [12]. There are many more secret key encryption schemes,
for example RC6 [16], Serpent [18], and Twoﬁsh [22].
In a secret key cryptosystem, the communication partners—call them Alice
and Bob—agree on a secret key before they secretly communicate. For this key
agreement they may use a secure channel, for example a courier. Alice and Bob can
also use the Difﬁe-Hellman key exchange protocol [6]. It was invented in 1976 and
does not require a secure channel.
Figure 1.2 shows the process of secret key encryption. Suppose that Alice and
Bob have successfully exchanged a secret key. If Alice wishes to send a conﬁdential
message to Bob, she uses this secret key to encrypt the data to be kept conﬁdential.
The data that is to be encrypted is called the plaintext. The result of the encryption
is the ciphertext. Alice sends the ciphertext to Bob. Upon receiving the ciphertext,
Bob uses the secret key that he has exchanged with Alice to decrypt the ciphertext.
If the cryptosystem is secure, then nobody can obtain any information concerning
the plaintext without the knowledge of the secret key.
Secret key cryptosystems are also referred to as symmetric cryptosystems since
both Alice and Bob have the same key. In some symmetric encryption schemes, the
encryption and decryption keys are different. However, they can be easily computed
from each other. Some secret key cryptosystems that are used in practice and the
time required to encrypt 1 MByte on a dual core 2.8 GHz computer using the Java
library Bouncy Castle [21] are shown in Table 1.1. All algorithms have a block size
of 128 bits, except DES-ede, which has the block size 64. The mode of use is the
electronic code book (ECB) mode.

1.3
Cryptography
7
Table 1.2 A public key
directory
Name
Public key
Buchmann
13121311235912753192375134123
Karatsiolis
84228349645098236102631135768
Wiesmaier
73528720920032836216521830930
Alice
54628291982624638121025032510
Bob
27381253812351972497652990930
:::
:::
1.3.2
Public Key Encryption
With the development of open computer networks such as the Internet with its
billions of users, exchanging secret keys between potential communication partners
as required by secret key cryptography became rather impractical.
One possible solution of this key distribution problem is to let a central authority,
the key center, distribute secret keys to all users. Applying these keys, the users can
secretly communicate with each other. An example of such an architecture is the
mobile phone standard GSM. In fact, GSM uses many interconnected key centers.
Each GSM provider operates one or more key centers. However, key distribution by
a centralized key center has a serious disadvantage. The key center can potentially
access all secret messages. This only works in closed environments where all users
trust the central authorities, for example their mobile phone providers. In an open,
decentralized environment such as the Internet, key distribution by key centers is
inappropriate. For such a situation, public key cryptography was invented.
The main idea of a public key cryptosystem is that two different but related
keys are used: one for encryption and one for decryption. Decryption works with
the decryption key only and not with the encryption key, and vice versa. As the
decryption key cannot be determined from the encryption key, the encryption key
can be made public. In order for a user Bob to receive conﬁdential messages, he
uses a key pair consisting of an encryption key and the corresponding decryption
key. Bob keeps the decryption key secret while his encryption key is made public
(as illustrated in Table 1.2). The encryption key is called Bob’s public key; the
corresponding decryption key is called Bob’s private key. Once the keys are
generated and Bob’s public key is published, Bob can receive conﬁdential messages
from anyone. No further key distribution is required.
This is illustrated in Fig. 1.3. Alice wishes to send a conﬁdential message to Bob.
She uses Bob’s public key to encrypt the message. The result of this encryption is
a ciphertext which is sent to Bob. Bob decrypts this message using his private key.
Since Bob keeps his private key secret, Alice’s message remains conﬁdential. This
shows that in public key cryptosystems key distribution only requires making public
keys accessible.
Public key cryptosystems are also called asymmetric cryptosystems. Public key
encryption not only provides conﬁdentiality. It can also be used to implement
identiﬁcation protocols. Suppose that the prover Bob who possesses a secret

8
1
The Purpose of PKI
plaintext
plaintext
decrypt
encrypt
Bob’s
public key
Bob’s
private key
≠
asymmetric
ciphertext
Alice
Bob
Fig. 1.3 The process of asymmetric encryption
encryption key wishes to identify himself to the veriﬁer Alice. Alice selects a
random number, encrypts it with Bob’s public key and sends the ciphertext to Bob.
Upon receiving the ciphertext, Bob decrypts it and sends the random number back
to Alice. Alice is convinced of Bob’s identity if the random number that she receives
from Bob is the same as the random number that she has sent to him. However, this
simple protocol has several drawbacks. One problem is that Alice can make Bob
decrypt messages of her choice since Bob may not be able to distinguish encrypted
random numbers from other ciphertexts. For this reason, public key encryption is
typically not used for entity authentication. Instead, digital signatures are used, these
are described in Sect. 1.3.7.
1.3.3
The RSA Public Key Cryptosystem
The ﬁrst and most frequently used public key cryptosystem is the RSA cryptosystem.
It is named after its inventors Rivest, Shamir, and Adleman, who received the
2002 Turing award for their invention. We explain a basic version of the RSA
cryptosystem. For details see [4].
To generate his secret and the corresponding public key, Bob selects two large
prime numbers p and q and computes their product
n D pq:
(1.1)
Bob also chooses an integer e with
1 < e < '.n/ D .p  1/.q  1/ and gcd.e; .p  1/.q  1// D 1:
(1.2)
Note that e is always odd since .p  1/.q  1/ is even. Bob computes an integer d
with
1 < d < .p  1/.q  1/ and de  1 mod .p  1/.q  1/:
(1.3)

1.3
Cryptography
9
That number can be computed by the extended Euclidean algorithm. Bob’s public
key is the pair .n; e/. His private key is d. The number n is called the RSA modulus,
e is called the encryption exponent, and d is called the decryption exponent. Note
that the private key d can be computed from the encryption exponent e if the prime
factors p and q of the RSA modulus n are known. Therefore, if an adversary—call
her Eve—is able to ﬁnd the prime factorization of n, then she can easily ﬁnd Bob’s
private key d. In fact, it can be shown that ﬁnding the private key d requires the
knowledge of the secret factors p and q.
Example 1.1. Bob chooses the prime factors p D 11 and q D 23. Then n D 253
and .p1/.q 1/ D 1022 D 220. The smallest possible encryption exponent e is
e D 3 since gcd.3; 220/ D 1. For this encryption exponent, the extended Euclidean
algorithm yields the decryption exponent d D 147.
The possible plaintexts for the RSA cryptosystem are the integers m with
0  m < n:
(1.4)
A plaintext m is encrypted by raising it to the eth power mod n. So the ciphertext is
c D me mod n:
(1.5)
If Alice knows the public key .n; e/, she can encrypt m.
Example 1.2. As in Example 1.1, let n D 253 and e D 3. Then the plaintext space
is f0; 1; : : : ; 252g. Encrypting the integer m D 165, Alice obtains 1653 mod 253 D
110.
To decrypt the ciphertext c, Bob computes the dth power of c mod n. So we have
m D cd mod n:
(1.6)
Example 1.3. We conclude Examples 1.1 and 1.2. There, we have chosen n D 253,
e D 3, and d D 147. Moreover, we have computed the ciphertext c D 110. Bob
can reconstruct the plaintext as 110147 mod 253 D 165.
RSA works because raising integers to eth powers mod n is easy for anybody
who knows the public key .n; e/. But for sufﬁciently large RSA moduli extracting
eth roots mod n is intractable without knowledge of the private key d.
1.3.4
Other Public Key Cryptosystems
Algorithms for factoring composite integers has been a research topic for many
decades. After the invention of RSA, this research was intensiﬁed but no efﬁcient
factoring algorithm has been found that works on classical computers. This does not
mean that polynomial time factoring algorithms are impossible. On the contrary,

10
1
The Purpose of PKI
Table 1.3 Performance of
public key cryptosystems
RSA
ElGamal
3.3 s
423 s
symmetric session key

	
plaintext
decrypt
	

	

	
	
encrypt
plaintext
decrypt
encrypt
Alice
Bob
Bob’s public key
Bob’s private key
Fig. 1.4 Hybrid encryption
in 1994 Peter Shor invented a polynomial time factoring algorithm for quantum
computers [19]. However, building sufﬁciently large quantum computers for fac-
toring large numbers is still out of reach. In the future, there may also appear new
efﬁcient factoring algorithms. It is therefore not sufﬁcient to rely on the RSA cryp-
tosystem. Alternatives are, for example, elliptic curve cryptosystems. Their security
is based on the difﬁculty of computing discrete logarithms in the group of points
of an elliptic curve over ﬁnite ﬁelds. Elliptic curve cryptosystems use much smaller
keys than RSA. However, discrete logarithm-based cryptosystems are also subject to
efﬁcient quantum computer attacks. An alternative cryptosystem that appears to be
immune against quantum computer attacks is the McEliece cryptosystem (see [2]).
1.3.5
Hybrid Encryption
The known public key cryptosystems are not as efﬁcient as many symmetric
cryptosystems. Two public key cryptosystems and the time required to encrypt
1 MByte on a dual core 2.8 GHz computer using the Java library Bouncy Castle and
the padding method described in the PKCS#1 standard [17] are shown in Table 1.3.
Therefore, in practice, hybrid encryption is used. Hybrid encryption is an efﬁcient
combination of public key and secret key cryptosystems. It is illustrated in Fig. 1.4.
In principle, hybrid encryption works as follows.

1.3
Cryptography
11
Hybrid encryption uses an efﬁcient symmetric cryptosystem together with a
public key scheme. Alice wants to send an encrypted message to Bob. She generates
a session key for the symmetric cryptosystem. At this point of the protocol, this
session key is not known to Bob. It is only known to Alice who generated it.
Alice encrypts the message for Bob using the symmetric encryption scheme and the
session key. She obtains a ciphertext. Since the symmetric cryptosystem is efﬁcient,
this encryption is fast. But Bob is not able to decrypt the ciphertext as long as
he does not know the session key. Therefore, Alice encrypts the session key with
Bob’s public key. Since the session key is small, this encryption is also fast although
the encryption function of the public key system may not be very efﬁcient. Alice
sends the ciphertext and the encrypted session key to Bob. Bob decrypts the session
key using his private key. Then he decrypts the ciphertext using the session key
and obtains the original message. Here, the public key system is only used for the
conﬁdential transport of the session key. This is how hybrid encryption combines
the elegance of key management of public key cryptosystems with the efﬁciency of
secret key cryptosystems.
1.3.6
Cryptographic Hash Functions and Message
Authentication Codes
Hash functions map arbitrary bit strings to strings of ﬁxed length. They are of the
form
h W f0; 1g ! f0; 1gn
(1.7)
where n is a positive integer. For simplicity, we have used the alphabet f0; 1g, which
may be replaced by any other ﬁnite set. Cryptographic hash functions are hash
functions with additional security properties. The most important property in our
context is collision-resistance. The hash function (1.7) is called collision-resistant
if ﬁnding two distinct strings w and w0 with the same hash value h.w/ D h.w0/ is
infeasible.
Cryptographic hash functions may be used to establish integrity, for example
of software. When software s is installed on some computing device, its hash value
x D h.s/ is calculated and stored in some other secure place, for example on a smart
card. When it comes to checking the integrity of the software s at a later point in
time, the hash value x0 D h.s0/ of the potentially modiﬁed software s0 is calculated.
If the two hash values h.s/ and h.s0/ are identical, then the integrity of the software
is proved. This follows from the fact that the hash function is collision-resistant.
In order to provide data authenticity, a message authentication code (MAC) can
be used. MACs are closely related to cryptographic hash functions. A MAC works
as follows. If Alice wishes to exchange authenticated messages with Bob they ﬁrst
agree on a secret MAC key. To send an authenticated message to Bob, Alice uses
this key to compute the MAC of the message. Like hash values, MACs are also short

12
1
The Purpose of PKI
Table 1.4 Performance of MAC algorithms
HMAC-SHA1
HMAC-SHA512
HMAC-MD5
HMAC-Tiger
16 ms
53 ms
9 ms
24 ms
bit strings of ﬁxed length. Alice sends the message together with the MAC to Bob.
Bob can use the shared secret key to verify the MAC.
In Table 1.4 we present a few MAC algorithms and show their performance on
processing of 1 MByte on a dual core 2.8 GHz using the Java library Bouncy Castle.
MACs can in principle also be used for entity authentication. Alice and Bob agree
on a secret key. When Alice wants to authenticate Bob, she sends a random string
to Bob. Bob calculates the MAC of that string and returns it to Alice. Alice veriﬁes
Bob’s identity by verifying the MAC. However, this identiﬁcation procedure has the
disadvantage of only working between two parties. Bob cannot use the same secret
key to authenticate himself to other communication partners since Alice, knowing
the secret, could impersonate Bob. This problem can be solved if an authentication
center is used that shares a secret key with all users. In order for Alice to identify
Bob she delegates the identiﬁcation of Bob to this authentication center.
Identiﬁcation solutions that do not rely on authentication centers are based on
digital signatures or dedicated identiﬁcation protocols, which are discussed in the
following sections.
1.3.7
Digital Signatures
In many contexts, entity and data authentication cannot be based on symmetric
techniques such as MACs. As an example, consider software updates. If a software
manufacturer such as Adobe or Microsoft issues a software update, it is important
for the users to be able to authenticate this update. This has been explained in
Sect. 1.2.4. However, the users must not be able to impersonate the software vendor
and distribute their own software updates. Therefore, MACs cannot be used in this
context. An asymmetric authentication mechanism is required that allows computers
to authenticate software updates without being able to generate authentic software
updates themselves. Digital or electronic signature schemes have this property.
In a digital signature scheme, the signer Bob uses his secret signature key to
calculate digital signatures of documents. That key is also referred to as Bob’s
private key. Potential veriﬁers can use Bob’s public veriﬁcation key that corresponds
to the secret signature key to verify Bob’s digital signature. The veriﬁcation key
is also called Bob’s public key. As in public key cryptosystems, the private keys
in a signature scheme cannot be computed from the corresponding public keys.
Figure 1.5 illustrates digital signatures.
Digital signatures can be used to prove the integrity and authenticity of data.
Also, digital signatures provide entity authentication and non-repudiation. Because
of those numerous applications, digital signatures are an extremely important cryp-
tographic tool. We now explain the various uses of digital signatures in more detail.

1.3
Cryptography
13
valid /
invalid
plaintext
sign
verify
plaintext
Signature
private
public
Fig. 1.5 Digital signatures
Suppose that Bob signs data such as an email or a bank transaction digitally. By
verifying this signature, Alice convinces herself that the data origin is Bob and that
the data has not been altered. This way, integrity and authenticity of the data are
established. In fact, many software vendors such as Microsoft, Apple, and Adobe
use digital signatures to authenticate software updates.
Next we explain that digital signatures also provide non-repudiation. Alice and
Bob agree on a contract. They both sign this contract digitally. At a later point
in time, Bob repudiates the contract. Alice presents Bob’s digital signature on the
contract to a judge in order to prove that Bob agreed to the contract. The judge
obtains Bob’s public key and veriﬁes the signature. It convinces the judge that Bob
has in fact signed the contract.
Digital signatures can also be used for entity authentication. There are several
ways to realize this. We explain a basic challenge-response identiﬁcation scheme
that uses digital signatures. Suppose that Alice wishes to identify herself to Bob.
Bob sends a random number (the challenge) to Alice. She signs that random number
and sends the digital signature (the response) to Bob. The successful veriﬁcation of
the signature will convince Bob of Alice’s identity. Since there is a new random
challenge each time, identiﬁcation based on digital signatures is more secure than
user name with password identiﬁcation.
There are many variants of the identiﬁcation protocol described here. For
example, the SSL and TLS protocols combine identiﬁcation with setting up a secure
channel. This will be discussed in Chap. 10.
1.3.8
The RSA Signature Scheme
The most widely used digital signature algorithm is the RSA scheme. Key gen-
eration for this algorithm works exactly as in the RSA cryptosystem presented in
Sect. 1.3.3. To describe the operations of signing and verifying we use the notation

14
1
The Purpose of PKI
introduced in Sect. 1.3.3. The private key d becomes the private signature key. The
public key .n; e/ becomes the public veriﬁcation key.
In addition to signature and veriﬁcation keys, a publicly known collision-resistant
hash function
h W f0; 1g ! f0; 1; : : : ; n  1g
(1.8)
is used. The signature of a string D 2 f0; 1gn is
s D h.D/d mod n:
(1.9)
To verify this signature, the veriﬁer uses the signer’s public key .n; e/, determines
the hash value h.D/ and checks that
h.D/ D se mod n:
(1.10)
If this congruence holds, then the signature is valid. Otherwise, it is invalid.
Example 1.4. Alice chooses p D 11, q D 23, e D 3. She obtains n D 253,
d D 147. Alice’s public key is .253; 3/. Her private key is 147.
Alice wants to sign a data string D with hash value h.D/ D 111. She computes
s D 111147 mod 253 D 89. The veriﬁer veriﬁes the signature by computing s3 mod
253 D 111 and checking that this value matches with the hash value.
It is also possible to generate the signature as
s D Dd mod n
(1.11)
without previously hashing the document to be signed. Then the document has to be
chosen from the set f0; 1; : : : ; n  1g and it is possible to recover the document by
verifying the signature
D D se mod n:
(1.12)
This is called a signature with message recovery. As explained in [4], using RSA
with message recovery opens the possibility of existential forgeries.
1.3.9
Other Digital Signature Schemes
There are several alternatives to the RSA signature scheme. Alternative systems
that are used in practice are the digital signature algorithm (DSA) [13] and the
elliptic curve digital signature algorithm (ECDSA) [9]. Their security is based on
the difﬁculty of computing discrete logarithms in the multiplicative group of a ﬁnite
ﬁeld or in the group of points of an elliptic curve over a ﬁnite ﬁeld, respectively.

1.4
Why Public Key Infrastructure?
15
As explained in Sect. 1.3.4, sufﬁciently large quantum computers can factor RSA
moduli and compute discrete logarithms very efﬁciently. An alternative efﬁcient
signature scheme that appears to be quantum computer-immune is the Merkle
Signature Scheme and its extensions [2].
1.4
Why Public Key Infrastructure?
We have seen how public key cryptography achieves important IT security goals.
The advantage of public key cryptography is that no exchange of secret keys is
required. But in public key cryptography, keys must also be managed appropriately.
The efﬁcient and secure management of the key pairs during their whole life cycle
is the purpose of public key infrastructures. This life cycle is the following.
The ﬁrst phase is key generation. In this step, a key pair is created. The next
phase is key usage. In this phase, the private key is used to decrypt or sign data.
Also, users have access to the public keys of other users to encrypt ciphertexts or to
verify signatures. In the ﬁnal stage of its life cycle a key pair becomes invalid. For
example, this happens when the validity period of the key pair ends or when the key
pair is invalidated because it is compromised.
There are several tasks of a PKI associated with each stage of the life cycle of
key pairs.
The ﬁrst task is to ensure that in the key generation phase, secure key pairs are
produced. One option is to let the users generate their own key pairs. Then they can
prevent the private keys from being disclosed to unauthorized persons. However, due
to technical limitations, users may not be able to generate secure keys. For example,
creating keys on computers that are connected to the Internet may be insecure since
those computers may be infected by malware. Hence, it appears to be more secure to
generate keys on dedicated hardware such as smart cards. However, this may also be
problematic. For example, consider the RSA system. RSA keys are generated using
two random prime numbers of approximately equal size. In the generation of those
prime numbers pseudorandom number generators (PRNG) are used. Those PRNGs
must be cryptographically secure, which means that predicting their result must be
infeasible. This is necessary to prevent adversaries from reconstructing the private
keys of users. But smart cards may not have enough computational resources to run
secure PRNGs. An alternative is to have the key pairs generated by a trusted third
party which has sufﬁcient computational power to generate secure keys. However,
if a trusted third party generates the key pairs, the private keys become also known
to that party, which may compromise the conﬁdentiality of private keys. Thus,
establishing an appropriate process for key generation is a challenging task for a
PKI.
In the key usage phase, a PKI also has several important tasks. The most
important and complex task of a PKI is to make the public keys available to the
users. It is not sufﬁcient to simply publish the public keys. Those who use public
keys must be able to verify their authenticity and validity and must know their

16
1
The Purpose of PKI
properties. If the authenticity of Bob’s public keys is not guaranteed, the adversary
Oscar may be able to replace Bob’s public keys with his own public keys. This may
enable him to decrypt messages that were encrypted for Bob or sign documents in
the name of Bob. Key validity refers to several issues. Public keys become invalid
when they expire. Also, public keys may be intended for a certain purpose. For
example, for security reasons, signature keys may be intended for document signing
but not for identiﬁcation. An example of an important property of a key pair is
the policy that was applied when the key was generated. For example, this policy
determines the level of protection that was used during key generation. Users may
ﬁnd this protection level too low and may therefore decide not to use the key.
The next task of a PKI is to deal with the problem of public keys becoming
insecure. This may happen for various reasons. For example, if the smart card on
which Alice keeps her secret signature key is stolen, the corresponding public key
must no longer be used to verify signatures of Alice. PKI users must be informed
that this is the case. Even more dramatically, if a public key cryptosystem is broken,
then all public keys that have been issued using this public key cryptosystem must
be invalidated.
Another task of a PKI in the key usage phase is to enable key backup whenever
necessary. For example, if Alice loses her smart card with her private decryption
key she can no longer access her encrypted ﬁles unless there is a backup of that
decryption key. Since private keys must be kept conﬁdential, key backup is a
security-sensitive issue. Note that private signature keys do not require backups.
When they are lost they may be replaced with new keys.
The ﬁnal task of a PKI in the usage phase is to support the protection of private
keys. This can be done by making secure software or hardware components such as
smart cards available and managing those components.
Once keys expire or become invalid for some other reason, the PKI must manage
those invalid keys. One option is to destroy them. Another option is to archive
them for later use. Invalid public encryption keys may be deleted. However, expired
private decryption keys may have to be archived to maintain the accessibility of
data that was encrypted using the corresponding encryption keys. Likewise, invalid
private signature keys may be deleted as they must no longer be used to sign data.
However, public veriﬁcation keys may have to be archived to allow veriﬁcation of
signatures that are used to provide long-term authentication or non-repudiation.
1.5
Identity-Based Public Key Cryptography
As we will see in the remainder of this book, setting up a PKI in which public keys
are available for all users is a challenging task. In order for users to be able to access
those public keys, they must be online or keep archives of relevant public keys. For
some contexts this is inappropriate. For example, consider an emergency situation
in which rescue workers, ﬁre ﬁghters, and police ofﬁcers wish to communicate
conﬁdentially. Since they are an ad hoc group, they do not know each other’s public

1.7
Exercises
17
keys. They also may not have access to a central public key directory. For such a
group of users, identity-based public key cryptography is very useful. It allows them
to compute the public keys from each other’s identities. No further authentication of
the public keys is needed.
Identity-based cryptography does not require a public key infrastructure that
distributes keys. However, there are several issues that must be considered. In
identity-based cryptography, the private keys of users are computed by a trusted
authority that has a secret master key. In principle, that authority can use all these
private keys. Also, revocation of invalid keys is more challenging as the public keys
are computed from identities that cannot be revoked. Because of these deﬁciencies,
identity-based public key cryptography is only used in niche applications.
In practice, mostly identity-based encryption (IBE) is used. In [3] the implemen-
tation guidelines for two identity-based encryption algorithms are presented. An
infrastructure for IBE is described in [1]. Using IBE for sending encrypted emails
is speciﬁed in [10].
1.6
Object Identiﬁers
To make cryptography interoperable, standards are necessary that ﬁx sizes, param-
eters, formats, and so on. Standardized cryptographic algorithms are referred to by
object identiﬁers (OIDs). Table 1.5 presents OIDs of the most important cryptosys-
tems. For example, the OID “1.2.840.113549.1.1.5”stands for the signature scheme
RSA used in combination with the cryptographic hash function SHA1.
OIDs identify arbitrary objects and not only cryptographic algorithms. Therefore
they are used extensively in a PKI for interoperability purposes.
1.7
Exercises
1.1. A bookseller offers books for sale on the Internet. He publishes the list of
offered books on his Web page. A customer selects books and speciﬁes the payment
method. Upon receiving the estimated delivery time, price, and delivery details
the customer completes the order and sends the necessary data for payment and
processing. The dealer replies with an acknowledgement. Which security goals are
relevant in which step of the transaction?
1.2. Identiﬁcation may be based on the proof of user characteristics of the following
types:
•
Properties (e.g. eye color).
•
Abilities (e.g. a handwritten signature).
•
Knowledge (e.g. a password).
•
Possession (e.g. an entrance ticket).

18
1
The Purpose of PKI
Table 1.5
Examples of OIDs
Algorithm
Type
OID
MD5
Cryptographic hash function
1.2.840.113549.2.5
SHA1
Cryptographic hash function
1.3.14.3.2.26
SHA256
Cryptographic hash function
2.16.840.1.101.3.4.2.1
SHA384
Cryptographic hash function
2.16.840.1.101.3.4.2.2
SHA512
Cryptographic hash function
2.16.840.1.101.3.4.2.3
SHA256withDSA
Digital signature
2.16.840.1.101.3.4.3.2
SHA256withECDSA
Digital signature
1.2.840.10045.4.3.2
SHA384withECDSA
Digital signature
1.2.840.10045.4.3.3
SHA512withECDSA
Digital signature
1.2.840.10045.4.3.4
MD5withRSA
Digital signature
1.2.840.113549.1.1.4
SHA1withRSA
Digital signature
1.2.840.113549.1.1.5
SHA1withDSA
Digital signature
1.2.840.10040.4.3
SHA1withECDSA
Digital signature
1.2.840.10045.4.1
AES with 128 bit key in ECB mode
Secret key encryption
2.16.840.1.101.3.4.1.1
AES with 256 bit key in CBC mode
Secret key encryption
2.16.840.1.101.3.4.1.42
HMAC-MD5
MAC
1.3.6.1.5.5.8.1.1
HMAC-SHA1
MAC
1.3.6.1.5.5.8.1.2
RSA
Public key encryption
1.2.840.113549.1.1.1
Give further examples of each type.
1.3. In order to strengthen password identiﬁcation, identiﬁcation servers store
cryptographic hash values of passwords. When a user identiﬁes herself, she types in
the password, the client computes and transmits the hash of the password, and the
server compares the transmitted value with its stored hash value.
1. Discuss the security of this method. In particular, show how a replay attack can
be mounted.
2. How can the replay attack be prevented?
References
1. G. Appenzeller, L. Martin, M. Schertler, Identity-based encryption architecture and supporting
data structures, in IETF Request for Comments, 5408, Jan 2009
2. D.J. Bernstein, J. Buchmann, E. Dahmen (ed.), Post Quantum Cryptography (Springer, Berlin,
2008)
3. X. Boyen, L. Martin, Identity-based cryptography standard (IBCS) #1: supersingular curve
implementations of the BF and BB1 cryptosystems, in IETF Request for Comments, 5091, Dec
2007
4. J.A. Buchmann, Introduction to Cryptography, 2nd edn. (Springer, New York, 2004)
5. Common Criteria, Common criteria for information technology security evaluation—part 3:
security assurance components—version 3.1 (2007), http://www.commoncriteriaportal.org/
thecc.html

References
19
6. W. Difﬁe, M.E. Hellman, New directions in cryptography. IEEE Trans. Inf. Theory IT-22(6),
644–654 (1976)
7. M. Gardner, Mathematical games: a new kind of cipher that would take millions of years to
break. Sci. Am. 237(2), 120–124 (1977)
8. Internet Usage, http://www.internetworldstats.com/stats.htm
9. D. Johnson, A. Menezes, S. Vanstone, The elliptic curve digital signature algorithm (ECDSA).
Int. J. Inf. Secur. 1(1), 36–63 (2001)
10. L. Martin, M. Schertler, Using the Boneh-Franklin and Boneh-Boyen identity-based encryption
algorithms with the cryptographic message syntax (CMS), in IETF Request for Comments,
5409, Jan 2009
11. National Bureau of Standards, Data Encryption Standard, FIPS PUB 46, Jan 1977
12. National Institute of Standards and Technology (NIST), FIPS PUB 46-3 – Data Encryption
Standard (DES) (1999), http://csrc.nist.gov/publications/ﬁps/ﬁps46-3/ﬁps46-3.pdf
13. National Institute of Standards and Technology (NIST), FIPS PUB 186-2 – Digital Signature
Standard (DSS) (2000), http://csrc.nist.gov/publications/ﬁps/archive/ﬁps186-2/ﬁps186-2.pdf
14. National Institute of Standards and Technology (NIST), FIPS PUB 197 – speciﬁcation for the
Advanced Encryption Standard (AES) (2001), http://csrc.nist.gov/publications/ﬁps/ﬁps197/
ﬁps-197.pdf
15. Privacy Breach, http://www.nytimes.com/2007/11/22/world/europe/22data.html
16. R.L. Rivest, M.J.B. Robshaw, R.Sidney, Y.L. Yin, The RC6 block cipher (1998), ftp://ftp.
rsasecurity.com/pub/rsalabs/rc6/rc6v11.pdf
17. RSA Laboratories, PKCS #1 v2.1: RSA cryptography standard (2002), http://www.rsa.com/
rsalabs/node.asp?id=2125
18. Serpent – A Candidate Block Cipher for the Advanced Encryption Standard, http://www.cl.
cam.ac.uk/~rja14/serpent.html
19. P.W. Shor, Algorithms for quantum computation: discrete logarithms and factoring, in Pro-
ceedings of the 35th IEEE Annual Symposium on Foundations of Computer Science, Santa Fe,
Nov 1994, pp. 124–134
20. The Clinton Administration’s Policy on Critical Infrastructure Protection: Presidential Deci-
sion Directive 63 (1998), http://csrc.nist.gov/drivers/documents/paper598.pdf
21. The Legion of the Bouncy Castle, http://www.bouncycastle.org/
22. Twoﬁsh, http://www.schneier.com/twoﬁsh.html

Chapter 2
Certiﬁcates
A major task of a PKI is to provide authenticity proofs for public keys. Important
tools that are used in such proofs are certiﬁcates. In this chapter we explain the
concept of a certiﬁcate and the main certiﬁcate standards.
2.1
The Concept of a Certiﬁcate
Suppose that user Alice wishes to verify a digital signature issued by user Bob. She
queries a directory service and obtains Bob’s public key. As explained in Sect. 1.4,
Alice needs to convince herself of the authenticity of that public key. This is what
certiﬁcates are used for. Certiﬁcates are data structures that bind public keys to
entities and that are signed by a third party. If Alice has a certiﬁcate for Bob’s
public key and if Alice trusts the third party that signed the certiﬁcate and also
trusts the signature veriﬁcation key of the third party, then verifying the signature of
the certiﬁcate convinces Alice of the authenticity of Bob’s public key. In this way,
certiﬁcates reduce the trust in a public key of an entity to the trust in some authority.
This reduction can be iterated. This is explained in Sect. 3.3 where certiﬁcate chains
are introduced.
We list the minimum contents of a certiﬁcate.
1. The name of the subject to which the public key in the certiﬁcate is bound. This
may also be a pseudonym.
2. The public key which is bound to the entity.
3. The cryptographic algorithm with which the public key is to be used.
4. The serial number of the certiﬁcate.
5. The validity period of the certiﬁcate.
6. The name of the issuer of the certiﬁcate that signed the certiﬁcate.
7. Restrictions that apply to the usage of the public key in the certiﬁcate. For
example, the usage may be restricted to entity authentication.
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__2, © Springer-Verlag Berlin Heidelberg 2013
21

22
2
Certiﬁcates
As we will see in the next section, certiﬁcates may contain much more informa-
tion. The certiﬁcate content is signed by the issuing third party and the signature is
appended to the certiﬁcate.
Typically, the issuer of a certiﬁcate is different from the subject. However, there
are self-issued certiﬁcates in which subject and issuer are the same. They are, for
example, used if issuers change their policy. A special case of self-issued certiﬁcates
are self-signed certiﬁcates which have the additional property that the certiﬁed
public key is also the public key required to verify the signature on the certiﬁcate.
Self-signed certiﬁcates are used to make public keys of an issuer available to an
application that can only process public keys contained in certiﬁcates.
2.2
X.509 Certiﬁcates
The most important certiﬁcate standard is the X.509 standard, which is explained in
this section.
X.509 certiﬁcates are speciﬁed in the X.509 recommendation [17] of the
telecommunication standardization sector of the International Telecommunication
Union (ITU-T). The proﬁle of X.509 certiﬁcates that are used on the Internet is
speciﬁed in [3].
In the ITU-T X.509 recommendation two types of certiﬁcates are deﬁned. The
ﬁrst is that of a public key certiﬁcate that binds a public key to a subject as explained
in Sect. 2.1. The second type is that of an attribute certiﬁcate that binds attributes
to a subject. For example, an attribute certiﬁcate may bind the role of a system
administrator to a subject. The subject may use this certiﬁcate to obtain certain
privileges. Attribute certiﬁcates are discussed in Sect. 2.4.
In the literature, the notion of an X.509 certiﬁcate typically refers to a public
key certiﬁcate as it is more important. In this book, we also adopt this convention.
If nothing else is said, X.509 certiﬁcate always means X.509 public key certiﬁcate.
2.2.1
Structure
X.509 certiﬁcates are speciﬁed using the abstract syntax notation version 1 (ASN.1)
as a speciﬁcation language. This language is widely used for the description of
data structures. ASN.1 is standardized by the ITU-T in [15]. An ASN.1 tutorial
can be found in [5]. With ASN.1 it is possible to describe complex data structures.
Listing 2.1 shows the high-level ASN.1 speciﬁcation of an X.509 certiﬁcate. A
structural representation can be found in Fig. 2.1.
ASN.1 permits various encoding rules. X.509 certiﬁcates are encoded according
to the distinguished encoding rules (DER) described in [16]. DER prescribe the
unique encoding of any ASN.1 structure and are based on the basic encoding rules
(BER).

2.2
X.509 Certiﬁcates
23
Certificate ::=
SEQUENCE
{
tbsCertificate
TBSCertificate,
signatureAlgorithm
AlgorithmIdentifier,
signatureValue
BIT STRING }
Listing 2.1 ASN.1 speciﬁcation of an X.509 certiﬁcate
signature algorithm
signature value
tbsCertificate
version
serial number
signature
issuer
validity
public key
subject unique ID
issuer unique ID
extensions
not before
not after
algorithm
public key
identifier
criticality flag
value
subject
extension
extension
Fig. 2.1 The structure of an X.509v3 certiﬁcate
An X.509 certiﬁcate is an ASN.1 SEQUENCE. Such a sequence is an ordered
list of elements. An X.509 certiﬁcate has three elements. The ﬁrst element is
tbsCertificate which is of type TBSCertificate. It contains the contents
of the certiﬁcate as described in Sect. 2.1, for example, the public key and the name
of its owner. The second element is signatureAlgorithm which describes the
signature algorithm used by the third party to sign the certiﬁcate. This element
contains the corresponding OID and the necessary parameters. It is of type
AlgorithmIdentifier. The third element is signatureValue. It contains
the signature of the certiﬁcate. It is of type BIT STRING.
In the following section we describe the certiﬁcate elements in more detail. They
are also referred to as the ﬁelds of the certiﬁcate.

24
2
Certiﬁcates
TBSCertificate
::=
SEQUENCE
{
version
[0]
EXPLICIT Version DEFAULT v1,
serialNumber
CertificateSerialNumber,
signature
AlgorithmIdentifier,
issuer
Name,
validity
Validity,
subject
Name,
subjectPublicKeyInfo SubjectPublicKeyInfo,
issuerUniqueID
[1]
IMPLICIT UniqueIdentifier OPTIONAL,
subjectUniqueID [2]
IMPLICIT UniqueIdentifier OPTIONAL,
extensions
[3]
EXPLICIT Extensions OPTIONAL }
Listing 2.2 ASN.1 speciﬁcation of tbsCertiﬁcate
2.2.2
tbsCertiﬁcate
The structure of the tbsCertiﬁcate element can be seen in Fig. 2.1 and its ASN.1
speciﬁcation in Listing 2.2.
All ﬁelds in this element except the issuerUniqueID, subjectUniqueID,
and the extensions are mandatory, which means that they must be present in
order for the certiﬁcate to be valid. An exception is the version ﬁeld, which may be
omitted if the version is 1.
version The version ﬁeld speciﬁes which version of the X.509 speciﬁcation is
used in this certiﬁcate. Currently, there are three versions of X.509 certiﬁcates. The
ﬁrst version X.509v1 was speciﬁed in 1988, the second version X.509v2 in 1993,
and the third version X.509v3 in 1996. Today, most X.509 certiﬁcates use version 3.
The differences of these versions are as follows. In contrast to X.509v1 and X.509v2
certiﬁcates, X.509v3 certiﬁcates may have extensions. Extensions of certiﬁcates are
covered in Sect. 2.3. The difference between v1 and v2 X.509 certiﬁcates is that the
latter are allowed to contain the issuerUniqueID and subjectUniqueID ﬁelds, which
we discuss in a subsequent paragraph.
The value of the version ﬁeld is an integer. If the certiﬁcate is v1 then this ﬁeld
can be omitted or the value of version is 0. For X.509v2 certiﬁcates the value of
version is 1. For X.509v3 certiﬁcates this value is 2.
serialNumber The certiﬁcate issuer assigns a serialNumber to the certiﬁcate
that is a non-negative integer encoded as a 20 bytes ASN1Integer. The serial
number ﬁeld is mandatory. The issuer must not assign the same serial number
to more than one certiﬁcate. Therefore, the combination of the issuer name and
the serial number uniquely identiﬁes a certiﬁcate. This fact is used in many PKI
protocols and applications. To meet this requirement, many issuers assign a starting
number to their ﬁrst certiﬁcate. Then the serial number is incremented by one each
time a new certiﬁcate is issued. But other methods to assign serial numbers to
certiﬁcates also exist.

2.2
X.509 Certiﬁcates
25
Table 2.1 Typical attribute
types
Attribute type
String representation
OID
countryName
C
2.5.4.6
organizationName
O
2.5.4.10
organizationalUnitName
OU
2.5.4.11
commonName
CN
2.5.4.3
localityName
L
2.5.4.7
stateOrProvinceName
ST
2.5.4.8
signature The issuer of an X.509 certiﬁcate signs the certiﬁcate. The mandatory
ﬁeld signature describes the signature algorithm that was used by the issuer to sign
the certiﬁcate. The ﬁeld is of type AlgorithmIdentiﬁer. It contains the OID of the
signature algorithm. OIDs for common signature schemes are listed in Table 1.5.
The signature ﬁeld may also contain algorithm parameters that were used in the
signature. This entry is optional. In most cases those parameters are not provided
using this ﬁeld, but are provided with the public key that is to be used to verify the
certiﬁcate’s signature. Providing parameter information may even be prohibited. For
example, when ECDSA with SHA1 is used, the algorithm parameters must not be
included (Sect. 2.2.3 of [14]).
Note that the signature algorithm speciﬁed in the signature ﬁeld is also speciﬁed
in the element signatureAlgorithm.
issuer The mandatory issuer ﬁeld speciﬁes the entity that issued the certiﬁcate
and guarantees the correctness of its contents. The issuer is represented by an
ASN.1 string called distinguished name (DN). Distinguished names are also used
in other contexts. The structure of a DN is speciﬁed in [18]. An example of
a DN is CN=Alice, OU=Administration, O=TU Darmstadt, C=DE.
This DN describes a person with common name (CN) Alice, who belongs to the
organizational unit (OU) “administration” of the organization (O) “TU Darmstadt”
that operates in the country (C) Germany (DE as speciﬁed in ISO 3166 [9]).
In our example, the DN reﬂects a logical hierarchy of a person belonging to an
organizational unit which is part of an organization located in a country. In general,
a DN is a sequence of attributes and their values. An attribute and its value are
separated by a “=” sign stating that an attribute has a speciﬁc value. The attribute-
value pairs are separated by commas. Table 2.1 shows typical attributes of a DN.
Although DNs do not have to reﬂect a hierarchy, this has proved to be very
useful.
Currently, the encoding of an X.509 DN must be UTF8 or PrintableString.
Other encoding such as TeletexString or BMPString may be used by older
certiﬁcates. Therefore, client applications that use X.509 certiﬁcates should support
all those encodings.
validity The validity ﬁeld indicates the validity period of a certiﬁcate. This ﬁeld
contains the two dates notBefore and notAfter. The notBefore date is a point
in time before which the certiﬁcate is not yet valid. The notAfter date is a point in
time after which the certiﬁcate is not valid anymore. Between these two dates the

26
2
Certiﬁcates
ECParameters ::= SEQUENCE {
version
ECPVer,
fieldID
FieldID,
curve
Curve,
base
ECPoint,
order
INTEGER,
cofactor
INTEGER OPTIONAL }
Listing 2.3 Parameters of an elliptic curve that may be included
certiﬁcate is valid unless it has been revoked. Revocation of certiﬁcates is discussed
in Chap. 5. Until the year 2049 UTCTime encoding must be used for representing
the two dates. From 2050, the GeneralizedTime encoding is to be used.
subject The subject ﬁeld describes the owner of the certiﬁcate, that is, the entity
that owns the private key corresponding to the public key contained in the certiﬁcate.
This owner may also be described in the subject alternative name extension (see
Sect. 2.3). If the owner is described only in the subject alternative name extension,
then the subject ﬁeld contains an empty sequence. Like issuers, subjects are
described by distinguished names. If the subject of a certiﬁcate is the issuer of
another certiﬁcate, then it is essential that the subject DN match the issuer DN of all
certiﬁcates issued by this entity and that the subject DN not be empty. Examples of
attributes that can be used to represent subject DNs are found in Table 2.1.
subjectPublicKeyInfo The subjectPublicKeyInfo ﬁeld contains the public
key that is certiﬁed by the certiﬁcate. The public key is described as a sequence
containing the OID of an algorithm followed by optional parameters and the public
key. An example of parameters for a public key used in elliptic curve cryptography
can be found in Listing 2.3 (see also [14]). The public key is represented using the
ASN.1 format. This format is given by its DER-encoding, which is a binary string.
issuerUniqueID and subjectUniqueID Although this is not recommended, it may
happen that a distinguished name is assigned to different entities. For example, if a
subject DN is used twice by an issuer, then the owner of the corresponding certiﬁcate
is not uniquely determined by the subject DN. To make the owner description
unique, the subjectUniqueID ﬁeld may be added. The content of that ﬁeld is a binary
string that is a unique identiﬁer for the owner of the certiﬁcate.
Likewise, several issuers may share the same DN. In this case the issuerUniqueID
ﬁeld resolves the situation. The subjectUniqueID and issuerUniqueID ﬁelds were
introduced in the second version of X.509. Therefore, only X.509v2 and X.509v3
certiﬁcates may contain these ﬁelds. The use of non-unique distinguished names
and of the subjectUniqueID and issuerUniqueID ﬁelds is not recommended because
they make certiﬁcate use more complicated.
extensions The ﬁeld extensions is discussed in Sect. 2.3.

2.3
X.509 Certiﬁcate Extensions
27
Extension
::=
SEQUENCE
{
extnID
OBJECT IDENTIFIER,
critical
BOOLEAN DEFAULT FALSE,
extnValue
OCTET STRING }
Listing 2.4 Extension
2.2.3
signatureAlgorithm
As explained in the previous section, the signature algorithm that was used to sign
the certiﬁcate is speciﬁed twice in an X.509 certiﬁcate, once in the tbsCertiﬁcate
ﬁeld and once in the signatureAlgorithm ﬁeld. The reason for this remains unclear.
2.2.4
signatureValue
This ﬁeld holds the signature on the tbsCertiﬁcate content of the certiﬁcate. It is
represented as a bit string.
2.3
X.509 Certiﬁcate Extensions
When used in practice, the contents of X.509v1 and v2 certiﬁcates turned out
to be insufﬁcient. Therefore, X.509v3 certiﬁcates may contain extensions which
support various PKI processes such as locating the issuer of a certiﬁcate. The ASN.1
structure of X.509 certiﬁcate extensions can be seen in Listing 2.4.
The ﬁrst ﬁeld in such an extension is extnID, which contains the OID of the
extension. Next, any extension contains a criticality indicator critical. If its value is
true then all applications that use this certiﬁcate must evaluate the extension. If an
application is unable to do so, then it must consider the certiﬁcate to be invalid. The
third ﬁeld contains the DER-encoded ASN.1 structure of the extension description.
In the following we explain the 17 extensions that are deﬁned in RFC 5280 [3].
In addition, any application may deﬁne and use its own extensions.
AuthorityKeyIdentiﬁer The purpose of the AuthorityKeyIdentifier
extension, also known as AKI extension or AKIE, is to support applications in
identifying the public key of the issuer, which must be used to verify the certiﬁcate
signature. The information in the issuer ﬁeld may not be sufﬁcient to identify
this public key since an issuer may have several public keys. The authority key
identiﬁer extension must be present in any X.509v3 certiﬁcate unless the certiﬁcate
is self-signed. Also, this extension must not be marked critical. For example, this
extension is used by Microsoft [2]. The ASN.1 speciﬁcation of the extension can

28
2
Certiﬁcates
AuthorityKeyIdentifier ::= SEQUENCE {
keyIdentifier
[0] KeyIdentifier
OPTIONAL,
authorityCertIssuer
[1] GeneralNames
OPTIONAL,
authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL
}
KeyIdentifier ::= OCTET STRING
Listing 2.5 AKI extension
be seen in Listing 2.5. It supports two methods for identifying the issuer’s public
key. The ﬁrst method assumes that an application has access to several public keys
of the certiﬁcate issuer and must choose between them. This choice can be made
by comparing the SHA-1 hash value stored in the keyIdentifier ﬁeld with the
SHA-1 hash values of the known public keys. Note that a successful comparison
is not a proof of authenticity of the issuer public key. This authenticity must be
established differently since it is the basis of the validation of the certiﬁcate. To save
space, the contents of the keyIdentiﬁer may be restricted to the 60 least signiﬁcant
bits of the hash value appended with 0100.
We describe the second method used by the authority key identiﬁer extension
to specify the veriﬁcation key for the certiﬁcate signature. It describes this public
key by presenting the distinguished name authorityCertIssuer of the issuer
and the serial number authorityCertSerialNumber of a certiﬁcate that
authenticates the public key. The authorityCertIssuer must coincide with the issuer
of the certiﬁcate. Serial number and distinguished name uniquely determine such a
certiﬁcate. From this certiﬁcate, an application can extract the relevant public key.
All ﬁelds in this extension are optional. For example, only the distinguished name
of the issuer may be present. However, this is not recommended since it may not
identify the public key uniquely. This second speciﬁcation method has a serious
disadvantage. Suppose that an application attempts to verify a certiﬁcate using an
authority key identiﬁer extension that does not contain the hash value of a public
key but points to an issuer public key certiﬁcate. Assume that the issuer public key
certiﬁcate has expired. Then the certiﬁcate veriﬁcation fails. However, the issuer
public key may still be valid. For example, there may be a new certiﬁcate for that
key. But due to the identiﬁcation method, the veriﬁcation process cannot ﬁnd this
new certiﬁcate. This disadvantage does not occur if a hash value is used to specify
the issuer public key since hash values do not contain validity information.
Subject Key Identiﬁer The SubjectKeyIdentifier extension of a certiﬁ-
cate contains the hash value of the public key which is certiﬁed by the certiﬁcate. It
is used by applications that compare the public key in the certiﬁcate to other public
keys. The extension is very useful if the owner of the certiﬁcate has several public
keys. As in the AuthorityKeyIdentiﬁer extension, this hash value is either the full
SHA-1 hash or the leading part of it. This extension must not be marked critical and

2.3
X.509 Certiﬁcate Extensions
29
KeyUsage ::= BIT STRING {
digitalSignature
(0),
nonRepudiation
(1),
keyEncipherment
(2),
dataEncipherment
(3),
keyAgreement
(4),
keyCertSign
(5),
cRLSign
(6),
encipherOnly
(7),
decipherOnly
(8) }
Listing 2.6 Key usage extension
must appear in certiﬁcates whose public keys can be used to verify signatures on
other certiﬁcates.
Key Usage The KeyUsage extension indicates what the public key contained
in the certiﬁcate can be used for. Listing 2.6 shows the ASN.1 structure of this
extension. The possible uses are the following.
digitalSignature
The public key can be used to verify digital signatures, for
example, in entity authentication protocols or for signing emails.
nonRepudiation
The public key can be used to verify signatures that provide non-
repudiation, as explained in Sect. 1.3.7.
keyEncipherment
The public key may be used to encrypt symmetric session
keys as explained in Sect. 1.3.5. It may also be used to encrypt private keys of
asymmetric systems, for example in key delivery protocols.
dataEncipherment
The public key may be used to encrypt data.
keyAgreement
The public key may be used in a key agreement scheme.
keyCertSign
The private key corresponding to the public key in the certiﬁcate
may be used to sign certiﬁcates. The public key is then used to verify certiﬁcate
signatures.
cRLSign
The private key corresponding to the public key in the certiﬁcate may
be used to sign certiﬁcate revocation lists. Such lists are discussed in Sect. 5.2.
encipherOnly
This ﬁeld is used when the keyAgreement usage option is selected.
decipherOnly
This ﬁeld is used when the keyAgreement usage option is selected.
Many clients and applications evaluate the key usage extension. A typical
example is that of an email client which has access to several certiﬁcates of the
same entity. The email client can tell by the key usage extension which certiﬁcate to
use for encrypting emails or for verifying email signatures. Likewise, for certiﬁcate
issuers the keyCertSign usage must be selected if the key usage extension is
present.
The key usage extension must be consistent with the corresponding crypto-
graphic algorithm and must not contain contradictions. For example, for a DSA key

30
2
Certiﬁcates
the key usage dataEnciphermentis inappropriate since DSA is a signature algorithm.
Also, encipherOnly and decipherOnly cannot be set at the same time.
Subject Alternative Name As explained in Sect. 2.2.2, the subject ﬁeld contains
the distinguished name of the public key owner. The SubjectAlternativeName
extension binds additional names to the public key in the certiﬁcate. Typical names
contained in this extension are email or IP addresses, domain names (DNS names)
or uniform resource identiﬁers (URIs). For example, when a certiﬁcate is used
for encrypting emails, the email address of the recipient may be contained in this
extension. Also, if the public key in the certiﬁcate is used for entity authentication
of the Web server of an organization, the DNS name or the IP address of that server
is typically contained in this extension. Most clients that connect securely to such
a server verify that the IP address or the DNS name of the server matches the IP
address or DNS name contained in this extension.
Name Constraints This extension is used by the issuer of a certiﬁcate to provide
limitations on the values of the subject ﬁeld or subject alternative name extension in
certiﬁcates issued using the key of this certiﬁcate. It may permit or exclude names.
For example, a bank that issues certiﬁcates may be required by this extension to
include the bank name in the certiﬁcates.
Issuer
Alternative
Name The
structure
and
meaning
of
the
Issuer
AlternativeName extension is analogous to the subject alternative name
extension. Note that this extension is not used in the certiﬁcate veriﬁcation algorithm
presented in Sect. 9.4.1.
Subject Directory Attributes This extension may contain attributes associated to
the subject in the certiﬁcate. Examples are its initials or its nationality.
Extended Key Usage This extension associates the public key in the certiﬁcate
with additional uses and functions that augment or replace the standard key usages
speciﬁed in the key usage extension. Examples are server or client authentication,
code signing, email security, time-stamping, and signing answers to certiﬁcate status
queries.
Further Extensions Further extensions that will be discussed later are: the
CertificatePolicies and PolicyMappings extensions in Sects. 8.2.1
and 8.2.2, respectively, the BasicConstraints extension in Sect. 3.3.1, the
PolicyConstraintsextension in Sect. 8.2.3, the CRLDistributionPoints
extension in Sect. 5.3.1, the Inhibit anyPolicy extension in Sect. 8.2.4, and
the extension FreshestCRL in Sect. 5.2.2.
The extensions discussed so far can be found in the X.509 speciﬁcation [17] and
are standard extensions of a certiﬁcate. Other extensions that may be deﬁned for
certain contexts or applications are called private extensions. In [3], where PKIs
for the Internet are speciﬁed, two private extensions are described. These are the
AuthorityInformationAccessand the SubjectInformationAccess
extensions. They are discussed in Sects. 9.6.1 and 9.6.2, respectively.

2.5
CV Certiﬁcates
31
2.4
Attribute Certiﬁcates
An attribute certiﬁcate is a digital document which is used by so-called attribute
authorities (AA) to assign privileges to entities. For example, such certiﬁcates are
used by mobile phone operating systems to verify that certain services have the right
to be executed in the controlled environment of mobile phones. For example, if a
third party wishes to access the address book of a mobile phone in order to include
more information, an attribute certiﬁcate proves that this operation is permitted. In
contrast to standard X.509 certiﬁcates, attribute certiﬁcates do not contain public
keys. Instead, they bind an authorization to the owner of the certiﬁcate. Like
standard X.509 certiﬁcates, attribute certiﬁcates are also signed by a trusted third
party. Although such certiﬁcates are also speciﬁed in the X.509 standard, they are
typically not called X.509 certiﬁcates. X.509 certiﬁcates are assumed to certify
public keys.
Attribute certiﬁcates are used in conjunction with X.509 certiﬁcates. For exam-
ple, consider a ﬁrmware update for a mobile phone. It is signed by its issuer and the
signature veriﬁcation key is authenticated by a certiﬁcate. In addition, an attribute
certiﬁcate may specify whether or not this update may be used for a certain type of
mobile phone.
There are several reasons for separating public key certiﬁcates from attribute
certiﬁcates. The authorization may have a much shorter lifetime than the public key
in the X.509 certiﬁcate. For example, ﬁrmware updates may be changed frequently.
The authorization to install the update expires when a new update is published.
However, the public key of the update publisher may be valid much longer. Also,
attribute certiﬁcates may replace complicated access lists. In the case of ﬁrmware
updates, the mobile device can just evaluate the attribute certiﬁcate instead of
checking by itself whether the update is appropriate.
The proﬁle of X.509 attribute certiﬁcates is speciﬁed in [17] and [8]. The
structure of an attribute certiﬁcate resembles that of an X.509 certiﬁcate. It is a
sequence: some content that is signed, the signing algorithm, and the signature.
It has basic ﬁelds: the owner, the issuer, the serial number, the validity period,
and the privileges (authorization information) of the owner. It may also contain
extensions. The ASN.1 speciﬁcation of an X.509 attribute certiﬁcate can be seen in
Listing 2.7. An infrastructure that is based on attribute certiﬁcates is called privilege
management infrastructure (PMI).
2.5
CV Certiﬁcates
Card veriﬁable (CV) certiﬁcates [4,10] are very compact public key certiﬁcates. CV
certiﬁcates avoid the overhead which comes with ﬂexible general-purposecertiﬁcate
formats such as X.509. Their purpose is to be veriﬁable by resource-restricted
devices such as smart cards, in particular to enable the authentication of an entity

32
2
Certiﬁcates
AttributeCertificate ::= SEQUENCE {
acinfo
AttributeCertificateInfo,
signatureAlgorithm
AlgorithmIdentifier,
signatureValue
BIT STRING }
AttributeCertificateInfo ::= SEQUENCE {
version
AttCertVersion -- version is v2,
holder
Holder,
issuer
AttCertIssuer,
signature
AlgorithmIdentifier,
serialNumber
CertificateSerialNumber,
attrCertValidityPeriod
AttCertValidityPeriod,
attributes
SEQUENCE OF Attribute,
issuerUniqueID
UniqueIdentifier OPTIONAL,
extensions
Extensions OPTIONAL }
Listing 2.7 Attribute certiﬁcate
cvcBody ::=
SEQUENCE {
profileId
UNSIGNED INTEGER,
issuer
CHARACTER STRING,
pubKey
SEQUENCE,
subject
CHARACTER STRING,
chat
SEQUENCE,
notBefore
DATE,
notAfter
DATE }
Listing 2.8 ASN.1 speciﬁcation of a CV certiﬁcate
to the device. After a successful authentication, the entity may use certain access-
protected functions of the device. CV certiﬁcates only contain the most important
ﬁelds, which are:
Certiﬁcate authority
A reference to the certiﬁcate issuer.
Certiﬁcate holder public key
The certiﬁed public key.
Certiﬁcate holder
A reference to the certiﬁcate subject.
Certiﬁcate holder authorization
The subject’s access rights to the device.
Certiﬁcate effective date
Start of the validity of the certiﬁcate.
Certiﬁcate expiration date
End of the validity of the certiﬁcate.
The corresponding ASN.1 structure of this self-descriptive variant can be found
in Listing 2.8.
To make CV certiﬁcates even more compact, the not self-descriptive variant of
CV certiﬁcates can be used. It integrates parts of the certiﬁcate into the signature by
using signatures with message recovery as speciﬁed in [11]. In this variant the CV
certiﬁcate only consists of a sequence of strings. The corresponding format must be
made known to the evaluating device beforehand.

2.7
Other Certiﬁcates
33
2.6
PGP Certiﬁcates
Pretty good privacy (PGP), which was invented 1991 by Phil Zimmermann,
establishes trust in the ownership of public keys using a social network. Trust
in the ownership of a public key is established by trustworthy participants of the
network certifying this ownership. This is what PGP certiﬁcates are used for. PGP
is discussed in detail in Sect. 3.2.
PGP certiﬁcates are speciﬁed in the OpenPGP speciﬁcation [1]. They contain at
least one public key, which is described in a so-called public key packet. A public
key packet includes:
•
The PGP version number that indicates which version of PGP was used to create
the key associated with the certiﬁcate.
•
The creation time of the key.
•
The public key together with the algorithm in which the key is to be used.
A PGP certiﬁcate includes:
•
A public key packet.
•
Optionally: Signatures to invalidate this certiﬁcate.
•
Identity information about the certiﬁcate holder, for example, name and email
address.
•
A digital signature of the public key packet and the identity information. This
signature is issued using the private key that corresponds to the public key in the
certiﬁcate.
•
Optionally: signatures of the public key packet and the identity information
of other PGP users. These signatures certify the authenticity of the public key
contained in the certiﬁcate. They are required to establish trust in the PGP web
of trust as explained in Sect. 3.2.
•
Optionally: other identity information. This information may also be signed.
•
Optionally: attributes of the user. They may also be signed.
•
Optionally: other public keys of the user. They may also be signed.
The current version of PGP certiﬁcates is version 4. PGP version 3 certiﬁcates
that may only contain one public key must not be generated anymore. However,
applications should be able to process them. The structure of PGP version 4
certiﬁcates is displayed in Fig. 2.2.
2.7
Other Certiﬁcates
There are several other certiﬁcate types that are used in certain contexts or
applications. We brieﬂy discuss these certiﬁcates.

34
2
Certiﬁcates
Primary
Key
Revocation Self
Signature
Direct Key
Signature
User ID
Signature
Signature
Subkey
Binding
Signature
Revocation
Primary Key
Binding
Signature
User ID
Signature
Signature
User
Attribute
Signature
Signature
Direct Key
Signature
Fig. 2.2 A PGP V4
certiﬁcate; the shaded
components are mandatory
2.7.1
WAP Certiﬁcates
The wireless application protocol (WAP) is a speciﬁcation for developing applica-
tions in wireless communication networks. Such applications have to satisfy special
requirements that account for the properties of devices used in such networks,
such as limited storage capabilities. The corresponding WAP certiﬁcates (see [20])
are modiﬁed X.509 certiﬁcates with reduced storage requirements. For example,
in WAP certiﬁcates serial numbers of user certiﬁcates must not be longer than
8 bytes. To provide extra information that does not ﬁt into the WAP certiﬁcate, such
certiﬁcates may have a domainInformation extension which contains a pointer
to extensions that are not contained in the certiﬁcate but are associated to it.
2.7.2
SPKI Certiﬁcates
An alternative to the X.509 standard is simple public key infrastructure (SPKI) [6,7].
It was speciﬁed by the corresponding working group at the IETF, which no longer
exists. SPKI uses the so-called SPKI certiﬁcates. Their main purpose is to support
authorization.
There are two types of SPKI certiﬁcates, the authorization certiﬁcate and the
name certiﬁcate. SPKI authorization certiﬁcates have issuer and subject ﬁelds. The
issuer is represented by a public key or its hash value. The subject may contain the
hash of an object (for example, a software package), a name, a public key (or its hash
value), information about the key holder intended for human readability, and data

2.8
Exercises
35
that support multi-party computation. Such certiﬁcates also have ﬁelds that specify
their version and their validity period and that provide human readable content and
additional information about the issuer (other certiﬁcates that authorize this issuer
to issue certiﬁcates) and the subject (for example, its public key). Authorization
certiﬁcates also support delegation.
Name certiﬁcates resemble authorization certiﬁcates but do not contain autho-
rization or delegation statements or additional information about the issuer or the
subject. They just bind names to public keys. Since issuers can use names of any
form, such certiﬁcates are easier to use for humans. One possible encoding of SPKI
certiﬁcates is XML [12].
For further reading on SPKI we refer the reader to [6,7], and [19].
2.7.3
Traceable Anonymous Certiﬁcate
When X.509 certiﬁcates are used by applications, the user’s identity can be easily
obtained from the certiﬁcate. In certain applications users may want to remain
anonymous. On the other hand, under certain conditions an application may have
the right to learn the user’s real identity. This is supported by traceable anonymous
certiﬁcates as deﬁned in [13]. Such certiﬁcates use the X.509 format. However,
the collaboration of two issuers guarantees the desired anonymity properties. Those
issuers are the blind issuer and the anonymity issuer. The user and the two
authorities interact in a protocol in which the user creates her or his key pair, the
blind issuer veriﬁes the real identity of the user, and the anonymity issuer issues the
certiﬁcate in which the subject is a pseudonym. The blind issuer and the anonymity
issuer can only link the user to the certiﬁcate if they collaborate.
2.8
Exercises
2.1. How many versions of X.509 certiﬁcates exist? What are the differences
between them?
2.2. In the three certiﬁcates shown in Fig. 2.3 the values of the keyIdentiﬁer (keyId),
authorityCertIssuer (aci), and authorityCertSerialNumber(acsn) of the authority key
identiﬁer extension are missing. Enter appropriate values.
2.3. Answer the following questions.
1. The authority key identiﬁer extension and subject key identiﬁer extension both
have a ﬁeld called keyIdentiﬁer. Can these ﬁelds have the same content in the
same certiﬁcate?
2. Can two different certiﬁcates have the same keyIdentiﬁer in the authority key
identiﬁer extension?

36
2
Certiﬁcates
Certiﬁcate 1
Serial No.: 26540
Issuer:
CN=Test CA
NotBefore: 2004-04-03
NotAfter:
2005-04-03
Subject:
CN=Alice
Public Key: key-0x4D367AB9
X509v3Extensions:
KeyUsage: critical
digitalSignature, dataEncipherment
Subject Key Identiﬁer:
keyId: 12:AB:45:76:F8:98
Authority Key Identiﬁer:
keyId:
aci:
acsn:
Certiﬁcate 3
Serial No.: 34
Issuer:
CN=Master CA
NotBefore: 2003-11-15
NotAfter:
2008-11-10
Subject:
CN=Test CA
Public Key: key-0x347893B2
X509v3Extensions:
KeyUsage: critical
keyCertSign, cRLSign
Subject Key Identiﬁer:
keyId: BE:76:34:4E:60:34
Authority Key Identiﬁer:
keyId:
aci:
acsn:
Certiﬁcate 2
Serial No.: 1
Issuer:
CN=Master CA
NotBefore: 2003-11-14
NotAfter:
2008-11-14
Subject:
CN=Master CA
Public Key: key-0x18FF6542
X509v3Extensions:
KeyUsage: critical
keyCertSign, cRLSign
Subject Key Identiﬁer:
keyId: 11:23:34:AB:65:F0
Authority Key Identiﬁer:
keyId:
aci:
acsn:
Fig. 2.3 Certiﬁcates with missing AKI values
Table 2.2 Key usage
extension values
(0)
(8)
1
1
0
1
0
0
0
0
0
3. Can two different certiﬁcates have the same keyIdentiﬁer in the subject key
identiﬁer extension?
2.4. In Table 2.2, values of the key usage extension are given. For what purposes
can the key in the corresponding certiﬁcate be used? For which algorithm is this
possible?
2.5. The certiﬁcates in Fig. 2.4 have the same serial number. Is this permitted?

References
37
Certiﬁcate 1
Serial No.: 2
Issuer:
E
NotBefore: 2003-02-01
NotAfter:
2005-12-31
Subject:
I
Public Key: key-0x384756AB
Certiﬁcate 2
Serial No.: 2
Issuer:
B
NotBefore: 2003-02-01
NotAfter:
2005-12-31
Subject:
F
Public Key: key-0x4569DEFA
Certiﬁcate 3
Serial No.: 2
Issuer:
G
NotBefore: 2003-02-01
NotAfter:
2005-12-31
Subject:
L
Public Key: key-0x8269AEB8
Fig. 2.4 Certiﬁcates with same serial numbers
References
1. J. Callas, L. Donnerhacke, H. Finney, D. Shaw, R. Thayer, OpenPGP message format, in IETF
Request for Comments, 4880, Nov 2007
2. Certiﬁcate Status and Revocation Checking, http://social.technet.microsoft.com/wiki/contents/
articles/certiﬁcate-status-and-revocation-checking.aspx
3. D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 5280, May 2008
4. Comité Européen de Normalisation (CEN), Application interface for smart cards used as secure
signature creation devices—part 1: basic requirements. CEN Workshop Agreement (2004),
ftp://ftp.cenorm.be/PUBLIC/CWAs/e-Europe/eSign/cwa14890-01-2004-Mar.pdf
5. O. Dubuisson, ASN.1—Communication Between Heterogeneous Systems (Morgan Kaufmann,
San Diego, 2000)
6. C. Ellison, SPKI requirements, in IETF Request for Comments, 2692, Sept 1999
7. C. Ellison, B. Frantz, B. Lampson, R. Rivest, B. Thomas, T. Ylonen, SPKI certiﬁcate theory,
in IETF Request for Comments, 2693, Sept 1999
8. S. Farrell, R. Housley, An internet attribute certiﬁcate proﬁle for authorization, in IETF Request
for Comments, 3281, Apr 2002
9. International Organization for Standardization (ISO), English country names and code ele-
ments, http://www.iso.org/iso/english_country_names_and_code_elements
10. International Organization for Standardization ISO, ISO/IEC 7816-8: identiﬁcation cards –
integrated circuit(s) cards with contacts – part 8: security related interindustry commands.
International Standard, Oct 1999
11. International Organization for Standardization ISO, ISO/IEC 9796: information technology –
security techniques – digital signature schemes giving message recovery – parts 1–3. Interna-
tional Standard, 1999–2002
12. J. Paajarvi, XML encoding of SPKI certiﬁcates (2000), http://xml.coverpages.org/draft-
paajarvi-xml-spki-cert-00.txt
13. S. Park, H. Park, Y. Won, J. Lee, S. Kent, Traceable anonymous certiﬁcate, in IETF Request
for Comments, 5636, Aug 2009
14. W. Polk, R. Housley, L. Bassham, Algorithms and identiﬁers for the internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 3279, Apr 2002

38
2
Certiﬁcates
15. Recommendation X.680 ITU-T, Information technology – abstract syntax notation one
(ASN.1): speciﬁcation of basic notation, July 2002
16. Recommendation X.690 ITU-T, Information technology – ASN.1 encoding rules: speciﬁcation
of basic encoding rules (BER), canonical encoding rules (CER) and distinguished encoding
rules (DER), July 2002
17. Recommendation X.509 ITU-T, Information technology – open systems interconnection – the
directory: public-key and attribute certiﬁcate frameworks, Aug 2005
18. Recommendation X.501 ITU-T, Information technology – open systems interconnection – the
directory: models, Nov 2008
19. SPKI/SDSI Certiﬁcate Documentation, http://world.std.com/~cme/html/spki.html
20. WAP Forum, WAP certiﬁcate and CRL proﬁles speciﬁcation, http://www.openmobilealliance.
org/tech/afﬁliates/wap/wap-211-wapcert-20010522-a.pdf

Chapter 3
Trust Models
Public key cryptography can only be used in practice if users trust the authenticity
of public keys. In this chapter we explain models and infrastructures that allow us
to establish trust in the authenticity of public keys.
3.1
Direct Trust
Direct trust is the most basic trust model. In fact, it is required by all other trust
models to initialize trust. We start by explaining this model in an example. Like other
operating systems, many Linux variants allow the installation of additional software
such as updates or services from servers located on the Internet. The authenticity
of those software packages is established by a digital signature. The veriﬁcation of
the signature requires a public key. Frequently, this key is provided on the original
Linux distribution CD or DVD, typically stored in PGP format. The authenticity of
this key is guaranteed by the authenticity of the CD or DVD and by the difﬁculty of
overwriting it. In such a situation, the trust in the public key is called direct since it
is directly obtained from its owner (the Linux distributor). No third party is involved
in authenticating the key.
More generally, we say that trust in the authenticity of a public key is direct if
the public key is directly obtained from the key owner or its owner directly conﬁrms
the authenticity of the key in a way that is convincing for the user.
We present an example of a public key which is obtained from another source
and which is authenticated by the owner. The email client Thunderbird comes
with many pre-installed certiﬁcates that are trusted by default. This is shown in
Fig. 3.1.
Those public keys are used to verify signatures on certiﬁcates which, in turn,
authenticate public keys of end users or intermediate entities (cf. Sect. 3.3). More
than 150 public keys are already contained in Thunderbird upon installation.
They are stored in self-signed certiﬁcates in the Thunderbird key repository. Their
authenticity can be veriﬁed as follows. Thunderbird computes a ﬁngerprint of the
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__3, © Springer-Verlag Berlin Heidelberg 2013
39

40
3
Trust Models
Fig. 3.1 Thunderbird’s certiﬁcate manager
self-signed certiﬁcate that contains the public key. Figure 3.2 shows the so-called
German national Root-CA certiﬁcate for legally binding electronic signatures as
presented by Thunderbird’s certiﬁcate viewer. The last section contains two different
ﬁngerprints. The ﬁrst one is computed using the SHA1 hash algorithm and the
second one is computed using the MD5 hash algorithm, which is no longer
considered to be secure. One of these ﬁngerprints is compared with the certiﬁcate
ﬁngerprint which can be obtained directly from the party that issued the certiﬁcate,
for example from a customer hotline or a Web page. The ﬁngerprint may also be
printed on a business card or published in a newspaper or an ofﬁcial government
publication. Figure 3.3 shows the Web page of CAcert [1], where the ﬁngerprints of
important CAcert certiﬁcates are published. CAcert is a community-driven service
providing free certiﬁcates.
This procedure establishes trust in public keys because an additional communi-
cation channel is used to check the correctness of the ﬁngerprint. Controlling two
communication channels is considered to be much harder for an adversary than one.
Many applications use pre-installed public keys. For example, operating systems,
email clients, and Web browsers. Most users trust those keys without checking
them. However, as explained above, any user can verify the ﬁngerprints of the
corresponding certiﬁcates. This is explicitly encouraged by certain applications. For
example, when a self-signed certiﬁcate is installed in a Windows operating system
a dialog window appears that notiﬁes the user about the certiﬁcate’s ﬁngerprint.

3.1
Direct Trust
41
Fig. 3.2 German national Root-CA certiﬁcate in Thunderbird
Figure 3.4 shows this dialog as presented by Windows 7. It recommends checking
the correctness of the ﬁngerprint by contacting the owner of the public key.
Another example of the use of direct trust is the secure shell (SSH) [8]
application. It is a popular program for connecting securely to remote servers. After
a successful authentication, users are able to access resources of the remote system.
Typically, user authentication is based on user name and password or on a public key
mechanism. Servers are always authenticated by a public key mechanism. When a
user attempts a login to the remote server for the ﬁrst time, this server displays

42
3
Trust Models
Fig. 3.3 Fingerprints of CAcert certiﬁcates
the ﬁngerprint of its public key. The respective dialog window is shown in Fig. 3.5.
The users may establish direct trust in this public key by verifying this ﬁngerprint
before continuing the login procedure. If the public key of the server has been
accepted once, it will always be used in the login procedure without any additional
veriﬁcation.
3.2
Web of Trust
Direct trust is insufﬁcient to make public key cryptography useful in practice. For
example, if a user wants to send an encrypted email to another user, establishing
direct trust requires the sender to contact the receiver prior to sending the email in
order to obtain the receiver’s public encryption key. Although this may be possible, it
slows down email communication considerably. Therefore, other trust models have
been introduced.
One of these alternative trust models is the web of trust. It was invented in
1992 by Phil Zimmermann in his system PGP [7]. The web of trust model is
inspired by social trust networks. In the web of trust, users trust a public key if
they have obtained it from its owner directly (direct trust) or if a sufﬁcient number
of trustworthy users recommend trusting the key.

3.2
Web of Trust
43
Fig. 3.4 Fingerprint dialog in Windows 7
$ ssh userver1.cdc.informatik.tu-darmstadt.de
The authenticity of host ’userver1.cdc.informatik.tu-darmstadt.de (130.83.167.15)’ can’t be
established.
RSA key ﬁngerprint is b2:e8:ac:0c:f7:bc:46:73:78:af:08:cf:54:b4:6e:17.
Are you sure you want to continue connecting (yes/no)?
Fig. 3.5 Fingerprint dialog in SSH
In the following sections we explain in detail how the web of trust is implemented
in PGP. The basic idea of PGP is that users who trust in a public key sign this public
key. Such signatures are called validity signatures. PGP participants trust in a public
key if it is signed by sufﬁciently many users whom they trust to sign keys of other
users. Our explanation follows RFC 4880 [2], which deﬁnes the OpenPGP standard
for the Internet. The corresponding open-source implementation is GNU privacy
guard (GPG).

44
3
Trust Models
Public Key
User ID
Signatures
Owner Trust
Key Legimacy
Fig. 3.6 A simple PGP
public key ring entry
3.2.1
Key Ring
Every PGP user owns a public key ring. It contains the public key of the key ring
owner and public keys of other users. A simple public key ring entry is shown in
Fig. 3.6. It contains the following information.
•
A public key.
•
The user ID of the owner of the public key.
•
One or more validity signatures of the public key and the user IDs of the signers.
At least the signature of the key owner must be present here. More signatures
may be added by other PGP users.
•
The owner trust, which indicates the trust of the key ring owner in the public key
owner to sign other people’s public keys.
•
The key legitimacy, which indicates the trust of the key ring owner in the
authenticity of the public key in this entry. It is also called key validity.
The implementation details of the public key ring are not speciﬁed. However,
there is a standardized way to export and import public keys using Transferable
Public Keys, which are simply concatenated and stored in a single ﬁle. Export
and import of private keys is done analogously using Transferable Secret Keys.
Transferable public and secret keys can even be combined in one ﬁle.
The contents of the ﬁrst two entries of a PGP key ring do not need further
explanation. So the next sections only discuss the last three ﬁelds of PGP key rings.
Signatures Upon generating their key pairs, users sign their own public keys. The
owner’s signature is always attached to the public key and is present in any key ring
that contains the public key. It is called self-signature. Other users may add their
own signatures to certify the authenticity of public keys. Before they do so they
are expected to establish direct trust in the signed public keys. For example, in the
PGP community, key signing parties are organized in which users sign each other’s
keys.
Owner Trust The owner trust of a public key indicates how much trust the key
ring owner has in the public key owner to sign public keys of other users. Therefore
it is assigned by the key ring owner to each public key in his or her key ring. It can
take the following ﬁve values.

3.2
Web of Trust
45
•
Ultimate owner trust is assigned to key ring owners’ own public keys since they
have unlimited trust in themselves.
•
The owner trust is set to complete if the key ring owner trusts fully the public key
owner to sign other public keys. This means that the key ring owner assumes that
the public key owner very carefully checks the identity of the owners of other
public keys before signing them.
•
The owner trust is set to marginal if the key ring owner only trusts marginally the
public key owner to sign other public keys. This means that the key ring owner
assumes that the public key owner checks the identity of the owners of other
public keys carelessly before signing them.
•
If the key ring owner does not trust the public key owner to sign other public
keys, the owner trust is set to none.
•
If the key ring owner has no information how the public key owner checks the
identity of the owners of other public keys before signing them, the owner trust
is set to unknown.
Key Legitimacy The key legitimacy of a public key determines the trust of
the owner of the public key ring in the authenticity of this public key, that is, in
the fact that this public key belongs to the entity described in the user ID ﬁeld of the
corresponding entry in the key ring. The key legitimacy can take three values.
•
The value complete indicates that the key ring owner is convinced that the public
key belongs to the user described in the user ID ﬁeld of the public key.
•
The key legitimacy is marginal if the key ring owner is only marginally convinced
that the public key belongs to the user described in the user ID ﬁeld of the public
key.
•
The key legitimacy is set to none if the key ring owner does not know whether
the public key belongs to the user described in the user ID ﬁeld.
While owner trust is chosen by the key ring owners, key legitimacy is calculated
when a public key is imported into the key ring. This calculation works as follows.
Suppose that a key K is imported into the key ring of user Alice. This key comes
with a number of signatures, one by the owner of key K and potentially several
additional signatures by other people. We explain how the key legitimacy of K is
determined.
The key legitimacy of K is set to complete if the key K is signed by Alice. In this
case, Alice has veriﬁed the authenticity of K herself. She trusts this key directly.
The key legitimacy of K is also set to complete if there is at least one signature
of K such that the corresponding veriﬁcation key K0 satisﬁes the following three
conditions.
•
K0 is in Alice’s public key ring.
•
The key legitimacy of K0 in Alice’s key ring is complete.
•
The owner trust of the owner of K0 in Alice’s key ring is complete.
This rule reﬂects the situation in which a public key is signed by a person who is
completely trusted by Alice to sign other people’s public keys.

46
3
Trust Models
Public key ring of Alice
1 Public key Owner
: Alice
Owner Trust / Key Legitimacy : ultimate / complete
1 Signer / Trust in Signer
: Alice / ultimate
2 Public key Owner
: Bob
Owner Trust / Key Legitimacy : complete / complete
1 Signer / Trust in Signer
: Bob / complete
2 Signer / Trust in Signer
: Alice / ultimate
3 Public key Owner
: Carl
Owner Trust / Key Legitimacy : marginal / complete
1 Signer / Trust in Signer
: Carl / marginal
2 Signer / Trust in Signer
: Bob / complete
4 Public key Owner
: Diana
Owner Trust / Key Legitimacy : marginal / marginal
1 Signer / Trust in Signer
: Diana / marginal
2 Signer / Trust in Signer
: Carl / marginal
3 Signer / Trust in Signer
: Oscar / –
5 Public key Owner
: Paul
Owner Trust / Key Legitimacy : none / none
1 Signer / Trust in Signer
: Diana / marginal
2 Signer / Trust in Signer
: Oscar / –
Fig. 3.7 Alice’s public key
ring
A third way for the key legitimacy of K to be set to complete is when there are at
least two signatures of K such that the corresponding veriﬁcation keys K1 and K2
satisfy the following three conditions:
•
K1 and K2 are in Alice’s key ring.
•
The key legitimacy of K1 and K2 is complete.
•
The owner trust of the owners of K1 and K2 is marginal.
The idea of this rule is that two signatures of users who are marginally trusted to
sign other people’s public keys is just as good as the signature of one user who is
completely trusted. There are variants of this rule where more than two marginally
trusted signatures are required. However, the rule presented here is mostly used.
The key legitimacy of K is set to marginal if none of the above rules holds and
there is at least one signature of K such that the corresponding veriﬁcation key K0
satisﬁes the following three conditions.
•
K0 is in Alice’s public key ring.
•
The key legitimacy of K0 in this key ring is complete.
•
The owner trust of the owner of K0 in the key ring is marginal.
In all other situations, the key legitimacy of K is set to none.
Example 3.1. Consider the public key ring of Alice as shown in Fig. 3.7. This key
ring contains the keys of Alice, Bob, Carl, Diana, and Paul. Alice assigns owner
trusts complete to Bob, marginal to Carl, marginal to Diana, and none to Paul. Alice
has signed Bob’s public key. Since the owner trust of Alice in herself is ultimate, the
key legitimacy of Bob’s key is set to complete. Bob has signed Carl’s key. Alice’s
owner trust in Bob is complete. Therefore, the key legitimacy of Carl’s public key

3.2
Web of Trust
47
is set to complete. Next, Diana’s public key is signed by Carl and Oscar. Oscar’s
public key is not in Alice’s public key ring. Carl’s public key is in Alice’s public key
ring, its key legitimacy is complete and its owner trust is marginal. Hence, the key
legitimacy of Diana’s public key is set to marginal. Paul’s public key is signed by
Diana and Oscar. Both keys do not contribute to the key legitimacy of Paul’s public
key, since Oscar’s public key is not in Alice’s public key ring and the key legitimacy
of Diana’s key is marginal. Therefore, the key legitimacy of Paul’s public key is set
to none.
In order for secure communication to become possible with PGP, public keys,
including their signatures, must be available to all users. In PGP this is achieved
by users mutually exchanging their public keys or by publishing public keys on key
servers. A key server is a publicly available directory service that allows everyone to
upload and download public keys, including their signatures. Examples of publicly
available PGP key servers are pgpkeys.pca.dfn.de, pool.skskeyservers.net, subkeys.
pgp.net, and pgp.mit.edu.
3.2.2
Trust Signatures
We have seen that the web of trust lets users choose the trust in public key owners
to sign public keys of others. This trust may also be computed using so-called trust
signatures. A trust signature of a public key not only asserts that the key belongs to
its claimed owner, but it also asserts that this owner is trustworthy to sign other keys.
More precisely, a trust signature of a public key assigns two values to this key (and
thereby to its owner): the trust amount and the trust level. Both are integers between
0 and 255. The trust amount corresponds to the owner trust. Usually, a trust amount
less than 120 indicates partial owner trust; higher values indicate full owner trust.
The meaning of the trust level is the following. Suppose that Alice has generated a
trust signature of Bob’s key with trust amount 200.
•
If the trust level is 0, then the trust signature asserts that Alice has convinced
herself of the validity of Bob’s key and has owner trust 200 in Bob. This has the
same meaning as an ordinary validity signature.
•
If the trust level is 1, then the trust signature asserts that Alice has convinced
herself of the validity of Bob’s key and has owner trust 200 in Bob. Also, Alice
imports Bob’s trust amount values for all keys for which Bob has issued level 0
trust signatures. In this case, Bob is called a trusted introducer for Alice.
•
Generally, trust level n means that Alice imports Bob’s trust amount values for
all public keys for which Bob has issued trust signatures with trust level less than
n. For trust levels greater than 1, Bob is called a meta introducer for Alice.
Example 3.2. Figure 3.8 shows a trust chain with a meta introducer and a trusted
introducer. Alice signs Bob’s key with trust level 2 and trust amount 200, which
makes Bob a meta introducer for Alice. Bob signs Carl’s key with level 1 and trust

48
3
Trust Models
(2,200)
Bob
Carl
Dorian
Elvis
Alice
(1,200)
(0,200)
(0,200)
Fig. 3.8 A trust chain with a meta introducer and a trusted introducer
200, which makes Carl a trusted introducer for Bob. As Bob is a meta introducer for
Alice, Carl is also a trusted introducer for Alice. Carl signs Dorian’s key with level
0 and trust 200. As Carl is a trusted introducer for Alice, she accepts Dorian’s key
as valid. Note that Alice has never assigned any owner trust value to Carl explicitly.
Nevertheless, she relies on his signature. She trusts Carl because he is a trusted
introducer of Bob. But, as Alice decided to trust Bob with level 2 only, the trust
chain ends here. In order to accept Elvis’ key as valid, Alice has to manually set her
owner trust in Dorian to complete.
3.2.3
Probabilistic Trust Model for GnuPG
The GNU project implements OpenPGP in GnuPG (GPG) [4]. In standard GPG,
key legitimacy is calculated as a function of a ﬁnite set of values for the owner trust.
In [5] the authors propose a probabilistic model for determining key legitimacy that
is based on network reliability techniques.
3.3
Hierarchical Trust
The web of trust is quite convenient. It easily scales and requires no centralized
infrastructure. But the applicability of the web of trust is limited. Signers of public
keys typically do not accept (legal) liability for the authenticity of the public keys
which they sign. Therefore, the web of trust appears to be inadequate in a business
context. For example, consider a user who veriﬁes the authenticity of a home
banking Web page before entering a secret password. He does this by verifying
a digital signature of the Web page. In such a context it would be preferable
that the public veriﬁcation key for the signature of the Web page is certiﬁed by
some authority that can be made liable if the key turns out not to be authentic.
In the hierarchical trust model, certiﬁcate signers accept such liability. Also, in a
hierarchical PKI, trust in public keys depends on the trust in a uniquely determined
certiﬁcate signer, the so-called trust anchor.
In a hierarchical PKI, public keys are certiﬁed by certiﬁcation authorities (CAs).
CAs implement a process for verifying the authenticity of public keys, which they

3.3
Hierarchical Trust
49
Certiﬁcation Authority (CA)
Bob
Alice
Carl
CCA
CA
CCA
Bob
CCA
Alice
CCA
Carl
Fig. 3.9 A simple hierarchical PKI
certify. CAs make this process public in order for users to be able to determine the
level of trust in the CAs. More details about this can be found in Chap. 8. Also,
CAs assume liability for the authenticity of the public keys they certify. The most
important example of a hierarchical PKI architecture is based on the X.509 standard.
Issuers of X.509 certiﬁcates are assumed to be CAs.
Figure 3.9 shows a very simple hierarchical PKI. The participating entities are
represented by rectangles while arrows represent certiﬁcates. In this PKI, a single
CA has issued certiﬁcates to the end entities Alice, Bob, and Carl. The CA is the
trust anchor. It has issued a so-called self-signed certiﬁcate to itself. This certiﬁcate
contains the public key that is to be used to verify the signatures of the certiﬁcates
issued by the CA. Both subject and issuer of the self-signed certiﬁcate are the CA
itself. This certiﬁcate is depicted by a loop arrow from the CA to itself. All entities
in the PKI establish direct trust in the trust anchor. Since the PKI users trust the
trust anchor to sign certiﬁcates, the PKI users trust the authenticity of the public
keys of Alice, Bob, and Carl. Also, if entities outside the PKI trust the trust anchor
and its public key, then they also accept the public keys of Alice, Bob, and Carl
as authentic. Note that the process of establishing trust in the trust anchor is very
security-sensitive.
The PKI in Fig. 3.9 works as follows. Assume Carl wants to get an authentic
copy of Alice’s public key. Carl obtains the certiﬁcate issued by the trust anchor
to Alice. Carl trusts the authenticity of the public key of the trust anchor directly.
He veriﬁes the CA’s signature on Alice’s certiﬁcate. Since Carl accepts the CA as a
trusted authority that can authenticate public keys, the valid CA signature on Alice’s
certiﬁcate proves for Carl the authenticity of Alice’s public key.
In general, a hierarchical PKI is a tree as shown in Fig. 3.10. The inner nodes
are CAs. The leaves are the end entities. The root of the tree is called root CA. It is
the trust anchor of the PKI. Each arrow from a node A to a node B represents a
certiﬁcate issued by CA A to entity B. Frequently, there is a self-signed certiﬁcate
of the trust anchor to itself.

50
3
Trust Models
Alice
Bob
Carl
Diana
Emil
CA3
CA4
CA1
CA2
RCA
Fig. 3.10 A CA hierarchy
In a hierarchical PKI, trust in the authenticity of a public key is established
via a certiﬁcation path. Such a path is a ﬁnite sequence of certiﬁcates with the
property that in all certiﬁcates except for the last one, the subject is the issuer of
the subsequent certiﬁcate. For a more detailed discussion on verifying certiﬁcation
paths see Sect. 9.4. The path establishes trust in the public key of an entity if:
•
The subject in the last certiﬁcate of the path is this entity and
•
The issuer in the ﬁrst certiﬁcate is the trust anchor.
As an example, we consider the PKI from Fig. 3.10. In this PKI, Alice trusts the
public key of Diana. To establish this trust, she uses the certiﬁcate chain C RCA
RCA , C RCA
CA2 ,
C CA2
Diana.
The chain starts with the self-signed certiﬁcate of the root CA. In the next
certiﬁcate, the root CA certiﬁes the public key of CA2. In the third certiﬁcate, CA2
certiﬁes the public key of Diana.
In principle, trust hierarchies of arbitrary depth are possible. However, trust
may be weakened by introducing more depth in the hierarchy. Therefore, using
trust hierarchies of large depth may not be a good idea. For example, the German
signature law allows a trust hierarchy of depth 2 only. The trust anchor is a
governmental agency which certiﬁes commercial CAs, which in turn provide
certiﬁcates to end entities.
3.3.1
Basic Constraints
The basic constraints extension of an X.509 certiﬁcate must always be set and be
marked critical if the subject of the certiﬁcate is a CA. The ASN.1 description of this
extension is shown in Listing 3.1. The extension has two ﬁelds. The ﬁrst ﬁeld, cA, is
a Boolean value which is true if the certiﬁcate belongs to a CA and false otherwise.
If this value is true, then the public key contained in the certiﬁcate can be used to
verify signatures on certiﬁcates. Conversely, public keys that are used for verifying

3.4
Combining Trust Hierarchies
51
BasicConstraints ::= SEQUENCE {
cA
BOOLEAN DEFAULT FALSE,
pathLenConstraint
INTEGER (0..MAX) OPTIONAL }
Listing 3.1 Basic constraints extension
A
B
C
CA
A
CA
B
CB
C
Fig. 3.11 PKI
architecture—basic
constraints
Table 3.1
Minimum values
for pathLenConstraint
Certiﬁcate
Path length constraint
C A
A
1
C A
B
0
C B
C
Not set
certiﬁcate signatures must be contained in certiﬁcates in which the cA ﬁeld of the
basic constraints extension is true.
The second ﬁeld pathLenConstraint is used only for CA certiﬁcates in
which the cA ﬁeld is true and the keyCertSign bit is set in the key usage
extension. The value of this ﬁeld is an integer. It sets a limit on the number
of intermediate CA certiﬁcates that may be found after this certiﬁcate in the
certiﬁcation path before the path is invalid. Self-issued certiﬁcates do not count.
If such a limit is not desired then this ﬁeld is empty.
For example, the PKI shown in Fig. 3.11 contains three certiﬁcates. The minimal
pathLenConstraint values in the basic constraints extension of these three certiﬁ-
cates still permitting a valid certiﬁcation path are listed in Table 3.1.
3.4
Combining Trust Hierarchies
In practice, there exist many different independent hierarchical PKIs. Public
administrations, companies, universities, and many other institutions operate such
PKIs. The participants of each PKI are able to authenticate the public keys of the
other users of this PKI. However, users of two different PKIs cannot authenticate
their respective public keys unless the PKIs are combined. For example, in Fig. 3.12

52
3
Trust Models
Alice
Bob
Carl
Diana
Emil
Frank
Greg
CA3
CA4
CA5
CA6
CA1
CA2
Fig. 3.12 Two independent PKIs
Alice cannot authenticate Emil’s public key because Alice and Emil are participants
of different PKIs. In this section we describe methods for combining PKIs.
3.4.1
Trusted Lists
A simple way for an entity to be able to authenticate the public keys of the end
entities of several hierarchical PKIs is to accept the trust anchors of those PKIs
as trustworthy. For this, membership in the PKI is not required. For example, in
Fig. 3.12 Alice can accept CA2 as a new trust anchor. She is then able to construct
certiﬁcation paths starting at CA2. This implies that Alice trusts the public keys of
Emil, Frank, and Greg although Alice is not a participant of their PKIs. An entity
that wishes to use the public keys of the end entities of several hierarchical PKIs
maintains a trusted list of root CAs. For example, this is done in Web browsers or
certiﬁcate stores of operating systems. Those browsers and certiﬁcate stores come
with a list of trusted CAs. Users can manage those lists by adding or removing CAs
from the list.
A trusted list allows the owner of the list to use public keys of the end entities
in the PKIs of which root CAs are contained in the list. But the trusted list does not
enable the end entities of these PKIs to use the public key of the list owner unless
he is a participant in all PKIs. This means that end entities of PKIs cannot send
encrypted messages to the list owner and they cannot verify signatures of the list
owner. Thus, trusted lists extend PKIs unilaterally only.
Figure 3.13 shows the certiﬁcate manager of the email client Thunderbird. While
the certiﬁcates marked with Builtin Object Token are pre-installed, the certiﬁcates
marked with Software Security Device were added by the user.
In addition to application-speciﬁc and end user-maintained trusted lists as seen
in the example above, it is also possible to have trusted lists in an application-
independent format. These lists may be maintained by a trusted party. A common
way to achieve this is using the so-called trust-service status lists (TSLs) as
deﬁned in [6]. A TSL is a structured document (e.g. XML or PDF) containing

3.4
Combining Trust Hierarchies
53
Fig. 3.13 Trusted list in Thunderbird
security-sensitive information on third parties which is signed by a trusted party.
In the PKI context this information can be a list of trusted certiﬁcates. Figure 3.14
shows (a part of) a TSL issued by the European Commission containing, apart from
other information, certain self-signed certiﬁcates of the member states.
3.4.2
Common Root
Another way to combine two or more hierarchical PKIs is to introduce a new
common root CA as shown in Fig. 3.15. This means that each end entity of the
combined PKIs replaces its original trust anchor by the new common root. As a
consequence, certiﬁcation paths that establish the authenticity of a public key
have to be changed by prepending the common root. For example, in Fig. 3.15
the new certiﬁcation path authenticating the public key of Emil for Alice is
C RCA
RCA , C RCA
CA2 , C CA2
CA5 , C CA5
Emil.
If a common root is used, all users of all combined CAs can mutually authenticate
their public keys. But all PKI users have to add the new common root or even
replace their trust anchors by the new common root. This may cause problems.
An institution may not be willing to accept an outside trust anchor or may ﬁnd it to
costly or error-prone to have all users modify their trust anchors.

54
3
Trust Models
Fig. 3.14 TSL of the European commission
Alice
Bob
Carl
Diana
Emil
Frank
Greg
CA3
CA4
CA5
CA6
CA1
CA2
RCA
Fig. 3.15 A common root hierarchy

3.4
Combining Trust Hierarchies
55
Fig. 3.16 Self-signed root certiﬁcates of two university PKIs
Fig. 3.17 Common root for two university PKIs
As an example, Fig. 3.16 shows the trust anchor certiﬁcates of the PKIs of the
Universities of Gießen and Darmstadt in Germany. Figure 3.17 shows how the DFN
root CA serves as a common root of these two PKIs.

56
3
Trust Models
Alice
Bob
Carl
Diana
Emil
Frank
Greg
CA3
CA4
CA5
CA6
CA1
CA2
CCA1
CA2
CCA2
CA1
Fig. 3.18 Cross-certiﬁed CAs hierarchy
3.4.3
Cross-Certiﬁcation
Cross-certiﬁcation allows users of two PKIs to authenticate each other’s public keys
without replacing their trust anchors. The idea is that the two root CAs certify
each other’s public keys using so-called cross-certiﬁcates. In fact, the two CAs
that cross-certify each other may also be intermediate CAs. However, this implies
that only some of the PKI participants accept each other’s public keys as authentic.
An example of cross-certiﬁcation is given in Fig. 3.18. Here, CA1 issues a cross-
certiﬁcate to CA2 and vice versa. The cross-certiﬁcate issued by CA1 to CA2
is C CA1
CA2 .
From the point of view of CA1 this certiﬁcate is called an issuedByThisCA
certiﬁcate. The older name reverse certiﬁcate is no longer used. From the point of
view of CA2, the certiﬁcate C CA1
CA2 is called an issuedToThisCA certiﬁcate. The
older name forward certiﬁcate is no longer used.
In the example, Alice authenticates the public key of Emil using the certiﬁcation
path C CA1
CA1 , C CA1
CA2 , C CA2
CA5 , C CA5
Emil.
Typically, cross-certiﬁcation is bidirectional. However, it is also possible that
CA1 certiﬁes CA2 without CA2 certifying CA1. Then the users of CA1 can
authenticate the public keys certiﬁed in the PKI of which CA2 is the root but not the
other way round. Figure 3.19 shows two cross-certiﬁcates of the German Medical
Association.
The drawback of cross-certiﬁcation is that the number of certiﬁcates required to
connect many PKIs is large. In fact, to connect n PKIs, n.n  1/ cross-certiﬁcates
must be issued. This may become impractical.
3.4.4
Bridge
Introducing bridge CAs allows users of several PKIs to authenticate each other’s
public keys without replacing their trust anchors. Also, compared to cross-certi-
ﬁcation much fewer new certiﬁcates are required when a bridge CA is introduced.

3.4
Combining Trust Hierarchies
57
Fig. 3.19 Cross-certiﬁcates of the German medical association
Alice
Bob
Carl
Diana
Emil
Frank
Greg
CA3
CA4
CA5
CA6
CA1
CA2
Bridge CA
Fig. 3.20 A bridge CA hierarchy
The bridge is a new CA; however, it is not the new root for the PKIs to be combined.
This is depicted in Fig. 3.20. The root CAs of the participating PKIs cross-certify
the bridge CA and remain the trust anchors of their respective PKIs. Certiﬁcation
paths for authenticating public keys of end entities in the PKI of which the same
CA is the root remain the same. Now consider Fig. 3.20 and assume that user Alice
with trust anchor CA1 wishes to authenticate the public key of user Emil with trust
anchor CA2. The corresponding certiﬁcation path starts at CA1, the trust anchor for
Alice, proceeds to the bridge, continues to CA2, and then follows the authentication
path from CA2 to Emil. The path is C CA1
CA1 , C CA1
Bridge CA, C
Bridge CA
CA2
, C CA2
CA5 , C CA5
Emil. It can be
seen from this certiﬁcation path that Alice does not need to update her trust anchor.

58
3
Trust Models
Fig. 3.21 Certiﬁcate of the
European Bridge CA
The bridge CA is operated by a trustworthy organization that is accepted by all PKIs
joining the bridge.
Cross-certiﬁcation, as shown in Fig. 3.20, is not the only way to connect to
a bridge CA. For example, the European Bridge CA (EBCA) [3] bridges the
PKIs of various European organizations by issuing a signed list containing the
certiﬁcates of the member organizations. The list is published in the PKCS#7 format
(confer Sect. 7.5.1). Figure 3.21 shows the certiﬁcate of the EBCA that is used to
sign the list. The certiﬁcate is subordinated to the German national root CA for
legally binding electronic signatures, which makes the signature of the list legally
binding.
3.5
Exercises
3.1. Enter the missing values into Table 3.2, which shows Alice’s key ring.
3.2. Answer the following questions:
1. Where is the hash value of a complete X.509 certiﬁcate used?
2. Where is the hash value of the TBS part of an X.509 certiﬁcate used?

3.5
Exercises
59
Table 3.2 Public key ring of
Alice with missing values
Public key ring of Alice
1
Public key owner
: Alice
Owner trust/key legitimacy : ultimate/complete
1
Signer/trust in signer
: Alice/ultimate
2
Public key owner
: Bob
Owner trust/key legitimacy : marginal/
1
Signer/trust in signer
: Alice/
2
Signer/trust in signer
: Bob/
3
Signer/trust in signer
: Carl/
3
Public key owner
: Carl
Owner trust/key legitimacy : none/
1
Signer/trust in signer
: Bob/
2
Signer/trust in signer
: Carl/
4
Public key owner
: Diana
Owner trust/key legitimacy : unknown/
1
Signer/trust in signer
: Bob/
2
Signer/trust in signer
: Carl/
3
Signer/trust in signer
: Diana/
4
Signer/trust in signer
: Emil/
5
Signer/trust in signer
: Frank/
5
Public key owner
: Emil
Owner trust/key legitimacy : marginal/
1
Signer/trust in signer
: Alice/
2
Signer/trust in signer
: Bob/
3
Signer/trust in signer
: Emil/
6
Public key owner
: Frank
Owner trust/key legitimacy : marginal/
1
Signer/trust in signer
: Alice/
2
Signer/trust in signer
: Frank/
3.3. Consider the hierarchical PKI in Fig. 3.22.
1. What are the possible trust anchors for Alice that enable her to trust the
authenticity of Bob’s public key?
2. What are the possible trust anchors for Alice that enable her to trust the
authenticity of Carl’s public key?
3. Is it possible for Alice to be convinced of the authenticity of Emil’s public key
without trusting the Dep2 CA?
4. Is it possible for Alice to be convinced of the authenticity of Emil’s public key
without trusting the Org2 CA?
3.4. Consider the PKIs in Fig. 3.23.
1. How can these ﬁve PKIs be connected in such a way that any end entity can trust
the public key of any other end entity?
2. How many new certiﬁcates are issued in each of the solutions?
3. How many trust anchors do the end entities have in each case? What are the trust
anchors of end entity G in each case?

60
3
Trust Models
Root
Dep1
Emil
Carl
Bob
Alice
Doris
Dep2
Org2
Org1
Fig. 3.22 A hierarchical PKI
Fig. 3.23 A PKI setup
References
1. CAcert – root keys, http://www.cacert.org/index.php?id=3
2. J. Callas, L. Donnerhacke, H. Finney, D. Shaw, R. Thayer, OpenPGP message format, in IETF
Request for Comments, 4880, Nov 2007
3. EBCA – TeleTrusT European Bridge CA, https://www.ebca.de/en/
4. GNU Privacy Guard, http://www.gnupg.org/
5. J. Jonczy, M. Wüthrich, R. Haenni, A probabilistic trust model for GnuPG, in Proceedings of
the 23rd Chaos Communication Congress, 23C3, Berlin, pp. 61–66, 2006
6. The European Telecommunications Standards Institute (ETSI), Electronic signatures and
infrastructures (ESI); Provision of harmonized trust-service status information. ETSI TS 102
231 V3.1.2, Dec 2009
7. The International PGP Home Page, http://www.pgpi.org/
8. T. Ylonen, C. Lonvick, The secure shell (SSH) protocol architecture, in IETF Request for
Comments, 4251, Jan 2006

Chapter 4
Private Keys
In the previous chapters we have seen how certiﬁcates and trust models can be used
to authenticate public keys. A further task of public key infrastructures is to support
the users in keeping their private keys secret. In this chapter we show how this can
be achieved. We introduce a private key life cycle model and discuss software- and
hardware-based solutions for storing and protecting private keys.
4.1
Private Key Life Cycle
We begin our discussion by examining the life cycle of a private key, shown in
Fig. 4.1, as presented in [10]. There, the life cycle is described using the terminology
of ﬁnite state machines. This means that a private key can be in different states and
there are transitions between the states. The possible states are depicted by circles,
the transitions are symbolized by arrows pointing from a source state to a destination
state.
We summarize the possible states and transitions. Initially, the key is non-
existent. From this state the only possible transition is to generate the key after which
it is storable. This means that the key exists in some volatile memory waiting to be
processed further. Key generation has to be implemented securely. For example,
random number generation must be done in such a way that the random numbers
cannot be predicted. Storable keys permit two transitions: they can be stored in
some personal security environment (PSE) after which they are deliverable to the
potential users. The PSE is protected against unauthorized access, for example by a
pass-phrase. In some cases it might be necessary to restore a deliverable key from
the PSE to the storable state. When keys are storable it is also possible to deposit
them, after which they are in the archived state. For example, this may be necessary
to back up decryption keys. Archived keys can be recovered, after which they are
storable again. Deliverable keys are delivered to their owners after which they are
usable for signing or decryption. If the keys do not reach the user, they may have
to be retracted. In all states in which keys exist, they may be copied or destroyed.
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__4, © Springer-Verlag Berlin Heidelberg 2013
61

62
4
Private Keys
deposit
store
deliver
use
recover
non-existent
storable
deliverable
usable
archived
destroy
destroy
destroy
destroy
copy
generate
copy
copy
copy
restore
retract
Fig. 4.1 The private key life cycle
The latter may happen to keys that are expired and do not need to be archived.
Destruction of keys is a sensitive issue which is discussed in [4] and [1].
In their different states the private keys may have additional attributes. These
attributes and the policies that are applied in the PKI determine which transitions are
selected. For example, a compromised signature key may be destroyed immediately;
a compromised decryption key may be required to decrypt old data and may
therefore be destroyed later.
4.2
Personal Security Environments
Personal security environments (PSEs) protect private keys of users against unautho-
rized access. Before a PSE grants access to its data, it requires authorization from
the accessing party. Typically, authorization is based on a personal identiﬁcation
number (PIN) or a pass-phrase, which are only known to authorized entities.
Figure 4.2 presents an overview of widespread PSE types. PSEs can be imple-
mented in software (for example, encrypted ﬁles) or in hardware (for example, smart
cards). While software PSEs provide better ﬂexibility and platform independence,

4.3
Software PSEs
63
standardized
(e.g., PKCS#12) 
OS- / language-
specific
(e.g., Java KeyStore)
application-
specific
(e.g., Firefox)
hardware
security module
(HSM)
USB token
smart card
software
hardware
secure storage of private keys
Fig. 4.2 Overview of personal security environments
hardware PSEs have a higher security level. The following sections describe
commonly used PSEs in more detail.
4.3
Software PSEs
4.3.1
PKCS#12
The PKCS#12 [8] standard speciﬁes a format that allows storing and transferring
security-sensitive data such as private keys and certiﬁcates. Many applications, for
example Web browsers and operating systems, can process private keys stored in
this format. Typically, they import the PKCS#12 ﬁles, extract the keys, and store
them using some internal representation.
Figure 4.3 shows the structure of PKCS#12. It is an AuthenticatedSafe
that contains one or more ContentInfo structures. It protects the authenticity
and conﬁdentiality of its contents using a secret password or a public key technique.
We describe the PKCS#12 structure in more detail.
AuthenticatedSafe The content that needs to be protected is placed in a container
called AuthenticatedSafe. It supports the following two authentication modes.
Public Key Integrity Mode In this mode the AuthenticatedSafe is digitally signed
using a private key of the content originator. The corresponding public key is
appended to the data. Receivers may check the authenticity of the content by
verifying the signature and by authenticating the public key, for example, by
obtaining its ﬁngerprint from the content owner.
Password Integrity Mode In this mode a MAC value of the AuthenticatedSafe’s
content is calculated using a symmetric key which is derived from a password, some
salt bits, and a counter. The salt and the counter are appended to the data. Recipients
who know the password can derive the same key and authenticate the content. The
salt bits and the counter prevent replay attacks.

64
4
Private Keys
Fig. 4.3 The PKCS#12
format
ContentInfo An AuthenticatedSafe may contain several ContentInfo structures.
Three ContentInfo types are possible: data, enveloped, and encrypted. The (plain)
data type is used if no conﬁdentiality protection is required. The other two types are
used in the modes explained now.
Public Key Privacy Mode In the public key privacy mode the type enveloped data
is used. The content is encrypted using a symmetric encryption key which in turn
is encrypted with the public key of the receiver. The receiver is able to decrypt the
encrypted symmetric key and the protected content.
Password Privacy Mode In the password privacy mode the type encrypted data
is used. The content is encrypted with a symmetric key which is derived from a
password, additional salt bits and a counter. The salt and the counter are appended
to the data. The password must be known to the recipient of the ﬁle to decrypt the
data.
Combinations If both a conﬁdentiality and an authenticity protecting mechanism
are used, four combinations of the modes are possible. Most commonly, the
password privacy and password integrity modes are used and the same password is
applied in both modes. Most operating systems and applications are able to process
this format and extract private keys from it.
Typically, for PKCS#12, ﬁles, the extensions .p12 or .pfx are used. This
allows their automatic processing, for example, as email attachments. A critical
discussion of the PKCS#12 standard can be found in [3].
4.3.2
PKCS#8
Another format to store private keys is speciﬁed in the PKCS#8 standard [7]. This
format allows storing private keys in encrypted and non-encrypted form. However,

4.3
Software PSEs
65
in practice this format is almost never used by itself for key transport. Instead, a
PKCS#8-encoded private key is transported by placing it into the ﬁle content of a
PKCS#12 ﬁle. If the PKCS#12 privacy mode is used, the PKCS#8 ﬁle needs no
encryption.
4.3.3
Java KeyStore
Java KeyStore is a Java class that supports storing, accessing, and modifying data
such as private keys, secret keys, and certiﬁcates. Also, this class supports the
interaction with standard formats such as PKCS#12 (see Sect. 4.3.1) and PKCS#11
(see Sect. 4.4.3). Using the KeyStore class it is possible to implement application-
speciﬁc Java key stores that are called key store types. Listing 4.1 shows how to
choose and use KeyStores in a Java program. Java has the following predeﬁned key
store types.
JKS
This is a very simple built-in key store implementation. It is the default type.
It implements the key store as a single ﬁle using a proprietary format. According
to the Java documentation it applies some kind of weak encryption and integrity
protection to the stored keys.
JCEKS
This type is provided as an alternative to the JKS type. It also implements
the KeyStore using a proprietary single ﬁle format. According to the Java
documentation this type provides stronger cryptography for encryption and
integrity protection. The default encryption method is password-based Triple-
DES.
PKCS12
This type allows creating, accessing, and modifying standard PKCS#12
ﬁles using the KeyStore interface.
PKCS11
This type allows accessing and modifying PKCS#11-based hardware
PSEs using the KeyStore interface. It relies on PKCS#11 libraries that are usually
delivered with the PSE hardware.
4.3.4
Application-Speciﬁc Formats
There are also many application-speciﬁc formats for storing private keys.
Microsoft Windows Figure 4.4 shows the certiﬁcate and key manager of
the Microsoft Windows operating systems. It can be opened by executing
certmgr.msc on the command line. It stores keys and certiﬁcates in several
categories. When a private key is imported it is stored together with the
corresponding certiﬁcate in the selected category. The certiﬁcate manager provides
an API to allow applications to access the store and a GUI for the user. Figure 4.4
shows the GUI with the categories on the left side and the certiﬁcates stored in the
“Third-Party Root Certiﬁcation Authorities” category.

66
4
Private Keys
import java.io.FileInputStream;
import java.io.IOException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
public class KeyStoreUse {
public static void main(String[] args) throws KeyStoreException
, NoSuchAlgorithmException, CertificateException,
IOException, UnrecoverableKeyException
{
KeyStore ks = KeyStore.getInstance("JKS");
/* replace the previous line with this one to work with JCEKS
KeyStores */
/* KeyStore ks = KeyStore.getInstance("JCEKS"); */
/* replace the previous line with this one to work with
PKCS12 (since Java version 5.0) */
/* KeyStore ks = KeyStore.getInstance("pkcs12"); */
char[] password = "the_password_that_protects_the_file".
toCharArray();
FileInputStream fis = new FileInputStream("path/to/file.ks");
ks.load(fis, password);
fis.close();
Key key = ks.getKey("alias", password);
PrivateKey privKey = (PrivateKey) key;
// perform an operation like signing with this private key
}
}
Listing 4.1 How to use a Java KeyStore
Thunderbird The email client Thunderbird has its own certiﬁcate and key man-
ager which stores keys and certiﬁcates in several categories. Imported private
keys are stored together with the corresponding certiﬁcate in the chosen category.
Figure 4.5 shows Thunderbird’s certiﬁcate manager. It shows the different categories
as tabs at the top of the window. The category “Your Certiﬁcates” is opened and
the certiﬁcates belonging to this category are visible. The certiﬁcate manager also
provides an API allowing plug-ins and add-ons to access the store.

4.3
Software PSEs
67
Fig. 4.4 Microsoft Windows certiﬁcate manager
Fig. 4.5 Thunderbird’s certiﬁcate manager

68
4
Private Keys
Fig. 4.6 A smart card
(Source: HRZ TU Darmstadt)
4.4
Hardware PSEs
To enhance the security of private keys, special-purpose hardware can be used.
Important examples of such hardware are smart cards and hardware security
modules, which are discussed in this section.
4.4.1
Smart Cards
Smart cards are plastic cards that carry a microprocessor which is able to perform
cryptographic operations. The smart card contains private keys which in most cases
are only used on the smart card and never leave it. For example, if a smart card
is used for digital signatures, then the hash value of the document is sent to the
smart card and signed there. Likewise, decryption is performed on the smart card.
An example of a smart card is shown in Fig. 4.6. Smart cards are commonly used in
PKIs as hardware PSEs. They provide very secure storage of private keys, and, at
the same time, they are portable because they are of the size of a credit card.
Access to private keys on a smart card requires providing a PIN. Typically, this
PIN is a sequence of digits between 0 and 9. If the user fails to enter the correct
PIN he may reenter the PIN. In order to prevent exhaustive search, the number of
admissible trials is limited, usually to three. If the maximum number of trials is
exceeded then the smart card is locked and cannot be accessed anymore. The smart
card may be unlocked by entering the personal unblocking key (PUK). The number
of PUK trials is also limited. While the PIN is a relatively short sequence of usually
4–6 digits meant to be memorized, the PUK is a relatively long sequence of usually
10–20 digits which is not expected to be memorizable.
If a private key is protected by a smart card, users need two components in
order to use it: knowledge of the PIN and possession of the smart card. This is
one of the reasons why smart cards provide much more security for private keys
than software PSEs. Since using the private key requires the possession of the smart
card, it can only be used by exactly one person at a time. Also, since the use of
the smart card requires the knowledge of the correct PIN, only the owner of the

4.4
Hardware PSEs
69
smart card can use it. On some smart cards the PIN authorization is replaced by
a biometric authorization. That enhances the security level of private keys even
further, as biometric attributes cannot be passed on to other persons.
Most smart cards run a proprietary operating system that manages its resources.
For example, it prevents private keys from being read from the smart card. It is
stored in the read-only memory (ROM) of the card and cannot be changed. Keys,
certiﬁcates, and other data are written in the electrically erasable programmable
read-only memory (EEPROM). In order to change or erase this information, special
access control mechanisms are used.
There are also Java-enabled smart cards, so-called Java cards. In addition to
their proprietary operating systems, these smart cards have a Java card runtime
environment (JCRE) and can process Java card applets. Such applets are usually
written in a reduced version of the Java programming language. Java cards are easier
to program than other smart cards since they use a standard high-level programming
language. However, if a cryptographic algorithm is not available on the smart card
processor, then its execution in a Java card is slow.
Frequently, smart cards are evaluated according to some evaluation framework
such as information technology security evaluation criteria (ITSEC) or common
criteria. This evaluation provides some evidence of the security of the smart card.
4.4.2
Smart Card Readers
In order to operate a smart card, a smart card reader is required which is connected
to a host computer. The reader handles the communication between the host and the
smart card. There are contact smart cards, contactless smart cards, and dual interface
cards. Contact smart cards use a metal contact to transmit data between the reader
and the smart card. Contactless smart cards use radio frequencies to transmit data.
Dual interface cards have both a contact and a contactless interface.
In addition to simple card readers that can only read from the card and write on
the card, there are readers with key pads for entering the PIN. The advantage of
such readers is that the PIN remains unknown to the host computer. This prevents
malicious software from eavesdropping and abusing the PIN. There are also smart
card readers with PIN pad and display. The display can be used to enhance the
security even further. It can be used to display messages to the user. For example,
the display may show a hash or even the whole document that is to be signed.
There are also programmable readers called FINREAD. These readers are
programmed by applets written in the Java language. This applet is called a ﬁnlet.
These readers can be customized for several applications. For example, they may
show the amount of an electronic banking transaction before the transaction is
signed.
Finally, the smart card may be placed in a USB token. Then the smart card com-
municates with its host via the USB interface. This solution has several advantages.
It may be cheaper since no extra card reader is required. More importantly, such

70
4
Private Keys
CK_SLOT_ID slotID;
CK_ULONG ulCount;
CK_MECHANISM_TYPE_PTR pMechanismList;
CK_RV rv;
...
rv = C_GetMechanismList(slotID, NULL_PTR, &ulCount);
if ((rv == CKR_OK) && (ulCount > 0)) {
pMechanismList = (CK_MECHANISM_TYPE_PTR) malloc(ulCount*
sizeof(CK_MECHANISM_TYPE));
rv = C_GetMechanismList(slotID, pMechanismList, &ulCount);
if (rv == CKR_OK) {
...
}
free(pMechanismList);
}
Listing 4.2 PKCS#11 example
a token can be used with almost every host computer since modern computers are
equipped with a USB interface.
4.4.3
Smart Card Communication Interfaces
In this section we explain three programming interfaces for the communication
between hosts and smart cards: PKCS#11, PC/SC, and CT-API. These standards
are supported by all major operating systems such as Microsoft Windows, Mac OS,
and Linux.
PKCS#11 The PKCS#11 standard [9] speciﬁes an interface to cryptographic
tokens such as smart cards that are able to store, manage, and use cryptographic
keys. PKCS#11 is the de facto standard for accessing smart cards. It deﬁnes a
platform-independent high-level API called cryptographic token interface (cryp-
toki) for accessing cryptographic hardware.
The API is written in the programming language C and deﬁnes data types and
functions for the most common cryptographic objects (such as keys and certiﬁcates)
and mechanisms (such as encryption and hashing). Many of the available crypto-
graphic hardware tokens exceed the functionality deﬁned in PKCS#11. Usually, the
manufacturers provide proprietary extensions to the PKCS#11 standard that enable
programmers to use the full potential of their hardware. Listing 4.2 shows sample
C code for requesting the list of supported mechanisms (algorithms) from a token.
The example is taken from [9].
Smart card manufacturers usually provide PKCS#11 implementations for their
cards. Correspondingly, clients have to provide support for PKCS#11 if they wish
to support smart cards. For example, Firefox and Thunderbird can access keys and
certiﬁcates on smart cards using PKCS#11. Figure 4.7 shows the dialog window
for installing a PKCS#11 library, usually provided in the form of a .dll ﬁle for

4.4
Hardware PSEs
71
Fig. 4.7 Installation of a PKCS#11 library in Firefox
Windows or .so ﬁle for Linux, in Firefox. Other applications are also based on
PKCS#11, for example authentication modules for UNIX or Microsoft Windows.
PC/SC The interoperability speciﬁcation for ICCs and personal computer systems
(PC/SC) interface is described in [6]. It is a widely accepted standard for smart cards
and readers. Most available card readers are delivered with a PC/SC driver. PC/SC
does not provide a high-level programming interface like PKCS#11, but requires
the programmer to send binary commands to the card. In Listing 4.3 we show an
example of a communication with a smart card via PC/SC.
CT-API CT-API (card terminal-API) is widely used in Germany. It is speciﬁed in
[2]. This interface is very simple. It only speciﬁes three different functions, one for

72
4
Private Keys
import java.security.NoSuchAlgorithmException;
import java.util.List;
import javax.smartcardio.*;
/**
* This example requires at least Java version 6.
*/
public class SmartCardConnection {
public static void main(String[] args) throws
NoSuchAlgorithmException, CardException {
TerminalFactory tf = TerminalFactory.getInstance("PC/SC",
null);
CardTerminals cts = tf.terminals();
List<CardTerminal> list
= cts.list();
CardTerminal ct = list.get(0);
Card card = ct.connect("T=1");
CardChannel cc = card.getBasicChannel();
/* Prepare the APDU 00 A4 00 0C 02 3F 00 (select Master File)
. */
byte[] select = {(byte)0x00,(byte)0xA4,(byte)0x00,(byte)0x0C
,(byte)0x02,(byte)0x3F,(byte)0x00};
CommandAPDU capdu = new CommandAPDU(select);
/* Send the command and receive the response from the card.
*/
ResponseAPDU rapdu = cc.transmit(capdu);
/* The response should be 90 00. */
}
}
Listing 4.3 Communication with a smart card over PC/SC using Java
opening the connection to the terminal or the card (CT_init), one for sending and
receiving data (CT_data), and one for closing the previously opened connection
(CT_close). Although CT-API is simple it allows us to perform all necessary
functions with a card and the card reader by sending binary commands.
4.4.4
Hardware Security Module
A hardware security module (HSM) is a hardware device that is optimized for
cryptographic operations without the size constraints of a smart card. HSMs are
available as PCI devices, as external devices that can be connected to a PC, for

References
73
example via USB, and as network devices which can be accessed using TCP/IP.
HSMs are operated using the PKCS#11 standard or the cryptographic architectures
JCA/JCE of the Java programming language. Typical HSM operations are secure
(pseudo)random number generation, key pair generation, calculation of digital sig-
natures, encryption, and decryption. Frequently, HSMs also support cryptographic
protocols such as TLS. HSMs are commonly used in server systems which have
to perform many cryptographic operations in a short period of time. Example
applications are time-stamping servers, online certiﬁcate status protocol servers, and
server-based certiﬁcate validation protocol servers. HSMs are typically protected
against mechanical, temperature, electrical, electronic, and chemical attacks and
support multi-person control.
Most HSMs are evaluated according to the FIPS 140-1 and FIPS 140-2 standards
[5]. These standards deﬁne requirements for cryptographic modules and have
different levels of assurance. Other evaluation frameworks such as the common
criteria are also used to evaluate HSMs.
4.5
Exercises
4.1. Answer the following questions:
1. What modes of content protection are allowed by PKCS#12?
2. How can the modes be combined?
3. What secrets must be known and to whom in each mode?
4.2. Describe the steps that are executed when a signature of a document is
generated on a smart card that is connected to a PC via a smart card reader.
References
1. G. Di Crescenzo, N. Ferguson, R. Impagliazzo, M. Jakobsson, How to forget a secret, in
Proceedings of the 16th Annual Symposium on Theoretical Aspects of Computer Science
(STACS’99), Trier, ed. by C. Meinel, S. Tison. Number 1563 in Lecture Notes in Computer
Science (LNCS). (Springer, Berlin/Heidelberg, 1999), pp. 500–509
2. DT, FHG, SIT, TÜV, TELETRUST, CT-API 1.1, Application independent CardTerminal
application programming interface for ICC applications (2002), http://www.tuvit.de/cps/rde/
xbcr/tuevit_de/CTAPI11EN.pdf
3. P. Gutmann, PFX – How not to design a crypto protocol/standard, http://www.cs.auckland.ac.
nz/~pgut001/pubs/pfx.html
4. P. Gutmann, Secure deletion of data from magnetic and solid-state memory, in Proceedings of
the 6th USENIX Security Symposium, San Jose, July 1996
5. NIST, FIPS standards, http://csrc.nist.gov/publications/PubsFIPS.html
6. PCSC Workgroup, PC/SC speciﬁcation, http://www.pcscworkgroup.com/
7. RSA Laboratories, PKCS #8 v1.2: private-key information syntax standard (1993), http://www.
rsa.com/rsalabs/node.asp?id=2130

74
4
Private Keys
8. RSA Laboratories, PKCS #12 v1.0: personal information exchange syntax (1999), http://www.
rsa.com/rsalabs/node.asp?id=2138
9. RSA Laboratories, PKCS #11 v2.20: cryptographic token interface standard (2004), http://
www.rsa.com/rsalabs/node.asp?id=2133
10. A. Wiesmaier, Secure private key management in adaptable public key infrastructures.
Ph.D. thesis, Cryptography and Computer Algebra Group, Technische Universität Darmstadt.
(Mensch und Buch Verlag, Berlin, 2009). ISBN-13: 978-3-86664-646-9

Chapter 5
Revocation
The validity period of certiﬁcates may be quite long. For example, X.509 SSL
server certiﬁcates are typically valid for at least 2 years. However, it may happen
that during the validity period a certiﬁcate has to be invalidated, for example,
if the private key that corresponds to the public key in the certiﬁcate has been
compromised. The process of invalidating the certiﬁcate before its expiration time
is called revocation. In this chapter, we discuss revocation and strategies to publish
revocation information.
5.1
Requirements
If a certiﬁcate is revoked, revocation information is generated and made available.
The certiﬁcate revocation information should have several properties. It must
contain the revoked certiﬁcates and the revocation time. In addition, it may also
contain the reason for the revocation. This may be useful to estimate potential
damage caused by using a revoked certiﬁcate. The revocation information must be
anywhere and always available since it cannot be predicted where and when the
public key contained in the certiﬁcate is used. The authenticity of the revocation
information must be veriﬁable by anyone. The revocation information must be
as fresh as possible. There may always be a delay between the revocation of a
certiﬁcate and the publication of the revocation information. However, this delay
should be as short as possible.
A more detailed analysis of revocation requirements as well as a list of criteria
for evaluating revocation mechanisms can be found in [1].
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__5, © Springer-Verlag Berlin Heidelberg 2013
75

76
5
Revocation
CertificateList ::= SEQUENCE {
tbsCertiList
TBSCertList,
signatureAlgorithm
AlgorithmIdentifier,
signatureValue
BIT STRING
}
TBSCertList
::=
SEQUENCE
{
version
Version OPTIONAL,
signature
AlgorithmIdentifier,
issuer
Name,
thisUpdate
Time,
nextUpdate
Time OPTIONAL,
revokedCertificates
SEQUENCE OF SEQUENCE
{
userCertificate
CertificateSerialNumber,
revocationDate
Time,
crlEntryExtensions
Extensions OPTIONAL }
OPTIONAL,
crlExtensions
[0]
EXPLICIT Extensions OPTIONAL }
Listing 5.1 ASN.1 speciﬁcation of an X.509 CRL
5.2
Certiﬁcate Revocation Lists
One way to publish revocation information is to use certiﬁcate revocation lists
(CRLs). A CRL is a list of revoked certiﬁcates which is digitally signed to prove its
authenticity. CRLs are regularly updated. When a CRL is updated, newly revoked
certiﬁcates are inserted into the CRL. There are direct CRLs and indirect CRLs.
Direct CRLs only contain certiﬁcates of one issuer and are issued and signed by
that issuer. In contrast, an indirect CRL may contain certiﬁcates of several issuers
and is signed by the so-called CRL issuer.
Users who wish to obtain revocation information download the CRL and verify
its digital signature. Then they check whether the certiﬁcate that they are interested
in is contained in the CRL.
One problem with CRLs is that they may become quite large since expired
certiﬁcates are not always removed from the CRL. Therefore, delta CRLs have
been introduced which only contain the certiﬁcates that have been revoked after
the publication of the last full CRL. The full CRL contains all revoked certiﬁcates.
It is also referred to as complete CRL.
CRLs are speciﬁed in the X.509 standard. The ASN.1 description of an X.509
CRL is shown in Listing 5.1. Its structure is presented in Fig. 5.1. This structure
resembles that of an X.509 certiﬁcate.
In the remainder of this section we explain X.509 CRLs in more detail.
5.2.1
Basic Fields
We describe the basic ﬁelds of a CRL.

5.2
Certiﬁcate Revocation Lists
77
signature algorithm
signatureValue
tbsCertList
version
signature
issuer
thisUpdate
nextUpdate
revoked certificates
extensions
identifier
criticality flag
value
extension
extension
CRL entry
CRL entry
user certificate
revocation date
extensions
Fig. 5.1 The structure of an X.509v2 CRL
version The version ﬁeld contains the version of the CRL speciﬁcation that is
used for this CRL. Currently, only version 2 CRLs are used. They support CRL
extensions. Therefore, the entry of this ﬁeld is always 2.
signature The signature ﬁeld contains the OID of the signature algorithm that has
been used to sign the CRL. This OID must be the same as the OID that is contained
in the part of the CRL that is not signed.
issuer The issuer ﬁeld contains the distinguished name of the CRL issuer who has
signed the CRL. This ﬁeld must not be empty.
thisUpdate The content of the thisUpdate ﬁeld is the time and date when the
CRL was issued. It informs users that certiﬁcates not included in the CRL were not
revoked before this point in time. The individual revocation time of a certiﬁcate is
contained in the corresponding CRL entry.
nextUpdate The nextUpdate ﬁeld contains the date and time when the next
update of the CRL will be available. This ﬁeld is optional. If it is present, the follow-
up CRL must not be published later than this date. Although RFC 5280 [3] proposes
not to use CRLs that do not contain this date, some issuers do not include this ﬁeld
to avoid liability. The nextUpdate time in a CRL should not be earlier than the
nextUpdate time in a previously issued CRL. This may be achieved by checking
the nextUpdate time of the previously issued CRL or by using a constant period
between thisUpdate and nextUpdate.

78
5
Revocation
reasonCode ::= { CRLReason }
CRLReason ::= ENUMERATED {
unspecified (0),
keyCompromise (1),
cACompromise (2),
affiliationChanged (3),
superseded (4),
cessationOfOperation (5),
certificateHold (6),
removeFromCRL (8),
privilegeWithdrawn (9),
aACompromise (10) }
Listing 5.2 Reason code extension
revokedCertiﬁcates The revokedCertificates ﬁeld contains the actual list
of revoked certiﬁcates. If no certiﬁcate is revoked, then this list is not present.
Revoked certiﬁcates are also called CRL entries. They consist of the following
sub-ﬁelds.
userCertiﬁcate
This ﬁeld contains the serial number of the revoked certiﬁcate. In
direct CRLs, this serial number and the issuer contained in the CRL issuer ﬁeld
determine the revoked certiﬁcate uniquely. Later in this section we explain how
certiﬁcates can be identiﬁed in indirect CRLs.
revocationDate
This entry contains the revocation date and time for the certiﬁcate
in this entry. It is assigned by the CRL issuer and not by the certiﬁcate owner.
The revocationDate of certiﬁcates that appear for the ﬁrst time in this CRL must
not be earlier than thisUpdate of the previous CRL. For such certiﬁcates, the
time difference between the revocationDate and thisUpdate of the present CRL
is called revocation latency. In addition to the two basic ﬁelds userCertiﬁcate and
revocationDate, CRL entries may contain three extensions which are explained
next.
reasonCode
This extension describes the reason for the revocation of the certiﬁ-
cate. Listing 5.2 shows the speciﬁcation of the extension, which contains ten
possible reasons. We explain the possible reasons.
unspeciﬁed
There is no particular reason for the revocation. RFC 5280
proposes to not include the reasonCode extension instead of using this entry.
keyCompromise
For end entity certiﬁcates only. The subject’s private key or
other security critical aspects regarding the subject are no longer secret or are
suspected to be compromised.
cACompromise
For CA certiﬁcates only. The subject’s private key or other
security critical aspects regarding the subject are no longer secret or are
suspected to be compromised.
afﬁliationChanged
The information on the subject is no longer correct. There
is no indication of a compromise.

5.2
Certiﬁcate Revocation Lists
79
superseded
There is a newer certiﬁcate replacing the one at hand. There is no
indication of a compromise.
cessationOfOperation
The certiﬁcate is not needed anymore. There is no
indication of a compromise.
certiﬁcateHold
The certiﬁcate is temporarily on hold and may be reactivated
later.
removeFromCRL
For use with delta CRLs only. The certiﬁcate is to be
removed from the CRL as the certiﬁcate is expired or is no longer on hold.
privilegeWithdrawn
A privilege contained in this certiﬁcate has been with-
drawn.
aACompromise
For attribute authority certiﬁcates only. The subject’s private
key or other security critical aspects regarding the subject are no longer secret
or are suspected to be compromised.
invalidityDate
This is the date when the event that makes revoking the certiﬁcate
necessary happened. It may be earlier than the revocation time speciﬁed in
revocationDate. For example, a key may be compromised some time before the
compromise is discovered by the user. Clearly, it is not meaningful for this date
to be later than the revocation date of the CRL entry.
certiﬁcateIssuer
This extension contains the distinguished name of the issuer of
the certiﬁcate revoked in this entry. Additionally, this entry may contain the issuer
alternative name. If this extension is absent in the ﬁrst entry of the CRL, then the
issuer of this revoked certiﬁcate is the issuer of the CRL. If this entry is absent in
any other entry of the CRL then the issuer of the revoked certiﬁcate is the issuer
of the previous entry. In this extension the same encoding must be used as in the
issuer distinguished name of the certiﬁcate.
5.2.2
CRL Extensions
Next, we describe possible CRL extensions. The extensions authority key identiﬁer,
issuer alternative name, and authority information access are the same as the
corresponding certiﬁcate extensions. They are discussed in Sects. 2.3 and 9.6.1
respectively. In addition, there are a few more extensions.
CRL Number CRLs are issued sequentially. After an initial CRL has been issued,
it is updated by issuing subsequent CRLs that contain newly revoked certiﬁcates
and (at least) all the previously revoked certiﬁcates that have not expired. The CRL
number allows organizing the CRLs by issuing time. The CRL number must not
be smaller than 0. Typically, the CRL number of the ﬁrst CRL is 0. Also, the CRL
number of a CRL must be larger than the CRL numbers of all previously issued
CRLs. If two CRLs happen to be issued at the same time by the same issuer, then
their CRL numbers must be identical. The CRL number extension is mandatory.

80
5
Revocation
IssuingDistributionPoint ::= SEQUENCE {
distributionPoint
[0] DistributionPointName OPTIONAL,
onlyContainsUserCerts
[1] BOOLEAN DEFAULT FALSE,
onlyContainsCACerts
[2] BOOLEAN DEFAULT FALSE,
onlySomeReasons
[3] ReasonFlags OPTIONAL,
indirectCRL
[4] BOOLEAN DEFAULT FALSE,
onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
Listing 5.3 Issuing distribution point extension
Delta CRL Indicator This extension indicates that the CRL is a delta CRL, which
means that it contains only the certiﬁcates that have been revoked after a previous
full CRL has been issued. If this extension is not present, then the CRL is a full CRL.
The delta CRL Indicator extension must be marked critical because applications
must be able to distinguish between full and delta CRLs.
The value of this extension is an integer. Using the delta CRL indicator, it is
possible to construct a full CRL from this delta CRL and the previous full CRL.
This is explained in more detail in Sect. 5.2.4.
Issuing Distribution Point The issuing distribution point extension allows speci-
fying the location of the CRL. It also supports partitioning of CRLs by limiting the
scope of the CRL. Listing 5.3 shows the speciﬁcation of this extension.
The distributionPoint ﬁeld speciﬁes the location of this CRL. It has the
format of CRL distribution points as explained in Sect. 5.3.1. If it is set, then it
must contain at least one of the distribution points contained in the certiﬁcate. This
enables a check that the location of this CRL matches the location where revocation
information about a certiﬁcate is expected. If it is not set, then all unexpired
certiﬁcates that are revoked within the scope of the CRL must be contained in it.
This prevents further partitioning of CRLs within the same scope.
The extension also allows limiting the scope of the CRL to certain types.
Possible types are certiﬁcates of end entities (onlyContainsUserCerts =
true), certiﬁcates of certiﬁcation authorities (onlyContainsCACerts = true),
and attribute certiﬁcates (onlyContainsAttributeCerts = true). There
must be no more than one type present in this extension. The extension may
also limit the reason of revocation of the certiﬁcates contained in the CRL. If the
onlySomeReasons ﬁeld is present, then the CRL only contains certiﬁcates that
are revoked for one of the reasons contained in this ﬁeld.
If present, the issuing distribution point extension must be marked critical. The
reason is that if an application is unable to evaluate this extension, then the status of
certiﬁcates not contained in the present CRL must be considered unknown since the
present CRL may only be a part of a partitioned CRL.
Freshest CRL This extension is sometimes also referred to as delta CRL
distribution point. It is used when delta CRLs are issued to incrementally
update full CRLs. It informs users where to locate the delta CRLs that are used

5.2
Certiﬁcate Revocation Lists
81
F0
F1
F2
F3
F4
t1
t2
t3
t4
t5
t6
t
Fig. 5.2 CRLs issued at regular time intervals
F0
F1
F2
F3
F4
F5
F6
F7
F8
F9
F10
F11
F12
t1
t2
t3
t4
t5
t6
t
Fig. 5.3 Over-issued CRLs
in conjunction with the complete CRL. The extension has the form of a CRL
distribution point extension as described in Sect. 5.3.1.
5.2.3
Issuing Time of a CRL
A very security-sensitive issue is the CRL issuing time. As we have seen, the issuing
time of the CRL is stored in the ﬁeld thisUpdate and the latest date at which the next
CRL is published is written into the nextUpdate ﬁeld. Many CRL issuers use a ﬁxed
time interval between thisUpdate and nextUpdate which can vary between a few
hours or days. This is depicted in Fig. 5.2.
If the nextUpdate ﬁeld is used, then a CRL must be issued not later than the time
indicated in this ﬁeld. This does not prohibit the CRL issuer from issuing CRLs
before the nextUpdate time. Such CRLs are called over-issued CRLs. The use of
those CRLs is depicted in Fig. 5.3.

82
5
Revocation
There are various reasons for using over-issued CRLs. One reason is to provide
immediate revocation information about individual certiﬁcates. Another reason is to
make CRL downloads more efﬁcient when a large number of downloads is expected.
The thisUpdate and nextUpdate dates for over-issued CRLs may be chosen such that
the time interval between them is ﬁxed. This is done in F 1  F 4 in Fig. 5.3. This
requires many CRLs to be issued, but supports reducing the download load of the
CRL repository. See also [2] for a further analysis on this method. As with full
CRLs, the nextUpdate ﬁeld is optional.
5.2.4
Delta CRLs
CRLs may become very large. Therefore, updating CRLs frequently, which is useful
from a security point of view, causes serious efﬁciency problems since large CRLs
have to be downloaded by the users frequently. A solution to this problem is delta
CRLs.
A delta CRL is a revocation list which only contains the certiﬁcates that have
been revoked after a certain complete CRL has been issued. This complete CRL
is called Base CRL for the delta CRL. Delta CRLs are small compared to their
base CRL. Users who have downloaded the Base CRL and an additional delta CRL
have timely revocation information without having to download many complete
CRLs.
We explain delta CRLs in more detail. Delta CRLs have the same ASN.1
speciﬁcation as X.509v2 CRLs. To indicate that a CRL is a delta CRL, the delta CRL
indicator (see Sect. 5.2.2) is used. This extension contains the CRL number of the
Base CRL. A delta CRL can be combined with its base or any other complete CRL
issued after the Base CRL, since such a CRL contains at least the same revocation
information as the Base CRL.
In order to provide complete revocation information, a delta CRL must satisfy the
following requirements with respect to its Base CRL or any complete CRL issued
after the Base CRL.
•
Complete CRL and delta CRL have the same issuer and the issuer uses the same
signature key.
•
Complete CRL and delta CRL have the same scope.
•
The Base CRL number indicated in the delta CRL is smaller than or equal to the
CRL number of the complete CRL.
•
The CRL number of the complete CRL is smaller than the CRL number of the
delta CRL.
There may be clients that are not able to process delta CRLs, for example if they
do not understand the critical delta CRL indicator extension. For supporting these
clients, CRL issuers can decide to issue a complete CRL with every delta CRL.

5.3
Certiﬁcate Extensions Related to Revocation
83
5.2.5
Authority Revocation List
Usually, CRLs contain certiﬁcates that belong to end entities and not to certiﬁcation
authorities. However, if it is necessary to revoke a CA certiﬁcate the issuer of the
CRL may decide to insert it into a CRL that is used exclusively to revoke CA
certiﬁcates. Such a revocation list is called an authority revocation list (ARL).
5.2.6
Indirect CRLs
Certiﬁcate issuers may decide to delegate revocation to a dedicated CRL issuer. For
example, there may be several certiﬁcate issuers in a PKI. However, for efﬁciency
and security reasons it is useful to have a single CRL issuer where the users can
obtain the full revocation information. Another reason for delegating revocation
is that the certiﬁcate issuer may not be able or willing to guarantee the required
response times or is even ofﬂine.
A CRL issued by a dedicated CRL issuer who is not the certiﬁcate issuer is
called indirect CRL. Issuers of indirect CRLs use a certiﬁcate with cRLSign as
key usage. The CRL entries of an indirect CRL use the extension certiﬁcateIssuer
(see Sect. 5.2.1) to inform the user about the issuer of the certiﬁcate. Moreover,
indirect CRLs are speciﬁed as indirect by setting the appropriate ﬂag in the issuing
distribution point extension as discussed in Sect. 5.2.2. The use of delta CRLs based
on indirect CRLs is permitted.
Unfortunately, not many applications are able to process indirect CRLs. There-
fore, indirect CRLs are not widely used.
5.3
Certiﬁcate Extensions Related to Revocation
We discuss certiﬁcate extensions that are used to support revocation.
5.3.1
CRL Distribution Points
When an application uses a certiﬁcate, it must check whether or not this certiﬁcate
has been revoked. When CRLs are used as a revocation mechanism, applications
need information on how to locate and download the relevant CRLs. This informa-
tion is contained in the CRL distribution points extension, which contains one or
more distribution points (see Listing 5.4). Each distribution point contains a URI
pointing to a location of a CRL. It also contains ﬁelds indicating which revocation
reasons the CRL covers. The extension may also contain the issuer of the CRL,
which is, for example, needed in indirect CRLs. For an example of such an extension
see Sect. 9.1.3.

84
5
Revocation
DistributionPoint ::= SEQUENCE {
distributionPoint
[0]
DistributionPointName OPTIONAL,
reasons
[1]
ReasonFlags OPTIONAL,
cRLIssuer
[2]
GeneralNames OPTIONAL }
DistributionPointName ::= CHOICE {
fullName
[0]
GeneralNames,
nameRelativeToCRLIssuer [1]
RelativeDistinguishedName }
Listing 5.4 CRL distribution point extension
5.4
OCSP
The advantage of CRLs is that applications can obtain the full revocation informa-
tion at predictable points in time. This means that the applications do not have to be
connected to the CRL issuer unless they wish to download a fresh CRL. But on the
other hand, CRLs may become very large, downloading them becomes extremely
time consuming, and storing may need a lot of space which may not be available, for
example in mobile devices. Also, due to the potentially long time intervals between
the publication of two subsequent lists, revocation information may not be up to
date when it is used, in particular, shortly before nextUpdate.
This is why the online certiﬁcate status protocol (OCSP) was invented. It allows
clients to query an OCSP server about the revocation status of individual certiﬁ-
cates. The OCSP method has certain advantages over the CRL method. First, the
revocation information has a chance to be always fresh. Users may obtain revocation
information immediately after the certiﬁcate is revoked. However, some servers just
query CRLs, which eliminates this advantage. Another advantage of OCSP is that it
does not require much storage. Only the revocation information about the certiﬁcate
under examination must be stored. On the other hand, in contrast to the CRL method,
OCSP requires the applications that need revocation information to be online.
OCSP is speciﬁed in RFC 2560 [8]. Many PKIs implement OCSP and many
clients are compliant with OCSP. As an example, Fig. 5.4 shows the conﬁguration
of an OCSP server in Firefox.
5.4.1
Functionality
We explain how OCSP works. OCSP clients send a request to an OCSP server about
the revocation status of one or more certiﬁcates. Optionally, the requests may be
digitally signed. For each certiﬁcate, the request submits the serial number of the
certiﬁcate, the hash value of the issuer’s DN, and the hash value of the issuer’s
public key. This information determines the certiﬁcates uniquely. Listing 5.5 shows
the ASN.1 speciﬁcation of an OCSP request.
The OCSP server replies to the request with three possible answers. If the status
of more than one certiﬁcate is requested, then the answer contains information about

5.4
OCSP
85
Fig. 5.4 Conﬁguration of an OCSP server in Firefox
the status of all certiﬁcates. The ﬁrst possible answer is revoked. This means that
the certiﬁcate has been previously revoked. The second possible answer is good.
It indicates that the certiﬁcate is not revoked. However, this answer does not mean
that the certiﬁcate is still valid. It may have expired. Also, the answer “good” does
not imply that the certiﬁcate exists. The third possible answer is unknown. This
answer means that the certiﬁcate is not known to the OCSP server and that it is
unable to give any answers about its status. If a protocol error has occurred, the
OCSP server answers with an error message which is not signed. Details about
OCSP responses are shown in Listing 5.6.
The meaning of thisUpdate and nextUpdate is analogous to the meaning
of the corresponding elements of a CRL, i.e. thisUpdate indicates when revocation
information has been updated by the OCSP server and nextUpdate refers to the
latest date at which the revocation will be updated again. The time when the answer
is signed is contained in the producedAt element. The reason for this information
is that OCSP servers may prepare their answers in advance and use them later. If the

86
5
Revocation
OCSPRequest
::=
SEQUENCE {
tbsRequest
TBSRequest,
optionalSignature
[0]
EXPLICIT Signature OPTIONAL }
TBSRequest
::=
SEQUENCE {
version
[0]
EXPLICIT Version DEFAULT v1,
requestorName
[1]
EXPLICIT GeneralName OPTIONAL,
requestList
SEQUENCE OF Request,
requestExtensions
[2]
EXPLICIT Extensions OPTIONAL }
Request
::=
SEQUENCE {
reqCert
CertID,
singleRequestExtensions
[0] EXPLICIT Extensions OPTIONAL }
CertID
::=
SEQUENCE {
hashAlgorithm
AlgorithmIdentifier,
issuerNameHash
OCTET STRING,
issuerKeyHash
OCTET STRING,
serialNumber
CertificateSerialNumber }
Listing 5.5 Elements of an OCSP request
producedAt time is unacceptable, clients may choose to download a fresher CRL
instead.
OCSP servers may be operated by various authorities. An obvious choice is the
certiﬁcate issuer. However, this may be a security risk if the signature key used to
sign OCSP replies is the same as the signature key used for signing certiﬁcates. It is
also possible to establish a dedicated OCSP service (at the issuer’s site or at any
other site) with a distinct DN which is different from the certiﬁcate issuer’s DN.
This OCSP service must have a certiﬁcate of the issuer with the extended key usage
extension set to the value OCSPsigning, which has the OID 1.3.6.1.5.5.7.3.9.
Applications that use OCSP must be able to decide whether the certiﬁcate of the
OCSP server is revoked or not. It is possible to check the validity of the OCSP server
certiﬁcate by inspecting a CRL. However, this reduces the efﬁciency advantage of
OCSP. Another approach is to make the OCSP server certiﬁcate permanently valid
by adding the extension ocsp-nocheck to it and choosing a short validity period
for its certiﬁcate.
5.4.2
Extensions
It is possible for clients and servers to add extensions to their OCSP requests
and responses. An overview over these extensions and their OIDs is presented in
Table 5.1. This table also shows whether servers or clients can set the extensions.
We explain the meaning of the extensions.

5.4
OCSP
87
OCSPResponse ::= SEQUENCE {
responseStatus
OCSPResponseStatus,
responseBytes
[0] EXPLICIT ResponseBytes OPTIONAL }
ResponseBytes ::= SEQUENCE {
responseType
OBJECT IDENTIFIER,
response
OCTET STRING }
BasicOCSPResponse
::= SEQUENCE {
tbsResponseData
ResponseData,
signatureAlgorithm
AlgorithmIdentifier,
signature
BIT STRING,
certs
[0] EXPLICIT SEQUENCE OF Certificate
OPTIONAL }
ResponseData ::= SEQUENCE {
version
[0] EXPLICIT Version DEFAULT v1,
responderID
ResponderID,
producedAt
GeneralizedTime,
responses
SEQUENCE OF SingleResponse,
responseExtensions
[1] EXPLICIT Extensions OPTIONAL }
SingleResponse ::= SEQUENCE {
certID
CertID,
certStatus
CertStatus,
thisUpdate
GeneralizedTime,
nextUpdate
[0]
EXPLICIT GeneralizedTime OPTIONAL,
singleExtensions
[1]
EXPLICIT Extensions OPTIONAL }
CertStatus ::= CHOICE {
good
[0]
IMPLICIT NULL,
revoked
[1]
IMPLICIT RevokedInfo,
unknown
[2]
IMPLICIT UnknownInfo }
Listing 5.6 Elements of an OCSP response
Table 5.1 Extensions for use in OCSP
Name
OID
Included by
Nonce
1.3.6.1.5.5.7.48.1.2
Client & server
CRL references
1.3.6.1.5.5.7.48.1.3
Server
Acceptable response types
1.3.6.1.5.5.7.48.1.4
Client
Archive cutoff
1.3.6.1.5.5.7.48.1.6
Server
CRL entry extensions
2.5.29.21, 2.5.29.24, 2.5.29.29
Server
Service locator
1.3.6.1.5.5.7.48.1.7
Client

88
5
Revocation
Nonce This extension is used to prevent replay attacks. The client sends a random
value to the server. The server must include this value in its answer.
CRL References This extension points to the CRL where a revoked or suspended
certiﬁcate can be found. This entry may contain the URL where the CRL can be
found, the CRL number, or the issuing time of the CRL.
Acceptable Response Types There can be several types of OCSP answers. By
using this extension in an OCSP request, clients indicate which types of response
they are able to process. RFC 2560 [8] deﬁnes the basic response type for OCSP,
which is expected to be supported by all servers and clients.
Archive Cutoff The archive cutoff is used to indicate whether a digital signature
was valid when it was produced, even if the respective certiﬁcate is expired at the
veriﬁcation time. For that, OCSP responders need to retain revocation information
on a certiﬁcate beyond the actual expiration date of the certiﬁcate. The retention
interval indicates how long the OCSP server keeps revocation information after
certiﬁcate expiration. After that interval, the OCSP responder does not have any
information about the certiﬁcate’s revocation history, and might declare revoked
certiﬁcates as good (which is compliant to the deﬁnition of possible OCSP
responses).
The archive cutoff is a value that indicates whether or not the OCSP responder
still holds revocation information on the certiﬁcate in question. The actual value of
the archive cutoff depends on the time the OCSP response is created, and therefore
has to be calculated for each response. The value is obtained by subtracting the
OCSP responder’s retention interval from the date indicated by the producedAt
element of the response.
The value of archive cutoff is a date that is used by the client to determine, via
comparison with the certiﬁcate expiration date, the quality of the OCSP response.
As long as the archive cutoff date is before the certiﬁcate expiration date, the OCSP
response for a revoked certiﬁcate will be “revoked”, even if the validation time is
after the certiﬁcate expiration time. If the archive cutoff date is after the certiﬁcate
expiration date, the OCSP response may be “good” although it has been revoked
before the signature in question was generated.
CRL Entry Extensions All extensions of a CRL entry can also be included in the
OCSP requests and answers. For example, the server may provide the invalidity date
of a certiﬁcate or the reason for the revocation. See Sect. 5.2.1 for a description of
these extensions.
Service Locator OCSP servers may operate as proxy servers for other OCSP
servers. In this extension of the OCSP request, the OCSP server is informed about
the location of the OCSP server which is responsible for answering OCSP requests
concerning the certiﬁcate in the request.

5.5
Other Revocation Mechanisms
89
5.4.3
Lightweight OCSP
OCSP servers that are responsible for answering requests for many certiﬁcates
may run into efﬁciency problems in regard to bandwidth and computing power.
This is even more likely in mobile application environments where bandwidth and
computing power is limited. This is why a lightweight variant of the OCSP protocol
was proposed in [4].
This OCSP variant reduces the options for OCSP requests in order for them to
be evaluated much more efﬁciently. For example, requests must not ask about more
than one certiﬁcate, they must use SHA1 to hash public key and issuer name and
must not use extensions. Responses must contain the basic OCSP response and it is
recommended that they contain only one response and no extensions.
5.4.4
Design of an OCSP Server
When designing an OCSP server, it must be decided how the server obtains
revocation information. One possibility for the OCSP server is to extract the
revocation information from a CRL. If a certiﬁcate in a request is contained in
the CRL, then the OCSP server answers “revoked”. When using this strategy, the
OCSP information is not fresher then the CRL information, which eliminates one
of the advantages of OCSP: fresher revocation information. However, the OCSP
revocation information is still much smaller than the CRL revocation information.
An alternative approach is to send revocation information concerning individual
certiﬁcates directly to the OCSP server. In this case, the OCSP server answers
“revoked” whenever it has such revocation information. This solution offers much
better timeliness than using CRLs.
If the OCSP server has no revocation information that justiﬁes the answer
“revoked”, it must choose between “good” and “unknown”. Again, different policies
are possible. One possibility is that the OCSP server answers “good” if it has
access to revocation information from the issuer of the certiﬁcate in the request and
“unknown” otherwise. However, some OCSP servers are more restrictive. They only
answer “good” if they are convinced of the existence of the certiﬁcate contained in
the request. For example, they may have access to a database containing all existing
certiﬁcates.
5.5
Other Revocation Mechanisms
5.5.1
Novomodo
A special method of revocation was proposed in [6]. This method is called
Novomodo and works as follows. With each certiﬁcate they create, CAs generate

90
5
Revocation
two random strings X0 and Y0 which remain secret. In addition to their standard
content, certiﬁcates have two additional ﬁelds. The ﬁrst ﬁeld contains the hash value
Y1 of Y0 and the second ﬁeld contains the hash value X365 obtained by hashing X0
365 times.
As long as a certiﬁcate is not revoked, the CA publishes the value X365i obtained
by hashing X0 365  i times on the ith day of the certiﬁcate’s validity. Applications
that wish to evaluate the revocation status of a certiﬁcate on the ith day of its validity,
hash the value X365i i times. If the result matches X365, then the certiﬁcate is valid.
In order to revoke a certiﬁcate, the CA publishes Y0. Then all applications can verify
for themselves that the certiﬁcate has been revoked by comparing the hash value of
Y0 to Y1.
The authenticity of Y1 and X365 is protected by the signature of the certiﬁcate.
An optimization of this scheme uses hash trees. It reduces the number of hash value
evaluations. It has been presented in [5].
5.5.2
Short-Lived Certiﬁcates
Revocation can be avoided if the validity of the certiﬁcate is very short, for example,
1 day. Even if revocation turns out to be necessary during the short validity period of
the certiﬁcate, revoking it is of no use since the certiﬁcate expires very soon anyway
and all revocation methods have a considerable revocation delay. In [7], short-lived
certiﬁcates are discussed and analyzed. A special variant of this method is proposed
in [9], where certiﬁcates are issued on demand. For example, CV certiﬁcates are
short-lived certiﬁcates.
5.6
Revocation in PGP
There is no central revocation mechanism such as CRLs in PGP. Instead, owners of
public keys can revoke their keys themselves by creating a signed statement which
asserts that this key is revoked. This statement is sometimes called a revocation
certiﬁcate. The revocation certiﬁcate is signed using the standard user signature
key. As with the normal certiﬁcation of the user ID and public key, a signature is
calculated over this data (see Sect. 2.6). This signature however is of another type
than the certiﬁcation signature. It has another value in the type octet of the signature
and therefore this certiﬁcate can be recognized as a revocation.
For revoking a PGP certiﬁcate, the user may send it directly to communication
partners or upload it to the key servers used in PGP. The other users then need to
import the revocation certiﬁcate to their key ring to mark the certiﬁcate as revoked.
Typically, the PGP revocation certiﬁcate is created immediately after the key
generation. This is because the key that is needed to sign the revocation certiﬁcate
may not be available at the time of the actual revocation. For example, a user may

5.7
Exercises
91
t
4
6
7
1
9
14
3
22
5
01-01
01-08
01-15
01-22
02-01
02-08
02-15
02-22
03-01
03-08
F
D
D
D
F;D
D
D
D
F;D
D
Fig. 5.5 Revocation in the course of time
Table 5.2 CRL numbers and Base CRLs
CRL
CRL number
Base CRL number
Complete CRL at 01-01
Delta CRL at 01-15
Complete CRL at 02-01
Delta CRL at 02-01
Delta CRL at 02-08
Delta CRL at 03-08
have forgotten the password required for unlocking the key or may have lost the key.
The revocation certiﬁcate must be protected in order to prevent unauthorized users
from revoking the key.
5.7
Exercises
5.1.
Check whether a user has all the revocation information contained in the full
CRL F 14 when one of the following sets of full CRLs F and delta CRLs  is given.
Here, the delta CRL j with Base CRL i is denoted by j
i .
1. fF 1; 5
1; 10
5 ; 12
10; 15
10g
2. fF 1; 5
1; F 5; F 12; 14
10g
3. fF 1; 5
2; 10
5 ; 14
12; 15
10g
5.2. A CA starts its operation on 1 December 2011. As revocation mechanism the
CA uses CRLs whose scope is all certiﬁcates. The CA issues one complete CRL at
the beginning of each month. The ﬁrst complete CRL is issued on 1 January 2012.
It contains 12 revoked certiﬁcates. In addition, the CA issues delta CRLs on the 1st,
on the 8th, on the 15th, and on the 22nd of each month. The Base CRL for the delta
CRLs is the freshest complete CRL that was issued previously. For example, the
Base CRL of the delta CRL issued on 1 February 2012 is the full CRL issued on
1 January 2012.
Figure 5.5 shows several CRL issuing dates in 2012 and revoked certiﬁcates. For
example, between 8 January and 15 January, six certiﬁcates were revoked.
1. What is the CRL number (2 Œ0; 9) and the Base CRL number of the CRLs
given in Table 5.2. Select the numbers such that the numbering of the CRLs is
consistent.
2. Which complete CRL has the most CRL entries? How many?

92
5
Revocation
CRL A
Issuer:
CA1
ThisUpdate:
NextUpdate:
Revoked Certiﬁcates:
Serial No.:
...
X509v2 CRL Extensions:
CRL Number: non-critical
143
CRL B
Issuer:
CA1
ThisUpdate:
NextUpdate:
Revoked Certiﬁcates:
Serial No.:
64
Serial No.:
128
X509v2 CRL Extensions:
CRL Number:
non-critical
143
Delta CRL Indicator:
critical
Base CRL Number: 138
Fig. 5.6 CRLs A and B with missing ThisUpdate and NextUpdate values
CRL C
Issuer:
CA1
ThisUpdate:
NextUpdate:
Revoked Certiﬁcates:
Serial No.:
32
Serial No.:
16
X509v2 CRL Extensions:
CRL Number: non-critical
138
Fig. 5.7 CRL C with missing ThisUpdate and NextUpdate values
CRL D
Issuer:
CA1
ThisUpdate:
2011-10-15
NextUpdate:
2011-11-01
Revoked Certiﬁcates:
Serial No.:
456
X509v2 CRL Extensions:
CRL Number:
non-critical
Delta CRL Indicator:
critical
Base CRL Number:
CRL E
Issuer:
CA1
ThisUpdate:
2011-10-15
NextUpdate:
2011-11-15
Revoked Certiﬁcates:
Serial No.:
232
Serial No.:
136
Serial No.:
164
Serial No.:
987
Serial No.:
456
X509v2 CRL Extensions:
CRL Number: non-critical
Fig. 5.8 CRLs with missing CRL number and Base CRL number values
3. Which delta CRL has the most CRL entries? How many?
4. A user has downloaded all delta CRLs. Which complete CRLs does this client
need in order to have complete revocation information on 3 March?
5.3. The issuer with DN “CN D CA1” publishes revocation information in the form
of CRLs and delta CRLs (for the scope “all certiﬁcates that this CA issues”).
1. Enter the thisUpdate and nextUpdate values of the CRLs A, B, and C (shown in
Figs. 5.6 and 5.7) that allow for consistency among the CRLs if no two complete

5.7
Exercises
93
CRL A
Issuer:
CN=First CA, C=DE
ThisUpdate:
2011-04-25
NextUpdate:
2011-05-25
Revoked Certiﬁcates:
Serial No.:
1
Serial No.:
2
Serial No.:
3
Certiﬁcate Issuer: CN=Second CA, C=DE
Serial No.:
4
Serial No.:
5
Serial No.:
6
Certiﬁcate Issuer: CN=Third CA, C=DE
Serial No.:
7
Certiﬁcate Issuer: CN=Forth CA, C=DE
X509v2 CRL Extensions:
CRL Number: non-critical
500
Fig. 5.9 An indirect CRL
Table 5.3 Revoked
certiﬁcates
Issuer
Serial number
Revoked
CN D First CA, C D DE
1
CN D First CA, C D DE
2
CN D First CA, C D DE
3
CN D First CA, C D DE
4
CN D First CA, C D DE
5
CN D Second CA, C D DE
1
CN D Second CA, C D DE
2
CN D Second CA, C D DE
3
CN D Second CA, C D DE
4
CN D Second CA, C D DE
5
CN D Second CA, C D DE
6
CN D Third CA, C D DE
6
CN D Third CA, C D DE
7
CN D Forth CA, C D DE
6
CN D Forth CA, C D DE
7
CRLs are issued on the same date and the permitted dates are 2011-08-10, 2011-
08-15, and 2011-09-10. In addition, enter the serial numbers of the revoked
certiﬁcates of CRL A.
2. Can a delta CRL contain more certiﬁcates than its Base CRL? Give a reason for
your answer.
3. Consider the CRLs D and E shown in Fig. 5.8. Choose appropriate CRL Number
and Base CRL Number values from f234; 321; 333g.
5.4. Consider the indirect CRL shown in Fig. 5.9. Enter the values “true” or “false”
in the column “revoked” of Table 5.3 that indicate whether a certiﬁcate is revoked
or not.

94
5
Revocation
References
1. A. Årnes, M. Just, S.V. Knapskog, S. Lloyd, H. Meijer, Selecting revocation solutions for PKI,
in Proceedings of NORDSEC 2000 Fifth Nordic Workshop on Secure IT Systems, 2000. http://
www.pvv.ntnu.no/~andrearn/certrev/
2. D.A. Cooper, A model of certiﬁcate revocation, in Proceedings of the 15th Annual Computer
Security Applications Conference (ACSAC’99), Scottsdale, 1999, pp. 256–264
3. D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 5280, May 2008
4. A. Deacon, R. Hurst, The lightweight online certiﬁcate status protocol (OCSP) proﬁle for
high-volume environments, in IETF Request for Comments, 5019, Sept 2007
5. F.F. Elwailly, C. Gentry, Z. Ramzan, QuasiModo: efﬁcient certiﬁcate validation and revocation,
in Proceedings of the 7th International Workshop on Theory and Practice in Public Key
Cryptography, PKC 2004, Singapore, 2004. Volume 2947 of Lecture Notes in Computer
Science, pp. 375–388
6. S. Micali, Novomodo – scalable certiﬁcate validation and simpliﬁed PKI management, in
Online Proceedings of the 1st Annual PKI Research Workshop, 2002. http://www.cs.dartmouth.
edu/~pki02/
7. M. Myers, Revocation: options and challenges, in Proceedings of Financial Cryptography,
Second International Conference, FC’98, Anguilla, 1998. Volume 1465 of Lecture Notes in
Computer Science, pp. 165–171
8. M. Myers, R. Ankney, A. Malpani, S. Galperin, C. Adams,
X.509 Internet public key
infrastructure online certiﬁcate status protocol – OCSP, in IETF Request for Comments, 2560,
June 1999
9. K. Scheibelhofer, PKI without revocation checking, in Online Proceedings of the 4th Annual
PKI R&D Workshop, Apr 2005. http://middleware.internet2.edu/pki05/proceedings/

Chapter 6
Validity Models
In this chapter we deal with validity models for digital signatures in the hierarchical
trust model. In order to explain what we mean by this, we start with an example.
Paul sells his house to Anna on 1 October 2009. Paul signs the sales contract
digitally. The certiﬁcate that authenticates Paul’s signature veriﬁcation key expires
on 31 July 2010. Should Paul’s signature still be considered valid after the certiﬁcate
has expired? In the most common validity models, for example in the shell model
from the PKIX standard, the answer is “no”. This does not seem to make much sense
since the transaction is still valid. Therefore, the German signature law requires an
electronic signature to be valid independent of the expiration of the certiﬁcate as
long as the certiﬁcate was valid at the time the signature was created. This so-called
chain model is a completely different validity model for signatures. In this chapter
we discuss the various validity models for digital signatures in more detail.
6.1
The Shell Model
In this section we describe the shell model. It is proposed in RFC 5280 (Sect. 6
of [1]) and used in the certiﬁcation path validation algorithm described in Sect. 9.4.1.
The model is shown in Fig. 6.1.
We explain under what conditions a signature is valid in the shell model. Suppose
that Alice has signed a document. Bob wishes to verify this signature. Denote by
C0; C1; : : : ; Cn, n 2 N, the certiﬁcation path that is used by Bob to verify the
authenticity of Alice’s veriﬁcation key. Here, C0 is a certiﬁcate for the corresponding
veriﬁcation key. In the shell model, Alice’s signature is valid if and only if at
veriﬁcation time all certiﬁcates in the certiﬁcation path C0; : : : ; Cn are valid. This
means that in the shell model the signature becomes invalid as soon as any of the
certiﬁcates in the path expires or is revoked.
Example 6.1. Consider the three certiﬁcates shown in Fig. 6.2:
Suppose Alice signed a document on 2011-06-15. According to the shell model,
this signature is valid on 2011-08-01 because all certiﬁcates in the chain are valid.
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__6, © Springer-Verlag Berlin Heidelberg 2013
95

96
6
Validity Models
time
Root
Certificate
CA
Certificate
End user
Certificate
Signature creation
Signature verification
Fig. 6.1 The shell model
Certiﬁcate 1
Serial No.: 1
Issuer:
CN=Root-CA
NotBefore: 2011-01-01
NotAfter:
2011-12-31
Subject:
CN=Root-CA
Public Key: key-0x654121
X509v3Extensions:
Subject Key Identiﬁer:
keyId: 12:AB:45:76:F8:98
Authority Key Identiﬁer:
keyId: 12:AB:45:76:F8:98
Certiﬁcate 2
Serial No.: 12
Issuer:
CN=Root-CA
NotBefore: 2011-03-01
NotAfter:
2012-02-28
Subject:
CN=Sub-CA
Public Key: key-0x943566
X509v3Extensions:
Subject Key Identiﬁer:
keyId: CA:53:91:2A:E6:22
Authority Key Identiﬁer:
keyId: 12:AB:45:76:F8:98
Certiﬁcate 3
Serial No.: 12
Issuer:
CN=Sub-CA
NotBefore: 2011-05-01
NotAfter:
2012-04-30
Subject:
CN=Alice
Public Key: key-0x567812
X509v3Extensions:
Subject Key Identiﬁer:
keyId: 2D:B8:8F:2F:64:48
Authority Key Identiﬁer:
keyId: CA:53:91:2A:E6:22
Fig. 6.2 Certiﬁcates in the shell model
The signature is invalid on 2012-02-01 because Certiﬁcate 1 has expired. Likewise,
the signature is invalid on 2012-06-05 because Certiﬁcates 1 and 2 have expired.
Figure 6.3 illustrates this example.
Today, the shell model is the one used everywhere on the Internet. This is
appropriate in all applications where signing and veriﬁcation times are very close
to each other. Examples of such applications are challenge-response authentication
mechanisms or email authentication. However, for contract signing this model
appears to be inappropriate. Signatures that prove the authenticity of a contract

6.2
The Chain Model
97
time
2011-12-31
2012-02-28
2011-01-01
2011-03-01
Certificate 1
Certificate 2
2012-02-01
2011-05-01
2012-04-30
Certificate 3
2012-06-05
Signature creation
Signature verification
2011-06-15
invalid
invalid
2011-08-01
valid
Fig. 6.3 Veriﬁcation of a signature according to the shell model
are expected to prove this authenticity much longer than the validity period of the
certiﬁcates in the corresponding veriﬁcation path. This is why the chain model,
which is explained in the next section, has been introduced.
6.2
The Chain Model
We now explain the chain model (Fig. 6.4).
As in the last section, suppose that Alice has signed a document, Bob wishes to
verify this signature, and C0; C1; : : : ; Cn, n 2 N is the certiﬁcation path that is used
by Bob to verify the authenticity of Alice’s veriﬁcation key. In the chain model,
Alice’s signature is valid if and only if all certiﬁcates in the corresponding chain
were valid when the private keys corresponding to the keys that they certify were
used for signing. More precisely, Ci certiﬁes the veriﬁcation key for the signature
on Ci1, 1  i  n. The certiﬁcate Ci must be valid when Ci1 is signed. In
addition, C0 is the certiﬁcate for the veriﬁcation key for Alice’s signature. Also this
certiﬁcate must be valid when Alice issues her signature. This means that in contrast
to the shell model, in the chain model the validity of a signature is independent of
the veriﬁcation time for this signature.
Example 6.2. Consider the three certiﬁcates from Example 6.1 and Fig. 6.5:
Any document that Alice signs between 2011-05-01 and 2012-04-30 is valid in
the chain model because her certiﬁcate (Certiﬁcate 3) is valid at signature time. The
signature on Certiﬁcate 3 is valid because at its issuing time Certiﬁcate 2 was valid.
Likewise, Certiﬁcate 2 was valid because at its issuing time Certiﬁcate 1 was valid.
Therefore, the signature created on 2011-06-15 is valid both on 2012-02-01
and 2012-06-05. However, the signature created on 2012-05-12 is invalid because
Alice’s certiﬁcate is expired.

98
6
Validity Models
time
Root
Certificate
CA
Certificate
End user
Certificate
Signature creation
Signature verification
Fig. 6.4 The chain model
time
2011-12-31
2012-02-28
2011-01-01
2011-03-01
Certificate 1
Certificate 2
2012-02-01
2011-05-01
2012-04-30
Certificate 3
2012-05-12
Signature creation
Signature verification
2011-06-15
2012-06-05
Fig. 6.5 Veriﬁcation of a signature according to the chain model
The chain model is used in Germany for verifying legally binding electronic
signatures because such signatures may be used for contract signing.
The chain model supports long validity periods for digital signatures. However, it
has certain drawbacks. If Alice issues a signature and later a certiﬁcate in the chain
that certiﬁes Alice’s veriﬁcation key is revoked, the signature remains valid. This
may have serious effects if the revocation reason is key compromise.
6.3
The Modiﬁed Shell Model
We now explain the modiﬁed shell model, which is also called hybrid model. It
is a mixture of the chain and the shell models and is implicitly mentioned in
RFC 5126 [2].
In the modiﬁed shell model, which is shown in Fig. 6.6, an end user signature is
valid if it is valid in the shell model at creation time. This means that at creation time
of the end user signature, all certiﬁcates in the relevant certiﬁcation path must be
valid. Thus, the validity of an end user signature is independent of the veriﬁcation

6.3
The Modiﬁed Shell Model
99
time
Root
Certificate
CA
Certificate
End user
Certificate
Signature creation
Signature verification
Fig. 6.6 The modiﬁed shell model aka hybrid model
time
2011-12-31
2012-02-28
2011-01-01
2011-03-01
Certificate 1
Certificate 2
2012-02-01
2011-05-01
2012-04-30
Certificate 3
2012-06-05
Signature creation
Signature verification
2011-06-15
Fig. 6.7 Veriﬁcation of a signature according to the modiﬁed shell model
time for that signature. This allows such a signature to be valid for a very long
time. However, in contrast to the chain model, the validity of the end user signature
is independent of the creation time of certiﬁcate signatures. This makes signature
veriﬁcation much simpler. Also, this implies that none of the certiﬁcates in the
relevant certiﬁcation path must be expired or revoked at the time of the creation of
the end user signature. However, expiration or revocation of one of the certiﬁcates
in the certiﬁcation path after signature generation has no inﬂuence on the signature
validity. As in the chain model, this may be problematic, for example, if such a
certiﬁcate has been revoked because of key compromise.
Example 6.3. Consider the three certiﬁcates from Example 6.1 and Fig. 6.7.
Any document that Alice signs between 2011-05-01 and 2011-12-31 is valid in
the modiﬁed shell model because all three certiﬁcates in the certiﬁcation path are
valid at signature time.
One application of the modiﬁed shell model is advanced electronic signatures as
speciﬁed in RFC 5126 [2]. These signatures are used for long-term scenarios. This
speciﬁcation proposes time-stamping a digitally signed document directly after it is
digitally signed—as a proof of existence of the document—including its signature at

100
6
Validity Models
Certiﬁcate A
Serial No.: 1
Issuer:
RootCA
NotBefore: 2010-01-01
NotAfter:
2012-05-31
Subject:
RootCA
Public Key: key-0x75590812
X509v3Extensions:
Subject Key Identiﬁer:
keyId: 0A:32:F0:35:5F:3F
Authority Key Identiﬁer:
keyId: 0A:32:F0:35:5F:3F
Certiﬁcate B
Serial No.: 3
Issuer:
RootCA
NotBefore: 2010-03-01
NotAfter:
2012-03-31
Subject:
SubCA
Public Key: key-0xAB328602
X509v3Extensions:
Subject Key Identiﬁer:
keyId: 60:43:6C:E5:9C:88
Authority Key Identiﬁer:
keyId: 0A:32:F0:35:5F:3F
Certiﬁcate C
Serial No.: 5
Issuer:
SubCA
NotBefore: 2010-05-01
NotAfter:
2012-07-31
Subject:
Alice
Public Key: key-0x11FE3665
X509v3Extensions:
Authority Key Identiﬁer:
keyId: 60:43:6C:E5:9C:88
Fig. 6.8 Certiﬁcates used in different validity models
Table 6.1 Validation in different models
Signature creation time
Shell model
Modiﬁed shell model
Chain model
2010-04-20
2011-03-15
signature generation time. Moreover, the speciﬁcation proposes time-stamping the
relevant certiﬁcation path and the corresponding revocation information. Another
application of the modiﬁed shell model is described in [3].
6.4
Exercises
6.1. In Fig. 6.8, three certiﬁcates are given.
1. Alice signs a document on 2010-04-20 and 2011-03-15. Enter the result of the
signature validation on 2012-01-01 into Table 6.1. Possible values are valid or
invalid.
2. Alice signs a document on 2011-03-15, 2012-05-24, 2012-07-08, and 2012-10-
19. Enter the result of the signature validation on 2013-01-01 into Table 6.2.
Possible values are valid or invalid.
3. Specify the time period in which Alice can create a valid signature for the
different validity models. Enter the values into Table 6.3.

References
101
Table 6.2 Validation for different signature times
Signature creation time
Shell model
Modiﬁed shell model
Chain model
2011-03-15
2012-05-24
2012-07-08
2012-10-19
Table 6.3 Valid signature creation times
Model
From
Until
Shell
Modiﬁed shell
Chain
References
1. D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 5280, May 2008
2. D. Pinkas, N. Pope, J. Ross, CMS advanced electronic signatures (CAdES), in IETF Request
for Comments, 5126, Feb 2008
3. U. Resnitzky, The directory-enabled PKI appliance: digital signatures made simple, approach
and real world experience, in 6th Annual PKI R&D Workshop, Gaithersburg, Apr 2007. http://
middleware.internet2.edu/pki07/proceedings/

Chapter 7
Certiﬁcation Service Provider
In Chap. 3 we explain the hierarchical trust model for PKIs. In this trust model,
certiﬁcation authorities that issue certiﬁcates play an important role. However,
issuing certiﬁcates is not sufﬁcient. The certiﬁcates must be maintained and
additional information must be provided during the entire life cycle. The entity that
is responsible for certiﬁcate life cycle management is called the certiﬁcation service
provider (CSP). A CA is only one component of a CSP. Another component is the
registration authority (RA), which registers certiﬁcate applicants and collects all
information relevant for issuing certiﬁcates. Other possible components of a CSP
are, for example, a directory service, which publishes information concerning cer-
tiﬁcates, and a revocation service, which issues revocation information. Sometimes,
certiﬁcation service providers are also called trust centers. In this chapter, we start
by explaining the life cycle of a certiﬁcate. Then, we describe the CSP components.
In the next chapter, we discuss certiﬁcate policies that govern the operation of CSPs
in a PKI.
7.1
Certiﬁcate Life Cycle
Certiﬁcate life cycles may vary according to the organization of a PKI and the
certiﬁcate usage. Here, we describe a typical certiﬁcate life cycle. It can be divided
into three phases.
7.1.1
Certiﬁcate Generation Phase
The certiﬁcate life cycle starts with a certiﬁcate application by some entity. This
entity may be the intended owner of the certiﬁcate or some other authorized entity,
for example, someone who is responsible for IT security in some institution of which
the intended certiﬁcate owner is an employee. The application is followed by the
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__7, © Springer-Verlag Berlin Heidelberg 2013
103

104
7
Certiﬁcation Service Provider
registration of the intended certiﬁcate holder. In the registration, the information
relevant for issuing the certiﬁcate is collected and veriﬁed. This information
typically includes the name of the intended certiﬁcate owner and some contact
information such as an email address. It may also include the public key to be
contained in the certiﬁcate if the corresponding key pair is generated by the intended
user. After application and registration, the certiﬁcate is issued. If the key pair is not
generated by the certiﬁcate applicant, the key pair is generated by a trusted third
party such as the card manufacturer or the CSP while issuing the certiﬁcate. The CSP
creates the certiﬁcate and signs it digitally. The CSP may also back up the private
key corresponding to the public key in the certiﬁcate. For example, this is useful for
decryption keys. For such keys, a backup prevents encrypted data from becoming
inaccessible in the case where the private key owner loses the private decryption
key. However, key backup opens security risks since the CSP has knowledge of
private keys and with this knowledge the power to decrypt information of its users.
Once a certiﬁcate is issued, it is delivered to and accepted by its owner. Without
owner acceptance the certiﬁcate must not be used since it may contain incorrect
information. The ﬁnal step of the generation phase is publication of the certiﬁcate
since it is intended to be used by many entities for establishing trust in the public
key in the certiﬁcate belonging to the certiﬁcate owner.
7.1.2
Certiﬁcate Validity Phase
The main purpose of a certiﬁcate is to prove that the public key contained in the
certiﬁcate belongs to the certiﬁcate owner. To this end, the certiﬁcate is retrieved
from some directory. This may be a local directory of the user or a directory
operated by some directory service. The certiﬁcate user validates the certiﬁcate,
which includes verifying the certiﬁcate signature and checking the validity period
of the certiﬁcate and its revocation status. But certiﬁcate validation may be much
more involved. For example, if the certiﬁcate is an element of a certiﬁcate chain, the
validity of the full chain must be checked. This is explained in Chap. 9.
When a certiﬁcate expires, the subject in the certiﬁcate may want to continue
using the public key, for example, if he or she wants the smart card containing
the corresponding private key to remain usable. In such a case, the certiﬁcate may
be reissued before it expires. The re-issued certiﬁcate has the same content as the
original certiﬁcate and a new expiration date.
7.1.3
Certiﬁcate Invalidity Phase
Typically, certiﬁcates have a limited validity period. For example, the validity of
an X.509 certiﬁcate ends on the notAfter date in the certiﬁcate. Another way of
invalidating certiﬁcates is to revoke them before they expire. Revocation is discussed
in Chap. 5.

7.2
Registration Authority
105
When the certiﬁcate of an encryption key is invalid, the corresponding public key
must not be used anymore for encryption. Likewise, private keys corresponding to
public keys of expired certiﬁcates must not be used to generate signatures anymore.
However, frequently, the certiﬁcate cannot simply be deleted. In the chain and
modiﬁed shell signature validity models, expired certiﬁcates may still be required
for authenticating signature veriﬁcation keys. Also, in long-term authentication pro-
tocols, even revoked certiﬁcates may have to be used. Therefore, invalid certiﬁcates
may have to be archived.
7.2
Registration Authority
In the certiﬁcate generation phase, registration is a very important process in which
the data necessary for generating certiﬁcates are collected and validated. This
process is taken care of by a dedicated component of the CSP, the registration
authority. Reasons for operating a separate registration authority may be found in
App. A of [2]. For example, these are security reasons. Registration requires a lot of
interaction with PKI users, while certiﬁcate issuance is the task of a few operators
and must be protected from interference by unauthorized persons.
Registration is a complex process which may be implemented in various ways
depending on operational and security requirements. We explain important steps of
the registration process.
Registration starts with establishing the identity of the intended certiﬁcate owner.
If the intended owner is a person, then the following information may be collected:
ﬁrst and last name, citizenship, place and date of birth, email address, employer,
and biometric data such as ﬁngerprints. This is more information than actually
will be contained in the certiﬁcate. It serves several other purposes. For example,
it allows the registration authority to decide whether the intended certiﬁcate owner is
eligible to apply for a certiﬁcate. This data may be collected online or the certiﬁcate
applicant may be required to register in person and to present some proof of identity
such as an identity card. The data may also be retrieved from existing databases.
In addition, the registration authority collects contact information and billing data
of the certiﬁcate applicant. This may include postal address and telephone number.
The information that the RA collects may become important in future legal disputes.
If the certiﬁcate owner is intended to be a computing device, analogous information
is gathered.
During registration, the preferences of the certiﬁcate holder are collected.
Examples of such preferences are the cryptosystem to be used with the certiﬁed
public key, parameters such as the key length, the delivery and billing method for
the certiﬁcate, and possibly a pseudonym.
If the public key that is to be certiﬁed and the corresponding private key are
generated by the certiﬁcate holder, the certiﬁcate applicant delivers the public key
to the CSP as part of the registration process. Common delivery protocols and
formats are PKCS#10, XKMS, and CRMF. PKCS#10 is most commonly used.

106
7
Certiﬁcation Service Provider
See also Sect. 7.5 for details on these protocols. Before the registration authority
accepts a public key, the applicant must provide a proof of possession (PoP) of the
corresponding private key. This prevents the CSP from issuing wrong certiﬁcates.
Each protocol deals with PoP differently. For example, PCKS#10 implements PoP
by requiring the applicant of a certiﬁcate to sign a PKCS#10 request. This means
that he or she is in possession of the private key. This assumes that the private
key can be used for signing even if it is a decryption key. CRMF provides three
mechanisms to implement PoP. One is to reveal the private key to the CSP. A second
is to exchange challenge-response messages between the CSP and the certiﬁcate
user. For example, the CSP encrypts a random value and expects the user to return
this value or the user sends a signed request. A third method is to create the
certiﬁcate, encrypt it and let the user decrypt it.
During registration it may also be important to establish the possibility for a
secure channel between the certiﬁcate owner and the CSP that is independent of the
key in the certiﬁcate. For example, this may be required when the certiﬁcate owner
wishes to revoke the certiﬁcate. A possible implementation of such a secure channel
may be based on a secret password that is agreed upon in the registration phase.
Upon collecting the registration information, the registration authority archives it
for later reference. The data must be protected according to applicable regulations.
Next, the registration authority veriﬁes that the entity applying for a certiﬁcate
with the properties speciﬁed in the applicant’s preferences is authorized to receive
such a certiﬁcate. For example, authorization may depend on the age of an applicant
or his or her position in an institution. If issuing a certiﬁcate is compliant with
applicable rules, the registration authority creates a unique digital name. This digital
name will be contained in the certiﬁcate and is assigned to not more than one entity.
It must not be used in a certiﬁcate which belongs to another entity. Registration
authorities may apply certain rules or restrictions when creating unique digital
names. Such rules help to make digital names meaningful. For example, if the
certiﬁcate belongs to an SSL server, then it makes sense to use the server domain
name as digital name. In addition, the name should support other functions such as
searching for certiﬁcates of a certain entity.
Since the registration process frequently requires applicants to appear in person,
the registration authority may operate many regional registration ofﬁces which are
sometimes referred to as local registration authorities (LRAs). This is particularly
useful for international organizations with branches in many countries. To make
certiﬁcate registration even more smooth it may be embedded into some other
registration process, for example, of the human resources department of some
organization.
If the registration has been completed successfully, the registration authority
submits a certiﬁcate request to the certiﬁcation authority. This request contains all
information which is required by the CA to issue a certiﬁcate.

7.3
Certiﬁcation Authority
107
7.3
Certiﬁcation Authority
Upon receiving certiﬁcation requests from the registration authority, the certiﬁcation
authority issues a certiﬁcate. The CA creates the certiﬁcate in accordance with the
applicable standard, for example X.509, and signs it using its secret signature key.
If the certiﬁcation request does not contain a public key, the CA generates a key
pair on behalf of the future certiﬁcate owner. The CA includes the public key of that
pair in the certiﬁcate and delivers the private key to the certiﬁcate owner. Typically,
the CA stores the private key within a personal security environment (PSE) such
as a smart card. The use of the smart card may be protected by the PIN that has
been selected by the user in the registration process. Alternatively, the CA may also
create a PIN for the user that is delivered separately from the PSE containing the
private key. The CA may also use alternative methods for delivering the private key.
The PSE is delivered to the user usually by mail or is picked up by the user directly
at the CSP. Software PSEs may be delivered by email or downloaded from the CSP.
They may also be directly installed at the client side by the system administration.
In any case, they must be protected appropriately.
In addition to issuing certiﬁcates, the CA may also provide revocation
information. If certiﬁcate revocation lists are used, the CA may generate and sign
those lists. If the OCSP protocol is applied, the CA may sign the OCSP responses.
There are many ways for the CSP to receive revocation requests. One possibility
is to establish a hotline which the certiﬁcate users can reach. By providing the cer-
tiﬁcate data as well as some authentication data such as a revocation password, the
users can revoke their certiﬁcates. Providing the revocation password is necessary to
avoid unauthorized revocations. Another possibility is to use a Web page instead of
a hotline. It also uses a revocation password. The CSP may also initiate a revocation
request. This is practiced when a certiﬁcate user is not eligible to use the certiﬁcate
anymore.
Another task of the CA is to back up the private key that it has created for the
certiﬁcate owner if key backup is required by the end user or the CSP. The CA is
also responsible for key recovery and may support key escrow, which allows some
other entity, such as a government agency, to access the private keys issued by the
CA. Key backup and key escrow are only applied to decryption keys.
In addition to the certiﬁcates which the CA issues to end users or other CAs,
it also issues certiﬁcates to itself. They are called self-issued certiﬁcates. In self-
issued certiﬁcates, the subject distinguished name and the issuer distinguished name
are identical. Self-issued certiﬁcates are used to communicate information about the
CA. For example, if the CA changes its key pair, then the CA issues a certiﬁcate
with the public key of the new key pair, which is signed with the private key of the
old key pair. A reason for the key pair to be changed may be that the size of the old
key is no longer considered to be secure. More information about key update can be
found in [2].
A special case of self-issued certiﬁcates is self-signed certiﬁcates. They certify
the public key which must be used to verify the signature on the certiﬁcate itself.

108
7
Certiﬁcation Service Provider
They are also called root certiﬁcates and are used as trust anchors in certiﬁcation
paths.
Since the CA is a very security-sensitive component of the CSP, the CA is
typically protected by several measures. Examples of this are key sizes that are
larger than the sizes of the end user keys, protection of the private key of the CA in
a hardware security module, and ofﬂine operation of the CA. Also, organizational
protection mechanisms may be used, such as access control that requires several
entities to collaborate and keeping the CA location secret.
7.4
Other Components
In addition to the registration authority and the certiﬁcation authority, the CSP may
have other components.
The CSP may operate a dedicated directory service. This service publishes
certiﬁcates and delivers certiﬁcates and PSEs that contain private keys to the users.
The directory service may also publish certiﬁcate revocation lists. For example,
such a directory service is useful if the CA operates ofﬂine. As already discussed
in Chap. 5, further components may be a revocation service that issues indirect
certiﬁcate revocation lists or an OCSP server.
Another useful CSP component is a time-stamping authority (TSA). A TSA
certiﬁes that a document existed at a certain point in time by signing the document
with the current date and time. They are speciﬁed in [1]. For example, TSAs are
used for long-term archiving of documents as described in [6].
Finally, servers for the server-based certiﬁcate validation protocol may construct
and validate certiﬁcation paths on behalf of users. See Sect. 9.5 for details.
7.5
Communication Within CSPs
The efﬁciency and security of a PKI relies on the efﬁciency and security of the
communication between the CSP components and between the CSP and the PKI
users. In this section we describe standardized formats and protocols that support
this communication.
7.5.1
Cryptographic Protection of Messages
Data that is communicated in a PKI requires cryptographic protection. For example,
it may be encrypted or digitally signed. A common format for protecting data
cryptographically is PKCS#7, which is speciﬁed in [8] and [4].

7.5
Communication Within CSPs
109
ContentInfo ::= SEQUENCE {
contentType ContentType,
content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
Listing 7.1 The ASN.1 structure of PKCS#7
The ASN.1 speciﬁcation of a PKCS#7 structure is presented in Listing 7.1.
PKCS#7 ﬁles are containers for content elements which are cryptographically
protected. The contentType determines the form of cryptographic protection
of the data. Listing 7.2 shows the six PKCS#7 content types with their respective
OIDs.
The content type data contains plain data that is not cryptographically protected.
The type enveloped-data consists of encrypted content of any type and the corre-
sponding encryption keys. These encryption keys are encrypted themselves using
the public keys of one or more recipients. This type can be viewed as a digital
envelope which can only be opened by designated receivers. The type signed-data
contains data of any type and one or several digital signatures on this data. To allow
the transport of certiﬁcates and certiﬁcate revocation lists, this type even allows there
to be no digital signature. The combined type signed-and-enveloped data contains
signed data that are enveloped. To generate such content, ﬁrst, content of type
signed-data is generated, which is then enveloped. The content type digested-data
contains data of any type together with a hash value of the data and a description
of the hash function that has been used to calculate the hash value. Data of type
encrypted-data is encrypted. However, in contrast to enveloped data there is no
encryption key. Keys are assumed to be managed by other means.
The cryptographic message syntax (CMS) is another format for protecting data
cryptographically. It is speciﬁed in [3]. CMS is based on PKCS#7. The content type
signed-and-enveloped-data has been removed. Instead, in CMS the content types
signed-data and enveloped-data can be nested. Also, a content type authenticated-
data with OID “1.2.840.113549.1.9.16.1.2” is added. It contains data that are
supplemented by a MAC value.
In addition to the use in CSPs, CMS is also used in many other applications such
as email security [7] or for long-time archiving (see [6]).
7.5.2
Certiﬁcate Requests
In this section we describe formats for sending certiﬁcate requests to CSPs. Such
formats are used in the registration process.
The certiﬁcation request format PKCS#10 is widely used. It is speciﬁed in [10]
and [5]. Listing 7.3 shows important parts of the ASN.1 description of PKCS#10.
A PKCS#10 ﬁle consists of a certiﬁcate request, a signature on this request,
and the algorithm used to create this signature. The certiﬁcate request contains the

110
7
Certiﬁcation Service Provider
contentType: 1.2.840.113549.1.7.1
Data ::= OCTET STRING
contentType: 1.2.840.113549.1.7.3
EnvelopedData ::= SEQUENCE {
version Version,
recipientInfos RecipientInfos,
encryptedContentInfo EncryptedContentInfo }
contentType: 1.2.840.113549.1.7.2
SignedData ::= SEQUENCE {
version Version,
digestAlgorithms DigestAlgorithmIdentifiers,
contentInfo ContentInfo,
certificates [0] IMPLICIT ExtendedCertificatesAndCertificates
OPTIONAL,
crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
signerInfos SignerInfos }
contentType: 1.2.840.113549.1.7.4
SignedAndEnvelopedData ::= SEQUENCE {
version Version,
recipientInfos RecipientInfos,
digestAlgorithms DigestAlgorithmIdentifiers,
encryptedContentInfo EncryptedContentInfo,
certificates [0] IMPLICIT ExtendedCertificatesAndCertificates
OPTIONAL,
crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
signerInfos SignerInfos }
contentType: 1.2.840.113549.1.7.5
DigestedData ::= SEQUENCE {
version Version,
digestAlgorithm DigestAlgorithmIdentifier,
contentInfo ContentInfo,
digest Digest }
contentType: 1.2.840.113549.1.7.6
EncryptedData ::= SEQUENCE {
version Version,
encryptedContentInfo EncryptedContentInfo }
Listing 7.2 The six content types of PKCS#7

7.5
Communication Within CSPs
111
CertificationRequest ::= SEQUENCE {
certificationRequestInfo CertificationRequestInfo,
signatureAlgorithm AlgorithmIdentifier{{SignatureAlgorithms}},
signature
BIT STRING
}
CertificationRequestInfo ::= SEQUENCE {
version
INTEGER { v1(0) } (v1,...),
subject
Name,
subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
attributes
[0] Attributes{{ CRIAttributes }}
}
Listing 7.3 The ASN.1 structure of PKCS#10
CertReqMsg ::= SEQUENCE {
certReq
CertRequest,
popo
ProofOfPossession
OPTIONAL,
regInfo
SEQUENCE SIZE(1..MAX) of AttributeTypeAndValue
OPTIONAL }
Listing 7.4 The ASN.1 structure of a CRMF message
name of the requesting entity, the public key to be certiﬁed, appropriate parameters
associated to the public key like the parameters of an elliptic curve, related attributes,
and the PKCS#10 version of the request.
The attributes in the certiﬁcate request are used to communicate the client
preferences to the CSP. Examples of such attributes are certiﬁcate extensions that
the entity would like to include in its certiﬁcate or a pass-phrase that the entity has
to provide in order to revoke its certiﬁcate. The possible attributes are described
in [9, Sect. 5.4].
The signature on the request guarantees authenticity and integrity of the content.
It also proves that the requesting entity possesses the private key corresponding
to the certiﬁed public key if this public key is a signature veriﬁcation key and
the corresponding private key is used to sign the request. Obviously, this proof of
possession does not work for encryption keys.
The certiﬁcate request message format (CRMF) [11], an alternative to PKCS#10,
is very similar to this standard. The ASN.1 speciﬁcation of CRMF is shown in
Listing 7.4.
The CertRequest element allows the certiﬁcate user to send a template of a
certiﬁcate to the CSP. This template can be used by the CSP to issue the certiﬁcate.
In this element it is also possible to specify additional controls that are operations
related to the certiﬁcate. For example, archiving of the private key by the CSP is
such a control. Listing 7.5 shows the ASN.1 structure of a CertRequest.

112
7
Certiﬁcation Service Provider
CertRequest ::= SEQUENCE {
certReqId
INTEGER,
certTemplate
CertTemplate,
controls
Controls OPTIONAL }
CertTemplate ::= SEQUENCE {
version
[0] Version
OPTIONAL,
serialNumber [1] INTEGER
OPTIONAL,
signingAlg
[2] AlgorithmIdentifier
OPTIONAL,
issuer
[3] Name
OPTIONAL,
validity
[4] OptionalValidity
OPTIONAL,
subject
[5] Name
OPTIONAL,
publicKey
[6] SubjectPublicKeyInfo
OPTIONAL,
issuerUID
[7] UniqueIdentifier
OPTIONAL,
subjectUID
[8] UniqueIdentifier
OPTIONAL,
extensions
[9] Extensions
OPTIONAL }
OptionalValidity ::= SEQUENCE {
notBefore
[0] Time OPTIONAL,
notAfter
[1] Time OPTIONAL } --at least one must be present
Time ::= CHOICE {
utcTime
UTCTime,
generalTime
GeneralizedTime }
Listing 7.5 The ASN.1 structure of a CertRequest
7.5.3
Complex Message Formats and Protocols
In addition to the formats described so far, there are message formats and protocols
that support many different PKI processes.
Such a format and protocol is the XML key management speciﬁcation [15],
which uses the XML syntax and the XML signature formats. XKMS consists of
two parts, the XML key information service speciﬁcation (X-KISS) and the XML
key registration service speciﬁcation (X-KRSS). X-KRSS supports registration,
re-certiﬁcation, certiﬁcate revocation, and key recovery. X-KISS allows us to locate
and validate certiﬁcates.
Another protocol that allows implementing all typical PKI processes is the
certiﬁcate management protocol (CMP), which is speciﬁed in [2]. For example,
CMP supports registration, certiﬁcation, revocation, management of CA keys, root
CA keys and certiﬁcates, key recovery, certiﬁcate delivery and publication, and
proof of possession of private keys. The speciﬁcation of a CMP message can be
seen in Listing 7.6.
A third complex format is certiﬁcate management over CMS (CMC), which is
speciﬁed in [12]. The CSP clients send CMC requests. The CSP server replies with
CMC responses. There are two kinds of CMC requests. A Simple PKI Request
is simply a PKCS#10 request. A Full PKI Request consists of several certiﬁcate

7.5
Communication Within CSPs
113
PKIMessage ::=SEQUENCE {
header
PKIHeader,
body
PKIBody,
protection
[0] PKIProtection OPTIONAL,
extraCerts
[1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
OPTIONAL
}
PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
Listing 7.6 The ASN.1 structure of a CMP message
Certiﬁcate 1
Serial No.: 2593
Issuer:
CN=University CA, O=TU Darmstadt, C=DE
NotBefore: 2011-06-02
NotAfter:
2012-06-01
Subject:
CN=Bob, O=TU Darmstadt, C=DE
Public Key: key-0x3EEA98E6
X509v3Extensions:
Subject Alternative Name:
email:bob@tu-darmstadt.de
KeyUsage: critical
digitalSignature
Subject Key Identiﬁer:
keyId: 99:13:D5:FD:90:31:7B:56:7F:BD
Authority Key Identiﬁer:
keyId: 0B:F8:2B:B7:B5:88:C8:03:7E:EB
aci: CN=Master CA, O=TU Darmstadt, C=DE
acsn: 03
Certiﬁcate 2
Serial No.: 2594
Issuer:
CN=University CA, O=TU Darmstadt, C=DE
NotBefore: 2011-06-02
NotAfter:
2012-06-01
Subject:
CN=Alice, O=TU Darmstadt, C=DE
Public Key: key-0x704400D7
X509v3Extensions:
Subject Alternative Name:
email:alice@tu-darmstadt.de
KeyUsage: critical
dataEncipherment
Subject Key Identiﬁer:
keyId: A2:F4:67:23:28:C2:C8:64:A8:45
Authority Key Identiﬁer:
keyId: 0B:F8:2B:B7:B5:88:C8:03:7E:EB
aci: CN=Master CA, O=TU Darmstadt, C=DE
acsn: 03
Fig. 7.1 Certiﬁcates 1 and 2
requests which use PKCS#10, CRMF, or some other format. These requests are sent
and protected inside a CMS container. There are also two kinds of CMC responses.
A Simple PKI Response is a CMS container which is used to send certiﬁcates to the
clients. If additional information needs to be sent to the client, a Full PKI Response

114
7
Certiﬁcation Service Provider
Certiﬁcate 3
Serial No.: 2595
Issuer:
CN=University CA, O=TU Darmstadt, C=DE
NotBefore: 2012-04-25
NotAfter:
2013-04-25
Subject:
CN=Carl, O=TU Darmstadt, C=DE
Public Key: key-0x6D099789
X509v3Extensions:
Subject Alternative Name:
email:carl@tu-darmstadt.de
KeyUsage: critical
dataEncipherment
Subject Key Identiﬁer:
keyId: 67:65:AE:DB:3E:2A:4C:5F:99:37
Authority Key Identiﬁer:
keyId: 0B:F8:2B:B7:B5:88:C8:03:7E:EB
aci: CN=Master CA, O=TU Darmstadt, C=DE
acsn: 03
Certiﬁcate 4
Serial No.: 1
Issuer:
CN=Master CA, O=TU Darmstadt, C=DE
NotBefore: 2009-12-01
NotAfter:
2014-12-01
Subject:
CN=Master CA, O=TU Darmstadt, C=DE
Public Key: key-0xB1BB55C3
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 1
KeyUsage: critical
keyCertSign, cRLSign
Subject Key Identiﬁer:
keyId: 54:23:AA:12:AB:CD:4E:5F:3A:11
Authority Key Identiﬁer:
keyId: 54:23:AA:12:AB:CD:4E:5F:3A:11
aci: CN=Master CA, O=TU Darmstadt, C=DE
acsn: 01
Fig. 7.2 Certiﬁcates 3 and 4
is used which can also contain other data. In addition, CMC offers mechanisms to
prove the user identity and possession of private keys.
The techniques that can be used to transfer CMC messages are speciﬁed in [13].
One option is to use the POST method of HTTP(S). A second option is to use
special MIME types and send the messages by email. A third option is to store the
messages in a ﬁle. This is a common technique when some components are ofﬂine.
By using the proper extension it is possible to specify the message type. The possible
extensions are .p10 for a Simple PKI Request, .crq for a Full PKI Request, .p7c
for a Simple PKI Response, and .prp for a Full PKI Response. It is also possible
to send the message as a binary string using TCP.
The usage of CMC is simpliﬁed when the compliance requirements speciﬁed
in [14] are respected. For example, these requirements refer to the request and
response types that are supported or the cryptographic algorithms that may be used.

References
115
Certiﬁcate 5
Serial No.: 3
Issuer:
CN=Master CA, O=TU Darmstadt, C=DE
NotBefore: 2009-12-01
NotAfter:
2014-12-01
Subject:
CN=University CA, O=TU Darmstadt, C=DE
Public Key: key-0x556486AB
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 0
KeyUsage: critical
keyCertSign, cRLSign
Subject Key Identiﬁer:
keyId: 0B:F8:2B:B7:B5:88:C8:03:7E:EB
Authority Key Identiﬁer:
keyId: 54:23:AA:12:AB:CD:4E:5F:3A:11
aci: CN=Master CA, O=TU Darmstadt, C=DE
acsn: 01
Fig. 7.3 Certiﬁcate 5
7.6
Exercises
7.1. Answer the following questions:
1. Which of the certiﬁcates shown in Figs. 7.1–7.3 are root certiﬁcates? Which are
CA certiﬁcates? How can they be recognized? Hint: consider the extensions of
the certiﬁcates.
2. How can the certiﬁcate for the public key of an issuer be found?
3. Suppose that a PKI client cannot interpret the key usage extension. How does the
client treat Certiﬁcate 1?
4. Bob has generated the key pair for Certiﬁcate 1 himself. What is required by
the CA to generate Bob’s certiﬁcate? How can the CA convince itself that Bob
knows the private key corresponding to the certiﬁed public key?
5. How can a proof of possession for Certiﬁcate 3 be performed? How does it differ
from the PoP of the previous question?
6. Why is PoP important? What attacks are possible without PoP?
7. What certiﬁcates might be subject to key backup?
References
1. C. Adams, P. Cain, D. Pinkas, R. Zuccherato, Internet X.509 public key infrastructure time-
stamp protocol (TSP), in IETF Request for Comments, 3161, Aug 2001
2. C. Adams, S. Farell, T. Kause, T. Mononen, Internet X.509 public key infrastructure certiﬁcate
management protocol (CMP), in IETF Request for Comments, 4210, Sept 2005
3. R. Housley, Cryptographic message syntax (CMS), in IETF Request for Comments, 3852, July
2004

116
7
Certiﬁcation Service Provider
4. B. Kaliski,
PKCS #7: cryptographic message syntax – Version 1.5, in
IETF Request for
Comments, 2315, Mar 1998
5. M. Nystrom, B. Kaliski, PKCS #10: certiﬁcation request syntax speciﬁcation – Version 1.7,
in IETF Request for Comments, 2986, Nov 2000
6. D. Pinkas, N. Pope, J. Ross, CMS advanced electronic signatures (CAdES), in IETF Request
for Comments, 5126, Feb 2008
7. B. Ramsdell, S. Turner, Secure/multipurpose internet mail extensions (S/MIME) Version 3.2
message speciﬁcation, in IETF Request for Comments, 5751, Jan 2010
8. RSA Laboratories, PKCS #7 v1.5: cryptographic message syntax standard (1993), http://www.
rsa.com/rsalabs/node.asp?id=2129
9. RSA Laboratories, PKCS #9 v2.0: selected object classes and attribute types (2000), http://
www.rsa.com/rsalabs/node.asp?id=2131
10. RSA Laboratories, PKCS #10 v1.7: certiﬁcation request syntax standard (2000), http://www.
rsa.com/rsalabs/node.asp?id=2132
11. J. Schaad, Internet X.509 public key infrastructure certiﬁcate request message format (CRMF),
in IETF Request for Comments, 4211, Sept 2005
12. J. Schaad, M. Myers,
Certiﬁcate management over CMS (CMC), in
IETF Request for
Comments, 5272, June 2008
13. J. Schaad, M. Myers, Certiﬁcate management over CMS (CMC): transport protocols, in IETF
Request for Comments, 5273, June 2008
14. J. Schaad, M. Myers,
Certiﬁcate management messages over CMS (CMC): compliance
requirements, in IETF Request for Comments, 5274, June 2008
15. World Wide Web Consortium (W3C), XML key management speciﬁcation (XKMS) (2001),
http://www.w3.org/TR/xkms/

Chapter 8
Certiﬁcate Policies
In the previous chapter we introduced CSPs that manage the life cycle of certiﬁcates
in a hierarchical PKI. CSPs follow certain rules which are called certiﬁcate policies.
They determine the applicability of a certiﬁcate to a particular community or
class of applications with common security requirements. Therefore, certiﬁcate
policies that a CSP applies while generating and managing certiﬁcates are made
explicit and available to the certiﬁcate users. In addition, the CSP may describe
the implementation of the policy in a certiﬁcation practice statement (CPS). In this
chapter we discuss certiﬁcate policies and certiﬁcation practice statements.
8.1
Structure of Certiﬁcate Policies
RFC 3647 [2] speciﬁes the following structure for certiﬁcate policies.
Introduction The introduction contains the name and OID of the policy. It provides
deﬁnitions and terminology and deﬁnes PKI entities such as certiﬁcation authorities,
registration authorities, and subscribers who receive certiﬁcates from CAs. It lists
applications of the certiﬁcates that comply with this policy and provides information
about the administration of the policy.
Publication and Repository Responsibilities During the life cycle of a certiﬁcate,
information such as the certiﬁcate policy, the certiﬁcation practice statement, the
certiﬁcate itself, and revocation information is published. This section of the policy
contains rules on how, when, and how frequently this is done and how the published
information can be accessed.
Identiﬁcation and Authentication In many phases of the certiﬁcate life cycle,
entities are required to identify themselves to the CSP. Examples are certiﬁcate
or revocation requests. Also, the communication between those entities and the
CSP must be authentic. This section speciﬁes identiﬁcation and authentication
mechanisms that are being used by the CSP.
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__8, © Springer-Verlag Berlin Heidelberg 2013
117

118
8
Certiﬁcate Policies
Certiﬁcate Life Cycle Operational Requirements This part of the policy deals
with the implementation of the certiﬁcate life cycle. The policy describes the
potential applicants and the application process. In particular, the policy must
specify whether the applying entity may generate its own key pair and how the
public key is delivered to the CSP. In addition, the policy contains requirements
concerning application processing by the CSP. For example, the policy contains
requirements for a registration process in which the identity of the applying entity
is checked and veriﬁed. This part of the policy also speciﬁes the requirements for
certiﬁcate generation, for example, whether the certiﬁcate use is to be restricted.
Also, this section contains requirements concerning notiﬁcation of the certiﬁcate
owners after certiﬁcate generation and acceptance of the certiﬁcates by their
owners. It provides rules for dealing with expired certiﬁcates, for their renewal,
and for their modiﬁcation. It also contains requirements for revocation. Examples
are acceptable reasons for revocation, maximum revocation latencies, and CRL
issuing frequencies. Also, this section addresses processes that deal with certiﬁcate
suspension, status queries, key escrow, key recovery, and users who cease to be part
of the PKI.
Facility, Management, and Operational Controls For certiﬁcates to be secure,
the security of the underlying cryptography and processes is not sufﬁcient. It is also
necessary to monitor and protect the facilities of the CSP and its management and
to establish adequate operational controls.
Facility protection issues that are addressed by this section of the policy include
physical access control, the location of the facilities and their protection, for
example from water or ﬁre, the power supply, and cleaning procedures. This part
of the policy contains provisions concerning the personnel that operate the CSP.
Issues are, for example, qualiﬁcation, training and access to information.
In addition, this section of the policy includes provisions for logging and the
evaluation and archiving of the logs. Also, CA key renewal in case of compromise
or disaster is addressed, as well as possible cessation of operation of the CSP.
Technical Security Controls This part of the policy deals with secure key
management, in particular the management of private keys. These mechanisms
apply to the keys of the issuing CA as well as the keys of the subscribers of
the CSP. This includes key generation, private key protection in personal security
environments, key transport and activation, and archiving. It may also include
provisions for securing the computing environment such as ﬁrewalls and secure
software development for the CSP.
Certiﬁcate, CRL, and OCSP Proﬁles Here, the format of certiﬁcates, certiﬁcate
revocation lists, and OCSP messages is speciﬁed. This information includes version,
cryptographic algorithms, extensions and their criticality, policies, and policy
constraints.

8.2
Relevant Certiﬁcate Extensions
119
Compliance Audit and Other Assessment This section explains the required
auditing procedures. It speciﬁes the auditing subject, the auditing frequencies, the
entities responsible for performing the audits, and provisions on how to deal with
the results of audits.
Other Business and Legal Matters This policy section includes information on
fees, ﬁnancial responsibilities, treatment of private and conﬁdential information,
intellectual property rights, and liability.
8.1.1
Certiﬁcation Practice Statement
A certiﬁcation practice statement (CPS) describes how a CSP implements and
enforces its chosen policy. Consequently, there may be several different certiﬁcation
practice statements for each certiﬁcate policy. The need for such a statement depends
on the level of detail that is presented in the certiﬁcate policy itself. Certiﬁcation
practice statements and their relation to certiﬁcate policies are discussed in [2].
8.2
Relevant Certiﬁcate Extensions
8.2.1
Certiﬁcate Policies
The CertiﬁcatePolicies extension in a certiﬁcate indicates the policies that are
applied by the issuer of the certiﬁcate. This extension is a sequence of OIDs and
the corresponding qualiﬁers. The sequence may also contain the OID “2.5.29.32.0”,
which means anyPolicy.
Qualiﬁers provide additional information about the policy. Possible qualiﬁers
are a pointer (URI) to the CPS document that corresponds to this policy or an
explanatory text of less than 200 characters. Listing 8.1 presents the format of
certiﬁcate policies extension.
In Fig. 8.1, an X.509 certiﬁcate as shown by the Windows OS can be seen. The
policy of this certiﬁcate is “1.2.3.4.5.6.7.8”. If a user clicks the “Issuer Statement”
button on the lower right corner, he or she can see the CPS of the certiﬁcate issuer,
which is typically published as a Web page.
8.2.2
Policy Mappings
The PolicyMappings extension is a critical extension which is set only in CA
certiﬁcates. In this extension, the CA declares its own issuerDomainPolicy

120
8
Certiﬁcate Policies
CertificatePolicies ::= SEQUENCE SIZE (1..MAX) OF
PolicyInformation
PolicyInformation ::= SEQUENCE {
policyIdentifier
CertPolicyId,
policyQualifiers
SEQUENCE SIZE (1..MAX) OF
PolicyQualifierInfo OPTIONAL }
CertPolicyId ::= OBJECT IDENTIFIER
PolicyQualifierInfo ::= SEQUENCE {
policyQualifierId
PolicyQualifierId,
qualifier
ANY DEFINED BY policyQualifierId }
Listing 8.1 Certiﬁcate policies extension
Fig. 8.1 “Issuer Statement”
button on the lower right
corner of Windows certiﬁcate
viewer
to be covered by a certain subjectDomainPolicy. The extension contains
the pair (issuerDomainPolicy, subjectDomainPolicy). Policy mapping is relevant in
certiﬁcation paths where policies of an issuer restrict the acceptability of policies in
subsequent certiﬁcates in the path (see Sect. 9.4.1). Policy mapping is also important
in cross-certiﬁcation, if the cross-certifying CAs do not share the same policy.

8.2
Relevant Certiﬁcate Extensions
121
PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
issuerDomainPolicy
CertPolicyId,
subjectDomainPolicy
CertPolicyId }
Listing 8.2 Policy mappings extension
When the policy mappings extension is present then the issuerDomainPolicy
remains only a valid policy in the certiﬁcation path if the extension contains a
mapping of this policy to itself.
There are two restrictions regarding the use of this extension. It is not permitted
to map anyPolicy to another policy, and vice versa. Also, any issuerDomainPolicy
that is mapped to some subjectDomainPolicy should appear in the certiﬁcate policy
extension. Listing 8.2 presents the format of the policy mappings extension.
8.2.3
Policy Constraints
This extension may only be set in CA certiﬁcates. It restricts the use of policies in
certiﬁcates in a certiﬁcation path that follow the certiﬁcate in which the extension is
present.
There are two types of policy constraints, requireExplicitPolicy and inhibitPoli-
cyMapping, that are both represented by nonnegative integers. A policy constraint
of the ﬁrst type is the number of certiﬁcates that may follow in the path before
the presence of an explicit policy is mandatory in all further certiﬁcates in the
path. The other type restricts the use of policy mapping. It contains the number
of certiﬁcates that may follow in the path before policy mapping is prohibited. If a
CA requires an explicit policy to be present and wants to prohibit policy mapping
in all subsequent certiﬁcates, it sets both policy constraint values to 0. The path
validation algorithm given by RFC 5280 in Sect. 6 of [3] (cf. Sect. 9.4.1) does
not process policy constraints of self-signed certiﬁcates provided as trust anchors,
but explicitly allows implementations to do so. Self-issued certiﬁcates are always
processed.
8.2.4
Inhibit anyPolicy
This critical extension, which may be set only in CA certiﬁcates, is used to prohibit
the use of anyPolicy in certiﬁcation paths. It contains the number of certiﬁcates that
may follow the CA certiﬁcate in the path before the use of anyPolicy is prohibited
in further certiﬁcates. Self-issued CA certiﬁcates in the path are not counted.

122
8
Certiﬁcate Policies
Fig. 8.2 A Web page authenticated by an EV certiﬁcate as displayed in Firefox
8.3
Extended Validation Certiﬁcates
Extended validation (EV) certiﬁcates are used to enable secure communication with
Web sites. They must only be issued after extensive veriﬁcation of the requesting
entity’s identity by the issuing CA. Extended validation certiﬁcates are speciﬁed
by the Certiﬁcation Authority Browser Forum [1], a voluntary consortium of
certiﬁcation authorities and Internet browser software and application providers that
create and use SSL certiﬁcates. Issuing EV certiﬁcates requires respecting certain
rules that support the security of such certiﬁcates. For example, the period between
publishing CRLs must not exceed 7 days.
The use of such certiﬁcates is indicated in most browsers by displaying the
corresponding URL on a green background. Figure 8.2 shows an example.
8.4
Exercises
8.1. Which of the certiﬁcates shown in Figs. 8.3 and 8.4 has a valid policy mappings
extension?

References
123
Certiﬁcate A
Serial No.: 8735
Issuer:
CN=Root CA
NotBefore: 2010-01-01
NotAfter:
2013-01-01
Subject:
CN=CA1
Public Key: key-0xE36E2A58
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 1
KeyUsage: critical
keyCertSign
Certiﬁcate Policies: critical
green, blue, ANY
Policy Mappings: critical
magenta −→blue
green −→blue
Certiﬁcate B
Serial No.: 8576845
Issuer:
CN=Root CA
NotBefore: 2010-01-01
NotAfter:
2013-01-01
Subject:
CN=Alice
Public Key: key-0xDCFE8299
X509v3Extensions:
Basic Constraints: critical
CA: FALSE
KeyUsage: critical
digitalSignature
Certiﬁcate Policies: critical
red, green
Policy Mappings: critical
green −→blue
Fig. 8.3 Certiﬁcates A and B with policy mappings
Certiﬁcate C
Serial No.: 8735
Issuer:
CN=Root CA
NotBefore: 2010-01-01
NotAfter:
2013-01-01
Subject:
CN=CA1
Public Key: key-0x1FD9DB9E
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 2
KeyUsage: critical
keyCertSign
Certiﬁcate Policies: critical
green, blue, ANY
Policy Mappings: critical
green −→blue
Certiﬁcate D
Serial No.: 907865
Issuer:
CN=Root CA
NotBefore: 2010-01-01
NotAfter:
2013-01-01
Subject:
CN=CA1
Public Key: key-0x80B35720
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 1
KeyUsage: critical
keyCertSign
Certiﬁcate Policies: critical
green, blue, ANY
Policy Mappings: critical
ANY −→yellow
Fig. 8.4 Certiﬁcates C and D with policy mappings
References
1. CA/Browser Forum, http://www.cabforum.org/
2. S. Chokhani, W. Ford, R. Sabett, C. Merrill, S. Wu, Internet X.509 public key infrastructure
certiﬁcate policy and certiﬁcation practices framework, in IETF Request for Comments, 3647,
Nov 2003
3. D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 5280, May 2008

Chapter 9
Certiﬁcation Paths: Retrieval and Validation
If entities wish to use a public key for encryption or signature veriﬁcation they must
retrieve this key and ﬁnd out to whom it belongs. If this public key has been certiﬁed
within a hierarchical PKI, the corresponding certiﬁcate must be found. Typically,
such a certiﬁcate is the last element of a certiﬁcation path. To verify its validity, the
appropriate trust anchor must be found and the certiﬁcation path must be constructed
and veriﬁed. In this chapter we explain how this is done.
9.1
LDAP
Most PKIs use LDAP directories to disseminate certiﬁcates and certiﬁcate revoca-
tion lists. LDAP, the lightweight directory access protocol [22], allows us to access
directories based on the X.500 standard. The current version of LDAP is LDAPv3.
We brieﬂy explain how LDAP works.
LDAP assumes the data to be organized in directory information trees (DITs) as
shown in Fig. 9.1. All nodes of such a tree are called entries. Each entry belongs to
one or more object classes and has one or more attributes. Each attribute has a name
and contains data. The possible attributes that an entry can have are determined
by the object classes to which the entry belongs. For example, in Fig. 9.2 the
entry for user Alice belongs to the object classes top, person, and pkiUser. It
has four attributes containing the corresponding data. Each entry of a DIT has a
relative distinguished name (RDN) which is constructed from some of its attributes.
Frequently, the attributes common name (cn), organizational unit (ou), and domain
component (dc) are used. But any attribute can be used. Also, each entry has a
distinguished name. It is a sequence that starts with the RDN of the entry and is
followed by the parent’s DN. The DN of an entry uniquely determines this entry
within its tree. We will now explain the use of LDAP for PKI in more detail.
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__9, © Springer-Verlag Berlin Heidelberg 2013
125

126
9
Certiﬁcation Paths: Retrieval and Validation
dc=orgName,dc=eu
c=de
c=at
o=orgName
cn=Alice
o=orgName
ou=pki
ou=support
cn=The CA
cn=Bob
Fig. 9.1 LDAP directory information tree
dc=orgName,dc=eu
c=de
cn=Alice
o=orgName
objectClass: top 
objectClass: person 
objectClass: pkiUser 
sn: Alice 
cn: Alice 
userCertificate: MX..(Base64) 
userCertificate: MU..(Base64) 
Fig. 9.2 LDAP user entry with certiﬁcates
9.1.1
Storing Certiﬁcates
User Certiﬁcates LDAP entries can be used to store certiﬁcates. For example,
Fig. 9.2 shows the LDAP entry of Alice, which contains two certiﬁcates. Typically,
the subjectDN of a certiﬁcate stored in an LDAP entry is equal to the DN of the
entry. But this is not mandatory.

9.1
LDAP
127
( 2.5.6.21 NAME ’pkiUser’
DESC ’X.509 PKI User’
SUP top AUXILIARY
MAY userCertificate )
Listing 9.1 pkiUser object class deﬁnition
There are several object classes that permit LDAP entries to contain certiﬁcates.
One of them is the object class pkiUser [23]. Its deﬁnition can be seen in
Listing 9.1. It allows the userCertificate attribute to be present. This attribute
may contain one or more X.509 certiﬁcates. The possibility of containing several
certiﬁcates is useful when a CA issues several certiﬁcates for one user or when
expired certiﬁcates are not removed from the directory. The possibility of containing
no certiﬁcate permits all certiﬁcates to be removed by deleting the attribute without
violating the rules of the directory.
Other object classes that allow the userCertiﬁcate attribute to be present
are strongAuthenticationUser [23] and inetOrgPerson [19]. The
inetOrgPerson object class is more ﬂexible than the pkiUser object class since in
addition to being able to contain user certiﬁcates it also permits providing other
information about users, such as their ofﬁce number or email address. In addition,
this object class also permits the use of the userPKCS12 attribute [19], which can
contain a PKCS#12-encoded PSE. The object class strongAuthenticationUser is
less ﬂexible than the other two classes since it requires at least one user certiﬁcate to
be present. Hence, if all certiﬁcates are removed from the userCertiﬁcate attribute,
the object class must be deleted. Moreover, the strongAutheticationUser object
class restricts the certiﬁcates in the corresponding entry to being used for strong
authentication purposes only.
In analogy to the pkiUser object class, the pmiUser object class deﬁned in
[18, Clause 17] supports publication of attribute certiﬁcates by specifying the
attributeCertificate attribute. Here, “pmi” stands for privilege manage-
ment infrastructure, which manages attribute certiﬁcates just as a PKI manages
public key certiﬁcates.
It is also possible for LDAP directories to store PGP certiﬁcates. Some appropri-
ate object classes have been deﬁned. However, they are not standardized.
CA Certiﬁcates Certiﬁcates that belong to a CA are stored in the LDAP entry of
the CA which—unlike a user entry—has no other purpose. The subjectDN in such
a certiﬁcate typically matches the DN of the LDAP entry. But as in the case of user
certiﬁcates, this is not mandatory. As an example, Fig. 9.3 shows the entry of the
CA OrgCA.
An object class that makes an LDAP entry a CA entry is pkiCA, deﬁned in
[23]. The speciﬁcation of this object class is shown in Listing 9.2. It permits the
cACertificate attribute, which holds one or more X.509 certiﬁcates, to be
present.

128
9
Certiﬁcation Paths: Retrieval and Validation
dc=orgName,dc=eu
c=at
o=orgName
ou=pki
cn=OrgCA
objectClass: top
objectClass: pkiCA
objectClass:cRLDistributionPoint
cn: OrgCA
certificateRevocationList: MIX....X
cACertificate: MIF....T
Fig. 9.3 LDAP CA entry with certiﬁcate and CRL
( 2.5.6.22 NAME ’pkiCA’
DESC ’X.509 PKI Certificate Authority’
SUP top AUXILIARY
MAY ( cACertificate $ certificateRevocationList $
authorityRevocationList $ crossCertificatePair $) )
Listing 9.2 pkiCA object class deﬁnition
( 2.5.6.16 NAME ’certificationAuthority’
DESC ’X.509 certificate authority’
SUP top AUXILIARY
MUST ( authorityRevocationList $
certificateRevocationList $ cACertificate )
MAY crossCertificatePair )
Listing 9.3 certiﬁcationAuthority object class deﬁnition
The objectClass certificationAuthority, [23] which is shown in
Listing 9.3, also permits CA certiﬁcates to be present. This object class is less
ﬂexible than the pkiCA object class since in addition to the cACertiﬁcate it also
requires the authorityRevocationList attribute to be present. The latter
attribute holds the authority revocation list. It is a special revocation list that
exclusively lists CA certiﬁcates as revoked. Such lists are rarely used.
A cross-certiﬁcate may be stored in the entry of the CA by which it is issued
and/or in the entry of the CA to which it is issued. For this purpose, the pkiCA object
class permits the crossCertificatePair attribute to be present. It contains

9.1
LDAP
129
a pair of certiﬁcates. The issuedToThisCA certiﬁcate is the ﬁrst element. The
issuedByThisCA certiﬁcate is the second element. One of these elements may be
absent. In previous speciﬁcations the issuedToThisCA certiﬁcate was called forward
certiﬁcate and the issuedByThisCA certiﬁcate was called reverse certiﬁcate.
Attribute authority certiﬁcates are kept in the aACertificate attribute, which
is permitted by the pmiAA objectClass.
9.1.2
Certiﬁcate Search
Certiﬁcates are published in LDAP directories to enable clients to access certiﬁcates
that they do not already possess. Therefore, most browsers and email clients support
certiﬁcate search in LDAP directories.
To search for objects in an LDAP directory, search ﬁlters are used. The format
of such a ﬁlter is speciﬁed in [20]. For example, if the search ﬁlter cn=Alice is
used, the entry shown in Fig. 9.2 is found. For entries that match the search criteria
of a chosen ﬁlter, the client may specify the attributes whose values are returned
by the directory. For certiﬁcate search, the userCertiﬁcate attribute can be speciﬁed.
It is augmented with the option ;binary [15] which requests that the certiﬁcates
be returned in their DER-encoded form. All values of the speciﬁed attribute are
returned. In our example these are two certiﬁcates. It is possible that an LDAP search
via a search ﬁlter is not successful since the content of the ﬁlter is not an attribute
of the corresponding LDAP entry. For example, an LDAP search that uses the ﬁlter
mail=alice@orgname.eu to search for Alice’s entry shown in Fig. 9.2 will
fail because Alice’s entry has no attribute containing her email address. To make the
search successful, search criteria may be applied directly to the certiﬁcate instead
of the entry of its owner. This is possible using matching rules, deﬁned in [23], or
component matching, described in [14]. When matching rules are applied expected
certiﬁcate content is searched for in the certiﬁcates contained in the directory. For
example, the certificateExactMatch rule [23] requires the serial number
and issuerDN values provided by the searching client to match the corresponding
values in a certiﬁcate stored in the directory in order for a certiﬁcate to be returned
to the client. Component matching offers a more generic and ﬂexible approach by
looking for components of the ASN.1 representation of an LDAP attribute. For an
example of the use of component matching for certiﬁcates, see [16]. Currently, only
few clients and servers support certiﬁcate-related matching rules and component
matching.
The last certiﬁcate search method that we mention is to store each certiﬁcate
in a separate LDAP entry. The components of the certiﬁcate such as subjectDN or
keyUsage are represented as attributes of this entry. This allows clients to locate
certiﬁcates by searching for LDAP attributes. In contrast to other search techniques
this method is not standardized.
A more detailed discussion of certiﬁcate search in LDAP can be found in [2].

130
9
Certiﬁcation Paths: Retrieval and Validation
( 2.5.6.19 NAME ’cRLDistributionPoint’
DESC ’X.509 CRL distribution point’
SUP top STRUCTURAL
MUST cn
MAY ( certificateRevocationList $
authorityRevocationList $ deltaRevocationList ) )
Listing 9.4 cRLDistributionPoint object class deﬁnition
Table 9.1
Details of an LDAP URL
orgName.eu
Is the name of the host that operates the
LDAP server
389
Is the corresponding port. It may be
omitted since 389 is the default
cn=OrgCA,ou=pki,o=orgName,
c=at,dc=orgName,dc=eu
Is the DN of the entry in the LDAP
directory
certiﬁcateRevocationList;binary
Notiﬁes the LDAP server to return only
CRLs
base
Indicates that the search should be
limited to the entry where the search
starts. This makes the search very fast
objectClass=cRLDistributionPoint
Is the search ﬁlter according to [20]
9.1.3
Storing CRLs
The pkiCA object class that is used to store CA certiﬁcates also allows storing CRLs.
The corresponding LDAP attribute is certificateRevocationList. This
multi-valued attribute holds the DER-encoded CRLs. Figure 9.3 shows the entry of
a CA that issues CRLs and publishes them on an LDAP server. CRLs may also be
published using the certificationAuthority object class. However, this is
not recommended due to the drawbacks described in Sect. 9.1.1. Another choice for
publishing CRLs is the cRLDistributionPoint object class (see Listing 9.4).
In addition to publishing CRLs, this object class also permits publishing delta CRLs
and ARLs. This object class is a good choice for storing CRLs since it allows the
cn attribute to be present, which can be used to build meaningful DNs as illustrated
in Fig. 9.3. Delta CRLs are stored in the attribute deltaRevocationList. This
object class is also useful for storing indirect CRLs since the entity related to the
entry is not necessarily a CA.
If CRLs are distributed using an LDAP directory, the CRL distribution points
extension (see Sect. 5.3.1) of the corresponding certiﬁcates can point to the location
of the CRL in the LDAP. In the example shown in Fig. 9.3, the value of this extension
is: ldap://orgName.eu:389/cn=OrgCA,ou=pki,o=orgName,c=at,
dc=orgName,dc=eu?certificateRevocationList;binary?base?
objectClass=cRLDistributionPoint. The meanings of the values in this
URL (according to the format deﬁned in [21]) are shown in Table 9.1.

9.2
Other Certiﬁcate Retrieval Methods
131
9.1.4
Security
The LDAP protocol offers mechanisms that address various security issues. They
are speciﬁed in [9]. Users can connect to the LDAP server anonymously, with their
user name, or with user name and password. Anonymous connections are mostly
used for LDAP searches, for example certiﬁcate searches. A more secure variant is
LDAPS which uses TLS to establish a secure channel before LDAP queries start. It
is also possible to combine LDAP with the simple authentication and security layer
(SASL) architecture. The list of available SASL mechanisms can be found in [12].
LDAP also supports authorization techniques that permit users to change the
content of the directory. For example, LDAP administrators may be allowed to
change all data while users may only be entitled to change their own data such
as password or telephone number. Moreover, certain attributes may not be visible
and searchable, for example, the userPassword attribute that holds the password of
a user.
9.2
Other Certiﬁcate Retrieval Methods
In addition to LDAP there are other methods that support the retrieval of certiﬁcates
and revocation information. Examples are the domain name system [13], HTTP
certiﬁcate stores [8], Web servers and FTP servers [11]. We will now discuss these
possibilities in more detail.
9.2.1
DNS
The domain name system is a hierarchically organized naming system for computers
and services on the Internet. For example, it is used for translating the symbolic
name of a host (domain name) into an Internet protocol (IP) address. DNS can also
be used for organizing certiﬁcates and CRLs. This is described in RFC 4398 [13].
The certiﬁcates and CRLs are stored in a resource record called CERT. They have
four ﬁelds. The ﬁrst ﬁeld contains the type of the certiﬁcate or CRL, for example
X.509, PGP, SPKI, and attribute certiﬁcate. The second ﬁeld contains a key tag that
describes the key contained in the certiﬁcate. It is a 16-bit identiﬁer that is derived
using a key tag calculation algorithm (see Appendix B of [1]). This algorithm is
not guaranteed to create unique representations for keys. However, it can be used to
speed up key search. The third ﬁeld contains the signature algorithm used to sign the
certiﬁcate or CRL as speciﬁed in Appendix A of [1], and the fourth ﬁeld contains
the certiﬁcate or CRL reference.

132
9
Certiﬁcation Paths: Retrieval and Validation
9.2.2
HTTP
RFC 4387 [8] speciﬁes how to search for X.509 or PGP certiﬁcates and CRLs using
simple HTTP requests. The RFC does not specify how those objects are stored.
In fact, any repository can be used for this purpose, such as databases, LDAP
directories, or even existing ﬁle systems. This search method only supports simple
requests. For example, clients can search for certiﬁcate ﬁngerprints.
9.2.3
Web Servers and FTP Servers
Another way of publishing certiﬁcates and CRLs is via HTTP or FTP servers.
This is speciﬁed in [11]. The certiﬁcates and CRLs are stored in DER-encoding
on the server. The respective extensions are “.cer” and “.crl”. The MIME types
are “application/pkix-cert” and “application/pkix-crl”. Certiﬁcates and CRLs can
be retrieved using the corresponding URI. Examples of such URIs are ftp:
//myFtpServer.de/certificates/myCertificate.cer and http:
//myHttpServer.com/crls/myCrl.crl. This method has several advan-
tages. Most organizations use FTP or HTTP servers. The URI is static. This makes
storing, retrieving and disseminating location information very easy.
9.2.4
WebDAV
In [3] the authors propose a method that uses the Web-based distributed authoring
and versioning standard (WebDAV) [6] for publishing certiﬁcates and revocation
lists. In WebDAV-based publication, every certiﬁcate and CRL is represented as
a Web page. In addition, the owner of one or more certiﬁcates is a collection
(comparable to a ﬁle system directory) and the corresponding certiﬁcates are
members of this collection. The certiﬁcates and CRLs can be accessed using HTTP
requests. The respective extensions are “.p7c” for certiﬁcates, “.crl” for CRLs, and
“.ace” for attribute certiﬁcates. The information on where to locate the certiﬁcate is
contained in the Authority Information Access extension (see Sect. 9.6.1). Revoked
certiﬁcates can be removed from the servers. The non-existence of a certiﬁcate is
an easy way of informing users about the revocation. Alternatively, a CRL with a
single entry can be placed on the server.
9.3
Certiﬁcation Path Building
In RFC 4158 [4], certiﬁcation path building is deﬁned as “the process used to
assemble the certiﬁcation path between the trust anchor and the target certiﬁcate”.
Certiﬁcation path building is a complex process. For example, it requires clients

9.3
Certiﬁcation Path Building
133
A
B
C
E
D
F
Fig. 9.4 An example of a
PKI hierarchy
that construct such paths to understand many different certiﬁcate extensions and to
support different protocols for accessing PKI repositories.
We explain the algorithm for certiﬁcate path building from RFC 4158. Construct-
ing a certiﬁcation path requires two inputs, the trust anchor that the path starts from
and the target certiﬁcate that the path ends with. The trust anchor can be given in
the form of a certiﬁcate or explicitly by its DN, a public key, an algorithm, and
corresponding parameters.
We illustrate the process of certiﬁcate path building in an example. Figure 9.4
shows a PKI as a graph. It has six participants which are the nodes. Entity A is the
trust anchor. An edge from X to Y means that X has issued a certiﬁcate to Y. This
certiﬁcate is denoted by C X
Y .
In this PKI there are two certiﬁcation paths from A to F. They can be constructed
from the trust anchor as shown in Fig. 9.5. The tree in this ﬁgure is called the
issuedBy direction tree. They can also be constructed from the target certiﬁcate,
as in Fig. 9.6, which shows the issuedTo direction tree. RFC 4158 calls the
issuedBy direction forward while the issuedTo direction is referred to as reverse.
As can be seen in Figs. 9.5 and 9.6, there may be certiﬁcation paths of different
lengths. Which path is found depends on the certiﬁcates that are being used in the
construction. When the client starts with certiﬁcate C A
C , the path is longer than when
it starts with certiﬁcate C A
B .
The direction in which the certiﬁcation path is constructed mainly depends
on what information is available. If all cross-certiﬁcates and CA certiﬁcates are
published in the directory that holds the target, then using both directions is possible.
If only the issuedToThisCA certiﬁcates are published, then the issuedTo direction
is used, while the opposite direction can be chosen when the issuedByThisCA
certiﬁcates are present. The issuedTo direction can also be selected if all certiﬁcates
contain information on how to locate the corresponding issuer certiﬁcates.

134
9
Certiﬁcation Paths: Retrieval and Validation
A
B
C
D
E
F
B
D
F
Fig. 9.5 issuedBy direction
tree
If there are different certiﬁcation paths, then certiﬁcation path building must be
optimized. For example, consider the PKI from Fig. 9.7. The shortest path from the
trust anchor B that validates C E
G is C B
A , C A
C , C C
E . The path C B
A , C A
C , C C
D , C D
B , C B
A , C A
C ,
C C
E is invalid because it contains a certiﬁcate (C B
A ) twice. However, the path C B
A ,
C A
C , C C
D , C D
F , C F
C , C C
E is valid but longer than the shortest path. This path contains
two certiﬁcates for entity C. Avoiding this is a simple optimization. Methods for
optimizing certiﬁcation path building can be found in Sect. 3 of [4]. Certiﬁcation
path building can be performed simultaneously with certiﬁcation path validation,
which is discussed in the following section.
9.4
Certiﬁcation Path Validation
In this section we explain the algorithm for certiﬁcation path validation speciﬁed in
RFC 5280 (Sect. 6 of [5]).

9.4
Certiﬁcation Path Validation
135
F
D
B
C
A
E
A
Fig. 9.6 issuedTo direction
tree
9.4.1
Validation Algorithm
RFC 5280 proposes an algorithm that validates a given certiﬁcation path in Sect. 6
of [5]. If the algorithm fails to validate the path, the reason for this failure is also
given.
This algorithm is rather complicated and not frequently used in practice.
Therefore, we only sketch the algorithm. The details can be found in Appendix A.
The goal of the algorithm is to ﬁnd out whether the path is valid in the shell model
and whether the policies that were used when the certiﬁcates were constructed
comply with the preferences of the user. Checking the latter is responsible for the
algorithm being so complex. Obviously, it would be easier if all the certiﬁcates
in the path were constructed under the same policy and if the user accepts this
policy. Apparently, the inventors of the algorithm found this too restrictive. Thus,
the algorithm allows policies that are equivalent. The equivalence of policies
is determined by the certiﬁcates in the path, which may map policies to other
equivalent policies. To deal with the possibility of policy mapping, the algorithm

136
9
Certiﬁcation Paths: Retrieval and Validation
A
C
B
D
E
F
G
Fig. 9.7 An example of a
PKI hierarchy
constructs a valid policy tree. The existence of a valid policy tree at the time when
the algorithm terminates indicates that the certiﬁcation path is valid.
The algorithm receives several inputs. One input is the certiﬁcation path to be
validated and the time at which it is to be validated. The last element of the path is the
certiﬁcate to be validated. The trust anchor is not included in this path. It is provided
separately to the algorithm. As second input, the algorithm receives information
about the preferences of the user who validates the path regarding policies. For
example, a set of identiﬁers of certiﬁcate policies is supplied that are accepted
by the user. Also, information is provided whether or not the user accepts policy
mapping.
The algorithm proceeds in four steps. The workﬂow of the algorithm is depicted
in Fig. 9.8. The ﬁrst step is the initialization, which is performed exactly once. In
this step, a number of variables are initialized that are modiﬁed during the algorithm.
For example, parameters for certiﬁcate veriﬁcation and the valid policy tree are
initialized. After the initialization the algorithm validates the certiﬁcates iteratively
in the basic certiﬁcate processing. This step is executed as many times as there
are certiﬁcates in the path unless the algorithm terminates before all certiﬁcates are
processed. In this step, signature veriﬁcation is performed, it is checked whether the
validity period of the certiﬁcate contains the validation time, and the policy tree is
updated. Each of these processes can lead to the termination of the algorithm, in
which case the certiﬁcation path is invalid. As long as there are more certiﬁcates
to be processed, basic certiﬁcate processing is followed by preparation for the next

9.5
Server-Based Certiﬁcate Validation Protocol (SCVP)
137
Certification Path Validation Algorithm
basic certiticate
processing
wrap-up
preparation for
the next
certificate
initialization
failure
current time
initial policy
set
trust anchor
information
inhibit
policy
mapping
explicit
policy
inhibit
anyPolicy
certification
path
[more certificates
follow in the path]
[last certificate in
the path]
failure
indication
failure
reason
success
indication
public key
public key
algorithm
public key
parameters
policy tree
permitted
subtrees
excluded
subtrees
Fig. 9.8 UML activity diagram of RFC 5280 path validation algorithm
certiﬁcate. For example, in this step the parameters for verifying the validity of
the next certiﬁcate are extracted and policy mapping is processed. The last step is
wrap-up. It is performed once and gathers the output information. If the algorithm
is successful, it outputs a success indicator, a valid policy tree, and the public key
that has been veriﬁed to belong to the subject in the last certiﬁcate in the path.
9.5
Server-Based Certiﬁcate Validation Protocol (SCVP)
Some clients outsource certiﬁcation path construction and validation because these
tasks are too complex for them or they do not have access to necessary resources
such as certiﬁcate archives. This is why the server-based certiﬁcate validation
protocol (SCVP) has been speciﬁed in [7].
This protocol is based on a client-server architecture. The clients make a request
(CVRequest) and get a response (CVResponse) from the server. For authenticity
purposes, both the request and the response may be signed or authenticated by a
MAC. Correspondingly, the SCVP messages are placed in a SignedData or an
AuthenticatedData container, which, in turn, is placed in a ContentInfo
message (see [10]). The messages exchanged between client and server are speciﬁed
in ASN.1 and are DER-encoded.

138
9
Certiﬁcation Paths: Retrieval and Validation
Typical content of a client request is the following.
•
The certiﬁcate for which a certiﬁcation path is to be constructed and validated. It
may be a public key certiﬁcate or an attribute certiﬁcate. There may be even more
than one certiﬁcate of the same type. Alternatively, references of the certiﬁcates
may be included.
•
The tasks that the server is expected to perform: certiﬁcation path construction,
or validation, or both, potentially with additional consideration of revocation
information.
•
The expected return values such as CRLs or OCSP responses.
•
The policy (see [17]) according to which the server is expected to perform the
validation.
•
The trust anchors accepted by the user.
•
Previous SCVP responses if the client wishes an alternative response.
•
The point in time for which the server should perform the speciﬁed tasks. For
example, this allows the client to validate a signature at signature time.
•
Certiﬁcates that may be used by the server in the certiﬁcation path construction.
•
Revocation information such as CRLs or OCSP responses.
•
Speciﬁcation of how old acceptable cached responses may be.
Upon receiving a request, the server tries to create and validate appropriate
certiﬁcation paths, for example, by connecting to repositories, OCSP servers, or
other SCVP servers. Then it returns a response to the client.
9.6
Relevant Certiﬁcate Extensions
There are several certiﬁcate extensions that are relevant for certiﬁcation path
construction and validation. Two of them are described in this section.
9.6.1
Authority Information Access
The private extension authority information access (see [5]) of a certiﬁcate C can
point to certiﬁcates that precede C in a certiﬁcation path. This supports certiﬁcation
path building. The extension can also point to an OCSP server that provides
revocation information regarding C. The extension has an accessMethod ﬁeld
that describes its content and an accessLocation ﬁeld.
The possible access methods are caIssuers and ocsp. They are represented
by the corresponding OIDs. caIssuers indicates that the extension points to cer-
tiﬁcates issued to the issuer of the certiﬁcate. The corresponding accessLocation
ﬁeld points to a location where these certiﬁcates can be found. The purpose of
this information is to aid certiﬁcate users in the certiﬁcation path construction. The
ocsp access method indicates that the extension points to an OCSP server that can

9.6
Relevant Certiﬁcate Extensions
139
Certiﬁcate A
Serial No.: 1
Issuer:
CN=Root CA
NotBefore: 2009-01-01
NotAfter:
2014-12-31
Subject:
CN=Root CA
Public Key: key-0x77004433
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 2
KeyUsage: critical
keyCertSign
Certiﬁcate Policies: critical
ANY
Certiﬁcate B
Serial No.: 2
Issuer:
CN=Root CA
NotBefore: 2009-01-02
NotAfter:
2012-12-31
Subject:
CN=CA1
Public Key: key-0xBBDD5588
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 1
KeyUsage: critical
keyCertSign
Certiﬁcate Policies: critical
green, blue, ANY
Certiﬁcate C
Serial No.: 3
Issuer:
CN=CA1
NotBefore: 2010-01-01
NotAfter:
2012-12-31
Subject:
CN=CA2
Public Key: key-0x12340987
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 0
KeyUsage: critical
keyCertSign
Certiﬁcate Policies: critical
green, yellow
Certiﬁcate D
Serial No.:
25
Issuer:
CN=CA2
NotBefore:
2012-01-01
NotAfter:
2012-12-31
Subject:
CN=Bob
Public Key: key-0x80907060
X509v3Extensions:
KeyUsage: critical
dataEncipherment
Certiﬁcate Policies: critical
yellow
Fig. 9.9 Certiﬁcation hierarchy to be validated
provide status information about the certiﬁcate. The corresponding accessLocation
ﬁeld points to this OCSP server.
The extension may contain several access method and access location ﬁelds.
9.6.2
Subject Information Access
The purpose of this private extension is to provide references to locations of data
and services associated to the subject of the certiﬁcate.
It has the same syntax as the authority information access extension containing
access method and access location pairs. Two access methods are deﬁned. One is
caRepository, which is used only in CA certiﬁcates. It provides the location of
a directory where the CA that is the subject of the certiﬁcate publishes certiﬁcates
that it issues. The second method is timeStamping, which is used only in end

140
9
Certiﬁcation Paths: Retrieval and Validation
Table 9.2 Input variables of
the algorithm
cp
date
uips
public key
ipolmap_inh
iexpol
iapol_inh
ipersub
iexsub
Table 9.3 Variables of the
algorithm and their values
during execution
Variables
Iteration
i D 1
i D 2
i D 3
(Wrap-up)
v_p_t
ex_pol
in_ap
pol_map
w_pk
w_iss
m_path
entity certiﬁcates that belong to time-stamping servers and provides the location of
a time-stamping server.
9.7
Exercises
9.1. Consider the certiﬁcates given in Fig. 9.9. Appendix A is required for solving
the exercise.
Alice veriﬁes the authenticity of Bob’s public key on 2012-03-23 using the path
validation algorithm. Her trust anchor is the “Root CA”.
1. Create a tree that depicts the certiﬁcation hierarchy for these certiﬁcates.
2. What is the length n of the certiﬁcation path cp?
3. Alice allows all policies, even the anyPolicy, but she wants the certiﬁcates to
satisfy at least one explicit policy. She also allows policy mapping and does not
put any constraints on the names contained in the certiﬁcates. Enter the values of
the input variables in Table 9.2. See Appendix A for the meaning of the variable
names.
4. Enter the states of the algorithm at the beginning of each iteration (Table 9.3).
5. Draw the valid policy tree v_p_t.
6. What is the output of the algorithm?

References
141
References
1. R. Arends, R. Austein, M. Larson, D. Massey, S. Rose, Resource records for the DNS security
extensions, in IETF Request for Comments, 4034, Mar 2005
2. D. Chadwick, Deﬁciencies in LDAP when used to support PKI. Commun. ACM 46(3), 99–104
(2003)
3. D.W. Chadwick, S. Anthony,
Using WebDAV for improved certiﬁcate revocation and
publication, in Proceedings of Public Key Infrastructure: 4th European PKI Workshop: Theory
and Practice, EuroPKI 2007, June 2007, Palma de Mallorca. Volume 4582 of Lecture Notes in
Computer Science, pp. 265–279
4. M. Cooper, Y. Dzambasow, P. Hesse, S. Joseph, R. Nicholas,
Internet X.509 public key
infrastructure: certiﬁcation path building, in IETF Request for Comments, 4158, Sept 2005
5. D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 5280, May 2008
6. L. Dusseault, HTTP extensions for web distributed authoring and versioning (WebDAV), in
IETF Request for Comments, 4918, June 2007
7. T. Freeman, R. Housley, A. Malpani, D. Cooper, W. Polk, Server-based certiﬁcate validation
protocol (SCVP), in IETF Request for Comments, 5055, Dec 2007
8. P. Gutmann, Internet X.509 public key infrastructure operational protocols: certiﬁcate store
access via HTTP, in IETF Request for Comments, 4387, Feb 2006
9. R. Harrison,
Lightweight directory access protocol (LDAP): authentication methods and
security mechanisms, in IETF Request for Comments, 4513, June 2006
10. R. Housley, Cryptographic message syntax (CMS), in IETF Request for Comments, 5652, Sept
2009
11. R. Housley, P. Hoffman, Internet X.509 public key infrastructure operational protocols: FTP
and HTTP, in IETF Request for Comments, 2585, May 1999
12. Internet Assigned Numbers Authority IANA, Simple authentication and security layer (SASL)
mechanisms, http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xml
13. S. Josefsson, Storing certiﬁcates in the domain name system (DNS), in IETF Request for
Comments, 4398, Mar 2006
14. S. Legg, Lightweight directory access protocol (LDAP) and X.500 component matching rules,
in IETF Request for Comments, 3687, Feb 2004
15. S. Legg, Lightweight directory access protocol (LDAP): the binary encoding option, in IETF
Request for Comments, 4522, June 2006
16. S.S. Lim, J.H. Choi, K.D. Zeilenga, Design and implementation of LDAP component matching
for ﬂexible and secure certiﬁcate access in PKI, in Online Proceedings of the 4th Annual PKI
R&D Workshop, Gaithersburg, Apr 2005. http://middleware.internet2.edu/pki05/proceedings/
17. D. Pinkas, R. Housley,
Delegated path validation and delegated path discovery protocol
requirements, in IETF Request for Comments, 3379, Sept 2002
18. Recommendation X.509 ITU-T, Information technology – open systems interconnection – the
directory: public-key and attribute certiﬁcate frameworks, Aug 2005
19. M. Smith, Deﬁnition of the inetOrgPerson LDAP object class, in IETF Request for Comments,
2798, Apr 2000
20. M. Smith, T. Howes, Lightweight directory access protocol (LDAP): string representation of
search ﬁlters, in IETF Request for Comments, 4515, June 2006
21. M. Smith, T. Howes, Lightweight directory access protocol (LDAP): uniform resource locator,
in IETF Request for Comments, 4516, June 2006
22. K. Zeilenga, Lightweight directory access protocol (LDAP): technical speciﬁcation road map,
in IETF Request for Comments, 4510, June 2006
23. K. Zeilenga,
Lightweight directory access protocol (LDAP) schema deﬁnitions for X.509
certiﬁcates, in IETF Request for Comments, 4523, June 2006

Chapter 10
PKI in Practice
In this chapter we present applications that use public key cryptography and PKIs.
In these applications both PGP- and X.509-based infrastructures can be used. While
X.509 is mostly used in commercial applications, PGP is popular in the private
sector.
10.1
Internet
Important PKI-based Internet protocols are SSL and TLS. These protocols support
conﬁdential and authenticated channels between clients and servers. The current
version of TLS is speciﬁed in [5], which replaces [4]. TLS is the successor of SSL
2.0 and 3.0 [11], speciﬁed by Netscape.
An important example of the application of TLS is Web-based e-commerce.
A typical scenario is the following. A Web shop has an X.509 certiﬁcate and
the corresponding private key which TLS uses to establish a secure channel
between customers and the Web shop. Typically, this channel has two properties.
The Web shop is authenticated to the customer and the communication between
the Web shop and the customer is conﬁdential. Thus, sensitive data such as name,
address, and credit card number of the customer are protected from unauthorized
access. TLS also supports client authentication, which also requires the clients
to have a certiﬁcate. However, this feature is usually not used in e-commerce. A
similar application of TLS is the protection of home banking applications. In such
applications it is essential that the bank customer authenticates himself or herself to
the bank. For this purpose, he or she possesses a private key and a certiﬁcate which
are usually stored on a smart card provided by the bank.
Another application of TLS is HTTPS, a combination of TLS with the HTTP
protocol. For example, HTTPS is used to authenticate Web pages. Figure 10.1 shows
the TLS secured Web page of Springer. The fact that a Web page is HTTPS-secured
is indicated by Web browsers. Firefox displays an icon in front of the URL. Clicking
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7__10, © Springer-Verlag Berlin Heidelberg 2013
143

144
10
PKI in Practice
Fig. 10.1 TLS-secured Springer Web page
on the icon causes Firefox to display more information about the secure connection,
as shown in Fig. 10.1. Further clicking shows even more information, such as the
cryptographic algorithms used (see Fig. 10.2). Firefox and other browsers also let
users examine server certiﬁcates (Fig. 10.3) and certiﬁcation paths (Fig. 10.4). Such
a path starts from a certiﬁcate which is directly trusted by the browser. If such a
certiﬁcate does not exist, the browser displays a warning about a possibly insecure
TLS connection.
TLS is also used in combination with other protocols used on the Internet, such
as LDAP [13], POP3 [17], IMAP [17], SMTP [14], and FTP [10]. To address attacks
against TLS, the protocol has been extended (see [21]).
Certiﬁcates that are used for TLS connections have speciﬁc content. Server
certiﬁcates contain the serverAuth value (OID “1.3.6.1.5.5.7.3.1”) in their
extended key usage extension. Client certiﬁcates contain the clientAuth value
(OID “1.3.6.1.5.5.7.3.2”) in the same extension.
10.2
Email
PKI can also provide end-to-end email security. End-to-end security refers to
conﬁdentiality, authenticity, and non-repudiation. We explain two standards that
provide such security.

10.2
Email
145
Fig. 10.2 Details of a TLS-secured Web site
10.2.1
S/MIME
One of the most important email security standards is secure/multipurpose Internet
mail extensions (S/MIME), deﬁned in [20]. The use of X.509 certiﬁcates in
connection with S/MIME is speciﬁed in [19]. This document requires the certiﬁcate
processing requirements described in [2] to be implemented by the email client and
introduces some additional requirements. For example, if the certiﬁcate contains
the extended key usage extension, it must contain the emailProtection
(“1.3.6.1.5.5.7.3.4”) or anyExtendedKeyUsage (“2.5.29.37.0”) OID.
We explain how S/MIME works when the two parties Alice and Bob exchange
emails using the Thunderbird email client. Both parties have a certiﬁcate issued by
the certiﬁcation authority CDC-CA. Figures 10.5–10.7 show the certiﬁcate cate-
gories stored by the Thunderbird certiﬁcate manager. As shown in Fig. 10.5, Alice
installed her own X.509 certiﬁcate together with her private key in the category
Your Certiﬁcates. As seen in Fig. 10.6, she installed Bob’s X.509 certiﬁcate in the
category People. Figure 10.7 also shows the category Authorities, where the CDC-
CA root certiﬁcate is installed.
As seen in Figs. 10.8 and 10.9, working with S/MIME emails only slightly differs
from working with unsecured emails once all necessary certiﬁcates are properly
installed. Figure 10.8 shows Alice writing an encrypted and signed message to Bob

146
10
PKI in Practice
Fig. 10.3 Server certiﬁcate
using S/MIME. The only difference with writing an unsecured message is that the
S/MIME menu is opened and the options Encrypt This Message and Digitally Sign
This Message are selected. The current security settings are shown in the lower
right corner of the email editor. Encryption is symbolized by a padlock symbol and
email signature is indicated by a sealed envelope. Each of these settings can be
set as a default by the user. When using S/MIME it is important to know that the
email header is not encrypted even if email encryption is used. Thus, a potential
eavesdropper can still see who is communicating with whom and can read the
subject line.
Figure 10.9 shows Bob reading Alice’s message. Encrypted emails are automat-
ically displayed in clear but remain encrypted in the mailbox. Signed emails are
automatically veriﬁed. The security settings of the email are indicated in the upper
right corner of the email window. As before, an encrypted email is symbolized by

10.2
Email
147
Fig. 10.4 Certiﬁcation path to the server certiﬁcate (the root certiﬁcate is trusted by the browser)
a padlock and a signed email is indicated by a sealed envelope. If decryption or
veriﬁcation fails, a warning is displayed.
10.2.2
PGP
Another important email security standard is PGP. It is standardized as OpenPGP
in [1]. The corresponding open-source implementation is GnuPG [12]. PGP email
security comes in different ﬂavors, such as PGP/INLINE as deﬁned in [1] and
PGP/MIME as deﬁned in [6]. While PGP/INLINE includes encrypted messages and
signatures in the standard email body, PGP/MIME uses a specialized email format.
As this is transparent to the regular user, we do not go into details here.

148
10
PKI in Practice
Fig. 10.5 Your certiﬁcates
Fig. 10.6 People

10.2
Email
149
Fig. 10.7 Authorities
Fig. 10.8 Alice sends an S/MIME secured email

150
10
PKI in Practice
Fig. 10.9 Bob receives an S/MIME secured email
Fig. 10.10 Alice’s PGP keys
As an example, again consider email communication between Alice and Bob
using the email client Thunderbird together with EnigMail [7]. Alice and Bob both
have their own and the other party’s PGP certiﬁcates. Figures 10.10 and 10.11
show Alice’s OpenPGP Key Management interface. As seen in Fig. 10.10, Alice has

10.2
Email
151
Fig. 10.11 Bob’s PGP certiﬁcate
Fig. 10.12 Alice sends a PGP secured email
installed her own PGP certiﬁcate along with her private key. As seen in Fig. 10.11,
Alice also installed Bob’s PGP certiﬁcate.
PGP secured emails are as easy to use as unsecured emails as soon as the
appropriate certiﬁcates are installed. Figure 10.12 shows Alice writing a PGP signed
and encrypted email to Bob. She opens the OpenPGP menu and checks Encrypt

152
10
PKI in Practice
Fig. 10.13 Bob receives a PGP secured email
Message and Sign Message. The chosen security settings are indicated in the lower
right corner of the email editor. The presence of the pencil symbol means that emails
are signed and the key symbol stands for email encryption. Both, email encryption
and signature, can be set as defaults by the user. As S/MIME, PGP does not encrypt
email headers.
Figure 10.13 shows Bob reading Alice’s email. Signed emails are automatically
veriﬁed. Encrypted emails are displayed in clear but remain encrypted in the
mailbox. The security status of the email is displayed in the highlighted bar in
the upper part of the email viewer window. In our example, decryption and signature
veriﬁcation were successful. If decryption or signature veriﬁcation are unsuccessful,
a warning is displayed in the bar. The security settings of the email are also indicated
in the lower right corner of the email viewer window. As before, a signed email is
indicated by a pencil, an encrypted message is symbolized by a key. Additionally,
the symbols known from S/MIME indicate the security status in the upper right
corner.
10.3
Code Signing
Software manufacturers digitally sign their software distributions in order to
authenticate their software and respective updates to the users, a practice also known
as code signing. Code signing is a very important countermeasure against attacks
that use viruses and Trojan horses.

10.3
Code Signing
153
Fig. 10.14 Installing a digitally signed windows update
Signed software should only be installed if the signature has been successfully
veriﬁed. Figure 10.14 shows the protection of Microsoft Windows updates. The
same is done for most other operating systems. Although it is not secure, in some
applications users may also choose to install software with unveriﬁed signatures.
Code signing can also be used to give certain rights to Java applets that run in
a Java-enabled browser. For example, signed applets may be allowed to read from
and write to the client ﬁle system, to establish connections to the Internet, or to
communicate with external ports such as the serial or parallel port. Figures 10.15–
10.17 show the windows that appear during signature veriﬁcation.
Another application of code signing is WebStart [18], which allows distributing
applications over a network. This works as follows. The WebStart server distributes
the application. Clients connect to the server and download the WebStart application
which then runs on the client machine just as applets run in a browser. The WebStart
application checks for updates, which it downloads automatically. This mechanism
simpliﬁes bug ﬁxing and adding new features. Code signing authorizes WebStart
applications to access resources on the client computer.
In certiﬁcates that are being used for code signing, the extended key usage
extension should be set and contain the codeSigning OID “1.3.6.1.5.5.7.3.3”.
Otherwise, most applications cannot use the certiﬁcates in this context.

154
10
PKI in Practice
Fig. 10.15 A dialog box asking for permission to run a signed applet
Fig. 10.16 Information about applet signature veriﬁcation
10.4
VPN
PKI is also useful for protecting virtual private networks (VPNs). VPNs establish
connections between remote computers and local area networks (LANs) as if they
were part of the network. For example, VPNs are used by employees on business
trips to connect to the LAN of their company or to connect branches of a company in

10.4
VPN
155
Fig. 10.17 Information about the certiﬁcate that is used to verify the applet signature
different countries. VPN security is implemented based on protocols such as IPsec
[15], SSH [23], or TSL/SSL [5]. The frequently used VPN software OpenVPN is
based on TSL/SSL and supports X.509 certiﬁcate-based authentication.
We show an example of how VPN is used. Alice remotely connects her laptop
to the LAN of her university research group using OpenVPN. She uses her
client certiﬁcate to authenticate herself to the VPN server. Conversely, the server
authenticates itself to Alice using its server certiﬁcate. Figure 10.18 shows Alice’s
client certiﬁcate. Note that the certiﬁcate is not issued to Alice, but to her laptop
lap58. Figure 10.19 shows the root certiﬁcate that is used by Alice’s VPN client
to authenticate the VPN server.
As seen in Figs. 10.20 and 10.21, both certiﬁcates are involved in establishing
the VPN connection. Figure 10.20 shows Alice’s VPN conﬁguration ﬁle. Line 9
speciﬁes the ﬁle name of the VPN root certiﬁcate. Lines 10 and 11 specify the
ﬁle names of Alice’s laptop’s certiﬁcate and private key. Line 17 speciﬁes the DN
of the VPN server to connect to. Figure 10.21 shows the log ﬁle resulting from
Alice establishing the VPN connection. Lines 288–290 document the successful
veriﬁcation of the VPN gateway certiﬁcate. Lines 291–294 show the so-called
cipher suite that deﬁnes which cryptographic mechanisms are used for the TLS
channel. They are AES-128-CBC and SHA1 for both directions (to and from the
server), which means that the data is encrypted using 128-bit AES in cipher block
chaining (CBC) mode and authenticated with HMAC [16] using the SHA1 hash
algorithm.

156
10
PKI in Practice
Fig. 10.18 Alice’s VPN
certiﬁcate
10.5
Legally Binding Electronic Signatures
Digital signatures may also replace handwritten signatures in legally binding
contracts when the contracts were issued electronically. Legally binding signatures
are deﬁned in related signature laws. An overview of such laws of various countries
can be found in [8].
Many European countries have laws that are compatible with the 1999/93/EC
directive of the European Union [9]. This directive speciﬁes the advanced electronic
signature. Such a signature must be uniquely linked to the signer; it must support
signer identiﬁcation and protection against unauthorized modiﬁcation of the signed
data. The European directive requires certiﬁcates that are used for legally binding
signatures, so-called qualiﬁed certiﬁcates, to be issued by certiﬁcation service
providers that must satisfy a number of requirements such as providing directory
services, supporting immediate certiﬁcate revocation, and obtaining and verifying
the identity of the certiﬁcate owner. If the certiﬁcate owner chooses to use a
pseudonym, the CSP must be able to link the pseudonym with the identity of the
certiﬁcate owner. The directive does not specify the certiﬁcate format, but X.509 is
the defacto standard.

10.5
Legally Binding Electronic Signatures
157
Fig. 10.19 VPN root certiﬁcate
Fig. 10.20 VPN conﬁguration ﬁle

158
10
PKI in Practice
Fig. 10.21 VPN connection log
Fig. 10.22 Government Gateway homepage

10.6
E-Government
159
Fig. 10.23 Government Gateway registration
The German law also deﬁnes so-called qualiﬁed signatures that compared
with advanced signatures have many additional features. For example, such sig-
natures must be created using secure devices speciﬁed by the German signature
ordinance.
In Germany, qualiﬁed signatures may be used in many contexts as a replacement
of handwritten signatures. We present a few examples. Certain companies must
document their waste management. Such documentation requires legally binding
signatures which may be issued as qualiﬁed signatures on electronic documents.
Electronic documentation allows for very efﬁcient management. Another applica-
tion of qualiﬁed signatures is e-justice, for example interaction with the courts over
the Internet. Also, the German patent ofﬁce accepts applications that are signed with
qualiﬁed signatures.
10.6
E-Government
PKI is also useful to secure e-government applications. This can be done using
legally binding electronic signatures as described in Sect. 10.5, but also by other
mechanisms. The term e-government refers to electronic transactions between a
government and citizens, companies, or other entities within this government’s
range of authority. Frequently, strong authentication, protection of integrity and con-
ﬁdentiality is a legal requirement for such transactions. Examples of e-government

160
10
PKI in Practice
Fig. 10.24 SimplySign homepage
Fig. 10.25 SimplySign certiﬁcation path download

10.6
E-Government
161
Fig. 10.26 SimplySign root
certiﬁcate
applications are electronic citizen portals, electronic voting, and electronic tax
declarations.
For example, if the London citizen Alice wants to manage her council tax account
online, she ﬁrst has to register with the service. Being a UK citizen, she does this
at the UK Government Gateway [3]. As seen in Fig. 10.22, this gateway allows for
registration of individuals, organizations and agents that act on behalf of others. She
follows the registration process for individuals. In the ﬁrst step depicted in Fig. 10.23
she has to decide whether she wants to use a certiﬁcate or not.
Alice is security-aware, and decides to use a certiﬁcate. As she does not yet have a
proper certiﬁcate, she has to apply for one from a proper CSP. In our example, Alice
decides to get a certiﬁcate from SimplySign [22]. Figure 10.24 shows SimplySign’s
home page, where we can see that Alice has to pay an annual fee for her certiﬁcate.
She accepts the registration with SimplySign. As seen in Fig. 10.25, the ﬁrst thing
she has to do is to download and install the respective certiﬁcation path to her
browser.
Figure 10.26 shows SimplySign’s root certiﬁcate, which is a self-signed certiﬁ-
cate. Figure 10.27 shows SimplySign’s issuing authority certiﬁcate, which is signed
by SimplySign’s root.

162
10
PKI in Practice
Fig. 10.27 SimplySign
issuing authority
After applying for her certiﬁcate and installing it in her browser, she goes back
to the Web site of the Government Gateway and ﬁnalizes the registration using her
certiﬁcate. Once logged in, she can choose the e-government service she wants
to use from a list. Figure 10.28 shows the list as presented by the Government
Gateway. Note that for each service the provision of further information, such as
the tax number, and additional registration might be necessary.
10.7
Exercises
10.1. Alice wants to send an encrypted email to Bob. Although she possesses Bob’s
certiﬁcate and has installed it in her email client, the client refuses to send the email.
Give possible reasons for the behavior of the email client.

References
163
Fig. 10.28 Government Gateway services
References
1. J. Callas, L. Donnerhacke, H. Finney, D. Shaw, R. Thayer, OpenPGP message format, in IETF
Request for Comments, 4880, Nov 2007
2. D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public
key infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle, in IETF Request for
Comments, 5280, May 2008
3. Department for Work and Pensions: Government Gateway, http://www.gateway.gov.uk/
4. T. Dierks, E. Rescorla, The transport layer security (TLS) protocol version 1.1, in IETF Request
for Comments, 4346, Apr 2006
5. T. Dierks, E. Rescorla, The transport layer security (TLS) protocol version 1.2, in IETF Request
for Comments, 5246, Aug 2008
6. M. Elkins, D. Del Torto, R. Levien, T. Roessler, MIME security with OpenPGP, in IETF
Request for Comments, 3156, Aug 2001
7. EnigMail project, http://whttp://www.enigmail.net
8. eSignatures Legal Wiki, http://www.esignaturelegalwiki.org
9. European Parliament and Council, Directive 1999/93/EC of the European Parliament and of
the Council of 13 Dec 1999 on a Community framework for electronic signatures, Dec 1999
10. P. Ford-Hutchinson, Securing FTP with TLS, in IETF Request for Comments, 4217, Oct 2005
11. A. Freier, P. Karlton, P. Kocher, The secure sockets layer (SSL) protocol version 3.0, in IETF
Request for Comments, 6101, Aug 2011
12. GNU Privacy Guard, http://www.gnupg.org/
13. R. Harrison, Lightweight directory access protocol (LDAP): authentication methods and
security mechanisms, in IETF Request for Comments, 4513, June 2006
14. P. Hoffman, SMTP service extension for secure SMTP over transport layer security, in IETF
Request for Comments, 3207, Feb 2002

164
10
PKI in Practice
15. S. Kent, K. Seo, Security architecture for the internet protocol, in IETF Request for Comments,
4301, Dec 2005
16. H. Krawczyk, M. Bellare, R. Canetti, HMAC: keyed-hashing for message authentication, in
IETF Request for Comments, 2104, Feb 1997
17. C. Newman, Using TLS with IMAP, POP3 and ACAP, in IETF Request for Comments, 2595,
June 1999
18. ORACLE, Java Web Start Technology,
http://www.oracle.com/technetwork/java/javase/
javawebstart/index.html
19. B. Ramsdell, S. Turner, Secure/multipurpose internet mail extensions (S/MIME) version 3.2
certiﬁcate handling, in IETF Request for Comments, 5750, Jan 2010
20. B. Ramsdell, S. Turner, Secure/multipurpose internet mail extensions (S/MIME) version 3.2
message speciﬁcation, in IETF Request for Comments, 5751, Jan 2010
21. E. Rescorla, M. Ray, S. Dispensa, N. Oskov, Transport layer security (TLS) renegotiation
indication extension, in IETF Request for Comments, 5746, Feb 2010
22. SimplySign, SimplySign, http://www.simplysign.co.uk/
23. T. Ylonen, C. Lonvick, The secure shell (SSH) protocol architecture, in IETF Request for
Comments, 4251, Jan 2006

Appendix A
Basic Path Validation Algorithm
The variables that are used in the algorithm are listed in Table A.1
The algorithm builds the so-called valid_policy_tree, which is used to
decide whether there is a valid policy for a certiﬁcate path. The answer is “yes”
if the algorithm is able to construct a valid policy tree of depth n. Otherwise, the
algorithm constructs a null policy tree. The nodes of this tree are called policy nodes.
As shown in Fig. A.1, each policy node has three attributes. The ﬁrst attribute is
the valid_policy. It is one of the policies from the certiﬁcate being processed
by the algorithm. The second attribute is the qualifier_set, which contains
qualiﬁers of this policy. The third attribute is the expected_policy_set.
One of the policies in this set must be valid for the next certiﬁcate in the chain
in order for the tree construction to continue. We represent a policy node by
N D hvp; fqsg; fepsgi where N represents the node, vp is the valid_policy, qs
the qualiﬁer_set, and eps the expected_policy_set.
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7, © Springer-Verlag Berlin Heidelberg 2013
165

166
A
Basic Path Validation Algorithm
Table A.1 Variables of RFC
5280 path validation
algorithm
cp
:
certiﬁcation path
n
:
length of cp
i
:
iteration counter
C
:
current certiﬁcate
uips
:
user-initial-policy-set
ipolmap_inh
:
initial-policy-mapping-inhibit
iexpol
:
initial-explicit-policy
iapol_inh
:
initial-any-policy-inhibit
ipersub
:
initial-permitted-subtrees
iexsub
:
initial-excluded-subtrees
v_p_t
:
valid_policy_tree
p_st
:
permitted_subtrees
ex_st
:
excluded_subtrees
ex_pol
:
explicit_policy
in_ap
:
inhibit_any-policy
pol_map
:
policy_mapping
w_pk
:
working_public_key
w_pk_a
:
working_public_key_algorithm
w_pk_p
:
working_public_key_parameters
w_iss
:
working_issuer_name
m_path
:
max_path_length
ex_pol_s
:
expected_policy_set
v_p_n_s
:
valid_policy_node_set
valid_policy
{ expected_policy_set }
{ qualifier_set }
Fig. A.1 Policy node

A
Basic Path Validation Algorithm
167
Algorithm 1 Initialization
Input: cp of length n
Input: date = current time
Input: uips
Input: Trust anchor information like its name, public key along with its algorithm and parameters
Input: ipolmap_inh
Input: iexpol
Input: iapol_inh
Input: ipersub
Input: iexsub
1: v_p_t D hanyPolicy; fg; fanyPolicygi
2: p_st D ipersub
3: ex_st D iexsub
4: if iexpol D true then ex_pol D 0 else ex_pol D n C 1 end if
5: if iapol_inh D true then in_ap D 0 else in_ap D n C 1 end if
6: if ipolmap_inh D true then pol_map D 0 else pol_map D n C 1 end if
7: set w_pk_a; w_pk; w_pk_p; and w_iss according to trust anchor information
8: m_path = n
9: C = ﬁrst certiﬁcate in the path
10: i = 0

168
A
Basic Path Validation Algorithm
Algorithm 2 Basic certiﬁcate processing
1: i D i C 1
2: if C is not signed with w_pk_a, w_pk, and w_pk_p then
3:
return failure and reason
4: end if
5: if C’s notBefore < date < C’s notAfter then
6:
return failure and reason
7: end if
8: if C is revoked then
9:
return failure and reason
10: end if
11: if C’s issuerDN ¤ w_iss_name then
12:
return failure and reason
13: end if
14: if C is self-issued and it is not the last certiﬁcate in cp then
15:
goto 21
16: else
17:
if C’c subject DN and every subject alternative name contained in C is not contained in
p_st or is contained in ex_st then
18:
return failure and reason
19:
end if
20: end if
21: if C has the certiﬁcate policies extension then
22:
if v_p_t is NOT NULL then
23:
process Policies (Algorithm 3)
24:
end if
25: else
26:
v_p_t = NULL
27: end if
28: if ex_pol > 0 OR v_p_t is NOT NULL then
29:
continue
30: else
31:
return failure and reason
32: end if

A
Basic Path Validation Algorithm
169
Algorithm 3 Process policies
1: for each policy in C other than anyPolicy do
2:
p_oid = current policy
3:
p_q = current policy qualiﬁer
4:
for each node N in v_p_t of depth i  1 with p_oid in ex_pol_s of N do
5:
append child node N 0 D hp_oid; fp_qg; fp_oidgi
6:
if node was not appended in previous step then
7:
for each node N in v_p_t of depth i  1 with anyPolicy as valid_policy do
8:
append child node N 0 D hp_oid; fp_qg; fp_oidgi
9:
end for
10:
end if
11:
end for
12: end for
13: if C contains the policy anyPolicy then
14:
p_q = policy qualiﬁer of anyPolicy
15:
if in_ap > 0 OR (i < n AND C is self-issued) then
16:
for each node N in v_p_t of depth i  1 do
17:
for each policy q_oid in ex_pol_s of N where q_oid does not appear as a child
of N do
18:
append child node N 0 D hq_oid; fp_qg; fq_oidgi
19:
end for
20:
end for
21:
end if
22: end if
23: starting from i  1 recursively delete all nodes of depth less or equal to i  1 that have no
child nodes

170
A
Basic Path Validation Algorithm
Algorithm 4 Preparation for certiﬁcate i C 1
1: process policy mappings (Algorithm 5)
2: w_iss = subjectDN of C
3: w_pk = subjectPublicKey of C
4: if C has subjectPublicKey parameters then
5:
w_pk_p = subjectPublicKey parameters of C
6: else
7:
if w_pk_a ¤ subjectPublicKey algorithm of C then
8:
w_pk_p D null
9:
end if
10: end if
11: w_pk_a = subjectPublicKey algorithm of C
12: if C has the name constraints extension then
13:
if C contains permittedSubtrees then
14:
p_st D p_st \ permittedSubtrees of C
15:
end if
16:
if C contains excludedSubtrees then
17:
ex_st D ex_st [ excludedSubtrees of C
18:
end if
19: end if
20: if C is not self-issued then
21:
ex_pol = max.0; ex_pol  1/
22:
pol_map = max.0; pol_map  1/
23:
in_ap = max.0; in_ap  1/
24: end if
25: if requireExplicitPolicy is set in C then
26:
ex_pol = min.ex_pol, requireExplicitPolicy of C)
27: end if
28: if inhibitPolicyMapping is set in C then
29:
pol_map = min.pol_map, inhibitPolicyMapping of C)
30: end if
31: if inhibitAnyPolicy is set in C then
32:
in_ap = min.in_ap, inhibitAnyPolicy of C)
33: end if
34: if C is not a CA certiﬁcate then
35:
return failure and reason
36: end if
37: if C is not self-issued then
38:
if m_path  0 then
39:
return failure and reason
40:
else
41:
m_path D m_path  1
42:
end if
43: end if
44: if pathLenContraint is set in C then
45:
m_path = min.m_path, pathLenConstraints of C)
46: end if
47: if C has the key usage extension then
48:
if keyCertSign bit is not set then
49:
return failure and reason
50:
end if
51: end if
52: recognize and process other extensions of C and return failure and reason if an unrecognized critical
extension is found
53: C = next certiﬁcate in path

A
Basic Path Validation Algorithm
171
Algorithm 5 Process policy mappings
1: if C has the policy mappings extension then
2:
if anyPolicy is found in issuerDomainPolicy or subjectDomainPolicy then return failure
and reason
3:
end if
4:
for each issuerDomainPolicy do
5:
id_p = current issuerDomainPolicy
6:
spol D set of policies that id_p is mapped to
7:
if pol_map > 0 then
8:
match_found D false
9:
for each node N in v_p_t of depth i with valid_policy D id_p do
10:
ex_pol_s of N D spol
11:
match_found D true
12:
end for
13:
if match_found D false but there is a node N 0 of depth i with valid_policy D
anyPolicy then
14:
p_q = policy qualiﬁer of node N 0
15:
append a node Q to the father of N 0 with Q D hid_p; fp_qg; fspolgi
16:
end if
17:
else
18:
delete each node N of depth i with valid_policy D id_p
19:
starting from i  1 recursively delete all nodes of depth less or equal to i  1 that
have no child nodes
20:
end if
21:
end for
22: else
23:
return
24: end if

172
A
Basic Path Validation Algorithm
Algorithm 6 Wrap-up procedure
1: ex_pol = min.0; ex_pol  1)
2: if C has requireExplicitPolicy = 0 then
3:
ex_pol D 0
4: end if
5: w_pk = subjectPublicKey of C
6: if C has subjectPublicKey parameters then
7:
w_pk_p = subjectPublicKey parameters of C
8: else
9:
if w_pk_a ¤ subjectPublicKey algorithm of C then
10:
w_pk_p D null
11:
end if
12: end if
13: w_pk_a = subjectPublicKey algorithm of C
14: recognize and process other extensions of C and return failure and reason if an unrecognized
critical extension is found
15: if v_p_t ¤ NULL then
16:
if uips is not anyPolicy then
17:
v_p_n_s D set of nodes whose parent nodes have valid_policy anyPolicy
18:
for each node N in v_p_n_s do
19:
if valid_policy of N is not in the uips and is not anyPolicy then
20:
delete N and its children nodes
21:
end if
22:
end for
23:
if v_p_t includes a node N of depth n with valid_policy anyPolicy and uips ¤
anyPolicy then
24:
p_q = qualiﬁer set of node N
25:
for each p_oid in uips that is not the valid_policy of a node N in the v_p_n_s
do
26:
append a node N 0 to the father node of N with N 0 D hp_oid; fp_qg; fp_oidgi
and delete N
27:
starting from i  1 recursively delete all nodes of depth less or equal to i  1
that have no child nodes
28:
end for
29:
end if
30:
else
31:
goto 36
32:
end if
33: else
34:
v_p_t D NULL
35: end if
36: if ex_pol > 0 OR v_p_t ¤ NULL then
37:
return success and output v_p_t, w_pk, w_pk_a, w_pk_p
38: else
39:
return failure and reason
40: end if

Solutions to the Exercises
Exercises of Chap. 1
1.1 The dealer is interested in maintaining the integrity of the list of books. The
messages of the dealer and the customer need to be authenticated. The transactions
need to be conﬁdential to protect the privacy of the customers and the ﬁnancial
information. The order and reply of the dealer must be binding.
1.2 Answer:
•
Properties: Fingerprint, iris, face, or other biometric properties.
•
Abilities: Keyboard stroke, voice.
•
Knowledge: PIN, name of pet.
•
Possession: Smart card, credit card, key.
1.3 Answer:
1. Accessing the database does not enable an adversary to impersonate users since
cryptographic hash functions are one-way. Replay is possible by intercepting the
password hashes and reusing them at a later point in time.
2. The replay attack can be prevented by using a random nonce n as shown in
Fig. A.2.
The nonce may also be the current time.
Exercises of Chap. 2
2.1 There are three versions of X.509 certiﬁcates. X509v1 certiﬁcates do not con-
tain the issuerUniqueID, the subjectUniqueID, or extensions. X509v2 certiﬁcates
contain the issuerUniqueID and subjectUniqueID ﬁelds but no extensions. X509v3
certiﬁcates contain extensions and these two ﬁelds.
2.2 The certiﬁcates are as shown in Figs. A.3 and A.4:
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7, © Springer-Verlag Berlin Heidelberg 2013
173

174
Solutions to the Exercises
Alice
Server
chooses n ∈R Z
n

computes
r = h(n||h(P))
r
-
knows h(P) and n. Checks r ?=
h(n||h(P))
Fig. A.2 Preventing replay attack using nonce
Certiﬁcate 1
Serial No.: 26540
Issuer:
CN=Test CA
NotBefore: 2004-04-03
NotAfter:
2005-04-03
Subject:
CN=Alice
Public Key: key-0x4D367AB9
X509v3Extensions:
KeyUsage: critical
digitalSignature, dataEnciphernemt
Subject Key Identiﬁer:
keyId: 12:AB:45:76:F8:98
Authority Key Identiﬁer:
keyId: BE:76:34:4E:60:34
aci: CN=Master CA
acsn: 34
Certiﬁcate 2
Serial No.: 1
Issuer:
CN=Master CA
NotBefore: 2003-11-14
NotAfter:
2008-11-14
Subject:
CN=Master CA
Public Key: key-0x18FF6542
X509v3Extensions:
Basic Constraints: critical
CA: TRUE
pathlen: 1
KeyUsage: critical
keyCertSign, cRLSign
Subject Key Identiﬁer:
keyId: 11:23:34:AB:65:F0
Authority Key Identiﬁer:
keyId: 11:23:34:AB:65:F0
aci: CN=Master CA
acsn: 1
Fig. A.3 Certiﬁcates 1 and 2 with AKI values
Certiﬁcate 3
Serial No.: 34
Issuer:
CN=Master CA
NotBefore: 2003-11-15
NotAfter:
2008-11-10
Subject:
CN=Test CA
Public Key: key-0x347893B2
X509v3Extensions:
KeyUsage: critical
keyCertSign, cRLSign
Subject Key Identiﬁer:
keyId: BE:76:34:4E:60:34
Authority Key Identiﬁer:
keyId: 11:23:34:AB:65:F0
aci: CN=Master CA
acsn: 1
Fig. A.4 Certiﬁcate 3 with AKI values

Solutions to the Exercises
175
2.3 Answer:
1. Yes, in self-signed certiﬁcates.
2. Yes, if an issuer has issued two certiﬁcates and signed them with the same key.
3. Yes, for certiﬁcates that certify the same public key, for example, due to
certiﬁcate renewal when a certiﬁcate expires.
2.4 Following the ASN.1 deﬁnition of the key usage extension in Listing 2.6, the
key contained in the certiﬁcate can be used for digital signatures, non-repudiation,
and data encipherment. For example, this is possible for RSA keys.
2.5 This is permitted because the certiﬁcates have been issued by different issuers
as indicated by the issuer ﬁeld.
Exercises of Chap. 3
3.1 Table A.2 shows Alice’s key ring with all values.
3.2 Answer:
1. The hash value of a complete X.509 certiﬁcate is used for calculating the
ﬁngerprint of the certiﬁcate. This ﬁngerprint allows us to verify the integrity of
the certiﬁcate, for example, in the context of direct trust.
2. The hash value of the TBS part of an X.509 certiﬁcate is used for creating and
verifying the signature of the certiﬁcate.
3.3 Answer:
1. Alice may trust in any of the three CAs: Root, Org1, or Dep1.
2. Alice may trust in any of the CAs: Root, Org1, or Dep2.
3. Yes. Alice may trust in the Org2 CA directly.
4. No. Alice may trust in the Root CA directly. This would lead to indirect trust in
Org2. Another possibility would be to trust in Org2 directly, which is not desired.
3.4 Answer:
1. Trusted Lists: as entities A, E, H, M, and O are the trust anchors of every end
entity, it is enough to add them to each end entity’s trusted list.
Bridge: the individual PKIs can be bridged as seen in Fig. A.5.
Cross-certiﬁcation: the individual PKIs can be combined by cross-certiﬁcation
as shown in Fig. A.6.
Common Root: the individual PKIs can be combined by putting them under a
common root CA as shown in Fig. A.7.

176
Solutions to the Exercises
Table A.2 Public key ring of
Alice with all values
Public key ring of Alice
1
Public key owner
: Alice
Owner trust/key legitimacy : ultimate/complete
1
Signer/trust in signer
: Alice/ultimate
2
Public key owner
: Bob
Owner trust/key legitimacy : marginal/complete
1
Signer/trust in signer
: Alice/ultimate
2
Signer/trust in signer
: Bob/marginal
3
Signer/trust in signer
: Carl/none
3
Public key owner
: Carl
Owner trust/key legitimacy : none/marginal
1
Signer/trust in signer
: Bob/marginal
2
Signer/trust in signer
: Carl/none
4
Public key owner
: Diana
Owner trust/key legitimacy : unknown/complete
1
Signer/trust in signer
: Bob/marginal
2
Signer/trust in signer
: Carl/none
3
Signer/trust in signer
: Diana/unknown
4
Signer/trust in signer
: Emil/marginal
5
Signer/trust in signer
: Frank/marginal
5
Public key owner
: Emil
Owner trust/key legitimacy : marginal/complete
1
Signer/trust in signer
: Alice/ultimate
2
Signer/trust in signer
: Bob/marginal
3
Signer/trust in signer
: Emil/marginal
6
Public key owner
: Frank
Owner trust/key legitimacy : marginal/complete
1
Signer/trust in signer
: Alice/ultimate
2
Signer/trust in signer
: Frank/marginal
H
J
I
K
L
E
G
F
O
Q
P
R
S
A
C
B
M
N
D
Bridge
Fig. A.5 Bridged individual
PKIs

Solutions to the Exercises
177
H
J
I
K
L
E
G
F
O
Q
P
R
S
A
C
B
M
N
D
Fig. A.6 Cross-certiﬁed individual PKIs
H
J
I
K
L
E
G
F
O
Q
P
R
S
A
C
B
M
N
D
Common Root
Fig. A.7 Individual PKIs under common root CA
Table A.3 Trust anchors
Architecture
Number of trust anchors
Trust anchor of G
Trusted lists
5
A, E, H, M, O
Bridge
1
E
Cross-certiﬁcation
1
E
Common root
1
Common root
2. When trusted lists are used it is not necessary to issue any new certiﬁcate. In the
bridge solution 2n D 10 new certiﬁcates are issued. Cross-certiﬁcation requires
issuing n  .n  1/ D 20 new certiﬁcates. In the common root solution, n D 5
new certiﬁcates are issued.
3. Table A.3 shows the number of trust anchors required in each case and the trust
anchors of entity G.

178
Solutions to the Exercises
Exercises of Chap. 4
4.1 Answer:
1. There are four modes: password-based integrity, password-based conﬁdentiality,
public key-based integrity, and public key-based conﬁdentiality.
2. All four combinations of one conﬁdentiality and one integrity mode are possible.
3. In the password-based modes the secret password must be known both to the
source and to the target platform. In public key integrity mode the private key
is known to the source platform that proves integrity by signing. In public
key conﬁdentiality the private key is known at the target platform that must
decrypt.
4.2 The hash of the document is computed on the PC. This hash is sent to the smart
card via the smart card reader. The smart card signs the hash and sends the signature
via the smart card reader to the PC.
Exercises of Chap. 5
5.1 Answer:
1. The user has complete revocation information.
F 1 C 5
1 ` F 5
(A.1)
F 5 C 10
5 ` F 10
(A.2)
F 10 C 15
10 ` F 15
(A.3)
F 15 ` F 14
(A.4)
2. The user has complete revocation information.
F 12 C 14
10 ` F 14
(A.5)
3. The user does not have complete revocation information. F 2 is missing. If the
user has F 2, then:
F 2 C 5
2 ` F 5
(A.6)
F 5 C 10
5 ` F 10
(A.7)
F 10 C 10
15 ` F 15
(A.8)

Solutions to the Exercises
179
Table A.4 Revocation lists
CRL
CRL number
Base-CRL number
Full CRL on 01-01
0
N/A
Delta CRL on 01-15
2
0
Full CRL on 02-01
4
N/A
Delta CRL on 02-01
4
0
Delta CRL on 02-08
5
4
Delta CRL on 03-08
9
8
5.2 Answer:
1. See Table A.4.
2. The CRL issued on 1 March. It contains 78 entries. This is calculated by adding
the number of all revoked certiﬁcates until this point in time, which is 12 C 4 C
6 C 7 C 1 C 9 C 14 C 3 C 22 D 78.
3. The delta CRL issued on 1 March. It contains 48 entries. This is calculated by
adding the number of all certiﬁcates revoked between 1 February and 1 March,
which is 9 C 14 C 3 C 22 D 48.
4. The user needs at least the complete CRL issued on 1 March. No delta CRLs are
necessary. If the user has downloaded the complete CRL issued on 1 January,
then the delta CRLs issued on 1 February and 1 March are necessary. If the user
has downloaded the complete CRL issued on 1 February, then the delta CRL of
1 March is required.
5.3 Answer:
1. We have the following requirements:
thisUpdateCRL A > thisUpdateCRL C
because CRL A has a greater CRL number than CRL C.
thisUpdateCRL A D thisUpdateCRL B
because CRL A has the same CRL number as CRL B.
thisUpdateCRL A < nextUpdateCRL A
thisUpdateCRL B < nextUpdateCRL B
thisUpdateCRL C < nextUpdateCRL C
This implies the constellation as shown in Fig. A.8.
2. Yes, this can happen if more certiﬁcates than those contained in the Base CRL
are revoked before the next complete CRL is issued.

180
Solutions to the Exercises
CRL A
Issuer:
CA1
ThisUpdate:
2011-08-15
NextUpdate:
2011-09-10
Revoked Certiﬁcates:
Serial No.:
32
Serial No.:
16
Serial No.:
64
Serial No.:
128
X509v2 CRL Extensions:
CRL Number: non-critical
143
CRL B
Issuer:
CA1
ThisUpdate:
2011-08-15
NextUpdate:
2011-09-10
Revoked Certiﬁcates:
Serial No.:
64
Serial No.:
128
X509v2 CRL Extensions:
CRL Number:
non-critical
143
Delta CRL Indicator:
critical
Base CRL Number: 138
CRL C
Issuer:
CA1
ThisUpdate:
2011-08-10
NextUpdate:
2011-08-15 or 2011-09-10
Revoked Certiﬁcates:
Serial No.:
32
Serial No.:
16
X509v2 CRL Extensions:
CRL Number: non-critical
138
Fig. A.8 CRLs with valid values
CRL D
Issuer:
CA1
ThisUpdate:
2011-10-15
NextUpdate:
2011-11-01
Revoked Certiﬁcates:
Serial No.:
456
X509v2 CRL Extensions:
CRL Number:
non-critical
321
Delta CRL Indicator:
critical
Base CRL Number: 234
CRL E
Issuer:
CA1
ThisUpdate:
2011-10-15
NextUpdate:
2011-11-15
Revoked Certiﬁcates:
Serial No.:
232
Serial No.:
136
Serial No.:
164
Serial No.:
987
Serial No.:
456
X509v2 CRL Extensions:
CRL Number: non-critical
321
Fig. A.9 CRL number and base CRL number values
3. The CRLs are shown in Fig. A.9.
The following combinations are permitted.
(a) CRL NumberCRL D D 321
Base CRL NumberCRL D D 234
CRL NumberCRL E D 321
(b) CRL NumberCRL D D 333
Base CRL NumberCRL D D 321
CRL NumberCRL E D 333

Solutions to the Exercises
181
Table A.5 Revoked certiﬁcates
Issuer
Serial number
Revoked
CN D First CA, C D DE
1
True
CN D First CA, C D DE
2
True
CN D First CA, C D DE
3
False
CN D First CA, C D DE
4
False
CN D First CA, C D DE
5
False
CN D Second CA, C D DE
1
False
CN D Second CA, C D DE
2
False
CN D Second CA, C D DE
3
True
CN D Second CA, C D DE
4
True
CN D Second CA, C D DE
5
True
CN D Second CA, C D DE
6
False
CN D Third CA, C D DE
6
True
CN D Third CA, C D DE
7
False
CN D Forth CA, C D DE
6
False
CN D Forth CA, C D DE
7
True
time
2012-03-31
2012-05-31
2010-01-01
2010-03-01
RootCA
SubCA
2012-05-24
2010-05-01
2012-07-31
Alice
2012-10-19
2011-03-15
2012-07-08
2012-01-01
Signature creation
Signature verification
2013-01-01
Fig. A.10 Signature and veriﬁcation time points of Exercise 6.1
(c) CRL NumberCRL D D 333
Base CRL NumberCRL D D 234
CRL NumberCRL E D 333
5.4 The correct values are shown in Table A.5.
Exercises of Chap. 6
6.1 Figure A.10 shows the relevant dates on a time line.
1. Table A.6 shows the validation values.

182
Solutions to the Exercises
Table A.6 Validation in different models
Signature creation time
Shell model
Modiﬁed shell model
Chain model
2010-04-20
Valid
Invalid
Invalid
2011-03-15
Valid
Valid
Valid
Table A.7 Validation for different signature times
Signature creation time
Shell model
Modiﬁed shell model
Chain model
2011-03-15
Invalid
Valid
Valid
2012-05-24
Invalid
Invalid
Valid
2012-07-08
Invalid
Invalid
Valid
2012-10-19
Invalid
Invalid
Invalid
Table A.8 Valid signature
creation times
Model
From
Until
Shell
2010-05-01
2012-03-31
Modiﬁed shell
2010-05-01
2012-03-31
Chain
2010-05-01
2012-07-31
2. Table A.7 shows the validation values.
3. Table A.8 shows the valid signature creation times.
Exercises of Chap. 7
7.1 Answer:
1. Certiﬁcate 4 is a root certiﬁcate and a CA certiﬁcate. A root certiﬁcate can be
identiﬁed by the fact that it is self-signed since the keyIdentiﬁer of the AKIE and
SKIE are the same. Certiﬁcate 5 is a CA certiﬁcate but not a root certiﬁcate. This
can be seen from the basic constraints extension.
2. To ﬁnd the public key of the issuer of certiﬁcate Z, a certiﬁcate must be found in
which the subject is the issuer of Z. If there are several such certiﬁcates, they
must all be tried. An alternative is to ﬁnd a certiﬁcate in which the subject
key identiﬁer is equal to the authority key identiﬁer of Z. A third possibility
is to ﬁnd a certiﬁcate in which the issuer and the serial number are equal to the
authorityCertIssuer and authorityCertSerialNumberin the authority key identiﬁer
extension in certiﬁcate Z.
3. The key usage extension is marked critical. This means that the application must
reject the certiﬁcate if it cannot interpret this extension.
4. The CA needs Bob’s public key. PoP can be implemented by having Bob sign a
challenge, typically the public key combined with a random number to prevent
replay attacks. For example, this is done in PKCS#10.

Solutions to the Exercises
183
Root CA
CA1
CA2
Bob
C
B
D
A
Fig. A.11 Certiﬁcation
hierarchy for the certiﬁcates
of Exercise 9.1
Table A.9 Input variables of
the algorithm
cp
Certiﬁcates B, C, and D
date
2012-03-23
uips
{ ANY }
public key
Key-0x77004433
ipolmap_inh
False
iexpol
True
iapol_inh
False
ipersub
{}
iexsub
{}
5. Since the key may only be used for encryption (key usage), signing cannot be
used in the PoP. Now there are two options. The direct method: Upon receiving
the public key, the registration authority sends an encrypted random number
to the owner of the public key who decrypts it and sends it back. The indirect
method: The RA accepts the public key without checking it. The CA generates
the certiﬁcate and encrypts it with the public key. The participant can only use
the certiﬁcate if he can decrypt it.
6. A certiﬁcate binds an identity to a public key. The CA must ensure that the
corresponding key pair exists. For example, this may not be the case if the public
key is changed because of transmission errors. Without PoP for signature keys
the following attack is possible. The adversary asks for a certiﬁcate containing
his own identity as the subject but the public key of another entity. Then, the
signatures of the other entity will be interpreted as the signatures of the adversary.
7. This makes sense for Certiﬁcates 2 and 3. They contain encryption keys. A key
backup allows encrypted data to be decrypted even if the private key is lost.

184
Solutions to the Exercises
Table A.10 Variables of the algorithm and their values during execution
Variables:
Iteration
i D 1
i D 2
i D 3
(wrap-up)
v_p_t
See Fig. A.12
ex_pol
0
0
0
0
in_ap
4
3
2
2
pol_map
4
3
2
2
w_pk
0x77004433
0xBBDD5588
0x12340987
0x80907060
w_iss
CN D RootCA
CN D CA1
CN D CA2
CN D CA2
m_path
3
1
0
0
ANY
{ ANY }
{ }
green
{ green }
{ }
yellow
{ yellow }
{ }
blue
{ blue }
{ }
ANY
{ ANY }
{ }
green
{ green }
{ }
yellow
{ yellow }
{ }
i=0
i=2
i=3
i=1
deleted
in i=3
deleted
in i=3
deleted
in i=2
Fig. A.12 The v_p_t during the execution of the algorithm
Exercises of Chap. 8
8.1 Answer:
1. Certiﬁcate A maps policy magenta to policy red, but magenta is not listed in the
certiﬁcate policies. Although this should not be used, the certiﬁcate is valid.

Solutions to the Exercises
185
ANY
{ ANY }
{ }
yellow
{ yellow }
{ }
ANY
{ ANY }
{ }
yellow
{ yellow }
{ }
Fig. A.13 The v_p_t when
the algorithm terminates
2. Certiﬁcate B is not valid. It contains a policy mappings extension but it is not a
CA certiﬁcate.
3. Certiﬁcate C is valid.
4. Certiﬁcate D is not valid because it maps anyPolicy to policy yellow.
Exercises of Chap. 9
9.1 Answer:
1. See Fig. A.11.
2. The length of the certiﬁcation path cp is n D 3. It contains the certiﬁcates B, C,
and D. Certiﬁcate A is the self-signed certiﬁcate of the Root CA and is excluded
from the path.
3. See Table A.9.
4. See Table A.10.

186
Solutions to the Exercises
5. See Fig. A.12.
6. The certiﬁcate is valid. The output of the algorithm indicates the successful
veriﬁcation and contains the public key key-0x80907060 and the valid policy
tree depicted in Fig. A.13.
Exercises of Chap. 10
10.1 Answer:
1. Certain extensions of Bob’s certiﬁcate do not contain appropriate values. The
dataEncipherment value must be set in the key usage extension. The emailPro-
tection (or anyExtendedKeyUsage) value must be set in the extended key usage
extension. The rfc822Name ﬁeld of the alternative name extension must contain
exactly the same email address as the recipient ﬁeld of the email.
2. The trust anchor to validate Bob’s certiﬁcate is not installed in the email client.
3. Alice does not have an appropriate certiﬁcate. Many email clients refuse to send
an email if the sender certiﬁcate does not permit encryption.

Index
Symbols
.crq
114
.p10
114
.p7c
114
.prp
114
delta CRL
82
A
aACertiﬁcate
129
Abstract Syntax Notation
22
acceptable response types
OCSP
88
accessLocation
138
accessMethod
138
caIssuers
138
ocsp
138
advanced electronic signature
156
AKI
See AuthorityKeyIdentiﬁer (AKI)
AKIE
27
AlgorithmIdentiﬁer
23
X.509 certiﬁcate
25
anonymity
5
anonymity issuer
35
anyExtendedKeyUsage
145
anyPolicy
119
archive cutoff
OCSP
88
ARL
83, 128
ASN.1
22
asymmetric cryptosystem
7
attribute certiﬁcate
22, 31
attributeCertiﬁcate
127
authenticated-data
109
AuthenticatedData
137
AuthenticatedSafe
63
authenticity
4
authority information access
132, 138
authority key identiﬁer
27
authority revocation list
83, 128
authorityCertIssuer
28
authorityCertSerialNumber
28
AuthorityInformationAccess
30
CRL
79
AuthorityKeyIdentiﬁer (AKI)
27
CRL
79
authorityRevocationList
128
B
Base CRL
82
basic constraints
50
basic encoding rules
22
basic ﬁeld
X.509 CRL
76
basic path validation algorithm
165
basic response types
OCSP
88
BasicConstraints
30
BER
22
blind issuer
35
BMPString
25
bridge CA
56, 57
Builtin Object Token
52
J.A. Buchmann et al., Introduction to Public Key Infrastructures,
DOI 10.1007/978-3-642-40657-7, © Springer-Verlag Berlin Heidelberg 2013
187

188
Index
C
C
25
CA
48, 107
cA
50
cACertiﬁcate
127
card reader
69
FINREAD
69
card terminal-API
71
card veriﬁable certiﬁcate (CVC)
31
caRepository
139
CERT
131
certiﬁcate
21
attribute
22, 31
concept
21
CVC
31
forward
56, 129
issuedByThisCA
56, 129
issuedToThisCA
56, 129
MIME type
132
PGP
33
qualiﬁed
156
reverse
56, 129
revocation
75
root
108
self-issued
107
self-signed
49, 107
short lived
90
SPKI
34
traceable anonymous
35
WAP
34
X.509
22
certiﬁcate acceptance
104
certiﬁcate application
103
certiﬁcate delivery
104
certiﬁcateExactMatch
129
certiﬁcate extension
27
certiﬁcate ﬁeld
23
certiﬁcate generation
103
certiﬁcate invalidity
104
certiﬁcateIssuer
X.509 CRL
79
certiﬁcate issuing
104
certiﬁcate life cycle
103
certiﬁcate management over CMS (CMC)
112
Certiﬁcate Management Protocol (CMP)
112
CertiﬁcatePolicies
30
certiﬁcate policies extension
119
certiﬁcate policy
117
structure
117
certiﬁcate publication
104, 131
DNS
131
FTP
132
HTTP
132
WebDAV
132
certiﬁcate request
109
certiﬁcate request message format (CRMF)
105, 111
certiﬁcate retrieval
131
certiﬁcate revocation
75, 83
certiﬁcate revocation list
76
certiﬁcateRevocationList
130
certiﬁcate validity
104
certiﬁcation authority
48, 107
certiﬁcation path
50, 125
building
132
extension
138
certiﬁcation path validation
134
certiﬁcation practice statement (CPS)
117,
119
certiﬁcation service provider (CSP)
103, 156
communication
108
message protection
108
PKCS#7
108
certiﬁcationAuthority
128, 130
CertRequest
111
chain model
97
challenge-response identiﬁcation
13
ciphertext
6
clientAuth
144
CMC
See certiﬁcate management over CMS
(CMC)
CMP
See Certiﬁcate Management Protocol
(CMP)
CMS
See Cryptographic Message Syntax
(CMS)
CN
25
code signing
152
collection
WebDAV
132
collision-resistance
11
combining trust hierarchies
51
common name
25
common root
53
complete CRL
76
component matching
129
conﬁdentiality
2
ContentInfo
63, 137
country
25
CPS
See certiﬁcation practice statement
(CPS)
critical
X.509 certiﬁcate
27

Index
189
CRL
76
complete
76
delta
76, 82
direct
76
distributionPoint
80
freshest
80
full
76
indirect
76, 83
issuing distribution point
80
issuing of
81
onlyContainsAttributeCerts
80
onlyContainsCACerts
80
onlyContainsUserCerts
80
onlySomeReasons
80
over-issued
81
scope
80
CRL AKI
79
CRL AuthorityInformationAccess
79
CRL AuthorityKeyIdentiﬁer
79
CRL distribution points
83
CRL entry
78
CRL entry extension
OCSP
88
CRL extension
79
CRL number
79
CRL references
OCSP
88
CRL scope
80
CRL SubjectAlternativeName
79
cRLDistributionPoint
130
CRLDistributionPoints
30
cRLSign
83
CRMF
See certiﬁcate request message
format (CMRF)
cross-certiﬁcate
56
cross-certiﬁcation
56
crossCertiﬁcatePair
128
Cryptographic Message Syntax (CMS)
109
authenticated-data
109
cryptographic token interface
70
cryptography
5
cryptoki
70
cryptosystem
asymmetric
7
McEliece
10
public key
7
RSA
8
secret key
5
symmetric
6
CSP
See certiﬁcation service provider (CSP)
CT-API
71
CV certiﬁcate
31
not self-descriptive
32
self-descriptive
32
CVC
See card veriﬁable certiﬁcate (CVC)
CVRequest
137
CVResponse
137
D
delta CRL
76, 82
delta CRL distribution point
80
delta CRL indicator
79
deltaRevocationList
130
DER
22
Difﬁe-Hellman key exchange
6
digested-data
109
digital signature
12
digital signature algorithm
14
direct CRL
76
directory information tree (DIT)
125
attributes
125
entry
125
object class
125
directory service
103, 108
direct trust
39
distinguished encoding rules
22
distinguished name
25, 125
DIT
See directory information tree (DIT)
DN
25, 125
DNS
131
certiﬁcate publication
131
domainInformation
34
DSA
14
E
e-commerce
1
e-government
2
e-health
2
electronic commerce
1
elliptic curve digital signature algorithm
(ECDSA)
14
emailProtection
145
encrypted-data
109
EnigMail
150
entity authentication
3
entry extensions
X.509 CRL
78
enveloped-data
109
EV certiﬁcate
122
expected_policy_set
165
extended key usage
30
extended validation certiﬁcate
122

190
Index
extension
24
CRL
79
OCSP
86
extnID
27
F
ﬁnlet
69
FINREAD
69
forward certiﬁcate
56, 129
freshest CRL
80
FreshestCRL
30
FTP
certiﬁcate publication
132
full CRL
76
Full PKI Request
112
Full PKI Response
113
G
GeneralizedTime
26
German national Root-CA
40
German signature law
50
GNU Privacy Guard (GPG)
43, 48, 147
GnuPG
probabilistic trust model
48
GSM
7
H
hardware PSE
68
hardware security module (HSM)
72
hash function
11
hierarchical trust
48
HSM
See hardware security module (HSM)
HTTP
certiﬁcate publication
132
hybrid encryption
10
hybrid model
98
I
identiﬁcation
3
identity-based encryption
17
identity-based public key cryptography
16,
17
indirect CRL
76, 83
inetOrgPerson
127
Inhibit anyPolicy
30, 121
inhibitPolicyMapping
121
integrity
3
invalidityDate
X.509 CRL
79
issuedBy
133
issuedBy direction tree
133
issuedByThisCA
56, 129
issuedTo
133
issuedTo direction tree
133
issuedToThisCA
56, 129
issuer
21
X.509 certiﬁcate
25
X.509 CRL
77
issuer alternative name
30
issuerDomainPolicy
119
issuerUniqueID
24, 26
issuing distribution point
80
J
Java card
69
Java card applet
69
Java card runtime environment (JCRE)
69
Java KeyStore (JKS)
65
JCEKS
65
JCRE
See Java card runtime environment
(JCRE)
JKS
See Java KeyStore (JKS)
K
key agreement
6
key backup
107
key center
7
keyCertSign
51
key escrow
107
key generation
15
keyIdentiﬁer
X.509 certiﬁcate
28
key legitimacy
44, 45
values of
45
key ring
44
key server
47
key usage
15, 29
KeyUsage
29
key validity
44
Konnektor
3

Index
191
L
LDAP
125
CA certiﬁcate
127
certiﬁcate search
129
certiﬁcate storage
126
CRL storage
130
security
131
userPassword
131
LDAPS
131
lightweight OCSP
89
local registration authority (LRA)
106
M
MAC
See message authentication code
(MAC)
matching rules
129
McEliece cryptosystem
10
Merkle Signature Scheme
15
message authentication code
11
message authentication code (MAC)
11
meta introducer
47
MIME type
certiﬁcate
132
modiﬁed shell model
98
N
name constraints
30
nextUpdate
OCSP
85
X.509 CRL
77
nonce
OCSP
86
non-repudiation
5
notAfter
25
notBefore
25
Novomodo
89
O
O
25
object identiﬁer
17
OCSP
See online certiﬁcate status protocol
(OCSP)
ocsp-nocheck
86
OCSPsigning
86
OID
17
online certiﬁcate status protocol (OCSP)
84
acceptable response types
88
archive cutoff
88
basic response types
88
CRL entry extension
88
CRL references
88
extensions
86
lightweight
89
nextUpdate
85
nonce
86
producedAt
85
retention interval
88
service locator
88
thisUpdate
85
OpenPGP
147
organization
25
organizational unit
25
OSCP
server design
89
OU
25
over-issued CRL
81
owner trust
44
P
p12
64
Password Integrity Mode
63
password privacy mode
64
pathLenConstraint
51
path length constraint
51
path retrieval
125
path validation
125
PC/SC
71
personal identiﬁcation number
62
personal security environment (PSE)
62
hardware
68
software
63
Thunderbird
66
Windows
65
pfx
64
PGP
33, 42, 147
revocation
90
revocation certiﬁcate
90
trust amount
47
trust level
47
phishing
4
PKC
1
PKCS#10
105, 109
PKCS#11
70
PKCS#12
63

192
Index
PKCS#7
108
content
109
contentType
109
data
109
digested-data
109
encrypted-data
109
enveloped-data
109
signed-and-enveloped data
109
signed-data
109
PKCS#8
64
PKCS#9
111
PKI
1
code signing
152
e-government
159
Email
144
Internet
143
legal signatures
156
VPN
154
pkiCA
127
pkiUser
127
plaintext
6
PMI
31
pmiAA
129
pmiUser
127
policy
ANY
119
mapping
119
policy constraints
121
PolicyConstraints
30
policy mappings
119
PolicyMappings
30
policy node
165
policy qualiﬁer
119
PoP
106
PrintableString
25
privacy
2
private extensions
30
private key
7, 12, 61
private key life cycle
61
privilege management infrastructure
31, 127
probabilistic trust model
GnuPG
48
producedAt
OCSP
85
proof of possession
106
prover
3
PSE
See personal security environment
(PSE)
pseudorandom number generator (PRNG)
15
public key
7, 12
public key cryptography
1
public key cryptosystem
7
public key encryption
7
public key infrastructure
1
Public Key Integrity Mode
63
public key packets
33
public key privacy mode
64
Q
qualiﬁed certiﬁcate
156
qualiﬁed signature
159
qualiﬁer_set
165
R
RA
103, 105
RDN
125
reasonCode
X.509 CRL
78
registration
104
registration authority
103, 105
relative distinguished name
125
requireExplicitPolicy
121
requirements
revocation
75
resource record
131
restrictions
21
retention interval
OCSP
88
reverse certiﬁcate
56, 129
revocation
75, 83
CVC
90
Novomodo
89
PGP
90
requirements
75
revocation certiﬁcate
90
revocationDate
X.509 CRL
78
revocation latency
X.509 CRL
78
revocation password
107
revocation service
103, 108
revokedCertiﬁcates
X.509 CRL
77
root CA
49
root certiﬁcate
108
RSA cryptosystem
8
RSA encryption
8
RSA modulus
9
RSA signature
13

Index
193
S
SASL
131
SCVP
137
secret key cryptosystem
5
secret key encryption
5
Secure Shell
41
security goals
2
self-issued certiﬁcate
22, 107
self-signature
44
self-signed certiﬁcate
22, 49, 107
SEQUENCE
23
serial number
21
serialNumber
X.509 certiﬁcate
24
serverAuth
144
server-based certiﬁcate validation protocol
137
service locator
OCSP
88
session key
11
shell model
95
short lived certiﬁcate
90
signature
X.509 certiﬁcate
25
X.509 CRL
77
signatureAlgorithm
23, 27
signature key
12
signature with message recovery
14
signatureValue
23, 27
signed-and-enveloped data
109
signed-data
109
SignedData
137
signer
12
simple authentication and security layer
131
Simple PKI Request
112
Simple PKI Response
113
simple public key infrastructure (SPKI)
34
smart card
68
interface
70
smart card communication interface
70
smart card readers
69
S/MIME
145
software PSE
63
Software Security Device
52
SPKI
See simple public key infrastructure
(SPKI)
SSH
41
SSL
143
strongAuthenticationUser
127
subject
21
X.509 certiﬁcate
26
subject alternative name
30
SubjectAlternativeName
30
CRL
79
subject directory attributes
30
subjectDomainPolicy
120
subject information access
139
SubjectInformationAccess
30
subject key identiﬁer
28
SubjectKeyIdentiﬁer
28
subjectPublicKeyInfo
X.509 certiﬁcate
26
subjectUniqueID
24, 26
symmetric cryptosystem
6
T
tbsCertiﬁcate
X.509 certiﬁcate
24
TeletexString
25
thisUpdate
OCSP
85
X.509 CRL
77
Thunderbird PSE
66
timeStamping
139
time-stamping authority
108
TLS
143
traceable anonymous certiﬁcate
35
Transferable Public Keys
44
Transferable Secret Keys
44
trust amount
PGP
47
trust anchor
48
trust center
103
trust hierarchies
51
combining
51
trust level
PGP
47
trust model
39
trust-service status list
52
trust signature
47
trusted introducer
47
trusted list
52
TSA
108
TSL
52
U
uncoercibility
5
unique digital name
106
userCertiﬁcate
127
X.509 CRL
78

194
Index
userPassword
LDAP
131
userPKCS12
127
UTCTime
26
UTF8
25
V
validation algorithm
135
validity
X.509 certiﬁcate
25
validity model
95
chain
97
hybrid
98
modiﬁed shell
98
shell
95
validity period
21
validity signature
43
valid_policy
165
valid policy tree
136
valid_policy_tree
165
veriﬁcation key
12
veriﬁer
3
version
X.509 certiﬁcate
24
X.509 CRL
76
W
WAP
34
WAP certiﬁcate
34
WebDAV
132
certiﬁcate publication
132
collection
132
web of trust
42
WebStart
153
Windows PSE
65
wireless application protocol
34
wrap-up
137
X
X-KISS
112
X-KRSS
112
X.509 certiﬁcate
22
AlgorithmIdentiﬁer
25
critical
27
extension
24, 27
ﬁeld
23
issuer
25
keyIdentiﬁer
28
serialNumber
24
signature
25
signatureAlgorithm
23
signatureValue
23
subject
26
subjectPublicKeyInfo
26
tbsCertiﬁcate
23, 24
validity
25
version
24
X.509 CRL
basic ﬁeld
76
certiﬁcateIssuer
79
entry extensions
78
invalidityDate
79
issuer
77
nextUpdate
77
reasonCode
78
revocation latency
78
revocationDate
78
revokedCertiﬁcates
77
signature
77
thisUpdate
77
userCertiﬁcate
78
version
76
XKMS
105, 112
XML key information service speciﬁcation
112
XML key management speciﬁcation
112
XML key registration service speciﬁcation
112

