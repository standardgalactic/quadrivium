

As the roles of Data and Business Analysts become more intertwined, this book is 
timely in its publication. Businesses often fail to recognise information is a key resource 
and are confused by how it is presented or overwhelmed its complexity during use. 
Keith brings to the forefront of the readers mind the importance of communicating 
and analysing the relationship between Business, Information, Systems and Data, and 
the value in developing models cooperatively, gaining ‘consensus, not perfection’ from 
stakeholders. Simple everyday examples and analogies to support the readers under­
standing and make the subject more relatable are used.
I enjoyed reading the book and completing the exercises. An excellent learning aid for 
Analysts who are new to modelling or need reminding of good practice.
Katie Walsh, Business Analyst and Mentor
Anyone interested in a thoughtful, well-done text on how to do high-quality business 
analytical data modelling should definitely proceed with this book.
David Hay, Essential Strategies International, CEO 
Modelling Business Information provides an introduction to data modelling, to the nomen­
clature used by common modelling techniques, and to techniques for representing 
common patterns. This is a useful book for business analysts who are creating the 
information model as well as for business and IT users who need to understand a data 
model.
Keith W. Hare, JCC Consulting, Inc., Senior Consultant 
Keith Gordon’s wonderfully compact yet thorough introduction to business-friendly 
information modelling is a terrific contribution to the field. Globally, there’s a surge of 
interest in data modelling as a powerful tool for improving communication, especially 
with professionals who used to think business-oriented entity relationship modelling 
didn’t need to be in their tool kits. Business analysts, Agile developers, data scientists, 
big data specialists, and other professionals will all benefit from Keith’s work.
Alec Sharp, Senior Consultant, Clariteq 
Modelling Business Information by Keith Gordon, is aimed at those who are new to busi­
ness analysis or information modelling. Keith draws on a wealth of experience in infor­
mation management, both as a practitioner, and as a lecturer with the Open University 
in his writing.
The first six chapters provide an accessible and clear foundation in the topic cov­
ering the reasons for developing information models, the basic elements of entity-
relationship diagrams, how to develop an information model from basic information 
requirements, and finally how to normalise existing data. I particularly like that it 
uses two graphical notations, the Barker-Ellis notation, noted for its readability, and 
the ubiquitous Unified Modelling Language notation, which helps to demonstrate that 
there are different notations that entity-relationship models can be developed in. This 
first part of the book also takes care to cover the syllabus for the Data Analysis 
certificate that is part of the scheme for the BCS Advanced International Diploma in 
Business Analysis.
The second part of the book covers a range of more advanced topics from naming con­
ventions and yet more entity-relationship model notations, to considerations of quality in
 

information models, corporate data models, modelling for business intelligence applica­
tions, and finally goes on to look at data and database topics including an overview of 
SQL, and moving to database design and optimisation.
Overall, the book provides an excellent grounding in the full range of topics related to 
information modelling.
Matthew West, Director, Information Junction 

MODELLING BUSINESS 
INFORMATION

BCS, THE CHARTERED INSTITUTE FOR IT
BCS, The Chartered Institute for IT, champions the global IT profession and the interests 
of individuals engaged in that profession for the benefit of all. We promote wider social 
and economic progress through the advancement of information technology science 
and practice. We bring together industry, academics, practitioners and government to 
share knowledge, promote new thinking, inform the design of new curricula, shape 
public policy and inform the public.
Our vision is to be a world-class organisation for IT. Our 75,000-strong membership 
includes practitioners, businesses, academics and students in the UK and internationally. 
We deliver a range of professional development tools for practitioners and employees. 
A leading IT qualification body, we offer a range of widely recognised qualifications.
Further Information
BCS, The Chartered Institute for IT,
First Floor, Block D,
North Star House, North Star Avenue,
Swindon, SN2 1FA, UK.
T +44 (0) 1793 417 424
F +44 (0) 1793 417 444
www.bcs.org/contact
http://shop.bcs.org/BCS logo

MODELLING BUSINESS 
INFORMATION
Entity relationship and class 
modelling for business analysts
Keith GordonBCS logo

© 2017 BCS Learning & Development Ltd
The right of Keith Gordon to be identified as author of this work has been asserted by him in accordance with 
sections 77 and 78 of the Copyright, Designs and Patents Act 1988.
All rights reserved. Apart from any fair dealing for the purposes of research or private study, or criticism or review, 
as permitted by the Copyright Designs and Patents Act 1988, no part of this publication may be reproduced, stored 
or transmitted in any form or by any means, except with the prior permission in writing of the publisher, or in the 
case of reprographic reproduction, in accordance with the terms of the licences issued by the Copyright Licensing 
Agency. Enquiries for permission to reproduce material outside those terms should be directed to the publisher.
All trademarks, registered names etc. acknowledged in this publication are the property of their respective 
owners.
BCS and the BCS logo are the registered trademarks of the British Computer Society, charity number 292786 
(BCS).
Published by BCS Learning & Development Ltd, a wholly owned subsidiary of BCS, The Chartered Institute for IT, 
First Floor, Block D, North Star House, North Star Avenue, Swindon, SN2 1FA, UK.
www.bcs.org
Paperback ISBN: 9781780173535
PDF ISBN-13: 9781780173542
EPUB ISBN-13: 9781780173559
Kindle ISBN-13: 9781780173566PaperBack icon
British Cataloguing in Publication Data.
A CIP catalogue record for this book is available at the British Library.
Disclaimer:
The views expressed in this book are those of the authors and do not necessarily reflect the views of the 
Institute or BCS Learning & Development Ltd except where explicitly stated as such. Although every care 
has been taken by the authors and BCS Learning & Development Ltd in the preparation of the publication, no 
warranty is given by the authors or BCS Learning & Development Ltd as publisher as to the accuracy or com­
pleteness of the information contained within it and neither the authors nor BCS Learning & Development Ltd 
shall be responsible or liable for any loss or damage whatsoever arising by virtue of such information or any 
instructions or advice contained within this publication or by any of the aforementioned.
Typeset by Lapiz Digital Services, Chennai, India.
vi

CONTENTS
	
List of figures and tables
x
	
About the Author
xiii
	
Foreword
xv
	
Acknowledgements
xviii
	
Glossary
xix
	
Introduction
xxv
PART 1	 THE BASICS
1
1.	
WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
3
	
What is business analysis?
3
	
Information and data
5
	
The importance for a business analyst of understanding 
	
information needs
6
	
The role of models in business analysis
7
	
Data models and data
10
	
Entity relationship modelling
11
	
Class modelling
12
	
Use of data models in business analysis
13
	
What makes a good data model? 
14
	
Introducing data analysis
14
2.	
MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE 
RELATIONSHIPS BETWEEN THEM
16
	
Entities and objects
16
	
Naming of entity types and object classes
18
	
Introduction to relationships and associations
19
	
Relationship notation in entity relationship models
20
	
Association notation in UML class models
22
	
Degrees of cardinality and optionality
24
	
Multiple relationships and associations
27
	
Recursive relationships and reflexive associations
29
	
Exercises for Chapter 2
30
3.	
MODELLING MORE COMPLEX RELATIONSHIPS 
32
	
The problems with many-to-many relationships and associations
32
	
Resolving entity relationship model many-to-many relationships 
33
	
Resolving class model many-to-many associations
35
vii

MODELLING BUSINESS INFORMATION
4.	
DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
50
	
The model drawing process
50
	
Identifying the entity types or the object classes
51
	
Identifying the relationships or associations
53
	
Drawing the initial diagram
54
	
Validating the diagram
56
	
Exercises for Chapter 4
63
5.	
RECORDING INFORMATION ABOUT THINGS
65
	
Revisiting entity types, object classes, relationships and associations
65
	
Introduction to attributes
66
	
The naming of attributes
69
	
Entity type, object class or attribute?
69
	
Unique identifiers
72
	
Domains
74
	
The UML extended attribute notation
75
	
Showing operations on class models
77
	
Exercises for Chapter 5
79
6.	
RATIONALISING DATA USING NORMALISATION
81
	
What is normalisation?
81
	
The relational model of data
82
	
The rules of normalisation
84
	
Starting the normalisation process
85
	
First normal form
86
	
Second normal form
89
	
Third normal form
90
	
The third normal form data model
94
	
Candidate keys, primary keys and alternate keys
95
	
The relationship of normalisation to modelling
95
	
Exercises for Chapter 6
96
PART 2	 SUPPLEMENTARY MATERIAL
97
7.	
OTHER MODELLING NOTATIONS
99
	
The IDEF1X notation
100
	
The Information Engineering notation
104
	
The Chen notation
104
	
Comparison of the notations
107
8.	
THE NAMING OF ARTEFACTS ON INFORMATION MODELS
108
	
The naming of entity types or object classes
108
	
The naming of domains
110
Exercises for Chapter 3
48
	
	
	
Generalisation and specialisation in entity relationship models
41
Generalisation and specialisation in class models
43
Aggregation and composition
46
viii
	
	
	
The ‘bill of materials’ structure
36
Mutually exclusive relationships and associations
39

CONTENTS
	
The naming of attributes
110
	
The naming of relationships in Ellis-Barker entity relationship models 
112
	
The naming of associations on UML class models 
112
9.	
INFORMATION MODEL QUALITY
114
	
Genericity and specificity in models
114
	
The nine characteristics of a good data model 
116
	
The six principles of high quality data models 
118
	
The five dimensions of data model quality
120
	
The layout of models
121
10.	
CORPORATE INFORMATION AND DATA MODELS
123
	
The problems 
123
	
Principles for the development of a corporate model
125
11.	
DATA AND DATABASES
127
	
The data landscape
127
	
Databases
130
12.	
BUSINESS INTELLIGENCE 
139
	
The data warehouse
139
	
The multidimensional model of data
140
	
Dimensional modelling
141
13.	
ADVANCES IN SQL (OR WHY BUSINESS ANALYSTS 
SHOULD NOT BE IN THE WEEDS) 
144
	
The basics of SQL
144
	
New SQL data types
145
	
The future
151
	
Implications for business analysts and information modellers
151
14.	
TAKING A REQUIREMENTS INFORMATION MODEL INTO 
DATABASE DESIGN
154
	
First-cut database design stage
154
	
Optimised database design stage
155
	
APPENDICES
157
	
Appendix A: Table of equivalences
158
	
Appendix B: Bibliography
159
	
Appendix C: Solutions to the exercises
162
	
Index
172
ix

LIST OF FIGURES AND TABLES
Figure 1.1	
Three levels of system
4
Figure 1.2	
The relationship between data and information
6
Figure 1.3	
A rich picture
7
Figure 1.4	
A business activity model
8
Figure 1.5	
A business process model
8
Figure 1.6	
A use case diagram
9
Figure 1.7	
Requirements engineering in context
9
Figure 1.8	
An example entity relationship model using the 
	
Ellis-Barker notation
12
Figure 1.9	
An example of a UML class model
13
Figure 2.1	
The vehicle hire company using Ellis-Barker notation
16
Figure 2.2	
The vehicle hire company using UML class model notation
17
Figure 2.3	
A relationship in an entity relationship model
20
Figure 2.4	
An association in a UML class model
22
Figure 2.5	
The use of role names
23
Figure 2.6	
One-to-many (1:n) optional–mandatory relationship 
	
and association
25
Figure 2.7	
One-to-many (1:n) mandatory–optional relationship 
	
and association
26
Figure 2.8	
One-to-one (1:1) optional–mandatory relationship 
	
and association
26
Figure 2.9	
Many-to-many (m:n) optional–optional relationship 
	
and association
27
Figure 2.10	
Modelling the ‘one-way’ hire situation
28
Figure 2.11	
Employee supervision
29
Figure 3.1	
Employees and branches
32
Figure 3.2	
Introducing the ASSIGNMENT entity type
34
Figure 3.3	
Introducing the ASSIGNMENT object class
35
Figure 3.4	
Introducing the ASSIGNMENT association class
36
Figure 3.5	
Introducing products within products
36
Figure 3.6	
The bill of materials structure in Ellis-Barker notation
37
Figure 3.7	
The bill of materials structure in UML class model notation
37
Figure 3.8	
Employee supervision in a matrix organisation
38
Figure 3.9	
Employee supervision in a matrix organisation resolved
39
Figure 3.10	
The vehicle hire company as shown in Figure 2.1
39
Figure 3.11	
The introduction of an exclusive arc
40
Figure 3.12	
The introduction of the {xor} constraint
41
Figure 3.13	
An example of a supertype–subtype hierarchy 
42
Figure 3.14	
Alternative depiction of a supertype–subtype hierarchy
43
x

LIST OF FIGURES AND TABLES
An example of the use of the composition symbol in a 
	
UML class model
47
Figure 3.21	
Composition using Ellis-Barker notation
47
Figure 4.1	
The model drawing process
51
Figure 4.2	
A ‘relationship matrix’
53
Figure 4.3	
The initial Ellis-Barker entity relationship model
54
Figure 4.4	
The initial UML class model
54
Figure 4.5	
The first data navigation path
57
Figure 4.6	
The second data navigation path
58
Figure 4.7	
The revised Ellis-Barker entity relationship model
59
Figure 4.8	
The revised UML class model
60
Figure 4.9	
Partial high-level process map
60
Figure 4.10	
Completed CRUD matrix
61
Figure 4.11	
The final Ellis-Barker entity relationship model
62
Figure 4.12	
The final UML class model
62
Figure 5.1	
The previous models
65
Figure 5.2	
Attribute types shown on an Ellis-Barker entity 
	
relationship model
67
Figure 5.3	
Attributes shown on a UML class model
68
Figure 5.4	
EMPLOYEE expanded (shown in Ellis-Barker entity 
	
relationship notation)
71
Figure 5.5	
EMPLOYEE expanded (shown in UML class 
	
modelling notation)
72
Figure 5.6	
Unique identifiers on an Ellis-Barker entity 
	
relationship model
73
Figure 5.7	
The UML <<enumeration>> class
76
Figure 5.8	
The UML extended attribute notation
76
Figure 5.9	
The UML operations notation
78
Figure 6.1	
Relational tables
83
Figure 6.2	
The staff record form
85
Figure 6.3	
Normalisation form completed to UNF
87
Figure 6.4 	
Normalisation form completed to 1NF
88
Figure 6.5	
Normalisation form completed to 2NF
91
Figure 6.6	
Normalisation form completed to 3NF
93
Figure 6.7	
The third normal form data model
94
Figure 7.1	
The model of the business scenario in Ellis-Barker notation
100
Figure 7.2	
The model of the business scenario in UML class model 
	
notation
101
Figure 7.3	
The model of the business scenario in IDEF1X notation
102
Figure 7.4	
The model of the business scenario in Information 
	
Engineering notation
105
Figure 7.5	
The model of the business scenario using Chen’s notation
106
Figure 3.20	
An example of the use of the aggregation symbol in a 
	
UML class model
47
Figure 3.19	
Aggregation using Ellis-Barker notation
46
Figure 3.18	
A UML class model with multiple superclass–subclass 
	
hierarchies
45
Alternative notation for a UML superclass–subclass 
	
hierarchy
44
Figure 3.17	
Figure 3.16	
A UML superclass–subclass hierarchy
44
Figure 3.15	
xi

MODELLING BUSINESS INFORMATION
Figure 7.6	
Comparison of the relationship notations
107
Figure 9.1	
An example of the replacement of roles by entity types
115
Figure 9.2	
The generic to specific continuum
116
Figure 9.3	
The cost-balance of flexible design
119
Figure 9.4	
The five dimensions of data model quality
120
Figure 11.1	
The data landscape
127
Figure 11.2	
Example data arranged in tables and columns
128
Figure 11.3	
The database chronology
131
Figure 11.4	
Hierarchical database schema 
131
Figure 11.5	
Hierarchical database occurrences 
132
Figure 11.6	
Network database schema 
134
Figure 11.7	
Network database occurrences 
135
Figure 12.1	
A multidimensional data model
140
Figure 12.2	
A typical ‘star’ schema for a data warehouse
141
Figure 12.3	
A ‘snowflake’ schema
143
Figure 12.4	
A ‘galaxy’ schema
143
Figure 13.1	
The original ‘workshop’ model
151
Figure 13.2	
The third normal form model
152
Figure 13.3	
The final model
153
Table 4.1	
Identified entity types or object classes 
52
Table 8.1	
Examples of formal attribute names
111
Table A.1	
Table of equivalences 
158
xii

ABOUT THE AUTHOR
Keith Gordon was a professional soldier for 38 years, joining the Army straight from 
school at 16 and retiring on his 55th birthday. During his service with the Royal 
Armoured Corps, the Royal Corps of Signals and the Royal Army Educational Corps 
(now the Educational and Training Services Branch of the Adjutant General’s Corps) he 
gained a Higher National Certificate in Electrical, Electronic and Telecommunications 
Engineering, a Certificate in Education from the Institute of Education of the University of 
London, a Bachelor of Arts from the Open University and a Master of Science in Design 
of Information Systems from Cranfield Institute of Technology. 
The Master of Science course, held at the Royal Military College of Science, was unclear 
about what sort of information system the students were supposed to be designing. 
Was it a business system to be used in the non-operational world of the military? Was 
it a command and control information system to be used on the battlefield? Was it a 
real-time system to be used in areas such as weapon control? Or was it a management 
information system? 
The course did, however, cover some really useful stuff. On the technical side this 
included programming in Ada and Coral-66, which are languages designed for embed­
ded and real-time systems. We also studied Soft Systems Methodology (the academic 
lead for the course had researched for his doctorate at Lancaster University under the 
supervision of Professor Peter Checkland) and we looked, in particular, at the work of 
Professor Brian Wilson specialising in the application of Soft Systems Methodology to 
the development of information systems. The Structured Systems Analysis and Design 
Method (SSADM) (now called ‘Business System Development’ and the impetus for the 
Business System Development scheme of BCS which includes the Business Analysis 
and Solution Development diplomas and used to include a Data Management diploma) 
also formed a substantial part of the course. 
Following the Design of Information Systems course, Keith spent three years as a con­
sultant in the Army School of Training Support, where he looked into and procured com­
puter systems for use in education and training – computer-based training (CBT). This 
role was part researcher and part business analyst. The next two years were spent as 
the Senior Education Officer in the Army’s apprentice college for the training of appren­
tice soldier chefs.
In 1992, he was posted to the Ministry of Defence and joined a new team of four officers 
and a civil servant ‘doing data management’ for the Army. In 1995, he was promoted 
to Lieutenant Colonel and became the head of that team until he retired from the Army 
in 1998. 
xiii

MODELLING BUSINESS INFORMATION
He is now an independent consultant and lecturer specialising in data management 
and business analysis. As well as developing and teaching commercial courses, he was 
for a number of years a tutor for the Open University, tutoring general computing and 
database courses in the undergraduate and postgraduate programmes. 
He is a Chartered Member of BCS, The Chartered Institute for IT, a Member of the 
Chartered Institute of Personnel and Development and a Fellow of the Institution for 
Engineering and Technology. 
He holds the Diploma in Business Systems Development specialising in data manage­
ment from BCS – formerly the Information Systems Examination Board (ISEB) – and he 
is now an examiner for the Business Systems Development scheme. 
He represents the UK within the international standards development community by 
being nominated by the British Standards Institution (BSI) to the international stand­
ards committee, ISO/IEC JTC1 SC32 WG2 (Information Technology – Data Management 
and Interchange – Metadata). In this role, he has contributed to the development of 
ISO/IEC 11179 (Metadata registries) and ISO/IEC 19763 (Metamodel framework for 
interoperability).
For a number of years, Keith was the secretary of the BCS Data Management Specialist 
Group and, as a founder member, was a committee member of the UK chapter of DAMA 
International, the worldwide association of data management professionals.
xiv

FOREWORD
Business analysts have a curiosity about the business environment. They are keen to 
understand how processes can be improved, how customers can be given better service 
and, ultimately, how their organisations can be successful. As analysts though, if we 
want to understand how things work and can be improved, we can’t look at processes 
alone. The other key dimension that underlies all of these aspects, and provides a firm 
foundation for the organisation’s work, is the information that makes the business oper­
ate. Information is the lifeblood of organisations and the people working within them.
Let’s think about what information offers:
yy evidence for root cause analysis;
yy a basis for decisions;
yy measures for evaluating performance;
yy tangible indications of opportunities;
yy parameters for applying business rules.
Information can address all of these areas and more, and provide a means of challeng­
ing assumptions and opinions. Surely this is a much better approach than employing 
gut feel or inventing ideas to suit personal agendas.
However, if businesses require information to operate effectively, they need a clear 
understanding of their data. If processes are to be efficient and effective, decision-mak­
ing is to be precise and customer service is to be of the highest standard, the data needs 
to be accurate, accessible and available. 
Data is at the heart of business. It forms the basis for providing essential information, 
including:
yy who our customers are and what work they have done with us;
yy the nature and characteristics of our products and services;
yy the details regarding our financial situation and staff. 
If organisations understand the importance of data, and work with it effectively, they can 
succeed in today’s world of high expectations and intense competition. If organisations 
fail to acquire, record, manage and utilise data, then business failure will surely follow. 
xv

MODELLING BUSINESS INFORMATION
Aside from the effective operation of the enterprise, there are also the opportunities that 
data can clarify or make available to forward looking, receptive organisations. Data can 
be interpreted to offer information about the changing nature of the business environ­
ment. For example, new service requirements, the demographic make-up of customers, 
areas where product customisation is desired; all of these can provide opportunities for 
the organisation to learn and grow. We often talk about the learning organisation, but 
to become one relies on the receipt of good feedback (the data) and acting upon it (the 
processes). 
Over the last couple of decades though, it has felt as if data was a secondary dimension 
with process improvement taking centre stage. There has been a move to almost ignore 
data requirements within organisations and place the focus on the business processes 
and the customer experience. Those of us who have worked as data analysts, model­
lers and managers, have long feared the effect this approach could have, predicting that 
the impact of a reduced focus on data would eventually be recognised and hoping that 
it wouldn’t be at too high a cost. The advent of popular memes such as ‘big data’ has 
certainly brought data back to the forefront but there is also the issue of smaller, every 
day data - the data that makes the wheels go around rather than completely reinventing 
the wheel. This data may not help us to predict the innovations of the future but without 
it the organisation can’t operate and will fail to identify where change is required.
A popular misconception has been that analysing data is ‘difficult’ and ‘technical’, and 
should be the responsibility of those working as software architects or developers 
rather than the business analysts engaging with business stakeholders. The reality that 
information and data reflect business requirements seems to have been lost some­
where along the way. 
Yet, if organisations are to ‘learn’ and benefit from receiving informed feedback in order 
that they can respond and grow, they have to understand that data is important and 
should be handled with care. There needs to be an appreciation that the data reflects 
the operations, policies and rules of the organisation and while these may be embed­
ded within software, they originate from people making decisions – including business 
managers and staff, external customers and suppliers, and regulatory agencies. In other 
words, data is not a technical domain, it is something everyone needs to appreciate, and 
the analysis of data needs to be conducted by those with business understanding. There 
should be people within the organisation who have the expertise and insight to elicit 
data requirements, analyse the structure and semantics of data, build clear models 
of the data and manage the data resource. We are in an insecure world where there is 
increasing recognition of the importance of data and the need to ensure data security 
and protection.
Which brings me to this book. Those of us who have long-lamented that we regularly 
encounter a limited data focus should congratulate Keith Gordon for providing such a 
comprehensive, clear and practical resource in this book. The topics covered take us 
through the process of eliciting, modelling and validating data. The key approaches 
to representing and understanding data are explained, including the often-overlooked 
topic of data normalisation. All in all, the book provides extensive guidance that the busi­
ness analyst – and anyone else requiring an understanding of data analysis – needs if 
they are to work effectively with data. The book helps anyone new to the world of data to 
learn the techniques and principles behind successful data analysis. The breadth of the
xvi

FOREWORD
book also helps those with experience in data analysis to encounter new ideas, brush 
up and broaden their knowledge, and deepen their understanding. 
Modelling Business Information encourages readers to understand that data is not just 
about modelling for the technical solution, it is concerned with understanding the organ­
isation, the rules it applies, and the information it needs. In other words, data analysis 
is a business discipline and the work to understand data should be performed by those 
with a business mindset. 
Organisations require business analysts who can help the business staff to articulate 
data requirements and ensure that information needs can be met. Tomorrow’s business 
world needs data to be collected, governed and analysed in order to be an effective 
resource for organisations. This book helps organisations to do this. You should read it 
and use it as a key business resource.
Debra Paul
Managing Director, Assist Knowledge Development
June 2017
xvii

ACKNOWLEDGEMENTS
Understanding and documenting the information needs of the business are an essential 
part of data management, so my real introduction to modelling these concepts and things 
came when I joined the Army’s data management team. Among the people to whom I owe 
a debt of gratitude are my colleagues in that team, Ian Nielsen, Martin Richley, Duncan 
Broad and Tim Scarlett, as well as the consultants who helped us develop our ‘corporate 
data model’ and design the resulting database, David Gradwell, Ken Allen, Ron Segal (who 
is now in New Zealand), Elaine Senior and the wonderful Harry Ellis who has done so 
much to help the world know how to understand and document information requirements 
through his pioneering work on data modelling and data management. Later members of 
that team included, among others, Mark Thurlow, Lucy Finney and Peter Lawson.
Over the last 20 years or so I have had many interesting conversations about infor­
mation and data modelling (yes, it is possible!) with, among others: Bob Walker and 
Gene Simaitis, both formerly of the Institute for Defense Analyses in Washington, DC; 
Mike Newton and Steven Self from the Open University; Hajime Horiuchi and Masao 
Okabe from Japan and Ray Gates from Canada, all colleagues in ISO/IEC JTC1 SC32 
WG2; Matthew West, author of Developing High Quality Data Models, formerly of Shell and 
now also a colleague in ISO/IEC JTC1 SC32 WG2; David Hay from Houston, USA, author 
of many books including Data Model Patterns, Conventions of Thought, Requirements 
Analysis and UML and Data Modelling, a Reconciliation; and Alec Sharp from Canada, 
conference speaker and co-author of Workflow Modeling, Tools for Process Improvement 
and Application Development.
Special mention must go to David Beaumont from Stehle Associates, my constant 
sounding board for my ideas over the last 18 years. 
Homing in on this book, I need to thank Terri Lydiard, a fellow BCS examiner, who 
reviewed an early draft of Chapter 1 and Keith Hare, of JCC Consulting in Granville, Ohio, 
USA and convenor of ISO/IEC JTC1/SC32/WG3, who reviewed Chapters 11 and 13. Both 
provided valuable comments which I have tried to incorporate. 
Thanks are also due to Ian Borthwick and Rebecca Youé of BCS who have been respon­
sible for getting this book into print.
Finally, a massive thank you to the back-up team at home, my wife, Vivienne. She has 
found it difficult to understand why I am not wandering around a golf course or sitting 
in an armchair by the fire instead of enjoying myself running around the world attending 
meetings, teaching, examining, writing books and generally getting involved in things 
because of my total inability to say, ‘No’. I have promised Vivienne that I will look up the 
word ‘Retirement’ in the dictionary one day – but not yet.
xviii

GLOSSARY
aggregation  (Class modelling) A special form of association that specifies a whole–part 
relationship between an object class representing the aggregate (whole) and another 
object class representing the component part.
alternate key  (Relational data analysis) A candidate key that is not selected to be the 
primary key for the relation.
artefact  A diagram or supporting description providing a representation of the system 
of interest.
association  (Class modelling) A business link between two object classes. The link is 
required in order to navigate from one class to another.
association class  (Class modelling) An object class that has both association and 
object class properties.
attribute  (Entity relationship modelling and class modelling) A named characteristic of 
an entity type or object class whose values serve to qualify, identify, classify, quantify or 
express the state of an instance of that entity type or object class.
big data  A data set, or a collection of data sets, with characteristics (for example, 
volume, velocity, variety, variability, veracity) that for a particular problem domain at a 
given point in time cannot be efficiently processed using current/existing/established/
traditional technologies and techniques in order to extract value.
candidate key  (Relational data analysis) An attribute, or a set of attributes, that pro­
vides the ability to uniquely identify a tuple in a relation without referring to any other 
data, such that no two tuples in a relation can have the same value, or set of values, for 
their candidate keys.
cardinality  (Entity relationship modelling and class modelling) The degree of occurrence 
indicated on a relationship between two entity types or an association between two object 
classes. The cardinality reflects part of the business rules for a relationship or association.
CASE  Acronym for computer-aided software engineering – a combination of software 
tools that assist computer development staff to engineer and maintain software sys­
tems, normally within the framework of a structured method.
Chen notation  (Entity relationship modelling) The original entity–relationship modelling 
notation.
xix

MODELLING BUSINESS INFORMATION
class model  (Class modelling) A technique from the Unified Modeling Language (UML). A 
class model describes, using graphics and documentation, the classes in a system and their 
associations with each other. Within business analysis the classes are limited to the things 
of significance about which information needs to be held in support of business operations.
composite identifier  (Entity relationship modelling) A unique identifier formed from a 
combination of attributes.
composite key  (Relational data analysis) A candidate key comprising more than one 
attribute.
composition  (Class modelling) A form of aggregation which requires that a part 
instance be included in at most one composite at a time, and that the composite object 
is responsible for the creation and destruction of the parts.
column  The logical structure within a table of a relational database management sys­
tem (RDBMS) that corresponds to the attribute in the relational model of data.
conceptual data model  A detailed model that captures the overall structure of organi­
sational data while being independent of any database management system or other 
implementation consideration – it is normally represented using entity types, relation­
ships and attributes with additional business rules and constraints that define how the 
data is to be used.
corporate data model  A conceptual data model whose scope extends beyond one 
application system.
data  A reinterpretable representation of information in a formalised manner suitable 
for communication, interpretation or processing.
data analysis  The process of understanding and documenting in a data model the 
information (or data) requirements of a business or business area; data analysis is a 
part of business analysis.
data mining  The process of finding significant, previously unknown and potentially 
valuable knowledge hidden in data.
data model  (i) An abstract, self-contained logical definition of the data structures and 
associated operators that make up the abstract machine with which users interact (such 
as the relational model of data). (ii) A model of the persistent data of some enterprise 
(such as an entity–relationship model or class model of the data required to support a 
business or business area).
data modelling  The task of developing a data model that represents the persistent 
data of some enterprise.
data type  A constraint on a data value that specifies its intrinsic nature, such as 
numeric, alphanumeric or date.
data warehouse  A specialised database containing consolidated historical data drawn 
from a number of existing databases to support strategic decision-making.
xx

GLOSSARY
database  (i) An organised way of keeping records in a computer system. (ii) A collec­
tion of data files under the control of a database management system.
database management system (DBMS)  A software application that is used to create, 
maintain and provide controlled access to databases.
described domain  (Entity relationship modelling and class modelling) A domain that is 
specified by a description or specification, such as a rule, a procedure or a range (i.e. 
interval); a domain that is not enumerated.
domain  (Entity relationship modelling and class modelling) A named pool (or set) of 
values from which an instance of an attribute must take its value; a domain provides 
a set of business validation rules, format constraints and other properties for one or 
more attributes
Ellis-Barker notation  (Entity relationship modelling) A modelling notation designed by 
Harry Ellis and Richard Barker while working at the consultancy company CACI with 
business users in mind so as to reduce interactions with those users. This notation was 
later used by the Oracle Corporation and by the UK Government’s Central Computer 
and Telecommunications Agency (CCTA) for its Structured Systems Analysis and Design 
Method (SSADM).
entity  (Entity relationship modelling) A named thing of significance about which infor­
mation needs to be held in support of business operations.
entity occurrence  (Entity relationship modelling) A single instance of an entity within 
an entity type.
entity relationship model  (Entity relationship modelling) A data model based on entity 
types and their attributes and relationships.
entity subtype  (Entity relationship modelling) A subset of the instances of an entity type, 
known as the supertype, that share common attributes or relationships distinct from 
other subsets of the supertype.
entity type  (Entity relationship modelling) An element of a data model that represents 
a set of characteristics common to a collection of entities that are instances of the type.
enumerated domain  (Entity relationship modelling and class modelling) A domain that 
is specified by a list of all its permitted values.
first normal form (1NF or FNF)  (Relational data analysis) A relation is in first normal 
form if all the values taken by the attributes of that relation are atomic or scalar 
values – the attributes are single-valued or, alternatively, there are no repeating groups 
of attributes.
foreign key  (Relational data analysis) One or more attributes in a relation that imple­
ment a many-to-one relationship that the relation has with another relation or with itself 
(the reference); the values of the foreign key in a tuple must match the values of the 
primary key in one of the tuples in the referenced relation.
xxi

MODELLING BUSINESS INFORMATION
hierarchic identifier  (Entity relationship modelling) A unique identifier where at least 
one element of the identifier is a relationship; a hierarchic identifier may be either a 
combination of relationships or a combination of attribute(s) and relationship(s).
hierarchic key  (Relational data analysis) A candidate key comprising more than one 
attribute where part of the candidate key is a foreign key.
IDEF1X  (Entity relationship modelling) An entity relationship modelling notation from 
the family of ICAM (Integrated Computer-Aided Manufacturing) Definition Languages 
(IDEF) used by the US Federal Government.
information  (i) Something communicated to a person. (ii) Knowledge concerning 
objects, such as facts, events, things, processes or ideas, including concepts, which 
have a particular meaning within a certain context.
information Engineering notation  (Entity relationship modelling) An entity relationship 
modelling notation that is one of the techniques used in Information Engineering, a 
methodology developed by James Martin and Clive Finkelstein in the late 1970s.
master data management  The authoritative, reliable foundation for data used across 
many applications and constituencies with the goal to provide a single version of the 
truth.
metadata  Data about data – that is, data describing the structure, content or use of 
some other data.
multiplicity  (Class modelling) A statement, consisting of a lower-bound (or minimum) 
and upper-bound (or maximum) of the form ‘minimum..maximum’, of the number of 
elements that may exist in a collection; when applied to an association it represents the 
cardinality and optionality of the association and when applied to an attribute it repre­
sents the optionality of the attribute.
multimedia data  Data representing documents, audio (sound), still images (pictures) 
and moving images (video).
normal form  (Relational data analysis) A state of a relation that can be determined by 
applying simple rules regarding dependencies to that relation.
normalisation  (Relational data analysis) Another name for relational data analysis.
object  (Class modelling) A construct within a system for which a set of attributes and 
operations can be specified; an instance of a particular object class.
object class  (Class modelling) A definition of a set of objects that share the same 
attributes, operations and associations.
object-orientation  A software-development strategy based on the concept that sys­
tems should be built from a collection of reusable components called objects that 
encompass both data and functionality.
xxii

GLOSSARY
object subclass  (Class modelling) A subset of the instances of an object class, known 
as the superclass, that share common attributes and associations distinct from other 
subsets of the superclass.
ODMG  Abbreviation for the Object Data Management Group, a body that has produced 
a specification for object-oriented databases.
OLAP  Acronym for online analytical processing – a set of techniques that can be 
applied to data to support strategic decision-making.
OLTP  Abbreviation for online transactional processing – data processing that sup­
ports operational procedures.
operation  (Class modelling) A set of actions performed on the data within an object.
optionality  (Entity relationship modelling and class modelling) The ability of an instance 
of an entity type or object class to exist without being linked to an instance of the related 
entity type or object class. The optionality reflects part of the business rules for a rela­
tionship or association.
permitted value  (Entity relationship modelling and class modelling) One of the explicit 
set of values that comprise an enumerated domain.
primary key  (Relational data analysis) The candidate key that is selected to enforce 
uniqueness of tuples in a relation.
RDBMS  Abbreviation for relational database management system – a database man­
agement system whose logical constructs are derived from the relational model of 
data. Most relational database management systems available are based on the SQL 
database language and have the table as their principal logical construct.
relation  (Relational data analysis) The basic structure in the relational model of data – 
formally a set of tuples, but informally visualised as a table with rows and columns.
relational data analysis  A technique of transforming complex data structures into 
simple, stable data structures that obey the rules of relational data design, leading to 
increased flexibility and reduced data duplication and redundancy – also known as nor­
malisation.
relational model of data  A model of data that has the relation as its main logical construct.
relationship  (Entity relationship modelling) A named set of characteristics common to 
a collection of connections between instances of two or more entity types, or between 
instances of one entity type and other instances of the same entity type.
schema  A description of the overall structure of a database expressed in a data defini­
tion language (such as the data definition component of SQL).
second normal form (2NF or SNF)  (Relational data analysis) A relation is in second 
normal form if it is in first normal form and every non-key attribute is fully dependent 
on the primary key – there are no part-key dependencies.
xxiii

MODELLING BUSINESS INFORMATION
simple identifier  (Entity relationship modelling) A unique identifier formed from a sin­
gle attribute.
simple key  (Relational data analysis) A candidate key comprising just one attribute.
SQL  Originally, SQL stood for structured query language. Now, the letters SQL have no 
meaning attributed to them. SQL is the database language defined in the ISO/IEC 9075 
set of international standards, the latest edition of which was published in 2016. The 
language contains the constructs necessary for data definition, data querying and data 
manipulation. Most vendors of relational database management systems use a version 
of SQL that approximates to that specified in the standards.
structured data  Data that has a high level of organisation in that it conforms to speci­
fied data types and relationships and is managed by technology that allows for querying 
and reporting, such as data within relational databases and spreadsheets.
surrogate identifier  (Entity relationship modelling) An artificial (i.e. not real world) 
unique identifier formed from an attribute or a combination of attributes that are either 
system-generated or allocated by a user.
table  The logical structure used by a relational database management system 
(RDBMS) that corresponds to the relation in the relational model of data – the table is 
the main structure in SQL.
third normal form (3NF or TNF)  (Relational data analysis) A relation is in third normal 
form if it is in second normal form and no transitive dependencies exist.
tuple  (Relational data analysis) A construct in the relational model of data that is equiv­
alent to a row in a table or an occurrence of an entity – it contains all the attribute values 
for each instance represented by the relation.
Unified Modeling Language (UML)  A set of diagramming notations for systems analy­
sis and design based on object-oriented concepts.
unique identifier  (Entity relationship modelling) An attribute, a combination of attrib­
utes, a combination of relationships or a combination of attribute(s) and relationship(s) 
that provides the ability for each entity to be uniquely identifiable so that each instance 
of an entity type is distinctly identifiable from all other instances of that entity type.
unstructured data  Computerised information which does not have a data structure that 
is easily readable by a machine, including audio, video and unstructured text such as the 
body of a word-processed document – effectively this is the same as multimedia data.
validation rule  (Entity relationship modelling and class modelling) A statement of the 
validation that may be applied to a described domain; this statement may be a reference 
to a data type to be applied to attributes, a range of values, or a ‘format mask’, or any 
other expression that constrains the domain.
xxiv

INTRODUCTION
In my previous book,1 I looked at how information, and its cousin, data, should be man­
aged as an enterprise-wide resource. In this book, I am looking at the role of business 
analysts in understanding and documenting the information that needs to be recorded 
in an information system or its supporting information technology (IT) system to meet 
the needs of the business for the storage and retrieval of information.
The first part of the book (Part 1, The Basics, Chapters 1 to 6) covers the requirements 
for the Data Analysis certificate that is part of the scheme for the BCS Advanced Inter­
national Diploma in Business Analysis.2
The book will, therefore, be of immediate interest for anybody who is studying for this 
certificate. It should also be of interest to all business analysts as I have tried to set out 
how an entity relationship model (also known as an entity relationship diagram) or a 
UML class model (also known as a class diagram) can help a business analyst under­
stand the information needs of a particular business area and then help communicate 
that understanding, both to the business users and, finally, to the systems developers.
The second part of the book (Part 2, Supplementary Material, Chapters 7 to 14) provides 
extra information that I believe should be of interest to business analysts. 
These chapters are followed by three appendices. Appendix A provides a table to show 
the equivalence between the concepts used in the various parts of the book. Appendix B 
provides a bibliography and Appendix C provides solutions to the exercises introduced 
in Part 1.
1 Principles ofaData Management: Facilitating Information Sharing, Second Edition (BCS, 2013).
2 http://certifications.bcs.org/category/18428
xxv


PART 1:
THE BASICS
The first part of the book (Chapters 1 to 6), which provides a general introduction to 
entity relationship modelling and UML class modelling, covers the requirements for the 
Data Analysis certificate that is part of the scheme for the BCS Advanced International 
Diploma in Business Analysis. 
Chapter 1, Why business analysts should model information, provides an introduction to 
business analysis, systems, information, data and modelling and why these topics come 
together within the development of requirements for an IT system. The notations used 
within the book, the Ellis-Barker entity relationship notation and the UML class diagram 
notion, are introduced. The chapter finishes with a discussion of data analysis.
Chapter 2, Modelling the things of interest to the business and the relationships between 
them, introduces the basic modelling concept of the entity to represent something of 
interest to the business about which information needs to be recorded and the related 
concept of the entity types, the representation of a group of entity occurrences with 
common characteristics. The relationships between entity types are also introduced. 
Alongside the introduction of these concepts, the comparable concepts of object, object 
class and association are also introduced. 
Chapter 3, Modelling more complex relationships, explores some of the more complex 
relationships that can exist between entity types or object classes. The topics covered 
are the resolution of many-to-many relationships and associations (including the oddity 
known as the ‘Bill of Materials’ structure), mutually exclusive relationships and asso­
ciations, which leads to generalisation and specialisation, and, finally, a quick look at 
aggregation and composition.
Chapter 4, Drawing and validating information model diagrams, introduces a process for 
drawing an information model diagram. It then considers two techniques for validating 
an information model – the data navigation path and the Create-Read-Update-Delete 
(CRUD) matrix.
Chapter 5, Recording information about things, introduces the related concepts of the 
attribute, the unique identifier and the domain, and their representation on both entity 
relationship models and class models. The object-oriented concept of the operation is 
also introduced at the end of the chapter.
Chapter 6, Rationalising data using normalisation, involves a change of direction as we 
look at the process of relational data analysis (or normalisation). We need to look at the 
theory of the relational model of data – the ‘model’ that underpins all of the database
1

MODELLING BUSINESS INFORMATION
management systems that use the SQL database language. Having understood the 
theory, we then look at the process of normalisation and the production of a ‘third 
normal form’ model.
These chapters should be read sequentially, from Chapter 1 through to Chapter 6. Revision 
exercises are provided at the end of Chapters 2 to 6.
2

1	
WHY BUSINESS ANALYSTS SHOULD 
MODEL INFORMATION
This chapter provides an introduction to business analysis, systems, information, data 
and modelling and why these topics come together within the development of require­
ments for an IT system. The chapter finishes with a discussion of data analysis.
WHAT IS BUSINESS ANALYSIS?
Business analysis is a discipline that has been evolving for about 20 years. Its main 
purpose is to ensure that there is alignment between business needs and business change 
solutions. Many of these business change solutions involve the development of new – or the 
enhancement of existing – information technology (commonly abbreviated to IT) systems.
There is no fixed route to becoming a business analyst. Some business analysts have a 
strong information technology background and have developed an understanding of busi­
ness in general and their business organisation in particular. Other business analysts have 
a strong business background and, where a solution involving information technology is 
concerned, they need to have obtained an understanding both of the capabilities provided 
by information technology and of how an information technology system is developed.
The word ‘system’ appears in the two preceding paragraphs because it is important for 
the business analyst to grasp hold of ‘systems thinking’. Whether the proposed business 
change solution involves the use of information technology or not, the business analyst 
is working with or specifying the requirements for systems. These systems may be 
business systems, information systems or information technology systems.
So, what is a system?
Professor Michael C. Jackson of the University of Hull has defined a system as 
a complex whole the functioning of which depends on its parts and the interactions 
between those parts.3 
Using this definition, the term ‘system’ can be applied to a hard, designed system such 
as a central heating system or to a soft, or human activity, system such as a business 
organisation.
A central heating system consists of a boiler, radiators, pipes and, importantly, a ther­
mostat to keep the whole system under control. This is a ‘complex whole’, the function­
ing of which depends on all of those parts working together.
3 Systems Thinking: Creative Holism for Managers (2003), page 3, Michael C. Jackson.
3

MODELLING BUSINESS INFORMATION
A business, whether in the private, public or not-for-profit sectors of the economy, consists 
of people (employees, suppliers and customers), organisations (headquarters, branches, 
departments) and processes (including ordering and receiving goods and selling goods). 
All businesses require information to manage their people, organisations and processes 
and, for most businesses these days, there is information technology providing support 
for the management of that information. So, a business can be seen as another ‘complex 
whole’, the functioning of which depends on the parts, the people, the organisations, the 
processes, the information and the technology, working together to achieve the goals of 
the business. There will also be checks and balances to ensure that the business remains 
effective and efficient – the equivalent of the thermostat in the central heating system.
Any business can, therefore, be considered as a system – a business system. Any sys­
tem can have a number of subsystems, so a business system can also have subsystems.
One of the important subsystems of a business system is the information system, or 
set of information systems, which supports the business by managing the business’s 
information. I define an information system as: 
a system that gets the right information to the right person in the right place at 
the right time.
We need, therefore, to think about information systemically. If there is a requirement for 
Sue in production to receive details of an important sales order as soon as it arrives in 
the business, then we need to arrange for that to happen. It could be that the arrange­
ment is for the salesman, John, who has just completed the sale, to walk along the cor­
ridor to production to tell Sue about the sales order. The right information (details of the 
sales order) is being delivered to the right person (Sue) in the right place (the production 
department) at the right time (immediately) without the use of any technology. We have 
a technology-free information system! Yes, that is possible, but that information system 
still needs defining, developing, implementing and maintaining.
Most modern businesses require the information system to be supported by an infor­
mation technology system – a collection of hardware, software and networks that func­
tion together to store and retrieve information.
The business analyst needs to think in terms of three levels of system: the business sys­
tem itself; the subsystem that handles the information for the business (the information 
system); and the sub-subsystem that provides the technology to support the informa­
tion system (the IT system). This is shown diagrammatically in Figure 1.1.
Figure 1.1 Three levels of system
Figure 1.
1
4

WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
Information is a key business resource in all business, even if the senior managers of 
most businesses fail to recognise that fact. 
INFORMATION AND DATA
In my previous book, I explained the relationship between information and data. I repeat 
that explanation here, slightly edited, because this book is about modelling business 
information with a view to storing that information as data within an information system 
or an information technology system.
An often-heard definition of information is that it is ‘data placed in context’. This implies 
that some information is the result of the translation of some data using some processing 
activity, and some communication protocol, into an agreed format that is identifiable to 
the user. In other words, if data has some meaning attributed to it, it becomes information.
For example, what do the figures ‘190267’ represent? Presented as ‘19/02/67’, it would 
probably make sense to assume that they represent a date. Presented on a screen with 
other details of an employee of a company, such as name and address, in a field that is 
labelled ‘Date of Birth’ the meaning becomes obvious. Similarly, presented as ‘190267 
metres’, it immediately becomes obvious that this is a long distance between two places 
but, for this to really make sense, the start point and the end point have to be specified 
as well as, perhaps, a number of intermediate points specifying the route.
While these examples demonstrate the relationship between data and information, they 
do not provide a clear definition of either data or information.
There are many definitions of data available in dictionaries and textbooks, but the essence 
of most of these definitions is the understanding that data is ‘facts, events, transactions 
and similar that have been recorded’. Furthermore, the definition of information is usually 
based on this definition of data. Information is seen as data in context or data that has 
been processed and communicated so that it can be used by its recipient.
The idea that data is a set of recorded facts is found in many books on computing. 
However, this concept of data as recorded facts is used beyond the computing and infor­
mation systems communities. It is, for example, also the concept used by statisticians. 
Indeed, the definition of data given in Webster’s 1828 Dictionary – published well before 
the introduction of computers – is ‘things given, or admitted; quantities, principles or 
facts given, known, or admitted, by which to find things or results unknown’.4
However, starting the development of our definitions by looking at data first appears to 
be starting at the wrong point. It is information that is important to the business, and it 
is there that our definitions, and our discussion about the relationship between informa­
tion and data, should really start.
We start by considering the everyday usage of information – something communicated 
to a person – and, with that, we can find a definition of data that is relevant to business 
analysts. That definition is found in ISO/IEC 2382-1 1993 (Information Technology – 
Vocabulary – Part 1: Fundamental Terms) stating that data is
4 See www.webstersdictionary1828.com
5

MODELLING BUSINESS INFORMATION
a re-interpretable representation of information in a formalised manner suitable for 
communication, interpretation or processing. 
There is a note attached to this definition in the ISO/IEC standard which states that data 
can be processed by human or automatic means; so, this definition covers all forms of 
data but, importantly, includes data held in information systems used to support the 
activities of an organisation at all levels: operational, managerial and strategic.
Figure 1.2 The relationship between data and information
Figure 1.2
Figure 1.2 provides an overview of the relationship between data and information in 
the context of an information technology system. The user of the system extracts the 
required information from their overall knowledge and inputs the information into the 
system. As it enters the system, it is converted into data so that it can be stored and 
processed. When another system user requires that information to be retrieved, the data 
is interpreted – that is, it has meaning applied to it – so that it can be of use to the user.
THE IMPORTANCE FOR A BUSINESS ANALYST OF UNDERSTANDING 
INFORMATION NEEDS
Understanding the information needed by the business, and its representation, data, 
is vitally important if we are to develop effective information systems and the infor­
mation technology systems to support them. In the BCS publication Business Analysis, 
now in its third edition, the need for a business analyst to take a holistic view of the 
business is stressed, where the holistic view is defined as encompassing people, organi­
sations, processes, information and technology (my emphasis). Yet, as an examiner, 
6

WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
I am constantly coming across practising or aspiring business analysts who believe 
that understanding and documenting the information needed by the business is nothing 
to do with them. There appears to be a view that if the processes are sorted out the 
information will look after itself. I think this is wrong. We are, after all, concerned with 
information systems or information technology systems, not processing systems.
THE ROLE OF MODELS IN BUSINESS ANALYSIS
Models in various forms play an important role in business analysis. As described later 
in the chapter, models help the business analyst understand and communicate require­
ments. Modelling is an essential competence for a business analyst.
When trying to understand how a business is currently running, we could draw a rich 
picture (see Figure 1.3). 
Figure 1.3 A rich picture
Figure 
1.3
When trying to understand what a business should be doing, we can draw a business 
activity model (see Figure 1.4). Both of these valuable techniques are derived from Peter 
Checkland’s Soft Systems Methodology.5
5 Checkland, P. (1981) Systems Thinking, Systems Practice. John Wiley & Sons, Chichester, UK provides a useful insight into the 
use of Soft Systems Methodology. For a shorter read try Checkland, P., Poulter, J. (2006) Learning for Action: A Short Definitive 
Account of Soft Systems Methodology and its use for Practitioners, Teachers and Students, John Wiley & Sons, Chichester, UK.
7

MODELLING BUSINESS INFORMATION
Figure 1.4 A business activity model
Figure 1.4
When trying to understand the current business processes we will probably draw a set 
of ‘as-is’ business process models (see Figure 1.5). We will then draw a series of ‘to-be’ 
business process models and discuss those with the business.
Figure 1.5 A business process model
Figure 1
.5
8

WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
As we move on to consider the functionality that an information technology system has 
to support, we might start drawing a use case diagram (see Figure 1.6).
Figure 1.6 A use case diagram
Figure 1.6
All of these models have two main roles.
The first of these roles is to help the analyst understand the situation they are analysing 
as they carry out the analysis.
Secondly, once developed, they help the analyst communicate that understanding back 
to the business (and, in the process, maybe demonstrate their misunderstanding, lead­
ing to a correction to the model) and, in the case of an information technology system 
development or enhancement, forward to the developers of that system.
When an information technology system is being developed, the process of eliciting 
the requirements from the business, analysing those requirements to ensure that they 
are good quality requirements, validating the requirements with the business, manag­
ing and documenting the requirements is known as ‘requirements engineering’. This is 
shown in context in Figure 1.7. 
Figure 1.7 Requirements engineering in context
Figure 1.7
As you can see, we can think of requirements engineering as the filling in a sandwich, with 
the business and its requirements on one side and the system developers on the other. 
9

MODELLING BUSINESS INFORMATION
When eliciting requirements from the business, models can be used in workshops or 
other interactions with the business to aid understanding. It can sometimes be useful 
to sketch out a model on a whiteboard or flipchart while talking to the users. Models 
are vital when you are asking the business to validate a set of requirements – ‘a picture 
paints a thousand words’.
Models are also essential when passing, or discussing, requirements to, or with, those 
who will have responsibility for the development of the system. It is not just that ‘IT people’ 
like to see models. Models will often express ideas and requirements much more clearly 
than is possible in text alone.
The trick is, of course, to use the same models when validating requirements with the 
business and when passing those requirements to the developers. ‘Business people’ do 
not have the time to learn complicated modelling notations and syntax. For them the 
models must be easy to understand. On the other hand, the developers want the models 
to be complete, clear, concise and unambiguous, and this can lead to the use of a complex 
set of notational elements. It can also, in some circumstances, lead to the use of some 
particular technical constructs that, from a business perspective, are unnecessary.
If we want to use the same models to communicate with the business and to communi­
cate with the developers, we need to use modelling notations and conventions that are 
both easy for the business to understand and sufficiently detailed to completely, con­
cisely, clearly and unambiguously convey the requirements to the system developers.
DATA MODELS AND DATA
We have seen a range of models that are in the business analyst’s toolkit. None of those 
we have seen so far truly helps us to understand what information a system needs to 
hold to enable it carry out its functions. These information requirements are modelled 
with a model called, confusingly, a data model.
In fact, data models can have two roles. 
Firstly, they can be used to specify what data (or information) the business needs recorded 
within the system. Here the model is a complete, concise and unambiguous statement of 
the information requirements of the business for the system under consideration. This 
model is the responsibility of the business analyst. 
Secondly, they can also be used to specify how the data is to be stored and organised within 
the system, so that it can be retrieved and analysed. Here the model is a specification for 
the design of the database of the system. This model (or, more probably, a set of models) 
is the responsibility of the database designer within the system development team.
The what model is a conceptual model, which is also known as a Computer-Independent 
Model (CIM). It represents the things that are of interest to the business about which 
information needs to be recorded, the specific information about these things that the 
business needs recorded, and any business relationships that exist between those 
things of interest. A model at this level can be considered as encapsulating the rules of 
the business, for example:
10

WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
yy ‘people or organisations cannot be recorded as customers until they have 
placed an order’;
yy ‘customers can place many orders’; and
yy ‘customers must be allocated a customer number and we must record their 
name and address’.
The system development team then develop a series of how data models that lead 
to the design of the system’s database. The first model the developers will produce 
will be a logical model (often known as a Logical Data Model (LDM) or a Platform-
Independent Model (PIM)) and the final model will be a model that represents the 
actual physical design of the database (known as a Physical Data Model (PDM) or a 
Platform-Specific Model (PSM)).
ENTITY RELATIONSHIP MODELLING
Data models have been around for well over 50 years. The earliest data modelling 
notation that I know of was for Bachman Diagrams. This notation was developed by 
Charles Bachman, one of the early database management system pioneers, to show the 
structure of a required database in the days before the advent of the modern ‘relational’ 
database. 
Entity relationship modelling, until recently the most common form of data modelling, 
was first introduced by Peter Chen.6 There are, however, many ‘flavours’ of entity rela­
tionship model. In this book, I am going to stick to just one of these entity relation­
ship modelling notations: the notation developed by Harry Ellis and Richard Barker 
in the early 1980s when they worked for CACI, a UK-based consultancy company. 
Unsurprisingly, we will refer to this as the Ellis-Barker notation. I will, however, discuss 
some other common notations in Chapter 7.
The Ellis-Barker notation was specifically designed with business users in mind. In fact, 
in Richard Barker’s own words, they were ‘striving for even greater accuracy in systems 
analysis, while minimising redundant interactions with the users’.7 The notation was 
used by the Oracle Corporation in its computer-aided software engineering (CASE) tool 
and was later adopted, in a truncated form, by the UK Government’s Central Computer 
and Telecommunications Agency (CCTA) for its Structured Systems Analysis and Design 
Method (SSADM). Richard Barker described the use of this notation in a book8 he wrote 
while working for the Oracle Corporation.
An example of an entity relationship model drawn using the Ellis-Barker notation is 
shown in Figure 1.8.
This model shows that the business concerned is interested in recording information about 
its products, its customers and the orders placed by those customers. Each of those orders 
has a number of ‘order lines’ (the items on the order) and a number of statuses.
6 Chen, P.P.S. (1976) The Entity–Relationship Model: Toward a Unified View of Data, ACM Transactions on Database Systems.
7 In the Foreword to Hay, D.C. (1996) Data Model Patterns: Conventions of Thought. Dorset House.
8 Barker, R (1990) CASE*Method: Entity Relationship Modelling, Addison-Wesley.
11

MODELLING BUSINESS INFORMATION
Figure 1.8 An example entity relationship model using the Ellis-Barker notation
Figure 
1.8
There are a number of advantages to using the Ellis-Barker notation within business 
analysis. Specifically, the notation:
yy was designed for use with business users – it names things in a way that the 
business will understand;
yy avoids the use of technical components that have no relevance to the business 
user and, if included (as in most other notations), would confuse the business user;
yy provides a limited, consistent set of symbols;
yy with its supporting documentation, provides a complete, concise, clear and 
unambiguous statement of the information requirements.
In addition, the Ellis-Barker notation is well known in the United Kingdom, having been 
adopted for use within the Structured Systems Analysis and Design Method (SSADM). 
Although no specific notation is mentioned in the syllabus for the BCS Data Analysis 
certificate, it is, I believe, the notation that the originators of that syllabus had in mind 
for entity relationship modelling.
CLASS MODELLING
In the late 1980s and early 1990s there were a number of disparate modelling initiatives 
devised to cope with the design of systems based on the object-oriented programming 
paradigm. In the mid-1990s three proponents of their own notations, Grady Booch, Ivar 
Jacobson and James Rumbaugh (known as the three amigos) came together to create the 
Unified Modeling Language (UML)TM. In 1997 UML was adopted as a standard by the Object 
Management Group (OMG),9 and in 2005 UML was also published by the International 
Organization for Standardization (ISO)10 as an approved ISO standard. The current version 
of the UML standard includes 13 diagram types, but we are only interested in one of 
9 See www.omg.org/
10 See www.iso.org/
12

WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
those – the ‘class diagram’, which is used to model information and data. We will refer to 
the models developed using this diagramming notation as ‘class models’.
An example of a UML class model is shown in Figure 1.9. This example uses the same 
business scenario as that shown in Figure 1.8 using the Ellis-Barker notation.
Figure 1.9 An example of a UML class model
Figu
re 1.9
USE OF DATA MODELS IN BUSINESS ANALYSIS
Because this book is aimed at business analysts the focus will be on Computer 
Independent (or conceptual) Models – the models where the ‘what’, the information 
or data that is required, is specified. There will, however, be some consideration of the 
other, ‘how’, models.
The shape and form of the ‘how’ models will be determined by the database management 
system that is to be used to manage the database. There are many types of database man­
agement systems available and that means that the business analyst should not assume 
any particular type of database when developing the ‘what’ model as part of requirements 
engineering. The job of the business analyst when modelling is to concentrate on develop­
ing a model that represents the information that the business needs to be recorded; the 
business analyst should not be including anything in that model that depends on a specific 
implementation.
The example models at Figures 1.8 and 1.9 might give the impression that information 
or data modelling is a simple task leading to relatively simple databases. But these are 
just simple examples. In practice, information or data models can be very large – I have 
seen some models that completely cover the walls of a six-person office. Developing 
an information or data model is not a trivial task. Having said that, information or data 
modelling should be part of the ‘consultancy toolkit’ of all business analysts.
Developing an information or data model does not mean that we are just documenting in 
‘boxes and lines’ what we find in the business. We need to apply the business analyst’s
13

MODELLING BUSINESS INFORMATION
enquiring mind to analyse what we find. As with all requirements elicitation, as we 
develop the model we are going to find that there are unanswered questions that need 
to be answered. Through asking questions of the business about the model we can 
gradually refine the model so that the end result is useful to the business, and allows 
the needs of the business and its systems to be met. Developing an information or 
data model is an iterative process that helps us to understand the information that the 
business needs to record. This process also helps us uncover the business rules and, 
more importantly, any exceptions to the rules that need to handled.
WHAT MAKES A GOOD DATA MODEL? 
The simple answer to this is that a good model should express the totality of the infor­
mation requirements of the business clearly, concisely and unambiguously. As with 
any set of requirements, all of the requirements should be included, there should be no 
overlapping or conflicting requirements, and no requirements should be hidden within 
other requirements. 
When modelling the processes of the business, the business analyst will think in terms of 
two sets of models: the ‘as-is’ models and the ‘to-be’ models. The ‘as-is’ models are the 
result of pure analysis: the documentation of the current situation using boxes and lines. 
When developing the ‘to-be’ models the business analyst is straying from pure analysis 
into the field of synthesis or design, albeit using the same set of box and line constructs as 
for the ‘as-is’ models. The ‘as-is’ models are developed to help us come up with the ‘to-be’ 
models. The final form of the ‘to-be’ models (the designs) will depend very much on the 
experience and creativity of the business analyst who is doing the modelling.
When modelling information or data the same is true, although we do not normally 
produce an ‘as-is’ information or data model. The only time we would produce an ‘as-
is’ model is when we are reverse-engineering an existing database or carrying out 
relational data analysis on existing documents, reports or input screens. Even so, the 
purpose of the reverse-engineering or relational data analysis is to influence a model 
of the information requirements to be met by a future information system (or set of 
information systems). Such a model is a ‘to-be’ model.
All information models that are the output of the requirements engineering process can, 
therefore, be considered as the start of the design process for the future information 
system or systems. The experience and creativity of the modeller will impact not only on 
the model itself but also on the design of any future database developed from the model.
We will look at the subject of data model quality in more detail in Chapter 9.
INTRODUCING DATA ANALYSIS
‘Data analysis’ is a difficult term because it has two meanings.
One meaning of the term is the analysis of an existing collection of data to find patterns, 
trends or hidden information. The result is some insight that will be useful to the busi­
ness.
14

WHY BUSINESS ANALYSTS SHOULD MODEL INFORMATION
The other meaning is the analysis of a business domain to understand the information 
or data that needs to be recorded in an information system to meet business needs. The 
result is a data model that may lead to a database design.
While some business analysts may be involved in analysing data under the first of those 
meanings, especially when that data could be used in strategic decision-making or as 
input into a business case, it is the second meaning that is of interest to us in this book. 
Business analysis helps us understand business requirements. Some of these require­
ments are information (or data) requirements. Data analysis helps us understand those 
information requirements, probably the most important of the overall business require­
ments for an information system. Data analysis is not separate from business analysis; 
it is an essential part of business analysis.
Like many other analysis or modelling activities, data analysis and modelling can be 
approached from a top-down perspective or from a bottom-up perspective.
The top-down approach involves starting with a blank sheet of paper (or, preferably, a 
clean whiteboard) and using an appropriate set of requirements elicitation techniques 
(interviews, workshops, observation, among others) to find out what information the 
business needs to achieve its goals. This then forms the basis of the information model, 
whether it is an Ellis-Barker entity relationship model or a UML class model. We will 
look at the development of Ellis-Barker entity relationship models and UML class mod­
els in Chapters 2 to 5.
The bottom-up approach involves looking at existing ‘data sources’ – which could be 
existing databases, screens and reports for existing information systems or, in a paper-
based system, the documents and records that are maintained – to build a model that 
represents the known information requirements. 
Business analysts should use both approaches and then compare the results. They will 
seldom match. Some detail, absolutely vital to the business, may have been missed 
when looking at things from the top down. Some new requirements not handled by the 
current system will probably have been missed when looking at things from the bottom 
up. Almost certainly, the analyst will need to develop a model that is a composite of the 
top-down model and the bottom-up model.
When taking a bottom-up approach, we can use a formal technique called relational 
data analysis (which is also called normalisation) or we can just informally use our intui­
tion. Most data modellers will use the formal technique when they start data modelling 
and then move to do things informally when they are more experienced. We will look at 
relational data analysis in Chapter 6.
15

2	
MODELLING THE THINGS OF 
INTEREST TO THE BUSINESS AND THE 
RELATIONSHIPS BETWEEN THEM
This chapter introduces the basic modelling concept of the entity, to represent some­
thing of interest to the business about which information needs to be recorded, and the 
related concept of the entity type, the representation of a group of entities with common 
characteristics. The relationships between entity types are also introduced. Alongside 
the introduction of these concepts, the comparable concepts of object, object class and 
association are also introduced.
ENTITIES AND OBJECTS
Put simply, an information or data model is a model of the things of interest to a business 
about which information needs to be recorded. 
In Figures 2.1 and 2.2 are two models showing some of the things of interest to a vehicle 
hire company about which that company will need to record information. They show that 
the things of interest are the actual vehicles that the company has to hire, the ‘vehicle 
types’ that describe those vehicles, the people who are the hirers and the agreements 
made for the hire of the vehicles.
Figure 2.1 is drawn using the Ellis-Barker entity relationship notation.
Figure 2.1 The vehicle hire company using Ellis-Barker notation
Figure 2.1
16

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
Figure 2.2 is drawn using the UML class model notation.
Figure 2.2 The vehicle hire company using UML class model notationFigure 2.2
Both notations are doing the same thing but in slightly different ways.
In entity relationship modelling, the ‘things of interest to the business about which infor­
mation needs to be recorded’ are known as entities. 
In UML class modelling, the ‘things of interest to the business about which information 
needs to be recorded’ are known as objects. 
These things can be tangible things such as people, places, buildings, equipment or 
assets. They can also be more abstract concepts such as contracts, agreements or 
transactions.
In modelling, however, we are not thinking about the individual entities or objects. 
Instead we are thinking about the group or class of things that have the same charac­
teristics. 
In entity relationship modelling, a group or class of entities that have the same char­
acteristics is known as an entity type. The individual entities within the entity type are 
known as entity occurrences.
In class modelling, a group or class of objects that have the same characteristics is 
known as an object class.
For example:
yy The vehicle with vehicle registration number KW64 CNV (an entity occurrence or 
an object) is an instance of the entity type or object class VEHICLE.
17

MODELLING BUSINESS INFORMATION
yy Miss Patricia Johnson (a second entity occurrence or object) who wishes to hire 
a vehicle is an instance of the entity type or object class PERSON.
yy The agreement made with Miss Patricia Johnson to hire KW64 CNV (a third 
entity occurrence or object) is an instance of the entity type or object class HIRE 
AGREEMENT.
There are many things or concepts within the real world about which information may 
be kept. If an organisation captured information on everything that existed, that organi­
sation would find itself swamped with information, most of which it would never use. 
As business analysts, we are only interested in representing as entity types or object 
classes on models those things about which the organisation needs to keep information 
to support its role or purpose.
In an enterprise whose core business is the hire of vehicles, any system to support 
that core business will need to record information about its vehicles, its hirers and the 
hire agreements. It will also need information about the suppliers of its vehicles. If it 
is a national or international enterprise it will also need to keep information about its 
branches and its employees. As it is hiring out vehicles it will need to maintain those 
vehicles. If that is carried out in-house it will need to keep information about the facili­
ties and the mechanics. If the maintenance is out-sourced it will need to keep informa­
tion about the garages or other maintenance facilities it uses. To support all of this, the 
company will have a number of accounts and information will be needed about the 
transactions passing through those accounts. 
The company that manufactures the vehicles will have a different set of things about which 
it needs to keep information: its products (the vehicles), the parts and raw materials that 
are used to manufacture the vehicles, its stock levels, the scheduling of work on its pro­
duction line, its organisational structure, its employees and its accounts and transactions.
NAMING OF ENTITY TYPES AND OBJECT CLASSES
For a model to be meaningful to the business users, the names of our entity types and 
object classes must also be meaningful to the business. To help with the communication 
with the business, these names should use the terminology of the business and should 
describe the thing of interest about which we will be storing information (the ‘what’). 
Names that describe ‘how’ we are storing that information, and which could end up 
being the solution, should be avoided. By convention they are always singular nouns (or 
noun phrases).
Examples of acceptable entity type and object class names are:
yy VEHICLE (not VEHICLES);
yy VEHICLE TYPE (not TYPE OF VEHICLE);
yy PERSON (not PEOPLE nor PERSON FILE nor PERSON TABLE nor PERSON 
RECORD);
yy HIRE AGREEMENT (not HIRE AGREEMENTS nor HIRE HISTORY).
18

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
Most modellers show entity type names and object class names using upper case (HIRE 
AGREEMENT). Others use mixed case (Hire Agreement). Either is acceptable providing a 
consistent approach is maintained.
On a Computer-Independent Model, or conceptual model, business analysts should 
use standard English with normal spaces. Naming using ‘technical’ formats, such as 
those that use underscores (HIRE_AGREEMENT or Hire_Agreement) or camel case 
(HireAgreement), should not be used on conceptual models as they do not follow normal 
business conventions. These technical approaches to naming should be the preserve 
of the system developers.
While it is important to use names that are meaningful to the business, consistency in nam­
ing is also very important. As business users are presented with a number of models they 
will find it easier to understand those models if there is a consistent approach to naming.
INTRODUCTION TO RELATIONSHIPS AND ASSOCIATIONS
Entity types and object classes represent business concepts that are the things about 
which the business needs to keep information. Within the business these ‘things’ will 
be associated in ways that are specific to that business. In our vehicle hire business, 
vehicles are associated with hire agreements and hire agreements are, conversely, 
associated with vehicles. Also, hire agreements are associated with the person who is 
hiring the vehicle and those people are, conversely, associated with hire agreements.
These associations between our entity types or our object classes are important to the 
business as they can be considered as a reflection of the rules, conditions or constraints 
of that business. During the development of the model the business analyst must dis­
cover these associations between entity types and object classes. These associations 
form an important part of the information that needs to be recorded about each of the 
‘things’ that we have identified as entity types or object classes.
The choice of entity types and object classes is restricted to those things about which 
the business is interested (and only those things) and about which information needs to 
be recorded. The same applies to relationships and associations. There may be many 
ways in which the business concepts that are represented by entity types or object 
classes are related in the real world, but the only ones that should be included in the 
model are those that are of sufficient interest to the business that information about 
those relationships needs to be recorded.
In an entity relationship model an association between two entity types is called a 
relationship.
In a class model a relationship between two object classes is called an association.
There is no conceptual difference between a relationship in an entity relationship model 
and an association in a class model. They are the same thing; the only difference is in 
the notation.
19

MODELLING BUSINESS INFORMATION
RELATIONSHIP NOTATION IN ENTITY RELATIONSHIP MODELS
Figure 2.3 shows a part of our earlier entity relationship model. The line drawn between 
the entity types HIRE AGREEMENT and VEHICLE represents a relationship between 
those entity types.
Figure 2.3 A relationship in an entity relationship model
Figur
e 2.3
These models need to be interpreted both by business people, who are required to 
negotiate or approve the information requirements to be met by the system, and by 
technical people, who have to implement the system. It is important that the models are 
interpreted unambiguously and an important contribution to this unambiguous under­
standing is to have a formal method of ‘reading’ these relationships.
For example, consider the relationship that is introduced in Figure 2.3. Reading this rela­
tionship from right to left – from VEHICLE to HIRE AGREEMENT – we have the sentence:
Each VEHICLE may be hired through one or more HIRE AGREEMENTS
Here text formatting, CAPITALS, underlining and italics, are used in this sentence to 
indicate the different elements of the sentence, which is constructed using the follow­
ing rules:
yy The word ‘Each’ is used because the box with the word ‘VEHICLE’ inside it is an 
entity type (that is, it represents all instances of the type – all the vehicles), but 
we want to refer to a single instance of the type (that is, a single vehicle).
yy ‘Each’ is followed by the name of the entity type at the end from which we are 
starting the sentence – in this case, VEHICLE.
yy The term ‘may be’ is used because not every vehicle has to be hired (some 
might be just purchased and not yet hired) – this is represented on the diagram 
by a dashed line at the VEHICLE end of the relationship; a dashed line is always 
read as ‘may be’.
yy ‘hired through’ comes from the name of the relationship (which is also known 
as the ‘link phrase’) at the VEHICLE end of the relationship.
yy The term ‘one or more’ is used because there is an inverted three-pronged 
arrow head (known as a crow’s foot) at the HIRE AGREEMENT end of the 
relationship; a crow’s foot is always read as ‘one or more’.
yy The sentence ends with the name of the entity type at the end of the line; we 
make it plural so that the sentence reads easily, in this case, HIRE AGREEMENTS.
20

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
Each relationship should also be read in the opposite direction. Reading the relationship 
from left to right – from HIRE AGREEMENT to VEHICLE – we have the sentence:
Each HIRE AGREEMENT must be made for one and only one VEHICLE
This sentence is constructed as follows:
yy ‘Each’ is used because we want to refer to a single instance of the type.
yy HIRE AGREEMENT comes from the name of the left-hand entity type.
yy The term ‘must be’ is used because every hire agreement has to be made for 
a vehicle – this is represented on the diagram by the solid line at the HIRE 
AGREEMENT end of the relationship and a solid line is always read as ‘must be’.
yy ‘made for’ comes from the name (link phrase) of the relationship at the HIRE 
AGREEMENT end of the relationship.
yy The term ‘one and only one’ is used because there is no crow’s foot at the far 
end, the VEHICLE end, of the relationship. The absence of a crow’s foot is always 
read as ‘one and only one’ – in this case we are making an assumption that 
there is a separate hire agreement for each vehicle that is hired (which should, 
of course, be confirmed with the business).
yy VEHICLE comes from the name of the right-hand entity type.
In data modelling parlance, this relationship is known as a one-to-many relationship. 
A vehicle can be associated with many hire agreements (Each VEHICLE may be hired 
through one or more HIRE AGREEMENTS) but a hire agreement can only be associated 
with one vehicle (Each HIRE AGREEMENT must be made for one and only one VEHICLE) 
through this relationship. 
The approach to the naming of relationships employed with this notation has advan­
tages when this notation is used in models developed during business analysis.
Firstly, to be able to interpret a model the business user has only to remember four 
facts:
yy A solid line is always read as ‘must be’.
yy A dashed line is always read as ‘may be’.
yy The presence of a crow’s foot is always read as ‘one or more’.
yy The absence of a crow’s foot is always read as ‘one and only one’.
Secondly, this approach provides a complete, concise and unambiguous statement of 
the nature of the relationship. This enables each relationship to be considered as a 
representation of a business rule.
A common failing is to produce a data model without naming the relationships. The names 
are there to describe the ‘nature’ of the relationship: a vehicle is hired through a hire agree­
ment. A relationship without a name makes no more sense than an entity type without a 
name. Everybody involved in data modelling recognises that entity types should be named 
21

MODELLING BUSINESS INFORMATION
(otherwise you have an empty box on your model – ‘What does that represent?’), yet mod­
els with unnamed relationships are quite common. Without naming relationships, there 
is a distinct possibility that the reader’s understanding of the nature of a relationship will 
differ from the modeller’s understanding of the nature of that relationship.
ASSOCIATION NOTATION IN UML CLASS MODELS
The association in the class model in Figure 2.4 represents the same relationship.
Figure 2.4 An association in a UML class model
Figu
re 2.4
In the same way that a relationship on an entity relationship model indicates that the 
business sees some business association between entities that are instances of the 
entity types involved in the relationship, an association on a class model indicates that 
the business sees some business relationship between objects that are instances of 
the object classes involved in the association. They are identical concepts. However, 
there the similarity ends as the only common feature of both the association and the 
relationship is the line, with an association shown as a line joining the two object 
classes.
As with a relationship on an entity relationship model, it is good practice to give a 
name to an association on a class model, with this name representing the business 
nature of the association. The association joining the VEHICLE object class to the HIRE 
AGREEMENT object class is named ‘is hired through’. This name is annotated with a 
small triangle that points in the direction that this name should be read. Since the tri­
angle points towards the HIRE AGREEMENT object class it shows that a vehicle is hired 
through a hire agreement.
Note that in entity relationship modelling the convention is to use prepositional phrases 
(such as ‘composed of one or more PARTS’) or gerund phrases (such as ‘referencing one 
and only one PERSON’) that can follow ‘may be’ or ‘must be’, whereas the convention 
on class models is to use active verb phrases for association names (such as ‘is hired 
through HIRE AGREEMENTS’).
22

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
UML allows an alternative approach to the naming of associations. This alternative 
approach, illustrated in Figure 2.5, is to use ‘role names’ to annotate the associations, 
where these role names describe the role that the instances of the classes play with 
respect to the associations. Role names consist of nouns or noun phrases.
Figure 2.5 The use of role names
Figu
re 2.5
Instead of using crow’s feet and solid and dotted lines, UML uses a concept called 
‘multiplicity’ to annotate its associations.
The ‘0..*’ multiplicity at the HIRE AGREEMENT end of the association shown in Figures 2.4 
and 2.5 represents that each vehicle is hired through zero to many hire agreements. This 
is equivalent to ‘each vehicle may be hired through one or more hire agreements’. 
Each multiplicity has a minimum value (sometimes called the ‘lower bound’) and a 
maximum value (sometimes called the ‘upper bound’), with these values separated by 
two dots. In the case of our ‘0..*’, the minimum value or lower bound is ‘zero’, represented 
by ‘0’, and the maximum value or upper bound is ‘many’, represented by ‘*’. 
UML allows the ‘0..*’ multiplicity to be replaced by the symbol ‘*’. This leaves the reader 
to infer that the minimum value is zero. This is not good practice, especially when deal­
ing with business users.
The ‘1..1’ multiplicity at the VEHICLE end of this association represents that each hire 
agreement is for only one vehicle, equivalent to ‘each hire agreement must be for one 
and only one vehicle’. 
UML allows the ‘1..1’ multiplicity to be replaced by the number ‘1’. Again, this is not good 
practice as it leaves the reader to infer that the minimum value equals the maximum 
value.
23

MODELLING BUSINESS INFORMATION
DEGREES OF CARDINALITY AND OPTIONALITY
Cardinality is a term used in mathematical set theory. The cardinality of a set is a 
measure of the number of elements of the set. 
When modelling information, it is important that we document for each entity occur­
rence or object, how many instances of the related entity type or object class can or 
must be related to that instance. 
In the relationship shown in Figure 2.3, for each vehicle there may be many hire agree­
ments and for each hire agreement there can only be one related vehicle. The fact that 
there are ‘many’ instances at one end of the relationship and only ‘one’ instance at the 
other end is known as the cardinality of the relationship. 
When modelling information, only two measures of cardinality are normally used: ‘one’ 
and ‘many’. Hence, the relationship in the entity relationship model in Figure 2.3 between 
the VEHICLE entity type and the HIRE AGREEMENT entity type is known as a ‘one-to-
many relationship’. 
UML, however, allows an integer, such as ‘3’, to be used instead of ‘1’ (one) or ‘*’ (many). 
The multiplicity ‘0..3’ means that the lower bound is ‘zero’ and the upper bound is ‘three’ 
– there cannot be more than three associated objects but there may be none at all. 
Similarly, the multiplicity ‘5..10’ means that there are at least five associated objects but 
there cannot be more than 10.
The association in Figures 2.4 and 2.5 between the VEHICLE object class and the HIRE 
AGREEMENT object class is similarly known as a ‘one-to-many association’.
Optionality is where we consider whether an instance of an entity type or object class 
can exist without being linked to an instance of the related entity type or object class. 
In the relationship in Figure 2.3 between HIRE AGREEMENT and VEHICLE we see that for 
each and every hire agreement there must be an associated vehicle – you cannot have 
a hire agreement without a vehicle. In our entity relationship notation, the relationship 
was ‘each HIRE AGREEMENT must be made for one and only one VEHICLE’. Hence, the 
relationship from HIRE AGREEMENT to VEHICLE is a mandatory relationship.
The equivalent UML class model association in Figures 2.4 and 2.5 was read as ‘each 
HIRE AGREEMENT is for only one VEHICLE’. Similarly, the association from HIRE 
AGREEMENT to VEHICLE is a mandatory association.
Considering the relationship shown in Figure 2.3 again, we see that it is not necessary 
for each vehicle to have an associated hire agreement – the hire company could have 
just purchased a vehicle and it has not yet been hired. In the entity relationship model the 
relationship was ‘each VEHICLE may be hired through one or more HIRE AGREEMENTS’. 
Hence, the relationship from VEHICLE to HIRE AGREEMENT is an optional relationship.
The equivalent UML class model association in Figures 2.4 and 2.5 was read from 
VEHICLE to HIRE AGREEMENT as ‘each VEHICLE is rented through one or many HIRE 
AGREEMENTS’. Similarly, the association from VEHICLE to HIRE AGREEMENT is an 
optional association.
24

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
The cardinality and optionality of a relationship in an entity relationship model or an 
association in a UML class model reflect the business rules that the relationship or 
association is trying to represent.
Relationships and associations can have a cardinality of ‘one-to-many’, ‘many-to-one’, 
‘one-to-one’ and ‘many-to-many’. They can also be ‘optional–mandatory’, ‘mandatory–
optional’, ‘optional–optional’ and ‘mandatory–mandatory’. Thus, there are 16 possible 
combinations for relationships and associations. Four of these are shown in Figures 
2.6 to 2.9. 
Figure 2.6 One-to-many (1:n) optional–mandatory relationship and association
Figu
re 2.6
As we saw earlier, the relationship shown in Figure 2.6 is read as:
Each VEHICLE may be hired through one or more HIRE AGREEMENTS
Each HIRE AGREEMENT must be made for one and only one VEHICLE
The equivalent association is read as:
Each VEHICLE is hired through zero to many HIRE AGREEMENTS
Each HIRE AGREEMENT is for only one VEHICLE
The one-to-many, optional–mandatory relationship or association is the most common 
form of relationship or association on information models.
The relationship in Figure 2.7 is read as:
Each ALBUM must be comprised of one or more RECORDED SONGS
Each RECORDED SONG may be included in one and only one ALBUM
The equivalent association is read as:
Each ALBUM comprises one to many RECORDED SONGS
Each RECORDED SONG is included in zero to one ALBUM
25

MODELLING BUSINESS INFORMATION
Figure 2.7 One-to-many (1:n) mandatory–optional relationship and association
Figu
re 2.7
The one-to-many, mandatory–optional relationship or association is very rare but can be 
quite useful. It can be used when the ‘thing’ at the one end is an invented thing (such as 
an album), but the ‘thing’ at the many end can already exist (such as a recorded song).
Figure 2.8 One-to-one (1:1) optional–mandatory relationship and association
Figu
re 2.8
The relationship in Figure 2.8 is read as:
Each PROJECT may be managed by one and only one PROJECT MANAGER
Each PROJECT MANAGER must be manager of one and only one PROJECT
The equivalent association is read as:
Each PROJECT is managed by zero to one PROJECT MANAGER
Each PROJECT MANAGER manages only one PROJECT
The one-to-one relationship or association is reasonably rare and further analysis will 
often lead to a one-to-many relationship or association or even a many-to-many rela­
tionship or association (see below). A mandatory–mandatory, one-to-one relationship or 
association is very rare and will nearly always turn out to be wrong.
26

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
Figure 2.9 Many-to-many (m:n) optional–optional relationship and association
Figu
re 2.9
The relationship in Figure 2.9 is read as:
Each DOCTOR may be treater of one or more PATIENTS
Each PATIENT may be treated by one or more DOCTORS
The equivalent association is read as:
Each DOCTOR treats zero to many PATIENTS
Each PATIENT is treated by zero to many DOCTORS
There is a false perception that the many-to-many relationship or association cannot 
exist. This false perception comes from one particular database implementation (the 
relational or SQL database). The information models developed during business analy­
sis should concentrate on what information is to be held and not how that information 
is to be held. Many-to-many relationships or associations are totally acceptable on busi­
ness analysis information models.
The optional–optional, many-to-many relationship or association often appears on a 
model during the early stages of analysis. Further analysis will generally suggest that 
the original optional–optional, many-to-many relationship or association is hiding some 
information that is required by the business and needs to be included on the model. This 
idea will be investigated in Chapter 3.
MULTIPLE RELATIONSHIPS AND ASSOCIATIONS
It is possible for there to be more than one relationship or association between the same 
two entity types or object classes.
For example, our vehicle hire company can allow one-way hires, where a vehicle is 
collected from one branch and delivered back at another branch. There are, therefore, 
two distinct relationships or associations between the entity type or object class HIRE 
AGREEMENT and a new entity type or object class called BRANCH: the relationship 
27

MODELLING BUSINESS INFORMATION
or association to the branch from which the vehicle that is the subject of the hire 
agreement is collected at the start of the hire, and the relationship or association to 
the branch to which the same vehicle is delivered at the end of the hire. These will, in 
most cases, be the same branch, but in the case of a one-way hire, could be different 
branches. 
Figure 2.10 Modelling the ‘one-way’ hire situation
Figur
e 2.10
This concept is shown in Figure 2.10.
The relationships shown in Figure 2.10 are read as: 
Each BRANCH may be collection point for vehicle hired through 
one or more HIRE AGREEMENTS
Each HIRE AGREEMENT must be for vehicle collected from 
	
one and only one BRANCH
and, for the second relationship:
Each BRANCH may be reception point for vehicle hired through 
one or more HIRE AGREEMENTS
Each HIRE AGREEMENT must be for vehicle delivered to one and only one BRANCH
Similarly, the associations on the UML class model are read as:
Each BRANCH is collection point for vehicle hired through 
	
zero to many HIRE AGREEMENTS
Each HIRE AGREEMENT is for vehicle collected from only one BRANCH
and:
Each BRANCH is return location for vehicle hired through 
	
zero to many HIRE AGREEMENTS
Each HIRE AGREEMENT is for vehicle returned to only one BRANCH
28

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
RECURSIVE RELATIONSHIPS AND REFLEXIVE ASSOCIATIONS
Sometimes a business relationship will exist between instances of the same entity type 
or object class. The most typical business situation where this occurs is where one 
employee supervises a number of other employees, although there are many other 
situations where this can occur. 
Such a relationship in an entity relationship model is formally known as a recursive 
relationship while the equivalent in a UML class model is formally known as a reflexive 
association. To most modellers, however, this is known as a ‘pig’s ear’ relationship or 
association.
This concept is shown in Figure 2.11.
Figure 2.11 Employee supervision
Figure 2
.11
The relationship is read as: 
Each EMPLOYEE may be supervisor of one or more other EMPLOYEES
Each EMPLOYEE may be supervised by one and only one other EMPLOYEE
Note the inclusion of the word ‘other’ to indicate that the relationship or association is 
to a different instance of EMPLOYEE.
The class model association is read as:
Each EMPLOYEE supervises zero to many other EMPLOYEES
Each EMPLOYEE is supervised by zero or one other EMPLOYEE
Note the optionality. In the entity relationship model it is optional at both ends, indicated 
by the dotted line, and in the class model the multiplicities are zero to one (‘0..1’) at one 
end and zero to many (‘0..*’) at the other end of the association. This is typical of a recur­
sive relationship or reflexive association that represents management or supervisory 
relationships. There is always someone at the top of an organisation who is not super­
vised by anybody. Similarly, there will be employees at the bottom of the organisation 
who do not supervise anyone.
29

MODELLING BUSINESS INFORMATION
EXERCISES FOR CHAPTER 2
2.1	 Write down the formal sentences that represent the relationship in the following 
diagram:
F
igure
2.2	 Redraw the following UML class model using Ellis-Barker entity relationship notation: 
Figu
re
2.3	 Redraw the following Ellis-Barker entity relationship using UML class model notation, 
using role names instead of direct association naming: 
Figure
30

MODELLING THE THINGS OF INTEREST TO THE BUSINESS AND THE RELATIONSHIPS BETWEEN THEM
2.4	 Draw partial information models using BOTH Ellis-Barker entity relationship notation 
and UML class model notation to represent the following situations.
	
a	 A sales person is always employed within a single sales region; a sales region can 
be staffed with many sales persons.
	
b	 A flight must always be from one airport and must always be to an airport (which 
may, or may not be, the same airport); an airport can be the departure airport or 
the arrival airport for a flight.
	
c	 Within business analysis we can think of processes at three levels: at the top level 
(the organisation level) are the processes; each process comprises a series of 
tasks; and each task comprises a series of steps. It is possible to identify a process 
without identifying the tasks within that process. Similarly, it is possible to identify 
a task without identifying the steps within that task.
31

3	
MODELLING MORE COMPLEX 
RELATIONSHIPS 
This chapter explores some of the more complex relationships that can exist between 
entity types and object classes. The topics covered are the resolution of many-to-many 
relationships and associations (including the oddity known as the ‘Bill of Materials’ 
structure), mutually exclusive relationships and associations, which lead to generalisa­
tion and specialisation, and, finally a quick look at aggregation and composition.
THE PROBLEMS WITH MANY-TO-MANY RELATIONSHIPS AND ASSOCIATIONS
Although many-to-many relationships and associations are legitimate constructs to 
have on a model, they can pose a problem as they may be hiding some important infor­
mation that the business should be interested in recording. It is the job of the analyst to 
test each of these many-to-many relationships and associations to see what informa­
tion, if any, they are hiding.
In our vehicle hire business example, consider the situation where each branch has a 
number of employees working at that branch and, during their time with the company, 
an employee can be located at a number of different branches. The model for this is 
shown in Figure 3.1.
Figure 3.1 Employees and branches
Figure 3
.1
32

MODELLING MORE COMPLEX RELATIONSHIPS 
The relationship between EMPLOYEE and BRANCH is read as: 
Each EMPLOYEE must be assigned to one or more BRANCHES
Each BRANCH may be location for one or more EMPLOYEES
The equivalent class model association is read as:
Each EMPLOYEE is employed by zero to many BRANCHES
Each BRANCH employs zero to many EMPLOYEES
In this example, the entity type or object class EMPLOYEE can record information about 
each employee, such as their name, their address and their grade. Similarly, the entity 
type or object class BRANCH can record information about each branch, such as the 
name of the branch and the address of the branch.
Hidden in this relationship or association is the need for some information that is neither 
specifically about employees nor specifically about branches; this is information about 
the assignments of the employees to the branches. Such information could include, for 
example, the start and end dates of the assignments, the role while at the branch and 
whether it is a permanent or temporary assignment.
Effectively we need to record information about the relationship between the instances 
of the entity types or object classes rather than about the instances of the entity types 
or object classes themselves. 
The way out of this problem is to replace the relationship or association by a new entity 
type or object class, with appropriate relationships or associations, to hold the infor­
mation we require. This is known within the modelling community as ‘resolving the 
many-to-many’.
RESOLVING ENTITY RELATIONSHIP MODEL MANY-TO-MANY RELATIONSHIPS 
Resolving the many-to-many relationship in Figure 3.1 means that we need to replace 
the relationship with a new entity type which, in this case, it makes sense to call 
ASSIGNMENT. This new entity type will then need relationships to both the EMPLOYEE 
and BRANCH entity types. The resolution is shown in Figure 3.2.
The relationships shown in Figure 3.2 are read as: 
Each EMPLOYEE must be assigned through one or more ASSIGNMENTS
Each ASSIGNMENT must be of one and only one EMPLOYEE
and
Each BRANCH may be location for employee assigned through 
one or more ASSIGNMENTS
Each ASSIGNMENT must be to one and only one BRANCH
33

MODELLING BUSINESS INFORMATION
Figure 3.2 Introducing the ASSIGNMENT entity type
Figure
 3.2
We give a special name to entity types such as the ASSIGNMENT entity type. Such an 
entity type is known as an associative entity type. Associative entity types are some­
times (incorrectly) referred to by other names, such as ‘link entities’.
The first thing we need to do when resolving a many-to-many relationship is decide on 
a name for the associative entity type. Sometimes that is easy, as in this case, because 
there is a business concept, an assignment, about which we need to record information. 
Other times it is more difficult, and then we would need to resort to an artificial name 
such as EMPLOYEE BRANCH ASSOCIATION.
Having decided on the name of the associative entity type the next thing we need to do 
is consider the nature of the relationships from the associative entity type to the original 
entity types.
In the original relationship, each branch could be the location for many employees, so now 
a branch may be associated with many assignments. Hence ‘Each BRANCH may be … one 
or more ASSIGNMENTS’. In fact, the optionality at the BRANCH end of the new relation­
ship is exactly the same as the optionality at the BRANCH end of the original relationship.
Also in the original relationship, each employee must be assigned to at least one branch, 
so now an employee must be the subject of at least one assignment, and over time, 
maybe more than one assignment. Hence ‘Each EMPLOYEE must be … one or more 
ASSIGNMENTS’. As before, the optionality at the EMPLOYEE end of the new relationship 
is exactly the same as the optionality at the EMPLOYEE end of the original relationship.
For an assignment to exist there must be an employee being assigned and a branch to 
which they are being assigned. Hence the optionality at the ASSIGNMENT end of both 
relationships is mandatory and ‘Each ASSIGNMENT must be … EMPLOYEE’ and ‘Each 
ASSIGNMENT must be … BRANCH’.
Now we have decided:
yy the optionality at the BRANCH entity type end of the relationship from the 
ASSIGNMENT associative entity type (may be);
yy the optionality at the EMPLOYEE entity type end of the relationship from the 
ASSIGNMENT associative entity type (must be);
yy the optionality at the ASSIGNMENT associative entity type end of the relationship 
from the BRANCH entity type (must be);
34

MODELLING MORE COMPLEX RELATIONSHIPS 
yy the optionality at the ASSIGNMENT associative entity type end of the relationship 
from the EMPLOYEE entity type (must be);
yy the cardinality for the relationship to the ASSIGNMENT associative entity type 
from the BRANCH entity type (one or more);
yy the cardinality for the relationship to the ASSIGNMENT associative entity type 
from the EMPLOYEE entity type (one or more).
The only thing we now need to consider is the cardinality at the BRANCH and EMPLOYEE 
ends of the relationships from ASSIGNMENT.
In each case, we need to consider whether more than one branch can be associated with 
a single assignment (highly unlikely) or whether more than one employee can be associ­
ated with a single assignment. While it is also unlikely that more than one employee can 
be associated with a single assignment it does depend on the business definition of an 
assignment. Can a group of employees all be assigned to a branch on the same day for the 
same length of time? Or is an assignment always of a single employee to a single branch?
Since there is no crow’s foot at the EMPLOYEE end of the relationship from ASSIGNMENT 
we can assume that the definition of an assignment concerns a single employee being 
assigned to a single branch.
If the definition of an assignment allowed for more than one employee to be involved in 
that assignment there would be another many-to-many relationship from ASSIGNMENT 
to EMPLOYEE and that would need to be analysed to see if it should be resolved.
RESOLVING CLASS MODEL MANY-TO-MANY ASSOCIATIONS
The equivalent resolution of the relationship in Figure 3.1 is shown in the UML class 
model in Figure 3.3.
Figure 3.3 Introducing the ASSIGNMENT object class
Figure 3.3
35

MODELLING BUSINESS INFORMATION
UML allows the use of a special type of class, called an association class, with a many-
to-many association to avoid the need to resolve that many-to-many association. The 
use of an association class in our example is shown in Figure 3.4. Please note the 
dashed association to the many-to-many association itself.
Figure 3.4 Introducing the ASSIGNMENT association class
Figure 3
.4
THE ‘BILL OF MATERIALS’ STRUCTURE
It is very common for recursive relationships or reflexive associations to be ‘many-
to-many’ and, thus, to need resolving. The resultant structure is known as a bill of 
materials structure.
Consider the recursive many-to-many relationship and the equivalent reflexive 
many-to-many association shown in Figure 3.5.
Figure 3.5 Introducing products within products
Figu
re 3.5
The situation depicted here is a manufacturing enterprise, perhaps the manufacturer of 
some of the vehicles that our example company hires. This manufacturer has the prod­
ucts that are manufactured (such as the trucks, vans and cars) and the products that are 
36

MODELLING MORE COMPLEX RELATIONSHIPS 
used in their manufacture (such as the chassis, the engines and the wheels). Engines, in 
turn are made up of other products (valves, bolts and so on). And some of these smaller 
products will be used in more than one of the larger products. As well as selling the 
trucks, vans and cars, the manufacturer will also be selling the wheels, engines, valves, 
bolts and other components to organisations that are carrying out repairs and mainte­
nance and even to the end-users who want to maintain their own vehicles. Hence, we 
have the many-to-many relationship or association. 
Applying the standard rules for resolving many-to-many relationships and associations, 
we get the structures shown in Figures 3.6 and 3.7.
Figure 3.6 The bill of materials structure in Ellis-Barker notation
Figure 3
.6
Figure 3.7 The bill of materials structure in UML class model notation
Figu
re 3.7
So, why is this familiar pattern known as a bill of materials structure? 
‘Bill of materials’ is a term in common use in the manufacturing industry, where a bill 
of materials is a list of the raw materials, subassemblies, components, parts (and the 
quantities of each) needed to manufacture an end product.
37

MODELLING BUSINESS INFORMATION
This is exactly what the example illustrates. There are the instances of PRODUCT, the 
things you can actually touch, the finished products of the manufacturing process, the 
trucks, the vans and the cars, and the components used within them, such as the wheels 
and the engines.
The choice of name for the associative entity type and object class is particularly dif­
ficult. There is a tendency to call it something like PRODUCT COMPONENT, or even 
just COMPONENT, but this would be wrong because both of these names suggest that 
instances are also tangible things. But you cannot touch the instances of the associative 
entity type and object class – it is purely a concept, saying that, for example, there is one 
engine in a car and a car has four wheels (or that could be five, if you count the spare). 
The information recorded in the associative is the fact that a particular type of wheel 
(an instance of PRODUCT) is included in a particular model of car (another instance of 
PRODUCT) and there are four or five wheels, as appropriate in that particular model of 
car. Hence, the choice of name (PRODUCT COMPONENT SPECIFICATION) for the associa­
tive entity type and object class in the example.
The bill of materials structure in information modelling is not restricted to manufactur­
ing. It can appear when modelling requirements in a number of different circumstances 
within organisations. For example, consider a business that is organised using a matrix 
structure.11 When a matrix organisation structure is used, each employee can have more 
than one supervisor at the same time. Under these circumstances the structure we saw 
earlier in Figure 2.11 needs to be adapted to recognise the many-to-many status of the 
supervisory relationship, as shown in Figure 3.8.
Figure 3.8 Employee supervision in a matrix organisation
Figure 3
.8
If we need information about these supervisions, such as start and end dates and the 
status of the supervision, then that many-to-many relationship needs resolving. This is 
shown in Figure 3.9.
Despite the fact that this has nothing to do with manufacturing and the ‘list of the raw 
materials, subassemblies, components, parts (and the quantities of each) needed to 
manufacture an end product’, this is still commonly called a ‘bill of materials’ structure 
within the modelling community.
11 An organisational structure in which the reporting relationships are set up as a grid, or matrix, rather than in the traditional 
hierarchy; for example, an employee may report both to a functional manager and to a product or project manager.
38

MODELLING MORE COMPLEX RELATIONSHIPS 
Figure 3.9 Employee supervision in a matrix organisation resolved
Figu
re 3.9
MUTUALLY EXCLUSIVE RELATIONSHIPS AND ASSOCIATIONS
Figure 3.10 repeats the Ellis-Barker model for the vehicle hire company that we first 
saw in Figure 2.1.
Figure 3.10 The vehicle hire company as shown in Figure 2.1
Figure 3.10
In this model, all of their hirers were people, but what would happen if some of the hir­
ers could be companies? Now we would have to introduce a new entity type, COMPANY, 
and have a similar relationship between HIRE AGREEMENT and COMPANY as we have 
between HIRE AGREEMENT and PERSON.
Normally, if an entity type is related to two or more other entity types all relationships apply 
for all instances of that entity type. In this case, however, only one of the two relationships 
between HIRE AGREEMENT and COMPANY and between HIRE AGREEMENT and PERSON 
can apply for any one instance of HIRE AGREEMENT. A hire agreement is made with a 
person or a company but not with both. These two relationships are mutually exclusive.
39

MODELLING BUSINESS INFORMATION
We recognise that relationships are mutually exclusive by using an arc (called an exclu­
sive arc) that crosses the ‘either/or’ relationship lines, as shown in Figure 3.11.
Figure 3.11 The introduction of an exclusive arc
Figure 3.11
These relationships are read as:
Each PERSON may be hirer in one or more HIRE AGREEMENTS
Each COMPANY may be hirer in one or more HIRE AGREEMENTS
Each HIRE AGREEMENT must be made with one and only one PERSON 
	
OR made with one and only one COMPANY
In Figure 3.11 dots were placed where the exclusive arc intersects the relationship lines. 
These dots are not necessary in this simple situation but can be helpful when develop­
ing larger, more complex models to show which relationships are in which exclusive 
group of relationships represented by each exclusive arc.
UML allows constraints between associations to be included on a class model and the 
most common form of constraint is the ‘exclusive-or’ constraint, which is indicated by 
an ‘{xor}’ symbol. The associations involved in the constraint are joined by a dashed line. 
This is shown in Figure 3.12.
Although exclusive arcs and {xor} constraints are very useful, particularly in the early 
stages of modelling, they can be hiding some important facts that should be exposed 
on the model. In our vehicle hire company, for instance, there may be a need to record 
different information about a hire agreement made with a person from that needed 
for a hire agreement made with a company. This leads us on to a consideration of the 
concepts of generalisation and specification.
40

MODELLING MORE COMPLEX RELATIONSHIPS 
Figure 3.12 The introduction of the {xor} constraint
Figu
re 3.12
GENERALISATION AND SPECIALISATION IN ENTITY RELATIONSHIP MODELS
Specialisation, and its reverse, generalisation, is where we recognise that the entity occur­
rences (the instances) of one of our entity types has a number of distinct subsets of those 
entity occurrences, with each of those subsets having some characteristics in common.
This is illustrated in Figure 3.13 where we recognise that there are two subsets of hire 
agreement, those that are personal hire agreements and those that are company hire 
agreements.
We have created a separate entity type for each of those subsets, known as a subtype, 
which is drawn within the supertype, the superset of the subsets. This ‘boxes within 
boxes’ depiction, currently unique to the Ellis-Barker notation, is very easy for business 
users to understand. Subtypes depict the way that the business classifies the different 
things of interest to the business.
In our example, HIRE AGREEMENT is the supertype with two subtypes: PERSONAL HIRE 
AGREEMENT and COMPANY HIRE AGREEMENT. 
When we start with HIRE AGREEMENT and recognise that there are subtypes such 
as PERSONAL HIRE AGREEMENT and COMPANY HIRE AGREEMENT we say that we 
are employing specialisation. If we start with entity types such as PERSONAL HIRE 
AGREEMENT and COMPANY HIRE AGREEMENT and recognise that there is really a 
supertype called HIRE AGREEMENT we say that we are employing generalisation. Others 
call this a supertype–subtype hierarchy.
41

MODELLING BUSINESS INFORMATION
Figure 3.13 An example of a supertype–subtype hierarchy 
Figure 3.13
Each instance of PERSONAL HIRE AGREEMENT is also an instance of HIRE AGREEMENT. 
Likewise, each instance of COMPANY HIRE AGREEMENT is also an instance of HIRE 
AGREEMENT. In the real world, in each case there is only one actual occurrence of 
a hire agreement, but it simultaneously exhibits the characteristics of both a HIRE 
AGREEMENT (the supertype) and either a PERSONAL HIRE AGREEMENT or a COMPANY 
HIRE AGREEMENT (the appropriate subtype).
Each instance of HIRE AGREEMENT must, therefore, also be seen as an instance of 
PERSONAL HIRE AGREEMENT or an instance of COMPANY HIRE AGREEMENT. 
All of the properties of the HIRE AGREEMENT entity type (the supertype) apply, therefore, 
to each and every instance of the PERSONAL HIRE AGREEMENT entity type and to each 
and every instance of the COMPANY HIRE AGREEMENT entity type (the subtypes). We say 
that the subtypes inherit all of the properties of the supertype.
Three fundamental rules we apply to supertype–subtype hierarchies when using the 
Ellis-Barker entity relationship notation are:
yy Subtypes are disjoint (or mutually exclusive) – a personal hire agreement 
cannot also be a company hire agreement and a company hire agreement 
cannot also be a personal hire agreement.
yy The hierarchy is complete – all instances of HIRE AGREEMENT are either 
instances of PERSONAL HIRE AGREEMENT or instances of COMPANY HIRE 
AGREEMENT. If there are other types of hire agreement they must be shown on 
the diagram as subtypes of HIRE AGREEMENT.
42

MODELLING MORE COMPLEX RELATIONSHIPS 
yy Subtypes are immutable – a personal hire agreement cannot change into a 
company hire agreement and a company hire agreement cannot change into a 
personal hire agreement.It is sometimes said that the hierarchy is static.
Although these rules can make life difficult for the modeller they do provide a dis­
cipline that has benefits if the rules are followed. This discipline will lead to clearer 
and less ambiguous models. These will lead to more stable and flexible database 
designs. 
An alternative depiction of supertypes and subtypes that uses mandatory–manda­
tory, one-to-one relationships and an exclusive arc is shown in Figure 3.14. This use 
of this depiction is now seldom used because of the superior ‘boxes within boxes’ 
depiction.
Figure 3.14 Alternative depiction of a supertype–subtype hierarchy
Figure 
3.14
Note that these one-to-one relationships are unnamed – the only circumstance where 
this is acceptable. These relationships are read as:
Each PERSONAL HIRE AGREEMENT must be one and only one HIRE AGREEMENT
Each COMPANY HIRE AGREEMENT must be one and only one HIRE AGREEMENT
Each HIRE AGREEMENT must be one and only one PERSONAL HIRE AGREEMENT 
OR one and only one COMPANY HIRE AGREEMENT
GENERALISATION AND SPECIALISATION IN CLASS MODELS
UML class models have a similar concept to entity relationship models, with object 
classes known as superclasses and subclasses, shown in Figure 3.15.
The subclasses, PERSONAL HIRE AGREEMENT and company HIRE AGREEMENT, are 
linked to their superclass, HIRE AGREEMENT, by a branching arrow.
43

MODELLING BUSINESS INFORMATION
Figure 3.15 A UML superclass–subclass hierarchy
Figu
re 3.15
UML also allows an alternative notation. Here each subclass is linked to the superclass 
using its own arrowhead. This is shown in Figure 3.16.
Figure 3.16 Alternative notation for a UML superclass–subclass hierarchy
Figu
re 3.16
Using this alternative notation that uses one arrowhead per subclass can at times be 
confusing, especially as UML allows the use of multiple superclass–subclass hierarchies. 
An example of the use of multiple superclass–subclass hierarchies is shown in Figure 3.17.
Here we see that an employee, represented by an instance of the EMPLOYEE class, may 
be classified by their gender, by their role within the company and by whether they are 
a branch manager or not (their status). To represent this, we have three specialisation 
hierarchies – UML calls these generalisation sets. The discriminators – ‘role’, ‘gender’ 
and ‘status’ – are used to distinguish between these generalisation sets.
44

MODELLING MORE COMPLEX RELATIONSHIPS 
Figure 3.17 A UML class model with multiple superclass–subclass hierarchies
Figure
 3.17
The rules applied by UML generalisation sets are different from the rules that apply 
when using the Ellis-Barker entity relationship notation. The UML rules for generalisa­
tion sets are as follows:
yy Generalisation sets can be ‘disjoint’ or ‘overlapping’: when a generalisation set 
is disjoint the instances of any one subclass within a superclass are mutually 
exclusive with the instances of each of the other subclasses that are specified 
for that superclass; when a generalisation set is overlapping the instances of 
the subclasses within a superclass are not mutually exclusive.
yy Generalisation sets can be ‘complete’ or ‘incomplete’: when a generalisation set 
is complete each of the instances of the superclass are also instances of one of 
the subclasses that are specified for that superclass; when a generalisation set 
is incomplete some of the instances of the superclass are not instances of any 
of the subclasses that are specified for that superclass.
yy Generalisation sets can be ‘static’ or ‘dynamic’: when a generalisation set 
is static each of the instances of the subclasses within a superclass are 
immutable – that is, an instance of one subclass within a superclass cannot at 
some later date change to become an instance of another subclass within the 
same superclass. When a generalisation set is dynamic each of the instances of 
the subclasses within a superclass are not immutable – that is, an instance of 
one subclass within a superclass can change to become an instance of another 
subclass within the same superclass at some time in the future.
The UML default for a generalisation set is ‘disjoint’, ‘incomplete’ and ‘static’. UML class 
models are annotated to indicate the nature of any generalisation set that is not ‘disjoint’, 
‘incomplete’ and ‘static’. In the example, all employees are either male or female and the 
generalisation set is annotated as ‘complete’. Also, employees cannot have both male 
and female gender at the same time but it is possible for them to change their gender 
over time, so the generalisation set is annotated as ‘dynamic’. 
45

MODELLING BUSINESS INFORMATION
AGGREGATION AND COMPOSITION
Aggregation and composition are real-world concepts that have implications for future 
database design. They should be shown, therefore, on our information models.
Despite the fact that in the non-technical world the words ‘aggregation’ and ‘compo­
sition’ are near synonyms – in Roget’s Thesaurus they are both shown as synonyms 
of ‘assemblage’ – and are often used interchangeably, they have specific and distinct 
meanings for us.
The Ellis-Barker entity relationship modelling notation does not have any special sym­
bols for aggregation and composition, so the fact that aggregation or composition is 
involved can only be shown through the choice of appropriate optionality and names for 
any relationship that is involved. UML does, however, have special symbols for aggrega­
tion and composition.
Aggregation is a special form of relationship or association that specifies a whole–part 
relationship between the aggregate (whole) and its component parts, where those com­
ponent parts can have an independent existence irrespective of whether the aggregate 
exists or not. So, for example, if the branches of our vehicle hire company are organ­
ised into areas under an area manager, the areas are the aggregates, which can be 
represented by a new AREA object class, and the branches are the component parts, 
represented by the BRANCH object class. 
An Ellis-Barker representation of the aggregation of branches within areas is shown in 
Figure 3.18.
Figure 3.18 Aggregation using Ellis-Barker notation
Figure
 3.18
In a UML class model, the fact that the instances of AREA are aggregates can be rep­
resented by the addition of a white diamond at the AREA end of the association to 
BRANCH. This is shown in Figure 3.19.
Composition is a stronger form of aggregation where the life of the component parts 
is dependent on the existence of the whole. Consider a situation where a company is 
receiving orders for its products or services. We will call these sales orders, with the 
sales orders (the wholes) represented in Figure 3.20 by the SALES ORDER object class. 
Each of these sales orders can be for more than one product or service. The specifica­
tion of the products or services ordered we will call ‘sales order items’ (the component 
parts) and these are represented by the SALES ORDER ITEM object class. The existence 
of a sales order item is dependent on the existence of the sales order of which it is a 
part. If the sales order is deleted, all of the sales order items must also be deleted. 
46

MODELLING MORE COMPLEX RELATIONSHIPS 
Figure 3.19 An example of the use of the aggregation symbol in a UML class model
Figu
re 3.1
9
In a UML class model, the fact that the instances of SALES ORDER are composed of 
instances of SALES ORDER ITEM can be represented by the addition of a black diamond 
at the SALES ORDER end of the association to SALES ORDER ITEM.
Figure 3.20 An example of the use of the composition symbol in a UML class model
Figure 3.20
An Ellis-Barker representation of the composition of sales order items within sales 
orders is shown in Figure 3.21.
Figure 3.21 Composition using Ellis-Barker notation
Figure 3.21
47

MODELLING BUSINESS INFORMATION
Aggregation and composition, and the associated UML symbols, can be difficult con­
cepts for business users to understand. These concepts should be used with care, espe­
cially on models that need to be discussed with business users. In fact, a good case can 
be made for business analysts not to use the UML symbols for aggregation (the white 
diamond) and composition (the black diamond) since some business users find their use 
confusing and they add little to the model that cannot be explained in other ways. These 
symbols are mentioned here for completeness – you might sometimes see a UML class 
model that includes these symbols in a model prepared by someone else.
EXERCISES FOR CHAPTER 3
3.1	 Using Ellis-Barker entity relationship notation, resolve the many-to-many relationship 
in the following diagram:
F
igure
3.2	 Using UML class model notation, resolve the many-to-many association in the 
following diagram: 
Figu
re
3.3	 Using Ellis-Barker entity relationship notation, resolve the many-to-many relationship 
in the following diagram: 
Figure
48

MODELLING MORE COMPLEX RELATIONSHIPS 
3.4	 Draw partial information model diagrams using both Ellis-Barker entity relationship 
notation and UML class model notation to represent the following situations. In each 
case, any many-to-many relationships or associations should be resolved. Any mutu­
ally exclusive relationships or associations should be shown. Any subtypes or sub­
classes should also be shown.
	
a	 A student must register for at least one course, but can register for more than one 
course; a course can have many students registered for that course.
	
b	 An actor can play roles in many films; a film can have many actors playing roles.
	
c	 An employee can be assigned to a department or to a project; projects and depart­
ments can each have many employees assigned to them.
	
d	 A bank provides business accounts, which can only be held by business organisa­
tions, and personal accounts, which can only be held by individuals; some per­
sonal accounts, joint personal accounts, may have an additional holder; business 
organisations or individuals can hold more than one appropriate account.
3.5	 A business can receive orders from external organisations or from its own branches. 
Draw one or more partial information model diagrams using the Ellis-Barker entity 
relationship notation to represent this situation. Any mutually exclusive relationships 
or associations should be shown. Any subtypes or subclasses should also be shown. 
(Note: there are a number of solutions to this exercise depending on the assumptions 
that are made.)
49

4	
DRAWING AND VALIDATING 
INFORMATION MODEL DIAGRAMS
This chapter introduces a process for drawing an information model. It then consid­
ers two techniques for validating an information model – the data navigation path 
(sometimes called a query access path or an enquiry access path) and the CRUD 
(Create-Read-Update-Delete) matrix.
THE MODEL DRAWING PROCESS
There are many different approaches to drawing an information model. The more 
experienced modellers will draw on many of these approaches during any set of 
modelling sessions. What all of these approaches have in common, however, is that 
none of them will allow you to arrive at a final model in one go. The very act of model­
ling will raise further questions, the answers to which will often, if not always, lead to 
some enhancement of the model. As an analyst, you should be doing more than simply 
documenting what you are told using ‘boxes and lines’ – you should be fully analysing 
the situation to determine the deep underlying nature of the information being used 
by the business.
I recall that, back in the early 1990s, when I was relatively new to information and data 
modelling – well before the widespread use of drawing packages and tools to support 
modelling – I naively asked one of the consultants then working with us when I would 
know that a model was complete. The answer I got was ‘When the Tipp-Ex [correction 
fluid] on the model is so thick that it is able to stand on its edge’. The implication of this 
statement is that even an experienced modeller has to rework a model many, many 
times. This statement is as true today as it was 25 years ago.
Which is all very well, but it does not really help someone who is new to modelling. What 
is needed is a ‘recipe’ from which a modeller can cook an acceptable model. Just such 
a recipe is illustrated in Figure 4.1.
There are seven steps to this process:
(1)	 Using a scenario or some other textual description of the situation, identify 
the entity types or object classes.
(2)	 Identify the direct relationships or associations between the identified entity 
types or object classes.
(3)	 Draw an initial diagram of entity types/object classes and relationships/
associations.
50

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
(4)	 Validate the diagram, probably using a data navigation path or a CRUD matrix.
(5)	 Update the diagram as necessary as a result of the validation.
(6)	 Revalidate the diagram.
(7)	 Iterate through steps (4) to (6) as many times as necessary until all of the 
information requirements have been identified.
Figure 4.1 The model drawing process
F
igure  4.1
IDENTIFYING THE ENTITY TYPES OR THE OBJECT CLASSES
As we saw earlier, entities and objects are identifiable things of interest to the business 
about which information needs to be recorded. These entities and objects can be tangi­
ble things such as people, places, buildings, equipment or assets, or intangible concepts 
such as contracts or transactions.
Our models do not, however, show entities or objects – they show entity types or object 
classes. An entity type is defined as a template for a set of entities with the same char­
acteristics, while an object class is similarly defined as a template for a set of objects 
with the same characteristics. When we identify entity types we are also identifying 
object classes.
To identify entity types or object classes we need to identify those sets of ‘things of 
interest to the business’ that have the same characteristics. Each of these things must 
be things about which the business needs to record information and each instance also 
needs to be individually identifiable. This identification could be because each instance 
of the entity type or object class has a unique name or serial number (within the busi­
ness under consideration).
51

MODELLING BUSINESS INFORMATION
So, now let us consider our vehicle hire business replenishing its stock of vehicles for 
hire. The business will issue a purchase order to one of its suppliers. There is a business 
rule that information is not recorded about suppliers until a purchase order has been 
placed upon the supplier. Each purchase order is for a quantity of vehicles which may 
or may not be all the same model, with each vehicle type (or model) being documented 
as a separate item on the purchase order. 
Upon acceptance of a purchase order, the supplier will fulfil the order placed upon it by 
making a delivery, or a number of deliveries, of vehicles. On receipt of a delivery, each 
of the items delivered (the vehicles) will be checked to make sure that (i) it correctly 
corresponds with an item that was included in a purchase order, and (ii) it is acceptable 
– for example, there is no damage to the vehicle. 
So, what are the ‘things of interest’ in this scenario that will form our entity types or 
object classes? One simple way is look for the nouns, or noun phrases.
This little scenario has seven potential entity types or object classes. At this point it is 
also useful to start developing a definition for each of our potential entity types or object 
classes – these help to clarify our understanding and prevent misunderstanding later 
on. See Table 4.1 for the identified entity types/object classes and definitions.
Table 4.1 Identified entity types or object classes 
Entity type or 
Object class
Definition
SUPPLIER
A legal entity (company or organisation) that supplies us with 
goods and/or services. 
PURCHASE ORDER
An authorisation issued by us to a supplier indicating the types, 
quantities and agreed prices for the supply of goods or services.
PURCHASE 
ORDER ITEM
An essential component part of a purchase order being the 
specification on that purchase order of the type, quantity and 
agreed price for the supply of a particular good or service.
VEHICLE TYPE
A particular brand or model of vehicle sold by a manufacturer 
identified with a particular body type, a particular engine type, 
a particular transmission type and a particular first year of 
production.
DELIVERY
A formal hand-over of goods or services to us by a supplier or 
their agent.
DELIVERY ITEM
An essential component part of a delivery being a particular 
good or service that has been delivered as part of that delivery.
DELIVERY ITEM 
RECONCILIATION
An agreement, or otherwise, that a delivered item correctly 
corresponds with a purchase order item and that it is acceptable 
to us, being of appropriate quality and without damage.
52

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
IDENTIFYING THE RELATIONSHIPS OR ASSOCIATIONS
Step 2 of the process is to identify the relationships or associations between the entity 
types and object classes. There will be many relationships or associations, but some 
of these will be what are called indirect relationships or associations – relationships or 
associations that link two entity types or object classes via another entity type or object 
class. We are not interested in those (from a modelling point of view). We are only inter­
ested in the direct relationships or associations – those relationships or associations 
that directly link one entity type or object class to another. 
One approach to the identification of relationships or associations is to produce a matrix, 
such as in Figure 4.2. This approach is only really feasible for relatively small models, 
but it does provide a starting point for a ‘new modeller’.
Figure 4.2 A ‘relationship matrix’
Figure 4
.2
Every place there is a direct link between two entity types or object classes the 
appropriate cell in the matrix is marked. Sometimes it is useful at this stage to think 
of a verb or verb phrase that describes the business link that the relationship or 
association represents. This will later help us with the naming of the relationship or 
association.
For example:
yy Each purchase order is raised against a supplier (and only one supplier).
yy Each purchase order item is part of a purchase order (and only one purchase order).
yy Each purchase order item is for a vehicle type (and only one vehicle type).
yy Each delivery is originated by a supplier (and only one supplier).
yy Each delivery item is part of a delivery (and only one delivery).
yy Each delivery item reconciliation is of a delivery item (and only one delivery item).
yy Each delivery item reconciliation is against a purchase order item (and only one 
purchase order item).
53

MODELLING BUSINESS INFORMATION
DRAWING THE INITIAL DIAGRAM
Step 3 of our process is to make a first attempt at drawing our model diagram. While 
this sounds easy, this is probably the most difficult step. Not only do we need to decide 
on a layout, but we also need to consider the cardinalities and optionalities which we 
generally ignored when we were identifying the relationships and associations. 
Our first attempt at the Ellis-Barker entity relationship model is at Figure 4.3 and the 
equivalent UML class model is at Figure 4.4.
Figure 4.3 The initial Ellis-Barker entity relationship model
Figure 4.3
Figure 4.4 The initial UML class model
Figure 4.4
54

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
At this stage, it is useful to consider the nature of each of the relationships and ensure 
that our selection of optionality and cardinality is correct.
The relationship or association from SUPPLIER to PURCHASE ORDER:
Each SUPPLIER must be subject of one or more PURCHASE ORDERS
Each PURCHASE ORDER must be raised against one and only one SUPPLIER
This agrees. We were told that a purchase order is issued to one supplier and that there 
is a business rule that information is not recorded about suppliers until a purchase 
order has been placed upon the supplier. 
The relationship or association from PURCHASE ORDER to PURCHASE ORDER ITEM:
Each PURCHASE ORDER must be composed of one or more PURCHASE ORDER ITEMS
Each PURCHASE ORDER ITEM must be part of one and only one PURCHASE ORDER
A purchase order item was defined as an essential component part of a purchase order, 
so a purchase order must have at least one purchase order item and each purchase 
order item must be part of a single purchase order.
The relationship or association from VEHICLE TYPE to PURCHASE ORDER ITEM:
Each VEHICLE TYPE may be cited in one or more PURCHASE ORDER ITEMS
Each PURCHASE ORDER ITEM may be for one and only one VEHICLE TYPE
We were told that, when replenishing its vehicle stock, the business issues purchase 
orders for vehicles with each vehicle type (or model) documented as a separate item 
on the purchase order. On the other hand, a purchase order was defined so that it could 
include goods or services other than vehicles. So, not every purchase order item has to 
be for the ordering of vehicles, hence the optional nature of this relationship.
The relationship or association from SUPPLIER to DELIVERY:
Each SUPPLIER may be originator of one or more DELIVERIES
Each DELIVERY must be originated by one and only one SUPPLIER
We were told that a supplier will fulfil the orders placed upon it by making a number of 
deliveries (hence ‘one or more’).
The relationship or association from DELIVERY to DELIVERY ITEM:
Each DELIVERY must be composed of one or more DELIVERY ITEMS
Each DELIVERY ITEM must be part of one and only one DELIVERY
A delivery consists of a number of delivery items (the vehicles). Without at least one 
delivery item there is no delivery, hence each delivery must be composed of delivery 
items.
55

MODELLING BUSINESS INFORMATION
The relationship or association from DELIVERY ITEM to DELIVERY ITEM 
RECONCILIATION:
Each DELIVERY ITEM may be subject of 
one and only one DELIVERY ITEM RECONCILIATION
Each DELIVERY ITEM RECONCILIATION must be of one and only one DELIVERY ITEM
We were told that, on receipt of a delivery, each of the items delivered (the vehicles) will 
be checked (reconciled) to make sure that (i) it correctly corresponds with an item that 
was included in a purchase order, and (ii) it is acceptable – undamaged. Each delivery 
item (a vehicle), therefore, has one reconciliation – this is a separate concept from the 
delivery item itself – but each delivery item reconciliation must be linked to a specific 
delivery item. The reconciliation may not take place until sometime after delivery has 
been taken.
The relationship or association from PURCHASE ORDER ITEM to DELIVERY ITEM 
RECONCILIATION:
Each PURCHASE ORDER ITEM may be object of
one or more DELIVERY ITEM RECONCILIATIONS
Each DELIVERY ITEM RECONCILIATION must be against 
one and only one PURCHASE ORDER ITEM
We were told that one of the purposes of delivery item reconciliation is to check that 
the delivery item corresponds with an item that was included in a purchase order 
(purchase order item). Each purchase order item (an order for a number of vehicles 
of a particular type) can, therefore, be reconciled with many delivery items (individual 
vehicles), but each delivery item reconciliation must be against a single purchase order 
item. At any one time there can be purchase order items that are awaiting delivery or 
reconciliation.
VALIDATING THE DIAGRAM
Now we come to the issue of validating the diagram – step 4 of our process.
One approach would be to talk again to the business to confirm that we have correctly 
understood and documented the requirements. This could be done informally during 
the elicitation phase of the requirements engineering process or more formally as part 
of requirements validation. Before we move into requirements validation, however, we 
would hope that we have fully understood and documented the requirements. We would, 
therefore, have probably already used some other validation technique.
We could look at the documentation used within the business and apply the relational 
data analysis process (see Chapter 6) to produce another model. This can then be used 
to compare with our model to highlight any deficiencies.
Two other common validation techniques are the development of data navigation paths 
and the development of CRUD matrices.
56

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
Validating the diagram by using data navigation paths
Providing we understand the queries that will be used against the recorded informa­
tion, we can validate our model by envisaging those queries being applied to data in a 
database that has been designed using this model. These queries can be documented 
in a diagram that represents the navigation of the data. Such a diagram is called a data 
navigation path.12
Consider the following query:
Determine the suppliers of vehicles of a particular vehicle type ordered during the 
month of November 2016.
The data navigation path diagram, using a suitable notation, for this query is shown in 
Figure 4.5.
Figure 4.5 The first data navigation path
Figure 
4.5
Using the vehicle type details, we enter the set of VEHICLE TYPE instances and iterate 
through those instances (iteration is shown by an asterisk ‘*’ in the top right hand corner). 
As we iterate through the VEHICLE TYPE instances we query each VEHICLE TYPE 
instance to find the required vehicle type (the ‘o’ indicates ‘option’).
We note from the model that there is a one-to-many association from VEHICLE TYPE to 
PURCHASE ORDER ITEM, which means that for each instance of VEHICLE TYPE there is 
a related set of PURCHASE ORDER ITEM instances. Having found our required instance 
of VEHICLE TYPE we can enter the relevant set of PURCHASE ORDER ITEM instances. 
12 These are sometimes also called ‘query access paths’ or ‘enquiry access paths’.
57

MODELLING BUSINESS INFORMATION
We note from the model that there is a many-to-one association from PURCHASE 
ORDER ITEM to PURCHASE ORDER. For each instance of PURCHASE ORDER ITEM there 
is only one related instance of PURCHASE ORDER and, for each PURCHASE ORDER ITEM 
instance, we navigate to this related instance of PURCHASE ORDER.
We inspect each of these instances in turn to see if the date of the purchase order is 
within November 2016.
We note from the model that there is a many-to-one association from PURCHASE 
ORDER to SUPPLIER – for each instance of PURCHASE ORDER there is only one related 
instance of SUPPLIER. For each of the PURCHASE ORDER instances with a purchase 
order date within November 2016 we navigate to the related instance of SUPPLIER.
Thus, we determine that we can answer the query ‘determine the suppliers of vehicles 
of a particular vehicle type ordered during the month of November 2016’.
Now let us consider a second query:
Determine the branches to which a particular supplier has made deliveries.
The data navigation path diagram for this query is shown in Figure 4.6.
Figure 4.6 The second data navigation path
Figure 
4.6
Using the supplier details, we enter the set of SUPPLIER instances and iterate through 
them. As we iterate through the SUPPLIER instances we query each one to find the 
required supplier.
We note from the model that there is a one-to-many association from SUPPLIER to 
DELIVERY – for each instance of SUPPLIER there may be many linked instances of 
DELIVERY. We navigate to this set of DELIVERY instances that relate to the required sup­
plier and iterate to each instance within this set to find the branch to which the delivery 
was made.
58

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
Now we have a problem because there is no related entity type or object class to rep­
resent the ‘branch’ concept. But ‘branch’ is almost certainly a concept that represents a 
thing of interest about which the business needs to record information.
From this we determine that we need to add a BRANCH entity type or object class to the 
model with a relationship or association to DELIVERY so that:
Each DELIVERY must be to one and only one BRANCH
Each BRANCH may be recipient of one or more DELIVERIES
Our revised Ellis-Barker entity relationship model is at Figure 4.7 and the equivalent 
UML class model is at Figure 4.8.
Figure 4.7 The revised Ellis-Barker entity relationship model
Figure 4.7
Validating the diagram by developing a CRUD matrix
Our second common validation technique involves the use of a special kind of matrix 
– a CRUD matrix. A CRUD matrix recognises that the four basic operations that can be 
applied to data within a database are operations that:
yy create data;
yy read data;
yy update data;
yy delete data.
59

MODELLING BUSINESS INFORMATION
Figure 4.8 The revised UML class model
Figure 4.8
The reason we develop a CRUD matrix is to compare the entity types or object classes 
on our model against the business processes to ensure that there are processes in 
place to create the information before it needs to be read or updated, and that, where 
appropriate, there are processes to delete the information. A CRUD matrix enables us 
to spot any deficiencies in our model.
A partial high-level process map for our vehicle hire business is shown at Figure 4.9.
Figure 4.9 Partial high-level process map
Figure 4.
9
60

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
A CRUD matrix has the entity types or object classes along one axis and the processes 
along the other axis, with the cells annotated with the letters C, R, U or D as appropriate. 
The CRUD matrix of entity types and object classes against the relevant processes for 
the ‘vehicle replenishment’ scenario is at Figure 4.10.
Figure 4.10 Completed CRUD matrix
F
i
gure 4
.
1
0
The completed CRUD matrix highlights two problems that we had not identified earlier.
The first problem is that the original text said that there is a business rule that informa­
tion is not recorded about suppliers until a purchase order has been placed upon that 
supplier. This was represented by the relationship:
Each SUPPLIER must be subject of one or more PURCHASE ORDERS
There is, however, a process called ‘Identify suppliers’ that is executed before the ‘Order 
new vehicles’ process. This implies that information is recorded about the suppliers 
before the purchase orders are raised and that the relationship should be:
Each SUPPLIER may be subject of one or more PURCHASE ORDERS
The second problem highlighted by the development of this CRUD matrix is that there is 
a process called ‘Return rejected vehicle’ that can be executed after the ‘Receive vehicle 
delivery’ process. This implies that there is a missing entity type or object class to han­
dle the return of a vehicle that is rejected after the delivery item reconciliation. Further 
investigation reveals that this is indeed true – if a vehicle is rejected, the supplier is 
contacted and asked to arrange collection, and information needs to be recorded about 
this collection. Thus, a new entity type or object class, REJECTED VEHICLE COLLECTION, 
related to DELIVERY ITEM RECONCILIATION, is required. The relationship or association 
will be fully optional because not every instance of REJECTED VEHICLE COLLECTION will 
be initiated by an instance of DELIVERY ITEM RECONCILIATION, and not every instance 
of DELIVERY ITEM RECONCILIATION will give rise to an instance of REJECTED VEHICLE 
COLLECTION. 
Our final Ellis-Barker entity relationship model is at Figure 4.11 and the equivalent UML 
class model is at Figure 4.12.
61

MODELLING BUSINESS INFORMATION
Figure 4.11 The final Ellis-Barker entity relationship model
Figure 4.11
Figure 4.12 The final UML class model
Figure 4.1
2
62

DRAWING AND VALIDATING INFORMATION MODEL DIAGRAMS
Once we have revised our model, we should revalidate and, if necessary, revise again. 
This process is carried on until we are satisfied that the diagram faithfully meets the 
information needs of the business area under investigation.
EXERCISES FOR CHAPTER 4
4.1	 Draw partial information model diagrams using both Ellis-Barker entity relationship 
notation and UML class model notation to represent the following business situation:
	
The Fordland Optical Company provides spectacles to order for a number of clients, 
most of whom are high street opticians. Each job undertaken by the company is the 
result of an order from a client; the company does not make spectacles for stock. 
	
The completion of each job is the responsibility of a single employee. When finished, 
each job comprises a frame, selected from a selection of frames held in stock, and 
two lenses. The properties of each lens are specified on a prescription; some lenses 
will be stock lenses, but others will need to be made by an employee, who may be a 
different employee from the employee tasked with the responsibility for the job.
4.2	 The following model is a representation, using Ellis-Barker entity relationship nota­
tion, of some of the information needed by Tam Bruce Hardware Ltd, a chain of retail 
hardware stores located in the south and west of the United Kingdom, to manage 
their business.
F
igure
63

MODELLING BUSINESS INFORMATION
	
a	 Develop a data navigation path diagram to determine whether this model can 
answer the following query:
	
	
Determine the employees who sold a particular stock item (SKU2756) on 20 
October 2016. Also, determine the stores those employees were working at and 
the till they were using at the time.
	
b	 Below is a partial high-level process map for Tam Bruce Hardware Ltd.
Figure
	
Develop a CRUD matrix to show which information is created, updated or read in each 
process (ignore the deletion of information for this exercise).
64

5	
RECORDING INFORMATION ABOUT 
THINGS
This chapter introduces the related concepts of the attribute, the unique identifier and the 
domain, and their representation on both entity relationship models and class models. 
The object-oriented concept of the operation is also introduced at the end of the chapter.
REVISITING ENTITY TYPES, OBJECT CLASSES, RELATIONSHIPS AND 
ASSOCIATIONS
Figure 5.1 shows the type of model we saw at the end of Chapter 3.
Figure 5.1 The previous models
Figu
re 5.1
Until now we have only seen entity types or objects classes and the relationships or 
associations between them.
Entity types or object classes represent the things of interest to the business or organisa­
tion about which the business or organisation needs to record information. Examples are:
yy The vehicle with vehicle registration number KW64 CNV (an entity occurrence or 
an object) is an instance of the entity type or object class VEHICLE.
yy Miss Patricia Johnson (a second entity occurrence or object) who wishes to hire 
a vehicle is an instance of the entity type or object class PERSON.
65

MODELLING BUSINESS INFORMATION
yy The agreement made with Miss Patricia Johnson to hire KW64 CNV (a third 
entity occurrence or object) is an instance of the entity type or object class HIRE 
AGREEMENT and also an instance of the entity type or object class PERSONAL 
HIRE AGREEMENT.
Relationships or associations represent some link between those things that are of 
interest to the business, so that, for example:
Each VEHICLE may be hired through one or more HIRE AGREEMENTS
Each HIRE AGREEMENT must be made for one and only one VEHICLE 
or:
Each VEHICLE is hired through zero to many HIRE AGREEMENTS 
Each HIRE AGREEMENT is made for only one VEHICLE 
This chapter introduces two other important concepts that we use in modelling informa­
tion – the attribute and the domain. 
INTRODUCTION TO ATTRIBUTES
Relationships and associations provide some of the information that is required by the 
business or organisation: which hire agreements are made for each vehicle and which 
vehicle is cited in each hire agreement, for instance.
But there is more information we want to know and record about the entity occurrences 
and objects. For example, we saw above that one of the instances of the entity type or 
object class VEHICLE has a vehicle registration number of KW64 CNV. Furthermore, all 
instances of the entity type or object class VEHICLE will have a vehicle registration num­
ber. There are also other things that the business will wish to record about all of their 
vehicles, such as the colour of the vehicles and the date that the vehicle was last serviced.
These pieces of information, the vehicle registration number, the colour of the vehicles 
and the date that the vehicle was last serviced are known as attributes. An attribute is 
defined as:
a property of an entity or object that is used to qualify, identify, classify, quantify 
or in some other way express the state of that entity or object. 
All instances of an entity type have the same attributes as do all instances of an object 
class. Note that the attribute concept is common to both entity relationship modelling 
and class modelling, although the notations used are different.
In the same way that we distinguished entity occurrences (the instances) from entity 
types (the group of entities with the same characteristics), we draw the same distinction 
between the ‘attribute occurrence (the value)’ and ‘attribute type’. The attribute 
66

RECORDING INFORMATION ABOUT THINGS
occurrence KW64 CNV is the value taken by the attribute type ‘vehicle registration 
number’ of one of the instances of the entity type VEHICLE.
From here on we shall use the terms ‘attribute’ (instead of ‘attribute type’) and ‘value’ 
(instead of ‘attribute occurrence’).
Attributes should be shown on models that are to be discussed with the business. The inclu­
sion of attributes makes a model easier to understand by non-technical business people.
Figure 5.2 shows the entity relationship model that we previously saw at Figure 3.13, 
only now with attributes, the pieces of information we wish to record, added. This shows 
our vehicle hire agency with two types of hire agreement, the personal hire agreement, 
made with persons, and the company hire agreement, made with companies.
Figure 5.2 Attribute types shown on an Ellis-Barker entity relationship model
Figure 5.2
The ‘start date time’ attribute of the HIRE AGREEMENT entity type is annotated with the 
symbol ‘(m)’. This indicates that this attribute is mandatory, which implies that for each 
and every hire agreement there must be a value recorded for the ‘start date time’ attribute. 
In other words, the start date and time of the hire of the vehicle by this person or company 
for which this hire agreement was raised must always be known and recorded.
The ‘actual return date time’ attribute of the HIRE AGREEMENT entity type is annotated 
with the symbol ‘(o)’. This indicates that this attribute is optional, which implies that for 
each and every hire agreement a value may be recorded for the ‘actual return date time’ 
attribute. The date and time that the vehicle will be returned at the end of the hire will 
not be known when information about a hire agreement is first recorded. 
67

MODELLING BUSINESS INFORMATION
On entity relationship models, all attributes are ‘single-valued’ – an attribute can never 
take more than one value at a time. There can only be one value of the ‘start date time’ 
attribute for any instance of the HIRE AGREEMENT entity type.
Despite the ‘single valued attribute’ convention (or rule, as some would say), in modern 
databases a value to be assigned to an attribute can be quite complex. For this reason, busi­
ness analysts do not need to get too hung up on the detail. For example, there is a ‘name’ 
attribute in the PERSON entity type. Some would need to split this down so that they have 
attributes of ‘title’, ‘given names’ and ‘family name’, but this is unnecessary unless there is 
a specific business requirement to break names down in this way. A person’s name might 
actually be recorded as three separate values for three different attributes or could be one 
of the complex value types, but that decision is part of the how and that should be something 
for the system developers to consider. The same argument applies to the ‘correspondence 
address’ attributes in both the PERSON and COMPANY entity types.
The equivalent attributed UML class model is shown in Figure 5.3.
Figure 5.3 Attributes shown on a UML class model
Figu
re 5.3
When attributes are added to a class model the only requirement, according to the UML 
specification published by the Object Management Group, is that the attributes have 
names. It is, however, good practice to add a multiplicity for each attribute.
68

RECORDING INFORMATION ABOUT THINGS
The ‘actual return date time’ attribute of the HIRE AGREEMENT object class is shown 
with a multiplicity of ‘[0..1]’. The ‘0’, the ‘lower bound’ of this multiplicity, indicates that 
there can be zero values for this attribute. The ‘1’, the upper bound, indicates that there 
can only be a maximum of one value for this attribute. From this we can conclude that 
the ‘actual return date time’ attribute of the HIRE AGREEMENT object class is single-
valued and optional.
The ‘start date time’ attribute of the HIRE AGREEMENT object class is shown with a mul­
tiplicity of ‘[1..1]’. The ‘1’ for the ‘lower bound’ indicates that there must be at least one 
value for this attribute. At the same time, the ‘1’ for the upper bound indicates that there 
cannot be more than one value for this attribute. From this we can conclude that the ‘start 
date time’ attribute of the HIRE AGREEMENT object class is single-valued and mandatory.
The UML specification allows multiplicities such as ‘[1..2]’ and ‘[0..5]’ or even ‘[1..*]’ and 
‘[0..*]’. In the PERSON object class in Figure 5.3 there are two attributes for telephone 
numbers. One is for the primary contact number. The multiplicity for this attribute is 
‘[1..1]’, so we can see that this attribute is mandatory. There is also an attribute for an 
alternative contact number. This has a multiplicity of ‘[0..1]’, so we can see that this 
attribute is optional. An alternative way to model this would be to have a single attribute, 
called, say, ‘contact telephone numbers’, which would have a multiplicity of ‘[1..2]’. Since 
the ‘lower bound’ is ‘1’ the attribute is mandatory (it must take at least one value) and 
because the ‘upper bound’ is ‘2’ the attribute may take a second value.
THE NAMING OF ATTRIBUTES
As with entity types and object classes, attributes are normally named with a noun or 
noun phrase. This name should clearly represent the business meaning of the value 
to be recorded for any instance of the attribute. By convention, an attribute name is 
normally singular. 
Again, by convention, the name of the entity type or object class containing the attribute is 
not normally included in the name of the attribute, but is used with the attribute name when 
referring to the attribute conversationally. Attribute names must be unique within the entity 
type or object class, but not necessarily unique within the model. So, we have the attribute 
‘name’, not ‘person name’, within the entity type or object class PERSON and we also have 
an attribute ‘name’ within the entity type or object class COMPANY. In conversation, how­
ever, we would call these attributes ‘PERSON name’ and ‘COMPANY name’ respectively. 
It is advisable not to use abbreviations in the names of attributes as this can lead to 
confusion when discussing models with the business, especially where the abbreviation 
is not in common use. There is also a danger that abbreviations can be used inconsist­
ently within a modelling team. A very common example of this is where ‘number’ is 
abbreviated inconsistently to ‘no’, ‘num’, ‘nmbr’ or ‘nbr’.
ENTITY TYPE, OBJECT CLASS OR ATTRIBUTE?
Attributes exist to provide the ability to qualify, identify, classify, quantify or in some 
other way express the state of an entity occurrence or object. Entity occurrences and 
69

MODELLING BUSINESS INFORMATION
objects are instances of entity types and object classes respectively. Both attributes and 
entity types or object classes are named using nouns or noun phrases. 
When, therefore, should a particular concept be modelled as an entity type or object 
class or as an attribute? There are two factors that will influence this decision: the 
circumstances of the business under review; and the experience of the modeller. There 
are, however, some simple steps a modeller can take to try to resolve this question.
Firstly, if you find that you have an entity type or object class with too many attributes, 
be suspicious, for this normally indicates that there is more analysis to be done. In this 
case, you will almost certainly find that some of those attributes are really describing 
things of interest about which the business needs to record information so they could 
(or, even should) be an entity type or object class in their own right. How many is ‘too 
many’? One rule of thumb that can be applied is that more than eight attributes is prob­
ably too many. 
Secondly, you should ensure that all of the attributes of an entity type or object class 
really represent characteristics or properties of the thing (concept) that is represented 
by the entity type or object class that contains those attribute types. There is always 
the danger that we have an attribute of a concept that should really be an attribute of 
another concept. 
We could, for example, create an entity type or object class called EMPLOYEE with attrib­
utes such as ‘staff number’, ‘name’, ‘birth date’, ‘residence address’, ‘contact telephone 
number’, ‘alternative contact telephone number’, ‘national insurance number’, ‘employ­
ment start date’, ‘employment end date’, ‘next-of-kin name’, ‘next-of-kin relationship’, 
‘next-of-kin address’ and ‘next-of-kin contact telephone number’.
No doubt you can think of information that a business would wish to record about its 
employees, but there we have 13 attributes, which is, according to the rule of thumb, too 
many. So, let us consider those attributes and see where it takes us.
The attributes ‘staff number’, ‘employment start date’ and ‘employment end date’ con­
cern a period of employment, but all of the other attributes represent characteristics of 
the people who are employed. We need, therefore, an entity type or object class called 
PERSON.
Each person who is employed could have more than one period of employment with 
our vehicle hire company, so there could be more than one value for both of ‘employ­
ment start date’ and of ‘employment end date’. This implies that we need a new entity 
type or object class called, say, PERSON EMPLOYMENT and there will be a one-to-many 
relationship from PERSON to PERSON EMPLOYMENT.
A person’s name can change because of marriage, divorce, deed poll (a legal docu­
ment that proves a change of name) or just a desire to be known by another name. 
This leads to another new entity type or object class called PERSON NAME, with a 
one-to-many relationship from PERSON to PERSON NAME. Attributes of PERSON 
NAME will probably be able to record the date of the change of name (‘effective date’) 
and the reason for the change (‘change reason’) as well as the name itself (‘name’). Of 
70

RECORDING INFORMATION ABOUT THINGS
course, in our business we may only be interested in the current name of any people 
we employ or do business with and creating a PERSON NAME entity type or object 
class would, in these circumstances, be unnecessary. It is important to understand 
the business needs.
There is an attribute of EMPLOYEE called ‘residence address’. More than one employee 
might live at the same address and the address (or rather the property represented 
by the address) could, therefore, become something of interest to the business about 
which information needs to be recorded. Also, an employee may change their residence. 
Now there is a many-to-many relationship to a new entity type or object class called 
PROPERTY with an associative entity type or object class to handle the dates that the 
employee was resident at that property.
Finally, there are four attributes associated with a next-of-kin. A next-of-kin is a person, 
and could even be another person who is also employed by our vehicle hire company. 
Instead of these attributes there should be a structure to recognise that a person can 
only have one next-of-kin, but someone designated as a next-of-kin can be a next-of-kin 
for more than one person.
Our entity type or object class of EMPLOYEE with 13 attributes could be shaken out into 
the Ellis-Barker entity relationship structure shown in Figure 5.4 if there was sufficient 
business need.
Figure 5.4 EMPLOYEE expanded (shown in Ellis-Barker entity relationship notation)
Fi
gure 5.4
71

MODELLING BUSINESS INFORMATION
Figure 5.5 shows the equivalent UML class model structure.
Figure 5.5 EMPLOYEE expanded (shown in UML class modelling notation)
Figure 5
.5
UNIQUE IDENTIFIERS
An entity type represents a set of entities, where an entity is thing of interest to the 
business about which information needs to be recorded. An attribute of an entity type 
is a property that is used to qualify, identify, classify, quantify or in some other way 
express the state of an entity. 
If we wish to record information about an entity and then to later retrieve that informa­
tion (for, why else would we be recording the information), that entity must be identifi­
able in some way. Each entity type must, therefore, have some characteristics that 
make each instance of the entity type uniquely identifiable. In that way, each instance of 
an entity type will be distinctly identifiable from all other instances of that entity type. 
It is useful, therefore, to identify those characteristics of an entity type that can be used 
to make each instance of the entity type uniquely identifiable. Not surprisingly, those 
characteristics are known as a unique identifier. The identification of unique identifiers 
is an essential part of the modelling of information.
A unique identifier for an entity type can be defined as:
an attribute, a combination of attributes, a combination of relationships or a 
combination of attribute(s) and relationships(s) that provides the ability for 
each entity to be uniquely identifiable so that each instance of an entity type 
is distinctly identifiable from all other instances of that entity type.
72

RECORDING INFORMATION ABOUT THINGS
In Figure 5.6 unique identifiers have been added to our attributed entity relationship 
model for our vehicle hire company:
Figure 5.6 Unique identifiers on an Ellis-Barker entity relationship model
Figure 5.6
The VEHICLE entity type has three attributes: ‘vehicle registration number’, ‘colour’ and 
‘last serviced date’. The vehicle hire company will have many vehicles of the same col­
our, so the ‘colour’ attribute cannot be used as a unique identifier. Also, many vehicles 
can be serviced on the same date, so the ‘last serviced date’ attribute cannot be used. 
However, if it is a rule within the business that once a vehicle joins the hire fleet its 
registration will not change, the ‘vehicle registration number’ attribute can be used 
as a unique identifier. For the VEHICLE entity type, therefore, we can select the single 
attribute ‘vehicle registration number’ as the unique identifier. A single attribute used 
as a unique identifier is known as a simple identifier. We replace the ‘(m)’ symbol of 
the ‘vehicle registration number’ attribute to the ‘(#)’ symbol to indicate that it is the 
unique identifier. All elements of a unique identifier are mandatory, so the ‘(#)’ symbol 
subsumes the ‘(m)’ symbol.
The VEHICLE TYPE entity type has a total of six attributes: ‘manufacturer’, ‘model name’, 
‘engine type’, ‘transmission type’, ‘first sale date’ and ‘last sale date’. A Vauxhall Astra is 
a different type of vehicle from a Vauxhall Corsa. A Vauxhall Corsa with a petrol engine 
and manual transmission is a different type of vehicle from a Vauxhall Corsa with a 
diesel engine and automatic transmission. Furthermore, Vauxhall frequently updates 
the Corsa. From this we can deduce that we need, at least, the combination of the values 
73

MODELLING BUSINESS INFORMATION
of the ‘manufacturer’, ‘model’, ‘engine type’, ‘transmission type’ and ‘first sale date’ 
attributes to uniquely identify a type of vehicle. All of these five attributes are annotated 
with the symbol ‘(#)’ to indicate that they are all part of the unique identifier. Where the 
unique identifier is a combination of two or more attributes it is known as a composite 
identifier.
The PERSON entity type has four attributes: ‘name’, ‘correspondence address’, ‘primary 
telephone number’ and ‘alternative telephone number’. The ‘alternative telephone num­
ber’ attribute cannot be used as part of the unique identifier because it is optional – an 
attribute must be mandatory to be considered as part of a unique identifier. None of 
the other attributes, ‘name’, ‘correspondence address’ or ‘primary telephone number’, 
can be guaranteed to be unique for any one person. Equally, there is no combination 
of mandatory attributes that can be guaranteed to be unique for any one person. It is 
possible that there are two women known as Patricia Johnson, a mother and daughter, 
who both use the same address for correspondence. Under these circumstances, where 
there are no ‘real-world’ identifiers, we create a new attribute, in this case called ‘identi­
fier’. A unique identifier created because there is no real-world identifier is known as 
a surrogate identifier. Surrogate identifiers are normally, but not exclusively, a single 
attribute called ‘identifier’.
The HIRE AGREEMENT entity type has only two mandatory attributes: ‘start date time’ 
and ‘due return date time’. Neither of these is sufficient on its own as a unique iden­
tifier. We could create another surrogate identifier but unique identifiers normally 
reflect some rule within the business and surrogate identifiers should be avoided 
wherever possible. There is, however, a set of characteristics which can uniquely iden­
tify a hire agreement, and this is the combination of the vehicle and the date and time 
that the hire started. The unique identifier is, therefore, the combination of the ‘start 
date time’ attribute, now annotated with a ‘(#)’, and the mandatory relationship from 
the HIRE AGREEMENT entity type to the VEHICLE entity type, which is now marked 
with a bar to show that it is an identifying relationship. This is known as a hierarchic 
identifier. 
The identification of unique identifiers, and their agreement with the business, helps to 
clarify some of the rules of the business.
There is no equivalent concept with information or data models created using the UML 
class model notation. This is because class models were originally devised to support 
the development of object-oriented systems where each object has a system generated 
‘object identifier’ which is hidden from the user.
DOMAINS
An attribute exists to provide values that help to qualify, identify, classify, quantify or in 
some other way express the state of the instances of an entity type or object class. Each 
attribute value is drawn from a domain, which can be defined as:
a named pool of values from which an attribute must take its value.
74

RECORDING INFORMATION ABOUT THINGS
In other words, a domain provides a set of business validation rules, format constraints 
and other properties for one or more attributes. A domain can exist as a list of specific 
values, as a range of values, as a set of qualifications or any combination of these.
In practice, for all instances of an entity type or an object class the values of any one 
attribute must be taken from a single domain. A domain may, however, be the provider 
of values for more than one attribute. 
Each domain can be classified as being of one of two types: the enumerated domain, 
a domain that consists of a fixed list of permitted values, and the described domain, a 
dynamic domain with new values being added and deleted as necessary – a described 
domain is sometimes called a non-enumerated domain.
The permitted values that constitute an enumerated domain are normally values that 
are obtained from the business. For example, the enumerated domain called ‘VEHICLE 
COLOUR’ provides values for the ‘colour’ attribute of the VEHICLE entity type or object 
class. The values the business has decided it wishes to use for the specification of col­
ours of the vehicles that it has available for hire are ‘black’, ‘white’, ‘silver’, ‘blue’, ‘green’, 
‘red’ and ‘beige’.
A described domain grows or shrinks as new values are added or deleted. For example, 
the ‘TELEPHONE NUMBER’ domain provides values for the ‘primary telephone number’ 
and the ‘alternative telephone number’ attributes of PERSON and the ‘telephone num­
ber’ attribute of COMPANY. When a telephone number is recorded for a new person or 
company the size of the ‘TELEPHONE NUMBER’ domain grows. When the record of a 
person or company is deleted, and the associated telephone numbers are also deleted, 
the domain shrinks. There may, or may not, be a rule, often called a validation rule, 
attached to a described domain to constrain the values of the domain.
Domains represent a business concept. They are not a technical concept. It is important 
that domains are recognised and documented during business analysis. With entity 
relationship modelling there is no standard approach to the documentation of domains. 
This is also true of described domains in class modelling. There is, however, a stand­
ard way of representing an enumerated domain on a class model, using a special type 
of ‘class’ called an ‘enumeration class’. This is shown in Figure 5.7 for the ‘VEHICLE 
COLOUR’ domain. 
THE UML EXTENDED ATTRIBUTE NOTATION
A very rich full notation for attributes is available in the UML specification for class 
models. Most of this extended notation is not used by business analysts. It is, however, 
shown in Figure 5.8 and described below for completeness. 
As well as the name of the attribute and its multiplicity, an attribute specification on a 
class model can include a data type for the values, any default value, any constraints 
that might apply to the values and an indication as to whether the attribute is a derived 
attribute.
The data type for the values for the attribute can be a primitive data type, a structured 
data type or an enumerated type.
75

MODELLING BUSINESS INFORMATION
Figure 5.7 The UML <<enumeration>> class
Figu
re 5.7
Figure 5.8 The UML extended attribute notation
Figu
re 5.8
76

RECORDING INFORMATION ABOUT THINGS
Examples of a primitive data type include ‘String’ for the name and the telephone num­
ber attributes in PERSON, ‘Calendar Date’ and ‘Calendar Date Time’ for the various date 
and date–time attributes and ‘Interval’ for the attribute that shows the duration of the 
hire in HIRE AGREEMENT.
An example of a structured data type, a data type defined for a particular application or 
group of applications, is ‘Address’ for the ‘correspondence address’ attributes in PERSON 
and COMPANY and the ‘billing address’ attribute in COMPANY HIRE AGREEMENT.
An example of an enumerated type, a data type that draws its values from an enumer­
ated domain, is ‘VEHICLE COLOUR’ for the ‘colour’ attribute in VEHICLE. 
A default value that an attribute will take in the absence of any other value is shown fol­
lowing an equals sign. An example is the ‘=now’ in the specification of ‘start date time’ 
in HIRE AGREEMENT. In the event that no value is given for the ‘start date time’ attribute 
for an instance of HIRE AGREEMENT, the database will default to the date and time when 
the details of the agreement are first entered into the database.
A constraint that will apply to a value of an attribute is shown in curly brackets. An 
example of a constraint is the ‘{<= today}’ for the ‘last serviced date’ attribute of the 
object class VEHICLE. This says that we cannot record a date of the last service that is 
sometime in the future (the date must be less than or equal to the current date).
A derived attribute, an attribute whose value is calculated or in some other way derived 
from the values of one or more other attributes, is preceded by a ‘/’ symbol. There may 
also be an attached note showing how the values are derived. The attribute ‘actual 
hire duration’ in HIRE AGREEMENT is an example of a derived attribute shown with an 
attached note showing how the duration of the hire is calculated.
SHOWING OPERATIONS ON CLASS MODELS
An object class is represented on a class model by a box. This box is split into three 
sections. The top section shows the name of the class. The middle section is used to 
specify the attributes. The bottom section, not used so far, is for the specification of the 
operations available for instances of the class.
The formal definition of an object in UML is: 
a discrete entity with a well-defined boundary and identity, that encapsulates state 
and behaviour; an instance of a class.13
From this definition, an object is really an entity. In both entity relationship modelling and 
class modelling the state of any entity or object is determined by the values assigned to 
the attributes. Behaviour in objects is important, however, when we move into the design 
13 From Rumbaugh, J. Jacobson, I. Booch, G. (1994) The Unified Modeling Language Reference Manual (2nd edition) Addison-
Wesley (quoted in Arlow, J. and Neustadt, I. (2005) UML 2 and the Unified Process: Practical Object-Oriented Analysis and 
Design, Second Edition. Addison-Wesley).
77

MODELLING BUSINESS INFORMATION
of IT systems based on object-oriented principles. The behaviour of an object is deter­
mined by the operations specified for the class to which the object belongs.
It is the signatures of the operations that are shown in this third section. There must 
then be program code to implement these operations for the class. A set of operations 
for the VEHICLE class is shown in Figure 5.9.
Figure 5.9 The UML operations notation
Figure 5.9
The first six operations in Figure 5.9 update or retrieve values for the attributes of the 
VEHICLE class. 
The operations that start with the keyword ‘set …’ write a value for the attribute. The 
‘(Vehicle Colour)’ in the specification for the ‘set vehicle colour (Vehicle Colour)’ operation 
is the data type of the parameter that needs to be passed to the code module for the 
operation (the input parameter).
The ‘get …’ operations read the attribute value. The ‘:Vehicle Colour’ in the specification 
for the ‘get vehicle colour () : Vehicle Colour’ operation is the data type of the value that 
will be returned as the result of running the code for the operation. There is no input 
parameter – the parentheses are empty.
The seventh and eighth operations are associated with the association from VEHICLE to 
VEHICLE TYPE, which is a many-to-one association. 
The operation ‘set vehicle associated vehicle type (Vehicle Type)’ creates a new link 
between this instance of VEHICLE and the instance of VEHICLE TYPE represented by 
the input parameter.
The operation ‘get vehicle associated vehicle type () : Vehicle Type’ returns the instance 
of VEHICLE TYPE linked to this instance of VEHICLE.
78

RECORDING INFORMATION ABOUT THINGS
The 9th, 10th and 11th operations are associated with the association from VEHICLE to 
HIRE AGREEMENT, a one-to-many association. 
As before, the operation ‘set new vehicle associated hire agreement (Hire Agreement)’ 
creates a new link between VEHICLE and HIRE AGREEMENT. 
The operation ‘get single vehicle associated hire agreement (calendar date) : Hire 
Agreement’ returns the instance of HIRE AGREEMENT associated with this instance of 
VEHICLE that was in force on the date that was specified as the input parameter. 
The operation ‘get all vehicle associated hire agreements () : set(Hire Agreement)’ returns 
the set of instances of HIRE AGREEMENT associated with this instance of VEHICLE.
Business analysts are rarely, if ever, called upon to consider operations.
EXERCISES FOR CHAPTER 5
5.1	 Draw an information model using Ellis-Barker entity relationship notation, includ­
ing unique identifiers for each entity type, to represent the following ‘front of house’ 
information requirements for the La Belle Contessa restaurant:
	
The menu consists of both food and beverage items. For each item, food and bever­
age, a unique designation and the menu cost of the item are recorded. For some items 
a description is also recorded. Additionally, for some food items the course (starter, 
main, dessert) with which the item is associated is recorded. Beverages are only sold 
with meals.
	
Each party using the restaurant is associated with a single table. Tables are identified 
by a table number. The time and date of the arrival of the party are recorded as is the 
number of guests in the party. If known, the name of the ‘principal’ guest in the party 
is recorded. During their time in the restaurant, each party is the responsibility of a 
single server, although other servers may help with the service to that party. Although 
servers are known by name, they also have a unique staff number that is recorded.
	
To help with the efficient running of the restaurant, when the server takes the party’s 
orders each meal is associated with a guest seated in a particular seat at the table. 
Each guest’s meal can consist of a number of food items from the menu. Any special 
instructions from the guest about the preparation or serving of a particular item are 
also recorded.
	
The party may order a number of beverages from the menu. With some of these 
ordered beverages it will be necessary to record the size of the beverage.
	
At the end of the service a bill is prepared using the recorded information. The date 
and time of the bill preparation are recorded.
5.2	 Draw an information model using UML class model notation, including enumeration 
classes to represent any enumerated domains, to represent the following information 
requirements for the sale of residential properties by the ARV Partnership group of 
estate agents:
79

MODELLING BUSINESS INFORMATION
The name and postal address of each client are recorded. Telephone numbers and 
email addresses may also be recorded for each client. 
	
A considerable amount of information is recorded for each property that the partnership 
has for sale. This includes the client who is the vendor and the client who is the eventual 
purchaser. Also recorded are the address of the property and the type of the property – 
a detached house, a semi-detached house, a terraced house, an end terrace house or 
a flat or apartment.
	
If the property is leasehold and not freehold, the number of years remaining on the 
lease is recorded.
	
Various physical aspects of the property are recorded: the type and quantity of the 
rooms in the property, the number of floors in the property, the area of the property 
in square metres, and the type of garage, if any, associated with the property. 
	
Each room in a property is classified as one of ‘reception’, ‘bedroom double’, ‘bed­
room double en suite’, ‘bedroom single’, ‘bedroom single en suite’, ‘family bathroom’, 
‘kitchen’, ‘utility’ or ‘cloakroom/wc’. Garages are classified as being one of ‘single 
attached’, ‘single detached’, ‘double attached’ or ‘double detached’.
	
Any additional comments about the property are also recorded.
	
Each viewing of a property by a potential purchaser is recorded, along with the details 
of that potential purchaser, the date and time of the viewing, the names of the employ­
ees who were present for that viewing and any special instructions associated with 
the viewing.
	
80

6	
RATIONALISING DATA USING 
NORMALISATION
This chapter involves a change of direction. Our discussion so far has involved com­
puter-independent models – the models that represent the information needs of a 
business. They use data modelling notation but they can be called information models 
as they represent what information needs to be recorded to run the business. This 
chapter starts to describe a how model – a platform-independent (or logical) data 
model. We are looking at the first stage of database design.
These models are based upon the theory of the relational model of data. This is the 
‘model’ that underpins all of the database management systems that use SQL database 
language. These models are ‘normalised’ models. This chapter introduces the relational 
model of data and the concept of normalisation.
Although normalisation is principally a database design technique for use with data­
bases managed by a relational database management system, the use of the technique 
can provide a formal approach to the analysis of documents during the elicitation of 
requirements for an information technology system. 
WHAT IS NORMALISATION?
Normalisation is a formal approach to the analysis of data requirements that relies 
on there being some document or other existing record (such as a program file) that 
lists the items of data that are to be recorded. This set of data items is then analysed 
using this process, which is known as relational data analysis. The result is a set of 
relations – an abstract concept explained in more detail below – in what is known as 
third normal form and this set of relations can be shown diagrammatically in a form 
that looks remarkably similar to our previous conceptual data model, although there 
are some significant differences.
Relational data analysis is based upon the relational model of data proposed in 1970 by 
Edgar F. Codd.14 Since well over 90 per cent of business applications are supported by 
the so-called relational database management systems, this is probably an appropri­
ate technique to employ, but, even though relational data analysis is used, the actual 
implemented database could be object-oriented or follow some other model of database 
implementation.
14 Codd, E.F. (1970) ‘A Relational Model of Data for Large Shared Data Banks’. Communications of the ACM, 13:6, 377–87.
81

MODELLING BUSINESS INFORMATION
The relational data analysis (or normalisation) process is used to develop a set of 
theoretical groupings of attributes. In this process, we determine the identifying 
attributes (the ‘key attributes’) – those attributes that contribute to the unique iden­
tification of instances of the entity types or object classes – and the non-identifying 
attributes (the ‘non-key attributes’) – the remaining attributes – and the relationships 
between them. One of the fundamental concepts of the relational model of data is that 
if we know the value of the key attributes for an instance of an entity type or object 
class we are able to determine the values of the non-key attributes. For example, in 
our vehicle hire business, if we have a unique identification number for each of our 
vehicles (say, the vehicle registration number AB63 MTO) then we can determine the 
model (VW Polo S 1.0 3dr manual 2014) and colour (red) of the vehicle. We cannot do 
this in reverse – knowing the model of a vehicle does not mean that we can determine 
the vehicle registration number.
Relational data analysis is used to minimise the possibility of ‘update anomalies’. 
These update anomalies can occur whenever there is duplication of data, which can 
lead to the possibility of one instance of the data being changed (or updated) but not 
another. Update anomalies can occur whenever data is updated, created or deleted. 
For example, if a customer’s address is held in more than one place and they notify 
us that they are moving, all instances of the customer’s address must be updated to 
the new address or some mail could still go to the old address of the customer – this 
was a common problem with banks in the United Kingdom until a few years ago.
THE RELATIONAL MODEL OF DATA
In the relational model of data, the data is recorded in a set of linked relations. A relation 
is an abstract concept from set theory – a set of sets – that can be represented as a 
two-dimensional table. This is the representation used in the SQL database language. 
The columns of the table represent the attributes of the relation. The rows of the table 
represent the tuples (which rhymes with couples) – the sets of data values – of the 
relation. Each tuple represents one of the real-world instances of the concept about 
which the relation is storing data.
Figure 6.1 shows two linked relations, each represented by a table. One relation records 
information about our hirers, while the second relation records information about the 
hire agreements. Each relation (table) has an attribute (column) called ‘Hirer Number’ 
with common values.
‘Hirer Number’ in the Hirer Table is known as the primary key of the Hirer Table. ‘Hirer 
Number’ in the Hire Agreement Table is known as a foreign key. We say that Hirer 
Number in the Hire Agreement Table references the Hirer Table. This use of the primary 
key–foreign key linkage between tables replicates exactly the idea of a relationship 
between entity types or an association between object classes.
There are a number of rules associated with relations. Without going into too much 
technical detail these are:
yy Each relation contains data about only one thing.
82

RATIONALISING DATA USING NORMALISATION
Figure 6.1 Relational tables
Figu
re 6.1
yy There is no significance to the order of the attributes15 within the relation 
heading; this is because the relation heading is a set of attributes and one of the 
properties of a mathematical set is that the elements of the set are unordered. 
The fact that in Figure 6.1 the attributes are arranged as columns in a table in 
a particular order from left to right is purely for presentational purposes; that 
order has no significance to the relation.
yy Similarly, since the body of the relation is a set of tuples, there is no significance 
to the order of the tuples within the body of the relation. Again, the fact that, in 
Figure 6.1, the tuples are arranged as rows in a table in a particular order from 
top to bottom is purely for presentational purposes.
yy Attributes within the relation heading should be unique; that is, there should be 
no duplication of attribute names within a relation.
yy There should be no attributes whose values can always be derived from the 
values taken by other attributes, whether those attributes are in the same 
relation or in another relation. For example, the cost of a vehicle hire can be 
calculated from the ‘cost per day’ rate for the hired vehicle and the duration of 
the hire, so the cost of the vehicle hire should not be recorded.
yy Relations have primary keys; the primary key comprises the attribute, or 
combination of attributes, whose values are the minimum required to uniquely 
identify each instance of the relation. The primary key of the relation represented 
using the Hirer Table in Figure 6.1 is the Hirer Number attribute; each hirer has 
a hirer number that is managed to ensure uniqueness.
yy No two tuples in a relation may have the same value of primary key. If the Hirer 
Number attribute is the primary key of the relation representing hirers, no two 
hirers can have the same hirer number.
15 Note that in the relational model of data, the term ‘attribute’ includes both native attributes – the attributes we saw in 
Chapter 5 – and foreign keys.
83

MODELLING BUSINESS INFORMATION
yy In each tuple, each part of the primary key must have a value. Every hirer must 
have a hirer number.
yy The attributes of a relation represent characteristics that are determined by the 
primary key; that is, they describe the ‘thing’ defined by the primary key. The 
name of the hirer with hirer number 101 is Mr John Davies and his telephone 
number is 01365 222514.
yy In any tuple, no attribute may take more than one value; that is, each attribute 
is single-valued – there are no multiple-valued attributes within a relation 
(although each of these ‘single values’ may be quite complex – see Chapter 13 
for more details).
THE RULES OF NORMALISATION
We use the process of relational data analysis – the development of a set of relations in 
third normal form – to develop a logical database design in which there will be no update 
anomalies when data is input into the database or later updated. In general terms, 
this means that for any piece of information there is only one place in the database 
where the data representing the information can be stored and that place is unambigu­
ously recognised. This process of relational data analysis allows us to confirm that we 
are associating attributes that are all about one thing (person, product, and so on) or 
concept (promotion, order, account, transaction and so on) of interest to the business.
In a series of additional papers published in late 1970 and 1971, Edgar Codd proposed 
three normal forms known as first normal form (commonly abbreviated to 1NF or FNF), 
second normal form (2NF or SNF) and third normal form (3NF or TNF). These three 
normal forms represent a process through which the data design can evolve to what is 
known as a normalised result. Later developments have added further normal forms, 
such as Boyce-Codd normal form (a stricter form of third normal form), fourth normal 
form, fifth normal form and sixth normal form, but we are only going to consider the 
first three normal forms. For most practical purposes, data needs to be in third normal 
form for it to be considered ‘normalised’.16 The term ‘third normal form’ is used to indi­
cate that data has been normalised and has no particular meaning other than that the 
checks inherent in the normalisation process have been applied to the data. 
The definitions of these first three normal forms are:17
yy A relation is in first normal form (1NF or FNF) if and only if all underlying 
domains contain atomic values only.
yy A relation is in second normal form (2NF or SNF) if and only if it is in first 
normal form and every non-key attribute is fully dependent on the primary key.
yy A relation is in third normal form (3NF of TNF) if and only if it is in second 
normal form and every non-key attribute is non-transitively dependent on the 
primary key.
16 Codd described relations in first normal form as ‘normalised’ and described second and third normal forms as further 
normal forms. Most people, however, refer to relations in third normal form as ‘normalised’.
17 These definitions are not the formal definitions developed by Codd but are adequate for our purpose.
84

RATIONALISING DATA USING NORMALISATION
STARTING THE NORMALISATION PROCESS
The normalisation process is a bottom-up process. We start with a group of data items 
and then work through the process until we have a set of relations in third normal form. 
The data items are normally found on the forms, reports or input screens which are 
used in the business.
Figure 6.2 shows a paper-based staff record form used by the human resources depart­
ment of our vehicle hire business. 
Figure 6.2 The staff record formFigure 6.2
Studying this form, we can identify a number of data items. These are:
yy the name of the employee;
yy the staff number of the employee;
yy the date of birth of the employee;
yy the National Insurance number of the employee;
yy the telephone number of the employee;
yy the address of the employee;
yy any disabilities of the employee;
yy the start date of the employment of the employee;
yy the number of the branch where the employee is employed;
yy the location of the branch where the employee is employed;
85

MODELLING BUSINESS INFORMATION
yy the telephone number of the branch where the employee is employed;
yy for each of the emergency contacts of the employee:
ßß the name of the emergency contact;
ßß the relationship of the emergency contact to the employee;
ßß the address of the emergency contact;
ßß the telephone number of the emergency contact;
yy for each qualification held by the employee:
ßß the title of the qualification; 
ßß the qualification award date of the qualification;
ßß the awarding body of the qualification;
ßß the renewal date of the qualification.
One of these data items is selected as a unique identifier which will eventually become 
the primary key of one of our relations. In this case, an appropriate unique identifier is 
the staff number of the employee.
We call this initial collection of data items the ‘un-normalised form’ (often abbreviated 
to UNF). These are placed on our ‘normalisation form’ – see Figure 6.3.
The accepted convention is that all of the entries on this form are in lower case. Beside 
each entry is a level indication – ‘1’ or ‘2’. All entries for which there are groups of data 
items that can be repeated – emergency contacts and qualification – are indicated with 
the level 2. These level 2 data items are known as repeating groups. All other data items 
(the ‘top of the form’ data items) are at level 1. 
FIRST NORMAL FORM
The first stage in our normalisation process is to move from this un-normalised form 
to produce a set of relations that are in first normal form. A relation is in first normal 
form if and only if all underlying domains contain atomic values only, that is, if all the 
values taken by the attributes of that relation are atomic or scalar values. The attributes 
are said to be single-valued. This is to comply with the rule that there must not be any 
multiple-valued attributes in a relation. To move to first normal form we need to remove 
the repeating groups from the initial ‘relation’.
Each of the repeating groups then becomes a relation in its own right. In our example, 
we have two new relations: one for the emergency contact details; and one for the quali­
fications held by the employee.
For each of these new relations we need to identify a primary key. For the employee’s 
emergency contacts, the name is sufficient to uniquely identify one contact among the 
contacts recorded for a single employee. But we need to uniquely identify an emer­
gency contact among all the emergency contacts recorded in the company. In any but 
the smallest company it is possible for two employees to have an emergency contact 
86

RATIONALISING DATA USING NORMALISATION
Figure 6.3 Normalisation form completed to UNF
Figure 6.
3
87

MODELLING BUSINESS INFORMATION
Figure 6.4 Normalisation form completed to 1NF
Figure 6.
4
88

RATIONALISING DATA USING NORMALISATION
called John Davies, and for them to be two different people. The name of the emergency 
contact is, therefore, insufficient to uniquely identify an emergency contact within the 
company. What we really need to uniquely identify an emergency contact is both the 
name of the contact and an indication, such as the staff number, of the employee for 
whom this person is an emergency contact. The primary key of this relation is, therefore, 
the combination of ‘staff number’ and ‘emergency contact name’.
Our first normal form relations are shown in Figure 6.4. These are now relations as they 
comply with all the rules we listed earlier. Each of the data items listed is now an attribute.
Both of our new relations have a primary key identified (in this case by underlining the 
relevant attributes). Both of these primary keys comprise at least two attributes, the 
primary key of the main relation and sufficient extra attributes to uniquely identify each 
instance of the real-world thing that the relation represents. As explained above, for the 
emergency contacts relation, this is the combination of the employee’s ‘staff number’ 
attribute and the ‘emergency contact name’ attribute. 
For the relation representing the employee’s qualifications there are three elements to 
the primary key since three items of data are required to uniquely identify each employ­
ee’s qualification. One of these is the employee’s ‘staff number’ attribute, as before. There 
is also the ‘qualification title’ attribute. But the combination of the employee’s staff num­
ber and the title of the qualification is insufficient to uniquely identify a qualification held 
by an employee. Inspection of the form shows that Rachel Davies holds two first aid 
qualifications, one of which is now out of date. So, to uniquely identify a qualification held 
by an employee we also need another item of information, the date that the qualification 
was awarded. Hence the primary key of the relation representing the qualifications held 
by employees is the combination of the ‘staff number’, ‘qualification title’ and ‘qualification 
award date’ attributes.
When the primary key of a relation appears as an attribute in another relation it is 
known as a foreign key in the other relation. In this case, ‘staff number’ is a foreign key 
in our two new relations.
SECOND NORMAL FORM
The next stage of our relational data analysis process is to move our relations to second 
normal form (2NF). For a relation to be in second normal form, it has to be in first normal 
form and, in addition, it must meet the condition that every attribute that is not part of the 
primary key is dependent on the whole of the primary key. In other words, there must be 
no ‘part-key dependencies’. More formally, a relation is in second normal form if and only if 
it is in first normal form and every non-key attribute is fully dependent on the primary key.
We saw the concept of dependence earlier. If we have two attributes, ‘staff number’ 
and ‘name’, and we know the value of the attribute ‘staff number’, we can determine the 
value of the attribute ‘name’. For example, given the staff number UK365, we know that 
the name of that employee is Miss Rachel Sarah Davies. We say that ‘name’ is depend­
ent on ‘staff number’. 
We achieve second normal form by reviewing every attribute that is not part of the 
primary key in the first normal form relations to see if any of those attributes are 
89

MODELLING BUSINESS INFORMATION
dependent on one or more parts of a multiple-part primary key but not the whole 
primary key. If so, then those attributes need to be removed.
Our main first normal form relation has ‘staff number’ as its primary key. This is a 
single-part primary key (equivalent to a simple identifier) and, therefore, each of the 
attributes in that relation must be dependent on the whole of the primary key. This first 
normal form relation is, therefore, also in second normal form.
Let us now consider the relation for emergency contacts. This relation has a multiple-
part primary key of two attributes – ‘employee staff number’ and ‘emergency contact 
name’ – and three non-key attributes – ‘emergency contact relationship’, ‘emergency 
contact address’ and ‘emergency contact telephone number’. If we know the combined 
values of ‘employee staff number’ and ‘emergency contact name,’ we can determine the 
values of the non-key attributes. The test is to take each non-key attribute in turn and 
see if it is possible to determine its value using only a part of the primary key. 
For ‘emergency contact relationship,’ we need to know the values of both ‘employee 
staff number’ and ‘emergency contact name’ to know its value. Knowing just the value 
of ‘employee staff number’ is insufficient. The employee with staff number UK365 has 
both a father and a fiancé as emergency contacts. Similarly knowing just the value of 
‘emergency contact name’ is insufficient; it is possible that more than one employee has 
an emergency contact called Mr John Davies. 
The same is true for both ‘emergency contact address’ and ‘emergency contact telephone 
number’. This relation for emergency contacts is, therefore, also in second normal form.
Let us now consider the other new relation, that for employee qualifications. This has a 
multiple-part primary key of three attributes – ‘employee staff number’, ‘qualification title’ 
and ‘qualification award date’ – and two non-key attributes – ‘qualification awarding body’ 
and ‘qualification renewal date’. We need to know the values of all three elements of the 
primary key to determine the value of ‘qualification renewal date’. The same is not true for 
‘qualification awarding body’. The value of this attribute is not dependent on the value of 
‘employee staff number’ or on the value of ‘qualification award date’. The value for ‘quali­
fication awarding body’ is only dependent on the value of ‘qualification title’ (assuming 
that only one body issues any qualification of a given name or title; this may not be true 
in the real world but we make that assumption for the purposes of this exercise).
To create our second normal form relations we need, therefore, to remove ‘qualification 
awarding body’ to another relation. This new relation also needs ‘qualification title’ as its 
primary key since we know that the value of ‘qualification awarding body’ is dependent 
on ‘qualification title’.
The second normal form relations are now shown in Figure 6.5. 
THIRD NORMAL FORM
We now need to move to third normal form. For a relation to be in third normal form it 
has to be in second normal form and also has to meet the condition that every attribute 
that is not part of the primary key is not dependent on an attribute that is also not part 
90

RATIONALISING DATA USING NORMALISATION
Figure 6.5 Normalisation form completed to 2NF
Figure 6.
5
91

MODELLING BUSINESS INFORMATION
of the primary key. In other words, there are no ‘inter-data dependencies’. More formally, 
a relation is in third normal form if and only if it is in second normal form and every 
non-key attribute is non-transitively dependent on the primary key.
We achieve third normal form by reviewing every attribute that is not part of the primary 
key in the second normal form relations to see if any of those attributes are dependent 
on another attribute that is not part of the primary key. If so, then those attributes need 
to be removed.
In the second normal form relation for employees, the value of ‘name’ is dependent on 
the value of ‘staff number’, the primary key. If I know that the value of the ‘staff number’ 
attribute is UK365, I can determine that the value of the ‘name’ attribute is Miss Rachel 
Sarah Davies. The same is true of the ‘date of birth’, ‘ni number’, ‘telephone number’, 
‘address’, ‘disabilities’, ‘start date’ and ‘branch number’ attributes. However, if I know 
the value of the ‘branch number’ attribute then I can determine the values of both the 
‘branch location’ and the ‘branch telephone number’ attributes. The attributes ‘branch 
location’ and the ‘branch telephone number’ are not, therefore, directly dependent on 
the primary key, the ‘staff number’ attribute. We say that the ‘branch location’ and the 
‘branch telephone number’ are transitively dependent (that is, indirectly dependent) on 
‘staff number’ through ‘branch number’.
The ‘branch location’ and the ‘branch telephone number’ attributes are, therefore, 
removed from the relation for employees to form a new relation. This new relation 
also needs ‘branch number’ as its primary key since both the ‘branch location’ and the 
‘branch telephone number’ are dependent on ‘branch number’.
The attribute ‘branch number’ remains in the employee relation as a foreign key. So that 
it can be identified as a foreign key that is not part of the primary key, it is marked with 
an asterisk (*).18
In the second normal form relation for emergency contacts for employees, all the non-
key attributes are directly dependent on the primary key. This relation is, therefore, also 
in third normal form.
Similarly, in the second normal form relation for the employee qualifications, all the 
non-key attributes are directly dependent on the primary key. This relation is, therefore, 
also in third normal form.
In the second normal form relation for qualifications, there is only one non-key attrib­
ute (‘qualification awarding body’). This means that this relation is automatically in 
third normal form – with only one non-key attribute it is impossible to have a transitive 
dependency.
The second normal form relation for employee qualifications also has only one non-
key attribute (‘qualification renewal date’), so this relation is also automatically in third 
normal form.
The third normal form relations are now shown in Figure 6.6. The last column of the 
form is populated with the selected names for the third normal form relations.
18 Some modellers also show foreign keys within a primary key with an asterisk and refer to them as prime-foreign keys.
92

RATIONALISING DATA USING NORMALISATION
Figure 6.6 Normalisation form completed to 3NF
Figure 6.
6
93

MODELLING BUSINESS INFORMATION
With our relations now in third normal form this is as far as we go with the process of 
relational data analysis.
THE THIRD NORMAL FORM DATA MODEL
We can now use these third normal form relations to create a new data model as in Figure 6.7.
Figure 6.7 The third normal form data model
Figure 6.7
We can see that each relation becomes an entity type (but note that we are using a 
different notation since this is a logical model)19 and each ‘primary key to foreign 
key pair’ becomes a one-to-many relationship, with the crow’s foot at the end of the 
relationship with the relation with the foreign key. At the other end of the relationship, 
the end with the relation with the primary key that corresponds to the foreign key, 
there is a plain end (i.e. there is no crow’s foot). All attributes are shown, including 
the foreign keys.
This diagram is less expressive than our computer-independent model because we do 
not have any names for the relationships. Also, it is impossible to say with any certainty 
whether these relationships are mandatory or optional, but, by convention, we use a 
default of mandatory at the many end of the relationship and optional at the one end of 
the relationship.
19 This is the notation used for third normal form models in Business Systems Development with SSADM; Data Modelling from 
the Central Computer and Telecommunications Agency (2000).
94

RATIONALISING DATA USING NORMALISATION
CANDIDATE KEYS, PRIMARY KEYS AND ALTERNATE KEYS
So far in our discussion of normalisation we have been talking about the primary key 
for a relation as if there is only one possible key. Sometimes there is more than one 
possible key. All of the possible keys for a relation are called candidate keys. 
If there is more than one candidate key for a relation, one of those candidate keys 
is selected to be the primary key. Generally, the decision as to which candidate key 
to use as the primary key is obvious, but sometimes the decision is more difficult. A 
primary key, however, is always needed for a relational implementation. The remain­
ing candidate keys that are not used as the primary key are known as alternate 
keys.
Candidate keys always represent a real-world situation where uniqueness is 
expected. To maintain integrity, therefore, all candidate keys, whether they are 
used as primary keys or ‘relegated’ to be alternate keys, should have an associated 
uniqueness constraint in an implemented database. With a relational database man­
agement system, declaring something as the primary key automatically imposes an 
implicit uniqueness constraint. For alternate keys, uniqueness constraints have to 
be explicitly created. 
THE RELATIONSHIP OF NORMALISATION TO MODELLING
Although the concept of normalisation is based on the relational model of data, it is 
good practice to ensure that our models are in third normal form whether a relational 
database management system is to be used for implementation or not.
It is not normally essential to go through the whole process of normalisation, from the 
un-normalised list of data items through to third normal form. Experienced model­
lers instinctively develop models that are in third normal form. This does not, however, 
remove the requirement for the modeller to check that their model is actually in third 
normal form as even the most experienced modeller can make mistakes.
A memorable way of remembering what constitutes a third normal form model is:
Every non-key attribute must be dependent upon (provide a fact about) the key, 
the whole key, and nothing but the key, so help me Codd. 
This parallels the oath sworn in a court of law to tell ‘the truth, the whole truth and 
nothing but the truth’.
It is, however, often helpful to create two or more models – one a top-down model and 
the others bottom-up third normal form models derived through normalisation – each 
based on a form (especially a form used within the business for recording or capturing 
information), a report or an existing input screen. These models can then be compared 
to create a final, composite, data model.
95

MODELLING BUSINESS INFORMATION
EXERCISES FOR CHAPTER 6
6.1	 The following diagram represents the record of a service call made by a service 
engineer to a domestic company to repair an appliance.
Figure
	
Analyse the entries on this form and use relational data analysis to determine the 
third normal form relations.
6.2	 Using the third normal form relations discovered in Exercise 6.1, develop a third normal 
form model to represent the information requirements identified from the analysis of 
this form.
96

PART 2:
SUPPLEMENTARY MATERIAL
The second part of this book (Chapters 7 to 14) provides extra information that should 
be of interest to business analysts. Each of these chapters stands alone and they can 
be read in any order.
Chapter 7, Other modelling notations, introduces three other notations that can be used 
to model information or data: the IDEF1X notation; the Information Engineering notation; 
and the Chen notation.
Chapter 8, The naming of artefacts on information models, provides a more formal 
approach to the naming of entity types or object classes, relationships or associations, 
attributes and domains.
Chapter 9, Information model quality, looks at various aspects of model quality, including 
the layout of models.
Chapter 10, Corporate information and data models, takes an enterprise-wide view of 
information and data and considers the development of corporate models.
Chapter 11, Data and databases, looks in more detail at data and databases. The differ­
ent categories of data: structured data, unstructured data, semi-structured data, master 
data, metadata and ‘big data’ are considered. The evolution of databases to handle this 
data is then described.
Chapter 12, Business intelligence, considers the subject of business intelligence and the 
related topics of data warehouses and dimensional modelling.
Chapter 13, Advances in SQL (or why business analysts should not be in the weeds), looks 
at the advances introduced into the SQL database language, leading to a discussion of 
why business analysts should not be ‘in the weeds’, or introducing unnecessary detail 
too early in the modelling process.
Chapter 14, Taking a requirements information model into database design, briefly intro­
duces the principles of database design.
97


7	
OTHER MODELLING NOTATIONS
This chapter shows three additional entity relationship notations and compares them 
with the Ellis-Barker notation and the UML class model notation. For this comparison, 
the same business scenario is used for all. The additional notations are: 
yy the IDEF1X notation;
yy the Information Engineering notation;
yy the Chen notation.
Figure 7.1 shows a model of the business scenario drawn using the Ellis-Barker nota­
tion. As mentioned in Chapter 1, this notation was developed in the early 1980s by Harry 
Ellis and Richard Barker when they were working for CACI, an IT services company. 
Richard Barker then took the notation and its related methodology into the development 
of Oracle’s CASE tool.
The beauty of this notation is that it is easy to read. Harry Ellis and Richard Barker set 
out to develop a notation that unambiguously and accurately portrayed the information 
or data requirements, yet at the same time reduced the number of interactions that the 
analyst would require with the users. I have used this notation with many who have 
never seen an information or data model before; they find the concepts easy to grasp 
and are soon able to describe the information or data requirements that led to the model 
being discussed.
The business scenario that is being used here is an expanded version of the vehicle 
hire scenario. This is not a ‘good’ model (I could have modelled some of the concepts 
using better modelling constructs) but it is contrived to expose some of the features of 
the other notations. One point to note is that the relationships from VAN TYPE and CAR 
TYPE to VEHICLE are both fully mandatory, imposing a constraint that details of van 
and car types are not recorded until the company has at least one vehicle of the type 
available for hire. Also, note that one of the relationships (the ‘returning’ relationship) 
from BRANCH to HIRE AGREEMENT is fully optional. The implication is that the returning 
branch is only recorded when the vehicle is to be returned to a different location from 
the one from which it was originally hired.
Figure 7.2 shows an equivalent UML class model depiction of the business scenario.
99

MODELLING BUSINESS INFORMATION
Figure 7.1 The model of the business scenario in Ellis-Barker notation
Figure
 7.1
THE IDEF1X NOTATION
IDEF1X is one of the family of ICAM Definition Languages (IDEF). ICAM is short for 
Integrated Computer-Aided Manufacturing, an initiative managed by the US Air Force. 
IDEF1X is technically a data modelling language – there was an IDEF1, an information 
modelling language, but this was extended and renamed as IDEF1X. Among the other 
IDEF languages are IDEF0, a functional modelling language; IDEF2, a dynamics model­
ling language; and IDEF3, a process or workflow modelling language. IDEF1X is now a 
US Federal standard and the language has become very widely used both within the US 
and internationally. IDEF1X is a very rich notation, encompassing many different facets 
of the basic entity type (called an entity in IDEF1X and not an entity type), attribute and 
relationship concepts.
Figure 7.3 shows the business scenario drawn in IDEF1X notation.
100

OTHER MODELLING NOTATIONS
Figure 7.2 The model of the business scenario in UML class model notation
Figu
re 7.2
101

MODELLING BUSINESS INFORMATION
Figure 7.3 The model of the business scenario in IDEF1X notation
Figure 7.3
102

OTHER MODELLING NOTATIONS
Within IDEF1X there are two different types of entity: independent and dependent. An 
independent entity is one that does not depend on any other for its identification and is 
shown on an IDEF1X diagram using a box with square corners. A dependent entity, on 
the other hand, is an entity that depends on one or more other entities for its identifica­
tion and is shown on an IDEF1X diagram using a box with rounded corners. The entities 
BRANCH, CLIENT, VAN TYPE and CAR TYPE are independent entities; all of the other 
entities are dependent entities.
In a full IDEF1X diagram, both types of entity have their attributes listed in two groups. The 
attributes above the separation line in the entity box are the key attributes (or the ‘primary 
key attributes’ – the attributes that form the primary key columns in the equivalent table 
in an SQL implementation); while the attributes below the line are the non-key attributes. 
All attributes, key and non-key, that are part of a foreign key are marked with ‘(FK)’. Note 
the rule that all attribute names (except for those that are part of a foreign key) must be 
unique within the model, which means that the entity name often has to be added to the 
attribute name to ensure this uniqueness. Foreign key attributes can retain their original 
names or can be renamed when in their foreign key role.
The relationship notation is very complex. A solid line represents an identifying relationship 
(a relationship where all the primary key attributes of the parent entity become part of the 
primary key of the child entity) and a dotted line represents a non-identifying relationship. 
A ‘blob’ on the end of the relationship line is almost the equivalent of a crow’s foot in the 
Ellis-Barker and other notations; it represents the end of the relationship that is at the child 
end of the relationship (the ‘foreign key end’). Un-annotated, the ‘blob’ represents ‘zero or 
more’; annotated with a ‘P’ (for positive) it represents ‘one or more’; annotated with a ‘Z’ 
(for zero), it represents ‘zero or one’; annotated with a number, for example ‘2’, it represents 
‘exactly 2’. An open diamond at the parent end (the ‘primary key end’) of a non-identify­
ing relationship indicates that the parent entity is optional, for example, not every branch 
(an instance of the entity BRANCH) is a returning branch for a hire.
Subtypes are shown external to their supertype. A subtype is known as a ‘category 
entity’ in IDEF1X and the combination of a supertype and its subtypes is known as a cat­
egory or generalisation hierarchy. There is a specific notation for a category hierarchy: 
a circle over two bars for a complete hierarchy (where each instance of the supertype 
has an equivalent instance of one of the subtypes) and a circle over a single bar for an 
incomplete hierarchy. (An incomplete hierarchy does not meet the rule for subtypes 
in an entity relationship model, that every instance of the supertype must also be an 
instance of one of the subtypes as well as the subtypes being mutually exclusive.) The 
name of the attribute in the supertype that is to act as the ‘category discriminator’ is 
alongside the category-hierarchy notation. Because the subtypes are shown external to 
the supertype, multiple subtyping hierarchies can be used.
There is no equivalent of the exclusive arc in IDEF1X which means that mutually exclu­
sive relationships must be shown using subtyping. Hence, we have the subtypes CAR 
and VAN of VEHICLE which play no role other than to relate VEHICLE with CAR TYPE and 
VAN TYPE respectively. 
Because the IDEF1X notation is very rich it is not very easy for those not involved in 
information or data modelling to understand the model. This becomes even more so, 
the greater the number of entities on the model. An IDEF1X model is more an expres­
sion of a logical schema than a conceptual model that documents a business area’s 
103

MODELLING BUSINESS INFORMATION
information requirements. The information requirements are documented, but they are 
swamped by a mass of detail that is really there so that the design of the database can 
be automated. It is sometimes difficult ‘to see the wood for the trees’. 
THE INFORMATION ENGINEERING NOTATION
Information Engineering was developed by James Martin and Clive Finkelstein in the 
late 1970s. It was very popular in the UK, Europe and USA in the 1980s and 1990s, 
where it had extensive computer aided software engineering (CASE) tool support. The 
methodology had a number of techniques which looked at data (its structure and how 
it changed over time) and processes and provided some cross-checking to ensure that 
there is a correlation between data and process.
Figure 7.4 shows the same business scenario drawn using the Information Engineering 
data modelling notation.
The relationship notation is as precise as that used in the Ellis-Barker notation, but more 
symbols are used to impart the same message. A crow’s foot with a bar across its base 
means ‘one or more’, while a crow’s foot with a circle at its base means ‘zero, one or more’. 
The absence of a crow’s foot with two bars means ‘one and only one’ and the absence of 
a crow’s foot with a circle and a single bar means ‘zero or one’. So, from Figure 7.4, the 
relationship between INDIVIDUAL CLIENT and PERSONAL HIRE AGREEMENT is read as 
‘each INDIVIDUAL CLIENT makes zero, one or more PERSONAL HIRE AGREEMENTS’ and 
‘each PERSONAL HIRE AGREEMENT is with one and only one INDIVIDUAL CLIENT’.
Attributes can be included on the diagram. They are listed outside the entity type box, as 
shown, with the unique identifiers (primary keys) being underlined. Exclusive arcs and 
entity subtypes are supported. The subtypes are shown separately from the supertype but 
connected to it by a line. There is no special notation for this line and it is possible for the 
subtypes to become visually separated from their supertype. Because the subtypes are 
external to the supertype, it is possible to include more than one set of subtypes on the 
same diagram. For example, a PERSON entity type could be subtyped into MALE PERSON 
and FEMALE PERSON and at the same time could also be subtyped into EMPLOYEE and 
CUSTOMER. This ability to support multiple subtyping hierarchies is not possible in the 
Ellis-Barker notation where the subtypes are located within the supertype ‘box’. 
THE CHEN NOTATION
The Chen notation in Figure 7.5 was the original entity–relationship modelling notation 
proposed by Peter Chen in 1976. The notation, with some refinements, is still in use today 
in a number of environments. It is particularly popular in academic environments.
Entity types are represented by boxes, relationships by diamonds and attributes by ellip­
ses attached to the entity type boxes. A feature of Chen’s notation is that relationships 
can be ‘n-ary’, in that more than two entity types may be related by a single relationship.
There are no equivalents of the exclusive arc or entity subtyping. The supertype–subtype 
hierarchy is simulated by the two ‘is a’ relationships, but these do not fully cover the 
concept because they do not document the fact that the subtypes are mutually exclusive.
104

OTHER MODELLING NOTATIONS
Figure 7.4 The model of the business scenario in Information Engineering notation
Figure 7.4
105

MODELLING BUSINESS INFORMATION
Figure 7.5 The model of the business scenario using Chen’s notation
Figure 7.5
106

OTHER MODELLING NOTATIONS
COMPARISON OF THE NOTATIONS
Figure 7.6 shows for comparison the different relationship notations used in the Ellis-
Barker, UML class model, IDEF1X, Information Engineering and Chen notations. Note 
that the Chen notation does not provide for the optional/mandatory concepts.
Figure 7.6 Comparison of the relationship notations
Figure 7.6
107

8	
THE NAMING OF ARTEFACTS ON 
INFORMATION MODELS
The names of the entity types or object classes, relationships or associations, attributes 
and domains on information models should comply with whatever data naming conven­
tion is in place within the organisation that is the subject of the model.
The aim of developing a data naming convention is to ensure that consistent, unique 
and meaningful names are given to all existing and new items within the organisation’s 
whole information and data architecture in order to achieve unambiguous understand­
ing of the information and data. Names need to be both meaningful and unique to the 
business: meaningful so that the terms used in the names are terms familiar to the 
business and unique so that the information or data objects to which they refer can be 
unambiguously identified. Technical terms and abbreviations should be avoided wher­
ever possible.
A full naming convention should cover all aspects of the organisation’s information and 
data architecture, from the conceptual information models to the database structures 
that are used to implement the requirements documented in the conceptual informa­
tion models. This explanation will concentrate on the naming of entity types or object 
classes, relationships or associations, attributes and domains on conceptual informa­
tion models.
THE NAMING OF ENTITY TYPES OR OBJECT CLASSES
Each entity type or object class is named with a singular noun or noun phrase, with the 
name representing a single instance (entity or object) of the entity type or object class. 
Examples are VEHICLE and PURCHASE ORDER. 
Uniqueness of entity type or object class names within the information and data archi­
tecture can be achieved at two levels:
At the first level, each entity type or object class name is to be unique within the con­
ceptual model that includes the entity type or object class. 
At the second level, the concatenation of the name of the conceptual model with the 
entity type or object class name provides a unique name for each entity type or object 
class within the information and data architecture. 
Abbreviations are not used in entity type or object class names. 
108

THE NAMING OF ARTEFACTS ON INFORMATION MODELS
Entity subtypes or object subclasses can be named following one of two conventions. 
It is normal for all entity subtypes or object subclasses of an immediate entity super­
type or object superclass to be named using the same convention. The conventions are 
described below.
First, where the entity subtype or object subclass names comprise the immediate 
supertype entity or superclass object name prefixed with an adjective to define the sub­
type or subclass. Examples are vehicle operation, a subtype or subclass of OPERATION, 
and MAINTENANCE VEHICLE OPERATION, a subtype or subclass of VEHICLE OPERATION. 
Second, where the entity subtype or object subclass identify independent concepts. 
Examples are FACILITY, a subtype or subclass of RESOURCE, and ORGANISATION, a 
subtype or subclass of PARTY.
Entity types or object classes that ‘characterise’ another entity type or object class 
normally have names that comprise the name of the entity type or object class being 
characterised, now acting as an adjectival phrase, suffixed by a noun that represents 
the nature of the characterisation. Examples are RESOURCE STATUS (which character­
ises the entity type or object class RESOURCE) and EMPLOYEE QUALIFICATION (which 
characterises the entity type or object class EMPLOYEE). 
Entity types or object classes that provide a categorisation or classification for instances 
of another entity type or object class normally have names that comprise the name of the 
entity type or object class whose instances are being categorised, now acting as an adjecti­
val phrase, suffixed by one of the words category, class or type as appropriate. Examples are 
INDIVIDUAL SKILL CATEGORY (which categorises the entity type or object class INDIVIDUAL 
SKILL), EQUIPMENT TYPE (which categorises the entity type or object class EQUIPMENT) and 
VEHICLE TYPE (which categorises the entity type or object class VEHICLE). 
Entity types or object classes that represent a relationship or association between two 
entity types or object classes (an associative entity type or object class) are normally 
named using one of two conventions as described below. 
First, using a name that represents the essence of the association formed from the 
conventions described above. Examples are the entity type or object class FACILITY 
VEHICLE CAPABILITY (which provides a relationship or association between the entity 
types or object classes FACILITY and VEHICLE) and the entity type or object class ASSET 
STRUCTURE ELEMENT (which provides a recursive relationship or reflexive association 
on the entity type or object class ASSET). 
Second, where the names of the two entity types or object classes being associated are 
concatenated and suffixed by the word association. In the special case of a recursive 
relationship or reflexive association, the associated entity type or object class name is 
only used once. Examples are OPERATION RESOURCE ASSOCIATION (which provides an 
association between the entity types or object classes OPERATION and RESOURCE) and 
PARTY ASSOCIATION (which provides a recursive relationship or reflexive association 
on the entity type or object class PARTY). 
The use of the first convention above is preferred to the second. If the second convention is 
used, it is normally because this entity type or object type represents a generic relationship 
109

MODELLING BUSINESS INFORMATION
or association. Under these circumstances an additional categorisation entity type or object 
class (for example, PARTY ASSOCIATION CATEGORY) is required. 
THE NAMING OF DOMAINS
Each domain is named with a singular noun or noun phrase, with the name representing 
the concept that the values of the domain collectively represent. Examples are WEIGHT 
and CONTROLLED NAME. 
Domain names should be unique within the information and data architecture. This can 
be achieved by following one of the two conventions described below.
First, for domains intended to be used across the information and data architecture 
(i.e. where the same domain may be used within more than one conceptual model), the 
domain name is to be unique within the information and data architecture.
Second, for domains to be used in a single conceptual model, each domain is to be 
named with a name that is unique within that conceptual model. The concatenation of 
the name of the conceptual model with the domain name provides a unique name for 
that domain within the information and data architecture. 
Abbreviations are not normally used in domain names. 
THE NAMING OF ATTRIBUTES
Each attribute is named with a singular noun or noun phrase, with the name repre­
senting the meaning of the value to be recorded. The name of the entity type or object 
class that contains the attribute is not included in the formal name of the attribute, 
but is used with the attribute name when referring to the attribute conversationally. 
Examples are ‘designation’ (in the entity type or object class EQUIPMENT TYPE, conver­
sationally ‘EQUIPMENT TYPE designation’), ‘last service date’ (in the entity type or object 
class EQUIPMENT, conversationally ‘EQUIPMENT last service date’) and ‘international 
standard book number’ (in the entity type or object class PUBLICATION, conversationally 
‘PUBLICATION international standard book number’). 
Uniqueness of attribute names within the information and data architecture can be 
achieved at three levels.
At the entity type or object class level, by having attribute names that are unique within 
the entity type or object class to which they belong. This is sometimes known as the 
‘short attribute name’.
At the model level, by concatenating the name of the entity type or object class to which 
the attribute belongs with the short attribute name to provide a unique name for each 
attribute within the conceptual model. This is known as the ‘full attribute name’.
110

THE NAMING OF ARTEFACTS ON INFORMATION MODELS
At the information and data architecture level, by concatenating the name of the con­
ceptual model with the full attribute name to provide a unique name for each attribute 
within the information and data architecture.
Abbreviations are not used in attribute names. 
Most, if not all, naming conventions for attributes rely on using terms, which may be 
either single words or a number of words, in a precise and predefined manner. Key to 
this in all naming conventions is what is known as the class word or term. This is also 
sometimes known as a representation term. Typical class words might be, for example, 
‘identifier’, ‘number’ and ‘text’, providing an indication of the form or the representation 
of the data. 
A common convention sees a ‘full attribute name’ consisting of three components. 
These components can be given different names within different approaches to nam­
ing, but a common classification identifies these components as: 
yy a mandatory prime term; 
yy an optional modifier term; 
yy a mandatory class term.
The prime term identifies the context for the attribute, i.e. the set of things that this 
attribute can be used to describe. This is, effectively, the name of the entity type or object 
class which includes the attribute. 
The class term identifies the class (category or type) of the information that the attribute 
provides about the context. 
The optional modifier term is used to discriminate between different attributes pro­
viding information of the same class for the same context or to provide some further 
specification or clarification to the attribute name. 
Table 8.1 provides examples to illustrate the use of these concepts. 
Table 8.1 Examples of formal attribute names
Full attribute name
Terms
Prime
Modifier
Class
PERSON family name
PERSON 
family
name
PERSON birth date
PERSON
birth
date
VEHICLE CATEGORY label
VEHICLE CATEGORY
(-)
label
STOCK HOLDING unit of measure
STOCK HOLDING 
(-)
unit of measure
ASSIGNMENT start date
ASSIGNMENT 
start
date
ASSIGNMENT end date
ASSIGNMENT
end
date
111

MODELLING BUSINESS INFORMATION
THE NAMING OF RELATIONSHIPS IN ELLIS-BARKER ENTITY RELATIONSHIP 
MODELS 
In a model drawn using the Ellis-Barker notation, each relationship is named using two 
sentences of the following forms: 
Each VEHICLE must be within one and only one VEHICLE TYPE. 
Each VEHICLE TYPE may be classification for one or more VEHICLES. 
where, in the first sentence:
yy must be represents the fact that the entity type VEHICLE has mandatory 
participation with respect to this relationship, represented by a solid line on a 
conceptual data model diagram;
yy within is the link phrase associated with the entity type VEHICLE;
yy one and only one represents the fact that only one instance of the entity type 
VEHICLE TYPE can be associated with any one instance of the entity type 
VEHICLE through this relationship, represented by the absence of a crow’s foot 
on a conceptual data model diagram.
And in the second sentence:
yy may be represents the fact that the entity type VEHICLE TYPE has optional 
participation with respect to this relationship, represented by a dashed line on 
a conceptual data model diagram;
yy classification for is the link phrase associated with the entity type VEHICLE TYPE;
yy one or more represents the fact that many instances of the entity type VEHICLE 
can be associated with a given instance of the entity type VEHICLE TYPE through 
this relationship, represented by a crow’s foot on a conceptual data model diagram. 
Uniqueness of relationship names within the information and data architecture can be 
achieved at two levels as described below. 
First, relationship names should be unique within a conceptual data model. 
Second, the concatenation of the name of the conceptual data model with the relationship 
name will provide a unique name for each relationship within the information and data 
architecture.
Abbreviations are not used in relationship names. 
THE NAMING OF ASSOCIATIONS ON UML CLASS MODELS 
In a UML class model the approach to the naming of associations is less formal than for 
a relationship on an Ellis-Barker model. Also, UML allows two possible approaches to 
the naming of associations: ‘direct naming’ and ‘naming using role names’.
112

THE NAMING OF ARTEFACTS ON INFORMATION MODELS
With ‘direct naming’ a single name is given to the association and, normally, this is anno­
tated with a small triangle that points in the direction that this name should be read. 
An example is an association from the object class VEHICLE TYPE to the object class 
VEHICLE with a name ‘is classification for’ and a triangle pointing towards the object 
class VEHICLE. The multiplicity at the VEHICLE TYPE end of the association is ‘1..1’ and 
at the VEHICLE end of the association ‘0..*’. This association is read as:
Each VEHICLE TYPE is classification for zero, one or many VEHICLES. 
The ‘reverse name’ of the association is inferred:
Each VEHICLE is within only one VEHICLE TYPE. 
With ‘naming using role names’ each association is annotated with two role names. 
These role names describe the role that the object instances of the object classes play 
with respect to the associations. Role names consist of nouns or noun phrases.
In the example, the role name associated with the VEHICLE object class could be ‘clas­
sified vehicle’ and the role name associated with the VEHICLE TYPE object class could 
be ‘vehicle classification’. 
It is not possible to ‘read’ an association named using role names.
113

9	
INFORMATION MODEL QUALITY
In Chapter 1 we started to look into the subject of model quality. In this chapter we will 
take a more detailed look into model quality. In particular, we will look at three areas 
that influence the quality of an information or data model: These are:
yy genericity and specificity in models;
yy three schemes for enforcing or determining the quality of a model: 
ßß the nine characteristics of a good data model (from Graeme Simsion and Graham 
Witt20); 
ßß the six principles of high quality data models (from Matthew West21); and
ßß the five dimensions of data model quality (from Michael Reingruber and William 
Gregory22);
yy the layout of models.
GENERICITY AND SPECIFICITY IN MODELS
What has become known as ‘generic information or data modelling’ is, to all intents 
and purposes, information or data modelling using all the conventional procedures and 
techniques of information or data modelling, but where the current business rules are 
not allowed to affect the shape of the model itself. Instead the model is adapted to treat 
such business rules as part of the subject matter being modelled. This provides longer-
term stability to the model and to any databases whose design is informed by the model.
The main difference between ‘traditional’ data models and generic data models is that 
the latter are characterised by entity types that are more abstract or generic than in a 
traditional data model. For example, in a model for a commercial business there could 
be a PARTY entity type instead of separate CUSTOMER, SUPPLIER and SUBCONTRACTOR 
entity types. Generic data models are also characterised by the inclusion of more ‘type’ 
entity types. These are entity types, such as ASSOCIATION TYPE, that allow for the 
recording in the database of the semantic definition of other data.
20 In Simsion, G. and Witt, G. (2004) Data Modeling Essentials, 3rd edition. Morgan Kaufman.
21 EPISTLE (European Process Industry STEP Technical Liaison Executive) (2003) Developing High Quality Data Models [online], 
ww.matthewwest.org.uk/publications/princ03.pdf.
22 In Reingruber, M. and Gregory, W.W. (1994) The Data Modeling Handbook: A Best-Practice Approach to Building Quality Data 
Models. Wiley-QED.
114

INFORMATION MODEL QUALITY
There are, however, other differences between traditional information or data models 
and generic information or data models, principally: 
yy There is generally a smaller number of entity types or object classes in a generic 
model than in a traditional model, making it easier to understand (although its 
relevance to the business may be less obvious). 
yy Roles played by instances of entity types or object classes and associations 
between entity types or object classes are represented in a generic data 
model by new entity types or object classes (and associated relationships or 
associations) and not by relationships or associations alone. For example, an 
‘employed by’ relationship between a company and a person may be subsumed 
by the structure shown in Figure 9.1. 
Figure 9.1 An example of the replacement of roles by entity types
Figure 9.1
yy As a consequence of using abstract entity types or object classes, for which 
‘real-world identifiers’ are often not available, identifiers in a generic model 
have to be artificial. These identifiers (or surrogate keys) have to be managed 
to be unique. 
Generic models can be developed for use at both the project and the corporate level. 
At the project level, the resulting database is more robust than if it had been developed 
from a ‘traditional’ model, leading to the likelihood that the overall lifetime cost of the 
project is reduced. It is, however, at the corporate level that generic models provide 
the greatest benefit. They enable different business viewpoints of data to be accom­
modated within the same model. They also enable the easy accommodation of new 
business viewpoints as the business develops. Additionally, because they generally 
have fewer entity types or object classes, they are more manageable and easier to 
understand. 
Figure 9.2 shows some of the stages on the continuum from generic models to specific 
models. The more generic the model, the more high level the names of the entity types. 
The ultimate generic model has an entity type or object class called THING. 
115

MODELLING BUSINESS INFORMATION
Figure 9.2 The generic to specific continuum
Figure 9
.2
The more abstract or generic the model, the greater the stability and the wider the per­
spective of the model. This leads to a more stable database design, providing greater 
future-proofing.
THE NINE CHARACTERISTICS OF A GOOD DATA MODEL 
Graeme Simsion and Graham Witt have listed nine characteristics of a good data model. 
These are completeness, non-redundancy, enforcing business rules, data reusability, 
stability and flexibility, elegance, communication, integration and conflicting objectives.
1. Completeness 
Have we included everything in which the business is interested to the extent that it 
needs to record information about those things? Have we fully understood the context 
in which the information is used?
2. Non-redundancy
Is it possible to record the same fact more than once? If so, we could have inconsistent 
information at some stage in the future. This can occur when the fact is updated in one 
place but not in the other.
Are we recording information that could be derived from other information that is 
recorded elsewhere? A typical example of this is where age and date of birth are both 
recorded: age can always be calculated from the date of birth.
116

INFORMATION MODEL QUALITY
3. Enforcement of business rules
Does the model accurately reflect the rules of the business? If these business rules are 
modelled correctly and taken forward as constraints in the design of the database, the 
information system becomes a tool for enforcing those rules. Conversely, inappropriate 
modelling of supposed business rules can lead to the constraints built into the system 
becoming a bar to business flexibility.
4. Data reusability
Can the information that we will record be reused? Can the information be used outside 
the boundaries of the system covered by our model? 
We should not be deriving information requirements solely from our process models 
(often quoted as ‘process begets data’). Information requirements are generally ‘whole 
business’ requirements. Process models, on the other hand, concentrate on a limited 
set of processes.
5. Stability and flexibility
How well will the model (and any databases built from the model) cope with any changes 
in business processes or requirements? 
One of life’s certainties is that business processes will change. If our models are built 
around the current business processes and our models only reflect the use of the infor­
mation within those processes (‘process begets data’ again) the models will quickly 
become out of date. 
Our models and our databases need to be both stable, so that they can survive any 
change in the business processes, and flexible, so that they are capable of handling new 
information without a major redesign. 
6. Elegance
Is our model simple and elegant? If so, it will be easier to understand and it will be far 
easier to communicate that understanding to others.
Part of the effort involved with designing an information model is to reduce the amount 
of complexity that comes from a lack of understanding of the information requirements.
7. Communication
The purpose of developing any model is to understand a situation and then for that 
model to act as a tool to communicate that understanding. In the case of an informa­
tion model, the model has to be communicated back to the business to demonstrate, or 
otherwise, that the business analyst has correctly understood the information require­
ments and the model also has to be communicated forward to the system developers.
The model, therefore, needs simplicity so that it is easy for the business users to inter­
pret and understand. At the same time, the model requires the technical rigour to unam­
biguously communicate the requirements to the developers.
117

MODELLING BUSINESS INFORMATION
If the correct level of simplicity is achieved it is even possible to use an incomplete 
model during the elicitation of requirements.
8. Integration
How will the proposed information system fit with the existing or future information 
systems? Although this model might accurately reflect the information requirements 
within the scope of this system, some of the other systems may hold identical infor­
mation, such as customer information, product information and codes used within the 
business. In many businesses there is still a ‘silo’ mentality, where information is not 
shared between systems. There may, however, be an organisation-wide enterprise 
architecture or technical architecture function, or even a data management function, 
and if so, an enterprise or corporate data model may exist and our data model will need 
to fit into that enterprise or corporate model.
9. Conflicting objectives
Attempting to achieve all of the above aims may be difficult because these aims often 
conflict with one another. Our overall aim should be to arrive at a final model that 
provides the best possible balance among these conflicting objectives.
THE SIX PRINCIPLES OF HIGH QUALITY DATA MODELS 
The European Process Industry STEP23 Technical Liaison Executive (EPISTLE) has 
published a document describing how to develop data models (or information models) 
that will meet the information or data requirements, be clear and unambiguous to all 
(not just the authors), be stable in the face of changing information or data require­
ments, be flexible in the face of changing business practices, be reusable by others, be 
consistent with other models covering the same scope and be able to reconcile conflict­
ing formation or data models. 
One of the authors of this EPISTLE publication was Matthew West, who was described 
as the ‘thought leader’ for data management in Shell International Limited when he 
worked for them. He was developing these ideas at the same time that I was responsible 
for data management in the British Army. Unbeknown to each other, we were following 
an almost identical path in the development of our approach to data management. 
In this work, Matthew West and the other authors identified six principles that will lead 
to the development of these high-quality data models. These are: 
i.	
Candidate attributes should be treated as representing relationships to other 
entity types. 
ii.	
Entity types should have a local identifier within a database or exchange file. 
These should be artificial and managed to ensure uniqueness. Relationships 
should not be used as part of the local identifier. 
23 STandard for the Exchange of Product model data.
118

INFORMATION MODEL QUALITY
iii.	 Activities, associations and event-effects should be represented by entity 
types (not relationships or attributes). 
iv.	 Relationships (in the entity–relationship sense) should only be used to 
express the involvement of entity types with activities or associations. 
v.	
Entity types should represent, and be named after, the underlying nature of 
the object, not the role it plays in a particular context. 
vi.	 Entity types should be part of a subtype–supertype hierarchy in order to 
define a universal context for the model. 
What EPISTLE calls a ‘high-quality data model’ almost always turns out to be a generic 
data model, for which it also uses the term ‘flexible design’. EPISTLE identified a number 
of advantages and disadvantages of developing data models such as this, which it has 
encapsulated in a diagram similar to Figure 9.3. 
Figure 9.3 The cost-balance of flexible design
Figure 9.3
All gains have to be paid for and the inherent flexibility gained by ‘genericity’ invokes a 
performance penalty.
Information systems that have their database design informed by generic data models 
have the following advantages: 
yy Reduced maintenance costs. Traditional designs tend to encapsulate the 
current business processes. As procedures change, information systems 
require maintenance to enable them to handle the revised procedures. Systems 
designed to be flexible from the outset do not incur this maintenance cost. 
yy Reduced enhancement costs. Similarly, the costs involved in adding additional 
functionality are reduced if the system is designed to be flexible. 
yy Longer system life. The maintenance and enhancement costs associated with 
traditional designs can become prohibitive, leading to a premature requirement 
to replace the system. 
119

MODELLING BUSINESS INFORMATION
yy Design reuse. Being designed to cover a wide scope and to be inherently flexible 
to change in business procedures, any single generic data model, its resulting 
database design and the software used to address that database design can be 
used in many different systems. This reduces, over time, the need for some data 
analysis and a considerable amount of database and software design. 
On the other hand, information systems that have their database design informed by 
generic data models have two disadvantages. 
First, the development costs are high. Initially, at least, the use of a generic data model 
as the basis of a database design for an information system leads to higher develop­
ment costs than if a traditional data model is used. These higher development costs 
come about partly through the unfamiliarity of the developers with the concepts embod­
ied in the model and partly from the fact that there is little tool support available for 
such development. These costs, however, are offset over time by the ability to reuse 
tested software components. 
Second, the hardware costs are high. Flexible designs based on generic data models 
require more powerful hardware to achieve performance comparable to more tradi­
tional designs. These costs, over time, are offset by the continuing reduction in the cost 
of hardware.
THE FIVE DIMENSIONS OF DATA MODEL QUALITY
Michael Reingruber and William Gregory have proposed an easily applied qualitative 
model for the assessment of the quality of a data model. This is shown in Figure 9.4.24
Figure 9.4 The five dimensions of data model quality
Figure 9.4
24 Permission to use this figure has been granted by the authors (the copyright holders).
120

INFORMATION MODEL QUALITY
In this model, Reingruber and Gregory started with the two dimensions of correct­
ness and completeness. These have then been augmented with two further orthogo­
nal dimensions – the syntactic dimension and the semantic dimension. The syntactic 
dimension addresses how the modelling language and its syntax have been used while 
the semantic dimension addresses the relationship between the model and the infor­
mation or data requirements of the business area that the model represents. Applying 
these orthogonal dimensions together, we get the four dimensions of syntactic cor­
rectness, syntactic completeness, conceptual correctness and conceptual complete­
ness. Reingruber and Gregory have added a fifth, overarching, dimension that they call 
enterprise awareness. This recognises that any information or data model for a specific 
business area or set of business processes should be seen as a subset of the enter­
prise or corporate model. It is the enterprise awareness dimension that is most often 
overlooked by modellers working as part of project teams involved in the development 
of information technology systems. 
This model of five dimensions emphasises a very important point. If you ask me to 
quality review a model you have created, the only dimensions I can confidently review 
are those of syntactic correctness and syntactic completeness. I may have some view 
on the remaining dimensions of conceptual correctness, conceptual completeness and 
enterprise awareness, but the only way I could confidently provide any sort of informed 
comment is to revisit every aspect of the analysis that you have undertaken. This is very 
costly and is also likely to reduce the faith in the model of the business users. Good col­
laboration, both with other modellers and with appropriate business users, is, therefore, 
vitally important when developing and validating a model.
THE LAYOUT OF MODELS
There is no ‘standard’ for the layout of models. However, the quality of the layout of a 
model can influence whether the model is understood or not. 
Despite the lack of any standards, there are some guidelines that can be applied to the 
layout of models to enhance their readability, and hence improve their understanding. 
These are:
yy Provide a light grey background for the model. This highlights the entity types 
and object classes and makes sure that relationship and association lines are 
not confused with the edges of the entity types and object classes. With just 
black and white a model can just become a mass of confusing lines.
yy Do not use any other colour. Models will often be printed in monochrome and 
the colour just becomes different grey tones. Also, some people who may need 
to read the model could be colour blind.
yy If possible, avoid crossing relationship and association lines. Models are easier 
to follow if relationship and association lines do not cross each other. However, 
even on relatively small models it is sometimes difficult to avoid crossing 
relationship and association lines. Under these circumstances, it is useful is 
use a small semi-circular ‘jog’ on one of the lines to emphasise that these are 
crossing lines and not intersecting lines.
121

MODELLING BUSINESS INFORMATION
yy Be consistent with the layout to improve communication with the business. 
Some modellers always place the entity type or object class representing the 
main subject of the model in the centre of the model, with the relationship 
and association lines radiating out from that entity type or object class. 
Others believe the entity types and object classes should be arranged so that 
all one-to-many relationships or associations should flow down the page (a 
hierarchical view, sometimes referred to as the ‘no dead crows’ approach). In 
their interactions with business users Harry Ellis and Richard Barker developed 
the so-called ‘starry skies’ approach where the entity types and object classes 
are arranged with those representing the most concrete things or concepts in 
the bottom right hand corner of the model and those representing the most 
abstract concepts in the top left hand corner of the model. Using the ‘starry 
skies’ approach, the crow’s feet all face left or upwards. 
Whichever approach to layout is adopted the key is consistency to help the business 
users understand the model. All models within an organisation should follow the same 
approach.
In this book we are restricted because our models are all displayed on a single page. This 
works against us having a consistent approach to layout (although we have attempted 
to follow the ‘starry skies’ approach with the Ellis-Barker entity relationship models and 
the hierarchical view with the UML class models).
122

10	 CORPORATE INFORMATION AND DATA 
MODELS
In this chapter we will be taking an enterprise-wide view of information and data. To 
achieve this, it is essential that we produce a clear and unambiguous definition of all 
information and data that the organisation uses. Such a definition must be a common 
view, accepted and agreed by all business areas.
THE PROBLEMS 
Organisations vary tremendously in size and nature. A large multinational organisation 
tends to have different information and data problems from a small company although, 
even in a small company, the problems can be quite complex. The type of business may 
also affect the nature of the problems. A large proportion of the information systems 
in a finance or insurance company relate to customers or potential customers. In a 
manufacturing environment, however, dealing with customers is only one part of the 
overall business processes.
Individual departments do not necessarily perceive a given problem as having a poten­
tial impact across the whole organisation. One of the difficulties often faced by a central 
team responsible for managing the information or data for the whole organisation is 
bridging the gap between different departmental views. This requires patience and tact. 
It certainly requires authority, or access to appropriate authority, as the implementation 
of a solution may well involve cooperation with several managers within the organisa­
tion. Most importantly, it demands an understanding both of the information needs of 
the whole business and of the nature of the associated technical and organisational 
problems.
In many respects, a corporate information or data model is very similar to the project-
level conceptual model. It comprises definitions of the things of significant interest to 
the business (the entity types or object classes), definitions of what we need to know 
about those things (the attributes) and the associations between them (the relation­
ships or associations). A corporate model is different because its scope extends beyond 
a single project; ideally it extends to cover the information requirements of the whole 
business.
Most of this book has been about the development of a conceptual model that records the 
information requirements of a specific business area to inform the development of the 
database that is at the heart of an information technology system to support that busi­
ness area – and only that business area. This information system, like most information 
123

MODELLING BUSINESS INFORMATION
systems, supports a limited set of users carrying out a limited set of business processes. 
However that conceptual model is developed, it is restricted to that subset of the total 
information requirements of the enterprise that is required to support the current busi­
ness processes or the business processes under consideration, for that restricted busi­
ness area.
This approach to modelling, therefore, provides a model that, within the bounds of a 
single project, is relatively easy to understand but leads to a database design that is 
usually based on the current use of information and data. Any requirement to store 
new ‘data items’ or to change the ‘business rules’ that apply to information or data 
means a change to the conceptual model, with subsequent changes to the database 
structure and the application programs that access the structure. The problem is often 
compounded because a database supporting a single system is normally optimised to 
improve the performance of the applications developed for that system. In the worst 
case, the scale of the changes to the system required when the business processes 
change may be so prohibitively costly, in both time and money, that the systems start to 
constrain rather than enhance the business.
The scope of a corporate information or data model must extend beyond a single infor­
mation system or business area. Any attempt to produce a corporate model using an 
approach similar to the development of the conceptual model of a single project is 
bound to fail, especially if the purpose of the initiative is to develop a corporate model 
that forms the basis of the database design for all future systems. There are two inter­
related reasons for this.
First, since the complexity of the corporate model is proportional to the complexity of the 
enterprise, for a very complex organisation, the corporate model could be exceedingly 
large and exceedingly complex, requiring many years (or decades) of development. It is 
also very probable that because of its complexity and its size the finished product will be 
unintelligible to all except those who have been intimately involved in its development. 
Second, physical database design and application development must be postponed until 
the development of the corporate data model is completed. If it is not, the organisation 
will be continuously developing legacy systems as the development of the corporate 
data model overtakes the development of the systems.
A corporate information or data model, by definition, has to cover many different busi­
ness areas. If the corporate data model is to be used as the basis for all future database 
design, it also has to be stable. A corporate data model, therefore, has to cope with both 
of the following phenomena. 
First, there is the different, sometimes conflicting, uses of information and data required 
by the different business areas.
Second, there is the uncertain nature of the future information and data requirements 
across the enterprise.
Information and data is used in many different ways by the many disparate business 
areas within an enterprise. While a single project, supporting one business area or 
124

CORPORATE INFORMATION AND DATA MODELS
a single set of business processes, could produce a conceptual model encapsulating 
that functional area’s use of information, this becomes increasingly more difficult the 
broader the scope of the model. In the development of a conceptual model to support 
all of an enterprise’s activity – to inform the development of a large number of inter-
operating systems – it will become necessary to develop a model that is ever more 
generic or abstract in nature.
Examples of two different uses of information that lead to this increasing ‘genericity’ 
of a corporate data model are described below.
First, there are the differences between departments over the meaning of terms such 
as ‘customer’. For the finance department, a customer is someone who has placed an 
order and needs to pay for the goods or services ordered, while for the sales depart­
ment, a customer could be someone that they are working with to develop a relation­
ship so that they will place an order at some time in the future. Furthermore, for the 
finance department the customer is the department of the ‘customer organisation’ who 
is responsible for paying the invoice, while for the sales department, the customer could 
be the person within the ‘customer organisation’ with the power to make purchasing 
decisions. 
The second example involves overlapping roles that can exist within and between busi­
nesses. For a company selling computer equipment and consumables, another com­
pany can be both a supplier, for example, supplying the paper to be sold, and a customer, 
for example, by buying computers to manage its own operations. For a finance company 
or a bank, an employee may also be a customer.
Also, in any enterprise there is some uncertainty over the future information or data 
requirements of the enterprise. If there is not to be continual reengineering of the infor­
mation technology systems, their databases must have sufficient in-built flexibility to 
be able to store and distribute new information. The corporate model must, therefore, 
reflect the requirement that databases derived from the corporate model must be able 
to store data about ‘objects’, activities and concepts that have never before been identi­
fied or are based on rapidly changing ‘business processes’ that are updated as proce­
dures are adapted to meet new circumstances. The database structures should be static 
over time, but capable of accommodating business change.
PRINCIPLES FOR THE DEVELOPMENT OF A CORPORATE MODEL
A corporate model can either be very large, with very many entity types or object 
classes in the model, and very detailed and specific, or else can be relatively small, 
with very few entity types or object classes, and very abstract or generic. A corporate 
model that is large and specific encapsulates all the business rules and is expressed 
using names and terms that are familiar to the business. It is a good model with 
which to discuss data requirements with the business, but any databases designed 
with such a model as their basis would be unlikely to cope with business change. A 
corporate model that is small and generic leads to stable database designs that cope 
with business change, but its generic nature means that it is not a suitable vehicle for 
discussions with the business.
125

MODELLING BUSINESS INFORMATION
As a result of leading the development of a corporate model, I have developed six princi­
ples for the development of corporate information or data models. These principles are:
yy Develop the model ‘top-down’ – building top-down implies the development 
of a single conceptual model that, from its inception, is intended to cover the 
complete information and data requirements of the whole enterprise. 
yy Give primacy to the core business – clearly, a corporate model must be 
developed with the core business of the enterprise uppermost in the minds of 
the developers, which ensures that the model is correctly focused.
yy Cover the whole enterprise – despite giving primacy to the core business, a 
corporate model must be able to support the information needs across the full 
breadth of the enterprise, which ensures that the model covers all business 
viewpoints and that no information requirements are missed.
yy Future-proof the model – for a corporate model to be of real value, it must 
be stable over time; it must be future-proofed – the model must, therefore, 
represent the true underlying nature of the information and data used in the 
business and not how that information or data is used at the time of the analysis. 
yy Develop cooperatively – it is impossible for a corporate modelling team to 
develop a corporate model in isolation; cooperation is essential. The modellers 
must consult widely with subject matter experts in the various business areas 
in the enterprise and with the technical people who are familiar with the existing 
information systems or who will be responsible for the development of future 
systems.
yy Gain consensus, not perfection – there is a danger that a corporate modelling 
team will seek to develop the perfect model. Although this is laudable, it may 
lead to a delay in the eventual use of the model – if a model is deemed to be 
‘fit for role’ by all business areas, even if it is not perfect, it should be published 
and supported.
126

11	 DATA AND DATABASES
Physical databases come in many different shapes and sizes and database technology 
is constantly evolving, as are the types of data we wish to keep in our databases.
THE DATA LANDSCAPE
We can consider the ‘data landscape’ as consisting of six categories of data: structured 
data, unstructured data, semi-structured data, master data, meta data and, finally, what 
has become known as ‘big data’. These six categories, and their relationships to each 
other, are shown in Figure 11.1.
Figure 11.1 The data landscape
Figure 11.
1
The simplest of these categories to understand is structured data – the numbers, dates 
and short character strings that have traditionally been capable of storage within a 
database. Most people these days think of this data being stored in a database organ­
ised into tables and columns as shown in Figure 11.2 (although that is not the only way 
to store structured data).
127

MODELLING BUSINESS INFORMATION
Figure 11.2 Example data arranged in tables and columns
Figure 1
1.2
128

DATA AND DATABASES
If that is structured data, what is unstructured data? This is a term that is applied to 
data that exists in documents, in drawings, in audio and video clips, and so on. This data 
is sometimes called multimedia data and is characteristically very large, with a size 
for an individual item of data ranging from kilobytes to gigabytes. Note that while these 
types of data are often considered to be ‘unstructured’, they may have well-defined 
(even standardised) structures – think MP3 for audio and MP4 for video. Another char­
acteristic of unstructured data is that it is not easily searched using traditional search 
algorithms. This data can be stored and managed by database management systems 
that have kept pace with developments of the SQL standard. Although it is not easy to 
manage, unstructured data can provide the business with valuable information. In most 
businesses, the quantity of unstructured data far exceeds the quantity of structured 
data. It is just that most of the unstructured data is not managed as data – it just exists 
within the business.
We also have a category of data called semi-structured data. This term normally refers 
to data that is encapsulated in a ‘document’ encoded using a syntax such as the eXten­
sible Markup Language (XML) or JavaScript Object Notation (JSON). This data can also 
be stored and managed by database management systems that have kept pace with the 
most recent developments of the SQL standard. This data can generally be searched to 
discover information and knowledge that is useful to the business.
The most recent term to come to the fore in the information and data world is ‘big data. 
This is a poorly defined concept, but big data can be considered as data that exhibits one 
or more of the following characteristics (known as the 3Vs):
yy Volume – where the collective volume of the data is sufficiently large (say from 
terabytes to zettabytes) so as to require special considerations. 
yy Variety – where the data consists of multiple types of data, potentially from 
multiple sources; this variety can be combinations of structured data, semi-
structured data and unstructured data.
yy Velocity – where the data is produced at high rates and operating on ‘stale’ or 
out-of-date data is not valuable.
There are many business areas where the data exhibits these characteristics. Google 
and Amazon have very high volumes of data, some of which is semi-structured or 
unstructured, as do the government ‘listening’ agencies such as the National Security 
Agency (NSA) in the USA and the Government Communications Headquarters (GCHQ) 
in the UK. The data handled by the mobile telephone companies is high-velocity data. 
To be of use to the business, however, this (big) data must also exhibit additional char­
acteristics (another 3Vs) of:
yy Value – where the data has perceived or quantifiable benefit to the business.
yy Veracity – where the correctness of the data can be assessed.
yy Variability – where the change in velocity is recognised.
The ‘established’ database technologies, basically those based on SQL, are poor at handling 
large volumes of data (they do not scale up well), are poor at handling semi-structured 
129

MODELLING BUSINESS INFORMATION
data and unstructured data (despite the advances in the SQL standard to facilitate their 
handling) and are poor at handling new types of data (although the international standards 
committee that is maintaining the SQL standard is trying very hard to plug this particular 
gap). As a consequence, we have recently seen the emergence of a number of the so-called 
‘big data technologies’ to both store and analyse big data. 
A working definition of big data that has been developed within the ISO community is:
Big Data is a data set, or a collection of data sets, with characteristics (for example, 
volume, velocity, variety, variability, veracity, etc.) that for a particular problem 
domain at a given point in time cannot be efficiently processed using current/exist-
ing/established/traditional technologies and techniques in order to extract value.25
As a warning, Michael I. Jordan, the Pehong Chen Distinguished Professor at the 
University of California, Berkeley has said:
The overeager adoption of big data is likely to result in catastrophes of analysis 
comparable to a national epidemic of collapsing bridges … Despite recent claims 
to the contrary, we are no further along with computer vision than we were with 
physics when Isaac Newton sat under his apple tree.26
We also have master data, the data that is used across many applications within an 
enterprise that needs to be managed centrally. Master data is normally considered to 
consist of ‘reference data’ (the codes that are used to categorise other data), ‘transac­
tion structure data’ (the data about the participants in a transaction, such as suppliers, 
customers and products) and ‘enterprise structure data’ (the data that describes the 
organisational structure or the financial structure of the enterprise). 
And then there is meta data (or metadata), ‘data about data’ or ‘data that describes other 
data’. This term has many uses, but for us it is any data, structured or otherwise, that 
describes the way that data is stored in a database. Data models are, therefore, meta­
data, as are definitions of SQL tables and columns and any constraints or data access 
rules that are applied to a database. 
DATABASES
As stated above, physical databases come in many different shapes and sizes and 
database technology is constantly evolving. An outline chronology of database evolu­
tion is shown in Figure 11.3.
Hierarchical databases
The hierarchical model of data formed the basis for a number of early database manage­
ment systems, the most prominent being IBM’s Information Management System (IMS). 
25 ISO/IEC JTC1 Study Group on Big Data.
26 Interview for IEEE Spectrum 20 October 2014.
130

DATA AND DATABASES
IMS was first released in 1968 and is still in use today with many legacy mainframe-
hosted applications used for accounting and inventory control.
Figure 11.3 The database chronology
Figure 11.3
Figure 11.4 shows an example of a schema diagram for a hierarchical database. This 
schema has only one hierarchy, but there could be many hierarchies in a single database. 
Each hierarchy comprises a number of record types, with each record type comprising 
a number of field types. Each hierarchy has a root record type. In this schema, the root 
is the DEPARTMENT record type, which has two field types, or data items, DNAME, the 
name of the department, and DTELNUMBER, the telephone number of the department.
Each hierarchy has a number of one-to-many parent–child relationship types. There 
may be zero, one or more child-record instances for each instance of a parent record. 
In this schema these are (DEPARTMENT, EMPLOYEE), (DEPARTMENT, DEPTMANAGER), 
(DEPARTMENT, PROJECT), (EMPLOYEE, EMPQUALIFICATION), (EMPLOYEE, DEPENDENT) 
and (PROJECT, PROJASSIGNMENT). In a hierarchical database, these relationships are 
represented by the parent–child links themselves.
Figure 11.4 Hierarchical database schema 
Figure 11.
4
Figure 11.5 shows an example set of data stored as records within the hierarchical 
database that conforms to the schema in Figure 11.4. 
131

MODELLING BUSINESS INFORMATION
Figure 11.5 Hierarchical database occurrences 
Figure 11.
5
132

DATA AND DATABASES
In a hierarchical database, the records may be stored sequentially, reading the hierar­
chical trees from top to bottom and left to right. Alternatively, the records may be linked 
using pointers, extra fields that contain data that identifies the location of the related 
record. Hence, a hierarchical database is an example of a navigational database – one 
where we need to navigate from record to record.
Network databases
Like its predecessor, the hierarchical model of data, the network model of data formed the 
basis for a number of pre-relational database management systems. The model was based 
on the recommendations of the Conference on Data Systems Languages (CODASYL) Data 
Base Task Group, published in 1971. The most prominent product based on the network 
model was the Integrated Database Management System (IDMS) from Cullinet Software, 
Inc (now part of Computer Associates). Many IDMS implementations are still in use today.
Figure 11.6 shows an example of a schema diagram for a network database. The main dif­
ference between the hierarchical model of data and the network model of data is that, in the 
network model, a record type can have more than one parent, whereas in the hierarchical 
model each record type is limited to only one parent. In the network model, the ‘links’ between 
record types are known as sets. Each set has an owner record type (the parent, with only one 
occurrence allowed) and a member record type (the children, with zero, one or more occur­
rences). In this schema, the WORKS-IN set has the DEPARTMENT record type as its owner and 
the EMPLOYEE record type as its member, while the IS-MANAGED-BY set has the EMPLOYEE 
record type as its owner and the DEPARTMENT record type as its member. The arrow head is 
the equivalent of a crow’s foot in an entity–relationship conceptual data model. 
Figure 11.7 shows how the example data is stored in a network database. The sets are 
maintained by a series of pointers. The DEPARTMENT record instance for the Finance 
Department is the owner of one of the WORKS-IN sets and has a pointer that points 
to the first member in the set, the EMPLOYEE record for the employee whose payroll 
number is AY334. This in turn points to the next EMPLOYEE record in the set, and so on. 
The last EMPLOYEE record in the set has a pointer that points back to the owner record, 
the FINANCE department. 
Relational (or SQL) databases
For most current and future business applications, a database managed using the 
SQL database language, where data is organised into tables and columns, as in Figure 
11.2, is used. Such a database is often called a ‘relational database’, after the idea that 
data should be organised in ‘relations’ put forward by IBM’s Edgar F. Codd in 1970, 
although SQL is not a truly faithful representation of Codd’s relational model of data. 
These are the most common database management systems in use today and most 
of our information modelling techniques were designed with the relational database 
in mind.
133

MODELLING BUSINESS INFORMATION
Figure 11.6 Network database schema 
Figure 11.
6
134

DATA AND DATABASES
Figure 11.7 Network database occurrences 
Fig
ure 11.7T
135

MODELLING BUSINESS INFORMATION
Leading examples of database management systems for business use that have SQL 
as their database language are Microsoft’s SQL Server and the database product from 
ORACLE. Other products, more suited to individual use, are MySQL, PostgreSQL and 
Microsoft Access. Although SQL was originally designed to handle simple structured 
data, the SQL standard is now ‘Object-Relational’ and includes facilities to store and 
manage more complex data such as geospatial data, binary data in the form of images, 
audio and video, and documents, including XML (eXtensible Markup Language) docu­
ments and JSON (JavaScript Object Notation) documents.
In effect, SQL is now encroaching on the post-relational world and the developments in 
SQL are explained in more detail in Chapter 13.
Object-oriented databases
Object-orientation is a programming paradigm where the world is seen as a collection 
of objects that exhibit both state and behaviour. The state of an object at any one time 
is the aggregation of the values of the object’s attributes. The behaviour is the set of 
messages to which the object can respond. Objects respond to messages by executing 
methods, short pieces of program code.
Objects are grouped into classes. So, for example, within an object-oriented program 
to manage human resources, there could be an EMPLOYEE class with attributes 
of ‘payrollNumber’, ‘title’, ‘surname’, ‘otherNames’, ‘birthDate’, and so on. One of the 
objects of this class has the state ‘CX137, Mrs, Rogers, Jennifer Alyson, 10 January 
1970’. This object also has an object identifier that is used by the system to uniquely 
identify the object. The object identifier is totally independent of the values of its 
attributes, is system generated, and is hidden from the user. This means that object-
orientation has no equivalent of the primary key concept of the relational model 
of data.
Examples of the sorts of messages that instances of the EMPLOYEE class may respond 
to are: ‘What is your surname?’, where the answer is generated by a method that reads 
the value of the ‘surname’ attribute; and ‘What is your age?’, where the answer is gen­
erated by a method that calculates the difference between the current date and the 
value of the ‘birthDate’ attribute. There can also be messages to update the values of an 
attribute, such as ‘setName(aNewName)’.
There are four fundamental concepts underlying the object-oriented programming 
paradigm. These are: 
yy Encapsulation (or data hiding) – the hiding of the implementation of an object’s 
data structure and methods from the user. The only way that an object can 
interact with other objects is through the passing of messages.
yy Inheritance – the ability of one object class to reuse the data structures and 
methods of another class without reimplementing them.
yy Polymorphism – where different objects in different classes respond to the 
same message by executing different methods.
yy Aggregation (or containment) – the ability to group objects to make more 
complex or composite objects.
136

DATA AND DATABASES
It is important that persistent storage of objects is available in any information sys­
tem that hosts object-oriented application programs. Some object-oriented program­
ming environments do provide persistent storage, but it is then closely coupled to the 
application programs themselves. There are, however, some object-oriented database 
management systems available on the market, but they tend to be used in fairly spe­
cialised environments, such as computer-aided design and manufacturing (CAD/CAM) 
and geographic information systems (GIS). Those products that are available, although 
following generally accepted object-oriented principles, have been developed using dif­
ferent approaches, such as the extension of an existing object-oriented programming 
language or the development of class libraries using an object-oriented programming 
language, and use different syntaxes for the data definition and data manipulation lan­
guages. There are no commonly accepted standards (yet) for object-oriented databases.
The Object Data Management Group (ODMG) has, however, developed a formal specifica­
tion for object-oriented databases. This specification includes a data definition language 
called the Object Definition Language (ODL) and a query language called the Object 
Query Language (OQL). There is not a single manipulation language; the manipulation 
of the objects needs to be programmed in an object-oriented programming language 
such as C++ or Java. 
The intention was that the ODMG standard should rival SQL but, as far as your author 
is aware, there are no general-purpose database management systems based on the 
ODMG standard suitable for business applications available on the market. Since most 
application programming is done using object-oriented programming languages, the 
use of a database based on the same language as the application programming would 
be advantageous, but most business applications use SQL as their database language. 
This presents problems, since the application program is based on objects and the data­
base is based on set theory. These problems are known as the ‘impedance mismatch’. 
NoSQL databases
To accommodate big data we require databases that are flexible so that they can 
easily accommodate new data types. We also need databases that are not disrupted by 
content structure changes from third-party data providers. Unfortunately, in addition to 
not scaling well for large volumes of data, the rigidly defined, schema-based approach 
used by SQL databases makes it very difficult, if not impossible, to quickly incorporate 
new types of data. SQL databases are also not a good fit for unstructured and semi-
structured data. This has led to the rise of the so-called NoSQL databases (it is unclear 
whether NoSQL stands for ‘Not only SQL’ or ‘Never SQL’).
There are over 150 NoSQL database management systems available that have been 
developed to store big data, but for over 90 per cent of normal business applications 
the established database technologies remain the appropriate technology to use. Only 
organisations handling massive amounts of data (such as Amazon, Google or the secu­
rity agencies) or who need to respond to incoming data as it arrives (such as telecom­
munication companies) require the special technology. 
All NoSQL databases achieve performance gains by doing away with some (or all) of 
the restrictions traditionally associated with conventional databases, such as read-write 
137

MODELLING BUSINESS INFORMATION
consistency, in exchange for scalability and distributed processing. NoSQL databases 
can be categorised under four main headings: 
yy Key-value stores – This is where the data is stored in a schema-less way, 
with the ‘key-value’ relationship consisting of a key, normally a string, and a 
value, which is the actual data of interest. The value itself can be stored using 
a data type of a programming language or as an object. Typical key-value store 
database management systems are Redis and Riak CS. 
yy Document stores – This is a special type of key-value store where the values 
are the native documents, such as Microsoft Office (MS Word and MS Excel, 
among others), PDF, XML or JSON documents. While every row in a table in 
an SQL database will have the same sequence of columns, each document 
could have data items that are completely different. Whole documents can be 
retrieved based on their ‘key’ but, in addition, document stores should provide 
an ability to retrieve a document based on its content. Typical document store 
database management systems are MongoDB and CouchDB.
yy Extensible record (or wide-column) stores – Like SQL databases, extensible 
record stores, or wide column stores, have tables (called ‘Super Column 
Families’) which contain columns (called ‘Super Columns’). However, each of 
the columns contains a mix of attributes, similar to key-value stores. The most 
common NoSQL database management systems are for extensible record 
stores. Typical extensible record store database management systems are 
Cassandra, Hadoop and HBase.
yy Graph databases – A graph database consists of interconnected elements 
with an undetermined number of interconnections. These can be used for data 
representing concepts such as social relationships, public transport links, road 
maps or network topologies. Typical graph database management systems are 
Sones GraphDB and Neo4j.
It is worth noting that many of the NoSQL databases are ‘navigational’ – the application 
writer is responsible for searching the data appropriately to track any related data.
138

12	 BUSINESS INTELLIGENCE 
Business intelligence is the name that has been given to the set of ‘techniques’ that 
is used to transform raw data into information that can be used to inform high-level 
decision-making. This set of techniques enables decision-makers to take historical, cur­
rent or predictive views of the business. The techniques include data warehousing, data 
mining, online analytical processing (OLAP) and dimensional modelling.
THE DATA WAREHOUSE
A data warehouse is not just a large collection of data. At its simplest, it is a copy of trans­
actional data – that is, the data created in the operational systems used by the enterprise. 
This copied data is specifically structured to make it easy for the data to be queried and 
analysed. Senior management can use this copied data to monitor the progress of the 
business and, hence, to make strategic decisions that affect the future of the business.
Although, at its heart, a data warehouse holds copies of transactional data, to make it 
easier to analyse and query that data, a data warehouse also holds some aggregated or 
summarised data – copied data that has been processed in some way. Most data ware­
houses also hold a considerable amount of human-readable metadata to help manage­
ment and other users understand the data in the warehouse. 
The data warehouse contains data that is: 
yy Subject-oriented – the data warehouse contains copies of data that are 
organised so that all the data relating to the same event or other subject of 
interest is associated with each other;
yy Time-variant – the data is arranged so changes over time can be identified;
yy Non-volatile – once data is in the data warehouse it is never updated or deleted; 
and
yy Integrated – the data in the data warehouse is from most or all of the 
enterprise’s operational systems and is structured so that it is seen as a single 
collection of data.
For a supermarket, the data warehouse could record that a customer – who may or may 
not have a loyalty card and may or may not, therefore, be identifiable – bought two 200g 
tins of Brand X baked beans, one 415g tin of Brand Y cream of tomato soup, and one 
own-brand uncut white loaf, and so on, as they passed through a particular checkout in 
a particular store at a particular time on a particular day.
139

MODELLING BUSINESS INFORMATION
This data can then be used to, among other things: 
yy compare sales between stores; 
yy compare sales of own-brand products against branded products; 
yy identify purchasing patterns for particular days of the week or times of day; 
yy identify relationships between product purchases – for example, it has been 
reported that a supermarket chain28 discovered that beer is more often bought 
by those who buy disposable nappies than by those who do not buy disposable 
nappies.
Since the data in a data warehouse is a historical copy of transactional data and is not 
going to be updated, there is no need to worry about update anomalies. There is, there­
fore, no requirement for the data to be normalised. This allows the data to be structured 
in a way that makes it easy to query. 
THE MULTIDIMENSIONAL MODEL OF DATA
Conceptually, users of data warehouses find it easy to visualise the data as a ‘cube’ of 
three, four or even five or more, dimensions. If a company sells products at stores and 
the company’s performance is measured over time, then the associated data can be 
visualised as in Figure 12.1; that is, as a cube with three dimensions (a product dimen­
sion, a store dimension and a time dimension). 
Figure 12.1 A multidimensional data model
Figur
e 12
.1
28 Usually ascribed to Walmart but some writers ascribe this to the 7–11 Stores or other store chains. It is probably an ‘urban 
myth’ but provides a good indication of the power of analysing the data held in a data warehouse.
140

BUSINESS INTELLIGENCE 
The conceptual visualisation of data in this way is referred to as the multidimensional 
model of data. The points (cells) within the cube are where the measurements for the par­
ticular combinations of product, store and time are stored. This way, the value of the sales 
of a particular product (200g tin of Brand X baked beans) at a particular store (Store 315) 
over a particular time (2 -3 p.m. on Friday 18 January 2013) can be directly seen. Summing 
along the store dimension gives the value of all of the sales of 200g tins of Brand X baked 
beans at all of the company’s stores during that hour. Summing along the product dimen­
sion gives the value of the sales of all the products sold at that store during that hour. 
Summing along the time dimension gives the value of the sales of 200g tins of Brand X 
baked beans at that store over the extended time period (month, year, and so on).
Once structured in this way the data can be: 
yy used with standard reporting tools, supporting questions of the ‘who …?’ 
and ‘what …?’ variety, such as, ‘which store had the greatest value of sales in 
December 2016?’ and ‘what was our best-selling product in December 2016?’; 
yy queried using OLAP (online analytical processing) techniques, supporting 
questions of the ‘what if …?’ and ‘why …?’ variety, such as ‘what will happen to our 
sales figures if we withdraw 200g tins of Brand X baked beans from our product 
range?’ – the OLAP techniques are the slice, dice, roll-up and drill-down operations; 
yy subject to data mining, the application of advanced statistical and other 
techniques against the large volumes of data held in a data warehouse to 
discover previously unknown patterns in the data that may be of interest to the 
business, such as the ‘beer and nappies’ correlation mentioned earlier. 
DIMENSIONAL MODELLING
The significance of this from a business analysis and information modelling perspective 
is that modelling rules, particularly those associated with relational data analysis, are 
turned on their head. Now we are into ‘dimensional modelling’. 
For example, our three-dimensional cube (product, store and time) could be represented 
using the dimensional ‘star schema’ shown in Figure 12.2. 
Figure 12.2 A typical ‘star’ schema for a data warehouse
Figure 12.
2
141

MODELLING BUSINESS INFORMATION
This star schema would be physically implemented as four tables. At the centre of 
the star is a single fact table – in this case the sales-fact table. This fact table has a 
many-to-one relationship with each of the dimension tables, store-dimension, product-
dimension and time-dimension.
In this schema, the fact table contains the daily sales totals, that is, the units sold, the cost 
value and the sale value, for each product in each store. This is as a result of a decision 
that was made following an analysis of the likely queries that may be made of the data. 
If it is likely that a user may at some time in the future wish to analyse the distribution of 
sales throughout a day, the time dimension table needs an additional column (say, ‘hour’). 
Decisions about the granularity of the dimensions of the data warehouse are, therefore, 
very important. Users can only drill down to the lowest level of granularity at which data 
is stored. Once data has been stored in the data warehouse with the granularity of the 
time dimension being set as a day, it is impossible to determine the pattern of sales at 
different times during the day.
There are a number of things to note about this schema. 
The primary key of the fact table is the combination of the foreign keys that reference 
the dimension tables. The only non-key columns of the fact table are all numerical. This 
is important because they are to be subject to statistical analysis. The dimension tables 
are not normalised – there is a lot of repetition of data. 
Additionally, the TIME-DIMENSION table has a column called ‘holiday-flag’. This enables 
users to query the data to see what effect holidays have on the sales. The other col­
umns in the time-dimension table allow for analyses that compare sales on Mondays 
against sales on, say, Tuesdays, January sales against March sales, first quarter sales 
against third quarter sales, and sales on May Day bank holiday 2012 against May Day 
bank holiday 2013. 
The STORE-DIMENSION table has a ‘floor-plan-type’ column. This allows analyses that 
look at the extent to which different store layouts may influence sales. Why are the 
fruit and vegetables by the entrance and the in-store bakeries diagonally opposite the 
entrance in most supermarkets?
There are possible variations on the star schema, such as the ‘snowflake’ schema and 
the ‘galaxy’ schema. 
Figure 12.3 provides an example of a snowflake schema. Such a schema introduces a 
degree of normalisation into the dimensions, but this makes the data more difficult to 
query. 
142

BUSINESS INTELLIGENCE 
Figure 12.3 A ‘snowflake’ schema
Figure 12.
3
Figure 12.4 provides an example of a galaxy schema. This is a schema where two or 
more fact tables share one or more of the dimensions.
Figure 12.4 A ‘galaxy’ schema
Figure 12.
4
143

13	 ADVANCES IN SQL (OR WHY BUSINESS 
ANALYSTS SHOULD NOT BE IN THE 
WEEDS) 
SQL used to be an abbreviation for Structured Query Language, but since the language 
includes data definition elements as well as query and manipulation elements it is now 
formally known as ‘The database language, SQL’. Over the years there have been a 
number of advances in the SQL standard that expand the functionality of SQL databases.
THE BASICS OF SQL
The development and maintenance of the international standard for SQL is the responsibil­
ity of ISO/IEC JTC1 SC32 WG3 – Working Group 3 (Database Languages) of Sub Committee 
32 (Data Management and Interchange) of the Joint Technical Committee 1 (Information 
Technology) of the International Organization for Standardization and the International 
Electrotechnical Commission. The SQL standard is published as ISO/IEC 9075.
Technically, the delegates to international standards committees are all nominated 
by their national bodies, such as the British Standards Institution, the American 
National Standards Institute, the Deutsches Institut für Normung and the China 
National Institute of Standardization, and each national body has a single vote. 
In the working groups, however, the delegates are considered to be ‘individual 
experts’ and, although they still need to be nominated by their national bodies, it is 
possible for experts from the same national body to disagree. Despite the fact that 
they are nominated by their national bodies, most of the members of ISO/IEC JTC1 
SC32 WG3 are employees of the major database management system vendors, 
such as IBM and the Oracle Corporation.
For many people involved in information technology, ‘standard SQL’ is SQL as defined in 
the third edition of the standard, generally known as SQL-92, which was published in 1992. 
This 1992 version of the standard has influenced much of the thinking of ‘traditional’ entity 
relationship modelling and UML class modelling where the target database will be an SQL 
database. Fundamental to this thinking was that all attributes should be single valued.
The data types available in SQL-92 were limited to those that could handle the so-called 
structured data:
yy Types to handle numbers, such as INTEGER, SMALLINT, NUMERIC, DECIMAL, 
REAL, DOUBLE PRECISION and FLOAT.
144

ADVANCES IN SQL (OR WHY BUSINESS ANALYSTS SHOULD NOT BE IN THE WEEDS) 
yy Types to handle character strings, such as CHARACTER, for fixed-length 
character strings, and CHARACTER VARYING.
yy Types to handle dates and time intervals, such as DATE, TIME, TIMESTAMP, 
INTERVAL YEAR, INTERVAL MONTH, INTERVAL DAY TO HOUR and INTERVAL 
MINUTE to SECOND.
NEW SQL DATA TYPES
The fourth edition of the standard, generally known as SQL3 or SQL:1999 but actually 
published as an international standard in 2000, introduced a fundamental shift: many 
new data types were introduced, including collection types, and the whole standard 
became ‘object-relational’. The standard has been regularly updated and augmented 
since the publication of SQL:1999.
The large object types
SQL has two data types for large objects: the CHARACTER LARGE OBJECT (also known 
as a CLOB) for character data, and the BINARY LARGE OBJECT (also known as a BLOB) 
for binary data (a string of bytes). As the name implies, both of these data types can be 
considerably larger than a conventional SQL data type.
A CLOB value can be used in much the same way as any other character string, includ­
ing searching for a given pattern and locating and extracting parts of a string. A BLOB 
value is similar to a CLOB value but does not have the ability for character interpretation.
CLOB and BLOB data types can be used in exactly the same way as other data types 
in defining and querying data. For example, a column to hold pictures of employees as 
BLOB values can be specified in a statement to create an ‘employee’ table as follows:
CREATE TABLE employee29
  (
    staff_number   SMALLINT,
    name           CHARACTER VARYING(25),
    staff_picture  BLOB(100K)
  ); 
The DISTINCT type
A distinct type is a user-defined type that provides the ability to distinguish a set of 
values that have some special meaning from other similar values that have a differ­
ent meaning. An example is a product code expressed as a number represented by 
an integer value which we would not want to confuse with another integer value, such 
as the quantity of stock of that product. The distinct type is very close to the domain 
concept in relational theory. 
An SQL distinct type is created using a statement such as:
CREATE TYPE staff_number_type AS SMALLINT;
29 Note that in our example SQL statements, the SQL keywords are in UPPER CASE and the user-defined elements are in 
lower case.
145

MODELLING BUSINESS INFORMATION
This statement creates a distinct type named ‘staff_number_type’ that has integer val­
ues represented by the data type SMALLINT, the source type. 
A distinct type can then be used in a column specification as follows:
CREATE TABLE employee
  (
    staff_number   staff_number_type,
    name           CHARACTER VARYING(25),
    staff_picture  BLOB(100K)
  ); 
A distinct type does not behave in the same way as its source type. All integer values 
can be added to each other or any other numerical operations that can be applied to 
integers. A ‘staff_number_type’ value, however, is not an integer so none of the numeri­
cal operations applies to ‘staff_number_type’ values. If operations are to apply to ‘staff_
number_type’ values, specific functions for those operations need to be written.
The STRUCTURED type
A structured type is another user-defined type that provides capabilities that support 
an object-oriented approach for databases that use SQL. A structured type is defined as 
having a number of components, referred to as attributes, and a number of methods, 
which are a special kind of function for processing values of the structured type. These 
include the provision of access to the values of the attributes. 
A structured type is created using a statement such as:
CREATE TYPE postal_address AS 
  ( 
    name_or_number   CHARACTER VARYING(30),
    road_or_street   CHARACTER VARYING(30),
    town_or_city     CHARACTER VARYING(30)
    county           CHARACTER VARYING(30),
    postcode         CHARACTER VARYING(20)
  );
Each attribute of a structured type is defined in a similar way to a column of a table, with 
a name and a type. This type may be a predefined data type, a distinct type or a different 
structured type. Once created, a structured type can be used in the same places that 
any data type can be used.
A structured type value is not an object (in the object-oriented sense) but has some 
similar characteristics. When a structured type is created, a function to create a new 
value of the type is also created as are methods to access (the observer method) and 
change (the mutator method) the values of each of the attributes. Other methods can 
also be created. For example, we could create a method, called ‘string_address’, to print 
an address in the form of a single character string with the parts of the address sepa­
rated by a comma and a space. This method would be added to the structured type with 
the statement:
146

ADVANCES IN SQL (OR WHY BUSINESS ANALYSTS SHOULD NOT BE IN THE WEEDS) 
ALTER TYPE postal_address 
  ADD METHOD string_address() 
  RETURNS CHARACTER VARYING(150); 
The method can then be created with the statement:
CREATE METHOD string_address() FOR postal_address 
  RETURN 
    SELF.name_or_number()
    || ’, ’
    || SELF.road_or_street()
    || ’, ’
    || SELF.town_or_city()
    || ’, ’
    || SELF.county()
    || ’, ’
    || SELF.postcode(); 
In this method, the variable SELF is used to specify the instance of postal_address for 
which the method is invoked. The symbol ‘||’ is the SQL symbol for concatenation.
A structured type can now be used as the data type for a column, such as in:
CREATE TABLE employee
  (
    staff_number   staff_number_type,
    name           CHARACTER VARYING(25),
    residence      postal_address,
    staff_picture  BLOB(100K)
  ); 
A structured type can have subtypes, which provide similar capabilities to object sub­
classes. Specifically, these are:
yy inheritance, whereby a subtype has all the attributes and methods of its 
immediate supertype;
yy overriding, whereby the body of an inherited method can be replaced by one 
defined for the subtype;
yy extension, whereby a subtype can have additional attributes and methods. 
Let us assume that we are in a global organisation and we want to maintain addresses 
in different countries.
CREATE TYPE international_postal_address 
  UNDER postal_address AS 
  ( 
    country          CHARACTER VARYING(30)
  ) 
  OVERRIDING METHOD string_address() 
    RETURNS CHARACTER VARYING(150) ;
147

MODELLING BUSINESS INFORMATION
The keyword UNDER specifies that is a subtype. This subtype has one additional attrib­
ute, ‘country’ (all other attributes being inherited) and the method ‘string_address’ is 
overridden for instances of this subtype.
The method for this subtype is created as follows:
CREATE METHOD string_address() FOR international_postal_address 
  RETURN 
    (SELF AS postal_address).string_address
    || ’,’
    || SELF.country();
SQL tables can also be created from structured types. Since structured types can have 
subtypes, we can use the subtypes to create sub-tables. This provides automatic facili­
ties for implementing generalisation and specialisation hierarchies.
The MULTISET type
A multiset is an unordered collection of elements all of the same data type, such as a 
collection of telephone numbers. So, for example, we can have a ‘telephone_numbers’ 
column for our ‘employee’ table, as follows:
CREATE TABLE employee
  (
    staff_number        staff_number_type,
    name                CHARACTER VARYING(25),
    residence           postal_address,
    telephone_numbers   CHARACTER VARYING(15) MULTISET,
    staff_picture       BLOB(100K)
  ); 
Alternatively, we can create a distinct type for a telephone number:
CREATE TYPE telephone_number_type AS CHARACTER VARYING(15); 
This can then be used in the column declaration:
CREATE TABLE employee
  (
    staff_number        staff_number_type,
    name                CHARACTER VARYING(25),
    residence           postal_address,
    telephone_numbers   telephone_number_type MULTISET,
    staff_picture       BLOB(100K)
  );
148

ADVANCES IN SQL (OR WHY BUSINESS ANALYSTS SHOULD NOT BE IN THE WEEDS) 
The VARIABLE ARRAY type
A variable array is a one-dimensional array that consists of an ordered collection of 
elements all of the same data type, with the maximum number of elements specified in 
the type declaration. Because a multiset is an unordered collection, with our multiset of 
telephone numbers we could not determine which of the telephone numbers assigned 
to an employee is their home telephone number or their mobile telephone number, 
for instance. Using a variable array overcomes this problem: we can say that the first 
element in the array is their home telephone number, the second element their mobile 
telephone number, and the third element an alternative telephone number.
Reusing the distinct type, the create table statement now becomes:
CREATE TABLE employee
  (
    staff_number        staff_number_type,
    name                CHARACTER VARYING(25),
    residence           postal_address,
    telephone_numbers   telephone_number_type ARRAY[5],
    staff_picture       BLOB(100K)
  );
This declaration allows a maximum of five telephone numbers to be held for each 
employee. If the employee does not have a home telephone number the first element 
of the array is null.
The ROW type
A row is a collection of fields, each defined with a name and a data type. The fields can 
be of different data types, for example:
ROW ( telephone_number_category  CHARACTER VARYING(10),
      telephone_number           telephone_number_type )
Each row value will hold a single telephone number with the ‘category’ of the phone 
number: ‘Home’, ‘Mobile’, and so on.
If we want to hold multiple phone numbers in a single column, as before, we can have 
a multiset of rows:
CREATE TABLE employee
  (
    staff_number       staff_number_type,
    name               CHARACTER VARYING(25),
    residence          postal_address,
    telephone_numbers  ROW ( telephone_number_category  
                                    CHARACTER VARYING(10),
                             telephone_number           
                                    telephone_number_type ) MULTISET,
    staff_picture       BLOB(100K)
  );
149

MODELLING BUSINESS INFORMATION
Each ‘value’ in the telephone numbers column is, in effect, a mini-table.
The DATALINK type
A data link allows large, multimedia files, such as an image file, a voice recording, a 
video recording or a text file, to be stored external to the database. The data stored in 
the relevant column is purely a pointer, in the form of a uniform resource locator (URL), 
to the externally stored multimedia file.
One advantage of this is that the multimedia data may be held remotely from the data­
base server, perhaps close to where the data is used to reduce the overall network 
traffic. A data link column may be declared with special properties that, in association 
with some additional software, allow there to be some control of the external multime­
dia file. One property ensures that the multimedia file cannot be renamed or deleted; 
another property denies access to the multimedia file other than as a result of querying 
the database; and a third property ensures that if the data link reference is deleted from 
the database an appropriate action is carried out, either the multimedia file is deleted 
or control is passed back to the normal file management system. 
For example, if we wish to store our staff pictures outside the database we can use:
CREATE TABLE employee
  (
    staff_number       staff_number_type,
    name               CHARACTER VARYING(25),
    residence          postal_address,
    telephone_numbers  ROW ( telephone_number_category  
                                    CHARACTER VARYING(10),
                             telephone_number           
                                    telephone_number_type ) MULTISET,
    staff_picture       DATALINK NO LINK CONTROL
  );
Here, ‘NO LINK CONTROL’ means that the data link column only holds references to the 
picture files – those files are not under control in any way. There are other options that 
exert varying levels of control over the picture files, for example, only allowing read 
and write access through the database and controlling what happens when the link is 
deleted.
The XML type
The XML type allows an XML document to be stored, and recognised as such, as a value 
in a column. As such, the XML type is fairly limited. However, SQL also now has facili­
ties that provide for the composition of an XML document using data extracted from the 
database and, conversely, for the storage of data extracted from an XML document in 
the database. 
150

ADVANCES IN SQL (OR WHY BUSINESS ANALYSTS SHOULD NOT BE IN THE WEEDS) 
THE FUTURE
At the time of writing, ISO/IEC JTC1 SC32 WG3 are developing enhancements to the SQL 
standard that will provide facilities for:
yy the use of multidimensional arrays;
yy the handling of JavaScript Object Notation (JSON) documents;
yy the development of ‘polymorphic table functions’ to emulate some of the 
features of NoSQL databases – these functions take zero or more tables as 
input parameters and return a table as the result of the function where the 
shape of the table is not known at function creation time.
IMPLICATIONS FOR BUSINESS ANALYSTS AND INFORMATION MODELLERS
Consider that as part of a requirements elicitation workshop with a group of users from 
a human resources department you gather that what they need to know about each 
employee is as shown in Figure 13.1.
Figure 13.1 The original ‘workshop’ model
Figure 1
3.1
As a modeller, you are aware of the requirement to produce a model that is in third 
normal form where all attributes are single valued. You arrive, therefore, at the model in 
Figure 13.2, replacing the ‘qualifications’, ‘grades’ and ‘assignments’ attributes with rela­
tionships to other entity types (ignoring the fact that some of the attributes of EMPLOYEE 
are really attributes that relate to the person who is playing the role of an employee).
151

MODELLING BUSINESS INFORMATION
Figure 13.2 The third normal form model
Figur
e 13.2
Now, consider that the database designer, familiar with the latest developments within 
the SQL standard, produces the following statement to create the employee table: 
CREATE TABLE employee
  (
    staff_number       staff_number_type,
    name               CHARACTER VARYING(25), 
    address            postal_address,
    birth_date         DATE,
    qualifications     ROW 
                        ( qualification_title CHARACTER VARYING(50), 
                          award_date          DATE
                          expiry_date         DATE ) MULTISET,
    grades             ROW 
                        ( grade_designation   CHARACTER VARYING(50), 
                          effective_date      DATE ) MULTISET,
    assignments        ROW 
                        ( department_name     CHARACTER VARYING(20), 
                          start_date          DATE
                          end_date            DATE ) MULTISET
  );
Then the final model, this time a data model, becomes as shown in Figure 13.3, which is 
the same as the information model at the end of the requirements elicitation workshop 
as we saw in Figure 13.1.
152

ADVANCES IN SQL (OR WHY BUSINESS ANALYSTS SHOULD NOT BE IN THE WEEDS) 
Figure 13.3 The final model
Figure 1
3.3
We have, you will see, not used all of the new facilities offered by SQL, yet we have effec­
tively removed the need to worry about third normal form and single-valued attributes. 
Of course, as a business analyst you should be aware of the capabilities of the database 
management system that is to be used on your project so that you understand whether 
you need to produce a model that is in third normal form or not.
It is interesting to note that, technically, we have not broken the ‘single-valued attribute’ 
rule because each item of data in the relevant columns of the ‘employee’ table is a single 
value. It is just that the values of the ‘qualifications’, ‘grades’ and ‘assignments’ columns 
are complex values.
153

14	 TAKING A REQUIREMENTS 
INFORMATION MODEL INTO 
DATABASE DESIGN
Once the conceptual model is complete it provides the start point for the design of the 
physical database.
The conceptual model, with its entity types (or object classes), attributes and relation­
ships (or associations), does not presuppose the form of the implemented database. 
Because the model is in third normal form or higher, it is very easily translated into a 
design for a relational database managed using the SQL database language. The model 
could, however, be translated into a design for a database managed by some other form 
of database management system, such as an object-oriented database management 
system. We assume, however, that the database is to be implemented using an SQL-
based relational database management system, where the main construct at the logical 
level is the database table.
This ‘physical database design’ process has two stages: first-cut database design; fol­
lowed by optimised database design.
FIRST-CUT DATABASE DESIGN STAGE
In the first-cut database design stage, the aim is to use the conceptual constructs of the 
logical-level schema of the target database management system to develop a design 
that matches the conceptual model as closely as possible.
Each entity type or object class in the conceptual model becomes a table, with each of the 
attributes of the entity type or object class becoming a column of that table. If the foreign 
keys needed to implement the relationships or associations are not already identified as 
attributes they need to be identified and become additional columns of the table.
There should be a consistent approach to the naming of tables and columns. It should 
be possible to relate the schema design back to the conceptual model from which it is 
derived, so the names of the tables and columns should be as close to the names in 
the conceptual model as possible (within the limitations that all database management 
systems place on the lengths of names). Ideally, each table name should be identical 
to the entity type or object class name, and this is normally possible within the nam­
ing length restrictions. The table corresponding to the EMPLOYEE entity type would be 
called ‘employee’ and the table corresponding to the EMPLOYEE QUALIFICATION entity 
type would be called either ‘employee_qualification’ or ‘employeeQualification’ to cope 
with the restriction that spaces are not allowed in SQL names.
154

TAKING A REQUIREMENTS INFORMATION MODEL INTO  DATABASE DESIGN
Column names must be unique within a table, so it is possible to have, for example, 
an ‘effectiveDate’ column in both the ‘employeeGrade’ table and in the ‘employeeAs­
signment’ table, distinguishing between the two if necessary by using ‘dot notation’, for 
example, ‘employeeGrade.effectiveDate’ and ‘employee Assignment.effectiveDate’. It is 
common practice to name foreign key columns with the same name as the column that 
they correspond to in the table that is referenced by the foreign key.
Each column is defined with a data type, such as:
yy CHARACTER(10), a fixed-length string of 10 characters; 
yy CHARACTER VARYING(10), a variable-length string with a maximum length of 
10 characters; 
yy DATE, a calendar date; and 
yy DECIMAL(5,2), a number such as ‘234.56’. 
If the domain for each attribute was specified as part of the conceptual model, it is usu­
ally fairly straightforward to determine the appropriate data type. If domains have not 
been specified then it is normally necessary to review some specimen data in order to 
determine the appropriate data type.
There has to be an explicit primary key declaration for each table (naming the column or 
columns in the table whose values uniquely identify a row in the table). If required, there 
must also be explicit foreign key declarations (naming the column or columns that com­
prise each foreign key) to implement each relationship from the table to another table.
OPTIMISED DATABASE DESIGN STAGE
The first-cut design gives a database design that closely resembles the conceptual 
model. Such a design should be robust, easy to understand and meet all the informa­
tion and data requirements of the business areas being supported. However, within 
the stated requirements for any information system are a number of non-functional 
requirements that specify performance targets for the overall system, such as the 
maximum time a user must wait after submitting a request for information (a query on 
the database) before that information is available. It may be necessary for the database 
designer to enhance or move away from the first-cut design to improve the perfor­
mance of the database.
The two main strategies for improving performance of a database are to make use of 
the built-in facilities of the database management system and to compromise on the 
design of the logical schema.
Two facilities provided by most database management systems are the ability to cluster 
data and the ability to create indexes. 
Data clustering means arranging data on the disk in such a way that logically related 
data is placed as closely together as possible. This improves performance because fewer 
disk access requests are required to answer queries on the database or to update data.
155

MODELLING BUSINESS INFORMATION
An index provides the database management system with an alternative way to access 
data other than searching through all the physical records associated with a particular 
logical table. A database index is analogous to the index at the back of this book. It enables 
the database management system to know where to go to access any particular piece 
of data. An index may be built on a single column or on multiple columns from the same 
table. Using an index improves retrieval performance by reducing the number of disk 
accesses required to query the data. Database update is, however, slowed down if data 
is indexed; each database update requires updating the index (which normally requires 
some restructuring of the complete index) as well as updating the main data file. 
These changes can be made without affecting the logical schema or the application 
processes. Physical data independence is maintained and data clustering and indexing 
can, therefore, be altered once the database is in use.
On the other hand, a compromise to the design of the logical schema affects data inde­
pendence. Such a compromise is often called denormalisation. You will recall that our 
aim is to design a logical schema that is in third normal form or higher. The rationale 
for this is that it provides only one place to store any item of data, reducing data redun­
dancy and eliminating the possibility of data inconsistency (at least within that single 
database). This means, however, that data that may be logically related is dispersed 
throughout the database. Collecting this dispersed data together to answer any particu­
lar query can require a large number of disk access requests, which can in turn impact 
performance. Denormalisation can involve returning ‘repeating groups’ to their master 
table (or relation). It can also mean joining two tables that are often queried together. 
Introducing new columns to hold data that can be derived from other data already held 
elsewhere in the database can also be considered as denormalisation. An example of 
this would be the recording of the total cost of an order where the costs of the individual 
items ordered are already recorded. 
While denormalisation can improve retrieval performance, it can slow down update 
performance (data needs to be recorded in more than one place) and introduce the pos­
sibility of inconsistency (because the users or the application programs need to manage 
the duplicated updates). Denormalisation should, therefore, be avoided if possible; if 
used, all decisions to denormalise should be carefully documented.
156

APPENDICES
Appendix A, Table of Equivalences, provides a table to show the equivalence between the 
concepts used in entity relationship modelling, UML class modelling, the relational model 
of data and in database management systems that use the SQL database language.
Appendix B, Bibliography, provides a list of useful reading, some of which has been 
helpful in the preparation of this book.
Appendix C, Solutions to the Exercises, provides sample worked solutions to the exer­
cises for Chapters 2 to 6.
157

APPENDIX A:	 TABLE OF EQUIVALENCES
Table A.1 shows the equivalence between the concepts used in:
yy entity relationship modelling;
yy class modelling;
yy the relational model of data;
yy the SQL database language. 
These are not ‘exact’ equivalences, but they are an adequate guide for this book.
Table A.1 Table of equivalences 
Entity relationship 
modelling
UML class 
modelling
The relational 
model of data
The SQL database 
language
Entity type
Object class
Relation
Table
Entity (or
Entity occurrence)
Object
Tuple
Row
Attribute (or 
Attribute type)
Attribute
Attribute
Column
Domain
Domain
Domain
(No equivalent)
Supertype
Superclass
(No equivalent)
(No equivalent)
Subtype
Subclass
(No equivalent)
(No equivalent)
Relationship
Association
Primary key to 
foreign key pair
Primary key to 
foreign key pair
(No equivalent)
Aggregation
(No equivalent)
(No equivalent)
(No equivalent)
Composition
(No equivalent)
(No equivalent)
Unique identifier
(No equivalent)
Candidate key
(No equivalent)
(No equivalent)
(No equivalent)
Primary key
Primary key
(No equivalent)
(No equivalent)
Foreign key
Foreign key
(No equivalent)
Operation
(No equivalent)
(No equivalent)
158

APPENDIX B:	 BIBLIOGRAPHY
Beware – there are some notational differences in the various publications in this 
bibliography
Arlow, J. and Neustadt, I. (2005) UML 2 and the Unified Process: Practical Object-Oriented 
Analysis and Design, 2nd edition. Addison-Wesley, Upper Saddle River, NJ, USA.
Barker, R. (1990) CASE*METHOD: Entity Relationship Modelling. Addison-Wesley, 
Wokingham, UK.
Brackett, M.H. (1994) Data Sharing Using a Common Data Architecture. Wiley, New York, 
USA.
Bruce, T.A. (1991) Designing Quality Databases with IDEF1X Information Models. Dorset 
House, New York, USA.
Cadle, J., Paul, D. and Turner, P. (eds) (2014) Business Analysis Techniques 99 Essential 
Tools for Success, 2nd edition. BCS, Swindon, UK.
Cattell, R.G.C. and Barry, D.K. (eds) (2000) The Object Data Standard: ODMG 3.3. Morgan 
Kaufman, San Francisco, CA, USA.
Central Computer and Telecommunications Agency (1994) Corporate Data Modelling. 
HMSO, Norwich, UK.
Central Computer and Telecommunications Agency (2000) Business Systems 
Development with SSADM; Data Modelling. HMSO, Norwich, UK.
Checkland, P. (1981) Systems Thinking, Systems Practice. John Wiley & Sons, Chichester, 
UK.
Chen, P.P-S. (1976) The Entity–Relationship Model: Toward a Unified View of Data. ACM 
Transactions on Database Systems, 1(1), 9–36.
Codd, E.F. (1970) A Relational Model of Data for Large Shared Data Banks. 
Communications of the ACM, 13(6), 377–387.
Connelly, T.M. and Begg, C.E. (2004) Database Systems: A Practical Approach to Design, 
Implementation and Management, 4th edition. Addison Wesley, Harlow, UK.
Daoust, N. (2012) UML Requirements Modeling for Business Analysts. Technics 
Publications, Westfield, NJ, USA.
159

MODELLING BUSINESS INFORMATION
Date, C.J., Darwen, H. and Lorentzos, N.A. (2003) Temporal Data and the Relational Model. 
Morgan Kaufman, San Francisco, CA, USA.
EPISTLE (European Process Industry STEP Technical Liaison Executive) (2003) 
Developing High Quality Data Models [online], www.matthew-west.org.uk/publications/
princ03.pdf, accessed 23 June 2017.
Genero, M.F. and Piattini, M.G. (2002) Conceptual model quality. In Piattini, M.G., Calero, 
C. and Genero, M.F. (eds), Information and Database Quality, pp. 16–44. Kluwer Academic 
Publishers, Boston, MA, USA.
Gordon, K. (2013) Principles of Data Management: Facilitating Information Sharing, 2nd 
edition. BCS, Swindon, UK.
Halpin, T. and Morgan, T. (2008) Information Modeling and Relational Databases. Morgan 
Kaufman, San Francisco, CA, USA.
Hay, D.C. (1996) Data Model Patterns: Conventions of Thought. Dorset House, New York, 
USA.
Hay, D.C. (2003) Requirements Analysis: From Business Views to Architecture. Prentice 
Hall, Upper Saddle River, NJ, USA.
Hay, D.C. (2011a) Enterprise Model Patterns: The UML Version. Technics Publications, 
Westfield, NJ, USA.
Hay, D.C. (2011b) UML and Data Modelling: A Reconciliation. Technics Publications, 
Westfield, NJ, USA.
ISO/IEC 2382-1 (1993) Information Technology – Vocabulary – Part 1: Fundamental terms.
ISO/IEC 9075 (2011) Information Technology – Database languages – SQL.
ISO/IEC (2015) ISO/IEC JTC 1 Information Technology, Big Data: Preliminary Report 2014.
Jackson, M.C. (2003) Systems Thinking: Creative Holism for Managers, John Wiley & Sons, 
Chichester, UK. 
Melton, J. (2003) Advanced SQL:1999: Understanding Object-Relational and Other 
Advanced Features. Morgan Kaufman, San Francisco, CA, USA.
Melton, J. and Simon, A.R. (2002) SQL:1999: Understanding Relational Language 
Components. Morgan Kaufman, San Francisco, CA, USA.
Paul, D., Cadle, J., and Yeates, D. (eds) (2014) Business Analysis, 3rd edition. BCS, 
Swindon, UK.
Reingruber, M. and Gregory, W.W. (1994) The Data Modeling Handbook: A Best-Practice 
Approach to Building Quality Data Models. Wiley-QED, New York, USA.
160

APPENDIX B – BIBLIOGRAPHY
Rumbaugh, J. Jacobson, I. and Booch, G. (1994) The Unified Modeling Language Reference 
Manual, 2nd edition. Addison Wesley, Reading, MA, USA.
Simsion, G. (2007) Data Modeling: Theory and Practice. Technics Publications, Westfield, 
NJ, USA.
Simsion, G. and Witt, G. (2004) Data Modeling Essentials, 3rd edition. Morgan Kaufman, 
San Francisco, CA, USA.
West, M. (2011) Developing High Quality Data Models. Morgan Kaufman, San Francisco, 
CA, USA.
161

APPENDIX C:	 SOLUTIONS TO THE 
EXERCISES
Chapter 2
2.1	 Each DEPARTMENT may be responsible for one or more PROJECTS 
Each PROJECT must be responsibility of one and only one DEPARTMENT
2.2	 	
Figure
2.3	 	
Figu
re
2.4a	 	
Figu
re
162

APPENDIX C – SOLUTIONS TO THE EXERCISES
2.4b	
Figu
re
2.4c	 There are two alternative answers for this exercise: one where we view processes, 
tasks and steps as being separate categories of ‘things of interest’ represented by 
separate entity types or object classes; and one where we see all of these ‘processes’ 
as a single category of ‘things of interest’.
	
Processes, tasks and steps seen as being separate categories of ‘things of interest’:
Figure
	
Processes, tasks and steps seen as being a single category of ‘things of interest’ – 
a process:
Figure
163

MODELLING BUSINESS INFORMATION
Chapter 3
3.1	 	
Figure
3.2	 	
Figu
re
3.3	 	
Figure
3.4a	
Figure
164

APPENDIX C – SOLUTIONS TO THE EXERCISES
3.4b	 	
Figur
e
3.4c	 	
Figure
165

MODELLING BUSINESS INFORMATION
3.4d	 	
Figure
3.5	 Assuming that there is no significant difference between an order received from an 
external organisation and an order from a branch of the business: 
Figure
166

APPENDIX C – SOLUTIONS TO THE EXERCISES
	
Assuming that there is a significant difference between an order received from an 
external organisation and an order from a branch of the business:
Figur
e
	
Assuming that there is a significant difference between an order received from an 
external organisation and an order from a branch of the business, but there are some 
common characteristics of external organisations and business branches so that both 
can be seen as ‘parties’: 
Figur
e
	
The same assumptions as above, but this would be an inappropriate model because it 
will allow an external order to be placed by a branch and a branch order to be placed 
by an external organisation: 
Figur
e
167

MODELLING BUSINESS INFORMATION
Chapter 4
4.1	
Fig
ure
168

APPENDIX C – SOLUTIONS TO THE EXERCISES
4.2a
Figure
4.2b
F
i
g
u
re
169

MODELLING BUSINESS INFORMATION
Chapter 5
5.1	
Figure
5.2	 	
Figu
re
170

APPENDIX C – SOLUTIONS TO THE EXERCISES
Chapter 6
6.1	 Using a normalisation form:
Figure
6.2	
Figure
171

INDEX
Page numbers in italics refer to figures or diagrams
1NF (first normal form) xix, 84, 
86–9
2NF (second normal form) xxi, 
84, 89–90
3NF (third normal form) xxii, 84, 
90–4
aggregation xvii, 46–8, 136
alternate keys xvii, 94
artefacts xvii
‘as-is’ models 14
association classes xvii, 35–6
associations
introduction to xvii, 19
identifying 53
multiple 27–8
mutually exclusive 39–41
naming 22–3, 112–13
notation 22–3
reflexive 29
associative entity types 34, 38
attribute occurrences 66–7
attribute types 66–7
attributes
introduction to xvii, 66–9
naming 69, 110–11
UML extended attribute 
notation 75–7
when to model concepts as 
69–71
Bachman Diagrams 11
Barker, Richard 11, 100
bibliography 159–61
big data xvii, 129–30
bill of materials structure. 36–9
binary large object data type 145
Booch, Grady 12
‘boxes within boxes’ depictions 
41, 43
Boyce-Codd normal form 84
business activity models 8
business analysis
and data analysis 14–15
definitions 3–5
information needs 6–7
role of models 7–10
use of models 13
business intelligence
data warehouses 139–40
dimensional modelling 141–3
multidimensional data models 
140–1
business process models 8
business rules enforcement 117
business systems 4–5
candidate keys xvii, 95
cardinality
overview xvii, 24–7
in model drawing 54–6
problems with 32–9
CASE
see computer-aided software 
engineering (CASE)
character large object data type 
145
Checkland, Peter 7–8
Chen notation xvii, 104, 106
class models xviii, 12–13, 22–3
class terms 111
Codd, Edgar F. 81, 84
columns xviii, 82, 154–5
communication 9–10, 117–18
completeness 116, 120–1
composite identifiers xviii, 73–4
composite keys xviii
composition xviii, 46–8
computer-aided software 
engineering (CASE) xvii
Computer-Independent Models 
(CIM) 10–11, 13, 19
conceptual data models xviii, 
154–5
constraints 40–1, 77
corporate models xviii, 123–6
correctness 120–1
CRUD matrix validation 59–62
data
big data 129–30
and data models 10–11
definition xviii
and information 5–6
master data 130
metadata 130
semi-structured data 129
structured data 127–9
types xviii, 145–51
unstructured data 129
data analysis xviii, 14–15
data clustering 155–6
data landscape 127–30
data mining xviii
data models
and data 10–11
definitions xviii
requirements of 13–14
third normal form (3NF or 
TNF) 94
what is a good model? 13–14
172

data navigation paths 57–9
data reusability 117
data types
binary large object type 145
character large object type 
145
datalink type 150
definition xviii
distinct type 145–6
multiset type 148
row type 149
structured type 146–8
variable array type 149
XML type 150–1
future developments 150–1
data warehouses xviii, 139–40
database design
first cut stage 154–5
optimised design stage 
155–6
role of models 10–11
database management system 
(DBMS) xix
databases
chronology 131
definitions xix
hierarchical 130–3
network 133, 134–5
NoSQL 137–8
object-oriented 136–7
relational (SQL) 133–6
datalink data type 150
DBMS (database management 
system) xix
denormalisation 156
derived attributes 77
described domains xix, 75
diagrams
drawing 54–6
validating 56–62
dimensional modelling 141–3
distinct data type 145–6
document stores 138
domains xix, 74–5, 110
drawing models
see model drawing
elegance 117
Ellis, Harry 11, 99
Ellis-Barker notation xix, 11–12, 
99–100
employee supervision 38–9
encapsulation 136
enquiry access path
see data navigation paths
enterprise awareness dimension 
120–1
entities xix, 16–18
entity occurrences xix, 17–18
entity relationship modelling xix, 
11–12, 20–2
entity subtypes xix, 41–3, 109
entity types
overview xix, 17–18, 65–6
or attributes? 69–72
identifying 51–2
naming 18–19, 108–10
subtypes xix, 41–3, 109
supertypes 41–3
enumerated data types 77
enumerated domains xix, 75
equivalences, table of 158
European Process Industry 
STEP21 Technical Liaison 
Executive (EPISTLE) 118–20
exclusive arcs 40
exclusive-or constraint 40–1
exercises
end of chapter 30–1, 48–9, 
63–4, 79–80, 96
solutions to 162–71
extensible record stores 138
final models 153
first cut database design stage 
154–5
first normal form (1NF or FNF) 
xix, 84, 86–9
flexibility 117
flexible design 119–20
foreign keys xix, 82, 89
full attribute names 111
galaxy schema 143
generalisation 43–5
generic data models 114–15, 
119–20
genericity 114–16
graph databases 138
Gregory, William 120–1
hierarchic identifiers xx, 74
hierarchic keys xx
hierarchical databases 130–3
IDEF1X notation xx, 100–4
indexes 156
information xx, 4–6
Information Engineering notation 
xx, 104, 105
information needs 6–7, 9–10, 
13–14
information systems 4–5
information technology systems 
4
inheritance 136
input parameters 78
integration 118
IT systems 4
Jacobson, Ivar 12
key-value stores 138
layout of models, quality of 
models 121–2
link entities 34
Logical Data Model (LDM) 11, 94
lower bounds 23
mandatory relationships/
associations
see optionality
many-to-many associations/
relationships 27, 32–7
see also cardinality
many-to-one relationships
see cardinality
master data 130
master data management xx
matrix organisation 38–9
metadata xx, 130
model drawing
process of 50–1
identifying entity types or 
object classes 51–2
identifying relationships or 
associations 53
drawing the initial diagram 
54–6
validating the diagram 56–62
models
in business analysis 7, 13
communication through 9–10
modifier terms 111
multidimensional data models 
140–1
multimedia data xx
173

multiple associations/
relationships 27–8
multiplicity xx, 23, 68–9
multiset data type 148
mutually exclusive associations/
relationships 39–41
naming
associations 22–3, 112–13
associative entity types 38
attributes 110–11
conventions 108–13
domains 110
entity types 108–10
object classes 38, 108–10
of object classes and entity 
types 18–19
relationships 20–2, 112
tables and columns 154–5
network databases 133, 134–5
non-redundancy 116
normal form xx
normalisation
what is it? xx, 81–2
relational model of data 
82–4
rules of 84
start of process 85–6
first normal form (1NF or FNF) 
86–9
second normal form (2NF or 
SNF) 89–90
third normal form (3NF or 
TNF) 90–4
third normal form data model 
94
relationship to modelling 95
alternate, candidate and 
primary keys 94
normalisation forms 86, 87–8, 
91, 93
NoSQL databases 137–8
notations
Chen xvii, 104, 106
comparison between 107
Ellis-Barker xix, 11–12, 99–100
IDEF1X xx, 100–4
Information Engineering xx, 
104, 105
need for clarity 10
relationships 20–2
UML class model notation 
12–13, 22–3, 75–9, 101
object classes
overview xx, 17–18, 65–6
or attributes? 69–72
identifying 51–2
naming 18–19, 38, 108–10
Object Data Management Group 
(ODMG) xxi, 137
Object Definition Language (ODL) 
137
Object Query Language (OQL) 137
object subclasses xxi, 43–5, 109
objectives, conflicting 118
object-orientation xx
object-oriented databases 
136–7
objects
behaviour of 77–8
definition xx
and entities 16–18
in UML 77
one-to-many associations/
relationships
see cardinality
one-to-one associations/
relationships
see cardinality
online analytical processing xxi, 
141
online transactional processing 
(OLTP) xxi
operations xxi, 77–9
optimised database design stage 
155–6
optionality xxi, 24–7, 54–6
optional-mandatory relationships 
26, 26
optional–optional relationships 
27, 27
partial high-level process maps 
60
permitted values xxi, 75
Physical Data Model (PDM) 11
‘pig’s ear’ associations/
relationships 29
Platform-Independent Model 
(PIM)
see Logical Data Model (LDM)
Platform-Specific Model (PSM) 
11
polymorphism 136
primary keys xxi, 82, 94
prime terms 111
primitive data types 77
product dimensions 140–1
products within products 36–7
quality of models
characteristics of good data 
models 116–18
five dimensions of data model 
quality 120–1
genericity or specificity 
114–16
layout of models 121–2
principles of high quality data 
models 118–20
query access path
see data navigation paths
recursive relationships 29, 109
reflexive associations 29, 109
Reingruber, Michael 120–1
relational (SQL) databases 
133–6
relational data analysis xxi, 14, 
15, 84
relational data analysis process 
56
relational database management 
system (RDBMS) xxi
relational model of data xxi, 
82–4
relations xxi, 81, 82–4
relationships
overview xxi, 65–6
identifying 53
introduction to 19
multiple 27–8
mutually exclusive 39–41
naming 20–2, 112
notation 20–2
recursive 29
repeating groups 86
representation terms 111
requirements engineering 
9–10, 9
reverse-engineering 14
rich picture 7
role names 23
row data type 149
Rumbaugh, James 12
schema xxi, 141–3
second normal form (2NF or 
SNF) xxi, 84, 89–90
semantic dimension 120–1
174

semi-structured data 129
simple identifiers xxii, 73
simple keys xxii
Simsion, Graeme 116–18
single valued attributes 68
SNF (second normal form) xxi, 
84, 89–90
snowflake schema 143
Soft Systems Methodology 7–8
solutions to exercises 162–71
specialisation
in class models 43–5
in entity relationship models 
41–3
specificity, quality of models 
114–16
SQL
basics xxii, 144–5
implications 151–3
new data types 145–51
SQL (relational) databases 
133–6
stability 117
standards
overview 6–7
ISO/IEC 2382-1 1993 
(Information Technology 
– Vocabulary – Part 1: 
Fundamental Terms) 6–7
ISO/IEC 9075 (SQL) 144, 151
Unified Modeling Language 
(UML) 12–13
star schema 141–2
storage 137
store dimensions 140–1
structured data xxii, 77, 127–9, 
146–8
subclasses xxi, 43–5, 109
subtypes 41–3, 109
superclasses 43–5
supertypes 41–3
surrogate identifiers xxii, 74
syntactic dimension 120–1
systems 3–5
tables xxii, 82–4, 154–5
third normal form (3NF or TNF) 
xxii, 84, 90–4
third normal form data model 
94, 152
time dimensions 140–1
‘to-be’ models 14
top-down approaches 15
transitive dependence 92
tuples xxii, 82–4
UML class model notation 12–13, 
22–3, 75–9, 101
Unified Modeling Language (UML) 
xxii, 12–13
unique identifiers xxii, 72–4
un-normalised form (UNF) 86
unstructured data xxii, 129
upper bounds 23
use case diagrams 9
validation xxii, 56–62
value 129
values (attribute occurrences) 
66–7
variability 129
variable array data type 149
variety 129
velocity 129
veracity 129
volume 129
West, Matthew 118–20
whole–part relationships 46
wide-column stores 138
Witt, Graham 116–18
workshop models 151
XML data type 150–1
{xor} constraints 40–1
175


